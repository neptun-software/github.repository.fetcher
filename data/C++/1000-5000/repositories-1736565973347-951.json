{
  "metadata": {
    "timestamp": 1736565973347,
    "page": 951,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dresden-elektronik/deconz-rest-plugin",
      "stars": 1908,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1650390625,
          "content": "Makefile\nMakefile.Debug\nMakefile.Release\nrelease\nui_de_web_widget.h\n.qmake.stash\ntests/build\n*.txt.user\nui_ddf_editor.h\nui_device_widget.h\n.vscode\n.devcontainer\nbuild*\n\n"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 3.4736328125,
          "content": "# Building\n\n## Supported platforms\n* Raspbian / Debian ~~Jessie~~, ~~Stretch~~, Buster, Bullseye and Bookworm\n* Ubuntu ~~Xenial~~, Bionic, Focal Fossa and Jammy\n* Windows 7, 10, 11\n\nThere are two ways to build the plugin:\n1. [CMake](#build-with-cmake)\n2. [QMake (deprecated)](#build-with-qmake)\n\n## Build with CMake\n\nCMake is the new build system to compile the REST-API plugin. The former `deconz-dev` package isn't needed anymore since the headers and sources of the deCONZ library are pulled from https://github.com/dresden-elektronik/deconz-lib automatically.\n\n### Linux\n\nOn Debian Buster the following development packages need to be installed.\n\n**Note:** On newer Ubuntu versions `qt5-default` isn't available, replace it with `qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools` instead.\n\n```\napt-get update && \\\napt-get install --no-install-recommends -y \\\nqt5-default \\\nlsb-release ca-certificates build-essential pkg-config git \\\nlibqt5serialport5-dev  libqt5websockets5-dev qtdeclarative5-dev  \\\nsqlite3 libsqlite3-dev libgpiod-dev libssl-dev curl cmake ninja-build\n```\n\n1. Checkout the repository\n\n        git clone https://github.com/dresden-elektronik/deconz-rest-plugin.git\n\n2. Compile the plugin\n\n        cmake -DCMAKE_INSTALL_PREFIX=/usr -G Ninja -B build\n        cmake --build build\n   \n3. Install in local temporary directory\n   (This step changes the RPATH so the plugin can find the official `/usr/lib/libdeCONZ.so` library.)\n\n        cmake --install build --prefix tmp\n\nThe compiled plugin is located at: `tmp/share/deCONZ/plugins/libde_rest_plugin.so`\n\n--------\n\n### Windows\n\nMSYS2 MINGW32 needs to be installed, it can be downloaded from https://msys2.org \n\n\nIn MSYS2 MINGW32 shell the following packages need to be installed:\n\n```\npacman -Sy mingw-w64-i686-qt5 mingw-w64-i686-openssl mingw-w64-i686-sqlite3\n```\n\n1. Checkout this repository\n\n        git clone https://github.com/dresden-elektronik/deconz-rest-plugin.git\n\n2. Open MSYS2 MINGW32 shell via Windows Start Menu\n\n3. Navigate to the source directory\n\n        cd /c/src/deconz-rest-plugin\n\n3. Compile the plugin with CMake\n\n\n        cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/mingw32/lib/cmake -B build\n        cmake --build build\n\nAfter compilation the plugin can be found in the build directory: `de_rest_plugin.dll`\n\n-----------\n\n### macOS\n\nCurrently only supported on Intel Macs (x86_64).\n\nInstall dependencies via Homebrew.\n\n```\nbrew install qt@5 ninja cmake\n```\n\n1. Checkout this repository\n\n        git clone https://github.com/dresden-elektronik/deconz-rest-plugin.git\n\n3. Navigate to the source directory\n\n        cd deconz-rest-plugin\n\n4. Compile the plugin with CMake\n\n        ./build-macos.sh\n\nAfter compilation the plugin can be found in the build directory: `de_rest_plugin.dylib`\n\n5. Copy the plugin to the app bundle\n\n        cp build/de_rest_plugin.dylib /Applications/deCONZ.app/Contents/Plugins\n\n## Build with QMake\n\n**Important:** Building via  QMake is deprecated and will be removed in future.\n\nThis method is only supported on Linux.\n\n### Install deCONZ development package\n\n    sudo apt install deconz-dev\n\n### Get and compile the plugin\n\n1. Checkout the repository\n\n        git clone https://github.com/dresden-elektronik/deconz-rest-plugin.git\n\n2. Checkout the latest version\n\n        cd deconz-rest-plugin\n        git checkout -b mybranch HEAD\n\n3. Compile the plugin\n\n        qmake && make -j2\n\n**Note** On Raspberry Pi 1 use `qmake && make`\n\n4. Replace original plugin\n\n        sudo cp ../libde_rest_plugin.so /usr/share/deCONZ/plugins\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 8.7841796875,
          "content": "cmake_minimum_required(VERSION 3.13)\n\nproject(de_rest_plugin VERSION 2.29.01 LANGUAGES C;CXX)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\nset(CMAKE_AUTOUIC ON)\nset(CMAKE_AUTOMOC ON)\nset(CMAKE_AUTORCC ON)\n\nset(CMAKE_CXX_STANDARD 14)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(Qt5 COMPONENTS Core Widgets Network WebSockets REQUIRED)\nfind_package(Git REQUIRED)\n\nif (UNIX)\n    include(FindPkgConfig)\n    pkg_check_modules (OPENSSL openssl)\nelse()\n    find_package(OpenSSL REQUIRED)\nendif()\n\nif (NOT DECONZ_FULL_BUILD)\n    # standalone build\n    add_subdirectory(sqlite3)\n\n#--- deCONZ library ---------------------------------------------------\n\ninclude(FetchContent)\n\nFetchContent_Declare(\n  deconzlib\n  GIT_REPOSITORY https://github.com/dresden-elektronik/deconz-lib.git\n  GIT_TAG        main\n)\n# FetchContent_MakeAvailable(deconzlib)\n# FetchContent_MakeAvailable requires CMake 3.14, but Debian Buster has only 3.13\nFetchContent_GetProperties(deconzlib)\nif (NOT deconzlib_POPULATED)\n    FetchContent_Populate(deconzlib)\n    add_subdirectory(${deconzlib_SOURCE_DIR} ${deconzlib_BINARY_DIR})\nendif()\n\nendif()\n\n#----------------------------------------------------------------------\n\nset(PLUGIN_INCLUDE_FILES\n    air_quality.h\n    alarm_system.h\n    alarm_system_device_table.h\n    alarm_system_event_handler.h\n    aps_controller_wrapper.h\n    backup.h\n    bindings.h\n    button_maps.h\n    colorspace.h\n    crypto/mmohash.h\n    crypto/password.h\n    crypto/random.h\n    crypto/scrypt.h\n    database.h\n    daylight.h\n    de_web_plugin.h\n    de_web_plugin_private.h\n    de_web_widget.h\n    device.h\n    device_access_fn.h\n    device_compat.h\n    device_ddf_bundle.h\n    device_ddf_init.h\n    device_descriptions.h\n    device_tick.h\n    device_js/device_js.h\n    event.h\n    event_emitter.h\n    fan_control.h\n    gateway.h\n    gateway_scanner.h\n    green_power.h\n    group.h\n    group_info.h\n    ias_ace.h\n    ias_zone.h\n    json.h\n    light_node.h\n    poll_control.h\n    poll_manager.h\n    product_match.h\n    read_files.h\n    resource.h\n    resourcelinks.h\n    rest_alarmsystems.h\n    rest_api.h\n    rest_ddf.h\n    rest_devices.h\n    rest_node_base.h\n    rule.h\n    scene.h\n    sensor.h\n    simple_metering.h\n    state_change.h\n    thermostat.h\n    thermostat_ui_configuration.h\n    tuya.h\n    ui/ddf_bindingeditor.h\n    ui/ddf_editor.h\n    ui/ddf_itemeditor.h\n    ui/ddf_itemlist.h\n    ui/ddf_treeview.h\n    ui/device_widget.h\n    ui/text_lineedit.h\n    utils/ArduinoJson.h\n    utils/ArduinoJson-v6.19.4.h\n    utils/bufstring.h\n    utils/scratchmem.h\n    utils/stringcache.h\n    utils/utils.h\n    websocket_server.h\n    xiaomi.h\n    zcl/zcl.h\n    zdp/zdp.h\n    zdp/zdp_handlers.h\n    )\n\nadd_library(${PROJECT_NAME} SHARED\n    ${PLUGIN_INCLUDE_FILES}\n\n    de_web_widget.ui\n    ui/ddf_editor.ui\n    ui/device_widget.ui\n\n    air_quality.cpp\n    alarm_system.cpp\n    alarm_system_device_table.cpp\n    alarm_system_event_handler.cpp\n    appliances.cpp\n    aps_controller_wrapper.cpp\n    authorisation.cpp\n    backup.cpp\n    basic.cpp\n    bindings.cpp\n    button_maps.cpp\n    change_channel.cpp\n    colorspace.cpp\n    crypto/mmohash.cpp\n    crypto/password.cpp\n    crypto/random.cpp\n    crypto/scrypt.cpp\n    cj/cj_all.c\n    database.cpp\n    daylight.cpp\n    de_otau.cpp\n    device_access_fn.cpp\n    device_compat.cpp\n    device.cpp\n    device_ddf_bundle.cpp\n    device_ddf_init.cpp\n    device_descriptions.cpp\n    device_js/duktape.c\n    device_js/device_js_duktape.cpp\n    device_tick.cpp\n    de_web_plugin.cpp\n    de_web_widget.cpp\n    discovery.cpp\n    electrical_measurement.cpp\n    event.cpp\n    event_emitter.cpp\n    event_queue.cpp\n    fan_control.cpp\n    firmware_update.cpp\n    gateway.cpp\n    gateway_scanner.cpp\n    green_power.cpp\n    group.cpp\n    group_info.cpp\n    gw_uuid.cpp\n    hue.cpp\n    ias_ace.cpp\n    ias_zone.cpp\n    identify.cpp\n    json.cpp\n    light_node.cpp\n    occupancy_sensing.cpp\n    permitJoin.cpp\n    poll_control.cpp\n    poll_manager.cpp\n    power_configuration.cpp\n    product_match.cpp\n    read_files.cpp\n    reset_device.cpp\n    resource.cpp\n    resourcelinks.cpp\n    rest_alarmsystems.cpp\n    rest_api.cpp\n    rest_capabilities.cpp\n    rest_configuration.cpp\n    rest_ddf.cpp\n    rest_devices.cpp\n    rest_gateways.cpp\n    rest_groups.cpp\n    rest_info.cpp\n    rest_lights.cpp\n    rest_node_base.cpp\n    rest_resourcelinks.cpp\n    rest_rules.cpp\n    rest_scenes.cpp\n    rest_schedules.cpp\n    rest_sensors.cpp\n    rest_touchlink.cpp\n    rest_userparameter.cpp\n    rule.cpp\n    scene.cpp\n    sensor.cpp\n    simple_metering.cpp\n    state_change.cpp\n    thermostat.cpp\n    thermostat_ui_configuration.cpp\n    time.cpp\n    tuya.cpp\n    ui/ddf_bindingeditor.cpp\n    ui/ddf_editor.cpp\n    ui/ddf_itemeditor.cpp\n    ui/ddf_itemlist.cpp\n    ui/ddf_treeview.cpp\n    ui/device_widget.cpp\n    ui/text_lineedit.cpp\n    upnp.cpp\n    utils/bufstring.cpp\n    utils/scratchmem.cpp\n    utils/stringcache.cpp\n    utils/utils.cpp\n    websocket_server.cpp\n    window_covering.cpp\n    xiaomi.cpp\n    xmas.cpp\n    zcl_tasks.cpp\n    zcl/zcl.cpp\n    zdp/zdp.cpp\n    zdp/zdp_handlers.cpp\n    )\n\nif (Git_FOUND)\n    execute_process(\n        COMMAND ${GIT_EXECUTABLE} log -1 --format=%at\n        WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}\n        OUTPUT_VARIABLE GIT_DATE\n        OUTPUT_STRIP_TRAILING_WHITESPACE\n    )\n    execute_process(\n        COMMAND ${GIT_EXECUTABLE} rev-list HEAD --max-count=1\n        WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}\n        OUTPUT_VARIABLE SRC_GIT_COMMIT\n        OUTPUT_STRIP_TRAILING_WHITESPACE\n    )\nendif()\n\ntarget_compile_definitions(${PROJECT_NAME}\n    PRIVATE\n    USE_WEBSOCKETS=1\n    USE_DUKTAPE_JS_ENGINE=1\n    USE_ULIB_SHARED=1\n\n    GW_SW_VERSION=\"\\\"\\\"${PROJECT_VERSION}\\\"\\\"\"\n    GW_SW_DATE=${GIT_DATE}\n    GW_API_VERSION=\"\\\"\\\"1.16.0\\\"\\\"\"\n    GIT_COMMMIT=\"\\\"\\\"${SRC_GIT_COMMIT}\\\"\\\"\"\n\n    # Minimum version of the RaspBee firmware\n    # which shall be used in order to support all features for this software release (case sensitive)\n    GW_AUTO_UPDATE_AVR_FW_VERSION=0x260b0500\n    GW_AUTO_UPDATE_R21_FW_VERSION=0x26420700\n    GW_MIN_AVR_FW_VERSION=0x26400500\n    GW_MIN_R21_FW_VERSION=0x26720700\n\n    # Minimum version of the deRFusb23E0X firmware\n    # which shall be used in order to support all features for this software release\n    GW_MIN_DERFUSB23E0X_FW_VERSION=0x22030300\n    GW_DEFAULT_NAME=\"\\\"\\\"Phoscon-GW\\\"\\\"\"\n)\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE cj)\n\nif (OPENSSL_FOUND)\n    target_compile_definitions(${PROJECT_NAME} PRIVATE HAS_OPENSSL=1)\n    if (APPLE)\n        target_include_directories(${PROJECT_NAME} PRIVATE ${OPENSSL_INCLUDE_DIRS})\n    else()\n        target_include_directories(${PROJECT_NAME} PRIVATE ${OPENSSL_INCLUDE_DIR})\n    endif()\nendif()\n\nif (Qt5Core_VERSION_STRING VERSION_LESS \"5.15.0\")\n    target_compile_definitions(${PROJECT_NAME} PRIVATE SKIP_EMPTY_PARTS=QString::SkipEmptyParts )\nelse()\n    target_compile_definitions(${PROJECT_NAME} PRIVATE SKIP_EMPTY_PARTS=Qt::SkipEmptyParts )\nendif()\n\ntarget_link_libraries(${PROJECT_NAME}\n    PRIVATE Qt5::Core\n    PRIVATE Qt5::Gui\n    PRIVATE Qt5::Widgets\n    PRIVATE Qt5::Network\n    PRIVATE Qt5::WebSockets\n    PRIVATE SQLite::SQLite3\n    PRIVATE deCONZLib\n)\n\n#--------------------------------------------------------------\ninclude(GNUInstallDirs)\n\nif (UNIX)\n    if (APPLE)\n        set_target_properties(${PROJECT_NAME} PROPERTIES\n            INSTALL_RPATH @loader_path)\n    else()\n        set_target_properties(${PROJECT_NAME} PROPERTIES\n            INSTALL_RPATH \"${CMAKE_INSTALL_FULL_LIBDIR}\")\n    endif()\nendif()\n\n\nif (${CMAKE_HOST_SYSTEM_NAME} MATCHES \"Linux\")\n    install(TARGETS ${PROJECT_NAME}\n        LIBRARY DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/deCONZ/plugins\"\n    )\n\n    # following applies only when build as part of deCONZ package\n    if (DECONZ_FULL_BUILD)\n        install(FILES \"general.xml\" DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/deCONZ/zcl\")\n        install(DIRECTORY devices DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/deCONZ\")\n        install(FILES \"button_maps.json\" DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/deCONZ/devices\")\n\n        install(DIRECTORY \"linux/deCONZ/lib/systemd\" DESTINATION \"/lib\")\n        install(\n            DIRECTORY \"linux/deCONZ/usr/bin/\"\n            DESTINATION ${CMAKE_INSTALL_BINDIR}\n            FILES_MATCHING\n            PATTERN \"*.sh\"\n        )\n    endif()\nendif()\n\n#add_library(deconz_common INTERFACE)\n#target_include_directories(deconz_common INTERFACE ${DECONZ_INCLUDE_DIR})\n#target_link_directories(deconz_common INTERFACE /usr/local/lib)\n#target_link_libraries(deconz_common\n #       INTERFACE Qt${QT_VERSION_MAJOR}::Core\n#        INTERFACE Qt${QT_VERSION_MAJOR}::Gui\n#        INTERFACE Qt${QT_VERSION_MAJOR}::Widgets\n#        INTERFACE Qt${QT_VERSION_MAJOR}::Qml\n#        deCONZ.so\n#)\n\n#add_subdirectory (resource)\n#add_subdirectory (device_js)\n#add_subdirectory (device)\n#add_subdirectory (utils)\n#add_subdirectory (zcl)\n#add_subdirectory (zdp)\n\n#enable_testing()\n\n#add_subdirectory (tests)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.6201171875,
          "content": "# Contribution Guide\n\n This document is work in progress and pull requests are welcome.\n\n\n## Pull Request Titles\n\nAll titles should follow a streamlines format and be expressive. The reasoning is that a release notes are auto-generated from PR titles and should be nice to read. Currently the auto-generated release notes are hand edited to look more uniform, it would be better if we can streamline this.\n\n### Examples\n\nThe following examples show some edits which are currently done manually:\n\n| Before edit                                  | Streamlined                                                  |\n| -------------------------------------------- | ------------------------------------------------------------ |\n| FIX: some bug in _TZ3000_32111               | Fix battery reporting for Tuya motion sensor (_TZ3000_32111) |\n| Fixed on/off command logging.                | Fix on/off command logging                                   |\n| Adding support for Sony Motion sensor        | DDF for Sony motion sensor (S12_UH)                          |\n| Add DDF to support sharp temp./humi. (SH500) | DDF for Sharp temperature and humidity sensor (SH500)        |\n| DDF: Add support for Tuya clone              | DDF for Tuya contact sensor (_TZ5555_232332)                 |\n| Update z67_jhsjdh.json                       | Fix Tuya Powerstrip unlock sequence                          |\n\nThe \"DDF for\" prefix for new DDF based devices might not be the most beautiful and maybe changed in future with better use of tags, perhaps to be replaced by \"Support for\".\n\nThere are also PR titles which can't be streamlined but for DDFs and bug fixes  which account for 80% of all pull requests we should do it.\n\n### Notes on \"some\"\n\nPull requests with the word \"some\" in the title will likely be rejected automatically in future with request to change. It is a very weak word which tells the reader nothing and should be be replaced by what is actually changed.\n\n### TAGS\n\nThe release notes generator uses tags to place PR titles in respective categories. The following tags are currently supported and can be assigned to pull requests:\n\n| TAG                | When to use                                                  |\n| ------------------ | ------------------------------------------------------------ |\n| Fix                | Bugfixes and solved problems.                                |\n| Enhancement        | New functionality  /  new generic item or sub-device descriptions / removed legacy C++ code. |\n| Device Request     | For new DDFs.                                                |\n| Device Improvement | Existing DDF is improved (can be combined with Fix tag).     |\n\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.490234375,
          "content": "Copyright (c) 2017, dresden elektronik ingenieurtechnik gmbh\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the <organization> nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5478515625,
          "content": "Introduction\n============\n\nThe deCONZ REST plugin provides a REST-API to access Zigbee 3.0 (Z30), Zigbee Home Automation (ZHA) and Zigbee Light Link (ZLL) lights, switches and sensors from Xiaomi Aqara, IKEA TRÅDFRI, Philips Hue, innr, Samsung and many more vendors.\n\nA list of supported Zigbee devices can be found on the [Supported Devices](https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices) page.\n\nTo communicate with Zigbee devices the [RaspBee](https://phoscon.de/raspbee?ref=gh) / [RaspBee&nbsp;II](https://phoscon.de/raspbee2?ref=gh) Zigbee shield for Raspberry Pi, or a [ConBee](https://phoscon.de/conbee?ref=gh) / [ConBee&nbsp;II](https://phoscon.de/conbee2?ref=gh) / [ConBee&nbsp;III](https://phoscon.de/conbee3?ref=gh) USB dongle is required.\n\n### API Documentation\n\n* [REST-API Documentation](http://dresden-elektronik.github.io/deconz-rest-doc/)\n* [deCONZ C++ Plugin API Documentation](https://phoscon.de/deconz-cpp).\n* [DDF and C++ Device API Documentation](https://dresden-elektronik.github.io/deconz-dev-doc)\n\nFor community based support with deCONZ or Phoscon, please visit the [deCONZ Discord server](https://discord.gg/QFhTxqN). \n\n### Phoscon App\nThe Phoscon App is a browser based web application and supports lights, sensors and switches. For more information and screenshots visit the [Phoscon App Documentation](https://phoscon.de/app/doc?ref=gh).\n\n\n### Release Schedule\n\ndeCONZ beta releases are scheduled roughly once per week. After 1–3 betas a stable version is released and a new beta cycle begins.\n\nCurrent Beta: **v2.28.1-beta**  \nCurrent Stable: **v2.28.1**\n\nNext Beta: **v2.29.0-beta** Expected in September.\nNext Stable: **v2.29.x** Expected in September.\n\nInstallation\n============\n\n##### Supported platforms\n* Raspbian ~~Jessie~~, ~~Stretch~~, Buster, Bullseye and Bookworm\n* Ubuntu ~~Xenial~~, Bionic, Focal Fossa and Jammy\n* Windows 7, 10, 11\n\n### Install deCONZ\nYou find the instructions for your platform and device on the Phoscon website:\n\n* [RaspBee](https://phoscon.de/raspbee/install?ref=gh)\n* [RaspBee&nbsp;II](https://phoscon.de/raspbee2/install?ref=gh)\n* [ConBee](https://phoscon.de/conbee/install?ref=gh)\n* [ConBee&nbsp;II](https://phoscon.de/conbee2/install?ref=gh)\n* [ConBee&nbsp;III](https://phoscon.de/conbee3/install?ref=gh)\n\n**Important:** If you're updating from a previous version **always make sure to create an backup** in the Phoscon App and read the changelog first.\n\nhttps://github.com/dresden-elektronik/deconz-rest-plugin/releases\n\n### Compiling the plugin\n\nThe build instructions are described in [BUILDING.md](BUILDING.md).\n\nPrecompiled deCONZ packages for manual installation\n===================================================\n\nThe deCONZ application packages are available for the following platforms and contain the main application and the pre-compiled REST-API plugin.\n\n* Windows  http://deconz.dresden-elektronik.de/win/\n* Raspbian http://deconz.dresden-elektronik.de/raspbian/beta/\n* Ubuntu and Debian 64-bit http://deconz.dresden-elektronik.de/ubuntu/beta/\n* ARM64 systems http://deconz.dresden-elektronik.de/debian/beta/\n\nTo manually install a Linux .deb package enter these commands:\n\n    sudo dpkg -i <package name>.deb\n    sudo apt-get install -f\n\nHeadless support for Linux\n--------------------------\n\nThe deCONZ package contains a systemd script, which allows deCONZ to run without a X11 server.\n\n1. Enable the service at boot time\n\n```bash\n$ sudo systemctl enable deconz\n```\n\n2. Disable deCONZ GUI autostart service\n\nThe dresden elektronik sd-card image and default installation method autostarts deCONZ GUI.\nThe following commands disable the deCONZ GUI service:\n\n```bash\n$ sudo systemctl disable deconz-gui\n$ sudo systemctl stop deconz-gui\n```\n\nHardware requirements\n---------------------\n\n* Raspberry Pi 1, 2B, 3B, 3B+ or 4B\n* [RaspBee](https://phoscon.de/raspbee?ref=gh) Zigbee shield for Raspberry Pi\n* [RaspBee&nbsp;II](https://phoscon.de/raspbee2?ref=gh) Zigbee shield for Raspberry Pi\n* [ConBee](https://phoscon.de/conbee?ref=gh) USB dongle for Raspberry Pi and PC\n* [ConBee&nbsp;II](https://phoscon.de/conbee2?ref=gh) USB dongle for Raspberry Pi and PC\n* [ConBee&nbsp;III](https://phoscon.de/conbee3?ref=gh) USB dongle for Raspberry Pi and PC\n\n3rd party libraries\n-------------------\nThe following libraries are used by the plugin:\n\n* [ArduinoJSON](https://arduinojson.org)\n* [SQLite](http://www.sqlite.org)\n* [qt-json](https://github.com/lawand/droper/tree/master/qt-json)\n* [colorspace](http://www.getreuer.info/home/colorspace)\n\nLicense\n=======\nThe plugin is available as open source and licensed under the BSD (3-Clause) license.\n\n"
        },
        {
          "name": "air_quality.cpp",
          "type": "blob",
          "size": 4.8623046875,
          "content": "#include <QDataStream>\n#include \"de_web_plugin_private.h\"\n#include \"air_quality.h\"\n\nconst std::array<KeyValMapAirQuality, 6> RStateAirQualityVocLevelGer = { { {65, QLatin1String(\"excellent\")}, {220, QLatin1String(\"good\")}, {660, QLatin1String(\"moderate\")}, {2200, QLatin1String(\"poor\")},\n                                                                            {5000, QLatin1String(\"unhealthy\")}, {65535, QLatin1String(\"out of scale\")} } };\n\n/*! Handle packets related to manufacturer specific clusters for air quality.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Thermostat cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleAirQualityClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAAirQuality\"));\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No air quality sensor found for \" FMT_MAC \", endpoint: 0x%02X\\n\", FMT_MAC_CAST(ind.srcAddress().ext()), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            quint32 level = UINT32_MAX; // invalid value\n            QString airquality;\n\n            switch (attrId)\n            {\n            case 0x4004:\n            {\n                // Bosch air quality sensor\n                if (ind.clusterId() == BOSCH_AIR_QUALITY_CLUSTER_ID && sensor->modelId() == QLatin1String(\"AIR\"))\n                {\n                    level = attr.numericValue().u16;\n                    const auto match = lessThenKeyValue(level, RStateAirQualityVocLevelGer);\n\n                    if (match.key)\n                    {\n                        airquality = match.value;\n                    }\n                }\n            }\n                break;\n\n            default:\n                break;\n            }\n\n            if (level != UINT32_MAX)\n            {\n                ResourceItem *item = sensor->item(RStateAirQualityPpb);\n                if (item)\n                {\n                    if (updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item->toNumber() != level)\n                    {\n                        item->setValue(level);\n                        enqueueEvent(Event(RSensors, RStateAirQualityPpb, sensor->id(), item));\n                        stateUpdated = true;\n                    }\n                }\n\n                item = sensor->item(RStateAirQuality);\n                if (item)\n                {\n                    if (updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item->toString() != airquality)\n                    {\n                        item->setValue(airquality);\n                        enqueueEvent(Event(RSensors, RStateAirQuality, sensor->id(), item));\n                        stateUpdated = true;\n                    }\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), ind.clusterId(), attrId, attr.numericValue());\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n}\n"
        },
        {
          "name": "air_quality.h",
          "type": "blob",
          "size": 0.1689453125,
          "content": "#ifndef AIR_QUALITY_H\n#define AIR_QUALITY_H\n\n#include \"utils/utils.h\"\n\nextern const std::array<KeyValMapAirQuality, 6> RStateAirQualityVocLevelGer;\n\n#endif // AIR_QUALITY_H\n"
        },
        {
          "name": "alarm_system.cpp",
          "type": "blob",
          "size": 20.8720703125,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QTimer>\n#include <array>\n#include <deconz/timeref.h>\n#include <deconz/dbg_trace.h>\n#include \"alarm_system.h\"\n#include \"alarm_system_device_table.h\"\n#include \"crypto/scrypt.h\"\n#include \"database.h\"\n#include \"event_emitter.h\"\n#include \"ias_ace.h\"\n\n#define AS_ID_MASK 0xFF\n#define AS_ID_CODE0 \"as_%1_code0\"\n\nusing AS_StateFunction = void (AlarmSystemPrivate::*)(const Event&);\n\n// Event arm mask for each target state.\n// The mask is used to filter incoming device events to trigger alarms.\nstatic const quint16 targetArmMask[4] = {0,\n                                         AS_ARM_MASK_ARMED_STAY,\n                                         AS_ARM_MASK_ARMED_NIGHT,\n                                         AS_ARM_MASK_ARMED_AWAY};\n\nstatic const std::array<QLatin1String, 4> armModeStrings = {\n    QLatin1String(\"disarmed\"),\n    QLatin1String(\"armed_stay\"),\n    QLatin1String(\"armed_night\"),\n    QLatin1String(\"armed_away\")\n};\n\nclass AlarmSystemPrivate\n{\npublic:\n    void setState(AS_StateFunction state);\n    void startStateTimer();\n    void stopTimer();\n\n    void stateDisarmed(const Event &event);\n    void stateArmed(const Event &event);\n    void stateExitDelay(const Event &event);\n    void stateEntryDelay(const Event &event);\n    void stateInAlarm(const Event &event);\n    void stateArming(const Event &event);\n\n    void updateArmStateAndPanelStatus();\n    void updateTargetStateValues();\n    void setSecondsRemaining(uint secs);\n\n    AlarmSystem *q = nullptr;\n    AS_DeviceTable *devTable = nullptr;\n\n    AS_ArmMode targetState = AS_ArmModeDisarmed;\n\n    // target state parmeteres are set when a state is entered\n    int exitDelay = 0;\n    int entryDelay = 0;\n    int triggerDuration = 0;\n    int armMask = 0;\n\n    QTimer *timer = nullptr;\n    deCONZ::SteadyTimeRef tState{0};\n    AS_StateFunction curState = &AlarmSystemPrivate::stateDisarmed;\n};\n\nvoid AlarmSystemPrivate::setState(AS_StateFunction state)\n{\n    if (state != curState)\n    {\n        curState = state;\n    }\n\n    updateArmStateAndPanelStatus();\n}\n\nvoid AlarmSystemPrivate::startStateTimer()\n{\n    tState = deCONZ::steadyTimeRef();\n    timer->stop();\n    timer->start(1000);\n}\n\nvoid AlarmSystemPrivate::stopTimer()\n{\n    timer->stop();\n}\n\n/*! Event handler for disarmed state.\n */\nvoid AlarmSystemPrivate::stateDisarmed(const Event &event)\n{\n    Q_UNUSED(event)\n}\n\n/*! Event handler for exit state.\n */\nvoid AlarmSystemPrivate::stateExitDelay(const Event &event)\n{\n    if (event.what() == REventTimerFired)\n    {\n        const deCONZ::TimeMs dt = deCONZ::steadyTimeRef() - tState;\n\n        if (deCONZ::TimeSeconds{exitDelay} < dt)\n        {\n            setSecondsRemaining(0);\n            stopTimer();\n\n            if (targetState == AS_ArmModeDisarmed)\n            {\n                setState(&AlarmSystemPrivate::stateDisarmed);\n            }\n            else\n            {\n                startStateTimer();\n                setState(&AlarmSystemPrivate::stateArming);\n            }\n        }\n        else\n        {\n            setSecondsRemaining((exitDelay * 1000 - dt.val) / 1000);\n        }\n    }\n}\n\n/*! Event handler for entry state.\n */\nvoid AlarmSystemPrivate::stateEntryDelay(const Event &event)\n{\n    if (event.what() == REventTimerFired)\n    {\n        const deCONZ::TimeMs dt = deCONZ::steadyTimeRef() - tState;\n\n        if (deCONZ::TimeSeconds{entryDelay} < dt)\n        {\n            setSecondsRemaining(0);\n            startStateTimer();\n            setState(&AlarmSystemPrivate::stateInAlarm);\n        }\n        else\n        {\n            setSecondsRemaining((entryDelay * 1000 - dt.val) / 1000);\n        }\n    }\n}\n\n/*! Event handler for armed states.\n */\nvoid AlarmSystemPrivate::stateArmed(const Event &event)\n{\n    if (event.what() == REventDeviceAlarm)\n    {\n        DBG_Printf(DBG_INFO, \"[AS] received device alarm, data: 0x%08X\\n\", event.num());\n        if ((event.num() & armMask) == 0)\n        {\n        }\n        else if ((event.num() & AS_ID_MASK) == q->id())\n        {\n            setSecondsRemaining(entryDelay);\n            setState(&AlarmSystemPrivate::stateEntryDelay);\n            startStateTimer();\n        }\n    }\n}\n\n/*! Event handler for in_alarm state.\n */\nvoid AlarmSystemPrivate::stateInAlarm(const Event &event)\n{\n    if (event.what() == REventTimerFired)\n    {\n        if (deCONZ::TimeSeconds{triggerDuration} < deCONZ::steadyTimeRef() - tState)\n        {\n            stopTimer();\n            setState(&AlarmSystemPrivate::stateArmed);\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"AS in alarm\\n\");\n            // TODO emit event\n        }\n    }\n}\n\n/*! Event handler for arming states.\n */\nvoid AlarmSystemPrivate::stateArming(const Event &event)\n{\n    if (event.what() == REventTimerFired)\n    {\n        stopTimer();\n        setState(&AlarmSystemPrivate::stateArmed);\n    }\n}\n\n/*! Update 'state/armstate', which maps directly to IAS ACE panel status.\n */\nvoid AlarmSystemPrivate::updateArmStateAndPanelStatus()\n{\n    ResourceItem *item = q->item(RStateArmState);\n    DBG_Assert(item);\n\n    if (!item)\n    {\n        return;\n    }\n\n    quint8 status = item->toNumber() & 0xFF;\n\n    if (curState == &AlarmSystemPrivate::stateDisarmed)\n    {\n        status = IAS_ACE_PANEL_STATUS_PANEL_DISARMED;\n    }\n    else if (curState == &AlarmSystemPrivate::stateArmed)\n    {\n        if      (targetState == AS_ArmModeArmedAway)  { status = IAS_ACE_PANEL_STATUS_ARMED_AWAY; }\n        else if (targetState == AS_ArmModeArmedStay)  { status = IAS_ACE_PANEL_STATUS_ARMED_STAY; }\n        else if (targetState == AS_ArmModeArmedNight) { status = IAS_ACE_PANEL_STATUS_ARMED_NIGHT; }\n    }\n    else if (curState == &AlarmSystemPrivate::stateArming)\n    {\n        if      (targetState == AS_ArmModeArmedAway)  { status = IAS_ACE_PANEL_STATUS_ARMING_AWAY; }\n        else if (targetState == AS_ArmModeArmedStay)  { status = IAS_ACE_PANEL_STATUS_ARMING_STAY; }\n        else if (targetState == AS_ArmModeArmedNight) { status = IAS_ACE_PANEL_STATUS_ARMING_NIGHT; }\n    }\n    else if (curState == &AlarmSystemPrivate::stateInAlarm)\n    {\n        status = IAS_ACE_PANEL_STATUS_IN_ALARM;\n    }\n    else if (curState == &AlarmSystemPrivate::stateEntryDelay)\n    {\n        status = IAS_ACE_PANEL_STATUS_ENTRY_DELAY;\n    }\n    else if (curState == &AlarmSystemPrivate::stateExitDelay)\n    {\n        status = IAS_ACE_PANEL_STATUS_EXIT_DELAY;\n    }\n\n    if (status != item->toNumber())\n    {\n        item->setValue(status);\n        emit q->eventNotify(Event(q->prefix(), item->descriptor().suffix, q->idString(), item));\n    }\n}\n\n/*! Each arm mode has it's own configuration parameters, this function\n    updates exit, entry and trigger durations as well as the arm mask.\n */\nvoid AlarmSystemPrivate::updateTargetStateValues()\n{\n    DBG_Assert(targetState <= AS_ArmModeArmedAway);\n    if (targetState > AS_ArmModeArmedAway)\n    {\n        return;\n    }\n\n    {\n        const char* exitSuffix[4]    = { RConfigDisarmedExitDelay,\n                                         RConfigArmedStayExitDelay,\n                                         RConfigArmedNightExitDelay,\n                                         RConfigArmedAwayExitDelay };\n\n        exitDelay = q->item(exitSuffix[targetState])->toNumber();\n    }\n\n    {\n        const char* entrySuffix[4]   = { RConfigDisarmedEntryDelay,\n                                         RConfigArmedStayEntryDelay,\n                                         RConfigArmedNightEntryDelay,\n                                         RConfigArmedAwayEntryDelay };\n\n        entryDelay = q->item(entrySuffix[targetState])->toNumber();\n    }\n\n    if (targetState > AS_ArmModeDisarmed)\n    {\n        const char* triggerSuffix[4] = { RInvalidSuffix,  // no trigger duration in disarmed state\n                                         RConfigArmedStayExitDelay,\n                                         RConfigArmedNightExitDelay,\n                                         RConfigArmedAwayTriggerDuration };\n\n        triggerDuration = q->item(triggerSuffix[targetState])->toNumber();\n    }\n    else\n    {\n        triggerDuration = 0;\n    }\n\n    armMask = targetArmMask[targetState];\n}\n\n/*! Sets the timout \\p secs for states which have a duration.\n */\nvoid AlarmSystemPrivate::setSecondsRemaining(uint secs)\n{\n    DBG_Assert(secs <= UINT8_MAX);\n    ResourceItem *item = q->item(RStateSecondsRemaining);\n    if (item && item->toNumber() != secs && secs <= UINT8_MAX)\n    {\n        item->setValue(secs);\n        emit q->eventNotify(Event(q->prefix(), item->descriptor().suffix, q->idString(), item));\n    }\n}\n\nAlarmSystem::AlarmSystem(AlarmSystemId id, EventEmitter *eventEmitter, AS_DeviceTable *devTable, QObject *parent) :\n    QObject(parent),\n    Resource(RAlarmSystems)\n{\n    d = new AlarmSystemPrivate;\n    d->q = this;\n    d->devTable = devTable;\n\n    d->timer = new QTimer(this);\n    d->timer->setSingleShot(false);\n    connect(d->timer, &QTimer::timeout, this, &AlarmSystem::timerFired);\n\n    {\n        ResourceItem *item = addItem(DataTypeUInt8, RConfigAlarmSystemId);\n        item->setIsPublic(false);\n        item->setValue(id);\n    }\n    addItem(DataTypeUInt32, RStateArmState)->setValue(IAS_ACE_PANEL_STATUS_NOT_READY_TO_ARM);\n    addItem(DataTypeBool, RConfigConfigured)->setValue(false);\n    addItem(DataTypeString, RConfigArmMode)->setValue(QString(armModeStrings[AS_ArmModeDisarmed]));\n    addItem(DataTypeString, RAttrId)->setValue(QString::number(id));\n    addItem(DataTypeString, RAttrName);\n\n    addItem(DataTypeUInt32, RStateSecondsRemaining)->setValue(0);\n\n    addItem(DataTypeUInt8, RConfigDisarmedEntryDelay)->setValue(0);\n    addItem(DataTypeUInt8, RConfigDisarmedExitDelay)->setValue(0);\n\n    addItem(DataTypeUInt8, RConfigArmedStayEntryDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedStayExitDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedStayTriggerDuration)->setValue(120);\n\n    addItem(DataTypeUInt8, RConfigArmedNightEntryDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedNightExitDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedNightTriggerDuration)->setValue(120);\n\n    addItem(DataTypeUInt8, RConfigArmedAwayEntryDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedAwayExitDelay)->setValue(120);\n    addItem(DataTypeUInt8, RConfigArmedAwayTriggerDuration)->setValue(120);\n\n    d->updateTargetStateValues();\n\n    connect(this, &AlarmSystem::eventNotify, eventEmitter, &EventEmitter::enqueueEvent);\n}\n\nAlarmSystem::~AlarmSystem()\n{\n    delete d;\n}\n\n/*! Main entry point to handle internal and external events.\n\n    The \\p event gets forwarded to the current state handler.\n */\nvoid AlarmSystem::handleEvent(const Event &event)\n{\n    if (event.resource() == RAlarmSystems && event.what() == RConfigArmMode) // target state changed?\n    {\n        const QString &armMode = item(event.what())->toString();\n\n        const AS_ArmMode oldTargetState = d->targetState;\n        const AS_ArmMode mode = AS_ArmModeFromString(armMode);\n\n        if (mode != AS_ArmModeMax)\n        {\n            d->targetState = mode;\n        }\n        else\n        {\n            return; // invalid target arm mode request, should not happen\n        }\n\n        d->updateTargetStateValues();\n\n        if (oldTargetState == d->targetState)\n        {\n            return;\n        }\n\n        d->setSecondsRemaining(d->exitDelay); // set early for correct numbers in state/panel events\n        d->setState(&AlarmSystemPrivate::stateExitDelay);\n        d->startStateTimer();\n    }\n    else\n    {\n        (d->*d->curState)(event);\n    }\n}\n\nvoid AlarmSystem::didSetValue(ResourceItem *i)\n{\n    if (!i || !i->descriptor().suffix)\n    {\n        return;\n    }\n\n    emit eventNotify(Event(prefix(), i->descriptor().suffix, idString(), i));\n\n    // only attr/* and config/*\n    if (i->descriptor().suffix[0] != 'c' && i->descriptor().suffix[0] != 'a')\n    {\n        return;\n    }\n\n    const std::array<const char*, 13> store = {\n        RAttrName,\n        RConfigArmMode,\n        RConfigDisarmedEntryDelay, RConfigDisarmedExitDelay,\n        RConfigArmedAwayEntryDelay, RConfigArmedAwayExitDelay, RConfigArmedAwayTriggerDuration,\n        RConfigArmedStayEntryDelay, RConfigArmedStayExitDelay, RConfigArmedStayTriggerDuration,\n        RConfigArmedNightEntryDelay, RConfigArmedNightExitDelay, RConfigArmedNightTriggerDuration\n    };\n\n    if (std::find(store.cbegin(), store.cend(), i->descriptor().suffix) != store.cend())\n    {\n        DB_AlarmSystemResourceItem dbItem;\n        dbItem.alarmSystemId = id();\n        dbItem.timestamp = deCONZ::systemTimeRef().ref;\n        dbItem.suffix = i->descriptor().suffix;\n        if (i->descriptor().type == DataTypeString)\n        {\n            dbItem.value = i->toString().toStdString();\n        }\n        else\n        {\n            dbItem.value = std::to_string(i->toNumber());\n        }\n        DB_StoreAlarmSystemResourceItem(dbItem);\n    }\n}\n\n/*! Returns true if the \\p code can be verified.\n\n    The verification is only done if an entry for \\p srcExtAddress exists\n    in the alarm system device table.\n */\nbool AlarmSystem::isValidCode(const QString &code, quint64 srcExtAddress)\n{\n    if (srcExtAddress != 0)\n    {\n        const AS_DeviceEntry &entry = d->devTable->get(srcExtAddress);\n\n        if (!isValid(entry) || entry.alarmSystemId != id())\n        {\n            return false;\n        }\n    }\n\n    DB_Secret sec;\n    sec.uniqueId = QString(AS_ID_CODE0).arg(id()).toStdString();\n\n    if (DB_LoadSecret(sec))\n    {\n        if (CRYPTO_ScryptVerify(sec.secret, code.toStdString()))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nAlarmSystemId AlarmSystem::id() const\n{\n    return item(RConfigAlarmSystemId)->toNumber();\n}\n\nconst QString &AlarmSystem::idString() const\n{\n    return item(RAttrId)->toString();\n}\n\n/*! Returnes the response status for IAS ACE device panel status request.\n */\nquint8 AlarmSystem::iasAcePanelStatus() const\n{\n    return item(RStateArmState)->toNumber() & 0xFF;\n}\n\n/*! Returns the remaining time in seconds, for entry and exit states, 0 for all other states.\n */\nuint AlarmSystem::secondsRemaining() const\n{\n    if (d->curState == &AlarmSystemPrivate::stateEntryDelay || d->curState == &AlarmSystemPrivate::stateExitDelay)\n    {\n        return item(RStateSecondsRemaining)->toNumber();\n    }\n\n    return 0;\n}\n\n/*! Returns 'state/armstate', which matches the panel IAS ACE panel status.\n */\nQLatin1String AlarmSystem::armStateString() const\n{\n    return IAS_PanelStatusToString(iasAcePanelStatus());\n}\n\n/*! Returns the configured target arm mode.\n\n    note that the current state can be different if the state machine is in a transition.\n */\nAS_ArmMode AlarmSystem::targetArmMode() const\n{\n    return d->targetState;\n}\n\n/*! Sets the target arm mode.\n\n    The state machine will pick up a changed mode and transition accordingly.\n */\nbool AlarmSystem::setTargetArmMode(AS_ArmMode targetArmMode)\n{\n    if (targetArmMode >= AS_ArmModeMax)\n    {\n        return false;\n    }\n\n    if (targetArmMode == d->targetState)\n    {\n        return true;\n    }\n\n    setValue(RConfigArmMode, QString(AS_ArmModeToString(targetArmMode)));\n\n    return true;\n}\n\nbool AlarmSystem::addDevice(const QString &uniqueId, quint32 flags)\n{\n    return d->devTable->put(uniqueId, flags, quint8(id()));\n}\n\nbool AlarmSystem::removeDevice(const QLatin1String &uniqueId)\n{\n    return d->devTable->erase(uniqueId);\n}\n\nconst AS_DeviceTable *AlarmSystem::deviceTable() const\n{\n    return d->devTable;\n}\n\n/*! Sets or updated the PIN code for \\p index.\n\n    The code is stored encryped in the database.\n */\nbool AlarmSystem::setCode(int index, const QString &code)\n{\n    if (code.isEmpty())\n    {\n        return false;\n    }\n\n    const std::string code0 = code.toStdString();\n\n    DB_Secret sec;\n    sec.uniqueId = QString(\"as_%1_code%2\").arg(id()).arg(index).toStdString();\n    sec.secret = CRYPTO_ScryptPassword(code0, CRYPTO_GenerateSalt());\n    sec.state = 1;\n\n    if (sec.secret.empty())\n    {\n        return false;\n    }\n\n    if (DB_StoreSecret(sec))\n    {\n        setValue(RConfigConfigured, true);\n        return true;\n    }\n\n    return false;\n}\n\n/*! Starts the alarm system operational mode.\n */\nvoid AlarmSystem::start()\n{\n    const QString &armMode = item(RConfigArmMode)->toString();\n\n    if      (armMode == armModeStrings[AS_ArmModeDisarmed])   { d->targetState = AS_ArmModeDisarmed;   d->setState(&AlarmSystemPrivate::stateDisarmed); }\n    else if (armMode == armModeStrings[AS_ArmModeArmedAway])  { d->targetState = AS_ArmModeArmedAway;  d->setState(&AlarmSystemPrivate::stateArmed); }\n    else if (armMode == armModeStrings[AS_ArmModeArmedStay])  { d->targetState = AS_ArmModeArmedStay;  d->setState(&AlarmSystemPrivate::stateArmed); }\n    else if (armMode == armModeStrings[AS_ArmModeArmedNight]) { d->targetState = AS_ArmModeArmedNight; d->setState(&AlarmSystemPrivate::stateArmed); }\n\n    d->updateArmStateAndPanelStatus();\n    d->updateTargetStateValues();\n\n    DB_Secret sec;\n    sec.uniqueId = QString(AS_ID_CODE0).arg(id()).toStdString();\n\n    bool configured = DB_LoadSecret(sec);\n    item(RConfigConfigured)->setValue(configured);\n}\n\nvoid AlarmSystem::timerFired()\n{\n    handleEvent(Event(RAlarmSystems, REventTimerFired, 0));\n}\n\nAlarmSystems::AlarmSystems()\n{\n}\n\nAlarmSystems::~AlarmSystems()\n{\n    for (auto *alarmSys : alarmSystems)\n    {\n        alarmSys->deleteLater();\n    }\n\n    alarmSystems.clear();\n}\n\nQLatin1String AS_ArmModeToString(AS_ArmMode armMode)\n{\n    Q_ASSERT(size_t(armMode) < armModeStrings.size());\n    return armModeStrings[armMode];\n}\n\nAS_ArmMode AS_ArmModeFromString(const QString &armMode)\n{\n    const auto i = std::find_if(armModeStrings.cbegin(), armModeStrings.cend(), [&armMode](const auto &str) {\n        return str == armMode;\n    });\n\n    if (i != armModeStrings.cend())\n    {\n        return static_cast<AS_ArmMode>(std::distance(armModeStrings.cbegin(), i));\n    }\n\n    return AS_ArmModeMax;\n}\n\nAlarmSystem *AS_GetAlarmSystemForDevice(quint64 extAddress, AlarmSystems &alarmSystems)\n{\n    AlarmSystem *result = nullptr;\n\n    for (auto *alarmSys : alarmSystems.alarmSystems)\n    {\n        const AS_DeviceEntry &entry = alarmSys->deviceTable()->get(extAddress);\n        if (isValid(entry) && entry.alarmSystemId == alarmSys->id())\n        {\n            result = alarmSys;\n            break;\n        }\n    }\n\n    return result;\n}\n\nconst AlarmSystem *AS_GetAlarmSystem(AlarmSystemId alarmSystemId, const AlarmSystems &alarmSystems)\n{\n    auto i = std::find_if(alarmSystems.alarmSystems.begin(), alarmSystems.alarmSystems.end(), [alarmSystemId](auto &as){\n        return as->item(RConfigAlarmSystemId)->toNumber() == alarmSystemId;\n    });\n\n    if (i != alarmSystems.alarmSystems.end())\n    {\n        return *i;\n    }\n\n    return nullptr;\n}\n\nAlarmSystem *AS_GetAlarmSystem(AlarmSystemId alarmSystemId, AlarmSystems &alarmSystems)\n{\n    auto i = std::find_if(alarmSystems.alarmSystems.begin(), alarmSystems.alarmSystems.end(), [alarmSystemId](auto &as){\n        return as->id() == alarmSystemId;\n    });\n\n    if (i != alarmSystems.alarmSystems.end())\n    {\n        return *i;\n    }\n\n    return nullptr;\n}\n\nvoid DB_LoadAlarmSystems(AlarmSystems &alarmSystems, AS_DeviceTable *devTable, EventEmitter *eventEmitter)\n{\n    for (AlarmSystemId alarmSystemId = 0; alarmSystemId < 4; alarmSystemId++)\n    {\n        const auto ritems = DB_LoadAlarmSystemResourceItems(alarmSystemId);\n\n        if (ritems.empty())\n        {\n            continue;\n        }\n\n        AlarmSystem *alarmSys = new AlarmSystem(alarmSystemId, eventEmitter, devTable);\n\n        alarmSystems.alarmSystems.push_back(alarmSys);\n\n        for (const auto &dbItem : ritems)\n        {\n            if (dbItem.value.empty())\n            {\n                continue;\n            }\n\n            ResourceItem *item = alarmSys->item(dbItem.suffix);\n\n            if (!item)\n            {\n                continue;\n            }\n\n            if (item->descriptor().type == DataTypeString)\n            {\n                item->setValue(QString::fromStdString(dbItem.value));\n            }\n            else if (item->descriptor().type == DataTypeUInt8)\n            {\n                qint64 num = strtol(dbItem.value.c_str(), nullptr, 10);\n                item->setValue(num);\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"[AS] database load item, %s, not supported\\n\", dbItem.suffix);\n            }\n        }\n\n        alarmSys->start();\n    }\n}\n\n/*! Creates a \"default\" alarm system with id \"1\", which is always present.\n */\nvoid AS_InitDefaultAlarmSystem(AlarmSystems &alarmSystems, AS_DeviceTable *devTable, EventEmitter *eventEmitter)\n{\n    if (AS_GetAlarmSystem(1, alarmSystems)) // already exists\n    {\n        return;\n    }\n\n    AlarmSystemId id = 1;\n    AlarmSystem *alarmSys = new AlarmSystem(id, eventEmitter, devTable);\n\n    alarmSystems.alarmSystems.push_back(alarmSys);\n\n\n    {\n        DB_AlarmSystem dbAlarmSys;\n        dbAlarmSys.id = id;\n        dbAlarmSys.timestamp = deCONZ::systemTimeRef().ref;\n\n        DB_StoreAlarmSystem(dbAlarmSys);\n    }\n\n    alarmSys->setValue(RAttrName, QString(\"default\"));\n}\n"
        },
        {
          "name": "alarm_system.h",
          "type": "blob",
          "size": 3.5068359375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef ALARM_SYSTEM_H\n#define ALARM_SYSTEM_H\n\n#include <QObject>\n#include <vector>\n#include \"resource.h\"\n\n/*! \\class AlarmSystem\n\n    This class implements a stateful alarm system. The system is controlled with events from physical devices and the REST API.\n\n    A general overview can be found at https://dresden-elektronik.github.io/deconz-rest-doc/endpoints/alarmsystems\n\n    The state machine mimics a typical alarm system, similar to implementations in home automation systems.\n\n        https://www.npmjs.com/package/homebridge-alarm-panel\n        https://www.home-assistant.io/integrations/manual\n\n    There are four target states:\n      disarmed\n      armed_away\n      armed_stay\n      armed_night\n\n    A: alarm system id\n    M: alarm mask\n       0000 0001 Away\n       0000 0010 Stay\n       0000 0100 Night\n\n    RConfigAlarmSystemId:  uint32   0000 0000 0000 0000 0000 0000 0000 0000\n                                    0000 0000 0000 0000 0000 0000 AAAA AAAA\n\n    REventDeviceAlarm        uint32   0000 0000 0000 0000 MMMM MMMM AAAA AAAA\n\n*/\n\n#define AS_ARM_MASK_ARMED_AWAY  0x0100\n#define AS_ARM_MASK_ARMED_STAY  0x0200\n#define AS_ARM_MASK_ARMED_NIGHT 0x0400\n\nclass Event;\nclass EventEmitter;\nclass AS_DeviceTable;\nclass AlarmSystemPrivate;\n\nenum AS_ArmMode\n{\n    AS_ArmModeDisarmed    = 0,\n    AS_ArmModeArmedStay   = 1,\n    AS_ArmModeArmedNight  = 2,\n    AS_ArmModeArmedAway   = 3,\n\n    AS_ArmModeMax\n};\n\nusing AlarmSystemId = quint32;\n\nclass AlarmSystem : public QObject,\n                    public Resource\n{\n    Q_OBJECT\n\npublic:\n    AlarmSystem(AlarmSystemId id, EventEmitter *eventEmitter, AS_DeviceTable *devTable, QObject *parent = nullptr);\n    ~AlarmSystem();\n    void handleEvent(const Event &event);\n    void didSetValue(ResourceItem *i) override;\n    bool isValidCode(const QString &code, quint64 srcExtAddress);\n    AlarmSystemId id() const;\n    const QString &idString() const;\n    quint8 iasAcePanelStatus() const;\n    uint secondsRemaining() const;\n    QLatin1String armStateString() const;\n    AS_ArmMode targetArmMode() const;\n    bool setTargetArmMode(AS_ArmMode targetArmMode);\n    bool addDevice(const QString &uniqueId, quint32 flags);\n    bool removeDevice(const QLatin1String &uniqueId);\n    const AS_DeviceTable *deviceTable() const;\n    bool setCode(int index, const QString &code);\n    void start();\n\nQ_SIGNALS:\n    void eventNotify(const Event&);\n\nprivate Q_SLOTS:\n    void timerFired();\n\nprivate:\n    AlarmSystemPrivate *d = nullptr;\n};\n\n/*! \\class AlarmSystems\n\n    RAII wrapper to hold \\c AlarmSystem objects.\n */\nclass AlarmSystems\n{\npublic:\n    AlarmSystems();\n    ~AlarmSystems();\n\n    std::vector<AlarmSystem*> alarmSystems;\n};\n\nvoid DB_LoadAlarmSystems(AlarmSystems &alarmSystems, AS_DeviceTable *devTable, EventEmitter *eventEmitter);\nvoid AS_InitDefaultAlarmSystem(AlarmSystems &alarmSystems, AS_DeviceTable *devTable, EventEmitter *eventEmitter);\n\nQLatin1String AS_ArmModeToString(AS_ArmMode armMode);\nAS_ArmMode AS_ArmModeFromString(const QString &armMode);\nAlarmSystem *AS_GetAlarmSystemForDevice(quint64 extAddress, AlarmSystems &alarmSystems);\nconst AlarmSystem *AS_GetAlarmSystem(AlarmSystemId alarmSystemId, const AlarmSystems &alarmSystems);\nAlarmSystem *AS_GetAlarmSystem(AlarmSystemId alarmSystemId, AlarmSystems &alarmSystems);\n\n#endif // ALARM_SYSTEM_H\n"
        },
        {
          "name": "alarm_system_device_table.cpp",
          "type": "blob",
          "size": 5.1123046875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"deconz/dbg_trace.h\"\n#include \"deconz/timeref.h\"\n#include \"alarm_system_device_table.h\"\n#include \"database.h\"\n#include \"utils/utils.h\"\n\n//! getIterator() is a helper to simplyfy code\nstatic std::vector<AS_DeviceEntry>::iterator getIterator(std::vector<AS_DeviceEntry> &table, quint64 extAddress)\n{\n    return std::find_if(table.begin(), table.end(), [&](const AS_DeviceEntry &entry) { return entry.extAddress == extAddress; });\n}\n\nstatic std::vector<AS_DeviceEntry>::const_iterator getIterator(const std::vector<AS_DeviceEntry> &table, quint64 extAddress)\n{\n    return std::find_if(table.cbegin(), table.cend(), [&](const AS_DeviceEntry &entry) { return entry.extAddress == extAddress; });\n}\n\nAS_DeviceTable::AS_DeviceTable()\n{\n    static_assert(sizeof(AS_DeviceEntry) == 64, \"expected size of AS_DeviceEntry == 64 bytes\");\n    static_assert (AS_MAX_UNIQUEID_LENGTH == DB_MAX_UNIQUEID_SIZE, \"DB/AS max uniqueid size mismatch\");\n}\n\nconst AS_DeviceEntry &AS_DeviceTable::get(const QString &uniqueId) const\n{\n    const quint64 extAddress = extAddressFromUniqueId(uniqueId);\n    const auto i = getIterator(m_table, extAddress);\n\n    if (i != m_table.cend())\n    {\n        return *i;\n    }\n\n    return m_invalidEntry;\n}\n\nconst AS_DeviceEntry &AS_DeviceTable::get(quint64 extAddress) const\n{\n    const auto i = getIterator(m_table, extAddress);\n\n    if (i != m_table.cend())\n    {\n        return *i;\n    }\n\n    return m_invalidEntry;\n}\n\nconst AS_DeviceEntry &AS_DeviceTable::at(size_t index) const\n{\n    if (index < m_table.size())\n    {\n        return m_table[index];\n    }\n\n    return m_invalidEntry;\n}\n\nstatic void entryInitArmMask(AS_DeviceEntry &entry)\n{\n    memset(entry.armMask, 0, sizeof(entry.armMask));\n    char *p = entry.armMask;\n\n    if (entry.flags & AS_ENTRY_FLAG_ARMED_AWAY) { *p++ = 'A'; }\n    if (entry.flags & AS_ENTRY_FLAG_ARMED_STAY) { *p++ = 'S'; }\n    if (entry.flags & AS_ENTRY_FLAG_ARMED_NIGHT) { *p++ = 'N'; }\n}\n\nstatic bool storeDeviceEntry(const AS_DeviceEntry &entry)\n{\n    DB_AlarmSystemDevice dbDevice;\n\n    copyString(dbDevice.uniqueid, sizeof(dbDevice.uniqueid), entry.uniqueId);\n    DBG_Assert(!isEmptyString(dbDevice.uniqueid));\n    if (isEmptyString(dbDevice.uniqueid))\n    {\n        return false;\n    }\n\n    dbDevice.alarmSystemId = entry.alarmSystemId;\n    dbDevice.flags = entry.flags;\n    dbDevice.timestamp = deCONZ::systemTimeRef().ref;\n\n    return DB_StoreAlarmSystemDevice(dbDevice);\n}\n\nbool AS_DeviceTable::put(const QString &uniqueId, quint32 flags, quint8 alarmSystemId)\n{\n    const quint64 extAddress = extAddressFromUniqueId(uniqueId);\n\n    if (extAddress == 0)\n    {\n        return false;\n    }\n\n    // check existing\n    auto i = getIterator(m_table, extAddress);\n\n    if (i != m_table.end())\n    {\n        if (i->flags != flags || i->alarmSystemId != alarmSystemId)\n        {\n            i->flags = flags;\n            i->alarmSystemId = alarmSystemId;\n            entryInitArmMask(*i);\n\n            storeDeviceEntry(*i);\n        }\n        return true;\n    }\n\n    // not existing, create new\n    m_table.push_back(AS_DeviceEntry());\n    AS_DeviceEntry &entry = m_table.back();\n\n    if (size_t(uniqueId.size()) >= sizeof(entry.uniqueId))\n    {\n        m_table.pop_back();\n        return false;\n    }\n\n    entry.uniqueIdSize = quint8(uniqueId.size());\n    memcpy(entry.uniqueId, qPrintable(uniqueId), entry.uniqueIdSize);\n    entry.uniqueId[entry.uniqueIdSize] = '\\0';\n    entry.extAddress = extAddress;\n    entry.alarmSystemId = alarmSystemId;\n    entry.flags = flags;\n    entryInitArmMask(entry);\n\n    storeDeviceEntry(entry);\n    return true;\n}\n\nbool AS_DeviceTable::erase(const QLatin1String &uniqueId)\n{\n    quint64 extAddress = extAddressFromUniqueId(uniqueId);\n    auto i = getIterator(m_table, extAddress);\n\n    if (i != m_table.end() && DB_DeleteAlarmSystemDevice(i->uniqueId))\n    {\n        *i = m_table.back();\n        m_table.pop_back();\n        return true;\n    }\n\n    return false;\n}\n\nvoid AS_DeviceTable::reset(std::vector<AS_DeviceEntry> &&table)\n{\n    m_table = table;\n}\n\nvoid DB_LoadAlarmSystemDevices(AS_DeviceTable *devTable)\n{\n    const auto dbDevices = DB_LoadAlarmSystemDevices();\n\n    if (dbDevices.empty())\n    {\n        return;\n    }\n\n    std::vector<AS_DeviceEntry> table;\n    table.reserve(dbDevices.size());\n\n    for (const auto &dbDev : dbDevices)\n    {\n        if (strlen(dbDev.uniqueid) > AS_MAX_UNIQUEID_LENGTH)\n        {\n            continue;\n        }\n\n        table.push_back(AS_DeviceEntry());\n        AS_DeviceEntry &entry = table.back();\n\n        entry.extAddress = extAddressFromUniqueId(QLatin1String(dbDev.uniqueid));\n        entry.alarmSystemId = dbDev.alarmSystemId;\n        entry.uniqueIdSize = quint8(strlen(dbDev.uniqueid));\n        memcpy(entry.uniqueId, dbDev.uniqueid, entry.uniqueIdSize);\n        entry.uniqueId[entry.uniqueIdSize] = '\\0';\n        entry.flags = dbDev.flags;\n        entryInitArmMask(entry);\n    }\n\n    devTable->reset(std::move(table));\n}\n"
        },
        {
          "name": "alarm_system_device_table.h",
          "type": "blob",
          "size": 1.849609375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef ALARM_SYSTEM_DEVICE_TABLE_H\n#define ALARM_SYSTEM_DEVICE_TABLE_H\n\n#include <QString>\n#include <vector>\n\n// 28:6d:97:00:01:06:41:79-01-0500  31 characters\n#define AS_MAX_UNIQUEID_LENGTH 31\n\n#define AS_ENTRY_FLAG_ARMED_AWAY  0x00000100\n#define AS_ENTRY_FLAG_ARMED_STAY  0x00000200\n#define AS_ENTRY_FLAG_ARMED_NIGHT 0x00000400\n#define AS_ENTRY_FLAG_IAS_ACE     0x00000008\n\n/*! \\struct AS_DeviceEntry\n\n    Holds a uniqueid and configuration for a device in an alarm system.\n    The size is 64 bytes to fit in one cache line.\n */\nstruct AS_DeviceEntry\n{\n    char uniqueId[AS_MAX_UNIQUEID_LENGTH + 1]{0};\n    quint64 extAddress = 0;\n    quint32 flags = 0;\n    quint8 uniqueIdSize = 0;\n    quint8 alarmSystemId = 0;\n    char armMask[4]{0};\n    char padding[14]{0};\n};\n\nclass AS_DeviceTable\n{\npublic:\n    AS_DeviceTable();\n\n    const AS_DeviceEntry &get(const QString &uniqueId) const;\n    const AS_DeviceEntry &get(quint64 extAddress) const;\n    const AS_DeviceEntry &at(size_t index) const;\n    bool put(const QString &uniqueId, quint32 flags, quint8 alarmSystemId);\n    bool erase(const QLatin1String &uniqueId);\n    size_t size() const { return m_table.size(); }\n    void reset(std::vector<AS_DeviceEntry> && table);\n\nprivate:\n    const AS_DeviceEntry m_invalidEntry{};\n    std::vector<AS_DeviceEntry> m_table;\n};\n\ninline bool isValid(const AS_DeviceEntry &entry)\n{\n    return entry.uniqueId[0] != '\\0' &&\n           entry.uniqueIdSize > 0 &&\n           entry.alarmSystemId > 0 &&\n           entry.extAddress != 0;\n}\n\nvoid DB_LoadAlarmSystemDevices(AS_DeviceTable *devTable);\n\n#endif // ALARM_SYSTEM_DEVICE_TABLE_H\n"
        },
        {
          "name": "alarm_system_event_handler.cpp",
          "type": "blob",
          "size": 6.1240234375,
          "content": " /*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <string.h>\n#include \"alarm_system.h\"\n#include \"alarm_system_device_table.h\"\n#include \"alarm_system_event_handler.h\"\n#include \"de_web_plugin_private.h\"\n#include \"ias_ace.h\"\n#include \"websocket_server.h\"\n\n// TODO remove dependency on plugin\n\n/*! For keypads mirror panel state and seconds remaining.\n */\nstatic void mirrorKeypadAlarmSystemState(const AlarmSystem *alarmSys, EventEmitter *eventEmitter)\n{\n    const AS_DeviceTable *devTable = alarmSys->deviceTable();\n    for (size_t i = 0; i < devTable->size(); i++)\n    {\n        const AS_DeviceEntry &entry = devTable->at(i);\n        if (isValid(entry) && entry.flags & AS_ENTRY_FLAG_IAS_ACE)\n        {\n            Resource *r = plugin->getResource(RSensors, QLatin1String(entry.uniqueId, entry.uniqueIdSize));\n\n            if (!r) { continue; }\n\n            ResourceItem *panel = r->item(RStatePanel);\n            ResourceItem *secondsRemaining = r->item(RStateSecondsRemaining);\n\n            if (!panel || !secondsRemaining) { continue; }\n\n            secondsRemaining->setValue(alarmSys->secondsRemaining());\n            panel->setValue(QString(alarmSys->armStateString()));\n\n            if (panel->needPushChange())\n            {\n                eventEmitter->enqueueEvent(Event(r->prefix(), panel->descriptor().suffix, r->item(RAttrId)->toString()));\n            }\n\n            if (secondsRemaining->needPushChange())\n            {\n                eventEmitter->enqueueEvent(Event(r->prefix(), secondsRemaining->descriptor().suffix, r->item(RAttrId)->toString()));\n            }\n        }\n    }\n}\n\nstatic void pushEventToWebsocket(const Event &event, AlarmSystem *alarmSys, WebSocketServer *webSocket)\n{\n    Q_ASSERT(event.what());\n    {\n        char type = event.what()[0];\n        if (!(type == 's' || type == 'c' || type == 'a'))\n        {\n            return; // only interested in attr/*, state/* and config/*\n        }\n    }\n\n    int suffixOffset = 0;\n\n    {\n        const char *delim = strchr(event.what(), '/');\n        if (!delim)\n        {\n            return;\n        }\n\n        suffixOffset = delim - event.what() + 1;\n    }\n\n\n    ResourceItem *item = alarmSys->item(event.what());\n\n    if (!item)\n    {\n        return;\n    }\n\n    if (!(item->needPushSet() || item->needPushChange()))\n    {\n        return; // already pushed\n    }\n\n    QVariantMap map;\n    map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n    map[QLatin1String(\"e\")] = QLatin1String(\"changed\");\n    map[QLatin1String(\"r\")] = QLatin1String(\"alarmsystems\");\n    map[QLatin1String(\"id\")] = alarmSys->idString();\n\n    {\n        QVariantMap map2;\n\n        for (int i = 0; i < alarmSys->itemCount(); i++)\n        {\n            item = alarmSys->itemForIndex(size_t(i));\n            Q_ASSERT(item);\n            const char *suffix = item->descriptor().suffix;\n            if (*suffix == *event.what() && item->isPublic())\n            {\n                item->clearNeedPush();\n                if (suffix == RStateArmState)\n                {\n                    map2[QLatin1String(suffix + suffixOffset)] = alarmSys->armStateString();\n                }\n                else\n                {\n                    map2[QLatin1String(suffix + suffixOffset)] = item->toVariant();\n                }\n            }\n        }\n\n        map[QLatin1String(event.what(), suffixOffset - 1)] = map2;\n    }\n\n    webSocket->broadcastTextMessage(Json::serialize(map));\n}\n\n\n/*! Global handler for alarm system related events.\n */\nvoid AS_HandleAlarmSystemEvent(const Event &event, AlarmSystems &alarmSystems, EventEmitter *eventEmitter, WebSocketServer *webSocket)\n{\n    for (auto *alarmSys : alarmSystems.alarmSystems)\n    {\n        alarmSys->handleEvent(event);\n\n        if (event.what() == RStateArmState || event.what() == RStateSecondsRemaining)\n        {\n            mirrorKeypadAlarmSystemState(alarmSys, eventEmitter);\n        }\n\n        if (event.resource() == RAlarmSystems && event.id() == alarmSys->idString())\n        {\n            pushEventToWebsocket(event, alarmSys, webSocket);\n        }\n    }\n}\n\n/*! Filter for events which are interesting for the alarm system.\n */\nstatic bool isAlarmSystemDeviceEvent(const Event &event)\n{\n    if (event.what()[0] != 's') // only interested in state/*\n    {\n        return false;\n    }\n\n    if (event.resource() == RSensors)\n    {\n        if (event.what() == RStatePresence)    { return event.num() > 0; }\n        if (event.what() == RStateOpen)        { return event.num() > 0; }\n        if (event.what() == RStateVibration)   { return event.num() > 0; }\n        if (event.what() == RStateButtonEvent) { return true; }\n        if (event.what() == RStateAction)\n        {\n            if (event.num() >= IAS_ACE_CMD_EMERGENCY && event.num() <= IAS_ACE_CMD_PANIC)\n            {\n                return true;\n            }\n        }\n    }\n    else if (event.resource() == RLights)\n    {\n        if (event.what() == RStateOn) { return event.num() > 0; }\n    }\n\n    return false;\n}\n\n/*! For devices which are added to an alarm system transform matching events into REventDeviceAlarm events.\n\n    When armed, the alarm system enters the entry delay state.\n */\nvoid AS_HandleAlarmSystemDeviceEvent(const Event &event, const AS_DeviceTable *devTable, EventEmitter *eventEmitter)\n{\n    if (!isAlarmSystemDeviceEvent(event))\n    {\n        return;\n    }\n\n    Resource *r = plugin->getResource(event.resource(), event.id());\n    if (!r)\n    {\n        return;\n    }\n\n    ResourceItem *uniqueId = r->item(RAttrUniqueId);\n    if (!uniqueId)\n    {\n        return;\n    }\n\n    const AS_DeviceEntry &entry = devTable->get(uniqueId->toString());\n    if (!isValid(entry))\n    {\n        return;\n    }\n\n    ResourceItem *item = r->item(event.what());\n    if (!item)\n    {\n        return;\n    }\n\n    int eventData = entry.alarmSystemId;\n     // arm mask\n    eventData |= entry.flags & (AS_ENTRY_FLAG_ARMED_AWAY | AS_ENTRY_FLAG_ARMED_STAY | AS_ENTRY_FLAG_ARMED_NIGHT);\n\n    eventEmitter->enqueueEvent(Event(RAlarmSystems, REventDeviceAlarm, eventData));\n}\n"
        },
        {
          "name": "alarm_system_event_handler.h",
          "type": "blob",
          "size": 0.7265625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef ALARM_SYSTEM_EVENT_HANDLER_H\n#define ALARM_SYSTEM_EVENT_HANDLER_H\n\nclass Event;\nclass EventEmitter;\nclass AlarmSystems;\nclass AS_DeviceTable;\nclass WebSocketServer;\n\nvoid AS_HandleAlarmSystemEvent(const Event &event, AlarmSystems &alarmSystems, EventEmitter *eventEmitter, WebSocketServer *webSocket);\nvoid AS_HandleAlarmSystemDeviceEvent(const Event &event, const AS_DeviceTable *devTable, EventEmitter *eventEmitter);\n\n#endif // ALARM_SYSTEM_EVENT_HANDLER_H\n"
        },
        {
          "name": "appliances.cpp",
          "type": "blob",
          "size": 2.2265625,
          "content": "#include <QDataStream>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n// server receive\n#define CMD_GET_ALERTS              0x00\n// server send\n#define CMD_GET_ALERTS_RESPONSE     0x00\n#define CMD_ALERTS_NOTIFICATION     0x01\n#define CMD_EVENT_NOTIFICATION      0x02\n\n// read flags\n#define ALERTS_ALERT (1 << 12)\n\n/*! Handle packets related to the Appliance Alerts and Events cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Appliance Alerts and Events server command\n */\nvoid DeRestPluginPrivate::handleApplianceAlertClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (!(zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient))\n    {\n        return;\n    }\n    \n    if (zclFrame.commandId() == CMD_ALERTS_NOTIFICATION && zclFrame.isClusterCommand())\n    {\n        // Specific to leakSMART water sensor V2\n        Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAWater\"));\n\n        if (!sensor)\n        {\n            DBG_Printf(DBG_INFO, \"No water leak sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n            return;\n        }\n\n        quint8 alertsCount;      // Count is just 4 Bits but doesn't matter right now\n        quint16 alertsStructure; // 24 Bit long, but 16 suffice\n\n        stream >> alertsCount;\n        stream >> alertsStructure;\n        \n        ResourceItem *item = sensor ? sensor->item(RStateWater) : nullptr;\n\n        if (sensor && item)\n        {\n            if (alertsStructure & ALERTS_ALERT)\n            {\n                item->setValue(true);\n            }\n            else\n            {\n                item->setValue(false);\n            }\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateWater, sensor->id(), item));\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            updateSensorEtag(&*sensor);\n        }\n    }\n}\n"
        },
        {
          "name": "aps_controller_wrapper.cpp",
          "type": "blob",
          "size": 6.1044921875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <deconz/zdp_profile.h>\n#include <deconz/aps_controller.h>\n#include <deconz/dbg_trace.h>\n#include <deconz/zcl.h>\n#include \"utils/utils.h\"\n#include \"aps_controller_wrapper.h\"\n\n// enable domain specific string literals\nusing namespace deCONZ::literals;\n\n//! Sends a ZCL Default Response based on parameters from the request in \\p ind and \\p zclFrame.\nstatic bool ZCL_SendDefaultResponse(deCONZ::ApsController *apsCtrl, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, quint8 status)\n{\n    deCONZ::ApsDataRequest apsReq;\n\n    // ZDP Header\n    apsReq.dstAddress() = ind.srcAddress();\n    apsReq.setDstAddressMode(ind.srcAddressMode());\n    apsReq.setDstEndpoint(ind.srcEndpoint());\n    apsReq.setSrcEndpoint(ind.dstEndpoint());\n    apsReq.setProfileId(ind.profileId());\n    apsReq.setRadius(0);\n    apsReq.setClusterId(ind.clusterId());\n    apsReq.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n\n    deCONZ::ZclFrame outZclFrame;\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(deCONZ::ZclDefaultResponseId);\n\n    if (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient)\n    {\n        outZclFrame.setFrameControl(deCONZ::ZclFCProfileCommand | deCONZ::ZclFCDirectionClientToServer | deCONZ::ZclFCDisableDefaultResponse);\n    }\n    else\n    {\n        outZclFrame.setFrameControl(deCONZ::ZclFCProfileCommand | deCONZ::ZclFCDirectionServerToClient | deCONZ::ZclFCDisableDefaultResponse);\n    }\n\n    if (zclFrame.manufacturerCode_t() != 0x0000_mfcode)\n    {\n        outZclFrame.setFrameControl(outZclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        outZclFrame.setManufacturerCode(zclFrame.manufacturerCode_t());\n    }\n\n    { // ZCL payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        stream << zclFrame.commandId();\n        stream << status;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    return apsCtrl->apsdeDataRequest(apsReq) == deCONZ::Success;\n}\n\n//! Returns true if \\p zclFrame requires a ZCL Default Response.\nstatic bool ZCL_NeedDefaultResponse(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return false;\n    }\n\n    if (ind.dstAddressMode() == deCONZ::ApsNwkAddress) // only respond to unicast\n    {\n        if (!(zclFrame.frameControl() & deCONZ::ZclFCDisableDefaultResponse))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//! Returns true if \\p req contains a specific or ZCL Default Response for \\p indZclFrame.\nstatic bool ZCL_IsResponse(const deCONZ::ZclFrame &indZclFrame, const deCONZ::ApsDataRequest &req)\n{\n    if (req.asdu().size() < 3) // need at least frame control | seqno | command id\n    {\n        return false;\n    }\n\n    // frame control | [manufacturer code] | seqno | command id\n    quint8 seq;\n    quint8 commandId;\n\n    if (req.asdu().size() >= 5 && req.asdu().at(0) & deCONZ::ZclFCManufacturerSpecific)\n    {\n        seq = static_cast<quint8>(req.asdu().at(3));\n        commandId = static_cast<quint8>(req.asdu().at(4));\n    }\n    else\n    {\n        seq = static_cast<quint8>(req.asdu().at(1));\n        commandId = static_cast<quint8>(req.asdu().at(2));\n    }\n\n    if (seq == indZclFrame.sequenceNumber())\n    {\n        if (commandId == deCONZ::ZclDefaultResponseId)\n        {\n            return true;\n        }\n\n        // Request and response command ids can differ, match for sequence number _should_ be fine.\n        // If we see false positives, mappings need to be created on per cluster base.\n        return true;\n    }\n\n    return false;\n}\n\nApsControllerWrapper::ApsControllerWrapper(deCONZ::ApsController *ctrl) :\n    m_apsCtrl(ctrl)\n{\n\n}\n\nint ApsControllerWrapper::apsdeDataRequest(const deCONZ::ApsDataRequest &req)\n{\n    if (!m_apsCtrl)\n    {\n        return deCONZ::ErrorNotConnected;\n    }\n    if (m_zclDefaultResponder)\n    {\n        m_zclDefaultResponder->checkApsdeDataRequest(req);\n    }\n    return m_apsCtrl->apsdeDataRequest(req);\n}\n\nZclDefaultResponder::ZclDefaultResponder(ApsControllerWrapper *apsCtrlWrapper, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame) :\n    m_apsCtrlWrapper(apsCtrlWrapper),\n    m_ind(ind),\n    m_zclFrame(zclFrame)\n{\n    // ZCL only and ignore OTA commands as these are handled by the OTA plugin\n    if (m_ind.profileId() != ZDP_PROFILE_ID && m_ind.clusterId() != 0x0019)\n    {\n        m_apsCtrlWrapper->registerZclDefaultResponder(this);\n        m_state = State::Watch;\n    }\n}\n\n/*! When the APS indication function ends this destructor sends the ZCL Default Response if needed (RAII).\n */\nZclDefaultResponder::~ZclDefaultResponder()\n{\n    if (m_state == State::Init) // ZDP indications\n    {\n        return;\n    }\n\n    m_apsCtrlWrapper->clearZclDefaultResponder();\n\n    if (m_state == State::Watch)\n    {\n        if (ZCL_NeedDefaultResponse(m_ind, m_zclFrame))\n        {\n            ZCL_SendDefaultResponse(m_apsCtrlWrapper->apsController(), m_ind, m_zclFrame, deCONZ::ZclSuccessStatus);\n        }\n    }\n}\n\n/*! During life time checks if \\p req is a response to the contained request.\n */\nvoid ZclDefaultResponder::checkApsdeDataRequest(const deCONZ::ApsDataRequest &req)\n{\n    if (m_state != State::Watch) { return; }\n\n    if (!isSameAddress(m_ind.srcAddress(), req.dstAddress())) {  return; }\n    if (req.profileId() != m_ind.profileId()) {  return; }\n    if (req.clusterId() != m_ind.clusterId()) {  return; }\n\n    if (ZCL_NeedDefaultResponse(m_ind, m_zclFrame)) // check here since in constructor m_zclFrame isn't parsed yet\n    {\n        if (ZCL_IsResponse(m_zclFrame, req))\n        {\n            m_state = State::HasResponse;\n        }\n    }\n    else\n    {\n        m_state = State::NoResponseNeeded;\n    }\n}\n"
        },
        {
          "name": "aps_controller_wrapper.h",
          "type": "blob",
          "size": 1.998046875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef APS_CONTROLLER_WRAPPER_H\n#define APS_CONTROLLER_WRAPPER_H\n\nnamespace  deCONZ {\n    class ApsController;\n    class ApsDataIndication;\n    class ApsDataRequest;\n    class ZclFrame;\n}\n\nclass ApsControllerWrapper;\n\n/*! RAII helper to send a ZCL Default Response after APS indication if needed.\n\n    The class observes outgoing APS requests for specific responses for a request and\n    automatically sends a ZCL Default Response if no specifc response was send.\n */\nclass ZclDefaultResponder\n{\npublic:\n    ZclDefaultResponder() = delete;\n    explicit ZclDefaultResponder(ApsControllerWrapper *apsCtrlWrapper, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    ~ZclDefaultResponder();\n    void checkApsdeDataRequest(const deCONZ::ApsDataRequest &req);\n\nprivate:\n    enum class State\n    {\n        Init,\n        NoResponseNeeded,\n        Watch,\n        HasResponse\n    };\n    ApsControllerWrapper *m_apsCtrlWrapper = nullptr;\n    const deCONZ::ApsDataIndication &m_ind;\n    const deCONZ::ZclFrame &m_zclFrame;\n    State m_state = State::Init;\n};\n\n/*! Wraps \\c deCONZ::ApsController to intercept apsdeDataRequest().\n\n    The main purpose is to deterministic send ZCL Default Response if needed.\n */\nclass ApsControllerWrapper\n{\npublic:\n    ApsControllerWrapper(deCONZ::ApsController *ctrl);\n    int apsdeDataRequest(const deCONZ::ApsDataRequest &req);\n    void registerZclDefaultResponder(ZclDefaultResponder *resp) { m_zclDefaultResponder = resp; }\n    void clearZclDefaultResponder() { m_zclDefaultResponder = nullptr; };\n    deCONZ::ApsController *apsController() { return m_apsCtrl; }\n\nprivate:\n    deCONZ::ApsController *m_apsCtrl = nullptr;\n    ZclDefaultResponder *m_zclDefaultResponder = nullptr;\n};\n\n#endif // APS_CONTROLLER_WRAPPER_H\n"
        },
        {
          "name": "authorisation.cpp",
          "type": "blob",
          "size": 7.07421875,
          "content": "/*\n * Copyright (c) 2013-2019 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QCryptographicHash>\n#include <QMessageAuthenticationCode>\n#include \"crypto/password.h\"\n#include \"de_web_plugin_private.h\"\n\n#define AUTH_KEEP_ALIVE 240\n\nApiAuth::ApiAuth() :\n    needSaveDatabase(false),\n    state(StateNormal)\n{\n\n}\n\n/*! Set and process device type.\n */\nvoid ApiAuth::setDeviceType(const QString &devtype)\n{\n    devicetype = devtype;\n}\n\n/*! Init authentication.\n */\nvoid DeRestPluginPrivate::initAuthentication()\n{\n    bool ok = false;\n\n    if (gwConfig.contains(\"gwusername\") && gwConfig.contains(\"gwpassword\"))\n    {\n        gwAdminUserName = gwConfig[\"gwusername\"].toString();\n        gwAdminPasswordHash = gwConfig[\"gwpassword\"].toString().toStdString();\n\n        if (!gwAdminUserName.isEmpty() && gwAdminPasswordHash.size() > 0)\n        {\n            ok = true;\n        }\n    }\n\n    if (!ok)\n    {\n        // generate default username and password\n        gwAdminUserName = \"delight\";\n        gwAdminPasswordHash = \"delight\";\n\n        DBG_Printf(DBG_INFO, \"create default username and password\\n\");\n\n        // combine username:password\n        QString comb = QString(\"%1:%2\").arg(gwAdminUserName).arg(gwAdminPasswordHash.c_str());\n\n        // create base64 encoded version as used in HTTP basic authentication\n        std::string hash = comb.toLocal8Bit().toBase64().toStdString();\n\n        gwAdminPasswordHash = CRYPTO_EncryptGatewayPassword(hash);\n\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\n    }\n}\n\n/*! Use HTTP basic authentication or HMAC token to check if the request\n    has valid credentials to create API key.\n */\nbool DeRestPluginPrivate::allowedToCreateApikey(const ApiRequest &req, ApiResponse &rsp, QVariantMap &map)\n{\n    if (req.hdr.hasKey(QLatin1String(\"Authorization\")))\n    {\n        const QString auth(req.hdr.value(QLatin1String(\"Authorization\")));\n        const QStringList ls = auth.split(' ');\n\n        if ((ls.size() > 1) && ls[0] == \"Basic\")\n        {\n            std::string pwhash = ls[1].toStdString();\n            std::string enc = CRYPTO_EncryptGatewayPassword(pwhash);\n\n            if (enc == gwAdminPasswordHash)\n            {\n                return true;\n            }\n            else if (pwhash == gwAdminPasswordHash)\n            {\n                return true; // on Windows plain hash was stored\n            }\n\n            DBG_Printf(DBG_INFO, \"Invalid admin password hash\\n\");\n        }\n    }\n\n    if (apsCtrl && map.contains(QLatin1String(\"hmac-sha256\")))\n    {\n        QDateTime now = QDateTime::currentDateTime();\n        QByteArray remoteHmac = map[\"hmac-sha256\"].toByteArray();\n        QByteArray sec0 = apsCtrl->getParameter(deCONZ::ParamSecurityMaterial0);\n        QByteArray installCode = sec0.mid(0, 16);\n\n        if (!gwLastChallenge.isValid() || gwLastChallenge.secsTo(now) > (60 * 10))\n        {\n            rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, QString(\"/api/challenge\"), QString(\"no active challange\")));\n            rsp.httpStatus = HttpStatusForbidden;\n            return false;\n        }\n\n        QByteArray hmac = QMessageAuthenticationCode::hash(gwChallenge, installCode, QCryptographicHash::Sha256).toHex();\n\n        if (remoteHmac == hmac)\n        {\n            return true;\n        }\n\n        DBG_Printf(DBG_INFO, \"expected challenge response: %s\\n\", qPrintable(hmac));\n        rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, QString(\"/api/challenge\"), QString(\"invalid challange response\")));\n        rsp.httpStatus = HttpStatusForbidden;\n        return false;\n    }\n\n    rsp.httpStatus = HttpStatusForbidden;\n    rsp.list.append(errorToMap(ERR_LINK_BUTTON_NOT_PRESSED, \"/\", \"link button not pressed\"));\n    return false;\n}\n\n/*! Authorise API access for the request.\n */\nvoid DeRestPluginPrivate::authorise(ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(rsp);\n\n    QHostAddress localHost(QHostAddress::LocalHost);\n    if (req.sock->peerAddress() == localHost)\n    {\n        req.auth = ApiAuthLocal;\n    }\n\n    if (req.sock == nullptr) // allow internal requests, as they are issued by triggering rules\n    {\n        req.auth = ApiAuthInternal;\n    }\n\n    QString apikey = req.apikey();\n    apiAuthCurrent = apiAuths.size();\n\n    if (apikey.isEmpty())\n    {\n        return;\n    }\n\n    std::vector<ApiAuth>::iterator i = apiAuths.begin();\n    std::vector<ApiAuth>::iterator end = apiAuths.end();\n\n    for (size_t pos = 0; i != end; ++i, pos++)\n    {\n        if (apikey == i->apikey && i->state == ApiAuth::StateNormal)\n        {\n            apiAuthCurrent = pos;\n            i->lastUseDate = QDateTime::currentDateTimeUtc();\n\n            // fill in useragent string if not already exist\n            if (i->useragent.isEmpty())\n            {\n                if (req.hdr.hasKey(QLatin1String(\"User-Agent\")))\n                {\n                    i->useragent = req.hdr.value(QLatin1String(\"User-Agent\"));\n                    DBG_Printf(DBG_HTTP, \"set useragent '%s' for apikey '%s'\\n\", qPrintable(i->useragent), qPrintable(i->apikey));\n                }\n            }\n\n            if (req.sock)\n            {\n                for (TcpClient &cl : openClients)\n                {\n                    if (cl.sock == req.sock && cl.closeTimeout > 0)\n                    {\n                        cl.closeTimeout = AUTH_KEEP_ALIVE;\n                        break;\n                    }\n                }\n            }\n\n            if ((!(i->useragent.isEmpty()) && i->useragent.startsWith(QLatin1String(\"iConnect\"))) || i->devicetype.startsWith(QLatin1String(\"iConnectHue\")))\n            {\n                req.mode = ApiModeStrict;\n            }\n            else if (i->devicetype.startsWith(QLatin1String(\"Echo\")))\n            {\n                req.mode = ApiModeEcho;\n            }\n            else if (i->devicetype.startsWith(QLatin1String(\"Hue Essentials\")))\n            {\n                // supports deCONZ specifics\n            }\n            else if (i->devicetype.startsWith(QLatin1String(\"hue_\")) ||\n                     i->devicetype.startsWith(QLatin1String(\"Hue \")) ||\n                     gwHueMode)\n            {\n                req.mode = ApiModeHue;\n            }\n            DBG_Printf(DBG_HTTP, \"ApiMode: %d\\n\", req.mode);\n\n            i->needSaveDatabase = true;\n            if (!apiAuthSaveDatabaseTime.isValid() || apiAuthSaveDatabaseTime.elapsed() > (1000 * 60 * 30))\n            {\n                apiAuthSaveDatabaseTime.start();\n                queSaveDb(DB_AUTH, DB_HUGE_SAVE_DELAY);\n            }\n            req.auth = ApiAuthFull;\n        }\n    }\n\n#if 0\n    // allow non registered devices to use the api if the link button is pressed\n    if (gwLinkButton)\n    {\n        ApiAuth auth;\n        auth.needSaveDatabase = true;\n        auth.apikey = apikey;\n        auth.devicetype = \"unknown\";\n        auth.createDate = QDateTime::currentDateTimeUtc();\n        auth.lastUseDate = QDateTime::currentDateTimeUtc();\n        apiAuths.push_back(auth);\n        queSaveDb(DB_AUTH, DB_SHORT_SAVE_DELAY);\n        return true;\n    }\n#endif\n\n}\n"
        },
        {
          "name": "backup.cpp",
          "type": "blob",
          "size": 22.6083984375,
          "content": "/*\n * Copyright (c) 2021-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QCoreApplication>\n#include <QDateTime>\n#include <QDir>\n#include <QFile>\n#include <QProcess>\n#include <QTextStream>\n#include <array>\n#include <stack>\n#include \"deconz/aps_controller.h\"\n#include \"deconz/dbg_trace.h\"\n#include \"deconz/util.h\"\n#include \"backup.h\"\n#include \"json.h\"\n#include \"crypto/random.h\"\n\n#define EXT_PROCESS_TIMEOUT 30000\n\nusing TmpFiles = std::array<const char*, 3>;\n\nstatic bool cleanupTemporaryFiles(const QString &path, const TmpFiles &files)\n{\n    for (const auto &f : files)\n    {\n        if (!f) { continue; } // some elements can be nullptr\n\n        const QString filePath = path + QLatin1String(f);\n        if (QFile::exists(filePath))\n        {\n            if (!QFile::remove(filePath))\n            {\n                DBG_Printf(DBG_ERROR, \"backup: failed to remove temporary file %s\\n\", qPrintable(filePath));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/*! Export the deCONZ network settings to a file.\n */\nbool BAK_ExportConfiguration(deCONZ::ApsController *apsCtrl)\n{\n    if (!apsCtrl)\n    {\n        return false;\n    }\n\n    const QString path = deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation);\n\n    // cleanup older files\n    if (!cleanupTemporaryFiles(path, { \"/deCONZ.conf\", \"/deCONZ.tar\", \"/deCONZ.tar.gz\" }))\n    {\n        return false;\n    }\n\n    {\n        uint8_t deviceType = apsCtrl->getParameter(deCONZ::ParamDeviceType);\n        uint16_t panId = apsCtrl->getParameter(deCONZ::ParamPANID);\n        quint64 extPanId = apsCtrl->getParameter(deCONZ::ParamExtendedPANID);\n        quint64 apsUseExtPanId = apsCtrl->getParameter(deCONZ::ParamApsUseExtendedPANID);\n        uint64_t macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n        uint16_t nwkAddress = apsCtrl->getParameter(deCONZ::ParamNwkAddress);\n        uint8_t apsAck = apsCtrl->getParameter(deCONZ::ParamApsAck);\n        uint8_t staticNwkAddress = apsCtrl->getParameter(deCONZ::ParamStaticNwkAddress);\n        // uint32_t channelMask = apsCtrl->getParameter(deCONZ::ParamChannelMask);\n        uint8_t curChannel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\n        uint8_t otauActive = apsCtrl->getParameter(deCONZ::ParamOtauActive);\n        uint8_t securityMode = apsCtrl->getParameter(deCONZ::ParamSecurityMode);\n        quint64 tcAddress = apsCtrl->getParameter(deCONZ::ParamTrustCenterAddress);\n        QByteArray networkKey = apsCtrl->getParameter(deCONZ::ParamNetworkKey);\n        QByteArray tcLinkKey = apsCtrl->getParameter(deCONZ::ParamTrustCenterLinkKey);\n        uint8_t nwkUpdateId = apsCtrl->getParameter(deCONZ::ParamNetworkUpdateId);\n        QVariantMap endpoint1 = apsCtrl->getParameter(deCONZ::ParamHAEndpoint, 0);\n        QVariantMap endpoint2 = apsCtrl->getParameter(deCONZ::ParamHAEndpoint, 1);\n\n        // simple checks to prevent invalid config export\n        if (deviceType != deCONZ::Coordinator) { return false; }\n        if (securityMode != 3) { return false; } // High - No master but TC link key\n        if (nwkAddress != 0x0000) { return  false; }\n        if (panId == 0) { return  false; }\n        if (macAddress == 0) { return  false; }\n        if (tcAddress == 0) { return  false; }\n        if (curChannel < 11 || curChannel > 26) { return  false; }\n\n        QVariantMap map;\n        map[\"deviceType\"] = deviceType;\n        map[\"panId\"] = QString(\"0x%1\").arg(QString::number(panId, 16));\n        map[\"extPanId\"] = QString(\"0x%1\").arg(QString::number(extPanId, 16));\n        map[\"apsUseExtPanId\"] = QString(\"0x%1\").arg(QString::number(apsUseExtPanId, 16));\n        map[\"macAddress\"] = QString(\"0x%1\").arg(QString::number(macAddress, 16));\n        map[\"staticNwkAddress\"] = (staticNwkAddress == 0) ? false : true;\n        map[\"nwkAddress\"] = QString(\"0x%1\").arg(QString::number(nwkAddress, 16));\n        map[\"apsAck\"] = (apsAck == 0) ? false : true;\n        //map[\"channelMask\"] = channelMask;\n        map[\"curChannel\"] = curChannel;\n        map[\"otauactive\"] = otauActive;\n        map[\"securityMode\"] = securityMode;\n        map[\"tcAddress\"] = QString(\"0x%1\").arg(QString::number(tcAddress,16));\n        map[\"networkKey\"] = networkKey.toHex();\n        map[\"tcLinkKey\"] = tcLinkKey.toHex();\n        map[\"nwkUpdateId\"] = nwkUpdateId;\n        map[\"endpoint1\"] = endpoint1;\n        map[\"endpoint2\"] = endpoint2;\n        map[\"deconzVersion\"] = QString(GW_SW_VERSION).replace(QChar('.'), \"\");\n\n        {\n            quint32 frameCounter = apsCtrl->getParameter(deCONZ::ParamFrameCounter);\n            if (frameCounter > 0)\n            {\n                map[\"frameCounter\"] = frameCounter;\n            }\n        }\n\n        bool ok = true;\n        QString saveString = Json::serialize(map, ok);\n\n        DBG_Assert(ok);\n        if (!ok)\n        {\n            return false;\n        }\n\n        // put config as JSON object in file\n        QFile configFile(path + \"/deCONZ.conf\");\n        if (configFile.open(QIODevice::ReadWrite))\n        {\n            QTextStream stream(&configFile);\n            stream << saveString << \"\\n\";\n            configFile.close();\n        }\n    }\n\n    if (QFile::exists(path + \"/deCONZ.conf\"))\n    {\n        //create .tar\n        QProcess archProcess;\n\n#ifdef Q_OS_WIN\n        const QString appPath = qApp->applicationDirPath();\n        {\n            if (!QFile::exists(appPath + \"/7za.exe\"))\n            {\n                DBG_Printf(DBG_INFO, \"7z not found: %s\\n\", qPrintable(appPath + \"/7za.exe\"));\n                return false;\n            }\n            QString cmd = appPath + \"/7za.exe\";\n            QStringList args;\n            args.append(\"a\");\n            args.append(path + \"/deCONZ.tar\");\n            args.append(path + \"/deCONZ.conf\");\n            args.append(path + \"/zll.db\");\n            args.append(path + \"/session.default\");\n            archProcess.start(cmd, args);\n        }\n#endif\n\n#ifdef Q_OS_LINUX\n        // clean up old homebridge backup files\n        const QStringList filters{ \"AccessoryInfo*\", \"IdentifierCache*\" };\n\n        {\n            QDir appDir(path);\n            const QStringList files = appDir.entryList(filters);\n\n            for (const auto &f : files)\n            {\n                const QString filePath = path + \"/\" + f;\n                if (QFile::exists(filePath))\n                {\n                    if (QFile::remove(filePath))\n                    {\n                        DBG_Printf(DBG_INFO, \"backup: removed temporary homebridge file %s\\n\", qPrintable(filePath));\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_ERROR, \"backup: failed to remove temporary homebridge file %s\\n\", qPrintable(filePath));\n                        return false;\n                    }\n                }\n            }\n        }\n\n        // backup homebridge files\n        const QString homebridgePersistPath = \"/home/pi/.homebridge/persist\"; // TODO: get mainuser\n\n        QString FirstFileName =\"\";\n        QString SecondFileName =\"\";\n\n        QDir dir(homebridgePersistPath);\n        if (dir.exists())\n        {\n            QStringList files = dir.entryList(filters);\n\n            if (files.size() > 0)\n            {\n                FirstFileName = files.at(0);\n                DBG_Printf(DBG_INFO, \"copy file: %s to backup directory\\n\", qPrintable(FirstFileName));\n                QFile accessoryFile(homebridgePersistPath + \"/\" + FirstFileName);\n                if (!accessoryFile.copy(path + \"/\" + FirstFileName))\n                {\n                    DBG_Printf(DBG_INFO, \"copy file: %s failed. Do not include it in backup\\n\", qPrintable(FirstFileName));\n                    FirstFileName = \"\";\n                    return false;\n                }\n\n            }\n            if (files.size() > 1)\n            {\n                SecondFileName = files.at(1);\n                DBG_Printf(DBG_INFO, \"copy file: %s to backup directory\\n\", qPrintable(SecondFileName));\n                QFile IdentifierFile(homebridgePersistPath + \"/\" + SecondFileName);\n                if (!IdentifierFile.copy(path + \"/\" + SecondFileName))\n                {\n                    DBG_Printf(DBG_INFO, \"copy file: %s failed. Do not include it in backup\\n\", qPrintable(SecondFileName));\n                    SecondFileName = \"\";\n                    return false;\n                }\n            }\n        }\n\n        // add homebridge-install logfiles to archive\n        QString logfilesDirectories = \"\";\n        QDir homebridgeInstallLogDir(path + \"/homebridge-install-logfiles\");\n        if (homebridgeInstallLogDir.exists())\n        {\n            logfilesDirectories += QLatin1String(\"homebridge-install-logfiles\");\n        }\n#endif\n#ifdef Q_OS_UNIX\n        {\n            QStringList args;\n            args.append(\"-cf\");\n            args.append(path + \"/deCONZ.tar\");\n            args.append(\"-C\");\n            args.append(path);\n            args.append(\"deCONZ.conf\");\n            args.append(\"zll.db\");\n            args.append(\"session.default\");\n#ifdef Q_OS_LINUX\n            args.append(FirstFileName);\n            args.append(SecondFileName);\n            args.append(logfilesDirectories);\n#endif\n            archProcess.start(\"tar\", args);\n        }\n#endif\n        archProcess.waitForFinished(EXT_PROCESS_TIMEOUT);\n        DBG_Printf(DBG_INFO, \"%s\\n\", qPrintable(archProcess.readAllStandardOutput()));\n\n        //create .tar.gz\n        {\n            QProcess zipProcess;\n            QStringList args;\n#ifdef Q_OS_WIN\n            QString cmd = appPath + \"/7za.exe\";\n\n            args.append(\"a\");\n            args.append(path + \"/deCONZ.tar.gz\");\n            args.append(path + \"/deCONZ.tar\");\n            zipProcess.start(cmd, args);\n#endif\n#ifdef Q_OS_UNIX\n            args.append(\"-k\");\n            args.append(\"-f\");\n            args.append(path + \"/deCONZ.tar\");\n            zipProcess.start(\"gzip\", args);\n#endif\n            zipProcess.waitForFinished(EXT_PROCESS_TIMEOUT);\n            DBG_Printf(DBG_INFO, \"%s\\n\", qPrintable(zipProcess.readAllStandardOutput()));\n        }\n    }\n\n    //cleanup\n    if (!cleanupTemporaryFiles(path, { \"/deCONZ.conf\", \"/deCONZ.tar\" }))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n/*! Import the deCONZ network settings from a file.\n */\nbool BAK_ImportConfiguration(deCONZ::ApsController *apsCtrl)\n{\n    if (!apsCtrl)\n    {\n        return false;\n    }\n\n    const QString path = deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation);\n\n    if (!cleanupTemporaryFiles(path, { \"/deCONZ.conf\", \"/deCONZ.tar\" }))\n    {\n        return false;\n    }\n\n#ifdef Q_OS_LINUX\n    // clean up old homebridge backup files\n    {\n        const QStringList filters{ \"AccessoryInfo*\", \"IdentifierCache*\" };\n\n         const QDir appDir(path);\n         const QStringList files = appDir.entryList(filters);\n\n         for (const auto &f : files)\n         {\n             const QString filePath = path + \"/\" + f;\n             if (QFile::exists(filePath))\n             {\n                 if (QFile::remove(filePath))\n                 {\n                     DBG_Printf(DBG_INFO, \"backup: removed temporary homebridge file %s\\n\", qPrintable(filePath));\n                 }\n                 else\n                 {\n                     DBG_Printf(DBG_ERROR, \"backup: failed to remove temporary homebridge file %s\\n\", qPrintable(filePath));\n                     return false;\n                 }\n             }\n         }\n     }\n #endif\n\n    if (QFile::exists(path + QLatin1String(\"/deCONZ.tar.gz\")))\n    {\n        // decompress .tar.gz\n        QProcess archProcess;\n        QStringList args;\n\n#ifdef Q_OS_WIN\n        const QString appPath = qApp->applicationDirPath();\n        const QString cmd = appPath + \"/7za.exe\";\n        args.append(\"e\");\n        args.append(\"-y\");\n        args.append(path + \"/deCONZ.tar.gz\");\n        args.append(\"-o\" + path);\n        archProcess.start(cmd, args);\n#endif\n#ifdef Q_OS_UNIX\n        args.append(\"-df\");\n        args.append(path + \"/deCONZ.tar.gz\");\n        archProcess.start(\"gzip\", args);\n#endif\n        archProcess.waitForFinished(EXT_PROCESS_TIMEOUT);\n        DBG_Printf(DBG_INFO, \"%s\\n\", qPrintable(archProcess.readAllStandardOutput()));\n    }\n\n    if (QFile::exists(path + QLatin1String(\"/deCONZ.tar\")))\n    {\n        // unpack .tar\n        QProcess zipProcess;\n        QStringList args;\n#ifdef Q_OS_WIN\n        const  QString appPath = qApp->applicationDirPath();\n        const QString cmd = appPath + \"/7za.exe\";\n        args.append(\"e\");\n        args.append(\"-y\");\n        args.append(path + \"/deCONZ.tar\");\n        args.append(\"-o\" + path);\n        zipProcess.start(cmd, args);\n#endif\n#ifdef Q_OS_UNIX\n        args.append(\"-xf\");\n        args.append(path + \"/deCONZ.tar\");\n        args.append(\"-C\");\n        args.append(path);\n        zipProcess.start(\"tar\", args);\n#endif\n        zipProcess.waitForFinished(EXT_PROCESS_TIMEOUT);\n        DBG_Printf(DBG_INFO, \"%s\\n\", qPrintable(zipProcess.readAllStandardOutput()));\n    }\n\n    QVariantMap map;\n    {\n        QFile file(path + QLatin1String(\"/deCONZ.conf\"));\n        if (file.exists() && file.open(QIODevice::ReadOnly))\n        {\n            bool ok = false;\n            const QString json = file.readAll();\n            QVariant var = Json::parse(json, ok);\n            if (ok)\n            {\n                map = var.toMap();\n            }\n        }\n    }\n\n    cleanupTemporaryFiles(path, { \"/deCONZ.conf\", \"/deCONZ.tar\", \"/deCONZ.tar.gz\" });\n\n    const std::array<const char*, 14> requiredFields = {\n        \"deviceType\", \"panId\", \"extPanId\", \"apsUseExtPanId\", \"macAddress\", \"staticNwkAddress\",\n        \"nwkAddress\", \"apsAck\", \"curChannel\", \"tcAddress\", \"securityMode\", \"networkKey\", \"tcLinkKey\",\n        \"nwkUpdateId\"\n    };\n\n    for (const auto *key : requiredFields)\n    {\n        if (!map.contains(QLatin1String(key)))\n        {\n            return false;\n        }\n    }\n\n    {\n        bool ok = false;\n        uint8_t deviceType = map[\"deviceType\"].toUInt(&ok);\n\n        // only coordinator supported currently\n        if (!ok || deviceType != deCONZ::Coordinator)\n        {\n            return false;\n        }\n\n        uint16_t panId =  ok ? map[\"panId\"].toString().toUShort(&ok, 16) : 0;\n        if (ok && panId == 0) { ok = false; }\n\n        quint64 extPanId =  ok ? map[\"extPanId\"].toString().toULongLong(&ok, 16) : 0;\n        if (ok && extPanId == 0) { ok = false; }\n\n        quint64 apsUseExtPanId = ok ? map[\"apsUseExtPanId\"].toString().toULongLong(&ok, 16) : 1;\n        if (ok && apsUseExtPanId != 0) { ok = false; } // must be zero\n\n        quint64 curMacAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n        quint64 macAddress =  ok ? map[\"macAddress\"].toString().toULongLong(&ok, 16) : 0;\n        if (ok && macAddress == 0) { ok = false; }\n\n        uint8_t staticNwkAddress = map[\"staticNwkAddress\"].toBool() ? 1 : 0;\n        uint16_t nwkAddress = map[\"nwkAddress\"].toString().toUInt(&ok, 16);\n        if (ok && nwkAddress != 0x0000) { ok = false; } // coordinator\n\n        uint8_t apsAck = map[\"apsAck\"].toBool() ? 1 : 0;\n        //map[\"channelMask\"] = channelMask;\n        uint8_t curChannel = ok ? map[\"curChannel\"].toUInt(&ok) : 0;\n        if (ok && (curChannel < 11 || curChannel > 26)) { ok = false; }\n\n        if (ok && map.contains(\"otauactive\"))\n        {\n            uint8_t otauActive = map[\"otauactive\"].toUInt();\n            apsCtrl->setParameter(deCONZ::ParamOtauActive, otauActive);\n        }\n        uint8_t securityMode = ok ? map[\"securityMode\"].toUInt(&ok) : 0;\n        if (ok && securityMode != 3)\n        {\n            // auto correct, has been seen as 0..2\n            securityMode = 3; // High - No Master but TC Link key\n        }\n\n        quint64 tcAddress =  ok ? map[\"tcAddress\"].toString().toULongLong(&ok, 16) : 0;\n        if (ok && tcAddress != macAddress)\n        {\n            tcAddress = macAddress; // auto correct\n        }\n        QByteArray nwkKey = QByteArray::fromHex(map[\"networkKey\"].toByteArray());\n\n        if (map[\"tcLinkKey\"].toString() != QLatin1String(\"5a6967426565416c6c69616e63653039\"))\n        {\n            // auto correct\n            map[\"tcLinkKey\"] = QLatin1String(\"5a6967426565416c6c69616e63653039\"); // HA default TC link key\n        }\n\n        QByteArray tcLinkKey = QByteArray::fromHex(map[\"tcLinkKey\"].toByteArray());\n\n        uint8_t currentNwkUpdateId = apsCtrl->getParameter(deCONZ::ParamNetworkUpdateId);\n        uint8_t nwkUpdateId = ok ? map[\"nwkUpdateId\"].toUInt(&ok) : 0;\n\n        if (!ok) // TODO as alternative load network configuration from zll.db file\n        {\n            return false;\n        }\n\n        apsCtrl->setParameter(deCONZ::ParamDeviceType, deviceType);\n        apsCtrl->setParameter(deCONZ::ParamPredefinedPanId, 1);\n        apsCtrl->setParameter(deCONZ::ParamPANID, panId);\n        apsCtrl->setParameter(deCONZ::ParamExtendedPANID, extPanId);\n        apsCtrl->setParameter(deCONZ::ParamApsUseExtendedPANID, apsUseExtPanId);\n        if (curMacAddress != macAddress)\n        {\n            apsCtrl->setParameter(deCONZ::ParamCustomMacAddress, 1);\n        }\n        apsCtrl->setParameter(deCONZ::ParamMacAddress, macAddress);\n        apsCtrl->setParameter(deCONZ::ParamStaticNwkAddress, staticNwkAddress);\n        apsCtrl->setParameter(deCONZ::ParamNwkAddress, nwkAddress);\n        apsCtrl->setParameter(deCONZ::ParamApsAck, apsAck);\n        // channelMask\n        apsCtrl->setParameter(deCONZ::ParamCurrentChannel, curChannel);\n        apsCtrl->setParameter(deCONZ::ParamSecurityMode, securityMode);\n        apsCtrl->setParameter(deCONZ::ParamTrustCenterAddress, tcAddress);\n        apsCtrl->setParameter(deCONZ::ParamNetworkKey, nwkKey);\n        apsCtrl->setParameter(deCONZ::ParamTrustCenterLinkKey, tcLinkKey);\n        if (currentNwkUpdateId < nwkUpdateId)\n        {\n            apsCtrl->setParameter(deCONZ::ParamNetworkUpdateId, nwkUpdateId);\n        }\n\n        {\n            quint32 frameCounter = map[\"frameCounter\"].toUInt(&ok);\n            if (ok && frameCounter > 0)\n            {\n                apsCtrl->setParameter(deCONZ::ParamFrameCounter, frameCounter);\n            }\n        }\n\n        // HA endpoint\n        QVariantMap endpoint1;\n        endpoint1[\"endpoint\"] = QLatin1String(\"0x01\");\n        endpoint1[\"profileId\"] = QLatin1String(\"0x0104\");\n        endpoint1[\"deviceId\"] = QLatin1String(\"0x05\");\n        endpoint1[\"deviceVersion\"] = QLatin1String(\"0x01\");\n        endpoint1[\"inClusters\"] = QVariantList({ \"0x0000\", \"0x0019\", \"0x000A\"});\n        endpoint1[\"outClusters\"] = QVariantList({ \"0x0500\"});\n        endpoint1[\"index\"] = static_cast<double>(0);\n\n        // green power endpoint\n        QVariantMap endpoint2;\n        endpoint2[\"endpoint\"] = QLatin1String(\"0xf2\");\n        endpoint2[\"profileId\"] = QLatin1String(\"0xA1E0\");\n        endpoint2[\"deviceId\"] = QLatin1String(\"0x0064\");\n        endpoint2[\"deviceVersion\"] = QLatin1String(\"0x01\");\n        endpoint2[\"inClusters\"] = QVariantList();\n        endpoint2[\"outClusters\"] = QVariantList({ \"0x0021\"});\n        endpoint2[\"index\"] = static_cast<double>(1);\n\n        apsCtrl->setParameter(deCONZ::ParamHAEndpoint, endpoint1);\n        apsCtrl->setParameter(deCONZ::ParamHAEndpoint, endpoint2);\n    }\n\n    return true;\n}\n\n/*! Reset the deCONZ network settings and/or delete database.\n */\nbool BAK_ResetConfiguration(deCONZ::ApsController *apsCtrl, bool resetGW, bool deleteDB)\n{\n    if (!apsCtrl)\n    {\n        return false;\n    }\n\n    if (resetGW)\n    {\n        uint16_t panId;\n        CRYPTO_RandomBytes((unsigned char*)&panId, sizeof(panId));\n\n        uint8_t deviceType = deCONZ::Coordinator;\n        quint64 apsUseExtPanId = 0x0000000000000000;\n        uint16_t nwkAddress = 0x0000;\n        //uint32_t channelMask = 33554432; // 25\n        uint8_t curChannel = 11;\n        uint8_t securityMode = 3;\n        // TODO: original macAddress\n        quint64 macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n\n        if (macAddress == 0)\n        {\n            return false;\n        }\n\n        QByteArray nwkKey(16, '\\x00');\n        CRYPTO_RandomBytes((unsigned char*)nwkKey.data(), nwkKey.size());\n\n        QByteArray tcLinkKey = QByteArray::fromHex(\"5a6967426565416c6c69616e63653039\");\n        uint8_t nwkUpdateId = 1;\n\n        apsCtrl->setParameter(deCONZ::ParamDeviceType, deviceType);\n        apsCtrl->setParameter(deCONZ::ParamPredefinedPanId, 1);\n        apsCtrl->setParameter(deCONZ::ParamPANID, panId);\n        apsCtrl->setParameter(deCONZ::ParamApsUseExtendedPANID, apsUseExtPanId);\n        apsCtrl->setParameter(deCONZ::ParamExtendedPANID, macAddress);\n        apsCtrl->setParameter(deCONZ::ParamApsAck, 0);\n        apsCtrl->setParameter(deCONZ::ParamNwkAddress, nwkAddress);\n        //apsCtrl->setParameter(deCONZ::ParamChannelMask, channelMask);\n        apsCtrl->setParameter(deCONZ::ParamCurrentChannel, curChannel);\n        apsCtrl->setParameter(deCONZ::ParamSecurityMode, securityMode);\n        apsCtrl->setParameter(deCONZ::ParamTrustCenterAddress, macAddress);\n        apsCtrl->setParameter(deCONZ::ParamNetworkKey, nwkKey);\n        apsCtrl->setParameter(deCONZ::ParamTrustCenterLinkKey, tcLinkKey);\n        apsCtrl->setParameter(deCONZ::ParamNetworkUpdateId, nwkUpdateId);\n        apsCtrl->setParameter(deCONZ::ParamOtauActive, 1);\n\n        // reset endpoints\n        QVariantMap epData;\n\n        epData[\"index\"] = 0;\n        epData[\"endpoint\"] = \"0x1\";\n        epData[\"profileId\"] = \"0x104\";\n        epData[\"deviceId\"] = \"0x5\";\n        epData[\"deviceVersion\"] = \"0x1\";\n        epData[\"inClusters\"] = QVariantList({ \"0x0019\", \"0x000a\" });\n        epData[\"outClusters\"] = QVariantList({ \"0x0500\" });\n        apsCtrl->setParameter(deCONZ::ParamHAEndpoint, epData);\n\n        epData.clear();\n        epData[\"index\"] = 1;\n        epData[\"endpoint\"] = \"0xF2\";\n        epData[\"profileId\"] = \"0xA1E0\";\n        epData[\"deviceId\"] = \"0x0064\";\n        epData[\"deviceVersion\"] = \"0x1\";\n        epData[\"outClusters\"] = QVariantList({ \"0x0021\" });\n        apsCtrl->setParameter(deCONZ::ParamHAEndpoint, epData);\n    }\n\n    if (deleteDB)\n    {\n        QString path = deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation);\n        QString filename = path + \"/zll.db\";\n\n        QFile file(filename);\n        if (file.exists())\n        {\n            QDateTime now = QDateTime::currentDateTime();\n            QString newFilename = path + \"zll_\" + now.toString(Qt::ISODate) + \".bak\";\n            if (QFile::copy(filename, newFilename))\n            {\n                DBG_Printf(DBG_INFO, \"db backup success\\n\");\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"db backup failed\\n\");\n            }\n\n            if (file.remove())\n            {\n                DBG_Printf(DBG_INFO, \"db deleted %s\\n\", qPrintable(file.fileName()));\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"db failed to delete %s\\n\", qPrintable(file.fileName()));\n            }\n        }\n    }\n\n    return true;\n}\n\n"
        },
        {
          "name": "backup.h",
          "type": "blob",
          "size": 0.578125,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef BACKUP_H\n#define BACKUP_H\n\nnamespace deCONZ {\n    class ApsController;\n}\n\nbool BAK_ExportConfiguration(deCONZ::ApsController *apsCtrl);\nbool BAK_ImportConfiguration(deCONZ::ApsController *apsCtrl);\nbool BAK_ResetConfiguration(deCONZ::ApsController *apsCtrl, bool resetGW, bool deleteDB);\n\n#endif // BACKUP_H\n"
        },
        {
          "name": "basic.cpp",
          "type": "blob",
          "size": 6.4931640625,
          "content": "/*\n * basic.cpp\n *\n * Implementation of Basic cluster server.\n * Send ZCL attribute response to read request on Basic Cluster attributes.\n *\n * 0x0000 ZCL Version    / Just to test\n * 0xF000 Running time   / Used for Legrand device\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n/*! Handle packets related to the ZCL Basic cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the read attribute request\n */\nvoid DeRestPluginPrivate::handleBasicClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesId)\n    {\n        sendBasicClusterResponse(ind, zclFrame);\n    }\n}\n\n/*! Sends read attributes response to Basic client.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the read attributes request\n */\nvoid DeRestPluginPrivate::sendBasicClusterResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n    quint16 manucode = 0xFFFF;\n\n    req.setProfileId(ind.profileId());\n    req.setClusterId(ind.clusterId());\n    req.setDstAddressMode(ind.srcAddressMode());\n    req.dstAddress() = ind.srcAddress();\n    req.setDstEndpoint(ind.srcEndpoint());\n    req.setSrcEndpoint(endpoint());\n\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(deCONZ::ZclReadAttributesResponseId);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                deCONZ::ZclFCDirectionServerToClient |\n                                deCONZ::ZclFCDisableDefaultResponse);\n\n    //is there manufacture field in the request, if yes add it.\n    if (zclFrame.frameControl() & deCONZ::ZclFCManufacturerSpecific)\n    {\n        manucode = zclFrame.manufacturerCode();\n        outZclFrame.setFrameControl(outZclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        outZclFrame.setManufacturerCode(manucode);\n    }\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        QDataStream instream(zclFrame.payload());\n        instream.setByteOrder(QDataStream::LittleEndian);\n        quint8 code = 0x00; // success\n        quint16 attr;\n\n        while (!instream.atEnd())\n        {\n            instream >> attr;\n            stream << attr;\n\n            switch (attr)\n            {\n            case 0x0000: // ZCL Version\n                stream << code;\n                stream << (quint8) deCONZ::Zcl8BitUint;\n                stream << (quint8) 0x02;\n                break;\n\n            case 0x0001: // Application Version\n            {\n                stream << code;\n                stream << (quint8) deCONZ::Zcl8BitUint;\n\n                Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n                if (sensor && sensor->modelId() == QLatin1String(\"TRADFRI remote control\"))\n                {\n                    // Since firmware version 2.3.014 when the large middle button is pressed the remote reads this attribute.\n                    // If it isn't 17 as reported by earlier remote firmware, the left/right buttons don't send hold and long press commands anymore.\n                    stream << quint8(17);\n                }\n                else\n                {\n                    stream << quint8(0x00);\n                }\n            }\n                break;\n\n            case 0x0002: // Stack Version\n                stream << code;\n                stream << (quint8) deCONZ::Zcl8BitUint;\n                stream << (quint8) 0x00;\n                break;\n\n            case 0x0003: // HW Version\n                stream << code;\n                stream << (quint8) deCONZ::Zcl8BitUint;\n                stream << (quint8) 0x00;\n                break;\n\n            case 0x0004: // Manufacturer Name\n            {\n                const char *name = \"dresden elektronik\";\n                const quint8 length = strlen(name);\n\n                stream << code;\n                stream << (quint8) deCONZ::ZclCharacterString;\n                stream << length;\n                for (uint i = 0; i < length; i++)\n                {\n                    stream << (quint8) name[i];\n                }\n            }\n                break;\n\n            case 0x0005: // Model Identifier\n            {\n                const QByteArray id = apsCtrl->getParameter(deCONZ::ParamDeviceName).toLatin1();\n                const quint8 length = id.length();\n\n                stream << code;\n                stream << (quint8) deCONZ::ZclCharacterString;\n                stream << length;\n                for (uint i = 0; i < length; i++)\n                {\n                    stream << (quint8) id[i];\n                }\n            }\n                break;\n\n            case 0x0007: // Power Source\n                stream << code;\n                stream << (quint8) deCONZ::Zcl8BitEnum;\n                stream << (quint8) 0x04; // DC Power\n                break;\n\n            case 0x4000: // SW Build ID\n            {\n                const QByteArray version = gwFirmwareVersion.toLatin1();\n                const quint8 length = version.length();\n\n                stream << code;\n                stream << (quint8) deCONZ::ZclCharacterString;\n                stream << length;\n                for (uint i = 0; i < length; i++)\n                {\n                    stream << (quint8) version[i];\n                }\n            }\n                break;\n\n            case 0xF000: // Legrand attribute used for pairing\n                if (manucode == VENDOR_LEGRAND)\n                {\n                    stream << code;\n                    stream << (quint8) deCONZ::Zcl32BitUint;\n                    stream << (quint32) 0x000000d5;\n                }\n                else\n                {\n                    stream << (quint8) 0x86;  // unsupported_attribute\n                }\n                break;\n\n            default:\n            {\n                stream << (quint8) 0x86;  // unsupported_attribute\n            }\n            break;\n            }\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_INFO, \"Basic failed to send reponse\\n\");\n    }\n\n}\n"
        },
        {
          "name": "bindings.cpp",
          "type": "blob",
          "size": 154.9697265625,
          "content": "/*\n * Copyright (c) 2017-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"device.h\"\n#include \"device_descriptions.h\"\n#include \"utils/utils.h\"\n#include \"zdp/zdp.h\"\n\n#define MAX_ACTIVE_BINDING_TASKS 3\n\n/*! Constructor. */\nBinding::Binding() :\n    srcAddress(0),\n    srcEndpoint(0),\n    clusterId(0),\n    dstAddrMode(0),\n    dstEndpoint(0)\n{\n    dstAddress.ext = 0;\n}\n\n/*! Returns true if bindings are equal. */\nbool Binding::operator==(const Binding &rhs) const\n{\n    if (rhs.dstAddrMode == dstAddrMode &&\n        rhs.srcAddress == srcAddress &&\n        rhs.dstAddress.ext == dstAddress.ext &&\n        rhs.clusterId == clusterId &&\n        rhs.dstEndpoint == dstEndpoint &&\n        rhs.srcEndpoint == srcEndpoint)\n    {\n        return true;\n    }\n    return false;\n}\n\n/*! Returns false if bindings are not equal. */\nbool Binding::operator!=(const Binding &rhs) const\n{\n    return !(*this == rhs);\n}\n\n/*! Reads a binding entry from stream. */\nbool Binding::readFromStream(QDataStream &stream)\n{\n    if (stream.atEnd()) return false;\n    stream >> srcAddress;\n    if (stream.atEnd()) return false;\n    stream >> srcEndpoint;\n    if (stream.atEnd()) return false;\n    stream >> clusterId;\n    if (stream.atEnd()) return false;\n    stream >> dstAddrMode;\n\n    if (dstAddrMode == GroupAddressMode)\n    {\n        if (stream.atEnd()) return false;\n        stream >> dstAddress.group;\n        dstEndpoint = 0; // not present\n        return true;\n    }\n    else if (dstAddrMode == ExtendedAddressMode)\n    {\n        if (stream.atEnd()) return false;\n        stream >> dstAddress.ext;\n        if (stream.atEnd()) return false;\n        stream >> dstEndpoint;\n        return true;\n    }\n\n    return false;\n}\n\n/*! Writes a binding to stream.\n    \\param stream the data stream\n */\nbool Binding::writeToStream(QDataStream &stream) const\n{\n    if (!srcAddress || !srcEndpoint)\n    {\n        return false;\n    }\n\n    stream << srcAddress;\n    stream << srcEndpoint;\n    stream << clusterId;\n    stream << dstAddrMode;\n\n    if (dstAddrMode == GroupAddressMode)\n    {\n        stream << dstAddress.group;\n        return true;\n    }\n    else if ((dstAddrMode == ExtendedAddressMode) && (dstAddress.ext != 0) && (dstEndpoint != 0))\n    {\n        stream << dstAddress.ext;\n        stream << dstEndpoint;\n        return true;\n    }\n\n    return false;\n}\n\n/*! Converts a plugin Binding object to core deCONZ::Binding. */\ndeCONZ::Binding convertToCoreBinding(const Binding &bnd)\n{\n    if (bnd.dstAddrMode == deCONZ::ApsExtAddress)\n    {\n        return deCONZ::Binding(bnd.srcAddress, bnd.dstAddress.ext, bnd.clusterId, bnd.srcEndpoint, bnd.dstEndpoint);\n    }\n    else if (bnd.dstAddrMode == deCONZ::ApsGroupAddress)\n    {\n        return deCONZ::Binding(bnd.srcAddress, bnd.dstAddress.group, bnd.clusterId, bnd.srcEndpoint);\n    }\n\n    return { };\n}\n\n/*! Queue reading ZDP binding table.\n    \\param node the node from which the binding table shall be read\n    \\param startIndex the index to start the reading\n    \\return true if the request is queued\n */\nbool DeRestPluginPrivate::readBindingTable(RestNodeBase *node, quint8 startIndex)\n{\n    DBG_Assert(node != 0);\n\n    if (!node || !node->node())\n    {\n        return false;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, node->address().ext());\n    if (device && device->managed())\n    {\n        return false;\n    }\n\n    Resource *r = dynamic_cast<Resource*>(node);\n\n    // whitelist\n    if (node->mgmtBindSupported())\n    {\n    }\n    else if (!node->mgmtBindSupported())\n    {\n        node->clearRead(READ_BINDING_TABLE);\n        return false;\n    }\n    else if (existDevicesWithVendorCodeForMacPrefix(node->address(), VENDOR_DDEL))\n    {\n    }\n    else if (existDevicesWithVendorCodeForMacPrefix(node->address(), VENDOR_UBISYS))\n    {\n    }\n    else if (existDevicesWithVendorCodeForMacPrefix(node->address(), VENDOR_DEVELCO))\n    {\n    }\n    else\n    {\n        node->clearRead(READ_BINDING_TABLE);\n        return false;\n    }\n\n    std::vector<BindingTableReader>::iterator i = bindingTableReaders.begin();\n    std::vector<BindingTableReader>::iterator end = bindingTableReaders.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->apsReq.dstAddress().ext() == node->address().ext())\n        {\n            // already running\n            if (i->state == BindingTableReader::StateIdle)\n            {\n                i->index = startIndex;\n                DBG_Assert(bindingTableReaderTimer->isActive());\n            }\n            return true;\n        }\n    }\n\n    BindingTableReader btReader;\n    btReader.state = BindingTableReader::StateIdle;\n    btReader.index = startIndex;\n    btReader.isEndDevice = !node->node()->nodeDescriptor().receiverOnWhenIdle();\n    btReader.apsReq.dstAddress() = node->address();\n\n    bindingTableReaders.push_back(btReader);\n\n    if (!bindingTableReaderTimer->isActive())\n    {\n        bindingTableReaderTimer->start();\n    }\n\n    return true;\n}\n\n/*! Handle bind table confirm.\n    \\param conf a APSDE-DATA.confirm\n    \\return true if confirm was processed\n */\nbool DeRestPluginPrivate::handleMgmtBindRspConfirm(const deCONZ::ApsDataConfirm &conf)\n{\n    if (conf.srcEndpoint() != ZDO_ENDPOINT || conf.dstEndpoint() != ZDO_ENDPOINT)\n    {\n        return false;\n    }\n\n    std::vector<BindingTableReader>::iterator i = bindingTableReaders.begin();\n    std::vector<BindingTableReader>::iterator end = bindingTableReaders.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->apsReq.id() == conf.id())\n        {\n            if (i->state == BindingTableReader::StateWaitConfirm)\n            {\n                i->time.start();\n                i->state = BindingTableReader::StateWaitResponse;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n/*! Handle bind table response.\n    \\param ind a ZDP MgmtBind_rsp\n */\nvoid DeRestPluginPrivate::handleMgmtBindRspIndication(const deCONZ::ApsDataIndication &ind)\n{\n    if (ind.asdu().size() < 2)\n    {\n        // at least seq number and status\n        return;\n    }\n\n    BindingTableReader *btReader = 0;\n\n    {\n        std::vector<BindingTableReader>::iterator i = bindingTableReaders.begin();\n        std::vector<BindingTableReader>::iterator end = bindingTableReaders.end();\n\n        for (; i != end; ++i)\n        {\n            if (isSameAddress(ind.srcAddress(), i->apsReq.dstAddress()))\n            {\n                btReader = &(*i);\n                break;\n            }\n        }\n    }\n\n    RestNodeBase *node = getSensorNodeForAddress(ind.srcAddress());\n\n    if (!node)\n    {\n        node = getLightNodeForAddress(ind.srcAddress());\n    }\n\n    if (!node)\n    {\n        if (btReader)\n        {\n            // no more needed\n            btReader->state = BindingTableReader::StateFinished;\n        }\n        return;\n    }\n\n    QDataStream stream(ind.asdu());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    quint8 seqNo;\n    quint8 status;\n\n    stream >> seqNo;\n    stream >> status;\n\n    if (status != deCONZ::ZdpSuccess)\n    {\n        if (status == deCONZ::ZdpNotPermitted ||\n            status == deCONZ::ZdpNotSupported)\n        {\n            if (node->mgmtBindSupported())\n            {\n                node->setMgmtBindSupported(false);\n            }\n        }\n\n        if (btReader)\n        {\n            // no more needed\n            btReader->state = BindingTableReader::StateFinished;\n        }\n        return;\n    }\n\n    quint8 entries;\n    quint8 startIndex;\n    quint8 listCount;\n    bool bend = false;\n\n    stream >> entries;\n    stream >> startIndex;\n    stream >> listCount;\n\n    if (entries > (startIndex + listCount))\n    {\n        if (btReader)\n        {\n            if (btReader->state == BindingTableReader::StateWaitResponse || btReader->state == BindingTableReader::StateWaitConfirm)\n            {\n                // read more\n                btReader->state = BindingTableReader::StateIdle;\n                btReader->index = startIndex + listCount;\n            }\n            else\n            {\n                DBG_Printf(DBG_ZDP, \"unexpected BTR state %d\\n\", (int)btReader->state);\n            }\n        }\n    }\n    else\n    {\n        bend = true;\n        if (btReader)\n        {\n            btReader->state = BindingTableReader::StateFinished;\n        }\n\n        enqueueEvent({RDevices, REventBindingTable, status, ind.srcAddress().ext()}); // TODO(mpi): I think this event is obsolete and should be removed\n    }\n\n    while (listCount && !stream.atEnd())\n    {\n        Binding bnd;\n\n        if (bnd.readFromStream(stream))\n        {\n            if (bnd.dstAddrMode == deCONZ::ApsExtAddress)\n            {\n                DBG_Printf(DBG_ZDP, \"found binding 0x%04X, 0x%02X -> 0x%016llX : 0x%02X\\n\", bnd.clusterId, bnd.srcEndpoint, bnd.dstAddress.ext, bnd.dstEndpoint);\n            }\n            else if (bnd.dstAddrMode == deCONZ::ApsGroupAddress)\n            {\n                DBG_Printf(DBG_ZDP, \"found binding 0x%04X, 0x%02X -> 0x%04X\\n\", bnd.clusterId, bnd.srcEndpoint, bnd.dstAddress.group);\n            }\n            else\n            {\n                continue;\n            }\n\n            auto i = bindingQueue.begin();\n            auto end = bindingQueue.end();\n\n            for (;i != end; ++i)\n            {\n                if (i->binding == bnd)\n                {\n                    if (i->action == BindingTask::ActionBind && i->state != BindingTask::StateFinished)\n                    {\n                        DBG_Printf(DBG_ZDP, \"binding 0x%04X, 0x%02X already exists, drop task\\n\", bnd.clusterId, bnd.dstEndpoint);\n                        i->state = BindingTask::StateFinished; // already existing\n                        sendConfigureReportingRequest(*i); // (re?)configure\n                    }\n                    else if (i->action == BindingTask::ActionUnbind && i->state == BindingTask::StateCheck)\n                    {\n                        DBG_Printf(DBG_ZDP, \"binding 0x%04X, 0x%02X exists, start unbind task\\n\", bnd.clusterId, bnd.dstEndpoint);\n                        i->state = BindingTask::StateIdle; // exists -> unbind\n                    }\n                    break;\n                }\n            }\n        }\n        else // invalid\n        {\n            DBG_Printf(DBG_ZDP, \"invalid binding entry\");\n            break;\n        }\n\n        listCount--;\n    }\n\n    // end, check remaining tasks\n    if (bend)\n    {\n        std::list<BindingTask>::iterator i = bindingQueue.begin();\n        std::list<BindingTask>::iterator end = bindingQueue.end();\n\n        for (;i != end; ++i)\n        {\n            if (i->state == BindingTask::StateCheck &&\n                i->binding.srcAddress == ind.srcAddress().ext())\n            {\n                // if binding was not found, activate binding task\n                if (i->action == BindingTask::ActionBind)\n                {\n                    DBG_Printf(DBG_ZDP, \"binding 0x%04X, 0x%02X not found, start bind task\\n\", i->binding.clusterId, i->binding.dstEndpoint);\n                    i->state = BindingTask::StateIdle;\n                }\n                else if (i->action == BindingTask::ActionUnbind)\n                {\n                    // nothing to unbind\n                    DBG_Printf(DBG_ZDP, \"binding 0x%04X, 0x%02X not found, remove unbind task\\n\", i->binding.clusterId, i->binding.dstEndpoint);\n                    i->state = BindingTask::StateFinished; // already existing\n                }\n            }\n        }\n    }\n}\n\n/*! Handle incoming ZCL configure reporting response.\n */\nvoid DeRestPluginPrivate::handleZclConfigureReportingResponseIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Device *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    QDateTime now = QDateTime::currentDateTime();\n    std::vector<RestNodeBase*> allNodes;\n    for (Sensor &s : sensors)\n    {\n        allNodes.push_back(&s);\n    }\n\n    for (LightNode &l : nodes)\n    {\n        allNodes.push_back(&l);\n    }\n\n    for (RestNodeBase * restNode : allNodes)\n    {\n        if (restNode->address().ext() != ind.srcAddress().ext())\n        {\n            continue;\n        }\n\n        DBG_Assert(zclFrame.sequenceNumber() != 0);\n\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        if (zclFrame.payload().size() == 1)\n        {\n            // Response contains a single status for all attributes\n            quint8 status;\n            stream >> status;\n\n            for (NodeValue &val : restNode->zclValues())\n            {\n                if (val.zclSeqNum != zclFrame.sequenceNumber())\n                {\n                    continue;\n                }\n\n                if (val.clusterId != ind.clusterId())\n                {\n                    continue;\n                }\n\n                DBG_Printf(DBG_INFO, \"ZCL configure reporting rsp seq: %u 0x%016llX for ep: 0x%02X cluster: 0x%04X attr: 0x%04X status: 0x%02X\\n\", zclFrame.sequenceNumber(), ind.srcAddress().ext(), ind.srcEndpoint(), ind.clusterId(), val.attributeId, status);\n\n                // mark as succefully configured\n                if (status == deCONZ::ZclSuccessStatus)\n                {\n                    val.timestampLastConfigured = now;\n                    val.zclSeqNum = 0; // clear\n                }\n            }\n            break;\n        }\n\n        while (!stream.atEnd())\n        {\n            // Response contains status per attribute\n            quint8 status;\n            quint8 direction;\n            quint16 attrId;\n\n            stream >> status;\n            stream >> direction;\n            stream >> attrId;\n\n            NodeValue &val = restNode->getZclValue(ind.clusterId(), attrId, ind.srcEndpoint());\n            if (val.zclSeqNum == zclFrame.sequenceNumber() && val.clusterId == ind.clusterId())\n            {\n                DBG_Printf(DBG_INFO, \"ZCL configure reporting rsp seq: %u 0x%016llX for ep: 0x%02X cluster: 0x%04X attr: 0x%04X status: 0x%02X\\n\", zclFrame.sequenceNumber(), ind.srcAddress().ext(), ind.srcEndpoint(), ind.clusterId(), val.attributeId, status);\n\n                if (status == deCONZ::ZclSuccessStatus)\n                {\n                    // mark as succefully configured\n                    val.timestampLastConfigured = now;\n                    val.zclSeqNum = 0; // clear\n                }\n            }\n        }\n    }\n\n    if (searchSensorsState == SearchSensorsActive && fastProbeAddr.hasExt() && bindingQueue.empty())\n    {\n        for (auto &s : sensors)\n        {\n            if (s.address().ext() == fastProbeAddr.ext())\n            {\n                checkSensorBindingsForAttributeReporting(&s);\n            }\n        }\n    }\n\n    bindingTimer->start(0); // fast process of next request\n}\n\n/*! Handle bind/unbind response.\n    \\param ind a ZDP Bind/Unbind_rsp\n */\nvoid DeRestPluginPrivate::handleBindAndUnbindRspIndication(const deCONZ::ApsDataIndication &ind)\n{\n    Device *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    QDataStream stream(ind.asdu());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    quint8 zdpSeqNum;\n    quint8 status;\n\n    stream >> zdpSeqNum;\n    stream >> status;\n\n    std::list<BindingTask>::iterator i = bindingQueue.begin();\n    std::list<BindingTask>::iterator end = bindingQueue.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->zdpSeqNum == zdpSeqNum)\n        {\n            const char *what = (ind.clusterId() == ZDP_BIND_RSP_CLID) ? \"Bind\" : \"Unbind\";\n\n            if (status == deCONZ::ZdpSuccess)\n            {\n                DBG_Printf(DBG_INFO, \"%s response success for 0x%016llx ep: 0x%02X cluster: 0x%04X\\n\", what, i->binding.srcAddress, i->binding.srcEndpoint, i->binding.clusterId);\n                if (ind.clusterId() == ZDP_BIND_RSP_CLID)\n                {\n                    if (sendConfigureReportingRequest(*i))\n                    {\n                        return;\n                    }\n                }\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"%s response failed with status 0x%02X for 0x%016llx ep: 0x%02X cluster: 0x%04X\\n\", what, status, i->binding.srcAddress, i->binding.srcEndpoint, i->binding.clusterId);\n            }\n\n            i->state = BindingTask::StateFinished;\n            break;\n        }\n    }\n\n    bindingTimer->start(0); // fast process of next binding requests\n}\n\n/*! Sends a ZDP bind request.\n    \\param bt a binding task\n */\nbool DeRestPluginPrivate::sendBindRequest(BindingTask &bt)\n{\n    DBG_Assert(apsCtrl != nullptr);\n\n    if (!apsCtrl)\n    {\n        return false;\n    }\n\n    for (auto &s : sensors)\n    {\n        if (s.address().ext() != bt.binding.srcAddress)\n        {\n            continue;\n        }\n\n        if (!s.node() || s.node()->nodeDescriptor().isNull())\n        {\n            // Whitelist sensors which don't seem to have a valid node descriptor.\n            // This is a workaround currently only required for Develco smoke sensor\n            // and potentially Bosch motion sensor\n            if (s.modelId().startsWith(QLatin1String(\"EMIZB-1\")) ||      // Develco EMI Norwegian HAN\n                s.modelId().startsWith(QLatin1String(\"ISW-ZPR1-WP13\")))  // Bosch motion sensor\n            {\n            }\n            else\n            {\n                return false; // needs to be known\n            }\n        }\n\n        if (s.node()->nodeDescriptor().receiverOnWhenIdle())\n        {\n            break; // ok\n        }\n\n        if (permitJoinFlag || searchSensorsState == SearchSensorsActive)\n        {\n            break; // ok\n        }\n\n        const QDateTime now = QDateTime::currentDateTime();\n        if (s.lastRx().secsTo(now) > 7)\n        {\n            return false;\n        }\n\n        break; // ok\n    }\n\n    Binding &bnd = bt.binding;\n    deCONZ::ApsDataRequest apsReq;\n\n    // set destination addressing\n    apsReq.setDstAddressMode(deCONZ::ApsExtAddress);\n    apsReq.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    apsReq.dstAddress().setExt(bnd.srcAddress);\n    apsReq.setDstEndpoint(ZDO_ENDPOINT);\n    apsReq.setSrcEndpoint(ZDO_ENDPOINT);\n    apsReq.setProfileId(ZDP_PROFILE_ID);\n\n    if (bt.action == BindingTask::ActionBind)\n    {\n        apsReq.setClusterId(ZDP_BIND_REQ_CLID);\n    }\n    else\n    {\n        apsReq.setClusterId(ZDP_UNBIND_REQ_CLID);\n    }\n\n    // prepare payload\n    QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    // generate and remember a new ZDP transaction sequence number\n    bt.zdpSeqNum = ZDP_NextSequenceNumber();\n\n    stream << bt.zdpSeqNum; // ZDP transaction sequence number\n\n    if (!bnd.writeToStream(stream))\n    {\n        return false;\n    }\n\n    if (apsCtrlWrapper.apsdeDataRequest(apsReq) == deCONZ::Success)\n    {\n        return true;\n    }\n\n    return false;\n}\n\n/*! Sends a ZCL configure attribute reporting request.\n    \\param bt a former binding task\n    \\param requests list of configure reporting requests which will be combined in a message\n */\nbool DeRestPluginPrivate::sendConfigureReportingRequest(BindingTask &bt, const std::vector<ConfigureReportingRequest> &requests)\n{\n    DBG_Assert(!requests.empty());\n    if (requests.empty())\n    {\n        return false;\n    }\n\n    // clue code to get classic hard coded C++ bindings into DDF\n    Device *device = DEV_GetDevice(m_devices, bt.binding.srcAddress);\n    if (!device)\n    {  }\n    else if (!device->managed())\n    {\n        DDF_Binding ddfBinding;\n\n        ddfBinding.isUnicastBinding = bt.binding.dstAddrMode == deCONZ::ApsExtAddress;\n        ddfBinding.isGroupBinding = bt.binding.dstAddrMode == deCONZ::ApsGroupAddress;\n        if (ddfBinding.isUnicastBinding)\n        {\n            ddfBinding.dstExtAddress = bt.binding.dstAddress.ext;\n        }\n        else if (ddfBinding.isGroupBinding)\n        {\n            ddfBinding.dstGroup = bt.binding.dstAddress.group;\n        }\n        ddfBinding.clusterId = bt.binding.clusterId;\n        ddfBinding.dstEndpoint =  bt.binding.dstEndpoint;\n        ddfBinding.srcEndpoint = bt.binding.srcEndpoint;\n\n        for (const ConfigureReportingRequest &rep : requests)\n        {\n            DDF_ZclReport ddfRep;\n\n            ddfRep.attributeId = rep.attributeId;\n            ddfRep.dataType = rep.dataType;\n            ddfRep.direction = rep.direction;\n            ddfRep.manufacturerCode = rep.manufacturerCode;\n            ddfRep.minInterval = rep.minInterval;\n            ddfRep.maxInterval = rep.maxInterval;\n            ddfRep.valid = true;\n\n            if      (rep.reportableChange16bit != 0xFFFF)     { ddfRep.reportableChange = rep.reportableChange16bit; }\n            else if (rep.reportableChange8bit != 0xFF)        { ddfRep.reportableChange = rep.reportableChange8bit; }\n            else if (rep.reportableChange24bit != 0xFFFFFF)   { ddfRep.reportableChange = rep.reportableChange24bit; }\n            else if (rep.reportableChange48bit != 0xFFFFFFFF) { ddfRep.reportableChange = rep.reportableChange48bit; }\n\n            ddfBinding.reporting.push_back(ddfRep);\n        }\n\n        device->addBinding(ddfBinding);\n\n        auto ddf = deviceDescriptions->get(device);\n        if (ddf.status == QLatin1String(\"Draft\"))\n        {\n            if (ddf.bindings != device->bindings())\n            {\n                ddf.bindings = device->bindings();\n                deviceDescriptions->put(ddf);\n            }\n        }\n    }\n    else if (device->managed())\n    {\n        return false;\n    }\n\n    if (zclSeq == 0) // don't use zero, simplify matching\n    {\n        zclSeq = 1;\n    }\n    const quint8 zclSeqNum = zclSeq++; // to match in configure reporting response handler\n    LightNode *lightNode = dynamic_cast<LightNode*>(bt.restNode);\n    QDateTime now = QDateTime::currentDateTime();\n    std::vector<ConfigureReportingRequest> out;\n\n    for (const ConfigureReportingRequest &rq : requests)\n    {\n        NodeValue &val = bt.restNode->getZclValue(bt.binding.clusterId, rq.attributeId, bt.binding.srcEndpoint);\n        if (val.clusterId == bt.binding.clusterId)\n        {\n            // value exists\n            if (rq.maxInterval != 0xffff && // disable reporting\n                val.timestampLastReport.isValid() &&\n                val.timestampLastReport.secsTo(now) < qMin((rq.maxInterval * 3), 1800))\n            {\n                DBG_Printf(DBG_INFO, \"skip configure report for cluster: 0x%04X attr: 0x%04X of node 0x%016llX (seems to be active)\\n\",\n                           bt.binding.clusterId, rq.attributeId, bt.restNode->address().ext());\n            }\n            else\n            {\n                if (!val.timestampLastReport.isValid())\n                {\n                    // fake first report timestamp to mark succesful binding\n                    // and prevent further bind requests before reports arrive\n                    val.timestampLastReport = QDateTime::currentDateTime();\n                }\n                val.zclSeqNum = zclSeqNum;\n                val.minInterval = rq.minInterval;\n                val.maxInterval = rq.maxInterval;\n                out.push_back(rq);\n            }\n        }\n        else if (lightNode && rq.maxInterval != 0xffff /* disable reporting */)\n        {\n            // wait for value is created via polling\n            DBG_Printf(DBG_INFO, \"skip configure report for cluster: 0x%04X attr: 0x%04X of node 0x%016llX (wait reading or unsupported)\\n\",\n                       bt.binding.clusterId, rq.attributeId, bt.restNode->address().ext());\n        }\n        else // sensors and disabled reporting\n        {\n            // values doesn't exist, create\n            deCONZ::NumericUnion dummy;\n            dummy.u64 = 0;\n            bt.restNode->setZclValue(NodeValue::UpdateByZclReport, bt.binding.srcEndpoint, bt.binding.clusterId, rq.attributeId, dummy);\n            val.zclSeqNum = zclSeqNum;\n            val.minInterval = rq.minInterval;\n            val.maxInterval = rq.maxInterval;\n            out.push_back(rq);\n        }\n    }\n\n    if (out.empty())\n    {\n        return false;\n    }\n\n    deCONZ::ApsDataRequest apsReq;\n\n    // ZDP Header\n    apsReq.dstAddress() = bt.restNode->address();\n    apsReq.setDstAddressMode(deCONZ::ApsExtAddress);\n    apsReq.setDstEndpoint(bt.binding.srcEndpoint);\n    apsReq.setSrcEndpoint(endpoint());\n    apsReq.setProfileId(HA_PROFILE_ID);\n    apsReq.setRadius(0);\n    apsReq.setClusterId(bt.binding.clusterId);\n    apsReq.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n\n    deCONZ::ZclFrame zclFrame;\n    zclFrame.setSequenceNumber(zclSeqNum);\n    zclFrame.setCommandId(deCONZ::ZclConfigureReportingId);\n\n    if (requests.front().manufacturerCode)\n    {\n        zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                 deCONZ::ZclFCManufacturerSpecific |\n                                 deCONZ::ZclFCDirectionClientToServer |\n                                 deCONZ::ZclFCDisableDefaultResponse);\n        zclFrame.setManufacturerCode(requests.front().manufacturerCode);\n    }\n    else\n    {\n        zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                 deCONZ::ZclFCDirectionClientToServer |\n                                 deCONZ::ZclFCDisableDefaultResponse);\n    }\n\n    { // payload\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        for (const ConfigureReportingRequest &rq : out)\n        {\n            stream << rq.direction;\n            stream << rq.attributeId;\n            stream << rq.dataType;\n            stream << rq.minInterval;\n            stream << rq.maxInterval;\n\n            if (rq.reportableChange16bit != 0xFFFF)\n            {\n                stream << rq.reportableChange16bit;\n            }\n            else if (rq.reportableChange8bit != 0xFF)\n            {\n                stream << rq.reportableChange8bit;\n            }\n            else if (rq.reportableChange24bit != 0xFFFFFF)\n            {\n                stream << (qint8) (rq.reportableChange24bit & 0xFF);\n                stream << (qint8) ((rq.reportableChange24bit >> 8) & 0xFF);\n                stream << (qint8) ((rq.reportableChange24bit >> 16) & 0xFF);\n            }\n            else if (rq.reportableChange48bit != 0xFFFFFFFF)\n            {\n                stream << (qint8) (rq.reportableChange48bit & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 8) & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 16) & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 24) & 0xFF);\n                stream << (qint8) 0x00;\n                stream << (qint8) 0x00;\n            }\n            DBG_Printf(DBG_INFO_L2, \"configure reporting rq seq %u for 0x%016llX, attribute 0x%04X/0x%04X\\n\", zclSeqNum, bt.restNode->address().ext(), bt.binding.clusterId, rq.attributeId);\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n\n    if (apsCtrlWrapper.apsdeDataRequest(apsReq) == deCONZ::Success)\n    {\n        queryTime = queryTime.addSecs(1);\n        return true;\n    }\n\n    return false;\n}\n\n/*! Sends a ZCL configure attribute reporting request.\n    \\param bt a former binding task\n */\nbool DeRestPluginPrivate::sendConfigureReportingRequest(BindingTask &bt)\n{\n    if (!bt.restNode || !bt.restNode->node())\n    {\n        return false;\n    }\n\n    deCONZ::SimpleDescriptor *sd = bt.restNode->node()->getSimpleDescriptor(bt.binding.srcEndpoint);\n    if (!sd)\n    {\n        return false;\n    }\n\n    // check if bound cluster is server cluster\n    deCONZ:: ZclCluster *cl = sd->cluster(bt.binding.clusterId, deCONZ::ServerCluster);\n    if (!cl)\n    {\n        return false;\n    }\n\n    const QDateTime now = QDateTime::currentDateTime();\n    ConfigureReportingRequest rq;\n\n    const LightNode *lightNode = dynamic_cast<LightNode *>(bt.restNode);\n    Sensor *sensor = dynamic_cast<Sensor *>(bt.restNode);\n\n    const Resource *r = [lightNode, sensor]() -> const Resource* {\n        if (lightNode) return lightNode;\n        else           return sensor;\n    }();\n\n    if (!r || !r->item(RAttrModelId))\n    {\n        return false;\n    }\n\n    const QString modelId = r->item(RAttrModelId)->toString();\n    const quint16 manufacturerCode = bt.restNode->node()->nodeDescriptor().manufacturerCode();\n\n    if (bt.binding.clusterId == BOSCH_AIR_QUALITY_CLUSTER_ID && manufacturerCode == VENDOR_BOSCH2)\n    {\n        return false; // nothing todo\n    }\n\n    if (bt.binding.clusterId == OCCUPANCY_SENSING_CLUSTER_ID)\n    {\n        // add values if not already present\n        deCONZ::NumericUnion dummy;\n        dummy.u64 = 0;\n        if (bt.restNode->getZclValue(bt.binding.clusterId, 0x0000, bt.binding.srcEndpoint).clusterId != bt.binding.clusterId)\n        {\n            bt.restNode->setZclValue(NodeValue::UpdateInvalid, bt.binding.srcEndpoint, bt.binding.clusterId, 0x0000, dummy);\n        }\n\n        rq.dataType = deCONZ::Zcl8BitBitMap;\n        rq.attributeId = 0x0000; // occupancy\n        rq.minInterval = 1;     // value used by Hue bridge\n        rq.maxInterval = 300;   // value used by Hue bridge\n\n        int processed = 0;\n        if (sendConfigureReportingRequest(bt, {rq}))\n        {\n            processed++;\n        }\n\n        return processed > 0;\n    }\n    else if (bt.binding.clusterId == IAS_ZONE_CLUSTER_ID)\n    {\n        // zone status reporting only supported by some devices\n        if (manufacturerCode != VENDOR_CENTRALITE &&\n            manufacturerCode != VENDOR_C2DF &&\n            manufacturerCode != VENDOR_SAMJIN)\n        {\n            return false;\n        }\n\n        // add values if not already present\n        deCONZ::NumericUnion dummy;\n        dummy.u64 = 0;\n        if (bt.restNode->getZclValue(bt.binding.clusterId, IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID, bt.binding.srcEndpoint).clusterId != bt.binding.clusterId)\n        {\n            bt.restNode->setZclValue(NodeValue::UpdateInvalid, bt.binding.srcEndpoint, bt.binding.clusterId, IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID, dummy);\n        }\n\n        if (sensor && sensor->type() == QLatin1String(\"ZHAOpenClose\") && modelId.startsWith(QLatin1String(\"multi\")))\n        {\n            // Only configure periodic reports, as events are already sent though zone status change notification commands\n            rq.minInterval = 300;\n            rq.maxInterval = 3600;\n        }\n        else if (sensor && sensor->type() == QLatin1String(\"ZHASwitch\") && modelId == QLatin1String(\"button\"))\n        {\n            rq.minInterval = 65535; // Disable reporting so devices must not be reset to not have it\n            rq.maxInterval = 65535; // configured at all. Should be changed in future to explicitly exclude device from reporting.\n        }\n        else\n        {\n            rq.minInterval = 300;\n            rq.maxInterval = 3600;\n\n            const ResourceItem *item = sensor ? sensor->item(RConfigDuration) : nullptr;\n\n            if (item && item->toNumber() > 15 && item->toNumber() <= UINT16_MAX)\n            {\n                rq.maxInterval = static_cast<quint16>(item->toNumber());\n                rq.maxInterval -= 5; // report before going presence: false\n            }\n        }\n\n        rq.dataType = deCONZ::Zcl16BitBitMap;\n        rq.attributeId = IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID;\n        rq.reportableChange16bit = 0xffff;\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == ILLUMINANCE_MEASUREMENT_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitUint;\n        rq.attributeId = 0x0000;         // measured value\n\n        if (modelId.startsWith(QLatin1String(\"MOSZB-1\")) ||           // Develco motion sensor\n            modelId.startsWith(QLatin1String(\"MotionSensor51AU\")))    // Aurora (Develco) motion sensor\n        {\n            rq.minInterval = 0;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 0xFFFF;\n        }\n        else\n        {\n            rq.minInterval = 5;              // value used by Hue bridge\n            rq.maxInterval = 300;            // value used by Hue bridge\n            rq.reportableChange16bit = 2000; // value used by Hue bridge\n        }\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == TEMPERATURE_MEASUREMENT_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitInt;\n        rq.attributeId = 0x0000;       // measured value\n\n        if (modelId.startsWith(QLatin1String(\"MOSZB-1\")) ||         // Develco motion sensor\n            modelId.startsWith(QLatin1String(\"FLSZB-1\")) ||         // Develco water leak sensor\n            modelId.startsWith(QLatin1String(\"ZHMS101\")) ||         // Wattle (Develco) magnetic sensor\n            modelId.startsWith(QLatin1String(\"MotionSensor51AU\")))  // Aurora (Develco) motion sensor\n        {\n            rq.minInterval = 60;           // according to technical manual\n            rq.maxInterval = 600;          // according to technical manual\n            rq.reportableChange16bit = 10; // according to technical manual\n        }\n        else\n        {\n            rq.minInterval = 10;           // value used by Hue bridge\n            rq.maxInterval = 300;          // value used by Hue bridge\n            rq.reportableChange16bit = 20; // value used by Hue bridge\n        }\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == THERMOSTAT_CLUSTER_ID)\n    {\n        if (modelId.startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;        // Local Temperature\n            rq.minInterval = 1;             // report changes every second\n            rq.maxInterval = 600;           // recommended value\n            rq.reportableChange16bit = 20;  // value from TEMPERATURE_MEASUREMENT_CLUSTER_ID\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl8BitUint;\n            rq2.attributeId = 0x0008;        // Pi Heating Demand (valve position %)\n            rq2.minInterval = 1;             // report changes every second\n            rq2.maxInterval = 600;           // recommended value\n            rq2.reportableChange8bit = 1;    // recommended value\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied Heating Setpoint - unused\n            rq3.minInterval = 65535;         // disable\n            rq3.maxInterval = 65535;         // disable\n            rq3.reportableChange16bit = 0;   // disable\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl16BitInt;\n            rq4.attributeId = 0x0014;        // Unoccupied Heating Setpoint - unused\n            rq4.minInterval = 65535;         // disable\n            rq4.maxInterval = 65535;         // disable\n            rq4.reportableChange16bit = 0;   // disable\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl16BitInt;\n            rq5.attributeId = 0x4003;        // Current Temperature Set point\n            rq5.minInterval = 1;             // report changes every second\n            rq5.maxInterval = 600;           // recommended value\n            rq5.reportableChange16bit = 50;  // recommended value\n            rq5.manufacturerCode = VENDOR_JENNIC;\n\n            ConfigureReportingRequest rq6;\n            rq6.dataType = deCONZ::Zcl24BitUint;\n            rq6.attributeId = 0x4008;        // Host Flags\n            rq6.minInterval = 1;             // report changes every second\n            rq6.maxInterval = 600;           // recommended value\n            rq6.reportableChange24bit = 1;   // recommended value\n            rq6.manufacturerCode = VENDOR_JENNIC;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4}) || // Use OR because of manuf. specific attributes\n                   sendConfigureReportingRequest(bt, {rq5, rq6});\n        }\n        else if (modelId == QLatin1String(\"Thermostat\")) // eCozy\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;        // Local Temperature\n            rq.minInterval = 1;             // report changes every second\n            rq.maxInterval = 600;           // recommended value\n            rq.reportableChange16bit = 20;  // value from TEMPERATURE_MEASUREMENT_CLUSTER_ID\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl8BitUint;\n            rq2.attributeId = 0x0008;        // Pi Heating Demand (valve position %)\n            rq2.minInterval = 1;             // report changes every second\n            rq2.maxInterval = 600;           // recommended value\n            rq2.reportableChange8bit = 1;    // recommended value\n\n            return sendConfigureReportingRequest(bt, {rq, rq2});\n        }\n        else if (modelId == QLatin1String(\"Super TR\")) // Elko Super TR\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;        // Local temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 20;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0012;        // Occupied heating setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::ZclBoolean;\n            rq4.attributeId = 0x0406;        // Device on\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl16BitInt;\n            rq5.attributeId = 0x0409;        // Floor temperature\n            rq5.minInterval = 1;\n            rq5.maxInterval = 600;\n            rq5.reportableChange16bit = 20;\n\n            ConfigureReportingRequest rq6;\n            rq6.dataType = deCONZ::ZclBoolean;\n            rq6.attributeId = 0x0413;        // Child lock\n            rq6.minInterval = 1;\n            rq6.maxInterval = 600;\n\n            ConfigureReportingRequest rq7;\n            rq7.dataType = deCONZ::ZclBoolean;\n            rq7.attributeId = 0x0415;        // Heating active/inactive\n            rq7.minInterval = 1;\n            rq7.maxInterval = 600;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq4, rq5, rq6, rq7});\n        }\n        else if (modelId == QLatin1String(\"SORB\")) // Stelpro Orleans Fan\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // Local Temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 20;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0011;        // Occupied cooling setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl8BitEnum;\n            rq4.attributeId = 0x001C;        // Thermostat mode\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4});\n        }\n        else if (modelId.startsWith(QLatin1String(\"STZB402\"))) // Stelpro baseboard thermostat\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // Local Temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 20;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0012;        // Occupied heating setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl8BitEnum;\n            rq3.attributeId = 0x001C;        // Thermostat mode\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3});\n        }\n        else if (modelId == QLatin1String(\"Zen-01\")) // Zen\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;        // Local Temperature\n            rq.minInterval = 1;             // report changes every second\n            rq.maxInterval = 600;           // recommended value\n            rq.reportableChange16bit = 20;  // value from TEMPERATURE_MEASUREMENT_CLUSTER_ID\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0011;        // Occupied cooling setpoint\n            rq2.minInterval = 1;             // report changes every second\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl16BitBitMap;\n            rq4.attributeId = 0x0029;        // Thermostat running state\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange16bit = 0xffff;\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl8BitEnum;\n            rq5.attributeId = 0x001C;        // Thermostat mode\n            rq5.minInterval = 1;\n            rq5.maxInterval = 600;\n            rq5.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4, rq5});\n        }\n        else if (modelId.startsWith(QLatin1String(\"SLR2\")) || // Hive\n                 modelId == QLatin1String(\"SLR1b\"))           // Hive\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;       // local temperature\n            rq.minInterval = 0;\n            rq.maxInterval = 300;\n            rq.reportableChange16bit = 10;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl8BitEnum;\n            rq4.attributeId = 0x001C;        // Thermostat mode\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange8bit = 0xff;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitBitMap;\n            rq2.attributeId = 0x0029;        // Thermostat running state\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 0xffff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4});\n        }\n        else if (modelId.startsWith(QLatin1String(\"3157100\"))) // Centralite Pearl\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;        // Local Temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 20;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0011;        // Occupied cooling setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl16BitBitMap;\n            rq4.attributeId = 0x0029;        // Thermostat running state\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange16bit = 0xffff;\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl8BitEnum;\n            rq5.attributeId = 0x001C;        // Thermostat mode\n            rq5.minInterval = 1;\n            rq5.maxInterval = 600;\n            rq5.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4, rq5});\n        }\n        else if (modelId == QLatin1String(\"PR412C\")) // OWON PCT502 Thermostat\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // Local Temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 50;\n\n            return sendConfigureReportingRequest(bt, {rq});\n        }\n        else if (sensor && (modelId == QLatin1String(\"0x8020\") || // Danfoss RT24V Display thermostat\n                            modelId == QLatin1String(\"0x8021\") || // Danfoss RT24V Display thermostat with floor sensor\n                            modelId == QLatin1String(\"0x8030\") || // Danfoss RTbattery Display thermostat\n                            modelId == QLatin1String(\"0x8031\") || // Danfoss RTbattery Display thermostat with infrared\n                            modelId == QLatin1String(\"0x8034\") || // Danfoss RTbattery Dial thermostat\n                            modelId == QLatin1String(\"0x8035\")))  // Danfoss RTbattery Dial thermostat with infrared\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // Local temperature\n            rq.minInterval = 60;\n            rq.maxInterval = 3600;\n            rq.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl8BitBitMap;\n            rq2.attributeId = 0x0002;        // Occupancy\n            rq2.minInterval = 60;\n            rq2.maxInterval = 43200;\n            rq2.reportableChange8bit = 1;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 43200;\n            rq3.reportableChange16bit = 1;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl16BitInt;\n            rq4.attributeId = 0x0014;        // Unoccupied heating setpoint\n            rq4.minInterval = 1;\n            rq4.maxInterval = 43200;\n            rq4.reportableChange16bit = 1;\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl8BitBitMap;\n            rq5.attributeId = 0x4110;        // Danfoss Output Status\n            rq5.minInterval = 60;\n            rq5.maxInterval = 3600;\n            rq5.reportableChange8bit = 1;\n            rq5.manufacturerCode = VENDOR_DANFOSS;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4}) || // Use OR because of manuf. specific attributes\n                   sendConfigureReportingRequest(bt, {rq5});\n        }\n        else if (modelId == QLatin1String(\"902010/32\")) // Bitron thermostat\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // local temperature\n            rq.minInterval = 0;\n            rq.maxInterval = 300;\n            rq.reportableChange16bit = 10;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0011;        // Occupied cooling setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl8BitEnum;\n            rq4.attributeId = 0x001B;        // Control Sequence of operation\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange8bit = 0xff;\n\n            ConfigureReportingRequest rq5;\n            rq5.dataType = deCONZ::Zcl8BitEnum;\n            rq5.attributeId = 0x001C;        // Thermostat mode\n            rq5.minInterval = 1;\n            rq5.maxInterval = 600;\n            rq5.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4, rq5});\n        }\n        else if (modelId == QLatin1String(\"TH1300ZB\")) // Sinope thermostat\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;       // local temperature\n            rq.minInterval = 60;\n            rq.maxInterval = 3600;\n            rq.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl8BitUint;\n            rq2.attributeId = 0x0008;        // Pi heating demand\n            rq2.minInterval = 60;\n            rq2.maxInterval = 43200;\n            rq2.reportableChange8bit = 1;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 43200;\n            rq3.reportableChange16bit = 1;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl8BitEnum;\n            rq4.attributeId = 0x001C;        // Thermostat mode\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4});\n        }\n        else if (modelId == QLatin1String(\"ALCANTARA2 D1.00P1.01Z1.00\")) // Alcantara 2 acova\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;         // Local Temperature\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0011;        // Occupied cooling setpoint\n            rq2.minInterval = 1;\n            rq2.maxInterval = 600;\n            rq2.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0012;        // Occupied heating setpoint\n            rq3.minInterval = 1;\n            rq3.maxInterval = 600;\n            rq3.reportableChange16bit = 50;\n\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl8BitEnum;\n            rq4.attributeId = 0x001C;        // Thermostat mode\n            rq4.minInterval = 1;\n            rq4.maxInterval = 600;\n            rq4.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4});\n        }\n        else\n        {\n            rq.dataType = deCONZ::Zcl16BitInt;\n            rq.attributeId = 0x0000;       // local temperature\n            rq.minInterval = 0;\n            rq.maxInterval = 300;\n            rq.reportableChange16bit = 10;\n            return sendConfigureReportingRequest(bt, {rq});\n        }\n    }\n    else if (bt.binding.clusterId == THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID)\n    {\n        if (modelId == QLatin1String(\"SORB\") ||               // Stelpro Orleans Fan\n                 modelId == QLatin1String(\"TH1300ZB\") ||           // Sinope thermostat\n                 modelId == QLatin1String(\"PR412C\") ||             // Owon thermostat\n                 modelId.startsWith(QLatin1String(\"3157100\")) ||   // Centralite pearl\n                 modelId.startsWith(QLatin1String(\"STZB402\")))     // Stelpro baseboard thermostat\n        {\n            rq.dataType = deCONZ::Zcl8BitEnum;\n            rq.attributeId = 0x0001;       // Keypad Lockout\n            rq.minInterval = 1;\n            rq.maxInterval = 43200;\n            rq.reportableChange8bit = 0xff;\n\n            return sendConfigureReportingRequest(bt, {rq});\n        }\n    }\n    else if (bt.binding.clusterId == FAN_CONTROL_CLUSTER_ID)\n    {\n        if (modelId.startsWith(QLatin1String(\"3157100\")))   // Centralite pearl\n        {\n            rq.dataType = deCONZ::Zcl8BitEnum;\n            rq.attributeId = 0x0000;        // Fan mode\n            rq.minInterval = 1;\n            rq.maxInterval = 600;\n            rq.reportableChange8bit = 0xff;\n            return sendConfigureReportingRequest(bt, {rq});\n        }\n    }\n    else if (bt.binding.clusterId == RELATIVE_HUMIDITY_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitUint;\n        rq.attributeId = 0x0000;       // measured value\n        rq.minInterval = 10;\n        rq.maxInterval = 300;\n        rq.reportableChange16bit = 100; // resolution: 1%\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == PRESSURE_MEASUREMENT_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitUint;\n        rq.attributeId = 0x0000; // measured value\n        rq.minInterval = 10;\n        rq.maxInterval = 300;\n        rq.reportableChange16bit = 20;\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == SOIL_MOISTURE_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitUint;\n        rq.attributeId = 0x0000; // measured value\n        rq.minInterval = 10;\n        rq.maxInterval = 300;\n        rq.reportableChange16bit = 20;\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == BINARY_INPUT_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::ZclBoolean;\n        rq.attributeId = 0x0055; // present value\n        rq.minInterval = 10;\n        rq.maxInterval = 300;\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == POWER_CONFIGURATION_CLUSTER_ID)\n    {\n        // Thoses device use only Attribute 0x0000 for tension and 0x001 for frequency\n        if (modelId == QLatin1String(\"SLP2\") ||\n            modelId == QLatin1String(\"SLP2b\"))\n        {\n            return false;\n        }\n\n        rq.dataType = deCONZ::Zcl8BitUint;\n        rq.attributeId = 0x0021;   // battery percentage remaining\n        if (modelId.startsWith(QLatin1String(\"SPZB\")))   // Eurotronic Spirit\n        {\n            rq.minInterval = 7200;       // value used by Hue bridge\n            rq.maxInterval = 7200;       // value used by Hue bridge\n            rq.reportableChange8bit = 0; // value used by Hue bridge\n        }\n        else if (modelId == QLatin1String(\"0x8020\") ||   // Danfoss RT24V Display thermostat\n                 modelId == QLatin1String(\"0x8021\") ||   // Danfoss RT24V Display thermostat with floor sensor\n                 modelId == QLatin1String(\"0x8030\") ||   // Danfoss RTbattery Display thermostat\n                 modelId == QLatin1String(\"0x8031\") ||   // Danfoss RTbattery Display thermostat with infrared\n                 modelId == QLatin1String(\"0x8034\") ||   // Danfoss RTbattery Dial thermostat\n                 modelId == QLatin1String(\"0x8035\"))     // Danfoss RTbattery Dial thermostat with infrared\n        {\n            rq.minInterval = 3600;         // Vendor defaults\n            rq.maxInterval = 43200;        // Vendor defaults\n            rq.reportableChange8bit = 2;   // Vendor defaults\n        }\n        else if (modelId == QLatin1String(\"4512705\") ||          // Namron remote control\n                 modelId == QLatin1String(\"4512726\") ||          // Namron rotary switch\n                 modelId == QLatin1String(\"CCT591011_AS\") ||     // LK Wiser Door / Window Sensor\n                 modelId == QLatin1String(\"CCT592011_AS\") ||     // LK Wiser Water Leak Sensor\n                 modelId.startsWith(QLatin1String(\"S57003\")) ||  // SLC switches\n                 modelId == QLatin1String(\"CCT593011_AS\") ||     // LK Wiser Temperature and Humidity Sensor\n                 modelId == QLatin1String(\"CCT595011_AS\") ||     // LK Wiser Motion Sensor\n                 modelId == QLatin1String(\"ZB-DoorSensor-D0003\") || // Linkind Door/Window Sensor\n                 modelId.startsWith(QLatin1String(\"FNB56-\")) ||  // Feibit devices\n                 modelId.startsWith(QLatin1String(\"FB56-\")))     // Feibit devices\n        {\n            rq.minInterval = 3600;\n            rq.maxInterval = 43200;\n            rq.reportableChange8bit = 1;\n        }\n        else if (modelId == QLatin1String(\"HG06323\") || // LIDL\n                 modelId == QLatin1String(\"lumi.flood.agl02\"))           // Xiaomi Aqara T1 water leak sensor SJCGQ12LM\n        {\n            rq.minInterval = 7200;\n            rq.maxInterval = 7200;\n            rq.reportableChange8bit = 1;\n        }\n        else if (sensor && (sensor->manufacturer().startsWith(QLatin1String(\"Climax\")) ||\n                            modelId.startsWith(QLatin1String(\"902010/23\"))))\n        {\n            rq.attributeId = 0x0035; // battery alarm mask\n            rq.dataType = deCONZ::Zcl8BitBitMap;\n            rq.minInterval = 300;\n            rq.maxInterval = 1800;\n            rq.reportableChange8bit = 0xFF;\n        }\n        else if (modelId == QLatin1String(\"tagv4\") ||\n                 modelId == QLatin1String(\"motionv4\") ||\n                 modelId == QLatin1String(\"moisturev4\") ||\n                 modelId == QLatin1String(\"multiv4\") ||\n                 modelId == QLatin1String(\"RFDL-ZB-MS\") ||\n                 modelId == QLatin1String(\"SZ-DWS04\") ||\n                 modelId == QLatin1String(\"Zen-01\") ||\n                 modelId == QLatin1String(\"Bell\") ||\n                 modelId == QLatin1String(\"ISW-ZPR1-WP13\") ||\n                 modelId == QLatin1String(\"SLT2\") ||\n                 modelId == QLatin1String(\"SLT3\") ||\n                 modelId == QLatin1String(\"TS0202\") || // Tuya sensor\n                 modelId == QLatin1String(\"3AFE14010402000D\") || // Konke presence sensor\n                 modelId == QLatin1String(\"3AFE28010402000D\") || // Konke presence sensor\n                 modelId.startsWith(QLatin1String(\"GZ-PIR02\")) ||          // Sercomm motion sensor\n                 modelId.startsWith(QLatin1String(\"SZ-WTD02N_CAR\")) ||     // Sercomm water sensor\n                 modelId.startsWith(QLatin1String(\"3300\")) ||          // Centralite contatc sensor\n                 modelId.startsWith(QLatin1String(\"3315\")) ||\n                 modelId.startsWith(QLatin1String(\"3157100\")) ||\n                 modelId == QLatin1String(\"URC4450BC0-X-R\") || // Xfinity Keypad XHK1-UE / URC4450BC0-X-R\n                 modelId == QLatin1String(\"3405-L\") || // IRIS 3405-L Keypad\n                 modelId.startsWith(QLatin1String(\"4655BC0\")))\n        {\n            rq.attributeId = 0x0020;   // battery voltage\n            rq.minInterval = 3600;\n            rq.maxInterval = 3600;\n            rq.reportableChange8bit = 0;\n        }\n        else if (modelId.startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                 modelId.startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                 modelId.startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) ||    // Osram 4 button remote\n                 modelId.startsWith(QLatin1String(\"Switch-LIGHTIFY\")))         // Osram 4 button remote\n        {\n            rq.attributeId = 0x0020;\n            rq.minInterval = 21600;\n            rq.maxInterval = 21600;\n            rq.reportableChange8bit = 0;\n        }\n        else if (modelId.startsWith(QLatin1String(\"MOSZB-1\")) ||         // Develco motion sensor\n                 modelId.startsWith(QLatin1String(\"FLSZB-1\")) ||         // Develco water leak sensor\n                 modelId.startsWith(QLatin1String(\"SIRZB-1\")) ||         // Develco siren\n                 modelId.startsWith(QLatin1String(\"ZHMS101\")) ||         // Wattle (Develco) magnetic sensor\n                 modelId.startsWith(QLatin1String(\"MotionSensor51AU\")))  // Aurora (Develco) motion sensor\n        {\n            rq.attributeId = 0x0020;   // battery voltage\n            rq.minInterval = 300;      // according to technical manual\n            rq.maxInterval = 43200;    // according to technical manual\n            rq.reportableChange8bit = 1;\n        }\n        else if (sensor && sensor->manufacturer() == QLatin1String(\"Samjin\"))\n        {\n            // https://github.com/SmartThingsCommunity/SmartThingsPublic/blob/master/devicetypes/smartthings/smartsense-multi-sensor.src/smartsense-multi-sensor.groovy\n            rq.minInterval = 30;\n            rq.maxInterval = 21600;\n            rq.reportableChange8bit = 10;\n        }\n        else if (modelId == QLatin1String(\"lumi.motion.agl04\"))                 // Xiaomi Aqara RTCGQ13LM high precision motion sensor\n        {\n            rq.attributeId = 0x0020;   // battery voltage\n            rq.minInterval = 3;\n            rq.maxInterval = 3600;\n            rq.reportableChange8bit = 1;\n        }\n        else\n        {\n            rq.minInterval = 300;\n            rq.maxInterval = 60 * 45;\n            rq.reportableChange8bit = 1;\n        }\n\n        // add values if not already present\n        deCONZ::NumericUnion dummy;\n        dummy.u64 = 0;\n        if (bt.restNode->getZclValue(POWER_CONFIGURATION_CLUSTER_ID, rq.attributeId, bt.binding.srcEndpoint).attributeId != rq.attributeId)\n        {\n            bt.restNode->setZclValue(NodeValue::UpdateInvalid, bt.binding.srcEndpoint, POWER_CONFIGURATION_CLUSTER_ID, rq.attributeId, dummy);\n        }\n\n        NodeValue &val = bt.restNode->getZclValue(POWER_CONFIGURATION_CLUSTER_ID, rq.attributeId, bt.binding.srcEndpoint);\n\n        if (val.timestampLastReport.isValid() && (val.timestampLastReport.secsTo(now) < val.maxInterval * 1.5))\n        {\n            return false;\n        }\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == ONOFF_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::ZclBoolean;\n        rq.attributeId = 0x0000; // on/off\n\n        if (existDevicesWithVendorCodeForMacPrefix(bt.restNode->address(), VENDOR_DDEL))\n        {\n            rq.minInterval = 5;\n            rq.maxInterval = 180;\n        }\n        else if (existDevicesWithVendorCodeForMacPrefix(bt.restNode->address(), VENDOR_XAL) ||\n                 manufacturerCode == VENDOR_XAL)\n        {\n            rq.minInterval = 5;\n            rq.maxInterval = 1200;\n        }\n        else if (manufacturerCode == VENDOR_IKEA)\n        {\n            // IKEA gateway uses min = 0, max = 0\n            // Instead here we use relaxed settings to not stress the network and device.\n            rq.minInterval = 1;\n            rq.maxInterval = 1800;\n        }\n        else // default configuration\n        {\n            rq.minInterval = 1;\n            rq.maxInterval = 300;\n        }\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == METERING_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl48BitUint;\n        rq.attributeId = 0x0000; // Curent Summation Delivered\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        if (modelId == QLatin1String(\"SmartPlug\") ||               // Heiman\n            modelId == QLatin1String(\"SKHMP30-I1\") ||              // GS smart plug\n            modelId.startsWith(QLatin1String(\"E13-\")) ||           // Sengled PAR38 Bulbs\n            modelId.startsWith(QLatin1String(\"Z01-A19\")))          // Sengled smart led\n        {\n            rq.reportableChange48bit = 10; // 0.001 kWh (1 Wh)\n        }\n        else if (modelId == QLatin1String(\"SZ-ESW01-AU\")) // Sercomm / Telstra smart plug\n        {\n            rq.reportableChange48bit = 1000; // 0.001 kWh (1 Wh)\n        }\n        else if (modelId.startsWith(QLatin1String(\"ROB_200\")) ||            // ROBB Smarrt micro dimmer\n                 modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")) || // Sunricher Micro Smart Dimmer\n                 modelId.startsWith(QLatin1String(\"SPW35Z\")))               // RT-RK OBLO SPW35ZD0 smart plug\n        {\n            rq.reportableChange48bit = 3600; // 0.001 kWh (1 Wh)\n        }\n        else\n        {\n            rq.reportableChange48bit = 1; // 0.001 kWh (1 Wh)\n        }\n\n        ConfigureReportingRequest rq2;\n        rq2.dataType = deCONZ::Zcl24BitInt;\n        rq2.attributeId = 0x0400; // Instantaneous Demand\n        rq2.minInterval = 1;\n        rq2.maxInterval = 300;\n        if (modelId == QLatin1String(\"SmartPlug\") ||        // Heiman\n            modelId == QLatin1String(\"902010/25\") ||        // Bitron\n            modelId == QLatin1String(\"SKHMP30-I1\") ||       // GS smart plug\n            modelId.startsWith(QLatin1String(\"Z01-A19\")) || // Sengled smart led\n            modelId == QLatin1String(\"160-01\"))             // Plugwise smart plug\n        {\n            rq2.reportableChange24bit = 10; // 1 W\n        }\n        else if (modelId == QLatin1String(\"SZ-ESW01-AU\")) // Sercomm / Telstra smart plug\n        {\n            rq2.reportableChange24bit = 1000; // 1 W\n        }\n        else\n        {\n            rq2.reportableChange24bit = 1; // 1 W\n        }\n\n        return sendConfigureReportingRequest(bt, {rq, rq2});\n    }\n    else if (bt.binding.clusterId == ELECTRICAL_MEASUREMENT_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitInt;\n        rq.attributeId = 0x050B; // Active power\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        if (modelId == QLatin1String(\"SmartPlug\") ||                   // Heiman\n            modelId == QLatin1String(\"SKHMP30-I1\") ||                  // GS smart plug\n            modelId == QLatin1String(\"SZ-ESW01-AU\") ||                 // Sercomm / Telstra smart plug\n            modelId.startsWith(QLatin1String(\"ROB_200\")) ||            // ROBB Smarrt micro dimmer\n            modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")) || // Sunricher Micro Smart Dimmer\n            modelId.startsWith(QLatin1String(\"lumi.switch.n0agl1\")) || // Xiaomi Aqara Single Switch Module T1 (With Neutral)\n            modelId.startsWith(QLatin1String(\"lumi.switch.b1naus01\"))) // Xiaomi ZB3.0 Smart Wall Switch\n        {\n            rq.reportableChange16bit = 10; // 1 W\n        }\n        else\n        {\n            rq.reportableChange16bit = 1; // 1 W\n        }\n\n        ConfigureReportingRequest rq2;\n        rq2.dataType = deCONZ::Zcl16BitUint;\n        rq2.attributeId = 0x0505; // RMS Voltage\n        rq2.minInterval = 1;\n        rq2.maxInterval = 300;\n        if (modelId == QLatin1String(\"SmartPlug\") ||           // Heiman\n            modelId == QLatin1String(\"PoP\") ||                 // Apex Smart Plug\n            modelId == QLatin1String(\"SKHMP30-I1\") ||          // GS smart plug\n            modelId == QLatin1String(\"SMRZB-1\") ||             // Develco smart cable\n            modelId == QLatin1String(\"Smart16ARelay51AU\"))     // Aurora (Develco) smart plug\n        {\n            rq2.reportableChange16bit = 100; // 1 V\n        }\n        else if (modelId == QLatin1String(\"SZ-ESW01-AU\")) // Sercomm / Telstra smart plug\n        {\n            rq2.reportableChange16bit = 125; // 1 V\n        }\n        else if (modelId.startsWith(QLatin1String(\"ROB_200\")) ||            // ROBB Smarrt micro dimmer\n                 modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")))   // Sunricher Micro Smart Dimmer\n        {\n            rq2.reportableChange16bit = 10; // 1 V\n        }\n        else\n        {\n            rq2.reportableChange16bit = 1; // 1 V\n        }\n\n        ConfigureReportingRequest rq3;\n        rq3.dataType = deCONZ::Zcl16BitUint;\n        rq3.attributeId = 0x0508; // RMS Current\n        rq3.minInterval = 1;\n        rq3.maxInterval = 300;\n        if (modelId == QLatin1String(\"PoP\") ||                     // Apex Smart Plug\n            modelId == QLatin1String(\"DoubleSocket50AU\") ||        // Aurora\n            modelId == QLatin1String(\"Smart16ARelay51AU\") ||       // Aurora (Develco) smart plug\n            modelId == QLatin1String(\"SZ-ESW01-AU\") ||             // Sercomm / Telstra smart plug\n            modelId == QLatin1String(\"SMRZB-1\") ||                 // Develco smart cable\n            modelId == QLatin1String(\"TS0121\"))                    // Tuya / Blitzwolf\n        {\n            rq3.reportableChange16bit = 100; // 0.1 A\n        }\n        else if (modelId == QLatin1String(\"SmartPlug\") ||        // Heiman\n                 modelId.startsWith(QLatin1String(\"EMIZB-1\")) || // Develco EMI\n                 modelId == QLatin1String(\"SKHMP30-I1\") ||       // GS smart plug\n                 modelId.startsWith(QLatin1String(\"SPW35Z\")) ||  // RT-RK OBLO SPW35ZD0 smart plug\n                 modelId == QLatin1String(\"TH1300ZB\"))           // Sinope thermostat\n        {\n            rq3.reportableChange16bit = 10; // 0.1 A\n        }\n        else\n        {\n            rq3.reportableChange16bit = 1; // 0.1 A\n        }\n\n        if (modelId == QLatin1String(\"TH1300ZB\"))\n        {\n            ConfigureReportingRequest rq4;\n            rq4.dataType = deCONZ::Zcl16BitUint;\n            rq4.attributeId = 0x050f; // Apparent power\n            rq4.minInterval = 1;\n            rq4.maxInterval = 300;\n            rq4.reportableChange16bit = 100; // 0.1 W\n\n            return sendConfigureReportingRequest(bt, {rq2, rq3, rq4});\n        }\n\n        return sendConfigureReportingRequest(bt, {rq, rq2, rq3});\n    }\n    else if (bt.binding.clusterId == LEVEL_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl8BitUint;\n        rq.attributeId = 0x0000; // current level\n\n        if (existDevicesWithVendorCodeForMacPrefix(bt.restNode->address(), VENDOR_DDEL))\n        {\n            rq.minInterval = 5;\n            rq.maxInterval = 180;\n            rq.reportableChange8bit = 5;\n        }\n        else if (manufacturerCode ==  VENDOR_IKEA)\n        {\n            // IKEA gateway uses min = 1, max = 0, change = 0\n            // Instead here we use relaxed settings to not stress the network and device.\n            rq.minInterval = 5;\n            rq.maxInterval = 1800;\n            rq.reportableChange8bit = 1;\n        }\n        else // default configuration\n        {\n            rq.minInterval = 1;\n            rq.maxInterval = 300;\n            rq.reportableChange8bit = 1;\n        }\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == WINDOW_COVERING_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl8BitUint;\n        rq.attributeId = 0x0008; // Current Position Lift Percentage\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        rq.reportableChange8bit = 1;\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == DOOR_LOCK_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl8BitEnum;;\n        rq.attributeId = 0x0000; // Current Lock Position\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        //rq.reportableChange8bit = 1;\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == FAN_CONTROL_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl8BitEnum;\n        rq.attributeId = 0x0000; // fan speed\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == COLOR_CLUSTER_ID)\n    {\n        rq.dataType = deCONZ::Zcl16BitUint;\n        rq.attributeId = 0x0007; // color temperature\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        rq.reportableChange16bit = 1;\n\n        ConfigureReportingRequest rq2;\n        rq2.dataType = deCONZ::Zcl16BitUint;\n        rq2.attributeId = 0x0003; // colorX\n        rq2.minInterval = 1;\n        rq2.maxInterval = 300;\n        rq2.reportableChange16bit = 10;\n\n        ConfigureReportingRequest rq3;\n        rq3.dataType = deCONZ::Zcl16BitUint;\n        rq3.attributeId = 0x0004; // colorY\n        rq3.minInterval = 1;\n        rq3.maxInterval = 300;\n        rq3.reportableChange16bit = 10;\n\n        ConfigureReportingRequest rq4;\n        rq4.dataType = deCONZ::Zcl8BitEnum;\n        rq4.attributeId = 0x0008; // color mode\n        rq4.minInterval = 1;\n        rq4.maxInterval = 300;\n\n        if (manufacturerCode == VENDOR_IKEA)\n        {\n            // IKEA gateway uses all zero values for min, max and change, which results in very rapid reports.\n            // Instead here we use relaxed settings to not stress the network and device.\n            rq.minInterval = 5;\n            rq.maxInterval = 1800;\n            rq.reportableChange16bit = 1;\n            rq2.minInterval = 5;\n            rq2.maxInterval = 1795;\n            rq2.reportableChange16bit = 10;\n            rq3.minInterval = 5;\n            rq3.maxInterval = 1795;\n            rq3.reportableChange16bit = 10;\n            rq4.minInterval = 1;\n            rq4.maxInterval = 1800;\n\n//          TODO re activate. Don't disable for now until more testing is done.\n//            const ResourceItem *cap = lightNode ? lightNode->item(RCapColorCapabilities) : nullptr;\n\n//            if (cap && (cap->toNumber() & 0x0008) == 0) // doesn't support xy --> color temperature light\n//            {\n//                rq2.minInterval = 0;\n//                rq2.maxInterval = 0xffff; // disable reporting\n//                rq3.minInterval = 0;\n//                rq3.maxInterval = 0xffff; // disable reporting\n//            }\n        }\n\n        return sendConfigureReportingRequest(bt, {rq, rq2, rq3, rq4});\n    }\n    else if (bt.binding.clusterId == SAMJIN_CLUSTER_ID)\n    {\n        // based on https://github.com/SmartThingsCommunity/SmartThingsPublic/blob/master/devicetypes/smartthings/smartsense-multi-sensor.src/smartsense-multi-sensor.groovy\n        if (sensor && sensor->type() == QLatin1String(\"ZHAVibration\"))\n        {\n            const quint16 manufacturerCode2 = sensor->manufacturer() == QLatin1String(\"Samjin\") ? VENDOR_SAMJIN\n                : sensor->manufacturer() == QLatin1String(\"SmartThings\") ? VENDOR_PHYSICAL : VENDOR_CENTRALITE;\n            const quint16 minInterval = manufacturerCode2 == VENDOR_SAMJIN ? 0 : 1;\n\n            rq.dataType = deCONZ::Zcl8BitBitMap;\n            rq.attributeId = 0x0010; // active\n            rq.minInterval = manufacturerCode2 == VENDOR_SAMJIN ? 0 : 10;\n            rq.maxInterval = 3600;\n            rq.reportableChange8bit = 0xFF;\n            rq.manufacturerCode = manufacturerCode2;\n\n            ConfigureReportingRequest rq1;\n            rq1.dataType = deCONZ::Zcl16BitInt;\n            rq1.attributeId = 0x0012; // acceleration x\n            rq1.minInterval = minInterval;\n            rq1.maxInterval = 3600;\n            rq1.reportableChange16bit = 1;\n            rq1.manufacturerCode = manufacturerCode2;\n\n            ConfigureReportingRequest rq2;\n            rq2.dataType = deCONZ::Zcl16BitInt;\n            rq2.attributeId = 0x0013; // acceleration y\n            rq2.minInterval = minInterval;\n            rq2.maxInterval = 3600;\n            rq2.reportableChange16bit = 1;\n            rq2.manufacturerCode = manufacturerCode2;\n\n            ConfigureReportingRequest rq3;\n            rq3.dataType = deCONZ::Zcl16BitInt;\n            rq3.attributeId = 0x0014; // acceleration z\n            rq3.minInterval = minInterval;\n            rq3.maxInterval = 3600;\n            rq3.reportableChange16bit = 1;\n            rq3.manufacturerCode = manufacturerCode2;\n\n            return sendConfigureReportingRequest(bt, {rq, rq1, rq2, rq3});\n        }\n    }\n    else if (bt.binding.clusterId == BASIC_CLUSTER_ID && manufacturerCode == VENDOR_IKEA && lightNode)\n    {\n        deCONZ::NumericUnion dummy;\n        dummy.u64 = 0;\n        // 'sw build id' value if not already present\n        if (bt.restNode->getZclValue(BASIC_CLUSTER_ID, 0x4000, bt.binding.srcEndpoint).attributeId != 0x4000)\n        {\n            bt.restNode->setZclValue(NodeValue::UpdateInvalid, bt.binding.srcEndpoint, BASIC_CLUSTER_ID, 0x4000, dummy);\n        }\n\n        NodeValue &val = bt.restNode->getZclValue(BASIC_CLUSTER_ID, 0x4000, bt.binding.srcEndpoint);\n\n        if (val.timestampLastReport.isValid() && (val.timestampLastReport.secsTo(now) > val.maxInterval * 1.5))\n        {\n            return false; // reporting this attribute might be already disabled\n        }\n\n        // already configured? wait for report ...\n        if (val.timestampLastConfigured.isValid() && (val.timestampLastConfigured.secsTo(now) < val.maxInterval * 1.5))\n        {\n            return false;\n        }\n\n        rq.dataType = deCONZ::ZclCharacterString;\n        rq.attributeId = 0x4000; // sw build id\n        rq.minInterval = 0;   // value used by IKEA gateway\n        rq.maxInterval = 0xffff; // disable reporting to prevent group casts\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n    else if (bt.binding.clusterId == BASIC_CLUSTER_ID && manufacturerCode == VENDOR_MUELLER && lightNode)\n    {\n        rq.dataType = deCONZ::Zcl8BitUint;\n        rq.attributeId = 0x4005; // Mueller special scene\n        rq.minInterval = 1;\n        rq.maxInterval = 300;\n        rq.reportableChange8bit = 1;\n        rq.manufacturerCode = VENDOR_MUELLER;\n\n        return sendConfigureReportingRequest(bt, {rq});\n    }\n\n    return false;\n}\n\n/*! Creates binding for attribute reporting to gateway node. */\nvoid DeRestPluginPrivate::checkLightBindingsForAttributeReporting(LightNode *lightNode)\n{\n    if (!apsCtrl || !lightNode || !lightNode->address().hasExt())\n    {\n        return;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, lightNode->address().ext());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    BindingTask::Action action = BindingTask::ActionUnbind;\n\n    // whitelist\n    if (gwReportingEnabled)\n    {\n        action = BindingTask::ActionBind;\n        if (lightNode->manufacturer() == QLatin1String(\"OSRAM\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"LEDVANCE\"))\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_JASCO)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_UBISYS)\n        {\n        }\n        // Danalock support\n        else if (lightNode->manufacturerCode() == VENDOR_DANALOCK)\n        {\n            DBG_Printf(DBG_INFO, \"Binding DanaLock\\n\");\n        }\n        // Schlage support\n        else if (lightNode->manufacturerCode() == VENDOR_SCHLAGE)\n        {\n            DBG_Printf(DBG_INFO, \"Binding Schlage\\n\");\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_IKEA)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_EMBER)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_LGE)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_MUELLER)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_KEEN_HOME)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_SUNRICHER)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_XAL)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_SINOPE)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_OWON)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_XIAOMI)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_STELPRO)\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_DATEK)\n        {\n        }\n        else if (lightNode->modelId().startsWith(QLatin1String(\"SP \")))\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"Climax\")))\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"Bitron\")))\n        {\n        }\n        else if (lightNode->modelId() == QLatin1String(\"NL08-0800\")) // Nanoleaf Ivy\n        {\n        }\n        else if (lightNode->modelId().startsWith(QLatin1String(\"ICZB-\"))) // iCasa Dimmer and Switch\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"Develco\"))) // Develco devices\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Aurora\"))\n        {\n        }\n        else if (lightNode->modelId().startsWith(QLatin1String(\"RICI01\"))) // LifeControl smart plug\n        {\n        }\n        else if (lightNode->modelId() == QLatin1String(\"SPLZB-131\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Computime\")) //Hive\n        {\n        }\n        else if (lightNode->manufacturer() == QString(\"欧瑞博\") || lightNode->manufacturer() == QLatin1String(\"ORVIBO\"))\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_LEGRAND) // Legrand switch and plug\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_NETVOX) // Netvox smart plug\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"ptvo.info\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"DIYRUZ\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Immax\"))\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"EcoDim\")))\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"ROBB smarrt\")))\n        {\n        }\n        else if (lightNode->manufacturer().startsWith(QLatin1String(\"Feibit\")))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"sengled\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"LDS\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Vimar\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Sercomm Corp.\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Kwikset\"))\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_YALE)\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"NIKO NV\"))\n        {\n        }\n        else if (lightNode->manufacturerCode() == VENDOR_AXIS || lightNode->manufacturerCode() == VENDOR_MMB) // Axis shade\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"yookee\") || // IDK if it s better use VENDOR_SI_LABS\n                 lightNode->manufacturer() == QLatin1String(\"yooksmart\"))\n        {\n        }\n        else if (lightNode->manufacturer() == QLatin1String(\"Sunricher\"))\n        {\n        }\n        else\n        {\n            return;\n        }\n    }\n    else\n    {\n        return;\n    }\n\n    auto i = lightNode->haEndpoint().inClusters().begin();\n    const auto end = lightNode->haEndpoint().inClusters().end();\n\n    int tasksAdded = 0;\n    QDateTime now = QDateTime::currentDateTime();\n\n    for (; i != end; ++i)\n    {\n        switch (i->id())\n        {\n        case BASIC_CLUSTER_ID:\n        case ONOFF_CLUSTER_ID:\n        case LEVEL_CLUSTER_ID:\n        case COLOR_CLUSTER_ID:\n        case WINDOW_COVERING_CLUSTER_ID:\n        // Danalock support\n        case DOOR_LOCK_CLUSTER_ID:\n        case IAS_ZONE_CLUSTER_ID:\n        case FAN_CONTROL_CLUSTER_ID:\n        {\n            bool bindingExists = false;\n            for (const NodeValue &val : lightNode->zclValues())\n            {\n                if (val.clusterId != i->id())\n                {\n                    continue;\n                }\n\n                quint16 maxInterval = val.maxInterval > 0 && val.maxInterval < 65535 ? (val.maxInterval * 3 / 2) : (60 * 6);\n\n                if (val.timestampLastReport.isValid() && val.timestampLastReport.secsTo(now) < maxInterval)\n                {\n                    bindingExists = true;\n                    break;\n                }\n\n                if (val.timestampLastConfigured.isValid())\n                {\n                    bindingExists = true;\n                    break;\n                }\n            }\n\n            // only IKEA lights should report basic cluster attributes\n            if (lightNode->manufacturerCode() != VENDOR_IKEA && i->id() == BASIC_CLUSTER_ID)\n            {\n                continue;\n            }\n\n            BindingTask bt;\n            if (existDevicesWithVendorCodeForMacPrefix(lightNode->address(), VENDOR_DDEL))\n            {\n                bt.state = BindingTask::StateCheck;\n            }\n            else\n            {\n                bt.state = BindingTask::StateIdle;\n            }\n            bt.action = action;\n            bt.restNode = lightNode;\n            Binding &bnd = bt.binding;\n            bnd.srcAddress = lightNode->address().ext();\n            bnd.dstAddrMode = deCONZ::ApsExtAddress;\n            bnd.srcEndpoint = lightNode->haEndpoint().endpoint();\n            bnd.clusterId = i->id();\n            bnd.dstAddress.ext = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n            bnd.dstEndpoint = endpoint();\n\n            if (bnd.dstEndpoint > 0) // valid gateway endpoint?\n            {\n                if (bindingExists)\n                {\n                    DBG_Printf(DBG_INFO, \"binding for cluster 0x%04X of 0x%016llX exists (verified by reporting)\\n\", i->id(), lightNode->address().ext());\n                    sendConfigureReportingRequest(bt);\n                }\n                else\n                {\n                    DBG_Printf(DBG_INFO_L2, \"create binding for attribute reporting of cluster 0x%04X\\n\", i->id());\n                    queueBindingTask(bt);\n                    tasksAdded++;\n                }\n            }\n        }\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    if (tasksAdded == 0)\n    {\n        return;\n    }\n\n    if (existDevicesWithVendorCodeForMacPrefix(lightNode->address(), VENDOR_DDEL) || lightNode->manufacturerCode() == VENDOR_XAL)\n    {\n        lightNode->enableRead(READ_BINDING_TABLE);\n        lightNode->setNextReadTime(READ_BINDING_TABLE, queryTime);\n        queryTime = queryTime.addSecs(5);\n        Q_Q(DeRestPlugin);\n        q->startZclAttributeTimer(1000);\n    }\n\n    if (!bindingTimer->isActive())\n    {\n        bindingTimer->start();\n    }\n}\n\n\n/*! Creates binding for attribute reporting to gateway node.\n    \\return true - when a binding request got queued.\n */\nbool DeRestPluginPrivate::checkSensorBindingsForAttributeReporting(Sensor *sensor)\n{\n    if (!apsCtrl || !sensor || !sensor->address().hasExt() || !sensor->node() || !sensor->toBool(RConfigReachable))\n    {\n        return false;\n    }\n\n    if (searchSensorsState != SearchSensorsActive &&\n        idleTotalCounter < (IDLE_READ_LIMIT + (60 * 15))) // wait for some input before fire bindings\n    {\n        return false;\n    }\n\n    if (sensor->node()->nodeDescriptor().isNull())\n    {\n        // Whitelist sensors which don't seem to have a valid node descriptor.\n        // This is a workaround currently only required for Develco smoke sensor\n        // and potentially Bosch motion sensor\n        if (sensor->modelId().startsWith(QLatin1String(\"EMIZB-1\")) ||     // Develco EMI Norwegian HAN\n            sensor->modelId().startsWith(QLatin1String(\"ISW-ZPR1-WP13\"))) // Bosch motion sensor\n        {\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    if (sensor->deletedState() != Sensor::StateNormal)\n    {\n        return false;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, sensor->address().ext());\n    if (device && device->managed())\n    {\n        return false;\n    }\n\n    bool deviceSupported = false;\n    // whitelist\n        // Climax\n    if (sensor->modelId().startsWith(QLatin1String(\"LM_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"LMHT_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"IR_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"DC_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"PSMD_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"PSMP5_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"PCM_\")) ||\n        // CentraLite\n        sensor->modelId().startsWith(QLatin1String(\"3300\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"332\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3200-Sgb\")) ||\n        sensor->modelId() == QLatin1String(\"3200-de\") ||\n        sensor->modelId().startsWith(QLatin1String(\"3305-S\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3315\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3320-L\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3323\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3326-L\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"3157100\")) ||\n        // GE\n        (sensor->manufacturer() == QLatin1String(\"Jasco Products\") && sensor->modelId() == QLatin1String(\"45856\")) ||\n        // NYCE\n        sensor->modelId() == QLatin1String(\"3011\") ||\n        sensor->modelId() == QLatin1String(\"3014\") ||\n        sensor->modelId() == QLatin1String(\"3041\") ||\n        sensor->modelId() == QLatin1String(\"3043\") ||\n        //Datek\n        sensor->modelId().startsWith(QLatin1String(\"ID Lock 150\")) ||\n        // Yale\n        sensor->modelId() == QLatin1String(\"YRD256 TSDB\") ||\n        sensor->modelId() == QLatin1String(\"YRD226 TSDB\") ||\n        sensor->modelId() == QLatin1String(\"YRD226/246 TSDB\") ||\n        sensor->modelId() == QLatin1String(\"YRD220/240 TSDB\") ||\n        sensor->modelId() == QLatin1String(\"easyCodeTouch_v1\") ||\n        // IKEA\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")) ||\n        // OSRAM\n        sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) || // Osram 4 button remote\n        // Keen Home\n        sensor->modelId().startsWith(QLatin1String(\"SV01-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"SV02-\")) ||\n        // Trust ZPIR-8000\n        sensor->modelId().startsWith(QLatin1String(\"VMS_ADUROLIGHT\")) ||\n        // Trust ZMST-808\n        sensor->modelId().startsWith(QLatin1String(\"CSW_ADUROLIGHT\")) ||\n        // iCasa\n        sensor->modelId().startsWith(QLatin1String(\"ICZB-RM\")) ||\n        // Envilar\n        sensor->modelId() == QLatin1String(\"ZGR904-S\") ||\n        // innr\n        sensor->modelId().startsWith(QLatin1String(\"SP \")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RC 110\")) ||\n        // Eurotronic\n        sensor->modelId() == QLatin1String(\"SPZB0001\") ||\n        // Heiman\n        // I don't think the IAS Zone sensor need to be listed here?\n        sensor->modelId().startsWith(QLatin1String(\"SmartPlug\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"CO_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"DOOR_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"PIR_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"GAS\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TH-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"HT-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"SMOK_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"WATER_\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"Smoke\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"COSensor\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"Water\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"Door\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"WarningDevice\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"PIRS\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"SKHMP30\")) || // GS smart plug\n        sensor->modelId().startsWith(QLatin1String(\"RC_V14\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RC-EM\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RC-EF-3.0\")) ||\n        // lidl / SilverCrest\n        sensor->modelId() == QLatin1String(\"TY0203\") ||  // Door sensor\n        sensor->modelId() == QLatin1String(\"TY0202\") || // Motion Sensor\n        sensor->modelId() == QLatin1String(\"TS0211\") || // Door bell\n        // DIYRuZ\n        sensor->modelId() == QLatin1String(\"DIYRuZ_Flower\") || // DIYRuZ_Flower\n        // Konke\n        sensor->modelId() == QLatin1String(\"3AFE140103020000\") ||\n        sensor->modelId() == QLatin1String(\"3AFE130104020015\") ||\n        sensor->modelId() == QLatin1String(\"3AFE14010402000D\") ||\n        sensor->modelId() == QLatin1String(\"3AFE220103020000\") ||\n        sensor->modelId() == QLatin1String(\"3AFE28010402000D\") ||\n        // Danalock support\n        sensor->modelId().startsWith(QLatin1String(\"V3\")) ||\n        // Schlage support\n        sensor->modelId().startsWith(QLatin1String(\"BE468\")) ||\n        // SmartThings\n        sensor->modelId().startsWith(QLatin1String(\"tagv4\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"motionv4\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"moisturev4\")) ||\n        sensor->modelId() == QLatin1String(\"button\") ||\n        (sensor->manufacturer() == QLatin1String(\"Samjin\") && sensor->modelId() == QLatin1String(\"motion\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"multi\")) ||\n        sensor->modelId() == QLatin1String(\"water\") ||\n        (sensor->manufacturer() == QLatin1String(\"Samjin\") && sensor->modelId() == QLatin1String(\"outlet\")) ||\n        // Axis\n        sensor->modelId() == QLatin1String(\"Gear\") ||\n        // Yookee\n        sensor->modelId() == QLatin1String(\"D10110\") ||\n        // Datek\n        sensor->modelId() == QLatin1String(\"PoP\") ||\n        // Bitron\n        sensor->modelId().startsWith(QLatin1String(\"902010\")) ||\n        // Develco\n        sensor->modelId().startsWith(QLatin1String(\"FLSZB-1\")) ||   // water leak sensor\n        sensor->modelId().startsWith(QLatin1String(\"MOSZB-1\")) ||   // motion sensor\n        sensor->modelId().startsWith(QLatin1String(\"ZHMS101\")) ||   // Wattle (Develco) magnetic sensor\n        sensor->modelId().startsWith(QLatin1String(\"EMIZB-1\")) ||   // EMI Norwegian HAN\n        sensor->modelId().startsWith(QLatin1String(\"SMRZB-3\")) ||   // Smart Relay DIN\n        sensor->modelId().startsWith(QLatin1String(\"SMRZB-1\")) ||   // Smart Cable\n        sensor->modelId().startsWith(QLatin1String(\"SIRZB-1\")) ||   // siren\n        sensor->modelId() == QLatin1String(\"MotionSensor51AU\") ||   // Aurora (Develco) motion sensor\n        sensor->modelId() == QLatin1String(\"Smart16ARelay51AU\") ||  // Aurora (Develco) smart plug\n        // LG\n        sensor->modelId() == QLatin1String(\"LG IP65 HMS\") ||\n        // Sinope\n        sensor->modelId().startsWith(QLatin1String(\"WL4200\")) || // water leak sensor\n        sensor->modelId().startsWith(QLatin1String(\"TH1300ZB\")) || // thermostat\n        //LifeControl smart plug\n        sensor->modelId() == QLatin1String(\"RICI01\") ||\n        //LifeControl enviroment sensor\n        sensor->modelId() == QLatin1String(\"VOC_Sensor\") ||\n        // EDP-WITHUS\n        sensor->modelId() == QLatin1String(\"ZB-SmartPlug-1.0.0\") ||\n        sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMController-D0800\")) || // Mueller-Licht tint dimmer\n        //Legrand\n        sensor->modelId() == QLatin1String(\"Connected outlet\") || //Legrand Plug\n        sensor->modelId() == QLatin1String(\"Shutter switch with neutral\") || //Legrand shutter switch\n        sensor->modelId() == QLatin1String(\"Shutter SW with level control\") || //Bticino shutter small size\n        sensor->modelId() == QLatin1String(\"Dimmer switch w/o neutral\") || //Legrand dimmer wired\n        sensor->modelId() == QLatin1String(\"Cable outlet\") || //Legrand Cable outlet\n        sensor->modelId() == QLatin1String(\"Remote switch\") || //Legrand wireless switch\n        sensor->modelId() == QLatin1String(\"Double gangs remote switch\") || //Legrand wireless double switch\n        sensor->modelId() == QLatin1String(\"Shutters central remote switch\") || //Legrand wireless shutter switch\n        sensor->modelId() == QLatin1String(\"DIN power consumption module\") || //Legrand DIN power consumption module\n        sensor->modelId() == QLatin1String(\"Remote motion sensor\") || //Legrand Motion detector\n        sensor->modelId() == QLatin1String(\"Remote toggle switch\") || //Legrand switch module\n        sensor->modelId() == QLatin1String(\"Teleruptor\") || //Legrand teleruptor\n        sensor->modelId() == QLatin1String(\"Contactor\") || //Legrand Contactor\n        sensor->modelId() == QLatin1String(\"Pocket remote\") || //Legrand wireless remote 4 scene\n        // Adeo\n        sensor->modelId() == QLatin1String(\"LDSENK10\") || // ADEO Animal compatible motion sensor (Leroy Merlin)\n        // Philio\n        sensor->modelId() == QLatin1String(\"PST03A-v2.2.5\") || //Philio pst03-a\n        // ORVIBO\n        sensor->modelId() == QLatin1String(\"c3442b4ac59b4ba1a83119d938f283ab\") ||\n        sensor->modelId().startsWith(QLatin1String(\"SN10ZW\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"SF2\")) ||\n        sensor->modelId() == QLatin1String(\"e70f96b3773a4c9283c6862dbafb6a99\") ||\n        // Netvox\n        sensor->modelId().startsWith(QLatin1String(\"Z809A\")) ||\n        // Samsung SmartPlug 2019\n        sensor->modelId().startsWith(QLatin1String(\"ZB-ONOFFPlug-D0005\")) ||\n        // Aurora\n        sensor->modelId().startsWith(QLatin1String(\"DoubleSocket50AU\")) ||\n        // Ecolink\n        sensor->modelId().startsWith(QLatin1String(\"4655BC0\")) ||\n        // Bosch\n        sensor->modelId().startsWith(QLatin1String(\"ISW-ZDL1-WP11G\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"ISW-ZPR1-WP13\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RFDL-ZB-MS\")) ||\n        (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && sensor->modelId() == QLatin1String(\"AIR\")) ||\n        // Salus\n        sensor->modelId().contains(QLatin1String(\"SP600\")) ||\n        sensor->modelId().contains(QLatin1String(\"SPE600\")) ||\n        // Zen\n        sensor->modelId().contains(QLatin1String(\"Zen-01\")) ||\n        // eCozy\n        sensor->modelId() == QLatin1String(\"Thermostat\") ||\n        // Alcantara\n        sensor->modelId() == QLatin1String(\"ALCANTARA2 D1.00P1.01Z1.00\") ||\n        // Stelpro\n        sensor->modelId().contains(QLatin1String(\"ST218\")) ||\n        sensor->modelId().contains(QLatin1String(\"STZB402\")) ||\n        sensor->modelId() == QLatin1String(\"SORB\") ||\n        // Tuya\n        sensor->modelId().startsWith(QLatin1String(\"TS01\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS02\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS03\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS0202\")) || // motion sensor, manu = _TYZB01_zwvaj5wy\n        sensor->modelId().startsWith(QLatin1String(\"TS0043\")) || // to test\n        sensor->modelId().startsWith(QLatin1String(\"TS0041\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS0044\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS0203\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TS0222\")) || // TYZB01 light sensor\n        sensor->modelId().startsWith(QLatin1String(\"TS004F\")) || // 4 Gang Tuya ZigBee Wireless 12 Scene Switch\n        sensor->modelId().startsWith(QLatin1String(\"TS011F\")) || // Plugs\n        // Tuyatec\n        sensor->modelId().startsWith(QLatin1String(\"RH3040\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RH3001\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"RH3052\")) ||\n        // Xiaomi\n        sensor->modelId().startsWith(QLatin1String(\"lumi.switch.b1naus01\")) ||\n        sensor->modelId() == QLatin1String(\"lumi.motion.agl04\") ||\n        sensor->modelId() == QLatin1String(\"lumi.flood.agl02\") ||\n        sensor->modelId() == QLatin1String(\"lumi.switch.n0agl1\") ||\n        // iris\n        sensor->modelId().startsWith(QLatin1String(\"1116-S\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"1117-S\")) ||\n        // ELKO\n        sensor->modelId().startsWith(QLatin1String(\"Super TR\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"ElkoDimmer\")) ||\n        // Hive\n        sensor->modelId() == QLatin1String(\"MOT003\") ||\n        sensor->modelId() == QLatin1String(\"DWS003\") ||\n        //Computime\n        sensor->modelId() == QLatin1String(\"SLP2\") ||\n        sensor->modelId() == QLatin1String(\"SLP2b\") ||\n        sensor->modelId() == QLatin1String(\"SLR2\") ||\n        sensor->modelId() == QLatin1String(\"SLR2b\") ||\n        sensor->modelId() == QLatin1String(\"SLR1b\") ||\n        sensor->modelId() == QLatin1String(\"SLT2\") ||\n        sensor->modelId() == QLatin1String(\"SLT3\") ||\n        // Sengled\n        sensor->modelId().startsWith(QLatin1String(\"E13-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"E1D-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"E1E-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"Z01-A19\")) ||\n        // Linkind\n        sensor->modelId() == QLatin1String(\"ZB-MotionSensor-D0003\") ||\n        sensor->modelId() == QLatin1String(\"ZB-DoorSensor-D0003\") ||\n        // LK Wiser\n        sensor->modelId() == QLatin1String(\"CCT591011_AS\") ||\n        sensor->modelId() == QLatin1String(\"CCT592011_AS\") ||\n        sensor->modelId() == QLatin1String(\"CCT593011_AS\") ||\n        sensor->modelId() == QLatin1String(\"CCT595011_AS\") ||\n        // Immax\n        sensor->modelId() == QLatin1String(\"4in1-Sensor-ZB3.0\") ||\n        sensor->modelId() == QLatin1String(\"DoorWindow-Sensor-ZB3.0\") ||\n        // Casa.IA\n        sensor->modelId().startsWith(QLatin1String(\"CTHS317ET\")) ||\n        // Sercomm\n        sensor->modelId().startsWith(QLatin1String(\"SZ-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"GZ-\")) ||\n        sensor->modelId() == QLatin1String(\"Tripper\") ||\n        // WAXMAN\n        sensor->modelId() == QLatin1String(\"leakSMART Water Sensor V2\") ||\n        // GamaBit\n        sensor->modelId() == QLatin1String(\"GMB-HAS-WL-B01\") ||\n        sensor->modelId() == QLatin1String(\"GMB-HAS-DW-B01\") ||\n        sensor->modelId() == QLatin1String(\"GMB-HAS-VB-B01\") ||\n        // RGBgenie\n        sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"ZG2833PAC\")) || // Sunricher C4\n        // Embertec\n        sensor->modelId().startsWith(QLatin1String(\"BQZ10-AU\")) ||\n        // ROBB Smarrt\n        sensor->modelId().startsWith(QLatin1String(\"ROB_200\")) ||\n        // Sunricher\n        sensor->modelId().startsWith(QLatin1String(\"Micro Smart Dimmer\")) ||\n        sensor->modelId() == QLatin1String(\"4512705\") || // Namron remote control\n        sensor->modelId() == QLatin1String(\"4512726\") || // Namron rotary switch\n        sensor->modelId().startsWith(QLatin1String(\"ZG2835\")) ||\n        // RT-RK\n        sensor->modelId().startsWith(QLatin1String(\"SPW35Z\")) ||\n        // SLC\n        sensor->modelId().startsWith(QLatin1String(\"S57003\")) ||\n        // Plugwise\n        sensor->modelId().startsWith(QLatin1String(\"160-01\")) ||\n        // Feibit\n        sensor->modelId().startsWith(QLatin1String(\"FNB56-\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"FB56-\")) ||\n        // Niko\n        sensor->modelId() == QLatin1String(\"Smart plug Zigbee PE\") ||\n        // Sage\n        sensor->modelId() == QLatin1String(\"Bell\") ||\n        // Owon\n        sensor->modelId() == QLatin1String(\"PR412C\") ||\n        // D-Link\n        sensor->modelId() == QLatin1String(\"DCH-B112\") ||\n        sensor->modelId() == QLatin1String(\"DCH-B122\") ||\n        // Sonoff\n        sensor->modelId() == QLatin1String(\"WB01\") ||\n        sensor->modelId() == QLatin1String(\"WB-01\") ||\n        sensor->modelId() == QLatin1String(\"MS01\") ||\n        sensor->modelId() == QLatin1String(\"MSO1\") ||\n        sensor->modelId() == QLatin1String(\"ms01\") ||\n        sensor->modelId() == QLatin1String(\"66666\") ||\n        sensor->modelId() == QLatin1String(\"TH01\") ||\n        sensor->modelId() == QLatin1String(\"DS01\") ||\n        // Danfoss\n        sensor->modelId() == QLatin1String(\"0x8020\") ||\n        sensor->modelId() == QLatin1String(\"0x8021\") ||\n        sensor->modelId() == QLatin1String(\"0x8030\") ||\n        sensor->modelId() == QLatin1String(\"0x8031\") ||\n        sensor->modelId() == QLatin1String(\"0x8034\") ||\n        sensor->modelId() == QLatin1String(\"0x8035\") ||\n        // Swann\n        sensor->modelId() == QLatin1String(\"SWO-MOS1PA\") ||\n        // LIDL\n        sensor->modelId() == QLatin1String(\"HG06323\") ||\n        // Xfinity\n        sensor->modelId() == QLatin1String(\"URC4450BC0-X-R\") ||\n        // Iris\n        sensor->modelId() == QLatin1String(\"3405-L\") ||\n        // Eria\n        sensor->modelId() == QLatin1String(\"Adurolight_NCC\")\n        )\n    {\n        deviceSupported = true;\n        if (!sensor->node()->nodeDescriptor().receiverOnWhenIdle() ||\n            (sensor->node()->nodeDescriptor().manufacturerCode() != VENDOR_DDEL))\n        {\n            sensor->setMgmtBindSupported(false);\n        }\n    }\n\n    if (!deviceSupported)\n    {\n        DBG_Printf(DBG_INFO_L2, \"don't create binding for attribute reporting of sensor %s\\n\", qPrintable(sensor->name()));\n        return false;\n    }\n\n    // prevent binding action if otau was busy recently\n    if (otauLastBusyTimeDelta() < OTA_LOW_PRIORITY_TIME)\n    {\n        if (sensor->modelId().startsWith(QLatin1String(\"FLS-\")))\n        {\n            DBG_Printf(DBG_INFO_L2, \"don't check binding for attribute reporting of %s (otau busy)\\n\", qPrintable(sensor->name()));\n            return false;\n        }\n    }\n\n    BindingTask::Action action = BindingTask::ActionUnbind;\n\n    // whitelist by Model ID\n    if (gwReportingEnabled)\n    {\n        if (deviceSupported)\n        {\n            action = BindingTask::ActionBind;\n        }\n    }\n\n    if (sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n        sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) ) // Osram 4 button remote\n    {\n        // Make bind only for endpoint 01\n        if (sensor->fingerPrint().endpoint != 0x01)\n        {\n            return false;\n        }\n    }\n\n    bool ret = false;\n    bool checkBindingTable = false;\n    QDateTime now = QDateTime::currentDateTime();\n\n    // sort server clusters so that 'more important' clusters will be bound as soon as possible\n    // 0xfc00, 0x0500, 0x0406, 0x0402, 0x0400, 0x0001\n\n    // for example for Philips motion sensor after joining the occupancy cluster 0x0406 is more\n    // important than power configuration cluster 0x0001 and should be bound first\n\n    // for the Philips dimmer switch the 0xfc00 for button events is also the most important\n    std::vector<quint16> inClusters = sensor->fingerPrint().inClusters;\n    std::sort(sensor->fingerPrint().inClusters.begin(), sensor->fingerPrint().inClusters.end(),\n              [](quint16 a, quint16 b) { return a < b; });\n\n    std::vector<quint16>::const_iterator i = inClusters.begin();\n    std::vector<quint16>::const_iterator end = inClusters.end();\n\n    for (; i != end; ++i)\n    {\n        NodeValue val;\n\n        if (*i == ILLUMINANCE_MEASUREMENT_CLUSTER_ID)\n        {\n            if (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && sensor->modelId() == QLatin1String(\"AIR\"))\n            {\n                continue; // use BOSCH_AIR_QUALITY_CLUSTER_ID instead\n            }\n            val = sensor->getZclValue(*i, 0x0000); // measured value\n        }\n        else if (*i == TEMPERATURE_MEASUREMENT_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // measured value\n        }\n        else if (*i == RELATIVE_HUMIDITY_CLUSTER_ID)\n        {\n            if (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && sensor->modelId() == QLatin1String(\"AIR\"))\n            {\n                continue; // use BOSCH_AIR_QUALITY_CLUSTER_ID instead\n            }\n            val = sensor->getZclValue(*i, 0x0000); // measured value\n        }\n        else if (*i == PRESSURE_MEASUREMENT_CLUSTER_ID)\n        {\n            if (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && sensor->modelId() == QLatin1String(\"AIR\"))\n            {\n                continue; // use BOSCH_AIR_QUALITY_CLUSTER_ID instead\n            }\n            val = sensor->getZclValue(*i, 0x0000); // measured value\n        }\n        else if (*i == SOIL_MOISTURE_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // measured value\n        }\n        else if (*i == OCCUPANCY_SENSING_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // occupied state\n        }\n        else if (*i == POWER_CONFIGURATION_CLUSTER_ID)\n        {\n            if (sensor->manufacturer() == QLatin1String(\"Samjin\") && sensor->modelId() == QLatin1String(\"multi\") && sensor->type() != QLatin1String(\"ZHAOpenClose\"))\n            {\n                continue; // process only once\n            }\n\n            if (sensor->modelId() == QLatin1String(\"Remote switch\") ||\n                sensor->modelId() == QLatin1String(\"Shutters central remote switch\") ||\n                sensor->modelId() == QLatin1String(\"Double gangs remote switch\") ||\n                sensor->modelId() == QLatin1String(\"Pocket remote\") ||\n                sensor->modelId() == QLatin1String(\"Remote toggle switch\") )\n            {\n                //Those device don't support report attribute\n                continue;\n            }\n            if (sensor->manufacturer().startsWith(QLatin1String(\"Climax\")) ||\n                sensor->modelId().startsWith(QLatin1String(\"902010/23\")))\n            {\n                val = sensor->getZclValue(*i, 0x0035); // battery alarm mask\n            }\n            else if (sensor->modelId().startsWith(QLatin1String(\"MOSZB-1\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"FLSZB-1\")) ||\n                     sensor->modelId() == QLatin1String(\"MotionSensor51AU\") ||\n                     sensor->modelId() == QLatin1String(\"Zen-01\") ||\n                     sensor->modelId() == QLatin1String(\"ISW-ZPR1-WP13\") ||\n                     sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                     sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                     sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                     sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) || // Osram 4 button remote\n                     sensor->modelId().startsWith(QLatin1String(\"moisturev4\")) || // SmartThings water leak sensor\n                     sensor->modelId() == QLatin1String(\"Remote switch\") ||\n                     sensor->modelId() == QLatin1String(\"Shutters central remote switch\") ||\n                     sensor->modelId() == QLatin1String(\"Double gangs remote switch\") ||\n                     sensor->modelId() == QLatin1String(\"Pocket remote\") ||\n                     sensor->modelId().startsWith(QLatin1String(\"ZHMS101\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"3AFE14010402000D\")) || //konke presence sensor\n                     sensor->modelId().startsWith(QLatin1String(\"3AFE28010402000D\")) || //konke presence sensor\n                     sensor->modelId().startsWith(QLatin1String(\"TS0202\")) || //Tuya presence sensor\n                     sensor->modelId().endsWith(QLatin1String(\"86opcn01\")) || // Aqara Opple\n                     sensor->modelId() == QLatin1String(\"lumi.motion.agl04\") || // Xiaomi Aqara RTCGQ13LM high precision motion sensor\n                     sensor->modelId().startsWith(QLatin1String(\"1116-S\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"1117-S\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"3323\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"3326-L\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"3305-S\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"3157100\")) ||\n                     sensor->modelId().startsWith(QLatin1String(\"4655BC0\")) ||\n                     sensor->modelId() == QLatin1String(\"URC4450BC0-X-R\") || // Xfinity Keypad XHK1-UE\n                     sensor->modelId() == QLatin1String(\"3405-L\") || // IRIS 3405-L Keypad\n                     sensor->modelId() == QLatin1String(\"113D\"))\n            {\n                val = sensor->getZclValue(*i, 0x0020); // battery voltage\n            }\n            else\n            {\n                val = sensor->getZclValue(*i, 0x0021); // battery percentage remaining\n            }\n\n            if (sensor->modelId() == QLatin1String(\"TRADFRI remote control\") && sensor->swVersion() == QLatin1String(\"0.9.8.1-5.7.0.0\"))\n            {\n                continue; // too old doesn't support battery percentage remaining attribute\n            }\n\n            if (val.timestampLastConfigured.isValid() && val.timestampLastConfigured.secsTo(now) < (val.maxInterval * 1.5))\n            {\n                continue;\n            }\n\n            // assume reporting is working\n            if (val.isValid() && val.timestamp.isValid() && val.timestamp.secsTo(now) < (val.maxInterval * 3 / 2))\n            {\n                continue;\n            }\n        }\n        else if (*i == IAS_ZONE_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID); // zone status\n\n            if (sensor->manufacturer() == QLatin1String(\"CentraLite\"))\n            {\n                const ResourceItem *item = sensor->item(RConfigDuration);\n                // update max reporting interval according to config.duration\n                if (item && item->toNumber() > 15 && item->toNumber() <= UINT16_MAX)\n                {\n                    val.maxInterval = static_cast<quint16>(item->toNumber());\n                    val.maxInterval -= 5; // report before going presence: false\n                }\n            }\n        }\n        else if (*i == BOSCH_AIR_QUALITY_CLUSTER_ID && sensor->modelId() == QLatin1String(\"AIR\"))\n        {\n            if (sensor->type() != QLatin1String(\"ZHAAirQuality\"))\n            {\n                continue; // only bind once\n            }\n            val = sensor->getZclValue(*i, 0x4004, 0x02); // air quality\n        }\n        else if (*i == METERING_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // Curent Summation Delivered\n\n        }\n        else if (*i == ELECTRICAL_MEASUREMENT_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x050b); // Active power\n        }\n        else if (*i == BINARY_INPUT_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0055); // Present value\n        }\n        else if (*i == THERMOSTAT_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // Local temperature\n        }\n        else if (*i == FAN_CONTROL_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0000); // Fan mode\n        }\n        else if (*i == THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0001); // Keypad lockout\n        }\n        else if (*i == SAMJIN_CLUSTER_ID)\n        {\n            val = sensor->getZclValue(*i, 0x0012); // Acceleration X\n        }\n\n        quint16 maxInterval = val.maxInterval > 0 && val.maxInterval < 65535 ? (val.maxInterval * 3 / 2) : (60 * 15);\n\n        if (!DEV_TestManaged())\n        {\n            if (val.timestampLastReport.isValid() && val.timestampLastReport.secsTo(now) < maxInterval) // got update in timely manner\n            {\n                DBG_Printf(DBG_INFO_L2, \"binding for attribute reporting of ep: 0x%02X cluster 0x%04X seems to be active\\n\", val.endpoint, *i);\n                continue;\n            }\n\n            if (!sensor->node()->nodeDescriptor().receiverOnWhenIdle() && sensor->lastRx().secsTo(now) > 6)\n            {\n                DBG_Printf(DBG_INFO, \"skip binding for attribute reporting of ep: 0x%02X cluster 0x%04X (end-device might sleep)\\n\", val.endpoint, *i);\n                return false;\n            }\n        }\n\n        quint8 srcEndpoint = sensor->fingerPrint().endpoint;\n\n        {  // some clusters might not be on fingerprint endpoint (power configuration), search in other simple descriptors\n            deCONZ::SimpleDescriptor *sd = sensor->node()->getSimpleDescriptor(srcEndpoint);\n            if (!sd || !sd->cluster(*i, deCONZ::ServerCluster))\n            {\n                for (auto &sd2 : sensor->node()->simpleDescriptors())\n                {\n                    if (sd2.cluster(*i, deCONZ::ServerCluster))\n                    {\n                        srcEndpoint = sd2.endpoint();\n                        break;\n                    }\n                }\n            }\n        }\n\n        switch (*i)\n        {\n        case POWER_CONFIGURATION_CLUSTER_ID:\n        case OCCUPANCY_SENSING_CLUSTER_ID:\n        case IAS_ZONE_CLUSTER_ID:\n        case ILLUMINANCE_MEASUREMENT_CLUSTER_ID:\n        case TEMPERATURE_MEASUREMENT_CLUSTER_ID:\n        case RELATIVE_HUMIDITY_CLUSTER_ID:\n        case PRESSURE_MEASUREMENT_CLUSTER_ID:\n        case SOIL_MOISTURE_CLUSTER_ID:\n        case METERING_CLUSTER_ID:\n        case ELECTRICAL_MEASUREMENT_CLUSTER_ID:\n        case VENDOR_CLUSTER_ID:\n        case BASIC_CLUSTER_ID:\n        case BINARY_INPUT_CLUSTER_ID:\n        case THERMOSTAT_CLUSTER_ID:\n        case FAN_CONTROL_CLUSTER_ID:\n        case THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID:\n        case DIAGNOSTICS_CLUSTER_ID:\n        case APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID:\n        case SAMJIN_CLUSTER_ID:\n        case DOOR_LOCK_CLUSTER_ID:\n        case BOSCH_AIR_QUALITY_CLUSTER_ID:\n        {\n            // For the moment reserved to doorlock device\n            if (*i == DOOR_LOCK_CLUSTER_ID && sensor->type() != QLatin1String(\"ZHADoorLock\"))\n            {\n                break;\n            }\n\n            DBG_Printf(DBG_INFO_L2, \"0x%016llX (%s) create binding for attribute reporting of cluster 0x%04X on endpoint 0x%02X\\n\",\n                       sensor->address().ext(), qPrintable(sensor->modelId()), (*i), srcEndpoint);\n\n            BindingTask bindingTask;\n\n            if (sensor->mgmtBindSupported())\n            {\n                bindingTask.state = BindingTask::StateCheck;\n                checkBindingTable = true;\n            }\n            else\n            {\n                bindingTask.state = BindingTask::StateIdle;\n            }\n\n            if (DEV_TestManaged())\n            {\n                bindingTask.state = BindingTask::StateFinished; // don't actually send anything\n            }\n\n            bindingTask.action = action;\n            bindingTask.restNode = sensor;\n            bindingTask.timeout = BindingTask::TimeoutEndDevice;\n            Binding &bnd = bindingTask.binding;\n            bnd.srcAddress = sensor->address().ext();\n            bnd.dstAddrMode = deCONZ::ApsExtAddress;\n            bnd.srcEndpoint = srcEndpoint;\n            bnd.clusterId = *i;\n            bnd.dstAddress.ext = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n            bnd.dstEndpoint = endpoint();\n\n            if (bnd.dstEndpoint > 0) // valid gateway endpoint?\n            {\n                ret = queueBindingTask(bindingTask);\n            }\n\n            if (*i == IAS_ZONE_CLUSTER_ID)\n            {\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    if (checkBindingTable)\n    {\n        sensor->enableRead(READ_BINDING_TABLE);\n        sensor->setNextReadTime(READ_BINDING_TABLE, queryTime);\n        queryTime = queryTime.addSecs(5);\n        Q_Q(DeRestPlugin);\n        q->startZclAttributeTimer(1000);\n    }\n\n    if (ret)\n    {\n        // fast iteration\n        bindingTimer->start(0);\n    }\n    else if (!bindingTimer->isActive())\n    {\n        bindingTimer->start(1000);\n    }\n\n    return ret;\n}\n\n/*! Creates binding for group control (switches, motion sensor, ...). */\nbool DeRestPluginPrivate::checkSensorBindingsForClientClusters(Sensor *sensor)\n{\n    if (!apsCtrl || !sensor || !sensor->node() || !sensor->address().hasExt() || !sensor->toBool(RConfigReachable))\n    {\n        return false;\n    }\n\n    if (searchSensorsState != SearchSensorsActive &&\n        idleTotalCounter < (IDLE_READ_LIMIT + (60 * 15))) // wait for some input before fire bindings\n    {\n        return false;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, sensor->address().ext());\n    if (device && device->managed())\n    {\n        return false;\n    }\n\n    Q_Q(DeRestPlugin);\n    QDateTime now = QDateTime::currentDateTime();\n    if (!sensor->node()->nodeDescriptor().receiverOnWhenIdle() && sensor->lastRx().secsTo(now) > 10)\n    {\n        DBG_Printf(DBG_INFO_L2, \"skip check bindings for client clusters (end-device might sleep)\\n\");\n        return false;\n    }\n\n    ResourceItem *item = sensor->item(RConfigGroup);\n\n    if (!item || item->toString().isEmpty())\n    {\n        DBG_Printf(DBG_INFO_L2, \"skip check bindings for client clusters (no group)\\n\");\n        return false;\n    }\n\n    std::vector<quint8> srcEndpoints;\n    QStringList gids = item->toString().split(',', SKIP_EMPTY_PARTS);\n\n    //quint8 srcEndpoint = sensor->fingerPrint().endpoint;\n    std::vector<quint16> clusters;\n\n    if (sensor->modelId().startsWith(QLatin1String(\"ElkoDimmer\")) || // Elko dimmer\n        sensor->modelId().startsWith(QLatin1String(\"E1E-\"))) // Sengled smart light switch\n    {\n        srcEndpoints.push_back(0x01);\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n    }\n    // Busch-Jaeger\n    else if (sensor->modelId() == QLatin1String(\"RB01\") ||\n             sensor->modelId() == QLatin1String(\"RM01\"))\n    {\n        quint8 firstEp = 0x0A;\n\n        // the model RM01 might have an relais or dimmer switch on endpoint 0x12\n        // in that case the endpoint 0x0A has no function\n        if (getLightNodeForAddress(sensor->address(), 0x12))\n        {\n            firstEp = 0x0B;\n        }\n\n        if (sensor->fingerPrint().endpoint == firstEp)\n        {\n            clusters.push_back(LEVEL_CLUSTER_ID);\n        }\n        else if (sensor->fingerPrint().endpoint > firstEp)\n        {\n            clusters.push_back(SCENE_CLUSTER_ID);\n        }\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n        sensor->setMgmtBindSupported(false);\n    }\n    // GE on/off switch 45856GE\n    else if (sensor->manufacturer() == QLatin1String(\"Jasco Products\") && sensor->modelId() == QLatin1String(\"45856\"))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // IKEA Trådfri dimmer\n    else if (sensor->modelId() == QLatin1String(\"TRADFRI wireless dimmer\"))\n    {\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // IKEA Trådfri remote\n    else if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI remote\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(SCENE_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // IKEA\n    else if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI on/off switch\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"TRADFRI SHORTCUT Button\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // IKEA Trådfri open/close remote\n    else if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI open/close remote\")))\n    {\n        clusters.push_back(WINDOW_COVERING_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // IKEA Trådfri motion sensor\n    else if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI motion sensor\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"WB01\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"WB-01\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // OSRAM 3 button remote\n    else if (sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) )\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(COLOR_CLUSTER_ID);\n\n        // We bind all endpoints to a single group, so we need to trick the for loop by\n        // creating dummy group entries that point to the first group so all endpoints are bound properly.\n        QString gid0 = gids[0];\n        gids.append(gid0);\n        gids.append(gid0);\n\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n    }\n    // OSRAM 4 button remote\n    else if (sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) )\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(COLOR_CLUSTER_ID);\n\n        // We bind all endpoints to a single group, so we need to trick the for loop by\n        // creating dummy group entries that point to the first group so all endpoints are bound properly.\n        QString gid0 = gids[0];\n        gids.append(gid0);\n        gids.append(gid0);\n        gids.append(gid0);\n\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n    }\n    // LEGRAND Remote switch, simple and double\n    else if (sensor->modelId() == QLatin1String(\"Remote switch\") ||\n             sensor->modelId() == QLatin1String(\"Double gangs remote switch\"))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // LEGRAND Remote switch 4 scene\n    else if (sensor->modelId() == QLatin1String(\"Pocket remote\"))\n    {\n        clusters.push_back(SCENE_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId() == QLatin1String(\"ZBT-CCTSwitch-D0001\"))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(COLOR_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // LEGRAND Remote shutter switch\n    else if (sensor->modelId() == QLatin1String(\"Shutters central remote switch\"))\n    {\n        clusters.push_back(WINDOW_COVERING_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId() == QLatin1String(\"Remote toggle switch\") || // LEGRAND switch micro module\n             sensor->modelId() == QLatin1String(\"Remote motion sensor\"))  //Legrand motion sensor\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"RC 110\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        gids.removeFirst(); // Remote doesn't support bindings on first endpoint.\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n        srcEndpoints.push_back(0x05);\n        srcEndpoints.push_back(0x06);\n        srcEndpoints.push_back(0x07);\n        srcEndpoints.push_back(0x08);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"ZGRC-TEUR-\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(SCENE_CLUSTER_ID);\n        clusters.push_back(COLOR_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"ICZB-RM\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"ZGR904-S\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY-013\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5001\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(SCENE_CLUSTER_ID);\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"ZG2833PAC\"))) // Sunricher C4\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n    }\n    else if (sensor->modelId() == QLatin1String(\"4512705\") || // Namron remote control\n             sensor->modelId() == QLatin1String(\"4512726\") || // Namron rotary switch\n             sensor->modelId().startsWith(QLatin1String(\"S57003\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(SCENE_CLUSTER_ID);\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"D1\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        sensor->setMgmtBindSupported(true);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"S1-R\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(0x02);\n        if (sensor->modelId().startsWith(QLatin1String(\"S1-R\")))\n        {\n            srcEndpoints.push_back(0x03);\n        }\n        sensor->setMgmtBindSupported(true);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"S2-R\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n        sensor->setMgmtBindSupported(true);\n    }\n    // Bitron remote control\n    else if (sensor->modelId().startsWith(QLatin1String(\"902010/23\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // Heiman remote control\n    else if (sensor->modelId().startsWith(QLatin1String(\"TS0215\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"RC_V14\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"RC-EM\")) ||\n             sensor->modelId() == QLatin1String(\"URC4450BC0-X-R\") ||\n             sensor->modelId() == QLatin1String(\"3405-L\") ||\n             sensor->modelId().startsWith(QLatin1String(\"RC-EF-3.0\")))\n    {\n        clusters.push_back(IAS_ACE_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5\")) || // RGBgenie remote control\n             sensor->manufacturer() == QLatin1String(\"_TZ3000_xabckq1v\") || // 4 Gang Tuya ZigBee Wireless 12 Scene Switch\n             sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMController-D0800\"))) // Mueller-Licht tint dimmer\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        clusters.push_back(SCENE_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // RGBgenie remote control\n    else if (sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY-012\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(0x01);\n        srcEndpoints.push_back(0x02);\n        srcEndpoints.push_back(0x03);\n        srcEndpoints.push_back(0x04);\n        srcEndpoints.push_back(0x05);\n    }\n    // Sage doorbell sensor\n    else if (sensor->modelId().startsWith(QLatin1String(\"Bell\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    // Linkind 1 key Remote Control / ZS23000178\n    // SR-ZG2835 Zigbee Rotary Switch\n    else if (sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMSwitch\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"ZG2835\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"Adurolight_NCC\")))\n    {\n        clusters.push_back(ONOFF_CLUSTER_ID);\n        clusters.push_back(LEVEL_CLUSTER_ID);\n        srcEndpoints.push_back(sensor->fingerPrint().endpoint);\n    }\n    else\n    {\n        return false;\n    }\n\n    // prevent binding action if otau was busy recently\n    if (otauLastBusyTimeDelta() < OTA_LOW_PRIORITY_TIME)\n    {\n        return false;\n    }\n\n    bool ret = false;\n    for (int j = 0; j < (int)srcEndpoints.size() && j < gids.size(); j++)\n    {\n        quint8 srcEndpoint = srcEndpoints[j];\n        Group *group = getGroupForId(gids[j]);\n\n        if (!group)\n        {\n            continue;\n        }\n\n        std::vector<quint16>::const_iterator i = clusters.begin();\n        std::vector<quint16>::const_iterator end = clusters.end();\n\n        for (; i != end; ++i)\n        {\n            DBG_Printf(DBG_ZDP, \"0x%016llX [%s] create binding for client cluster 0x%04X on endpoint 0x%02X\\n\",\n                       sensor->address().ext(), qPrintable(sensor->modelId()), (*i), srcEndpoint);\n\n            BindingTask bindingTask;\n\n            bindingTask.state = BindingTask::StateIdle;\n            bindingTask.action = BindingTask::ActionBind;\n            bindingTask.timeout = BindingTask::TimeoutEndDevice;\n            bindingTask.restNode = sensor;\n            Binding &bnd = bindingTask.binding;\n            bnd.srcAddress = sensor->address().ext();\n            bnd.dstAddrMode = deCONZ::ApsGroupAddress;\n            bnd.srcEndpoint = srcEndpoint;\n            bnd.clusterId = *i;\n            bnd.dstAddress.group = group->address();\n\n            if (sensor->mgmtBindSupported())\n            {\n                bindingTask.state = BindingTask::StateCheck;\n            }\n\n            if (queueBindingTask(bindingTask))\n            {\n                ret = true;\n            }\n\n            // group addressing has no destination endpoint\n//            bnd.dstEndpoint = endpoint();\n\n//            if (bnd.dstEndpoint > 0) // valid gateway endpoint?\n//            {\n//                queueBindingTask(bindingTask);\n//            }\n        }\n    }\n\n    if (sensor->mgmtBindSupported())\n    {\n        if (!sensor->mustRead(READ_BINDING_TABLE))\n        {\n            sensor->enableRead(READ_BINDING_TABLE);\n            sensor->setNextReadTime(READ_BINDING_TABLE, queryTime);\n            queryTime = queryTime.addSecs(1);\n        }\n        q->startZclAttributeTimer(1000);\n    }\n\n    if (!bindingTimer->isActive())\n    {\n        bindingTimer->start();\n    }\n\n    return ret;\n}\n\n/*! Creates groups for \\p sensor if needed. */\nvoid DeRestPluginPrivate::checkSensorGroup(Sensor *sensor)\n{\n    if (!sensor)\n    {\n        return;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, sensor->address().ext());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    Group *group = nullptr;\n\n    {\n        std::vector<Group>::iterator i = groups.begin();\n        std::vector<Group>::iterator end = groups.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->address() == 0)\n            {\n                continue;\n            }\n\n            if (i->state() == Group::StateNormal &&\n                (i->deviceIsMember(sensor->uniqueId()) || i->deviceIsMember(sensor->id())))\n            {\n                group = &*i;\n                break;\n            }\n        }\n    }\n\n    if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI on/off switch\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI SHORTCUT Button\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"Remote Control N2\")) || // STYRBAR\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI open/close remote\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI motion sensor\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI remote control\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"TRADFRI wireless dimmer\")) ||\n        // sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")) ||\n        sensor->modelId().startsWith(QLatin1String(\"902010/23\")) || // bitron remote\n        sensor->modelId().startsWith(QLatin1String(\"Adurolight_NCC\")) || // Eria Adurosmart Wireless Dimming Switch\n        sensor->modelId().startsWith(QLatin1String(\"WB01\")) || // Sonoff SNZB-01\n        sensor->modelId().startsWith(QLatin1String(\"WB-01\")) || // Sonoff SNZB-01\n        sensor->modelId().startsWith(QLatin1String(\"Bell\")) || // Sage doorbell sensor\n        sensor->modelId().startsWith(QLatin1String(\"ZBT-CCTSwitch-D0001\")) || //LDS Remote\n        sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMSwitch\")) || // Linkind 1 key Remote Control / ZS23000178\n        sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMController-D0800\")) || // Mueller-Licht tint dimmer\n        sensor->modelId().startsWith(QLatin1String(\"ElkoDimmer\")) || // Elko dimmer\n        sensor->modelId().startsWith(QLatin1String(\"E1E-\")) || // Sengled smart light switch\n        sensor->modelId().startsWith(QLatin1String(\"ZG2835\")) || // SR-ZG2835 Zigbee Rotary Switch\n        sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5121\"))) // RGBgenie ZB-5121 remote\n    {\n\n    }\n    else if (sensor->modelId() == QLatin1String(\"Remote switch\") ||\n         sensor->modelId() == QLatin1String(\"Double gangs remote switch\") ||\n\t     sensor->modelId() == QLatin1String(\"Shutters central remote switch\") ||\n         sensor->modelId() == QLatin1String(\"Remote toggle switch\") ||\n         sensor->modelId() == QLatin1String(\"Remote motion sensor\"))\n    {\n        //Make group but without uniqueid\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) ) // Osram 4 button remote\n    {\n        quint8 maxEp = 0x03;\n        if (sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) ||\n            sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) ||\n            sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) )\n        {\n            maxEp = 0x04;\n        }\n        for (quint8 ep = 0x01; !group && ep <= maxEp; ep++)\n        {\n            Sensor *s = getSensorNodeForAddressAndEndpoint(sensor->address(), ep);\n            if (s && s->deletedState() == Sensor::StateNormal && s != sensor)\n            {\n                ResourceItem *item = s->item(RConfigGroup);\n                if (item && item->lastSet().isValid())\n                {\n                    const QString &gid = item->toString();\n\n                    std::vector<Group>::iterator i = groups.begin();\n                    std::vector<Group>::iterator end = groups.end();\n\n                    for (; i != end; ++i)\n                    {\n                        if (!gid.isEmpty() && i->state() == Group::StateNormal && i->id() == gid)\n                        {\n                            group = &*i;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else if (sensor->modelId() == QLatin1String(\"RB01\") ||\n             sensor->modelId() == QLatin1String(\"RM01\"))\n    {\n        // check if group is created for other endpoint\n        for (quint8 ep = 0x0A; !group && ep < 0x0F; ep++)\n        {\n            Sensor *s = getSensorNodeForAddressAndEndpoint(sensor->address(), ep);\n            if (s && s->deletedState() == Sensor::StateNormal && s != sensor)\n            {\n                ResourceItem *item = s->item(RConfigGroup);\n                if (item && item->lastSet().isValid())\n                {\n                    const QString &gid = item->toString();\n\n                    std::vector<Group>::iterator i = groups.begin();\n                    std::vector<Group>::iterator end = groups.end();\n\n                    for (; i != end; ++i)\n                    {\n                        if (!gid.isEmpty() && i->state() == Group::StateNormal && i->id() == gid)\n                        {\n                            group = &*i;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        return;\n    }\n\n    ResourceItem *item = sensor->item(RConfigGroup);\n\n    if (!item)\n    {\n        item = sensor->addItem(DataTypeString, RConfigGroup);\n    }\n    else if (!group && item->lastSet().isValid())\n    {\n        const QString &gid = item->toString(); //FIXME: handle list of groups\n\n        std::vector<Group>::iterator i = groups.begin();\n        std::vector<Group>::iterator end = groups.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->address() == 0)\n            {\n                continue;\n            }\n\n            if (!gid.isEmpty() && i->state() == Group::StateNormal && i->id() == gid)\n            {\n                group = &*i;\n                break;\n            }\n        }\n    }\n\n    if (!group)\n    {\n        group = addGroup();\n        group->setName(sensor->name());\n        ResourceItem *item2 = group->addItem(DataTypeString, RAttrUniqueId);\n        DBG_Assert(item2);\n        if (item2)\n        {\n            const QString uid = generateUniqueId(sensor->address().ext(), 0, 0);\n            item2->setValue(uid);\n        }\n    }\n\n    DBG_Assert(group);\n    if (!group)\n    {\n        return;\n    }\n\n    if (group->addDeviceMembership(sensor->id()))\n    {\n\n    }\n\n    if (item->toString() != group->id()) // FIXME: handle list of groups\n    {\n        item->setValue(group->id()); // FIXME: handle list of groups\n        sensor->setNeedSaveDatabase(true);\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        Event e(RSensors, RConfigGroup, sensor->id(), item);\n        enqueueEvent(e);\n    }\n}\n\n/*! Checks if there are any orphan groups for \\p sensor and removes them. */\nvoid DeRestPluginPrivate::checkOldSensorGroups(Sensor *sensor)\n{\n    if (!sensor)\n    {\n        return;\n    }\n\n    ResourceItem *item = sensor->item(RConfigGroup);\n\n    if (!item || !item->lastSet().isValid() || item->toString().isEmpty())\n    {\n        return;\n    }\n\n    QStringList gids = item->toString().split(',', SKIP_EMPTY_PARTS);\n\n    {\n        auto i = groups.begin();\n        const auto end = groups.end();\n\n        for (; i != end; ++i)\n        {\n            if (gids.contains(i->id())) // current group\n            {\n                if (i->state() != Group::StateNormal)\n                {\n                    DBG_Printf(DBG_INFO, \"reanimate group %u for sensor %s\\n\", i->address(), qPrintable(sensor->name()));\n                    i->setState(Group::StateNormal);\n                    updateGroupEtag(&*i);\n                    queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\n                }\n            }\n            else if (i->deviceIsMember(sensor->uniqueId()) || i->deviceIsMember(sensor->id()))\n            {\n                i->removeDeviceMembership(sensor->uniqueId());\n                i->removeDeviceMembership(sensor->id());\n\n                if (!i->item(RAttrUniqueId) || i->item(RAttrUniqueId)->toString().isEmpty())\n                {\n                    continue; // don't remove ordinary groups\n                }\n\n                if (i->address() != 0 && i->state() == Group::StateNormal && !i->hasDeviceMembers())\n                {\n                    DBG_Printf(DBG_INFO, \"delete old group %u of sensor %s\\n\", i->address(), qPrintable(sensor->name()));\n                    i->setState(Group::StateDeleted);\n                    updateGroupEtag(&*i);\n                    queSaveDb(DB_GROUPS | DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n\n                    // for each node which is part of this group send a remove group request (will be unicast)\n                    // note: nodes which are curently switched off will not be removed!\n                    auto j = nodes.begin();\n                    const auto jend = nodes.end();\n\n                    for (; j != jend; ++j)\n                    {\n                        GroupInfo *groupInfo = getGroupInfo(&*j, i->address());\n\n                        if (groupInfo)\n                        {\n                            j->setNeedSaveDatabase(true);\n                            groupInfo->actions &= ~GroupInfo::ActionAddToGroup; // sanity\n                            groupInfo->actions |= GroupInfo::ActionRemoveFromGroup;\n                            groupInfo->state = GroupInfo::StateNotInGroup;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/*! Remove groups which are controlled by device \\p id. */\nvoid DeRestPluginPrivate::deleteGroupsWithDeviceMembership(const QString &id)\n{\n    auto i = groups.begin();\n    const auto end = groups.end();\n    for (; i != end; ++i)\n    {\n        if (i->deviceIsMember(id) && i->state() == Group::StateNormal)\n        {\n            i->removeDeviceMembership(id);\n\n            updateGroupEtag(&*i);\n            queSaveDb(DB_GROUPS | DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n\n            if (i->hasDeviceMembers())\n            {\n                continue;\n            }\n\n            if (!i->item(RAttrUniqueId) || i->item(RAttrUniqueId)->toString().isEmpty())\n            {\n                continue; // don't remove ordinary groups\n            }\n\n            i->setState(Group::StateDeleted);\n\n            // for each node which is part of this group send a remove group request (will be unicast)\n            // note: nodes which are curently switched off will not be removed!\n            auto j = nodes.begin();\n            const auto jend = nodes.end();\n\n            for (; j != jend; ++j)\n            {\n                GroupInfo *groupInfo = getGroupInfo(&*j, i->address());\n\n                if (groupInfo)\n                {\n                    j->setNeedSaveDatabase(true);\n                    groupInfo->actions &= ~GroupInfo::ActionAddToGroup; // sanity\n                    groupInfo->actions |= GroupInfo::ActionRemoveFromGroup;\n                    groupInfo->state = GroupInfo::StateNotInGroup;\n                }\n            }\n        }\n    }\n}\n\n/*! Process binding related tasks queue every one second. */\nvoid DeRestPluginPrivate::bindingTimerFired()\n{\n    if (bindingQueue.empty())\n    {\n        return;\n    }\n\n    Q_Q(DeRestPlugin);\n    if (!q->pluginActive())\n    {\n        bindingQueue.clear();\n        return;\n    }\n\n    int active = 0;\n    std::list<BindingTask>::iterator i = bindingQueue.begin();\n    std::list<BindingTask>::iterator end = bindingQueue.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->state == BindingTask::StateIdle)\n        {\n            if (active >= MAX_ACTIVE_BINDING_TASKS)\n            { /* do nothing */ }\n            else if (sendBindRequest(*i))\n            {\n                i->state = BindingTask::StateInProgress;\n                break;\n            }\n            else if (i->retries < 5)\n            {\n                i->retries++;\n            }\n            else\n            {\n                // too harsh?\n                DBG_Printf(DBG_INFO_L2, \"failed to send bind/unbind request to 0x%016llX cluster 0x%04X. drop\\n\", i->binding.srcAddress, i->binding.clusterId);\n                i->state = BindingTask::StateFinished;\n            }\n        }\n        else if (i->state == BindingTask::StateInProgress)\n        {\n            i->timeout--;\n            if (i->timeout < 0)\n            {\n                i->retries--;\n                if (i->retries > 0)\n                {\n                    if (i->restNode && !i->restNode->isAvailable())\n                    {\n                        DBG_Printf(DBG_INFO_L2, \"giveup binding srcAddr: 0x%016llX (not available)\\n\", i->binding.srcAddress);\n                        i->state = BindingTask::StateFinished;\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO_L2, \"binding/unbinding timeout srcAddr: 0x%016llX, retry\\n\", i->binding.srcAddress);\n                        i->state = BindingTask::StateIdle;\n                        i->timeout = BindingTask::Timeout;\n                        if (i->restNode && i->restNode->node() && !i->restNode->node()->nodeDescriptor().receiverOnWhenIdle())\n                        {\n                            i->timeout = BindingTask::TimeoutEndDevice;\n                        }\n                    }\n                }\n                else\n                {\n                    DBG_Printf(DBG_INFO_L2, \"giveup binding srcAddr: 0x%016llX\\n\", i->binding.srcAddress);\n                    i->state = BindingTask::StateFinished;\n                }\n            }\n            else\n            {\n                active++;\n            }\n        }\n        else if (i->state == BindingTask::StateFinished)\n        {\n            bindingQueue.erase(i);\n            break;\n        }\n        else if (i->state == BindingTask::StateCheck)\n        {\n            i->timeout--;\n            if (i->timeout < 0)\n            {\n                i->retries--;\n                if (i->retries > 0 && i->restNode)\n                {\n                    if (i->restNode->mgmtBindSupported())\n                    {\n                        if (!i->restNode->mustRead(READ_BINDING_TABLE))\n                        {\n                            i->restNode->enableRead(READ_BINDING_TABLE);\n                            i->restNode->setNextReadTime(READ_BINDING_TABLE, queryTime);\n                            queryTime = queryTime.addSecs(5);\n                        }\n                        q->startZclAttributeTimer(1000);\n\n                        i->state = BindingTask::StateCheck;\n                    }\n                    else\n                    {\n                        i->state = BindingTask::StateIdle;\n                    }\n                    i->timeout = BindingTask::Timeout;\n                    if (i->restNode && i->restNode->node() && !i->restNode->node()->nodeDescriptor().receiverOnWhenIdle())\n                    {\n                        i->timeout = BindingTask::TimeoutEndDevice;\n                    }\n\n                    DBG_Printf(DBG_INFO_L2, \"%s check timeout, retries = %d (srcAddr: 0x%016llX cluster: 0x%04X)\\n\",\n                               (i->action == BindingTask::ActionBind ? \"bind\" : \"unbind\"), i->retries, i->binding.srcAddress, i->binding.clusterId);\n\n                    bindingQueue.push_back(*i);\n                    bindingQueue.pop_front();\n                    break;\n                }\n                else\n                {\n                    DBG_Printf(DBG_INFO_L2, \"giveup binding\\n\");\n                    DBG_Printf(DBG_INFO_L2, \"giveup %s (srcAddr: 0x%016llX cluster: 0x%04X)\\n\",\n                               (i->action == BindingTask::ActionBind ? \"bind\" : \"unbind\"), i->binding.srcAddress, i->binding.clusterId);\n                    i->state = BindingTask::StateFinished;\n                }\n            }\n        }\n    }\n\n    if (!bindingQueue.empty())\n    {\n        bindingTimer->start(1000);\n    }\n}\n\n/*! Process ongoing binding table queries.\n*/\nvoid DeRestPluginPrivate::bindingTableReaderTimerFired()\n{\n    std::vector<BindingTableReader>::iterator i = bindingTableReaders.begin();\n\n    for (; i != bindingTableReaders.end(); )\n    {\n        if (i->state == BindingTableReader::StateIdle)\n        {\n            deCONZ::ApsDataRequest &apsReq = i->apsReq;\n\n            i->apsReq.setDstAddressMode(deCONZ::ApsExtAddress);\n            i->apsReq.setProfileId(ZDP_PROFILE_ID);\n            i->apsReq.setClusterId(ZDP_MGMT_BIND_REQ_CLID);\n            i->apsReq.setDstEndpoint(ZDO_ENDPOINT);\n            i->apsReq.setSrcEndpoint(ZDO_ENDPOINT);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n            i->apsReq.setTxOptions(0);\n#endif\n            i->apsReq.setRadius(0);\n\n            QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n            stream.setByteOrder(QDataStream::LittleEndian);\n\n            QTime now = QTime::currentTime();\n            stream << (uint8_t)now.second(); // seqno\n            stream << i->index;\n\n            // send\n            if (apsCtrlWrapper.apsdeDataRequest(apsReq) == deCONZ::Success)\n            {\n                DBG_Printf(DBG_ZDP, \"Mgmt_Bind_req id: %d to 0x%016llX send\\n\", i->apsReq.id(), i->apsReq.dstAddress().ext());\n                i->time.start();\n                i->state = BindingTableReader::StateWaitConfirm;\n                break;\n            }\n            else\n            {\n                DBG_Printf(DBG_ZDP, \"failed to send Mgmt_Bind_req to 0x%016llX\\n\", i->apsReq.dstAddress().ext());\n                i->state = BindingTableReader::StateFinished;\n            }\n        }\n        else if (i->state == BindingTableReader::StateWaitConfirm)\n        {\n            if (i->time.elapsed() > BindingTableReader::MaxConfirmTime)\n            {\n                DBG_Printf(DBG_ZDP, \"timeout for Mgmt_Bind_req id %d to 0x%016llX\\n\", i->apsReq.id(), i->apsReq.dstAddress().ext());\n                i->state = BindingTableReader::StateFinished;\n            }\n        }\n        else if (i->state == BindingTableReader::StateWaitResponse)\n        {\n            const int maxResponseTime = i->isEndDevice ? BindingTableReader::MaxEndDeviceResponseTime\n                                                 : BindingTableReader::MaxResponseTime;\n            if (i->time.elapsed() > maxResponseTime)\n            {\n                DBG_Printf(DBG_ZDP, \"timeout for response to Mgmt_Bind_req id %d to 0x%016llX\\n\", i->apsReq.id(), i->apsReq.dstAddress().ext());\n                i->state = BindingTableReader::StateFinished;\n            }\n        }\n\n        if (i->state == BindingTableReader::StateFinished)\n        {\n            *i = bindingTableReaders.back();\n            bindingTableReaders.pop_back();\n        }\n        else\n        {\n            ++i;\n        }\n    }\n\n    if (!bindingTableReaders.empty())\n    {\n        bindingTableReaderTimer->start();\n    }\n}\n\n/*! Add a binding task to the queue and prevent double entries.\n    \\param bindingTask - the binding task\n    \\return true - when enqueued\n */\nbool DeRestPluginPrivate::queueBindingTask(const BindingTask &bindingTask)\n{\n    if (!apsCtrl || apsCtrl->networkState() != deCONZ::InNetwork)\n    {\n        return false;\n    }\n\n    const std::list<BindingTask>::const_iterator i = std::find(bindingQueue.begin(), bindingQueue.end(), bindingTask);\n\n    if (i == bindingQueue.end())\n    {\n        DBG_Printf(DBG_INFO_L2, \"queue binding task for 0x%016llX, cluster 0x%04X\\n\", bindingTask.binding.srcAddress, bindingTask.binding.clusterId);\n\n        Device *device = DEV_GetDevice(m_devices, bindingTask.binding.srcAddress);\n\n        if (device && !device->managed())\n        {\n            DDF_Binding ddfBinding;\n\n            ddfBinding.isUnicastBinding = bindingTask.binding.dstAddrMode == deCONZ::ApsExtAddress;\n            ddfBinding.isGroupBinding = bindingTask.binding.dstAddrMode == deCONZ::ApsGroupAddress;\n            if (ddfBinding.isUnicastBinding)\n            {\n                ddfBinding.dstExtAddress = bindingTask.binding.dstAddress.ext;\n            }\n            else if (ddfBinding.isGroupBinding)\n            {\n                ddfBinding.dstGroup = bindingTask.binding.dstAddress.group;\n            }\n\n            ddfBinding.clusterId = bindingTask.binding.clusterId;\n            ddfBinding.dstEndpoint =  bindingTask.binding.dstEndpoint;\n            ddfBinding.srcEndpoint = bindingTask.binding.srcEndpoint;\n\n            device->addBinding(ddfBinding);\n\n            auto ddf = deviceDescriptions->get(device);\n            if (ddf.status == QLatin1String(\"Draft\"))\n            {\n                if (ddf.bindings != device->bindings())\n                {\n                    ddf.bindings = device->bindings();\n                    deviceDescriptions->put(ddf);\n                }\n            }\n\n            if (bindingTask.state == BindingTask::StateFinished) // dummy\n            {\n                bindingQueue.push_back(bindingTask);\n                sendConfigureReportingRequest(bindingQueue.back());\n                return false;\n            }\n        }\n\n        bindingQueue.push_back(bindingTask);\n    }\n    else\n    {\n        DBG_Printf(DBG_INFO, \"discard double entry in binding queue (size: %u) for for 0x%016llX, cluster 0x%04X\\n\", bindingQueue.size(), bindingTask.binding.srcAddress, bindingTask.binding.clusterId);\n    }\n\n    return true;\n}\n"
        },
        {
          "name": "bindings.h",
          "type": "blob",
          "size": 3.0234375,
          "content": "/*\n * Copyright (c) 2016-2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef BINDINGS_H\n#define BINDINGS_H\n\n#include <QElapsedTimer>\n#include <deconz.h>\n\n/*! \\class Binding\n\n    Represents a ZigBee ZDO Binding.\n */\nclass Binding\n{\npublic:\n    enum Constans\n    {\n        GroupAddressMode = 0x01,\n        ExtendedAddressMode = 0x03\n    };\n\n    Binding();\n    bool operator==(const Binding &rhs) const;\n    bool operator!=(const Binding &rhs) const;\n    /*! The source IEEE address. */\n    quint64 srcAddress;\n    /*! The source endpoint. */\n    quint8 srcEndpoint;\n    /*! The cluster on the source device that is bound to the destination device. */\n    quint16 clusterId;\n    /*! The addressing mode for the destination address.\n        0x01 = 16-bit group address (no endpoint)\n        0x03 = 64-bit extended address + endpoint\n     */\n    quint8 dstAddrMode;\n    union\n    {\n        quint16 group; //!< The destination group address (if dstAddrMode = 0x01).\n        quint64 ext; //!< The destination extended address (if dstAddrMode = 0x03).\n    } dstAddress;\n    /*! Destination endpoint (if dstAddrMode = 0x03). */\n    quint8 dstEndpoint;\n\n    bool readFromStream(QDataStream &stream);\n    bool writeToStream(QDataStream &stream) const;\n};\n\n/*! \\class BindingTableReader\n\n    Helper class to query full binding table of a node.\n */\nclass BindingTableReader\n{\npublic:\n    enum Constants\n    {\n        MaxConfirmTime = 10 * 60 * 1000, // 10 min\n        MaxResponseTime = 10 * 1000, // 10 sec\n        MaxEndDeviceResponseTime = 60 * 60 * 1000 // 60 min\n    };\n\n    BindingTableReader() :\n        state(StateIdle),\n        index(0),\n        isEndDevice(false)\n    {\n    }\n\n    enum State {\n        StateIdle,\n        StateWaitConfirm,\n        StateWaitResponse,\n        StateFinished\n    };\n    State state; //!< State of query\n    quint8 index; //!< Current read index\n    bool isEndDevice; //!< True if node is an end-device\n    QElapsedTimer time; //!< State timeout reference\n    deCONZ::ApsDataRequest apsReq; //!< The APS request to match APS confirm.id\n};\n\nclass ConfigureReportingRequest\n{\npublic:\n    ConfigureReportingRequest() :\n        direction(0x00),\n        reportableChange8bit(0xFF),\n        reportableChange16bit(0xFFFF),\n        reportableChange24bit(0xFFFFFF),\n        reportableChange48bit(0xFFFFFFFF),  // there's no quint48\n        manufacturerCode(0)\n    {\n    }\n\n    quint8 zclSeqNum;\n    quint8 direction;\n    quint8 dataType;\n    quint16 attributeId;\n    quint16 minInterval;\n    quint16 maxInterval;\n    quint8 reportableChange8bit;\n    quint16 reportableChange16bit;\n    quint32 reportableChange24bit;          // there's no quint24\n    quint32 reportableChange48bit;          // there's no quint48\n    quint16 manufacturerCode;\n};\n\n#if DECONZ_LIB_VERSION >= 0x010F00\ndeCONZ::Binding convertToCoreBinding(const Binding &bnd);\n#endif\n\n#endif // BINDINGS_H\n"
        },
        {
          "name": "build-macos.sh",
          "type": "blob",
          "size": 0.90234375,
          "content": "#!/usr/bin/env sh\n\n# Helper script to build libde_rest_plugin.dylib\n# that can be copied into deCONZ.app/Contents/Plugins.\n\nMACHINE=$(uname -m)\nQTLOC=/usr/local/opt/qt@5\n\nif [[ \"$MACHINE\" != \"x86_64\" ]]; then\n\techo \"building currently only supported on x86_64\"\n\texit 1\nfi\n\nif [ ! -d \"$QTLOC\" ]; then\n\techo \"Homebrew (x86_64) or Qt5 not installed in $QTLOC\"\n\texit 1\nfi\n\nrm -fr build\n\ncmake -Wno-dev -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$QTLOC -G Ninja -B build .\ncmake --build build\n\npushd build\n\nfor i in `otool -L libde_rest_plugin.dylib | grep /opt/qt | cut -f1 -d' '`\ndo\n\t# fixup framework paths\n\t# /usr/local/opt/qt@5/lib/         QtWidgets.framework/Versions/5/QtWidgets\n    # @executable_path/../Frameworks/  QtWidgets.framework/Versions/5/QtWidgets\n\tnewpath=`echo $i | awk '{gsub(/.*qt.*\\/lib/,\"@executable_path/../Frameworks\");}1'`\n\tinstall_name_tool -change $i $newpath libde_rest_plugin.dylib\ndone\n\npopd\n"
        },
        {
          "name": "button_maps.cpp",
          "type": "blob",
          "size": 1.7109375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"button_maps.h\"\n\nButtonMapRef BM_ButtonMapRefForHash(uint32_t buttonMapNameHash, const std::vector<ButtonMap> &buttonMaps)\n{\n    const auto bm = std::find_if(buttonMaps.cbegin(), buttonMaps.cend(),\n                                 [buttonMapNameHash](const auto &bm) { return bm.buttonMapRef.hash == buttonMapNameHash; });\n    if (bm != buttonMaps.cend())\n    {\n        return bm->buttonMapRef;\n    }\n\n    return {};\n}\n\nconst ButtonMap *BM_ButtonMapForRef(ButtonMapRef ref, const std::vector<ButtonMap> &buttonMaps)\n{\n    if (isValid(ref) && ref.index < buttonMaps.size())\n    {\n        const ButtonMap &bm = buttonMaps[ref.index];\n        if (bm.buttonMapRef.hash == ref.hash)\n        {\n            return &bm;\n        }\n    }\n\n    return nullptr;\n}\n\nconst ButtonMap *BM_ButtonMapForProduct(ProductIdHash productHash, const std::vector<ButtonMap> &buttonMaps,\n                                                    const std::vector<ButtonProduct> &buttonProductMap)\n{\n    ButtonMapRef buttonMapHash{};\n    {\n        const auto mapping = std::find_if(buttonProductMap.cbegin(), buttonProductMap.cend(),\n                                      [productHash](const auto &i) { return i.productHash == productHash; });\n\n        if (mapping != buttonProductMap.cend())\n        {\n            buttonMapHash = mapping->buttonMapRef;\n        }\n    }\n\n    if (isValid(buttonMapHash))\n    {\n        return BM_ButtonMapForRef(buttonMapHash, buttonMaps);\n    }\n\n    return nullptr;\n}\n"
        },
        {
          "name": "button_maps.h",
          "type": "blob",
          "size": 2.0087890625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef BUTTON_MAPS_H\n#define BUTTON_MAPS_H\n\n#include <QString>\n#include <vector>\n\nusing ProductIdHash = std::size_t;\n\n/*! Reference to a button map for quick lookup and leightweight embedding. */\nstruct ButtonMapRef\n{\n    uint32_t hash = 0; //! hash of button map name\n    uint32_t index = UINT32_MAX; //! index into ButtonMap vector\n};\n\n/*! Meta data about buttons, not used by the plugin but exposed via REST API. */\nstruct ButtonMeta\n{\n    struct Button\n    {\n        QString name;\n        int button;\n    };\n\n    std::vector<ButtonMeta::Button> buttons;\n    ButtonMapRef buttonMapRef{};\n};\n\n/*! Mapping between a product and a buttom map.\n */\nstruct ButtonProduct\n{\n    ButtonMapRef buttonMapRef{};\n    ProductIdHash productHash = 0; //! hash of modelid or manufacturer name generated by \\c productHash(Resource*)\n};\n\nstruct ButtonMap\n{\n    struct Item\n    {\n        quint8 mode;\n        quint8 endpoint;\n        quint16 clusterId;\n        quint8 zclCommandId;\n        quint16 zclParam0;\n        int button;\n        QString name;\n    };\n    std::vector<ButtonMap::Item> buttons;\n    ButtonMapRef buttonMapRef{};\n};\n\nButtonMapRef BM_ButtonMapRefForHash(uint32_t buttonMapNameHash, const std::vector<ButtonMap> &buttonMaps);\nconst ButtonMap *BM_ButtonMapForRef(ButtonMapRef ref, const std::vector<ButtonMap> &buttonMaps);\nconst ButtonMap *BM_ButtonMapForProduct(ProductIdHash productHash, const std::vector<ButtonMap> &buttonMaps, const std::vector<ButtonProduct> &buttonProductMap);\n\ninline bool isValid(ButtonMapRef a) { return a.hash != 0 && a.index != UINT32_MAX; }\ninline bool operator==(ButtonMapRef a, ButtonMapRef b) { return a.hash == b.hash && a.index == b.index; }\ninline bool operator!=(ButtonMapRef a, ButtonMapRef b) { return !(a == b); }\n\n#endif // BUTTON_MAPS_H\n"
        },
        {
          "name": "button_maps.json",
          "type": "blob",
          "size": 139.3427734375,
          "content": "{\n\t\"buttons\": {\n        \"S_BUTTON_1\": 1000,\n        \"S_BUTTON_2\": 2000,\n        \"S_BUTTON_3\": 3000,\n        \"S_BUTTON_4\": 4000,\n        \"S_BUTTON_5\": 5000,\n        \"S_BUTTON_6\": 6000,\n        \"S_BUTTON_7\": 7000,\n        \"S_BUTTON_8\": 8000,\n        \"S_BUTTON_9\": 9000,\n        \"S_BUTTON_10\": 10000,\n        \"S_BUTTON_11\": 11000,\n        \"S_BUTTON_12\": 12000,\n        \"S_BUTTON_13\": 13000,\n        \"S_BUTTON_14\": 14000,\n        \"S_BUTTON_15\": 15000,\n        \"S_BUTTON_16\": 16000,\n        \"S_BUTTON_17\": 17000,\n        \"S_BUTTON_18\": 18000,\n        \"S_BUTTON_19\": 19000,\n        \"S_BUTTON_20\": 20000,\n        \"S_BUTTON_21\": 21000,\n        \"S_BUTTON_22\": 22000,\n        \"S_BUTTON_23\": 23000,\n        \"S_BUTTON_24\": 24000,\n        \"S_BUTTON_25\": 25000,\n        \"S_BUTTON_26\": 26000,\n        \"S_BUTTON_27\": 27000\n\t},\n\t\"buttonActions\": {\n        \"S_BUTTON_ACTION_INITIAL_PRESS\": 0,\n        \"S_BUTTON_ACTION_HOLD\": 1,\n        \"S_BUTTON_ACTION_SHORT_RELEASED\": 2,\n        \"S_BUTTON_ACTION_LONG_RELEASED\": 3,\n        \"S_BUTTON_ACTION_DOUBLE_PRESS\": 4,\n        \"S_BUTTON_ACTION_TREBLE_PRESS\": 5,\n        \"S_BUTTON_ACTION_QUADRUPLE_PRESS\": 6,\n        \"S_BUTTON_ACTION_SHAKE\": 7,\n        \"S_BUTTON_ACTION_DROP\": 8,\n        \"S_BUTTON_ACTION_TILT\": 9,\n        \"S_BUTTON_ACTION_MANY_PRESS\": 10,\n        \"S_BUTTON_ACTION_ROTATE_CLOCKWISE\": 30,\n        \"S_BUTTON_ACTION_ROTATE_COUNTER_CLOCKWISE\": 31\n\t},\n\t\"clusters\": {\n        \"BASIC\": 0,\n        \"SCENES\": 5,\n        \"ONOFF\": 6,\n        \"LEVEL_CONTROL\": 8,\n        \"MULTISTATE_INPUT\": 18,\n        \"DOOR_LOCK\": 257,\n        \"WINDOW_COVERING\": 258,\n        \"COLOR_CONTROL\": 768,\n        \"IAS_ZONE\": 1280,\n        \"IAS_ACE\": 1281,\n        \"SENGLED\": 64528,\n        \"FC80\": 64640,\n        \"XIAOMI\": 64704,\n        \"ADUROLIGHT\": 64716,\n        \"XIAOYAN\": 64716\n\t},\n\t\"commands\": {\n        \"DOOR_LOCK\": {\n            \"ATTRIBUTE_REPORT\": 10\n        },\n        \"SCENES\": {\n            \"ADD_SCENE\": 0,\n            \"VIEW_SCENE\": 1,\n            \"REMOVE_SCENE\": 2,\n            \"STORE_SCENE\": 4,\n            \"RECALL_SCENE\": 5,\n            \"IKEA_STEP_CT\": 7,\n            \"IKEA_MOVE_CT\": 8,\n            \"IKEA_STOP_CT\": 9\n        },\n        \"ONOFF\": {\n            \"ATTRIBUTE_REPORT\": 10,\n            \"OFF\": 0,\n            \"ON\": 1,\n            \"TOGGLE\": 2,\n            \"OFF_WITH_EFFECT\": 64,\n            \"ON_WITH_TIMED_OFF\": 66,\n            \"LIDL\": 253\n        },\n        \"LEVEL_CONTROL\": {\n            \"MOVE_TO_LEVEL\": 0,\n            \"MOVE\": 1,\n            \"STEP\": 2,\n            \"STOP\": 3,\n            \"MOVE_TO_LEVEL_WITH_ON_OFF\": 4,\n            \"MOVE_WITH_ON_OFF\": 5,\n            \"STEP_WITH_ON_OFF\": 6,\n            \"STOP_WITH_ON_OFF\": 7\n        },\n        \"WINDOW_COVERING\": {\n            \"OPEN\": 0,\n            \"CLOSE\": 1,\n            \"STOP\": 2,\n            \"GOTO_LIFT_PCT\": 5,\n            \"GOTO_TILT_PCT\": 8\n        },\n        \"COLOR_CONTROL\": {\n            \"MOVE_HUE\": 1,\n            \"STEP_HUE\": 2,\n            \"MOVE_TO_SATURATION\": 3,\n            \"MOVE_TO_COLOR\": 7,\n            \"MOVE_TO_COLOR_TEMPERATURE\": 10,\n            \"STOP_MOVE_STEP\": 71,\n            \"MOVE_COLOR_TEMPERATURE\": 75,\n            \"STEP_COLOR_TEMPERATURE\": 76\n        },\n        \"IAS_ACE\": {\n            \"ARM\": 0,\n            \"EMERGENCY\": 2,\n            \"FIRE\": 3,\n            \"SOS\": 4,\n            \"STATUS_CHANGE\": 0\n        },\n        \"IAS_ZONE\": {\n            \"STATUS_CHANGE\": 0\n        },\n        \"MULTISTATE_INPUT\": {\n            \"ATTRIBUTE_REPORT\": 10\n        },\n        \"SENGLED\": {\n            \"COMMAND_0\": 0\n        },\n        \"FC80\": {\n            \"COMMAND_1\": 1,\n            \"COMMAND_2\": 2,\n            \"COMMAND_3\": 3,\n            \"COMMAND_4\": 4,\n            \"COMMAND_6\": 6\n        },\n        \"XIAOMI\": {\n            \"ATTRIBUTE_REPORT\": 10\n        },\n        \"ADUROLIGHT\": {\n            \"COMMAND_0\": 0\n        },\n        \"XIAOYAN\": {\n            \"COMMAND_0\": 0,\n            \"ATTRIBUTE_REPORT\": 10,\n            \"COMMAND_20\": 20\n        }\n\t},\n\t\"maps\": {\n        \"deKoboldMap\": {\n            \"vendor\": \"dresden elektronik\",\n            \"modelids\": [\"Kobold\"],\n            \"doc\": \"Kobold\",\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button 1\"}\n            ],\n            \"map\": [\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm stop\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm stop\"],\n                [2, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [2, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [2, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm stop\"],\n                [2, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm stop\"]\n            ]\n        },\n        \"instaRemoteMap\": {\n            \"vendor\": \"GIRA / JUNG\",\n            \"doc\":\"Switches and remotes\",\n            \"modelids\": [\"HS_4f_GJ_1\", \"WS_4f_J_1\", \"WS_3f_G_1\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF_WITH_EFFECT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off with effect\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 0\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"2\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 2\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"3\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 3\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"4\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 4\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"5\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 5\"]\n            ]\n        },\n        \"ikeaOnOffMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI on/off switch\",\n            \"modelids\": [\"TRADFRI on/off switch\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"On\"},\n                {\"S_BUTTON_2\": \"Off\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"ikeaShortcutMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI shortcut button\",\n            \"modelids\": [\"TRADFRI SHORTCUT Button\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Off\"]\n            ]\n        },\n        \"ikeaOpenCloseMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI open/close remote\",\n            \"modelids\": [\"TRADFRI open/close remote\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Open\"},\n                {\"S_BUTTON_2\": \"Close\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"WINDOW_COVERING\", \"OPEN\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Open\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"CLOSE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Close\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"ikeaRodretMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"Rodret dimmer remote\",\n            \"modelids\": [\"RODRET Dimmer\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Dim Up\"},\n                {\"S_BUTTON_2\": \"Dim Down\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"ikeaRemoteMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI round 5 button remote\",\n            \"modelids\": [\"TRADFRI remote control\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"On/Off\"},\n                {\"S_BUTTON_2\": \"Dim Up\"},\n                {\"S_BUTTON_3\": \"Dim Down\"},\n                {\"S_BUTTON_4\": \"Previous Scene\"},\n                {\"S_BUTTON_5\": \"Next Scene\"}\n            ],\n            \"map\": [\n                [3, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_STEP_CT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Setup 10s\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [3, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_STEP_CT\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step ct colder\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_MOVE_CT\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move ct colder\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_STOP_CT\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop ct colder\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_STEP_CT\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step ct warmer\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_MOVE_CT\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Move ct warmer\"],\n                [3, \"0x01\", \"SCENES\", \"IKEA_STOP_CT\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop ct warmer\"]\n            ]\n        },\n        \"ikeaStyrbarMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"STYRBAR remote\",\n            \"modelids\": [\"Remote Control N2\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Dim Up\"},\n                {\"S_BUTTON_2\": \"Dim Down\"},\n                {\"S_BUTTON_3\": \"Previous Scene\"},\n                {\"S_BUTTON_4\": \"Next Scene\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_STEP_CT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step ct colder\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_MOVE_CT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move ct colder\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_STOP_CT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop ct colder\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_STEP_CT\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step ct warmer\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_MOVE_CT\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move ct warmer\"],\n                [1, \"0x01\", \"SCENES\", \"IKEA_STOP_CT\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop ct warmer\"]\n            ]\n        },\n        \"ikeaSymfoniskGen2Map\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"SYMFONISK sound remote gen2\",\n            \"modelids\": [\"SYMFONISK sound remote gen2\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Play\"},\n                {\"S_BUTTON_2\": \"Plus\"},\n                {\"S_BUTTON_3\": \"Minus\"},\n                {\"S_BUTTON_4\": \"Previous\"},\n                {\"S_BUTTON_5\": \"Next\"},\n                {\"S_BUTTON_6\": \"One Dot\"},\n                {\"S_BUTTON_7\": \"Two Dots\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_1\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_INITIAL_PRESS\", \"0x01\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_2\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"0x02\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_3\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"0x03\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_4\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"0x04\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_6\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"0x06\"],\n                [1, \"0x03\", \"FC80\", \"COMMAND_1\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_INITIAL_PRESS\", \"0x01\"],\n                [1, \"0x03\", \"FC80\", \"COMMAND_2\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_HOLD\", \"0x02\"],\n                [1, \"0x03\", \"FC80\", \"COMMAND_3\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"0x03\"],\n                [1, \"0x03\", \"FC80\", \"COMMAND_4\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"0x04\"],\n                [1, \"0x03\", \"FC80\", \"COMMAND_6\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"0x06\"]\n            ]\n        },\n\t\"ikeaSomrigMap\": {\n            \"vendor\": \"IKEA of Sweden\",\n            \"doc\": \"IKEA SOMRIG Shortcut Button\",\n            \"modelids\": [\"SOMRIG shortcut button\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"One Dot\"},\n                {\"S_BUTTON_2\": \"Two Dots\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"FC80\", \"COMMAND_1\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_INITIAL_PRESS\", \"0x01\"],\n                [1, \"0x01\", \"FC80\", \"COMMAND_2\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"0x02\"],\n                [1, \"0x01\", \"FC80\", \"COMMAND_3\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"0x03\"],\n                [1, \"0x01\", \"FC80\", \"COMMAND_4\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"0x04\"],\n                [1, \"0x01\", \"FC80\", \"COMMAND_6\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"0x06\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_1\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_INITIAL_PRESS\", \"0x01\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_2\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"0x02\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_3\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"0x03\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_4\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"0x04\"],\n                [1, \"0x02\", \"FC80\", \"COMMAND_6\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"0x06\"]\n            ]\n        },\n        \"osramMiniRemoteMap\": {\n            \"vendor\": \"OSRAM\",\n            \"doc\": \"Lightify Switch Mini\",\n            \"modelids\": [\"Lightify Switch Mini\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Up\"},\n                {\"S_BUTTON_2\": \"Down\"},\n                {\"S_BUTTON_3\": \"Middle\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Up short press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Up long press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Up long release\"],\n                [1, \"0x03\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0x72\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"0 short press\"],\n                [1, \"0x03\", \"COLOR_CONTROL\", \"MOVE_TO_SATURATION\", \"0xFE\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"0 long press\"],\n                [1, \"0x03\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0x00\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"0 long release\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0x00\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Down short press\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Down long press\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Down long release\"]\n            ]\n        },\n        \"osram4ButRemoteMap\": {\n            \"vendor\": \"OSRAM\",\n            \"doc\": \"Lightify 4 button remote (1)\",\n            \"modelids\": [\"Switch 4x EU-LIGHTIFY\", \"Switch 4x-LIGHTIFY\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Top Left\"},\n                {\"S_BUTTON_2\": \"Top Right\"},\n                {\"S_BUTTON_3\": \"Bottom Left\"},\n                {\"S_BUTTON_4\": \"Bottom Right\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"UL short press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"UL long press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"UL long release\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"UR short press\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"MOVE_TO_SATURATION\", \"0xFE\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"UR long press\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0x00\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"UR long release\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0x00\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"LL short press\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"LL long press\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"LL long release\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"0x03\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"LR short press\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"MOVE_TO_SATURATION\", \"0xFE\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"LR long press\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0x00\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"LR long release\"]\n            ]\n        },\n        \"osram4ButRemoteMap2\": {\n            \"vendor\": \"OSRAM\",\n            \"doc\": \"Lightify 4 button remote (2)\",\n            \"modelids\": [\"Switch-LIGHTIFY\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Top Left\"},\n                {\"S_BUTTON_2\": \"Top Right\"},\n                {\"S_BUTTON_3\": \"Bottom Left\"},\n                {\"S_BUTTON_4\": \"Bottom Right\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"UL short press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"UL long press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"UL long release\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"UR short press\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"UR long press\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"STOP_MOVE_STEP\", \"0x00\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"UR long release\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0x00\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"LL short press\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"LL long press\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"LL long release\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"0x03\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"LR short press\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0x03\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"LR long press\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"STOP_MOVE_STEP\", \"0x00\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"LR long release\"]\n            ]\n        },\n        \"ikeaDimmerMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI dimmer\",\n            \"modelids\": [\"TRADFRI wireless dimmer\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Rotate Full Brightness\"},\n                {\"S_BUTTON_2\": \"Rotate Clockwise\"},\n                {\"S_BUTTON_3\": \"Rotate Counter Clockwise\"},\n                {\"S_BUTTON_4\": \"Rotate Off\"}\n            ],\n            \"map\": [\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0xFF\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to level 255 (with on/off)\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move up (with on/off)\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"0\", \"0\", \"Stop_ up (with on/off)\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move down\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"0\", \"0\", \"Stop_ down (with on/off)\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to level 0 (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0xFF\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to level 255 (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to level 0 (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ down (with on/off)\"]\n            ]\n        },\n        \"ikeaMotionSensorMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"TRÅDFRI motion sensor\",\n            \"modelids\": [\"TRADFRI motion sensor\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Motion\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON_WITH_TIMED_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On with timed off\"]\n            ]\n        },\n        \"ikeaSoundControllerMap\": {\n            \"vendor\": \"IKEA\",\n            \"doc\": \"SYMFONISK remote\",\n            \"modelids\": [\"SYMFONISK Sound Controller\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button\"},\n                {\"S_BUTTON_2\": \"Rotate Clockwise\"},\n                {\"S_BUTTON_3\": \"Rotate Counter Clockwise\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Step Up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Step Down\"],\n                [4, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Step Up\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Step Down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move Up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move Up\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"0\", \"0\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move Down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move Down\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"0\", \"0\", \"Stop\"]\n            ]\n        },\n        \"bjeSwitchMap\": {\n            \"vendor\": \"Busch-Jaeger\",\n            \"doc\": \"Switches\",\n            \"modelids\": [\"RB01\", \"RM01\"],\n            \"map\": [\n                [1, \"0x0A\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x0A\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [1, \"0x0A\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0A\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x0A\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [1, \"0x0A\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0B\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x0B\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [1, \"0x0B\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0B\", \"SCENES\", \"RECALL_SCENE\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 3\"],\n                [1, \"0x0B\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x0B\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [1, \"0x0B\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0B\", \"SCENES\", \"RECALL_SCENE\", \"4\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 4\"],\n                [1, \"0x0C\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x0C\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [1, \"0x0C\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0C\", \"SCENES\", \"RECALL_SCENE\", \"5\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 5\"],\n                [1, \"0x0C\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x0C\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [1, \"0x0C\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0C\", \"SCENES\", \"RECALL_SCENE\", \"6\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 6\"],\n                [1, \"0x0D\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x0D\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [1, \"0x0D\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0D\", \"SCENES\", \"RECALL_SCENE\", \"7\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 7\"],\n                [1, \"0x0D\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x0D\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [1, \"0x0D\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x0D\", \"SCENES\", \"RECALL_SCENE\", \"8\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 8\"],\n                [4, \"0x0A\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [4, \"0x0A\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [4, \"0x0A\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0A\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [4, \"0x0A\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [4, \"0x0A\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0B\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [4, \"0x0B\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [4, \"0x0B\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0B\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [4, \"0x0B\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [4, \"0x0B\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0C\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [4, \"0x0C\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [4, \"0x0C\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0C\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [4, \"0x0C\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [4, \"0x0C\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0D\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [4, \"0x0D\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_HOLD\", \"Step down\"],\n                [4, \"0x0D\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [4, \"0x0D\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [4, \"0x0D\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_HOLD\", \"Step up (with on/off)\"],\n                [4, \"0x0D\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"trustZYCT202SwitchMap\": {\n            \"vendor\": \"Trust\",\n            \"doc\": \"ZYCT-202 remote\",\n            \"modelids\": [\"ZYCT-202\", \"ZLL-NonColorController\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF_WITH_EFFECT\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n        },\n        \"wiserFugaDoubleRelayMap\": {\n            \"vendor\": \"Schneider Electric\",\n            \"doc\": \"Wiser LK FUGA double relay switch\",\n            \"modelids\": [\"LK Switch\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Top left\"},\n                {\"S_BUTTON_2\": \"Top right\"},\n                {\"S_BUTTON_3\": \"Bottom left\"},\n                {\"S_BUTTON_4\": \"Bottom right\"}\n            ],\n            \"map\": [\n                [2, \"0x15\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x16\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x17\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x18\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n        },\n        \"wiserFugaDimmerMap\": {\n            \"vendor\": \"Schneider Electric\",\n            \"doc\": \"Wiser LK FUGA dimmer switch\",\n            \"modelids\": [\"LK Dimmer\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Top left\"},\n                {\"S_BUTTON_2\": \"Top right\"},\n                {\"S_BUTTON_3\": \"Bottom left\"},\n                {\"S_BUTTON_4\": \"Bottom right\"}\n            ],\n            \"map\": [\n                [2, \"0x15\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x16\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dim up\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dim down\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x17\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 1\"],\n                [2, \"0x18\", \"SCENES\", \"RECALL_SCENE\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 2\"]\n            ]\n        },\n        \"wiserFugaBatteryMap\": {\n            \"vendor\": \"Schneider Electric\",\n            \"doc\": \"Wiser LK FUGA battery 4 button switch\",\n            \"modelids\": [\"FLS/AIRLINK/4\", \"FLS/SYSTEM-M/4\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Top left\"},\n                {\"S_BUTTON_2\": \"Top right\"},\n                {\"S_BUTTON_3\": \"Bottom left\"},\n                {\"S_BUTTON_4\": \"Bottom right\"}\n            ],\n            \"map\": [\n                [2, \"0x15\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x15\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x16\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x16\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dim up\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dim down\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dim up\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dim down\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"wiserDimmerMap\": {\n            \"vendor\": \"Schneider Electric\",\n            \"doc\": \"Wiser Merten switch and dimmer\",\n            \"modelids\": [\"1GANG/DIMMER/1\", \"1GANG/SWITCH/1\", \"2GANG/DIMMER/2\"],\n            \"map\": [\n                [2, \"0x15\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x15\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x16\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [2, \"0x16\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dim up\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dim down\"],\n                [2, \"0x15\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dim up\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dim down\"],\n                [2, \"0x16\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"AdeoKeyfobMap\": {\n            \"vendor\": \"Adeo\",\n            \"doc\": \"4 buttons remotes from Adeo\",\n            \"modelids\": [\"LDSENK09\"],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm all zones\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm day/home zones only\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Disarm\"],\n                [1, \"0x01\", \"IAS_ACE\", \"SOS\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Sos\"]\n            ]\n        },\n        \"xiaomiSwitchCtrlNeutralMap\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"QBKG03LM (dual rocker) and QBKG04LM (single rocker) switch\",\n            \"modelids\": [\"lumi.ctrl_neutral1\", \"lumi.ctrl_neutral2\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Left\"},\n                {\"S_BUTTON_2\": \"Right\"},\n                {\"S_BUTTON_3\": \"Both\"}\n            ],\n            \"map\": [\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"]\n            ]\n        },\n        \"xiaomiSwitchCtrlLn1Aq1Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"QBKG11LM switch\",\n            \"modelids\": [\"lumi.ctrl_ln1.aq1\"],\n            \"map\": [\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"]\n            ]\n        },\n        \"xiaomiSwitchCtrlLn2Aq1Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"QBKG12LM switch\",\n            \"modelids\": [\"lumi.ctrl_ln2.aq1\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Left\"},\n                {\"S_BUTTON_2\": \"Right\"},\n                {\"S_BUTTON_3\": \"Both\"}\n            ],\n            \"map\": [\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"]\n            ]\n        },\n        \"xiaomiSwitchB186acn01Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG03LM 2018 remote\",\n            \"modelids\": [\"lumi.remote.b186acn01\"],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"]\n            ]\n        },\n        \"xiaomiSwitchAcn007Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG20LM mini switch\",\n            \"modelids\": [\"lumi.remote.acn007\"],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"]\n            ]\n        },\n        \"xiaomiSwitchAq3Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG12LM remote\",\n            \"modelids\": [\"lumi.sensor_switch.aq3\"],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"16\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"17\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"18\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHAKE\", \"Shake\"]\n            ]\n        },\n        \"xiaomiSwitchB1acn01Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG11LM 2018 remote and WB-R02D switch\",\n            \"modelids\": [\"lumi.remote.b1acn01\", \"lumi.remote.b1acn02\"],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"]\n            ]\n        },\n        \"xiaomiSwitchB28ac1Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WRS-R02 Aqara wireless remote switch H1 (Double Rocker)\",\n            \"modelids\": [\"lumi.remote.b28ac1\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Left\"},\n                {\"S_BUTTON_2\": \"Right\"},\n                {\"S_BUTTON_3\": \"Both\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"]\n            ]\n        },\n        \"xiaomiSwitchBx1acn02Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Xiaomi Aqara D1 1-gang QBKG21LM and 2-gang QBKG22LM without neutral wire (2020 version)\",\n            \"modelids\": [\"lumi.switch.b1lacn02\", \"lumi.switch.b2lacn02\"],\n            \"map\": [\n                [1, \"0x04\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x04\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x04\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x05\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x05\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x05\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x06\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x06\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x06\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"]\n            ]\n        },\n        \"xiaomiSwitchBxnacn02Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Xiaomi Aqara D1 1-gang QBKG23LM and 2-gang QBKG24LM with neutral wire (2020 version)\",\n            \"modelids\": [\"lumi.switch.b1nacn02\", \"lumi.switch.b2nacn02\"],\n            \"map\": [\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"4\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quadruple press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"4\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quadruple press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"4\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quadruple press\"],\n                [1, \"0x07\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"]\n            ]\n        },\n        \"xiaomiSwitchE1Acn004Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Xiaomi Aqara E1 dual rocker wireless switch WXKG17LM\",\n            \"modelids\": [\"lumi.remote.acn004\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Left\"},\n                {\"S_BUTTON_2\": \"Right\"},\n                {\"S_BUTTON_3\": \"Both\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"255\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long released\"]\n            ]\n        },\n        \"xiaomiSwitchH1Euk0XMap\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Xiaomi Aqara H1 1/2-gang with and without neutral wire WS-EUK01, WS-EUK02, WS-EUK03, WS-EUK04\",\n            \"modelids\": [\"lumi.switch.l1aeu1\", \"lumi.switch.l2aeu1\", \"lumi.switch.n1aeu1\", \"lumi.switch.n2aeu1\"],\n            \"map\": [\n                [1, \"0x29\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x29\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x2A\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x2A\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x33\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x33\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x01\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x02\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x02\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x33\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x33\", \"XIAOMI\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"]\n            ]\n        },\n        \"xiaomiSwitchAq2Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG11LM 2016 remote\",\n            \"modelids\": [\"lumi.sensor_switch.aq2\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Triple press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"4\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quad press\"]\n            ]\n        },\n        \"xiaomiSwitchMap\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"WXKG01LM remote\",\n            \"modelids\": [\"lumi.sensor_switch\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_INITIAL_PRESS\", \"Normal press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Normal release\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long release\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Triple press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"4\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quad press\"],\n                [1, \"0x01\", \"ONOFF\", \"ATTRIBUTE_REPORT\", \"0x80\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_MANY_PRESS\", \"Many press\"]\n            ]\n        },\n        \"xiaomiVibrationMap\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Vibration sensor (not implemented)\",\n            \"modelids\": [\"lumi.vibration\"],\n            \"map\": [\n                [1, \"0x01\", \"DOOR_LOCK\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHAKE\", \"Shake\"],\n                [1, \"0x01\", \"DOOR_LOCK\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TILT\", \"Tilt\"],\n                [1, \"0x01\", \"DOOR_LOCK\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DROP\", \"Drop\"]\n            ]\n        },\n        \"ubisysS1Map\": {\n            \"vendor\": \"Ubisys\",\n            \"doc\": \"Universal power switch S1 (5501)\",\n            \"modelids\": [\"S1 (5501)\"],\n            \"map\": [\n                [1, \"0x02\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"ubisysD1Map\": {\n            \"vendor\": \"Ubisys\",\n            \"doc\": \"Universal dimmer D1 and power switch S1-R\",\n            \"modelids\": [\"D1\", \"S1-R\", \"S1\"],\n            \"map\": [\n                [1, \"0x02\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"ubisysC4Map\": {\n            \"vendor\": \"Ubisys\",\n            \"doc\": \"Control unit C4\",\n            \"modelids\": [\"C4 (5504)\", \"C4\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"ubisysS2Map\": {\n            \"vendor\": \"Ubisys\",\n            \"doc\": \"Power switch S2\",\n            \"modelids\": [\"S2 (5502)\", \"S2\", \"S2-R (5602)\"],\n            \"map\": [\n                [1, \"0x03\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"ubisysJ1Map\": {\n            \"vendor\": \"Ubisys\",\n            \"doc\": \"Cover controller J1 (5502), J1-R (5602)\",\n            \"modelids\": [\"J1 (5502)\", \"J1-R (5602)\"],\n            \"map\": [\n                [1, \"0x02\", \"WINDOW_COVERING\", \"OPEN\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Open\"],\n                [1, \"0x02\", \"WINDOW_COVERING\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x02\", \"WINDOW_COVERING\", \"CLOSE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Close\"],\n                [1, \"0x02\", \"WINDOW_COVERING\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"lutronLZL4BWHLSwitchMap\": {\n            \"vendor\": \"Lutron\",\n            \"doc\": \"LZL4BWHL remote\",\n            \"modelids\": [\"LZL4BWHL01 Remote\"],\n            \"map\": [\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0xfe\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"on\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"dimm up\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x00\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"dimm up release\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"dimm down\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"dimm down release\"],\n                [4, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"off\"]\n            ]\n        },\n        \"lutronAuroraMap\": {\n            \"vendor\": \"Lutron\",\n            \"doc\": \"Z3-1BRL remote\",\n            \"modelids\": [\"Z3-1BRL\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button\"},\n                {\"S_BUTTON_2\": \"Rotate Clockwise\"},\n                {\"S_BUTTON_3\": \"Rotate Counter Clockwise\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x02\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown\"]\n            ]\n        },\n        \"innrRC110Map\": {\n            \"vendor\": \"Innr\",\n            \"doc\": \"RC 110 remote\",\n            \"modelids\": [\"RC 110\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"DimUp\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"DimDown\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x02\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"1\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x34\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"2\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x66\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"3\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0x99\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"4\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0xC2\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"5\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"0xFE\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"6\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 1\"],\n                [1, \"0x03\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_11\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_11\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_11\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 1\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 1\"],\n                [1, \"0x04\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_13\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 2\"],\n                [1, \"0x04\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_13\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_14\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_14\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_14\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 2\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 2\"],\n                [1, \"0x05\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_16\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 3\"],\n                [1, \"0x05\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_16\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_17\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_17\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_17\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_18\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_18\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 3\"],\n                [1, \"0x05\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_18\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 3\"],\n                [1, \"0x06\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_19\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 4\"],\n                [1, \"0x06\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_19\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_20\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_20\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_20\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 4\"],\n                [1, \"0x06\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 4\"],\n                [1, \"0x07\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_22\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 5\"],\n                [1, \"0x07\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_22\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_23\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_23\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_23\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_24\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_24\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 5\"],\n                [1, \"0x07\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_24\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 5\"],\n                [1, \"0x08\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_25\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 6\"],\n                [1, \"0x08\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_25\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OnOff 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_26\", \"S_BUTTON_ACTION_HOLD\", \"DimUp 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_26\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_26\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_27\", \"S_BUTTON_ACTION_HOLD\", \"DimDown 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_27\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown 6\"],\n                [1, \"0x08\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_27\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown 6\"]\n            ]\n        },\n        \"icasaKPD12Map\": {\n            \"vendor\": \"iCasa\",\n            \"doc\": \"ICZB-KPD12 remote\",\n            \"modelids\": [\"ICZB-KPD12\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Off\"},\n                {\"S_BUTTON_2\": \"On\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"icasaKPD14SMap\": {\n            \"vendor\": \"iCasa\",\n            \"doc\": \"ICZB-KPD14S remote\",\n            \"modelids\": [\"ICZB-KPD14S\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Off\"},\n                {\"S_BUTTON_2\": \"On\"},\n                {\"S_BUTTON_3\": \"S1\"},\n                {\"S_BUTTON_4\": \"S2\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 2\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 2\"]\n            ]\n        },\n        \"icasaKPD18SMap\": {\n            \"vendor\": \"iCasa\",\n            \"doc\": \"ICZB-KPD18S remote\",\n            \"modelids\": [\"ICZB-KPD18S\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Off\"},\n                {\"S_BUTTON_2\": \"On\"},\n                {\"S_BUTTON_3\": \"S1\"},\n                {\"S_BUTTON_4\": \"S2\"},\n                {\"S_BUTTON_5\": \"S3\"},\n                {\"S_BUTTON_6\": \"S4\"},\n                {\"S_BUTTON_7\": \"S5\"},\n                {\"S_BUTTON_8\": \"S6\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 2\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 2\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"3\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 3\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"3\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 3\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"4\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 4\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"4\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 4\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"5\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 5\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"5\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 5\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"6\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 6\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"6\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 6\"]\n            ]\n        },\n        \"icasaRemoteMap\": {\n            \"vendor\": \"iCasa\",\n            \"doc\": \"Remotes\",\n            \"modelids\": [\"ICZB-RM11S\", \"ZGRC-KEY-012\", \"ZGRC-KEY-013\", \"RGBgenie ZB-5001\", \"RGBgenie ZB-5004\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"2\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 2\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"samjinButtonMap\": {\n            \"vendor\": \"Samjin\",\n            \"doc\": \"Remote\",\n            \"modelids\": [\"button\"],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ZONE\", \"STATUS_CHANGE\", \"0x01\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x01\", \"IAS_ZONE\", \"STATUS_CHANGE\", \"0x02\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"IAS_ZONE\", \"STATUS_CHANGE\", \"0x03\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Hold\"]\n            ]\n        },\n        \"TuyaKeyfobMap\": {\n            \"vendor\": \"Woox\",\n            \"doc\": \"4 button remotes from Woox and Nedis\",\n            \"modelids\": [\"_TZ3000_0zrccfgx\", \"_TZ3000_fsiepnrh\", \"_TZ3000_p6ju8myv\"],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm day/home zones only\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Disarm\"],\n                [1, \"0x01\", \"IAS_ACE\", \"EMERGENCY\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Emergency\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"3\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm all zones\"]\n            ]\n        },\n        \"sunricherCCTMap\": {\n            \"vendor\": \"Sunricher\",\n            \"doc\": \"CCT remote\",\n            \"modelids\": [\"ZGRC-KEY-002\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x013C\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move color temperature up\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x033C\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move color temperature down\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"STOP_MOVE_STEP\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_\"]\n            ]\n        },\n        \"sunricherZG2855Map\": {\n            \"vendor\": \"Sunricher\",\n            \"doc\": \"Zigbee 3 in 1 remote ZG2855-RGB\",\n            \"modelids\": [\"ZG2855-RGB\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Increase lightness\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Decrease lightness\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR\", \"0xEB\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0x30\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"]\n            ]\n        },\n        \"sunricherC4Map\": {\n            \"vendor\": \"Sunricher\",\n            \"doc\": \"Zigbee Push-Button Coupler SR-ZG2833PAC-C4\",\n            \"modelids\": [\"ZG2833PAC\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x03\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x04\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"]\n            ]\n        },\n        \"sunricherC42Map\": {\n            \"vendor\": \"Sunricher\",\n            \"doc\": \"Control unit C4\",\n            \"modelids\": [\"VIVARES_PBC4_01\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button 1\"},\n                {\"S_BUTTON_2\": \"Button 2\"},\n                {\"S_BUTTON_3\": \"Button 3\"},\n                {\"S_BUTTON_4\": \"Button 4\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"rgbgenie5121Map\": {\n            \"vendor\": \"RGBgenie\",\n            \"doc\": \"Micro remote ZB-5121\",\n            \"modelids\": [\"RGBgenie ZB-5121\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"]\n            ]\n        },\n        \"sunricherMap\": {\n            \"vendor\": \"Sunricher\",\n            \"doc\": \"Wireless switches from Sunricher, Namron, SLC and EcoDim\",\n            \"modelids\": [\"ED-10010\", \"ED-10011\", \"ED-10012\", \"ED-10013\", \"ED-10014\", \"ED-10015\", \"ZG2833K2_EU07\", \"ZG2833K8_EU05\", \"ZG2833K4_EU06\", \"ZG2835\", \"4512701\", \"4512702\", \"4512703\", \"4512705\", \"4512719\", \"4512721\", \"4512728\", \"4512729\", \"S57003\", \"ROB_200-008\", \"ROB_200-009-0\", \"ROB_200-008-0\", \"ROB_200-007-0\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"On 1\"},\n                {\"S_BUTTON_2\": \"Off 1\"},\n                {\"S_BUTTON_3\": \"On 2\"},\n                {\"S_BUTTON_4\": \"Off 2\"},\n                {\"S_BUTTON_5\": \"On 3\"},\n                {\"S_BUTTON_6\": \"Off 3\"},\n                {\"S_BUTTON_7\": \"On 4\"},\n                {\"S_BUTTON_8\": \"Off 4\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x04\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"Tuya3gangMap\": {\n            \"vendor\": \"Tuya\",\n            \"doc\": \"3-gang remote\",\n            \"modelids\": [\"_TZ3000_yw5tvzsk\", \"_TZ3000_czuyt8lz\",\"_TZ3000_ee8nrt2l\", \"_TZ3000_ygvf9xzp\", \"_TZ3000_t8hzpgnd\", \"_TZ3000_wkai4ga5\", \"_TZ3000_bi6lpsew\", \"_TZ3400_keyjhapk\", \"_TYZB02_key8kk7r\", \"_TZ3400_keyjqthh\", \"_TZ3400_key8kk7r\", \"_TZ3000_vp6clf9d\", \"_TYZB02_keyjqthh\", \"_TZ3000_peszejy7\", \"_TZ3000_qzjcsmar\", \"_TZ3000_owgcnkrh\", \"_TZ3000_adkvzooy\", \"_TZ3000_arfwfgoa\", \"_TZ3000_a7ouggvs\", \"_TZ3000_rrjr1q0u\", \"_TZ3000_abci1hiu\", \"_TZ3000_dfgbtub0\", \"_TZ3000_rco1yzb1\", \"_TZ3000_gbm10jnj\", \"_TZ3000_5e235jpa\", \"_TZ3000_sj7jbgks\", \"_TZ3000_w8jwkczz\", \"_TZ3000_dziaict4\", \"_TZ3000_famkxci2\", \"_TZ3000_itb0omhv\", \"_TZ3000_tzvbimpq\", \"_TZ3000_mh9px7cq\", \"_TZ3000_b7bxojrg\", \"_TZ3000_ufhtxr59\", \"_TZ3000_4upl1fcj\", \"_TZ3000_i3rjdrwu\", \"_TZ3000_w3c7ouru\", \"_TZ3000_abci1hiu\",\"_TZ3000_wqcbzbae\", \"_TZ3000_pkeqinnt\", \"_TZ3000_uaa99arv\", \"_TZ3000_wbfgbpxq\", \"_TZ3000_fa9mlvja\", \"_TZ3000_tk3s5tyg\", \"_TZ3000_mrpevh8p\", \"_TZ3000_qgwcxxws\", \"_TZ3000_yj6k7vfo\", \"_TZ3000_axpdxqgu\", \"_TZ3000_a4xycprs\", \"_TZ3000_u3nv1jwk\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B1 short\"],\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"B1 double\"],\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"B1 long\"],\n                [1, \"0x02\", \"ONOFF\", \"0xfd\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B2 short\"],\n                [1, \"0x02\", \"ONOFF\", \"0xfd\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"B2 double\"],\n                [1, \"0x02\", \"ONOFF\", \"0xfd\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"B2 long\"],\n                [1, \"0x03\", \"ONOFF\", \"0xfd\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B3 short\"],\n                [1, \"0x03\", \"ONOFF\", \"0xfd\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"B3 double\"],\n                [1, \"0x03\", \"ONOFF\", \"0xfd\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"B3 long\"],\n                [1, \"0x04\", \"ONOFF\", \"0xfd\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B4 short\"],\n                [1, \"0x04\", \"ONOFF\", \"0xfd\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"B4 double\"],\n                [1, \"0x04\", \"ONOFF\", \"0xfd\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"B4 long\"]\n            ]\n        },\n        \"TuyaDimmerMap\": {\n            \"vendor\": \"Tuya\",\n            \"doc\": \"4-gang remote\",\n            \"modelids\": [\"_TZ3000_xabckq1v\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B1\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B2\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B3\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B4\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"B3H\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B3R\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"B4L\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"B4R\"]\n            ]\n        },\n        \"TuyaSmartButton\": {\n            \"vendor\": \"Tuya\",\n            \"doc\": \"Smart Button with two modes (remote mode not mapped)\",\n            \"modelids\": [\"_TZ3000_ja5osu5g\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Short\"],\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double\"],\n                [1, \"0x01\", \"ONOFF\", \"0xfd\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long\"]\n            ]\n        },\n        \"legrandSceneRemote\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Pocket remote\",\n            \"modelids\": [\"Pocket remote\"],\n            \"map\": [\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0xEA\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0xEB\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 2\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0xEC\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 3\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0xED\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Scene 4\"]\n            ]\n        },\n        \"legrandSwitchRemote\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Remote switch\",\n            \"modelids\": [\"Remote switch\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Toggle\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"]\n            ]\n        },\n        \"legrandDoubleSwitchRemote\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Double remote switch\",\n            \"modelids\": [\"Double gangs remote switch\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"]\n            ]\n        },\n        \"PaulmannMap\": {\n            \"vendor\": \"Paulmann LichtGmbH\",\n            \"doc\": \"On off remote\",\n            \"modelids\": [\"501.34\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"ON Left\"},\n                {\"S_BUTTON_2\": \"OFF Left\"},\n                {\"S_BUTTON_3\": \"ON Right\"},\n                {\"S_BUTTON_4\": \"OFF Right\"},\n                {\"S_BUTTON_5\": \"ON Left long\"},\n                {\"S_BUTTON_6\": \"OFF Left long\"},\n                {\"S_BUTTON_7\": \"ON Right long\"},\n                {\"S_BUTTON_8\": \"OFF Right long\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"ON Left\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OFF Left\"],\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"ON Right\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"OFF Right\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim Up Left\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop Dim\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim Down Left\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop Dim\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim Up Right\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop Dim\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim Down Right\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"1\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop Dim\"]\n            ]\n        },\n        \"aqaraOpple6Map\": {\n            \"vendor\": \"Xiaomi\",\n            \"doc\": \"Aqara Opple switches\",\n            \"modelids\": [\"lumi.remote.b286opcn01\", \"lumi.remote.b486opcn01\", \"lumi.remote.b686opcn01\"],\n            \"map\": [\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Off hold\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Off double press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Off triple press\"],\n                [1, \"0x01\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Off long released\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"On hold\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"On double press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"On triple press\"],\n                [1, \"0x02\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"On long released\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dim down hold\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim down press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Dim down double press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Dim down triple press\"],\n                [1, \"0x03\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dim down long released\"],\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dim up hold\"],\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim up press\"],\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Dim up double press\"],\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Dim up triple press\"],\n                [1, \"0x04\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dim up long released\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Color warm hold\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Color warm press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Color warm double press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Color warm triple press\"],\n                [1, \"0x05\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Color warm long released\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Color cold hold\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"1\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Color cold press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"2\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Color cold double press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"3\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Color cold triple press\"],\n                [1, \"0x06\", \"MULTISTATE_INPUT\", \"ATTRIBUTE_REPORT\", \"0xFF\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Color cold long released\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off press\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim down press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dim down hold\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dim down long released\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim up press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dim up hold\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dim up long released\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Color warm press\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x010F\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Color warm hold\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x100F\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Color warm long released\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"STEP_COLOR_TEMPERATURE\", \"3\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Color cold press\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x030F\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Color cold hold\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x300F\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Color cold long released\"]\n            ]\n        },\n        \"legrandShutterSwitchRemote\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Shutter switch remote\",\n            \"modelids\": [\"Shutters central remote switch\"],\n            \"map\": [\n                [1, \"0x01\", \"WINDOW_COVERING\", \"OPEN\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"CLOSE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"WINDOW_COVERING\", \"STOP\", \"2\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"legrandToggleRemoteSwitch\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Remote toggle switch\",\n            \"modelids\": [\"Remote toggle switch\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n        },\n        \"legrandMotionSensor\": {\n            \"vendor\": \"Legrand\",\n            \"doc\": \"Remote motion sensor\",\n            \"modelids\": [\"Remote motion sensor\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"ONOFF\", \"ON_WITH_TIMED_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On with timed off\"]\n            ]\n        },\n        \"bitronRemoteMap\": {\n            \"vendor\": \"Bitron\",\n            \"doc\": \"4 button remote 902010/23\",\n            \"modelids\": [\"902010/23\"],\n            \"map\": [\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"]\n            ]\n        },\n        \"rcv14Map\": {\n            \"vendor\": \"Heiman\",\n            \"doc\": \"Smart controller HS1RC-M and HS1RC-E\",\n            \"modelids\": [\"RC_V14\", \"RC-EM\", \"RC-EF-3.0\"],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm day/home zones only\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Disarm\"],\n                [1, \"0x01\", \"IAS_ACE\", \"EMERGENCY\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Emergency\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"3\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm all zones\"]\n            ]\n        },\n        \"immaxKeyfobMap\": {\n            \"vendor\": \"Immax\",\n            \"doc\": \"Smart Keyfob 07046L\",\n            \"modelids\": [\"Keyfob-ZB3.0\"],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm day/home zones only\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Disarm\"],\n                [1, \"0x01\", \"IAS_ACE\", \"EMERGENCY\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Emergency\"],\n                [1, \"0x01\", \"IAS_ACE\", \"ARM\", \"3\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Arm all zones\"]\n            ]\n        },\n        \"tintMap\": {\n            \"vendor\": \"Tint\",\n            \"doc\": \"Remote\",\n            \"modelids\": [\"ZBT-Remote-ALL-RGBW\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step Up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move Up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step Down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move Down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to Color Temperature (Up)\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to Color Temperature (Down)\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to Color\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"3\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Work Light\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"1\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Sunset\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"2\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Party\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"6\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Night Light\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"4\", \"S_BUTTON_11\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Campfire\"],\n                [1, \"0x01\", \"BASIC\", \"0x02\", \"5\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Romance\"]\n            ]\n        },\n        \"sageMap\": {\n            \"vendor\": \"Sage\",\n            \"doc\": \"Door bell\",\n            \"modelids\": [\"Bell\"],\n            \"map\": [\n                [1, \"0x12\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x12\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x12\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"On (hold)\"],\n                [1, \"0x12\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"On (released)\"]\n            ]\n        },\n        \"sonoffOnOffMap\": {\n            \"vendor\": \"Sonoff\",\n            \"doc\": \"Switch SNZB-01\",\n            \"modelids\": [\"WB01\", \"WB-01\", \"SNZB-01P\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"double\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"long\"],\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"short\"]\n            ]\n        },\n        \"ZGRC-KEY-009\": {\n            \"vendor\": \"YPHIX\",\n            \"doc\": \"RGB wall switch\",\n            \"modelids\": [\"ZGRC-KEY-009\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"185\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move color temperature\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"1\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_HOLD\", \"Move color temperature\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"STOP_MOVE_STEP\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop move color temperature\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR\", \"206\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_HOLD\", \"Move to color\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_HUE\", \"3\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Move to color\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 2\"]\n            ]\n        },\n        \"ZGRC-KEY-007\": {\n            \"vendor\": \"YPHIX\",\n            \"doc\": \"K2 wall switch\",\n            \"modelids\": [\"ZGRC-KEY-007\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop_ (with on/off)\"]\n            ]\n        },\n        \"LDSRemoteMap\": {\n            \"vendor\": \"EcoSmart/LDS\",\n            \"doc\": \"4 button CCT switch\",\n            \"modelids\": [\"ZBT-CCTSwitch-D0001\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_TO_LEVEL\", \"0x7F\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim short\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Dim long press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0x01\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dim long release\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0x1D\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Temperature short\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x00\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Temperature Long press\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_COLOR_TEMPERATURE\", \"0x01\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Temperature Long press 2\"]\n            ]\n        },\n        \"ZBT-DIMController-D0800Map\": {\n            \"vendor\": \"LDS\",\n            \"doc\": \"Mueller-Licht tint dimmer\",\n            \"modelids\": [\"ZBT-DIMController-D0800\", \"ZBT-DIMSwitch-D0000\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"On/Off\"},\n                {\"S_BUTTON_2\": \"Dim Up\"},\n                {\"S_BUTTON_3\": \"Dim Down\"},\n                {\"S_BUTTON_4\": \"Scene\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"1\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"]\n            ]\n        },\n        \"linkind1keyMap\": {\n            \"vendor\": \"Linkind\",\n            \"doc\": \"1 button remote ZS232000178\",\n            \"modelids\": [\"ZBT-DIMSwitch-D0001\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_HOLD\", \"Move up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"Move down\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"iluminizeMap\": {\n            \"vendor\": \"Iluminize\",\n            \"doc\": \"4 button CCT touch remote\",\n            \"modelids\": [\"ZGRC-TEUR-003\"],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down (with on/off)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x01\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_5\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"],\n                [1, \"0x01\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x01\", \"SCENES\", \"STORE_SCENE\", \"0\", \"S_BUTTON_6\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"],\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_7\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_8\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_9\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down (with on/off)\"],\n                [1, \"0x02\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_10\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x02\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_11\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"],\n                [1, \"0x02\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x02\", \"SCENES\", \"STORE_SCENE\", \"0\", \"S_BUTTON_12\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"],\n                [1, \"0x03\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_13\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_14\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_16\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_15\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_16\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down (with on/off)\"],\n                [1, \"0x03\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_16\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x03\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_17\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"],\n                [1, \"0x03\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_18\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x03\", \"SCENES\", \"STORE_SCENE\", \"0\", \"S_BUTTON_18\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"],\n                [1, \"0x04\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_19\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x04\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_20\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"1\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STEP_WITH_ON_OFF\", \"0\", \"S_BUTTON_22\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Step down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"1\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_HOLD\", \"Dimm up (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_21\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm up stop\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"MOVE_WITH_ON_OFF\", \"0\", \"S_BUTTON_22\", \"S_BUTTON_ACTION_HOLD\", \"Dimm down (with on/off)\"],\n                [1, \"0x04\", \"LEVEL_CONTROL\", \"STOP_WITH_ON_OFF\", \"0\", \"S_BUTTON_22\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Dimm down stop\"],\n                [1, \"0x04\", \"COLOR_CONTROL\", \"MOVE_TO_COLOR_TEMPERATURE\", \"0\", \"S_BUTTON_23\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Move to color temperature\"],\n                [1, \"0x04\", \"SCENES\", \"RECALL_SCENE\", \"0\", \"S_BUTTON_24\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Recall scene 1\"],\n                [1, \"0x04\", \"SCENES\", \"STORE_SCENE\", \"0\", \"S_BUTTON_24\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Store scene 1\"]\n            ]\n        },\n        \"lidlMap\": {\n            \"vendor\": \"LIDL Livarno Lux\",\n            \"doc\": \"LIDL / Livarno Lux Remote Control (_TYZB01_bngwdjsr)\",\n            \"modelids\": [\"HG06323\"],\n            \"buttons\": [\n              {\"S_BUTTON_1\": \"On\"},\n              {\"S_BUTTON_2\": \"Dim Up\"},\n              {\"S_BUTTON_3\": \"Dim Down\"},\n              {\"S_BUTTON_4\": \"Off\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ONOFF\", \"LIDL\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On (0)\"],\n                [1, \"0x01\", \"ONOFF\", \"LIDL\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On (1)\"],\n                [1, \"0x01\", \"ONOFF\", \"LIDL\", \"2\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On (2)\"],\n                [1, \"0x01\", \"ONOFF\", \"LIDL\", \"3\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On (3)\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimUp Press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_HOLD\", \"DimUp Hold\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimUp Release\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"DimDown Press\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"MOVE\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_HOLD\", \"DimDown Hold\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STOP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"DimDown Release\"],\n                [1, \"0x01\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n\n        },\n        \"lidlDoorbellMap\": {\n            \"vendor\": \"LIDL Silvercrest\",\n            \"doc\": \"Lidl / Silvercrest doorbell (_TZ1800_ladpngdx)\",\n            \"modelids\": [\"HG06668\",\"_TZ1800_ladpngdx\", \"TS0211\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Button\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"IAS_ZONE\", \"STATUS_CHANGE\", \"0x05\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Ring\"]\n            ]\n        },\n        \"sengledMap\": {\n            \"vendor\": \"Sengled\",\n            \"doc\": \"Sengled Smart Light Switch\",\n            \"modelids\": [\"E1E-G7F\"],\n            \"map\": [\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"1\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On (single press)\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"5\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"On (double press)\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"6\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"On (long press)\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"2\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim up\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"3\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim down\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"4\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"7\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Off (double press)\"],\n                [1, \"0x01\", \"SENGLED\", \"COMMAND_0\", \"8\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Off (long press)\"]\n            ]\n        },\n        \"elkoMap\": {\n            \"vendor\": \"ELKO\",\n            \"doc\": \"Elko ESH 316 Endevender RF\",\n            \"modelids\": [\"ElkoDimmerRemoteZHA\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"On/Off\"},\n                {\"S_BUTTON_2\": \"Dim Up\"},\n                {\"S_BUTTON_3\": \"Dim Down\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"ONOFF\", \"TOGGLE\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim up\"],\n                [1, \"0x01\", \"LEVEL_CONTROL\", \"STEP\", \"1\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim down\"]\n            ]\n        },\n        \"aduroMap\": {\n            \"vendor\": \"Adurolight Manufacturing\",\n            \"doc\": \"Eria Adurosmart Wireless Dimming Switch\",\n            \"modelids\": [\"Adurolight_NCC\"],\n            \"map\": [\n                [1, \"0x01\", \"ADUROLIGHT\", \"COMMAND_0\", \"0x0000\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x01\", \"ADUROLIGHT\", \"COMMAND_0\", \"0x0001\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim up\"],\n                [1, \"0x01\", \"ADUROLIGHT\", \"COMMAND_0\", \"0x0002\", \"S_BUTTON_3\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Dim down\"],\n                [1, \"0x01\", \"ADUROLIGHT\", \"COMMAND_0\", \"0x0003\", \"S_BUTTON_4\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n        },\n        \"terncySd01Map\": {\n            \"vendor\": \"Terncy\",\n            \"doc\": \"Terncy Smart Dial SD01\",\n            \"modelids\": [\"TERNCY-SD01\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Action button\"}\n            ],\n            \"map\": [\n                [1, \"0x01\", \"XIAOYAN\", \"COMMAND_0\", \"0x0001\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Single press\"],\n                [1, \"0x01\", \"XIAOYAN\", \"COMMAND_0\", \"0x0002\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_DOUBLE_PRESS\", \"Double press\"],\n                [1, \"0x01\", \"XIAOYAN\", \"COMMAND_0\", \"0x0003\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_TREBLE_PRESS\", \"Tripple press\"],\n                [1, \"0x01\", \"XIAOYAN\", \"COMMAND_0\", \"0x0004\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_QUADRUPLE_PRESS\", \"Quadruple press\"],\n                [1, \"0x01\", \"XIAOYAN\", \"COMMAND_20\", \"0x01\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Long press\"],\n                [1, \"0x01\", \"XIAOYAN\", \"ATTRIBUTE_REPORT\", \"0x00\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_ROTATE_CLOCKWISE\", \"Rotate clockwise\"],\n                [1, \"0x01\", \"XIAOYAN\", \"ATTRIBUTE_REPORT\", \"0x01\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_ROTATE_COUNTER_CLOCKWISE\", \"Rotate counter-clockwise\"]\n            ]\n        },\n        \"NHPBMap\": {\n            \"vendor\": \"Schneider Electric\",\n            \"doc\": \"Cover controller\",\n            \"modelids\": [\"NHPB/SHUTTER/1\"],\n            \"map\": [\n                [1, \"0x15\", \"WINDOW_COVERING\", \"OPEN\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Open\"],\n                [1, \"0x15\", \"WINDOW_COVERING\", \"STOP\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"],\n                [1, \"0x15\", \"WINDOW_COVERING\", \"CLOSE\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Close\"],\n                [1, \"0x15\", \"WINDOW_COVERING\", \"STOP\", \"1\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_LONG_RELEASED\", \"Stop\"]\n            ]\n        },\n        \"boschLightControl2Map\": {\n            \"vendor\": \"Bosch\",\n            \"doc\": \"Light/shutter control II (BMCT-SLZ)\",\n            \"modelids\": [\"RBSH-MMS-ZB-EU\"],\n            \"buttons\": [\n                {\"S_BUTTON_1\": \"Left\"},\n                {\"S_BUTTON_2\": \"Right\"}\n            ],\n            \"map\": [\n                [1, \"0x02\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x02\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_1\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"],\n                [1, \"0x03\", \"ONOFF\", \"ON\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"On\"],\n                [1, \"0x03\", \"ONOFF\", \"OFF\", \"0\", \"S_BUTTON_2\", \"S_BUTTON_ACTION_SHORT_RELEASED\", \"Off\"]\n            ]\n        }\n    }\n}\n"
        },
        {
          "name": "button_maps.schema.json",
          "type": "blob",
          "size": 5.693359375,
          "content": "{\n  \"$id\": \"https://github.com/dresden-elektronik/deconz-rest-plugin/button_maps.schema.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"description\": \"Description of deCONZ button events\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"buttons\": {\n      \"type\": \"object\",\n      \"patternProperties\": {\n        \"^S_BUTTON_[0-9]{1,2}\": {\n          \"type\": \"integer\",\n          \"minimum\": 1000\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"buttonActions\": {\n      \"type\": \"object\",\n      \"patternProperties\": {\n        \"^S_BUTTON_ACTION_\": {\n          \"type\": \"integer\",\n          \"minimum\": 0,\n          \"maximum\": 99\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"clusters\": {\n      \"type\": \"object\",\n      \"patternProperties\": {\n        \"^[A-Z]+\": {\n          \"type\": \"integer\",\n          \"minimum\": 0,\n          \"maximum\": 65535\n        }\n      },\n      \"propertyNames\": {\n        \"$ref\": \"#/definitions/clusters\"\n      },\n      \"additionalProperties\": false\n    },\n    \"commands\": {\n      \"type\": \"object\",\n      \"propertyNames\": { \"$ref\": \"#/definitions/clusters\" },\n      \"properties\" : {\n        \"SCENES\": {\n          \"type\": \"object\",\n          \"propertyNames\": { \"$ref\": \"#/definitions/scene-commands\" }\n        },\n        \"ONOFF\": {\n          \"type\": \"object\",\n          \"propertyNames\": { \"$ref\": \"#/definitions/onoff-commands\" },\n          \"patternProperties\": {\n            \"^[A-Z]+\": {\"type\": \"integer\" }\n          }\n        }\n      }\n    },\n    \"maps\": {\n      \"type\": \"object\",\n      \"patternProperties\": {\n        \"^[a-z]+\": {\n          \"$ref\": \"#/definitions/entry\"\n        }\n      }\n    }\n  },\n  \"required\": [ \"buttons\", \"buttonActions\", \"clusters\", \"commands\", \"maps\" ],\n  \"definitions\": {\n    \"clusters\": {\n      \"enum\": [\n          \"BASIC\",\n          \"SCENES\",\n          \"SENGLED\",\n          \"ONOFF\",\n          \"LEVEL_CONTROL\",\n          \"MULTISTATE_INPUT\",\n          \"DOOR_LOCK\",\n          \"WINDOW_COVERING\",\n          \"COLOR_CONTROL\",\n          \"IAS_ZONE\",\n          \"IAS_ACE\",\n          \"FC80\",\n          \"XIAOMI\",\n          \"ADUROLIGHT\",\n          \"XIAOYAN\"\n        ]\n    },\n    \"adurolight-commands\": {\n      \"enum\": [ \"ATTRIBUTE_REPORT\", \"COMMAND_0\", \"COMMAND_20\" ]\n    },\n    \"basic-commands\": {\n      \"enum\": [ \"0x02\" ]\n    },\n    \"scene-commands\": {\n      \"enum\": [ \"ADD_SCENE\", \"VIEW_SCENE\", \"REMOVE_SCENE\", \"STORE_SCENE\", \"RECALL_SCENE\", \"IKEA_STEP_CT\", \"IKEA_MOVE_CT\", \"IKEA_STOP_CT\" ]\n    },\n    \"sengled-commands\": {\n      \"enum\": [ \"COMMAND_0\" ]\n    },\n    \"onoff-commands\": {\n      \"enum\": [ \"ATTRIBUTE_REPORT\", \"OFF\", \"ON\", \"TOGGLE\", \"OFF_WITH_EFFECT\", \"ON_WITH_TIMED_OFF\", \"LIDL\" ]\n    },\n    \"level-commands\": {\n      \"enum\": [ \"MOVE_TO_LEVEL\", \"MOVE\", \"STEP\", \"STOP\", \"MOVE_TO_LEVEL_WITH_ON_OFF\", \"MOVE_WITH_ON_OFF\", \"STEP_WITH_ON_OFF\", \"STOP_WITH_ON_OFF\" ]\n    },\n    \"color-commands\": {\n      \"enum\": [ \"MOVE_HUE\", \"STEP_HUE\", \"MOVE_TO_SATURATION\", \"MOVE_TO_COLOR\", \"MOVE_TO_COLOR_TEMPERATURE\", \"STOP_MOVE_STEP\", \"MOVE_COLOR_TEMPERATURE\", \"STEP_COLOR_TEMPERATURE\" ]\n    },\n    \"window-covering-commands\": {\n      \"enum\": [ \"OPEN\", \"CLOSE\", \"STOP\", \"GOTO_LIFT_PCT\", \"GOTO_TILT_PCT\" ]\n    },\n    \"ias-commands\": {\n      \"enum\": [ \"ARM\", \"EMERGENCY\", \"STATUS_CHANGE\" ]\n    },\n    \"multistate-input-commands\": {\n      \"enum\": [ \"ATTRIBUTE_REPORT\" ]\n    },\n    \"fc80-commands\": {\n      \"enum\": [ \"COMMAND_1\", \"COMMAND_2\", \"COMMAND_3\", \"COMMAND_4\", \"COMMAND_6\" ]\n    },\n    \"xiaomi-commands\": {\n      \"enum\": [ \"ATTRIBUTE_REPORT\" ]\n    },\n    \"xiaoyan-commands\": {\n      \"enum\": [ \"ATTRIBUTE_REPORT\", \"COMMAND_0\", \"COMMAND_20\" ]\n    },\n    \"entry\": {\n      \"type\": \"object\",\n      \"required\": [\"vendor\", \"modelids\", \"map\"],\n      \"properties\": {\n        \"map\": {\n          \"type\": \"array\",\n          \"items\": { \"$ref\": \"#/definitions/button-event\" },\n          \"minItems\": 1\n        },\n        \"modelids\": {\n          \"type\": \"array\"\n        }\n      }\n    },\n    \"button-event\" : {\n      \"minItems\": 8,\n      \"maxItems\": 8,\n      \"items\" : [\n        {\n          \"type\": \"integer\",\n          \"enum\": [ 1, 2, 3, 4 ],\n          \"description\": \"Mode of operation.\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^0x[0-9a-fA-F]{2}\",\n          \"description\": \"Source endpoint of the received command.\"\n        },\n        {\n          \"$ref\": \"#/definitions/clusters\",\n          \"description\": \"The cluster of the received command.\"\n        },\n        {\n          \"anyOf\": [\n            { \"$ref\": \"#/definitions/adurolight-commands\" },\n            { \"$ref\": \"#/definitions/basic-commands\" },\n            { \"$ref\": \"#/definitions/onoff-commands\" },\n            { \"$ref\": \"#/definitions/level-commands\" },\n            { \"$ref\": \"#/definitions/color-commands\" },\n            { \"$ref\": \"#/definitions/scene-commands\" },\n            { \"$ref\": \"#/definitions/sengled-commands\" },\n            { \"$ref\": \"#/definitions/window-covering-commands\" },\n            { \"$ref\": \"#/definitions/ias-commands\" },\n            { \"$ref\": \"#/definitions/multistate-input-commands\" },\n            { \"$ref\": \"#/definitions/fc80-commands\" },\n            { \"$ref\": \"#/definitions/xiaomi-commands\" },\n            { \"$ref\": \"#/definitions/xiaoyan-commands\" }\n          ],\n          \"description\": \"The received cluster command.\"\n        },\n        {\n          \"type\": \"string\",\n          \"description\": \"The related parameter.\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^S_BUTTON_[0-9]{1,2}|0\",\n          \"description\": \"The mapped button.\"\n        },\n        {\n          \"type\": \"string\",\n          \"pattern\": \"^S_BUTTON_ACTION|0\",\n          \"description\": \"The mapped button action.\"\n        },\n        {\n          \"type\": \"string\",\n          \"description\": \"A comment what this event does.\"\n        }\n      ]\n    }\n  }\n}\n"
        },
        {
          "name": "change_channel.cpp",
          "type": "blob",
          "size": 15.314453125,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"zdp/zdp.h\"\n\n#define CC_CHANNELCHANGE_WAIT_TIME         1000\n#define CC_CHANNELCHANGE_WAIT_CONFIRM_TIME 10000\n#define CC_CHANNELCHANGE_VERIFY_TIME       1000\n#define CC_DISCONNECT_CHECK_DELAY 100\n#define NETWORK_ATTEMPS 10\n#define CC_RECONNECT_CHECK_DELAY  5000\n#define CC_RECONNECT_NOW          100\n\n/*! Init the change channel api and helpers.\n */\nvoid DeRestPluginPrivate::initChangeChannelApi()\n{\n    channelChangeState = CC_Idle;\n    ccRetries = 0;\n    channelchangeTimer = new QTimer(this);\n    channelchangeTimer->setSingleShot(true);\n    connect(channelchangeTimer, SIGNAL(timeout()),\n            this, SLOT(channelchangeTimerFired()));\n\n    QTimer *wdTimer = new QTimer(this);\n    wdTimer->setSingleShot(false);\n    connect(wdTimer, SIGNAL(timeout()), this, SLOT(networkWatchdogTimerFired()));\n    wdTimer->start(10000);\n}\n\n\n/*! Starts the whole channel changing process if connected.\n    \\param channel - user input channel\n    \\return true if connected.\n */\nbool DeRestPluginPrivate::startChannelChange(quint8 channel)\n{\n    if (!isInNetwork())\n    {\n        return false;\n    }\n\n    ccRetries = 0;\n    gwZigbeeChannel = channel;\n    queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\n\n    if (channelChangeState != CC_Idle)\n    {\n        DBG_Printf(DBG_INFO, \"channel change in progress.\\n\");\n        return true;\n    }\n\n    channelChangeState = CC_Verify_Channel;\n    DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_verify_Channel\\n\");\n    channelchangeTimer->start(CC_CHANNELCHANGE_VERIFY_TIME);\n    return true;\n}\n\n\n/*! Check if user input channel equals gateway channel.\n    \\param channel - user input channel\n    \\return true if equal\n */\nbool DeRestPluginPrivate::verifyChannel(quint8 channel)\n{\n\n    DBG_Assert(apsCtrl != nullptr);\n    if (!apsCtrl)\n    {\n        return false;\n    }\n\n    if (!isInNetwork())\n    {\n        return false;\n    }\n\n    quint8 currentChannel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\n    quint64 apsUseExtPanid = apsCtrl->getParameter(deCONZ::ParamApsUseExtendedPANID);\n    quint64 tcAddress = apsCtrl->getParameter(deCONZ::ParamTrustCenterAddress);\n    quint64 macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n    quint8 deviceType = apsCtrl->getParameter(deCONZ::ParamDeviceType);\n\n    bool ok = true;\n\n    if (currentChannel != channel)\n    {\n        ok = false;\n    }\n\n    if (deviceType == deCONZ::Coordinator)\n    {\n        if (apsUseExtPanid != 0)\n        {\n            ok = false;\n        }\n        else if (tcAddress != macAddress)\n        {\n            ok = false;\n        }\n    }\n\n    if (ok)\n    {\n        DBG_Printf(DBG_INFO, \"network configuration verified!\\n\");\n        return true;\n    }\n    else\n    {\n        DBG_Printf(DBG_INFO, \"network configuration NOT verified!\\n\");\n        return false;\n    }\n}\n\n\n/*! Sends request to gateway to change channel\n    \\param channel - user input channel\n */\nvoid DeRestPluginPrivate::changeChannel(quint8 channel)\n{\n    if (!apsCtrl)\n    {\n    }\n    else if ((gwDeviceAddress.ext() & deMacPrefix) != deMacPrefix)\n    {\n        // require valid mac address\n    }\n    else if (ccRetries < 3)\n    {\n        DBG_Assert(channel >= 11 && channel <= 26);\n        if (apsCtrl && channel >= 11 && channel <= 26)\n        {\n            uint8_t nwkUpdateId = apsCtrl->getParameter(deCONZ::ParamNetworkUpdateId);\n            if (nwkUpdateId < 255)\n            {\n                nwkUpdateId++;\n            }\n            else if (nwkUpdateId == 255)\n            {\n                nwkUpdateId = 1;\n            }\n            const quint8 zdpSeq = ZDP_NextSequenceNumber();\n            const quint32 scanChannels = (1 << static_cast<uint>(channel));\n            const quint8 scanDuration = 0xfe; //special value = channel change\n\n            DBG_Printf(DBG_INFO, \"change channel with nwkUpdateId = %u\\n\", nwkUpdateId);\n\n            apsCtrl->setParameter(deCONZ::ParamCurrentChannel, channel);\n            apsCtrl->setParameter(deCONZ::ParamNetworkUpdateId, nwkUpdateId);\n\n            deCONZ::ApsDataRequest req;\n\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n            req.setTxOptions(nullptr);\n#endif\n            req.setDstEndpoint(ZDO_ENDPOINT);\n            req.setDstAddressMode(deCONZ::ApsNwkAddress);\n            req.dstAddress().setNwk(deCONZ::BroadcastRxOnWhenIdle);\n            req.setProfileId(ZDP_PROFILE_ID);\n            req.setClusterId(ZDP_MGMT_NWK_UPDATE_REQ_CLID);\n            req.setSrcEndpoint(ZDO_ENDPOINT);\n            req.setRadius(0);\n\n            QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n            stream.setByteOrder(QDataStream::LittleEndian);\n            stream << zdpSeq;\n            stream << scanChannels;\n            stream << scanDuration;\n            stream << nwkUpdateId;\n\n            if (apsCtrlWrapper.apsdeDataRequest(req) == deCONZ::Success)\n            {\n                channelChangeApsRequestId = req.id();\n                DBG_Printf(DBG_INFO, \"change channel to %d, channel mask = 0x%08lX\\n\", channel, scanChannels);\n                channelChangeState = CC_WaitConfirm;\n                channelchangeTimer->start(CC_CHANNELCHANGE_WAIT_CONFIRM_TIME);\n                DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_WaitConfirm\\n\");\n                return;\n            }\n            else\n            {\n                DBG_Printf(DBG_ERROR, \"cant send change channel\\n\");\n            }\n        }\n\n        channelChangeState = CC_Verify_Channel;\n        DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_verify_Channel\\n\");\n        channelchangeTimer->start(CC_CHANNELCHANGE_VERIFY_TIME);\n        return;\n    }\n\n    if (apsCtrl && isInNetwork())\n    {\n        if (gwZigbeeChannel != apsCtrl->getParameter(deCONZ::ParamCurrentChannel))\n        {\n\n        }\n    }\n    ccRetries = 0;\n    channelChangeState = CC_Idle;\n    DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Idle\\n\");\n    DBG_Printf(DBG_INFO, \"channel change not successful.\\n\");\n    return;\n}\n\n/*! Handle confirmation of ZDP channel change request.\n    \\param success true on success\n */\nvoid DeRestPluginPrivate::channelChangeSendConfirm(bool success)\n{\n    channelchangeTimer->stop();\n\n    if (channelChangeState == CC_WaitConfirm)\n    {\n        if (success)\n        {\n            channelChangeDisconnectNetwork();\n        }\n        else\n        {\n            channelChangeState = CC_Verify_Channel;\n            DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_verify_Channel\\n\");\n            channelchangeTimer->start(CC_CHANNELCHANGE_VERIFY_TIME);\n        }\n    }\n}\n\n\n/*! Request to disconnect from network.\n */\nvoid DeRestPluginPrivate::channelChangeDisconnectNetwork()\n{\n    DBG_Assert(channelChangeState == CC_WaitConfirm);\n\n    if (channelChangeState != CC_WaitConfirm)\n    {\n        return;\n    }\n\n    DBG_Assert(apsCtrl != 0);\n\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    ccNetworkDisconnectAttempts = NETWORK_ATTEMPS;\n    ccNetworkConnectedBefore = gwRfConnectedExpected;\n    channelChangeState = CC_DisconnectingNetwork;\n    DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_DisconnectingNetwork\\n\");\n\n    apsCtrl->setNetworkState(deCONZ::NotInNetwork);\n\n    channelchangeTimer->start(CC_DISCONNECT_CHECK_DELAY);\n}\n\n/*! Checks if network is disconnected to proceed with further actions.\n */\nvoid DeRestPluginPrivate::checkChannelChangeNetworkDisconnected()\n{\n    if (channelChangeState != CC_DisconnectingNetwork)\n    {\n        return;\n    }\n\n    if (ccNetworkDisconnectAttempts > 0)\n    {\n        ccNetworkDisconnectAttempts--;\n    }\n\n    if (isInNetwork())\n    {\n        if (ccNetworkDisconnectAttempts == 0)\n        {\n            DBG_Printf(DBG_INFO, \"disconnect from network failed.\\n\");\n\n            // even if we seem to be connected force a delayed reconnect attemp to\n            // prevent the case that the disconnect happens shortly after here\n            channelChangeStartReconnectNetwork(CC_RECONNECT_CHECK_DELAY);\n        }\n        else\n        {\n            DBG_Assert(apsCtrl != nullptr);\n            if (apsCtrl)\n            {\n                DBG_Printf(DBG_INFO, \"disconnect from network failed, try again\\n\");\n                apsCtrl->setNetworkState(deCONZ::NotInNetwork);\n                channelchangeTimer->start(CC_DISCONNECT_CHECK_DELAY);\n            }\n            else\n            {   // sanity\n                channelChangeState = CC_Idle;\n                DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Idle\\n\");\n            }\n        }\n\n        return;\n    }\n    channelChangeStartReconnectNetwork(CC_RECONNECT_NOW);\n}\n\n/*! Reconnect to previous network state, trying serveral times if necessary.\n    \\param delay - the delay after which reconnecting shall be started\n */\nvoid DeRestPluginPrivate::channelChangeStartReconnectNetwork(int delay)\n{\n    channelChangeState = CC_ReconnectNetwork;\n    DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_ReconnectNetwork\\n\");\n    ccNetworkReconnectAttempts = NETWORK_ATTEMPS;\n\n    DBG_Printf(DBG_INFO, \"start reconnect to network\\n\");\n\n    channelchangeTimer->stop();\n    if (delay > 0)\n    {\n        channelchangeTimer->start(delay);\n    }\n    else\n    {\n        channelChangeReconnectNetwork();\n    }\n}\n\n/*! Helper to reconnect to previous network state, trying serveral times if necessary.\n */\nvoid DeRestPluginPrivate::channelChangeReconnectNetwork()\n{\n    if (channelChangeState != CC_ReconnectNetwork)\n    {\n        return;\n    }\n\n    if (isInNetwork())\n    {\n        channelChangeState = CC_Verify_Channel;\n        DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_verify_Channel\\n\");\n        channelchangeTimer->start(CC_CHANNELCHANGE_VERIFY_TIME);\n        DBG_Printf(DBG_INFO, \"reconnect network done\\n\");\n        return;\n    }\n\n    // respect former state\n    if (!ccNetworkConnectedBefore)\n    {\n        channelChangeState = CC_Idle;\n        DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Idle\\n\");\n        DBG_Printf(DBG_INFO, \"network was not connected before\\n\");\n        return;\n    }\n\n    if (ccNetworkReconnectAttempts > 0)\n    {\n        if (apsCtrl->networkState() != deCONZ::Connecting)\n        {\n            ccNetworkReconnectAttempts--;\n\n            const quint8 deviceType = apsCtrl->getParameter(deCONZ::ParamDeviceType);\n\n            if (deviceType == deCONZ::Coordinator)\n            {\n                apsCtrl->setParameter(deCONZ::ParamApsUseExtendedPANID, 0); // will become mac address\n                apsCtrl->setParameter(deCONZ::ParamTrustCenterAddress, gwDeviceAddress.ext());\n                apsCtrl->setParameter(deCONZ::ParamStaticNwkAddress, false);\n                apsCtrl->setParameter(deCONZ::ParamNwkAddress, 0);\n            }\n\n            if (apsCtrl->setNetworkState(deCONZ::InNetwork) != deCONZ::Success)\n            {\n                DBG_Printf(DBG_INFO, \"failed to reconnect to network try=%d\\n\", (NETWORK_ATTEMPS - ccNetworkReconnectAttempts));\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"try to reconnect to network try=%d\\n\", (NETWORK_ATTEMPS - ccNetworkReconnectAttempts));\n            }\n        }\n\n        channelchangeTimer->start(CC_RECONNECT_CHECK_DELAY);\n    }\n    else\n    {\n        channelChangeState = CC_Idle;\n        DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Idle\\n\");\n        DBG_Printf(DBG_INFO, \"reconnect network failed\\n\");\n    }\n}\n\n/*! Checks if network uses parameters it's suppoesed to be.\n */\nvoid DeRestPluginPrivate::networkWatchdogTimerFired()\n{\n    if (!apsCtrl || channelChangeState != CC_Idle)\n    {\n        return;\n    }\n\n    if (!isInNetwork())\n    {\n        return;\n    }\n\n    if (saveDatabaseItems & DB_NOSAVE)\n    {\n        return; // deCONZ will restart shortly\n    }\n\n    quint8 channel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\n    quint32 channelMask = apsCtrl->getParameter(deCONZ::ParamChannelMask);\n    quint64 apsUseExtPanid = apsCtrl->getParameter(deCONZ::ParamApsUseExtendedPANID);\n    quint64 tcAddress = apsCtrl->getParameter(deCONZ::ParamTrustCenterAddress);\n    quint64 macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n    quint8 deviceType = apsCtrl->getParameter(deCONZ::ParamDeviceType);\n\n    if (gwZigbeeChannel == 0)\n    {\n        if (channel >= 11 && channel <= 26)\n        {\n            gwZigbeeChannel = channel;\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\n        }\n    }\n\n    if (channel < 11 || channel > 26)\n    {\n        DBG_Printf(DBG_INFO, \"invalid current channel %u (TODO)\\n\", channel);\n        return;\n    }\n\n    if (channelMask && (channelMask & (1 << channel)) == 0)\n    {\n        DBG_Printf(DBG_INFO, \"channel %u does not match channel mask 0x%08X (TODO)\\n\", channel, channelMask);\n    }\n\n    if (gwZigbeeChannel == 0)\n    {\n        DBG_Printf(DBG_INFO, \"invalid gwZigbeeChannel %u (TODO)\\n\", gwZigbeeChannel);\n        return;\n    }\n    else if (deviceType != deCONZ::Coordinator)\n    {\n        DBG_Printf(DBG_INFO, \"unsupported device type %u (TODO)\\n\", deviceType);\n        return;\n    }\n    else if ((macAddress & deMacPrefix) != deMacPrefix) // only support our mac address\n    {\n        DBG_Printf(DBG_INFO, \"invalid mac address 0x%016llX\\n\", macAddress);\n        return;\n    }\n    else if (gwZigbeeChannel < 11 || gwZigbeeChannel > 26)\n    {\n        DBG_Assert(0); // should never happen\n        return;\n    }\n\n    bool needCheck = false;\n\n    if (channel != gwZigbeeChannel)\n    {\n        gwZigbeeChannel = channel;\n        saveDatabaseItems |= DB_CONFIG;\n    }\n    else if (deviceType == deCONZ::Coordinator)\n    {\n        if (apsUseExtPanid != 0)\n        {\n            needCheck = true;\n            DBG_Printf(DBG_INFO, \"apsUseExtPanid is 0x%016llX but should be 0, start reconfiguration\\n\", apsUseExtPanid);\n        }\n\n        if (tcAddress != macAddress)\n        {\n            needCheck = true;\n            DBG_Printf(DBG_INFO, \"tcAddress is 0x%016llX but should be 0x%016llX, start reconfiguration\\n\", tcAddress, macAddress);\n        }\n\n        if (needCheck)\n        {\n            gwDeviceAddress.setExt(macAddress);\n            gwDeviceAddress.setNwk(0x0000);\n        }\n    }\n\n    if (needCheck)\n    {\n        //startChannelChange(gwZigbeeChannel);\n        DBG_Printf(DBG_INFO, \"Skip automatic channel change, TODO warn user\\n\");\n    }\n}\n\n/*! Starts a delayed action based on current channelchange state.\n */\nvoid DeRestPluginPrivate::channelchangeTimerFired()\n{\n    switch (channelChangeState)\n    {\n    case CC_Idle:\n        break;\n\n    case CC_Verify_Channel:\n        if (!verifyChannel(gwZigbeeChannel))\n        {\n            channelChangeState = CC_Change_Channel;\n            DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Change_Channel\\n\");\n            channelchangeTimer->start(CC_CHANNELCHANGE_WAIT_TIME);\n        }\n        else\n        {\n            channelChangeState = CC_Idle;\n            DBG_Printf(DBG_INFO_L2, \"ChannelChangeState: CC_Idle\\n\");\n        }\n        break;\n\n    case CC_Change_Channel:\n        ccRetries++;\n        changeChannel(gwZigbeeChannel);\n        break;\n\n    case CC_ReconnectNetwork:\n        channelChangeReconnectNetwork();\n        break;\n\n    case CC_DisconnectingNetwork:\n        checkChannelChangeNetworkDisconnected();\n        break;\n\n    case CC_WaitConfirm:\n        DBG_Printf(DBG_INFO, \"channel change not successful.\\n\");\n        channelChangeState = CC_Idle;\n        break;\n\n    default:\n        DBG_Printf(DBG_INFO, \"channelChangeTimerFired() unhandled state %d\\n\", channelChangeState);\n        break;\n    }\n}\n"
        },
        {
          "name": "cj",
          "type": "tree",
          "content": null
        },
        {
          "name": "cloc_device.sh",
          "type": "blob",
          "size": 0.1806640625,
          "content": "#!/bin/bash\n\ncloc \\\n\tdevice.* \\\n\tdevice_access_fn.* \\\n\tdevice_compat.* \\\n\tdevice_ddf_init.* \\\n\tdevice_descriptions.* \\\n\tdevice_js/* \\\n\tzcl/* \\\n\tdevice_tick.* \\\n\tstate_change.* \\\n\tui/*\n\n"
        },
        {
          "name": "colorspace.cpp",
          "type": "blob",
          "size": 38.28125,
          "content": "/**\n * @file colorspace.c\n * @author Pascal Getreuer 2005-2010 <getreuer@gmail.com>\n *\n * == Summary ==\n * This file implements routines for color transformations between the spaces\n * sRGB, Y'UV, Y'CbCr, Y'PbPr, Y'DbDr, Y'IQ, HSV, HSL, HSI, CIEXYZ, CIELAB, \n * CIELUV, CIELCH, and CIECAT02 LMS.\n *\n * == Usage ==\n * First call GetColorTransform, specifying the source and destination color\n * spaces as \"dest<-src\" or \"src->dest\".  Then call ApplyColorTransform to\n * perform the transform:\n@code\n       num S[3] = {173, 0.8, 0.5};\n       num D[3];\n       colortransform Trans;\n       \n       if(!(GetColorTransform(&Trans, \"HSI -> Lab\")))\n       {\n           printf(\"Invalid syntax or unknown color space\\n\");\n           return;\n       }   \n       \n       ApplyColorTransform(Trans, &D[0], &D[1], &D[2], S[0], S[1], S[2]);\n@endcode\n * \"num\" is a typedef defined at the beginning of colorspace.h that may be set\n * to either double or float, depending on the application.\n *\n * Specific transformation routines can also be called directly.  The following\n * converts an sRGB color to CIELAB and then back to sRGB:\n@code\n     num R = 0.85, G = 0.32, B = 0.5;\n     num L, a, b;\n     Rgb2Lab(&L, &a, &b, R, G, B);\n     Lab2Rgb(&R, &G, &B, L, a, b);\n@endcode\n * Generally, the calling syntax is\n@code \n     Foo2Bar(&B0, &B1, &B2, F0, F1, F2);\n@endcode \n * where (F0,F1,F2) are the coordinates of a color in space \"Foo\" and\n * (B0,B1,B2) are the transformed coordinates in space \"Bar.\"  For any \n * transformation routine, its inverse has the sytax\n@code \n     Bar2Foo(&F0, &F1, &F2, B0, B1, B2);\n@endcode  \n *\n * The conversion routines are consistently named with the first letter of a\n * color space capitalized with following letters in lower case and omitting\n * prime symbols.  For example, \"Rgb2Ydbdr\" converts sRGB to Y'DbDr.  For\n * any transformation routine Foo2Bar, its inverse is Bar2Foo.\n *\n * All transformations assume a two degree observer angle and a D65 illuminant.\n * The white point can be changed by modifying the WHITEPOINT_X, WHITEPOINT_Y,  \n * WHITEPOINT_Z definitions at the beginning of colorspace.h.\n *\n * == List of transformation routines ==\n *   - Rgb2Yuv(num *Y, num *U, num *V, num R, num G, num B)\n *   - Rgb2Ycbcr(num *Y, num *Cb, num *Cr, num R, num G, num B)\n *   - Rgb2Jpegycbcr(num *Y, num *Cb, num *Cr, num R, num G, num B)\n *   - Rgb2Ypbpr(num *Y, num *Pb, num *Pr, num R, num G, num B)\n *   - Rgb2Ydbdr(num *Y, num *Db, num *Dr, num R, num G, num B)\n *   - Rgb2Yiq(num *Y, num *I, num *Q, num R, num G, num B)\n *   - Rgb2Hsv(num *H, num *S, num *V, num R, num G, num B)\n *   - Rgb2Hsl(num *H, num *S, num *L, num R, num G, num B)\n *   - Rgb2Hsi(num *H, num *S, num *I, num R, num G, num B)\n *   - Rgb2Xyz(num *X, num *Y, num *Z, num R, num G, num B)\n *   - Xyz2Lab(num *L, num *a, num *b, num X, num Y, num Z)\n *   - Xyz2Luv(num *L, num *u, num *v, num X, num Y, num Z)\n *   - Xyz2Lch(num *L, num *C, num *h, num X, num Y, num Z)\n *   - Xyz2Cat02lms(num *L, num *M, num *S, num X, num Y, num Z) \n *   - Rgb2Lab(num *L, num *a, num *b, num R, num G, num B)\n *   - Rgb2Luv(num *L, num *u, num *v, num R, num G, num B)\n *   - Rgb2Lch(num *L, num *C, num *h, num R, num G, num B)\n *   - Rgb2Cat02lms(num *L, num *M, num *S, num R, num G, num B) \n * (Similarly for the inverse transformations.)\n *\n * It is possible to transform between two arbitrary color spaces by first\n * transforming from the source space to sRGB and then transforming from\n * sRGB to the desired destination space.  For transformations between CIE\n * color spaces, it is convenient to use XYZ as the intermediate space.  This\n * is the strategy used by GetColorTransform and ApplyColorTransform. \n *\n * == References ==\n * The definitions of these spaces and the many of the transformation formulas\n * can be found in \n *\n *    Poynton, \"Frequently Asked Questions About Gamma\"\n *    http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html\n *\n *    Poynton, \"Frequently Asked Questions About Color\"\n *    http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html\n *\n * and Wikipedia articles\n *    http://en.wikipedia.org/wiki/SRGB\n *    http://en.wikipedia.org/wiki/YUV\n *    http://en.wikipedia.org/wiki/YCbCr\n *    http://en.wikipedia.org/wiki/YPbPr\n *    http://en.wikipedia.org/wiki/YDbDr\n *    http://en.wikipedia.org/wiki/YIQ\n *    http://en.wikipedia.org/wiki/HSL_and_HSV\n *    http://en.wikipedia.org/wiki/CIE_1931_color_space\n *    http://en.wikipedia.org/wiki/Lab_color_space\n *    http://en.wikipedia.org/wiki/CIELUV_color_space\n *    http://en.wikipedia.org/wiki/LMS_color_space\n *\n * == License (BSD) ==\n * Copyright (c) 2005-2010, Pascal Getreuer\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n * \n * - Redistributions of source code must retain the above copyright \n *   notice, this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright \n *   notice, this list of conditions and the following disclaimer in \n *   the documentation and/or other materials provided with the distribution.\n *       \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include \"colorspace.h\"\n\n#ifdef MATLAB_MEX_FILE\n#include \"mex.h\"\n#endif\n\n/** @brief Min of A and B */\n#define MIN(A,B)\t(((A) <= (B)) ? (A) : (B))\n\n/** @brief Max of A and B */\n#define MAX(A,B)\t(((A) >= (B)) ? (A) : (B))\n\n/** @brief Min of A, B, and C */\n#define MIN3(A,B,C)\t(((A) <= (B)) ? MIN(A,C) : MIN(B,C))\n\n/** @brief Max of A, B, and C */\n#define MAX3(A,B,C)\t(((A) >= (B)) ? MAX(A,C) : MAX(B,C))\n\n#ifndef M_PI\n/** @brief The constant pi */\n#define M_PI\t3.14159265358979323846264338327950288\n#endif\n\n/** \n * @brief sRGB gamma correction, transforms R to R'\n * http://en.wikipedia.org/wiki/SRGB\n */\n#define GAMMACORRECTION(t)\t\\\n\t(((t) <= 0.0031306684425005883) ? \\\n\t(12.92*(t)) : (1.055*pow((t), 0.416666666666666667) - 0.055))\n\n/** \n * @brief Inverse sRGB gamma correction, transforms R' to R \n */\n#define INVGAMMACORRECTION(t)\t\\\n\t(((t) <= 0.0404482362771076) ? \\\n\t((t)/12.92) : pow(((t) + 0.055)/1.055, 2.4))\n\n/** \n * @brief CIE L*a*b* f function (used to convert XYZ to L*a*b*)\n * http://en.wikipedia.org/wiki/Lab_color_space\n */\n#define LABF(t)\t\\\n\t((t >= 8.85645167903563082e-3) ? \\\n\tpow(t,0.333333333333333) : (841.0/108.0)*(t) + (4.0/29.0))\n\n/** \n * @brief CIE L*a*b* inverse f function \n * http://en.wikipedia.org/wiki/Lab_color_space\n */\n#define LABINVF(t)\t\\\n\t((t >= 0.206896551724137931) ? \\\n\t((t)*(t)*(t)) : (108.0/841.0)*((t) - (4.0/29.0)))\n\n/** @brief u'v' coordinates of the white point for CIE Lu*v* */\n#define WHITEPOINT_U\t((4*WHITEPOINT_X) \\\n\t/(WHITEPOINT_X + 15*WHITEPOINT_Y + 3*WHITEPOINT_Z))\n#define WHITEPOINT_V\t((9*WHITEPOINT_Y) \\\n\t/(WHITEPOINT_X + 15*WHITEPOINT_Y + 3*WHITEPOINT_Z))\n\n/** @brief Enumeration of the supported color spaces */\n#define UNKNOWN_SPACE\t0\n#define RGB_SPACE\t\t1\n#define YUV_SPACE\t\t2\n#define YCBCR_SPACE\t\t3\n#define JPEGYCBCR_SPACE\t4\n#define YPBPR_SPACE\t\t5\n#define YDBDR_SPACE\t\t6\n#define YIQ_SPACE\t\t7\n#define HSV_SPACE\t\t8\n#define HSL_SPACE\t\t9\n#define HSI_SPACE\t\t10\n#define XYZ_SPACE\t\t11\n#define LAB_SPACE\t\t12\n#define LUV_SPACE\t\t13\n#define LCH_SPACE\t\t14\n#define CAT02LMS_SPACE\t15\n\n#define NUM_TRANSFORM_PAIRS\t\t18\n\n\n/** @brief Table representing all transformations in this file */\nstatic const struct\n{\n\tint Space[2];\n\tvoid (*Fun[2])(num*, num*, num*, num, num, num);\n} TransformPair[NUM_TRANSFORM_PAIRS] = {\n\t{{RGB_SPACE, YUV_SPACE}, {Rgb2Yuv, Yuv2Rgb}},\n\t{{RGB_SPACE, YCBCR_SPACE}, {Rgb2Ycbcr, Ycbcr2Rgb}},\n\t{{RGB_SPACE, JPEGYCBCR_SPACE}, {Rgb2Jpegycbcr, Jpegycbcr2Rgb}},\n\t{{RGB_SPACE, YPBPR_SPACE}, {Rgb2Ypbpr, Ypbpr2Rgb}},\n\t{{RGB_SPACE, YDBDR_SPACE}, {Rgb2Ydbdr, Ydbdr2Rgb}},\n\t{{RGB_SPACE, YIQ_SPACE}, {Rgb2Yiq, Yiq2Rgb}},\n\t{{RGB_SPACE, HSV_SPACE}, {Rgb2Hsv, Hsv2Rgb}},\n\t{{RGB_SPACE, HSL_SPACE}, {Rgb2Hsl, Hsl2Rgb}},\n\t{{RGB_SPACE, HSI_SPACE}, {Rgb2Hsi, Hsi2Rgb}},\n\t{{RGB_SPACE, XYZ_SPACE}, {Rgb2Xyz, Xyz2Rgb}},\n\t{{XYZ_SPACE, LAB_SPACE}, {Xyz2Lab, Lab2Xyz}},\n\t{{XYZ_SPACE, LUV_SPACE}, {Xyz2Luv, Luv2Xyz}},\n\t{{XYZ_SPACE, LCH_SPACE}, {Xyz2Lch, Lch2Xyz}},\n\t{{XYZ_SPACE, CAT02LMS_SPACE}, {Xyz2Cat02lms, Cat02lms2Xyz}},\n\t{{RGB_SPACE, LAB_SPACE}, {Rgb2Lab, Lab2Rgb}},\n\t{{RGB_SPACE, LUV_SPACE}, {Rgb2Luv, Luv2Rgb}},\n\t{{RGB_SPACE, LCH_SPACE}, {Rgb2Lch, Lch2Rgb}},\n\t{{RGB_SPACE, CAT02LMS_SPACE}, {Rgb2Cat02lms, Cat02lms2Rgb}}\n\t};\n\n\n/*\n * == Linear color transformations ==\n * \n * The following routines implement transformations between sRGB and\n * the linearly-related color spaces Y'UV, Y'PbPr, Y'DbDr, and Y'IQ.\n */\n\n\n/**\n * @brief Convert sRGB to NTSC/PAL Y'UV Luma + Chroma\n *\n * @param Y, U, V pointers to hold the result\n * @param R, G, B the input sRGB values\n *\n * Wikipedia: http://en.wikipedia.org/wiki/YUV\n */\nvoid Rgb2Yuv(num *Y, num *U, num *V, num R, num G, num B)\n{\n\t*Y = (num)( 0.299*R + 0.587*G + 0.114*B);\n\t*U = (num)(-0.147*R - 0.289*G + 0.436*B);\n\t*V = (num)( 0.615*R - 0.515*G - 0.100*B);\n}\n\n\n/**\n * @brief Convert NTSC/PAL Y'UV to sRGB\n *\n * @param R, G, B pointers to hold the result\n * @param Y, U, V the input YUV values\n */\nvoid Yuv2Rgb(num *R, num *G, num *B, num Y, num U, num V)\n{\n\t*R = (num)(Y - 3.945707070708279e-05*U + 1.1398279671717170825*V);\n\t*G = (num)(Y - 0.3946101641414141437*U - 0.5805003156565656797*V);\n\t*B = (num)(Y + 2.0319996843434342537*U - 4.813762626262513e-04*V);\n}\n\n\n/** @brief sRGB to Y'CbCr Luma + Chroma */\nvoid Rgb2Ycbcr(num *Y, num *Cb, num *Cr, num R, num G, num B)\n{\n\t*Y  = (num)( 65.481*R + 128.553*G +  24.966*B +  16);\n\t*Cb = (num)(-37.797*R -  74.203*G + 112.0  *B + 128);\n\t*Cr = (num)(112.0  *R -  93.786*G -  18.214*B + 128);\n}\n\n\n/** @brief Y'CbCr to sRGB */\nvoid Ycbcr2Rgb(num *R, num *G, num *B, num Y, num Cr, num Cb)\n{\n\tY -= 16;\n\tCb -= 128;\n\tCr -= 128;\n\t*R = (num)(0.00456621004566210107*Y + 1.1808799897946415e-09*Cr + 0.00625892896994393634*Cb);\n\t*G = (num)(0.00456621004566210107*Y - 0.00153632368604490212*Cr - 0.00318811094965570701*Cb);\n\t*B = (num)(0.00456621004566210107*Y + 0.00791071623355474145*Cr + 1.1977497040190077e-08*Cb);\n}\n\n\n/** @brief sRGB to JPEG-Y'CbCr Luma + Chroma */\nvoid Rgb2Jpegycbcr(num *Y, num *Cb, num *Cr, num R, num G, num B)\n{\n\tRgb2Ypbpr(Y, Cb, Cr, R, G, B);\n\t*Cb += (num)0.5;\n\t*Cr += (num)0.5;\n}\n\n/** @brief JPEG-Y'CbCr to sRGB */\nvoid Jpegycbcr2Rgb(num *R, num *G, num *B, num Y, num Cb, num Cr)\n{\n\tCb -= (num)0.5;\n\tCr -= (num)0.5;\n\tYpbpr2Rgb(R, G, B, Y, Cb, Cr);\n}\n\n\n/** @brief sRGB to Y'PbPr Luma (ITU-R BT.601) + Chroma */\nvoid Rgb2Ypbpr(num *Y, num *Pb, num *Pr, num R, num G, num B)\n{\n\t*Y  = (num)( 0.299    *R + 0.587   *G + 0.114   *B);\n\t*Pb = (num)(-0.1687367*R - 0.331264*G + 0.5     *B);\n\t*Pr = (num)( 0.5      *R - 0.418688*G - 0.081312*B);\n}\n\n\n/** @brief Y'PbPr to sRGB */\nvoid Ypbpr2Rgb(num *R, num *G, num *B, num Y, num Pb, num Pr)\n{\n\t*R = (num)(0.99999999999914679361*Y - 1.2188941887145875e-06*Pb + 1.4019995886561440468*Pr);\n\t*G = (num)(0.99999975910502514331*Y - 0.34413567816504303521*Pb - 0.71413649331646789076*Pr);\n\t*B = (num)(1.00000124040004623180*Y + 1.77200006607230409200*Pb + 2.1453384174593273e-06*Pr);\n}\n\n\n/** @brief sRGB to SECAM Y'DbDr Luma + Chroma */\nvoid Rgb2Ydbdr(num *Y, num *Db, num *Dr, num R, num G, num B)\n{\n\t*Y  = (num)( 0.299*R + 0.587*G + 0.114*B);\n\t*Db = (num)(-0.450*R - 0.883*G + 1.333*B);\n\t*Dr = (num)(-1.333*R + 1.116*G + 0.217*B);\n}\n\n\n/** @brief SECAM Y'DbDr to sRGB */\nvoid Ydbdr2Rgb(num *R, num *G, num *B, num Y, num Db, num Dr)\n{\n\t*R = (num)(Y + 9.2303716147657e-05*Db - 0.52591263066186533*Dr);\n\t*G = (num)(Y - 0.12913289889050927*Db + 0.26789932820759876*Dr);\n\t*B = (num)(Y + 0.66467905997895482*Db - 7.9202543533108e-05*Dr);\n}\n\n\n/** @brief sRGB to NTSC YIQ */\nvoid Rgb2Yiq(num *Y, num *I, num *Q, num R, num G, num B)\n{\n\t*Y = (num)(0.299   *R + 0.587   *G + 0.114   *B);\n\t*I = (num)(0.595716*R - 0.274453*G - 0.321263*B);\n\t*Q = (num)(0.211456*R - 0.522591*G + 0.311135*B);\n}\n\n\n/** @brief Convert NTSC YIQ to sRGB */\nvoid Yiq2Rgb(num *R, num *G, num *B, num Y, num I, num Q)\n{\n\t*R = (num)(Y + 0.9562957197589482261*I + 0.6210244164652610754*Q);\n\t*G = (num)(Y - 0.2721220993185104464*I - 0.6473805968256950427*Q);\n\t*B = (num)(Y - 1.1069890167364901945*I + 1.7046149983646481374*Q);\n}\n\n\n\n/*\n * == Hue Saturation Value/Lightness/Intensity color transformations ==\n * \n * The following routines implement transformations between sRGB and\n * color spaces HSV, HSL, and HSI.\n */\n\n\n/** \n * @brief Convert an sRGB color to Hue-Saturation-Value (HSV)\n * \n * @param H, S, V pointers to hold the result\n * @param R, G, B the input sRGB values scaled in [0,1]\n *\n * This routine transforms from sRGB to the hexcone HSV color space.  The\n * sRGB values are assumed to be between 0 and 1.  The output values are\n *   H = hexagonal hue angle   (0 <= H < 360),\n *   S = C/V                   (0 <= S <= 1),\n *   V = max(R',G',B')         (0 <= V <= 1),\n * where C = max(R',G',B') - min(R',G',B').  The inverse color transformation\n * is given by Hsv2Rgb.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Rgb2Hsv(num *H, num *S, num *V, num R, num G, num B)\n{\n\tnum Max = MAX3(R, G, B);\n\tnum Min = MIN3(R, G, B);\n\tnum C = Max - Min;\n\t\n\t\n\t*V = Max;\n\t\n\tif(C > 0)\n\t{\n\t\tif(Max == R)\n\t\t{\n\t\t\t*H = (G - B) / C;\n\t\t\t\n\t\t\tif(G < B)\n\t\t\t\t*H += 6;\n\t\t}\n\t\telse if(Max == G)\n\t\t\t*H = 2 + (B - R) / C;\n\t\telse\n\t\t\t*H = 4 + (R - G) / C;\n\t\t\n\t\t*H *= 60;\n\t\t*S = C / Max;\n\t}\n\telse\n\t\t*H = *S = 0;\n}\n\n\n/** \n * @brief Convert a Hue-Saturation-Value (HSV) color to sRGB\n * \n * @param R, G, B pointers to hold the result\n * @param H, S, V the input HSV values\n *\n * The input values are assumed to be scaled as \n *    0 <= H < 360,\n *    0 <= S <= 1,\n *    0 <= V <= 1. \n * The output sRGB values are scaled between 0 and 1.  This is the inverse\n * transformation of Rgb2Hsv.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Hsv2Rgb(num *R, num *G, num *B, num H, num S, num V)\n{\n\tnum C = S * V;\n\tnum Min = V - C;\n\tnum X;\n\t\n\t\n\tH -= 360*floor(H/360);\n\tH /= 60;\n\tX = C*(1 - fabs(H - 2*floor(H/2) - 1));\n\t\n\tswitch((int)H)\n\t{\n\tcase 0:\n\t\t*R = Min + C;\n\t\t*G = Min + X;\n\t\t*B = Min;\n\t\tbreak;\n\tcase 1:\n\t\t*R = Min + X;\n\t\t*G = Min + C;\n\t\t*B = Min;\n\t\tbreak;\n\tcase 2:\n\t\t*R = Min;\n\t\t*G = Min + C;\n\t\t*B = Min + X;\n\t\tbreak;\n\tcase 3:\n\t\t*R = Min;\n\t\t*G = Min + X;\n\t\t*B = Min + C;\n\t\tbreak;\n\tcase 4:\n\t\t*R = Min + X;\n\t\t*G = Min;\n\t\t*B = Min + C;\n\t\tbreak;\n\tcase 5:\n\t\t*R = Min + C;\n\t\t*G = Min;\n\t\t*B = Min + X;\n\t\tbreak;\n\tdefault:\n\t\t*R = *G = *B = 0;\n\t}\n}\n\n\n/** \n * @brief Convert an sRGB color to Hue-Saturation-Lightness (HSL)\n * \n * @param H, S, L pointers to hold the result\n * @param R, G, B the input sRGB values scaled in [0,1]\n *\n * This routine transforms from sRGB to the double hexcone HSL color space\n * The sRGB values are assumed to be between 0 and 1.  The outputs are\n *   H = hexagonal hue angle                (0 <= H < 360),\n *   S = { C/(2L)     if L <= 1/2           (0 <= S <= 1),\n *       { C/(2 - 2L) if L >  1/2\n *   L = (max(R',G',B') + min(R',G',B'))/2  (0 <= L <= 1),\n * where C = max(R',G',B') - min(R',G',B').  The inverse color transformation\n * is given by Hsl2Rgb.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Rgb2Hsl(num *H, num *S, num *L, num R, num G, num B)\n{\n\tnum Max = MAX3(R, G, B);\n\tnum Min = MIN3(R, G, B);\n\tnum C = Max - Min;\n\t\n\t\n\t*L = (Max + Min)/2;\n\t\n\tif(C > 0)\n\t{\n\t\tif(Max == R)\n\t\t{\n\t\t\t*H = (G - B) / C;\n\t\t\t\n\t\t\tif(G < B)\n\t\t\t\t*H += 6;\n\t\t}\n\t\telse if(Max == G)\n\t\t\t*H = 2 + (B - R) / C;\n\t\telse\n\t\t\t*H = 4 + (R - G) / C;\n\t\t\n\t\t*H *= 60;\n\t\t*S = (*L <= 0.5) ? (C/(2*(*L))) : (C/(2 - 2*(*L)));\n\t}\n\telse\n\t\t*H = *S = 0;\n}\n\n\n/** \n * @brief Convert a Hue-Saturation-Lightness (HSL) color to sRGB\n * \n * @param R, G, B pointers to hold the result\n * @param H, S, L the input HSL values\n *\n * The input values are assumed to be scaled as \n *    0 <= H < 360,\n *    0 <= S <= 1,\n *    0 <= L <= 1. \n * The output sRGB values are scaled between 0 and 1.  This is the inverse\n * transformation of Rgb2Hsl.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Hsl2Rgb(num *R, num *G, num *B, num H, num S, num L)\n{\n\tnum C = (L <= 0.5) ? (2*L*S) : ((2 - 2*L)*S);\n\tnum Min = L - 0.5*C;\n\tnum X;\n\t\n\t\n\tH -= 360*floor(H/360);\n\tH /= 60;\n\tX = C*(1 - fabs(H - 2*floor(H/2) - 1));\n\t\n\tswitch((int)H)\n\t{\n\tcase 0:\n\t\t*R = Min + C;\n\t\t*G = Min + X;\n\t\t*B = Min;\n\t\tbreak;\n\tcase 1:\n\t\t*R = Min + X;\n\t\t*G = Min + C;\n\t\t*B = Min;\n\t\tbreak;\n\tcase 2:\n\t\t*R = Min;\n\t\t*G = Min + C;\n\t\t*B = Min + X;\n\t\tbreak;\n\tcase 3:\n\t\t*R = Min;\n\t\t*G = Min + X;\n\t\t*B = Min + C;\n\t\tbreak;\n\tcase 4:\n\t\t*R = Min + X;\n\t\t*G = Min;\n\t\t*B = Min + C;\n\t\tbreak;\n\tcase 5:\n\t\t*R = Min + C;\n\t\t*G = Min;\n\t\t*B = Min + X;\n\t\tbreak;\n\tdefault:\n\t\t*R = *G = *B = 0;\n\t}\n}\n\n\n/** \n * @brief Convert an sRGB color to Hue-Saturation-Intensity (HSI)\n * \n * @param H, S, I pointers to hold the result\n * @param R, G, B the input sRGB values scaled in [0,1]\n *\n * This routine transforms from sRGB to the cylindrical HSI color space.  The\n * sRGB values are assumed to be between 0 and 1.  The output values are\n *   H = polar hue angle         (0 <= H < 360),\n *   S = 1 - min(R',G',B')/I     (0 <= S <= 1),\n *   I = (R'+G'+B')/3            (0 <= I <= 1).\n * The inverse color transformation is given by Hsi2Rgb.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Rgb2Hsi(num *H, num *S, num *I, num R, num G, num B)\n{\n\tnum alpha = 0.5*(2*R - G - B);\n\tnum beta = 0.866025403784439*(G - B);\n\t\n\t\n\t*I = (R + G + B)/3;\n\t\n\tif(*I > 0)\n\t{\n\t\t*S = 1 - MIN3(R,G,B) / *I;\n\t\t*H = atan2(beta, alpha)*(180/M_PI);\n\t\t\n\t\tif(*H < 0)\n\t\t\t*H += 360;\n\t}\n\telse\n\t\t*H = *S = 0;\n}\n\n\n/** \n * @brief Convert a Hue-Saturation-Intesity (HSI) color to sRGB\n * \n * @param R, G, B pointers to hold the result\n * @param H, S, I the input HSI values\n *\n * The input values are assumed to be scaled as \n *    0 <= H < 360,\n *    0 <= S <= 1,\n *    0 <= I <= 1. \n * The output sRGB values are scaled between 0 and 1.  This is the inverse\n * transformation of Rgb2Hsi.\n *\n * Wikipedia: http://en.wikipedia.org/wiki/HSL_and_HSV\n */\nvoid Hsi2Rgb(num *R, num *G, num *B, num H, num S, num I)\n{\n\tH -= 360*floor(H/360);\n\t\n\tif(H < 120)\n\t{\n\t\t*B = I*(1 - S);\n\t\t*R = I*(1 + S*cos(H*(M_PI/180))/cos((60 - H)*(M_PI/180)));\n\t\t*G = 3*I - *R - *B;\n\t}\n\telse if(H < 240)\n\t{\n\t\tH -= 120;\n\t\t*R = I*(1 - S);\n\t\t*G = I*(1 + S*cos(H*(M_PI/180))/cos((60 - H)*(M_PI/180)));\n\t\t*B = 3*I - *R - *G;\n\t}\n\telse\n\t{\n\t\tH -= 240;\n\t\t*G = I*(1 - S);\n\t\t*B = I*(1 + S*cos(H*(M_PI/180))/cos((60 - H)*(M_PI/180)));\n\t\t*R = 3*I - *G - *B;\n\t}\n}\n\n\n/*\n * == CIE color transformations ==\n * \n * The following routines implement transformations between sRGB and\n * the CIE color spaces XYZ, L*a*b, L*u*v*, and L*C*H*.  These \n * transforms assume a 2 degree observer angle and a D65 illuminant.\n */\n\n\n/**\n * @brief Transform sRGB to CIE XYZ with the D65 white point\n *\n * @param X, Y, Z pointers to hold the result\n * @param R, G, B the input sRGB values\n *\n * Poynton, \"Frequently Asked Questions About Color,\" page 10 \n * Wikipedia: http://en.wikipedia.org/wiki/SRGB\n * Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\n */\nvoid Rgb2Xyz(num *X, num *Y, num *Z, num R, num G, num B)\n{\n\tR = INVGAMMACORRECTION(R);\n\tG = INVGAMMACORRECTION(G);\n\tB = INVGAMMACORRECTION(B);\n\t*X = (num)(0.4123955889674142161*R + 0.3575834307637148171*G + 0.1804926473817015735*B);\n\t*Y = (num)(0.2125862307855955516*R + 0.7151703037034108499*G + 0.07220049864333622685*B);\n\t*Z = (num)(0.01929721549174694484*R + 0.1191838645808485318*G + 0.9504971251315797660*B);\n}\n\n/**\n * @brief Transform sRGB to xy\n *\n * @param X, Y pointers to hold the result\n * @param R, G, B the input sRGB values\n */\nvoid Rgb2xy(num *x, num *y, num R, num G, num B)\n{\n    R = INVGAMMACORRECTION(R);\n    G = INVGAMMACORRECTION(G);\n    B = INVGAMMACORRECTION(B);\n    num X = (num)(0.4123955889674142161*R + 0.3575834307637148171*G + 0.1804926473817015735*B);\n    num Y = (num)(0.2125862307855955516*R + 0.7151703037034108499*G + 0.07220049864333622685*B);\n    num Z = (num)(0.01929721549174694484*R + 0.1191838645808485318*G + 0.9504971251315797660*B);\n    *x = X / (X + Y + Z);\n    *y = Y / (X + Y + Z);\n\n}\n\n/**\n * @brief Transform CIE XYZ to sRGB with the D65 white point\n *\n * @param R, G, B pointers to hold the result\n * @param X, Y, Z the input XYZ values\n *\n * Official sRGB specification (IEC 61966-2-1:1999)\n * Poynton, \"Frequently Asked Questions About Color,\" page 10\n * Wikipedia: http://en.wikipedia.org/wiki/SRGB\n * Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\n */\nvoid Xyz2Rgb(num *R, num *G, num *B, num X, num Y, num Z)\n{\t\n\tnum R1, B1, G1, Min;\n\t\n\t\n\tR1 = (num)( 3.2406*X - 1.5372*Y - 0.4986*Z);\n\tG1 = (num)(-0.9689*X + 1.8758*Y + 0.0415*Z);\n\tB1 = (num)( 0.0557*X - 0.2040*Y + 1.0570*Z);\n\t\n\tMin = MIN3(R1, G1, B1);\n\t\n\t/* Force nonnegative values so that gamma correction is well-defined. */\n\tif(Min < 0)\n\t{\n\t\tR1 -= Min;\n\t\tG1 -= Min;\n\t\tB1 -= Min;\n\t}\n\n\t/* Transform from RGB to R'G'B' */\n\t*R = GAMMACORRECTION(R1);\n\t*G = GAMMACORRECTION(G1);\n\t*B = GAMMACORRECTION(B1);\n}\n\n\n/**\n * Convert CIE XYZ to CIE L*a*b* (CIELAB) with the D65 white point\n *\n * @param L, a, b pointers to hold the result\n * @param X, Y, Z the input XYZ values\n *\n * Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space\n */\nvoid Xyz2Lab(num *L, num *a, num *b, num X, num Y, num Z)\n{\n\tX /= WHITEPOINT_X;\n\tY /= WHITEPOINT_Y;\n\tZ /= WHITEPOINT_Z;\n\tX = LABF(X);\n\tY = LABF(Y);\n\tZ = LABF(Z);\n\t*L = 116*Y - 16;\n\t*a = 500*(X - Y);\n\t*b = 200*(Y - Z);\n}\n\n\n/**\n * Convert CIE L*a*b* (CIELAB) to CIE XYZ with the D65 white point\n *\n * @param X, Y, Z pointers to hold the result\n * @param L, a, b the input L*a*b* values\n *\n * Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space \n */\nvoid Lab2Xyz(num *X, num *Y, num *Z, num L, num a, num b)\n{\n\tL = (L + 16)/116;\n\ta = L + a/500;\n\tb = L - b/200;\n\t*X = WHITEPOINT_X*LABINVF(a);\n\t*Y = WHITEPOINT_Y*LABINVF(L);\n\t*Z = WHITEPOINT_Z*LABINVF(b);\n}\n\n\n/**\n * Convert CIE XYZ to CIE L*u*v* (CIELUV) with the D65 white point\n *\n * @param L, u, v pointers to hold the result\n * @param X, Y, Z the input XYZ values\n *\n * Wikipedia: http://en.wikipedia.org/wiki/CIELUV_color_space\n */\nvoid Xyz2Luv(num *L, num *u, num *v, num X, num Y, num Z)\n{\t\n\tnum u1, v1, Denom;\n\t\n\n\tif((Denom = X + 15*Y + 3*Z) > 0)\n\t{\n\t\tu1 = (4*X) / Denom;\n\t\tv1 = (9*Y) / Denom;\n\t}\n\telse\n\t\tu1 = v1 = 0;\n\n\tY /= WHITEPOINT_Y;\n\tY = LABF(Y);\n\t*L = 116*Y - 16;\n\t*u = 13*(*L)*(u1 - WHITEPOINT_U);\n\t*v = 13*(*L)*(v1 - WHITEPOINT_V);\n}\n\n\n/**\n * Convert CIE L*u*v* (CIELUV) to CIE XYZ with the D65 white point\n *\n * @param X, Y, Z pointers to hold the result\n * @param L, u, v the input L*u*v* values\n *\n * Wikipedia: http://en.wikipedia.org/wiki/CIELUV_color_space\n */\nvoid Luv2Xyz(num *X, num *Y, num *Z, num L, num u, num v)\n{\n\t*Y = (L + 16)/116;\n\t*Y = WHITEPOINT_Y*LABINVF(*Y);\n\t\n\tif(L != 0)\n\t{\n\t\tu /= L;\n\t\tv /= L;\n\t}\n\t\n\tu = u/13 + WHITEPOINT_U;\n\tv = v/13 + WHITEPOINT_V;\n\t*X = (*Y) * ((9*u)/(4*v));\n\t*Z = (*Y) * ((3 - 0.75*u)/v - 5);\n}\n\n\n/**\n * Convert CIE XYZ to CIE L*C*H* with the D65 white point\n *\n * @param L, C, H pointers to hold the result\n * @param X, Y, Z the input XYZ values\n *\n * CIE L*C*H* is related to CIE L*a*b* by\n *    a* = C* cos(H* pi/180),\n *    b* = C* sin(H* pi/180).\n */\nvoid Xyz2Lch(num *L, num *C, num *H, num X, num Y, num Z)\n{\n\tnum a, b;\n\t\n\t\n\tXyz2Lab(L, &a, &b, X, Y, Z);\n\t*C = sqrt(a*a + b*b);\n\t*H = atan2(b, a)*180.0/M_PI;\n\t\n\tif(*H < 0)\n\t\t*H += 360;\n}\n\n/**\n * Convert CIE L*C*H* to CIE XYZ with the D65 white point\n *\n * @param X, Y, Z pointers to hold the result\n * @param L, C, H the input L*C*H* values\n */\nvoid Lch2Xyz(num *X, num *Y, num *Z, num L, num C, num H)\n{\n\tnum a = C * cos(H*(M_PI/180.0));\n\tnum b = C * sin(H*(M_PI/180.0));\n\t\n\t\n\tLab2Xyz(X, Y, Z, L, a, b);\n}\n\n\n/** @brief XYZ to CAT02 LMS */\nvoid Xyz2Cat02lms(num *L, num *M, num *S, num X, num Y, num Z)\n{\n\t*L = (num)( 0.7328*X + 0.4296*Y - 0.1624*Z);\n\t*M = (num)(-0.7036*X + 1.6975*Y + 0.0061*Z);\n\t*S = (num)( 0.0030*X + 0.0136*Y + 0.9834*Z);\n}\n\n\n/** @brief CAT02 LMS to XYZ */\nvoid Cat02lms2Xyz(num *X, num *Y, num *Z, num L, num M, num S)\n{\n\t*X = (num)( 1.096123820835514*L - 0.278869000218287*M + 0.182745179382773*S);\n\t*Y = (num)( 0.454369041975359*L + 0.473533154307412*M + 0.072097803717229*S);\n\t*Z = (num)(-0.009627608738429*L - 0.005698031216113*M + 1.015325639954543*S);\n}\n\n\n/* \n * == Glue functions for multi-stage transforms ==\n */\n\nvoid Rgb2Lab(num *L, num *a, num *b, num R, num G, num B)\n{\n\tnum X, Y, Z;\n\tRgb2Xyz(&X, &Y, &Z, R, G, B);\n\tXyz2Lab(L, a, b, X, Y, Z);\n}\n\n\nvoid Lab2Rgb(num *R, num *G, num *B, num L, num a, num b)\n{\n\tnum X, Y, Z;\n\tLab2Xyz(&X, &Y, &Z, L, a, b);\n\tXyz2Rgb(R, G, B, X, Y, Z);\n}\n\n\nvoid Rgb2Luv(num *L, num *u, num *v, num R, num G, num B)\n{\n\tnum X, Y, Z;\n\tRgb2Xyz(&X, &Y, &Z, R, G, B);\n\tXyz2Luv(L, u, v, X, Y, Z);\n}\n\n\nvoid Luv2Rgb(num *R, num *G, num *B, num L, num u, num v)\n{\n\tnum X, Y, Z;\n\tLuv2Xyz(&X, &Y, &Z, L, u, v);\n\tXyz2Rgb(R, G, B, X, Y, Z);\n}\n\nvoid Rgb2Lch(num *L, num *C, num *H, num R, num G, num B)\n{\n\tnum X, Y, Z;\n\tRgb2Xyz(&X, &Y, &Z, R, G, B);\n\tXyz2Lch(L, C, H, X, Y, Z);\n}\n\n\nvoid Lch2Rgb(num *R, num *G, num *B, num L, num C, num H)\n{\n\tnum X, Y, Z;\n\tLch2Xyz(&X, &Y, &Z, L, C, H);\n\tXyz2Rgb(R, G, B, X, Y, Z);\n}\n\n\nvoid Rgb2Cat02lms(num *L, num *M, num *S, num R, num G, num B)\n{\n\tnum X, Y, Z;\n\tRgb2Xyz(&X, &Y, &Z, R, G, B);\n\tXyz2Cat02lms(L, M, S, X, Y, Z);\n}\n\n\nvoid Cat02lms2Rgb(num *R, num *G, num *B, num L, num M, num S)\n{\n\tnum X, Y, Z;\n\tCat02lms2Xyz(&X, &Y, &Z, L, M, S);\n\tXyz2Rgb(R, G, B, X, Y, Z);\n}\n\n\n\n/* \n * == Interface Code ==\n * The following is to define a function GetColorTransform with a convenient\n * string-based interface.\n */\n\n/** @brief Convert a color space name to an integer ID */\nstatic int IdFromName(const char *Name)\n{\n\tif(!strcmp(Name, \"rgb\") || *Name == 0)\n\t\treturn RGB_SPACE;\n\telse if(!strcmp(Name, \"yuv\"))\n\t\treturn YUV_SPACE;\n\telse if(!strcmp(Name, \"ycbcr\"))\n\t\treturn YCBCR_SPACE;\n\telse if(!strcmp(Name, \"jpegycbcr\"))\n\t\treturn YCBCR_SPACE;\n\telse if(!strcmp(Name, \"ypbpr\"))\n\t\treturn YPBPR_SPACE;\n\telse if(!strcmp(Name, \"ydbdr\"))\n\t\treturn YDBDR_SPACE;\n\telse if(!strcmp(Name, \"yiq\"))\n\t\treturn YIQ_SPACE;\n\telse if(!strcmp(Name, \"hsv\") || !strcmp(Name, \"hsb\"))\n\t\treturn HSV_SPACE;\n\telse if(!strcmp(Name, \"hsl\") || !strcmp(Name, \"hls\"))\n\t\treturn HSL_SPACE;\n\telse if(!strcmp(Name, \"hsi\"))\n\t\treturn HSI_SPACE;\n\telse if(!strcmp(Name, \"xyz\") || !strcmp(Name, \"ciexyz\"))\n\t\treturn XYZ_SPACE;\n\telse if(!strcmp(Name, \"lab\") || !strcmp(Name, \"cielab\"))\n\t\treturn LAB_SPACE;\n\telse if(!strcmp(Name, \"luv\") || !strcmp(Name, \"cieluv\"))\n\t\treturn LUV_SPACE;\n\telse if(!strcmp(Name, \"lch\") || !strcmp(Name, \"cielch\"))\n\t\treturn LCH_SPACE;\n\telse if(!strcmp(Name, \"cat02lms\") || !strcmp(Name, \"ciecat02lms\"))\n\t\treturn CAT02LMS_SPACE;\n\telse\n\t\treturn UNKNOWN_SPACE;\n}\n\n\n/**\n * @brief Given a transform string, returns a colortransform struct\n *\n * @param Trans a colortransform pointer to hold the transform\n * @param TransformString string specifying the transformations\n * @return 1 on success, 0 on failure\n * \n * This function provides a convenient interface to the collection of transform\n * functions in this file.  TransformString specifies the source and \n * destination color spaces, \n *    TransformString = \"dest<-src\" \n * or alternatively,\n *    TransformString = \"src->dest\".\n *\n * Supported color spaces are\n *    \"RGB\"             sRGB Red Green Blue (ITU-R BT.709 gamma-corrected),\n *    \"YPbPr\"           Luma (ITU-R BT.601) + Chroma,\n *    \"YCbCr\"           Luma + Chroma (\"digitized\" version of Y'PbPr),\n *    \"JPEG-YCbCr\"      Luma + Chroma space used in JFIF JPEG,\n *    \"YUV\"             NTSC PAL Y'UV Luma + Chroma,\n *    \"YIQ\"             NTSC Y'IQ Luma + Chroma,\n *    \"YDbDr\"           SECAM Y'DbDr Luma + Chroma,\n *    \"HSV\" or \"HSB\"    Hue Saturation Value/Brightness,\n *    \"HSL\" or \"HLS\"    Hue Saturation Luminance,\n *    \"HSI\"             Hue Saturation Intensity,\n *    \"XYZ\"             CIE XYZ,\n *    \"Lab\"             CIE L*a*b* (CIELAB),\n *    \"Luv\"             CIE L*u*v* (CIELUV),\n *    \"LCH\"             CIE L*C*H* (CIELCH),\n *    \"CAT02 LMS\"       CIE CAT02 LMS.\n * Color space names are case-insensitive and spaces are ignored.  When sRGB\n * is the source or destination, it can be omitted.  For example \"yuv<-\" is \n * short for \"yuv<-rgb\".\n *\n * The routine returns a colortransform structure representing the transform.\n * The transform is performed by calling GetColorTransform.  For example,\n@code\n       num S[3] = {173, 0.8, 0.5};\n       num D[3];\n       colortransform Trans;\n       \n       if(!(GetColorTransform(&Trans, \"HSI -> Lab\")))\n       {\n           printf(\"Invalid syntax or unknown color space\\n\");\n           return;\n       }   \n       \n       ApplyColorTransform(Trans, &D[0], &D[1], &D[2], S[0], S[1], S[2]);\n@endcode\n */\nint GetColorTransform(colortransform *Trans, const char *TransformString)\n{\n\tint LeftNumChars = 0, RightNumChars = 0, LeftSide = 1, LeftToRight = 0;\n\tint i, j, SrcSpaceId, DestSpaceId;\n\tchar LeftSpace[16], RightSpace[16], c;\n\t\n\t\n\tTrans->NumStages = 0;\n\tTrans->Fun[0] = 0;\n\tTrans->Fun[1] = 0;\n\t\n\t/* Parse the transform string */\n\twhile(1)\n\t{\n\t\tc = *(TransformString++);\t/* Read the next character */\n\t\t\n\t\tif(!c)\n\t\t\tbreak;\n\t\telse if(c == '<')\n\t\t{\n\t\t\tLeftToRight = 0;\n\t\t\tLeftSide = 0;\n\t\t}\n\t\telse if(c == '>')\n\t\t{\n\t\t\tLeftToRight = 1;\n\t\t\tLeftSide = 0;\n\t\t}\n\t\telse if(c != ' ' && c != '-' && c != '=')\n\t\t{\n\t\t\tif(LeftSide)\n\t\t\t{\t/* Append the character to LeftSpace */\n\t\t\t\tif(LeftNumChars < 15)\n\t\t\t\t\tLeftSpace[LeftNumChars++] = tolower(c);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t/* Append the character to RightSpace */\n\t\t\t\tif(RightNumChars < 15)\n\t\t\t\t\tRightSpace[RightNumChars++] = tolower(c);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* Append null terminators on the LeftSpace and RightSpace strings */\n\tLeftSpace[LeftNumChars] = 0;\n\tRightSpace[RightNumChars] = 0;\n\t\n\t/* Convert names to colorspace enum */\n\tif(LeftToRight)\n\t{\n\t\tSrcSpaceId = IdFromName(LeftSpace);\n\t\tDestSpaceId = IdFromName(RightSpace);\n\t}\n\telse\n\t{\n\t\tSrcSpaceId = IdFromName(RightSpace);\n\t\tDestSpaceId = IdFromName(LeftSpace);\n\t}\n\t\n\t/* Is either space is unknown? (probably a parsing error) */\n\tif(SrcSpaceId == UNKNOWN_SPACE || DestSpaceId == UNKNOWN_SPACE)\n\t\treturn 0;\t/* Return failure */\n\t\n\t/* Is this an identity transform? */\n\tif(SrcSpaceId == DestSpaceId)\n\t\treturn 1;\t/* Return successfully */\n\t\n\t/* Search the TransformPair table for a direct transformation */\n\tfor(i = 0; i < NUM_TRANSFORM_PAIRS; i++)\n\t{\n\t\tif(SrcSpaceId == TransformPair[i].Space[0] \n\t\t\t&& DestSpaceId == TransformPair[i].Space[1])\n\t\t{\n\t\t\tTrans->NumStages = 1;\n\t\t\tTrans->Fun[0] = TransformPair[i].Fun[0];\n\t\t\treturn 1;\n\t\t}\n\t\telse if(DestSpaceId == TransformPair[i].Space[0] \n\t\t\t&& SrcSpaceId == TransformPair[i].Space[1])\n\t\t{\n\t\t\tTrans->NumStages = 1;\n\t\t\tTrans->Fun[0] = TransformPair[i].Fun[1];\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\t/* Search the TransformPair table for a two-stage transformation */\n\tfor(i = 1; i < NUM_TRANSFORM_PAIRS; i++)\n\t\tif(SrcSpaceId == TransformPair[i].Space[1])\n\t\t\tfor(j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif(DestSpaceId == TransformPair[j].Space[1]\n\t\t\t\t\t&& TransformPair[i].Space[0] == TransformPair[j].Space[0])\n\t\t\t\t{\n\t\t\t\t\tTrans->NumStages = 2;\n\t\t\t\t\tTrans->Fun[0] = TransformPair[i].Fun[1];\n\t\t\t\t\tTrans->Fun[1] = TransformPair[j].Fun[0];\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\telse if(DestSpaceId == TransformPair[i].Space[1])\n\t\t\tfor(j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif(SrcSpaceId == TransformPair[j].Space[1]\n\t\t\t\t\t&& TransformPair[j].Space[0] == TransformPair[i].Space[0])\n\t\t\t\t{\n\t\t\t\t\tTrans->NumStages = 2;\n\t\t\t\t\tTrans->Fun[0] = TransformPair[j].Fun[1];\n\t\t\t\t\tTrans->Fun[1] = TransformPair[i].Fun[0];\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\n\treturn 0;\n}\n\n\n/**\n * @brief Apply a colortransform \n *\n * @param Trans colortransform struct created by GetColorTransform\n * @param D0, D1, D2 pointers to hold the result\n * @param S0, S1, S2 the input values\n */\nvoid ApplyColorTransform(colortransform Trans, \n\tnum *D0, num *D1, num *D2, num S0, num S1, num S2)\n{\n\tswitch(Trans.NumStages)\n\t{\n\tcase 1:\n\t\tTrans.Fun[0](D0, D1, D2, S0, S1, S2);\n\t\tbreak;\n\tcase 2:\n\t\t{\n\t\t\tnum T0, T1, T2;\n\t\t\tTrans.Fun[0](&T0, &T1, &T2, S0, S1, S2);\n\t\t\tTrans.Fun[1](D0, D1, D2, T0, T1, T2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*D0 = S0;\n\t\t*D1 = S1;\n\t\t*D2 = S2;\n\t\tbreak;\n\t}\n}\n\n\n/* The code below allows this file to be compiled as a MATLAB MEX function.  \n * From MATLAB, the calling syntax is\n *    B = colorspace('dest<-src', A);\n * See colorspace.m for details.\n */\n#ifdef MATLAB_MEX_FILE\n/** @brief MEX gateway */\nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray*prhs[])\n{ \n    #define\tS_IN\t     prhs[0]\n    #define\tA_IN\t     prhs[1]\n    #define\tB_OUT\t     plhs[0]\n#define IS_REAL_FULL_DOUBLE(P) (!mxIsComplex(P) \\\n&& !mxIsSparse(P) && mxIsDouble(P))\n\tnum *A, *B;\n\tchar *SBuf;\n\tconst int *Size;\n\tcolortransform Trans;\n\tint SBufLen, NumPixels, Channel, Channel2;\n    \n\t   \n    /* Parse the input arguments */\n    if(nrhs != 2)\n        mexErrMsgTxt(\"Two input arguments required.\");\n    else if(nlhs > 1)\n        mexErrMsgTxt(\"Too many output arguments.\");\n    \n\tif(!mxIsChar(S_IN))\n\t\tmexErrMsgTxt(\"First argument should be a string.\");\n    if(!IS_REAL_FULL_DOUBLE(A_IN))\n        mexErrMsgTxt(\"Second argument should be a real full double array.\");\n\t\n\tSize = mxGetDimensions(A_IN);\n\t\n\tif(mxGetNumberOfDimensions(A_IN) > 3 \n\t\t|| Size[mxGetNumberOfDimensions(A_IN) - 1] != 3)\n\t\tmexErrMsgTxt(\"Second argument should be an Mx3 or MxNx3 array.\");\n\t\n\t/* Read the color transform from S */\n\tSBufLen = mxGetNumberOfElements(S_IN)*sizeof(mxChar) + 1;\n\tSBuf = mxMalloc(SBufLen);\n\tmxGetString(S_IN, SBuf, SBufLen);\n\t\n\tif(!(GetColorTransform(&Trans, SBuf)))\n\t\tmexErrMsgTxt(\"Invalid syntax or unknown color space.\");\n\t\n\tmxFree(SBuf);\n\t\n\tA = (num *)mxGetData(A_IN);\n\tNumPixels = mxGetNumberOfElements(A_IN)/3;\n\t\n\t/* Create the output image */ \n\tB_OUT = mxCreateDoubleMatrix(0, 0, mxREAL); \n\tmxSetDimensions(B_OUT, Size, mxGetNumberOfDimensions(A_IN));\n\tmxSetData(B_OUT, B = mxMalloc(sizeof(num)*mxGetNumberOfElements(A_IN)));\n\t\n\tChannel = NumPixels;\n\tChannel2 = NumPixels*2;\n\t\n\t/* Apply the color transform */\n\twhile(NumPixels--)\n\t{\n\t\tApplyColorTransform(Trans, B, B + Channel, B + Channel2,\n\t\t\tA[0], A[Channel], A[Channel2]);\n\t\tA++;\n\t\tB++;\n\t}\n\n    return;\n}\n#endif\n\n#define TEMPERATURE_TO_X_TEMPERATURE_TRESHOLD           4000\n\n#define TEMPERATURE_TO_Y_FIRST_TEMPERATURE_TRESHOLD     2222\n#define TEMPERATURE_TO_Y_SECOND_TEMPERATURE_TRESHOLD    4000\n\n#define TEMPERATURE_TO_X_FIRST_FACTOR_FIRST_EQUATION    17440695910400\n#define TEMPERATURE_TO_X_SECOND_FACTOR_FIRST_EQUATION   15358885888\n#define TEMPERATURE_TO_X_THIRD_FACTOR_FIRST_EQUATION    57520658\n#define TEMPERATURE_TO_X_FOURTH_FACTOR_FIRST_EQUATION   11790\n\n#define TEMPERATURE_TO_X_FIRST_FACTOR_SECOND_EQUATION   198301902438400\n#define TEMPERATURE_TO_X_SECOND_FACTOR_SECOND_EQUATION  138086835814\n#define TEMPERATURE_TO_X_THIRD_FACTOR_SECOND_EQUATION   14590587\n#define TEMPERATURE_TO_X_FOURTH_FACTOR_SECOND_EQUATION  15754\n\n#define TEMPERATURE_TO_Y_FIRST_FACTOR_FIRST_EQUATION    18126\n#define TEMPERATURE_TO_Y_SECOND_FACTOR_FIRST_EQUATION   22087\n#define TEMPERATURE_TO_Y_THIRD_FACTOR_FIRST_EQUATION    35808\n#define TEMPERATURE_TO_Y_FOURTH_FACTOR_FIRST_EQUATION   3312\n\n#define TEMPERATURE_TO_Y_FIRST_FACTOR_SECOND_EQUATION   15645\n#define TEMPERATURE_TO_Y_SECOND_FACTOR_SECOND_EQUATION  22514\n#define TEMPERATURE_TO_Y_THIRD_FACTOR_SECOND_EQUATION   34265\n#define TEMPERATURE_TO_Y_FOURTH_FACTOR_SECOND_EQUATION  2744\n\n#define TEMPERATURE_TO_Y_FIRST_FACTOR_THIRD_EQUATION    50491\n#define TEMPERATURE_TO_Y_SECOND_FACTOR_THIRD_EQUATION   96229\n#define TEMPERATURE_TO_Y_THIRD_FACTOR_THIRD_EQUATION    61458\n#define TEMPERATURE_TO_Y_FOURTH_FACTOR_THIRD_EQUATION   6062\n\n#define XY_TO_TEMPERATURE_X_EPICENTER                   21757\n#define XY_TO_TEMPERATURE_Y_EPICENTER                   12176\n\n#define XY_TO_TEMPERATURE_FIRST_FACTOR                  44900ull\n#define XY_TO_TEMPERATURE_SECOND_FACTOR                 352500ull\n#define XY_TO_TEMPERATURE_THIRD_FACTOR                  682330ull\n#define XY_TO_TEMPERATURE_FOURTH_FACTOR                 552033ull\n\n/**************************************************************************//**\n\\brief Converts color temperature to appropriate XY coordinates\n\n\\param[in] temperature - color temperature (attribute value);\n\\param[out] x          - x coordinate (attribute value);\n\\param[out] y          - y coordinate (attribute value)\n******************************************************************************/\nvoid MiredColorTemperatureToXY(unsigned short int temperature, unsigned short int *x, unsigned short int *y)\n{\n  if (temperature == 0)\n      temperature = 153;\n\n  unsigned long long localX, localY;\n  unsigned short int temp = 1000000 / temperature;\n\n  if (TEMPERATURE_TO_X_TEMPERATURE_TRESHOLD > temp)\n    localX =  TEMPERATURE_TO_X_THIRD_FACTOR_FIRST_EQUATION / temp +\n      TEMPERATURE_TO_X_FOURTH_FACTOR_FIRST_EQUATION -\n      TEMPERATURE_TO_X_SECOND_FACTOR_FIRST_EQUATION / temp / temp -\n      TEMPERATURE_TO_X_FIRST_FACTOR_FIRST_EQUATION / temp / temp/ temp;\n  else\n    localX = TEMPERATURE_TO_X_SECOND_FACTOR_SECOND_EQUATION / temp / temp +\n      TEMPERATURE_TO_X_THIRD_FACTOR_SECOND_EQUATION / temp +\n      TEMPERATURE_TO_X_FOURTH_FACTOR_SECOND_EQUATION -\n      TEMPERATURE_TO_X_FIRST_FACTOR_SECOND_EQUATION / temp / temp / temp;\n\n  if (TEMPERATURE_TO_Y_FIRST_TEMPERATURE_TRESHOLD > temp)\n    localY = TEMPERATURE_TO_Y_THIRD_FACTOR_FIRST_EQUATION * localX / 65536 -\n      TEMPERATURE_TO_Y_FIRST_FACTOR_FIRST_EQUATION * localX * localX * localX / 281474976710656 -\n      TEMPERATURE_TO_Y_SECOND_FACTOR_FIRST_EQUATION * localX * localX / 4294967296 -\n      TEMPERATURE_TO_Y_FOURTH_FACTOR_FIRST_EQUATION;\n  else if (TEMPERATURE_TO_Y_SECOND_TEMPERATURE_TRESHOLD > temp)\n    localY = TEMPERATURE_TO_Y_THIRD_FACTOR_SECOND_EQUATION * localX / 65536 -\n      TEMPERATURE_TO_Y_FIRST_FACTOR_SECOND_EQUATION * localX * localX * localX / 281474976710656 -\n      TEMPERATURE_TO_Y_SECOND_FACTOR_SECOND_EQUATION * localX * localX / 4294967296 -\n      TEMPERATURE_TO_Y_FOURTH_FACTOR_SECOND_EQUATION;\n  else\n  {\n    localY = TEMPERATURE_TO_Y_THIRD_FACTOR_THIRD_EQUATION * localX / 65536 +\n      TEMPERATURE_TO_Y_FIRST_FACTOR_THIRD_EQUATION * localX * localX * localX / 281474976710656 -\n      TEMPERATURE_TO_Y_SECOND_FACTOR_THIRD_EQUATION * localX * localX / 4294967296 -\n      TEMPERATURE_TO_Y_FOURTH_FACTOR_THIRD_EQUATION;\n  }\n\n  localY *= 4;\n\n  *x = (unsigned)localX;\n  *y = (unsigned)localY;\n}\n"
        },
        {
          "name": "colorspace.h",
          "type": "blob",
          "size": 3.146484375,
          "content": "/** \r\n * @file colorspace.h \r\n * @author Pascal Getreuer 2005-2010 <getreuer@gmail.com>\r\n */\r\n\r\n#ifndef _COLORSPACE_H_\r\n#define _COLORSPACE_H_\r\n\r\n/** @brief Datatype to use for representing real numbers \r\n * Set this typedef to either double or float depending on the application.\r\n */\r\ntypedef double num;\r\n\r\n\r\n/** @brief XYZ color of the D65 white point */\r\n#define WHITEPOINT_X\t0.950456\r\n#define WHITEPOINT_Y\t1.0\r\n#define WHITEPOINT_Z\t1.088754\r\n\r\n\r\n\r\n/** @brief struct for representing a color transform */\r\ntypedef struct\r\n{\r\n\tint NumStages;\r\n\tvoid (*Fun[2])(num*, num*, num*, num, num, num);\r\n} colortransform;\r\n\r\nint GetColorTransform(colortransform *Trans, const char *TransformString);\r\nvoid ApplyColorTransform(colortransform Trans, \r\n\tnum *D0, num *D1, num *D2, num S0, num S1, num S2);\r\n\r\nvoid Rgb2Yuv(num *Y, num *U, num *V, num R, num G, num B);\r\nvoid Yuv2Rgb(num *R, num *G, num *B, num Y, num U, num V);\r\nvoid Rgb2Ycbcr(num *Y, num *Cb, num *Cr, num R, num G, num B);\r\nvoid Ycbcr2Rgb(num *R, num *G, num *B, num Y, num Cb, num Cr);\r\nvoid Rgb2Jpegycbcr(num *R, num *G, num *B, num Y, num Cb, num Cr);\r\nvoid Jpegycbcr2Rgb(num *R, num *G, num *B, num Y, num Cb, num Cr);\r\nvoid Rgb2Ypbpr(num *Y, num *Pb, num *Pr, num R, num G, num B);\r\nvoid Ypbpr2Rgb(num *R, num *G, num *B, num Y, num Pb, num Pr);\r\nvoid Rgb2Ydbdr(num *Y, num *Db, num *Dr, num R, num G, num B);\r\nvoid Ydbdr2Rgb(num *R, num *G, num *B, num Y, num Db, num Dr);\r\nvoid Rgb2Yiq(num *Y, num *I, num *Q, num R, num G, num B);\r\nvoid Yiq2Rgb(num *R, num *G, num *B, num Y, num I, num Q);\r\n\r\nvoid Rgb2Hsv(num *H, num *S, num *V, num R, num G, num B);\r\nvoid Hsv2Rgb(num *R, num *G, num *B, num H, num S, num V);\r\nvoid Rgb2Hsl(num *H, num *S, num *L, num R, num G, num B);\r\nvoid Hsl2Rgb(num *R, num *G, num *B, num H, num S, num L);\r\nvoid Rgb2Hsi(num *H, num *S, num *I, num R, num G, num B);\r\nvoid Hsi2Rgb(num *R, num *G, num *B, num H, num S, num I);\r\n\r\nvoid Rgb2Xyz(num *X, num *Y, num *Z, num R, num G, num B);\r\nvoid Rgb2xy(num *x, num *y, num R, num G, num B);\r\nvoid Xyz2Rgb(num *R, num *G, num *B, num X, num Y, num Z);\r\nvoid Xyz2Lab(num *L, num *a, num *b, num X, num Y, num Z);\r\nvoid Lab2Xyz(num *X, num *Y, num *Z, num L, num a, num b);\r\nvoid Xyz2Luv(num *L, num *u, num *v, num X, num Y, num Z);\r\nvoid Luv2Xyz(num *X, num *Y, num *Z, num L, num u, num v);\r\nvoid Xyz2Lch(num *L, num *C, num *H, num X, num Y, num Z);\r\nvoid Lch2Xyz(num *X, num *Y, num *Z, num L, num C, num H);\r\nvoid Xyz2Cat02lms(num *L, num *M, num *S, num X, num Y, num Z);\r\nvoid Cat02lms2Xyz(num *X, num *Y, num *Z, num L, num M, num S);\r\n\r\nvoid Rgb2Lab(num *L, num *a, num *b, num R, num G, num B);\r\nvoid Lab2Rgb(num *R, num *G, num *B, num L, num a, num b);\r\nvoid Rgb2Luv(num *L, num *u, num *v, num R, num G, num B);\r\nvoid Luv2Rgb(num *R, num *G, num *B, num L, num u, num v);\r\nvoid Rgb2Lch(num *L, num *C, num *H, num R, num G, num B);\r\nvoid Lch2Rgb(num *R, num *G, num *B, num L, num C, num H);\r\nvoid Rgb2Cat02lms(num *L, num *M, num *S, num R, num G, num B);\r\nvoid Cat02lms2Rgb(num *R, num *G, num *B, num L, num M, num S);\r\n\r\nvoid MiredColorTemperatureToXY(unsigned short int temperature, unsigned short int *x, unsigned short int *y);\r\n\r\n#endif  /* _COLORSPACE_H_ */\r\n"
        },
        {
          "name": "crypto",
          "type": "tree",
          "content": null
        },
        {
          "name": "database.cpp",
          "type": "blob",
          "size": 236.7021484375,
          "content": "/*\r\n * Copyright (c) 2016-2024 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#define __STDC_FORMAT_MACROS\r\n#include <inttypes.h>\r\n#include <QString>\r\n#include <QStringBuilder>\r\n#include <QElapsedTimer>\r\n#include <unistd.h>\r\n#include \"database.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"deconz/atom_table.h\"\r\n#include \"deconz/dbg_trace.h\"\r\n#include \"deconz/u_assert.h\"\r\n#include \"deconz/u_sstream_ex.h\"\r\n#include \"deconz/u_memory.h\"\r\n#include \"device_descriptions.h\"\r\n#include \"gateway.h\"\r\n#include \"json.h\"\r\n#include \"product_match.h\"\r\n#include \"utils/ArduinoJson.h\"\r\n#include \"utils/utils.h\"\r\n\r\nconstexpr size_t MAX_SQL_LEN = 2048;\r\n\r\nstatic const char *pragmaUserVersion = \"PRAGMA user_version\";\r\nstatic const char *pragmaPageCount = \"PRAGMA page_count\";\r\nstatic const char *pragmaPageSize = \"PRAGMA page_size\";\r\nstatic const char *pragmaFreeListCount = \"PRAGMA freelist_count\";\r\n\r\nstatic sqlite3 *db = nullptr;\r\nstatic char sqlBuf[MAX_SQL_LEN];\r\n\r\nstatic StaticJsonDocument<1024 * 1024 * 2> dbJson; /* 2 mega bytes*/\r\n\r\nstruct DB_Callback {\r\n  DeRestPluginPrivate *d = nullptr;\r\n  LightNode *lightNode = nullptr;\r\n  Sensor *sensorNode = nullptr;\r\n};\r\n\r\n/******************************************************************************\r\n                    Local prototypes\r\n******************************************************************************/\r\nstatic bool initAlarmSystemsTable();\r\nstatic bool initSecretsTable();\r\nstatic bool setDbUserVersion(int userVersion);\r\nstatic int getDbPragmaInteger(const char *sql);\r\nstatic bool upgradeDbToUserVersion1();\r\nstatic bool upgradeDbToUserVersion2();\r\nstatic bool upgradeDbToUserVersion6();\r\nstatic bool upgradeDbToUserVersion7();\r\nstatic bool upgradeDbToUserVersion8();\r\nstatic bool upgradeDbToUserVersion9();\r\nstatic bool upgradeDbToUserVersion10();\r\nstatic int sqliteLoadAuthCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadConfigCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadUserparameterCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadLightNodeCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllGroupsCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllResourcelinksCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadGroupCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllScenesCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadSceneCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllRulesCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllSensorsCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteGetAllLightIdsCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteGetAllSensorIdsCallback(void *user, int ncols, char **colval , char **colname);\r\nstatic int sqliteLoadAllGatewaysCallback(void *user, int ncols, char **colval , char **colname);\r\n\r\n/******************************************************************************\r\n                    Implementation\r\n******************************************************************************/\r\n\r\nstatic QString dbEscapeString(const QString &str)\r\n{\r\n    QString result;\r\n    result.reserve(str.size());\r\n\r\n    for (const QChar &ch : str)\r\n    {\r\n        if (ch.isNonCharacter() || ch < ' ')\r\n        {\r\n            result.push_back('.');\r\n            continue;\r\n        }\r\n\r\n        switch (ch.unicode())\r\n        {\r\n        case u'\\'':\r\n            result.push_back(ch);\r\n            result.push_back(ch);\r\n            break;\r\n\r\n        default:\r\n            result.push_back(ch);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n#ifdef DECONZ_DEBUG_BUILD\r\nstatic void DB_UpdateHook(void *user, int op, char const *dbName, char const *tableName, sqlite3_int64 rowid)\r\n{\r\n    (void)user;\r\n    const char *opName = \"?\";\r\n\r\n    if      (op == SQLITE_INSERT) { opName = \"INSERT\"; }\r\n    else if (op == SQLITE_UPDATE) { opName = \"UPDATE\"; }\r\n    else if (op == SQLITE_DELETE) { opName = \"DELETE\"; }\r\n\r\n\r\n    if (op == SQLITE_UPDATE)\r\n    {\r\n        if (tableName[0] == 'd')\r\n        {\r\n            DBG_Printf(DBG_INFO_L2, \"dummy\\n\");\r\n        }\r\n    }\r\n    DBG_Printf(DBG_INFO, \"%s %s %lld\\n\", opName, tableName, (long long)rowid);\r\n\r\n}\r\n#endif\r\n\r\n\r\n/*! Inits the database and creates tables/columns if necessary.\r\n */\r\nvoid DeRestPluginPrivate::initDb()\r\n{\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"DB initDb() failed db not opened\\n\");\r\n        return;\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"DB sqlite version %s\\n\", sqlite3_libversion());\r\n\r\n    int pageCount = getDbPragmaInteger(pragmaPageCount);\r\n    int pageSize = getDbPragmaInteger(pragmaPageSize);\r\n    int pageFreeListCount = getDbPragmaInteger(pragmaFreeListCount);\r\n    DBG_Printf(DBG_INFO, \"DB file size %d bytes, free pages %d\\n\", pageCount * pageSize, pageFreeListCount);\r\n\r\n    checkDbUserVersion();\r\n}\r\n\r\n/*! Checks the sqlite 'user_version' in order to apply database schema updates.\r\n    Updates are applied in recursive manner to have sane upgrade paths from\r\n    certain versions in the field.\r\n */\r\nvoid DeRestPluginPrivate::checkDbUserVersion()\r\n{\r\n    bool updated = false;\r\n    const int userVersion = getDbPragmaInteger(pragmaUserVersion); // sqlite default is 0\r\n\r\n    if (userVersion == 0) // initial and legacy databases\r\n    {\r\n        updated = upgradeDbToUserVersion1();\r\n    }\r\n    else if (userVersion == 1)\r\n    {\r\n        updated = upgradeDbToUserVersion2();\r\n    }\r\n    else if (userVersion >= 2 && userVersion <= 5 )\r\n    {\r\n        updated = upgradeDbToUserVersion6();\r\n    }\r\n    else if (userVersion == 6)\r\n    {\r\n        updated = upgradeDbToUserVersion7();\r\n    }\r\n    else if (userVersion == 7)\r\n    {\r\n        updated = upgradeDbToUserVersion8();\r\n    }\r\n    else if (userVersion == 8)\r\n    {\r\n        updated = upgradeDbToUserVersion9();\r\n    }\r\n    else if (userVersion == 9)\r\n    {\r\n        updated = upgradeDbToUserVersion10();\r\n    }\r\n    else if (userVersion == 10)\r\n    {\r\n        // latest version\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_INFO, \"DB database file opened with a older deCONZ version\\n\");\r\n    }\r\n\r\n    if (!updated)\r\n    {\r\n        cleanUpDb();\r\n        createTempViews();\r\n\r\n        initSecretsTable(); // todo, temporary, use user version > 8, after PR #5089 is merged\r\n        initAlarmSystemsTable();\r\n    }\r\n    else // if something was upgraded\r\n    {\r\n        checkDbUserVersion(); // tail recursion\r\n    }\r\n}\r\n\r\nstatic int DB_LoadDuplSensorsCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<std::string>*>(user);\r\n    Q_ASSERT(result);\r\n    Q_ASSERT(ncols == 1);\r\n\r\n    if (colval[0] && colval[0][0])\r\n    {\r\n        result->push_back(std::string(colval[0]));\r\n    }\r\n    return 0;\r\n};\r\n\r\n/*! Remove sensors with duplicated uniqueid, keeping the one with lowest 'id'\r\n    in the assumption it was the first one created. (fix for db regressions before v2.15.2).\r\n */\r\nstatic void DB_CleanupDuplSensors(sqlite3 *db)\r\n{\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    int ret;\r\n    std::vector<std::string> uniqueids;\r\n\r\n    ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT uniqueid\"\r\n                                 \" FROM sensors\"\r\n                                 \" WHERE type NOT LIKE 'CLIP%%'\"\r\n                                 \" AND deletedState == 'normal'\"\r\n                                 \" GROUP BY uniqueid\"\r\n                                 \" HAVING COUNT(uniqueid) > 1\");\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadDuplSensorsCallback, &uniqueids, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    if (uniqueids.empty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    for (const auto &uniqueid : uniqueids)\r\n    {\r\n        std::vector<std::string> result;\r\n\r\n        // get the lowest sensor.id for uniqueid, likely the first one which was created (we keep it)\r\n        ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT sid\"\r\n                                     \" FROM sensors\"\r\n                                     \" WHERE uniqueid = '%s'\"\r\n                                     \" AND deletedState == 'normal'\"\r\n                                     \" ORDER BY sid DESC LIMIT 1\", uniqueid.c_str());\r\n        U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n        if (size_t(ret) < sizeof(sqlBuf))\r\n        {\r\n            char *errmsg = nullptr;\r\n            int rc = sqlite3_exec(db, sqlBuf, DB_LoadDuplSensorsCallback, &result, &errmsg);\r\n\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n\r\n        if (result.size() != 1 || result.front().empty())\r\n        {\r\n            continue;\r\n        }\r\n\r\n        // delete sensors with same uniqueid which have a higher 'sid' as lowest known one\r\n        ret = snprintf(sqlBuf, sizeof(sqlBuf), \"DELETE FROM sensors\"\r\n                                     \" WHERE uniqueid = '%s' and sid != '%s'\", uniqueid.c_str(), result.front().c_str());\r\n        U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n        if (size_t(ret) < sizeof(sqlBuf))\r\n        {\r\n            char *errmsg = nullptr;\r\n            int rc = sqlite3_exec(db, sqlBuf, DB_LoadDuplSensorsCallback, &result, &errmsg);\r\n\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Cleanup tasks for database maintenance.\r\n */\r\nvoid DeRestPluginPrivate::cleanUpDb()\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n    DBG_Printf(DBG_INFO, \"DB cleanup\\n\");\r\n\r\n    /* Create SQL statement */\r\n    const char *sql[] = {\r\n        // cleanup invalid sensor resource for Centralite motion sensor\r\n        \"DELETE FROM sensors WHERE modelid = 'Motion Sensor-A' AND uniqueid LIKE '%02-0406'\",\r\n\r\n        // cleanup invalid ZHAAlarm resource for Xiaomi motion sensor\r\n        \"DELETE from sensors WHERE type = 'ZHAAlarm' AND modelid LIKE 'lumi.sensor_motion%'\",\r\n\r\n        // cleanup invalid Tuya smart knob light resource (only has ZHASwitch)\r\n        \"DELETE from nodes WHERE manufacturername = '_TZ3000_4fjiwweb'\",\r\n\r\n        // delete duplicates in device_descriptors\r\n        //\"DELETE FROM device_descriptors WHERE rowid NOT IN\"\r\n        //\" (SELECT max(rowid) FROM device_descriptors GROUP BY device_id,type,endpoint)\",\r\n\r\n        // change old default value of zcl data store, from 1 hour to disabled\r\n        \"UPDATE config2 SET value = 0 WHERE key = 'zclvaluemaxage' AND value = 3600\",\r\n\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        errmsg = nullptr;\r\n\r\n        /* Execute SQL statement */\r\n        rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sql[i], errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n\r\n    DB_CleanupDuplSensors(db);\r\n}\r\n\r\n/*! Creates temporary views only valid during this session.\r\n */\r\nvoid DeRestPluginPrivate::createTempViews()\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n    DBG_Printf(DBG_INFO, \"DB create temporary views\\n\");\r\n\r\n    /* Create SQL statement */\r\n    const char *sql[] = {\r\n        \"CREATE TEMP VIEW sensor_device_view \"\r\n        \"  AS SELECT a.sid, b.mac, b.id FROM sensors a, devices b \"\r\n        \"  WHERE a.uniqueid like b.mac || '%'\",\r\n        \"CREATE TEMP VIEW sensor_device_value_view \"\r\n        \"  AS SELECT a.sid AS sensor_id, b.cluster AS cluster_id, b.data AS data, b.timestamp AS timestamp \"\r\n        \"  from sensor_device_view a, zcl_values b where a.id = b.device_id \"\r\n        \"  ORDER BY timestamp ASC \",\r\n\r\n        \"CREATE TEMP VIEW light_device_view \"\r\n        \"  AS SELECT a.id as lid, b.mac, b.id FROM nodes a, devices b \"\r\n        \"  WHERE a.mac like b.mac || '%'\",\r\n        \"CREATE TEMP VIEW light_device_value_view \"\r\n        \"  AS SELECT a.lid AS light_id, b.cluster AS cluster_id, b.data AS data, b.timestamp AS timestamp \"\r\n        \"  from light_device_view a, zcl_values b where a.id = b.device_id \"\r\n        \"  ORDER BY timestamp ASC \",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != NULL; i++)\r\n    {\r\n        errmsg = NULL;\r\n\r\n        /* Execute SQL statement */\r\n        rc = sqlite3_exec(db, sql[i], NULL, NULL, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sql[i], errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO_L2, \"DB view [%d] created\\n\", i);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Returns SQLite pragma parameters specified by \\p sql.\r\n */\r\nstatic int getDbPragmaInteger(const char *sql)\r\n{\r\n    int rc;\r\n    int val = -1;\r\n    sqlite3_stmt *res = NULL;\r\n\r\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n    if (rc == SQLITE_OK) { rc = sqlite3_step(res); }\r\n\r\n    DBG_Assert(rc == SQLITE_ROW);\r\n    if (rc == SQLITE_ROW)\r\n    {\r\n        val = sqlite3_column_int(res, 0);\r\n        DBG_Printf(DBG_INFO, \"DB %s: %d\\n\", sql, val);\r\n    }\r\n\r\n    DBG_Assert(res != NULL);\r\n    if (res)\r\n    {\r\n        rc = sqlite3_finalize(res);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n    return val;\r\n}\r\n\r\n/*! Writes database user_version to \\p userVersion. */\r\nstatic bool setDbUserVersion(int userVersion)\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n\r\n    DBG_Printf(DBG_INFO, \"DB write sqlite user_version %d\\n\", userVersion);\r\n\r\n    const auto sql = QString(\"PRAGMA user_version = %1\").arg(userVersion);\r\n\r\n    errmsg = NULL;\r\n    rc = sqlite3_exec(db, qPrintable(sql), NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", qPrintable(sql), errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/*! Upgrades database to user_version 1. */\r\nstatic bool upgradeDbToUserVersion1()\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 1\\n\");\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"CREATE TABLE IF NOT EXISTS auth (apikey TEXT PRIMARY KEY, devicetype TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS userparameter (key TEXT PRIMARY KEY, value TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS nodes (mac TEXT PRIMARY KEY, id TEXT, state TEXT, name TEXT, groups TEXT, endpoint TEXT, modelid TEXT, manufacturername TEXT, swbuildid TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS config2 (key text PRIMARY KEY, value text)\",\r\n        \"ALTER TABLE nodes add column id TEXT\",\r\n        \"ALTER TABLE nodes add column state TEXT\",\r\n        \"ALTER TABLE nodes add column groups TEXT\",\r\n        \"ALTER TABLE nodes add column endpoint TEXT\",\r\n        \"ALTER TABLE nodes add column modelid TEXT\",\r\n        \"ALTER TABLE nodes add column manufacturername TEXT\",\r\n        \"ALTER TABLE nodes add column swbuildid TEXT\",\r\n        \"ALTER TABLE nodes add column ritems TEXT\",\r\n        \"ALTER TABLE auth add column createdate TEXT\",\r\n        \"ALTER TABLE auth add column lastusedate TEXT\",\r\n        \"ALTER TABLE auth add column useragent TEXT\",\r\n        \"CREATE TABLE IF NOT EXISTS groups (gid TEXT PRIMARY KEY, name TEXT, state TEXT, mids TEXT, devicemembership TEXT, lightsequence TEXT, hidden TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS resourcelinks (id TEXT PRIMARY KEY, json TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS rules (rid TEXT PRIMARY KEY, name TEXT, created TEXT, etag TEXT, lasttriggered TEXT, owner TEXT, status TEXT, timestriggered TEXT, actions TEXT, conditions TEXT, periodic TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS sensors (sid TEXT PRIMARY KEY, name TEXT, type TEXT, modelid TEXT, manufacturername TEXT, uniqueid TEXT, swversion TEXT, state TEXT, config TEXT, fingerprint TEXT, deletedState TEXT, mode TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS scenes (gsid TEXT PRIMARY KEY, gid TEXT, sid TEXT, name TEXT, transitiontime TEXT, lights TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS schedules (id TEXT PRIMARY KEY, json TEXT)\",\r\n        \"CREATE TABLE IF NOT EXISTS gateways (uuid TEXT PRIMARY KEY, name TEXT, ip TEXT, port TEXT, pairing TEXT, apikey TEXT, cgroups TEXT)\",\r\n        \"ALTER TABLE sensors add column fingerprint TEXT\",\r\n        \"ALTER TABLE sensors add column deletedState TEXT\",\r\n        \"ALTER TABLE sensors add column mode TEXT\",\r\n        \"ALTER TABLE groups add column state TEXT\",\r\n        \"ALTER TABLE groups add column mids TEXT\",\r\n        \"ALTER TABLE groups add column devicemembership TEXT\",\r\n        \"ALTER TABLE groups add column lightsequence TEXT\",\r\n        \"ALTER TABLE groups add column hidden TEXT\",\r\n        \"ALTER TABLE groups add column type TEXT\",\r\n        \"ALTER TABLE groups add column class TEXT\",\r\n        \"ALTER TABLE groups add column uniqueid TEXT\",\r\n        \"ALTER TABLE scenes add column transitiontime TEXT\",\r\n        \"ALTER TABLE scenes add column lights TEXT\",\r\n        \"ALTER TABLE rules add column periodic TEXT\",\r\n        \"CREATE TABLE IF NOT EXISTS zbconf (conf TEXT)\",\r\n        NULL\r\n    };\r\n\r\n    for (int i = 0; sql[i] != NULL; i++)\r\n    {\r\n        errmsg = NULL;\r\n        rc = sqlite3_exec(db, sql[i], NULL, NULL, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sql[i], errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(1);\r\n}\r\n\r\n/*! Upgrades database to user_version 2. */\r\nstatic bool upgradeDbToUserVersion2()\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 2\\n\");\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"PRAGMA foreign_keys = 1\",\r\n        \"CREATE TABLE IF NOT EXISTS devices (id INTEGER PRIMARY KEY, mac TEXT UNIQUE, timestamp INTEGER NOT NULL)\",\r\n\r\n        // zcl_values: table for logging various data\r\n        // zcl_values.data: This field can hold anything (text,integer,blob) since sqlite supports dynamic types on per value level.\r\n        \"CREATE TABLE IF NOT EXISTS zcl_values (id INTEGER PRIMARY KEY, device_id INTEGER REFERENCES devices(id) ON DELETE CASCADE, endpoint INTEGER NOT NULL, cluster INTEGER NOT NULL, attribute INTEGER NOT NULL, data INTEGER NOT NULL, timestamp INTEGER NOT NULL)\",\r\n        NULL\r\n    };\r\n\r\n    for (int i = 0; sql[i] != NULL; i++)\r\n    {\r\n        errmsg = NULL;\r\n        rc = sqlite3_exec(db, sql[i], NULL, NULL, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sql[i], errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(2);\r\n}\r\n\r\n/*! Upgrades database to user_version 6. */\r\nstatic bool upgradeDbToUserVersion6()\r\n{\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 6\\n\");\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"DROP TABLE IF EXISTS device_gui\", // development version\r\n\r\n        \"ALTER TABLE devices ADD COLUMN nwk INTEGER\",\r\n\r\n        // device_descriptors: cache for queried descriptors\r\n        // device_descriptors.data: This field holds the raw descriptor as blob.\r\n        \"CREATE TABLE IF NOT EXISTS device_descriptors (\"\r\n        \" id INTEGER PRIMARY KEY,\"\r\n        \" device_id INTEGER REFERENCES devices(id) ON DELETE CASCADE,\"\r\n        \" flags INTEGER NOT NULL DEFAULT 0,\"\r\n        \" endpoint INTEGER NOT NULL,\"\r\n        \" type INTEGER NOT NULL,\"  // ZDP cluster id which was used to query the descriptor\r\n        \" data BLOB NOT NULL,\"\r\n        \" timestamp INTEGER NOT NULL)\",\r\n\r\n        \"CREATE TABLE if NOT EXISTS device_gui (\"\r\n        \" id INTEGER PRIMARY KEY,\"\r\n        \" device_id INTEGER UNIQUE,\"\r\n        \" flags INTEGER NOT NULL DEFAULT 0,\"\r\n        \" scene_x REAL NOT NULL,\"\r\n        \" scene_y REAL NOT NULL,\"\r\n        \" FOREIGN KEY(device_id) REFERENCES devices(id) ON DELETE CASCADE)\",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            bool fatalError = true;\r\n            if (errmsg)\r\n            {\r\n                if (strstr(errmsg, \"duplicate column name\")) // harmless\r\n                {\r\n                    fatalError = false;\r\n                }\r\n                else\r\n                {\r\n                    DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sql[i], errmsg, rc);\r\n                }\r\n                sqlite3_free(errmsg);\r\n            }\r\n\r\n            if (fatalError)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(6);\r\n}\r\n\r\n/*! Upgrades database to user_version 7. */\r\nstatic bool upgradeDbToUserVersion7()\r\n{\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 7\\n\");\r\n\r\n    /*\r\n       The 'source_routes' table references 'devices' so that entries are\r\n       automatically deleted if the destination node is removed.\r\n       Inserting an entry with an existing uuid will automatically replace the old row.\r\n\r\n       The 'source_route_hops' table also references 'devices' so that\r\n       entries for a hop get deleted when the respective node is removed.\r\n       In this case the source route entry still exists but the source_routes.hops\r\n       count won't match the number of source_route_hops entries anymore.\r\n     */\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"CREATE TABLE IF NOT EXISTS source_routes (\"\r\n        \" uuid TEXT PRIMARY KEY ON CONFLICT REPLACE,\"\r\n        \" dest_device_id INTEGER REFERENCES devices(id) ON DELETE CASCADE,\"\r\n        \" route_order INTEGER NOT NULL,\"\r\n        \" hops INTEGER NOT NULL,\"  // to track number of entries which should be in 'source_route_relays'\r\n        \" timestamp INTEGER NOT NULL)\",\r\n\r\n        \"CREATE TABLE if NOT EXISTS source_route_hops (\"\r\n        \" source_route_uuid TEXT REFERENCES source_routes(uuid) ON DELETE CASCADE,\"\r\n        \" hop_device_id INTEGER REFERENCES devices(id) ON DELETE CASCADE,\"\r\n        \" hop INTEGER NOT NULL)\",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d), line: %d\\n\", sql[i], errmsg, rc, __LINE__);\r\n                sqlite3_free(errmsg);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(7);\r\n}\r\n\r\n/*! Upgrades database to user_version 8. */\r\nstatic bool upgradeDbToUserVersion8()\r\n{\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 8\\n\");\r\n\r\n    const char *sql[] = {\r\n        \"ALTER TABLE sensors add column lastseen TEXT\",\r\n        \"ALTER TABLE sensors add column lastannounced TEXT\",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d), line: %d\\n\", sql[i], errmsg, rc, __LINE__);\r\n                sqlite3_free(errmsg);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(8);\r\n}\r\n\r\n/*! Upgrades database to user_version 9. */\r\nstatic bool upgradeDbToUserVersion9()\r\n{\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 9\\n\");\r\n\r\n    /*\r\n       The 'sub_devices' table references 'devices' so that entries are\r\n       automatically deleted if the destination node is removed.\r\n       Inserting an existing entry will automatically be ignored.\r\n\r\n       The 'resource_items' table references 'sub_devices' so that\r\n       entries are deleted when the respective sub_devices entry is removed.\r\n       Each entry is unique and automatically replaced if already existing.\r\n     */\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"CREATE TABLE IF NOT EXISTS sub_devices (\"\r\n        \" id INTEGER PRIMARY KEY,\"\r\n        \" uniqueid TEXT NOT NULL,\"\r\n        \" device_id INTEGER REFERENCES devices(id) ON DELETE CASCADE,\"\r\n        \" timestamp INTEGER NOT NULL,\"\r\n        \" UNIQUE(uniqueid) ON CONFLICT IGNORE)\",\r\n\r\n        \"CREATE TABLE if NOT EXISTS resource_items (\"\r\n        \" sub_device_id TEXT REFERENCES sub_devices(id) ON DELETE CASCADE,\"\r\n        \" item STRING NOT NULL,\"\r\n        \" value NOT NULL,\" // can be any type\r\n        \" source STRING NOT NULL,\"\r\n        \" timestamp INTEGER NOT NULL,\" // is the last set timestamp\r\n        \" PRIMARY KEY (sub_device_id, item) ON CONFLICT REPLACE\"\r\n        \")\",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d), line: %d\\n\", sql[i], errmsg, rc, __LINE__);\r\n                sqlite3_free(errmsg);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(9);\r\n}\r\n\r\n/*! Upgrades database to user_version 10. */\r\nstatic bool upgradeDbToUserVersion10()\r\n{\r\n    DBG_Printf(DBG_INFO, \"DB upgrade to user_version 10\\n\");\r\n\r\n    /*\r\n       The 'dev_resource_items' table references 'devices' so that\r\n       entries are deleted when the respective devices entry is removed.\r\n       Each entry is unique and automatically replaced if already existing.\r\n\r\n       Note this needs an extra table since Device* isn't a sub_device that can\r\n       be referenced.\r\n     */\r\n\r\n    // create tables\r\n    const char *sql[] = {\r\n        \"CREATE TABLE if NOT EXISTS dev_resource_items (\"\r\n        \" device_id TEXT REFERENCES devices(id) ON DELETE CASCADE,\"\r\n        \" item STRING NOT NULL,\"\r\n        \" value NOT NULL,\" // can be any type\r\n        \" timestamp INTEGER NOT NULL,\" // is the last set timestamp\r\n        \" PRIMARY KEY (device_id, item) ON CONFLICT REPLACE\"\r\n        \")\",\r\n        nullptr\r\n    };\r\n\r\n    for (int i = 0; sql[i] != nullptr; i++)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sql[i], nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d), line: %d\\n\", sql[i], errmsg, rc, __LINE__);\r\n                sqlite3_free(errmsg);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return setDbUserVersion(10);\r\n}\r\n\r\n/*! Stores a source route.\r\n    Any existing source route with the same uuid will be replaced automatically.\r\n */\r\nvoid DeRestPluginPrivate::storeSourceRoute(const deCONZ::SourceRoute &sourceRoute)\r\n{\r\n    DBG_Assert(sourceRoute.hops().size() > 1);\r\n\r\n    if (sourceRoute.hops().size() <= 1)\r\n    {\r\n        return; // at least two hops (incl. destination)\r\n    }\r\n\r\n    openDb();\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"INSERT INTO source_routes (uuid,dest_device_id,route_order,hops,timestamp)\"\r\n                          \" SELECT '%1', (SELECT id FROM devices WHERE mac = '%2'), %3, %4, strftime('%s','now');\")\r\n                          .arg(sourceRoute.uuid())\r\n                          .arg(generateUniqueId(sourceRoute.hops().back().ext(), 0, 0))\r\n                          .arg(sourceRoute.order())\r\n                          .arg(sourceRoute.hops().size());\r\n\r\n    for (size_t i = 0; i < sourceRoute.hops().size(); i++)\r\n    {\r\n        sql += QString(\"INSERT INTO source_route_hops (source_route_uuid, hop_device_id, hop)\"\r\n                       \" SELECT '%1', (SELECT id FROM devices WHERE mac = '%2'), %3;\")\r\n                .arg(sourceRoute.uuid())\r\n                .arg(generateUniqueId(sourceRoute.hops().at(i).ext(), 0, 0))\r\n                .arg(i);\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s, line: %d\\n\", qPrintable(sql), errmsg, __LINE__);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    closeDb();\r\n}\r\n\r\n/*! Deletes the source route with \\p uuid. */\r\nvoid DeRestPluginPrivate::deleteSourceRoute(const QString &uuid)\r\n{\r\n    DBG_Assert(!uuid.isEmpty());\r\n\r\n    openDb();\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    const auto sql = QString(\"DELETE FROM source_routes WHERE uuid = '%1'\").arg(uuid);\r\n    int rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s, line: %d\\n\", qPrintable(sql), errmsg, __LINE__);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    closeDb();\r\n}\r\n\r\n/*! Restores and activates all source routes in core. */\r\nvoid DeRestPluginPrivate::restoreSourceRoutes()\r\n{\r\n    openDb();\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const auto loadSourceRoutesCallback = [](void *user, int ncols, char **colval , char **) -> int\r\n    {\r\n        auto *sourceRoutes = static_cast<std::vector<deCONZ::SourceRoute>*>(user);\r\n        DBG_Assert(sourceRoutes);\r\n        DBG_Assert(ncols == 3);\r\n        // TODO verify number of hops in colval[2]\r\n        sourceRoutes->push_back(deCONZ::SourceRoute(colval[0], QString(colval[1]).toInt(), {}));\r\n        return 0;\r\n    };\r\n\r\n    char *errmsg = nullptr;\r\n    std::vector<deCONZ::SourceRoute> sourceRoutes;\r\n    const char *sql = \"SELECT uuid, route_order, hops FROM source_routes\";\r\n\r\n    int rc = sqlite3_exec(db, sql, loadSourceRoutesCallback, &sourceRoutes, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s, line: %d\\n\", qPrintable(sql), errmsg, __LINE__);\r\n            sqlite3_free(errmsg);\r\n            errmsg = nullptr;\r\n        }\r\n    }\r\n\r\n    const auto loadHopsCallback = [](void *user, int ncols, char **colval , char **) -> int\r\n    {\r\n        auto *hops = static_cast<std::vector<deCONZ::Address>*>(user);\r\n        DBG_Assert(hops);\r\n        DBG_Assert(ncols == 2);\r\n\r\n        const auto mac = QString(\"0x%1\").arg(colval[0]).remove(':');\r\n        // TODO make use of 'hop' in colval[1]\r\n\r\n        bool ok = false;\r\n        deCONZ::Address addr;\r\n        addr.setExt(static_cast<uint64_t>(mac.toULongLong(&ok, 16)));\r\n\r\n        if (ok)\r\n        {\r\n            hops->push_back(addr);\r\n        }\r\n\r\n        return 0;\r\n    };\r\n\r\n    for (auto &sr : sourceRoutes)\r\n    {\r\n        std::vector<deCONZ::Address> hops;\r\n        const auto sql = QString(\"SELECT mac, hop FROM source_route_hops INNER JOIN devices WHERE hop_device_id = devices.id AND source_route_uuid = '%1';\").arg(sr.uuid());\r\n\r\n        rc = sqlite3_exec(db, qPrintable(sql), loadHopsCallback, &hops, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s, line: %d\\n\", qPrintable(sql), errmsg, __LINE__);\r\n                sqlite3_free(errmsg);\r\n                errmsg = nullptr;\r\n            }\r\n        }\r\n        else if (apsCtrl && hops.size() > 1) // at least two items\r\n        {\r\n            apsCtrl->activateSourceRoute(deCONZ::SourceRoute(sr.uuid(), sr.order(), hops));\r\n        }\r\n    }\r\n\r\n    closeDb();\r\n}\r\n\r\n/*! Puts a new top level device entry in the db (mac address) or refreshes nwk address.\r\n */\r\nint DB_StoreDevice(const deCONZ::Address &addr)\r\n{\r\n    if (!db || !addr.hasExt() || !addr.hasNwk())\r\n        return -1;\r\n\r\n    struct Entry {\r\n        long id;\r\n        long nwk;\r\n    } entry;\r\n\r\n    int rc;\r\n\r\n    const auto loadDeviceCallback = [](void *user, int ncols, char **colval , char **) -> int\r\n    {\r\n        long id;\r\n        long nwk;\r\n        U_SStream ss;\r\n\r\n        if (ncols != 2)\r\n            return 1;\r\n\r\n        U_sstream_init(&ss, colval[0], U_StringLength(colval[0]));\r\n        id = U_sstream_get_long(&ss);\r\n        if (ss.status != U_SSTREAM_OK)\r\n            return 1;\r\n\r\n        U_sstream_init(&ss, colval[1], U_StringLength(colval[1]));\r\n        nwk = U_sstream_get_long(&ss);\r\n        if (ss.status != U_SSTREAM_OK)\r\n            return 1;\r\n\r\n        Entry *e = static_cast<Entry*>(user);\r\n        e->id = id;\r\n        e->nwk = nwk;\r\n        return 0;\r\n    };\r\n\r\n    U_SStream ss;\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n    // check already existing\r\n    U_sstream_put_str(&ss, \"SELECT id, nwk FROM devices WHERE mac = '\");\r\n    U_sstream_put_mac_address(&ss, addr.ext());\r\n    U_sstream_put_str(&ss, \"'\");\r\n\r\n    entry.id = -1;\r\n    entry.nwk = -1;\r\n\r\n    rc = sqlite3_exec(db, sqlBuf, loadDeviceCallback, &entry, nullptr);\r\n\r\n    if (rc == SQLITE_OK && entry.id != -1)\r\n    {\r\n        if (entry.nwk == addr.nwk())\r\n            return entry.id; // all there\r\n\r\n        // Update NWK address\r\n        U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n        U_sstream_put_str(&ss, \"UPDATE devices SET nwk = \");\r\n        U_sstream_put_long(&ss, addr.nwk());\r\n        U_sstream_put_str(&ss, \" WHERE mac = '\");\r\n        U_sstream_put_mac_address(&ss, addr.ext());\r\n        U_sstream_put_str(&ss, \"';\");\r\n\r\n        rc = sqlite3_exec(db, sqlBuf, nullptr, nullptr, nullptr);\r\n\r\n        if (rc == SQLITE_OK)\r\n            return entry.id;\r\n\r\n        return -1;\r\n    }\r\n\r\n    // add new entry\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n    U_sstream_put_str(&ss, \"INSERT INTO devices (mac,nwk,timestamp) SELECT '\");\r\n    U_sstream_put_mac_address(&ss, addr.ext());\r\n    U_sstream_put_str(&ss, \"', \");\r\n    U_sstream_put_long(&ss, addr.nwk());\r\n    U_sstream_put_str(&ss, \", strftime('%s','now');\");\r\n\r\n    rc = sqlite3_exec(db, sqlBuf, nullptr, nullptr, nullptr);\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n        // query again to get device id\r\n        U_sstream_put_str(&ss, \"SELECT id, nwk FROM devices WHERE mac = '\");\r\n        U_sstream_put_mac_address(&ss, addr.ext());\r\n        U_sstream_put_str(&ss, \"'\");\r\n\r\n        entry.id = -1;\r\n        entry.nwk = -1;\r\n\r\n        rc = sqlite3_exec(db, sqlBuf, loadDeviceCallback, &entry, nullptr);\r\n\r\n        if (rc == SQLITE_OK && entry.id != -1)\r\n        {\r\n            return entry.id;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n/*! Push/update a zdp descriptor in the database to cache node data.\r\n  */\r\nvoid DeRestPluginPrivate::pushZdpDescriptorDb(quint64 extAddress, quint8 endpoint, quint16 type, const QByteArray &data)\r\n{\r\n    DBG_Printf(DBG_INFO_L2, \"DB pushZdpDescriptorDb()\\n\");\r\n\r\n    openDb();\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // store now to make sure 'devices' table is populated\r\n    if (!dbQueryQueue.empty())\r\n    {\r\n        saveDb();\r\n    }\r\n\r\n    qint64 now = QDateTime::currentMSecsSinceEpoch() / 1000;\r\n    const QString uniqueid = generateUniqueId(extAddress, 0, 0);\r\n    char mac[23 + 1];\r\n    strncpy(mac, qPrintable(uniqueid), uniqueid.size());\r\n    mac[23] = '\\0';\r\n\r\n    // 0) check if exists\r\n    int rc;\r\n    sqlite3_stmt *res = nullptr;\r\n    const char * sql = \"SELECT COUNT(*) FROM device_descriptors\"\r\n                       \" WHERE device_id = (SELECT id FROM devices WHERE mac = ?1)\"\r\n                       \" AND endpoint = ?2\"\r\n                       \" AND type = ?3\"\r\n                       \" AND data = ?4\";\r\n\r\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, nullptr);\r\n    DBG_Assert(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_text(res, 1, mac, -1, SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 2, endpoint);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 3, type);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_blob(res, 4, data.constData(), data.size(), SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    int rows = -1;\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_step(res);\r\n        DBG_Assert(rc == SQLITE_ROW);\r\n        if (rc == SQLITE_ROW)\r\n        {\r\n            rows = sqlite3_column_int(res, 0);\r\n        }\r\n    }\r\n\r\n    rc = sqlite3_finalize(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    if (rows != 0) // error or already existing\r\n    {\r\n        return;\r\n    }\r\n\r\n    // 1) if exist, try to update existing entry\r\n\r\n    sql = \"UPDATE device_descriptors SET data = ?1, timestamp = ?2\"\r\n          \" WHERE device_id = (SELECT id FROM devices WHERE mac = ?3)\"\r\n          \" AND endpoint = ?4\"\r\n          \" AND type = ?5\";\r\n\r\n\r\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, nullptr);\r\n    DBG_Assert(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_blob(res, 1, data.constData(), data.size(), SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int64(res, 2, now);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_text(res, 3, mac, -1, SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 4, endpoint);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 5, type);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"DB failed %s\\n\", sqlite3_errmsg(db));\r\n        if (res)\r\n        {\r\n            rc = sqlite3_finalize(res);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n        return;\r\n    }\r\n\r\n#if SQLITE_VERSION_NUMBER > 3014000\r\n    auto exp = sqlite3_expanded_sql(res);\r\n    if (exp)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"DB %s\\n\", exp);\r\n        sqlite3_free(exp);\r\n    }\r\n#endif\r\n\r\n    int changes = -1;\r\n    rc = sqlite3_step(res);\r\n    if (rc == SQLITE_DONE)\r\n    {\r\n        changes = sqlite3_changes(db);\r\n    }\r\n    DBG_Assert(rc == SQLITE_DONE);\r\n\r\n    rc = sqlite3_finalize(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (changes == 1)\r\n    {\r\n        return; // done updating already existing entry\r\n    }\r\n\r\n    // 2) no existing entry, insert new entry\r\n    res = nullptr;\r\n    sql = \"INSERT INTO device_descriptors (device_id, endpoint, type, data, timestamp)\"\r\n          \" SELECT id, ?1, ?2, ?3, ?4\"\r\n          \" FROM devices WHERE mac = ?5\";\r\n\r\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, nullptr);\r\n    DBG_Assert(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 1, endpoint);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int(res, 2, type);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_blob(res, 3, data.constData(), data.size(), SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_int64(res, 4, now);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        rc = sqlite3_bind_text(res, 5, mac, -1, SQLITE_STATIC);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"DB failed %s\\n\", sqlite3_errmsg(db));\r\n        if (res)\r\n        {\r\n            rc = sqlite3_finalize(res);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n        return;\r\n    }\r\n\r\n#if SQLITE_VERSION_NUMBER > 3014000\r\n    exp = sqlite3_expanded_sql(res);\r\n    if (exp)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"DB %s\\n\", exp);\r\n        sqlite3_free(exp);\r\n    }\r\n#endif\r\n\r\n    rc = sqlite3_step(res);\r\n    if (rc == SQLITE_DONE)\r\n    {\r\n        changes = sqlite3_changes(db);\r\n        DBG_Assert(changes == 1);\r\n    }\r\n    rc = sqlite3_finalize(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n    closeDb();\r\n}\r\n\r\n/*! Push a zcl value sample in the database to keep track of value history.\r\n    The data might be a sensor reading or light state or any ZCL value.\r\n  */\r\nvoid DeRestPluginPrivate::pushZclValueDb(quint64 extAddress, quint8 endpoint, quint16 clusterId, quint16 attributeId, qint64 data)\r\n{\r\n    if (dbZclValueMaxAge <= 0)\r\n    {\r\n        return; // zcl value datastore disabled\r\n    }\r\n\r\n    /*\r\n\r\n    select mac, printf('0x%04X', cluster), data, datetime(zcl_values.timestamp,'unixepoch','localtime')\r\n    from zcl_values inner join devices ON zcl_values.device_id = devices.id\r\n    where zcl_values.timestamp > strftime('%s','now') - 300;\r\n\r\n    */\r\n    qint64 now = QDateTime::currentMSecsSinceEpoch() / 1000;\r\n    QString sql = QString(QLatin1String(\r\n                              \"INSERT INTO zcl_values (device_id,endpoint,cluster,attribute,data,timestamp) \"\r\n                              \"SELECT id, %2, %3, %4, %5, %6 \"\r\n                              \"FROM devices WHERE mac = '%1'\"))\r\n            .arg(generateUniqueId(extAddress, 0, 0))\r\n            .arg(endpoint)\r\n            .arg(clusterId)\r\n            .arg(attributeId)\r\n            .arg(data)\r\n            .arg(now);\r\n\r\n    dbQueryQueue.push_back(sql);\r\n    queSaveDb(DB_QUERY_QUEUE, (dbQueryQueue.size() > 30) ? DB_SHORT_SAVE_DELAY : DB_LONG_SAVE_DELAY);\r\n\r\n    // add a cleanup command if not already queued\r\n    for (const QString &q : dbQueryQueue)\r\n    {\r\n        if (q.startsWith(QLatin1String(\"DELETE FROM zcl_values\")))\r\n        {\r\n            return; // already queued\r\n        }\r\n    }\r\n\r\n    sql = QString(QLatin1String(\"DELETE FROM zcl_values WHERE timestamp < %1\")).arg(now - dbZclValueMaxAge);\r\n    dbQueryQueue.push_back(sql);\r\n}\r\n\r\nbool DeRestPluginPrivate::dbIsOpen() const\r\n{\r\n    return db != nullptr;\r\n}\r\n\r\n/*! Opens/creates sqlite database.\r\n */\r\nvoid DeRestPluginPrivate::openDb()\r\n{\r\n    //DBG_Assert(db == 0);\r\n\r\n    if (db)\r\n    {\r\n        ttlDataBaseConnection = idleTotalCounter + DB_CONNECTION_TTL;\r\n        return;\r\n    }\r\n\r\n    int rc = sqlite3_open(qPrintable(sqliteDatabaseName), &db);\r\n\r\n    if (rc != SQLITE_OK) {\r\n        // failed\r\n        DBG_Printf(DBG_ERROR, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\r\n        db = nullptr;\r\n        return;\r\n    }\r\n\r\n    const char *sql = \"PRAGMA foreign_keys = ON\"; // must be enabled at runtime for each connection\r\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, nullptr);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    ttlDataBaseConnection = idleTotalCounter + DB_CONNECTION_TTL;\r\n\r\n#ifdef DECONZ_DEBUG_BUILD\r\n    sqlite3_update_hook(db, DB_UpdateHook, this);\r\n#endif\r\n}\r\n\r\n/*! Reads all data sets from sqlite database.\r\n */\r\nvoid DeRestPluginPrivate::readDb()\r\n{\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    loadAuthFromDb();\r\n    loadConfigFromDb();\r\n    loadUserparameterFromDb();\r\n    loadAllGroupsFromDb();\r\n    loadAllResourcelinksFromDb();\r\n    loadAllScenesFromDb();\r\n    loadAllRulesFromDb();\r\n    loadAllSchedulesFromDb();\r\n    loadAllSensorsFromDb();\r\n    loadAllGatewaysFromDb();\r\n}\r\n\r\n/*! Sqlite callback to load authorisation data.\r\n */\r\nstatic int sqliteLoadAuthCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    Q_UNUSED(colname);\r\n    DBG_Assert(user != 0);\r\n    DBG_Assert(ncols == 5);\r\n\r\n    if (!user || (ncols != 5))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    // TODO remove old entries via lastusedate\r\n\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    ApiAuth auth;\r\n\r\n    auth.apikey = colval[0];\r\n    auth.setDeviceType(colval[1]);\r\n\r\n    if (colval[4])\r\n    {\r\n        auth.useragent = colval[4];\r\n    }\r\n\r\n    // fill in createdate and lastusedate\r\n    // if they not exist in database yet\r\n    if (colval[2] && colval[3])\r\n    {\r\n        auth.createDate = QDateTime::fromString(colval[2], \"yyyy-MM-ddTHH:mm:ss\"); // ISO 8601\r\n        auth.lastUseDate = QDateTime::fromString(colval[3], \"yyyy-MM-ddTHH:mm:ss\"); // ISO 8601\r\n    }\r\n    else\r\n    {\r\n        auth.createDate = QDateTime::currentDateTimeUtc();\r\n        auth.lastUseDate = QDateTime::currentDateTimeUtc();\r\n    }\r\n\r\n    if (!auth.createDate.isValid())\r\n    {\r\n        auth.createDate = QDateTime::currentDateTimeUtc();\r\n    }\r\n\r\n    if (!auth.lastUseDate.isValid())\r\n    {\r\n        auth.lastUseDate = QDateTime::currentDateTimeUtc();\r\n    }\r\n\r\n    auth.createDate.setTimeSpec(Qt::UTC);\r\n    auth.lastUseDate.setTimeSpec(Qt::UTC);\r\n\r\n    if (!auth.apikey.isEmpty() && !auth.devicetype.isEmpty())\r\n    {\r\n        d->apiAuths.push_back(auth);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all authorisation data from database.\r\n */\r\nvoid DeRestPluginPrivate::loadAuthFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(QLatin1String(\"SELECT apikey,devicetype,createdate,lastusedate,useragent FROM auth\"));\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAuthCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load configuration data.\r\n */\r\nstatic int sqliteLoadConfigCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    Q_UNUSED(colname);\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols != 2) || !colval)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (colval[0] && colval[1] && DBG_IsEnabled(DBG_INFO_L2))\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"Load config %s: %s from db.\\n\", colval[0], colval[1]);\r\n    }\r\n\r\n    bool ok;\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    QString val = QString::fromUtf8(colval[1]);\r\n\r\n    if (strcmp(colval[0], \"name\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwName = val;\r\n            d->gwConfig[\"name\"] = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"announceinterval\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            int minutes = val.toInt(&ok);\r\n            if (ok && (minutes >= 0))\r\n            {\r\n                d->gwAnnounceInterval = minutes;\r\n                d->gwConfig[\"announceinterval\"] = (double)minutes;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"announceurl\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            // ignore old gce entry, use default\r\n            if (!val.contains(QLatin1String(\"dresden-light.appspot.com\")))\r\n            {\r\n                d->gwAnnounceUrl = val;\r\n                d->gwConfig[\"announceurl\"] = val;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"rfconnect\") == 0)\r\n    {\r\n        // only reload from database if auto reconnect is disabled\r\n        if (!val.isEmpty() && deCONZ::appArgumentNumeric(\"--auto-connect\", 1) == 0)\r\n        {\r\n            int conn = val.toInt(&ok);\r\n            if (ok && ((conn == 0) || (conn == 1)))\r\n            {\r\n                d->gwRfConnectedExpected = (conn == 1);\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"networkopenduration\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint seconds = val.toUInt(&ok);\r\n            if (ok)\r\n            {\r\n                d->gwNetworkOpenDuration = seconds;\r\n                d->gwConfig[\"networkopenduration\"] = (double)seconds;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"timeformat\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwTimeFormat = val;\r\n            d->gwConfig[\"timeformat\"] = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"timezone\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwTimezone = val;\r\n            d->gwConfig[\"timezone\"] = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"rgbwdisplay\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwRgbwDisplay = val;\r\n            d->gwConfig[\"rgbwdisplay\"] = val;\r\n        }\r\n    }\r\n#if 0\r\n    else if (strcmp(colval[0], \"groupdelay\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint milliseconds = val.toUInt(&ok);\r\n            if (ok && (milliseconds <= MAX_GROUP_SEND_DELAY))\r\n            {\r\n                d->gwGroupSendDelay = milliseconds;\r\n                d->gwConfig[\"groupdelay\"] = (double)milliseconds;\r\n            }\r\n        }\r\n    }\r\n#endif\r\n    else if (strcmp(colval[0], \"zigbeechannel\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint zigbeechannel = val.toUInt(&ok);\r\n            if (ok && ((zigbeechannel == 0) || (zigbeechannel == 11) || (zigbeechannel == 15) || (zigbeechannel == 20) || (zigbeechannel == 25)))\r\n            {\r\n                d->gwZigbeeChannel = zigbeechannel;\r\n                d->gwConfig[\"zigbeechannel\"] = (uint)zigbeechannel;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"group0\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint group0 = val.toUInt(&ok);\r\n            if (ok && group0 > 0 && group0 <= 0xfff7) // 0 and larger than 0xfff7 is not valid for Osram Lightify\r\n            {\r\n                d->gwGroup0 = static_cast<quint16>(group0);\r\n                d->gwConfig[\"group0\"] = group0;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"updatechannel\") == 0)\r\n    {\r\n        if ((val == \"stable\") || (val == \"alpha\") || (val == \"beta\"))\r\n        {\r\n            d->gwUpdateChannel = val;\r\n            d->gwConfig[\"updatechannel\"] = val;\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB unexpected value for updatechannel: %s\\n\", qPrintable(val));\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"gwusername\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"gwusername\"] = val;\r\n            d->gwAdminUserName = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"gwpassword\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"gwpassword\"] = val;\r\n            d->gwAdminPasswordHash = val.toStdString();\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"uuid\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"uuid\"] = val;\r\n            d->gwUuid = val.replace(\"{\", \"\").replace(\"}\", \"\");\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"otauactive\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint otauActive = 1;\r\n\r\n            if (val == \"true\")\r\n            {\r\n                otauActive = 1;\r\n            }\r\n            else if (val == \"false\")\r\n            {\r\n                otauActive = 0;\r\n            }\r\n            else\r\n            {\r\n                otauActive = val.toUInt(&ok);\r\n                if (!ok || (otauActive != 0 && otauActive != 1))\r\n                {\r\n                    otauActive = 1;\r\n                }\r\n            }\r\n\r\n            if (d->apsCtrl)\r\n            {\r\n                d->apsCtrl->setParameter(deCONZ::ParamOtauActive, otauActive);\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifi\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wifi\"] = val;\r\n            d->gwWifi = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifichannel\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wifichannel\"] = val;\r\n            d->gwWifiChannel = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifiname\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wifiname\"] = val;\r\n            d->gwWifiName = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wificlientname\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wificlientname\"] = val;\r\n            d->gwWifiClientName = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifipw\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wifipw\"] = val;\r\n            d->gwWifiPw = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifipwenc\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wifipwenc\"] = val;\r\n            d->gwWifiPwEnc = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"workingpwenc\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"workingpwenc\"] = val;\r\n            d->gwWifiWorkingPwEnc = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifibackuppwenc\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wifibackuppwenc\"] = val;\r\n            d->gwWifiBackupPwEnc = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifibackuppw\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wifibackuppw\"] = val;\r\n            d->gwWifiBackupPw = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifibackupname\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wifibackupname\"] = val;\r\n            d->gwWifiBackupName = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wificlientpw\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"wificlientpw\"] = val;\r\n            d->gwWifiClientPw = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifitype\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wifitype\"] = val;\r\n            d->gwWifiType = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"workingtype\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"workingtype\"] = val;\r\n            d->gwWifiWorkingType = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"workingname\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"workingname\"] = val;\r\n            d->gwWifiWorkingName = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"workingpw\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            //d->gwConfig[\"workingpw\"] = val;\r\n            d->gwWifiWorkingPw = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifiip\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"wifiip\"] = val;\r\n            d->gwWifiIp = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"wifilastupdated\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            uint lastupdated = val.toUInt(&ok);\r\n            if (ok)\r\n            {\r\n                d->gwConfig[\"wifilastupdated\"] = (uint)lastupdated;\r\n                d->gwWifiLastUpdated = lastupdated;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"homebridge\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"homebridge\"] = val;\r\n            d->gwHomebridge = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"homebridgeversion\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"homebridgeversion\"] = val;\r\n            d->gwHomebridgeVersion = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"homebridgeupdateversion\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"homebridgeupdateversion\"] = val;\r\n            d->gwHomebridgeUpdateVersion = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"homebridgeupdate\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            if (val == \"true\")\r\n            {\r\n                d->gwConfig[\"homebridgeupdate\"] = true;\r\n                d->gwHomebridgeUpdate = true;\r\n            }\r\n            else\r\n            {\r\n                d->gwConfig[\"homebridgeupdate\"] = false;\r\n                d->gwHomebridgeUpdate = false;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"homebridge-pin\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"homebridgepin\"] = val;\r\n            d->gwHomebridgePin = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"userparameter\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"userparameter\"] = Json::parse(val);\r\n            bool ok;\r\n            QVariant var = Json::parse(val, ok);\r\n\r\n            if (ok)\r\n            {\r\n                QVariantMap map = var.toMap();\r\n                d->gwUserParameter = map;\r\n            }\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"bridgeid\") == 0)\r\n    {\r\n      if (!val.isEmpty())\r\n      {\r\n          d->gwConfig[\"bridgeid\"] = val;\r\n          d->gwBridgeId = val;\r\n      }\r\n    }\r\n    else if (strcmp(colval[0], \"websocketport\") == 0)\r\n    {\r\n        quint16 port = val.toUInt(&ok);\r\n        if (!val.isEmpty() && ok)\r\n        {\r\n            d->gwConfig[\"websocketport\"] = port;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"websocketnotifyall\") == 0)\r\n    {\r\n      if (!val.isEmpty())\r\n      {\r\n          bool notifyAll = val == \"true\";\r\n          d->gwConfig[\"websocketnotifyall\"] = notifyAll;\r\n          d->gwWebSocketNotifyAll = notifyAll;\r\n      }\r\n    }\r\n    else if (strcmp(colval[0], \"disablePermitJoinAutoOff\") == 0)\r\n    {\r\n      if (!val.isEmpty())\r\n      {\r\n          bool v = val == \"true\";\r\n          d->gwConfig[\"disablePermitJoinAutoOff\"] = v;\r\n          d->gwdisablePermitJoinAutoOff = v;\r\n      }\r\n    }\r\n    else if (strcmp(colval[0], \"proxyaddress\") == 0)\r\n    {\r\n      if (!val.isEmpty())\r\n      {\r\n          d->gwConfig[\"proxyaddress\"] = val;\r\n          d->gwProxyAddress = val;\r\n      }\r\n    }\r\n    else if (strcmp(colval[0], \"proxyport\") == 0)\r\n    {\r\n        quint16 port = val.toUInt(&ok);\r\n        if (!val.isEmpty() && ok)\r\n        {\r\n            d->gwConfig[\"proxyport\"] = port;\r\n            d->gwProxyPort = port;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"swupdatestate\") == 0)\r\n    {\r\n        if (!val.isEmpty())\r\n        {\r\n            d->gwConfig[\"swupdatestate\"] = val;\r\n            d->gwSwUpdateState = val;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"zclvaluemaxage\") == 0)\r\n    {\r\n        qint64 maxAge = val.toLongLong(&ok);\r\n        if (!val.isEmpty() && ok)\r\n        {\r\n            d->gwConfig[\"zclvaluemaxage\"] = maxAge;\r\n            d->dbZclValueMaxAge = maxAge;\r\n        }\r\n    }\r\n    else if (strcmp(colval[0], \"lightlastseeninterval\") == 0)\r\n    {\r\n        int lightLastSeen = val.toUInt(&ok);\r\n        if (!val.isEmpty() && ok)\r\n        {\r\n            d->gwConfig[\"lightlastseeninterval\"] = lightLastSeen;\r\n            d->gwLightLastSeenInterval = lightLastSeen;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Sqlite callback to load userparameter data.\r\n */\r\nstatic int sqliteLoadUserparameterCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    Q_UNUSED(colname);\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols != 2))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    QString key = QString::fromUtf8(colval[0]);\r\n    QString val = QString::fromUtf8(colval[1]);\r\n\r\n    if (!val.isEmpty())\r\n    {\r\n        d->gwUserParameter[key] = val;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all config from database\r\n */\r\nvoid DeRestPluginPrivate::loadConfigFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString configTable = \"config\"; // default config table version 1\r\n\r\n    // check if config table version 2\r\n    {\r\n        QString sql = QString(\"SELECT key FROM config2\");\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        errmsg = NULL;\r\n        rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            configTable = \"config2\";\r\n        }\r\n    }\r\n\r\n    {\r\n        QString sql = QString(\"SELECT key,value FROM %1\").arg(configTable);\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadConfigCallback, this, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Loads all config from database\r\n */\r\nvoid DeRestPluginPrivate::loadSwUpdateStateFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    {\r\n        QString sql = QLatin1String(\"SELECT * FROM config2 WHERE key='swupdatestate'\");\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadConfigCallback, this, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Loads wifi information from database\r\n */\r\nvoid DeRestPluginPrivate::loadWifiInformationFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    {\r\n        QString sql;\r\n        sql = QLatin1String(\"SELECT * FROM config2 WHERE key='wifitype'\");\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadConfigCallback, this, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n        sql = QLatin1String(\"SELECT * FROM config2 WHERE key='wifi'\");\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadConfigCallback, this, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Loads all userparameter from database\r\n */\r\nvoid DeRestPluginPrivate::loadUserparameterFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    {\r\n        QString sql = QString(\"SELECT key,value FROM %1\").arg(\"userparameter\");\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadUserparameterCallback, this, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a group.\r\n\r\n    Groups will only be added to cache if not already known.\r\n    Known groups will not be overwritten.\r\n */\r\nstatic int sqliteLoadAllGroupsCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    bool ok;\r\n    Group group;\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite group: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n\r\n            if (strcmp(colname[i], \"gid\") == 0)\r\n            {\r\n                group.setAddress(val.toUInt(&ok, 16));\r\n\r\n                if (!ok)\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"Error group in DB has no valid id: %s\\n\", colval[i]);\r\n                    return 0;\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                group.setName(val);\r\n            }\r\n            else if (strcmp(colname[i], \"state\") == 0)\r\n            {\r\n                if (val == QLatin1String(\"deleted\"))\r\n                {\r\n                    group.setState(Group::StateDeleted);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"mids\") == 0)\r\n            {\r\n                group.setMidsFromString(val);\r\n            }\r\n            else if (strcmp(colname[i], \"lightsequence\") == 0)\r\n            {\r\n                group.setLightsequenceFromString(val);\r\n            }\r\n            else if (strcmp(colname[i], \"devicemembership\") == 0)\r\n            {\r\n                group.setDmFromString(val);\r\n            }\r\n            else if (strcmp(colname[i], \"hidden\") == 0)\r\n            {\r\n                bool hidden = (val == QLatin1String(\"true\")) ? true : false;\r\n                group.hidden = hidden;\r\n            }\r\n            else if (strcmp(colname[i], \"type\") == 0)\r\n            {\r\n                ResourceItem *item = group.item(RAttrType);\r\n                if (item && !val.isEmpty())\r\n                {\r\n                    item->setValue(val);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"class\") == 0)\r\n            {\r\n                ResourceItem *item = group.item(RAttrClass);\r\n                if (item && !val.isEmpty())\r\n                {\r\n                    item->setValue(val);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"uniqueid\") == 0)\r\n            {\r\n                ResourceItem *item = 0;\r\n                if (!val.isEmpty())\r\n                {\r\n                    item = group.addItem(DataTypeString, RAttrUniqueId);\r\n                }\r\n\r\n                if (item)\r\n                {\r\n                    item->setValue(val);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!group.id().isEmpty() && !group.name().isEmpty())\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"DB found group %s 0x%04X\\n\", qPrintable(group.name()), group.address());\r\n        // check doubles\r\n        Group *g = d->getGroupForId(group.id());\r\n        if (!g)\r\n        {\r\n            // append to cache if not already known\r\n            d->updateEtag(group.etag);\r\n            d->groups.push_back(group);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all groups from database.\r\n */\r\nvoid DeRestPluginPrivate::loadAllGroupsFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM groups\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllGroupsCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for all resourcelinks.\r\n\r\n    Resourcelinks will only be added to cache if not already known.\r\n */\r\nstatic int sqliteLoadAllResourcelinksCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Resourcelinks rl;\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite resourcelink: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n\r\n            if (strcmp(colname[i], \"id\") == 0)\r\n            {\r\n                rl.id = val;\r\n\r\n                if (rl.id.isEmpty())\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"Error resourcelink in DB has no valid id: %s\\n\", colval[i]);\r\n                    return 0;\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"json\") == 0)\r\n            {\r\n                bool ok;\r\n                rl.data = Json::parse(val, ok).toMap();\r\n\r\n                if (!ok)\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"Error resourcelink in DB has no valid json string: %s\\n\", colval[i]);\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const Resourcelinks &r : d->resourcelinks)\r\n    {\r\n        if (r.id == rl.id)\r\n        {\r\n            // already exist in cache\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    if (!rl.data.contains(QLatin1String(\"description\")) || rl.data[\"description\"].toString().isNull())\r\n    {\r\n        rl.data[\"description\"] = QLatin1String(\"\");\r\n    }\r\n\r\n    d->resourcelinks.push_back(rl);\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all resourcelinks from database.\r\n */\r\nvoid DeRestPluginPrivate::loadAllResourcelinksFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM resourcelinks\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllResourcelinksCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a scene.\r\n\r\n    Scenes will only be added to cache if not already known.\r\n    Known scenes will not be overwritten.\r\n */\r\nstatic int sqliteLoadAllScenesCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    bool ok = false;\r\n    bool ok1 = false;\r\n    bool ok2 = false;\r\n    Scene scene{};\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite scene: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n            if (strcmp(colname[i], \"gid\") == 0)\r\n            {\r\n                scene.groupAddress = val.toUInt(&ok1, 16);\r\n            }\r\n            else if (strcmp(colname[i], \"sid\") == 0)\r\n            {\r\n                scene.id = val.toUInt(&ok2, 16);\r\n            }\r\n            else if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                scene.name = val;\r\n            }\r\n            else if (strcmp(colname[i], \"transitiontime\") == 0)\r\n            {\r\n                scene.setTransitiontime(val.toUInt(&ok));\r\n            }\r\n            else if (strcmp(colname[i], \"lights\") == 0)\r\n            {\r\n                scene.setLights(Scene::jsonToLights(val));\r\n            }\r\n        }\r\n    }\r\n\r\n    if (ok1 && ok2)\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"DB found scene sid: 0x%02X, gid: 0x%04X\\n\", scene.id, scene.groupAddress);\r\n\r\n        Group *g = d->getGroupForId(scene.groupAddress);\r\n        if (g)\r\n        {\r\n            // append scene to group if not already known\r\n            Scene *s = d->getSceneForId(scene.groupAddress,scene.id);\r\n            if (!s)\r\n            {\r\n                // append scene to group if not already known\r\n                d->updateEtag(g->etag);\r\n                g->scenes.push_back(scene);\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all scenes from database.\r\n */\r\nvoid DeRestPluginPrivate::loadAllScenesFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM scenes\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllScenesCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a schedule.\r\n */\r\nstatic int sqliteLoadAllSchedulesCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Schedule schedule;\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite schedule: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n\r\n            if (strcmp(colname[i], \"id\") == 0)\r\n            {\r\n                schedule.id = val;\r\n\r\n                if (schedule.id.isEmpty())\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"Error schedule in DB has no valid id: %s\\n\", colval[i]);\r\n                    return 0;\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"json\") == 0)\r\n            {\r\n                schedule.jsonString = val;\r\n\r\n                if (schedule.jsonString.isEmpty())\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"Error schedule in DB has no valid json string: %s\\n\", colval[i]);\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    std::vector<Schedule>::const_iterator i = d->schedules.begin();\r\n    std::vector<Schedule>::const_iterator end = d->schedules.end();\r\n\r\n    for (;i != end; ++i)\r\n    {\r\n        if (i->id == schedule.id)\r\n        {\r\n            // already exist in cache\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    if (d->jsonToSchedule(schedule.jsonString, schedule, NULL))\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"DB parsed schedule %s\\n\", qPrintable(schedule.id));\r\n        d->schedules.push_back(schedule);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all schedules from database.\r\n */\r\nvoid DeRestPluginPrivate::loadAllSchedulesFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM schedules\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllSchedulesCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*! Load sensor data from database.\r\n */\r\nvoid DeRestPluginPrivate::loadSensorDataFromDb(Sensor *sensor, QVariantList &ls, qint64 fromTime, int max)\r\n{\r\n    DBG_Assert(db);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    DBG_Assert(sensor);\r\n\r\n    if (!sensor)\r\n    {\r\n        return;\r\n    }\r\n\r\n    struct RMap {\r\n        const char *item;\r\n        quint16 clusterId;\r\n        quint16 attributeId;\r\n    };\r\n\r\n    const RMap rmap[] = {\r\n        // Item, clusterId, attributeId\r\n        { RStatePresence, 0x0406, 0x0000 },\r\n        { RStatePresence, 0x0500, 0x0000 },\r\n        { RStateLightLevel, 0x0400, 0x0000 },\r\n        { RStateTemperature, 0x0402, 0x0000 },\r\n        { RStateHumidity, 0x0405, 0x0000 },\r\n        { RStateOpen, 0x0006, 0x0000 },\r\n        { RStateOpen, 0x0500, 0x0000 },\r\n        { nullptr, 0, 0 }\r\n    };\r\n\r\n    const RMap *r = rmap;\r\n\r\n    while (r->item)\r\n    {\r\n        for (int i  = 0; i < sensor->itemCount(); i++)\r\n        {\r\n            ResourceItem *item = sensor->itemForIndex(static_cast<size_t>(i));\r\n\r\n            if (r->item != item->descriptor().suffix)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const char *sql = \"SELECT data,timestamp FROM sensor_device_value_view \"\r\n                              \"WHERE sensor_id = ?1 AND timestamp > ?2 AND cluster_id = ?3 limit ?4\";\r\n\r\n            int rc;\r\n            int sid = sensor->id().toInt();\r\n            sqlite3_stmt *res = nullptr;\r\n\r\n            rc = sqlite3_prepare_v2(db, sql, -1, &res, nullptr);\r\n            DBG_Assert(res != nullptr);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n\r\n            if (rc == SQLITE_OK)\r\n            {\r\n                rc = sqlite3_bind_int(res, 1, sid);\r\n                DBG_Assert(rc == SQLITE_OK);\r\n            }\r\n\r\n            if (rc == SQLITE_OK)\r\n            {\r\n                rc = sqlite3_bind_int64(res, 2, fromTime);\r\n                DBG_Assert(rc == SQLITE_OK);\r\n            }\r\n\r\n            if (rc == SQLITE_OK)\r\n            {\r\n                rc = sqlite3_bind_int(res, 3, r->clusterId);\r\n                DBG_Assert(rc == SQLITE_OK);\r\n            }\r\n\r\n            if (rc == SQLITE_OK)\r\n            {\r\n                rc = sqlite3_bind_int(res, 4, max);\r\n                DBG_Assert(rc == SQLITE_OK);\r\n            }\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (res)\r\n                {\r\n                    rc = sqlite3_finalize(res);\r\n                    DBG_Assert(rc == SQLITE_OK);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            while (sqlite3_step(res) == SQLITE_ROW)\r\n            {\r\n                QVariantMap map;\r\n                qint64 val = sqlite3_column_int64(res, 0);\r\n                qint64 timestamp = sqlite3_column_int64(res, 1);\r\n\r\n                QDateTime dateTime;\r\n                dateTime.setMSecsSinceEpoch(timestamp * 1000);\r\n                map[item->descriptor().suffix] = val;\r\n                map[\"t\"] = dateTime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n                ls.append(map);\r\n            }\r\n\r\n            rc = sqlite3_finalize(res);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n        r++;\r\n    }\r\n}\r\n\r\n/*! Load light from database.\r\n */\r\nvoid DeRestPluginPrivate::loadLightDataFromDb(LightNode *lightNode, QVariantList &ls, qint64 fromTime, int max)\r\n{\r\n    DBG_Assert(db);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    DBG_Assert(lightNode);\r\n\r\n    if (!lightNode)\r\n    {\r\n        return;\r\n    }\r\n\r\n    struct RMap {\r\n        const char *item;\r\n        quint16 clusterId;\r\n        quint16 attributeId;\r\n    };\r\n\r\n    const RMap rmap[] = {\r\n        // Item, clusterId, attributeId\r\n        { RStateOn, 0x0006, 0x0000 },\r\n        { RStateLightLevel, 0x0008, 0x0000 },\r\n        { nullptr, 0, 0 }\r\n    };\r\n\r\n    for (int i  = 0; i < lightNode->itemCount(); i++)\r\n    {\r\n        ResourceItem *item = lightNode->itemForIndex(i);\r\n        const RMap *found = nullptr;\r\n        const RMap *r = rmap;\r\n\r\n        while (!found && r->item)\r\n        {\r\n            if (r->item == item->descriptor().suffix)\r\n            {\r\n              found = r;\r\n              break;\r\n            }\r\n            r++;\r\n        }\r\n\r\n        if (!found)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        const char *sql = \"SELECT data,timestamp FROM light_device_value_view \"\r\n                          \"WHERE light_id = ?1 AND timestamp > ?2 AND cluster_id = ?3 limit ?4\";\r\n\r\n        int rc;\r\n        int sid = lightNode->id().toInt();\r\n        sqlite3_stmt *res = nullptr;\r\n\r\n        rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\r\n        DBG_Assert(res != nullptr);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            rc = sqlite3_bind_int(res, 1, sid);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            rc = sqlite3_bind_int(res, 2, fromTime);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            rc = sqlite3_bind_int(res, 3, found->clusterId);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n\r\n        // TODO zcl attribute\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            rc = sqlite3_bind_int(res, 4, max);\r\n            DBG_Assert(rc == SQLITE_OK);\r\n        }\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (res)\r\n            {\r\n                rc = sqlite3_finalize(res);\r\n                DBG_Assert(rc == SQLITE_OK);\r\n            }\r\n            continue;\r\n        }\r\n\r\n        while (sqlite3_step(res) == SQLITE_ROW)\r\n        {\r\n            QVariantMap map;\r\n            qint64 val = sqlite3_column_int64(res, 0);\r\n            qint64 timestamp = sqlite3_column_int64(res, 1);\r\n\r\n            QDateTime dateTime;\r\n            dateTime.setMSecsSinceEpoch(timestamp * 1000);\r\n            map[item->descriptor().suffix] = val;\r\n            map[\"t\"] = dateTime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n            ls.append(map);\r\n        }\r\n\r\n        rc = sqlite3_finalize(res);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a node (identified by its mac address).\r\n */\r\nstatic int sqliteLoadLightNodeCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    DB_Callback *cb = static_cast<DB_Callback*>(user);\r\n    LightNode *lightNode = cb->lightNode;\r\n\r\n    DBG_Assert(cb);\r\n    DBG_Assert(cb->d);\r\n    DBG_Assert(lightNode);\r\n\r\n    QString id;\r\n    QString name;\r\n    QStringList groupIds;\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            if (strcmp(colname[i], \"mac\") == 0)\r\n            {\r\n                if (val != lightNode->uniqueId())\r\n                {\r\n                    // force update and cleanup of light node db entry\r\n                    lightNode->setNeedSaveDatabase(true);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"endpoint\") == 0)\r\n            {\r\n                bool ok;\r\n                uint endpoint = val.toUInt(&ok);\r\n                if (ok && endpoint > 0 && endpoint < 255)\r\n                {\r\n                    if (lightNode->haEndpoint().endpoint() != endpoint)\r\n                    {\r\n                        return 0; // not the node\r\n                    }\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                name = val;\r\n            }\r\n            else if (strcmp(colname[i], \"modelid\") == 0)\r\n            {\r\n                if (!val.isEmpty())\r\n                {\r\n                    lightNode->setModelId(val);\r\n                    lightNode->item(RAttrModelId)->setValue(val);\r\n                    lightNode->clearRead(READ_MODEL_ID);\r\n                    cb->d->setLightNodeStaticCapabilities(lightNode);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"manufacturername\") == 0)\r\n            {\r\n                if (!val.isEmpty())\r\n                {\r\n                    lightNode->setManufacturerName(val);\r\n                    lightNode->clearRead(READ_VENDOR_NAME);\r\n                    cb->d->setLightNodeStaticCapabilities(lightNode);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"swbuildid\") == 0)\r\n            {\r\n                if (!val.isEmpty() && 0 != val.compare(QLatin1String(\"Unknown\"), Qt::CaseInsensitive))\r\n                {\r\n                    lightNode->setSwBuildId(val);\r\n                    lightNode->clearRead(READ_SWBUILD_ID);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"id\") == 0)\r\n            {\r\n                id = val;\r\n            }\r\n            else if (strcmp(colname[i], \"groups\") == 0)\r\n            {\r\n                groupIds = val.split(\",\");\r\n            }\r\n            else if (strcmp(colname[i], \"state\") == 0)\r\n            {\r\n                if (val == QLatin1String(\"deleted\"))\r\n                {\r\n                    lightNode->setState(LightNode::StateDeleted);\r\n                }\r\n                else\r\n                {\r\n                    lightNode->setState(LightNode::StateNormal);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"ritems\") == 0 && !val.isEmpty())\r\n            {\r\n                lightNode->jsonToResourceItems(val);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!id.isEmpty())\r\n    {\r\n        lightNode->setId(id);\r\n    }\r\n\r\n    if (!name.isEmpty())\r\n    {\r\n        lightNode->setName(name);\r\n    }\r\n\r\n    auto gi = groupIds.cbegin();\r\n    const auto gend = groupIds.cend();\r\n\r\n    for (; gi != gend; ++gi)\r\n    {\r\n        bool ok;\r\n        quint16 gid = gi->toUShort(&ok);\r\n\r\n        if (!ok)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        // already known?\r\n        auto k = lightNode->groups().cbegin();\r\n        const auto kend = lightNode->groups().cend();\r\n\r\n        for (; k != kend; ++k)\r\n        {\r\n            if (k->id == gid)\r\n            {\r\n                ok = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            GroupInfo groupInfo;\r\n            groupInfo.id = gid;\r\n            groupInfo.state = GroupInfo::StateInGroup;\r\n            lightNode->groups().push_back(groupInfo);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads data (if available) for a LightNode from the database according to the adress\r\n */\r\nQString DeRestPluginPrivate::loadDataForLightNodeFromDb(QString extAddress)\r\n{\r\n    QString result;\r\n    DBG_Assert(db != nullptr);\r\n\r\n    if (!db || extAddress.isEmpty())\r\n    {\r\n        return result;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT manufacturername FROM nodes WHERE mac LIKE '%1%' COLLATE NOCASE\").arg(extAddress);\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n\r\n    const char * val = nullptr;\r\n    sqlite3_stmt *res = nullptr;\r\n    int rc;\r\n\r\n    rc = sqlite3_prepare_v2(db, qPrintable(sql), -1, &res, nullptr);\r\n    if (rc == SQLITE_OK)\r\n    {\r\n\t\trc = sqlite3_step(res);\r\n\t}\r\n\r\n    if (rc == SQLITE_ROW)\r\n    {\r\n        val = reinterpret_cast<const char*>(sqlite3_column_text(res, 0));\r\n        if (val)\r\n        {\r\n            result = val;\r\n            DBG_Printf(DBG_INFO, \"DB %s: %s\\n\", qPrintable(sql), qPrintable(val));\r\n        }\r\n    }\r\n\r\n    if (res)\r\n    {\r\n        rc = sqlite3_finalize(res);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*! Loads data (if available) for a LightNode from the database.\r\n */\r\nvoid DeRestPluginPrivate::loadLightNodeFromDb(LightNode *lightNode)\r\n{\r\n    int rc;\r\n    char *errmsg = nullptr;\r\n\r\n    DBG_Assert(db != nullptr);\r\n    DBG_Assert(lightNode != nullptr);\r\n\r\n    if (!db || !lightNode)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // check for new uniqueId format\r\n    QString sql = QString(\"SELECT * FROM nodes WHERE mac='%1' COLLATE NOCASE AND state != 'deleted'\").arg(lightNode->uniqueId());\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n\r\n    DB_Callback cb;\r\n    cb.d = this;\r\n    cb.lightNode = lightNode;\r\n\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadLightNodeCallback, &cb, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    if (lightNode->needSaveDatabase())\r\n    {\r\n        queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    // check for unique IDs\r\n    if (!lightNode->id().isEmpty())\r\n    {\r\n        std::vector<LightNode>::iterator i = nodes.begin();\r\n        std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (&(*i) != lightNode)\r\n            {\r\n                // id already set to another node\r\n                // empty it here so a new one will be generated\r\n                if (i->id() == lightNode->id())\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"detected already used id %s, force generate new id\\n\", qPrintable(i->id()));\r\n                    lightNode->setId(\"\");\r\n                    queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a group (identified by its group id).\r\n */\r\nstatic int sqliteLoadGroupCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Group *group = static_cast<Group*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                group->setName(val);\r\n            }\r\n            else if (strcmp(colname[i], \"state\") == 0)\r\n            {\r\n                if (val == \"deleted\")\r\n                {\r\n                    group->setState(Group::StateDeleted);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads data (if available) for a Group from the database.\r\n */\r\nvoid DeRestPluginPrivate::loadGroupFromDb(Group *group)\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n    DBG_Assert(group != 0);\r\n\r\n    if (!db || !group)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString gid = QString(\"%1\").arg(group->address(), 4, 16, QLatin1Char('0'));\r\n    QString sql = QString(\"SELECT * FROM groups WHERE gid='%1'\").arg(gid);\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadGroupCallback, group, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a scene (identified by its scene id).\r\n */\r\nstatic int sqliteLoadSceneCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Scene *scene = static_cast<Scene*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++) {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                scene->name = QString::fromUtf8(colval[i]);\r\n            }\r\n            if (strcmp(colname[i], \"transitiontime\") == 0)\r\n            {\r\n                QString tt = QString::fromUtf8(colval[i]);\r\n                scene->setTransitiontime(tt.toUInt());\r\n            }\r\n            if (strcmp(colname[i], \"lights\") == 0)\r\n            {\r\n                scene->setLights(Scene::jsonToLights(colval[i]));\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads data (if available) for a Scene from the database.\r\n */\r\nvoid DeRestPluginPrivate::loadSceneFromDb(Scene *scene)\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n    DBG_Assert(scene != 0);\r\n\r\n    if (!db || !scene)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString gsid = \"0x\" + QString(\"%1%2\")\r\n                       .arg(scene->groupAddress, 4, 16, QLatin1Char('0'))\r\n                       .arg(scene->id, 2, 16, QLatin1Char('0')).toUpper(); // unique key\r\n\r\n    QString sql = QString(\"SELECT * FROM scenes WHERE gsid='%1'\").arg(gsid);\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadSceneCallback, scene, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a rule.\r\n\r\n    Rule will only be added to cache if not already known.\r\n */\r\nstatic int sqliteLoadAllRulesCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Rule rule;\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite rules: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n\r\n            if (strcmp(colname[i], \"rid\") == 0)\r\n            {\r\n                rule.setId(val);\r\n            }\r\n            else if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                rule.setName(val);\r\n            }\r\n            else if (strcmp(colname[i], \"created\") == 0)\r\n            {\r\n                rule.setCreationtime(val);\r\n            }\r\n            else if (strcmp(colname[i], \"etag\") == 0)\r\n            {\r\n                rule.etag = val;\r\n            }\r\n#if 0 // don't reload for now, see https://github.com/dresden-elektronik/deconz-rest-plugin/pull/7672\r\n      // the values are still stored in the database for the last session to provide debugging hints\r\n            else if (strcmp(colname[i], \"lasttriggered\") == 0)\r\n            {\r\n                if (colval[i][0] >= '0' && colval[i][0] <= '9') // isdigit()\r\n                {\r\n                    rule.m_lastTriggered = QDateTime::fromString(val, QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\"));\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"timestriggered\") == 0)\r\n            {\r\n                rule.setTimesTriggered(val.toUInt());\r\n            }\r\n#endif\r\n            else if (strcmp(colname[i], \"owner\") == 0)\r\n            {\r\n                rule.setOwner(val);\r\n            }\r\n            else if (strcmp(colname[i], \"status\") == 0)\r\n            {\r\n                rule.setStatus(val);\r\n            }\r\n            else if (strcmp(colname[i], \"actions\") == 0)\r\n            {\r\n                rule.setActions(Rule::jsonToActions(val));\r\n            }\r\n            else if (strcmp(colname[i], \"conditions\") == 0)\r\n            {\r\n                rule.setConditions(Rule::jsonToConditions(val));\r\n            }\r\n            else if (strcmp(colname[i], \"periodic\") == 0)\r\n            {\r\n                bool ok;\r\n                int periodic = val.toUInt(&ok);\r\n                if (ok)\r\n                {\r\n                    rule.setTriggerPeriodic(periodic);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!rule.id().isEmpty() && !rule.name().isEmpty())\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"DB found rule %s %s\\n\", qPrintable(rule.name()), qPrintable(rule.id()));\r\n        // check doubles\r\n        Rule *r = d->getRuleForId(rule.id());\r\n        if (!r)\r\n        {\r\n            // append to cache if not already known\r\n            d->updateEtag(rule.etag);\r\n            d->rules.push_back(rule);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all rules from database\r\n */\r\nvoid DeRestPluginPrivate::loadAllRulesFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM rules\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllRulesCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load data for a sensor.\r\n\r\n    Sensor will only be added to cache if not already known.\r\n */\r\nstatic int sqliteLoadAllSensorsCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    Sensor sensor;\r\n    QDateTime startTime = QDateTime::currentDateTimeUtc();\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    int configCol = -1;\r\n    int stateCol = -1;\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            QString val = QString::fromUtf8(colval[i]);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"Sqlite sensors: %s = %s\\n\", colname[i], qPrintable(val));\r\n\r\n            if (strcmp(colname[i], \"sid\") == 0)\r\n            {\r\n                sensor.setId(val);\r\n            }\r\n            else if (strcmp(colname[i], \"name\") == 0)\r\n            {\r\n                sensor.setName(val);\r\n            }\r\n            else if (strcmp(colname[i], \"type\") == 0)\r\n            {\r\n                if (val == QLatin1String(\"ZHALight\"))\r\n                {\r\n                    val = QLatin1String(\"ZHALightLevel\");\r\n                    sensor.setNeedSaveDatabase(true);\r\n                }\r\n                sensor.setType(val);\r\n            }\r\n            else if (strcmp(colname[i], \"modelid\") == 0)\r\n            {\r\n                sensor.setModelId(val.simplified());\r\n            }\r\n            else if (strcmp(colname[i], \"mode\") == 0)\r\n            {\r\n                sensor.setMode((Sensor::SensorMode)val.toUInt());\r\n            }\r\n            else if (strcmp(colname[i], \"etag\") == 0)\r\n            {\r\n                sensor.etag = val;\r\n            }\r\n            else if (strcmp(colname[i], \"manufacturername\") == 0)\r\n            {\r\n                sensor.setManufacturer(val.simplified());\r\n            }\r\n            else if (strcmp(colname[i], \"uniqueid\") == 0)\r\n            {\r\n                sensor.setUniqueId(val);\r\n            }\r\n            else if (strcmp(colname[i], \"swversion\") == 0)\r\n            {\r\n                sensor.setSwVersion(val.simplified());\r\n            }\r\n            else if (strcmp(colname[i], \"state\") == 0)\r\n            {\r\n                stateCol = i;\r\n            }\r\n            else if (strcmp(colname[i], \"config\") == 0)\r\n            {\r\n                configCol = i;\r\n            }\r\n            else if (strcmp(colname[i], \"fingerprint\") == 0)\r\n            {\r\n                SensorFingerprint fp;\r\n                if (fp.readFromJsonString(val))\r\n                {\r\n                    sensor.fingerPrint() = fp;\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"deletedState\") == 0)\r\n            {\r\n                if (val == QLatin1String(\"deleted\"))\r\n                {\r\n                    sensor.setDeletedState(Sensor::StateDeleted);\r\n                    return 0;\r\n                }\r\n                else\r\n                {\r\n                    sensor.setDeletedState(Sensor::StateNormal);\r\n                }\r\n            }\r\n            else if (strcmp(colname[i], \"lastseen\") == 0)\r\n            {\r\n                sensor.setLastSeen(val);\r\n            }\r\n            else if (strcmp(colname[i], \"lastannounced\") == 0)\r\n            {\r\n                sensor.setLastAnnounced(val);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!sensor.id().isEmpty() && !sensor.name().isEmpty() && !sensor.type().isEmpty())\r\n    {\r\n        bool ok;\r\n        bool isClip = sensor.type().startsWith(QLatin1String(\"CLIP\"));\r\n        ResourceItem *item = nullptr;\r\n        quint64 extAddr = 0;\r\n        quint16 clusterId = 0;\r\n        quint8 endpoint = sensor.fingerPrint().endpoint;\r\n\r\n\r\n        if (!isClip && sensor.type() == QLatin1String(\"Daylight\"))\r\n        {\r\n            isClip = true;\r\n        }\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"DB found sensor %s %s\\n\", qPrintable(sensor.name()), qPrintable(sensor.id()));\r\n\r\n        if (!isClip)\r\n        {\r\n            // ignore DDF \"matchexpr\" at this stage since the node is not yet fully loaded\r\n            const auto &ddf = d->deviceDescriptions->get(&sensor, DDF_IgnoreMatchExpr);\r\n            if (ddf.isValid())\r\n            {\r\n                unsigned ep = endpointFromUniqueId(sensor.uniqueId());\r\n                if (ep == 0xFF || ep == 0)\r\n                {\r\n                    // in earlier versions the sensor was created from an DDF draft device with not yet set endpoint\r\n                    // TODO(mpi): delete sensor from DB\r\n                    // SELECT * FROM sensors where uniqueid LIKE '%-ff-%'\r\n                    DBG_Printf(DBG_INFO, \"DB skip loading sensor %s %s, invalid endpoint 0xff\\n\", qPrintable(sensor.name()), qPrintable(sensor.uniqueId()));\r\n                    return 0;\r\n                }\r\n\r\n                if (DEV_TestManaged() || DDF_IsStatusEnabled(ddf.status))\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"DB skip loading sensor %s %s, handled by DDF %s\\n\", qPrintable(sensor.name()), qPrintable(sensor.id()), qPrintable(ddf.product));\r\n                    return 0;\r\n                }\r\n                \r\n                DBG_Printf(DBG_INFO, \"DB legacy loading sensor %s %s, should be added into DDF %s\\n\", qPrintable(sensor.name()), qPrintable(sensor.id()), qPrintable(ddf.product));\r\n            }\r\n        }\r\n\r\n        if (isClip)\r\n        {\r\n            sensor.removeItem(RAttrLastAnnounced);\r\n            sensor.removeItem(RAttrLastSeen);\r\n            ok = true;\r\n        }\r\n        // convert from old format 0x0011223344556677 to 00:11:22:33:44:55:66:77-AB where AB is the endpoint\r\n        else if (sensor.uniqueId().startsWith(QLatin1String(\"0x\")))\r\n        {\r\n            extAddr = sensor.uniqueId().toULongLong(&ok, 16);\r\n        }\r\n        else\r\n        {\r\n            const QStringList ls = sensor.uniqueId().split('-', SKIP_EMPTY_PARTS);\r\n            if (ls.size() == 2 && ls[1] == QLatin1String(\"f2\"))\r\n            {\r\n                // Green Power devices, e.g. ZGPSwitch\r\n            }\r\n            else if (ls.size() != 3)\r\n            {\r\n                return 0;\r\n            }\r\n\r\n            QString mac = ls[0]; // need copy\r\n            mac.remove(':'); // inplace remove\r\n            extAddr = mac.toULongLong(&ok, 16);\r\n\r\n            if (!ok)\r\n            {\r\n                return 0;\r\n            }\r\n\r\n            // restore clusterId\r\n            if (ls.size() == 3)\r\n            {\r\n                clusterId = ls[2].toUShort(&ok, 16);\r\n\r\n                if (!ok)\r\n                {\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isClip && extAddr == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        // ZGP switches\r\n        if (sensor.fingerPrint().profileId == GP_PROFILE_ID)\r\n        {\r\n            sensor.addItem(DataTypeString, RConfigGPDKey)->setIsPublic(false);\r\n            sensor.addItem(DataTypeUInt16, RConfigGPDDeviceId)->setIsPublic(false);\r\n            sensor.addItem(DataTypeUInt32, RStateGPDFrameCounter)->setIsPublic(false);\r\n            sensor.addItem(DataTypeUInt64, RStateGPDLastPair)->setIsPublic(false);\r\n        }\r\n\r\n        if (sensor.type().endsWith(QLatin1String(\"Switch\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(COMMISSIONING_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : COMMISSIONING_CLUSTER_ID;\r\n            }\r\n\r\n            if (sensor.fingerPrint().hasOutCluster(ONOFF_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ONOFF_CLUSTER_ID;\r\n                if (sensor.modelId().startsWith(QLatin1String(\"Pocket remote\")) ||\r\n                    sensor.modelId().startsWith(QLatin1String(\"SYMFONISK\")))\r\n                {\r\n                    // blacklisted\r\n                }\r\n                else\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigGroup);\r\n                }\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ONOFF_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ONOFF_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ANALOG_INPUT_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(DOOR_LOCK_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : DOOR_LOCK_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(MULTISTATE_INPUT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : MULTISTATE_INPUT_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasOutCluster(IAS_ACE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ACE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasOutCluster(SCENE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : SCENE_CLUSTER_ID;\r\n            }\r\n\r\n            item = sensor.addItem(DataTypeInt32, RStateButtonEvent);\r\n            item->setValue(0);\r\n\r\n            if (sensor.modelId().startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\r\n            {\r\n                sensor.addItem(DataTypeUInt16, RStateX);\r\n                sensor.addItem(DataTypeUInt16, RStateY);\r\n                sensor.addItem(DataTypeInt16, RStateAngle);\r\n            }\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"AncillaryControl\")))\r\n        {\r\n            clusterId = IAS_ACE_CLUSTER_ID;\r\n            sensor.addItem(DataTypeString, RStateAction);\r\n            sensor.addItem(DataTypeString, RStatePanel);\r\n            sensor.addItem(DataTypeUInt32, RStateSecondsRemaining)->setValue(0);\r\n            sensor.addItem(DataTypeBool, RStateTampered)->setValue(false);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"LightLevel\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(ILLUMINANCE_MEASUREMENT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ILLUMINANCE_MEASUREMENT_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeUInt16, RStateLightLevel);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeUInt32, RStateLux);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeBool, RStateDark);\r\n            item->setValue(true);\r\n            item->setTimeStamps(QDateTime::currentDateTime().addSecs(-120));\r\n            item = sensor.addItem(DataTypeBool, RStateDaylight);\r\n            item->setValue(false);\r\n            item = sensor.addItem(DataTypeUInt16, RConfigTholdDark);\r\n            item->setValue(R_THOLDDARK_DEFAULT);\r\n            item = sensor.addItem(DataTypeUInt16, RConfigTholdOffset);\r\n            item->setValue(R_THOLDOFFSET_DEFAULT);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Temperature\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(TEMPERATURE_MEASUREMENT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : TEMPERATURE_MEASUREMENT_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeInt16, RStateTemperature);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeInt16, RConfigOffset);\r\n            item->setValue(0);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"AirQuality\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(BOSCH_AIR_QUALITY_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : BOSCH_AIR_QUALITY_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeString, RStateAirQuality);\r\n            item = sensor.addItem(DataTypeUInt16, RStateAirQualityPpb);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Spectral\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(VENDOR_CLUSTER_ID))\r\n            {\r\n                clusterId = VENDOR_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeUInt16, RStateSpectralX);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeUInt16, RStateSpectralY);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeUInt16, RStateSpectralZ);\r\n            item->setValue(0);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Humidity\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(RELATIVE_HUMIDITY_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : RELATIVE_HUMIDITY_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeUInt16, RStateHumidity);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeInt16, RConfigOffset);\r\n            item->setValue(0);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Pressure\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(PRESSURE_MEASUREMENT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : PRESSURE_MEASUREMENT_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeInt16, RStatePressure);\r\n            item->setValue(0);\r\n            item = sensor.addItem(DataTypeInt16, RConfigOffset);\r\n            item->setValue(0);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Moisture\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(SOIL_MOISTURE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : SOIL_MOISTURE_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeInt16, RStateMoisture);\r\n            item->setValue(0);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Presence\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(OCCUPANCY_SENSING_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : OCCUPANCY_SENSING_CLUSTER_ID;\r\n                if (sensor.modelId().startsWith(QLatin1String(\"FLS\")) ||\r\n                    sensor.modelId().startsWith(QLatin1String(\"MOSZB-1\")))\r\n                {\r\n                    // TODO write and recover min/max to db\r\n                    deCONZ::NumericUnion dummy;\r\n                    dummy.u64 = 0;\r\n                    sensor.setZclValue(NodeValue::UpdateInvalid, sensor.fingerPrint().endpoint, clusterId, 0x0000, dummy);\r\n                    NodeValue &val = sensor.getZclValue(clusterId, 0x0000);\r\n                    val.minInterval = 1;     // value used by Hue bridge\r\n                    val.maxInterval = 300;   // value used by Hue bridge\r\n\r\n                    sensor.setNextReadTime(READ_OCCUPANCY_CONFIG, QTime::currentTime());\r\n                    sensor.enableRead(READ_OCCUPANCY_CONFIG);\r\n                    sensor.setLastRead(READ_OCCUPANCY_CONFIG, 0);\r\n                }\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(BINARY_INPUT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : BINARY_INPUT_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ONOFF_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ONOFF_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStatePresence);\r\n            item->setValue(false);\r\n            if (sensor.modelId().startsWith(QLatin1String(\"MOSZB-1\")) && clusterId == OCCUPANCY_SENSING_CLUSTER_ID) // Develco/frient motion sensor\r\n            {\r\n                sensor.addItem(DataTypeUInt16, RConfigDelay)->setValue(0);\r\n                sensor.addItem(DataTypeUInt16, RConfigPending)->setValue(0);\r\n            }\r\n            else\r\n            {\r\n                item = sensor.addItem(DataTypeUInt16, RConfigDuration);\r\n                if (sensor.modelId().startsWith(QLatin1String(\"tagv4\"))) // SmartThings Arrival sensor\r\n                {\r\n                    item->setValue(310);\r\n                }\r\n                else if (sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\r\n                {\r\n                    item->setValue(90);\r\n                }\r\n                else\r\n                {\r\n                    item->setValue(60); // presence should be reasonable for physical sensors\r\n                }\r\n            }\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Flag\")))\r\n        {\r\n            item = sensor.addItem(DataTypeBool, RStateFlag);\r\n            item->setValue(false);\r\n            item = sensor.item(RStateLastUpdated);\r\n            item->setValue(startTime);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Status\")))\r\n        {\r\n            item = sensor.addItem(DataTypeInt32, RStateStatus);\r\n            item->setValue(0);\r\n            item = sensor.item(RStateLastUpdated);\r\n            item->setValue(startTime);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"OpenClose\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ONOFF_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ONOFF_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStateOpen);\r\n            item->setValue(false);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"DoorLock\")))\r\n        {\r\n            clusterId = clusterId ? clusterId : DOOR_LOCK_CLUSTER_ID;\r\n\r\n            sensor.addItem(DataTypeString, RStateLockState);\r\n            sensor.addItem(DataTypeBool, RConfigLock);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Alarm\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStateAlarm);\r\n            item->setValue(false);\r\n\r\n            if (R_GetProductId(&sensor) == QLatin1String(\"NAS-AB02B0 Siren\"))\r\n            {\r\n                sensor.addItem(DataTypeUInt8, RConfigMelody);\r\n                sensor.addItem(DataTypeString, RConfigPreset);\r\n                sensor.addItem(DataTypeUInt8, RConfigVolume);\r\n                sensor.addItem(DataTypeInt8, RConfigTempMaxThreshold);\r\n                sensor.addItem(DataTypeInt8, RConfigTempMinThreshold);\r\n                sensor.addItem(DataTypeInt8, RConfigHumiMaxThreshold);\r\n                sensor.addItem(DataTypeInt8, RConfigHumiMinThreshold);\r\n            }\r\n\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"CarbonMonoxide\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStateCarbonMonoxide);\r\n            item->setValue(false);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Fire\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : TUYA_CLUSTER_ID;\r\n                sensor.addItem(DataTypeBool, RStateLowBattery)->setValue(false);\r\n            }\r\n\r\n            item = sensor.addItem(DataTypeBool, RStateFire);\r\n            item->setValue(false);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Vibration\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(DOOR_LOCK_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : DOOR_LOCK_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(SAMJIN_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : SAMJIN_CLUSTER_ID;\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationX);\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationY);\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationZ);\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStateVibration);\r\n            item->setValue(false);\r\n            if (sensor.modelId().startsWith(QLatin1String(\"lumi.vibration\")))\r\n            {\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationX);\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationY);\r\n                item = sensor.addItem(DataTypeInt16, RStateOrientationZ);\r\n                item = sensor.addItem(DataTypeUInt16, RStateTiltAngle);\r\n                item = sensor.addItem(DataTypeUInt16, RStateVibrationStrength);\r\n            }\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Water\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : IAS_ZONE_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeBool, RStateWater);\r\n            item->setValue(false);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Consumption\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(METERING_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : METERING_CLUSTER_ID;\r\n                if ((sensor.modelId() != QLatin1String(\"ZB-ONOFFPlug-D0005\")) &&\r\n                    (sensor.modelId() != QLatin1String(\"TS0121\")) &&\r\n                    (!sensor.modelId().startsWith(QLatin1String(\"BQZ10-AU\"))) &&\r\n                    (!sensor.modelId().startsWith(QLatin1String(\"ROB_200\"))) &&\r\n                    (sensor.modelId() != QLatin1String(\"lumi.switch.b1naus01\")) &&\r\n                    (sensor.modelId() != QLatin1String(\"lumi.switch.n0agl1\")) &&\r\n                    (!sensor.modelId().startsWith(QLatin1String(\"SPW35Z\"))))\r\n                {\r\n                    item = sensor.addItem(DataTypeInt16, RStatePower);\r\n                    item->setValue(0);\r\n                }\r\n                if (sensor.modelId().startsWith(QLatin1String(\"EMIZB-1\")))\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RConfigInterfaceMode)->setValue(1);\r\n                }\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ANALOG_INPUT_CLUSTER_ID;\r\n            }\r\n            if (sensor.modelId() != QLatin1String(\"160-01\"))\r\n            {\r\n                item = sensor.addItem(DataTypeUInt64, RStateConsumption);\r\n                item->setValue(0);\r\n            }\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Power\")))\r\n        {\r\n            bool hasVoltage = true;\r\n            if (sensor.fingerPrint().hasInCluster(ELECTRICAL_MEASUREMENT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ELECTRICAL_MEASUREMENT_CLUSTER_ID;\r\n                if (sensor.modelId().startsWith(QLatin1String(\"Plug\")) && sensor.manufacturer() == QLatin1String(\"OSRAM\")) // OSRAM\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"OSRAM %s: ZHAPower sensor id: %s ignored loading from database\\n\", qPrintable(sensor.modelId()), qPrintable(sensor.id()));\r\n                    return 0;\r\n                    // hasVoltage = false;\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"ZB-ONOFFPlug-D0005\") ||\r\n                         sensor.modelId() == QLatin1String(\"lumi.switch.b1nacn02\") ||\r\n                         sensor.modelId() == QLatin1String(\"lumi.switch.b2nacn02\") ||\r\n                         sensor.modelId() == QLatin1String(\"lumi.switch.b1naus01\") ||\r\n                         sensor.modelId() == QLatin1String(\"lumi.switch.n0agl1\") ||\r\n                         sensor.manufacturer() == QLatin1String(\"Legrand\"))\r\n                {\r\n                    hasVoltage = false;\r\n                }\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\r\n            {\r\n                clusterId = clusterId ? clusterId : ANALOG_INPUT_CLUSTER_ID;\r\n                if (!sensor.modelId().startsWith(QLatin1String(\"lumi.plug.mm\"))) // Only available for new ZB3.0 Mi smart plugs?\r\n                {\r\n                    hasVoltage = false;\r\n                }\r\n            }\r\n            item = sensor.addItem(DataTypeInt16, RStatePower);\r\n            item->setValue(0);\r\n            if (hasVoltage)\r\n            {\r\n                item = sensor.addItem(DataTypeUInt16, RStateVoltage);\r\n                item->setValue(0);\r\n                item = sensor.addItem(DataTypeUInt16, RStateCurrent);\r\n                item->setValue(0);\r\n            }\r\n        }\r\n        else if (sensor.type() == QLatin1String(\"Daylight\"))\r\n        {\r\n            d->daylightSensorId = sensor.id();\r\n            sensor.removeItem(RConfigReachable);\r\n            sensor.addItem(DataTypeBool, RConfigConfigured);\r\n            item = sensor.addItem(DataTypeInt8, RConfigSunriseOffset);\r\n            item->setValue(30);\r\n            item = sensor.addItem(DataTypeInt8, RConfigSunsetOffset);\r\n            item->setValue(-30);\r\n            sensor.addItem(DataTypeString, RConfigLat)->setIsPublic(false);\r\n            sensor.addItem(DataTypeString, RConfigLong)->setIsPublic(false);\r\n            sensor.addItem(DataTypeBool, RStateDaylight);\r\n            sensor.addItem(DataTypeBool, RStateDark);\r\n            sensor.addItem(DataTypeInt32, RStateStatus);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Thermostat\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(THERMOSTAT_CLUSTER_ID) || sensor.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\r\n            {\r\n                clusterId = THERMOSTAT_CLUSTER_ID;\r\n            }\r\n\r\n            //only for legrand cluster. Add only mode field.\r\n            if (sensor.fingerPrint().hasInCluster(LEGRAND_CONTROL_CLUSTER_ID) &&\r\n                sensor.modelId() == QLatin1String(\"Cable outlet\"))\r\n            {\r\n                clusterId = LEGRAND_CONTROL_CLUSTER_ID;\r\n                sensor.addItem(DataTypeString, RConfigMode);\r\n            }\r\n            else\r\n            {\r\n                item = sensor.addItem(DataTypeInt16, RStateTemperature);\r\n                item->setValue(0);\r\n                item = sensor.addItem(DataTypeInt16, RConfigOffset);\r\n                item->setValue(0);\r\n                sensor.addItem(DataTypeInt16, RConfigHeatSetpoint);    // Heating set point\r\n                sensor.addItem(DataTypeBool, RStateOn)->setValue(false);                // Heating on/off\r\n\r\n                if (sensor.modelId().startsWith(QLatin1String(\"SLR2\")) ||   // Hive\r\n                    sensor.modelId() == QLatin1String(\"SLR1b\") ||           // Hive\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD MOES TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n\r\n                if (R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\"))\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeBool, RStateLowBattery)->setValue(false);\r\n                }\r\n\r\n                if (R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD MOES TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\r\n                {\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                }\r\n\r\n                if (R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigPreset);\r\n                    sensor.addItem(DataTypeBool, RConfigSetValve)->setValue(false);\r\n                }\r\n\r\n                if (R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\")  ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\")  ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigSchedule);\r\n                }\r\n\r\n                if (R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY369 TRV\")  ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD HY368 TRV\")  ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\r\n                    R_GetProductId(&sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\r\n                {\r\n                    sensor.addItem(DataTypeBool, RConfigWindowOpen)->setValue(false);\r\n                }\r\n\r\n                if (sensor.modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeUInt32, RConfigHostFlags)->setIsPublic(false);\r\n                    sensor.addItem(DataTypeBool, RConfigDisplayFlipped)->setValue(false);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"902010/32\"))  // Bitron\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                    sensor.addItem(DataTypeUInt8, RConfigControlSequence)->setValue(4);\r\n                    sensor.addItem(DataTypeInt16, RConfigCoolSetpoint);\r\n                    sensor.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigSchedule);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"Super TR\"))   // ELKO\r\n                {\r\n                    sensor.addItem(DataTypeString, RConfigTemperatureMeasurement);\r\n                    sensor.addItem(DataTypeInt16, RStateFloorTemperature);\r\n                    sensor.addItem(DataTypeBool, RStateHeating)->setValue(false);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"Thermostat\")) // ecozy\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeString, RConfigSchedule);\r\n                    sensor.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\r\n                    sensor.addItem(DataTypeInt16, RConfigLastChangeAmount);\r\n                    sensor.addItem(DataTypeUInt8, RConfigLastChangeSource);\r\n                    sensor.addItem(DataTypeTime, RConfigLastChangeTime);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"SORB\")) // Stelpro Orleans Fan\r\n                {\r\n                    sensor.addItem(DataTypeInt16, RConfigCoolSetpoint);\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else if (sensor.modelId().startsWith(QLatin1String(\"STZB402\"))) // Stelpro baseboard thermostat\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"Zen-01\"))\r\n                {\r\n                    sensor.addItem(DataTypeInt16, RConfigCoolSetpoint);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                    sensor.addItem(DataTypeString, RConfigFanMode);\r\n                }\r\n                else if (sensor.modelId().startsWith(QLatin1String(\"3157100\")))\r\n                {\r\n                    sensor.addItem(DataTypeInt16, RConfigCoolSetpoint);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                    sensor.addItem(DataTypeString, RConfigFanMode);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"TH1300ZB\")) // sinope thermostat\r\n                {\r\n                    sensor.addItem(DataTypeUInt8, RStateValve);\r\n                    sensor.addItem(DataTypeBool, RConfigLocked)->setValue(false);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else if (sensor.modelId() == QLatin1String(\"ALCANTARA2 D1.00P1.01Z1.00\")) // Alcantara 2 acova\r\n                {\r\n                    sensor.addItem(DataTypeInt16, RConfigCoolSetpoint);\r\n                    sensor.addItem(DataTypeString, RConfigMode);\r\n                }\r\n                else\r\n                {\r\n                    if (!sensor.modelId().isEmpty())\r\n                    {\r\n                        sensor.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\r\n                        sensor.addItem(DataTypeString, RConfigSchedule);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Battery\")))\r\n        {\r\n            if (sensor.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\r\n            {\r\n                clusterId = POWER_CONFIGURATION_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(XIAOMI_CLUSTER_ID))\r\n            {\r\n                clusterId = XIAOMI_CLUSTER_ID;\r\n            }\r\n            else if (sensor.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\r\n            {\r\n                clusterId = TUYA_CLUSTER_ID;\r\n            }\r\n            item = sensor.addItem(DataTypeUInt8, RStateBattery);\r\n            item->setValue(100);\r\n        }\r\n        else if (sensor.type() == QLatin1String(\"CLIPDaylightOffset\"))\r\n        {\r\n            sensor.addItem(DataTypeInt16, RConfigOffset);\r\n            sensor.addItem(DataTypeString, RConfigMode);\r\n            sensor.addItem(DataTypeTime, RStateLocaltime);\r\n        }\r\n        else if (sensor.type().endsWith(QLatin1String(\"Time\")))\r\n        {\r\n            sensor.addItem(DataTypeTime, RStateUtc);\r\n            sensor.addItem(DataTypeTime, RStateLocaltime);\r\n            sensor.addItem(DataTypeTime, RStateLastSet);\r\n        }\r\n\r\n        if (sensor.modelId().startsWith(QLatin1String(\"TRADFRI\")) ||\r\n                 sensor.modelId().startsWith(QLatin1String(\"SYMFONISK\")))\r\n        {\r\n            sensor.setManufacturer(QLatin1String(\"IKEA of Sweden\"));\r\n\r\n            // support power configuration cluster for IKEA devices\r\n            if (!sensor.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\r\n            {\r\n                sensor.fingerPrint().inClusters.push_back(POWER_CONFIGURATION_CLUSTER_ID);\r\n            }\r\n\r\n            item = sensor.addItem(DataTypeString, RConfigAlert);\r\n            item->setValue(R_ALERT_DEFAULT);\r\n        }\r\n        // Skip legacy Xiaomi items\r\n        else if (sensor.modelId() == QLatin1String(\"lumi.flood.agl02\") ||\r\n                 sensor.modelId() == QLatin1String(\"lumi.motion.agl04\") || sensor.modelId() == QLatin1String(\"lumi.switch.b1nacn02\") ||\r\n                 sensor.modelId() == QLatin1String(\"lumi.switch.b2nacn02\") || sensor.modelId() == QLatin1String(\"lumi.switch.b1naus01\") ||\r\n                 sensor.modelId() == QLatin1String(\"lumi.switch.n0agl1\") || sensor.modelId() == QLatin1String(\"lumi.switch.b1lacn02\") ||\r\n                 sensor.modelId() == QLatin1String(\"lumi.switch.b2lacn02\"))\r\n        {\r\n        }\r\n        else if (sensor.modelId().startsWith(QLatin1String(\"lumi.\")))\r\n        {\r\n            if (!sensor.modelId().startsWith(QLatin1String(\"lumi.ctrl_\")) &&\r\n                !sensor.modelId().startsWith(QLatin1String(\"lumi.plug\")) &&\r\n                sensor.modelId() != QLatin1String(\"lumi.curtain\") &&\r\n                !sensor.modelId().startsWith(QLatin1String(\"lumi.relay.c\")) &&\r\n                !sensor.type().endsWith(QLatin1String(\"Battery\")))\r\n            {\r\n                item = sensor.addItem(DataTypeUInt8, RConfigBattery);\r\n                //item->setValue(100); // wait for report\r\n            }\r\n\r\n            if (sensor.modelId().startsWith(QLatin1String(\"lumi.vibration\")))\r\n            {\r\n                // low: 0x15, medium: 0x0B, high: 0x01\r\n                item = sensor.addItem(DataTypeUInt8, RConfigSensitivity);\r\n                item = sensor.addItem(DataTypeUInt8, RConfigSensitivityMax);\r\n                item->setValue(0x15); // low\r\n                item = sensor.addItem(DataTypeUInt16, RConfigPending);\r\n            }\r\n\r\n            if (!sensor.item(RStateTemperature) &&\r\n                sensor.modelId() != QLatin1String(\"lumi.sensor_switch\") &&\r\n                !sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_ht\")) &&\r\n                !sensor.modelId().endsWith(QLatin1String(\"86opcn01\"))) // exclude Aqara Opple\r\n            {\r\n                item = sensor.addItem(DataTypeInt16, RConfigTemperature);\r\n                item->setValue(0);\r\n                //item = sensor.addItem(DataTypeInt16, RConfigOffset);\r\n                //item->setValue(0);\r\n            }\r\n\r\n            if (sensor.modelId().endsWith(QLatin1String(\"86opcn01\")))\r\n            {\r\n                // Aqara switches need to be configured to send proper button events\r\n                item = sensor.addItem(DataTypeUInt16, RConfigPending);\r\n                item->setValue(item->toNumber() | R_PENDING_MODE);\r\n            }\r\n\r\n            if (sensor.modelId() == QLatin1String(\"lumi.switch.n0agl1\"))\r\n            {\r\n                sensor.removeItem(RConfigBattery);\r\n            }\r\n        }\r\n        else if (sensor.modelId().startsWith(QLatin1String(\"tagv4\"))) // SmartThings Arrival sensor\r\n        {\r\n            item = sensor.addItem(DataTypeString, RConfigAlert);\r\n            item->setValue(R_ALERT_DEFAULT);\r\n        }\r\n\r\n        // TODO cleanup conditions to be readable\r\n        //Only use the ZHAAncillaryControl sensor if present for enrollement, but only enabled for one device ATM\r\n        if (sensor.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID) &&\r\n           (sensor.modelId() != QLatin1String(\"URC4450BC0-X-R\") ||\r\n            sensor.modelId() != QLatin1String(\"3405-L\") ||\r\n           (sensor.type().endsWith(QLatin1String(\"AncillaryControl\")) || !sensor.fingerPrint().hasOutCluster(IAS_ACE_CLUSTER_ID))))\r\n        {\r\n            if (sensor.modelId() == QLatin1String(\"button\") ||\r\n                sensor.modelId().startsWith(QLatin1String(\"multi\")) ||\r\n                sensor.modelId() == QLatin1String(\"water\") ||\r\n                R_GetProductId(&sensor) == QLatin1String(\"NAS-AB02B0 Siren\"))\r\n            {\r\n                // no support for some IAS Zone flags\r\n            }\r\n            else\r\n            {\r\n                item = sensor.addItem(DataTypeBool, RStateLowBattery);\r\n                item->setValue(false);\r\n                item = sensor.addItem(DataTypeBool, RStateTampered);\r\n                item->setValue(false);\r\n            }\r\n            sensor.addItem(DataTypeUInt16, RConfigPending)->setValue(0);\r\n            sensor.addItem(DataTypeUInt32, RConfigEnrolled)->setValue(IAS_STATE_INIT);\r\n        }\r\n\r\n        if (sensor.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\r\n        {\r\n            if (sensor.manufacturer().startsWith(QLatin1String(\"Climax\")) ||\r\n                sensor.modelId().startsWith(QLatin1String(\"902010/23\")))\r\n            {\r\n                // climax non IAS reports state/lowbattery via battery alarm mask attribute\r\n                item = sensor.addItem(DataTypeBool, RStateLowBattery);\r\n                // don't set value -> null until reported\r\n            }\r\n            else if (sensor.modelId() == QLatin1String(\"Bell\"))\r\n            {\r\n                // Don't expose battery resource item for this device\r\n            }\r\n            else if (!sensor.type().endsWith(QLatin1String(\"Battery\")))\r\n            {\r\n                item = sensor.addItem(DataTypeUInt8, RConfigBattery);\r\n                // item->setValue(100);\r\n            }\r\n        }\r\n\r\n        if (stateCol >= 0 &&\r\n            sensor.type() != QLatin1String(\"CLIPGenericFlag\") &&\r\n            sensor.type() != QLatin1String(\"CLIPGenericStatus\") &&\r\n            sensor.type() != QLatin1String(\"Daylight\"))\r\n        {\r\n            sensor.jsonToState(QLatin1String(colval[stateCol]));\r\n        }\r\n\r\n        if (configCol >= 0)\r\n        {\r\n            sensor.jsonToConfig(QLatin1String(colval[configCol]));\r\n        }\r\n\r\n        {\r\n            ResourceItem *item = sensor.item(RStatePresence);\r\n            if (item && item->toBool())\r\n            {\r\n                item->setValue(false); // reset at startup\r\n            }\r\n        }\r\n\r\n        {\r\n            ResourceItem *item = sensor.item(RConfigEnrolled);\r\n            if (item)\r\n            {\r\n                item->setValue(IAS_STATE_INIT); // reset at startup\r\n            }\r\n        }\r\n\r\n        {\r\n            ResourceItem *item = sensor.item(RStateGPDLastPair);\r\n            if (item)\r\n            {\r\n                item->setValue(0); // reset at startup\r\n            }\r\n        }\r\n\r\n        // check for older setups with multiple ZHASwitch sensors per device\r\n        if (sensor.manufacturer() == QLatin1String(\"ubisys\") && sensor.type() == QLatin1String(\"ZHASwitch\"))\r\n        {\r\n            if ((sensor.modelId().startsWith(QLatin1String(\"D1\")) && sensor.fingerPrint().endpoint != 0x02))\r\n            {\r\n                DBG_Printf(DBG_INFO, \"ubisys sensor id: %s, endpoint 0x%02X (%s) ignored loading from database\\n\", qPrintable(sensor.id()), sensor.fingerPrint().endpoint, qPrintable(sensor.modelId()));\r\n                return 0;\r\n            }\r\n\r\n            QStringList supportedModes({\"momentary\", \"rocker\", \"custom\"});\r\n            item = sensor.addItem(DataTypeString, RConfigMode);\r\n\r\n            if (configCol >= 0)\r\n            {\r\n                sensor.jsonToConfig(QLatin1String(colval[configCol])); // needed again otherwise item isEmpty\r\n            }\r\n\r\n            if (item->toString().isEmpty() || !supportedModes.contains(item->toString()))\r\n            {\r\n                item->setValue(supportedModes.first());\r\n            }\r\n        }\r\n\r\n        if (extAddr != 0 && endpoint != 0xFF)\r\n        {\r\n            const QString uid = generateUniqueId(extAddr, endpoint, clusterId);\r\n\r\n            if (uid != sensor.uniqueId())\r\n            {\r\n                // update to new format\r\n                sensor.setUniqueId(uid);\r\n                sensor.setNeedSaveDatabase(true);\r\n            }\r\n        }\r\n\r\n        // temp. workaround for default value of 'two groups' which is only supported by lighting switch\r\n        if (sensor.mode() == Sensor::ModeTwoGroups)\r\n        {\r\n            if (sensor.modelId() != QLatin1String(\"Lighting Switch\"))\r\n            {\r\n                sensor.setMode(Sensor::ModeScenes);\r\n            }\r\n        }\r\n\r\n        // check doubles, split uid into mac address and endpoint\r\n\r\n        if (ok)\r\n        {\r\n            Sensor *s = 0;\r\n\r\n            if (!isClip)\r\n            {\r\n                s = d->getSensorNodeForUniqueId(sensor.uniqueId());\r\n            }\r\n\r\n            if (!s)\r\n            {\r\n                // if sensor was seen recently set reachable true\r\n                item = sensor.item(RStateLastUpdated);\r\n                if (!isClip && item && item->toNumber() > 0)\r\n                {\r\n                    QDateTime now = QDateTime::currentDateTimeUtc();\r\n                    QDateTime lastSeen = QDateTime::fromMSecsSinceEpoch(item->toNumber());\r\n                    const int minLastSeen = 60 * 60 * 24; // 24 hours\r\n                    const int maxLastSeen = 60 * 60 * 24 * 7; // 1 week\r\n\r\n                    item = sensor.item(RConfigReachable);\r\n\r\n                    if (item && lastSeen.isValid() && now > lastSeen)\r\n                    {\r\n                        const auto dt = lastSeen.secsTo(now);\r\n                        if (dt < minLastSeen)\r\n                        {\r\n                            sensor.rx();\r\n                            item->setValue(true);\r\n                        }\r\n                        else if (dt > maxLastSeen && item->toBool()) // reachable but way too long ago\r\n                        {\r\n                            item->setValue(false);\r\n                        }\r\n                    }\r\n\r\n                    // when reachable and assigned to a group, force check of group membership\r\n                    if (item->toBool())\r\n                    {\r\n                        item = sensor.item(RConfigGroup);\r\n                        if (item && !item->toString().isEmpty() && item->toString() != QLatin1String(\"0\"))\r\n                        {\r\n                            enqueueEvent(Event(RSensors, REventValidGroup, sensor.id()));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                {\r\n                    auto *productId = sensor.item(RAttrProductId);\r\n                    if (productId)\r\n                    {\r\n                        productId->setIsPublic(false); // don't show in REST-API\r\n                    }\r\n                }\r\n\r\n                sensor.address().setExt(extAddr);\r\n                // append to cache if not already known\r\n                sensor.setHandle(R_CreateResourceHandle(&sensor, d->sensors.size()));\r\n                d->sensors.push_back(sensor);\r\n                d->updateSensorEtag(&d->sensors.back());\r\n\r\n                if (!isClip && sensor.modelId() != QLatin1String(\"Daylight\"))\r\n                {\r\n                    const auto key = extAddr != 0 ? extAddr : qHash(sensor.uniqueId());\r\n                    auto *device = DEV_GetOrCreateDevice(d, deCONZ::ApsController::instance(), d->eventEmitter, d->m_devices, key);\r\n                    device->addSubDevice(&d->sensors.back());\r\n                }\r\n\r\n                if (sensor.needSaveDatabase())\r\n                {\r\n                    d->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Loads all sensors from database\r\n */\r\nvoid DeRestPluginPrivate::loadAllSensorsFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql = QString(\"SELECT * FROM sensors\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllSensorsCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Loads all gateways from database\r\n */\r\nvoid DeRestPluginPrivate::loadAllGatewaysFromDb()\r\n{\r\n    int rc;\r\n    char *errmsg = 0;\r\n\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString sql(QLatin1String(\"SELECT * FROM gateways\"));\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    rc = sqlite3_exec(db, qPrintable(sql), sqliteLoadAllGatewaysCallback, this, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Sqlite callback to load all light ids into temporary array.\r\n */\r\nstatic int sqliteGetAllLightIdsCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    std::vector<int> *lightIds = static_cast<std::vector<int>*>(user);\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            if (strcmp(colname[i], \"id\") == 0)\r\n            {\r\n                bool ok;\r\n                int id = QString(colval[i]).toInt(&ok);\r\n\r\n                if (ok)\r\n                {\r\n                    lightIds->push_back(id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Determines a unused id for a light.\r\n */\r\nint getFreeLightId()\r\n{\r\n    DeRestPluginPrivate *plugin = DeRestPluginPrivate::instance();\r\n\r\n    DBG_Assert(plugin && plugin->dbIsOpen());\r\n\r\n    if (!plugin || !plugin->dbIsOpen())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"DB getFreeSensorId() called with no valid db pointer\\n\");\r\n        return 1; // TODO, this is an error we should handle this. 1 is misleading\r\n    }\r\n\r\n    std::vector<int> lightIds(plugin->nodes.size());\r\n\r\n    { // append all ids from nodes known at runtime\r\n        std::vector<LightNode>::const_iterator i = plugin->nodes.begin();\r\n        std::vector<LightNode>::const_iterator end = plugin->nodes.end();\r\n        for (;i != end; ++i)\r\n        {\r\n            lightIds.push_back(i->id().toUInt());\r\n        }\r\n    }\r\n\r\n    // append all ids from database (dublicates are ok here)\r\n    const auto sql = QString(\"SELECT * FROM nodes\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, qPrintable(sql), sqliteGetAllLightIdsCallback, &lightIds, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    int id = 1;\r\n    while (1)\r\n    {\r\n        const auto result = std::find(lightIds.begin(), lightIds.end(), id);\r\n\r\n        // id not known?\r\n        if (result == lightIds.end())\r\n        {\r\n            return id;\r\n        }\r\n        id++;\r\n    }\r\n\r\n    return id;\r\n}\r\n\r\n/*! Sqlite callback to load all sensor ids into temporary array.\r\n */\r\nstatic int sqliteGetAllSensorIdsCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n    DBG_Assert(ncols == 1);\r\n    Q_UNUSED(colname)\r\n\r\n    if (!user || ncols != 1)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    auto *sensorIds = static_cast<std::vector<int>*>(user);\r\n\r\n    errno = 0;\r\n    unsigned long id = strtoul(colval[0], nullptr, 10);\r\n    if (errno == 0)\r\n    {\r\n        const auto j = std::find(sensorIds->cbegin(), sensorIds->cend(), int(id));\r\n\r\n        if (j == sensorIds->cend())\r\n        {\r\n            sensorIds->push_back(int(id));\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nstatic int sqliteLoadAllGatewaysCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    DBG_Assert(user != 0);\r\n\r\n    if (!user || (ncols <= 0))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    DeRestPluginPrivate *d = static_cast<DeRestPluginPrivate*>(user);\r\n\r\n    int idxUuid = -1;\r\n    int idxName = -1;\r\n    int idxIp = -1;\r\n    int idxPort = -1;\r\n    int idxApikey = -1;\r\n    int idxPairing = -1;\r\n    int idxCgroups = -1;\r\n\r\n    for (int i = 0; i < ncols; i++)\r\n    {\r\n        if (colval[i] && (colval[i][0] != '\\0'))\r\n        {\r\n            if      (strcmp(colname[i], \"uuid\") == 0)    { idxUuid = i; }\r\n            else if (strcmp(colname[i], \"name\") == 0)    { idxName = i; }\r\n            else if (strcmp(colname[i], \"ip\") == 0)      { idxIp = i; }\r\n            else if (strcmp(colname[i], \"port\") == 0)    { idxPort = i; }\r\n            else if (strcmp(colname[i], \"apikey\") == 0)  { idxApikey = i; }\r\n            else if (strcmp(colname[i], \"pairing\") == 0)  { idxPairing = i; }\r\n            else if (strcmp(colname[i], \"cgroups\") == 0) { idxCgroups = i; }\r\n        }\r\n    }\r\n\r\n    if (idxUuid == -1)\r\n    {\r\n        return 0; // required\r\n    }\r\n\r\n    Gateway *gw = new Gateway(d);\r\n\r\n    gw->setUuid(colval[idxUuid]);\r\n    if (idxName != -1) { gw->setName(colval[idxName]); }\r\n    if (idxIp != -1) { gw->setAddress(QHostAddress(colval[idxIp])); }\r\n    if (idxPort != -1) { gw->setPort(QString(colval[idxPort]).toUShort()); }\r\n    if (idxApikey != -1) { gw->setApiKey(colval[idxApikey]); }\r\n    if (idxPairing != -1) { gw->setPairingEnabled(colval[idxPairing][0] == '1'); }\r\n    if (idxCgroups != -1 && colval[idxCgroups][0] == '[') // must be json array\r\n    {\r\n        bool ok;\r\n        QVariant var = Json::parse(colval[idxCgroups], ok);\r\n\r\n        if (ok && var.type() == QVariant::List)\r\n        {\r\n            QVariantList ls = var.toList();\r\n            for (int i = 0; i < ls.size(); i++)\r\n            {\r\n                QVariantMap e = ls[i].toMap();\r\n                if (e.contains(QLatin1String(\"lg\")) && e.contains(QLatin1String(\"rg\")))\r\n                {\r\n                    double lg = e[QLatin1String(\"lg\")].toDouble();\r\n                    double rg = e[QLatin1String(\"rg\")].toDouble();\r\n\r\n                    if (lg > 0 && lg <= 0xfffful && rg > 0 && rg <= 0xfffful)\r\n                    {\r\n                        gw->addCascadeGroup(lg, rg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    gw->setNeedSaveDatabase(false);\r\n    d->gateways.push_back(gw);\r\n\r\n    return 0;\r\n}\r\n\r\n/*! Determines a unused id for a sensor.\r\n */\r\nint getFreeSensorId()\r\n{\r\n    DeRestPluginPrivate *plugin = DeRestPluginPrivate::instance();\r\n\r\n    DBG_Assert(plugin && plugin->dbIsOpen());\r\n\r\n    if (!plugin || !plugin->dbIsOpen())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"DB getFreeSensorId() called with no valid db pointer\\n\");\r\n        return 1; // TODO, this is an error we should handle this. 1 is misleading\r\n    }\r\n\r\n    std::vector<int> sensorIds(plugin->sensors.size());\r\n\r\n    // collect all ids from nodes known at runtime\r\n    std::transform (plugin->sensors.cbegin(), plugin->sensors.cend(), sensorIds.begin(),\r\n        [](const Sensor&s) { return s.id().toInt(); }\r\n    );\r\n\r\n    // add all ids referenced in rules of sensors which don't exist anymore -> to not consider these\r\n    for (const Rule &r : plugin->rules)\r\n    {\r\n        for (const RuleCondition &c : r.conditions())\r\n        {\r\n            if (c.resource() == RSensors)\r\n            {\r\n                bool ok;\r\n                const int sid = c.id().toInt(&ok);\r\n                if (ok && std::find(sensorIds.cbegin(), sensorIds.cend(), sid) == sensorIds.cend())\r\n                {\r\n                    sensorIds.push_back(sid);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // append all ids from database (also deleted ones)\r\n    const char * sql = \"SELECT sid FROM sensors\";\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", sql);\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, sql, sqliteGetAllSensorIdsCallback, &sensorIds, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    std::sort(sensorIds.begin(), sensorIds.end());\r\n\r\n    // 'append' only, start with largest known id\r\n    // skip daylight sensor.id 1000 from earlier versions to keep id value low as possible\r\n    const auto startId = std::find_if(sensorIds.rbegin(), sensorIds.rend(), [](int sid) { return sid < 1000; });\r\n\r\n    int sid = (startId != sensorIds.rend()) ? *startId : 1;\r\n\r\n    while (sid < 10000)\r\n    {\r\n        const auto result = std::find(sensorIds.cbegin(), sensorIds.cend(), sid);\r\n\r\n        if (result == sensorIds.end())\r\n        {\r\n            return sid;\r\n        }\r\n\r\n        sid++;\r\n    }\r\n\r\n    return sid;\r\n}\r\n\r\n/*! Saves the current auth with apikey to the database.\r\n */\r\nvoid DeRestPluginPrivate::saveApiKey(QString apikey)\r\n{\r\n    int rc;\r\n    char *errmsg;\r\n\r\n    std::vector<ApiAuth>::iterator i = apiAuths.begin();\r\n    std::vector<ApiAuth>::iterator end = apiAuths.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->apikey == apikey)\r\n        {\r\n            DBG_Assert(i->createDate.timeSpec() == Qt::UTC);\r\n            DBG_Assert(i->lastUseDate.timeSpec() == Qt::UTC);\r\n\r\n            QString sql = QString(QLatin1String(\"REPLACE INTO auth (apikey, devicetype, createdate, lastusedate, useragent) VALUES ('%1', '%2', '%3', '%4', '%5')\"))\r\n                    .arg(i->apikey)\r\n                    .arg(i->devicetype)\r\n                    .arg(i->createDate.toString(\"yyyy-MM-ddTHH:mm:ss\"))\r\n                    .arg(i->lastUseDate.toString(\"yyyy-MM-ddTHH:mm:ss\"))\r\n                    .arg(i->useragent);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n/*! Saves all nodes, groups and scenes to the database.\r\n */\r\nvoid DeRestPluginPrivate::saveDb()\r\n{\r\n    DBG_Assert(db != 0);\r\n\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (saveDatabaseItems == 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (saveDatabaseItems & DB_NOSAVE)\r\n    {\r\n        return;\r\n    }\r\n\r\n    int rc;\r\n    char *errmsg;\r\n    QElapsedTimer measTimer;\r\n\r\n    measTimer.start();\r\n\r\n    // check if former transaction was committed\r\n    if (sqlite3_get_autocommit(db) == 0) // is 1 when all is committed\r\n    {\r\n        errmsg = NULL;\r\n        rc = sqlite3_exec(db, \"COMMIT\", 0, 0, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: COMMIT former transaction, error: %s (%d)\\n\", errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n\r\n            queSaveDb(saveDatabaseItems, DB_SHORT_SAVE_DELAY);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // make the whole save process one transaction otherwise each insert would become\r\n    // a transaction which is extremly slow\r\n    errmsg = NULL;\r\n    rc = sqlite3_exec(db, \"BEGIN\", 0, 0, &errmsg);\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB SQL exec failed: BEGIN, error: %s\\n\", errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        if (rc == SQLITE_BUSY)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"DB locked by another process, retry later\\n\");\r\n        }\r\n\r\n        queSaveDb(saveDatabaseItems, DB_SHORT_SAVE_DELAY);\r\n        return;\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"DB save zll database items 0x%08X\\n\", saveDatabaseItems);\r\n\r\n    // dump authorisation data\r\n    if (saveDatabaseItems & DB_AUTH)\r\n    {\r\n        std::vector<ApiAuth>::iterator i = apiAuths.begin();\r\n        std::vector<ApiAuth>::iterator end = apiAuths.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (!i->needSaveDatabase)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            i->needSaveDatabase = false;\r\n\r\n            if (i->state == ApiAuth::StateDeleted)\r\n            {\r\n                // delete group from db (if exist)\r\n                QString sql = QString(QLatin1String(\"DELETE FROM auth WHERE apikey='%1'\")).arg(i->apikey);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n            else if (i->state == ApiAuth::StateNormal)\r\n            {\r\n                DBG_Assert(i->createDate.timeSpec() == Qt::UTC);\r\n                DBG_Assert(i->lastUseDate.timeSpec() == Qt::UTC);\r\n\r\n                QString sql = QString(QLatin1String(\"REPLACE INTO auth (apikey, devicetype, createdate, lastusedate, useragent) VALUES ('%1', '%2', '%3', '%4', '%5')\"))\r\n                        .arg(i->apikey)\r\n                        .arg(i->devicetype)\r\n                        .arg(i->createDate.toString(\"yyyy-MM-ddTHH:mm:ss\"))\r\n                        .arg(i->lastUseDate.toString(\"yyyy-MM-ddTHH:mm:ss\"))\r\n                        .arg(i->useragent);\r\n\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_AUTH;\r\n    }\r\n\r\n    // dump config\r\n    if (saveDatabaseItems & DB_CONFIG)\r\n    {\r\n        gwConfig[\"networkopenduration\"] = (double)gwNetworkOpenDuration;\r\n        gwConfig[\"timeformat\"] = gwTimeFormat;\r\n        gwConfig[\"timezone\"] = gwTimezone;\r\n        gwConfig[\"rgbwdisplay\"] = gwRgbwDisplay;\r\n        gwConfig[\"rfconnect\"] = (double)(gwRfConnectedExpected ? 1 : 0);\r\n        gwConfig[\"announceinterval\"] = (double)gwAnnounceInterval;\r\n        gwConfig[\"announceurl\"] = gwAnnounceUrl;\r\n        gwConfig[\"groupdelay\"] = gwGroupSendDelay;\r\n        gwConfig[\"zigbeechannel\"] = gwZigbeeChannel;\r\n        gwConfig[\"group0\"] = gwGroup0;\r\n        gwConfig[\"gwusername\"] = gwAdminUserName;\r\n        gwConfig[\"gwpassword\"] = QString::fromStdString(gwAdminPasswordHash);\r\n        gwConfig[\"homebridge\"] = gwHomebridge;\r\n        gwConfig[\"homebridgeversion\"] = gwHomebridgeVersion;\r\n        gwConfig[\"homebridgeupdateversion\"] = gwHomebridgeUpdateVersion;\r\n        gwConfig[\"homebridgeupdate\"] = gwHomebridgeUpdate;\r\n        gwConfig[\"homebridge-pin\"] = gwHomebridgePin;\r\n        gwConfig[\"updatechannel\"] = gwUpdateChannel;\r\n        gwConfig[\"swupdatestate\"] = gwSwUpdateState;\r\n        gwConfig[\"uuid\"] = gwUuid;\r\n        gwConfig[\"otauactive\"] = isOtauActive();\r\n        gwConfig[\"wifi\"] = gwWifi;\r\n        gwConfig[\"wifitype\"] = gwWifiType;\r\n        gwConfig[\"wifiname\"] = gwWifiName;\r\n        gwConfig[\"wificlientname\"] = gwWifiClientName;\r\n        gwConfig[\"wifichannel\"] = gwWifiChannel;\r\n        gwConfig[\"workingpw\"] = gwWifiWorkingPw;\r\n        gwConfig[\"workingtype\"] = gwWifiWorkingType;\r\n        gwConfig[\"workingname\"] = gwWifiWorkingName;\r\n        gwConfig[\"wificlientpw\"] = gwWifiClientPw;\r\n        gwConfig[\"wifipw\"] = gwWifiPw;\r\n        gwConfig[\"wifipwenc\"] = gwWifiPwEnc;\r\n        gwConfig[\"workingpwenc\"] = gwWifiWorkingPwEnc;\r\n        gwConfig[\"wifibackuppwenc\"] = gwWifiBackupPwEnc;\r\n        gwConfig[\"wifiip\"] = gwWifiIp;\r\n        gwConfig[\"wifipageactive\"] = gwWifiPageActive;\r\n        gwConfig[\"wifibackupname\"] = gwWifiBackupName;\r\n        gwConfig[\"wifibackuppw\"] = gwWifiBackupPw;\r\n        gwConfig[\"wifilastupdated\"] = gwWifiLastUpdated;\r\n        gwConfig[\"bridgeid\"] = gwBridgeId;\r\n        gwConfig[\"websocketnotifyall\"] = gwWebSocketNotifyAll;\r\n        gwConfig[\"disablePermitJoinAutoOff\"] = gwdisablePermitJoinAutoOff;\r\n        gwConfig[\"proxyaddress\"] = gwProxyAddress;\r\n        gwConfig[\"proxyport\"] = gwProxyPort;\r\n        gwConfig[\"zclvaluemaxage\"] = dbZclValueMaxAge;\r\n        gwConfig[\"lightlastseeninterval\"] = gwLightLastSeenInterval;\r\n\r\n        QVariantMap::iterator i = gwConfig.begin();\r\n        QVariantMap::iterator end = gwConfig.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->canConvert(QVariant::String))\r\n            {\r\n                QString sql = QString(QLatin1String(\r\n                                          \"UPDATE config2 SET value = '%2' WHERE key = '%1';\"\r\n                                          \"INSERT INTO config2 (key, value) SELECT '%1', '%2' WHERE (SELECT changes() = 0);\"))\r\n                        .arg(i.key())\r\n                        .arg(i.value().toString());\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_CONFIG;\r\n    }\r\n\r\n    // save userparameter\r\n    if (saveDatabaseItems & DB_USERPARAM)\r\n    {\r\n        QVariantMap::iterator i = gwUserParameter.begin();\r\n        QVariantMap::iterator end = gwUserParameter.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->canConvert(QVariant::String))\r\n            {\r\n                QString sql = QString(QLatin1String(\"REPLACE INTO userparameter (key, value) VALUES ('%1', '%2')\"))\r\n                        .arg(i.key())\r\n                        .arg(i.value().toString());\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        while (!gwUserParameterToDelete.empty())\r\n        {\r\n            QString key = gwUserParameterToDelete.back();\r\n\r\n            // delete parameter from db (if exist)\r\n            QString sql = QString(QLatin1String(\"DELETE FROM userparameter WHERE key='%1'\")).arg(key);\r\n            gwUserParameterToDelete.pop_back();\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_USERPARAM;\r\n    }\r\n\r\n    // save gateways\r\n    if (saveDatabaseItems & DB_GATEWAYS)\r\n    {\r\n        std::vector<Gateway*>::iterator i = gateways.begin();\r\n        std::vector<Gateway*>::iterator end = gateways.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            Gateway *gw = *i;\r\n            if (!gw->needSaveDatabase())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            gw->setNeedSaveDatabase(false);\r\n\r\n            if (!gw->pairingEnabled())\r\n            {\r\n                // delete gateways from db (if exist)\r\n                QString sql = QString(QLatin1String(\"DELETE FROM gateways WHERE uuid='%1'\")).arg(gw->uuid());\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                QByteArray cgroups(\"[]\");\r\n                if (!gw->cascadeGroups().empty())\r\n                {\r\n                    QVariantList ls;\r\n                    for (size_t i = 0; i < gw->cascadeGroups().size(); i++)\r\n                    {\r\n                        const Gateway::CascadeGroup &cg = gw->cascadeGroups()[i];\r\n                        QVariantMap e;\r\n                        e[QLatin1String(\"lg\")] = (double)cg.local;\r\n                        e[QLatin1String(\"rg\")] = (double)cg.remote;\r\n                        ls.push_back(e);\r\n                    }\r\n                    cgroups = Json::serialize(ls);\r\n                }\r\n\r\n                QString sql = QString(QLatin1String(\"REPLACE INTO gateways (uuid, name, ip, port, pairing, apikey, cgroups) VALUES ('%1', '%2', '%3', '%4', '%5', '%6', '%7')\"))\r\n                        .arg(gw->uuid())\r\n                        .arg(gw->name())\r\n                        .arg(gw->address().toString())\r\n                        .arg(gw->port())\r\n                        .arg((gw->pairingEnabled() ? '1' : '0'))\r\n                        .arg(gw->apiKey())\r\n                        .arg(qPrintable(cgroups));\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_GATEWAYS;\r\n    }\r\n\r\n    // save nodes\r\n    if (saveDatabaseItems & DB_LIGHTS)\r\n    {\r\n        std::vector<LightNode>::iterator i = nodes.begin();\r\n        std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (!i->needSaveDatabase())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            i->setNeedSaveDatabase(false);\r\n\r\n            if (i->state() == LightNode::StateDeleted)\r\n            {\r\n                // delete LightNode from db (if exist)\r\n                QString sql = QString(\"DELETE FROM nodes WHERE mac='%1'\").arg(i->uniqueId());\r\n                sql.append(QString(\"; DELETE FROM devices WHERE mac = '%1'\").arg(generateUniqueId(i->address().ext(), 0, 0)));\r\n\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (i->parentResource())\r\n            {\r\n                Device *device = static_cast<Device*>(i->parentResource());\r\n                if (device && device->managed())\r\n                {\r\n                    DB_StoreSubDeviceItems(&*i);\r\n                }\r\n            }\r\n\r\n            std::vector<GroupInfo>::const_iterator gi = i->groups().begin();\r\n            std::vector<GroupInfo>::const_iterator gend = i->groups().end();\r\n\r\n            QStringList groupIds;\r\n            for ( ;gi != gend; ++gi)\r\n            {\r\n                if (gi->state == GroupInfo::StateInGroup)\r\n                {\r\n                    groupIds.append(QString::number((int)gi->id));\r\n                }\r\n            }\r\n\r\n            const QLatin1String lightState(\"normal\");\r\n            QString ritems = dbEscapeString(i->resourceItemsToJson());\r\n            QString sql = QString(QLatin1String(\"REPLACE INTO nodes (id, state, mac, name, groups, endpoint, modelid, manufacturername, swbuildid, ritems) VALUES ('%1', '%2', '%3', '%4', '%5', '%6', '%7', '%8', '%9', '%10')\"))\r\n                    .arg(i->id())\r\n                    .arg(lightState)\r\n                    .arg(i->uniqueId().toLower())\r\n                    .arg(dbEscapeString(i->name()))\r\n                    .arg(groupIds.join(\",\"))\r\n                    .arg(i->haEndpoint().endpoint())\r\n                    .arg(i->modelId())\r\n                    .arg(i->manufacturer())\r\n                    .arg(i->swBuildId())\r\n                    .arg(ritems);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n\r\n            // prevent deletion of nodes with numeric only mac address\r\n            bool deleteUpperCase = false;\r\n            for (int c = 0; c < i->uniqueId().size(); c++)\r\n            {\r\n                char ch = i->uniqueId().at(c).toLatin1();\r\n                if (ch != '-' && ch != ':' && isalpha(ch))\r\n                {\r\n                    deleteUpperCase = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (deleteUpperCase)\r\n            {\r\n                // delete old LightNode with upper case unique id from db (if exist)\r\n                sql = QString(\"DELETE FROM nodes WHERE mac='%1'\").arg(i->uniqueId().toUpper());\r\n            }\r\n\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_LIGHTS;\r\n    }\r\n\r\n    // save/delete groups and scenes\r\n    if (saveDatabaseItems & (DB_GROUPS | DB_SCENES))\r\n    {\r\n        std::vector<Group>::const_iterator i = groups.begin();\r\n        std::vector<Group>::const_iterator end = groups.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            QString gid = \"0x\" + QString(\"%1\").arg(i->address(), 4, 16, QLatin1Char('0')).toUpper();\r\n\r\n            if (i->state() == Group::StateDeleted)\r\n            {\r\n                // delete scenes of this group (if exist)\r\n                QString sql = QString(QLatin1String(\"DELETE FROM scenes WHERE gid='%1'\")).arg(gid);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (i->state() == Group::StateDeleteFromDB)\r\n            {\r\n                // delete group from db (if exist)\r\n                QString sql = QString(QLatin1String(\"DELETE FROM groups WHERE gid='%1'\")).arg(gid);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n            QString grpState((i->state() == Group::StateDeleted ? QLatin1String(\"deleted\") : QLatin1String(\"normal\")));\r\n            QString hidden((i->hidden == true ? QLatin1String(\"true\") : QLatin1String(\"false\")));\r\n            const QString &gtype = i->item(RAttrType)->toString();\r\n            const QString &gclass = i->item(RAttrClass)->toString();\r\n            QString uniqueid;\r\n            const ResourceItem *item = i->item(RAttrUniqueId);\r\n            if (item)\r\n            {\r\n                uniqueid = item->toString();\r\n            }\r\n\r\n            QString sql = QString(QLatin1String(\"REPLACE INTO groups (gid, name, state, mids, devicemembership, lightsequence, hidden, type, class, uniqueid) VALUES ('%1', '%2', '%3', '%4', '%5', '%6', '%7', '%8', '%9', '%10')\"))\r\n                    .arg(gid)\r\n                    .arg(dbEscapeString(i->name()))\r\n                    .arg(grpState)\r\n                    .arg(i->midsToString())\r\n                    .arg(i->dmToString())\r\n                    .arg(i->lightsequenceToString())\r\n                    .arg(hidden)\r\n                    .arg(gtype)\r\n                    .arg(gclass)\r\n                    .arg(uniqueid);\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n\r\n            if (i->state() == Group::StateNormal)\r\n            {\r\n                std::vector<Scene>::const_iterator si = i->scenes.begin();\r\n                std::vector<Scene>::const_iterator send = i->scenes.end();\r\n\r\n                for (; si != send; ++si)\r\n                {\r\n                    QString gsid = \"0x\" + QString(\"%1%2\")\r\n                       .arg(i->address(), 4, 16, QLatin1Char('0'))\r\n                       .arg(si->id, 2, 16, QLatin1Char('0')).toUpper(); // unique key\r\n\r\n                    QString sid = \"0x\" + QString(\"%1\").arg(si->id, 2, 16, QLatin1Char('0')).toUpper();\r\n\r\n                    QString lights = Scene::lightsToString(si->lights());\r\n                    QString sql;\r\n\r\n                    if (si->state == Scene::StateDeleted)\r\n                    {\r\n                        // delete scene from db (if exist)\r\n                        sql = QString(QLatin1String(\"DELETE FROM scenes WHERE gsid='%1'\")).arg(gsid);\r\n                    }\r\n                    else\r\n                    {\r\n                        sql = QString(QLatin1String(\"REPLACE INTO scenes (gsid, gid, sid, name, transitiontime, lights) VALUES ('%1', '%2', '%3', '%4', '%5', '%6')\"))\r\n                            .arg(gsid)\r\n                            .arg(gid)\r\n                            .arg(sid)\r\n                            .arg(dbEscapeString(si->name))\r\n                            .arg(si->transitiontime())\r\n                            .arg(lights);\r\n                    }\r\n                    DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                    errmsg = NULL;\r\n                    rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                    if (rc != SQLITE_OK)\r\n                    {\r\n                        if (errmsg)\r\n                        {\r\n                            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                            sqlite3_free(errmsg);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~(DB_GROUPS | DB_SCENES);\r\n    }\r\n\r\n    // save/delete rules\r\n    if (saveDatabaseItems & DB_RULES)\r\n    {\r\n        auto i = rules.begin();\r\n        const auto end = rules.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (!i->needSaveDatabase())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            i->clearNeedSaveDatabase();\r\n\r\n            const QString &rid = i->id();\r\n\r\n            if (i->state() == Rule::StateDeleted)\r\n            {\r\n                // delete rule from db (if exist)\r\n                QString sql = QString(QLatin1String(\"DELETE FROM rules WHERE rid='%1'\")).arg(rid);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            QString actionsJSON = Rule::actionsToString(i->actions());\r\n            QString conditionsJSON = Rule::conditionsToString(i->conditions());\r\n            QString lastTriggered;\r\n\r\n            if (i->lastTriggered().isValid())\r\n            {\r\n                lastTriggered = i->lastTriggered().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\"));\r\n            }\r\n            else\r\n            {\r\n                lastTriggered = QLatin1String(\"none\");\r\n            }\r\n\r\n            QString sql = QLatin1String(\"REPLACE INTO rules (rid, name, created, etag, lasttriggered, owner, status, timestriggered, actions, conditions, periodic) VALUES ('\") +\r\n                    rid + QLatin1String(\"','\") +\r\n                    i->name() + QLatin1String(\"','\") +\r\n                    i->creationtime() + QLatin1String(\"','\") +\r\n                    i->etag + QLatin1String(\"','\") +\r\n                    lastTriggered + QLatin1String(\"','\") +\r\n                    i->owner() + QLatin1String(\"','\") +\r\n                    i->status() + QLatin1String(\"','\") +\r\n                    QString::number(i->timesTriggered()) + QLatin1String(\"','\") +\r\n                    actionsJSON + QLatin1String(\"','\") +\r\n                    conditionsJSON + QLatin1String(\"','\") +\r\n                    QString::number(i->triggerPeriodic()) + QLatin1String(\"')\");\r\n\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_RULES;\r\n    }\r\n\r\n    // save/delete resourcelinks\r\n    if (saveDatabaseItems & DB_RESOURCELINKS)\r\n    {\r\n        for (Resourcelinks &rl : resourcelinks)\r\n        {\r\n            if (!rl.needSaveDatabase())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            rl.setNeedSaveDatabase(false);\r\n\r\n            if (rl.state == Resourcelinks::StateNormal)\r\n            {\r\n                QString json = Json::serialize(rl.data);\r\n                QString sql = QString(QLatin1String(\"REPLACE INTO resourcelinks (id, json) VALUES ('%1', '%2')\"))\r\n                        .arg(rl.id)\r\n                        .arg(json);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n            else if (rl.state == Resourcelinks::StateDeleted)\r\n            {\r\n                QString sql = QString(QLatin1String(\"DELETE FROM resourcelinks WHERE id='%1'\")).arg(rl.id);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_RESOURCELINKS;\r\n    }\r\n\r\n    // save/delete schedules\r\n    if (saveDatabaseItems & DB_SCHEDULES)\r\n    {\r\n        std::vector<Schedule>::iterator i = schedules.begin();\r\n        std::vector<Schedule>::iterator end = schedules.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->state ==Schedule::StateNormal)\r\n            {\r\n                QString sql = QString(QLatin1String(\"REPLACE INTO schedules (id, json) VALUES ('%1', '%2')\"))\r\n                        .arg(i->id)\r\n                        .arg(i->jsonString);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n            }\r\n            else if (i->state == Schedule::StateDeleted)\r\n            {\r\n                QString sql = QString(QLatin1String(\"DELETE FROM schedules WHERE id='%1'\")).arg(i->id);\r\n\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    //i = schedules.erase(i);\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_SCHEDULES;\r\n    }\r\n\r\n    // save/delete sensors\r\n    if (saveDatabaseItems & DB_SENSORS)\r\n    {\r\n        std::vector<Sensor>::iterator i = sensors.begin();\r\n        std::vector<Sensor>::iterator end = sensors.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n\r\n            if (!i->needSaveDatabase())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            i->setNeedSaveDatabase(false);\r\n\r\n            if (i->deletedState() == Sensor::StateDeleted)\r\n            {\r\n                // delete sensor from db (if exist)\r\n                QString sql = QString(\"DELETE FROM sensors WHERE uniqueid='%1'\").arg(i->uniqueId());\r\n                sql.append(QString(\"; DELETE FROM devices WHERE mac = '%1'\").arg(generateUniqueId(i->address().ext(), 0, 0)));\r\n\r\n                errmsg = NULL;\r\n                rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n                if (rc != SQLITE_OK)\r\n                {\r\n                    if (errmsg)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                        sqlite3_free(errmsg);\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // don't store incomplete DDF draft sensors\r\n            if (i->type().startsWith('Z'))\r\n            {\r\n                unsigned ep = endpointFromUniqueId(i->uniqueId());\r\n                if (ep == 0xFF || ep == 0)\r\n                {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (i->parentResource())\r\n            {\r\n                Device *device = static_cast<Device*>(i->parentResource());\r\n                if (device && device->managed())\r\n                {\r\n                    DB_StoreSubDeviceItems(&*i);\r\n                }\r\n            }\r\n\r\n            QString stateJSON = i->stateToString();\r\n            QString configJSON = i->configToString();\r\n            QString fingerPrintJSON = i->fingerPrint().toString();\r\n            const QString deletedState = \"normal\";\r\n\r\n            QString sql = QString(QLatin1String(\"REPLACE INTO sensors (sid, name, type, modelid, manufacturername, uniqueid, swversion, state, config, fingerprint, deletedState, mode, lastseen, lastannounced) VALUES ('%1', '%2', '%3', '%4', '%5', '%6', '%7', '%8', '%9', '%10', '%11', '%12', '%13', '%14')\"))\r\n                    .arg(i->id())\r\n                    .arg(dbEscapeString(i->name()))\r\n                    .arg(i->type())\r\n                    .arg(i->modelId())\r\n                    .arg(i->manufacturer())\r\n                    .arg(i->uniqueId())\r\n                    .arg(i->swVersion())\r\n                    .arg(stateJSON)\r\n                    .arg(configJSON)\r\n                    .arg(fingerPrintJSON)\r\n                    .arg(deletedState)\r\n                    .arg(QString::number(i->mode()))\r\n                    .arg(i->lastSeen())\r\n                    .arg(i->lastAnnounced());\r\n\r\n            DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n        }\r\n\r\n        saveDatabaseItems &= ~DB_SENSORS;\r\n    }\r\n\r\n    // process query queue\r\n    if (saveDatabaseItems & DB_QUERY_QUEUE)\r\n    {\r\n        for (const QString &sql : dbQueryQueue)\r\n        {\r\n            if (DBG_IsEnabled(DBG_INFO_L2))\r\n            {\r\n                DBG_Printf(DBG_INFO_L2, \"DB sql exec %s\\n\", qPrintable(sql));\r\n            }\r\n\r\n            errmsg = NULL;\r\n            rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n            if (rc != SQLITE_OK)\r\n            {\r\n                if (errmsg)\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                    sqlite3_free(errmsg);\r\n                }\r\n            }\r\n        }\r\n\r\n        dbQueryQueue.clear();\r\n        saveDatabaseItems &= ~DB_QUERY_QUEUE;\r\n    }\r\n\r\n    errmsg = NULL;\r\n    rc = sqlite3_exec(db, \"COMMIT\", 0, 0, &errmsg);\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: COMMIT, error: %s (%d)\\n\", errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        // if the transaction is still intact (SQLITE_BUSY) it will be committed on the next run of saveDb()\r\n    }\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"DB saved in %ld ms\\n\", (long)measTimer.elapsed());\r\n\r\n        if (saveDatabaseItems & DB_SYNC)\r\n        {\r\n#ifdef Q_OS_LINUX\r\n            QElapsedTimer measTimer;\r\n            measTimer.restart();\r\n            sync();\r\n            DBG_Printf(DBG_INFO_L2, \"sync() in %d ms\\n\", int(measTimer.elapsed()));\r\n#endif\r\n            saveDatabaseItems &= ~DB_SYNC;\r\n        }\r\n    }\r\n}\r\n\r\n/*! Closes the database.\r\n    If closing fails for some reason the db pointer is not 0 and the database left open.\r\n */\r\nvoid DeRestPluginPrivate::closeDb()\r\n{\r\n    if (db)\r\n    {\r\n        if (ttlDataBaseConnection > idleTotalCounter)\r\n        {\r\n            return;\r\n        }\r\n\r\n        int ret = sqlite3_close(db);\r\n        if (ret == SQLITE_OK)\r\n        {\r\n            db = nullptr;\r\n#ifdef Q_OS_LINUX\r\n            QElapsedTimer measTimer;\r\n            measTimer.restart();\r\n            sync();\r\n            DBG_Printf(DBG_INFO, \"sync() in %d ms\\n\", int(measTimer.elapsed()));\r\n#endif\r\n            return;\r\n        }\r\n        else if (ret == SQLITE_BUSY)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"sqlite3_close() busy %d\\n\", ret);\r\n            return; // close later\r\n        }\r\n\r\n        DBG_Printf(DBG_INFO, \"sqlite3_close() failed %d\\n\", ret);\r\n    }\r\n\r\n    DBG_Assert(db == 0);\r\n}\r\n\r\n/*! Request saving of database.\r\n   \\param items - bitmap of DB_ flags\r\n   \\param msec - delay in milliseconds\r\n */\r\nvoid DeRestPluginPrivate::queSaveDb(int items, int msec)\r\n{\r\n    saveDatabaseItems |= items;\r\n\r\n    if (databaseTimer->isActive())\r\n    {\r\n        // prefer shorter interval\r\n        if (databaseTimer->interval() > msec)\r\n        {\r\n            databaseTimer->stop();\r\n            databaseTimer->start(msec);\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    databaseTimer->start(msec);\r\n}\r\n\r\nstatic int sqliteLastZbconfCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    Q_UNUSED(colname);\r\n    QString *str = static_cast<QString*>(user);\r\n    if (!str || ncols != 1)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    *str = QString::fromUtf8(colval[0]);\r\n    return 0;\r\n}\r\n\r\n/* Get the last known working zigbee configuration from database. */\r\nvoid DeRestPluginPrivate::getLastZigBeeConfigDb(QString &out)\r\n{\r\n\r\n    QString sql = QLatin1String(\"SELECT conf FROM zbconf ORDER BY rowid desc limit 1\");\r\n\r\n    DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n    char *errmsg = NULL;\r\n    int rc = sqlite3_exec(db, qPrintable(sql), sqliteLastZbconfCallback, &out, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Returns a list of all Zigbee network configurations. */\r\nvoid DeRestPluginPrivate::getZigbeeConfigDb(QVariantList &out)\r\n{\r\n    openDb();\r\n\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    int rc;\r\n    sqlite3_stmt *res = nullptr;\r\n    const char * sql = \"SELECT rowid, conf FROM zbconf\";\r\n\r\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, nullptr);\r\n    DBG_Assert(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    while (1)\r\n    {\r\n        rc = sqlite3_step(res);\r\n        DBG_Assert(rc == SQLITE_ROW);\r\n        if (rc != SQLITE_ROW)\r\n        {\r\n            break;\r\n        }\r\n\r\n        int rowid = sqlite3_column_int(res, 0);\r\n        const char* conf = reinterpret_cast<const char*>(sqlite3_column_text(res, 1));\r\n        const auto size = sqlite3_column_bytes(res, 1);\r\n\r\n        if (!conf || size <= 100 || size > 2048)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        QVariantMap map = Json::parse(QLatin1String(conf)).toMap();\r\n\r\n        if (map.isEmpty())\r\n        {\r\n            continue;\r\n        }\r\n\r\n        map[\"id\"] = rowid;\r\n\r\n        out.push_back(map);\r\n\r\n        DBG_Printf(DBG_INFO, \"ZB rowid %d, conf: %s\\n\", rowid, conf);\r\n    }\r\n\r\n    rc = sqlite3_finalize(res);\r\n    DBG_Assert(rc == SQLITE_OK);\r\n\r\n    closeDb();\r\n}\r\n\r\n/*! Deletes a device from the database.\r\n\r\n    Due the foreign keys this affects the tables:\r\n    - device\r\n    - device_descriptors\r\n    - device_gui\r\n    - source_routes\r\n    - source_route_hops\r\n */\r\nvoid DeRestPluginPrivate::deleteDeviceDb(const QString &uniqueId)\r\n{\r\n    DBG_Assert(!uniqueId.isEmpty());\r\n\r\n    openDb();\r\n    DBG_Assert(db);\r\n    if (!db)\r\n    {\r\n        return;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    const auto sql = QString(\"DELETE FROM devices WHERE mac = '%1'\").arg(uniqueId);\r\n    int rc = sqlite3_exec(db, sql.toUtf8().constData(), NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s, line: %d\\n\", qPrintable(sql), errmsg, __LINE__);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    closeDb();\r\n}\r\n\r\n/*! Put working ZigBee configuration in database for later recovery or fail safe operations.\r\n    - An entry is only added when different from last entry.\r\n    - Entries are only added, never modified, this way errors or unwanted changes can be debugged.\r\n    - Too old entries might be delated later on sqlite3 'rowid' provides timed order.\r\n */\r\nvoid DeRestPluginPrivate::updateZigBeeConfigDb()\r\n{\r\n    if (!apsCtrl)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (apsCtrl->getParameter(deCONZ::ParamDeviceConnected) == 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwFirmwareVersion.startsWith(QLatin1String(\"0x0000000\"))) // 0x00000000 and 0x00000001\r\n    {\r\n        return;\r\n    }\r\n\r\n    QString conf;\r\n    getLastZigBeeConfigDb(conf);\r\n\r\n    QDateTime now = QDateTime::currentDateTime();\r\n    if (conf.isEmpty()) // initial\r\n    {}\r\n    else if (!zbConfigGood.isValid() || (zbConfigGood.secsTo(now) > CHECK_ZB_GOOD_INTERVAL) || (now < zbConfigGood))\r\n    {\r\n        return;\r\n    }\r\n\r\n    uint8_t deviceType = apsCtrl->getParameter(deCONZ::ParamDeviceType);\r\n    uint16_t panId = apsCtrl->getParameter(deCONZ::ParamPANID);\r\n    quint64 extPanId = apsCtrl->getParameter(deCONZ::ParamExtendedPANID);\r\n    quint64 apsUseExtPanId = apsCtrl->getParameter(deCONZ::ParamApsUseExtendedPANID);\r\n    uint64_t macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\r\n    uint16_t nwkAddress = apsCtrl->getParameter(deCONZ::ParamNwkAddress);\r\n    uint8_t staticNwkAddress = apsCtrl->getParameter(deCONZ::ParamStaticNwkAddress);\r\n    uint8_t curChannel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\r\n    uint8_t securityMode = apsCtrl->getParameter(deCONZ::ParamSecurityMode);\r\n    quint64 tcAddress = apsCtrl->getParameter(deCONZ::ParamTrustCenterAddress);\r\n    QByteArray networkKey = apsCtrl->getParameter(deCONZ::ParamNetworkKey);\r\n    uint8_t nwkUpdateId = apsCtrl->getParameter(deCONZ::ParamNetworkUpdateId);\r\n\r\n    // some basic checks for common configuration as HA coordinator\r\n    if (macAddress == 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (deviceType != deCONZ::Coordinator)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (deviceType == deCONZ::Coordinator)\r\n    {\r\n        // 0 is required and means the used extended panid will become\r\n        // coordinator mac address once network is up\r\n        if (apsUseExtPanId != 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (tcAddress != macAddress)\r\n        {\r\n            return;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        return; // router currently not supported\r\n    }\r\n\r\n    if (curChannel < 11 || curChannel > 26)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (securityMode != 3) // no master but tc link key\r\n    {\r\n        return;\r\n    }\r\n\r\n    QVariantMap map;\r\n    map[\"deviceType\"] = deviceType;\r\n    map[\"panId\"] = QString(\"0x%1\").arg(QString::number(panId,16));\r\n    map[\"extPanId\"] = QString(\"0x%1\").arg(QString::number(extPanId,16));\r\n    map[\"apsUseExtPanId\"] = QString(\"0x%1\").arg(QString::number(apsUseExtPanId,16));\r\n    map[\"macAddress\"] = QString(\"0x%1\").arg(QString::number(macAddress,16));\r\n    map[\"staticNwkAddress\"] = (staticNwkAddress == 0) ? false : true;\r\n    map[\"nwkAddress\"] = QString(\"0x%1\").arg(QString::number(nwkAddress,16));\r\n    map[\"curChannel\"] = curChannel;\r\n    map[\"securityMode\"] = securityMode;\r\n    map[\"tcAddress\"] = QString(\"0x%1\").arg(QString::number(tcAddress,16));\r\n    map[\"networkKey\"] = networkKey.toHex();\r\n    map[\"nwkUpdateId\"] = nwkUpdateId;\r\n    map[\"swversion\"] = QLatin1String(GW_SW_VERSION);\r\n    map[\"fwversion\"] = gwFirmwareVersion;\r\n\r\n    bool success = true;\r\n    QString curConf = Json::serialize(map, success);\r\n    if (!success)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (conf == curConf) // nothing changed\r\n    {\r\n        return;\r\n    }\r\n\r\n    {\r\n        QString sql = QString(QLatin1String(\"INSERT INTO zbconf (conf) VALUES ('%1')\")).arg(curConf);\r\n\r\n        DBG_Printf(DBG_INFO_L2, \"sql exec %s\\n\", qPrintable(sql));\r\n        char * errmsg = NULL;\r\n        int rc = sqlite3_exec(db, qPrintable(sql), NULL, NULL, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"sqlite3_exec failed: %s, error: %s\\n\", qPrintable(sql), errmsg);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*! Checks various data for consistency.\r\n */\r\nvoid DeRestPluginPrivate::checkConsistency()\r\n{\r\n    if (gwProxyAddress == QLatin1String(\"none\"))\r\n    {\r\n        gwProxyPort = 0;\r\n    }\r\n}\r\n\r\n/*! Timer handler for storing persistent data.\r\n */\r\nvoid DeRestPluginPrivate::saveDatabaseTimerFired()\r\n{\r\n    if (otauLastBusyTimeDelta() < OTA_LOW_PRIORITY_TIME)\r\n    {\r\n        if ((idleTotalCounter - saveDatabaseIdleTotalCounter) < (60 * 30))\r\n        {\r\n            databaseTimer->start(DB_SHORT_SAVE_DELAY);\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (permitJoinFlag) // don't save database while joining devices\r\n    {\r\n        databaseTimer->start(DB_SHORT_SAVE_DELAY);\r\n        return;\r\n    }\r\n\r\n    if (saveDatabaseItems & DB_NOSAVE)\r\n    {\r\n        databaseTimer->start(DB_SHORT_SAVE_DELAY);\r\n        return;\r\n    }\r\n\r\n    if (saveDatabaseItems)\r\n    {\r\n        saveDatabaseIdleTotalCounter = idleTotalCounter;\r\n        openDb();\r\n        saveDb();\r\n        closeDb();\r\n\r\n        DBG_Assert(saveDatabaseItems == 0);\r\n    }\r\n}\r\n\r\nbool DB_StoreSecret(const DB_Secret &secret)\r\n{\r\n    if (!db || secret.uniqueId.empty())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    std::vector<char> sql(512);\r\n\r\n    int rc = snprintf(sql.data(), sql.size(), \"REPLACE INTO secrets (uniqueid,secret,state) VALUES ('%s','%s',%d)\", secret.uniqueId.data(), secret.secret.data(), secret.state);\r\n\r\n    if (rc >= int(sql.size()))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql.data(), NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", sql.data(), errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*! Sqlite callback to load userparameter data.\r\n */\r\nstatic int sqliteLoadSecretCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    DB_Secret *secret = static_cast<DB_Secret*>(user);\r\n\r\n    if (ncols == 2 && secret)\r\n    {\r\n        secret->secret = colval[0];\r\n        secret->state = std::strtoul(colval[1], nullptr, 10);\r\n        return 0;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nbool DB_LoadSecret(DB_Secret &secret)\r\n{\r\n    if (!db || secret.uniqueId.empty())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char sql[200];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"SELECT secret,state FROM secrets WHERE uniqueid = '%s'\", secret.uniqueId.data());\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, sqliteLoadSecretCallback, &secret, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return !secret.secret.empty();\r\n}\r\n\r\nstatic bool initSecretsTable()\r\n{\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const char *sql = \"CREATE TABLE IF NOT EXISTS secrets (uniqueid TEXT PRIMARY KEY, secret TEXT, state INTEGER)\";\r\n\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, sql, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nstatic bool initAlarmSystemsTable()\r\n{\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    const char *sql = \"CREATE TABLE IF NOT EXISTS alarm_systems (id INTEGER PRIMARY KEY ON CONFLICT IGNORE, timestamp INTEGER NOT NULL)\";\r\n\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, sql, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    sql = \"CREATE TABLE if NOT EXISTS alarm_systems_ritems (\"\r\n          \" suffix TEXT PRIMARY KEY ON CONFLICT REPLACE,\"\r\n          \" as_id INTEGER,\"\r\n          \" value TEXT NOT NULL,\"\r\n          \" timestamp INTEGER NOT NULL,\"\r\n          \" FOREIGN KEY(as_id) REFERENCES alarm_systems(id) ON DELETE CASCADE)\";\r\n\r\n    errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    sql = \"CREATE TABLE if NOT EXISTS alarm_systems_devices (\"\r\n          \" uniqueid TEXT PRIMARY KEY ON CONFLICT REPLACE,\"\r\n          \" as_id INTEGER,\"\r\n          \" flags INTEGER NOT NULL,\"\r\n          \" timestamp INTEGER NOT NULL,\"\r\n          \" FOREIGN KEY(as_id) REFERENCES alarm_systems(id) ON DELETE CASCADE)\";\r\n\r\n    errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nbool DB_StoreAlarmSystem(const DB_AlarmSystem &alarmSys)\r\n{\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char sql[200];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"REPLACE INTO alarm_systems (id,timestamp) VALUES ('%d',%\" PRIu64 \")\", alarmSys.id, alarmSys.timestamp);\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nbool DB_StoreAlarmSystemResourceItem(const DB_AlarmSystemResourceItem &item)\r\n{\r\n    if (!db || !item.suffix || item.value.empty())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char sql[200];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"REPLACE INTO alarm_systems_ritems (suffix,as_id,value,timestamp) VALUES ('%s','%d','%s',%\" PRIu64 \")\", item.suffix, item.alarmSystemId, item.value.data(), item.timestamp);\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*! Sqlite callback to load alarm system resource items.\r\n */\r\nstatic int sqliteLoadAlarmSystemResourceItemsCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_AlarmSystemResourceItem>*>(user);\r\n\r\n    if (ncols == 3 && result)\r\n    {\r\n        ResourceItemDescriptor rid;\r\n        if (getResourceItemDescriptor(QLatin1String(colval[0]), rid))\r\n        {\r\n            DB_AlarmSystemResourceItem item;\r\n            item.suffix = rid.suffix;\r\n            item.value = colval[1];\r\n            item.timestamp = std::strtoull(colval[2], nullptr, 10);\r\n            result->push_back(item);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nstd::vector<DB_AlarmSystemResourceItem> DB_LoadAlarmSystemResourceItems(int alarmSystemId)\r\n{\r\n    std::vector<DB_AlarmSystemResourceItem> result;\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    char sql[200];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"SELECT suffix,value,timestamp FROM alarm_systems_ritems WHERE as_id = '%d'\", alarmSystemId);\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return result;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, sqliteLoadAlarmSystemResourceItemsCallback, &result, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nbool DB_StoreAlarmSystemDevice(const DB_AlarmSystemDevice &dev)\r\n{\r\n    if (!db || isEmptyString(dev.uniqueid))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char sql[200];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"REPLACE INTO alarm_systems_devices (uniqueid,as_id,flags,timestamp) VALUES ('%s','%d','%d',%\" PRIu64 \")\", dev.uniqueid, dev.alarmSystemId, dev.flags, dev.timestamp);\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, NULL, NULL, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"DB sqlite3_exec failed: %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*! Sqlite callback to load alarm system devices.\r\n */\r\nstatic int sqliteLoadAlarmSystemDevicesCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_AlarmSystemDevice>*>(user);\r\n\r\n    if (ncols == 3 && result)\r\n    {\r\n        DB_AlarmSystemDevice item;\r\n\r\n        copyString(item.uniqueid, sizeof(item.uniqueid), colval[0]);\r\n        item.alarmSystemId = std::strtoul(colval[1], nullptr, 10);\r\n        item.flags = std::strtoul(colval[2], nullptr, 10);\r\n\r\n        DBG_Assert(!isEmptyString(item.uniqueid));\r\n        DBG_Assert(item.alarmSystemId != 0);\r\n        if (!isEmptyString(item.uniqueid) && item.alarmSystemId != 0)\r\n        {\r\n            result->push_back(item);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nstd::vector<DB_AlarmSystemDevice> DB_LoadAlarmSystemDevices()\r\n{\r\n    std::vector<DB_AlarmSystemDevice> result;\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    const char *sql = \"SELECT uniqueid,as_id,flags FROM alarm_systems_devices\";\r\n\r\n    char *errmsg = nullptr;\r\n    int rc = sqlite3_exec(db, sql, sqliteLoadAlarmSystemDevicesCallback, &result, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nbool DB_DeleteAlarmSystemDevice(const std::string &uniqueId)\r\n{\r\n    if (!db || uniqueId.empty())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char sql[160];\r\n\r\n    int rc = snprintf(sql, sizeof(sql), \"DELETE FROM alarm_systems_devices WHERE uniqueid = '%s'\", uniqueId.data());\r\n\r\n    if (rc >= int(sizeof(sql)))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    char *errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"sqlite3_exec %s, error: %s\\n\", sql, errmsg);\r\n            sqlite3_free(errmsg);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*!\r\n */\r\nbool DB_LoadZclValue(DB_ZclValue *val)\r\n{\r\n    if (!db || val->deviceId < 0)\r\n        return false;\r\n\r\n    const auto loadCallback = [](void *user, int ncols, char **colval , char **) -> int\r\n    {\r\n        long data;\r\n        U_SStream ss;\r\n        DB_ZclValue *v = static_cast<DB_ZclValue*>(user);\r\n\r\n        if (ncols != 1)\r\n            return 1;\r\n\r\n        U_sstream_init(&ss, colval[0], U_StringLength(colval[0]));\r\n        data = U_sstream_get_long(&ss); // TODO no 64-bit yet on 32-bit platforms..\r\n        if (ss.status != U_SSTREAM_OK)\r\n            return 1;\r\n\r\n        v->data = data;\r\n        v->loaded = 1;\r\n\r\n        return 0;\r\n    };\r\n\r\n    U_SStream ss;\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n    U_sstream_put_str(&ss, \"SELECT data FROM zcl_values WHERE device_id = \");\r\n    U_sstream_put_long(&ss, val->deviceId);\r\n    if (val->endpoint != 0)\r\n    {\r\n        U_sstream_put_str(&ss, \" AND endpoint = \");\r\n        U_sstream_put_long(&ss, val->endpoint);\r\n    }\r\n    U_sstream_put_str(&ss, \" AND cluster = \");\r\n    U_sstream_put_long(&ss, val->clusterId);\r\n    U_sstream_put_str(&ss, \" AND attribute = \");\r\n    U_sstream_put_long(&ss, val->attrId);\r\n\r\n    val->loaded = 0;\r\n    int rc = sqlite3_exec(db, sqlBuf, loadCallback, val, nullptr);\r\n\r\n    if (rc == SQLITE_OK && val->loaded == 1)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool DB_StoreZclValue(const DB_ZclValue *val)\r\n{\r\n    if (!db || val->deviceId < 0)\r\n        return false;\r\n\r\n    DB_ZclValue v0 = *val;\r\n\r\n    if (DB_LoadZclValue(&v0) && v0.data == val->data)\r\n    {\r\n        return true; // already present\r\n    }\r\n\r\n    U_SStream ss;\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n    U_sstream_put_str(&ss, \"INSERT INTO zcl_values (device_id,endpoint,cluster,attribute,data,timestamp) VALUES (\");\r\n    U_sstream_put_long(&ss, val->deviceId);\r\n    U_sstream_put_str(&ss, \", \");\r\n    U_sstream_put_long(&ss, val->endpoint);\r\n    U_sstream_put_str(&ss, \", \");\r\n    U_sstream_put_long(&ss, val->clusterId);\r\n    U_sstream_put_str(&ss, \", \");\r\n    U_sstream_put_long(&ss, val->attrId);\r\n    U_sstream_put_str(&ss, \", \");\r\n    U_sstream_put_long(&ss, val->data);\r\n    U_sstream_put_str(&ss, \", strftime('%s','now'));\");\r\n\r\n    if (SQLITE_OK == sqlite3_exec(db, sqlBuf, nullptr, nullptr, nullptr))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool DB_StoreSubDevice(const char *uniqueId)\r\n{\r\n    U_SStream ss;\r\n    unsigned len;\r\n    char mac[32]; // mac address\r\n\r\n    U_ASSERT(uniqueId);\r\n    if (!uniqueId)\r\n        return false;\r\n\r\n    len = U_StringLength(uniqueId);\r\n    U_ASSERT(len > 8);\r\n    if (len < 8) // note should be larger than 8, but anyway..\r\n        return false;\r\n\r\n    U_sstream_init(&ss, (void*)uniqueId, len);\r\n\r\n    if (U_sstream_find(&ss, \"-\") == 0)\r\n        return false;\r\n\r\n    if (ss.pos >= sizeof(mac))\r\n        return false;\r\n\r\n    U_memcpy(mac, uniqueId, ss.pos);\r\n    mac[ss.pos] = '\\0';\r\n    ss.pos++; // point after '-'\r\n\r\n    // sanity check that we have a valid endpoint in the uniqueId\r\n    unsigned ep = U_sstream_get_hex_byte(&ss);\r\n    if (ep == 0 || ep == 255)\r\n        return false;\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n        return false;\r\n\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n    U_sstream_put_str(&ss, \"INSERT INTO sub_devices (device_id,uniqueid,timestamp)\");\r\n    U_sstream_put_str(&ss, \" SELECT id, '\");\r\n    U_sstream_put_str(&ss, uniqueId);\r\n    U_sstream_put_str(&ss, \"', \");\r\n    U_sstream_put_longlong(&ss, QDateTime::currentMSecsSinceEpoch() / 1000);\r\n    U_sstream_put_str(&ss, \" FROM devices WHERE mac = '\");\r\n    U_sstream_put_str(&ss, mac);\r\n    U_sstream_put_str(&ss, \"'\");\r\n\r\n    char *errmsg = nullptr;\r\n\r\n    int rc = sqlite3_exec(db, sqlBuf, nullptr, nullptr, &errmsg);\r\n\r\n    if (rc != SQLITE_OK)\r\n    {\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n    return true;\r\n}\r\n\r\nbool DB_StoreDeviceItem(int deviceId, const DB_ResourceItem2 &item)\r\n{\r\n    U_SStream ss;\r\n    U_ASSERT(deviceId >= 0);\r\n    U_ASSERT(item.name.size() > 0);\r\n    U_ASSERT(item.valueSize != 0);\r\n    U_ASSERT(item.valueSize < sizeof(item.value));\r\n    U_ASSERT(item.value[item.valueSize] == '\\0' && \"item.value must be null terminated\");\r\n\r\n    if (item.valueSize == 0)\r\n        return 0;\r\n\r\n    if (sizeof(item.value) <= item.valueSize)\r\n        return false;\r\n\r\n    if (item.value[item.valueSize] != '\\0')\r\n        return false;\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // 1) update or insert\r\n\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n    U_sstream_put_str(&ss, \"INSERT INTO dev_resource_items (device_id,item,value,timestamp)\"\r\n                           \" VALUES (\");\r\n    U_sstream_put_long(&ss, deviceId);\r\n    U_sstream_put_str(&ss, \",'\");\r\n    U_sstream_put_str(&ss, item.name.c_str());\r\n    U_sstream_put_str(&ss, \"','\");\r\n    U_sstream_put_str(&ss, item.value);\r\n    U_sstream_put_str(&ss, \"',\");\r\n    U_sstream_put_longlong(&ss, item.timestampMs);\r\n    U_sstream_put_str(&ss, \")\");\r\n\r\n    int rc = SQLITE_ERROR;\r\n\r\n    if (ss.status == U_SSTREAM_OK)\r\n    {\r\n        char *errmsg = nullptr;\r\n\r\n        rc = sqlite3_exec(db, sqlBuf, nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    if (rc == SQLITE_OK)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool DB_ResourceItem2DbItem(const ResourceItem *rItem, DB_ResourceItem2 *dbItem)\r\n{\r\n    U_ASSERT(rItem);\r\n    U_ASSERT(dbItem);\r\n\r\n    if (rItem && dbItem)\r\n    {\r\n        U_SStream ss;\r\n\r\n        dbItem->timestampMs = rItem->lastSet().toMSecsSinceEpoch();\r\n        dbItem->name = rItem->descriptor().suffix;\r\n        U_sstream_init(&ss, dbItem->value, sizeof(dbItem->value));\r\n        U_sstream_put_str(&ss, rItem->toCString());\r\n        dbItem->valueSize = ss.pos;\r\n        return dbItem->valueSize != 0;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nstatic int DB_LoadDeviceItemsCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_ResourceItem2>*>(user);\r\n    U_ASSERT(result);\r\n    U_ASSERT(ncols == 3);\r\n\r\n    DB_ResourceItem2 ritem;\r\n\r\n    if (ritem.name.maxSize() < U_StringLength(colval[0]))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ritem.name = colval[0];\r\n\r\n    ritem.valueSize = U_StringLength(colval[1]);\r\n    if (ritem.valueSize >= sizeof(ritem.value))\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    U_memcpy(ritem.value, colval[1], ritem.valueSize);\r\n    ritem.value[ritem.valueSize] = '\\0';\r\n\r\n    ritem.timestampMs = QString(colval[2]).toLongLong() * 1000;\r\n\r\n    if (!ritem.name.empty() && ritem.valueSize != 0)\r\n    {\r\n        result->push_back(std::move(ritem));\r\n    }\r\n    return 0;\r\n};\r\n\r\nbool DB_LoadDeviceItems(int deviceId, std::vector<DB_ResourceItem2> &items)\r\n{\r\n    U_SStream ss;\r\n    U_ASSERT(deviceId >= 0);\r\n\r\n    items.clear();\r\n\r\n    if (deviceId < 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    U_sstream_init(&ss, sqlBuf, sizeof(sqlBuf));\r\n\r\n\r\n    U_sstream_put_str(&ss, \"SELECT item,value,timestamp FROM dev_resource_items WHERE device_id = \");\r\n    U_sstream_put_long(&ss, deviceId);\r\n\r\n    if (ss.status == U_SSTREAM_OK)\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadDeviceItemsCallback, &items, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return items.size() != 0;\r\n}\r\n\r\nstatic int DB_LoadIdentifiersCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_IdentifierPair>*>(user);\r\n    U_ASSERT(result);\r\n    U_ASSERT(ncols == 2);\r\n\r\n    DB_IdentifierPair ident;\r\n    const char *modelid = colval[0];\r\n    const char *mfname = colval[1];\r\n    unsigned modelidLength = U_StringLength(modelid);\r\n    unsigned mfnameLength = U_StringLength(mfname);\r\n\r\n    if (modelidLength && mfnameLength)\r\n    {\r\n        AT_AtomIndex ati;\r\n\r\n        if (AT_AddAtom(modelid, modelidLength, &ati) == 0)\r\n            return 1;\r\n\r\n        ident.modelIdAtomIndex = ati.index;\r\n\r\n        if (AT_AddAtom(mfname, mfnameLength, &ati) == 0)\r\n            return 1;\r\n\r\n        ident.mfnameAtomIndex = ati.index;\r\n\r\n        result->push_back(ident);\r\n        return 0;\r\n    }\r\n    return 0;\r\n};\r\n\r\nstatic int DB_LoadIdentifiersLegacyCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_IdentifierPair>*>(user);\r\n    U_ASSERT(result);\r\n    U_ASSERT(ncols == 2);\r\n\r\n    DB_IdentifierPair ident;\r\n    const char *modelid = colval[0];\r\n    const char *mfname = colval[1];\r\n    unsigned modelidLength = U_StringLength(modelid);\r\n    unsigned mfnameLength = U_StringLength(mfname);\r\n\r\n    if (modelidLength && mfnameLength)\r\n    {\r\n        {\r\n            U_SStream ss;\r\n            U_sstream_init(&ss, (void*)modelid, modelidLength);\r\n\r\n            // coordinator identifiers are not of interest\r\n            if (U_sstream_starts_with(&ss, \"ConBee\") || U_sstream_starts_with(&ss, \"RaspBee\"))\r\n                return 0;\r\n        }\r\n\r\n        AT_AtomIndex ati;\r\n\r\n        if (AT_AddAtom(modelid, modelidLength, &ati) == 0)\r\n            return 1;\r\n\r\n        ident.modelIdAtomIndex = ati.index;\r\n\r\n        if (AT_AddAtom(mfname, mfnameLength, &ati) == 0)\r\n            return 1;\r\n\r\n        ident.mfnameAtomIndex = ati.index;\r\n\r\n        for (size_t i = 0; i < result->size(); i++)\r\n        {\r\n            const auto &ipair = result->at(i);\r\n\r\n            if (ipair.mfnameAtomIndex == ident.mfnameAtomIndex &&\r\n                ipair.modelIdAtomIndex == ident.modelIdAtomIndex)\r\n            {\r\n                return 0; // already known\r\n            }\r\n        }\r\n\r\n        result->push_back(ident);\r\n        return 0;\r\n    }\r\n    return 0;\r\n};\r\n\r\n\r\nstd::vector<DB_IdentifierPair> DB_LoadIdentifierPairs()\r\n{\r\n    int rc;\r\n    char *errmsg = nullptr;\r\n    std::vector<DB_IdentifierPair> result;\r\n\r\n    const char *sql =\r\n            \"select DISTINCT RI.value as a, RI2.value as b\"\r\n            \" from resource_items RI\"\r\n            \" join resource_items RI2 on RI2.sub_device_id = RI.sub_device_id\"\r\n            \" WHERE RI.item = 'attr/modelid' and RI2.item = 'attr/manufacturername'\";\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, DB_LoadIdentifiersCallback, &result, &errmsg);\r\n\r\n    if (errmsg)\r\n    {\r\n        DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n        sqlite3_free(errmsg);\r\n    }\r\n\r\n    // load from legacy sensors table\r\n    sql = \"select DISTINCT modelid, manufacturername from sensors WHERE type LIKE 'ZHA%'\";\r\n    errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, DB_LoadIdentifiersLegacyCallback, &result, &errmsg);\r\n\r\n    if (errmsg)\r\n    {\r\n        DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n        sqlite3_free(errmsg);\r\n    }\r\n\r\n    // load from legacy nodes table\r\n    sql = \"select DISTINCT modelid, manufacturername from nodes WHERE modelid != '' AND manufacturername != '' AND ritems is not null;\";\r\n    errmsg = nullptr;\r\n    rc = sqlite3_exec(db, sql, DB_LoadIdentifiersLegacyCallback, &result, &errmsg);\r\n\r\n    if (errmsg)\r\n    {\r\n        DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n        sqlite3_free(errmsg);\r\n    }\r\n\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    if (DBG_IsEnabled(DBG_DDF))\r\n    {\r\n        for (size_t i = 0; i < result.size(); i++)\r\n        {\r\n            AT_Atom mfname = AT_GetAtomByIndex({result[i].mfnameAtomIndex});\r\n            AT_Atom modelid = AT_GetAtomByIndex({result[i].modelIdAtomIndex});\r\n\r\n            U_ASSERT(mfname.data && mfname.len);\r\n            U_ASSERT(modelid.data && modelid.len);\r\n\r\n            DBG_Printf(DBG_DDF, \"DDF identifier pair: %s | %s\\n\", (const char*)mfname.data, (const char*)modelid.data);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nstruct SelectDeviceItemData\r\n{\r\n    unsigned valueLength;\r\n    char value[128];\r\n    uint64_t timestamp;\r\n    bool isValid;\r\n};\r\n\r\n/*! Sqlite callback to check if an resource item entry already exists.\r\n    [0] item suffix\r\n    [1] value\r\n    [2] timestamp\r\n */\r\nstatic int sqliteSelectDeviceItemCallback(void *user, int ncols, char **colval , char **colname)\r\n{\r\n    U_ASSERT(user);\r\n    U_ASSERT(ncols == 3);\r\n\r\n    Q_UNUSED(colname)\r\n\r\n    SelectDeviceItemData *result = static_cast<SelectDeviceItemData*>(user);\r\n\r\n    result->valueLength = U_StringLength(colval[1]);\r\n    result->isValid = false;\r\n    if (result->valueLength < sizeof(result->value))\r\n    {\r\n        result->timestamp = U_ParseUint64(colval[2], -1, 10);\r\n        memcpy(&result->value[0], colval[1], result->valueLength);\r\n        result->value[result->valueLength] = '\\0';\r\n        result->isValid = true;\r\n        return 0;\r\n    }\r\n\r\n    result->valueLength = 0;\r\n    result->isValid = false;\r\n    return 1;\r\n}\r\n\r\nbool DB_StoreSubDeviceItem(const Resource *sub, ResourceItem *item)\r\n{\r\n    if (!item->needStore())\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const char *suffix = item->descriptor().suffix;\r\n\r\n    if ((suffix == RAttrMode && item->toNumber() == Sensor::ModeScenes) || suffix == RStatePresence)\r\n    {\r\n        // don't waste time on these\r\n        // TODO(mpi): this needs to be controlled via DDF\r\n        item->clearNeedStore();\r\n        return true;\r\n    }\r\n\r\n    const ResourceItem *uniqueId = sub->item(RAttrUniqueId);\r\n    if (!uniqueId)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n    if (!db)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (!item->lastChanged().isValid())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    int ret = 0;\r\n    uint64_t dt = 0; // delta in seconds from timestamp in database\r\n    SelectDeviceItemData dbResult;\r\n    dbResult.isValid = false;\r\n    const uint64_t timestamp = item->lastChanged().toMSecsSinceEpoch() / 1000;\r\n    const auto value = dbEscapeString(item->toVariant().toString()).toUtf8();\r\n\r\n    // 1) check insert or update needed\r\n\r\n    ret = snprintf(sqlBuf, sizeof(sqlBuf),\r\n                   \"SELECT item,value,timestamp FROM resource_items\"\r\n                   \" WHERE sub_device_id = (SELECT id FROM sub_devices WHERE uniqueid = '%s')\"\r\n                   \" AND item = '%s'\",\r\n                   uniqueId->toCString(),\r\n                   item->descriptor().suffix);\r\n\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, sqliteSelectDeviceItemCallback, &dbResult, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n\r\n        if (dbResult.isValid)\r\n        {\r\n            bool isEqual = false;\r\n            if (dbResult.valueLength == (unsigned)value.size())\r\n            {\r\n                if (memcmp(value.constData(), &dbResult.value[0], dbResult.valueLength) == 0)\r\n                {\r\n                    isEqual = true;\r\n                }\r\n            }\r\n\r\n            if (dbResult.timestamp < timestamp)\r\n            {\r\n                dt = timestamp - dbResult.timestamp;\r\n            }\r\n\r\n#ifdef ARCH_ARM\r\n            uint64_t storeDelay = 1800;\r\n#else\r\n            uint64_t storeDelay = 600;\r\n#endif\r\n\r\n            if (isEqual)\r\n            {\r\n                if (item->descriptor().type == DataTypeString)\r\n                {\r\n                    item->clearNeedStore();\r\n                    return true; // don't check timestamp for strings\r\n                }\r\n\r\n                if (suffix[0] == 'a' && dt < storeDelay) // attr/*  but not a string\r\n                {\r\n                    return true; // only update timestamp every 10 minutes\r\n                }\r\n                if (suffix[0] == 's' && dt < storeDelay) // state/*\r\n                {\r\n                    return true; // only update timestamp every 10 minutes\r\n                }\r\n                if (suffix[0] == 'c' && suffix[1] == 'o' && dt < storeDelay) // config/*\r\n                {\r\n                    return true; // only update timestamp every 10 minutes\r\n                }\r\n                if (suffix[0] == 'c' && suffix[1] == 'a' && suffix[2] == 'p' && dt < 84000) // cap/*\r\n                {\r\n                    return true; // hmm could be skipped all together?\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // only update 'value' and 'timestamp' every 10 minutes if changed\r\n                // TODO(mpi): extend the item descriptor to specify storage intervals\r\n                // we don't need to write the DB for rapid changing values\r\n                if (item->descriptor().suffix[0] == 's' && dt < storeDelay) // state/*\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 2) update or insert\r\n\r\n    ret = snprintf(sqlBuf, sizeof(sqlBuf),\r\n                       \"INSERT INTO resource_items (sub_device_id,item,value,source,timestamp)\"\r\n                       \" SELECT id, '%s', '%s', 'dev', %\" PRIu64\r\n                       \" FROM sub_devices WHERE uniqueid = '%s'\",\r\n                       item->descriptor().suffix,\r\n                       value.constData(),\r\n                       timestamp, uniqueId->toCString());\r\n\r\n    DBG_Assert(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n//        DBG_Printf(DBG_INFO_L2, \"%s\\n\", &sqlBuf[0]);\r\n\r\n        if (DBG_IsEnabled(DBG_MEASURE))\r\n        {\r\n            DBG_Printf(DBG_MEASURE, \"DB store %s%s/%s ## %s\\n\", uniqueId->toCString(), sub->prefix(), item->descriptor().suffix, sqlBuf);\r\n        }\r\n\r\n        char *errmsg = nullptr;\r\n\r\n        int rc = sqlite3_exec(db, sqlBuf, nullptr, nullptr, &errmsg);\r\n\r\n        if (rc != SQLITE_OK)\r\n        {\r\n            if (errmsg)\r\n            {\r\n                DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n                sqlite3_free(errmsg);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            item->clearNeedStore();\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n    return true;\r\n}\r\n\r\nstatic int DB_LoadSubDeviceItemsCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<DB_ResourceItem>*>(user);\r\n    Q_ASSERT(result);\r\n    Q_ASSERT(ncols == 3);\r\n\r\n    DB_ResourceItem ritem;\r\n\r\n    ritem.name = colval[0];\r\n    ritem.value = QString(colval[1]);\r\n    ritem.timestampMs = QString(colval[2]).toLongLong() * 1000;\r\n\r\n    if (!ritem.name.empty() && !ritem.value.isNull())\r\n    {\r\n        result->push_back(std::move(ritem));\r\n    }\r\n    return 0;\r\n};\r\n\r\nstd::vector<DB_ResourceItem> DB_LoadSubDeviceItemsOfDevice(QLatin1String deviceUniqueId)\r\n{\r\n    DBG_Assert(deviceUniqueId.size() == 23); // 64 bit uniqueId with : after each byte\r\n\r\n    std::vector<DB_ResourceItem> result;\r\n\r\n    if (deviceUniqueId.size() != 23)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    int ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT item,value,timestamp FROM resource_items\"\r\n                                 \" WHERE sub_device_id = (SELECT id FROM sub_devices WHERE uniqueid LIKE '%%%s%%')\",\r\n                                 deviceUniqueId.data());\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadSubDeviceItemsCallback, &result, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return result;\r\n}\r\n\r\nint DB_GetSubDeviceItemCount(QLatin1String uniqueId)\r\n{\r\n    int result = 0;\r\n\r\n    U_ASSERT(db); // should be called while db is open\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    int rc = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT COUNT(item) FROM resource_items\"\r\n                                         \" WHERE sub_device_id = (SELECT id FROM sub_devices WHERE uniqueid = '%s')\",\r\n                                         uniqueId.data());\r\n\r\n    U_ASSERT(size_t(rc) < sizeof(sqlBuf));\r\n    if (size_t(rc) < sizeof(sqlBuf))\r\n    {\r\n        sqlite3_stmt *res = nullptr;\r\n\r\n        int rc = sqlite3_prepare_v2(db, sqlBuf, -1, &res, nullptr);\r\n        DBG_Assert(res);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n\r\n        if (rc == SQLITE_OK)\r\n        {\r\n            rc = sqlite3_step(res);\r\n            DBG_Assert(rc == SQLITE_ROW);\r\n            if (rc == SQLITE_ROW)\r\n            {\r\n                result = sqlite3_column_int(res, 0);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"error preparing sql (err: %d): %s\\n\", rc, sqlBuf);\r\n        }\r\n\r\n        rc = sqlite3_finalize(res);\r\n        DBG_Assert(rc == SQLITE_OK);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nstd::vector<DB_ResourceItem> DB_LoadSubDeviceItems(QLatin1String uniqueId)\r\n{\r\n    std::vector<DB_ResourceItem> result;\r\n\r\n    U_ASSERT(uniqueId.size() <= 64);\r\n    if (uniqueId.size() > 64)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    int ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT item,value,timestamp FROM resource_items\"\r\n                                         \" WHERE sub_device_id = (SELECT id FROM sub_devices WHERE uniqueid = '%s')\",\r\n                                         uniqueId.data());\r\n\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadSubDeviceItemsCallback, &result, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return result;\r\n}\r\n\r\nbool DB_StoreSubDeviceItems(Resource *sub)\r\n{\r\n    for (int i = 0; i < sub->itemCount(); i++)\r\n    {\r\n        auto *item = sub->itemForIndex(size_t(i));\r\n        if (item && item->needStore())\r\n        {\r\n            DB_StoreSubDeviceItem(sub, item);\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nstatic int DB_LoadLegacyValueCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<DB_LegacyItem*>(user);\r\n    Q_ASSERT(result);\r\n    Q_ASSERT(ncols == 1);\r\n\r\n    if (colval[0][0] == '{') // state and config json objects\r\n    {\r\n        BufString<64> key; // config/offset -> offset\r\n        for (size_t i = 0; i < result->column.size(); i++)\r\n        {\r\n            if (result->column.c_str()[i] == '/')\r\n            {\r\n                key.setString(&result->column.c_str()[i + 1]);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!key.empty() && DeserializationError::Ok == deserializeJson(dbJson, static_cast<const char*>(colval[0])))\r\n        {\r\n            if (dbJson.containsKey(key.c_str()))\r\n            {\r\n                auto var = dbJson[key.c_str()];\r\n                if (var.is<int>())\r\n                {\r\n                    result->value.setString(std::to_string(var.as<int>()).c_str());\r\n                    return 0;\r\n                }\r\n                else if (var.is<double>())\r\n                {\r\n                    result->value.setString(std::to_string(var.as<double>()).c_str());\r\n                    return 0;\r\n                }\r\n                else if (var.is<const char*>())\r\n                {\r\n                    result->value.setString(var.as<const char*>());\r\n                    return 0;\r\n                }\r\n                else if (var.is<bool>())\r\n                {\r\n                    result->value.setString((var.as<bool>() ? \"true\" : \"false\"));\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (colval[0][0])\r\n    {\r\n        result->value.setString(colval[0]);\r\n        return 0;\r\n    }\r\n\r\n    return 1;\r\n};\r\n\r\nbool DB_LoadLegacySensorValue(DB_LegacyItem *litem)\r\n{\r\n    bool result = false;\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    litem->value.clear();\r\n\r\n    BufString<64> column; // config/* -> config, state/* -> state\r\n    for (size_t i = 0; i < litem->column.size(); i++)\r\n    {\r\n        if (litem->column.c_str()[i] == '/')\r\n        {\r\n            column.setString(litem->column.c_str(), i);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (column.empty())\r\n    {\r\n        column = litem->column;\r\n    }\r\n\r\n    int ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT %s FROM sensors WHERE uniqueid = '%s' AND deletedState = 'normal'\",\r\n                       column.c_str(), litem->uniqueId.c_str());\r\n\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadLegacyValueCallback, litem, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        else\r\n        {\r\n            result = !litem->value.empty();\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return result;\r\n}\r\n\r\nstatic int DB_LoadLegacySensorUniqueIdsCallback(void *user, int ncols, char **colval , char **)\r\n{\r\n    auto *result = static_cast<std::vector<std::string>*>(user);\r\n    Q_ASSERT(result);\r\n    Q_ASSERT(ncols == 1);\r\n    if (colval[0][0])\r\n    {\r\n        result->push_back(colval[0]);\r\n    }\r\n\r\n    return 0;\r\n};\r\n\r\nstd::vector<std::string> DB_LoadLegacySensorUniqueIds(QLatin1String deviceUniqueId, const char *type)\r\n{\r\n    std::vector<std::string> result;\r\n\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    int ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT uniqueid FROM sensors WHERE uniqueid LIKE '%%%s%%' AND type = '%s' AND deletedState = 'normal'\",\r\n                       deviceUniqueId.data(), type);\r\n\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadLegacySensorUniqueIdsCallback, &result, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return result;\r\n}\r\n\r\nbool DB_LoadLegacyLightValue(DB_LegacyItem *litem)\r\n{\r\n    bool result = false;\r\n    DeRestPluginPrivate::instance()->openDb();\r\n\r\n    if (!db)\r\n    {\r\n        return result;\r\n    }\r\n\r\n    litem->value.clear();\r\n\r\n    int ret = snprintf(sqlBuf, sizeof(sqlBuf), \"SELECT %s FROM nodes WHERE mac = '%s'\", litem->column .c_str(), litem->uniqueId.c_str());\r\n    U_ASSERT(size_t(ret) < sizeof(sqlBuf));\r\n    if (size_t(ret) < sizeof(sqlBuf))\r\n    {\r\n        char *errmsg = nullptr;\r\n        int rc = sqlite3_exec(db, sqlBuf, DB_LoadLegacyValueCallback, litem, &errmsg);\r\n\r\n        if (errmsg)\r\n        {\r\n            DBG_Printf(DBG_ERROR_L2, \"SQL exec failed: %s, error: %s (%d)\\n\", sqlBuf, errmsg, rc);\r\n            sqlite3_free(errmsg);\r\n        }\r\n        else\r\n        {\r\n            result = !litem->value.empty();\r\n        }\r\n    }\r\n\r\n    DeRestPluginPrivate::instance()->closeDb();\r\n\r\n    return result;\r\n}\r\n"
        },
        {
          "name": "database.h",
          "type": "blob",
          "size": 3.1875,
          "content": "/*\n * Copyright (c) 2016-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DATABASE_H\n#define DATABASE_H\n\n#include <string>\n#include <cinttypes>\n#include <vector>\n#include <cstddef>\n#include <QString>\n#include <QVariant>\n#include <utils/bufstring.h>\n\n#define DB_MAX_UNIQUEID_SIZE 31\n\nnamespace deCONZ {\n    class Address;\n}\n\nstruct DB_Secret\n{\n    std::string uniqueId;\n    std::string secret;\n    int state = 0;\n};\n\nstruct DB_AlarmSystem\n{\n    int id;\n    uint64_t timestamp;\n};\n\nstruct DB_AlarmSystemResourceItem\n{\n    int alarmSystemId;\n    const char *suffix;\n    std::string value;\n    uint64_t timestamp;\n};\n\nstruct DB_AlarmSystemDevice\n{\n    char uniqueid[DB_MAX_UNIQUEID_SIZE + 1];\n    uint64_t timestamp;\n    uint32_t flags;\n    int alarmSystemId;\n};\n\nbool DB_StoreSecret(const DB_Secret &secret);\nbool DB_LoadSecret(DB_Secret &secret);\n\nbool DB_StoreAlarmSystem(const DB_AlarmSystem &alarmSys);\nbool DB_StoreAlarmSystemResourceItem(const DB_AlarmSystemResourceItem &item);\nstd::vector<DB_AlarmSystemResourceItem> DB_LoadAlarmSystemResourceItems(int alarmSystemId);\n\nbool DB_StoreAlarmSystemDevice(const DB_AlarmSystemDevice &dev);\nstd::vector<DB_AlarmSystemDevice> DB_LoadAlarmSystemDevices();\nbool DB_DeleteAlarmSystemDevice(const std::string &uniqueId);\n\n\n// DDF specific \nclass Resource;\nclass ResourceItem;\n\n\n // TODO(mpi) deprecated for DB_ResourceItem2\nstruct DB_ResourceItem\n{\n    BufString<64> name;\n    QVariant value;\n    qint64 timestampMs = 0; // milliseconds since Epoch\n};\n\nstruct DB_ResourceItem2\n{\n    BufString<64> name;\n    unsigned valueSize;\n    char value[160];\n    qint64 timestampMs = 0; // milliseconds since Epoch\n};\n\nstruct DB_LegacyItem\n{\n    BufString<64> column;\n    BufString<64> uniqueId;\n\n    BufString<128> value;\n};\n\nstruct DB_ZclValue\n{\n    int64_t data;\n    int deviceId;\n    uint16_t clusterId;\n    uint16_t attrId;\n    uint8_t endpoint;\n\n    // internal\n    uint8_t loaded;\n};\n\nstruct DB_IdentifierPair\n{\n    unsigned modelIdAtomIndex;\n    unsigned mfnameAtomIndex;\n};\n\nint DB_StoreDevice(const deCONZ::Address &addr);\n\nint DB_GetSubDeviceItemCount(QLatin1String uniqueId);\nbool DB_LoadZclValue(DB_ZclValue *val);\nbool DB_StoreZclValue(const DB_ZclValue *val);\nbool DB_StoreSubDevice(const char *uniqueId);\nbool DB_StoreDeviceItem(int deviceId, const DB_ResourceItem2 &item);\nbool DB_LoadDeviceItems(int deviceId, std::vector<DB_ResourceItem2> &items);\nbool DB_ResourceItem2DbItem(const ResourceItem *rItem, DB_ResourceItem2 *dbItem);\nstd::vector<DB_IdentifierPair> DB_LoadIdentifierPairs();\nbool DB_StoreSubDeviceItem(const Resource *sub, ResourceItem *item);\nbool DB_StoreSubDeviceItems(Resource *sub);\nstd::vector<DB_ResourceItem> DB_LoadSubDeviceItemsOfDevice(QLatin1String deviceUniqueId);\nstd::vector<DB_ResourceItem> DB_LoadSubDeviceItems(QLatin1String uniqueId);\nbool DB_LoadLegacySensorValue(DB_LegacyItem *litem);\nstd::vector<std::string> DB_LoadLegacySensorUniqueIds(QLatin1String deviceUniqueId, const char *type);\nbool DB_LoadLegacyLightValue(DB_LegacyItem *litem);\n\n\n#endif // DATABASE_H\n"
        },
        {
          "name": "daylight.cpp",
          "type": "blob",
          "size": 4.013671875,
          "content": "/*\n * Copyright (c)2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QtMath>\n#include <QVariantMap>\n#include \"daylight.h\"\n\n// Qt/C++ port of:\n// https://github.com/mourner/suncalc/blob/master/suncalc.js\n\nstatic const qreal dayMs = 1000 * 60 * 60 * 24;\nstatic const qreal J1970 = 2440588;\nstatic const qreal J2000 = 2451545;\nstatic const double rad = M_PI / 180;\nstatic const double e = rad * 23.4397; // obliquity of the Earth\n\nstatic double toJulian(double msecSinceEpoch) { return msecSinceEpoch / dayMs - 0.5 + J1970; }\nstatic double fromJulian(double j) { return (j + 0.5 - J1970) * dayMs; }\nstatic double toDays(double msecSinceEpoch) { return toJulian(msecSinceEpoch) - J2000; }\nstatic double declination(double l, double b)    { return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l)); }\n\n// general sun calculations\n\nstatic double solarMeanAnomaly(double d) { return rad * (357.5291 + 0.98560028 * d); }\n\nstatic double eclipticLongitude(double M) {\n\n    double C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M)); // equation of center\n    double P = rad * 102.9372; // perihelion of the Earth\n\n    return M + C + P + M_PI;\n}\n\n// calculations for sun times\n\nstatic const double J0 = 0.0009;\n\nstatic double julianCycle(double d, double lw) { return round(d - J0 - lw / (2 * M_PI)); }\n\nstatic double approxTransit(double Ht, double lw, double n) { return J0 + (Ht + lw) / (2 * M_PI) + n; }\nstatic double solarTransitJ(double ds, double M, double L)  { return J2000 + ds + 0.0053 * sin(M) - 0.0069 * sin(2 * L); }\n\nstatic double hourAngle(double h, double phi, double d) { return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d))); }\n\n// returns set time for the given sun altitude\nstatic double getSetJ(double h, double lw, double phi, double dec, double n, double M, double L) {\n\n    double w = hourAngle(h, phi, dec);\n    double a = approxTransit(w, lw, n);\n    return solarTransitJ(a, M, L);\n}\n\nstruct TimePin {\n    double offset;\n    const char *first;\n    int firstWeight;\n    const char *second;\n    int secondWeight;\n};\n\n// calculates sun times for a given date and latitude/longitude\n\nvoid getDaylightTimes(qint64 msecSinceEpoch, double lat, double lng,  std::vector<DL_Result> &result)\n{\n    std::vector<TimePin> times;\n    // sun times configuration (angle, morning name, evening name)\n    times.push_back({-0.833, \"sunriseStart\",  DL_SUNRISE_START, \"sunsetEnd\",    DL_SUNSET_END});\n    times.push_back({-0.3,   \"sunriseEnd\",    DL_SUNRISE_END,   \"sunsetStart\",  DL_SUNSET_START});\n    times.push_back({-6,     \"dawn\",          DL_DAWN,          \"dusk\",         DL_DUSK});\n    times.push_back({-12,    \"nauticalDawn\",  DL_NAUTICAL_DAWN, \"nauticalDusk\", DL_NAUTICAL_DUSK});\n    times.push_back({-18,    \"nightEnd\",      DL_NIGHT_END,     \"nightStart\",   DL_NIGHT_START});\n    times.push_back({6,      \"goldenHour1\",   DL_GOLDENHOUR1,   \"goldenHour2\",  DL_GOLDENHOUR2});\n\n    double lw = rad * -lng,\n        phi = rad * lat,\n\n        d = toDays(msecSinceEpoch),\n        n = julianCycle(d, lw),\n        ds = approxTransit(0, lw, n),\n\n        M = solarMeanAnomaly(ds),\n        L = eclipticLongitude(M),\n        dec = declination(L, 0),\n\n        Jnoon = solarTransitJ(ds, M, L),\n\n        Jset, Jrise;\n\n\n    result.push_back({\"solarNoon\", DL_SOLAR_NOON, (qint64)fromJulian(Jnoon)});\n    result.push_back({\"nadir\", DL_NADIR, (qint64)fromJulian(Jnoon - 0.5)});\n\n    for (const TimePin &time : times)\n    {\n\n        Jset = getSetJ(time.offset * rad, lw, phi, dec, n, M, L);\n        Jrise = Jnoon - (Jset - Jnoon);\n\n        result.push_back({time.first, time.firstWeight, (qint64)fromJulian(Jrise)});\n        result.push_back({time.second, time.secondWeight, (qint64)fromJulian(Jset)});\n    }\n\n    std::sort(result.begin(), result.end(),\n              [](const DL_Result &a, const DL_Result &b)\n              { return a.msecsSinceEpoch < b.msecsSinceEpoch; });\n}\n\n"
        },
        {
          "name": "daylight.h",
          "type": "blob",
          "size": 0.92578125,
          "content": "/*\n * Copyright (c)2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DAYLIGHT_H\n#define DAYLIGHT_H\n\n#define DL_NADIR          100\n#define DL_NIGHT_END      110\n#define DL_NAUTICAL_DAWN  120\n#define DL_DAWN           130\n#define DL_SUNRISE_START  140\n#define DL_SUNRISE_END    150\n#define DL_GOLDENHOUR1    160\n#define DL_SOLAR_NOON     170\n#define DL_GOLDENHOUR2    180\n#define DL_SUNSET_START   190\n#define DL_SUNSET_END     200\n#define DL_DUSK           210\n#define DL_NAUTICAL_DUSK  220\n#define DL_NIGHT_START    230\n\nstruct DL_Result {\n    const char *name;\n    int weight;\n    qint64 msecsSinceEpoch;\n};\n\nvoid getDaylightTimes(qint64 msecSinceEpoch, double lat, double lng, std::vector<DL_Result> &result);\n\n#endif // DAYLIGHT_H\n"
        },
        {
          "name": "de_otau.cpp",
          "type": "blob",
          "size": 8.6298828125,
          "content": "/*\n * Copyright (c) 2016-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"device_descriptions.h\"\n#include \"database.h\"\n\n\n// de otau specific\n#define OTAU_IMAGE_NOTIFY_CLID                 0x0201\n#define OTAU_QUERY_NEXT_IMAGE_REQUEST_CLID     0x0202\n#define OTAU_QUERY_NEXT_IMAGE_RESPONSE_CLID    0x8202\n#define OTAU_IMAGE_BLOCK_REQUEST_CLID          0x0203\n#define OTAU_IMAGE_BLOCK_RESPONSE_CLID         0x8203\n#define OTAU_REPORT_STATUS_CLID                0x0205\n\n// std otau specific\n#define OTAU_IMAGE_NOTIFY_CMD_ID             0x00\n#define OTAU_QUERY_NEXT_IMAGE_REQUEST_CMD_ID 0x01\n#define OTAU_IMAGE_BLOCK_REQUEST_CMD_ID      0x03\n#define OTAU_IMAGE_PAGE_REQUEST_CMD_ID       0x04\n#define OTAU_UPGRADE_END_REQUEST_CMD_ID      0x06\n\n// artifical attribute ids for some OTAU related parameters\n#define OTAU_SWVERSION_ID     0x1000\n\n#define DONT_CARE_FILE_VERSION                 0xFFFFFFFFUL\n\n#define OTAU_IMAGE_TYPE_QJ             0x00 // Query jitter\n#define OTAU_IMAGE_TYPE_QJ_MFC         0x01 // Query jitter, manufacturer code\n#define OTAU_IMAGE_TYPE_QJ_MFC_IT      0x02 // Query jitter, manufacturer code, image type\n#define OTAU_IMAGE_TYPE_QJ_MFC_IT_FV   0x03 // Query jitter, manufacturer code, image type, file version\n\n#define OTAU_NOTIFY_INTERVAL      (1000 * 60 * 30)\n#define OTAU_IDLE_TICKS_NOTIFY    60  // seconds\n#define OTAU_BUSY_TICKS           60  // seconds\n\n/*! Inits the otau manager.\n */\nvoid DeRestPluginPrivate::initOtau()\n{\n    otauIdleTicks = 0;\n    otauBusyTicks = 0;\n    otauIdleTotalCounter = 0;\n\n    otauTimer = new QTimer(this);\n    otauTimer->setSingleShot(false);\n    connect(otauTimer, SIGNAL(timeout()),\n            this, SLOT(otauTimerFired()));\n\n    otauTimer->start(1000);\n}\n\n/*! Handler for incoming otau packets.\n */\nvoid DeRestPluginPrivate::otauDataIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, Device *device)\n{\n    if (!device || ind.clusterId() != OTAU_CLUSTER_ID)\n    {\n        return;\n    }\n\n    quint8 fieldControl;\n    quint16 manufacturerId;\n    quint16 imageType;\n    quint32 swVersion = 0;\n    quint16 hwVersion;\n    bool updateOtaTicks = false;\n\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        // TODO(mpi): parsing the attribute response can likely be removed here\n        // since this is already done by the read function.\n        // Below the item->needPushChange() check is used to capture the change in any case.\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint16 attrId;\n        quint8 status;\n        quint8 dataType;\n\n        stream >> attrId;\n        stream >> status;\n        stream >> dataType;\n\n        if (status == deCONZ::ZclSuccessStatus && attrId == 0x0002 && dataType == deCONZ::Zcl32BitUint && stream.status() == QDataStream::Ok)\n        {\n            deCONZ::ZclAttribute attr(attrId, dataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n            if (attr.readFromStream(stream))\n            {\n                swVersion = attr.numericValue().u32;\n            }\n        }\n    }\n    else if (zclFrame.isClusterCommand() && zclFrame.commandId() == OTAU_QUERY_NEXT_IMAGE_REQUEST_CMD_ID)\n    {\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream >> fieldControl;\n        stream >> manufacturerId;\n        stream >> imageType;\n        stream >> swVersion;\n\n        if (fieldControl & 0x01)\n        {\n            stream >> hwVersion;\n        }\n\n        if (swVersion == 0 || stream.status() != QDataStream::Ok)\n        {\n            return;\n        }\n    }\n\n    if (swVersion != 0)\n    {\n        // the OTA cluster 0x0002 attribute isn't always present, but it can be extracted from the Query Next Image Request\n        // store the OTA versions for DDF and non DDF devices, so it can be used in DDF matchexpr\n\n        DB_ZclValue zclVal;\n        zclVal.deviceId = device->deviceId();\n        zclVal.endpoint = ind.srcEndpoint();\n        zclVal.clusterId = ind.clusterId();\n        zclVal.attrId = 0x0002; // OTA current file version\n        zclVal.data = swVersion;\n\n        DB_StoreZclValue(&zclVal); // does only write if the value is already there\n\n        ResourceItem *item = device->item(RAttrOtaVersion);\n\n        if (item)\n        {\n            if (item->toNumber() != swVersion)\n            {\n                item->setValue(swVersion, ResourceItem::SourceDevice);\n            }\n\n            if (device->managed() && item->needPushChange())\n            {\n                // the known OTA version has changed (or initially set)\n                // there might be a different DDF to match, trigger reload\n                const auto &ddf = DeviceDescriptions::instance()->get(device, DDF_EvalMatchExpr);\n                if (ddf.isValid() && !ddf.matchExpr.isEmpty())\n                {\n                    Event e(device->prefix(), REventDDFReload, 1, device->key());\n                    enqueueEvent(e);\n                }\n            }\n        }\n\n        if (device->managed())\n        {\n            return;\n        }\n\n        LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n        // extract software version from request\n        if (lightNode)\n        {\n            deCONZ::NumericUnion val = {0};\n            val.u32 = swVersion;\n\n            lightNode->setZclValue(NodeValue::UpdateByZclRead, ind.srcEndpoint(), OTAU_CLUSTER_ID, OTAU_SWVERSION_ID, val);\n\n            if (lightNode->swBuildId().isEmpty())\n            {\n                QString version = \"0x\" + QString(\"%1\").arg(swVersion, 8, 16, QLatin1Char('0')).toUpper();\n\n                lightNode->setSwBuildId(version);\n                lightNode->setNeedSaveDatabase(true);\n                updateEtag(lightNode->etag);\n\n                // read real sw build id\n                lightNode->setLastRead(READ_SWBUILD_ID, idleTotalCounter);\n                lightNode->enableRead(READ_SWBUILD_ID);\n                lightNode->setNextReadTime(READ_SWBUILD_ID, queryTime);\n                queryTime = queryTime.addSecs(5);\n            }\n        }\n    }\n    else if (zclFrame.isProfileWideCommand())\n    {\n        return; // all done here\n    }\n    else if (zclFrame.commandId() == OTAU_UPGRADE_END_REQUEST_CMD_ID)\n    {\n        LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n\n        if (lightNode)\n        {\n            lightNode->setLastRead(READ_SWBUILD_ID, idleTotalCounter);\n            lightNode->enableRead(READ_SWBUILD_ID);\n            lightNode->setNextReadTime(READ_SWBUILD_ID, queryTime.addSecs(160));\n            storeRecoverOnOffBri(lightNode);\n        }\n    }\n    else if (zclFrame.commandId() == OTAU_IMAGE_BLOCK_REQUEST_CMD_ID)\n    {\n        // remember last activity time\n        otauIdleTotalCounter = idleTotalCounter;\n        updateOtaTicks = true;\n    }\n    else if (zclFrame.commandId() == OTAU_IMAGE_PAGE_REQUEST_CMD_ID)\n    {\n        updateOtaTicks = true;\n    }\n    else\n    {\n        return;\n    }\n\n    if (!isOtauActive())\n    {\n        return;\n    }\n\n    if (updateOtaTicks)\n    {\n        if (otauIdleTicks > 0)\n        {\n            otauIdleTicks = 0;\n        }\n\n        if (otauBusyTicks <= 0)\n        {\n            updateEtag(gwConfigEtag);\n        }\n\n        otauBusyTicks = OTAU_BUSY_TICKS;\n    }\n}\n\n/*! Returns true if otau is busy with uploading data.\n */\nbool DeRestPluginPrivate::isOtauBusy()\n{\n    if (isInNetwork() && isOtauActive() && (otauBusyTicks > 0))\n    {\n        return true;\n    }\n\n    return false;\n}\n\nbool DEV_OtauBusy()\n{\n    return plugin->isOtauBusy();\n}\n\n/*! Returns true if otau is activated.\n */\nbool DeRestPluginPrivate::isOtauActive()\n{\n    if (apsCtrl)\n    {\n        return apsCtrl->getParameter(deCONZ::ParamOtauActive) == 1;\n    }\n\n    return false;\n}\n\nint DeRestPluginPrivate::otauLastBusyTimeDelta() const\n{\n    if (otauIdleTotalCounter == 0)\n    {\n        return INT_MAX; // not valid\n    }\n\n    if (idleTotalCounter >= otauIdleTotalCounter)\n    {\n        return idleTotalCounter - otauIdleTotalCounter;\n    }\n\n    return INT_MAX;\n}\n\n/*! Unicasts otau notify packets to the nodes.\n */\nvoid DeRestPluginPrivate::otauTimerFired()\n{\n    if (!isOtauActive())\n    {\n        return;\n    }\n\n    if (!isInNetwork())\n    {\n        return;\n    }\n\n    if (otauIdleTicks < INT_MAX)\n    {\n        otauIdleTicks++;\n    }\n\n    if (otauBusyTicks > 0)\n    {\n        otauBusyTicks--;\n\n        if (otauBusyTicks == 0)\n        {\n            updateEtag(gwConfigEtag);\n        }\n    }\n}\n"
        },
        {
          "name": "de_web_plugin.cpp",
          "type": "blob",
          "size": 662.375,
          "content": " /*\n * Copyright (c) 2017-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QCoreApplication>\n#include <QDebug>\n#include <QDesktopServices>\n#include <QtPlugin>\n#include <QtCore/qmath.h>\n#include <QNetworkAccessManager>\n#include <QPushButton>\n#include <QTextCodec>\n#include <QTime>\n#include <QTimer>\n#include <QTcpSocket>\n#include <QHostAddress>\n#include <QUrl>\n#include <QCryptographicHash>\n#include <QFile>\n#include <QDir>\n#include <QProcess>\n#include <QSettings>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QJsonValue>\n#include <QJsonParseError>\n#include <cmath>\n#include \"alarm_system_device_table.h\"\n#include \"database.h\"\n#include \"deconz/u_assert.h\"\n#include \"device_ddf_init.h\"\n#include \"device_descriptions.h\"\n#include \"device_tick.h\"\n#include \"device_js/device_js.h\"\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"de_web_widget.h\"\n#include \"ui/device_widget.h\"\n#include \"gateway_scanner.h\"\n#include \"ias_ace.h\"\n#include \"json.h\"\n#include \"poll_control.h\"\n#include \"poll_manager.h\"\n#include \"product_match.h\"\n#include \"rest_ddf.h\"\n#include \"rest_devices.h\"\n#include \"rest_alarmsystems.h\"\n#include \"read_files.h\"\n#include \"tuya.h\"\n#include \"utils/utils.h\"\n#include \"utils/scratchmem.h\"\n#include \"xiaomi.h\"\n#include \"zcl/zcl.h\"\n#include \"zdp/zdp.h\"\n#include \"zdp/zdp_handlers.h\"\n\n#ifdef ARCH_ARM\n  #include <unistd.h>\n  #include <sys/reboot.h>\n  #include <errno.h>\n#endif\n\nDeRestPluginPrivate *plugin = nullptr;\n\nstatic int checkZclAttributesDelay = 750;\nstatic uint MaxGroupTasks = 4;\n\nconst quint64 macPrefixMask       = 0xffffff0000000000ULL;\n\n// New mac prefixes can be checked here: https://wintelguy.com/index.pl\nconst quint64 legrandMacPrefix    = 0x0004740000000000ULL;\nconst quint64 dishMacPrefix       = 0x0008890000000000ULL;\nconst quint64 silabs1MacPrefix    = 0x000b570000000000ULL;\nconst quint64 emberMacPrefix      = 0x000d6f0000000000ULL;\nconst quint64 instaMacPrefix      = 0x000f170000000000ULL;\nconst quint64 tiMacPrefix         = 0x00124b0000000000ULL;\nconst quint64 netvoxMacPrefix     = 0x00137a0000000000ULL;\nconst quint64 boschMacPrefix      = 0x00155f0000000000ULL;\nconst quint64 jennicMacPrefix     = 0x00158d0000000000ULL;\nconst quint64 develcoMacPrefix    = 0x0015bc0000000000ULL;\nconst quint64 philipsMacPrefix    = 0x0017880000000000ULL;\nconst quint64 ubisysMacPrefix     = 0x001fee0000000000ULL;\nconst quint64 computimeMacPrefix  = 0x001e5e0000000000ULL;\nconst quint64 deMacPrefix         = 0x00212e0000000000ULL;\nconst quint64 celMacPrefix        = 0x0022a30000000000ULL; // California Eastern Laboratories\nconst quint64 zenMacPrefix        = 0x0024460000000000ULL;\nconst quint64 heimanMacPrefix     = 0x0050430000000000ULL;\nconst quint64 davicomMacPrefix    = 0x00606e0000000000ULL;\nconst quint64 xiaomiMacPrefix     = 0x04cf8c0000000000ULL;\nconst quint64 konkeMacPrefix      = 0x086bd70000000000ULL;\nconst quint64 ikea2MacPrefix      = 0x14b4570000000000ULL;\nconst quint64 profaluxMacPrefix   = 0x20918a0000000000ULL;\nconst quint64 stMacPrefix         = 0x24fd5b0000000000ULL;\nconst quint64 samjinMacPrefix     = 0x286d970000000000ULL;\nconst quint64 casaiaPrefix        = 0x3c6a2c0000000000ULL;\nconst quint64 sinopeMacPrefix     = 0x500b910000000000ULL;\nconst quint64 lumiMacPrefix       = 0x54ef440000000000ULL;\nconst quint64 silabs6MacPrefix    = 0x588e810000000000ULL;\nconst quint64 silabs9MacPrefix    = 0x5c02720000000000ULL;\nconst quint64 silabs8MacPrefix    = 0x60a4230000000000ULL;\nconst quint64 silabs4MacPrefix    = 0x680ae20000000000ULL;\nconst quint64 ecozyMacPrefix      = 0x70b3d50000000000ULL;\nconst quint64 silabs11MacPrefix   = 0x804b500000000000ULL;\nconst quint64 osramMacPrefix      = 0x8418260000000000ULL;\nconst quint64 silabs5MacPrefix    = 0x842e140000000000ULL;\nconst quint64 silabs10MacPrefix   = 0x8471270000000000ULL;\nconst quint64 embertecMacPrefix   = 0x848e960000000000ULL;\nconst quint64 YooksmartMacPrefix  = 0x84fd270000000000ULL;\nconst quint64 silabs13MacPrefix   = 0x8cf6810000000000ULL;\nconst quint64 silabsMacPrefix     = 0x90fd9f0000000000ULL;\nconst quint64 zhejiangMacPrefix   = 0xb0ce180000000000ULL;\nconst quint64 silabs12MacPrefix   = 0xb4e3f90000000000ULL;\nconst quint64 silabs7MacPrefix    = 0xbc33ac0000000000ULL;\nconst quint64 dlinkMacPrefix      = 0xc4e90a0000000000ULL;\nconst quint64 silabs2MacPrefix    = 0xcccccc0000000000ULL;\nconst quint64 energyMiMacPrefix   = 0xd0cf5e0000000000ULL;\nconst quint64 schlageMacPrefix    = 0xd0cf5e0000000000ULL;\nconst quint64 bjeMacPrefix        = 0xd85def0000000000ULL;\nconst quint64 silabs3MacPrefix    = 0xec1bbd0000000000ULL;\nconst quint64 onestiPrefix        = 0xf4ce360000000000ULL;\nconst quint64 xalMacPrefix        = 0xf8f0050000000000ULL;\nconst quint64 lutronMacPrefix     = 0xffff000000000000ULL;\n\nstruct SupportedDevice {\n    quint16 vendorId;\n    const char *modelId;\n    quint64 mac;\n};\n\nstatic const SupportedDevice supportedDevices[] = {\n    { VENDOR_3A_SMART_HOME, \"FNB56-GAS\", jennicMacPrefix }, // Feibit FNB56-GAS05FB1.4 gas leak detector\n    { VENDOR_3A_SMART_HOME, \"FNB56-COS\", jennicMacPrefix }, // Feibit FNB56-COS06FB1.7 Carb. Mon. detector\n    { VENDOR_3A_SMART_HOME, \"FNB56-SMF\", jennicMacPrefix }, // Feibit FNB56-SMF06FB1.6 smoke detector\n    { VENDOR_3A_SMART_HOME, \"c3442b4ac59b4ba1a83119d938f283ab\", jennicMacPrefix }, // ORVIBO SF30 smoke sensor\n    { VENDOR_ADEO, \"LDSENK10\", silabs9MacPrefix }, // ADEO Animal compatible motion sensor (Leroy Merlin)\n    { VENDOR_BUSCH_JAEGER, \"RB01\", bjeMacPrefix },\n    { VENDOR_BUSCH_JAEGER, \"RM01\", bjeMacPrefix },\n    { VENDOR_BOSCH, \"ISW-ZDL1-WP11G\", boschMacPrefix },\n    { VENDOR_BOSCH, \"ISW-ZPR1-WP13\", boschMacPrefix },\n    { VENDOR_BOSCH, \"RFDL-ZB-MS\", emberMacPrefix }, // Bosch motion sensor\n    { VENDOR_BOSCH2, \"AIR\", tiMacPrefix }, // Bosch Air quality sensor\n    { VENDOR_CENTRALITE, \"3321-S\", emberMacPrefix }, // Centralite multipurpose sensor\n    { VENDOR_CENTRALITE, \"3325-S\", emberMacPrefix }, // Centralite motion sensor\n    { VENDOR_CENTRALITE, \"3305-S\", emberMacPrefix }, // Centralite motion sensor\n    { VENDOR_CLS, \"3200-Sgb\", emberMacPrefix }, // Centralite smart plug / Samsung smart outlet\n    { VENDOR_CLS, \"3200-de\", emberMacPrefix }, // Centralite smart plug / Samsung smart outlet\n    { VENDOR_C2DF, \"3300\", emberMacPrefix }, // Centralite contact sensor\n    { VENDOR_C2DF, \"3320-L\", emberMacPrefix }, // Centralite contact sensor\n    { VENDOR_C2DF, \"3315\", emberMacPrefix }, // Centralite water sensor\n    { VENDOR_D_LINK, \"DCH-B112\", dlinkMacPrefix }, // D-Link DCH-B112 door/window sensor\n    { VENDOR_D_LINK, \"DCH-B122\", dlinkMacPrefix }, // D-Link DCH-B122 motion sensor\n    { VENDOR_NONE, \"SD8SC_00.00.03.09TC\", tiMacPrefix }, // Centralite smoke sensor\n    { VENDOR_CENTRALITE, \"3326-L\", emberMacPrefix }, // Iris motion sensor v2\n    { VENDOR_C2DF, \"3326-L\", emberMacPrefix }, // Iris motion sensor v2\n    { VENDOR_CENTRALITE, \"3328-G\", emberMacPrefix }, // Centralite micro motion sensor\n    { VENDOR_CENTRALITE, \"3323\", emberMacPrefix }, // Centralite contact sensor\n    { VENDOR_DATEK, \"ID Lock 150\", silabs4MacPrefix }, // ID-Lock\n    { VENDOR_JASCO, \"45856\", celMacPrefix },\n    { VENDOR_NONE, \"FB56-DOS06HM1.3\", tiMacPrefix }, // Feibit FB56-DOS06HM1.3 door/window sensor\n    { VENDOR_NONE, \"LM_\",  tiMacPrefix },\n    { VENDOR_NONE, \"LMHT_\", tiMacPrefix },\n    { VENDOR_NONE, \"IR_\", tiMacPrefix },\n    { VENDOR_NONE, \"DC_\", tiMacPrefix },\n    { VENDOR_NONE, \"BX_\", tiMacPrefix }, // Climax siren\n    { VENDOR_NONE, \"PSMD_\", tiMacPrefix }, // Climax smart plug\n    { VENDOR_NONE, \"PSMP5_\", tiMacPrefix }, // Climax smart plug\n    { VENDOR_NONE, \"PCM_\", tiMacPrefix }, // Climax power meter\n    { VENDOR_NONE, \"OJB-IR715-Z\", tiMacPrefix },\n    { VENDOR_NONE, \"902010/21\", tiMacPrefix }, // Bitron: door/window sensor\n    { VENDOR_NONE, \"902010/22\", tiMacPrefix }, // Bitron: motion sensor\n    { VENDOR_NONE, \"902010/23\", tiMacPrefix }, // Bitron: remote control\n    { VENDOR_NONE, \"902010/24\", tiMacPrefix }, // Bitron: smoke detector\n    { VENDOR_NONE, \"902010/25\", tiMacPrefix }, // Bitron: smart plug\n    { VENDOR_NONE, \"902010/29\", tiMacPrefix }, // Bitron: Outdoor siren\n    { VENDOR_NONE, \"SPW35Z\", tiMacPrefix }, // RT-RK OBLO SPW35ZD0 smart plug\n    { VENDOR_NONE, \"SWO-MOS1PA\", tiMacPrefix }, // Swann One Motion Sensor\n    { VENDOR_BITRON, \"902010/32\", emberMacPrefix }, // Bitron: thermostat\n    { VENDOR_IKEA, \"TRADFRI remote control\", silabs1MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI remote control\", silabsMacPrefix },\n    { VENDOR_IKEA, \"TRADFRI remote control\", silabs2MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI motion sensor\", silabs1MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI wireless dimmer\", silabs1MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI on/off switch\", silabs1MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI SHORTCUT Button\", silabs4MacPrefix },\n    { VENDOR_IKEA, \"TRADFRI open/close remote\", silabs1MacPrefix },\n    { VENDOR_IKEA, \"SYMFONISK\", ikea2MacPrefix }, // sound controller\n    { VENDOR_INSTA, \"Remote\", instaMacPrefix },\n    { VENDOR_INSTA, \"HS_4f_GJ_1\", instaMacPrefix },\n    { VENDOR_INSTA, \"WS_4f_J_1\", instaMacPrefix },\n    { VENDOR_INSTA, \"WS_3f_G_1\", instaMacPrefix },\n    { VENDOR_AXIS, \"Gear\", zenMacPrefix },\n    { VENDOR_MMB, \"Gear\", zenMacPrefix },\n    { VENDOR_SI_LABS, \"D10110\", konkeMacPrefix }, // Yoolax Blinds\n    { VENDOR_SI_LABS, \"D10110\", YooksmartMacPrefix }, // Yoolax Blinds\n    { VENDOR_NYCE, \"3011\", emberMacPrefix }, // NYCE door/window sensor\n    { VENDOR_NYCE, \"3014\", emberMacPrefix }, // NYCE garage door/tilt sensor\n    { VENDOR_NYCE, \"3041\", emberMacPrefix }, // NYCE motion sensor\n    { VENDOR_NYCE, \"3043\", emberMacPrefix }, // NYCE ceiling motion sensor\n    { VENDOR_PHYSICAL, \"tagv4\", stMacPrefix}, // SmartThings Arrival sensor\n    { VENDOR_PHYSICAL, \"motionv4\", stMacPrefix}, // SmartThings motion sensor\n    { VENDOR_PHYSICAL, \"moisturev4\", stMacPrefix}, // SmartThings water leak sensor\n    { VENDOR_PHYSICAL, \"multiv4\", stMacPrefix}, // SmartThings multi sensor 2016\n    { VENDOR_SAMJIN, \"motion\", samjinMacPrefix }, // Smarthings GP-U999SJVLBAA (Samjin) Motion Sensor\n    { VENDOR_SAMJIN, \"multi\", samjinMacPrefix }, // Smarthings (Samjin) Multipurpose Sensor\n    { VENDOR_SAMJIN, \"water\", samjinMacPrefix }, // Smarthings (Samjin) Water Sensor\n    { VENDOR_SAMJIN, \"button\", samjinMacPrefix }, // Smarthings (Samjin) Button\n    { VENDOR_SAMJIN, \"outlet\", samjinMacPrefix }, // Smarthings (Samjin) Outlet\n    { VENDOR_JENNIC, \"lumi.lock.v1\", jennicMacPrefix }, // Xiaomi A6121 Vima Smart Lock\n    { VENDOR_JENNIC, \"lumi.sensor_magnet\", jennicMacPrefix },\n    { VENDOR_JENNIC, \"lumi.sensor_motion\", jennicMacPrefix },\n    { VENDOR_JENNIC, \"lumi.sensor_switch.aq2\", jennicMacPrefix }, // Xiaomi WXKG11LM 2016\n    { VENDOR_JENNIC, \"lumi.remote.b1acn01\", jennicMacPrefix },    // Xiaomi WXKG11LM 2018\n    { VENDOR_JENNIC, \"lumi.sensor_switch.aq3\", jennicMacPrefix }, // Xiaomi WXKG12LM\n    { VENDOR_JENNIC, \"lumi.sensor_86sw1\", jennicMacPrefix },      // Xiaomi single button wall switch WXKG03LM 2016\n    { VENDOR_JENNIC, \"lumi.remote.b186acn01\", jennicMacPrefix },  // Xiaomi single button wall switch WXKG03LM 2018\n    { VENDOR_JENNIC, \"lumi.remote.b186acn02\", jennicMacPrefix },  // Xiaomi single button wall switch WXKG02LM 2020\n    { VENDOR_JENNIC, \"lumi.sensor_86sw2\", jennicMacPrefix },      // Xiaomi dual button wall switch WXKG02LM 2016\n    { VENDOR_JENNIC, \"lumi.remote.b286acn01\", jennicMacPrefix },  // Xiaomi dual button wall switch WXKG02LM 2018\n    { VENDOR_JENNIC, \"lumi.remote.b286acn02\", jennicMacPrefix },  // Xiaomi dual button wall switch WXKG02LM 2020\n    { VENDOR_JENNIC, \"lumi.sensor_switch\", jennicMacPrefix },     // Xiaomi WXKG01LM, WXKG11LM and WXKG12LM (fallback)\n    { VENDOR_JENNIC, \"lumi.ctrl_neutral\", jennicMacPrefix }, // Xiaomi Wall Switch (end-device)\n    { VENDOR_JENNIC, \"lumi.vibration\", jennicMacPrefix }, // Xiaomi Aqara vibration/shock sensor\n    { VENDOR_JENNIC, \"lumi.sensor_wleak\", jennicMacPrefix },\n    { VENDOR_JENNIC, \"lumi.relay.c\", jennicMacPrefix }, // Xiaomi Aqara LLKZMK11LM\n    { VENDOR_JENNIC, \"lumi.switch.b1lacn02\", jennicMacPrefix }, // Xiaomi Aqara D1 1-gang (no neutral wire) QBKG21LM\n    { VENDOR_JENNIC, \"lumi.switch.b2lacn02\", jennicMacPrefix }, // Xiaomi Aqara D1 2-gang (no neutral wire) QBKG22LM\n    { VENDOR_XIAOMI, \"lumi.switch.b1nacn02\", jennicMacPrefix }, // Xiaomi Aqara D1 1-gang (neutral wire) QBKG23LM\n    { VENDOR_XIAOMI, \"lumi.switch.b2nacn02\", jennicMacPrefix }, // Xiaomi Aqara D1 2-gang (neutral wire) QBKG24LM\n    { VENDOR_XIAOMI, \"lumi.plug\", jennicMacPrefix }, // Xiaomi smart plug (router)\n    { VENDOR_XIAOMI, \"lumi.ctrl_ln\", jennicMacPrefix}, // Xiaomi Wall Switch (router)\n    { VENDOR_XIAOMI, \"lumi.remote.b286opcn01\", xiaomiMacPrefix }, // Xiaomi Aqara Opple WXCJKG11LM\n    { VENDOR_XIAOMI, \"lumi.remote.b486opcn01\", xiaomiMacPrefix }, // Xiaomi Aqara Opple WXCJKG12LM\n    { VENDOR_XIAOMI, \"lumi.remote.b686opcn01\", xiaomiMacPrefix }, // Xiaomi Aqara Opple WXCJKG13LM\n    { VENDOR_XIAOMI, \"lumi.plug\", xiaomiMacPrefix }, // Xiaomi smart plugs (router)\n    { VENDOR_XIAOMI, \"lumi.switch.b1naus01\", xiaomiMacPrefix }, // Xiaomi Aqara ZB3.0 Smart Wall Switch Single Rocker WS-USC03\n    // { VENDOR_XIAOMI, \"lumi.curtain\", jennicMacPrefix}, // Xiaomi curtain controller (router) - exposed only as light\n    { VENDOR_XIAOMI, \"lumi.curtain.hagl04\", xiaomiMacPrefix}, // Xiaomi B1 curtain controller\n    { VENDOR_XIAOMI, \"lumi.motion.agl04\", lumiMacPrefix}, // Xiaomi Aqara RTCGQ13LM high precision motion sensor\n    { VENDOR_XIAOMI, \"lumi.flood.agl02\", xiaomiMacPrefix}, // Xiaomi Aqara T1 water leak sensor SJCGQ12LM\n    { VENDOR_XIAOMI, \"lumi.switch.n0agl1\", lumiMacPrefix}, // Xiaomi Aqara Single Switch Module T1 (With Neutral)\n    { VENDOR_NONE, \"Z716A\", netvoxMacPrefix },\n    // { VENDOR_OSRAM_STACK, \"Plug\", osramMacPrefix }, // OSRAM plug - exposed only as light\n    { VENDOR_OSRAM, \"Lightify Switch Mini\", emberMacPrefix }, // Osram 3 button remote\n    { VENDOR_OSRAM, \"Switch 4x EU-LIGHTIFY\", emberMacPrefix }, // Osram 4 button remote\n    { VENDOR_OSRAM, \"Switch 4x-LIGHTIFY\", emberMacPrefix }, // Osram 4 button remote\n    { VENDOR_OSRAM, \"Switch-LIGHTIFY\", emberMacPrefix }, // Osram 4 button remote\n    { VENDOR_OSRAM_STACK, \"CO_\", heimanMacPrefix }, // Heiman CO sensor\n    { VENDOR_OSRAM_STACK, \"DOOR_\", heimanMacPrefix }, // Heiman door/window sensor - older model\n    { VENDOR_OSRAM_STACK, \"PIR_\", heimanMacPrefix }, // Heiman motion sensor\n    { VENDOR_OSRAM_STACK, \"GAS_\", heimanMacPrefix }, // Heiman gas sensor - older model\n    { VENDOR_OSRAM_STACK, \"TH-\", heimanMacPrefix }, // Heiman temperature/humidity sensor\n    { VENDOR_OSRAM_STACK, \"SMOK_\", heimanMacPrefix }, // Heiman fire sensor - older model\n    { VENDOR_OSRAM_STACK, \"WATER_\", heimanMacPrefix }, // Heiman water sensor\n    { VENDOR_OSRAM_STACK, \"RC_V14\", heimanMacPrefix }, // Heiman HS1RC-M remote control\n    { VENDOR_LGE, \"LG IP65 HMS\", emberMacPrefix },\n    { VENDOR_EMBER, \"SmartPlug\", emberMacPrefix }, // Heiman smart plug\n    { VENDOR_HEIMAN, \"SmartPlug\", emberMacPrefix }, // Heiman smart plug\n    { VENDOR_HEIMAN, \"GAS\", emberMacPrefix }, // Heiman gas sensor - newer model\n    { VENDOR_HEIMAN, \"Smoke\", emberMacPrefix }, // Heiman fire sensor - newer model\n    { VENDOR_HEIMAN, \"COSensor\", emberMacPrefix }, // Heiman CO sensor - newer model\n    { VENDOR_HEIMAN, \"TH-\", emberMacPrefix }, // Heiman temperature/humidity sensor - newer model\n    { VENDOR_HEIMAN, \"HT-\", emberMacPrefix }, // Heiman temperature/humidity sensor - newer model\n    { VENDOR_HEIMAN, \"Water\", emberMacPrefix }, // Heiman water sensor - newer model\n    { VENDOR_HEIMAN, \"Door\", emberMacPrefix }, // Heiman door/window sensor - newer model\n    { VENDOR_HEIMAN, \"WarningDevice\", emberMacPrefix }, // Heiman siren\n    { VENDOR_HEIMAN, \"Smoke\", jennicMacPrefix }, // Heiman fire sensor - newer model\n    { VENDOR_HEIMAN, \"PIRSensor-EM\", jennicMacPrefix }, // Heiman motion sensor - newer model\n    { VENDOR_HEIMAN, \"SKHMP30\", jennicMacPrefix }, // GS (Heiman) smart plug\n    { VENDOR_HEIMAN, \"RC-EM\", emberMacPrefix }, // Heiman IAS ACE remote control\n    { VENDOR_HEIMAN, \"RC-EF-3.0\", silabs5MacPrefix }, // Heiman IAS ACE remote control\n    { VENDOR_LUTRON, \"LZL4BWHL01\", lutronMacPrefix }, // Lutron LZL-4B-WH-L01 Connected Bulb Remote\n    { VENDOR_KEEN_HOME , \"SV01-\", celMacPrefix}, // Keen Home Vent\n    { VENDOR_KEEN_HOME , \"SV02-\", celMacPrefix}, // Keen Home Vent\n    { VENDOR_JENNIC, \"VMS_ADUROLIGHT\", jennicMacPrefix }, // Trust motion sensor ZPIR-8000\n    { VENDOR_JENNIC, \"CSW_ADUROLIGHT\", jennicMacPrefix }, // Trust contact sensor ZMST-808\n    { VENDOR_JENNIC, \"ZYCT-202\", jennicMacPrefix }, // Trust remote control ZYCT-202 (older model)\n    { VENDOR_ADUROLIGHT, \"ZLL-NonColorController\", jennicMacPrefix }, // Trust remote control ZYCT-202 (newer model)\n    { VENDOR_INNR, \"RC 110\", jennicMacPrefix }, // innr remote RC 110\n    { VENDOR_VISONIC, \"MCT-340\", emberMacPrefix }, // Visonic MCT-340 E temperature/motion\n    { VENDOR_SUNRICHER, \"ZGR904-S\", emberMacPrefix }, // Envilar remote\n    { VENDOR_SUNRICHER, \"ICZB-KPD1\", emberMacPrefix }, // iCasa keypad\n    { VENDOR_SUNRICHER, \"ICZB-RM\", silabs2MacPrefix }, // iCasa remote\n    { VENDOR_SUNRICHER, \"ZGRC-KEY\", emberMacPrefix }, // Sunricher wireless CCT remote\n    { VENDOR_SUNRICHER, \"RGBgenie ZB-5\", emberMacPrefix }, // RGBgenie remote control\n    { VENDOR_SUNRICHER, \"ROB_200-010-0\", silabs3MacPrefix }, // Robbshop window covering controller\n    { VENDOR_SUNRICHER, \"ROB_200-014-0\", silabs3MacPrefix }, // Robbshop rotary dimmer\n    { VENDOR_SUNRICHER, \"Micro Smart Dimmer\", silabs3MacPrefix }, // Sunricher SR-ZG9040A built-in dimmer\n    { VENDOR_SUNRICHER, \"ZG2835\", silabs6MacPrefix }, // SR-ZG2835 Zigbee Rotary Switch\n    { VENDOR_SUNRICHER, \"ZGRC-TEUR-\", emberMacPrefix }, // iluminize wall switch 511.524\n    { VENDOR_SUNRICHER, \"ZG2833PAC\", silabs3MacPrefix}, // Sunricher Zigbee Push-Button Coupler SR-ZG2833PAC-C4\n    { VENDOR_JENNIC, \"SPZB0001\", jennicMacPrefix }, // Eurotronic thermostat\n    { VENDOR_NONE, \"RES001\", tiMacPrefix }, // Hubitat environment sensor, see #1308\n    { VENDOR_SINOPE, \"WL4200S\", sinopeMacPrefix}, // Sinope water sensor with wired remote sensor\n    { VENDOR_SINOPE, \"WL4200\", sinopeMacPrefix}, // Sinope water sensor\n    { VENDOR_SINOPE, \"TH1300ZB\", sinopeMacPrefix }, // Sinope Thermostat\n    { VENDOR_ZEN, \"Zen-01\", zenMacPrefix }, // Zen Thermostat\n    { VENDOR_C2DF, \"3157100\", emberMacPrefix }, // Centralite Thermostat\n    { VENDOR_EMBER, \"Super TR\", emberMacPrefix }, // Elko Thermostat\n    { VENDOR_DATEK_WIRLESS, \"Super TR\", silabs4MacPrefix }, // Elko Thermostat\n    { VENDOR_EMBER, \"ElkoDimmer\", emberMacPrefix }, // Elko dimmer\n    { VENDOR_ATMEL, \"Thermostat\", ecozyMacPrefix }, // eCozy Thermostat\n    { VENDOR_OWON, \"PR412C\", emberMacPrefix }, // OWON PCT502 Thermostat\n    { VENDOR_STELPRO, \"ST218\", xalMacPrefix }, // Stelpro Thermostat\n    { VENDOR_STELPRO, \"STZB402\", xalMacPrefix }, // Stelpro baseboard thermostat\n    { VENDOR_STELPRO, \"SORB\", xalMacPrefix }, // Stelpro Orleans Fan\n    { VENDOR_DEVELCO, \"FLSZB-1\", develcoMacPrefix }, // Develco water leak sensor\n    { VENDOR_DEVELCO, \"EMIZB-1\", develcoMacPrefix }, // Develco EMI Norwegian HAN\n    { VENDOR_DEVELCO, \"SMRZB-3\", develcoMacPrefix }, // Develco Smart Relay DIN\n    { VENDOR_DEVELCO, \"SMRZB-1\", develcoMacPrefix }, // Develco Smart Cable\n    { VENDOR_DEVELCO, \"SIRZB-1\", develcoMacPrefix }, // Develco siren\n    { VENDOR_DEVELCO, \"ZHMS101\", develcoMacPrefix }, // Wattle (Develco) magnetic sensor\n    { VENDOR_DEVELCO, \"MotionSensor51AU\", develcoMacPrefix }, // Aurora (Develco) motion sensor\n    { VENDOR_DEVELCO, \"Smart16ARelay51AU\", develcoMacPrefix }, // Aurora (Develco) smart plug\n    { VENDOR_DATEK_WIRLESS, \"PoP\", konkeMacPrefix }, // Apex Smart Plug\n    { VENDOR_EMBER, \"3AFE14010402000D\", konkeMacPrefix }, // Konke Kit Pro-BS Motion Sensor\n    { VENDOR_KONKE, \"3AFE28010402000D\", ikea2MacPrefix }, // Konke Kit Pro-BS Motion Sensor ver.2\n    { VENDOR_EMBER, \"3AFE140103020000\", konkeMacPrefix }, // Konke Kit Pro-FT Temp Humidity Sensor\n    { VENDOR_KONKE, \"3AFE220103020000\", ikea2MacPrefix }, // Konke Kit Pro-BS Temp Humidity Sensor ver.2\n    { VENDOR_KONKE, \"3AFE220103020000\", konkeMacPrefix }, // Konke Kit Pro-BS Temp Humidity Sensor ver ???\n    { VENDOR_EMBER, \"3AFE130104020015\", konkeMacPrefix }, // Konke Kit Pro-Door Entry Sensor\n    { VENDOR_EMBER, \"ALCANTARA2 D1.00P1.01Z1.00\", silabs5MacPrefix }, // Alcantara 2 acova\n    { VENDOR_NONE, \"RICI01\", tiMacPrefix}, // LifeControl smart plug\n    { VENDOR_JENNIC, \"Adurolight_NCC\", jennicMacPrefix}, // Eria Adurosmart Wireless Dimming Switch\n    { VENDOR_JENNIC, \"VOC_Sensor\", jennicMacPrefix}, // LifeControl Enviroment sensor\n    { VENDOR_JENNIC, \"SN10ZW\", jennicMacPrefix }, // ORVIBO motion sensor\n    { VENDOR_JENNIC, \"e70f96b3773a4c9283c6862dbafb6a99\", jennicMacPrefix }, // ORVIBO open/close sensor SM11\n    { VENDOR_OSRAM_STACK, \"SF20\", heimanMacPrefix }, // ORVIBO SF20 smoke sensor\n    // Danalock support\n    { VENDOR_DANALOCK, \"V3\", silabs1MacPrefix}, // Danalock Smart Lock\n    // Schlage support\n    { VENDOR_SCHLAGE, \"BE468\", schlageMacPrefix}, // Schlage BE468 Smart Lock\n    { VENDOR_HEIMAN, \"SF21\", emberMacPrefix }, // ORVIBO SF21 smoke sensor\n    { VENDOR_3A_SMART_HOME, \"ST30 Temperature Sensor\", jennicMacPrefix }, // Orvibo ST30 Temp/Humidity Sensor with display\n    { VENDOR_EMBER, \"ST30 Temperature Sensor\", silabs9MacPrefix }, // Orvibo ST30 Temp/Humidity Sensor with display (alternate)\n    { VENDOR_HEIMAN, \"358e4e3e03c644709905034dae81433e\", emberMacPrefix }, // Orvibo Combustible Gas Sensor\n    { VENDOR_LEGRAND, \"Dimmer switch w/o neutral\", legrandMacPrefix }, // Legrand Dimmer switch wired\n    { VENDOR_LEGRAND, \"Connected outlet\", legrandMacPrefix }, // Legrand Plug\n    { VENDOR_LEGRAND, \"Shutter switch with neutral\", legrandMacPrefix }, // Legrand Shutter switch\n    { VENDOR_LEGRAND, \"Remote toggle switch\", legrandMacPrefix }, // Legrand switch module\n    { VENDOR_LEGRAND, \"Cable outlet\", legrandMacPrefix }, // Legrand Cable outlet\n    { VENDOR_LEGRAND, \"Remote switch\", legrandMacPrefix }, // Legrand wireless switch\n    { VENDOR_LEGRAND, \"Double gangs remote switch\", legrandMacPrefix }, // Legrand wireless double switch\n    { VENDOR_LEGRAND, \"Remote motion sensor\", legrandMacPrefix }, // Legrand motion sensor\n    { VENDOR_LEGRAND, \"Shutters central remote switch\", legrandMacPrefix }, // Legrand wireless shutter switch (battery)\n    { VENDOR_LEGRAND, \"DIN power consumption module\", legrandMacPrefix }, // Legrand DIN power consumption module\n    { VENDOR_LEGRAND, \"Teleruptor\", legrandMacPrefix }, // Legrand Teleruptor\n    { VENDOR_LEGRAND, \"Contactor\", legrandMacPrefix }, // Legrand Contactor\n    { VENDOR_LEGRAND, \"Pocket remote\", legrandMacPrefix }, // Legrand wireless 4 x scene remote\n    { VENDOR_NETVOX, \"Z809AE3R\", netvoxMacPrefix }, // Netvox smartplug\n    { VENDOR_LDS, \"ZB-ONOFFPlug-D0005\", silabs2MacPrefix }, // Samsung SmartPlug 2019 (7A-PL-Z-J3)\n    { VENDOR_LDS, \"ZBT-DIMSwitch\", silabs2MacPrefix }, // Linkind 1 key Remote Control / ZS23000178\n    { VENDOR_LDS, \"ZB-KeypadGeneric-D0002\", silabs3MacPrefix }, // Linkind Keypad / ZS130000078\n    { VENDOR_LDS, \"ZB-MotionSensor-D0003\", silabsMacPrefix }, // Linkind motion sensor / ZS110040078\n    { VENDOR_LDS, \"ZB-DoorSensor-D0003\", YooksmartMacPrefix }, // Linkind Door/Window Sensor / ZS110050078\n    { VENDOR_LDS, \"ZBT-DIMController-D0800\", jennicMacPrefix }, // Mueller-Licht tint dimmer\n    { VENDOR_PHYSICAL, \"outletv4\", stMacPrefix }, // Samsung SmartThings plug (IM6001-OTP)\n    { VENDOR_EMBER, \"RH3040\", konkeMacPrefix }, // Tuyatec motion sensor\n    { VENDOR_NONE, \"RH3001\", ikea2MacPrefix }, // Tuyatec door/window sensor\n    { VENDOR_EMBER, \"RH3001\", silabs3MacPrefix }, // Tuya/Blitzwolf BW-IS2 door/window sensor\n    { VENDOR_NONE, \"RH3052\", emberMacPrefix }, // Tuyatec temperature sensor\n    { VENDOR_NONE, \"RH3052\", konkeMacPrefix }, // Tuyatec/Lupus temperature sensor\n    { VENDOR_EMBER, \"TS0201\", silabs3MacPrefix }, // Tuya/Blitzwolf temperature and humidity sensor\n    { VENDOR_EMBER, \"TS0203\", silabs12MacPrefix }, // tuya door windows sensor\n    { VENDOR_NONE, \"TS0204\", silabs3MacPrefix }, // Tuya gas sensor\n    { VENDOR_NONE, \"TS0205\", silabs3MacPrefix }, // Tuya smoke sensor\n    { VENDOR_NONE, \"TS0121\", silabs3MacPrefix }, // Tuya/Blitzwolf smart plug\n    { VENDOR_EMBER, \"TS0121\", silabs3MacPrefix }, // Tuya/Blitzwolf smart plug\n    { VENDOR_EMBER, \"TS0302\", silabs3MacPrefix }, // Tuya curtain switch\n    { VENDOR_EMBER, \"TS0041\", silabs3MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0041\", silabs5MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0042\", silabs3MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0043\", silabs3MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0043\", silabs8MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0043\", silabs7MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS0044\", silabs9MacPrefix }, // Tuya wireless switch\n    { VENDOR_EMBER, \"TS004F\", silabs8MacPrefix }, // Tuya wireless switch\n    { VENDOR_NONE, \"kud7u2l\", silabs3MacPrefix }, // Tuya Smart TRV HY369 Thermostatic Radiator Valve\n    { VENDOR_NONE, \"GbxAXL2\", silabs3MacPrefix }, // Another Tuya Smart TRV Thermostatic Radiator Valve\n    { VENDOR_NONE, \"w7cahqs\", silabs8MacPrefix }, // hama Smart Radiator Thermostat\n    { VENDOR_EMBER, \"TS0601\", silabs7MacPrefix }, // Tuya Smart TRV HY369 Thermostatic Radiator Valve\n    { VENDOR_EMBER, \"TS0601\", silabs5MacPrefix }, // MOES Zigbee Radiator Actuator HY368 / Moes Tuya Thermostat BTH-002\n    { VENDOR_EMBER, \"TS0207\", silabs3MacPrefix }, // Tuya water leak sensor\n    { VENDOR_NONE, \"TS0202\", silabs4MacPrefix }, // Tuya presence sensor\n    { VENDOR_EMBER, \"TS0202\", ikea2MacPrefix }, // Tuya multi sensor\n    { VENDOR_NONE, \"0yu2xgi\", silabs5MacPrefix }, // Tuya siren\n    { VENDOR_EMBER, \"TS0601\", silabs9MacPrefix }, // Tuya siren\n    { VENDOR_EMBER, \"TS0222\", silabs9MacPrefix }, // TYZB01 light sensor\n    { VENDOR_OWON, \"CTHS317ET\", casaiaPrefix }, // CASA.ia Temperature probe CTHS-317-ET\n    { VENDOR_NONE, \"eaxp72v\", ikea2MacPrefix }, // Tuya TRV Wesmartify Thermostat Essentials Premium\n    { VENDOR_EMBER, \"TS011F\", YooksmartMacPrefix }, // Tuya Plug Blitzwolf BW-SHP15\n    { VENDOR_EMBER, \"TS011F\", silabs10MacPrefix }, // Other tuya plugs\n    { VENDOR_NONE, \"88teujp\", silabs8MacPrefix }, // SEA802-Zigbee\n    { VENDOR_NONE, \"uhszj9s\", silabs8MacPrefix }, // HiHome WZB-TRVL\n    { VENDOR_NONE, \"fvq6avy\", silabs7MacPrefix }, // Revolt NX-4911-675 Thermostat\n    { VENDOR_NONE, \"GMB-HAS-WL-B01\", tiMacPrefix }, // GamaBit Ltd. water leak Sensor\n    { VENDOR_NONE, \"GMB-HAS-DW-B01\", tiMacPrefix }, // GamaBit Ltd. Window/Door Sensor\n    { VENDOR_NONE, \"GMB-HAS-VB-B01\", tiMacPrefix }, // GamaBit Ltd. Vibration Sensor\n    { VENDOR_HEIMAN, \"TY0203\", silabs3MacPrefix }, // Lidl/Silvercrest Smart Window or Door Sensor\n    { VENDOR_HEIMAN, \"TY0203\", silabs7MacPrefix }, // Lidl/Silvercrest Smart Window or Door Sensor\n    { VENDOR_HEIMAN, \"TY0202\", silabs3MacPrefix }, // Lidl/Silvercrest Smart Motion Sensor\n    { VENDOR_HEIMAN, \"TY0202\", silabs7MacPrefix }, // Lidl/Silvercrest Smart Motion Sensor\n    { VENDOR_HEIMAN, \"TS0211\", silabs3MacPrefix }, // Lidl/Silvercrest Smart Wireless Door Bell\n    { VENDOR_HEIMAN, \"TS0211\", silabs5MacPrefix }, // Lidl/Silvercrest Smart Wireless Door Bell\n    { VENDOR_HEIMAN, \"TS0211\", silabs7MacPrefix }, // Lidl/Silvercrest Smart Wireless Door Bell\n    { VENDOR_HEIMAN, \"TS0215\", silabs3MacPrefix }, // Tuya IAS ACE remote control\n    { VENDOR_AURORA, \"DoubleSocket50AU\", jennicMacPrefix }, // Aurora AOne Double Socket UK\n    { VENDOR_COMPUTIME, \"SP600\", computimeMacPrefix }, // Salus smart plug\n    { VENDOR_COMPUTIME, \"SPE600\", computimeMacPrefix }, // Salus smart plug\n    { VENDOR_HANGZHOU_IMAGIC, \"1116-S\", energyMiMacPrefix }, // iris contact sensor v3\n    { VENDOR_HANGZHOU_IMAGIC, \"1117-S\", energyMiMacPrefix }, // iris motion sensor v3\n    { VENDOR_JENNIC, \"113D\", jennicMacPrefix }, // iHorn (Huawei) temperature and humidity sensor\n    { VENDOR_CHINA_FIRE_SEC, \"LH05121\", jennicMacPrefix }, // iHorn (Huawei) smoke detector\n    { VENDOR_SERCOMM, \"SZ-ESW01\", emberMacPrefix }, // Sercomm / Telstra smart plug\n    { VENDOR_SERCOMM, \"SZ-SRN12N\", emberMacPrefix }, // Sercomm siren\n    { VENDOR_SERCOMM, \"SZ-SRN12N\", energyMiMacPrefix }, // Sercomm siren\n    { VENDOR_SERCOMM, \"SZ-DWS04\", emberMacPrefix }, // Sercomm open/close sensor\n    { VENDOR_SERCOMM, \"SZ-WTD02N_CAR\", emberMacPrefix }, // Sercomm water sensor\n    { VENDOR_SERCOMM, \"GZ-PIR02\", emberMacPrefix }, // Sercomm motion sensor\n    { VENDOR_SERCOMM, \"Tripper\", emberMacPrefix }, // Quirky Tripper (Sercomm) open/close sensor\n    { VENDOR_ALERTME, \"MOT003\", tiMacPrefix }, // Hive Motion Sensor\n    { VENDOR_ALERTME, \"DWS003\", tiMacPrefix }, // Hive Door sensor\n    { VENDOR_ALERTME, \"SLP2\", computimeMacPrefix }, // Hive  plug\n    { VENDOR_ALERTME, \"SLP2b\", computimeMacPrefix }, // Hive  plug\n    { VENDOR_ALERTME, \"SLR1b\", computimeMacPrefix }, // Hive   Heating Receiver 1 channel\n    { VENDOR_ALERTME, \"SLR2\", computimeMacPrefix }, // Hive   Heating Receiver 2 channel\n    { VENDOR_ALERTME, \"SLR2b\", computimeMacPrefix }, // Hive   Heating Receiver 2 channel second version\n    { VENDOR_ALERTME, \"SLT2\", computimeMacPrefix }, // Hive thermostat\n    { VENDOR_ALERTME, \"SLT3\", computimeMacPrefix }, // Hive thermostat\n    { VENDOR_SUNRICHER, \"4512705\", silabs2MacPrefix }, // Namron remote control\n    { VENDOR_SUNRICHER, \"4512726\", silabs2MacPrefix }, // Namron rotary switch\n    { VENDOR_SUNRICHER, \"S57003\", silabs2MacPrefix }, // SLC 4-ch remote controller\n    { VENDOR_SENGLED_OPTOELEC, \"E13-\", zhejiangMacPrefix }, // Sengled PAR38 Bulbs\n    { VENDOR_SENGLED_OPTOELEC, \"E1D-\", zhejiangMacPrefix }, // Sengled contact sensor\n    { VENDOR_SENGLED_OPTOELEC, \"E1E-\", zhejiangMacPrefix }, // Sengled Smart Light Switch\n    { VENDOR_SENGLED_OPTOELEC, \"Z01-A19\", zhejiangMacPrefix }, // Sengled SMART LED Z01-A19NAE26\n    { VENDOR_JENNIC, \"4in1-Sensor-ZB3.0\", emberMacPrefix }, // Immax NEO ZB3.0 4 in 1 sensor\n    { VENDOR_JENNIC, \"DoorWindow-Sensor-ZB3.0\", emberMacPrefix }, // Immax NEO ZB3.0 window/door sensor 07045L\n    { VENDOR_WAXMAN, \"leakSMART Water Sensor V2\", celMacPrefix }, // WAXMAN LeakSMART v2\n    { VENDOR_PHILIO, \"PST03A-v2.2.5\", emberMacPrefix }, // Philio pst03-a\n    { VENDOR_EMBERTEC, \"BQZ10-AU\", embertecMacPrefix }, // Embertec smart plug\n    { VENDOR_MUELLER, \"ZBT-Remote-ALL-RGBW\", jennicMacPrefix }, // Tint remote control\n    { VENDOR_PLUGWISE_BV, \"160-01\", emberMacPrefix }, // Plugwise smart plug\n    { VENDOR_NIKO_NV, \"Smart plug Zigbee PE\", silabs9MacPrefix }, // Niko Smart Plug 552-80699\n    { VENDOR_ATMEL, \"Bell\", dishMacPrefix }, // Sage doorbell sensor\n    { VENDOR_UNIVERSAL2, \"4655BC0\", emberMacPrefix }, // Ecolink contact sensor\n    { VENDOR_NONE, \"ZB-SmartPlug-1.0.0\", tiMacPrefix }, // edp re:dy plug\n    { VENDOR_NONE, \"WB01\", tiMacPrefix }, // Sonoff SNZB-01\n    { VENDOR_NONE, \"WB-01\", tiMacPrefix }, // Sonoff SNZB-01\n    { VENDOR_NONE, \"MS01\", tiMacPrefix }, // Sonoff SNZB-03\n    { VENDOR_NONE, \"MSO1\", tiMacPrefix }, // Sonoff SNZB-03\n    { VENDOR_NONE, \"ms01\", tiMacPrefix }, // Sonoff SNZB-03\n    { VENDOR_NONE, \"66666\", tiMacPrefix }, // Sonoff SNZB-03\n    { VENDOR_NONE, \"TH01\", tiMacPrefix }, // Sonoff SNZB-02\n    { VENDOR_NONE, \"DS01\", tiMacPrefix }, // Sonoff SNZB-04\n    { VENDOR_NONE, \"DIYRuZ_Flower\", tiMacPrefix }, // DIYRuZ_Flower\n    { VENDOR_SCHNEIDER, \"CCT591011_AS\", emberMacPrefix }, // LK Wiser Door / Window Sensor\n    { VENDOR_SCHNEIDER, \"CCT592011_AS\", emberMacPrefix }, // LK Wiser Water Leak Sensor\n    { VENDOR_SCHNEIDER, \"CCT593011_AS\", emberMacPrefix }, // LK Wiser Temperature and Humidity Sensor\n    { VENDOR_SCHNEIDER, \"CCT595011_AS\", emberMacPrefix }, // LK Wiser Motion Sensor\n    { VENDOR_DANFOSS, \"0x8020\", silabs6MacPrefix }, // Danfoss RT24V Display thermostat\n    { VENDOR_DANFOSS, \"0x8021\", silabs6MacPrefix }, // Danfoss RT24V Display thermostat with floor sensor\n    { VENDOR_DANFOSS, \"0x8030\", silabs6MacPrefix }, // Danfoss RTbattery Display thermostat\n    { VENDOR_DANFOSS, \"0x8031\", silabs6MacPrefix }, // Danfoss RTbattery Display thermostat with infrared\n    { VENDOR_DANFOSS, \"0x8034\", silabs6MacPrefix }, // Danfoss RTbattery Dial thermostat\n    { VENDOR_DANFOSS, \"0x8035\", silabs6MacPrefix }, // Danfoss RTbattery Dial thermostat with infrared\n    { VENDOR_LDS, \"ZBT-CCTSwitch-D0001\", silabs2MacPrefix }, // Leedarson remote control\n    { VENDOR_YALE, \"YRD256 TSDB\", emberMacPrefix }, // Yale YRD256 ZigBee keypad door lock\n    { VENDOR_YALE, \"YRD226 TSDB\", emberMacPrefix }, // Yale YRD226 ZigBee keypad door lock\n    { VENDOR_YALE, \"YRD226/246 TSDB\", emberMacPrefix }, // Yale YRD226 ZigBee keypad door lock\n    { VENDOR_YALE, \"YRD256L TSDB SL\", emberMacPrefix }, // Yale YRD256L ZigBee keypad door lock\n    { VENDOR_YALE, \"YRD220/240 TSDB\", emberMacPrefix }, // Yale\n    { VENDOR_KWIKSET, \"SMARTCODE_CONVERT_GEN1\", zenMacPrefix }, // Kwikset 914 ZigBee smart lock\n    { VENDOR_DSR, \"easyCodeTouch_v1\", onestiPrefix }, // EasyAccess EasyCodeTouch\n    { VENDOR_EMBER, \"TS1001\", silabs5MacPrefix }, // LIDL Livarno Lux Remote Control HG06323\n    { VENDOR_EMBER, \"TS1001\", silabs7MacPrefix }, // LIDL Livarno Lux Remote Control HG06323\n    { VENDOR_XFINITY, \"URC4450BC0-X-R\", emberMacPrefix }, // Xfinity Keypad XHK1-UE / URC4450BC0-X-R\n    { VENDOR_CENTRALITE, \"3405-L\", emberMacPrefix }, // IRIS 3405-L Keypad\n\n    { 0, nullptr, 0 }\n};\n\nint TaskItem::_taskCounter = 1; // static rolling taskcounter\n\n/*! Returns the largest supported API version.\n\n    There might be one, none or multiple versions listed in \\p hdrValue:\n\n        Accept: nothing, relevant, here    --> ApiVersion_1\n        Accept: vnd.ddel.v1                --> ApiVersion_1_DDEL\n        Accept: vnd.ddel.v1,vnd.ddel.v1.1  --> ApiVersion_1_1_DDEL\n        Accept: vnd.ddel.v2                --> ApiVersion_2_DDEL\n        Accept: vnd.ddel.v1,vnd.ddel.v2    --> ApiVersion_2_DDEL\n */\nstatic ApiVersion getAcceptHeaderApiVersion(const QLatin1String &hdrValue)\n{\n    ApiVersion result = { ApiVersion_1 };\n\n    struct ApiVersionMap {\n        ApiVersion version;\n        QLatin1String str;\n    };\n\n    static const std::array<ApiVersionMap, 6> versions = {\n        {\n            // ordered by largest version\n            { ApiVersion_3_DDEL,   QLatin1String(\"application/vnd.ddel.v3\") },\n            { ApiVersion_2_DDEL,   QLatin1String(\"application/vnd.ddel.v2\") },\n            { ApiVersion_1_1_DDEL, QLatin1String(\"application/vnd.ddel.v1.1\") },\n            { ApiVersion_1_1_DDEL, QLatin1String(\"vnd.ddel.v1.1\") }, // backward compatibility\n            { ApiVersion_1_DDEL,   QLatin1String(\"application/vnd.ddel.v1\") },\n            { ApiVersion_1_DDEL,   QLatin1String(\"vnd.ddel.v1\") }   // backward compatibility\n        }\n    };\n\n    for (const auto &version : versions)\n    {\n        if (contains(hdrValue, version.str))\n        {\n            result = version.version;\n            break;\n        }\n    }\n\n    return result;\n}\n\nApiRequest::ApiRequest(const QHttpRequestHeader &h, const QStringList &p, QTcpSocket *s, const QString &c) :\n    hdr(h), path(p), sock(s), content(c), version(ApiVersion_1), auth(ApiAuthNone), mode(ApiModeNormal)\n{\n    const auto accept = hdr.value(QLatin1String(\"Accept\"));\n    if (accept.size() > 4) // rule out */*\n    {\n        version = getAcceptHeaderApiVersion(accept);\n    }\n}\n\n/*! Returns the apikey of a request or a empty string if not available\n */\nQString ApiRequest::apikey() const\n{\n    if (path.length() > 1 && path[0] == QLatin1String(\"api\"))\n    {\n        return path.at(1);\n    }\n\n    return QLatin1String(\"\");\n}\n\n/*! Returns the next ZCL sequence number to use.\n */\nquint8 zclNextSequenceNumber()\n{\n    Q_ASSERT(plugin);\n    return plugin->zclSeq++;\n}\n\n/*! Returns deCONZ core node for a given \\p extAddress.\n */\nconst deCONZ::Node *getCoreNode(uint64_t extAddress)\n{\n    int i = 0;\n    const deCONZ::Node *result = nullptr;\n    const deCONZ::Node *node = nullptr;\n    deCONZ::ApsController *ctrl = deCONZ::ApsController::instance();\n\n    while (ctrl->getNode(i, &node) == 0)\n    {\n        if (node->address().ext() == extAddress)\n        {\n            result = node;\n            break;\n        }\n        i++;\n    }\n\n    return result;\n}\n\n/*! Constructor for pimpl.\n    \\param parent - the main plugin\n */\nDeRestPluginPrivate::DeRestPluginPrivate(QObject *parent) :\n    QObject(parent),\n    apsCtrlWrapper(deCONZ::ApsController::instance())\n{\n    plugin = this;\n    ScratchMemInit();\n\n    DEV_SetTestManaged(deCONZ::appArgumentNumeric(\"--dev-test-managed\", 0));\n\n#ifdef DECONZ_DEBUG_BUILD\n    EventTestZclPacking();\n#endif\n\n    pollManager = new PollManager(this);\n\n    databaseTimer = new QTimer(this);\n    databaseTimer->setSingleShot(true);\n\n    eventEmitter = new EventEmitter(this);\n    connect(eventEmitter, &EventEmitter::eventNotify, this, &DeRestPluginPrivate::handleEvent);\n    initResourceDescriptors();\n\n    restDevices = new RestDevices(this);\n    connect(restDevices, &RestDevices::eventNotify, eventEmitter, &EventEmitter::enqueueEvent);\n    connect(eventEmitter, &EventEmitter::eventNotify, restDevices, &RestDevices::handleEvent);\n\n    alarmSystemDeviceTable.reset(new AS_DeviceTable);\n\n    alarmSystems.reset(new AlarmSystems);\n\n    deviceJs = new DeviceJs();\n\n    deviceDescriptions = new DeviceDescriptions(this);\n    connect(deviceDescriptions, &DeviceDescriptions::eventNotify, eventEmitter, &EventEmitter::enqueueEvent);\n    connect(eventEmitter, &EventEmitter::eventNotify, deviceDescriptions, &DeviceDescriptions::handleEvent);\n\n    {\n        QSettings config(deCONZ::getStorageLocation(deCONZ::ConfigLocation), QSettings::IniFormat);\n\n        int filterBronze = config.value(\"ddf-filter/bronze\", 0).toInt();\n        int filterSilver = config.value(\"ddf-filter/silver\", 0).toInt();\n        int filterGold = config.value(\"ddf-filter/gold\", 1).toInt();\n\n        QStringList filter;\n\n        if (filterBronze) { filter.append(\"Bronze\"); }\n        if (filterSilver) { filter.append(\"Silver\"); }\n        if (filterGold)\n        {\n            filter.append(\"Gold\");\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"Warning: DDF Gold status is not enabled\\n\");\n        }\n\n        deviceDescriptions->setEnabledStatusFilter(filter);\n    }\n\n    connect(databaseTimer, SIGNAL(timeout()),\n            this, SLOT(saveDatabaseTimerFired()));\n\n    webSocketServer = 0;\n\n    gwScanner = new GatewayScanner(this);\n    connect(gwScanner, SIGNAL(foundGateway(QHostAddress,quint16,QString,QString)),\n            this, SLOT(foundGateway(QHostAddress,quint16,QString,QString)));\n//    gwScanner->startScan();\n\n    QString dataPath = deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation);\n\n    saveDatabaseItems = 0;\n    saveDatabaseIdleTotalCounter = 0;\n    dbZclValueMaxAge = 0; // default disable\n    sqliteDatabaseName = dataPath + QLatin1String(\"/zll.db\");\n\n    idleLimit = 0;\n    idleTotalCounter = IDLE_READ_LIMIT;\n    idleLastActivity = 0;\n    idleUpdateZigBeeConf = idleTotalCounter + 15;\n    queryTime = QTime::currentTime();\n    udpSock = 0;\n    haEndpoint = 0;\n    gwGroupSendDelay = deCONZ::appArgumentNumeric(\"--group-delay\", GROUP_SEND_DELAY);\n    gwLinkButton = false;\n    gwWebSocketNotifyAll = true;\n    gwdisablePermitJoinAutoOff = false;\n    gwLightLastSeenInterval = 60;\n\n    // preallocate memory to get consistent pointers\n    nodes.reserve(300);\n    sensors.reserve(150);\n\n    fastProbeTimer = new QTimer(this);\n    fastProbeTimer->setInterval(500);\n    fastProbeTimer->setSingleShot(true);\n    connect(fastProbeTimer, SIGNAL(timeout()), this, SLOT(delayedFastEnddeviceProbe()));\n\n    apsCtrl = deCONZ::ApsController::instance();\n    apsCtrl->setParameter(deCONZ::ParamOtauActive, 0);\n\n    // starttime reference counts from here\n    starttimeRef.start();\n\n    initConfig();\n\n    updateEtag(gwConfigEtag);\n    updateEtag(gwSensorsEtag);\n    updateEtag(gwGroupsEtag);\n    updateEtag(gwLightsEtag);\n\n    // set some default might be overwritten by database\n    gwAnnounceInterval = ANNOUNCE_INTERVAL;\n    gwAnnounceUrl = \"https://phoscon.de/discover\";\n    inetDiscoveryManager = nullptr;\n\n    webhookManager = new QNetworkAccessManager(this);\n    connect(webhookManager, SIGNAL(finished(QNetworkReply*)),\n            this, SLOT(webhookFinishedRequest(QNetworkReply*)));\n\n    // lights\n    searchLightsState = SearchLightsIdle;\n    searchLightsTimeout = 0;\n\n    // sensors\n    sensorCheckIter = 0;\n    searchSensorsState = SearchSensorsIdle;\n    searchSensorsTimeout = 0;\n\n    ttlDataBaseConnection = 0;\n    openDb();\n    initDb();\n\n    deviceDescriptions->prepare();\n    deviceDescriptions->readAll();\n\n    readDb();\n\n    DB_LoadAlarmSystemDevices(alarmSystemDeviceTable.get());\n    DB_LoadAlarmSystems(*alarmSystems, alarmSystemDeviceTable.get(), eventEmitter);\n    AS_InitDefaultAlarmSystem(*alarmSystems, alarmSystemDeviceTable.get(), eventEmitter);\n\n    closeDb();\n\n    initTimezone();\n\n    checkConsistency();\n\n    if (!gwUserParameter.contains(\"groupssequenceleft\"))\n    {\n        gwUserParameter[\"groupssequenceleft\"] = \"[]\";\n    }\n    if (!gwUserParameter.contains(\"groupssequenceright\"))\n    {\n        gwUserParameter[\"groupssequenceright\"] = \"[]\";\n    }\n    if (gwUuid.isEmpty())\n    {\n        generateGatewayUuid();\n    }\n\n    // create default group\n    // get new id\n    if (gwGroup0 == 0)\n    {\n        for (uint16_t i = 0xFFF0; i > 0; i--) // 0 and larger than 0xfff7 is not valid for Osram Lightify\n        {\n            Group* group = getGroupForId(i);\n            if (!group)\n            {\n                gwGroup0 = i;\n                break;\n            }\n        }\n    }\n\n    // delete old group 0\n    if (gwGroup0 != 0)\n    {\n        for (Group& group : groups)\n        {\n            if (group.address() == 0 && !(group.state() == Group::StateDeleted || group.state() == Group::StateDeleteFromDB))\n            {\n                group.setState(Group::StateDeleted);\n                queSaveDb(DB_CONFIG | DB_GROUPS, DB_LONG_SAVE_DELAY);\n                break;\n            }\n        }\n    }\n\n    // create new group 0\n    Group* group = getGroupForId(gwGroup0);\n    if (!group)\n    {\n        Group group;\n        group.setAddress(gwGroup0);\n        group.setName(\"All\");\n        groups.push_back(group);\n        queSaveDb(DB_GROUPS, DB_LONG_SAVE_DELAY);\n    }\n\n    connect(apsCtrl, SIGNAL(apsdeDataConfirm(deCONZ::ApsDataConfirm)),\n            this, SLOT(apsdeDataConfirm(deCONZ::ApsDataConfirm)));\n\n    connect(apsCtrl, SIGNAL(apsdeDataIndication(deCONZ::ApsDataIndication)),\n            this, SLOT(apsdeDataIndication(deCONZ::ApsDataIndication)));\n\n    connect(apsCtrl, SIGNAL(apsdeDataRequestEnqueued(deCONZ::ApsDataRequest)),\n            this, SLOT(apsdeDataRequestEnqueued(deCONZ::ApsDataRequest)));\n\n    connect(apsCtrl, SIGNAL(nodeEvent(deCONZ::NodeEvent)),\n            this, SLOT(nodeEvent(deCONZ::NodeEvent)));\n\n    connect(apsCtrl, SIGNAL(sourceRouteCreated(deCONZ::SourceRoute)), this, SLOT(storeSourceRoute(deCONZ::SourceRoute)));\n    connect(apsCtrl, SIGNAL(sourceRouteDeleted(QString)), this, SLOT(deleteSourceRoute(QString)));\n    connect(apsCtrl, SIGNAL(nodesRestored()), this, SLOT(restoreSourceRoutes()), Qt::QueuedConnection);\n\n    deCONZ::GreenPowerController *gpCtrl = deCONZ::GreenPowerController::instance();\n\n    if (gpCtrl)\n    {\n        bool ok =\n        connect(gpCtrl, SIGNAL(gpDataIndication(deCONZ::GpDataIndication)),\n                this, SLOT(gpDataIndication(deCONZ::GpDataIndication)));\n\n        DBG_Assert(ok);\n    }\n\n    taskTimer = new QTimer(this);\n    taskTimer->setSingleShot(false);\n    connect(taskTimer, SIGNAL(timeout()),\n            this, SLOT(processTasks()));\n    taskTimer->start(100);\n\n    groupTaskTimer = new QTimer(this);\n    groupTaskTimer->setSingleShot(false);\n    connect(groupTaskTimer, SIGNAL(timeout()),\n            this, SLOT(processGroupTasks()));\n    groupTaskTimer->start(250);\n\n    fastRuleCheckTimer = new QTimer(this);\n    fastRuleCheckTimer->setInterval(5);\n    fastRuleCheckTimer->setSingleShot(true);\n    connect(fastRuleCheckTimer, SIGNAL(timeout()),\n            this, SLOT(fastRuleCheckTimerFired()));\n\n    checkSensorsTimer = new QTimer(this);\n    checkSensorsTimer->setSingleShot(false);\n    checkSensorsTimer->setInterval(CHECK_SENSOR_INTERVAL);\n    connect(checkSensorsTimer, SIGNAL(timeout()),\n            this, SLOT(checkSensorStateTimerFired()));\n    checkSensorsTimer->start();\n    sensorCheckFast = 0;\n\n    bindingTimer = new QTimer(this);\n    bindingTimer->setSingleShot(true);\n    bindingTimer->setInterval(1000);\n    connect(bindingTimer, SIGNAL(timeout()),\n            this, SLOT(bindingTimerFired()));\n\n    bindingTableReaderTimer = new QTimer(this);\n    bindingTableReaderTimer->setSingleShot(true);\n    bindingTableReaderTimer->setInterval(1000);\n    connect(bindingTableReaderTimer, SIGNAL(timeout()),\n            this, SLOT(bindingTableReaderTimerFired()));\n\n    lockGatewayTimer = new QTimer(this);\n    lockGatewayTimer->setSingleShot(true);\n    connect(lockGatewayTimer, SIGNAL(timeout()),\n            this, SLOT(lockGatewayTimerFired()));\n\n    openClientTimer = new QTimer(this);\n    openClientTimer->setSingleShot(false);\n    connect(openClientTimer, SIGNAL(timeout()),\n            this, SLOT(openClientTimerFired()));\n    openClientTimer->start(1000);\n\n    quint16 wsPort = deCONZ::appArgumentNumeric(QLatin1String(\"--ws-port\"), gwConfig[\"websocketport\"].toUInt());\n    webSocketServer = new WebSocketServer(this, wsPort);\n    gwConfig[\"websocketport\"] = webSocketServer->port();\n\n    initNetworkInfo();\n    initUpnpDiscovery();\n\n    initAuthentication();\n    initInternetDicovery();\n    initSchedules();\n    initPermitJoin();\n    initOtau();\n    initTouchlinkApi();\n    initChangeChannelApi();\n    initResetDeviceApi();\n    initFirmwareUpdate();\n    //restoreWifiState();\n    needRuleCheck = RULE_CHECK_DELAY;\n\n    QTimer::singleShot(3000, this, SLOT(initWiFi()));\n\n    connect(pollManager, &PollManager::done, this, &DeRestPluginPrivate::pollNextDevice);\n\n    auto *deviceTick = new DeviceTick(m_devices, this);\n    connect(eventEmitter, &EventEmitter::eventNotify, deviceTick, &DeviceTick::handleEvent);\n    connect(deviceTick, &DeviceTick::eventNotify, eventEmitter, &EventEmitter::enqueueEvent);\n\n    const deCONZ::Node *node;\n    if (apsCtrl && apsCtrl->getNode(0, &node) == 0)\n    {\n        addLightNode(node);\n    }\n\n    const QStringList buttonMapLocations = {\n        deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation) + QLatin1String(\"/devices/button_maps.json\")\n#ifdef Q_OS_LINUX\n        , \"/usr/share/deCONZ/devices/button_maps.json\"\n#endif\n#ifdef Q_OS_WIN\n        , qApp->applicationDirPath() + QLatin1String(\"/../devices/button_maps.json\")\n#endif\n#if defined (__APPLE__)\n        , qApp->applicationDirPath() + QLatin1String(\"/../Resources/devices/button_maps.json\")\n#endif\n    };\n\n    for (const auto &path : buttonMapLocations)\n    {\n        if (!QFile::exists(path))\n        {\n            continue;\n        }\n\n        QStringList requiredJsonObjects = {\"buttons\", \"buttonActions\", \"clusters\", \"commands\", \"maps\"};\n        QJsonDocument buttonMapsDoc = readButtonMapJson(path);\n\n        if (checkRootLevelObjectsJson(buttonMapsDoc, requiredJsonObjects))\n        {\n            btnMapClusters = loadButtonMapClustersJson(buttonMapsDoc);\n            btnMapClusterCommands = loadButtonMapCommadsJson(buttonMapsDoc);\n            buttonMaps = loadButtonMapsJson(buttonMapsDoc, btnMapClusters, btnMapClusterCommands);\n            buttonMeta = loadButtonMetaJson(buttonMapsDoc, buttonMaps);\n            buttonProductMap = loadButtonMapModelIdsJson(buttonMapsDoc, buttonMaps);\n            break; // only load once\n        }\n    }\n}\n\n/*! Deconstructor for pimpl.\n */\nDeRestPluginPrivate::~DeRestPluginPrivate()\n{\n    plugin = nullptr;\n    if (inetDiscoveryManager)\n    {\n        inetDiscoveryManager->deleteLater();\n        inetDiscoveryManager = 0;\n    }\n    delete deviceJs;\n    deviceJs = nullptr;\n    eventEmitter = nullptr;\n    ScratchMemDestroy();\n}\n\nDeRestPluginPrivate *DeRestPluginPrivate::instance()\n{\n    DBG_Assert(plugin);\n    return plugin;\n}\n\nvoid DeRestPluginPrivate::apsdeDataIndicationDevice(const deCONZ::ApsDataIndication &ind, Device *device)\n{\n    if (!device)\n    {\n        return;\n    }\n\n    if (!device->item(RCapSleeper)->toBool())\n    {\n        auto *item = device->item(RStateReachable);\n        if (!item->toBool())\n        {\n            item->setValue(true);\n            enqueueEvent(Event(device->prefix(), item->descriptor().suffix, 0, device->key()));\n        }\n    }\n\n    deCONZ::ZclFrame zclFrame;\n\n    if (ind.profileId() == HA_PROFILE_ID || ind.profileId() == ZLL_PROFILE_ID)\n    {\n        QDataStream stream(ind.asdu());\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.readFromStream(stream);\n\n        if (!zclFrame.isProfileWideCommand())\n        {\n            if (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient)\n            {\n                // Keep Device poll state machine happy for non profile wide responses.\n                // There a response is assumed by 'server to client' direction.\n                // The status is set to SUCCESS since not all responses contain a status field.\n                enqueueEvent(Event(device->prefix(), REventZclResponse, EventZclResponsePack(ind.clusterId(), zclFrame.sequenceNumber(), deCONZ::ZclSuccessStatus), device->key()));\n            }\n        }\n        else if (zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId && zclFrame.payload().size() >= 3)\n        {\n            const auto status = quint8(zclFrame.payload().at(2));\n            enqueueEvent(Event(device->prefix(), REventZclResponse, EventZclResponsePack(ind.clusterId(), zclFrame.sequenceNumber(), status), device->key()));\n        }\n        else if (zclFrame.commandId() == deCONZ::ZclConfigureReportingResponseId && zclFrame.payload().size() >= 1)\n        {\n            const auto status = quint8(zclFrame.payload().at(0));\n            enqueueEvent(Event(device->prefix(), REventZclResponse, EventZclResponsePack(ind.clusterId(), zclFrame.sequenceNumber(), status), device->key()));\n        }\n        else if (zclFrame.commandId() == deCONZ::ZclReadReportingConfigResponseId)\n        {\n            const auto rsp = ZCL_ParseReadReportConfigurationRsp(ind, zclFrame);\n            enqueueEvent(EventWithData(device->prefix(), REventZclReadReportConfigResponse, rsp, device->key()));\n        }\n    }\n    else if (ind.profileId() == ZDP_PROFILE_ID)\n    {\n        if (ind.clusterId() == ZDP_ACTIVE_ENDPOINTS_RSP_CLID)\n        {\n            enqueueEvent(Event(device->prefix(), REventActiveEndpoints, 0, device->key()));\n        }\n        else if (ind.clusterId() == ZDP_NODE_DESCRIPTOR_RSP_CLID)\n        {\n            enqueueEvent(Event(device->prefix(), REventNodeDescriptor, 0, device->key()));\n        }\n        else if (ind.clusterId() == ZDP_SIMPLE_DESCRIPTOR_RSP_CLID)\n        {\n            enqueueEvent(Event(device->prefix(), REventSimpleDescriptor, 0, device->key()));\n        }\n        else if (ind.clusterId() == ZDP_MGMT_BIND_RSP_CLID)\n        {\n            enqueueEvent(EventWithData(device->prefix(), REventZdpMgmtBindResponse, ind.asdu().constData(), ind.asdu().size(), device->key()));\n        }\n\n        if ((ind.clusterId() & 0x8000) != 0 && ind.asdu().size() >= 2)\n        {\n            enqueueEvent(Event(device->prefix(), REventZdpResponse, EventZdpResponsePack(ind.asdu().at(0), ind.asdu().at(1)), device->key()));\n        }\n        return;\n    }\n    else\n    {\n        return; // only ZCL and ZDP for now\n    }\n\n    int awake = 0;\n    auto resources = device->subDevices();\n    resources.push_back(device); // self reference\n\n    for (auto &r : resources)\n    {\n        if (ind.clusterId() == BASIC_CLUSTER_ID && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n        { }\n        else if (!device->managed())\n        {\n            if (r->prefix() == RSensors)\n            {\n                // keep sensors reachable which are not handled in updateSensorNode()\n                ResourceItem *reachable = r->item(RConfigReachable);\n\n                if (reachable)\n                {\n                    Sensor *s = static_cast<Sensor*>(r);\n                    Q_ASSERT(s);\n                    s->rx();\n                    if (!reachable->toBool())\n                    {\n                        reachable->setValue(true);\n                        enqueueEvent(Event(r->prefix(), reachable->descriptor().suffix, r->item(RAttrId)->toString(), reachable, device->key()));\n                    }\n                }\n            }\n            continue;\n        }\n\n        {   // TODO this is too messy\n            ResourceItem *reachable = nullptr;\n            if (r->prefix() == RLights)\n            {\n                LightNode *l = static_cast<LightNode*>(r);\n                l->rx();\n                reachable = r->item(RStateReachable);\n            }\n            else if (r->prefix() == RSensors)\n            {\n                Sensor *s = static_cast<Sensor*>(r);\n                s->rx();\n                reachable = r->item(RConfigReachable);\n            }\n\n            if (reachable && !reachable->toBool())\n            {\n                reachable->setValue(true);\n                enqueueEvent(Event(r->prefix(), reachable->descriptor().suffix, r->item(RAttrId)->toString(), reachable, device->key()));\n            }\n        }\n\n        // for state/* changes, only emit the state/lastupdated event once for the first state/* item.\n        bool eventLastUpdatedEmitted = false;\n\n        DeviceJs::instance()->clearItemsSet();\n\n        for (int i = 0; i < r->itemCount(); i++)\n        {\n            ResourceItem *item = r->itemForIndex(i);\n            DBG_Assert(item);\n            if (!item)\n            {\n                continue;\n            }\n\n            ParseFunction_t parseFunction = item->parseFunction();\n            const auto &ddfItem = DDF_GetItem(item);\n\n            // First call\n            // Init the parse function. Later on this needs to be done by the device description loader.\n            if (!parseFunction && ddfItem.isValid())\n            {\n                parseFunction = DA_GetParseFunction(ddfItem.parseParameters);\n            }\n\n            if (!parseFunction)\n            {\n                if (!ddfItem.parseParameters.isNull())\n                {\n                    DBG_Printf(DBG_INFO, \"parse function for %s not found: %s\\n\", item->descriptor().suffix, qPrintable(ddfItem.parseParameters.toString()));\n                }\n                continue;\n            }\n\n            if (parseFunction(r, item, ind, zclFrame, ddfItem.parseParameters))\n            {\n            }\n        }\n\n        auto *idItem = r->item(RAttrId);\n        if (!idItem)\n        {\n            idItem = r->item(RAttrUniqueId);\n        }\n\n        if (idItem)\n        {\n            for (ResourceItem *i : DeviceJs::instance()->itemsSet())\n            {\n                i->setNeedStore();\n                if (i->awake())\n                {\n                    awake++;\n                }\n\n                const bool push = i->pushOnSet() || (i->pushOnChange() && i->lastChanged() == i->lastSet());\n\n                enqueueEvent(Event(r->prefix(), i->descriptor().suffix, idItem->toString(), i, device->key()));\n                if (push && i->lastChanged() == i->lastSet())\n                {\n                    const char *itemSuffix = i->descriptor().suffix;\n                    if (itemSuffix[0] == 's') // state/*\n                    {\n                        // don't store state items within APS indication handler as this can block for >1 sec on slow systems\n                    }\n                    else if (r->prefix() != RDevices)\n                    {\n                        DBG_MEASURE_START(DB_StoreSubDeviceItem);\n                        DB_StoreSubDeviceItem(r, i);\n                        DBG_MEASURE_END(DB_StoreSubDeviceItem);\n                    }\n                    else if (r->prefix() == RDevices && ind.clusterId() == BASIC_CLUSTER_ID)\n                    {\n                        if (itemSuffix == RAttrAppVersion)\n                        {\n                            DB_ZclValue dbVal;\n                            dbVal.deviceId = device->deviceId();\n                            dbVal.endpoint = ind.srcEndpoint();\n                            dbVal.clusterId = ind.clusterId();\n                            dbVal.attrId = 0x0001;\n                            dbVal.data = i->toNumber();\n                            DB_StoreZclValue(&dbVal);\n                        }\n                    }\n                    else if (r->prefix() == RDevices && ind.clusterId() == IAS_ZONE_CLUSTER_ID)\n                    {\n                        if (itemSuffix == RAttrZoneType)\n                        {\n                            DB_ZclValue dbVal;\n                            dbVal.deviceId = device->deviceId();\n                            dbVal.endpoint = ind.srcEndpoint();\n                            dbVal.clusterId = ind.clusterId();\n                            dbVal.attrId = 0x0001;\n                            dbVal.data = i->toNumber();\n                            DB_StoreZclValue(&dbVal);\n                        }\n                    }\n                }\n\n                if (!eventLastUpdatedEmitted && i->descriptor().suffix[0] == 's') // state/*\n                {\n                    ResourceItem *lastUpdated = r->item(RStateLastUpdated);\n                    if (lastUpdated)\n                    {\n                        eventLastUpdatedEmitted = true;\n                        lastUpdated->setValue(i->lastSet());\n                        enqueueEvent(Event(r->prefix(), lastUpdated->descriptor().suffix, idItem->toString(), lastUpdated, device->key()));\n                    }\n                }\n            }\n        }\n    }\n\n    if (ind.profileId() == ZDP_PROFILE_ID)\n    {\n\n    }\n    else if (ind.clusterId() == POWER_CONFIGURATION_CLUSTER_ID) // genral assumption that the device is awake\n    {\n        awake++;\n    }\n\n    if (awake > 0)\n    {\n        enqueueEvent(Event(device->prefix(), REventAwake, 0, device->key()));\n    }\n}\n\n/*! APSDE-DATA.indication callback.\n    \\param ind - the indication primitive\n    \\note Will be called from the main application for each incoming indication.\n    Any filtering for nodes, profiles, clusters must be handled by this plugin.\n */\nvoid DeRestPluginPrivate::apsdeDataIndication(const deCONZ::ApsDataIndication &ind)\n{\n    Q_Q(DeRestPlugin);\n    if (!q->pluginActive())\n    {\n        return;\n    }\n\n    deCONZ::ZclFrame zclFrame;\n    ZclDefaultResponder zclDefaultResponder(&apsCtrlWrapper, ind, zclFrame);\n\n    if (DBG_IsEnabled(DBG_MEASURE))\n    {\n        DBG_Printf(DBG_INFO, \"R stats, str: %u, num: %u, item: %u\\n\", rStats.toString, rStats.toNumber, rStats.item);\n        rStats = { };\n    }\n\n    auto *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n\n    apsdeDataIndicationDevice(ind, device);\n\n    if ((ind.profileId() == HA_PROFILE_ID) || (ind.profileId() == ZLL_PROFILE_ID))\n    {\n        const bool devManaged = device && device->managed();\n        {\n            QDataStream stream(ind.asdu());\n            stream.setByteOrder(QDataStream::LittleEndian);\n            zclFrame.readFromStream(stream);\n        }\n\n        switch (ind.clusterId())\n        {\n        case GROUP_CLUSTER_ID:\n            handleGroupClusterIndication(ind, zclFrame);\n            break;\n\n        case SCENE_CLUSTER_ID:\n            handleSceneClusterIndication(ind, zclFrame);\n            handleClusterIndicationGateways(ind, zclFrame);\n            break;\n\n        case OTAU_CLUSTER_ID:\n            otauDataIndication(ind, zclFrame, device);\n            break;\n\n        case COMMISSIONING_CLUSTER_ID:\n            handleCommissioningClusterIndication(ind, zclFrame);\n            break;\n\n        case LEVEL_CLUSTER_ID:\n            handleClusterIndicationGateways(ind, zclFrame);\n            break;\n\n        case ONOFF_CLUSTER_ID:\n            if (!DEV_TestStrict())\n            {\n                handleOnOffClusterIndication(ind, zclFrame);\n                handleClusterIndicationGateways(ind, zclFrame);\n            }\n            break;\n\n        case METERING_CLUSTER_ID:\n            if (!DEV_TestStrict() && !devManaged) { handleSimpleMeteringClusterIndication(ind, zclFrame); }\n            break;\n\n        case ELECTRICAL_MEASUREMENT_CLUSTER_ID:\n            if (!DEV_TestStrict() && !devManaged) { handleElectricalMeasurementClusterIndication(ind, zclFrame); }\n            break;\n\n        case IAS_ZONE_CLUSTER_ID:\n            handleIasZoneClusterIndication(ind, zclFrame);\n            break;\n\n        case IAS_ACE_CLUSTER_ID:\n            IAS_IasAceClusterIndication(ind, zclFrame, alarmSystems.get(), apsCtrlWrapper);\n            break;\n\n        case POWER_CONFIGURATION_CLUSTER_ID:\n            if (!DEV_TestStrict() && !devManaged) { handlePowerConfigurationClusterIndication(ind, zclFrame); }\n            break;\n\n        case XAL_CLUSTER_ID:\n            handleXalClusterIndication(ind, zclFrame);\n            break;\n\n        case TIME_CLUSTER_ID:\n            if (!DEV_TestStrict()) { handleTimeClusterIndication(ind, zclFrame); }\n            break;\n\n        case WINDOW_COVERING_CLUSTER_ID:\n            if (!DEV_TestStrict() && !devManaged) { handleWindowCoveringClusterIndication(ind, zclFrame); }\n            break;\n\n        case TUYA_CLUSTER_ID:\n            // Tuya manfacture cluster:\n            handleTuyaClusterIndication(ind, zclFrame, device);\n            break;\n\n        case THERMOSTAT_CLUSTER_ID:\n            if (!DEV_TestStrict()) { handleThermostatClusterIndication(ind, zclFrame); }\n            break;\n\n        case BASIC_CLUSTER_ID:\n            if (!DEV_TestStrict()) { handleBasicClusterIndication(ind, zclFrame); }\n            break;\n\n        case APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID:\n            handleApplianceAlertClusterIndication(ind, zclFrame);\n            break;\n\n        case THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID:\n            if (!DEV_TestStrict() && !devManaged) { handleThermostatUiConfigurationClusterIndication(ind, zclFrame); }\n            break;\n\n        case IDENTIFY_CLUSTER_ID:\n            handleIdentifyClusterIndication(ind, zclFrame);\n            break;\n\n        case BOSCH_AIR_QUALITY_CLUSTER_ID: // Bosch Air quality sensor\n            if (!DEV_TestStrict()) { handleAirQualityClusterIndication(ind, zclFrame); }\n            break;\n\n        case POLL_CONTROL_CLUSTER_ID:\n            handlePollControlIndication(ind, zclFrame);\n            break;\n\n        case FAN_CONTROL_CLUSTER_ID:\n            handleFanControlClusterIndication(ind, zclFrame);\n            break;\n\n        case DOOR_LOCK_CLUSTER_ID:\n            DBG_Printf(DBG_INFO, \"Door lock debug 0x%016llX, data 0x%08X \\n\", ind.srcAddress().ext(), zclFrame.commandId() );\n            break;\n\n        case XIAOMI_CLUSTER_ID:\n            if (!DEV_TestStrict()) { handleXiaomiLumiClusterIndication(ind, zclFrame); }\n            break;\n\n        case OCCUPANCY_SENSING_CLUSTER_ID:\n            if (!DEV_TestStrict()) { handleOccupancySensingClusterIndication(ind, zclFrame); }\n            break;\n\n        default:\n        {\n        }\n            break;\n        }\n\n        handleIndicationSearchSensors(ind, zclFrame);\n\n        if (ind.dstAddressMode() == deCONZ::ApsGroupAddress || ind.clusterId() == VENDOR_CLUSTER_ID || ind.clusterId() == IAS_ZONE_CLUSTER_ID || zclFrame.manufacturerCode() == VENDOR_XIAOYAN ||\n            !(zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient) ||\n            (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId))\n        {\n            Sensor *sensorNode = nullptr;\n            quint8 count = 0;\n\n            for (Sensor &sensor: sensors)\n            {\n                if (sensor.deletedState() != Sensor::StateNormal || !sensor.node())                             { continue; }\n                if (!isSameAddress(sensor.address(), ind.srcAddress()))                                         { continue; }\n                if (sensor.type() != QLatin1String(\"ZHASwitch\"))                                                { continue; }\n\n                sensorNode = &sensor;\n                count++;\n            }\n\n            if (count == 1)\n            {\n                // Only 1 switch resource for the indication address found\n            }\n            else\n            {\n                sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n            }\n\n            if (sensorNode)\n            {\n                checkSensorButtonEvent(sensorNode, ind, zclFrame);\n            }\n        }\n\n        if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n        {\n            zbConfigGood = QDateTime::currentDateTime();\n            handleZclAttributeReportIndication(ind, zclFrame);\n        }\n        else if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n        {\n            zbConfigGood = QDateTime::currentDateTime();\n        }\n        else if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclConfigureReportingResponseId)\n        {\n            handleZclConfigureReportingResponseIndication(ind, zclFrame);\n        }\n    }\n    else if (ind.profileId() == ZDP_PROFILE_ID)\n    {\n        switch (ind.clusterId())\n        {\n        case ZDP_NODE_DESCRIPTOR_CLID:\n        {\n            ZDP_HandleNodeDescriptorRequest(ind, apsCtrl);\n        }\n            break;\n\n        case ZDP_NODE_DESCRIPTOR_RSP_CLID:\n        {\n            // Safeguard to issue a 2nd active endpoint request in case the first one got MIA\n            // Temporary workaround till state machine is available (request is fired ruthless)\n            deCONZ::ApsDataRequest apsReq;\n\n            // ZDP Header\n            apsReq.dstAddress() = ind.srcAddress();\n            apsReq.setDstAddressMode(deCONZ::ApsNwkAddress);\n            apsReq.setDstEndpoint(ZDO_ENDPOINT);\n            apsReq.setSrcEndpoint(ZDO_ENDPOINT);\n            apsReq.setProfileId(ZDP_PROFILE_ID);\n            apsReq.setRadius(0);\n            apsReq.setClusterId(ZDP_ACTIVE_ENDPOINTS_CLID);\n\n            QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n            stream.setByteOrder(QDataStream::LittleEndian);\n\n            stream << zclSeq++;\n            stream << ind.srcAddress().nwk();\n\n            apsCtrlWrapper.apsdeDataRequest(apsReq);  // Fire and forget\n\n            handleNodeDescriptorResponseIndication(ind);\n            handleIndicationSearchSensors(ind, zclFrame);\n        }\n            break;\n\n        case ZDP_SIMPLE_DESCRIPTOR_RSP_CLID:\n        case ZDP_ACTIVE_ENDPOINTS_RSP_CLID:\n        {\n            handleIndicationSearchSensors(ind, zclFrame);\n        }\n            break;\n\n        case ZDP_DEVICE_ANNCE_CLID:\n        {\n            handleDeviceAnnceIndication(ind);\n            handleIndicationSearchSensors(ind, zclFrame);\n        }\n            break;\n\n        case ZDP_IEEE_ADDR_CLID:\n        {\n            handleIeeeAddressReqIndication(ind);\n        }\n            break;\n\n        case ZDP_NWK_ADDR_CLID:\n        {\n            handleNwkAddressReqIndication(ind);\n        }\n            break;\n\n        case ZDP_MGMT_LQI_RSP_CLID:\n        {\n            handleMgmtLqiRspIndication(ind);\n        }\n            break;\n\n        case ZDP_MGMT_BIND_RSP_CLID:\n            handleMgmtBindRspIndication(ind);\n            break;\n\n        case ZDP_BIND_RSP_CLID:\n        case ZDP_UNBIND_RSP_CLID:\n            handleBindAndUnbindRspIndication(ind);\n            break;\n\n        case ZDP_MGMT_LEAVE_RSP_CLID:\n            handleMgmtLeaveRspIndication(ind);\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    eventEmitter->process();\n}\n\n/*! APSDE-DATA.confirm callback.\n    \\param conf - the confirm primitive\n    \\note Will be called from the main application for each incoming confirmation,\n    even if the APSDE-DATA.request was not issued by this plugin.\n */\nvoid DeRestPluginPrivate::apsdeDataConfirm(const deCONZ::ApsDataConfirm &conf)\n{\n    pollManager->apsdeDataConfirm(conf);\n    DA_ApsRequestConfirmed(conf);\n\n    if (conf.dstAddress().hasExt())\n    {\n        const int num = EventApsConfirmPack(conf.id(), conf.status());\n        enqueueEvent(Event(RDevices, REventApsConfirm, num, conf.dstAddress().ext()));\n    }\n\n    std::list<TaskItem>::iterator i = runningTasks.begin();\n    std::list<TaskItem>::iterator end = runningTasks.end();\n\n    for (;i != end; ++i)\n    {\n        TaskItem &task = *i;\n\n        if (task.req.id() != conf.id())\n        {\n            continue;\n        }\n\n        if (conf.dstAddressMode() == deCONZ::ApsNwkAddress &&\n            task.req.dstAddressMode() == deCONZ::ApsNwkAddress &&\n            !isSameAddress(conf.dstAddress(), task.req.dstAddress()))\n        {\n            DBG_Printf(DBG_INFO, \"warn APSDE-DATA.confirm: 0x%02X nwk mismatch\\n\", conf.id());\n            //continue;\n        }\n\n        QDateTime now = QDateTime::currentDateTime();\n\n        if (conf.status() != deCONZ::ApsSuccessStatus)\n        {\n            DBG_Printf(DBG_INFO, \"0x%016llX error APSDE-DATA.confirm: 0x%02X on task\\n\", task.req.dstAddress().ext(), conf.status());\n        }\n        else if (task.req.dstAddressMode() == deCONZ::ApsGroupAddress &&\n                 (task.req.clusterId() == ONOFF_CLUSTER_ID ||\n                  task.req.clusterId() == LEVEL_CLUSTER_ID ||\n                  task.req.clusterId() == COLOR_CLUSTER_ID))\n        {\n            quint16 groupId = task.req.dstAddress().group();\n            quint16 attrId = 0x0000;\n            if (task.req.clusterId() == COLOR_CLUSTER_ID)\n            {\n                attrId = 0x0003; // currentX\n            }\n\n            for (LightNode &l : nodes)\n            {\n                if (gwPermitJoinDuration > 0)\n                {\n                    break;\n                }\n\n                if (!l.isAvailable() ||\n                    !l.lastRx().isValid() /*||\n                    l.manufacturerCode() == VENDOR_IKEA ||\n                    l.manufacturerCode() == VENDOR_OSRAM ||\n                    l.manufacturerCode() == VENDOR_OSRAM_STACK ||\n                    l.manufacturer().startsWith(QLatin1String(\"IKEA\")) ||\n                    l.manufacturer().startsWith(QLatin1String(\"OSRAM\"))*/)\n                {\n                    continue;\n                }\n\n\n                // fast poll lights which don't support or have active ZCL reporting\n                const NodeValue &val = l.getZclValue(ONOFF_CLUSTER_ID, attrId);\n                if ((!val.timestampLastReport.isValid() || val.timestampLastReport.secsTo(now) > (60 * 5)) &&\n                    isLightNodeInGroup(&l, groupId))\n                {\n                    DBG_Printf(DBG_INFO_L2, \"\\t0x%016llX force poll\\n\", l.address().ext());\n                    queuePollNode(&l);\n                }\n            }\n        }\n        else if (task.lightNode && gwPermitJoinDuration == 0)\n        {\n            switch (task.taskType)\n            {\n            case TaskSendOnOffToggle:\n            case TaskSetLevel:\n            case TaskSetXyColor:\n            case TaskSetEnhancedHue:\n            case TaskSetSat:\n            case TaskSetColorTemperature:\n            case TaskSetHue:\n            case TaskSetHueAndSaturation:\n            case TaskIncColorTemperature:\n                {\n                    DBG_Printf(DBG_INFO, \"\\t0x%016llX force poll (2)\\n\", task.lightNode->address().ext());\n                    queuePollNode(task.lightNode);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (DBG_IsEnabled(DBG_INFO_L2))\n        {\n            DBG_Printf(DBG_INFO_L2, \"Erase task req-id: %u, type: %d zcl seqno: %u send time %d, profileId: 0x%04X, clusterId: 0x%04X\\n\",\n                       task.req.id(), task.taskType, task.zclFrame.sequenceNumber(), idleTotalCounter - task.sendTime, task.req.profileId(), task.req.clusterId());\n        }\n        runningTasks.erase(i);\n        processTasks();\n        break;\n    }\n\n    if (channelChangeApsRequestId == conf.id() && channelChangeState == CC_WaitConfirm)\n    {\n        channelChangeSendConfirm(conf.status() == deCONZ::ApsSuccessStatus);\n    }\n    else if (resetDeviceApsRequestId == conf.id() && resetDeviceState == ResetWaitConfirm)\n    {\n        resetDeviceSendConfirm(conf.status() == deCONZ::ApsSuccessStatus);\n    }\n\n    if (handleMgmtBindRspConfirm(conf))\n    {\n        return;\n    }\n}\n\nvoid DeRestPluginPrivate::apsdeDataRequestEnqueued(const deCONZ::ApsDataRequest &req)\n{\n    DA_ApsRequestEnqueued(req);\n}\n\n/*! Process incoming green power button event.\n    \\param ind - the data indication\n */\nvoid DeRestPluginPrivate::gpProcessButtonEvent(const deCONZ::GpDataIndication &ind)\n{\n    /*\n        PTM 215Z DEMO\n\n        A0 B0\n        A1 B1\n\n        DeviceId 0x02 (On/Off Switch)\n\n\n             A0,B0 Press    0x64 Press   2 of 2\n             A0,B0 Release  0x65 Release 2 of 2\n\n        A0 0x10 Scene0      B0 0x22 Toggle\n        A1 0x11 Scene1      B1 0x12 Scene2\n\n             A1,B1 Press    0x62 Press   1 of 2\n             A1,B1 Release  0x63 Release 1 of 2\n\n     */\n\n    /*\n        Friends of Hue switch\n\n        A0 B0\n        A1 B1\n\n        DeviceId 0x02 (On/Off Switch)\n\n\n             A0,B0 Press    0x64 Press   2 of 2\n             A0,B0 Release  0x65 Release 2 of 2\n\n        A0 0x10 Press   Scene0      B0 0x13 Press   Scene 3\n        A0 0x14 Release Scene4      B0 0x17 Release Scene 7\n\n        A1 0x11 Press   Scene1      B1 0x12 Press   Scene 2\n        A1 0x15 Release Scene5      B1 0x16 Release Scene 6\n\n             A1,B1 Press    0x62 Press   1 of 2\n             A1,B1 Release  0x63 Release 1 of 2\n\n     */\n\n    Sensor *sensor = getSensorNodeForAddress(ind.gpdSrcId());\n    ResourceItem *item = sensor ? sensor->item(RStateButtonEvent) : nullptr;\n\n    if (!sensor || !item || sensor->deletedState() == Sensor::StateDeleted)\n    {\n        return;\n    }\n    sensor->rx();\n\n    {\n        ResourceItem *frameCounter = sensor->item(RStateGPDFrameCounter);\n        if (frameCounter)\n        {\n            frameCounter->setValue(ind.frameCounter());\n        }\n    }\n\n    quint32 btn = ind.gpdCommandId();\n    if (sensor->modelId() == QLatin1String(\"FOHSWITCH\"))\n    {\n        // Map the command to the mapped button and action.\n        // PTM215ZE Friends of Hue switch.\n        const quint32 buttonMapPTM215ZE[] = {\n            0x12, S_BUTTON_1, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x13, S_BUTTON_1, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x14, S_BUTTON_2, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x15, S_BUTTON_2, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x18, S_BUTTON_3, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x19, S_BUTTON_3, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x22, S_BUTTON_4, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x23, S_BUTTON_4, S_BUTTON_ACTION_SHORT_RELEASED,\n            0\n        };\n\n        // PTM216Z Friends of Hue switch.\n        // CommandId: 0x69 Push, 0x6A Release\n        // Buttons: 0000 0001 A0\n        //          0000 0010 A1\n        //          0000 0100 B0\n        //          0000 1000 B1\n        //          0001 0000 Energy Bar\n        const quint32 buttonMapPTM216Z[] = {\n            0x6901, S_BUTTON_1, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6902, S_BUTTON_2, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6904, S_BUTTON_3, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6908, S_BUTTON_4, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x690A, S_BUTTON_5, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6905, S_BUTTON_6, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6906, S_BUTTON_7, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x6909, S_BUTTON_8, S_BUTTON_ACTION_INITIAL_PRESS,\n            0\n        };\n\n        // Generic Friends of Hue switch.\n        const quint32 buttonMapFOHSWITCH[] = {\n            0x10, S_BUTTON_1, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x14, S_BUTTON_1, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x11, S_BUTTON_2, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x15, S_BUTTON_2, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x13, S_BUTTON_3, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x17, S_BUTTON_3, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x12, S_BUTTON_4, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x16, S_BUTTON_4, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x64, S_BUTTON_5, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x65, S_BUTTON_5, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x62, S_BUTTON_6, S_BUTTON_ACTION_INITIAL_PRESS,\n            0x63, S_BUTTON_6, S_BUTTON_ACTION_SHORT_RELEASED,\n            0x68, S_BUTTON_7, S_BUTTON_ACTION_INITIAL_PRESS,\n            0xe0, S_BUTTON_7, S_BUTTON_ACTION_SHORT_RELEASED,\n            0\n        };\n\n        const quint32* buttonMap = 0;\n        // Determine which button map to use.\n        if (sensor->swVersion() == QLatin1String(\"PTM215ZE\"))\n        {\n            buttonMap = buttonMapPTM215ZE;\n        }\n        else if (sensor->swVersion() == QLatin1String(\"PTM216Z\") && !ind.payload().isEmpty())\n        {\n            btn <<= 8;\n            btn |= static_cast<quint32>(ind.payload()[0]) & 0xff; // actual buttons in payload\n            buttonMap = buttonMapPTM216Z;\n        }\n        else\n        {\n            buttonMap = buttonMapFOHSWITCH;\n        }\n\n        quint32 btnMapped = 0;\n        quint32 btnAction = 0;\n        for (int i = 0; buttonMap[i] != 0; i += 3)\n        {\n            if (buttonMap[i] == btn)\n            {\n                btnMapped = buttonMap[i + 1];\n                btnAction = buttonMap[i + 2];\n                break;\n            }\n        }\n\n        if (buttonMap == buttonMapPTM216Z && ind.gpdCommandId() == 0x6A)\n        {\n            // Release event has no button payload, use the former press event button\n            btnAction = S_BUTTON_ACTION_SHORT_RELEASED;\n            btnMapped = item->toNumber() & ~0x3; // without action\n        }\n\n        const QDateTime now = QDateTime::currentDateTime();\n        if (btnMapped == 0)\n        {\n            // not found\n        }\n        else if (btnAction == S_BUTTON_ACTION_INITIAL_PRESS)\n        {\n            sensor->durationDue = now.addMSecs(500); // enable generation of x001 (hold)\n            checkSensorsTimer->start(CHECK_SENSOR_FAST_INTERVAL);\n            btn = btnMapped + S_BUTTON_ACTION_INITIAL_PRESS;\n        }\n        else if (btnAction == S_BUTTON_ACTION_SHORT_RELEASED)\n        {\n            sensor->durationDue = QDateTime(); // disable generation of x001 (hold)\n            const quint32 action = item->toNumber() & 0x03; // last action\n\n            if (action == S_BUTTON_ACTION_HOLD || // hold already triggered -> long release\n                item->lastSet().msecsTo(now) > 400) // over 400 ms since initial press? -> long release\n            {\n                btn = btnMapped + S_BUTTON_ACTION_LONG_RELEASED;\n            }\n            else\n            {\n                btn = btnMapped + S_BUTTON_ACTION_SHORT_RELEASED;\n            }\n        }\n        else if (btn == 0x68) // aka ShortPress2Of2\n        {\n            // finish commissioning by pressing button 2000 and 3000 simultaneously\n            btn = btnMapped + S_BUTTON_ACTION_SHORT_RELEASED;\n        }\n        else if (btn == 0xe0) // aka commissioning\n        {\n            btn = btnMapped + S_BUTTON_ACTION_LONG_RELEASED;\n        }\n    }\n\n    updateSensorEtag(sensor);\n    sensor->setNeedSaveDatabase(true);\n    sensor->updateStateTimestamp();\n    item->setValue(btn);\n    DBG_Printf(DBG_ZGP, \"ZGP 0x%08X button %u %s\\n\", ind.gpdSrcId(), item->toNumber(), qPrintable(sensor->modelId()));\n    Event e(RSensors, RStateButtonEvent, sensor->id(), item);\n    enqueueEvent(e);\n    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n}\n\n/*! Returns the number of tasks for a specific address.\n    \\param address - the destination address\n */\nint DeRestPluginPrivate::taskCountForAddress(const deCONZ::Address &address)\n{\n    int count = 0;\n\n    {\n        std::list<TaskItem>::const_iterator i = tasks.begin();\n        std::list<TaskItem>::const_iterator end = tasks.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->req.dstAddress() == address)\n            {\n                count++;\n            }\n\n        }\n    }\n\n    {\n        std::list<TaskItem>::const_iterator i = runningTasks.begin();\n        std::list<TaskItem>::const_iterator end = runningTasks.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->req.dstAddress() == address)\n            {\n                count++;\n            }\n\n        }\n    }\n\n    return count;\n}\n\n/*! Process incoming green power data frame.\n    \\param ind - the data indication\n */\nvoid DeRestPluginPrivate::gpDataIndication(const deCONZ::GpDataIndication &ind)\n{\n    switch (ind.gpdCommandId())\n    {\n    case deCONZ::GpCommandIdScene0:\n    case deCONZ::GpCommandIdScene1:\n    case deCONZ::GpCommandIdScene2:\n    case deCONZ::GpCommandIdScene3:\n    case deCONZ::GpCommandIdScene4:\n    case deCONZ::GpCommandIdScene5:\n    case deCONZ::GpCommandIdScene6:\n    case deCONZ::GpCommandIdScene7:\n    case deCONZ::GpCommandIdScene8:\n    case deCONZ::GpCommandIdScene9:\n    case deCONZ::GpCommandIdScene10:\n    case deCONZ::GpCommandIdScene11:\n    case deCONZ::GpCommandIdScene12:\n    case deCONZ::GpCommandIdScene13:\n    case deCONZ::GpCommandIdScene14:\n    case deCONZ::GpCommandIdScene15:\n    case deCONZ::GpCommandIdOn:\n    case deCONZ::GpCommandIdOff:\n    case deCONZ::GpCommandIdToggle:\n    case deCONZ::GpCommandIdRelease:\n    case deCONZ::GpCommandIdPress1Of1:\n    case deCONZ::GpCommandIdRelease1Of1:\n    case deCONZ::GpCommandIdPress1Of2:\n    case deCONZ::GpCommandIdRelease1Of2:\n    case deCONZ::GpCommandIdPress2Of2:\n    case deCONZ::GpCommandIdRelease2Of2:\n    case deCONZ::GpCommandIdShortPress1Of1:\n    case deCONZ::GpCommandIdShortPress1Of2:\n    case deCONZ::GpCommandIdShortPress2Of2:\n    case 0x69: // TODO replace with enum in later version\n    case 0x6A:\n    {\n        gpProcessButtonEvent(ind);\n    }\n        break;\n\n    case deCONZ::GpCommandIdCommissioning:\n    {\n        // 1    8-bit enum    GPD DeviceID\n        // 1    8-bit bmp     Options\n        // 0/1  8-bit bmp     Extended Options\n        // 0/16 Security Key  GPD Key\n        // 0/4  u32           GPD Key MIC\n        // 0/4  u32           GPD outgoing counter\n\n        // Philips Hue Tap\n        // 0x02               GPD DeviceID\n        // 0x81               Options (MAC Sequence number, extended options field)\n        // 0xF2               Extended Options Field: (Key Type: Individual, out of the box GPD key, GPD Key Present, GPD Key Encryption, GPD Outgoing present)\n        // 16 Security Key  GPD Key\n        // 4  u32           GPD Key MIC\n        // 4  u32           GPD outgoing counter\n\n        // Vimar (Friends of Hue) 4 button 03906\n        // Note 1: Niko and Busch-Jaeger Friends of Hue switches use the same module.\n        // Note 2: Hue bridge uses modelid FOHSWITCH for Friends of Hue switches.\n        // 0x02               GPD DeviceID\n        // 0xC5               Options (MAC Sequence number, application information present, fixed location, extended options field)\n        // 0xF2               Extended Options Field: (Key Type: Individual, out of the box GPD key, GPD Key Present, GPD Key Encryption, GPD Outgoing present)\n        // 16   Security Key  GPD Key\n        // 4    u32           GPD Key MIC\n        // 4    u32           GPD outgoing counter\n        // 0x04               ApplicationInformation (GPD commands are present)\n        // ManufacturerSpecific (18 byte)\n        // Number of GPD commands (1 byte): 0x11 (17)\n        // GPD CommandID list (17 byte): 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x22, 0x60, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68\n\n        // Illumra (ZBT-S1AWH and ZBT-S2AWH)\n        // Uses the more advanced PTM 215ZE module\n        // 0x02               GPD DeviceID\n        // 0x81               Options (MAC Sequence number, application information present, extended options field)\n        // 0xF2               Extended Options Field: (Key Type: Individual, out of the box GPD key, GPD Key Present, GPD Key Encryption, GPD Outgoing present)\n        // 16   Security Key  GPD Key\n        // 4    u32           GPD Key MIC\n        // 4    u32           GPD outgoing counter\n        // Commissioning package is identical to Hue tab, however PTM 215ZE has a very different command set to above two modules\n\n        // TODO: Capture all received commands and store them in ordered string.\n        //       This way we can distinguish between the modules.\n        // Note: It would be better to map things to the usual 1002, 1001, 1003, ... buttonevents\n        //       Maybe except for Hue Tap to keep compatibility? -- Maybe.\n\n        quint8 gpdDeviceId;\n        GpKey_t gpdKey = { 0 };\n        quint32 gpdMIC = 0;\n        quint32 gpdOutgoingCounter = 0;\n        deCONZ::GPCommissioningOptions options;\n        deCONZ::GpExtCommissioningOptions extOptions;\n        uint8_t applicationInformationField = 0;\n        uint8_t numberOfGPDCommands = 0;\n        options.byte = 0;\n        extOptions.byte = 0;\n\n        QDataStream stream(ind.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        if (stream.atEnd()) { return; }\n        stream >> gpdDeviceId;\n\n        if (stream.atEnd()) { return; }\n        stream >> options.byte;\n\n        if (options.bits.extOptionsField)\n        {\n            if (stream.atEnd()) { return; }\n            stream >> extOptions.byte;\n        }\n\n        if (extOptions.bits.gpdKeyPresent)\n        {\n            for (int i = 0; i < 16; i++)\n            {\n                if (stream.atEnd()) { return; }\n                stream >> gpdKey.at(i);\n            }\n\n            if (extOptions.bits.gpdKeyEncryption)\n            {\n                // When GPDkeyPresent sub-field is set\n                // to 0b1 and the GPDkeyEncryption sub-field is set to 0b1, both fields GPDkey and GPDkeyMIC are\n                // present; the field GPDkey contains the gpdSecurityKey, of the type as indicated in the gpdSecurityKey-\n                // Type, encrypted with the default TC-LK (see A.3.3.3.3) as described inA.3.7.1.2.3; and the GPDk-\n                // eyMIC field contains the MIC for the encrypted GPD key, calculated as described in A.3.7.1.2.3.\n                if (stream.atEnd()) { return; }\n\n                gpdKey = GP_DecryptSecurityKey(ind.gpdSrcId(), gpdKey);\n\n                stream >> gpdMIC;\n            }\n        }\n\n        switch (extOptions.bits.securityLevelCapabilities)\n        {\n        case 0:\n        default:\n            break;\n        }\n\n        if (extOptions.bits.gpdOutgoingCounterPresent)\n        {\n            if (stream.atEnd()) { return; }\n            stream >> gpdOutgoingCounter;\n        }\n\n        if (options.bits.reserved & 1) // applications ID present (TODO flag not yet in deCONZ lib)\n        {\n            if (stream.atEnd()) { return; }\n            stream >> applicationInformationField;\n\n            if (applicationInformationField & 0x04)\n            {\n                if (stream.atEnd()) { return; }\n                stream >> numberOfGPDCommands;\n            }\n        }\n\n        SensorFingerprint fp;\n        fp.endpoint = GREEN_POWER_ENDPOINT;\n        fp.deviceId = gpdDeviceId;\n        fp.profileId = GP_PROFILE_ID;\n        fp.outClusters.push_back(GREEN_POWER_CLUSTER_ID);\n\n        Sensor *sensor = getSensorNodeForFingerPrint(ind.gpdSrcId(), fp, QLatin1String(\"ZGPSwitch\"));\n\n#if DECONZ_LIB_VERSION >= 0x011000\n        if (searchSensorsState == SearchSensorsActive && extOptions.bits.gpdKeyEncryption && ind.gppShortAddress() != 0)\n        {\n            if (searchSensorGppPairCounter < GP_MAX_PROXY_PAIRINGS && ind.gppLqi() >= deCONZ::GppGpdLqiModerate)\n            {\n                if (GP_SendPairing(ind.gpdSrcId(), GP_DEFAULT_PROXY_GROUP, gpdDeviceId, gpdOutgoingCounter, gpdKey, apsCtrl, zclSeq++, ind.gppShortAddress()))\n                {\n                    searchSensorGppPairCounter++;\n                }\n            }\n        }\n#endif\n\n        if (!sensor || sensor->deletedState() == Sensor::StateDeleted)\n        {\n            if (searchSensorsState != SearchSensorsActive)\n            {\n                return;\n            }\n\n            // create new sensor\n            Sensor sensorNode;\n            sensorNode.setType(\"ZGPSwitch\");\n\n            // https://github.com/dresden-elektronik/deconz-rest-plugin/pull/3285\n            // Illumra Dual Rocker Switch PTM215ZE\n            if (gpdDeviceId == deCONZ::GpDeviceIdOnOffSwitch && options.byte == 0x81 && ind.payload().size() == 27 && (ind.gpdSrcId() & 0x01500000) == 0x01500000)\n            {\n                sensorNode.setModelId(\"FOHSWITCH\");\n                sensorNode.setManufacturer(\"PhilipsFoH\");\n                sensorNode.setSwVersion(\"PTM215ZE\");\n            }\n            else if (gpdDeviceId == deCONZ::GpDeviceIdOnOffSwitch && options.byte == 0x81)\n            {\n                sensorNode.setModelId(\"ZGPSWITCH\");\n                sensorNode.setManufacturer(\"Philips\");\n                sensorNode.setSwVersion(\"1.0\");\n            }\n            else if (gpdDeviceId == deCONZ::GpDeviceIdOnOffSwitch && options.byte == 0xc5 && extOptions.byte == 0xF2 && numberOfGPDCommands == 17)\n            {\n                // FoH Outdoor switch\n                sensorNode.setModelId(\"FOHSWITCH\");\n                sensorNode.setManufacturer(\"PhilipsFoH\");\n                sensorNode.setSwVersion(\"1.0\");\n            }\n            else if (gpdDeviceId == deCONZ::GpDeviceIdOnOffSwitch && options.byte == 0xc5 && ind.payload().size() == 46)\n            {\n                // Note following can likely be removed in favor of the previous else if ()\n                sensorNode.setModelId(\"FOHSWITCH\");\n                sensorNode.setManufacturer(\"PhilipsFoH\");\n                sensorNode.setSwVersion(\"1.0\");\n            }\n            else if (gpdDeviceId == GpDeviceIdGenericSwitch && options.byte == 0x85 && extOptions.byte == 0xF2 &&\n                     ind.payload().size() == 31 &&\n                     ind.payload()[27] == 0x10 /* application info */ &&\n                     ind.payload()[29] == 0x05 /* switch type 5 button*/)\n            {\n                // This matches PTM216Z but there is no real information in the frame about the manufacturer.\n                // https://www.enocean.com/en/products/enocean_modules_24ghz/ptm-216z/\n                // srcId: 0x01520396\n\n                // Ind.payload: 07 85 f2 e0 7d 56 d0 10 e7 70 c9 95 eb af 6d 58 ad 17 0a 63 c2 27 ae dc 00 00 00\n                // 10 Application info\n                // 02 Optional data length\n                // 05 Switch type: 5 buttons\n                // 08 Button that was pressed (B1)\n\n                // Does this switch work in the Philips Hue bridge?\n                sensorNode.setModelId(\"FOHSWITCH\");\n                sensorNode.setManufacturer(\"PhilipsFoH\");\n                sensorNode.setSwVersion(\"PTM216Z\");\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"ZGP srcId: 0x%08X unsupported green power device gpdDeviceId 0x%02X, options.byte: 0x%02X, extOptions.byte: 0x%02X, numGPDCommands: %u, ind.payload: 0x%s\\n\", ind.gpdSrcId(), gpdDeviceId, options.byte, extOptions.byte, numberOfGPDCommands, qPrintable(ind.payload().toHex()));\n                return;\n            }\n\n            sensorNode.address().setExt(ind.gpdSrcId());\n            sensorNode.fingerPrint() = fp;\n            sensorNode.setUniqueId(generateUniqueId(sensorNode.address().ext(), sensorNode.fingerPrint().endpoint, GREEN_POWER_CLUSTER_ID));\n            sensorNode.setMode(Sensor::ModeNone);\n            sensorNode.rx();\n\n            ResourceItem *item;\n            item = sensorNode.item(RConfigOn);\n            item->setValue(true);\n\n            item = sensorNode.addItem(DataTypeInt32, RStateButtonEvent);\n            item->setValue(ind.gpdCommandId());\n\n            if (sensorNode.id().isEmpty())\n            {\n                openDb();\n                sensorNode.setId(QString::number(getFreeSensorId()));\n                closeDb();\n            }\n\n            if (sensorNode.name().isEmpty())\n            {\n                if (sensorNode.modelId() == QLatin1String(\"FOHSWITCH\"))\n                {\n                    sensorNode.setName(QString(\"FoH Switch %2\").arg(sensorNode.id()));\n                }\n                else\n                {\n                    sensorNode.setName(QString(\"Hue Tap %2\").arg(sensorNode.id()));\n                }\n            }\n\n            checkSensorGroup(&sensorNode);\n\n            DBG_Printf(DBG_INFO, \"SensorNode %u: %s added\\n\", sensorNode.id().toUInt(), qPrintable(sensorNode.name()));\n            updateSensorEtag(&sensorNode);\n\n            sensorNode.setNeedSaveDatabase(true);\n            sensorNode.setHandle(R_CreateResourceHandle(&sensorNode, sensors.size()));\n            sensors.push_back(sensorNode);\n\n            sensor = &sensors.back();\n\n            Event e(RSensors, REventAdded, sensorNode.id());\n            enqueueEvent(e);\n            queSaveDb(DB_SENSORS , DB_SHORT_SAVE_DELAY);\n\n            needRuleCheck = RULE_CHECK_DELAY;\n            gpProcessButtonEvent(ind);\n        }\n        else if (sensor && sensor->deletedState() == Sensor::StateNormal)\n        {\n            if (searchSensorsState == SearchSensorsActive)\n            {\n                gpProcessButtonEvent(ind);\n            }\n        }\n\n        if (sensor) // add or update config attributes for known and new devices\n        {\n            {\n                ResourceItem *item = sensor->addItem(DataTypeString, RConfigGPDKey);\n                item->setIsPublic(false);\n                unsigned char buf[GP_SECURITY_KEY_SIZE * 2 + 1];\n                DBG_HexToAscii(gpdKey.data(), gpdKey.size(), buf);\n                Q_ASSERT(buf[GP_SECURITY_KEY_SIZE * 2] == '\\0');\n                item->setValue(QString(QLatin1String(reinterpret_cast<char*>(buf))));\n            }\n\n            {\n                ResourceItem *item = sensor->addItem(DataTypeUInt16, RConfigGPDDeviceId);\n                item->setIsPublic(false);\n                item->setValue(gpdDeviceId);\n            }\n\n            {\n                ResourceItem *item = sensor->addItem(DataTypeUInt32, RStateGPDFrameCounter);\n                item->setIsPublic(false);\n                item->setValue(gpdOutgoingCounter);\n            }\n\n            {\n                ResourceItem *item = sensor->addItem(DataTypeUInt64, RStateGPDLastPair);\n                item->setIsPublic(false);\n                item->setValue(deCONZ::steadyTimeRef().ref);\n            }\n            sensor->setNeedSaveDatabase(true);\n        }\n    }\n        break;\n\n    default:\n    {\n        DBG_Printf(DBG_ZGP, \"ZGP unhandled command gpdsrcid %u: gpdcmdid: 0x%02X\\n\", ind.gpdSrcId(), ind.gpdCommandId());\n    }\n        break;\n    }\n}\n\n/*! Returns true if the ZigBee network is connected.\n */\nbool DeRestPluginPrivate::isInNetwork()\n{\n    if (apsCtrl)\n    {\n        return (apsCtrl->networkState() == deCONZ::InNetwork);\n    }\n    return false;\n}\n\n/*! Creates a new unique ETag for a resource.\n */\nvoid DeRestPluginPrivate::updateEtag(QString &etag)\n{\n    QDateTime time = QDateTime::currentDateTime();\n#if QT_VERSION < 0x050000\n    etag = QString(QCryptographicHash::hash(time.toString(\"yyyy-MM-ddThh:mm:ss.zzz\").toAscii(), QCryptographicHash::Md5).toHex());\n#else\n    etag = QString(QCryptographicHash::hash(time.toString(\"yyyy-MM-ddThh:mm:ss.zzz\").toLatin1(), QCryptographicHash::Md5).toHex());\n#endif\n    // quotes are mandatory as described in w3 spec\n    etag.prepend('\"');\n    etag.append('\"');\n}\n\n/*! Returns the system uptime in seconds.\n */\nqint64 DeRestPluginPrivate::getUptime()\n{\n    DBG_Assert(starttimeRef.isValid());\n\n    if (!starttimeRef.isValid())\n    {\n        starttimeRef.start();\n    }\n\n    if (starttimeRef.isValid())\n    {\n        qint64 uptime = starttimeRef.elapsed();\n        if (uptime > 1000)\n        {\n            return uptime / 1000;\n        }\n    }\n\n    return 0;\n}\n\n/*! Child end-device polled for data.\n    \\param event - the related node event\n */\nvoid DeRestPluginPrivate::handleMacDataRequest(const deCONZ::NodeEvent &event)\n{\n    DBG_Assert(event.node());\n    if (!event.node())\n    {\n        return;\n    }\n\n    if (!event.node()->address().hasExt())\n    {\n        return;\n    }\n\n    auto *device = DEV_GetOrCreateDevice(this, deCONZ::ApsController::instance(), eventEmitter, m_devices, event.node()->address().ext());\n    Q_ASSERT(device);\n    enqueueEvent(Event(device->prefix(), REventAwake, 0, device->key()));\n\n    auto subDevices = device->subDevices();\n\n    for (auto &r : subDevices)\n    {\n        if (r->prefix() == RSensors)\n        {\n            Sensor *s = static_cast<Sensor*>(r);\n            Q_ASSERT(s);\n            s->rx();\n\n            if (searchSensorsState == SearchSensorsActive && fastProbeAddr.ext() == s->address().ext())\n            {\n                // Following calls are quite heavy, so only exec while sensor search is active.\n                // Since MAC data requests are only received from directly connected devices, this is \"extra\" anyway.\n                // TODO(mpi): we might remove this entirely after testing in favor for DDF.\n                checkSensorBindingsForAttributeReporting(s);\n                delayedFastEnddeviceProbe(&event);\n                checkSensorBindingsForClientClusters(s);\n                checkIasEnrollmentStatus(s);\n\n                if (s->lastAttributeReportBind() < (idleTotalCounter - IDLE_ATTR_REPORT_BIND_LIMIT))\n                {\n                    if (checkSensorBindingsForAttributeReporting(s))\n                    {\n                        s->setLastAttributeReportBind(idleTotalCounter);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/*! Adds new node(s) to node cache.\n    Only supported ZLL and HA nodes will be added.\n    \\param node - the base for the LightNode\n */\nvoid DeRestPluginPrivate::addLightNode(const deCONZ::Node *node)\n{\n    if (DEV_TestStrict())\n    {\n        return;\n    }\n\n    DBG_Assert(node != nullptr);\n    if (!node)\n    {\n        return;\n    }\n    if (node->nodeDescriptor().manufacturerCode() == VENDOR_KEEN_HOME || // Keen Home Vent\n        node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC || // Xiaomi lumi.ctrl_neutral1, lumi.ctrl_neutral2\n        node->nodeDescriptor().manufacturerCode() == VENDOR_XIAOMI || // Xiaomi lumi.curtain.hagl04\n        node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER || // atsmart Z6-03 switch + Heiman plug + Tuya stuff\n        (!node->nodeDescriptor().isNull() && node->nodeDescriptor().manufacturerCode() == VENDOR_NONE) || // Climax Siren\n        node->nodeDescriptor().manufacturerCode() == VENDOR_DEVELCO || // Develco Smoke sensor with siren\n        node->nodeDescriptor().manufacturerCode() == VENDOR_LDS || // Samsung SmartPlug 2019\n        node->nodeDescriptor().manufacturerCode() == VENDOR_THIRD_REALITY || // Third Reality smart light switch\n        node->nodeDescriptor().manufacturerCode() == VENDOR_AXIS || // Axis shade\n        node->nodeDescriptor().manufacturerCode() == VENDOR_MMB || // Axis shade\n        node->nodeDescriptor().manufacturerCode() == VENDOR_SI_LABS || // Yoolax Blinds\n        // Danalock support. The vendor ID (0x115c) needs to defined and whitelisted, as it's battery operated\n        node->nodeDescriptor().manufacturerCode() == VENDOR_DANALOCK || // Danalock Door Lock\n        node->nodeDescriptor().manufacturerCode() == VENDOR_KWIKSET || // Kwikset 914 ZigBee smart lock\n        // Schlage support. The vendor ID (0x1236) needs to defined and whitelisted, as it's battery operated\n        node->nodeDescriptor().manufacturerCode() == VENDOR_SCHLAGE)\n    {\n        // whitelist\n    }\n    else if (!node->nodeDescriptor().receiverOnWhenIdle())\n    {\n        return;\n    }\n\n    auto *device = DEV_GetOrCreateDevice(this, deCONZ::ApsController::instance(), eventEmitter, m_devices, node->address().ext());\n    Q_ASSERT(device);\n\n    if (node->nodeDescriptor().manufacturerCode() == VENDOR_PROFALUX)\n    {\n        //Profalux device don't have manufactureName and ModelID so can't wait for RAttrManufacturerName or RAttrModelId\n    }\n    else if (permitJoinFlag)\n    {\n        // during pairing only proceed when device code has finished query Basic Cluster\n        if (device->item(RAttrManufacturerName)->toString().isEmpty() ||\n            device->item(RAttrModelId)->toString().isEmpty())\n        {\n            return;\n        }\n    }\n\n    bool hasTuyaCluster = false;\n    QString manufacturer;\n\n    //Make 2 fakes device for tuya switches\n    if (node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER && !node->simpleDescriptors().empty())\n    {\n        const deCONZ::SimpleDescriptor *sd = &node->simpleDescriptors()[0];\n        bool hasColorCluster = false;\n\n        if (sd && (sd->deviceId() == DEV_ID_SMART_PLUG) && (node->simpleDescriptors().size() < 2) &&\n        (((node->address().ext() & 0xffffff0000000000ULL ) == silabs3MacPrefix) ||\n         ((node->address().ext() & 0xffffff0000000000ULL ) == silabs4MacPrefix))\n        )\n        {\n\n            for (size_t c = 0; c < sd->inClusters().size(); c++)\n            {\n                if (sd->inClusters()[c].id() == TUYA_CLUSTER_ID) { hasTuyaCluster = true; }\n                if (sd->inClusters()[c].id() == COLOR_CLUSTER_ID) { hasColorCluster = true; }\n            }\n\n            if  (hasTuyaCluster && !hasColorCluster)\n            {\n                DBG_Printf(DBG_INFO, \"Tuya : Creating 2 Fake Endpoints\\n\");\n\n                //Ok it's the good device, make 2 clones with differents endpoints\n\n                //node is not modifiable (WHY ?) so use an ugly way\n                deCONZ::Node *NodePachable = const_cast<deCONZ::Node*>(&*node);\n\n                deCONZ::SimpleDescriptor sd1;\n                deCONZ::SimpleDescriptor sd2;\n\n                const deCONZ::SimpleDescriptor &csd1 = sd1;\n                const deCONZ::SimpleDescriptor &csd2 = sd2;\n\n                node->copySimpleDescriptor(0x01, &sd1);\n                node->copySimpleDescriptor(0x01, &sd2);\n\n                sd1.setEndpoint(0x02);\n                sd2.setEndpoint(0x03);\n\n                //remove useless cluster\n                if (false)\n                {\n                    auto &cl = sd1.inClusters();\n\t\t\t\t\tcl.clear();\n\n\t\t\t\t\tfor (const deCONZ::ZclCluster &cl2 : sd2.inClusters())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cl2.id() == TUYA_CLUSTER_ID)\n\t\t\t\t\t\t{\n                            cl.push_back(cl2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t    }\n\n                NodePachable->setSimpleDescriptor(csd1);\n                NodePachable->setSimpleDescriptor(csd2);\n\n                // Update node\n                apsCtrl->updateNode(*NodePachable);\n\n            }\n        }\n    }\n\n    auto i = node->simpleDescriptors().cbegin();\n    const auto end = node->simpleDescriptors().cend();\n\n    for (;i != end; ++i)\n    {\n        bool hasServerOnOff = false;\n        bool hasServerLevel = false;\n        bool hasServerColor = false;\n        bool hasIASWDCluster = false;\n\n        for (size_t c = 0; c < i->inClusters().size(); c++)\n        {\n            if      (i->inClusters()[c].id() == ONOFF_CLUSTER_ID) { hasServerOnOff = true; }\n            else if (i->inClusters()[c].id() == LEVEL_CLUSTER_ID) { hasServerLevel = true; }\n            else if (i->inClusters()[c].id() == COLOR_CLUSTER_ID) { hasServerColor = true; }\n            else if (i->inClusters()[c].id() == WINDOW_COVERING_CLUSTER_ID) { hasServerOnOff = true; }\n            else if (i->inClusters()[c].id() == IAS_WD_CLUSTER_ID) { hasIASWDCluster = true; }\n            else if ((i->inClusters()[c].id() == TUYA_CLUSTER_ID) && (node->macCapabilities() & deCONZ::MacDeviceIsFFD) ) { hasServerOnOff = true; }\n            // Danalock support. The cluster needs to be defined and whitelisted by setting hasServerOnOff\n            else if (node->nodeDescriptor().manufacturerCode() == VENDOR_DANALOCK && i->inClusters()[c].id() == DOOR_LOCK_CLUSTER_ID) { hasServerOnOff = true; }\n            else if (node->nodeDescriptor().manufacturerCode() == VENDOR_SCHLAGE && i->inClusters()[c].id() == DOOR_LOCK_CLUSTER_ID) { hasServerOnOff = true; } //Schlage Connect Smart Deadbolt B3468\n            else if (node->nodeDescriptor().manufacturerCode() == VENDOR_KWIKSET && i->inClusters()[c].id() == DOOR_LOCK_CLUSTER_ID) { hasServerOnOff = true; } //Kwikset 914 ZigBee smart lock\n            else if (i->inClusters()[c].id() == BASIC_CLUSTER_ID)\n            {\n                std::vector<deCONZ::ZclAttribute>::const_iterator j = i->inClusters()[c].attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator jend = i->inClusters()[c].attributes().end();\n\n                for (; j != jend; ++j)\n                {\n                    if (manufacturer.isEmpty() && j->id() == 0x0004) // manufacturer id\n                    {\n                        manufacturer = j->toString().trimmed();\n                    }\n                }\n\n            }\n        }\n\n        // check if node already exist\n        LightNode *lightNode2 = nullptr;\n\n        for (auto &l : nodes)\n        {\n            if (l.state() != LightNode::StateNormal)\n            {\n                continue;\n            }\n\n            if (!node->address().hasExt() || node->address().ext() != l.address().ext())\n            {\n                continue;\n            }\n\n            if (l.haEndpoint().endpoint() != i->endpoint())\n            {\n                continue;\n            }\n\n            lightNode2 = &l;\n            break;\n        }\n\n        if (lightNode2)\n        {\n            DBG_Assert(lightNode2->state() != LightNode::StateDeleted);\n\n            if (lightNode2->node() != node)\n            {\n                lightNode2->setNode(const_cast<deCONZ::Node*>(node));\n            }\n\n            lightNode2->setManufacturerCode(node->nodeDescriptor().manufacturerCode());\n            ResourceItem *reachable = lightNode2->item(RStateReachable);\n\n            DBG_Assert(reachable);\n            bool avail = !node->isZombie() && lightNode2->lastRx().isValid();\n            if (!reachable->toBool() && avail)\n            {\n                // the node existed before\n                // refresh all with new values\n                reachable->setValue(avail);\n                Event e(RLights, RStateReachable, lightNode2->id(), reachable);\n                enqueueEvent(e);\n\n                if (avail)\n                {\n                    lightNode2->enableRead(READ_VENDOR_NAME |\n                                           READ_MODEL_ID |\n                                           READ_SWBUILD_ID |\n                                           READ_COLOR |\n                                           READ_LEVEL |\n                                           READ_ON_OFF |\n                                           READ_GROUPS |\n                                           READ_SCENES |\n                                           READ_BINDING_TABLE);\n\n                    for (uint32_t j = 0; j < 32; j++)\n                    {\n                        uint32_t item = 1 << j;\n                        if (lightNode2->mustRead(item))\n                        {\n                            lightNode2->setNextReadTime(item, queryTime);\n                            lightNode2->setLastRead(item, idleTotalCounter);\n                        }\n\n                    }\n\n                    queryTime = queryTime.addSecs(1);\n\n                    lightNode2->setNeedSaveDatabase(true);\n                    updateEtag(lightNode2->etag);\n                }\n            }\n\n            if (lightNode2->uniqueId().isEmpty() || lightNode2->uniqueId().startsWith(QLatin1String(\"0x\")))\n            {\n                QString uid = generateUniqueId(lightNode2->address().ext(), lightNode2->haEndpoint().endpoint(), 0);\n                lightNode2->setUniqueId(uid);\n                lightNode2->setNeedSaveDatabase(true);\n                updateEtag(lightNode2->etag);\n            }\n\n            continue;\n        }\n\n        LightNode lightNode;\n        lightNode.setNode(nullptr);\n        lightNode.item(RStateReachable)->setValue(true);\n\n        Q_Q(DeRestPlugin);\n        lightNode.setNode(const_cast<deCONZ::Node*>(node));\n        lightNode.address() = node->address();\n        lightNode.setManufacturerCode(node->nodeDescriptor().manufacturerCode());\n\n        // For Tuya, we realy need manufacture Name, but can't use it to compare because of fonction setManufacturerCode() that put \"Heiman\",\n        if (node->nodeDescriptor().isNull() || node->simpleDescriptors().empty())\n        { }\n        else if (node->nodeDescriptor().manufacturerCode() == VENDOR_NONE || (node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER))\n        {\n            // TODO(mpi): this needs to go in favor of DDF\n            if (manufacturer.isEmpty())\n            {\n                //searching in DB\n                openDb();\n                manufacturer = loadDataForLightNodeFromDb(generateUniqueId(node->address().ext(),0,0));\n                closeDb();\n\n                if (manufacturer.isEmpty())\n                {\n                    // extract from sensor if possible\n                    Sensor *sensor = getSensorNodeForAddress(node->address());\n                    if (sensor && !sensor->manufacturer().isEmpty())\n                    {\n                        manufacturer = sensor->manufacturer();\n                        lightNode.setNeedSaveDatabase(true);\n                    }\n                }\n\n                if (!manufacturer.isEmpty())\n                {\n                    lightNode.setManufacturerName(manufacturer);\n                }\n            }\n        }\n\n        //VENDOR_NONE only use device with 2 cluster ? or perhaps VENDOR_EMBER too\n        if (!node->nodeDescriptor().isNull() && node->nodeDescriptor().manufacturerCode() == VENDOR_NONE)\n        {\n            //General method to detect tuya cluster\n            if ((i->inClusters().size() == 2) && (i->endpoint() == 0x01) )\n            {\n                hasServerOnOff = true;\n            }\n            //Tuya white list\n            if (lightNode.manufacturer() == QLatin1String(\"_TYST11_xu1rkty3\") ||  //Covering with only 2 clusters\n                R_GetProductId(&lightNode) == QLatin1String(\"NAS-AB02B0 Siren\")) // Tuya Siren\n            {\n                hasServerOnOff = true;\n            }\n            //Tuya black list\n            //For exempleis valve with 2 cluster\n            if (R_GetProductId(&lightNode).startsWith(QLatin1String(\"Tuya_THD\")))\n            {\n                hasServerOnOff = false;\n            }\n        }\n        if (node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER)\n        {\n            //Tuya black list\n            //_TZE200_aoclfnxz is a thermostat\n            //_TZE200_c88teujp same\n            if (R_GetProductId(&lightNode).startsWith(QLatin1String(\"Tuya_THD\")))\n            {\n                hasServerOnOff = false;\n            }\n            if (R_GetProductId(&lightNode).startsWith(QLatin1String(\"Tuya_COVD\")) || //Battery covering\n                R_GetProductId(&lightNode) == QLatin1String(\"NAS-AB02B0 Siren\"))     // Tuya siren\n            {\n                hasServerOnOff = true;\n            }\n            //wireless switch\n            if (lightNode.manufacturer() == QLatin1String(\"_TZ3000_bi6lpsew\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3400_keyjhapk\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TYZB02_key8kk7r\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3400_keyjqthh\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_abci1hiu\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_rrjr1q0u\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3400_key8kk7r\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_vp6clf9d\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_wkai4ga5\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_peszejy7\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_qzjcsmar\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_owgcnkrh\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_arfwfgoa\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TYZB02_keyjqthh\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_dfgbtub0\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_xabckq1v\") ||\n                lightNode.manufacturer() == QLatin1String(\"_TZ3000_a7ouggvs\"))\n            {\n                hasServerOnOff = false;\n            }\n        }\n\n        if (!i->inClusters().empty())\n        {\n            if (i->profileId() == HA_PROFILE_ID)\n            {\n                // filter for supported devices\n                switch (i->deviceId())\n                {\n                case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:\n                case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:\n                case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:\n                case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:\n                case DEV_ID_HA_WINDOW_COVERING_DEVICE:\n                case DEV_ID_HA_WINDOW_COVERING_CONTROLLER:\n                // Danalock support. The device id (0x000a) needs to be defined and whitelisted\n                case DEV_ID_DOOR_LOCK:\n                {\n                    if (hasServerOnOff)\n                    {\n                        lightNode.setHaEndpoint(*i);\n                    }\n                }\n                break;\n                case DEV_ID_DOOR_LOCK_UNIT: // ORVIBO Zigbee Dry Contact CM10ZW\n                {\n                    if (!node->nodeDescriptor().isNull() && node->nodeDescriptor().manufacturerCode() == VENDOR_NONE)\n                    {\n                        if (hasServerOnOff)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                }\n                break;\n\n                case DEV_ID_FAN:\n                {\n                    if (hasServerOnOff)\n                    {\n                        lightNode.setHaEndpoint(*i);\n                    }\n                }\n                break;\n\n                case DEV_ID_MAINS_POWER_OUTLET:\n                case DEV_ID_HA_ONOFF_LIGHT:\n                case DEV_ID_LEVEL_CONTROL_SWITCH:\n                case DEV_ID_ONOFF_OUTPUT:\n                case DEV_ID_LEVEL_CONTROLLABLE_OUTPUT:\n                case DEV_ID_HA_DIMMABLE_LIGHT:\n                case DEV_ID_HA_ONOFF_LIGHT_SWITCH:\n                case DEV_ID_HA_DIMMER_SWITCH:\n                case DEV_ID_HA_COLOR_DIMMABLE_LIGHT:\n                case DEV_ID_SMART_PLUG:\n                case DEV_ID_ZLL_ONOFF_LIGHT:\n                case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:\n                case DEV_ID_ZLL_ONOFF_SENSOR:\n    //            case DEV_ID_ZLL_DIMMABLE_LIGHT: // same as DEV_ID_HA_ONOFF_LIGHT\n                case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:\n                case DEV_ID_ZLL_COLOR_LIGHT:\n                case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n                case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT:\n                    {\n                        if (hasServerOnOff)\n                        {\n                            if (checkMacAndVendor(node, VENDOR_JENNIC) &&\n                                // prevent false positives like Immax IM-Z3.0-DIM which has only two endpoints (0x01)\n                                // lumi.ctrl_neutral1 and lumi.ctrl_neutral2 have more 5 endpoints\n                                node->simpleDescriptors().size() > 5  &&\n                                i->endpoint() != 0x02 && i->endpoint() != 0x03)\n                            {\n                                // TODO better filter for lumi. devices (i->deviceId(), modelid?)\n                                // blacklist switch endpoints for lumi.ctrl_neutral1 and lumi.ctrl_neutral2\n                                DBG_Printf(DBG_INFO, \"Skip load endpoint 0x%02X for 0x%016llX (expect: lumi.ctrl_neutral1 / lumi.ctrl_neutral2)\\n\", i->endpoint(), node->address().ext());\n                            }\n                            else\n                            {\n                                lightNode.setHaEndpoint(*i);\n                            }\n                        }\n                    }\n                    break;\n\n                case DEV_ID_ZLL_COLOR_CONTROLLER:\n                    {\n                        // FIXME special temporary filter to detect xxx 4 key switch\n                        if (i->endpoint() == 0x01 && hasServerColor && hasServerLevel)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                            lightNode.item(RStateOn)->setValue(true);\n                            break;\n                        }\n                    }\n                    break;\n\n                case DEV_ID_RANGE_EXTENDER:\n                    {\n                        if (node->nodeDescriptor().manufacturerCode() == VENDOR_IKEA ||\n                           R_GetProductId(&lightNode) == QLatin1String(\"Tuya_RPT Repeater\"))\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                case DEV_ID_CONFIGURATION_TOOL:\n                    {\n                        if (node->nodeDescriptor().manufacturerCode() == VENDOR_DDEL)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                case DEV_ID_XIAOMI_SMART_PLUG:\n                    {\n                        if (node->nodeDescriptor().manufacturerCode() == VENDOR_XIAOMI &&\n                            (i->endpoint() == 0x01 || i->endpoint() == 0x02) && hasServerOnOff)\n                        {\n                            // Xiaomi lumi.plug and wall switch lumi.ctrl_ln1.aq2, lumi.ctrl_ln2.aq2\n                            lightNode.setHaEndpoint(*i);\n                        }\n                        else if (node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC &&\n                                 (i->endpoint() == 0x02 || i->endpoint() == 0x03) && hasServerOnOff)\n                        {\n                            // Xiaomi wall switch lumi.ctrl_neutral1, lumi.ctrl_neutral2\n                            // TODO exclude endpoint 0x03 for lumi.ctrl_neutral1\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                case DEV_ID_IAS_ZONE:\n                    {\n                        if (hasIASWDCluster)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                case DEV_ID_IAS_WARNING_DEVICE:\n                    {\n                        lightNode.setHaEndpoint(*i);\n                    }\n                    break;\n\n                case DEV_ID_CONSUMPTION_AWARENESS_DEVICE:\n                    {\n                        if (node->nodeDescriptor().manufacturerCode() == VENDOR_LEGRAND)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                default:\n                    {\n                    }\n                    break;\n                }\n            }\n            else if (i->profileId() == ZLL_PROFILE_ID)\n            {\n                // filter for supported devices\n                switch (i->deviceId())\n                {\n                case DEV_ID_ZLL_COLOR_LIGHT:\n                case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n                case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:\n                case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT:\n                case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:\n                case DEV_ID_ZLL_DIMMABLE_LIGHT:\n                case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:\n                case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:\n                case DEV_ID_ZLL_ONOFF_LIGHT:\n                case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:\n                case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:\n                //case DEV_ID_ZLL_ONOFF_SENSOR:\n                    {\n                        if (hasServerOnOff)\n                        {\n                            lightNode.setHaEndpoint(*i);\n                        }\n                    }\n                    break;\n\n                default:\n                    break;\n                }\n            }\n        }\n        else if (i->profileId() == DIN_PROFILE_ID)\n        {\n            switch (i->deviceId())\n            {\n            case DEV_ID_DIN_XBEE:\n            {\n                if (i->endpoint() == DIN_DDO_ENDPOINT)\n                {\n                    lightNode.setHaEndpoint(*i);\n                }\n            }\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (!lightNode.haEndpoint().isValid())\n        {\n            continue;\n        }\n\n        QString uid = generateUniqueId(lightNode.address().ext(), lightNode.haEndpoint().endpoint(), 0);\n        lightNode.setUniqueId(uid);\n\n\n        if (existDevicesWithVendorCodeForMacPrefix(node->address(), VENDOR_DDEL) && i->deviceId() != DEV_ID_CONFIGURATION_TOOL && node->nodeDescriptor().manufacturerCode() == VENDOR_DDEL)\n        {\n            ResourceItem *item = lightNode.addItem(DataTypeUInt32, RAttrPowerup);\n            DBG_Assert(item != 0);\n            item->setValue(R_POWERUP_RESTORE | R_POWERUP_RESTORE_AT_DAYLIGHT | R_POWERUP_RESTORE_AT_NO_DAYLIGHT);\n        }\n\n        openDb();\n        loadLightNodeFromDb(&lightNode);\n        closeDb();\n\n        const DeviceDescription &ddf = deviceDescriptions->get(&lightNode);\n        if (ddf.isValid() && DDF_IsStatusEnabled(ddf.status))\n        {\n            DBG_Printf(DBG_INFO, \"skip legacy loading %s / %s \\n\", qPrintable(lightNode.uniqueId()), qPrintable(lightNode.modelId()));\n\n            // To speed loading DDF up the first time after it was run as legacy before,\n            // assign manufacturer name and modelid to parent device. That way we don't have to wait until the\n            // data is queried again via Zigbee.\n            // Note: Due the deviceDescriptions->get(&lightNode); matching we can be sure the legacy strings aren't made up.\n            ResourceItem *item = device->item(RAttrManufacturerName);\n            if (item->toString().isEmpty())\n            {\n                item->setValue(lightNode.item(RAttrManufacturerName)->toString());\n            }\n\n            item = device->item(RAttrModelId);\n            if (item->toString().isEmpty())\n            {\n                item->setValue(lightNode.item(RAttrModelId)->toString());\n            }\n\n            return;\n        }\n\n        setLightNodeStaticCapabilities(&lightNode);\n\n        DBG_Assert(lightNode.state() != LightNode::StateDeleted);\n\n        if (lightNode.manufacturerCode() == VENDOR_XIAOMI)\n        {\n            if (lightNode.manufacturer() != QLatin1String(\"LUMI\"))\n            {\n                lightNode.setManufacturerName(QLatin1String(\"LUMI\"));\n                lightNode.setNeedSaveDatabase(true);\n            }\n        }\n\n        if (lightNode.manufacturerCode() == VENDOR_MAXSTREAM)\n        {\n            lightNode.setManufacturerName(QLatin1String(\"Digi\"));\n            lightNode.setModelId(QLatin1String(\"XBee\"));\n            lightNode.setNeedSaveDatabase(true);\n        }\n\n        ResourceItem *reachable = lightNode.item(RStateReachable);\n        DBG_Assert(reachable);\n        if (reachable) //  might have been set to false after reload\n        {\n            if (!reachable->toBool())\n            {\n                reachable->setValue(!node->isZombie() && lightNode.lastRx().isValid());\n            }\n        }\n\n        if (lightNode.id().isEmpty())\n        {\n            if (!(searchLightsState == SearchLightsActive || permitJoinFlag))\n            {\n                // don't add new light node when search is not active\n                return;\n            }\n\n            openDb();\n            lightNode.setId(QString::number(getFreeLightId()));\n            closeDb();\n            lightNode.setNeedSaveDatabase(true);\n        }\n\n        if (checkMacAndVendor(node, VENDOR_OSRAM) || checkMacAndVendor(node, VENDOR_OSRAM_STACK))\n        {\n            if (lightNode.manufacturer() != QLatin1String(\"OSRAM\"))\n            {\n                lightNode.setManufacturerName(QLatin1String(\"OSRAM\"));\n                lightNode.setNeedSaveDatabase(true);\n            }\n        }\n\n        if (lightNode.modelId() == QLatin1String(\"FLS-PP3 White\"))\n        { } // only push data from FLS-PP3 color endpoint\n        else\n        {\n            if (lightNode.name().isEmpty())\n                lightNode.setName(QString(\"%1 %2\").arg(lightNode.type()).arg(lightNode.id()));\n\n            if (!lightNode.name().isEmpty())\n            { q->nodeUpdated(lightNode.address().ext(), QLatin1String(\"name\"), lightNode.name()); }\n\n            if (!lightNode.swBuildId().isEmpty())\n            { q->nodeUpdated(lightNode.address().ext(), QLatin1String(\"version\"), lightNode.swBuildId()); }\n\n            if (!lightNode.manufacturer().isEmpty())\n            { q->nodeUpdated(lightNode.address().ext(), QLatin1String(\"vendor\"), lightNode.manufacturer()); }\n\n            if (!lightNode.modelId().isEmpty())\n            { q->nodeUpdated(lightNode.address().ext(), QLatin1String(\"modelid\"), lightNode.modelId()); }\n        }\n\n        //Add missing values for Profalux device\n        if (existDevicesWithVendorCodeForMacPrefix(node->address(), VENDOR_PROFALUX))\n        {\n            //Shutter ?\n            if (i->deviceId() == DEV_ID_ZLL_COLOR_LIGHT)\n            {\n                lightNode.setManufacturerName(QLatin1String(\"Profalux\"));\n                lightNode.setModelId(QLatin1String(\"PFLX Shutter\"));\n                lightNode.setNeedSaveDatabase(true);\n            }\n        }\n\n        //Add missing field for Tuya Device with tuya cluster\n        // Window covering\n        if (R_GetProductId(&lightNode).startsWith(QLatin1String(\"Tuya_COVD\")))\n        {\n            lightNode.addItem(DataTypeBool, RStateOpen);\n            lightNode.addItem(DataTypeUInt8, RStateLift);\n            lightNode.addItem(DataTypeUInt8, RStateBri);\n\n            ResourceItem *type = lightNode.item(RAttrType);\n            DBG_Assert(type);\n            if (type)\n            {\n                type->setValue(QString(\"Window covering device\"));\n            }\n            lightNode.setNeedSaveDatabase(true);\n        }\n\n        //Siren\n        if (R_GetProductId(&lightNode) == QLatin1String(\"NAS-AB02B0 Siren\"))\n        {\n            lightNode.removeItem(RStateOn);\n            ResourceItem *type = lightNode.item(RAttrType);\n            DBG_Assert(type);\n            if (type)\n            {\n                type->setValue(QString(\"Warning device\"));\n            }\n            lightNode.setNeedSaveDatabase(true);\n        }\n        // dimmer switches\n        if (R_GetProductId(&lightNode).startsWith(QLatin1String(\"Tuya_DIMSWITCH\")))\n        {\n            lightNode.addItem(DataTypeUInt8, RStateBri);\n\n            ResourceItem *type = lightNode.item(RAttrType);\n            DBG_Assert(type);\n            if (type)\n            {\n                type->setValue(QString(\"Dimmable light\"));\n            }\n            lightNode.setNeedSaveDatabase(true);\n        }\n\n        // Tanslate Tuya ManufacturerName\n        {\n            const lidlDevice *device = getLidlDevice(lightNode.manufacturer());\n            if (device != nullptr)\n            {\n                lightNode.setManufacturerName(QLatin1String(device->manufacturername));\n                lightNode.setModelId(QLatin1String(device->modelid));\n                lightNode.setNeedSaveDatabase(true);\n            }\n        }\n\n        // \"translate\" ORVIBO vendor name\n        if (lightNode.manufacturer() == QString(\"欧瑞博\"))\n        {\n            lightNode.setManufacturerName(QLatin1String(\"ORVIBO\"));\n            lightNode.setNeedSaveDatabase(true);\n        }\n        // replace ORVIBO model IDs\n        if (lightNode.modelId() == QLatin1String(\"abb71ca5fe1846f185cfbda554046cce\"))\n        {\n            lightNode.setModelId(QLatin1String(\"T10D1ZW dimmer\"));\n            lightNode.setNeedSaveDatabase(true);\n        }\n        else if (lightNode.modelId() == QLatin1String(\"545df2981b704114945f6df1c780515a\"))\n        {\n            lightNode.setModelId(QLatin1String(\"T10W1ZW switch\"));\n            lightNode.setNeedSaveDatabase(true);\n        }\n        else if (lightNode.modelId() == QLatin1String(\"82c167c95ed746cdbd21d6817f72c593\"))\n        {\n            lightNode.setModelId(QLatin1String(\"CM10ZW\"));\n            lightNode.setNeedSaveDatabase(true);\n        }\n\n        // add light node to default group\n        GroupInfo *groupInfo = getGroupInfo(&lightNode, gwGroup0);\n        if (!groupInfo)\n        {\n            groupInfo = createGroupInfo(&lightNode, gwGroup0);\n            lightNode.setNeedSaveDatabase(true);\n            groupInfo->actions &= ~GroupInfo::ActionRemoveFromGroup; // sanity\n            groupInfo->actions |= GroupInfo::ActionAddToGroup;\n        }\n\n        // force reading attributes\n        lightNode.enableRead(READ_VENDOR_NAME |\n                             READ_MODEL_ID |\n                             READ_SWBUILD_ID |\n                             READ_COLOR |\n                             READ_LEVEL |\n                             READ_ON_OFF |\n                             READ_GROUPS |\n                             READ_SCENES |\n                             READ_BINDING_TABLE);\n        for (uint32_t j = 0; j < 32; j++)\n        {\n            uint32_t item = 1 << j;\n            if (lightNode.mustRead(item))\n            {\n                lightNode.setNextReadTime(item, queryTime);\n                lightNode.setLastRead(item, idleTotalCounter);\n            }\n        }\n        lightNode.setLastAttributeReportBind(0);\n        queryTime = queryTime.addSecs(1);\n\n        DBG_Printf(DBG_INFO, \"LightNode %u: %s added\\n\", lightNode.id().toUInt(), qPrintable(lightNode.name()));\n\n        lightNode.setHandle(R_CreateResourceHandle(&lightNode, nodes.size()));\n        nodes.push_back(lightNode);\n        lightNode2 = &nodes.back();\n        queuePollNode(lightNode2);\n        device->addSubDevice(lightNode2);\n\n        if (searchLightsState == SearchLightsActive || permitJoinFlag)\n        {\n            Event e(RLights, REventAdded, lightNode2->id());\n            enqueueEvent(e);\n        }\n\n        needRuleCheck = RULE_CHECK_DELAY;\n\n        q->startZclAttributeTimer(checkZclAttributesDelay);\n        updateLightEtag(lightNode2);\n\n        if (lightNode2->needSaveDatabase())\n        {\n            queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n        }\n    }\n}\n\n/*! Adds known static values to a lightnode.\n    \\param lightNode - the LightNode to update\n */\nvoid DeRestPluginPrivate::setLightNodeStaticCapabilities(LightNode *lightNode)\n{\n    DBG_Assert(lightNode);\n    if (!lightNode)\n    {\n        return;\n    }\n\n    ResourceItem *item = nullptr;\n    const QString modelId = lightNode->modelId();\n\n    if (lightNode->manufacturerCode() == VENDOR_LEDVANCE &&\n            (lightNode->modelId() == QLatin1String(\"BR30 RGBW\") ||\n            lightNode->modelId() == QLatin1String(\"RT RGBW\") ||\n            lightNode->modelId() == QLatin1String(\"A19 RGBW\")))\n    {\n        item = lightNode->item(RAttrType);\n        if (item)\n        {\n            item->setValue(QVariant(\"Color temperature light\"));\n        }\n        if (lightNode->item(RCapColorCapabilities) != nullptr)\n        {\n            return; // already initialized\n        }\n        lightNode->addItem(DataTypeUInt16, RStateCt);\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMin)->setValue(142);\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMax)->setValue(666);\n        lightNode->addItem(DataTypeUInt16, RCapColorCapabilities)->setValue(0x0001 | 0x0008 | 0x0010);\n        lightNode->addItem(DataTypeString, RStateColorMode)->setValue(QVariant(\"ct\"));\n    }\n    else if (lightNode->modelId() == QLatin1String(\"LIGHTIFY A19 RGBW\"))\n    {\n        if (lightNode->item(RCapColorCapabilities) != nullptr)\n        {\n            return; // already initialized\n        }\n        lightNode->addItem(DataTypeUInt16, RStateCt);\n        // the light doesn't provide ctmin, ctmax and color capabilities attributes\n        // however it supports the 'Move To Color Temperature' command and Color Temperature attribute\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMin)->setValue(152);\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMax)->setValue(689);\n        // hue, saturation, color mode, xy, ct\n        lightNode->addItem(DataTypeUInt16, RCapColorCapabilities)->setValue(0x0001 | 0x0008 | 0x0010);\n    }\n    else if (lightNode->modelId() == QLatin1String(\"LIGHTIFY A19 Tunable White\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY Conv Under Cabinet TW\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY Under Cabinet TW\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY BR Tunable White\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY RT Tunable White\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY Edge-lit Flushmount TW\") ||\n             lightNode->modelId() == QLatin1String(\"LIGHTIFY Surface TW\") ||\n             lightNode->modelId() == QLatin1String(\"A19 TW 10 year\") ||\n             lightNode->modelId() == QLatin1String(\"Classic B40 TW - LIGHTIFY\") ||\n             lightNode->modelId() == QLatin1String(\"Classic A60 TW\") ||\n             lightNode->modelId() == QLatin1String(\"Classic A60 TW\") ||\n             lightNode->modelId() == QLatin1String(\"Zigbee CCT Downlight\") ||\n             lightNode->modelId() == QLatin1String(\"Halo_RL5601\") ||\n             (lightNode->manufacturerCode() == VENDOR_LEDVANCE && lightNode->modelId() == QLatin1String(\"Down Light TW\")) ||\n             (lightNode->manufacturerCode() == VENDOR_LEDVANCE && lightNode->modelId() == QLatin1String(\"BR30 TW\")) ||\n             (lightNode->manufacturerCode() == VENDOR_LEDVANCE && lightNode->modelId() == QLatin1String(\"MR16 TW\")) ||\n             (lightNode->manufacturerCode() == VENDOR_LEDVANCE && lightNode->modelId() == QLatin1String(\"RT TW\")))\n    {\n        item = lightNode->item(RAttrType);\n        if (item && item->toString() == QLatin1String(\"Color dimmable light\")) // some TW lights wrongly report as dimmable\n        {\n            item->setValue(QVariant(\"Color temperature light\"));\n        }\n\n        if (lightNode->item(RCapColorCapabilities) != nullptr)\n        {\n            return; // already initialized\n        }\n        lightNode->addItem(DataTypeUInt16, RStateCt);\n        // these lights don't provide ctmin, ctmax and color capabilities attributes\n        // however they support the 'Move To Color Temperature' command and Color Temperature attribute\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMin)->setValue(153); // 6500K\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMax)->setValue(370); // 2700K\n        // color mode, xy, ct\n        lightNode->addItem(DataTypeUInt16, RCapColorCapabilities)->setValue(0x0008 | 0x0010);\n        lightNode->addItem(DataTypeString, RStateColorMode)->setValue(QVariant(\"ct\"));\n        lightNode->removeItem(RStateHue);\n        lightNode->removeItem(RStateSat);\n\n        item = lightNode->item(RStateX);\n        if (item) { item->setIsPublic(false); }\n        item = lightNode->item(RStateY);\n        if (item) { item->setIsPublic(false); }\n    } else if (lightNode->manufacturerCode() == VENDOR_SENGLED_OPTOELEC &&\n            lightNode->modelId() == QLatin1String(\"Z01-A19NAE26\"))\n    {\n        item = lightNode->item(RAttrType);\n        if (item)\n        {\n            item->setValue(QVariant(\"Color temperature light\"));\n        }\n        if (lightNode->item(RCapColorCapabilities) != nullptr)\n        {\n            return; // already initialized\n        }\n        lightNode->addItem(DataTypeUInt16, RStateCt);\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMin)->setValue(153);\n        lightNode->addItem(DataTypeUInt16, RCapColorCtMax)->setValue(370);\n        lightNode->addItem(DataTypeUInt16, RCapColorCapabilities)->setValue(0x0001 | 0x0008 | 0x0010);\n        lightNode->addItem(DataTypeString, RStateColorMode)->setValue(QVariant(\"ct\"));\n    }\n    else if (isXmasLightStrip(lightNode))\n    {\n        lightNode->removeItem(RStateAlert);\n        lightNode->removeItem(RStateX);\n        lightNode->removeItem(RStateY);\n        lightNode->addItem(DataTypeUInt16, RStateHue);\n        lightNode->addItem(DataTypeUInt8, RStateSat);\n        lightNode->addItem(DataTypeString, RStateEffect)->setValue(QVariant(\"none\"));\n    }\n}\n\n/*! Force polling if the node has updated simple descriptors in setup phase.\n    \\param node - the base for the LightNode\n\n    TODO(mpi): This function can likely be removed entirely, after testing.\n */\nvoid DeRestPluginPrivate::updatedLightNodeEndpoint(const deCONZ::NodeEvent &event)\n{\n    if (DEV_TestManaged())\n    {\n        return;\n    }\n\n    if (!event.node())\n    {\n        return;\n    }\n\n    if (event.clusterId() != ZDP_SIMPLE_DESCRIPTOR_RSP_CLID)\n    {\n        return;\n    }\n\n    for (LightNode &lightNode : nodes)\n    {\n        if (lightNode.address().ext() != event.node()->address().ext())\n        {\n            continue;\n        }\n\n        if (event.endpoint() != lightNode.haEndpoint().endpoint())\n        {\n            continue;\n        }\n\n        lightNode.rx();\n        queuePollNode(&lightNode);\n    }\n}\n\n/*! Checks if a known node changed its reachable state changed.\n    \\param node - the base for the LightNode\n    \\return the related LightNode or 0\n */\nvoid DeRestPluginPrivate::nodeZombieStateChanged(const deCONZ::Node *node)\n{\n    if (!node)\n    {\n        return;\n    }\n\n    bool available = !node->isZombie();\n\n    {\n        auto *device = DEV_GetDevice(m_devices, node->address().ext());\n        if (device)\n        {\n            ResourceItem *item = device->item(RStateReachable);\n            if (item && item->toBool() != available)\n            {\n                item->setValue(available);\n                enqueueEvent({device->prefix(), item->descriptor().suffix, 0, device->key()});\n            }\n        }\n    }\n\n    { // lights\n        std::vector<LightNode>::iterator i = nodes.begin();\n        std::vector<LightNode>::iterator end = nodes.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->state() != LightNode::StateNormal)\n            {\n                continue;\n            }\n\n            if (i->address().ext() != node->address().ext())\n            {\n                continue;\n            }\n\n            if (i->node() != node)\n            {\n                i->setNode(const_cast<deCONZ::Node*>(node));\n            }\n\n            ResourceItem *item = i->item(RStateReachable);\n            DBG_Assert(item);\n            if (item && (item->toBool() != available || !item->lastSet().isValid()))\n            {\n                if (available && node->endpoints().end() == std::find(node->endpoints().begin(),\n                                                                      node->endpoints().end(),\n                                                                      i->haEndpoint().endpoint()))\n                {\n                    available = false;\n                }\n\n                if (item && item->toBool() != available)\n                {\n                    i->setNeedSaveDatabase(true);\n                    item->setValue(available);\n                    updateLightEtag(&*i);\n                    Event e(RLights, RStateReachable, i->id(), item);\n                    enqueueEvent(e);\n                }\n            }\n        }\n    }\n\n    { // sensors\n        std::vector<Sensor>::iterator i = sensors.begin();\n        std::vector<Sensor>::iterator end = sensors.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->deletedState() != Sensor::StateNormal)\n            {\n                continue;\n            }\n\n            if (i->address().ext() == node->address().ext())\n            {\n                if (i->node() != node)\n                {\n                    i->setNode(const_cast<deCONZ::Node*>(node));\n                }\n\n                checkSensorNodeReachable(&(*i));\n            }\n        }\n    }\n}\n\n/*! Updates/adds a LightNode from a Node.\n    If the node does not exist it will be created\n    otherwise the values will be checked for change\n    and updated in the internal representation.\n    \\param node - holds up to date data\n    \\return the updated or added LightNode\n */\nLightNode *DeRestPluginPrivate::updateLightNode(const deCONZ::NodeEvent &event)\n{\n    if (!event.node())\n    {\n        return nullptr;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, event.node()->address().ext());\n\n    if (device && device->managed())\n    {\n        return nullptr;\n    }\n\n    bool updated = false;\n    LightNode *lightNode = getLightNodeForAddress(event.node()->address(), event.endpoint());\n\n    if (!lightNode)\n    {\n        // was no relevant node\n        return nullptr;\n    }\n\n    if (lightNode->node() != event.node())\n    {\n        lightNode->setNode(const_cast<deCONZ::Node*>(event.node()));\n    }\n\n    if (lightNode->toBool(RStateReachable))\n    {\n        if ((event.node()->state() == deCONZ::FailureState) || event.node()->isZombie())\n        {\n            lightNode->setValue(RStateReachable, false);\n        }\n    }\n    else\n    {\n        if (event.node()->state() != deCONZ::FailureState)\n        {\n            lightNode->setValue(RStateReachable, true);\n        }\n    }\n\n    if (lightNode->isAvailable())\n    {\n        lightNode->rx();\n    }\n\n    // filter\n    if ((event.profileId() != HA_PROFILE_ID) && (event.profileId() != ZLL_PROFILE_ID))\n    {\n        return lightNode;\n    }\n\n    auto i = event.node()->simpleDescriptors().cbegin();\n    const auto end = event.node()->simpleDescriptors().cend();\n\n    for (;i != end; ++i)\n    {\n        if (i->endpoint() != lightNode->haEndpoint().endpoint())\n        {\n            continue;\n        }\n\n        if (i->inClusters().empty())\n        {\n            continue;\n        }\n\n        if (i->profileId() == HA_PROFILE_ID)\n        {\n            switch(i->deviceId())\n            {\n            case DEV_ID_MAINS_POWER_OUTLET:\n            case DEV_ID_SMART_PLUG:\n            case DEV_ID_HA_COLOR_DIMMABLE_LIGHT:\n            case DEV_ID_ZLL_COLOR_LIGHT:\n            case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n            case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:\n            case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT:\n            case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:\n            case DEV_ID_HA_DIMMABLE_LIGHT:\n            case DEV_ID_HA_ONOFF_LIGHT_SWITCH:\n            case DEV_ID_HA_DIMMER_SWITCH:\n            case DEV_ID_RANGE_EXTENDER:\n            case DEV_ID_CONFIGURATION_TOOL:\n            //case DEV_ID_ZLL_DIMMABLE_LIGHT: // same as DEV_ID_HA_ONOFF_LIGHT\n            case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:\n            case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:\n            case DEV_ID_HA_ONOFF_LIGHT:\n            case DEV_ID_LEVEL_CONTROL_SWITCH:\n            case DEV_ID_ONOFF_OUTPUT:\n            case DEV_ID_LEVEL_CONTROLLABLE_OUTPUT:\n            case DEV_ID_ZLL_ONOFF_LIGHT:\n            case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:\n            case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:\n            case DEV_ID_HA_WINDOW_COVERING_DEVICE:\n            case DEV_ID_HA_WINDOW_COVERING_CONTROLLER:\n            // Danalock support. The device id (0x000a) needs to be defined and whitelisted\n            case DEV_ID_DOOR_LOCK:\n            case DEV_ID_ZLL_ONOFF_SENSOR:\n            case DEV_ID_XIAOMI_SMART_PLUG:\n            case DEV_ID_IAS_ZONE:\n            case DEV_ID_IAS_WARNING_DEVICE:\n            case DEV_ID_FAN:\n                break;\n\n            default:\n                continue;\n            }\n        }\n        else if (i->profileId() == ZLL_PROFILE_ID)\n        {\n            switch(i->deviceId())\n            {\n            case DEV_ID_ZLL_COLOR_LIGHT:\n            case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n            case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:\n            case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT:\n            case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:\n            case DEV_ID_ZLL_DIMMABLE_LIGHT:\n            case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:\n            case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:\n            case DEV_ID_ZLL_ONOFF_LIGHT:\n            case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:\n            case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:\n            case DEV_ID_ZLL_ONOFF_SENSOR:\n                break;\n\n            default:\n                continue;\n            }\n        }\n        else\n        {\n            continue;\n        }\n\n        // copy whole endpoint as reference\n        lightNode->setHaEndpoint(*i);\n\n        auto ic = lightNode->haEndpoint().inClusters().cbegin();\n        const auto endc = lightNode->haEndpoint().inClusters().cend();\n\n        NodeValue::UpdateType updateType = NodeValue::UpdateInvalid;\n        if (event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclRead)\n        {\n            updateType = NodeValue::UpdateByZclRead;\n        }\n        else if (event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclReport)\n        {\n            updateType = NodeValue::UpdateByZclReport;\n        }\n\n        for (; ic != endc; ++ic)\n        {\n            if (updateType == NodeValue::UpdateInvalid)\n            {\n                break;\n            }\n\n            if (ic->id() == COLOR_CLUSTER_ID && (event.clusterId() == COLOR_CLUSTER_ID))\n            {\n                if (isXmasLightStrip(lightNode))\n                {\n                    continue;\n                }\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (std::find(event.attributeIds().begin(),\n                                  event.attributeIds().end(),\n                                  ia->id()) == event.attributeIds().end())\n                    {\n                        continue;\n                    }\n\n                    lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                    if (ia->id() == 0x0000) // current hue\n                    {\n                        uint8_t hue = ia->numericValue().u8;\n\n                        if (hue > 254) // FIXME: Hue lights accept and report Hue of 255 ?\n                        {\n                            hue = 254;\n                        }\n\n                        qreal normHue = (static_cast<double>(hue) * 360 / 254) / 360; // FIXME: Hue lights enhanced hue = 256 * hue.\n                        if      (normHue < 0) { normHue = 0; }\n                        else if (normHue > 1) { normHue = 1; }\n\n                        const quint16 ehue = static_cast<quint16>(normHue * 65535);\n\n                        lightNode->setValue(RStateHue, ehue);\n                    }\n                    else if (ia->id() == 0x4000 && lightNode->manufacturerCode() != VENDOR_MUELLER) // enhanced current hue\n                    {\n                        quint16 hue = ia->numericValue().u16;\n                        lightNode->setValue(RStateHue, hue);\n                    }\n                    else if (ia->id() == 0x0001) // current saturation\n                    {\n                        uint8_t sat = ia->numericValue().u8;\n                        lightNode->setValue(RStateSat, sat);\n                    }\n                    else if (ia->id() == 0x0003) // current x\n                    {\n                        uint16_t colorX = ia->numericValue().u16;\n\n                        // sanity for colorX\n                        if (colorX > 0xFEFF)\n                        {\n                            colorX = 0xFEFF;\n                        }\n                        lightNode->setValue(RStateX, colorX);\n                    }\n                    else if (ia->id() == 0x0004) // current y\n                    {\n                        uint16_t colorY = ia->numericValue().u16;\n                        // sanity for colorY\n                        if (colorY > 0xFEFF)\n                        {\n                            colorY = 0xFEFF;\n                        }\n                        lightNode->setValue(RStateY, colorY);\n                    }\n                    else if (ia->id() == 0x0007) // color temperature\n                    {\n                        uint16_t ct = ia->numericValue().u16;\n                        lightNode->setValue(RStateCt, ct);\n                    }\n                    else if (ia->id() == 0x0008 || ia->id() == 0x4001) // color mode | enhanced color mode\n                    {\n                        if (ia->id() == 0x0008 && lightNode->manufacturerCode() == VENDOR_IKEA)\n                        {\n                            //DBG_Printf(DBG_INFO, \"Ignore color mode (0x0008) in favor for enhanced color mode (0x4001) for Ikea light 0x%016llx\\n\", lightNode->address().ext());\n                            continue;\n                        }\n                        if (ia->id() == 0x4001 && lightNode->manufacturer() == QLatin1String(\"GLEDOPTO\"))\n                        {\n                            //DBG_Printf(DBG_INFO, \"Ignore enhanced color mode (0x4001) in favor for color mode (0x0008) for GLEDOPTO light 0x%016llx\\n\", lightNode->address().ext());\n                            continue;\n                        }\n\n                        uint8_t cm = ia->numericValue().u8;\n\n                        if (lightNode->item(RStateHue) == nullptr && lightNode->item(RStateX) == nullptr && lightNode->item(RStateCt) != nullptr)\n                        {\n                            // OSRAM/LEDVANCE tunable white lights sometimes report hue and saturation, but only ct makes sense\n                            cm = 2;\n                        }\n\n                        {\n                            ResourceItem *item = lightNode->item(RCapColorCapabilities);\n                            if (item && item->toNumber() > 0)\n                            {\n                                const auto cap = item->toNumber();\n                                if (cap == 0x0010 && cm != 2) // color temperature only light\n                                {\n                                    cm = 2; // fix unsupported color modes (IKEA ct light)\n                                }\n                            }\n                        }\n\n                        const char *modes[4] = {\"hs\", \"xy\", \"ct\", \"hs\"};\n\n                        if (cm < 4)\n                        {\n                            lightNode->setValue(RStateColorMode, QString(modes[cm]));\n                        }\n                    }\n                    else if (ia->id() == 0x4002) // color loop active\n                    {\n                        if (RStateEffectValuesMueller.indexOf(lightNode->toString(RStateEffect), 0) <= 1)\n                        {\n                            if ((int)ia->numericValue().u8 < RStateEffectValues.size())\n                            {\n                                lightNode->setValue(RStateEffect, RStateEffectValues[ia->numericValue().u8]);\n                            }\n                        }\n                    }\n                    else if (ia->id() == 0x4004) // color loop time\n                    {\n                        uint8_t clTime = ia->numericValue().u8;\n\n                        if (lightNode->colorLoopSpeed() != clTime)\n                        {\n                            lightNode->setColorLoopSpeed(clTime);\n                        }\n                    }\n                    else if (ia->id() == 0x400a) // color capabilities\n                    {\n                        quint16 cap = ia->numericValue().u16;\n                        lightNode->setValue(RCapColorCapabilities, cap);\n                    }\n                    else if (ia->id() == 0x400b) // color temperature min\n                    {\n                        quint16 cap = ia->numericValue().u16;\n                        lightNode->setValue(RCapColorCtMin, cap);\n                    }\n                    else if (ia->id() == 0x400c) // color temperature max\n                    {\n                        quint16 cap = ia->numericValue().u16;\n                        lightNode->setValue(RCapColorCtMax, cap);\n                    }\n                }\n            }\n            else if (ic->id() == LEVEL_CLUSTER_ID && (event.clusterId() == LEVEL_CLUSTER_ID))\n            {\n                if (isXmasLightStrip(lightNode))\n                {\n                    continue;\n                }\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (ia->id() == 0x0000) // current level\n                    {\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                        uint8_t level = ia->numericValue().u8;\n                        if (lightNode->setValue(RStateBri, level))\n                        {\n                            lightNode->clearRead(READ_LEVEL);\n                            pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                        }\n                        break;\n                    }\n                }\n            }\n            else if (ic->id() == ONOFF_CLUSTER_ID && (event.clusterId() == ONOFF_CLUSTER_ID))\n            {\n                if (lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain\")))\n                {\n                    continue; // ignore OnOff cluster\n                }\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (ia->id() == 0x0000) // OnOff\n                    {\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                        bool on = ia->numericValue().u8;\n                        if (lightNode->setValue(RStateOn, on))\n                        {\n                            pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                        }\n                        else\n                        {\n                            // since light event won't trigger a group check, do it here\n                            for (const GroupInfo &gi : lightNode->groups())\n                            {\n                                if (gi.state == GroupInfo::StateInGroup)\n                                {\n                                    Event e(RGroups, REventCheckGroupAnyOn, int(gi.id));\n                                    enqueueEvent(e);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            // Danalock support. In updateLightNode(), whitelist the same cluster and add a handler for ic->id() == DOOR_LOCK_CLUSTER_ID, similar to ONOFF_CLUSTER_ID, but obviously checking for attribute 0x0101/0x0000.\n            else if (ic->id() == DOOR_LOCK_CLUSTER_ID && (event.clusterId() == DOOR_LOCK_CLUSTER_ID))\n            {\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (ia->id() == 0x0000) // Lock state\n                    {\n                        bool on = ia->numericValue().u8 == 1;\n                        ResourceItem *item = lightNode->item(RStateOn);\n                        if (item && item->toBool() != on)\n                        {\n                            DBG_Printf(DBG_INFO, \"0x%016llX onOff %u --> %u\\n\", lightNode->address().ext(), (uint)item->toNumber(), on);\n                            item->setValue(on);\n                            Event e(RLights, RStateOn, lightNode->id(), item);\n                            enqueueEvent(e);\n                            updated = true;\n                            pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                        }\n                        else\n                        {\n                            // since light event won't trigger a group check, do it here\n                            for (const GroupInfo &gi : lightNode->groups())\n                            {\n                                if (gi.state == GroupInfo::StateInGroup)\n                                {\n                                    Event e(RGroups, REventCheckGroupAnyOn, int(gi.id));\n                                    enqueueEvent(e);\n                                }\n                            }\n                        }\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                        break;\n                    }\n                }\n            }\n            else if (ic->id() == BASIC_CLUSTER_ID && (event.clusterId() == BASIC_CLUSTER_ID))\n            {\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (std::find(event.attributeIds().begin(),\n                                  event.attributeIds().end(),\n                                  ia->id()) == event.attributeIds().end())\n                    {\n                        continue;\n                    }\n\n                    if (ia->id() == 0x0001 && lightNode->modelId() == QLatin1String(\"TS011F\")) // Application version\n                    {\n                        // For some Tuya plugs (TS011F) date code is empty, use this attribute instead.\n                        // _TZ3000_1obwwnmq    3x plug\n                        // _TZ3000_kdi2o9m6    1x plug\n                        // _TZ3000_mraovvmm\n                        const auto str = QString::number(static_cast<int>(ia->numericValue().u8));\n                        ResourceItem *item = lightNode->item(RAttrSwVersion);\n\n                        if (!str.isEmpty() && item)\n                        {\n                            if (item->toString() != str)\n                            {\n                                lightNode->setNeedSaveDatabase(true);\n                                queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                                updated = true;\n                            }\n                            item->setValue(str); // always needed to refresh set timestamp\n                        }\n                    }\n                    else if (ia->id() == 0x0004) // Manufacturer name\n                    {\n                        QString str = ia->toString().trimmed();\n                        const lidlDevice *device = getLidlDevice(str);\n\n                        if (device != nullptr)\n                        {\n                            ResourceItem *item = lightNode->item(RAttrModelId);\n                            QString str2 = QLatin1String(device->modelid);\n\n                            if (item && !str2.isEmpty() && str2 != item->toString())\n                            {\n                                lightNode->setModelId(str2);\n                                item->setValue(str2);\n                                lightNode->setNeedSaveDatabase(true);\n                                queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                                updated = true;\n                                setLightNodeStaticCapabilities(lightNode);\n                            }\n                            str = QLatin1String(device->manufacturername);\n                        }\n\n                        if (str == QString(\"欧瑞博\"))\n                        {\n                            str = QLatin1String(\"ORVIBO\");\n                        }\n\n                        if (!str.isEmpty() && str != lightNode->manufacturer())\n                        {\n                            auto *item = lightNode->item(RAttrManufacturerName);\n                            lightNode->setManufacturerName(str);\n                            lightNode->setNeedSaveDatabase(true);\n                            queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                            updated = true;\n                            setLightNodeStaticCapabilities(lightNode);\n                            enqueueEvent({lightNode->prefix(), item->descriptor().suffix, lightNode->id(), item, lightNode->address().ext()});\n\n                            {\n                                Q_Q(DeRestPlugin);\n                                emit q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"vendor\"), str);\n                            }\n                        }\n                    }\n                    else if (ia->id() == 0x0005) // Model identifier\n                    {\n                        QString str = ia->toString().trimmed();\n                        ResourceItem *item = lightNode->item(RAttrModelId);\n\n                        if (isLidlDevice(str, lightNode->manufacturer()))\n                        {\n                            // Ignore non-unique ModelIdentifier; modelid set from unqiue ManufacturerName.\n                            continue;\n                        }\n                        if (str == QLatin1String(\"abb71ca5fe1846f185cfbda554046cce\"))\n                        {\n                            str = QLatin1String(\"T10D1ZW dimmer\");\n                        }\n                        else if (str == QLatin1String(\"545df2981b704114945f6df1c780515a\"))\n                        {\n                            str = QLatin1String(\"T10W1ZW switch\");\n                        }\n                        else if (str == QLatin1String(\"82c167c95ed746cdbd21d6817f72c593\"))\n                        {\n                            str = QLatin1String(\"CM10ZW\");\n                        }\n\n                        if (item && !str.isEmpty() && str != item->toString())\n                        {\n                            lightNode->setModelId(str);\n                            item->setValue(str);\n                            lightNode->setNeedSaveDatabase(true);\n                            queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                            updated = true;\n                            setLightNodeStaticCapabilities(lightNode);\n                            enqueueEvent({lightNode->prefix(), item->descriptor().suffix, lightNode->id(), item, lightNode->address().ext()});\n                        }\n\n                        {\n                            Q_Q(DeRestPlugin);\n                            emit q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"modelid\"), str);\n                        }\n                    }\n                    else if (ia->id() == 0x0006) // Date code\n                    {\n                        const QString str = ia->toString().trimmed();\n                        ResourceItem *item = lightNode->item(RAttrSwVersion);\n\n                        if (item && !str.isEmpty())\n                        {\n                            if (str != item->toString())\n                            {\n                                lightNode->setNeedSaveDatabase(true);\n                                queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                                updated = true;\n                            }\n                            item->setValue(str); // always needed to refresh set timestamp\n\n                            {\n                                Q_Q(DeRestPlugin);\n                                emit q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"version\"), str);\n                            }\n                        }\n                    }\n                    else if (ia->id() == 0x4000) // Software build identifier\n                    {\n                        const QString str = ia->toString().trimmed();\n                        ResourceItem *item = lightNode->item(RAttrSwVersion);\n\n                        deCONZ::NumericUnion dummy;\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), dummy);\n\n                        if (item && !str.isEmpty())\n                        {\n                            if (str != item->toString())\n                            {\n                                lightNode->setNeedSaveDatabase(true);\n                                queSaveDb(DB_LIGHTS, DB_LONG_SAVE_DELAY);\n                                updated = true;\n                            }\n                            item->setValue(str); // always needed to refresh set timestamp\n\n                            {\n                                Q_Q(DeRestPlugin);\n                                emit q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"version\"), str);\n                            }\n                        }\n                    }\n                    else if (ia->id() == 0x4005 && lightNode->manufacturerCode() == VENDOR_MUELLER)\n                    {\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                        quint8 scene = ia->numericValue().u8;\n                        if (scene >= 1 && scene <= 6)\n                        {\n                            lightNode->setValue(RStateEffect, RStateEffectValuesMueller[scene + 1]);\n                        }\n                    }\n                }\n            }\n            else if (ic->id() == ANALOG_OUTPUT_CLUSTER_ID && (event.clusterId() == ANALOG_OUTPUT_CLUSTER_ID))\n            {\n                if (!lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain\")))\n                {\n                    continue; // ignore except for lumi.curtain\n                }\n\n                auto ia = ic->attributes().cbegin();\n                const auto enda = ic->attributes().cend();\n\n                for (;ia != enda; ++ia)\n                {\n                    if (ia->id() == 0x0055) // Present Value\n                    {\n                        if (ia->numericValue().real < 0.0f || ia->numericValue().real > 100.0f)\n                        {\n                            // invalid value range\n                            break;\n                        }\n\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                        int lift = 100 - int(ia->numericValue().real);\n                        bool open = lift < 100;\n                        if (lightNode->setValue(RStateLift, lift))\n                        {\n                            pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                        }\n                        lightNode->setValue(RStateOpen, open);\n\n                        // FIXME: deprecate\n                        quint8 level = 254 * lift / 100;\n                        bool on = level > 0;\n                        lightNode->setValue(RStateBri, level);\n                        lightNode->setValue(RStateOn, on);\n                        // END FIXME: deprecate\n\n                        break;\n                    }\n                }\n            }\n            // This code can potentially be removed here and covered by fan_control.cpp\n            else if (ic->id() == FAN_CONTROL_CLUSTER_ID && (event.clusterId() == FAN_CONTROL_CLUSTER_ID))\n            {\n                std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n                for (;ia != enda; ++ia)\n                {\n                    if (ia->id() == 0x0000) // Fan Mode\n                    {\n                        lightNode->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n\n                        uint8_t mode = ia->numericValue().u8;\n                        lightNode->setValue(RStateSpeed, mode);\n                    }\n                }\n            }\n        }\n\n        break;\n    }\n\n    if (updated)\n    {\n        updateLightEtag(lightNode);\n        lightNode->setNeedSaveDatabase(true);\n        saveDatabaseItems |= DB_LIGHTS;\n    }\n\n    return lightNode;\n}\n\n/*! Returns a LightNode for a given MAC or NWK address or 0 if not found.\n */\nLightNode *DeRestPluginPrivate::getLightNodeForAddress(const deCONZ::Address &addr, quint8 endpoint)\n{\n    for (LightNode &light: nodes)\n    {\n        if (light.state() != LightNode::StateNormal || !light.node())   { continue; }\n        if (light.haEndpoint().endpoint() != endpoint && endpoint != 0) { continue; }\n        if (!isSameAddress(light.address(), addr))                      { continue; }\n\n        return &light;\n    }\n    return nullptr;\n}\n\n/*! Returns the number of Endpoints of a device.\n */\nint DeRestPluginPrivate::getNumberOfEndpoints(quint64 extAddr)\n{\n    int count = 0;\n    std::vector<LightNode>::iterator i;\n    std::vector<LightNode>::iterator end = nodes.end();\n\n    for (i = nodes.begin(); i != end; ++i)\n    {\n        if (i->address().ext() == extAddr)\n        {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n/*! Returns a LightNode for its given \\p id or uniqueid, or 0 if not found.\n */\nLightNode *DeRestPluginPrivate::getLightNodeForId(const QString &id)\n{\n    std::vector<LightNode>::iterator i;\n    std::vector<LightNode>::iterator end = nodes.end();\n\n    if (id.length() < MIN_UNIQUEID_LENGTH)\n    {\n        for (i = nodes.begin(); i != end; ++i)\n        {\n            if (i->id() == id && i->state() == LightNode::StateNormal)\n            {\n                return &*i;\n            }\n        }\n    }\n    else\n    {\n        for (i = nodes.begin(); i != end; ++i)\n        {\n            if (i->uniqueId() == id && i->state() == LightNode::StateNormal)\n            {\n                return &*i;\n            }\n        }\n    }\n\n    return nullptr;\n}\n\n/*! Returns a Rule for its given \\p id or 0 if not found.\n */\nRule *DeRestPluginPrivate::getRuleForId(const QString &id)\n{\n    std::vector<Rule>::iterator i;\n    std::vector<Rule>::iterator end = rules.end();\n\n    for (i = rules.begin(); i != end; ++i)\n    {\n        if (i->id() == id && i->state() != Rule::StateDeleted)\n        {\n            return &(*i);\n        }\n    }\n\n    end = rules.end();\n\n    for (i = rules.begin(); i != end; ++i)\n    {\n        if (i->id() == id)\n        {\n            return &(*i);\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns a Rule for its given \\p name or 0 if not found.\n */\nRule *DeRestPluginPrivate::getRuleForName(const QString &name)\n{\n    std::vector<Rule>::iterator i;\n    std::vector<Rule>::iterator end = rules.end();\n\n    for (i = rules.begin(); i != end; ++i)\n    {\n        if (i->name() == name)\n        {\n            return &(*i);\n        }\n    }\n\n    return 0;\n}\n\n/*! Checks if a SensorNode is reachable.\n    \\param sensor - the SensorNode\n    \\param event - the related NodeEvent (optional)\n */\nvoid DeRestPluginPrivate::checkSensorNodeReachable(Sensor *sensor, const deCONZ::NodeEvent *event)\n{\n    Q_UNUSED(event);\n    if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n    {\n        return;\n    }\n\n    bool updated = false;\n    bool reachable = false;\n    QDateTime now = QDateTime::currentDateTime();\n\n    if (!sensor->fingerPrint().hasEndpoint())\n    {\n        reachable = true; // assumption for GP device\n    }\n    if (sensor->node() && !sensor->node()->nodeDescriptor().receiverOnWhenIdle() &&\n        sensor->lastRx().isValid() &&\n        sensor->lastRx().secsTo(now) < (60 * 60 * 24)) // if end device was active in last 24 hours\n    {\n        reachable = true;\n    }\n    else if (sensor->node() && !sensor->node()->isZombie())\n    {\n        if (sensor->lastRx().isValid() && sensor->lastRx().secsTo(now) < (60 * 60 * 24))\n        {\n            reachable = true;\n        }\n    }\n\n    ResourceItem *item = sensor->item(RConfigReachable);\n\n    if (reachable)\n    {\n        if (item && !item->toBool())\n        {\n            // the node existed before\n            // refresh all with new values\n            DBG_Printf(DBG_INFO_L2, \"SensorNode id: %s (%s) available\\n\", qPrintable(sensor->id()), qPrintable(sensor->name()));\n            if (sensor->node() && sensor->node()->nodeDescriptor().receiverOnWhenIdle())\n            {\n                sensor->setNextReadTime(READ_BINDING_TABLE, queryTime);\n                sensor->enableRead(READ_BINDING_TABLE/* | READ_MODEL_ID | READ_SWBUILD_ID | READ_VENDOR_NAME*/);\n                queryTime = queryTime.addSecs(5);\n            }\n            //sensor->setLastRead(READ_BINDING_TABLE, idleTotalCounter);\n            //checkSensorBindingsForAttributeReporting(sensor);\n\n            updated = true;\n        }\n\n        auto *device = DEV_GetDevice(m_devices, sensor->address().ext());\n        const bool devManaged = device && device->managed();\n\n        if (!DEV_TestStrict() && !devManaged)\n        {\n            if (sensor->type() == QLatin1String(\"ZHATime\") && !sensor->mustRead(READ_TIME))\n            {\n                std::vector<quint16>::const_iterator ci = sensor->fingerPrint().inClusters.begin();\n                std::vector<quint16>::const_iterator cend = sensor->fingerPrint().inClusters.end();\n                for (;ci != cend; ++ci)\n                {\n                    if (*ci == TIME_CLUSTER_ID)\n                    {\n                        NodeValue val = sensor->getZclValue(*ci, 0x0000); // Time\n                        if (!val.timestamp.isValid() || val.timestamp.secsTo(now) >= 6 * 3600)\n                        {\n                            DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: set READ_TIME from checkSensorNodeReachable()\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()));\n                            sensor->setNextReadTime(READ_TIME, queryTime);\n                            sensor->setLastRead(READ_TIME, idleTotalCounter);\n                            sensor->enableRead(READ_TIME);\n                            queryTime = queryTime.addSecs(1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        if (item && item->toBool())\n        {\n            DBG_Printf(DBG_INFO, \"SensorNode id: %s (%s) no longer available\\n\", qPrintable(sensor->id()), qPrintable(sensor->name()));\n            updated = true;\n        }\n    }\n\n    if (item && (item->toBool() != reachable || !item->lastSet().isValid()))\n    {\n        item->setValue(reachable);\n        Event e(RSensors, RConfigReachable, sensor->id(), item);\n        enqueueEvent(e);\n    }\n\n    if (updated)\n    {\n        updateSensorEtag(sensor);\n    }\n}\n\n/*! On reception of an group command, check that the config.group entries are set properly.\n\n    - This requires the DDF has { \"meta\": { \"group.endpoints\": [<endpoints>] }} set,\n      or as alternative the DDF has group bindings specified.\n    - This takes into account if there are also matching bindings set in the DDF.\n    - \"auto\" entries are replaced based on the index in group.ednpoints.\n    - Existing group entries are replaced if the device hasn't configured bindings in the DDF.\n */\nvoid DEV_CheckConfigGroupIndication(Resource *rsub, uint8_t srcEndpoint, uint dstGroup, const DeviceDescription::SubDevice &ddfSubDevice)\n{\n    if (!rsub || !rsub->parentResource())\n    {\n        return;\n    }\n\n    ResourceItem *configGroup = rsub->item(RConfigGroup);\n    if (!configGroup)\n    {\n        return;\n    }\n\n    const auto ddfItem = std::find_if(ddfSubDevice.items.cbegin(), ddfSubDevice.items.cend(),\n                                      [configGroup](const auto &x){ return x.descriptor.suffix == RConfigGroup; });\n\n    if (ddfItem == ddfSubDevice.items.cend())\n    {\n        return;\n    }\n\n    Device *device = static_cast<Device*>(rsub->parentResource());\n\n    QVariantList epList;\n    if (ddfSubDevice.meta.contains(QLatin1String(\"group.endpoints\")))\n    {\n        epList = ddfSubDevice.meta.value(QLatin1String(\"group.endpoints\")).toList();\n    }\n    else if (ddfItem->defaultValue.toString().contains(QLatin1String(\"auto\")))\n    {\n        // try to extract from bindings, todo cache\n        for (const auto &bnd : device->bindings())\n        {\n            const QVariant ep(uint(bnd.srcEndpoint));\n            if (bnd.isGroupBinding && !epList.contains(ep))\n            {\n               epList.push_back(ep);\n            }\n        }\n    }\n\n    if (epList.isEmpty())\n    {\n        return;\n    }\n\n    bool updated = false;\n    QStringList groupList = configGroup->toString().split(',', SKIP_EMPTY_PARTS);\n\n    for (int i = 0; i < epList.size(); i++) // i is index in config.group\n    {\n        if (epList[i].toUInt() != srcEndpoint)\n        {\n            continue;\n        }\n\n        if (i >= groupList.size())\n        {\n            // more entries in group.endpoints as in config.group\n            break;\n        }\n\n        QString groupId = QString::number(dstGroup);\n\n        if (groupList[i] == groupId)\n        {\n            return; // verified\n        }\n\n        if (groupList[i] == QLatin1String(\"null\"))\n        {\n            return; // ignore\n        }\n\n        if (groupList[i] == QLatin1String(\"auto\"))\n        {\n            // already receiving group casts for the source endpoint\n            // repleace auto with group id\n            groupList[i] = groupId;\n            updated = true;\n            break;\n        }\n\n        // at this point groupList[i] has a group which is different from the received one\n\n        for (const auto &bnd : device->bindings())\n        {\n            if (bnd.isGroupBinding && bnd.srcEndpoint == srcEndpoint && bnd.configGroup == i)\n            {\n                // don't overwrite config.group, device supports bindings and maintains\n                // what's configured in config.group\n                return;\n            }\n        }\n\n        DBG_Printf(DBG_DDF, \"config.group at index %d changed, ep: %u, %u --> %u\\n\", i, unsigned(srcEndpoint), groupList[i].toUInt(), dstGroup);\n\n        // no suitable binding found, repleace\n        groupList[i] = groupId;\n        updated = true;\n        break;\n    }\n\n    if (updated)\n    {\n        configGroup->setValue(groupList.join(','));\n        DB_StoreSubDeviceItem(rsub, configGroup);\n\n        if (rsub->prefix() == RSensors)\n        {\n            Sensor *s = static_cast<Sensor*>(rsub);\n            if (s)\n            {\n                s->setNeedSaveDatabase(true);\n                plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n}\n\nvoid DeRestPluginPrivate::checkSensorButtonEvent(Sensor *sensor, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    DBG_Assert(sensor != nullptr);\n\n    if (!sensor)\n    {\n        return;\n    }\n\n    if (ind.clusterId() == OTAU_CLUSTER_ID)\n    {\n        return;\n    }\n\n    bool checkReporting = false;\n    bool checkClientCluster = false;\n    bool doLegacyGroupStuff = true;\n\n    const ButtonMap *buttonMapEntry = nullptr;\n\n    if (!isValid(sensor->buttonMapRef())) // TODO sensor.hasButtonMap()\n    {\n        buttonMapEntry = BM_ButtonMapForProduct(productHash(sensor), buttonMaps, buttonProductMap);\n        if (buttonMapEntry)\n        {\n            sensor->setButtonMapRef(buttonMapEntry->buttonMapRef);\n\n            // fix sensor.mode legacy cruft, if the complete button map only uses one mode\n            // (true for most switches) set it as sensor.mode\n            uint modes = 0;\n            uint modesCount = 0;\n\n            for (const auto &btn : buttonMapEntry->buttons)\n            {\n                if ((modes & (1 << btn.mode)) == 0)\n                {\n                    modes |= 1 << btn.mode;\n                    modesCount++;\n                }\n            }\n\n            if (modesCount == 1 && !buttonMapEntry->buttons.empty())\n            {\n                if (buttonMapEntry->buttons[0].mode != sensor->mode())\n                {\n                    sensor->setMode(Sensor::SensorMode(buttonMapEntry->buttons[0].mode));\n                    updateSensorEtag(sensor);\n                    sensor->setNeedSaveDatabase(true);\n                }\n            }\n        }\n    }\n    else\n    {\n        buttonMapEntry = BM_ButtonMapForRef(sensor->buttonMapRef(), buttonMaps);\n    }\n\n    QString cluster = \"0x\" + QString(\"%1\").arg(ind.clusterId(), 4, 16, QLatin1Char('0')).toUpper();\n    QString cmd = \"0x\" + QString(\"%1\").arg(zclFrame.commandId(), 2, 16, QLatin1Char('0')).toUpper();\n    QString addressMode;\n    QString zclPayload = zclFrame.payload().isEmpty() ? \"None\" : qPrintable(zclFrame.payload().toHex().toUpper());\n    quint8 pl0 = zclFrame.payload().isEmpty() ? 0 : zclFrame.payload().at(0);\n\n    if (ind.dstAddress().isNwkUnicast()) { addressMode = \", unicast to: 0x\" + QString(\"%1\").arg(ind.dstAddress().nwk(), 4, 16, QLatin1Char('0')).toUpper(); }\n    else if (ind.dstAddressMode() == deCONZ::ApsGroupAddress) { addressMode = \", broadcast to: 0x\" + QString(\"%1\").arg(ind.dstAddress().group(), 4, 16, QLatin1Char('0')).toUpper(); }\n    else { addressMode = \", unknown\"; }\n\n    if (!btnMapClusters.key(ind.clusterId()).isEmpty())\n    {\n        QString val = btnMapClusters.key(ind.clusterId());\n        QMap<QString, quint16> temp = btnMapClusterCommands.value(val);\n        cluster = val + \" (\" + cluster + \")\";\n\n        if (!temp.empty() && !temp.key(zclFrame.commandId()).isEmpty()) { cmd = temp.key(zclFrame.commandId()) + \" (\" + cmd + \")\"; }\n    }\n\n    checkInstaModelId(sensor);\n\n    if (!buttonMapEntry || buttonMapEntry->buttons.empty())\n    {\n        DBG_Printf(DBG_INFO_L2, \"[INFO] - No button map for: %s%s, endpoint: 0x%02X, cluster: %s, command: %s, payload: %s, zclSeq: %u\\n\",\n            qPrintable(sensor->modelId()), qPrintable(addressMode), ind.srcEndpoint(), qPrintable(cluster), qPrintable(cmd), qPrintable(zclPayload), zclFrame.sequenceNumber());\n        return;\n    }\n\n    {\n        Device *device = static_cast<Device*>(sensor->parentResource());\n        if (device && device->managed())\n        {\n            // check if group configuration is handled by DDF\n            const auto &ddfSubDevice = DeviceDescriptions::instance()->getSubDevice(sensor);\n\n            if (ddfSubDevice.isValid())\n            {\n                doLegacyGroupStuff = false;\n                if (ind.dstAddressMode() == deCONZ::ApsGroupAddress)\n                {\n                    // TODO make this async as event and handle later\n                    DEV_CheckConfigGroupIndication(sensor, ind.srcEndpoint(), ind.dstAddress().group(), ddfSubDevice);\n                }\n            }\n        }\n    }\n\n    if (!doLegacyGroupStuff)\n    {\n        // DDF managed devices handle this in another place\n    }\n    // Busch-Jaeger\n    else if (sensor->modelId() == QLatin1String(\"RM01\") || sensor->modelId() == QLatin1String(\"RB01\"))\n    {\n        // setup during add sensor\n    }\n    else if (sensor->modelId() == QLatin1String(\"TRADFRI remote control\"))\n    {\n        checkReporting = true;\n        if (sensor->mode() != Sensor::ModeColorTemperature) // only supported mode yet\n        {\n            sensor->setMode(Sensor::ModeColorTemperature);\n            updateSensorEtag(sensor);\n        }\n\n        if (sensor->fingerPrint().profileId == HA_PROFILE_ID) // new ZB3 firmware\n        {\n            if (ind.dstAddressMode() == deCONZ::ApsGroupAddress && ind.dstAddress().group() == 0)\n            {\n                checkClientCluster = true;\n                ResourceItem *item = sensor->item(RConfigGroup);\n                if (!item || (item && (item->toString() == QLatin1String(\"0\") || item->toString().isEmpty())))\n                {\n                    // still default group, create unique group and binding\n                    checkSensorGroup(sensor);\n                }\n            }\n        }\n    }\n    else if (sensor->modelId() == QLatin1String(\"TRADFRI wireless dimmer\"))\n    {\n        if (sensor->mode() != Sensor::ModeDimmer && sensor->mode() != Sensor::ModeScenes)\n        {\n            sensor->setMode(Sensor::ModeDimmer);\n        }\n\n        if (sensor->fingerPrint().profileId == HA_PROFILE_ID) // new ZB3 firmware\n        {\n            checkReporting = true;\n            if (ind.dstAddressMode() == deCONZ::ApsGroupAddress && ind.dstAddress().group() == 0)\n            {\n                checkClientCluster = true;\n                ResourceItem *item = sensor->item(RConfigGroup);\n                if (!item || (item && (item->toString() == QLatin1String(\"0\") || item->toString().isEmpty())))\n                {\n                    // still default group, create unique group and binding\n                    checkSensorGroup(sensor);\n                }\n            }\n        }\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI on/off switch\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"TRADFRI SHORTCUT Button\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"Remote Control N2\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"TRADFRI open/close remote\")) ||\n             // sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")) ||\n             sensor->modelId().startsWith(QLatin1String(\"TRADFRI motion sensor\")))\n    {\n        checkReporting = true;\n        if (ind.dstAddressMode() == deCONZ::ApsGroupAddress && ind.dstAddress().group() == 0)\n        {\n            checkClientCluster = true;\n            ResourceItem *item = sensor->item(RConfigGroup);\n            if (!item || (item && (item->toString() == QLatin1String(\"0\") || item->toString().isEmpty())))\n            {\n                // still default group, create unique group and binding\n                checkSensorGroup(sensor);\n            }\n        }\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")))\n    {\n        checkReporting = true;\n    }\n    else if (sensor->modelId() == QLatin1String(\"Remote switch\") || //legrand switch\n             sensor->modelId() == QLatin1String(\"Double gangs remote switch\") || //Legrand micro module\n             sensor->modelId() == QLatin1String(\"Shutters central remote switch\") || // legrand shutter switch\n             sensor->modelId() == QLatin1String(\"Remote motion sensor\") || // legrand motion sensor\n             sensor->modelId() == QLatin1String(\"Remote toggle switch\")) // legrand switch simple and double\n    {\n        checkReporting = true;\n        checkClientCluster = true;\n    }\n    else if (sensor->modelId() == QLatin1String(\"Pocket remote\")) // legrand 4x scene remote\n    {\n        checkReporting = true;\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n             sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\"))) // Osram 4 button remote\n    {\n        checkReporting = true;\n        checkClientCluster = true;\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"ZBT-CCTSwitch-D0001\"))) // LDS remote\n    {\n        checkReporting = true;\n        checkClientCluster = true;\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"ICZB-RM\")) || // icasa remote\n             sensor->modelId().startsWith(QLatin1String(\"ZGR904-S\")) || // Envilar remote\n             sensor->modelId().startsWith(QLatin1String(\"RGBGenie ZB-5\")) || // RGBGenie remote control\n             sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY\")) || // RGBGenie ZB-5001\n             sensor->modelId().startsWith(QLatin1String(\"ZG2833PAC\"))) // Sunricher C4\n\n    {\n        checkReporting = true;\n        checkClientCluster = true;\n    }\n    else if (sensor->modelId().startsWith(QLatin1String(\"TS0215\")) || // Tuya remote\n             sensor->modelId().startsWith(QLatin1String(\"RC 110\")) || // innr remote\n             sensor->modelId().startsWith(QLatin1String(\"RC_V14\")) || // Heiman remote\n             sensor->modelId() == QLatin1String(\"URC4450BC0-X-R\") ||  // Xfinity Keypad XHK1-UE\n             sensor->modelId() == QLatin1String(\"3405-L\") ||          // IRIS 3405-L Keypad\n             sensor->modelId().startsWith(QLatin1String(\"RC-EM\")))   // Heiman remote\n    {\n        checkClientCluster = true;\n    }\n    else if (ind.dstAddressMode() == deCONZ::ApsGroupAddress)\n    {\n    }\n    else if (sensor->modelId().endsWith(QLatin1String(\"86opcn01\"))) // Aqara Opple\n    {\n        checkReporting = true;\n    }\n    else if (sensor->modelId() == QLatin1String(\"Bell\")) //Sage doorbell sensor\n    {\n        if (ind.dstAddressMode() == deCONZ::ApsGroupAddress && ind.dstAddress().group() == 0)\n        {\n            checkClientCluster = true;\n            checkReporting = true;\n            ResourceItem *item = sensor->item(RConfigGroup);\n            if (!item || (item && (item->toString() == QLatin1String(\"0\") || item->toString().isEmpty())))\n            {\n                checkSensorGroup(sensor); // still default group, create unique group and binding\n            }\n        }\n    }\n    else if (sensor->modelId() == QLatin1String(\"HG06323\")) // LIDL Remote Control\n    {\n        checkReporting = true;\n    }\n\n    if (zclFrame.sequenceNumber() == sensor->previousSequenceNumber)\n    {\n        // useful in general but limit scope to known problematic devices\n        if ((sensor->node() && sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_IKEA) ||\n            isTuyaManufacturerName(sensor->manufacturer()) ||\n            // TODO \"HG06323\" can likely be removed after testing,\n            // since the device only sends group casts and we don't expect this to trigger.\n            sensor->modelId() == QLatin1String(\"HG06323\"))\n        {\n            // deCONZ doesn't always send ZCL Default Response to unicast commands, or they can get lost.\n            // in this case some devices re-send the command multiple times\n            DBG_Printf(DBG_INFO_L2, \"Discard duplicated zcl.cmd: 0x%02X, cluster: 0x%04X with zcl.seq: %u for %s / %s\\n\",\n                       zclFrame.commandId(), ind.clusterId(), zclFrame.sequenceNumber(), qPrintable(sensor->manufacturer()), qPrintable(sensor->modelId()));\n            return;\n        }\n        else // warn only\n        {\n            DBG_Printf(DBG_INFO, \"Warning duplicated zcl.cmd: 0x%02X, cluster: 0x%04X with zcl.seq: %u for %s / %s\\n\",\n                       zclFrame.commandId(), ind.clusterId(), zclFrame.sequenceNumber(), qPrintable(sensor->manufacturer()), qPrintable(sensor->modelId()));\n        }\n    }\n\n    sensor->previousSequenceNumber = zclFrame.sequenceNumber();\n\n    if (!doLegacyGroupStuff)\n    {\n        // DDF managed devices handle this in another place\n    }\n    else if ((ind.dstAddressMode() == deCONZ::ApsGroupAddress && ind.dstAddress().group() != 0) &&\n       sensor->modelId() != QLatin1String(\"Pocket remote\") && // Need to prevent this device use group feature, just without avoiding the RConfigGroup creation.\n       !(ind.srcEndpoint() == 2 && sensor->modelId() == QLatin1String(\"Kobold\"))) // managed via REST API and \"auto\" config.group, check src.endpoint:2 to skip modelId check\n    {\n        ResourceItem *item = sensor->addItem(DataTypeString, RConfigGroup);\n\n        quint16 groupId = ind.dstAddress().group();\n\n        QStringList gids;\n        const QString gid = QString::number(groupId);\n\n        if (item)\n        {\n            gids = item->toString().split(',');\n        }\n\n        if (!item) // should always be non null, this check is here to keep static analizer happy\n        {\n\n        }\n        else if (sensor->modelId().startsWith(QLatin1String(\"RC 110\"))) // innr remote\n        {\n            // 7 controller endpoints: 0x01, 0x03, 0x04, ..., 0x08\n            if (gids.length() != 7)\n            {\n                // initialise list of groups: one for each endpoint\n                gids = QStringList();\n                gids << \"0\" << \"0\" << \"0\" << \"0\" << \"0\" << \"0\" << \"0\";\n            }\n\n            // check group corresponding to source endpoint\n            int i = ind.srcEndpoint();\n            i -= i == 1 ? 1 : 2;\n            if (gids.value(i) != gid)\n            {\n                // replace group corresponding to source endpoint\n                gids.replace(i, gid);\n                item->setValue(gids.join(','));\n                sensor->setNeedSaveDatabase(true);\n                updateSensorEtag(sensor);\n                enqueueEvent(Event(RSensors, RConfigGroup, sensor->id(), item));\n            }\n\n            Event e(RSensors, REventValidGroup, sensor->id());\n            enqueueEvent(e);\n        }\n        else if (sensor->modelId().startsWith(QLatin1String(\"ICZB-RM\")) ||          // icasa remote\n                 sensor->modelId().startsWith(QLatin1String(\"ZGR904-S\")) ||         // Envilar remote\n                 sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY\")) ||         // Sunricher remote\n                 sensor->modelId().startsWith(QLatin1String(\"ZG2833PAC\")) ||        // Sunricher C4\n                 sensor->modelId() == QLatin1String(\"4512705\") ||                   // Namron remote control\n                 sensor->modelId() == QLatin1String(\"4512726\") ||                   // Namron rotary switch\n                 sensor->modelId().startsWith(QLatin1String(\"S57003\")) ||           // SLC 4 ch remote switche\n                 sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5001\")) || // RGBGenie remote\n                 sensor->modelId().startsWith(QLatin1String(\"ZGRC-TEUR-\")))         // iluminize wall switch 511.524\n        {\n            if (gids.length() != 5 && sensor->modelId().startsWith(QLatin1String(\"ZGRC-KEY-012\"))) // 5 controller endpoints: 0x01, 0x02, 0x03, 0x04, 0x05\n            {\n                // initialise list of groups: one for each endpoint\n                gids = QStringList();\n                gids << \"0\" << \"0\" << \"0\" << \"0\" << \"0\";\n            }\n            else if (gids.length() != 4) // 4 controller endpoints: 0x01, 0x02, 0x03, 0x04\n            {\n                // initialise list of groups: one for each endpoint\n                gids = QStringList();\n                gids << \"0\" << \"0\" << \"0\" << \"0\";\n            }\n\n            // check group corresponding to source endpoint\n            int i = ind.srcEndpoint();\n            i -= 1;\n            if (gids.value(i) != gid)\n            {\n                // replace group corresponding to source endpoint\n                gids.replace(i, gid);\n                item->setValue(gids.join(','));\n                sensor->setNeedSaveDatabase(true);\n                updateSensorEtag(sensor);\n                enqueueEvent(Event(RSensors, RConfigGroup, sensor->id(), item));\n            }\n\n            Event e(RSensors, REventValidGroup, sensor->id());\n            enqueueEvent(e);\n        }\n        else if (sensor->modelId().startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\n        {\n            bool changed = true;\n            if (gids.length() != 3)\n            {\n                gids = QStringList();\n                gids << \"0\" << \"0\" << \"0\";\n            }\n\n            if (gids.contains(gid))\n            {\n                changed = false;\n            }\n            else if (gids.value(1) == \"0\" && gids.value(0) == QString::number(groupId - 2))\n            {\n                gids.replace(1, QString::number(groupId - 1));\n                gids.replace(2, gid);\n            }\n            else if (gids.value(1) == \"0\" && gids.value(0) == QString::number(groupId - 1))\n            {\n                gids.replace(1, gid);\n            }\n            else if (gids.value(1) == \"0\" && gids.value(0) == QString::number(groupId + 2))\n            {\n                gids.replace(0, gid);\n                gids.replace(1, QString::number(groupId + 1));\n                gids.replace(2, QString::number(groupId + 2));\n            }\n            else if (gids.value(1) == \"0\" && gids.value(0) == QString::number(groupId + 1))\n            {\n                gids.replace(0, gid);\n                gids.replace(1, QString::number(groupId + 1));\n            }\n            else if (gids.value(2) == \"0\" && gids.value(1) == QString::number(groupId - 1))\n            {\n                gids.replace(2, gid);\n            }\n            else if (gids.value(2) == \"0\" && gids.value(0) == QString::number(groupId + 1))\n            {\n                gids.replace(0, gid);\n                gids.replace(1, QString::number(groupId + 1));\n                gids.replace(2, QString::number(groupId + 1));\n            }\n            else\n            {\n                gids.replace(0, gid);\n                gids.replace(1, \"0\");\n                gids.replace(2, \"0\");\n            }\n\n            if (changed)\n            {\n                item->setValue(gids.join(','));\n                sensor->setNeedSaveDatabase(true);\n                updateSensorEtag(sensor);\n                enqueueEvent(Event(RSensors, RConfigGroup, sensor->id(), item));\n            }\n\n            Event e(RSensors, REventValidGroup, sensor->id());\n            enqueueEvent(e);\n        }\n        else\n        {\n            if (!gids.contains(gid))\n            {\n                item->setValue(gid);\n                sensor->setNeedSaveDatabase(true);\n                updateSensorEtag(sensor);\n                enqueueEvent(Event(RSensors, RConfigGroup, sensor->id(), item));\n            }\n\n            Event e(RSensors, REventValidGroup, sensor->id());\n            enqueueEvent(e);\n        }\n    }\n\n    bool ok = false;\n    for (const auto &buttonMap : buttonMapEntry->buttons)\n    {\n        if (buttonMap.mode != Sensor::ModeNone && !ok)\n        {\n            if (buttonMap.mode == sensor->mode() &&\n                buttonMap.endpoint == ind.srcEndpoint() &&\n                buttonMap.clusterId == ind.clusterId() &&\n                buttonMap.zclCommandId == zclFrame.commandId())\n            {\n                ok = true;\n\n                //Tuya\n                if (ind.clusterId() == ONOFF_CLUSTER_ID && zclFrame.commandId() == 0xFD)\n                {\n                    ok = false;\n                    if (zclFrame.payload().size() >= 1)\n                    {\n                        quint8 level = zclFrame.payload().at(0);\n                        ok = buttonMap.zclParam0 == level;\n                    }\n                }\n                else if (zclFrame.isProfileWideCommand() &&\n                    zclFrame.commandId() == deCONZ::ZclReportAttributesId &&\n                    zclFrame.payload().size() >= 4)\n                {\n                    QDataStream stream(zclFrame.payload());\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    quint16 attrId;\n                    quint8 dataType;\n                    stream >> attrId;\n                    stream >> dataType;\n\n                    // Xiaomi\n                    if (ind.clusterId() == XIAOMI_CLUSTER_ID && zclFrame.payload().size() > 12)\n                    {\n                        ok = false;\n                    }\n                    else if (ind.clusterId() == ONOFF_CLUSTER_ID && sensor->manufacturer() == QLatin1String(\"LUMI\"))\n                    {\n                        quint8 value;\n                        stream >> value;\n                        ok = false;\n                        // payload: u16 attrId, u8 datatype, u8 data\n                        if (attrId == 0x0000 && dataType == deCONZ::ZclBoolean && // onoff attribute\n                            buttonMap.zclParam0 == value)\n                        {\n                            ok = true;\n                        }\n                        else if (attrId == 0x8000 && dataType == deCONZ::Zcl8BitUint && // custom attribute for multi press\n                            buttonMap.zclParam0 == value)\n                        {\n                            ok = true;\n                        }\n\n                        // the round button (lumi.sensor_switch) sends a release command regardless if it is a short press or a long release\n                        // figure it out here to decide if it is a short release (1002) or a long release (1003)\n                        if (ok && sensor->modelId() == QLatin1String(\"lumi.sensor_switch\"))\n                        {\n                            const QDateTime now = QDateTime::currentDateTime();\n\n                            if (buttonMap.button == (S_BUTTON_1 + S_BUTTON_ACTION_INITIAL_PRESS))\n                            {\n                                sensor->durationDue = now.addMSecs(500); // enable generation of 1001 (hold)\n                                checkSensorsTimer->start(CHECK_SENSOR_FAST_INTERVAL);\n                            }\n                            else if (buttonMap.button == (S_BUTTON_1 + S_BUTTON_ACTION_SHORT_RELEASED))\n                            {\n                                sensor->durationDue = QDateTime(); // disable generation of 1001 (hold)\n\n                                ResourceItem *item = sensor->item(RStateButtonEvent);\n                                if (item && (item->toNumber() == (S_BUTTON_1 + S_BUTTON_ACTION_INITIAL_PRESS) ||\n                                             item->toNumber() == (S_BUTTON_1 + S_BUTTON_ACTION_HOLD)))\n                                {\n                                    if (item->toNumber() == (S_BUTTON_1 + S_BUTTON_ACTION_HOLD) || // hold already triggered -> long release\n                                        item->lastSet().msecsTo(now) > 400) // over 400 ms since initial press? -> long release\n                                    {\n                                        ok = false; // force long release button event\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ((ind.clusterId() == DOOR_LOCK_CLUSTER_ID && sensor->manufacturer() == QLatin1String(\"LUMI\")) ||\n                             ind.clusterId() == MULTISTATE_INPUT_CLUSTER_ID)\n                    {\n                        ok = false;\n                        if (attrId == MULTI_STATE_INPUT_PRESENT_VALUE_ATTRIBUTE_ID &&\n                            dataType == deCONZ::Zcl16BitUint)\n                        {\n                            quint16 value;\n                            stream >> value;\n                            ok = buttonMap.zclParam0 == value;\n                        }\n                    }\n                    else if (attrId == XIAOYAN_ATTRID_ROTATION_ANGLE && ind.clusterId() == XIAOYAN_CLUSTER_ID && sensor->modelId() == QLatin1String(\"TERNCY-SD01\"))\n                    {\n                        qint16 value;\n                        stream >> value;\n                        ok = false;\n\n                        if (value > 0)\n                        {\n                            ok = buttonMap.zclParam0 == 0; // Rotate clockwise\n                        }\n                        else\n                        {\n                            ok = buttonMap.zclParam0 == 1; // Rotate counter-clockwise\n                        }\n                    }\n                }\n                else if (zclFrame.isProfileWideCommand() &&\n                         zclFrame.commandId() == deCONZ::ZclWriteAttributesId &&\n                         zclFrame.payload().size() >= 4)\n                {\n                    QDataStream stream(zclFrame.payload());\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    quint16 attrId;\n                    quint8 dataType;\n                    quint8 pl3;\n                    stream >> attrId;\n                    stream >> dataType;\n                    stream >> pl3;\n\n                    if (ind.clusterId() == BASIC_CLUSTER_ID && sensor->modelId().startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\n                    {\n                        ok = attrId == 0x4005 && dataType == deCONZ::Zcl8BitUint && buttonMap.zclParam0 == pl3;\n                    }\n                }\n                else if (zclFrame.isProfileWideCommand())\n                {\n                }\n                else if (ind.clusterId() == SCENE_CLUSTER_ID && zclFrame.commandId() == 0x05) // recall scene\n                {\n                    ok = false; // payload: groupId (uint16) , sceneId (uint8)\n                    if (zclFrame.payload().size() >= 3)\n                    {\n                        // This device use same sceneID but different groupID : EDFF010000 ECFF010000 EBFF010000 EAFF010000\n                        if (sensor->modelId() == QLatin1String(\"Pocket remote\"))\n                        {\n                            if (buttonMap.zclParam0 == zclFrame.payload().at(0))\n                            {\n                                ok = true;\n                            }\n                        }\n                        else\n                        {\n                            if (buttonMap.zclParam0 == zclFrame.payload().at(2))\n                            {\n                                ok = true;\n                            }\n                        }\n                    }\n                }\n                else if (ind.clusterId() == SCENE_CLUSTER_ID && zclFrame.commandId() == 0x04) // store scene\n                {\n                    ok = false; // payload: groupId, sceneId\n                    if (zclFrame.payload().size() >= 3 && buttonMap.zclParam0 == zclFrame.payload().at(2))\n                    {\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == SCENE_CLUSTER_ID && zclFrame.manufacturerCode() == VENDOR_IKEA) // IKEA non-standard scene\n                {\n                    ok = false;\n                    if (zclFrame.commandId() == 0x07 || // short release\n                        zclFrame.commandId() == 0x08)   // hold\n                    {\n                        if (zclFrame.payload().size() >= 1 && buttonMap.zclParam0 == zclFrame.payload().at(0)) // next, prev scene\n                        {\n                            sensor->previousDirection = buttonMap.zclParam0;\n                            ok = true;\n                        }\n                    }\n                    else if (zclFrame.commandId() == 0x09) // long release\n                    {\n                        if (zclFrame.payload().at(0) == 0x00 && zclFrame.payload().at(1) == 0x00)\n                        {\n                            sensor->previousCommandId = 0x09;\n                            ResourceItem *item = sensor->item(RStateButtonEvent);\n                            if (item)\n                            {\n                                item->setLastZclReport(deCONZ::steadyTimeRef());\n                            }\n                        }\n                        else\n                        {\n                            sensor->previousCommandId = 0x00;\n                            if (buttonMap.zclParam0 == sensor->previousDirection)\n                            {\n                                sensor->previousDirection = 0xFF;\n                                ok = true;\n                            }\n                        }\n\n                    }\n                }\n                else if (ind.clusterId() == ONOFF_CLUSTER_ID && sensor->previousCommandId == 0x09 && sensor->modelId() == QLatin1String(\"Remote Control N2\"))\n                {\n                    // for left and right buttons long press, the Ikea Styrbar sends:\n                    // 0x09 -> ON -> 0x07 -> 0x08 -> 0x09\n                    // disable to not trigger 1002 and 2002 button events, if last 0x09 was received within 2 seconds\n                    // check that ON is received within 2 seconds is needed, since user can abort long press after 0x09 command\n\n                    ResourceItem *item = sensor->item(RStateButtonEvent);\n\n                    if (item && deCONZ::steadyTimeRef() - item->lastZclReport() < deCONZ::TimeMs{2000})\n                    {\n                        ok = false; // part of long press\n                    }\n\n                    sensor->previousCommandId = 0xFF;\n                }\n                else if (ind.clusterId() == LEVEL_CLUSTER_ID && zclFrame.commandId() == 0x04 && // move to level (with on/off)\n                         sensor->modelId().startsWith(QLatin1String(\"Z3-1BRL\"))) // Lutron Aurora Friends-of-Hue dimmer\n                {\n                    // This code is for handling the button map for the Aurora, until we figure out how to activate the 0xFC00 cluster.\n                    ok = false;\n                    if (zclFrame.payload().size() >= 2)\n                    {\n                        quint8 level = zclFrame.payload().at(0);\n                        quint8 tt = zclFrame.payload().at(1);\n                        if (tt == 7) // button pressed\n                        {\n                            ok = buttonMap.zclParam0 == 0; // Toggle\n                        }\n                        else if (tt == 2) // dial turned\n                        {\n                            if      (sensor->previousDirection < level) ok = buttonMap.zclParam0 == 1; // DimUp\n                            else if (sensor->previousDirection > level) ok = buttonMap.zclParam0 == 2; // DimDown\n                            else if (level == 0xFF)                     ok = buttonMap.zclParam0 == 1; // DimUp\n                            else if (level == 2)                        ok = buttonMap.zclParam0 == 2; // DimDown\n                        }\n                        if (ok)\n                        {\n                            sensor->previousDirection = level;\n                        }\n                    }\n                }\n                else if (ind.clusterId() == LEVEL_CLUSTER_ID && zclFrame.commandId() == 0x04) // move to level (with on/off)\n                {\n                    ok = false;\n                    if (zclFrame.payload().size() >= 1)\n                    {\n                        quint8 level = zclFrame.payload().at(0);\n                        ok = buttonMap.zclParam0 == level;\n\n                    }\n                }\n                else if (ind.clusterId() == LEVEL_CLUSTER_ID &&\n                         (zclFrame.commandId() == 0x01 ||  // move\n                          zclFrame.commandId() == 0x02 ||  // step\n                          zclFrame.commandId() == 0x05 ||  // move (with on/off)\n                          zclFrame.commandId() == 0x06))   // step (with on/off)\n                {\n                    ok = false;\n                    if (zclFrame.payload().size() >= 1 && buttonMap.zclParam0 == zclFrame.payload().at(0)) // direction\n                    {\n                        sensor->previousDirection = zclFrame.payload().at(0);\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == LEVEL_CLUSTER_ID &&\n                           (zclFrame.commandId() == 0x03 ||  // stop\n                            zclFrame.commandId() == 0x07))  // stop (with on/off)\n                {\n                    ok = false;\n                    if (buttonMap.zclParam0 == sensor->previousDirection) // direction of previous move/step\n                    {\n                        sensor->previousDirection = 0xFF;\n                        ok = true;\n                    }\n                    if (buttonMap.zclParam0 != sensor->previousDirection && // direction of previous move/step\n                        (sensor->modelId().startsWith(QLatin1String(\"RGBgenie ZB-5121\")) || // Device sends cmd = 7 + param = 0 for dim up/down\n                        sensor->modelId().startsWith(QLatin1String(\"ZBT-DIMSwitch-D0001\")) ||\n                        sensor->modelId().startsWith(QLatin1String(\"ZGRC-TEUR-003\"))))\n                    {\n                        sensor->previousDirection = 0xFF;\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == WINDOW_COVERING_CLUSTER_ID)\n                {\n                    ok = false;\n                    if (zclFrame.commandId() == 0x00 || zclFrame.commandId() == 0x01) // Open, Close\n                    {\n                        sensor->previousDirection = zclFrame.commandId();\n                        ok = true;\n                    }\n                    else if (zclFrame.commandId() == 0x02) // Stop\n                    {\n                        if (buttonMap.zclParam0 == sensor->previousDirection)\n                        {\n                            sensor->previousDirection = 0xFF;\n                            ok = true;\n                        }\n                    }\n                }\n                else if (ind.clusterId() == IAS_ZONE_CLUSTER_ID)\n                {\n                    ok = false;\n                    // following works for Samjin button\n                    if (zclFrame.payload().size() == 6 && buttonMap.zclParam0 == zclFrame.payload().at(0))\n                    {\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == IAS_ACE_CLUSTER_ID)\n                {\n                    ok = false;\n                    if (zclFrame.commandId() == 0x00 && zclFrame.payload().size() == 3 && buttonMap.zclParam0 == zclFrame.payload().at(0))\n                    {\n                        ok = true;\n                    }\n                    else if ((zclFrame.commandId() == 0x02 || zclFrame.commandId() == 0x03 || zclFrame.commandId() == 0x04) && zclFrame.payload().isEmpty())\n                    {\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID &&\n                         zclFrame.commandId() == 0x07 && zclFrame.payload().size() >= 4 && // Move to Color\n                         sensor->modelId().startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\n                {\n                    quint16 x;\n                    quint16 y;\n                    qint16 a = 0xFFFF;\n                    QDataStream stream(zclFrame.payload());\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    stream >> x;\n                    stream >> y;\n\n                    switch (x) {\n                        case 19727: a =   0; break; // North\n                        case 22156: a =  10; break;\n                        case 24216: a =  20; break;\n                        case 25909: a =  30; break;\n                        case 27663: a =  40; break;\n                        case 29739: a =  50; break;\n                        case 32302: a =  60; break;\n                        case 35633: a =  70; break;\n                        case 39898: a =  80; break;\n                        case 45875: a =  90; break; // East\n                        case 42184: a = 100; break;\n                        case 39202: a = 110; break;\n                        case 36633: a = 120; break;\n                        case 34493: a = 130; break;\n                        case 32602: a = 140; break;\n                        case 30993: a = 150; break;\n                        case 29270: a = 160; break;\n                        case 27154: a = 170; break;\n                        case 24420: a = 180; break; // South\n                        case 20648: a = 190; break;\n                        case 11111: a = 200; break;\n                        case  7208: a = 210; break;\n                        case  7356: a = 220; break;\n                        case  7451: a = 230; break;\n                        case  7517: a = 240; break;\n                        case  7563: a = 250; break;\n                        case  7599: a = 260; break;\n                        case  7627: a = 270; break; // West\n                        case  7654: a = 280; break;\n                        case  7684: a = 290; break;\n                        case  7719: a = 300; break;\n                        case  7760: a = 310; break;\n                        case  7808: a = 320; break;\n                        case  7864: a = 330; break;\n                        case 12789: a = 340; break;\n                        case 16664: a = 350; break;\n                        default: ok = false; break;\n                    }\n\n                    if (ok)\n                    {\n                        ResourceItem *item = sensor->item(RStateX);\n                        if (item)\n                        {\n                            item->setValue(x);\n                            enqueueEvent(Event(RSensors, RStateX, sensor->id(), item));\n                        }\n                        item = sensor->item(RStateY);\n                        if (item)\n                        {\n                            item->setValue(y);\n                            enqueueEvent(Event(RSensors, RStateY, sensor->id(), item));\n                        }\n                        item = sensor->item(RStateAngle);\n                        if (item)\n                        {\n                            item->setValue(a);\n                            enqueueEvent(Event(RSensors, RStateAngle, sensor->id(), item));\n                        }\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO, \"unknown xy values for: %s ep: 0x%02X cl: 0x%04X cmd: 0x%02X xy: (%u, %u)\\n\",\n                                   qPrintable(sensor->modelId()), ind.srcEndpoint(), ind.clusterId(), zclFrame.commandId(), x, y);\n                    }\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID &&\n                         zclFrame.commandId() == 0x0a && zclFrame.payload().size() >= 2 && // Move to Color Temperature\n                         sensor->modelId().startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\n                {\n                    quint16 ct;\n                    QDataStream stream(zclFrame.payload());\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    stream >> ct;\n\n                    if      (sensor->previousCt < ct) ok = buttonMap.zclParam0 == 0; // CtUp\n                    else if (sensor->previousCt > ct) ok = buttonMap.zclParam0 == 1; // CtDown\n                    else if (ct == 370)               ok = buttonMap.zclParam0 == 0; // DimUp\n                    else if (ct == 153)               ok = buttonMap.zclParam0 == 1; // DimDown\n                    if (ok)\n                    {\n                        sensor->previousCt = ct;\n                    }\n\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID &&\n                         zclFrame.commandId() == 0x0a && zclFrame.payload().size() >= 2 && // Move to Color Temperature\n                         sensor->modelId().startsWith(QLatin1String(\"ZBT-CCTSwitch-D0001\")))\n                {\n                        if (buttonMap.zclParam0 != pl0)\n                        {\n                            ok = false;\n                            pl0 = zclFrame.payload().isEmpty() ? 0 : zclFrame.payload().at(1);\n                        }\n                        //ignore the command if previous was button4\n                        if (sensor->previousCommandId == 0x04)\n                        {\n                            ok = false;\n                        }\n                }\n                else if ((ind.clusterId() == COLOR_CLUSTER_ID) &&\n                         (zclFrame.commandId() == 0x4b) &&\n                         sensor->modelId().startsWith(QLatin1String(\"ZBT-CCTSwitch-D0001\")))\n                {\n                    quint8 pl0 = zclFrame.payload().isEmpty() ? 0 : zclFrame.payload().at(0);\n                    if (buttonMap.zclParam0 != pl0)\n                    {\n                        ok = false;\n                    }\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID &&\n                         (zclFrame.commandId() == 0x4b && zclFrame.payload().size() >= 7))  // move color temperature\n                {\n                    ok = false;\n                    // u8 move mode\n                    // u16 rate\n                    // u16 ctmin = 0\n                    // u16 ctmax = 0\n                    quint8 moveMode = zclFrame.payload().at(0);\n                    quint16 param = moveMode;\n\n                    if (moveMode == 0x01 || moveMode == 0x03)\n                    {\n                        sensor->previousDirection = moveMode;\n                    }\n                    else if (moveMode == 0x00)\n                    {\n                        param = sensor->previousDirection;\n                        param <<= 4;\n                    }\n\n                    // byte-2 most likely 0, but include anyway\n                    param |= (quint16)zclFrame.payload().at(2) & 0xff;\n                    param <<= 8;\n                    param |= (quint16)zclFrame.payload().at(1) & 0xff;\n                    if (buttonMap.zclParam0 == param)\n                    {\n                        if (moveMode == 0x00)\n                        {\n                            sensor->previousDirection = 0xFF;\n                        }\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID &&\n                         (zclFrame.commandId() == 0x4c))  // step color temperature\n                {\n                    ok = false;\n                    if (zclFrame.payload().size() >= 1 && buttonMap.zclParam0 == zclFrame.payload().at(0)) // direction\n                    {\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == COLOR_CLUSTER_ID && (zclFrame.commandId() == 0x01 ))  // Move hue command\n                {\n                    // Only used by Osram devices currently\n                    if (sensor->modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                        sensor->modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                        sensor->modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                        sensor->modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\"))) // Osram 4 button remote\n                    {\n                        if (buttonMap.zclParam0 != pl0)\n                        {\n                            ok = false;\n                        }\n                    }\n\n                }\n                else if (ind.clusterId() == SENGLED_CLUSTER_ID)\n                {\n                    ok = false;\n\n                    if (buttonMap.zclParam0 == pl0)\n                    {\n                        ok = true;\n                    }\n                }\n                else if (ind.clusterId() == ADUROLIGHT_CLUSTER_ID || ind.clusterId() == XIAOYAN_CLUSTER_ID)\n                {\n                    ok = false;\n\n                    if (zclFrame.payload().size() > 1 && buttonMap.zclParam0 == zclFrame.payload().at(1))\n                    {\n                        ok = true;\n                    }\n                    else if (zclFrame.payload().size() == 1 && buttonMap.zclParam0 == zclFrame.payload().at(0) && zclFrame.manufacturerCode() == VENDOR_XIAOYAN)\n                    {\n                        ok = true;\n                    }\n                }\n\n                if (ok && buttonMap.button != 0)\n                {\n                    if (!buttonMap.name.isEmpty()) { cmd = buttonMap.name; }\n\n                    DBG_Printf(DBG_INFO, \"[INFO] - Button %u - %s%s, endpoint: 0x%02X, cluster: %s, action: %s, payload: %s, zclSeq: %u\\n\",\n                        buttonMap.button, qPrintable(sensor->modelId()), qPrintable(addressMode), ind.srcEndpoint(), qPrintable(cluster), qPrintable(cmd), qPrintable(zclPayload), zclFrame.sequenceNumber());\n\n                    ResourceItem *item = sensor->item(RStateButtonEvent);\n                    if (item)\n                    {\n                        if (sensor->node() &&\n                            (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_PHILIPS ||\n                             sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_IKEA))\n                        {\n                        }\n                        else if (item->toNumber() == buttonMap.button && ind.dstAddressMode() == deCONZ::ApsGroupAddress)\n                        {\n                            QDateTime now = QDateTime::currentDateTime();\n                            const auto dt = item->lastSet().msecsTo(now);\n\n                            if (dt > 0 && dt < 500)\n                            {\n                                DBG_Printf(DBG_INFO, \"[INFO] - Button %u %s, discard too fast event (dt = %d) %s\\n\", buttonMap.button, qPrintable(cmd), static_cast<int>(dt), qPrintable(sensor->modelId()));\n                                break;\n                            }\n                        }\n\n                        item->setValue(buttonMap.button);\n\n                        Event e(RSensors, RStateButtonEvent, sensor->id(), item);\n                        enqueueEvent(e);\n                        updateSensorEtag(sensor);\n                        sensor->updateStateTimestamp();\n                        sensor->setNeedSaveDatabase(true);\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                    }\n\n                    item = sensor->item(RStatePresence);\n                    if (item)\n                    {\n                        item->setValue(true);\n                        Event e(RSensors, RStatePresence, sensor->id(), item);\n                        enqueueEvent(e);\n                        updateSensorEtag(sensor);\n                        sensor->updateStateTimestamp();\n                        sensor->setNeedSaveDatabase(true);\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n\n                        ResourceItem *item2 = sensor->item(RConfigDuration);\n                        if (item2 && item2->toNumber() > 0)\n                        {\n                            sensor->durationDue = QDateTime::currentDateTime().addSecs(item2->toNumber());\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    //Remember last command id\n    if (sensor->modelId().startsWith(QLatin1String(\"ZBT-CCTSwitch-D0001\"))) // LDS remote\n    {\n        sensor->previousCommandId = zclFrame.commandId();\n    }\n\n    if (checkReporting && sensor->node() &&\n        sensor->lastAttributeReportBind() < (idleTotalCounter - BUTTON_ATTR_REPORT_BIND_LIMIT))\n    {\n        if (checkSensorBindingsForAttributeReporting(sensor))\n        {\n            sensor->setLastAttributeReportBind(idleTotalCounter);\n        }\n        if (sensor->mustRead(READ_BINDING_TABLE))\n        {\n            sensor->setNextReadTime(READ_BINDING_TABLE, queryTime);\n            queryTime = queryTime.addSecs(1);\n        }\n        DBG_Printf(DBG_INFO_L2, \"Force binding of attribute reporting for sensor %s\\n\", qPrintable(sensor->name()));\n    }\n\n    if (checkClientCluster && sensor->node())\n    {\n        checkSensorBindingsForClientClusters(sensor);\n    }\n\n    if (ok)\n    {\n        return;\n    }\n\n    if (sensor->item(RStateButtonEvent))\n    {\n        DBG_Printf(DBG_INFO_L2, \"[INFO] - No button handler for: %s%s, endpoint: 0x%02X, cluster: %s, command: %s, payload: %s, zclSeq: %u\\n\",\n            qPrintable(sensor->modelId()), qPrintable(addressMode), ind.srcEndpoint(), qPrintable(cluster), qPrintable(cmd), qPrintable(zclPayload), zclFrame.sequenceNumber());\n    }\n}\n\n/*! Adds a new sensor node to node cache.\n    Only supported ZLL and HA nodes will be added.\n    \\param node - the base for the SensorNode\n    \\param event - the related NodeEvent (optional)\n */\nvoid DeRestPluginPrivate::addSensorNode(const deCONZ::Node *node, const deCONZ::NodeEvent *event)\n{\n    if (DEV_TestStrict())\n    {\n        return;\n    }\n\n    DBG_Assert(node);\n\n    if (!node)\n    {\n        return;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, node->address().ext());\n\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    { // check existing sensors\n        std::vector<Sensor>::iterator i = sensors.begin();\n        std::vector<Sensor>::iterator end = sensors.end();\n\n        bool pollControlInitialized = false;\n\n        for (; i != end; ++i)\n        {\n            if (i->address().ext() == node->address().ext())\n            {\n                if (i->deletedState() != Sensor::StateNormal)\n                {\n                    continue;\n                }\n\n                if (i->node() != node)\n                {\n                    i->setNode(const_cast<deCONZ::Node*>(node));\n\n                    pushSensorInfoToCore(&*i);\n\n                    // If device has Poll Control cluster, configure it via the first Sensor.\n                    if (!pollControlInitialized && PC_GetPollControlEndpoint(node) > 0)\n                    {\n                        auto *itemPending = i->item(RConfigPending);\n                        if (itemPending)\n                        {\n                            pollControlInitialized = true;\n                            itemPending->setValue(itemPending->toNumber() | R_PENDING_WRITE_POLL_CHECKIN_INTERVAL | R_PENDING_SET_LONG_POLL_INTERVAL);\n                        }\n                    }\n                }\n\n                auto *item = i->item(RStateBattery);\n                if (!item)\n                {\n                    item = i->item(RConfigBattery);\n                }\n\n                if (item && item->toNumber() > 0)\n                {\n                    q_ptr->nodeUpdated(i->address().ext(), QLatin1String(item->descriptor().suffix), QString::number(item->toNumber()));\n                }\n\n                checkSensorNodeReachable(&*i, event);\n            }\n        }\n    }\n\n    if (searchSensorsState != SearchSensorsActive)\n    {\n        return;\n    }\n\n    if (fastProbeAddr.hasExt() && fastProbeAddr.ext() != node->address().ext())\n    {\n        return;\n    }\n\n    // check for new sensors\n    QString modelId;\n    QString manufacturer;\n    auto i = node->simpleDescriptors().cbegin();\n    const auto end = node->simpleDescriptors().cend();\n\n    // Trust and iHorn specific\n    if (node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC && modelId.isEmpty() && i != end)\n    {\n        int inClusterCount = i->inClusters().size();\n        int outClusterCount = i->outClusters().size();\n\n        // check Trust remote control ZYCT-202 or ZLL-NonColorController\n        if (node->simpleDescriptors().size() == 2 &&\n            node->simpleDescriptors()[0].endpoint() == 0x01 &&\n            node->simpleDescriptors()[0].profileId() == ZLL_PROFILE_ID &&\n            node->simpleDescriptors()[0].deviceId() == DEV_ID_ZLL_NON_COLOR_CONTROLLER &&\n            node->simpleDescriptors()[1].endpoint() == 0x02 &&\n            node->simpleDescriptors()[1].profileId() == ZLL_PROFILE_ID &&\n            node->simpleDescriptors()[1].deviceId() == 0x03f2)\n        {\n            // server clusters endpoint 0x01: 0x0000, 0x0004, 0x0003, 0x0006, 0x0008, 0x1000\n            // client clusters endpoint 0x01: 0x0000, 0x0004, 0x0003, 0x0006, 0x0008, 0x1000\n            // server clusters endpoint 0x02: 0x1000\n            // client clusters endpoint 0x02: 0x1000\n            modelId = QLatin1String(\"ZYCT-202\"); //  the modelid returned by device is empty\n            manufacturer = QLatin1String(\"Trust\");\n        }\n        // check iHorn temperature and humidity sensor 113D\n        if (node->simpleDescriptors().size() == 1 &&\n            node->simpleDescriptors()[0].endpoint() == 0x01 &&\n            node->simpleDescriptors()[0].profileId() == HA_PROFILE_ID &&\n            node->simpleDescriptors()[0].deviceId() == 0x0302 &&\n            inClusterCount == 8 && outClusterCount == 11)\n        {\n            modelId = QLatin1String(\"113D\"); //  the modelid returned by device is empty\n            manufacturer = QLatin1String(\"iHorn\");\n        }\n    }\n\n    for (;i != end; ++i)\n    {\n        SensorFingerprint fpAirQualitySensor;\n        SensorFingerprint fpAlarmSensor;\n        SensorFingerprint fpBatterySensor;\n        SensorFingerprint fpCarbonMonoxideSensor;\n        SensorFingerprint fpConsumptionSensor;\n        SensorFingerprint fpFireSensor;\n        SensorFingerprint fpHumiditySensor;\n        SensorFingerprint fpLightSensor;\n        SensorFingerprint fpOpenCloseSensor;\n        SensorFingerprint fpPowerSensor;\n        SensorFingerprint fpPresenceSensor;\n        SensorFingerprint fpPressureSensor;\n        SensorFingerprint fpMoistureSensor;\n        SensorFingerprint fpSpectralSensor;\n        SensorFingerprint fpSwitch;\n        SensorFingerprint fpTemperatureSensor;\n        SensorFingerprint fpThermostatSensor;\n        SensorFingerprint fpTimeSensor;\n        SensorFingerprint fpVibrationSensor;\n        SensorFingerprint fpWaterSensor;\n        SensorFingerprint fpDoorLockSensor;\n        SensorFingerprint fpAncillaryControlSensor;\n\n        {   // scan server clusters of endpoint\n            auto ci = i->inClusters().cbegin();\n            const auto cend = i->inClusters().cend();\n            for (; ci != cend; ++ci)\n            {\n                switch (ci->id())\n                {\n                case BASIC_CLUSTER_ID:\n                {\n                    if (modelId.isEmpty() || manufacturer.isEmpty())\n                    {\n                        std::vector<deCONZ::ZclAttribute>::const_iterator j = ci->attributes().begin();\n                        std::vector<deCONZ::ZclAttribute>::const_iterator jend = ci->attributes().end();\n\n                        for (; j != jend; ++j)\n                        {\n                            if (manufacturer.isEmpty() && j->id() == 0x0004) // manufacturer id\n                            {\n                                manufacturer = j->toString().trimmed();\n                            }\n                            else if (modelId.isEmpty() && j->id() == 0x0005) // model id\n                            {\n                                modelId = j->toString().trimmed();\n                                // replace ORVIBO model ID\n                                if (modelId == QLatin1String(\"895a2d80097f4ae2b2d40500d5e03dcc\"))\n                                {\n                                    modelId = QLatin1String(\"SN10ZW motion sensor\");\n                                }\n                                else if (modelId == QLatin1String(\"b5db59bfd81e4f1f95dc57fdbba17931\"))\n                                {\n                                    modelId = QLatin1String(\"SF20 smoke sensor\");\n                                }\n                                else if (modelId == QLatin1String(\"98293058552c49f38ad0748541ee96ba\"))\n                                {\n                                    modelId = QLatin1String(\"SF21 smoke sensor\");\n                                }\n                                else if (modelId == QLatin1String(\"898ca74409a740b28d5841661e72268d\") ||\n                                         modelId == QLatin1String(\"50938c4c3c0b4049923cd5afbc151bde\"))\n                                {\n                                    modelId = QLatin1String(\"ST30 Temperature Sensor\");\n                                }\n                                else if (modelId == QLatin1String(\"PST03A-v2.2.5\")) // Device doesn't have a manufacturer name\n                                {\n                                    manufacturer = QLatin1String(\"Philio\");\n                                }\n                            }\n                        }\n                    }\n\n                    if (node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC &&\n                             modelId.startsWith(QLatin1String(\"lumi.sensor_wleak\")))\n                    {\n                        fpWaterSensor.inClusters.push_back(IAS_ZONE_CLUSTER_ID);\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_SINOPE &&\n                             modelId.startsWith(QLatin1String(\"WL4200\")))\n                    {\n                        fpWaterSensor.inClusters.push_back(IAS_ZONE_CLUSTER_ID);\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_XIAOMI &&\n                             modelId.endsWith(QLatin1String(\"86opcn01\")))   // Aqara Opple switches\n                    {\n                        fpSwitch.inClusters.push_back(MULTISTATE_INPUT_CLUSTER_ID);\n                    }\n                    else if (isTuyaManufacturerName(manufacturer))\n                    {\n                        // For some device the Tuya cluster is sometime Invisible, so force device detection\n                        if (manufacturer.endsWith(QLatin1String(\"kud7u2l\"))  ||\n                            manufacturer.endsWith(QLatin1String(\"eaxp72v\")) ||\n                            manufacturer.endsWith(QLatin1String(\"88teujp\")) ||\n                            manufacturer.endsWith(QLatin1String(\"uhszj9s\")) ||\n                            manufacturer.endsWith(QLatin1String(\"fvq6avy\")) ||\n                            manufacturer.endsWith(QLatin1String(\"w7cahqs\")) ||\n                            manufacturer.endsWith(QLatin1String(\"wdxldoj\")) ||\n                            manufacturer.endsWith(QLatin1String(\"hn3negr\")) ||\n                            manufacturer.endsWith(QLatin1String(\"oclfnxz\")) ||\n                            manufacturer.endsWith(QLatin1String(\"ivfvd7h\")) ||\n                            manufacturer.endsWith(QLatin1String(\"wnjrr72\")) ||\n                            manufacturer.endsWith(QLatin1String(\"GbxAXL2\")))\n                        {\n                            fpThermostatSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                        }\n                        if (manufacturer.endsWith(QLatin1String(\"0yu2xgi\")))\n                        {\n                            fpTemperatureSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                            fpTemperatureSensor.inClusters.push_back(TEMPERATURE_MEASUREMENT_CLUSTER_ID);\n                            fpHumiditySensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                            fpHumiditySensor.inClusters.push_back(RELATIVE_HUMIDITY_CLUSTER_ID);\n                            fpAlarmSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                            fpAlarmSensor.inClusters.push_back(IAS_ZONE_CLUSTER_ID);\n                        }\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER &&\n                             (manufacturer.endsWith(QLatin1String(\"oclfnxz\")) ||\n                              manufacturer.endsWith(QLatin1String(\"6wax7g0\")) ||\n                              manufacturer.endsWith(QLatin1String(\"88teujp\"))))\n                    {\n                        fpThermostatSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC &&\n                              modelId.startsWith(QLatin1String(\"lumi.lock.v1\")))\n                    {\n                        fpDoorLockSensor.inClusters.push_back(DOOR_LOCK_CLUSTER_ID);\n                    }\n\n                    fpAirQualitySensor.inClusters.push_back(ci->id());\n                    fpAlarmSensor.inClusters.push_back(ci->id());\n                    fpBatterySensor.inClusters.push_back(ci->id());\n                    fpCarbonMonoxideSensor.inClusters.push_back(ci->id());\n                    fpConsumptionSensor.inClusters.push_back(ci->id());\n                    fpFireSensor.inClusters.push_back(ci->id());\n                    fpHumiditySensor.inClusters.push_back(ci->id());\n                    fpLightSensor.inClusters.push_back(ci->id());\n                    fpOpenCloseSensor.inClusters.push_back(ci->id());\n                    fpPowerSensor.inClusters.push_back(ci->id());\n                    fpPresenceSensor.inClusters.push_back(ci->id());\n                    fpPressureSensor.inClusters.push_back(ci->id());\n                    fpSwitch.inClusters.push_back(ci->id());\n                    fpTemperatureSensor.inClusters.push_back(ci->id());\n                    fpThermostatSensor.inClusters.push_back(ci->id());\n                    fpTimeSensor.inClusters.push_back(ci->id());\n                    fpVibrationSensor.inClusters.push_back(ci->id());\n                    fpWaterSensor.inClusters.push_back(ci->id());\n                    fpDoorLockSensor.inClusters.push_back(ci->id());\n                    fpAncillaryControlSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case IDENTIFY_CLUSTER_ID:\n                {\n                    if (manufacturer == QLatin1String(\"_TYST11_xu1rkty3\"))\n                    {\n                        fpBatterySensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                    }\n                }\n                    break;\n\n                case POWER_CONFIGURATION_CLUSTER_ID:\n                {\n                    fpAirQualitySensor.inClusters.push_back(ci->id());\n                    fpAlarmSensor.inClusters.push_back(ci->id());\n                    if ((node->nodeDescriptor().manufacturerCode() == VENDOR_AXIS || node->nodeDescriptor().manufacturerCode() == VENDOR_MMB) &&\n                        (modelId == QLatin1String(\"Gear\")) && (i->endpoint() == 0x01))\n                    {\n                        fpBatterySensor.inClusters.push_back(ci->id());\n                    }\n                    if (node->nodeDescriptor().manufacturerCode() == VENDOR_SI_LABS &&\n                        modelId.startsWith(QLatin1String(\"D10110\")))\n                    {\n                        fpBatterySensor.inClusters.push_back(ci->id());\n                    }\n                    fpCarbonMonoxideSensor.inClusters.push_back(ci->id());\n                    fpFireSensor.inClusters.push_back(ci->id());\n                    fpHumiditySensor.inClusters.push_back(ci->id());\n                    fpLightSensor.inClusters.push_back(ci->id());\n                    fpOpenCloseSensor.inClusters.push_back(ci->id());\n                    fpPresenceSensor.inClusters.push_back(ci->id());\n                    fpPressureSensor.inClusters.push_back(ci->id());\n                    fpMoistureSensor.inClusters.push_back(ci->id());\n                    fpSwitch.inClusters.push_back(ci->id());\n                    fpTemperatureSensor.inClusters.push_back(ci->id());\n                    fpThermostatSensor.inClusters.push_back(ci->id());\n                    fpTimeSensor.inClusters.push_back(ci->id());\n                    fpVibrationSensor.inClusters.push_back(ci->id());\n                    fpWaterSensor.inClusters.push_back(ci->id());\n                    fpDoorLockSensor.inClusters.push_back(ci->id());\n                    fpAncillaryControlSensor.inClusters.push_back(ci->id());\n                    fpAirQualitySensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case COMMISSIONING_CLUSTER_ID:\n                {\n                    if ((modelId == QLatin1String(\"ZYCT-202\") || modelId == QLatin1String(\"ZLL-NonColorController\")) && i->endpoint() != 0x01)\n                    {\n                        // ignore second endpoint\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                             modelId.startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                             modelId.startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                             modelId.startsWith(QLatin1String(\"Switch-LIGHTIFY\"))) // Osram 4 button remote\n                    {\n                        // Don't create entry for this cluster\n                    }\n                    else\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                        fpPresenceSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case ONOFF_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"lumi.sensor_magnet\")))\n                    {\n                        fpOpenCloseSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.sensor_86sw\")))\n                    {\n                        if (i->endpoint() == 0x01) // create sensor only for first endpoint\n                        {\n                            fpSwitch.inClusters.push_back(ci->id());\n                        }\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.ctrl_neutral\")))\n                    {\n                        if (i->endpoint() == 0x04) // create sensor only for first switch endpoint\n                        {\n                            fpSwitch.inClusters.push_back(ci->id());\n                        }\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.sensor_switch\")))\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId == QLatin1String(\"lumi.remote.b1acn01\"))\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if (manufacturer == QLatin1String(\"_TZ3000_bi6lpsew\") ||\n                             manufacturer == QLatin1String(\"_TZ3400_keyjhapk\") ||\n                             manufacturer == QLatin1String(\"_TYZB02_key8kk7r\") ||\n                             manufacturer == QLatin1String(\"_TZ3400_keyjqthh\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_rrjr1q0u\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_abci1hiu\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_vp6clf9d\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_wkai4ga5\") ||\n                             manufacturer == QLatin1String(\"_TZ3400_key8kk7r\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_peszejy7\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_qzjcsmar\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_owgcnkrh\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_adkvzooy\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_arfwfgoa\") ||\n                             manufacturer == QLatin1String(\"_TYZB02_keyjqthh\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_dfgbtub0\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_xabckq1v\") ||\n                             manufacturer == QLatin1String(\"_TZ3000_a7ouggvs\"))\n                    {\n                        //Making the device only for endpoint 0x01\n                        if (i->endpoint() == 0x01)\n                        {\n                            fpSwitch.inClusters.push_back(ci->id());\n                        }\n                    }\n                }\n                    break;\n\n                case ONOFF_SWITCH_CONFIGURATION_CLUSTER_ID:\n                {\n                    fpSwitch.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case IAS_ZONE_CLUSTER_ID:\n                {\n                    // Don't create ZHAalarm for thoses device using this cluster\n                    if (manufacturer.endsWith(QLatin1String(\"0yu2xgi\")) || // Tuya siren\n                        manufacturer.endsWith(QLatin1String(\"mdqxxnn\")))   // Tuya light sensor TYZB01\n                    {\n                    }\n                    else if (modelId == QLatin1String(\"URC4450BC0-X-R\") ||\n                             modelId == QLatin1String(\"3405-L\") ||\n                             modelId == QLatin1String(\"ZB-KeypadGeneric-D0002\"))\n                    {\n                        fpAncillaryControlSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"CO_\")) ||                   // Heiman CO sensor\n                             modelId.startsWith(QLatin1String(\"COSensor\")))                // Heiman CO sensor (newer model)\n                    {\n                        fpCarbonMonoxideSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"DOOR_\")) ||                      // Heiman door/window sensor\n                             modelId.startsWith(QLatin1String(\"Door\")) ||                       // Heiman door/window sensor (newer model)\n                             modelId == QLatin1String(\"FB56-DOS06HM1.3\") ||                     // Feibit FB56-DOS06HM1.3 door/window sensor\n                             modelId == QLatin1String(\"3AFE130104020015\") ||                    // Konke door/window sensor\n                             modelId == QLatin1String(\"e70f96b3773a4c9283c6862dbafb6a99\") ||    // Orvibo door/window sensor\n                             modelId.startsWith(QLatin1String(\"902010/21\")) ||                  // Bitron door/window sensor\n                             modelId.startsWith(QLatin1String(\"ZHMS101\")) ||                    // Wattle (Develco) door/window sensor\n                             modelId.startsWith(QLatin1String(\"4655BC0\")) ||                    // Ecolink contact sensor\n                             modelId.startsWith(QLatin1String(\"3300\")) ||                       // Centralite contact sensor\n                             modelId == QLatin1String(\"CCT591011_AS\") ||                        // LK Wiser Door / Window Sensor\n                             modelId == QLatin1String(\"E1D-G73\") ||                             // Sengled contact sensor\n                             modelId == QLatin1String(\"DS01\") ||                                // Sonoff SNZB-04\n                             modelId == QLatin1String(\"ZB-DoorSensor-D0003\") ||                 // Linkind Door/Window Sensor\n                             modelId == QLatin1String(\"DoorWindow-Sensor-ZB3.0\") ||             // Immax NEO ZB3.0 window/door sensor\n                             modelId == QLatin1String(\"GMB-HAS-DW-B01\") ||                      // GamaBit Ltd. Window/Door Sensor\n                             modelId == QLatin1String(\"TY0203\") ||                              // lidl / SilverCrest\n                             modelId == QLatin1String(\"DCH-B112\") ||                            // D-Link door/window sensor\n                             manufacturer == QLatin1String(\"_TZ3000_402jjyro\") ||               // tuya door windows sensor\n                             modelId == QLatin1String(\"RH3001\"))                                // Tuya/Blitzwolf BW-IS2 door/window sensor\n                    {\n                        fpOpenCloseSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"PIR_\")) ||             // Heiman motion sensor\n                             modelId.startsWith(QLatin1String(\"PIRS\")) ||             // Heiman motion sensor (newer model)\n                             modelId == QLatin1String(\"3AFE14010402000D\") ||          // Konke motion sensor\n                             modelId == QLatin1String(\"3AFE28010402000D\") ||          // Konke motion sensor ver.2\n                             modelId == QLatin1String(\"SWO-MOS1PA\") ||                // Swann One Motion Sensor\n                             modelId == QLatin1String(\"motion\") ||                    // Samjin motion sensor\n                             modelId == QLatin1String(\"ZB-MotionSensor-D0003\") ||     // Linkind motion sensor\n                             modelId == QLatin1String(\"3041\") ||                      // NYCE motion sensor\n                             modelId == QLatin1String(\"CCT595011_AS\") ||              // LK Wiser Motion Sensor\n                             modelId.startsWith(QLatin1String(\"902010/22\")) ||        // Bitron motion sensor\n                             modelId.startsWith(QLatin1String(\"SN10ZW\")) ||           // ORVIBO motion sensor\n                             modelId.startsWith(QLatin1String(\"MOSZB-1\")) ||          // Develco motion sensor\n                             modelId.startsWith(QLatin1String(\"MotionSensor51AU\")) || // Aurora (Develco) motion sensor\n                             modelId.startsWith(QLatin1String(\"MOT003\")) ||           // Hive motion sensor\n                             modelId == QLatin1String(\"DCH-B122\") ||                  // D-Link DCH-B122 motion sensor\n                             modelId == QLatin1String(\"4in1-Sensor-ZB3.0\") ||         // Immax NEO ZB3.0 4 in 1 sensor E13-A21\n                             modelId == QLatin1String(\"GZ-PIR02\") ||                  // Sercomm motion sensor\n                             modelId == QLatin1String(\"E13-A21\") ||                   // Sengled E13-A21 PAR38 bulp with motion sensor\n                             modelId == QLatin1String(\"TS0202\") ||                    // Tuya generic motion sensor\n                             modelId == QLatin1String(\"TY0202\") ||                    // Lidl/Silvercrest Smart Motion Sensor\n                             modelId == QLatin1String(\"LDSENK10\") ||                  // ADEO - Animal compatible motion sensor\n                             modelId == QLatin1String(\"66666\") ||                     // Sonoff SNZB-03\n                             modelId == QLatin1String(\"MS01\") ||                      // Sonoff SNZB-03\n                             modelId == QLatin1String(\"MSO1\") ||                      // Sonoff SNZB-03\n                             modelId == QLatin1String(\"ms01\"))                        // Sonoff SNZB-03\n                    {\n                        fpPresenceSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"GAS\")) ||                     // Heiman gas sensor (old and newer model)\n                             modelId.startsWith(QLatin1String(\"SMOK_\")) ||                   // Heiman fire sensor\n                             modelId.startsWith(QLatin1String(\"Smoke\")) ||                   // Heiman fire sensor (newer model)\n                             modelId.startsWith(QLatin1String(\"902010/24\")) ||               // Bitron smoke detector\n                             modelId.startsWith(QLatin1String(\"SF2\")) ||                     // ORVIBO (Heiman) smoke sensor\n                             modelId == QLatin1String(\"358e4e3e03c644709905034dae81433e\") || // Orvibo Combustible Gas Sensor\n                             modelId == QLatin1String(\"c3442b4ac59b4ba1a83119d938f283ab\") || // ORVIBO SF30 smoke sensor\n                             modelId.startsWith(QLatin1String(\"LH05121\")) ||                 // iHorn smoke detector\n                             modelId.startsWith(QLatin1String(\"TS0204\")) ||                  // Tuya gas sensor\n                             modelId.startsWith(QLatin1String(\"TS0205\")) ||                  // Tuya smoke sensor\n                             modelId == QLatin1String(\"SD8SC_00.00.03.09TC\") ||              // Centralite smoke sensor\n                             modelId.startsWith(QLatin1String(\"FNB56-SMF\")) ||               // Feibit smoke detector\n                             modelId.startsWith(QLatin1String(\"FNB56-COS\")) ||               // Feibit FNB56-COS06FB1.7 Carb. Mon. detector\n                             modelId.startsWith(QLatin1String(\"FNB56-GAS\")))                 // Feibit gas sensor\n                    {\n                        // Gas sensor detects combustable gas, so fire is more appropriate than CO.\n                        fpFireSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"WATER_\")) ||           // Heiman water sensor\n                             modelId.startsWith(QLatin1String(\"Water\")) ||            // Heiman water sensor (newer model)\n                             modelId.startsWith(QLatin1String(\"lumi.sensor_wleak\")) || // Xiaomi Aqara flood sensor\n                             modelId == QLatin1String(\"lumi.flood.agl02\") ||          // Xiaomi Aqara T1 water leak sensor SJCGQ12LM\n                             modelId == QLatin1String(\"CCT592011_AS\") ||              // LK Wiser Water Leak Sensor\n                             modelId.startsWith(QLatin1String(\"moisturev4\")) ||       // SmartThings water leak sensor\n                             modelId.startsWith(QLatin1String(\"WL4200\")) ||           // Sinope Water Leak detector\n                             modelId.startsWith(QLatin1String(\"3315\")) ||             // Centralite water sensor\n                             modelId.startsWith(QLatin1String(\"SZ-WTD02N_CAR\")) ||    // Sercomm water sensor\n                             modelId.startsWith(QLatin1String(\"FLSZB-1\")) ||          // Develco Water Leak detector\n                             modelId == QLatin1String(\"GMB-HAS-WL-B01\") ||            // GamaBit Ltd. water leak Sensor\n                             modelId.startsWith(QLatin1String(\"TS0207\")))             // Tuya water leak sensor\n                    {\n                        fpWaterSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId == QLatin1String(\"WarningDevice\") ||               // Heiman siren\n                             modelId == QLatin1String(\"SZ-SRN12N\") ||                   // Sercomm siren\n                             modelId == QLatin1String(\"SIRZB-1\") ||                     // Develco siren\n                             modelId == QLatin1String(\"902010/29\"))                     // Bitron outdoor siren\n                    {\n                        fpAlarmSensor.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId == QLatin1String(\"GMB-HAS-VB-B01\"))                // GamaBit Ltd. Vibration Sensor\n                    {\n                        fpVibrationSensor.inClusters.push_back(ci->id());\n                    }\n                    else if ((manufacturer == QLatin1String(\"Samjin\") && modelId == QLatin1String(\"button\")) ||\n                              modelId == QLatin1String(\"TS0211\"))\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if (!modelId.isEmpty())\n                    {\n                        for (const deCONZ::ZclAttribute &attr : ci->attributes())\n                        {\n                            if (attr.id() == 0x0001 && attr.lastRead() <= 0) // IAS Zone type\n                            {\n                                // Might not work as intended, when IAS Zone Type hasn't been read.\n                                switch (attr.numericValue().u16) {\n                                    case IAS_ZONE_TYPE_MOTION_SENSOR:\n                                        fpPresenceSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_CONTACT_SWITCH:\n                                        fpOpenCloseSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_CARBON_MONOXIDE_SENSOR:\n                                        fpCarbonMonoxideSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_FIRE_SENSOR:\n                                        fpFireSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_VIBRATION_SENSOR:\n                                        fpVibrationSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_WATER_SENSOR:\n                                        fpWaterSensor.inClusters.push_back(ci->id());\n                                        break;\n                                    case IAS_ZONE_TYPE_WARNING_DEVICE:\n                                    case IAS_ZONE_TYPE_STANDARD_CIE:\n                                    default:\n                                        if (manufacturer == QLatin1String(\"Trust\"))\n                                        {\n                                            // ignore for ZHAAlarm\n                                        }\n                                        else if (modelId.startsWith(QLatin1String(\"lumi.sensor_motion\")))\n                                        {\n                                            // ignore for ZHAAlarm\n                                        }\n                                        else\n                                        {\n                                            fpAlarmSensor.inClusters.push_back(ci->id());\n                                        }\n                                        break;\n                                }\n                            }\n                        }\n                    }\n                }\n                    break;\n\n                case OCCUPANCY_SENSING_CLUSTER_ID:\n                {\n                    if (node->nodeDescriptor().manufacturerCode() == VENDOR_CENTRALITE ||\n                        node->nodeDescriptor().manufacturerCode() == VENDOR_C2DF)\n                    {\n                        // only use IAS Zone cluster on endpoint 0x01 for Centralite motion sensors\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_NYCE)\n                    {\n                        // only use IAS Zone cluster on endpoint 0x01 for NYCE motion sensors\n                    }\n                    else\n                    {\n                        fpPresenceSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case ILLUMINANCE_MEASUREMENT_CLUSTER_ID:\n                case ILLUMINANCE_LEVEL_SENSING_CLUSTER_ID:\n                {\n                    fpLightSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case TEMPERATURE_MEASUREMENT_CLUSTER_ID:\n                {\n\n                    if (modelId == QLatin1String(\"VOC_Sensor\"))\n                    {\n                        fpHumiditySensor.inClusters.push_back(ci->id());\n                    }\n\n                    // Hive devices, don't show model id faster enought\n                    if ((node->nodeDescriptor().manufacturerCode() == VENDOR_ALERTME) && (modelId.isEmpty()))\n                    {\n                    }\n                    // Don't create entry for the plug\n                    else if (modelId == QLatin1String(\"SLP2b\"))\n                    {\n                    }\n                    // Don't create entry for cluster 0x07 and 0x08 for Hive thermostat\n                    else if ((modelId.startsWith(QLatin1String(\"SLR2\")) || modelId == QLatin1String(\"SLR1b\")) && i->endpoint() > 0x06)\n                    {\n                    }\n                    // Don't create entry for the door lock\n                    //else if (modelId == QLatin1String(\"SMARTCODE_CONVERT_GEN1\"))\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_KWIKSET)\n                    {\n                    }\n                    // Don't create entries for the following Danfoss in-room thermostats\n                    else if(modelId == QLatin1String(\"0x8020\") ||\n                            modelId == QLatin1String(\"0x8030\") ||\n                            modelId == QLatin1String(\"0x8034\"))\n                    {\n                    }\n                    else\n                    {\n                        fpTemperatureSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case RELATIVE_HUMIDITY_CLUSTER_ID:\n                {\n                    if (modelId == QLatin1String(\"AIR\") && node->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2)\n                    {\n                       // use manufacturer specific cluster instead\n                    }\n                    // Don't create sensor for first endpoint\n                    else if (modelId == QLatin1String(\"ST30 Temperature Sensor\") && i->endpoint() != 0x02)\n                    {\n                    }\n                    else if (modelId != QLatin1String(\"VOC_Sensor\"))\n                    {\n                        fpHumiditySensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case PRESSURE_MEASUREMENT_CLUSTER_ID:\n                {\n                    fpPressureSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case SOIL_MOISTURE_CLUSTER_ID:\n                {\n                    fpMoistureSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case ANALOG_INPUT_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"lumi.plug\")) || modelId.startsWith(QLatin1String(\"lumi.ctrl_ln1\")) ||\n                             modelId == QLatin1String(\"lumi.switch.b1nacn02\"))\n                    {\n                        if (i->endpoint() == 0x02 || i->endpoint() == 0x15)\n                        {\n                            fpPowerSensor.inClusters.push_back(ci->id());\n                        }\n                        else if (i->endpoint() == 0x03 || i->endpoint() == 0x16)\n                        {\n                            fpConsumptionSensor.inClusters.push_back(ci->id());\n                        }\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.ctrl_ln2\")) || modelId == QLatin1String(\"lumi.switch.b2nacn02\"))\n                    {\n                        if (i->endpoint() == 0x03)\n                        {\n                            fpPowerSensor.inClusters.push_back(ci->id());\n                        }\n                        else if (i->endpoint() == 0x04)\n                        {\n                            fpConsumptionSensor.inClusters.push_back(ci->id());\n                        }\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.relay.c\")))\n                    {\n                        fpConsumptionSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case MULTISTATE_INPUT_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"lumi.ctrl_ln\")) && i->endpoint() == 0x05)\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if (modelId == QLatin1String(\"lumi.sensor_switch.aq3\") || modelId == QLatin1String(\"lumi.remote.b1acn01\"))\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if ((modelId == QLatin1String(\"lumi.remote.b186acn01\") || modelId == QLatin1String(\"lumi.remote.b186acn02\") ||\n                              modelId == QLatin1String(\"lumi.remote.b286acn01\") || modelId == QLatin1String(\"lumi.remote.b286acn02\")) && i->endpoint() == 0x01)\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if ((modelId == QLatin1String(\"lumi.switch.b1lacn02\") || modelId == QLatin1String(\"lumi.switch.b2lacn02\")) && i->endpoint() == 0x04)\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                    else if ((modelId == QLatin1String(\"lumi.switch.b1nacn02\") || modelId == QLatin1String(\"lumi.switch.b2nacn02\")) && i->endpoint() == 0x05)\n                    {\n                        fpSwitch.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case BINARY_INPUT_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"tagv4\")) || // SmartThings Arrival sensor\n                        modelId == QLatin1String(\"Remote motion sensor\")) // Legrand motion sensor\n                    {\n                        fpPresenceSensor.inClusters.push_back(ci->id());\n                    }\n\n                }\n                    break;\n\n                case DOOR_LOCK_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"lumi.vibration\"))) // lumi.vibration\n                    {\n                        // fpSwitch.inClusters.push_back(DOOR_LOCK_CLUSTER_ID);\n                        fpVibrationSensor.inClusters.push_back(DOOR_LOCK_CLUSTER_ID);\n                    }\n                    else\n                    {\n                        //Using whitelist to ensure old doorlock hardware compatibility\n                        if (modelId == QLatin1String(\"SMARTCODE_CONVERT_GEN1\") || // Kwikset 914\n                            modelId == QLatin1String(\"YRD226/246 TSDB\") || // Yale YRD226 ZigBee keypad door lock\n                            modelId == QLatin1String(\"YRD226 TSDB\") || // Yale YRD226 ZigBee keypad door lock\n                            modelId == QLatin1String(\"YRD256 TSDB\") || // Yale YRD256 ZigBee keypad door lock\n                            modelId == QLatin1String(\"YRD256L TSDB SL\") ||\n                            modelId == QLatin1String(\"YRD220/240 TSDB\") ||\n                            modelId == QLatin1String(\"easyCodeTouch_v1\") || // EasyAccess EasyCodeTouch\n                            modelId == QLatin1String(\"ID Lock 150\"))\n                        {\n                            fpDoorLockSensor.inClusters.push_back(DOOR_LOCK_CLUSTER_ID);\n                        }\n                    }\n                }\n                    break;\n\n                case LEGRAND_CONTROL_CLUSTER_ID:\n                {\n                    if (modelId == QLatin1String(\"Cable outlet\"))\n                    {\n                        fpThermostatSensor.inClusters.push_back(LEGRAND_CONTROL_CLUSTER_ID);\n                    }\n                }\n                    break;\n\n                case TUYA_CLUSTER_ID:\n                {\n                    if (manufacturer.endsWith(QLatin1String(\"kud7u2l\")) ||\n                        manufacturer.endsWith(QLatin1String(\"GbxAXL2\")) ||\n                        manufacturer.endsWith(QLatin1String(\"eaxp72v\")) ||\n                        manufacturer.endsWith(QLatin1String(\"fvq6avy\")) ||\n                        manufacturer.endsWith(QLatin1String(\"uhszj9s\")) ||\n                        manufacturer.endsWith(QLatin1String(\"oclfnxz\")) ||\n                        manufacturer.endsWith(QLatin1String(\"w7cahqs\")) ||\n                        manufacturer.endsWith(QLatin1String(\"wdxldoj\")) ||\n                        manufacturer.endsWith(QLatin1String(\"hn3negr\")) ||\n                        manufacturer.endsWith(QLatin1String(\"6wax7g0\")) ||\n                        manufacturer.endsWith(QLatin1String(\"88teujp\")))\n                    {\n                        fpThermostatSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                    }\n                    if (manufacturer == QLatin1String(\"_TZE200_xuzcvlku\") ||\n                        manufacturer == QLatin1String(\"_TZE200_zah67ekd\") ||\n                        manufacturer == QLatin1String(\"_TZE200_rddyvrci\"))\n                    {\n                        fpBatterySensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                    }\n                    if (manufacturer == QLatin1String(\"_TZE200_aycxwiau\"))\n                    {\n                        fpFireSensor.inClusters.push_back(TUYA_CLUSTER_ID);\n                    }\n                }\n                    break;\n\n                case SAMJIN_CLUSTER_ID:\n                {\n                    if (modelId.startsWith(QLatin1String(\"multi\"))) // Samjin Multipurpose sensor\n                    {\n                        fpVibrationSensor.inClusters.push_back(SAMJIN_CLUSTER_ID);\n                    }\n                }\n                    break;\n\n                case METERING_CLUSTER_ID:\n                {\n                    fpConsumptionSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case ELECTRICAL_MEASUREMENT_CLUSTER_ID:\n                {\n                    if(modelId != QLatin1String(\"160-01\"))\n                    {\n                        fpPowerSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case THERMOSTAT_CLUSTER_ID:\n                {\n                    if(modelId != QLatin1String(\"VOC_Sensor\"))\n                    {\n                        fpThermostatSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID:\n                {\n                    if (modelId == QLatin1String(\"leakSMART Water Sensor V2\"))\n                    {\n                        fpWaterSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case TIME_CLUSTER_ID:\n                {\n                    // Many Xiaomi devices advertise non-functional Time cluster, so better use whitelist.\n                    if (modelId == QLatin1String(\"Thermostat\")) // eCozy\n                    {\n                        fpTimeSensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case BOSCH_AIR_QUALITY_CLUSTER_ID:\n                {\n                    if (node->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && modelId == QLatin1String(\"AIR\"))\n                    {\n                        fpAirQualitySensor.inClusters.push_back(ci->id());\n                        // fake proper clusterIds\n                        fpLightSensor.inClusters.push_back(ILLUMINANCE_MEASUREMENT_CLUSTER_ID);\n                        fpLightSensor.inClusters.push_back(ci->id());\n                        fpPressureSensor.inClusters.push_back(PRESSURE_MEASUREMENT_CLUSTER_ID);\n                        fpPressureSensor.inClusters.push_back(ci->id());\n                        fpHumiditySensor.inClusters.push_back(RELATIVE_HUMIDITY_CLUSTER_ID);\n                        fpHumiditySensor.inClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID:\n                case DIAGNOSTICS_CLUSTER_ID:\n                case FAN_CONTROL_CLUSTER_ID:\n                {\n                    fpThermostatSensor.inClusters.push_back(ci->id());\n                }\n                    break;\n\n                case XIAOMI_CLUSTER_ID:    // Xiaomi specific\n                {\n                    if (modelId.startsWith(QLatin1String(\"lumi.\")))\n                    {\n                        fpConsumptionSensor.inClusters.push_back(ci->id());\n                        fpHumiditySensor.inClusters.push_back(ci->id());\n                        fpLightSensor.inClusters.push_back(ci->id());\n                        fpOpenCloseSensor.inClusters.push_back(ci->id());\n                        fpPowerSensor.inClusters.push_back(ci->id());\n                        fpPresenceSensor.inClusters.push_back(ci->id());\n                        fpPressureSensor.inClusters.push_back(ci->id());\n                        fpSwitch.inClusters.push_back(ci->id());\n                        fpTemperatureSensor.inClusters.push_back(ci->id());\n                        fpThermostatSensor.inClusters.push_back(ci->id());\n                        if (modelId.startsWith(QLatin1String(\"lumi.curtain\")))\n                        {\n                            fpBatterySensor.inClusters.push_back(ci->id());\n                        }\n                    }\n                }\n                    break;\n\n                default:\n                    break;\n                }\n            }\n        }\n\n        {   // scan client clusters of endpoint\n            auto ci = i->outClusters().cbegin();\n            const auto cend = i->outClusters().cend();\n            for (; ci != cend; ++ci)\n            {\n                switch (ci->id())\n                {\n                case ONOFF_CLUSTER_ID:\n                case LEVEL_CLUSTER_ID:\n                case SCENE_CLUSTER_ID:\n                case WINDOW_COVERING_CLUSTER_ID:\n                {\n                    if (modelId == QLatin1String(\"ZYCT-202\") || modelId == QLatin1String(\"ZLL-NonColorController\") || modelId == QLatin1String(\"Adurolight_NCC\"))\n                    {\n                        fpSwitch.outClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"RC 110\")) ||   // innr RC 110\n                             modelId.startsWith(QLatin1String(\"ICZB-RM\")) ||  // icasa remote\n                             modelId.startsWith(QLatin1String(\"ZGR904-S\")) || // Envilar remote\n                             modelId.startsWith(QLatin1String(\"ZGRC-KEY\")) || // Sunricher remote\n                             modelId.startsWith(QLatin1String(\"ZG2833PAC\")) || // Sunricher C4\n                             modelId == QLatin1String(\"4512705\") ||           // Namron remote control\n                             modelId == QLatin1String(\"4512726\") ||           // Namron rotary switch\n                             modelId.startsWith(QLatin1String(\"S57003\")))     // SLC 4 ch remote switch\n                    {\n                        if (i->endpoint() == 0x01) // create sensor only for first endpoint\n                        {\n                            fpSwitch.outClusters.push_back(ci->id());\n                        }\n                    }\n                    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_JENNIC ||\n                             modelId.endsWith(QLatin1String(\"86opcn01\"))) // Aqara Opple prevent client clusters creation, client clusters aren't used, fpSwitch is created for 0xfc00 cluster.\n                    {\n                        // prevent creation of ZHASwitch, till supported\n                    }\n                    else if (i->deviceId() == DEV_ID_ZLL_ONOFF_SENSOR &&\n                        node->nodeDescriptor().manufacturerCode() == VENDOR_IKEA)\n                    {\n                        fpPresenceSensor.outClusters.push_back(ci->id());\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                             modelId.startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                             modelId.startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                             modelId.startsWith(QLatin1String(\"Switch-LIGHTIFY\"))) // Osram 4 button remote\n                    {\n                        // Only create entry for endpoint 0x01\n                        fpSwitch.outClusters.push_back(ci->id());\n                    }\n                    else if (!node->nodeDescriptor().isNull())\n                    {\n                        fpSwitch.outClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n                case IAS_ACE_CLUSTER_ID:\n                {\n                    if (modelId == QLatin1String(\"TS0215\") ||\n                        modelId == QLatin1String(\"RC_V14\") ||\n                        modelId == QLatin1String(\"RC-EM\") ||\n                        modelId == QLatin1String(\"RC-EF-3.0\"))\n                    {\n                        fpSwitch.outClusters.push_back(ci->id());\n                    }\n                    if (modelId == QLatin1String(\"URC4450BC0-X-R\") ||\n                        modelId == QLatin1String(\"3405-L\") ||\n                        modelId == QLatin1String(\"ZB-KeypadGeneric-D0002\"))\n                    {\n                        fpAncillaryControlSensor.outClusters.push_back(ci->id());\n                    }\n                }\n                    break;\n\n/*\n                TODO from PR: \"Corrections on sensor fingerprints\" #5246\n                Following is disabled for now since unwanted ZHASwitch resources are created.\n\n                case OTAU_CLUSTER_ID:\n                case TIME_CLUSTER_ID:\n                {\n                    fpAirQualitySensor.outClusters.push_back(ci->id());\n                    fpAlarmSensor.outClusters.push_back(ci->id());\n                    fpBatterySensor.outClusters.push_back(ci->id());\n                    fpCarbonMonoxideSensor.outClusters.push_back(ci->id());\n                    fpConsumptionSensor.outClusters.push_back(ci->id());\n                    fpFireSensor.outClusters.push_back(ci->id());\n                    fpHumiditySensor.outClusters.push_back(ci->id());\n                    fpLightSensor.outClusters.push_back(ci->id());\n                    fpOpenCloseSensor.outClusters.push_back(ci->id());\n                    fpPowerSensor.outClusters.push_back(ci->id());\n                    fpPresenceSensor.outClusters.push_back(ci->id());\n                    fpPressureSensor.outClusters.push_back(ci->id());\n                    fpSwitch.outClusters.push_back(ci->id());\n                    fpTemperatureSensor.outClusters.push_back(ci->id());\n                    fpThermostatSensor.outClusters.push_back(ci->id());\n                    fpTimeSensor.outClusters.push_back(ci->id());\n                    fpVibrationSensor.outClusters.push_back(ci->id());\n                    fpWaterSensor.outClusters.push_back(ci->id());\n                    fpDoorLockSensor.outClusters.push_back(ci->id());\n                    fpAncillaryControlSensor.outClusters.push_back(ci->id());\n                }\n                    break;\n*/\n\n                default:\n                    break;\n                }\n            }\n        }\n\n        if (modelId.isEmpty())\n        {\n            Sensor *sensor = getSensorNodeForAddress(node->address()); // extract from other sensors if possible\n            if (sensor && sensor->deletedState() == Sensor::StateNormal && !sensor->modelId().isEmpty())\n            {\n                modelId = sensor->modelId();\n            }\n            else\n            { // extract from light if possible\n                LightNode *lightNode = getLightNodeForAddress(node->address());\n                if (lightNode && !lightNode->modelId().isEmpty())\n                {\n                    modelId = lightNode->modelId();\n                }\n            }\n        }\n\n        // Add clusters used, but not exposed to sensors\n        if (modelId == QLatin1String(\"TRADFRI remote control\"))\n        {\n            fpSwitch.outClusters.push_back(SCENE_CLUSTER_ID);\n        }\n        else if (modelId == QLatin1String(\"Adurolight_NCC\"))\n        {\n            fpSwitch.outClusters.push_back(ADUROLIGHT_CLUSTER_ID);\n        }\n        else if (modelId == QLatin1String(\"E1E-G7F\"))\n        {\n            fpSwitch.outClusters.push_back(SENGLED_CLUSTER_ID);\n        }\n\n        if (!isDeviceSupported(node, modelId))\n        {\n            continue;\n        }\n\n        Sensor *sensor = nullptr;\n\n        // ZHASwitch\n        if (fpSwitch.hasInCluster(ONOFF_SWITCH_CONFIGURATION_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(ONOFF_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(ANALOG_INPUT_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(MULTISTATE_INPUT_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(DOOR_LOCK_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpSwitch.hasInCluster(ADUROLIGHT_CLUSTER_ID) ||\n            fpSwitch.hasOutCluster(IAS_ACE_CLUSTER_ID) ||\n            !fpSwitch.outClusters.empty())\n        {\n            fpSwitch.endpoint = i->endpoint();\n            fpSwitch.deviceId = i->deviceId();\n            fpSwitch.profileId = i->profileId();\n\n            if (modelId.startsWith(QLatin1String(\"RWL02\")))\n            {\n                sensor = getSensorNodeForAddress(node->address().ext()); // former created with with endpoint 1\n                if (sensor && sensor->deletedState() != Sensor::StateNormal)\n                {\n                    sensor = nullptr;\n                }\n                if (modelId != QLatin1String(\"RWL022\")) // new model with one endpoint\n                {\n                    fpSwitch.endpoint = 2;\n                }\n            }\n\n            if (modelId.startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                modelId.startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                modelId.startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                modelId.startsWith(QLatin1String(\"Switch-LIGHTIFY\"))) // Osram 4 button remote\n            {\n                sensor = getSensorNodeForAddress(node->address().ext());\n                if (sensor && sensor->deletedState() != Sensor::StateNormal)\n                {\n                    sensor = nullptr;\n                }\n            }\n\n            if (!sensor)\n            {\n                sensor = getSensorNodeForFingerPrint(node->address().ext(), fpSwitch, \"ZHASwitch\");\n            }\n\n            if (modelId == QLatin1String(\"OJB-IR715-Z\"))\n            {\n                // don't create ZHASwitch, IAS Presence only\n            }\n            else if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpSwitch, \"ZHASwitch\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        //ZHAAncillaryControl\n        if (fpAncillaryControlSensor.hasOutCluster(IAS_ACE_CLUSTER_ID))\n        {\n\n            fpAncillaryControlSensor.endpoint = i->endpoint();\n            fpAncillaryControlSensor.deviceId = i->deviceId();\n            fpAncillaryControlSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpAncillaryControlSensor, QLatin1String(\"ZHAAncillaryControl\"));\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpAncillaryControlSensor, QLatin1String(\"ZHAAncillaryControl\"), modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAPresence\n        if (fpPresenceSensor.hasInCluster(OCCUPANCY_SENSING_CLUSTER_ID) ||\n            fpPresenceSensor.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpPresenceSensor.hasInCluster(BINARY_INPUT_CLUSTER_ID) ||\n            fpPresenceSensor.hasOutCluster(ONOFF_CLUSTER_ID))\n        {\n            fpPresenceSensor.endpoint = i->endpoint();\n            fpPresenceSensor.deviceId = i->deviceId();\n            fpPresenceSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpPresenceSensor, \"ZHAPresence\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpPresenceSensor, \"ZHAPresence\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAOpenClose\n        if (fpOpenCloseSensor.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpOpenCloseSensor.hasInCluster(ONOFF_CLUSTER_ID))\n        {\n            fpOpenCloseSensor.endpoint = i->endpoint();\n            fpOpenCloseSensor.deviceId = i->deviceId();\n            fpOpenCloseSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpOpenCloseSensor, \"ZHAOpenClose\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpOpenCloseSensor, \"ZHAOpenClose\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHADoorLock\n        if (fpDoorLockSensor.hasInCluster(DOOR_LOCK_CLUSTER_ID))\n        {\n            fpDoorLockSensor.endpoint = i->endpoint();\n            fpDoorLockSensor.deviceId = i->deviceId();\n            fpDoorLockSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpDoorLockSensor, \"ZHADoorLock\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpDoorLockSensor, \"ZHADoorLock\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHATemperature\n        if (fpTemperatureSensor.hasInCluster(TEMPERATURE_MEASUREMENT_CLUSTER_ID))\n        {\n            fpTemperatureSensor.endpoint = i->endpoint();\n            fpTemperatureSensor.deviceId = i->deviceId();\n            fpTemperatureSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpTemperatureSensor, \"ZHATemperature\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpTemperatureSensor, \"ZHATemperature\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHALightLevel\n        if (fpLightSensor.hasInCluster(ILLUMINANCE_MEASUREMENT_CLUSTER_ID))\n        {\n            fpLightSensor.endpoint = i->endpoint();\n            fpLightSensor.deviceId = i->deviceId();\n            fpLightSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpLightSensor, \"ZHALightLevel\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpLightSensor, \"ZHALightLevel\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAHumidity\n        if (fpHumiditySensor.hasInCluster(RELATIVE_HUMIDITY_CLUSTER_ID))\n        {\n            fpHumiditySensor.endpoint = i->endpoint();\n            fpHumiditySensor.deviceId = i->deviceId();\n            fpHumiditySensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpHumiditySensor, \"ZHAHumidity\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpHumiditySensor, \"ZHAHumidity\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAPressure\n        if (fpPressureSensor.hasInCluster(PRESSURE_MEASUREMENT_CLUSTER_ID))\n        {\n            fpPressureSensor.endpoint = i->endpoint();\n            fpPressureSensor.deviceId = i->deviceId();\n            fpPressureSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpPressureSensor, \"ZHAPressure\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpPressureSensor, \"ZHAPressure\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAMoisture\n        if (fpMoistureSensor.hasInCluster(SOIL_MOISTURE_CLUSTER_ID))\n        {\n            fpMoistureSensor.endpoint = i->endpoint();\n            fpMoistureSensor.deviceId = i->deviceId();\n            fpMoistureSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpMoistureSensor, \"ZHAMoisture\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpMoistureSensor, \"ZHAMoisture\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAAlarm\n        if (fpAlarmSensor.hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            fpAlarmSensor.endpoint = i->endpoint();\n            fpAlarmSensor.deviceId = i->deviceId();\n            fpAlarmSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpAlarmSensor, \"ZHAAlarm\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpAlarmSensor, \"ZHAAlarm\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHACarbonMonoxide\n        if (fpCarbonMonoxideSensor.hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            fpCarbonMonoxideSensor.endpoint = i->endpoint();\n            fpCarbonMonoxideSensor.deviceId = i->deviceId();\n            fpCarbonMonoxideSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpCarbonMonoxideSensor, \"ZHACarbonMonoxide\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpCarbonMonoxideSensor, \"ZHACarbonMonoxide\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAFire\n        if (fpFireSensor.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpFireSensor.hasInCluster(TUYA_CLUSTER_ID))\n        {\n            fpFireSensor.endpoint = i->endpoint();\n            fpFireSensor.deviceId = i->deviceId();\n            fpFireSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpFireSensor, \"ZHAFire\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpFireSensor, \"ZHAFire\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAVibration\n        if (fpVibrationSensor.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpVibrationSensor.hasInCluster(SAMJIN_CLUSTER_ID) ||\n            fpVibrationSensor.hasInCluster(DOOR_LOCK_CLUSTER_ID))\n        {\n            fpVibrationSensor.endpoint = i->endpoint();\n            fpVibrationSensor.deviceId = i->deviceId();\n            fpVibrationSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpVibrationSensor, \"ZHAVibration\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpVibrationSensor, \"ZHAVibration\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAWater\n        if (fpWaterSensor.hasInCluster(IAS_ZONE_CLUSTER_ID) ||\n            fpWaterSensor.hasInCluster(APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID))\n        {\n            fpWaterSensor.endpoint = i->endpoint();\n            fpWaterSensor.deviceId = i->deviceId();\n            fpWaterSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpWaterSensor, \"ZHAWater\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpWaterSensor, \"ZHAWater\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n                checkIasEnrollmentStatus(sensor);\n            }\n        }\n\n        // ZHAConsumption\n        if (fpConsumptionSensor.hasInCluster(METERING_CLUSTER_ID) ||\n            fpConsumptionSensor.hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            fpConsumptionSensor.endpoint = i->endpoint();\n            fpConsumptionSensor.deviceId = i->deviceId();\n            fpConsumptionSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpConsumptionSensor, \"ZHAConsumption\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpConsumptionSensor, \"ZHAConsumption\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAPower\n        if (fpPowerSensor.hasInCluster(ELECTRICAL_MEASUREMENT_CLUSTER_ID) ||\n            fpPowerSensor.hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            fpPowerSensor.endpoint = i->endpoint();\n            fpPowerSensor.deviceId = i->deviceId();\n            fpPowerSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpPowerSensor, \"ZHAPower\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpPowerSensor, \"ZHAPower\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHASpectral\n        if (fpSpectralSensor.hasInCluster(VENDOR_CLUSTER_ID))\n        {\n            fpSpectralSensor.endpoint = i->endpoint();\n            fpSpectralSensor.deviceId = i->deviceId();\n            fpSpectralSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpTemperatureSensor, \"ZHASpectral\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpSpectralSensor, \"ZHASpectral\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAThermostat\n        if (fpThermostatSensor.hasInCluster(THERMOSTAT_CLUSTER_ID) ||\n           (fpThermostatSensor.hasInCluster(LEGRAND_CONTROL_CLUSTER_ID) && modelId == QLatin1String(\"Cable outlet\")) ||\n           (fpThermostatSensor.hasInCluster(TUYA_CLUSTER_ID)))\n        {\n            fpThermostatSensor.endpoint = i->endpoint();\n            fpThermostatSensor.deviceId = i->deviceId();\n            fpThermostatSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpThermostatSensor, \"ZHAThermostat\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpThermostatSensor, \"ZHAThermostat\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHABattery\n        if (fpBatterySensor.hasInCluster(POWER_CONFIGURATION_CLUSTER_ID) ||\n            fpBatterySensor.hasInCluster(XIAOMI_CLUSTER_ID) ||\n            fpBatterySensor.hasInCluster(TUYA_CLUSTER_ID))\n        {\n            fpBatterySensor.endpoint = i->endpoint();\n            fpBatterySensor.deviceId = i->deviceId();\n            fpBatterySensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpBatterySensor, \"ZHABattery\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpBatterySensor, \"ZHABattery\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHATime\n        if (fpTimeSensor.hasInCluster(TIME_CLUSTER_ID))\n        {\n            fpTimeSensor.endpoint = i->endpoint();\n            fpTimeSensor.deviceId = i->deviceId();\n            fpTimeSensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpTimeSensor, \"ZHATime\");\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpTimeSensor, \"ZHATime\", modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n        // ZHAAirQuality\n        if (fpAirQualitySensor.hasInCluster(ANALOG_INPUT_CLUSTER_ID) ||        // Xiaomi Aqara TVOC Air Quality Monitor\n            fpAirQualitySensor.hasInCluster(BOSCH_AIR_QUALITY_CLUSTER_ID))     // Bosch Air quality sensor\n        {\n            fpAirQualitySensor.endpoint = i->endpoint();\n            fpAirQualitySensor.deviceId = i->deviceId();\n            fpAirQualitySensor.profileId = i->profileId();\n\n            sensor = getSensorNodeForFingerPrint(node->address().ext(), fpAirQualitySensor, QLatin1String(\"ZHAAirQuality\"));\n            if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n            {\n                addSensorNode(node, fpAirQualitySensor, QLatin1String(\"ZHAAirQuality\"), modelId, manufacturer);\n            }\n            else\n            {\n                checkSensorNodeReachable(sensor);\n            }\n        }\n\n    }\n}\n\nvoid DeRestPluginPrivate::addSensorNode(const deCONZ::Node *node, const SensorFingerprint &fingerPrint, const QString &type, const QString &modelId, const QString &manufacturer)\n{\n    DBG_Assert(node);\n    if (!node)\n    {\n        return;\n    }\n\n    // Xiaomi plug might contain invalid sensor clusters\n    // prevent creation of related sensors for clusters like 0x0400, 0x0402, 0x0403, 0x0405, 0x0406\n    // https://github.com/dresden-elektronik/deconz-rest-plugin/issues/1094\n    if (modelId.startsWith(QLatin1String(\"lumi.plug\")) &&\n       !(type == QLatin1String(\"ZHAConsumption\") || type == QLatin1String(\"ZHAPower\")))\n    {\n        return;\n    }\n\n    auto *device = DEV_GetOrCreateDevice(this, deCONZ::ApsController::instance(), eventEmitter, m_devices, node->address().ext());\n\n    Sensor sensorNode;\n    sensorNode.setMode(Sensor::ModeScenes);\n    sensorNode.setNode(const_cast<deCONZ::Node*>(node));\n    sensorNode.address() = node->address();\n    sensorNode.setType(type);\n    sensorNode.fingerPrint() = fingerPrint;\n    sensorNode.setModelId(modelId);\n    quint16 clusterId = 0;\n\n    if (!manufacturer.isEmpty())\n    {\n        sensorNode.setManufacturer(manufacturer);\n    }\n\n    const auto &ddf = deviceDescriptions->get(&sensorNode);\n    if (ddf.isValid() && DDF_IsStatusEnabled(ddf.status))\n    {\n        DBG_Printf(DBG_DDF, \"skip create %s via legacy code for: %s (use DDF)\\n\", qPrintable(type), qPrintable(modelId));\n        return;\n    }\n\n    // simple check if existing device needs to be updated\n    Sensor *sensor2 = nullptr;\n    if (node->endpoints().size() == 1)\n    {\n        quint8 ep = node->endpoints()[0];\n        std::vector<Sensor>::iterator i = sensors.begin();\n        std::vector<Sensor>::iterator end = sensors.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->address().ext() == node->address().ext() &&\n                ep == i->fingerPrint().endpoint &&\n                i->deletedState() != Sensor::StateDeleted &&\n                i->type() == type)\n            {\n                sensor2 = &*i;\n                break;\n            }\n        }\n\n        if (sensor2)\n        {\n            sensorNode.setId(sensor2->id()); // preserve\n        }\n    }\n\n    ResourceItem *item;\n    item = sensorNode.item(RConfigOn);\n    item->setValue(true);\n\n    item = sensorNode.item(RConfigReachable);\n    item->setValue(true);\n\n    if (sensorNode.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\n    {\n        if (manufacturer.startsWith(QLatin1String(\"Climax\")) ||\n            sensorNode.modelId().startsWith(QLatin1String(\"902010/23\")))\n        {\n            // climax non IAS reports state/lowbattery via battery alarm mask attribute\n            sensorNode.addItem(DataTypeBool, RStateLowBattery);\n            // don't set value -> null until reported\n        }\n        else if (sensorNode.modelId() == QLatin1String(\"Bell\"))\n        {\n            // Don't expose battery resource item for this device\n        }\n        else if (!sensorNode.type().endsWith(QLatin1String(\"Battery\")))\n        {\n            sensorNode.addItem(DataTypeUInt8, RConfigBattery);\n        }\n    }\n\n    if (sensorNode.type().endsWith(QLatin1String(\"Switch\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(COMMISSIONING_CLUSTER_ID))\n        {\n            clusterId = COMMISSIONING_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ONOFF_CLUSTER_ID) ||\n                 sensorNode.fingerPrint().hasOutCluster(ONOFF_CLUSTER_ID))\n        {\n            clusterId = ONOFF_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(WINDOW_COVERING_CLUSTER_ID) ||\n                 sensorNode.fingerPrint().hasOutCluster(WINDOW_COVERING_CLUSTER_ID))\n        {\n            clusterId = WINDOW_COVERING_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            clusterId = ANALOG_INPUT_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(DOOR_LOCK_CLUSTER_ID))\n        {\n            clusterId = DOOR_LOCK_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(MULTISTATE_INPUT_CLUSTER_ID))\n        {\n            clusterId = MULTISTATE_INPUT_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasOutCluster(IAS_ACE_CLUSTER_ID))\n        {\n            clusterId = IAS_ACE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasOutCluster(SCENE_CLUSTER_ID))\n        {\n            clusterId = SCENE_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeInt32, RStateButtonEvent);\n\n        if (modelId.startsWith(QLatin1String(\"ZBT-Remote-ALL-RGBW\")))\n        {\n            sensorNode.addItem(DataTypeUInt16, RStateX);\n            sensorNode.addItem(DataTypeUInt16, RStateY);\n            sensorNode.addItem(DataTypeInt16, RStateAngle);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"AncillaryControl\")))\n    {\n        clusterId = IAS_ACE_CLUSTER_ID;\n        sensorNode.addItem(DataTypeString, RStateAction);\n        sensorNode.addItem(DataTypeString, RStatePanel);\n        sensorNode.addItem(DataTypeUInt32, RStateSecondsRemaining)->setValue(0);\n        sensorNode.addItem(DataTypeBool, RStateTampered)->setValue(false);\n\n        // by default add keypads to \"default\" alarm system 1\n        AlarmSystem *alarmSys = AS_GetAlarmSystem(1, *alarmSystems);\n        DBG_Assert(alarmSys != nullptr);\n        if (alarmSys)\n        {\n            alarmSys->addDevice(sensorNode.uniqueId(), AS_ENTRY_FLAG_IAS_ACE);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"LightLevel\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(ILLUMINANCE_MEASUREMENT_CLUSTER_ID))\n        {\n            clusterId = ILLUMINANCE_MEASUREMENT_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeUInt16, RStateLightLevel);\n        sensorNode.addItem(DataTypeUInt32, RStateLux);\n        sensorNode.addItem(DataTypeBool, RStateDark);\n        sensorNode.addItem(DataTypeBool, RStateDaylight);\n        item = sensorNode.addItem(DataTypeUInt16, RConfigTholdDark);\n        item->setValue(R_THOLDDARK_DEFAULT);\n        item = sensorNode.addItem(DataTypeUInt16, RConfigTholdOffset);\n        item->setValue(R_THOLDOFFSET_DEFAULT);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Temperature\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(TEMPERATURE_MEASUREMENT_CLUSTER_ID))\n        {\n            clusterId = TEMPERATURE_MEASUREMENT_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeInt16, RStateTemperature);\n        item = sensorNode.addItem(DataTypeInt16, RConfigOffset);\n        item->setValue(0);\n\n        if (R_GetProductId(&sensorNode).startsWith(QLatin1String(\"Tuya_SEN\")))\n        {\n            // Enable reporting in \"blind mode\"\n            sendTuyaRequest(sensorNode.address(), 0x01, DP_TYPE_BOOL, DP_IDENTIFIER_REPORTING, QByteArray(\"\\x01\", 1));\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Humidity\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(RELATIVE_HUMIDITY_CLUSTER_ID))\n        {\n            clusterId = RELATIVE_HUMIDITY_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeUInt16, RStateHumidity);\n        item = sensorNode.addItem(DataTypeInt16, RConfigOffset);\n        item->setValue(0);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Pressure\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(PRESSURE_MEASUREMENT_CLUSTER_ID))\n        {\n            clusterId = PRESSURE_MEASUREMENT_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeInt16, RStatePressure);\n        item = sensorNode.addItem(DataTypeInt16, RConfigOffset);\n        item->setValue(0);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Moisture\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(SOIL_MOISTURE_CLUSTER_ID))\n        {\n            clusterId = SOIL_MOISTURE_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeInt16, RStateMoisture);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Presence\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(OCCUPANCY_SENSING_CLUSTER_ID))\n        {\n            clusterId = OCCUPANCY_SENSING_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(BINARY_INPUT_CLUSTER_ID))\n        {\n            clusterId = BINARY_INPUT_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasOutCluster(ONOFF_CLUSTER_ID))\n        {\n            clusterId = ONOFF_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeBool, RStatePresence)->setValue(false);\n\n        if (modelId.startsWith(QLatin1String(\"MOSZB-1\")) && clusterId == OCCUPANCY_SENSING_CLUSTER_ID)\n        {\n            sensorNode.addItem(DataTypeUInt16, RConfigDelay)->setValue(0);\n            sensorNode.addItem(DataTypeUInt16, RConfigPending)->setValue(0);\n        }\n        else if (modelId == QLatin1String(\"lumi.motion.agl04\"))\n        {\n            sensorNode.addItem(DataTypeUInt16, RConfigDelay)->setValue(0);\n            sensorNode.addItem(DataTypeUInt16, RConfigPending)->setValue(0);\n            sensorNode.addItem(DataTypeUInt8, RConfigSensitivity)->setValue(0);\n        }\n        else\n        {\n            item = sensorNode.addItem(DataTypeUInt16, RConfigDuration);\n\n            if (modelId.startsWith(QLatin1String(\"tagv4\"))) // SmartThings Arrival sensor\n            {\n                item->setValue(310); // Sensor will be configured to report every 5 minutes\n            }\n            else if (modelId.startsWith(QLatin1String(\"lumi.sensor_motion\"))) // reporting under motion varies between 60 - 90 seconds\n            {\n                item->setValue(90);\n            }\n            else\n            {\n                item->setValue(60); // default 60 seconds\n            }\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"OpenClose\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ONOFF_CLUSTER_ID))\n        {\n            clusterId = ONOFF_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateOpen);\n        item->setValue(false);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"DoorLock\")))\n    {\n        clusterId = DOOR_LOCK_CLUSTER_ID;\n\n        sensorNode.addItem(DataTypeString, RStateLockState);\n        sensorNode.addItem(DataTypeBool, RConfigLock);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Alarm\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateAlarm);\n        item->setValue(false);\n\n        if (R_GetProductId(&sensorNode) == QLatin1String(\"NAS-AB02B0 Siren\"))\n        {\n            sensorNode.addItem(DataTypeUInt8, RConfigMelody);\n            sensorNode.addItem(DataTypeString, RConfigPreset);\n            sensorNode.addItem(DataTypeUInt8, RConfigVolume);\n            sensorNode.addItem(DataTypeInt8, RConfigTempMaxThreshold);\n            sensorNode.addItem(DataTypeInt8, RConfigTempMinThreshold);\n            sensorNode.addItem(DataTypeInt8, RConfigHumiMaxThreshold);\n            sensorNode.addItem(DataTypeInt8, RConfigHumiMinThreshold);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"CarbonMonoxide\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateCarbonMonoxide);\n        item->setValue(false);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Fire\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\n        {\n            clusterId = TUYA_CLUSTER_ID;\n            sensorNode.addItem(DataTypeBool, RStateLowBattery)->setValue(false);\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateFire);\n        item->setValue(false);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Vibration\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(DOOR_LOCK_CLUSTER_ID))\n        {\n            clusterId = DOOR_LOCK_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(SAMJIN_CLUSTER_ID))\n        {\n            clusterId = SAMJIN_CLUSTER_ID;\n            item = sensorNode.addItem(DataTypeInt16, RStateOrientationX);\n            item = sensorNode.addItem(DataTypeInt16, RStateOrientationY);\n            item = sensorNode.addItem(DataTypeInt16, RStateOrientationZ);\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateVibration);\n        item->setValue(false);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Water\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n        {\n            clusterId = IAS_ZONE_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID))\n        {\n            clusterId = APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeBool, RStateWater);\n        item->setValue(false);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Consumption\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(METERING_CLUSTER_ID))\n        {\n            clusterId = METERING_CLUSTER_ID;\n            if (modelId != QLatin1String(\"160-01\"))\n            {\n                item = sensorNode.addItem(DataTypeUInt64, RStateConsumption);\n            }\n            if ((modelId != QLatin1String(\"ZB-ONOFFPlug-D0005\")) &&\n                (modelId != QLatin1String(\"TS0121\")) &&\n                (!modelId.startsWith(QLatin1String(\"BQZ10-AU\"))) &&\n                (!modelId.startsWith(QLatin1String(\"ROB_200\"))) &&\n                (modelId != QLatin1String(\"lumi.switch.b1nacn02\")) &&\n                (modelId != QLatin1String(\"lumi.switch.b2nacn02\")) &&\n                (modelId != QLatin1String(\"lumi.switch.b1naus01\")) &&\n                (modelId != QLatin1String(\"lumi.switch.n0agl1\")) &&\n                (!modelId.startsWith(QLatin1String(\"SPW35Z\"))))\n            {\n                item = sensorNode.addItem(DataTypeInt16, RStatePower);\n            }\n            if (modelId.startsWith(QLatin1String(\"EMIZB-1\")))\n            {\n                sensorNode.addItem(DataTypeUInt8, RConfigInterfaceMode)->setValue(1);\n            }\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            clusterId = ANALOG_INPUT_CLUSTER_ID;\n            item = sensorNode.addItem(DataTypeUInt64, RStateConsumption);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Power\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(ELECTRICAL_MEASUREMENT_CLUSTER_ID))\n        {\n            clusterId = ELECTRICAL_MEASUREMENT_CLUSTER_ID;\n            item = sensorNode.addItem(DataTypeInt16, RStatePower);\n            if ( (!modelId.startsWith(QLatin1String(\"Plug\"))) &&\n                 (!modelId.startsWith(QLatin1String(\"ZB-ONOFFPlug-D0005\"))) &&\n                 (modelId != QLatin1String(\"lumi.switch.b1naus01\")) &&\n                 (modelId != QLatin1String(\"lumi.switch.b1nacn02\")) &&\n                 (modelId != QLatin1String(\"lumi.switch.b2nacn02\")) &&\n                 (modelId != QLatin1String(\"lumi.switch.n0agl1\")) &&\n                 (node->nodeDescriptor().manufacturerCode() != VENDOR_LEGRAND) ) // OSRAM and Legrand plug don't have theses options\n            {\n                item = sensorNode.addItem(DataTypeUInt16, RStateVoltage);\n                item = sensorNode.addItem(DataTypeUInt16, RStateCurrent);\n            }\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            clusterId = ANALOG_INPUT_CLUSTER_ID;\n            item = sensorNode.addItem(DataTypeInt16, RStatePower);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Thermostat\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(THERMOSTAT_CLUSTER_ID) || sensorNode.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\n        {\n            clusterId = THERMOSTAT_CLUSTER_ID;\n        }\n        //Only for legrand cluster, add only mode field.\n        if ((sensorNode.fingerPrint().hasInCluster(LEGRAND_CONTROL_CLUSTER_ID)) && (sensorNode.modelId() == QLatin1String(\"Cable outlet\") ) )\n        {\n            clusterId = LEGRAND_CONTROL_CLUSTER_ID;\n            sensorNode.addItem(DataTypeString, RConfigMode);\n        }\n        else\n        {\n            sensorNode.addItem(DataTypeInt16, RStateTemperature);\n            item = sensorNode.addItem(DataTypeInt16, RConfigOffset);\n            item->setValue(0);\n            sensorNode.addItem(DataTypeInt16, RConfigHeatSetpoint);    // Heating set point\n            sensorNode.addItem(DataTypeBool, RStateOn)->setValue(false);           // Heating on/off\n\n            if (sensorNode.modelId().startsWith(QLatin1String(\"SLR2\")) ||   // Hive\n                sensorNode.modelId() == QLatin1String(\"SLR1b\") ||           // Hive\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD MOES TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\"))\n            {\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n\n            if (R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n            {\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeBool, RStateLowBattery)->setValue(false);\n            }\n\n            if (R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD MOES TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n            {\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n            }\n\n            if (R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n            {\n                sensorNode.addItem(DataTypeString, RConfigPreset);\n                sensorNode.addItem(DataTypeBool, RConfigSetValve)->setValue(false);\n            }\n\n            if (R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n            {\n                sensorNode.addItem(DataTypeString, RConfigSchedule);\n            }\n\n            if (R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                R_GetProductId(&sensorNode) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n            {\n                sensorNode.addItem(DataTypeBool, RConfigWindowOpen)->setValue(false);\n            }\n\n            if (modelId.startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n            {\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeUInt32, RConfigHostFlags)->setIsPublic(false);\n                sensorNode.addItem(DataTypeBool, RConfigDisplayFlipped)->setValue(false);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else if (sensorNode.modelId() == QLatin1String(\"902010/32\"))  // Bitron\n            {\n                sensorNode.addItem(DataTypeString, RConfigMode);\n                sensorNode.addItem(DataTypeUInt8, RConfigControlSequence)->setValue(4);\n                sensorNode.addItem(DataTypeInt16, RConfigCoolSetpoint);\n                sensorNode.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigSchedule);\n            }\n            else if (sensorNode.modelId() == QLatin1String(\"Super TR\"))   // ELKO\n            {\n                sensorNode.addItem(DataTypeString, RConfigTemperatureMeasurement);\n                sensorNode.addItem(DataTypeInt16, RStateFloorTemperature);\n                sensorNode.addItem(DataTypeBool, RStateHeating)->setValue(false);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else if (modelId == QLatin1String(\"Thermostat\")) // ecozy\n            {\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeString, RConfigSchedule);\n                sensorNode.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\n                sensorNode.addItem(DataTypeInt16, RConfigLastChangeAmount);\n                sensorNode.addItem(DataTypeUInt8, RConfigLastChangeSource);\n                sensorNode.addItem(DataTypeTime, RConfigLastChangeTime);\n            }\n            else if (modelId == QLatin1String(\"SORB\")) // Stelpro Orleans Fan\n            {\n                sensorNode.addItem(DataTypeInt16, RConfigCoolSetpoint);\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else if (modelId.startsWith(QLatin1String(\"STZB402\"))) // Stelpro baseboard thermostat\n            {\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else if (modelId == QLatin1String(\"Zen-01\"))\n            {\n                sensorNode.addItem(DataTypeInt16, RConfigCoolSetpoint);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n                sensorNode.addItem(DataTypeString, RConfigFanMode);\n            }\n            else if (modelId.startsWith(QLatin1String(\"3157100\")))\n            {\n                sensorNode.addItem(DataTypeInt16, RConfigCoolSetpoint);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n                sensorNode.addItem(DataTypeString, RConfigFanMode);\n            }\n            else if (modelId == QLatin1String(\"PR412C\")) // OWON PCT502 Thermostat\n            {\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n            }\n            else if (modelId == QLatin1String(\"TH1300ZB\")) // sinope thermostat\n            {\n                sensorNode.addItem(DataTypeUInt8, RStateValve);\n                sensorNode.addItem(DataTypeBool, RConfigLocked)->setValue(false);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else if (modelId == QLatin1String(\"ALCANTARA2 D1.00P1.01Z1.00\")) // Alcantara 2 acova\n            {\n                sensorNode.addItem(DataTypeInt16, RConfigCoolSetpoint);\n                sensorNode.addItem(DataTypeString, RConfigMode);\n            }\n            else\n            {\n                if (!modelId.isEmpty())\n                {\n                    sensorNode.addItem(DataTypeBool, RConfigScheduleOn)->setValue(false);\n                    sensorNode.addItem(DataTypeString, RConfigSchedule);\n                }\n            }\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Battery\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\n        {\n            clusterId = POWER_CONFIGURATION_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(XIAOMI_CLUSTER_ID))\n        {\n            clusterId = XIAOMI_CLUSTER_ID;\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(TUYA_CLUSTER_ID))\n        {\n            clusterId = TUYA_CLUSTER_ID;\n        }\n        sensorNode.addItem(DataTypeUInt8, RStateBattery);\n        if (modelId.startsWith(QLatin1String(\"lumi.curtain.\")))\n        {\n            sensorNode.addItem(DataTypeBool, RStateCharging);\n        }\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"Time\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(TIME_CLUSTER_ID))\n        {\n            clusterId = TIME_CLUSTER_ID;\n        }\n        item = sensorNode.addItem(DataTypeTime, RStateUtc);\n        item = sensorNode.addItem(DataTypeTime, RStateLocaltime);\n        item = sensorNode.addItem(DataTypeTime, RStateLastSet);\n    }\n    else if (sensorNode.type().endsWith(QLatin1String(\"AirQuality\")))\n    {\n        if (sensorNode.fingerPrint().hasInCluster(BOSCH_AIR_QUALITY_CLUSTER_ID))\n        {\n            clusterId = BOSCH_AIR_QUALITY_CLUSTER_ID;\n\n            // Init Poll control\n            item = sensorNode.addItem(DataTypeUInt16, RConfigPending);\n            item->setValue(item->toNumber() | R_PENDING_WRITE_POLL_CHECKIN_INTERVAL | R_PENDING_SET_LONG_POLL_INTERVAL);\n        }\n        else if (sensorNode.fingerPrint().hasInCluster(ANALOG_INPUT_CLUSTER_ID))\n        {\n            clusterId = ANALOG_INPUT_CLUSTER_ID;\n        }\n\n        if (node->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2 && modelId == QLatin1String(\"AIR\"))  // Bosch air quality sensor\n        {\n            item = sensorNode.addItem(DataTypeString, RStateAirQuality);\n            item = sensorNode.addItem(DataTypeUInt16, RStateAirQualityPpb);\n        }\n    }\n\n    const lidlDevice *lidlDevice = getLidlDevice(manufacturer);\n    if (lidlDevice != nullptr)\n    {\n        sensorNode.setManufacturer(QLatin1String(lidlDevice->manufacturername));\n        sensorNode.setModelId(QLatin1String(lidlDevice->modelid));\n    }\n    else if (isTuyaManufacturerName(sensorNode.manufacturer())) // Leave Tuya manufacturer name as is\n    {\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_DDEL)\n    {\n    }\n    else if ((node->nodeDescriptor().manufacturerCode() == VENDOR_OSRAM_STACK) || (node->nodeDescriptor().manufacturerCode() == VENDOR_OSRAM))\n    {\n        if (modelId.startsWith(QLatin1String(\"CO_\")) ||   // Heiman CO sensor\n            modelId.startsWith(QLatin1String(\"DOOR_\")) || // Heiman door/window sensor\n            modelId.startsWith(QLatin1String(\"PIR_\")) ||  // Heiman motion sensor\n            modelId.startsWith(QLatin1String(\"GAS_\")) ||  // Heiman conbustable gas sensor\n            modelId.startsWith(QLatin1String(\"TH-\")) || // Heiman temperature/humidity sensor\n            modelId.startsWith(QLatin1String(\"SMOK_\")) || // Heiman fire sensor\n            modelId.startsWith(QLatin1String(\"WATER_\")) || // Heiman water sensor\n            modelId.startsWith(QLatin1String(\"RC_V14\")))   // Heiman remote\n        {\n            sensorNode.setManufacturer(\"Heiman\");\n        }\n        else\n        {\n            sensorNode.setManufacturer(\"OSRAM\");\n        }\n    }\n    else if ((node->nodeDescriptor().manufacturerCode() == VENDOR_SINOPE))\n    {\n        sensorNode.setManufacturer(\"Sinope\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_UBISYS)\n    {\n        sensorNode.setManufacturer(\"ubisys\");\n\n        if (type == QLatin1String(\"ZHASwitch\"))\n        {\n            sensorNode.addItem(DataTypeString, RConfigGroup);\n            item = sensorNode.addItem(DataTypeString, RConfigMode);\n            item->setValue(QString(\"momentary\"));\n        }\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_BUSCH_JAEGER)\n    {\n        sensorNode.setManufacturer(\"Busch-Jaeger\");\n\n        if (node->endpoints().size() >= 4)\n        {\n            sensorNode.setMode(Sensor::ModeScenes);\n        }\n        else if (node->endpoints().size() >= 2)\n        {\n            // has light endpoint?\n            const deCONZ::SimpleDescriptor *sd = getSimpleDescriptor(node, 0x12);\n            if (sd)\n            {\n                sensorNode.setMode(Sensor::ModeDimmer);\n            }\n            else\n            {\n                sensorNode.setMode(Sensor::ModeScenes);\n            }\n        }\n        else\n        {\n            sensorNode.setMode(Sensor::ModeDimmer);\n        }\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_BEGA)\n    {\n        sensorNode.setManufacturer(\"BEGA Gantenbrink-Leuchten KG\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH || node->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2)\n    {\n        sensorNode.setManufacturer(QLatin1String(\"BOSCH\"));\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_IKEA || modelId.startsWith(QLatin1String(\"TRADFRI\")))\n    {\n        sensorNode.setManufacturer(QLatin1String(\"IKEA of Sweden\"));\n\n        if (modelId == QLatin1String(\"TRADFRI wireless dimmer\"))\n        {\n\n            sensorNode.setMode(Sensor::ModeDimmer);\n        }\n        else\n        {\n            item = sensorNode.addItem(DataTypeString, RConfigAlert);\n            item->setValue(R_ALERT_DEFAULT);\n        }\n\n        sensorNode.setName(QString(\"%1 %2\").arg(modelId).arg(sensorNode.id()));\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_INSTA)\n    {\n        sensorNode.setManufacturer(\"Insta\");\n        checkInstaModelId(&sensorNode);\n    }\n    // Skip legacy Xiaomi items\n    else if (sensorNode.modelId() == QLatin1String(\"lumi.flood.agl02\") ||\n             sensorNode.modelId() == QLatin1String(\"lumi.motion.agl04\") || sensorNode.modelId() == QLatin1String(\"lumi.switch.b1nacn02\") ||\n             sensorNode.modelId() == QLatin1String(\"lumi.switch.b2nacn02\") ||\n             sensorNode.modelId() == QLatin1String(\"lumi.switch.b1naus01\") || sensorNode.modelId() == QLatin1String(\"lumi.switch.n0agl1\") ||\n             sensorNode.modelId() == QLatin1String(\"lumi.switch.b1lacn02\") || sensorNode.modelId() == QLatin1String(\"lumi.switch.b2lacn02\"))\n    {\n    }\n    else if (modelId.startsWith(QLatin1String(\"lumi\")))\n    {\n        sensorNode.setManufacturer(\"LUMI\");\n        if (!sensorNode.modelId().startsWith(QLatin1String(\"lumi.ctrl_\")) &&\n            !sensorNode.modelId().startsWith(QLatin1String(\"lumi.plug\")) &&\n            !sensorNode.modelId().startsWith(QLatin1String(\"lumi.relay.c\")) &&\n            sensorNode.modelId() != QLatin1String(\"lumi.curtain\") &&\n            !sensorNode.type().endsWith(QLatin1String(\"Battery\")))\n        {\n            sensorNode.addItem(DataTypeUInt8, RConfigBattery);\n        }\n\n        if (!sensorNode.item(RStateTemperature) &&\n            sensorNode.modelId() != QLatin1String(\"lumi.sensor_switch\") &&\n            !sensorNode.modelId().endsWith(QLatin1String(\"86opcn01\"))) // exclude Aqara Opple\n        {\n            sensorNode.addItem(DataTypeInt16, RConfigTemperature);\n            //sensorNode.addItem(DataTypeInt16, RConfigOffset);\n        }\n\n        if (sensorNode.modelId().endsWith(QLatin1String(\"86opcn01\")))\n        {\n            // Aqara switches need to be configured to send proper button events\n            // write basic cluster attribute 0x0009 value 1\n            item = sensorNode.addItem(DataTypeUInt16, RConfigPending);\n            item->setValue(item->toNumber() | R_PENDING_MODE);\n        }\n\n        if (sensorNode.modelId().startsWith(QLatin1String(\"lumi.vibration\")))\n        {\n            ResourceItem *item = nullptr;\n            if (sensorNode.type() == QLatin1String(\"ZHAVibration\"))\n            {\n                item = sensorNode.addItem(DataTypeInt16, RStateOrientationX);\n                item = sensorNode.addItem(DataTypeInt16, RStateOrientationY);\n                item = sensorNode.addItem(DataTypeInt16, RStateOrientationZ);\n                item = sensorNode.addItem(DataTypeUInt16, RStateTiltAngle);\n                item = sensorNode.addItem(DataTypeUInt16, RStateVibrationStrength);\n            }\n            // low: 0x15, medium: 0x0B, high: 0x01\n            item = sensorNode.addItem(DataTypeUInt8, RConfigSensitivity);\n            item = sensorNode.addItem(DataTypeUInt8, RConfigSensitivityMax);\n            item->setValue(0x15); // low\n            item = sensorNode.addItem(DataTypeUInt16, RConfigPending);\n        }\n    }\n    else if (modelId.startsWith(QLatin1String(\"Super TR\")) ||\n             modelId.startsWith(QLatin1String(\"ElkoDimmer\")))\n    {\n        sensorNode.setManufacturer(\"ELKO\");\n    }\n    else if ( //node->nodeDescriptor().manufacturerCode() == VENDOR_EMBER ||\n             node->nodeDescriptor().manufacturerCode() == VENDOR_HEIMAN)\n    {\n        sensorNode.setManufacturer(\"Heiman\");\n    }\n    else if (modelId == QLatin1String(\"4512705\") ||\n             modelId == QLatin1String(\"4512726\")) // Namron rotary switch\n    {\n        sensorNode.setManufacturer(\"Namron AS\");\n    }\n    else if (modelId.startsWith(QLatin1String(\"S57003\")))\n    {\n        sensorNode.setManufacturer(\"The Light Group AS\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_LGE)\n    {\n        sensorNode.setManufacturer(\"LG Electronics\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_LUTRON)\n    {\n        sensorNode.setManufacturer(\"Lutron\");\n\n        if (modelId.startsWith(QLatin1String(\"LZL4BWHL\")))\n        {\n            sensorNode.setMode(Sensor::ModeDimmer);\n        }\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_KEEN_HOME)\n    {\n        sensorNode.setManufacturer(\"Keen Home Inc\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_PHYSICAL)\n    {\n        sensorNode.setManufacturer(\"SmartThings\");\n\n        item = sensorNode.addItem(DataTypeString, RConfigAlert);\n        item->setValue(R_ALERT_DEFAULT);\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_SAMJIN)\n    {\n        sensorNode.setManufacturer(\"Samjin\");\n\n        if (PC_GetPollControlEndpoint(node) > 0)\n        {\n            item = sensorNode.addItem(DataTypeUInt16, RConfigPending);\n            item->setValue(item->toNumber() | R_PENDING_WRITE_POLL_CHECKIN_INTERVAL | R_PENDING_SET_LONG_POLL_INTERVAL);\n        }\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_INNR)\n    {\n        sensorNode.setManufacturer(\"innr\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_VISONIC)\n    {\n        sensorNode.setManufacturer(\"Visonic\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_CENTRALITE ||\n             node->nodeDescriptor().manufacturerCode() == VENDOR_C2DF)\n    {\n        sensorNode.setManufacturer(\"CentraLite\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_NYCE)\n    {\n        sensorNode.setManufacturer(\"NYCE\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_DEVELCO)\n    {\n        sensorNode.setManufacturer(\"Develco Products A/S\");\n    }\n    else if (sensorNode.manufacturer().startsWith(QLatin1String(\"TUYATEC\")))\n    {\n        sensorNode.setManufacturer(\"Tuyatec\");\n    }\n    else if (node->nodeDescriptor().manufacturerCode() == VENDOR_SERCOMM)\n    {\n        sensorNode.setManufacturer(\"Sercomm Corp.\");\n    }\n\n    if (sensorNode.manufacturer().isEmpty())\n    {\n        return; // required\n    }\n\n    // Only use the ZHAAncillaryControl sensor if present for enrollement, but only enabled for one device ATM\n    if ((clusterId == IAS_ZONE_CLUSTER_ID || (clusterId == IAS_ACE_CLUSTER_ID && sensorNode.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))) &&\n        (modelId != QLatin1String(\"URC4450BC0-X-R\") ||\n         modelId != QLatin1String(\"3405-L\") ||\n        (sensorNode.type().endsWith(QLatin1String(\"AncillaryControl\")) || !sensorNode.fingerPrint().hasOutCluster(IAS_ACE_CLUSTER_ID))))\n    {\n        if (modelId == QLatin1String(\"button\") ||\n            modelId.startsWith(QLatin1String(\"multi\")) ||\n            modelId == QLatin1String(\"water\") ||\n            R_GetProductId(&sensorNode) == QLatin1String(\"NAS-AB02B0 Siren\"))\n        {\n            // no support for some IAS flags\n        }\n        else\n        {\n            item = sensorNode.addItem(DataTypeBool, RStateLowBattery);\n            item->setValue(false);\n            item = sensorNode.addItem(DataTypeBool, RStateTampered);\n            item->setValue(false);\n        }\n        sensorNode.addItem(DataTypeUInt16, RConfigPending)->setValue(0);\n        sensorNode.addItem(DataTypeUInt32, RConfigEnrolled)->setValue(IAS_STATE_INIT);\n    }\n\n    QString uid = generateUniqueId(sensorNode.address().ext(), sensorNode.fingerPrint().endpoint, clusterId);\n    sensorNode.setUniqueId(uid);\n\n    if (!sensor2 && sensorNode.id().isEmpty())\n    {\n        openDb();\n        sensorNode.setId(QString::number(getFreeSensorId()));\n        sensorNode.setNeedSaveDatabase(true);\n        closeDb();\n    }\n\n    if (sensorNode.name().isEmpty())\n    {\n        QString name = type;\n        if (name.startsWith(\"ZHA\"))\n        {\n            name.remove(0, 3);\n        }\n        sensorNode.setName(QString(\"%1 %2\").arg(name).arg(sensorNode.id()));\n    }\n\n    // force reading attributes\n    if (node->isRouter())\n    {\n        sensorNode.setNextReadTime(READ_BINDING_TABLE, queryTime);\n        sensorNode.enableRead(READ_BINDING_TABLE);\n        sensorNode.setLastRead(READ_BINDING_TABLE, idleTotalCounter);\n        queryTime = queryTime.addSecs(1);\n    }\n    {\n        std::vector<quint16>::const_iterator ci = fingerPrint.inClusters.begin();\n        std::vector<quint16>::const_iterator cend = fingerPrint.inClusters.end();\n        for (;ci != cend; ++ci)\n        {\n            if (*ci == OCCUPANCY_SENSING_CLUSTER_ID)\n            {\n                sensorNode.setNextReadTime(READ_OCCUPANCY_CONFIG, queryTime);\n                sensorNode.enableRead(READ_OCCUPANCY_CONFIG);\n                sensorNode.setLastRead(READ_OCCUPANCY_CONFIG, idleTotalCounter);\n                queryTime = queryTime.addSecs(1);\n            }\n            else if (*ci == BASIC_CLUSTER_ID)\n            {\n                if (sensorNode.modelId().isEmpty())\n                {\n                    DBG_Printf(DBG_INFO, \"SensorNode %u: %s read model id and vendor name\\n\", sensorNode.id().toUInt(), qPrintable(sensorNode.name()));\n                    sensorNode.setNextReadTime(READ_MODEL_ID, queryTime);\n                    sensorNode.setLastRead(READ_MODEL_ID, idleTotalCounter);\n                    sensorNode.enableRead(READ_MODEL_ID);\n                    queryTime = queryTime.addSecs(1);\n                }\n\n                if (sensorNode.manufacturer().isEmpty())\n                {\n                    sensorNode.setNextReadTime(READ_VENDOR_NAME, queryTime);\n                    sensorNode.setLastRead(READ_VENDOR_NAME, idleTotalCounter);\n                    sensorNode.enableRead(READ_VENDOR_NAME);\n                    queryTime = queryTime.addSecs(1);\n                }\n            }\n            else if (*ci == POWER_CONFIGURATION_CLUSTER_ID)\n            {\n                //This device make a Rejoin every time, you trigger it, it's the only moment where you can read attribute.\n                if (sensorNode.modelId() == QLatin1String(\"Remote switch\") ||\n                    sensorNode.modelId() == QLatin1String(\"Shutters central remote switch\") ||\n                    sensorNode.modelId() == QLatin1String(\"Pocket remote\") ||\n                    sensorNode.modelId() == QLatin1String(\"Double gangs remote switch\") )\n                {\n                    //Ask for battery but only every day max\n                    //int diff = idleTotalCounter - sensorNode.lastRead(READ_BATTERY);\n                    //if (diff > 24 * 3600)\n                    {\n                        sensorNode.setNextReadTime(READ_BATTERY, queryTime);\n                        sensorNode.setLastRead(READ_BATTERY, idleTotalCounter);\n                        sensorNode.enableRead(READ_BATTERY);\n                        queryTime = queryTime.addSecs(1);\n                    }\n                }\n            }\n            else if (*ci == TIME_CLUSTER_ID)\n            {\n                if (!DEV_TestStrict())\n                {\n                    if (sensorNode.modelId() == QLatin1String(\"Thermostat\")) // eCozy\n                    {\n                        DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: set READ_TIME from addSensorNode()\\n\", qPrintable(sensorNode.type()), qPrintable(sensorNode.name()));\n                        sensorNode.setNextReadTime(READ_TIME, queryTime);\n                        sensorNode.setLastRead(READ_TIME, idleTotalCounter);\n                        sensorNode.enableRead(READ_TIME);\n                        queryTime = queryTime.addSecs(1);\n                    }\n                }\n            }\n        }\n    }\n\n    sensorNode.setNeedSaveDatabase(true);\n\n    if (sensor2)\n    {\n        DBG_Printf(DBG_INFO, \"[7] update existing sensor %s (%s)\\n\", qPrintable(sensor2->id()), qPrintable(modelId));\n        *sensor2 = sensorNode;\n    }\n    else\n    {\n        DBG_Printf(DBG_INFO, \"SensorNode %s: %s added\\n\", qPrintable(sensorNode.id()), qPrintable(sensorNode.name()));\n        sensorNode.setHandle(R_CreateResourceHandle(&sensorNode, sensors.size()));\n        sensors.push_back(sensorNode);\n        sensor2 = &sensors.back();\n        updateSensorEtag(sensor2);\n        needRuleCheck = RULE_CHECK_DELAY;\n        device->addSubDevice(sensor2);\n    }\n\n    if (searchSensorsState == SearchSensorsActive)\n    {\n        Event e(RSensors, REventAdded, sensorNode.id());\n        enqueueEvent(e);\n\n        // check missing queries\n        if (!fastProbeTimer->isActive())\n        {\n            fastProbeTimer->start(100);\n        }\n\n        if (modelId.startsWith(QLatin1String(\"lumi.\")))\n        {\n            for (const auto &ind : fastProbeIndications)\n            {\n                if ((ind.clusterId() == BASIC_CLUSTER_ID || ind.clusterId() == XIAOMI_CLUSTER_ID) && ind.profileId() != ZDP_PROFILE_ID)\n                {\n                    deCONZ::ZclFrame zclFrame;\n\n                    {\n                        QDataStream stream(ind.asdu());\n                        stream.setByteOrder(QDataStream::LittleEndian);\n                        zclFrame.readFromStream(stream);\n                    }\n\n                    // replay Xiaomi special report\n                    handleZclAttributeReportIndicationXiaomiSpecial(ind, zclFrame);\n                }\n            }\n        }\n    }\n\n    sensor2->rx();\n    checkSensorBindingsForAttributeReporting(sensor2);\n\n\n    Q_Q(DeRestPlugin);\n    q->startZclAttributeTimer(checkZclAttributesDelay);\n\n    queSaveDb(DB_SENSORS , DB_SHORT_SAVE_DELAY);\n}\n\n/*! Updates  ZHALightLevel sensor /state: lightlevel, lux, dark and daylight.\n    \\param sensor - the sensor\n    \\param measuredValue - 16-bit light level\n */\nvoid DeRestPluginPrivate::updateSensorLightLevel(Sensor &sensor, quint16 measuredValue)\n{\n    const quint16 measuredValueIn = measuredValue;\n    ResourceItem *item = sensor.item(RStateLightLevel);\n\n    if (!item)\n    {\n        return;\n    }\n\n    if (sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\n    {\n        // measured value is given as lux: transform\n        // ZCL Attribute = 10.000 * log10(Illuminance (lx)) + 1\n        double ll = 10000 * std::log10(measuredValue) + 1;\n        if (ll > 0xfffe) { measuredValue = 0xfffe; }\n        else             { measuredValue = ll; }\n    }\n\n    if (item)\n    {\n        item->setValue(measuredValue);\n        sensor.updateStateTimestamp();\n        sensor.setNeedSaveDatabase(true);\n        Event e(RSensors, RStateLightLevel, sensor.id(), item);\n        enqueueEvent(e);\n        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n    }\n\n    quint16 tholddark = R_THOLDDARK_DEFAULT;\n    quint16 tholdoffset = R_THOLDOFFSET_DEFAULT;\n    item = sensor.item(RConfigTholdDark);\n    if (item)\n    {\n        tholddark = item->toNumber();\n    }\n    item = sensor.item(RConfigTholdOffset);\n    if (item)\n    {\n        tholdoffset = item->toNumber();\n    }\n    bool dark = measuredValue <= tholddark;\n    bool daylight = measuredValue >= tholddark + tholdoffset;\n\n    item = sensor.item(RStateDark);\n    // if (!item)\n    // {\n    //     item = sensor.addItem(DataTypeBool, RStateDark);\n        DBG_Assert(item != 0);\n    // }\n    if (item && item->setValue(dark))\n    {\n        if (item->lastChanged() == item->lastSet())\n        {\n            Event e(RSensors, RStateDark, sensor.id(), item);\n            enqueueEvent(e);\n        }\n    }\n\n    item = sensor.item(RStateDaylight);\n    // if (!item)\n    // {\n    //     item = sensor.addItem(DataTypeBool, RStateDaylight);\n        DBG_Assert(item != 0);\n    // }\n    if (item && item->setValue(daylight))\n    {\n        if (item->lastChanged() == item->lastSet())\n        {\n            Event e(RSensors, RStateDaylight, sensor.id(), item);\n            enqueueEvent(e);\n        }\n    }\n\n    item = sensor.item(RStateLux);\n\n    // if (!item)\n    // {\n    //     item = sensor.addItem(DataTypeUInt32, RStateLux);\n        DBG_Assert(item != 0);\n    // }\n\n    if (item)\n    {\n        quint32 lux = 0;\n        if (sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\n        {   // measured values is actually given in lux\n            lux = measuredValueIn;\n        }\n        else if (measuredValue > 0 && measuredValue < 0xffff)\n        {\n            // valid values are 1 - 0xfffe\n            // 0, too low to measure\n            // 0xffff invalid value\n\n            // ZCL Attribute = 10.000 * log10(Illuminance (lx)) + 1\n            // lux = 10^((ZCL Attribute - 1)/10.000)\n            qreal exp = measuredValue - 1;\n            qreal l = qPow(10, exp / 10000.0f);\n            l += 0.5;   // round value\n            lux = static_cast<quint32>(l);\n        }\n        item->setValue(lux);\n        if (item->lastChanged() == item->lastSet())\n        {\n            Event e(RSensors, RStateLux, sensor.id(), item);\n            enqueueEvent(e);\n        }\n    }\n}\n\n/*! Updates/adds a SensorNode from a Node.\n    If the node does not exist it will be created\n    otherwise the values will be checked for change\n    and updated in the internal representation.\n    \\param node - holds up to date data\n */\nvoid DeRestPluginPrivate::updateSensorNode(const deCONZ::NodeEvent &event)\n{\n    if (!event.node())\n    {\n        return;\n    }\n\n    // filter for relevant clusters\n    if (event.profileId() == HA_PROFILE_ID || event.profileId() == ZLL_PROFILE_ID)\n    {\n        switch (event.clusterId())\n        {\n        case ILLUMINANCE_MEASUREMENT_CLUSTER_ID:\n        case TEMPERATURE_MEASUREMENT_CLUSTER_ID:\n        case RELATIVE_HUMIDITY_CLUSTER_ID:\n        case PRESSURE_MEASUREMENT_CLUSTER_ID:\n        case SOIL_MOISTURE_CLUSTER_ID:\n        case BASIC_CLUSTER_ID:\n        case ONOFF_CLUSTER_ID:\n        case ANALOG_INPUT_CLUSTER_ID:\n        case MULTISTATE_INPUT_CLUSTER_ID:\n        case BINARY_INPUT_CLUSTER_ID:\n        case DOOR_LOCK_CLUSTER_ID:\n        case SAMJIN_CLUSTER_ID:\n        case VENDOR_CLUSTER_ID:\n        case BOSCH_AIR_QUALITY_CLUSTER_ID:\n            break;\n\n        default:\n            return; // don't process further\n        }\n    }\n    else\n    {\n        return; // don't process further\n    }\n\n    std::vector<Sensor>::iterator i = sensors.begin();\n    std::vector<Sensor>::iterator end = sensors.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address().ext() != event.node()->address().ext())\n        {\n            continue;\n        }\n\n        if (i->deletedState() != Sensor::StateNormal)\n        {\n            continue;\n        }\n\n        if (i->node() != event.node())\n        {\n            i->setNode(const_cast<deCONZ::Node*>(event.node()));\n        }\n\n        if (event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclReport ||\n            event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclRead)\n        {\n            i->rx();\n        }\n\n        checkSensorNodeReachable(&*i, &event);\n\n        if (!i->isAvailable())\n        {\n            continue;\n        }\n\n        if (event.event() == deCONZ::NodeEvent::UpdatedPowerDescriptor)\n        {\n            if (event.node()->powerDescriptor().isValid())\n            {\n                ResourceItem *item = i->item(RConfigBattery);\n                int battery = 255; // invalid\n\n                if (event.node()->powerDescriptor().currentPowerSource() == deCONZ::PowerSourceRechargeable ||\n                    event.node()->powerDescriptor().currentPowerSource() == deCONZ::PowerSourceDisposable)\n                {\n                    switch (event.node()->powerDescriptor().currentPowerLevel())\n                    {\n                    case deCONZ::PowerLevel100:      battery = 100; break;\n                    case deCONZ::PowerLevel66:       battery = 66; break;\n                    case deCONZ::PowerLevel33:       battery = 33; break;\n                    case deCONZ::PowerLevelCritical: battery = 0; break;\n                    default:\n                        break;\n                    }\n                }\n\n                if (item)\n                {\n                    item->setValue(battery);\n                    Event e(RSensors, RConfigBattery, i->id(), item);\n                    enqueueEvent(e);\n                }\n                updateSensorEtag(&*i);\n            }\n            return;\n        }\n\n        if (event.clusterId() == BOSCH_AIR_QUALITY_CLUSTER_ID && !(i->modelId() == QLatin1String(\"AIR\") && event.node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2))\n        {\n            continue; // Bosch Air quality sensor\n        }\n\n        if (event.clusterId() != BASIC_CLUSTER_ID && event.clusterId() != POWER_CONFIGURATION_CLUSTER_ID && event.clusterId() != VENDOR_CLUSTER_ID)\n        {\n            // filter endpoint\n            if (event.endpoint() != i->fingerPrint().endpoint)\n            {\n                if (existDevicesWithVendorCodeForMacPrefix(event.node()->address(), VENDOR_JENNIC))\n                {\n                    if (i->modelId().startsWith(QLatin1String(\"lumi.sensor_86sw\")) ||\n                        i->modelId().startsWith(QLatin1String(\"lumi.ctrl_neutral\")) ||\n                        (i->modelId().startsWith(QLatin1String(\"lumi.ctrl_ln\")) && event.clusterId() == MULTISTATE_INPUT_CLUSTER_ID) ||\n                        (i->modelId().startsWith(QLatin1String(\"lumi.remote\")) && event.clusterId() == MULTISTATE_INPUT_CLUSTER_ID))\n                    { // 3 endpoints: 1 sensor\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n                else\n                {\n                    continue;\n                }\n            }\n\n            // assume data must be in server cluster attribute\n            bool found = false;\n            std::vector<quint16>::const_iterator ci = i->fingerPrint().inClusters.begin();\n            std::vector<quint16>::const_iterator cend = i->fingerPrint().inClusters.end();\n            for (; ci != cend; ++ci)\n            {\n                if (*ci == event.clusterId())\n                {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found)\n            {\n                continue;\n            }\n        }\n\n        const deCONZ::SimpleDescriptor *sd = getSimpleDescriptor(event.node(), event.endpoint());\n        if (sd)\n        {\n            auto ic = sd->inClusters().cbegin();\n            const auto endc = sd->inClusters().cend();\n\n            for (; ic != endc; ++ic)\n            {\n                if (ic->id() == event.clusterId())\n                {\n                    std::vector<deCONZ::ZclAttribute>::const_iterator ia = ic->attributes().begin();\n                    std::vector<deCONZ::ZclAttribute>::const_iterator enda = ic->attributes().end();\n\n                    NodeValue::UpdateType updateType = NodeValue::UpdateInvalid;\n                    if (event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclRead)\n                    {\n                        updateType = NodeValue::UpdateByZclRead;\n                    }\n                    else if (event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclReport)\n                    {\n                        updateType = NodeValue::UpdateByZclReport;\n                    }\n\n                    if (event.clusterId() == BOSCH_AIR_QUALITY_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            if (ia->id() == 0x4001) // air pressure (mBar)\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                const auto pressure = ia->numericValue().u16;\n                                ResourceItem *item = i->item(RStatePressure);\n\n                                if (item)\n                                {\n                                    item->setValue(pressure);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    enqueueEvent(Event(RSensors, item->descriptor().suffix, i->id(), item));\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                            else if (ia->id() == 0x4003) // humidity (%)\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                ResourceItem *item = i->item(RStateHumidity);\n\n                                if (item)\n                                {\n                                    item->setValue(static_cast<quint16>(ia->numericValue().u8) * 100);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    enqueueEvent(Event(RSensors, item->descriptor().suffix, i->id(), item));\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                            else if (ia->id() == 0x4005) // measured illuminance (lux)\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                updateSensorLightLevel(*i, ia->numericValue().u16); // ZigBee uses a 16-bit measured value\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == ILLUMINANCE_MEASUREMENT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            if (ia->id() == 0x0000) // measured illuminance (lux)\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                updateSensorLightLevel(*i, ia->numericValue().u16); // ZigBee uses a 16-bit measured value\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == TEMPERATURE_MEASUREMENT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0000) // temperature (0.01 °C)\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                int temp = ia->numericValue().s16;\n                                ResourceItem *item = i->item(RStateTemperature);\n\n                                if (item)\n                                {\n                                    ResourceItem *item2 = i->item(RConfigOffset);\n                                    if (item2 && item2->toNumber() != 0)\n                                    {\n                                        temp += item2->toNumber();\n                                    }\n                                    item->setValue(temp);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n\n                                    if (item2)\n                                    {\n                                        DDF_AnnoteZclParse(&*i, item, event.endpoint(), event.clusterId(), ia->id(), \"Item.val = Attr.val + R.item('config/offset').val\");\n                                    }\n                                    else\n                                    {\n                                        DDF_AnnoteZclParse(&*i, item, event.endpoint(), event.clusterId(), ia->id(), \"Item.val = Attr.val\");\n                                    }\n\n                                    Event e(RSensors, RStateTemperature, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                            else if (i->modelId().startsWith(QLatin1String(\"VOC_Sensor\")) && ia->id() == 0x0001) // LifeControl MCLH-08 relative humidity\n                            {\n                                // humidity sensor values are transferred via temperature cluster 0x0001 attribute\n                                // see: https://github.com/dresden-elektronik/deconz-rest-plugin/pull/1964\n\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0001, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                int humidity = ia->numericValue().u16;\n                                ResourceItem *item = i->item(RStateHumidity);\n\n                                if (item)\n                                {\n                                    ResourceItem *item2 = i->item(RConfigOffset);\n                                    if (item2 && item2->toNumber() != 0)\n                                    {\n                                        int _humidity = humidity + static_cast<int>(item2->toNumber());\n                                        humidity = _humidity < 0 ? 0 : _humidity > 10000 ? 10000 : _humidity;\n                                    }\n                                    item->setValue(humidity);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStateHumidity, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == RELATIVE_HUMIDITY_CLUSTER_ID)\n                    {\n                        if (i->modelId() == QLatin1String(\"AIR\") && event.node()->nodeDescriptor().manufacturerCode() == VENDOR_BOSCH2)\n                        {\n                            continue; // Bosch Air quality sensor has invalid value here, it will be taken from BOSCH_AIR_QUALITY_CLUSTER_ID\n                        }\n\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0000) // relative humidity\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                int humidity = ia->numericValue().u16;\n                                ResourceItem *item = i->item(RStateHumidity);\n\n                                if (item)\n                                {\n                                    ResourceItem *item2 = i->item(RConfigOffset);\n                                    if (item2 && item2->toNumber() != 0)\n                                    {\n                                        qint16 _humidity = humidity + item2->toNumber();\n                                        humidity = _humidity < 0 ? 0 : _humidity > 10000 ? 10000 : _humidity;\n                                    }\n                                    item->setValue(humidity);\n\n                                    if (item2)\n                                    {\n                                        DDF_AnnoteZclParse(&*i, item, event.endpoint(), event.clusterId(), ia->id(), \"Item.val = Attr.val + R.item('config/offset').val\");\n                                    }\n                                    else\n                                    {\n                                        DDF_AnnoteZclParse(&*i, item, event.endpoint(), event.clusterId(), ia->id(), \"Item.val = Attr.val\");\n                                    }\n\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStateHumidity, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == PRESSURE_MEASUREMENT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0000) // pressure\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                qint16 pressure = ia->numericValue().s16;\n                                ResourceItem *item = i->item(RStatePressure);\n\n                                if (item)\n                                {\n                                    ResourceItem *item2 = i->item(RConfigOffset);\n                                    if (item2 && item2->toNumber() != 0)\n                                    {\n                                        pressure += item2->toNumber();\n                                    }\n\n                                    item->setValue(pressure);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStatePressure, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == SOIL_MOISTURE_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0000) // Soil Moisture\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), 0x0000, ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                qint16 soil_moisture = ia->numericValue().s16 / 100;\n                                ResourceItem *item = i->item(RStateMoisture);\n\n                                if (item)\n                                {\n                                    item->setValue(soil_moisture);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStateMoisture, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == ONOFF_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            if (ia->id() == 0x0000) // onoff\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                                }\n\n                                ResourceItem *item = i->item(RStateOpen);\n\n                                if (item)\n                                {\n                                    bool open = ia->numericValue().u8 == 1;\n                                    item->setValue(open);\n\n                                    if (item->lastSet() == item->lastChanged())\n                                    {\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                    }\n                                    i->setNeedSaveDatabase(true);\n                                    i->updateStateTimestamp();\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                item = i->item(RStateButtonEvent);\n\n                                if (item && // i->buttonMap(buttonMapData, buttonMapForModelId).empty() &&\n                                    event.event() == deCONZ::NodeEvent::UpdatedClusterDataZclReport)\n                                {\n                                    quint32 button = 0;\n\n                                    if (i->modelId().startsWith(QLatin1String(\"lumi.sensor_86sw\")))\n                                    {\n                                        button = (S_BUTTON_1 * event.endpoint()) + S_BUTTON_ACTION_SHORT_RELEASED;\n                                    }\n                                    else if (i->modelId() == QLatin1String(\"lumi.sensor_switch\"))\n                                    { // handeled by button map\n                                    }\n                                    else if (i->modelId() == QLatin1String(\"lumi.sensor_switch.aq2\"))\n                                    { // handeled by button map\n                                    }\n                                    else if (i->modelId().startsWith(QLatin1String(\"lumi.ctrl_neutral\")))\n                                    {\n                                        switch (event.endpoint())\n                                        {\n                                        case 4: button = S_BUTTON_1 + S_BUTTON_ACTION_SHORT_RELEASED; break;\n                                        case 5: button = S_BUTTON_2 + S_BUTTON_ACTION_SHORT_RELEASED; break;\n                                        case 6: button = S_BUTTON_3 + S_BUTTON_ACTION_SHORT_RELEASED; break;\n                                        default: // should not happen\n                                            // button = (S_BUTTON_1 * event.endpoint()) + S_BUTTON_ACTION_SHORT_RELEASED;\n                                            break;\n                                        }\n                                    }\n                                    else\n                                    {\n                                        if (ia->numericValue().u8 == 0) { button = S_BUTTON_1 + S_BUTTON_ACTION_INITIAL_PRESS; }\n                                        else                            { button = S_BUTTON_1 + S_BUTTON_ACTION_SHORT_RELEASED; }\n                                    }\n\n                                    if (button)\n                                    {\n                                        item->setValue(button);\n\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                        i->setNeedSaveDatabase(true);\n                                        i->updateStateTimestamp();\n                                        enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                    }\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == SAMJIN_CLUSTER_ID)\n                    {\n                        bool updated = false;\n\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            if (ia->id() == 0x0010) // active\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u8);\n                                }\n\n                                ResourceItem *item = i->item(RStateVibration);\n                                if (item)\n                                {\n                                    const bool vibration = ia->numericValue().u8 == 0x01;\n                                    item->setValue(vibration);\n                                    updated = true;\n\n                                    if (item->lastSet() == item->lastChanged())\n                                    {\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0x0012) // accelerate x\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                ResourceItem *item = i->item(RStateOrientationX);\n\n                                if (item)\n                                {\n                                    item->setValue(ia->numericValue().s16);\n                                    updated = true;\n\n                                    if (item->lastSet() == item->lastChanged())\n                                    {\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0x0013) // accelerate y\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                ResourceItem *item = i->item(RStateOrientationY);\n\n                                if (item)\n                                {\n                                    item->setValue(ia->numericValue().s16);\n                                    updated = true;\n\n                                    if (item->lastSet() == item->lastChanged())\n                                    {\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0x0014) // accelerate z\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().s16);\n                                }\n\n                                ResourceItem *item = i->item(RStateOrientationZ);\n\n                                if (item)\n                                {\n                                    item->setValue(ia->numericValue().s16);\n                                    updated = true;\n\n                                    if (item->lastSet() == item->lastChanged())\n                                    {\n                                        Event e(RSensors, item->descriptor().suffix, i->id(), item);\n                                        enqueueEvent(e);\n                                    }\n                                }\n                            }\n                        }\n\n                        if (updated)\n                        {\n                            i->setNeedSaveDatabase(true);\n                            i->updateStateTimestamp();\n                            enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                        }\n                    }\n                    else if (event.clusterId() == BASIC_CLUSTER_ID)\n                    {\n                        DBG_Printf(DBG_INFO_L2, \"Update Sensor 0x%016llX Basic Cluster\\n\", event.node()->address().ext());\n\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            // Correct incomplete sensor fingerprint\n                            if (!i->fingerPrint().hasInCluster(BASIC_CLUSTER_ID))\n                            {\n                                i->fingerPrint().inClusters.push_back(BASIC_CLUSTER_ID);\n                            }\n\n                            if (ia->id() == 0x0005) // Model identifier\n                            {\n                                if (i->mustRead(READ_MODEL_ID))\n                                {\n                                    i->clearRead(READ_MODEL_ID);\n                                }\n\n                                QString str = ia->toString().simplified();\n\n                                if (isLidlDevice(str, i->manufacturer()))\n                                {\n                                    // Ignore non-unique ModelIdentifier; modelid set from unqiue ManufacturerName.\n                                    continue;\n                                }\n\n                                if (str == QLatin1String(\"895a2d80097f4ae2b2d40500d5e03dcc\"))\n                                {\n                                    str = QLatin1String(\"SN10ZW motion sensor\");\n                                }\n                                else if (str == QLatin1String(\"b5db59bfd81e4f1f95dc57fdbba17931\"))\n                                {\n                                    str = QLatin1String(\"SF20 smoke sensor\");\n                                }\n                                else if (str == QLatin1String(\"98293058552c49f38ad0748541ee96ba\"))\n                                {\n                                    str = QLatin1String(\"SF21 smoke sensor\");\n                                }\n                                else if (str == QLatin1String(\"898ca74409a740b28d5841661e72268d\") ||\n                                         str == QLatin1String(\"50938c4c3c0b4049923cd5afbc151bde\"))\n                                {\n                                    str = QLatin1String(\"ST30 Temperature Sensor\");\n                                }\n                                if (!str.isEmpty())\n                                {\n                                    if (i->modelId() != str)\n                                    {\n                                        auto *item = i->item(RAttrModelId);\n                                        i->setModelId(str);\n                                        i->setNeedSaveDatabase(true);\n                                        checkInstaModelId(&*i);\n                                        updateSensorEtag(&*i);\n                                        pushSensorInfoToCore(&*i);\n                                        queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n                                        enqueueEvent({i->prefix(), item->descriptor().suffix, i->id(), item, i->address().ext()});\n                                    }\n\n                                    if (i->name() == QString(\"Switch %1\").arg(i->id()))\n                                    {\n                                        QString name = QString(\"%1 %2\").arg(str).arg(i->id());\n                                        if (i->name() != name)\n                                        {\n                                            i->setName(name);\n                                            i->setNeedSaveDatabase(true);\n                                            updateSensorEtag(&*i);\n                                        }\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0x0004) // Manufacturer Name\n                            {\n                                if (i->mustRead(READ_VENDOR_NAME))\n                                {\n                                    i->clearRead(READ_VENDOR_NAME);\n                                }\n\n                                QString str = ia->toString().simplified();\n                                const lidlDevice *device = getLidlDevice(str);\n\n                                if (device != nullptr)\n                                {\n                                    QString str2 = QLatin1String(device->modelid);\n\n                                    if (!str2.isEmpty() && str2 != i->modelId())\n                                    {\n                                        i->setModelId(str);\n                                        i->setNeedSaveDatabase(true);\n                                        checkInstaModelId(&*i);\n                                        updateSensorEtag(&*i);\n                                        pushSensorInfoToCore(&*i);\n                                        queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n                                    }\n                                    str = QLatin1String(device->manufacturername);\n                                }\n\n                                if (str.startsWith(QLatin1String(\"TUYATEC\")))\n                                {\n                                    str = QLatin1String(\"Tuyatec\"); // normalize TUYATEC-xdqihhgb --> Tuyatec\n                                }\n\n                                if (i->modelId().startsWith(QLatin1String(\"TRADFRI\")))\n                                {\n                                    str = QLatin1String(\"IKEA of Sweden\"); // Fix: since some IKEA devices had a bug returning an invalid string\n                                }\n\n                                if (!str.isEmpty())\n                                {\n                                    if (i->manufacturer() != str)\n                                    {\n                                        auto *item = i->item(RAttrManufacturerName);\n                                        updateSensorEtag(&*i);\n                                        i->setManufacturer(str);\n                                        i->setNeedSaveDatabase(true);\n                                        pushSensorInfoToCore(&*i);\n                                        queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n                                        enqueueEvent({i->prefix(), item->descriptor().suffix, i->id(), item, i->address().ext()});\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0x0006) // Date code as fallback for sw build id\n                            {\n                                QString str = ia->toString().simplified();\n\n                                if (!i->swVersion().isEmpty() && !i->modelId().startsWith(QLatin1String(\"lumi.\")))\n                                {\n                                    // check\n                                }\n                                else if (!str.isEmpty() && str != i->swVersion())\n                                {\n                                    i->setSwVersion(str);\n                                    i->setNeedSaveDatabase(true);\n                                    pushSensorInfoToCore(&*i);\n                                    queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n                                    updateSensorEtag(&*i);\n                                }\n                            }\n                            else if (ia->id() == 0x4000) // Software build identifier\n                            {\n                                if (i->mustRead(READ_SWBUILD_ID))\n                                {\n                                    i->clearRead(READ_SWBUILD_ID);\n                                }\n                                QString str = ia->toString().simplified();\n                                if (!str.isEmpty())\n                                {\n                                    if (str != i->swVersion())\n                                    {\n                                        i->setSwVersion(str);\n                                        i->setNeedSaveDatabase(true);\n                                        pushSensorInfoToCore(&*i);\n                                        queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n                                        updateSensorEtag(&*i);\n                                    }\n                                }\n                            }\n                            else if (ia->id() == 0xff0d && i->modelId().startsWith(QLatin1String(\"lumi.vibration\"))) // sensitivity\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                }\n\n                                const quint8 sensitivity = ia->numericValue().u8;\n                                ResourceItem *item = i->item(RConfigSensitivity);\n\n                                if (item && item->toNumber() != sensitivity)\n                                {\n                                    if (!item->lastSet().isValid())\n                                    {\n                                        item->setValue(sensitivity);\n                                    }\n                                    else\n                                    {\n                                        // values differs\n                                        quint16 pending = R_PENDING_SENSITIVITY;\n                                        ResourceItem *item2 = i->item(RConfigPending);\n                                        DBG_Assert(item2);\n                                        if (item2)\n                                        {\n                                            if (item2->lastSet().isValid())\n                                            {\n                                                pending |= item2->toNumber();\n                                            }\n\n                                            item2->setValue(pending);\n                                        }\n                                    }\n\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RConfigSensitivity, i->id(), item);\n                                    enqueueEvent(e);\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == ANALOG_INPUT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0055) // present value\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                }\n\n                                if ((i->modelId() == QLatin1String(\"lumi.plug\") && event.endpoint() == 2) ||\n                                         (i->modelId() == QLatin1String(\"lumi.switch.b1nacn02\") && event.endpoint() == 2) ||\n                                         (i->modelId() == QLatin1String(\"lumi.switch.b2nacn02\") && event.endpoint() == 3) ||\n                                         (i->modelId().startsWith(QLatin1String(\"lumi.ctrl_\")) && event.endpoint() == 2) ||\n                                          i->modelId().startsWith(QLatin1String(\"lumi.relay.c\")))\n                                {\n                                    if (i->type() == QLatin1String(\"ZHAPower\"))\n                                    {\n                                        qint16 power = static_cast<qint16>(round(ia->numericValue().real));\n                                        ResourceItem *item = i->item(RStatePower);\n\n                                        if (item)\n                                        {\n                                            item->setValue(power); // in W\n                                            i->updateStateTimestamp();\n                                            i->setNeedSaveDatabase(true);\n                                            enqueueEvent(Event(RSensors, RStatePower, i->id(), item));\n                                            enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                        }\n                                        updateSensorEtag(&*i);\n                                    }\n                                }\n                                else if ((i->modelId() == QLatin1String(\"lumi.plug\") && event.endpoint() == 3) ||\n                                         (i->modelId() == QLatin1String(\"lumi.switch.b1nacn02\") && event.endpoint() == 3) ||\n                                         (i->modelId() == QLatin1String(\"lumi.switch.b2nacn02\") && event.endpoint() == 4) ||\n                                         (i->modelId().startsWith(QLatin1String(\"lumi.ctrl_\")) && event.endpoint() == 3))\n                                {\n                                    if (i->type() == QLatin1String(\"ZHAConsumption\"))\n                                    {\n                                        quint64 consumption = round(ia->numericValue().real) * 1000;\n                                        ResourceItem *item = i->item(RStateConsumption);\n\n                                        if (item)\n                                        {\n                                            item->setValue(consumption); // in 0.001 kWh\n                                            i->updateStateTimestamp();\n                                            i->setNeedSaveDatabase(true);\n                                            enqueueEvent(Event(RSensors, RStateConsumption, i->id(), item));\n                                            enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                        }\n                                        updateSensorEtag(&*i);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == MULTISTATE_INPUT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == MULTI_STATE_INPUT_PRESENT_VALUE_ATTRIBUTE_ID) // present value\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                    pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                }\n\n                                qint32 buttonevent = -1;\n                                qint32 gesture = -1; //\n                                ResourceItem *item = i->item(RStateButtonEvent);\n                                int rawValue = ia->numericValue().u16;\n\n                                DBG_Printf(DBG_INFO, \"Multi state present value: 0x%04X (%u), %s\\n\", rawValue, rawValue, qPrintable(i->modelId()));\n\n                                if (i->modelId() == QLatin1String(\"lumi.remote.b186acn02\") ||\n                                    i->modelId() == QLatin1String(\"lumi.remote.b286acn01\") ||\n                                    i->modelId() == QLatin1String(\"lumi.remote.b286acn02\"))\n                                {\n                                    buttonevent = S_BUTTON_1 * event.endpoint();\n                                    switch (rawValue)\n                                    {\n                                        case   0: buttonevent += S_BUTTON_ACTION_HOLD;           break;\n                                        case   1: buttonevent += S_BUTTON_ACTION_SHORT_RELEASED; break;\n                                        case   2: buttonevent += S_BUTTON_ACTION_DOUBLE_PRESS;   break;\n                                        case 255: buttonevent += S_BUTTON_ACTION_LONG_RELEASED;  break;\n                                        default:\n                                        {\n                                            DBG_Printf(DBG_INFO, \"unsupported button rawValue 0x%04X\\n\", rawValue);\n                                            buttonevent = -1;\n                                        }\n                                            break;\n                                    }\n                                }\n                                else if (i->modelId() == QLatin1String(\"lumi.ctrl_ln1.aq1\"))\n                                {\n                                    // handeled by button map\n                                }\n                                else if (i->modelId() == QLatin1String(\"lumi.ctrl_ln2.aq1\"))\n                                {\n                                    // handeled by button map\n                                }\n                                else if (i->modelId().startsWith(QLatin1String(\"lumi.ctrl_ln\")))\n                                {\n                                    // TODO The following can likely be removed sine lumi.ctrl_ln1.aq1 and lumi.ctrl_ln2.aq1 are using button maps now.\n                                    //      are there any other lumi.ctrl_ln* devices?\n                                    //      The lumi.ctrl_ln1.aq2, lumi.ctrl_ln2.aq2 seem to be a typo, the Internet only knows .aq1 versions\n                                    //      and versions without .aq1? https://github.com/Koenkk/zigbee-herdsman-converters/blob/master/devices.js#L716.\n                                    switch (event.endpoint())\n                                    {\n                                        case 0x05: buttonevent = S_BUTTON_1; break;\n                                        case 0x06: buttonevent = S_BUTTON_2; break;\n                                        case 0x07: buttonevent = S_BUTTON_3; break;\n                                        default: break;\n                                    }\n                                    if (buttonevent != -1)\n                                    {\n                                        switch (rawValue) {\n                                            case 1: buttonevent += S_BUTTON_ACTION_SHORT_RELEASED; break;\n                                            case 2: buttonevent += S_BUTTON_ACTION_DOUBLE_PRESS;   break;\n                                            default: buttonevent = -1; break;\n                                        }\n                                    }\n                                }\n\n                                if (item && buttonevent != -1)\n                                {\n                                    item->setValue(buttonevent);\n                                    DBG_Printf(DBG_INFO, \"[INFO] - Button %u %s\\n\", item->toNumber(), qPrintable(i->modelId()));\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStateButtonEvent, i->id(), item);\n                                    enqueueEvent(e);\n                                }\n\n                                item = (gesture != -1) ? i->item(RStateGesture) : nullptr;\n                                if (item && gesture != -1)\n                                {\n                                    item->setValue(gesture);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStateGesture, i->id(), item);\n                                    enqueueEvent(e);\n                                }\n\n                                if (gesture != -1 || buttonevent != -1) // something was updated\n                                {\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                                }\n\n                                updateSensorEtag(&*i);\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == BINARY_INPUT_CLUSTER_ID)\n                    {\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0055) // present value\n                            {\n                                if (updateType != NodeValue::UpdateInvalid)\n                                {\n                                    i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                }\n\n                                const NodeValue &val = i->getZclValue(event.clusterId(), 0x0055);\n\n                                ResourceItem *item = i->item(RStatePresence);\n\n                                if (item)\n                                {\n                                    item->setValue(true);\n                                    i->updateStateTimestamp();\n                                    i->setNeedSaveDatabase(true);\n                                    Event e(RSensors, RStatePresence, i->id(), item);\n                                    enqueueEvent(e);\n                                    enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n\n                                    DDF_AnnoteZclParse(&*i, item, event.endpoint(), event.clusterId(), ia->id(), \"Item.val = true\");\n\n                                    // prepare to automatically set presence to false\n                                    if (item->toBool())\n                                    {\n                                        if (val.clusterId == event.clusterId() && val.maxInterval > 0 &&\n                                            updateType == NodeValue::UpdateByZclReport)\n                                        {\n                                            // prevent setting presence back to false, when report.maxInterval > config.duration\n                                            i->durationDue = item->lastSet().addSecs(val.maxInterval);\n                                        }\n                                        else\n                                        {\n                                            ResourceItem *item2 = i->item(RConfigDuration);\n                                            if (item2 && item2->toNumber() > 0)\n                                            {\n                                                i->durationDue = item->lastSet().addSecs(item2->toNumber());\n                                            }\n                                        }\n                                    }\n                                }\n                                updateSensorEtag(&*i);\n\n                            }\n                        }\n                    }\n                    else if (event.clusterId() == DOOR_LOCK_CLUSTER_ID) {\n                        bool updated = false;\n                        for (;ia != enda; ++ia)\n                        {\n                            if (std::find(event.attributeIds().begin(),\n                                          event.attributeIds().end(),\n                                          ia->id()) == event.attributeIds().end())\n                            {\n                                continue;\n                            }\n\n                            if (i->modelId().startsWith(QLatin1String(\"lumi.vibration\")) && i->type() == QLatin1String(\"ZHAVibration\"))\n                            {\n                                if (ia->id() == 0x0055) // u16: event type\n                                {\n                                    if (updateType != NodeValue::UpdateInvalid)\n                                    {\n                                        i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                        pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                    }\n                                    const quint16 value = ia->numericValue().u16;\n                                    DBG_Printf(DBG_INFO, \"0x%016llX: 0x0101/0x0055: event: %d\\n\", event.node()->address().ext(), value);\n\n                                    if (value == 0x0001) // vibration\n                                    {\n                                        ResourceItem *item = i->item(RStateVibration);\n                                        if (item)\n                                        {\n                                            item->setValue(true);\n                                            enqueueEvent(Event(RSensors, RStateVibration, i->id(), item));\n                                            i->durationDue = item->lastSet().addSecs(65);\n                                            updated = true;\n                                        }\n                                    }\n                                    else if (value == 0x002) // tilted\n                                    {\n                                        // tiltangle is set through 0x0503 attribute\n                                    }\n                                    else if (value == 0x003) // dropped\n                                    {\n                                        ResourceItem *item = i->item(RStateTiltAngle);\n                                        if (item)\n                                        {\n                                            item->setValue(360);\n                                            enqueueEvent(Event(RSensors, RStateTiltAngle, i->id(), item));\n                                            updated = true;\n                                        }\n                                    }\n                                }\n                                else if (ia->id() == 0x0503) // u16: tilt angle\n                                {\n                                    if (updateType != NodeValue::UpdateInvalid)\n                                    {\n                                        i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                        pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                    }\n                                    const quint16 value = ia->numericValue().u16;\n                                    DBG_Printf(DBG_INFO, \"0x%016llX: 0x0101/0x0503: tilt angle: %d°\\n\", event.node()->address().ext(), value);\n                                    ResourceItem *item = i->item(RStateTiltAngle);\n                                    if (item)\n                                    {\n                                        item->setValue(value);\n                                        enqueueEvent(Event(RSensors, RStateTiltAngle, i->id(), item));\n                                        updated = true;\n                                    }\n                                }\n                                else if (ia->id() == 0x0505) // u32: vibration strength\n                                {\n                                    if (updateType != NodeValue::UpdateInvalid)\n                                    {\n                                        i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                        pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                    }\n\n                                    const quint32 value = ia->numericValue().u32;\n                                    const quint16 strength = (value >> 16) & 0xffff;\n                                    DBG_Printf(DBG_INFO, \"0x%016llX: 0x0101/0x0505: vibration strength: %d\\n\", event.node()->address().ext(), strength);\n                                    ResourceItem *item = i->item(RStateVibrationStrength);\n                                    if (item)\n                                    {\n                                        item->setValue(strength);\n                                        enqueueEvent(Event(RSensors, RStateVibrationStrength, i->id(), item));\n                                        updated = true;\n                                    }\n                                }\n                                else if (ia->id() == 0x0508) // u48: orientation\n                                {\n                                    if (updateType != NodeValue::UpdateInvalid)\n                                    {\n                                        i->setZclValue(updateType, event.endpoint(), event.clusterId(), ia->id(), ia->numericValue());\n                                        pushZclValueDb(event.node()->address().ext(), event.endpoint(), event.clusterId(), ia->id(), ia->numericValue().u16);\n                                    }\n                                    const quint64 value = ia->numericValue().u64;\n                                    const qint16 x = value & 0xffff;\n                                    const qint16 y = (value >> 16) & 0xffff;\n                                    const qint16 z = (value >> 32) & 0xffff;\n                                    DBG_Printf(DBG_INFO, \"0x%016llX: 0x0101/0x0508: raw orientation: 0x%012llx (%d, %d, %d)\\n\", event.node()->address().ext(), value, x, y, z);\n                                    const qreal X = 0.0 + x;\n                                    const qreal Y = 0.0 + y;\n                                    const qreal Z = 0.0 + z;\n                                    const qint16 angleX = round(qAtan(X / qSqrt(Z * Z + Y * Y)) * 180 / M_PI);\n                                    const qint16 angleY = round(qAtan(Y / qSqrt(X * X + Z * Z)) * 180 / M_PI);\n                                    const qint16 angleZ = round(qAtan(Z / qSqrt(X * X + Y * Y)) * 180 / M_PI);\n                                    DBG_Printf(DBG_INFO, \"0x%016llX: 0x0101/0x0508: orientation: (%d°, %d°, %d°)\\n\", event.node()->address().ext(), angleX, angleY, angleZ);\n                                    ResourceItem *item = i->item(RStateOrientationX);\n                                    if (item)\n                                    {\n                                        item->setValue(angleX);\n                                        enqueueEvent(Event(RSensors, RStateOrientationX, i->id(), item));\n                                        updated = true;\n                                    }\n                                    item = i->item(RStateOrientationY);\n                                    if (item)\n                                    {\n                                        item->setValue(angleY);\n                                        enqueueEvent(Event(RSensors, RStateOrientationY, i->id(), item));\n                                        updated = true;\n                                    }\n                                    item = i->item(RStateOrientationZ);\n                                    if (item)\n                                    {\n                                        item->setValue(angleZ);\n                                        enqueueEvent(Event(RSensors, RStateOrientationZ, i->id(), item));\n                                        updated = true;\n                                    }\n                                }\n                            }\n                            else if (i->type() == QLatin1String(\"ZHADoorLock\")) // Door lock\n                            {\n                                if (ia->id() == 0x0000) // Lock state\n                                {\n                                    QString str;\n                                    bool dlLock;\n\n                                    if (ia->numericValue().u8 == 1)\n                                    {\n                                        str = QLatin1String(\"locked\");\n                                        dlLock = true;\n                                    }\n                                    else if (ia->numericValue().u8 == 0)\n                                    {\n                                        str = QLatin1String(\"not fully locked\");\n                                        dlLock = false;\n                                    }\n                                    else if (ia->numericValue().u8 == 2)\n                                    {\n                                        str = QLatin1String(\"unlocked\");\n                                        dlLock = false;\n                                    }\n                                    else\n                                    {\n                                        str = QLatin1String(\"undefined\");\n                                        dlLock = false;\n                                    }\n\n                                    // Update RConfigLock bool state\n                                    ResourceItem *item = i->item(RConfigLock);\n                                    if (item && item->toNumber() != dlLock)\n                                    {\n                                        item->setValue(dlLock);\n                                        enqueueEvent(Event(RSensors, RConfigLock, i->id(), item));\n                                        updated = true;\n                                    }\n\n                                    // Update RStateLockState Str value\n                                    item = i->item(RStateLockState);\n                                    if (item && item->toString() != str)\n                                    {\n                                        //DBG_Printf(DBG_INFO, \"0x%016llX onOff %u --> %u\\n\", lightNode->address().ext(), (uint)item->toNumber(), on);\n\n                                        item->setValue(str);\n                                        enqueueEvent(Event(RSensors, RStateLockState, i->id(), item));\n                                        updated = true;\n                                    }\n                                }\n                            }\n                        }\n                        if (updated)\n                        {\n                            i->updateStateTimestamp();\n                            i->setNeedSaveDatabase(true);\n                            enqueueEvent(Event(RSensors, RStateLastUpdated, i->id()));\n                            updateSensorEtag(&*i);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (i->needSaveDatabase())\n        {\n            saveDatabaseItems |= DB_SENSORS;\n        }\n    }\n}\n\n/*! Returns true if the device is supported.\n */\nbool DeRestPluginPrivate::isDeviceSupported(const deCONZ::Node *node, const QString &modelId)\n{\n    if (!node || modelId.isEmpty())\n    {\n        return false;\n    }\n\n    const SupportedDevice *s = supportedDevices;\n    while (s->modelId)\n    {\n        if ((!node->nodeDescriptor().isNull() && node->nodeDescriptor().manufacturerCode() == s->vendorId) ||\n            ((node->address().ext() & macPrefixMask) == s->mac) || existDevicesWithVendorCodeForMacPrefix(node->address(), s->vendorId))\n        {\n            if (modelId.startsWith(QLatin1String(s->modelId)))\n            {\n                return true;\n            }\n        }\n        s++;\n    }\n\n    return false;\n}\n\n/*! Returns the first Sensor for its given \\p id or 0 if not found.\n    \\note There might be more sensors with the same extAddr.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForAddress(quint64 extAddr)\n{\n    std::vector<Sensor>::iterator i = sensors.begin();\n    std::vector<Sensor>::iterator end = sensors.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address().ext() == extAddr && i->deletedState() != Sensor::StateDeleted)\n        {\n            return &(*i);\n        }\n    }\n\n    end = sensors.end();\n\n    for (i = sensors.begin(); i != end; ++i)\n    {\n        if (i->address().ext() == extAddr)\n        {\n            return &(*i);\n        }\n    }\n\n    return 0;\n\n}\n\n/*! Returns the first Sensor for its given \\p addr or 0 if not found.\n    \\note There might be more sensors with the same address.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForAddress(const deCONZ::Address &addr)\n{\n    for (Sensor &sensor: sensors)\n    {\n        if (sensor.deletedState() != Sensor::StateNormal)                   { continue; }\n        if (!isSameAddress(sensor.address(), addr))                         { continue; }\n\n        return &sensor;\n    }\n    return nullptr;\n}\n\n/*! Returns the first Sensor for its given \\p Address and \\p Endpoint and \\p Type or 0 if not found.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForAddressAndEndpoint(const deCONZ::Address &addr, quint8 ep, const QString &type)\n{\n    for (Sensor &sensor: sensors)\n    {\n        if (sensor.deletedState() != Sensor::StateNormal || !sensor.node()) { continue; }\n        if (sensor.fingerPrint().endpoint != ep)                            { continue; }\n        if (sensor.type() != type)                                          { continue; }\n        if (!isSameAddress(sensor.address(), addr))                         { continue; }\n\n        return &sensor;\n    }\n    return nullptr;\n}\n\n\n/*! Returns the first Sensor for its given \\p Address and \\p Endpoint or 0 if not found.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForAddressAndEndpoint(const deCONZ::Address &addr, quint8 ep)\n{\n    for (Sensor &sensor: sensors)\n    {\n        if (sensor.deletedState() != Sensor::StateNormal || !sensor.node()) { continue; }\n        if (sensor.fingerPrint().endpoint != ep)                            { continue; }\n        if (!isSameAddress(sensor.address(), addr))                         { continue; }\n\n        return &sensor;\n    }\n    return nullptr;\n}\n\n/*! Returns the first Sensor for its given \\p Address and \\p Endpoint and \\p Cluster or nullptr if not found.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForAddressEndpointAndCluster(const deCONZ::Address &addr, quint8 ep, quint16 cluster)\n{\n    for (Sensor &sensor: sensors)\n    {\n        if (sensor.deletedState() != Sensor::StateNormal || !sensor.node())                             { continue; }\n        if (sensor.fingerPrint().endpoint != ep)                                                        { continue; }\n        if (!isSameAddress(sensor.address(), addr))                                                     { continue; }\n        if (sensor.fingerPrint().hasInCluster(cluster) || sensor.fingerPrint().hasOutCluster(cluster))  { }\n        else                                                                                            { continue; }\n\n        return &sensor;\n    }\n    return nullptr;\n}\n\n/*! Returns the first Sensor which matches a fingerprint.\n    \\note There might be more sensors with the same fingerprint.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForFingerPrint(quint64 extAddr, const SensorFingerprint &fingerPrint, const QString &type)\n{\n    std::vector<Sensor>::iterator i = sensors.begin();\n    std::vector<Sensor>::iterator end = sensors.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address().ext() == extAddr && i->deletedState() != Sensor::StateDeleted)\n        {\n            if (i->type() == type && i->fingerPrint().endpoint == fingerPrint.endpoint)\n            {\n                if (!(i->fingerPrint() == fingerPrint))\n                {\n                    DBG_Printf(DBG_INFO, \"updated fingerprint for sensor %s\\n\", qPrintable(i->name()));\n                    i->fingerPrint() = fingerPrint;\n                    i->setNeedSaveDatabase(true);\n                    updateEtag(i->etag);\n                    queSaveDb(DB_SENSORS , DB_SHORT_SAVE_DELAY);\n                }\n                return &(*i);\n            }\n        }\n    }\n\n    end = sensors.end();\n\n    for (i = sensors.begin(); i != end; ++i)\n    {\n        if (i->address().ext() == extAddr)\n        {\n            if (i->type() == type && i->fingerPrint().endpoint == fingerPrint.endpoint)\n            {\n                if (!(i->fingerPrint() == fingerPrint))\n                {\n                    DBG_Printf(DBG_INFO, \"updated fingerprint for sensor %s\\n\", qPrintable(i->name()));\n                    i->fingerPrint() = fingerPrint;\n                    i->setNeedSaveDatabase(true);\n                    updateEtag(i->etag);\n                    queSaveDb(DB_SENSORS , DB_SHORT_SAVE_DELAY);\n                }\n                return &(*i);\n            }\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns a Sensor for its given \\p unique id or 0 if not found.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForUniqueId(const QString &uniqueId)\n{\n    if (uniqueId.isEmpty())\n    {\n        return nullptr;\n    }\n\n    for (Sensor &s : sensors)\n    {\n        if (s.deletedState() == Sensor::StateNormal && s.uniqueId() == uniqueId)\n        {\n            return &s;\n        }\n    }\n\n    return nullptr;\n}\n\n/*! Returns a Sensor for its given \\p id or 0 if not found.\n */\nSensor *DeRestPluginPrivate::getSensorNodeForId(const QString &id)\n{\n    for (Sensor &s : sensors)\n    {\n        if (s.deletedState() == Sensor::StateNormal && s.id() == id)\n        {\n            return &s;\n        }\n    }\n\n    return nullptr;\n}\n\n/*! Returns a Group for a given group id or 0 if not found.\n */\nGroup *DeRestPluginPrivate::getGroupForId(uint16_t id)\n{\n    uint16_t gid = id ? id : gwGroup0;\n\n    std::vector<Group>::iterator i = groups.begin();\n    std::vector<Group>::iterator end = groups.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address() == gid)\n        {\n            return &(*i);\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns a Scene for a given group id and Scene id or 0 if not found.\n */\nScene *DeRestPluginPrivate::getSceneForId(uint16_t gid, uint8_t sid)\n{\n    Group *group = getGroupForId(gid);\n\n    if (group)\n    {\n        std::vector<Scene>::iterator i = group->scenes.begin();\n        std::vector<Scene>::iterator end = group->scenes.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == sid)\n            {\n                return &(*i);\n            }\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns a Group for a given group name or 0 if not found.\n */\nGroup *DeRestPluginPrivate::getGroupForName(const QString &name)\n{\n    DBG_Assert(name.isEmpty() == false);\n    if (name.isEmpty())\n    {\n        return 0;\n    }\n\n    std::vector<Group>::iterator i = groups.begin();\n    std::vector<Group>::iterator end = groups.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->name() == name)\n        {\n            return &(*i);\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns a Group for a given group id or 0 if not found.\n */\nGroup *DeRestPluginPrivate::getGroupForId(const QString &id)\n{\n    if (id.isEmpty() || !id.at(0).isDigit())\n    {\n        return nullptr;\n    }\n\n    // check valid 16-bit group id 0..0xFFFF\n    bool ok;\n    uint gid = id.toUInt(&ok, 10);\n    if (!ok || (gid > 0xFFFFUL))\n    {\n        DBG_Printf(DBG_INFO, \"Get group for id error: invalid group id %s\\n\", qPrintable(id));\n        return nullptr;\n    }\n    if (gid == 0)\n    {\n        gid = gwGroup0;\n    }\n\n    for (auto &group : groups)\n    {\n        if (group.address() == gid)\n        {\n            return &group;\n        }\n    }\n\n    return nullptr;\n}\n\n/*! Delete a group of a switch from database permanently.\n */\nbool DeRestPluginPrivate::deleteOldGroupOfSwitch(Sensor *sensor, quint16 newGroupId)\n{\n    DBG_Assert(sensor && !sensor->id().isEmpty());\n    if (!sensor || sensor->id().isEmpty())\n    {\n        return false;\n    }\n\n    std::vector<Group>::iterator i = groups.begin();\n    std::vector<Group>::iterator end = groups.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address() == newGroupId)\n        {\n            continue;\n        }\n\n        if (i->state() != Group::StateNormal)\n        {\n            continue;\n        }\n\n        if (i->m_deviceMemberships.end() != std::find(i->m_deviceMemberships.begin(),\n                                                      i->m_deviceMemberships.end(),\n                                                      sensor->id()))\n        {\n            DBG_Printf(DBG_INFO, \"delete old switch group 0x%04X of sensor %s\\n\", i->address(), qPrintable(sensor->name()));\n            //found\n            i->setState(Group::StateDeleted);\n        }\n    }\n    return true;\n}\n\n\n/*! Returns GroupInfo in a LightNode for a given group id or 0 if not found.\n */\nGroupInfo *DeRestPluginPrivate::getGroupInfo(LightNode *lightNode, uint16_t id)\n{\n    DBG_Assert(lightNode != 0);\n\n    if (lightNode)\n    {\n        std::vector<GroupInfo>::iterator i = lightNode->groups().begin();\n        std::vector<GroupInfo>::iterator end = lightNode->groups().end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == id)\n            {\n                return &(*i);\n            }\n        }\n    }\n\n    return 0;\n}\n\nGroupInfo *DeRestPluginPrivate::createGroupInfo(LightNode *lightNode, uint16_t id)\n{\n    DBG_Assert(lightNode != 0);\n\n    // dont create a duplicate\n    GroupInfo *g = getGroupInfo(lightNode, id);\n    if (g)\n    {\n        return g;\n    }\n\n    // not found .. create\n    GroupInfo groupInfo;\n    groupInfo.id = id;\n    lightNode->groups().push_back(groupInfo);\n\n    return &lightNode->groups().back();\n}\n\n/*! Returns a deCONZ::Node for a given MAC address or 0 if not found.\n */\ndeCONZ::Node *DeRestPluginPrivate::getNodeForAddress(uint64_t extAddr)\n{\n    int i = 0;\n    const deCONZ::Node *node;\n\n    DBG_Assert(apsCtrl != nullptr);\n\n    if (apsCtrl == nullptr)\n    {\n        return 0;\n    }\n\n    while (apsCtrl->getNode(i, &node) == 0)\n    {\n        if (node->address().ext() == extAddr)\n        {\n            return const_cast<deCONZ::Node*>(node); // FIXME: use const\n        }\n        i++;\n    }\n\n    return 0;\n}\n\n/*! Returns the cluster descriptor for given cluster id.\n    \\return the cluster or 0 if not found\n */\ndeCONZ::ZclCluster *DeRestPluginPrivate::getInCluster(deCONZ::Node *node, uint8_t endpoint, uint16_t clusterId)\n{\n    if (DBG_Assert(node != 0) == false)\n    {\n        return 0;\n    }\n\n    deCONZ::SimpleDescriptor *sd = node->getSimpleDescriptor(endpoint);\n\n    if (sd)\n    {\n        auto i = sd->inClusters().begin();\n        auto end = sd->inClusters().end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id() == clusterId)\n            {\n                return &(*i);\n            }\n        }\n    }\n\n    return 0;\n}\n\n/*! Get proper src endpoint for outgoing requests.\n    \\param req - the profileId() must be specified in the request.\n    \\return a endpoint number\n */\nuint8_t DeRestPluginPrivate::getSrcEndpoint(RestNodeBase *restNode, const deCONZ::ApsDataRequest &req)\n{\n    Q_UNUSED(restNode);\n    if (req.profileId() == HA_PROFILE_ID || req.profileId() == ZLL_PROFILE_ID)\n    {\n        return endpoint();\n    }\n    return 0x01;\n}\n\n/*! Check and process queued attributes marked for read.\n    \\return true - if at least one attribute was processed\n */\nbool DeRestPluginPrivate::processZclAttributes(LightNode *lightNode)\n{\n    DBG_Assert(lightNode != 0);\n\n    if (!lightNode)\n    {\n        return false;\n    }\n\n    if (!lightNode->isAvailable() || !lightNode->lastRx().isValid())\n    {\n        return false;\n    }\n\n    DBG_Assert(apsCtrl != nullptr);\n    if (apsCtrl && apsCtrl->getParameter(deCONZ::ParamAutoPollingActive) == 0)\n    {\n        return false;\n    }\n\n    int processed = 0;\n\n    QTime tNow = QTime::currentTime();\n\n    const Device *device = static_cast<Device*>(lightNode->parentResource());\n    const bool devManaged = device && device->managed();\n\n    if (!devManaged)\n    {\n        if (lightNode->mustRead(READ_BINDING_TABLE) && tNow > lightNode->nextReadTime(READ_BINDING_TABLE))\n        {\n            if (readBindingTable(lightNode, 0))\n            {\n                lightNode->clearRead(READ_BINDING_TABLE);\n                processed++;\n            }\n        }\n\n        if (lightNode->mustRead(READ_VENDOR_NAME) && tNow > lightNode->nextReadTime(READ_VENDOR_NAME))\n        {\n            if (!lightNode->manufacturer().isEmpty())\n            {\n                lightNode->clearRead(READ_VENDOR_NAME);\n                processed++;\n            }\n            else\n            {\n                std::vector<uint16_t> attributes;\n                attributes.push_back(0x0004); // Manufacturer name\n\n                if (readAttributes(lightNode, lightNode->haEndpoint().endpoint(), BASIC_CLUSTER_ID, attributes))\n                {\n                    lightNode->clearRead(READ_VENDOR_NAME);\n                    processed++;\n                }\n            }\n        }\n\n        if ((processed < 2) && lightNode->mustRead(READ_MODEL_ID) && tNow > lightNode->nextReadTime(READ_MODEL_ID))\n        {\n            if (!lightNode->modelId().isEmpty())\n            {\n                lightNode->clearRead(READ_MODEL_ID);\n                processed++;\n            }\n            else\n            {\n                std::vector<uint16_t> attributes;\n                attributes.push_back(0x0005); // Model identifier\n\n                if (readAttributes(lightNode, lightNode->haEndpoint().endpoint(), BASIC_CLUSTER_ID, attributes))\n                {\n                    lightNode->clearRead(READ_MODEL_ID);\n                    processed++;\n                }\n            }\n        }\n    }\n\n    if ((processed < 2) && lightNode->mustRead(READ_GROUPS) && tNow > lightNode->nextReadTime(READ_GROUPS))\n    {\n        std::vector<uint16_t> groups; // empty meaning read all groups\n        if (readGroupMembership(lightNode, groups))\n        {\n            lightNode->clearRead(READ_GROUPS);\n            processed++;\n        }\n    }\n\n    return (processed > 0);\n}\n\n/*! Check and process queued attributes marked for read and write.\n    \\return true - if at least one attribute was processed\n */\nbool DeRestPluginPrivate::processZclAttributes(Sensor *sensorNode)\n{\n    int processed = 0;\n\n    DBG_Assert(sensorNode != 0);\n\n    if (!sensorNode)\n    {\n        return false;\n    }\n\n    if (!sensorNode->isAvailable())\n    {\n        return false;\n    }\n\n    if (!sensorNode->type().startsWith('Z')) // CLIP & Daylight sensors\n    {\n        return false;\n    }\n\n    if (!sensorNode->node())\n    {\n        if (sensorNode->type().startsWith(QLatin1String(\"ZGP\"))) // ZGP nothing to be done here\n        {\n            return false;\n        }\n\n        deCONZ::Node *node = getNodeForAddress(sensorNode->address().ext());\n        if (node)\n        {\n            sensorNode->setNode(node);\n            sensorNode->fingerPrint().checkCounter = SENSOR_CHECK_COUNTER_INIT; // force check\n        }\n    }\n\n    if (!sensorNode->node())\n    {\n        return false;\n    }\n\n    const deCONZ::NodeDescriptor &nd = sensorNode->node()->nodeDescriptor();\n\n    if (nd.isNull())\n    {\n        return false;\n    }\n\n    if (!nd.receiverOnWhenIdle() && (nd.manufacturerCode() == VENDOR_XIAOMI || sensorNode->modelId().startsWith(QLatin1String(\"lumi.\"))))\n    {\n        if (sensorNode->modelId() == QLatin1String(\"lumi.motion.agl04\"))\n        {\n            // Continue to process\n        }\n        else\n        {\n            return false; // don't talk to sleeping Xiaomi devices here\n        }\n    }\n\n    if (sensorNode->node()->simpleDescriptors().empty())\n    {\n        return false;\n    }\n\n    QTime tNow = QTime::currentTime();\n\n    const Device *device = static_cast<Device*>(sensorNode->parentResource());\n    const bool devManaged = device && device->managed();\n\n    if (!devManaged)\n    {\n        if (sensorNode->mustRead(READ_BINDING_TABLE) && tNow > sensorNode->nextReadTime(READ_BINDING_TABLE))\n        {\n            bool ok = false;\n            // only read binding table of chosen sensors\n            // whitelist by Model ID\n            if (sensorNode->manufacturer().startsWith(QLatin1String(\"BEGA\")))\n            {\n                ok = true;\n            }\n\n            if (!ok)\n            {\n                sensorNode->clearRead(READ_BINDING_TABLE);\n            }\n\n            if (ok && readBindingTable(sensorNode, 0))\n            {\n                // only read binding table once per node even if multiple devices/sensors are implemented\n                std::vector<Sensor>::iterator i = sensors.begin();\n                std::vector<Sensor>::iterator end = sensors.end();\n\n                for (; i != end; ++i)\n                {\n                    if (i->address().ext() == sensorNode->address().ext())\n                    {\n                        i->clearRead(READ_BINDING_TABLE);\n                    }\n                }\n                processed++;\n            }\n        }\n\n        if (sensorNode->mustRead(READ_VENDOR_NAME) && tNow > sensorNode->nextReadTime(READ_VENDOR_NAME))\n        {\n            std::vector<uint16_t> attributes;\n            attributes.push_back(0x0004); // Manufacturer name\n\n            if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, BASIC_CLUSTER_ID, attributes))\n            {\n                sensorNode->clearRead(READ_VENDOR_NAME);\n                processed++;\n            }\n        }\n\n        if (sensorNode->mustRead(READ_MODEL_ID) && tNow > sensorNode->nextReadTime(READ_MODEL_ID))\n        {\n            std::vector<uint16_t> attributes;\n            attributes.push_back(0x0005); // Model identifier\n\n            if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, BASIC_CLUSTER_ID, attributes))\n            {\n                sensorNode->clearRead(READ_MODEL_ID);\n                processed++;\n            }\n        }\n\n        if (sensorNode->mustRead(READ_SWBUILD_ID) && tNow > sensorNode->nextReadTime(READ_SWBUILD_ID))\n        {\n            std::vector<uint16_t> attributes;\n            attributes.push_back(0x4000); // Software build identifier\n\n            if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, BASIC_CLUSTER_ID, attributes))\n            {\n                sensorNode->clearRead(READ_SWBUILD_ID);\n                processed++;\n            }\n        }\n\n        if (sensorNode->mustRead(READ_OCCUPANCY_CONFIG) && tNow > sensorNode->nextReadTime(READ_OCCUPANCY_CONFIG))\n        {\n            if (sensorNode->modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\n            {\n                sensorNode->clearRead(READ_OCCUPANCY_CONFIG);\n            }\n            else\n            {\n                std::vector<uint16_t> attributes;\n                attributes.push_back(0x0010); // occupied to unoccupied delay\n\n                if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, OCCUPANCY_SENSING_CLUSTER_ID, attributes))\n                {\n                    sensorNode->clearRead(READ_OCCUPANCY_CONFIG);\n                    processed++;\n                }\n            }\n        }\n\n        if (sensorNode->mustRead(WRITE_OCCUPANCY_CONFIG) && tNow > sensorNode->nextReadTime(READ_OCCUPANCY_CONFIG))\n        {\n            // only valid bounds\n            int duration = sensorNode->item(RConfigDuration)->toNumber();\n\n            if (duration >= 0 && duration <= 65535)\n            {\n                // occupied to unoccupied delay\n                deCONZ::ZclAttribute attr(0x0010, deCONZ::Zcl16BitUint, \"occ\", deCONZ::ZclReadWrite, true);\n                attr.setValue((quint64)duration);\n\n                if (writeAttribute(sensorNode, sensorNode->fingerPrint().endpoint, OCCUPANCY_SENSING_CLUSTER_ID, attr))\n                {\n                    sensorNode->clearRead(WRITE_OCCUPANCY_CONFIG);\n                    processed++;\n                }\n            }\n            else\n            {\n                sensorNode->clearRead(WRITE_OCCUPANCY_CONFIG);\n            }\n        }\n\n        if (sensorNode->mustRead(WRITE_DELAY) && tNow > sensorNode->nextReadTime(WRITE_DELAY))\n        {\n            ResourceItem *item = sensorNode->item(RConfigDelay);\n\n            DBG_Printf(DBG_INFO_L2, \"handle pending delay for 0x%016llX\\n\", sensorNode->address().ext());\n            if (item)\n            {\n                quint64 delay = item->toNumber();\n                // occupied to unoccupied delay\n                deCONZ::ZclAttribute attr(0x0010, deCONZ::Zcl16BitUint, \"occ\", deCONZ::ZclReadWrite, true);\n                attr.setValue(delay);\n\n                if (writeAttribute(sensorNode, sensorNode->fingerPrint().endpoint, OCCUPANCY_SENSING_CLUSTER_ID, attr))\n                {\n                    // FIXME: The Write Attributes command will not reach deep sleepers.\n                    //        Unfortuneately, Occupied to Unoccupied Delay is not reportable.\n                    //        Fortunately, the Hue motion sensor is a light sleeper.\n                    ResourceItem *item = sensorNode->item(RConfigPending);\n                    quint16 mask = item->toNumber();\n                    mask &= ~R_PENDING_DELAY;\n                    item->setValue(mask);\n                    sensorNode->clearRead(WRITE_DELAY);\n                    processed++;\n                }\n            }\n            else\n            {\n                sensorNode->clearRead(WRITE_DELAY);\n            }\n        }\n\n        if (sensorNode->mustRead(WRITE_SENSITIVITY) && tNow > sensorNode->nextReadTime(WRITE_SENSITIVITY))\n        {\n            ResourceItem *item = sensorNode->item(RConfigSensitivity);\n\n            DBG_Printf(DBG_INFO_L2, \"handle pending sensitivity for 0x%016llX\\n\", sensorNode->address().ext());\n            if (item)\n            {\n                quint64 sensitivity = item->toNumber();\n\n                if (nd.manufacturerCode() == VENDOR_PHILIPS)\n                {\n                    deCONZ::ZclAttribute attr(0x0030, deCONZ::Zcl8BitUint, \"sensitivity\", deCONZ::ZclReadWrite, true);\n                    attr.setValue(sensitivity);\n\n                    if (writeAttribute(sensorNode, sensorNode->fingerPrint().endpoint, OCCUPANCY_SENSING_CLUSTER_ID, attr, VENDOR_PHILIPS))\n                    {\n                        sensorNode->setNextReadTime(WRITE_SENSITIVITY, tNow.addSecs(7200));\n                        processed++;\n                    }\n                }\n                else if (nd.manufacturerCode() == VENDOR_XIAOMI)\n                {\n                    deCONZ::ZclAttribute attr(XIAOMI_ATTRID_MOTION_SENSITIVITY, deCONZ::Zcl8BitUint, \"sensitivity\", deCONZ::ZclReadWrite, true);\n                    attr.setValue(sensitivity);\n\n                    if (writeAttribute(sensorNode, sensorNode->fingerPrint().endpoint, XIAOMI_CLUSTER_ID, attr, VENDOR_XIAOMI))\n                    {\n                        sensorNode->setNextReadTime(WRITE_SENSITIVITY, tNow.addSecs(3300)); // Default special reporting intervall\n                        processed++;\n                    }\n                }\n            }\n            else\n            {\n                sensorNode->clearRead(WRITE_SENSITIVITY);\n            }\n        }\n    }\n\n    // TODO(mpi): is following code already handled by DDF, so we can skip if devManaged?\n\n\n    if (sensorNode->mustRead(READ_THERMOSTAT_STATE) && tNow > sensorNode->nextReadTime(READ_THERMOSTAT_STATE))\n    {\n        std::vector<uint16_t> attributes;\n\n        if (sensorNode->modelId() == QLatin1String(\"Thermostat\")) // eCozy\n        {\n            // attributes.push_back(0x0000); // Local Temperature - reported\n            // attributes.push_back(0x0008); // PI Heating Demand - reported\n            attributes.push_back(0x0010); // Local Temperature Calibration\n            attributes.push_back(0x0012); // Occupied Heating Setpoint\n            attributes.push_back(0x0023); // Temperature Setpoint Hold\n            attributes.push_back(0x0030); // Setpoint Change Source\n            attributes.push_back(0x0031); // Setpoint Change Amount\n            attributes.push_back(0x0032); // Setpoint Change Timestamp\n        }\n        else\n        {\n            // TODO use poll manager, only poll when needed\n            attributes.push_back(0x0000); // temperature\n            attributes.push_back(0x0012); // heating setpoint\n            attributes.push_back(0x0025); // scheduler state\n            attributes.push_back(0x0029); // heating operation state\n        }\n\n        if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, THERMOSTAT_CLUSTER_ID, attributes))\n        {\n            sensorNode->clearRead(READ_THERMOSTAT_STATE);\n            processed++;\n        }\n    }\n\n    if (sensorNode->mustRead(READ_THERMOSTAT_SCHEDULE) && tNow > sensorNode->nextReadTime(READ_THERMOSTAT_SCHEDULE))\n    {\n        TaskItem task;\n\n        // set destination parameters\n        task.req.dstAddress() = sensorNode->address();\n        task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n        task.req.setDstEndpoint(sensorNode->fingerPrint().endpoint);\n        task.req.setSrcEndpoint(getSrcEndpoint(sensorNode, task.req));\n        task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n\n        if (addTaskThermostatGetSchedule(task))\n        {\n            sensorNode->clearRead(READ_THERMOSTAT_SCHEDULE);\n            processed++;\n        }\n    }\n\n    if (!devManaged && sensorNode->mustRead(READ_BATTERY) && tNow > sensorNode->nextReadTime(READ_BATTERY))\n    {\n        std::vector<uint16_t> attributes;\n        attributes.push_back(0x0020); // battery level\n        if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, POWER_CONFIGURATION_CLUSTER_ID, attributes))\n        {\n            sensorNode->clearRead(READ_BATTERY);\n            processed++;\n        }\n    }\n\n    if (!DEV_TestStrict() && !devManaged)\n    {\n        if (sensorNode->mustRead(READ_TIME) && tNow > sensorNode->nextReadTime(READ_TIME))\n        {\n            DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: exec READ_TIME\\n\", qPrintable(sensorNode->type()), qPrintable(sensorNode->name()));\n            std::vector<uint16_t> attributes;\n            attributes.push_back(0x0000); // Time\n            attributes.push_back(0x0007); // Local Time\n            attributes.push_back(0x0008); // Last Set\n            if (readAttributes(sensorNode, sensorNode->fingerPrint().endpoint, TIME_CLUSTER_ID, attributes))\n            {\n                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: clear READ_TIME\\n\", qPrintable(sensorNode->type()), qPrintable(sensorNode->name()));\n                sensorNode->clearRead(READ_TIME);\n                processed++;\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: READ_TIME failed\\n\", qPrintable(sensorNode->type()), qPrintable(sensorNode->name()));\n            }\n        }\n\n        if (sensorNode->mustRead(WRITE_TIME) && tNow > sensorNode->nextReadTime(WRITE_TIME))\n        {\n            DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: exec WRITE_TIME\\n\", qPrintable(sensorNode->type()), qPrintable(sensorNode->name()));\n            deCONZ::ZclAttribute attr(0x0000, deCONZ::ZclUtcTime, \"time\", deCONZ::ZclReadWrite, true);\n            attr.setValue(QDateTime::currentDateTimeUtc());\n\n            if (addTaskSyncTime(sensorNode))\n            {\n                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: clear WRITE_TIME\\n\", qPrintable(sensorNode->type()), qPrintable(sensorNode->name()));\n                sensorNode->clearRead(WRITE_TIME);\n                processed++;\n            }\n        }\n    }\n\n    return (processed > 0);\n}\n\n/*! Queue reading ZCL attributes of a node.\n    \\param restNode the node from which the attributes shall be read\n    \\param endpoint the destination endpoint\n    \\param clusterId the cluster id related to the attributes\n    \\param attributes a list of attribute ids which shall be read\n    \\param manufacturerCode (optional) manufacturerCode for manufacturer-specific attribute\n    \\return true if the request is queued\n */\nbool DeRestPluginPrivate::readAttributes(RestNodeBase *restNode, quint8 endpoint, uint16_t clusterId, const std::vector<uint16_t> &attributes, uint16_t manufacturerCode)\n{\n    DBG_Assert(restNode != 0);\n    DBG_Assert(!attributes.empty());\n\n    if (!restNode || !restNode->node() || attributes.empty() || !restNode->isAvailable())\n    {\n        return false;\n    }\n\n    if (clusterId == TIME_CLUSTER_ID)\n    {\n        // FIXME: should check for light sleeper instead\n    }\n    else if (!restNode->node()->nodeDescriptor().receiverOnWhenIdle())\n    {\n        QDateTime now = QDateTime::currentDateTime();\n        if (!restNode->lastRx().isValid() || (restNode->lastRx().secsTo(now) > 3))\n        {\n            return false;\n        }\n    }\n\n\n    if (taskCountForAddress(restNode->address()) >= MAX_TASKS_PER_NODE)\n    {\n        return false;\n    }\n\n    if ((runningTasks.size() + tasks.size()) > MAX_BACKGROUND_TASKS)\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskReadAttributes;\n\n//    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(endpoint);\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = restNode->address();\n    task.req.setClusterId(clusterId);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(restNode, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(deCONZ::ZclReadAttributesId);\n\n    if (manufacturerCode)\n    {\n        task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                      deCONZ::ZclFCManufacturerSpecific |\n                                      deCONZ::ZclFCDirectionClientToServer |\n                                      deCONZ::ZclFCDisableDefaultResponse);\n        task.zclFrame.setManufacturerCode(manufacturerCode);\n        DBG_Printf(DBG_INFO_L2, \"read manufacturer specific attributes of 0x%016llX cluster: 0x%04X: [ \", restNode->address().ext(), clusterId);\n    }\n    else\n    {\n        task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                      deCONZ::ZclFCDirectionClientToServer |\n                                      deCONZ::ZclFCDisableDefaultResponse);\n\n        DBG_Printf(DBG_INFO_L2, \"read attributes of 0x%016llX cluster: 0x%04X: [ \", restNode->address().ext(), clusterId);\n    }\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        for (uint i = 0; i < attributes.size(); i++)\n        {\n            stream << attributes[i];\n            DBG_Printf(DBG_INFO_L2, \"0x%04X \", attributes[i]);\n        }\n    }\n    DBG_Printf(DBG_INFO_L2, \"]\\n\");\n\n    // check duplicates\n    for (const TaskItem &t0 : tasks)\n    {\n        if (t0.taskType != task.taskType ||\n            t0.req.dstAddress() != task.req.dstAddress() ||\n            t0.req.clusterId() != task.req.clusterId() ||\n            t0.req.dstEndpoint() != task.req.dstEndpoint() ||\n            t0.zclFrame.commandId() != task.zclFrame.commandId() ||\n            t0.zclFrame.manufacturerCode() != task.zclFrame.manufacturerCode())\n        {\n            continue;\n        }\n\n        if (t0.zclFrame.payload() == task.zclFrame.payload())\n        {\n            DBG_Printf(DBG_INFO, \"discard read attributes of 0x%016llX cluster: 0x%04X (already in queue)\\n\", restNode->address().ext(), clusterId);\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Queue reading Group Identifiers.\n    \\param node the node from which the group identifiers shall be read\n    \\param startIndex the index to start the reading\n    \\return true if the request is queued\n */\nbool DeRestPluginPrivate::getGroupIdentifiers(RestNodeBase *node, quint8 endpoint, quint8 startIndex)\n{\n    DBG_Assert(node != 0);\n\n    if (!node || !node->isAvailable())\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskGetGroupIdentifiers;\n\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(endpoint);\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = node->address();\n    task.req.setClusterId(COMMISSIONING_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID); // utility commands (ref.: zll spec. 7.1.1)\n    task.req.setSrcEndpoint(getSrcEndpoint(node, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x41); // get group identifiers cmd\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << startIndex;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    DBG_Printf(DBG_INFO, \"Send get group identifiers for node 0%04X \\n\", node->address().ext());\n\n    return addTask(task);\n}\n\n/*! Queue writing a ZCL attribute of a node.\n    \\param restNode the node from which the attributes shall be read\n    \\param endpoint the destination endpoint\n    \\param clusterId the cluster id related to the attributes\n    \\param attribute the attribute to write\n    \\param manufacturerCode (optional) manufacturerCode for manufacturer-specific attribute\n    \\return true if the request is queued\n */\nbool DeRestPluginPrivate::writeAttribute(RestNodeBase *restNode, quint8 endpoint, uint16_t clusterId, const deCONZ::ZclAttribute &attribute, uint16_t manufacturerCode)\n{\n    DBG_Assert(restNode != nullptr);\n\n    if (!restNode || !restNode->isAvailable())\n    {\n        return false;\n    }\n\n    if (!restNode->node()->nodeDescriptor().receiverOnWhenIdle())\n    {\n        QDateTime now = QDateTime::currentDateTime();\n        if (!restNode->lastRx().isValid() || (restNode->lastRx().secsTo(now) > 3))\n        {\n            return false;\n        }\n    }\n\n    TaskItem task;\n    task.taskType = TaskWriteAttribute;\n\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(endpoint);\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = restNode->address();\n    task.req.setClusterId(clusterId);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(restNode, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n\n    if (manufacturerCode)\n    {\n        task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                      deCONZ::ZclFCManufacturerSpecific |\n                                      deCONZ::ZclFCDirectionClientToServer |\n                                      deCONZ::ZclFCDisableDefaultResponse);\n        task.zclFrame.setManufacturerCode(manufacturerCode);\n        DBG_Printf(DBG_INFO_L2, \"write manufacturer specific attribute of 0x%016llX ep: 0x%02X cluster: 0x%04X: 0x%04X\\n\", restNode->address().ext(), endpoint, clusterId, attribute.id());\n    }\n    else\n    {\n        task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                      deCONZ::ZclFCDirectionClientToServer |\n                                      deCONZ::ZclFCDisableDefaultResponse);\n\n        DBG_Printf(DBG_INFO, \"write attribute of 0x%016llX ep: 0x%02X cluster: 0x%04X: 0x%04X\\n\", restNode->address().ext(), endpoint, clusterId, attribute.id());\n    }\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << attribute.id();\n        stream << attribute.dataType();\n\n        if (!attribute.writeToStream(stream))\n        {\n            return false;\n        }\n    }\n\n    // check duplicates\n    for (const TaskItem &t0 : tasks)\n    {\n        if (t0.taskType != task.taskType ||\n            t0.req.dstAddress() != task.req.dstAddress() ||\n            t0.req.clusterId() != task.req.clusterId() ||\n            t0.req.dstEndpoint() != task.req.dstEndpoint() ||\n            t0.zclFrame.commandId() != task.zclFrame.commandId() ||\n            t0.zclFrame.manufacturerCode() != task.zclFrame.manufacturerCode())\n        {\n            continue;\n        }\n\n        if (t0.zclFrame.payload() == task.zclFrame.payload())\n        {\n            DBG_Printf(DBG_INFO, \"discard write attribute of 0x%016llX ep: 0x%02X cluster: 0x%04X: 0x%04X (already in queue)\\n\", restNode->address().ext(), endpoint, clusterId, attribute.id());\n            return false;\n        }\n    }\n\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Queue reading details of a scene from a node.\n    \\param restNode the node from which the scene details shall be read\n    \\param groupId the group Id of the scene\n    \\param sceneId the scene Id\n    \\return true if the request is queued\n */\nbool DeRestPluginPrivate::readSceneAttributes(LightNode *lightNode, uint16_t groupId, uint8_t sceneId )\n{\n    DBG_Assert(lightNode != 0);\n\n    if (!lightNode || !lightNode->isAvailable())\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskViewScene;\n    task.lightNode = lightNode;\n\n    task.req.setSendDelay(3000); // delay a bit to let store scene finish\n//    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(lightNode->haEndpoint().endpoint());\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = lightNode->address();\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(lightNode, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x41); // Enhanced view scene\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << groupId;\n        stream << sceneId;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Get group membership of a node.\n    \\param lightNode the node from which the groups shall be discovered\n    \\param groups - 0 or more group ids\n */\nbool DeRestPluginPrivate::readGroupMembership(LightNode *lightNode, const std::vector<uint16_t> &groups)\n{\n    DBG_Assert(lightNode != 0);\n\n    if (!lightNode || !lightNode->isAvailable() || !lightNode->lastRx().isValid())\n    {\n        return false;\n    }\n\n    bool found = false;\n    for (const auto &cl : lightNode->haEndpoint().inClusters())\n    {\n        if (cl.id() == GROUP_CLUSTER_ID)\n        {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) // not all light endpoints have a group cluster (lumi.ctrl_ln2.aq1)\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskGetGroupMembership;\n\n//    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(lightNode->haEndpoint().endpoint());\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = lightNode->address();\n    task.req.setClusterId(GROUP_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(lightNode, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x02); // get group membership\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << (uint8_t)groups.size();\n\n        for (uint i = 0; i < groups.size(); i++)\n        {\n            stream << groups[i];\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Checks if a group membership is already known.\n    If not the group will be added and node gets marked for update.\n */\nvoid DeRestPluginPrivate::foundGroupMembership(LightNode *lightNode, uint16_t groupId)\n{\n    DBG_Assert(lightNode != 0);\n\n    if (!lightNode)\n    {\n        return;\n    }\n\n    Group *group = getGroupForId(groupId);\n\n    // check if the group is known in the node\n    std::vector<GroupInfo>::iterator i = lightNode->groups().begin();\n    std::vector<GroupInfo>::iterator end = lightNode->groups().end();\n\n    for (; i != end; ++i)\n    {\n        if (i->id == groupId)\n        {\n            if (group && group->state() != Group::StateNormal && group->m_deviceMemberships.size() == 0) // don't touch group of switch\n            {\n                i->actions &= ~GroupInfo::ActionAddToGroup; // sanity\n                i->actions |= GroupInfo::ActionRemoveFromGroup;\n                if (i->state != GroupInfo::StateNotInGroup)\n                {\n                    i->state = GroupInfo::StateNotInGroup;\n                    lightNode->setNeedSaveDatabase(true);\n                    queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n                }\n            }\n\n            return; // ok already known\n        }\n    }\n\n    updateLightEtag(lightNode);\n\n    GroupInfo groupInfo;\n    groupInfo.id = groupId;\n\n    if (group)\n    {\n        updateGroupEtag(group);\n\n        if (group->state() != Group::StateNormal && group->m_deviceMemberships.size() == 0) // don't touch group of switch\n        {\n            groupInfo.actions &= ~GroupInfo::ActionAddToGroup; // sanity\n            groupInfo.actions |= GroupInfo::ActionRemoveFromGroup;\n            groupInfo.state = GroupInfo::StateNotInGroup;\n        }\n        else\n        {\n            lightNode->enableRead(READ_SCENES); // force reading of scene membership\n        }\n    }\n\n    queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n    lightNode->setNeedSaveDatabase(true);\n    lightNode->groups().push_back(groupInfo);\n}\n\n/*! Checks if the group is known in the global cache.\n    If not it will be added.\n */\nvoid DeRestPluginPrivate::foundGroup(uint16_t groupId)\n{\n    // check if group is known global\n    std::vector<Group>::iterator i = groups.begin();\n    std::vector<Group>::iterator end = groups.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->address() == groupId)\n        {\n            return; // ok already known\n        }\n    }\n\n    Group group;\n    group.setAddress(groupId);\n    group.colorX = 0;\n    group.colorY = 0;\n    group.setIsOn(false);\n    group.level = 128;\n    group.hue = 0;\n    group.hueReal = 0.0f;\n    group.sat = 128;\n    group.setName(QString());\n    updateEtag(group.etag);\n    openDb();\n    loadGroupFromDb(&group);\n    closeDb();\n    if (group.name().isEmpty()) {\n        group.setName(QString(\"Group %1\").arg(group.id()));\n        queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\n    }\n    groups.push_back(group);\n    updateEtag(gwConfigEtag);\n}\n\n/*! Returns true if the \\p lightNode is member of the group with the \\p groupId.\n */\nbool DeRestPluginPrivate::isLightNodeInGroup(const LightNode *lightNode, uint16_t groupId) const\n{\n    DBG_Assert(lightNode != 0);\n\n    if (lightNode)\n    {\n        std::vector<GroupInfo>::const_iterator i = lightNode->groups().begin();\n        std::vector<GroupInfo>::const_iterator end = lightNode->groups().end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == groupId && i->state == GroupInfo::StateInGroup)\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/*! Delete the light with the \\p lightId from all Scenes of the Group with the given \\p groupId.\n    Also remove these scenes from the Device.\n */\nvoid DeRestPluginPrivate::deleteLightFromScenes(QString lightId, uint16_t groupId)\n{\n    Group *group = getGroupForId(groupId);\n    LightNode *lightNode = getLightNodeForId(lightId);\n\n    if (group)\n    {\n        std::vector<Scene>::iterator i = group->scenes.begin();\n        std::vector<Scene>::iterator end = group->scenes.end();\n\n        for (; i != end; ++i)\n        {\n            i->deleteLight(lightId);\n\n            // send remove scene request to lightNode\n            if (isLightNodeInGroup(lightNode, group->address()))\n            {\n                GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\n\n                std::vector<uint8_t> &v = groupInfo->removeScenes;\n\n                if (std::find(v.begin(), v.end(), i->id) == v.end())\n                {\n                    groupInfo->removeScenes.push_back(i->id);\n                }\n            }\n        }\n    }\n}\n\n/*! Set on/off attribute for all nodes in a group.\n */\nvoid DeRestPluginPrivate::setAttributeOnOffGroup(Group *group, uint8_t onOff)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return;\n    }\n\n    bool changed = false;\n    bool on = (onOff == 0x01);\n    if (on != group->isOn())\n    {\n        group->setIsOn(on);\n        updateGroupEtag(group);\n        changed = true;\n    }\n\n    std::vector<LightNode>::iterator i = nodes.begin();\n    std::vector<LightNode>::iterator end = nodes.end();\n\n    for (; i != end; ++i)\n    {\n        LightNode *lightNode = &*i;\n        if (isLightNodeInGroup(lightNode, group->address()))\n        {\n            ResourceItem *item = lightNode->item(RStateOn);\n            if (item->toBool() != on)\n            {\n                item->setValue(on);\n                Event e(RLights, RStateOn, lightNode->id(), item);\n                enqueueEvent(e);\n                updateLightEtag(lightNode);\n            }\n            setAttributeOnOff(lightNode);\n        }\n    }\n\n    if (changed)\n    {\n        updateEtag(gwConfigEtag);\n    }\n}\n\n/*! Get scene membership of a node for a group.\n    \\param group - the group of interrest\n */\nbool DeRestPluginPrivate::readSceneMembership(LightNode *lightNode, Group *group)\n{\n    DBG_Assert(lightNode != 0);\n    DBG_Assert(group != 0);\n\n    if (!lightNode || !group || !lightNode->isAvailable())\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskGetSceneMembership;\n\n//    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(lightNode->haEndpoint().endpoint());\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = lightNode->address();\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(lightNode, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x06); // get scene membership\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << group->address();\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Checks if the scene membership is known to the group.\n    If the scene is not known it will be added.\n */\nvoid DeRestPluginPrivate::foundScene(LightNode *lightNode, Group *group, uint8_t sceneId)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return;\n    }\n\n    std::vector<Scene>::iterator i = group->scenes.begin();\n    std::vector<Scene>::iterator end = group->scenes.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->id == sceneId)\n        {\n            if (i->state == Scene::StateDeleted && group->m_deviceMemberships.size() == 0) // don't touch scenes from switch\n            {\n                GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\n\n                if (groupInfo)\n                {\n                    std::vector<uint8_t> &v = groupInfo->removeScenes;\n\n                    if (std::find(v.begin(), v.end(), sceneId) == v.end())\n                    {\n                        DBG_Printf(DBG_INFO, \"Found Scene %u which was deleted before, delete again\\n\", sceneId);\n                        groupInfo->removeScenes.push_back(sceneId);\n                    }\n                }\n            }\n            return; // already known\n        }\n    }\n\n    DBG_Printf(DBG_INFO, \"0x%016llX found scene 0x%02X for group 0x%04X\\n\", lightNode->address().ext(), sceneId, group->address());\n\n    Scene scene;\n    scene.groupAddress = group->address();\n    scene.id = sceneId;\n    openDb();\n    loadSceneFromDb(&scene);\n    closeDb();\n    if (scene.name.isEmpty())\n    {\n        scene.name = tr(\"Scene %1\").arg(sceneId);\n    }\n    group->scenes.push_back(scene);\n    updateGroupEtag(group);\n    updateEtag(gwConfigEtag);\n    queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\n}\n\n/*! Sets the name of a scene which will be saved in the database.\n */\nvoid DeRestPluginPrivate::setSceneName(Group *group, uint8_t sceneId, const QString &name)\n{\n    DBG_Assert(group != 0);\n    DBG_Assert(name.size() != 0);\n\n    if(!group || name.isEmpty())\n    {\n        return;\n    }\n\n    std::vector<Scene>::iterator i = group->scenes.begin();\n    std::vector<Scene>::iterator end = group->scenes.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->id == sceneId)\n        {\n            i->name = name;\n            queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\n            updateEtag(group->etag);\n            break;\n        }\n    }\n}\n\n/*! Sends a store scene request to a group.\n */\nbool DeRestPluginPrivate::storeScene(Group *group, uint8_t sceneId)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return false;\n    }\n\n    Scene *scene = group->getScene(sceneId);\n    if (!scene)\n    {\n        return false;\n    }\n\n    {\n        TaskItem task;\n        task.ordered = true;\n        task.req.setDstAddressMode(deCONZ::ApsGroupAddress);\n        task.req.dstAddress().setGroup(group->address());\n        task.req.setDstEndpoint(0xff);\n        task.req.setSrcEndpoint(0x01);\n\n        // add or replace empty scene, needed to set transition time\n        if (!addTaskAddEmptyScene(task, group->address(), scene->id, scene->transitiontime()))\n        {\n            return false;\n        }\n    }\n\n    {\n        TaskItem task;\n        task.ordered = true;\n        task.req.setDstAddressMode(deCONZ::ApsGroupAddress);\n        task.req.dstAddress().setGroup(group->address());\n        task.req.setDstEndpoint(0xff);\n        task.req.setSrcEndpoint(0x01);\n\n        if (!addTaskStoreScene(task, group->address(), scene->id))\n        {\n            return false;\n        }\n    }\n#if 0\n    std::vector<LightNode>::iterator i = nodes.begin();\n    std::vector<LightNode>::iterator end = nodes.end();\n    for (; i != end; ++i)\n    {\n        LightNode *lightNode = &(*i);\n        if (lightNode->isAvailable() && // note: we only create/store the scene if node is available\n            isLightNodeInGroup(lightNode, group->address()) )\n        {\n            GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\n\n            if (!groupInfo)\n            {\n                continue;\n            }\n\n            //if (lightNode->sceneCapacity() != 0 || groupInfo->sceneCount() != 0) //xxx workaround\n            {\n                std::vector<uint8_t> &v = groupInfo->modifyScenes;\n\n                if (std::find(v.begin(), v.end(), sceneId) == v.end())\n                {\n                    groupInfo->modifyScenes.push_back(sceneId);\n                }\n            }\n\n            /*if (lightNode->manufacturerCode() == VENDOR_OSRAM ||\n                lightNode->manufacturerCode() == VENDOR_OSRAM_STACK)\n            {\n                // quirks mode: need extra store scene command (color temperature issue)\n                std::vector<uint8_t> &v = groupInfo->addScenes;\n\n                if (std::find(v.begin(), v.end(), sceneId) == v.end())\n                {\n                    groupInfo->addScenes.push_back(sceneId);\n                }\n            }*/\n        }\n    }\n#endif\n\n    return true;\n}\n\n/*! Sends a modify scene request to a group.\n */\nbool DeRestPluginPrivate::modifyScene(Group *group, uint8_t sceneId)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return false;\n    }\n\n    std::vector<LightNode>::iterator i = nodes.begin();\n    std::vector<LightNode>::iterator end = nodes.end();\n    for (; i != end; ++i)\n    {\n        LightNode *lightNode = &(*i);\n        if (lightNode->isAvailable() && // note: we only modify the scene if node is available\n            isLightNodeInGroup(lightNode, group->address()))\n        {\n            GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\n\n            std::vector<uint8_t> &v = groupInfo->modifyScenes;\n\n            if (std::find(v.begin(), v.end(), sceneId) == v.end())\n            {\n                DBG_Printf(DBG_INFO, \"Start modify scene for 0x%016llX, groupId 0x%04X, scene 0x%02X\\n\", i->address().ext(), groupInfo->id, sceneId);\n                groupInfo->modifyScenes.push_back(sceneId);\n            }\n        }\n    }\n\n    return true;\n}\n\n/*! Sends a remove scene request to a group.\n */\nbool DeRestPluginPrivate::removeScene(Group *group, uint8_t sceneId)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return false;\n    }\n\n    {\n        std::vector<Scene>::iterator i = group->scenes.begin();\n        std::vector<Scene>::iterator end = group->scenes.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == sceneId)\n            {\n                i->state = Scene::StateDeleted;\n                updateEtag(group->etag);\n                updateEtag(gwConfigEtag);\n                break;\n            }\n        }\n    }\n\n    std::vector<LightNode>::iterator i = nodes.begin();\n    std::vector<LightNode>::iterator end = nodes.end();\n    for (; i != end; ++i)\n    {\n        LightNode *lightNode = &(*i);\n        // note: we queue removing of scene even if node is not available\n        if (isLightNodeInGroup(lightNode, group->address()))\n        {\n            GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\n\n            std::vector<uint8_t> &v = groupInfo->removeScenes;\n\n            if (std::find(v.begin(), v.end(), sceneId) == v.end())\n            {\n                groupInfo->removeScenes.push_back(sceneId);\n            }\n        }\n    }\n\n    return true;\n}\n\n/*! Sends a call scene request to a group.\n */\nbool DeRestPluginPrivate::callScene(Group *group, uint8_t sceneId)\n{\n    DBG_Assert(group != 0);\n\n    if (!group)\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskCallScene;\n\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n    task.req.setTxOptions(0);\n#endif\n    task.req.setDstEndpoint(0xFF);\n    task.req.setDstAddressMode(deCONZ::ApsGroupAddress);\n    task.req.dstAddress().setGroup(group->address());\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(0, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x05); // recall scene\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << group->address();\n        stream << sceneId;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    if (addTask(task))\n    {\n        return true;\n    }\n\n    return false;\n}\n\n/*! Handle incoming XAL cluster commands.\n */\nvoid DeRestPluginPrivate::handleXalClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n\n    if (!lightNode)\n    {\n        return;\n    }\n\n    if (!existDevicesWithVendorCodeForMacPrefix(lightNode->address(), VENDOR_XAL))\n    {\n        return;\n    }\n\n    bool updated = false;\n\n    if (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient && zclFrame.isClusterCommand())\n    {\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n        quint8 status;\n\n        stream >> status;\n\n        if (zclFrame.commandId() == 0x05) // light id\n        {\n            quint8 id;\n            stream >> id;\n            ResourceItem *item = lightNode->addItem(DataTypeUInt32, RAttrConfigId);\n            if (!item->lastSet().isValid() || item->toNumber() != id)\n            {\n                item->setValue(id);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode->id(), item));\n                updated = true;\n            }\n        }\n        else if (zclFrame.commandId() == 0x07) // min. level\n        {\n            quint8 minLevel;\n            stream >> minLevel;\n            ResourceItem *item = lightNode->addItem(DataTypeUInt8, RAttrLevelMin);\n            if (!item->lastSet().isValid() || item->toNumber() != minLevel)\n            {\n                item->setValue(minLevel);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode->id(), item));\n                updated = true;\n            }\n        }\n        else if (zclFrame.commandId() == 0x09) // power on level\n        {\n            quint8 powerOnLevel;\n            stream >> powerOnLevel;\n            ResourceItem *item = lightNode->addItem(DataTypeUInt8, RAttrPowerOnLevel);\n            if (!item->lastSet().isValid() || item->toNumber() != powerOnLevel)\n            {\n                item->setValue(powerOnLevel);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode->id(), item));\n                updated = true;\n            }\n        }\n        else if (zclFrame.commandId() == 0x0d) // power on temperature\n        {\n            quint16 powerOnTemp;\n            stream >> powerOnTemp;\n            ResourceItem *item = lightNode->addItem(DataTypeUInt16, RAttrPowerOnCt);\n            if (!item->lastSet().isValid() || item->toNumber() != powerOnTemp)\n            {\n                item->setValue(powerOnTemp);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode->id(), item));\n                updated = true;\n            }\n        }\n    }\n\n    if (updated)\n    {\n        updateLightEtag(lightNode);\n    }\n\n    if (zclFrame.isDefaultResponse())\n    {\n        DBG_Printf(DBG_INFO, \"XAL cluster default response cmd 0x%02X, status 0x%02X\\n\", zclFrame.defaultResponseCommandId(), zclFrame.defaultResponseStatus());\n    }\n}\n\n/*! Handle incoming ZCL attribute report commands.\n */\nvoid DeRestPluginPrivate::handleZclAttributeReportIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Q_UNUSED(zclFrame)\n\n    bool checkReporting = false;\n    const quint64 macPrefix = ind.srcAddress().ext() & macPrefixMask;\n\n    if (DBG_IsEnabled(DBG_INFO))\n    {\n        DBG_Printf(DBG_INFO, \"ZCL attribute report 0x%016llX for cluster: 0x%04X, ep: 0x%02X, frame control: 0x%02X, mfcode: 0x%04X \\n\", ind.srcAddress().ext(), ind.clusterId(), ind.srcEndpoint(), zclFrame.frameControl(), zclFrame.manufacturerCode());\n    }\n\n    if (DBG_IsEnabled(DBG_INFO_L2))\n    {\n        DBG_Printf(DBG_INFO_L2, \"\\tpayload: %s\\n\", qPrintable(zclFrame.payload().toHex()));\n    }\n\n    if (!(zclFrame.frameControl() & deCONZ::ZclFCDisableDefaultResponse))\n    {\n        checkReporting = true;\n    }\n    else if (existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_PHILIPS) ||\n            macPrefix == tiMacPrefix ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_DDEL) ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_IKEA) ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_OSRAM_STACK) ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_JENNIC) ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_SI_LABS) ||\n            existDevicesWithVendorCodeForMacPrefix(ind.srcAddress(), VENDOR_CENTRALITE))\n    {\n        // these sensors tend to mac data poll after report\n        checkReporting = true;\n    }\n\n    if (checkReporting)\n    {\n        for (Sensor &sensor : sensors)\n        {\n            if (sensor.deletedState() != Sensor::StateNormal || !sensor.node())\n            {\n                continue;\n            }\n\n            if (!isSameAddress(ind.srcAddress(), sensor.address()))\n            {\n                continue;\n            }\n\n            if (sensor.node() &&\n                ((sensor.lastAttributeReportBind() < (idleTotalCounter - BUTTON_ATTR_REPORT_BIND_LIMIT)) || sensor.lastAttributeReportBind() == 0))\n            {\n                if (checkSensorBindingsForAttributeReporting(&sensor))\n                {\n                    sensor.setLastAttributeReportBind(idleTotalCounter);\n                }\n            }\n        }\n    }\n\n    if (zclFrame.isProfileWideCommand() && existDevicesWithVendorCodeForMacPrefix(ind.srcAddress().ext(), VENDOR_XIAOMI) && ind.clusterId() == BASIC_CLUSTER_ID)\n    {\n        handleZclAttributeReportIndicationXiaomiSpecial(ind, zclFrame);\n    }\n}\n\nvoid DeRestPluginPrivate::queuePollNode(RestNodeBase *node)\n{\n    if (!node || !node->node() || node->address().ext() == gwDeviceAddress.ext())\n    {\n        return;\n    }\n\n    if (!node->node()->nodeDescriptor().receiverOnWhenIdle())\n    {\n        return; // only support non sleeping devices for now\n    }\n\n    auto *resource = dynamic_cast<Resource*>(node);\n\n    if (!resource)\n    {\n        return;\n    }\n\n    const Device *device = static_cast<Device*>(resource->parentResource());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    const PollNodeItem pollItem(node->uniqueId(), resource->prefix());\n\n    if (std::find(pollNodes.begin(), pollNodes.end(), pollItem) != pollNodes.end())\n    {\n        return; // already in queue\n    }\n\n    pollNodes.push_back(pollItem);\n}\n\n/*! Stores on/off and bri of a light so that the state can be recovered after powercycle/powerloss.\n    \\param lightNode - the related light\n */\nvoid DeRestPluginPrivate::storeRecoverOnOffBri(LightNode *lightNode)\n{\n    if (!lightNode || !lightNode->address().hasNwk())\n    {\n        return;\n    }\n\n    ResourceItem *onOff = lightNode->item(RStateOn);\n    ResourceItem *bri = lightNode->item(RStateBri);\n\n    if (!onOff || !bri)\n    {\n        return;\n    }\n\n    if (!onOff->lastSet().isValid() || !bri->lastSet().isValid())\n    {\n        return;\n    }\n\n    auto i = recoverOnOff.begin();\n    auto end = recoverOnOff.end();\n\n    for (; i != end; ++i)\n    {\n        if (isSameAddress(i->address, lightNode->address()))\n        {\n            // update entry\n            i->onOff = onOff->toBool();\n            i->bri = bri->toNumber();\n            i->idleTotalCounterCopy = idleTotalCounter;\n            return;\n        }\n    }\n\n    // create new entry\n    DBG_Printf(DBG_INFO, \"New recover onOff entry 0x%016llX\\n\", lightNode->address().ext());\n    RecoverOnOff rc;\n    rc.address = lightNode->address();\n    rc.onOff = onOff->toBool();\n    rc.bri = bri->toNumber();\n    rc.idleTotalCounterCopy = idleTotalCounter;\n    recoverOnOff.push_back(rc);\n}\n\n/*! Queues a client for closing the connection.\n    \\param sock the client socket\n    \\param closeTimeout timeout in seconds then the socket should be closed\n */\nvoid DeRestPluginPrivate::pushClientForClose(QTcpSocket *sock, int closeTimeout)\n{\n    std::vector<TcpClient>::iterator i = openClients.begin();\n    std::vector<TcpClient>::iterator end = openClients.end();\n\n    for ( ;i != end; ++i)\n    {\n        if (i->sock == sock)\n        {\n            // update\n            if (i->closeTimeout > 0)\n            {\n                if (i->closeTimeout < closeTimeout)\n                {\n                    i->closeTimeout = closeTimeout;\n                }\n            }\n            return;\n        }\n    }\n\n    TcpClient client;\n    client.sock = sock;\n    client.closeTimeout = closeTimeout;\n\n    connect(sock, SIGNAL(destroyed()),\n            this, SLOT(clientSocketDestroyed()));\n\n    openClients.push_back(client);\n}\n\n/*! Adds a task to the queue.\n    \\return true - on success\n */\nbool DeRestPluginPrivate::addTask(const TaskItem &task)\n{\n    if (!isInNetwork())\n    {\n        return false;\n    }\n\n    if (channelChangeState != CC_Idle)\n    {\n        return false;\n    }\n\n    if (DBG_IsEnabled(DBG_INFO))\n    {\n        if (task.req.dstAddress().hasExt())\n        {\n            DBG_Printf(DBG_INFO_L2, \"add task %d type %d to 0x%016llX cluster 0x%04X req.id %u\\n\", task.taskId, task.taskType, task.req.dstAddress().ext(), task.req.clusterId(), task.req.id());\n        }\n        else if (task.req.dstAddress().hasGroup())\n        {\n            DBG_Printf(DBG_INFO_L2, \"add task %d type %d to group 0x%04X cluster 0x%04X req.id %u\\n\", task.taskId, task.taskType, task.req.dstAddress().group(), task.req.clusterId(), task.req.id());\n        }\n    }\n\n    const uint MaxTasks = 20;\n\n    std::list<TaskItem>::iterator i = tasks.begin();\n    std::list<TaskItem>::iterator end = tasks.end();\n\n    if ((task.taskType != TaskSetLevel) &&\n        (task.taskType != TaskGetSceneMembership) &&\n        (task.taskType != TaskGetGroupMembership) &&\n        (task.taskType != TaskGetGroupIdentifiers) &&\n        (task.taskType != TaskStoreScene) &&\n        (task.taskType != TaskRemoveScene) &&\n        (task.taskType != TaskRemoveAllScenes) &&\n        (task.taskType != TaskReadAttributes) &&\n        (task.taskType != TaskWriteAttribute) &&\n        (task.taskType != TaskViewScene) &&\n        (task.taskType != TaskTuyaRequest) &&\n        (task.taskType != TaskAddScene))\n    {\n        for (; i != end; ++i)\n        {\n            if (i->taskType == task.taskType)\n            {\n                if ((i->req.dstAddress() ==  task.req.dstAddress()) &&\n                    (i->req.dstEndpoint() ==  task.req.dstEndpoint()) &&\n                    (i->req.srcEndpoint() ==  task.req.srcEndpoint()) &&\n                    (i->req.profileId() ==  task.req.profileId()) &&\n                    (i->req.clusterId() ==  task.req.clusterId()) &&\n                    (i->req.txOptions() ==  task.req.txOptions()) &&\n                    (i->req.asdu().size() ==  task.req.asdu().size()))\n\n                {\n                    DBG_Printf(DBG_INFO, \"Replace task %d type %d in queue cluster 0x%04X with newer task %d of same type. %u runnig tasks\\n\", i->taskId, task.taskType, task.req.clusterId(), task.taskId, runningTasks.size());\n                    *i = task;\n                    return true;\n                }\n            }\n        }\n    }\n\n    if (tasks.size() < MaxTasks) {\n        tasks.push_back(task);\n        return true;\n    }\n\n    DBG_Printf(DBG_INFO, \"failed to add task %d type: %d, too many tasks\\n\", task.taskId, task.taskType);\n\n    return false;\n}\n\n/*! Fires the next APS-DATA.request.\n */\nvoid DeRestPluginPrivate::processTasks()\n{\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    if (tasks.empty())\n    {\n        return;\n    }\n\n    if (!isInNetwork())\n    {\n        DBG_Printf(DBG_INFO, \"Not in network cleanup %d tasks\\n\", (runningTasks.size() + tasks.size()));\n        runningTasks.clear();\n        tasks.clear();\n        return;\n    }\n\n    if (channelChangeState != CC_Idle)\n    {\n        return;\n    }\n\n    if (runningTasks.size() >= MAX_BACKGROUND_TASKS)\n    {\n        std::list<TaskItem>::iterator j = runningTasks.begin();\n        std::list<TaskItem>::iterator jend = runningTasks.end();\n\n        for (; j != jend; ++j)\n        {\n            int dt = idleTotalCounter - j->sendTime;\n\n            if (dt > 120)\n            {\n                DBG_Printf(DBG_INFO, \"drop request %u send time %d, cluster 0x%04X, after %d seconds\\n\", j->req.id(), j->sendTime, j->req.clusterId(), dt);\n                runningTasks.erase(j);\n                return;\n            }\n\n        }\n\n        DBG_Printf(DBG_INFO, \"%d running tasks, wait\\n\", runningTasks.size());\n        return;\n    }\n\n    QTime now = QTime::currentTime();\n    std::list<TaskItem>::iterator i = tasks.begin();\n    std::list<TaskItem>::iterator end = tasks.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->lightNode)\n        {\n            // drop dead unicasts\n            if (!i->lightNode->isAvailable() || !i->lightNode->lastRx().isValid())\n            {\n                DBG_Printf(DBG_INFO, \"drop request to zombie (rx = %u)\\n\", (uint)i->lightNode->lastRx().isValid());\n                tasks.erase(i);\n                return;\n            }\n        }\n\n        // send only few requests to a destination at a time\n        int onAir = 0;\n        const int maxOnAir = i->req.dstAddressMode() == deCONZ::ApsGroupAddress ? 6 : 2;\n        std::list<TaskItem>::iterator j = runningTasks.begin();\n        std::list<TaskItem>::iterator jend = runningTasks.end();\n\n        bool ok = true;\n        if (i->ordered && std::distance(tasks.begin(), i) > 0) // previous not processed yet\n        {\n            ok = false;\n        }\n\n        for (; ok && j != jend; ++j)\n        {\n            if (i->ordered && i->taskId == (j->taskId + 1)) // previous running\n            {\n                ok = false;\n                break;\n            }\n\n            if (i->req.dstAddressMode() == deCONZ::ApsGroupAddress &&\n                j->req.dstAddressMode() == deCONZ::ApsGroupAddress)\n            {\n                onAir++;\n\n                if (onAir >= maxOnAir)\n                {\n                    ok = false;\n                    break;\n                }\n            }\n            else if (i->req.dstAddress() == j->req.dstAddress())\n            {\n                onAir++;\n                int dt = idleTotalCounter - j->sendTime;\n                if (dt < 5 || onAir >= maxOnAir)\n                {\n                    if (dt > 120)\n                    {\n                        DBG_Printf(DBG_INFO, \"drop request %u send time %d, cluster 0x%04X, onAir %d after %d seconds\\n\", j->req.id(), j->sendTime, j->req.clusterId(), onAir, dt);\n                        runningTasks.erase(j);\n                        return;\n                    }\n                    else\n                    {\n                        //DBG_Printf(DBG_INFO, \"request %u send time %d, cluster 0x%04X, onAir %d\\n\", i->req.id(), j->sendTime, j->req.clusterId(), onAir);\n                        DBG_Printf(DBG_INFO, \"delay sending request %u dt %d ms to 0x%016llX, ep: 0x%02X cluster: 0x%04X onAir: %d\\n\", i->req.id(), dt, i->req.dstAddress().ext(), i->req.dstEndpoint(), i->req.clusterId(), onAir);\n                        ok = false;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (!ok) // destination already busy\n        {\n        }\n        else\n        {\n            bool pushRunning = (i->req.state() != deCONZ::FireAndForgetState);\n\n            // groupcast tasks\n            if (i->req.dstAddressMode() == deCONZ::ApsGroupAddress)\n            {\n                Group *group = getGroupForId(i->req.dstAddress().group());\n\n                if (group)\n                {\n                    int diff = group->sendTime.msecsTo(now);\n\n                    if (!group->sendTime.isValid() || (diff <= 0) || (diff > gwGroupSendDelay))\n                    {\n                        i->sendTime = idleTotalCounter;\n                        if (apsCtrlWrapper.apsdeDataRequest(i->req) == deCONZ::Success)\n                        {\n                            group->sendTime = now;\n                            if (pushRunning)\n                            {\n                                runningTasks.push_back(*i);\n                            }\n                            tasks.erase(i);\n                            return;\n                        }\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO, \"delayed group sending\\n\");\n                    }\n                }\n                else\n                {\n                    DBG_Printf(DBG_INFO, \"drop request to unknown group\\n\");\n                    tasks.erase(i);\n                    return;\n                }\n            }\n            // unicast/broadcast tasks\n            else\n            {\n                if (i->lightNode && !i->lightNode->isAvailable())\n                {\n                    DBG_Printf(DBG_INFO, \"drop request to zombie\\n\");\n                    tasks.erase(i);\n                    return;\n                }\n                else\n                {\n\n                    i->sendTime = idleTotalCounter;\n                    int ret = apsCtrlWrapper.apsdeDataRequest(i->req);\n\n                    if (ret == deCONZ::Success)\n                    {\n                        if (pushRunning)\n                        {\n                            runningTasks.push_back(*i);\n                        }\n                        tasks.erase(i);\n                        return;\n                    }\n                    else if (ret == deCONZ::ErrorNodeIsZombie)\n                    {\n                        DBG_Printf(DBG_INFO, \"drop request to zombie\\n\");\n                        tasks.erase(i);\n                        return;\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO, \"enqueue APS request failed with error %d, drop\\n\", ret);\n                        tasks.erase(i);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/*! Handler for node events.\n    \\param event the event which occured\n */\nvoid DeRestPluginPrivate::nodeEvent(const deCONZ::NodeEvent &event)\n{\n    if (event.event() != deCONZ::NodeEvent::NodeDeselected)\n    {\n        if (!event.node())\n        {\n            return;\n        }\n    }\n\n    switch (event.event())\n    {\n    case deCONZ::NodeEvent::NodeSelected:\n        if (event.node()->address().nwk() == 0x0000)\n        {\n            addLightNode(event.node());\n        }\n\n        if (deviceWidget)\n        {\n            deviceWidget->nodeEvent(event);\n        }\n\n        break;\n\n    case deCONZ::NodeEvent::NodeDeselected:\n        if (deviceWidget)\n        {\n            deviceWidget->nodeEvent(event);\n        }\n        break;\n\n#if DECONZ_LIB_VERSION >= 0x011003\n    case deCONZ::NodeEvent::EditDeviceDDF:\n        if (deviceWidget)\n        {\n            deviceWidget->nodeEvent(event);\n        }\n        break;\n#endif\n\n    case deCONZ::NodeEvent::NodeRemoved: // deleted via GUI\n    {\n#if DECONZ_LIB_VERSION >= 0x011001\n        if (event.node() && event.node()->address().nwk() != 0x0000)\n        {\n            restDevices->deleteDevice(event.node()->address().ext());\n        }\n#endif\n        if (deviceWidget)\n        {\n            deviceWidget->nodeEvent(event);\n        }\n    }\n        break;\n\n    case deCONZ::NodeEvent::NodeAdded:\n    {\n        int deviceId = -1;\n        QTime now = QTime::currentTime();\n        if (queryTime.secsTo(now) < 20)\n        {\n            queryTime = now.addSecs(20);\n        }\n        if (event.node())\n        {\n            deviceId = DB_StoreDevice(event.node()->address());\n        }\n\n        auto *device = DEV_GetOrCreateDevice(this, deCONZ::ApsController::instance(), eventEmitter, m_devices, event.node()->address().ext());\n        if (device)\n        {\n            device->setDeviceId(deviceId);\n            if (DEV_InitDeviceBasic(device))\n            {\n                enqueueEvent(Event(device->prefix(), REventPoll, 0, device->key()));\n            }\n        }\n\n        addLightNode(event.node());\n        addSensorNode(event.node());\n    }\n        break;\n\n#if DECONZ_LIB_VERSION >= 0x010900\n    case deCONZ::NodeEvent::NodeMacDataRequest:\n    {\n        handleMacDataRequest(event);\n    }\n        break;\n#endif\n\n    case deCONZ::NodeEvent::NodeZombieChanged:\n    {\n        nodeZombieStateChanged(event.node());\n    }\n        break;\n\n    case deCONZ::NodeEvent::UpdatedNodeAddress:\n    {\n        if (event.node())\n        {\n            DB_StoreDevice(event.node()->address());\n        }\n        break;\n    }\n\n    case deCONZ::NodeEvent::UpdatedSimpleDescriptor:\n    {\n        addLightNode(event.node());\n        updatedLightNodeEndpoint(event);\n        addSensorNode(event.node());\n\n        if (!event.node())\n        {\n            return;\n        }\n        const deCONZ::SimpleDescriptor *sd = getSimpleDescriptor(event.node(), event.endpoint());\n        if (!sd)\n        {\n            return;\n        }\n\n        QByteArray data;\n        QDataStream stream(&data, QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        sd->writeToStream(stream);\n        if (!data.isEmpty() && sd->deviceId() != 0xffff)\n        {\n            pushZdpDescriptorDb(event.node()->address().ext(), sd->endpoint(), ZDP_SIMPLE_DESCRIPTOR_CLID, data);\n        }\n    }\n        break;\n\n    case deCONZ::NodeEvent::UpdatedNodeDescriptor:\n    {\n        if (event.node() && !event.node()->nodeDescriptor().isNull())\n        {\n            pushZdpDescriptorDb(event.node()->address().ext(), ZDO_ENDPOINT, ZDP_NODE_DESCRIPTOR_CLID, event.node()->nodeDescriptor().toByteArray());\n        }\n    }\n        break;\n\n    case deCONZ::NodeEvent::UpdatedPowerDescriptor:\n    {\n        updateSensorNode(event);\n    }\n        break;\n\n    case deCONZ::NodeEvent::UpdatedClusterData:\n    case deCONZ::NodeEvent::UpdatedClusterDataZclRead:\n    case deCONZ::NodeEvent::UpdatedClusterDataZclReport:\n    {\n        if (event.profileId() == ZDP_PROFILE_ID && event.clusterId() == ZDP_ACTIVE_ENDPOINTS_RSP_CLID)\n        {\n            updateSensorNode(event);\n            return;\n        }\n\n        if (event.profileId() != HA_PROFILE_ID && event.profileId() != ZLL_PROFILE_ID)\n        {\n            return;\n        }\n\n        if (event.node())\n        {\n            Device *device = DEV_GetDevice(m_devices, event.node()->address().ext());\n\n            if (device && device->managed())\n            {\n                return;\n            }\n        }\n\n        // filter for supported sensor clusters\n        switch (event.clusterId())\n        {\n        // sensor node?\n        case POWER_CONFIGURATION_CLUSTER_ID:\n        case ONOFF_CLUSTER_ID:\n        case ONOFF_SWITCH_CONFIGURATION_CLUSTER_ID:\n        case ILLUMINANCE_MEASUREMENT_CLUSTER_ID:\n        case ILLUMINANCE_LEVEL_SENSING_CLUSTER_ID:\n        case TEMPERATURE_MEASUREMENT_CLUSTER_ID:\n        case RELATIVE_HUMIDITY_CLUSTER_ID:\n        case PRESSURE_MEASUREMENT_CLUSTER_ID:\n        case SOIL_MOISTURE_CLUSTER_ID:\n        case OCCUPANCY_SENSING_CLUSTER_ID:\n        case IAS_ZONE_CLUSTER_ID:\n        case BASIC_CLUSTER_ID:\n        case ANALOG_INPUT_CLUSTER_ID:\n        case MULTISTATE_INPUT_CLUSTER_ID:\n        case BINARY_INPUT_CLUSTER_ID:\n        case METERING_CLUSTER_ID:\n        case ELECTRICAL_MEASUREMENT_CLUSTER_ID:\n        case VENDOR_CLUSTER_ID:\n        case WINDOW_COVERING_CLUSTER_ID:\n        case DOOR_LOCK_CLUSTER_ID:\n        case SAMJIN_CLUSTER_ID:\n        case TIME_CLUSTER_ID:\n        case BOSCH_AIR_QUALITY_CLUSTER_ID:\n            {\n                addSensorNode(event.node(), &event);\n                updateSensorNode(event);\n            }\n            break;\n\n        default:\n            break;\n        }\n\n        // filter for supported light clusters\n        switch (event.clusterId())\n        {\n        // sensor node?\n        case BASIC_CLUSTER_ID:\n        case IDENTIFY_CLUSTER_ID:\n        case ONOFF_CLUSTER_ID:\n        case LEVEL_CLUSTER_ID:\n        case GROUP_CLUSTER_ID:\n        case SCENE_CLUSTER_ID:\n        case COLOR_CLUSTER_ID:\n        case ANALOG_OUTPUT_CLUSTER_ID: // lumi.curtain\n        case WINDOW_COVERING_CLUSTER_ID:  // FIXME ubisys J1 is not a light\n        // Danalock support. In nodeEvent() in de_web_plugin.cpp, whitelist DOOR_LOCK_CLUSTER_ID to call updateLightNode()\n        case DOOR_LOCK_CLUSTER_ID:\n        {\n            updateLightNode(event);\n        }\n        break;\n        case FAN_CONTROL_CLUSTER_ID:\n            {\n                updateLightNode(event);\n            }\n            break;\n\n        default:\n            break;\n        }\n    }\n        break;\n\n    default:\n        break;\n    }\n}\n\n/*! Process task like add to group and remove from group.\n */\nvoid DeRestPluginPrivate::processGroupTasks()\n{\n    if (nodes.empty())\n    {\n        return;\n    }\n\n    if (!isInNetwork())\n    {\n        return;\n    }\n\n    if (tasks.size() > MaxGroupTasks)\n    {\n        return;\n    }\n\n    if (DA_ApsUnconfirmedRequests() > 3)\n    {\n        return;\n    }\n\n    if (groupTaskNodeIter >= nodes.size())\n    {\n        groupTaskNodeIter = 0;\n    }\n\n    if (!nodes[groupTaskNodeIter].isAvailable())\n    {\n        groupTaskNodeIter++;\n        return;\n    }\n\n    TaskItem task;\n\n    task.lightNode = &nodes[groupTaskNodeIter];\n    groupTaskNodeIter++;\n\n    if (task.lightNode->state() != LightNode::StateNormal)\n    {\n        return;\n    }\n\n    // set destination parameters\n    task.req.dstAddress() = task.lightNode->address();\n//    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(task.lightNode->haEndpoint().endpoint());\n    task.req.setSrcEndpoint(getSrcEndpoint(task.lightNode, task.req));\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n\n    std::vector<GroupInfo>::iterator i = task.lightNode->groups().begin();\n    std::vector<GroupInfo>::iterator end = task.lightNode->groups().end();\n\n    for (; i != end; ++i)\n    {\n        if (i->actions & GroupInfo::ActionAddToGroup)\n        {\n            if (addTaskAddToGroup(task, i->id))\n            {\n                i->actions &= ~GroupInfo::ActionAddToGroup;\n            }\n            return;\n        }\n\n        if (i->actions & GroupInfo::ActionRemoveFromGroup)\n        {\n            if (addTaskRemoveFromGroup(task, i->id))\n            {\n                i->actions &= ~GroupInfo::ActionRemoveFromGroup;\n            }\n            return;\n        }\n\n        if (!i->addScenes.empty())\n        {\n            if (addTaskStoreScene(task, i->id, i->addScenes[0]))\n            {\n                processTasks();\n            }\n            return;\n        }\n\n        if (!i->removeScenes.empty())\n        {\n            if (addTaskRemoveScene(task, i->id, i->removeScenes[0]))\n            {\n                processTasks();\n            }\n            return;\n        }\n\n        for (const TaskItem &task : tasks)\n        {\n            if (task.taskType == TaskAddScene || task.taskType == TaskStoreScene)\n            {\n                // wait till tasks are processed\n                return;\n            }\n        }\n\n        for (const TaskItem &task : runningTasks)\n        {\n            if (task.taskType == TaskAddScene || task.taskType == TaskStoreScene)\n            {\n                // wait till tasks are processed\n                return;\n            }\n        }\n\n        if (!i->modifyScenes.empty())\n        {\n            if (i->modifyScenesRetries < GroupInfo::MaxActionRetries)\n            {\n                i->modifyScenesRetries++;\n\n                bool needRead = false;\n                Scene *scene = getSceneForId(i->id, i->modifyScenes[0]);\n\n                if (scene)\n                {\n                    //const std::vector<LightState> &lights() const;\n                    std::vector<LightState>::const_iterator ls = scene->lights().begin();\n                    std::vector<LightState>::const_iterator lsend = scene->lights().end();\n\n                    for (; ls != lsend; ++ls)\n                    {\n                        if (!ls->needRead())\n                        {\n                            continue;\n                        }\n\n                        if (ls->lid() == task.lightNode->id())\n                        {\n                            needRead = true;\n                            if (readSceneAttributes(task.lightNode, i->id, scene->id))\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n\n\n                if (!needRead && addTaskAddScene(task, i->id, i->modifyScenes[0], task.lightNode->id()))\n                {\n                    processTasks();\n                    return;\n                }\n            }\n            else\n            {\n                i->modifyScenes.front() = i->modifyScenes.back();\n                i->modifyScenes.pop_back();\n                i->modifyScenesRetries = 0;\n            }\n        }\n    }\n}\n\n/*! Handle packets related to the ZCL group cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the groups cluster reponse\n */\nvoid DeRestPluginPrivate::handleGroupClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n\n    if (!lightNode)\n    {\n        return;\n    }\n\n    int endpointCount = getNumberOfEndpoints(lightNode->address().ext());\n\n    if (zclFrame.isDefaultResponse())\n    {\n    }\n    else if (zclFrame.commandId() == 0x02) // Get group membership response\n    {\n        DBG_Assert(zclFrame.payload().size() >= 2);\n\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        uint8_t capacity;\n        uint8_t count;\n\n        stream >> capacity;\n        stream >> count;\n\n        lightNode->setGroupCapacity(capacity);\n        lightNode->setGroupCount(count);\n\n        QVector<quint16> responseGroups;\n        for (uint i = 0; i < count; i++)\n        {\n            if (!stream.atEnd())\n            {\n                uint16_t groupId;\n                stream >> groupId;\n\n                responseGroups.push_back(groupId);\n\n                DBG_Printf(DBG_INFO, FMT_MAC \" found group 0x%04X\\n\", (unsigned long long)lightNode->address().ext(), groupId);\n\n                foundGroup(groupId);\n                foundGroupMembership(lightNode, groupId);\n            }\n        }\n\n        std::vector<GroupInfo>::iterator i = lightNode->groups().begin();\n        std::vector<GroupInfo>::iterator end = lightNode->groups().end();\n\n        for (; i != end; ++i)\n        {\n            Group *group = getGroupForId(i->id);\n\n            if (group && group->state() == Group::StateNormal\n                && group->m_deviceMemberships.size() == 0 //no switch group\n                && !responseGroups.contains(i->id)\n                && i->state == GroupInfo::StateInGroup)\n            {\n                    DBG_Printf(DBG_INFO, FMT_MAC \" restore group 0x%04X for lightNode\\n\", (unsigned long long)lightNode->address().ext(), i->id);\n                    i->actions &= ~GroupInfo::ActionRemoveFromGroup; // sanity\n                    i->actions |= GroupInfo::ActionAddToGroup;\n                    i->state = GroupInfo::StateInGroup;\n                    updateEtag(group->etag);\n                    updateEtag(gwConfigEtag);\n                    lightNode->setNeedSaveDatabase(true);\n                    queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n            }\n            else if (group && group->state() == Group::StateNormal\n                && group->m_deviceMemberships.size() > 0) //a switch group\n            {\n                if (responseGroups.contains(i->id)\n                    && i->state == GroupInfo::StateNotInGroup) // light was added by a switch -> add it to deCONZ group)\n                {\n                    i->state = GroupInfo::StateInGroup;\n                    std::vector<QString> &v = group->m_multiDeviceIds;\n                    std::vector<QString>::iterator fi = std::find(v.begin(), v.end(), lightNode->id());\n                    if (fi != v.end())\n                    {\n                        group->m_multiDeviceIds.erase(fi);\n                        queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\n                    }\n                    updateEtag(group->etag);\n                    updateEtag(gwConfigEtag);\n                    lightNode->setNeedSaveDatabase(true);\n                    queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\n                }\n                else if (!responseGroups.contains(i->id)\n                    && i->state == GroupInfo::StateInGroup) // light was removed from group by switch -> remove it from deCONZ group)\n                {\n                    i->state = GroupInfo::StateNotInGroup;\n                    updateEtag(group->etag);\n                    updateEtag(gwConfigEtag);\n     "
        },
        {
          "name": "de_web_plugin.h",
          "type": "blob",
          "size": 1.92578125,
          "content": "/*\n * Copyright (c) 2017-2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_PLUGIN_H\n#define REST_PLUGIN_H\n\n#include <list>\n#include <QObject>\n#include <deconz.h>\n\nclass DeRestWidget;\nclass DeRestPluginPrivate;\nclass DeviceWidget;\n\nclass QTimer;\n\n#if DECONZ_LIB_VERSION < 0x010800\n  #error \"The REST plugin requires at least deCONZ library version 1.8.0.\"\n#endif\n\nclass DeRestPlugin : public QObject,\n                     public deCONZ::NodeInterface,\n                     public deCONZ::HttpClientHandler\n{\n    Q_OBJECT\n    Q_INTERFACES(deCONZ::NodeInterface)\n#if QT_VERSION >= 0x050000\n    Q_PLUGIN_METADATA(IID \"org.dresden-elektronik.DeRestPlugin\")\n#endif\npublic:\n    explicit DeRestPlugin(QObject *parent = 0);\n    ~DeRestPlugin();\n    // node interface\n    const char *name();\n    bool hasFeature(Features feature);\n    QWidget *createWidget();\n    QDialog *createDialog();\n\n    // http client handler interface\n    bool isHttpTarget(const QHttpRequestHeader &hdr);\n    int handleHttpRequest(const QHttpRequestHeader &hdr, QTcpSocket *sock);\n    void clientGone(QTcpSocket *sock);\n    bool pluginActive() const;\n\npublic Q_SLOTS:\n    bool dbSaveAllowed() const;\n    void idleTimerFired();\n    void refreshAll();\n    void startZclAttributeTimer(int delay);\n    void stopZclAttributeTimer();\n    void checkZclAttributeTimerFired();\n    void appAboutToQuit();\n    bool startUpdateFirmware();\n    const QString &getNodeName(quint64 extAddress) const;\n\nQ_SIGNALS:\n    void nodeUpdated(quint64 extAddress, QString key, QString value);\n\nprivate:\n    QTimer *m_idleTimer = nullptr;\n    QTimer *m_readAttributesTimer = nullptr;\n    friend class DeRestWidget;\n    DeRestWidget *m_w = nullptr;\n    DeRestPluginPrivate *d = nullptr;\n};\n\n#endif // REST_PLUGIN_H\n"
        },
        {
          "name": "de_web_plugin_private.h",
          "type": "blob",
          "size": 77.751953125,
          "content": "/*\n * Copyright (c) 2017-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DE_WEB_PLUGIN_PRIVATE_H\n#define DE_WEB_PLUGIN_PRIVATE_H\n#include <QtGlobal>\n#include <QObject>\n#include <QTime>\n#include <QTimer>\n#include <QElapsedTimer>\n#include <stdint.h>\n#include <queue>\n#include <memory>\n#include <sqlite3.h>\n#include <deconz.h>\n#include \"device.h\"\n#include \"aps_controller_wrapper.h\"\n#include \"alarm_system.h\"\n#include \"resource.h\"\n#include \"daylight.h\"\n#include \"event_emitter.h\"\n#include \"green_power.h\"\n#include \"resource.h\"\n#include \"rest_api.h\"\n#include \"rest_node_base.h\"\n#include \"light_node.h\"\n#include \"group.h\"\n#include \"group_info.h\"\n#include \"scene.h\"\n#include \"sensor.h\"\n#include \"resourcelinks.h\"\n#include \"rule.h\"\n#include \"bindings.h\"\n#include \"websocket_server.h\"\n\n// enable domain specific string literals\nusing namespace deCONZ::literals;\n\n#if defined(Q_OS_LINUX) && !defined(Q_PROCESSOR_X86)\n  // Workaround to detect ARM and AARCH64 in older Qt versions.\n  #define ARCH_ARM\n#endif\n\n#define IDLE_TIMER_INTERVAL 1000\n#define IDLE_LIMIT 30\n#define IDLE_READ_LIMIT 120\n#define IDLE_USER_LIMIT 20\n#define IDLE_ATTR_REPORT_BIND_LIMIT 1800\n#define IDLE_ATTR_REPORT_BIND_LIMIT_SHORT 5\n#define BUTTON_ATTR_REPORT_BIND_LIMIT 120\n#define WARMUP_TIME 120\n#define RULE_CHECK_DELAY 4 // seconds\n\n#define MAX_UNLOCK_GATEWAY_TIME 600\n#define MAX_RECOVER_ENTRY_AGE 600\n#define PERMIT_JOIN_SEND_INTERVAL (1000 * 60)\n#define SET_ENDPOINTCONFIG_DURATION (1000 * 16) // time deCONZ needs to update Endpoints\n#define OTA_LOW_PRIORITY_TIME (60 * 2)\n#define CHECK_SENSOR_FAST_ROUNDS 3\n#define CHECK_SENSOR_FAST_INTERVAL 100\n#define CHECK_SENSOR_INTERVAL      1000\n#define CHECK_SENSORS_MAX          10\n#define CHECK_ZB_GOOD_INTERVAL     60\n\n// wifi managed flags\n#define WIFI_MGTM_HOSTAPD         0x01  // hostapd (by deCONZ)\n#define WIFI_MGTM_WPA_SUPPLICANT  0x02  // wpa_supplicant (by deCONZ)\n#define WIFI_MGTM_INTERFACES      0x04  // interfaces (by deCONZ)\n#define WIFI_MGMT_ACTIVE          0x08  // 1 when accesspoint or client is active\n\n#define DE_OTAU_ENDPOINT             0x50\n#define DE_PROFILE_ID              0xDE00\n\n// Digi Drop-In-Networking (DIN) ZigBee Profile, used by the XBee.\n#define DIN_PROFILE_ID                      0xC105 // Digi Drop-In-Networking\n#define DIN_DDO_ENDPOINT                    0xE6   // Digi Device Object endpoint\n#define DIN_DDM_ENDPOINT                    0xE8   // Digi Data Management endpoint\n#define DEV_ID_DIN_XBEE                     0x0001 // Device ID used by the XBee\n\n// Generic devices\n#define DEV_ID_ONOFF_SWITCH                 0x0000 // On/Off switch\n#define DEV_ID_LEVEL_CONTROL_SWITCH         0x0001 // Level control switch\n#define DEV_ID_ONOFF_OUTPUT                 0x0002 // On/Off output\n#define DEV_ID_LEVEL_CONTROLLABLE_OUTPUT    0x0003 // Level controllable output\n#define DEV_ID_CONFIGURATION_TOOL           0x0005 // Configuration tool\n#define DEV_ID_RANGE_EXTENDER               0x0008 // Range extender\n#define DEV_ID_MAINS_POWER_OUTLET           0x0009 // Mains power outlet\n#define DEV_ID_CONSUMPTION_AWARENESS_DEVICE 0x000d // Consumption awareness device\n#define DEV_ID_FAN                          0x000e // Fan (used by Hamption Bay fan module)\n#define DEV_ID_SMART_PLUG                   0x0051 // Smart plug\n// HA lighting devices\n#define DEV_ID_HA_ONOFF_LIGHT               0x0100 // On/Off light\n#define DEV_ID_HA_DIMMABLE_LIGHT            0x0101 // Dimmable light\n#define DEV_ID_HA_COLOR_DIMMABLE_LIGHT      0x0102 // Color dimmable light\n#define DEV_ID_HA_ONOFF_LIGHT_SWITCH        0x0103 // On/Off light switch\n#define DEV_ID_HA_DIMMER_SWITCH             0x0104 // Dimmer switch\n#define DEV_ID_HA_LIGHT_SENSOR              0x0106 // Light sensor\n#define DEV_ID_HA_OCCUPANCY_SENSOR          0x0107 // Occupancy sensor\n\n// Other HA devices\n#define DEV_ID_HA_WINDOW_COVERING_DEVICE    0x0202 // Window Covering Device\n#define DEV_ID_HA_WINDOW_COVERING_CONTROLLER 0x0203 // Window Covering Controller\n\n// Door lock device\n#define DEV_ID_DOOR_LOCK                    0x000a // Door Lock\n#define DEV_ID_DOOR_LOCK_UNIT               0x000b // Door Lock controller\n\n//\n#define DEV_ID_IAS_ZONE                     0x0402 // IAS Zone\n#define DEV_ID_IAS_WARNING_DEVICE           0x0403 // IAS Warning Device\n// Smart Energy devices\n#define DEV_ID_SE_METERING_DEVICE           0x0501 // Smart Energy metering device\n\n// ZLL lighting devices\n#define DEV_ID_ZLL_ONOFF_LIGHT              0x0000 // On/Off light\n#define DEV_ID_ZLL_ONOFF_PLUGIN_UNIT        0x0010 // On/Off plugin unit\n#define DEV_ID_ZLL_DIMMABLE_LIGHT           0x0100 // Dimmable light\n#define DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT     0x0110 // Dimmable plugin unit\n#define DEV_ID_ZLL_COLOR_LIGHT              0x0200 // Color light\n#define DEV_ID_ZLL_EXTENDED_COLOR_LIGHT     0x0210 // Extended color light\n#define DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT  0x0220 // Color temperature light\n// ZigBee 3.0 lighting devices\n#define DEV_ID_Z30_ONOFF_PLUGIN_UNIT        0x010a // On/Off plugin unit\n#define DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT     0x010b // Dimmable plugin unit\n#define DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT  0x010c // Color temperature light\n#define DEV_ID_Z30_EXTENDED_COLOR_LIGHT     0x010d // Extended color light\n// ZLL controller devices\n#define DEV_ID_ZLL_COLOR_CONTROLLER         0x0800 // Color controller\n#define DEV_ID_ZLL_COLOR_SCENE_CONTROLLER   0x0810 // Color scene controller\n#define DEV_ID_ZLL_NON_COLOR_CONTROLLER     0x0820 // Non color controller\n#define DEV_ID_ZLL_NON_COLOR_SCENE_CONTROLLER 0x0830 // Non color scene controller\n#define DEV_ID_ZLL_CONTROL_BRIDGE           0x0840 // Control bridge\n#define DEV_ID_ZLL_ONOFF_SENSOR             0x0850 // On/Off sensor\n\n#define DEV_ID_XIAOMI_SMART_PLUG            0xffff\n\n#define DEFAULT_TRANSITION_TIME 4 // 400ms\n#define MAX_ENHANCED_HUE 65535\n#define MAX_ENHANCED_HUE_Z 65278 // max supportet ehue of all devices\n#define MIN_UNIQUEID_LENGTH 26   // 00:21:2e:ff:ff:00:a6:fd-02\n\n#define BASIC_CLUSTER_ID                      0x0000\n#define POWER_CONFIGURATION_CLUSTER_ID        0x0001\n#define IDENTIFY_CLUSTER_ID                   0x0003\n#define GROUP_CLUSTER_ID                      0x0004\n#define SCENE_CLUSTER_ID                      0x0005\n#define ONOFF_CLUSTER_ID                      0x0006\n#define ONOFF_SWITCH_CONFIGURATION_CLUSTER_ID 0x0007\n#define LEVEL_CLUSTER_ID                      0x0008\n#define TIME_CLUSTER_ID                       0x000A\n#define ANALOG_INPUT_CLUSTER_ID               0x000C\n#define ANALOG_OUTPUT_CLUSTER_ID              0x000D\n#define BINARY_INPUT_CLUSTER_ID               0x000F\n#define MULTISTATE_INPUT_CLUSTER_ID           0x0012\n#define MULTISTATE_OUTPUT_CLUSTER_ID          0x0013\n#define OTAU_CLUSTER_ID                       0x0019\n#define POLL_CONTROL_CLUSTER_ID               0x0020\n#define DOOR_LOCK_CLUSTER_ID                  0x0101\n#define WINDOW_COVERING_CLUSTER_ID            0x0102\n#define THERMOSTAT_CLUSTER_ID                 0x0201\n#define FAN_CONTROL_CLUSTER_ID                0x0202\n#define THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID 0x0204\n#define COLOR_CLUSTER_ID                      0x0300\n#define ILLUMINANCE_MEASUREMENT_CLUSTER_ID    0x0400\n#define ILLUMINANCE_LEVEL_SENSING_CLUSTER_ID  0x0401\n#define TEMPERATURE_MEASUREMENT_CLUSTER_ID    0x0402\n#define PRESSURE_MEASUREMENT_CLUSTER_ID       0x0403\n#define RELATIVE_HUMIDITY_CLUSTER_ID          0x0405\n#define OCCUPANCY_SENSING_CLUSTER_ID          0x0406\n#define SOIL_MOISTURE_CLUSTER_ID              0x0408\n#define IAS_ZONE_CLUSTER_ID                   0x0500\n#define IAS_ACE_CLUSTER_ID                    0x0501\n#define IAS_WD_CLUSTER_ID                     0x0502\n#define METERING_CLUSTER_ID                   0x0702\n#define APPLIANCE_EVENTS_AND_ALERTS_CLUSTER_ID 0x0B02\n#define ELECTRICAL_MEASUREMENT_CLUSTER_ID     0x0B04\n#define DIAGNOSTICS_CLUSTER_ID                0x0B05\n#define COMMISSIONING_CLUSTER_ID              0x1000\n#define TUYA_CLUSTER_ID                       0xEF00\n#define DE_CLUSTER_ID                         0xFC00\n#define VENDOR_CLUSTER_ID                     0xFC00\n#define UBISYS_DEVICE_SETUP_CLUSTER_ID        0xFC00\n#define SAMJIN_CLUSTER_ID                     0xFC02\n#define DEVELCO_AIR_QUALITY_CLUSTER_ID        0xFC03\n#define SENGLED_CLUSTER_ID                    0xFC10\n#define LEGRAND_CONTROL_CLUSTER_ID            0xFC40\n#define XIAOMI_CLUSTER_ID                     0xFCC0\n#define ADUROLIGHT_CLUSTER_ID                 0xFCCC\n#define XIAOYAN_CLUSTER_ID                    0xFCCC\n#define XAL_CLUSTER_ID                        0xFCCE\n#define BOSCH_AIR_QUALITY_CLUSTER_ID          quint16(0xFDEF)\n\n#define IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID  0x0002\n\n#define ONOFF_COMMAND_OFF     0x00\n#define ONOFF_COMMAND_ON      0x01\n#define ONOFF_COMMAND_TOGGLE  0x02\n#define ONOFF_COMMAND_OFF_WITH_EFFECT  0x040\n#define ONOFF_COMMAND_ON_WITH_TIMED_OFF  0x42\n#define LEVEL_COMMAND_MOVE_TO_LEVEL 0x00\n#define LEVEL_COMMAND_MOVE 0x01\n#define LEVEL_COMMAND_STEP 0x02\n#define LEVEL_COMMAND_STOP 0x03\n#define LEVEL_COMMAND_MOVE_TO_LEVEL_WITH_ON_OFF 0x04\n#define LEVEL_COMMAND_MOVE_WITH_ON_OFF 0x05\n#define LEVEL_COMMAND_STEP_WITH_ON_OFF 0x06\n#define LEVEL_COMMAND_STOP_WITH_ON_OFF 0x07\n#define SCENE_COMMAND_RECALL_SCENE 0x05\n#define SCENE_COMMAND_IKEA_STEP_CT 0x07\n#define SCENE_COMMAND_IKEA_MOVE_CT 0x08\n#define SCENE_COMMAND_IKEA_STOP_CT 0x09\n#define WINDOW_COVERING_COMMAND_OPEN          0x00\n#define WINDOW_COVERING_COMMAND_CLOSE         0x01\n#define WINDOW_COVERING_COMMAND_STOP          0x02\n#define WINDOW_COVERING_COMMAND_GOTO_LIFT_PCT 0x05\n#define WINDOW_COVERING_COMMAND_GOTO_TILT_PCT 0x08\n\n#define XIAOYAN_ATTRID_ROTATION_ANGLE      0x001B\n#define XIAOYAN_ATTRID_DURATION            0x001A\n\n#define MULTI_STATE_INPUT_PRESENT_VALUE_ATTRIBUTE_ID quint16(0x0055)\n\n// IAS Zone Types\n#define IAS_ZONE_TYPE_STANDARD_CIE            0x0000\n#define IAS_ZONE_TYPE_MOTION_SENSOR           0x000d\n#define IAS_ZONE_TYPE_CONTACT_SWITCH          0x0015\n#define IAS_ZONE_TYPE_FIRE_SENSOR             0x0028\n#define IAS_ZONE_TYPE_WATER_SENSOR            0x002a\n#define IAS_ZONE_TYPE_CARBON_MONOXIDE_SENSOR  0x002b\n#define IAS_ZONE_TYPE_VIBRATION_SENSOR        0x002d\n#define IAS_ZONE_TYPE_WARNING_DEVICE          0x0225\n\n// IAS Setup states\n#define IAS_STATE_INIT                 0\n#define IAS_STATE_ENROLLED             1 // finished\n#define IAS_STATE_READ                 2\n#define IAS_STATE_WAIT_READ            3\n#define IAS_STATE_WRITE_CIE_ADDR       4\n#define IAS_STATE_WAIT_WRITE_CIE_ADDR  5\n#define IAS_STATE_DELAY_ENROLL         6\n#define IAS_STATE_ENROLL               7\n#define IAS_STATE_WAIT_ENROLL          8\n#define IAS_STATE_MAX                  9 // invalid\n\n#ifndef DBG_IAS\n  #define DBG_IAS DBG_INFO  // DBG_IAS didn't exist before version v2.10.x\n#endif\n\n// read and write flags\n#define READ_MODEL_ID          (1 << 0)\n#define READ_SWBUILD_ID        (1 << 1)\n#define READ_ON_OFF            (1 << 2)\n#define READ_LEVEL             (1 << 3)\n#define READ_COLOR             (1 << 4)\n#define READ_GROUPS            (1 << 5)\n#define READ_SCENES            (1 << 6)\n#define READ_SCENE_DETAILS     (1 << 7)\n#define READ_VENDOR_NAME       (1 << 8)\n#define READ_BINDING_TABLE     (1 << 9)\n#define READ_OCCUPANCY_CONFIG  (1 << 10)\n#define WRITE_OCCUPANCY_CONFIG (1 << 11)\n#define READ_GROUP_IDENTIFIERS (1 << 12)\n#define WRITE_DELAY            (1 << 13)\n#define WRITE_SENSITIVITY      (1 << 15)\n#define READ_THERMOSTAT_STATE  (1 << 17)\n#define READ_BATTERY           (1 << 18)\n#define READ_TIME              (1 << 19)\n#define WRITE_TIME             (1 << 20)\n#define READ_THERMOSTAT_SCHEDULE (1 << 21)\n\n#define READ_MODEL_ID_INTERVAL   (60 * 60) // s\n#define READ_SWBUILD_ID_INTERVAL (60 * 60) // s\n\n// manufacturer codes\n// https://github.com/wireshark/wireshark/blob/master/epan/dissectors/packet-zbee.h\n#define VENDOR_NONE                 0x0000\n#define VENDOR_EMBER                0x1002\n#define VENDOR_PHILIPS              0x100B // Also used by iCasa routers\n#define VENDOR_VISONIC              0x1011\n#define VENDOR_ATMEL                0x1014\n#define VENDOR_DEVELCO              0x1015\n#define VENDOR_YALE                 0x101D\n#define VENDOR_MAXSTREAM            0x101E // Used by Digi\n#define VENDOR_VANTAGE              0x1021\n#define VENDOR_LEGRAND              0x1021 // wrong name?\n#define VENDOR_LGE                  0x102E\n#define VENDOR_JENNIC               0x1037 // Used by Xiaomi, Trust, Eurotronic\n#define VENDOR_ALERTME              0x1039\n#define VENDOR_CLS                  0x104E\n#define VENDOR_CENTRALITE           0x104E // wrong name?\n#define VENDOR_SI_LABS              0x1049\n#define VENDOR_SCHNEIDER            0x105E\n#define VENDOR_4_NOKS               0x1071\n#define VENDOR_BITRON               0x1071 // branded\n#define VENDOR_COMPUTIME            0x1078\n#define VENDOR_XFINITY              0x10EF // Xfinity\n#define VENDOR_AXIS                 0x1262 // Axis\n#define VENDOR_KWIKSET              0x1092\n#define VENDOR_MMB                  0x109a\n#define VENDOR_NETVOX               0x109F\n#define VENDOR_NYCE                 0x10B9\n#define VENDOR_UNIVERSAL2           0x10EF\n#define VENDOR_UBISYS               0x10F2\n#define VENDOR_DATEK_WIRLESS        0x1337\n#define VENDOR_DANALOCK             0x115C\n#define VENDOR_SCHLAGE              0x1236 // Used by Schlage Locks\n#define VENDOR_BEGA                 0x1105\n#define VENDOR_PHYSICAL             0x110A // Used by SmartThings\n#define VENDOR_OSRAM                0x110C\n#define VENDOR_PROFALUX             0x1110\n#define VENDOR_EMBERTEC             0x1112\n#define VENDOR_JASCO                0x1124 // Used by GE\n#define VENDOR_BUSCH_JAEGER         0x112E\n#define VENDOR_SERCOMM              0x1131\n#define VENDOR_BOSCH                0x1133\n#define VENDOR_DDEL                 0x1135\n#define VENDOR_WAXMAN               0x113B\n#define VENDOR_OWON                 0x113C\n#define VENDOR_TUYA                 0x1141\n#define VENDOR_LUTRON               0x1144\n#define VENDOR_BOSCH2               0x1155\n#define VENDOR_ZEN                  0x1158\n#define VENDOR_KEEN_HOME            0x115B\n#define VENDOR_XIAOMI               0x115F\n#define VENDOR_SENGLED_OPTOELEC     0x1160\n#define VENDOR_INNR                 0x1166\n#define VENDOR_LDS                  0x1168 // Used by Samsung SmartPlug 2019\n#define VENDOR_PLUGWISE_BV          0x1172\n#define VENDOR_D_LINK               0x1175\n#define VENDOR_INSTA                0x117A\n#define VENDOR_IKEA                 0x117C\n#define VENDOR_3A_SMART_HOME        0x117E\n#define VENDOR_STELPRO              0x1185\n#define VENDOR_LEDVANCE             0x1189\n#define VENDOR_SINOPE               0x119C\n#define VENDOR_JIUZHOU              0x119D\n#define VENDOR_PAULMANN             0x119D // branded\n#define VENDOR_BOSCH3               0x1209\n#define VENDOR_HEIMAN               0x120B\n#define VENDOR_CHINA_FIRE_SEC       0x1214\n#define VENDOR_MUELLER              0x121B // Used by Mueller Licht\n#define VENDOR_AURORA               0x121C // Used by Aurora Aone\n#define VENDOR_SUNRICHER            0x1224 // white label used by iCasa, Illuminize, Namron, SLC ...\n#define VENDOR_XIAOYAN              0x1228\n#define VENDOR_XAL                  0x122A\n#define VENDOR_ADUROLIGHT           0x122D\n#define VENDOR_THIRD_REALITY        0x1233\n#define VENDOR_DSR                  0x1234\n#define VENDOR_HANGZHOU_IMAGIC      0x123B\n#define VENDOR_SAMJIN               0x1241\n#define VENDOR_DANFOSS              0x1246\n#define VENDOR_NIKO_NV              0x125F\n#define VENDOR_KONKE                0x1268\n#define VENDOR_SHYUGJ_TECHNOLOGY    0x126A\n#define VENDOR_ADEO                 0x1277\n#define VENDOR_XIAOMI2              0x126E\n#define VENDOR_DATEK                0x1337\n#define VENDOR_OSRAM_STACK          0xBBAA\n#define VENDOR_C2DF                 0xC2DF\n#define VENDOR_PHILIO               0xFFA0\n\n#define ANNOUNCE_INTERVAL 45 // minutes default announce interval\n\n#define MAX_NODES 200\n#define MAX_SENSORS 1000\n#define MAX_GROUPS 100\n#define MAX_SCENES 100\n#define MAX_LIGHTSTATES 1000\n#define MAX_SCHEDULES 500\n#define MAX_RULES 500\n#define MAX_CONDITIONS 1000\n#define MAX_ACTIONS 1000\n#define MAX_RESOURCELINKS 100\n#define MAX_STREAMING 0\n#define MAX_CHANNELS 50\n\n#define MAX_GROUP_SEND_DELAY 5000 // ms between to requests to the same group\n#define GROUP_SEND_DELAY 50 // default ms between to requests to the same group\n#define MAX_TASKS_PER_NODE 2\n#define MAX_BACKGROUND_TASKS 5\n\n#define MAX_RULE_ILLUMINANCE_VALUE_AGE_MS (1000 * 60 * 20) // 20 minutes\n\n// string lengths\n#define MAX_GROUP_NAME_LENGTH 32\n#define MAX_SCENE_NAME_LENGTH 32\n#define MAX_RULE_NAME_LENGTH 64\n#define MAX_SENSOR_NAME_LENGTH 32\n\n// Special application return codes\n#define APP_RET_UPDATE        40\n#define APP_RET_RESTART_APP   41\n#define APP_RET_UPDATE_BETA   42\n#define APP_RET_RESTART_SYS   43\n#define APP_RET_SHUTDOWN_SYS  44\n#define APP_RET_UPDATE_ALPHA  45\n#define APP_RET_UPDATE_FW     46\n\n// Firmware version related (32-bit field)\n#define FW_PLATFORM_MASK          0x0000FF00UL\n#define FW_PLATFORM_DERFUSB23E0X  0x00000300UL\n#define FW_PLATFORM_AVR           0x00000500UL\n#define FW_PLATFORM_R21           0x00000700UL\n\n// schedules\n#define SCHEDULE_CHECK_PERIOD 1000\n\n// save database items\n#define DB_LIGHTS         0x00000001\n#define DB_GROUPS         0x00000002\n#define DB_AUTH           0x00000004\n#define DB_CONFIG         0x00000008\n#define DB_SCENES         0x00000010\n#define DB_SCHEDULES      0x00000020\n#define DB_RULES          0x00000040\n#define DB_SENSORS        0x00000080\n#define DB_USERPARAM      0x00000100\n#define DB_GATEWAYS       0x00000200\n#define DB_RESOURCELINKS  0x00000400\n#define DB_QUERY_QUEUE    0x00000800\n#define DB_SYNC           0x00001000\n#define DB_NOSAVE         0x00002000\n\n#define DB_HUGE_SAVE_DELAY  (60 * 60 * 1000) // 60 minutes\n#define DB_LONG_SAVE_DELAY  (15 * 60 * 1000) // 15 minutes\n#define DB_SHORT_SAVE_DELAY (1 *  60 * 1000) // 1 minute\n#define DB_FAST_SAVE_DELAY (1 * 1000) // 1 second\n\n#define DB_CONNECTION_TTL (60 * 15) // 15 minutes\n\n// internet discovery\n\n// network reconnect\n#define DISCONNECT_CHECK_DELAY 100\n#define NETWORK_ATTEMPS        10\n#define RECONNECT_CHECK_DELAY  5000\n#define RECONNECT_NOW          100\n\n//Epoch mode\n#define UNIX_EPOCH 0\n#define J2000_EPOCH 1\n\nvoid getTime(quint32 *time, qint32 *tz, quint32 *dstStart, quint32 *dstEnd, qint32 *dstShift, quint32 *standardTime, quint32 *localTime, quint8 mode);\nint getFreeSensorId(); // TODO needs to be part of a Database class\nint getFreeLightId();  // TODO needs to be part of a Database class\n\nextern const quint64 macPrefixMask;\n\nextern const quint64 celMacPrefix;\nextern const quint64 bjeMacPrefix;\nextern const quint64 davicomMacPrefix;\nextern const quint64 dlinkMacPrefix;\nextern const quint64 deMacPrefix;\nextern const quint64 emberMacPrefix;\nextern const quint64 embertecMacPrefix;\nextern const quint64 energyMiMacPrefix;\nextern const quint64 heimanMacPrefix;\nextern const quint64 zenMacPrefix;\nextern const quint64 silabs1MacPrefix;\nextern const quint64 ikea2MacPrefix;\nextern const quint64 silabsMacPrefix;\nextern const quint64 silabs2MacPrefix;\nextern const quint64 silabs3MacPrefix;\nextern const quint64 silabs4MacPrefix;\nextern const quint64 silabs5MacPrefix;\nextern const quint64 silabs6MacPrefix;\nextern const quint64 silabs7MacPrefix;\nextern const quint64 silabs8MacPrefix;\nextern const quint64 silabs9MacPrefix;\nextern const quint64 silabs10MacPrefix;\nextern const quint64 silabs11MacPrefix;\nextern const quint64 silabs12MacPrefix;\nextern const quint64 silabs13MacPrefix;\nextern const quint64 instaMacPrefix;\nextern const quint64 casaiaPrefix;\nextern const quint64 boschMacPrefix;\nextern const quint64 jennicMacPrefix;\nextern const quint64 lutronMacPrefix;\nextern const quint64 netvoxMacPrefix;\nextern const quint64 osramMacPrefix;\nextern const quint64 philipsMacPrefix;\nextern const quint64 sinopeMacPrefix;\nextern const quint64 stMacPrefix;\nextern const quint64 samjinMacPrefix;\nextern const quint64 tiMacPrefix;\nextern const quint64 ubisysMacPrefix;\nextern const quint64 xalMacPrefix;\nextern const quint64 onestiPrefix;\nextern const quint64 develcoMacPrefix;\nextern const quint64 legrandMacPrefix;\nextern const quint64 YooksmartMacPrefix;\nextern const quint64 profaluxMacPrefix;\nextern const quint64 xiaomiMacPrefix;\nextern const quint64 computimeMacPrefix;\nextern const quint64 konkeMacPrefix;\nextern const quint64 ecozyMacPrefix;\nextern const quint64 zhejiangMacPrefix;\nextern const quint64 schlageMacPrefix;\nextern const quint64 lumiMacPrefix;\n\ninline bool existDevicesWithVendorCodeForMacPrefix(quint64 addr, quint16 vendor)\n{\n    const quint64 prefix = addr & macPrefixMask;\n    switch (vendor) {\n        case VENDOR_XIAOMI:\n            return prefix == jennicMacPrefix ||\n                   prefix == xiaomiMacPrefix ||\n                   prefix == lumiMacPrefix;\n        case VENDOR_SINOPE:\n            return prefix == sinopeMacPrefix;\n        case VENDOR_HEIMAN:\n            return prefix == emberMacPrefix ||\n                   prefix == jennicMacPrefix;\n        case VENDOR_SUNRICHER:\n            return prefix == emberMacPrefix ||\n                   prefix == silabs3MacPrefix ||\n                   prefix == silabs6MacPrefix;\n        case VENDOR_3A_SMART_HOME:\n            return prefix == jennicMacPrefix;\n        case VENDOR_ADEO:\n            return prefix == emberMacPrefix ||\n                   prefix == silabs9MacPrefix ||\n                   prefix == konkeMacPrefix;\n        case VENDOR_ALERTME:\n            return prefix == tiMacPrefix ||\n                   prefix == computimeMacPrefix;\n        case VENDOR_BITRON:\n            return prefix == tiMacPrefix;\n        case VENDOR_BOSCH:\n            return prefix == boschMacPrefix ||\n                   prefix == emberMacPrefix;\n        case VENDOR_BUSCH_JAEGER:\n            return prefix == bjeMacPrefix;\n        case VENDOR_C2DF:\n            return prefix == emberMacPrefix;\n        case VENDOR_CENTRALITE:\n            return prefix == emberMacPrefix;\n        case VENDOR_CHINA_FIRE_SEC:\n            return prefix == jennicMacPrefix;\n        case VENDOR_DANFOSS:\n            return prefix == silabs2MacPrefix;\n        case VENDOR_EMBER:\n            return prefix == emberMacPrefix ||\n                   prefix == konkeMacPrefix ||\n                   prefix == silabs3MacPrefix ||\n                   prefix == silabs5MacPrefix ||\n                   prefix == silabs10MacPrefix ||\n                   prefix == silabs13MacPrefix ||\n                   prefix == silabs7MacPrefix;\n        case VENDOR_EMBERTEC:\n            return prefix == embertecMacPrefix;\n        case VENDOR_DDEL:\n            return prefix == deMacPrefix ||\n                   prefix == silabs3MacPrefix;\n        case VENDOR_IKEA:\n            return prefix == silabs1MacPrefix ||\n                   prefix == silabsMacPrefix ||\n                   prefix == silabs2MacPrefix ||\n                   prefix == silabs4MacPrefix ||\n                   prefix == energyMiMacPrefix ||\n                   prefix == emberMacPrefix;\n        case VENDOR_JASCO:\n            return prefix == celMacPrefix;\n        case VENDOR_INNR:\n            return prefix == jennicMacPrefix ||\n                   prefix == silabs4MacPrefix;\n        case VENDOR_LDS:\n            return prefix == jennicMacPrefix ||\n                   prefix == silabsMacPrefix ||\n                   prefix == silabs2MacPrefix;\n        case VENDOR_INSTA:\n            return prefix == instaMacPrefix;\n        case VENDOR_JENNIC:\n            return prefix == jennicMacPrefix;\n        case VENDOR_KEEN_HOME:\n            return prefix == celMacPrefix;\n        case VENDOR_LGE:\n            return prefix == emberMacPrefix;\n        case VENDOR_LUTRON:\n            return prefix == lutronMacPrefix;\n        case VENDOR_NIKO_NV:\n            return prefix == konkeMacPrefix;\n        case VENDOR_NYCE:\n            return prefix == emberMacPrefix;\n        case VENDOR_OSRAM:\n        case VENDOR_OSRAM_STACK:\n            return prefix == osramMacPrefix ||\n                   prefix == heimanMacPrefix;\n        case VENDOR_OWON:\n            return prefix == davicomMacPrefix;\n        case VENDOR_PHILIPS:\n            return prefix == philipsMacPrefix;\n        case VENDOR_PLUGWISE_BV:\n            return prefix == emberMacPrefix;\n        case VENDOR_PHYSICAL:\n            return prefix == stMacPrefix;\n        case VENDOR_SENGLED_OPTOELEC:\n            return prefix == zhejiangMacPrefix;\n        case VENDOR_SERCOMM:\n            return prefix == emberMacPrefix ||\n                   prefix == energyMiMacPrefix;\n        case VENDOR_SI_LABS:\n            return prefix == silabsMacPrefix ||\n                   prefix == energyMiMacPrefix ||\n                   prefix == silabs1MacPrefix;\n        case VENDOR_STELPRO:\n            return prefix == xalMacPrefix;\n        case VENDOR_UBISYS:\n            return prefix == ubisysMacPrefix;\n        case VENDOR_UNIVERSAL2:\n            return prefix == emberMacPrefix;\n        case VENDOR_VISONIC:\n            return prefix == emberMacPrefix;\n        case VENDOR_XAL:\n            return prefix == xalMacPrefix;\n        case VENDOR_SAMJIN:\n            return prefix == samjinMacPrefix;\n        case VENDOR_DEVELCO:\n            return prefix == develcoMacPrefix;\n        case VENDOR_LEGRAND:\n            return prefix == legrandMacPrefix;\n        case VENDOR_PROFALUX:\n            return prefix == profaluxMacPrefix;\n        case VENDOR_NETVOX:\n            return prefix == netvoxMacPrefix;\n        case VENDOR_AURORA:\n            return prefix == jennicMacPrefix;\n        case VENDOR_COMPUTIME:\n            return prefix == computimeMacPrefix;\n        case VENDOR_DANALOCK:\n            return prefix == silabs1MacPrefix;\n        case VENDOR_AXIS:\n        case VENDOR_MMB:\n            return prefix == zenMacPrefix;\n        case VENDOR_SCHLAGE:\n            return prefix == schlageMacPrefix;\n        case VENDOR_ADUROLIGHT:\n\t        return prefix == jennicMacPrefix;\n        case VENDOR_D_LINK:\n            return prefix == dlinkMacPrefix;\n        default:\n            return false;\n    }\n}\n\ninline bool existDevicesWithVendorCodeForMacPrefix(const deCONZ::Address &addr, quint16 vendor)\n{\n    return existDevicesWithVendorCodeForMacPrefix(addr.ext(), vendor);\n}\n\ninline bool checkMacAndVendor(const deCONZ::Node *node, quint16 vendor)\n{\n    return node->nodeDescriptor().manufacturerCode() == vendor && existDevicesWithVendorCodeForMacPrefix(node->address(), vendor);\n}\n\nquint8 zclNextSequenceNumber();\nconst deCONZ::Node *getCoreNode(uint64_t extAddress);\n\n// Forward declarations\nclass DeviceDescriptions;\nclass DeviceWidget;\nclass DeviceJs;\nclass Gateway;\nclass GatewayScanner;\nclass QUdpSocket;\nclass QTcpSocket;\nclass DeRestPlugin;\nclass QHostInfo;\nclass QNetworkReply;\nclass QNetworkAccessManager;\nclass QProcess;\nclass PollManager;\nclass RestDevices;\n\nstruct Schedule\n{\n    enum Week\n    {\n        Monday    = 0x01,\n        Tuesday   = 0x02,\n        Wednesday = 0x04,\n        Thursday  = 0x08,\n        Friday    = 0x10,\n        Saturday  = 0x20,\n        Sunday    = 0x40,\n    };\n\n    enum Type\n    {\n        TypeInvalid,\n        TypeAbsoluteTime,\n        TypeRecurringTime,\n        TypeTimer\n    };\n\n    enum State\n    {\n        StateNormal,\n        StateDeleted\n    };\n\n    Schedule() :\n        type(TypeInvalid),\n        state(StateNormal),\n        status(QLatin1String(\"enabled\")),\n        activation(QLatin1String(\"start\")),\n        autodelete(true),\n        weekBitmap(0),\n        recurring(0),\n        timeout(0),\n        currentTimeout(0)\n    {\n    }\n\n    Type type;\n    State state;\n    /*! Numeric identifier as string. */\n    QString id;\n    /*! etag of Schedule. */\n    QString etag;\n    /*! Name length 0..32, if 0 default name \"schedule\" will be used. (Optional) */\n    QString name;\n    /*! Description length 0..64, default is empty string. (Optional) */\n    QString description;\n    /*! Command a JSON object with length 0..90. (Required) */\n    QString command;\n    /*! Time is given in ISO 8601:2004 format: YYYY-MM-DDTHH:mm:ss. (Required) */\n    QString time;\n    /*! Localtime is given in ISO 8601:2004 format: YYYY-MM-DDTHH:mm:ss. (Optional) */\n    QString localtime;\n    /*! UTC time that the timer was started. Only provided for timers. */\n    QString starttime;\n    /*! status of schedule (enabled or disabled). */\n    QString status;\n    /*! should activation of schedule start or end at given time (if a fading time is given) (start or end). */\n    QString activation;\n    /*! If set to true, the schedule will be removed automatically if expired, if set to false it will be disabled. */\n    bool autodelete;\n    /*! Same as time but as qt object. */\n    QDateTime datetime;\n    /*! Date time of last schedule activation. */\n    QDateTime lastTriggerDatetime;\n    /*! Whole JSON schedule as received from API as string. */\n    QString jsonString;\n    /*! Whole JSON schedule as received from API as map. */\n    QVariantMap jsonMap;\n    /*! Bitmap for recurring schedule. */\n    quint8 weekBitmap;\n    /*! R[nn], the recurring part, 0 means forever. */\n    uint recurring;\n    QDateTime endtime; /*! Localtime of timeout: for timers only. */\n    /*! Timeout in seconds. */\n    int timeout;\n    /*! Current timeout counting down to ::timeout. */\n    int currentTimeout;\n};\n\nenum TaskType\n{\n    TaskIdentify = 0,\n    TaskGetHue = 1,\n    TaskSetHue = 2,\n    TaskSetEnhancedHue = 3,\n    TaskSetHueAndSaturation = 4,\n    TaskSetXyColor = 5,\n    TaskSetColorTemperature = 6,\n    TaskGetColor = 7,\n    TaskGetSat = 8,\n    TaskSetSat = 9,\n    TaskGetLevel = 10,\n    TaskSetLevel = 11,\n    TaskIncColorTemperature = 12,\n    TaskStopLevel = 13,\n    TaskSendOnOffToggle = 14,\n    TaskMoveLevel = 15,\n    TaskGetOnOff = 16,\n    TaskSetColorLoop = 17,\n    TaskGetColorLoop = 18,\n    TaskReadAttributes = 19,\n    TaskWriteAttribute = 20,\n    TaskGetGroupMembership = 21,\n    TaskGetGroupIdentifiers = 22,\n    TaskGetSceneMembership = 23,\n    TaskStoreScene = 24,\n    TaskCallScene = 25,\n    TaskViewScene = 26,\n    TaskAddScene = 27,\n    TaskRemoveScene = 28,\n    TaskRemoveAllScenes = 29,\n    TaskAddToGroup = 30,\n    TaskRemoveFromGroup = 31,\n    TaskViewGroup = 32,\n    TaskTriggerEffect = 33,\n    TaskWarning = 34,\n    TaskIncBrightness = 35,\n    TaskWindowCovering = 36,\n    TaskThermostat = 37,\n    TaskDoorLock = 38, // Danalock support\n    TaskHueGradient = 45,\n    TaskSyncTime = 40,\n    TaskTuyaRequest = 41,\n    TaskXmasLightStrip = 42,\n    TaskSimpleMetering = 43,\n    TaskHueEffect = 44\n};\n\nenum XmasLightStripMode\n{\n    ModeWhite = 0,\n    ModeColour = 1,\n    ModeEffect = 2\n};\n\nenum XmasLightStripEffect\n{\n    EffectSteady = 0x00,\n    EffectSnow = 0x01,\n    EffectRainbow = 0x02,\n    EffectSnake = 0x03,\n    EffectTwinkle = 0x04,\n    EffectFireworks = 0x05,\n    EffectFlag = 0x06,\n    EffectWaves = 0x07,\n    EffectUpdown = 0x08,\n    EffectVintage = 0x09,\n    EffectFading = 0x0a,\n    EffectCollide = 0x0b,\n    EffectStrobe = 0x0c,\n    EffectSparkles = 0x0d,\n    EffectCarnaval = 0x0e,\n    EffectGlow = 0x0f\n};\n\nstruct TaskItem\n{\n    TaskItem()\n    {\n        taskId = _taskCounter++;\n        autoMode = false;\n        onOff = false;\n        client = 0;\n        node = 0;\n        lightNode = 0;\n        cluster = 0;\n        colorX = 0;\n        colorY = 0;\n        colorTemperature = 0;\n        transitionTime = DEFAULT_TRANSITION_TIME;\n        onTime = 0;\n        sendTime = 0;\n        ordered = false;\n    }\n\n    TaskType taskType;\n    int taskId;\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame zclFrame;\n    uint8_t zclSeq;\n    bool ordered; // won't be send until al prior taskIds are send\n    int sendTime; // copy of idleTotalCounter\n    bool confirmed;\n    bool onOff;\n    bool colorLoop;\n    qreal hueReal;\n    uint16_t identifyTime;\n    uint8_t effectIdentifier;\n    uint8_t options;\n    uint16_t duration;\n    uint8_t hue;\n    uint8_t sat;\n    uint8_t level;\n    uint16_t enhancedHue;\n    uint16_t colorX;\n    uint16_t colorY;\n    uint16_t colorTemperature;\n    uint16_t groupId;\n    uint8_t sceneId;\n    qint32 inc; // bri_inc, hue_inc, sat_inc, ct_inc\n    QString etag;\n    uint16_t transitionTime;\n    uint16_t onTime;\n    QTcpSocket *client;\n\n    bool autoMode; // true then this is a automode task\n    deCONZ::Node *node;\n    LightNode *lightNode;\n    deCONZ::ZclCluster *cluster;\n\nprivate:\n    static int _taskCounter;\n};\n\n/*! \\class ApiAuth\n\n    Helper to combine serval authorisation parameters.\n */\nclass ApiAuth\n{\npublic:\n    enum State\n    {\n        StateNormal,\n        StateDeleted\n    };\n\n    ApiAuth();\n    void setDeviceType(const QString &devtype);\n\n    bool needSaveDatabase;\n    State state;\n    QString apikey; // also called username (10..32 chars)\n    QString devicetype;\n    QDateTime createDate;\n    QDateTime lastUseDate;\n    QString useragent;\n};\n\n/*! \\class ApiConfig\n\n    Provide config to the resource system.\n */\nclass ApiConfig : public Resource\n{\npublic:\n    ApiConfig();\n};\n\nclass TcpClient\n{\npublic:\n    int closeTimeout; // close socket in n seconds\n    QTcpSocket *sock;\n};\n\n/*! \\class DeWebPluginPrivate\n\n    Pimpl of DeWebPlugin.\n */\nclass DeRestPluginPrivate : public QObject\n{\n    Q_OBJECT\n\npublic:\n\n    struct nodeVisited {\n        const deCONZ::Node* node;\n        bool visited;\n    };\n\n    DeRestPluginPrivate(QObject *parent = 0);\n    ~DeRestPluginPrivate();\n\n    static DeRestPluginPrivate *instance();\n\n    // REST API authorisation\n    void initAuthentication();\n    bool allowedToCreateApikey(const ApiRequest &req, ApiResponse &rsp, QVariantMap &map);\n    void authorise(ApiRequest &req, ApiResponse &rsp);\n\n    // REST API gateways\n    int handleGatewaysApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllGateways(const ApiRequest &req, ApiResponse &rsp);\n    int getGatewayState(const ApiRequest &req, ApiResponse &rsp);\n    int setGatewayState(const ApiRequest &req, ApiResponse &rsp);\n    int addCascadeGroup(const ApiRequest &req, ApiResponse &rsp);\n    int deleteCascadeGroup(const ApiRequest &req, ApiResponse &rsp);\n    void gatewayToMap(const ApiRequest &req, const Gateway *gw, QVariantMap &map);\n\n    // REST API configuration\n    void initConfig();\n    int handleConfigBasicApi(const ApiRequest &req, ApiResponse &rsp);\n    int handleConfigLocalApi(const ApiRequest &req, ApiResponse &rsp);\n    int handleConfigFullApi(const ApiRequest &req, ApiResponse &rsp);\n    int createUser(const ApiRequest &req, ApiResponse &rsp);\n    int getFullState(const ApiRequest &req, ApiResponse &rsp);\n    int getConfig(const ApiRequest &req, ApiResponse &rsp);\n    int getBasicConfig(const ApiRequest &req, ApiResponse &rsp);\n    int getZigbeeConfig(const ApiRequest &req, ApiResponse &rsp);\n    int putZigbeeConfig(const ApiRequest &req, ApiResponse &rsp);\n    int getChallenge(const ApiRequest &req, ApiResponse &rsp);\n    int modifyConfig(const ApiRequest &req, ApiResponse &rsp);\n    int deleteUser(const ApiRequest &req, ApiResponse &rsp);\n    int updateSoftware(const ApiRequest &req, ApiResponse &rsp);\n    int restartGateway(const ApiRequest &req, ApiResponse &rsp);\n    int restartApp(const ApiRequest &req, ApiResponse &rsp);\n    int shutDownGateway(const ApiRequest &req, ApiResponse &rsp);\n    int updateFirmware(const ApiRequest &req, ApiResponse &rsp);\n    int exportConfig(const ApiRequest &req, ApiResponse &rsp);\n    int importConfig(const ApiRequest &req, ApiResponse &rsp);\n    int resetConfig(const ApiRequest &req, ApiResponse &rsp);\n    int changePassword(const ApiRequest &req, ApiResponse &rsp);\n    int deletePassword(const ApiRequest &req, ApiResponse &rsp);\n    int getWifiState(const ApiRequest &req, ApiResponse &rsp);\n    int configureWifi(const ApiRequest &req, ApiResponse &rsp);\n    int restoreWifiConfig(const ApiRequest &req, ApiResponse &rsp);\n    int putWifiScanResult(const ApiRequest &req, ApiResponse &rsp);\n    int putWifiUpdated(const ApiRequest &req, ApiResponse &rsp);\n    int putHomebridgeUpdated(const ApiRequest &req, ApiResponse &rsp);\n\n    void configToMap(const ApiRequest &req, QVariantMap &map);\n    void basicConfigToMap(const ApiRequest &req, QVariantMap &map);\n\n    // REST API userparameter\n    int handleUserparameterApi(const ApiRequest &req, ApiResponse &rsp);\n    int createUserParameter(const ApiRequest &req, ApiResponse &rsp);\n    int addUserParameter(const ApiRequest &req, ApiResponse &rsp);\n    int modifyUserParameter(const ApiRequest &req, ApiResponse &rsp);\n    int getUserParameter(const ApiRequest &req, ApiResponse &rsp);\n    int getAllUserParameter(const ApiRequest &req, ApiResponse &rsp);\n    int deleteUserParameter(const ApiRequest &req, ApiResponse &rsp);\n\n    // REST API lights\n    int handleLightsApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllLights(const ApiRequest &req, ApiResponse &rsp);\n    int searchNewLights(const ApiRequest &req, ApiResponse &rsp);\n    int getNewLights(const ApiRequest &req, ApiResponse &rsp);\n    int getLightData(const ApiRequest &req, ApiResponse &rsp);\n    int getLightState(const ApiRequest &req, ApiResponse &rsp);\n    int setLightState(const ApiRequest &req, ApiResponse &rsp);\n    int setLightConfig(const ApiRequest &req, ApiResponse &rsp);\n    int setWindowCoveringState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map);\n    int setWarningDeviceState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map);\n    int setTuyaDeviceState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map);\n    int setDoorLockState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map);\n    int setLightAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int deleteLight(const ApiRequest &req, ApiResponse &rsp);\n    int removeAllScenes(const ApiRequest &req, ApiResponse &rsp);\n    int removeAllGroups(const ApiRequest &req, ApiResponse &rsp);\n    void handleLightEvent(const Event &e);\n\n    bool lightToMap(const ApiRequest &req, const LightNode *webNode, QVariantMap &map);\n\n    // REST API groups\n    int handleGroupsApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllGroups(const ApiRequest &req, ApiResponse &rsp);\n    int createGroup(const ApiRequest &req, ApiResponse &rsp);\n    int getGroupAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int setGroupAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int setGroupState(const ApiRequest &req, ApiResponse &rsp);\n    int deleteGroup(const ApiRequest &req, ApiResponse &rsp);\n    void handleGroupEvent(const Event &e);\n    Group *addGroup();\n\n    // REST API groups > scenes\n    int createScene(const ApiRequest &req, ApiResponse &rsp);\n    int getAllScenes(const ApiRequest &req, ApiResponse &rsp);\n    int getSceneAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int setSceneAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int storeScene(const ApiRequest &req, ApiResponse &rsp);\n    int recallScene(const ApiRequest &req, ApiResponse &rsp);\n    int modifyScene(const ApiRequest &req, ApiResponse &rsp);\n    int deleteScene(const ApiRequest &req, ApiResponse &rsp);\n\n    bool groupToMap(const ApiRequest &req, const Group *group, QVariantMap &map);\n\n    // REST API schedules\n    void initSchedules();\n    int handleSchedulesApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllSchedules(const ApiRequest &req, ApiResponse &rsp);\n    int createSchedule(const ApiRequest &req, ApiResponse &rsp);\n    int getScheduleAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int setScheduleAttributes(const ApiRequest &req, ApiResponse &rsp);\n    int deleteSchedule(const ApiRequest &req, ApiResponse &rsp);\n    bool jsonToSchedule(const QString &jsonString, Schedule &schedule, ApiResponse *rsp);\n\n    // REST API touchlink\n    void initTouchlinkApi();\n    int handleTouchlinkApi(const ApiRequest &req, ApiResponse &rsp);\n    int touchlinkScan(const ApiRequest &req, ApiResponse &rsp);\n    int getTouchlinkScanResults(const ApiRequest &req, ApiResponse &rsp);\n    int identifyLight(const ApiRequest &req, ApiResponse &rsp);\n    int resetLight(const ApiRequest &req, ApiResponse &rsp);\n\n    // REST API sensors\n    int handleSensorsApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllSensors(const ApiRequest &req, ApiResponse &rsp);\n    int getSensor(const ApiRequest &req, ApiResponse &rsp);\n    int getSensorData(const ApiRequest &req, ApiResponse &rsp);\n    int searchNewSensors(const ApiRequest &req, ApiResponse &rsp);\n    int getNewSensors(const ApiRequest &req, ApiResponse &rsp);\n    int updateSensor(const ApiRequest &req, ApiResponse &rsp);\n    int deleteSensor(const ApiRequest &req, ApiResponse &rsp);\n    int changeSensorConfig(const ApiRequest &req, ApiResponse &rsp);\n    int changeSensorState(const ApiRequest &req, ApiResponse &rsp);\n    int changeThermostatSchedule(const ApiRequest &req, ApiResponse &rsp);\n    int createSensor(const ApiRequest &req, ApiResponse &rsp);\n    int getGroupIdentifiers(const ApiRequest &req, ApiResponse &rsp);\n    int recoverSensor(const ApiRequest &req, ApiResponse &rsp);\n    bool sensorToMap(const Sensor *sensor, QVariantMap &map, const ApiRequest &req);\n    void handleSensorEvent(const Event &e);\n\n    // REST API resourcelinks\n    int handleResourcelinksApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllResourcelinks(const ApiRequest &req, ApiResponse &rsp);\n    int getResourcelinks(const ApiRequest &req, ApiResponse &rsp);\n    int createResourcelinks(const ApiRequest &req, ApiResponse &rsp);\n    int updateResourcelinks(const ApiRequest &req, ApiResponse &rsp);\n    int deleteResourcelinks(const ApiRequest &req, ApiResponse &rsp);\n\n    // REST API rules\n    int handleRulesApi(const ApiRequest &req, ApiResponse &rsp);\n    int getAllRules(const ApiRequest &req, ApiResponse &rsp);\n    int getRule(const ApiRequest &req, ApiResponse &rsp);\n    int createRule(const ApiRequest &req, ApiResponse &rsp);\n    int updateRule(const ApiRequest &req, ApiResponse &rsp);\n    int deleteRule(const ApiRequest &req, ApiResponse &rsp);\n    bool evaluateRule(Rule &rule, const Event &e, Resource *eResource, ResourceItem *eItem, QDateTime now, QDateTime previousNow);\n    void indexRuleTriggers(Rule &rule);\n    void triggerRule(Rule &rule);\n    bool ruleToMap(const Rule *rule, QVariantMap &map);\n    int handleWebHook(const RuleAction &action);\n\n    bool checkActions(QVariantList actionsList, ApiResponse &rsp);\n    bool checkConditions(QVariantList conditionsList, ApiResponse &rsp);\n\n    // REST API scenes\n    int handleScenesApi(const ApiRequest &req, ApiResponse &rsp);\n\n    // REST API info\n    int handleInfoApi(const ApiRequest &req, ApiResponse &rsp);\n    int getInfoTimezones(const ApiRequest &req, ApiResponse &rsp);\n\n    // REST API capabilities\n    int handleCapabilitiesApi(const ApiRequest &req, ApiResponse &rsp);\n    int getCapabilities(const ApiRequest &req, ApiResponse &rsp);\n\n    // UPNP discovery\n    void initUpnpDiscovery();\n    void initDescriptionXml();\n    // Internet discovery\n    void initInternetDicovery();\n    bool setInternetDiscoveryInterval(int minutes);\n    // Permit join\n    void initPermitJoin();\n    void setPermitJoinDuration(int duration);\n\n    // Otau\n    void initOtau();\n    void otauDataIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, Device *device);\n    bool isOtauBusy();\n    bool isOtauActive();\n    int otauLastBusyTimeDelta() const;\n\n    //Channel Change\n    void initChangeChannelApi();\n    bool startChannelChange(quint8 channel);\n\n    //reset Device\n    void initResetDeviceApi();\n\n    //Timezone\n    QVariantList getTimezones();\n\nQ_SIGNALS:\n    void eventNotify(const Event&);\n\npublic Q_SLOTS:\n    Resource *getResource(const char *resource, const QString &id = QString());\n    void announceUpnp();\n    void upnpReadyRead();\n    void apsdeDataIndicationDevice(const deCONZ::ApsDataIndication &ind, Device *device);\n    void apsdeDataIndication(const deCONZ::ApsDataIndication &ind);\n    void apsdeDataConfirm(const deCONZ::ApsDataConfirm &conf);\n    void apsdeDataRequestEnqueued(const deCONZ::ApsDataRequest &req);\n    void gpDataIndication(const deCONZ::GpDataIndication &ind);\n    void gpProcessButtonEvent(const deCONZ::GpDataIndication &ind);\n    void configurationChanged();\n    void networkStateChangeRequest(bool shouldConnect);\n    int taskCountForAddress(const deCONZ::Address &address);\n    void processTasks();\n    void processGroupTasks();\n    void nodeEvent(const deCONZ::NodeEvent &event);\n    void initTimezone();\n    void initNetworkInfo();\n    void initWiFi();\n    void internetDiscoveryTimerFired();\n    void internetDiscoveryFinishedRequest(QNetworkReply *reply);\n    void internetDiscoveryExtractVersionInfo(QNetworkReply *reply);\n    void internetDiscoveryExtractGeo(QNetworkReply *reply);\n    void inetProxyHostLookupDone(const QHostInfo &host);\n    void inetProxyCheckHttpVia(const QString &via);\n    void scheduleTimerFired();\n    void permitJoin(int seconds);\n    void permitJoinTimerFired();\n    void otauTimerFired();\n    void lockGatewayTimerFired();\n    void openClientTimerFired();\n    void clientSocketDestroyed();\n    void saveDatabaseTimerFired();\n    void userActivity();\n    bool sendBindRequest(BindingTask &bt);\n    bool sendConfigureReportingRequest(BindingTask &bt, const std::vector<ConfigureReportingRequest> &requests);\n    bool sendConfigureReportingRequest(BindingTask &bt);\n    void checkLightBindingsForAttributeReporting(LightNode *lightNode);\n    bool checkPollControlClusterTask(Sensor *sensor);\n    bool checkSensorBindingsForAttributeReporting(Sensor *sensor);\n    bool checkSensorBindingsForClientClusters(Sensor *sensor);\n    void checkSensorGroup(Sensor *sensor);\n    void checkOldSensorGroups(Sensor *sensor);\n    void deleteGroupsWithDeviceMembership(const QString &id);\n    void bindingTimerFired();\n    void bindingTableReaderTimerFired();\n    void indexRulesTriggers();\n    void fastRuleCheckTimerFired();\n    void webhookFinishedRequest(QNetworkReply *reply);\n    void daylightTimerFired();\n    bool checkDaylightSensorConfiguration(Sensor *sensor, const QString &gwBridgeId, double *lat, double *lng);\n    size_t calcDaylightOffsets(Sensor *daylightSensor, size_t iter);\n    void handleRuleEvent(const Event &e);\n    bool queueBindingTask(const BindingTask &bindingTask);\n    void restartAppTimerFired();\n    void pollSwUpdateStateTimerFired();\n    void pollDatabaseWifiTimerFired();\n    void restartGatewayTimerFired();\n    void shutDownGatewayTimerFired();\n    void simpleRestartAppTimerFired();\n    void pushSensorInfoToCore(Sensor *sensor);\n    void pollNextDevice();\n\n    // database\n    void storeSourceRoute(const deCONZ::SourceRoute &sourceRoute);\n    void deleteSourceRoute(const QString &uuid);\n    void restoreSourceRoutes();\n\n    // touchlink\n    void touchlinkDisconnectNetwork();\n    void checkTouchlinkNetworkDisconnected();\n    void startTouchlinkMode(uint8_t channel);\n    void startTouchlinkModeConfirm(deCONZ::TouchlinkStatus status);\n    void sendTouchlinkConfirm(deCONZ::TouchlinkStatus status);\n    void sendTouchlinkScanRequest();\n    void sendTouchlinkIdentifyRequest();\n    void sendTouchlinkResetRequest();\n    void touchlinkTimerFired();\n    void touchlinkScanTimeout();\n    void interpanDataIndication(const QByteArray &data);\n    void touchlinkStartReconnectNetwork(int delay);\n    void touchlinkReconnectNetwork();\n    bool isTouchlinkActive();\n\n    // channel change\n    void channelchangeTimerFired();\n    void changeChannel(quint8 channel);\n    bool verifyChannel(quint8 channel);\n    void channelChangeSendConfirm(bool success);\n    void channelChangeDisconnectNetwork();\n    void checkChannelChangeNetworkDisconnected();\n    void channelChangeStartReconnectNetwork(int delay);\n    void channelChangeReconnectNetwork();\n    void networkWatchdogTimerFired();\n\n    // generic reconnect network\n    void reconnectTimerFired();\n    void genericDisconnectNetwork();\n    void checkNetworkDisconnected();\n    void startReconnectNetwork(int delay);\n    void reconnectNetwork();\n\n    //reset device\n    void resetDeviceTimerFired();\n    void checkResetState();\n    void resetDeviceSendConfirm(bool success);\n\n    // lights\n    void startSearchLights();\n    void searchLightsTimerFired();\n\n    // sensors\n    void startSearchSensors();\n    void searchSensorsTimerFired();\n    void checkInstaModelId(Sensor *sensor);\n    void delayedFastEnddeviceProbe(const deCONZ::NodeEvent *event = nullptr);\n    void checkSensorStateTimerFired();\n\n    // events\n    void handleEvent(const Event &e);\n\n    // firmware update\n    void initFirmwareUpdate();\n    void firmwareUpdateTimerFired();\n    void checkFirmwareDevices();\n    void queryFirmwareVersion();\n    void updateFirmwareDisconnectDevice();\n    void updateFirmware();\n    void updateFirmwareWaitFinished();\n    bool startUpdateFirmware();\n\n    //wifi settings\n    int scanWifiNetworks(const ApiRequest &req, ApiResponse &rsp);\n    void wifiPageActiveTimerFired();\n\n    //homebridge\n    int resetHomebridge(const ApiRequest &req, ApiResponse &rsp);\n\n    // time manager\n    void timeManagerTimerFired();\n    void ntpqFinished();\n\n    // gateways\n    void foundGateway(const QHostAddress &host, quint16 port, const QString &uuid, const QString &name);\n\n    // window covering\n    void calibrateWindowCoveringNextStep();\n\n    // thermostat\n    void addTaskThermostatGetScheduleTimer();\n\npublic:\n    void checkRfConnectState();\n    bool isInNetwork();\n    void generateGatewayUuid();\n    void updateEtag(QString &etag);\n    qint64 getUptime();\n    void handleMacDataRequest(const deCONZ::NodeEvent &event);\n    void addLightNode(const deCONZ::Node *node);\n    void setLightNodeStaticCapabilities(LightNode *lightNode);\n    void updatedLightNodeEndpoint(const deCONZ::NodeEvent &event);\n    void nodeZombieStateChanged(const deCONZ::Node *node);\n    LightNode *updateLightNode(const deCONZ::NodeEvent &event);\n    LightNode *getLightNodeForAddress(const deCONZ::Address &addr, quint8 endpoint = 0);\n    int getNumberOfEndpoints(quint64 extAddr);\n    LightNode *getLightNodeForId(const QString &id);\n    Rule *getRuleForId(const QString &id);\n    Rule *getRuleForName(const QString &name);\n    void addSensorNode(const deCONZ::Node *node, const deCONZ::NodeEvent *event = 0);\n    void addSensorNode(const deCONZ::Node *node, const SensorFingerprint &fingerPrint, const QString &type, const QString &modelId, const QString &manufacturer);\n    void checkSensorNodeReachable(Sensor *sensor, const deCONZ::NodeEvent *event = 0);\n    void checkSensorButtonEvent(Sensor *sensor, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    void updateSensorNode(const deCONZ::NodeEvent &event);\n    void updateSensorLightLevel(Sensor &sensor, quint16 measuredValue);\n    bool isDeviceSupported(const deCONZ::Node *node, const QString &modelId);\n    Sensor *getSensorNodeForAddressEndpointAndCluster(const deCONZ::Address &addr, quint8 ep, quint16 cluster);\n    Sensor *getSensorNodeForAddressAndEndpoint(const deCONZ::Address &addr, quint8 ep, const QString &type);\n    Sensor *getSensorNodeForAddressAndEndpoint(const deCONZ::Address &addr, quint8 ep);\n    Sensor *getSensorNodeForAddress(quint64 extAddr);\n    Sensor *getSensorNodeForAddress(const deCONZ::Address &addr);\n    Sensor *getSensorNodeForFingerPrint(quint64 extAddr, const SensorFingerprint &fingerPrint, const QString &type);\n    Sensor *getSensorNodeForUniqueId(const QString &uniqueId);\n    Sensor *getSensorNodeForId(const QString &id);\n    Group *getGroupForName(const QString &name);\n    Group *getGroupForId(uint16_t id);\n    Group *getGroupForId(const QString &id);\n    bool deleteOldGroupOfSwitch(Sensor *sensor, quint16 newGroupId);\n    Scene *getSceneForId(uint16_t gid, uint8_t sid);\n    GroupInfo *getGroupInfo(LightNode *lightNode, uint16_t id);\n    GroupInfo *createGroupInfo(LightNode *lightNode, uint16_t id);\n    deCONZ::Node *getNodeForAddress(uint64_t extAddr);\n    deCONZ::ZclCluster *getInCluster(deCONZ::Node *node, uint8_t endpoint, uint16_t clusterId);\n    uint8_t getSrcEndpoint(RestNodeBase *restNode, const deCONZ::ApsDataRequest &req);\n    bool processZclAttributes(LightNode *lightNode);\n    bool processZclAttributes(Sensor *sensorNode);\n    bool readBindingTable(RestNodeBase *node, quint8 startIndex);\n    bool getGroupIdentifiers(RestNodeBase *node, quint8 endpoint, quint8 startIndex);\n    bool readAttributes(RestNodeBase *restNode, quint8 endpoint, uint16_t clusterId, const std::vector<uint16_t> &attributes, uint16_t manufacturerCode = 0);\n    bool writeAttribute(RestNodeBase *restNode, quint8 endpoint, uint16_t clusterId, const deCONZ::ZclAttribute &attribute, uint16_t manufacturerCode = 0);\n    bool readSceneAttributes(LightNode *lightNode, uint16_t groupId, uint8_t sceneId);\n    bool readGroupMembership(LightNode *lightNode, const std::vector<uint16_t> &groups);\n    void foundGroupMembership(LightNode *lightNode, uint16_t groupId);\n    void foundGroup(uint16_t groupId);\n    bool isLightNodeInGroup(const LightNode *lightNode, uint16_t groupId) const;\n    void deleteLightFromScenes(QString lightId, uint16_t groupId);\n//    void readAllInGroup(Group *group);\n    void setAttributeOnOffGroup(Group *group, uint8_t onOff);\n    bool readSceneMembership(LightNode *lightNode, Group *group);\n    void foundScene(LightNode *lightNode, Group *group, uint8_t sceneId);\n    void setSceneName(Group *group, uint8_t sceneId, const QString &name);\n    bool storeScene(Group *group, uint8_t sceneId);\n    bool modifyScene(Group *group, uint8_t sceneId);\n    bool removeScene(Group *group, uint8_t sceneId);\n    bool callScene(Group *group, uint8_t sceneId);\n    bool removeAllScenes(Group *group);\n    void storeRecoverOnOffBri(LightNode *lightNode);\n    bool flsNbMaintenance(LightNode *lightNode);\n    bool pushState(QString json, QTcpSocket *sock);\n    void patchNodeDescriptor(const deCONZ::ApsDataIndication &ind);\n    bool writeIasCieAddress(Sensor*);\n    void checkIasEnrollmentStatus(Sensor*);\n    void processIasZoneStatus(Sensor *sensor, quint16 zoneStatus, NodeValue::UpdateType updateType);\n\n    void pushClientForClose(QTcpSocket *sock, int closeTimeout);\n\n    uint8_t endpoint();\n\n    // Task interface\n    bool addTask(const TaskItem &task);\n    bool addTaskMoveLevel(TaskItem &task, bool withOnOff, bool upDirection, quint8 rate);\n    bool addTaskSetOnOff(TaskItem &task, quint8 cmd, quint16 ontime, quint8 flags = 0);\n    bool addTaskSetBrightness(TaskItem &task, uint8_t bri, bool withOnOff);\n    bool addTaskIncColorTemperature(TaskItem &task, int32_t ct);\n    bool addTaskIncBrightness(TaskItem &task, int16_t bri);\n    bool addTaskSetColorTemperature(TaskItem &task, uint16_t ct);\n    bool addTaskSetEnhancedHue(TaskItem &task, uint16_t hue);\n    bool addTaskSetSaturation(TaskItem &task, uint8_t sat);\n    bool addTaskSetHueAndSaturation(TaskItem &task, uint8_t hue, uint8_t sat);\n    bool addTaskSetXyColorAsHueAndSaturation(TaskItem &task, double x, double y);\n    bool addTaskSetXyColor(TaskItem &task, double x, double y);\n    bool addTaskSetColorLoop(TaskItem &task, bool colorLoopActive, uint8_t speed);\n    bool addTaskIdentify(TaskItem &task, uint16_t identifyTime);\n    bool addTaskTriggerEffect(TaskItem &task, uint8_t effectIdentifier);\n    bool addTaskWarning(TaskItem &task, uint8_t options, uint16_t duration);\n    // Danalock support. To control the lock from the REST API, you need to create a new routine addTaskDoorLock() in zcl_tasks.cpp, cf. the addTaskWarning() I created to control the Siren.\n    bool addTaskDoorLockUnlock(TaskItem &task, uint8_t cmd);\n    bool addTaskAddToGroup(TaskItem &task, uint16_t groupId);\n    bool addTaskViewGroup(TaskItem &task, uint16_t groupId);\n    bool addTaskRemoveFromGroup(TaskItem &task, uint16_t groupId);\n    bool addTaskStoreScene(TaskItem &task, uint16_t groupId, uint8_t sceneId);\n    bool addTaskAddEmptyScene(TaskItem &task, quint16 groupId, quint8 sceneId, quint16 transitionTime);\n    bool addTaskAddScene(TaskItem &task, uint16_t groupId, uint8_t sceneId, const QString &lightId);\n    bool addTaskRemoveScene(TaskItem &task, uint16_t groupId, uint8_t sceneId);\n    bool addTaskWindowCovering(TaskItem &task, uint8_t cmdId, uint16_t pos, uint8_t pct);\n    bool addTaskWindowCoveringSetAttr(TaskItem &task, uint16_t mfrCode, uint16_t attrId, uint8_t attrType, uint16_t attrValue);\n    bool addTaskWindowCoveringCalibrate(TaskItem &task, int WindowCoveringType);\n    bool addTaskThermostatCmd(TaskItem &task, uint16_t mfrCode, uint8_t cmd, int16_t setpoint, uint8_t daysToReturn);\n    bool addTaskThermostatGetSchedule(TaskItem &task);\n    bool addTaskThermostatSetWeeklySchedule(TaskItem &task, quint8 weekdays, const QString &transitions);\n    void updateThermostatSchedule(Sensor *sensor, quint8 newWeekdays, QString &transitions);\n    bool addTaskThermostatReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t mfrCode, uint16_t attrId, uint8_t attrType, int attrValue);\n    bool addTaskThermostatWriteAttributeList(TaskItem &task, uint16_t mfrCode, QMap<quint16, quint32> &AttributeList );\n    bool addTaskControlModeCmd(TaskItem &task, uint8_t cmdId, int8_t mode);\n    bool addTaskSyncTime(Sensor *sensor);\n    bool addTaskThermostatUiConfigurationReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode=0);\n    bool addTaskFanControlReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode=0);\n    bool addTaskSimpleMeteringReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode=0);\n\n    // Advanced features of Hue lights.\n    QStringList getHueEffectNames(quint64 effectBitmap, bool colorloop);\n    QStringList getHueGradientStyleNames(quint16 styleBitmap);\n    bool addTaskHueEffect(TaskItem &task, QString &effect);\n    bool validateHueGradient(const ApiRequest &req, ApiResponse &rsp, QVariantMap &gradient, quint16 styleBitmap);\n    bool addTaskHueGradient(TaskItem &task, QVariantMap &gradient);\n\n    // Merry Christmas!\n    bool isXmasLightStrip(const LightNode *lightNode);\n    bool addTaskXmasLightStripOn(TaskItem &task, bool on);\n    bool addTaskXmasLightStripMode(TaskItem &task, XmasLightStripMode mode);\n    bool addTaskXmasLightStripWhite(TaskItem &task, quint8 bri);\n    bool addTaskXmasLightStripColour(TaskItem &task, quint16 hue, quint8 sat, quint8 bri);\n    bool addTaskXmasLightStripEffect(TaskItem &task, XmasLightStripEffect effect, quint8 speed, const QList<QList<quint8> > &colours);\n    int setXmasLightStripState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map);\n\n    void handleGroupClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleSceneClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleOnOffClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleClusterIndicationGateways(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleIasZoneClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    bool sendIasZoneEnrollResponse(Sensor *sensor);\n    bool sendIasZoneEnrollResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleIndicationSearchSensors(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    bool sendTuyaRequest(TaskItem &task, TaskType taskType, qint8 Dp_type, qint8 Dp_identifier, const QByteArray &data);\n    bool sendTuyaRequest(deCONZ::Address srcAddress, quint8 srcEndpoint, qint8 Dp_type, qint8 Dp_identifier, const QByteArray &data);\n    bool sendTuyaCommand(const deCONZ::ApsDataIndication &ind, qint8 commandId, const QByteArray &data);\n    void handleCommissioningClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    bool sendTuyaRequestThermostatSetWeeklySchedule(TaskItem &taskRef, quint8 weekdays, const QString &transitions, qint8 Dp_identifier);\n    bool handleMgmtBindRspConfirm(const deCONZ::ApsDataConfirm &conf);\n    void handleDeviceAnnceIndication(const deCONZ::ApsDataIndication &ind);\n    void handleNodeDescriptorResponseIndication(const deCONZ::ApsDataIndication &ind);\n    void handleIeeeAddressReqIndication(const deCONZ::ApsDataIndication &ind);\n    void handleNwkAddressReqIndication(const deCONZ::ApsDataIndication &ind);\n    void handleMgmtBindRspIndication(const deCONZ::ApsDataIndication &ind);\n    void handleBindAndUnbindRspIndication(const deCONZ::ApsDataIndication &ind);\n    void handleMgmtLeaveRspIndication(const deCONZ::ApsDataIndication &ind);\n    void handleMgmtLqiRspIndication(const deCONZ::ApsDataIndication &ind);\n    void handleXalClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleWindowCoveringClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handlePollControlIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    // Danalock support\n    void handleDoorLockClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleThermostatClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleThermostatUiConfigurationClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleAirQualityClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleTimeClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleFanControlClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleIdentifyClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    void sendTimeClusterResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleBasicClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void sendBasicClusterResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleTuyaClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, Device *device);\n    void handleZclAttributeReportIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleZclConfigureReportingResponseIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void taskToLocalData(const TaskItem &task);\n    void handleZclAttributeReportIndicationXiaomiSpecial(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void queuePollNode(RestNodeBase *node);\n    void handleApplianceAlertClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    bool serialiseThermostatTransitions(const QVariantList &transitions, QString *s);\n    bool deserialiseThermostatTransitions(const QString &s, QVariantList *transitions);\n    bool serialiseThermostatSchedule(const QVariantMap &schedule, QString *s);\n    bool deserialiseThermostatSchedule(const QString &s, QVariantMap *schedule);\n    void handleSimpleMeteringClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    void handleElectricalMeasurementClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    void handleXiaomiLumiClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n    void handleOccupancySensingClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n    void handlePowerConfigurationClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame);\n\n    // Modify node attributes\n    void setAttributeOnOff(LightNode *lightNode);\n    void setAttributeLevel(LightNode *lightNode);\n    void setAttributeEnhancedHue(LightNode *lightNode);\n    void setAttributeSaturation(LightNode *lightNode);\n    void setAttributeColorXy(LightNode *lightNode);\n    void setAttributeColorTemperature(LightNode *lightNode);\n    void setAttributeColorLoopActive(LightNode *lightNode);\n\n    // Etag helper\n    void updateSensorEtag(Sensor *sensorNode);\n    void updateLightEtag(LightNode *lightNode);\n    void updateGroupEtag(Group *group);\n\n    // Database interface\n    void initDb();\n    void checkDbUserVersion();\n    void cleanUpDb();\n    void createTempViews();\n    void pushZdpDescriptorDb(quint64 extAddress, quint8 endpoint, quint16 type, const QByteArray &data);\n    void pushZclValueDb(quint64 extAddress, quint8 endpoint, quint16 clusterId, quint16 attributeId, qint64 data);\n    bool dbIsOpen() const;\n    void openDb();\n    void readDb();\n    void loadAuthFromDb();\n    void loadConfigFromDb();\n    void loadUserparameterFromDb();\n    void loadAllGroupsFromDb();\n    void loadAllResourcelinksFromDb();\n    void loadAllScenesFromDb();\n    void loadAllSchedulesFromDb();\n    void loadLightNodeFromDb(LightNode *lightNode);\n    QString loadDataForLightNodeFromDb(QString extAddress);\n    void loadGroupFromDb(Group *group);\n    void loadSceneFromDb(Scene *scene);\n    void loadSwUpdateStateFromDb();\n    void loadWifiInformationFromDb();\n    void loadAllRulesFromDb();\n    void loadAllSensorsFromDb();\n    void loadSensorDataFromDb(Sensor *sensor, QVariantList &ls, qint64 fromTime, int max);\n    void loadLightDataFromDb(LightNode *lightNode, QVariantList &ls, qint64 fromTime, int max);\n    void loadAllGatewaysFromDb();\n    void saveDb();\n    void saveApiKey(QString apikey);\n    void closeDb();\n    void queSaveDb(int items, int msec);\n    void updateZigBeeConfigDb();\n    void getLastZigBeeConfigDb(QString &out);\n    void getZigbeeConfigDb(QVariantList &out);\n    void deleteDeviceDb(const QString &uniqueId);\n\n    void checkConsistency();\n\n    int ttlDataBaseConnection; // when idleTotalCounter becomes greater the DB will be closed\n    int saveDatabaseItems;\n    int saveDatabaseIdleTotalCounter;\n    QString sqliteDatabaseName;\n    std::vector<QString> dbQueryQueue;\n    qint64 dbZclValueMaxAge;\n    QTimer *databaseTimer;\n    QString emptyString;\n\n    // JSON support\n    std::vector<ButtonMeta> buttonMeta;\n    std::vector<ButtonMap> buttonMaps;\n    QMap<QString, quint16> btnMapClusters;\n    QMap<QString, QMap<QString, quint16>> btnMapClusterCommands;\n    std::vector<ButtonProduct> buttonProductMap;\n\n    // gateways\n    std::vector<Gateway*> gateways;\n    GatewayScanner *gwScanner;\n\n    // authorisation\n    QElapsedTimer apiAuthSaveDatabaseTime;\n    size_t apiAuthCurrent;\n    std::vector<ApiAuth> apiAuths;\n    QString gwAdminUserName;\n    std::string gwAdminPasswordHash;\n\n    struct SwUpdateState {\n     QString noUpdate;\n     QString readyToInstall;\n     QString transferring;\n     QString installing;\n    } swUpdateState = {\"noupdates\",\"allreadytoinstall\",\"transferring\",\"installing\"};\n\n    // configuration\n    bool gwLinkButton;\n    bool gwWebSocketNotifyAll;  // include all attributes in websocket notification\n    bool gwdisablePermitJoinAutoOff; // Stop the periodic verification for closed network\n    bool gwRfConnectedExpected;  // the state which should be hold\n    bool gwRfConnected;  // to detect changes\n    int gwAnnounceInterval; // used by internet discovery [minutes]\n    QString gwAnnounceUrl;\n    int gwAnnounceVital; // 0 not tried, > 0 success attemps, < 0 failed attemps\n    int gwPermitJoinDuration = 0; // global permit join state (last set)\n    QString permitJoinApiKey;\n    uint16_t gwNetworkOpenDuration; // user setting how long network remains open\n    QString gwWifi;     // configured | not-configured | not-available | new-configured | deactivated\n    QString gwWifiActive;\n    uint gwWifiLastUpdated;\n    QString gwWifiEth0;\n    QString gwWifiWlan0;\n    QVariantList gwWifiAvailable;\n    int gwLightLastSeenInterval; // Intervall to throttle lastseen updates\n    enum WifiState {\n        WifiStateInitMgmt,\n        WifiStateIdle\n    };\n    WifiState gwWifiState;\n    QString gwWifiStateString;\n    quint32 gwWifiMgmt;\n    QString gwWifiType; // accesspoint | ad-hoc | client\n    QString gwWifiName;\n    QString gwWifiBackupName;\n    QString gwWifiWorkingType;\n    QString gwWifiWorkingName;\n    QString gwWifiWorkingPw;\n    QString gwWifiWorkingPwEnc;\n    QString gwWifiClientName;\n    QString gwWifiChannel;\n    QString gwWifiIp;\n    QString gwWifiPw;\n    QString gwWifiPwEnc;\n    QString gwWifiBackupPw;\n    QString gwWifiBackupPwEnc;\n    QString gwWifiClientPw;\n    //QString gwWifiApPw;\n    pid_t gwWifiPID;\n    QTimer *wifiPageActiveTimer;\n    bool gwWifiPageActive;\n    QString gwProxyAddress;\n    quint16 gwProxyPort;\n    QString gwTimezone;\n    QString gwTimeFormat;\n    QString gwMAC;\n    QString gwIPAddress;\n    uint16_t gwPort;\n    bool gwAllowLocal;\n    QString gwNetMask;\n    QString gwHomebridge;\n    QString gwHomebridgePin;\n    QString gwHomebridgeVersion;\n    QString gwHomebridgeUpdateVersion;\n    bool gwHomebridgeUpdate;\n    QString gwName;\n    bool gwHueMode;\n    bool gwLANBridgeId;\n    QString gwBridgeId;\n    QString gwUuid;\n    QString gwUpdateVersion;\n    QString gwUpdateDate;\n    QString gwSwUpdateState;\n    QString gwRgbwDisplay;\n    QString gwFirmwareVersion;\n    QString gwFirmwareVersionUpdate; // for local update of the firmware if it doesn't fit the GW_MIN_<platform>_FW_VERSION\n    bool gwFirmwareNeedUpdate;\n    QString gwUpdateChannel;\n    int gwGroupSendDelay;\n    uint gwZigbeeChannel;\n    uint16_t gwGroup0;\n    QVariantMap gwConfig;\n    QString gwSensorsEtag;\n    QString gwLightsEtag;\n    QString gwGroupsEtag;\n    QString gwConfigEtag;\n    QByteArray gwChallenge;\n    QDateTime gwLastChallenge;\n    bool gwRunFromShellScript;\n    QString gwRunMode;\n    bool gwDeleteUnknownRules;\n    QVariantMap gwUserParameter;\n    std::vector<QString> gwUserParameterToDelete;\n    deCONZ::Address gwDeviceAddress;\n    QString gwSdImageVersion;\n    QDateTime globalLastMotion; // last time any physical PIR has detected motion\n    QDateTime zbConfigGood; // timestamp incoming ZCL reports/read attribute responses are received, indication that network is operational\n\n    // time manager\n    enum TimeManagerState {\n        TM_Init,\n        TM_WaitNtpq,\n        TM_NtpRunning\n    };\n    TimeManagerState timeManagerState;\n    QProcess *ntpqProcess;\n\n    // firmware update\n    enum FW_UpdateState {\n        FW_Idle,\n        FW_CheckVersion,\n        FW_CheckDevices,\n        FW_WaitUserConfirm,\n        FW_DisconnectDevice,\n        FW_Update,\n        FW_UpdateWaitFinished\n    };\n    QTimer *fwUpdateTimer;\n    QTimer *pollSwUpdateStateTimer;\n    QTimer *pollDatabaseWifiTimer;\n    int fwUpdateIdleTimeout;\n    bool fwUpdateStartedByUser;\n    FW_UpdateState fwUpdateState;\n    QString fwUpdateFile;\n    QProcess *fwProcess;\n    QProcess *zipProcess;\n    QProcess *archProcess;\n    QStringList fwProcessArgs;\n    QString fwDeviceName;\n\n    // Helper to reference nodes in containers.\n    // This is needed since the pointer might change due container resize / item removal.\n    struct PollNodeItem\n    {\n        PollNodeItem(const QString &_uuid, const char *rt) :\n        uuid(_uuid),\n        resourceType(rt)\n        { }\n        bool operator==(const PollNodeItem &other) const\n        {\n            return resourceType == other.resourceType && uuid == other.uuid;\n        }\n        const QString uuid;\n        const char* resourceType = nullptr; // back ref to the container RLights, RSensors\n    };\n\n    std::deque<PollNodeItem> pollNodes;\n    PollManager *pollManager = nullptr;\n\n    // upnp\n    QByteArray descriptionXml;\n\n    // gateway lock (link button)\n    QTimer *lockGatewayTimer;\n\n    // permit join\n    QTimer *permitJoinTimer;\n    QElapsedTimer permitJoinLastSendTime;\n    bool permitJoinFlag; // indicates that permitJoin changed from greater than 0 to 0\n\n    // schedules\n    QTimer *scheduleTimer;\n    std::vector<Schedule> schedules;\n    TaskItem taskScheduleTimer;\n\n    // window covering\n    TaskItem calibrationTask;\n\n    // webhooks\n    QNetworkAccessManager *webhookManager = nullptr;\n\n    // internet discovery\n    QNetworkAccessManager *inetDiscoveryManager;\n    QTimer *inetDiscoveryTimer;\n    QNetworkReply *inetDiscoveryResponse;\n    QString osPrettyName;\n    QString piRevision;\n\n    // otau\n    QTimer *otauTimer;\n    int otauIdleTicks;\n    int otauBusyTicks;\n    int otauIdleTotalCounter;\n\n    // touchlink\n\n    // touchlink state machine\n    enum TouchlinkState\n    {\n        // general\n        TL_Idle,\n        TL_DisconnectingNetwork,\n        TL_StartingInterpanMode,\n        TL_StoppingInterpanMode,\n        TL_ReconnectNetwork,\n        // scanning\n        TL_SendingScanRequest,\n        TL_WaitScanResponses,\n        // identify\n        TL_SendingIdentifyRequest,\n        // reset\n        TL_SendingResetRequest\n    };\n\n    enum TouchlinkAction\n    {\n        TouchlinkScan,\n        TouchlinkIdentify,\n        TouchlinkReset\n    };\n\n    struct ScanResponse\n    {\n        QString id;\n        deCONZ::Address address;\n        bool factoryNew;\n        uint8_t channel;\n        uint16_t panid;\n        uint32_t transactionId;\n        int8_t rssi;\n    };\n\n    int touchlinkNetworkDisconnectAttempts; // disconnect attemps before touchlink\n    int touchlinkNetworkReconnectAttempts; // reconnect attemps after touchlink\n    bool touchlinkNetworkConnectedBefore;\n    uint8_t touchlinkChannel;\n    uint8_t touchlinkScanCount;\n    deCONZ::TouchlinkController *touchlinkCtrl;\n    TouchlinkAction touchlinkAction;\n    TouchlinkState touchlinkState;\n    deCONZ::TouchlinkRequest touchlinkReq;\n    QTimer *touchlinkTimer;\n    QDateTime touchlinkScanTime;\n    std::vector<ScanResponse> touchlinkScanResponses;\n    ScanResponse touchlinkDevice; // device of interrest (identify, reset, ...)\n\n    // channel change state machine\n    enum ChannelChangeState\n    {\n        CC_Idle,\n        CC_Verify_Channel,\n        CC_WaitConfirm,\n        CC_Change_Channel,\n        CC_DisconnectingNetwork,\n        CC_ReconnectNetwork\n    };\n\n    ChannelChangeState channelChangeState;\n    QTimer *channelchangeTimer;\n    quint8 ccRetries;\n    int ccNetworkDisconnectAttempts; // disconnect attemps before chanelchange\n    int ccNetworkReconnectAttempts; // reconnect attemps after channelchange\n    bool ccNetworkConnectedBefore;\n    uint8_t channelChangeApsRequestId;\n\n    // generic network reconnect state machine\n    enum NetworkReconnectState\n    {\n        DisconnectingNetwork,\n        ReconnectNetwork,\n        MaintainNetwork\n    };\n\n    QTimer *reconnectTimer = nullptr;\n    NetworkReconnectState networkState = MaintainNetwork;\n    int networkDisconnectAttempts;\n    int networkReconnectAttempts;\n    bool networkConnectedBefore;\n    bool needRestartApp = false;\n\n    // delete device state machine\n    enum ResetDeviceState\n    {\n        ResetIdle,\n        ResetWaitConfirm,\n        ResetWaitIndication\n    };\n\n    QTimer *resetDeviceTimer;\n    ResetDeviceState resetDeviceState;\n    uint8_t zdpResetSeq;\n    uint64_t lastNodeAddressExt;\n    uint8_t resetDeviceApsRequestId;\n\n    // lights\n    enum SearchLightsState\n    {\n        SearchLightsIdle,\n        SearchLightsActive,\n        SearchLightsDone,\n    };\n\n    // sensors\n    enum SearchSensorsState\n    {\n        SearchSensorsIdle,\n        SearchSensorsActive,\n        SearchSensorsDone,\n    };\n\n\n    DeviceWidget *deviceWidget = nullptr;\n    RestDevices *restDevices;\n\n    class SensorCommand\n    {\n    public:\n        bool operator ==(const SensorCommand &other) const\n        {\n            return endpoint == other.endpoint &&\n                    cluster == other.cluster &&\n                    zclCommand == other.zclCommand &&\n                    zclCommandParameter == other.zclCommandParameter &&\n                    dstGroup == other.dstGroup;\n        }\n        quint8 endpoint;\n        quint16 cluster;\n        quint8 zclCommand;\n        quint16 dstGroup;\n        uint zclCommandParameter;\n    };\n\n    class SensorCandidate\n    {\n    public:\n        SensorCandidate() :\n            macCapabilities(0),\n            waitIndicationClusterId(0)\n        {\n\n        }\n        deCONZ::Address address;\n        quint8 macCapabilities;\n        QElapsedTimer timeout;\n        quint16 waitIndicationClusterId;\n        std::vector<quint8> endpoints;\n        std::vector<SensorCommand> rxCommands;\n    };\n\n    SearchLightsState searchLightsState;\n    QVariantMap searchLightsResult;\n    int searchLightsTimeout;\n    QString lastLightsScan;\n\n    SearchSensorsState searchSensorsState;\n    size_t searchSensorGppPairCounter = 0;\n    deCONZ::Address fastProbeAddr;\n    std::vector<deCONZ::ApsDataIndication> fastProbeIndications;\n    QVariantMap searchSensorsResult;\n    QTimer *fastProbeTimer;\n    int searchSensorsTimeout;\n    QString lastSensorsScan;\n    std::vector<SensorCandidate> searchSensorsCandidates;\n\n    class RecoverOnOff\n    {\n    public:\n        deCONZ::Address address;\n        bool onOff;\n        uint bri;\n        int idleTotalCounterCopy;\n    };\n    std::vector<RecoverOnOff> recoverOnOff;\n\n    // resourcelinks\n    std::vector<Resourcelinks> resourcelinks;\n\n    // rules\n    int needRuleCheck;\n    std::vector<int> fastRuleCheck;\n    QTimer *fastRuleCheckTimer;\n\n    // general\n    ApiConfig config;\n    QTime queryTime;\n    ApsControllerWrapper apsCtrlWrapper;\n    deCONZ::ApsController *apsCtrl = nullptr;\n    uint groupTaskNodeIter; // Iterates through nodes array\n    QElapsedTimer idleTimer;\n    int idleTotalCounter; // sys timer\n    int idleLimit;\n    int idleUpdateZigBeeConf; //\n    int idleLastActivity; // delta in seconds\n    size_t lightIter;\n    size_t sensorIter;\n    size_t lightAttrIter;\n    size_t sensorAttrIter;\n    size_t sensorCheckIter;\n    int sensorCheckFast;\n    DeviceContainer m_devices;\n    std::vector<Group> groups;\n    std::vector<LightNode> nodes;\n    std::vector<Rule> rules;\n    QString daylightSensorId;\n    size_t daylightOffsetIter = 0;\n    std::vector<DL_Result> daylightTimes;\n    std::vector<Sensor> sensors;\n    std::list<TaskItem> tasks;\n    std::list<TaskItem> runningTasks;\n    QTimer *taskTimer;\n    QTimer *groupTaskTimer;\n    QTimer *checkSensorsTimer;\n    uint8_t zclSeq;\n    std::list<QTcpSocket*> eventListeners;\n    bool joinedMulticastGroup;\n    QTimer *upnpTimer;\n    QUdpSocket *udpSock;\n    QUdpSocket *udpSockOut;\n    uint8_t haEndpoint;\n\n    // events\n    EventEmitter *eventEmitter = nullptr;\n\n    // bindings\n    bool gwReportingEnabled;\n    QTimer *bindingTimer;\n    QTimer *bindingTableReaderTimer;\n    std::list<BindingTask> bindingQueue; // bind/unbind queue\n    std::vector<BindingTableReader> bindingTableReaders;\n\n    DeviceDescriptions *deviceDescriptions = nullptr;\n    DeviceJs *deviceJs = nullptr;\n\n    // IAS\n    std::unique_ptr<AS_DeviceTable> alarmSystemDeviceTable;\n    std::unique_ptr<AlarmSystems> alarmSystems;\n\n    // TCP connection watcher\n    QTimer *openClientTimer;\n    std::vector<TcpClient> openClients;\n\n    WebSocketServer *webSocketServer;\n\n    // will be set at startup to calculate the uptime\n    QElapsedTimer starttimeRef;\n\n    Q_DECLARE_PUBLIC(DeRestPlugin)\n    DeRestPlugin *q_ptr; // public interface\n\n};\n\nextern DeRestPluginPrivate *plugin;\n\n#endif // DE_WEB_PLUGIN_PRIVATE_H\n"
        },
        {
          "name": "de_web_widget.cpp",
          "type": "blob",
          "size": 5.033203125,
          "content": "/*\n * Copyright (c) 2013-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QAction>\n#include <QLabel>\n#include <QNetworkInterface>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"de_web_widget.h\"\n#include \"ui_de_web_widget.h\"\n\nQAction *readBindingTableAction = nullptr;\n\n/*! Constructor. */\nDeRestWidget::DeRestWidget(QWidget *parent, DeRestPlugin *_plugin) :\n    QDialog(parent),\n    ui(new Ui::DeWebWidget),\n    plugin(_plugin)\n{\n    ui->setupUi(this);\n    setWindowTitle(tr(\"DE REST-API\"));\n    deCONZ::ApsController *apsCtrl = deCONZ::ApsController::instance();\n\n    quint16 httpPort = apsCtrl ? deCONZ::ApsController::instance()->getParameter(deCONZ::ParamHttpPort) : 0;\n\n    ui->ipAddressesLabel->setTextFormat(Qt::RichText);\n    ui->ipAddressesLabel->setTextInteractionFlags(Qt::TextBrowserInteraction);\n    ui->ipAddressesLabel->setOpenExternalLinks(true);\n    ui->gitCommitLabel->setText(QLatin1String(GIT_COMMMIT));\n\n    QString str;\n    QList<QNetworkInterface> ifaces = QNetworkInterface::allInterfaces();\n\n    QList<QNetworkInterface>::Iterator ifi = ifaces.begin();\n    QList<QNetworkInterface>::Iterator ifend = ifaces.end();\n\n    for (; ifi != ifend; ++ifi)\n    {\n        QString name = ifi->humanReadableName();\n\n        // filter\n        if (name.contains(\"br-\", Qt::CaseInsensitive) ||\n            name.contains(\"docker\", Qt::CaseInsensitive) ||\n            name.contains(\"vm\", Qt::CaseInsensitive) ||\n            name.contains(\"virtual\", Qt::CaseInsensitive) ||\n            name.contains(\"loop\", Qt::CaseInsensitive))\n        {\n            continue;\n        }\n\n        QList<QNetworkAddressEntry> addr = ifi->addressEntries();\n\n        QList<QNetworkAddressEntry>::Iterator i = addr.begin();\n        QList<QNetworkAddressEntry>::Iterator end = addr.end();\n\n        for (; i != end; ++i)\n        {\n            QHostAddress a = i->ip();\n\n            if (a.protocol() == QAbstractSocket::IPv4Protocol)\n            {\n                QString url = QString(\"http://%1:%2\").arg(a.toString()).arg(httpPort);\n\n                str.append(\"<b>\");\n                str.append(ifi->humanReadableName());\n                str.append(\"</b>&nbsp;&nbsp;&nbsp;&nbsp;\");\n                str.append(QString(\"<a href=\\\"%1\\\">%2</a><br/>\").arg(url).arg(url));\n            }\n        }\n    }\n\n    if (httpPort == 0)\n    {\n        str = tr(\"No HTTP server is running\");\n    }\n\n    ui->ipAddressesLabel->setText(str);\n\n    //\n    connect(deCONZ::ApsController::instance(), &deCONZ::ApsController::nodeEvent, this, &DeRestWidget::nodeEvent);\n\n    // keyboard shortcuts\n    readBindingTableAction = new QAction(tr(\"Read binding table\"), this);\n    readBindingTableAction->setShortcut(Qt::CTRL + Qt::Key_B);\n    readBindingTableAction->setProperty(\"type\", \"node-action\");\n    readBindingTableAction->setProperty(\"actionid\", \"read-binding-table\");\n    readBindingTableAction->setEnabled(m_selectedNodeAddress.hasExt());\n    connect(readBindingTableAction, &QAction::triggered, this, &DeRestWidget::readBindingTableTriggered);\n    addAction(readBindingTableAction);\n}\n\n/*! Deconstructor. */\nDeRestWidget::~DeRestWidget()\n{\n    Q_ASSERT(ui);\n    delete ui;\n    ui = nullptr;\n}\n\n/*! Returns true if the plugin is active. */\nbool DeRestWidget::pluginActive() const\n{\n    if (ui)\n    {\n        return ui->pluginActiveCheckBox->isChecked();\n    }\n    return false;\n}\n\nvoid DeRestWidget::readBindingTableTriggered()\n{\n    if (m_selectedNodeAddress.hasExt())\n    {\n        auto *restNode = dynamic_cast<RestNodeBase*>(plugin->d->getLightNodeForAddress(m_selectedNodeAddress));\n\n        if (!restNode)\n        {\n            restNode = dynamic_cast<RestNodeBase*>(plugin->d->getSensorNodeForAddress(m_selectedNodeAddress));\n        }\n\n        if (restNode)\n        {\n            restNode->setMgmtBindSupported(true);\n            plugin->d->readBindingTable(restNode, 0);\n        }\n    }\n}\n\nvoid DeRestWidget::nodeEvent(const deCONZ::NodeEvent &event)\n{\n    if (event.node() && event.event() == deCONZ::NodeEvent::NodeSelected)\n    {\n        m_selectedNodeAddress = event.node()->address();\n        readBindingTableAction->setEnabled(m_selectedNodeAddress.hasExt());\n    }\n    else if (event.event() == deCONZ::NodeEvent::NodeDeselected)\n    {\n        m_selectedNodeAddress = {};\n        readBindingTableAction->setEnabled(false);\n    }\n}\n\nvoid DeRestWidget::showEvent(QShowEvent *)\n{\n    deCONZ::ApsController *apsCtrl = deCONZ::ApsController::instance();\n\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    QByteArray sec0 = apsCtrl->getParameter(deCONZ::ParamSecurityMaterial0);\n\n    if (!sec0.isEmpty())\n    {\n        QByteArray installCode;\n        for (int i = 0; i < 4; i++)\n        {\n            installCode += sec0.mid(i * 4, 4);\n            if (i < 3) { installCode += ' '; }\n        }\n        ui->labelInstallCode->setText(installCode);\n    }\n    else\n    {\n        ui->labelInstallCode->setText(tr(\"not available\"));\n    }\n\n}\n"
        },
        {
          "name": "de_web_widget.h",
          "type": "blob",
          "size": 0.880859375,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DE_WEB_WIDGET_H\n#define DE_WEB_WIDGET_H\n\n#include <QDialog>\n#include <deconz.h>\n\nnamespace Ui {\nclass DeWebWidget;\n}\n\nclass DeRestPlugin;\n\nclass DeRestWidget : public QDialog\n{\n    Q_OBJECT\n    \npublic:\n    explicit DeRestWidget(QWidget *parent, DeRestPlugin *_plugin);\n    ~DeRestWidget();\n    bool pluginActive() const;\n\nprivate Q_SLOTS:\n    void readBindingTableTriggered();\n    void nodeEvent(const deCONZ::NodeEvent &event);\n\nprivate:\n    void showEvent(QShowEvent *);\n    deCONZ::Address m_selectedNodeAddress;\n    Ui::DeWebWidget *ui = nullptr;\n    DeRestPlugin *plugin = nullptr;\n};\n\n#endif // DE_WEB_WIDGET_H\n"
        },
        {
          "name": "de_web_widget.ui",
          "type": "blob",
          "size": 4.16015625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>DeWebWidget</class>\n <widget class=\"QDialog\" name=\"DeWebWidget\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>495</width>\n    <height>263</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>DE REST API</string>\n  </property>\n  <property name=\"sizeGripEnabled\">\n   <bool>true</bool>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n   <item>\n    <widget class=\"QLabel\" name=\"label_3\">\n     <property name=\"font\">\n      <font>\n       <weight>75</weight>\n       <bold>true</bold>\n      </font>\n     </property>\n     <property name=\"text\">\n      <string>GIT Commit</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"gitCommitLabel\">\n     <property name=\"text\">\n      <string>&lt;commit hash&gt;</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label\">\n     <property name=\"font\">\n      <font>\n       <weight>75</weight>\n       <bold>true</bold>\n      </font>\n     </property>\n     <property name=\"text\">\n      <string>IP Addresses</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label_2\">\n     <property name=\"text\">\n      <string>Click on the link to open the Phoscon App in your browser.</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"ipAddressesLabel\">\n     <property name=\"text\">\n      <string>127.0.0.1</string>\n     </property>\n     <property name=\"margin\">\n      <number>16</number>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\" stretch=\"0,0,0,0\">\n     <item>\n      <widget class=\"QLabel\" name=\"label_4\">\n       <property name=\"font\">\n        <font>\n         <weight>75</weight>\n         <bold>true</bold>\n        </font>\n       </property>\n       <property name=\"text\">\n        <string>Install Code</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer_3\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeType\">\n        <enum>QSizePolicy::Minimum</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>20</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QLabel\" name=\"labelInstallCode\">\n       <property name=\"text\">\n        <string>not available</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n     <item>\n      <widget class=\"QCheckBox\" name=\"pluginActiveCheckBox\">\n       <property name=\"text\">\n        <string>Plugin Active</string>\n       </property>\n       <property name=\"checked\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer_2\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>92</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"closeButton\">\n       <property name=\"text\">\n        <string>Close</string>\n       </property>\n      </widget>\n     </item>\n    </layout>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections>\n  <connection>\n   <sender>closeButton</sender>\n   <signal>clicked()</signal>\n   <receiver>DeWebWidget</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>218</x>\n     <y>128</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>162</x>\n     <y>133</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "description_in.xml",
          "type": "blob",
          "size": 1.0478515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n  <specVersion>\n    <major>1</major>\n    <minor>0</minor>\n  </specVersion>\n  <URLBase>http://{{IPADDRESS}}:{{PORT}}/</URLBase>\n  <device>\n    <deviceType>urn:schemas-upnp-org:device:Basic:1</deviceType>\n    <friendlyName>{{GWNAME}} ({{IPADDRESS}})</friendlyName>\n    <manufacturer>Royal Philips Electronics</manufacturer>\n    <manufacturerURL>http://www.dresden-elektronik.de</manufacturerURL>\n    <modelDescription>Philips hue compatible Personal Wireless Lighting</modelDescription>\n    <modelName>Philips hue bridge 2015</modelName>\n    <modelNumber>BSB002</modelNumber>\n    <modelURL>http://www.dresden-elektronik.de</modelURL>\n    <serialNumber>{{SERIAL}}</serialNumber>\n    <UDN>uuid:{{UUID}}</UDN>\n    <presentationURL>index.html</presentationURL>\n    <iconList>\n      <icon>\n        <mimetype>image/png</mimetype>\n        <height>48</height>\n        <width>48</width>\n        <depth>24</depth>\n        <url>hue_logo_0.png</url>\n      </icon>\n    </iconList>\n  </device>\n</root>\n"
        },
        {
          "name": "device.cpp",
          "type": "blob",
          "size": 78.615234375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QBasicTimer>\n#include <QElapsedTimer>\n#include <QTimer>\n#include <QTimerEvent>\n#include <QMetaObject>\n#include <array>\n#include <deconz/dbg_trace.h>\n#include <deconz/node.h>\n#include \"device.h\"\n#include \"device_access_fn.h\"\n#include \"device_descriptions.h\"\n#include \"event.h\"\n#include \"event_emitter.h\"\n#include \"utils/utils.h\"\n#include \"zcl/zcl.h\"\n#include \"zdp/zdp.h\"\n\n#define STATE_LEVEL_BINDING  StateLevel1\n#define STATE_LEVEL_POLL     StateLevel2\n\n#define MGMT_BIND_SUPPORT_UNKNOWN -1\n#define MGMT_BIND_SUPPORTED        1\n#define MGMT_BIND_NOT_SUPPORTED    0\n\n#define DEV_INVALID_DEVICE_ID -1\n\ntypedef void (*DeviceStateHandler)(Device *, const Event &);\n\n/*! Device state machine description can be found in the wiki:\n\n       https://github.com/dresden-elektronik/deconz-rest-plugin-v2/wiki/Device-Class#state-machine\n*/\nvoid DEV_InitStateHandler(Device *device, const Event &event);\nvoid DEV_IdleStateHandler(Device *device, const Event &event);\nvoid DEV_NodeDescriptorStateHandler(Device *device, const Event &event);\nvoid DEV_ActiveEndpointsStateHandler(Device *device, const Event &event);\nvoid DEV_SimpleDescriptorStateHandler(Device *device, const Event &event);\nvoid DEV_BasicClusterStateHandler(Device *device, const Event &event);\nvoid DEV_GetDeviceDescriptionHandler(Device *device, const Event &event);\nstatic const deCONZ::SimpleDescriptor *DEV_GetSimpleDescriptorForServerCluster(const Device *device, deCONZ::ZclClusterId_t clusterId);\nvoid DEV_BindingHandler(Device *device, const Event &event);\nvoid DEV_BindingTableReadHandler(Device *device, const Event &event);\nvoid DEV_BindingTableVerifyHandler(Device *device, const Event &event);\nvoid DEV_BindingCreateHandler(Device *device, const Event &event);\nvoid DEV_BindingRemoveHandler(Device *device, const Event &event);\nvoid DEV_ReadReportConfigurationHandler(Device *device, const Event &event);\nvoid DEV_ReadNextReportConfigurationHandler(Device *device, const Event &event);\nvoid DEV_ConfigureNextReportConfigurationHandler(Device *device, const Event &event);\nvoid DEV_ConfigureReportingHandler(Device *device, const Event &event);\nvoid DEV_BindingIdleHandler(Device *device, const Event &event);\nvoid DEV_PollIdleStateHandler(Device *device, const Event &event);\nvoid DEV_PollNextStateHandler(Device *device, const Event &event);\nvoid DEV_PollBusyStateHandler(Device *device, const Event &event);\nvoid DEV_DeadStateHandler(Device *device, const Event &event);\n\n// enable domain specific string literals\nusing namespace deCONZ::literals;\n\nconstexpr int RxOnWhenIdleResponseTime = 2000; // Expect shorter response delay for rxOnWhenIdle devices\nconstexpr int RxOffWhenIdleResponseTime = 8000; // 7680 ms + some space for timeout\nconstexpr int MaxConfirmTimeout = 20000; // If for some reason no APS-DATA.confirm is received (should almost\nconstexpr int BindingAutoCheckInterval = 1000 * 60 * 60;\nconstexpr int MaxPollItemRetries = 3;\nconstexpr int MaxIdleApsConfirmErrors = 16;\nconstexpr int MaxSubResources = 8;\n\nstatic int devManaged = -1;\n\nstruct DEV_PollItem\n{\n    explicit DEV_PollItem(const Resource *r, const ResourceItem *i, const QVariant &p) :\n        resource(r), item(i), readParameters(p) {}\n    size_t retry = 0;\n    const Resource *resource = nullptr;\n    const ResourceItem *item = nullptr;\n    QVariant readParameters;\n};\n\n// special value for ReportTracker::lastConfigureCheck during zcl configure reporting step\nconstexpr int64_t MarkZclConfigureBusy = 21;\n\nstruct ReportTracker\n{\n    deCONZ::SteadyTimeRef lastReport;\n    deCONZ::SteadyTimeRef lastConfigureCheck;\n    uint16_t clusterId = 0;\n    uint16_t attributeId = 0;\n    uint8_t endpoint = 0;\n};\n\nstruct BindingTracker\n{\n    deCONZ::SteadyTimeRef tBound;\n};\n\nstruct BindingContext\n{\n    size_t bindingCheckRound = 0;\n    size_t bindingIter = 0;\n    size_t reportIter = 0;\n    size_t configIter = 0;\n    int mgmtBindSupported = MGMT_BIND_SUPPORT_UNKNOWN;\n    uint8_t mgmtBindStartIndex = 0;\n    std::vector<BindingTracker> bindingTrackers;\n    std::vector<DDF_Binding> bindings;\n    std::vector<ReportTracker> reportTrackers;\n    ZCL_ReadReportConfigurationParam readReportParam;\n    ZCL_Result zclResult;\n    ZDP_Result zdpResult;\n};\n\nstatic ReportTracker &DEV_GetOrCreateReportTracker(Device *device, uint16_t clusterId, uint16_t attrId, uint8_t endpoint);\n\nclass DevicePrivate\n{\npublic:\n    void setState(DeviceStateHandler newState, DEV_StateLevel level = StateLevel0);\n    void startStateTimer(int IntervalMs, DEV_StateLevel level);\n    void stopStateTimer(DEV_StateLevel level);\n    bool hasRxOnWhenIdle() const;\n\n    Device *q = nullptr; //! reference to public interface\n    deCONZ::ApsController *apsCtrl = nullptr; //! opaque instance pointer forwarded to external functions\n\n    /*! sub-devices are not yet referenced via pointers since these may become dangling.\n        This is a helper to query the actual sub-device Resource* on demand via Resource::Handle.\n    */\n    std::array<Resource::Handle, MaxSubResources> subResourceHandles;\n    std::vector<Resource*> subResources;\n    const deCONZ::Node *node = nullptr; //! a reference to the deCONZ core node\n    int deviceId = DEV_INVALID_DEVICE_ID;\n    DeviceKey deviceKey = 0; //! for physical devices this is the MAC address\n\n    /*! The currently active state handler function(s).\n        Indexes >0 represent sub states of StateLevel0 running in parallel.\n    */\n    std::array<DeviceStateHandler, StateLevelMax> state{};\n\n    std::array<QBasicTimer, StateLevelMax> timer; //! internal single shot timer one for each state level\n    QElapsedTimer awake; //! time to track when an end-device was last awake\n    BindingContext binding; //! only used by binding sub state machine\n    std::vector<DEV_PollItem> pollItems; //! queue of items to poll\n    int idleApsConfirmErrors = 0;\n    /*! True while a new state waits for the state enter event, which must arrive first.\n        This is for debug asserting that the order of events is valid - it doesn't drive logic. */\n    bool stateEnterLock[StateLevelMax] = {};\n    bool managed = false; //! a managed device doesn't rely on legacy implementation of polling etc.\n    ZDP_Result zdpResult; //! keep track of a running ZDP request\n    DA_ReadResult readResult; //! keep track of a running \"read\" request\n\n    uint8_t zdpNeedFetchEndpointIndex = 0xFF; //! used in combination with flags.needReadSimpleDescriptors\n    int maxResponseTime = RxOffWhenIdleResponseTime;\n\n    struct\n    {\n        unsigned char hasDdf : 1;\n        unsigned char initialRun : 1;\n        unsigned char needZDPMaintenanceOnce : 1;\n        unsigned char needReadActiveEndpoints : 1;\n        unsigned char needReadSimpleDescriptors : 1;\n        unsigned char reserved : 3;\n    } flags{};\n};\n\nDevice *DEV_ParentDevice(Resource *r)\n{\n    if (r && r->parentResource() && r->parentResource()->prefix() == RDevices)\n    {\n        return static_cast<Device*>(r->parentResource());\n    }\n\n    return nullptr;\n}\n\n//! Forward device attribute changes to core.\nvoid DEV_ForwardNodeChange(Device *device, const QString &key, const QString &value)\n{\n    if (device)\n    {\n        QMetaObject::invokeMethod(device->d->apsCtrl, \"onRestNodeUpdated\", Qt::DirectConnection,\n                              Q_ARG(quint64, device->key()), Q_ARG(QString, key), Q_ARG(QString, value));\n    }\n}\n\nvoid DEV_EnqueueEvent(Device *device, const char *event)\n{\n    Q_ASSERT(device);\n    Q_ASSERT(event);\n    emit device->eventNotify(Event(device->prefix(), event, 0, device->key()));\n}\n\nResource *DEV_GetSubDevice(Device *device, const char *prefix, const QString &identifier)\n{\n    if (!device)\n    {\n        return nullptr;\n    }\n\n    for (auto &sub : device->subDevices())\n    {\n        if (prefix && sub->prefix() != prefix)\n        {\n            continue;\n        }\n\n        if (sub->item(RAttrUniqueId)->toString() == identifier || sub->item(RAttrId)->toString() == identifier)\n        {\n            return sub;\n        }\n    }\n\n    return nullptr;\n}\n\nvoid DEV_InitStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        d->zdpResult = { };\n\n        if ((event.deviceKey() & 0x00212E0000000000LLU) == 0x00212E0000000000LLU)\n        {\n            if (!d->node)\n            {\n                d->node = DEV_GetCoreNode(device->key());\n            }\n\n            if (d->node && d->node->isCoordinator())\n            {\n                d->setState(DEV_DeadStateHandler);\n                return; // ignore coordinaor for now\n            }\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        return;\n    }\n\n    if (event.what() == REventPoll ||\n        event.what() == REventAwake ||\n        event.what() == RConfigReachable ||\n        event.what() == RStateReachable ||\n        event.what() == REventStateTimeout ||\n        event.what() == RStateLastUpdated ||\n        d->flags.initialRun == 1)\n    {\n        d->flags.initialRun = 0;\n        d->binding.bindingCheckRound = 0;\n\n        // lazy reference to deCONZ::Node\n        if (!device->node())\n        {\n            d->node = DEV_GetCoreNode(device->key());\n        }\n\n        if (device->node())\n        {\n            {\n                const deCONZ::Address a = device->node()->address();\n                ResourceItem *ext = device->item(RAttrExtAddress);\n                if (!ext->lastSet().isValid() || ext->toNumber() != a.ext())\n                {\n                    ext->setValue(a.ext());\n                }\n                ResourceItem *nwk = device->item(RAttrNwkAddress);\n                if (!nwk->lastSet().isValid() || nwk->toNumber() != a.nwk())\n                {\n                    nwk->setValue(a.nwk());\n                }\n            }\n\n            // got a node, jump to verification\n            if (!device->node()->nodeDescriptor().isNull() || device->reachable())\n            {\n                d->setState(DEV_NodeDescriptorStateHandler);\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_DEV, \"DEV Init no node found: \" FMT_MAC \"\\n\", FMT_MAC_CAST(event.deviceKey()));\n\n            if ((device->key() & 0xffffffff00000000LLU) == 0)\n            {\n                d->setState(DEV_DeadStateHandler);\n                return; // ignore ZGP for now\n            }\n        }\n    }\n}\n\nvoid DEV_CheckItemChanges(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n    std::vector<Resource*> subDevices;\n\n    if (event.what() == REventAwake || event.what() == REventPoll)\n    {\n        subDevices = device->subDevices();\n    }\n    else\n    {\n        auto *sub = DEV_GetSubDevice(device, event.resource(), event.id());\n        if (sub)\n        {\n            subDevices.push_back(sub);\n        }\n    }\n\n    int apsEnqueued = 0;\n    for (auto *sub : subDevices)\n    {\n        if (sub && !sub->stateChanges().empty())\n        {\n            auto *item = sub->item(event.what());\n            for (auto &change : sub->stateChanges())\n            {\n                if (item)\n                {\n                    change.verifyItemChange(item);\n                }\n\n                if (apsEnqueued == 0 && change.tick(d->deviceKey, sub, d->apsCtrl) == 1)\n                {\n                    apsEnqueued++;\n                }\n            }\n\n            sub->cleanupStateChanges();\n        }\n    }\n}\n\n/*! #2 This state checks that a valid NodeDescriptor is available.\n */\nvoid DEV_NodeDescriptorStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        if (!device->node()->nodeDescriptor().isNull())\n        {\n            DBG_Printf(DBG_DEV, \"DEV ZDP node descriptor verified: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n            d->maxResponseTime = d->hasRxOnWhenIdle() ? RxOnWhenIdleResponseTime\n                                                      : RxOffWhenIdleResponseTime;\n\n            bool isSleeper = !d->hasRxOnWhenIdle();\n            ResourceItem *capSleeper = device->item(RCapSleeper);\n            if (!capSleeper->lastSet().isValid() || capSleeper->toBool() != isSleeper)\n            {\n                capSleeper->setValue(isSleeper); // can be overwritten by DDF\n            }\n            d->setState(DEV_ActiveEndpointsStateHandler);\n        }\n        else if (!device->reachable()) // can't be queried, go back to #1 init\n        {\n            d->setState(DEV_InitStateHandler);\n        }\n        else\n        {\n            d->zdpResult = ZDP_NodeDescriptorReq(d->node->address(), d->apsCtrl);\n            if (d->zdpResult.isEnqueued)\n            {\n                d->startStateTimer(MaxConfirmTimeout, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(StateLevel0);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(StateLevel0);\n                d->startStateTimer(d->maxResponseTime, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventNodeDescriptor) // received the node descriptor\n    {\n        d->setState(DEV_InitStateHandler); // evaluate egain from state #1 init\n        DEV_EnqueueEvent(device, REventAwake);\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV read ZDP node descriptor timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_InitStateHandler);\n    }\n}\n\n/*! #3 This state checks that active endpoints are known.\n */\nvoid DEV_ActiveEndpointsStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        if (!device->node()->endpoints().empty() && !d->flags.needReadActiveEndpoints)\n        {\n            DBG_Printf(DBG_DEV, \"DEV ZDP active endpoints verified: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n            d->setState(DEV_SimpleDescriptorStateHandler);\n        }\n        else if (!device->reachable())\n        {\n            d->setState(DEV_InitStateHandler);\n        }\n        else\n        {\n            d->zdpResult = ZDP_ActiveEndpointsReq(d->node->address(), d->apsCtrl);\n            if (d->zdpResult.isEnqueued)\n            {\n                d->startStateTimer(MaxConfirmTimeout, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(StateLevel0);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(StateLevel0);\n                d->startStateTimer(d->maxResponseTime, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventActiveEndpoints)\n    {\n        d->flags.needReadActiveEndpoints = 0;\n        d->setState(DEV_InitStateHandler);\n        DEV_EnqueueEvent(device, REventAwake);\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV read ZDP active endpoints timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_InitStateHandler);\n    }\n}\n\n\n/*! #4 This state checks that for all active endpoints simple descriptors are known.\n */\nvoid DEV_SimpleDescriptorStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        quint8 needFetchEp = 0x00;\n\n        if (d->flags.needReadSimpleDescriptors) // forced read to refresh simple descriptors\n        {\n            if (d->zdpNeedFetchEndpointIndex < device->node()->endpoints().size())\n            {\n                needFetchEp = device->node()->endpoints()[d->zdpNeedFetchEndpointIndex];\n            }\n        }\n        else\n        {\n            for (uint8_t ep : device->node()->endpoints())\n            {\n                bool ok = false;\n                for (size_t i = 0; i < device->node()->simpleDescriptors().size(); i++)\n                {\n                    const deCONZ::SimpleDescriptor &sd = device->node()->simpleDescriptors()[i];\n                    if (sd.endpoint() == ep && sd.deviceId() != 0xffff)\n                    {\n                        ok = true;\n                        break;\n                    }\n                }\n\n                if (!ok)\n                {\n                    needFetchEp = ep;\n                    break;\n                }\n            }\n        }\n\n        if (needFetchEp == 0x00)\n        {\n            DBG_Printf(DBG_DEV, \"DEV ZDP simple descriptors verified: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n            d->flags.needReadSimpleDescriptors = 0;\n            d->zdpNeedFetchEndpointIndex = 0xFF;\n            d->setState(DEV_BasicClusterStateHandler);\n        }\n        else if (!device->reachable())\n        {\n            d->setState(DEV_InitStateHandler);\n        }\n        else\n        {\n            d->zdpResult = ZDP_SimpleDescriptorReq(d->node->address(), needFetchEp, d->apsCtrl);\n            if (d->zdpResult.isEnqueued)\n            {\n                d->startStateTimer(MaxConfirmTimeout, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(StateLevel0);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(StateLevel0);\n                d->startStateTimer(d->maxResponseTime, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == REventSimpleDescriptor)\n    {\n        if (d->flags.needReadSimpleDescriptors) // forced read to refresh simple descriptors (next EP)\n        {\n            if (d->zdpNeedFetchEndpointIndex < device->node()->endpoints().size())\n            {\n                d->zdpNeedFetchEndpointIndex += 1;\n            }\n        }\n        d->setState(DEV_InitStateHandler);\n        DEV_EnqueueEvent(device, REventAwake);\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV read ZDP simple descriptor timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_InitStateHandler);\n    }\n}\n\n/*! Returns the first Simple Descriptor for a given server \\p clusterId or nullptr if not found.\n */\nstatic const deCONZ::SimpleDescriptor *DEV_GetSimpleDescriptorForServerCluster(const Device *device, deCONZ::ZclClusterId_t clusterId)\n{\n    for (const auto &sd : device->node()->simpleDescriptors())\n    {\n        const auto cluster = std::find_if(sd.inClusters().cbegin(), sd.inClusters().cend(), [clusterId](const deCONZ::ZclCluster &cl)\n        {\n            return cl.id_t() == clusterId;\n        });\n\n        if (cluster != sd.inClusters().cend())\n        {\n            return &sd;\n        }\n    }\n\n    return nullptr;\n}\n\n/*! Try to fill \\c ResourceItem value from \\p subDevices if not already set.\n */\nbool DEV_FillItemFromSubdevices(Device *device, const char *itemSuffix, const std::vector<Resource*> &subDevices)\n{\n    auto *ditem = device->item(itemSuffix);\n    Q_ASSERT(ditem);\n\n    if (ditem->lastSet().isValid())\n    {\n        return true;\n    }\n\n    for (const auto rsub : subDevices)\n    {\n        auto *sitem = rsub->item(itemSuffix);\n        if (sitem && sitem->lastSet().isValid())\n        {\n            // copy from sub-device into device\n            if (ditem->setValue(sitem->toVariant()))\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/*! Try to fill \\c ResourceItem value from Basic cluster attributes if not already set.\n */\nbool DEV_FillItemFromBasicCluster(Device *device, const char *itemSuffix, deCONZ::ZclClusterId_t clusterId,  deCONZ::ZclAttributeId_t attrId)\n{\n    ResourceItem *ditem = device->item(itemSuffix);\n\n    if (!ditem || !device->node())\n    {\n        return false;\n    }\n\n    if (ditem->lastSet().isValid())\n    {\n        return true;\n    }\n\n    for (const auto &sd : device->node()->simpleDescriptors())\n    {\n        const auto cl = std::find_if(sd.inClusters().cbegin(), sd.inClusters().cend(),\n                                     [clusterId](const auto &x) { return x.id_t() == clusterId; });\n\n        if (cl == sd.inClusters().cend()) { continue; }\n\n        const auto at = std::find_if(cl->attributes().cbegin(), cl->attributes().cend(),\n                                     [attrId](const auto &x){ return x.id_t() == attrId; });\n\n        if (at == cl->attributes().cend()) { continue; }\n\n        const QVariant v = at->toVariant();\n\n        if (!v.isNull() && ditem->setValue(v))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*! Sends a ZCL Read Attributes request for \\p clusterId and \\p attrId.\n    This also configures generic read and parse handlers for an \\p item if not already set.\n */\nbool DEV_ZclRead(Device *device, ResourceItem *item, deCONZ::ZclClusterId_t clusterId, deCONZ::ZclAttributeId_t attrId)\n{\n    Q_ASSERT(device);\n    Q_ASSERT(item);\n\n    DevicePrivate *d = device->d;\n\n    if (!device->reachable())\n    {\n        DBG_Printf(DBG_DEV, \"DEV not reachable, skip read %s: \" FMT_MAC \"\\n\", item->descriptor().suffix, FMT_MAC_CAST(device->key()));\n        return false;\n    }\n\n    const auto *sd = DEV_GetSimpleDescriptorForServerCluster(device, clusterId);\n\n    if (!sd)\n    {\n        DBG_Printf(DBG_DEV, \"DEV TODO cluster 0x%04X not found: \" FMT_MAC \"\\n\", static_cast<quint16>(clusterId), FMT_MAC_CAST(device->key()));\n        return false;\n    }\n\n    ZCL_Param param{};\n    param.valid = 1;\n    param.endpoint = sd->endpoint();\n    param.clusterId = static_cast<quint16>(clusterId);\n    param.attributes[0] = static_cast<quint16>(attrId);\n    param.attributeCount = 1;\n\n    const auto zclResult = ZCL_ReadAttributes(param, device->item(RAttrExtAddress)->toNumber(), device->item(RAttrNwkAddress)->toNumber(), d->apsCtrl);\n\n    d->readResult.isEnqueued = zclResult.isEnqueued;\n    d->readResult.apsReqId = zclResult.apsReqId;\n    d->readResult.sequenceNumber = zclResult.sequenceNumber;\n\n    return d->readResult.isEnqueued;\n}\n\n/*! #5 This state reads all common basic cluster attributes needed to match a DDF,\n    e.g. modelId, manufacturer name, application version, etc.\n */\nvoid DEV_BasicClusterStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        struct _item {\n            const char *suffix;\n            deCONZ::ZclClusterId_t clusterId;\n            deCONZ::ZclAttributeId_t attrId;\n        };\n\n        const std::array<_item, 2> items = {\n            _item{ RAttrManufacturerName, 0x0000_clid, 0x0004_atid },\n            _item{ RAttrModelId,          0x0000_clid, 0x0005_atid }\n        };\n\n        size_t okCount = 0;\n        const auto &subDevices = device->subDevices();\n\n        for (const auto &it : items)\n        {\n            if (DEV_FillItemFromSubdevices(device, it.suffix, subDevices))\n            {\n                okCount++;\n                continue;\n            }\n            else if (DEV_FillItemFromBasicCluster(device, it.suffix, it.clusterId,  it.attrId))\n            {\n                okCount++;\n                continue;\n            }\n\n            if (DEV_ZclRead(device, device->item(it.suffix), it.clusterId, it.attrId))\n            {\n                d->startStateTimer(MaxConfirmTimeout, StateLevel0);\n                return; // keep state and wait for REventStateTimeout or response\n            }\n\n            DBG_Printf(DBG_DEV, \"DEV failed to read %s: \" FMT_MAC \"\\n\", it.suffix, FMT_MAC_CAST(device->key()));\n            break;\n        }\n\n        if (okCount != items.size())\n        {\n            d->setState(DEV_InitStateHandler);\n        }\n        else\n        {\n            DBG_Printf(DBG_DEV, \"DEV modelId: %s, \" FMT_MAC \"\\n\", qPrintable(device->item(RAttrModelId)->toString()), FMT_MAC_CAST(device->key()));\n            d->setState(DEV_GetDeviceDescriptionHandler);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(StateLevel0);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->readResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(StateLevel0);\n                d->startStateTimer(d->maxResponseTime, StateLevel0);\n            }\n            else\n            {\n                d->setState(DEV_InitStateHandler);\n            }\n        }\n    }\n    else if (event.what() == RAttrManufacturerName || event.what() == RAttrModelId)\n    {\n        DBG_Printf(DBG_DEV, \"DEV received %s: \" FMT_MAC \"\\n\", event.what(), FMT_MAC_CAST(device->key()));\n        d->setState(DEV_InitStateHandler); // ok re-evaluate\n        DEV_EnqueueEvent(device, REventAwake);\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV read basic cluster timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_InitStateHandler);\n    }\n}\n\n/*! Forward device attributes to core to show it in the GUI.\n */\nvoid DEV_PublishToCore(Device *device)\n{\n\n    struct CoreItem\n    {\n        const char *suffix;\n        const char *mapped;\n    };\n\n    std::array<CoreItem, 4> coreItems = {\n        {\n            { RAttrName, \"name\" },\n            { RAttrModelId, \"modelid\" },\n            { RAttrManufacturerName, \"vendor\" },\n            { RAttrSwVersion, \"version\" }\n        }\n    };\n\n    const auto subDevices = device->subDevices();\n    if (!subDevices.empty())\n    {\n        for (const CoreItem &i : coreItems)\n        {\n            const auto *item = subDevices.front()->item(i.suffix);\n            if (item && !item->toString().isEmpty())\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(i.mapped), item->toString());\n            }\n        }\n    }\n}\n\n/*! #6 This state checks if for the device a device description file (DDF) is available.\n\n    In that case the device is initialised (or updated) based on the JSON description.\n    The actual processing is delegated to \\c DeviceDescriptions class. This is done async\n    so thousands of DDF files can be lazy loaded.\n */\nvoid DEV_GetDeviceDescriptionHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        // if there is a IAS Zone Cluster add the RAttrZoneType\n        if (DEV_GetSimpleDescriptorForServerCluster(device, 0x0500_clid))\n        {\n            device->addItem(DataTypeUInt16, RAttrZoneType);\n        }\n        DEV_EnqueueEvent(device, REventDDFInitRequest);\n    }\n    else if (event.what() == REventDDFInitResponse)\n    {\n        DEV_PublishToCore(device);\n\n        if (event.num() == 1 || event.num() == 3)\n        {\n            d->managed = true;\n            d->flags.hasDdf = 1;\n            d->setState(DEV_IdleStateHandler);\n            // TODO(mpi): temporary forward this info here, gets replaced by device actor later\n            if (event.num() == 1)\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(\"hasddf\"), QLatin1String(\"1\"));\n            }\n            else if (event.num() == 3)\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(\"hasddf\"), QLatin1String(\"2\"));\n            }\n        }\n        else\n        {\n            d->managed = false;\n            d->flags.hasDdf = 0;\n            d->setState(DEV_DeadStateHandler);\n        }\n    }\n}\n\nvoid DEV_CheckReachable(Device *device)\n{\n    DevicePrivate *d = device->d;\n    bool devReachable = device->reachable();\n\n    for (Resource *r : d->subResources)\n    {\n        ResourceItem *item = r->item(RConfigReachable);\n        if (!item)\n        {\n            item = r->item(RStateReachable);\n        }\n\n        if (item && ((item->toBool() != devReachable) || !item->lastSet().isValid()))\n        {\n            r->setValue(item->descriptor().suffix, devReachable);\n        }\n    }\n}\n\n/*! #7 In this state the device is operational and runs sub states\n    In parallel.\n\n    IdleState : Bindings | Polling | ItemChange\n */\nvoid DEV_IdleStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DEV_CheckReachable(device);\n        d->binding.bindingIter = 0;\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        d->setState(DEV_PollIdleStateHandler, STATE_LEVEL_POLL);\n        return;\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->setState(nullptr, STATE_LEVEL_BINDING);\n        d->setState(nullptr, STATE_LEVEL_POLL);\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n        d->stopStateTimer(STATE_LEVEL_POLL);\n        return;\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n        {\n            d->idleApsConfirmErrors = 0;\n        }\n        else\n        {\n            d->idleApsConfirmErrors++;\n\n            if (d->idleApsConfirmErrors > MaxIdleApsConfirmErrors && device->item(RStateReachable)->toBool())\n            {\n                d->idleApsConfirmErrors = 0;\n                DBG_Printf(DBG_DEV, \"DEV Idle max APS confirm errors: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n                device->item(RStateReachable)->setValue(false);\n                DEV_CheckReachable(device);\n            }\n        }\n    }\n    else if (event.what() != RAttrLastSeen && event.what() != REventPoll)\n    {\n        // DBG_Printf(DBG_DEV, \"DEV Idle event %s/0x%016llX/%s\\n\", event.resource(), event.deviceKey(), event.what());\n        if (event.what() == RAttrSwVersion || event.what() == RAttrName)\n        {\n            DEV_PublishToCore(device);\n        }\n    }\n\n    if (!device->reachable() && !device->item(RCapSleeper)->toBool())\n    {\n        DBG_Printf(DBG_DEV, \"DEV (NOT reachable) Idle event %s/\" FMT_MAC \"/%s\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()), event.what());\n    }\n\n    DEV_CheckItemChanges(device, event);\n\n    // process parallel states\n    for (int i = StateLevel1; i < StateLevelMax; i++)\n    {\n        device->handleEvent(event, DEV_StateLevel(i));\n    }\n}\n\n/*! Bindings sub state machien is described in:\n\n      https://github.com/dresden-elektronik/deconz-rest-plugin-v2/wiki/Device-Class#bindings-sub-state-machine\n*/\n\nvoid DEV_BindingHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Binding enter %s/\" FMT_MAC \"\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()));\n    }\n    else if (event.what() == REventPoll || event.what() == REventAwake || event.what() == REventBindingTick)\n    {\n        if (DA_ApsUnconfirmedRequests() > 4)\n        {\n            // wait\n        }\n        else\n        {\n            d->binding.bindingIter = 0;\n            if (d->binding.mgmtBindSupported == MGMT_BIND_NOT_SUPPORTED)\n            {\n                d->setState(DEV_BindingTableVerifyHandler, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingTableReadHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventBindingTable)\n    {\n        if (event.num() == deCONZ::ZdpSuccess)\n        {\n            d->binding.mgmtBindSupported = MGMT_BIND_SUPPORTED;\n        }\n        else if (event.num() == deCONZ::ZdpNotSupported)\n        {\n            d->binding.mgmtBindSupported = MGMT_BIND_NOT_SUPPORTED;\n        }\n    }\n}\n\ndeCONZ::Binding DEV_ToCoreBinding(const DDF_Binding &bnd, quint64 srcAddress)\n{\n    if (bnd.isUnicastBinding)\n    {\n        return deCONZ::Binding(srcAddress, bnd.dstExtAddress, bnd.clusterId, bnd.srcEndpoint, bnd.dstEndpoint);\n    }\n    else if (bnd.isGroupBinding)\n    {\n        return deCONZ::Binding(srcAddress, bnd.dstGroup, bnd.clusterId, bnd.srcEndpoint);\n    }\n\n    Q_ASSERT(0);\n    return {};\n}\n\nvoid DEV_BindingTableReadHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Binding read bindings %s/\" FMT_MAC \"\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()));\n        d->binding.mgmtBindStartIndex = 0;\n        DEV_EnqueueEvent(device, REventBindingTick);\n    }\n    else if (event.what() == REventBindingTick)\n    {\n        d->zdpResult = ZDP_MgmtBindReq(d->binding.mgmtBindStartIndex, d->node->address(), d->apsCtrl);\n\n        if (d->zdpResult.isEnqueued)\n        {\n            d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_BINDING);\n        }\n        else\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(STATE_LEVEL_BINDING);\n                d->startStateTimer(d->maxResponseTime, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventZdpMgmtBindResponse)\n    {\n        uint8_t buf[128];\n        if (event.hasData() && event.dataSize() >= 2 && event.dataSize() < sizeof(buf))\n        {\n            if (event.getData(buf, event.dataSize()))\n            {\n                const uint8_t seq = buf[0];\n                const uint8_t status = buf[1];\n\n                if (seq != d->zdpResult.zdpSeq)\n                {\n                    return;\n                }\n\n                if (status == deCONZ::ZdpSuccess)\n                {\n                    d->stopStateTimer(STATE_LEVEL_BINDING);\n\n                    d->binding.mgmtBindSupported = MGMT_BIND_SUPPORTED;\n\n                    uint8_t size = 0;\n                    uint8_t index = 0;\n                    uint8_t count = 0;\n\n                    if (event.dataSize() >= 5)\n                    {\n                        size = buf[2];\n                        index = buf[3];\n                        count = buf[4];\n                    }\n\n                    if (size > index + count)\n                    {\n                        d->binding.mgmtBindStartIndex = index + count;\n                        DEV_EnqueueEvent(device, REventBindingTick); // process next\n                    }\n                    else\n                    {\n                        d->binding.bindingIter = 0;\n                        d->setState(DEV_BindingTableVerifyHandler, STATE_LEVEL_BINDING);\n                    }\n                }\n                else\n                {\n                    if (status == deCONZ::ZdpNotSupported || status == deCONZ::ZdpNotPermitted)\n                    {\n                        d->binding.mgmtBindSupported = MGMT_BIND_NOT_SUPPORTED;\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_DEV, \"DEV ZDP read binding table error: \" FMT_MAC \", status: 0x%02X (TODO handle?)\\n\", FMT_MAC_CAST(device->key()), status);\n                    }\n                    d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n                }\n            }\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZDP read binding table timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nvoid DEV_BindingTableVerifyHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Binding verify bindings %s/\" FMT_MAC \"\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()));\n        DEV_EnqueueEvent(device, REventBindingTick);\n    }\n    else if (event.what() != REventBindingTick)\n    {\n\n    }\n    else if (d->binding.bindingIter >= d->binding.bindings.size())\n    {\n        d->binding.bindingCheckRound++;\n        d->setState(DEV_BindingRemoveHandler, STATE_LEVEL_BINDING);\n    }\n    else\n    {\n        auto &ddfBinding = d->binding.bindings[d->binding.bindingIter];\n        auto &tracker = d->binding.bindingTrackers[d->binding.bindingIter];\n\n        if (ddfBinding.dstExtAddress == 0 && ddfBinding.isUnicastBinding)\n        {\n            ddfBinding.dstExtAddress = d->apsCtrl->getParameter(deCONZ::ParamMacAddress);\n            DBG_Assert(ddfBinding.dstExtAddress != 0);\n\n            if (ddfBinding.dstExtAddress == 0)\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n                return;\n            }\n        }\n        else if (ddfBinding.isGroupBinding)\n        {\n            bool ok = false;\n\n            // update destination group based on RConfigGroup\n            for (const auto &sub : device->subDevices())\n            {\n                ResourceItem *configGroup = sub->item(RConfigGroup);\n                if (!configGroup)\n                {\n                    continue;\n                }\n\n                const auto ls = configGroup->toString().split(',', SKIP_EMPTY_PARTS);\n                if (ddfBinding.configGroup >= ls.size())\n                {\n                    ddfBinding.dstGroup = 0; // clear\n                    break;\n                }\n\n                uint group = ls[ddfBinding.configGroup].toUShort(&ok, 0);\n                if (ok && group != 0)\n                {\n                    ddfBinding.dstGroup = group;\n                }\n                break;\n            }\n\n            if (!ok)\n            {\n                d->binding.bindingIter++; // process next\n                DEV_EnqueueEvent(device, REventBindingTick);\n                return;\n            }\n        }\n\n        const auto &bindingTable = device->node()->bindingTable();\n        const auto bnd = DEV_ToCoreBinding(ddfBinding, d->deviceKey);\n\n        const auto i = std::find(bindingTable.const_begin(), bindingTable.const_end(), bnd);\n\n        bool needBind = false;\n\n        if (i == bindingTable.const_end())\n        {\n            needBind = true;\n        }\n        else\n        {\n            if (tracker.tBound < i->confirmedTimeRef())\n            {\n                tracker.tBound = i->confirmedTimeRef();\n            }\n            const auto now = deCONZ::steadyTimeRef();\n            const auto dt = isValid(tracker.tBound) ? (now - tracker.tBound).val / 1000 : -1;\n\n            if (i->dstAddressMode() == deCONZ::ApsExtAddress)\n            {\n                DBG_Printf(DBG_DEV, \"DEV BND \" FMT_MAC \" cl: 0x%04X, dstAddrmode: %u, dst: \" FMT_MAC \", dstEp: 0x%02X, dt: %d seconds\\n\",\n                           FMT_MAC_CAST(i->srcAddress()), i->clusterId(), i->dstAddressMode(), FMT_MAC_CAST(i->dstAddress().ext()), i->dstEndpoint(), (int)dt);\n            }\n            else if (i->dstAddressMode() == deCONZ::ApsGroupAddress)\n            {\n                DBG_Printf(DBG_DEV, \"DEV BND  \" FMT_MAC \" cl: 0x%04X, dstAddrmode: %u, group: 0x%04X, dstEp: 0x%02X, dt: %d seconds\\n\",\n                           FMT_MAC_CAST(i->srcAddress()), i->clusterId(), i->dstAddressMode(), i->dstAddress().group(), i->dstEndpoint(), (int)dt);\n            }\n\n            if (dt < 0 || dt > 1800) // TODO max value\n            {\n                needBind = true;\n            }\n        }\n\n        if (needBind)\n        {\n            d->setState(DEV_BindingCreateHandler, STATE_LEVEL_BINDING);\n        }\n        else if (i->dstAddressMode() == deCONZ::ApsExtAddress)\n        {\n            d->binding.configIter = 0;\n            d->binding.reportIter = 0;\n            d->setState(DEV_ReadReportConfigurationHandler, STATE_LEVEL_BINDING);\n        }\n        else if (i->dstAddressMode() == deCONZ::ApsGroupAddress)\n        {\n            d->binding.bindingIter++; // process next\n            DEV_EnqueueEvent(device, REventBindingTick);\n        }\n    }\n}\n\nstatic void DEV_ProcessNextBinding(Device *device)\n{\n    DevicePrivate *d = device->d;\n\n    d->binding.bindingIter++;\n    d->setState(DEV_BindingTableVerifyHandler, STATE_LEVEL_BINDING);\n}\n\nvoid DEV_BindingCreateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        const auto &ddfBinding = d->binding.bindings[d->binding.bindingIter];\n        auto &tracker = d->binding.bindingTrackers[d->binding.bindingIter];\n        tracker.tBound = {};\n\n        const auto bnd = DEV_ToCoreBinding(ddfBinding, d->deviceKey);\n\n        d->zdpResult = ZDP_BindReq(bnd, d->apsCtrl);\n\n        if (d->zdpResult.isEnqueued)\n        {\n            d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_BINDING);\n        }\n        else\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(STATE_LEVEL_BINDING);\n                d->startStateTimer(d->maxResponseTime, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventZdpResponse)\n    {\n        if (EventZdpResponseSequenceNumber(event) == d->zdpResult.zdpSeq)\n        {\n            if (EventZdpResponseStatus(event) == deCONZ::ZdpSuccess)\n            {\n                BindingTracker &tracker = d->binding.bindingTrackers[d->binding.bindingIter];\n                tracker.tBound = deCONZ::steadyTimeRef();\n                d->setState(DEV_BindingTableVerifyHandler, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZDP create binding timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nvoid DEV_BindingRemoveHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        const auto &bindingTable = device->node()->bindingTable();\n        auto i = bindingTable.const_begin();\n        auto end = bindingTable.const_end();\n\n        for (; i != end; ++i)\n        {\n            if (i->dstAddressMode() == deCONZ::ApsGroupAddress)\n            {\n                bool hasDdfBinding = false;\n                bool hasDdfGroup = false;\n\n                for (const auto &ddfBinding : d->binding.bindings)\n                {\n                    if (ddfBinding.isGroupBinding &&\n                        i->clusterId() == ddfBinding.clusterId &&\n                        i->srcEndpoint() == ddfBinding.srcEndpoint)\n                    {\n                        hasDdfBinding = true;\n                        if (i->dstAddress().group() == ddfBinding.dstGroup)\n                        {\n                            hasDdfGroup = true;\n                            break;\n                        }\n                    }\n                }\n\n                if (hasDdfBinding && !hasDdfGroup)\n                {\n                    break;\n                }\n            }\n        }\n\n        if (i == bindingTable.const_end())\n        {\n            d->setState(DEV_BindingIdleHandler, STATE_LEVEL_BINDING);\n            return;\n        }\n\n        d->zdpResult = ZDP_UnbindReq(*i, d->apsCtrl);\n\n        if (d->zdpResult.isEnqueued)\n        {\n            d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_BINDING);\n        }\n        else\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->zdpResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(STATE_LEVEL_BINDING);\n                d->startStateTimer(d->maxResponseTime, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventZdpResponse)\n    {\n        if (EventZdpResponseSequenceNumber(event) == d->zdpResult.zdpSeq)\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            DEV_EnqueueEvent(device, REventBindingTick);\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZDP remove binding timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nstatic bool reportingConfigurationValid(const Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n    ZCL_ReadReportConfigurationRsp rsp{};\n\n    if (!event.getData(&rsp, sizeof(rsp)))\n    {\n        return false;\n    }\n\n    const auto &bnd = d->binding.bindings[d->binding.bindingIter];\n\n    size_t okCount = 0;\n\n    for (size_t i = 0; i < rsp.recordCount; i++)\n    {\n        const auto &record = rsp.records[i];\n\n        for (const auto &report : bnd.reporting)\n        {\n            bool found = false;\n            for (auto &rec : d->binding.readReportParam.records) // compare with request\n            {\n                if (rec.attributeId == report.attributeId && rec.direction == report.direction)\n                {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found || record.status != deCONZ::ZclSuccessStatus) { continue; }\n            if (report.manufacturerCode != rsp.manufacturerCode) { continue; }\n            if (report.attributeId != record.attributeId) { continue; }\n            if (report.minInterval != record.minInterval) { continue; }\n            if (report.maxInterval != record.maxInterval) { continue; }\n            if (report.reportableChange != record.reportableChange) { continue; }\n\n            okCount++;\n\n            DBG_Printf(DBG_DEV, \"DEV ZCL report configuration cl: 0x%04X, at: 0x%04X OK \" FMT_MAC \"\\n\", rsp.clusterId, record.attributeId, FMT_MAC_CAST(device->key()));\n        }\n    }\n\n    if (okCount == d->binding.readReportParam.records.size())\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZCL report configuration cl: 0x%04X, mfcode: 0x%04X verified \" FMT_MAC \"\\n\", rsp.clusterId, rsp.manufacturerCode, FMT_MAC_CAST(device->key()));\n        return true;\n    }\n    else\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZCL report configuration cl: 0x%04X, mfcode: 0x%04X needs update \" FMT_MAC \"\\n\", rsp.clusterId, rsp.manufacturerCode, FMT_MAC_CAST(device->key()));\n        return false;\n    }\n}\n\nvoid DEV_ReadReportConfigurationHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        Q_ASSERT(d->binding.bindingIter < d->binding.bindings.size());\n        const auto &bnd = d->binding.bindings[d->binding.bindingIter];\n\n        if (bnd.reporting.empty())\n        {\n            DEV_ProcessNextBinding(device);\n            return;\n        }\n\n        ZCL_ReadReportConfigurationParam &param = d->binding.readReportParam;\n        param = {};\n\n        param.extAddress = device->node()->address().ext();\n        param.nwkAddress = device->node()->address().nwk();\n        param.clusterId = bnd.clusterId;\n        param.manufacturerCode = 0;\n        param.endpoint = bnd.srcEndpoint;\n\n        auto tnow = deCONZ::steadyTimeRef();\n\n        for (; d->binding.reportIter < bnd.reporting.size(); d->binding.reportIter++)\n        {\n            const DDF_ZclReport &report = bnd.reporting[d->binding.reportIter];\n            ReportTracker &tracker = DEV_GetOrCreateReportTracker(device, bnd.clusterId, report.attributeId, bnd.srcEndpoint);\n\n            if (d->binding.bindingCheckRound == 0)\n            {\n                // always verify on first round (needed for DDF hot reloading)\n            }\n            else if ((tnow - tracker.lastConfigureCheck) < deCONZ::TimeSeconds{3600})\n            {\n                DBG_Printf(DBG_DEV, \"DEV \" FMT_MAC \" skip read ZCL report config for 0x%04X / 0x%04X\\n\", FMT_MAC_CAST(d->deviceKey), bnd.clusterId, report.attributeId);\n                continue;\n            }\n\n            if (param.records.empty()) // only include matching manufacturer code reports in one frame\n            {\n                param.manufacturerCode = report.manufacturerCode;\n            }\n            else if (param.manufacturerCode != report.manufacturerCode)\n            {\n                break; // proceed later\n            }\n\n            tracker.lastConfigureCheck.ref = MarkZclConfigureBusy;\n\n            ZCL_ReadReportConfigurationParam::Record record{};\n\n            record.attributeId = report.attributeId;\n            record.direction = report.direction;\n\n            param.records.push_back(record);\n\n            if (param.records.size() == ZCL_ReadReportConfigurationParam::MaxRecords)\n            {\n                break;\n            }\n        }\n\n        if (param.records.empty())\n        {\n            DEV_ProcessNextBinding(device);\n            return;\n        }\n\n        d->binding.zclResult = ZCL_ReadReportConfiguration(param, d->apsCtrl);\n\n        if (d->binding.zclResult.isEnqueued)\n        {\n            d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_BINDING);\n        }\n        else\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->binding.zclResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(STATE_LEVEL_BINDING);\n                d->startStateTimer(d->maxResponseTime, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventZclReadReportConfigResponse)\n    {\n        if (reportingConfigurationValid(device, event))\n        {\n            const auto tnow = deCONZ::steadyTimeRef();\n\n            for (ReportTracker &tracker : d->binding.reportTrackers)\n            {\n                if (tracker.lastConfigureCheck.ref == MarkZclConfigureBusy)\n                {\n                    tracker.lastConfigureCheck = tnow;\n                }\n            }\n\n            auto &bnd = d->binding.bindings[d->binding.bindingIter];\n\n            if (d->binding.reportIter < bnd.reporting.size())\n            {\n                d->setState(DEV_ReadNextReportConfigurationHandler, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                DEV_ProcessNextBinding(device);\n            }\n        }\n        else\n        {\n            d->setState(DEV_ConfigureReportingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZCL read report configuration timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\n/*! Helper state to proceed with the next reporting check. */\nvoid DEV_ReadNextReportConfigurationHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        d->setState(DEV_ReadReportConfigurationHandler, STATE_LEVEL_BINDING);\n    }\n}\n\n/*! Helper state to proceed with the next configure reporting. */\nvoid DEV_ConfigureNextReportConfigurationHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        d->setState(DEV_ConfigureReportingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nvoid DEV_ConfigureReportingHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        const auto &bnd = d->binding.bindings[d->binding.bindingIter];\n        Q_ASSERT(!bnd.reporting.empty());\n\n        ZCL_ConfigureReportingParam param{};\n\n        param.extAddress = device->node()->address().ext();\n        param.nwkAddress = device->node()->address().nwk();\n        param.clusterId = bnd.clusterId;\n        param.manufacturerCode = d->binding.readReportParam.manufacturerCode;\n        param.endpoint = bnd.srcEndpoint;\n\n        for (size_t i = d->binding.configIter; i < d->binding.reportIter && i < bnd.reporting.size(); i++)\n        {\n            const DDF_ZclReport &report = bnd.reporting[i];\n            d->binding.configIter++;\n\n            if (report.manufacturerCode != param.manufacturerCode)\n            {\n                continue;\n            }\n\n            ZCL_ConfigureReportingParam::Record record{};\n\n            record.attributeId = report.attributeId;\n            record.direction = report.direction;\n            record.dataType = report.dataType;\n            record.minInterval = report.minInterval;\n            record.maxInterval = report.maxInterval;\n            record.reportableChange = report.reportableChange;\n            record.timeout = 0; // TODO\n\n            param.records.push_back(record);\n\n            if (param.records.size() == ZCL_ConfigureReportingParam::MaxRecords)\n            {\n                break; // prevent too large APS frames\n            }\n        }\n\n        d->binding.zclResult.isEnqueued = false;\n\n        if (!param.records.empty())\n        {\n            d->binding.zclResult = ZCL_ConfigureReporting(param, d->apsCtrl);\n        }\n\n        if (d->binding.zclResult.isEnqueued)\n        {\n            d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_BINDING);\n        }\n        else\n        {\n            d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventApsConfirm)\n    {\n        if (d->binding.zclResult.apsReqId == EventApsConfirmId(event))\n        {\n            if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n            {\n                d->stopStateTimer(STATE_LEVEL_BINDING);\n                d->startStateTimer(d->maxResponseTime, STATE_LEVEL_BINDING);\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventZclResponse)\n    {\n        if (d->binding.zclResult.sequenceNumber == EventZclSequenceNumber(event))\n        {\n            DBG_Printf(DBG_DEV, \"DEV configure reporting %s/\" FMT_MAC \" ZCL response seq: %u, status: 0x%02X\\n\",\n                   event.resource(), FMT_MAC_CAST(event.deviceKey()), d->binding.zclResult.sequenceNumber, EventZclStatus(event));\n\n            if (EventZclStatus(event) == deCONZ::ZclSuccessStatus)\n            {\n                auto &bnd = d->binding.bindings[d->binding.bindingIter];\n\n                if (d->binding.configIter < d->binding.reportIter)\n                {\n                    d->setState(DEV_ConfigureNextReportConfigurationHandler, STATE_LEVEL_BINDING);\n                }\n                else if (d->binding.reportIter < bnd.reporting.size())\n                {\n                    d->setState(DEV_ReadNextReportConfigurationHandler, STATE_LEVEL_BINDING);\n                }\n                else\n                {\n                    DEV_ProcessNextBinding(device);\n                }\n            }\n            else\n            {\n                d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n            }\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV ZCL configure reporting timeout: \" FMT_MAC \"\\n\", FMT_MAC_CAST(device->key()));\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nvoid DEV_BindingIdleHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Binding idle enter %s/\" FMT_MAC \"\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()));\n        d->startStateTimer(BindingAutoCheckInterval, STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_BINDING);\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nstatic ReportTracker &DEV_GetOrCreateReportTracker(Device *device, uint16_t clusterId, uint16_t attrId, uint8_t endpoint)\n{\n    DevicePrivate *d = device->d;\n\n    auto i = std::find_if(d->binding.reportTrackers.begin(), d->binding.reportTrackers.end(), [&](ReportTracker &tracker) {\n        return tracker.endpoint == endpoint &&\n               tracker.clusterId == clusterId &&\n               tracker.attributeId == attrId;\n    });\n\n    if (i != d->binding.reportTrackers.end())\n    {\n        return *i;\n    }\n\n    ReportTracker tracker;\n\n    tracker.endpoint = endpoint;\n    tracker.clusterId = clusterId;\n    tracker.attributeId = attrId;\n\n    d->binding.reportTrackers.push_back(tracker);\n\n    return d->binding.reportTrackers.back();\n}\n\nstatic void DEV_UpdateReportTracker(Device *device, const ResourceItem *item)\n{\n    if (!isValid(item->lastZclReport()))\n    {\n        return;\n    }\n\n    const ZCL_Param &zclParam = item->zclParam();\n    if (!isValid(zclParam) || zclParam.attributeCount == 0)\n    {\n        return;\n    }\n\n    Q_ASSERT(zclParam.attributeCount < zclParam.attributes.size());\n\n    for (size_t i = 0; i < zclParam.attributeCount && i < zclParam.attributes.size(); i++)\n    {\n        ReportTracker &tracker = DEV_GetOrCreateReportTracker(device, zclParam.clusterId, zclParam.attributes[i], zclParam.endpoint);\n        tracker.lastReport = item->lastZclReport();\n    }\n}\n\n/*! Returns all items wich are ready for polling.\n    The returned vector is reversed to use std::vector::pop_back() when processing the queue.\n */\nstd::vector<DEV_PollItem> DEV_GetPollItems(Device *device)\n{\n    DevicePrivate *d = device->d;\n    std::vector<DEV_PollItem> result;\n    const auto now = QDateTime::currentDateTime();\n    const auto tnow = deCONZ::steadyTimeRef();\n\n    for (const auto *r : device->subDevices())\n    {\n        for (int i = 0; i < r->itemCount(); i++)\n        {\n            const auto *item = r->itemForIndex(size_t(i));\n\n            if (item->zclUnsupportedAttribute())\n            {\n                continue;\n            }\n\n            DEV_UpdateReportTracker(device, item);\n\n            const auto &ddfItem = DDF_GetItem(item);\n\n            if (ddfItem.readParameters.isNull())\n            {\n                continue;\n            }\n\n            int64_t dt = -1;\n\n            if (item->refreshInterval().val == 0)\n            {\n\n            }\n            else\n            {\n                if (isValid(item->lastZclReport()))\n                {\n                    dt = (tnow - item->lastZclReport()).val / 1000;\n                    if (dt < item->refreshInterval().val)\n                    {\n                        continue;\n                    }\n                }\n\n                if (item->lastSet().isValid() && item->valueSource() == ResourceItem::SourceDevice)\n                {\n                    const auto dt2 = item->lastSet().secsTo(now);\n                    if (dt2  < item->refreshInterval().val)\n                    {\n                        continue;\n                    }\n\n                    dt = dt2;\n                }\n            }\n\n            const auto m = ddfItem.readParameters.toMap();\n            if (m.empty())\n            {\n                continue;\n            }\n\n            if (m.contains(QLatin1String(\"fn\")) && m.value(QLatin1String(\"fn\")).toString() == QLatin1String(\"none\"))\n            {\n                continue;\n            }\n\n            DBG_Printf(DBG_DEV, \"DEV \" FMT_MAC \" read %s, dt %d sec\\n\", FMT_MAC_CAST(d->deviceKey), item->descriptor().suffix, int(dt));\n            result.emplace_back(DEV_PollItem{r, item, ddfItem.readParameters});\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n\n/*! This state waits for REventPoll (and later REventPollForce).\n    It collects all poll worthy items in a queue and moves to the PollNext state.\n */\nvoid DEV_PollIdleStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Poll Idle enter %s/\" FMT_MAC \"\\n\", event.resource(), FMT_MAC_CAST(event.deviceKey()));\n    }\n    else if (event.what() == REventPoll || event.what() == REventAwake)\n    {\n        if (DA_ApsUnconfirmedRequests() > 4)\n        {\n            // wait\n            return;\n        }\n\n        if (device->node()) // update nwk address if needed\n        {\n            const auto &addr = device->node()->address();\n            if (addr.hasNwk() && addr.nwk() != device->item(RAttrNwkAddress)->toNumber())\n            {\n                device->item(RAttrNwkAddress)->setValue(addr.nwk());\n            }\n        }\n\n        if (d->flags.needZDPMaintenanceOnce)\n        {\n            // use some jitter to spread the the one time refresh of ZDP stuff\n            static int randomDelay = 0;\n            randomDelay++;\n            if (randomDelay > (d->deviceKey & 0xFF))\n            {\n                randomDelay = 0;\n                d->flags.needZDPMaintenanceOnce = 0;\n\n                if (!device->item(RCapSleeper)->toBool() && device->reachable())\n                {\n                    d->flags.needReadActiveEndpoints = 1;\n                    d->flags.needReadSimpleDescriptors = 1;\n                    d->zdpNeedFetchEndpointIndex = 0;\n                    DEV_EnqueueEvent(device, REventZdpReload);\n                    return;\n                }\n            }\n        }\n\n\n        d->pollItems = DEV_GetPollItems(device);\n\n        if (!d->pollItems.empty())\n        {\n            d->setState(DEV_PollNextStateHandler, STATE_LEVEL_POLL);\n            return;\n        }\n    }\n}\n\n/*! This state processes the next DEV_PollItem and moves to the PollBusy state.\n    If no more items are in the queue it moves back to PollIdle state.\n */\nvoid DEV_PollNextStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter || event.what() == REventStateTimeout)\n    {\n        Q_ASSERT(event.num() == STATE_LEVEL_POLL); // TODO remove\n        if (!device->reachable())\n        {\n            d->pollItems.clear();\n        }\n\n        if (d->pollItems.empty())\n        {\n            d->setState(DEV_PollIdleStateHandler, STATE_LEVEL_POLL);\n            return;\n        }\n\n        auto &poll = d->pollItems.back();\n        const auto readFunction = DA_GetReadFunction(poll.readParameters);\n\n        d->readResult = { };\n        if (readFunction)\n        {\n            d->readResult = readFunction(poll.resource, poll.item, d->apsCtrl, poll.readParameters);\n        }\n        else\n        {\n            DBG_Printf(DBG_DEV, \"DEV Poll Next no read function for item: %s / \" FMT_MAC \"\\n\", poll.item->descriptor().suffix, FMT_MAC_CAST(device->key()));\n            d->pollItems.pop_back();\n            d->startStateTimer(5, STATE_LEVEL_POLL); // try next\n            return;\n        }\n\n        if (d->readResult.isEnqueued)\n        {\n            d->setState(DEV_PollBusyStateHandler, STATE_LEVEL_POLL);\n        }\n        else\n        {\n            poll.retry++;\n\n            DBG_Printf(DBG_DEV, \"DEV Poll Next failed to enqueue read item: %s / \" FMT_MAC \"\\n\", poll.item->descriptor().suffix, FMT_MAC_CAST(device->key()));\n            if (poll.retry >= MaxPollItemRetries)\n            {\n                d->pollItems.pop_back();\n            }\n            d->startStateTimer(d->maxResponseTime, STATE_LEVEL_POLL); // try again\n        }\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_POLL);\n    }\n}\n\n/*! Increments retry counter of an item, or throws it away if maximum is reached. */\nstatic void checkPollItemRetry(std::vector<DEV_PollItem> &pollItems)\n{\n    if (!pollItems.empty())\n    {\n        auto &pollItem = pollItems.back();\n        pollItem.retry++;\n\n        if (pollItem.retry >= MaxPollItemRetries)\n        {\n            pollItems.pop_back();\n        }\n    }\n}\n\n/*! This state waits for APS confirm or timeout for an ongoing poll request.\n    In any case it moves back to PollNext state.\n    If the request is successful the DEV_PollItem will be removed from the queue.\n */\nvoid DEV_PollBusyStateHandler(Device *device, const Event &event)\n{\n    DevicePrivate *d = device->d;\n\n    if (event.what() == REventStateEnter)\n    {\n        d->startStateTimer(MaxConfirmTimeout, STATE_LEVEL_POLL);\n    }\n    else if (event.what() == REventStateLeave)\n    {\n        d->stopStateTimer(STATE_LEVEL_POLL);\n    }\n    else if (event.what() == REventApsConfirm && EventApsConfirmId(event) == d->readResult.apsReqId)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Poll Busy %s/\" FMT_MAC \" APS-DATA.confirm id: %u, ZCL seq: %u, status: 0x%02X\\n\",\n                   event.resource(), FMT_MAC_CAST(event.deviceKey()), d->readResult.apsReqId, d->readResult.sequenceNumber, EventApsConfirmStatus(event));\n\n        if (EventApsConfirmStatus(event) == deCONZ::ApsSuccessStatus)\n        {\n            d->idleApsConfirmErrors = 0;\n            d->stopStateTimer(StateLevel0);\n            d->startStateTimer(d->maxResponseTime, STATE_LEVEL_POLL);\n        }\n        else\n        {\n            checkPollItemRetry(d->pollItems);\n            d->setState(DEV_PollNextStateHandler, STATE_LEVEL_POLL);\n        }\n    }\n    else if (event.what() == REventZclResponse)\n    {\n        if (d->readResult.clusterId != EventZclClusterId(event))\n        { }\n        else if (d->readResult.sequenceNumber == EventZclSequenceNumber(event) || d->readResult.ignoreResponseSequenceNumber)\n        {\n            uint8_t status = EventZclStatus(event);\n            DBG_Printf(DBG_DEV, \"DEV Poll Busy %s/\" FMT_MAC \" ZCL response seq: %u, status: 0x%02X, cluster: 0x%04X\\n\",\n                   event.resource(), FMT_MAC_CAST(event.deviceKey()), d->readResult.sequenceNumber, status, d->readResult.clusterId);\n\n            DBG_Assert(!d->pollItems.empty());\n            if (!d->pollItems.empty())\n            {\n                if (status == deCONZ::ZclUnsupportedAttributeStatus)\n                {\n                    const auto &pi = d->pollItems.back();\n                    Resource *r = DEV_GetResource(pi.resource->handle());\n                    ResourceItem *item = r ? r->item(pi.item->descriptor().suffix) : nullptr;\n\n                    if (item)\n                    {\n                        item->setZclUnsupportedAttribute();\n                    }\n                }\n\n                d->pollItems.pop_back();\n            }\n            d->setState(DEV_PollNextStateHandler, STATE_LEVEL_POLL);\n        }\n    }\n    else if (event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_DEV, \"DEV Poll Busy %s/\" FMT_MAC \" timeout seq: %u, cluster: 0x%04X\\n\",\n           event.resource(), FMT_MAC_CAST(event.deviceKey()), d->readResult.sequenceNumber, d->readResult.clusterId);\n        checkPollItemRetry(d->pollItems);\n        d->setState(DEV_PollNextStateHandler, STATE_LEVEL_POLL);\n    }\n}\n\n/*! Empty handler to stop processing of the device.\n */\nvoid DEV_DeadStateHandler(Device *device, const Event &event)\n{\n    if (event.what() == REventStateEnter)\n    {\n        DBG_Printf(DBG_DEV, \"DEV enter passive state \" FMT_MAC \"\\n\", FMT_MAC_CAST(event.deviceKey()));\n    }\n    else if (event.what() == REventStateLeave)\n    {\n\n    }\n    else\n    {\n        DevicePrivate *d = device->d;\n        if (device->managed()) // when DDF handling is enabled again\n        {\n            d->setState(DEV_InitStateHandler);\n        }\n        else\n        {\n\n            if (event.what() == REventPoll || event.what() == REventAwake)\n            {\n                extern void DEV_PollLegacy(Device *device); // defined in de_web_plugin.cpp\n\n                if (d->node && d->node->isCoordinator())\n                {\n                    return;\n                }\n\n                DEV_PollLegacy(device);\n            }\n        }\n    }\n}\n\nDevice::Device(DeviceKey key, deCONZ::ApsController *apsCtrl, QObject *parent) :\n    QObject(parent),\n    Resource(RDevices),\n    d(new DevicePrivate)\n{\n    Q_ASSERT(parent);\n    d->q = this;\n    d->apsCtrl = apsCtrl;\n    d->deviceKey = key;\n    d->flags.initialRun = 1;\n    d->flags.hasDdf = 0;\n    d->flags.needZDPMaintenanceOnce = 1;\n    d->flags.needReadActiveEndpoints = 0;\n    d->flags.needReadSimpleDescriptors = 0;\n\n    addItem(DataTypeBool, RStateReachable);\n    addItem(DataTypeBool, RCapSleeper);\n    addItem(DataTypeUInt64, RAttrExtAddress);\n    addItem(DataTypeUInt16, RAttrNwkAddress);\n    addItem(DataTypeString, RAttrUniqueId)->setValue(generateUniqueId(key, 0, 0));\n    addItem(DataTypeString, RAttrManufacturerName);\n    addItem(DataTypeString, RAttrModelId);\n    addItem(DataTypeString, RAttrDdfPolicy);\n    addItem(DataTypeString, RAttrDdfHash);\n    addItem(DataTypeUInt32, RAttrOtaVersion);\n\n    // lazy init since the event handler is connected after the constructor\n    QTimer::singleShot(0, this, [this]()\n    {\n        d->setState(DEV_InitStateHandler);\n    });\n}\n\nDevice::~Device()\n{\n    for (auto *r : subDevices())\n    {\n        r->setParentResource(nullptr);\n    }\n\n    Q_ASSERT(d);\n    delete d;\n    d = nullptr;\n}\n\nvoid Device::setDeviceId(int id)\n{\n    if (id >= 0)\n    {\n        d->deviceId = id;\n    }\n}\n\nint Device::deviceId() const\n{\n    return d->deviceId;\n}\n\nvoid Device::addSubDevice(Resource *sub)\n{\n    Q_ASSERT(sub);\n    Q_ASSERT(sub->item(RAttrUniqueId));\n\n    sub->setParentResource(this);\n\n    Q_ASSERT(isValid(sub->handle()));\n\n    for (auto &hnd : d->subResourceHandles)\n    {\n        if (hnd == sub->handle())\n        {\n            hnd = sub->handle(); // refresh (index might be changed)\n            return;\n        }\n    }\n\n    for (auto &hnd : d->subResourceHandles)\n    {\n        if (!isValid(hnd))\n        {\n            hnd = sub->handle();\n            DEV_CheckReachable(this);\n\n            std::sort(d->subResourceHandles.begin(), d->subResourceHandles.end(), [](const auto &a, const auto &b)\n            {\n                if (a.order == 0) { return false; }\n                return a.order < b.order;\n            });\n\n            return;\n        }\n    }\n\n\n    Q_ASSERT(0); // too many sub resources, todo raise limit\n}\n\nDeviceKey Device::key() const\n{\n    return d->deviceKey;\n}\n\nconst deCONZ::Node *Device::node() const\n{\n    return d->node;\n}\n\nbool Device::managed() const\n{\n    return d->managed && d->flags.hasDdf;\n}\n\nvoid Device::setManaged(bool managed)\n{\n    d->managed = managed;\n}\n\nvoid Device::setSupportsMgmtBind(bool supported)\n{\n    if (supported)\n    {\n        d->binding.mgmtBindSupported = MGMT_BIND_SUPPORTED;\n    }\n    else\n    {\n        d->binding.mgmtBindSupported = MGMT_BIND_NOT_SUPPORTED;\n    }\n}\n\nvoid Device::handleEvent(const Event &event, DEV_StateLevel level)\n{\n    if (event.what() == REventStateEnter || event.what() == REventStateLeave)\n    {\n        if (event.num() < StateLevel0 || event.num() >= StateLevelMax)\n        {\n            return;\n        }\n\n        const auto level1 = static_cast<unsigned>(event.num());\n        const auto fn = d->state[level1];\n        if (d->stateEnterLock[level1] && event.what() == REventStateEnter)\n        {\n            d->stateEnterLock[level1] = false;\n        }\n        if (fn)\n        {\n            fn(this, event);\n        }\n    }\n    else if (d->stateEnterLock[level])\n    {\n        // REventStateEnter must always arrive first via urgend event queue.\n        // This branch should never hit!\n        DBG_Printf(DBG_DEV, \"DEV event before REventStateEnter: \" FMT_MAC \", skip: %s\\n\", FMT_MAC_CAST(d->deviceKey), event.what());\n    }\n    else if (event.what() == REventDDFReload)\n    {\n        d->setState(DEV_InitStateHandler);\n        d->binding.bindingCheckRound = 0;\n        d->startStateTimer(50, StateLevel0);\n    }\n    else if (event.what() == REventZdpReload)\n    {\n        d->setState(DEV_ActiveEndpointsStateHandler);\n        d->startStateTimer(50, StateLevel0);\n    }\n    else if (d->state[level])\n    {\n        if (event.what() == REventAwake && level == StateLevel0)\n        {\n            d->awake.start();\n        }\n        else if (event.what() == RStateReachable && event.resource() == RDevices)\n        {\n            DEV_CheckReachable(this);\n        }\n\n        d->state[level](this, event);\n    }\n}\n\nvoid DevicePrivate::setState(DeviceStateHandler newState, DEV_StateLevel level)\n{\n    if (state[level] != newState)\n    {\n        if (state[level])\n        {\n            state[level](q, Event(q->prefix(), REventStateLeave, level, q->key()));\n            stateEnterLock[level] = false;\n        }\n\n        state[level] = newState;\n\n        if (state[level])\n        {\n            stateEnterLock[level] = true;\n            Event e(q->prefix(), REventStateEnter, level, q->key());\n            e.setUrgent(true);\n            emit q->eventNotify(e);\n        }\n    }\n}\n\nvoid DevicePrivate::startStateTimer(int IntervalMs, DEV_StateLevel level)\n{\n    timer[level].start(IntervalMs, q);\n}\n\nvoid DevicePrivate::stopStateTimer(DEV_StateLevel level)\n{\n    if (timer[level].isActive())\n    {\n        timer[level].stop();\n    }\n}\n\nbool DevicePrivate::hasRxOnWhenIdle() const\n{\n    return q->node()->nodeDescriptor().receiverOnWhenIdle();\n}\n\nvoid Device::timerEvent(QTimerEvent *event)\n{\n    for (int i = 0; i < StateLevelMax; i++)\n    {\n        if (event->timerId() == d->timer[i].timerId())\n        {\n            d->timer[i].stop(); // single shot\n            if (d->state[i])\n            {\n                d->state[i](this, Event(prefix(), REventStateTimeout, i, key()));\n            }\n            break;\n        }\n    }\n}\n\nqint64 Device::lastAwakeMs() const\n{\n    return d->awake.isValid() ? d->awake.elapsed() : 8640000;\n}\n\nbool Device::reachable() const\n{\n    if (lastAwakeMs() < RxOffWhenIdleResponseTime)\n    {\n        return true;\n    }\n    else if (node() && !node()->nodeDescriptor().isNull() && node()->nodeDescriptor().receiverOnWhenIdle())\n    {\n        return item(RStateReachable)->toBool();\n    }\n    else if (!item(RCapSleeper)->toBool())\n    {\n        return item(RStateReachable)->toBool();\n    }\n\n    return false;\n}\n\nconst std::vector<Resource *> &Device::subDevices()\n{\n    // temp hack to get valid sub device pointers\n    d->subResources.clear();\n\n    for (const auto hnd : d->subResourceHandles)\n    {\n        if (!isValid(hnd))\n        {\n            continue;\n        }\n\n        auto *r = DEV_GetResource(hnd);\n\n        if (r)\n        {\n            d->subResources.push_back(r);\n        }\n    }\n\n    return d->subResources;\n}\n\nvoid Device::clearBindings()\n{\n    d->binding.bindings.clear();\n    d->binding.bindingTrackers.clear();\n    if (d->state[STATE_LEVEL_BINDING])\n    {\n        d->setState(DEV_BindingHandler, STATE_LEVEL_BINDING);\n    }\n}\n\nbool isSame(const DDF_Binding &a, const DDF_Binding &b)\n{\n    return a.clusterId == b.clusterId &&\n           a.srcEndpoint == b.srcEndpoint &&\n           (\n            (a.isGroupBinding && b.isGroupBinding && a.configGroup == b.configGroup) ||\n            (a.isUnicastBinding && b.isUnicastBinding && a.dstExtAddress == b.dstExtAddress)\n           );\n}\n\n/*! Merges reporting configuration from \\p b into \\p a if not already existing.\n */\nvoid mergeBindingReportConfigs(DDF_Binding &a, const DDF_Binding &b)\n{\n    for (const DDF_ZclReport &br : b.reporting)\n    {\n        const auto i = std::find_if(a.reporting.cbegin(), a.reporting.cend(),\n                                    [&br](const DDF_ZclReport &ar) { return ar.attributeId == br.attributeId; });\n\n        if (i == a.reporting.cend())\n        {\n            DBG_Printf(DBG_DEV, \"DEV add reporting cluster: 0x%04X, attr: 0x%04X\\n\", b.clusterId, br.attributeId);\n            a.reporting.push_back(br);\n        }\n    }\n}\n\nvoid Device::addBinding(const DDF_Binding &bnd)\n{\n\n    auto i = std::find_if(d->binding.bindings.begin(), d->binding.bindings.end(),\n                          [&bnd](const auto &i) { return isSame(i, bnd); });\n\n    if (i != d->binding.bindings.end())\n    {\n        mergeBindingReportConfigs(*i, bnd);\n    }\n    else\n    {\n        DBG_Printf(DBG_DEV, \"DEV add binding cluster: 0x%04X, \" FMT_MAC \"\\n\", bnd.clusterId, FMT_MAC_CAST(d->deviceKey));\n        BindingTracker tracker{};\n\n        d->binding.bindings.push_back(bnd);\n        d->binding.bindingTrackers.push_back(tracker);\n        Q_ASSERT(d->binding.bindings.size() == d->binding.bindingTrackers.size());\n        if (bnd.dstEndpoint == 0 && bnd.isUnicastBinding)\n        {\n            d->binding.bindings.back().dstEndpoint = 0x01; // todo query coordinator endpoint\n        }\n    }\n}\n\nconst std::vector<DDF_Binding> &Device::bindings() const\n{\n    return d->binding.bindings;\n}\n\nDevice *DEV_GetDevice(DeviceContainer &devices, DeviceKey key)\n{\n    auto d = std::find_if(devices.begin(), devices.end(),\n                          [key](const std::unique_ptr<Device> &device) { return device->key() == key; });\n\n    if (d != devices.end())\n    {\n        return d->get();\n    }\n\n    return nullptr;\n}\n\nDevice *DEV_GetOrCreateDevice(QObject *parent, deCONZ::ApsController *apsCtrl, EventEmitter *eventEmitter, DeviceContainer &devices, DeviceKey key)\n{\n    Q_ASSERT(key != 0);\n    Q_ASSERT(apsCtrl);\n    auto d = std::find_if(devices.begin(), devices.end(),\n                          [key](const std::unique_ptr<Device> &device) { return device->key() == key; });\n\n    if (d == devices.end())\n    {\n        devices.emplace_back(new Device(key, apsCtrl, parent));\n        Device *device = devices.back().get();\n        QObject::connect(device, SIGNAL(eventNotify(Event)), eventEmitter, SLOT(enqueueEvent(Event)));\n        device->setHandle(R_CreateResourceHandle(device, devices.size() - 1));\n        return device;\n    }\n\n    Q_ASSERT(d != devices.end());\n\n    return d->get();\n}\n\nbool DEV_RemoveDevice(DeviceContainer &devices, DeviceKey key)\n{\n    const auto i = std::find_if(devices.cbegin(), devices.cend(),\n                          [key](const std::unique_ptr<Device> &device) { return device->key() == key; });\n    if (i != devices.cend())\n    {\n        devices.erase(i);\n    }\n\n    return false;\n}\n\nvoid DEV_SetTestManaged(int enabled)\n{\n    if (enabled >= 0 && enabled <= 2)\n    {\n        devManaged = enabled ? enabled : 0;\n    }\n}\n\n/*! Is used to test full Device control over: Device and sub-device creation, read, write, parse of Zigbee commands.\n */\nbool DEV_TestManaged()\n{\n    return devManaged > 0;\n}\n\n/*! Is used to test full Device control over: Device and sub-device creation, read, write, parse of Zigbee commands.\n    In addition legacy code for these tasks is disabled.\n */\nbool DEV_TestStrict()\n{\n    return devManaged > 1;\n}\n"
        },
        {
          "name": "device.h",
          "type": "blob",
          "size": 6.0693359375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_H\n#define DEVICE_H\n\n#include <memory>\n#include <QObject>\n#include \"resource.h\"\n\nclass Event;\nclass EventEmitter;\nclass Device;\nclass DDF_Binding;\n\nnamespace deCONZ\n{\n    class ApsController;\n    class Node;\n}\n\nusing DeviceKey = uint64_t; //! uniqueId for an Device, MAC address for physical devices\n\n/*! Indexes in m_state[] array.\n    Level 0   is the top level state\n    Level >0  are for parallel states in a compound level 0 state\n*/\nenum DEV_StateLevel {\n    StateLevel0 = 0,\n    StateLevel1 = 1,\n    StateLevel2 = 2,\n\n    StateLevelMax\n};\n\n/*! \\class Device\n\n    A generic per device supervisor for routers and end-devices.\n\n    This class doesn't and MUST not know anything specific about devices.\n    Device specific details are defined in device description files.\n\n    As a starting point a Device only knows the MAC address called `DeviceKey` in this context.\n\n    Each Device has a event driven state machine. As a side effect it is self healing, meaning that\n    every missing piece like ZCL attributes or ZDP descriptors will be queried automatically.\n    If an error or timeout occurs the process is retried later on.\n\n    For sleeping end-devices the event/awake notifies to the state machine that the\n    device is listening. Based on this even deep sleepers can be reached. Note that the event\n    is not emitted on each Rx from an device but only when it is certain that the devices is listening\n    e.g. MAC Data Requests, specific commands, Poll Control Cluster Checkings, etc.\n\n    Currently implemented:\n\n    - ZDP Node Descriptor\n    - ZDP Active Endpoints\n    - ZDP Simple Descriptors\n    - ZCL Basic cluster modelid and manufacturer name\n\n\n    Configurations like bindings and ZCL attribute reporting are maintained and verified continously. These may\n    be specified in device description files or are configured dynamically via REST-API, e.g. a switch controls\n    a certain group.\n\n    TODO\n\n    A Device maintains sub-resources which may represent lights, sensors or any other device. The device state given\n    by the REST-API like on/off, brightness or thermostat configuration is kept in RecourceItems per sub-device.\n    The state machine continiously verifies that a given state will be set, this is different from the former and\n    common approach of fire commands and hope for the best.\n\n    Commands MAY have a time to life (TTL) for example to not switch off a light after 3 hours when it becomes reachable.\n\n    This class doesn't know much about ZCL attributes, it should operate mainly on ResourceItems which encapsulate\n    how underlying ZCL attributes are written, parsed or queried. The same Resource item, like state/temperature might\n    have a different configuration between devices. All this class sees is a state/temperature item or more precisely\n    — just a ResouceItem in a certain state.\n */\n\nclass DevicePrivate;\n\nclass Device : public QObject,\n               public Resource\n{\n    Q_OBJECT\n\npublic:\n    DevicePrivate *d = nullptr; //! Public Pimpl pointer so that free functions in device.cpp can use it.\n\n    Device() = delete;\n    Device(const Device &) = delete;\n    explicit Device(DeviceKey key, deCONZ::ApsController*apsCtrl, QObject *parent = nullptr);\n    ~Device();\n    void setDeviceId(int id);\n    int deviceId() const;\n    void addSubDevice(Resource *sub);\n    DeviceKey key() const;\n    const deCONZ::Node *node() const;\n    bool managed() const;\n    void setManaged(bool managed);\n    void setSupportsMgmtBind(bool supported);\n    void handleEvent(const Event &event, DEV_StateLevel level = StateLevel0);\n    void timerEvent(QTimerEvent *event) override;\n    qint64 lastAwakeMs() const;\n    bool reachable() const;\n    const std::vector<Resource *> &subDevices();\n    void clearBindings();\n    void addBinding(const DDF_Binding &bnd);\n    const std::vector<DDF_Binding> &bindings() const;\n\nQ_SIGNALS:\n    void eventNotify(const Event&); //! The device emits an event, which needs to be enqueued in a higher layer.\n};\n\nDevice *DEV_ParentDevice(Resource *r);\n\n/*! Helper to forward attributes to core (modelid, battery, etc.). */\nvoid DEV_ForwardNodeChange(Device *device, const QString &key, const QString &value);\n\nusing DeviceContainer = std::vector<std::unique_ptr<Device>>;\n\nResource *DEV_GetSubDevice(Device *device, const char *prefix, const QString &identifier);\n\n/*! Returns a device for a given \\p key.\n\n    \\param devices - the container which contains the device\n    \\param key - unique identifier for a device (MAC address for physical devices)\n */\nDevice *DEV_GetDevice(DeviceContainer &devices, DeviceKey key);\n\n/*! Returns a device for a given \\p key.\n\n    If the device doesn't exist yet it will be created.\n\n    \\param parent - must be DeRestPluginPrivate instance\n    \\param eventEmitter - emitter to enqueue events\n    \\param devices - the container which contains the device\n    \\param key - unique identifier for a device (MAC address for physical devices)\n */\nDevice *DEV_GetOrCreateDevice(QObject *parent, deCONZ::ApsController *apsCtrl, EventEmitter *eventEmitter, DeviceContainer &devices, DeviceKey key);\n\n/*! Removes a device with \\p key.\n\n    \\param devices - the container which contains the device\n    \\param key - unique identifier for a device (MAC address for physical devices)\n */\nbool DEV_RemoveDevice(DeviceContainer &devices, DeviceKey key);\n\n/*! Returns \\c Resource for a given \\p identifier.\n\n    \\param resource - RSensors | RLights | RGroups | RConfig\n    \\param identifier - id | uniqueid | empty (for RConfig)\n*/\nResource *DEV_GetResource(const char *resource, const QString &identifier);\nResource *DEV_GetResource(Resource::Handle hnd);\n\n/*! Returns deCONZ core node for a given \\p extAddress.\n */\nconst deCONZ::Node *DEV_GetCoreNode(uint64_t extAddress);\n\nvoid DEV_CheckReachable(Device *device);\n\nvoid DEV_SetTestManaged(int enabled);\nbool DEV_TestManaged();\nbool DEV_TestStrict();\n\n#endif // DEVICE_H\n"
        },
        {
          "name": "device",
          "type": "tree",
          "content": null
        },
        {
          "name": "device_access_fn.cpp",
          "type": "blob",
          "size": 66.025390625,
          "content": "/*\n * Copyright (c) 2021-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QTimeZone>\n#include \"deconz/u_assert.h\"\n#include \"device_access_fn.h\"\n#include \"device_descriptions.h\"\n#include \"device_js/device_js.h\"\n#include \"ias_zone.h\"\n#include \"resource.h\"\n#include \"zcl/zcl.h\"\n\n\n#define CMD_ID_ANY 0x100\n#define TIME_CLUSTER_ID     0x000A\n\n#define TIME_ATTRID_TIME                    0x0000\n#define TIME_ATTRID_LOCAL_TIME              0x0007\n#define TIME_ATTRID_LAST_SET_TIME           0x0008\n\n/*\n    Documentation for manufacturer specific Tuya cluster (0xEF00)\n\n        https://developer.tuya.com/en/docs/iot-device-dev/tuya-zigbee-universal-docking-access-standard?id=K9ik6zvofpzql\n\n    Tuya ZCL insights\n\n        https://github.com/TuyaInc/tuya_zigbee_sdk/blob/master/silicon_labs_zigbee/include/zigbee_attr.h\n\n    Basic cluster (0x0000)\n    -------------\n\n    0x0001 Application version:: 0b 01 00 0001 = 1.0.1 ie 0x41 for 1.0.1\n\n    0x0004 Manufacturer name:  XXX…XXX (16 bytes in length, consisting of an 8-byte prefix and an 8-byte PID)\n                               0-7 bytes: _ TZE600_\n                               8-16 bytes: PID (created and provided by the product manager in the platform or self-service)\n\n    Tuya cluster (0xEF00)\n    ---------------------\n\n    https://developer.tuya.com/en/docs/iot-device-dev/tuya-zigbee-universal-docking-access-standard?id=K9ik6zvofpzql\n\n    Zigbee generic docking is suitable for scenarios where the Zigbee standard protocol is not supported or not very suitable.\n\n    ZDP Simple Descriptor Device Id (0x0051)\n\n    Frame control for outgoing commands:\n\n        deCONZ::ZclFCClusterCommand\n        deCONZ::ZclFCDirectionClientToServer\n        deCONZ::ZclFCDisableDefaultResponse\n\n    DP data format\n    --------------\n\n    DPID  U8        Datapoint serial number\n    Type  U8        Datatype in value\n\n          Name  Id   Length\n          ------------------------------\n          raw     0x00\n          bool    0x01\n          value   0x02\n          string  0x03\n          enum    0x04\n          bitmap  0x05\n\n    Length U16      Length of Value\n    Value  1/2/4/N  The value as big endian\n\n\n    ZCL Payload of comamnds\n    -----------------------\n\n    Example MoesGo switch TY_DATA_REPORT\n\n    00 4c        sequence number\n    02           DPID\n    02           Type: Value\n    00 04        Length: 4\n    00 00 00 15\n\n*/\n#define TUYA_CLUSTER_ID 0xEF00\n\nenum TuyaCommandId : unsigned char\n{\n    TY_DATA_REQUEST              = 0x00,\n    TY_DATA_RESPONSE             = 0x01,\n    TY_DATA_REPORT               = 0x02,\n    TY_DATA_QUERY                = 0x03,\n    TY_DATA_STATUS_SEARCH        = 0x06,\n    TUYA_MCU_VERSION_REQ         = 0x10,\n    TUYA_MCU_VERSION_RSP         = 0x11,\n    TUYA_MCU_OTA_NOTIFY          = 0x12,\n    TUYA_MCU_OTA_BLOCK_DATA_REQ  = 0x13,\n    TUYA_MCU_OTA_BLOCK_DATA_RSP  = 0x14,\n    TUYA_MCU_OTA_RESULT          = 0x15,\n    TUYA_MCU_SYNC_TIME           = 0x24\n};\n\nenum TuyaDataType : unsigned char\n{\n    TuyaDataTypeRaw              = 0x00,\n    TuyaDataTypeBool             = 0x01,\n    TuyaDataTypeValue            = 0x02,\n    TuyaDataTypeString           = 0x03,\n    TuyaDataTypeEnum             = 0x04,\n    TuyaDataTypeBitmap           = 0x05\n};\n\nenum DA_Constants\n{\n    BroadcastEndpoint = 255, //! Accept incoming commands from any endpoint.\n    AutoEndpoint = 0 //! Use src/dst endpoint of the related Resource (uniqueid).\n};\n\nstruct ParseFunction\n{\n    ParseFunction(const QString &_name, const int _arity, ParseFunction_t _fn) :\n        name(_name),\n        arity(_arity),\n        fn(_fn)\n    { }\n    QString name;\n    int arity = 0; // number of parameters given by the device description file\n    ParseFunction_t fn = nullptr;\n};\n\nstruct ReadFunction\n{\n    ReadFunction(const QString &_name, const int _arity, ReadFunction_t _fn) :\n        name(_name),\n        arity(_arity),\n        fn(_fn)\n    { }\n    QString name;\n    int arity = 0; // number of parameters given by the device description file\n    ReadFunction_t fn = nullptr;\n};\n\nstruct WriteFunction\n{\n    WriteFunction(const QString &_name, const int _arity, WriteFunction_t _fn) :\n        name(_name),\n        arity(_arity),\n        fn(_fn)\n    { }\n    QString name;\n    int arity = 0; // number of parameters given by the device description file\n    WriteFunction_t fn = nullptr;\n};\n\nquint8 zclNextSequenceNumber(); // todo defined in de_web_plugin_private.h\n\n/*! Helper to get an unsigned int from \\p var which might be a number or string value.\n\n   \\param var - Holds the string or number.\n   \\param max – Upper bound of the allowed value.\n   \\param ok – true if var holds and uint which is <= \\p max.\n */\nuint variantToUint(const QVariant &var, size_t max, bool *ok)\n{\n    Q_ASSERT(ok);\n    *ok = false;\n\n    if (var.isNull())\n    {\n        return 0;\n    }\n\n    const auto val = var.toString().toUInt(ok, 0);\n    *ok = *ok && val <= max;\n\n    return *ok ? val : 0;\n}\n\n/*! Extracts common ZCL parameters from an object.\n */\nstatic ZCL_Param getZclParam(const QVariantMap &param)\n{\n    ZCL_Param result{};\n\n    if (!param.contains(QLatin1String(\"cl\")))\n    {\n        return result;\n    }\n\n    bool ok = true;\n\n    result.endpoint = param.contains(\"ep\") ? variantToUint(param[\"ep\"], UINT8_MAX, &ok) : quint8(AutoEndpoint);\n    result.clusterId = ok ? variantToUint(param[\"cl\"], UINT16_MAX, &ok) : 0;\n    result.manufacturerCode = ok && param.contains(\"mf\") ? variantToUint(param[\"mf\"], UINT16_MAX, &ok) : 0;\n\n    if (param.contains(QLatin1String(\"cmd\"))) // optional\n    {\n        if (param[\"cmd\"].toString() == QLatin1String(\"any\"))\n        {\n            result.commandId = CMD_ID_ANY;\n            result.hasCommandId = 1;\n        }\n        else\n        {\n            result.commandId = variantToUint(param[\"cmd\"], UINT32_MAX, &ok);\n            result.hasCommandId = ok ? 1 : 0;\n        }\n    }\n    else\n    {\n        result.hasCommandId = 0;\n    }\n\n    if (param.contains(QLatin1String(\"fc\"))) // optional\n    {\n        result.frameControl = (uint8_t)variantToUint(param[\"fc\"], UINT8_MAX, &ok);\n        result.hasFrameControl = ok ? 1 : 0;\n    }\n    else\n    {\n        result.hasFrameControl = 0;\n    }\n\n    const auto ignoreSeqno = QLatin1String(\"noseq\");\n    if (param.contains(ignoreSeqno))\n    {\n        result.ignoreResponseSeq = param.value(ignoreSeqno).toBool() ? 1 : 0;\n    }\n    else\n    {\n        result.ignoreResponseSeq = 0;\n    }\n\n    result.attributeCount = 0;\n    const auto attr = param[QLatin1String(\"at\")]; // optional\n\n    if (!ok)\n    { }\n    else if (attr.type() == QVariant::String)\n    {\n        result.attributes[result.attributeCount] = variantToUint(attr, UINT16_MAX, &ok);\n        result.attributeCount = 1;\n    }\n    else if (attr.type() == QVariant::List)\n    {\n        const auto arr = attr.toList();\n        for (const auto &at : arr)\n        {\n            if (result.attributeCount == ZCL_Param::MaxAttributes)\n            {\n                break;\n            }\n\n            if (ok && at.type() == QVariant::String)\n            {\n                result.attributes[result.attributeCount] = variantToUint(at, UINT16_MAX, &ok);\n                result.attributeCount++;\n            }\n        }\n\n        ok = result.attributeCount == size_t(arr.size());\n    }\n    else if (param[\"eval\"].toString().contains(\"Attr\")) // guard against missing \"at\"\n    {\n        ok = false;\n    }\n\n    result.valid = ok;\n\n    return result;\n}\n\nquint8 resolveAutoEndpoint(const Resource *r)\n{\n    quint8 result = AutoEndpoint;\n\n    U_ASSERT(r);\n    if (r)\n    {\n        const ResourceItem *itemUniqueId = r->item(RAttrUniqueId);\n\n        U_ASSERT(itemUniqueId);\n        if (itemUniqueId)\n        {\n            // hack to get endpoint. todo find better solution\n            const auto ls = itemUniqueId->toString().split('-', SKIP_EMPTY_PARTS);\n            if (ls.size() >= 2)\n            {\n                bool ok = false;\n                uint ep = ls[1].toUInt(&ok, 16);\n                if (ok && ep < BroadcastEndpoint)\n                {\n                    result = ep;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Evaluates an items Javascript expression for a received attribute.\n */\nbool evalZclAttribute(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, int attrIndex, const deCONZ::ZclAttribute &attr, const QVariant &parseParameters)\n{\n    bool ok = false;\n    const auto &zclParam = item->zclParam();\n\n    for (size_t i = 0; i < zclParam.attributeCount; i++)\n    {\n        if (zclParam.attributes[i] == attr.id())\n        {\n            ok = true;\n            break;\n        }\n    }\n\n    if (!ok)\n    {\n        return false;\n    }\n\n    const auto expr = parseParameters.toMap()[\"eval\"].toString();\n\n    if (!expr.isEmpty())\n    {\n        DeviceJs &engine = *DeviceJs::instance();\n        engine.reset();\n        engine.setResource(r);\n        engine.setItem(item);\n        engine.setZclAttribute(attrIndex, attr);\n        engine.setZclFrame(zclFrame);\n        engine.setApsIndication(ind);\n\n        if (engine.evaluate(expr) == JsEvalResult::Ok)\n        {\n            const auto res = engine.result();\n            if (res.isValid())\n            {\n                DBG_Printf(DBG_DDF, \"%s/%s expression: %s --> %s\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, qPrintable(expr), qPrintable(res.toString()));\n\n                // item->setValue(res, ResourceItem::SourceDevice);\n                return true;\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_DDF, \"failed to evaluate expression for %s/%s: %s, err: %s\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, qPrintable(expr), qPrintable(engine.errorString()));\n        }\n    }\n    return false;\n}\n\n/*! Evaluates an items Javascript expression for a received ZCL frame.\n */\nbool evalZclFrame(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    const auto expr = parseParameters.toMap()[\"eval\"].toString();\n\n    if (!expr.isEmpty())\n    {\n        DeviceJs &engine = *DeviceJs::instance();\n        engine.reset();\n        engine.setResource(r);\n        engine.setItem(item);\n        engine.setZclFrame(zclFrame);\n        engine.setApsIndication(ind);\n\n        if (engine.evaluate(expr) == JsEvalResult::Ok)\n        {\n            const auto res = engine.result();\n            if (res.isValid())\n            {\n                if (DBG_IsEnabled(DBG_DDF))\n                {\n                    DBG_Printf(DBG_DDF, \"expression: %s --> %s\\n\", qPrintable(expr), qPrintable(res.toString()));\n                }\n                return true;\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_DDF, \"failed to evaluate expression for %s/%s: %s, err: %s\\n\", qPrintable(r->item(RAttrUniqueId)->toString()), item->descriptor().suffix, qPrintable(expr), qPrintable(engine.errorString()));\n        }\n    }\n    return false;\n}\n\n/*! A general purpose function to map number values of a source item to a string which is stored in \\p item .\n\n    The item->parseParameters() is expected to be an object (given in the device description file).\n    {\"fn\": \"numtostr\", \"srcitem\": suffix, \"op\": operator, \"to\": array}\n    - srcitem: the suffix of the source item which holds the numeric value\n    - op: (lt | le | eq | gt | ge) the operator used to match the 'to' array\n    - to: [number, string, [number, string], ...] an sorted array to map 'number -> string' with the given operator\n\n    Example: { \"parse\": {\"fn\": \"numtostr\", \"srcitem\": \"state/airqualityppb\", \"op\": \"le\", \"to\": [65, \"good\", 65535, \"bad\"] }\n */\nbool parseNumericToString(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    Q_UNUSED(ind)\n    Q_UNUSED(zclFrame)\n    bool result = false;\n\n    ResourceItem *srcItem = nullptr;\n    const auto map = parseParameters.toMap();\n\n    enum Op { OpNone, OpLessThan, OpLessEqual, OpEqual, OpGreaterThan, OpGreaterEqual };\n    Op op = OpNone;\n\n    if (!item->parseFunction()) // init on first call\n    {\n        if (item->descriptor().type != DataTypeString)\n        {\n            return result;\n        }\n\n        if (!map.contains(QLatin1String(\"to\")) || !map.contains(QLatin1String(\"op\")) || !map.contains(QLatin1String(\"srcitem\")))\n        {\n            return result;\n        }\n\n        item->setParseFunction(parseNumericToString);\n    }\n\n    ResourceItemDescriptor rid;\n    if (!getResourceItemDescriptor(map[\"srcitem\"].toString(), rid))\n    {\n        return result;\n    }\n\n    srcItem = r->item(rid.suffix);\n    if (!srcItem)\n    {\n        return result;\n    }\n\n    if (!(srcItem->needPushChange() || srcItem->needPushSet()))\n    {\n        return result; // only update if needed\n    }\n\n    {\n        const auto opString = map[QLatin1String(\"op\")].toString();\n\n        if      (opString == QLatin1String(\"le\")) { op = OpLessEqual; }\n        else if (opString == QLatin1String(\"lt\")) { op = OpLessThan; }\n        else if (opString == QLatin1String(\"eq\")) { op = OpEqual; }\n        else if (opString == QLatin1String(\"ge\")) { op = OpGreaterEqual; }\n        else if (opString == QLatin1String(\"gt\")) { op = OpGreaterThan; }\n        else\n        {\n            return result;\n        }\n    }\n\n    const qint64 num = srcItem->toNumber();\n    const auto to = map[\"to\"].toList();\n\n    if (to.size() & 1)\n    {\n        return result; // array size must be even\n    }\n\n    auto i = std::find_if(to.cbegin(), to.cend(), [num, op](const QVariant &var)\n    {\n        if (var.type() == QVariant::Double || var.type() == QVariant::LongLong)\n        {\n            if (op == OpLessEqual)    { return num <= var.toInt(); }\n            if (op == OpLessThan)     { return num < var.toInt();  }\n            if (op == OpEqual)        { return num == var.toInt(); }\n            if (op == OpGreaterEqual) { return num >= var.toInt(); }\n            if (op == OpGreaterThan)  { return num > var.toInt();  }\n        }\n        return false;\n    });\n\n    // DBG_Printf(DBG_DDF, \"%s/%s numtostr: %s %lld --> %d\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, srcItem->descriptor().suffix, num, i - to.cbegin());\n\n    if (i != to.cend())\n    {\n        i++; // point next element (string)\n\n        if (i != to.cend() && i->type() == QVariant::String)\n        {\n            const QString str = i->toString();\n            if (!str.isEmpty())\n            {\n                DBG_Printf(DBG_DDF, \"%s/%s numtostr: %s %lld --> %s\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, srcItem->descriptor().suffix, num, qPrintable(str));\n                item->setValue(str);\n                item->setLastZclReport(srcItem->lastZclReport()); // Treat as report\n                result = true;\n            }\n        }\n    }\n\n    if (result)\n    {\n        DeviceJS_ResourceItemValueChanged(item);\n    }\n\n    return result;\n}\n\n/*! A generic function to parse ZCL values from read/report commands.\n    The item->parseParameters() is expected to be an object (given in the device description file).\n\n    {\"fn\": \"zcl:attr\", \"ep\": endpoint, \"cl\": clusterId, \"mf\": manufacturerCode, \"at\": attributeId, \"eval\": expression}\n\n    - endpoint: (optional) 255 means any endpoint, 0 means auto selected from the related resource, defaults to 0\n    - clusterId: string hex value\n    - manufacturerCode: (optional) string hex value\n    - attributeId: string hex value or array of string hex values\n    - expression: Javascript expression to transform the attribute value to the Item value\n\n    Example: { \"parse\": {\"fn\": \"zcl:attr\", \"ep:\" 1, \"cl\": \"0x0402\", \"at\": \"0x0000\", \"eval\": \"Attr.val + R.item('config/offset').val\" } }\n\n    TODO: move code to parse a ZCL command to separate function.\n\n    Exmaple: { \"parse\": {\"fn\": \"zcl:cmd\", \"ep\": 2, \"cl\": \"0xfc00\", \"mf\", \"0x100b\", \"script\": \"fc00_buttonevent.js\" } }\n */\nbool parseZclAttribute(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    bool result = false;\n\n    if (!item->parseFunction()) // init on first call\n    {\n        Q_ASSERT(!parseParameters.isNull());\n        if (parseParameters.isNull())\n        {\n            return result;\n        }\n\n        ZCL_Param param = getZclParam(parseParameters.toMap());\n\n        Q_ASSERT(param.valid);\n        if (!param.valid)\n        {\n            return result;\n        }\n\n        if (param.hasCommandId)\n        {\n            if (param.commandId == CMD_ID_ANY)\n            {\n\n            }\n            else if (param.commandId != zclFrame.commandId())\n            {\n                return result;\n            }\n        }\n        else if (!param.hasCommandId && param.attributeCount == 0)\n        {\n            // catch all handler\n        }\n        else if (!param.hasCommandId && zclFrame.commandId() != deCONZ::ZclReadAttributesResponseId && zclFrame.commandId() != deCONZ::ZclReportAttributesId)\n        {\n            return result;\n        }\n\n        if (param.manufacturerCode != zclFrame.manufacturerCode())\n        {\n            return result;\n        }\n\n        if (param.endpoint == AutoEndpoint)\n        {\n            param.endpoint = resolveAutoEndpoint(r);\n\n            if (param.endpoint == AutoEndpoint)\n            {\n                return result;\n            }\n        }\n\n        item->setParseFunction(parseZclAttribute);\n        item->setZclProperties(param);\n    }\n\n    const auto &zclParam = item->zclParam();\n\n    if (ind.clusterId() != zclParam.clusterId)\n    {\n        return result;\n    }\n    \n    if (!zclParam.hasCommandId &&\n         zclFrame.isProfileWideCommand() &&\n         zclFrame.commandId() != deCONZ::ZclReadAttributesResponseId &&\n         zclFrame.commandId() != deCONZ::ZclReportAttributesId)\n    {\n        return result;\n    }\n    \n    if (zclParam.manufacturerCode != zclFrame.manufacturerCode())\n    {\n        return result;\n    }\n\n    if (zclParam.endpoint < BroadcastEndpoint && zclParam.endpoint != ind.srcEndpoint())\n    {\n        return result;\n    }\n\n    if (zclParam.attributeCount == 0) // attributes are optional\n    {\n        if (zclParam.hasCommandId)\n        {\n            if (zclParam.commandId == CMD_ID_ANY)\n            {\n\n            }\n            else if (zclParam.commandId != zclFrame.commandId())\n            {\n                return result;\n            }\n        }\n        \n        if (evalZclFrame(r, item, ind, zclFrame, parseParameters))\n        {\n            result = true;\n        }\n        return result;\n    }\n\n    if (zclFrame.payload().isEmpty() && zclParam.attributeCount > 0)\n    {\n        return result;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    int attrIndex = -1;\n    while (!stream.atEnd())\n    {\n        quint16 attrId;\n        quint8 status;\n        quint8 dataType;\n\n        stream >> attrId;\n        attrIndex++;\n\n        if (zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n        {\n            stream >> status;\n            if (status != deCONZ::ZclSuccessStatus)\n            {\n                continue;\n            }\n        }\n\n        stream >> dataType;\n        deCONZ::ZclAttribute attr(attrId, dataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n        if (!attr.readFromStream(stream))\n        {\n            break;\n        }\n\n        if (evalZclAttribute(r, item, ind, zclFrame, attrIndex, attr, parseParameters))\n        {\n            if (zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n            {\n                item->setLastZclReport(deCONZ::steadyTimeRef().ref);\n            }\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n/*! A generic function to parse Tuya private cluster values from response/report commands.\n    The item->parseParameters() is expected to be an object (given in the device description file).\n\n    {\"fn\": \"tuya\", \"dpid\": datapointId, \"eval\": expression}\n\n    - datapointId: 1-255 the datapoint identifier (DPID) to extract\n    - expression: Javascript expression to transform the raw value\n\n    Example: { \"parse\": {\"fn\": \"tuya\", \"dpid:\" 1, \"eval\": \"Attr.val + R.item('config/offset').val\" } }\n */\nbool parseTuyaData(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    bool result = false;\n\n    if (ind.clusterId() != TUYA_CLUSTER_ID || !(zclFrame.commandId() == TY_DATA_REPORT || zclFrame.commandId() ==  TY_DATA_RESPONSE || zclFrame.commandId() ==  TY_DATA_STATUS_SEARCH))\n    {\n        return result;\n    }\n\n    if (!item->parseFunction()) // init on first call\n    {\n        const auto map = parseParameters.toMap();\n        if (map.isEmpty())\n        {\n            return result;\n        }\n\n        if (!map.contains(QLatin1String(\"dpid\")) || !map.contains(QLatin1String(\"eval\")))\n        {\n            return result;\n        }\n\n        bool ok = false;\n        ZCL_Param param{};\n        param.attributes[0] = variantToUint(map.value(QLatin1String(\"dpid\")), 255, &ok);\n        if (!ok)\n        {\n            return result;\n        }\n        param.valid = 1;\n        param.endpoint = ind.srcEndpoint();\n        param.clusterId = ind.clusterId();\n        param.attributeCount = 1;\n\n        item->setParseFunction(parseTuyaData);\n        item->setZclProperties(param);\n    }\n\n    quint16 seq;\n    quint8 dpid;\n    quint8 dataType;\n    quint16 dataLength;\n    quint8 zclDataType = 0;\n    const auto &zclParam = item->zclParam();\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::BigEndian); // tuya is big endian!\n\n    stream >> seq;\n\n    int attrIndex = 0;\n    while (!stream.atEnd()) // a message can contain multiple datapoints\n    {\n        stream >> dpid;\n        stream >> dataType;\n        stream >> dataLength;\n\n        if (stream.status() != QDataStream::Ok)\n        {\n            return result;\n        }\n\n        deCONZ::NumericUnion num;\n        num.u64 = 0;\n\n        switch (dataType)\n        {\n        case TuyaDataTypeRaw:\n        {\n            // Not setting value because need to much ressource.\n            zclDataType = deCONZ::ZclCharacterString;\n        }\n        break;\n            \n        case TuyaDataTypeString:\n            return result; // TODO implement?\n\n        case TuyaDataTypeBool:\n        { stream >> num.u8; zclDataType = deCONZ::ZclBoolean; }\n            break;\n\n        case TuyaDataTypeEnum:\n        { stream >> num.u8; zclDataType = deCONZ::Zcl8BitUint; }\n            break;\n\n        case TuyaDataTypeValue: // docs aren't clear, assume signed\n        {  stream >> num.s32; zclDataType = deCONZ::Zcl32BitInt; }\n            break;\n\n        case TuyaDataTypeBitmap:\n        {\n            switch (dataLength)\n            {\n            case 1: { stream >> num.u8;  zclDataType = deCONZ::Zcl8BitUint; } break;\n            case 2: { stream >> num.u16; zclDataType = deCONZ::Zcl16BitUint; } break;\n            case 4: { stream >> num.u32; zclDataType = deCONZ::Zcl32BitUint; } break;\n            }\n        }\n            break;\n\n        default:\n            return result; // unkown datatype\n        }\n\n        if (dpid == zclParam.attributes[0])\n        {\n            // map datapoint into ZCL attribute\n            deCONZ::ZclAttribute attr(dpid, zclDataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n            if (zclDataType == deCONZ::Zcl32BitInt)\n            {\n                attr.setValue(qint64(num.s32));\n            }\n            else\n            {\n                attr.setValue(quint64(num.u32));\n            }\n\n            if (evalZclAttribute(r, item, ind, zclFrame, attrIndex, attr, parseParameters))\n            {\n                item->setLastZclReport(deCONZ::steadyTimeRef().ref);\n                result = true;\n            }\n        }\n\n        attrIndex++;\n\n        const char *rt = zclFrame.commandId() == TY_DATA_REPORT ? \"REPORT\" : \"RESPONSE\";\n\n        DBG_Printf(DBG_INFO, \"TY_DATA_%s: seq %u, dpid: 0x%02X, type: 0x%02X, length: %u, val: %d\\n\",\n                   rt, seq, dpid, dataType, dataLength, num.s32);\n    }\n\n    return result;\n}\n\n/*! A generic function to trigger Tuya device reporting all datapoints.\n    Important: This function should be attached to only one item!\n    The item->readParameters() is expected to be an object (given in the device description file).\n\n    { \"fn\": \"tuya\"}\n\n    Example: { \"read\": {\"fn\": \"tuya\"} }\n */\nstatic DA_ReadResult readTuyaAllData(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &readParameters)\n{\n    Q_UNUSED(item)\n    Q_UNUSED(readParameters);\n\n    DA_ReadResult result{};\n\n    // Workaround: dont't query too quickly, reports will only be send a few seconds after receiving the query command.\n    // The device report timer resets on each received query.\n    // Not the ideal solution since this is global across all devices but should do the trick for now.\n    static deCONZ::SteadyTimeRef lastReadGlobal{};\n\n    auto now = deCONZ::steadyTimeRef();\n    if (now - lastReadGlobal < deCONZ::TimeSeconds{15})\n    {\n        return result;\n    }\n\n    lastReadGlobal = now;\n\n    auto *rTop = r->parentResource() ? r->parentResource() : r;\n\n    const auto *extAddr = rTop->item(RAttrExtAddress);\n    const auto *nwkAddr = rTop->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame zclFrame;\n\n    req.setDstEndpoint(1); // TODO is this always 1? if not search simple descriptor for Tuya cluster\n    req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.dstAddress().setNwk(nwkAddr->toNumber());\n    req.dstAddress().setExt(extAddr->toNumber());\n    req.setClusterId(TUYA_CLUSTER_ID);\n    req.setProfileId(HA_PROFILE_ID);\n    req.setSrcEndpoint(1); // TODO\n\n    zclFrame.setSequenceNumber(zclNextSequenceNumber());\n    zclFrame.setCommandId(TY_DATA_QUERY);\n\n    zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    // no payload\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n    result.isEnqueued = apsCtrl->apsdeDataRequest(req) == deCONZ::Success;\n    result.apsReqId = req.id();\n    result.sequenceNumber = zclFrame.sequenceNumber();\n    result.clusterId = req.clusterId();\n\n    return result;\n}\n\n/*! A generic function to write Tuya data.\n    The \\p writeParameters is expected to contain one object (given in the device description file).\n\n    { \"fn\": \"tuya\", \"dpid\": datapointId, \"dt\": dataType, \"eval\": expression }\n\n    - datapointId: number\n    - dataType: string hex value\n\n          bool           0x10\n          s32 value      0x2b\n          enum           0x30\n          8-bit bitmap   0x18\n          16-bit bitmap  0x19\n          32-bit bitmap  0x1b\n\n    - expression: to transform the item value\n\n    Example: \"write\": {\"fn\":\"tuya\", \"dpid\": 1,  \"dt\": \"0x10\", \"eval\": \"Item.val == 1\"}\n */\nbool writeTuyaData(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &writeParameters)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(item);\n    Q_ASSERT(apsCtrl);\n\n    bool result = false;\n    const auto rParent = r->parentResource() ? r->parentResource() : r;\n    const auto *extAddr = rParent->item(RAttrExtAddress);\n    const auto *nwkAddr = rParent->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    const auto map = writeParameters.toMap();\n\n    if (!map.contains(QLatin1String(\"dpid\")) || !map.contains(QLatin1String(\"dt\")) || !map.contains(QLatin1String(\"eval\")))\n    {\n        return result;\n    }\n\n    bool ok = false;\n\n    const auto dpid = variantToUint(map.value(QLatin1String(\"dpid\")), 255, &ok);\n    if (!ok)\n    {\n        return result;\n    }\n    const auto dataType = variantToUint(map.value(\"dt\"), UINT8_MAX, &ok);\n    switch (dataType)\n    {\n    case deCONZ::ZclBoolean:\n    case deCONZ::Zcl32BitInt:\n    case deCONZ::Zcl8BitEnum:\n    case deCONZ::Zcl8BitBitMap:\n    case deCONZ::Zcl16BitBitMap:\n    case deCONZ::Zcl32BitBitMap:\n        break;\n\n    default:\n        return result; // unsupported datatype\n    }\n\n    const auto expr = map.value(\"eval\").toString();\n\n    if (!ok || expr.isEmpty())\n    {\n        return result;\n    }\n\n    DBG_Printf(DBG_INFO, \"writeTuyaData, dpid: 0x%02X, type: 0x%02X, expr: %s\\n\",\n               dpid & 0xFF, dataType & 0xFF, qPrintable(expr));\n\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame zclFrame;\n\n    req.setDstEndpoint(1); // TODO is this always 1? if not search simple descriptor for Tuya cluster\n    req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.dstAddress().setNwk(nwkAddr->toNumber());\n    req.dstAddress().setExt(extAddr->toNumber());\n    req.setClusterId(TUYA_CLUSTER_ID);\n    req.setProfileId(HA_PROFILE_ID);\n    req.setSrcEndpoint(1); // TODO\n\n    zclFrame.setSequenceNumber(zclNextSequenceNumber());\n    zclFrame.setCommandId(TY_DATA_REQUEST);\n\n    zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n\n    { // payload\n        QVariant value;\n        DeviceJs &engine = *DeviceJs::instance();\n        engine.reset();\n        engine.setResource(r);\n        engine.setItem(item);\n\n        if (engine.evaluate(expr) == JsEvalResult::Ok)\n        {\n            value = engine.result();\n            DBG_Printf(DBG_INFO, \"Tuya write expression: %s --> %s\\n\", qPrintable(expr), qPrintable(value.toString()));\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"failed to evaluate Tuya write expression for %s/%s: %s, err: %s\\n\", qPrintable(r->item(RAttrUniqueId)->toString()), item->descriptor().suffix, qPrintable(expr), qPrintable(engine.errorString()));\n            return result;\n        }\n\n        if (!value.isValid())\n        {\n            return result;\n        }\n\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::BigEndian); // Tuya is big endian\n\n        stream << quint16(req.id()); // use as sequence number\n        stream << quint8(dpid);\n\n        switch (dataType)\n        {\n        case deCONZ::ZclBoolean:\n        {\n            stream << quint8(TuyaDataTypeBool);\n            stream << quint16(1); // length\n            stream << quint8(value.toUInt());\n        }\n            break;\n\n        case deCONZ::Zcl32BitInt:\n        {\n            stream << quint8(TuyaDataTypeValue);\n            stream << quint16(4); // length\n            stream << qint32(value.toInt());\n        }\n            break;\n\n        case deCONZ::Zcl8BitEnum:\n        {\n            stream << quint8(TuyaDataTypeEnum);\n            stream << quint16(1); // length\n            stream << quint8(value.toUInt());\n        }\n            break;\n\n        case deCONZ::Zcl8BitBitMap:\n        {\n            stream << quint8(TuyaDataTypeBitmap);\n            stream << quint16(1); // length\n            stream << quint8(value.toUInt());\n        }\n            break;\n\n        case deCONZ::Zcl16BitBitMap:\n        {\n            stream << quint8(TuyaDataTypeBitmap);\n            stream << quint16(2); // length\n            stream << quint16(value.toUInt());\n        }\n            break;\n\n        case deCONZ::Zcl32BitBitMap:\n        {\n            stream << quint8(TuyaDataTypeBitmap);\n            stream << quint16(4); // length\n            stream << quint32(value.toUInt());\n        }\n            break;\n\n        default: // TODO unsupported datatype\n            return result;\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n    result = apsCtrl->apsdeDataRequest(req) == deCONZ::Success;\n\n    return result;\n}\n\n/*! Extracts manufacturer specific Xiaomi ZCL attribute from report commands to basic cluster.\n\n    \\param zclFrame - Contains the special report with attribute 0xff01, 0xff02 or 0x00f7.\n    \\param rtag - The tag or struct index of the attribute to return.\n    \\returns Parsed attribute, use attr.id() != 0xffff to check for valid result.\n */\ndeCONZ::ZclAttribute parseXiaomiZclTag(const quint8 rtag, const deCONZ::ZclFrame &zclFrame)\n{\n    deCONZ::ZclAttribute result;\n\n    quint16 attrId = 0;\n    quint8 dataType = 0;\n    quint8 length = 0;\n    quint16 structElements = 0;\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n    stream.setFloatingPointPrecision(QDataStream::SinglePrecision);\n\n    while (attrId == 0 && !stream.atEnd())\n    {\n        quint16 a;\n        stream >> a;\n        stream >> dataType;\n\n        if (dataType == deCONZ::ZclCharacterString || dataType == deCONZ::ZclOctedString)\n        {\n            stream >> length;\n        }\n\n        if (a == 0xff01 && dataType == deCONZ::ZclCharacterString)\n        {\n            attrId = a;\n        }\n        else if (a == 0xff02 && dataType == 0x4c /*deCONZ::ZclStruct*/)\n        {\n            attrId = a;\n            stream >> structElements;\n        }\n        else if (a == 0x00f7 && dataType == deCONZ::ZclOctedString)\n        {\n            attrId = a;\n        }\n\n        if (dataType == deCONZ::ZclCharacterString && attrId != 0xff01)\n        {\n            for (; length > 0; length--) // skip string attribute\n            {\n                quint8 dummy;\n                stream >> dummy;\n            }\n        }\n    }\n\n    if (stream.atEnd() || attrId == 0)\n    {\n        return result;\n    }\n\n    quint8 tag = 0;\n\n    while (!stream.atEnd())\n    {\n        if (attrId == 0xff01 || attrId == 0x00f7)\n        {\n            stream >> tag;\n        }\n\n        stream >> dataType;\n\n        deCONZ::ZclAttribute atmp(tag, dataType, QLatin1String(\"\"), deCONZ::ZclRead, true);\n\n        if (!atmp.readFromStream(stream))\n        {\n            return result;\n        }\n\n        if (tag == rtag)\n        {\n            result = atmp;\n            break;\n        }\n\n        if (structElements > 0)\n        {\n            tag++; // running struct index\n        }\n    }\n\n    return result;\n}\n\n/*! A generic function to parse ZCL values from Xiaomi special report commands.\n    The item->parseParameters() is expected to be an object (given in the device description file).\n\n    {\"fn\": \"xiaomi:special\", \"ep\": endpoint, \"at\": attributeId, \"idx\": index, \"eval\": expression}\n\n    - endpoint: (optional), 0xff means any endpoint (default: 0xff)\n    - attributeId: string hex value of 0xff01, 0xff02 or 0x00f7.\n    - index: string hex value representing the tag or index in the structure\n    - expression: Javascript expression to transform the raw value (as alternative \"script\" can be used to reference a external JS script file)\n\n    Example: { \"parse\": {\"fn\": \"xiaomi:special\", \"at\": \"0xff01\", \"idx\": \"0x01\", \"eval\": \"Item.val = Attr.val\" } }\n */\nbool parseXiaomiSpecial(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    bool result = false;\n\n    if (zclFrame.commandId() != deCONZ::ZclReportAttributesId)\n    {\n        return result;\n    }\n\n    if (ind.clusterId() != 0x0000 && ind.clusterId() != 0xfcc0) // must be basic or lumi specific cluster\n    {\n        return result;\n    }\n\n    if (!item->parseFunction()) // init on first call\n    {\n        Q_ASSERT(!parseParameters.isNull());\n        if (parseParameters.isNull())\n        {\n            return result;\n        }\n\n        const auto map = parseParameters.toMap();\n\n        bool ok = true;\n        ZCL_Param param;\n\n        param.endpoint = BroadcastEndpoint; // default\n        param.clusterId = 0x0000;\n        \n        if (ind.clusterId() == 0xfcc0)\n        {\n            param.clusterId = 0xfcc0;\n            param.manufacturerCode = 0x115f;\n        }\n\n        if (map.contains(QLatin1String(\"ep\")))\n        {\n            param.endpoint = variantToUint(map[\"ep\"], UINT8_MAX, &ok);\n        }\n        const auto at = ok ? variantToUint(map[\"at\"], UINT16_MAX, &ok) : 0;\n        const auto idx = ok ? variantToUint(map[\"idx\"], UINT16_MAX, &ok) : 0;\n\n        DBG_Assert(at == 0xff01 || at == 0xff02 || at == 0x00f7);\n        if (!ok)\n        {\n            return result;\n        }\n\n        param.attributeCount = 2;\n        param.attributes[0] = at;\n        // keep tag/idx as second \"attribute id\"\n        param.attributes[1] = idx;\n\n        if (param.endpoint == AutoEndpoint)\n        {\n            param.endpoint = resolveAutoEndpoint(r);\n\n            if (param.endpoint == AutoEndpoint)\n            {\n                return result;\n            }\n        }\n\n        item->setParseFunction(parseXiaomiSpecial);\n        item->setZclProperties(param);\n    }\n\n    const auto &zclParam = item->zclParam();\n\n    if (!(ind.clusterId() == 0x0000 || ind.clusterId() == 0xfcc0) || zclFrame.payload().isEmpty())\n    {\n        return result;\n    }\n\n    if (zclParam.endpoint < BroadcastEndpoint && zclParam.endpoint != ind.srcEndpoint())\n    {\n        return result;\n    }\n\n    Q_ASSERT(zclParam.attributeCount == 2); // attribute id + tag/idx\n    const auto attr = parseXiaomiZclTag(zclParam.attributes[1], zclFrame);\n\n    int attrIndex = 0;\n    if (evalZclAttribute(r, item, ind, zclFrame, attrIndex, attr, parseParameters))\n    {\n        result = true;\n    }\n\n    return result;\n}\n\n/*! A function to parse IAS Zone status change notifications or read/report commands for IAS Zone status of the IAS Zone cluster.\n    The item->parseParameters() is expected to be an object (given in the device description file).\n\n    {\"fn\": \"ias:zonestatus\", \"mask\": expression}\n\n    - mask (optional): The bitmask to be applied for Alarm1 and Alarm2 of the IAS zone status value as list of strings\n\n    Example: { \"parse\": {\"fn\": \"ias:zonestatus\", \"mask\": \"alarm1,alarm2\" } }\n */\nbool parseIasZoneNotificationAndStatus(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    bool result = false;\n\n    if (ind.clusterId() != IAS_ZONE_CLUSTER_ID)\n    {\n        return result;\n    }\n\n    if (ind.srcEndpoint() != resolveAutoEndpoint(r))\n    {\n        return result;\n    }\n\n    if (zclFrame.isClusterCommand())  // is IAS Zone status notification?\n    {\n        if (zclFrame.commandId() != CMD_STATUS_CHANGE_NOTIFICATION)\n        {\n            return result;\n        }\n\n    }\n    else if (zclFrame.commandId() != deCONZ::ZclReadAttributesResponseId && zclFrame.commandId() != deCONZ::ZclReportAttributesId) // is read or report?\n    {\n        return result;\n    }\n\n    if (!item->parseFunction()) // init on first call\n    {\n        item->setParseFunction(parseIasZoneNotificationAndStatus);\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    quint16 zoneStatus = UINT16_MAX;\n\n    while (!stream.atEnd())\n    {\n        if (zclFrame.isClusterCommand())\n        {\n            quint8 extendedStatus;\n            quint8 zoneId;\n            quint16 delay;\n\n            stream >> zoneStatus;\n            stream >> extendedStatus; // reserved, set to 0\n            stream >> zoneId;\n            stream >> delay;\n\n            DBG_Assert(stream.status() == QDataStream::Ok);\n        }\n        else\n        {\n            quint16 attrId;\n            quint8 status;\n            quint8 dataType;\n\n            stream >> attrId;\n\n            if (zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n            {\n                stream >> status;\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n\n            stream >> dataType;\n            deCONZ::ZclAttribute attr(attrId, dataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n            if (!attr.readFromStream(stream))\n            {\n                break;\n            }\n\n            if (attr.id() == 0x0002)\n            {\n                zoneStatus = attr.numericValue().u16;\n                break;\n            }\n        }\n    }\n\n    if (zoneStatus != UINT16_MAX)\n    {\n        int mask = 0;\n        const char *suffix = item->descriptor().suffix;\n\n        if (suffix == RStateAlarm || suffix == RStateCarbonMonoxide || suffix == RStateFire || suffix == RStateOpen ||\n            suffix == RStatePresence || suffix == RStateVibration || suffix == RStateWater)\n        {\n            const auto map = parseParameters.toMap();\n\n            if (map.contains(QLatin1String(\"mask\")))\n            {\n                QStringList alarmMask = map[\"mask\"].toString().split(',', SKIP_EMPTY_PARTS);\n\n                if (alarmMask.contains(QLatin1String(\"alarm1\"))) { mask |= STATUS_ALARM1; }\n                if (alarmMask.contains(QLatin1String(\"alarm2\"))) { mask |= STATUS_ALARM2; }\n            }\n        }\n        else if (suffix == RStateTampered)\n        {\n            mask |= STATUS_TAMPER;\n        }\n        else if (suffix == RStateLowBattery)\n        {\n            mask |= STATUS_BATTERY;\n        }\n        else if (suffix == RStateTest)\n        {\n            mask |= STATUS_TEST;\n        }\n\n        item->setValue((zoneStatus & mask) != 0);\n        item->setLastZclReport(deCONZ::steadyTimeRef().ref);    // Treat as report\n\n        DeviceJS_ResourceItemValueChanged(item); // since this isn't going through JS add item to the changed set here\n        result = true;\n    }\n\n    return result;\n}\n\n/*! A function to write current time data to the time server cluster, syncing on-device RTC. Time calculations are borrowed from time.cpp.\n\n    {\"fn\": \"time\"}\n\n    - The function does not require any further parameters\n\n    Example: { \"write\": {\"fn\": \"time\"} }\n */\nbool writeTimeData(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &writeParameters)\n{\n    Q_UNUSED(writeParameters);\n    Q_UNUSED(item);\n\n    Q_ASSERT(r);\n    Q_ASSERT(apsCtrl);\n\n    bool result = false;\n    const auto rParent = r->parentResource() ? r->parentResource() : r;\n    const auto *extAddr = rParent->item(RAttrExtAddress);\n    const auto *nwkAddr = rParent->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    quint8 endpoint = resolveAutoEndpoint(r);\n\n    if (endpoint == AutoEndpoint)\n    {\n        return result;\n    }\n    \n    DBG_Printf(DBG_DDF, \"%s correcting time drift...\\n\", r->item(RAttrUniqueId)->toCString());\n\n    const QDateTime now = QDateTime::currentDateTimeUtc();\n    const QDateTime yearStart(QDate(QDate::currentDate().year(), 1, 1), QTime(0, 0), Qt::UTC);\n    const QTimeZone timeZone(QTimeZone::systemTimeZoneId());\n\n    QDateTime epoch;\n\n    quint32 time_now = 0xFFFFFFFF;              // id 0x0000 Time\n    qint8 time_status = 0x0D;                   // id 0x0001 TimeStatus Master|MasterZoneDst|Superseding\n    qint32 time_zone = 0xFFFFFFFF;              // id 0x0002 TimeZone\n    quint32 time_dst_start = 0xFFFFFFFF;        // id 0x0003 DstStart\n    quint32 time_dst_end = 0xFFFFFFFF;          // id 0x0004 DstEnd\n    qint32 time_dst_shift = 0xFFFFFFFF;         // id 0x0005 DstShift\n    quint32 time_valid_until_time = 0xFFFFFFFF; // id 0x0009 ValidUntilTime\n\n    epoch = QDateTime(QDate(2000, 1, 1), QTime(0, 0), Qt::UTC);;\n    time_now = epoch.secsTo(now);\n    time_zone = timeZone.offsetFromUtc(yearStart);\n\n    if (timeZone.hasTransitions())\n    {\n        const QTimeZone::OffsetData dstStartOffsetData = timeZone.nextTransition(yearStart);\n        const QTimeZone::OffsetData dstEndOffsetData = timeZone.nextTransition(dstStartOffsetData.atUtc);\n        time_dst_start = epoch.secsTo(dstStartOffsetData.atUtc);\n        time_dst_end = epoch.secsTo(dstEndOffsetData.atUtc);\n        time_dst_shift = dstStartOffsetData.daylightTimeOffset;\n    }\n\n    time_valid_until_time = time_now + (3600 * 24);\n\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame zclFrame;\n\n    req.setDstEndpoint(endpoint);\n    req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    req.setDstAddressMode(deCONZ::ApsExtAddress);\n    req.dstAddress().setNwk(nwkAddr->toNumber());\n    req.dstAddress().setExt(extAddr->toNumber());\n    req.setClusterId(TIME_CLUSTER_ID);\n    req.setProfileId(HA_PROFILE_ID);\n    req.setSrcEndpoint(1); // TODO\n\n    zclFrame.setSequenceNumber(zclNextSequenceNumber());\n    zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n\n    zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << (quint16) 0x0000; // Time\n        stream << (quint8) deCONZ::ZclUtcTime;\n        stream << time_now;\n\n        stream << (quint16) 0x0001; // Time Status\n        stream << (quint8) deCONZ::Zcl8BitBitMap;\n        stream << time_status;\n\n        stream << (quint16) 0x0002; // Time Zone\n        stream << (quint8) deCONZ::Zcl32BitInt;\n        stream << time_zone;\n\n        stream << (quint16) 0x0003; // Dst Start\n        stream << (quint8) deCONZ::Zcl32BitUint;\n        stream << time_dst_start;\n\n        stream << (quint16) 0x0004; // Dst End\n        stream << (quint8) deCONZ::Zcl32BitUint;\n        stream << time_dst_end;\n\n        stream << (quint16) 0x0005; // Dst Shift\n        stream << (quint8) deCONZ::Zcl32BitInt;\n        stream << time_dst_shift;\n\n        stream << (quint16) 0x0009; // Valid Until Time\n        stream << (quint8) deCONZ::ZclUtcTime;\n        stream << time_valid_until_time;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n    result = apsCtrl->apsdeDataRequest(req) == deCONZ::Success;\n\n    return result;\n}\n\n/*! A specialized function to parse time (utc), local and last set time from read/report commands of the time cluster and auto-sync time if needed.\n    The item->parseParameters() is expected to be an object (given in the device description file).\n\n    {\"fn\": \"time\"}\n\n    - The function does not require any further parameters\n\n    Example: { \"parse\": {\"fn\": \"time\"} }\n */\nbool parseAndSyncTime(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters)\n{\n    Q_UNUSED(parseParameters);\n    bool result = false;\n\n    if (ind.clusterId() != TIME_CLUSTER_ID)\n    {\n        return result;\n    }\n\n    if (ind.srcEndpoint() != resolveAutoEndpoint(r))\n    {\n        return result;\n    }\n\n    if (zclFrame.commandId() != deCONZ::ZclReadAttributesResponseId && zclFrame.commandId() != deCONZ::ZclReportAttributesId) // is read or report?\n    {\n        return result;\n    }\n\n    if (!item->parseFunction()) // init on first call\n    {\n        item->setParseFunction(parseAndSyncTime);\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    const QDateTime epoch = QDateTime(QDate(2000, 1, 1), QTime(0, 0), Qt::UTC);\n    const char *suffix = item->descriptor().suffix;\n\n    while (!stream.atEnd())\n    {\n        quint16 attrId;\n        quint8 status;\n        quint8 dataType;\n\n        stream >> attrId;\n\n        if (zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n        {\n            stream >> status;\n            if (status != deCONZ::ZclSuccessStatus)\n            {\n                continue;\n            }\n        }\n\n        stream >> dataType;\n        deCONZ::ZclAttribute attr(attrId, dataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n        if (!attr.readFromStream(stream))\n        {\n            break;\n        }\n\n        switch (attrId) {\n        case TIME_ATTRID_TIME:\n        {\n            if (suffix == RStateUtc)\n            {\n                QDateTime time = epoch.addSecs(attr.numericValue().u32);\n                const qint32 drift = QDateTime::currentDateTimeUtc().secsTo(time);\n\n                if (item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                {\n                    item->setValue(time, ResourceItem::SourceDevice);\n                }\n\n                if (drift < -10 || drift > 10)\n                {\n                    DBG_Printf(DBG_DDF, \"%s/%s : time drift detected, %d seconds to now\\n\", r->item(RAttrUniqueId)->toCString(), suffix, drift);\n\n                    auto *apsCtrl = deCONZ::ApsController::instance();\n\n                    if (writeTimeData(r, item, apsCtrl, item->toVariant())) // last parameter's content is irrelevant\n                    {\n                        // Check if drift got eliminated\n                        const auto &ddfItem = DDF_GetItem(item);\n                        const auto readFunction = DA_GetReadFunction(ddfItem.readParameters);\n                        auto res = readFunction(r, item, apsCtrl, ddfItem.readParameters);\n\n                        if (res.isEnqueued)\n                        {\n                            DBG_Printf(DBG_DDF, \"%s time verification queued...\\n\", r->item(RAttrUniqueId)->toCString());\n                        }\n                    }\n                }\n                else\n                {\n                    DBG_Printf(DBG_DDF, \"%s/%s : NO considerable time drift detected, %d seconds to now\\n\", r->item(RAttrUniqueId)->toCString(), suffix, drift);\n                }\n\n                item->setLastZclReport(deCONZ::steadyTimeRef().ref);    // Treat as report\n\n                result = true;\n            }\n        }\n            break;\n\n        case TIME_ATTRID_LOCAL_TIME:\n        {\n            if (suffix == RStateLocaltime)\n            {\n                QDateTime time = epoch.addSecs(attr.numericValue().u32 - QDateTime::currentDateTime().offsetFromUtc());\n\n                if (item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                {\n                    item->setValue(time, ResourceItem::SourceDevice);\n                }\n\n                item->setLastZclReport(deCONZ::steadyTimeRef().ref);     // Treat as report\n\n                result = true;\n            }\n        }\n            break;\n\n        case TIME_ATTRID_LAST_SET_TIME:\n        {\n            if (suffix == RStateLastSet)\n            {\n                QDateTime time = epoch.addSecs(attr.numericValue().u32);\n\n                if (item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                {\n                    item->setValue(time, ResourceItem::SourceDevice);\n                }\n\n                item->setLastZclReport(deCONZ::steadyTimeRef().ref);     // Treat as report\n\n                result = true;\n            }\n        }\n            break;\n        }\n    }\n\n    if (result)\n    {\n        DeviceJS_ResourceItemValueChanged(item);\n    }\n\n    return result;\n}\n\n/*! A generic function to read ZCL attributes.\n    The item->readParameters() is expected to be an object (given in the device description file).\n\n    { \"fn\": \"zcl:attr\", \"ep\": endpoint, \"cl\" : clusterId, \"mf\": manufacturerCode, \"at\": attributeId, \"noseq\": noSequenceNumber  }\n\n    - endpoint: the destination endpoint, use 0 for auto endpoint (from the uniqueid)\n    - clusterId: string hex value\n    - manufacturerCode: (optional) string hex value\n    - attributeId: string hex value or array of up to 8 string hex values\n    - noSequenceNumber: (optional) bool must be set to `true` and must only be present if needed\n\n    Example: { \"read\": {\"fn\": \"zcl:attr\", \"ep\": 1, \"cl\": \"0x0402\", \"mf\": \"0x110b\", \"at\": \"0x0000\"} }\n */\nstatic DA_ReadResult readZclAttribute(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &readParameters)\n{\n    Q_UNUSED(item)\n\n    DA_ReadResult result{};\n\n    Q_ASSERT(!readParameters.isNull());\n    if (readParameters.isNull())\n    {\n        return result;\n    }\n\n    auto *rTop = r->parentResource() ? r->parentResource() : r;\n\n    const auto *extAddr = rTop->item(RAttrExtAddress);\n    const auto *nwkAddr = rTop->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    auto param = getZclParam(readParameters.toMap());\n\n    if (!param.valid)\n    {\n        return result;\n    }\n\n    if (param.endpoint == AutoEndpoint)\n    {\n        if (r->prefix() == RDevices)\n        {\n            param.endpoint = item->readEndpoint();\n        }\n        else\n        {\n            param.endpoint = resolveAutoEndpoint(r);\n        }\n\n        if (param.endpoint == AutoEndpoint)\n        {\n            return result;\n        }\n    }\n\n    const auto zclResult = ZCL_ReadAttributes(param, extAddr->toNumber(), nwkAddr->toNumber(), apsCtrl);\n\n    result.isEnqueued = zclResult.isEnqueued;\n    result.apsReqId = zclResult.apsReqId;\n    result.sequenceNumber = zclResult.sequenceNumber;\n    result.clusterId = param.clusterId;\n    result.ignoreResponseSequenceNumber = param.ignoreResponseSeq == 1;\n\n    return result;\n}\n\n/*! A generic function to write ZCL attributes.\n    The \\p writeParameters is expected to contain one object (given in the device description file).\n\n    { \"fn\": \"zcl:attr\", \"ep\": endpoint, \"cl\": clusterId, \"mf\": manufacturerCode, \"at\": attributeId, \"dt\": zclDataType, \"eval\": expression }\n\n    - endpoint: the destination endpoint, use 0 for auto endpoint (from the uniqueid)\n    - clusterId: string hex value\n    - manufacturerCode: (optional) string hex value\n    - attributeId: string hex value\n    - zclDataType: string hex value\n    - expression: to transform the item value to the attribute value\n\n    Example: \"write\": {\"fn\": \"zcl:attr\", \"cl\": \"0x0000\", \"mf\": \"0x11F5\", \"at\": \"0xff0d\",  \"dt\": \"0x20\", \"eval\": \"Item.val\"}\n */\nbool writeZclAttribute(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &writeParameters)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(item);\n    Q_ASSERT(apsCtrl);\n\n    bool result = false;\n\n    const auto rParent = r->parentResource() ? r->parentResource() : r;\n    const auto *extAddr = rParent->item(RAttrExtAddress);\n    const auto *nwkAddr = rParent->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    const auto map = writeParameters.toMap();\n    ZCL_Param param = getZclParam(map);\n\n    if (!param.valid)\n    {\n        return result;\n    }\n\n    if (param.attributeCount != 1)\n    {\n        return result;\n    }\n\n    if (param.endpoint == AutoEndpoint)\n    {\n        param.endpoint = resolveAutoEndpoint(r);\n\n        if (param.endpoint == AutoEndpoint)\n        {\n            return result;\n        }\n    }\n\n    if (!map.contains(\"dt\") || !map.contains(\"eval\"))\n    {\n        return result;\n    }\n\n    bool ok;\n    const auto dataType = variantToUint(map.value(\"dt\"), UINT8_MAX, &ok);\n    const auto expr = map.value(\"eval\").toString();\n    if (!ok || expr.isEmpty())\n    {\n        return result;\n    }\n    deCONZ::ZclAttribute attribute(param.attributes[0], dataType, QLatin1String(\"\"), deCONZ::ZclReadWrite, true);\n\n    DeviceJs &engine = *DeviceJs::instance();\n    engine.reset();\n    engine.setResource(r);\n    engine.setItem(item);\n    if (engine.evaluate(expr) == JsEvalResult::Ok)\n    {\n        const auto value = engine.result();\n        DBG_Printf(DBG_DDF, \"%s/%s expression: %s --> %s\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, qPrintable(expr), qPrintable(value.toString()));\n        attribute.setValue(value);\n    }\n    else\n    {\n        DBG_Printf(DBG_DDF, \"failed to evaluate expression for %s/%s: %s, err: %s\\n\", qPrintable(r->item(RAttrUniqueId)->toString()), item->descriptor().suffix, qPrintable(expr), qPrintable(engine.errorString()));\n        return result;\n    }\n\n    const auto zclResult = ZCL_WriteAttribute(param, extAddr->toNumber(), nwkAddr->toNumber(), apsCtrl, &attribute);\n\n    result = zclResult.isEnqueued;\n    return result;\n}\n\n/*! A generic function to send a cluster-specific ZCL command.\n    The \\p cmdParameters is expected to contain one object (given in the device description file).\n\n    { \"fn\": \"zcl:cmd\", \"ep\": endpoint, \"cl\": clusterId, \"mf\": manufacturerCode, \"cmd\": commandId, \"fc\": frameControl, \"eval\": expression }\n\n    - endpoint: the destination endpoint, use 0 for auto endpoint (from the uniqueid)\n    - clusterId: string hex value\n    - manufacturerCode: (optional) string hex value\n    - commandId: string hex value\n    - frameControl: (optional) string hex value, OR combined 8-bit bitmap to overwrite ZCL frame control\n\n          ZclFCProfileCommand          = 0x00,\n          ZclFCClusterCommand          = 0x01,\n          ZclFCManufacturerSpecific    = 0x04,\n          ZclFCDirectionServerToClient = 0x08,\n          ZclFCDirectionClientToServer = 0x00,\n          ZclFCEnableDefaultResponse   = 0x00,\n          ZclFCDisableDefaultResponse  = 0x10\n\n    - expression: (optional) to transform the item value to the command payload as hex string value\n\n    Example: \"read\": {\"fn\": \"zcl:cmd\", \"ep\": \"0x0b\", \"cl\": \"0x0000\", \"mf\": \"0x100b\", \"cmd\": \"0xc0\", \"eval\": \"'002d00000040'\"}\n */\nstatic DA_ReadResult sendZclCommand(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &cmdParameters)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(item);\n    Q_ASSERT(apsCtrl);\n\n    DA_ReadResult result{};\n\n    const auto rParent = r->parentResource() ? r->parentResource() : r;\n    const auto *extAddr = rParent->item(RAttrExtAddress);\n    const auto *nwkAddr = rParent->item(RAttrNwkAddress);\n\n    if (!extAddr || !nwkAddr)\n    {\n        return result;\n    }\n\n    const auto map = cmdParameters.toMap();\n    ZCL_Param param = getZclParam(map);\n\n    if (!param.valid)\n    {\n        return result;\n    }\n\n    std::vector<uint8_t> payload;\n\n    if (map.contains(\"eval\"))\n    {\n        const auto expr = map.value(\"eval\").toString();\n        if (expr.isEmpty())\n        {\n            return result;\n        }\n        DeviceJs &engine = *DeviceJs::instance();\n        engine.reset();\n        engine.setResource(r);\n        engine.setItem(item);\n        if (engine.evaluate(expr) == JsEvalResult::Ok)\n        {\n            const auto value = engine.result();\n            DBG_Printf(DBG_DDF, \"%s/%s expression: %s --> %s\\n\", r->item(RAttrUniqueId)->toCString(), item->descriptor().suffix, qPrintable(expr), qPrintable(value.toString()));\n            auto a = QByteArray::fromHex(value.toString().toLatin1());\n            for (const auto b : a)\n            {\n                payload.push_back(b);\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_DDF, \"failed to evaluate expression for %s/%s: %s, err: %s\\n\", qPrintable(r->item(RAttrUniqueId)->toString()), item->descriptor().suffix, qPrintable(expr), qPrintable(engine.errorString()));\n            return result;\n        }\n    }\n\n    const auto zclResult = ZCL_SendCommand(param, extAddr->toNumber(), nwkAddr->toNumber(), apsCtrl, &payload);\n\n    result.isEnqueued = zclResult.isEnqueued;\n    result.apsReqId = zclResult.apsReqId;\n    result.sequenceNumber = zclResult.sequenceNumber;\n    result.clusterId = param.clusterId;\n    result.ignoreResponseSequenceNumber = param.ignoreResponseSeq == 1;\n\n    return result;\n}\n\n/*! A generic function to send a cluster-specific ZCL command.\n    The \\p cmdParameters is expected to contain one object (given in the device description file).\n\n    { \"fn\": \"zcl:cmd\", \"ep\": endpoint, \"cl\": clusterId, \"mf\": manufacturerCode, \"cmd\": commandId, \"eval\": expression }\n\n    - endpoint: the destination endpoint, use 0 for auto endpoint (from the uniqueid)\n    - clusterId: string hex value\n    - manufacturerCode: (optional) string hex value\n    - commandId: string hex value\n    - expression: (optional) to transform the item value to the command payload as hex string value\n\n    Example: \"write\": {\"fn\": \"zcl:cmd\", \"cl\": \"0x0000\", \"mf\": \"0x100b\", \"cmd\": \"0xc0\",  \"eval\": \"'002d00000040'\"}\n */\nbool writeZclCommand(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &cmdParameters)\n{\n    const auto result = sendZclCommand(r, item, apsCtrl, cmdParameters);\n    return result.isEnqueued;\n}\n\nParseFunction_t DA_GetParseFunction(const QVariant &params)\n{\n    ParseFunction_t result = nullptr;\n\n    const std::array<ParseFunction, 8> functions =\n    {\n        ParseFunction(QLatin1String(\"zcl\"), 1, parseZclAttribute), // Deprecated\n        ParseFunction(QLatin1String(\"zcl:attr\"), 1, parseZclAttribute),\n        ParseFunction(QLatin1String(\"zcl:cmd\"), 1, parseZclAttribute),\n        ParseFunction(QLatin1String(\"xiaomi:special\"), 1, parseXiaomiSpecial),\n        ParseFunction(QLatin1String(\"ias:zonestatus\"), 1, parseIasZoneNotificationAndStatus),\n        ParseFunction(QLatin1String(\"tuya\"), 1, parseTuyaData),\n        ParseFunction(QLatin1String(\"numtostr\"), 1, parseNumericToString),\n        ParseFunction(QLatin1String(\"time\"), 1, parseAndSyncTime)\n    };\n\n    QString fnName;\n\n    if (params.type() == QVariant::Map)\n    {\n        const auto params1 = params.toMap();\n        if (params1.isEmpty())\n        {  }\n        else if (params1.contains(QLatin1String(\"fn\")))\n        {\n            fnName = params1[\"fn\"].toString();\n        }\n        else\n        {\n            fnName = QLatin1String(\"zcl:attr\"); // default\n        }\n    }\n\n    for (const auto &f : functions)\n    {\n        if (f.name == fnName)\n        {\n            result = f.fn;\n            break;\n        }\n    }\n\n    return result;\n}\n\nReadFunction_t DA_GetReadFunction(const QVariant &params)\n{\n    ReadFunction_t result = nullptr;\n\n    const std::array<ReadFunction, 4> functions =\n    {\n        ReadFunction(QLatin1String(\"zcl\"), 1, readZclAttribute), // Deprecated\n        ReadFunction(QLatin1String(\"zcl:attr\"), 1, readZclAttribute),\n        ReadFunction(QLatin1String(\"zcl:cmd\"), 1, sendZclCommand),\n        ReadFunction(QLatin1String(\"tuya\"), 1, readTuyaAllData)\n    };\n\n    QString fnName;\n\n    if (params.type() == QVariant::Map)\n    {\n        const auto params1 = params.toMap();\n        if (params1.isEmpty())\n        {  }\n        else if (params1.contains(QLatin1String(\"fn\")))\n        {\n            fnName = params1[\"fn\"].toString();\n        }\n        else\n        {\n            fnName = QLatin1String(\"zcl:attr\"); // default\n        }\n    }\n\n    for (const auto &f : functions)\n    {\n        if (f.name == fnName)\n        {\n            result = f.fn;\n            break;\n        }\n    }\n\n    return result;\n}\n\nWriteFunction_t DA_GetWriteFunction(const QVariant &params)\n{\n    WriteFunction_t result = nullptr;\n\n    const std::array<WriteFunction, 4> functions =\n    {\n        WriteFunction(QLatin1String(\"zcl\"), 1, writeZclAttribute), // Deprecated\n        WriteFunction(QLatin1String(\"zcl:attr\"), 1, writeZclAttribute),\n        WriteFunction(QLatin1String(\"zcl:cmd\"), 1, writeZclCommand),\n        WriteFunction(QLatin1String(\"tuya\"), 1, writeTuyaData)\n    };\n\n    QString fnName;\n\n    if (params.type() == QVariant::Map)\n    {\n        const auto params1 = params.toMap();\n        if (params1.isEmpty())\n        {  }\n        else if (params1.contains(QLatin1String(\"fn\")))\n        {\n            fnName = params1[\"fn\"].toString();\n        }\n        else\n        {\n            fnName = QLatin1String(\"zcl:attr\"); // default\n        }\n    }\n\n    for (const auto &f : functions)\n    {\n        if (f.name == fnName)\n        {\n            result = f.fn;\n            break;\n        }\n    }\n\n    return result;\n}\n\n/* APS core queue tracking\n\n   Track the running APS queue to aid scheduling of new APS requests\n   in order to not overhelm the queue. The aim is to execute low priority tasks,\n   like polling and binding maintenance, only when the queue is not too busy.\n   This leaves room to send high priority commands e.g. to control a light\n   without waiting for low priority APS request to be finished.\n */\n#define APS_BUSY_TABLE_SIZE 32\n\nstruct DA_ReqBusy\n{\n    uint64_t dstExtAddr;\n    int64_t tref;\n    uint16_t clusterId;\n    uint8_t dstEndpoint;\n    uint8_t apsRequestId;\n};\n\nstatic unsigned _DA_ApsUnconfirmedCount = 0;\nstatic DA_ReqBusy _DA_BusyTable[APS_BUSY_TABLE_SIZE];\n\n/*! Returns number of APS requests busy in the core APS queue. */\nunsigned DA_ApsUnconfirmedRequests()\n{\n    return _DA_ApsUnconfirmedCount;\n}\n\n/*! Returns number of APS requests, for \\p extAddr, busy in the core APS queue. */\nunsigned DA_ApsUnconfirmedRequestsForExtAddress(uint64_t extAddr)\n{\n    unsigned result = 0;\n\n    if (_DA_ApsUnconfirmedCount != 0)\n    {\n        for (unsigned i = 0; i < APS_BUSY_TABLE_SIZE; i++)\n        {\n            DA_ReqBusy *e = &_DA_BusyTable[i];\n\n            if (e->tref != 0 && e->dstExtAddr == extAddr)\n            {\n                result++;\n            }\n\n            if (result == _DA_ApsUnconfirmedCount)\n            {\n                break; // nothing more to count\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Call back when an APS request is put in the core APS queue.\n    Record it here to track it until it's confirmed aka done.\n */\nvoid DA_ApsRequestEnqueued(const deCONZ::ApsDataRequest &req)\n{\n    if (!req.dstAddress().hasExt())\n    {\n        DBG_Assert(!req.dstAddress().isNwkUnicast());\n        return;\n    }\n\n    const int64_t now = deCONZ::steadyTimeRef().ref / 1000;\n\n    for (unsigned i = 0; i < APS_BUSY_TABLE_SIZE; i++)\n    {\n        DA_ReqBusy *e = &_DA_BusyTable[i];\n\n        if (e->tref != 0 && ((now - e->tref) > 60))\n        {\n            // confirm timeout, should normally not happen\n            DBG_Assert(_DA_ApsUnconfirmedCount > 0);\n            if (_DA_ApsUnconfirmedCount > 0)\n            {\n                _DA_ApsUnconfirmedCount--;\n            }\n            memset(e, 0, sizeof(*e));\n        }\n\n        if (e->tref == 0)\n        {\n            e->dstExtAddr = req.dstAddress().ext();\n            e->dstEndpoint = req.dstEndpoint();\n            e->apsRequestId = req.id();\n            e->clusterId = req.clusterId();\n            e->tref = now;\n            DBG_Assert(_DA_ApsUnconfirmedCount < APS_BUSY_TABLE_SIZE);\n            if (_DA_ApsUnconfirmedCount < APS_BUSY_TABLE_SIZE)\n            {\n                _DA_ApsUnconfirmedCount++;\n            }\n            return;\n        }\n    }\n}\n\n/*! Callback when a APS request is confirmed, aka when it has been sent by the\n    firmware or an error occured. The actual status isn't considered here, we\n    only care that the APS request is 'done'.\n */\nvoid DA_ApsRequestConfirmed(const deCONZ::ApsDataConfirm &conf)\n{\n    if (!conf.dstAddress().hasExt())\n    {\n        return;\n    }\n\n    if (_DA_ApsUnconfirmedCount != 0)\n    {\n        for (unsigned i = 0; i < APS_BUSY_TABLE_SIZE; i++)\n        {\n            DA_ReqBusy *e = &_DA_BusyTable[i];\n            if (e->apsRequestId != conf.id()) continue;\n            if (e->dstExtAddr != conf.dstAddress().ext()) continue;\n            if (e->dstEndpoint != conf.dstEndpoint()) continue;\n\n            memset(e, 0, sizeof(*e));\n            _DA_ApsUnconfirmedCount--;\n            return;\n        }\n    }\n}\n"
        },
        {
          "name": "device_access_fn.h",
          "type": "blob",
          "size": 1.83984375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_ACCESS_FN_H\n#define DEVICE_ACCESS_FN_H\n\n#include <QString>\n#include <QVariant>\n#include <vector>\n\nclass Resource;\nclass ResourceItem;\n\nnamespace deCONZ {\n    class ApsController;\n    class ApsDataConfirm;\n    class ApsDataRequest;\n    class ApsDataIndication;\n    class ZclFrame;\n}\n\nstruct DA_ReadResult\n{\n    bool isEnqueued = false;\n    bool ignoreResponseSequenceNumber = false;\n    quint8 apsReqId = 0;\n    quint8 sequenceNumber = 0;\n    quint16 clusterId = 0;\n};\n\ntypedef bool (*ParseFunction_t)(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters);\ntypedef DA_ReadResult (*ReadFunction_t)(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &readParameters);\ntypedef bool (*WriteFunction_t)(const Resource *r, const ResourceItem *item, deCONZ::ApsController *apsCtrl, const QVariant &writeParameters);\n\n// temporary expose parseTuyaData for check in tuya.cpp\nbool parseTuyaData(Resource *r, ResourceItem *item, const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame, const QVariant &parseParameters);\nParseFunction_t DA_GetParseFunction(const QVariant &params);\nReadFunction_t DA_GetReadFunction(const QVariant &params);\nWriteFunction_t DA_GetWriteFunction(const QVariant &params);\n\nunsigned DA_ApsUnconfirmedRequests();\nunsigned DA_ApsUnconfirmedRequestsForExtAddress(uint64_t extAddr);\nvoid DA_ApsRequestEnqueued(const deCONZ::ApsDataRequest &req);\nvoid DA_ApsRequestConfirmed(const deCONZ::ApsDataConfirm &conf);\n\n#endif // DEVICE_ACCESS_FN_H\n"
        },
        {
          "name": "device_compat.cpp",
          "type": "blob",
          "size": 8.80078125,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <memory>\n#include \"database.h\"\n#include \"device.h\"\n#include \"device_compat.h\"\n#include \"resource.h\"\n#include \"sensor.h\"\n#include \"light_node.h\"\n#include \"utils/utils.h\"\n\nint getFreeSensorId();\nint getFreeLightId();\n\n#define READ_GROUPS            (1 << 5) // from web_plugin_private.h\n\n/*! Overloads to add specific resources in higher layer.\n    Since Device class doesn't know anything about web plugin or testing code,\n    this is a free standing function which needs to be implemented in the higher layer.\n*/\nResource *DEV_AddResource(const Sensor &sensor);\nResource *DEV_AddResource(const LightNode &lightNode);\n\n/*! V1 compatibility function to create SensorNodes based on sub-device description.\n */\nstatic Resource *DEV_InitSensorNodeFromDescription(Device *device, const DeviceDescription &ddf, const DeviceDescription::SubDevice &sub, const QString &uniqueId)\n{\n    Sensor sensor;\n    QString rUniqueId = uniqueId;\n    DeviceDescriptions *dd = DeviceDescriptions::instance();\n    QString type = dd->constantToString(sub.type);\n\n    /*  There are sub-devices which may have a different uniqueid as the DDF template states.\n        For example: Sunricher ZHASwitches with -1000 or -0006 cluster id. The legacy code created these\n                     based on the simple descriptor clusters, which differed between firmware versions.\n\n        This function handles the case that there is only once sub-device in the DDF.\n\n          1. Check if there is already a ZHASwitch with same \"type\" and uniqueid endpoint in 'sensors' table.\n          2. If so keep using it even if the uniqueid cluster is different.\n     */\n    if (ddf.subDevices.size() == 1 && type == QLatin1String(\"ZHASwitch\") && sub.uniqueId.size() > 1)\n    {\n        const auto uniqueIds =  DB_LoadLegacySensorUniqueIds(device->item(RAttrUniqueId)->toLatin1String(), qPrintable(type));\n\n        if (uniqueIds.size() == 1 && uniqueIds.front() != uniqueId.toStdString())\n        {\n            const QString u = QString::fromStdString(uniqueIds.front());\n\n            unsigned ep = endpointFromUniqueId(u);\n            if (ep == sub.uniqueId.at(1).toUInt(nullptr, 0))\n            {\n                rUniqueId = u;\n            }\n        }\n    }\n\n    sensor.fingerPrint() = sub.fingerPrint;\n    sensor.address().setExt(device->item(RAttrExtAddress)->toNumber());\n    sensor.address().setNwk(device->item(RAttrNwkAddress)->toNumber());\n    sensor.setModelId(device->item(RAttrModelId)->toCString());\n    sensor.setManufacturer(device->item(RAttrManufacturerName)->toCString());\n    sensor.setType(type);\n    sensor.setUniqueId(rUniqueId);\n    sensor.setNode(const_cast<deCONZ::Node*>(device->node()));\n    R_SetValue(&sensor, RConfigOn, true, ResourceItem::SourceApi);\n\n    auto dbItem = std::make_unique<DB_LegacyItem>();\n    dbItem->uniqueId = sensor.item(RAttrUniqueId)->toCString();\n\n    {\n        dbItem->column = \"sid\";\n\n        if (DB_LoadLegacySensorValue(dbItem.get()))\n        {\n            sensor.setId(toLatin1String(dbItem->value));\n        }\n        else\n        {\n            sensor.setId(QString::number(getFreeSensorId()));\n            sensor.setNeedSaveDatabase(true);\n        }\n    }\n\n    {\n        dbItem->column = \"name\";\n        if (DB_LoadLegacySensorValue(dbItem.get()))\n        {\n            sensor.setName(dbItem->value.c_str());\n        }\n        else\n        {\n            QString friendlyName = sensor.type();\n            if (friendlyName.startsWith(\"ZHA\") || friendlyName.startsWith(\"ZLL\"))\n            {\n                friendlyName = friendlyName.mid(3);\n            }\n            sensor.setName(QString(\"%1 %2\").arg(friendlyName, sensor.id()));\n            sensor.setNeedSaveDatabase(true);\n        }\n    }\n\n    sensor.rx();\n\n    auto *r = DEV_AddResource(sensor);\n    Q_ASSERT(r);\n\n    device->addSubDevice(r);\n\n    return r;\n}\n\n/*! V1 compatibility function to create LightsNode based on sub-device description.\n */\nstatic Resource *DEV_InitLightNodeFromDescription(Device *device, const DeviceDescription::SubDevice &sub, const QString &uniqueId)\n{\n    LightNode lightNode;\n\n    {\n        const auto ls = uniqueId.split('-', SKIP_EMPTY_PARTS);\n        if (ls.size() >= 2 && device->node())\n        {\n            bool ok;\n            const uint ep = ls[1].toUInt(&ok, 16);\n            deCONZ::SimpleDescriptor sd;\n            if (device->node()->copySimpleDescriptor(ep, &sd) == 0)\n            {\n                lightNode.setHaEndpoint(sd);\n            }\n        }\n    }\n\n    // check if a sub-resource explicitly has static modelid / manufacturername (example.: FLS-PP3)\n    int thingsDone = 0;\n    for (const DeviceDescription::Item &ddfItem : sub.items)\n    {\n        if (ddfItem.descriptor.suffix == RAttrManufacturerName && ddfItem.isStatic)\n        {\n            lightNode.setManufacturerName(ddfItem.defaultValue.toString());\n            thingsDone++;\n        }\n        else if (ddfItem.descriptor.suffix == RAttrModelId && ddfItem.isStatic)\n        {\n            lightNode.setModelId(ddfItem.defaultValue.toString());\n            thingsDone++;\n        }\n\n        if (thingsDone == 2) // break out early if everything was done what could be done\n        {\n            break;\n        }\n    }\n\n    if (lightNode.modelId().isEmpty())\n    {\n        lightNode.setModelId(device->item(RAttrModelId)->toCString());\n    }\n\n    if (lightNode.manufacturer().isEmpty())\n    {\n        lightNode.setManufacturerName(device->item(RAttrManufacturerName)->toCString());\n    }\n\n    lightNode.address().setExt(device->item(RAttrExtAddress)->toNumber());\n    lightNode.address().setNwk(device->item(RAttrNwkAddress)->toNumber());\n\n\n    lightNode.setManufacturerCode(device->node()->nodeDescriptor().manufacturerCode());\n    lightNode.setNode(const_cast<deCONZ::Node*>(device->node())); // TODO this is evil\n\n    lightNode.item(RAttrType)->setValue(DeviceDescriptions::instance()->constantToString(sub.type));\n    lightNode.setUniqueId(uniqueId);\n    lightNode.enableRead(READ_GROUPS);\n\n    auto dbItem = std::make_unique<DB_LegacyItem>();\n    dbItem->uniqueId = lightNode.item(RAttrUniqueId)->toCString();\n\n    {\n        dbItem->column = \"id\";\n\n        if (DB_LoadLegacyLightValue(dbItem.get()))\n        {\n            lightNode.setId(toLatin1String(dbItem->value));\n        }\n        else\n        {\n            lightNode.setId(QString::number(getFreeLightId()));\n            lightNode.setNeedSaveDatabase(true);\n        }\n    }\n\n    {\n        dbItem->column = \"name\";\n        if (DB_LoadLegacyLightValue(dbItem.get()))\n        {\n            lightNode.setName(dbItem->value.c_str());\n        }\n        else\n        {\n            lightNode.setName(QString(\"%1 %2\").arg(lightNode.type(), lightNode.id()));\n            lightNode.setNeedSaveDatabase(true);\n        }\n    }\n\n    {\n        dbItem->column = \"groups\";\n        if (DB_LoadLegacyLightValue(dbItem.get()))\n        {\n            const auto groupList = QString(static_cast<QLatin1String>(dbItem->value)).split(',', SKIP_EMPTY_PARTS);\n\n            for (const auto &g : groupList)\n            {\n                bool ok = false;\n                uint gid = g.toUShort(&ok, 0);\n                if (!ok) { continue; }\n\n                auto i = std::find_if(lightNode.groups().cbegin(), lightNode.groups().cend(), [gid](const auto &group)\n                {\n                    return gid == group.id;\n                });\n\n                if (i == lightNode.groups().cend())\n                {\n                    GroupInfo groupInfo;\n                    groupInfo.id = gid;\n                    groupInfo.state = GroupInfo::StateInGroup;\n                    lightNode.groups().push_back(groupInfo);\n                }\n            }\n        }\n    }\n\n    // remove some items which need to be specified via DDF\n    lightNode.removeItem(RStateOn);\n    lightNode.removeItem(RStateBri);\n    lightNode.removeItem(RStateHue);\n    lightNode.removeItem(RStateSat);\n    lightNode.removeItem(RStateAlert);\n\n    lightNode.rx();\n\n    auto *r = DEV_AddResource(lightNode);\n    Q_ASSERT(r);\n\n    device->addSubDevice(r);\n\n    return r;\n}\n\n/*! Creates Sensor and LightNode based on sub-device description.\n\n    The purpose of this function is to hide Sensor and LightNode classes from Device code.\n\n    \\returns Resource pointer of the related node.\n */\nResource *DEV_InitCompatNodeFromDescription(Device *device, const DeviceDescription &ddf, const DeviceDescription::SubDevice &sub, const QString &uniqueId)\n{\n    if (sub.restApi == QLatin1String(\"/sensors\"))\n    {\n        return DEV_InitSensorNodeFromDescription(device, ddf, sub, uniqueId);\n    }\n    else if (sub.restApi == QLatin1String(\"/lights\"))\n    {\n        return DEV_InitLightNodeFromDescription(device, sub, uniqueId);\n    }\n\n    return nullptr;\n}\n"
        },
        {
          "name": "device_compat.h",
          "type": "blob",
          "size": 0.544921875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_COMPAT_H\n#define DEVICE_COMPAT_H\n\n#include \"device_descriptions.h\"\n\nclass Device;\n\nResource *DEV_InitCompatNodeFromDescription(Device *device, const DeviceDescription &ddf, const DeviceDescription::SubDevice &sub, const QString &uniqueId);\n\n#endif // DEVICE_COMPAT_H\n"
        },
        {
          "name": "device_ddf_bundle.cpp",
          "type": "blob",
          "size": 4.6728515625,
          "content": "#include \"deconz/u_assert.h\"\n#include \"device_ddf_bundle.h\"\n\nint DDFB_FindChunk(U_BStream *bs, const char *tag, unsigned *size)\n{\n    char fourcc[4];\n    unsigned sz;\n    unsigned long origPos = bs->pos;\n\n    for (;bs->pos < bs->size && bs->status == U_BSTREAM_OK;)\n    {\n        fourcc[0] = U_bstream_get_u8(bs);\n        fourcc[1] = U_bstream_get_u8(bs);\n        fourcc[2] = U_bstream_get_u8(bs);\n        fourcc[3] = U_bstream_get_u8(bs);\n        sz = U_bstream_get_u32_le(bs);\n\n        if (bs->pos + sz > bs->size)\n        {\n            break; // invalid size\n        }\n\n        if (fourcc[0] == tag[0] && fourcc[1] == tag[1] && fourcc[2] == tag[2] && fourcc[3] == tag[3])\n        {\n            *size = sz;\n            return 1;\n        }\n\n        bs->pos += sz;\n    }\n\n    bs->pos = origPos;\n    *size = 0;\n    return 0;\n}\n\nint DDFB_IsChunk(U_BStream *bs, const char *tag)\n{\n    unsigned char *fourcc;\n    if (bs->pos + 4 < bs->size)\n    {\n        fourcc = &bs->data[bs->pos];\n        return fourcc[0] == tag[0] && fourcc[1] == tag[1] && fourcc[2] == tag[2] && fourcc[3] == tag[3];\n    }\n\n    return 0;\n}\n\nint DDFB_SkipChunk(U_BStream *bs)\n{\n    char fourcc[4];\n    unsigned sz;\n\n    fourcc[0] = U_bstream_get_u8(bs);\n    fourcc[1] = U_bstream_get_u8(bs);\n    fourcc[2] = U_bstream_get_u8(bs);\n    fourcc[3] = U_bstream_get_u8(bs);\n    sz = U_bstream_get_u32_le(bs);\n\n    if (bs->status == U_BSTREAM_OK)\n    {\n        if (bs->pos + sz <= bs->size)\n        {\n            bs->pos += sz;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n    https://github.com/deconz-community/ddf-tools/blob/main/packages/bundler/README.md\n*/\nint IsValidDDFBundle(U_BStream *bs, unsigned char sha256[U_SHA256_HASH_SIZE])\n{\n    unsigned chunkSize;\n\n    if (DDFB_FindChunk(bs, \"RIFF\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    if (DDFB_FindChunk(bs, \"DDFB\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    {\n        // Bundle hash over DDFB chunk (header + data)\n        if (U_Sha256(&bs->data[bs->pos - 8], chunkSize + 8, sha256) == 0)\n        {\n            return 0; // this\n        }\n    }\n\n    U_BStream bsDDFB;\n    U_bstream_init(&bsDDFB, &bs->data[bs->pos], chunkSize);\n\n    // check DESC JSON has required fields\n    if (DDFB_FindChunk(&bsDDFB, \"DESC\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    // DBG_Printf(DBG_INFO, \"DESC: %.*s\\n\", chunkSize, &bsDDFB.data[bsDDFB.pos]);\n\n    return 1;\n}\n\nbool DDFB_SanitizeBundleHashString(char *str, unsigned len)\n{\n    if (len != 64)\n        return false;\n\n    for (unsigned i = 0; i < len; i++)\n    {\n        char ch = str[i];\n\n        if      (ch >= '0' && ch <= '9') { } // ok\n        else if (ch >= 'a' && ch <= 'f') { } // ok\n        else if (ch >= 'A' && ch <= 'F') { str[i] = ch + ('a' - 'A'); } // convert to lower case\n        else\n        {\n            return false; // invalid hex char\n        }\n    }\n\n    return true;\n}\n\nint DDFB_ReadExtfChunk(U_BStream *bs, DDFB_ExtfChunk *extf)\n{\n    U_BStream bs1;\n    char fourcc[4];\n    unsigned chunkSize;\n    unsigned long origPos = bs->pos;\n\n    extf->emptyString = '\\0';\n\n    fourcc[0] = U_bstream_get_u8(bs);\n    fourcc[1] = U_bstream_get_u8(bs);\n    fourcc[2] = U_bstream_get_u8(bs);\n    fourcc[3] = U_bstream_get_u8(bs);\n    chunkSize = U_bstream_get_u32_le(bs);\n\n    if (bs->status != U_BSTREAM_OK)\n    {\n        return 0;\n    }\n\n    if (bs->size < bs->pos + chunkSize)\n    {\n        return 0;\n    }\n\n    U_ASSERT(fourcc[0] == 'E');\n    U_ASSERT(fourcc[1] == 'X');\n    U_ASSERT(fourcc[2] == 'T');\n    U_ASSERT(fourcc[3] == 'F');\n\n    U_bstream_init(&bs1, &bs->data[bs->pos], chunkSize);\n    bs->pos += chunkSize; // move bs behind chunk\n\n    extf->fileType[0] = (char)U_bstream_get_u8(&bs1);\n    extf->fileType[1] = (char)U_bstream_get_u8(&bs1);\n    extf->fileType[2] = (char)U_bstream_get_u8(&bs1);\n    extf->fileType[3] = (char)U_bstream_get_u8(&bs1);\n    extf->fileType[4] = '\\0';\n\n    // file path string\n    extf->pathLength = U_bstream_get_u16_le(&bs1);\n    if (bs1.size < bs1.pos + extf->pathLength)\n    {\n        return 0;\n    }\n    extf->path = (const char*)&bs1.data[bs1.pos];\n    bs1.pos += extf->pathLength;\n\n    // modification time string\n    extf->modificationTimeLength = U_bstream_get_u16_le(&bs1);\n    if (bs1.size < bs1.pos + extf->modificationTimeLength)\n    {\n        return 0;\n    }\n    if (extf->modificationTimeLength == 0) // optional\n    {\n        extf->modificationTime = &extf->emptyString;\n    }\n    else\n    {\n        extf->modificationTime = (const char*)&bs1.data[bs1.pos];\n    }\n\n    bs1.pos += extf->modificationTimeLength;\n\n    // file content\n    extf->fileSize = U_bstream_get_u32_le(&bs1);\n    if (bs1.size < bs1.pos + extf->fileSize)\n    {\n        return 0;\n    }\n    extf->fileData = &bs1.data[bs1.pos];\n\n    return 1;\n}\n"
        },
        {
          "name": "device_ddf_bundle.h",
          "type": "blob",
          "size": 0.818359375,
          "content": "#ifndef DEVICE_DDF_BUNDLE_H\n#define DEVICE_DDF_BUNDLE_H\n\n#include \"deconz/u_bstream.h\"\n#include \"deconz/u_sha256.h\"\n\n#define MAX_BUNDLE_SIZE (1 << 20) // 1 MB\n\nstruct DDFB_ExtfChunk\n{\n    struct DDFB_ExtfChunk *next;\n    char fileType[5]; // fourcc + '\\0'\n    char emptyString;\n    unsigned pathLength;\n    const char *path;\n    unsigned modificationTimeLength;\n    const char *modificationTime;\n    unsigned fileSize;\n    unsigned char *fileData;\n};\n\nint DDFB_FindChunk(U_BStream *bs, const char *tag, unsigned *size);\nint DDFB_IsChunk(U_BStream *bs, const char *tag);\nint DDFB_SkipChunk(U_BStream *bs);\nint DDFB_ReadExtfChunk(U_BStream *bs, DDFB_ExtfChunk *extf);\nint IsValidDDFBundle(U_BStream *bs, unsigned char sha256[U_SHA256_HASH_SIZE]);\nbool DDFB_SanitizeBundleHashString(char *str, unsigned len);\n\n\n#endif // DEVICE_DDF_BUNDLE_H\n"
        },
        {
          "name": "device_ddf_init.cpp",
          "type": "blob",
          "size": 17.7373046875,
          "content": "/*\n * Copyright (c) 2021-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"deconz/u_assert.h\"\n#include \"device.h\"\n#include \"device_compat.h\"\n#include \"device_descriptions.h\"\n#include \"device_ddf_init.h\"\n#include \"deconz/u_sstream_ex.h\"\n#include \"database.h\"\n#include \"poll_control.h\"\n#include \"utils/utils.h\"\n\nvoid DEV_AllocateGroup(const Device *device, Resource *rsub, ResourceItem *item);\n\nstatic QString uniqueIdFromTemplate(const QStringList &templ, const Device *device)\n{\n    bool ok = false;\n    quint8 endpoint = 0;\n    quint16 clusterId = 0;\n    quint64 extAddress;\n\n    extAddress = device->item(RAttrExtAddress)->toNumber();\n\n    // <mac>-<endpoint>\n    // <mac>-<endpoint>-<cluster>\n\n    /* supported templates\n\n       [\"$address.ext\", <endpoint>]\n       [\"$address.ext\", <endpoint>, <cluster>]\n    */\n\n    if (templ.size() > 1 && templ.first() == QLatin1String(\"$address.ext\"))\n    {\n        endpoint = templ.at(1).toUInt(&ok, 0);\n\n        if (ok && templ.size() > 2)\n        {\n            ok = false;\n            const QString pos2 = templ.at(2);\n            if (pos2.at(0).isDigit())\n            {\n                clusterId = pos2.toUInt(&ok, 0);\n            }\n        }\n    }\n\n    if (ok)\n    {\n        return generateUniqueId(extAddress, endpoint, clusterId);\n    }\n\n    return {};\n}\n\n/*! Creates a ResourceItem if not exist, initialized with \\p ddfItem content.\n */\nstatic ResourceItem *DEV_InitDeviceDescriptionItem(const DeviceDescription::Item &ddfItem, const std::vector<DB_ResourceItem> &dbItems, Resource *rsub)\n{\n    U_ASSERT(rsub);\n    U_ASSERT(ddfItem.isValid());\n\n    auto *item = rsub->item(ddfItem.descriptor.suffix);\n    const char *uniqueId = rsub->item(RAttrUniqueId)->toCString();\n    U_ASSERT(uniqueId);\n\n    if (item)\n    {\n        if (DBG_IsEnabled(DBG_INFO_L2))\n        {\n            DBG_Printf(DBG_DDF, \"sub-device: %s, has item: %s\\n\", uniqueId, ddfItem.descriptor.suffix);\n        }\n    }\n    else\n    {\n        if (DBG_IsEnabled(DBG_INFO_L2))\n        {\n            DBG_Printf(DBG_DDF, \"sub-device: %s, create item: %s\\n\", uniqueId, ddfItem.descriptor.suffix);\n        }\n        item = rsub->addItem(ddfItem.descriptor.type, ddfItem.descriptor.suffix);\n\n        DBG_Assert(item);\n        if (!item)\n        {\n            return nullptr;\n        }\n    }\n\n    U_ASSERT(item);\n\n    const auto dbItem = std::find_if(dbItems.cbegin(), dbItems.cend(), [&ddfItem](const auto &dbItem)\n    {\n        return ddfItem.name == dbItem.name;\n    });\n\n    if (!ddfItem.isStatic && dbItem != dbItems.cend())\n    {\n        if (item->descriptor().suffix == RAttrId && !item->toString().isEmpty())\n        {\n            // keep 'id', it might have been loaded from legacy db\n            // and will be updated in 'resource_items' table on next write\n        }\n        else if (item->lastSet().isValid() && item->toVariant() == dbItem->value)\n        {\n            // nothing to do\n        }\n        else\n        {\n            item->setValue(dbItem->value);\n            item->setTimeStamps(QDateTime::fromMSecsSinceEpoch(dbItem->timestampMs));\n        }\n        item->clearNeedStore(); // already in DB\n    }\n    else if (!ddfItem.isStatic && dbItem == dbItems.cend() && !item->lastSet().isValid())\n    {\n        // try load from legacy sensors/nodes db tables\n        auto dbLegacyItem = std::make_unique<DB_LegacyItem>();\n        dbLegacyItem->uniqueId = uniqueId;\n        dbLegacyItem->column.setString(item->descriptor().suffix);\n\n        if (rsub->prefix() == RSensors)\n        {\n            DB_LoadLegacySensorValue(dbLegacyItem.get());\n        }\n        // TODO lights needs some more investigation, might not be needed..\n//        else if (rsub->prefix() == RLights)\n//        {\n//            DB_LoadLegacyLightValue(dbLegacyItem.get());\n//        }\n\n        if (!dbLegacyItem->value.empty())\n        {\n            item->setValue(QVariant(QString(dbLegacyItem->value.c_str())));\n            item->setTimeStamps(item->lastSet().addSecs(-120)); // TODO extract from 'lastupdated'?\n        }\n    }\n\n    if (ddfItem.defaultValue.isValid())\n    {\n        if (ddfItem.isStatic || !item->lastSet().isValid())\n        {\n            item->setValue(ddfItem.defaultValue);\n            item->clearNeedStore(); // already in DB\n        }\n    }\n\n    U_ASSERT(ddfItem.handle != DeviceDescription::Item::InvalidItemHandle);\n    item->setDdfItemHandle(ddfItem.handle);\n\n    // check updates\n    item->setIsPublic(ddfItem.isPublic);\n    item->setAwake(ddfItem.awake);\n\n    if (ddfItem.refreshInterval != DeviceDescription::Item::NoRefreshInterval)\n    {\n        item->setRefreshInterval(deCONZ::TimeSeconds{ddfItem.refreshInterval});\n    }\n\n    if (item->refreshInterval().val == 0 && !ddfItem.readParameters.isNull())\n    {\n        // If a DDF doesn't specify a refresh.interval and also not the generic item\n        // default to 30 seconds to relax polling a bit.\n        // Note: ideally this should be specified in a DDF/generic item.\n        const auto m = ddfItem.readParameters.toMap();\n        if (m.value(QLatin1String(\"fn\")) != QLatin1String(\"none\"))\n        {\n            item->setRefreshInterval(deCONZ::TimeSeconds{30});\n        }\n    }\n\n    item->setParseFunction(nullptr);\n\n    return item;\n}\n\n/*! Creates and initializes sub-device Resources and ResourceItems if not already present.\n\n    This function replaces the legacy database loading and joining device initialization.\n */\nbool DEV_InitDeviceFromDescription(Device *device, const DeviceDescription &ddf)\n{\n    Q_ASSERT(device);\n    Q_ASSERT(ddf.isValid());\n\n    size_t subCount = 0;\n    auto *dd = DeviceDescriptions::instance();\n\n    if (ddf.storageLocation == deCONZ::DdfBundleLocation || ddf.storageLocation == deCONZ::DdfBundleUserLocation)\n    {\n        ResourceItem *ddfhashItem = device->item(RAttrDdfHash);\n        U_ASSERT(ddfhashItem);\n\n        char buf[72];\n        U_SStream ss;\n        U_sstream_init(&ss, buf, sizeof(buf));\n        U_sstream_put_hex(&ss, &ddf.sha256Hash[0], sizeof(ddf.sha256Hash));\n\n        for (unsigned i = 0; i < ss.pos; i++) // workaround to convert to lower case\n        {\n            if (buf[i] >= 'A' && buf[i] <= 'F')\n                buf[i] = buf[i] + ('a' - 'A');\n        }\n\n        U_ASSERT(ss.pos == 64);\n        ddfhashItem->setValue(buf, 64);\n    }\n\n    for (const auto &sub : ddf.subDevices)\n    {\n        Q_ASSERT(sub.isValid());\n\n        const auto uniqueId = uniqueIdFromTemplate(sub.uniqueId, device);\n        if (uniqueId.isEmpty())\n        {\n            DBG_Printf(DBG_DDF, \"failed to init sub-device uniqueid: %s, %s\\n\", qPrintable(sub.uniqueId.join('-')), qPrintable(sub.type));\n            return false;\n        }\n\n        Resource *rsub = DEV_GetSubDevice(device, nullptr, uniqueId);\n\n        if (!rsub)\n        {\n            rsub = DEV_InitCompatNodeFromDescription(device, ddf, sub, uniqueId);\n        }\n\n        if (!rsub)\n        {\n            DBG_Printf(DBG_DDF, \"sub-device: %s, failed to setup: %s\\n\", qPrintable(uniqueId), qPrintable(sub.type));\n            return false;\n        }\n\n        subCount++;\n\n        auto *mf = rsub->item(RAttrManufacturerName);\n        if (mf && mf->toLatin1String().size() == 0)\n        {\n            mf->setValue(dd->constantToString(device->item(RAttrManufacturerName)->toString()));\n        }\n\n        // TODO storing should be done else where, since this is init code\n        DB_StoreSubDevice(rsub->item(RAttrUniqueId)->toCString());\n        DB_StoreSubDeviceItem(rsub, rsub->item(RAttrManufacturerName));\n        DB_StoreSubDeviceItem(rsub, rsub->item(RAttrModelId));\n\n        const auto dbItems = DB_LoadSubDeviceItems(rsub->item(RAttrUniqueId)->toLatin1String());\n\n        for (const auto &ddfItem : sub.items)\n        {\n            auto *item = DEV_InitDeviceDescriptionItem(ddfItem, dbItems, rsub);\n            if (!item)\n            {\n                continue;\n            }\n            \n            if (item->descriptor().suffix == RStatePresence && item->toBool())\n            {\n                DBG_Printf(DBG_DDF, \"sub-device: %s, presence state is true, reverting to false\\n\", qPrintable(uniqueId));\n                item->setValue(false);\n                item->clearNeedStore();\n            }\n\n            if (item->descriptor().suffix == RConfigGroup)\n            {\n                DEV_AllocateGroup(device, rsub, item);\n            }\n\n            if (!ddfItem.defaultValue.isNull() && !ddfItem.writeParameters.isNull())\n            {\n                QString writeFunction;\n                const auto writeParam = ddfItem.writeParameters.toMap();\n\n                if (writeParam.contains(QLatin1String(\"fn\")))\n                {\n                    writeFunction = writeParam.value(QLatin1String(\"fn\")).toString();\n                }\n\n                if (writeFunction.isEmpty() || writeFunction.startsWith(QLatin1String(\"zcl\")))\n                {\n                    bool ok;\n\n                    QVariant value = item->toVariant();\n                    if (!value.isValid())\n                    {\n                        value = ddfItem.defaultValue;\n                    }\n\n                    StateChange stateChange(StateChange::StateWaitSync, SC_WriteZclAttribute, sub.uniqueId.at(1).toUInt());\n                    stateChange.addTargetValue(item->descriptor().suffix, value);\n                    stateChange.setChangeTimeoutMs(1000 * 60 * 60);\n\n                    if (writeParam.contains(QLatin1String(\"state.timeout\")))\n                    {\n                        int stateTimeout = writeParam.value(QLatin1String(\"state.timeout\")).toInt(&ok);\n\n                        if (ok && stateTimeout > 0)\n                        {\n                            stateChange.setStateTimeoutMs(1000 * stateTimeout);\n                        }\n                    }\n\n                    rsub->addStateChange(stateChange);\n                }\n            }\n\n            // DDF enforce sub device \"type\" (enables overwriting the type from C++ code)\n            if (item->descriptor().suffix == RAttrType)\n            {\n                const QString type = DeviceDescriptions::instance()->constantToString(sub.type);\n                if (type != item->toString() && !type.startsWith('$'))\n                {\n                    item->setValue(type);\n                }\n            }\n\n            if (item->descriptor().suffix == RConfigBattery || item->descriptor().suffix == RStateBattery)\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(item->descriptor().suffix), QString::number(item->toNumber()));\n            }\n\n            if (item->descriptor().suffix == RConfigCheckin)\n            {\n                if (PC_GetPollControlEndpoint(device->node()) > 0)\n                {\n                    auto *itemPending = rsub->item(RConfigPending);\n                    if (itemPending) // TODO long poll interval via StateChange\n                    {\n                        itemPending->setValue(itemPending->toNumber() | R_PENDING_SET_LONG_POLL_INTERVAL);\n                    }\n                }\n            }\n        }\n    }\n\n    if (ddf.sleeper >= 0)\n    {\n        device->item(RCapSleeper)->setValue(ddf.sleeper == 1);\n    }\n\n    if (ddf.supportsMgmtBind >= 0)\n    {\n        device->setSupportsMgmtBind(ddf.supportsMgmtBind == 1);\n    }\n\n    device->clearBindings();\n    for (const auto &bnd : ddf.bindings)\n    {\n        device->addBinding(bnd);\n    }\n\n    return subCount == ddf.subDevices.size();\n}\n\nbool DEV_InitBaseDescriptionForDevice(Device *device, DeviceDescription &ddf)\n{\n    ddf.status = QLatin1String(\"Draft\");\n    ddf.manufacturerNames.push_back(device->item(RAttrManufacturerName)->toString());\n    ddf.modelIds.push_back(device->item(RAttrModelId)->toString());\n\n    if (ddf.manufacturerNames.last().isEmpty() || ddf.modelIds.isEmpty() || ddf.modelIds.front().isEmpty())\n    {\n        return false;\n    }\n\n    const auto *dd = DeviceDescriptions::instance();\n\n    for (const Resource *r : device->subDevices())\n    {\n        DeviceDescription::SubDevice sub;\n\n        sub.type = dd->stringToConstant(r->item(RAttrType)->toString());\n        sub.restApi = QLatin1String(r->prefix());\n\n        if (ddf.product.isEmpty())\n        {\n            const ResourceItem *productId = r->item(RAttrProductId);\n            if (productId && !productId->toString().isEmpty())\n            {\n                ddf.product = productId->toString();\n            }\n        }\n\n        {\n            QString uniqueId = r->item(RAttrUniqueId)->toString();\n            QStringList ls = uniqueId.split('-', SKIP_EMPTY_PARTS);\n\n            // this is a bit fugly but uniqueid template must be valid\n            DBG_Assert(ls.size() > 1); // lights uniqueid\n            if (ls.size() > 1)\n            {\n                ls[0] = QLatin1String(\"$address.ext\");\n\n                ls[1] = \"0x\" + ls[1];\n                if (ls.size() > 2) // sensor uniqueid\n                {\n                    ls[2] = \"0x\" + ls[2];\n                }\n                sub.uniqueId = ls;\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        if (r->prefix() == RSensors)\n        {\n            const Sensor *sensor = dynamic_cast<const Sensor*>(r);\n            if (sensor)\n            {\n                sub.fingerPrint = sensor->fingerPrint();\n            }\n        }\n\n        for (int i = 0; i < r->itemCount(); i++)\n        {\n            const ResourceItem *item = r->itemForIndex(i);\n\n            DeviceDescription::Item ddfItem = dd->getGenericItem(item->descriptor().suffix);\n\n            if (!ddfItem.isValid())\n            {\n                // create some\n                ddfItem.name = item->descriptor().suffix;\n                ddfItem.descriptor = item->descriptor();\n            }\n\n            ddfItem.isPublic = item->isPublic();\n\n            sub.items.push_back(ddfItem);\n        }\n\n        ddf.subDevices.push_back(sub);\n    }\n\n    return true;\n}\n\n\nbool DEV_InitDeviceBasic(Device *device)\n{\n    {\n        ResourceItem *ddfPolicy = device->item(RAttrDdfPolicy);\n        U_ASSERT(ddfPolicy);\n\n        {\n            // load attr/ddf_policy and attr/ddf_hash from database if exists\n\n            std::vector<DB_ResourceItem2> dbItems2;\n\n            if (DB_LoadDeviceItems(device->deviceId(), dbItems2))\n            {\n                for (const auto &dbItem : dbItems2)\n                {\n                    U_ASSERT(dbItem.valueSize != 0);\n                    if (dbItem.valueSize == 0)\n                    {\n                        continue;\n                    }\n\n                    if (dbItem.name == RAttrDdfPolicy && ddfPolicy)\n                    {\n                        ddfPolicy->setValue(dbItem.value, (int)dbItem.valueSize);\n                        ddfPolicy->setTimeStamps(QDateTime::fromMSecsSinceEpoch(dbItem.timestampMs));\n                    }\n                    else if (dbItem.name == RAttrDdfHash)\n                    {\n                        U_ASSERT(dbItem.valueSize == 64);\n                        if (dbItem.valueSize == 64)\n                        {\n                            ResourceItem *ddfHash = device->item(RAttrDdfHash);\n                            ddfHash->setValue(dbItem.value, (int)dbItem.valueSize);\n                            ddfHash->setTimeStamps(QDateTime::fromMSecsSinceEpoch(dbItem.timestampMs));\n                        }\n                    }\n                }\n            }\n        }\n\n        // if no attr/ddf_policy is set, use the default\n        if (ddfPolicy && ddfPolicy->toLatin1String().size() == 0)\n        {\n            ddfPolicy->setValue(\"latest_prefer_stable\", -1);\n\n            // DB_ResourceItem2 dbItem;\n\n            // if (DB_ResourceItem2DbItem(ddfPolicy, &dbItem))\n            // {\n            //     if (DB_StoreDeviceItem(device->deviceId(), dbItem))\n            //     {\n\n            //     }\n            // }\n        }\n    }\n\n    const auto dbItems = DB_LoadSubDeviceItemsOfDevice(device->item(RAttrUniqueId)->toLatin1String());\n\n    size_t found = 0;\n    std::array<const char*, 2> poi = { RAttrManufacturerName, RAttrModelId };\n    for (const auto &dbItem : dbItems)\n    {\n        if (dbItem.name == RStateReachable || dbItem.name == RConfigReachable)\n        {\n            ResourceItem *reachable = device->item(RStateReachable);\n            DBG_Assert(reachable);\n            if (reachable)\n            {\n                reachable->setValue(dbItem.value.toBool());\n                reachable->setTimeStamps(QDateTime::fromMSecsSinceEpoch(dbItem.timestampMs));\n            }\n            continue;\n        }\n\n        for (const char *suffix: poi)\n        {\n            if (dbItem.name != suffix)\n            {\n                continue;\n            }\n\n            auto *item = device->item(suffix);\n\n            if (item)\n            {\n                item->setValue(dbItem.value);\n                item->setTimeStamps(QDateTime::fromMSecsSinceEpoch(dbItem.timestampMs));\n                found++;\n            }\n\n            break;\n        }\n    }\n\n    DB_ZclValue zclVal;\n    zclVal.deviceId = device->deviceId();\n    zclVal.endpoint = 0;\n    zclVal.clusterId = 0x0019; // OTA cluster\n    zclVal.attrId = 0x0002; // OTA current file version\n    zclVal.data = 0;\n\n    if (DB_LoadZclValue(&zclVal) && zclVal.data != 0)\n    {\n        ResourceItem *item = device->item(RAttrOtaVersion);\n        if (item && item->toNumber() != zclVal.data)\n        {\n            item->setValue(zclVal.data, ResourceItem::SourceDevice);\n            item->clearNeedPush();\n        }\n    }\n\n    zclVal.clusterId = 0x0500; // IAS Zone cluster\n    zclVal.attrId = 0x0001; // IAS Zone Type\n    zclVal.data = 0;\n\n    if (DB_LoadZclValue(&zclVal) && zclVal.data != 0)\n    {\n        ResourceItem *item = device->addItem(DataTypeUInt16, RAttrZoneType);\n        if (item && item->toNumber() != zclVal.data)\n        {\n            item->setValue(zclVal.data, ResourceItem::SourceDevice);\n            item->clearNeedPush();\n        }\n    }\n\n    return found == poi.size();\n}\n"
        },
        {
          "name": "device_ddf_init.h",
          "type": "blob",
          "size": 0.5869140625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_DDF_INIT_H\n#define DEVICE_DDF_INIT_H\n\nclass Device;\nclass DeviceDescription;\n\nbool DEV_InitDeviceBasic(Device *device);\nbool DEV_InitDeviceFromDescription(Device *device, const DeviceDescription &ddf);\nbool DEV_InitBaseDescriptionForDevice(Device *device, DeviceDescription &ddf);\n\n#endif // DEVICE_DDF_INIT_H\n"
        },
        {
          "name": "device_descriptions.cpp",
          "type": "blob",
          "size": 133.3505859375,
          "content": "/*\n * Copyright (c) 2022-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <array>\n#include <QDirIterator>\n#include <QFile>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QJsonValue>\n#include <QSettings>\n#include <QTimer>\n#include <deconz/atom_table.h>\n#include <deconz/dbg_trace.h>\n#include <deconz/file.h>\n#include <deconz/u_assert.h>\n#include <deconz/u_sstream_ex.h>\n#include <deconz/buffer_pool.h>\n#include <deconz/u_memory.h>\n#include <deconz/u_time.h>\n#include <deconz/u_ecc.h>\n#include \"database.h\"\n#include \"device_ddf_bundle.h\"\n#include \"device_ddf_init.h\"\n#include \"device_descriptions.h\"\n#include \"device_js/device_js.h\"\n#include \"utils/scratchmem.h\"\n#include \"json.h\"\n#include \"event.h\"\n#include \"resource.h\"\n\n#define DDF_MAX_PATH_LENGTH 1024\n#define DDF_MAX_PUBLIC_KEYS 64\n\n#define HND_MIN_LOAD_COUNTER 1\n#define HND_MAX_LOAD_COUNTER 15\n#define HND_MAX_DESCRIPTIONS 16383\n#define HND_MAX_ITEMS        1023\n#define HND_MAX_SUB_DEVS     15\n\n/*! \\union ItemHandlePack\n\n    Packs location to an DDF item into a opaque 32-bit unsigned int handle.\n    The DDF item lookup complexity is O(1) via DDF_GetItem() function.\n */\nunion ItemHandlePack\n{\n    // 32-bit memory layout\n    // llll dddd dddd dddd ddss ssii iiii iiii\n    struct {\n        //! Max: 15, check for valid handle, for each DDF reload the counter is incremented (wraps to 0).\n        unsigned int loadCounter : 4;\n        unsigned int description : 14; //! Max: 16383, index into descriptions[].\n        unsigned int subDevice: 4;     //! Max: 15, index into description -> subdevices[]\n        unsigned int item : 10;        //! Max: 1023, index into subdevice -> items[]\n    };\n    uint32_t handle;\n};\n\nstatic unsigned atDDFPolicyLatestPreferStable;\nstatic unsigned atDDFPolicyLatest;\nstatic unsigned atDDFPolicyPin;\nstatic unsigned atDDFPolicyRawJson;\n\nstatic DeviceDescriptions *_instance = nullptr;\nstatic DeviceDescriptionsPrivate *_priv = nullptr;\n\nclass DDF_ParseContext\n{\npublic:\n    deCONZ::StorageLocation fileLocation;\n    char filePath[DDF_MAX_PATH_LENGTH];\n    unsigned filePathLength = 0;\n    uint8_t *fileData = nullptr;\n    unsigned fileDataSize = 0;\n    std::array<cj_token, 8192> tokens;\n    DDFB_ExtfChunk *extChunks;\n    int64_t bundleLastModified;\n    uint64_t signatures; // bitmap as index in publicKeys[] array\n\n    uint32_t scratchPos = 0;\n    std::array<unsigned char, 1 << 20> scratchMem; // 1.05 MB\n\n    // stats\n    int n_rawDDF = 0;\n    int n_devIdentifiers = 0;\n};\n\nstruct ConstantEntry\n{\n    AT_AtomIndex key;\n    AT_AtomIndex value;\n};\n\n\n/*\n * Lookup which DDFs already have been queried.\n *\n */\nenum DDF_LoadState\n{\n    DDF_LoadStateScheduled,\n    DDF_LoadStateLoaded\n};\n\nenum DDF_ReloadWhat\n{\n    DDF_ReloadIdle,\n    DDF_ReloadBundles,\n    DDF_ReloadAll\n};\n\nstruct DDF_LoadRecord\n{\n    AT_AtomIndex modelid;\n    AT_AtomIndex mfname;\n    uint32_t mfnameLowerCaseHash;\n    DDF_LoadState loadState;\n};\n\nclass DeviceDescriptionsPrivate\n{\npublic:\n    uint loadCounter = HND_MIN_LOAD_COUNTER;\n\n    std::vector<ConstantEntry> constants2;\n    std::vector<DeviceDescription::Item> genericItems;\n    std::vector<DeviceDescription> descriptions;\n\n    DeviceDescription invalidDescription;\n    DeviceDescription::Item invalidItem;\n    DeviceDescription::SubDevice invalidSubDevice;\n\n    QStringList enabledStatusFilter;\n\n    std::vector<DDF_SubDeviceDescriptor> subDevices;\n\n    std::vector<DDF_FunctionDescriptor> readFunctions;\n    std::vector<DDF_FunctionDescriptor> writeFunctions;\n    std::vector<DDF_FunctionDescriptor> parseFunctions;\n\n    std::vector<DDF_LoadRecord> ddfLoadRecords;\n    std::vector<U_ECC_PublicKeySecp256k1> publicKeys;\n\n    DDF_ReloadWhat ddfReloadWhat = DDF_ReloadIdle;\n    QTimer *ddfReloadTimer = nullptr;\n};\n\nstatic int DDF_ReadFileInMemory(DDF_ParseContext *pctx);\nstatic int DDF_ReadConstantsJson(DDF_ParseContext *pctx, std::vector<ConstantEntry> & constants);\nstatic DeviceDescription::Item DDF_ReadItemFile(DDF_ParseContext *pctx);\nstatic DeviceDescription DDF_ReadDeviceFile(DDF_ParseContext *pctx);\nstatic DDF_SubDeviceDescriptor DDF_ReadSubDeviceFile(DDF_ParseContext *pctx);\nstatic DeviceDescription DDF_MergeGenericItems(const std::vector<DeviceDescription::Item> &genericItems, const DeviceDescription &ddf);\nstatic int DDF_MergeGenericBundleItems(DeviceDescription &ddf, DDF_ParseContext *pctx);\nstatic int DDF_ProcessSignatures(DDF_ParseContext *pctx, std::vector<U_ECC_PublicKeySecp256k1> &publicKeys, U_BStream *bs, uint32_t *bundleHash);\nstatic DeviceDescription::Item *DDF_GetItemMutable(const ResourceItem *item);\nstatic void DDF_UpdateItemHandlesForIndex(std::vector<DeviceDescription> &descriptions, uint loadCounter, size_t index);\nstatic void DDF_TryCompileAndFixJavascript(QString *expr, const QString &path);\nDeviceDescription DDF_LoadScripts(const DeviceDescription &ddf);\n\n/*\n * https://maskray.me/blog/2023-04-12-elf-hash-function\n *\n * PJW hash adapted from musl libc.\n *\n * TODO(mpi): make this a own module U_StringHash()\n */\nstatic uint32_t DDF_StringHash(const void *s0, unsigned size)\n{\n    uint32_t h;\n    const unsigned char *s;\n\n    h = 0;\n    s = (const unsigned char*)s0;\n\n    while (size--)\n    {\n        h = 16 * h + *s++;\n        h ^= h >> 24 & 0xF0;\n    }\n    return h & 0xfffffff;\n}\n\n/*! Helper to create a 32-bit string hash from an atom string.\n\n    This is mainly used to get a unique number to compare case insensitive manufacturer names.\n    For example for \"HEIMAN\", \"heiman\" and \"Heiman\" atoms this function returns the same hash.\n */\nstatic uint32_t DDF_AtomLowerCaseStringHash(AT_AtomIndex ati)\n{\n    unsigned len;\n    AT_Atom atom;\n    char str[192];\n\n    str[0] = '\\0';\n    atom = AT_GetAtomByIndex(ati);\n\n    if (atom.len == 0)\n        return 0;\n\n    if (sizeof(str) <= atom.len) // should not happen\n        return DDF_StringHash(atom.data, atom.len);\n\n    for (len = 0; len < atom.len; len++)\n    {\n        uint8_t ch = atom.data[len];\n\n        if (ch & 0x80) // non ASCII UTF-8 string, don't bother\n            return DDF_StringHash(atom.data, atom.len);\n\n        if (ch >= 'A' && ch <= 'Z')\n            ch += (unsigned char)('a' - 'A');\n\n        str[len] = (char)ch;\n    }\n\n    str[len] = '\\0';\n    return DDF_StringHash(str, len);\n}\n\n/*! Constructor. */\nDeviceDescriptions::DeviceDescriptions(QObject *parent) :\n    QObject(parent),\n    d_ptr2(new DeviceDescriptionsPrivate)\n{\n    _instance = this;\n    _priv = d_ptr2;\n\n    d_ptr2->ddfReloadTimer = new QTimer(this);\n    d_ptr2->ddfReloadTimer->setSingleShot(true);\n    connect(d_ptr2->ddfReloadTimer, &QTimer::timeout, this, &DeviceDescriptions::ddfReloadTimerFired);\n\n    {\n        // register DDF policy atoms used later on for fast comparisons\n        AT_AtomIndex ati;\n        const char *str;\n\n        str = \"latest_prefer_stable\";\n        AT_AddAtom(str, U_strlen(str), &ati);\n        atDDFPolicyLatestPreferStable = ati.index;\n\n        str = \"latest\";\n        AT_AddAtom(str, U_strlen(str), &ati);\n        atDDFPolicyLatest = ati.index;\n\n        str = \"pin\";\n        AT_AddAtom(str, U_strlen(str), &ati);\n        atDDFPolicyPin = ati.index;\n\n        str = \"raw_json\";\n        AT_AddAtom(str, U_strlen(str), &ati);\n        atDDFPolicyRawJson = ati.index;\n    }\n\n    {\n        /*\n         * Register offical public keys for beta and stable signed bundles.\n         * These are used to to select bundles according to the attr/ddf_policy\n         */\n        U_ECC_PublicKeySecp256k1 pk;\n        uint8_t stable_key[33] = {\n            0x03, 0x93, 0x2D, 0x60, 0xA3, 0x35, 0x44, 0xFD, 0xB9, 0x20, 0x2B, 0x41, 0xA7, 0x68, 0xCD, 0xD8,\n            0x70, 0x90, 0x82, 0xBD, 0xE8, 0xCD, 0x85, 0x47, 0x21, 0x68, 0xC5, 0x2A, 0xD8, 0xC3, 0xE5, 0x76, 0xF6 };\n\n        uint8_t beta_key[33] = {\n            0x02, 0xAB, 0x93, 0x42, 0x38, 0x60, 0xD3, 0x9D, 0x2C, 0xDC, 0xBC, 0xA0, 0xF9, 0x04, 0x2B, 0xD1,\n            0xA2, 0x45, 0xED, 0xB6, 0xDC, 0xC1, 0x0C, 0x4C, 0xFF, 0x1B, 0x78, 0xE9, 0xF2, 0x43, 0xF5, 0x3F, 0x1E };\n\n        U_memcpy(pk.key, stable_key, sizeof(pk.key));\n        d_ptr2->publicKeys.push_back(pk);\n\n        U_memcpy(pk.key, beta_key, sizeof(pk.key));\n        d_ptr2->publicKeys.push_back(pk);\n    }\n\n    {  // Parse function as shown in the DDF editor.\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:attr\";\n        fn.description = \"Generic function to parse ZCL attributes.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Attribute ID\";\n        param.key = \"at\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = QLatin1String(\"Item.val = Attr.val\");\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n\n    {  // Read function as shown in the DDF editor.\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:attr\";\n        fn.description = \"Generic function to read ZCL attributes.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 255;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Attribute ID\";\n        param.key = \"at\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 1;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->readFunctions.push_back(fn);\n    }\n    \n    {  // Write function as shown in the DDF editor.\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:attr\";\n        fn.description = \"Generic function to write ZCL attributes.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Attribute ID\";\n        param.key = \"at\";\n        param.description = \"As string hex value\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n        \n        param.name = \"Datatype\";\n        param.key = \"dt\";\n        param.description = \"Datatype of the data to be written.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = QLatin1String(\"Item.val;\");\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->writeFunctions.push_back(fn);\n    }\n    \n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:cmd\";\n        fn.description = \"Generic function to parse ZCL commands.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Command ID\";\n        param.key = \"cmd\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n    \n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:cmd\";\n        fn.description = \"Generic function to read ZCL commands.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 255;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Command ID\";\n        param.key = \"cmd\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n        \n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->readFunctions.push_back(fn);\n    }\n    \n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"zcl:cmd\";\n        fn.description = \"Generic function to send ZCL commands.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"255 means any endpoint, 0 means auto selected from subdevice.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Cluster ID\";\n        param.key = \"cl\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Command ID\";\n        param.key = \"cmd\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Manufacturer code\";\n        param.key = \"mf\";\n        param.description = \"As string hex value.\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->writeFunctions.push_back(fn);\n    }\n    \n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"tuya\";\n        fn.description = \"Generic function to parse Tuya data.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Datapoint\";\n        param.key = \"dpid\";\n        param.description = \"1-255 the datapoint ID.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Javascript file\";\n        param.key = \"script\";\n        param.description = \"Relative path of a Javascript .js file.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = QLatin1String(\"Item.val = Attr.val\");\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"tuya\";\n        fn.description = \"Generic function to read all Tuya datapoints. It has no parameters.\";\n        d_ptr2->readFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"tuya\";\n        fn.description = \"Generic function to write Tuya data.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Datapoint\";\n        param.key = \"dpid\";\n        param.description = \"1-255 the datapoint ID.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n        \n        param.name = \"Datatype\";\n        param.key = \"dt\";\n        param.description = \"Datatype of the data to be written.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = QLatin1String(\"Item.val;\");\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->writeFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"ias:zonestatus\";\n        fn.description = \"Generic function to parse IAS ZONE status change notifications or zone status from read/report command.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"IAS Zone status mask\";\n        param.key = \"mask\";\n        param.description = \"Sets the bitmask for Alert1 and Alert2 item of the IAS Zone status.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = QLatin1String(\"alarm1,alarm2\");\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"numtostr\";\n        fn.description = \"Generic function to to convert number to string.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Source item\";\n        param.key = \"srcitem\";\n        param.description = \"The source item holding the number.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Operator\";\n        param.key = \"op\";\n        param.description = \"Comparison operator (lt | le | eq | gt | ge)\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Mapping\";\n        param.key = \"to\";\n        param.description = \"Array of (num, string) mappings\";\n        param.dataType = DataTypeString;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 1;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"time\";\n        fn.description = \"Specialized function to parse time, local and last set time from read/report commands of the time cluster and auto-sync time if needed.\";\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n\n    {\n        DDF_FunctionDescriptor fn;\n        fn.name = \"xiaomi:special\";\n        fn.description = \"Generic function to parse custom Xiaomi attributes and commands.\";\n\n        DDF_FunctionDescriptor::Parameter param;\n\n        param.name = \"Endpoint\";\n        param.key = \"ep\";\n        param.description = \"Source endpoint of the incoming command, default value 255 means any endpoint.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 255;\n        param.isOptional = 1;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Attribute ID\";\n        param.key = \"at\";\n        param.description = \"The attribute to parse, shall be 0xff01, 0xff02 or 0x00f7\";\n        param.dataType = DataTypeUInt16;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Index\";\n        param.key = \"idx\";\n        param.description = \"A 8-bit string hex value.\";\n        param.dataType = DataTypeUInt8;\n        param.defaultValue = 0;\n        param.isOptional = 0;\n        param.isHexString = 1;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        param.name = \"Expression\";\n        param.key = \"eval\";\n        param.description = \"Javascript expression to transform the raw value.\";\n        param.dataType = DataTypeString;\n        param.defaultValue = {};\n        param.isOptional = 0;\n        param.isHexString = 0;\n        param.supportsArray = 0;\n        fn.parameters.push_back(param);\n\n        d_ptr2->parseFunctions.push_back(fn);\n    }\n}\n\n/*! Query the database which mfname/modelid pairs are present.\n    Use these to load only DDFs and bundles which are in use.\n */\nvoid DeviceDescriptions::prepare()\n{\n    auto &records = _priv->ddfLoadRecords;\n    const auto res = DB_LoadIdentifierPairs();\n\n    for (size_t i = 0; i < res.size(); i++)\n    {\n        size_t j = 0;\n        for (j = 0; j < records.size(); j++)\n        {\n            if (records[j].mfname.index == res[i].mfnameAtomIndex &&\n                records[j].modelid.index == res[i].modelIdAtomIndex)\n            {\n                break;\n            }\n        }\n\n        if (j == records.size())\n        {\n            DDF_LoadRecord rec;\n            rec.mfname.index = res[i].mfnameAtomIndex;\n            rec.mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(rec.mfname);\n            rec.modelid.index = res[i].modelIdAtomIndex;\n            rec.loadState = DDF_LoadStateScheduled;\n            records.push_back(rec);\n        }\n    }\n}\n\n/*! Destructor. */\nDeviceDescriptions::~DeviceDescriptions()\n{\n    Q_ASSERT(_instance == this);\n    _instance = nullptr;\n    _priv = nullptr;\n    Q_ASSERT(d_ptr2);\n    delete d_ptr2;\n    d_ptr2 = nullptr;\n}\n\nvoid DeviceDescriptions::setEnabledStatusFilter(const QStringList &filter)\n{\n    if (d_ptr2->enabledStatusFilter != filter)\n    {\n        d_ptr2->enabledStatusFilter = filter;\n        DBG_Printf(DBG_INFO, \"DDF enabled for %s status\\n\", qPrintable(filter.join(QLatin1String(\", \"))));\n    }\n}\n\nconst QStringList &DeviceDescriptions::enabledStatusFilter() const\n{\n    return d_ptr2->enabledStatusFilter;\n}\n\n/*! Returns the DeviceDescriptions singleton instance.\n */\nDeviceDescriptions *DeviceDescriptions::instance()\n{\n    Q_ASSERT(_instance);\n    return _instance;\n}\n\nbool DDF_IsStatusEnabled(const QString &status)\n{\n    if (_priv)\n    {\n        return _priv->enabledStatusFilter.contains(status, Qt::CaseInsensitive);\n    }\n    return false;\n}\n\n/*! Helper to transform hard C++ coded parse functions to DDF.\n */\nvoid DDF_AnnoteZclParse1(int line, const char *file, const Resource *resource, ResourceItem *item, quint8 ep, quint16 clusterId, quint16 attributeId, const char *eval)\n{\n    DBG_Assert(resource);\n    DBG_Assert(item);\n    DBG_Assert(eval);\n\n    if (!_instance || !resource || !item || !eval)\n    {\n        return;\n    }\n\n    if (item->ddfItemHandle() == DeviceDescription::Item::InvalidItemHandle)\n    {\n        const Device *device = nullptr;\n        if (resource->parentResource())\n        {\n            device = static_cast<const Device*>(resource->parentResource());\n        }\n\n        if (!device)\n        {\n            return;\n        }\n\n        const auto *uniqueId = resource->item(RAttrUniqueId);\n        if (!uniqueId)\n        {\n            return;\n        }\n\n        auto &ddf = _instance->get(device);\n        if (!ddf.isValid())\n        {\n            return;\n        }\n\n        // this is pretty heavy but will be removed later\n        const QStringList u = uniqueId->toString().split(QLatin1Char('-'), SKIP_EMPTY_PARTS);\n\n        for (const auto &sub : ddf.subDevices)\n        {\n            if (u.size() != sub.uniqueId.size())\n            {\n                continue;\n            }\n\n            bool ok = true;\n            for (int i = 1; i < qMin(u.size(), sub.uniqueId.size()); i++)\n            {\n                if (u[i].toUInt(0, 16) != sub.uniqueId[i].toUInt(0, 16))\n                {\n                    ok = false;\n                }\n            }\n\n            if (!ok)\n            {\n                continue;\n            }\n\n            for (const auto &ddfItem : sub.items)\n            {\n                if (ddfItem.name == item->descriptor().suffix)\n                {\n                    item->setDdfItemHandle(ddfItem.handle);\n                    break;\n                }\n            }\n\n            break;\n        }\n    }\n\n    if (item->ddfItemHandle() != DeviceDescription::Item::InvalidItemHandle)\n    {\n        DeviceDescription::Item *ddfItem = DDF_GetItemMutable(item);\n\n        if (ddfItem && ddfItem->isValid())\n        {\n            if (ddfItem->parseParameters.isNull())\n            {\n                char buf[255];\n\n                QVariantMap param;\n                param[QLatin1String(\"ep\")] = int(ep);\n                snprintf(buf, sizeof(buf), \"0x%04X\", clusterId);\n                param[QLatin1String(\"cl\")] = QLatin1String(buf);\n                snprintf(buf, sizeof(buf), \"0x%04X\", attributeId);\n                param[QLatin1String(\"at\")] = QLatin1String(buf);\n                param[QLatin1String(\"eval\")] = QLatin1String(eval);\n\n                size_t fileLen = strlen(file);\n                const char *fileName = file + fileLen;\n\n                for (size_t i = fileLen; i > 0; i--, fileName--)\n                {\n                    if (*fileName == '/')\n                    {\n                        fileName++;\n                        break;\n                    }\n                }\n\n                snprintf(buf, sizeof(buf), \"%s:%d\", fileName, line);\n                param[QLatin1String(\"cppsrc\")] = QLatin1String(buf);\n\n                ddfItem->parseParameters = param;\n\n                DBG_Printf(DBG_DDF, \"DDF %s:%d: %s updated ZCL function cl: 0x%04X, at: 0x%04X, eval: %s\\n\", fileName, line, qPrintable(resource->item(RAttrUniqueId)->toString()), clusterId, attributeId, eval);\n            }\n        }\n    }\n}\n\nvoid DeviceDescriptions::handleEvent(const Event &event)\n{\n    if (event.what() == REventDDFInitRequest)\n    {\n        handleDDFInitRequest(event);\n    }\n    else if (event.what() == REventDDFReload)\n    {\n        if (event.num() == 0)\n        {\n        }\n    }\n}\n\n/*! Get the DDF object for a \\p resource.\n    \\returns The DDF object, DeviceDescription::isValid() to check for success.\n */\nconst DeviceDescription &DeviceDescriptions::get(const Resource *resource, DDF_MatchControl match)\n{\n    U_ASSERT(resource);\n\n    Q_D(const DeviceDescriptions);\n\n    const ResourceItem *modelidItem = resource->item(RAttrModelId);\n    const ResourceItem *mfnameItem = resource->item(RAttrManufacturerName);\n    const ResourceItem *typeItem = resource->item(RAttrType);\n\n    /*\n     * Collect all matching DDFs.\n     * The result is than sorted and according to the attr/ddf_policy the best candidate\n     * will be selected.\n     */\n    unsigned matchedCount = 0;\n    static std::array<int, 16> matchedIndices;\n\n    U_ASSERT(modelidItem);\n    U_ASSERT(mfnameItem);\n\n    if (typeItem)\n    {\n        const char *type = typeItem->toCString();\n        if (type[0] == 'Z' && type[1] == 'G')\n        {\n            return d->invalidDescription; // TODO(mpi): For now ZGP devices aren't supported in DDF\n        }\n\n        if (type[0] == 'C' && type[1] == 'o' && type[2] == 'n')\n        {\n            return d->invalidDescription; // filter \"Configuration tool\" aka the coordinator\n        }\n    }\n\n    unsigned modelidAtomIndex = modelidItem->atomIndex();\n    unsigned mfnameAtomIndex = mfnameItem->atomIndex();\n\n    if (modelidAtomIndex == 0 || mfnameAtomIndex == 0)\n    {\n        return d->invalidDescription; // happens when called from legacy init code addLightNode() etc.\n    }\n\n    U_ASSERT(modelidAtomIndex != 0);\n    U_ASSERT(mfnameAtomIndex != 0);\n\n    uint32_t mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(AT_AtomIndex{mfnameAtomIndex});\n\n    /*\n     * Filter matching DDFs, there can be multiple entries for the same modelid and manufacturer name.\n     * Further sorting for the 'best' match according to attr/ddf_policy is done afterwards.\n     */\n    {\n        auto i = d->descriptions.begin();\n\n        for (;matchedCount < matchedIndices.size();)\n        {\n            i = std::find_if(i, d->descriptions.end(), [modelidAtomIndex, mfnameAtomIndex, mfnameLowerCaseHash](const DeviceDescription &ddf)\n            {\n                if (ddf.mfnameAtomIndices.size() != ddf.modelidAtomIndices.size())\n                {\n                    return false; // should not happen\n                }\n\n                for (size_t j = 0; j < ddf.modelidAtomIndices.size(); j++)\n                {\n                    if (ddf.modelidAtomIndices[j] == modelidAtomIndex)\n                    {\n                        if (ddf.mfnameAtomIndices[j] == mfnameAtomIndex) // exact manufacturer name match\n                            return true;\n\n                        // tolower() manufacturer name match\n                        uint32_t mfnameLowerCaseHash2 = DDF_AtomLowerCaseStringHash(AT_AtomIndex{ddf.mfnameAtomIndices[j]});\n                        if (mfnameLowerCaseHash == mfnameLowerCaseHash2)\n                            return true;\n                    }\n                }\n\n                return false;\n            });\n\n            if (i == d->descriptions.end())\n            {\n                // nothing found, try to load further DDFs\n                if (loadDDFAndBundlesFromDisc(resource))\n                {\n                    i = d->descriptions.begin();\n                    continue; // found DDFs or bundles, try again\n                }\n                break;\n            }\n\n            if (!i->matchExpr.isEmpty() && match == DDF_EvalMatchExpr)\n            {\n                DeviceJs *djs = DeviceJs::instance();\n                djs->reset();\n                djs->setResource(resource->parentResource() ? resource->parentResource() : resource);\n                if (djs->evaluate(i->matchExpr) == JsEvalResult::Ok)\n                {\n                    const auto res = djs->result();\n                    DBG_Printf(DBG_DDF, \"matchexpr: %s --> %s\\n\", qPrintable(i->matchExpr), qPrintable(res.toString()));\n                    if (res.toBool()) // needs to evaluate to true\n                    {\n                        matchedIndices[matchedCount] = i->handle;\n                        matchedCount++;\n                    }\n                }\n                else\n                {\n                    DBG_Printf(DBG_DDF, \"failed to evaluate matchexpr for %s: %s, err: %s\\n\", qPrintable(resource->item(RAttrUniqueId)->toString()), qPrintable(i->matchExpr), qPrintable(djs->errorString()));\n                }\n            }\n            else\n            {\n                matchedIndices[matchedCount] = i->handle;\n                matchedCount++;\n            }\n\n            i++; // proceed search\n        }\n    }\n\n    if (matchedCount != 0)\n    {\n        /*\n         * Now split the matches up in categories sorted by latest timestamp.\n         */\n        unsigned invalidIndex = 0xFFFFFFFF;\n        unsigned rawJsonIndex = invalidIndex;\n        unsigned latestStableBundleIndex = invalidIndex;\n        unsigned latestBetaBundleIndex = invalidIndex;\n        unsigned latestUserBundleIndex = invalidIndex;\n\n        for (size_t i = 0; i < matchedCount; i++)\n        {\n            const DeviceDescription &ddf1 = d->descriptions[matchedIndices[i]];\n\n            if (ddf1.storageLocation == deCONZ::DdfLocation || ddf1.storageLocation == deCONZ::DdfUserLocation)\n            {\n                if (rawJsonIndex == invalidIndex)\n                {\n                    rawJsonIndex = matchedIndices[i];\n                }\n                else if (d->descriptions[rawJsonIndex].status == QLatin1String(\"Draft\"))\n                {\n                    rawJsonIndex = matchedIndices[i];\n                }\n                else if (ddf1.storageLocation == deCONZ::DdfUserLocation && d->descriptions[rawJsonIndex].storageLocation == deCONZ::DdfLocation)\n                {\n                    // already had a match but user location has more precedence than system location\n                    rawJsonIndex = matchedIndices[i];\n                }\n                continue;\n            }\n\n            if (ddf1.storageLocation == deCONZ::DdfBundleUserLocation || ddf1.storageLocation == deCONZ::DdfBundleLocation)\n            {\n                if (ddf1.signedBy & 1) // has stable signature\n                {\n                    if (latestStableBundleIndex == invalidIndex)\n                    {\n                        latestStableBundleIndex = matchedIndices[i];\n                    }\n                    else\n                    {\n                        const DeviceDescription &ddf0 = d->descriptions[latestStableBundleIndex];\n                        if (ddf0.lastModified < ddf1.lastModified)\n                        {\n                            latestStableBundleIndex = matchedIndices[i]; // newer\n                        }\n                    }\n                }\n\n                if (ddf1.signedBy & 2) // has beta signature\n                {\n                    if (latestBetaBundleIndex == invalidIndex)\n                    {\n                        latestBetaBundleIndex = matchedIndices[i];\n                    }\n                    else\n                    {\n                        const DeviceDescription &ddf0 = d->descriptions[latestBetaBundleIndex];\n                        if (ddf0.lastModified < ddf1.lastModified)\n                        {\n                            latestBetaBundleIndex = matchedIndices[i]; // newer\n                        }\n                    }\n                }\n\n                if ((ddf1.signedBy & 3) == 0) // has neither beta or stable signature\n                {\n                    if (latestUserBundleIndex == invalidIndex)\n                    {\n                        latestUserBundleIndex = matchedIndices[i];\n                    }\n                    else\n                    {\n                        const DeviceDescription &ddf0 = d->descriptions[latestUserBundleIndex];\n                        if (ddf0.lastModified < ddf1.lastModified)\n                        {\n                            latestUserBundleIndex = matchedIndices[i]; // newer\n                        }\n                    }\n                }\n            }\n        }\n\n        unsigned policy = atDDFPolicyLatestPreferStable; // default\n\n        {\n            const Resource *rParent = resource->parentResource() ? resource->parentResource() : resource;\n            const ResourceItem *ddfPolicyItem = rParent->item(RAttrDdfPolicy);\n\n            if (ddfPolicyItem)\n            {\n                policy = ddfPolicyItem->atomIndex();\n            }\n        }\n\n        if (policy == atDDFPolicyRawJson && rawJsonIndex != invalidIndex)\n        {\n            return d->descriptions[rawJsonIndex];\n        }\n\n        if (policy == atDDFPolicyLatestPreferStable)\n        {\n            if (latestStableBundleIndex != invalidIndex)\n                return d->descriptions[latestStableBundleIndex];\n        }\n\n        if (policy == atDDFPolicyLatest || policy == atDDFPolicyLatestPreferStable)\n        {\n            unsigned bundleCount = 0;\n            std::array<unsigned, 3> bundleIndices;\n\n            if (latestStableBundleIndex != invalidIndex)\n                bundleIndices[bundleCount++] = latestStableBundleIndex;\n\n            if (latestBetaBundleIndex != invalidIndex)\n                bundleIndices[bundleCount++] = latestBetaBundleIndex;\n\n            if (latestUserBundleIndex != invalidIndex)\n                bundleIndices[bundleCount++] = latestUserBundleIndex;\n\n            if (bundleCount != 0)\n            {\n                unsigned bestMatch = bundleIndices[0];\n                for (unsigned i = 1; i < bundleCount; i++)\n                {\n                    const DeviceDescription &ddf0 = d->descriptions[bestMatch];\n                    const DeviceDescription &ddf1 = d->descriptions[i];\n\n                    if (ddf0.lastModified < ddf1.lastModified)\n                        bestMatch = i;\n                }\n\n                return d->descriptions[bestMatch];\n            }\n        }\n\n        if (policy == atDDFPolicyPin)\n        {\n            /*\n             * Lookup a matching bundle by its hash. This is finicky but ensures no bugus is matched.\n             */\n            const Resource *rParent = resource->parentResource() ? resource->parentResource() : resource;\n            const ResourceItem *ddfHashItem = rParent->item(RAttrDdfHash);\n\n            if (ddfHashItem)\n            {\n                unsigned len = U_strlen(ddfHashItem->toCString());\n                if (len == 64)\n                {\n                    uint32_t hash[8] = {0};\n\n                    { // convert bundle hash string to binary\n                        U_SStream ss;\n                        uint8_t *byte = reinterpret_cast<uint8_t*>(&hash[0]);\n\n                        U_sstream_init(&ss, (void*)ddfHashItem->toCString(), len);\n\n                        for (int i = 0; i < 32; i++)\n                            byte[i] = U_sstream_get_hex_byte(&ss);\n                    }\n\n                    // The hash must belong to one of the earlier matched bundles.\n                    for (unsigned i = 0; i < matchedCount; i++)\n                    {\n                        const DeviceDescription &ddf = d->descriptions[matchedIndices[i]];\n\n                        int j = 0;\n                        for (; j < 8; j++)\n                        {\n                            if (ddf.sha256Hash[j] != hash[j])\n                                break;\n                        }\n\n                        if (j == 8) // match\n                            return ddf;\n                    }\n                }\n            }\n        }\n\n        /*\n         * Fallback: If none of above matches pick your poison.\n         */\n\n        if (latestStableBundleIndex != invalidIndex)\n            return d->descriptions[latestStableBundleIndex];\n\n        if (latestBetaBundleIndex != invalidIndex)\n            return d->descriptions[latestBetaBundleIndex];\n\n        if (latestUserBundleIndex != invalidIndex)\n            return d->descriptions[latestUserBundleIndex];\n\n        if (rawJsonIndex != invalidIndex)\n            return d->descriptions[rawJsonIndex];\n    }\n\n    return d->invalidDescription;\n}\n\nbool DeviceDescriptions::loadDDFAndBundlesFromDisc(const Resource *resource)\n{\n    Q_D(DeviceDescriptions);\n\n    const ResourceItem *modelidItem = resource->item(RAttrModelId);\n    const ResourceItem *mfnameItem = resource->item(RAttrManufacturerName);\n\n    U_ASSERT(modelidItem);\n    U_ASSERT(mfnameItem);\n\n    unsigned modelidAtomIndex = modelidItem->atomIndex();\n    unsigned mfnameAtomIndex = mfnameItem->atomIndex();\n\n    U_ASSERT(modelidAtomIndex != 0);\n    U_ASSERT(mfnameAtomIndex != 0);\n\n    if (modelidAtomIndex == 0 || mfnameAtomIndex == 0)\n    {\n        return false;\n    }\n\n    uint32_t mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(AT_AtomIndex{mfnameAtomIndex});\n\n    for (const DDF_LoadRecord &loadRecord : d->ddfLoadRecords)\n    {\n        if (loadRecord.mfnameLowerCaseHash == mfnameLowerCaseHash && loadRecord.modelid.index == modelidAtomIndex)\n        {\n            return false; // been here before\n        }\n\n        if (loadRecord.mfname.index == mfnameAtomIndex && loadRecord.modelid.index == modelidAtomIndex)\n        {\n            return false; // been here before, note this check can likely be removed due the lower case check already been hit\n        }\n    }\n\n    DBG_Printf(DBG_DDF, \"try load DDF from disc for %s -- %s\\n\", mfnameItem->toCString(), modelidItem->toCString());\n\n    // mark for loading\n    DDF_LoadRecord loadRecord;\n    loadRecord.modelid.index = modelidAtomIndex;\n    loadRecord.mfname.index = mfnameAtomIndex;\n    loadRecord.mfnameLowerCaseHash = mfnameLowerCaseHash;\n    loadRecord.loadState = DDF_LoadStateScheduled;\n    d->ddfLoadRecords.push_back(loadRecord);\n\n    unsigned countBefore = d->descriptions.size();\n    readAll();\n\n    return countBefore < d->descriptions.size();\n}\n\nconst DeviceDescription &DeviceDescriptions::getFromHandle(DeviceDescription::Item::Handle hnd) const\n{\n    Q_D(const DeviceDescriptions);\n    ItemHandlePack h;\n    h.handle = hnd;\n    if (h.handle != DeviceDescription::Item::InvalidItemHandle)\n    {\n        if (h.description < d->descriptions.size())\n        {\n            return d->descriptions[h.description];\n        }\n    }\n\n    return d->invalidDescription;\n}\n\nvoid DeviceDescriptions::put(const DeviceDescription &ddf)\n{\n    if (!ddf.isValid())\n    {\n        return;\n    }\n\n    Q_D(DeviceDescriptions);\n\n    if (ddf.handle >= 0 && ddf.handle <= int(d->descriptions.size()))\n    {\n        DeviceDescription &ddf0 = d->descriptions[ddf.handle];\n\n        DBG_Assert(ddf0.handle == ddf.handle);\n        if (ddf.handle == ddf0.handle)\n        {\n            DBG_Printf(DBG_DDF, \"update ddf %s index %d\\n\", qPrintable(ddf0.modelIds.front()), ddf.handle);\n            ddf0 = ddf;\n            DDF_UpdateItemHandlesForIndex(d->descriptions, d->loadCounter, static_cast<size_t>(ddf.handle));\n            return;\n        }\n    }\n}\n\nconst DeviceDescription &DeviceDescriptions::load(const QString &path)\n{\n    Q_UNUSED(path)\n\n    // TODO(mpi) implement\n\n    Q_D(DeviceDescriptions);\n\n#if 0\n\n    auto i = std::find_if(d->descriptions.begin(), d->descriptions.end(), [&path](const auto &ddf){ return ddf.path == path; });\n    if (i != d->descriptions.end())\n    {\n        return *i;\n    }\n\n    auto result = DDF_ReadDeviceFile(path);\n\n    if (!result.empty())\n    {\n        for (auto &ddf : result)\n        {\n            ddf = DDF_MergeGenericItems(d->genericItems, ddf);\n            ddf = DDF_LoadScripts(ddf);\n\n            i = std::find_if(d->descriptions.begin(), d->descriptions.end(), [&ddf](const DeviceDescription &b)\n            {\n                return ddf.modelIds == b.modelIds && ddf.manufacturerNames == b.manufacturerNames;\n            });\n\n            if (i != d->descriptions.end())\n            {\n                *i = ddf; // update\n            }\n            else\n            {\n                d->descriptions.push_back(ddf);\n            }\n        }\n\n        DDF_UpdateItemHandles(d->descriptions, d->loadCounter);\n\n        i = std::find_if(d->descriptions.begin(), d->descriptions.end(), [&path](const auto &ddf){ return ddf.path == path; });\n        if (i != d->descriptions.end())\n        {\n            return *i;\n        }\n    }\n\n#endif\n\n    return d->invalidDescription;\n}\n\n/*! Returns the DDF sub device belonging to a resource. */\nconst DeviceDescription::SubDevice &DeviceDescriptions::getSubDevice(const Resource *resource) const\n{\n    Q_D(const DeviceDescriptions);\n\n    if (resource)\n    {\n        ItemHandlePack h;\n        for (int i = 0; i < resource->itemCount(); i++)\n        {\n            const ResourceItem *item = resource->itemForIndex(size_t(i));\n            U_ASSERT(item);\n\n            h.handle = item->ddfItemHandle();\n            if (h.handle == DeviceDescription::Item::InvalidItemHandle)\n            {\n                continue;\n            }\n\n            if (h.loadCounter != d->loadCounter)\n            {\n                return d->invalidSubDevice;\n            }\n\n            DBG_Assert(h.description < d->descriptions.size());\n            if (h.description >= d->descriptions.size())\n            {\n                return d->invalidSubDevice;\n            }\n\n            auto &ddf = d->descriptions[h.description];\n\n            DBG_Assert(h.subDevice < ddf.subDevices.size());\n            if (h.subDevice >= ddf.subDevices.size())\n            {\n                return d->invalidSubDevice;\n            }\n\n            return ddf.subDevices[h.subDevice];\n        }\n    }\n\n    return d->invalidSubDevice;\n}\n\n/*! Turns a string constant into it's value.\n    \\returns The constant value on success, or the constant itself on error.\n */\nQString DeviceDescriptions::constantToString(const QString &constant) const\n{\n    Q_D(const DeviceDescriptions);\n\n    if (constant.startsWith('$'))\n    {\n        char buf[128];\n        AT_AtomIndex key;\n\n        int len;\n        for (len = 0; len < constant.size() && len < 127; len++)\n        {\n            buf[len] = constant.at(len).toLatin1();\n        }\n        buf[len] = '\\0';\n\n        if (AT_GetAtomIndex(buf, (unsigned)len, &key))\n        {\n            for (size_t i = 0; i < d->constants2.size(); i++)\n            {\n                if (d->constants2[i].key.index == key.index)\n                {\n                    AT_Atom a = AT_GetAtomByIndex(d->constants2[i].value);\n                    if (a.len)\n                    {\n                        return QString::fromUtf8((const char*)a.data, a.len);\n                    }\n                }\n            }\n        }\n    }\n\n    return constant;\n}\n\nQString DeviceDescriptions::stringToConstant(const QString &str) const\n{\n    Q_D(const DeviceDescriptions);\n\n    if (str.startsWith('$'))\n    {\n        return str;\n    }\n\n    char buf[128];\n    AT_AtomIndex val;\n\n    int len;\n    for (len = 0; len < str.size() && len < 127; len++)\n    {\n        buf[len] = str.at(len).toLatin1();\n    }\n    buf[len] = '\\0';\n\n    if (len)\n    {\n        if (AT_GetAtomIndex(buf, (unsigned)len, &val))\n        {\n            for (size_t i = 0; i < d->constants2.size(); i++)\n            {\n                if (d->constants2[i].value.index == val.index)\n                {\n                    AT_Atom a = AT_GetAtomByIndex(d->constants2[i].key);\n                    if (a.len)\n                    {\n                        return QString::fromUtf8((const char*)a.data, a.len);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return str;\n}\n\nstatic DeviceDescription::Item *DDF_GetItemMutable(const ResourceItem *item)\n{\n    if (!_priv || !item)\n    {\n        return nullptr;\n    }\n\n    DeviceDescriptionsPrivate *d = _priv;\n\n    ItemHandlePack h;\n    h.handle = item->ddfItemHandle(); // unpack\n\n    if (h.handle == DeviceDescription::Item::InvalidItemHandle)\n    {\n        return nullptr;\n    }\n\n    if (h.loadCounter != d->loadCounter)\n    {\n        return nullptr;\n    }\n\n    DBG_Assert(h.description < d->descriptions.size());\n    if (h.description >= d->descriptions.size())\n    {\n        return nullptr;\n    }\n\n    auto &ddf = d->descriptions[h.description];\n\n    DBG_Assert(h.subDevice < ddf.subDevices.size());\n    if (h.subDevice >= ddf.subDevices.size())\n    {\n        return nullptr;\n    }\n\n    auto &sub = ddf.subDevices[h.subDevice];\n\n    DBG_Assert(h.item < sub.items.size());\n\n    if (h.item < sub.items.size())\n    {\n        return &sub.items[h.item];\n    }\n\n    return nullptr;\n}\n\n/*! Retrieves the DDF item for the given \\p item.\n\n    If \\p item has a valid DDF item handle the respective entry is returned.\n    Otherwise the generic item list is searched based on the item.suffix.\n\n    The returned entry can be check with DeviceDescription::Item::isValid().\n */\nconst DeviceDescription::Item &DDF_GetItem(const ResourceItem *item)\n{\n    Q_ASSERT(_instance);\n    return _instance->getItem(item);\n}\n\n/*! \\see DDF_GetItem() description.\n */\nconst DeviceDescription::Item &DeviceDescriptions::getItem(const ResourceItem *item) const\n{\n    Q_D(const DeviceDescriptions);\n\n    ItemHandlePack h;\n    h.handle = item->ddfItemHandle(); // unpack\n\n    if (h.handle == DeviceDescription::Item::InvalidItemHandle)\n    {\n        return getGenericItem(item->descriptor().suffix);\n    }\n\n    if (h.loadCounter != d->loadCounter)\n    {\n        return d->invalidItem;\n    }\n\n    // Note: There are no further if conditions since at this point it's certain that a handle must be valid.\n\n    Q_ASSERT(h.description < d->descriptions.size());\n\n    const auto &ddf = d->descriptions[h.description];\n\n    Q_ASSERT(h.subDevice < ddf.subDevices.size());\n\n    const auto &sub = ddf.subDevices[h.subDevice];\n\n    Q_ASSERT(h.item < sub.items.size());\n\n    return sub.items[h.item];\n}\n\nconst DDF_Items &DeviceDescriptions::genericItems() const\n{\n    return d_ptr2->genericItems;\n}\n\nconst DeviceDescription::Item &DeviceDescriptions::getGenericItem(const char *suffix) const\n{\n    Q_D(const DeviceDescriptions);\n\n    for (const auto &item : d->genericItems)\n    {\n        if (item.name == QLatin1String(suffix))\n        {\n            return item;\n        }\n    }\n\n    return d->invalidItem;\n}\n\nconst std::vector<DDF_FunctionDescriptor> &DeviceDescriptions::getParseFunctions() const\n{\n    return d_ptr2->parseFunctions;\n}\n\nconst std::vector<DDF_FunctionDescriptor> &DeviceDescriptions::getReadFunctions() const\n{\n    return d_ptr2->readFunctions;\n}\n\nconst std::vector<DDF_FunctionDescriptor> &DeviceDescriptions::getWriteFunctions() const\n{\n    return d_ptr2->writeFunctions;\n}\n\nconst std::vector<DDF_SubDeviceDescriptor> &DeviceDescriptions::getSubDevices() const\n{\n    return d_ptr2->subDevices;\n}\n\nstatic void DDF_UpdateItemHandlesForIndex(std::vector<DeviceDescription> &descriptions, uint loadCounter, size_t index)\n{\n    U_ASSERT(index < descriptions.size());\n    if (descriptions.size() <= index)\n    {\n        return; // should not happen\n    }\n\n    U_ASSERT(index < HND_MAX_DESCRIPTIONS);\n    U_ASSERT(loadCounter >= HND_MIN_LOAD_COUNTER);\n    U_ASSERT(loadCounter <= HND_MAX_LOAD_COUNTER);\n\n    ItemHandlePack handle;\n    DeviceDescription &ddf = descriptions[index];\n\n    ddf.handle = static_cast<int>(index);\n\n    handle.description = static_cast<unsigned>(index);\n    handle.loadCounter = loadCounter;\n    handle.subDevice = 0;\n\n    for (DeviceDescription::SubDevice &sub : ddf.subDevices)\n    {\n        handle.item = 0;\n\n        for (DeviceDescription::Item &item : sub.items)\n        {\n            item.handle = handle.handle;\n            U_ASSERT(handle.item < HND_MAX_ITEMS);\n            handle.item++;\n        }\n\n        U_ASSERT(handle.subDevice < HND_MAX_SUB_DEVS);\n        handle.subDevice++;\n    }\n}\n\n/*! Temporary workaround since DuktapeJS doesn't support 'let', try replace it with 'var'.\n\n    The fix only applies if the JS doesn't compile and after the modified version successfully\n    compiles. Can be removed onces all DDFs have been updated.\n\n    Following cases are fixed:\n\n    '^let '   // let at begin of the expression\n    ' let '\n    '\\nlet '\n    '\\tlet '\n    '(let '   // let within a scope like: for (let i=0; i < 3; i++) {...}\n*/\nstatic void DDF_TryCompileAndFixJavascript(QString *expr, const QString &path)\n{\n#ifdef USE_DUKTAPE_JS_ENGINE\n    if (DeviceJs::instance()->testCompile(*expr) == JsEvalResult::Ok)\n    {\n        return;\n    }\n\n    int idx = 0;\n    int nfixes = 0;\n    QString fix = *expr;\n    const QString letSearch(\"let\");\n\n    for ( ; idx != -1; )\n    {\n        idx = fix.indexOf(letSearch, idx);\n        if (idx < 0)\n        {\n            break;\n        }\n\n        if (idx == 0 || fix.at(idx - 1).isSpace() || fix.at(idx - 1) == '(')\n        {\n            fix[idx + 0] = 'v';\n            fix[idx + 1] = 'a';\n            fix[idx + 2] = 'r';\n            idx += 4;\n            nfixes++;\n        }\n    }\n\n    if (nfixes > 0 && DeviceJs::instance()->testCompile(fix) == JsEvalResult::Ok)\n    {\n        *expr = fix;\n        return;\n    }\n\n    // if we get here, the expressions has other problems, print compile error and path\n    DBG_Printf(DBG_DDF, \"DDF failed to compile JS: %s\\n%s\\n\", qPrintable(path), qPrintable(DeviceJs::instance()->errorString()));\n\n#else\n    Q_UNUSED(expr)\n    Q_UNUSED(path)\n#endif\n}\n\nenum JSON_Schema\n{\n    JSON_SCHEMA_UNKNOWN,\n    JSON_SCHEMA_CONSTANTS_1,\n    JSON_SCHEMA_CONSTANTS_2,\n    JSON_SCHEMA_RESOURCE_ITEM_1,\n    JSON_SCHEMA_SUB_DEVICE_1,\n    JSON_SCHEMA_DEV_CAP_1\n};\n\n/*! Returns the JSON schema of a file.\n\n    The function doesn't actually parse the full JSON document\n    but instead just extracts the \"schema\": \"<SCHEMA>\" content.\n*/\nJSON_Schema DDF_GetJsonSchema(uint8_t *data, unsigned dataSize)\n{\n    U_SStream ss[1];\n    unsigned beg = 0;\n    unsigned end = 0;\n    unsigned len;\n\n    U_ASSERT(data);\n    U_ASSERT(dataSize > 0);\n\n    if (*data != '{' && *data != '[') // not JSON object or array\n    {\n        return JSON_SCHEMA_UNKNOWN;\n    }\n\n    U_sstream_init(ss, data, dataSize);\n\n    if (U_sstream_find(ss, \"\\\"schema\\\"\"))\n    {\n        U_sstream_seek(ss, ss[0].pos + 8);\n\n        if (U_sstream_find(ss, \"\\\"\"))\n        {\n            U_sstream_seek(ss, ss[0].pos + 1);\n            beg = ss[0].pos;\n\n            if (U_sstream_find(ss, \"\\\"\"))\n            {\n                end = ss[0].pos;\n            }\n        }\n    }\n\n    if (beg < end)\n    {\n        len = end - beg;\n        U_sstream_init(ss, &data[beg], len);\n\n        if (len == 19 && U_sstream_starts_with(ss, \"devcap1.schema.json\"))\n        {\n            return JSON_SCHEMA_DEV_CAP_1;\n        }\n        else if (len == 25 && U_sstream_starts_with(ss, \"resourceitem1.schema.json\"))\n        {\n            return JSON_SCHEMA_RESOURCE_ITEM_1;\n        }\n        else if (len == 22 && U_sstream_starts_with(ss, \"constants1.schema.json\"))\n        {\n            return JSON_SCHEMA_CONSTANTS_1;\n        }\n        else if (len == 22 && U_sstream_starts_with(ss, \"constants2.schema.json\"))\n        {\n            return JSON_SCHEMA_CONSTANTS_2;\n        }\n        else if (len == 22 && U_sstream_starts_with(ss, \"subdevice1.schema.json\"))\n        {\n            return JSON_SCHEMA_SUB_DEVICE_1;\n        }\n    }\n\n    return JSON_SCHEMA_UNKNOWN;\n}\n\n/*! Reads all DDF related files.\n */\nvoid DeviceDescriptions::readAll()\n{\n    readAllRawJson();\n    readAllBundles();\n}\n\n/*! Reads all scheduled raw JSON DDF files.\n */\nvoid DeviceDescriptions::readAllRawJson()\n{\n    Q_D(DeviceDescriptions);\n\n    d->loadCounter = (d->loadCounter + 1) % HND_MAX_LOAD_COUNTER;\n    if (d->loadCounter <= HND_MIN_LOAD_COUNTER)\n    {\n        d->loadCounter = HND_MIN_LOAD_COUNTER;\n    }\n\n    ScratchMemWaypoint swp;\n    uint8_t *ctx_mem = SCRATCH_ALLOC(uint8_t*, sizeof(DDF_ParseContext) + 64);\n    U_ASSERT(ctx_mem);\n    if (!ctx_mem)\n    {\n        DBG_Printf(DBG_ERROR, \"DDF not enough memory to create DDF_ParseContext\\n\");\n        return;\n    }\n\n    DBG_Printf(DBG_DDF, \"DDF try to find raw JSON DDFs for %u identifier pairs\\n\", (unsigned)d->ddfLoadRecords.size());\n\n    DDF_ParseContext *pctx = new(ctx_mem)DDF_ParseContext; // placement new into scratch memory, no further cleanup needed\n    U_ASSERT(pctx);\n    pctx->extChunks = nullptr;\n\n    DBG_MEASURE_START(DDF_ReadRawJson);\n\n    std::vector<DDF_SubDeviceDescriptor> subDevices;\n\n    std::array<deCONZ::StorageLocation, 2> locations = { deCONZ::DdfLocation, deCONZ::DdfUserLocation};\n\n    bool hasConstants = false;\n\n    // need to resolve constants first\n    for (size_t dit = 0; dit < locations.size(); dit++)\n    {\n        const QString filePath = deCONZ::getStorageLocation(locations[dit]) + \"/generic/constants.json\";\n\n        pctx->filePath[0] = '\\0';\n        pctx->filePathLength = 0;\n        pctx->scratchPos = 0;\n\n        {\n            U_SStream ss;\n            U_sstream_init(&ss, pctx->filePath, sizeof(pctx->filePath));\n            U_sstream_put_str(&ss, filePath.toUtf8().data());\n            pctx->filePathLength = ss.pos;\n        }\n\n        if (DDF_ReadFileInMemory(pctx))\n        {\n            if (DDF_ReadConstantsJson(pctx, d->constants2))\n            {\n                DBG_Printf(DBG_DDF, \"DDF loaded %d string constants from %s\\n\", (int)d->constants2.size(), pctx->filePath);\n                hasConstants = true;\n            }\n        }\n    }\n\n    if (d->constants2.empty() || !hasConstants) // should not happen\n    {\n        DBG_Printf(DBG_DDF, \"DDF failed to load string constants\\n\");\n    }\n\n    U_ASSERT(hasConstants);\n\n    for (size_t dit = 0; dit < locations.size(); dit++)\n    {\n        const QString dirpath = deCONZ::getStorageLocation(locations[dit]);\n        QDirIterator it(dirpath, QDirIterator::Subdirectories | QDirIterator::FollowSymlinks);\n\n        while (it.hasNext())\n        {\n            it.next();\n\n            pctx->filePath[0] = '\\0';\n            pctx->filePathLength = 0;\n            pctx->scratchPos = 0;\n            QString filePath = it.filePath();\n            {\n                U_SStream ss;\n                U_sstream_init(&ss, pctx->filePath, sizeof(pctx->filePath));\n                U_sstream_put_str(&ss, filePath.toUtf8().data());\n                pctx->filePathLength = ss.pos;\n            }\n\n            if (it.filePath().endsWith(QLatin1String(\"generic/constants.json\")))\n            {\n            }\n            else if (it.fileName() == QLatin1String(\"button_maps.json\"))\n            {  }\n            else if (it.fileName().endsWith(QLatin1String(\".json\")))\n            {\n                if (it.filePath().contains(QLatin1String(\"generic/items/\")))\n                {\n                    if (DDF_ReadFileInMemory(pctx))\n                    {\n                        DeviceDescription::Item result = DDF_ReadItemFile(pctx);\n                        if (result.isValid())\n                        {\n                            result.isGenericRead = !result.readParameters.isNull() ? 1 : 0;\n                            result.isGenericWrite = !result.writeParameters.isNull() ? 1 : 0;\n                            result.isGenericParse = !result.parseParameters.isNull() ? 1 : 0;\n\n                            size_t j = 0;\n                            for (j = 0; j < d->genericItems.size(); j++)\n                            {\n                                DeviceDescription::Item  &genItem = d->genericItems[j];\n                                if (genItem.name == result.name)\n                                {\n                                    // replace\n                                    genItem = result;\n                                    break;\n                                }\n                            }\n\n                            if (j == d->genericItems.size())\n                            {\n                                d->genericItems.push_back(result);\n                            }\n                        }\n                    }\n                }\n                else if (it.filePath().contains(QLatin1String(\"generic/subdevices/\")))\n                {\n                    if (DDF_ReadFileInMemory(pctx))\n                    {\n                        DDF_SubDeviceDescriptor result = DDF_ReadSubDeviceFile(pctx);\n                        if (isValid(result))\n                        {\n                            subDevices.push_back(result);\n                        }\n                    }\n                }\n                else\n                {\n                    if (DDF_ReadFileInMemory(pctx))\n                    {\n                        DeviceDescription result = DDF_ReadDeviceFile(pctx);\n                        if (result.isValid())\n                        {\n                            result.storageLocation = locations[dit];\n                            if (U_Sha256(pctx->fileData, pctx->fileDataSize, (unsigned char*)&result.sha256Hash[0]) == 0)\n                            {\n                                DBG_Printf(DBG_DDF, \"DDF failed to create SHA-256 hash of DDF\\n\");\n                            }\n\n                            unsigned j = 0;\n                            unsigned k = 0;\n                            bool found = false;\n\n                            /*\n                             * Check if this DDF is already loaded.\n                             */\n                            for (j = 0; j < d->descriptions.size(); j++)\n                            {\n                                const DeviceDescription &ddf = d->descriptions[j];\n\n                                for (k = 0; k < 8; k++)\n                                {\n                                    if (ddf.sha256Hash[k] != result.sha256Hash[k])\n                                    {\n                                        break;\n                                    }\n                                }\n\n                                if (k == 8)\n                                {\n                                    found = true;\n                                    break;\n                                }\n                            }\n\n                            if (!found)\n                            {\n                                /*\n                                 * Further check if the DDF is scheduled for loading.\n                                 * That is when an actual possibly matching device exists in the setup.\n                                 */\n                                bool scheduled = false;\n                                if (result.manufacturerNames.size() == result.modelIds.size())\n                                {\n                                    for (j = 0; j < result.manufacturerNames.size(); j++)\n                                    {\n                                        AT_AtomIndex mfnameIndex;\n                                        AT_AtomIndex modelidIndex;\n                                        uint32_t mfnameLowerCaseHash = 0;\n\n                                        mfnameIndex.index = 0;\n                                        modelidIndex.index = 0;\n\n                                        /*\n                                         * Try to get atoms for the mfname/modelid pair.\n                                         * Note: If they don't exist, this isn't the pair we are looking for!\n                                         * We don't add atoms for all strings found in DDFs to safe memory.\n                                         */\n\n                                        {\n                                            const QByteArray m = constantToString(result.manufacturerNames[j]).toUtf8();\n                                            if (AT_GetAtomIndex(m.constData(), (unsigned)m.size(), &mfnameIndex) != 1)\n                                            {\n                                                if (m.startsWith('$'))\n                                                {\n                                                    DBG_Printf(DBG_DDF, \"DDF failed to resolve constant %s\\n\", m.data());\n                                                    // continue here anyway as long as modelid matches\n                                                }\n                                                else\n                                                {\n                                                    continue;\n                                                }\n                                            }\n                                            else\n                                            {\n                                                mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(mfnameIndex);\n                                            }\n                                        }\n\n                                        {\n                                            const QByteArray m = constantToString(result.modelIds[j]).toUtf8();\n                                            if (AT_GetAtomIndex(m.constData(), (unsigned)m.size(), &modelidIndex) != 1)\n                                            {\n                                                continue;\n                                            }\n                                        }\n\n                                        for (k = 0; k < d->ddfLoadRecords.size(); k++)\n                                        {\n                                            if (modelidIndex.index == d->ddfLoadRecords[k].modelid.index)\n                                            {\n                                                if (mfnameLowerCaseHash == 0)\n                                                {\n                                                    // ignore for now, in worst case we load a DDF to memory which isn't used\n                                                    U_ASSERT(0);\n                                                }\n                                                else if (mfnameLowerCaseHash != d->ddfLoadRecords[k].mfnameLowerCaseHash)\n                                                {\n                                                    continue;\n                                                }\n                                                scheduled = true;\n                                                break;\n                                            }\n                                        }\n\n                                        if (scheduled)\n                                        {\n                                            break;\n                                        }\n                                    }\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_DDF, \"DDF ignore %s due unequal manufacturername/modelid array sizes\\n\", pctx->filePath);\n                                }\n\n                                if (scheduled)\n                                {\n                                    /*\n                                     * The DDF is of interest, now register all atoms for faster lookups.\n                                     */\n                                    for (const auto &mfname : result.manufacturerNames)\n                                    {\n                                        const QString m = DeviceDescriptions::instance()->constantToString(mfname);\n\n                                        AT_AtomIndex ati;\n                                        if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                                        {\n                                            result.mfnameAtomIndices.push_back(ati.index);\n                                        }\n                                    }\n\n                                    for (const auto &modelId : result.modelIds)\n                                    {\n                                        const QString m = DeviceDescriptions::instance()->constantToString(modelId);\n\n                                        AT_AtomIndex ati;\n                                        if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                                        {\n                                            result.modelidAtomIndices.push_back(ati.index);\n                                        }\n                                    }\n\n                                    DBG_Printf(DBG_DDF, \"DDF cache raw JSON DDF %s\\n\", pctx->filePath);\n                                    d->descriptions.push_back(std::move(result));\n                                    DDF_UpdateItemHandlesForIndex(d->descriptions, d->loadCounter, d->descriptions.size() - 1);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (!subDevices.empty())\n    {\n        std::sort(subDevices.begin(), subDevices.end(), [](const auto &a, const auto &b){\n            return a.name < b.name;\n        });\n\n        d->subDevices = std::move(subDevices);\n    }\n\n    if (!d->descriptions.empty())\n    {\n        for (auto &ddf : d->descriptions)\n        {\n            ddf = DDF_MergeGenericItems(d->genericItems, ddf);\n            ddf = DDF_LoadScripts(ddf);\n        }\n\n        DBG_Printf(DBG_DDF, \"DDF loaded %d raw JSON DDFs\\n\", (int)d->descriptions.size());\n    }\n\n    DBG_MEASURE_END(DDF_ReadRawJson);\n}\n\n#if 0\n    {\n        U_ECC_PrivateKeySecp256k1 privkey = {0};\n        U_ECC_PublicKeySecp256k1 pubkey = {0};\n        U_ECC_SignatureSecp256k1 sig = {0};\n        unsigned char hash[U_SHA256_HASH_SIZE] = {0};\n\n        if (U_ECC_CreateKeyPairSecp256k1(&privkey, &pubkey) == 1)\n        {\n            DBG_Printf(DBG_INFO, \"created keypair\\n\");\n\n            U_Sha256(&privkey, sizeof(privkey), hash); // just to have some hash\n\n            if (U_ECC_SignSecp256K1(&privkey, hash, sizeof(hash), &sig))\n            {\n                DBG_Printf(DBG_INFO, \"created signature\\n\");\n\n                if (U_ECC_VerifySignatureSecp256k1(&pubkey, &sig, hash, sizeof(hash)))\n                {\n                    DBG_Printf(DBG_INFO, \"verified signature\\n\");\n                }\n\n                sig.sig[6] = sig.sig[6] + 9; // invalidate\n                if (U_ECC_VerifySignatureSecp256k1(&pubkey, &sig, hash, sizeof(hash)) == 0)\n                {\n                    DBG_Printf(DBG_INFO, \"invalid signature [OK]\\n\");\n                }\n            }\n        }\n    }\n\n    {\n        U_HmacSha256Test();\n    }\n#endif\n\n/*! Trigger REventDDFReload for all present devices which match with device identifier pair of DDF bundle.\n */\nstatic int DDF_ReloadBundleDevices(const char *desc, unsigned descSize, std::vector<DDF_LoadRecord> &ddfLoadRecords)\n{\n    cj_ctx cj[1];\n    char buf[96];\n    cj_token_ref ref;\n    cj_token_ref parent_ref;\n    cj_token_ref deviceids_ref;\n    AT_AtomIndex modelid_ati;\n    AT_AtomIndex mfname_ati;\n    cj_token *tokens;\n    unsigned n_tokens = 1024;\n    int n_marked = 0;\n\n    ScratchMemWaypoint swp;\n    tokens = SCRATCH_ALLOC(cj_token*, n_tokens * sizeof(*tokens));\n    U_ASSERT(tokens);\n    if (!tokens)\n        return 0;\n\n    cj_parse_init(cj, desc, descSize, tokens, n_tokens);\n    cj_parse(cj);\n\n    if (cj->status != CJ_OK)\n        return 0;\n\n    parent_ref = 0;\n    deviceids_ref = cj_value_ref(cj, parent_ref, \"device_identifiers\");\n\n    // array of 2 string element arrays\n    // \"device_identifiers\":[[\"LUMI\",\"lumi.sensor_magnet\"]]\n\n    if (deviceids_ref == CJ_INVALID_TOKEN_INDEX)\n        return 0;\n\n    if (tokens[deviceids_ref].type != CJ_TOKEN_ARRAY_BEG)\n        return 0;\n\n    // verify flat string array, and equal size for manufacturer names and modelids\n    for (ref = deviceids_ref + 1; tokens[ref].type != CJ_TOKEN_ARRAY_END && ref < cj[0].tokens_pos; )\n    {\n        if (tokens[ref].type == CJ_TOKEN_ITEM_SEP)\n        {\n            ref++;\n            continue;\n        }\n\n        // inner array for each entry\n        if (tokens[ref].type != CJ_TOKEN_ARRAY_BEG)\n            break;\n\n        if (tokens[ref + 1].type != CJ_TOKEN_STRING) // mfname\n            break;\n\n        if (tokens[ref + 2].type != CJ_TOKEN_ITEM_SEP)\n            break;\n\n        if (tokens[ref + 3].type != CJ_TOKEN_STRING) // modelid\n            break;\n\n        if (tokens[ref + 4].type != CJ_TOKEN_ARRAY_END)\n            break;\n\n        /*\n         * Lookup if the manufacturername and modelid pair has registered atoms.\n         * If not this can't be a bundle of interest.\n         */\n        bool foundAtoms = true;\n\n        if (cj_copy_ref_utf8(cj, buf, sizeof(buf), ref + 1) == 0)\n            break; // this has to be a valid string\n\n        if (AT_GetAtomIndex(buf, U_strlen(buf), &mfname_ati) == 0)\n            foundAtoms = false; // unknown, can be ok\n\n        if (cj_copy_ref_utf8(cj, buf, sizeof(buf), ref + 3) == 0)\n            break; // this has to be a valid string\n\n        if (AT_GetAtomIndex(buf, U_strlen(buf), &modelid_ati) == 0)\n            foundAtoms = false; // unknown, can be ok\n\n        ref += 5;\n        if (!foundAtoms)\n            continue;\n\n        for (size_t j = 0; j < ddfLoadRecords.size(); j++)\n        {\n            DDF_LoadRecord &rec = ddfLoadRecords[j];\n\n            if (rec.mfname.index != mfname_ati.index)\n                continue;\n\n            if (rec.modelid.index != modelid_ati.index)\n                continue;\n\n            rec.loadState = DDF_LoadStateScheduled;\n            n_marked++;\n        }\n    }\n\n    return n_marked > 0;\n}\n\nstatic int DDF_IsBundleScheduled(DDF_ParseContext *pctx, const char *desc, unsigned descSize, const std::vector<DDF_LoadRecord> &ddfLoadRecords)\n{\n    cj_ctx cj[1];\n    char buf[96];\n    cj_token_ref ref;\n    cj_token_ref parent_ref;\n    cj_token_ref deviceids_ref;\n    cj_token_ref last_modified_ref;\n    AT_AtomIndex modelid_ati;\n    AT_AtomIndex mfname_ati;\n    cj_token *tokens = pctx->tokens.data();\n\n    cj_parse_init(cj, desc, descSize, pctx->tokens.data(), (cj_size)pctx->tokens.size());\n    cj_parse(cj);\n\n    if (cj->status != CJ_OK)\n        return 0;\n\n    parent_ref = 0;\n    deviceids_ref = cj_value_ref(cj, parent_ref, \"device_identifiers\");\n    last_modified_ref = cj_value_ref(cj, parent_ref, \"last_modified\");\n\n    // array of 2 string element arrays\n    // \"device_identifiers\":[[\"LUMI\",\"lumi.sensor_magnet\"]]\n\n    if (last_modified_ref == CJ_INVALID_TOKEN_INDEX)\n        return 0;\n\n    if (tokens[last_modified_ref].type != CJ_TOKEN_STRING)\n        return 0;\n\n    {\n        cj_token *tok = &tokens[last_modified_ref];\n        pctx->bundleLastModified = U_TimeFromISO8601(&desc[tok->pos], tok->len);\n    }\n\n    if (deviceids_ref == CJ_INVALID_TOKEN_INDEX)\n        return 0;\n\n    if (tokens[deviceids_ref].type != CJ_TOKEN_ARRAY_BEG)\n        return 0;\n\n    // verify flat string array, and equal size for manufacturer names and modelids\n    for (ref = deviceids_ref + 1; tokens[ref].type != CJ_TOKEN_ARRAY_END && ref < cj[0].tokens_pos; )\n    {\n        if (tokens[ref].type == CJ_TOKEN_ITEM_SEP)\n        {\n            ref++;\n            continue;\n        }\n\n        // inner array for each entry\n        if (tokens[ref].type != CJ_TOKEN_ARRAY_BEG)\n            break;\n\n        if (tokens[ref + 1].type != CJ_TOKEN_STRING) // mfname\n            break;\n\n        if (tokens[ref + 2].type != CJ_TOKEN_ITEM_SEP)\n            break;\n\n        if (tokens[ref + 3].type != CJ_TOKEN_STRING) // modelid\n            break;\n\n        if (tokens[ref + 4].type != CJ_TOKEN_ARRAY_END)\n            break;\n\n        /*\n         * Lookup if the manufacturername and modelid pair has registered atoms.\n         * If not this can't be a bundle of interest.\n         */\n        bool foundAtoms = true;\n\n        if (cj_copy_ref_utf8(cj, buf, sizeof(buf), ref + 1) == 0)\n            break; // this has to be a valid string\n\n        if (AT_GetAtomIndex(buf, U_strlen(buf), &mfname_ati) == 0)\n            foundAtoms = false; // unknown, can be ok\n\n        if (cj_copy_ref_utf8(cj, buf, sizeof(buf), ref + 3) == 0)\n            break; // this has to be a valid string\n\n        if (AT_GetAtomIndex(buf, U_strlen(buf), &modelid_ati) == 0)\n            foundAtoms = false; // unknown, can be ok\n\n        ref += 5;\n        if (!foundAtoms)\n            continue;\n\n        uint32_t mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(mfname_ati);\n\n        for (size_t j = 0; j < ddfLoadRecords.size(); j++)\n        {\n            const DDF_LoadRecord &rec = ddfLoadRecords[j];\n\n            if (rec.modelid.index != modelid_ati.index)\n                continue;\n\n            if (rec.mfnameLowerCaseHash != mfnameLowerCaseHash)\n                continue;\n\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nvoid DEV_DDF_BundleUpdated(unsigned char *data, unsigned dataSize)\n{\n    U_BStream bs;\n    unsigned chunkSize;\n\n    U_bstream_init(&bs, data, dataSize);\n\n    if (DDFB_FindChunk(&bs, \"RIFF\", &chunkSize) == 0)\n        return;\n\n    if (DDFB_FindChunk(&bs, \"DDFB\", &chunkSize) == 0)\n        return;\n\n    if (DDFB_FindChunk(&bs, \"DESC\", &chunkSize) == 0)\n        return;\n\n    if (DDF_ReloadBundleDevices((char*)&bs.data[bs.pos], chunkSize, _priv->ddfLoadRecords) != 0)\n    {\n        _priv->ddfReloadWhat = DDF_ReloadBundles;\n        _priv->ddfReloadTimer->stop();\n        _priv->ddfReloadTimer->start(2000);\n    }\n}\n\nvoid DeviceDescriptions::reloadAllRawJsonAndBundles(const Resource *resource)\n{\n\n    const ResourceItem *mfnameItem = resource->item(RAttrManufacturerName);\n    const ResourceItem *modelidItem = resource->item(RAttrModelId);\n    unsigned mfnameAtomIndex = mfnameItem->atomIndex();\n    unsigned modelidAtomIndex = modelidItem->atomIndex();\n    uint32_t mfnameLowerCaseHash = DDF_AtomLowerCaseStringHash(AT_AtomIndex{mfnameAtomIndex});\n\n    for (size_t j = 0; j < d_ptr2->ddfLoadRecords.size(); j++)\n    {\n        DDF_LoadRecord &rec = d_ptr2->ddfLoadRecords[j];\n\n        if (rec.mfnameLowerCaseHash != mfnameLowerCaseHash)\n            continue;\n\n        if (rec.modelid.index != modelidAtomIndex)\n            continue;\n\n        if (rec.loadState != DDF_LoadStateScheduled)\n        {\n            rec.loadState = DDF_LoadStateScheduled;\n        }\n    }\n\n    d_ptr2->ddfReloadWhat = DDF_ReloadAll;\n    d_ptr2->ddfReloadTimer->stop();\n    d_ptr2->ddfReloadTimer->start(1000);\n}\n\nvoid DeviceDescriptions::ddfReloadTimerFired()\n{\n    if (d_ptr2->ddfReloadWhat == DDF_ReloadAll)\n    {\n        readAll();\n    }\n    else if (d_ptr2->ddfReloadWhat == DDF_ReloadBundles)\n    {\n        readAllBundles();\n    }\n\n    d_ptr2->ddfReloadWhat = DDF_ReloadIdle;\n\n     for (DDF_LoadRecord &rec : d_ptr2->ddfLoadRecords)\n     {\n        // trigger DDF reload event for matching devices\n        if (rec.loadState == DDF_LoadStateScheduled)\n        {\n            rec.loadState = DDF_LoadStateLoaded;\n            DEV_ReloadDeviceIdendifier(rec.mfname.index, rec.modelid.index);\n        }\n     }\n}\n\n/*! Reads all scheduled DDF bundles.\n */\nvoid DeviceDescriptions::readAllBundles()\n{\n    Q_D(DeviceDescriptions);\n\n    ScratchMemWaypoint swp;\n    uint8_t *ctx_mem = SCRATCH_ALLOC(uint8_t*, sizeof(DDF_ParseContext) + 64);\n    U_ASSERT(ctx_mem);\n    if (!ctx_mem)\n    {\n        DBG_Printf(DBG_ERROR, \"DDF not enough memory to create DDF_ParseContext\\n\");\n        return;\n    }\n\n    DDF_ParseContext *pctx = new(ctx_mem)DDF_ParseContext; // placement new into scratch memory, no further cleanup needed\n    U_ASSERT(pctx);\n\n    DBG_MEASURE_START(DDF_ReadBundles);\n\n    FS_Dir dir;\n    FS_File fp;\n    U_SStream ss;\n    U_BStream bs;\n    unsigned chunkSize;\n    unsigned basePathLength;\n    unsigned scratchPosPerBundle;\n\n    deCONZ::StorageLocation locations[2] = { deCONZ::DdfBundleUserLocation, deCONZ::DdfBundleLocation };\n\n    for (int dit = 0; dit < 2; dit++)\n    {\n        {\n            QByteArray loc = deCONZ::getStorageLocation(locations[dit]).toUtf8();\n            U_sstream_init(&ss, pctx->filePath, sizeof(pctx->filePath));\n            U_sstream_put_str(&ss, loc.data());\n            basePathLength = ss.pos;\n        }\n\n        // during processing of a bundle additional memory might be allocated\n        // restore this point for each bundle to be processeed\n        scratchPosPerBundle = ScratchMemPos();\n\n        if (FS_OpenDir(&dir, pctx->filePath))\n        {\n            for (;FS_ReadDir(&dir);)\n            {\n                if (dir.entry.type != FS_TYPE_FILE)\n                    continue;\n\n                U_sstream_init(&ss, dir.entry.name, strlen(dir.entry.name));\n\n                if (U_sstream_find(&ss, \".ddf\") == 0 && U_sstream_find(&ss, \".ddb\") == 0)\n                    continue;\n\n                ScratchMemRewind(scratchPosPerBundle);\n\n                U_sstream_init(&ss, pctx->filePath, sizeof(pctx->filePath));\n                ss.pos = basePathLength; // reuse path and append the filename to existing base path\n                U_sstream_put_str(&ss, \"/\");\n                U_sstream_put_str(&ss, dir.entry.name);\n                pctx->filePathLength = ss.pos;\n                pctx->bundleLastModified = 0;\n                pctx->extChunks = nullptr;\n                pctx->signatures = 0;\n\n                if (DDF_ReadFileInMemory(pctx) == 0)\n                    continue;\n\n                // keep copy here since pcxt vars are adjusted to sub sections during read\n                unsigned ddfbChunkOffset;\n                unsigned ddfbChunkSize;\n                uint32_t ddfbHash[8];\n                unsigned char *fileData;\n                unsigned fileDataSize;\n\n                fileData = pctx->fileData;\n                fileDataSize = pctx->fileDataSize;\n\n                U_bstream_init(&bs, pctx->fileData, pctx->fileDataSize);\n\n                if (DDFB_FindChunk(&bs, \"RIFF\", &chunkSize) == 0)\n                    continue;\n\n                if (DDFB_FindChunk(&bs, \"DDFB\", &chunkSize) == 0)\n                    continue;\n\n                ddfbChunkOffset = bs.pos;\n                ddfbChunkSize = chunkSize;\n\n                {   // check if bundle is already loaded\n                    // bundle hash over DDFB chunk (header + data)\n                    U_Sha256(&pctx->fileData[ddfbChunkOffset - 8], ddfbChunkSize + 8, (uint8_t*)&ddfbHash[0]);\n\n                    unsigned i;\n                    unsigned k;\n\n                    for (i = 0; i < d->descriptions.size(); i++)\n                    {\n                        uint32_t *hash0 = d->descriptions[i].sha256Hash;\n\n                        for (k = 0; k < 8; k++)\n                        {\n                            if (hash0[k] != ddfbHash[k])\n                                break;\n                        }\n\n                        if (k == 8)\n                            break; // match\n                    }\n\n                    if (i < d->descriptions.size()) // skip, already known\n                        continue;\n                }\n\n                if (DDFB_FindChunk(&bs, \"DESC\", &chunkSize) == 0)\n                    continue;\n\n                /*\n                 * Only load bundles into memory for devices which are present.\n                 */\n                if (DDF_IsBundleScheduled(pctx, (char*)&bs.data[bs.pos], chunkSize, d->ddfLoadRecords) == 0)\n                    continue;\n\n                // limit to DDFB content\n                U_bstream_init(&bs, &fileData[ddfbChunkOffset], ddfbChunkSize);\n\n                // read external files first\n                for (;bs.status == U_BSTREAM_OK;)\n                {\n                    if (DDFB_IsChunk(&bs, \"EXTF\"))\n                    {\n                        DDFB_ExtfChunk *extf = SCRATCH_ALLOC(DDFB_ExtfChunk*, sizeof (*extf));\n                        if (extf && DDFB_ReadExtfChunk(&bs, extf))\n                        {\n                            // collect external chunk descriptors in a temporary list\n                            extf->next = pctx->extChunks;\n                            pctx->extChunks = extf;\n                            continue;\n                        }\n                    }\n\n                    DDFB_SkipChunk(&bs);\n                }\n\n                if (!pctx->extChunks)\n                    continue; // must not be empty\n\n                if (DDF_ReadConstantsJson(pctx, d->constants2))\n                {\n\n                }\n\n                /*\n                 * Now process the actual DDF content which is in ETXF chunk with type DDFC.\n                 */\n\n                DDFB_ExtfChunk *extfDDFC = nullptr;\n\n                for (DDFB_ExtfChunk *extf = pctx->extChunks; extf; extf = extf->next)\n                {\n                    if (extf->fileType[0] != 'D' || extf->fileType[1] != 'D' || extf->fileType[2] != 'F' || extf->fileType[3] != 'C')\n                        continue;\n\n                    JSON_Schema schema = DDF_GetJsonSchema(extf->fileData, extf->fileSize);\n\n                    if (schema == JSON_SCHEMA_DEV_CAP_1)\n                    {\n                        extfDDFC = extf;\n                        break;\n                    }\n                }\n\n                if (!extfDDFC)\n                    continue; // main DDF JSON must be present\n\n                // tmp swap where data points\n                pctx->fileData = extfDDFC->fileData;\n                pctx->fileDataSize = extfDDFC->fileSize;\n\n                DeviceDescription ddf = DDF_ReadDeviceFile(pctx);\n                if (!ddf.isValid())\n                {\n                    continue;\n                }\n\n                // process signatures\n                U_bstream_init(&bs, &fileData[8], fileDataSize - 8); // after RIFF header\n                if (DDFB_FindChunk(&bs, \"SIGN\", &chunkSize) == 1)\n                {\n                    U_bstream_init(&bs, &bs.data[bs.pos], chunkSize);\n                    DDF_ProcessSignatures(pctx, d->publicKeys, &bs, ddfbHash);\n                }\n\n                ddf.storageLocation = locations[dit];\n                ddf.lastModified = pctx->bundleLastModified;\n                ddf.signedBy = pctx->signatures;\n\n                if (DDF_MergeGenericBundleItems(ddf, pctx) == 0)\n                {\n                    continue;\n                }\n\n                // copy bundle hash generated earlier\n                for (unsigned i = 0; i < 8; i++)\n                    ddf.sha256Hash[i] = ddfbHash[i];\n\n                {\n                    /*\n                     * The DDF is of interest, now register all atoms for faster lookups.\n                     */\n                    for (const auto &mfname : ddf.manufacturerNames)\n                    {\n                        const QString m = constantToString(mfname);\n\n                        AT_AtomIndex ati;\n                        if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                        {\n                            ddf.mfnameAtomIndices.push_back(ati.index);\n                        }\n                    }\n\n                    for (const auto &modelId : ddf.modelIds)\n                    {\n                        const QString m = constantToString(modelId);\n\n                        AT_AtomIndex ati;\n                        if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                        {\n                            ddf.modelidAtomIndices.push_back(ati.index);\n                        }\n                    }\n\n                    d->descriptions.push_back(std::move(ddf));\n                    DDF_UpdateItemHandlesForIndex(d->descriptions, d->loadCounter, d->descriptions.size() - 1);\n                }\n\n                DBG_Printf(DBG_DDF, \"DDF bundle: %s, size: %u bytes\\n\", ss.str, pctx->fileDataSize);\n            }\n\n            FS_CloseDir(&dir);\n        }\n    }\n\n    DBG_MEASURE_END(DDF_ReadBundles);\n}\n\n/*! Tries to init a Device from an DDF file.\n\n    Currently this is done syncronously later on it will be async to not block\n    the main thread while loading DDF files.\n */\nvoid DeviceDescriptions::handleDDFInitRequest(const Event &event)\n{\n    Q_D(DeviceDescriptions);\n\n    auto *resource = DEV_GetResource(RDevices, QString::number(event.deviceKey()));\n\n    int result = -1; // error\n\n    if (resource)\n    {\n        const DeviceDescription &ddf = get(resource, DDF_EvalMatchExpr);\n\n        if (ddf.isValid())\n        {\n            result = 0;\n\n            if (!DEV_TestManaged() && !DDF_IsStatusEnabled(ddf.status))\n            {\n                result = 2;\n            }\n            else if (DEV_InitDeviceFromDescription(static_cast<Device*>(resource), ddf))\n            {\n                result = 1; // ok\n\n                if (ddf.status == QLatin1String(\"Draft\"))\n                {\n                    result = 2;\n                }\n                else if (ddf.storageLocation == deCONZ::DdfBundleLocation || ddf.storageLocation == deCONZ::DdfBundleUserLocation)\n                {\n                    result = 3;\n                }\n            }\n        }\n\n        if (result >= 0)\n        {\n            DBG_Printf(DBG_INFO, \"DEV found DDF for \" FMT_MAC \", path: %s, result: %d\\n\", FMT_MAC_CAST(event.deviceKey()), qPrintable(ddf.path), result);\n        }\n\n        if (result == 0)\n        {\n            DBG_Printf(DBG_INFO, \"DEV init Device from DDF for \" FMT_MAC \" failed\\n\", FMT_MAC_CAST(event.deviceKey()));\n        }\n        else if (result == -1)\n        {\n            DBG_Printf(DBG_INFO, \"DEV no DDF for \" FMT_MAC \", modelId: %s\\n\", FMT_MAC_CAST(event.deviceKey()), resource->item(RAttrModelId)->toCString());\n            DBG_Printf(DBG_INFO, \"DEV create on-the-fly DDF for \" FMT_MAC \"\\n\", FMT_MAC_CAST(event.deviceKey()));\n\n            DeviceDescription ddf1;\n            Device *device = static_cast<Device*>(resource);\n\n            if (DEV_InitBaseDescriptionForDevice(device, ddf1))\n            {\n                /*\n                 * Register all atoms for faster lookups.\n                 */\n                for (const auto &mfname : ddf1.manufacturerNames)\n                {\n                    const QString m = constantToString(mfname);\n\n                    AT_AtomIndex ati;\n                    if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                    {\n                        ddf1.mfnameAtomIndices.push_back(ati.index);\n                    }\n                }\n\n                for (const auto &modelId : ddf1.modelIds)\n                {\n                    const QString m = constantToString(modelId);\n\n                    AT_AtomIndex ati;\n                    if (AT_AddAtom(m.toUtf8().data(), m.size(), &ati) && ati.index != 0)\n                    {\n                        ddf1.modelidAtomIndices.push_back(ati.index);\n                    }\n                }\n\n                ddf1.storageLocation = deCONZ::DdfUserLocation;\n                d->descriptions.push_back(std::move(ddf1));\n                DDF_UpdateItemHandlesForIndex(d->descriptions, d->loadCounter, d->descriptions.size() - 1);\n            }\n        }\n    }\n\n    emit eventNotify(Event(RDevices, REventDDFInitResponse, result, event.deviceKey()));\n}\n\n/*! Reads constants.json file and places them into \\p constants map.\n */\nstatic int DDF_ReadConstantsJson(DDF_ParseContext *pctx, std::vector<ConstantEntry> &constants)\n{\n    cj_ctx ctx;\n    cj_ctx *cj;\n    cj_token *tok;\n    cj_token_ref ref;\n    ConstantEntry constEntry;\n\n    const char *fileData = (const char*)pctx->fileData;\n    unsigned fileDataSize = pctx->fileDataSize;\n\n    // if this is a bundle point to data within the bundle\n    if (pctx->extChunks)\n    {\n        fileData = nullptr;\n        fileDataSize = 0;\n\n        for (DDFB_ExtfChunk *extf = pctx->extChunks; extf; extf = extf->next)\n        {\n            if (extf->fileType[0] != 'J' || extf->fileType[1] != 'S' || extf->fileType[2] != 'O' || extf->fileType[3] != 'N')\n                continue;\n\n            JSON_Schema schema = DDF_GetJsonSchema(extf->fileData, extf->fileSize);\n\n            if (schema == JSON_SCHEMA_CONSTANTS_2)\n            {\n                fileData = (const char*)extf->fileData;\n                fileDataSize = extf->fileSize;\n                break;\n            }\n        }\n    }\n\n    if (!fileData || fileDataSize == 0)\n    {\n        return 0;\n    }\n\n    auto &tokens = pctx->tokens;\n\n    cj = &ctx;\n\n    cj_parse_init(cj, fileData, fileDataSize, tokens.data(), tokens.size());\n    cj_parse(cj);\n\n    if (cj->status == CJ_OK)\n    {\n        for (ref = 0; ref < cj->tokens_pos; ref++)\n        {\n            tok = &cj->tokens[ref];\n\n            if (tok->type == CJ_TOKEN_STRING && (ref + 2) < cj->tokens_pos)\n            {\n                if (cj->buf[tok->pos] == '$' && tok[1].type == CJ_TOKEN_NAME_SEP && tok[2].type == CJ_TOKEN_STRING)\n                {\n                    if (tok[0].len < 2 || tok[2].len < 2)\n                    {\n                        // min size of strings, should perhaps be longer ...\n                    }\n                    else if (tok[0].len > AT_MAX_ATOM_SIZE || tok[2].len > AT_MAX_ATOM_SIZE)\n                    {\n\n                    }\n                    else if (AT_AddAtom(&cj->buf[tok[0].pos], tok[0].len, &constEntry.key) == 1 &&\n                             AT_AddAtom(&cj->buf[tok[2].pos], tok[2].len, &constEntry.value) == 1)\n                    {\n                        // check already known\n                        for (size_t i = 0; i < constants.size(); i++)\n                        {\n                            if (constants[i].key.index == constEntry.key.index && constants[i].value.index == constEntry.value.index)\n                            {\n                                constEntry.key.index = 0;\n                                constEntry.value.index = 0;\n                                break;\n                            }\n                        }\n\n                        // The code allows to add same keys with different values,\n                        // this might be a problem, but so is replacing a existing key.\n                        // When doing a lookup we can iterate in reverse to yield the newest key-value pair.\n                        if (constEntry.key.index != 0 && constEntry.value.index != 0)\n                        {\n                            constants.push_back(constEntry);\n                        }\n                    }\n                }\n            }\n        }\n\n        return 1;\n    }\n\n    return 0;\n}\n\nApiDataType API_DataTypeFromString(const QString &str)\n{\n    if (str == QLatin1String(\"bool\")) return DataTypeBool;\n    if (str == QLatin1String(\"uint8\")) return DataTypeUInt8;\n    if (str == QLatin1String(\"uint16\")) return DataTypeUInt16;\n    if (str == QLatin1String(\"uint32\")) return DataTypeUInt32;\n    if (str == QLatin1String(\"uint64\")) return DataTypeUInt64;\n    if (str == QLatin1String(\"int8\")) return DataTypeInt8;\n    if (str == QLatin1String(\"int16\")) return DataTypeInt16;\n    if (str == QLatin1String(\"int32\")) return DataTypeInt32;\n    if (str == QLatin1String(\"int64\")) return DataTypeInt64;\n    if (str == QLatin1String(\"string\")) return DataTypeString;\n    if (str == QLatin1String(\"double\")) return DataTypeReal;\n    if (str == QLatin1String(\"time\")) return DataTypeTime;\n    if (str == QLatin1String(\"timepattern\")) return DataTypeTimePattern;\n\n    return DataTypeUnknown;\n}\n\nstatic int DDF_ReadFileInMemory(DDF_ParseContext *pctx)\n{\n    FS_File f;\n    long remaining = (pctx->scratchPos < pctx->scratchMem.size()) ? pctx->scratchMem.size() - pctx->scratchPos : 0;\n\n    pctx->scratchPos = 0;\n    pctx->fileData = nullptr;\n    pctx->fileDataSize = 0;\n    if (FS_OpenFile(&f, FS_MODE_R, pctx->filePath))\n    {\n        long fsize = FS_GetFileSize(&f);\n\n        if (fsize + 1 > remaining)\n        {\n\n        }\n        else if (fsize > 0)\n        {\n            unsigned char *data = pctx->scratchMem.data() + pctx->scratchPos;\n            long n = FS_ReadFile(&f, data, remaining);\n            if (n == fsize)\n            {\n                FS_CloseFile(&f);\n                data[n] = '\\0';\n                pctx->scratchPos += (n + 1);\n                pctx->fileData = data;\n                pctx->fileDataSize = n;\n                return 1;\n            }\n        }\n\n        FS_CloseFile(&f);\n    }\n\n\n    return 0;\n}\n\n/*! Parses an item object.\n    \\returns A parsed item, use DeviceDescription::Item::isValid() to check for success.\n */\nstatic DeviceDescription::Item DDF_ParseItem(DDF_ParseContext *pctx, const QJsonObject &obj)\n{\n    DeviceDescription::Item result{};\n    bool hasSchema = obj.contains(QLatin1String(\"schema\"));\n\n    if (obj.contains(QLatin1String(\"name\")))\n    {\n        result.name = obj.value(QLatin1String(\"name\")).toString().toUtf8().constData();\n    }\n    else if (obj.contains(QLatin1String(\"id\"))) // generic/item TODO align name/id?\n    {\n        result.name = obj.value(QLatin1String(\"id\")).toString().toUtf8().constData();\n    }\n\n    // Handle deprecated names/ids within DDFs, but not in generic/items\n    if (!hasSchema)\n    {\n        if (result.name == RConfigColorCapabilities) { result.name = RCapColorCapabilities; }\n        if (result.name == RConfigCtMax) { result.name = RCapColorCtMax; }\n        if (result.name == RConfigCtMin) { result.name = RCapColorCtMin; }\n    }\n\n    if (obj.contains(QLatin1String(\"description\")))\n    {\n        result.description = obj.value(QLatin1String(\"description\")).toString();\n    }\n\n    if (result.name.empty())\n    {\n        return {};\n    }\n\n    // try to create a dynamic ResourceItemDescriptor\n    if (!getResourceItemDescriptor(result.name, result.descriptor))\n    {\n        QString schema;\n        if (hasSchema)\n        {\n            schema = obj.value(QLatin1String(\"schema\")).toString();\n        }\n\n        if (schema == QLatin1String(\"resourceitem1.schema.json\"))\n        {\n            QString dataType;\n            ResourceItemDescriptor rid{};\n\n            if (obj.contains(QLatin1String(\"access\")))\n            {\n                const auto access = obj.value(QLatin1String(\"access\")).toString();\n                if (access == QLatin1String(\"R\"))\n                {\n                    rid.access = ResourceItemDescriptor::Access::ReadOnly;\n                }\n                else if (access == QLatin1String(\"RW\"))\n                {\n                    rid.access = ResourceItemDescriptor::Access::ReadWrite;\n                }\n            }\n\n            if (obj.contains(QLatin1String(\"datatype\")))\n            {\n                QString dataType = obj.value(QLatin1String(\"datatype\")).toString().toLower();\n                rid.type = API_DataTypeFromString(dataType);\n                if (dataType.startsWith(\"uint\") || dataType.startsWith(\"int\"))\n                {\n                    rid.qVariantType = QVariant::Double;\n                }\n                else if (rid.type == DataTypeReal)\n                {\n                    rid.qVariantType = QVariant::Double;\n                }\n                else if (rid.type == DataTypeBool)\n                {\n                    rid.qVariantType = QVariant::Bool;\n                }\n                else\n                {\n                    DBG_Assert(rid.type == DataTypeString || rid.type == DataTypeTime || rid.type == DataTypeTimePattern);\n                    rid.qVariantType = QVariant::String;\n                }\n            }\n\n            if (obj.contains(QLatin1String(\"range\")))\n            {\n                const auto range = obj.value(QLatin1String(\"range\")).toArray();\n                if (range.count() == 2)\n                {\n                    bool ok1 = false;\n                    bool ok2 = false;\n                    double rangeMin = range.at(0).toString().toDouble(&ok1);\n                    double rangeMax = range.at(1).toString().toDouble(&ok2);\n\n                    if (ok1 && ok2)\n                    {\n                        rid.validMin = rangeMin;\n                        rid.validMax = rangeMax;\n                    }\n                    // TODO validate range according to datatype\n                }\n            }\n\n            if (rid.isValid())\n            {\n                rid.flags = ResourceItem::FlagDynamicDescriptor;\n\n                // TODO this is fugly, should later on be changed to use the atom table\n                size_t len = result.name.size();\n                char *dynSuffix  = new char[len + 1];\n                memcpy(dynSuffix, result.name.c_str(), len);\n                dynSuffix[len] = '\\0';\n                rid.suffix = dynSuffix;\n\n                // TODO ResourceItemDescriptor::flags (push, etc.)\n                if (R_AddResourceItemDescriptor(rid))\n                {\n                    DBG_Printf(DBG_DDF, \"DDF added dynamic ResourceItemDescriptor %s\\n\", result.name.c_str());\n                }\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_DDF, \"DDF unsupported ResourceItem schema: %s\\n\", qPrintable(schema));\n        }\n    }\n\n    if (getResourceItemDescriptor(result.name, result.descriptor))\n    {\n        if (obj.contains(QLatin1String(\"access\")))\n        {\n            const auto access = obj.value(QLatin1String(\"access\")).toString();\n            if (access == \"R\")\n            {\n                result.descriptor.access = ResourceItemDescriptor::Access::ReadOnly;\n            }\n            else if (access == \"RW\")\n            {\n                result.descriptor.access = ResourceItemDescriptor::Access::ReadWrite;\n            }\n        }\n\n        if (obj.contains(QLatin1String(\"public\")))\n        {\n            result.isPublic = obj.value(QLatin1String(\"public\")).toBool() ? 1 : 0;\n            result.hasIsPublic = 1;\n        }\n\n        if (obj.contains(QLatin1String(\"implicit\")))\n        {\n            result.isImplicit = obj.value(QLatin1String(\"implicit\")).toBool() ? 1 : 0;\n        }\n\n        if (obj.contains(QLatin1String(\"awake\")))\n        {\n            result.awake = obj.value(QLatin1String(\"awake\")).toBool() ? 1 : 0;\n        }\n\n        if (obj.contains(QLatin1String(\"managed\")))\n        {\n            result.isManaged = obj.value(QLatin1String(\"managed\")).toBool() ? 1 : 0;\n        }\n\n        if (obj.contains(QLatin1String(\"static\")))\n        {\n            result.isStatic = 1;\n            result.defaultValue = obj.value(QLatin1String(\"static\")).toVariant();\n        }\n        else\n        {\n            if (obj.contains(QLatin1String(\"default\")))\n            {\n                result.defaultValue = obj.value(QLatin1String(\"default\")).toVariant();\n            }\n\n            const auto parse = obj.value(QLatin1String(\"parse\"));\n            if (parse.isObject())\n            {\n                result.parseParameters = parse.toVariant();\n            }\n\n            const auto read = obj.value(QLatin1String(\"read\"));\n            if (read.isObject())\n            {\n                result.readParameters = read.toVariant();\n            }\n\n            if (obj.contains(QLatin1String(\"refresh.interval\")))\n            {\n                result.refreshInterval = obj.value(QLatin1String(\"refresh.interval\")).toInt(0);\n            }\n\n            const auto write = obj.value(QLatin1String(\"write\"));\n            if (write.isObject())\n            {\n                result.writeParameters = write.toVariant();\n            }\n        }\n\n        if (DBG_IsEnabled(DBG_INFO_L2))\n        {\n            DBG_Printf(DBG_DDF, \"DDF loaded resource item descriptor: %s, public: %u\\n\", result.descriptor.suffix, (result.isPublic ? 1 : 0));\n        }\n    }\n    else\n    {\n        DBG_Printf(DBG_DDF, \"DDF failed to load resource item descriptor: %s\\n\", result.name.c_str());\n    }\n\n    return result;\n}\n\n/*! Parses a sub device in a DDF object \"subdevices\" array.\n    \\returns The sub device object, use DeviceDescription::SubDevice::isValid() to check for success.\n */\nstatic DeviceDescription::SubDevice DDF_ParseSubDevice(DDF_ParseContext *pctx, const QJsonObject &obj)\n{\n    DeviceDescription::SubDevice result;\n\n    result.type = obj.value(QLatin1String(\"type\")).toString();\n    if (result.type.isEmpty())\n    {\n        return result;\n    }\n\n    result.restApi = obj.value(QLatin1String(\"restapi\")).toString();\n    if (result.restApi.isEmpty())\n    {\n        return result;\n    }\n\n    if (obj.contains(QLatin1String(\"meta\")))\n    {\n        auto meta = obj.value(QLatin1String(\"meta\"));\n        if (meta.isObject())\n        {\n            result.meta = meta.toVariant().toMap();\n        }\n    }\n\n    const auto uniqueId = obj.value(QLatin1String(\"uuid\"));\n    if (uniqueId.isArray())\n    {\n        const auto arr = uniqueId.toArray();\n        for (const auto &i : arr)\n        {\n            result.uniqueId.push_back(i.toString());\n        }\n    }\n\n    const auto fingerPrint = obj.value(QLatin1String(\"fingerprint\"));\n    if (fingerPrint.isObject())\n    {\n        bool ok;\n        const auto fp = fingerPrint.toObject();\n        result.fingerPrint.endpoint = fp.value(QLatin1String(\"endpoint\")).toString().toUInt(&ok, 0);\n        result.fingerPrint.profileId = ok ? fp.value(QLatin1String(\"profile\")).toString().toUInt(&ok, 0) : 0;\n        result.fingerPrint.deviceId = ok ? fp.value(QLatin1String(\"device\")).toString().toUInt(&ok, 0) : 0;\n\n        if (fp.value(QLatin1String(\"in\")).isArray())\n        {\n            const auto arr = fp.value(QLatin1String(\"in\")).toArray();\n            for (const auto &cl : arr)\n            {\n                const auto clusterId = ok ? cl.toString().toUInt(&ok, 0) : 0;\n                if (ok)\n                {\n                    result.fingerPrint.inClusters.push_back(clusterId);\n                }\n            }\n        }\n\n        if (fp.value(QLatin1String(\"out\")).isArray())\n        {\n            const auto arr = fp.value(QLatin1String(\"out\")).toArray();\n            for (const auto &cl : arr)\n            {\n                const auto clusterId = ok ? cl.toString().toUInt(&ok, 0) : 0;\n                if (ok)\n                {\n                    result.fingerPrint.outClusters.push_back(clusterId);\n                }\n            }\n        }\n\n        if (!ok)\n        {\n            result.fingerPrint = { };\n        }\n    }\n\n    const auto items = obj.value(QLatin1String(\"items\"));\n    if (!items.isArray())\n    {\n        return result;\n    }\n\n    {\n        const auto arr = items.toArray();\n        for (const auto &i : arr)\n        {\n            if (i.isObject())\n            {\n                const auto item = DDF_ParseItem(pctx, i.toObject());\n\n                if (item.isValid())\n                {\n                    result.items.push_back(item);\n                }\n                else\n                {\n\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n// {\"at\": \"0x0021\", \"dt\": \"u8\", \"min\": 5, \"max\": 3600, \"change\": 1 },\n\n/*! Parses a ZCL report in a DDF_Binding object \"report\" array.\n    \\returns The ZCL report, use DDF_ZclReport::isValid() to check for success.\n */\nstatic DDF_ZclReport DDF_ParseZclReport(const QJsonObject &obj)\n{\n    DDF_ZclReport result{};\n\n    // check required fields\n    if (!obj.contains(QLatin1String(\"at\")) ||\n        !obj.contains(QLatin1String(\"dt\")) ||\n        !obj.contains(QLatin1String(\"min\")) ||\n        !obj.contains(QLatin1String(\"max\")))\n    {\n        return {};\n    }\n\n    bool ok = false;\n    result.attributeId = obj.value(QLatin1String(\"at\")).toString().toUShort(&ok, 0);\n\n    if (!ok)\n    {\n        return {};\n    }\n\n    {\n        auto dataType = obj.value(QLatin1String(\"dt\")).toString().toUShort(&ok, 0);\n        if (!ok || dataType > 0xFF)\n        {\n            return {};\n        }\n        result.dataType = dataType;\n    }\n\n    {\n        const auto minInterval = obj.value(QLatin1String(\"min\")).toInt(-1);\n\n        if (minInterval < 0 || minInterval > UINT16_MAX)\n        {\n            return {};\n        }\n\n        result.minInterval = minInterval;\n    }\n\n    {\n        const auto maxInterval = obj.value(QLatin1String(\"max\")).toInt(-1);\n\n        if (maxInterval < 0 || maxInterval > UINT16_MAX)\n        {\n            return {};\n        }\n\n        result.maxInterval = maxInterval;\n    }\n\n    if (obj.contains(QLatin1String(\"change\")))\n    {\n        result.reportableChange = obj.value(QLatin1String(\"change\")).toString().toUInt(&ok, 0);\n\n        if (!ok)\n        {\n            return {};\n        }\n    }\n\n    if (obj.contains(QLatin1String(\"mf\")))\n    {\n        result.manufacturerCode = obj.value(QLatin1String(\"mf\")).toString().toUShort(&ok, 0);\n\n        if (!ok)\n        {\n            return {};\n        }\n    }\n\n    result.valid = true;\n\n    return result;\n}\n\n/*! Parses a binding in a DDF object \"bindings\" array.\n    \\returns The binding, use DDF_Binding::isValid() to check for success.\n */\nstatic DDF_Binding DDF_ParseBinding(const QJsonObject &obj)\n{\n    DDF_Binding result{};\n\n    // check required fields\n    if (!obj.contains(QLatin1String(\"bind\")) ||\n        !obj.contains(QLatin1String(\"src.ep\")) ||\n        !obj.contains(QLatin1String(\"cl\")))\n    {\n        return {};\n    }\n\n    const auto type = obj.value(QLatin1String(\"bind\")).toString();\n\n    if (type == QLatin1String(\"unicast\"))\n    {\n        result.isUnicastBinding = 1;\n    }\n    else if (type == QLatin1String(\"groupcast\"))\n    {\n        result.isGroupBinding = 1;\n    }\n    else\n    {\n        return {};\n    }\n\n    bool ok = false;\n    {\n        const auto srcEndpoint = obj.value(QLatin1String(\"src.ep\")).toInt(-1);\n\n        if (srcEndpoint < 0 || srcEndpoint > UINT8_MAX)\n        {\n            return {};\n        }\n        result.srcEndpoint = srcEndpoint;\n    }\n\n    {\n        result.clusterId = obj.value(QLatin1String(\"cl\")).toString().toUShort(&ok, 0);\n\n        if (!ok)\n        {\n            return {};\n        }\n    }\n\n    if (obj.contains(QLatin1String(\"dst.ep\")))\n    {\n        const auto dstEndpoint = obj.value(QLatin1String(\"dst.ep\")).toInt(-1);\n        if (dstEndpoint < 0 || dstEndpoint >= 255)\n        {\n            return {};\n        }\n        result.dstEndpoint = dstEndpoint;\n    }\n    else\n    {\n        result.dstEndpoint = 0;\n    }\n\n    if (result.isGroupBinding && obj.contains(QLatin1String(\"config.group\")))\n    {\n        const auto configGroup = obj.value(QLatin1String(\"config.group\")).toInt(-1);\n        if (configGroup < 0 || configGroup >= 255)\n        {\n            return {};\n        }\n        result.configGroup = configGroup;\n    }\n    else\n    {\n        result.configGroup = 0;\n    }\n\n    const auto report = obj.value(QLatin1String(\"report\"));\n    if (report.isArray())\n    {\n        const auto reportArr = report.toArray();\n        for (const auto &i : reportArr)\n        {\n            if (i.isObject())\n            {\n                const auto rep = DDF_ParseZclReport(i.toObject());\n                if (isValid(rep))\n                {\n                    result.reporting.push_back(rep);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Parses a single string or array of strings in DDF JSON object.\n    The obj[key] value can be a string or array of strings.\n    \\returns List of parsed strings.\n */\nstatic QStringList DDF_ParseStringOrList(const QJsonObject &obj, QLatin1String key)\n{\n    QStringList result;\n    const auto val = obj.value(key);\n\n    if (val.isString()) // \"key\": \"alpha.sensor\"\n    {\n        result.push_back(val.toString());\n    }\n    else if (val.isArray()) // \"key\": [ \"alpha.sensor\", \"beta.sensor\" ]\n    {\n        const auto arr = val.toArray();\n        for (const auto &i : arr)\n        {\n            if (i.isString())\n            {\n                result.push_back(i.toString());\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Parses an DDF JSON object.\n    \\returns DDF object, use DeviceDescription::isValid() to check for success.\n */\nstatic DeviceDescription DDF_ParseDeviceObject(DDF_ParseContext *pctx, const QJsonObject &obj)\n{\n    DeviceDescription result;\n\n    const auto schema = obj.value(QLatin1String(\"schema\")).toString();\n\n    if (schema != QLatin1String(\"devcap1.schema.json\"))\n    {\n        return result;\n    }\n\n    const auto subDevices = obj.value(QLatin1String(\"subdevices\"));\n    if (!subDevices.isArray())\n    {\n        return result;\n    }\n\n    U_ASSERT(pctx->filePathLength != 0);\n    U_ASSERT(pctx->filePath[pctx->filePathLength] == '\\0');\n    result.path = &pctx->filePath[0];\n\n    // TODO(mpi): get rid of QStringLists and only use atoms\n    result.manufacturerNames = DDF_ParseStringOrList(obj, QLatin1String(\"manufacturername\"));\n    result.modelIds = DDF_ParseStringOrList(obj, QLatin1String(\"modelid\"));\n    result.product = obj.value(QLatin1String(\"product\")).toString();\n\n    if (obj.contains(QLatin1String(\"status\")))\n    {\n        result.status = obj.value(QLatin1String(\"status\")).toString();\n    }\n\n    if (obj.contains(QLatin1String(\"vendor\")))\n    {\n        result.vendor = obj.value(QLatin1String(\"vendor\")).toString();\n    }\n\n    if (obj.contains(QLatin1String(\"sleeper\")))\n    {\n        result.sleeper = obj.value(QLatin1String(\"sleeper\")).toBool() ? 1 : 0;\n    }\n\n    if (obj.contains(QLatin1String(\"supportsMgmtBind\")))\n    {\n        result.supportsMgmtBind = obj.value(QLatin1String(\"supportsMgmtBind\")).toBool() ? 1 : 0;\n    }\n\n    if (obj.contains(QLatin1String(\"matchexpr\")))\n    {\n        result.matchExpr = obj.value(QLatin1String(\"matchexpr\")).toString();\n    }\n\n    const auto keys = obj.keys();\n    for (const auto &key : keys)\n    {\n        DBG_Printf(DBG_DDF, \"DDF %s: %s\\n\", qPrintable(key), qPrintable(obj.value(key).toString()));\n    }\n\n    const auto subDevicesArr = subDevices.toArray();\n    for (const auto &i : subDevicesArr)\n    {\n        if (i.isObject())\n        {\n            const auto sub = DDF_ParseSubDevice(pctx, i.toObject());\n            if (sub.isValid())\n            {\n                result.subDevices.push_back(sub);\n            }\n        }\n    }\n\n    const auto bindings = obj.value(QLatin1String(\"bindings\"));\n    if (bindings.isArray())\n    {\n        const auto bindingsArr = bindings.toArray();\n        for (const auto &i : bindingsArr)\n        {\n            if (i.isObject())\n            {\n                const auto bnd = DDF_ParseBinding(i.toObject());\n                if (isValid(bnd))\n                {\n                    result.bindings.push_back(bnd);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Reads an item file under (generic/items/).\n    \\returns A parsed item, use DeviceDescription::Item::isValid() to check for success.\n */\nstatic DeviceDescription::Item DDF_ReadItemFile(DDF_ParseContext *pctx)\n{\n    if (!pctx->fileData || pctx->fileDataSize < 16)\n    {\n        return { };\n    }\n\n    const QByteArray data = QByteArray::fromRawData((const char*)pctx->fileData, pctx->fileDataSize);\n\n    QJsonParseError error;\n    QJsonDocument doc = QJsonDocument::fromJson(data, &error);\n\n    if (error.error != QJsonParseError::NoError)\n    {\n        DBG_Printf(DBG_DDF, \"DDF failed to read %s, err: %s, offset: %d\\n\", pctx->filePath, qPrintable(error.errorString()), error.offset);\n        return { };\n    }\n\n    if (doc.isObject())\n    {\n        return DDF_ParseItem(pctx, doc.object());\n    }\n\n    return { };\n}\n\n/*! Reads an subdevice file under (generic/subdevices/).\n    \\returns A parsed subdevice, use isValid(DDF_SubDeviceDescriptor) to check for success.\n */\nstatic DDF_SubDeviceDescriptor DDF_ReadSubDeviceFile(DDF_ParseContext *pctx)\n{\n    DDF_SubDeviceDescriptor result = { };\n\n    if (!pctx->fileData || pctx->fileDataSize < 16)\n    {\n        return result;\n    }\n\n    const QByteArray data = QByteArray::fromRawData((const char*)pctx->fileData, pctx->fileDataSize);\n\n    QJsonParseError error;\n    QJsonDocument doc = QJsonDocument::fromJson(data, &error);\n\n    if (error.error != QJsonParseError::NoError)\n    {\n        DBG_Printf(DBG_DDF, \"DDF failed to read %s, err: %s, offset: %d\\n\", pctx->filePath, qPrintable(error.errorString()), error.offset);\n        return result;\n    }\n\n    if (doc.isObject())\n    {\n        const auto obj = doc.object();\n        QString schema;\n        if (obj.contains(QLatin1String(\"schema\")))\n        {\n            schema = obj.value(QLatin1String(\"schema\")).toString();\n        }\n\n        if (schema != QLatin1String(\"subdevice1.schema.json\"))\n        {\n            return result;\n        }\n\n        if (obj.contains(QLatin1String(\"name\")))\n        {\n            result.name = obj.value(QLatin1String(\"name\")).toString();\n        }\n        if (obj.contains(QLatin1String(\"type\")))\n        {\n            result.type = obj.value(QLatin1String(\"type\")).toString();\n        }\n        if (obj.contains(QLatin1String(\"restapi\")))\n        {\n            result.restApi = obj.value(QLatin1String(\"restapi\")).toString();\n        }\n\n        result.order = obj.value(QLatin1String(\"order\")).toInt(SUBDEVICE_DEFAULT_ORDER);\n\n        if (obj.contains(QLatin1String(\"uuid\")))\n        {\n            const auto uniqueId = obj.value(QLatin1String(\"uuid\"));\n            if (uniqueId.isArray())\n            {\n                const auto arr = uniqueId.toArray();\n                for (const auto &i : arr)\n                {\n                    DBG_Assert(i.isString());\n                    result.uniqueId.push_back(i.toString());\n                }\n            }\n        }\n        if (obj.contains(QLatin1String(\"items\")))\n        {\n            const auto items = obj.value(QLatin1String(\"items\"));\n            if (items.isArray())\n            {\n                const auto arr = items.toArray();\n                for (const auto &i : arr)\n                {\n                    DBG_Assert(i.isString());\n                    ResourceItemDescriptor rid;\n                    if (getResourceItemDescriptor(i.toString(), rid))\n                    {\n                        result.items.push_back(rid.suffix);\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic QVariant DDF_ResolveParamScript(const QVariant &param, const QString &path)\n{\n    auto result = param;\n\n    if (param.type() != QVariant::Map)\n    {\n        return result;\n    }\n\n    auto map = param.toMap();\n\n    if (map.contains(QLatin1String(\"script\")))\n    {\n        const auto script = map[\"script\"].toString();\n\n        const QFileInfo fi(path);\n        QFile f(fi.canonicalPath() + \"/\" + script);\n\n        if (f.exists() && f.open(QFile::ReadOnly))\n        {\n            QString content = f.readAll();\n            if (!content.isEmpty())\n            {\n                DDF_TryCompileAndFixJavascript(&content, path);\n                map[\"eval\"] = content;\n                result = std::move(map);\n            }\n        }\n    }\n    else if (map.contains(QLatin1String(\"eval\")))\n    {\n        QString content = map[QLatin1String(\"eval\")].toString();\n        if (!content.isEmpty())\n        {\n            DDF_TryCompileAndFixJavascript(&content, path);\n            map[QLatin1String(\"eval\")] = content;\n            result = std::move(map);\n        }\n    }\n\n    return result;\n}\n\nstatic QVariant DDF_ResolveBundleParamScript(const QVariant &param, DDF_ParseContext *pctx)\n{\n    auto result = param;\n\n    if (param.type() != QVariant::Map)\n    {\n        return result;\n    }\n\n    auto map = param.toMap();\n    unsigned fnameStart;\n\n    if (map.contains(QLatin1String(\"script\")))\n    {\n        const std::string script = map[\"script\"].toString().toStdString();\n\n        for (DDFB_ExtfChunk *extf = pctx->extChunks; extf; extf = extf->next)\n        {\n            if (extf->fileType[0] != 'S' || extf->fileType[1] != 'C' || extf->fileType[2] != 'J' || extf->fileType[3] != 'S')\n                continue;\n\n            if (extf->pathLength < 4) // should not happen: a.js\n                continue;\n\n            /*\n             * Lookup just the filename of the Javascript file in the bundle.\n             * While this could be wrong in theory it's unlikely.\n             * If needed we can resolve relative paths later on to be more strict.\n             */\n            fnameStart = extf->pathLength;\n            for (;fnameStart; fnameStart--)\n            {\n                if (extf->path[fnameStart] == '/')\n                    break;\n            }\n\n            unsigned fnameLength = extf->pathLength - fnameStart;\n            if (script.size() < fnameLength)\n                continue;\n\n            if (U_memcmp(script.c_str() + (script.size() - fnameLength), &extf->path[fnameStart], fnameLength) != 0)\n                continue;\n\n            QString content = QString::fromUtf8((const char*)extf->fileData, extf->fileSize);\n\n            if (!content.isEmpty())\n            {\n                map[\"eval\"] = content;\n            }\n\n            break;\n        }\n    }\n\n    if (map.contains(QLatin1String(\"eval\")))\n    {\n        QString content = map[QLatin1String(\"eval\")].toString();\n        if (!content.isEmpty())\n        {\n            QString path; // dummy\n            DDF_TryCompileAndFixJavascript(&content, path);\n            map[QLatin1String(\"eval\")] = content;\n            result = std::move(map);\n        }\n    }\n\n    return result;\n}\n\nDeviceDescription DDF_LoadScripts(const DeviceDescription &ddf)\n{\n    auto result = ddf;\n\n    for (auto &sub : result.subDevices)\n    {\n        for (auto &item : sub.items)\n        {\n            item.parseParameters = DDF_ResolveParamScript(item.parseParameters, ddf.path);\n            item.readParameters = DDF_ResolveParamScript(item.readParameters, ddf.path);\n            item.writeParameters = DDF_ResolveParamScript(item.writeParameters, ddf.path);\n        }\n    }\n\n    return result;\n}\n\n/*! Reads a DDF file which may contain one or more device descriptions.\n    \\returns Vector of parsed DDF objects.\n */\nstatic DeviceDescription DDF_ReadDeviceFile(DDF_ParseContext *pctx)\n{\n    U_ASSERT(pctx->fileData);\n    U_ASSERT(pctx->fileDataSize > 64);\n\n    const QByteArray data = QByteArray::fromRawData((const char*)pctx->fileData, pctx->fileDataSize);\n    QJsonParseError error;\n    QJsonDocument doc = QJsonDocument::fromJson(data, &error);\n\n    if (error.error != QJsonParseError::NoError)\n    {\n        DBG_Printf(DBG_DDF, \"DDF failed to read %s, err: %s, offset: %d\\n\", pctx->filePath, qPrintable(error.errorString()), error.offset);\n        return { };\n    }\n\n    if (doc.isObject())\n    {\n        DeviceDescription ddf = DDF_ParseDeviceObject(pctx, doc.object());\n        if (ddf.isValid())\n        {\n            return ddf;\n        }\n    }\n\n    return { };\n}\n\nstatic int DDF_ProcessSignatures(DDF_ParseContext *pctx, std::vector<U_ECC_PublicKeySecp256k1> &publicKeys, U_BStream *bs, uint32_t *bundleHash)\n{\n    unsigned i;\n    unsigned count;\n    uint16_t pubkeyLen;\n    uint16_t sigLen;\n\n    U_ECC_PublicKeySecp256k1 pubkey;\n    U_ECC_SignatureSecp256k1 sig;\n\n    count = 0;\n\n    for (;bs->status == U_BSTREAM_OK && bs->pos < bs->size;)\n    {\n        pubkeyLen = U_bstream_get_u16_le(bs);\n        if (sizeof(pubkey.key) < pubkeyLen)\n        {\n            return 0;\n        }\n\n        for (i = 0; i < pubkeyLen; i++)\n        {\n            pubkey.key[i] = U_bstream_get_u8(bs);\n        }\n\n        sigLen = U_bstream_get_u16_le(bs);\n        if (sizeof(sig.sig) < sigLen)\n        {\n            return 0;\n        }\n\n        for (i = 0; i < sigLen; i++)\n        {\n            sig.sig[i] = U_bstream_get_u8(bs);\n        }\n\n        if (U_ECC_VerifySignatureSecp256k1(&pubkey, &sig, (uint8_t*)bundleHash, U_SHA256_HASH_SIZE))\n        {\n            for (i = 0; i < publicKeys.size(); i++)\n            {\n                U_ECC_PublicKeySecp256k1 &pk = publicKeys[i];\n\n                if (U_memcmp(pk.key, pubkey.key, sizeof(pk.key)) == 0)\n                    break; // already known\n            }\n\n            if (i == publicKeys.size() && publicKeys.size() < DDF_MAX_PUBLIC_KEYS)\n            {\n                publicKeys.push_back(pubkey);\n            }\n\n            pctx->signatures |= (1 << i);\n            count++;\n        }\n    }\n\n    if (count)\n        return 1;\n\n    return 0;\n}\n\n/*! Merge common properties like \"read\", \"parse\" and \"write\" functions from generic items into DDF items.\n    Only properties which are already defined in the DDF file won't be overwritten.\n\n    \\param genericItems - generic items used as source\n    \\param ddf - DDF object with unmerged items\n    \\returns The merged DDF object.\n */\nstatic DeviceDescription DDF_MergeGenericItems(const std::vector<DeviceDescription::Item> &genericItems, const DeviceDescription &ddf)\n{\n    auto result = ddf;\n\n    for (auto &sub : result.subDevices)\n    {\n        for (auto &item : sub.items)\n        {\n            const auto genItem = std::find_if(genericItems.cbegin(), genericItems.cend(),\n                                              [&item](const DeviceDescription::Item &i){ return i.descriptor.suffix == item.descriptor.suffix; });\n            if (genItem == genericItems.cend())\n            {\n                continue;\n            }\n\n            item.isImplicit = genItem->isImplicit;\n            item.isManaged = genItem->isManaged;\n            item.isGenericRead = 0;\n            item.isGenericWrite = 0;\n            item.isGenericParse = 0;\n\n            if (!item.isStatic)\n            {\n                if (item.readParameters.isNull()) { item.readParameters = genItem->readParameters; item.isGenericRead = 1; }\n                if (item.writeParameters.isNull()) { item.writeParameters = genItem->writeParameters; item.isGenericWrite = 1; }\n                if (item.parseParameters.isNull()) { item.parseParameters = genItem->parseParameters; item.isGenericParse = 1; }\n                if (item.refreshInterval == DeviceDescription::Item::NoRefreshInterval && genItem->refreshInterval != item.refreshInterval)\n                {\n                    item.refreshInterval = genItem->refreshInterval;\n                }\n            }\n\n            if (item.descriptor.access == ResourceItemDescriptor::Access::Unknown)\n            {\n                item.descriptor.access = genItem->descriptor.access;\n            }\n\n            if (!item.hasIsPublic)\n            {\n                item.isPublic = genItem->isPublic;\n            }\n\n            if (!item.defaultValue.isValid() && genItem->defaultValue.isValid())\n            {\n                item.defaultValue = genItem->defaultValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int DDF_MergeGenericBundleItems(DeviceDescription &ddf, DDF_ParseContext *pctx)\n{\n    std::vector<DeviceDescription::Item> genericItems;\n\n    {\n        // preserve parse context\n        uint8_t *fileData = pctx->fileData;\n        unsigned fileDataSize = pctx->fileDataSize;\n\n        /*\n         * Load generic items from bundle.\n         */\n\n        for (DDFB_ExtfChunk *extf = pctx->extChunks; extf; extf = extf->next)\n        {\n            U_SStream ss;\n            U_sstream_init(&ss, (void*)extf->path, extf->pathLength);\n            if (U_sstream_starts_with(&ss, \"generic/items\") == 0)\n                continue;\n\n            // temp. change where data points\n            pctx->fileData = extf->fileData;\n            pctx->fileDataSize = extf->fileSize;\n\n            DeviceDescription::Item item = DDF_ReadItemFile(pctx);\n            if (item.isValid())\n            {\n                genericItems.push_back(std::move(item));\n            }\n            else\n            {\n                U_ASSERT(0 && \"failed to read bundle item file\");\n            }\n        }\n\n        // restore parse context\n        pctx->fileData = fileData;\n        pctx->fileDataSize = fileDataSize;\n    }\n\n\n    for (DeviceDescription::SubDevice &sub : ddf.subDevices)\n    {\n        for (DeviceDescription::Item &item : sub.items)\n        {\n            const auto genItem = std::find_if(genericItems.cbegin(), genericItems.cend(),\n                                              [&item](const DeviceDescription::Item &i){ return i.descriptor.suffix == item.descriptor.suffix; });\n            if (genItem == genericItems.cend())\n            {\n                continue;\n            }\n\n            item.isImplicit = genItem->isImplicit;\n            item.isManaged = genItem->isManaged;\n            item.isGenericRead = 0;\n            item.isGenericWrite = 0;\n            item.isGenericParse = 0;\n\n            if (!item.isStatic)\n            {\n                if (item.readParameters.isNull()) { item.readParameters = genItem->readParameters; item.isGenericRead = 1; }\n                if (item.writeParameters.isNull()) { item.writeParameters = genItem->writeParameters; item.isGenericWrite = 1; }\n                if (item.parseParameters.isNull()) { item.parseParameters = genItem->parseParameters; item.isGenericParse = 1; }\n                if (item.refreshInterval == DeviceDescription::Item::NoRefreshInterval && genItem->refreshInterval != item.refreshInterval)\n                {\n                    item.refreshInterval = genItem->refreshInterval;\n                }\n\n                item.parseParameters = DDF_ResolveBundleParamScript(item.parseParameters, pctx);\n                item.readParameters = DDF_ResolveBundleParamScript(item.readParameters, pctx);\n                item.writeParameters = DDF_ResolveBundleParamScript(item.writeParameters, pctx);\n            }\n\n            if (item.descriptor.access == ResourceItemDescriptor::Access::Unknown)\n            {\n                item.descriptor.access = genItem->descriptor.access;\n            }\n\n            if (!item.hasIsPublic)\n            {\n                item.isPublic = genItem->isPublic;\n            }\n\n            if (!item.defaultValue.isValid() && genItem->defaultValue.isValid())\n            {\n                item.defaultValue = genItem->defaultValue;\n            }\n        }\n    }\n\n    return 1;\n}\n\nuint8_t DDF_GetSubDeviceOrder(const QString &type)\n{\n    if (type.isEmpty() || type.startsWith(QLatin1String(\"CLIP\")))\n    {\n        return SUBDEVICE_DEFAULT_ORDER;\n    }\n\n    if (_priv)\n    {\n        auto i = std::find_if(_priv->subDevices.cbegin(), _priv->subDevices.cend(), [&](const auto &sub)\n        { return sub.name == type; });\n\n        if (i != _priv->subDevices.cend())\n        {\n            return i->order;\n        }\n    }\n\n#ifdef QT_DEBUG\n    DBG_Printf(DBG_DDF, \"DDF No subdevice for type: %s\\n\", qPrintable(type));\n#endif\n\n    return SUBDEVICE_DEFAULT_ORDER;\n}\n\n/*! Creates a unique Resource handle.\n */\nResource::Handle R_CreateResourceHandle(const Resource *r, size_t containerIndex)\n{\n    Q_ASSERT(r->prefix() != nullptr);\n    Q_ASSERT(!r->item(RAttrUniqueId)->toString().isEmpty());\n\n    Resource::Handle result;\n    result.hash = qHash(r->item(RAttrUniqueId)->toString());\n    result.index = containerIndex;\n    result.type = r->prefix()[1];\n    result.order = 0;\n\n    Q_ASSERT(result.type == 's' || result.type == 'l' || result.type == 'd' || result.type == 'g');\n    Q_ASSERT(isValid(result));\n\n    if (result.type == 's' || result.type == 'l')\n    {\n        const ResourceItem *type = r->item(RAttrType);\n        if (type)\n        {\n            result.order = DDF_GetSubDeviceOrder(type->toString());\n        }\n    }\n\n    return result;\n}\n"
        },
        {
          "name": "device_descriptions.h",
          "type": "blob",
          "size": 8.9091796875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_DESCRIPTIONS_H\n#define DEVICE_DESCRIPTIONS_H\n\n#include <QObject>\n#include <QVariantMap>\n#include \"resource.h\"\n#include \"sensor.h\"\n\n#define SUBDEVICE_DEFAULT_ORDER  200\n\nclass Event;\n\nclass DDF_ZclReport\n{\npublic:\n    quint32 reportableChange = 0;\n    quint16 attributeId = 0;\n    quint16 minInterval = 0;\n    quint16 maxInterval = 0;\n    quint16 manufacturerCode = 0;\n    quint8 direction = 0;\n    quint8 dataType = 0;\n    bool valid = false;\n};\n\ninline bool operator==(const DDF_ZclReport &a, const DDF_ZclReport &b)\n{\n    return memcmp(&a, &b, sizeof(a)) == 0;\n}\n\ninline bool operator!=(const DDF_ZclReport &a, const DDF_ZclReport &b) { return !(a == b); }\n\ninline bool isValid(const DDF_ZclReport &rep) { return rep.valid; }\n\nclass DDF_Binding\n{\npublic:\n    union\n    {\n        quint16 dstGroup;\n        quint64 dstExtAddress;\n    };\n\n    quint16 clusterId;\n    quint8 srcEndpoint;\n    quint8 dstEndpoint;\n    quint8 configGroup;\n    struct\n    {\n        unsigned int isGroupBinding : 1;\n        unsigned int isUnicastBinding : 1;\n        unsigned int pad : 6 + 24;\n    };\n    std::vector<DDF_ZclReport> reporting;\n};\n\ninline bool isValid(const DDF_Binding &bnd) { return (bnd.isUnicastBinding || bnd.isGroupBinding) && bnd.srcEndpoint != 0; }\n\ninline bool operator==(const DDF_Binding &a, const DDF_Binding &b)\n{\n    if (a.clusterId == b.clusterId &&\n        a.srcEndpoint == b.srcEndpoint &&\n        a.reporting == b.reporting)\n    {\n        if (a.isUnicastBinding && b.isUnicastBinding &&\n            a.dstExtAddress == b.dstExtAddress &&\n            a.dstEndpoint == b.dstEndpoint)\n        {\n            return true;\n        }\n        if (a.isGroupBinding && b.isGroupBinding && a.dstGroup == b.dstGroup)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\ninline bool operator!=(const DDF_Binding &a, const DDF_Binding &b)  { return !(a == b); }\n\nclass DeviceDescription\n{\npublic:\n    bool isValid() const { return !manufacturerNames.isEmpty() && !modelIds.empty() && !subDevices.empty(); }\n\n    uint32_t sha256Hash[8] = {}; // either raw .json hash or bundle hash\n    int64_t lastModified = 0;\n    uint64_t signedBy = 0; // each bit is an index into d->publicKeys[] (max. 64)\n\n    // TODO get rid of QStringLists use the atom lists instead\n    QStringList modelIds;\n    QStringList manufacturerNames; // as reported in Basic cluster\n\n    std::vector<unsigned> modelidAtomIndices;\n    std::vector<unsigned> mfnameAtomIndices;\n\n    int storageLocation = -1; // deCONZ::StorageLocation\n\n    QString path;\n    QString vendor; // optional: friendly name of manufacturer\n    QString product;\n    QString status;\n    QString matchExpr;\n\n    int handle = -1; // index in container\n    int sleeper = -1;\n    int supportsMgmtBind = -1;\n\n    class Item\n    {\n    public:\n        using Handle = uint32_t;\n        enum Constants {\n            NoRefreshInterval = -1,\n            InvalidItemHandle = 0\n        };\n\n        Item()\n        {\n            flags = 0;\n        }\n\n        bool isValid() const { return !name.empty() && descriptor.isValid(); }\n        bool operator==(const Item &other) const\n        {\n            return flags == other.flags &&\n                   handle == other.handle &&\n                   refreshInterval == other.refreshInterval &&\n                   name == other.name &&\n                   descriptor.suffix == other.descriptor.suffix &&\n                   parseParameters == other.parseParameters &&\n                   readParameters == other.readParameters &&\n                   writeParameters == other.writeParameters &&\n                   defaultValue == other.defaultValue &&\n                   description == other.description;\n        }\n\n        bool operator!=(const Item &other) const { return !(*this == other); }\n\n\n        Handle handle = InvalidItemHandle;\n\n        union\n        {\n            struct // 16 bits flags\n            {\n                unsigned short isGenericRead : 1;\n                unsigned short isGenericWrite : 1;\n                unsigned short isGenericParse : 1;\n                unsigned short isPublic : 1;\n                unsigned short isStatic : 1;\n                unsigned short isImplicit : 1;\n                unsigned short isManaged : 1; // managed internally\n                unsigned short awake : 1;\n                unsigned short hasIsPublic : 1; // to overwrite specific values\n                unsigned short pad : 7;\n            };\n\n            unsigned short flags;\n        };\n\n        int refreshInterval = NoRefreshInterval;\n        BufString<64> name;  // todo global cache\n        ResourceItemDescriptor descriptor;\n        QVariant parseParameters;\n        QVariant readParameters;\n        QVariant writeParameters;\n        QVariant defaultValue;\n        QString description;\n    };\n\n    class SubDevice\n    {\n    public:\n        bool isValid() const { return !type.isEmpty() && !restApi.isEmpty() && !uniqueId.isEmpty() && !items.empty(); }\n        QString type;\n        QString restApi;\n        QStringList uniqueId; // [ \"$address.ext\", \"01\", \"0405\"],\n        QVariantMap meta;\n        std::vector<Item> items;\n        SensorFingerprint fingerPrint;\n    };\n\n    std::vector<SubDevice> subDevices;\n    std::vector<DDF_Binding> bindings;\n};\n\nclass DDF_SubDeviceDescriptor\n{\npublic:\n    QString type;\n    QString name;\n    QString restApi;\n    QStringList uniqueId;\n    std::vector<const char*> items; // RAttrName, etc.\n    int order;\n};\n\ninline bool isValid(const DDF_SubDeviceDescriptor &sub)\n{\n    return !sub.type.isEmpty() && !sub.name.isEmpty() && !sub.restApi.isEmpty() && !sub.uniqueId.isEmpty();\n}\n\nstruct DDF_FunctionDescriptor\n{\n    struct Parameter\n    {\n        struct // 16 bits flags\n        {\n            unsigned int isOptional : 1;\n            unsigned int supportsArray : 1;\n            unsigned int isHexString : 1;\n            unsigned int pad : 5;\n        };\n\n        QString name;\n        QString key;\n        QString description;\n        ApiDataType dataType = DataTypeUnknown;\n        QVariant defaultValue = 0;\n    };\n\n    QString name;\n    QString description;\n    std::vector<Parameter> parameters;\n};\n\nclass DeviceDescriptionsPrivate;\n\nusing DDF_Items = std::vector<DeviceDescription::Item>;\n\nenum DDF_MatchControl\n{\n    DDF_EvalMatchExpr,\n    DDF_IgnoreMatchExpr\n};\n\nclass DeviceDescriptions : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit DeviceDescriptions(QObject *parent = nullptr);\n    ~DeviceDescriptions();\n    void setEnabledStatusFilter(const QStringList &filter);\n    const QStringList &enabledStatusFilter() const;\n    const DeviceDescription &get(const Resource *resource, DDF_MatchControl match = DDF_EvalMatchExpr);\n    const DeviceDescription &getFromHandle(DeviceDescription::Item::Handle hnd) const;\n    void put(const DeviceDescription &ddf);\n    const DeviceDescription &load(const QString &path);\n\n    const DeviceDescription::SubDevice &getSubDevice(const Resource *resource) const;\n\n    void prepare();\n\n    QString constantToString(const QString &constant) const;\n    QString stringToConstant(const QString &str) const;\n\n    const DDF_Items &genericItems() const;\n    const DeviceDescription::Item &getItem(const ResourceItem *item) const;\n    const DeviceDescription::Item &getGenericItem(const char *suffix) const;\n    const std::vector<DDF_FunctionDescriptor> &getParseFunctions() const;\n    const std::vector<DDF_FunctionDescriptor> &getReadFunctions() const;\n    const std::vector<DDF_FunctionDescriptor> &getWriteFunctions() const;\n    const std::vector<DDF_SubDeviceDescriptor> &getSubDevices() const;\n\n    static DeviceDescriptions *instance();\n\npublic Q_SLOTS:\n    void handleEvent(const Event &event);\n    void readAll();\n    void readAllRawJson();\n    void readAllBundles();\n\n    void ddfReloadTimerFired();\n    void reloadAllRawJsonAndBundles(const Resource *resource);\n\nQ_SIGNALS:\n    void eventNotify(const Event&); //! Emitted \\p Event needs to be enqueued in a higher layer.\n    void loaded();\n\nprivate:\n    void handleDDFInitRequest(const Event &event);\n    bool loadDDFAndBundlesFromDisc(const Resource *resource);\n\n    Q_DECLARE_PRIVATE_D(d_ptr2, DeviceDescriptions)\n    DeviceDescriptionsPrivate *d_ptr2 = nullptr;\n};\n\n#define DDF_AnnoteZclParse(resource, item, ep, cl, at, eval) \\\n    DDF_AnnoteZclParse1(__LINE__, __FILE__, resource, item, ep, cl, at, eval)\n\nbool DDF_IsStatusEnabled(const QString &status);\nvoid DDF_AnnoteZclParse1(int line, const char* file, const Resource *resource, ResourceItem *item, quint8 ep, quint16 clusterId, quint16 attributeId, const char *eval);\nconst DeviceDescription::Item &DDF_GetItem(const ResourceItem *item);\nResource::Handle R_CreateResourceHandle(const Resource *r, size_t containerIndex);\n\nvoid DEV_ReloadDeviceIdendifier(unsigned atomIndexMfname, unsigned atomIndexModelid);\n\n#endif // DEVICEDESCRIPTIONS_H\n"
        },
        {
          "name": "device_js",
          "type": "tree",
          "content": null
        },
        {
          "name": "device_tick.cpp",
          "type": "blob",
          "size": 7.1572265625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QElapsedTimer>\n#include <QTimer>\n#include <deconz/dbg_trace.h>\n#include <deconz/timeref.h>\n#include \"event.h\"\n#include \"resource.h\"\n#include \"device_tick.h\"\n\n#define DEV_TICK_BOOT_TIME 8000\n#define TICK_INTERVAL_JOIN 500\n#define TICK_INTERVAL_IDLE 1000\n#define TICK_INTERVAL_IDLE_OTAU 6000\n\nextern int DEV_ApsQueueSize();\nextern bool DEV_OtauBusy();\n\nstruct JoinDevice\n{\n    DeviceKey deviceKey;\n    quint8 macCapabilities;\n};\n\nstatic const char *RLocal = nullptr;\n\ntypedef void (*DT_StateHandler)(DeviceTickPrivate *d, const Event &event);\n\nstatic void DT_StateInit(DeviceTickPrivate *d, const Event &event);\nstatic void DT_StateJoin(DeviceTickPrivate *d, const Event &event);\nstatic void DT_StateIdle(DeviceTickPrivate *d, const Event &event);\n\nclass DeviceTickPrivate\n{\npublic:\n    DT_StateHandler stateHandler = DT_StateInit;\n    std::vector<JoinDevice> joinDevices;\n    deCONZ::SteadyTimeRef joinDisabledTime;\n    DeviceTick *q = nullptr;\n    QTimer *timer = nullptr;\n    size_t devIter = 0;\n    const DeviceContainer *devices = nullptr;\n};\n\n/*! Constructor.\n */\nDeviceTick::DeviceTick(const DeviceContainer &devices, QObject *parent) :\n    QObject(parent),\n    d(new DeviceTickPrivate)\n{\n    d->devices = &devices;\n    d->q = this;\n    d->timer = new QTimer(this);\n    d->timer->setSingleShot(true);\n    connect(d->timer, &QTimer::timeout, this, &DeviceTick::timoutFired);\n    d->timer->start(DEV_TICK_BOOT_TIME);\n}\n\n/*! Destructor.\n */\nDeviceTick::~DeviceTick()\n{\n    Q_ASSERT(d);\n    delete d;\n    d = nullptr;\n}\n\n/*! Public event entry.\n */\nvoid DeviceTick::handleEvent(const Event &event)\n{\n    d->stateHandler(d, event);\n}\n\n/*! State timer callback.\n */\nvoid DeviceTick::timoutFired()\n{\n    d->stateHandler(d, Event(RLocal, REventStateTimeout, 0));\n}\n\n/*! Sets a new DeviceTick state.\n    The events REventStateLeave and REventStateEnter will be triggered accordingly.\n */\nstatic void DT_SetState(DeviceTickPrivate *d, DT_StateHandler state)\n{\n    if (d->stateHandler != state)\n    {\n        d->stateHandler(d, Event(RLocal, REventStateLeave, 0));\n        d->stateHandler = state;\n        d->stateHandler(d, Event(RLocal, REventStateEnter, 0));\n    }\n}\n\n/*! Starts the state timer. Free function to be mocked by test code.\n */\nstatic void DT_StartTimer(DeviceTickPrivate *d, int timeoutMs)\n{\n    d->timer->start(timeoutMs);\n}\n\n/*! Stops the state timer. Free function to be mocked by test code.\n */\nstatic void DT_StopTimer(DeviceTickPrivate *d)\n{\n    d->timer->stop();\n}\n\n/*! Initial state to wait DEV_TICK_BOOT_TIME seconds before starting normal operation.\n */\nstatic void DT_StateInit(DeviceTickPrivate *d, const Event &event)\n{\n    if (event.resource() == RLocal && event.what() == REventStateTimeout)\n    {\n        DBG_Printf(DBG_INFO, \"DEV Tick.Init: booted after %lld seconds\\n\", DEV_TICK_BOOT_TIME);\n        DT_SetState(d, DT_StateIdle);\n    }\n}\n\n/*! Emits REventPoll to the next device in DT_StateIdle.\n */\nstatic void DT_PollNextIdleDevice(DeviceTickPrivate *d)\n{\n    const auto devCount = d->devices->size();\n\n    if (devCount == 0)\n    {\n        return;\n    }\n\n    d->devIter %= devCount;\n\n    const auto &device = d->devices->at(d->devIter);\n    Q_ASSERT(device);\n    if (device->reachable())\n    {\n        emit d->q->eventNotify(Event(device->prefix(), REventPoll, 0, device->key()));\n    }\n    d->devIter++;\n}\n\n/*! This state is active while Permit Join is disabled for normal idle operation.\n\n    It walks over all Devices in TICK_INTERVAL_IDLE spacing.\n    The state transitions to DT_StateJoin when REventPermitjoinEnabled is received.\n */\nstatic void DT_StateIdle(DeviceTickPrivate *d, const Event &event)\n{\n    if (event.what() == REventPermitjoinEnabled)\n    {\n        DT_SetState(d, DT_StateJoin);\n    }\n    else if (event.resource() == RLocal)\n    {\n        if (event.what() == REventStateTimeout)\n        {\n            int timeout = DEV_OtauBusy() ? TICK_INTERVAL_IDLE_OTAU : TICK_INTERVAL_IDLE;\n            if (DA_ApsUnconfirmedRequests() < 4)\n            {\n                DT_PollNextIdleDevice(d);\n            }\n            DT_StartTimer(d, timeout);\n        }\n        else if (event.what() == REventStateEnter)\n        {\n            DT_StartTimer(d, TICK_INTERVAL_IDLE);\n        }\n        else if (event.what() == REventStateLeave)\n        {\n            DT_StopTimer(d);\n        }\n    }\n}\n\n/*! Adds a joining device entry to the queue if not already present.\n */\nstatic void DT_RegisterJoiningDevice(DeviceTickPrivate *d, DeviceKey deviceKey, quint8 macCapabilities)\n{\n    Q_ASSERT(deviceKey != 0); // if this triggers we have problems elsewhere\n\n    auto i = std::find_if(d->joinDevices.cbegin(), d->joinDevices.cend(), [&deviceKey](const JoinDevice &dev)\n    {\n        return deviceKey == dev.deviceKey;\n    });\n\n    if (i == d->joinDevices.cend())\n    {\n        JoinDevice dev;\n        dev.deviceKey = deviceKey;\n        dev.macCapabilities = macCapabilities;\n        d->joinDevices.push_back(dev);\n        DBG_Printf(DBG_INFO, \"DEV Tick: fast poll 0x%016llX, mac capabilities: 0x%02X\\n\", deviceKey, macCapabilities);\n    }\n}\n\n/*! Emits REventPoll to the next device in DT_StateJoin.\n */\nstatic void DT_PollNextJoiningDevice(DeviceTickPrivate *d)\n{\n    if (d->joinDevices.empty())\n    {\n        return;\n    }\n\n    d->devIter %= d->joinDevices.size();\n    Q_ASSERT(d->devIter < d->joinDevices.size());\n\n    const JoinDevice &device = d->joinDevices.at(d->devIter);\n    emit d->q->eventNotify(Event(RDevices, REventAwake, 0, device.deviceKey));\n    d->devIter++;\n}\n\n/*! This state is active while Permit Join is enabled.\n\n    When a REventDeviceAnnounce event is received, the device is added to a joining\n    queue and processed exclusivly and quickly.\n\n    The state transitions to DT_StateIdle when Permit Join is disabled.\n */\nstatic void DT_StateJoin(DeviceTickPrivate *d, const Event &event)\n{\n    if (event.what() == REventPermitjoinDisabled)\n    {\n        d->joinDisabledTime = deCONZ::steadyTimeRef();\n    }\n    else if (event.what() == REventDeviceAnnounce)\n    {\n        DBG_Printf(DBG_INFO, \"DEV Tick.Join: %s\\n\", event.what());\n        DT_RegisterJoiningDevice(d, event.deviceKey(), static_cast<quint8>(event.num()));\n    }\n    else if (event.resource() == RLocal)\n    {\n        if (event.what() == REventStateTimeout)\n        {\n            if (deCONZ::isValid(d->joinDisabledTime) &&\n                deCONZ::TimeSeconds{20} < (deCONZ::steadyTimeRef() - d->joinDisabledTime))\n            {\n                // leave state after delay to let fast polling finish even then permit join is disabled again\n                DT_SetState(d, DT_StateIdle);\n                return;\n            }\n\n            DT_PollNextJoiningDevice(d);\n            DT_StartTimer(d, TICK_INTERVAL_JOIN);\n        }\n        else if (event.what() == REventStateEnter)\n        {\n            d->joinDisabledTime = {};\n            DT_StartTimer(d, TICK_INTERVAL_JOIN);\n        }\n        else if (event.what() == REventStateLeave)\n        {\n            DT_StopTimer(d);\n            d->joinDevices.clear();\n        }\n    }\n}\n"
        },
        {
          "name": "device_tick.h",
          "type": "blob",
          "size": 1.1357421875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef DEVICE_TICK_H\n#define DEVICE_TICK_H\n\n#include <QObject>\n#include \"device.h\"\n\nclass Event;\nclass Device;\n\nclass DeviceTickPrivate;\n\n\n/*! \\class DeviceTick\n\n    Coordinates poking the Device state machines.\n\n    It differentiates between normal idle operation and device pairing while\n    Permit Join is enabled. While during pairing a faster pace is applied.\n\n    TODO\n\n    Take task queue and APS-DATA.request queue into account.\n */\nclass DeviceTick : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit DeviceTick(const DeviceContainer &devices, QObject *parent = nullptr);\n    ~DeviceTick();\n\nQ_SIGNALS:\n    void eventNotify(const Event&); //! Emitted \\p Event needs to be enqueued in a higher layer.\n\npublic Q_SLOTS:\n    void handleEvent(const Event &event);\n\nprivate Q_SLOTS:\n    void timoutFired();\n\nprivate:\n    DeviceTickPrivate *d = nullptr;\n};\n\n#endif // DEVICE_TICK_H\n"
        },
        {
          "name": "devices",
          "type": "tree",
          "content": null
        },
        {
          "name": "discovery.cpp",
          "type": "blob",
          "size": 17.9814453125,
          "content": "/*\r\n * Copyright (c) 2016-2020 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QFile>\r\n#include <QHostInfo>\r\n#include <QNetworkAccessManager>\r\n#include <QNetworkReply>\r\n#include <QNetworkProxy>\r\n#include <QSysInfo>\r\n#include \"de_web_plugin_private.h\"\r\n#include \"json.h\"\r\n#ifdef Q_OS_LINUX\r\n#include <unistd.h>\r\n#include <sys/time.h>\r\n#endif\r\n\r\n/*! Inits the internet discovery manager.\r\n */\r\nvoid DeRestPluginPrivate::initInternetDicovery()\r\n{\r\n    Q_ASSERT(inetDiscoveryManager == 0);\r\n    inetDiscoveryManager = new QNetworkAccessManager;\r\n    connect(inetDiscoveryManager, SIGNAL(finished(QNetworkReply*)),\r\n            this, SLOT(internetDiscoveryFinishedRequest(QNetworkReply*)));\r\n\r\n\r\n    DBG_Assert(gwAnnounceInterval >= 0);\r\n    if (gwAnnounceInterval < 0)\r\n    {\r\n        gwAnnounceInterval = ANNOUNCE_INTERVAL;\r\n    }\r\n\r\n    gwAnnounceVital = 0;\r\n    inetDiscoveryTimer = new QTimer(this);\r\n    inetDiscoveryTimer->setSingleShot(false);\r\n\r\n    {\r\n        QList<QNetworkProxy> proxies = QNetworkProxyFactory::systemProxyForQuery(QNetworkProxyQuery(gwAnnounceUrl));\r\n\r\n        if (!proxies.isEmpty())\r\n        {\r\n            const QNetworkProxy &proxy = proxies.first();\r\n            if (proxy.type() == QNetworkProxy::HttpProxy || proxy.type() == QNetworkProxy::HttpCachingProxy)\r\n            {\r\n                gwProxyPort = proxy.port();\r\n                gwProxyAddress = proxy.hostName();\r\n                inetDiscoveryManager->setProxy(proxy);\r\n                QHostInfo::lookupHost(proxy.hostName(),\r\n                                      this, SLOT(inetProxyHostLookupDone(QHostInfo)));\r\n            }\r\n        }\r\n    }\r\n\r\n    connect(inetDiscoveryTimer, SIGNAL(timeout()),\r\n            this, SLOT(internetDiscoveryTimerFired()));\r\n\r\n    setInternetDiscoveryInterval(gwAnnounceInterval);\r\n\r\n    // force first run\r\n    if (gwAnnounceInterval > 0)\r\n    {\r\n        QTimer::singleShot(5000, this, SLOT(internetDiscoveryTimerFired()));\r\n    }\r\n\r\n    {\r\n        QFile f(\"/etc/os-release\");\r\n        if (f.exists() && f.open(QFile::ReadOnly))\r\n        {\r\n            QTextStream stream(&f);\r\n\r\n            while (!stream.atEnd())\r\n            {\r\n                QString line = stream.readLine(200);\r\n                QStringList lineLs = line.split(QChar('='));\r\n\r\n                if (lineLs.size() != 2)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (lineLs[0] == QLatin1String(\"PRETTY_NAME\"))\r\n                {\r\n                    osPrettyName = lineLs[1];\r\n                    osPrettyName.remove(QChar('\"'));\r\n                }\r\n            }\r\n        }\r\n    }\r\n#ifdef ARCH_ARM\r\n    { // get raspberry pi revision\r\n        QFile f(\"/proc/cpuinfo\");\r\n        if (f.exists() && f.open(QFile::ReadOnly))\r\n        {\r\n            QByteArray arr = f.readAll();\r\n            QTextStream stream(arr);\r\n\r\n            while (!stream.atEnd())\r\n            {\r\n                QString line = stream.readLine(200);\r\n                QStringList lineLs = line.split(QChar(':'));\r\n\r\n                if (lineLs.size() != 2)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (lineLs[0].startsWith(QLatin1String(\"Revision\")))\r\n                {\r\n                    piRevision = lineLs[1].trimmed();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n#endif // ARCH_ARM\r\n\r\n    if (osPrettyName.isEmpty())\r\n    {\r\n#ifdef Q_OS_WIN\r\n        switch (QSysInfo::WindowsVersion)\r\n        {\r\n        case QSysInfo::WV_XP:         osPrettyName = QLatin1String(\"WinXP\"); break;\r\n        case QSysInfo::WV_WINDOWS7:   osPrettyName = QLatin1String(\"Win7\"); break;\r\n        case QSysInfo::WV_WINDOWS8:   osPrettyName = QLatin1String(\"Win8\"); break;\r\n        case QSysInfo::WV_WINDOWS8_1: osPrettyName = QLatin1String(\"Win8.1\"); break;\r\n        case QSysInfo::WV_WINDOWS10:  osPrettyName = QLatin1String(\"Win10\"); break;\r\n        default:\r\n            osPrettyName = QLatin1String(\"Win\");\r\n            break;\r\n        }\r\n#endif\r\n#ifdef Q_OS_OSX\r\n        osPrettyName = \"Mac\";\r\n#endif\r\n#ifdef Q_OS_LINUX\r\n        osPrettyName = \"Linux\";\r\n#endif\r\n    }\r\n}\r\n\r\n/*! Sets the announce interval for internet discovery.\r\n\r\n    \\param minutes a value between 0..180 min\r\n    \\return true on success\r\n */\r\nbool DeRestPluginPrivate::setInternetDiscoveryInterval(int minutes)\r\n{\r\n    if ((minutes < 0) || (minutes > 180))\r\n    {\r\n        DBG_Printf(DBG_INFO, \"discovery ignored invalid announce interval (%d minutes)\\n\", minutes);\r\n        return false;\r\n    }\r\n\r\n    inetDiscoveryTimer->stop();\r\n    if (gwAnnounceInterval != minutes)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"discovery updated announce interval to %d minutes\\n\", minutes);\r\n    }\r\n\r\n    gwAnnounceInterval = minutes;\r\n\r\n    if (gwAnnounceInterval > 0)\r\n    {\r\n        int msec = 1000 * 60 * gwAnnounceInterval;\r\n        inetDiscoveryTimer->start(msec);\r\n    }\r\n    return true;\r\n}\r\n\r\n/*! Handle announce trigger timer.\r\n */\r\nvoid DeRestPluginPrivate::internetDiscoveryTimerFired()\r\n{\r\n    if (gwAnnounceInterval <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwSwUpdateState == swUpdateState.transferring || gwSwUpdateState == swUpdateState.installing)\r\n    {\r\n        return; // don't interfere with running operations\r\n    }\r\n\r\n    int i = 0;\r\n    const deCONZ::Node *node;\r\n    deCONZ::ApsController *ctrl = deCONZ::ApsController::instance();\r\n\r\n    while (ctrl && ctrl->getNode(i, &node) == 0)\r\n    {\r\n      i++;\r\n    }\r\n\r\n    QVariantMap map;\r\n    map[\"name\"] = gwName;\r\n    map[\"mac\"] = gwBridgeId;\r\n    map[\"internal_ip\"] = gwConfig[\"ipaddress\"].toString();\r\n    map[\"internal_port\"] = gwConfig[\"port\"].toDouble();\r\n    map[\"interval\"] = gwAnnounceInterval;\r\n    map[\"swversion\"] = gwConfig[\"swversion\"].toString();\r\n    map[\"fwversion\"] = gwConfig[\"fwversion\"].toString();\r\n    map[\"nodecount\"] = (double)i;\r\n    map[\"uptime\"] = (double)getUptime();\r\n    map[\"updatechannel\"] = gwUpdateChannel;\r\n    map[\"os\"] = osPrettyName;\r\n    map[\"runmode\"] = gwRunMode;\r\n    if (!piRevision.isEmpty())\r\n    {\r\n        map[\"pirev\"] = piRevision;\r\n    }\r\n\r\n    QByteArray data = Json::serialize(map);\r\n    inetDiscoveryManager->put(QNetworkRequest(QUrl(gwAnnounceUrl)), data);\r\n}\r\n\r\n/*! Callback for finished HTTP requests.\r\n\r\n    \\param reply the reply to a HTTP request\r\n */\r\nvoid DeRestPluginPrivate::internetDiscoveryFinishedRequest(QNetworkReply *reply)\r\n{\r\n    DBG_Assert(reply != 0);\r\n\r\n    if (!reply)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (reply->error() == QNetworkReply::NoError)\r\n    {\r\n        if (gwAnnounceVital < 0)\r\n        {\r\n            gwAnnounceVital = 0;\r\n        }\r\n        gwAnnounceVital++;\r\n        DBG_Printf(DBG_INFO, \"Announced to internet %s\\n\", qPrintable(gwAnnounceUrl));\r\n        internetDiscoveryExtractGeo(reply);\r\n        internetDiscoveryExtractVersionInfo(reply);\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_INFO, \"discovery network reply error: %s\\n\", qPrintable(reply->errorString()));\r\n        if (gwAnnounceVital > 0)\r\n        {\r\n            gwAnnounceVital = 0;\r\n        }\r\n        gwAnnounceVital--;\r\n\r\n        if (gwProxyAddress != QLatin1String(\"none\") && gwProxyPort > 0)\r\n        {\r\n            if (inetDiscoveryManager->proxy().type() != QNetworkProxy::HttpProxy)\r\n            {\r\n                //first fail, speed up retry\r\n                QTimer::singleShot(5000, this, SLOT(internetDiscoveryTimerFired()));\r\n            }\r\n\r\n            QNetworkProxy proxy(QNetworkProxy::HttpProxy, gwProxyAddress, gwProxyPort);\r\n            inetDiscoveryManager->setProxy(proxy);\r\n        }\r\n\r\n        if (gwAnnounceVital < -10) // try alternative path\r\n        {\r\n            gwAnnounceUrl = QLatin1String(\"https://phoscon.de/discover\");\r\n        }\r\n    }\r\n\r\n    reply->deleteLater();\r\n}\r\n\r\n/*! Fills major.minor.patch versions as int in the array \\p ls.\r\n    \\returns true if \\p version is a valid version string and \\p ls could be filled.\r\n */\r\nbool versionToIntList(const QString &version, std::array<int, 3> &ls)\r\n{\r\n    bool result = false;\r\n    const auto versionList = version.split('.');\r\n\r\n    if (versionList.size() >= 3)\r\n    {\r\n        for (size_t i = 0; i < ls.size(); i++)\r\n        {\r\n            ls[i] = versionList[i].toInt(&result);\r\n            if (!result)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*! Returns true if the \\p remote version is newer than \\p current version.\r\n */\r\nbool remoteVersionIsNewer(const std::array<int, 3> &current, const std::array<int, 3> &remote)\r\n{\r\n    return current[0] <  remote[0] ||\r\n           (current[0] == remote[0] && current[1] <  remote[1]) ||\r\n           (current[0] == remote[0] && current[1] == remote[1] && current[2] < remote[2]);\r\n}\r\n\r\n/*! Extracts the update channels version info about the deCONZ/WebApp.\r\n\r\n    \\param reply which holds the version info in JSON format\r\n */\r\nvoid DeRestPluginPrivate::internetDiscoveryExtractVersionInfo(QNetworkReply *reply)\r\n{\r\n    bool ok;\r\n    QByteArray content = reply->readAll();\r\n    QVariant var = Json::parse(content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"discovery couldn't extract version info from reply\\n\");\r\n    }\r\n\r\n#ifdef ARCH_ARM\r\n    if (reply->hasRawHeader(\"date\") || reply->hasRawHeader(\"Date\"))\r\n    {\r\n        // if NTP is not working (UDP blocked, proxies, etc)\r\n        // try to extract time from discover server http header if local time is too off\r\n        QString date = reply->rawHeader(\"date\");\r\n        if (date.isEmpty())\r\n        {\r\n            date = reply->rawHeader(\"Date\");\r\n        }\r\n        DBG_Printf(DBG_INFO, \"discovery server date: %s\\n\", qPrintable(date));\r\n\r\n        QStringList ls = date.split(' ');\r\n        if (ls.size() == 6) // RFC 1123: ddd, dd MMM yyyy HH:mm:ss GTM\r\n        {\r\n            int day = ls[1].toInt();\r\n            int month = 0;\r\n            int year = ls[3].toInt();\r\n\r\n            const char *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\r\n            for (int i = 0; i < 12; i++)\r\n            {\r\n                if (ls[2].startsWith(months[i]))\r\n                {\r\n                    month = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            QDateTime dt;\r\n            dt.setTimeSpec(Qt::UTC);\r\n            dt.setDate(QDate(year, month, day));\r\n            dt.setTime(QTime::fromString(ls[4]));\r\n\r\n            QDateTime now = QDateTime::currentDateTimeUtc();\r\n            int diff = qAbs(now.secsTo(dt));\r\n\r\n            if (diff < 60)\r\n            {\r\n                DBG_Printf(DBG_INFO, \"\\t local time seems to be ok\\n\");\r\n            }\r\n            else if (getUptime() > 600 &&\r\n                     gwConfig[\"ntp\"].toString() != QLatin1String(\"synced\"))\r\n            {\r\n                DBG_Printf(DBG_INFO, \"\\t = %s, diff %d\\n\", qPrintable(dt.toString()), diff);\r\n                // lazy adjustment of process time\r\n                //time_t t = dt.toSecsSinceEpoch(); // Qt 5.8\r\n                time_t t = dt.toTime_t();\r\n                struct tm tbrokenDown;\r\n                if (localtime_r(&t, &tbrokenDown))\r\n                {\r\n                    struct timeval tv;\r\n                    tv.tv_sec = mktime(&tbrokenDown);\r\n                    tv.tv_usec = 0;\r\n                    if (settimeofday(&tv, NULL) < 0)\r\n                    {\r\n                        DBG_Printf(DBG_ERROR, \"settimeofday(): errno %d\\n\", errno);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n#endif // ARCH_ARM\r\n\r\n#ifdef ARCH_ARM\r\n    if (map.contains(\"versions\") && (map[\"versions\"].type() == QVariant::Map))\r\n    {\r\n        const auto versions = map[\"versions\"].toMap();\r\n\r\n        if (versions.contains(gwUpdateChannel) && (versions[gwUpdateChannel].type() == QVariant::String))\r\n        {\r\n            const auto version = versions[gwUpdateChannel].toString();\r\n\r\n            if (!version.isEmpty())\r\n            {\r\n                std::array<int, 3> current = { };\r\n                std::array<int, 3> remote = { };\r\n\r\n                if (versionToIntList(gwUpdateVersion, current) &&\r\n                    versionToIntList(version, remote) &&\r\n                    remoteVersionIsNewer(current, remote))\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"discovery found version %s for update channel %s\\n\", qPrintable(version), qPrintable(gwUpdateChannel));\r\n                    gwUpdateVersion = version;\r\n                    gwSwUpdateState = swUpdateState.readyToInstall;\r\n                }\r\n                else\r\n                {\r\n                    gwSwUpdateState = swUpdateState.noUpdate;\r\n                }\r\n                updateEtag(gwConfigEtag);\r\n            }\r\n            else\r\n            {\r\n                DBG_Printf(DBG_ERROR, \"discovery reply doesn't contain valid version info for update channel %s\\n\", qPrintable(gwUpdateChannel));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"discovery reply doesn't contain version info for update channel %s\\n\", qPrintable(gwUpdateChannel));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"discovery reply doesn't contain valid version info\\n\");\r\n    }\r\n#endif // ARCH_ARM\r\n\r\n    if (map.contains(\"interval\") && (map[\"interval\"].type() == QVariant::Double))\r\n    {\r\n        const int interval = map[\"interval\"].toInt(&ok);\r\n        if (ok && interval >= 0 && interval != gwAnnounceInterval)\r\n        {\r\n            setInternetDiscoveryInterval(interval);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Extracts the geo information.\r\n\r\n    \\param reply from discovery server\r\n */\r\nvoid DeRestPluginPrivate::internetDiscoveryExtractGeo(QNetworkReply *reply)\r\n{\r\n//    for (const QByteArray &hdr : reply->rawHeaderList())\r\n//    {\r\n//        DBG_Printf(DBG_INFO, \"hdr: %s: %s\\n\", qPrintable(hdr), qPrintable(reply->rawHeader(hdr)));\r\n//    }\r\n\r\n    if (reply->hasRawHeader(\"X-AppEngine-CityLatLong\"))\r\n    {\r\n        QList<QByteArray> ll = reply->rawHeader(\"X-AppEngine-CityLatLong\").split(',');\r\n        if (ll.size() != 2)\r\n        {\r\n            // no geo information available\r\n            return;\r\n        }\r\n\r\n        Sensor *sensor = getSensorNodeForId(daylightSensorId);\r\n        DBG_Assert(sensor != 0);\r\n        if (!sensor)\r\n        {\r\n            return;\r\n        }\r\n\r\n        ResourceItem *configured = sensor->item(RConfigConfigured);\r\n        ResourceItem *lat = sensor->item(RConfigLat);\r\n        ResourceItem *lon = sensor->item(RConfigLong);\r\n\r\n        DBG_Assert(configured && lat && lon);\r\n        if (!configured || !lat || !lon)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!configured->toBool() || !configured->lastSet().isValid())\r\n        {\r\n            configured->setValue(true);\r\n            lat->setValue(QString(ll[0]));\r\n            lon->setValue(QString(ll[1]));\r\n            sensor->setNeedSaveDatabase(true);\r\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Finished Lookup of http proxy IP address.\r\n\r\n    \\param host holds the proxy host info\r\n */\r\nvoid DeRestPluginPrivate::inetProxyHostLookupDone(const QHostInfo &host)\r\n{\r\n    if (host.error() != QHostInfo::NoError)\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"Proxy host lookup failed: %s\\n\", qPrintable(host.errorString()));\r\n        return;\r\n    }\r\n\r\n    foreach (const QHostAddress &address, host.addresses())\r\n    {\r\n        QString addr = address.toString();\r\n        if (address.protocol() == QAbstractSocket::IPv4Protocol &&\r\n            !addr.isEmpty() && gwProxyAddress != address.toString())\r\n        {\r\n            DBG_Printf(DBG_INFO, \"Found proxy IP address: %s\\n\", qPrintable(address.toString()));\r\n            gwProxyAddress = address.toString();\r\n            DBG_Assert(gwProxyPort != 0);\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            updateEtag(gwConfigEtag);\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n/*! Check if a received via field contains a usable proxy.\r\n\r\n    \\param via holds the proxy host info received by http request header\r\n */\r\nvoid DeRestPluginPrivate::inetProxyCheckHttpVia(const QString &via)\r\n{\r\n    if (via.isEmpty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwProxyPort != 0 && !gwProxyAddress.isEmpty() && gwProxyAddress != QLatin1String(\"none\"))\r\n    {\r\n        return; // already configured?\r\n    }\r\n\r\n    // https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.45\r\n    // 1.1 proxy.some-domain.com:3128 (squid/2.7.STABLE9)\r\n    DBG_Printf(DBG_INFO, \"Test proxy: \\t%s\\n\", qPrintable(via));\r\n\r\n    for (QString &entry : via.split(',')) // there might be multiple proxied in the chain\r\n    {\r\n        QStringList ls = entry.split(' ');\r\n        if (ls.size() < 2)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (!ls[0].contains(QLatin1String(\"1.1\")))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        QStringList recvBy = ls[1].split(':');\r\n        if (ls.size() < 1) // at least host must be specified\r\n        {\r\n            continue;\r\n        }\r\n\r\n        quint16 port = 8080;\r\n        if (recvBy.size() == 2) // optional\r\n        {\r\n            port = recvBy[1].toUInt();\r\n        }\r\n\r\n        DBG_Printf(DBG_INFO, \"\\t --> %s:%u\\n\", qPrintable(recvBy[0]), port);\r\n\r\n        if (gwProxyPort != 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (gwAnnounceVital >= 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        gwProxyAddress = recvBy[0];\r\n        gwProxyPort = port;\r\n\r\n        if (gwProxyAddress.contains('.'))\r\n        {\r\n            recvBy = gwProxyAddress.split('.');\r\n            gwProxyAddress = recvBy[0]; // strip domain // todo might be too restrictive\r\n        }\r\n\r\n        QNetworkProxy proxy(QNetworkProxy::HttpProxy, gwProxyAddress, gwProxyPort);\r\n        inetDiscoveryManager->setProxy(proxy);\r\n        QHostInfo::lookupHost(proxy.hostName(),\r\n                              this, SLOT(inetProxyHostLookupDone(QHostInfo)));\r\n        updateEtag(gwConfigEtag);\r\n\r\n        if (gwAnnounceInterval > 0)\r\n        {\r\n            QTimer::singleShot(5000, this, SLOT(internetDiscoveryTimerFired()));\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "name": "electrical_measurement.cpp",
          "type": "blob",
          "size": 14.6845703125,
          "content": "#include <math.h>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"device.h\"\n#include \"device_descriptions.h\"\n\n#define ACTIVE_POWER                            0x050B\n#define RMS_VOLTAGE                             0x0505\n#define RMS_CURRENT                             0x0508\n#define APPARENT_POWER                          0x050F\n\n/*! Handle packets related to the ZCL electrical measurement cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the electrical measurement cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleElectricalMeasurementClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAPower\"));\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No power sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const auto modelId = sensor->modelId();\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            ResourceItem *item = nullptr;\n\n            switch (attrId)\n            {\n            case ACTIVE_POWER:\n            {\n                qint16 power = attr.numericValue().s16;\n                item = sensor->item(RStatePower);\n\n                if (item && power != -32768)\n                {\n                    if (modelId == QLatin1String(\"SmartPlug\") ||                              // Heiman\n                        modelId.startsWith(QLatin1String(\"SKHMP30\")) ||                       // GS smart plug\n                        modelId.startsWith(QLatin1String(\"ROB_200\")) ||                       // ROBB Smarrt micro dimmer\n                        modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")) ||            // Sunricher Micro Smart Dimmer\n                        modelId == QLatin1String(\"RICI01\") ||                                 // LifeControl Smart Plug\n                        modelId.startsWith(QLatin1String(\"outlet\")) ||                        // Samsung SmartThings IM6001-OTP/IM6001-OTP01\n                        modelId == QLatin1String(\"3200-Sgb\") ||                               // Samsung/Centralite smart outlet\n                        modelId == QLatin1String(\"3200-de\") ||                                // Samsung/Centralite smart outlet\n                        modelId.startsWith(QLatin1String(\"lumi.switch.n0agl1\")) ||            // Xiaomi Aqara Single Switch Module T1 (With Neutral)\n                        modelId.startsWith(QLatin1String(\"lumi.switch.b1naus01\")))            // Xiaomi ZB3.0 Smart Wall Switch\n                    {\n                        power = static_cast<qint16>(round((double)power / 10.0)); // 0.1W -> W\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != -32768) { Item.val = Math.round(Attr.val / 10); } \");\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"Plug\")) && sensor->manufacturer() == QLatin1String(\"OSRAM\")) // OSRAM\n                    {\n                        power = power == 28000 ? 0 : power / 10;\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != -32768) { Item.val = Attr.val == 28000 ? 0: Attr.val / 10; } \");\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"SZ-ESW01\")))                   // Sercomm / Telstra smart plug\n                    {\n                        power = static_cast<qint16>(round(((double)power * 128) / 1000.0));\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != -32768) { Item.val = Math.round(Attr.val * 128 / 1000); } \");\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"lumi.relay.c2acn\")))           // Xiaomi relay\n                    {\n                        continue;   // Device seems to always report -1 via this cluster/attribute\n                    }\n                    else\n                    {\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != -32768) { Item.val = Attr.val; } \");\n                    }\n\n                    if (!item->lastSet().isValid() || item->toNumber() != power)\n                    {\n                        item->setValue(power); // in W\n                        enqueueEvent(Event(RSensors, RStatePower, sensor->id(), item));\n                    }\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), ELECTRICAL_MEASUREMENT_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            case RMS_VOLTAGE:\n            {\n                quint16 voltage = attr.numericValue().u16;\n                item = sensor->item(RStateVoltage);\n\n                if (item && voltage != 65535)\n                {\n                    if (modelId == QLatin1String(\"SmartPlug\") ||                                       // Heiman\n                        modelId.startsWith(QLatin1String(\"SMRZB-3\")) ||                                // Develco smart relay\n                        modelId.startsWith(QLatin1String(\"SMRZB-1\")) ||                                // Develco smart cable\n                        modelId.startsWith(QLatin1String(\"SKHMP30\")) ||                                // GS smart plug\n                        modelId == QLatin1String(\"Smart16ARelay51AU\") ||                               // Aurora (Develco) smart plug\n                        modelId == QLatin1String(\"PoP\"))                                               // Apex Smart Plug\n                    {\n                        voltage = static_cast<quint16>(round((double)voltage / 100.0)); // 0.01V -> V\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Math.round(Attr.val / 100); } \");\n                    }\n                    else if (modelId == QLatin1String(\"RICI01\") ||                                     // LifeControl Smart Plug\n                             modelId.startsWith(QLatin1String(\"outlet\")) ||                            // Samsung SmartThings IM6001-OTP/IM6001-OTP01\n                             modelId.startsWith(QLatin1String(\"ROB_200\")) ||                           // ROBB Smarrt micro dimmer\n                             modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")))                  // Sunricher Micro Smart Dimmer\n                    {\n                        voltage = static_cast<quint16>(round((double)voltage / 10.0)); // 0.1V -> V\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Math.round(Attr.val / 10); } \");\n                    }\n                    else if (modelId.startsWith(QLatin1String(\"SZ-ESW01\")))                            // Sercomm / Telstra smart plug\n                    {\n                        voltage = static_cast<quint16>(round((double)voltage / 125.0)); // -> V\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Math.round(Attr.val / 125); } \");\n                    }\n                    else\n                    {\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Attr.val; } \");\n                    }\n\n                    if (!item->lastSet().isValid() || item->toNumber() != voltage)\n                    {\n                        item->setValue(voltage); // in V\n                        enqueueEvent(Event(RSensors, RStateVoltage, sensor->id(), item));\n                    }\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), ELECTRICAL_MEASUREMENT_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            case RMS_CURRENT:\n            {\n                quint16 current = attr.numericValue().u16;\n                item = sensor->item(RStateCurrent);\n\n                if (item && current != 65535)\n                {\n                    if (modelId.startsWith(QLatin1String(\"outlet\")) ||                            // Samsung SmartThings IM6001-OTP/IM6001-OTP01\n                        modelId == QLatin1String(\"DoubleSocket50AU\") ||                           // Aurora\n                        modelId == QLatin1String(\"Smart16ARelay51AU\") ||                          // Aurora (Develco) smart plug\n                        modelId == QLatin1String(\"RICI01\") ||                                     // LifeControl Smart Plug\n                        modelId.startsWith(QLatin1String(\"SZ-ESW01\")) ||                          // Sercomm / Telstra smart plug\n                        modelId == QLatin1String(\"TS0121\") ||                                     // Tuya smart plug\n                        modelId.startsWith(QLatin1String(\"ROB_200\")) ||                           // ROBB Smarrt micro dimmer\n                        modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")) ||                // Sunricher Micro Smart Dimmer\n                        modelId == QLatin1String(\"SMRZB-1\") ||                                    // Develco smart cable\n                        modelId == QLatin1String(\"PoP\") ||                                        // Apex Smart Plug\n                        modelId == QLatin1String(\"TS011F\"))                                       // Tuya plugs\n                    {\n                        // already in mA\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Attr.val; } \");\n                    }\n                    else if (modelId == QLatin1String(\"SmartPlug\") ||                             // Heiman\n                             modelId.startsWith(QLatin1String(\"EMIZB-1\")) ||                      // Develco EMI\n                             modelId.startsWith(QLatin1String(\"SKHMP30\")) ||                      // GS smart plug\n                             modelId == QLatin1String(\"3200-Sgb\") ||                              // Samsung smart outlet\n                             modelId == QLatin1String(\"3200-de\") ||                               // Samsung smart outlet\n                             modelId.startsWith(QLatin1String(\"SPW35Z\")) ||                       // RT-RK OBLO SPW35ZD0 smart plug\n                             modelId == QLatin1String(\"TH1300ZB\"))                                // Sinope thermostat\n                    {\n                        current *= 10; // 0.01A -> mA\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Attr.val * 10; } \");\n                    }\n                    else\n                    {\n                        current *= 1000; // A -> mA\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Attr.val * 1000; } \");\n                    }\n\n                    if (!item->lastSet().isValid() || item->toNumber() != current)\n                    {\n                        item->setValue(current); // in mA\n                        enqueueEvent(Event(RSensors, RStateCurrent, sensor->id(), item));\n                    }\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), ELECTRICAL_MEASUREMENT_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            case APPARENT_POWER:\n            {\n                quint16 power = attr.numericValue().u16;\n                item = sensor->item(RStatePower);\n\n                if (item && power != 65535)\n                {\n                    if (modelId == QLatin1String(\"TH1300ZB\")) // Sinope thermostat\n                    {\n                        power = static_cast<quint16>(round((double)power / 1000.0)); // -> W\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Math.round(Attr.val / 1000); } \");\n                    }\n                    else\n                    {\n                        DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"if (Attr.val != 65535) { Item.val = Attr.val; } \");\n                    }\n\n                    if (!item->lastSet().isValid() || item->toNumber() != power)\n                    {\n                        item->setValue(power); // in W\n                        enqueueEvent(Event(RSensors, RStatePower, sensor->id(), item));\n                    }\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), ELECTRICAL_MEASUREMENT_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n}\n"
        },
        {
          "name": "event.cpp",
          "type": "blob",
          "size": 3.208984375,
          "content": "#include <array>\n#include \"event.h\"\n#include \"resource.h\"\n\nconstexpr const int MaxEventDataBuffers = 64;\nconstexpr const int MaxEventDataSize = 256;\n\nstruct EventData\n{\n    quint16 id;\n    quint8 data[MaxEventDataSize];\n};\n\n\nstatic size_t _eventDataIter = 0;\nstatic EventData _eventData[MaxEventDataBuffers];\n\n\nquint16 allocDataBuffer()\n{\n    _eventDataIter = (_eventDataIter + 1) % MaxEventDataBuffers;\n    _eventData[_eventDataIter].id++;\n    return int(_eventDataIter);\n}\n\n#ifdef DECONZ_DEBUG_BUILD\n/*! Verify that ZCL packing functions work as expected\n    TODO(mpi) move to separate testing code.\n*/\nvoid EventTestZclPacking()\n{\n    uint clusterId = 0xf123;\n    uint status = 0x83;\n    uint seqno = 24;\n    Event e(RDevices, REventZclResponse, EventZclResponsePack(clusterId, seqno, status), 0x11111);\n\n    Q_ASSERT(EventZclClusterId(e) == clusterId);\n    Q_ASSERT(EventZclSequenceNumber(e) == seqno);\n    Q_ASSERT(EventZclStatus(e) == status);\n}\n#endif\n\n/*! Constructor.\n */\nEvent::Event()\n{\n    m_num = 0;\n    m_numPrev = 0;\n    m_hasData = 0;\n    m_urgent = 0;\n}\n\nEvent::Event(const char *resource, const char *what, const QString &id, ResourceItem *item, DeviceKey deviceKey) :\n    m_resource(resource),\n    m_what(what),\n    m_id(id),\n    m_num(0),\n    m_numPrev(0),\n    m_deviceKey(deviceKey),\n    m_hasData(0),\n    m_urgent(0)\n{\n    DBG_Assert(item != 0);\n    if (item)\n    {\n        m_num = item->toNumber();\n        m_numPrev = item->toNumberPrevious();\n    }\n}\n\n/*! Constructor.\n */\nEvent::Event(const char *resource, const char *what, const QString &id, DeviceKey deviceKey) :\n    m_resource(resource),\n    m_what(what),\n    m_id(id),\n    m_num(0),\n    m_numPrev(0),\n    m_deviceKey(deviceKey),\n    m_hasData(0),\n    m_urgent(0)\n{\n\n}\n\n/*! Constructor.\n */\nEvent::Event(const char *resource, const char *what, const QString &id, int num, DeviceKey deviceKey) :\n    m_resource(resource),\n    m_what(what),\n    m_id(id),\n    m_num(num),\n    m_numPrev(0),\n    m_deviceKey(deviceKey),\n    m_hasData(0),\n    m_urgent(0)\n{\n\n}\n\n/*! Constructor.\n */\nEvent::Event(const char *resource, const char *what, int num, DeviceKey deviceKey) :\n    m_resource(resource),\n    m_what(what),\n    m_num(num),\n    m_numPrev(0),\n    m_deviceKey(deviceKey),\n    m_hasData(0),\n    m_urgent(0)\n{\n    if (resource == RGroups)\n    {\n        m_id = QString::number(num);\n    }\n}\n\nEvent::Event(const char *resource, const char *what, const void *data, size_t size, DeviceKey deviceKey) :\n    m_resource(resource),\n    m_what(what),\n    m_deviceKey(deviceKey),\n    m_hasData(1),\n    m_urgent(0)\n{\n    Q_ASSERT(data);\n    Q_ASSERT(size > 0 && size <= MaxEventDataSize);\n    m_num = 0;\n    m_numPrev = 0;\n    m_dataIndex = allocDataBuffer();\n    m_dataId = _eventData[m_dataIndex].id;\n    m_dataSize = size;\n    memcpy(_eventData[m_dataIndex].data, data, size);\n}\n\nbool Event::hasData() const\n{\n    if (m_hasData != 1) { return false; }\n    if (m_dataIndex >= MaxEventDataSize) { return false; }\n    if (m_dataId != _eventData[m_dataIndex].id) { return false; }\n\n    return true;\n}\n\nbool Event::getData(void *dst, size_t size) const\n{\n    if (size == m_dataSize && hasData())\n    {\n        memcpy(dst, _eventData[m_dataIndex].data, size);\n        return true;\n    }\n\n    Q_ASSERT(0);\n\n    return false;\n}\n"
        },
        {
          "name": "event.h",
          "type": "blob",
          "size": 4.423828125,
          "content": "#ifndef EVENT_H\n#define EVENT_H\n\n#include <QString>\n#include \"device.h\"\n\nclass Resource;\nclass ResourceItem;\n\nstruct EventData;\n\nclass Event\n{\npublic:\n    Event();\n    Event(const char *resource, const char *what, const QString &id, ResourceItem *item, DeviceKey deviceKey = 0);\n    Event(const char *resource, const char *what, const QString &id, DeviceKey deviceKey);\n    Event(const char *resource, const char *what, const QString &id, int num = 0, DeviceKey deviceKey = 0);\n    Event(const char *resource, const char *what, int num, DeviceKey deviceKey = 0);\n    //! Don't call following ctor directly use EventWithData() factory function.\n    Event(const char *resource, const char *what, const void *data, size_t size, DeviceKey deviceKey = 0);\n\n    const char *resource() const { return m_resource; }\n    const char *what() const { return m_what; }\n    const QString &id() const { return m_id; }\n    int num() const { return m_num; }\n    int numPrevious() const { return m_numPrev; }\n    DeviceKey deviceKey() const { return m_deviceKey; }\n    void setDeviceKey(DeviceKey key) { m_deviceKey = key; }\n    bool hasData() const;\n    quint16 dataSize() const { return m_dataSize; }\n    bool getData(void *dst, size_t size) const;\n    bool isUrgent() const { return m_urgent == 1; }\n    void setUrgent(bool urgent) { m_urgent = urgent ? 1 : 0; }\n\nprivate:\n    const char *m_resource = nullptr;\n    const char *m_what = nullptr;\n    QString m_id;\n    union\n    {\n        struct\n        {\n            int m_num;\n            int m_numPrev;\n        };\n\n        struct\n        {\n            quint16 m_dataIndex;\n            quint16 m_dataId;\n            quint16 m_dataSize;\n        };\n    };\n    DeviceKey m_deviceKey = 0;\n    struct\n    {\n        unsigned char m_hasData : 1;\n        unsigned char m_urgent : 1;\n        unsigned char _pad : 6;\n    };\n};\n\ntemplate <typename D>\nEvent EventWithData(const char *resource, const char *what, const D &data, DeviceKey deviceKey)\n{\n    static_assert (std::is_trivially_copyable<D>::value, \"data needs to be trivially copyable\");\n    return Event(resource, what, &data, sizeof(data), deviceKey);\n}\n\ninline Event EventWithData(const char *resource, const char *what, const void *data, size_t size, DeviceKey deviceKey)\n{\n    return Event(resource, what, data, size, deviceKey);\n}\n\n//! Unpacks APS confirm id.\ninline quint8 EventApsConfirmId(const Event &event)\n{\n    return event.num() >> 8 & 0xFF;\n}\n\n//! Unpacks APS confirm status.\ninline quint8 EventApsConfirmStatus(const Event &event)\n{\n    return event.num() & 0xFF;\n}\n\n//! Packs APS id and confirm status into an \\c int used as `num` parameter for REventApsConfirm.\ninline int EventApsConfirmPack(quint8 id, quint8 status)\n{\n    return id << 8 | status;\n}\n\n//! Unpacks ZDP sequence number.\ninline quint8 EventZdpResponseSequenceNumber(const Event &event)\n{\n    return event.num() >> 8 & 0xFF;\n}\n\n//! Unpacks ZDP sequence number.\ninline quint8 EventZdpResponseStatus(const Event &event)\n{\n    return event.num() & 0xFF;\n}\n\n//! Packs APS id and confirm status into an \\c int used as `num` parameter for REventApsConfirm.\ninline int EventZdpResponsePack(quint8 seq, quint8 status)\n{\n    return seq << 8 | status;\n}\n\n//! Unpacks ZCL ClusterID.\ninline unsigned EventZclClusterId(const Event &event)\n{\n    uint32_t n = static_cast<uint32_t>(event.num());\n    return (n >> 16) & 0xFFFF;\n}\n\n//! Unpacks ZCL sequence number.\ninline quint8 EventZclSequenceNumber(const Event &event)\n{\n    return (event.num() >> 8) & 0xFF;\n}\n\n//! Unpacks ZCL command status.\ninline quint8 EventZclStatus(const Event &event)\n{\n    return event.num() & 0xFF;\n}\n\n//! Packs cluster ID, ZCL sequence number and command status into an \\c int used as `num` parameter for REventZclResponse.\ninline int EventZclResponsePack(uint16_t clusterId, uint8_t seq, uint8_t status)\n{\n    uint32_t n;\n\n    n = clusterId;\n    n <<= 8;\n    n |= seq;\n    n <<= 8;\n    n |= status;\n\n    return static_cast<int>(n);\n}\n\n#ifdef DECONZ_DEBUG_BUILD\nvoid EventTestZclPacking();\n#endif\n\n//! Packs timer into an \\c int used as `num` parameter for REventStartTimer and REventStopTimer.\ninline int EventTimerPack(int timerId, int timeoutMs)\n{\n    Q_ASSERT(timerId <= 0xFF);\n    Q_ASSERT(timeoutMs <= 0xFFFFFF);\n    return timerId << 24 | timeoutMs;\n}\n\n//! Unpacks timer id.\ninline int EventTimerId(const Event &event)\n{\n    return (event.num() >> 24) & 0xFF;\n}\n\n//! Unpacks timer timout.\ninline int EventTimerTimout(const Event &event)\n{\n    return event.num() & 0xFFFFFF;\n}\n\n#endif // EVENT_H\n"
        },
        {
          "name": "event_emitter.cpp",
          "type": "blob",
          "size": 3.8310546875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QTimer>\n#include <QElapsedTimer>\n#include \"event_emitter.h\"\n#include \"rest_node_base.h\"\n#include \"de_web_plugin_private.h\"\n\nstatic EventEmitter *instance_ = nullptr;\n\nstatic bool isDuplicate(size_t pos, const std::vector<Event> &queue, const Event &e)\n{\n    for (size_t i = pos; i < queue.size(); i++)\n    {\n        const Event &x = queue[i];\n\n        if (e.deviceKey() != x.deviceKey()) {continue;}\n        if (e.resource() != x.resource()) continue;\n        if (e.what() != x.what()) continue;\n        if (e.num() != x.num()) continue;\n        if (e.id() != x.id()) continue;\n        if (e.hasData() != x.hasData()) continue;\n        if (e.hasData() && e.dataSize() != x.dataSize()) continue;\n\n        return true;\n    }\n\n    return false;\n}\n\nEventEmitter::EventEmitter(QObject *parent) :\n    QObject(parent)\n{\n    m_queue.reserve(64);\n\n    m_timer = new QTimer(this);\n    m_timer->setSingleShot(true);\n    m_timer->setInterval(0);\n    connect(m_timer, &QTimer::timeout, this, &EventEmitter::timerFired);\n\n    Q_ASSERT(instance_ == nullptr);\n    instance_ = this;\n}\n\nvoid EventEmitter::enqueueEvent(const Event &event)\n{\n    RestNodeBase *restNode = nullptr;\n\n    // workaround to attach DeviceKey to an event\n    // TODO DDF remove dependency on plugin\n    if (event.deviceKey() == 0 && (event.resource() == RSensors || event.resource() == RLights))\n    {\n        if (event.resource() == RSensors)\n        {\n            restNode = plugin->getSensorNodeForId(event.id());\n            if (!restNode)\n            {\n                restNode = plugin->getSensorNodeForUniqueId(event.id());\n            }\n        }\n        else if (event.resource() == RLights)\n        {\n            restNode = plugin->getLightNodeForId(event.id());\n        }\n    }\n\n    if (event.isUrgent())\n    {\n        m_urgentQueue.push_back(event);\n    }\n    else\n    {\n        if (restNode && restNode->address().ext() > 0)\n        {\n            Event e2 = event;\n            e2.setDeviceKey(restNode->address().ext());\n            if (!isDuplicate(m_pos, m_queue, e2))\n            {\n                m_queue.push_back(e2);\n            }\n        }\n        else if (!isDuplicate(m_pos, m_queue, event))\n        {\n            m_queue.push_back(event);\n        }\n    }\n\n    if (!m_timer->isActive())\n    {\n        m_timer->start();\n    }\n}\n\nEventEmitter::~EventEmitter()\n{\n    instance_ = nullptr;\n}\n\nvoid EventEmitter::process()\n{\n    QElapsedTimer t;\n    t.start();\n\n    while (t.elapsed() < 10 && (m_urgentQueue.size() || m_queue.size()))\n    {\n        size_t i = 0;\n        while (i < m_urgentQueue.size())\n        {\n            // create a copy of the event, m_queue can be realloced during processing\n            // which would invalidate the event reference\n            const Event ev = m_urgentQueue[i];\n            emit eventNotify(ev);\n            i++;\n\n            if (i == m_urgentQueue.size())\n            {\n                m_urgentQueue.clear();\n                break;\n            }\n        }\n\n        DBG_Assert(m_urgentQueue.empty());\n        if (m_pos < m_queue.size())\n        {\n            m_pos++;\n            const Event ev = m_queue[m_pos - 1];\n            emit eventNotify(ev);\n            if (m_pos == m_queue.size())\n            {\n                m_queue.clear();\n                m_pos = 0;\n            }\n        }\n    }\n}\n\nvoid EventEmitter::timerFired()\n{\n    process();\n\n    if (!m_queue.empty() && !m_timer->isActive())\n    {\n        m_timer->start();\n    }\n}\n\n/*! Puts an event into the queue.\n    \\param event - the event\n */\nvoid enqueueEvent(const Event &event)\n{\n    if (instance_)\n    {\n        instance_->enqueueEvent(event);\n    }\n}\n"
        },
        {
          "name": "event_emitter.h",
          "type": "blob",
          "size": 0.865234375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef EVENT_EMITTER_H\n#define EVENT_EMITTER_H\n\n#include <QObject>\n#include <vector>\n#include \"event.h\"\n\nclass QTimer;\n\nvoid enqueueEvent(const Event &event);\n\nclass EventEmitter : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit EventEmitter(QObject *parent = nullptr);\n    ~EventEmitter();\n\npublic Q_SLOTS:\n    void process();\n    void enqueueEvent(const Event &event);\n    void timerFired();\n\nQ_SIGNALS:\n    void eventNotify(const Event&);\n\nprivate:\n    size_t m_pos = 0;\n    QTimer *m_timer = nullptr;\n    std::vector<Event> m_queue;\n    std::vector<Event> m_urgentQueue;\n};\n\n#endif // EVENT_EMITTER_H\n"
        },
        {
          "name": "event_queue.cpp",
          "type": "blob",
          "size": 1.3076171875,
          "content": "#include \"alarm_system_event_handler.h\"\n#include \"de_web_plugin_private.h\"\n#include \"ui/device_widget.h\"\n\n/*! Handles one event and fires again if more are in the queue.\n */\nvoid DeRestPluginPrivate::handleEvent(const Event &e)\n{\n    if (e.resource() == RSensors)\n    {\n        handleSensorEvent(e);\n        AS_HandleAlarmSystemDeviceEvent(e, alarmSystemDeviceTable.get(), eventEmitter);\n    }\n    else if (e.resource() == RLights)\n    {\n        handleLightEvent(e);\n        AS_HandleAlarmSystemDeviceEvent(e, alarmSystemDeviceTable.get(), eventEmitter);\n    }\n    else if (e.resource() == RGroups)\n    {\n        handleGroupEvent(e);\n    }\n    else if (e.resource() == RAlarmSystems || e.what() == REventDeviceAlarm)\n    {\n        if (alarmSystems)\n        {\n            AS_HandleAlarmSystemEvent(e, *alarmSystems, eventEmitter, webSocketServer);\n        }\n    }\n    else if (e.resource() == RConfig)\n    {\n        if (deviceWidget)\n        {\n            deviceWidget->handleEvent(e);\n        }\n    }\n    else if (e.resource() == RDevices && e.what() == REventDDFInitResponse)\n    {\n        needRuleCheck = RULE_CHECK_DELAY;\n    }\n\n    if (e.deviceKey() != 0)\n    {\n        auto *device = DEV_GetDevice(m_devices, e.deviceKey());\n        if (device)\n        {\n            device->handleEvent(e);\n        }\n    }\n\n    handleRuleEvent(e);\n}\n"
        },
        {
          "name": "fan_control.cpp",
          "type": "blob",
          "size": 6.5166015625,
          "content": "#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"fan_control.h\"\n\nconst std::array<KeyValMap, 7> RConfigFanModeValues = { { {QLatin1String(\"off\"), 0}, {QLatin1String(\"low\"), 1}, {QLatin1String(\"medium\"), 2}, {QLatin1String(\"high\"), 3},\n                                                                 {QLatin1String(\"on\"), 4}, {QLatin1String(\"auto\"), 5}, {QLatin1String(\"smart\"), 6}} };\n\n/*! Handle packets related to the ZCL Fan control cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Thermostat cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleFanControlClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAThermostat\"));\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No thermostat sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    // Currently only intended for thermostats. Might change later...\n    if (sensor->type() != QLatin1String(\"ZHAThermostat\"))\n    {\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            ResourceItem *item = nullptr;\n\n            switch (attrId)\n            {\n            case FAN_CTRL_ATTRID_FAN_MODE:\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"3157100\")) ||   // Centralite pearl\n                    sensor->modelId() == QLatin1String(\"Zen-01\"))      // Zen\n                {\n                    qint8 mode = attr.numericValue().u8;\n                    QString modeSet;\n\n                    modeSet = QLatin1String(\"off\");\n                    if ( mode == 0x00 ) { modeSet = QLatin1String(\"off\"); }\n                    if ( mode == 0x01 ) { modeSet = QLatin1String(\"low\"); }\n                    if ( mode == 0x02 ) { modeSet = QLatin1String(\"medium\"); }\n                    if ( mode == 0x03 ) { modeSet = QLatin1String(\"high\"); }\n                    if ( mode == 0x04 ) { modeSet = QLatin1String(\"on\"); }\n                    if ( mode == 0x05 ) { modeSet = QLatin1String(\"auto\"); }\n                    if ( mode == 0x06 ) { modeSet = QLatin1String(\"smart\"); }\n\n                    item = sensor->item(RConfigFanMode);\n                    if (item && !item->toString().isEmpty() && item->toString() != modeSet)\n                    {\n                        item->setValue(modeSet);\n                        enqueueEvent(Event(RSensors, RConfigFanMode, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), FAN_CONTROL_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n}\n\n/*! Write Attribute on fan control cluster.\n   \\param task - the task item\n   \\param attrId\n   \\param attrType\n   \\param attrValue\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskFanControlReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode)\n{\n    if (readOrWriteCmd != deCONZ::ZclReadAttributesId && readOrWriteCmd != deCONZ::ZclWriteAttributesId)\n    {\n        DBG_Printf(DBG_INFO, \"Thermostat invalid parameter readOrWriteCmd %d\\n\", readOrWriteCmd);\n        return false;\n    }\n\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(FAN_CONTROL_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(readOrWriteCmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n            deCONZ::ZclFCDirectionClientToServer |\n            deCONZ::ZclFCDisableDefaultResponse);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (readOrWriteCmd == deCONZ::ZclWriteAttributesId)\n    {\n        stream << attrId;\n        stream << attrType;\n\n        deCONZ::ZclAttribute attr(attrId, attrType, QLatin1String(\"\"), deCONZ::ZclWrite, true);\n        attr.setValue(QVariant(attrValue));\n\n        if (!attr.writeToStream(stream))\n        {\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "fan_control.h",
          "type": "blob",
          "size": 0.2021484375,
          "content": "#ifndef FAN_CONTROL_H\n#define FAN_CONTROL_H\n\n#include \"utils/utils.h\"\n\n#define FAN_CTRL_ATTRID_FAN_MODE           0x0000\n\nextern const std::array<KeyValMap, 7> RConfigFanModeValues;\n\n#endif // FAN_CONTROL_H\n"
        },
        {
          "name": "firmware_update.cpp",
          "type": "blob",
          "size": 19.880859375,
          "content": "/*\n * Copyright (c) 2016-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QApplication>\n#include <QDesktopServices>\n#include <QProcessEnvironment>\n#include <QFile>\n#include <QDir>\n#include <QString>\n#include <QProcess>\n#ifdef Q_OS_LINUX\n#include <unistd.h>\n#endif\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n#define FW_IDLE_TIMEOUT (10 * 1000)\n#define FW_WAIT_UPDATE_READY (2) //s\n#define FW_IDLE_TIMEOUT_LONG (240 * 1000)\n#define FW_WAIT_USER_TIMEOUT (120 * 1000)\n\n/*! Inits the firmware update manager.\n */\nvoid DeRestPluginPrivate::initFirmwareUpdate()\n{\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    fwProcess = nullptr;\n    fwUpdateState = FW_Idle;\n\n    apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateIdle);\n\n    fwUpdateStartedByUser = false;\n    fwUpdateTimer = new QTimer(this);\n    fwUpdateTimer->setSingleShot(true);\n    connect(fwUpdateTimer, SIGNAL(timeout()),\n            this, SLOT(firmwareUpdateTimerFired()));\n\n    fwUpdateTimer->start(5000);\n}\n\n/*! Starts the actual firmware update process.\n */\nvoid DeRestPluginPrivate::updateFirmware()\n{\n    if (gwFirmwareNeedUpdate)\n    {\n        gwFirmwareNeedUpdate = false;\n    }\n\n    Q_ASSERT(apsCtrl);\n    if (apsCtrl->getParameter(deCONZ::ParamFirmwareUpdateActive) == deCONZ::FirmwareUpdateIdle ||\n        apsCtrl->getParameter(deCONZ::ParamDeviceConnected) == 1)\n    {\n        DBG_Printf(DBG_INFO, \"GW firmware update conditions not met, abort\\n\");\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n        updateEtag(gwConfigEtag);\n        return;\n    }\n\n    bool needSudo = true;\n\n    if (fwDeviceName == QLatin1String(\"ConBee II\"))\n    {\n        needSudo = false;\n    }\n\n    QString bin;\n    QString gcfFlasherBin = qApp->applicationDirPath() + \"/GCFFlasher\";\n#ifdef Q_OS_WIN\n    gcfFlasherBin.append(\".exe\");\n    bin = gcfFlasherBin;\n#elif defined(Q_OS_LINUX) && !defined(ARCH_ARM) // on desktop linux\n\n    if (!needSudo || geteuid() == 0)\n    {\n        bin = QLatin1String(\"/usr/bin/GCFFlasher_internal.bin\");\n    }\n    else\n    {\n        bin = QLatin1String(\"pkexec\");\n        gcfFlasherBin = QLatin1String(\"/usr/bin/GCFFlasher_internal\");\n        fwProcessArgs.prepend(gcfFlasherBin);\n    }\n#elif defined(Q_OS_OSX)\n    // TODO\n    // /usr/bin/osascript -e 'do shell script \"make install\" with administrator privileges'\n    bin = \"sudo\";\n    fwProcessArgs.prepend(gcfFlasherBin);\n#else\n    if (!needSudo || geteuid() == 0)\n    {\n        bin = QLatin1String(\"/usr/bin/GCFFlasher_internal.bin\");\n    }\n    else  // on ARM or Raspbian assume we don't need password (todo find a better solution)\n    {\n        bin = QLatin1String(\"sudo\");\n        gcfFlasherBin = QLatin1String(\"/usr/bin/GCFFlasher_internal\");\n        fwProcessArgs.prepend(gcfFlasherBin);\n    }\n#endif\n\n    if (!fwProcess)\n    {\n        fwProcess = new QProcess(this);\n    }\n\n    fwProcessArgs << \"-t\" << \"60\" << \"-f\" << fwUpdateFile;\n\n    fwUpdateState = FW_UpdateWaitFinished;\n    updateEtag(gwConfigEtag);\n    fwUpdateTimer->start(250);\n\n    DBG_Printf(DBG_INFO, \"exec: %s %s\\n\", qPrintable(bin), qPrintable(fwProcessArgs.join(' ')));\n\n    fwProcess->start(bin, fwProcessArgs);\n}\n\n/*! Observes the firmware update process.\n */\nvoid DeRestPluginPrivate::updateFirmwareWaitFinished()\n{\n    if (fwProcess)\n    {\n        if (fwProcess->bytesAvailable())\n        {\n            QByteArray data = fwProcess->readAllStandardOutput();\n            DBG_Printf(DBG_INFO, \"%s\", qPrintable(data));\n\n            if (apsCtrl->getParameter(deCONZ::ParamFirmwareUpdateActive) != deCONZ::FirmwareUpdateRunning)\n            {\n                if (data.contains(\"flashing\"))\n                {\n                    apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateRunning);\n                }\n            }\n        }\n\n        if (fwProcess->state() == QProcess::Starting)\n        {\n            DBG_Printf(DBG_INFO, \"GW firmware update starting ..\\n\");\n        }\n        else if (fwProcess->state() == QProcess::Running)\n        {\n            DBG_Printf(DBG_INFO_L2, \"GW firmware update running ..\\n\");\n        }\n        else if (fwProcess->state() == QProcess::NotRunning)\n        {\n            if (fwProcess->exitStatus() == QProcess::NormalExit)\n            {\n                DBG_Printf(DBG_INFO, \"GW firmware update exit code %d\\n\", fwProcess->exitCode());\n            }\n            else if (fwProcess->exitStatus() == QProcess::CrashExit)\n            {\n                DBG_Printf(DBG_INFO, \"GW firmware update crashed %s\\n\", qPrintable(fwProcess->errorString()));\n            }\n\n            fwProcess->deleteLater();\n            fwProcess = nullptr;\n        }\n    }\n\n    // done\n    if (fwProcess == nullptr)\n    {\n        gwFirmwareVersion = QLatin1String(\"0x00000000\"); // force reread\n        fwUpdateStartedByUser = false;\n        gwFirmwareNeedUpdate = false;\n        updateEtag(gwConfigEtag);\n        apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateIdle);\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n        updateEtag(gwConfigEtag);\n    }\n    else // recheck\n    {\n        fwUpdateTimer->start(250);\n    }\n}\n\n/*! Starts the device disconnect so that the serial port is released.\n */\nvoid DeRestPluginPrivate::updateFirmwareDisconnectDevice()\n{\n    Q_ASSERT(apsCtrl);\n//    if (apsCtrl->getParameter(deCONZ::ParamFirmwareUpdateActive) == deCONZ::FirmwareUpdateIdle)\n//    {\n//        if (apsCtrl->getParameter(deCONZ::ParamDeviceConnected) == 1)\n//        {\n//            DBG_Printf(DBG_INFO, \"GW firmware disconnect device before update\\n\");\n//        }\n//    }\n\n    zbConfigGood = QDateTime(); // clear\n\n    if (apsCtrl->getParameter(deCONZ::ParamDeviceConnected) == 1)\n    {\n        fwUpdateTimer->start(100); // recheck\n    }\n    else\n    {\n        DBG_Printf(DBG_INFO, \"GW firmware start update (device not connected)\\n\");\n        fwUpdateState = FW_Update;\n        fwUpdateTimer->start(0);\n        updateEtag(gwConfigEtag);\n    }\n}\n\n/*! Starts the firmware update.\n */\nbool DeRestPluginPrivate::startUpdateFirmware()\n{\n    fwUpdateStartedByUser = true;\n    if (fwUpdateState == FW_WaitUserConfirm)\n    {\n        apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateRunning);\n        updateEtag(gwConfigEtag);\n        fwUpdateState = FW_DisconnectDevice;\n        fwUpdateTimer->start(100);\n        zbConfigGood = QDateTime();\n        return true;\n    }\n\n    return false;\n}\n\n/*! Delayed trigger to update the firmware.\n */\nvoid DeRestPluginPrivate::firmwareUpdateTimerFired()\n{\n    // TODO(mpi): whole firmware module needs to be rewritten for upcoming GCFFlasher4 based connectiongs\n    return; // disabled for now, causes SEGV on some setups since v2.23.x\n\n    if (otauLastBusyTimeDelta() < OTA_LOW_PRIORITY_TIME)\n    {\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n    }\n    else if (fwUpdateState == FW_Idle)\n    {\n        if (gwFirmwareNeedUpdate)\n        {\n            gwFirmwareNeedUpdate = false;\n            updateEtag(gwConfigEtag);\n        }\n\n        if (gwFirmwareVersion == QLatin1String(\"0x00000000\"))\n        {\n            uint8_t devConnected = apsCtrl->getParameter(deCONZ::ParamDeviceConnected);\n            uint32_t fwVersion = apsCtrl->getParameter(deCONZ::ParamFirmwareVersion);\n\n            if (devConnected && fwVersion)\n            {\n                gwFirmwareVersion = QString(\"0x%1\").arg(fwVersion, 8, 16, QLatin1Char('0'));\n                gwConfig[\"fwversion\"] = gwFirmwareVersion;\n                updateEtag(gwConfigEtag);\n            }\n        }\n\n        fwUpdateState = FW_CheckDevices;\n        fwUpdateTimer->start(0);\n    }\n    else if (fwUpdateState == FW_CheckDevices)\n    {\n        checkFirmwareDevices();\n    }\n    else if (fwUpdateState == FW_CheckVersion)\n    {\n        queryFirmwareVersion();\n    }\n    else if (fwUpdateState == FW_DisconnectDevice)\n    {\n        updateFirmwareDisconnectDevice();\n    }\n    else if (fwUpdateState == FW_Update)\n    {\n        updateFirmware();\n    }\n    else if (fwUpdateState == FW_UpdateWaitFinished)\n    {\n        updateFirmwareWaitFinished();\n    }\n    else if (fwUpdateState == FW_WaitUserConfirm)\n    {\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n    }\n    else\n    {\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n    }\n}\n\n/*! Lazy query of firmware version.\n    Because the device might not be connected at first optaining the\n    firmware version must be delayed.\n\n    If the firmware is older then the min required firmware for the platform\n    and a proper firmware update file exists, the API will announce that a\n    firmware update is available.\n */\nvoid DeRestPluginPrivate::queryFirmwareVersion()\n{\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    { // check for GCFFlasher binary\n        QString gcfFlasherBin = qApp->applicationDirPath() + \"/GCFFlasher\";\n#ifdef Q_OS_WIN\n        gcfFlasherBin.append(\".exe\");\n#elif defined(Q_OS_LINUX) && !defined(ARCH_ARM)\n        gcfFlasherBin = \"/usr/bin/GCFFlasher_internal\";\n#elif defined(Q_OS_OSX)\n        // TODO\n#else\n        gcfFlasherBin = \"/usr/bin/GCFFlasher_internal\";\n#endif\n\n        if (!QFile::exists(gcfFlasherBin))\n        {\n            DBG_Printf(DBG_INFO, \"GW update firmware failed, %s doesn't exist\\n\", qPrintable(gcfFlasherBin));\n            fwUpdateState = FW_Idle;\n            fwUpdateTimer->start(FW_IDLE_TIMEOUT_LONG);\n            return;\n        }\n    }\n\n    const quint8 devConnected = apsCtrl->getParameter(deCONZ::ParamDeviceConnected);\n    quint32 fwVersion = apsCtrl->getParameter(deCONZ::ParamFirmwareVersion);\n\n    if (fwUpdateFile.isEmpty() && fwVersion == 0 && idleTotalCounter > (IDLE_READ_LIMIT + 10))\n    {\n        if (fwDeviceName == QLatin1String(\"ConBee II\"))\n        {\n            fwVersion = FW_ONLY_R21_BOOTLOADER;\n        }\n    }\n\n    // does the update file exist?\n    // todo if the fwVersion is 0, make a guess on which firmware file to select based on device enumerator\n    QString fileName;\n    if (fwUpdateFile.isEmpty() && fwVersion > 0)\n    {\n        if (((fwVersion & FW_PLATFORM_MASK) == FW_PLATFORM_AVR) || fwVersion == FW_ONLY_AVR_BOOTLOADER)\n        {\n            fileName = QString(\"deCONZ_Rpi_0x%1.bin.GCF\").arg(GW_MIN_AVR_FW_VERSION, 8, 16, QLatin1Char('0'));\n        }\n        else if (((fwVersion & FW_PLATFORM_MASK) == FW_PLATFORM_R21) || fwVersion == FW_ONLY_R21_BOOTLOADER)\n        {\n            fileName = QString(\"deCONZ_ConBeeII_0x%1.bin.GCF\").arg(GW_MIN_R21_FW_VERSION, 8, 16, QLatin1Char('0'));\n        }\n\n        // search in different locations\n        std::vector<QString> paths;\n#ifdef Q_OS_LINUX\n        paths.push_back(QLatin1String(\"/usr/share/deCONZ/firmware/\"));\n#endif\n        paths.push_back(deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation) + QLatin1String(\"/firmware/\"));\n        paths.push_back(deCONZ::getStorageLocation(deCONZ::HomeLocation) + QLatin1String(\"/raspbee_firmware/\"));\n#ifdef Q_OS_OSX\n        QDir dir(qApp->applicationDirPath());\n        dir.cdUp();\n        dir.cd(\"Resources\");\n        paths.push_back(dir.path() + \"/\");\n#endif\n\n        std::vector<QString>::const_iterator i = paths.begin();\n        std::vector<QString>::const_iterator end = paths.end();\n        for (; i != end; ++i)\n        {\n            if (QFile::exists(*i + fileName))\n            {\n                fwUpdateFile = *i + fileName;\n                DBG_Printf(DBG_INFO, \"GW update firmware found: %s\\n\", qPrintable(fwUpdateFile));\n                break;\n            }\n        }\n    }\n\n    if (fwUpdateFile.isEmpty())\n    {\n        DBG_Printf(DBG_INFO_L2, \"GW update firmware not found: %s\\n\", qPrintable(fileName));\n        fwUpdateState = FW_Idle;\n        fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n        return;\n    }\n\n    Q_ASSERT(!gwFirmwareNeedUpdate);\n\n    if (devConnected == 0 || fwVersion == 0)\n    {\n        // if even after some time no firmware was detected\n        // ASSUME that a device is present and reachable but might not have firmware installed\n        if (fwDeviceName == QLatin1String(\"ConBee II\"))\n        {\n            // ignore\n            fwUpdateState = FW_Idle;\n            fwUpdateTimer->start(FW_IDLE_TIMEOUT_LONG);\n        }\n        else if (getUptime() >= FW_WAIT_UPDATE_READY && fwDeviceName == QLatin1String(\"RaspBee\"))\n        {\n            gwFirmwareVersion = QLatin1String(\"0x00000000\"); // unknown\n            gwFirmwareVersionUpdate = QString(\"0x%1\").arg(GW_MIN_AVR_FW_VERSION, 8, 16, QLatin1Char('0'));\n            gwConfig[\"fwversion\"] = gwFirmwareVersion;\n            gwFirmwareNeedUpdate = true;\n            updateEtag(gwConfigEtag);\n\n            fwUpdateState = FW_WaitUserConfirm;\n            fwUpdateTimer->start(FW_WAIT_USER_TIMEOUT);\n            apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateReadyToStart);\n\n            if (fwUpdateStartedByUser)\n            {\n                startUpdateFirmware();\n            }\n        }\n        return;\n    }\n    else if (devConnected || fwVersion == FW_ONLY_AVR_BOOTLOADER)\n    {\n        QString str = QString(\"0x%1\").arg(fwVersion, 8, 16, QLatin1Char('0'));\n\n        if (gwFirmwareVersion != str)\n        {\n            gwFirmwareVersion = str;\n            gwConfig[\"fwversion\"] = str;\n            updateEtag(gwConfigEtag);\n        }\n\n        DBG_Printf(DBG_INFO_L2, \"GW firmware version: %s\\n\", qPrintable(gwFirmwareVersion));\n\n        // if the device is detected check that the firmware version is >= min version\n        // if fwVersion is FW_ONLY_AVR_BOOTLOADER, there might be no firmware at all, but update is possible\n        if (((fwVersion & FW_PLATFORM_MASK) == FW_PLATFORM_AVR) || fwVersion == FW_ONLY_AVR_BOOTLOADER)\n        {\n            if (fwVersion < GW_MIN_AVR_FW_VERSION)\n            {\n                gwFirmwareVersionUpdate = QString(\"0x%1\").arg(GW_MIN_AVR_FW_VERSION, 8, 16, QLatin1Char('0'));\n                gwFirmwareNeedUpdate = true;\n                updateEtag(gwConfigEtag);\n\n                DBG_Printf(DBG_INFO, \"GW firmware version shall be updated to: 0x%08x\\n\", GW_MIN_AVR_FW_VERSION);\n                fwUpdateState = FW_WaitUserConfirm;\n                fwUpdateTimer->start(FW_WAIT_USER_TIMEOUT);\n                apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateReadyToStart);\n\n                bool autoUpdate = false;\n\n                // auto update factory fresh devices with too old or no firmware\n                if (fwVersion == FW_ONLY_AVR_BOOTLOADER)\n                {\n                    autoUpdate = true;\n                }\n                else if (apsCtrl->getParameter(deCONZ::ParamDeviceName) == QLatin1String(\"RaspBee\") &&\n                    !gwSdImageVersion.isEmpty() && nodes.empty() && sensors.size() < 2)\n                {\n                    autoUpdate = true;\n                }\n\n                if (autoUpdate && fwVersion <= GW_AUTO_UPDATE_AVR_FW_VERSION)\n                {\n                    DBG_Printf(DBG_INFO, \"GW firmware start auto update\\n\");\n                    startUpdateFirmware();\n                }\n\n                return;\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"GW firmware version is up to date: 0x%08x\\n\", fwVersion);\n                fwUpdateState = FW_Idle;\n                fwUpdateTimer->start(FW_IDLE_TIMEOUT_LONG);\n                return;\n            }\n        }\n\n        // adapted from above AVR handling\n        if ((fwVersion & FW_PLATFORM_MASK) == FW_PLATFORM_R21 && fwDeviceName == QLatin1String(\"ConBee II\"))\n        {\n            if (fwVersion < GW_MIN_R21_FW_VERSION)\n            {\n                gwFirmwareVersionUpdate = QString(\"0x%1\").arg(GW_MIN_R21_FW_VERSION, 8, 16, QLatin1Char('0'));\n                gwFirmwareNeedUpdate = true;\n                updateEtag(gwConfigEtag);\n\n                DBG_Printf(DBG_INFO, \"GW firmware version shall be updated to: 0x%08x\\n\", GW_MIN_R21_FW_VERSION);\n                fwUpdateState = FW_WaitUserConfirm;\n                fwUpdateTimer->start(FW_WAIT_USER_TIMEOUT);\n                apsCtrl->setParameter(deCONZ::ParamFirmwareUpdateActive, deCONZ::FirmwareUpdateReadyToStart);\n\n//                bool autoUpdate = false; // TODO refactor when R21 bootloader v2 arrives\n\n                // auto update factory fresh devices with too old or no firmware\n                if (gwRunMode.startsWith(QLatin1String(\"docker\")))\n                {\n                    // TODO needs to be testet\n                }\n                else if (fwVersion > FW_ONLY_R21_BOOTLOADER && fwVersion <= GW_AUTO_UPDATE_R21_FW_VERSION)\n                {\n//                    autoUpdate = true;\n                }\n\n//                if (autoUpdate && fwVersion <= GW_AUTO_UPDATE_R21_FW_VERSION)\n//                {\n//                    DBG_Printf(DBG_INFO, \"GW firmware start auto update\\n\");\n//                    startUpdateFirmware();\n//                }\n                return;\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"GW firmware version is up to date: 0x%08x\\n\", fwVersion);\n                fwUpdateState = FW_Idle;\n                fwUpdateTimer->start(FW_IDLE_TIMEOUT_LONG);\n                return;\n            }\n        }\n\n        if (!gwFirmwareVersionUpdate.isEmpty())\n        {\n            gwFirmwareVersionUpdate.clear();\n            updateEtag(gwConfigEtag);\n        }\n    }\n\n    fwUpdateState = FW_Idle;\n    fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n}\n\n/*! Checks if devices for firmware update are present.\n */\nvoid DeRestPluginPrivate::checkFirmwareDevices()\n{\n    fwProcessArgs.clear();\n\n    const quint8 devConnected = apsCtrl->getParameter(deCONZ::ParamDeviceConnected);\n    deCONZ::DeviceEnumerator *devEnumerator = deCONZ::DeviceEnumerator::instance();\n\n    if (devConnected == 0)\n    {\n        devEnumerator->listSerialPorts();\n    }\n\n    const std::vector<deCONZ::DeviceEntry> &availPorts = devEnumerator->getList();\n\n    auto i = availPorts.cbegin();\n    const auto end = availPorts.cend();\n\n    int raspBeeCount = 0;\n    int usbDongleCount = 0;\n    QString ttyPath;\n    QString serialNumber;\n\n    ttyPath = apsCtrl->getParameter(deCONZ::ParamDevicePath);\n\n    for (; i != end; ++i)\n    {\n        if (i->friendlyName.contains(QLatin1String(\"ConBee\")))\n        {\n            usbDongleCount++;\n            if (ttyPath.isEmpty())\n            {\n                ttyPath = i->path;\n            }\n        }\n        else if (i->friendlyName.contains(QLatin1String(\"RaspBee\")))\n        {\n            raspBeeCount = 1;\n            if (ttyPath.isEmpty())\n            {\n                ttyPath = i->path;\n            }\n        }\n\n        if (ttyPath == i->path)\n        {\n            serialNumber = i->serialNumber;\n            fwDeviceName = i->friendlyName;\n        }\n    }\n\n    if (devConnected > 0 && !ttyPath.isEmpty())\n    {\n        if (!serialNumber.isEmpty())\n        {\n            fwProcessArgs << \"-s\" << serialNumber; // GCFFlasher >= 3.2\n        }\n        else\n        {\n            fwProcessArgs << \"-d\" << ttyPath; // GCFFlasher >= 3.x\n        }\n    }\n    else if (usbDongleCount > 1)\n    {\n        DBG_Printf(DBG_INFO_L2, \"GW firmware update too many USB devices connected, abort\\n\");\n    }\n    else if (usbDongleCount == 1)\n    {\n        DBG_Printf(DBG_INFO_L2, \"GW firmware update select USB device\\n\");\n#ifndef Q_OS_WIN // windows does append characters  to the serial number for some reason 'A' (TODO)\n        if (!serialNumber.isEmpty())\n        {\n            fwProcessArgs << \"-s\" << serialNumber;\n        }\n        else\n#endif\n        {\n            fwProcessArgs << \"-d\" << \"0\";\n        }\n    }\n    else if (raspBeeCount > 0 && usbDongleCount == 0 && !ttyPath.isEmpty())\n    {\n        DBG_Printf(DBG_INFO_L2, \"GW firmware update select %s device\\n\", qPrintable(ttyPath));\n        fwProcessArgs << \"-d\" << \"RaspBee\";\n    }\n\n    if (!fwProcessArgs.isEmpty())\n    {\n        fwUpdateState = FW_CheckVersion;\n        fwUpdateTimer->start(0);\n        return;\n    }\n\n    fwUpdateState = FW_Idle;\n    fwUpdateTimer->start(FW_IDLE_TIMEOUT);\n}\n"
        },
        {
          "name": "gateway.cpp",
          "type": "blob",
          "size": 27.91796875,
          "content": "/*\n * Copyright (c) 2013-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QBuffer>\n#include <QNetworkAccessManager>\n#include <QNetworkReply>\n#include <QTimer>\n#include <QTime>\n#include <deconz.h>\n#include \"gateway.h\"\n#include \"group.h\"\n#include \"json.h\"\n\n\n#define PHILIPS_MAC_PREFIX QLatin1String(\"001788\")\n\nenum GW_Event\n{\n    ActionProcess,\n    EventTimeout,\n    EventResponse,\n    EventCommandAdded\n};\n\nclass Command\n{\npublic:\n    quint16 groupId;\n    quint16 clusterId;\n    quint8 commandId;\n\n    union {\n        quint8 sceneId;\n        quint8 level;\n    } param;\n    quint8 mode;\n    quint16 transitionTime;\n};\n\nclass GatewayPrivate\n{\npublic:\n    void startTimer(int msec, GW_Event event);\n    void handleEvent(GW_Event event);\n    void handleEventStateOffline(GW_Event event);\n    void handleEventStateNotAuthorized(GW_Event event);\n    void handleEventStateConnected(GW_Event event);\n    void checkConfigResponse(const QByteArray &data);\n    void checkGroupsResponse(const QByteArray &data);\n    void checkAuthResponse(const QByteArray &data);\n    bool hasAuthorizedError(const QVariant &var);\n\n    DeRestPluginPrivate *parent;\n    Gateway::State state;\n    bool pairingEnabled;\n    bool needSaveDatabase;\n    QString apikey;\n    QString name;\n    QString uuid;\n    QHostAddress address;\n    quint16 port;\n    QTimer *timer;\n    GW_Event timerAction;\n    QNetworkAccessManager *manager;\n    QBuffer *reqBuffer;\n    QNetworkReply *reply;\n    int pings;\n    std::vector<Gateway::Group> groups;\n    std::vector<Gateway::CascadeGroup> cascadeGroups;\n    std::vector<Command> commands;\n};\n\nGateway::Gateway(DeRestPluginPrivate *parent) :\n    QObject(parent),\n    d_ptr(new GatewayPrivate)\n{\n    Q_D(Gateway);\n    d->parent = parent;\n    d->pings = 0;\n    d->port = 0;\n    d->state = Gateway::StateOffline;\n    d->pairingEnabled = false;\n    d->needSaveDatabase = false;\n    d->reply = nullptr;\n    d->manager = new QNetworkAccessManager(this);\n    connect(d->manager, SIGNAL(finished(QNetworkReply*)), this, SLOT(finished(QNetworkReply*)));\n    d->timer = new QTimer(this);\n    d->timer->setSingleShot(true);\n    d->reqBuffer = new QBuffer(this);\n    connect(d->timer, SIGNAL(timeout()), this, SLOT(timerFired()));\n\n    d->startTimer(5000, ActionProcess);\n}\n\nGateway::~Gateway()\n{\n    Q_ASSERT(d_ptr);\n\n    if (d_ptr)\n    {\n        delete d_ptr;\n        d_ptr = nullptr;\n    }\n}\n\nvoid Gateway::setAddress(const QHostAddress &address)\n{\n    Q_D(Gateway);\n    if (d->address != address)\n    {\n        d->address = address;\n        d->needSaveDatabase = true;\n    }\n}\n\nconst QString &Gateway::name() const\n{\n    Q_D(const Gateway);\n    return d->name;\n}\n\nvoid Gateway::setName(const QString &name)\n{\n    Q_D(Gateway);\n    if (d->name != name)\n    {\n        d->name = name;\n        d->needSaveDatabase = true;\n    }\n}\n\nconst QString &Gateway::uuid() const\n{\n    Q_D(const Gateway);\n    return d->uuid;\n}\n\nvoid Gateway::setUuid(const QString &uuid)\n{\n    Q_D(Gateway);\n    if (d->uuid != uuid)\n    {\n        d->uuid = uuid;\n        d->needSaveDatabase = true;\n    }\n}\n\nconst QHostAddress &Gateway::address() const\n{\n    Q_D(const Gateway);\n    return d->address;\n}\n\nquint16 Gateway::port() const\n{\n    Q_D(const Gateway);\n    return d->port;\n}\n\nvoid Gateway::setPort(quint16 port)\n{\n    Q_D(Gateway);\n    if (d->port != port)\n    {\n        d->port = port;\n        d->needSaveDatabase = true;\n    }\n}\n\nvoid Gateway::setApiKey(const QString &apiKey)\n{\n    Q_D(Gateway);\n    if (d->apikey != apiKey)\n    {\n        d->apikey = apiKey;\n        d->needSaveDatabase = true;\n    }\n}\n\nconst QString &Gateway::apiKey() const\n{\n    Q_D(const Gateway);\n    return d->apikey;\n}\n\nbool Gateway::pairingEnabled() const\n{\n    Q_D(const Gateway);\n    return d->pairingEnabled;\n}\n\nvoid Gateway::setPairingEnabled(bool pairingEnabled)\n{\n    Q_D(Gateway);\n    if (d->pairingEnabled != pairingEnabled)\n    {\n        d->pairingEnabled = pairingEnabled;\n        d->needSaveDatabase = true;\n    }\n}\n\nGateway::State Gateway::state() const\n{\n    Q_D(const Gateway);\n    return d->state;\n}\n\nbool Gateway::needSaveDatabase() const\n{\n    Q_D(const Gateway);\n    return d->needSaveDatabase;\n}\n\nvoid Gateway::setNeedSaveDatabase(bool save)\n{\n    Q_D(Gateway);\n    d->needSaveDatabase = save;\n}\n\nvoid Gateway::addCascadeGroup(quint16 local, quint16 remote)\n{\n    Q_D(Gateway);\n    for (size_t i = 0; i < d->cascadeGroups.size(); i++)\n    {\n        if (d->cascadeGroups[i].local == local && d->cascadeGroups[i].remote == remote)\n        {\n            // already known\n            return;\n        }\n    }\n\n    CascadeGroup cg;\n    cg.local = local;\n    cg.remote = remote;\n    d->cascadeGroups.push_back(cg);\n    d->needSaveDatabase = true;\n}\n\nvoid Gateway::removeCascadeGroup(quint16 local, quint16 remote)\n{\n    Q_D(Gateway);\n    for (size_t i = 0; i < d->cascadeGroups.size(); i++)\n    {\n        if (d->cascadeGroups[i].local == local && d->cascadeGroups[i].remote == remote)\n        {\n            d->cascadeGroups[i].local = d->cascadeGroups.back().local;\n            d->cascadeGroups[i].remote = d->cascadeGroups.back().remote;\n            d->cascadeGroups.pop_back();\n            d->needSaveDatabase = true;\n            return;\n        }\n    }\n}\n\nvoid Gateway::handleGroupCommand(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Q_D(Gateway);\n    if (d->state != StateConnected)\n    {\n        return;\n    }\n\n    if (ind.dstAddressMode() != deCONZ::ApsGroupAddress)\n    {\n        return;\n    }\n\n    for (size_t j = 0; j < d->cascadeGroups.size(); j++)\n    {\n        const CascadeGroup &cg = d->cascadeGroups[j];\n        if (cg.local == ind.dstAddress().group())\n        {\n            Command cmd;\n\n            cmd.transitionTime = 0;\n\n            // filter\n            if (ind.clusterId() == SCENE_CLUSTER_ID)\n            {\n                switch(zclFrame.commandId())\n                {\n                    case SCENE_COMMAND_RECALL_SCENE:\n                        if (zclFrame.payload().size() < 3) // sanity\n                        {\n                            continue;\n                        }\n                        // payload U16 group, U8 scene\n                        cmd.param.sceneId = zclFrame.payload().at(2);\n                        break;\n                    case SCENE_COMMAND_IKEA_MOVE_CT:\n                        cmd.mode = zclFrame.payload().at(0);\n                        cmd.transitionTime = 2540.0 / 83; // value for DimUp/Down\n                        break;\n                    case SCENE_COMMAND_IKEA_STEP_CT:\n                        // payload U8 mode\n                        cmd.mode = zclFrame.payload().at(0);\n                        cmd.param.level = 43;    // value for DimUp/Down\n                        cmd.transitionTime = 5;  // value for DimUp/Down\n                        break;\n                    case SCENE_COMMAND_IKEA_STOP_CT:\n                        break;\n                    default:\n                        continue;\n                }\n            }\n            else if (ind.clusterId() == ONOFF_CLUSTER_ID) // onoff\n            {\n                switch(zclFrame.commandId())\n                {\n                    case ONOFF_COMMAND_OFF:\n                        // Set on: false trough REST API\n                        break;\n                    case ONOFF_COMMAND_ON:\n                        // Set on: true trough REST API\n                        // Hue dimmer switch On\n                        break;\n                    case ONOFF_COMMAND_TOGGLE:\n                        // IKEA Trådfri Remote On/Off\n                        {\n                            ::Group *group = d->parent->getGroupForId(cg.local);\n                            const ResourceItem *item = group ? group->item(RStateAllOn) : nullptr;\n                            if (group && item)\n                            {\n                                cmd.param.level = item->toBool() ? 0x00 : 0x01;\n                                break;\n                            }\n                        }\n                        continue;\n                    case ONOFF_COMMAND_OFF_WITH_EFFECT:\n                        // Hue dimmer switch Off\n                        cmd.transitionTime = 4;\n                        break;\n                    case ONOFF_COMMAND_ON_WITH_TIMED_OFF:\n                        // IKEA Trådfri motion sensor\n                        break;\n                    default:\n                        continue;\n                }\n            }\n            else if (ind.clusterId() == LEVEL_CLUSTER_ID)\n            {\n                switch (zclFrame.commandId())\n                {\n                    case LEVEL_COMMAND_MOVE_TO_LEVEL:\n                        // Set bri through REST API\n                        // payload U8 level, U16 transition time\n                        cmd.param.level = zclFrame.payload().at(0);\n                        cmd.transitionTime = zclFrame.payload().at(1);\n                        break;\n                    case LEVEL_COMMAND_MOVE_WITH_ON_OFF:\n                        // IKEA Trådfri remote DimUp Hold\n                        // fall through\n                    case LEVEL_COMMAND_MOVE:\n                        // IKEA Trådfri remote DimDown Hold\n                        // payload U8 mode, U8 rate\n                        cmd.mode = zclFrame.payload().at(0);\n                        cmd.param.level = zclFrame.payload().at(1);\n                        // DBG_Printf(DBG_INFO_L2, \"GW level %u\\n\", cmd.param.level);\n                        cmd.transitionTime = 2540.0 / cmd.param.level;\n                        break;\n                    case LEVEL_COMMAND_STEP_WITH_ON_OFF:\n                        // IKEA Trådfri remote DimUp Short Release\n                        // fall through\n                    case LEVEL_COMMAND_STEP:\n                        // Hue dimmer switch DimUp, DimDown Press, Hold\n                        // IKEA Trådfri remote DimDown Short Release\n                        // payload U8 mode, U8 step size, U16 transitionTime\n                        cmd.mode = zclFrame.payload().at(0);\n                        cmd.param.level = zclFrame.payload().at(1);\n                        cmd.transitionTime = zclFrame.payload().at(2);\n                        break;\n                    case LEVEL_COMMAND_STOP_WITH_ON_OFF:\n                        // IKEA Trådfri remote DimUp Long Release\n                        // fall through\n                    case LEVEL_COMMAND_STOP:\n                        // Hue dimmer switch DimUp, DimDown Long Release\n                        // IKEA Trådfri remote DimDown Long Release\n                        break;\n                    default:\n                        continue;\n                }\n            }\n            else\n            {\n                continue;\n            }\n\n            cmd.clusterId = ind.clusterId();\n            cmd.groupId = cg.remote;\n            cmd.commandId = zclFrame.commandId();\n            d->commands.push_back(cmd);\n            d->handleEvent(EventCommandAdded);\n\n            DBG_Printf(DBG_INFO, \"GW %s forward command 0x%02X on cluster 0x%04X on group 0x%04X to remote group 0x%04X\\n\", qPrintable(d->name), zclFrame.commandId(), ind.clusterId(), cg.local, cg.remote);\n        }\n    }\n}\n\nconst std::vector<Gateway::Group> &Gateway::groups() const\n{\n    Q_D(const Gateway);\n    return d->groups;\n}\n\nconst std::vector<Gateway::CascadeGroup> &Gateway::cascadeGroups() const\n{\n    Q_D(const Gateway);\n    return d->cascadeGroups;\n}\n\nvoid Gateway::timerFired()\n{\n    Q_D(Gateway);\n    d->handleEvent(d->timerAction);\n}\n\nvoid Gateway::finished(QNetworkReply *reply)\n{\n    Q_D(Gateway);\n    if (d->reply == reply)\n    {\n        d->handleEvent(EventResponse);\n    }\n}\n\nvoid Gateway::error(QNetworkReply::NetworkError)\n{\n    Q_D(Gateway);\n    if (d->reply && sender() == d->reply)\n    {\n        d->handleEvent(EventResponse);\n    }\n}\n\n\nvoid GatewayPrivate::startTimer(int msec, GW_Event event)\n{\n    timerAction = event;\n    timer->start(msec);\n}\n\nvoid GatewayPrivate::handleEvent(GW_Event event)\n{\n    if      (state == Gateway::StateOffline)       { handleEventStateOffline(event); }\n    else if (state == Gateway::StateNotAuthorized) { handleEventStateNotAuthorized(event); }\n    else if (state == Gateway::StateConnected)     { handleEventStateConnected(event); }\n    else\n    {\n        Q_ASSERT(0);\n    }\n}\n\nvoid GatewayPrivate::handleEventStateOffline(GW_Event event)\n{\n    if (event == ActionProcess)\n    {\n        if (port == 0 || address.isNull())\n        {\n            // need parameters\n            startTimer(1000, ActionProcess);\n            return;\n        }\n\n        pings = 0;\n\n        QString url;\n        if (!apikey.isEmpty())\n        {\n            url = QString(\"http://%1:%2/api/%3/config\").arg(address.toString()).arg(port).arg(apikey);\n\n        }\n        else\n        {\n            url = QString(\"http://%1:%2/api/config\").arg(address.toString()).arg(port);\n        }\n\n        reply = manager->get(QNetworkRequest(url));\n        QObject::connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),\n                manager->parent(), SLOT(error(QNetworkReply::NetworkError)));\n\n        startTimer(2000, EventTimeout);\n    }\n    else if (event == EventResponse)\n    {\n        QNetworkReply *r = reply;\n        if (reply)\n        {\n            timer->stop();\n            reply = 0;\n            int code = r->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();\n\n            r->deleteLater();\n\n            if (code == 403)\n            {\n                state = Gateway::StateNotAuthorized;\n                if (!apikey.isEmpty())\n                {\n                    apikey.clear();\n                    needSaveDatabase = true;\n                }\n                startTimer(5000, ActionProcess);\n            }\n            else if (code == 200)\n            {\n                checkConfigResponse(r->readAll());\n                state = Gateway::StateConnected;\n                startTimer(5000, ActionProcess);\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"unhandled http status code in offline state %d\\n\", code);\n                startTimer(10000, EventTimeout);\n            }\n        }\n    }\n    else if (event == EventTimeout)\n    {\n        if (reply)\n        {\n            QNetworkReply *r = reply;\n            reply = 0;\n            if (r->isRunning())\n            {\n                r->abort();\n            }\n            r->deleteLater();\n        }\n        startTimer(10000, ActionProcess);\n    }\n}\n\nvoid GatewayPrivate::handleEventStateNotAuthorized(GW_Event event)\n{\n    if (event == ActionProcess)\n    {\n        if (!pairingEnabled)\n        {\n            startTimer(5000, ActionProcess);\n            return;\n        }\n\n        pings = 0;\n\n        // try to create user account\n        const QString url = QString(\"http://%1:%2/api/\").arg(address.toString()).arg(port);\n\n        QVariantMap map;\n        map[QLatin1String(\"devicetype\")] = QLatin1String(\"x-gw\");\n        //map[QLatin1String(\"username\")] = apikey;\n\n        QString json = Json::serialize(map);\n\n        reqBuffer->close();\n        reqBuffer->setData(json.toUtf8());\n        reqBuffer->open(QBuffer::ReadOnly);\n\n        QNetworkRequest req(url);\n        reply = manager->sendCustomRequest(req, \"POST\", reqBuffer);\n\n        QObject::connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),\n                manager->parent(), SLOT(error(QNetworkReply::NetworkError)));\n\n        startTimer(5000, EventTimeout);\n    }\n    else if (event == EventResponse)\n    {\n        QNetworkReply *r = reply;\n        if (reply)\n        {\n            timer->stop();\n            reply = 0;\n            int code = r->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();\n\n            r->deleteLater();\n\n            if (code == 403)\n            {\n                // gateway must be unlocked ...\n            }\n            else if (code == 200)\n            {\n                checkAuthResponse(r->readAll());\n                startTimer(100, ActionProcess);\n            }\n\n            // retry\n            if (!timer->isActive())\n            {\n                startTimer(10000, ActionProcess);\n            }\n        }\n    }\n    else if (event == EventTimeout)\n    {\n        state = Gateway::StateOffline;\n        startTimer(5000, ActionProcess);\n    }\n}\n\nvoid GatewayPrivate::handleEventStateConnected(GW_Event event)\n{\n    if (event == ActionProcess)\n    {\n        Q_ASSERT(reply == 0);\n\n        if (apikey.isEmpty())\n        {\n            state = Gateway::StateNotAuthorized;\n            startTimer(5000, ActionProcess);\n            return;\n        }\n\n        if (commands.empty())\n        {\n            const QString url = QString(\"http://%1:%2/api/%3/groups\").arg(address.toString()).arg(port).arg(apikey);\n\n            pings++;\n            reply = manager->get(QNetworkRequest(url));\n            QObject::connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),\n                    manager->parent(), SLOT(error(QNetworkReply::NetworkError)));\n        }\n        else\n        {\n            bool ok = false;\n            double level;\n            QString url;\n            QVariantMap map;\n            const Command &cmd = commands.back();\n\n            if (cmd.clusterId == SCENE_CLUSTER_ID)\n            {\n                switch (cmd.commandId) {\n                    case SCENE_COMMAND_RECALL_SCENE:\n                        ok = true;\n                        if (uuid.startsWith(PHILIPS_MAC_PREFIX))  // cascade gateway is Hue bridge\n                        {\n                            const QString scene = QString(\"g%1s%2\").arg(cmd.groupId).arg(cmd.param.sceneId);\n                            map[QLatin1String(\"scene\")] = scene;\n                        }\n                        else\n                        {\n                            url = QString(\"http://%1:%2/api/%3/groups/%4/scenes/%5/recall\")\n                                        .arg(address.toString()).arg(port).arg(apikey).arg(cmd.groupId).arg(cmd.param.sceneId);\n                        }\n                        break;\n                    case SCENE_COMMAND_IKEA_STEP_CT:\n                        ok = true;\n                        level = cmd.param.level * (cmd.mode == 0x00 ? 1 : -1);\n                        map[QLatin1String(\"ct_inc\")] = level;\n                        break;\n                    case SCENE_COMMAND_IKEA_MOVE_CT:\n                        ok = true;\n                        level = cmd.mode == 0x00 ? 254 : -254;\n                        map[QLatin1String(\"ct_inc\")] = level;\n                        break;\n                    case SCENE_COMMAND_IKEA_STOP_CT:\n                        ok = true;\n                        level = 0;\n                        map[QLatin1String(\"ct_inc\")] = level;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            else if (cmd.clusterId == ONOFF_CLUSTER_ID) // onoff\n            {\n                switch (cmd.commandId) {\n                    case ONOFF_COMMAND_OFF_WITH_EFFECT:\n                        // Hue dimmer switch Off\n                        // fall through\n                    case ONOFF_COMMAND_OFF:\n                        // Set on: false through REST API\n                        ok = true;\n                        map[QLatin1String(\"on\")] = false;\n                        break;\n                    case ONOFF_COMMAND_ON:\n                        // Set on: true through REST API\n                        // Hue dimmer switch On\n                        ok = true;\n                        map[QLatin1String(\"on\")] = true;\n                        break;\n                    case ONOFF_COMMAND_TOGGLE:\n                        ok = true;\n                        map[QLatin1String(\"on\")] = cmd.param.level == 0x01;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            else if (cmd.clusterId == LEVEL_CLUSTER_ID)\n            {\n                switch (cmd.commandId)\n                {\n                      case LEVEL_COMMAND_MOVE_TO_LEVEL:\n                          // Set bri through REST API\n                          ok = true;\n                          level = cmd.param.level;\n                          map[QLatin1String(\"bri\")] = level;\n                          break;\n                      case LEVEL_COMMAND_MOVE_WITH_ON_OFF:\n                          if (cmd.mode == 0x00)\n                          {\n                              map[QLatin1String(\"on\")] = true;\n                          }\n                          // fall through\n                      case LEVEL_COMMAND_MOVE:\n                          // IKEA Trådfri remote DimDown Hold\n                          ok = true;\n                          level = cmd.mode == 0x00 ? 254 : -254;\n                          map[QLatin1String(\"bri_inc\")] = level;\n                          break;\n                      case LEVEL_COMMAND_STEP_WITH_ON_OFF:\n                          // IKEA Trådfri remote DimUp Short Release\n                          if (cmd.mode == 0x00)\n                          {\n                              map[QLatin1String(\"on\")] = true;\n                          }\n                          // fall through\n                      case LEVEL_COMMAND_STEP:\n                          // Hue dimmer switch DimUp, DimDown Short Release, Hold\n                          // IKEA Trådfri remote DimDown Short Release\n                          ok = true;\n                          level = cmd.param.level * (cmd.mode == 0x00 ? 1 : -1);\n                          map[QLatin1String(\"bri_inc\")] = level;\n                          break;\n                      case LEVEL_COMMAND_STOP_WITH_ON_OFF:\n                          // IKEA Trådfri remote DimUp Long Release\n                          // fall through\n                      case LEVEL_COMMAND_STOP:\n                          // Philips Hue dimmer DimUp, DimDown Long Release\n                          // IKEA Trådfri remote DimDown Long Release\n                          ok = true;\n                          level = 0;\n                          map[QLatin1String(\"bri_inc\")] = level;\n                          break;\n                      default:\n                          break;\n                }\n            }\n\n            commands.pop_back();\n\n            if (!ok)\n            {\n                startTimer(50, EventTimeout);\n                return;\n            }\n\n            if (url.isEmpty())\n            {\n                url = QString(\"http://%1:%2/api/%3/groups/%4/action\")\n                            .arg(address.toString()).arg(port).arg(apikey).arg(cmd.groupId);\n            }\n\n            QString json;\n            if (!map.isEmpty())\n            {\n                if (cmd.transitionTime != 0)\n                {\n                    map[QLatin1String(\"transitiontime\")] = (double) cmd.transitionTime;\n                }\n                json = Json::serialize(map);\n                DBG_Printf(DBG_INFO_L2, \"GW body %s\\n\", qPrintable(json));\n            }\n            else\n            {\n                json = QLatin1String(\"{}\");\n            }\n            reqBuffer->close();\n            reqBuffer->setData(json.toUtf8());\n            reqBuffer->open(QBuffer::ReadOnly);\n\n            QNetworkRequest req(url);\n            reply = manager->put(req, reqBuffer);\n\n            QObject::connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),\n                    manager->parent(), SLOT(error(QNetworkReply::NetworkError)));\n        }\n\n        startTimer(1000, EventTimeout);\n    }\n    else if (event == EventResponse)\n    {\n        QNetworkReply *r = reply;\n        if (reply)\n        {\n            timer->stop();\n            reply = 0;\n            int code = r->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();\n\n            if (code == 200)\n            {\n                // ok check again later\n                if (r->url().toString().endsWith(QLatin1String(\"/groups\")))\n                {\n                    pings = 0;\n                    checkGroupsResponse(r->readAll());\n                }\n                startTimer(15000, ActionProcess);\n            }\n            else if (code == 403)\n            {\n                state = Gateway::StateNotAuthorized;\n                startTimer(5000, ActionProcess);\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"unhandled http status code in connected state %d switch to offline state\\n\", code);\n                state = Gateway::StateOffline;\n                startTimer(5000, ActionProcess);\n            }\n\n            r->deleteLater();\n        }\n    }\n    else if (event == EventTimeout)\n    {\n        if (reply)\n        {\n            QNetworkReply *r = reply;\n            reply = 0;\n            if (r->isRunning())\n            {\n                r->abort();\n            }\n            r->deleteLater();\n        }\n        if (pings > 5)\n        {\n            DBG_Printf(DBG_INFO, \"max request timeout in connected state switch to offline state\\n\");\n            state = Gateway::StateOffline;\n        }\n        startTimer(5000, ActionProcess);\n    }\n    else if (event == EventCommandAdded)\n    {\n        if (!reply) // not busy\n        {\n            startTimer(50, ActionProcess);\n        }\n    }\n}\n\nvoid GatewayPrivate::checkConfigResponse(const QByteArray &data)\n{\n    bool ok;\n    QVariant var = Json::parse(data, ok);\n\n    if (hasAuthorizedError(var))\n    {\n        return;\n    }\n\n    if (var.type() != QVariant::Map)\n        return;\n\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        return;\n    }\n\n    if (map.contains(QLatin1String(\"name\")))\n    {\n        name = map[QLatin1String(\"name\")].toString();\n    }\n}\n\nvoid GatewayPrivate::checkGroupsResponse(const QByteArray &data)\n{\n    bool ok;\n    QVariant var = Json::parse(data, ok);\n\n    if (hasAuthorizedError(var))\n    {\n        return;\n    }\n\n    if (var.type() != QVariant::Map)\n        return;\n\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        return;\n    }\n\n    QStringList groupIds = map.keys();\n\n    QStringList::iterator i = groupIds.begin();\n    QStringList::iterator end = groupIds.end();\n\n    if (groups.size() != (size_t)groupIds.size())\n    {\n        groups.clear();\n    }\n\n    for (size_t j = 0; i != end; ++i, j++)\n    {\n\n        QVariantMap g = map[*i].toMap();\n        QString name = g[\"name\"].toString();\n\n        if (j == groups.size())\n        {\n            Gateway::Group group;\n            group.name = name;\n            group.id = *i;\n            groups.push_back(group);\n            DBG_Printf(DBG_INFO, \"\\tgroup %s: %s\\n\", qPrintable(group.id), qPrintable(group.name));\n        }\n        else if (j < groups.size())\n        {\n            Gateway::Group &group = groups[j];\n            if (group.name != name || group.id != *i)\n            {\n                // update\n                group.name = name;\n                group.id = *i;\n                DBG_Printf(DBG_INFO, \"\\tgroup %s: %s\\n\", qPrintable(group.id), qPrintable(group.name));\n            }\n        }\n    }\n}\n\nvoid GatewayPrivate::checkAuthResponse(const QByteArray &data)\n{\n    bool ok;\n    QVariant var = Json::parse(data, ok);\n\n    if (hasAuthorizedError(var))\n    {\n        return;\n    }\n\n    if (var.type() != QVariant::List)\n    {\n        return; // unexpected\n    }\n\n    QVariantMap map = var.toList().first().toMap();\n    if (!map.contains(\"success\"))\n    {\n        return;\n    }\n\n    map = map[\"success\"].toMap();\n\n    if (map.contains(\"username\"))\n    {\n        apikey = map[\"username\"].toString();\n        needSaveDatabase = true;\n        state = Gateway::StateConnected;\n    }\n}\n\nbool GatewayPrivate::hasAuthorizedError(const QVariant &var)\n{\n    if (var.type() != QVariant::List)\n    {\n        return false;\n    }\n\n    QVariantList ls = var.toList();\n    for (const QVariant &item : ls)\n    {\n        QVariantMap map = item.toMap();\n        if (!map.contains(QLatin1String(\"error\")))\n        {\n            continue;\n        }\n\n        map = map[\"error\"].toMap();\n\n        if (map.contains(QLatin1String(\"type\")) && map[\"type\"].toInt() == ERR_UNAUTHORIZED_USER)\n        {\n            if (state == Gateway::StateConnected)\n            {\n                state = Gateway::StateNotAuthorized;\n                apikey.clear();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"
        },
        {
          "name": "gateway.h",
          "type": "blob",
          "size": 1.73046875,
          "content": "#ifndef GATEWAY_H\n#define GATEWAY_H\n\n#include <QObject>\n#include <QHostAddress>\n#include <QNetworkReply>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\nnamespace deCONZ {\n    class ApsDataIndication;\n    class ZclFrame;\n}\n\nclass GatewayPrivate;\n\nclass Gateway : public QObject\n{\n    Q_OBJECT\npublic:\n    class Group\n    {\n    public:\n        QString id;\n        QString name;\n    };\n\n    class CascadeGroup\n    {\n    public:\n        quint16 local;\n        quint16 remote;\n    };\n\n    enum State\n    {\n        StateOffline,\n        StateNotAuthorized,\n        StateConnected\n    };\n\n    explicit Gateway(DeRestPluginPrivate *parent = 0);\n    ~Gateway();\n\n    const QString &name() const;\n    void setName(const QString &name);\n    const QString &uuid() const;\n    void setUuid(const QString &uuid);\n    const QHostAddress &address() const;\n    void setAddress(const QHostAddress &address);\n    quint16 port() const;\n    void setPort(quint16 port);\n    void setApiKey(const QString &apiKey);\n    const QString &apiKey() const;\n    bool pairingEnabled() const;\n    void setPairingEnabled(bool pairingEnabled);\n    State state() const;\n    bool needSaveDatabase() const;\n    void setNeedSaveDatabase(bool save);\n    void addCascadeGroup(quint16 local, quint16 remote);\n    void removeCascadeGroup(quint16 local, quint16 remote);\n    void handleGroupCommand(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame);\n\n    const std::vector<Group> &groups() const;\n    const std::vector<CascadeGroup> &cascadeGroups() const;\n\nsignals:\n\nprivate Q_SLOTS:\n    void timerFired();\n    void finished(QNetworkReply *reply);\n    void error(QNetworkReply::NetworkError);\n\nprivate:\n    Q_DECLARE_PRIVATE(Gateway)\n    GatewayPrivate *d_ptr;\n};\n\n#endif // GATEWAY_H\n"
        },
        {
          "name": "gateway_scanner.cpp",
          "type": "blob",
          "size": 8.0498046875,
          "content": "/*\n * Copyright (c) 2016-2017 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QApplication>\n#include <QTimer>\n#include <QNetworkAccessManager>\n#include <QNetworkInterface>\n#include <QNetworkReply>\n#include <vector>\n#include \"gateway_scanner.h\"\n#include \"deconz.h\"\n#include \"json.h\"\n\nenum ScanState\n{\n    StateInit,\n    StateIdle,\n    StateRunning,\n};\n\nenum ScanEvent\n{\n    ActionProcess,\n    EventTimeout,\n    EventGotReply\n};\n\nclass GatewayScannerPrivate\n{\npublic:\n    void initScanner();\n    void handleEvent(ScanEvent event);\n    void startScanTimer(int msec, ScanEvent action);\n    void stopTimer();\n    void queryNextIp();\n    void processReply();\n\n    GatewayScanner *q;\n    ScanState state;\n    QNetworkAccessManager *manager;\n    QNetworkReply *reply;\n    QTimer *timer;\n    ScanEvent timerAction;\n    std::vector<quint32> interfaces;\n    quint32 scanIp;\n    quint16 scanPort;\n    int scanIteration;\n    quint32 host;\n    size_t interfaceIter;\n};\n\nGatewayScanner::GatewayScanner(QObject *parent) :\n    QObject(parent),\n    d_ptr(new GatewayScannerPrivate)\n{\n    Q_D(GatewayScanner);\n    d->q = this;\n    d->scanIteration = 0;\n    d->state = StateInit;\n    d->manager = new QNetworkAccessManager(this);\n    connect(d->manager, SIGNAL(finished(QNetworkReply*)), this, SLOT(requestFinished(QNetworkReply*)));\n    d->timer = new QTimer(this);\n    d->timer->setSingleShot(true);\n    connect(d->timer, SIGNAL(timeout()), this, SLOT(scanTimerFired()));\n}\n\nGatewayScanner::~GatewayScanner()\n{\n    Q_ASSERT(d_ptr != nullptr);\n    if (d_ptr)\n    {\n        delete d_ptr;\n        d_ptr = nullptr;\n    }\n}\n\nbool GatewayScanner::isRunning() const\n{\n    Q_D(const GatewayScanner);\n\n    return (d->state != StateInit);\n}\n\nvoid GatewayScanner::queryGateway(const QString &url)\n{\n    Q_D(GatewayScanner);\n\n    if (!isRunning() && d->reply == nullptr)\n    {\n        d->reply = d->manager->get(QNetworkRequest(url));\n        QObject::connect(d->reply, SIGNAL(error(QNetworkReply::NetworkError)),\n                d->manager->parent(), SLOT(onError(QNetworkReply::NetworkError)));\n    }\n}\n\nvoid GatewayScanner::startScan()\n{\n    Q_D(GatewayScanner);\n\n    // TODO fix: GLib-ERROR **: Creating pipes for GWakeup: Too many open files\n    if (d->state == StateInit)\n    {\n        d->startScanTimer(1, ActionProcess);\n    }\n}\n\nvoid GatewayScanner::scanTimerFired()\n{\n    Q_D(GatewayScanner);\n    d->handleEvent(d->timerAction);\n}\n\nvoid GatewayScanner::requestFinished(QNetworkReply *reply)\n{\n    Q_D(GatewayScanner);\n\n    if (reply == d->reply)\n    {\n        d->processReply();\n    }\n\n    if (isRunning())\n    {\n        d->handleEvent(EventGotReply);\n    }\n    reply->deleteLater();\n}\n\nvoid GatewayScannerPrivate::processReply()\n{\n    if (!reply)\n    {\n        return;\n    }\n\n    QNetworkReply *r = reply;\n    reply = nullptr;\n\n    int code = r->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();\n\n    if (code != 200) // not authorized or ok\n    {\n        return;\n    }\n\n    bool ok;\n    QVariant var = Json::parse(r->readAll(), ok);\n    if (!ok)\n    {\n        return;\n    }\n\n    QVariantMap map = var.toMap();\n    if (map.isEmpty())\n    {\n        return;\n    }\n\n    if (!map.contains(QLatin1String(\"bridgeid\")) ||\n        !map.contains(QLatin1String(\"modelid\")) ||\n        !map.contains(QLatin1String(\"name\")))\n    {\n        return;\n    }\n\n    QString name = map[\"name\"].toString();\n    //QString modelid = map[\"modelid\"].toString();\n    QString bridgeid = map[\"bridgeid\"].toString();\n\n    QUrl url = r->url();\n\n    QHostAddress host(url.host());\n    if (host.isNull() || name.isEmpty() || bridgeid.isEmpty())\n    {\n        return;\n    }\n\n    //DBG_Printf(DBG_INFO, \"GW: %s %s, %s, %s\\n\", qPrintable(url.host()), qPrintable(name), qPrintable(modelid), qPrintable(bridgeid));\n    q->foundGateway(host, static_cast<quint16>(url.port(80)), bridgeid, name);\n}\n\nvoid GatewayScanner::onError(QNetworkReply::NetworkError code)\n{\n    Q_D(GatewayScanner);\n    Q_UNUSED(code)\n\n    sender()->deleteLater();\n\n    if (!d->timer->isActive())\n    {\n        // must be in timeout window\n        return;\n    }\n\n    if (d->reply && sender() == d->reply)\n    {\n        //DBG_Printf(DBG_INFO, \"reply err: %d\\n\", code);\n        d->timer->stop();\n        d->handleEvent(EventGotReply);\n    }\n}\n\nvoid GatewayScannerPrivate::initScanner()\n{\n    QList<QNetworkInterface> ifaces = QNetworkInterface::allInterfaces();\n\n    QList<QNetworkInterface>::Iterator ifi = ifaces.begin();\n    QList<QNetworkInterface>::Iterator ifend = ifaces.end();\n\n    for (; ifi != ifend; ++ifi)\n    {\n        QString name = ifi->humanReadableName();\n\n        // filter\n        if (name.contains(\"vm\", Qt::CaseInsensitive) ||\n            name.contains(\"virtual\", Qt::CaseInsensitive) ||\n            name.contains(\"loop\", Qt::CaseInsensitive))\n        {\n            continue;\n        }\n\n        QList<QNetworkAddressEntry> addr = ifi->addressEntries();\n\n        QList<QNetworkAddressEntry>::Iterator i = addr.begin();\n        QList<QNetworkAddressEntry>::Iterator end = addr.end();\n\n        for (; i != end; ++i)\n        {\n            QHostAddress a = i->ip();\n\n            if (a.protocol() == QAbstractSocket::IPv4Protocol)\n            {\n                quint32 ipv4 = a.toIPv4Address();\n                if ((ipv4 & 0xff000000UL) == 0x7f000000UL)\n                {\n                    // 127.x.x.x\n                    continue;\n                }\n\n                if (std::find(interfaces.begin(), interfaces.end(), ipv4) == interfaces.end())\n                {\n                    interfaces.push_back(ipv4);\n                }\n            }\n        }\n    }\n\n    scanIteration++;\n    interfaceIter = 0;\n    host = 0;\n}\n\nvoid GatewayScannerPrivate::handleEvent(ScanEvent event)\n{\n    if (state == StateInit)\n    {\n        if (event == ActionProcess)\n        {\n            initScanner();\n            state = StateIdle;\n            startScanTimer(10, ActionProcess);\n        }\n        else\n        {\n            Q_ASSERT(0);\n        }\n    }\n    else if (state == StateIdle)\n    {\n        if (event == ActionProcess)\n        {\n            queryNextIp();\n        }\n        else if (event == EventTimeout)\n        {\n            QNetworkReply *r = reply;\n            if (reply)\n            {\n                reply = nullptr;\n                if (r->isRunning())\n                {\n                    r->abort();\n                }\n                r->deleteLater();\n            }\n            host++;\n            startScanTimer(1000, ActionProcess);\n        }\n        else if (event == EventGotReply)\n        {\n            host++;\n            startScanTimer(1, ActionProcess);\n        }\n        else\n        {\n            Q_ASSERT(0);\n        }\n    }\n    else\n    {\n        Q_ASSERT(0);\n    }\n}\n\nvoid GatewayScannerPrivate::startScanTimer(int msec, ScanEvent action)\n{\n    timerAction = action;\n    timer->stop();\n    timer->start(msec);\n}\n\nvoid GatewayScannerPrivate::stopTimer()\n{\n    timer->stop();\n}\n\nvoid GatewayScannerPrivate::queryNextIp()\n{\n    if (!interfaces.empty() && host > 255)\n    {\n        interfaces.pop_back();\n        host = 0;\n    }\n\n    if (interfaces.empty())\n    {\n        state = StateInit;\n        DBG_Printf(DBG_INFO, \"scan finished\\n\");\n        return;\n    }\n\n    scanIp = interfaces.back();\n    scanPort = 80;\n\n    if (host == (scanIp & 0x000000fful))\n    {\n        DBG_Printf(DBG_INFO, \"scan skip host .%u\\n\", host);\n        host++; // don't scan own ip\n    }\n\n    const QString url = QString(\"http://%1.%2.%3.%4:%5/api/config\")\n                .arg(((scanIp >> 24) & 0xff))\n                .arg(((scanIp >> 16) & 0xff))\n                .arg(((scanIp >> 8) & 0xff))\n                .arg(host & 0xff).arg(scanPort);\n\n    scanIp &= 0xffffff00ull;\n    scanIp |= host & 0xff;\n\n    //DBG_Printf(DBG_INFO, \"scan %s\\n\", qPrintable(url));\n    reply = manager->get(QNetworkRequest(url));\n    QObject::connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),\n            manager->parent(), SLOT(onError(QNetworkReply::NetworkError)));\n\n    startScanTimer(1000, EventTimeout);\n}\n"
        },
        {
          "name": "gateway_scanner.h",
          "type": "blob",
          "size": 0.7509765625,
          "content": "#ifndef GATEWAYSCANNER_H\n#define GATEWAYSCANNER_H\n\n#include <QObject>\n#include <QNetworkReply>\n#include <QHostAddress>\n\nclass GatewayScannerPrivate;\n\nclass GatewayScanner : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit GatewayScanner(QObject *parent = 0);\n    ~GatewayScanner();\n    bool isRunning() const;\n    void queryGateway(const QString &url);\n\nQ_SIGNALS:\n    void foundGateway(const QHostAddress &host, quint16 port, const QString &uuid, const QString &name);\n\npublic Q_SLOTS:\n    void startScan();\n\nprivate Q_SLOTS:\n    void scanTimerFired();\n    void requestFinished(QNetworkReply *reply);\n    void onError(QNetworkReply::NetworkError code);\n\nprivate:\n    Q_DECLARE_PRIVATE(GatewayScanner)\n    GatewayScannerPrivate *d_ptr;\n};\n\n#endif // GATEWAYSCANNER_H\n"
        },
        {
          "name": "general.xml",
          "type": "blob",
          "size": 451.5205078125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<zcl>\r\n  <datatypes>\r\n    <!--Null-->\r\n    <datatype id=\"0x00\" name=\"No data\" shortname=\"ndat\" length=\"0\" ad=\"-\"></datatype>\r\n    <!--General data -->\r\n    <datatype id=\"0x08\" name=\"8-bit data\" shortname=\"dat8\" length=\"1\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x09\" name=\"16-bit data\" shortname=\"dat16\" length=\"2\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0a\" name=\"24-bit data\" shortname=\"dat24\" length=\"3\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0b\" name=\"32-bit data\" shortname=\"dat32\" length=\"4\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0c\" name=\"40-bit data\" shortname=\"dat40\" length=\"5\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0d\" name=\"48-bit data\" shortname=\"dat48\" length=\"6\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0e\" name=\"56-bit data\" shortname=\"dat56\" length=\"7\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x0f\" name=\"64-bit data\" shortname=\"dat64\" length=\"8\" ad=\"D\"></datatype>\r\n    <!-- Logical -->\r\n    <datatype id=\"0x10\" name=\"Boolean\" shortname=\"bool\" length=\"1\" inval=\"0xff\" ad=\"D\"></datatype>\r\n    <!-- Bitmap -->\r\n    <datatype id=\"0x18\" name=\"8-bit bitmap\" shortname=\"bmp8\" length=\"1\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x19\" name=\"16-bit bitmap\" shortname=\"bmp16\" length=\"2\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1a\" name=\"24-bit bitmap\" shortname=\"bmp24\" length=\"3\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1b\" name=\"32-bit bitmap\" shortname=\"bmp32\" length=\"4\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1c\" name=\"40-bit bitmap\" shortname=\"bmp40\" length=\"5\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1d\" name=\"48-bit bitmap\" shortname=\"bmp48\" length=\"6\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1e\" name=\"56-bit bitmap\" shortname=\"bmp56\" length=\"7\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x1f\" name=\"64-bit bitmap\" shortname=\"bmp64\" length=\"8\" ad=\"D\"></datatype>\r\n    <!-- Unsigned integer -->\r\n    <datatype id=\"0x20\" name=\"Unsigned 8-bit integer\" shortname=\"u8\" length=\"1\" inval=\"0xff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x21\" name=\"Unsigned 16-bit integer\" shortname=\"u16\" length=\"2\" inval=\"0xffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x22\" name=\"Unsigned 24-bit integer\" shortname=\"u24\" length=\"3\" inval=\"0xffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x23\" name=\"Unsigned 32-bit integer\" shortname=\"u32\" length=\"4\" inval=\"0xffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x24\" name=\"Unsigned 40-bit integer\" shortname=\"u40\" length=\"5\" inval=\"0xffffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x25\" name=\"Unsigned 48-bit integer\" shortname=\"u48\" length=\"6\" inval=\"0xffffffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x26\" name=\"Unsigned 56-bit integer\" shortname=\"u56\" length=\"7\" inval=\"0xffffffffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x27\" name=\"Unsigned 64-bit integer\" shortname=\"u64\" length=\"8\" inval=\"0xffffffffffffffff\" ad=\"A\"></datatype>\r\n    <!-- Signed integer -->\r\n    <datatype id=\"0x28\" name=\"Signed 8-bit integer\" shortname=\"s8\" length=\"1\" inval=\"0x80\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x29\" name=\"Signed 16-bit integer\" shortname=\"s16\" length=\"2\" inval=\"0x8000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2a\" name=\"Signed 24-bit integer\" shortname=\"s24\" length=\"3\" inval=\"0x800000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2b\" name=\"Signed 32-bit integer\" shortname=\"s32\" length=\"4\" inval=\"0x80000000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2c\" name=\"Signed 40-bit integer\" shortname=\"s40\" length=\"5\" inval=\"0x8000000000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2d\" name=\"Signed 48-bit integer\" shortname=\"s48\" length=\"6\" inval=\"0x800000000000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2e\" name=\"Signed 56-bit integer\" shortname=\"s56\" length=\"7\" inval=\"0x80000000000000\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x2f\" name=\"Signed 64-bit integer\" shortname=\"s64\" length=\"8\" inval=\"0x8000000000000000\" ad=\"A\"></datatype>\r\n    <!-- Enumeration -->\r\n    <datatype id=\"0x30\" name=\"8-bit enumeration\" shortname=\"enum8\" length=\"1\" inval=\"0xff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x31\" name=\"16-bit enumeration\" shortname=\"enum16\" length=\"2\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <!-- Floating point -->\r\n    <datatype id=\"0x38\" name=\"Semi-precision\" shortname=\"semi\" length=\"2\" inval=\"nan\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x39\" name=\"Single precision\" shortname=\"float\" length=\"4\" inval=\"nan\" ad=\"A\"></datatype>\r\n    <datatype id=\"0x3a\" name=\"Double precision\" shortname=\"double\" length=\"8\" inval=\"nan\" ad=\"A\"></datatype>\r\n    <!-- String -->\r\n    <!-- oN, defined in first N octets -->\r\n    <datatype id=\"0x41\" name=\"Octed string\" shortname=\"ostring\" length=\"o1\" inval=\"0xff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x42\" name=\"Character string\" shortname=\"cstring\" length=\"o1\" inval=\"0xff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x43\" name=\"Long octed string\" shortname=\"lostring\" length=\"o2\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x44\" name=\"Long character string\" shortname=\"lcstring\" length=\"o2\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <!-- Ordered sequence -->\r\n    <!-- sloc, sum of length of content -->\r\n    <datatype id=\"0x48\" name=\"Array\" shortname=\"array\" length=\"2+sloc\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x4c\" name=\"Structure\" shortname=\"struct\" length=\"2+sloc\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <!-- Collection -->\r\n    <datatype id=\"0x50\" name=\"Set\" shortname=\"set\" length=\"sloc\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0x51\" name=\"Bag\" shortname=\"bag\" length=\"sloc\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <!-- Time -->\r\n    <datatype id=\"0xe0\" name=\"Time of day\" shortname=\"time\" length=\"4\" inval=\"0xffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0xe1\" name=\"Date\" shortname=\"date\" length=\"4\" inval=\"0xffffffff\" ad=\"A\"></datatype>\r\n    <datatype id=\"0xe2\" name=\"UTCTime\" shortname=\"utc\" length=\"4\" inval=\"0xffffffff\" ad=\"A\"></datatype>\r\n    <!-- Identifier -->\r\n    <datatype id=\"0xe8\" name=\"Cluster ID\" shortname=\"cid\" length=\"2\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0xe9\" name=\"Attribute ID\" shortname=\"aid\" length=\"2\" inval=\"0xffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0xea\" name=\"BACnet OID\" shortname=\"oid\" length=\"4\" inval=\"0xffffffff\" ad=\"D\"></datatype>\r\n    <!-- Miscellaneous -->\r\n    <datatype id=\"0xf0\" name=\"IEEE address\" shortname=\"uid\" length=\"8\" inval=\"0xffffffffffffffff\" ad=\"D\"></datatype>\r\n    <datatype id=\"0xf1\" name=\"128-bit security key\" shortname=\"seckey\" length=\"16\" ad=\"D\"></datatype>\r\n  </datatypes>\r\n\r\n  <enumeration id=\"0x00\" name=\"ZCL_Status\">\r\n    <value value=\"0x00\" name=\"SUCCESS\"></value>\r\n    <value value=\"0x01\" name=\"FAILURE\"></value>\r\n    <value value=\"0x7e\" name=\"NOT_AUTHORIZED\"></value>\r\n    <value value=\"0x7f\" name=\"RESERVED_FIELD_NOT_ZERO\"></value>\r\n    <value value=\"0x80\" name=\"MALFORMED_COMMAND\"></value>\r\n    <value value=\"0x81\" name=\"UNSUP_CLUSTER_COMMAND\"></value>\r\n    <value value=\"0x82\" name=\"UNSUP_GENERAL_COMMAND\"></value>\r\n    <value value=\"0x83\" name=\"UNSUP_MANUF_CLUSTER_COMMAND\"></value>\r\n    <value value=\"0x84\" name=\"UNSUP_MANUF_GENERAL_COMMAND\"></value>\r\n    <value value=\"0x85\" name=\"INVALID_FIELD\"></value>\r\n    <value value=\"0x86\" name=\"UNSUPPORTED_ATTRIBUTE\"></value>\r\n    <value value=\"0x87\" name=\"INVALID_VALUE\"></value>\r\n    <value value=\"0x88\" name=\"READ_ONLY\"></value>\r\n    <value value=\"0x89\" name=\"INSUFFICIENT_SPACE\"></value>\r\n    <value value=\"0x8a\" name=\"DUPLICATE_EXISTS\"></value>\r\n    <value value=\"0x8b\" name=\"NOT_FOUND\"></value>\r\n    <value value=\"0x8c\" name=\"UNREPORTABLE_ATTRIBUTE\"></value>\r\n    <value value=\"0x8d\" name=\"INVALID_DATA_TYPE\"></value>\r\n    <value value=\"0x8e\" name=\"INVALID_SECTOR\"></value>\r\n    <value value=\"0x8f\" name=\"WRITE_ONLY\"></value>\r\n    <value value=\"0x90\" name=\"INCONSISTENT_STARTUP_STATE\"></value>\r\n    <value value=\"0x91\" name=\"DEFINED_OUT_OF_BAND\"></value>\r\n    <value value=\"0xc0\" name=\"HARDWARE_FAILURE\"></value>\r\n    <value value=\"0xc1\" name=\"SOFTWARE_FAILURE\"></value>\r\n    <value value=\"0xc2\" name=\"CALIBRATION_ERROR\"></value>\r\n  </enumeration>\r\n\r\n  <enumeration id=\"0x01\" name=\"ZDP_Status\">\r\n    <value value=\"0x00\" name=\"SUCCESS\"></value>\r\n    <value value=\"0x80\" name=\"INV_REQUESTTYPE\"></value>\r\n    <value value=\"0x81\" name=\"DEVICE_NOT_FOUND\"></value>\r\n    <value value=\"0x82\" name=\"INVALID_EP\"></value>\r\n    <value value=\"0x83\" name=\"NOT_ACTIVE\"></value>\r\n    <value value=\"0x84\" name=\"NOT_SUPPORTED\"></value>\r\n    <value value=\"0x85\" name=\"TIMEOUT\"></value>\r\n    <value value=\"0x86\" name=\"NO_MATCH\"></value>\r\n    <!--          0x87  reserved -->\r\n    <value value=\"0x88\" name=\"NO_ENTRY\"></value>\r\n    <value value=\"0x89\" name=\"NO_DESCRIPTOR\"></value>\r\n    <value value=\"0x8a\" name=\"INSUFFCIENT_SPACE\"></value>\r\n    <value value=\"0x8b\" name=\"NOT_PERMITTED\"></value>\r\n    <value value=\"0x8c\" name=\"TABLE_FULL\"></value>\r\n    <value value=\"0x8d\" name=\"NOT_AUTHORIZED\"></value>\r\n  </enumeration>\r\n\r\n  <domain name=\"General\" useZcl=\"true\" description=\"The general functional domain contains clusters and information that provides generally applicable functions and attributes that are not specific to other functional domains.\">\r\n    <cluster id=\"0x0000\" name=\"Basic\">\r\n      <description>Attributes for determining basic information about a device, setting user device information such as description of location, and enabling a device.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Basic Device Information\">\r\n          <attribute id=\"0x0000\" name=\"ZCL Version\" type=\"u8\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Application Version\" type=\"u8\" access=\"r\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Stack Version\" type=\"u8\" access=\"r\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"HW Version\" type=\"u8\" access=\"r\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Manufacturer Name\" type=\"cstring\" access=\"r\" required=\"o\" range=\"0,32\"></attribute>\r\n          <attribute id=\"0x0005\" name=\"Model Identifier\" type=\"cstring\" access=\"r\" required=\"o\" range=\"0,32\"></attribute>\r\n          <attribute id=\"0x0006\" name=\"Date Code\" type=\"cstring\" access=\"r\" required=\"o\" range=\"0,16\"></attribute>\r\n          <attribute id=\"0x0007\" name=\"Power Source\" type=\"enum8\" default=\"0\" access=\"r\" required=\"m\">\r\n            <value name=\"Unknown\" value=\"0\"></value>\r\n            <value name=\"Mains (single phase)\" value=\"1\"></value>\r\n            <value name=\"Mains (3 phase)\" value=\"2\"></value>\r\n            <value name=\"Battery\" value=\"3\"></value>\r\n            <value name=\"DC Source\" value=\"4\"></value>\r\n            <value name=\"Emergency mains constantly powered\" value=\"5\"></value>\r\n            <value name=\"Emergency mains and transfer switch\" value=\"6\"></value>\r\n            <value name=\"Unknown with battery backup\" value=\"0x80\"></value>\r\n            <value name=\"Mains (single phase) with battery backup\" value=\"0x81\"></value>\r\n\t          <value name=\"Mains (3 phase) with battery backup\" value=\"0x82\"></value>\r\n\t          <value name=\"Battery with battery backup\" value=\"0x83\"></value>\r\n            <value name=\"DC Source with battery backup\" value=\"0x84\"></value>\r\n            <value name=\"Emergency mains constantly powered with battery backup\" value=\"0x85\"></value>\r\n            <value name=\"Emergency mains and transfer switch with battery backup\" value=\"0x86\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0008\" name=\"Generic Device Class\" type=\"enum8\" default=\"0xff\" access=\"r\" required=\"o\" >\r\n            <description>IKEA control outlet specific.</description>\r\n            <value name=\"Lighting\" value=\"0\"></value>\r\n            <value name=\"Unspecified\" value=\"0xff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0009\" name=\"Generic Device Type\" type=\"enum8\" default=\"0xff\" access=\"r\" required=\"o\" >\r\n            <description>IKEA control outlet specific.</description>\r\n            <value name=\"Incandescent\" value=\"0\"></value>\r\n            <value name=\"Spotlight Halogen\" value=\"1\"></value>\r\n            <value name=\"Halogen Bulb\" value=\"2\"></value>\r\n            <value name=\"CFL\" value=\"3\"></value>\r\n            <value name=\"Linear Fluorencent\" value=\"4\"></value>\r\n            <value name=\"LED Bulb\" value=\"5\"></value>\r\n            <value name=\"Spotlight LED\" value=\"6\"></value>\r\n            <value name=\"LED Strip\" value=\"7\"></value>\r\n            <value name=\"LED Tube\" value=\"8\"></value>\r\n            <value name=\"Indoor Luminaire\" value=\"9\"></value>\r\n            <value name=\"Outdoor Luminaire\" value=\"0x0a\"></value>\r\n            <value name=\"Pendant Luminaire\" value=\"0x0b\"></value>\r\n            <value name=\"Floor Standing Luminaire\" value=\"0x0c\"></value>\r\n            <value name=\"Controller\" value=\"0xe0\"></value>\r\n            <value name=\"Wall Switch\" value=\"0xe1\"></value>\r\n            <value name=\"Portable Remote Controller\" value=\"0xe2\"></value>\r\n            <value name=\"Motion or Light Sensor\" value=\"0xe3\"></value>\r\n            <!-- 0xe4 to 0xef Reserved -->\r\n            <value name=\"Actuator\" value=\"0xf0\"></value>\r\n            <value name=\"Wall Socket\" value=\"0xf1\"></value>\r\n            <value name=\"Gateway or Bridge\" value=\"0xf2\"></value>\r\n            <value name=\"Plug-In Unit\" value=\"0xf3\"></value>\r\n            <value name=\"Retrofit Actuator\" value=\"0xf4\"></value>\r\n            <value name=\"Unspecified\" value=\"0xff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x000a\" name=\"Product code\" type=\"ostring\" access=\"r\" required=\"o\" >\r\n            <description>As printed on the product.</description>\r\n          </attribute>\r\n    <attribute id=\"0x000b\" name=\"Product URL\" type=\"cstring\" access=\"r\" required=\"o\" range=\"0,50\"></attribute>\r\n    <attribute id=\"0x000c\" name=\"Manufacturer Version Details\" type=\"cstring\" access=\"r\" required=\"o\"></attribute>\r\n    <attribute id=\"0x000d\" name=\"Serial Number\" type=\"cstring\" access=\"r\" required=\"o\"></attribute>\r\n    <attribute id=\"0x000e\" name=\"Product Label\" type=\"cstring\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x4000\" name=\"SW Build ID\" type=\"cstring\" access=\"r\" required=\"o\" range=\"0,16\"></attribute>\r\n          <attribute id=\"0xff0d\" name=\"Xiaomi Sensitivity\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xff22\" name=\"Xiaomi Disconnect 1\" type=\"u8\" showas=\"hex\" access=\"rw\" required=\"o\" mfcode=\"0x115f\">\r\n            <description>Set to 0x12 (0xFE) to connect (disconnect) the left button to (from) the relay.</description>\r\n          </attribute>\r\n          <attribute id=\"0xff23\" name=\"Xiaomi Disconnect 2\" type=\"u8\" showas=\"hex\" access=\"rw\" required=\"o\" mfcode=\"0x115f\">\r\n            <description>Set to 0x22 (0xFE) to connect (disconnect) the left button to (from) the relay.</description>\r\n          </attribute>\r\n          <!-- <attribute id=\"0xff0d\" name=\"Xiaomi Sensitivity\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x1037\"></attribute> -->\r\n          <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n    <attribute id=\"0xfffe\" name=\"Tuya magic spell final attribute\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\">\r\n    <description>Read attributes in this order Manufacturer name,ZCL version,Application version,Model Identifier,Power source and finally this one\"</description>\r\n    </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Basic Device Settings\">\r\n          <attribute id=\"0x0010\" name=\"Location Description\" type=\"cstring\" range=\"0,16\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Physical Environment\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Unspecified Environment\" value=\"0x00\"></value>\r\n            <value name=\"Mirror (ZSE Profile)\" value=\"0x01\"></value>\r\n            <value name=\"Atrium (non ZSE profile)\" value=\"0x01\"></value>\r\n            <value name=\"Bar\" value=\"0x02\"></value>\r\n            <value name=\"Courtyard\" value=\"0x03\"></value>\r\n            <value name=\"Bathroom\" value=\"0x04\"></value>\r\n            <value name=\"Bedroom\" value=\"0x05\"></value>\r\n            <value name=\"Billiard Room\" value=\"0x06\"></value>\r\n            <value name=\"Utility Room\" value=\"0x07\"></value>\r\n            <value name=\"Cellar\" value=\"0x08\"></value>\r\n            <value name=\"Storage Closet\" value=\"0x09\"></value>\r\n            <value name=\"Theater\" value=\"0x0a\"></value>\r\n            <value name=\"Office\" value=\"0x0b\"></value>\r\n            <value name=\"Deck\" value=\"0x0c\"></value>\r\n            <value name=\"Den\" value=\"0x0d\"></value>\r\n            <value name=\"Dining Room\" value=\"0x0e\"></value>\r\n            <value name=\"Electrical Room\" value=\"0x0f\"></value>\r\n            <value name=\"Elevator\" value=\"0x10\"></value>\r\n            <value name=\"Entry\" value=\"0x11\"></value>\r\n            <value name=\"Family Room\" value=\"0x12\"></value>\r\n            <value name=\"Main Floor\" value=\"0x13\"></value>\r\n            <value name=\"Upstairs\" value=\"0x14\"></value>\r\n            <value name=\"Downstairs\" value=\"0x15\"></value>\r\n            <value name=\"Basement/Lower Level\" value=\"0x16\"></value>\r\n            <value name=\"Gallery\" value=\"0x17\"></value>\r\n            <value name=\"Game Room\" value=\"0x18\"></value>\r\n            <value name=\"Garage\" value=\"0x19\"></value>\r\n            <value name=\"Gym\" value=\"0x1a\"></value>\r\n            <value name=\"Hallway\" value=\"0x1b\"></value>\r\n            <value name=\"House\" value=\"0x1c\"></value>\r\n            <value name=\"Kitchen\" value=\"0x1d\"></value>\r\n            <value name=\"Laundry Room\" value=\"0x1e\"></value>\r\n            <value name=\"Library\" value=\"0x1f\"></value>\r\n            <value name=\"Master Bedroom\" value=\"0x20\"></value>\r\n            <value name=\"Mud Room (small room for coats and boots)\" value=\"0x21\"></value>\r\n            <value name=\"Nursery\" value=\"0x22\"></value>\r\n            <value name=\"Pantry\" value=\"0x23\"></value>\r\n            <value name=\"Office\" value=\"0x24\"></value>\r\n            <value name=\"Outside\" value=\"0x25\"></value>\r\n            <value name=\"Pool\" value=\"0x26\"></value>\r\n            <value name=\"Porch\" value=\"0x27\"></value>\r\n            <value name=\"Sewing Room\" value=\"0x28\"></value>\r\n            <value name=\"Sitting Room\" value=\"0x29\"></value>\r\n            <value name=\"Stairway\" value=\"0x2a\"></value>\r\n            <value name=\"Yard\" value=\"0x2b\"></value>\r\n            <value name=\"Attic\" value=\"0x2c\"></value>\r\n            <value name=\"Hot Tub\" value=\"0x2d\"></value>\r\n            <value name=\"Living Room\" value=\"0x2e\"></value>\r\n            <value name=\"Sauna\" value=\"0x2f\"></value>\r\n            <value name=\"Shop/Workshop\" value=\"0x30\"></value>\r\n            <value name=\"Guest Bedroom\" value=\"0x31\"></value>\r\n            <value name=\"Guest Bath\" value=\"0x32\"></value>\r\n            <value name=\"Powder Room (1/2 bath)\" value=\"0x33\"></value>\r\n            <value name=\"Back Yard\" value=\"0x34\"></value>\r\n            <value name=\"Front Yard\" value=\"0x35\"></value>\r\n            <value name=\"Patio\" value=\"0x36\"></value>\r\n            <value name=\"Driveway\" value=\"0x37\"></value>\r\n            <value name=\"Sun Room\" value=\"0x38\"></value>\r\n            <value name=\"Living Room\" value=\"0x39\"></value>\r\n            <value name=\"Spa\" value=\"0x3a\"></value>\r\n            <value name=\"Whirlpool\" value=\"0x3b\"></value>\r\n            <value name=\"Shed\" value=\"0x3c\"></value>\r\n            <value name=\"Equipment Storage\" value=\"0x3d\"></value>\r\n            <value name=\"Hobby/Craft Room\" value=\"0x3e\"></value>\r\n            <value name=\"Fountain\" value=\"0x3f\"></value>\r\n            <value name=\"Pond\" value=\"0x40\"></value>\r\n            <value name=\"Reception Room\" value=\"0x41\"></value>\r\n            <value name=\"Breakfast Room\" value=\"0x42\"></value>\r\n            <value name=\"Nook\" value=\"0x43\"></value>\r\n            <value name=\"Garden\" value=\"0x44\"></value>\r\n            <value name=\"Balcony\" value=\"0x45\"></value>\r\n            <value name=\"Panic Room\" value=\"0x46\"></value>\r\n            <value name=\"Terrace\" value=\"0x47\"></value>\r\n            <value name=\"Roof\" value=\"0x48\"></value>\r\n            <value name=\"Toilet\" value=\"0x49\"></value>\r\n            <value name=\"Toilet Main\" value=\"0x4a\"></value>\r\n            <value name=\"Outside Toilet\" value=\"0x4b\"></value>\r\n            <value name=\"Shower room\" value=\"0x4c\"></value>\r\n            <value name=\"Study\" value=\"0x4d\"></value>\r\n            <value name=\"Front Garden\" value=\"0x4e\"></value>\r\n            <value name=\"Back Garden\" value=\"0x4f\"></value>\r\n            <value name=\"Kettle\" value=\"0x50\"></value>\r\n            <value name=\"Television\" value=\"0x51\"></value>\r\n            <value name=\"Stove\" value=\"0x52\"></value>\r\n            <value name=\"Microwave\" value=\"0x53\"></value>\r\n            <value name=\"Toaster\" value=\"0x54\"></value>\r\n            <value name=\"Vacuum\" value=\"0x55\"></value>\r\n            <value name=\"Appliance\" value=\"0x56\"></value>\r\n            <value name=\"Front Door\" value=\"0x57\"></value>\r\n            <value name=\"Back Door\" value=\"0x58\"></value>\r\n            <value name=\"Fridge Door\" value=\"0x59\"></value>\r\n            <value name=\"Medication Cabinet Door\" value=\"0x60\"></value>\r\n            <value name=\"Wardrobe Door\" value=\"0x61\"></value>\r\n            <value name=\"Front Cupboard Door\" value=\"0x62\"></value>\r\n            <value name=\"Other Door\" value=\"0x63\"></value>\r\n            <value name=\"Waiting Room\" value=\"0x64\"></value>\r\n            <value name=\"Triage Room\" value=\"0x65\"></value>\r\n            <value name=\"Doctor’s Office\" value=\"0x66\"></value>\r\n            <value name=\"Patient’s Private Room\" value=\"0x67\"></value>\r\n            <value name=\"Consultation Room\" value=\"0x68\"></value>\r\n            <value name=\"Nurse Station\" value=\"0x69\"></value>\r\n            <value name=\"Ward\" value=\"0x6a\"></value>\r\n            <value name=\"Corridor\" value=\"0x6b\"></value>\r\n            <value name=\"Operating Theatre\" value=\"0x6c\"></value>\r\n            <value name=\"Dental Surgery Room\" value=\"0x6d\"></value>\r\n            <value name=\"Medical Imaging Room\" value=\"0x6e\"></value>\r\n            <value name=\"Decontamination Room\" value=\"0x6f\"></value>\r\n            <value name=\"Atrium\" value=\"0x70\"></value>\r\n            <value name=\"Mirror\" value=\"0x71\"></value>\r\n            <value name=\"Unknown Environment\" value=\"0xff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0012\" name=\"Device Enabled\" type=\"bool\" default=\"1\" access=\"rw\" required=\"o\">\r\n            <value name=\"Disabled\" value=\"0\"></value>\r\n            <value name=\"Enabled\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0013\" name=\"Alarm Mask\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"o\">\r\n            <value name=\"General Hardware Fault\" value=\"0\"></value>\r\n            <value name=\"General Software Fault\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0014\" name=\"Disable Local Config\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Reset (to factory defaults) disabled\" value=\"0\"></value>\r\n            <value name=\"Device configuration disabled\" value=\"1\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Hue Specific\" mfcode=\"0x100b\">\r\n          <!--\r\n          <attribute id=\"0x0000\" name=\"Hue Unknown 0\" type=\"cstring\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Hue Unknown 1\" type=\"u32\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Hue Unknown 1\" type=\"u32\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Hue Unknown 1\" type=\"u32\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n          -->\r\n          <attribute id=\"0x0030\" name=\"Sensitivity\" description=\"Hue motion sensor related SML001\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\">\r\n            <value name=\"default\" value=\"0\"></value>\r\n            <value name=\"high\" value=\"1\"></value>\r\n            <value name=\"max\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0031\" name=\"Configuration\" type=\"bmp16\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\" description=\"TODO flags are only known for hue dimmer switch\">\r\n            <value name=\"Touchlink enabled 0\" value=\"0\"></value>\r\n            <value name=\"Touchlink enabled 1\" value=\"1\"></value>\r\n            <value name=\"Touchlink enabled 2\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0032\" name=\"Usertest\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\"></attribute>\r\n          <attribute id=\"0x0033\" name=\"LED Indication\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\"></attribute>\r\n          <attribute id=\"0x0034\" name=\"Device Mode\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\">\r\n            <value name=\"Single Rocker\" value=\"0\"></value>\r\n            <value name=\"Single Push Button\" value=\"1\"></value>\r\n            <value name=\"Dual Rocker\" value=\"2\"></value>\r\n            <value name=\"Dual Push Button\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0040\" name=\"Product Identifier\" type=\"cstring\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0041\" name=\"Software Config Identifier\" type=\"u32\" mfcode=\"0x100b\" showas=\"hex\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0050\" name=\"Hue Unknown 50\" type=\"bmp32\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n            <value name=\"Unknown\" value=\"0x00\"/>\r\n          </attribute>\r\n          <attribute id=\"0x0051\" name=\"Hue Unknown 51\" type=\"enum8\" mfcode=\"0x100b\" access=\"rw\" required=\"o\">\r\n            <value name=\"Default\" value=\"0x00\"/>\r\n            <value name=\"Hue bridge setting\" value=\"0x01\"/>\r\n          </attribute>\r\n          <attribute id=\"0xf109\" name=\"Hue Unknown f109\" type=\"bool\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x4000\" description=\"Manufacturer specific\" mfcode=\"0x1037\">\r\n          <attribute id=\"0x4001\" name=\"128-Bit security key\" type=\"seckey\" access=\"r\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n          <attribute id=\"0x4002\" name=\"IEEE address\" type=\"uid\" access=\"rw\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x4000\" description=\"Manufacturer specific\" mfcode=\"0x1166\">\r\n          <attribute id=\"0x4001\" name=\"128-Bit security key\" type=\"seckey\" access=\"r\" required=\"m\" mfcode=\"0x1166\"></attribute>\r\n          <attribute id=\"0x4002\" name=\"IEEE address\" type=\"uid\" access=\"rw\" required=\"m\" mfcode=\"0x1166\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x4000\" description=\"Müller Licht specific\" mfcode=\"0x121b\">\r\n          <attribute id=\"0x4005\" name=\"Scene\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x121b\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x5000\" description=\"ID Lock specific\" mfcode=\"0x1337\">\r\n          <attribute id=\"0x5000\" name=\"Lock fw\" type=\"cstring\" access=\"r\" required=\"m\" mfcode=\"0x1337\" />\r\n        </attribute-set>\r\n        <attribute-set id=\"0x8000\" description=\"Develco specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x8000\" name=\"Primary SW Version\" type=\"ostring\" access=\"r\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8010\" name=\"Primary Bootloader SW Version\" type=\"ostring\" access=\"r\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8020\" name=\"Primary HW Version\" type=\"ostring\" access=\"r\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8030\" name=\"Primary HW name\" type=\"ostring\" access=\"r\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8050\" name=\"Primary SW Version 3rd Party\" type=\"ostring\" access=\"r\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8100\" name=\"LED Control\" type=\"bmp8\" default=\"0xff\" access=\"rw\" required=\"o\" mfcode=\"0x1015\">\r\n            <value name=\"0x00 - LED disabled, 0x01 - Enable periodic fault flashes\" value=\"0\"></value>\r\n            <value name=\"0x02 - Indicate motion detection\" value=\"1\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        \r\n        \r\n        \r\n        <attribute-set id=\"0x9000\" description=\"Sunricher specific\" mfcode=\"0x1224\">\r\n          <attribute id=\"0x8806\" name=\"Dimming brightness curve\" type=\"u8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Works after reset power of the device.\r\n              0: linear,\r\n              15: logarithmic with gamma value 1.5,\r\n              18: logarithmic with gamma value 1.8</description>\r\n          </attribute>\r\n          <attribute id=\"0x8903\" name=\"Motion sensor daylight sensor lux threshold\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>2 bytes, only when the detected lux is lower than the threshold, turning on the light is permitted. For instance, with value 0x0000, this function does not work.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8904\" name=\"Motion sensor operation mode\" type=\"u8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>0: means auto mode,\r\n              1: means manual mode\r\n              \r\n              Auto mode means that when a motion is detected, the device will output PWM according to the set brightness threshold, and delay time.\r\n              PWM status needs to be reported to the gateway.\r\n              \r\n              Manual mode means that PWM output is controlled and determined by the gateway or the wireless switch, not associated with motion detection.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8905\" name=\"Motion sensor sensitivity setting\" type=\"u8\" default=\"0x01\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Works after reset power of the device. 1 byte, data range 0-15, 0 is the highest sensitivity, 15 is the lowest sensitivity.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8906\" name=\"Motion sensor microwave detection\" type=\"u8\" default=\"0x01\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Works after reset power of the device.\r\n              0: disabled,\r\n              1: enabled.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8907\" name=\"Send ON/OFF command to the touchlink devices\" type=\"u8\" default=\"0x01\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Works after reset power of the device. Configuration of whether to send ON/OFF command to the touchlink devices and binding devices.\r\n              0=do not send,\r\n              1=send</description>\r\n          </attribute>\r\n          <attribute id=\"0x890C\" name=\"Brightness module\" type=\"u8\" default=\"0x01\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>0=disabled,\r\n              1=enabled</description>\r\n          </attribute>\r\n          <attribute id=\"0x8902\" name=\"Light on time\" type=\"u16\" default=\"0x003C\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Light on time (the first delay time).\r\n              Works after reset power of the device. When motion sensor mode is set as auto mode, and motion is detected, after the person leaves, light on time of the device.\r\n              2 bytes, unit is second.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8908\" name=\"Brightness of PWM output when motion detected\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Configuration of the brightness value of PWM output when motion detected, this brightness value is controlled through PWM output working as PID\r\n              closed loop control to achieve the constant light output. Value range is 0-1000LUX, 0LUX means this attribute is disabled, and PWM output when motion \r\n              detected is not associated with the brightness value.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8909\" name=\"PWM output percentage when motion detected\" type=\"u8\" default=\"0xfe\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Configuration of PWM output percentage when motion detected. Value Range is 0-254, which means 0-100%.\r\n              When configured PID closed loop control brightness LUX is 0, PWM output of the device is according to this value.</description>\r\n          </attribute>\r\n          <attribute id=\"0x890A\" name=\"Light on time (status 2nd delay)\" type=\"u8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>After the light on time expires, the light status within the duration of 2nd delay time. Value Range is 0-254, which means 0-100%.</description>\r\n          </attribute>\r\n          <attribute id=\"0x8901\" name=\"Light on time (duration 2nd delay)\" type=\"u16\" default=\"0x003C\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>After the light on time expires, the duration of 2nd delay time. Value range is 0-65536s.</description>\r\n          </attribute>\r\n          <attribute id=\"0x890B\" name=\"Light status after expiration 2nd delay time\" type=\"u8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>After the 2nd delay time expires, the status of the light. Value Range is 0-254, which means 0-100%.</description>\r\n          </attribute>\r\n          <attribute id=\"0x890D\" name=\"Linearity error ratio coefficient of LUX measurement (M)\" type=\"u16\" default=\"0x03E8\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Default value is 1000, which means 1000 per mill. When increase the value of M, LUX measurement value will be magnified linearly.\r\n              When decrease the value of M, LUX measurement value will be minified linearly. For instance, modify M value as 1001, LUX measurement value will be magnified\r\n              to 1.001 times. Modify M value as 500, LUX measurement value will be magnified to 0.5 times.</description>\r\n          </attribute>\r\n          <attribute id=\"0x890E\" name=\"Fixed deviation of LUX measurement\" type=\"s16\" default=\"0x0000\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>For instance, if we need to increase the measurement value by 100LUX, then this parameter value will be +100.\r\n              If we need to decrease the measurement value by 100LUX, then this parameter value will be -100.\r\n</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x9000\" description=\"Sunricher specific\" mfcode=\"0x1224\">\r\n          <attribute id=\"0x9001\" name=\"Light PWM Frequency\" type=\"u16\" default=\"0x0CE4\" access=\"rw\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Works after reset power of the device, the device that directly outputs PWM can be configured,\r\n              DO NOT set the PWM frequency too high which will affect the dimming resolution.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xe000\" description=\"Schneider specific\" mfcode=\"0x105e\">\r\n          <attribute id=\"0xe001\" name=\"Application FW Version\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe002\" name=\"Application HW Version\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe004\" name=\"Serial Number\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe007\" name=\"Product Indentifier\" type=\"enum16\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe008\" name=\"Product Range\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe009\" name=\"Product Model\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe00a\" name=\"Product Family\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n          <attribute id=\"0xe00b\" name=\"Vendor URL\" type=\"cstring\" access=\"r\" required=\"o\" mfcode=\"0x105e\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xFF00\" description=\"Xiaomi specific\" mfcode=\"0x1037\">\r\n          <attribute id=\"0xFF0D\" name=\"Xiaomi Sensitivity\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFF22\" name=\"Xiaomi Disconnect 1\" type=\"u8\" showas=\"hex\" access=\"rw\" required=\"o\" mfcode=\"0x115f\">\r\n            <description>Set to 0x12 (0xFE) to connect (disconnect) the left button to (from) the relay.</description>\r\n          </attribute>\r\n          <attribute id=\"0xFF23\" name=\"Xiaomi Disconnect 2\" type=\"u8\" showas=\"hex\" access=\"rw\" required=\"o\" mfcode=\"0x115f\">\r\n            <description>Set to 0x22 (0xFE) to connect (disconnect) the left button to (from) the relay.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xFF00\" description=\"Xiaomi specific\" mfcode=\"0x115f\">\r\n          <attribute id=\"0xFF08\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFF51\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFF52\" name=\"Unknown\" type=\"cstring\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFF53\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFF54\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n          <attribute id=\"0xFFF0\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xFF00\" description=\"Tuya specific\" mfcode=\"0x1002\">\r\n          <attribute id=\"0xffde\" name=\"Reporting1\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0xffe2\" name=\"Unknown1\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0xffe4\" name=\"Unknown2\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0xfffe\" name=\"Unknown3\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"00\" dir=\"recv\" name=\"Reset to Factory Defaults\" required=\"o\"></command>\r\n        <command id=\"0xc0\" dir=\"recv\" name=\"Hue Capabilities\" vendor=\"0x100b\" required=\"o\" response=\"0xc1\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"0x00\" default=\"0x00\" showas=\"hex\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u32\" name=\"Offset\" default=\"0x00\" showas=\"hex\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Max Packet Size\" default=\"0x40\" showas=\"hex\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"0xc1\" dir=\"recv\" name=\"Hue Capabilities Response\" vendor=\"0x100b\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Status\" showas=\"hex\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u32\" name=\"Offset\" showas=\"hex\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u32\" name=\"Total Payload Length\" showas=\"hex\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"ostring\" name=\"Payload\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0001\" name=\"Power Configuration\">\r\n      <description>Attributes for determining more detailed information about a device’s power source(s), and for configuring under/over voltage alarms.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Mains Information\">\r\n          <attribute id=\"0x0000\" name=\"Mains Voltage\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Mains Frequency\" type=\"u8\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Mains Settings\">\r\n          <attribute id=\"0x0010\" name=\"Mains Alarm Mask\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Mains Voltage too low (7.2.2.2.2)\" value=\"0\"></value>\r\n            <value name=\"Mains Voltage too high (7.2.2.2.3)\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0011\" name=\"Mains Voltage Min Threshold\" type=\"u16\" access=\"rw\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Mains Voltage Max Threshold\" type=\"u16\" access=\"rw\" default=\"0xffff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Mains Voltage Dwell Trip Point\" type=\"u16\" access=\"rw\" default=\"0\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Battery Information\">\r\n          <attribute id=\"0x0020\" name=\"Battery Voltage\" type=\"u8\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0021\" name=\"Battery Percentage Remaining\" type=\"u8\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Battery Settings\">\r\n          <attribute id=\"0x0030\" name=\"Battery Manufacturer\" type=\"cstring\" access=\"rw\" required=\"o\" range=\"0,16\"></attribute>\r\n          <attribute id=\"0x0031\" name=\"Battery Size\" type=\"enum8\" default=\"0xff\" access=\"rw\" required=\"o\">\r\n            <value name=\"No Battery\" value=\"0\"></value>\r\n            <value name=\"Built in\" value=\"1\"></value>\r\n            <value name=\"Other\" value=\"2\"></value>\r\n            <value name=\"AA\" value=\"3\"></value>\r\n            <value name=\"AAA\" value=\"4\"></value>\r\n            <value name=\"C\" value=\"5\"></value>\r\n            <value name=\"D\" value=\"6\"></value>\r\n      \t    <value name=\"CR2\" value=\"7\"></value>\r\n\t          <value name=\"CR123A\" value=\"8\"></value>\r\n\t          <value name=\"Unknown\" value=\"0xff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0032\" name=\"Battery AHr Rating\" type=\"u16\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0033\" name=\"Battery Quantity\" type=\"u8\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0034\" name=\"Battery Rated Voltage\" type=\"u8\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0035\" name=\"Battery Alarm Mask\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Battery Voltage too low\" value=\"0\"></value>\r\n            <value name=\"Battery Alarm 1\" value=\"1\"></value>\r\n            <value name=\"Battery Alarm 2\" value=\"2\"></value>\r\n            <value name=\"Battery Alarm 3\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0036\" name=\"Battery Voltage Min Threshold\" type=\"u8\" access=\"rw\" default=\"00\" required=\"o\"></attribute>\r\n          <attribute id=\"0x003e\" name=\"Battery Alarm State\" type=\"bmp32\" access=\"rw\" default=\"0\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0002\" name=\"Device Temperature Configuration\">\r\n      <description>Attributes for determining information about a device’s internal temperature, and for configuring under/over temperature alarms.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Device Temperature Information\">\r\n          <attribute id=\"0x0000\" name=\"Current Temperature\" type=\"s16\" access=\"r\" range=\"-200,200\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Temp Experienced\" type=\"s16\" access=\"r\" range=\"-200,200\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Temp Experienced\" type=\"s16\" access=\"r\" range=\"-200,200\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Over Temp Total Dwell\" type=\"u16\" access=\"r\" range=\"0x0000,0xffff\" default=\"0\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Device Temperature Settings\">\r\n          <attribute id=\"0x0010\" name=\"Device Temp Alarm Mask\" type=\"bmp8\" access=\"rw\" range=\"00000000,00000011\" default=\"00000000\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Low Temp Threshold\" type=\"s16\" access=\"rw\" range=\"-200,200\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"High Temp Threshold\" type=\"s16\" access=\"rw\" range=\"-200,200\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Low Temp Dwell Trip Point\" type=\"u24\" access=\"rw\" range=\"0x000000,0xffffff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"High Temp Dwell Trip Point\" type=\"u24\" access=\"rw\" range=\"0x000000,0xffffff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0003\" name=\"Identify\">\r\n      <description>Attributes and commands for putting a device into Identification mode (e.g. flashing a light)</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Identify Time\" type=\"u16\" access=\"rw\" default=\"0x0000\" range=\"0x0000,0xfff\" required=\"m\"></attribute>\r\n        <attribute id=\"0x4000\" name=\"Identification button\" type=\"bool\" default=\"0x00\" access=\"r\" required=\"m\" mfcode=\"0x1246\"></attribute>\r\n        <command id=\"00\" dir=\"recv\" name=\"Identify\" required=\"m\">\r\n          <description>Start or stop the device identifying itself.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Identify Time\" required=\"m\" default=\"5\">\r\n              <description>The time in seconds for which a device will stay in identify mode.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Identify Query\" response=\"0x00\" required=\"m\">\r\n          <description>Allows the sending device to request the target or targets to respond if they are currently identifying themselves.</description>\r\n          <payload>\r\n          </payload>\r\n        </command>\r\n        <command id=\"40\" dir=\"recv\" name=\"Trigger Effect\" required=\"m\">\r\n          <description>The trigger effect command allows the support of feedback to the user, such as a certain light effect.\r\n          </description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Effect identifier\" required=\"m\" default=\"0x00\">\r\n              <description>The effect identifier field specifies the identify effect to use.</description>\r\n              <value name=\"Blink\" value=\"0x00\"></value>\r\n              <value name=\"Breathe\" value=\"0x01\"></value>\r\n              <value name=\"Okay\" value=\"0x02\"></value>\r\n              <value name=\"Channel change\" value=\"0x0b\"></value>\r\n              <value name=\"Finish\" value=\"0xfe\"></value>\r\n              <value name=\"Stop\" value=\"0xff\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Effect variant\" required=\"m\" default=\"0\">\r\n              <description>The effect identifier field specifies the identify effect to use.</description>\r\n              <value name=\"Default\" value=\"0x00\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"00\" dir=\"recv\" name=\"Identify Query Response\" required=\"m\">\r\n          <description>Response of a identify query command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Timeout\" required=\"m\" default=\"0\">\r\n              <description>The time in seconds for which a device will stay in identify mode.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0004\" name=\"Groups\">\r\n      <description>Attributes and commands for group configuration and manipulation.</description>\r\n      <server>\r\n        <attribute id=\"0000\" name=\"Name Support\" type=\"bmp8\" range=\"x0000000\" access=\"r\" required=\"m\">\r\n          <value name=\"Name Support\" value=\"7\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"IKEA Scene\" type=\"u32\" access=\"rw\" required=\"m\" showas=\"hex\" mfcode=\"0x117c\"></attribute>\r\n        <command id=\"00\" dir=\"recv\" name=\"Add group\" required=\"m\" response=\"0x00\">\r\n          <description>Add a group to the device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"cstring\" name=\"Group Name\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"View group\" required=\"m\" response=\"0x01\">\r\n          <description>Get the name of a group.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Get group membership\" required=\"m\" response=\"0x02\">\r\n          <description>Get the group membership of the device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Group count\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group list\" showas=\"hex\" listSize=\"@0x0000\" required=\"m\" ></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"03\" dir=\"recv\" name=\"Remove group\" required=\"m\" response=\"0x03\">\r\n          <description>Remove a group from the device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"04\" dir=\"recv\" name=\"Remove all groups\" required=\"m\">\r\n          <description>Remove all group from the device.</description>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"00\" dir=\"recv\" name=\"Add group response\" required=\"m\">\r\n          <description>The Response to the add group request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"View group response\" required=\"m\">\r\n          <description>The Response to the view group request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"cstring\" name=\"Group Name\" required=\"m\"></attribute>\r\n            <condition id=\"0x0000\" op=\"!=\" value=\"0x00\">\r\n              <action action=\"ignore\" id=\"0x0001\" />\r\n              <action action=\"ignore\" id=\"0x0002\" />\r\n            </condition>\r\n          </payload>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Get group membership response\" required=\"m\">\r\n          <description>The Response to the get group membership request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Capacity\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Group count\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Group list\" showas=\"hex\" listSize=\"0x0001\" required=\"o\" ></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"03\" dir=\"recv\" name=\"Remove group response\" required=\"m\">\r\n          <description>The Response to the remove group request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0005\" name=\"Scenes\">\r\n      <description>Attributes and commands for scene configuration and manipulation.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Scene Count\" type=\"u8\" range=\"0x00-0xff\" access=\"r\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Current Scene\" type=\"u8\" range=\"0x00-0xff\" access=\"r\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n        <!--\r\n        <attribute id=\"0x0001\" name=\"Hue Unknown 01\" type=\"bmp32\" mfcode=\"0x100b\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n        -->\r\n        <attribute id=\"0x0002\" name=\"Current Group\" type=\"u16\" range=\"0x0000-0xfff7\" access=\"r\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Scene Valid\" type=\"bool\" access=\"r\" required=\"m\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"Name Support\" type=\"bmp8\" access=\"r\" showas=\"hex\" required=\"m\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0005\" name=\"Last ConfiguredBy\" type=\"uid\" access=\"r\" showas=\"hex\" required=\"o\"></attribute>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Add scene\" required=\"m\" response=\"0x00\">\r\n          <description>Add a scenes to the group (empty).</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u8\" name=\"Name Length\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"View scene\" required=\"m\" response=\"0x01\">\r\n          <description>Views the scenes of a group.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Remove scene\" required=\"m\" response=\"0x02\">\r\n          <description>Removes a scenes of a group.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Remove all scenes\" required=\"m\" response=\"0x03\">\r\n          <description>Removes all scenes of a group.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Store scene\" required=\"m\" response=\"0x04\">\r\n          <description>Stores a scene of a group for a device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Recall scene\" required=\"m\" response=\"0x05\">\r\n          <description>Recalls a scene of a group for a device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Get scene membership\" required=\"m\" response=\"0x06\">\r\n          <description>Get the scenes of a group for a device.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Enhanced view scene\" required=\"m\" response=\"0x41\">\r\n          <description>Views the scenes of a group.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"IKEA step\" required=\"o\" vendor=\"0x117c\">\r\n          <description>Command sent by TRADFRI remote control on press left or right.  Set Direction to 1 for left or leave at 0 for right.  Leave the Unknown parameters at their default values.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Direction\" required=\"m\" default=\"0x0\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Unknown\" required=\"m\" showas=\"hex\" default=\"0x01\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Unknown\" required=\"m\" showas=\"hex\" default=\"0x000d\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"IKEA move\" required=\"o\" vendor=\"0x117c\">\r\n          <description>Command sent by TRADFRI remote control on hold left or right.  Set Direction to 1 for left or leave at 0 for right.  Leave the Unknown parameter at its default value.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Direction\" required=\"m\" default=\"0x0\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Unknown\" required=\"m\" showas=\"hex\" default=\"0x000d\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x09\" dir=\"recv\" name=\"IKEA stop\" required=\"o\" vendor=\"0x117c\">\r\n          <description>Command sent by TRADFRI remote control on release (after hold).  Leave the Unknown parameter at its default value.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Unknown\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <!-- TODO -->\r\n      </server>\r\n      <client>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Add scene response\" required=\"m\">\r\n          <description>Response to the add scene command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"View scene response\" required=\"m\">\r\n          <description>Response to the view scene command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Transition Time\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Remove scene response\" required=\"m\">\r\n          <description>Response to the remove scene command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Remove all scenes response\" required=\"m\">\r\n          <description>Response to the remove all scenes command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Store scene response\" required=\"m\">\r\n          <description>Response to the store scene command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Get scene membershio response\" required=\"m\">\r\n          <description>Shows details about scene membership.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Capacity\" required=\"m\" showas=\"dec\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u8\" name=\"Scene count\" required=\"m\" showas=\"dec\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Enhanced view scene response\" required=\"m\">\r\n          <description>A scene description.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Status\" required=\"m\" default=\"0x00\" enumeration=\"ZCL_Status\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Group ID\" required=\"m\" showas=\"hex\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Scene ID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Transition Time\" required=\"m\" showas=\"dec\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"cstring\" name=\"Name\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0006\" name=\"On/Off\">\r\n      <description>Attributes and commands for switching devices between 'On' and 'Off' states.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"OnOff state\">\r\n          <attribute id=\"0000\" name=\"OnOff\" type=\"bool\" access=\"r\" default=\"0\" required=\"m\">\r\n            <value name=\"On\" value=\"1\"></value>\r\n            <value name=\"Off\" value=\"0\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4000\" name=\"GlobalSceneControl\" type=\"bool\" access=\"r\" default=\"0x01\" required=\"o\"></attribute>\r\n          <attribute id=\"0x4001\" name=\"OnTime\" type=\"u16\" access=\"rw\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x4002\" name=\"OffWaitTime\" type=\"u16\" access=\"rw\" default=\"0\" required=\"o\"></attribute>\r\n          <attribute id=\"0x4003\" name=\"StartUp OnOff\" type=\"enum8\" access=\"rw\" default=\"0x01\" required=\"o\">\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"On\" value=\"0x01\"></value>\r\n            <value name=\"Toggle\" value=\"0x02\"></value>\r\n            <value name=\"Previous\" value=\"0xff\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x8000\" description=\"Xiaomi\" mfcode=\"0x1037\">\r\n          <attribute id=\"0x8000\" name=\"Button Press\" type=\"u8\" access=\"r\" required=\"o\"/>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x8001\" description=\"Tuya special\">\r\n          <attribute id=\"0x8001\" name=\"Back Light mode\" type=\"enum8\" default=\"0\" required=\"o\" access=\"rw\">\r\n            <value name=\"Mode 1-Off\" value=\"0\"></value>\r\n            <value name=\"Mode 2-Light when On\" value=\"1\"></value>\r\n            <value name=\"Mode 3-Light when Off\" value=\"2\"></value>\r\n            <value name=\"Mode 4-Actual state\" value=\"3\"></value>\t\t  \r\n          </attribute>\r\n          <attribute id=\"0x8002\" name=\"Power on state\" type=\"enum8\" default=\"0\" required=\"o\" access=\"rw\">\r\n            <value name=\"Off\" value=\"0\"></value>\r\n            <value name=\"On\" value=\"1\"></value>\r\n            <value name=\"Last state\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x8003\" name=\"Over current alarm\" type=\"bool\" default=\"0\" required=\"o\" access=\"r\">\r\n                <value name=\"Over current OK\" value=\"0\"></value>\r\n                <value name=\"Over current alarm\" value=\"1\"></value>\r\n            </attribute>\r\n\t          <attribute id=\"0x8004\" name=\"Switch operation mode\" type=\"enum8\" default=\"0\" required=\"m\" access=\"r\">\r\n                <value name=\"Command Mode (Light OnOff/Dimmer commands)\" value=\"0\"></value>\r\n                <value name=\"Event Mode (Tuya Scene commands)\" value=\"1\"></value>\r\n            </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xe000\" description=\"Schneider specific\" mfcode=\"0x105e\">\r\n          <attribute id=\"0xe001\" name=\"On Time Reload\" type=\"u32\" access=\"rw\" required=\"o\" mfcode=\"0x105e\">\r\n            <description>Defines number of  seconds before the light is switched off automaticaly. Time is in seconds.\r\n              Value 0 disables the functionality. When brightness is changed, or ON command is received, timer is always restarted.\r\n              Check On Time Reload Options for possible impulse modes (if attribute is implemented).</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <command id=\"00\" dir=\"recv\" name=\"Off\" required=\"m\">\r\n          <description>On receipt of this command, a device shall enter its 'Off' state. This state is device dependent, but it is recommended that it is used for power off or similar functions.</description>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"On\" required=\"m\">\r\n          <description>On receipt of this command, a device shall enter its 'On' state. This state is device dependent, but it is recommended that it is used for power on or similar functions.</description>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Toggle\" required=\"m\">\r\n          <description>On receipt of this command, if a device is in its ‘Off’ state it shall enter its 'On' state. Otherwise, if it is in its ‘On’ state it shall enter its 'Off' state.</description>\r\n        </command>\r\n        <command id=\"40\" dir=\"recv\" name=\"Off with effect\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Effect identifier\" required=\"m\" default=\"0x00\">\r\n              <description>The effect identifier field specifies the fading effect to use.</description>\r\n              <value name=\"Delayed all off\" value=\"0x00\"></value>\r\n              <value name=\"Dying light\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Effect variant\" required=\"m\" default=\"0x00\">\r\n              <description>The effect identifier field specifies the effect variant to use.</description>\r\n              <value name=\"Fade off in 0.8s (Delayed all off)/20% dim up in 0.5s then off in 1s (Dying light)\" value=\"0x00\"></value>\r\n              <value name=\"No fade (Delayed all off)\" value=\"0x01\"></value>\r\n              <value name=\"50% dim down in 0.8s then fade off in 12s (Delayed all off)\" value=\"0x02\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"41\" dir=\"recv\" name=\"On with recall global scene\" required=\"m\">\r\n          <description>The on with recall global scene command allows the recall of the light settings when the light was turned off.</description>\r\n        </command>\r\n        <command id=\"42\" dir=\"recv\" name=\"On with timed off\" required=\"m\">\r\n          <description>Allows lamps to be turned on for a specific duration with a guarded off duration so that should the lamp be subsequently switched off, further on with timed off commands, received during this time, are prevented from turning the lamps back on.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"bmp8\" name=\"On/off control\" required=\"m\" default=\"0x00\">\r\n              <description>The effect identifier field specifies the fading effect to use.</description>\r\n              <value name=\"Accept only when on\" value=\"0\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"On time\" required=\"m\" default=\"0x0000\">\r\n              <description>Length of time (in 1/10ths second) that the lamp is to remain on.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Off wait time\" required=\"m\" default=\"0x0000\">\r\n              <description>Length of time (in 1/10ths second) that the lamp shall remain off.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <!-- Develco manufacturer specific -->\r\n        <command id=\"00\" dir=\"recv\" name=\"Safe Mode Off\" required=\"o\" mfcode=\"0x1015\">\r\n          <description>The 'Safe mode off' functionality is the same as \"Safe mode on\" the only different is relay entering off state instead of on state.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"SafeModeTime in Minutes\" required=\"m\" default=\"0x00\"/>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Safe Mode On\" required=\"o\" mfcode=\"0x1015\">\r\n          <description>If 'Safe mode On' command is sent to a relay with value 10 minutes, the relay will enter the safe mode after 10 minutes and force the relay to turn ON. If a standard OFF command from the On/Off cluster is sent within the first 10 minutes. The timer is restarted and the relay will not turn ON before the new 10 minute time has timed out. Sending the standard OFF command regularly within the 10 minute time interval will prevent the relay to enter safe mode ON state.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"SafeModeTime in Minutes\" required=\"m\" default=\"0x00\"/>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xde06\" name=\"RGB Color\">\r\n      <description>Attributes and commands for setting devices light color. The color is specified in the RGB range from 0 - 255.</description>\r\n      <server>\r\n        <attribute id=\"0000\" name=\"CurrentColorSet\" type=\"u32\" access=\"r\" default=\"0\" required=\"m\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0001\" name=\"ColorSetCount\" type=\"u8\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n        <command id=\"00\" dir=\"recv\" name=\"Set Color\" required=\"m\">\r\n          <description>On receipt of this command, the color of the light shall be changed and the current index updatet.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Red\" required=\"m\" default=\"0x00\" range=\"0x00,0xFF\" showas=\"slider\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Green\" required=\"m\" default=\"0x00\" range=\"0x00,0xFF\" showas=\"slider\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Blue\" required=\"m\" default=\"0x00\" range=\"0x00,0xFF\" showas=\"slider\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u8\" name=\"Set Index\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"bmp8\" name=\"Options\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Change colors\" value=\"0\"></value>\r\n              <value name=\"Use current preset\" value=\"1\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0007\" name=\"On/Off Switch Configuration\">\r\n      <description>Attributes and commands for configuring On/Off switching devices</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Switch Information\">\r\n          <attribute id=\"0x0000\" name=\"SwitchType\" type=\"enum8\" access=\"r\" default=\"0\" required=\"m\">\r\n            <description>The SwitchType attribute specifies the basic functionality of the On/Off switching device.</description>\r\n            <value name=\"Toggle\" value=\"0\">\r\n              <description>A switch with two physical states. An action by the user (e.g. toggling a rocker switch) moves the switch from state 1 to state 2. The switch then remains in that state until another action from the user returns it to state 1.</description>\r\n            </value>\r\n            <value name=\"Momentary\" value=\"1\">\r\n              <description>A switch with two physical states. An action by the user (e.g. pressing a button) moves the switch from state 1 to state 2. When the user ends his action (e.g. releases the button) the switch returns to state 1.</description>\r\n            </value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Switch Settings\">\r\n          <attribute id=\"0x0010\" name=\"SwitchActions\" type=\"enum8\" access=\"rw\" default=\"0\" required=\"m\">\r\n            <description>The SwitchActions attribute is 8-bits in length and specifies the commands of the On/Off cluster to be generated when the switch moves between its two states.</description>\r\n            <value name=\"On-Off\" value=\"0\"></value>\r\n            <value name=\"Off-On\" value=\"1\"></value>\r\n            <value name=\"Toggle\" value=\"2\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0008\" name=\"Level Control\">\r\n      <description>This cluster provides an interface for controlling a characteristic of a device that can be set to a level, for example the brightness of a light, the degree of closure of a door, or the power output of a heater.</description>\r\n      <server>\r\n        <attribute id = \"0x0000\" name=\"Current Level\" type=\"u8\" range=\"0x00,0xff\" access=\"r\" required=\"m\" default=\"0x00\">\r\n          <description>The CurrentLevel attribute represents the current level of this device. meaning of 'level' is device dependent.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0001\" name=\"Remaining Time\" type=\"u16\" range=\"0x0000,0xffff\" access=\"r\" required=\"o\" default=\"0x0000\">\r\n          <description>The RemainingTime attribute represents the time remaining until the current command is complete - it is specified in 1/10ths of a second.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0003\" name=\"Hue Min Dim Level\" type=\"u16\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n          <description>Percentage of the maximum lumen the device outputs on minimum brightness (in 0.001%).</description>\r\n        </attribute>\r\n        <attribute id = \"0x000f\" name=\"Options\" type=\"bmp8\" access=\"rw\" required=\"o\">\r\n          <value name=\"Execute If Off\" value=\"0\"></value>\r\n          <value name=\"Couple Color Temp To Level\" value=\"1\"></value>\r\n        </attribute>\r\n        <attribute id = \"0x0010\" name=\"OnOff Transistion Time\" type=\"u16\" range=\"0x0000,0xffff\" access=\"rw\" required=\"o\" default=\"0x0000\">\r\n          <description>The OnOffTransitionTime attribute represents the time taken to move to or from the target level when On of Off commands are received by an On/Off cluster on the same endpoint. It is specified in 1/10ths of a second. The actual time taken should be as close to OnOffTransitionTime as the device is able.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0011\" name=\"On Level\" type=\"u8\" range=\"0x01,0xff\" access=\"rw\" required=\"o\" default=\"0xff\">\r\n          <description>The OnLevel attribute determines the value that the CurrentLevel attribute is set to when the OnOff attribute of an On/Off cluster on the same endpoint is set to On. If the OnLevel attribute is not implemented, or is set to 0xff, it has no effect.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0012\" name=\"On Transition Time\" type=\"u16\" range=\"0x0000,0xfffe\" access=\"rw\" required=\"o\" default=\"0\">\r\n          <description>The OnTransitionTime attribute represents the time taken to move the current level from the minimum level to the maximum level when an On command is received by an On/Off cluster on the same endpoint. It is specified in 10ths of a second. If this command is not implemented, or contains a value of 0xffff, the On/OffTransitionTime will be used instead.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0013\" name=\"Off Transition Time\" type=\"u16\" range=\"0x0000,0xfffe\" access=\"rw\" required=\"o\" default=\"0\">\r\n          <description>The OffTransitionTime attribute represents the time taken to move the current level from the maximum level to the minimum level when an Off command is received by an On/Off cluster on the same endpoint. It is specified in 10ths of a second. If this command is not implemented, or contains a value of 0xffff, the On/OffTransitionTime will be used instead.</description>\r\n        </attribute>\r\n        <attribute id = \"0x0014\" name=\"Default Move Rate\" type=\"u8\" range=\"0x00,0xfe\" access=\"rw\" required=\"o\">\r\n          <description>The DefaultMoveRate attribute determines the movement rate, in units per second, when a Move command is received with a Rate parameter of 0xFF.</description>\r\n        </attribute>\r\n        <attribute id=\"0x4000\" name=\"StartUp Current Level\" type=\"u8\" access=\"rw\" required=\"o\"></attribute>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Move to Level\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Level\" required=\"m\" default=\"0x00\" range=\"0x00,0xff\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Transistion time\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Move\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Move mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Up\" value=\"0x00\"></value>\r\n              <value name=\"Down\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Rate\" required=\"m\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Step\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Up\" value=\"0x00\"></value>\r\n              <value name=\"Down\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Step size\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Stop\" required=\"m\">\r\n          <description></description>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Move to Level (with On/Off)\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Level\" required=\"m\" default=\"0x00\" range=\"0x00,0xff\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Transistion time\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Move (with On/Off)\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Move mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Up\" value=\"0x00\"></value>\r\n              <value name=\"Down\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Rate\" required=\"m\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Step (with On/Off)\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Up\" value=\"0x00\"></value>\r\n              <value name=\"Down\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Step size\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Stop (with On/Off)\" required=\"m\">\r\n          <description></description>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <!-- TODO commands -->\r\n      </client>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0009\" name=\"Alarms\">\r\n      <description>Sending alarm notifications and configuring alarm functionality.</description>\r\n      <!-- TODO -->\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Alarm Information\">\r\n          <attribute id=\"0x0000\" name=\"Alarm Count\" type=\"u16\" access=\"rw\" required=\"m\" default=\"0x00\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"send\" name=\"Alarm\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Alarm code\" default=\"0x00\" required=\"m\" showas=\"hex\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Cluster Id\" default=\"0x0000\" required=\"m\" showas=\"hex\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000a\" name=\"Time\">\r\n      <description>This cluster provides a basic interface to a real-time clock.</description>\r\n      <server>\r\n        <attribute id=\"0000\" name=\"Time\" type=\"utc\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0001\" name=\"Time Status\" type=\"bmp8\" default=\"0b00000000\" access=\"rw\" required=\"m\">\r\n          <value name=\"Master Clock\" value=\"0\"></value>\r\n          <value name=\"Synchronized\" value=\"1\"></value>\r\n          <value name=\"Master for Timezone and Dst\" value=\"2\"></value>\r\n          <value name=\"Superseding\" value=\"3\"></value>\r\n        </attribute>\r\n        <attribute id=\"0002\" name=\"Time Zone\" type=\"s32\" range=\"-86400,86400\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0003\" name=\"Dst Start\" type=\"u32\" range=\"0x00000000,0xfffffffe\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0004\" name=\"Dst End\" type=\"u32\" range=\"0x00000000,0xfffffffe\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0005\" name=\"Dst Shift\" type=\"s32\" range=\"-86400,86400\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0006\" name=\"Standard Time\" type=\"u32\" range=\"0x00000000,0xfffffffe\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0007\" name=\"Local Time\" type=\"u32\" range=\"0x00000000,0xfffffffe\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0008\" name=\"Last Set Time\" type=\"utc\" range=\"0x00000000,0xffffffff\" default=\"0xffffffff\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0009\" name=\"Valid Until Time\" type=\"utc\" range=\"0x00000000,0xffffffff\" default=\"0xffffffff\" access=\"rw\" required=\"o\"></attribute>\r\n        <!-- TODO -->\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000b\" name=\"Location\">\r\n      <description>Measure distance between devices.</description>\r\n      <server>\r\n        <command id=\"0x40\" dir=\"recv\" name=\"Distance measure\" required=\"m\" response=\"0x40\" showas=\"hex\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Target address\" required=\"m\" default=\"0x0000\" ></attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Resolution\" required=\"m\" default=\"0x00\">\r\n              <value name=\"High\" value=\"0x00\"></value>\r\n              <value name=\"Mid\" value=\"0x01\"></value>\r\n              <value name=\"Low\" value=\"0x02\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"0x40\" dir=\"recv\" name=\"Distance measure response\" required=\"m\">\r\n          <description>Returns the result of a distance measure.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Target address\" required=\"m\" default=\"0x0000\" showas=\"hex\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Distance (Meter)\" required=\"m\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Quality index\" required=\"m\" default=\"0\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000c\" name=\"Analog Input (Basic)\">\r\n      <description>An interface for reading the value of an analog measurement and accessing various characteristics of that measurement.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0041\" name=\"Max Present Value\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0045\" name=\"Min Present Value\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of service\" type=\"bool\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" name=\"Present value\" type=\"float\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x006a\" name=\"Resolution\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" name=\"Status flags\" type=\"bmp8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0075\" name=\"Engineering Units\" type=\"enum16\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n        <attribute id=\"0xff05\" name=\"Unknown\" type=\"u16\" required=\"o\" access=\"r\" default=\"0\" showas=\"hex\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000d\" name=\"Analog Output (Basic)\">\r\n      <description>The Analog Output (Basic) cluster provides an interface for setting the value of an analog output (typically to the environment) and accessing various characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0041\" name=\"Max Present Value\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0045\" name=\"Min Present Value\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of service\" type=\"bool\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" name=\"Present value\" type=\"float\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006a\" name=\"Resolution\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" name=\"Status flags\" type=\"bmp8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0075\" name=\"Engineering Units\" type=\"enum16\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n        <attribute id=\"0xf000\" name=\"Xiaomi 0xf000\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000e\" name=\"Analog Value (Basic)\">\r\n      <description>An interface for setting an analog value, typically used as a control system parameter, and accessing various characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of service\" type=\"bool\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" name=\"Present value\" type=\"float\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"float\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" name=\"Status flags\" type=\"bmp8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0075\" name=\"Engineering Units\" type=\"enum16\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x000f\" name=\"Binary Input (Basic)\">\r\n      <description>The Binary Input (Basic) cluster provides an interface for reading the value of a binary measurement and accessing various characteristics of that measurement. The cluster is typically used to implement a sensor that measures a two-state physical quantity.</description>\r\n      <server>\r\n        <attribute id=\"0x0004\" name=\"Active Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0x002e\" name=\"Inactive Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of Service\" type=\"bool\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0054\" name=\"Polarity\" type=\"enum8\" required=\"o\" access=\"r\">\r\n          <value name=\"Normal\" value=\"0\"></value>\r\n          <value name=\"Reverse\" value=\"1\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0055\" name=\"Present Value\" type=\"bool\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x006F\" name=\"Status Flags\" type=\"bmp8\" default=\"0\" access=\"r\" required=\"m\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n        <attribute-set id=\"0x8000\" description=\"Develco specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x8000\" name=\"IAS Activation\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n        <attribute-set id=\"0x8000\" description=\"Develco specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x8000\" name=\"OnWithTimeOff_OnTime\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8001\" name=\"OnWithTimeOff_OffWaitTime\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n        </attribute-set>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0010\" name=\"Binary Output (Basic)\">\r\n      <description>The Binary Output (Basic) cluster provides an interface for setting the value of a binary output, and accessing various characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x0004\" name=\"Active Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x002e\" name=\"Inactive Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x0042\" name=\"Min Off Time\" type=\"u32\" required=\"o\" access=\"rw\" default=\"0xffffffff\"></attribute>\r\n        <attribute id=\"0x0043\" name=\"Min On Time\" type=\"u32\" required=\"o\" access=\"rw\" default=\"0xffffffff\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of service\" type=\"bool\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0054\" name=\"Polarity\" type=\"enum8\" required=\"o\" access=\"r\">\r\n          <value name=\"Normal\" value=\"0\"></value>\r\n          <value name=\"Reverse\" value=\"1\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0055\" name=\"Present value\" type=\"bool\" required=\"m\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"bool\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" name=\"Status flags\" type=\"bmp8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n        <attribute-set id=\"0xff00\" description=\"Xiaomi Specific\" mfcode=\"0x1037\">\r\n          <attribute id=\"0xff06\" name=\"Interlock\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0011\" name=\"Binary Value (Basic)\">\r\n      <description>The Binary Value (Basic) cluster provides an interface for setting a binary value, typically used as a control system parameter, and accessing various characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x0004\" name=\"Active Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x002e\" name=\"Inactive Text\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x0042\" name=\"Min Off Time\" type=\"u32\" required=\"o\" access=\"rw\" default=\"0xffffffff\"></attribute>\r\n        <attribute id=\"0x0043\" name=\"Min On Time\" type=\"u32\" required=\"o\" access=\"rw\" default=\"0xffffffff\"></attribute>\r\n        <attribute id=\"0x0051\" name=\"Out of service\" type=\"bool\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" name=\"Present value\" type=\"bool\" required=\"m\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"bool\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" name=\"Status flags\" type=\"bmp8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0012\" name=\"Multistate Input (Basic)\">\r\n      <description>Provides an interface for reading the value of a multistate measurement and accessing various characteristics of that measurement. The cluster is typically used to implement a sensor that measures a physical quantity that can take on one of a number of discrete states.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x004a\" type=\"u16\" name=\"Number of states\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0051\" type=\"bool\" name=\"Out of service\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" type=\"u16\" name=\"Present value\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x006f\" type=\"bmp8\" name=\"Status flags\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0013\" name=\"Multistate Output (Basic)\">\r\n      <description>The Multistate Output (Basic) cluster provides an interface for setting the value of an output that can take one of a number of discrete values, and accessing characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x004a\" type=\"u16\" name=\"Number of states\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0051\" type=\"bool\" name=\"Out of service\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" type=\"u16\" name=\"Present value\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"u16\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" type=\"bmp8\" name=\"Status flags\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n        <attribute id=\"0xf000\" name=\"Xiaomi 0xf000\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0014\" name=\"Multistate Value (Basic)\">\r\n      <description>The Multistate Value (Basic) cluster provides an interface for setting a multistate value, typically used as a control system parameter, and accessing characteristics of that value.</description>\r\n      <server>\r\n        <attribute id=\"0x001c\" name=\"Description\" type=\"cstring\" required=\"o\" access=\"rw\" default=\"\"></attribute>\r\n        <attribute id=\"0x004a\" type=\"u16\" name=\"Number of states\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0051\" type=\"bool\" name=\"Out of service\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0055\" type=\"u16\" name=\"Present value\" required=\"m\" access=\"rw\" default=\"0\"></attribute>\r\n        <attribute id=\"0x0067\" name=\"Reliability\" type=\"enum8\" required=\"o\" access=\"rw\" default=\"0\">\r\n          <value name=\"No fault detected\" value=\"0\"></value>\r\n          <value name=\"No sensor\" value=\"1\"></value>\r\n          <value name=\"Over range\" value=\"2\"></value>\r\n          <value name=\"Under range\" value=\"3\"></value>\r\n          <value name=\"Open loop\" value=\"4\"></value>\r\n          <value name=\"Shorted loop\" value=\"5\"></value>\r\n          <value name=\"No output\" value=\"6\"></value>\r\n          <value name=\"Unreliable other\" value=\"7\"></value>\r\n          <value name=\"Process error\" value=\"8\"></value>\r\n          <value name=\"Multi state fault\" value=\"9\"></value>\r\n          <value name=\"Configuration error\" value=\"10\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0068\" name=\"Relinquish Default\" type=\"u16\" required=\"o\" access=\"rw\"></attribute>\r\n        <attribute id=\"0x006f\" type=\"bmp8\" name=\"Status flags\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"In Alarm\" value=\"0x01\"></value>\r\n          <value name=\"Fault\" value=\"0x02\"></value>\r\n          <value name=\"Overidden\" value=\"0x04\"></value>\r\n          <value name=\"Out of Service\" value=\"0x08\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0100\" name=\"Application Type\" type=\"u32\" required=\"o\" access=\"r\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0015\" name=\"Commissioning\">\r\n      <description>Attributes and commands for commissioning and managing a ZigBee device.</description>\r\n      <server>\r\n        <!-- TODO -->\r\n        <attribute-set id=\"0x0000\" description=\"Startup Parameters I\">\r\n          <attribute id=\"0x0000\" name=\"Short Address\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfff7\" showas=\"hex\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Extended PAN ID\" type=\"uid\" access=\"rw\" range=\"0x0000000000000000,0xfffffffffffffffe\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"PAN ID\" type=\"u16\" access=\"rw\" range=\"0x0000,0xffff\" showas=\"hex\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Channel Mask\" type=\"bmp32\" access=\"rw\" required=\"m\">\r\n            <value name=\"CH 11\" value=\"11\"></value>\r\n            <value name=\"CH 12\" value=\"12\"></value>\r\n            <value name=\"CH 13\" value=\"13\"></value>\r\n            <value name=\"CH 14\" value=\"14\"></value>\r\n            <value name=\"CH 15\" value=\"15\"></value>\r\n            <value name=\"CH 16\" value=\"16\"></value>\r\n            <value name=\"CH 17\" value=\"17\"></value>\r\n            <value name=\"CH 18\" value=\"18\"></value>\r\n            <value name=\"CH 19\" value=\"19\"></value>\r\n            <value name=\"CH 20\" value=\"20\"></value>\r\n            <value name=\"CH 21\" value=\"21\"></value>\r\n            <value name=\"CH 22\" value=\"22\"></value>\r\n            <value name=\"CH 23\" value=\"23\"></value>\r\n            <value name=\"CH 24\" value=\"24\"></value>\r\n            <value name=\"CH 25\" value=\"25\"></value>\r\n            <value name=\"CH 26\" value=\"26\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0004\" name=\"Protocol Version\" type=\"u8\" access=\"rw\" default=\"0x02\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0005\" name=\"Stack Profile\" type=\"u8\" access=\"rw\" range=\"0x01,0x02\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0006\" name=\"Startup Control\" type=\"enum8\" access=\"rw\" required=\"m\">\r\n            <value name=\"Part of the network\" value=\"0x00\"></value>\r\n            <value name=\"Form a network\" value=\"0x01\"></value>\r\n            <value name=\"Rejoin the network\" value=\"0x02\"></value>\r\n            <value name=\"Start from scratch\" value=\"0x03\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Startup Parameters II\">\r\n          <attribute id=\"0x0010\" name=\"Trust Center Address\" type=\"uid\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Trust Center Master Key\" type=\"seckey\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Network Key\" type=\"seckey\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Use Insecure Join\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Preconfigured Link Key\" type=\"seckey\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Network Key Seq Num\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"Network Key Type\" type=\"enum8\" access=\"rw\" required=\"m\">\r\n            <value name=\"Standard\" value=\"0x01\"></value>\r\n            <value name=\"High Security\" value=\"0x05\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0017\" name=\"Network Manager Address\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Join Parameters\">\r\n          <attribute id=\"0x0020\" name=\"Scan Attemps\" type=\"u8\" access=\"rw\" range=\"0x01,0xff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0021\" name=\"Time Between Scans\" type=\"u16\" access=\"rw\" range=\"0x0001,0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0022\" name=\"Rejoin Interval\" type=\"u16\" access=\"rw\" range=\"0x0001,0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0023\" name=\"Max Rejoin Interval\" type=\"u16\" access=\"rw\" range=\"0x0001,0xffff\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"End Device Parameters\">\r\n          <attribute id=\"0x0030\" name=\"Indirect Poll Rate\" type=\"u16\" access=\"rw\" range=\"0x0000,0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0030\" name=\"Parent Retry Threshold\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0040\" description=\"Concentrator Parameters\">\r\n          <attribute id=\"0x0040\" name=\"Concentrator Flag\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0041\" name=\"Concentrator Radius\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0042\" name=\"Concentrator Discovery Time\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xde00\" description=\"DE Setup Parameters\">\r\n          <attribute id=\"0xde01\" name=\"MAC Address\" type=\"uid\" access=\"rw\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"00\" dir=\"recv\" name=\"Restart Device\" required=\"m\" response=\"0x00\">\r\n          <description>The Restart Device command is used to optionally install a set of startup parameters in a device and run the startup procedure so as to put the new values into effect. The new values may take effect immediately or after an optional delay with optional jitter. The server will send a Restart Device Response command back to the client device before executing the procedure or starting the countdown timer required to time the delay.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Options\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"m\">\r\n              <value name=\"Don't replace attributes on restart\" value=\"0\"></value>\r\n              <value name=\"Immediate\" value=\"1\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Delay\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Jitter\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Save Startup Parameters\" required=\"o\" response=\"0x01\">\r\n          <description>The Save Startup Parameters Request command allows for the current attribute set to be stored under a given index.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Options\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Index\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Restore Startup Parameters\" required=\"o\" response=\"0x02\">\r\n          <description>This command allows a saved startup parameters attribute set to be restored to current status overwriting whatever was there previously.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Options\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Index\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"03\" dir=\"recv\" name=\"Reset Startup Parameters\" required=\"m\" response=\"0x03\">\r\n          <description>This command allows current startup parameters attribute set and one or all of the saved attribute sets to be set to default values. There is also an option for erasing the index under which an attribute set is saved thereby freeing up storage capacity.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Options\" type=\"bmp8\" default=\"00000000\" access=\"rw\" required=\"m\">\r\n              <value name=\"Reset Current\" value=\"0\"></value>\r\n              <value name=\"Reset All\" value=\"1\"></value>\r\n              <value name=\"Erase Index\" value=\"2\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Index\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"00\" dir=\"recv\" name=\"Restart Device Response\" required=\"m\">\r\n          <description>On receipt of this command the client is made aware that the server has received the corresponding request and is informed of the status of the request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Status\" type=\"enum8\" access=\"rw\" required=\"m\" enumeration=\"ZCL_Status\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Save Startup Parameters Response\" required=\"m\">\r\n          <description>On receipt of this command the client is made aware that the server has received the corresponding request and is informed of the status of the request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Status\" type=\"enum8\" access=\"rw\" required=\"m\" enumeration=\"ZCL_Status\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Restore Startup Parameters Response\" required=\"m\">\r\n          <description>On receipt of this command the client is made aware that the server has received the corresponding request and is informed of the status of the request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Status\" type=\"enum8\" access=\"rw\" required=\"m\" enumeration=\"ZCL_Status\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"03\" dir=\"recv\" name=\"Reset Startup Parameters Response\" required=\"m\">\r\n          <description>On receipt of this command the client is made aware that the server has received the corresponding request and is informed of the status of the request.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" name=\"Status\" type=\"enum8\" access=\"rw\" required=\"m\" enumeration=\"ZCL_Status\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0019\" name=\"OTAU\">\r\n      <description>Over the air upgrade.</description>\r\n      <client>\r\n        <attribute id=\"0x0000\" name=\"Upgrade server\" type=\"uid\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"File Offset\" type=\"u32\" default=\"0xffffffff\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Current File Version\" type=\"u32\" default=\"0xffffffff\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Current ZigBee Stack Version\" type=\"u16\" default=\"0xffff\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"Downloaded File Version\" type=\"u32\" default=\"0xffffffff\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0005\" name=\"Downloaded ZigBee Stack Version\" type=\"u16\" default=\"0xffff\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0006\" name=\"Image upgrade status\" type=\"enum8\" default=\"0x04\" access=\"rw\" required=\"m\">\r\n          <value name=\"Normal\" value=\"0\"></value>\r\n          <value name=\"Download in progress\" value=\"1\"></value>\r\n          <value name=\"Download complete\" value=\"2\"></value>\r\n          <value name=\"Waiting to upgrade\" value=\"3\"></value>\r\n          <value name=\"Count down\" value=\"4\"></value>\r\n          <value name=\"Wait for more\" value=\"5\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0007\" name=\"Manufacturer ID\" type=\"u16\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0008\" name=\"Image Type ID\" type=\"u16\" access=\"r\" required=\"o\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0009\" name=\"Min block request delay\" type=\"u16\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <command id=\"0x01\" dir=\"send\" name=\"Query next image\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"bmp8\" name=\"Control field\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Hardware version present\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" showas=\"hex\" name=\"Manufacturer ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"enum16\" name=\"Image type\" required=\"m\" default=\"0x0000\">\r\n              <value name=\"Specific image\" value=\"0x0000\"></value>\r\n              <value name=\"Security credential\" value=\"0xFFC0\"></value>\r\n              <value name=\"Configuration\" value=\"0xFFC1\"></value>\r\n              <value name=\"Log\" value=\"0xFFC2\"></value>\r\n              <value name=\"Wild card\" value=\"0xFFFF\"></value>\r\n            </attribute>\r\n            <!--  Firmware Version -->\r\n            <attribute id=\"0x0003\" type=\"u8\" showas=\"hex\" name=\"Application Release\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" showas=\"hex\" name=\"Application Build\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0005\" type=\"u8\" showas=\"hex\" name=\"Stack Release\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0006\" type=\"u8\" showas=\"hex\" name=\"Stack Build\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Upgrade end response\" required=\"m\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" showas=\"hex\" name=\"Manufacturer ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" showas=\"hex\" name=\"Image type\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u32\" showas=\"hex\" name=\"File version\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u32\" showas=\"hex\" name=\"Current time\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u32\" showas=\"hex\" name=\"Upgrade time\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n      <server>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0020\" name=\"Poll Control\">\r\n      <description>Provides a mechanism for the management of an end device’s MAC Data Request rate.</description>\r\n      <client>\r\n      </client>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Check-in Interval\" type=\"u32\" default=\"0x3840\" access=\"rw\" required=\"m\" range=\"0x0,0x6e0000\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Long Poll Interval\" type=\"u32\" default=\"0x14\" access=\"r\" required=\"m\" range=\"0x04,0x6e0000\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Short Poll Interval\" type=\"u16\" default=\"0x02\" access=\"r\" required=\"m\" range=\"0x01,0xffff\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Fast Poll Timeout\" type=\"u16\" default=\"0x028\" access=\"rw\" required=\"m\" range=\"0x01,0xffff\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"Check-in Interval Min\" type=\"u32\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0005\" name=\"Long Poll Interval Min\" type=\"u32\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0006\" name=\"Fast Poll Timeout Max\" type=\"u16\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n        <command id=\"0x00\" dir=\"send\" name=\"Check-in\" required=\"m\">\r\n          <description>The Poll Control Cluster server sends out a Check-in command to the devices to which it is paired based on the server‘s Check-inInterval attribute. It does this to find out if any of the Poll Control Cluster Clients with which it is paired are interested in having it enter fast poll mode so that it can be managed. This request is sent out based on either the Check-inInterval, or the next Check-in value in the Fast Poll Stop Request generated by the Poll Control Cluster Client.</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"send\" name=\"Stop\" required=\"m\">\r\n          <description>send Fast Poll Stop</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Set Long Poll Interval\" required=\"o\">\r\n          <description>Sets the Read Only LongPollInterval attribute.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u32\" showas=\"hex\" name=\"New Long Poll Interval\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Set Short Poll Interval\" required=\"o\">\r\n          <description>Sets the Read Only ShortPollInterval attribute.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" showas=\"hex\" name=\"New Short Poll Interval\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0800\" name=\"Key Establishment\">\r\n      <description></description>\r\n      <client></client>\r\n      <server></server>\r\n      <!-- TODO -->\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Closures\" low_bound=\"0100\" high_bound=\"01ff\" description=\"The closures functional domain contains clusters and information to build devices in the closure domain, e.g. shade controllers.\">\r\n    <cluster id=\"0x0100\" name=\"Shade Configuration\">\r\n      <description></description>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0100\" name=\"Shade Configuration\">\r\n      <description>The shade configuration cluster provides an interface for reading information about a shade, and configuring its open and closed limits.</description>\r\n      <client>\r\n      </client>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Shade Information Attribute Set\">\r\n          <attribute id=\"0x0000\" name=\"Physical Closed Limit\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"MotorStepSize\" type=\"u8\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Status\" type=\"bmp8\" access=\"rw\" required=\"m\">\r\n            <value name=\"Shade operational\" value=\"0\"></value>\r\n            <value name=\"Shade adjusting\" value=\"1\"></value>\r\n            <value name=\"Shade direction\" value=\"2\"></value>\r\n            <value name=\"Direction Reversed\" value=\"3\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Shade Settings Attribute Set\">\r\n          <attribute id=\"0x0010\" name=\"Closed Limit\" type=\"u16\" access=\"rw\" range=\"0x0001,0xfffe\" default=\"0x0001\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Mode\" type=\"enum8\" access=\"rw\" default=\"0x00\" required=\"m\">\r\n            <value name=\"Normal\" value=\"0x00\"></value>\r\n            <value name=\"Configure\" value=\"0x01\"></value>\r\n            <value name=\"Invalid\" value=\"0xff\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0101\" name=\"Door Lock\">\r\n      <description>The door lock cluster provides an interface to a generic way to secure a door.</description>\r\n      <client>\r\n      </client>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Basic Information Attribute Set\">\r\n          <attribute id=\"0x0000\" name=\"Lock State\" type=\"enum8\" access=\"r\" required=\"m\">\r\n            <value name=\"Not fully locked\" value=\"0x00\"></value>\r\n            <value name=\"Locked\" value=\"0x01\"></value>\r\n            <value name=\"Unlocked\" value=\"0x02\"></value>\r\n            <value name=\"Undefined\" value=\"0xff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0001\" name=\"Lock Type\" type=\"enum8\" access=\"r\" required=\"m\">\r\n            <value name=\"Dead bolt\" value=\"0x00\"></value>\r\n            <value name=\"Magnetic\" value=\"0x01\"></value>\r\n            <value name=\"Other\" value=\"0x02\"></value>\r\n            <value name=\"Mortise\" value=\"0x03\"></value>\r\n            <value name=\"Rim\" value=\"0x04\"></value>\r\n            <value name=\"Latch Bolt\" value=\"0x05\"></value>\r\n            <value name=\"Cylindrical Lock\" value=\"0x06\"></value>\r\n            <value name=\"Tubular Lock\" value=\"0x07\"></value>\r\n            <value name=\"Interconnected Lock\" value=\"0x08\"></value>\r\n            <value name=\"Dead Latch\" value=\"0x09\"></value>\r\n            <value name=\"Door Furniture\" value=\"0x0A\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0002\" name=\"Actuator enabled\" type=\"bool\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Door state\" type=\"enum8\" access=\"r\" required=\"m\">\r\n            <value name=\"Open\" value=\"0x00\"/>\r\n            <value name=\"Closed\" value=\"0x01\"/>\r\n            <value name=\"Error jammed\" value=\"0x02\"/>\r\n            <value name=\"Error forced open\" value=\"0x03\"/>\r\n            <value name=\"Error unspecified\" value=\"0x04\"/>\r\n            <value name=\"Undefined\" value=\"0xff\"/>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"User, PIN, Schedule Information Attribute Set\">\r\n          <attribute id=\"0x0010\" name=\"Number Of Log Records Supported\" type=\"u16\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Number Of Total Users Supported\" type=\"u16\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Number Of PIN Users Supported\" type=\"u16\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Number Of RFID Users Supported\" type=\"u16\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Number Of WeekDay Schedules Supported Per User\" type=\"u8\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Number Of Year Day Schedules Supported Per User\" type=\"u8\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"Number Of Holiday Schedules Supported\" type=\"u8\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0017\" name=\"Max PIN length\" type=\"u8\" access=\"r\" required=\"o\"/>\r\n          <attribute id=\"0x0018\" name=\"Min PIN length\" type=\"u8\" access=\"r\" required=\"o\"/>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Operational Settings Attribute Set\">\r\n          <attribute id=\"0x0020\" name=\"Enable Logging\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0021\" name=\"Language\" type=\"cstring\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0022\" name=\"Led Setting\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Never use LED for signalization\" value=\"0x00\"></value>\r\n            <value name=\"Use LED signalization except for access allowed events\" value=\"0x01\"></value>\r\n            <value name=\"Use LED signalization for all events\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0023\" name=\"Auto Relock Time\" type=\"u32\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0024\" name=\"Sound Volume\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Silent Mode\" value=\"0x00\"></value>\r\n            <value name=\"Low Volume\" value=\"0x01\"></value>\r\n            <value name=\"Hight Volume\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0025\" name=\"Operating mode\" type=\"enum8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Normal\" value=\"0x00\"></value>\r\n            <value name=\"Vacation\" value=\"0x01\"></value>\r\n            <value name=\"Privacy\" value=\"0x02\"></value>\r\n            <value name=\"No RF Lock/Unlock\" value=\"0x03\"></value>\r\n            <value name=\"Passage\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0026\" name=\"Supported operating mode\" type=\"bmp16\" default=\"0x0000\" access=\"r\" required=\"o\">\r\n            <value name=\"Normal Mode Supported\" value=\"0\"></value>\r\n            <value name=\"Vacation Mode Supported\" value=\"1\"></value>\r\n            <value name=\"Privacy Mode Supported\" value=\"2\"></value>\r\n            <value name=\"No RF Lock or Unlock Mode Supported\" value=\"3\"></value>\r\n            <value name=\"Passage Mode Supported\" value=\"4\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0027\" name=\"Default Configuration Register\" type=\"bmp16\" default=\"0x0000\" access=\"r\" required=\"o\">\r\n            <value name=\"Enable Local Programming\" value=\"0\"></value>\r\n            <value name=\"Keypad Interface\" value=\"1\"></value>\r\n            <value name=\"RF Interface\" value=\"2\"></value>\r\n            <value name=\"Sound Volume attribute\" value=\"5\"></value>\r\n            <value name=\"Auto Relock Time attribute\" value=\"6\"></value>\r\n            <value name=\"Led Settings attribute\" value=\"7\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0028\" name=\"Enable Local Programming\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0029\" name=\"Enable One TouchLocking\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x002A\" name=\"Enable Inside Status LED\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x002B\" name=\"Enable Privacy ModeButton\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Security Settings Attribute Set\">\r\n          <attribute id=\"0x0030\" name=\"Wrong Code Entry Limit\" type=\"u8\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0031\" name=\"User Code Temporary Disable Time\" type=\"u8\" default=\"0\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0032\" name=\"Send PIN Over The Air\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0033\" name=\"Require PIN for RF Operation\" type=\"bool\" default=\"0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0034\" name=\"Zigbee Security Level\" type=\"enum8\" default=\"0\" access=\"r\" required=\"o\">\r\n            <value name=\"Network Security\" value=\"0x00\"></value>\r\n            <value name=\"APS Security\" value=\"0x01\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0040\" description=\"Alarm and Event Masks Attribute Set\">\r\n          <attribute id=\"0x0040\" name=\"Alarm Mask\" type=\"bmp16\" default=\"0x0000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Deadbolt Jammed\" value=\"0\"></value>\r\n            <value name=\"Lock Reset to Factory Defaults\" value=\"1\"></value>\r\n            <value name=\"Reserved\" value=\"2\"></value>\r\n            <value name=\"RF Module Power Cycled\" value=\"3\"></value>\r\n            <value name=\"Tamper Alarm – wrong code entry limit\" value=\"4\"></value>\r\n            <value name=\"Tamper Alarm - front escutcheon removed from main\" value=\"5\"></value>\r\n            <value name=\"Forced Door Open under Door Locked Condition\" value=\"6\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0042\" name=\"RF Operation Event Mask\" type=\"bmp16\" default=\"0x0000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Unknown or manufacturer-specific RF operation event\" value=\"0\"></value>\r\n            <value name=\"Lock, source: RF\" value=\"1\"></value>\r\n            <value name=\"Unlock, source: RF\" value=\"2\"></value>\r\n            <value name=\"Lock, source: RF, error: invalid code\" value=\"3\"></value>\r\n            <value name=\"Lock, source: RF, error: invalid schedule\" value=\"4\"></value>\r\n            <value name=\"Unlock, source: RF, error: invalid code\" value=\"5\"></value>\r\n            <value name=\"Unlock, source: RF, error: invalid schedule\" value=\"6\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0043\" name=\"Manual Operation Event Mask\" type=\"bmp16\" default=\"0x0000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Unknown or manufacturer-specific manual operation event\" value=\"0\"></value>\r\n            <value name=\"Thumbturn Lock\" value=\"1\"></value>\r\n            <value name=\"Thumbturn Unlock\" value=\"2\"></value>\r\n            <value name=\"One touch lock\" value=\"3\"></value>\r\n            <value name=\"Key Lock\" value=\"4\"></value>\r\n            <value name=\"Key Unlock\" value=\"5\"></value>\r\n            <value name=\"Auto lock\" value=\"6\"></value>\r\n            <value name=\"Schedule Lock\" value=\"7\"></value>\r\n            <value name=\"Schedule Unlock\" value=\"8\"></value>\r\n            <value name=\"Manual Lock (Key or Thumbturn)\" value=\"9\"></value>\r\n            <value name=\"Manual Unlock (Key or Thumbturn)\" value=\"10\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0050\" description=\"Xiaomi Special\" mfcode=\"0x1037\">\r\n          <attribute id=\"0x0055\" name=\"Event Type\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0503\" name=\"Tilt Angle\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0505\" name=\"Vibration Strength\" type=\"u32\" showas=\"hex\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0508\" name=\"Orientation\" type=\"u48\" showas=\"hex\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x4000\" description=\"ID Lock special\" mfcode=\"0x1337\">\r\n          <attribute id=\"0x4000\" name=\"Master PIN mode\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x1337\"/>\r\n          <attribute id=\"0x4001\" name=\"RFID Enabled\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x1337\"/>\r\n          <attribute id=\"0x4002\" name=\"Hinge mode\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x1337\"/>\r\n          <attribute id=\"0x4003\" name=\"Service PIN mode\" type=\"u8\" access=\"rw\" required=\"m\" mfcode=\"0x1337\">\r\n            <value name=\"Deactivated\" value=\"0x00\"/>\r\n            <value name=\"1x use\" value=\"0x01\"/>\r\n            <value name=\"2x uses\" value=\"0x02\"/>\r\n            <value name=\"5x uses\" value=\"0x03\"/>\r\n            <value name=\"10x uses\" value=\"0x04\"/>\r\n            <value name=\"Random PIN 1x use\" value=\"0x05\"/>\r\n            <value name=\"Random PIN 24 hours\" value=\"0x06\"/>\r\n            <value name=\"Always valid\" value=\"0x07\"/>\r\n            <value name=\"12 hours\" value=\"0x08\"/>\r\n            <value name=\"24 hours\" value=\"0x09\"/>\r\n          </attribute>\r\n          <attribute id=\"0x4004\" name=\"Lock mode\" type=\"u8\" access=\"rw\" required=\"m\" mfcode=\"0x1337\">\r\n            <value name=\"Auto lock OFF/Away mode OFF\" value=\"0x00\"/>\r\n            <value name=\"Auto lock ON/Away mode OFF\" value=\"0x01\"/>\r\n            <value name=\"Auto lock OFF/Away mode ON\" value=\"0x02\"/>\r\n            <value name=\"Auto lock ON/Away mode ON\" value=\"0x03\"/>\r\n          </attribute>\r\n          <attribute id=\"0x4005\" name=\"Relock enabled\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x1337\"/>\r\n          <attribute id=\"0x4006\" name=\"Audio volume\" type=\"u8\" access=\"rw\" required=\"m\" mfcode=\"0x1337\">\r\n            <value name=\"Volume off\" value=\"0x00\"/>\r\n            <value name=\"1\" value=\"0x01\"/>\r\n            <value name=\"2\" value=\"0x02\"/>\r\n            <value name=\"3\" value=\"0x03\"/>\r\n            <value name=\"4\" value=\"0x04\"/>\r\n            <value name=\"5\" value=\"0x05\"/>\r\n          </attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Lock Door\" required=\"m\">\r\n          <description>This command causes the lock device to lock the door.</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Unlock Door\" required=\"m\">\r\n          <description>This command causes the lock device to unlock the door.</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Toggle Door\" required=\"o\">\r\n          <description>This command toggle the lock device.</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Unlock with timer\" required=\"o\">\r\n          <description>This command Unlock the lock device but with a timer.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Timeout\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Get Log Record\" required=\"o\">\r\n          <description>Request a log record.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Log Index\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"send\" name=\"Get Log Record Response\" required=\"m\">\r\n          <description>Returns the specified log record.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Log Entry ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u32\" name=\"Timestamp\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"enum8\" name=\"Event Type\" required=\"m\">\r\n              <value name=\"Operation\" value=\"0\"></value>\r\n              <value name=\"Programming\" value=\"1\"></value>\r\n              <value name=\"Alarm\" value=\"2\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u8\" name=\"Source\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" name=\"Event ID/Alarm Code\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0005\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0006\" type=\"cstring\" name=\"PIN\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Set PIN code\" required=\"o\">\r\n          <description>Set PIN-code for user. User ID is between 0 and [# of PIN Users Supported Attribute]</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"User Status\" required=\"o\">\r\n              <value name=\"Occupied/Enabled\" value=\"1\" />\r\n              <value name=\"Occupied/Disabled\" value=\"3\" />\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"enum8\" name=\"User Type\" required=\"o\">\r\n              <value name=\"Unrestricted\" value=\"0\"/>\r\n              <value name=\"Year Day Schedule User\" value=\"1\"/>\r\n              <value name=\"Week Day Schedule User\" value=\"2\"/>\r\n              <value name=\"Master User\" value=\"3\"/>\r\n              <value name=\"Non Access User\" value=\"4\"/>\r\n              <value name=\"Not Supported\" value=\"0xff\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"ostring\" name=\"Code\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"send\" name=\"Set PIN code response\" required=\"o\">\r\n          <description>Status</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Status\" required=\"m\">\r\n              <value name=\"Success\" value=\"0\" />\r\n              <value name=\"Fail\" value=\"1\" />\r\n              <value name=\"Memory full\" value=\"2\" />\r\n              <value name=\"Duplicate code error\" value=\"3\" />\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Get PIN code\" required=\"o\">\r\n          <description>Get PIN code for user. User ID is between 0 and [# of PIN Users Supported Attribute]</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"send\" name=\"Get PIN code response\" required=\"o\">\r\n          <description>Returns PIN-code for user.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"User Status\" required=\"o\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"enum8\" name=\"User Type\" required=\"o\">\r\n              <value name=\"Unrestricted\" value=\"0\"/>\r\n              <value name=\"Year Day Schedule User\" value=\"1\"/>\r\n              <value name=\"Week Day Schedule User\" value=\"2\"/>\r\n              <value name=\"Master User\" value=\"3\"/>\r\n              <value name=\"Non Access User\" value=\"4\"/>\r\n              <value name=\"Not Supported\" value=\"0xff\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"ostring\" name=\"Code\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Clear PIN code\" required=\"o\">\r\n          <description>Clear PIN code for user. User ID is between 0 and [# of PIN Users Supported Attribute]</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"send\" name=\"Clear PIN code response\" required=\"o\">\r\n          <description>Status</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Status\" required=\"m\">\r\n              <value name=\"Success\" value=\"0\" />\r\n              <value name=\"General failure\" value=\"1\" />\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"Clear all PIN codes\" required=\"o\">\r\n          <description>Clear all registred PIN codes.</description>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"send\" name=\"Clear all PIN codes response\" required=\"o\">\r\n          <description>Status</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Status\" required=\"m\">\r\n              <value name=\"Success\" value=\"0\" />\r\n              <value name=\"General failure\" value=\"1\" />\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x20\" dir=\"send\" name=\"Operationg Event Notification\" required=\"o\">\r\n          <description>The door lock server sends out operation event notification when the event is triggered by the various event sources.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Operation Event Source\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Operation Event Code\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"User ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0003\" type=\"u8\" name=\"PIN\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u32\" name=\"ZigBee Local Time\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0005\" type=\"cstring\" name=\"Data\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0102\" name=\"Window Covering\">\r\n      <description>The window covering cluster provides an interface for controlling and adjusting automatic window coverings such as drapery motors, automatic shades, and blinds.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Window Covering Information\">\r\n          <attribute id=\"0x0000\" name=\"Window Covering Type\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"m\">\r\n            <value name=\"Rollershade\" value=\"0\"></value>\r\n            <value name=\"Rollershade - 2 Motor\" value=\"1\"></value>\r\n            <value name=\"Rollershade – Exterior\" value=\"2\"></value>\r\n            <value name=\"Rollershade - Exterior - 2 Motor\" value=\"3\"></value>\r\n            <value name=\"Drapery\" value=\"4\"></value>\r\n            <value name=\"Awning\" value=\"5\"></value>\r\n            <value name=\"Shutter\" value=\"6\"></value>\r\n            <value name=\"Tilt Blind - Tilt Only\" value=\"7\"></value>\r\n            <value name=\"Tilt Blind - Lift and Tilt\" value=\"8\"></value>\r\n            <value name=\"Projector Screen\" value=\"9\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0001\" name=\"Physical Closed Limit – Lift\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Physical Closed Limit – Tilt\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Current Position – Lift\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Current Position – Tilt\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0005\" name=\"Number of Actuations – Lift\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0006\" name=\"Number of Actuations – Tilt\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0007\" name=\"Config / Status\" type=\"bmp8\" default=\"0x03\" access=\"r\" required=\"o\">\r\n            <value name=\"Operational\" value=\"0\"></value>\r\n            <value name=\"Online\" value=\"1\"></value>\r\n            <value name=\"Commands Reversed\" value=\"2\"></value>\r\n            <value name=\"Lift control is Closed Loop\" value=\"3\"></value>\r\n            <value name=\"Tilt control is Closed Loop\" value=\"4\"></value>\r\n            <value name=\"Lift: Encoder Controlled\" value=\"5\"></value>\r\n            <value name=\"Tilt: Encoder Controlled\" value=\"6\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0008\" name=\"Current Position Lift Percentage\" type=\"u8\" default=\"0x00\" access=\"r\" required=\"o\" range=\"0,0x64\"></attribute>\r\n          <attribute id=\"0x0009\" name=\"Current Position Tilt Percentage\" type=\"u8\" default=\"0x00\" access=\"r\" required=\"o\" range=\"0,0x64\"></attribute>\r\n          <attribute id=\"0x000a\" name=\"Operational Status\" type=\"bmp8\" required=\"m\" access=\"r\">\r\n            <value name=\"Covering is opening\" value=\"0\"></value>\r\n            <value name=\"Covering is closing\" value=\"1\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Window Covering Settings\">\r\n          <attribute id=\"0x0010\" name=\"Installed Open Limit – Lift\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Installed Closed Limit – Lift\" type=\"u16\" default=\"0xffff\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Installed Open Limit – Tilt\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Installed Open Limit – Tilt\" type=\"u16\" default=\"0xffff\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Velocity – Lift\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Acceleration Time – Lift\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"Deceleration Time – Lift\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0017\" name=\"Mode\" type=\"bmp8\" default=\"0x0000\" access=\"rw\" required=\"o\">\r\n            <value name=\"Reversed\" value=\"0\"></value>\r\n            <value name=\"Calibration Mode\" value=\"1\"></value>\r\n            <value name=\"Maintenance Mode\" value=\"2\"></value>\r\n            <value name=\"LED feedback\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0018\" name=\"Intermediate Setpoints – Lift\" type=\"ostring\" default=\"1,0x0000\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0019\" name=\"Intermediate Setpoints – Tilt\" type=\"ostring\" default=\"1,0x0000\" access=\"rw\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xf000\" description=\"Tuya specific Window Covering Setting\">\r\n          <attribute id=\"0xf000\" name=\"Window cover status\" type=\"enum8\" required=\"m\" access=\"rw\">\r\n            <value name=\"Up/open\" value=\"0\"></value>\r\n            <value name=\"Down/close\" value=\"1\"></value>\r\n            <value name=\"Stop\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0xf001\" name=\"Calibration\" type=\"enum8\" default=\"0\" required=\"m\" access=\"rw\">\r\n            <value name=\"Start\" value=\"0\"></value>\r\n            <value name=\"End\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0xf002\" name=\"Motor Reversal\" type=\"enum8\" default=\"0\" required=\"m\" access=\"rw\">\r\n            <value name=\"Off\" value=\"0\"></value>\r\n            <value name=\"On\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0xf003\" name=\"Calibration time (tenth of a second)\" type=\"u16\" default=\"0x0000\" required=\"m\" access=\"rw\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xe000\" description=\"Schneider specific\" mfcode=\"0x105e\">\r\n          <attribute id=\"0xe000\" name=\"Drive Close Duration\" type=\"u16\" default=\"120\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Obsolete (only because backward compatibility).\r\n              Driving time from fully open to fully close state in seconds. If possible, use Lift Drive Up Time, Lift Drive Down Time.\r\n              If you set this time, also both (Lift Drive Up Time, Lift Drive Down Time) are set to this value automatically.</description>\r\n          </attribute>\r\n          <attribute id=\"0xe010\" name=\"Protection Status\" type=\"bmp8\" required=\"o\" access=\"r\" mfcode=\"0x105e\">\r\n            <description>The Protection Status attribute specifies the status of the different protections of the device. Can be active only\r\n              if Protection Sensor attribute is set (protection sensor as external device must be connected to device).\r\n              Bit0: 0 = sun protection not active, 1 = sun protection active.\r\n              Other bits reserved.</description>\r\n            <value name=\"Sun protection active\" value=\"0\"></value>\r\n          </attribute>\r\n          <attribute id=\"0xe012\" name=\"Sun Protection Illuminance Threshold\" type=\"u16\" default=\"32767\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Default value in lux is 1862 Lux. Value in attribute = 10000 x log10 1862 = 10000 x3.26 = around 32767.\r\n              The Sun Protection Illuminance Threshold attribute specifies the illuminance level above which the device enters Sun Protection mode\r\n              if enabled (if ProtectionSensor attribute is set = protection sensor is connected to device).\r\n              Sun Protection Illuminance Threshold represents illuminance in Lux (symbol lx) as follows:\r\n              Sun Protection Illuminance Threshold = 10,000 x log10 Illuminance\r\n              Where 1lx gt Illuminance gt 3.576 Mlx, corresponding to a SunProtectionIlluminanceThreshold in the range 0 to 0xfffe. A value of 0xffff indicates that this attribute is not valid.</description>\r\n          </attribute>\r\n          <attribute id=\"0xe013\" name=\"Protection Sensor\" type=\"bmp8\" required=\"m\" access=\"r\" mfcode=\"0x105e\">\r\n            <description>The ProtectionSensor attribute specifies if the sun protection sensor (as external device) is connected or device\r\n              receives measurement from a type of protection sensor (either local wired or wireless).\r\n              Bit0: 0 = sun protection sensor not connected, 1 = sun protection sensor connected\r\n              Other bits reserved.</description>\r\n            <value name=\"Sun protection sensor connected\" value=\"0\"></value>\r\n          </attribute>\r\n          <attribute id=\"0xe014\" name=\"Lift Drive Up Time\" type=\"u16\" default=\"1200\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Driving time from fully close to fully open state in1 /10 seconds.</description>\r\n          </attribute>\r\n          <attribute id=\"0xe015\" name=\"Lift Drive Down Time\" type=\"u16\" default=\"1200\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Driving time from fully open to fully close state in 1/10 seconds.</description>\r\n          </attribute>\r\n          <attribute id=\"0xe016\" name=\"Tilt Open Close And Step Time\" type=\"u16\" default=\"100\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Time from fully open to fully close tilt position in 1/100 seconds. This time is also taken as base for calculation of\r\n              step size in Schneider manufacture specific command Stop Or Step Lift Percentage. If set to 0, WindosCoveringType attribute is automatically set to 0 (lift only)</description>\r\n          </attribute>\r\n          <attribute id=\"0xe017\" name=\"Tilt Position Percentage After Move To Level\" type=\"u8\" default=\"0xFF\" required=\"o\" access=\"rw\" mfcode=\"0x105e\">\r\n            <description>Tilt position in percent adopted by tilt after receiving go to lift percentage command. Values 0-100 are absolute position of\r\n              tilt with following meaning:\r\n              100: Position of tilt when shutter is moving up (usually up).\r\n              0: Position of tilt when shutter is moving down (usually down).\r\n              255: No action after command.\r\n              101-254: Tilt position before movement is restored.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0000\" description=\"Ubisys specific\" mfcode=\"0x10f2\">\r\n          <attribute id=\"0x0000\" name=\"Window Covering Type\" type=\"enum8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\">\r\n            <value name=\"Rollershade\" value=\"0\"></value>\r\n            <value name=\"Rollershade - 2 Motor\" value=\"1\"></value>\r\n            <value name=\"Rollershade – Exterior\" value=\"2\"></value>\r\n            <value name=\"Rollershade - Exterior - 2 Motor\" value=\"3\"></value>\r\n            <value name=\"Drapery\" value=\"4\"></value>\r\n            <value name=\"Awning\" value=\"5\"></value>\r\n            <value name=\"Shutter\" value=\"6\"></value>\r\n            <value name=\"Tilt Blind - Tilt Only\" value=\"7\"></value>\r\n            <value name=\"Tilt Blind - Lift and Tilt\" value=\"8\"></value>\r\n            <value name=\"Projector Screen\" value=\"9\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0007\" name=\"Config and Status\" type=\"bmp8\" default=\"0x03\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\">\r\n            <value name=\"Operational\" value=\"0\"></value>\r\n            <value name=\"Online\" value=\"1\"></value>\r\n            <value name=\"Commands Reversed\" value=\"2\"></value>\r\n            <value name=\"Lift control is Closed Loop\" value=\"3\"></value>\r\n            <value name=\"Tilt control is Closed Loop\" value=\"4\"></value>\r\n            <value name=\"Lift: Encoder Controlled\" value=\"5\"></value>\r\n            <value name=\"Tilt: Encoder Controlled\" value=\"6\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0010\" name=\"Installed Open Limit – Lift\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Installed Closed Limit – Lift\" type=\"u16\" default=\"0xffff\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Installed Open Limit – Tilt\" type=\"u16\" default=\"0x0000\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Installed Open Limit – Tilt\" type=\"u16\" default=\"0xffff\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1000\" name=\"Turnaround Guard Time\" type=\"u8\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1001\" name=\"Lift to Tilt Transition Steps\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1002\" name=\"Total Steps\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1003\" name=\"Lift to Tilt Transition Steps 2\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1004\" name=\"Total Steps 2\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1005\" name=\"Additional Steps\" type=\"u8\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1006\" name=\"Inactive Power Threshold\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1007\" name=\"Startup Steps\" type=\"u16\" default=\"0\" required=\"m\" access=\"rw\" mfcode=\"0x10f2\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Up / Open\" required=\"m\"></command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Down / Close\" required=\"m\"></command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Stop\" required=\"m\"></command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Go To Lift Value\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Lift Value\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Go to Lift Percentage\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Lift Percentage\" required=\"m\" default=\"0x00\" range=\"0,0x64\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Go to Tilt Value\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Tilt Value\" required=\"m\" default=\"0x0000\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"Go to Tilt Percentage\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Tilt Percentage\" required=\"m\" default=\"0x00\" range=\"0,0x64\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"HVAC\" low_bound=\"0200\" high_bound=\"02ff\" description=\"The HVAC functional domain contains clusters and information to build devices in the HVAC domain, e.g. pumps.\">\r\n    <cluster id=\"0x0200\" name=\"Pump Configuration and Control\">\r\n      <description>An interface for configuring and controlling pumps.</description>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0201\" name=\"Thermostat\">\r\n      <description>Thermostat control cluster attributes and commands.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Thermostat Information\">\r\n          <attribute id=\"0x0000\" name=\"Local Temperature\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Outdoor Temperature\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Occupancy\" type=\"bmp8\" access=\"r\" required=\"o\" default=\"0\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Abs Min Heat Setpoint Limit\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"o\" default=\"0x02bc\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Abs Max Heat Setpoint Limit\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"o\" default=\"0x0bb8\"></attribute>\r\n          <attribute id=\"0x0005\" name=\"Abs Min Cool Setpoint Limit\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"o\" default=\"0x0640\"></attribute>\r\n          <attribute id=\"0x0006\" name=\"Abs Max Cool Setpoint Limit\" type=\"s16\" range=\"0x954d,0x7fff\" access=\"r\" required=\"o\" default=\"0x0c80\"></attribute>\r\n          <attribute id=\"0x0007\" name=\"PI Cooling Demand\" type=\"u8\" range=\"0x00,0x64\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0008\" name=\"PI Heating Demand\" type=\"u8\" range=\"0x00,0x64\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0009\" name=\"HVAC System Type Configuration\" type=\"bmp8\" access=\"rw\" required=\"o\" default=\"0\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Thermostat Settings\">\r\n          <attribute id=\"0x0010\" name=\"Local Temperature Calibration\" type=\"s8\" default=\"0x00\" range=\"0xe7,0x19\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Occupied Cooling Setpoint\" type=\"s16\" default=\"0x0a28\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Occupied Heating Setpoint\" type=\"s16\" default=\"0x07d0\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Unoccupied Cooling Setpoint\" type=\"s16\" default=\"0x0a28\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Unoccupied Heating Setpoint\" type=\"s16\" default=\"0x07d0\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Min Heat Setpoint Limit\" type=\"s16\" default=\"0x02bc\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"Max Heat Setpoint Limit\" type=\"s16\" default=\"0x0bb8\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0017\" name=\"Min Cool Setpoint Limit\" type=\"s16\" default=\"0x0640\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0018\" name=\"Max Cool Setpoint Limit\" type=\"s16\" default=\"0x0c80\" range=\"0x954d,0x7fff\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0019\" name=\"Min Setpoint Dead Band\" type=\"s8\" default=\"0x19\" range=\"0x0a,0x19\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x001a\" name=\"Remote Sensing\" type=\"bmp8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Local temperature sensed remotely\" value=\"0\"></value>\r\n            <value name=\"Outdoor temperature sensed remotely\" value=\"1\"></value>\r\n            <value name=\"Occupancy sensed remotely\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x001b\" name=\"Control Sequence Of Operation\" type=\"enum8\" default=\"0x04\" access=\"rw\" required=\"m\">\r\n            <value name=\"Cooling Only\" value=\"0\"></value>\r\n            <value name=\"Cooling With Reheat\" value=\"1\"></value>\r\n            <value name=\"Heating Only\" value=\"2\"></value>\r\n            <value name=\"Heating With Reheat\" value=\"3\"></value>\r\n            <value name=\"Cooling and Heating 4-pipes\" value=\"4\"></value>\r\n            <value name=\"Cooling and Heating 4-pipes with Reheat\" value=\"5\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x001c\" name=\"System Mode\" type=\"enum8\" default=\"0x01\" access=\"rw\" required=\"m\">\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"Auto\" value=\"0x01\"></value>\r\n            <value name=\"Cool\" value=\"0x03\"></value>\r\n            <value name=\"Heat\" value=\"0x04\"></value>\r\n            <value name=\"Emergency heating\" value=\"0x05\"></value>\r\n            <value name=\"Precooling\" value=\"0x06\"></value>\r\n            <value name=\"Fan only\" value=\"0x07\"></value>\r\n            <value name=\"Dry\" value=\"0x08\"></value>\r\n            <value name=\"Sleep\" value=\"0x09\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x001d\" name=\"Alarm Mask\" type=\"bmp8\" default=\"0\" access=\"r\" required=\"o\">\r\n            <value name=\"Initialization failure\" value=\"0\"></value>\r\n            <value name=\"Hardware failure\" value=\"1\"></value>\r\n            <value name=\"Self-calibration failure\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x001e\" name=\"Thermostat Running Mode\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"o\">\r\n            <value name=\"Off\" value=\"0\"></value>\r\n            <value name=\"Cool\" value=\"3\"></value>\r\n            <value name=\"Heat\" value=\"4\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Thermostat Schedule and HVAC Relay\">\r\n          <attribute id=\"0x0020\" name=\"Start of Week\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"o\">\r\n            <value name=\"Sunday\" value=\"0\"></value>\r\n            <value name=\"Monday\" value=\"1\"></value>\r\n            <value name=\"Tuesday\" value=\"2\"></value>\r\n            <value name=\"Wednesday\" value=\"3\"></value>\r\n            <value name=\"Thursday\" value=\"4\"></value>\r\n            <value name=\"Friday\" value=\"5\"></value>\r\n            <value name=\"Saturday\" value=\"6\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0021\" name=\"Number of Weekly Transitions\" type=\"u8\" range=\"0x00,0xff\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0022\" name=\"Number of Daily Transitions\" type=\"u8\" range=\"0x00,0xff\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0023\" name=\"Temperature Setpoint Hold\" type=\"enum8\" default=\"0x00\" access=\"rw\" required=\"o\">\r\n            <value name=\"Setpoint Hold Off\" value=\"0\"></value>\r\n            <value name=\"Setpoint Hold On\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0024\" name=\"Temperature Setpoint Hold Duration\" type=\"u16\" range=\"0x05a0,0xffff\" default=\"0xffff\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0025\" name=\"Thermostat Programming Operation Mode\" type=\"bmp8\" default=\"0\" access=\"rw\" required=\"o\">\r\n            <value name=\"Simple/setpoint mode\" value=\"0\">\r\n              <description>0 – This mode means the thermostat setpoint is altered only by manual up/down changes at the thermostat or remotely, not by internal schedule programming.\r\n1 – Schedule programming mode. This enables or disables any programmed weekly schedule con-figurations.\r\nNote: It does not clear or delete previous weekly schedule programming configurations.</description>\r\n            </value>\r\n            <value name=\"Auto/recovery mode\" value=\"1\"></value>\r\n            <value name=\"Economy/EnergyStar mode\" value=\"2\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0029\" description=\"HVAC Relay\">\r\n          <attribute id=\"0x0029\" name=\"Thermostat Running State\" type=\"bmp16\" access=\"r\" required=\"o\">\r\n            <value name=\"Heat State On\" value=\"0\"></value>\r\n            <value name=\"Cool State On\" value=\"1\"></value>\r\n            <value name=\"Fan State On\" value=\"2\"></value>\r\n            <value name=\"Heat 2nd Stage State On\" value=\"3\"></value>\r\n            <value name=\"Cool 2nd Stage State On\" value=\"4\"></value>\r\n            <value name=\"Fan 2nd Stage State On\" value=\"5\"></value>\r\n            <value name=\"Fan 3rd Stage State On\" value=\"6\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Thermostat Setpoint Change Tracking\">\r\n          <attribute id=\"0x0030\" name=\"Setpoint Change Source\" type=\"enum8\" access=\"r\" required=\"o\">\r\n            <value name=\"Manual\" value=\"0\"></value>\r\n            <value name=\"Schedule\" value=\"1\"></value>\r\n            <value name=\"Zigbee\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0031\" name=\"Setpoint Change Amount\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"/>\r\n          <attribute id=\"0x0032\" name=\"Setpoint Change Timestamp\" type=\"utc\" access=\"r\" required=\"o\" default=\"0\"/>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0040\" description=\"AC Information\">\r\n          <attribute id=\"0x0040\" name=\"AC Type\" type=\"enum8\" access=\"rw\" required=\"o\">\r\n            <value name=\"Cooling and Fixed Speed\" value=\"1\"></value>\r\n            <value name=\"Heat Pump and Fixed Speed\" value=\"2\"></value>\r\n            <value name=\"Cooling and Inverter\" value=\"3\"></value>\r\n            <value name=\"Heat Pump and Inverter\" value=\"4\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0041\" name=\"AC Capacity\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x00\"/>\r\n          <attribute id=\"0x0042\" name=\"AC Refrigerant Type\" type=\"enum8\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <value name=\"R22\" value=\"1\"></value>\r\n            <value name=\"R410a\" value=\"2\"></value>\r\n            <value name=\"R407c\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0043\" name=\"AC Compressor Type\" type=\"enum8\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <value name=\"T1, Max working ambient 43 oC\" value=\"1\"></value>\r\n            <value name=\"T2, Max working ambient 35 oC\" value=\"2\"></value>\r\n            <value name=\"T3, Max working ambient 52 oC\" value=\"3\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0044\" name=\"AC Error Code\" type=\"bmp32\" access=\"rw\" required=\"o\" default=\"0x00000000\">\r\n            <value name=\"Compressor Failure or Refrigerant Leakage\" value=\"0\"></value>\r\n            <value name=\"Room Temperature Sensor Failure\" value=\"1\"></value>\r\n            <value name=\"Outdoor Temperature Sensor Failure\" value=\"2\"></value>\r\n            <value name=\"Indoor Coil Temperature Sensor Failure\" value=\"3\"></value>\r\n            <value name=\"Fan Failure\" value=\"4\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0045\" name=\"AC Louver Position\" type=\"enum8\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <value name=\"Fully Closed\" value=\"1\"></value>\r\n            <value name=\"Fully Open\" value=\"2\"></value>\r\n            <value name=\"Quarter Open\" value=\"3\"></value>\r\n            <value name=\"Half Open\" value=\"4\"></value>\r\n            <value name=\"Three Quarters Open\" value=\"5\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0046\" name=\"AC Coil Temperature\" type=\"s16\" access=\"r\" required=\"o\"/>\r\n          <attribute id=\"0x0047\" name=\"AC Capacity Format\" type=\"enum8\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <value name=\"BTUh\" value=\"0\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0080\" description=\"eCozy\" mfcode=\"0x1014\">\r\n          <attribute id=\"0x0080\" name=\"Unknown\" type=\"s16\" access=\"r\" required=\"o\"/>\r\n          <attribute id=\"0x0081\" name=\"Unknown\" type=\"s16\" access=\"r\" required=\"o\"/>\r\n          <attribute id=\"0x0082\" name=\"Unknown (Heat Setpoint?)\" type=\"s16\" access=\"r\" required=\"o\"/>\r\n        </attribute-set>\r\n        <!-- ubisys manufacturer specific -->\r\n        <attribute-set id=\"0x0000\" description=\"Ubisys specific\" mfcode=\"0x10f2\">\r\n          <attribute id=\"0x0000\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Unknown\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Unknown\" type=\"s16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0009\" name=\"Unknown\" type=\"u16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000a\" name=\"Unknown\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000b\" name=\"Unknown\" type=\"s8\" access=\"r\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000c\" name=\"Unknown\" type=\"s8\" access=\"r\" required=\"m\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000d\" name=\"Unknown\" type=\"u8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000e\" name=\"Unknown\" type=\"u8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x000f\" name=\"Unknown\" type=\"u8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0010\" name=\"TemperatureOffset\" type=\"s8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"DefaultOccupiedHeatingSetpoint\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"VacationMode\" type=\"bool\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"RemoteTemperature\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"RemoteTemperatureValidDuration\" type=\"88\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"DetectOpenWindow\" type=\"bmp8\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"OpenWindowState\" type=\"bmp8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0017\" name=\"OpenWindowSensitivity\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0018\" name=\"OpenWindowDetectionPeriod\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0019\" name=\"OpenWindowTimeout\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x001a\" name=\"HeatingDemandLowerBound\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x001b\" name=\"HeatingDemandUpperBound\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x001c\" name=\"Season\" type=\"enum8\" access=\"rw\" required=\"m\" mfcode=\"0x10f2\">\r\n              <value name=\"winter\" value=\"0x00\"></value>\r\n              <value name=\"summer\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x001d\" name=\"BackupHeatingDemand\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x001e\" name=\"AlternateBackupHeatingDemand\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0020\" name=\"ProportionalGain\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0021\" name=\"ProportionalShift\" type=\"s8\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x0022\" name=\"IntegralFactor\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1000\" name=\"ValveDrivePosition0\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n          <attribute id=\"0x1001\" name=\"ValveDrivePosition100 \" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x10f2\"></attribute>\r\n        </attribute-set>\r\n        <!-- Sinope manufacturer specific -->\r\n        <attribute-set id=\"0x0400\" description=\"Sinope specific\" mfcode=\"0x119c\">\r\n          <attribute id=\"0x0400\" name=\"Occupancy\" type=\"enum8\" access=\"rw\" required=\"m\" mfcode=\"0x119c\">\r\n              <value name=\"Unoccupied\" value=\"0x00\"></value>\r\n              <value name=\"Occupied\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0401\" name=\"Main Cycle Output\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x119c\">\r\n            <description>Number of second</description>\r\n          </attribute>\r\n            <attribute id=\"0x0402\" name=\"Backlight\" type=\"enum8\" access=\"rw\" required=\"m\" mfcode=\"0x119c\">\r\n              <value name=\"On demand\" value=\"0x00\"></value>\r\n              <value name=\"Always ON\" value=\"0x01\"></value>\r\n          </attribute>\r\n            <attribute id=\"0x0404\" name=\"Aux Cycle Output\" type=\"u16\" access=\"rw\" required=\"m\" mfcode=\"0x119c\">\r\n            <description>Number of second</description>\r\n          </attribute>\t\t\t\r\n        </attribute-set>\r\n        <!-- ELKO specific -->\r\n        <attribute-set id=\"0x0400\" description=\"ELKO specific\" mfcode=\"0x1002\">\r\n          <attribute id=\"0x0401\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0402\" name=\"Unknown name field\" type=\"cstring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0403\" name=\"Temperature measurement\" type=\"enum8\" access=\"rw\" required=\"m\">\r\n            <value name=\"Air sensor\" value=\"0x00\"></value>\r\n            <value name=\"Floor sensor\" value=\"0x01\"></value>\r\n            <value name=\"Floor protection\" value=\"0x03\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0404\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0405\" name=\"Regulator mode\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0406\" name=\"Device on\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0407\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0408\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0409\" name=\"Floor temperature sensor\" type=\"s16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0411\" name=\"Night lowering\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0412\" name=\"Unknown\" type=\"bool\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0413\" name=\"Child lock\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0414\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0415\" name=\"Heating active/inactive\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0416\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0417\" name=\"Unknown\" type=\"s8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0418\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0419\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <!-- Eurotronic manufacturer specific -->\r\n        <attribute-set id=\"0x4000\" description=\"Eurotronic\" mfcode=\"0x1037\">\r\n          <attribute id=\"0x4000\" name=\"TRV Mode\" type=\"enum8\" default=\"0x02\" access=\"rw\" required=\"m\" mfcode=\"0x1037\">\r\n            <value name=\"Unknown 1\" value=\"0\"></value>\r\n            <value name=\"Unknown 2\" value=\"1\"></value>\r\n            <value name=\"manual\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4001\" name=\"Set Valve Position\" type=\"u8\" default=\"0x00\" access=\"rw\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n          <attribute id=\"0x4002\" name=\"Errors\" type=\"u8\" default=\"0x00\" access=\"r\" required=\"m\" mfcode=\"0x1037\">\r\n            <value name=\"Reserved\" value=\"0\"></value>\r\n            <value name=\"Reserved\" value=\"1\"></value>\r\n            <value name=\"Reserved\" value=\"2\"></value>\r\n            <value name=\"Valve Adaption Failed (E1)\" value=\"3\"></value>\r\n            <value name=\"Valve Movement too slow (E2)\" value=\"4\"></value>\r\n            <value name=\"Valve not Moving (E3)\" value=\"5\"></value>\r\n            <value name=\"Reserved\" value=\"6\"></value>\r\n            <value name=\"Reserved\" value=\"7\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4003\" name=\"Current Temperature Setpoint\" type=\"s16\" default=\"0x07d0\" access=\"rw\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n          <attribute id=\"0x4008\" name=\"Host Flags\" type=\"u24\" default=\"0x000000\" showas=\"hex\" access=\"rw\" required=\"m\" mfcode=\"0x1037\"></attribute>\r\n        </attribute-set>\r\n        <!-- Danfoss manufacturer specific -->\r\n        <attribute-set id=\"0x4000\" description=\"Danfoss specific\" mfcode=\"0x1246\">\r\n          <attribute id=\"0x4000\" name=\"eTRV Open Window Detection\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Quarantine\" value=\"0x00\"></value>\r\n            <value name=\"Closed\" value=\"0x01\"></value>\r\n            <value name=\"Hold\" value=\"0x02\"></value>\r\n            <value name=\"Open\" value=\"0x03\"></value>\r\n            <value name=\"Windows open from external, but detected closed\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4003\" name=\"External Open Window Detected\" type=\"bool\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4010\" name=\"Exercise day of week\" type=\"enum8\" default=\"0x04\" access=\"rw\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Sunday\" value=\"0x00\"></value>\r\n            <value name=\"Monday\" value=\"0x01\"></value>\r\n            <value name=\"Tuesday\" value=\"0x02\"></value>\r\n            <value name=\"Wednesday\" value=\"0x03\"></value>\r\n            <value name=\"Thursday\" value=\"0x04\"></value>\r\n            <value name=\"Friday\" value=\"0x05\"></value>\r\n            <value name=\"Saturday\" value=\"0x06\"></value>\r\n            <value name=\"Undefined\" value=\"0x07\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4011\" name=\"Exercise trigger time\" type=\"u16\" default=\"660\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4012\" name=\"Mounting mode active\" type=\"bool\" default=\"0x01\" access=\"r\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4013\" name=\"Mounting mode control\" type=\"bool\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4014\" name=\"eTRV Orientation\" type=\"bool\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4015\" name=\"External Measured Room Sensor\" type=\"s16\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4016\" name=\"Radiator Covered\" type=\"bool\" access=\"w\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4020\" name=\"Control Algorithm Scale Factor\" type=\"u8\" default=\"1\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4030\" name=\"Heat Available\" type=\"bool\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4031\" name=\"Heat Supply Request \" type=\"bool\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4032\" name=\"Load Balancing Enabled\" type=\"bool\" default=\"0x01\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4040\" name=\"Load Radiator Room Mean\" type=\"s16\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x404A\" name=\"Load Estimate (Radiator)\" type=\"s16\" access=\"r\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x404B\" name=\"Regulation SetPoint Offset\" type=\"s8\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x404C\" name=\"Adaptation Run Control\" type=\"enum8\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Idle\" value=\"0x00\"></value>\r\n            <value name=\"Initiate Adaptation Run\" value=\"0x01\"></value>\r\n            <value name=\"Cancel Adaptation Run\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x404D\" name=\"Adaptation Run Status\" type=\"bmp8\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Adaptation Run in Progress\" value=\"0\"></value>\r\n            <value name=\"OP Found\" value=\"1\"></value>\r\n            <value name=\"OP Lost\" value=\"2\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x404E\" name=\"Adaptation Run Settings\" type=\"bmp8\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Default\" value=\"0\"></value>\r\n            <value name=\"Automatic Adaptation Run Enabled\" value=\"1\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x404F\" name=\"Preheat Status\" type=\"bool\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4050\" name=\"Preheat Time\" type=\"u32\" access=\"r\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4051\" name=\"Window Open Feature On\" type=\"bool\" default=\"0x01\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n        </attribute-set>\r\n        <!-- Stelpro manufacturer specific -->\r\n        <attribute-set id=\"0x4000\" description=\"Stelpro specific\" mfcode=\"0x1185\">\r\n          <attribute id=\"0x4001\" name=\"Outdoor temp\" type=\"s16\" access=\"rw\" required=\"m\" mfcode=\"0x1185\"></attribute>\r\n          <attribute id=\"0x401c\" name=\"System Mode\" type=\"enum8\" default=\"0x04\" access=\"rw\" required=\"m\" mfcode=\"0x1185\">\r\n            <value name=\"Off\" value=\"0x00\"/>\r\n            <value name=\"Heat\" value=\"0x04\"/>\r\n            <value name=\"Eco\" value=\"0x05\"/>\r\n            <description>States only supportedb by Stelpro thermostats (useless for Maestro).</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <!-- Sunrichee manufacturer specific -->\r\n        <attribute-set id=\"0x1000\" description=\"Sunricher Specific Attributes\" mfcode=\"0x1224\">\r\n          <attribute id=\"0x1000\" name=\"Display LED Brightness\" type=\"enum8\" access=\"rw\" default=\"0x01\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>OLED brightness when operating the buttons.  Default: Medium.</description>\r\n            <value name=\"Low\" value=\"0x00\"></value>\r\n            <value name=\"Medium\" value=\"0x01\"></value>\r\n            <value name=\"High\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1001\" name=\"Button Vibration Level\" type=\"enum8\" access=\"rw\" default=\"0x00\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Key beep volume and vibration level.  Default: Low.</description>\r\n            <value name=\"Off\" value=\"0x0000\"></value>\r\n            <value name=\"Low\" value=\"0x0001\"></value>\r\n            <value name=\"High\" value=\"0x0002\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1002\" name=\"Floor Sensor Type\" type=\"enum8\" access=\"rw\" default=\"0x01\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Type of the external floor sensor.  Default: NTC 10K/25.</description>\r\n            <value name=\"NTC 10K/25\" value=\"0x01\"></value>\r\n            <value name=\"NTC 15K/25\" value=\"0x02\"></value>\r\n            <value name=\"NTC 50K/25\" value=\"0x03\"></value>\r\n            <value name=\"NTC 100K/25\" value=\"0x04\"></value>\r\n            <value name=\"NTC 12K/25\" value=\"0x05\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1003\" name=\"Control Type\" type=\"enum8\" access=\"rw\" default=\"0x00\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The sensor used for heat control.  Default: Room Sensor.</description>\r\n            <value name=\"Room Sensor\" value=\"0x00\"></value>\r\n            <value name=\"Floor Sensor\" value=\"0x01\"></value>\r\n            <value name=\"Room Sensor + Floor Sensor\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1004\" name=\"PowerUp Status\" type=\"enum8\" access=\"rw\" default=\"0x00\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The mode after a power reset.  Default: Previous Mode.</description>\r\n            <value name=\"Default Mode\" value=\"0x00\"></value>\r\n            <value name=\"Previous Mode\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1005\" name=\"Floor Sensor Calibration\" type=\"s8\" access=\"rw\" default=\"0\" range=\"-30,30\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The tempearatue calibration for the exernal floor sensor, between -30 and 30 in 0.1°C.  Default: 0.</description>\r\n          </attribute>\r\n          <attribute id=\"0x1006\" name=\"Dry Time\" type=\"u8\" access=\"rw\" default=\"5\" range=\"5,100\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The duration of Dry Mode, between 5 and 100 minutes.  Default: 5.</description>\r\n          </attribute>\r\n          <attribute id=\"0x1007\" name=\"Mode After Dry\" type=\"enum8\" access=\"rw\" default=\"0x02\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The mode after Dry Mode.  Default: Schedule.</description>\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"Manual\" value=\"0x01\"></value>\r\n            <value name=\"Schedule\" value=\"0x02\"></value>\r\n            <value name=\"Away\" value=\"0x03\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1008\" name=\"Temperature Display\" type=\"enum8\" access=\"rw\" default=\"0x02\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The temperature on the display.  Default: Room Temperature.</description>\r\n            <value name=\"Room Temperature\" value=\"0x00\"></value>\r\n            <value name=\"Floor Temperature\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x1009\" name=\"Window Open Detection\" type=\"u8\" access=\"rw\" default=\"0\" range=\"0,8\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>The threshold to detect window open, between 3 and 8 in 0.5 °C.  Default: 0 (disabled).</description>\r\n          </attribute>\r\n          <attribute id=\"0x100A\" name=\"Hysteresis\" type=\"u8\" access=\"rw\" default=\"5\" range=\"5,20\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Hysteresis setting, between 5 and 20 in 0.1 °C.  Default: 5.</description>\r\n          </attribute>\r\n          <attribute id=\"0x2001\" name=\"Alarm Air Temperature\" type=\"u8\" access=\"rw\" default=\"45\" range=\"0,60\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Room temperature alarm threshold, between 20 and 60 in °C.  0 means disabled.  Default: 45.</description>\r\n          </attribute>\r\n          <attribute id=\"0x2002\" name=\"Away Mode\" type=\"enum8\" access=\"rw\" default=\"0x00\" required=\"m\" mfcode=\"0x1224\">\r\n            <description>Set Away Mode.  Default: Home.</description>\r\n            <value name=\"Home\" value=\"0x00\"></value>\r\n            <value name=\"Away\" value=\"0x01\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <!-- Danfoss manufacturer specific -->\r\n        <attribute-set id=\"0x4100\" description=\"Danfoss specific\" mfcode=\"0x1246\">\r\n          <attribute id=\"0x4100\" name=\"Room Status Code\" type=\"enum16\" default=\"0x0000\" access=\"r\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"No Error\" value=\"0x0000\"></value>\r\n            <value name=\"Missing RT\" value=\"0x0101\"></value>\r\n            <value name=\"RT Touch Error\" value=\"0x0201\"></value>\r\n            <value name=\"Floor Sensor Short Circuit\" value=\"0x0401\"></value>\r\n            <value name=\"Floor Sensor Disconnected\" value=\"0x0801\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4110\" name=\"Output Status\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Inactive\" value=\"0x00\"></value>\r\n            <value name=\"Active\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4120\" name=\"Room Floor Sensor Mode\" type=\"enum8\" default=\"0x00\" access=\"r\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Comfort Mode\" value=\"0x00\"></value>\r\n            <value name=\"Floor Sensor Mode\" value=\"0x01\"></value>\r\n            <value name=\"Dual Mode\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4121\" name=\"Floor Minimum Setpoint\" type=\"s16\" default=\"0x0708\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4121\" name=\"Floor Maximum Setpoint\" type=\"s16\" default=\"0x0DAC\" access=\"rw\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n          <attribute id=\"0x4130\" name=\"Schedule Type Used\" type=\"enum8\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1246\">\r\n            <value name=\"Regular Schedule\" value=\"0x00\"></value>\r\n            <value name=\"Vacation Schedule\" value=\"0x01\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <!-- Bosch manufacturer specific -->\r\n        <attribute-set id=\"0x4000\" description=\"Bosch specific\" mfcode=\"0x1209\">\r\n          <attribute id=\"0x4007\" name=\"Operating Mode\" type=\"enum8\" default=\"0x00\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Schedule\" value=\"0x00\"></value>\r\n            <value name=\"Manual\" value=\"0x01\"></value>\r\n            <value name=\"Off\" value=\"0x05\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4008\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4009\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x400A\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x400E\" name=\"Unknown\" type=\"bool\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x400F\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4020\" name=\"Valve Opening\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4021\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4022\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4023\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4024\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4040\" name=\"External Measured Room Sensor\" type=\"s16\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4041\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4042\" name=\"External Window Open Detection\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Closed\" value=\"0x00\"></value>\r\n            <value name=\"Open\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4043\" name=\"Boost\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"On\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4050\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x5000\" name=\"Error Code\" type=\"bmp8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x5010\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Setpoint Raise/Lower\" required=\"m\">\r\n          <description>This command increases (or decreases) the setpoint(s) by amount, in steps of 0.1°C.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Mode\" required=\"m\">\r\n              <value name=\"Heat (adjust Heat Setpoint)\" value=\"0x00\"></value>\r\n              <value name=\"Cool (adjust Cool Setpoint)\" value=\"0x01\"></value>\r\n              <value name=\"Both (adjust Heat Setpoint and Cool Setpoint)\" value=\"0x02\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"s8\" name=\"Amount\" required=\"m\">\r\n              <description>The amount field is a signed 8-bit integer that specifies the amount the setpoint(s) are to be a increased (or decreased) by, in steps of 0.1°C.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Set Weekly Schedule\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Number of Transtions for Sequence\" required=\"m\">\r\n              <value name=\"0\" value=\"0\"></value>\r\n              <value name=\"1\" value=\"1\"></value>\r\n              <value name=\"2\" value=\"2\"></value>\r\n              <value name=\"3\" value=\"3\"></value>\r\n              <value name=\"4\" value=\"4\"></value>\r\n              <value name=\"5\" value=\"5\"></value>\r\n              <value name=\"6\" value=\"6\"></value>\r\n              <value name=\"7\" value=\"7\"></value>\r\n              <value name=\"8\" value=\"8\"></value>\r\n              <value name=\"9\" value=\"9\"></value>\r\n              <value name=\"10\" value=\"10\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"bmp8\" name=\"Day of Week for Sequence\" required=\"m\">\r\n              <value name=\"Sunday\" value=\"0\"></value>\r\n              <value name=\"Monday\" value=\"1\"></value>\r\n              <value name=\"Tuesday\" value=\"2\"></value>\r\n              <value name=\"Wednesday\" value=\"3\"></value>\r\n              <value name=\"Thursday\" value=\"4\"></value>\r\n              <value name=\"Friday\" value=\"5\"></value>\r\n              <value name=\"Saturday\" value=\"6\"></value>\r\n              <value name=\"Vacation or Away\" value=\"7\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"bmp8\" name=\"Mode for Sequence\" required=\"m\">\r\n              <value name=\"Heat Setpoint Field Present in Payload\" value=\"0\"></value>\r\n              <value name=\"Cool Setpoint Field Present in Payload\" value=\"1\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Transition Time 1\" required=\"o\"/>\r\n            <attribute id=\"0x0004\" type=\"s16\" name=\"Heat Set Point 1\" required=\"o\"/>\r\n            <attribute id=\"0x0005\" type=\"u16\" name=\"Transition Time 2\" required=\"o\"/>\r\n            <attribute id=\"0x0006\" type=\"s16\" name=\"Heat Set Point 2\" required=\"o\"/>\r\n            <attribute id=\"0x0007\" type=\"u16\" name=\"Transition Time 3\" required=\"o\"/>\r\n            <attribute id=\"0x0008\" type=\"s16\" name=\"Heat Set Point 3\" required=\"o\"/>\r\n            <attribute id=\"0x0009\" type=\"u16\" name=\"Transition Time 4\" required=\"o\"/>\r\n            <attribute id=\"0x000A\" type=\"s16\" name=\"Heat Set Point 4\" required=\"o\"/>\r\n            <attribute id=\"0x000B\" type=\"u16\" name=\"Transition Time 5\" required=\"o\"/>\r\n            <attribute id=\"0x000C\" type=\"s16\" name=\"Heat Set Point 5\" required=\"o\"/>\r\n            <attribute id=\"0x000D\" type=\"u16\" name=\"Transition Time 6\" required=\"o\"/>\r\n            <attribute id=\"0x000E\" type=\"s16\" name=\"Heat Set Point 6\" required=\"o\"/>\r\n            <attribute id=\"0x000F\" type=\"u16\" name=\"Transition Time 7\" required=\"o\"/>\r\n            <attribute id=\"0x0010\" type=\"s16\" name=\"Heat Set Point 7\" required=\"o\"/>\r\n            <attribute id=\"0x0011\" type=\"u16\" name=\"Transition Time 8\" required=\"o\"/>\r\n            <attribute id=\"0x0012\" type=\"s16\" name=\"Heat Set Point 8\" required=\"o\"/>\r\n            <attribute id=\"0x0013\" type=\"u16\" name=\"Transition Time 9\" required=\"o\"/>\r\n            <attribute id=\"0x0014\" type=\"s16\" name=\"Heat Set Point 9\" required=\"o\"/>\r\n            <attribute id=\"0x0015\" type=\"u16\" name=\"Transition Time 10\" required=\"o\"/>\r\n            <attribute id=\"0x0016\" type=\"s16\" name=\"Heat Set Point 10\" required=\"o\"/>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Get Weekly Schedule\" required=\"o\" response=\"0x00\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"bmp8\" name=\"Days to Return\" required=\"m\">\r\n              <value name=\"Sunday\" value=\"0\"></value>\r\n              <value name=\"Monday\" value=\"1\"></value>\r\n              <value name=\"Tuesday\" value=\"2\"></value>\r\n              <value name=\"Wednesday\" value=\"3\"></value>\r\n              <value name=\"Thursday\" value=\"4\"></value>\r\n              <value name=\"Friday\" value=\"5\"></value>\r\n              <value name=\"Saturday\" value=\"6\"></value>\r\n              <value name=\"Vacation or Away\" value=\"7\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"bmp8\" name=\"Mode to Return\" required=\"m\">\r\n              <value name=\"Heat Setpoint Field Present in Payload\" value=\"0\"></value>\r\n              <value name=\"Cool Setpoint Field Present in Payload\" value=\"1\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Clear Weekly Schedule\" required=\"o\"></command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Get Relay Status Log\" required=\"o\"></command>\r\n        <!-- Danfoss manufacturer specific -->\r\n        <command id=\"0x40\" dir=\"recv\" name=\"Set Heating Setpoint\" required=\"o\" mfcode=\"0x1246\">\r\n          <description>Set immediately:\r\nThe actuator will make a large movement to minimize reaction time.\r\n\r\nMimic Occupied Heating Setpoint Behavior:\r\nThe behavior will be the same as setting the attribute \"Occupied Heating Setpoint\" to the same value.\r\n\r\nPreserve Displayed Setpoint:\r\nDisplayed setpoint is not affected, but regulated setpoint will change. Can be used for Forecast functionality.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Setpoint Type\" required=\"m\">\r\n              <value name=\"Set immediately\" value=\"0\"/>\r\n              <value name=\"Mimic Occupied Heating Setpoint Behavior\" value=\"1\"/>\r\n              <value name=\"Preserve Displayed Setpoint\" value=\"2\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Heating Setpoint\" required=\"m\"/>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Danfoss Test Command\" required=\"o\" mfcode=\"0x1246\"></command>\r\n        <command id=\"0x42\" dir=\"recv\" name=\"Preheat\" required=\"o\" mfcode=\"0x1246\">\r\n          <description>Request eTRV to enter pre-heat if in schedule mode and if other eTRV in same room has triggeed pre-heat.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Type\" required=\"m\">\r\n              <value name=\"Force Preheat\" value=\"0\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u32\" name=\"Timestamp\" required=\"m\">\r\n              <description>Timestamp received from other eTRV in the same room that went into preheat.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Get Weekly Schedule Response\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Number of Transtions for Sequence\" required=\"m\">\r\n              <value name=\"0\" value=\"0\"></value>\r\n              <value name=\"1\" value=\"1\"></value>\r\n              <value name=\"2\" value=\"2\"></value>\r\n              <value name=\"3\" value=\"3\"></value>\r\n              <value name=\"4\" value=\"4\"></value>\r\n              <value name=\"5\" value=\"5\"></value>\r\n              <value name=\"6\" value=\"6\"></value>\r\n              <value name=\"7\" value=\"7\"></value>\r\n              <value name=\"8\" value=\"8\"></value>\r\n              <value name=\"9\" value=\"9\"></value>\r\n              <value name=\"10\" value=\"10\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"bmp8\" name=\"Day of Week for Sequence\" required=\"m\">\r\n              <value name=\"Sunday\" value=\"0\"></value>\r\n              <value name=\"Monday\" value=\"1\"></value>\r\n              <value name=\"Tuesday\" value=\"2\"></value>\r\n              <value name=\"Wednesday\" value=\"3\"></value>\r\n              <value name=\"Thursday\" value=\"4\"></value>\r\n              <value name=\"Friday\" value=\"5\"></value>\r\n              <value name=\"Saturday\" value=\"6\"></value>\r\n              <value name=\"Vacation or Away\" value=\"7\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"bmp8\" name=\"Mode for Sequence\" required=\"m\">\r\n              <value name=\"Heat Setpoint Field Present in Payload\" value=\"0\"></value>\r\n              <value name=\"Cool Setpoint Field Present in Payload\" value=\"1\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Transition Time 1\" required=\"o\"/>\r\n            <attribute id=\"0x0004\" type=\"s16\" name=\"Heat Set Point 1\" required=\"o\"/>\r\n            <attribute id=\"0x0005\" type=\"u16\" name=\"Transition Time 2\" required=\"o\"/>\r\n            <attribute id=\"0x0006\" type=\"s16\" name=\"Heat Set Point 2\" required=\"o\"/>\r\n            <attribute id=\"0x0007\" type=\"u16\" name=\"Transition Time 3\" required=\"o\"/>\r\n            <attribute id=\"0x0008\" type=\"s16\" name=\"Heat Set Point 3\" required=\"o\"/>\r\n            <attribute id=\"0x0009\" type=\"u16\" name=\"Transition Time 4\" required=\"o\"/>\r\n            <attribute id=\"0x000A\" type=\"s16\" name=\"Heat Set Point 4\" required=\"o\"/>\r\n            <attribute id=\"0x000B\" type=\"u16\" name=\"Transition Time 5\" required=\"o\"/>\r\n            <attribute id=\"0x000C\" type=\"s16\" name=\"Heat Set Point 5\" required=\"o\"/>\r\n            <attribute id=\"0x000D\" type=\"u16\" name=\"Transition Time 6\" required=\"o\"/>\r\n            <attribute id=\"0x000E\" type=\"s16\" name=\"Heat Set Point 6\" required=\"o\"/>\r\n            <attribute id=\"0x000F\" type=\"u16\" name=\"Transition Time 7\" required=\"o\"/>\r\n            <attribute id=\"0x0010\" type=\"s16\" name=\"Heat Set Point 7\" required=\"o\"/>\r\n            <attribute id=\"0x0011\" type=\"u16\" name=\"Transition Time 8\" required=\"o\"/>\r\n            <attribute id=\"0x0012\" type=\"s16\" name=\"Heat Set Point 8\" required=\"o\"/>\r\n            <attribute id=\"0x0013\" type=\"u16\" name=\"Transition Time 9\" required=\"o\"/>\r\n            <attribute id=\"0x0014\" type=\"s16\" name=\"Heat Set Point 9\" required=\"o\"/>\r\n            <attribute id=\"0x0015\" type=\"u16\" name=\"Transition Time 10\" required=\"o\"/>\r\n            <attribute id=\"0x0016\" type=\"s16\" name=\"Heat Set Point 10\" required=\"o\"/>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0202\" name=\"Fan Control\">\r\n      <description>This cluster specifies an interface to control the speed of a fan as part of a heating / cooling system.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Fan Mode\" type=\"enum8\" access=\"rw\" default=\"0x05\" required=\"m\">\r\n          <value name=\"Off\" value=\"0x00\"></value>\r\n          <value name=\"Low\" value=\"0x01\"></value>\r\n          <value name=\"Medium\" value=\"0x02\"></value>\r\n          <value name=\"High\" value=\"0x03\"></value>\r\n          <value name=\"On\" value=\"0x04\"></value>\r\n          <value name=\"Auto\" value=\"0x05\"></value>\r\n          <value name=\"Smart\" value=\"0x06\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Fan Mode Sequence\" type=\"enum8\" access=\"rw\" default=\"0x02\" required=\"m\">\r\n          <value name=\"Low/Med/High\" value=\"0x00\"></value>\r\n          <value name=\"Low/High\" value=\"0x01\"></value>\r\n          <value name=\"Low/Med/High/Auto\" value=\"0x02\"></value>\r\n          <value name=\"Low/High/Auto\" value=\"0x03\"></value>\r\n          <value name=\"On/Auto\" value=\"0x04\"></value>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0203\" name=\"Dehumidification Control\">\r\n      <description>dfdf</description>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0204\" name=\"Thermostat User Interface Configuration\">\r\n      <description>This cluster provides an interface to allow configuration of the user interface for a thermostat, or a thermostat controller device, that supports a keypad and LCD screen.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Temperature Display Mode\" type=\"enum8\" access=\"rw\" range=\"0x00,0x01\" default=\"0x00\" required=\"m\">\r\n          <value name=\"Temperature in °C\" value=\"0x00\"></value>\r\n          <value name=\"Temperature in °F\" value=\"0x01\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Keypad Lockout\" type=\"enum8\" access=\"rw\" range=\"0x00,0x05\" default=\"0x00\" required=\"m\">\r\n          <value name=\"No lockout\" value=\"0x00\"></value>\r\n          <value name=\"Level 1 lockout\" value=\"0x01\"></value>\r\n          <value name=\"Level 2 lockout\" value=\"0x02\"></value>\r\n          <value name=\"Level 3 lockout\" value=\"0x03\"></value>\r\n          <value name=\"Level 4 lockout\" value=\"0x04\"></value>\r\n          <value name=\"Level 5 lockout\" value=\"0x05\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Schedule Programming Visibility\" type=\"enum8\" access=\"rw\"  range=\"0x00,0x01\" default=\"0x00\" required=\"o\">\r\n          <value name=\"Local schedule programming enabled\" value=\"0x00\"></value>\r\n          <value name=\"Local schedule programming disabled\" value=\"0x01\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x4000\" name=\"Viewing Direction\" type=\"enum8\" access=\"rw\" range=\"0x00,0x01\" default=\"0x00\" required=\"o\" mfcode=\"0x1246\">\r\n          <value name=\"Viewing direction 1\" value=\"0x00\"></value>\r\n          <value name=\"Viewing direction 2\" value=\"0x01\"></value>\r\n        </attribute>\r\n\r\n        <!-- Bosch manufacturer specific -->\r\n        <attribute-set id=\"0x4000\" description=\"Bosch specific\" mfcode=\"0x1209\">\r\n          <attribute id=\"0x400B\" name=\"Display Orientation\" type=\"u8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\"></attribute>\r\n          <attribute id=\"0x4031\" name=\"Unknown\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"0x00\" value=\"0x00\"></value>\r\n            <value name=\"0x01\" value=\"0x01\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4039\" name=\"Displayed Temperature\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Setpoint Temperature\" value=\"0x00\"></value>\r\n            <value name=\"Measured Temperature\" value=\"0x01\"></value>\r\n            <value name=\"Unknown\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x403a\" name=\"Display On-time\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n            <value name=\"10\" value=\"0x0A\"></value>\r\n            <value name=\"20\" value=\"0x04\"></value>\r\n            <value name=\"30\" value=\"0x04\"></value>\r\n            <value name=\"40\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x403b\" name=\"Display Brightness\" type=\"enum8\" access=\"rw\" required=\"o\" mfcode=\"0x1209\">\r\n            <value name=\"Off\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n            <value name=\"5\" value=\"0x05\"></value>\r\n            <value name=\"6\" value=\"0x06\"></value>\r\n            <value name=\"7\" value=\"0x07\"></value>\r\n            <value name=\"8\" value=\"0x08\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xde42\" name=\"DE Debug\">\r\n      <description>Attributes and commands for debugging purposes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Debug enabled\" type=\"bool\" access=\"rw\" default=\"0x00\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Debug destination\" type=\"u16\" access=\"rw\" default=\"0x0000\" showas=\"hex\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Lighting\" low_bound=\"0300\" high_bound=\"03ff\" description=\"The lighting functional domain contains clusters and information to build devices in the lighting domain, e.g. ballast units.\">\r\n    <cluster id=\"0x0300\" name=\"Color Control\">\r\n      <description>Attributes and commands for controlling the color properties of a color-capable light.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Color Information\">\r\n          <attribute id=\"0x0000\" name=\"Current Hue\" type=\"u8\" access=\"r\" range=\"0x00,0xfe\" default=\"0x00\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Current Saturation\" type=\"u8\" access=\"r\" range=\"0x00,0xfe\" default=\"0x00\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Remaining Time\" type=\"u16\" access=\"r\" range=\"0x0000,0xfffe\" default=\"0x0000\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Current X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" default=\"0x61eb\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Current Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" default=\"0x607b\" required=\"m\"></attribute>\r\n          <!-- Haven't yet seen any lights supporting these\r\n          <attribute id=\"0x0005\" name=\"Drift Compensation\" type=\"enum8\" access=\"r\" required=\"o\">\r\n            <value name=\"None\" value=\"0x00\"></value>\r\n            <value name=\"Other / Unknown\" value=\"0x01\"></value>\r\n            <value name=\"Temperature monitoring\" value=\"0x02\"></value>\r\n            <value name=\"Optical luminance monitoring and feedback\" value=\"0x03\"></value>\r\n\t        </attribute>\r\n          <attribute id=\"0x0006\" name=\"Compensation Text\" type=\"cstring\" access=\"r\" required=\"o\"></attribute>\r\n          -->\r\n          <attribute id=\"0x0007\" name=\"Color Temperature Mireds\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0008\" name=\"Color Mode\" type=\"enum8\" access=\"r\" range=\"0x00,0x02\" default=\"0x01\" required=\"o\">\r\n            <value name=\"Current hue and current saturation\" value=\"0x00\"></value>\r\n            <value name=\"Current x and current y\" value=\"0x01\"></value>\r\n            <value name=\"Color temperature\" value=\"0x02\"></value>\r\n          </attribute>\r\n          <attribute id = \"0x000f\" name=\"Options\" type=\"bmp8\" access=\"rw\" required=\"o\">\r\n            <value name=\"Execute If Off\" value=\"0\"></value>\r\n          </attribute>\r\n          <!-- TODO -->\r\n          <attribute id=\"0x4000\" name=\"Enhanced Current Hue\" type=\"u16\" access=\"r\" range=\"0x0000,0xffff\" default=\"0x0000\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4001\" name=\"Enhanced Color Mode\" type=\"enum8\" access=\"r\" range=\"0x00,0xff\" default=\"0x00\" required=\"m\">\r\n            <value name=\"Current hue and current saturation\" value=\"0x00\"></value>\r\n            <value name=\"Current x and current y\" value=\"0x01\"></value>\r\n            <value name=\"Color temperature\" value=\"0x02\"></value>\r\n            <value name=\"Enhanced current hue and current saturation\" value=\"0x03\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x4002\" name=\"Color Loop Active\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" default=\"0x00\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4003\" name=\"Color Loop Direction\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" default=\"0x00\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4004\" name=\"Color Loop Time\" type=\"u16\" access=\"r\" range=\"0x00,0xff\" default=\"0x0019\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4005\" name=\"Color Loop Start Enhanced Hue\" type=\"u16\" access=\"r\" range=\"0x00,0xff\" default=\"0x2300\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4006\" name=\"Color Loop Stored Enhanced Hue\" type=\"u16\" access=\"r\" range=\"0x00,0xff\" default=\"0x0000\" required=\"m\"></attribute>\r\n          <attribute id=\"0x400a\" type=\"bmp16\" name=\"Color Capabilities\" access=\"r\" required=\"m\" default=\"0x0000\">\r\n            <value name=\"Hue saturation\" value=\"0\"></value>\r\n            <value name=\"Enhanced Hue saturation\" value=\"1\"></value>\r\n            <value name=\"Color loop\" value=\"2\"></value>\r\n            <value name=\"CIE 1931 XY\" value=\"3\"></value>\r\n            <value name=\"Color temperature\" value=\"4\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x400b\" name=\"Color Temperature Min Mireds\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x400c\" name=\"Color Temperature Max Mireds\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" default=\"0xfeff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x400d\" name=\"Couple Color Temp To Min Mireds\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x4010\" name=\"StartUp Color Temperature Mireds\" type=\"u16\" access=\"rw\" range=\"0x0000,0xffff\" default=\"0xffff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0003\" mfcode=\"0x100b\" name=\"Hue StartUp Current X\" type=\"u16\" access=\"rw\" range=\"0x0000,0xffff\" default=\"0xffff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0004\" mfcode=\"0x100b\" name=\"Hue StartUp Current Y\" type=\"u16\" access=\"rw\" range=\"0x0000,0xffff\" default=\"0xffff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Defined Primaries Information\">\r\n          <attribute id=\"0x0010\" name=\"Number of Primaries\" type=\"u8\" access=\"r\" range=\"0x00,0x06\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Primary1 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Primary1 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Primary1 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Primary2 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0016\" name=\"Primary2 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0017\" name=\"Primary2 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0019\" name=\"Primary3 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x001a\" name=\"Primary3 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x001b\" name=\"Primary3 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Additional Defined Primaries Information\">\r\n          <attribute id=\"0x0020\" name=\"Primary4 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0021\" name=\"Primary4 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0022\" name=\"Primary4 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0024\" name=\"Primary5 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0025\" name=\"Primary5 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0026\" name=\"Primary5 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0028\" name=\"Primary6 X\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0029\" name=\"Primary6 Y\" type=\"u16\" access=\"r\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x002a\" name=\"Primary6 Intensity\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Defined Color Points Settings\">\r\n          <attribute id=\"0x0030\" name=\"WhitePoint X\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0031\" name=\"WhitePoint Y\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0032\" name=\"ColorPoint R X\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0033\" name=\"ColorPoint R Y\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0034\" name=\"ColorPoint R Intensity\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0036\" name=\"ColorPoint G X\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0037\" name=\"ColorPoint G Y\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0038\" name=\"ColorPoint G Intensity\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x003a\" name=\"ColorPoint B X\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x003b\" name=\"ColorPoint B Y\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfeff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x003c\" name=\"ColorPoint B Intensity\" type=\"u8\" access=\"rw\" range=\"0x00,0xff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xde00\" description=\"FLS extensions\" mfcode=\"0x1135\">\r\n          <attribute id=\"0xde01\" name=\"Active channels\" type=\"u8\" access=\"r\" range=\"0x00,0xff\" default=\"0x00\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Move to Hue\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Hue\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Direction\" required=\"m\">\r\n              <value name=\"Shortest Distance\" value=\"0x00\"></value>\r\n              <value name=\"Longest Distance\" value=\"0x01\"></value>\r\n              <value name=\"Up\" value=\"0x02\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10ths of a second.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Move Hue\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Move Mode\" required=\"m\">\r\n              <value name=\"Stop\" value=\"0x00\"></value>\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Rate\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Step Hue\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step Mode\" required=\"m\">\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Step Size\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Move to Saturation\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Saturation\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Move Saturation\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Move Mode\" required=\"m\">\r\n              <value name=\"Stop\" value=\"0x00\"></value>\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Rate\" required=\"m\">\r\n              <description>The steps per second.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Step Saturation\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step Mode\" required=\"m\">\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Step Size\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Move to Hue and Saturation\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Hue\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Saturation\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Move to Color\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Color X\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Color Y\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"Move Color\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"s16\" name=\"Rate X\" required=\"m\">\r\n              <description>The steps per second.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"s16\" name=\"Rate Y\" required=\"m\">\r\n              <description>The steps per second.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x09\" dir=\"recv\" name=\"Step Color\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"s16\" name=\"Step X\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"s16\" name=\"Step Y\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x0a\" dir=\"recv\" name=\"Move to Color Temperature\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Color temperature Mireds\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x40\" dir=\"recv\" name=\"Enhanced Move to Hue\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Enhanced Hue\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Direction\" required=\"m\">\r\n              <value name=\"Shortest Distance\" value=\"0x00\"></value>\r\n              <value name=\"Longest Distance\" value=\"0x01\"></value>\r\n              <value name=\"Up\" value=\"0x02\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Enhanced Move Hue\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Move Mode\" required=\"m\">\r\n              <value name=\"Stop\" value=\"0x00\"></value>\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Rate\" required=\"m\">\r\n              <description>Steps per second.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x42\" dir=\"recv\" name=\"Enhanced Step Hue\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step Mode\" required=\"m\">\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Step Size\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x43\" dir=\"recv\" name=\"Enhanced Move to Hue and Saturation\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Enhanced Hue\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Saturation\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x44\" dir=\"recv\" name=\"Color Loop Set\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"bmp8\" name=\"Update Flags\" required=\"m\">\r\n              <value name=\"Update Action\" value=\"0\"></value>\r\n              <value name=\"Update Direction\" value=\"1\"></value>\r\n              <value name=\"Update Time\" value=\"2\"></value>\r\n              <value name=\"Update Start Hue\" value=\"3\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Action\" required=\"m\">\r\n              <value name=\"De-activate color loop\" value=\"0x00\"></value>\r\n              <value name=\"Activate from Color Loop Start Enhanced Hue\" value=\"0x01\"></value>\r\n              <value name=\"Activate from Enhanced Current Hue\" value=\"0x02\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"enum8\" name=\"Direction\" required=\"m\">\r\n              <value name=\"Decrement Hue\" value=\"0x00\"></value>\r\n              <value name=\"Increment Hue\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Time\" required=\"m\">\r\n              <description>Time in seconds used for a whole color loop.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0004\" type=\"u16\" name=\"Start Enhanced Hue\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x47\" dir=\"recv\" name=\"Stop move step\" required=\"m\">\r\n          <description>Stops move to and step commands. It has no effect on a active color loop.</description>\r\n          <payload></payload>\r\n        </command>\r\n        <command id=\"0x4b\" dir=\"recv\" name=\"Move Color Temperature\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Move Mode\" required=\"m\">\r\n              <value name=\"Stop\" value=\"0x00\"></value>\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Rate\" required=\"m\">\r\n              <description>Steps per second.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Color Temperature Min Mireds\" required=\"m\">\r\n              <description>Specifies a lower bound on the color temperature for the current move operation.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Color Temperature Max Mireds\" required=\"m\">\r\n              <description>Specifies a upper bound on the color temperature for the current move operation.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x4c\" dir=\"recv\" name=\"Step Color Temperature\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Step Mode\" required=\"m\">\r\n              <value name=\"Up\" value=\"0x01\"></value>\r\n              <value name=\"Down\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"u16\" name=\"Step Size\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u16\" name=\"Transition Time\" required=\"m\">\r\n              <description>The transition time in 1/10 seconds.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Color Temperature Min Mireds\" required=\"m\">\r\n              <description>Specifies a lower bound on the color temperature for the current step operation.</description>\r\n            </attribute>\r\n            <attribute id=\"0x0004\" type=\"u16\" name=\"Color Temperature Max Mireds\" required=\"m\">\r\n              <description>Specifies a upper bound on the color temperature for the current step operation.</description>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0xd0\" dir=\"recv\" name=\"Set Active Channels\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Channels\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client></client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0301\" name=\"Ballast Configuration\">\r\n      <description>Attributes and commands to configure a ballast.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Ballast Information\">\r\n          <attribute id=\"0x0000\" name=\"Physical Min Level\" type=\"u8\" access=\"r\" range=\"0x01,0xfe\" default=\"0x01\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Physical Max Level\" type=\"u8\" access=\"r\" range=\"0x01,0xfe\" default=\"0xfe\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Ballast Status\" type=\"bmp8\" access=\"r\" default=\"0x00\" required=\"m\">\r\n            <value name=\"Non-operational\" value=\"0\"></value>\r\n            <value name=\"Lamp not in socket\" value=\"1\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Ballast Settings\">\r\n          <attribute id=\"0x0010\" name=\"Min Level\" type=\"u8\" access=\"rw\" range=\"0x01,0xfe\" default=\"0x01\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Max Level\" type=\"u8\" access=\"rw\" range=\"0x01,0xfe\" default=\"0xfe\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Power On Level\" type=\"u8\" access=\"rw\" range=\"0x01,0xfe\" default=\"0xfe\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Power On Fade Time\" type=\"u16\" access=\"rw\" range=\"0x0000,0xfffe\" default=\"0x0000\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Intrinsic Ballast Factor\" type=\"u8\" access=\"rw\" range=\"0x00,0xfe\" default=\"0x00\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0015\" name=\"Ballast Factor Adjustment\" type=\"u8\" access=\"rw\" range=\"0x64,0xff\" default=\"0xff\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Lamp Information\">\r\n          <attribute id=\"0x0020\" name=\"Lamp Quantity\" type=\"u8\" access=\"r\" range=\"0x00,0xfe\" default=\"0x00\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Lamp Settings\">\r\n          <attribute id=\"0x0030\" name=\"Lamp Type\" type=\"cstring\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0031\" name=\"Lamp Manufacturer\" type=\"cstring\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0032\" name=\"Lamp Rated Hours\" type=\"u24\" access=\"rw\" range=\"0x000000,0xfffffe\" default=\"0xffffff\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0033\" name=\"Lamp Burn Hours\" type=\"u24\" access=\"rw\" range=\"0x000000,0xfffffe\" default=\"0x000000\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0034\" name=\"Lamp Alarm Mode\" type=\"bmp8\" access=\"rw\" default=\"0x00\" required=\"m\">\r\n            <value name=\"Lamp Burn Hours\" value=\"0\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0035\" name=\"Lamp Burn Hours Trip Point\" type=\"u24\" access=\"rw\" range=\"0x000000,0xfffffe\" default=\"0x000000\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Measurement and sensing\" low_bound=\"0400\" high_bound=\"04ff\" description=\"The measurement and sensing functional domain contains clusters and information to build devices in the measurement and sensing domain, e.g. a temperature sensor or an occupancy sensor.\">\r\n    <cluster id=\"0x0400\" name=\"Illuminance measurement\">\r\n      <description>The server cluster provides an interface to illuminance measurement functionality, including configuration and provision of notifications of illuminance measurements.</description>\r\n      <!-- TODO -->\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Illuminance Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0002,0xfffd\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0001,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n          <attribute id=\"0x0004\" name=\"Light Sensor Type\" type=\"enum8\" range=\"0x00,0xff\" access=\"r\" required=\"o\">\r\n            <value name=\"Photodiode\" value=\"0x00\"></value>\r\n            <value name=\"CMOS\" value=\"0x01\"></value>\r\n            <value name=\"Unknown\" value=\"0xff\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n        <attribute-set id=\"0xf000\" description=\"Illuminance Adjustement Configuration\">\r\n          <attribute id=\"0xf000\" name=\"Hysteresis\" type=\"u16\" access=\"rw\" required=\"o\"></attribute>\r\n          <attribute id=\"0xf001\" name=\"Max Up Speed\" type=\"u16\" access=\"rw\" required=\"o\">\r\n            <description>Maximum up adjustment speed in 1/10 seconds.</description>\r\n          </attribute>\r\n          <attribute id=\"0xf002\" name=\"Max Down Speed\" type=\"u16\" access=\"rw\" required=\"o\">\r\n            <description>Maximum down adjustment speed in 1/10 seconds.</description>\r\n          </attribute>\r\n          <attribute id=\"0xf003\" name=\"Target Value\" type=\"u16\" access=\"rw\" required=\"o\">\r\n            <description>Target value in Lux which should be kept.</description>\r\n          </attribute>\r\n          <attribute id=\"0xf004\" name=\"Startup Type\" type=\"enum8\" access=\"rw\" required=\"o\">\r\n            <description>Brightness control startup type.</description>\r\n            <value name=\"Default Level\" value=\"0x00\"></value>\r\n            <value name=\"Zero Level\" value=\"0x01\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0401\" name=\"Illuminance level sensing\">\r\n      <description></description>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0402\" name=\"Temperature measurement\">\r\n      <description>The server cluster provides an interface to temperature measurement functionality, including configuration and provision of notifications of temperature measurements.</description>\r\n      <!-- TODO -->\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Temperature Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"s16\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"s16\" access=\"r\" required=\"m\" range=\"0x954d,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"s16\" access=\"r\" required=\"m\" range=\"0x954e,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0403\" name=\"Pressure measurement\">\r\n      <description>The server cluster provides an interface to air pressure measurement functionality, including configuration and provision of notifications of air pressure measurements.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Pressure Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"s16\" access=\"r\" default=\"0x8000\" required=\"m\"></attribute>\r\n\t  <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x8001,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x8002,0x7fff\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n\t<attribute-set id=\"0x0001\" description=\"Extended Pressure Measurement Information\">\r\n          <attribute id=\"0x0010\" name=\"Scaled Value\" type=\"s16\" access=\"r\" default=\"0\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x0011\" name=\"Min Scaled Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x8001,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Max Scaled Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x8002,0x7fff\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Scaled Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n          <attribute id=\"0x0014\" name=\"Scale\" type=\"s8\" access=\"r\" required=\"o\" range=\"0x81,0x7f\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0404\" name=\"Flow measurement\">\r\n      <description>The server cluster provides an interface to flow measurement measurement functionality, including configuration and provision of notifications of flow measurements.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Flow Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xFFFF\" required=\"m\">\r\n\t  <description>Represents the flow in m3/h times 10 </description></attribute>\r\n\t  <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0000,0xfffd\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0001,0x7ffe\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0405\" name=\"Relative humidity measurement\">\r\n      <description>Percentage of water in the air</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Relative Humidity Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0000,0x270f\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0001,0x2710\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0406\" name=\"Occupancy sensing\">\r\n      <description>\r\n        <!-- TODO -->\r\n      </description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Occupancy sensor information\">\r\n          <attribute id=\"0x0000\" name=\"Occupancy\" type=\"bmp8\" range=\"0000000x\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Occupancy Sensor Type\" type=\"enum8\" range=\"0x00,0xfe\" access=\"r\" required=\"m\">\r\n            <value name=\"PIR\" value=\"0x00\"></value>\r\n            <value name=\"Ultrasonic\" value=\"0x01\"></value>\r\n            <value name=\"PIR and ultrasonic\" value=\"0x02\"></value>\r\n\t    <value name=\"Physical contact\" value=\"0x03\"></value>\r\n          </attribute>\r\n\t  <attribute id=\"0x0002\" name=\"Occupancy Sensor Type Bitmap\" type=\"bmp8\" access=\"r\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"PIR configuration\">\r\n          <attribute id=\"0x0010\" name=\"PIR Occupied To Unoccupied Delay\" type=\"u16\" range=\"0x00,0xfffe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The PIROccupiedToUnoccupiedDelay attribute is 16-bits in length and specifies the time delay, in seconds, before the PIR sensor changes to its occupied state when the sensed area becomes unoccupied. This attribute, along with PIRUnoccupiedToOccupiedTime, may be used to reduce sensor 'chatter' when used in an area where occupation changes frequently.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0011\" name=\"PIR Unoccupied To Occupied Delay\" type=\"u16\" range=\"0x00,0xfffe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The PIRUnoccupiedToOccupiedDelay attribute is 16-bits in length and specifies the time delay, in seconds, before the PIR sensor changes to its unoccupied state when the sensed area becomes occupied.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0012\" name=\"PIR Unoccupied To Occupied Threshold\" type=\"u8\" range=\"0x01,0xfe\" access=\"rw\" required=\"o\" default=\"0x01\">\r\n            <description>The PIRUnoccupiedToOccupiedThreshold attribute is 8 bits in length and specifies the number of movement detection events that must occur in the period PIRUnoccupiedToOccupiedDelay, before the PIR sensor changes to its occupied state.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0020\" description=\"Ultrasonic configuration\">\r\n          <attribute id=\"0x0020\" name=\"Ultrasonic Occupied To Unoccupied Delay\" type=\"u16\" range=\"0x00,0xfe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The UltraSonicOccupiedToUnoccupiedDelay attribute specifies the time delay, in seconds, before the ultrasonic sensor changes to its occupied state when the sensed area becomes unoccupied. This attribute, along with UltraSonicUnoccupiedToOccupiedTime, may be used to reduce sensor 'chatter' when used in an area where occupation changes frequently.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0021\" name=\"Ultrasonic Unoccupied To Occupied Delay\" type=\"u16\" range=\"0x00,0xfe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The UltraSonicUnoccupiedToOccupiedDelay attribute specifies the time delay, in seconds, before the ultrasonic sensor changes to its unoccupied state when the sensed area becomes occupied.</description>\r\n          </attribute>\r\n\t  <attribute id=\"0x0022\" name=\"Ultrasonic Unoccupied To Occupied Threshold\" type=\"u8\" range=\"0x01,0xfe\" access=\"rw\" required=\"o\" default=\"0x01\">\r\n            <description>The UltrasonicUnoccupiedToOccupiedThreshold attribute is 8 bits in length and specifies the number of movement detection events that must occur in the period PIRUnoccupiedToOccupiedDelay, before the PIR sensor changes to its occupied state.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n\t<attribute-set id=\"0x0030\" description=\"Physical Contact configuration\">\r\n          <attribute id=\"0x0030\" name=\"Physical Contact Occupied To Unoccupied Delay\" type=\"u16\" range=\"0x00,0xfe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The PhysicalContactOccupiedToUnoccupiedDelay attribute specifies the time delay, in seconds, before the Physical Contact sensor changes to its occupied state when the sensed area becomes unoccupied. This attribute, along with UltraSonicUnoccupiedToOccupiedTime, may be used to reduce sensor 'chatter' when used in an area where occupation changes frequently.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0031\" name=\"Physical Contact Unoccupied To Occupied Delay\" type=\"u16\" range=\"0x00,0xfe\" access=\"rw\" required=\"o\" default=\"0x00\">\r\n            <description>The PhysicalContactUnoccupiedToOccupiedDelay attribute specifies the time delay, in seconds, before the Physical Contact sensor changes to its unoccupied state when the sensed area becomes occupied.</description>\r\n          </attribute>\r\n\t  <attribute id=\"0x0032\" name=\"Physical Contact Unoccupied To Occupied Threshold\" type=\"u8\" range=\"0x01,0xfe\" access=\"rw\" required=\"o\" default=\"0x01\">\r\n            <description>The PhysicalContactUnoccupiedToOccupiedThreshold attribute is 8 bits in length and specifies the number of movement detection events that must occur in the period PIRUnoccupiedToOccupiedDelay, before the PIR sensor changes to its occupied state.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0030\" description=\"Philips Specific\" mfcode=\"0x100b\">\r\n          <attribute id=\"0x0030\" name=\"Sensitivity\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\"></attribute>\r\n          <attribute id=\"0x0031\" name=\"Sensitivity max.\" type=\"u8\" default=\"0\" access=\"rw\" required=\"o\" mfcode=\"0x100b\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0000\" description=\"Develco Specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x0000\" name=\"ArmThreshold_MinTemperature\" type=\"s16\" access=\"rw\" range=\"0x954d,0x7ffe\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"ArmThreshold_MaxTemperature\" type=\"s16\" access=\"rw\" range=\"0x954d,0x7ffe\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Target Level\" type=\"u16\" access=\"rw\" range=\"0x0002,0xfffd\" required=\"m\" mfcode=\"0x1015\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n   \r\n    <cluster id=\"0x0407\" name=\"Leaf Wetness measurement\">\r\n      <description>Percentage of water on the leaves of plants</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Leaf Wetness Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0000,0x270f\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0001,0x2710\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n            \r\n    <cluster id=\"0x0408\" name=\"Soil Moisture measurement\">\r\n      <description>Percentage of water in the soil</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Soil Moisture Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0000,0x270f\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" range=\"0x0001,0x2710\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\" range=\"0x0000,0x0800\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x0409\" name=\"pH Measurement\">\r\n      <description>Provides an interface to pH measurement functionality</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"pH measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\">\r\n\t    <description>\"Represents the pH with no units as follows: Measured Value = 100 x pH\"</description>\r\n\t  </attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x040A\" name=\"Electrical Conductivity\">\r\n      <description>Provides an interface to Electrical Conductivity measurement functionality</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Electrical Conductivity Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\">\r\n\t    <description>\"Electrical Conductivity in mS/m. The maximum resolution this format allows is 0.1\"</description>\r\n\t  </attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x040B\" name=\"Wind Speed Measurement\">\r\n      <description>Provides an interface to Wind Speed Measurement functionality</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Wind Speed Measurement Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\">\r\n\t    <description>\"100 x Wind Speed in m/s. The maximum resolution this format allows is 0.01\"</description>\r\n\t  </attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"u16\" access=\"r\" default=\"0xffff\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"u16\" access=\"r\" required=\"m\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"u16\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x040C\" name=\"Carbon monoxyde (CO) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Carbon monoxyde Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x040D\" name=\"Carbon dioxyde (CO2) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Carbon Dioxyde Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x040E\" name=\"Ethylene (CH2) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Ethylene Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x040F\" name=\"Ethylene Oxide (C2H4O) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Ethylene Oxide Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x0410\" name=\"Hydrogen (H) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Hydrogen Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x0411\" name=\"Hydrogen Sulfide (H2S) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Hydrogen Sulfide Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x0412\" name=\"Nitric Oxide (NO) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Nitric Oxide Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x0413\" name=\"Nitrogen Dioxide (NO2) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Nitrogen Dioxide Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n   <cluster id=\"0x0414\" name=\"Oxygen (O2) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Oxygen Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n        \r\n   <cluster id=\"0x0415\" name=\"Ozone (O3) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Ozone Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n            \r\n   <cluster id=\"0x0416\" name=\"Sulfur Dioxide measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Sulfur Dioxide Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n               \r\n   <cluster id=\"0x0417\" name=\"Dissolved Oxygen (DO) measurement\">\r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Dissolved Oxygen Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                    \r\n   <cluster id=\"0x0418\" name=\"Bromate measurement\">\r\n      <description>Typical range example: not detected to 3.6 PPB. Typical value example:1.79 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Bromate Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                           \r\n   <cluster id=\"0x0419\" name=\"Chloramines measurement\">\r\n      <description>Typical range example: 0.9 to 3.8 PPM. typical value example: 2.87 PPM</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Chloramines Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                               \r\n   <cluster id=\"0x041A\" name=\"Chlorine measurement\">\r\n      <description>Typical range example: 0.1 to 2.4 PPM. Typical value example: 1.28 PPM</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Chlorine Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                \r\n   <cluster id=\"0x041B\" name=\"Fecal coliform and E Coli measurement\">\r\n      <description>Percent of positive samples. Typical value example: 0</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Fecal coliform and E Coli Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                    \r\n   <cluster id=\"0x041C\" name=\"Fluoride measurement\">\r\n      <description>Typical range example: 0 to 100 PPM.Typical value example: 0.72 PPM</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Fluoride Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                        \r\n   <cluster id=\"0x041D\" name=\"Haloacetic Acids measurement\">\r\n      <description>Typical range example: Not Detected to 20 PPB. Ttypical value example: 14 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Haloacetic Acids Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                           \r\n   <cluster id=\"0x041E\" name=\"Total Trihalomethanes measurement\">\r\n      <description>Typical range example: 0 to 100 PPB. Typical value example: 44 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Total Trihalomethanes Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster> \r\n                                           \r\n   <cluster id=\"0x041F\" name=\"Total Coliform Bacteria measurement\">\r\n      <description>Percent of positive samples. Typical range example: 0 to 100%. Typical value example: 1.33%</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Total Coliform Bacteria Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster> \r\n                                           \r\n   <cluster id=\"0x0420\" name=\"Turbidity measurement\">\r\n      <description>Cloudiness of particles in water where an average person would notice a 5 or higher. Typical range example: 0 to 10. Typical value example: 0.18</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Turbidity Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster> \r\n                                           \r\n   <cluster id=\"0x0421\" name=\"Copper measurement\">\r\n      <description>Typical range example: 0 to 10 PPM. Typical value example: 0.191 PPM</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Copper Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                           \r\n   <cluster id=\"0x0422\" name=\"Lead measurement\">\r\n      <description>Typical range example: 0 to 10 PPB. Typical value example: 3.2 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Lead Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                           \r\n   <cluster id=\"0x0423\" name=\"Manganese measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 31 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Manganese Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                           \r\n   <cluster id=\"0x0424\" name=\"Sulfate measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 36 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Sulfate Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                           \r\n   <cluster id=\"0x0425\" name=\"Bromodichloromethane measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 9.6 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Bromodichloromethane Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                            \r\n   <cluster id=\"0x0426\" name=\"Bromoform measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 1.1 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Bromoform Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                             \r\n   <cluster id=\"0x0427\" name=\"Chlorodibromomethane measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 6.4 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Chlorodibromomethane Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                             \r\n   <cluster id=\"0x0428\" name=\"Chloroform measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 8.0 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Chloroform Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n                                               \r\n   <cluster id=\"0x0429\" name=\"Sodium measurement\">\r\n      <description>Typical range example: 0 to 1000 PPB. Typical value example: 27 PPB</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Sodium Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    \r\n    <cluster id=\"0x042A\" name=\"PM2.5 Measurement\"> \r\n      <description>Particulate Matter 2.5 microns or less</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"PM 2.5 Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n            \r\n    <cluster id=\"0x042B\" name=\"Formaldehyde Measurement\"> \r\n      <description></description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Formaldehyde Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n            \r\n    <cluster id=\"0x042C\" name=\"PM1 Measurement\"> \r\n      <description>PM1 concentration measurement</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"PM1 Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n           \r\n    <cluster id=\"0x042D\" name=\"PM10 Measurement\"> \r\n      <description>PM10 concentration measurement</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"PM10 Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n            \r\n    <cluster id=\"0x042E\" name=\"VOC Measurement\"> \r\n      <description>Volatile Organic Compounds concentration measurement.Typical range example: 0 to 10 PPM. Typical value example: 1.11 PPM</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"VOC Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Tolerance\" type=\"float\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    <cluster id=\"0x0b04\" name=\"Electrical Measurement\">\r\n      <description>Provides a mechanism for querying data about the electrical properties as measured by the device.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Basic Information\">\r\n          <attribute id=\"0x0000\" name=\"Measurement Type\" type=\"bmp32\" access=\"r\" required=\"m\" default=\"0x00000000\">\r\n            <value name=\"Active measurement (AC)\" value=\"0\"></value>\r\n            <value name=\"Reactive measurement (AC)\" value=\"1\"></value>\r\n            <value name=\"Apparent measurement (AC)\" value=\"2\"></value>\r\n            <value name=\"Phase A measurement\" value=\"3\"></value>\r\n            <value name=\"Phase B measurement\" value=\"4\"></value>\r\n            <value name=\"Phase C measurement\" value=\"5\"></value>\r\n            <value name=\"DC measurement\" value=\"6\"></value>\r\n            <value name=\"Harmonics measurement\" value=\"7\"></value>\r\n            <value name=\"Power quality measurement\" value=\"8\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n\t<attribute-set id=\"0x0100\" description=\"DC Measurement\">\r\n\t  <attribute id=\"0x0100\" name=\"DC Voltage\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0101\" name=\"DC Voltage Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0102\" name=\"DC Voltage Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0103\" name=\"DC Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0104\" name=\"DC Current Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0105\" name=\"DC Current Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0106\" name=\"DC Power\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0107\" name=\"DC Power Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0108\" name=\"DC Power Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n        </attribute-set>\r\n\t<attribute-set id=\"0x0200\" description=\"DC Formatting\">\r\n\t  <attribute id=\"0x0200\" name=\"DC Voltage Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n\t  <attribute id=\"0x0201\" name=\"DC Voltage Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0202\" name=\"DC Current Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0203\" name=\"DC Current Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n\t  <attribute id=\"0x0204\" name=\"DC Power Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n\t  <attribute id=\"0x0205\" name=\"DC Power Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0300\" description=\"AC (Non-phase Specific) Measurements\">\r\n          <attribute id=\"0x0300\" name=\"AC Frequency\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0301\" name=\"AC Frequency Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0302\" name=\"AC Frequency Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0303\" name=\"Neutral current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x0304\" name=\"Total Active Power\" type=\"s32\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0305\" name=\"Total Reactive Power\" type=\"s32\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0306\" name=\"Total Apparent Power\" type=\"u32\" access=\"r\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x0307\" name=\"Measured 1st harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n          <attribute id=\"0x0308\" name=\"Measured 3rd harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x0309\" name=\"Measured 5th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030A\" name=\"Measured 7th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030B\" name=\"Measured 9th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030C\" name=\"Measured 11th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030D\" name=\"Measured Phase 1st harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030E\" name=\"Measured Phase 3rd harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x030F\" name=\"Measured Phase 5th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x0310\" name=\"Measured Phase 7th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x0311\" name=\"Measured Phase 9th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n\t  <attribute id=\"0x0312\" name=\"Measured Phase 11th harmonic Current\" type=\"s16\" access=\"r\" required=\"o\"> default=\"0x8000\"</attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0400\" description=\"AC (Non-phase Specific) Formatting\">\r\n\t  <attribute id=\"0x0400\" name=\"AC Frequency Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n\t  <attribute id=\"0x0401\" name=\"AC Frequency Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0402\" name=\"Power Multiplier\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x000001\"></attribute>\r\n          <attribute id=\"0x0403\" name=\"Power Divisor\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x000001\"></attribute>\r\n\t  <attribute id=\"0x0404\" name=\"Harmonic Current Multiplier\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n\t  <attribute id=\"0x0405\" name=\"Phase Harmonic Current Multiplier\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0500\" description=\"AC (Single Phase or Phase A) Measurements\">\r\n\t  <attribute id=\"0x0501\" name=\"Line Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n\t  <attribute id=\"0x0502\" name=\"Active Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0503\" name=\"Reactive Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0505\" name=\"RMS Voltage\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0506\" name=\"RMS Voltage Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0507\" name=\"RMS Voltage Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x0508\" name=\"RMS Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0509\" name=\"RMS Current Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x050a\" name=\"RMS Current Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x050b\" name=\"Active Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\">\r\n            <description>Represents the single phase or Phase A, current demand of active power delivered or received at the premises, in Watts (W). Positive values indicate power delivered to the premises where negative values indicate power received from the premises.</description>\r\n          </attribute>\r\n\t  <attribute id=\"0x050c\" name=\"Active Power Min\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x050d\" name=\"Active Power Max\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x050e\" name=\"Reactive Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x050f\" name=\"Apparent Power\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x0510\" name=\"Power Factor\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n\t  <attribute id=\"0x0511\" name=\"Average RMS Voltage Measurement Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0512\" name=\"Average RMS Over Voltage Counter\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0513\" name=\"Average RMS Under Voltage Counter\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0514\" name=\"RMS Extreme Over Voltage Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0515\" name=\"RMS Extreme Under Voltage Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0516\" name=\"RMS Voltage Sag Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0517\" name=\"RMS Voltage Swell Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0600\" description=\"AC Formatting\">\r\n          <attribute id=\"0x0600\" name=\"AC Voltage Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0601\" name=\"AC Voltage Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0602\" name=\"AC Current Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0603\" name=\"AC Current Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0604\" name=\"AC Power Multiplier\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n          <attribute id=\"0x0605\" name=\"AC Power Divisor\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0001\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0700\" description=\"DC Manufacturer Threshold Alarms\">\r\n          <attribute id=\"0x0700\" name=\"DC Overload Alarms Mask\" type=\"bmp8\" access=\"rw\" required=\"o\" default=\"00000000\">\r\n\t              <value name=\"Voltage Overload\" value=\"0\"></value>\r\n                      <value name=\"Current Overload\" value=\"1\"></value>\r\n\t  </attribute>\r\n          <attribute id=\"0x0701\" name=\"AC Voltage Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0702\" name=\"AC Current Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n        </attribute-set>\r\n\t<attribute-set id=\"0x0800\" description=\"AC Manufacturer Threshold Alarms\">\r\n          <attribute id=\"0x0800\" name=\"DC Overload Alarms Mask\" type=\"bmp16\" access=\"rw\" required=\"o\" default=\"0x0\">\r\n\t              <value name=\"Voltage Overload\" value=\"0\"></value>\r\n                      <value name=\"Current Overload\" value=\"1\"></value>\r\n\t\t      <value name=\"Active Power Overload\" value=\"2\"></value>\r\n                      <value name=\"Reactive Power Overload\" value=\"3\"></value>\r\n\t\t      <value name=\"Average RMS Over Voltage\" value=\"4\"></value>\r\n                      <value name=\"Average RMS Under Voltage\" value=\"5\"></value>\r\n\t\t      <value name=\"RMS Extreme Over Voltage\" value=\"6\"></value>\r\n                      <value name=\"RMS Extreme Under Voltage\" value=\"7\"></value>\r\n\t\t      <value name=\"RMS Voltage Sag\" value=\"8\"></value>\r\n                      <value name=\"RMS Voltage Swell\" value=\"9\"></value>\r\n\t  </attribute>\r\n          <attribute id=\"0x0801\" name=\"AC Voltage Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0802\" name=\"AC Current Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n\t  <attribute id=\"0x0803\" name=\"AC Active Power Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n          <attribute id=\"0x0804\" name=\"AC Reactive Power Overload\" type=\"s16\" access=\"r\" required=\"o\" default=\"0xffff\"></attribute>\r\n\t  <attribute id=\"0x0805\" name=\"Average RMS Over Voltage\" type=\"s16\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0806\" name=\"Average RMS Under Voltage\" type=\"s16\" access=\"r\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x0807\" name=\"RMS Extreme Over Voltage\" type=\"s16\" access=\"rw\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x0808\" name=\"RMS Extreme Under Voltage\" type=\"s16\" access=\"rw\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x0809\" name=\"RMS Voltage Sag\" type=\"s16\" access=\"rw\" required=\"o\"></attribute>\r\n\t  <attribute id=\"0x080a\" name=\"RMS Voltage Swell\" type=\"s16\" access=\"rw\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0900\" description=\"AC (Phase B) Measurements\">\r\n          <attribute id=\"0x0901\" name=\"Line Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0902\" name=\"Active Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0903\" name=\"Reactive Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0905\" name=\"RMS Voltage\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0906\" name=\"RMS Voltage Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0907\" name=\"RMS Voltage Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0908\" name=\"RMS Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0909\" name=\"RMS Current Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x090a\" name=\"RMS Current Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x090b\" name=\"Active Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x090c\" name=\"Active Power Min\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x090d\" name=\"Active Power Max\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x090e\" name=\"Reactive Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x090f\" name=\"Apparent Power\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0910\" name=\"Power Factor\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n\t  <attribute id=\"0x0911\" name=\"Average RMS Voltage Measurement Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0912\" name=\"Average RMS Over Voltage Counter\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0913\" name=\"Average RMS Under Voltage Counter\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0914\" name=\"RMS Extreme Over Voltage Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0915\" name=\"RMS Extreme Under Voltage Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0916\" name=\"RMS Voltage Sag Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0917\" name=\"RMS Voltage Swell Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0a00\" description=\"AC (Phase C) Measurements\">\r\n\t  <attribute id=\"0x0a01\" name=\"Line Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0a02\" name=\"Active Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a03\" name=\"Reactive Current\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a05\" name=\"RMS Voltage\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0a06\" name=\"RMS Voltage Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a07\" name=\"RMS Voltage Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0a08\" name=\"RMS Current\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0a09\" name=\"RMS Current Min\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n          <attribute id=\"0x0a0a\" name=\"RMS Current Max\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0a0b\" name=\"Active Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a0c\" name=\"Active Power Min\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a0d\" name=\"Active Power Max\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n\t  <attribute id=\"0x0a0e\" name=\"Reactive Power\" type=\"s16\" access=\"r\" required=\"o\" default=\"0x8000\"></attribute>\r\n          <attribute id=\"0x0a0f\" name=\"Apparent Power\" type=\"u16\" access=\"r\" required=\"o\" default=\"0xFFFF\"></attribute>\r\n\t  <attribute id=\"0x0a10\" name=\"Power Factor\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n\t  <attribute id=\"0x0a11\" name=\"Average RMS Voltage Measurement Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a12\" name=\"Average RMS Over Voltage Counter\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a13\" name=\"Average RMS Under Voltage Counter\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a14\" name=\"RMS Extreme Over Voltage Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a15\" name=\"RMS Extreme Under Voltage Period\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a16\" name=\"RMS Voltage Sag Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n\t  <attribute id=\"0x0a17\" name=\"RMS Voltage Swell Period\" type=\"u16\" access=\"rw\" required=\"o\" default=\"0x0000\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0b05\" name=\"Diagnostics\">\r\n      <description>The diagnostics cluster provides access to information regarding the operation of the ZigBee stack over time.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Hardware Information\">\r\n          <attribute id=\"0x0000\" name=\"Number of Resets\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Persistens Memory Writes\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0100\" description=\"Stack/Network Information\">\r\n          <attribute id=\"0x0100\" name=\"Mac Rx Bcast\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x00000000\"></attribute>\r\n          <attribute id=\"0x0101\" name=\"Mac Tx Bcast\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x00000000\"></attribute>\r\n          <attribute id=\"0x0102\" name=\"Mac Rx Ucast\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x00000000\"></attribute>\r\n          <attribute id=\"0x0103\" name=\"Mac Tx Ucast\" type=\"u32\" access=\"r\" required=\"o\" default=\"0x00000000\"></attribute>\r\n          <attribute id=\"0x0104\" name=\"Mac Tx Ucast Retry\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0105\" name=\"Mac Tx Ucast Fail\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0106\" name=\"APS Rx Bcast\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0107\" name=\"APS Tx Bcast\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0108\" name=\"APS Rx Ucast\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0109\" name=\"APS Tx Ucast Success\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010a\" name=\"APS Tx Ucast Retry\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010b\" name=\"APS Tx Ucast Fail\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010c\" name=\"Route Disc Initiated\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010d\" name=\"Neighbor Added\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010e\" name=\"Neighbor Removed\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x010f\" name=\"Neighbor Stale\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0110\" name=\"Join Indication\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0111\" name=\"Child Moved\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0112\" name=\"NWK FC Failure\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0113\" name=\"APS FC Failure\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0114\" name=\"APS Unauthorized Key\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0115\" name=\"NWK Decrypt Failures\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0116\" name=\"APS Decrypt Failures\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0117\" name=\"Packet Buffer Alloc Failures\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0118\" name=\"Relayed Ucast\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x0119\" name=\"Phy to MAC queue limit reached\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x011a\" name=\"Packet Validate Dropcount\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x011b\" name=\"Avg MAC Retry per APS Msg Sent\" type=\"u16\" access=\"r\" required=\"o\" default=\"0x0000\"></attribute>\r\n          <attribute id=\"0x011c\" name=\"Last Message LQI\" type=\"u8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n          <attribute id=\"0x011d\" name=\"Last Message RSSI\" type=\"s8\" access=\"r\" required=\"o\" default=\"0x00\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x4000\" description=\"Vendor specific attributes\">\r\n          <attribute id=\"0x4000\" name=\"SW error code\" type=\"bmp16\" access=\"rw\" default=\"0\" required=\"o\" mfcode=\"0x1246\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0500\" name=\"IAS Zone\">\r\n      <description>The IAS Zone cluster defines an interface to the functionality of an IAS security zone device. IAS Zone supports up to two alarm types per zone, low battery reports and supervision of the IAS network.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Zone information\">\r\n          <attribute id=\"0x0000\" name=\"Zone State\" type=\"enum8\" range=\"0x00,0x01\" access=\"r\" required=\"m\">\r\n            <value name=\"Not enrolled\" value=\"0x00\"></value>\r\n            <value name=\"Enrolled\" value=\"0x01\">\r\n              <description>The client will react to Zone State Change Notification commands from the server.</description>\r\n            </value>\r\n          </attribute>\r\n          <attribute id=\"0x0001\" name=\"Zone Type\" type=\"enum16\" range=\"0x0000,0xffff\" access=\"r\" required=\"m\">\r\n            <value name=\"Standard CIE\" value=\"0x0000\"></value>\r\n            <value name=\"Motion sensor\" value=\"0x000d\"></value>\r\n            <value name=\"Contact switch\" value=\"0x0015\"></value>\r\n            <value name=\"Fire sensor\" value=\"0x0028\"></value>\r\n            <value name=\"Water sensor\" value=\"0x002a\"></value>\r\n            <value name=\"Carbon Monoxide (CO) sensor\" value=\"0x002b\"></value>\r\n            <value name=\"Personal emergency device\" value=\"0x002c\"></value>\r\n            <value name=\"Vibration / Movement sensor\" value=\"0x002d\"></value>\r\n            <value name=\"Remote Control\" value=\"0x010f\"></value>\r\n            <value name=\"Key fob\" value=\"0x0115\"></value>\r\n            <value name=\"Keypad\" value=\"0x021d\"></value>\r\n            <value name=\"Standard Warning Device\" value=\"0x0225\"></value>\r\n            <value name=\"Glass break sensor\" value=\"0x0226\"></value>\r\n            <value name=\"Security repeater\" value=\"0x0229\"></value>\r\n            <value name=\"Manufacturer specific\" value=\"0x8000\"></value>\r\n            <value name=\"Invalid Zone Type\" value=\"0xffff\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0002\" type=\"bmp16\" name=\"Zone Status\" access=\"r\" required=\"m\">\r\n            <value name=\"Alarm 1\" value=\"0\"></value>\r\n            <value name=\"Alarm 2\" value=\"1\"></value>\r\n            <value name=\"Tamper\" value=\"2\"></value>\r\n            <value name=\"Battery\" value=\"3\"></value>\r\n            <value name=\"Supervision reports\" value=\"4\"></value>\r\n            <value name=\"Restore reports\" value=\"5\"></value>\r\n            <value name=\"Trouble\" value=\"6\"></value>\r\n            <value name=\"AC (mains)\" value=\"7\"></value>\r\n            <value name=\"Test\" value=\"8\"></value>\r\n            <value name=\"Battery defect\" value=\"9\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0010\" description=\"Zone settings\">\r\n          <attribute id=\"0x0010\" name=\"IAS_CIE_Address\" type=\"uid\" access=\"rw\" required=\"o\" default=\"0\"></attribute>\r\n          <attribute id=\"0x0011\" name=\"Zone ID\" type=\"u8\" range=\"0x00,0xff\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0012\" name=\"Number Of ZoneSensitivity Levels Supported\" type=\"u8\" range=\"0x02,0xff\" access=\"r\" required=\"o\" default=\"2\"></attribute>\r\n          <attribute id=\"0x0013\" name=\"Current Zone SensitivityLevel\" type=\"u8\" range=\"0x00,0xff\" access=\"rw\" required=\"o\" default=\"0\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x8000\" description=\"Develco specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x8000\" name=\"Zone Status Interval\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x8001\" name=\"Alarm Off Delay\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1015\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0xf000\" description=\"Xiaomi specific\" mfcode=\"0x1037\">\r\n          <attribute id=\"0xfff0\" name=\"Device config\" type=\"u64\" access=\"r\" required=\"o\" mfcode=\"0x115f\"></attribute>\r\n        </attribute-set>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Zone Enroll Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Enroll response code\" required=\"m\">\r\n              <value name=\"Success\" value=\"0x00\"></value>\r\n              <value name=\"Not supported\" value=\"0x01\"></value>\r\n              <value name=\"No enroll permit\" value=\"0x02\"></value>\r\n              <value name=\"Too many zones\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Initiate Normal Operation Mode\" required=\"o\">\r\n          <payload>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x00\" dir=\"send\" name=\"Zone Status Change Notification\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"bmp16\" name=\"Zone Status\" required=\"m\">\r\n              <value name=\"Alarm 1\" value=\"0\"></value>\r\n              <value name=\"Alarm 2\" value=\"1\"></value>\r\n              <value name=\"Tamper\" value=\"2\"></value>\r\n              <value name=\"Battery\" value=\"3\"></value>\r\n              <value name=\"Supervision reports\" value=\"4\"></value>\r\n              <value name=\"Restore reports\" value=\"5\"></value>\r\n              <value name=\"Trouble\" value=\"6\"></value>\r\n              <value name=\"AC (mains)\" value=\"7\"></value>\r\n              <value name=\"Test\" value=\"8\"></value>\r\n              <value name=\"Battery defect\" value=\"9\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"bmp8\" name=\"Extended Status\" default=\"0x00\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"u16\" name=\"Delay\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"send\" name=\"Zone Enroll request\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum16\" name=\"Zone Status\" required=\"m\">\r\n              <value name=\"Standard CIE\" value=\"0x0000\"></value>\r\n              <value name=\"Motion sensor\" value=\"0x000d\"></value>\r\n              <value name=\"Contact switch\" value=\"0x0015\"></value>\r\n              <value name=\"Fire sensor\" value=\"0x0028\"></value>\r\n              <value name=\"Water sensor\" value=\"0x002a\"></value>\r\n              <value name=\"Gas sensor\" value=\"0x002b\"></value>\r\n              <value name=\"Personal emergency device\" value=\"0x002c\"></value>\r\n              <value name=\"Vibration / Movement sensor\" value=\"0x002d\"></value>\r\n              <value name=\"Remote Control\" value=\"0x010f\"></value>\r\n              <value name=\"Key fob\" value=\"0x0115\"></value>\r\n              <value name=\"Keypad\" value=\"0x021d\"></value>\r\n              <value name=\"Standard Warning Device\" value=\"0x0225\"></value>\r\n              <value name=\"Invalid Zone Type\" value=\"0xffff\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"u16\" name=\"Manufacturer Code\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0501\" name=\"IAS ACE\">\r\n      <description>The IAS ACE cluster defines an interface to the functionality of any Ancillary Control Equipment of the IAS system. Using this cluster, a ZigBee enabled ACE device can access a IAS CIE device and manipulate the IAS system, on behalf of a level-2 user.</description>\r\n      <server>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Arm\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Arm Mode\" required=\"m\">\r\n              <value name=\"Disarm\" value=\"0x00\"></value>\r\n              <value name=\"Arm Day/Home Zones Only\" value=\"0x01\"></value>\r\n              <value name=\"Arm Night/Sleep Zones Only\" value=\"0x02\"></value>\r\n              <value name=\"Arm All Zones\" value=\"0x03\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"cstring\" name=\"Arm/Disarm Code\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Bypass\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Number of Zones\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"cstring\" name=\"Arm/Disarm Code\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Emergency\" required=\"m\"></command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Fire\" required=\"m\"></command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Panic\" required=\"m\"></command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Get Zone ID Map\" required=\"m\"></command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Get Zone Information\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Get Panel Status\" required=\"m\"></command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"Get Bypassed Zone List\" required=\"m\"></command>\r\n        <command id=\"0x09\" dir=\"recv\" name=\"Get Zone Status\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Starting Zone ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Max Number of Zone IDs\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"bool\" name=\"Zone Status Mask Flag\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"bmp16\" name=\"Zone Status Mask\" required=\"m\"></attribute>\r\n            <!--More to do here!!!-->\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Arm Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Arm Notification\" required=\"m\">\r\n              <value name=\"All Zones Disarmed\" value=\"0x00\"></value>\r\n              <value name=\"Only Day/Home Zones Armed\" value=\"0x01\"></value>\r\n              <value name=\"Only Night/Sleep Zones Armed\" value=\"0x02\"></value>\r\n              <value name=\"All Zones Armed\" value=\"0x03\"></value>\r\n              <value name=\"Invalid Arm/Disarm Code\" value=\"0x04\"></value>\r\n              <value name=\"Not ready to arm\" value=\"0x05\"></value>\r\n              <value name=\"Already disarmed\" value=\"0x06\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"cstring\" name=\"Arm/Disarm Code\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Get Zone ID Map Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"bmp16\" name=\"Zone ID Map section 0\" required=\"m\"></attribute>\r\n            <!--More to do here!!!-->\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x02\" dir=\"recv\" name=\"Get Zone Information Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"enum16\" name=\"Zone Type\" required=\"m\">\r\n              <value name=\"All Zones Disarmed\" value=\"0x00\"></value>\r\n              <value name=\"Only Day/Home Zones Armed\" value=\"0x01\"></value>\r\n              <value name=\"Only Night/Sleep Zones Armed\" value=\"0x02\"></value>\r\n              <value name=\"All Zones Armed\" value=\"0x03\"></value>\r\n              <value name=\"Invalid Arm/Disarm Code\" value=\"0x04\"></value>\r\n              <value name=\"Not ready to arm\" value=\"0x05\"></value>\r\n              <value name=\"Already disarmed\" value=\"0x06\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x02\" type=\"uid\" name=\"IEEE address\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"cstring\" name=\"Zone Label\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Zone Status Changed\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Zone ID\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"enum16\" name=\"Zone Status\" required=\"m\">\r\n              <!--More to do here!!!-->\r\n              <value name=\"All Zones Disarmed\" value=\"0x00\"></value>\r\n              <value name=\"Only Day/Home Zones Armed\" value=\"0x01\"></value>\r\n              <value name=\"Only Night/Sleep Zones Armed\" value=\"0x02\"></value>\r\n              <value name=\"All Zones Armed\" value=\"0x03\"></value>\r\n              <value name=\"Invalid Arm/Disarm Code\" value=\"0x04\"></value>\r\n              <value name=\"Not ready to arm\" value=\"0x05\"></value>\r\n              <value name=\"Already disarmed\" value=\"0x06\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x02\" type=\"enum8\" name=\"Audible Notification\" default=\"0x01\" required=\"m\">\r\n              <value name=\"Mute\" value=\"0x00\"></value>\r\n              <value name=\"Default sound\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x03\" type=\"cstring\" name=\"Zone Label\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x04\" dir=\"recv\" name=\"Panel Status Changed\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Panel Status\" required=\"m\">\r\n              <value name=\"Panel disarmed (all zones disarmed) and ready to arm\" value=\"0x00\"></value>\r\n              <value name=\"Armed stay\" value=\"0x01\"></value>\r\n              <value name=\"Armed night\" value=\"0x02\"></value>\r\n              <value name=\"Armed away\" value=\"0x03\"></value>\r\n              <value name=\"Exit delay\" value=\"0x04\"></value>\r\n              <value name=\"Entry delay\" value=\"0x05\"></value>\r\n              <value name=\"Not ready to arm\" value=\"0x06\"></value>\r\n              <value name=\"In alarm\" value=\"0x07\"></value>\r\n              <value name=\"Arming stay\" value=\"0x08\"></value>\r\n              <value name=\"Arming night\" value=\"0x09\"></value>\r\n              <value name=\"Arming away\" value=\"0x0a\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Seconds Remaining\" default=\"0x00\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"enum8\" name=\"Audible Notification\" default=\"0x01\" required=\"m\">\r\n              <value name=\"Mute\" value=\"0x00\"></value>\r\n              <value name=\"Default sound\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x03\" type=\"enum8\" name=\"Alarm Status\" default=\"0x00\" required=\"m\">\r\n              <value name=\"No alarm\" value=\"0x00\"></value>\r\n              <value name=\"Burglar\" value=\"0x01\"></value>\r\n              <value name=\"Fire\" value=\"0x02\"></value>\r\n              <value name=\"Emergency\" value=\"0x03\"></value>\r\n              <value name=\"Police Panic\" value=\"0x04\"></value>\r\n              <value name=\"Fire Panic\" value=\"0x05\"></value>\r\n              <value name=\"Emergency Panic (i.e., medical issue)\" value=\"0x06\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x04\" type=\"cstring\" name=\"Zone Label\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x05\" dir=\"recv\" name=\"Get Panel Status Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Panel Status\" required=\"m\">\r\n              <value name=\"Panel disarmed (all zones disarmed) and ready to arm\" value=\"0x00\"></value>\r\n              <value name=\"Armed stay\" value=\"0x01\"></value>\r\n              <value name=\"Armed night\" value=\"0x02\"></value>\r\n              <value name=\"Armed away\" value=\"0x03\"></value>\r\n              <value name=\"Exit delay\" value=\"0x04\"></value>\r\n              <value name=\"Entry delay\" value=\"0x05\"></value>\r\n              <value name=\"Not ready to arm\" value=\"0x06\"></value>\r\n              <value name=\"In alarm\" value=\"0x07\"></value>\r\n              <value name=\"Arming stay\" value=\"0x08\"></value>\r\n              <value name=\"Arming night\" value=\"0x09\"></value>\r\n              <value name=\"Arming away\" value=\"0x0a\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Seconds Remaining\" default=\"0x00\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"enum8\" name=\"Audible Notification\" default=\"0x01\" required=\"m\">\r\n              <value name=\"Mute\" value=\"0x00\"></value>\r\n              <value name=\"Default sound\" value=\"0x01\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x03\" type=\"enum8\" name=\"Alarm Status\" default=\"0x00\" required=\"m\">\r\n              <value name=\"No alarm\" value=\"0x00\"></value>\r\n              <value name=\"Burglar\" value=\"0x01\"></value>\r\n              <value name=\"Fire\" value=\"0x02\"></value>\r\n              <value name=\"Emergency\" value=\"0x03\"></value>\r\n              <value name=\"Police Panic\" value=\"0x04\"></value>\r\n              <value name=\"Fire Panic\" value=\"0x05\"></value>\r\n              <value name=\"Emergency Panic (i.e., medical issue)\" value=\"0x06\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x04\" type=\"cstring\" name=\"Zone Label\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x06\" dir=\"recv\" name=\"Set Bypassed Zone List\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Number of Zones\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Zone ID 1\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Zone ID 2\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"u8\" name=\"Zone ID 3\" required=\"m\"></attribute>\r\n            <attribute id=\"0x04\" type=\"u8\" name=\"Zone ID 4\" required=\"m\"></attribute>\r\n            <attribute id=\"0x05\" type=\"u8\" name=\"Zone ID 5\" required=\"m\"></attribute>\r\n            <attribute id=\"0x06\" type=\"u8\" name=\"Zone ID 6\" required=\"m\"></attribute>\r\n            <attribute id=\"0x07\" type=\"u8\" name=\"Zone ID 7\" required=\"m\"></attribute>\r\n            <attribute id=\"0x08\" type=\"u8\" name=\"Zone ID 8\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x07\" dir=\"recv\" name=\"Bypass Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"u8\" name=\"Number of Zones\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Bypass Result for Zone ID 1\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Bypass Result for Zone ID 2\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"u8\" name=\"Bypass Result for Zone ID 3\" required=\"m\"></attribute>\r\n            <attribute id=\"0x04\" type=\"u8\" name=\"Bypass Result for Zone ID 4\" required=\"m\"></attribute>\r\n            <attribute id=\"0x05\" type=\"u8\" name=\"Bypass Result for Zone ID 5\" required=\"m\"></attribute>\r\n            <attribute id=\"0x06\" type=\"u8\" name=\"Bypass Result for Zone ID 6\" required=\"m\"></attribute>\r\n            <attribute id=\"0x07\" type=\"u8\" name=\"Bypass Result for Zone ID 7\" required=\"m\"></attribute>\r\n            <attribute id=\"0x08\" type=\"u8\" name=\"Bypass Result for Zone ID 8\" required=\"m\"></attribute>\r\n            <!--\r\n              <value name=\"Zone bypassed\" value=\"0x00\"></value>\r\n              <value name=\"Zone not bypassed\" value=\"0x01\"></value>\r\n              <value name=\"Not allowed\" value=\"0x02\"></value>\r\n              <value name=\"Invalid Zone ID\" value=\"0x03\"></value>\r\n              <value name=\"Unknown Zone ID\" value=\"0x04\"></value>\r\n              <value name=\"Invalid Arm/Disarm Code\" value=\"0x05\"></value>\r\n            -->\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x08\" dir=\"recv\" name=\"Get Zone Status Response\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"bool\" name=\"Zone Status Complete\" required=\"m\"></attribute>\r\n            <attribute id=\"0x01\" type=\"u8\" name=\"Number of Zones\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Zone ID 1\" required=\"m\"></attribute>\r\n            <attribute id=\"0x03\" type=\"bmp16\" name=\"Zone ID 1 Zone Status\" required=\"m\"></attribute>\r\n            <attribute id=\"0x04\" type=\"u8\" name=\"Zone ID 2\" required=\"m\"></attribute>\r\n            <attribute id=\"0x05\" type=\"bmp16\" name=\"Zone ID 2 Zone Status\" required=\"m\"></attribute>\r\n            <attribute id=\"0x06\" type=\"u8\" name=\"Zone ID 3\" required=\"m\"></attribute>\r\n            <attribute id=\"0x07\" type=\"bmp16\" name=\"Zone ID 3 Zone Status\" required=\"m\"></attribute>\r\n            <attribute id=\"0x08\" type=\"u8\" name=\"Zone ID 4\" required=\"m\"></attribute>\r\n            <attribute id=\"0x09\" type=\"bmp16\" name=\"Zone ID 4 Zone Status\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0502\" name=\"IAS WD\">\r\n      <description>The IAS WD cluster provides an interface to the functionality of any Warning Device equipment of the IAS system. Using this cluster, a ZigBee enabled CIE device can access a ZigBee enabled IAS WD device and issue alarm warning indications (siren, strobe lighting, etc.) when a system alarm condition is detected.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Max Duration\" type=\"u16\" range=\"0x0000,0xfffe\" access=\"rw\" required=\"m\" default=\"240\"></attribute>\r\n\t<attribute id=\"0xF000\" name=\"Tuya Alarm mode\" type=\"u8\" access=\"rw\" required=\"o\">\r\n\t      <value name=\"Disarm the alarm\" value=\"0x00\"></value>\r\n              <value name=\"Sound alarm\" value=\"0x01\"></value>\r\n              <value name=\"Light alarm\" value=\"0x02\"></value>\r\n              <value name=\"Sound and light alarm\" value=\"0x03\"></value>\r\n\t</attribute>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Start warning\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"bmp8\" name=\"Options\" required=\"m\">\r\n              <value name=\"Siren level 0\" value=\"0\"></value>\r\n              <value name=\"Siren level 1\" value=\"1\"></value>\r\n              <value name=\"Strobe\" value=\"2\"></value>\r\n              <value name=\"Warning mode 0\" value=\"4\"></value>\r\n              <value name=\"Warning mode 1\" value=\"5\"></value>\r\n              <value name=\"Warning mode 2\" value=\"6\"></value>\r\n              <value name=\"Warning mode 3\" value=\"7\"></value>\r\n            </attribute>\r\n            <attribute id=\"0x01\" type=\"u16\" name=\"Warning duration\" required=\"m\"></attribute>\r\n            <attribute id=\"0x02\" type=\"u8\" name=\"Strobe duty cycle\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x00\" type=\"enum8\" name=\"Strobe level\" required=\"m\">\r\n              <value name=\"Low\" value=\"0x00\"></value>\r\n              <value name=\"Medium\" value=\"0x01\"></value>\r\n              <value name=\"High\" value=\"0x02\"></value>\r\n              <value name=\"Very high\" value=\"0x03\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Squawk\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x00\" type=\"bmp8\" name=\"Options\" required=\"m\">\r\n              <value name=\"Sqawk level 0\" value=\"0\"></value>\r\n              <value name=\"Sqawk level 1\" value=\"1\"></value>\r\n              <value name=\"Strobe\" value=\"3\"></value>\r\n              <value name=\"Sound for disarmed\" value=\"4\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Security and safety\" low_bound=\"0500\" high_bound=\"05ff\" description=\"The security and safety functional domain contains clusters and information to build devices in the security and safety domain, e.g. alarm units.\">\r\n  </domain>\r\n\r\n  <domain name=\"Protocol interfaces\" low_bound=\"0600\" high_bound=\"06ff\" description=\"The protocol interfaces functional domain contains clusters and information to build devices to interface to other protocols, e.g. BACnet.\">\r\n  </domain>\r\n\r\n  <domain name=\"Smart energy\" low_bound=\"0700\" high_bound=\"07ff\" description=\"TODO Smart Energy Description\">\r\n    <cluster id=\"0x0700\" name=\"Price\">\r\n      <description>The Price Cluster provides the mechanism for communicating Gas, Energy, or Water pricing information within the premise. This pricing information is distributed to the ESP from either the utilities or from regional energy providers.</description>\r\n      <server>\r\n        <attribute id=\"0000\" name=\"Tier1 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier1\"></attribute>\r\n        <attribute id=\"0001\" name=\"Tier2 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier2\"></attribute>\r\n        <attribute id=\"0002\" name=\"Tier3 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier3\"></attribute>\r\n        <attribute id=\"0003\" name=\"Tier4 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier4\"></attribute>\r\n        <attribute id=\"0004\" name=\"Tier5 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier5\"></attribute>\r\n        <attribute id=\"0005\" name=\"Tier6 Price Label\" type=\"ostring\" access=\"rw\" required=\"o\" range=\"0,12\" default=\"Tier6\"></attribute>\r\n        <command id=\"00\" dir=\"recv\" name=\"Get Current Price\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"bmp8\" name=\"Command Options\" required=\"m\">\r\n              <value name=\"Requestor Rx On When Idle\" value=\"0x00\"/>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Get Scheduled Prices\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"utc\" name=\"Start Time\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Number of Events\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0701\" name=\"Demand Response and Load Control\">\r\n      <description>This cluster provides an interface to the functionality of Smart Energy Demand Response and Load Control. Devices targeted by this cluster include thermostats and devices that support load control.</description>\r\n      <client>\r\n        <attribute id=\"0000\" name=\"Utility Enrolment Group\" type=\"u8\" access=\"rw\" default=\"0\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n        <attribute id=\"0001\" name=\"Start Randomize Minutes\" type=\"u8\" access=\"rw\" default=\"0x1e\" range=\"0x00,0x3c\" required=\"m\"></attribute>\r\n        <attribute id=\"0002\" name=\"Stop Randomize Minutes\" type=\"u8\" access=\"rw\" default=\"0x1e\" range=\"0x00,0x3c\" required=\"m\"></attribute>\r\n        <attribute id=\"0003\" name=\"Device Class Value\" type=\"u16\" access=\"r\" default=\"0x1e\" range=\"0x00,0xff\" required=\"m\"></attribute>\r\n      </client>\r\n      <server>\r\n        <!-- TODO -->\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0702\" name=\"Simple Metering\">\r\n      <description>The Simple Metering Cluster provides a mechanism to retrieve usage information from Electric, Gas, Water, and potentially Thermal metering devices.\r\nThese devices can operate on either battery or mains power, and can have a wide variety of sophistication.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Reading Information Set\">\r\n          <attribute id=\"0x0000\" name=\"Current Summation Delivered\" type=\"u48\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Current Summation Received\" type=\"u48\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x041b\" name=\"Unknown\" type=\"u64\" access=\"rw\" required=\"o\" mfcode=\"0x1037\"></attribute>\r\n          <!-- TODO -->\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0100\" description=\"TOU Information Set\">\r\n          <attribute id=\"0x0100\" name=\"Index HCHC/EJPHN/BBRHCJB, Current Summation Delivered (1)\" type=\"u48\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0102\" name=\"Index HCHP/EJPHPM/BBRHPJB, Current Summation Delivered(2)\" type=\"u48\" access=\"r\" required=\"m\"></attribute>\r\n          <!-- TODO -->\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0200\" description=\"Meter Status\">\r\n          <attribute id=\"0x0200\" name=\"Status\" type=\"bmp8\" default=\"00000000\" access=\"r\" required=\"m\">\r\n            <value name=\"Check Meter\" value=\"0\"></value>\r\n            <value name=\"Low Battery\" value=\"1\"></value>\r\n            <value name=\"Tamper Detect\" value=\"2\"></value>\r\n            <value name=\"Power Failure\" value=\"3\"></value>\r\n            <value name=\"Power Quality\" value=\"4\"></value>\r\n            <value name=\"Leak Detect\" value=\"5\"></value>\r\n            <value name=\"Service Disconnect Open\" value=\"6\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0300\" description=\"Formatting\">\r\n          <attribute id=\"0x0300\" name=\"Unit of Measure\" type=\"enum8\" default=\"0\" access=\"r\" required=\"m\">\r\n            <value name=\"kW &amp; kWh binary\" value=\"0\"></value>\r\n            <value name=\"m³ &amp; m³/h binary\" value=\"1\"></value>\r\n            <value name=\"ft³ &amp; ft³/h binary\" value=\"2\"></value>\r\n            <value name=\"ccf &amp; ccf/h binary\" value=\"3\"></value>\r\n            <value name=\"US gl &amp; Us gl/h binary\" value=\"4\"></value>\r\n            <value name=\"IMP gl &amp; IMP gl/h binary\" value=\"5\"></value>\r\n            <value name=\"BTUs &amp; BTU/h binary\" value=\"6\"></value>\r\n            <value name=\"Liters &amp; l/h binary\" value=\"7\"></value>\r\n            <value name=\"kPA(gauge) binary\" value=\"8\"></value>\r\n            <value name=\"kPA(absolute) binary\" value=\"9\"></value>\r\n            <value name=\"kW &amp; kWh BCD\" value=\"80\"></value>\r\n            <value name=\"m³ &amp; m³/h BCD\" value=\"81\"></value>\r\n            <value name=\"ft³ &amp; ft³/h BCD\" value=\"82\"></value>\r\n            <value name=\"ccf &amp; ccf/h BCD\" value=\"83\"></value>\r\n            <value name=\"US gl &amp; Us gl/h BCD\" value=\"84\"></value>\r\n            <value name=\"IMP gl &amp; IMP gl/h BCD\" value=\"85\"></value>\r\n            <value name=\"BTUs &amp; BTU/h BCD\" value=\"86\"></value>\r\n            <value name=\"Liters &amp; l/h BCD\" value=\"87\"></value>\r\n            <value name=\"kPA(gauge) BCD\" value=\"88\"></value>\r\n            <value name=\"kPA(absolute) BCD\" value=\"89\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0301\" name=\"Multiplier\" type=\"u24\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0302\" name=\"Divisor\" type=\"u24\" access=\"r\" required=\"o\"></attribute>\r\n          <attribute id=\"0x0303\" name=\"Summation Formatting\" type=\"bmp8\" access=\"r\" required=\"m\">\r\n            <value name=\"Number Digits Right\" description=\"Number of Digets to the right of the Decimal Point\" value=\"0,2\"></value>\r\n            <value name=\"Number Digits Left\" description=\"Number of Digets to the left of the Decimal Point\" value=\"3,6\"></value>\r\n            <value name=\"Suppress Leading Zeros\" value=\"7\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0304\" name=\"Demand Formatting\" type=\"bmp8\" access=\"r\" required=\"o\">\r\n            <value name=\"Number Digits Right\" description=\"Number of Digets to the right of the Decimal Point\" value=\"0,2\"></value>\r\n            <value name=\"Number Digits Left\" description=\"Number of Digets to the left of the Decimal Point\" value=\"3,6\"></value>\r\n            <value name=\"Suppress Leading Zeros\" value=\"7\"></value>\r\n          </attribute>\r\n          <!-- TODO -->\r\n          <attribute id=\"0x0306\" name=\"Metering Device Type\" type=\"enum8\" access=\"r\" required=\"m\">\r\n            <value name=\"Electric Metering\" value=\"0\"></value>\r\n            <value name=\"Gas Metering\" value=\"1\"></value>\r\n            <value name=\"Water Metering\" value=\"2\"></value>\r\n            <value name=\"Thermal Metering\" value=\"3\"></value>\r\n            <value name=\"Pressure Metering\" value=\"4\"></value>\r\n            <value name=\"Heat Metering\" value=\"5\"></value>\r\n            <value name=\"Cooling Metering\" value=\"6\"></value>\r\n            <value name=\"Mirrored Gas Metering\" value=\"128\"></value>\r\n            <value name=\"Mirrored Water Metering\" value=\"129\"></value>\r\n            <value name=\"Mirrored Thermal Metering\" value=\"130\"></value>\r\n            <value name=\"Mirrored Pressure Metering\" value=\"131\"></value>\r\n            <value name=\"Mirrored Heat Metering\" value=\"132\"></value>\r\n            <value name=\"Mirrored Cooling Metering\" value=\"133\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0308\" name=\"Meter Serial Number\" type=\"ostring\" range=\"0,24\" access=\"r\" required=\"o\"></attribute>\r\n          <!-- TODO -->\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0300\" description=\"Develco specific\" mfcode=\"0x1015\">\r\n          <attribute id=\"0x0300\" name=\"Pulse Configuration\" type=\"u16\" access=\"rw\" required=\"o\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x0301\" name=\"Current Summation\" type=\"u48\" access=\"w\" required=\"o\" mfcode=\"0x1015\"></attribute>\r\n          <attribute id=\"0x0302\" name=\"Interface Mode\" type=\"enum16\" access=\"rw\" required=\"o\" mfcode=\"0x1015\">\r\n            <value name=\"Pulse Counting on an Electricity Meter – Unit KWh\" value=\"0x0000\"></value>\r\n            <value name=\"Pulse Counting on a Gas Meter – Unit m3\" value=\"0x0001\"></value>\r\n            <value name=\"Pulse Counting on a Water Meter – Unit m3\" value=\"0x0002\"></value>\r\n            <value name=\"Kamstrup KMP Protocol\" value=\"0x0100\"></value>\r\n            <value name=\"Not Supported - Linky Protocol\" value=\"0x0101\"></value>\r\n            <value name=\"DLMS-COSEM - IEC62056-21 mod A\" value=\"0x0102\"></value>\r\n            <value name=\"P1 Dutch Standard – DSMR 2.3 Version\" value=\"0x0103\"></value>\r\n            <value name=\"P1 Dutch Standard – DSMR 4.0 Version\" value=\"0x0104\"></value>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0400\" description=\"ESP Historical Consumption\">\r\n          <attribute id=\"0x0400\" name=\"Instantaneous Demand\" type=\"s24\" access=\"r\" required=\"o\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0500\" description=\"Load Profile Configuration\">\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0600\" description=\"Supply Limit\">\r\n        </attribute-set>\r\n        <!-- TODO -->\r\n        <!-- dont support generated commands yet\r\n        <command id=\"01\" dir=\"send\" name=\"Get Profile Response\" required=\"o\">\r\n          <payload>\r\n            <field type=\"utc\" name=\"End Time\"></field>\r\n            <field type=\"enum8\" name=\"Status\">\r\n              <value name=\"Success\" value=\"0x00\"/>\r\n              <value name=\"Undefined Interval Channel requested\" value=\"0x01\"/>\r\n              <value name=\"Interval Channel not supported\" value=\"0x02\"/>\r\n              <value name=\"Invalid End Time\" value=\"0x03\"/>\r\n              <value name=\"More periods requested then can be returned\" value=\"0x04\"/>\r\n              <value name=\"No intervals available for the requested time\" value=\"0x05\"/>\r\n            </field>\r\n            <field type=\"enum8\" name=\"Profile Interval Period\">\r\n              <value name=\"Daily\" value=\"0\"/>\r\n              <value name=\"60 minutes\" value=\"1\"/>\r\n              <value name=\"30 minutes\" value=\"2\"/>\r\n              <value name=\"15 minutes\" value=\"3\"/>\r\n              <value name=\"10 minutes\" value=\"4\"/>\r\n              <value name=\"7.5 minutes\" value=\"5\"/>\r\n              <value name=\"5 minutes\" value=\"6\"/>\r\n              <value name=\"2.5 minutes\" value=\"7\"/>\r\n            </field>\r\n            <field type=\"u8\" name=\"Number Of Periods Delivered\"></field>\r\n            <field type=\"u24\" name=\"Intervals\" list=\"true\"></field>\r\n          </payload>\r\n        </command>\r\n        -->\r\n        <command id=\"00\" dir=\"recv\" name=\"Get Profile\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Interval Channel\" required=\"m\">\r\n              <value name=\"Consumption Delivered\" value=\"0x00\"/>\r\n              <value name=\"Consumption Received\" value=\"0x01\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0001\" type=\"utc\" name=\"End Time\" required=\"m\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Number Of Periods\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"01\" dir=\"recv\" name=\"Request Mirror Response\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"EndPoint ID\" range=\"0x0001,0x00f0\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"02\" dir=\"recv\" name=\"Mirror Removed\" required=\"o\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Removed EndPoint ID\" range=\"0x0001,0x00f0\" required=\"m\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0703\" name=\"Message\">\r\n      <description>This cluster provides an interface for passing text messages between ZigBee devices.</description>\r\n      <server>\r\n      </server>\r\n      <client>\r\n      </client>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0704\" name=\"Smart Energy Tunneling (Complex Metering)\">\r\n      <description>The tunneling cluster provides an interface for tunneling protocols.</description>\r\n      <server>\r\n        <attribute id=\"0000\" name=\"Close Tunnel Timeout\" type=\"u16\" range=\"0x0001,0xFFFF\" default=\"0xFFFF\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n      <!-- TODO -->\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0705\" name=\"Prepayment\">\r\n      <description></description>\r\n      <!-- TODO -->\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Appliances\" low_bound=\"0b00\" high_bound=\"0b03\" description=\"The Appliance clusters are typically used in ZigBee appliance management.\">\r\n    <cluster id=\"0x001b\" name=\"Appliance Control\">\r\n      <description>The Appliance Control cluster provides an interface to remotely control and to program household appliances. Example of control is Start, Stop and Pause commands.</description>\r\n      <server>\r\n        <!-- TODO -->\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0b00\" name=\"Appliance Identification\">\r\n      <description>Attributes and commands for determining basic information about a device and setting user device information. The Appliance Identification Cluster is a transposition of EN50523 \"Identify Product\" functional block.</description>\r\n      <server>\r\n        <!-- TODO -->\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0b01\" name=\"Meter Identification\">\r\n      <description>Attributes and commands that provide an interface to meter identification.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" type=\"cstring\" name=\"CompanyName\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0001\" type=\"u16\" name=\"MeterTypeID\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0004\" type=\"u16\" name=\"DataQualityID\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0005\" type=\"cstring\" name=\"CustomerName\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0006\" type=\"ostring\" name=\"Model\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0007\" type=\"ostring\" name=\"PartNumber\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0008\" type=\"ostring\" name=\"ProductRevision\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x000a\" type=\"ostring\" name=\"SoftwareRevision\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x000b\" type=\"cstring\" name=\"UtilityName\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x000c\" type=\"u16\" name=\"POD\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x000d\" type=\"s24\" name=\"AvailablePower\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x000e\" type=\"s24\" name=\"PowerThreshold\" access=\"r\" required=\"m\"/>\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0b02\" name=\"Appliance Events and Alerts\">\r\n      <description>Attributes and commands for transmitting or notifying the occurrence of an event, such as \"temperature reached\" and of an alert such as alarm, fault or warning. It is based on the \"Signal event\" syntax of EN50523 and completed where necessary.</description>\r\n      <server>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Get Alerts\" required=\"m\">\r\n          <description>The get group identifiers request command is used to retrieve the actual group identifiers that the endpoint is using in its multicast communication in controlling different (remote) devices.</description>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0x0b03\" name=\"Appliance Statistics\">\r\n      <description>The Appliance Statistics provides a mechanism for transmitting appliance statistics to a collection unit (gateway). The statistics can be in format of data logs.</description>\r\n      <server>\r\n        <!-- TODO -->\r\n      </server>\r\n      <client>\r\n        <!-- TODO -->\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Light Link\" useZcl=\"true\" description=\"The light link domain contains clusters and information that provides ZLL specific functions and attributes.\">\r\n    <cluster id=\"0x1000\" name=\"Touchlink Commissioning\">\r\n      <description>Attributes and commands for touchlink commissioning.</description>\r\n      <server>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Get group identifiers\" required=\"m\" response=\"0x41\">\r\n          <description>The get group identifiers request command is used to retrieve the actual group identifiers that the endpoint is using in its multicast communication in controlling different (remote) devices.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Start index\" showas=\"dec\" required=\"m\" default=\"0\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x42\" dir=\"recv\" name=\"Get endpoint list\" required=\"m\" response=\"0x42\">\r\n          <description>The get endpoint list request command is used to retrieve addressing information for each endpoint the device is using in its unicast communication in controlling different (remote) devices.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Start index\" showas=\"dec\" required=\"m\" default=\"0\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0xd0\" dir=\"recv\" name=\"Write MAC address\" required=\"m\" vendor=\"0x1135\">\r\n          <description>Non standard write MAC address (DDEL).</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u64\" name=\"MAC address\" showas=\"hex\" required=\"m\" default=\"0\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n        <command id=\"0x41\" dir=\"recv\" name=\"Get group identifiers response\" required=\"m\">\r\n          <description>The get group identifiers response command allows a remote device to respond to the get group identifiers request command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Total\" required=\"m\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Start index\" required=\"m\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Count\" required=\"m\" default=\"0\"></attribute>\r\n            <!-- TODO this will display only first item of the list -->\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"First group ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" name=\"First group type\" showas=\"hex\" required=\"m\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x42\" dir=\"recv\" name=\"Get endpoint list response\" required=\"m\">\r\n          <description>The get group identifiers response command allows a remote device to respond to the get group identifiers request command.</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u8\" name=\"Total\" required=\"m\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"Start index\" required=\"m\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"Count\" required=\"m\" default=\"0\"></attribute>\r\n            <!-- TODO this will display only first item of the list -->\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"NWK address\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" name=\"Endpoint\" showas=\"hex\" required=\"m\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0005\" type=\"u16\" name=\"Profile ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0006\" type=\"u16\" name=\"Device ID\" showas=\"hex\" required=\"m\" default=\"0x0000\"></attribute>\r\n            <attribute id=\"0x0007\" type=\"u8\" name=\"Version\" showas=\"hex\" required=\"m\" default=\"0x00\"></attribute>\r\n          </payload>\r\n        </command>\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <domain name=\"Green Power\" useZcl=\"true\"\r\n    description=\"The green power domain contains clusters and information that provides ZGP specific functions and attributes.\">\r\n    <cluster id=\"0x0021\" name=\"Green Power\">\r\n      <description>Attributes and commands.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Max Sink Table Entries\" type=\"u8\" default=\"0x00\" access=\"r\" required=\"m\" showas=\"hex\">\r\n          <description>Maximum number of Sink Table entries supported by this device.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Sink Table\" type=\"lostring\" default=\"0x0000\" access=\"r\" required=\"m\" showas=\"hex\">\r\n          <description>Sink Table, holding information about local bindings between a particular GPD and target‘s local endpoints.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Communication Mode\" type=\"bmp8\" default=\"0x01\" access=\"rw\" required=\"m\" showas=\"hex\">\r\n          <description>Default communication mode requested by this sink.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0003\" name=\"Commissioning Exit Mode\" type=\"bmp8\" default=\"0x02\" access=\"rw\" required=\"m\" showas=\"hex\">\r\n          <description>Conditions for the sink to exit the commissioning mode.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0004\" name=\"Commissioning Window\" type=\"u16\" default=\"0x00B4\" access=\"rw\" required=\"o\" showas=\"hex\">\r\n          <description>Default duration of the Commissioning window duration, in seconds, as requested by this sink.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0005\" name=\"Security Level\" type=\"bmp8\" default=\"0x06\" access=\"rw\" required=\"m\" showas=\"hex\">\r\n          <description>The minimum required security level to be supported by the paired GPDs.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0006\" name=\"Functionality\" type=\"bmp24\" default=\"0x0\" access=\"r\" required=\"m\" showas=\"hex\">\r\n          <description>The optional GP functionality supported by this sink.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0007\" name=\"Active Functionality\" type=\"bmp24\" default=\"0xffffff\" access=\"r\" required=\"m\" showas=\"hex\">\r\n          <description>The optional GP functionality supported by this sink that is active.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0020\" name=\"Shared Security Key Type\" type=\"bmp8\" default=\"0x00\" access=\"r\" required=\"m\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0021\" name=\"Shared Security Key\" type=\"seckey\" access=\"r\" required=\"m\" showas=\"hex\"></attribute>\r\n        <attribute id=\"0x0022\" name=\"GP Link Key\" type=\"seckey\" access=\"r\" required=\"m\" showas=\"hex\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    <device id=\"0x0060\" name=\"GP Proxy\" description=\"\"></device>\r\n    <device id=\"0x0061\" name=\"GP Proxy Basic\" description=\"\"></device>\r\n    <device id=\"0x0062\" name=\"GP Target Plus\" description=\"\"></device>\r\n    <device id=\"0x0063\" name=\"GP Target\" description=\"\"></device>\r\n    <device id=\"0x0064\" name=\"GP Commissioning Tool\" description=\"\"></device>\r\n    <device id=\"0x0065\" name=\"GP Combo\" description=\"\"></device>\r\n    <device id=\"0x0066\" name=\"GP Combo Basic\" description=\"\"></device>\r\n  </domain>\r\n\r\n  <domain name=\"Manufacturer Specific\" useZcl=\"true\" description=\"Manufacturer specific clusters.\">\r\n    <!-- Dresden Elektronik -->\r\n    <cluster id=\"0xfc00\" name=\"Spectral Measurement\" mfcode=\"0x1135\">\r\n      <description>Dresden Elektronik Specific clusters.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" type=\"u8\" name=\"On\" required=\"m\" access=\"rw\" default=\"0\">\r\n          <description>Enable Sensor </description>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"X-Value\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"m\" showas=\"dec\">\r\n          <description>X-Value</description>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Y-Value\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"m\" showas=\"dec\">\r\n          <description>Y-Value</description>\r\n        </attribute>\r\n        <attribute id=\"0x0003\" name=\"Z-Value\" type=\"u16\" default=\"0x0000\" access=\"r\" required=\"m\" showas=\"dec\">\r\n          <description>Z-Value</description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- Hue -->\r\n    <cluster id=\"0xfc00\" name=\"Hue Button\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster for Hue dimmer family.</description>\r\n      <server>\r\n        <command id=\"0x00\" dir=\"send\" name=\"Button Action Notification\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Button\" required=\"m\"/>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Event Type\" required=\"m\">\r\n              <value name=\"Button\" value=\"0x00\"/>\r\n              <value name=\"Rotary\" value=\"0x01\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"\" showas=\"hex\" required=\"m\">\r\n              <description>Type of next attribute</description>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"enum8\" name=\"Action\" required=\"m\">\r\n              <value name=\"Press\" value=\"0x00\"/>\r\n              <value name=\"Hold / Start\" value=\"0x01\"/>\r\n              <value name=\"Release / Repeat\" value=\"0x02\"/>\r\n              <value name=\"Long Release\" value=\"0x03\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" name=\"\" showas=\"hex\" required=\"m\">\r\n              <description>Type of next attribute</description>\r\n            </attribute>\r\n            <attribute id=\"0x0005\" type=\"s16\" name=\"Duration / Rotation\" required=\"m\"/>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc01\" name=\"Hue Entertainment\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster for Hue Entertainment.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Capabilities\" type=\"bmp8\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <value name=\"Proxy\" value=\"0\"/>\r\n          <value name=\"Renderer\" value=\"1\"/>\r\n          <value name=\"Multiple Segements\" value=\"2\"/>\r\n          <value name=\"Supported\" value=\"3\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Segments\" type=\"u8\" mfcode=\"0x100b\" access=\"r\" default=\"1\" required=\"o\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc02\" name=\"Hue Outlet\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster for Hue smart plugs.</description>\r\n      <server>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc03\" name=\"Hue Effects\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster for Hue lights.</description>\r\n      <server>\r\n        <command id=\"0x00\" dir=\"recv\" name=\"Set Effect\" vendor=\"0x100b\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Command\" showas=\"hex\" default=\"0x0020\" required=\"o\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Effect\" required=\"m\">\r\n              <value name=\"None\" value=\"0x00\"/>\r\n              <value name=\"Candle\" value=\"0x01\"/>\r\n              <value name=\"Fire\" value=\"0x02\"/>\r\n              <value name=\"Prism\" value=\"0x03\"/>\r\n              <value name=\"Sunrise\" value=\"0x09\"/>\r\n              <value name=\"Sparkle\" value=\"0x0a\"/>\r\n              <value name=\"Opal\" value=\"0x0b\"/>\r\n              <value name=\"Glisten\" value=\"0x0c\"/>\r\n              <value name=\"Sunset\" value=\"0x0d\"/>\r\n              <value name=\"Underwater\" value=\"0x0e\"/>\r\n              <value name=\"Cosmos\" value=\"0x0f\"/>\r\n              <value name=\"Sunbeam\" value=\"0x10\"/>\r\n              <value name=\"Enchant\" value=\"0x11\"/>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <attribute id=\"0x0001\" name=\"Capabilities\" type=\"bmp32\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <value name=\"Unknown 00\" value=\"0\"/>\r\n          <value name=\"Unknown 01\" value=\"1\"/>\r\n          <value name=\"Effects\" value=\"2\"/>\r\n          <value name=\"Gradient\" value=\"3\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Light State\" type=\"ostring\" mfcode=\"0x100b\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Unknown 10\" type=\"bmp16\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <value name=\"Unknown 00\" value=\"0\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0011\" name=\"Effects\" type=\"bmp64\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n          <value name=\"Candle\" value=\"0x01\"/>\r\n          <value name=\"Fire\" value=\"0x02\"/>\r\n          <value name=\"Prism\" value=\"0x03\"/>\r\n          <value name=\"Sunrise\" value=\"0x09\"/>\r\n          <value name=\"Sparkle\" value=\"0x0a\"/>\r\n          <value name=\"Opal\" value=\"0x0b\"/>\r\n          <value name=\"Glisten\" value=\"0x0c\"/>\r\n          <value name=\"Sunset\" value=\"0x0d\"/>\r\n          <value name=\"Underwater\" value=\"0x0e\"/>\r\n          <value name=\"Cosmos\" value=\"0x0f\"/>\r\n          <value name=\"Sunbeam\" value=\"0x10\"/>\r\n          <value name=\"Enchant\" value=\"0x11\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0012\" name=\"Gradient Unknown 12\" type=\"bmp32\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n          <value name=\"Unknown 00\" value=\"0x00\"/>\r\n          <value name=\"Unknwon 01\" value=\"0x01\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0013\" name=\"Gradient Styles\" type=\"bmp16\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n          <value name=\"Linear\" value=\"0x00\"/>\r\n          <value name=\"Scattered\" value=\"0x01\"/>\r\n          <value name=\"Mirrored\" value=\"0x02\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0030\" name=\"Gradient Pixel Count\" type=\"u8\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0031\" name=\"Gradient Pixel Length\" type=\"u16\" mfcode=\"0x100b\" access=\"r\" required=\"o\">\r\n          <description>Physical length of a gradient pixel (in 0.1 mm).</description>\r\n        </attribute>\r\n        <attribute id=\"0x0032\" name=\"Gradient Unknown 32\" type=\"u8\" mfcode=\"0x100b\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0033\" name=\"Gradient Reverse Colors\" type=\"u8\" mfcode=\"0x100b\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0034\" name=\"Gradient Unknown 34\" type=\"u8\" mfcode=\"0x100b\" access=\"rw\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0035\" name=\"Gradient Unknown 35\" type=\"u8\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n        <attribute id=\"0x0036\" name=\"Gradient Max Segments\" type=\"u8\" mfcode=\"0x100b\" access=\"r\" required=\"o\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc04\" name=\"Hue Unknown\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster.</description>\r\n      <server>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc06\" name=\"Hue Unknown\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster.</description>\r\n      <server>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- Hue for Lutron Aurora -->\r\n    <cluster id=\"0xfc00\" name=\"Hue Button\" mfcode=\"0x1144\">\r\n      <description>Hue-specific cluster for Hue dimmer family.</description>\r\n      <server>\r\n        <command id=\"0x00\" dir=\"send\" name=\"Button Action Notification\" required=\"m\">\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Button\" required=\"m\"/>\r\n            <attribute id=\"0x0001\" type=\"enum8\" name=\"Event Type\" required=\"m\">\r\n              <value name=\"Button\" value=\"0x00\"/>\r\n              <value name=\"Rotary\" value=\"0x01\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0002\" type=\"u8\" name=\"\" showas=\"hex\" required=\"m\">\r\n              <description>Type of next attribute</description>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"enum8\" name=\"Action\" required=\"m\">\r\n              <value name=\"Press\" value=\"0x00\"/>\r\n              <value name=\"Hold / Start\" value=\"0x01\"/>\r\n              <value name=\"Release / Repeat\" value=\"0x02\"/>\r\n              <value name=\"Long Release\" value=\"0x03\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0004\" type=\"u8\" name=\"\" showas=\"hex\" required=\"m\">\r\n              <description>Type of next attribute</description>\r\n            </attribute>\r\n            <attribute id=\"0x0005\" type=\"s16\" name=\"Duration / Rotation\" required=\"m\"/>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc06\" name=\"Hue Secure\" mfcode=\"0x100b\">\r\n      <description>Hue-specific cluster for Hue Secure Contact Sensor.</description>\r\n      <server>\r\n        <attribute id=\"0x0100\" name=\"Contact\" type=\"enum8\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <value name=\"Close\" value=\"0\"/>\r\n          <value name=\"Open\" value=\"1\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0101\" name=\"Last Contact Change\" type=\"u32\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <description>The time in 0.1s since last change to the Contact state.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0102\" name=\"Tamper\" type=\"enum8\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <value name=\"Battery Door Closed\" value=\"0\"/>\r\n          <value name=\"Battery Door Open\" value=\"1\"/>\r\n        </attribute>\r\n        <attribute id=\"0x0103\" name=\"Last Tamper Change\" type=\"u32\" mfcode=\"0x100b\" access=\"r\" required=\"m\">\r\n          <description>The time in 0.1s since last change to the Tamper state.</description>\r\n        </attribute>\r\n      </server>\r\n    </cluster>\r\n\r\n    <!-- Sunricher C4 -->\r\n    <cluster id=\"0xfc00\" name=\"Device Setup\" mfcode=\"0x1224\">\r\n      <description>Sunricher-specific cluster.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" type=\"array\" name=\"Input Configurations\" access=\"rw\" required=\"m\" mfcode=\"0x1224\"/>\r\n        <attribute id=\"0x0001\" type=\"array\" name=\"Input Actions\" access=\"rw\" required=\"m\" mfcode=\"0x1224\"/>\r\n      </server>\r\n    </cluster>\r\n\r\n    <!-- LiXee -->\r\n    <cluster id=\"0xff66\" name=\"LiXee specific cluster\" mfcode=\"0x1037\">\r\n      <description>LiXee specific cluster.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" type=\"cstring\" name=\"Option tarifaire\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0002\" type=\"u8\" name=\"Horaire HP-HC\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0003\" type=\"u8\" name=\"Présence des potentiels\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0004\" type=\"u8\" name=\"Préavis début EJP\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0005\" type=\"u16\" name=\"Avertissement de Dépassement De Puissance Souscrite\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0006\" type=\"u16\" name=\"Avertissement de Dépassement D'intensité P1\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0007\" type=\"u16\" name=\"Avertissement de Dépassement D'intensité P2\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0008\" type=\"u16\" name=\"Avertissement de Dépassement D'intensité P3\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0200\" type=\"cstring\" name=\"Libellé tarif fournisseur en cours\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0203\" type=\"u32\" name=\"Energie active soutirée Distributeur, index 01\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0203\" type=\"u32\" name=\"Energie active soutirée Distributeur, index 01\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0207\" type=\"u16\" name=\"Puissance app. Instantanée injectée\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n        <attribute id=\"0x0217\" type=\"cstring\" name=\"Registre de Statuts\" access=\"r\" required=\"m\"/>\r\n        <attribute id=\"0x0300\" type=\"u8\" name=\"Protocole Linky\" access=\"r\" required=\"m\" default=\"0x00\"/>\r\n      </server>\r\n    </cluster>\r\n\r\n    <!-- Tuya -->\r\n    <cluster id=\"0xe001\" name=\"Tuya specific\" mfcode=\"0x1141\">\r\n\t\t\t<description>Tuya Specific switch mode cluster.</description>\r\n\t\t\t<server>\r\n\t\t\t<attribute id=\"0xD010\" type=\"enum8\" name=\"Power On Behavior\" default=\"0x02\" access=\"rw\" required=\"m\">\r\n\t\t\t\t<description>Power on behavior</description>\r\n\t\t\t\t\t<value name=\"Off\" value=\"0x00\"></value>\r\n\t\t\t\t\t<value name=\"On\" value=\"0x01\"></value>\r\n\t\t\t\t\t<value name=\"Last state\" value=\"0x02\"></value>\r\n\t\t\t</attribute>\r\n\t\t\t<attribute id=\"0xD011\" type=\"enum8\" name=\"unknown\" access=\"rw\" required=\"m\">\r\n\t\t\t\t<description>Seems used in some switches then casting -tuya magic-</description>\r\n\t\t\t</attribute>\r\n\t\t\t<attribute id=\"0xD030\" type=\"enum8\" name=\"Switch mode\" default=\"0x00\" access=\"rw\" required=\"m\">\r\n\t\t\t\t<description>Switch mode</description>\r\n\t\t\t\t\t<value name=\"Toggle\" value=\"0x00\"></value>\r\n\t\t\t\t\t<value name=\"State\" value=\"0x01\"></value>\r\n\t\t\t\t\t<value name=\"Momentary\" value=\"0x02\"></value>\r\n\t\t\t</attribute>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t</client>\r\n\t\t</cluster>\r\n   <cluster id=\"0xe002\" name=\"Tuya specific\" mfcode=\"0x1141\">\r\n\t\t\t<description>Tuya Specific alarm threshold cluster.</description>\r\n\t\t\t<server>\r\n\t\t\t<attribute id=\"0xD006\" type=\"u8\" name=\"alarm_temperature\" access=\"rw\" required=\"o\">\r\n\t\t\t\t\t<value name=\"Min alarm\" value=\"0x00\"></value>\r\n\t\t\t\t\t<value name=\"Max alarm\" value=\"0x01\"></value>\r\n\t\t\t\t\t<value name=\"Alarm off\" value=\"0x02\"></value>\r\n\t\t\t</attribute>\r\n\t\t\t<attribute id=\"0xD00A\" type=\"u16\" name=\"alarm_temperature_max\" access=\"rw\" required=\"o\" />\r\n\t\t\t<attribute id=\"0xD00B\" type=\"u16\" name=\"alarm_temperature_min\" access=\"rw\" required=\"o\" />\r\n\t\t\t<attribute id=\"0xD00C\" type=\"u16\" name=\"alarm_humidity_max\" access=\"rw\" required=\"o\" />\r\n\t\t\t<attribute id=\"0xD00E\" type=\"u16\" name=\"alarm_humidity_min\" access=\"rw\" required=\"o\" />\r\n\t\t\t<attribute id=\"0xD00F\" type=\"u8\" name=\"alarm_humidity\" default=\"0x00\" access=\"rw\" required=\"o\">\r\n\t\t\t\t\t<value name=\"Min alarm\" value=\"0x00\"></value>\r\n\t\t\t\t\t<value name=\"Max alarm\" value=\"0x01\"></value>\r\n\t\t\t\t\t<value name=\"Alarm off\" value=\"0x02\"></value>\r\n\t\t\t</attribute>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t</client>\r\n    </cluster>\r\n    <cluster id=\"0xef00\" name=\"Tuya specific\" mfcode=\"0x1002\">\r\n      <description>Tuya Specific clusters.</description>\r\n      <server>\r\n        <command id=\"00\" dir=\"recv\" name=\"Data Request\" required=\"m\">\r\n          <description>Request datapoint (fields are big-endian!)</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"u16\" name=\"Sequence number\" required=\"m\" showas=\"hex\" default=\"0\"></attribute>\r\n            <attribute id=\"0x0001\" type=\"u8\" name=\"DPID\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0002\" type=\"enum8\" name=\"Type\" required=\"m\" showas=\"hex\" default=\"0x00\">\r\n              <value name=\"Raw\" value=\"0x00\"/>\r\n              <value name=\"Bool\" value=\"0x01\"/>\r\n              <value name=\"Value\" value=\"0x02\"/>\r\n              <value name=\"String\" value=\"0x03\"/>\r\n              <value name=\"Enum\" value=\"0x04\"/>\r\n              <value name=\"Bitmap\" value=\"0x05\"/>\r\n            </attribute>\r\n            <attribute id=\"0x0003\" type=\"u16\" name=\"Length\" required=\"m\" showas=\"hex\" default=\"0x00\"></attribute>\r\n            <attribute id=\"0x0004\" type=\"u32\" name=\"Value\" required=\"m\" showas=\"hex\" default=\"0\"></attribute>\r\n          </payload>\r\n        </command>\r\n        <command id=\"0x03\" dir=\"recv\" name=\"Data Query\" required=\"m\">\r\n          <description>Trigger report all datapoints.</description>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- Legrand -->\r\n    <cluster id=\"0xfc01\" name=\"Legrand - Specific clusters\" mfcode=\"1021\">\r\n      <description>Legrand Classic Specific clusters, used by all devices. But take care they are device specific.\r\n> Dimmer switch without neutral : Option 1 = Dimmer on/off.\r\n> Cable outlet : Option 1 = Fil pilote on/off.\r\n> Contactor : On/off=0003 - HP/HC=0004.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" type=\"dat16\" name=\"Option 1\" default=\"0x0101\" access=\"rw\" required=\"m\" showas=\"hex\">\r\n          <description>Choose correctly according to your device Dimmer OR fil pilote.\r\nDimmer > Off=0100 - On=0101\r\nFil pilote > Off=0001 - On=0002\r\nContactor > On/off=0003 - HP/HC=0004</description>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" type=\"bool\" name=\"Option 2\" required=\"m\" access=\"rw\" default=\"0\">\r\n          <description>Option 1</description>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" type=\"bool\" name=\"Option 3\" required=\"m\" access=\"rw\" default=\"0\">\r\n          <description>Option 2</description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc40\" name=\"Legrand - Specific clusters 2\" mfcode=\"1021\">\r\n      <description>Legrand Specific clusters, Used by cable outlet.</description>\r\n      <server>\r\n        <command id=\"00\" dir=\"recv\" name=\"Unknow\" required=\"m\">\r\n          <description>Set fil pilote mode</description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Comfort\" value=\"0x00\"></value>\r\n              <value name=\"Comfort -1\" value=\"0x01\"></value>\r\n              <value name=\"Comfort -2\" value=\"0x02\"></value>\r\n              <value name=\"Eco\" value=\"0x03\"></value>\r\n              <value name=\"Hors-Gel\" value=\"0x04\"></value>\r\n              <value name=\"Off\" value=\"0x05\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n        <attribute id=\"0x0000\" type=\"enum8\" name=\"Mode\" default=\"0x00\" access=\"r\" required=\"m\">\r\n          <description>Heating mode</description>\r\n          <value name=\"Comfort\" value=\"0x00\"></value>\r\n          <value name=\"Comfort -1\" value=\"0x01\"></value>\r\n          <value name=\"Comfort -2\" value=\"0x02\"></value>\r\n          <value name=\"Eco\" value=\"0x03\"></value>\r\n          <value name=\"Hors-Gel\" value=\"0x04\"></value>\r\n          <value name=\"Off\" value=\"0x05\"></value>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- ubisys -->\r\n    <cluster id=\"0xfc00\" name=\"Device Setup\" mfcode=\"0x10f2\">\r\n      <description>Attributes and commands.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Input Configurations\" type=\"array\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Input Actions\" type=\"array\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc01\" name=\"Dimmer Setup\" mfcode=\"0x10f2\">\r\n      <description>Attributes and commands.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Capabilities\" type=\"bmp8\" default=\"00000000\" access=\"r\" required=\"m\">\r\n          <value name=\"Forward Phase Control\" value=\"0\"></value>\r\n          <value name=\"Reverse Phase Control\" value=\"1\"></value>\r\n          <value name=\"Reactance Discriminator\" value=\"5\"></value>\r\n          <value name=\"Configurable Curve\" value=\"6\"></value>\r\n          <value name=\"Overload detection\" value=\"7\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Status\" type=\"bmp8\" default=\"00000000\" access=\"r\" required=\"m\">\r\n          <value name=\"Forward Phase Control\" value=\"0\"></value>\r\n          <value name=\"Reverse Phase Control\" value=\"1\"></value>\r\n          <value name=\"Operational\" value=\"2\"></value>\r\n          <value name=\"Overload\" value=\"3\"></value>\r\n          <value name=\"Capacitive Load\" value=\"6\"></value>\r\n          <value name=\"Inductive Load\" value=\"7\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Mode\" type=\"bmp8\" default=\"00000000\" access=\"r\" required=\"m\">\r\n          <value name=\"Automatic Phase Control\" value=\"0\"></value>\r\n          <value name=\"Forward Phase Control\" value=\"1\"></value>\r\n          <value name=\"Reverse Phase Control\" value=\"2\"></value>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- Samjin -->\r\n    <cluster id=\"0xfc02\" name=\"Samjin specific\" mfcode=\"0x104e\">\r\n      <description>Samjin manufacturer-specifc cluster for SmartThings multi sensor.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Motion Threshold Multiplier\" type=\"u8\" mfcode=\"0x104e\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Motion Threshold\" type=\"u16\" mfcode=\"0x104e\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Active\" type=\"bmp8\" mfcode=\"0x104e\" default=\"0\" access=\"r\" required=\"m\">\r\n          <value name=\"Active\" value=\"0\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0012\" name=\"Acceleration X\" type=\"s16\" mfcode=\"0x104e\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Acceleration Y\" type=\"s16\" mfcode=\"0x104e\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0014\" name=\"Acceleration Z\" type=\"s16\" mfcode=\"0x104e\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc02\" name=\"Samjin\" mfcode=\"0x110a\">\r\n      <description>Samjin manufacturer-specifc cluster for SmartThings multi sensor.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Motion Threshold Multiplier\" type=\"u8\" mfcode=\"0x110a\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Motion Threshold\" type=\"u16\" mfcode=\"0x110a\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Active\" type=\"bmp8\" mfcode=\"0x110a\" default=\"0\" access=\"r\" required=\"m\">\r\n          <value name=\"Active\" value=\"0\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0012\" name=\"Acceleration X\" type=\"s16\" mfcode=\"0x110a\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Acceleration Y\" type=\"s16\" mfcode=\"0x110a\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0014\" name=\"Acceleration Z\" type=\"s16\" mfcode=\"0x110a\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc02\" name=\"Samjin\" mfcode=\"0x1241\">\r\n      <description>Samjin manufacturer-specifc cluster for SmartThings multi sensor.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Motion Threshold Multiplier\" type=\"u8\" mfcode=\"0x1241\" default=\"0\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Active\" type=\"bmp8\" mfcode=\"0x1241\" default=\"0\" access=\"r\" required=\"m\">\r\n          <value name=\"Active\" value=\"0\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0012\" name=\"Acceleration X\" type=\"s16\" mfcode=\"0x1241\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Acceleration Y\" type=\"s16\" mfcode=\"0x1241\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0014\" name=\"Acceleration Z\" type=\"s16\" mfcode=\"0x1241\" default=\"0\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- SENGLED -->\r\n    <!-- Inspired from https://github.com/YuhangZho/EmberZNet5.3.0-GA/blob/ce8eb024f2ea536832a0d849c3808c6f21131155/em35x/tool/appbuilder/sengled_cluster.xml -->\r\n    <cluster id=\"0xfc01\" name=\"Sengled control specific\" mfcode=\"0x1160\">\r\n\t\t<description>Sengled specific cluster for control</description>\r\n\t\t\t<server>\r\n\t\t\t\t<attribute id=\"0x0000\" name=\"Illumination threshold\" type=\"u8\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x01\" range=\"0,1\"> </attribute>\r\n\t\t\t\t<attribute id=\"0x0001\" name=\"Automatic lights enable\" type=\"bool\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x01\"> </attribute>\r\n\t\t\t\t<attribute id=\"0x0002\" name=\"Save enable\" type=\"bool\" mfcode=\"0x1160\" access=\"r\" required=\"m\" default=\"0x01\"> </attribute>\r\n\t\t\t\t<attribute id=\"0x0003\" name=\"comm Occupancy\" type=\"u8\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x0\" range=\"0,1\"> </attribute>\r\n\t\t\t    <attribute id=\"0x0004\" name=\"comm PIR occupied to unoccupied delay\" type=\"u16\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x005a\" range=\"0,14400\"> </attribute>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t</client>\r\n\t   </cluster>\r\n     <cluster id=\"0xfc02\" name=\"Sengled Mobile Control specific\" mfcode=\"0x1160\">\r\n\t\t\t<description>Sengled specific cluster for mobile control</description>\r\n\t\t\t<server>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t<command id=\"00\" dir=\"recv\" name=\"MobileControl\" required=\"m\" mfcode=\"0x1160\">\r\n\t\t\t\t<description>Command description for zcl Mobile Control.</description>\r\n\t\t\t\t<payload>\r\n\t\t\t\t\t<attribute id=\"0x0000\" type=\"u16\" name=\"control_type\"> </attribute>\r\n\t\t\t\t        <attribute id=\"0x0001\" type=\"u16\" name=\"control_data\"> </attribute>\r\n\t\t\t\t        <attribute id=\"0x0002\" type=\"u16\" name=\"transition_time\"> </attribute>\r\n\t\t\t\t</payload>\r\n\t\t\t</command>\r\n\t\t\t</client>\r\n\t  </cluster>\r\n\t  <cluster id=\"0xfc03\" name=\"Sengled RGB calibration specific\" mfcode=\"0x1160\">\r\n\t\t\t<description>Sengled specific cluster for RGB calibration</description>\r\n\t\t\t<server>\r\n\t\t\t\t<attribute id=\"0x0000\" name=\"Temp adc data\" type=\"u16\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x01ff\" range=\"0,65535\" > </attribute>\r\n\t\t\t\t<attribute id=\"0x0001\" name=\"Red cali coeff\" type=\"u32\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x2710\" range=\"0,4294967295\" > </attribute>\r\n\t\t\t\t<attribute id=\"0x0002\" name=\"Green cali coeff\" type=\"u32\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x2710\" range=\"0,4294967295\" > </attribute>\r\n\t\t\t\t<attribute id=\"0x0003\" name=\"Blue cali coeff\" type=\"u32\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x2710\" range=\"0,4294967295\" > </attribute>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t<command id=\"00\" dir=\"recv\" name=\"rgb_calibration\" required=\"m\" mfcode=\"0x1160\">\r\n\t\t\t\t<description>Sengled TEST control</description>\r\n\t\t\t\t<payload>\r\n\t\t\t\t\t<attribute id=\"0x0000\" type=\"u8\" name=\"cali_cmd\"> </attribute>\r\n\t\t\t\t        <attribute id=\"0x0001\" type=\"u16\" name=\"cali_data\"> </attribute>\r\n\t\t\t\t</payload>\r\n\t\t\t</command>\r\n\t\t\t</client>\r\n\t  </cluster>\r\n\t\t<cluster id=\"0xfc04\" name=\"Sengled light auto reset specific\" mfcode=\"0x1160\">\r\n\t\t\t<description>Auto reset for Shangrui light</description>\r\n\t\t\t<server>\r\n\t\t\t\t<attribute id=\"0x0000\" name=\"Auto reset\" type=\"u8\" mfcode=\"0x1160\" access=\"rw\" required=\"o\" default=\"0x00\"> </attribute>\r\n\t\t\t</server>\r\n\t\t\t<client>\r\n\t\t\t</client>\r\n\t  </cluster>\r\n    \r\n    <!-- OSRAM -->\r\n    <cluster id=\"0xfc0f\" name=\"OSRAM specific\" mfcode=\"0xbbaa\">\r\n      <description>OSRAM manufacturer-specific cluster to set power-on defaults.</description>\r\n      <server>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Store Power-On Defaults\" required=\"o\"></command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- LEDVANCE -->\r\n    <cluster id=\"0xfc01\" name=\"LEDVANCE specific\" mfcode=\"0x1189\">\r\n      <description>LEDVANCE manufacturer-specific cluster to set power-on defaults.</description>\r\n      <server>\r\n        <command id=\"0x01\" dir=\"recv\" name=\"Store Power-On Defaults\" required=\"o\"></command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- E-Wand -->\r\n    <cluster id=\"0xfc10\" name=\"E-Wand specific\" mfcode=\"0x1263\">\r\n      <description>E-Wand manufacturer specific window covering configuration.</description>\r\n      <server>\r\n        <command id=\"0x23\" dir=\"recv\" name=\"Set Direction\" required=\"o\">\r\n          <description></description>\r\n          <payload>\r\n            <attribute id=\"0x0000\" type=\"enum8\" name=\"Mode\" required=\"m\" default=\"0x00\">\r\n              <value name=\"Standard\" value=\"0x00\"></value>\r\n              <value name=\"Reversed\" value=\"0x01\"></value>\r\n              <value name=\"Toggle\" value=\"0x02\"></value>\r\n            </attribute>\r\n          </payload>\r\n        </command>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- IKEA -->\r\n    <cluster id=\"0xfc57\" name=\"IKEA specific\" mfcode=\"0x117c\">\r\n      <description>Unknown cluster, found on the IKEA Vindstyrka Air Quality Sensor.</description>\r\n      <server>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc7c\" name=\"IKEA specific\" mfcode=\"0x117c\">\r\n      <description>IKEA control outlet cluster.</description>\r\n      <server>\r\n        <attribute id=\"0x0010\" name=\"Unknown 1\" type=\"u8\" access=\"rw\" required=\"m\" showas=\"hex\" mfcode=\"0x117c\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" required=\"m\" access=\"rw\" showas=\"hex\" mfcode=\"0x117c\">\r\n          <description></description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc7d\" name=\"Air Purifier Control\" mfcode=\"0x117c\">\r\n      <description>Cluster to control the IKEA Starkvind Air Purifier.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Filter Run Time\" type=\"u32\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Replace Filter\" type=\"u8\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Filter Life Time\" type=\"u32\" access=\"rw\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Disable LEDs\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"Air Quality\" type=\"u16\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0005\" name=\"Lock Controls\" type=\"bool\" access=\"rw\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0006\" name=\"Target Mode\" type=\"u8\" access=\"rw\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0007\" name=\"Current Mode\" type=\"u8\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        <attribute id=\"0x0008\" name=\"Device Run Time\" type=\"u32\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n      </server>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfc7e\" name=\"tVOC Measurement\" mfcode=\"0x117c\">\r\n      <description>Cluster to report tVOC on the IKEA Vindstyrka Air Quality Sensor.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"tVOC Information\">\r\n          <attribute id=\"0x0000\" name=\"Measured Value\" type=\"float\" access=\"r\" default=\"0\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n          <attribute id=\"0x0001\" name=\"Min Measured Value\" type=\"float\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Max Measured Value\" type=\"float\" access=\"r\" required=\"m\" mfcode=\"0x117c\"></attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\t  \r\n    <!-- SONOFF -->\r\n    <cluster id=\"0xfc11\" name=\"Sonoff specific\" mfcode=\"0x1286\">\r\n      <description>Cluster for light sensor</description>\r\n      <server>\r\n        <attribute id=\"0x2001\" name=\"Brightness\" type=\"u8\" access=\"r\" required=\"m\" mfcode=\"0x1286\">\r\n          <description></description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\t  \r\n    <!-- Leviton -->\r\n    <cluster id=\"0x8007\" name=\"Leviton Specific Load Cluster\" mfcode=\"0x109b\">\r\n      <description>Additional features implemented in Leviton’s DG6HD.</description>\r\n      <server>\r\n        <attribute id=\"0x0001\" type=\"u8\" name=\"Min Dim Level\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0x00\">\r\n          <description>Minimum Level represents the minimum level the dimmer can be set to. This must be lower than Maximum Level.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" type=\"u8\" name=\"Max Dim Level\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0xFF\">\r\n          <description>Maximum Level represents the maximum level the dimmer can be set to. This must be greater than Minimum Level.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0003\" type=\"u8\" name=\"Locator LED\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0x00\">\r\n          <description>Represents how the Locator LED functions. This can be set to ALWAYS ON (0x00), ALWAYS OFF (0X01), or a timed delay (0x02 to 0xFF). The Timed delay is always seconds -1. When using timed delay, the led will come on when a button is pressed.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0004\" type=\"u8\" name=\"Dimming LED\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0x00\">\r\n          <description>Represents how the Dimming LED functions. This can be set to ALWAYS ON (0x00), ALWAYS OFF (0X01), or a timed delay (0x02 to 0xFF). The Timed delay is always seconds -1. When using timed delay, the led will come on when a button is pressed.</description>\r\n        </attribute>\r\n        <attribute id=\"0x0007\" type=\"u8\" name=\"Initial On Level\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0x00\">\r\n          <description>Initial On Level represents the desired level to be applied to a dimmer when an “On” button is pressed.\r\n\t\t  0x00 : Go to the last level set.\r\n\t\t  0x01-0xFF : Go to a specific level</description>\r\n        </attribute>\r\n        <attribute id=\"0x0008\" type=\"bool\" name=\"Power Restore\" default=\"1\" access=\"rw\" required=\"o\">\r\n\t  <description>Power Restore represents the option to turn the switch/dimmer back to its previous level when powered up, or remain off.</description>\r\n            <value name=\"Leave Load Off\" value=\"0\"></value>\r\n            <value name=\"Go to the last level set\" value=\"1\"></value>\r\n        </attribute>\r\n\t<attribute id=\"0x0009\" type=\"u8\" name=\"Press and Hold Time\" required=\"o\" access=\"rw\" range=\"0x00,0xFF\" default=\"0x32\">\r\n          <description>Represents the ramp time when pressing and holding the dim/brighten button on a dimmer. This value represents the amount of time needed to go from 0% to 100%. This time value is in 0.1s increments</description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- LUMI -->\r\n    <cluster id=\"0xfcc0\" name=\"Lumi specific\" mfcode=\"0x115f\">\r\n      <description>Lumi specific attributes.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Unknown\">\r\n          <attribute id=\"0x0001\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Power Outages\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Unknown\" type=\"enum8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0006\" name=\"Unknown\" type=\"ostring\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0007\" name=\"Unknown\" type=\"ostring\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0008\" name=\"Unknown (write only)\" type=\"ostring\" mfcode=\"0x115f\" access=\"w\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0009\" name=\"Device operation mode\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x000A\" name=\"Switch mode\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Switch mode: 1 - event based switching, 2 - zigbee group switching, 3 - Xiaomi specific switching</description>\r\n          </attribute>\r\n          <attribute id=\"0x000C\" name=\"Unknown\" type=\"ostring\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x000D\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00E8\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00E9\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EA\" name=\"Unknown\" type=\"ostring\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EB\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00ED\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EE\" name=\"Firmware\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F0\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F1\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F3\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F4\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F5\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F6\" name=\"Reporting Interval\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F7\" name=\"Unknown\" type=\"ostring\" mfcode=\"0x115f\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F8\" name=\"Unknown\" type=\"u64\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F9\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FA\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FB\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FC\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FE\" name=\"Serial Number\" type=\"cstring\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FF\" name=\"Unknown (write only)\" type=\"ostring\" mfcode=\"0x115f\" access=\"w\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0100\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0102\" name=\"Motion cool off time\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Time in seconds when RTCGQ13LM sets motion to false if no further motion has been detected</description>\r\n          </attribute>\r\n          <attribute id=\"0x010C\" name=\"Motion sensitivity\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Motion sensitivity: 1 - low, 2 - medium, 3 - high</description>\r\n          </attribute>\r\n          <attribute id=\"0x0112\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0114\" name=\"TVOC unit config\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>0 - µg/m³ + °C, 1 - ppb + °C, 16 - µg/m³ + °F, 17 - ppb + °F</description>\r\n          </attribute>\r\n          <attribute id=\"0x0125\" name=\"Multiclick mode\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0129\" name=\"Air Quality\" type=\"u8\" mfcode=\"0x115f\" access = \"r\" required=\"o\">\r\n            <description>Air Quality: 1 - excellent, 2 - good, 3 - moderate, 4 - poor, 5 unhealthy</description>\r\n          </attribute>\r\n          <attribute id=\"0x0135\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0136\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0137\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0138\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0152\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0200\" name=\"Child lock off\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Child lock off: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x0201\" name=\"Restore Power on Outage\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0202\" name=\"Auto-off after 20m below Threshold\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0203\" name=\"Device LED off (9pm-9am)\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0204\" name=\"Min. Power Change for Report (W)\" type=\"float\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0205\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Attribute 0x0205 has range between 1 and 50 only</description>\r\n          </attribute>\r\n          <attribute id=\"0x0206\" name=\"Power Threshold for Auto-off\" type=\"float\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0207\" name=\"Consumer Connected\" type=\"bool\" mfcode=\"0x115f\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020B\" name=\"Max. Load Exceeded at (W)\" type=\"float\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020C\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020D\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020E\" name=\"Unknown\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x023B\" name=\"Unknown\" type=\"float\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x023E\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0270\" description=\"Smart Radiator Thermostat E1\">\r\n            <attribute id=\"0x0270\" name=\"Calibrate\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> \r\n                <description>Write 1 to calibrate</description>\r\n            </attribute>\r\n            <attribute id=\"0x0271\" name=\"Mode\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> \r\n                <description>Heating state: 0 - off, 1 - on</description>\r\n            </attribute>\r\n            <attribute id=\"0x0272\" name=\"Preset\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\" default=\"0\"> \r\n                <description>Preset: 0 - manual, 1 - auto, 2 - away</description>\r\n            </attribute>\r\n            <attribute id=\"0x0273\" name=\"Window detection\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n                <description>Window detection: 0 - off, 1 - on</description>\r\n            </attribute>\r\n            <attribute id=\"0x0274\" name=\"Valve fault detection\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n                <description>Valve fault detection: 0 - off, 1 - on</description>\r\n            </attribute>\r\n            <attribute id=\"0x0275\" name=\"Valve fault alarm\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n                <description>Valve fault alarm: 0 - false, 1 - true</description>\r\n            </attribute>\r\n            <attribute id=\"0x0277\" name=\"Child lock on\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n                <description>Child lock on: 0 - false, 1 - true</description>\r\n            </attribute>\r\n            <attribute id=\"0x0279\" name=\"Away preset temperature\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> </attribute>\r\n            <attribute id=\"0x027a\" name=\"Window open\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n                <description>Window open: 0 - false, 1 - true</description>\r\n            </attribute>\r\n            <attribute id=\"0x027b\" name=\"Calibrated\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n                <description>Calibrated: 0 - false, 1 - true</description>\r\n            </attribute>\r\n            <attribute id=\"0x027e\" name=\"External sensor\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n                <description>Temperature sensor: 0 - internal, 1 - external</description>\r\n            </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0400\" description=\"Aqara Roller Shade Driver E1\">\r\n          <attribute id=\"0x0400\" name=\"Reverse Direction\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"o\">\r\n            <description>Reverse the direction of up/open and down/close.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0402\" name=\"Positions Stored\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"o\">\r\n            <description>Position clearing: write false to clear the stored up/open and down/close positions.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0407\" name=\"Store Position\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"o\">\r\n            <description>Position setting: write 1 to store the up/open position, 2 to store the down/close position.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0408\" name=\"Speed\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"o\">\r\n            <description>Motor speed: 2: high, 1: medium, 0: low.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0409\" name=\"Charging\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"o\">\r\n            <description>Battery charging state: 1: charging, 2: not charging.</description>\r\n          </attribute>\r\n          <attribute id=\"0x040a\" name=\"Battery\" type=\"u8\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0500\" description=\"Aqara LED Strip T1\">\r\n          <attribute id=\"0x0515\" name=\"Min Dim Level (%)\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0516\" name=\"Max Dim Level (%)\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0517\" name=\"PowerOn OnOff\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>OnOff state on power on: 0: on, 1: previous, 2: off.</description>\r\n          </attribute>\r\n          <attribute id=\"0x051B\" name=\"Segments\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Number of 20cm segments.</description>\r\n          </attribute>\r\n          <attribute id=\"0x051C\" name=\"Music Sync\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Music Sync: 0: off, 1: on.</description>\r\n          </attribute>\r\n          <attribute id=\"0x051D\" name=\"Music Sync Effect\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Music Sync Effecy: 0: random, 1: breathing, 2: rainbow, 3: chasing.</description>\r\n          </attribute>\r\n          <attribute id=\"0x051E\" name=\"Music Sync Sensitivity\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Music Sync Sensitivity: 0: low, 2: high.</description>\r\n          </attribute>\r\n        </attribute-set>\r\n        <attribute-set id=\"0x0700\" description=\"Unknown\">\r\n          <attribute id=\"0x0700\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0701\" name=\"Unknown\" type=\"s8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0702\" name=\"Unknown\" type=\"s8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0703\" name=\"Unknown\" type=\"s8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0704\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0705\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0740\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0780\" name=\"Unknown\" type=\"bool\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0781\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0782\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0783\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x07C0\" name=\"Unknown\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0xF000\" name=\"Report Consumer Connected\" type=\"u8\" mfcode=\"0x115f\" access=\"rw\" required=\"m\">\r\n            <description>Report Consumer Connected: 1 - false, 0 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0xF001\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> </attribute>\r\n          <attribute id=\"0xF002\" name=\"Unknown\" type=\"u32\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> </attribute>\r\n          <attribute id=\"0xFFF2\" name=\"External temperature\" type=\"ostring\" mfcode=\"0x115f\" access=\"r\" required=\"m\">\r\n            <description>Could used to write external temperature values to TRV</description>\r\n          </attribute>\r\n          <attribute id=\"0xFFFD\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x115f\" access=\"rw\" required=\"m\"> </attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    <!-- AQARA -->\r\n    <cluster id=\"0xfcc0\" name=\"Aqara specific\" mfcode=\"0x1234\">\r\n      <description>Aqara specific attributes.</description>\r\n      <server>\r\n        <attribute-set id=\"0x0000\" description=\"Unknown\">\r\n          <attribute id=\"0x0001\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0002\" name=\"Power Outages\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0003\" name=\"Unknown\" type=\"enum8\" access=\"r\" required=\"m\">\r\n            <value name=\"0\" value=\"0x00\"></value>\r\n            <value name=\"1\" value=\"0x01\"></value>\r\n            <value name=\"2\" value=\"0x02\"></value>\r\n            <value name=\"3\" value=\"0x03\"></value>\r\n            <value name=\"4\" value=\"0x04\"></value>\r\n          </attribute>\r\n          <attribute id=\"0x0006\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0007\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0008\" name=\"Unknown (write only)\" type=\"ostring\" access=\"w\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0009\" name=\"Device operation mode\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x000A\" name=\"Switch mode\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Switch mode: 1 - event based switching, 2 - zigbee group switching, 3 - Xiaomi specific switching</description>\r\n          </attribute>\r\n          <attribute id=\"0x000C\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x000D\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00E4\" name=\"Unknown\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00E8\" name=\"Device Running\" type=\"bool\" access=\"rw\" required=\"m\">\r\n            <description>Set to false to reboot the device.</description>\r\n          </attribute>\r\n          <attribute id=\"0x00E9\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EA\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EB\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00ED\" name=\"Unknown\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00EE\" name=\"Unknown\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F0\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F1\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F3\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F4\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F5\" name=\"Unknown\" type=\"u32\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F6\" name=\"Reporting Interval\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F7\" name=\"Unknown\" type=\"ostring\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F8\" name=\"Unknown\" type=\"u64\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00F9\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FA\" name=\"Unknown\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FB\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FC\" name=\"Unknown\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FE\" name=\"Serial Number\" type=\"cstring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x00FF\" name=\"Unknown (write only)\" type=\"ostring\" access=\"w\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0100\" name=\"Unknown\" type=\"u8\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0102\" name=\"Motion cool off time\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Time in seconds when RTCGQ13LM sets motion to false if no further motion has been detected</description>\r\n          </attribute>\r\n          <attribute id=\"0x010C\" name=\"Motion Sensitivity\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Motion sensitivity: 1 - low, 2 - medium, 3 - high</description>\r\n          </attribute>\r\n          <attribute id=\"0x0112\" name=\"Unknown\" type=\"u32\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0114\" name=\"TVOC unit config\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>0 - µg/m³ + °C, 1 - ppb + °C, 16 - µg/m³ + °F, 17 - ppb + °F</description>\r\n          </attribute>\r\n          <attribute id=\"0x0125\" name=\"Multiclick mode\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0133\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0134\" name=\"Unknown\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0135\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0136\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0137\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0138\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0142\" name=\"Presence\" type=\"u8\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0143\" name=\"Presence Event\" type=\"u8\" access=\"r\" required=\"m\">\r\n            <description>Presence Event: 0 - enter, 1 - leave, 2 - enter left, 3 - right leave, 4 - enter right', 5 - left leave, 6 - approaching, 7 - absenting</description>\r\n          </attribute>\r\n          <attribute id=\"0x0144\" name=\"Device Mode\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Device mode: 0 - undirected, 1 - leftright</description>\r\n          </attribute>\r\n          <attribute id=\"0x0145\" name=\"Unknown\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0146\" name=\"Trigger Distance\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Trigger distance: 0 - far, 1 - medium, 2 - near</description>\r\n          </attribute>\r\n          <attribute id=\"0x0147\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0148\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0149\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0150\" name=\"Set Detection Region\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0151\" name=\"Report Detection Region\" type=\"ostring\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0152\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0153\" name=\"Set Exits and Entrances\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0154\" name=\"Set Interference Region\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0155\" name=\"Report Grid\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0156\" name=\"Set Edge\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0157\" name=\"Reset Presence\" type=\"u8\" access=\"w\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0159\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x015A\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x015B\" name=\"Detection Range\" type=\"u32\" access=\"rw\" required=\"m\">\r\n            <description>Detection Range in cm, from 0 to 600, in increments of 30.</description>\r\n          </attribute>\r\n          <attribute id=\"0x015C\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x015D\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x015E\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x015F\" name=\"Position\" type=\"u32\" access=\"r\" required=\"m\">\r\n            <description>Distance to detected person, in cm.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0160\" name=\"Occupancy\" type=\"u8\" access=\"r\" required=\"m\">\r\n            <description>4 = Occupancy; 2 = No occupancy.</description>\r\n          </attribute>\r\n          <attribute id=\"0x0200\" name=\"Child lock off\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Child lock off: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x0201\" name=\"Restore Power on Outage\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0202\" name=\"Auto-off after 20m below Threshold\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0203\" name=\"Device LED off (9pm-9am)\" type=\"bool\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0204\" name=\"Min. Power Change for Report (W)\" type=\"float\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0205\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\">\r\n            <description>Attribute 0x0205 has range between 1 and 50 only</description>\r\n          </attribute>\r\n          <attribute id=\"0x0206\" name=\"Power Threshold for Auto-off\" type=\"float\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0207\" name=\"Consumer Connected\" type=\"bool\" access=\"r\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020B\" name=\"Max. Load Exceeded at (W)\" type=\"float\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020C\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020D\" name=\"Unknown\" type=\"u8\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x020E\" name=\"Unknown\" type=\"u16\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x023B\" name=\"Unknown\" type=\"float\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x023E\" name=\"Unknown\" type=\"u32\" access=\"rw\" required=\"m\"></attribute>\r\n          <attribute id=\"0x0270\" name=\"Calibrate\" type=\"u8\" access=\"rw\" required=\"m\"> \r\n              <description>Write 1 to calibrate</description>\r\n          </attribute>\r\n          <attribute id=\"0x0271\" name=\"Mode\" type=\"u8\" access=\"rw\" required=\"m\"> \r\n              <description>Heating state: 0 - off, 1 - on</description>\r\n          </attribute>\r\n          <attribute id=\"0x0272\" name=\"Preset\" type=\"u8\" access=\"rw\" required=\"m\" default=\"0\"> \r\n              <description>Preset: 0 - manual, 1 - auto, 2 - away</description>\r\n          </attribute>\r\n          <attribute id=\"0x0273\" name=\"Window detection\" type=\"u8\" access=\"rw\" required=\"m\">\r\n              <description>Window detection: 0 - off, 1 - on</description>\r\n          </attribute>\r\n          <attribute id=\"0x0274\" name=\"Valve fault detection\" type=\"u8\" access=\"rw\" required=\"m\">\r\n              <description>Valve fault detection: 0 - off, 1 - on</description>\r\n          </attribute>\r\n          <attribute id=\"0x0275\" name=\"Valve fault alarm\" type=\"u8\" access=\"r\" required=\"m\">\r\n              <description>Valve fault alarm: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x0277\" name=\"Child lock on\" type=\"u8\" access=\"rw\" required=\"m\">\r\n              <description>Child lock on: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x0279\" name=\"Away preset temperature\" type=\"u32\" access=\"rw\" required=\"m\"> </attribute>\r\n          <attribute id=\"0x027a\" name=\"Window open\" type=\"u8\" access=\"r\" required=\"m\">\r\n              <description>Window open: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x027b\" name=\"Calibrated\" type=\"u8\" access=\"r\" required=\"m\">\r\n              <description>Calibrated: 0 - false, 1 - true</description>\r\n          </attribute>\r\n          <attribute id=\"0x027e\" name=\"External sensor\" type=\"u8\" access=\"r\" required=\"m\">\r\n              <description>Temperature sensor: 0 - internal, 1 - external</description>\r\n          </attribute>\r\n          <attribute id=\"0x0402\" name=\"Positions Stored\" type=\"bool\" access=\"rw\" required=\"o\">\r\n            <description>Position clearing: write false to clear the stored up/open and down/close positions.</description>\r\n          </attribute>\r\n          <attribute id=\"0x040a\" name=\"Battery\" type=\"u8\" access=\"r\" required=\"m\"> </attribute>\r\n          <attribute id=\"0xFFF2\" name=\"External temperature\" type=\"ostring\" access=\"r\" required=\"m\">\r\n            <description>Could used to write external temperature values to TRV</description>\r\n          </attribute>\r\n          <attribute id=\"0xFFFD\" name=\"Cluster Revision\" type=\"u16\" access=\"rw\" required=\"m\"> </attribute>\r\n        </attribute-set>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    <!-- SINOPE -->\r\n    <cluster id=\"0xff01\" name=\"Sinope specific\" mfcode=\"0x119c\">\r\n      <description>Sinope specific cluster attributes</description>\r\n      <server>\r\n\t<attribute id=\"0x0002\" name=\"Keypad lock\" type=\"u8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t  <value name=\"Unlocked\" value=\"0x00\"></value>\r\n          <value name=\"Locked\" value=\"0x01\"></value>\r\n\t</attribute>\r\n\t<attribute id=\"0x0010\" name=\"Outdoor Temp on Display\" type=\"s16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> <description>Celcius * 100</description> </attribute>\r\n\t<attribute id=\"0x0011\" name=\"Outdoor Temp on Display Timeout\" type=\"u16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t\t<description>Delay in seconds before reverting to setpoint display if no more outdoor temp is received</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0012\" name=\"Config 2nd Display \" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t\t\t<value name=\"Auto\" value=\"0x00\"></value>\r\n\t\t\t<value name=\"Setpoint\" value=\"0x01\"></value>\r\n\t\t        <value name=\"Outside Temp\" value=\"0x02\"></value>\r\n\t</attribute>\r\n\t<attribute id=\"0x0020\" name=\"Current Time on Display\" type=\"u32\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t\t <description>Seconds since year 2000</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0050\" name=\"On Led Color\" type=\"u24\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t  <value name=\"Lim\" value=\"0x0affdc\"></value>\r\n          <value name=\"Amber\" value=\"0x000a4b\"></value>\r\n\t  <value name=\"Fushia\" value=\"0x64ffff\"></value>\r\n\t  <value name=\"Perle\" value=\"0x000a4b\"></value>\r\n\t  <value name=\"Blue\" value=\"0xffff00\"></value>\r\n\t</attribute>\r\n\t<attribute id=\"0x0051\" name=\"Off Led Color\" type=\"u24\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t  <value name=\"Lim\" value=\"0x0affdc\"></value>\r\n          <value name=\"Amber\" value=\"0x000a4b\"></value>\r\n\t  <value name=\"Fushia\" value=\"0x64ffff\"></value>\r\n\t  <value name=\"Perle\" value=\"0x000a4b\"></value>\r\n\t  <value name=\"Blue\" value=\"0xffff00\"></value>\r\n\t</attribute>\r\n\t<attribute id=\"0x0052\" name=\"On Led Intensity\" type=\"u8\" mfcode=\"0x119c\" range=\"0,100\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0053\" name=\"Off Led Intensity\" type=\"u8\" mfcode=\"0x119c\" range=\"0,100\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0054\" name=\"Unknown\" type=\"u8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0055\" name=\"Min Intensity\" type=\"u16\" mfcode=\"0x119c\" range=\"0,3000\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0060\" name=\"Connected Load\" type=\"u16\" mfcode=\"0x119c\" access=\"r\" required=\"m\">\r\n\t\t<description>Watt/hr</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0070\" name=\"Current Load\" type=\"bmp8\" mfcode=\"0x119c\" access=\"r\" required=\"m\"> \r\n\t\t <description>Watt/hr</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0071\" name=\"Eco Mode\" type=\"s8\" mfcode=\"0x119c\" range=\"-100,100\" default=\"-128\" access=\"rw\" required=\"m\"> \r\n\t\t <description>Eco mode in percent</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0072\" name=\"Eco Mode 1\" type=\"u8\" mfcode=\"0x119c\" range=\"0,99\" default=\"255\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0073\" name=\"Eco Mode 2\" type=\"u8\" mfcode=\"0x119c\" range=\"0,100\" default=\"255\" access=\"rw\" required=\"m\"> </attribute>\r\n        <attribute id=\"0x0076\" name=\"drConfigWaterTempMin\" type=\"u8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> <description>45 or 0</description></attribute>\r\n        <attribute id=\"0x0077\" name=\"drConfigWaterTempTime\" type=\"u8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x0078\" name=\"drWTTimeOn\" type=\"u16\" mfcode=\"0x119c\" access=\"r\" required=\"m\"> </attribute>\r\n\t<attribute id=\"0x00A0\" name=\"Timer\" type=\"u16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> <description>Number of seconds</description> </attribute>\r\n        <attribute id=\"0x0105\" name=\"Floor Control Mode\" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\">\r\n          <value name=\"Ambient\" value=\"0x01\"></value>\r\n          <value name=\"Floor\" value=\"0x02\"></value>\r\n        </attribute>\r\n\t<attribute id=\"0x0106\" name=\"Aux Output Mode\" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\">\r\n\t\t\t<value name=\"Off\" value=\"0x00\"></value>\r\n\t\t\t<value name=\"Expansion module\" value=\"0x01\"></value>\r\n\t</attribute>\r\n\t<attribute id=\"0x0108\" name=\"Ambient Max Heat Setpoint Limit\" type=\"s16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"> \r\n\t\t\t<description>temp: celcius*100, valid only if floor control mode is selected</description>\r\n\t</attribute>\r\n        <attribute id=\"0x0109\" name=\"Floor Min Heat Setpoint Limit\" type=\"s16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x010A\" name=\"Floor Max Heat Setpoint Limit\" type=\"s16\" mfcode=\"0x119c\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x010B\" name=\"Temperature Sensor\" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\">\r\n          <value name=\"10k\" value=\"0x00\"></value>\r\n          <value name=\"12k\" value=\"0x01\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x010C\" name=\"Floor Limit Status\" type=\"enum8\" mfcode=\"0x119c\" access=\"r\" required=\"m\">\r\n          <value name=\"Off\" value=\"0x00\"></value>\r\n\t  <value name=\"floorLimitLowReached\" value=\"0x01\"></value>\r\n\t  <value name=\"floorLimitMaxReached\" value=\"0x02\"></value>\r\n\t  <value name=\"floorAirLimitMaxReached\" value=\"0x03\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0114\" name=\"Time Format on Display\" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\">\r\n          <value name=\"24h\" value=\"0x00\"></value>\r\n          <value name=\"12h\" value=\"0x01\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0115\" name=\"GFCi Status\" type=\"enum8\" mfcode=\"0x119c\" access=\"r\" required=\"m\">\r\n          <value name=\"Ok\" value=\"0x00\"></value>\r\n          <value name=\"Error\" value=\"0x01\"></value>\r\n        </attribute>\r\n\t<attribute id=\"0x0118\" name=\"Aux Connected Load\" type=\"u16\" mfcode=\"0x119c\" default=\"0xffff\" access=\"r\" required=\"m\">\r\n\t\t<description>watt/hr, 0xffff=off</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0119\" name=\"Connected Load\" type=\"u16\" mfcode=\"0x119c\" access=\"r\" required=\"m\">\r\n\t\t<description>Watt</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0128\" name=\"Pump protection\" type=\"enum8\" mfcode=\"0x119c\" access=\"rw\" required=\"m\">\r\n\t\t\t\t\t<value name=\"Off\" value=\"0xff\"></value>\r\n\t\t\t\t\t<value name=\"On\" value=\"0x01\"></value>\r\n\t</attribute>\t\r\n\t<attribute id=\"0x012D\" name=\"Report Local Temperature\" type=\"s16\" mfcode=\"0x119c\" access=\"r\" required=\"m\">\r\n\t\t<description>Celcius * 100</description>\r\n\t</attribute>\r\n\t<attribute id=\"0x0283\" name=\"ColdLoadPickupStatus\" type=\"u8\" mfcode=\"0x119c\" access=\"r\" required=\"m\"> </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- INNR -->\r\n    <cluster id=\"0xfc82\" name=\"innr specific\" mfcode=\"0x1166\">\r\n      <description>innr specific attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0006\" name=\"Unknown\" type=\"cstring\" mfcode=\"0x1166\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0011\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0012\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0014\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0015\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1166\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x1166\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n    <cluster id=\"0xfd01\" name=\"innr specific 2\" mfcode=\"0x1166\">\r\n      <description>innr specific attributes 2.</description>\r\n      <server>\r\n        <attribute id=\"0x0004\" name=\"Key Report Mask Read/Write\" mfcode=\"0x1166\" type=\"u8\" default=\"0\" access=\"rw\" required=\"m\">\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- IMMAX -->\r\n    <cluster id=\"0xfc82\" name=\"Immax specific\" mfcode=\"0x1037\">\r\n      <description>Immax specific attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0010\" name=\"Turned on since\" type=\"u32\" mfcode=\"0x1037\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0011\" name=\"Turned on (total)\" type=\"u32\" mfcode=\"0x1037\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0012\" name=\"Consumption since turned on\" type=\"u32\" mfcode=\"0x1037\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Unknown\" type=\"u32\" mfcode=\"0x1037\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x1037\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- BOSCH -->\r\n    <cluster id=\"0xfcac\" name=\"Bosch specific\" mfcode=\"0x1209\">\r\n      <description>Bosch specific attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Device setup time remaining\" type=\"u16\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Motion alert reset\" type=\"u16\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Device setup time\" type=\"u16\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Audio alert on motion\" type=\"bool\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x1209\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfca0\" name=\"Bosch specific\" mfcode=\"0x1209\">\r\n      <description>Bosch specific attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Device mode\" type=\"enum8\" mfcode=\"0x1209\" access=\"rw\" required=\"m\">\r\n          <value name=\"Disabled\" value=\"0x00\"></value>\r\n          <value name=\"Shutter\" value=\"0x01\"></value>\r\n          <value name=\"Light\" value=\"0x04\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Switch type\" type=\"enum8\" mfcode=\"0x1209\" access=\"rw\" required=\"m\">\r\n          <value name=\"Undefined\" value=\"0x00\"></value>\r\n          <value name=\"Momentary\" value=\"0x01\"></value>\r\n          <value name=\"Momentary (sides switched)\" value=\"0x02\"></value>\r\n          <value name=\"Rocker\" value=\"0x03\"></value>\r\n          <value name=\"Rocker (sides switched)\" value=\"0x04\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"Calibration opening time\" type=\"u32\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Calibration closing time\" type=\"u32\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0008\" name=\"Child lock\" type=\"bool\" mfcode=\"0x1209\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0013\" name=\"Motor state\" type=\"enum8\" mfcode=\"0x1209\" access=\"r\" required=\"m\">\r\n          <value name=\"Idle\" value=\"0x00\"></value>\r\n          <value name=\"Opening\" value=\"0x01\"></value>\r\n          <value name=\"Closing\" value=\"0x02\"></value>\r\n        </attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x1209\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfdee\" name=\"AIR Measurement Config\" mfcode=\"0x1155\">\r\n      <description>BOSCH Thermotechnik indoor air quality configuration</description>\r\n      <server>\r\n        <attribute id=\"0x4001\" name=\"Unknown\" type=\"enum8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0x4002\" name=\"Unknown\" type=\"lcstring\" access=\"r\" required=\"m\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0x4003\" name=\"Unknown\" type=\"ostring\" required=\"m\" access=\"r\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0x4004\" name=\"Unknown\" type=\"u8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0x4005\" name=\"Unknown\" type=\"u8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description></description>\r\n        </attribute>\r\n        <attribute id=\"0x4006\" name=\"Unknown\" type=\"u32\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description></description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfdef\" name=\"AIR Measurement\" mfcode=\"0x1155\">\r\n      <description>BOSCH Thermotechnik indoor air quality</description>\r\n      <server>\r\n        <attribute id=\"0x4001\" name=\"Air pressure\" type=\"u16\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Air pressure (mBar)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4002\" name=\"Temperature\" type=\"s16\" access=\"r\" required=\"m\">\r\n          <description>Temperature (°C)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4003\" name=\"Humidity\" type=\"u8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Relative humidity (%)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4004\" name=\"Air quality\" type=\"u16\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Air quality VOC (ppm) </description>\r\n        </attribute>\r\n        <attribute id=\"0x4005\" name=\"Brightness\" type=\"u16\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Ambient light brightness (lux)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4006\" name=\"Loudness\" type=\"u8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Noise level (dB)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4008\" name=\"timestamp\" type=\"u32\" required=\"m\" access=\"r\" default=\"0\">\r\n          <description>Relative timestamp since start(seconds)</description>\r\n        </attribute>\r\n        <attribute id=\"0x4009\" name=\"Trigger\" type=\"enum8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"by timer\" value=\"0x00\"></value>\r\n          <value name=\"by double tap\" value=\"0x01\"></value>\r\n          <description>Trigger of this measurement</description>\r\n        </attribute>\r\n        <attribute id=\"0x400B\" name=\"ModeOfOperation\" type=\"enum8\" required=\"m\" access=\"r\" default=\"0\">\r\n          <value name=\"normal, day mode\" value=\"0x00\"></value>\r\n          <value name=\"night, up side down\" value=\"0x01\"></value>\r\n          <description>Device orientation</description>\r\n        </attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- DEVELCO -->\r\n    <cluster id=\"0xfc03\" name=\"VOC Measurement\" mfcode=\"0x1015\">\r\n      <description>Develco specific attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Measured value\" type=\"u16\" mfcode=\"0x1015\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Min. measured value\" type=\"u16\" mfcode=\"0x1015\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Max. measured value\" type=\"u16\" mfcode=\"0x1015\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Resolution\" type=\"u16\" mfcode=\"0x1015\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- NIKO -->\r\n    <cluster id=\"0xfc00\" name=\"Niko specific\" mfcode=\"0x125f\">\r\n      <description>Niko specific attributes.\r\n\r\nLED color: 0 - off, 255 - white, 65280 - blue, 16711680 - red\r\nChild lock on: 0, Child lock off: 1\r\nLED on: 1, LED off: 0\r\n0x0300: Switches permission to write either to 0x0202 (1) or to 0x0302 (0)\r\nWriting 1 to 0x0202 and 0x0302 makes 0x0300 writable. Then writing 1 to 0x0300 sets 0x0300 bitmap from 0x11 to 0x12, but block all other writes to 0x03XX attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Unknown\" type=\"bmp8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0100\" name=\"LED color\" type=\"u24\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0101\" name=\"Child lock\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0102\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0103\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0104\" name=\"LED on/off\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0200\" name=\"Connected to power since\" type=\"u32\" mfcode=\"0x125f\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0201\" name=\"Unknown\" type=\"u48\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0202\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0300\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0301\" name=\"Unknown\" type=\"bmp8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0302\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0303\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0304\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0305\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0306\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0307\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0308\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0309\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x030A\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0400\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0401\" name=\"Unknown\" type=\"u32\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0500\" name=\"Unknown\" type=\"u16\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0501\" name=\"Unknown\" type=\"u16\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0502\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0503\" name=\"Unknown\" type=\"u16\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0504\" name=\"Unknown\" type=\"u16\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0505\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0506\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0507\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0508\" name=\"Unknown\" type=\"u8\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0600\" name=\"Unknown\" type=\"seckey\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0601\" name=\"Unknown\" type=\"seckey\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0xFFFD\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x125f\" access=\"rw\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- DATEK -->\r\n    <cluster id=\"0xfee1\" name=\"Datek on/off configuration\" mfcode=\"0x1337\">\r\n      <description>Datek on/off configuration attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Off if offline\" type=\"u8\" mfcode=\"0x1337\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Frost guard temperature\" type=\"u8\" mfcode=\"0x1337\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Frost guard temperature hysteresis\" type=\"u8\" mfcode=\"0x1337\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Frost guard mins between change\" type=\"u8\" mfcode=\"0x1337\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"On time\" type=\"u16\" mfcode=\"0x1337\" access=\"rw\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"On/off configuration mode\" type=\"enum8\" mfcode=\"0x1337\" access=\"rw\" required=\"m\">\r\n          <value name=\"Off\" value=\"0x00\"></value>\r\n          <value name=\"On\" value=\"0x01\"></value>\r\n        </attribute>\r\n        <attribute id=\"0xFFFD\" name=\"Cluster revision\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xfeed\" name=\"Datek diagnostics\" mfcode=\"0x1337\">\r\n      <description>Datek diagnostics cluster attributes.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Last reset info\" type=\"u8\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0001\" name=\"Last extended reset info\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0002\" name=\"Reboot counter\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0003\" name=\"Last hop LQI\" type=\"u8\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0004\" name=\"Last hop RSSI\" type=\"s8\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0005\" name=\"Tx power\" type=\"s8\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0010\" name=\"Button 0 click counter\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0020\" name=\"Button 0 ms click counter\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0100\" name=\"Electrical measurement avg\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0101\" name=\"Electrical measurement raw\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0102\" name=\"Electrical measurement noise w load\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0x0103\" name=\"Electrical measurement noise w/o load\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n        <attribute id=\"0xFFFD\" name=\"Cluster revision\" type=\"u16\" mfcode=\"0x1337\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <!-- SCHNEIDER ELECTRIC -->\r\n    <cluster id=\"0xfc04\" name=\"Schneider specific\" mfcode=\"0x105e\">\r\n      <description>Schneider manufacturer-specifc cluster.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Indicator Luminance Level\" type=\"u8\" default=\"0\" mfcode=\"0x105e\" access=\"rw\" required=\"o\">\r\n          <description>Brightness of indication front LED.\r\n            0 = 100 percent\r\n            1 = 80 percent\r\n            2 = 60 percent\r\n            3 = 40 percent\r\n            4 = 20 percent\r\n            5 = 0 percent</description>\r\n        </attribute>\r\n        <attribute id=\"0x0002\" name=\"LED indication\" type=\"u8\" default=\"1\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n          <description>Allows to select the LED indicator mode:\r\n            0: Consistent With Load - The LED on the Socket Outlet is On when the device is On\r\n            1: Reverse With Load - The LED on the Socket Outlet is On when the device is Off\r\n            2: Always Off - The LED on the Socket Outlet is always Off\r\n            3: Always On - The LED on the Socket Outlet is always On</description>\r\n        </attribute>\r\n        <attribute id=\"0x0050\" name=\"Local Control\" type=\"enum8\" default=\"0\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n          <description>0 = local control is active\r\n            1 = local control is inactive\r\n            User can not:\r\n            A) control device locally (OF/OFF)\r\n            B) activate e-mode\r\n            User can:\r\n            A) clear alarm locally</description>\r\n          <value name=\"Local control is active\" value=\"0\"></value>\r\n          <value name=\"Local control is inactive\" value=\"1\"></value>\r\n        </attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster revision\" type=\"u16\" mfcode=\"0x105e\" default=\"1\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n\r\n    <cluster id=\"0xff17\" name=\"Schneider specific\" mfcode=\"0x105e\">\r\n      <description>Schneider manufacturer-specifc cluster.</description>\r\n      <server>\r\n        <attribute id=\"0x0000\" name=\"Switch Indication\" type=\"enum8\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n          <description>Attribute is shared between all endpoints where this cluster is presented.\r\n            Attribute defines the meaning of indicator (LED) on the device, which provides the feedback to user about state of output.\r\n          </description>\r\n          <value name=\"Indicator is on when load is on\" value=\"0\"></value>\r\n          <value name=\"Indicator is always on\" value=\"1\"></value>\r\n          <value name=\"Indicator is on when load is off\" value=\"2\"></value>\r\n          <value name=\"Indicator is always off\" value=\"3\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0001\" name=\"Switch Actions\" type=\"enum8\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n          <description>Default values depends on endpoint and device type. More info you find in device description.\r\n            If value is one of non defined, switch does not send any action when pressed.\r\n          </description>\r\n          <value name=\"Lift (locked)\" value=\"0\"></value>\r\n          <value name=\"Lift and tilt (locked)\" value=\"1\"></value>\r\n          <value name=\"Lift (unlocked)\" value=\"2\"></value>\r\n          <value name=\"Lift and tilt (unlocked)\" value=\"3\"></value>\r\n          <value name=\"Unknown (4)\" value=\"4\"></value>\r\n          <value name=\"Unknown (5)\" value=\"5\"></value>\r\n          <value name=\"Unknown (6)\" value=\"6\"></value>\r\n          <value name=\"Unknown (7)\" value=\"7\"></value>\r\n        </attribute>\r\n        <attribute id=\"0x0010\" name=\"Up Scene ID\" type=\"u8\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n          <description>The Up Scene ID attribute represents the Scene Id field value of any Scene command cluster transmitted by the\r\n            device when user activates is rocker up side according to the rocker configuration. See Switch Actions attribute.\r\n          </description>\r\n        </attribute>\r\n        <attribute id=\"0x0011\" name=\"Up Group ID\" type=\"u16\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n        <description>The Up Group ID attribute represents the Group Id field value of any Scene command cluster transmitted by the\r\n          device when user activates is rocker up side according to the rocker configuration. Value greater than 0xFFF7 means, no\r\n          command is sent. See Switch Actions attribute.\r\n        </description>\r\n        </attribute>\r\n        <attribute id=\"0x0020\" name=\"Down Scene ID\" type=\"u8\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n        <description>The Down Scene ID attribute represents the Scene Id field value of any Scene command cluster transmitted by the\r\n          device when user activates is rocker down side according to the rocker configuration. See Switch Actions attribute.\r\n        </description>\r\n        </attribute>\r\n        <attribute id=\"0x0021\" name=\"Down Group ID\" type=\"u16\" mfcode=\"0x105e\" access=\"rw\" required=\"m\">\r\n        <description>The Down Group ID attribute represents the Group Id field value of any Scene command cluster transmitted by the\r\n          device when user activates is rocker down side according to the rocker configuration. Value greater than 0xFFF7 means, no\r\n          command is sent. See Switch Actions attribute.\r\n        </description>\r\n        </attribute>\r\n        <attribute id=\"0xfffd\" name=\"Cluster Revision\" type=\"u16\" mfcode=\"0x105e\" access=\"r\" required=\"m\"></attribute>\r\n      </server>\r\n      <client>\r\n      </client>\r\n    </cluster>\r\n  </domain>\r\n\r\n  <profile id=\"0104\" name=\"Home Automation\" description=\"This profile defines device descriptions and standard practices for applications needed in a residential or light commercial environment. Installation scenarios range from a single room to an entire home up to 20,000 square feet (approximately 1850m2).\" version=\"1.0\" rev=\"25\" icon=\"ha.png\">\r\n    <domain-ref name=\"General\" low_bound=\"0000\" />\r\n    <domain-ref name=\"Measurement and Sensing\" low_bound=\"0400\" />\r\n    <domain-ref name=\"Lighting\" low_bound=\"0300\" />\r\n    <domain-ref name=\"HVAC\" low_bound=\"0200\" />\r\n    <domain-ref name=\"Closures\" low_bound=\"0100\" />\r\n    <domain-ref name=\"Security and Safety\" low_bound=\"0500\" />\r\n    <domain-ref name=\"Smart Energy\" low_bound=\"0x0700\" />\r\n    <domain-ref name=\"Appliances\" low_bound=\"0x0b00\" />\r\n    <domain-ref name=\"Light Link\" low_bound=\"1000\" />\r\n    <domain-ref name=\"Manufacturer Specific\" low_bound=\"0xfc00\" />\r\n    <device id=\"0x000c\" name=\"Simple sensor\" icon=\"dev-light-sensor.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0010\" name=\"On/off plug-in unit\" description=\"\"></device>\r\n    <device id=\"0x0051\" name=\"Smart plug\" description=\"\"></device>\r\n    <device id=\"0x0100\" name=\"On/off light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0110\" name=\"Dimmable plug-in unit\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0200\" name=\"Color light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0210\" name=\"Extended color light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0220\" name=\"Color temperature light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0800\" name=\"Color controller\" description=\"\"></device>\r\n    <device id=\"0x0810\" name=\"Color scene controller\" description=\"\"></device>\r\n    <device id=\"0x0820\" name=\"Non color controller\" description=\"\"></device>\r\n    <device id=\"0x0830\" name=\"Non color scene controller\" description=\"\"></device>\r\n    <device id=\"0x0840\" name=\"Control bridge\" description=\"\"></device>\r\n    <device id=\"0x0850\" name=\"On/off sensor\" description=\"\"></device>\r\n  </profile>\r\n\r\n  <profile id=\"0109\" name=\"Smart Energy\" description=\"This profile defines device descriptions and standard practices for Demand Response and Load Management 'Smart Energy' applications needed in a Smart Energy based residential or light commercial environment.\" version=\"1.0\" rev=\"15\" icon=\"se.png\">\r\n    <domain-ref name=\"General\" low_bound=\"0000\" />\r\n    <domain-ref name=\"Smart Energy\" low_bound=\"0700\" />\r\n  </profile>\r\n\r\n  <profile id=\"0xc05e\" name=\"Light Link\" description=\"This profile defines device descriptions and standard practices for ZigBee Light Link.\" version=\"1.0\" rev=\"15\" icon=\"zll.png\">\r\n    <domain-ref name=\"General\" low_bound=\"0000\" />\r\n    <domain-ref name=\"Light Link\" low_bound=\"1000\" />\r\n    <domain-ref name=\"Lighting\" low_bound=\"0300\" />\r\n    <domain-ref name=\"Measurement and Sensing\" low_bound=\"0400\" />\r\n    <domain-ref name=\"Smart Energy\" low_bound=\"0x0700\" />\r\n    <domain-ref name=\"Manufacturer Specific\" low_bound=\"0xfc00\" />\r\n    <device id=\"0x0000\" name=\"On/off light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0010\" name=\"On/off plug-in unit\" description=\"\"></device>\r\n    <device id=\"0x0100\" name=\"Dimmable light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0110\" name=\"Dimmable plug-in unit\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0200\" name=\"Color light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0210\" name=\"Extended color light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0220\" name=\"Color temperature light\" description=\"\" icon=\"dev-on-off-light.png\"></device>\r\n    <device id=\"0x0800\" name=\"Color controller\" description=\"\"></device>\r\n    <device id=\"0x0810\" name=\"Color scene controller\" description=\"\"></device>\r\n    <device id=\"0x0820\" name=\"Non color controller\" description=\"\"></device>\r\n    <device id=\"0x0830\" name=\"Non color scene controller\" description=\"\"></device>\r\n    <device id=\"0x0840\" name=\"Control bridge\" description=\"\"></device>\r\n    <device id=\"0x0850\" name=\"On/off sensor\" description=\"\"></device>\r\n  </profile>\r\n\r\n  <profile id=\"0xa1e0\" name=\"Green Power\" description=\"This profile defines device descriptions and standard practices for ZigBee Green Power.\" version=\"1.1\" rev=\"15\" icon=\"zll.png\">\r\n    <domain-ref name=\"Green Power\" low_bound=\"0x0021\" />\r\n  </profile>\r\n\r\n  <profile id=\"0xc105\" name=\"Drop-In Networking\" description=\"This profile defines the Digi Drop-In Networking used by the XBee.\" version=\"1.0\" rev=\"15\" icon=\"dev-unknown.svg\">\r\n    <device id=\"0x0001\" name=\"XBee\" description=\"\" icon=\"dev-range-extender.png\"></device>\r\n  </profile>\r\n\r\n  <profile id=\"0xde00\" name=\"dresden elektronik\" description=\"Profile used by dresden elektronik.\" version=\"1.0\" rev=\"15\" icon=\"de.png\">\r\n    <device id=\"0x0001\" name=\"Configuration Tool\" description=\"\" icon=\"dev-configuration-tool.png\"></device>\r\n  </profile>\r\n\r\n  <profile id=\"0xc0c9\" name=\"Develco Private Profile\" description=\"Profile used by dresden elektronik.\" version=\"1.0\" rev=\"15\" icon=\"dev-unknown.svg\">\r\n    <device id=\"0x0001\" name=\"Develco Utility\" description=\"Private profile for internal Develco Products use only.\"></device>\r\n  </profile>\r\n\r\n  <profile id=\"0xc4c8\" name=\"Leviton Manufacturer Specific Profile\" description=\"Profile used by Leviton Decora Smart switch.\" version=\"1.0\" rev=\"1\" icon=\"dev-on-off-light.png\">\r\n    <domain-ref name=\"Lighting\" low_bound=\"0300\" />\r\n    <domain-ref name=\"Manufacturer Specific\" low_bound=\"0xfc00\" />\r\n  </profile>\r\n\r\n  <devices>\r\n    <!-- Generic -->\r\n    <device id=\"0x0000\" name=\"On/Off Switch\" description=\"\" icon=\"dev-on-off-switch.png\">\r\n    </device>\r\n    <device id=\"0x0001\" name=\"Level Control Switch\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0002\" name=\"On/Off Output\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0003\" name=\"Level Controllable Output\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0004\" name=\"Scene Selector\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0005\" name=\"Configuration Tool\" description=\"\" icon=\"dev-configuration-tool.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0006\" name=\"Remote Control\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0007\" name=\"Combined Interface\" description=\"\" icon=\"dev-combined-interface.svg\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0008\" name=\"Range Extender\" icon=\"dev-range-extender.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0009\" name=\"Mains Power Outlet\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x000a\" name=\"Door Lock\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x000b\" name=\"Door Lock Controller\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x000c\" name=\"Simple Sensor\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x000d\" name=\"Consumption Awareness Device\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0050\" name=\"Home Gateway\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0051\" name=\"Smart Plug\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0052\" name=\"White Goods\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0053\" name=\"Meter Interface\">\r\n      <description></description>\r\n    </device>\r\n    <!-- Lighting -->\r\n    <device id=\"0x0100\" name=\"On/Off Light\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0101\" name=\"Dimmable Light\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0102\" name=\"Color Dimmable Light\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0103\" name=\"On/Off Light Switch\" icon=\"dev-on-off-switch.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0104\" name=\"Dimmer Switch\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0105\" name=\"Color Dimmer Switch\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0106\" name=\"Light Sensor\" icon=\"dev-light-sensor.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0107\" name=\"Occupancy Sensor\" icon=\"dev-occupancy-sensor.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0108\" name=\"On/off ballast\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0109\" name=\"Dimmable ballast\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x010a\" name=\"On/off plugin unit\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x010b\" name=\"Dimmable plugin unit\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x010c\" name=\"Color temperature light\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x010d\" name=\"Extended color light\" icon=\"dev-on-off-light.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x010e\" name=\"Light level sensor\" icon=\"dev-light-sensor.png\">\r\n      <description></description>\r\n    </device>\r\n    <!-- Closures -->\r\n    <device id=\"0x0200\" name=\"Shade\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0201\" name=\"Shade Controller\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0202\" name=\"Window Covering Device\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0203\" name=\"Window Covering Controller\">\r\n      <description></description>\r\n    </device>\r\n    <!-- HVAC -->\r\n    <device id=\"0x0300\" name=\"Heating/Cooling Unit\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0301\" name=\"Thermostat\" description=\"\" icon=\"dev-thermostat.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0302\" name=\"Temperature Sensor\" icon=\"dev-temperature-sensor.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0303\" name=\"Pump\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0304\" name=\"Pump Controller\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0305\" name=\"Pressure Sensor\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0306\" name=\"Flow Sensor\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0307\" name=\"Mini Split AC\">\r\n      <description></description>\r\n    </device>\r\n    <!-- Intruder Alarm Systems -->\r\n    <device id=\"0x0400\" name=\"IAS Control and Indicating Equipment\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0401\" name=\"IAS Ancillary Control Equipment\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0402\" name=\"IAS Zone\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0403\" name=\"IAS Warning Device\">\r\n      <description></description>\r\n    </device>\r\n    <!-- Smart Energy -->\r\n    <device id=\"0x0500\" name=\"Energy Service Portal\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0501\" name=\"Metering Device\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0502\" name=\"In-Premise Display\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0503\" name=\"Programmable Communicating Thermostat (PCT)\" description=\"\" icon=\"dev-prog-thermostat.png\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0504\" name=\"Load Control Device\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0505\" name=\"Smart Appliance\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0506\" name=\"Prepayment Terminal\">\r\n      <description></description>\r\n    </device>\r\n    <device id=\"0x0507\" name=\"Device Management\">\r\n      <description></description>\r\n    </device>\r\n  </devices>\r\n</zcl>\r\n"
        },
        {
          "name": "green_power.cpp",
          "type": "blob",
          "size": 12.5302734375,
          "content": "/*\n * Copyright (c) 2020-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QDataStream>\n\n#ifdef HAS_OPENSSL\n#define OPEN_SSL_VERSION_MIN 0x10100000L\n\n#include <openssl/opensslv.h>\n#if OPENSSL_VERSION_NUMBER >= OPEN_SSL_VERSION_MIN\n  #define HAS_RECENT_OPENSSL\n#endif\n#endif\n\n#ifdef HAS_RECENT_OPENSSL\n  #include <openssl/aes.h>\n  #include <openssl/evp.h>\n#endif\n#include <string>\n#include \"deconz/aps_controller.h\"\n#include \"deconz/dbg_trace.h\"\n#include \"deconz/green_power.h\"\n#include \"deconz/zcl.h\"\n#include \"deconz/u_library_ex.h\"\n#include \"green_power.h\"\n#include \"resource.h\"\n\n#define GP_PAIR_INTERVAL_SECONDS (60 * 15)\n\n// this code is based on\n// https://github.com/Smanar/Zigbee_firmware/blob/master/Encryption.cpp\n\n#define AES_KEYLENGTH 128\n#define AES_BLOCK_SIZE 16\n\n\n// From https://github.com/Koenkk/zigbee-herdsman/blob/master/src/controller/greenPower.ts\n/*!\n */\nGpKey_t GP_DecryptSecurityKey(quint32 sourceID, const GpKey_t &securityKey)\n{\n    GpKey_t result = { 0 };\n\n#ifdef HAS_RECENT_OPENSSL\n    void *libCrypto = nullptr;\n    void *libSsl = nullptr;\n    const unsigned char defaultTCLinkKey[] = { 0x5A, 0x69, 0x67, 0x42, 0x65, 0x65, 0x41, 0x6C, 0x6C, 0x69, 0x61, 0x6E, 0x63, 0x65, 0x30, 0x39 };\n\n    unsigned char nonce[13]; // u8 source address, u32 frame counter, u8 security control\n    unsigned char sourceIDInBytes[4];\n\n    sourceIDInBytes[0] = sourceID & 0x000000ff;\n    sourceIDInBytes[1] = (sourceID & 0x0000ff00) >> 8;\n    sourceIDInBytes[2] = (sourceID & 0x00ff0000) >> 16;\n    sourceIDInBytes[3] = (sourceID & 0xff000000) >> 24;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            nonce[4 * i + j] = sourceIDInBytes[j];\n        }\n    }\n\n    nonce[12] = 0x05;\n\n    libCrypto = U_library_open_ex(\"libcrypto\");\n    libSsl = U_library_open_ex(\"libssl\");\n\n    if (!libCrypto || !libSsl)\n    {\n        DBG_Printf(DBG_ZGP, \"[ZGP] OpenSSl library for ZGP encryption not found\\n\");\n        return result;\n    }\n\n    unsigned long openSslVersion = 0;\n\n    auto _OpenSSL_version_num = reinterpret_cast<unsigned long (*)(void)>(U_library_symbol(libCrypto, \"OpenSSL_version_num\"));\n    const auto _EVP_CIPHER_CTX_new = reinterpret_cast<EVP_CIPHER_CTX*(*)(void)>(U_library_symbol(libCrypto, \"EVP_CIPHER_CTX_new\"));\n    const auto _EVP_EncryptInit_ex = reinterpret_cast<int (*)(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned char *key, const unsigned char *iv)>(U_library_symbol(libCrypto, \"EVP_EncryptInit_ex\"));\n    const auto _EVP_CIPHER_CTX_ctrl = reinterpret_cast<int (*)(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)>(U_library_symbol(libCrypto, \"EVP_CIPHER_CTX_ctrl\"));\n    const auto _EVP_EncryptUpdate = reinterpret_cast<int (*)(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl)>(U_library_symbol(libCrypto, \"EVP_EncryptUpdate\"));\n    const auto _EVP_CIPHER_CTX_free = reinterpret_cast<void (*)(EVP_CIPHER_CTX *c)>(U_library_symbol(libCrypto, \"EVP_CIPHER_CTX_free\"));\n    const auto _EVP_aes_128_ccm  = reinterpret_cast<const EVP_CIPHER *(*)(void)>(U_library_symbol(libCrypto, \"EVP_aes_128_ccm\"));\n\n    if (_OpenSSL_version_num)\n    {\n        openSslVersion = _OpenSSL_version_num();\n    }\n\n    if (openSslVersion >= OPEN_SSL_VERSION_MIN &&\n            _EVP_CIPHER_CTX_new &&\n            _EVP_EncryptInit_ex &&\n            _EVP_CIPHER_CTX_ctrl &&\n            _EVP_EncryptUpdate &&\n            _EVP_CIPHER_CTX_free &&\n            _EVP_aes_128_ccm)\n    {\n        DBG_Printf(DBG_ZGP, \"[ZGP] OpenSSl version 0x%08X loaded\\n\", openSslVersion);\n    }\n    else\n    {\n        DBG_Printf(DBG_ZGP, \"[ZGP] OpenSSl library version 0x%08X for ZGP encryption resolve symbols failed\\n\", openSslVersion);\n        return result;\n    }\n\n    // buffers for encryption and decryption\n    constexpr size_t encryptLength = ((GP_SECURITY_KEY_SIZE + AES_BLOCK_SIZE) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;\n    std::array<unsigned char, encryptLength> encryptBuf = { 0 };\n\n    EVP_CIPHER_CTX *ctx = _EVP_CIPHER_CTX_new();\n    int outlen = 0;\n\n    /* Set cipher type and mode */\n    _EVP_EncryptInit_ex(ctx, _EVP_aes_128_ccm(), nullptr, nullptr, nullptr);\n\n    /* Set nonce length if default 96 bits is not appropriate */\n    _EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, sizeof(nonce), nullptr);\n\n    /* Initialise key and IV */\n    _EVP_EncryptInit_ex(ctx, nullptr, nullptr, defaultTCLinkKey, nonce);\n\n    /* Encrypt plaintext: can only be called once */\n    _EVP_EncryptUpdate(ctx, encryptBuf.data(), &outlen, securityKey.data(), static_cast<int>(securityKey.size()));\n    _EVP_CIPHER_CTX_free(ctx);\n\n    std::copy(encryptBuf.begin(), encryptBuf.begin() + result.size(), result.begin());\n\n#else\n    Q_UNUSED(securityKey)\n    DBG_Printf(DBG_ERROR, \"[ZGP] failed to decrypt GPDKey for 0x%08X, OpenSSL is not available or too old\\n\", unsigned(sourceID));\n#endif // HAS_RECENT_OPENSSL\n\n    return result;\n}\n\n/*! Send Commissioning Mode command to GP proxy device.\n */\nbool GP_SendProxyCommissioningMode(deCONZ::ApsController *apsCtrl, quint8 zclSeqNo)\n{\n    deCONZ::ApsDataRequest req;\n\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.dstAddress().setNwk(deCONZ::BroadcastRouters);\n    req.setProfileId(GP_PROFILE_ID);\n    req.setClusterId(GREEN_POWER_CLUSTER_ID);\n    req.setDstEndpoint(GREEN_POWER_ENDPOINT);\n    req.setSrcEndpoint(GREEN_POWER_ENDPOINT);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n    req.setTxOptions(nullptr);\n#endif\n    req.setRadius(0);\n\n    QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    deCONZ::ZclFrame zclFrame;\n\n    zclFrame.setSequenceNumber(zclSeqNo);\n    zclFrame.setCommandId(0x02); // commissioning mode\n    zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionServerToClient |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint8 options = 0x0b; // enter commissioning mode, exit on window expire\n        quint16 window = 40;\n        stream << options;\n        stream << window;\n    }\n\n    { // ZCL frame\n\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n    // broadcast\n    if (apsCtrl->apsdeDataRequest(req) == deCONZ::Success)\n    {\n        DBG_Printf(DBG_ZGP, \"[ZGP] send GP proxy commissioning mode\\n\");\n        return true;\n    }\n\n    DBG_Printf(DBG_ZGP, \"[ZGP] send GP proxy commissioning mode failed\\n\");\n    return false;\n}\n\n/*! Send Pair command to GP proxy device.\n */\nbool GP_SendPairing(quint32 gpdSrcId, quint16 sinkGroupId, quint8 deviceId, quint32 frameCounter, const GpKey_t &key, deCONZ::ApsController *apsCtrl, quint8 zclSeqNo, quint16 gppShortAddress)\n{\n    deCONZ::ApsDataRequest req;\n\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.dstAddress().setNwk(gppShortAddress);\n    req.setProfileId(GP_PROFILE_ID);\n    req.setClusterId(GREEN_POWER_CLUSTER_ID);\n    req.setDstEndpoint(GREEN_POWER_ENDPOINT);\n    req.setSrcEndpoint(GREEN_POWER_ENDPOINT);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n    req.setTxOptions(nullptr);\n#endif\n    req.setRadius(0);\n\n    QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    deCONZ::ZclFrame zclFrame;\n\n    zclFrame.setSequenceNumber(zclSeqNo);\n    zclFrame.setCommandId(0x01); // pairing\n    zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionServerToClient |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        // 0..2: applicationID\n        // 3: add sink\n        // 4: remove gpd\n        // 5..6: communication mode\n        // 7: gpd fixed\n        quint8 options0 = 0x48; // bits 0..7: add sink, enter commissioning mode, exit on window expire\n\n        // 0 / 8: gpd mac seq number capabilities\n        // 1..2 / 9..10: security level\n        // 3..5 / 11..13: security key type\n        // 6 / 14: frame counter present\n        // 7 / 15: gpd security key present\n\n        // The GPDsecurityFrameCounter field shall be present whenever the AddSink sub-field of the Options field is set to 0b1;\n\n        quint8 options1 = 0xe5;\n        // bits 8..15: security level 0b10 (Full (4B) frame counter and full (4B) MIC only)\n        //             key type 0b100 (individual, out- of-the-box GPD key),\n        //             frame counter present, security key present\n        quint8 options2 = 0x00;\n        stream << options0;\n        stream << options1;\n        stream << options2;\n        stream << gpdSrcId;\n        stream << sinkGroupId;\n        stream << deviceId;\n        stream << frameCounter;\n\n        {\n            for (size_t  i = 0; i < 16; i++)\n            {\n                stream << key[i];\n            }\n        }\n    }\n\n    { // ZCL frame\n\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        zclFrame.writeToStream(stream);\n    }\n\n    // broadcast\n    if (apsCtrl->apsdeDataRequest(req) == deCONZ::Success)\n    {\n        DBG_Printf(DBG_ZGP, \"[ZGP]  send GP pairing to 0x%04X\\n\", gppShortAddress);\n        return true;\n    }\n\n    DBG_Printf(DBG_ZGP, \"[ZGP] send GP pairing to 0x%04X failed\\n\", gppShortAddress);\n    return false;\n}\n\n\n// TODO remove TMP_ functions after alarm systems PR is merged, where these functions are in utils.h\nstatic bool TMP_isHexChar(char ch)\n{\n    return ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'));\n}\n\nstatic quint64 TMP_extAddressFromUniqueId(const QString &uniqueId)\n{\n    quint64 result = 0;\n\n    if (uniqueId.size() < 23)\n    {\n        return result;\n    }\n\n    // 28:6d:97:00:01:06:41:79-01-0500  31 characters\n    int pos = 0;\n    char buf[16 + 1];\n\n    for (auto ch : uniqueId)\n    {\n        if (ch != ':')\n        {\n            buf[pos] = ch.toLatin1();\n\n            if (!TMP_isHexChar(buf[pos]))\n            {\n                return result;\n            }\n            pos++;\n        }\n\n        if (pos == 16)\n        {\n            buf[pos] = '\\0';\n            break;\n        }\n    }\n\n    if (pos == 16)\n    {\n        result = strtoull(buf, nullptr, 16);\n    }\n\n    return result;\n}\n\n/*! For already paired ZGP devices a Pair command needs to be send periodically every \\c GP_PAIR_INTERVAL_SECONDS\n    in order to keep ZGP Proxy entrys alive.\n\n    Each ZGP device keeps track of when the last Pair command was sent and the current device frame counter.\n */\nbool GP_SendPairingIfNeeded(Resource *resource, deCONZ::ApsController *apsCtrl, quint8 zclSeqNo)\n{\n    if (!resource || !apsCtrl)\n    {\n        return false;\n    }\n\n    ResourceItem *gpdLastpair = resource->item(RStateGPDLastPair);\n    if (!gpdLastpair)\n    {\n        return false;\n    }\n\n    const deCONZ::SteadyTimeRef now = deCONZ::steadyTimeRef();\n\n    if (now - deCONZ::SteadyTimeRef{gpdLastpair->toNumber()} < deCONZ::TimeSeconds{GP_PAIR_INTERVAL_SECONDS})\n    {\n        return false;\n    }\n\n    // the GPDKey must be known to send pair command\n    ResourceItem *gpdKey = resource->item(RConfigGPDKey);\n\n    if (!gpdKey || gpdKey->toString().isEmpty())\n    {\n        return false;\n    }\n\n    ResourceItem *frameCounter = resource->item(RStateGPDFrameCounter);\n    ResourceItem *gpdDeviceId = resource->item(RConfigGPDDeviceId);\n    ResourceItem *uniqueId = resource->item(RAttrUniqueId);\n\n    if (!gpdKey || !frameCounter || !gpdDeviceId || !uniqueId)\n    {\n        return false;\n    }\n\n    auto srcGpdId = TMP_extAddressFromUniqueId(uniqueId->toString());\n\n    if (srcGpdId == 0 || srcGpdId > UINT32_MAX)\n    {\n        return false; // should not happen\n    }\n\n    GpKey_t key;\n\n    {\n        QByteArray arr = QByteArray::fromHex(gpdKey->toString().toLocal8Bit());\n        DBG_Assert(arr.size() == int(key.size()));\n        if (arr.size() != int(key.size()))\n        {\n            return false;\n        }\n\n        memcpy(key.data(), arr.constData(), key.size());\n    }\n\n    quint8 deviceId = gpdDeviceId->toNumber() & 0xFF;\n\n    if (GP_SendPairing(quint32(srcGpdId), GP_DEFAULT_PROXY_GROUP, deviceId, frameCounter->toNumber(), key, apsCtrl, zclSeqNo, deCONZ::BroadcastRouters))\n    {\n        gpdLastpair->setValue(now.ref);\n        return true;\n    }\n\n    return false;\n}\n"
        },
        {
          "name": "green_power.h",
          "type": "blob",
          "size": 1.2138671875,
          "content": "/*\n * Copyright (c) 2020-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef GREEN_POWER_H\n#define GREEN_POWER_H\n\n#include <array>\n#include <QtGlobal>\n\n#define GREEN_POWER_CLUSTER_ID  0x0021\n#define GREEN_POWER_ENDPOINT    0xf2\n#define GP_SECURITY_KEY_SIZE 16\n#define GP_MAX_PROXY_PAIRINGS 3\n#define GP_DEFAULT_PROXY_GROUP 0xdd09\n\nnamespace deCONZ {\n    class ApsController;\n}\n\nenum ZgpDeviceId\n{\n    GpDeviceIdOnOffSwitch = 0x02,\n    GpDeviceIdGenericSwitch = 0x07\n};\n\nclass Resource;\n\nusing GpKey_t = std::array<unsigned char, GP_SECURITY_KEY_SIZE>;\n\nGpKey_t GP_DecryptSecurityKey(quint32 sourceID, const GpKey_t &securityKey);\nbool GP_SendProxyCommissioningMode(deCONZ::ApsController *apsCtrl, quint8 zclSeqNo);\nbool GP_SendPairing(quint32 gpdSrcId, quint16 sinkGroupId, quint8 deviceId, quint32 frameCounter, const GpKey_t &key, deCONZ::ApsController *apsCtrl, quint8 zclSeqNo, quint16 gppShortAddress);\nbool GP_SendPairingIfNeeded(Resource *resource, deCONZ::ApsController *apsCtrl, quint8 zclSeqNo);\n\n#endif // GREEN_POWER_H\n"
        },
        {
          "name": "group.cpp",
          "type": "blob",
          "size": 6.568359375,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"event_emitter.h\"\n#include \"group.h\"\n#include <QStringList>\n\n/*! Constructor.\n */\nGroup::Group() :\n    Resource(RGroups),\n    m_state(StateNormal),\n    m_addr(0),\n    m_id(\"0\"),\n    m_on(false),\n    m_colorLoopActive(false)\n{\n   sendTime = QTime::currentTime();\n   hidden = false;\n   hueReal = 0;\n   hue = 0;\n   sat = 127;\n   level = 127;\n   colorX = 0;\n   colorY = 0;\n   colorTemperature = 0;\n   colormode = QLatin1String(\"hs\");\n   alert = QLatin1String(\"none\");\n\n    // add common items\n    addItem(DataTypeString, RAttrName);\n    addItem(DataTypeBool, RStateAllOn);\n    addItem(DataTypeBool, RStateAnyOn);\n    addItem(DataTypeString, RActionScene);\n    ResourceItem * rtype = addItem(DataTypeString, RAttrType);\n    rtype->setValue(QString(QLatin1String(\"LightGroup\")));\n    ResourceItem * rclass = addItem(DataTypeString, RAttrClass);\n    rclass->setValue(QString(QLatin1String(\"Other\")));\n}\n\n/*! Returns the 16 bit group address.\n */\nuint16_t Group::address() const\n{\n    return m_addr;\n}\n\n/*! Sets the 16 bit group address.\n    \\param address the 16 bit group address (ZigBee level)\n */\nvoid Group::setAddress(uint16_t address)\n{\n    m_addr = address;\n    m_id = QString::number(address);\n}\n\n/*! Returns the group identifier. */\nconst QString &Group::id() const\n{\n    return m_id;\n}\n\n/*! Returns the group name.\n */\nconst QString &Group::name() const\n{\n    return item(RAttrName)->toString();\n}\n\n/*! Sets the group name.\n    \\param name the group name\n */\nvoid Group::setName(const QString &name)\n{\n    ResourceItem *it = item(RAttrName);\n    it->setValue(name);\n}\n\n/*! Returns the group state.\n */\nGroup::State Group::state() const\n{\n    return m_state;\n}\n\n/*! Sets the group state.\n    \\param state the group state\n */\nvoid Group::setState(State state)\n{\n    m_state = state;\n}\n\n/*! Returns true if the group is on. */\nbool Group::isOn() const\n{\n    return m_on;\n}\n\n/*! Sets the group on state.\n    \\param on whereever the group is on or off\n */\nvoid Group::setIsOn(bool on)\n{\n    m_on = on;\n}\n\n/*! Sets the group color loop active state.\n    \\param colorLoopActive whereever the color loop is active\n */\nvoid Group::setColorLoopActive(bool colorLoopActive)\n{\n    m_colorLoopActive = colorLoopActive;\n}\n\n/*! Returns true if the color loop is active. */\nbool Group::isColorLoopActive() const\n{\n    return m_colorLoopActive;\n}\n\n/*! Handles admin when ResourceItem value has been set.\n * \\param i ResourceItem\n */\nvoid Group::didSetValue(ResourceItem *i)\n{\n    enqueueEvent(Event(RGroups, i->descriptor().suffix, id(), i));\n}\n\n/*! multiDeviceIds to string. */\nconst QString Group::midsToString() const\n{\n    QString result = \"\";\n\n    std::vector<QString>::const_iterator i = m_multiDeviceIds.begin();\n    std::vector<QString>::const_iterator end = m_multiDeviceIds.end();\n\n    for (;i != end; ++i)\n    {\n        result.append(*i);\n        if (i != end-1)\n        {\n            result.append(QLatin1String(\",\"));\n        }\n    }\n\n    return result;\n}\n\n/*! multiDeviceIds String to vector. */\nvoid Group::setMidsFromString(const QString &mids)\n{\n    QStringList list = mids.split(QLatin1String(\",\"), SKIP_EMPTY_PARTS);\n\n    QStringList::const_iterator i = list.begin();\n    QStringList::const_iterator end = list.end();\n\n    for (;i != end; ++i)\n    {\n        m_multiDeviceIds.push_back(*i);\n    }\n}\n\n/*! deviceMembership to string. */\nconst QString Group::dmToString() const\n{\n    QString result(QLatin1String(\"\"));\n\n    std::vector<QString>::const_iterator i = m_deviceMemberships.begin();\n    std::vector<QString>::const_iterator end = m_deviceMemberships.end();\n\n    for (;i != end; ++i)\n    {\n        result.append(*i);\n        if (i != end-1)\n        {\n            result.append(\",\");\n        }\n    }\n\n    return result;\n}\n\n/*! deviceMembership String to vector. */\nvoid Group::setDmFromString(const QString &deviceIds)\n{\n    QStringList list = deviceIds.split(QLatin1String(\",\"), SKIP_EMPTY_PARTS);\n\n    QStringList::const_iterator i = list.begin();\n    QStringList::const_iterator end = list.end();\n\n    for (;i != end; ++i)\n    {\n        m_deviceMemberships.push_back(*i);\n    }\n}\n\n/*! lightsequence to string. */\nconst QString Group::lightsequenceToString() const\n{\n    QString result(QLatin1String(\"\"));\n\n    std::vector<QString>::const_iterator i = m_lightsequence.begin();\n    std::vector<QString>::const_iterator end = m_lightsequence.end();\n\n    for (;i != end; ++i)\n    {\n        result.append(*i);\n        if (i != end-1)\n        {\n            result.append(QLatin1String(\",\"));\n        }\n    }\n\n    return result;\n}\n\n/*! lightsequence String to vector. */\nvoid Group::setLightsequenceFromString(const QString &lightsequence)\n{\n    QStringList list = lightsequence.split(QLatin1String(\",\"), SKIP_EMPTY_PARTS);\n\n    QStringList::const_iterator i = list.begin();\n    QStringList::const_iterator end = list.end();\n\n    for (;i != end; ++i)\n    {\n        m_lightsequence.push_back(*i);\n    }\n}\n\n/*! Returns the scene for a given \\p sceneId or 0 if not present. */\nScene *Group::getScene(quint8 sceneId)\n{\n    std::vector<Scene>::iterator i = scenes.begin();\n    std::vector<Scene>::iterator end = scenes.end();\n    for (; i != end; ++i)\n    {\n        if (i->id == sceneId && i->state == Scene::StateNormal)\n        {\n            return &*i;\n        }\n    }\n\n    return 0;\n}\n\n/*! Returns true if device with \\p id was added to the group. */\nbool Group::addDeviceMembership(const QString &id)\n{\n    if (std::find(m_deviceMemberships.begin(), m_deviceMemberships.end(), id) == m_deviceMemberships.end())\n    {\n        m_deviceMemberships.push_back(id);\n        return true;\n    }\n\n    return false;\n}\n\n/*! Returns true if device with \\p id was removed from the group. */\nbool Group::removeDeviceMembership(const QString &id)\n{\n    std::vector<QString>::iterator i = std::find(m_deviceMemberships.begin(), m_deviceMemberships.end(), id);\n\n    if (i != m_deviceMemberships.end())\n    {\n        *i = m_deviceMemberships.back();\n        m_deviceMemberships.pop_back();\n        return true;\n    }\n\n    return false;\n}\n\n/*! Returns true if device with \\p id controls the group. */\nbool Group::deviceIsMember(const QString &id) const\n{\n    if (std::find(m_deviceMemberships.begin(), m_deviceMemberships.end(), id) == m_deviceMemberships.end())\n    {\n        return false;\n    }\n    return true;\n}\n\n/*! Returns true if group is controlled by devices. */\nbool Group::hasDeviceMembers() const\n{\n    return !m_deviceMemberships.empty();\n}\n"
        },
        {
          "name": "group.h",
          "type": "blob",
          "size": 2.0595703125,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef GROUP_H\n#define GROUP_H\n\n#include <stdint.h>\n#include <QString>\n#include <QTime>\n#include <vector>\n#include \"resource.h\"\n#include \"scene.h\"\n\n/*! \\class Group\n\n    Represents the group state of lights.\n */\nclass Group : public Resource\n{\npublic:\n    enum State\n    {\n        StateNormal,\n        StateDeleted,\n        StateDeleteFromDB\n    };\n\n    Group();\n    uint16_t address() const;\n    void setAddress(uint16_t address);\n    const QString &id() const;\n    const QString &name() const;\n    void setName(const QString &name);\n    State state() const;\n    void setState(State state);\n    bool isOn() const;\n    void setIsOn(bool on);\n    void setColorLoopActive(bool colorLoopActive);\n    bool isColorLoopActive() const;\n    void didSetValue(ResourceItem *i) override;\n    const QString midsToString() const;\n    void setMidsFromString(const QString &mids);\n    const QString dmToString() const;\n    void setDmFromString(const QString &deviceIds);\n    const QString lightsequenceToString() const;\n    void setLightsequenceFromString(const QString &deviceIds);\n    Scene *getScene(quint8 sceneId);\n    bool addDeviceMembership(const QString &id);\n    bool removeDeviceMembership(const QString &id);\n    bool deviceIsMember(const QString &id) const;\n    bool hasDeviceMembers() const;\n\n    uint16_t colorX;\n    uint16_t colorY;\n    uint16_t hue;\n    qreal hueReal;\n    uint16_t sat;\n    uint16_t level;\n    uint16_t colorTemperature;\n    QString etag;\n    QString colormode;\n    QString alert;\n    std::vector<Scene> scenes;\n    QTime sendTime;\n    bool hidden;\n    std::vector<QString> m_multiDeviceIds;\n    std::vector<QString> m_lightsequence;\n    std::vector<QString> m_deviceMemberships;\n\nprivate:\n    State m_state;\n    uint16_t m_addr;\n    QString m_id;\n    bool m_on;\n    bool m_colorLoopActive;\n};\n\n#endif // GROUP_H\n"
        },
        {
          "name": "group_info.cpp",
          "type": "blob",
          "size": 0.69140625,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"group_info.h\"\n\n/*! Constructor.\n */\nGroupInfo::GroupInfo() :\n   state(StateInGroup),\n   actions(ActionNone),\n   id(0),\n   modifyScenesRetries(0),\n   m_sceneCount(0)\n{\n}\n\n/*! Returns the scene Count.\n */\nuint8_t GroupInfo::sceneCount() const\n{\n    return m_sceneCount;\n}\n\n/*! Sets the sceneCount.\n    \\param sceneCount the sceneCount\n */\nvoid GroupInfo::setSceneCount(uint8_t sceneCount)\n{\n    m_sceneCount = sceneCount;\n}\n"
        },
        {
          "name": "group_info.h",
          "type": "blob",
          "size": 1.0341796875,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef GROUP_INFO_H\n#define GROUP_INFO_H\n\n#include <stdint.h>\n#include <vector>\n\nclass GroupInfo\n{\npublic:\n    enum Action\n    {\n        ActionNone            = 0x00,\n        ActionReadScenes      = 0x01,\n        ActionAddToGroup      = 0x02,\n        ActionRemoveFromGroup = 0x04\n    };\n\n    enum Constants\n    {\n        MaxActionRetries = 3\n    };\n\n    enum State\n    {\n        StateInGroup,\n        StateNotInGroup\n    };\n\n    GroupInfo();\n\n    State state;\n    uint8_t actions;\n    uint16_t id;\n    std::vector<uint8_t> addScenes;\n    std::vector<uint8_t> removeScenes;\n    std::vector<uint8_t> modifyScenes;\n    int modifyScenesRetries;\n\n    uint8_t sceneCount() const;\n    void setSceneCount(uint8_t sceneCount);\n\nprivate:\n\n    uint8_t m_sceneCount;\n};\n\n#endif // GROUP_INFO_H\n"
        },
        {
          "name": "gw_uuid.cpp",
          "type": "blob",
          "size": 1.015625,
          "content": "/*\r\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QUuid>\r\n#include <QSettings>\r\n#include \"de_web_plugin_private.h\"\r\n\r\n/*! Generates a uinique id for the gateway. */\r\nvoid DeRestPluginPrivate::generateGatewayUuid()\r\n{\r\n#ifdef Q_OS_WIN\r\n    QSettings settings(\"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\", QSettings::NativeFormat);\r\n    gwUuid = settings.value(\"MachineGuid\", \"\").toString();\r\n\r\n    if (gwUuid.isEmpty())\r\n    {\r\n        QUuid uuid = QUuid::createUuid();\r\n        gwUuid = uuid.toString();\r\n    }\r\n#endif\r\n\r\n#ifdef Q_OS_LINUX\r\n   QUuid uuid = QUuid::createUuid();\r\n   gwUuid = uuid.toString().replace(\"{\", \"\").replace(\"}\", \"\");\r\n#endif\r\n\r\n   DBG_Assert(!gwUuid.isEmpty());\r\n\r\n   if (!gwUuid.isEmpty())\r\n   {\r\n       queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n   }\r\n}\r\n"
        },
        {
          "name": "hue.cpp",
          "type": "blob",
          "size": 11.689453125,
          "content": "/*\n * Handle Hue-specific FC03 cluster.\n */\n\n#include <QString>\n#include <math.h>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n#define HUE_EFFECTS_CLUSTER_ID 0xFC03\n\nstruct code {\n    quint8 value;\n    QString name;\n};\n\ncode effects[] = {\n    { 0x01, QLatin1String(\"candle\") },\n    { 0x02, QLatin1String(\"fire\") },\n    { 0x03, QLatin1String(\"prism\") },\n    { 0x09, QLatin1String(\"sunrise\") },\n    { 0x0a, QLatin1String(\"sparkle\") },\n    { 0x0b, QLatin1String(\"opal\") },\n    { 0x0c, QLatin1String(\"glisten\") },\n    { 0x0d, QLatin1String(\"sunset\") },\n    { 0x0e, QLatin1String(\"underwater\") },\n    { 0x0f, QLatin1String(\"cosmos\") },\n    { 0x10, QLatin1String(\"sunbeam\") },\n    { 0x11, QLatin1String(\"enchant\") }\n};\n\nquint8 effectNameToValue(QString &effectName)\n{\n    for (auto &e: effects)\n    {\n        if (e.name == effectName)\n        {\n            return e.value;\n        }\n    }\n    return 0xFF;\n}\n\n/*! Return a list of effect names corresponding to the bitmap of supported effects.\n\n   \\param effectBitmap - the bitmap with supported effects (from 0x0011)\n   \\return QStringList of effect names\n */\nQStringList DeRestPluginPrivate::getHueEffectNames(quint64 effectBitmap, bool colorloop)\n{\n    QStringList names = { QLatin1String(\"none\") };\n    if (colorloop)\n    {\n        names.append(QLatin1String(\"colorloop\"));\n    }\n    for (auto &e: effects) {\n        if (effectBitmap & (0x01 << e.value))\n        {\n            names.append(e.name);\n        }\n    }\n    return names;\n};\n\ncode styles[] = {\n    { 0x00, QLatin1String(\"linear\") }, // interpolated_palette\n    { 0x02, QLatin1String(\"scattered\") }, // random_pixelated\n    { 0x04, QLatin1String(\"mirrored\") } // interpolated_palette_mirrored\n};\n\nquint8 styleNameToValue(QString &styleName)\n{\n    for (auto &s: styles)\n    {\n        if (s.name == styleName)\n        {\n            return s.value;\n        }\n    }\n    return 0xFF;\n}\n\n/*! Return a list of style names corresponding to the bitmap of supported styles.\n\n   \\param styleBitmap - the bitmap with supported styles (from 0x0013)\n   \\return QStringList of style names\n */\nQStringList DeRestPluginPrivate::getHueGradientStyleNames(quint16 styleBitmap)\n{\n    QStringList names = {};\n\n    for (auto &s: styles) {\n        if (styleBitmap & (0x01 << (s.value >> 1)))\n        {\n            names.append(s.name);\n        }\n    }\n    return names;\n};\n\nconst double maxX = 0.7347;\nconst double maxY = 0.8431;\n\n/*! Add a Hue effect task to the queue.\n\n   \\param task - the task item\n   \\param effectName - the effect\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskHueEffect(TaskItem &task, QString &effectName)\n{\n    task.taskType = TaskHueEffect;\n    task.req.setClusterId(HUE_EFFECTS_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x00);\n    task.zclFrame.setManufacturerCode(VENDOR_PHILIPS);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCManufacturerSpecific |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << (quint16) 0x0020; // set effect\n        // stream << (quint16) 0x0021; // set effect (with on/off)\n        // stream << (quint8) 1; // on\n        if (effectName == \"none\")\n        {\n            stream << (quint8) 0; // none\n        }\n        else\n        {\n            stream << effectNameToValue(effectName);\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\nbool DeRestPluginPrivate::validateHueGradient(const ApiRequest &req, ApiResponse &rsp, QVariantMap &gradient, quint16 styleBitmap = 0x0001)\n{\n    QString id = req.path[3];\n    bool ok = true;\n    bool check;\n\n    if (gradient[\"points\"].isNull())\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, gradient/points, for parameter, gradient\")));\n        return false;\n    }\n    if (gradient[\"points\"].type() != QVariant::List)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/points\").arg(gradient[\"points\"].toString())));\n        return false;\n    }\n    QVariantList &points = *reinterpret_cast<QVariantList *>(gradient[\"points\"].data()); // Create reference instead of copy\n    const quint8 length = points.length();\n    if (length < 2 || length > 9)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid length, %1, for parameter, gradient/points\").arg(length)));\n        return false;\n    }\n    if (gradient[\"segments\"].isNull()) gradient[\"segments\"] = length;\n    if (gradient[\"color_adjustment\"].isNull()) gradient[\"color_adjustment\"] = 0;\n    if (gradient[\"offset\"].isNull()) gradient[\"offset\"] = 0;\n    if (gradient[\"offset_adjustment\"].isNull()) gradient[\"offset_adjustment\"] = 0;\n    if (gradient[\"style\"].isNull()) gradient[\"style\"] = \"linear\";\n\n    for (QVariantMap::const_iterator p = gradient.begin(); p != gradient.end(); p++)\n    {\n        QString param = p.key();\n\n        if (param == \"points\")\n        {\n            int i = -1;\n            for (auto &point : points)\n            {\n                i++;\n                if (point.type() != QVariant::List)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/points/%2\").arg(point.toString()).arg(i)));\n                    ok = false;\n                    continue;\n                }\n                QVariantList &xy = *reinterpret_cast<QVariantList *>(point.data()); // Create reference instead of copy\n                if (xy.length() != 2)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid length, %1, for parameter, gradient/points/%2\").arg(xy.length()).arg(i)));\n                    ok = false;\n                    continue;\n                }\n                double x = xy[0].toDouble(&check);\n                if (!check || x < 0 || x > 1)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/points/%2/0\").arg(xy[0].toString()).arg(i)));\n                    ok = false;\n                }\n                if (x > maxX) xy[0] = maxX; // This is why we needed a reference\n                double y = xy[1].toDouble(&check);\n                if (!check || y < 0 || y > 1)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/points/%2/1\").arg(xy[1].toString()).arg(i)));\n                    ok = false;\n                }\n                if (y > maxY) xy[1] = maxY; // This is why we needed a reference\n            }\n        }\n        else if (param == \"segments\" || param == \"offset\")\n        {\n            quint8 value = gradient[param].toUInt(&check);\n            if (!check || value > 0x1F)\n            {\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/%2\").arg(gradient[param].toString()).arg(param)));\n                ok = false;\n            }\n        }\n        else if (param == \"style\")\n        {\n            QString styleName = gradient[param].toString();\n            bool valid = false;\n            for (auto &s: styles)\n            {\n                if (styleName == s.name && (styleBitmap & (0x01 << (s.value >> 1)))) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid)\n            {\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/%2\").arg(gradient[param].toString()).arg(param)));\n                ok = false;\n            }\n        }\n        else if (param == \"color_adjustment\" || param == \"offset_adjustment\")\n        {\n            quint8 value = gradient[param].toUInt(&check);\n            if (!check || value > 0x07)\n            {\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, gradient/%2\").arg(gradient[param].toString()).arg(param)));\n                ok = false;\n            }\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, gradient/%1, not available\").arg(param)));\n            ok = false;\n        }\n    }\n    return ok;\n}\n\nvoid streamPoint(QDataStream &stream, double x, double y)\n{\n    const quint16 rawX = (x >= maxX) ? 4095 : floor(x * 4095 / maxX);\n    const quint16 rawY = (y >= maxY) ? 4095 : floor(y * 4095 / maxY);\n    stream << (quint8) (rawX & 0x0FF);\n    stream << (quint8) (((rawX & 0xF00) >> 8) | ((rawY & 0x00F) << 4));\n    stream << (quint8) ((rawY & 0xFF0) >> 4);\n}\n\n/*! Add a Hue gradient task to the queue.\n\n   \\param task - the task item\n   \\param gradient - the gradient\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskHueGradient(TaskItem &task, QVariantMap &gradient)\n{\n    task.taskType = TaskHueGradient;\n    task.req.setClusterId(HUE_EFFECTS_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x00);\n    task.zclFrame.setManufacturerCode(VENDOR_PHILIPS);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCManufacturerSpecific |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n\n    QVariantList points = gradient[\"points\"].toList();\n    QVariantList point;\n    quint8 style = 0xFF;\n    for (auto &s: styles)\n    {\n        if (gradient[\"style\"] == s.name)\n        {\n            style = s.value;\n            break;\n        }\n    }\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << (quint16) 0x0150; // set gradient\n        stream << (quint16) 0x0004; // transitiontime\n\n        const quint8 nPoints = points.length();\n        stream << (quint8) (1 + 3 * (nPoints + 1));\n        stream << (quint8) (nPoints << 4);\n        stream << (quint8) style;\n        stream << (quint8) 0;\n        stream << (quint8) 0;\n        for (auto &point : points)\n        {\n            QVariantList xy = point.toList();\n            streamPoint(stream, xy[0].toDouble(), xy[1].toDouble());\n        }\n        stream << (quint8) ((gradient[\"segments\"].toUInt() << 3) | gradient[\"color_adjustment\"].toUInt());\n        stream << (quint8) ((gradient[\"offset\"].toUInt() << 3)| gradient[\"offset_adjustment\"].toUInt());\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n    return addTask(task);\n}\n"
        },
        {
          "name": "ias_ace.cpp",
          "type": "blob",
          "size": 12.099609375,
          "content": "\n// TODO remove dependency on plugin\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n#include \"ias_ace.h\"\n#include \"ias_zone.h\"\n\n//  Arm mode command\n//-------------------\n// 0x00 Disarm    \n// 0x01 Arm Day/Home Zones Only\n// 0x02 Arm Night/Sleep Zones Only\n// 0x03 Arm All Zones\n\n//  Arm mode response\n//-------------------\n// 0x00 All Zones Disarmed\n// 0x01 Only Day/Home Zones Armed\n// 0x02 Only Night/Sleep Zones Armed\n// 0x03 All Zones Armed\n// 0x04 Invalid Arm/Disarm Code\n// 0x05 Not ready to arm\n// 0x06 Already disarmed\n\n//   Panel status\n// --------------        \n// 0x00 Panel disarmed (all zones disarmed) and ready to arm\n// 0x01 Armed stay\n// 0x02 Armed night\n// 0x03 Armed away\n// 0x04 Exit delay\n// 0x05 Entry delay\n// 0x06 Not ready to arm\n// 0x07 In alarm\n// 0x08 Arming Stay\n// 0x09 Arming Night\n// 0x0a Arming Away\n\n// Alarm Status\n// ------------\n// 0x00 No alarm\n// 0x01 Burglar\n// 0x02 Fire\n// 0x03 Emergency\n// 0x04 Police Panic\n// 0x05 Fire Panic\n// 0x06 Emergency Panic (i.e., medical issue)\n\n// Audible Notification\n// ----------------------   \n// 0x00 Mute (i.e., no audible notification)\n// 0x01 Default sound\n// 0x80-0xff Manufacturer specific\n\n#define IAS_ACE_ARM_MODE_DISARM                       0x00\n#define IAS_ACE_ARM_MODE_ARM_DAY_HOME_ZONES_ONLY      0x01\n#define IAS_ACE_ARM_MODE_ARM_NIGHT_SLEEP_ZONES_ONLY   0x02\n#define IAS_ACE_ARM_MODE_ARM_ALL_ZONES                0x03\n\n#define IAS_ACE_ARM_NOTF_ALL_ZONES_DISARMED           0x00\n#define IAS_ACE_ARM_NOTF_ONLY_DAY_HOME_ZONES_ARMED    0x01\n#define IAS_ACE_ARM_NOTF_ONLY_NIGHT_SLEEP_ZONES_ARMED 0x02\n#define IAS_ACE_ARM_NOTF_ALL_ZONES_ARMED              0x03\n#define IAS_ACE_ARM_NOTF_INVALID_ARM_DISARM_CODE      0x04\n#define IAS_ACE_ARM_NOTF_NOT_READY_TO_ARM             0x05\n#define IAS_ACE_ARM_NOTF_ALREADY_DISARMED             0x06\n\n// strings mapping directly to IAS_ACE_ARM_MODE_* and IAS_ACE_ARM_NOTF_*\nstatic const std::array<QLatin1String, 7> IAS_ArmResponse = {\n    QLatin1String(\"disarmed\"),\n    QLatin1String(\"armed_stay\"),\n    QLatin1String(\"armed_night\"),\n    QLatin1String(\"armed_away\"),\n    QLatin1String(\"invalid_code\"),\n    QLatin1String(\"not_ready\"),\n    QLatin1String(\"already_disarmed\")\n};\n\nstatic const std::array<QLatin1String, 11> IAS_PanelStates = {\n    QLatin1String(\"disarmed\"),\n    QLatin1String(\"armed_stay\"),\n    QLatin1String(\"armed_night\"),\n    QLatin1String(\"armed_away\"),\n    QLatin1String(\"exit_delay\"),\n    QLatin1String(\"entry_delay\"),\n    QLatin1String(\"not_ready\"),\n    QLatin1String(\"in_alarm\"),\n    QLatin1String(\"arming_stay\"),\n    QLatin1String(\"arming_night\"),\n    QLatin1String(\"arming_away\")\n};\n\nstatic void sendArmResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, quint8 armMode, ApsControllerWrapper &apsCtrlWrapper);\nstatic void sendGetPanelStatusResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, quint8 panelStatus, quint8 secs, ApsControllerWrapper &apsCtrlWrapper);\n\nQLatin1String IAS_PanelStatusToString(quint8 panelStatus)\n{\n    if (panelStatus < IAS_PanelStates.size())\n    {\n        return IAS_PanelStates[panelStatus];\n    }\n\n    return QLatin1String(\"\");\n}\n\nint IAS_PanelStatusFromString(const QString &panelStatus)\n{\n    const auto i = std::find(IAS_PanelStates.cbegin(), IAS_PanelStates.cend(), panelStatus);\n\n    if (i != IAS_PanelStates.cend())\n    {\n        return std::distance(IAS_PanelStates.cbegin(), i);\n    }\n\n    return -1;\n}\n\nstatic quint8 handleArmCommand(AlarmSystem *alarmSys, quint8 armMode, const QString &pinCode, quint64 srcAddress)\n{\n    if (!alarmSys || armMode > IAS_ACE_ARM_MODE_ARM_ALL_ZONES)\n    {\n        return IAS_ACE_ARM_NOTF_NOT_READY_TO_ARM;\n    }\n\n    if (!alarmSys->isValidCode(pinCode, srcAddress))\n    {\n        return IAS_ACE_ARM_NOTF_INVALID_ARM_DISARM_CODE;\n    }\n\n    const quint8 armMode0 = alarmSys->targetArmMode();\n\n    if (armMode0 == IAS_ACE_ARM_MODE_DISARM && armMode == armMode0)\n    {\n        return IAS_ACE_ARM_NOTF_ALREADY_DISARMED;\n    }\n\n    static_assert (IAS_ACE_ARM_MODE_DISARM == AS_ArmModeDisarmed, \"\");\n    static_assert (IAS_ACE_ARM_MODE_ARM_DAY_HOME_ZONES_ONLY == AS_ArmModeArmedStay, \"\");\n    static_assert (IAS_ACE_ARM_MODE_ARM_NIGHT_SLEEP_ZONES_ONLY == AS_ArmModeArmedNight, \"\");\n    static_assert (IAS_ACE_ARM_MODE_ARM_ALL_ZONES == AS_ArmModeArmedAway, \"\");\n\n    if (armMode0 != armMode)\n    {\n        alarmSys->setTargetArmMode(AS_ArmMode(armMode));\n    }\n\n    return armMode;\n}\n\nvoid IAS_IasAceClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, AlarmSystems *alarmSystems, ApsControllerWrapper &apsCtrlWrapper)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    if (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient)\n    {\n        return;\n    }\n\n    Sensor *sensor = plugin->getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAAncillaryControl\"));\n    if (!sensor)\n    {\n        return;\n    }\n\n    bool stateUpdated = false;\n\n    if (zclFrame.commandId() == IAS_ACE_CMD_ARM && zclFrame.payload().size() >= 2)\n    {\n        // [0] arm mode (enum8)\n        const quint8 armMode = quint8(zclFrame.payload().at(0));\n\n        if (armMode > IAS_ACE_ARM_MODE_ARM_ALL_ZONES)\n        {\n            DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX invalid arm mode: %d, skip\\n\", ind.srcAddress().ext(), armMode);\n            return;\n        }\n        \n        quint8 armRsp = IAS_ACE_ARM_NOTF_NOT_READY_TO_ARM;\n\n        // [1] arm/disarm code in payload (pascal string, allowed to be empty, e.g. for keyfobs)\n        QString armCode;\n        if (zclFrame.payload().size() > 2)\n        {\n            int length = zclFrame.payload().at(1);\n            if (length <= zclFrame.payload().size() - 2)\n            {\n                armCode = QString::fromUtf8(zclFrame.payload().constData() + 2, length);\n            }\n            else\n            {\n                armRsp = IAS_ACE_ARM_NOTF_INVALID_ARM_DISARM_CODE;\n                armCode = QLatin1String(\"invalid_code\");\n            }\n        }\n\n        // [2] zone id (uint8, ignore, we don't do anything with it)\n        // const quint8 zoneId = static_cast<quint8>(zclFrame.payload().at(zclFrame.payload().size() - 1));\n        \n        DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX arm command received, arm mode: 0x%02X, code length: %d\\n\", ind.srcAddress().ext(), armMode, armCode.size());\n\n        AlarmSystem *alarmSys = AS_GetAlarmSystemForDevice(ind.srcAddress().ext(), *alarmSystems);\n\n        if (alarmSys)\n        {\n            armRsp = handleArmCommand(alarmSys, armMode, armCode, ind.srcAddress().ext());\n        }\n\n        {\n            ResourceItem *actionItem = sensor->item(RStateAction);\n\n            if (actionItem && armRsp < IAS_ArmResponse.size())\n            {\n                actionItem->setValue(QString(IAS_ArmResponse[armRsp]));\n                enqueueEvent(Event(sensor->prefix(), actionItem->descriptor().suffix, sensor->id(), armMode));\n                stateUpdated = true;\n            }\n        }\n\n        sendArmResponse(ind, zclFrame, armRsp, apsCtrlWrapper);\n    }\n    else if (zclFrame.commandId() == IAS_ACE_CMD_GET_PANEL_STATUS)\n    {\n        quint8 panelStatus = IAS_ACE_PANEL_STATUS_NOT_READY_TO_ARM;\n        quint8 secondsRemaining = 0;\n\n        AlarmSystem *alarmSys = AS_GetAlarmSystemForDevice(ind.srcAddress().ext(), *alarmSystems);\n\n        if (alarmSys)\n        {\n            panelStatus = alarmSys->iasAcePanelStatus();\n\n            if (panelStatus == IAS_ACE_PANEL_STATUS_ENTRY_DELAY || panelStatus == IAS_ACE_PANEL_STATUS_EXIT_DELAY)\n            {\n                secondsRemaining = quint8(alarmSys->secondsRemaining());\n            }\n        }\n\n        sendGetPanelStatusResponse(ind, zclFrame, panelStatus, secondsRemaining, apsCtrlWrapper);\n    }\n    else if (zclFrame.commandId() >= IAS_ACE_CMD_EMERGENCY && zclFrame.commandId() <= IAS_ACE_CMD_PANIC)\n    {\n        ResourceItem *actionItem = sensor->item(RStateAction);\n\n        const std::array<QLatin1String, 3> cmds = {\n            QLatin1String(\"emergency\"),\n            QLatin1String(\"fire\"),\n            QLatin1String(\"panic\")\n        };\n\n        const quint8 index = zclFrame.commandId() - IAS_ACE_CMD_EMERGENCY;\n\n        if (actionItem && index < cmds.size())\n        {\n            actionItem->setValue(QString(cmds[index]));\n            enqueueEvent(Event(sensor->prefix(), actionItem->descriptor().suffix, sensor->id(), zclFrame.commandId()));\n            stateUpdated = true;\n        }\n    }\n    else\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX unhandled command: 0x%02X\\n\", ind.srcAddress().ext(), zclFrame.commandId());\n    }\n    \n    if (stateUpdated)\n    {\n        sensor->updateStateTimestamp();\n        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        plugin->updateSensorEtag(sensor);\n        sensor->setNeedSaveDatabase(true);\n        plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n    }\n}\n\nstatic void sendArmResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, quint8 armMode, ApsControllerWrapper &apsCtrlWrapper)\n{\n    DBG_Assert(armMode <= IAS_ACE_ARM_NOTF_ALREADY_DISARMED);\n\n    if (armMode > IAS_ACE_ARM_NOTF_ALREADY_DISARMED)\n    {\n        return;\n    }\n\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n\n    req.setProfileId(ind.profileId());\n    req.setClusterId(ind.clusterId());\n    req.setDstAddressMode(ind.srcAddressMode());\n    req.dstAddress() = ind.srcAddress();\n    req.setDstEndpoint(ind.srcEndpoint());\n    req.setSrcEndpoint(plugin->endpoint());\n\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(IAS_ACE_CMD_ARM_RESPONSE);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionServerToClient |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << armMode;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX failed to send IAS ACE arm reponse.\\n\", ind.srcAddress().ext());\n    }\n}\n\nstatic void sendGetPanelStatusResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, quint8 panelStatus, quint8 secs, ApsControllerWrapper &apsCtrlWrapper)\n{\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n\n    req.setProfileId(ind.profileId());\n    req.setClusterId(ind.clusterId());\n    req.setDstAddressMode(ind.srcAddressMode());\n    req.dstAddress() = ind.srcAddress();\n    req.setDstEndpoint(ind.srcEndpoint());\n    req.setSrcEndpoint(plugin->endpoint());\n\n    DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX panel status response: 0x%02X\\n\", ind.srcAddress().ext(), panelStatus);\n\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(IAS_ACE_CMD_GET_PANEL_STATUS_RESPONSE);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                deCONZ::ZclFCDirectionServerToClient); // deCONZ::ZclFCDisableDefaultResponse\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        stream << (quint8) panelStatus; // Panel status\n        stream << (quint8) secs; // Seconds Remaining \n        stream << (quint8) 0x01; // Audible Notification\n\n        if (panelStatus == IAS_ACE_PANEL_STATUS_IN_ALARM)\n        {\n            // TODO make this dynamic and managed by alarm system\n            stream << (quint8) 0x03; // Alarm status, emergency\n        }\n        else\n        {\n            stream << (quint8) 0x00; // Alarm status\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ACE] 0x%016llX failed to send IAS ACE get panel reponse.\\n\", ind.srcAddress().ext());\n    }\n}\n"
        },
        {
          "name": "ias_ace.h",
          "type": "blob",
          "size": 1.9189453125,
          "content": "#ifndef IAS_ACE_H\n#define IAS_ACE_H\n\n#include <QString>\n\n// server send\n#define IAS_ACE_CMD_ARM_RESPONSE 0x00\n#define IAS_ACE_CMD_GET_ZONE_ID_MAP_RESPONSE 0x01\n#define IAS_ACE_CMD_GET_ZONE_INFORMATION_RESPONSE 0x02\n#define IAS_ACE_CMD_ZONE_STATUS_CHANGED 0x03\n#define IAS_ACE_CMD_PANEL_STATUS_CHANGED 0x04\n#define IAS_ACE_CMD_GET_PANEL_STATUS_RESPONSE 0x05\n#define IAS_ACE_CMD_SET_BYPASSED_ZONE_LIST 0x06\n#define IAS_ACE_CMD_BYPASS_RESPONSE 0x07\n#define IAS_ACE_CMD_GET_ZONE_STATUS_RESPONSE 0x08\n// server receive\n#define IAS_ACE_CMD_ARM 0x00\n#define IAS_ACE_CMD_BYPASS 0x01\n#define IAS_ACE_CMD_EMERGENCY 0x02\n#define IAS_ACE_CMD_FIRE 0x03\n#define IAS_ACE_CMD_PANIC 0x04\n#define IAS_ACE_CMD_GET_ZONE_ID_MAP 0x05\n#define IAS_ACE_CMD_GET_ZONE_INFORMATION 0x06\n#define IAS_ACE_CMD_GET_PANEL_STATUS 0x07\n#define IAS_ACE_CMD_GET_BYPASSED_ZONE_LIST 0x08\n#define IAS_ACE_CMD_GET_ZONE_STATUS 0x09\n\n#define IAS_ACE_PANEL_STATUS_PANEL_DISARMED           0x00\n#define IAS_ACE_PANEL_STATUS_ARMED_STAY               0x01\n#define IAS_ACE_PANEL_STATUS_ARMED_NIGHT              0x02\n#define IAS_ACE_PANEL_STATUS_ARMED_AWAY               0x03\n#define IAS_ACE_PANEL_STATUS_EXIT_DELAY               0x04\n#define IAS_ACE_PANEL_STATUS_ENTRY_DELAY              0x05\n#define IAS_ACE_PANEL_STATUS_NOT_READY_TO_ARM         0x06\n#define IAS_ACE_PANEL_STATUS_IN_ALARM                 0x07\n#define IAS_ACE_PANEL_STATUS_ARMING_STAY              0x08\n#define IAS_ACE_PANEL_STATUS_ARMING_NIGHT             0x09\n#define IAS_ACE_PANEL_STATUS_ARMING_AWAY              0x0a\n\nnamespace deCONZ {\n    class ApsDataIndication;\n    class ZclFrame;\n}\n\nclass AlarmSystems;\nclass ApsControllerWrapper;\n\nQLatin1String IAS_PanelStatusToString(quint8 panelStatus);\nint IAS_PanelStatusFromString(const QString &panelStatus);\nvoid IAS_IasAceClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, AlarmSystems *alarmSystems, ApsControllerWrapper &apsCtrlWrapper);\n\n#endif // IAS_ACE_H\n"
        },
        {
          "name": "ias_zone.cpp",
          "type": "blob",
          "size": 27.83203125,
          "content": "/*\n * Copyright (c) 2017-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"device_descriptions.h\"\n#include \"ias_zone.h\"\n\n/*\n    IAS Zone Enrollment is handled in a per device state machine.\n    The actual state is managed via RConfigEnrolled as state variable.\n    State timeouts are based on the ResourceItem::lastSet() timestamp.\n\n    A IAS device is enrolled if:\n\n      1. CIE address written\n      2. Zone state = 1\n      3. Both values are verified by read\n\n    The state machine ensures all tasks are done and recovers automatically\n    from any errors which might happen.\n\n    The state machine is described in following PlantUML diagram,\n    and can be displayed with online PlantUML viewer: http://www.plantuml.com/plantuml/uml\n*/\n\n/*\n\n@startuml\nhide empty description\nstate Init\nstate \"Read Attributes\" as Read\nstate \"Wait Read Response\" as WaitRead\nstate \"Write CIE Address\" as WriteCieAddr\nstate \"Wait Write Response\" as WaitWriteCieAddr\nstate ReadRsp <<choice>>\nstate \"Delay Enroll\" as DelayEnroll\nstate \"Enroll\" as Enroll\nstate \"Wait Enroll\" as WaitEnroll\n\n\n\n[*] --> Init\nInit : Mark CIE Address and\nInit : Zone State unknown.\n\nInit --> Read\nRead : CIE Address\nRead : Zone State\nRead --> WaitRead :  Command Send\nRead --> Read\n\nWaitRead --> Init: 8 sec. Timeout\\nError\nWaitRead --> ReadRsp : Read Attributes\\nResponse\n\nReadRsp --> WriteCieAddr : Invalid CIE Address\nReadRsp --> DelayEnroll : Valid CIE Address\\nZone State = 0\nReadRsp --> Enrolled : Valid CIE Address\\nZone State = 1\n\nDelayEnroll --> Enroll : After 5 sec. or\\nReceiving\\nEnroll Request\nEnroll --> WaitEnroll : Command Send\nEnroll --> Enroll\nWaitEnroll --> Read : After 2 sec.\n\nWriteCieAddr --> WaitWriteCieAddr : Command Send\nWriteCieAddr --> WriteCieAddr\n\nWaitWriteCieAddr --> Read : Write Attribute\\nResponse\nWaitWriteCieAddr --> Init: 8 sec. Timeout\\nError\n\nEnrolled --> [*]\n@enduml\n\n*/\n\n/*! Helper to set IAS device state and print debug information on state changes.\n */\n#define IAS_SetState(sensor, item, state) IAS_SetState1(sensor, item, state, #state)\nstatic quint32 IAS_SetState1(const Sensor *sensor, ResourceItem *item, quint32 state, const char *strState)\n{\n    DBG_Assert(item);\n\n    if (item->toNumber() != state)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX set state: %s (%u)\\n\", sensor->address().ext(), strState, state);\n        item->setValue(state);\n    }\n\n    return state;\n}\n\n/*! Sanity function to ensure IAS state variable has a valid value.\n    A invalid value will be set to IAS_STATE_INIT.\n */\nstatic void IAS_EnsureValidState(ResourceItem *itemIasState)\n{\n    DBG_Assert(itemIasState);\n    if (itemIasState && itemIasState->toNumber() >= IAS_STATE_MAX)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - invalid state: %u, set to IAS_STATE_INIT\\n\", itemIasState->toNumber());\n        itemIasState->setValue(IAS_STATE_INIT);\n    }\n}\n\n/*! Configure presence restoration timer */\nstatic void IAS_QueueRestorePresence(Sensor *const sensor, const ResourceItem &presence)\n{\n    const NodeValue &val = sensor->getZclValue(IAS_ZONE_CLUSTER_ID, IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID);\n    const ResourceItem *const duration = sensor->item(RConfigDuration);\n    if (val.maxInterval > 0)\n    {\n        sensor->durationDue = presence.lastSet().addSecs(val.maxInterval);\n    }\n    else if (duration && duration->toNumber() > 0)\n    {\n        sensor->durationDue = presence.lastSet().addSecs(duration->toNumber());\n    }\n}\n\n/*! Check whether a sensor sends Zone Status Change when an alarm is reset */\nstatic bool IAS_SensorSendsRestoreReports(const Sensor &sensor, const quint16 zoneStatus)\n{\n    if (zoneStatus & STATUS_RESTORE_REP)\n    {\n        return true;\n    }\n    const std::array<const QLatin1String, 5> supportedSensors = {\n        QLatin1String(\"TY0202\"),\n        QLatin1String(\"MS01\"),\n        QLatin1String(\"MSO1\"),\n        QLatin1String(\"ms01\"),\n        QLatin1String(\"66666\")\n    };\n    return std::find(supportedSensors.cbegin(), supportedSensors.cend(), sensor.modelId()) != supportedSensors.cend();\n}\n\n/*! Handle packets related to the ZCL IAS Zone cluster.\n    \\param ind - The APS level data indication containing the ZCL packet\n    \\param zclFrame - The actual ZCL frame which holds the IAS zone server command\n */\nvoid DeRestPluginPrivate::handleIasZoneClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (!(zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient))\n    {\n        return;\n    }\n    \n    DBG_Printf(DBG_IAS, \"[IAS ZONE] - Address 0x%016llX, Payload %s, Command 0x%02X\\n\", ind.srcAddress().ext(), qPrintable(zclFrame.payload().toHex()), zclFrame.commandId());\n\n    // during setup the IAS Zone type will be read\n    // start to proceed discovery here\n    if (searchSensorsState == SearchSensorsActive)\n    {\n        if (!fastProbeTimer->isActive())\n        {\n            fastProbeTimer->start(5);\n        }\n    }\n\n    Sensor *sensor = nullptr;\n    ResourceItem *itemIasState = nullptr;\n    ResourceItem *itemPending = nullptr;\n\n    for (auto &s : sensors)\n    {\n        if (!(s.address().ext() == ind.srcAddress().ext() &&\n              s.fingerPrint().endpoint == ind.srcEndpoint() &&\n              s.fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID) &&\n              s.deletedState() == Sensor::StateNormal))\n        {\n            continue;\n        }\n        \n        //check if the device have itemIasState and itemPending, because a device can have many sensor and not this field on all\n        itemIasState = s.item(RConfigEnrolled);\n        itemPending = s.item(RConfigPending);\n\n        if (!itemIasState || !itemPending)\n        {\n            continue;\n        }\n\n        sensor = &s;\n    }\n\n    DBG_Assert(itemIasState);\n    DBG_Assert(itemPending);\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX No IAS sensor found for endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    IAS_EnsureValidState(itemIasState);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    bool isWriteResponse = false;\n    bool isClusterCmd = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclWriteAttributesResponseId)\n    {\n        isWriteResponse = true;\n    }\n    if ((zclFrame.frameControl() & 0x09) == (deCONZ::ZclFCDirectionServerToClient | deCONZ::ZclFCClusterCommand))\n    {\n        isClusterCmd = true;\n    }\n\n    // Read ZCL Reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        if (isReadAttr)\n        {\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Read attributes response:\\n\", sensor->address().ext());\n        }\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Read attribute 0x%04X status: 0x%02X\\n\", sensor->address().ext(), attrId, status);\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            DBG_Assert(stream.status() == QDataStream::Ok);\n\n            switch (attrId)\n            {\n                case IAS_ZONE_STATE:\n                {\n                    const quint8 iasZoneState = attr.numericValue().u8;\n\n                    if (iasZoneState == 1)\n                    {\n                        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX   -> IAS Zone State: enrolled.\\n\", sensor->address().ext());\n                        R_ClearFlags(itemPending, R_PENDING_ENROLL_RESPONSE);\n                    }\n                    else if (iasZoneState == 0)\n                    {\n                        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX   -> IAS Zone State: NOT enrolled.\\n\", sensor->address().ext());\n                        R_SetFlags(itemPending, R_PENDING_ENROLL_RESPONSE);\n                    }\n\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), IAS_ZONE_CLUSTER_ID, attrId, attr.numericValue());\n                }\n                    break;\n\n                case IAS_ZONE_TYPE:\n                {\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), IAS_ZONE_CLUSTER_ID, attrId, attr.numericValue());\n                }\n                    break;\n\n                case IAS_ZONE_STATUS:\n                {\n                    if (!DEV_TestStrict())\n                    {\n                        const quint16 zoneStatus = attr.numericValue().u16;   // might be reported or received via CMD_STATUS_CHANGE_NOTIFICATION\n\n                        processIasZoneStatus(sensor, zoneStatus, updateType);\n                    }\n\n                }\n                    break;\n\n                case IAS_CIE_ADDRESS:\n                {\n                    const quint64 iasCieAddress = attr.numericValue().u64;\n\n                    if (iasCieAddress != 0 && iasCieAddress != 0xFFFFFFFFFFFFFFFF)\n                    {\n                        DBG_Assert(iasCieAddress == apsCtrl->getParameter(deCONZ::ParamMacAddress));\n                        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX   -> IAS CIE address = 0x%016llX: already written.\\n\", sensor->address().ext(), iasCieAddress);\n                        R_ClearFlags(itemPending, R_PENDING_WRITE_CIE_ADDRESS);\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX   -> IAS CIE address = 0x%016llX: NOT written.\\n\", sensor->address().ext());\n                        R_SetFlags(itemPending, R_PENDING_WRITE_CIE_ADDRESS);\n                    }\n\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), IAS_ZONE_CLUSTER_ID, attrId, attr.numericValue());\n                }\n                    break;\n\n                default:\n                    break;\n\n            }\n        }\n\n        if (itemIasState->toNumber() == IAS_STATE_WAIT_READ)\n        {\n            // Read attributes response, decide next state.\n            if (R_HasFlags(itemPending, R_PENDING_WRITE_CIE_ADDRESS)) // 1. task to be setup\n            {\n                IAS_SetState(sensor, itemIasState, IAS_STATE_WRITE_CIE_ADDR);\n            }\n            else if (R_HasFlags(itemPending, R_PENDING_ENROLL_RESPONSE)) // 2. task to be setup\n            {\n                IAS_SetState(sensor, itemIasState, IAS_STATE_DELAY_ENROLL);\n            }\n            else\n            {\n                // Valid CIE Address and Zone State = 1 --> finished\n                IAS_SetState(sensor, itemIasState, IAS_STATE_ENROLLED);\n                sensor->setNeedSaveDatabase(true);\n            }\n        }\n\n        checkIasEnrollmentStatus(sensor);\n    }\n\n    // Read ZCL Cluster Command Response\n    if (isClusterCmd && zclFrame.commandId() == CMD_STATUS_CHANGE_NOTIFICATION)\n    {\n        if (!DEV_TestStrict())\n        {\n            quint16 zoneStatus;\n            quint8 extendedStatus;\n            quint8 zoneId;\n            quint16 delay;\n            stream >> zoneStatus;\n            stream >> extendedStatus; // reserved, set to 0\n            stream >> zoneId;\n            stream >> delay;\n            DBG_Assert(stream.status() == QDataStream::Ok);\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Status Change, status: 0x%04X, zoneId: %u, delay: %u\\n\", sensor->address().ext(), zoneStatus, zoneId, delay);\n\n            processIasZoneStatus(sensor, zoneStatus, NodeValue::UpdateByZclReport);\n        }\n        \n        checkIasEnrollmentStatus(sensor);\n    }\n    else if (isClusterCmd && zclFrame.commandId() == CMD_ZONE_ENROLL_REQUEST)\n    {\n        quint16 zoneType;\n        quint16 manufacturer;\n\n        stream >> zoneType;\n        stream >> manufacturer;\n        DBG_Assert(stream.status() == QDataStream::Ok);\n\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Zone Enroll Request, zone type: 0x%04X, manufacturer: 0x%04X\\n\", sensor->address().ext(), zoneType, manufacturer);\n\n        if (itemIasState->toNumber() == IAS_STATE_DELAY_ENROLL ||\n            itemIasState->toNumber() == IAS_STATE_ENROLL) // This state might still be active if previous send didn't work\n        {\n            // End waiting and send Enroll Response within state machine.\n            IAS_SetState(sensor, itemIasState, IAS_STATE_ENROLL);\n            checkIasEnrollmentStatus(sensor);\n        }\n        else\n        {\n            // Send independend of state to don't interfere with state machine.\n            sendIasZoneEnrollResponse(ind, zclFrame);\n        }\n        return; // don't trigger ZCL Default Response\n    }\n\n    // ZCL Write Attributes Response\n    if (isWriteResponse)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Write of IAS CIE address done.\\n\", sensor->address().ext());\n\n        if (itemIasState->toNumber() == IAS_STATE_WAIT_WRITE_CIE_ADDR)\n        {\n            // read attributes again to see if it worked\n            IAS_SetState(sensor, itemIasState, IAS_STATE_READ);\n        }\n\n        checkIasEnrollmentStatus(sensor);\n    }\n}\n\n/*! Processes the received IAS zone status value.\n    \\param sensor - Sensor containing the IAS zone cluster\n    \\param zoneStatus - IAS zone status value\n    \\param updateType - Update type\n */\nvoid DeRestPluginPrivate::processIasZoneStatus(Sensor *sensor, quint16 zoneStatus, NodeValue::UpdateType updateType)\n{\n    ResourceItem *item2;\n\n    // Valid for all devices type\n    item2 = sensor->item(RStateLowBattery);\n    if (item2)\n    {\n        bool battery = (zoneStatus & STATUS_BATTERY) ? true : false;\n        item2->setValue(battery);\n        enqueueEvent(Event(RSensors, RStateLowBattery, sensor->id(), item2));\n    }\n\n    item2 = sensor->item(RStateTampered);\n    if (item2)\n    {\n        bool tamper = (zoneStatus & STATUS_TAMPER) ? true : false;\n        item2->setValue(tamper);\n        enqueueEvent(Event(RSensors, RStateTampered, sensor->id(), item2));\n    }\n    \n    item2 = sensor->item(RConfigReachable);\n    if (item2 && !item2->toBool())\n    {\n        item2->setValue(true);\n        enqueueEvent(Event(RSensors, RConfigReachable, sensor->id(), item2));\n    }\n    \n    const char *attr = nullptr;\n    if (sensor->type() == QLatin1String(\"ZHAAlarm\"))\n    {\n        attr = RStateAlarm;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHACarbonMonoxide\"))\n    {\n        attr = RStateCarbonMonoxide;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHAFire\"))\n    {\n        attr = RStateFire;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHAOpenClose\"))\n    {\n        attr = RStateOpen;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHAPresence\"))\n    {\n        attr = RStatePresence;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHAVibration\"))\n    {\n        attr = RStateVibration;\n    }\n    else if (sensor->type() == QLatin1String(\"ZHAWater\"))\n    {\n        attr = RStateWater;\n    }\n\n    ResourceItem *item = nullptr;\n    if (attr)\n    {\n        item = sensor->item(attr);\n    }\n\n    if (item)\n    {\n        bool alarm = (zoneStatus & (STATUS_ALARM1 | STATUS_ALARM2)) ? true : false;\n        item->setValue(alarm);\n        enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor->id(), item));\n\n        // TODO DDF DDF_AnnoteZclParseCommand()\n        DDF_AnnoteZclParse(sensor, item, 0, IAS_ZONE_CLUSTER_ID, IAS_ZONE_STATUS, \"Item.val = (Attr.val & 0x3) != 0\");\n\n        item2 = sensor->item(RStateTest);\n        if (item2)\n        {\n            bool test = (zoneStatus & STATUS_TEST) ? true : false;\n            item2->setValue(test);\n            enqueueEvent(Event(RSensors, RStateTest, sensor->id(), item2));\n        }\n\n        deCONZ::NumericUnion num = {0};\n        num.u16 = zoneStatus;\n        sensor->setZclValue(updateType, sensor->fingerPrint().endpoint, IAS_ZONE_CLUSTER_ID, IAS_ZONE_CLUSTER_ATTR_ZONE_STATUS_ID, num);\n\n        if (alarm && item->descriptor().suffix == RStatePresence)\n        {\n            if (!IAS_SensorSendsRestoreReports(*sensor, zoneStatus)) {\n                IAS_QueueRestorePresence(sensor, *item);\n            }\n        }\n    }\n    \n    sensor->updateStateTimestamp();\n    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n\n    updateEtag(sensor->etag);\n    updateEtag(gwConfigEtag);\n    sensor->setNeedSaveDatabase(true);\n    queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n    \n}\n\n/*! Sends IAS Zone enroll response to IAS Zone server.\n    \\param ind - The APS level data indication containing the ZCL packet\n    \\param zclFrame - The actual ZCL frame which holds the IAS Zone enroll request\n */\nbool DeRestPluginPrivate::sendIasZoneEnrollResponse(Sensor *sensor)\n{\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n\n    req.setProfileId(sensor->fingerPrint().profileId);\n    req.setClusterId(IAS_ZONE_CLUSTER_ID); // todo check for other ias clusters\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.dstAddress() = sensor->address();\n    req.setDstEndpoint(sensor->fingerPrint().endpoint);\n    req.setSrcEndpoint(endpoint());\n\n    outZclFrame.setSequenceNumber(zclSeq++);\n    outZclFrame.setCommandId(CMD_ZONE_ENROLL_RESPONSE);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint8 code = 0x00; // success\n        quint8 zoneId = IAS_DEFAULT_ZONE;\n\n        stream << code;\n        stream << zoneId;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Send Zone Enroll Response, zcl.seq: %u\\n\", sensor->address().ext(), outZclFrame.sequenceNumber());\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Failed sending Zone Enroll Response\\n\", sensor->address().ext());\n        return false;\n    }\n\n    return true;\n}\n\n/*! Sends IAS Zone enroll response to IAS Zone server.\n    \\param ind - The APS level data indication containing the ZCL packet\n    \\param zclFrame - The actual ZCL frame which holds the IAS Zone enroll request\n */\nbool DeRestPluginPrivate::sendIasZoneEnrollResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n\n    req.setProfileId(ind.profileId());\n    req.setClusterId(ind.clusterId());\n    req.setDstAddressMode(ind.srcAddressMode());\n    req.dstAddress() = ind.srcAddress();\n    req.setDstEndpoint(ind.srcEndpoint());\n    req.setSrcEndpoint(endpoint());\n\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(CMD_ZONE_ENROLL_RESPONSE);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint8 code = 0x00; // success\n        quint8 zoneId = IAS_DEFAULT_ZONE;\n\n        stream << code;\n        stream << zoneId;\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Send Zone Enroll Response, zcl.seq: %u\\n\", ind.srcAddress().ext(), zclFrame.sequenceNumber());\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Failed sending Zone Enroll Response\\n\", ind.srcAddress().ext());\n        return false;\n    }\n\n    return true;\n}\n\n/*! Drives the IAS Zone Enrollment state machine.\n\n    This handler can be called at any time, e.g. after receiving a command or from a timer.\n    \\param sensor - Sensor containing the IAS zone cluster\n */\nvoid DeRestPluginPrivate::checkIasEnrollmentStatus(Sensor *sensor)\n{\n    ResourceItem *itemIasState = sensor->item(RConfigEnrolled); // holds per device IAS state variable\n\n    if (!itemIasState)\n    {\n        return;\n    }\n\n    ResourceItem *itemPending = sensor->item(RConfigPending);\n    if (!itemPending)\n    {\n        // All IAS devices should have config.enrolled and config.pending items.\n        // Bail out early for non IAS devices.\n        return;\n    }\n\n    IAS_EnsureValidState(itemIasState);\n    quint32 iasState = itemIasState->toNumber();\n\n    if (iasState == IAS_STATE_ENROLLED)\n    {\n        DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor (%s) is enrolled.\\n\", sensor->address().ext(), qPrintable(sensor->type()));\n        return; // already enrolled nothing todo\n    }\n\n    if (sensor->fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID))\n    {\n        const auto now = QDateTime::currentDateTime();\n\n        if (iasState != IAS_STATE_WAIT_READ) // don't print in WAIT_READ since it's too noisy\n        {\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor ID: %s\\n\", sensor->address().ext(), qPrintable(sensor->uniqueId()));\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor type: %s\\n\", sensor->address().ext(), qPrintable(sensor->type()));\n\n            const NodeValue val = sensor->getZclValue(IAS_ZONE_CLUSTER_ID, IAS_ZONE_STATE);\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor zone state value: %d\\n\", sensor->address().ext(), val.value.u8);\n\n            const NodeValue val1 = sensor->getZclValue(IAS_ZONE_CLUSTER_ID, IAS_CIE_ADDRESS);\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor IAS CIE address: 0x%016llX\\n\", sensor->address().ext(), val1.value.u64);\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor config pending value: %d\\n\", sensor->address().ext(), itemPending->toNumber());\n        }\n\n        if (iasState == IAS_STATE_INIT)\n        {\n            // At the beginning we don't know device values of CIE address and Zone state.\n            // The device might already be enrolled, which will be verified by IAS_STATE_READ.\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor init enrollment.\\n\", sensor->address().ext());\n            R_SetFlags(itemPending, R_PENDING_ENROLL_RESPONSE | R_PENDING_WRITE_CIE_ADDRESS);\n            iasState = IAS_SetState(sensor, itemIasState, IAS_STATE_READ);\n        }\n        else if (iasState == IAS_STATE_DELAY_ENROLL)\n        {\n            // Some devices don't send an Enroll Request.\n            // Wait a few seconds, and if no Enroll Request is received move on to IAS_STATE_ENROLL\n            // to send an unsoliticed Enroll Response.\n            const auto dt = itemIasState->lastSet().secsTo(now);\n\n            if (dt > 5)\n            {\n                DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX initiate unsoliticed enroll response after %d seconds delay.\\n\", sensor->address().ext(), static_cast<int>(dt));\n                iasState = IAS_SetState(sensor, itemIasState, IAS_STATE_ENROLL);\n            }\n        }\n        else if (iasState == IAS_STATE_WAIT_ENROLL)\n        {\n            // After sending a Enroll Response, wait a few seconds and read the attributes again to verify.\n            const auto dt = itemIasState->lastSet().secsTo(now);\n\n            if (dt > 2)\n            {\n                // Read attributes again to verify if it worked.\n                iasState = IAS_SetState(sensor, itemIasState, IAS_STATE_READ);\n            }\n        }\n\n        if (!R_HasFlags(itemPending, R_PENDING_ENROLL_RESPONSE) && !R_HasFlags(itemPending, R_PENDING_WRITE_CIE_ADDRESS))\n        {\n            if (iasState != IAS_STATE_ENROLLED) // everything seems to be done, finish here\n            {\n                IAS_SetState(sensor, itemIasState, IAS_STATE_ENROLLED);\n                sensor->setNeedSaveDatabase(true);\n            }\n            return;\n        }\n\n        if (iasState == IAS_STATE_READ)\n        {\n            DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Read IAS zone state and CIE address...\\n\", sensor->address().ext());\n\n            if (readAttributes(sensor, sensor->fingerPrint().endpoint, IAS_ZONE_CLUSTER_ID, {IAS_ZONE_STATE, IAS_CIE_ADDRESS}))\n            {\n                queryTime = queryTime.addSecs(1);\n                IAS_SetState(sensor, itemIasState, IAS_STATE_WAIT_READ);\n            }\n            else\n            {\n                // Remain in IAS_STATE_READ and try again in next invocation.\n                DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Failed to send read attributes.\\n\", sensor->address().ext());\n            }\n        }\n        else if (iasState == IAS_STATE_WRITE_CIE_ADDR)\n        {\n            if (writeIasCieAddress(sensor))\n            {\n                IAS_SetState(sensor, itemIasState, IAS_STATE_WAIT_WRITE_CIE_ADDR);\n            }\n            // On error remain in IAS_STATE_WRITE_CIE_ADDR and try again in next invocation.\n        }\n        else if (iasState == IAS_STATE_ENROLL)\n        {\n            if (sendIasZoneEnrollResponse(sensor))\n            {\n                IAS_SetState(sensor, itemIasState, IAS_STATE_WAIT_ENROLL);\n            }\n            // On error remain in IAS_STATE_ENROLL and try again in next invocation.\n        }\n        else if (iasState == IAS_STATE_WAIT_READ ||\n                 iasState == IAS_STATE_WAIT_WRITE_CIE_ADDR)\n        {\n            const auto dt = itemIasState->lastSet().secsTo(now);\n\n            if (dt > 8) // Wait up to 8 seconds, because next mac poll might take 7.x seconds until max transactions expires.\n            {\n                DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX timeout after %d seconds, state: %d, retry...\\n\", sensor->address().ext(), static_cast<int>(dt), iasState);\n                IAS_SetState(sensor, itemIasState, IAS_STATE_INIT);\n            }\n            else\n            {\n                DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Sensor (%s) enrollment pending... since %d seconds.\\n\", sensor->address().ext(), qPrintable(sensor->type()), static_cast<int>(dt));\n            }\n        }\n    }\n}\n\n/*! Write IAS CIE address attribute for a node.\n    \\param sensor - Sensor containing the IAS zone cluster\n */\nbool DeRestPluginPrivate::writeIasCieAddress(Sensor *sensor)\n{\n    ResourceItem *item = nullptr;\n    item = sensor->item(RConfigPending);\n\n    DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Send write IAS CIE address.\\n\", sensor->address().ext());\n\n    if (sensor->fingerPrint().hasInCluster(IAS_ZONE_CLUSTER_ID) && item && R_HasFlags(item, R_PENDING_WRITE_CIE_ADDRESS))\n    {\n        // write CIE address needed for some IAS Zone devices\n        const quint64 iasCieAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n        deCONZ::ZclAttribute attribute(IAS_CIE_ADDRESS, deCONZ::ZclIeeeAddress, QLatin1String(\"CIE address\"), deCONZ::ZclReadWrite, false);\n        attribute.setValue(iasCieAddress);\n\n        if (writeAttribute(sensor, sensor->fingerPrint().endpoint, IAS_ZONE_CLUSTER_ID, attribute, 0))\n        {\n            return true;\n        }\n    }\n\n    DBG_Printf(DBG_IAS, \"[IAS ZONE] - 0x%016llX Failed sending write IAS CIE address.\\n\", sensor->address().ext());\n\n    return false;\n}\n"
        },
        {
          "name": "ias_zone.h",
          "type": "blob",
          "size": 1.134765625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef IAS_ZONE_H\n#define IAS_ZONE_H\n\n#define IAS_ZONE_CLUSTER_ID 0x0500\n#define IAS_DEFAULT_ZONE    100\n\n// server send\n#define CMD_STATUS_CHANGE_NOTIFICATION 0x00\n#define CMD_ZONE_ENROLL_REQUEST        0x01\n// server receive\n#define CMD_ZONE_ENROLL_RESPONSE       0x00\n\n// Zone status flags\n#define STATUS_ALARM1         0x0001\n#define STATUS_ALARM2         0x0002\n#define STATUS_TAMPER         0x0004\n#define STATUS_BATTERY        0x0008\n#define STATUS_SUPERVISION    0x0010\n#define STATUS_RESTORE_REP    0x0020\n#define STATUS_TROUBLE        0x0040\n#define STATUS_AC_MAINS       0x0080\n#define STATUS_TEST           0x0100\n#define STATUS_BATTERY_DEFECT 0x0200\n\n// Attributes\n#define IAS_ZONE_STATE        0x0000\n#define IAS_ZONE_TYPE         0x0001\n#define IAS_ZONE_STATUS       0x0002\n#define IAS_CIE_ADDRESS       0x0010\n#define IAS_ZONE_ID           0x0011\n\n#endif // IAS_ZONE_H\n"
        },
        {
          "name": "identify.cpp",
          "type": "blob",
          "size": 3.5625,
          "content": "/*\n * Copyright (c) 2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n\n#define IDENTIFY_COMMAND_IDENTIFY_QUERY          0x01\n#define IDENTIFY_COMMAND_IDENTIFY_QUERY_RESPONSE 0x00\n\nvoid DeRestPluginPrivate::handleIdentifyClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n\n    if (zclFrame.commandId() == IDENTIFY_COMMAND_IDENTIFY_QUERY &&\n        zclFrame.isClusterCommand() &&\n        (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient) == 0)\n    {\n        {   // Aqara Opple switches send identify query command when not configured for using Multistate Input Cluster\n            // Note they behave differently when paired to coordinator vs. router\n            auto *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), 0x01);\n\n            if (sensor && sensor->modelId().endsWith(QLatin1String(\"86opcn01\")))\n            {\n                auto *item = sensor->item(RConfigPending);\n                if (item /*&& (item->toNumber() & R_PENDING_MODE)*/)\n                {\n                    // Aqara Opple switches need to be configured to send proper button events\n                    // send the magic word\n                    DBG_Printf(DBG_INFO, \"Write Aqara Opple switch 0x%016llX mode attribute 0x0009 = 1\\n\", ind.srcAddress().ext());\n                    deCONZ::ZclAttribute attr(0x0009, deCONZ::Zcl8BitUint, QLatin1String(\"mode\"), deCONZ::ZclReadWrite, false);\n                    attr.setValue(static_cast<quint64>(1));\n                    writeAttribute(sensor, 0x01, 0xFCC0, attr, VENDOR_XIAOMI);\n                    item->setValue(item->toNumber() & ~R_PENDING_MODE);\n                }\n                return;\n            }\n\n            if (permitJoinFlag)\n            {\n                // send Idendify Query Response if requested during pairing\n                deCONZ::ApsDataRequest req;\n                deCONZ::ZclFrame outZclFrame;\n\n                req.dstAddress() = ind.srcAddress();\n                req.setDstAddressMode(deCONZ::ApsExtAddress);\n                req.setClusterId(ind.clusterId());\n                req.setProfileId(ind.profileId());\n                req.setDstEndpoint(ind.srcEndpoint());\n                req.setSrcEndpoint(endpoint());\n\n                outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n                outZclFrame.setCommandId(IDENTIFY_COMMAND_IDENTIFY_QUERY_RESPONSE);\n\n\n                outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                            deCONZ::ZclFCDirectionServerToClient |\n                                            deCONZ::ZclFCDisableDefaultResponse);\n\n                { // payload\n                    QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n                    stream.setByteOrder(QDataStream::LittleEndian);\n\n                    stream << quint16(60); // our identify time\n                }\n\n                { // ZCL frame\n                    QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    outZclFrame.writeToStream(stream);\n                }\n\n                if (apsCtrlWrapper.apsdeDataRequest(req) == deCONZ::Success)\n                {\n                    DBG_Printf(DBG_INFO, \"send identify query response to 0x%016llX\\n\", ind.srcAddress().ext());\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ikea-ota-download.py",
          "type": "blob",
          "size": 0.763671875,
          "content": "#!/usr/bin/env python\n\"\"\"\nSnipped to download current IKEA ZLL OTA files into ~/otau\ncompatible with python 3.\n\"\"\"\n\nimport os\nimport json\ntry:\n\tfrom urllib.request import urlopen, urlretrieve\nexcept ImportError:\n\tfrom urllib2 import urlopen\n\tfrom urllib import urlretrieve\n\n\nf = urlopen(\"http://fw.ota.homesmart.ikea.net/feed/version_info.json\")\ndata = f.read()\n\narr = json.loads(data.decode('utf-8'))\n\notapath = '%s/otau' % os.path.expanduser('~')\n\nif not os.path.exists(otapath):\n\tos.makedirs(otapath)\n\nfor i in arr:\n\tif 'fw_binary_url' in i:\n\t\turl = i['fw_binary_url']\n\t\tls = url.split('/')\n\t\tfname = ls[len(ls) - 1]\n\t\tpath = '%s/%s' % (otapath, fname)\n\n\t\tif not os.path.isfile(path):\n\t\t\turlretrieve(url, path)\n\t\t\tprint(path)\n\t\telse:\n\t\t    print('%s already exists' % fname)\n\n\n\n\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "json.cpp",
          "type": "blob",
          "size": 14.51953125,
          "content": "/*\n * Copyright (c) 2013-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"deconz/u_assert.h\"\n#include \"deconz/u_sstream.h\"\n#include \"utils/scratchmem.h\"\n#include \"json.h\"\n#include <QLocale>\n\nstatic QString sanitizeString(QString str)\n{\n\tstr.replace(QLatin1String(\"\\\\\"), QLatin1String(\"\\\\\\\\\"));\n\tstr.replace(QLatin1String(\"\\\"\"), QLatin1String(\"\\\\\\\"\"));\n\tstr.replace(QLatin1String(\"\\b\"), QLatin1String(\"\\\\b\"));\n\tstr.replace(QLatin1String(\"\\f\"), QLatin1String(\"\\\\f\"));\n\tstr.replace(QLatin1String(\"\\n\"), QLatin1String(\"\\\\n\"));\n\tstr.replace(QLatin1String(\"\\r\"), QLatin1String(\"\\\\r\"));\n\tstr.replace(QLatin1String(\"\\t\"), QLatin1String(\"\\\\t\"));\n\treturn QString(QLatin1String(\"\\\"%1\\\"\")).arg(str);\n}\n\nstatic QByteArray join(const QList<QByteArray> &list, const QByteArray &sep)\n{\n\tQByteArray res;\n\tforeach(const QByteArray &i, list)\n\t{\n\t\tif(!res.isEmpty())\n\t\t{\n\t\t\tres += sep;\n\t\t}\n\t\tres += i;\n\t}\n\treturn res;\n}\n\n/**\n * parse\n */\nQVariant Json::parse(const QString &json)\n{\n\tbool success = true;\n\treturn Json::parse(json, success);\n}\n\n/**\n * parse\n */\nQVariant Json::parse(const QString &json, bool &success)\n{\n\tsuccess = true;\n\n\t//Return an empty QVariant if the JSON data is either null or empty\n\tif(!json.isNull() || !json.isEmpty())\n\t{\n\t\tQString data = json;\n\t\t//We'll start from index 0\n\t\tint index = 0;\n\n\t\t//Parse the first value\n\t\tQVariant value = Json::parseValue(data, index, success);\n\n\t\t//Return the parsed value\n\t\treturn value;\n\t}\n\telse\n\t{\n\t\t//Return the empty QVariant\n\t\treturn QVariant();\n\t}\n}\n\n/**\n * serialize\n */\nQByteArray Json::serialize(const QVariant &data)\n{\n\tbool success = true;\n\treturn Json::serialize(data, success);\n}\n\n/**\n * serialize\n */\nQByteArray Json::serialize(const QVariant &data, bool &success)\n{\n\tQByteArray str;\n\tsuccess = true;\n\n\tif(!data.isValid()) // invalid or null?\n\t{\n\t\tstr = \"null\";\n\t}\n\telse if((data.type() == QVariant::List) || (data.type() == QVariant::StringList)) // variant is a list?\n\t{\n\t\tQList<QByteArray> values;\n\t\tconst QVariantList list = data.toList();\n\t\tforeach(const QVariant& v, list)\n\t\t{\n\t\t\tQByteArray serializedValue = serialize(v);\n\t\t\tif(serializedValue.isNull())\n\t\t\t{\n\t\t\t\tsuccess = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalues << serializedValue;\n\t\t}\n\n\t\tstr = \"[\" + join( values, \",\" ) + \"]\";\n\t}\n\telse if(data.type() == QVariant::Map) // variant is a map?\n\t{\n\t\tconst QVariantMap vmap = data.toMap();\n\t\tQMapIterator<QString, QVariant> it( vmap );\n\t\tstr = \"{\";\n\t\tQList<QByteArray> pairs;\n\t\twhile(it.hasNext())\n\t\t{\n\t\t\tit.next();\n\t\t\tQByteArray serializedValue = serialize(it.value());\n\t\t\tif(serializedValue.isNull())\n\t\t\t{\n\t\t\t\tsuccess = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpairs << sanitizeString(it.key()).toUtf8() + \":\" + serializedValue;\n\t\t}\n\t\tstr += join(pairs, \",\");\n\t\tstr += \"}\";\n\t}\n\telse if (data.isNull())\n\t{\n\t\tstr = \"null\";\n\t}\n\telse if((data.type() == QVariant::String) || (data.type() == QVariant::ByteArray)) // a string or a byte array?\n\t{\n\t\tstr = sanitizeString(data.toString())\n#if QT_VERSION >= 0x050000\n\t\t.toUtf8();\n#else\n\t\t.toAscii();\n#endif\n\t}\n    else if(data.type() == QVariant::Double) // double?\n    {\n#if (QT_VERSION >= QT_VERSION_CHECK(5,7, 0))\n        str = QByteArray::number(data.toDouble(), 'f', QLocale::FloatingPointShortest);\n#else\n        str = QByteArray::number(data.toDouble());\n#endif\n    }\n\telse if (data.type() == QVariant::Bool) // boolean value?\n\t{\n\t\tstr = data.toBool() ? \"true\" : \"false\";\n\t}\n\telse if (data.type() == QVariant::ULongLong) // large unsigned number?\n\t{\n\t\tstr = QByteArray::number(data.value<qulonglong>());\n\t}\n\telse if ( data.canConvert<qlonglong>() ) // any signed number?\n\t{\n\t\tstr = QByteArray::number(data.value<qlonglong>());\n\t}\n\telse if (data.canConvert<QString>()) // can value be converted to string?\n\t{\n\t\t// this will catch QDate, QDateTime, QUrl, ...\n\t\tstr = sanitizeString(data.toString())\n#if QT_VERSION >= 0x050000\n\t\t.toUtf8();\n#else\n\t\t.toAscii();\n#endif\n\t}\n\telse\n\t{\n\t\tsuccess = false;\n\t}\n\tif (success)\n\t{\n\t\treturn str;\n\t}\n\telse\n\t{\n\t\treturn QByteArray();\n\t}\n}\n\n/**\n * parseValue\n */\nQVariant Json::parseValue(const QString &json, int &index, bool &success)\n{\n\t//Determine what kind of data we should parse by\n\t//checking out the upcoming token\n\tswitch(Json::lookAhead(json, index))\n\t{\n\t\tcase JsonTokenString:\n\t\t\treturn Json::parseString(json, index, success);\n\t\tcase JsonTokenNumber:\n\t\t\treturn Json::parseNumber(json, index);\n\t\tcase JsonTokenCurlyOpen:\n\t\t\treturn Json::parseObject(json, index, success);\n\t\tcase JsonTokenSquaredOpen:\n\t\t\treturn Json::parseArray(json, index, success);\n\t\tcase JsonTokenTrue:\n\t\t\tJson::nextToken(json, index);\n\t\t\treturn QVariant(true);\n\t\tcase JsonTokenFalse:\n\t\t\tJson::nextToken(json, index);\n\t\t\treturn QVariant(false);\n\t\tcase JsonTokenNull:\n\t\t\tJson::nextToken(json, index);\n\t\t\treturn QVariant();\n\t\tcase JsonTokenNone:\n\t\t\tbreak;\n\t}\n\n\t//If there were no tokens, flag the failure and return an empty QVariant\n\tsuccess = false;\n\treturn QVariant();\n}\n\n/**\n * parseObject\n */\nQVariant Json::parseObject(const QString &json, int &index, bool &success)\n{\n\tQVariantMap map;\n\tint token;\n\n\t//Get rid of the whitespace and increment index\n\tJson::nextToken(json, index);\n\n\t//Loop through all of the key/value pairs of the object\n\tbool done = false;\n\twhile(!done)\n\t{\n\t\t//Get the upcoming token\n\t\ttoken = Json::lookAhead(json, index);\n\n\t\tif(token == JsonTokenNone)\n\t\t{\n\t\t\t success = false;\n\t\t\t return QVariantMap();\n\t\t}\n\t\telse if(token == JsonTokenComma)\n\t\t{\n\t\t\tJson::nextToken(json, index);\n\t\t}\n\t\telse if(token == JsonTokenCurlyClose)\n\t\t{\n\t\t\tJson::nextToken(json, index);\n\t\t\treturn map;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Parse the key/value pair's name\n\t\t\tQString name = Json::parseString(json, index, success).toString();\n\n\t\t\tif(!success)\n\t\t\t{\n\t\t\t\treturn QVariantMap();\n\t\t\t}\n\n\t\t\t//Get the next token\n\t\t\ttoken = Json::nextToken(json, index);\n\n\t\t\t//If the next token is not a colon, flag the failure\n\t\t\t//return an empty QVariant\n\t\t\tif(token != JsonTokenColon)\n\t\t\t{\n\t\t\t\tsuccess = false;\n\t\t\t\treturn QVariant(QVariantMap());\n\t\t\t}\n\n\t\t\t//Parse the key/value pair's value\n\t\t\tQVariant value = Json::parseValue(json, index, success);\n\n\t\t\tif(!success)\n\t\t\t{\n\t\t\t\treturn QVariantMap();\n\t\t\t}\n\n\t\t\t//Assign the value to the key in the map\n\t\t\tmap[name] = value;\n\t\t}\n\t}\n\n\t//Return the map successfully\n\treturn QVariant(map);\n}\n\n/**\n * parseArray\n */\nQVariant Json::parseArray(const QString &json, int &index, bool &success)\n{\n\tQVariantList list;\n\n\tJson::nextToken(json, index);\n\n\tbool done = false;\n\twhile(!done)\n\t{\n\t\tint token = Json::lookAhead(json, index);\n\n\t\tif(token == JsonTokenNone)\n\t\t{\n\t\t\tsuccess = false;\n\t\t\treturn QVariantList();\n\t\t}\n\t\telse if(token == JsonTokenComma)\n\t\t{\n\t\t\tJson::nextToken(json, index);\n\t\t}\n\t\telse if(token == JsonTokenSquaredClose)\n\t\t{\n\t\t\tJson::nextToken(json, index);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQVariant value = Json::parseValue(json, index, success);\n\n\t\t\tif(!success)\n\t\t\t{\n\t\t\t\treturn QVariantList();\n\t\t\t}\n\n\t\t\tlist.push_back(value);\n\t\t}\n\t}\n\n\treturn QVariant(list);\n}\n\n/**\n * parseString\n */\nQVariant Json::parseString(const QString &json, int &index, bool &success)\n{\n\tQString s;\n\tQChar c;\n\n\tJson::eatWhitespace(json, index);\n\n\tc = json[index++];\n\n\tbool complete = false;\n\twhile(!complete)\n\t{\n\t\tif(index == json.size())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tc = json[index++];\n\n\t\tif(c == '\\\"')\n\t\t{\n\t\t\tcomplete = true;\n\t\t\tbreak;\n\t\t}\n\t\telse if(c == '\\\\')\n\t\t{\n\t\t\tif(index == json.size())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = json[index++];\n\n\t\t\tif(c == '\\\"')\n\t\t\t{\n\t\t\t\ts.append('\\\"');\n\t\t\t}\n\t\t\telse if(c == '\\\\')\n\t\t\t{\n\t\t\t\ts.append('\\\\');\n\t\t\t}\n\t\t\telse if(c == '/')\n\t\t\t{\n\t\t\t\ts.append('/');\n\t\t\t}\n\t\t\telse if(c == 'b')\n\t\t\t{\n\t\t\t\ts.append('\\b');\n\t\t\t}\n\t\t\telse if(c == 'f')\n\t\t\t{\n\t\t\t\ts.append('\\f');\n\t\t\t}\n\t\t\telse if(c == 'n')\n\t\t\t{\n\t\t\t\ts.append('\\n');\n\t\t\t}\n\t\t\telse if(c == 'r')\n\t\t\t{\n\t\t\t\ts.append('\\r');\n\t\t\t}\n\t\t\telse if(c == 't')\n\t\t\t{\n\t\t\t\ts.append('\\t');\n\t\t\t}\n\t\t\telse if(c == 'u')\n\t\t\t{\n\t\t\t\tint remainingLength = json.size() - index;\n\n\t\t\t\tif(remainingLength >= 4)\n\t\t\t\t{\n\t\t\t\t\tQString unicodeStr = json.mid(index, 4);\n\n\t\t\t\t\tint symbol = unicodeStr.toInt(0, 16);\n\t\t\t\t\t\n\t\t\t\t\ts.append(QChar(symbol));\n\n\t\t\t\t\tindex += 4;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.append(c);\n\t\t}\n\t}\n\n\tif(!complete)\n\t{\n\t\tsuccess = false;\n\t\treturn QVariant();\n\t}\n\n\treturn QVariant(s);\n}\n\n/**\n * parseNumber\n */\nQVariant Json::parseNumber(const QString &json, int &index)\n{\n\tJson::eatWhitespace(json, index);\n\n\tint lastIndex = Json::lastIndexOfNumber(json, index);\n\tint charLength = (lastIndex - index) + 1;\n\tQString numberStr;\n\n\tnumberStr = json.mid(index, charLength);\n\t\n\tindex = lastIndex + 1;\n\n\treturn QVariant(numberStr.toDouble(NULL));\n}\n\n/**\n * lastIndexOfNumber\n */\nint Json::lastIndexOfNumber(const QString &json, int index)\n{\n\tint lastIndex;\n\n\tfor(lastIndex = index; lastIndex < json.size(); lastIndex++)\n\t{\n\t\tif(QString(\"0123456789+-.eE\").indexOf(json[lastIndex]) == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lastIndex -1;\n}\n\n/**\n * eatWhitespace\n */\nvoid Json::eatWhitespace(const QString &json, int &index)\n{\n\tfor(; index < json.size(); index++)\n\t{\n\t\tif(QString(\" \\t\\n\\r\").indexOf(json[index]) == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * lookAhead\n */\nint Json::lookAhead(const QString &json, int index)\n{\n\tint saveIndex = index;\n\treturn Json::nextToken(json, saveIndex);\n}\n\n/**\n * nextToken\n */\nint Json::nextToken(const QString &json, int &index)\n{\n\tJson::eatWhitespace(json, index);\n\n\tif(index == json.size())\n\t{\n\t\treturn JsonTokenNone;\n\t}\n\n\tQChar c = json[index];\n\tindex++;\n#if QT_VERSION >= 0x050000\n    switch(c.toLatin1())\n#else\n    switch(c.toAscii())\n#endif\n\t{\n\t\tcase '{': return JsonTokenCurlyOpen;\n\t\tcase '}': return JsonTokenCurlyClose;\n\t\tcase '[': return JsonTokenSquaredOpen;\n\t\tcase ']': return JsonTokenSquaredClose;\n\t\tcase ',': return JsonTokenComma;\n\t\tcase '\"': return JsonTokenString;\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\tcase '-': return JsonTokenNumber;\n\t\tcase ':': return JsonTokenColon;\n\t}\n\n\tindex--;\n\n\tint remainingLength = json.size() - index;\n\n\t//True\n\tif(remainingLength >= 4)\n\t{\n\t\tif (json[index] == 't' && json[index + 1] == 'r' &&\n\t\t\tjson[index + 2] == 'u' && json[index + 3] == 'e')\n\t\t{\n\t\t\tindex += 4;\n\t\t\treturn JsonTokenTrue;\n\t\t}\n\t}\n\n\t//False\n\tif (remainingLength >= 5)\n\t{\n\t\tif (json[index] == 'f' && json[index + 1] == 'a' &&\n\t\t\tjson[index + 2] == 'l' && json[index + 3] == 's' &&\n\t\t\tjson[index + 4] == 'e')\n\t\t{\n\t\t\tindex += 5;\n\t\t\treturn JsonTokenFalse;\n\t\t}\n\t}\n\n\t//Null\n\tif (remainingLength >= 4)\n\t{\n\t\tif (json[index] == 'n' && json[index + 1] == 'u' &&\n\t\t\tjson[index + 2] == 'l' && json[index + 3] == 'l')\n\t\t{\n\t\t\tindex += 4;\n\t\t\treturn JsonTokenNull;\n\t\t}\n\t}\n\n\treturn JsonTokenNone;\n}\n\nenum JsonBuilderState\n{\n    JBS_Initial,\n    JBS_Empty,\n    JBS_Element,\n    JBS_Key\n};\n\nenum JsonBuilderConstants\n{\n    kJB_None = 0,\n    kJB_MaxNesting = 16,\n    kJB_Object = 4,\n    kJB_Array = 8,\n};\n\nclass JsonBuilderPrivate\n{\npublic:\n    U_SStream ss;\n    JsonBuilderState state;\n    int needComma;\n    int err;\n    int nesting;\n    uint8_t stack[kJB_MaxNesting];\n};\n\nJsonBuilder::JsonBuilder(unsigned bufsize)\n{\n    d = SCRATCH_ALLOC(JsonBuilderPrivate*, sizeof(*d));\n    U_ASSERT(d && \"failed to alloc JsonBuilderPrivate\");\n    if (!d)\n        return;\n\n    d->state = JBS_Initial;\n    d->nesting = 0;\n    d->err = 0;\n    d->stack[0] = kJB_None;\n\n    d->ss.str = SCRATCH_ALLOC(char*, bufsize);\n    U_ASSERT(d->ss.str && \"failed to alloc JsonBuilderPrivate.ss.str\");\n    if (!d->ss.str)\n    {\n        d = nullptr;\n        return;\n    }\n\n    U_sstream_init(&d->ss, d->ss.str, bufsize);\n}\n\nvoid JsonBuilder::startArray()\n{\n    U_ASSERT(d->nesting < kJB_MaxNesting);\n    if (d->nesting == kJB_MaxNesting)\n    {\n        d->err = 1;\n        return;\n    }\n\n    if (d->state == JBS_Element)\n    {\n        U_sstream_put_str(&d->ss, \",\");\n    }\n\n    d->stack[d->nesting] = kJB_Array;\n    d->nesting++;\n    U_sstream_put_str(&d->ss, \"[\");\n    d->state = JBS_Empty;\n}\n\nvoid JsonBuilder::endArray()\n{\n    U_ASSERT(d->nesting > 0);\n    if (d->nesting == 0)\n    {\n        d->err = 1;\n        return;\n    }\n\n    d->nesting--;\n    U_ASSERT(d->stack[d->nesting] == kJB_Array);\n    if (d->stack[d->nesting] != kJB_Array)\n    {\n        d->err = 1;\n        return;\n    }\n\n    d->stack[d->nesting] = kJB_None;\n    U_sstream_put_str(&d->ss, \"]\");\n    d->state = JBS_Element;\n}\n\nvoid JsonBuilder::startObject()\n{\n    U_ASSERT(d->nesting < kJB_MaxNesting);\n    if (d->nesting == kJB_MaxNesting)\n    {\n        d->err = 1;\n        return;\n    }\n\n    if (d->state == JBS_Element)\n    {\n        U_sstream_put_str(&d->ss, \",\");\n    }\n\n    d->stack[d->nesting] = kJB_Object;\n    d->nesting++;\n    U_sstream_put_str(&d->ss, \"{\");\n    d->state = JBS_Empty;\n}\n\nvoid JsonBuilder::endObject()\n{\n    U_ASSERT(d->nesting > 0);\n    if (d->nesting == 0)\n    {\n        d->err = 1;\n        return;\n    }\n\n    d->nesting--;\n    U_ASSERT(d->stack[d->nesting] == kJB_Object);\n    if (d->stack[d->nesting] != kJB_Object)\n    {\n        d->err = 1;\n        return;\n    }\n\n    d->stack[d->nesting] = kJB_None;\n    U_sstream_put_str(&d->ss, \"}\");\n    d->state = JBS_Element;\n}\n\nvoid JsonBuilder::addKey(const char *key)\n{\n    if (d->nesting == 0)\n    {\n        d->err = 1;\n        return;\n    }\n\n    bool isObject = d->stack[d->nesting - 1] == kJB_Object;\n\n    if (!isObject)\n    {\n        d->err = 1;\n        return;\n    }\n\n    if (d->state == JBS_Empty || d->state == JBS_Element)\n    {\n        if (d->state == JBS_Element)\n        {\n            U_sstream_put_str(&d->ss, \",\");\n        }\n        U_sstream_put_str(&d->ss, \"\\\"\");\n        U_sstream_put_str(&d->ss, key);\n        U_sstream_put_str(&d->ss, \"\\\"\");\n        U_sstream_put_str(&d->ss, \":\");\n        d->state = JBS_Key;\n    }\n    else\n    {\n        d->err = 1;\n        return;\n    }\n}\n\nvoid JsonBuilder::addNumber(double num)\n{\n    if (d->nesting == 0)\n    {\n        d->err = 1;\n        return;\n    }\n\n    bool isObject = d->stack[d->nesting - 1] == kJB_Object;\n\n    if (isObject)\n    {\n        if (d->state != JBS_Key)\n        {\n            d->err = 1;\n            return;\n        }\n    }\n    else if (d->state == JBS_Element)\n    {\n        U_sstream_put_str(&d->ss, \",\");\n    }\n\n    U_sstream_put_double(&d->ss, num, 6);\n    d->state = JBS_Element;\n}\n\nvoid JsonBuilder::addString(const char *str)\n{\n    if (d->nesting == 0)\n    {\n        d->err = 1;\n        return;\n    }\n\n    bool isObject = d->stack[d->nesting - 1] == kJB_Object;\n\n    if (isObject)\n    {\n        if (d->state != JBS_Key)\n        {\n            d->err = 1;\n            return;\n        }\n    }\n    else if (d->state == JBS_Element)\n    {\n        U_sstream_put_str(&d->ss, \",\");\n    }\n\n    U_sstream_put_str(&d->ss, \"\\\"\");\n    U_sstream_put_str(&d->ss, str);\n    U_sstream_put_str(&d->ss, \"\\\"\");\n    d->state = JBS_Element;\n}\n"
        },
        {
          "name": "json.h",
          "type": "blob",
          "size": 4.9365234375,
          "content": "/*\n * Copyright (c) 2013-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef JSON_H\n#define JSON_H\n\n#include <QVariant>\n#include <QString>\n\n/* CJ\n * Low level JSON module\n */\n#include \"cj/cj.h\"\n\n/*\n * CJ extra modules, have no header thus declare protoypes here.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint cj_copy_ref_utf8(cj_ctx *ctx, char *buf, unsigned size, cj_token_ref ref);\nint cj_ref_to_boolean(cj_ctx *ctx, int *result, cj_token_ref ref);\nint cj_ref_to_double(cj_ctx *ctx, double *result, cj_token_ref ref);\nint cj_ref_to_long(cj_ctx *ctx, long *result, cj_token_ref ref);\nint cj_ref_to_null(cj_ctx *ctx, cj_token_ref ref);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/**\n * \\enum JsonToken\n */\nenum JsonToken\n{\n\tJsonTokenNone = 0,\n\tJsonTokenCurlyOpen = 1,\n\tJsonTokenCurlyClose = 2,\n\tJsonTokenSquaredOpen = 3,\n\tJsonTokenSquaredClose = 4,\n\tJsonTokenColon = 5,\n\tJsonTokenComma = 6,\n\tJsonTokenString = 7,\n\tJsonTokenNumber = 8,\n\tJsonTokenTrue = 9,\n\tJsonTokenFalse = 10,\n\tJsonTokenNull = 11\n};\n\n/**\n * \\class Json\n * \\brief A JSON data parser\n *\n * Json parses a JSON data into a QVariant hierarchy.\n */\nclass Json\n{\n\tpublic:\n\t\t/**\n\t\t * Parse a JSON string\n\t\t *\n\t\t * \\param json The JSON data\n\t\t */\n\t\tstatic QVariant parse(const QString &json);\n\n\t\t/**\n\t\t * Parse a JSON string\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param success The success of the parsing\n\t\t */\n\t\tstatic QVariant parse(const QString &json, bool &success);\n\n\t\t/**\n\t\t* This method generates a textual JSON representation\n\t\t*\n\t\t* \\param data The JSON data generated by the parser.\n\t\t* \\param success The success of the serialization\n\t\t*/\n\t\tstatic QByteArray serialize(const QVariant &data);\n\n\t\t/**\n\t\t* This method generates a textual JSON representation\n\t\t*\n\t\t* \\param data The JSON data generated by the parser.\n\t\t* \\param success The success of the serialization\n\t\t*\n\t\t* \\return QByteArray Textual JSON representation\n\t\t*/\n\t\tstatic QByteArray serialize(const QVariant &data, bool &success);\n\n\tprivate:\n\t\t/**\n\t\t * Parses a value starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The start index\n\t\t * \\param success The success of the parse process\n\t\t *\n\t\t * \\return QVariant The parsed value\n\t\t */\n\t\tstatic QVariant parseValue(const QString &json, int &index,\n\t\t\t\t\t\t\t\t   bool &success);\n\n\t\t/**\n\t\t * Parses an object starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The start index\n\t\t * \\param success The success of the object parse\n\t\t *\n\t\t * \\return QVariant The parsed object map\n\t\t */\n\t\tstatic QVariant parseObject(const QString &json, int &index,\n\t\t\t\t\t\t\t\t\t   bool &success);\n\n\t\t/**\n\t\t * Parses an array starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t * \\param success The success of the array parse\n\t\t *\n\t\t * \\return QVariant The parsed variant array\n\t\t */\n\t\tstatic QVariant parseArray(const QString &json, int &index,\n\t\t\t\t\t\t\t\t\t   bool &success);\n\n\t\t/**\n\t\t * Parses a string starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t * \\param success The success of the string parse\n\t\t *\n\t\t * \\return QVariant The parsed string\n\t\t */\n\t\tstatic QVariant parseString(const QString &json, int &index,\n\t\t\t\t\t\t\t\t\tbool &success);\n\n\t\t/**\n\t\t * Parses a number starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t *\n\t\t * \\return QVariant The parsed number\n\t\t */\n\t\tstatic QVariant parseNumber(const QString &json, int &index);\n\n\t\t/**\n\t\t * Get the last index of a number starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t *\n\t\t * \\return The last index of the number\n\t\t */\n\t\tstatic int lastIndexOfNumber(const QString &json, int index);\n\n\t\t/**\n\t\t * Skip unwanted whitespace symbols starting from index\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The start index\n\t\t */\n\t\tstatic void eatWhitespace(const QString &json, int &index);\n\n\t\t/**\n\t\t * Check what token lies ahead\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t *\n\t\t * \\return int The upcoming token\n\t\t */\n\t\tstatic int lookAhead(const QString &json, int index);\n\n\t\t/**\n\t\t * Get the next JSON token\n\t\t *\n\t\t * \\param json The JSON data\n\t\t * \\param index The starting index\n\t\t *\n\t\t * \\return int The next JSON token\n\t\t */\n\t\tstatic int nextToken(const QString &json, int &index);\n};\n\n\n/*!\n * \\class JsonBuilder\n * \\brief JSON builder class that uses scratch allocator under the hood.\n */\nclass JsonBuilderPrivate;\n\nclass JsonBuilder\n{\npublic:\n    JsonBuilder() = delete;\n    explicit JsonBuilder(unsigned bufsize);\n\n    void startArray();\n    void endArray();\n    void startObject();\n    void endObject();\n    void addKey(const char *key);\n    void addNumber(double num);\n    void addString(const char *str);\n\nprivate:\n    JsonBuilderPrivate *d = nullptr;\n};\n\n#endif //JSON_H\n"
        },
        {
          "name": "light_node.cpp",
          "type": "blob",
          "size": 27.8115234375,
          "content": "/*\n * Copyright (c) 2016-2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"product_match.h\"\n\n/*! Constructor.\n */\nLightNode::LightNode() :\n    Resource(RLights),\n    m_state(StateNormal),\n    m_resetRetryCount(0),\n    m_zdpResetSeq(0),\n    m_groupCapacity(0),\n    m_manufacturerCode(0),\n    m_otauClusterId(0), // unknown\n    m_colorLoopActive(false),\n    m_colorLoopSpeed(0),\n    m_groupCount(0),\n    m_sceneCapacity(16)\n\n{\n    // add common items\n    addItem(DataTypeBool, RStateOn);\n    addItem(DataTypeString, RStateAlert);\n    addItem(DataTypeBool, RStateReachable);\n    addItem(DataTypeString, RAttrName);\n    addItem(DataTypeString, RAttrManufacturerName);\n    addItem(DataTypeString, RAttrModelId);\n    addItem(DataTypeString, RAttrType);\n    addItem(DataTypeString, RAttrSwVersion);\n    addItem(DataTypeString, RAttrId);\n    addItem(DataTypeString, RAttrUniqueId);\n    addItem(DataTypeTime, RAttrLastAnnounced);\n    addItem(DataTypeTime, RAttrLastSeen);\n}\n\n/*! Returns the LightNode state.\n */\nLightNode::State LightNode::state() const\n{\n    return m_state;\n}\n\n/*! Sets the LightNode state.\n    \\param state the LightNode state\n */\nvoid LightNode::setState(State state)\n{\n    m_state = state;\n}\n\n/*! Returns true if the light is reachable.\n */\nbool LightNode::isAvailable() const\n{\n    return item(RStateReachable)->toBool();\n}\n\n/*! Returns the ZigBee Alliance manufacturer code.\n */\nuint16_t LightNode::manufacturerCode() const\n{\n    return m_manufacturerCode;\n}\n\n/*! Sets the ZigBee Alliance manufacturer code.\n    \\param code the vendor specific manufacturer code\n */\nvoid LightNode::setManufacturerCode(uint16_t code)\n{\n    if (m_manufacturerCode != code)\n    {\n        m_manufacturerCode = code;\n\n        if (!manufacturer().isEmpty())\n        {\n            return;\n        }\n\n        QString name;\n        switch (code)\n        {\n        case VENDOR_ATMEL: // fall through\n        case VENDOR_DDEL:    name = QLatin1String(\"dresden elektronik\"); break;\n        case VENDOR_BEGA:    name = QLatin1String(\"BEGA\"); break;\n        case VENDOR_IKEA:    name = QLatin1String(\"IKEA of Sweden\"); break;\n        case VENDOR_INNR:    name = QLatin1String(\"innr\"); break;\n        case VENDOR_LDS:     name = QLatin1String(\"LDS\"); break;\n        case VENDOR_INSTA:   name = QLatin1String(\"Insta\"); break;\n        case VENDOR_PHILIPS: name = QLatin1String(\"Philips\"); break;\n        case VENDOR_LEDVANCE: name = QLatin1String(\"LEDVANCE\"); break;\n        case VENDOR_OSRAM_STACK: // fall through\n        case VENDOR_OSRAM:   name = QLatin1String(\"OSRAM\"); break;\n        case VENDOR_UBISYS:  name = QLatin1String(\"ubisys\"); break;\n        case VENDOR_BUSCH_JAEGER:  name = QLatin1String(\"Busch-Jaeger\"); break;\n        //case VENDOR_EMBER:   // fall through\n        //case VENDOR_HEIMAN:  name = QLatin1String(\"Heiman\"); break;\n        case VENDOR_KEEN_HOME: name = QLatin1String(\"Keen Home Inc\"); break;\n        case VENDOR_DANALOCK: name = QLatin1String(\"Danalock\"); break;\n        case VENDOR_SCHLAGE: name = QLatin1String(\"Schlage\"); break;\n        case VENDOR_DEVELCO: name = QLatin1String(\"Develco Products A/S\"); break;\n        case VENDOR_NETVOX:   name = QLatin1String(\"netvox\"); break;\n        }\n\n        if (!manufacturer().isEmpty())\n        {\n            setManufacturerName(name);\n        }\n    }\n}\n\n/*! Returns the manufacturer name. */\nconst QString &LightNode::manufacturer() const\n{\n    return item(RAttrManufacturerName)->toString();\n}\n\n/*! Sets the manufacturer name.\n    \\param name the manufacturer name\n */\nvoid LightNode::setManufacturerName(const QString &name)\n{\n    item(RAttrManufacturerName)->setValue(name.trimmed());\n}\n\n/*! Returns the model indentifier.\n */\nconst QString &LightNode::modelId() const\n{\n    return item(RAttrModelId)->toString();\n}\n\n/*! Sets the model identifier.\n    \\param modelId the model identifier\n */\nvoid LightNode::setModelId(const QString &modelId)\n{\n    item(RAttrModelId)->setValue(modelId.trimmed());\n}\n\n/*! Returns the software build identifier.\n */\nconst QString &LightNode::swBuildId() const\n{\n    return item(RAttrSwVersion)->toString();\n}\n\n/*! Sets the software build identifier.\n    \\param swBuildId the software build identifier\n */\nvoid LightNode::setSwBuildId(const QString &swBuildId)\n{\n    item(RAttrSwVersion)->setValue(swBuildId.trimmed());\n}\n\n/*! Returns the name of the light node.\n */\nconst QString &LightNode::name() const\n{\n    return item(RAttrName)->toString();\n}\n\n/*! Sets the name of the light node.\n    \\param name the name\n */\nvoid LightNode::setName(const QString &name)\n{\n    item(RAttrName)->setValue(name);\n}\n\n/*! Returns the device type as string for example: 'Extended color light'.\n */\nconst QString &LightNode::type() const\n{\n    return item(RAttrType)->toString();\n}\n\n/*! Returns the modifiable list of groups in which the light is a member.\n */\nstd::vector<GroupInfo> &LightNode::groups()\n{\n    return m_groups;\n}\n\n/*! Returns the const list of groups in which the light is a member.\n */\nconst std::vector<GroupInfo> &LightNode::groups() const\n{\n    return m_groups;\n}\n\n/*! Returns the otau cluster id.\n */\nuint16_t LightNode::otauClusterId() const\n{\n    return m_otauClusterId;\n}\n\n/*! Sets the otau cluster id.\n    \\param clusterId the cluster id\n */\nvoid LightNode::setOtauClusterId(uint16_t clusterId)\n{\n    m_otauClusterId = clusterId;\n}\n\n/*! Returns true if the light supports the color cluster.\n */\nbool LightNode::hasColor() const\n{\n    return item(RStateColorMode) != nullptr;\n}\n\n/*! Sets the nodes color loop active state.\n    \\param colorLoopActive whereever the color loop is active\n */\nvoid LightNode::setColorLoopActive(bool colorLoopActive)\n{\n    m_colorLoopActive = colorLoopActive;\n}\n\n/*! Returns true if the color loop is active. */\nbool LightNode::isColorLoopActive() const\n{\n    return m_colorLoopActive;\n}\n\nbool LightNode::supportsColorLoop() const\n{\n    const auto *colorCapabilities = item(RCapColorCapabilities);\n\n    if (colorCapabilities)\n    {\n        const quint16 colorLoopCap = COLOR_CAP_ENHANCED_HUE | COLOR_CAP_COLORLOOP;\n        return (colorCapabilities->toNumber() & colorLoopCap) == colorLoopCap;\n    }\n\n    return false;\n}\n\n/*! Sets the nodes color loop speed state.\n    \\param colorLoopActive whereever the color loop is active\n */\nvoid LightNode::setColorLoopSpeed(uint8_t speed)\n{\n    m_colorLoopSpeed = speed;\n}\n\n/*! Returns the nodes color loop speed state. */\nuint8_t LightNode::colorLoopSpeed() const\n{\n    return m_colorLoopSpeed;\n}\n\n/*! Handles admin when ResourceItem value has been set.\n * \\param i ResourceItem\n */\nvoid LightNode::didSetValue(ResourceItem *i)\n{\n    enqueueEvent(Event(RLights, i->descriptor().suffix, id(), i));\n    if (i->descriptor().suffix != RAttrLastSeen) // prevent flooding database writes\n    {\n        setNeedSaveDatabase(true);\n    }\n}\n\n/*! Mark received command and update lastseen. */\nvoid LightNode::rx()\n{\n    RestNodeBase *b = static_cast<RestNodeBase *>(this);\n    b->rx();\n    if (lastRx() >= item(RAttrLastSeen)->lastChanged().addSecs(plugin->gwLightLastSeenInterval))\n    {\n        setValue(RAttrLastSeen, lastRx().toUTC());\n    }\n}\n\n/*! Returns the lights HA endpoint descriptor.\n */\nconst deCONZ::SimpleDescriptor &LightNode::haEndpoint() const\n{\n    const auto *sd = m_haEndpoint < 255 ? getSimpleDescriptor(m_node, m_haEndpoint) : nullptr;\n    if (sd)\n    {\n        return *sd;\n    }\n\n    static deCONZ::SimpleDescriptor invalidEndpoint; // TODO hack\n    return invalidEndpoint;\n}\n\n/*! Sets the lights HA endpoint descriptor.\n    \\param endpoint the HA endpoint descriptor\n */\nvoid LightNode::setHaEndpoint(const deCONZ::SimpleDescriptor &endpoint)\n{\n    bool isWindowCovering = false;\n    bool isInitialized = m_haEndpoint < 255;\n    m_haEndpoint = endpoint.endpoint();\n\n    // check if std otau cluster present in endpoint\n    if (otauClusterId() == 0)\n    {\n        auto it = endpoint.outClusters().cbegin();\n        const auto end = endpoint.outClusters().cend();\n\n        for (; it != end; ++it)\n        {\n            if (it->id() == OTAU_CLUSTER_ID)\n            {\n                setOtauClusterId(OTAU_CLUSTER_ID);\n                break;\n            }\n        }\n    }\n\n    if (manufacturerCode() == VENDOR_XIAOMI && endpoint.deviceId() == DEV_ID_HA_COLOR_DIMMABLE_LIGHT)\n    {\n        // https://github.com/dresden-elektronik/deconz-rest-plugin/issues/1057\n        // The Xiaomi Aqara TW (ZNLDP12LM) light is, has wrong device type in simple descriptor\n        // we will treat it as color temperature light once the modelid is known\n        if (modelId().isEmpty())\n        {\n            return; // wait until known: Xiaomi lumi.light.aqcn02\n        }\n\n        isInitialized = item(RStateColorMode) != nullptr;\n    }\n\n    // initial setup\n    if (!isInitialized)\n    {\n        quint16 deviceId = endpoint.deviceId();\n        QString ltype = QLatin1String(\"Unknown\");\n\n        {\n            auto i = endpoint.inClusters().cbegin();\n            const auto end = endpoint.inClusters().cend();\n\n            for (; i != end; ++i)\n            {\n                if (i->id() == ONOFF_CLUSTER_ID)\n                {\n                }\n                else if (i->id() == LEVEL_CLUSTER_ID)\n                {\n                    if ((manufacturerCode() == VENDOR_IKEA && endpoint.deviceId() == DEV_ID_Z30_ONOFF_PLUGIN_UNIT) || // IKEA Tradfri control outlet\n                        (manufacturerCode() == VENDOR_INNR && endpoint.deviceId() == DEV_ID_ZLL_ONOFF_PLUGIN_UNIT) || // innr SP120 smart plug\n                        (manufacturerCode() == VENDOR_INNR && endpoint.deviceId() == DEV_ID_Z30_ONOFF_PLUGIN_UNIT) || // innr ZigBee 3.0 smart plugs (SP2xx)\n                        (manufacturerCode() == VENDOR_3A_SMART_HOME && endpoint.deviceId() == DEV_ID_ZLL_ONOFF_LIGHT) || // 3A in-wall switch\n                        (manufacturerCode() == VENDOR_PHILIPS && endpoint.deviceId() == DEV_ID_HA_ONOFF_LIGHT && endpoint.profileId() == HA_PROFILE_ID) ||\n                        (manufacturerCode() == VENDOR_PHILIPS && endpoint.deviceId() == DEV_ID_Z30_ONOFF_PLUGIN_UNIT)) // Philips Hue plug\n                    { } // skip state.bri not supported\n                    else\n                    {\n                        addItem(DataTypeUInt8, RStateBri);\n                    }\n                }\n                else if (i->id() == COLOR_CLUSTER_ID)\n                {\n                    if ((manufacturerCode() == VENDOR_NONE && deviceId == DEV_ID_ZLL_DIMMABLE_LIGHT) ||\n                        (manufacturerCode() == VENDOR_NONE && deviceId == DEV_ID_LEVEL_CONTROL_SWITCH))\n                    {\n                        // GLEDOPTO GL-C-009 advertises non-functional color cluster\n                        // ORVIBO T10D1ZW in-wall dimmer does the same\n                    }\n                    else\n                    {\n                        addItem(DataTypeString, RStateColorMode)->setValue(QVariant(\"hs\"));\n                    }\n\n                    if (modelId() == QLatin1String(\"lumi.light.aqcn02\"))\n                    {\n                        // correct wrong device id\n                        deviceId = DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT;\n                    }\n\n                    switch (deviceId)\n                    {\n                    case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n                    case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:\n                    case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:\n                    case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT: // fall through\n                    {\n                        addItem(DataTypeUInt16, RCapColorCapabilities);\n                        addItem(DataTypeUInt16, RCapColorCtMin);\n                        addItem(DataTypeUInt16, RCapColorCtMax)->setValue(0xFEFF);\n                        addItem(DataTypeUInt16, RStateCt);\n\n                        if (deviceId == DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT ||\n                            deviceId == DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT)\n                        {\n                            item(RStateColorMode)->setValue(QVariant(\"ct\")); // note due addItem() calls, pointer is different here\n                        }\n                    }\n                    // fall through\n\n                    default:\n                        break;\n                    }\n\n                    switch (deviceId)\n                    {\n                    case DEV_ID_ZLL_COLOR_LIGHT:\n                        {\n                            addItem(DataTypeUInt16, RCapColorCapabilities);\n                        }\n                        // fall through\n                    case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:\n                    case DEV_ID_HA_COLOR_DIMMABLE_LIGHT:\n                    case DEV_ID_Z30_EXTENDED_COLOR_LIGHT: // fall through\n                        {\n                            addItem(DataTypeUInt16, RStateX);\n                            addItem(DataTypeUInt16, RStateY);\n                            if (manufacturer() == QLatin1String(\"LIDL Livarno Lux\"))\n                            {\n                                removeItem(RCapColorCapabilities);\n                            }\n                            // else if (modelId() == QLatin1String(\"lumi.light.acn132\"))\n                            else if (deviceId == DEV_ID_HA_COLOR_DIMMABLE_LIGHT && manufacturerCode() == 0 &&\n                                     manufacturer().isEmpty() && modelId().isEmpty())\n                            {\n                            }\n                            else\n                            {\n                                addItem(DataTypeString, RStateEffect)->setValue(QVariant(\"none\"));\n                                addItem(DataTypeUInt16, RStateHue);\n                                addItem(DataTypeUInt8, RStateSat);\n                            }\n                        }\n                        break;\n                    default:\n                        break;\n                    }\n                }\n                else if (i->id() == WINDOW_COVERING_CLUSTER_ID /*FIXME ubisys J1*/)\n                {\n                    if (modelId() != QLatin1String(\"lumi.light.aqcn02\"))\n                    {\n                        auto ic = endpoint.inClusters().cbegin();\n                        auto ia = ic->attributes().cbegin();\n                        const auto enda = ic->attributes().cend();\n                        isWindowCovering = true;\n                        bool hasLift = true; // set default to lift\n                        bool hasTilt = false;\n                        for (;ia != enda; ++ia)\n                        {\n                            if (ia->id() == 0x0000)  // WindowCoveringType\n                            {\n                                /*\n                                 * Value Type                         Capabilities\n                                 *  0    Roller Shade                 = Lift only\n                                 *  1    Roller Shade two motors      = Lift only\n                                 *  2    Roller Shade exterior        = Lift only\n                                 *  3    Roller Shade two motors ext  = Lift only\n                                 *  4    Drapery                      = Lift only\n                                 *  5    Awning                       = Lift only\n                                 *  6    Shutter                      = Tilt only\n                                 *  7    Tilt Blind Lift only         = Tilt only\n                                 *  8    Tilt Blind lift & tilt       = Lift & Tilt\n                                 *  9    Projector Screen             = Lift only\n                                 */\n                                uint8_t coveringType = ia->numericValue().u8;\n                                if (coveringType == 8 ) {\n                                    hasTilt = true;\n                                }\n                                else if (coveringType == 6 || coveringType == 7)\n                                {\n                                    hasTilt = true;\n                                    hasLift = false;\n                                }\n                            }\n                        }\n                        removeItem(RStateAlert);\n                        addItem(DataTypeBool, RStateOpen);\n                        // FIXME: removeItem(RStateOn);\n                        if (hasLift)\n                        {\n                            addItem(DataTypeUInt8, RStateLift);\n                            addItem(DataTypeUInt8, RStateBri); // FIXME: deprecate\n                        }\n                        if (hasTilt)\n                        {\n                            addItem(DataTypeUInt8, RStateTilt);\n                            addItem(DataTypeUInt8, RStateSat); // FIXME: deprecate\n                        }\n                    }\n                }\n                else if (i->id() == FAN_CONTROL_CLUSTER_ID) {\n                    addItem(DataTypeUInt8, RStateSpeed);\n                }\n                //else if (i->id() == TUYA_CLUSTER_ID) {\n                //}\n                else if (i->id() == IAS_WD_CLUSTER_ID)\n                {\n                    if (modelId().startsWith(QLatin1String(\"902010/24\")) ||   // Bitron Smoke Detector with siren\n                        modelId().startsWith(QLatin1String(\"FLSZB-1\")) ||     // Develco water leak sensor with siren\n                        modelId().startsWith(QLatin1String(\"SIRZB-1\")) ||     // Develco siren\n                        modelId() == QLatin1String(\"902010/29\") ||            // Bitron outdoor siren\n                        modelId() == QLatin1String(\"SD8SC_00.00.03.09TC\"))    // Centralite smoke sensor\n                    {\n                        removeItem(RStateOn);\n                        ltype = QLatin1String(\"Warning device\");\n                    }\n                }\n                else if (i->id() == IDENTIFY_CLUSTER_ID)\n                {\n                    if ((manufacturerCode() == VENDOR_IKEA && deviceId == DEV_ID_RANGE_EXTENDER) ||\n                        R_GetProductId(this) == QLatin1String(\"Tuya_RPT Repeater\"))\n                    {\n                        // the ikea repeater has no on/off cluster but an led which supports identify\n                        removeItem(RStateOn);\n                        ltype = QLatin1String(\"Range extender\");\n                    }\n                }\n            }\n        }\n\n        if (endpoint.profileId() == HA_PROFILE_ID)\n        {\n\n            if ((manufacturerCode() == VENDOR_LEGRAND) && isWindowCovering)\n            {\n                // correct wrong device id for legrand, the window suhtter command is see as plug\n                // DEV_ID_Z30_ONOFF_PLUGIN_UNIT\n                deviceId = DEV_ID_HA_WINDOW_COVERING_DEVICE;\n            }\n\n            switch (deviceId)\n            {\n            //case DEV_ID_ZLL_DIMMABLE_LIGHT:   break; // clash with on/off light\n            case DEV_ID_HA_ONOFF_LIGHT:\n            {\n                if (item(RStateBri) == nullptr)    { ltype = QLatin1String(\"On/Off light\"); }\n                else                               { ltype = QLatin1String(\"Dimmable light\"); }\n            }\n                break;\n            case DEV_ID_LEVEL_CONTROL_SWITCH:          ltype = QLatin1String(\"Level control switch\"); break;\n            case DEV_ID_ONOFF_OUTPUT:                  ltype = QLatin1String(\"On/Off output\"); break;\n            case DEV_ID_LEVEL_CONTROLLABLE_OUTPUT:     ltype = QLatin1String(\"Level controllable output\"); break;\n            case DEV_ID_MAINS_POWER_OUTLET:            ltype = QLatin1String(\"On/Off plug-in unit\"); break;\n            case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:         ltype = QLatin1String(\"On/Off plug-in unit\"); break;\n            case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:         ltype = QLatin1String(\"On/Off plug-in unit\"); break;\n            case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:      ltype = QLatin1String(\"Dimmable plug-in unit\"); break;\n            case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:      ltype = QLatin1String(\"Dimmable plug-in unit\"); break;\n            case DEV_ID_HA_DIMMABLE_LIGHT:             ltype = QLatin1String(\"Dimmable light\"); break;\n            case DEV_ID_HA_COLOR_DIMMABLE_LIGHT:       ltype = QLatin1String(\"Color dimmable light\"); break;\n            case DEV_ID_HA_ONOFF_LIGHT_SWITCH:         ltype = QLatin1String(\"On/Off light switch\"); break;\n            case DEV_ID_HA_DIMMER_SWITCH:              ltype = QLatin1String(\"Dimmer switch\"); break;\n            case DEV_ID_ZLL_ONOFF_LIGHT:               ltype = QLatin1String(\"On/Off light\"); break;\n            case DEV_ID_SMART_PLUG:                    ltype = QLatin1String(\"Smart plug\"); break;\n            case DEV_ID_ZLL_COLOR_LIGHT:               ltype = QLatin1String(\"Color light\"); break;\n            case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:      ltype = QLatin1String(\"Extended color light\"); break;\n            case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:      ltype = QLatin1String(\"Extended color light\"); break;\n            case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT:   ltype = QLatin1String(\"Color temperature light\"); break;\n            case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT:   ltype = QLatin1String(\"Color temperature light\"); break;\n            case DEV_ID_XIAOMI_SMART_PLUG:             ltype = QLatin1String(\"Smart plug\"); break;\n            case DEV_ID_CONSUMPTION_AWARENESS_DEVICE:  ltype = QLatin1String(\"Consumption awareness device\");\n                                                       removeItem(RStateOn); break;\n            case DEV_ID_IAS_ZONE:                      removeItem(RStateOn);\n                                                       ltype = QLatin1String(\"Warning device\"); break;\n            case DEV_ID_IAS_WARNING_DEVICE:            removeItem(RStateOn);\n                                                       ltype = QLatin1String(\"Warning device\"); break;\n            case DEV_ID_HA_WINDOW_COVERING_CONTROLLER: ltype = QLatin1String(\"Window covering controller\"); break;\n            case DEV_ID_HA_WINDOW_COVERING_DEVICE:     ltype = QLatin1String(\"Window covering device\"); break;\n            case DEV_ID_DOOR_LOCK:                     addItem(DataTypeBool, RCapGroupsNotSupported);\n                                                       ltype = QLatin1String(\"Door Lock\"); break;\n            case DEV_ID_DOOR_LOCK_UNIT:                addItem(DataTypeBool, RCapGroupsNotSupported);\n                                                       ltype = QLatin1String(\"Door Lock Unit\"); break;\n            case DEV_ID_FAN:                           ltype = QLatin1String(\"Fan\"); break;\n            case DEV_ID_CONFIGURATION_TOOL:            removeItem(RStateOn);\n                                                       removeItem(RStateAlert);\n                                                       addItem(DataTypeBool, RCapGroupsNotSupported);\n                                                       ltype = QLatin1String(\"Configuration tool\"); break;\n            default:\n                break;\n            }\n        }\n        else if (endpoint.profileId() == ZLL_PROFILE_ID)\n        {\n            switch (deviceId)\n            {\n            case DEV_ID_ZLL_ONOFF_LIGHT:             ltype = QLatin1String(\"On/Off light\"); break;\n            case DEV_ID_ZLL_ONOFF_PLUGIN_UNIT:       ltype = QLatin1String(\"On/Off plug-in unit\"); break;\n            case DEV_ID_Z30_ONOFF_PLUGIN_UNIT:       ltype = QLatin1String(\"On/Off plug-in unit\"); break;\n            case DEV_ID_ZLL_DIMMABLE_PLUGIN_UNIT:    ltype = QLatin1String(\"Dimmable plug-in unit\"); break;\n            case DEV_ID_Z30_DIMMABLE_PLUGIN_UNIT:    ltype = QLatin1String(\"Dimmable plug-in unit\"); break;\n            case DEV_ID_ZLL_DIMMABLE_LIGHT:          ltype = QLatin1String(\"Dimmable light\"); break;\n            case DEV_ID_ZLL_COLOR_LIGHT:             ltype = QLatin1String(\"Color light\"); break;\n            case DEV_ID_ZLL_EXTENDED_COLOR_LIGHT:    ltype = QLatin1String(\"Extended color light\"); break;\n            case DEV_ID_Z30_EXTENDED_COLOR_LIGHT:    ltype = QLatin1String(\"Extended color light\"); break;\n            case DEV_ID_Z30_COLOR_TEMPERATURE_LIGHT: ltype = QLatin1String(\"Color temperature light\"); break;\n            case DEV_ID_ZLL_COLOR_TEMPERATURE_LIGHT: ltype = QLatin1String(\"Color temperature light\"); break;\n            default:\n                break;\n            }\n        }\n        else if (endpoint.profileId() == DIN_PROFILE_ID)\n        {\n            switch (deviceId)\n            {\n            case DEV_ID_DIN_XBEE:                    removeItem(RStateOn);\n                                                     removeItem(RStateAlert);\n                                                     addItem(DataTypeBool, RCapGroupsNotSupported);\n                                                     ltype = QLatin1String(\"Range extender\"); break;\n            default:\n                break;\n            }\n        }\n\n        item(RAttrType)->setValue(ltype);\n    }\n}\n\n/*! Returns the group capacity.\n */\nuint8_t LightNode::groupCapacity() const\n{\n    return m_groupCapacity;\n}\n\n/*! Sets the group capacity.\n    \\param capacity the group capacity\n */\nvoid LightNode::setGroupCapacity(uint8_t capacity)\n{\n    m_groupCapacity = capacity;\n}\n\n/*! Returns the resetRetryCount.\n */\nuint8_t LightNode::resetRetryCount() const\n{\n    return m_resetRetryCount;\n}\n\n/*! Sets the resetRetryCount.\n    \\param resetRetryCount the resetRetryCount\n */\nvoid LightNode::setResetRetryCount(uint8_t resetRetryCount)\n{\n    m_resetRetryCount = resetRetryCount;\n}\n\n/*! Returns the zdpResetSeq number.\n */\nuint8_t LightNode::zdpResetSeq() const\n{\n    return m_zdpResetSeq;\n}\n\n/*! Sets the zdpResetSeq number.\n    \\param resetRetryCount the resetRetryCount\n */\nvoid LightNode::setZdpResetSeq(uint8_t zdpResetSeq)\n{\n    m_zdpResetSeq = zdpResetSeq;\n}\n\n/*! Returns the group Count.\n */\nuint8_t LightNode::groupCount() const\n{\n    return m_groupCount;\n}\n\n/*! Sets the groupCount.\n    \\param groupCount the groupCount\n */\nvoid LightNode::setGroupCount(uint8_t groupCount)\n{\n    m_groupCount = groupCount;\n}\n\n/*! Returns the scene Capacity.\n */\nuint8_t LightNode::sceneCapacity() const\n{\n    return m_sceneCapacity;\n}\n\n/*! Sets the scene Capacity.\n    \\param sceneCapacity the scene Capacity\n */\nvoid LightNode::setSceneCapacity(uint8_t sceneCapacity)\n{\n    m_sceneCapacity = sceneCapacity;\n}\n\n/*! Parse the light resource items from a JSON string. */\nvoid LightNode::jsonToResourceItems(const QString &json)\n{\n    bool ok;\n    QVariant var = Json::parse(json, ok);\n\n    if (!ok)\n    {\n        return;\n    }\n\n    QVariantMap map = var.toMap();\n    QDateTime dt = QDateTime::currentDateTime().addSecs(-120);\n\n    if (map.contains(RAttrLastAnnounced))\n    {\n        QString lastannounced = map[RAttrLastAnnounced].toString();\n        QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\");\n        QDateTime la = QDateTime::fromString(lastannounced, format);\n        la.setTimeSpec(Qt::UTC);\n        map[RAttrLastAnnounced] = la;\n    }\n\n    if (map.contains(RAttrLastSeen))\n    {\n        QString lastseen = map[RAttrLastSeen].toString();\n        QString format = lastseen.length() == 20 ? QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\") : QLatin1String(\"yyyy-MM-ddTHH:mmZ\");\n        QDateTime ls = QDateTime::fromString(lastseen, format);\n        ls.setTimeSpec(Qt::UTC);\n        map[RAttrLastSeen] = ls;\n        if (ls < dt)\n        {\n            dt = ls;\n        }\n    }\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const char *key = item->descriptor().suffix;\n\n        if (map.contains(QLatin1String(key)))\n        {\n            if (item->descriptor().suffix == RAttrType && map[key] == QLatin1String(\"Unknown\"))\n            {\n                // type is set in setHaEndpoint()\n                continue;\n            }\n            item->setValue(map[key]);\n            item->setTimeStamps(dt);\n        }\n    }\n}\n\n/*! Transfers resource items into JSON string. */\nQString LightNode::resourceItemsToJson()\n{\n    QVariantMap map;\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const char *key = item->descriptor().suffix;\n        map[key] = item->toVariant();\n    }\n\n    return Json::serialize(map);\n}\n"
        },
        {
          "name": "light_node.h",
          "type": "blob",
          "size": 2.8564453125,
          "content": "/*\n * Copyright (c) 2016-2017 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef LIGHT_NODE_H\n#define LIGHT_NODE_H\n\n#include <QString>\n#include <deconz.h>\n#include \"resource.h\"\n#include \"rest_node_base.h\"\n#include \"group_info.h\"\n\n#define COLOR_CAP_HUE_SAT         (1 << 0)\n#define COLOR_CAP_ENHANCED_HUE    (1 << 1)\n#define COLOR_CAP_COLORLOOP       (1 << 2)\n#define COLOR_CAP_XY              (1 << 3)\n#define COLOR_CAP_CT              (1 << 4)\n\n/*! \\class LightNode\n\n    Represents a HA or ZLL based light.\n */\nclass LightNode : public Resource,\n                  public RestNodeBase\n{\npublic:\n    enum State\n    {\n        StateNormal,\n        StateDeleted\n    };\n\n    LightNode();\n    State state() const;\n    void setState(State state);\n    bool isAvailable() const override;\n    uint16_t manufacturerCode() const;\n    void setManufacturerCode(uint16_t code);\n    const QString &manufacturer() const;\n    void setManufacturerName(const QString &name);\n    const QString &modelId() const;\n    void setModelId(const QString &modelId);\n    const QString &swBuildId() const;\n    void setSwBuildId(const QString & swBuildId);\n    const QString &name() const;\n    void setName(const QString &name);\n    const QString &type() const;\n    std::vector<GroupInfo> &groups();\n    const std::vector<GroupInfo> &groups() const;\n    uint16_t otauClusterId() const;\n    void setOtauClusterId(uint16_t clusterId);\n    bool hasColor() const;\n    void setColorLoopActive(bool colorLoopActive);\n    bool isColorLoopActive() const;\n    bool supportsColorLoop() const;\n    void setColorLoopSpeed(uint8_t speed);\n    uint8_t colorLoopSpeed() const;\n    void didSetValue(ResourceItem *i) override;\n    void rx();\n    const deCONZ::SimpleDescriptor &haEndpoint() const;\n    void setHaEndpoint(const deCONZ::SimpleDescriptor &endpoint);\n    uint8_t groupCapacity() const;\n    void setGroupCapacity(uint8_t capacity);\n    uint8_t resetRetryCount() const;\n    void setResetRetryCount(uint8_t resetRetryCount);\n    uint8_t zdpResetSeq() const;\n    void setZdpResetSeq(uint8_t zdpResetSeq);\n    uint8_t groupCount() const;\n    void setGroupCount(uint8_t groupCount);\n    uint8_t sceneCapacity() const;\n    void setSceneCapacity(uint8_t sceneCapacity);\n    void jsonToResourceItems(const QString &json);\n    QString resourceItemsToJson();\n\n    QString etag;\n\nprivate:\n    State m_state;\n    uint8_t m_resetRetryCount;\n    uint8_t m_zdpResetSeq;\n    uint8_t m_groupCapacity;\n    uint16_t m_manufacturerCode;\n    uint16_t m_otauClusterId;\n    std::vector<GroupInfo> m_groups;\n    bool m_colorLoopActive;\n    uint8_t m_colorLoopSpeed;\n    quint8 m_haEndpoint = 255;\n    uint8_t m_groupCount;\n    uint8_t m_sceneCapacity;\n};\n\n#endif // LIGHT_NODE_H\n"
        },
        {
          "name": "linux",
          "type": "tree",
          "content": null
        },
        {
          "name": "occupancy_sensing.cpp",
          "type": "blob",
          "size": 7.650390625,
          "content": "#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"device_descriptions.h\"\n\n#define OCCUPIED_STATE                  0x0000\n#define OCCUPIED_TO_UNOCCUPIED_DELAY    0x0010\n\n/*! Handle packets related to the ZCL occupancy sensing cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the occupancy sensing cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleOccupancySensingClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    Sensor *sensor = getSensorNodeForAddressEndpointAndCluster(ind.srcAddress(), ind.srcEndpoint(), OCCUPANCY_SENSING_CLUSTER_ID );\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No presence sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    else if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n    }\n    else\n    {\n        return; // neither ZCL Report nor ZCL Read Attributes Response\n    }\n\n    const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n    bool configUpdated = false;\n    bool stateUpdated = false;\n\n    while (!stream.atEnd())\n    {\n        quint16 attrId;\n        quint8 attrTypeId;\n\n        stream >> attrId;\n        if (isReadAttr)\n        {\n            quint8 status;\n            stream >> status;  // Read Attribute Response status\n            if (status != deCONZ::ZclSuccessStatus)\n            {\n                continue;\n            }\n        }\n        stream >> attrTypeId;\n\n        deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n        if (!attr.readFromStream(stream))\n        {\n            continue;\n        }\n\n        ResourceItem *item = nullptr;\n\n        switch (attrId)\n        {\n        case OCCUPIED_STATE:\n        {\n            quint8 occupancy = attr.numericValue().u8;\n            item = sensor->item(RStatePresence);\n\n            if (item)\n            {\n                item->setValue(occupancy);\n                enqueueEvent(Event(RSensors, RStatePresence, sensor->id(), item));\n                stateUpdated = true;\n\n                DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Attr.val != 0\");\n\n                // The checked sensors support reporting occupancy = false\n                if (!sensor->modelId().startsWith(QLatin1String(\"MOSZB-1\")) && !sensor->modelId().startsWith(QLatin1String(\"SML00\")))\n                {\n                    const NodeValue &val = sensor->getZclValue(OCCUPANCY_SENSING_CLUSTER_ID, OCCUPIED_STATE);\n\n                    // prepare to automatically set presence to false\n                    if (item->toBool())\n                    {\n                        if (val.maxInterval > 0 && updateType == NodeValue::UpdateByZclReport)\n                        {\n                            // prevent setting presence back to false, when report.maxInterval > config.duration\n                            // Add 3 seconds grace time for late reports\n                            sensor->durationDue = item->lastSet().addSecs(val.maxInterval + 3);\n                        }\n                        else\n                        {\n                            ResourceItem *item2 = sensor->item(RConfigDuration);\n                            if (item2 && item2->toNumber() > 0)\n                            {\n                                // If occupied state is not reportable, add duration seconds after a occupied = true to automatically set to false\n                                sensor->durationDue = item->lastSet().addSecs(item2->toNumber());\n                            }\n                        }\n                    }\n                }\n            }\n\n            sensor->setZclValue(updateType, ind.srcEndpoint(), OCCUPANCY_SENSING_CLUSTER_ID, OCCUPIED_STATE, attr.numericValue());\n        }\n            break;\n\n        case OCCUPIED_TO_UNOCCUPIED_DELAY:\n        {\n            if (sensor->modelId() == QLatin1String(\"LG IP65 HMS\"))\n            {\n                // TODO(mpi): this can be removed, I don't think there are any users of this device (large industrial light+sensor)\n                quint16 duration = attr.numericValue().u16;\n                item = sensor->item(RConfigDuration);\n\n                if (!item) { item = sensor->addItem(DataTypeUInt16, RConfigDuration); }\n\n                if (item && item->toNumber() != duration)\n                {\n                    enqueueEvent(Event(RSensors, RConfigDuration, sensor->id(), item));\n\n                    if (item->toNumber() <= 0)\n                    {\n                        DBG_Printf(DBG_INFO, \"got occupied to unoccupied delay %u\\n\", duration);\n                        item->setValue(duration);\n                        configUpdated = true;\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO, \"occupied to unoccupied delay is %u should be %u, force rewrite\\n\", duration, (quint16)item->toNumber());\n                        if (!sensor->mustRead(WRITE_OCCUPANCY_CONFIG))\n                        {\n                            sensor->enableRead(WRITE_OCCUPANCY_CONFIG);\n                            sensor->setNextReadTime(WRITE_OCCUPANCY_CONFIG, queryTime);\n                            queryTime = queryTime.addSecs(1);\n                        }\n\n                        if (!sensor->mustRead(READ_OCCUPANCY_CONFIG))\n                        {\n                            sensor->enableRead(READ_OCCUPANCY_CONFIG);\n                            sensor->setNextReadTime(READ_OCCUPANCY_CONFIG, queryTime);\n                            queryTime = queryTime.addSecs(5);\n                        }\n\n                        Q_Q(DeRestPlugin);\n                        q->startZclAttributeTimer(750);\n                    }\n                }\n            }\n            else\n            {\n                quint16 delay = attr.numericValue().u16;\n                item = sensor->item(RConfigDelay);\n\n                if (item && item->toNumber() != delay)\n                {\n                    item->setValue(delay);\n                    enqueueEvent(Event(RSensors, RConfigDelay, sensor->id(), item));\n                    configUpdated = true;\n                }\n\n                if (sensor->mustRead(WRITE_DELAY))\n                {\n                    ResourceItem *item = sensor->item(RConfigPending);\n                    if (item)\n                    {\n                        quint16 mask = item->toNumber();\n                        mask &= ~R_PENDING_DELAY;\n                        item->setValue(mask);\n                        enqueueEvent(Event(RSensors, RConfigPending, sensor->id(), item));\n                    }\n                    sensor->clearRead(WRITE_DELAY);\n                }\n            }\n\n            sensor->setZclValue(updateType, ind.srcEndpoint(), OCCUPANCY_SENSING_CLUSTER_ID, OCCUPIED_TO_UNOCCUPIED_DELAY, attr.numericValue());\n        }\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    if (stateUpdated)\n    {\n        sensor->updateStateTimestamp();\n        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n    }\n\n    if (configUpdated || stateUpdated)\n    {\n        updateSensorEtag(&*sensor);\n        sensor->setNeedSaveDatabase(true);\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n    }\n}\n"
        },
        {
          "name": "permitJoin.cpp",
          "type": "blob",
          "size": 5.7880859375,
          "content": "/*\r\n * Copyright (c) 2016-2021 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n#include \"de_web_plugin.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"zdp/zdp.h\"\r\n\r\n/*! Inits permit join manager.\r\n\r\n    The manager will observe and ensure the global permit join state.\r\n */\r\nvoid DeRestPluginPrivate::initPermitJoin()\r\n{\r\n    permitJoinFlag = false;\r\n    permitJoinTimer = new QTimer(this);\r\n    permitJoinTimer->setSingleShot(false);\r\n    connect(permitJoinTimer, SIGNAL(timeout()),\r\n            this, SLOT(permitJoinTimerFired()));\r\n    permitJoinTimer->start(1000);\r\n}\r\n\r\n/*! Sets the permit join interval\r\n\r\n    \\param duration specifies the interval in which joining is enabled\r\n               - 0 disabled\r\n               - >0 duration in seconds until joining will be disabled\r\n\r\n */\r\nvoid DeRestPluginPrivate::setPermitJoinDuration(int duration)\r\n{\r\n    if (gwPermitJoinDuration != duration)\r\n    {\r\n        gwPermitJoinDuration = duration;\r\n    }\r\n\r\n    // force resend\r\n    permitJoinLastSendTime.invalidate();\r\n}\r\n\r\n/*! Handle broadcasting of permit join interval.\r\n\r\n    This is done every PERMIT_JOIN_SEND_INTERVAL to ensure\r\n    any node in the network has the same settings.\r\n */\r\nvoid DeRestPluginPrivate::permitJoinTimerFired()\r\n{\r\n    Q_Q(DeRestPlugin);\r\n    if (!q->pluginActive() || !apsCtrl)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwPermitJoinDuration > 0)\r\n    {\r\n        gwPermitJoinDuration--;\r\n\r\n        if (!permitJoinFlag)\r\n        {\r\n            permitJoinFlag = true;\r\n            enqueueEvent(Event(RConfig, REventPermitjoinEnabled, gwPermitJoinDuration));\r\n        }\r\n        else\r\n        {\r\n            enqueueEvent(Event(RConfig, REventPermitjoinRunning, gwPermitJoinDuration));\r\n        }\r\n\r\n        if (DEV_TestManaged())\r\n        {\r\n\r\n        }\r\n        else if ((gwPermitJoinDuration % 10) == 0) // TODO bad this needs to go\r\n        {\r\n            // try to add light nodes even if they existed in deCONZ bevor and therefore\r\n            // no node added event will be triggert in this phase\r\n            int i = 0;\r\n            const deCONZ::Node *node = nullptr;\r\n            while (apsCtrl->getNode(i, &node) == 0)\r\n            {\r\n                if (node && !node->isZombie() &&\r\n                        !node->nodeDescriptor().isNull() && node->nodeDescriptor().receiverOnWhenIdle())\r\n                {\r\n                    addLightNode(node);\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        else if ((gwPermitJoinDuration % 15) == 0) // TODO bad this needs to go\r\n        {\r\n            for (LightNode &l : nodes)\r\n            {\r\n                if (l.isAvailable() && l.modelId().isEmpty())\r\n                {\r\n                    queuePollNode(&l);\r\n                }\r\n            }\r\n        }\r\n\r\n        updateEtag(gwConfigEtag); // update Etag so that webApp can count down permitJoin duration\r\n    }\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        return;\r\n    }\r\n\r\n    auto ctrlPermitJoin = apsCtrl->getParameter(deCONZ::ParamPermitJoin);\r\n    if (ctrlPermitJoin > 0 && gwPermitJoinDuration == 0)\r\n    {\r\n        // workaround since the firmware reports cached value instead hot value\r\n        apsCtrl->setPermitJoin(gwPermitJoinDuration);\r\n        permitJoinLastSendTime.invalidate(); // force broadcast\r\n    }\r\n\r\n    if (!permitJoinFlag)\r\n    {\r\n\r\n    }\r\n    else if (!permitJoinLastSendTime.isValid() || (permitJoinLastSendTime.elapsed() > PERMIT_JOIN_SEND_INTERVAL && !gwdisablePermitJoinAutoOff))\r\n    {\r\n        deCONZ::ApsDataRequest apsReq;\r\n        quint8 tcSignificance = 0x01;\r\n\r\n        apsReq.setDstAddressMode(deCONZ::ApsNwkAddress);\r\n        apsReq.dstAddress().setNwk(deCONZ::BroadcastRouters);\r\n        apsReq.setProfileId(ZDP_PROFILE_ID);\r\n        apsReq.setClusterId(ZDP_MGMT_PERMIT_JOINING_REQ_CLID);\r\n        apsReq.setDstEndpoint(ZDO_ENDPOINT);\r\n        apsReq.setSrcEndpoint(ZDO_ENDPOINT);\r\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\r\n        apsReq.setTxOptions(0);\r\n#endif\r\n        apsReq.setRadius(0);\r\n\r\n        QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\r\n        stream.setByteOrder(QDataStream::LittleEndian);\r\n\r\n        static_assert (PERMIT_JOIN_SEND_INTERVAL / 1000 < 180, \"permit join send interval < 180 seconds\");\r\n        static_assert (PERMIT_JOIN_SEND_INTERVAL / 1000 > 30, \"permit join send interval > 30 seconds\");\r\n\r\n        int duration = qMin(gwPermitJoinDuration, (PERMIT_JOIN_SEND_INTERVAL / 1000) + 5);\r\n\r\n        stream << ZDP_NextSequenceNumber();\r\n        stream << static_cast<quint8>(duration);\r\n        stream << tcSignificance;\r\n\r\n        // set for own node\r\n        apsCtrl->setPermitJoin(duration);\r\n\r\n        // broadcast\r\n        if (apsCtrl->apsdeDataRequest(apsReq) == deCONZ::Success)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"send permit join, duration: %d\\n\", duration);\r\n            permitJoinLastSendTime.restart();\r\n\r\n            if (gwPermitJoinDuration > 0)\r\n            {\r\n                GP_SendProxyCommissioningMode(apsCtrl, zclSeq++);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"send permit join failed\\n\");\r\n        }\r\n    }\r\n\r\n    if (gwPermitJoinDuration == 0 && permitJoinFlag)\r\n    {\r\n        permitJoinApiKey.clear();\r\n        permitJoinFlag = false;\r\n        enqueueEvent(Event(RConfig, REventPermitjoinDisabled, 0));\r\n    }\r\n}\r\n\r\nvoid DeRestPluginPrivate::permitJoin(int seconds)\r\n{\r\n    if (seconds > 0)\r\n    {\r\n        int tmp = gwNetworkOpenDuration; // preserve configured duration\r\n        gwNetworkOpenDuration = seconds;\r\n        startSearchSensors();\r\n        startSearchLights();\r\n        gwNetworkOpenDuration = tmp;\r\n    }\r\n    else\r\n    {\r\n        gwPermitJoinDuration = 0;\r\n    }\r\n}\r\n"
        },
        {
          "name": "poll_control.cpp",
          "type": "blob",
          "size": 6.798828125,
          "content": "/*\n * Copyright (c) 2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"poll_control.h\"\n\nstatic void handleCheckinCommand(DeRestPluginPrivate *plugin, const deCONZ::ApsDataIndication &ind)\n{\n    std::vector<Resource*> resources;\n\n    for (auto &s : plugin->sensors)\n    {\n        if (s.address().ext() == ind.srcAddress().ext() && s.deletedState() == Sensor::StateNormal && s.item(RConfigCheckin))\n        {\n            resources.push_back(&s);\n            s.setNeedSaveDatabase(true);\n        }\n    }\n\n    if (!resources.empty())\n    {\n        plugin->queSaveDb(DB_SENSORS, DB_LONG_SAVE_DELAY);\n    }\n\n    //        stick to sensors for now, perhaps we need to add lights later on\n    //        for (auto &n : plugin->nodes)\n    //        {\n    //            if (n.address().ext() == ind.srcAddress().ext() && n.state() == LightNode::StateNormal)\n    //            {\n    //                resources.push_back(&n);\n    //            }\n    //        }\n\n    const auto now = QDateTime::currentDateTimeUtc();\n\n    for (auto *r : resources)\n    {\n        auto *item = r->item(RStateLastCheckin);\n        if (!item)\n        {\n            item = r->addItem(DataTypeTime, RStateLastCheckin);\n        }\n\n        Q_ASSERT(item);\n        if (item)\n        {\n            item->setIsPublic(false);\n            item->setValue(now);\n            enqueueEvent(Event(r->prefix(), item->descriptor().suffix, r->toString(RAttrId), item));\n        }\n\n        if (r->prefix() == RSensors)\n        {\n            plugin->checkPollControlClusterTask(dynamic_cast<Sensor*>(r));\n        }\n    }\n\n    DBG_Printf(DBG_INFO, \"Poll control check-in from 0x%016llX\\n\", ind.srcAddress().ext());\n}\n\nvoid DeRestPluginPrivate::handlePollControlIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isClusterCommand() && (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient) && zclFrame.commandId() == POLL_CONTROL_CMD_CHECKIN)\n    {\n        handleCheckinCommand(this, ind);\n    }\n}\n\n/*! Checks open tasks for poll control cluster.\n    \\return true - when a binding or APS request got queued.\n */\nbool DeRestPluginPrivate::checkPollControlClusterTask(Sensor *sensor)\n{\n    if (!sensor)\n    {\n        return false;\n    }\n\n    if (!sensor->node())\n    {\n        return false;\n    }\n\n    if (searchSensorsState == SearchSensorsActive)\n    {\n        // defer this until other items have been processed\n        return false;\n    }\n\n    ResourceItem *item = sensor->item(RConfigPending);\n    if (!item)\n    {\n        return false;\n    }\n\n    if ((item->toNumber() & (R_PENDING_WRITE_POLL_CHECKIN_INTERVAL | R_PENDING_SET_LONG_POLL_INTERVAL)) == 0)\n    {\n        return false; // nothing to do\n    }\n\n    if (sensor->node()->simpleDescriptors().empty())\n    {\n        return false; // only proceed when simple descriptors are queried\n    }\n\n    const quint8 pcEndpoint = PC_GetPollControlEndpoint(sensor->node());\n    if (pcEndpoint == 0)\n    {\n        // not supported, remove\n        item->setValue(item->toNumber() & ~(R_PENDING_WRITE_POLL_CHECKIN_INTERVAL | R_PENDING_SET_LONG_POLL_INTERVAL));\n        return false;\n    }\n\n    if (sensor->node()->nodeDescriptor().manufacturerCode() == VENDOR_IKEA && (item->toNumber() & R_PENDING_SET_LONG_POLL_INTERVAL) != 0)\n    {\n        // for IKEA devices leave long poll interval at factory default settings\n        // TODO configure in DDF\n        item->setValue(item->toNumber() & ~(R_PENDING_SET_LONG_POLL_INTERVAL));\n    }\n\n    if (item->toNumber() & R_PENDING_WRITE_POLL_CHECKIN_INTERVAL)\n    {\n        ResourceItem *configCheckin = sensor->item(RConfigCheckin);\n\n        // write poll control checkin interval\n        deCONZ::ZclAttribute attr(0x0000, deCONZ::Zcl32BitUint, QLatin1String(\"Check-in interval\"), deCONZ::ZclReadWrite, false);\n        if (configCheckin && configCheckin->toNumber() > (4 * 60))\n        {\n            attr.setValue(static_cast<quint64>(configCheckin->toNumber()));\n        }\n        else\n        {\n            attr.setValue(static_cast<quint64>(14400)); // 1 hour in 0.25 seconds\n        }\n\n        DBG_Printf(DBG_INFO, \"Write poll cluster check-in interval for 0x%016llx\\n\", sensor->address().ext());\n\n        if (writeAttribute(sensor, pcEndpoint, POLL_CONTROL_CLUSTER_ID, attr, 0))\n        {\n            // mark done\n            item->setValue(item->toNumber() & ~R_PENDING_WRITE_POLL_CHECKIN_INTERVAL);\n            return true;\n        }\n\n        return false; // only send Set Long Poll Interval after writing this attribute\n    }\n\n    if (item->toNumber() & R_PENDING_SET_LONG_POLL_INTERVAL)\n    {\n        deCONZ::ApsDataRequest apsReq;\n\n         // ZDP Header\n         apsReq.dstAddress() = sensor->address();\n         apsReq.setDstAddressMode(deCONZ::ApsExtAddress);\n         apsReq.setDstEndpoint(pcEndpoint);\n         apsReq.setSrcEndpoint(endpoint());\n         apsReq.setProfileId(HA_PROFILE_ID);\n         apsReq.setRadius(0);\n         apsReq.setClusterId(POLL_CONTROL_CLUSTER_ID);\n         apsReq.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n\n         deCONZ::ZclFrame outZclFrame;\n         outZclFrame.setSequenceNumber(static_cast<quint8>(QDateTime::currentMSecsSinceEpoch()));\n         outZclFrame.setCommandId(0x02); // set long poll interval\n         outZclFrame.setFrameControl(deCONZ::ZclFCClusterCommand | deCONZ::ZclFCDirectionClientToServer);\n\n         { // ZCL payload\n             QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n             stream.setByteOrder(QDataStream::LittleEndian);\n             // TODO this needs to be device dependend and configured via a RConfigLongPoll\n             const quint32 longPollInterval = 4 * 60 * 15; // 15 minutes in quarter seconds\n             stream << longPollInterval;\n         }\n\n         { // ZCL frame\n             QDataStream stream(&apsReq.asdu(), QIODevice::WriteOnly);\n             stream.setByteOrder(QDataStream::LittleEndian);\n             outZclFrame.writeToStream(stream);\n         }\n\n         if (apsCtrlWrapper.apsdeDataRequest(apsReq) == deCONZ::Success)\n         {\n             item->setValue(item->toNumber() & ~R_PENDING_SET_LONG_POLL_INTERVAL);\n             return true;\n         }\n    }\n\n    return false;\n}\n\n/*! Returns the endpoint of the Poll Control server cluster.\n    \\return 0 if not found.\n    \\return >0 endpoint if found.\n */\nquint8 PC_GetPollControlEndpoint(const deCONZ::Node *node)\n{\n    if (!node)\n    {\n        return 0;\n    }\n\n    for (const auto &sd : node->simpleDescriptors())\n    {\n        for (const auto &cl : sd.inClusters())\n        {\n            if (cl.id() == POLL_CONTROL_CLUSTER_ID)\n            {\n                return sd.endpoint();\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "poll_control.h",
          "type": "blob",
          "size": 0.9423828125,
          "content": "/*\n * Copyright (c) 2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef POLL_CONTROL_H\n#define POLL_CONTROL_H\n\n// commands send by server\n#define POLL_CONTROL_CMD_CHECKIN                 0x00\n// commands send by client\n#define POLL_CONTROL_CMD_CHECKIN_RESPONSE        0x00\n#define POLL_CONTROL_CMD_FAST_POLL_STOP          0x01\n#define POLL_CONTROL_CMD_SET_LONG_POLL_INTERVAL  0x02\n#define POLL_CONTROL_CMD_SET_SHORT_POLL_INTERVAL 0x03\n\n/* Poll Control cluster\n\n   RStateLastCheckin   book keeping of the last received check-in timestamp\n   RConfigCheckin      configuration of the check-in interval\n   RConfigLongPoll     configuration of the long poll interval\n */\n\nquint8 PC_GetPollControlEndpoint(const deCONZ::Node *node);\n\n#endif // POLL_CONTROL_H\n"
        },
        {
          "name": "poll_manager.cpp",
          "type": "blob",
          "size": 18.365234375,
          "content": "/*\n * Copyright (c) 2017-2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"poll_manager.h\"\n#include \"de_web_plugin_private.h\"\n#include \"utils/utils.h\"\n\n/*! Constructor.\n */\nPollManager::PollManager(QObject *parent) :\n    QObject(parent)\n{\n    pollState = StateIdle;\n    timer = new QTimer(this);\n    timer->setSingleShot(true);\n    connect(timer, SIGNAL(timeout()), this, SLOT(pollTimerFired()));\n    plugin = qobject_cast<DeRestPluginPrivate*>(parent);\n}\n\n/*! Queues polling of the node.\n    \\param restNode - the node to poll\n */\nvoid PollManager::poll(RestNodeBase *restNode, const QDateTime &tStart)\n{\n    Resource *r = dynamic_cast<Resource*>(restNode);\n    DBG_Assert(r);\n    if (!r || !restNode->node())\n    {\n        return;\n    }\n\n    DBG_Assert(!hasItems());\n\n    PollItem pitem;\n\n    if (!restNode->node()->nodeDescriptor().receiverOnWhenIdle())\n    {\n        auto *item = r->item(RCapSleeper);\n        if (!item || item->toBool())\n        {\n            return;\n        }\n    }\n\n    LightNode *lightNode = nullptr;\n    Sensor *sensor = nullptr;\n\n    if (r->prefix() == RLights)\n    {\n        lightNode = dynamic_cast<LightNode*>(restNode);\n        DBG_Assert(lightNode);\n        if (!lightNode || lightNode->state() != LightNode::StateNormal)\n        {\n            return;\n        }\n        pitem.endpoint = lightNode->haEndpoint().endpoint();\n        DBG_Printf(DBG_INFO_L2, \"Poll light node %s\\n\", qPrintable(lightNode->name()));\n    }\n    else if (r->prefix() == RSensors)\n    {\n        sensor = dynamic_cast<Sensor*>(restNode);\n        DBG_Assert(sensor);\n        if (!sensor || sensor->deletedState() != Sensor::StateNormal)\n        {\n            return;\n        }\n        pitem.endpoint = sensor->fingerPrint().endpoint;\n        DBG_Printf(DBG_INFO_L2, \"Poll %s sensor node %s\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()));\n    }\n    else\n    {\n        return;\n    }\n\n    pitem.id = restNode->id();\n    pitem.prefix = r->prefix();\n    pitem.address = restNode->address();\n    pitem.tStart = tStart;\n\n    for (int i = 0; i < r->itemCount(); i++)\n    {\n        const ResourceItem *item = r->itemForIndex(i);\n        const char *suffix = item ? item->descriptor().suffix : nullptr;\n\n        if (plugin->permitJoinFlag)\n        {\n            // limit queries during joining\n            if (suffix == RAttrModelId || suffix == RAttrSwVersion)\n            {\n                pitem.items.push_back(suffix);\n            }\n        }\n        else if (lightNode && lightNode->type() == QLatin1String(\"Window covering device\"))\n        {\n            if (suffix == RStateLift ||\n                suffix == RAttrModelId ||\n                suffix == RAttrSwVersion)\n            {\n                pitem.items.push_back(suffix);\n            }\n        }\n        else if (suffix == RStateOn ||\n            suffix == RStateBri ||\n            suffix == RStateColorMode ||\n            (suffix == RStateConsumption && sensor && sensor->type() == QLatin1String(\"ZHAConsumption\")) ||\n            (suffix == RStatePower && sensor && sensor->type() == QLatin1String(\"ZHAPower\")) ||\n            (suffix == RStatePresence && sensor && sensor->type() == QLatin1String(\"ZHAPresence\")) ||\n            (suffix == RStateLightLevel && sensor && sensor->type() == QLatin1String(\"ZHALightLevel\")) ||\n            suffix == RAttrModelId ||\n            suffix == RAttrSwVersion)\n        {\n            // DBG_Printf(DBG_INFO_L2, \"    attribute %s\\n\", suffix);\n            pitem.items.push_back(suffix);\n        }\n    }\n\n    for (PollItem &i : items)\n    {\n        if (i.prefix == r->prefix() && i.id == restNode->id())\n        {\n            i.items = pitem.items; // update\n            if (tStart.isValid())\n            {\n                i.tStart = tStart;\n            }\n            return;\n        }\n    }\n\n    items.push_back(pitem);\n\n    if (!timer->isActive())\n    {\n        timer->start(100);\n    }\n}\n\n/*! Delays polling for \\p ms milliseconds.\n */\nvoid PollManager::delay(int ms)\n{\n    timer->stop();\n    timer->start(ms);\n}\n\n/*! Handle APS confirm if related to polling.\n */\nvoid PollManager::apsdeDataConfirm(const deCONZ::ApsDataConfirm &conf)\n{\n    if (pollState != StateWait)\n    {\n        return;\n    }\n\n    if (apsReqId != conf.id())\n    {\n        return;\n    }\n\n    if (!isSameAddress(dstAddr, conf.dstAddress()))\n    {\n        return;\n    }\n\n    DBG_Printf(DBG_INFO_L2, \"Poll APS confirm %u status: 0x%02X\\n\", conf.id(), conf.status());\n\n    if (!items.empty() && conf.status() != deCONZ::ApsSuccessStatus)\n    {\n        PollItem &pitem = items.front();\n\n        for (auto &i : pitem.items)\n        {\n            if (i)\n            {\n                DBG_Printf(DBG_INFO_L2, \"\\t drop item %s\\n\", i);\n                i = nullptr; // clear\n            }\n        }\n    }\n\n    pollState = StateIdle;\n    timer->stop();\n    timer->start(1);\n}\n\n/*! Timer callback to proceed polling.\n */\nvoid PollManager::pollTimerFired()\n{\n    if (pollState == StateDone)\n    {\n        pollState = StateIdle;\n        timer->start(50);\n        emit done();\n        return;\n    }\n\n    if (pollState == StateWait)\n    {\n        DBG_Printf(DBG_INFO, \"timeout on poll APS confirm\\n\");\n        pollState = StateIdle;\n    }\n\n    DBG_Assert(pollState == StateIdle);\n\n    if (items.empty())\n    {\n        pollState = StateDone;\n        timer->start(500);\n        return;\n    }\n\n    QDateTime now = QDateTime::currentDateTime();\n    PollItem &pitem = items.front();\n    Resource *r = plugin->getResource(pitem.prefix, pitem.id);\n    ResourceItem *item = nullptr;\n    RestNodeBase *restNode = nullptr;\n    const LightNode *lightNode = nullptr;\n    if (r && r->prefix() == RLights)\n    {\n        restNode = dynamic_cast<RestNodeBase*>(r);\n        lightNode = dynamic_cast<LightNode*>(restNode);\n        item = r->item(RStateReachable);\n    }\n    else if (r && r->prefix() == RSensors)\n    {\n        restNode = dynamic_cast<RestNodeBase*>(r);\n        item = r->item(RConfigReachable);\n    }\n\n    if (pitem.tStart.isValid() && pitem.tStart > now)\n    {\n        if (items.size() > 1)\n        {\n            PollItem tmp = pitem;\n            items.front() = items.back();\n            items.back() = tmp;\n        }\n        timer->start(1);\n        return;\n    }\n\n    if (!r || pitem.items.empty() ||\n        !restNode ||\n        //!restNode->lastRx().isValid() ||\n        !item || !item->toBool()) // not reachable\n    {\n        items.front() = items.back();\n        items.pop_back();\n        timer->start(1);\n        return;\n    }\n\n    //const auto dtReachable = item->lastSet().secsTo(now);\n\n    quint16 clusterId = 0xffff; // invalid\n    std::vector<quint16> attributes;\n\n    item = r->item(RStateOn);\n    bool isOn = item ? item->toBool() : false;\n    const char *&suffix = pitem.items[0];\n\n    for (size_t i = 0; pitem.items[0] == nullptr && i < pitem.items.size(); i++)\n    {\n        if (pitem.items[i] != nullptr)\n        {\n            pitem.items[0] = pitem.items[i]; // move to front\n            pitem.items[i] = nullptr; // clear\n            break;\n        }\n    }\n\n    if (!suffix)\n    {\n        pitem.items.clear(); // all done\n    }\n\n    if (suffix == RStateOn && lightNode)\n    {\n        clusterId = ONOFF_CLUSTER_ID;\n        attributes.push_back(0x0000); // onOff\n    }\n    else if (suffix == RStateBri && isOn)\n    {\n        NodeValue &val = restNode->getZclValue(LEVEL_CLUSTER_ID, 0x0000);\n\n        if (isOn || !val.timestamp.isValid())\n        {\n            clusterId = LEVEL_CLUSTER_ID;\n            attributes.push_back(0x0000); // current level\n        }\n    }\n    else if (suffix == RStateColorMode && lightNode)\n    {\n        clusterId = COLOR_CLUSTER_ID;\n        item = r->item(RCapColorCapabilities);\n\n        if ((!item || item->toNumber() <= 0) && (lightNode->haEndpoint().profileId() == ZLL_PROFILE_ID || lightNode->manufacturerCode() == VENDOR_XIAOMI || lightNode->manufacturerCode() == VENDOR_MUELLER || lightNode->manufacturerCode() == VENDOR_XAL || lightNode->manufacturerCode() == VENDOR_LEDVANCE))\n        {\n            if (item && lightNode->modelId() == QLatin1String(\"lumi.light.aqcn02\"))\n            {\n                item->setValue(0x0010); // color capabilities are not supported, set here\n            }\n\n            attributes.push_back(0x0008); // color mode\n            attributes.push_back(0x4001); // enhanced color mode\n            attributes.push_back(0x400a); // color capabilities\n            attributes.push_back(0x400b); // color temperature min\n            attributes.push_back(0x400c); // color temperature max\n        }\n        else\n        {\n            quint16 cap = item ? static_cast<quint16>(item->toNumber()) : 0;\n            std::vector<quint16> toCheck;\n\n            if (cap == 0 && lightNode->haEndpoint().profileId() == HA_PROFILE_ID)\n            {\n                // e.g. OSRAM US version\n                // DEV_ID_HA_COLOR_DIMMABLE_LIGHT\n                cap  = (0x0001 | 0x0008 | 0x0010); // hue, saturation, color mode, xy, ct\n            }\n\n            toCheck.push_back(0x0008); // color mode\n            toCheck.push_back(0x4001); // enhanced color mode\n\n            // if reading 0x400x attributes fail with response 0x86 they will be marked\n            // as not available and will be ignored in further poll cycles\n\n            if (cap & 0x0002) // enhanced hue supported\n            {\n                toCheck.push_back(0x4000); // enhanced hue\n                toCheck.push_back(0x0001); // saturation\n            }\n            else if (cap & 0x0001)\n            {\n                toCheck.push_back(0x0000); // hue\n                toCheck.push_back(0x0001); // saturation\n            }\n\n            if (cap & 0x0004)\n            {\n                toCheck.push_back(0x4002); // Color loop active\n            }\n\n            if (cap & 0x0008)\n            {\n                toCheck.push_back(0x0003); // currentX\n                toCheck.push_back(0x0004); // currentY\n            }\n\n            if (cap & 0x0010)\n            {\n                toCheck.push_back(0x0007); // color temperature\n            }\n\n            for (const deCONZ::ZclCluster &cl : lightNode->haEndpoint().inClusters())\n            {\n                if (cl.id() != COLOR_CLUSTER_ID)\n                {\n                    continue;\n                }\n\n                for (const deCONZ::ZclAttribute &attr : cl.attributes())\n                {\n                    for (quint16 attrId : toCheck)\n                    {\n                        // discard attributes which are not be available\n                        if (attrId == attr.id() && attr.isAvailable())\n                        {\n                            NodeValue &val = restNode->getZclValue(clusterId, attrId);\n                            if (isOn || !val.timestamp.isValid())\n                            {\n                                attributes.push_back(attrId);\n                            }\n                        }\n                    }\n                }\n\n                break;\n            }\n        }\n    }\n    else if (suffix == RStatePresence)\n    {\n        clusterId = OCCUPANCY_SENSING_CLUSTER_ID;\n        attributes.push_back(0x0000); // Occupancy\n        attributes.push_back(0x0010); // PIR Occupied To Unoccupied Delay\n    }\n    else if (suffix == RStateLightLevel)\n    {\n        clusterId = ILLUMINANCE_MEASUREMENT_CLUSTER_ID;\n        attributes.push_back(0x0000); // Measured Value\n    }\n    else if (suffix == RStateConsumption)\n    {\n        clusterId = METERING_CLUSTER_ID;\n        attributes.push_back(0x0000); // Current Summation Delivered\n        attributes.push_back(0x0400); // Instantaneous Demand\n    }\n    else if (suffix == RStatePower)\n    {\n        clusterId = ELECTRICAL_MEASUREMENT_CLUSTER_ID;\n        attributes.push_back(0x050b); // Active Power\n        attributes.push_back(0x0505); // RMS Voltage\n        attributes.push_back(0x0508); // RMS Current\n    }\n    else if (suffix == RStateLift)\n    {\n        clusterId = WINDOW_COVERING_CLUSTER_ID;\n        attributes.push_back(0x0008); // Current Position Lift Percentage\n\n        NodeValue &val = restNode->getZclValue(clusterId, 0x0008);\n        if (val.isValid() && val.maxInterval == 0)\n        {\n            val.maxInterval = 10;\n        }\n    }\n    else if (suffix == RAttrModelId)\n    {\n        item = r->item(RAttrModelId);\n        if (item && (item->toString().isEmpty() || (item->lastSet().secsTo(now) > READ_MODEL_ID_INTERVAL && item->toString().startsWith(\"FLS-A\")))) // dynamic model ids\n        {\n            clusterId = BASIC_CLUSTER_ID;\n            //attributes.push_back(0x0004); // manufacturer\n            attributes.push_back(0x0005); // model id\n        }\n    }\n    else if (suffix == RAttrSwVersion && lightNode)\n    {\n        item = r->item(RAttrSwVersion);\n        if (item && (item->toString().isEmpty() ||\n             (item->lastSet().secsTo(now) > READ_SWBUILD_ID_INTERVAL))) // dynamic\n        {\n            if (lightNode->manufacturerCode() == VENDOR_EMBER && lightNode->modelId() == QLatin1String(\"TS011F\")) // Tuya plugs\n            {\n                if (item->toString().isEmpty())\n                {\n                    attributes.push_back(0x0001);  // application version\n                    clusterId = BASIC_CLUSTER_ID;\n                }\n            }\n            else if (lightNode->manufacturerCode() == VENDOR_UBISYS ||\n                lightNode->manufacturerCode() == VENDOR_EMBER ||\n                lightNode->manufacturerCode() == VENDOR_HEIMAN ||\n                lightNode->manufacturerCode() == VENDOR_XIAOMI ||\n                lightNode->manufacturerCode() == VENDOR_DEVELCO ||\n                lightNode->manufacturer().startsWith(QLatin1String(\"Climax\")) ||\n                lightNode->manufacturer() == QLatin1String(\"SZ\"))\n            {\n                if (item->toString().isEmpty())\n                {\n                    attributes.push_back(0x0006); // date code\n                    clusterId = BASIC_CLUSTER_ID;\n                }\n            }\n            else\n            {\n                if (item->toString().isEmpty() ||\n                    lightNode->manufacturerCode() == VENDOR_IKEA ||\n                    lightNode->manufacturerCode() == VENDOR_OSRAM ||\n                    lightNode->manufacturerCode() == VENDOR_OSRAM_STACK ||\n                    lightNode->manufacturerCode() == VENDOR_XAL ||\n                    lightNode->manufacturerCode() == VENDOR_PHILIPS ||\n                    lightNode->manufacturerCode() == VENDOR_DDEL)\n                {\n                    attributes.push_back(0x4000); // sw build id\n                    clusterId = BASIC_CLUSTER_ID;\n                }\n            }\n        }\n    }\n\n    size_t fresh = 0;\n    const int reportWaitTime = 360;\n\n    // check that cluster exists on endpoint\n    if (clusterId != 0xffff)\n    {\n        bool found = false;\n        const deCONZ::SimpleDescriptor *sd = getSimpleDescriptor(restNode->node(), pitem.endpoint);\n        if (sd)\n        {\n            for (const auto &cl : sd->inClusters())  // Loop through clusters\n            {\n                if (cl.id() == clusterId)\n                {\n                    found = true;\n\n                    std::vector<quint16> check;\n\n                    for (const deCONZ::ZclAttribute &attr : cl.attributes())    // Loop through cluster attributes\n                    {\n                        for (quint16 attrId : attributes)   // Loop through poll candidates\n                        {\n                            // discard attributes which are not be available\n                            if (attrId == attr.id() && attr.isAvailable())\n                            {\n                                if (attr.dataType_t() == deCONZ::ZclCharacterString && attr.toString().isEmpty() && attr.lastRead() <= 0)\n                                {\n                                    continue; // skip empty string attributes which are available, read only once\n                                }\n\n                                check.push_back(attr.id());     // Only use available attributes\n\n                                if (cl.id() == BASIC_CLUSTER_ID)\n                                {\n                                    continue; // don't rely on reporting\n                                }\n\n                                NodeValue &val = restNode->getZclValue(clusterId, attrId);\n                                quint16 maxInterval = val.maxInterval > 0 && val.maxInterval < 65535 ? (val.maxInterval * 3 / 2) : reportWaitTime;\n\n                                // This should truely compensates missing reports and poll at startup until a report comes in, prevents unnecessary polling\n                                if (val.timestampLastReport.isValid() && val.timestampLastReport.secsTo(now) < maxInterval)\n                                {\n                                    fresh++;\n                                }\n                            }\n                        }\n                    }\n\n                    attributes = check;     // reassign filtered attributes\n                    break;\n                }\n            }\n        }\n\n        if (!found)\n        {\n            DBG_Printf(DBG_INFO_L2, \"Poll APS request to 0x%016llX cluster: 0x%04X dropped, cluster doesn't exist\\n\", pitem.address.ext(), clusterId);\n            clusterId = 0xffff;\n        }\n    }\n\n    if (clusterId != 0xffff && fresh > 0 && fresh == attributes.size())\n    {\n        DBG_Printf(DBG_INFO_L2, \"Poll APS request to 0x%016llX cluster: 0x%04X dropped, values are fresh enough\\n\", pitem.address.ext(), clusterId);\n        suffix = nullptr; // clear\n        timer->start(100);\n    }\n    else if (!attributes.empty() && clusterId != 0xffff &&\n        plugin->readAttributes(restNode, pitem.endpoint, clusterId, attributes))\n    {\n        pollState = StateWait;\n        // TODO this hack to get aps request id\n        DBG_Assert(plugin->tasks.back().taskType == TaskReadAttributes);\n        apsReqId = plugin->tasks.back().req.id();\n        dstAddr = pitem.address;\n        timer->start(60 * 1000); // wait for confirm\n        suffix = nullptr; // clear\n        DBG_Printf(DBG_INFO_L2, \"Poll APS request %u to 0x%016llX cluster: 0x%04X\\n\", apsReqId, dstAddr.ext(), clusterId);\n    }\n    else if (suffix)\n    {\n        suffix = nullptr; // clear\n        timer->start(100);\n    }\n    else\n    {\n        if (clusterId != 0xffff)\n        {\n            DBG_Printf(DBG_INFO_L2, \"Poll APS request to 0x%016llX cluster: 0x%04X dropped\\n\", pitem.address.ext(), clusterId);\n        }\n        timer->start(100);\n        items.front() = items.back();\n        items.pop_back();\n    }\n}\n"
        },
        {
          "name": "poll_manager.h",
          "type": "blob",
          "size": 1.47265625,
          "content": "/*\n * Copyright (c) 2017 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef POLL_MANAGER_H\n#define POLL_MANAGER_H\n\n#include <QObject>\n#include <QDateTime>\n#include <vector>\n#include <deconz.h>\n\nclass QTimer;\nclass DeRestPluginPrivate;\nclass RestNodeBase;\n\n/*! \\class PollItem\n\n    Item representing a node in the polling queue.\n */\nclass PollItem\n{\npublic:\n    // Resource related\n    QString id;\n    const char *prefix;\n    std::vector<const char*> items;\n    QDateTime tStart;\n    // APS\n    quint8 endpoint;\n    deCONZ::Address address;\n};\n\n/*! \\class PollManager\n\n    Service to handle periodically polling of nodes.\n */\nclass PollManager : public QObject\n{\n    Q_OBJECT\npublic:\n    enum PollState {\n        StateIdle,\n        StateWait,\n        StateDone\n    };\n    explicit PollManager(QObject *parent = 0);\n    void poll(RestNodeBase *restNode, const QDateTime &tStart = QDateTime());\n    void delay(int ms);\n    bool hasItems() const { return !items.empty(); }\n\nsignals:\n    void done();\n\npublic slots:\n    void apsdeDataConfirm(const deCONZ::ApsDataConfirm &conf);\n    void pollTimerFired();\n\nprivate:\n    QTimer *timer;\n    std::vector<PollItem> items;\n    DeRestPluginPrivate *plugin;\n    PollState pollState;\n    quint8 apsReqId;\n    deCONZ::Address dstAddr;\n};\n\n#endif // POLL_MANAGER_H\n"
        },
        {
          "name": "power_configuration.cpp",
          "type": "blob",
          "size": 17.2138671875,
          "content": "#include \"device_descriptions.h\"\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"utils/utils.h\"\n\n#define POWER_CONFIG_ATTRID_BATTERY_VOLTAGE               0x0020\n#define POWER_CONFIG_ATTRID_BATTERY_PERCENTAGE_REMAINING  0x0021\n#define POWER_CONFIG_ATTRID_BATTERY_ALARM_MASK            0x0035\n\nstatic quint8 calculateBatteryPercentageRemaining(const Resource *r, ResourceItem *item, const quint8 batteryVoltage, const float vmin, const float vmax)\n{\n    float batteryPercentage = batteryVoltage;\n\n    if      (batteryPercentage > vmax) { batteryPercentage = vmax; }\n    else if (batteryPercentage < vmin) { batteryPercentage = vmin; }\n\n    batteryPercentage = ((batteryPercentage - vmin) / (vmax - vmin)) * 100;\n\n    if      (batteryPercentage > 100) { batteryPercentage = 100; }\n    else if (batteryPercentage <= 0)  { batteryPercentage = 1; } // ?\n\n    if (r && item)\n    {\n        const int maxSize = 384;\n        auto jsEval = std::make_unique<char[]>(maxSize);\n        int ret = snprintf(jsEval.get(), maxSize,\n                          \"const vmin = %u;\"\n                          \" const vmax = %u;\"\n                          \" let bat = Attr.val;\"\n\n                          \" if (bat > vmax) { bat = vmax; }\"\n                          \" else if (bat < vmin) { bat = vmin; }\"\n\n                          \" bat = ((bat - vmin) / (vmax - vmin)) * 100;\"\n\n                          \" if (bat > 100) { bat = 100; }\"\n                          \" else if (bat <= 0)  { bat = 1; }\"\n\n                          \" Item.val = bat;\", unsigned(vmin), unsigned(vmax));\n\n        DBG_Assert(ret < maxSize);\n        if (ret > 0 && ret < maxSize && jsEval[ret] == '\\0')\n        {\n            DDF_AnnoteZclParse(r, item, 255, POWER_CONFIGURATION_CLUSTER_ID, POWER_CONFIG_ATTRID_BATTERY_VOLTAGE, jsEval.get());\n        }\n    }\n\n    return static_cast<quint8>(batteryPercentage);\n}\n\n/*! Handle packets related to the ZCL power configuration cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the power configuration cluster command or attribute\n */\nvoid DeRestPluginPrivate::handlePowerConfigurationClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    else if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n    }\n    else\n    {\n        return; // neither ZCL Report nor ZCL Read Attributes Response\n    }\n\n    const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n    while (!stream.atEnd())\n    {\n        quint16 attrId;\n        quint8 attrTypeId;\n\n        stream >> attrId;\n        if (isReadAttr)\n        {\n            quint8 status;\n            stream >> status;  // Read Attribute Response status\n            if (status != deCONZ::ZclSuccessStatus)\n            {\n                continue;\n            }\n        }\n        stream >> attrTypeId;\n\n        deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n        if (!attr.readFromStream(stream))\n        {\n            continue;\n        }\n\n        for (Sensor &sensor: sensors)\n        {\n            // Interate through all sensors of a device, but we don't care about the endpoint to distrubute the battery value\n            if (sensor.deletedState() != Sensor::StateNormal || !sensor.node())     { continue; }\n            if (!isSameAddress(sensor.address(), ind.srcAddress()))                 { continue; }\n\n            if (sensor.mustRead(READ_BATTERY))\n            {\n                sensor.clearRead(READ_BATTERY);\n            }\n\n            switch (attrId)\n            {\n            case POWER_CONFIG_ATTRID_BATTERY_PERCENTAGE_REMAINING:\n            {\n                // Specifies the remaining battery life as a half integer percentage of the full battery capacity (e.g., 34.5%, 45%,\n                // 68.5%, 90%) with a range between zero and 100%, with 0x00 = 0%, 0x64 = 50%, and 0xC8 = 100%. This is\n                // particularly suited for devices with rechargeable batteries.\n\n                uint divider = 2;\n\n                if (sensor.modelId().startsWith(QLatin1String(\"TRADFRI\")) || // IKEA\n                    sensor.modelId().startsWith(QLatin1String(\"SYMFONISK\")) || // IKEA\n                    sensor.modelId().startsWith(QLatin1String(\"ICZB-\")) || // iCasa keypads and remote\n                    sensor.modelId().startsWith(QLatin1String(\"ZGR904-S\")) || // Envilar remote\n                    sensor.modelId().startsWith(QLatin1String(\"ZGRC-KEY\")) || //  Sunricher wireless CCT remote\n                    sensor.modelId().startsWith(QLatin1String(\"SV01-\")) || // Keen Home vent\n                    sensor.modelId().startsWith(QLatin1String(\"SV02-\")) || // Keen Home vent\n                    sensor.modelId() == QLatin1String(\"4512705\") || // Namron remote control\n                    sensor.modelId() == QLatin1String(\"4512726\") || // Namron rotary switch\n                    sensor.modelId().startsWith(QLatin1String(\"S57003\")) || // SLC 4-ch remote controller\n                    sensor.modelId().startsWith(QLatin1String(\"RGBgenie ZB-5\")) || // RGBgenie remote control\n                    sensor.modelId().startsWith(QLatin1String(\"VOC_Sensor\")) || // LifeControl Enviroment sensor\n                    sensor.modelId().startsWith(QLatin1String(\"TY0203\")) || // SilverCrest / lidl\n                    sensor.modelId().startsWith(QLatin1String(\"TY0202\")) || // SilverCrest / lidl\n                    sensor.modelId().startsWith(QLatin1String(\"ZG2835\")))   // SR-ZG2835 Zigbee Rotary Switch\n                {\n                    divider = 1;\n                }\n\n                int bat = attr.numericValue().u8 / divider;\n\n                if (sensor.modelId() == QLatin1String(\"0x8020\") || // Danfoss RT24V Display thermostat\n                    sensor.modelId() == QLatin1String(\"0x8021\") || // Danfoss RT24V Display thermostat with floor sensor\n                    sensor.modelId() == QLatin1String(\"0x8030\") || // Danfoss RTbattery Display thermostat\n                    sensor.modelId() == QLatin1String(\"0x8031\") || // Danfoss RTbattery Display thermostat with infrared\n                    sensor.modelId() == QLatin1String(\"0x8034\") || // Danfoss RTbattery Dial thermostat\n                    sensor.modelId() == QLatin1String(\"0x8035\"))   // Danfoss RTbattery Dial thermostat with infrared\n                {\n                    // The Danfoss Icon Zigbee module exposes each in-room thermostat in its controller\n                    // as an endpoint. Each endpoint has the battery measurement for the device it represents.\n                    // This check makes sure none of the other endpoints get their battery value overwritten.\n                    if (ind.srcEndpoint() != sensor.fingerPrint().endpoint)\n                    {\n                        continue;\n                    }\n                }\n\n                ResourceItem *item = nullptr;\n\n                if (sensor.type().endsWith(QLatin1String(\"Battery\")))\n                {\n                    item = sensor.item(RStateBattery);\n\n                    if (item)\n                    {\n                        item->setValue(bat);\n                        sensor.updateStateTimestamp();\n                        sensor.setNeedSaveDatabase(true);\n                        queSaveDb(DB_SENSORS, DB_HUGE_SAVE_DELAY);\n                        enqueueEvent(Event(RSensors, RStateBattery, sensor.id(), item));\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                        updateSensorEtag(&sensor);\n                    }\n                }\n                else\n                {\n                    item = sensor.item(RConfigBattery);\n\n                    if (!item && attr.numericValue().u8 > 0) // valid value: create resource item\n                    {\n                        item = sensor.addItem(DataTypeUInt8, RConfigBattery);\n                    }\n\n                    if (item)\n                    {\n                        item->setValue(bat);\n                        enqueueEvent(Event(RSensors, RConfigBattery, sensor.id(), item));\n                        updateSensorEtag(&sensor);\n                        sensor.setNeedSaveDatabase(true);\n                        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                    }\n                }\n\n                if (item)\n                {\n                    if (divider == 1)\n                    {\n                        DDF_AnnoteZclParse(&sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Attr.val\");\n                    }\n                    else if (divider == 2)\n                    {\n                        DDF_AnnoteZclParse(&sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Attr.val / 2\");\n                    }\n                }\n\n                // Correct incomplete sensor fingerprint\n                if (!sensor.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\n                {\n                    sensor.fingerPrint().inClusters.push_back(POWER_CONFIGURATION_CLUSTER_ID);\n                }\n\n                sensor.setZclValue(updateType, ind.srcEndpoint(), POWER_CONFIGURATION_CLUSTER_ID, POWER_CONFIG_ATTRID_BATTERY_PERCENTAGE_REMAINING, attr.numericValue());\n            }\n                break;\n\n            case POWER_CONFIG_ATTRID_BATTERY_VOLTAGE:\n            {\n                if (sensor.modelId().startsWith(QLatin1String(\"tagv4\")) ||   // SmartThings Arrival sensor\n                    sensor.modelId().startsWith(QLatin1String(\"motionv4\")) ||// SmartThings motion sensor\n                    sensor.modelId().startsWith(QLatin1String(\"moisturev4\")) ||// SmartThings water leak sensor\n                    sensor.modelId().startsWith(QLatin1String(\"multiv4\")) ||// SmartThings multi sensor 2016\n                    sensor.modelId().startsWith(QLatin1String(\"3305-S\")) ||  // SmartThings 2014 motion sensor\n                    sensor.modelId() == QLatin1String(\"Remote switch\") ||    // Legrand switch\n                    sensor.modelId() == QLatin1String(\"Pocket remote\") ||    // Legrand wireless switch scene x 4\n                    sensor.modelId() == QLatin1String(\"Double gangs remote switch\") ||    // Legrand switch double\n                    sensor.modelId() == QLatin1String(\"Shutters central remote switch\") || // Legrand switch module\n                    sensor.modelId() == QLatin1String(\"Remote toggle switch\") || // Legrand shutter switch\n                    sensor.modelId() == QLatin1String(\"Remote motion sensor\") || // Legrand motion sensor\n                    sensor.modelId() == QLatin1String(\"lumi.flood.agl02\") ||         // Xiaomi Aqara T1 water leak sensor SJCGQ12LM\n                    sensor.modelId() == QLatin1String(\"lumi.motion.agl04\") ||        // Xiaomi Aqara RTCGQ13LM high precision motion sensor\n                    sensor.modelId() == QLatin1String(\"Zen-01\") ||           // Zen thermostat\n                    sensor.modelId() == QLatin1String(\"Thermostat\") ||       // eCozy thermostat\n                    sensor.modelId() == QLatin1String(\"Bell\") ||             // Sage doorbell sensor\n                    sensor.modelId() == QLatin1String(\"ISW-ZPR1-WP13\") ||    // Bosch motion sensor\n                    sensor.modelId() == QLatin1String(\"3AFE14010402000D\") ||   // Konke motion sensor\n                    sensor.modelId() == QLatin1String(\"3AFE28010402000D\") ||   // Konke motion sensor v2\n                    sensor.modelId() == QLatin1String(\"FB56-DOS06HM1.3\") ||    // Feibit FB56-DOS06HM1.3 door/window sensor\n                    sensor.modelId().endsWith(QLatin1String(\"86opcn01\")) ||    // Aqara Opple\n                    sensor.modelId().startsWith(QLatin1String(\"FLSZB-1\")) ||   // Develco water leak sensor\n                    sensor.modelId().startsWith(QLatin1String(\"SIRZB-1\")) ||   // Develco siren\n                    sensor.modelId().startsWith(QLatin1String(\"ZHMS101\")) ||   // Wattle (Develco) magnetic sensor\n                    sensor.modelId().startsWith(QLatin1String(\"MotionSensor51AU\")) || // Aurora (Develco) motion sensor\n                    sensor.modelId().startsWith(QLatin1String(\"RFDL-ZB-MS\")) ||// Bosch motion sensor\n                    sensor.modelId().startsWith(QLatin1String(\"1116-S\")) ||    // iris contact sensor v3\n                    sensor.modelId().startsWith(QLatin1String(\"1117-S\")) ||    // iris motion sensor v3\n                    sensor.modelId().startsWith(QLatin1String(\"3326-L\")) ||    // iris motion sensor v2\n                    sensor.modelId().startsWith(QLatin1String(\"3300\")) ||      // Centralite contact sensor\n                    sensor.modelId().startsWith(QLatin1String(\"3320-L\")) ||    // Centralite contact sensor\n                    sensor.modelId().startsWith(QLatin1String(\"3323\")) ||      // Centralite contact sensor\n                    sensor.modelId().startsWith(QLatin1String(\"3315\")) ||      // Centralite water sensor\n                    sensor.modelId().startsWith(QLatin1String(\"3157100\")) ||      // Centralite pearl thermostat\n                    sensor.modelId().startsWith(QLatin1String(\"4655BC0\")) ||      // Ecolink contact sensor\n                    sensor.modelId().startsWith(QLatin1String(\"SZ-DWS04\"))   || // Sercomm open/close sensor\n                    sensor.modelId().startsWith(QLatin1String(\"SZ-WTD02N_CAR\")) || // Sercomm water sensor\n                    sensor.modelId().startsWith(QLatin1String(\"GZ-PIR02\"))   || // Sercomm motion sensor\n                    sensor.modelId() == QLatin1String(\"URC4450BC0-X-R\")   || // Xfinity Keypad XHK1-UE\n                    sensor.modelId() == QLatin1String(\"3405-L\") ||           // IRIS 3405-L Keypad\n                    sensor.modelId().startsWith(QLatin1String(\"Tripper\")) || // Quirky Tripper (Sercomm) open/close\n                    sensor.modelId().startsWith(QLatin1String(\"Lightify Switch Mini\")) ||  // Osram 3 button remote\n                    sensor.modelId().startsWith(QLatin1String(\"Switch 4x EU-LIGHTIFY\")) || // Osram 4 button remote\n                    sensor.modelId().startsWith(QLatin1String(\"Switch 4x-LIGHTIFY\")) || // Osram 4 button remote\n                    sensor.modelId().startsWith(QLatin1String(\"Switch-LIGHTIFY\")) ) // Osram 4 button remote\n                {  }\n                else\n                {\n                    continue;\n                }\n\n                ResourceItem *item = sensor.item(RConfigBattery);\n\n                if (!item && attr.numericValue().u8 > 0) // valid value: create resource item\n                {\n                    sensor.addItem(DataTypeUInt8, RConfigBattery);\n                }\n\n                // Correct incomplete sensor fingerprint\n                if (!sensor.fingerPrint().hasInCluster(POWER_CONFIGURATION_CLUSTER_ID))\n                {\n                    sensor.fingerPrint().inClusters.push_back(POWER_CONFIGURATION_CLUSTER_ID);\n                }\n\n                quint8 battery = attr.numericValue().u8; // in 0.1 V\n\n                float vmin = 20; // TODO: check - I've seen 24\n                float vmax = 30; // TODO: check - I've seen 29\n\n                if (sensor.modelId() == QLatin1String(\"Zen-01\") ||\n                    sensor.modelId() == QLatin1String(\"URC4450BC0-X-R\")) // 4x LR6 AA 1.5 V\n                {\n                    vmin = 36; // according to attribute 0x0036\n                    vmax = 60;\n                }\n\n                battery = calculateBatteryPercentageRemaining(&sensor, item, battery, vmin, vmax);\n                \n                if (item)\n                {\n                    item->setValue(battery);\n                    enqueueEvent(Event(RSensors, RConfigBattery, sensor.id(), item));\n                    updateSensorEtag(&sensor);\n                    sensor.setNeedSaveDatabase(true);\n                    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                }\n                \n                sensor.setZclValue(updateType, ind.srcEndpoint(), POWER_CONFIGURATION_CLUSTER_ID, POWER_CONFIG_ATTRID_BATTERY_VOLTAGE, attr.numericValue());\n            }\n                break;\n\n            case POWER_CONFIG_ATTRID_BATTERY_ALARM_MASK:\n            {\n                ResourceItem *item = sensor.item(RStateLowBattery);\n\n                if (!item)\n                {\n                    item = sensor.addItem(DataTypeBool, RStateLowBattery);\n                }\n\n                bool lowBat = (attr.numericValue().u8 & 0x01);\n\n                sensor.setZclValue(updateType, ind.srcEndpoint(), POWER_CONFIGURATION_CLUSTER_ID, POWER_CONFIG_ATTRID_BATTERY_ALARM_MASK, attr.numericValue());\n\n                if (item)\n                {\n                    item->setValue(lowBat);\n                    enqueueEvent(Event(RSensors, RConfigBattery, sensor.id(), item));\n                    updateSensorEtag(&sensor);\n                    sensor.setNeedSaveDatabase(true);\n                    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n\n                    DDF_AnnoteZclParse(&sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = (Attr.val & 1) != 0\");\n                }\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "product_match.cpp",
          "type": "blob",
          "size": 10.9345703125,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <regex>\n#include <deconz/dbg_trace.h>\n\n#include \"product_match.h\"\n#include \"resource.h\"\n\n/*! The product map is a helper to map Basic Cluster manufacturer name and modelid\n   to human readable product identifiers like marketing string or the model no. as printed on the product package.\n\n   In case of Tuya multiple entries may refer to the same device, so in matching code\n   it's best to match against the \\c productId.\n\n   Example:\n\n   if (R_GetProductId(sensor) == QLatin1String(\"SEA801-ZIGBEE TRV\"))\n   {\n   }\n\n   Note: this will later on be replaced with the data from DDF files.\n*/\nstruct ProductMap\n{\n    const char *zmanufacturerName;\n    const char *zmodelId;\n    const char *manufacturer;\n    // a common product identifier even if multipe branded versions exist\n    const char *commonProductId;\n};\n\nstatic const ProductMap products[] =\n{\n    // Prefix signification\n    // --------------------\n    // Tuya_THD : thermostat device using Tuya cluster\n    // Tuya_COVD : covering device using Tuya cluster\n    // Tuya_RPT : Repeater\n    // Tuya_SEN : Sensor\n\n    // Tuya Thermostat / TRV\n    {\"_TYST11_zuhszj9s\", \"uhszj9s\", \"HiHome\", \"Tuya_THD WZB-TRVL TRV\"},\n    {\"_TZE200_zuhszj9s\", \"TS0601\", \"HiHome\", \"Tuya_THD WZB-TRVL TRV\"},\n    {\"_TYST11_KGbxAXL2\", \"GbxAXL2\", \"Saswell\", \"Tuya_THD SEA801-ZIGBEE TRV\"},\n    {\"_TYST11_c88teujp\", \"88teujp\", \"Saswell\", \"Tuya_THD SEA801-ZIGBEE TRV\"},\n    {\"_TZE200_c88teujp\", \"TS0601\", \"Saswell\", \"Tuya_THD SEA801-ZIGBEE TRV\"},\n    {\"_TYST11_ckud7u2l\", \"kud7u2l\", \"Tuya\", \"Tuya_THD HY369 TRV\"},\n    {\"_TZE200_ckud7u2l\", \"TS0601\", \"Tuya\", \"Tuya_THD HY369 TRV\"},\n    {\"_TZE200_ywdxldoj\", \"TS0601\", \"MOES/tuya\", \"Tuya_THD HY368 TRV\"},\n    {\"_TZE200_fhn3negr\", \"TS0601\", \"MOES/tuya\", \"Tuya_THD MOES TRV\"},\n    {\"_TZE200_aoclfnxz\", \"TS0601\", \"Moes\", \"Tuya_THD BTH-002 Thermostat\"},\n    {\"_TYST11_jeaxp72v\", \"eaxp72v\", \"Essentials\", \"Tuya_THD Essentials TRV\"},\n    {\"_TZE200_jeaxp72v\", \"TS0601\", \"Essentials\", \"Tuya_THD Essentials TRV\"},\n    {\"_TYST11_kfvq6avy\", \"fvq6avy\", \"Revolt\", \"Tuya_THD NX-4911-675 TRV\"},\n    {\"_TZE200_kfvq6avy\", \"TS0601\", \"Revolt\", \"Tuya_THD NX-4911-675 TRV\"},\n    {\"_TYST11_zivfvd7h\", \"ivfvd7h\", \"Siterwell\", \"Tuya_THD GS361A-H04 TRV\"},\n    {\"_TZE200_zivfvd7h\", \"TS0601\", \"Siterwell\", \"Tuya_THD GS361A-H04 TRV\"},\n    {\"_TYST11_yw7cahqs\", \"w7cahqs\", \"Hama\", \"Tuya_THD Smart radiator TRV\"},\n    {\"_TZE200_yw7cahqs\", \"TS0601\", \"Hama\", \"Tuya_THD Smart radiator TRV\"},\n    {\"_TZE200_h4cgnbzg\", \"TS0601\", \"Hama\", \"Tuya_THD Smart radiator TRV\"},\n    {\"_TZE200_cwnjrr72\", \"TS0601\", \"MOES\", \"Tuya_THD HY368 TRV\"},\n    {\"_TZE200_cpmgn2cf\", \"TS0601\", \"MOES\", \"Tuya_THD HY368 TRV\"},\n    {\"_TZE200_b6wax7g0\", \"TS0601\", \"MOES\", \"Tuya_THD BRT-100\"},\n\n    // Tuya Covering\n    {\"_TYST11_wmcdj3aq\", \"mcdj3aq\", \"Zemismart\", \"Tuya_COVD ZM25TQ\"},\n    {\"_TZE200_wmcdj3aq\", \"TS0601\", \"Zemismart\", \"Tuya_COVD ZM25TQ\"},\n    {\"_TZE200_fzo2pocs\", \"TS0601\", \"Zemismart\", \"Tuya_COVD ZM25TQ\"},\n    {\"_TYST11_xu1rkty3\", \"u1rkty3\", \"Smart Home\", \"Tuya_COVD DT82LEMA-1.2N\"},\n    {\"_TZE200_xuzcvlku\", \"TS0601\", \"Zemismart\", \"Tuya_COVD M515EGB\"},\n    {\"_TZE200_rddyvrci\", \"TS0601\", \"Moes\", \"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\"},\n    {\"_TZE200_zah67ekd\", \"TS0601\", \"MoesHouse / Livolo\", \"Tuya_COVD AM43-0.45-40\"},\n    {\"_TZE200_nogaemzt\", \"TS0601\", \"Tuya\", \"Tuya_COVD YS-MT750\"},\n    {\"_TZE200_zpzndjez\", \"TS0601\", \"Tuya\", \"Tuya_COVD DS82\"},\n    {\"_TZE200_cowvfni3\", \"TS0601\", \"Zemismart\", \"Tuya_COVD ZM79E-DT\"},\n    {\"_TZE200_5zbp6j0u\", \"TS0601\", \"Tuya/Zemismart\", \"Tuya_COVD DT82LEMA-1.2N\"},\n    {\"_TZE200_fdtjuw7u\", \"TS0601\", \"Yushun\", \"Tuya_COVD YS-MT750\"},\n    {\"_TZE200_bqcqqjpb\", \"TS0601\", \"Yushun\", \"Tuya_COVD YS-MT750\"},\n    {\"_TZE200_nueqqe6k\", \"TS0601\", \"Zemismart\", \"Tuya_COVD M515EGB\"},\n    {\"_TZE200_iossyxra\", \"TS0601\", \"Zemismart\", \"Tuya_COVD Roller Shade\"},\n\n    // Tuya covering not using tuya cluster but need reversing\n    {\"_TZ3000_egq7y6pr\", \"TS130F\", \"Lonsonho\", \"11830304 Switch\"},\n    {\"_TZ3000_xzqbrqk1\", \"TS130F\", \"Lonsonho\", \"Zigbee curtain switch\"}, // https://github.com/dresden-elektronik/deconz-rest-plugin/issues/3757#issuecomment-776201454\n    {\"_TZ3000_ltiqubue\", \"TS130F\", \"Tuya\", \"Zigbee curtain switch\"},\n    {\"_TZ3000_vd43bbfq\", \"TS130F\", \"Tuya\", \"QS-Zigbee-C01 Module\"}, // Curtain module QS-Zigbee-C01\n    {\"_TZ3000_kpve0q1p\", \"TS130F\", \"Tuya\", \"Covering Switch ESW-2ZAD-EU\"},\n    {\"_TZ3000_fccpjz5z\", \"TS130F\", \"Tuya\", \"QS-Zigbee-C01 Module\"}, // Curtain module QS-Zigbee-C01\n    {\"_TZ3000_j1xl73iw\", \"TS130F\", \"Tuya\", \"Zigbee dual curtain switch\"},\n\n    // Other\n    {\"_TYST11_d0yu2xgi\", \"0yu2xgi\", \"NEO/Tuya\", \"NAS-AB02B0 Siren\"},\n    {\"_TZE200_d0yu2xgi\", \"TS0601\", \"NEO/Tuya\", \"NAS-AB02B0 Siren\"},\n    {\"_TZ3000_m0vaazab\", \"TS0207\", \"Tuya\", \"Tuya_RPT Repeater\"},\n    \n    // Sensor\n    {\"_TZ3210_rxqls8v0\", \"TS0202\", \"Fantem\", \"Tuya_SEN Multi-sensor\"},\n    {\"_TZ3210_zmy9hjay\", \"TS0202\", \"Fantem\", \"Tuya_SEN Multi-sensor\"},\n    {\"_TZE200_aycxwiau\", \"TS0601\", \"Woox\", \"Tuya_OTH R7049 Smoke Alarm\"},\n\n     // Switch\n    {\"_TZE200_la2c2uo9\", \"TS0601\", \"Moes\", \"Tuya_DIMSWITCH MS-105Z\"},\n    {\"_TZE200_dfxkcots\", \"TS0601\", \"Earda\", \"Tuya_DIMSWITCH Earda Dimmer\"},\n    {\"_TZE200_9i9dt8is\", \"TS0601\", \"Earda\", \"Tuya_DIMSWITCH EDM-1ZAA-EU\"},\n\n    {nullptr, nullptr, nullptr, nullptr}\n};\n\n/*! Returns the product identifier for a matching Basic Cluster manufacturer name. */\nstatic QLatin1String productIdForManufacturerName(const QString &manufacturerName, const ProductMap *mapIter)\n{\n    Q_ASSERT(mapIter);\n\n    for (; mapIter->commonProductId != nullptr; mapIter++)\n    {\n        if (manufacturerName == QLatin1String(mapIter->zmanufacturerName))\n        {\n            return QLatin1String(mapIter->commonProductId);\n        }\n    }\n\n    return QLatin1String(\"\");\n}\n\n/*! Returns the product identifier for a resource. */\nconst QString R_GetProductId(Resource *resource)\n{\n    DBG_Assert(resource);\n\n\n    if (!resource)\n    {\n        return { };\n    }\n\n    auto *productId = resource->item(RAttrProductId);\n\n    if (productId)\n    {\n        return productId->toString();\n    }\n\n    const auto *manufacturerName = resource->item(RAttrManufacturerName);\n    const auto *modelId = resource->item(RAttrModelId);\n\n    // Need manufacturerName\n    if (!manufacturerName)\n    {\n        return { };\n    }\n\n    //Tuya don't need modelId\n    if (isTuyaManufacturerName(manufacturerName->toString()))\n    {\n        // for Tuya devices match against manufacturer name\n        const auto productIdStr = productIdForManufacturerName(manufacturerName->toString(), products);\n        if (productIdStr.size() > 0)\n        {\n            productId = resource->addItem(DataTypeString, RAttrProductId);\n            DBG_Assert(productId);\n            productId->setValue(QString(productIdStr));\n            productId->setIsPublic(false); // not ready for public\n            return productId->toString();\n        }\n        else\n        {\n            // Fallback\n            // manufacturer name is the most unique identifier for Tuya\n            if (DBG_IsEnabled(DBG_INFO_L2))\n            {\n                DBG_Printf(DBG_INFO_L2, \"No Tuya productId entry found for manufacturername: %s\\n\", qPrintable(manufacturerName->toString()));\n            }\n\n            return manufacturerName->toString();\n        }\n    }\n\n    if (modelId)\n    {\n        return modelId->toString();\n    }\n\n    return { };\n}\n\n/*! Returns true if the \\p manufacturer name referes to a Tuya device. */\nbool isTuyaManufacturerName(const QString &manufacturer)\n{\n    return manufacturer.startsWith(QLatin1String(\"_T\")) && // quick check for performance\n           std::regex_match(qPrintable(manufacturer), std::regex(\"_T[A-Z][A-Z0-9]{4}_[a-z0-9]{8}\"));\n}\n\n// Tests for Tuya manufacturer name\n/*\n Q_ASSERT(isTuyaManufacturerName(\"_TZ3000_bi6lpsew\"));\n Q_ASSERT(isTuyaManufacturerName(\"_TYZB02_key8kk7r\"));\n Q_ASSERT(isTuyaManufacturerName(\"_TYST11_ckud7u2l\"));\n Q_ASSERT(isTuyaManufacturerName(\"_TYZB02_keyjqthh\"));\n Q_ASSERT(!isTuyaManufacturerName(\"lumi.sensor_switch.aq2\"));\n*/\n\n\n\nstatic const lidlDevice lidlDevices[] = { // Sorted by zigbeeManufacturerName\n    { \"_TYZB01_bngwdjsr\", \"TS1001\",  \"LIDL Livarno Lux\", \"HG06323\" }, // Remote Control\n    { \"_TZ1800_ejwkn2h2\", \"TY0203\",  \"LIDL Silvercrest\", \"HG06336\" }, // Contact sensor\n    { \"_TZ1800_fcdjzz3s\", \"TY0202\",  \"LIDL Silvercrest\", \"HG06335\" }, // Motion sensor\n    { \"_TZ1800_ladpngdx\", \"TS0211\",  \"LIDL Silvercrest\", \"HG06668\" }, // Door bell\n    { \"_TZ3000_1obwwnmq\", \"TS011F\",  \"LIDL Silvercrest\", \"HG06338\" }, // Smart USB Extension Lead (EU)\n    { \"_TZ3000_49qchf10\", \"TS0502A\", \"LIDL Livarno Lux\", \"HG06492C\" }, // CT Light (E27)\n    { \"_TZ3000_9cpuaca6\", \"TS0505A\", \"LIDL Livarno Lux\", \"14148906L\" }, // Stimmungsleuchte\n    { \"_TZ3000_dbou1ap4\", \"TS0505A\", \"LIDL Livarno Lux\", \"HG06106C\" }, // RGB Light (E27)\n    { \"_TZ3000_el5kt5im\", \"TS0502A\", \"LIDL Livarno Lux\", \"HG06492A\" }, // CT Light (GU10)\n    { \"_TZ3000_gek6snaj\", \"TS0505A\", \"LIDL Livarno Lux\", \"14149506L\" }, // Lichtleiste\n    { \"_TZ3000_kdi2o9m6\", \"TS011F\",  \"LIDL Silvercrest\", \"HG06337\" }, // Smart plug (EU)\n    { \"_TZ3000_br3laukf\", \"TS0101\",  \"LIDL Silvercrest\", \"HG06620\"}, // Garden Spike with 2 Sockets\n    { \"_TZ3000_kdpxju99\", \"TS0505A\", \"LIDL Livarno Lux\", \"HG06106A\" }, // RGB Light (GU10)\n    { \"_TZ3000_oborybow\", \"TS0502A\", \"LIDL Livarno Lux\", \"HG06492B\" }, // CT Light (E14)\n    { \"_TZ3000_odygigth\", \"TS0505A\", \"LIDL Livarno Lux\", \"HG06106B\" }, // RGB Light (E14)\n    { \"_TZ3000_riwp3k79\", \"TS0505A\", \"LIDL Livarno Lux\", \"HG06104A\" }, // LED Light Strip\n    { \"_TZE200_s8gkrkxk\", \"TS0601\",  \"LIDL Livarno Lux\", \"HG06467\" }, // Smart LED String Lights (EU)\n    { nullptr, nullptr, nullptr, nullptr }\n};\n\nconst lidlDevice *getLidlDevice(const QString &zigbeeManufacturerName)\n{\n    const lidlDevice *device = lidlDevices;\n\n    while (device->zigbeeManufacturerName != nullptr)\n    {\n        if (zigbeeManufacturerName == QLatin1String(device->zigbeeManufacturerName))\n        {\n            return device;\n        }\n        device++;\n    }\n    return nullptr;\n}\n\nbool isLidlDevice(const QString &zigbeeModelIdentifier, const QString &manufacturername)\n{\n    const lidlDevice *device = lidlDevices;\n\n    while (device->zigbeeManufacturerName != nullptr)\n    {\n        if (zigbeeModelIdentifier == QLatin1String(device->zigbeeModelIdentifier) &&\n            manufacturername == QLatin1String(device->manufacturername))\n        {\n            return true;\n        }\n        device++;\n    }\n    return false;\n}\n\nuint productHash(const Resource *r)\n{\n    if (!r || !r->item(RAttrManufacturerName) || !r->item(RAttrModelId))\n    {\n        return 0;\n    }\n\n    if (isTuyaManufacturerName(r->item(RAttrManufacturerName)->toString()))\n    {\n        // for Tuya devices use manufacturer name as modelid\n        return qHash(r->item(RAttrManufacturerName)->toString());\n    }\n    else\n    {\n        return qHash(r->item(RAttrModelId)->toString());\n    }\n}\n"
        },
        {
          "name": "product_match.h",
          "type": "blob",
          "size": 0.837890625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef PRODUCT_MATCH_H\n#define PRODUCT_MATCH_H\n\n#include <QString>\n\nclass Resource;\n\nstruct lidlDevice {\n    const char *zigbeeManufacturerName;\n    const char *zigbeeModelIdentifier;\n    const char *manufacturername;\n    const char *modelid;\n};\n\nconst QString R_GetProductId(Resource *resource);\nbool isTuyaManufacturerName(const QString &manufacturer);\nbool isLidlDevice(const QString &zigbeeModelIdentifier, const QString &manufacturername);\nconst lidlDevice *getLidlDevice(const QString &zigbeeManufacturerName);\nuint productHash(const Resource *r);\n\n#endif // PRODUCT_MATCH_H\n"
        },
        {
          "name": "read_files.cpp",
          "type": "blob",
          "size": 28.2822265625,
          "content": "#include <QFile>\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QJsonValue>\n#include <QJsonParseError>\n#include <deconz/dbg_trace.h>\n#include \"read_files.h\"\n#include \"sensor.h\"\n\n#define MAX_BUTTON_CHARACTER_LENGTH                    11\n#define MAX_BUTTON_VALUE                               32000\n#define MAX_BUTTON_ACTION_CHARACTER_LENGTH             40\n#define MAX_BUTTON_ACTION_VALUE                        64\n#define MAX_CLUSTER_CHARACTER_LENGTH                   20\n#define MAX_CLUSTER_VALUE                              0xFFFF\n#define MAX_COMMAND_CHARACTER_LENGTH                   28\n#define MAX_COMMAND_VALUE                              0xFF\n#define MAX_MODELID_CHARACTER_LENGTH                   32\n#define MAX_DESCRIPTION_CHARACTER_LENGTH               40\n\nQJsonDocument readButtonMapJson(const QString &path)\n{\n    QFile file;\n    file.setFileName(path);\n\n    if (file.exists())\n    {\n        DBG_Printf(DBG_INFO, \"[INFO] - Found file containing button maps. Parsing data...\\n\");\n\n        QJsonParseError error;\n\n        file.open(QIODevice::ReadOnly | QIODevice::Text);\n        QJsonDocument buttonMaps = QJsonDocument::fromJson(file.readAll(), &error);\n        file.close();\n\n        if (buttonMaps.isNull() || buttonMaps.isEmpty())\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Error: %s at offset: %d (in characters)\\n\", qPrintable(error.errorString()), error.offset);\n            return QJsonDocument();\n        }\n        else\n        {\n            return buttonMaps;\n        }\n    }\n    else\n    {\n        DBG_Printf(DBG_INFO, \"[ERROR] - File containing button maps was NOT found.\\n\");\n        return QJsonDocument();\n    }\n}\n\nbool checkRootLevelObjectsJson(const QJsonDocument &buttonMaps, const QStringList &requiredJsonObjects)\n{\n    // Check root level objects\n    for ( const auto& i : requiredJsonObjects  )\n    {\n        if (buttonMaps.object().value(QString(i)) == QJsonValue::Undefined)\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - No object named '%s' found in JSON file. Skip to load button maps.\\n\", qPrintable(i));\n            return false;\n        }\n        else if (!buttonMaps.object().value(QString(i)).isObject())\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Expected '%s' in JSON file to be an object, but it isn't. Skip to load button maps.\\n\", qPrintable(i));\n            return false;\n        }\n    }\n    return true;\n}\n\nQMap<QString, quint16> loadButtonMapClustersJson(const QJsonDocument &buttonMaps)\n{\n    // Load button map clusters\n    QJsonObject clustersObj = buttonMaps.object().value(QLatin1String(\"clusters\")).toObject();\n    QMap<QString, quint16> btnMapClusters;\n    quint8 counter = 0;\n\n    for (auto i = clustersObj.constBegin(); i != clustersObj.constEnd(); ++i)       // Loop through cluster objects\n    {\n        ++counter;\n\n        if (i.key().isNull() || i.key().isEmpty() || i.key().length() > MAX_CLUSTER_CHARACTER_LENGTH)\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Key #%d for object 'clusters' is no string or too long. Skipping entry...\\n\", counter);\n            continue;\n        }\n        else if (!i.value().isDouble() || i.value().toDouble() > MAX_CLUSTER_VALUE)\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Value #%d for object 'clusters' is no number or too large. Skipping entry...\\n\", counter);\n            continue;\n        }\n        else\n        {\n            btnMapClusters.insert(i.key(), i.value().toInt());   // Store data in QMap for later use\n        }\n    }\n    return btnMapClusters;\n}\n\nQMap<QString, QMap<QString, quint16>> loadButtonMapCommadsJson(const QJsonDocument &buttonMaps)\n{\n    // Load button map commands\n    QJsonObject commandsObj = buttonMaps.object().value(QLatin1String(\"commands\")).toObject();\n    QMap<QString, QMap<QString, quint16>> btnMapClusterCommands;\n    quint8 counter = 0;\n\n    for (auto i = commandsObj.constBegin(); i != commandsObj.constEnd(); ++i)       // Loop through commands objects\n    {\n        ++counter;\n\n        if (i.key().isNull() || i.key().isEmpty() || i.key().length() > MAX_CLUSTER_CHARACTER_LENGTH)\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Key #%d for object 'commands' is no string or too long. Skipping entry...\\n\", counter);\n            continue;\n        }\n        else if (!i.value().isObject())\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Expected '%s' in JSON file to be an object, but it isn't. Skipping entry...\\n\", qPrintable(i.key()));\n            continue;\n        }\n        else\n        {\n            QJsonObject commandObj = i.value().toObject();\n            QString commandsObjName = i.key();\n            QMap<QString, quint16> commandMap;\n            quint8 counter2 = 0;\n\n            for (auto i = commandObj.constBegin(); i != commandObj.constEnd(); ++i)       // Loop through cluster specific command objects\n            {\n                ++counter2;\n\n                if (i.key().isNull() || i.key().isEmpty() || i.key().length() > MAX_COMMAND_CHARACTER_LENGTH)\n                {\n                    DBG_Printf(DBG_INFO, \"[ERROR] - Key #%d for object '%s' is no string or too long. Skipping entry...\\n\", counter2, qPrintable(commandsObjName));\n                    continue;\n                }\n                else if (!i.value().isDouble() || i.value().toDouble() > MAX_COMMAND_VALUE)       // FIXME: value might be too small\n                {\n                    DBG_Printf(DBG_INFO, \"[ERROR] - Value #%d for object '%s' is no number or too large. Skipping entry...\\n\", counter2, qPrintable(commandsObjName));\n                    continue;\n                }\n                else\n                {\n                    commandMap.insert(i.key(), i.value().toInt());   // Store data in QMap for later use\n                }\n            }\n            btnMapClusterCommands.insert(commandsObjName, commandMap);   // Store data in QMap for later use\n        }\n    }\n    return btnMapClusterCommands;\n}\n\n/*! Reads the associated modelIDs from all available button maps in JSON file.\n */\nstd::vector<ButtonProduct> loadButtonMapModelIdsJson(const QJsonDocument &buttonMapsDoc, const std::vector<ButtonMap> &buttonMaps)\n{\n    std::vector<ButtonProduct> result;\n    result.reserve(128);\n\n    const QJsonObject allMapsObj = buttonMapsDoc.object().value(QLatin1String(\"maps\")).toObject();     // Get all button maps\n\n    for (auto i = allMapsObj.constBegin(); i != allMapsObj.constEnd(); ++i)       // Loop through button maps\n    {\n        const QString buttonMapName = i.key();    // Individual button map name\n\n        ButtonProduct item;\n        item.buttonMapRef = BM_ButtonMapRefForHash(qHash(i.key()), buttonMaps);\n\n        if (isValid(item.buttonMapRef) && i.value().isObject())        // Check if individual button map is an object\n        {\n            const QJsonObject buttonMapObj = i.value().toObject();\n            if (buttonMapObj.value(QString(\"modelids\")).isArray())\n            {\n                const QJsonArray buttonMapModelIds = buttonMapObj.value(QString(\"modelids\")).toArray();\n\n                if (buttonMapModelIds.size() == 0)\n                {\n                    DBG_Printf(DBG_INFO, \"[WARNING] - Button map '%s' in JSON file has no assigned ModelIDs. Skip loading button map...\\n\", qPrintable(buttonMapName));\n                    continue;   // Skip button map\n                }\n\n                const auto jend = buttonMapModelIds.constEnd();\n                for (auto j = buttonMapModelIds.constBegin(); j != jend; ++j)       // Loop through modelIDs\n                {\n                    const QString modelId = j->toString();\n\n                    if (j->isString() && !modelId.isEmpty() && modelId.size() <= MAX_MODELID_CHARACTER_LENGTH)\n                    {\n                        item.productHash = qHash(modelId);\n                        result.push_back(item);\n                    }\n                    else if (j->isString() && modelId.size() > MAX_MODELID_CHARACTER_LENGTH)\n                    {\n                        DBG_Printf(DBG_INFO, \"[ERROR] - Entry of 'modelids', button map '%s' in JSON file is too long. Skipping entry...\\n\", qPrintable(buttonMapName));\n                        continue;\n                    }\n                    else\n                    {\n                        DBG_Printf(DBG_INFO, \"[ERROR] - Expected entry of 'modelids', button map '%s' in JSON file to be a string, but isn't. Skipping entry...\\n\", qPrintable(buttonMapName));\n                    }\n                }\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Expected 'modelids' of button map '%s' in JSON file to be an array, but isn't. Skip loading button map...\\n\", qPrintable(buttonMapName));\n                continue;   // Skip button map\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"[ERROR] - Expected '%s' in JSON file to be an object, but it isn't. Skip loading button map...\\n\", qPrintable(buttonMapName));\n            continue;   // Skip button map\n        }\n    }\n    return result;\n}\n\n\n/*! Reads all available button maps from JSON file.\n */\nstd::vector<ButtonMap> loadButtonMapsJson(const QJsonDocument &buttonMaps, const QMap<QString, quint16> &btnMapClusters,\n                                                                 const QMap<QString, QMap<QString, quint16>> &btnMapClusterCommands)\n{\n    std::vector<ButtonMap> result;\n    result.reserve(128);\n\n        QMap<QString, quint16> buttons;\n        QMap<QString, quint8> actions;\n        quint8 counter = 0;\n\n\n        // Load button map buttons\n        QJsonObject buttonsObj = buttonMaps.object().value(QLatin1String(\"buttons\")).toObject();\n\n        for (auto i = buttonsObj.constBegin(); i != buttonsObj.constEnd(); ++i)       // Loop through button objects\n        {\n            ++counter;\n\n            if (i.key().isNull() || i.key().isEmpty() || i.key().length() > MAX_BUTTON_CHARACTER_LENGTH)\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Key #%d for object 'buttons' is no string or too long. Skipping entry...\\n\", counter);\n                continue;\n            }\n            else if (!i.value().isDouble() || i.value().toDouble() > MAX_BUTTON_VALUE)\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Value #%d for object 'buttons' is no number or too large. Skipping entry...\\n\", counter);\n                continue;\n            }\n            else\n            {\n                buttons.insert(i.key(), i.value().toInt());   // Store data in QMap for later use\n            }\n        }\n\n        counter = 0;\n\n        QJsonObject actionsObj = buttonMaps.object().value(QLatin1String(\"buttonActions\")).toObject();\n\n        for (auto i = actionsObj.constBegin(); i != actionsObj.constEnd(); ++i)       // Loop through button action objects\n        {\n            ++counter;\n\n            if (i.key().isNull() || i.key().isEmpty() || i.key().length() > MAX_BUTTON_ACTION_CHARACTER_LENGTH)\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Key #%d for object 'buttonActions' is no string or too long. Skipping entry...\\n\", counter);\n                continue;\n            }\n            else if (!i.value().isDouble() || i.value().toDouble() > MAX_BUTTON_ACTION_VALUE)\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Value #%d for object 'buttonActions' is no number or too large. Skipping entry...\\n\", counter);\n                continue;\n            }\n            else\n            {\n                actions.insert(i.key(), i.value().toInt());   // Store data in QMap for later use\n            }\n        }\n\n        // Load button maps\n        QJsonObject allMapsObj = buttonMaps.object().value(QLatin1String(\"maps\")).toObject();     // Get all button maps\n\n        for (auto i = allMapsObj.constBegin(); i != allMapsObj.constEnd(); ++i)       // Loop through button maps\n        {\n            QString buttonMapName = i.key();    // Individual button map name\n            //DBG_Printf(DBG_INFO, \"[INFO] - Button map name: %s\\n\", qPrintable(buttonMapName));\n            int mapItem = 0;\n\n            if (i.value().isObject())        // Check if individual button map is an object\n            {\n                QJsonObject buttonMapObj = i.value().toObject();\n\n                if (buttonMapObj.value(QString(\"map\")).isArray())   // Check if button map is an array of arrays\n                {\n                    std::vector<ButtonMap::Item> btnMapVec;\n                    QJsonArray buttonMapArr = buttonMapObj.value(QString(\"map\")).toArray();\n                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map size: %d\\n\", i.value().toArray().size());\n\n                    for (auto i = buttonMapArr.constBegin(); i != buttonMapArr.constEnd(); ++i, mapItem++)       // Loop through button map items\n                    {\n                        QJsonValue val = *i;\n                        if (val.isArray())\n                        {\n                            QJsonArray buttonMapItemArr = val.toArray();\n\n                            if (buttonMapItemArr.size() != 8)\n                            {\n                                DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d for '%s' has an incorrect size. Expected 8, got %d\\n\",\n                                            mapItem, qPrintable(buttonMapName), buttonMapItemArr.size());\n                                continue;\n                            }\n                            else\n                            {\n                                bool ok;\n                                quint16 btn = 0;\n                                ButtonMap::Item btnMap;\n\n                                // Initialize with defaults\n                                btnMap.mode = Sensor::ModeNone;\n                                btnMap.endpoint = 0;\n                                btnMap.clusterId = 0;\n                                btnMap.zclCommandId = 0;\n                                btnMap.zclParam0 = 0;\n                                btnMap.button = 0;\n                                btnMap.name = \"\";\n\n                                if (buttonMapItemArr.at(0).isDouble())\n                                {\n                                    const auto mode = buttonMapItemArr.at(0).toInt();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #1: %d\\n\", buttonMapItemArr.at(0).toUint());\n                                    if      (mode == 0) { btnMap.mode = Sensor::ModeNone; }\n                                    else if (mode == 1) { btnMap.mode = Sensor::ModeScenes; }\n                                    else if (mode == 2) { btnMap.mode = Sensor::ModeTwoGroups; }\n                                    else if (mode == 3) { btnMap.mode = Sensor::ModeColorTemperature; }\n                                    else if (mode == 4) { btnMap.mode = Sensor::ModeDimmer; }\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #1 for '%s' does not seem to be an integer. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(1).isString() && buttonMapItemArr.at(1).toString().startsWith(QLatin1String(\"0x\")) &&\n                                    buttonMapItemArr.at(1).toString().length() == 4)\n                                {\n                                    QString ep = buttonMapItemArr.at(1).toString();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #2: %d\\n\", ep.toUint(&ok, 0));\n                                    btnMap.endpoint = ep.toUInt(&ok, 0);\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #2 for '%s' has an incorrect format. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(2).isString() && buttonMapItemArr.at(2).toString().startsWith(QLatin1String(\"0x\")) &&\n                                    buttonMapItemArr.at(2).toString().length() == 6)\n                                {\n                                    QString cid = buttonMapItemArr.at(2).toString();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #3: %d\\n\", cid.toUint(&ok, 0));\n                                    btnMap.clusterId = cid.toUInt(&ok, 0);\n                                }\n                                else if (buttonMapItemArr.at(2).isString() && !buttonMapItemArr.at(2).toString().startsWith(QLatin1String(\"0x\")) &&\n                                         buttonMapItemArr.at(2).toString().length() <= MAX_CLUSTER_CHARACTER_LENGTH)\n                                {\n                                    QString cid = buttonMapItemArr.at(2).toString();\n                                    if (btnMapClusters.value(cid, 65535) != 65535) { btnMap.clusterId = btnMapClusters.value(buttonMapItemArr.at(2).toString()); }\n                                    else\n                                    {\n                                        DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #3 for '%s' was not found in object 'clusters'. Skipping entry.\\n\",\n                                                    mapItem, qPrintable(buttonMapName));\n                                        continue;\n                                    }\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #3 for '%s' has an incorrect format. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(3).isString() && buttonMapItemArr.at(3).toString().startsWith(QLatin1String(\"0x\")) &&\n                                    buttonMapItemArr.at(3).toString().length() == 4)\n                                {\n                                    QString cmd = buttonMapItemArr.at(3).toString();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #4: %d\\n\", cmd.toUint(&ok, 0));\n                                    btnMap.zclCommandId = cmd.toUInt(&ok, 0);\n                                }\n                                else if (buttonMapItemArr.at(3).isString() && !buttonMapItemArr.at(3).toString().startsWith(QLatin1String(\"0x\")) &&\n                                         buttonMapItemArr.at(3).toString().length() <= MAX_COMMAND_CHARACTER_LENGTH)\n                                {\n                                    QString cid = buttonMapItemArr.at(2).toString();\n                                    QString cmd = buttonMapItemArr.at(3).toString();\n\n                                    if (btnMapClusters.value(cid, 65535) != 65535)\n                                    {\n                                        QMap<QString, quint16> temp = btnMapClusterCommands.value(cid);\n\n                                        if (!temp.empty() && temp.value(cmd, 65535) != 65535) { btnMap.zclCommandId = temp.value(cmd); }\n                                        else\n                                        {\n                                            DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #4 for '%s' was not found in object 'commands' for cluster '%s'. Skipping entry.\\n\",\n                                                        mapItem, qPrintable(buttonMapName), qPrintable(cid));\n                                            continue;\n                                        }\n                                    }\n                                    else\n                                    {\n                                        DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #4 for '%s' was not found as cluster in object 'commands'. Skipping entry.\\n\",\n                                                    mapItem, qPrintable(buttonMapName));\n                                        continue;\n                                    }\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #4 for '%s' has an incorrect format. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(4).isString() && buttonMapItemArr.at(4).toString().length() <= 3)\n                                {\n                                    QString para = buttonMapItemArr.at(4).toString();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #5: %d\\n\", para.toUint(&ok, 0));\n                                    btnMap.zclParam0 = para.toUInt(&ok, 0);\n                                }\n                                else if (buttonMapItemArr.at(4).isString() && buttonMapItemArr.at(4).toString().startsWith(QLatin1String(\"0x\")) &&\n                                         (buttonMapItemArr.at(4).toString().length() == 4 || buttonMapItemArr.at(4).toString().length() == 6))\n                                {\n                                    QString para = buttonMapItemArr.at(4).toString();\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #5: %d\\n\", para.toUint(&ok, 0));\n                                    btnMap.zclParam0 = para.toUInt(&ok, 0);\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #5 for '%s' has an incorrect format. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(5).isString() && buttonMapItemArr.at(5).toString().length() <= MAX_BUTTON_CHARACTER_LENGTH)\n                                {\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #6: %s\\n\", qPrintable(buttonMapItemArr.at(5).toString()));\n                                    btn = buttons.value(buttonMapItemArr.at(5).toString(), 0);\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #6 for '%s' is unknown. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(6).isString() && buttonMapItemArr.at(6).toString().length() <= MAX_BUTTON_ACTION_CHARACTER_LENGTH)\n                                {\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #7: %s\\n\", qPrintable(buttonMapItemArr.at(6).toString()));\n                                    btn += actions.value(buttonMapItemArr.at(6).toString(), 0);\n                                    btnMap.button = btn;\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #7 for '%s' is unknown. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n                                if (buttonMapItemArr.at(7).isString() && buttonMapItemArr.at(7).toString().length() <= MAX_DESCRIPTION_CHARACTER_LENGTH)\n                                {\n                                    //DBG_Printf(DBG_INFO, \"[INFO] - Button map item #8: %s\\n\", qPrintable(buttonMapItemArr.at(7).toString()));\n                                    btnMap.name = buttonMapItemArr.at(7).toString();\n                                }\n                                else\n                                {\n                                    DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d, field #8 for '%s' is too long. Skipping entry.\\n\",\n                                                mapItem, qPrintable(buttonMapName));\n                                    continue;\n                                }\n\n\n                                //DBG_Printf(DBG_INFO, \"[INFO] - btnMap item #6: %d\\n\", btnMap.button);\n                                //DBG_Printf(DBG_INFO, \"[INFO] - btnMap item #7: %s\\n\", qPrintable(btnMap.name));\n                                btnMapVec.push_back(btnMap);\n                            }\n                        }\n                        else\n                        {\n                            DBG_Printf(DBG_INFO, \"[ERROR] - Button map item #%d for '%s' in JSON must be an array, but isn't.\\n\",\n                                        mapItem, qPrintable(buttonMapName));\n                            continue;\n                        }\n                    }\n\n                    ButtonMapRef buttonMapRef;\n                    buttonMapRef.hash = qHash(buttonMapName);\n                    buttonMapRef.index = result.size();\n\n#ifdef QT_DEBUG\n                    {\n                        ButtonMapRef ref = BM_ButtonMapRefForHash(buttonMapRef.hash, result);\n                        if (isValid(ref))\n                        {\n                            DBG_Printf(DBG_INFO, \"[ERROR] - Button map duplicated hash for %s\\n\", qPrintable(buttonMapName));\n                        }\n                    }\n#endif\n\n                    result.emplace_back(ButtonMap{std::move(btnMapVec), buttonMapRef});\n                }\n                else\n                {\n                    DBG_Printf(DBG_INFO, \"[ERROR] - Expected 'map' of button map '%s' in JSON file to be an array, but isn't. Skip loading button map...\\n\", qPrintable(buttonMapName));\n                    continue;   // Skip button map\n                }\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"[ERROR] - Expected '%s' in JSON file to be an object, but it isn't. Skip loading button map...\\n\", qPrintable(buttonMapName));\n                continue;   // Skip button map\n            }\n        }\n\n        DBG_Printf(DBG_INFO, \"[INFO] - Button maps loaded.\\n\");\n\n        return result;\n}\n\nstd::vector<ButtonMeta> loadButtonMetaJson(const QJsonDocument &buttonMapsDoc, const std::vector<ButtonMap> &buttonMaps)\n{\n    std::vector<ButtonMeta> result;\n\n    const QLatin1String buttonPrefix(\"S_BUTTON_\");\n    const QJsonObject mapsObj = buttonMapsDoc.object().value(QLatin1String(\"maps\")).toObject();     // Get all button maps\n\n    for (auto i = mapsObj.constBegin(); i != mapsObj.constEnd(); ++i)       // Loop through button maps\n    {\n        ButtonMeta meta;\n        meta.buttons.reserve(4);\n        meta.buttonMapRef = BM_ButtonMapRefForHash(qHash(i.key()), buttonMaps);    // Individual button map name\n\n        if (!isValid(meta.buttonMapRef))\n        {\n            continue;\n        }\n\n        if (!i.value().isObject())\n        {\n            continue;\n        }\n\n        const QJsonObject buttonMapObj = i.value().toObject();\n        if (!buttonMapObj.value(QLatin1String(\"buttons\")).isArray())\n        {\n            continue;\n        }\n\n        const QJsonArray buttons = buttonMapObj.value(QLatin1String(\"buttons\")).toArray();\n\n        for (auto j = buttons.constBegin(); j != buttons.constEnd(); ++j)\n        {\n            if (!j->isObject())\n            {\n                continue;\n            }\n\n            const QJsonObject buttonObj = j->toObject();\n            const auto keys = buttonObj.keys();\n            for (const auto &k : keys)\n            {\n                if (!k.startsWith(buttonPrefix))\n                {\n                    continue;\n                }\n\n                bool ok = false;\n                ButtonMeta::Button b;\n                b.button = k.midRef(buttonPrefix.size()).toInt(&ok);\n\n                if (ok)\n                {\n                    b.name = buttonObj.value(k).toString();\n                    meta.buttons.push_back(b);\n                }\n            }\n        }\n\n        if (!meta.buttons.empty())\n        {\n            result.push_back(std::move(meta));\n        }\n    }\n\n    return result;\n}\n"
        },
        {
          "name": "read_files.h",
          "type": "blob",
          "size": 0.8759765625,
          "content": "#ifndef READ_FILES_H\n#define READ_FILES_H\n\n#include <QJsonDocument>\n#include \"button_maps.h\"\n\nQJsonDocument readButtonMapJson(const QString &path);\nbool checkRootLevelObjectsJson(const QJsonDocument &buttonMaps, const QStringList &requiredObjects);\nQMap<QString, quint16> loadButtonMapClustersJson(const QJsonDocument &buttonMaps);\nQMap<QString, QMap<QString, quint16>> loadButtonMapCommadsJson(const QJsonDocument &buttonMaps);\nstd::vector<ButtonProduct> loadButtonMapModelIdsJson(const QJsonDocument &buttonMapsDoc, const std::vector<ButtonMap> &buttonMaps);\nstd::vector<ButtonMeta> loadButtonMetaJson(const QJsonDocument &buttonMapsDoc, const std::vector<ButtonMap> &buttonMaps);\nstd::vector<ButtonMap> loadButtonMapsJson(const QJsonDocument &buttonMaps, const QMap<QString, quint16> &btnMapClusters, const QMap<QString, QMap<QString, quint16>> &btnMapClusterCommands);\n\n#endif // READ_FILES_H\n"
        },
        {
          "name": "reset_device.cpp",
          "type": "blob",
          "size": 9.9345703125,
          "content": "/*\r\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include \"de_web_plugin_private.h\"\r\n#include \"utils/utils.h\"\r\n\r\n#define CHECK_RESET_DEVICES 3000\r\n#define WAIT_CONFIRM 2000\r\n#define WAIT_INDICATION 5000\r\n\r\n/*! Init the reset device api\r\n */\r\nvoid DeRestPluginPrivate::initResetDeviceApi()\r\n{\r\n    resetDeviceTimer = new QTimer(this);\r\n    resetDeviceTimer->setSingleShot(true);\r\n    connect(resetDeviceTimer, SIGNAL(timeout()),\r\n            this, SLOT(resetDeviceTimerFired()));\r\n    zdpResetSeq = 0;\r\n    lastNodeAddressExt = 0;\r\n    resetDeviceState = ResetIdle;\r\n    resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n}\r\n\r\n/*! Check all light nodes if they need to be reseted.\r\n */\r\nvoid DeRestPluginPrivate::checkResetState()\r\n{\r\n    if (!apsCtrl || !isInNetwork() || searchSensorsState == SearchSensorsActive || searchLightsState == SearchLightsActive)\r\n    {\r\n        resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n        return;\r\n    }\r\n\r\n    std::vector<LightNode>::iterator i = nodes.begin();\r\n    std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (/*i->isAvailable() && */ i->state() == LightNode::StateDeleted && i->resetRetryCount() > 0)\r\n        {\r\n            uint8_t retryCount = i->resetRetryCount();\r\n            retryCount--;\r\n            i->setResetRetryCount(retryCount);\r\n\r\n            // check if light has already a new pairing\r\n            for (const LightNode &l : nodes)\r\n            {\r\n                if (l.address().ext() == i->address().ext() && l.state() == LightNode::StateNormal)\r\n                {\r\n                    i->setResetRetryCount(0);\r\n                    retryCount = 0; // do nothing\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (retryCount > 0 && i->address().ext() != lastNodeAddressExt) // prefer unhandled nodes\r\n            {\r\n                DBG_Printf(DBG_INFO, \"reset device retries: %i\\n\", retryCount);\r\n                // send mgmt_leave_request\r\n                lastNodeAddressExt = i->address().ext();\r\n                zdpResetSeq += 1;\r\n                i->setZdpResetSeq(zdpResetSeq);\r\n\r\n                deCONZ::ApsDataRequest req;\r\n\r\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\r\n                req.setTxOptions(0);\r\n#endif\r\n                req.setDstEndpoint(ZDO_ENDPOINT);\r\n                req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n                req.dstAddress().setExt(i->address().ext());\r\n                req.setProfileId(ZDP_PROFILE_ID);\r\n                req.setClusterId(ZDP_MGMT_LEAVE_REQ_CLID);\r\n                req.setSrcEndpoint(ZDO_ENDPOINT);\r\n                req.setRadius(0);\r\n\r\n                QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\r\n                stream.setByteOrder(QDataStream::LittleEndian);\r\n                stream << zdpResetSeq; // seq no.\r\n                stream << (quint64)i->address().ext(); // device address\r\n\r\n                uint8_t flags = 0;\r\n                //                    flags |= 0x40; // remove children\r\n                //                    flags |= 0x80; // rejoin\r\n                stream << flags; // flags\r\n\r\n                if (apsCtrlWrapper.apsdeDataRequest(req) == deCONZ::Success)\r\n                {\r\n                    resetDeviceApsRequestId = req.id();\r\n                    resetDeviceState = ResetWaitConfirm;\r\n                    resetDeviceTimer->start(WAIT_CONFIRM);\r\n                    DBG_Printf(DBG_INFO, \"reset device apsdeDataRequest success\\n\");\r\n                    return;\r\n                }\r\n                else\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"can't send reset device apsdeDataRequest\\n\");\r\n                }\r\n            }\r\n        }\r\n        lastNodeAddressExt = 0;\r\n    }\r\n\r\n    const auto now = QDateTime::currentDateTime();\r\n    std::vector<Sensor>::iterator si = sensors.begin();\r\n    std::vector<Sensor>::iterator si_end = sensors.end();\r\n\r\n    for (; si != si_end; ++si)\r\n    {\r\n        if (si->isAvailable() && si->resetRetryCount() > 0 && si->node())\r\n        {\r\n            if (!si->node()->nodeDescriptor().receiverOnWhenIdle() && si->lastRx().secsTo(now) > 6)\r\n            {\r\n                // wait until awake\r\n                continue;\r\n            }\r\n\r\n            uint8_t retryCount = si->resetRetryCount();\r\n            retryCount--;\r\n            si->setResetRetryCount(retryCount);\r\n            DBG_Printf(DBG_INFO, \"reset device retries: %i\\n\", retryCount);\r\n\r\n            if (retryCount > 0 && si->address().ext() != lastNodeAddressExt) // prefer unhandled nodes\r\n            {\r\n                // send mgmt_leave_request\r\n                lastNodeAddressExt = si->address().ext();\r\n                zdpResetSeq += 1;\r\n                si->setZdpResetSeq(zdpResetSeq);\r\n\r\n                deCONZ::ApsDataRequest req;\r\n\r\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\r\n                req.setTxOptions(0);\r\n#endif\r\n                req.setDstEndpoint(ZDO_ENDPOINT);\r\n                req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n                req.dstAddress().setExt(si->address().ext());\r\n                req.setProfileId(ZDP_PROFILE_ID);\r\n                req.setClusterId(ZDP_MGMT_LEAVE_REQ_CLID);\r\n                req.setSrcEndpoint(ZDO_ENDPOINT);\r\n                req.setRadius(0);\r\n\r\n                QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\r\n                stream.setByteOrder(QDataStream::LittleEndian);\r\n                stream << zdpResetSeq; // seq no.\r\n                stream << (quint64)si->address().ext(); // device address\r\n\r\n                uint8_t flags = 0;\r\n                //                    flags |= 0x40; // remove children\r\n                //                    flags |= 0x80; // rejoin\r\n                stream << flags; // flags\r\n\r\n                if (apsCtrlWrapper.apsdeDataRequest(req) == deCONZ::Success)\r\n                {\r\n                    resetDeviceApsRequestId = req.id();\r\n                    resetDeviceState = ResetWaitConfirm;\r\n                    resetDeviceTimer->start(WAIT_CONFIRM);\r\n                    DBG_Printf(DBG_INFO, \"reset device apsdeDataRequest success\\n\");\r\n                    return;\r\n                }\r\n                else\r\n                {\r\n                    DBG_Printf(DBG_ERROR, \"can't send reset device apsdeDataRequest\\n\");\r\n                }\r\n\r\n            }\r\n        }\r\n        lastNodeAddressExt = 0;\r\n    }\r\n\r\n    resetDeviceState = ResetIdle;\r\n    resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n}\r\n\r\n/*! Handle confirmation of ZDP reset device request.\r\n    \\param success true on success\r\n */\r\nvoid DeRestPluginPrivate::resetDeviceSendConfirm(bool success)\r\n{\r\n    if (resetDeviceState == ResetWaitConfirm)\r\n    {\r\n        resetDeviceTimer->stop();\r\n        if (success)\r\n        {\r\n           resetDeviceState = ResetWaitIndication;\r\n           resetDeviceTimer->start(WAIT_INDICATION);\r\n        }\r\n        else\r\n        {\r\n            resetDeviceState = ResetIdle;\r\n            DBG_Printf(DBG_INFO, \"reset device apsdeDataConfirm fail\\n\");\r\n            resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n        }\r\n    }\r\n}\r\n\r\n/*! Handle mgmt leave response.\r\n    \\param ind a ZDP MgmtLeave_rsp\r\n */\r\nvoid DeRestPluginPrivate::handleMgmtLeaveRspIndication(const deCONZ::ApsDataIndication &ind)\r\n{\r\n    if (resetDeviceState == ResetWaitIndication)\r\n    {\r\n        if (ind.asdu().size() < 2)\r\n        {\r\n            // at least seq number and status\r\n            return;\r\n        }\r\n\r\n        resetDeviceTimer->stop();\r\n\r\n        QDataStream stream(ind.asdu());\r\n        stream.setByteOrder(QDataStream::LittleEndian);\r\n\r\n        quint8 seqNo;\r\n        quint8 status;\r\n\r\n        stream >> seqNo;    // use SeqNo ?\r\n        stream >> status;\r\n\r\n        DBG_Printf(DBG_INFO, \"MgmtLeave_rsp \" FMT_MAC \" seq: %u, status 0x%02X \\n\", (unsigned long long)ind.srcAddress().ext(), seqNo, status);\r\n\r\n        if (status == deCONZ::ZdpSuccess || status == deCONZ::ZdpNotSupported)\r\n        {\r\n            // set retryCount and isAvailable for all endpoints of that device\r\n            std::vector<LightNode>::iterator i;\r\n            std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n            for (i = nodes.begin(); i != end; ++i)\r\n            {\r\n                if (isSameAddress(ind.srcAddress(), i->address()))\r\n                {\r\n                   i->setResetRetryCount(0);\r\n                   if (i->state() == LightNode::StateDeleted)\r\n                   {\r\n                       i->item(RStateReachable)->setValue(false);\r\n                   }\r\n                }\r\n            }\r\n\r\n            std::vector<Sensor>::iterator s;\r\n            std::vector<Sensor>::iterator send = sensors.end();\r\n\r\n            for (s = sensors.begin(); s != send; ++s)\r\n            {\r\n                if (isSameAddress(ind.srcAddress(), s->address()))\r\n                {\r\n                   s->setResetRetryCount(0);\r\n                   s->item(RConfigReachable)->setValue(false);\r\n                }\r\n            }\r\n        }\r\n\r\n        resetDeviceState = ResetIdle;\r\n        resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n    }\r\n}\r\n\r\n/*! Starts a delayed action based on current delete device state.\r\n */\r\nvoid DeRestPluginPrivate::resetDeviceTimerFired()\r\n{\r\n    switch (resetDeviceState)\r\n    {\r\n    case ResetIdle:\r\n    {\r\n        checkResetState();\r\n    }\r\n        break;\r\n\r\n    case ResetWaitConfirm:\r\n    {\r\n        DBG_Printf(DBG_INFO, \"reset device wait for confirm timeout.\\n\");\r\n        resetDeviceState = ResetIdle;\r\n        resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n    }\r\n        break;\r\n\r\n    case ResetWaitIndication:\r\n    {\r\n        DBG_Printf(DBG_INFO, \"reset device wait for indication timeout.\\n\");\r\n        resetDeviceState = ResetIdle;\r\n        resetDeviceTimer->start(CHECK_RESET_DEVICES);\r\n    }\r\n        break;\r\n\r\n    default:\r\n        DBG_Printf(DBG_INFO, \"deleteDeviceTimerFired() unhandled state %d\\n\", resetDeviceState);\r\n        break;\r\n    }\r\n}\r\n"
        },
        {
          "name": "resource.cpp",
          "type": "blob",
          "size": 78.01171875,
          "content": "/*\n * Copyright (c) 2017-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n\n#include <deconz/u_assert.h>\n#include <deconz/dbg_trace.h>\n#include <utils/stringcache.h>\n#include \"resource.h\"\n\nconst char *RAlarmSystems = \"/alarmsystems\";\nconst char *RConfig = \"/config\";\nconst char *RDevices = \"/devices\";\nconst char *RGroups = \"/groups\";\nconst char *RLights = \"/lights\";\nconst char *RSensors = \"/sensors\";\n\nconst char *REventActiveEndpoints = \"event/active.endpoints\";\nconst char *REventAdded = \"event/added\";\nconst char *REventApsConfirm = \"event/aps.confirm\";\nconst char *REventAwake = \"event/awake\";\nconst char *REventBindingTable = \"event/binding.table\";\nconst char *REventBindingTick = \"event/binding.tick\";\nconst char *REventCheckGroupAnyOn = \"event/checkgroupanyon\";\nconst char *REventDDFInitRequest = \"event/ddf.init.req\";\nconst char *REventDDFInitResponse = \"event/ddf.init.rsp\";\nconst char *REventDDFReload = \"event/ddf.reload\";\nconst char *REventDeleted = \"event/deleted\";\nconst char *REventDeviceAlarm = \"event/devicealarm\";\nconst char *REventDeviceAnnounce = \"event/device.anounce\";\nconst char *REventNodeDescriptor = \"event/node.descriptor\";\nconst char *REventPermitjoinDisabled = \"event/permit.join.disabled\";\nconst char *REventPermitjoinEnabled = \"event/permit.join.enabled\";\nconst char *REventPermitjoinRunning = \"event/permit.join.running\";\nconst char *REventPoll = \"event/poll\";\nconst char *REventSimpleDescriptor = \"event/simple.descriptor\";\nconst char *REventStartTimer = \"event/start.timer\";\nconst char *REventStateEnter = \"event/state.enter\";\nconst char *REventStateLeave = \"event/state.leave\";\nconst char *REventStateTimeout = \"event/state.timeout\";\nconst char *REventStopTimer = \"event/stop.timer\";\nconst char *REventTick = \"event/tick\";\nconst char *REventTimerFired = \"event/timerfired\";\nconst char *REventValidGroup = \"event/validgroup\";\nconst char *REventZclReadReportConfigResponse = \"event/zcl.read.report.config.response\";\nconst char *REventZclResponse = \"event/zcl.response\";\nconst char *REventZdpReload = \"event/zdp.reload\";\nconst char *REventZdpMgmtBindResponse = \"event/zdp.mgmt.bind.response\";\nconst char *REventZdpResponse = \"event/zdp.response\";\n\nconst char *RInvalidSuffix = \"invalid/suffix\";\n\nconst char *RAttrAppVersion = \"attr/appversion\";\nconst char *RAttrClass = \"attr/class\";\nconst char *RAttrConfigId = \"attr/configid\";\nconst char *RAttrDdfHash = \"attr/ddf_hash\";\nconst char *RAttrDdfPolicy = \"attr/ddf_policy\";\nconst char *RAttrExtAddress = \"attr/extaddress\";\nconst char *RAttrGroupAddress = \"attr/groupaddress\";\nconst char *RAttrId = \"attr/id\";\nconst char *RAttrLastAnnounced = \"attr/lastannounced\";\nconst char *RAttrLastSeen = \"attr/lastseen\";\nconst char *RAttrLevelMin = \"attr/levelmin\";\nconst char *RAttrManufacturerName = \"attr/manufacturername\";\nconst char *RAttrMode = \"attr/mode\";\nconst char *RAttrModelId = \"attr/modelid\";\nconst char *RAttrName = \"attr/name\";\nconst char *RAttrNwkAddress = \"attr/nwkaddress\";\nconst char *RCapOtauFileVersion = \"cap/otau/file_version\";\nconst char *RCapOtauImageType = \"cap/otau/image_type\";\nconst char *RCapOtauManufacturerCode = \"cap/otau/manufacturer_code\";\nconst char *RAttrOtaVersion = \"attr/otaversion\";\nconst char *RAttrPowerOnCt = \"attr/poweronct\";\nconst char *RAttrPowerOnLevel = \"attr/poweronlevel\";\nconst char *RAttrPowerup = \"attr/powerup\";\nconst char *RAttrProductId = \"attr/productid\";\nconst char *RAttrProductName = \"attr/productname\";\nconst char *RAttrSwconfigid = \"attr/swconfigid\";\nconst char *RAttrSwVersion = \"attr/swversion\";\nconst char *RAttrSwVersionBis = \"attr/swversion_bis\";\nconst char *RAttrType = \"attr/type\";\nconst char *RAttrUniqueId = \"attr/uniqueid\";\nconst char *RAttrZoneType = \"attr/zonetype\";\n\nconst char *RActionScene = \"action/scene\";\n\nconst char *RStateAction = \"state/action\";\nconst char *RStateAirQuality = \"state/airquality\";\nconst char *RStateAirQualityBis = \"state/airquality_bis\";\nconst char *RStateAirQualityPpb = \"state/airqualityppb\";\nconst char *RStateAirQualityPpbBis = \"state/airqualityppb_bis\";\nconst char *RStateAlarm = \"state/alarm\";\nconst char *RStateAlert = \"state/alert\";\nconst char *RStateAllOn = \"state/all_on\";\nconst char *RStateAngle = \"state/angle\";\nconst char *RStateAnyOn = \"state/any_on\";\nconst char *RStateArmState = \"state/armstate\";\nconst char *RStateBattery = \"state/battery\";\nconst char *RStateBri = \"state/bri\";\nconst char *RStateButtonEvent = \"state/buttonevent\";\nconst char *RStateCarbonMonoxide = \"state/carbonmonoxide\";\nconst char *RStateCharging = \"state/charging\";\nconst char *RStateColorMode = \"state/colormode\";\nconst char *RStateConsumption = \"state/consumption\";\nconst char *RStateConsumption_2 = \"state/consumption_2\";\nconst char *RStateCt = \"state/ct\";\nconst char *RStateCurrent = \"state/current\";\nconst char *RStateCurrent_P1 = \"state/current_P1\";\nconst char *RStateCurrent_P2 = \"state/current_P2\";\nconst char *RStateCurrent_P3 = \"state/current_P3\";\nconst char *RStateDark = \"state/dark\";\nconst char *RStateDaylight = \"state/daylight\";\nconst char *RStateDeviceRunTime = \"state/deviceruntime\";\nconst char *RStateEffect = \"state/effect\";\nconst char *RStateErrorCode = \"state/errorcode\";\nconst char *RStateEventDuration = \"state/eventduration\";\nconst char *RStateExpectedEventDuration = \"state/expectedeventduration\";\nconst char *RStateExpectedRotation = \"state/expectedrotation\";\nconst char *RStateFilterRunTime = \"state/filterruntime\";\nconst char *RStateFire = \"state/fire\";\nconst char *RStateFlag = \"state/flag\";\nconst char *RStateFloorTemperature = \"state/floortemperature\";\nconst char *RStateGPDFrameCounter = \"state/gpd_frame_counter\";\nconst char *RStateGPDLastPair = \"state/gpd_last_pair\";\nconst char *RStateGesture = \"state/gesture\";\nconst char *RStateGradient = \"state/gradient\";\nconst char *RStateHeating = \"state/heating\";\nconst char *RStateHue = \"state/hue\";\nconst char *RStateHumidity = \"state/humidity\";\nconst char *RStateHumidityBis = \"state/humidity_bis\";\nconst char *RStateLastCheckin = \"state/lastcheckin\";\nconst char *RStateLastSet = \"state/lastset\";\nconst char *RStateLastUpdated = \"state/lastupdated\";\nconst char *RStateLift = \"state/lift\";\nconst char *RStateLightLevel = \"state/lightlevel\";\nconst char *RStateLocaltime = \"state/localtime\";\nconst char *RStateLockState = \"state/lockstate\";\nconst char *RStateLowBattery = \"state/lowbattery\";\nconst char *RStateLux = \"state/lux\";\nconst char *RStateMeasuredValue = \"state/measured_value\";\nconst char *RStateMoisture = \"state/moisture\";\nconst char *RStateMountingModeActive = \"state/mountingmodeactive\";\nconst char *RStateMusicSync = \"state/music_sync\";\nconst char *RStateOn = \"state/on\";\nconst char *RStateOpen = \"state/open\";\nconst char *RStateOpenBis = \"state/open_bis\";\nconst char *RStateOrientationX = \"state/orientation_x\";\nconst char *RStateOrientationY = \"state/orientation_y\";\nconst char *RStateOrientationZ = \"state/orientation_z\";\nconst char *RStatePM2_5 = \"state/pm2_5\";\nconst char *RStatePanel = \"state/panel\";\nconst char *RStatePower = \"state/power\";\nconst char *RStatePresence = \"state/presence\";\nconst char *RStatePresenceEvent = \"state/presenceevent\";\nconst char *RStatePressure = \"state/pressure\";\nconst char *RStatePressureBis = \"state/pressure_bis\";\nconst char *RStateProduction = \"state/production\";\nconst char *RStateReachable = \"state/reachable\";\nconst char *RStateReplaceFilter = \"state/replacefilter\";\nconst char *RStateRotaryEvent = \"state/rotaryevent\";\nconst char *RStateSat = \"state/sat\";\nconst char *RStateSecondsRemaining = \"state/seconds_remaining\";\nconst char *RStateSpectralX = \"state/spectral_x\";\nconst char *RStateSpectralY = \"state/spectral_y\";\nconst char *RStateSpectralZ = \"state/spectral_z\";\nconst char *RStateSpeed = \"state/speed\";\nconst char *RStateStatus = \"state/status\";\nconst char *RStateSunrise = \"state/sunrise\";\nconst char *RStateSunset = \"state/sunset\";\nconst char *RStateTampered = \"state/tampered\";\nconst char *RStateTemperature = \"state/temperature\";\nconst char *RStateTemperatureBis = \"state/temperature_bis\";\nconst char *RStateTest = \"state/test\";\nconst char *RStateTilt = \"state/tilt\";\nconst char *RStateTiltAngle = \"state/tiltangle\";\nconst char *RStateUtc = \"state/utc\";\nconst char *RStateValve = \"state/valve\";\nconst char *RStateVibration = \"state/vibration\";\nconst char *RStateVibrationStrength = \"state/vibrationstrength\";\nconst char *RStateVoltage = \"state/voltage\";\nconst char *RStateWater = \"state/water\";\nconst char *RStateWaterBis = \"state/water_bis\";\nconst char *RStateWindowOpen = \"state/windowopen\";\nconst char *RStateX = \"state/x\";\nconst char *RStateY = \"state/y\";\n\nconst QStringList RStateAlertValues({\n    \"none\", \"select\", \"lselect\"\n});\n\nconst QStringList RStateAlertValuesTriggerEffect({\n    \"none\", \"select\", \"lselect\", \"blink\", \"breathe\", \"okay\", \"channelchange\", \"finish\", \"stop\"\n});\n\nconst QStringList RStateEffectValues({\n    \"none\", \"colorloop\"\n});\nconst QStringList RStateEffectValuesMueller({\n    \"none\", \"colorloop\", \"sunset\", \"party\", \"worklight\", \"campfire\", \"romance\", \"nightlight\"\n});\n\nconst char *RCapAlertTriggerEffect = \"cap/alert/trigger_effect\";\nconst char *RCapBriMinDimLevel = \"cap/bri/min_dim_level\";\nconst char *RCapBriMoveWithOnOff = \"cap/bri/move_with_onoff\";\nconst char *RCapColorCapabilities = \"cap/color/capabilities\";\nconst char *RCapColorCtComputesXy = \"cap/color/ct/computes_xy\";\nconst char *RCapColorCtMax = \"cap/color/ct/max\";\nconst char *RCapColorCtMin = \"cap/color/ct/min\";\nconst char *RCapColorEffects = \"cap/color/effects\";\nconst char *RCapColorGamutType = \"cap/color/gamut_type\";\nconst char *RCapColorGradientMaxSegments = \"cap/color/gradient/max_segments\";\nconst char *RCapColorGradientPixelCount = \"cap/color/gradient/pixel_count\";\nconst char *RCapColorGradientPixelLength = \"cap/color/gradient/pixel_length\";\nconst char *RCapColorGradientStyles = \"cap/color/gradient/styles\";\nconst char *RCapColorXyBlueX = \"cap/color/xy/blue_x\";\nconst char *RCapColorXyBlueY = \"cap/color/xy/blue_y\";\nconst char *RCapColorXyGreenX = \"cap/color/xy/green_x\";\nconst char *RCapColorXyGreenY = \"cap/color/xy/green_y\";\nconst char *RCapColorXyRedX = \"cap/color/xy/red_x\";\nconst char *RCapColorXyRedY = \"cap/color/xy/red_y\";\nconst char *RCapGroup = \"cap/group\";\nconst char *RCapGroupsNotSupported = \"cap/groups/not_supported\";\nconst char *RCapMeasuredValueMax = \"cap/measured_value/max\";\nconst char *RCapMeasuredValueMin = \"cap/measured_value/min\";\nconst char *RCapMeasuredValueQuantity = \"cap/measured_value/quantity\";\nconst char *RCapMeasuredValueSubstance = \"cap/measured_value/substance\";\nconst char *RCapMeasuredValueUnit = \"cap/measured_value/unit\";\nconst char *RCapOnOffWithEffect = \"cap/on/off_with_effect\";\nconst char *RCapSleeper = \"cap/sleeper\";\nconst char *RCapTransitionBlock = \"cap/transition_block\";\n\nconst char *RConfigAlarmSystemId = \"config/alarmsystemid\";\nconst char *RConfigAlert = \"config/alert\";\nconst char *RConfigAllowTouchlink = \"config/allowtouchlink\";\nconst char *RConfigArmMode = \"config/armmode\";\nconst char *RConfigArmedAwayEntryDelay = \"config/armed_away_entry_delay\";\nconst char *RConfigArmedAwayExitDelay = \"config/armed_away_exit_delay\";\nconst char *RConfigArmedAwayTriggerDuration = \"config/armed_away_trigger_duration\";\nconst char *RConfigArmedNightEntryDelay = \"config/armed_night_entry_delay\";\nconst char *RConfigArmedNightExitDelay = \"config/armed_night_exit_delay\";\nconst char *RConfigArmedNightTriggerDuration = \"config/armed_night_trigger_duration\";\nconst char *RConfigArmedStayEntryDelay = \"config/armed_stay_entry_delay\";\nconst char *RConfigArmedStayExitDelay = \"config/armed_stay_exit_delay\";\nconst char *RConfigArmedStayTriggerDuration = \"config/armed_stay_trigger_duration\";\nconst char *RConfigBattery = \"config/battery\";\nconst char *RConfigBatteryBis = \"config/battery_bis\";\nconst char *RConfigBriCoupleCt = \"config/bri/couple_ct\";\nconst char *RConfigBriExecuteIfOff = \"config/bri/execute_if_off\";\nconst char *RConfigBriMax = \"config/bri/max\";\nconst char *RConfigBriMin = \"config/bri/min\";\nconst char *RConfigBriOnLevel = \"config/bri/on_level\";\nconst char *RConfigBriOnOffTransitiontime = \"config/bri/onoff_transitiontime\";\nconst char *RConfigBriOptions = \"config/bri/options\";\nconst char *RConfigBriStartup = \"config/bri/startup\";\nconst char *RConfigCheckin = \"config/checkin\";\nconst char *RConfigClickMode = \"config/clickmode\";\nconst char *RConfigColorCapabilities = \"config/colorcapabilities\";\nconst char *RConfigColorCtStartup = \"config/color/ct/startup\";\nconst char *RConfigColorExecuteIfOff = \"config/color/execute_if_off\";\nconst char *RConfigColorGradientPixelCount = \"config/color/gradient/pixel_count\";\nconst char *RConfigColorGradientReversed = \"config/color/gradient/reversed\";\nconst char *RConfigColorXyStartupX = \"config/color/xy/startup_x\";\nconst char *RConfigColorXyStartupY = \"config/color/xy/startup_y\";\nconst char *RConfigConfigured = \"config/configured\";\nconst char *RConfigTuyaUnlock = \"config/tuya_unlock\";\nconst char *RConfigControlSequence = \"config/controlsequence\";\nconst char *RConfigCoolSetpoint = \"config/coolsetpoint\";\nconst char *RConfigCtMax = \"config/ctmax\";\nconst char *RConfigCtMin = \"config/ctmin\";\nconst char *RConfigDelay = \"config/delay\";\nconst char *RConfigDetectionRange = \"config/detectionrange\";\nconst char *RConfigDeviceMode = \"config/devicemode\";\nconst char *RConfigDeviceModeBis = \"config/devicemode_bis\";\nconst char *RConfigDisarmedEntryDelay = \"config/disarmed_entry_delay\";\nconst char *RConfigDisarmedExitDelay = \"config/disarmed_exit_delay\";\nconst char *RConfigDisplayFlipped = \"config/displayflipped\";\nconst char *RConfigDuration = \"config/duration\";\nconst char *RConfigEnrolled = \"config/enrolled\";\nconst char *RConfigExternalTemperatureSensor = \"config/externalsensortemp\";\nconst char *RConfigExternalWindowOpen = \"config/externalwindowopen\";\nconst char *RConfigFanMode = \"config/fanmode\";\nconst char *RConfigFilterLifeTime = \"config/filterlifetime\";\nconst char *RConfigGPDDeviceId = \"config/gpd_device_id\";\nconst char *RConfigGPDKey = \"config/gpd_key\";\nconst char *RConfigGroup = \"config/group\";\nconst char *RConfigHeatSetpoint = \"config/heatsetpoint\";\nconst char *RConfigHostFlags = \"config/hostflags\";\nconst char *RConfigHumiMaxThreshold = \"config/humiditymaxthreshold\";\nconst char *RConfigHumiMinThreshold = \"config/humidityminthreshold\";\nconst char *RConfigInterfaceMode = \"config/interfacemode\";\nconst char *RConfigLastChangeAmount = \"config/lastchange_amount\";\nconst char *RConfigLastChangeSource = \"config/lastchange_source\";\nconst char *RConfigLastChangeTime = \"config/lastchange_time\";\nconst char *RConfigLat = \"config/lat\";\nconst char *RConfigLedIndication = \"config/ledindication\";\nconst char *RConfigLoadBalancing = \"config/loadbalancing\";\nconst char *RConfigLocalTime = \"config/localtime\";\nconst char *RConfigLock = \"config/lock\";\nconst char *RConfigLocked = \"config/locked\";\nconst char *RConfigLong = \"config/long\";\nconst char *RConfigMelody = \"config/melody\";\nconst char *RConfigMode = \"config/mode\";\nconst char *RConfigMountingMode = \"config/mountingmode\";\nconst char *RConfigOffset = \"config/offset\";\nconst char *RConfigOn = \"config/on\";\nconst char *RConfigOnStartup = \"config/on/startup\";\nconst char *RConfigPending = \"config/pending\";\nconst char *RConfigPreset = \"config/preset\";\nconst char *RConfigPulseConfiguration = \"config/pulseconfiguration\";\nconst char *RConfigRadiatorCovered = \"config/radiatorcovered\";\nconst char *RConfigReachable = \"config/reachable\";\nconst char *RConfigReportGrid = \"config/reportgrid\";\nconst char *RConfigResetPresence = \"config/resetpresence\";\nconst char *RConfigReversed = \"config/reversed\";\nconst char *RConfigSchedule = \"config/schedule\";\nconst char *RConfigScheduleOn = \"config/schedule_on\";\nconst char *RConfigSelfTest = \"config/selftest\";\nconst char *RConfigSensitivity = \"config/sensitivity\";\nconst char *RConfigSensitivityBis = \"config/sensitivity_bis\";\nconst char *RConfigSensitivityMax = \"config/sensitivitymax\";\nconst char *RConfigSetValve = \"config/setvalve\";\nconst char *RConfigSpeed = \"config/speed\";\nconst char *RConfigSunriseOffset = \"config/sunriseoffset\";\nconst char *RConfigSunsetOffset = \"config/sunsetoffset\";\nconst char *RConfigSwingMode = \"config/swingmode\";\nconst char *RConfigTempMaxThreshold = \"config/temperaturemaxthreshold\";\nconst char *RConfigTempMinThreshold = \"config/temperatureminthreshold\";\nconst char *RConfigTemperature = \"config/temperature\";\nconst char *RConfigTemperatureMeasurement = \"config/temperaturemeasurement\";\nconst char *RConfigTholdDark = \"config/tholddark\";\nconst char *RConfigTholdOffset = \"config/tholdoffset\";\nconst char *RConfigUnoccupiedHeatSetpoint = \"config/unoccupiedheatsetpoint\";\nconst char *RConfigTriggerDistance = \"config/triggerdistance\";\nconst char *RConfigTriggerDistanceBis = \"config/triggerdistance_bis\";\nconst char *RConfigUbisysJ1AdditionalSteps = \"config/ubisys_j1_additionalsteps\";\nconst char *RConfigUbisysJ1ConfigurationAndStatus = \"config/ubisys_j1_configurationandstatus\";\nconst char *RConfigUbisysJ1InactivePowerThreshold = \"config/ubisys_j1_inactivepowerthreshold\";\nconst char *RConfigUbisysJ1InstalledClosedLimitLift = \"config/ubisys_j1_installedclosedlimitlift\";\nconst char *RConfigUbisysJ1InstalledClosedLimitTilt = \"config/ubisys_j1_installedclosedlimittilt\";\nconst char *RConfigUbisysJ1InstalledOpenLimitLift = \"config/ubisys_j1_installedopenlimitlift\";\nconst char *RConfigUbisysJ1InstalledOpenLimitTilt = \"config/ubisys_j1_installedopenlimittilt\";\nconst char *RConfigUbisysJ1LiftToTiltTransitionSteps = \"config/ubisys_j1_lifttotilttransitionsteps\";\nconst char *RConfigUbisysJ1LiftToTiltTransitionSteps2 = \"config/ubisys_j1_lifttotilttransitionsteps2\";\nconst char *RConfigUbisysJ1Mode = \"config/ubisys_j1_mode\";\nconst char *RConfigUbisysJ1StartupSteps = \"config/ubisys_j1_startupsteps\";\nconst char *RConfigUbisysJ1TotalSteps = \"config/ubisys_j1_totalsteps\";\nconst char *RConfigUbisysJ1TotalSteps2 = \"config/ubisys_j1_totalsteps2\";\nconst char *RConfigUbisysJ1TurnaroundGuardTime = \"config/ubisys_j1_turnaroundguardtime\";\nconst char *RConfigUbisysJ1WindowCoveringType = \"config/ubisys_j1_windowcoveringtype\";\nconst char *RConfigUrl = \"config/url\";\nconst char *RConfigUsertest = \"config/usertest\";\nconst char *RConfigVolume = \"config/volume\";\nconst char *RConfigWindowCoveringType = \"config/windowcoveringtype\";\nconst char *RConfigWindowOpen = \"config/windowopen_set\";\nconst char *RConfigWindowOpenDetectionEnabled = \"config/windowopendetectionenabled\";\n\nconst QStringList RConfigDeviceModeValues({\n    \"singlerocker\", \"singlepushbutton\", \"dualrocker\", \"dualpushbutton\"\n});\n\nconst QStringList RConfigLastChangeSourceValues({\n    \"manual\", \"schedule\", \"zigbee\"\n});\n\nstatic std::vector<ResourceItemDescriptor> rItemDescriptors;\nstatic const QString rInvalidString; // is returned when string is asked but not available\n\nR_Stats rStats;\n\nvoid initResourceDescriptors()\n{\n    rItemDescriptors.clear();\n\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUnknown, QVariant::Invalid, RInvalidSuffix));\n\n    // init resource lookup\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RAttrAppVersion));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrClass));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RAttrConfigId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrDdfHash));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrDdfPolicy));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RAttrExtAddress));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RAttrGroupAddress));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RAttrLastAnnounced));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RAttrLastSeen));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RAttrLevelMin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrManufacturerName));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RAttrMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrModelId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrName));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RAttrNwkAddress));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RCapOtauFileVersion));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapOtauImageType));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapOtauManufacturerCode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RAttrOtaVersion));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RAttrPowerOnCt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RAttrPowerOnLevel));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RAttrPowerup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrProductId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrProductName));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrSwconfigid));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrSwVersion));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrSwVersionBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrType));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RAttrUniqueId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RAttrZoneType));\n\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RActionScene));\n\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateAction));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateAirQuality));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateAirQualityBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateAirQualityPpb));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateAirQualityPpbBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateAlarm));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateAlert));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateAllOn));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateAngle));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateAnyOn));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::String, RStateArmState));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateBattery, 0, 100));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateBri));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt32, QVariant::Double, RStateButtonEvent));\n    rItemDescriptors.back().flags |= ResourceItem::FlagPushOnSet;\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateCarbonMonoxide));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateCharging));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateColorMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RStateConsumption));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RStateConsumption_2));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateCt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateCurrent));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateCurrent_P1));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateCurrent_P2));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateCurrent_P3));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateDark));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateDaylight));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateDeviceRunTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateEffect));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateErrorCode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateEventDuration));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateExpectedEventDuration));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateExpectedRotation));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateFilterRunTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateFire));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateFlag));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateFloorTemperature, -27315, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateGPDFrameCounter));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RStateGPDLastPair));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt32, QVariant::Double, RStateGesture));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateGradient));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateHeating));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateHue));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateHumidity, 0, 10000));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateHumidityBis, 0, 10000));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateLastCheckin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateLastSet));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateLastUpdated));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateLift));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateLightLevel, 0, 0xfffe));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateLocaltime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateLockState));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateLowBattery));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateLux));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeReal, QVariant::Double, RStateMeasuredValue));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateMoisture));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateMountingModeActive));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateMusicSync));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateOn));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateOpen));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateOpenBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateOrientationX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateOrientationY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateOrientationZ));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStatePM2_5));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStatePanel));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStatePower));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStatePresence));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStatePresenceEvent));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStatePressure, 0, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStatePressureBis, 0, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RStateProduction));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateReachable));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateReplaceFilter));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateRotaryEvent));\n    rItemDescriptors.back().flags |= ResourceItem::FlagPushOnSet;\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateSat));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RStateSecondsRemaining));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateSpectralX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateSpectralY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateSpectralZ));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateSpeed, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt32, QVariant::Double, RStateStatus));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateSunrise));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateSunset));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateTampered));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateTemperature, -27315, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RStateTemperatureBis, -27315, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateTest));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateTilt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateTiltAngle));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RStateUtc));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RStateValve));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateVibration));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateVibrationStrength));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateVoltage));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateWater));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RStateWaterBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RStateWindowOpen));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RStateY));\n\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapAlertTriggerEffect));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapBriMinDimLevel));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapBriMoveWithOnOff));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorCapabilities));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapColorCtComputesXy));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorCtMax));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorCtMin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt64, QVariant::Double, RCapColorEffects));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RCapColorGamutType));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RCapColorGradientMaxSegments));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RCapColorGradientPixelCount));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorGradientPixelLength));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorGradientStyles));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyBlueX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyBlueY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyGreenX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyGreenY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyRedX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RCapColorXyRedY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RCapGroup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapGroupsNotSupported));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeReal, QVariant::Double, RCapMeasuredValueMax));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeReal, QVariant::Double, RCapMeasuredValueMin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RCapMeasuredValueQuantity));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RCapMeasuredValueSubstance));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RCapMeasuredValueUnit));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapOnOffWithEffect));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapSleeper));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RCapTransitionBlock));\n\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigAlarmSystemId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigAlert));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool,  QVariant::Bool, RConfigAllowTouchlink));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigArmMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedAwayEntryDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedAwayExitDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedAwayTriggerDuration, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedNightEntryDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedNightExitDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedNightTriggerDuration, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedStayEntryDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedStayExitDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigArmedStayTriggerDuration, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBattery, 0, 100));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBatteryBis, 0, 100));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool,  QVariant::Bool, RConfigBriCoupleCt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool,  QVariant::Bool, RConfigBriExecuteIfOff));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBriMax));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBriMin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBriOnLevel));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigBriOnOffTransitiontime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBriOptions));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigBriStartup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RConfigCheckin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigClickMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigColorCapabilities));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigColorCtStartup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool,  QVariant::Bool, RConfigColorExecuteIfOff));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigColorGradientPixelCount, 5, 50));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool,  QVariant::Bool, RConfigColorGradientReversed));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigColorXyStartupX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigColorXyStartupY));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigConfigured));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigTuyaUnlock));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigControlSequence));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigCoolSetpoint, 700, 3500));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigCtMax));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigCtMin));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigDelay));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RConfigDetectionRange));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigDeviceMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigDeviceModeBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigDisarmedEntryDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigDisarmedExitDelay, 0, 255));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigDisplayFlipped));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigDuration));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RConfigEnrolled));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigExternalTemperatureSensor));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigExternalWindowOpen));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigFanMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RConfigFilterLifeTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigGPDDeviceId));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigGPDKey));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigGroup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigHeatSetpoint, 500, 3200));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigUnoccupiedHeatSetpoint, 500, 3200));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt32, QVariant::Double, RConfigHostFlags));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigHumiMaxThreshold));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigHumiMinThreshold));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigInterfaceMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigLastChangeAmount));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigLastChangeSource));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RConfigLastChangeTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigLat));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigLedIndication));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigLoadBalancing));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeTime, QVariant::String, RConfigLocalTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigLock));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigLocked));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigLong));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigMelody));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigMountingMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigOffset, INT16_MIN, INT16_MAX));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigOn));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigOnStartup));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigPending));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigPreset));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigPulseConfiguration));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigRadiatorCovered));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigReachable));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigReportGrid));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigResetPresence));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigReversed));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigSchedule));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigScheduleOn));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigSelfTest));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigSensitivity));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigSensitivityBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigSensitivityMax));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigSpeed));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigSetValve));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigSunriseOffset, -120, 120));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigSunsetOffset, -120, 120));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigSwingMode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigTempMaxThreshold));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt8, QVariant::Double, RConfigTempMinThreshold));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeInt16, QVariant::Double, RConfigTemperature, -27315, 32767));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigTemperatureMeasurement));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigTholdDark, 0, 0xfffe));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigTholdOffset, 1, 0xfffe));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigTriggerDistance));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigTriggerDistanceBis));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigUbisysJ1AdditionalSteps));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigUbisysJ1ConfigurationAndStatus));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1InactivePowerThreshold));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1InstalledClosedLimitLift));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1InstalledClosedLimitTilt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1InstalledOpenLimitLift));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1InstalledOpenLimitTilt));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1LiftToTiltTransitionSteps));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1LiftToTiltTransitionSteps2));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigUbisysJ1Mode));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1StartupSteps));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1TotalSteps));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt16, QVariant::Double, RConfigUbisysJ1TotalSteps2));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigUbisysJ1TurnaroundGuardTime));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigUbisysJ1WindowCoveringType));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeString, QVariant::String, RConfigUrl));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigUsertest));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigVolume));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeUInt8, QVariant::Double, RConfigWindowCoveringType));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigWindowOpen));\n    rItemDescriptors.emplace_back(ResourceItemDescriptor(DataTypeBool, QVariant::Bool, RConfigWindowOpenDetectionEnabled));\n}\n\nconst char *getResourcePrefix(const QString &str)\n{\n    Q_UNUSED(str);\n    return nullptr;\n}\n\nbool getResourceItemDescriptor(const QString &str, ResourceItemDescriptor &descr)\n{\n    auto i = rItemDescriptors.begin();\n    const auto end = rItemDescriptors.end();\n\n    for (; i != end; ++i)\n    {\n        if (str.endsWith(QLatin1String(i->suffix)))\n        {\n            descr = *i;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool R_AddResourceItemDescriptor(const ResourceItemDescriptor &rid)\n{\n    if (rid.isValid())\n    {\n        QLatin1String str1(rid.suffix);\n\n        auto i = rItemDescriptors.begin();\n        const auto end = rItemDescriptors.end();\n\n        for (; i != end; ++i)\n        {\n            QLatin1String str2(i->suffix);\n\n            if (str1 == str2)\n            {\n                return false; //already known\n            }\n        }\n\n        rItemDescriptors.push_back(rid);\n        return true;\n    }\n\n    return false;\n}\n\n/*! Clears \\p flags in \\p item which must be a numeric value item.\n    The macro is used to print the flag defines as human readable.\n */\nbool R_ClearFlags1(ResourceItem *item, qint64 flags, const char *strFlags)\n{\n    DBG_Assert(item);\n\n    if (item)\n    {\n        const auto old = item->toNumber();\n        if ((old & flags) != 0)\n        {\n            DBG_Printf(DBG_INFO_L2, \"[INFO_L2] - Clear %s flags %s (0x%016llX) in 0x%016llX  --> 0x%016llX\\n\",\n                       item->descriptor().suffix, strFlags, flags, item->toNumber(), old & ~flags);\n            item->setValue(item->toNumber() & ~flags);\n            return true;\n        }\n    }\n    return false;\n}\n\n/*! Sets \\p flags in \\p item which must be a numeric value item.\n    The macro is used to print the flag defines as human readable.\n */\nbool R_SetFlags1(ResourceItem *item, qint64 flags, const char *strFlags)\n{\n    DBG_Assert(item);\n\n    if (item)\n    {\n        const auto old = item->toNumber();\n        if ((old & flags) != flags)\n        {\n            DBG_Printf(DBG_INFO_L2, \"[INFO_L2] - Set %s flags %s (0x%016llX) in 0x%016llX --> 0x%016llX\\n\",\n                       item->descriptor().suffix, strFlags, flags, item->toNumber(), old | flags);\n            item->setValue(item->toNumber() | flags);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool R_HasFlags(const ResourceItem *item, qint64 flags)\n{\n    DBG_Assert(item);\n\n    if (item)\n    {\n        return (item->toNumber() & flags) == flags;\n    }\n\n    return false;\n}\n\n/*! Copy constructor. */\nResourceItem::ResourceItem(const ResourceItem &other)\n{\n    *this = other;\n}\n\nbool ResourceItem::setItemString(const QString &str)\n{\n    const ResourceItemDescriptor *rid = &descriptor();\n    if (!(rid->type == DataTypeString ||\n          rid->type == DataTypeTimePattern))\n    {\n        return false;\n    }\n\n    const auto utf8 = str.toUtf8();\n\n    // for now keep all attr/* items also as atoms\n    if (utf8.size() <= int(m_istr.maxSize()) && rid->suffix[0] != 'a' && rid->suffix[1] != 't')\n    {\n        m_istr.setString(utf8.constData());\n        m_strHandle = STRING_CACHE_INVALID_HANDLE;\n        return true;\n    }\n\n    m_strHandle = StringCacheAdd(utf8.constData(), (unsigned)utf8.size(), StringCacheImmutable);\n    return m_strHandle != STRING_CACHE_INVALID_HANDLE;\n}\n\n/*! Move constructor. */\nResourceItem::ResourceItem(ResourceItem &&other) noexcept\n{\n    *this = std::move(other);\n}\n\n/*! Destructor. */\nResourceItem::~ResourceItem() noexcept\n{\n    if (m_str)\n    {\n        delete m_str;\n        m_str = nullptr;\n    }\n\n    m_ridIndex = 0;\n}\n\n/*! Returns true when a value has been set but not pushed upstream. */\nbool ResourceItem::needPushSet() const\n{\n    return (m_flags & FlagNeedPushSet) > 0;\n}\n\n/*! Returns true when a value has been set and is different from previous\n    but not pushed upstream.\n */\nbool ResourceItem::needPushChange() const\n{\n    return (m_flags & FlagNeedPushChange) > 0;\n}\n\n/*! Clears set and changed push flags, called after value has been pushed to upstream. */\nvoid ResourceItem::clearNeedPush()\n{\n    m_flags &= ~static_cast<quint16>(FlagNeedPushSet | FlagNeedPushChange);\n}\n\n/*! Returns true when a value needs to be stored to database.\n */\nbool ResourceItem::needStore() const\n{\n    return (m_flags & FlagNeedStore) > 0;\n}\n\n/*! Sets need store flag. */\nvoid ResourceItem::setNeedStore()\n{\n    m_flags |= static_cast<quint16>(FlagNeedStore);\n}\n\n/*! Clears need store flag. */\nvoid ResourceItem::clearNeedStore()\n{\n    m_flags &= ~static_cast<quint16>(FlagNeedStore);\n}\n\nbool ResourceItem::pushOnSet() const\n{\n    return (m_flags & FlagPushOnSet) > 0;\n}\n\nvoid ResourceItem::setPushOnSet(bool enable)\n{\n    if (enable)\n    {\n        m_flags |= static_cast<quint16>(FlagPushOnSet);\n    }\n    else\n    {\n        m_flags &= ~static_cast<quint16>(FlagPushOnSet);\n    }\n}\n\nbool ResourceItem::pushOnChange() const\n{\n    return (m_flags & FlagPushOnChange) > 0;\n}\n\nvoid ResourceItem::setPushOnChange(bool enable)\n{\n    if (enable)\n    {\n        m_flags |= static_cast<quint16>(FlagPushOnChange);\n    }\n    else\n    {\n        m_flags &= ~static_cast<quint16>(FlagPushOnChange);\n    }\n}\n\nbool ResourceItem::awake() const\n{\n    return (m_flags & FlagAwakeOnSet) > 0;\n}\n\nvoid ResourceItem::setAwake(bool awake)\n{\n    if (awake)\n    {\n        m_flags |= static_cast<quint16>(FlagAwakeOnSet);\n    }\n    else\n    {\n        m_flags &= ~static_cast<quint16>(FlagAwakeOnSet);\n    }\n}\n\nbool ResourceItem::implicit() const\n{\n    return (m_flags & FlagImplicit) > 0;\n}\n\nvoid ResourceItem::setImplicit(bool implicit)\n{\n    if (implicit)\n    {\n        m_flags |= static_cast<quint16>(FlagImplicit);\n    }\n    else\n    {\n        m_flags &= ~static_cast<quint16>(FlagImplicit);\n    }\n}\n\nvoid ResourceItem::setZclUnsupportedAttribute()\n{\n    m_flags |= static_cast<uint16_t>(FlagZclUnsupportedAttr);\n}\n\nbool ResourceItem::zclUnsupportedAttribute() const\n{\n    return (m_flags & FlagZclUnsupportedAttr) > 0;\n}\n\n/*! Copy assignment. */\nResourceItem &ResourceItem::operator=(const ResourceItem &other)\n{\n    // self assignment?\n    if (this == &other)\n    {\n        return *this;\n    }\n\n    m_valueSource = other.m_valueSource;\n    m_isPublic = other.m_isPublic;\n    m_flags = other.m_flags;\n    m_parseFunction = other.m_parseFunction;\n    m_refreshInterval = other.m_refreshInterval;\n    m_zclParam = other.m_zclParam;\n    m_readEndpoint = other.m_readEndpoint;\n    m_num = other.m_num;\n    m_numPrev = other.m_numPrev;\n    m_lastZclReport = other.m_lastZclReport;\n    m_ridIndex = other.m_ridIndex;\n    m_lastSet = other.m_lastSet;\n    m_lastChanged = other.m_lastChanged;\n    m_rulesInvolved = other.m_rulesInvolved;\n    m_ddfItemHandle = other.m_ddfItemHandle;\n    m_istr = other.m_istr;\n    m_strHandle = other.m_strHandle;\n\n    if (other.m_str)\n    {\n        if (m_str)\n        {\n            *m_str = *other.m_str;\n        }\n        else\n        {\n            m_str = new QString(*other.m_str);\n        }\n    }\n    else if (m_str)\n    {\n        delete m_str;\n        m_str = nullptr;\n    }\n\n    return *this;\n}\n\n/*! Move assignment. */\nResourceItem &ResourceItem::operator=(ResourceItem &&other) noexcept\n{\n    // self assignment?\n    if (this == &other)\n    {\n        return *this;\n    }\n\n    m_valueSource = other.m_valueSource;\n    m_isPublic = other.m_isPublic;\n    m_flags = other.m_flags;\n    m_num = other.m_num;\n    m_numPrev = other.m_numPrev;\n    m_lastZclReport = other.m_lastZclReport;\n    m_ridIndex = other.m_ridIndex;\n    m_lastSet = std::move(other.m_lastSet);\n    m_lastChanged = std::move(other.m_lastChanged);\n    m_rulesInvolved = std::move(other.m_rulesInvolved);\n    m_zclParam = other.m_zclParam;\n    m_readEndpoint = other.m_readEndpoint;\n    m_parseFunction = other.m_parseFunction;\n    m_refreshInterval = other.m_refreshInterval;\n    m_ddfItemHandle = other.m_ddfItemHandle;\n    m_istr = other.m_istr;\n    m_strHandle = other.m_strHandle;\n    other.m_ridIndex = 0;\n\n    if (m_str)\n    {\n        delete m_str;\n        m_str = nullptr;\n    }\n\n    if (other.m_str)\n    {\n        m_str = other.m_str;\n        other.m_str = nullptr;\n    }\n\n    return *this;\n}\n\n/*! Initial main constructor to create a valid ResourceItem. */\nResourceItem::ResourceItem(const ResourceItemDescriptor &rid)\n{\n    m_ridIndex = 0;\n\n    for (size_t i = 0; i < rItemDescriptors.size(); i++)\n    {\n        if (rItemDescriptors[i].suffix == rid.suffix)\n        {\n            m_ridIndex = static_cast<uint16_t>(i);\n            break;\n        }\n    }\n\n    if (rid.type == DataTypeString ||\n        rid.type == DataTypeTime ||\n        rid.type == DataTypeTimePattern)\n    {\n        m_str = new QString;\n    }\n\n    m_flags = rid.flags;\n    m_flags |= FlagPushOnChange;\n}\n\nconst QString &ResourceItem::toString() const\n{\n    rStats.toString++;\n\n    const ResourceItemDescriptor *rid = &descriptor();\n\n    if (rid->type == DataTypeString ||\n        rid->type == DataTypeTimePattern)\n    {\n        if (m_str)\n        {\n            return *m_str;\n        }\n    }\n    else if (rid->type == DataTypeTime)\n    {\n        U_ASSERT(m_str);\n        if (m_num > 0 && m_str)\n        {\n            QDateTime dt;\n\n            // default: local time in sec resolution\n            QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ss\");\n\n            if (rid->suffix == RStateLastUpdated || rid->suffix == RStateLastCheckin)\n            {\n                // UTC in msec resolution\n                format = QLatin1String(\"yyyy-MM-ddTHH:mm:ss.zzz\"); // TODO add Z\n                dt.setOffsetFromUtc(0);\n            }\n            else if (rid->suffix == RAttrLastAnnounced || rid->suffix == RStateLastSet || rid->suffix == RStateUtc || rid->suffix == RConfigLastChangeTime)\n            {\n                // UTC in sec resolution\n                format = QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\");\n                dt.setOffsetFromUtc(0);\n            }\n            else if (rid->suffix == RAttrLastSeen)\n            {\n                // UTC in min resolution\n                format = QLatin1String(\"yyyy-MM-ddTHH:mmZ\");\n                dt.setOffsetFromUtc(0);\n            }\n            else if (rid->suffix == RStateSunrise || rid->suffix == RStateSunset)\n            {\n                // UTC in sec resulution\n                format = QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"); // TODO add Z\n                dt.setOffsetFromUtc(0);\n            }\n\n            dt.setMSecsSinceEpoch(m_num);\n            *m_str = dt.toString(format);\n            return *m_str;\n        }\n    }\n\n    return rInvalidString;\n}\n\nQLatin1String ResourceItem::toLatin1String() const\n{\n    if (m_strHandle == STRING_CACHE_INVALID_HANDLE)\n    {\n        return m_istr;\n    }\n    else\n    {\n        const char *str;\n        unsigned length;\n\n        if (StringCacheGet(m_strHandle, &str, &length))\n        {\n            return QLatin1String(str, length);\n        }\n    }\n\n    return QLatin1String(\"\");\n}\n\nconst char *ResourceItem::toCString() const\n{\n    if (m_strHandle != STRING_CACHE_INVALID_HANDLE)\n    {\n        const char *str;\n        unsigned length;\n\n        if (StringCacheGet(m_strHandle, &str, &length))\n        {\n            U_ASSERT(str[length] == '\\0');\n            return str;\n        }\n    }\n\n    return m_istr.c_str();\n}\n\nqint64 ResourceItem::toNumber() const\n{\n    rStats.toNumber++;\n    return m_num;\n}\n\nqint64 ResourceItem::toNumberPrevious() const\n{\n    return m_numPrev;\n}\n\nbool ResourceItem::toBool() const\n{\n    return m_num != 0;\n}\n\n/*! Sets the item string to \\p str.\n\n    \\param str - utf8 string, \\0 terminated\n    \\param length - the length of str excluding \\0 (aka strlen(str))\n                    can be -1 to let the length be determined automatically\n */\nbool ResourceItem::setValue(const char *str, int length, ValueSource source)\n{\n    U_ASSERT(str);\n    U_ASSERT(length >= -1);\n\n    if (length == -1) // strlen\n    {\n        for (length = 0; str[length]; length++)\n        {}\n    }\n\n    const QVariant val(QLatin1String(str, length));\n    return setValue(val, source);\n}\n\nbool ResourceItem::setValue(const QString &val, ValueSource source)\n{\n    return setValue(QVariant(val), source);\n}\n\nbool ResourceItem::setValue(qint64 val, ValueSource source)\n{\n    const ResourceItemDescriptor *rid = &descriptor();\n\n    if (rid->validMin != 0 || rid->validMax != 0)\n    {\n        // range check\n        if (val < rid->validMin || val > rid->validMax)\n        {\n            return false;\n        }\n    }\n\n    m_lastSet = QDateTime::currentDateTime();\n    m_numPrev = m_num;\n    m_valueSource = source;\n    m_flags |= FlagNeedPushSet;\n    m_flags |= FlagNeedStore;\n\n    if (m_num != val)\n    {\n        m_num = val;\n        m_lastChanged = m_lastSet;\n        m_flags |= FlagNeedPushChange;\n    }\n\n    return true;\n}\n\nbool ResourceItem::setValue(const QVariant &val, ValueSource source)\n{\n    if (!val.isValid())\n    {\n        m_lastSet = QDateTime();\n        m_lastChanged = m_lastSet;\n        m_valueSource = SourceUnknown;\n        return true;\n    }\n\n    const auto now = QDateTime::currentDateTime();\n    m_valueSource = source;\n\n    const ResourceItemDescriptor *rid = &descriptor();\n\n    if (rid->type == DataTypeString ||\n        rid->type == DataTypeTimePattern)\n    {\n        // TODO validate time pattern\n        if (m_str)\n        {\n            m_lastSet = now;\n            m_flags |= FlagNeedPushSet;\n            const auto str = val.toString().trimmed();\n            setItemString(str);\n            if (*m_str != str)\n            {\n                *m_str = str;\n                m_lastChanged = m_lastSet;\n                m_flags |= FlagNeedPushChange;\n                m_flags |= FlagNeedStore;\n            }\n            return true;\n        }\n    }\n    else if (rid->type == DataTypeBool)\n    {\n        m_lastSet = now;\n        m_numPrev = m_num;\n        m_flags |= FlagNeedPushSet;\n        m_flags |= FlagNeedStore;\n\n        if (m_num != val.toBool())\n        {\n            m_num = val.toBool();\n            m_lastChanged = m_lastSet;\n            m_flags |= FlagNeedPushChange;\n        }\n        return true;\n    }\n    else if (rid->type == DataTypeTime)\n    {\n        if (val.type() == QVariant::String)\n        {\n            const auto str = val.toString();\n            auto fmt = str.contains('.') ? QLatin1String(\"yyyy-MM-ddTHH:mm:ss.zzz\")\n                                         : QLatin1String(\"yyyy-MM-ddTHH:mm:ss\");\n            auto dt = QDateTime::fromString(str, fmt);\n            dt.setTimeSpec(Qt::UTC);\n\n            if (dt.isValid())\n            {\n                m_lastSet = now;\n                m_numPrev = m_num;\n                m_flags |= FlagNeedPushSet;\n\n                if (m_num != dt.toMSecsSinceEpoch())\n                {\n                    m_num = dt.toMSecsSinceEpoch();\n                    m_lastChanged = m_lastSet;\n                    m_flags |= FlagNeedPushChange;\n                    m_flags |= FlagNeedStore;\n                }\n                return true;\n            }\n        }\n        else if (val.type() == QVariant::DateTime)\n        {\n            m_lastSet = now;\n            m_numPrev = m_num;\n            m_flags |= FlagNeedPushSet;\n\n            if (m_num != val.toDateTime().toMSecsSinceEpoch())\n            {\n                m_num = val.toDateTime().toMSecsSinceEpoch();\n                m_lastChanged = m_lastSet;\n                m_flags |= FlagNeedPushChange;\n                m_flags |= FlagNeedStore;\n            }\n            return true;\n        }\n    }\n    else if (rid->type == DataTypeReal)\n    {\n        bool ok = false;\n        double d = val.toDouble(&ok);\n\n        if (ok)\n        {\n            m_lastSet = now;\n            m_doublePrev = m_double;\n            m_flags |= FlagNeedPushSet;\n\n            if (m_double != d)\n            {\n                m_double = d;\n                m_lastChanged = m_lastSet;\n                m_flags |= FlagNeedPushChange;\n                m_flags |= FlagNeedStore;\n            }\n            return true;\n        }\n    }\n    else\n    {\n        bool ok = false;\n        const int n = val.toInt(&ok);\n\n        if (ok)\n        {\n            if (rid->validMin == 0 && rid->validMax == 0)\n            { /* no range check */ }\n            else if (n >= rid->validMin && n <= rid->validMax)\n            {   /* range check: ok*/ }\n            else {\n                m_valueSource = SourceUnknown;\n                return false;\n            }\n\n            m_lastSet = now;\n            m_numPrev = m_num;\n            m_flags |= FlagNeedPushSet;\n            m_flags |= FlagNeedStore;\n\n            if (m_num != n)\n            {\n                m_num = n;\n                m_lastChanged = m_lastSet;\n                m_flags |= FlagNeedPushChange;\n            }\n            return true;\n        }\n    }\n\n    m_valueSource = SourceUnknown;\n    return false;\n}\n\n/*! Returns true if the items string exactls equals \\p str.\n\n    This helps to get rid of some Qt specific checks.\n    So instead of\n\n         if (item->toString() == QLatin1String(\"some string\")) {}\n\n    write\n\n         if (item->equalsString(\"some string\")) {}\n\n    \\param str - utf8 string\n    \\param length - optional length of str aka strlen(str)\n                    the default value of -1 means the length is determined automatically\n */\nbool ResourceItem::equalsString(const char *str, int length) const\n{\n    U_ASSERT(str);\n    U_ASSERT(length >= -1);\n    if (!str)\n    {\n        return false;\n    }\n\n    if (length == -1) // strlen\n    {\n        for (length = 0; str[length]; length++)\n        {}\n    }\n\n    if (m_strHandle != STRING_CACHE_INVALID_HANDLE && length > 0)\n    {\n        const char *istr;\n        unsigned ilen;\n        if (StringCacheGet(m_strHandle, &istr, &ilen))\n        {\n            if (ilen != length)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < length; i++)\n            {\n                if (str[i] != istr[i])\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    if (m_istr.size() == (size_t)length)\n    {\n        return m_istr == str;\n    }\n\n    return false;\n}\n\nconst ResourceItemDescriptor &ResourceItem::descriptor() const\n{\n    U_ASSERT(m_ridIndex < rItemDescriptors.size());\n    if (rItemDescriptors.size() <= m_ridIndex)\n    {\n        // invalid descriptor, note if this triggers there is likely a bug lurking somewhere\n        return rItemDescriptors[0];\n    }\n    return rItemDescriptors[m_ridIndex];\n}\n\nconst QDateTime &ResourceItem::lastSet() const\n{\n    return m_lastSet;\n}\n\nconst QDateTime &ResourceItem::lastChanged() const\n{\n    return m_lastChanged;\n}\n\nvoid ResourceItem::setTimeStamps(const QDateTime &t)\n{\n    m_lastSet = t;\n    m_lastChanged = t;\n}\n\nQVariant ResourceItem::toVariant() const\n{\n    if (!m_lastSet.isValid())\n    {\n        return QVariant();\n    }\n\n    const ResourceItemDescriptor *rid = &descriptor();\n\n    if (rid->type == DataTypeString ||\n        rid->type == DataTypeTimePattern)\n    {\n        if (m_str)\n        {\n            return *m_str;\n        }\n        return QString();\n    }\n    else if (rid->type == DataTypeBool)\n    {\n        return (bool)m_num;\n    }\n    else if (rid->type == DataTypeTime)\n    {\n        return toString();\n    }\n    else if (rid->type == DataTypeReal)\n    {\n        return (double)m_double;\n    }\n    else\n    {\n       return (double)m_num;\n    }\n\n    return QVariant();\n}\n\n/*! Marks the resource item as involved in a rule. */\nvoid ResourceItem::inRule(int ruleHandle)\n{\n    for (int handle : m_rulesInvolved)\n    {\n        if (handle == ruleHandle)\n        {\n            return;\n        }\n    }\n\n    m_rulesInvolved.push_back(ruleHandle);\n}\n\n/*! Returns the rules handles in which the resource item is involved. */\nconst std::vector<int> &ResourceItem::rulesInvolved() const\n{\n    return m_rulesInvolved;\n}\n\n/*! Returns true if the item should be available in the public api. */\nbool ResourceItem::isPublic() const\n{\n    return m_isPublic;\n}\n\n/*! Sets an item should be available in the public api. */\nvoid ResourceItem::setIsPublic(bool isPublic)\n{\n    m_isPublic = isPublic;\n}\n\n/*! Initial main constructor. */\nResource::Resource(const char *prefix) :\n    m_prefix(prefix)\n{\n    Q_ASSERT(prefix == RSensors || prefix == RLights || prefix == RDevices || prefix == RGroups || prefix == RConfig || prefix == RAlarmSystems);\n}\n\n/*! Copy constructor. */\nResource::Resource(const Resource &other) :\n    m_handle(other.m_handle),\n    m_prefix(other.m_prefix),\n    m_parent(other.m_parent),\n    m_rItems(other.m_rItems)\n{\n}\n\n/*! Move constructor. */\nResource::Resource(Resource &&other) noexcept\n{\n    *this = std::move(other);\n}\n\n/*! Copy assignment. */\nResource &Resource::operator=(const Resource &other)\n{\n    if (this != &other)\n    {\n        m_handle = other.m_handle;\n        m_prefix = other.m_prefix;\n        m_parent = other.m_parent;\n        m_rItems = other.m_rItems;\n    }\n    return *this;\n}\n\n/*! Move assignment. */\nResource &Resource::operator=(Resource &&other) noexcept\n{\n    if (this != &other)\n    {\n        m_handle = other.m_handle;\n        m_prefix = other.m_prefix;\n        m_parent = other.m_parent;\n        m_rItems = std::move(other.m_rItems);\n    }\n    return *this;\n}\n\nconst char *Resource::prefix() const\n{\n    Q_ASSERT(m_prefix);\n    return m_prefix;\n}\n\nResourceItem *Resource::addItem(ApiDataType type, const char *suffix)\n{\n    ResourceItem *it = item(suffix);\n    if (!it) // prevent double insertion\n    {\n        std::vector<ResourceItemDescriptor>::const_iterator i = rItemDescriptors.begin();\n        std::vector<ResourceItemDescriptor>::const_iterator end = rItemDescriptors.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->suffix == suffix && i->type == type)\n            {\n                m_rItems.emplace_back(*i);\n                return &m_rItems.back();\n            }\n        }\n\n        DBG_Assert(0);\n        DBG_Printf(DBG_ERROR, \"unknown datatype:suffix +  %d: %s\\n\", type, suffix);\n    }\n\n    return it;\n}\n\nvoid Resource::removeItem(const char *suffix)\n{\n    auto i = m_rItems.begin();\n    const auto end = m_rItems.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->descriptor().suffix != suffix)\n        {\n            continue;\n        }\n\n        *i = std::move(m_rItems.back());\n        m_rItems.pop_back();\n        break;\n    }\n}\n\nResourceItem *Resource::item(const char *suffix)\n{\n    rStats.item++;\n\n    for (size_t i = 0; i < m_rItems.size(); i++)\n    {\n        if (m_rItems[i].descriptor().suffix == suffix)\n        {\n            return &m_rItems[i];\n        }\n    }\n\n    return nullptr;\n}\n\nconst ResourceItem *Resource::item(const char *suffix) const\n{\n    rStats.item++;\n\n    for (size_t i = 0; i < m_rItems.size(); i++)\n    {\n        if (m_rItems[i].descriptor().suffix == suffix)\n        {\n            return &m_rItems[i];\n        }\n    }\n\n    return nullptr;\n}\n\nbool Resource::toBool(const char *suffix) const\n{\n    const ResourceItem *i = item(suffix);\n    if (i)\n    {\n        return i->toBool();\n    }\n    return false;\n}\n\nqint64 Resource::toNumber(const char *suffix) const\n{\n    const ResourceItem *i = item(suffix);\n    if (i)\n    {\n        return i->toNumber();\n    }\n    return 0;\n}\n\nconst QString &Resource::toString(const char *suffix) const\n{\n    const ResourceItem *i = item(suffix);\n    if (i)\n    {\n        return i->toString();\n    }\n    return rInvalidString;\n}\n\nQVariant Resource::toVariant(const char *suffix) const\n{\n    const ResourceItem *i = item(suffix);\n    if (i)\n    {\n        return i->toVariant();\n    }\n    return QVariant();\n}\n\n/*! Set ResourceItem value.\n * \\param suffix ResourceItem suffix\n * \\param val ResourceIetm value\n */\nbool Resource::setValue(const char *suffix, qint64 val, bool forceUpdate)\n{\n    ResourceItem *i = item(suffix);\n    if (!i)\n    {\n        return false;\n    }\n    if (forceUpdate || i->toNumber() != val)\n    {\n        if (!(i->setValue(val))) // TODO DDF ValueSource\n        {\n            return false;\n        }\n        didSetValue(i);\n        return true;\n    }\n    return false;\n}\n\n/*! Set ResourceItem value.\n * \\param suffix ResourceItem suffix\n * \\param val ResourceIetm value\n */\nbool Resource::setValue(const char *suffix, const QString &val, bool forceUpdate)\n{\n    ResourceItem *i = item(suffix);\n    if (!i)\n    {\n        return false;\n    }\n    if (forceUpdate || i->toString() != val)\n    {\n        if (!(i->setValue(val)))\n        {\n            return false;\n        }\n        didSetValue(i);\n        return true;\n    }\n    return false;\n}\n\n/*! Set ResourceItem value.\n * \\param suffix ResourceItem suffix\n * \\param val ResourceIetm value\n */\nbool Resource::setValue(const char *suffix, const QVariant &val, bool forceUpdate)\n{\n    ResourceItem *i = item(suffix);\n    if (!i)\n    {\n        return false;\n    }\n    if (forceUpdate || i->toVariant() != val)\n    {\n        if (!(i->setValue(val)))\n        {\n            return false;\n        }\n        didSetValue(i);\n        return true;\n    }\n    return false;\n}\n\nint Resource::itemCount() const\n{\n    return m_rItems.size();\n}\n\nResourceItem *Resource::itemForIndex(size_t idx)\n{\n    if (idx < m_rItems.size())\n    {\n        return &m_rItems[idx];\n    }\n    return nullptr;\n}\n\nconst ResourceItem *Resource::itemForIndex(size_t idx) const\n{\n    if (idx < m_rItems.size())\n    {\n        return &m_rItems[idx];\n    }\n    return nullptr;\n}\n\n/*! Adds \\p stateChange to a Resource.\n\n    If an equal StateChange already exists it will be replaced.\n    TODO move out of Resource, it shouldn't depend on it.\n */\nvoid Resource::addStateChange(const StateChange &stateChange)\n{\n    auto i = std::find(m_stateChanges.begin(), m_stateChanges.end(), stateChange);\n\n    if (i != m_stateChanges.end())\n    {\n        *i = stateChange;\n    }\n    else\n    {\n        m_stateChanges.push_back(stateChange);\n    }\n}\n\n/*! Removes all StateChange items having state StateFailed or StateFinished.\n\n    TODO move out of Resource, it shouldn't depend on it.\n */\nvoid Resource::cleanupStateChanges()\n{\n    while (!m_stateChanges.empty())\n    {\n        const auto i = std::find_if(m_stateChanges.begin(), m_stateChanges.end(), [](const StateChange &x)\n        {\n            return x.state() == StateChange::StateFailed || x.state() == StateChange::StateFinished;\n        });\n\n        if (i != m_stateChanges.end())\n        {\n            if (i->state() == StateChange::StateFinished)\n            {\n                DBG_Printf(DBG_INFO, \"SC state change finished: %s\\n\", qPrintable(item(RAttrUniqueId)->toString()));\n            }\n            else if (i->state() == StateChange::StateFailed)\n            {\n                DBG_Printf(DBG_INFO, \"SC state change failed: %s\\n\", qPrintable(item(RAttrUniqueId)->toString()));\n            }\n\n            m_stateChanges.erase(i);\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n\n/*! Returns the string presentation of an data type */\nQLatin1String R_DataTypeToString(ApiDataType type)\n{\n    switch (type)\n    {\n    case DataTypeUnknown: { return QLatin1String(\"unknown\"); }\n    case DataTypeBool: { return QLatin1String(\"bool\"); }\n    case DataTypeUInt8: { return QLatin1String(\"uint8\"); }\n    case DataTypeUInt16: { return QLatin1String(\"uint16\"); }\n    case DataTypeUInt32: { return QLatin1String(\"uint32\"); }\n    case DataTypeUInt64: { return QLatin1String(\"uint64\"); }\n    case DataTypeInt8: { return QLatin1String(\"int8\"); }\n    case DataTypeInt16: { return QLatin1String(\"int16\"); }\n    case DataTypeInt32: { return QLatin1String(\"int32\"); }\n    case DataTypeInt64: { return QLatin1String(\"int64\"); }\n    case DataTypeReal: { return QLatin1String(\"double\"); }\n    case DataTypeString: { return QLatin1String(\"string\"); }\n    case DataTypeTime: { return QLatin1String(\"ISO 8601 timestamp\"); }\n    case DataTypeTimePattern: { return QLatin1String(\"time pattern\"); }\n    }\n\n    return QLatin1String(\"unknown\");\n}\n\n/*! Returns true if \\p str contains a valid list of group identifiers.\n\n    Valid values are:\n      \"\"          empty\n      \"45\"        single group\n      \"343,123\"   two groups\n      \"1,null,null,null\"  4 groups but only first set\n */\nbool isValidRConfigGroup(const QString &str)\n{\n    int result = 0;\n    const QStringList groupList = str.split(',', SKIP_EMPTY_PARTS);\n\n    for (const auto &groupId : groupList)\n    {\n        bool ok = false;\n        auto gid = groupId.toUInt(&ok, 0);\n        if (ok && gid <= UINT16_MAX) { result++; }\n        else if (!ok && groupId == QLatin1String(\"null\")) { result++; }\n    }\n\n    return result == groupList.size();\n}\n"
        },
        {
          "name": "resource.h",
          "type": "blob",
          "size": 24.8359375,
          "content": "#ifndef RESOURCE_H\n#define RESOURCE_H\n\n#include <QDateTime>\n#include <QElapsedTimer>\n#include <QVariant>\n#include <vector>\n#include <deconz.h>\n#include \"utils/bufstring.h\"\n#include \"state_change.h\"\n#include \"zcl/zcl.h\"\n\nclass QString;\nclass QVariant;\n\nenum ApiDataType\n{\n    DataTypeUnknown,\n    DataTypeBool,\n    DataTypeUInt8,\n    DataTypeUInt16,\n    DataTypeUInt32,\n    DataTypeUInt64,\n    DataTypeInt8,\n    DataTypeInt16,\n    DataTypeInt32,\n    DataTypeInt64,\n    DataTypeReal,\n    DataTypeString,\n    DataTypeTime,\n    DataTypeTimePattern\n};\n\nstruct R_Stats\n{\n    size_t toString = 0;\n    size_t toNumber = 0;\n    size_t item = 0;\n};\n\nextern R_Stats rStats;\n\n// resource prefixes: /devices, /lights, /sensors, ...\nextern const char *RAlarmSystems;\nextern const char *RConfig;\nextern const char *RDevices;\nextern const char *RGroups;\nextern const char *RLights;\nextern const char *RSensors;\n\n// resource events\nextern const char *REventAdded;\nextern const char *REventApsConfirm;\nextern const char *REventAwake;\nextern const char *REventBindingTable;\nextern const char *REventBindingTick;\nextern const char *REventDeleted;\nextern const char *REventDeviceAlarm;\nextern const char *REventDeviceAnnounce;\nextern const char *REventPermitjoinEnabled;\nextern const char *REventPermitjoinDisabled;\nextern const char *REventPermitjoinRunning;\nextern const char *REventPoll;\nextern const char *REventDDFReload;\nextern const char *REventDDFInitRequest;\nextern const char *REventDDFInitResponse;\nextern const char *REventValidGroup;\nextern const char *REventCheckGroupAnyOn;\nextern const char *REventNodeDescriptor;\nextern const char *REventActiveEndpoints;\nextern const char *REventSimpleDescriptor;\nextern const char *REventStartTimer;\nextern const char *REventStopTimer;\nextern const char *REventStateEnter;\nextern const char *REventStateLeave;\nextern const char *REventStateTimeout;\nextern const char *REventTick;\nextern const char *REventTimerFired;\nextern const char *REventZclResponse;\nextern const char *REventZclReadReportConfigResponse;\nextern const char *REventZdpReload;\nextern const char *REventZdpMgmtBindResponse;\nextern const char *REventZdpResponse;\n\n// resouce suffixes: state/buttonevent, config/on, ...\nextern const char *RInvalidSuffix;\n\nextern const char *RAttrAppVersion;\nextern const char *RAttrClass;\nextern const char *RAttrConfigId;\nextern const char *RAttrDdfHash;\nextern const char *RAttrDdfPolicy;\nextern const char *RAttrExtAddress;\nextern const char *RAttrGroupAddress;\nextern const char *RAttrId;\nextern const char *RAttrLastAnnounced;\nextern const char *RAttrLastSeen;\nextern const char *RAttrLevelMin;\nextern const char *RAttrManufacturerName;\nextern const char *RAttrMode;\nextern const char *RAttrModelId;\nextern const char *RAttrName;\nextern const char *RAttrNwkAddress;\nextern const char *RCapOtauFileVersion;\nextern const char *RCapOtauImageType;\nextern const char *RCapOtauManufacturerCode;\nextern const char *RAttrOtaVersion;\nextern const char *RAttrPowerOnCt;\nextern const char *RAttrPowerOnLevel;\nextern const char *RAttrPowerup;\nextern const char *RAttrProductId;\nextern const char *RAttrProductName;\nextern const char *RAttrSwconfigid;\nextern const char *RAttrSwVersion;\nextern const char *RAttrSwVersionBis;\nextern const char *RAttrType;\nextern const char *RAttrUniqueId;\nextern const char *RAttrZoneType;\n\nextern const char *RActionScene;\n\nextern const char *RStateAction;\nextern const char *RStateAirQuality;\nextern const char *RStateAirQualityBis;\nextern const char *RStateAirQualityPpb; // Deprecated\nextern const char *RStateAirQualityPpbBis; // Deprecated\nextern const char *RStateAlarm;\nextern const char *RStateAlert;\nextern const char *RStateAllOn;\nextern const char *RStateAngle;\nextern const char *RStateAnyOn;\nextern const char *RStateArmState;\nextern const char *RStateBattery;\nextern const char *RStateBri;\nextern const char *RStateButtonEvent;\nextern const char *RStateCarbonMonoxide;\nextern const char *RStateCharging;\nextern const char *RStateColorMode;\nextern const char *RStateConsumption;\nextern const char *RStateConsumption_2;\nextern const char *RStateCt;\nextern const char *RStateCurrent;\nextern const char *RStateCurrent_P1;\nextern const char *RStateCurrent_P2;\nextern const char *RStateCurrent_P3;\nextern const char *RStateDark;\nextern const char *RStateDaylight;\nextern const char *RStateDeviceRunTime;\nextern const char *RStateEffect;\nextern const char *RStateErrorCode;\nextern const char *RStateEventDuration;\nextern const char *RStateExpectedEventDuration;\nextern const char *RStateExpectedRotation;\nextern const char *RStateFilterRunTime;\nextern const char *RStateFire;\nextern const char *RStateFlag;\nextern const char *RStateFloorTemperature;\nextern const char *RStateGPDFrameCounter;\nextern const char *RStateGPDLastPair;\nextern const char *RStateGesture;\nextern const char *RStateGradient;\nextern const char *RStateHeating;\nextern const char *RStateHue;\nextern const char *RStateHumidity;\nextern const char *RStateHumidityBis;\nextern const char *RStateLastCheckin; // Poll control check-in\nextern const char *RStateLastSet;\nextern const char *RStateLastUpdated;\nextern const char *RStateLift;\nextern const char *RStateLightLevel;\nextern const char *RStateLocaltime;\nextern const char *RStateLockState;\nextern const char *RStateLowBattery;\nextern const char *RStateLux;\nextern const char *RStateMeasuredValue;\nextern const char *RStateMoisture;\nextern const char *RStateMountingModeActive;\nextern const char *RStateMusicSync;\nextern const char *RStateOn;\nextern const char *RStateOpen;\nextern const char *RStateOpenBis;\nextern const char *RStateOrientationX;\nextern const char *RStateOrientationY;\nextern const char *RStateOrientationZ;\nextern const char *RStatePM2_5; // Deprecated\nextern const char *RStatePanel;\nextern const char *RStatePower;\nextern const char *RStatePresence;\nextern const char *RStatePresenceEvent;\nextern const char *RStatePressure;\nextern const char *RStatePressureBis;\nextern const char *RStateProduction;\nextern const char *RStateReachable;\nextern const char *RStateReplaceFilter;\nextern const char *RStateRotaryEvent;\nextern const char *RStateSat;\nextern const char *RStateSecondsRemaining;\nextern const char *RStateSpectralX;\nextern const char *RStateSpectralY;\nextern const char *RStateSpectralZ;\nextern const char *RStateSpeed;\nextern const char *RStateStatus;\nextern const char *RStateSunrise;\nextern const char *RStateSunset;\nextern const char *RStateTampered;\nextern const char *RStateTemperature;\nextern const char *RStateTemperatureBis;\nextern const char *RStateTest;\nextern const char *RStateTilt;\nextern const char *RStateTiltAngle;\nextern const char *RStateUtc;\nextern const char *RStateValve;\nextern const char *RStateVibration;\nextern const char *RStateVibrationStrength;\nextern const char *RStateVoltage;\nextern const char *RStateWater;\nextern const char *RStateWaterBis;\nextern const char *RStateWindowOpen;\nextern const char *RStateX;\nextern const char *RStateY;\n\nextern const char *RCapAlertTriggerEffect;\nextern const char *RCapBriMoveWithOnOff;\nextern const char *RCapBriMinDimLevel;\nextern const char *RCapColorCapabilities;\nextern const char *RCapColorCtComputesXy;\nextern const char *RCapColorCtMax;\nextern const char *RCapColorCtMin;\nextern const char *RCapColorEffects;\nextern const char *RCapColorGamutType;\nextern const char *RCapColorGradientMaxSegments;\nextern const char *RCapColorGradientPixelCount;\nextern const char *RCapColorGradientPixelLength;\nextern const char *RCapColorGradientStyles;\nextern const char *RCapColorXyBlueX;\nextern const char *RCapColorXyBlueY;\nextern const char *RCapColorXyGreenX;\nextern const char *RCapColorXyGreenY;\nextern const char *RCapColorXyRedX;\nextern const char *RCapColorXyRedY;\nextern const char *RCapGroup;\nextern const char *RCapGroupsNotSupported;\nextern const char *RCapMeasuredValueMax;\nextern const char *RCapMeasuredValueMin;\nextern const char *RCapMeasuredValueQuantity;\nextern const char *RCapMeasuredValueSubstance;\nextern const char *RCapMeasuredValueUnit;\nextern const char *RCapOnOffWithEffect;\nextern const char *RCapSleeper;\nextern const char *RCapTransitionBlock;\n\nextern const char *RConfigAlarmSystemId;\nextern const char *RConfigAlert;\nextern const char *RConfigAllowTouchlink;\nextern const char *RConfigArmMode;\nextern const char *RConfigArmedAwayEntryDelay;\nextern const char *RConfigArmedAwayExitDelay;\nextern const char *RConfigArmedAwayTriggerDuration;\nextern const char *RConfigArmedNightEntryDelay;\nextern const char *RConfigArmedNightExitDelay;\nextern const char *RConfigArmedNightTriggerDuration;\nextern const char *RConfigArmedStayEntryDelay;\nextern const char *RConfigArmedStayExitDelay;\nextern const char *RConfigArmedStayTriggerDuration;\nextern const char *RConfigBattery;\nextern const char *RConfigBatteryBis;\nextern const char *RConfigBriCoupleCt;\nextern const char *RConfigBriExecuteIfOff;\nextern const char *RConfigBriMax;\nextern const char *RConfigBriMin;\nextern const char *RConfigBriOnLevel;\nextern const char *RConfigBriOnOffTransitiontime;\nextern const char *RConfigBriOptions;\nextern const char *RConfigBriStartup;\nextern const char *RConfigCheckin;\nextern const char *RConfigClickMode;\nextern const char *RConfigColorCapabilities; // Deprecated\nextern const char *RConfigColorCtStartup;\nextern const char *RConfigColorExecuteIfOff;\nextern const char *RConfigColorGradientPixelCount;\nextern const char *RConfigColorGradientReversed;\nextern const char *RConfigColorXyStartupX;\nextern const char *RConfigColorXyStartupY;\nextern const char *RConfigConfigured;\nextern const char *RConfigTuyaUnlock;\nextern const char *RConfigControlSequence;\nextern const char *RConfigCoolSetpoint;\nextern const char *RConfigCtMax; // Deprecated\nextern const char *RConfigCtMin; // Deprecated\nextern const char *RConfigDelay;\nextern const char *RConfigDetectionRange;\nextern const char *RConfigDeviceMode;\nextern const char *RConfigDeviceModeBis;\nextern const char *RConfigDisarmedEntryDelay;\nextern const char *RConfigDisarmedExitDelay;\nextern const char *RConfigDisplayFlipped;\nextern const char *RConfigDuration;\nextern const char *RConfigEnrolled;\nextern const char *RConfigExternalTemperatureSensor;\nextern const char *RConfigExternalWindowOpen;\nextern const char *RConfigFanMode;\nextern const char *RConfigFilterLifeTime;\nextern const char *RConfigGPDDeviceId;\nextern const char *RConfigGPDKey;\nextern const char *RConfigGroup;\nextern const char *RConfigHeatSetpoint;\nextern const char *RConfigHostFlags;\nextern const char *RConfigHumiMaxThreshold;\nextern const char *RConfigHumiMinThreshold;\nextern const char *RConfigInterfaceMode;\nextern const char *RConfigLastChangeAmount;\nextern const char *RConfigLastChangeSource;\nextern const char *RConfigLastChangeTime;\nextern const char *RConfigLat;\nextern const char *RConfigLedIndication;\nextern const char *RConfigLoadBalancing;\nextern const char *RConfigLocalTime;\nextern const char *RConfigLock;\nextern const char *RConfigLocked;\nextern const char *RConfigLong;\nextern const char *RConfigMelody;\nextern const char *RConfigMode;\nextern const char *RConfigMountingMode;\nextern const char *RConfigOffset;\nextern const char *RConfigOn;\nextern const char *RConfigOnStartup;\nextern const char *RConfigPending;\nextern const char *RConfigPreset;\nextern const char *RConfigPulseConfiguration;\nextern const char *RConfigRadiatorCovered;\nextern const char *RConfigReachable;\nextern const char *RConfigReportGrid;\nextern const char *RConfigResetPresence;\nextern const char *RConfigReversed;\nextern const char *RConfigSchedule;\nextern const char *RConfigScheduleOn;\nextern const char *RConfigSelfTest;\nextern const char *RConfigSensitivity;\nextern const char *RConfigSensitivityBis;\nextern const char *RConfigSensitivityMax;\nextern const char *RConfigSetValve;\nextern const char *RConfigSpeed;\nextern const char *RConfigSunriseOffset;\nextern const char *RConfigSunsetOffset;\nextern const char *RConfigUnoccupiedHeatSetpoint;\nextern const char *RConfigSwingMode;\nextern const char *RConfigTempMaxThreshold;\nextern const char *RConfigTempMinThreshold;\nextern const char *RConfigTemperature;\nextern const char *RConfigTemperatureMeasurement;\nextern const char *RConfigTholdDark;\nextern const char *RConfigTholdOffset;\nextern const char *RConfigTriggerDistance;\nextern const char *RConfigTriggerDistanceBis;\nextern const char *RConfigUbisysJ1AdditionalSteps;\nextern const char *RConfigUbisysJ1ConfigurationAndStatus;\nextern const char *RConfigUbisysJ1InactivePowerThreshold;\nextern const char *RConfigUbisysJ1InstalledClosedLimitLift;\nextern const char *RConfigUbisysJ1InstalledClosedLimitTilt;\nextern const char *RConfigUbisysJ1InstalledOpenLimitLift;\nextern const char *RConfigUbisysJ1InstalledOpenLimitTilt;\nextern const char *RConfigUbisysJ1LiftToTiltTransitionSteps;\nextern const char *RConfigUbisysJ1LiftToTiltTransitionSteps2;\nextern const char *RConfigUbisysJ1Mode;\nextern const char *RConfigUbisysJ1StartupSteps;\nextern const char *RConfigUbisysJ1TotalSteps;\nextern const char *RConfigUbisysJ1TotalSteps2;\nextern const char *RConfigUbisysJ1TurnaroundGuardTime;\nextern const char *RConfigUbisysJ1WindowCoveringType;\nextern const char *RConfigUrl;\nextern const char *RConfigUsertest;\nextern const char *RConfigVolume;\nextern const char *RConfigWindowCoveringType;\nextern const char *RConfigWindowOpen;\nextern const char *RConfigWindowOpenDetectionEnabled;\n\n#define R_ALERT_DEFAULT             QVariant(QLatin1String(\"none\"))\n#define R_SENSITIVITY_MAX_DEFAULT   2\n#define R_THOLDDARK_DEFAULT         12000\n#define R_THOLDOFFSET_DEFAULT       7000\n\nextern const QStringList RStateAlertValues;\nextern const QStringList RStateAlertValuesTriggerEffect;\n\nextern const QStringList RStateEffectValues;\nextern const QStringList RStateEffectValuesMueller;\nextern const QStringList RStateEffectValuesXmasLightStrip;\n\nextern const QStringList RConfigLastChangeSourceValues;\n\nextern const QStringList RConfigDeviceModeValues;\n\n#define R_PENDING_DELAY             (1 << 0)\n#define R_PENDING_SENSITIVITY       (1 << 2)\n#define R_PENDING_WRITE_CIE_ADDRESS (1 << 4)\n#define R_PENDING_ENROLL_RESPONSE   (1 << 5)\n#define R_PENDING_MODE              (1 << 6)\n#define R_PENDING_WRITE_POLL_CHECKIN_INTERVAL  (1 << 6)\n#define R_PENDING_SET_LONG_POLL_INTERVAL       (1 << 7)\n\n// after device announce is received lights can be brought into a defined state\n// this might be useful for powerloss and OTA updates or simply providing a default power on configuration\n#define R_POWERUP_RESTORE                   (1 << 0)  // restore last known on/off and brightness state\n#define R_POWERUP_RESTORE_AT_DAYLIGHT       (1 << 1)  // restore at daylight\n#define R_POWERUP_RESTORE_AT_NO_DAYLIGHT    (1 << 2)  // restore when no daylight\n\nnamespace deCONZ {\n    class ApsDataIndication;\n    class ZclFrame;\n}\n\nclass  ResourceItemDescriptor\n{\npublic:\n    enum class Access { Unknown, ReadWrite, ReadOnly };\n    ResourceItemDescriptor() = default;\n    ResourceItemDescriptor(ApiDataType t, QVariant::Type v, const char *s, qint64 min = 0, qint64 max = 0) :\n        type(t),\n        qVariantType(v),\n        suffix(s),\n        validMin((double)min),\n        validMax((double)max) { }\n\n    bool isValid() const { return (type != DataTypeUnknown && suffix); }\n    Access access = Access::Unknown;\n    ApiDataType type = DataTypeUnknown;\n    QVariant::Type qVariantType = QVariant::Invalid;\n    const char *suffix = RInvalidSuffix;\n    double validMin = 0;\n    double validMax = 0;\n    quint16 flags = 0;\n};\n\nclass Resource;\nclass ResourceItem;\n\nusing ItemString = BufString<16>;\n\nclass ResourceItem\n{\npublic:\n    enum ItemFlags\n    {\n        FlagNeedPushSet     = 0x01, // set after a value has been set\n        FlagNeedPushChange  = 0x02, // set when new value different than previous\n        FlagPushOnSet       = 0x04, // events will be generated when item is set (even when value doesn't change)\n        FlagPushOnChange    = 0x08, // events will be generated only when item changes\n        FlagAwakeOnSet      = 0x10, // REventAwake will be generated when item is set after parse\n        FlagImplicit        = 0x20, // the item is always present for a specific resource type\n        FlagDynamicDescriptor = 0x40, // ResourceItemDescriptor is dynamic (not specified in code)\n        FlagNeedStore      = 0x80,   // set when item needs to be stored to database\n        FlagZclUnsupportedAttr = 0x100  // set when the \"read\" function failed with ZCL unsupported attribute status\n    };\n\n    enum ValueSource\n    {\n        SourceUnknown,\n        SourceDevice,\n        SourceApi\n    };\n\n    ResourceItem(const ResourceItem &other);\n    ResourceItem(ResourceItem &&other) noexcept;\n    ResourceItem(const ResourceItemDescriptor &rid);\n    ResourceItem &operator=(const ResourceItem &other);\n    ResourceItem &operator=(ResourceItem &&other) noexcept;\n    ~ResourceItem() noexcept;\n    bool needPushSet() const;\n    bool needPushChange() const;\n    void clearNeedPush();\n    bool needStore() const;\n    void setNeedStore();\n    void clearNeedStore();\n    bool pushOnSet() const;\n    void setPushOnSet(bool enable);\n    bool pushOnChange() const;\n    void setPushOnChange(bool enable);\n    bool awake() const;\n    void setAwake(bool awake);\n    bool implicit() const;\n    void setImplicit(bool implicit);\n    void setZclUnsupportedAttribute();\n    bool zclUnsupportedAttribute() const;\n    const QString &toString() const;\n    QLatin1String toLatin1String() const;\n    const char *toCString() const;\n    unsigned atomIndex() const { return m_strHandle; }\n    qint64 toNumber() const;\n    qint64 toNumberPrevious() const;\n    deCONZ::SteadyTimeRef lastZclReport() const { return m_lastZclReport; }\n    void setLastZclReport(deCONZ::SteadyTimeRef t) { m_lastZclReport = t; }\n    bool toBool() const;\n    QVariant toVariant() const;\n    deCONZ::TimeSeconds refreshInterval() const { return m_refreshInterval; }\n    void setRefreshInterval(deCONZ::TimeSeconds interval) { m_refreshInterval = interval; }\n    void setZclProperties(const ZCL_Param &param) { m_zclParam = param; }\n    void setReadEndpoint(uint8_t ep) { m_readEndpoint = ep; }\n    uint8_t readEndpoint() const { return m_readEndpoint; }\n    bool setValue(const char *str, int length, ValueSource source = SourceUnknown);\n    bool setValue(const QString &val, ValueSource source = SourceUnknown);\n    bool setValue(qint64 val, ValueSource source = SourceUnknown);\n    bool setValue(const QVariant &val, ValueSource source = SourceUnknown);\n    bool equalsString(const char *str, int length = -1) const;\n    const ResourceItemDescriptor &descriptor() const;\n    const QDateTime &lastSet() const;\n    const QDateTime &lastChanged() const;\n    void setTimeStamps(const QDateTime &t);\n    void inRule(int ruleHandle);\n    const std::vector<int> &rulesInvolved() const;\n    bool isPublic() const;\n    void setIsPublic(bool isPublic);\n    const ZCL_Param &zclParam() const { return m_zclParam; }\n    ParseFunction_t parseFunction() const { return m_parseFunction; }\n    void setParseFunction(ParseFunction_t fn) { m_parseFunction = fn; }\n    ValueSource valueSource() const { return m_valueSource; }\n    void setDdfItemHandle(quint32 handle) { m_ddfItemHandle = handle; }\n    quint32 ddfItemHandle() const { return m_ddfItemHandle; }\n\nprivate:\n    ResourceItem() = delete;\n    bool setItemString(const QString &str);\n\n    /* New layout\n\n        quint16 flags;\n        quint16 m_ridHandle;\n        quint32 m_ddfItemHandle;\n        qint32 m_lastSet; // ms since epoch - FIX_OSSET\n        qint32 m_lastChanged; // ...\n        qint64 num;\n        qint64 numPrevious;\n        ItemString istr;\n\n        // . 40 bytes\n     */\n\n    ValueSource m_valueSource = SourceUnknown;\n    bool m_isPublic = true;\n    uint16_t m_flags = 0; // bitmap of ResourceItem::ItemFlags\n    uint16_t m_ridIndex = 0; // index into rItemDescriptors[]\n    union\n    {\n        struct {\n            qint64 m_num = 0;\n            qint64 m_numPrev = 0;\n        };\n        struct {\n            double m_double;\n            double m_doublePrev;\n        };\n    };\n    deCONZ::SteadyTimeRef m_lastZclReport;\n\n    unsigned m_strHandle = 0; // for strings which don't fit into \\c m_istr\n    ItemString m_istr; // internal embedded small string\n    deCONZ::TimeSeconds m_refreshInterval;\n    QString *m_str = nullptr;\n    QDateTime m_lastSet;\n    QDateTime m_lastChanged;\n    std::vector<int> m_rulesInvolved; // the rules a resource item is trigger\n    ZCL_Param m_zclParam{}; // for parse function\n    ParseFunction_t m_parseFunction = nullptr;\n    quint32 m_ddfItemHandle = 0; // invalid item handle\n    uint8_t m_readEndpoint = 0;\n};\n\nclass Resource\n{\npublic:\n    struct Handle\n    {\n        uint hash = 0;     // qHash(uniqueid)\n        quint16 index = 0; // index in container\n        // 'D' device\n        // 'G' group\n        // 'L' LightNode\n        // 'S' Sensor\n        char type = 0;\n        quint8 order = 0;\n    };\n\n    Resource(const char *prefix);\n    ~Resource() = default;\n    Resource(const Resource &other);\n    Resource(Resource &&other) noexcept;\n    Resource &operator=(const Resource &other);\n    Resource &operator=(Resource &&other) noexcept;\n    const char *prefix() const;\n    ResourceItem *addItem(ApiDataType type, const char *suffix);\n    void removeItem(const char *suffix);\n    ResourceItem *item(const char *suffix);\n    const ResourceItem *item(const char *suffix) const;\n    bool toBool(const char *suffix) const;\n    qint64 toNumber(const char *suffix) const;\n    const QString &toString(const char *suffix) const;\n    QVariant toVariant(const char *suffix) const;\n    virtual void didSetValue(ResourceItem *) {};\n    bool setValue(const char *suffix, qint64 val, bool forceUpdate = false);\n    bool setValue(const char *suffix, const QString &val, bool forceUpdate = false);\n    bool setValue(const char *suffix, const QVariant &val, bool forceUpdate = false);\n    int itemCount() const;\n    ResourceItem *itemForIndex(size_t idx);\n    const ResourceItem *itemForIndex(size_t idx) const;\n    void addStateChange(const StateChange &stateChange);\n    std::vector<StateChange> &stateChanges() { return m_stateChanges; }\n    void cleanupStateChanges();\n    Resource *parentResource() { return m_parent; }\n    const Resource *parentResource() const { return m_parent; }\n    void setParentResource(Resource *parent) { m_parent = parent; }\n    Handle handle() const noexcept { return m_handle; }\n    void setHandle(Handle handle) { m_handle = handle; }\n\nprivate:\n    Resource() = delete;\n    Handle m_handle{};\n    const char *m_prefix = nullptr;\n    Resource *m_parent = nullptr;\n    std::vector<ResourceItem> m_rItems;\n    std::vector<StateChange> m_stateChanges;\n};\n\nvoid initResourceDescriptors();\nconst char *getResourcePrefix(const QString &str);\nbool getResourceItemDescriptor(const QString &str, ResourceItemDescriptor &descr);\n#define R_SetFlags(item, flags) R_SetFlags1(item, flags, #flags)\nbool R_SetFlags1(ResourceItem *item, qint64 flags, const char *strFlags);\n#define R_ClearFlags(item, flags) R_ClearFlags1(item, flags, #flags)\nbool R_ClearFlags1(ResourceItem *item, qint64 flags, const char *strFlags);\nbool R_HasFlags(const ResourceItem *item, qint64 flags);\n\ntemplate <typename V>\nbool R_SetValue(Resource *r, const char *suffix, const V &val, ResourceItem::ValueSource source)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(suffix);\n\n    auto *item = r->item(suffix);\n    if (!item)\n    {\n        return false;\n    }\n\n    return item->setValue(val, source);\n}\n\ntemplate <typename V, typename EventEmitter>\nbool R_SetValueEventOnChange(Resource *r, const char *suffix, const V &val, ResourceItem::ValueSource source, EventEmitter *eventEmitter = nullptr)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(suffix);\n    Q_ASSERT(eventEmitter);\n\n    auto *item = r->item(suffix);\n    if (!item)\n    {\n        return false;\n    }\n\n    const auto result = item->setValue(val, source);\n\n    if (result && item->lastChanged() != item->lastSet())\n    {\n        const auto *idItem = r->item(RAttrId);\n        if (!idItem)\n        {\n            idItem = r->item(RAttrUniqueId);\n        }\n        Q_ASSERT(idItem);\n\n        eventEmitter->enqueueEvent({r->prefix(), item->descriptor().suffix, idItem->toString(), item});\n    }\n\n    return result;\n}\n\ntemplate <typename V, typename EventEmitter>\nbool R_SetValueEventOnSet(Resource *r, const char *suffix, const V &val, ResourceItem::ValueSource source, EventEmitter *eventEmitter = nullptr)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(suffix);\n    Q_ASSERT(eventEmitter);\n\n    auto *item = r->item(suffix);\n    if (!item)\n    {\n        return false;\n    }\n\n    const auto result = item->setValue(val, source);\n\n    if (result)\n    {\n        const auto *idItem = r->item(RAttrId);\n        if (!idItem)\n        {\n            idItem = r->item(RAttrUniqueId);\n        }\n        Q_ASSERT(idItem);\n\n        eventEmitter->enqueueEvent({r->prefix(), item->descriptor().suffix, idItem->toString(), item});\n    }\n\n    return result;\n}\n\nbool R_AddResourceItemDescriptor(const ResourceItemDescriptor &rid);\n\nbool isValidRConfigGroup(const QString &str);\n\nuint8_t DDF_GetSubDeviceOrder(const QString &type);\nQLatin1String R_DataTypeToString(ApiDataType type);\ninline bool isValid(Resource::Handle hnd) { return hnd.hash != 0 && hnd.index < UINT16_MAX && hnd.type != 0; }\ninline bool operator==(Resource::Handle a, Resource::Handle b) { return a.hash == b.hash && a.type == b.type; }\n\n#endif // RESOURCE_H\n"
        },
        {
          "name": "resource",
          "type": "tree",
          "content": null
        },
        {
          "name": "resourcelinks.cpp",
          "type": "blob",
          "size": 0.2880859375,
          "content": "#include \"resourcelinks.h\"\n\nResourcelinks::Resourcelinks() :\n    state(StateNormal),\n    m_needSaveDatabase(false)\n{\n}\n\nbool Resourcelinks::needSaveDatabase() const\n{\n    return m_needSaveDatabase;\n}\n\nvoid Resourcelinks::setNeedSaveDatabase(bool needSave)\n{\n    m_needSaveDatabase = needSave;\n}\n"
        },
        {
          "name": "resourcelinks.h",
          "type": "blob",
          "size": 0.73828125,
          "content": "/*\n * Copyright (c) 2017 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n#ifndef RESOURCELINKS_H\n#define RESOURCELINKS_H\n\n#include <QString>\n#include <QVariantMap>\n#include <vector>\n\n/*! \\class Resourcelinks\n\n    Represents REST API resourcelinks.\n */\nclass Resourcelinks\n{\npublic:\n    enum State { StateNormal, StateDeleted };\n    Resourcelinks();\n    bool needSaveDatabase() const;\n    void setNeedSaveDatabase(bool needSave);\n\n    State state;\n    QString id;\n    QVariantMap data;\n\nprivate:\n    bool m_needSaveDatabase;\n};\n\n#endif // RESOURCELINKS_H\n"
        },
        {
          "name": "rest_alarmsystems.cpp",
          "type": "blob",
          "size": 22.1015625,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"alarm_system_device_table.h\"\n#include \"de_web_plugin_private.h\"\n#include \"rest_alarmsystems.h\"\n\n#define ALARMSYS_PREFIX \"/alarmsystems\"\n#define FMT_AS_ID \"/alarmsystems/%1\"\n#define FMT_AS_ID_DEV \"/alarmsystems/%1/device/%2\"\n#define FMT_AS_RESOURCE_NOT_AVAILABLE \"resource, /alarmsystems/%1, not available\"\n#define FMT_AS_RESOURCE_DEV_NOT_AVAILABLE \"resource, /alarmsystems/%1/device/%2, not available\"\n\nstatic const QLatin1String paramArmMask(\"armmask\");\nstatic const QLatin1String paramTrigger(\"trigger\");\nstatic const QLatin1String paramName(\"name\");\n\nstatic int getAllAlarmSystems(const ApiRequest &req, ApiResponse &rsp, const AlarmSystems &alarmSystems);\nstatic int getAlarmSystem(const ApiRequest &req, ApiResponse &rsp, const AlarmSystems &alarmSystems);\nstatic int putAlarmSystemConfig(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems);\nstatic int putAlarmSystemAttributes(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems);\nstatic int putAlarmSystemArmMode(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems);\nstatic int putAlarmSystemDevice(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems);\nstatic int deleteAlarmSystemDevice(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems);\n\nstatic QVariantMap errAlarmSystemNotAvailable(QLatin1String id)\n{\n    return errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(FMT_AS_ID).arg(id),\n                                                  QString(FMT_AS_RESOURCE_NOT_AVAILABLE).arg(id));\n}\n\nstatic QVariantMap errBodyContainsInvalidJson(int id)\n{\n    return errorToMap(ERR_INVALID_JSON, QString(FMT_AS_ID).arg(id),\n                                        QString(\"body contains invalid JSON\"));\n}\n\nstatic QVariantMap errInternalError(int id, const QString &reason)\n{\n    return errorToMap(ERR_INTERNAL_ERROR, QString(FMT_AS_ID).arg(id),\n                                        QString(\"internal error, %1, occured\").arg(reason));\n}\n\nstatic QVariantMap errMissingParameter(int id, const QLatin1String &param)\n{\n    return errorToMap(ERR_MISSING_PARAMETER, QString(FMT_AS_ID).arg(id), QString(\"missing parameter, %1\").arg(param));\n}\n\nstatic QVariantMap errAlarmSystemDeviceNotAvailable(const QLatin1String &id, const QLatin1String &uniqueId)\n{\n    return errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(FMT_AS_ID).arg(id),\n                                                  QString(FMT_AS_RESOURCE_DEV_NOT_AVAILABLE).arg(id).arg(uniqueId));\n}\n\n\nstatic QVariantMap errInvalidDeviceValue(int id, const QLatin1String &uniqueId, const QLatin1String &param, const QString &value)\n{\n    return errorToMap(ERR_INVALID_VALUE, QString(FMT_AS_ID_DEV \"/%3\").arg(id).arg(uniqueId).arg(param),\n                                         QString(\"invalid value, %1, for parameter, %2\").arg(value).arg(param));\n}\n\nstatic QVariantMap errMissingDeviceParameter(int id, QLatin1String uniqueId, const QLatin1String &param)\n{\n    return errorToMap(ERR_MISSING_PARAMETER, QString(FMT_AS_ID_DEV).arg(id).arg(uniqueId),\n                                             QString(\"missing parameter, %1\").arg(param));\n}\n\nstatic QVariantMap errInvalidValue(int id, const char *suffix, const QString &value)\n{\n    Q_ASSERT(suffix);\n\n    const char *param = strchr(suffix, '/');\n    DBG_Assert(param != nullptr);\n    if (!param)\n    {\n        return {};\n    }\n    param++;\n\n    if (suffix[0] == 'a' && suffix[1] == 't')\n    {\n        suffix = param; // strip attr/\n    }\n\n    return errorToMap(ERR_INVALID_VALUE, QString(FMT_AS_ID \"/%2\").arg(id).arg(QLatin1String(suffix)), QString(\"invalid value, %1, for parameter, %2\").arg(value).arg(QLatin1String(param)));\n}\n\nstatic QVariantMap errParameterNotAvailable(int id, const QString &param)\n{\n    return errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(FMT_AS_ID \"/%2\").arg(id).arg(param), QString(\"parameter, %1, not available\").arg(param));\n}\n\nstatic bool isValidAlaramSystemId(QLatin1String id)\n{\n    if (id.size() == 0)\n    {\n        return false;\n    }\n\n    for (int i = 0; i < id.size(); i++)\n    {\n        if (!std::isdigit(id.data()[i]))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic int alarmSystemIdToInteger(QLatin1String id)\n{\n    if (isValidAlaramSystemId(id))\n    {\n        return std::atoi(id.data());\n    }\n\n    return INT_MAX;\n}\n\n\nstatic QVariantMap alarmSystemToMap(const AlarmSystem *alarmSys)\n{\n    QVariantMap result;\n\n    QVariantMap config;\n    QVariantMap state;\n    QVariantMap devices;\n\n    state[QLatin1String(\"armstate\")] = alarmSys->armStateString();\n    state[QLatin1String(\"seconds_remaining\")] = alarmSys->secondsRemaining();\n\n    const auto alarmSystemId = alarmSys->id();\n\n    for (size_t i = 0; i < alarmSys->deviceTable()->size(); i++)\n    {\n        const AS_DeviceEntry &entry = alarmSys->deviceTable()->at(i);\n        if (entry.alarmSystemId == alarmSystemId && isValid(entry))\n        {\n            QVariantMap dev;\n\n            if ((entry.flags & (AS_ENTRY_FLAG_ARMED_AWAY | AS_ENTRY_FLAG_ARMED_STAY | AS_ENTRY_FLAG_ARMED_NIGHT)) != 0)\n            {\n                dev[paramArmMask] = QLatin1String(entry.armMask);\n            }\n            else\n            {\n                dev[paramArmMask] = QLatin1String(\"none\");\n            }\n\n            // TODO  \"trigger\": \"state/presence\"\n\n            devices[QLatin1String(entry.uniqueId, entry.uniqueIdSize)] = dev;\n        }\n    }\n\n    for (int i = 0; i < alarmSys->itemCount(); i++)\n    {\n        const ResourceItem *item = alarmSys->itemForIndex(i);\n\n        if (item && item->isPublic() && memcmp(item->descriptor().suffix, \"config/\", 7) == 0)\n        {\n            config[QLatin1String(item->descriptor().suffix + 7)] = item->toVariant();\n        }\n    }\n\n    result[QLatin1String(\"name\")] = alarmSys->item(RAttrName)->toString();\n    result[QLatin1String(\"config\")] = config;\n    result[QLatin1String(\"state\")] = state;\n    result[QLatin1String(\"devices\")] = devices;\n\n    return result;\n}\n\nint AS_handleAlarmSystemsApi(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems, EventEmitter *eventEmitter)\n{\n    Q_UNUSED(eventEmitter);\n\n    // GET /api/<apikey>/alarmsystems\n    if (req.hdr.pathComponentsCount() == 3 && req.hdr.httpMethod() == HttpGet)\n    {\n        return getAllAlarmSystems(req, rsp, alarmSystems);\n    }\n\n    // POST /api/<apikey>/alarmsystems\n    if (req.hdr.pathComponentsCount() == 3 && req.hdr.httpMethod() == HttpPost)\n    {\n        rsp.httpStatus = HttpStatusNotImplemented;\n        return REQ_READY_SEND;\n    }\n\n    // GET /api/<apikey>/alarmsystems/<id>\n    if (req.hdr.pathComponentsCount() == 4 && req.hdr.httpMethod() == HttpGet)\n    {\n        return getAlarmSystem(req, rsp, alarmSystems);\n    }\n\n    // PUT /api/<apikey>/alarmsystems/<id>/config\n    if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpPut && req.hdr.pathAt(4) == QLatin1String(\"config\"))\n    {\n        return putAlarmSystemConfig(req, rsp, alarmSystems);\n    }\n\n    // PUT /api/<apikey>/alarmsystems/<id>/device/<uniqueid>\n    if (req.hdr.pathComponentsCount() == 6 && req.hdr.httpMethod() == HttpPut && req.hdr.pathAt(4) == QLatin1String(\"device\"))\n    {\n        return putAlarmSystemDevice(req, rsp, alarmSystems);\n    }\n\n    // DELETE /api/<apikey>/alarmsystems/<id>/device/<uniqueid>\n    if (req.hdr.pathComponentsCount() == 6 && req.hdr.httpMethod() == HttpDelete && req.hdr.pathAt(4) == QLatin1String(\"device\"))\n    {\n        return deleteAlarmSystemDevice(req, rsp, alarmSystems);\n    }\n\n    // PUT /api/<apikey>/alarmsystems/<id>\n    if (req.hdr.pathComponentsCount() == 4 && req.hdr.httpMethod() == HttpPut)\n    {\n        return putAlarmSystemAttributes(req, rsp, alarmSystems);\n    }\n\n    // PUT /api/<apikey>/alarmsystems/<id>/(disarm | arm_stay | arm_night | arm_away)\n    if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpPut)\n    {\n        const QLatin1String op = req.hdr.pathAt(4);\n        if (op == QLatin1String(\"disarm\") || op == QLatin1String(\"arm_stay\") || op == QLatin1String(\"arm_night\") || op == QLatin1String(\"arm_away\"))\n        {\n            return putAlarmSystemArmMode(req, rsp, alarmSystems);\n        }\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\nQVariantMap AS_AlarmSystemsToMap(const AlarmSystems &alarmSystems)\n{\n    QVariantMap result;\n\n    for (const AlarmSystem *alarmSys : alarmSystems.alarmSystems)\n    {\n        result[QString::number(alarmSys->id())] = alarmSystemToMap(alarmSys);\n    }\n\n    return result;\n}\n\nstatic int getAllAlarmSystems(const ApiRequest &, ApiResponse &rsp, const AlarmSystems &alarmSystems)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    if (alarmSystems.alarmSystems.empty())\n    {\n        rsp.str = QLatin1String(\"{}\");\n        return REQ_READY_SEND;\n    }\n\n    rsp.map = AS_AlarmSystemsToMap(alarmSystems);\n\n    return REQ_READY_SEND;\n}\n\nstatic int getAlarmSystem(const ApiRequest &req, ApiResponse &rsp, const AlarmSystems &alarmSystems)\n{\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    const AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n    rsp.map = alarmSystemToMap(alarmSys);\n\n    return REQ_READY_SEND;\n}\n\n// [ { \"success\": { \"/alarmsystems/1/config/configured\": true } } ]\n\nQVariantMap addSuccessEntry(int id, const char *suffix, const QVariant &value)\n{\n    QVariantMap result;\n    QVariantMap item;\n\n    item[QString(FMT_AS_ID \"/%2\").arg(id).arg(QLatin1String(suffix))] = value;\n    result[QLatin1String(\"success\")] = item;\n\n    return result;\n}\n\n// PUT /api/<apikey>/alarmsystems/<id>/config\nstatic int putAlarmSystemConfig(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems)\n{\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    bool ok = false;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.list.append(errBodyContainsInvalidJson(id));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    const auto keys = map.keys();\n\n    for (const auto &key : keys)\n    {\n        if (key == QLatin1String(\"code0\"))\n        {\n            const QString code0 = map.value(key).toString();\n\n            if (code0.size() < 4 || code0.size() > 16)\n            {\n                rsp.list.append(errInvalidValue(id, \"config/code0\", code0));\n                rsp.httpStatus = HttpStatusBadRequest;\n                return REQ_READY_SEND;\n            }\n\n            if (alarmSys->setCode(0, code0))\n            {\n                rsp.list.append(addSuccessEntry(id, RConfigConfigured, true));\n            }\n            else\n            {\n                rsp.list.append(errInternalError(id, QLatin1String(\"failed to set code\")));\n                rsp.httpStatus = HttpStatusServiceUnavailable;\n                return REQ_READY_SEND;\n            }\n\n            continue;\n        }\n\n        ResourceItemDescriptor rid;\n\n        if (!getResourceItemDescriptor(QString(\"config/%1\").arg(key), rid))\n        {\n            rsp.list.append(errParameterNotAvailable(id, key));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n\n        std::array<const char*, 2> readOnly = { RConfigArmMode, RConfigConfigured };\n\n        if (std::find(readOnly.cbegin(), readOnly.cend(), rid.suffix) != readOnly.cend())\n        {\n            rsp.list.append(errParameterNotAvailable(id, key));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n\n        auto val = map.value(key);\n        if (alarmSys->setValue(rid.suffix, val))\n        {\n            rsp.list.append(addSuccessEntry(id, rid.suffix, val));\n        }\n        else\n        {\n            rsp.list.append(errInvalidValue(id, rid.suffix, val.toString()));\n            rsp.httpStatus = HttpStatusServiceUnavailable;\n            return REQ_READY_SEND;\n        }\n    }\n\n    return REQ_READY_SEND;\n}\n\n// PUT /api/<apikey>/alarmsystems/<id>\nstatic int putAlarmSystemAttributes(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems)\n{\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    bool ok = false;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.list.append(errBodyContainsInvalidJson(id));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    const auto keys = map.keys();\n    rsp.httpStatus = HttpStatusOk;\n\n    for (const auto &key : keys)\n    {\n        if (key == paramName)\n        {\n            const auto name = map.value(key).toString();\n\n            if (name.isEmpty() || name.size() > 32)\n            {\n                rsp.list.append(errInvalidValue(id, RAttrName, name));\n                rsp.httpStatus = HttpStatusNotFound;\n                return REQ_READY_SEND;\n            }\n\n            alarmSys->setValue(RAttrName, name);\n\n            rsp.list.append(addSuccessEntry(id, paramName.data(), name));\n        }\n        else\n        {\n            rsp.list.append(errParameterNotAvailable(id, key));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n    }\n\n    return REQ_READY_SEND;\n}\n\n\n// PUT /api/<apikey>/alarmsystems/<id>/(disarm | arm_stay | arm_night | arm_away)\nstatic int putAlarmSystemArmMode(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems)\n{\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    bool ok = false;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.list.append(errBodyContainsInvalidJson(id));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    if (!map.contains(QLatin1String(\"code0\")))\n    {\n        rsp.list.append(errMissingParameter(id, QLatin1String(\"code0\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    const QString code0 = map.value(QLatin1String(\"code0\")).toString();\n\n    if (!alarmSys->isValidCode(code0, 0))\n    {\n        rsp.list.append(errInvalidValue(id, \"attr/code0\", code0)); // use attr/ since this gets stripped away\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    AS_ArmMode mode = AS_ArmModeMax;\n\n    const QLatin1String op = req.hdr.pathAt(4);\n    if      (op == QLatin1String(\"disarm\"))    { mode = AS_ArmModeDisarmed; }\n    else if (op == QLatin1String(\"arm_away\"))  { mode = AS_ArmModeArmedAway; }\n    else if (op == QLatin1String(\"arm_stay\"))  { mode = AS_ArmModeArmedStay; }\n    else if (op == QLatin1String(\"arm_night\")) { mode = AS_ArmModeArmedNight; }\n    else\n    {\n        DBG_Assert(0 && \"should never happen\");\n        return REQ_READY_SEND;\n    }\n\n    if (alarmSys->setTargetArmMode(mode))\n    {\n        // success\n        rsp.list.append(addSuccessEntry(id, RConfigArmMode, AS_ArmModeToString(mode)));\n    }\n    else\n    {\n        rsp.list.append(errInternalError(id, QString(\"failed to %1 the alarm system\").arg(op)));\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    return REQ_READY_SEND;\n}\n\nstatic bool isValidArmMask(const QString &armMask)\n{\n    if (armMask.isEmpty())\n    {\n        return false;\n    }\n\n    for (const auto ch : armMask)\n    {\n        if (!(ch == 'A' || ch == 'S' || ch == 'N'))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nbool isValidAlarmDeviceTrigger(const char *suffix)\n{\n    const std::array<const char*, 5> triggers = {\n        RStatePresence,\n        RStateVibration,\n        RStateOpen,\n        RStateButtonEvent,\n        RStateOn\n    };\n\n    return std::find(triggers.cbegin(), triggers.cend(), suffix) != triggers.cend();\n}\n\nconst char *getAlarmTriggerSuffix(const Resource *r)\n{\n    const std::array<const char*, 5> triggers = {\n        RStatePresence,\n        RStateVibration,\n        RStateOpen,\n        RStateButtonEvent,\n        RStateOn\n    };\n\n    for (const char *suffix : triggers)\n    {\n        const ResourceItem *item = r->item(suffix);\n        if (item)\n        {\n            return suffix;\n        }\n    }\n\n    return nullptr;\n}\n\n// PUT /api/<apikey>/alarmsystems/<id>/device/<uniqueid>\nstatic int putAlarmSystemDevice(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    const QLatin1String uniqueqId = req.hdr.pathAt(5);\n    Sensor *sensor = plugin->getSensorNodeForUniqueId(uniqueqId);\n    Resource *dev = sensor;\n\n    if (!dev)\n    {\n        dev = plugin->getLightNodeForId(uniqueqId);\n    }\n\n    if (!dev)\n    {\n        rsp.list.append(errAlarmSystemDeviceNotAvailable(req.hdr.pathAt(3), uniqueqId));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    bool ok = false;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok)\n    {\n        rsp.list.append(errBodyContainsInvalidJson(id));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    quint32 flags = 0;\n\n    // keypad and keyfobs\n    if (sensor && sensor->fingerPrint().hasOutCluster(IAS_ACE_CLUSTER_ID))\n    {\n        flags |= AS_ENTRY_FLAG_IAS_ACE;\n    }\n\n    if (map.isEmpty() && flags == 0) // non IAS ACE devices\n    {\n        rsp.list.append(errAlarmSystemDeviceNotAvailable(req.hdr.pathAt(3), uniqueqId));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n    else\n    {\n        ResourceItem *item = nullptr;\n\n        if (map.contains(paramArmMask))\n        {\n            const auto m = map.value(paramArmMask).toString();\n\n            if (!isValidArmMask(m))\n            {\n                rsp.list.append(errInvalidDeviceValue(id, uniqueqId, paramArmMask, m));\n                rsp.httpStatus = HttpStatusNotFound;\n                return REQ_READY_SEND;\n            }\n\n            if (m.contains('A')) { flags |= AS_ENTRY_FLAG_ARMED_AWAY; }\n            if (m.contains('S')) { flags |= AS_ENTRY_FLAG_ARMED_STAY; }\n            if (m.contains('N')) { flags |= AS_ENTRY_FLAG_ARMED_NIGHT; }\n        }\n        else if (flags == 0) // non IAS ACE devices\n        {\n            rsp.list.append(errMissingDeviceParameter(id, uniqueqId, paramArmMask));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n\n        if (map.contains(paramTrigger))\n        {\n            const auto trigger = map.value(paramTrigger).toString();\n\n            ResourceItemDescriptor rid;\n            if (getResourceItemDescriptor(trigger, rid))\n            {\n                if (isValidAlarmDeviceTrigger(rid.suffix))\n                {\n                    item = dev->item(rid.suffix);\n                }\n            }\n        }\n        else // auto selection\n        {\n            item = dev->item(getAlarmTriggerSuffix(dev));\n        }\n\n        if (!item && flags == 0) // non IAS ACE devices\n        {\n            rsp.list.append(errAlarmSystemDeviceNotAvailable(req.hdr.pathAt(3), uniqueqId));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n    }\n\n    if (alarmSys->addDevice(uniqueqId, flags))\n    {\n        QVariantMap rspItem;\n        QVariantMap success;\n        success[QLatin1String(\"added\")] = QString(FMT_AS_ID_DEV).arg(id).arg(uniqueqId);\n        rspItem[QLatin1String(\"success\")] = success;\n\n        rsp.list.append(rspItem);\n    }\n    else\n    {\n        rsp.list.append(errAlarmSystemDeviceNotAvailable(req.hdr.pathAt(3), uniqueqId));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    return REQ_READY_SEND;\n}\n\n// DELETE /api/<apikey>/alarmsystems/<id>/device/<uniqueid>\nstatic int deleteAlarmSystemDevice(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    const int id = alarmSystemIdToInteger(req.hdr.pathAt(3));\n\n    AlarmSystem *alarmSys = AS_GetAlarmSystem(id, alarmSystems);\n\n    if (!alarmSys)\n    {\n        rsp.list.append(errAlarmSystemNotAvailable(req.hdr.pathAt(3)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    const QLatin1String uniqueqId = req.hdr.pathAt(5);\n\n    {\n        const AS_DeviceEntry &entry = alarmSys->deviceTable()->get(QString(uniqueqId));\n\n        if (!isValid(entry))\n        {\n            rsp.list.append(errAlarmSystemDeviceNotAvailable(req.hdr.pathAt(3), uniqueqId));\n            rsp.httpStatus = HttpStatusNotFound;\n            return REQ_READY_SEND;\n        }\n    }\n\n    if (alarmSys->removeDevice(uniqueqId))\n    {\n        QVariantMap rspItem;\n        QVariantMap success;\n        success[QLatin1String(\"removed\")] = QString(FMT_AS_ID_DEV).arg(id).arg(uniqueqId);\n        rspItem[QLatin1String(\"success\")] = success;\n\n        rsp.list.append(rspItem);\n    }\n    else\n    {\n        rsp.list.append(errInternalError(id, QLatin1String(\"failed remove device\")));\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rest_alarmsystems.h",
          "type": "blob",
          "size": 0.7939453125,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_ALARMSYSTEMS_H\n#define REST_ALARMSYSTEMS_H\n\n#include <QVariant>\n\nclass ApiRequest;\nclass ApiResponse;\nclass EventEmitter;\nclass AlarmSystems;\n\n/*! Alarm systems REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint AS_handleAlarmSystemsApi(const ApiRequest &req, ApiResponse &rsp, AlarmSystems &alarmSystems, EventEmitter *eventEmitter);\nQVariantMap AS_AlarmSystemsToMap(const AlarmSystems &alarmSystems);\n\n#endif // REST_ALARMSYSTEMS_H\n"
        },
        {
          "name": "rest_api.cpp",
          "type": "blob",
          "size": 2.0478515625,
          "content": "/*\n * Copyright (c) 2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <deconz/dbg_trace.h>\n#include \"rest_api.h\"\n\nconst char *HttpStatusOk           = \"200 OK\"; // OK\nconst char *HttpStatusAccepted     = \"202 Accepted\"; // Accepted but not complete\nconst char *HttpStatusNotModified  = \"304 Not Modified\"; // For ETag / If-None-Match\nconst char *HttpStatusBadRequest   = \"400 Bad Request\"; // Malformed request\nconst char *HttpStatusUnauthorized = \"401 Unauthorized\"; // Unauthorized\nconst char *HttpStatusForbidden    = \"403 Forbidden\"; // Understand request but no permission\nconst char *HttpStatusNotFound     = \"404 Not Found\"; // Requested uri not found\nconst char *HttpStatusServiceUnavailable = \"503 Service Unavailable\";\nconst char *HttpStatusNotImplemented = \"501 Not Implemented\";\nconst char *HttpContentHtml        = \"text/html; charset=utf-8\";\nconst char *HttpContentCss         = \"text/css\";\nconst char *HttpContentJson        = \"application/json; charset=utf-8\";\nconst char *HttpContentJS          = \"text/javascript\";\nconst char *HttpContentPNG         = \"image/png\";\nconst char *HttpContentJPG         = \"image/jpg\";\nconst char *HttpContentSVG         = \"image/svg+xml\";\nconst char *HttpContentOctetStream = \"application/octet-stream\";\n\n/*! Creates a error map used in JSON response.\n    \\param id - error id\n    \\param ressource example: \"/lights/2\"\n    \\param description example: \"resource, /lights/2, not available\"\n    \\return the map\n */\nQVariantMap errorToMap(int id, const QString &ressource, const QString &description)\n{\n    QVariantMap map;\n    QVariantMap error;\n    error[\"type\"] = (double)id;\n    error[\"address\"] = ressource.toHtmlEscaped();\n    error[\"description\"] = description.toHtmlEscaped();\n    map[\"error\"] = error;\n\n    DBG_Printf(DBG_INFO_L2, \"API error %d, %s, %s\\n\", id, qPrintable(ressource), qPrintable(description));\n\n    return map;\n}\n"
        },
        {
          "name": "rest_api.h",
          "type": "blob",
          "size": 3.919921875,
          "content": "/*\n * Copyright (c) 2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_API_H\n#define REST_API_H\n\n#include <QString>\n#include <QList>\n#include <QVariant>\n\n#include <deconz/qhttprequest_compat.h>\n#include <deconz/http_client_handler.h>\n\n/*! JSON generic error message codes */\n#define ERR_UNAUTHORIZED_USER          1\n#define ERR_INVALID_JSON               2\n#define ERR_RESOURCE_NOT_AVAILABLE     3\n#define ERR_METHOD_NOT_AVAILABLE       4\n#define ERR_MISSING_PARAMETER          5\n#define ERR_PARAMETER_NOT_AVAILABLE    6\n#define ERR_INVALID_VALUE              7\n#define ERR_PARAMETER_NOT_MODIFIABLE   8\n#define ERR_TOO_MANY_ITEMS             11\n#define ERR_INVALID_DDF_BUNDLE         12\n#define ERR_DUPLICATE_EXIST            100 // de extension\n#define ERR_NOT_ALLOWED_SENSOR_TYPE    501\n#define ERR_SENSOR_LIST_FULL           502\n#define ERR_RULE_ENGINE_FULL           601\n#define ERR_CONDITION_ERROR            607\n#define ERR_ACTION_ERROR               608\n#define ERR_INTERNAL_ERROR             901\n\n#define ERR_NOT_CONNECTED              950 // de extension\n#define ERR_BRIDGE_BUSY                951 // de extension\n\n#define ERR_LINK_BUTTON_NOT_PRESSED    101\n#define ERR_DEVICE_OFF                 201\n#define ERR_DEVICE_NOT_REACHABLE       202\n#define ERR_BRIDGE_GROUP_TABLE_FULL    301\n#define ERR_DEVICE_GROUP_TABLE_FULL    302\n\n#define ERR_DEVICE_SCENES_TABLE_FULL   402 // de extension\n\n// REST API return codes\n#define REQ_READY_SEND   0\n#define REQ_NOT_HANDLED -1\n\n// HTTP status codes\nextern const char *HttpStatusOk;\nextern const char *HttpStatusAccepted;\nextern const char *HttpStatusNotModified;\nextern const char *HttpStatusUnauthorized;\nextern const char *HttpStatusBadRequest;\nextern const char *HttpStatusForbidden;\nextern const char *HttpStatusNotFound;\nextern const char *HttpStatusNotImplemented;\nextern const char *HttpStatusServiceUnavailable;\nextern const char *HttpContentHtml;\nextern const char *HttpContentCss;\nextern const char *HttpContentJson;\nextern const char *HttpContentJS;\nextern const char *HttpContentPNG;\nextern const char *HttpContentJPG;\nextern const char *HttpContentSVG;\nextern const char *HttpContentOctetStream;\n\nenum ApiVersion\n{\n    ApiVersion_1,        //!< common version 1.0\n    ApiVersion_1_DDEL,   //!< version 1.0, \"Accept: application/vnd.ddel.v1\"\n    ApiVersion_1_1_DDEL, //!< version 1.1, \"Accept: application/vnd.ddel.v1.1\"\n    ApiVersion_2_DDEL,   //!< version 2.0, \"Accept: application/vnd.ddel.v2\"\n    ApiVersion_3_DDEL    //!< version 3.0, \"Accept: application/vnd.ddel.v3\"\n};\n\nenum ApiAuthorisation\n{\n    ApiAuthNone,\n    ApiAuthLocal,\n    ApiAuthInternal,\n    ApiAuthFull\n};\n\nenum ApiMode\n{\n    ApiModeNormal,\n    ApiModeStrict,\n    ApiModeEcho,\n    ApiModeHue\n};\n\n/*! \\class ApiRequest\n\n    Helper to simplify HTTP REST request handling.\n */\nclass ApiRequest\n{\npublic:\n    ApiRequest(const QHttpRequestHeader &h, const QStringList &p, QTcpSocket *s, const QString &c);\n    QString apikey() const;\n    ApiVersion apiVersion() const { return version; }\n\n    const QHttpRequestHeader &hdr;\n    const QStringList &path;\n    QTcpSocket *sock;\n    QString content;\n    ApiVersion version;\n    ApiAuthorisation auth;\n    ApiMode mode;\n};\n\n/*! \\class ApiResponse\n\n    Helper to simplify HTTP REST request handling.\n */\nclass ApiResponse\n{\npublic:\n    QString etag;\n    const char *httpStatus = nullptr;\n    const char *contentType = nullptr;\n    unsigned contentLength = 0;\n    const char *fileName = nullptr; // for Content-Disposition: attachment: filename=\"<fileName>\"\n    QVariantMap map; // json content\n    QVariantList list; // json content\n    QString str; // json string\n    char *bin = nullptr;\n};\n\n// REST API common\nQVariantMap errorToMap(int id, const QString &ressource, const QString &description);\n\n#endif // REST_API_H\n"
        },
        {
          "name": "rest_capabilities.cpp",
          "type": "blob",
          "size": 5.08984375,
          "content": "/*\n * Copyright (c) 2018-2019 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n/*! Capabilities REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleCapabilitiesApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    // GET /api/<apikey>/capabilities\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\n    {\n        return getCapabilities(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! GET /api/<apikey>/info/timezones\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getCapabilities(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req)\n\n    QVariantMap lightsMap;\n    lightsMap[QLatin1String(\"available\")] = static_cast<double>(MAX_NODES - nodes.size());\n    lightsMap[QLatin1String(\"total\")] = MAX_NODES;\n    rsp.map[QLatin1String(\"lights\")] = lightsMap;\n\n    QVariantMap sensorsMap;\n    sensorsMap[QLatin1String(\"available\")] = static_cast<double>(MAX_SENSORS - sensors.size());\n    sensorsMap[QLatin1String(\"total\")] = MAX_SENSORS;\n    QVariantMap clipMap;\n    clipMap[QLatin1String(\"available\")] = static_cast<double>(MAX_SENSORS - sensors.size());\n    clipMap[QLatin1String(\"total\")] = MAX_SENSORS;\n    sensorsMap[QLatin1String(\"clip\")] = clipMap;\n    QVariantMap zllMap;\n    zllMap[QLatin1String(\"available\")] = static_cast<double>(MAX_NODES - nodes.size());\n    zllMap[QLatin1String(\"total\")] = MAX_NODES;\n    sensorsMap[QLatin1String(\"zll\")] = zllMap;\n    QVariantMap zgpMap;\n    zgpMap[QLatin1String(\"available\")] = static_cast<double>(MAX_NODES - nodes.size());\n    zgpMap[QLatin1String(\"total\")] = MAX_NODES;\n    sensorsMap[QLatin1String(\"zgp\")] = zgpMap;\n    rsp.map[QLatin1String(\"sensors\")] = sensorsMap;\n\n    QVariantMap groupsMap;\n    groupsMap[QLatin1String(\"available\")] = static_cast<double>(MAX_GROUPS - groups.size());\n    groupsMap[QLatin1String(\"total\")] = MAX_GROUPS;\n    rsp.map[QLatin1String(\"groups\")] = groupsMap;\n\n    QVariantMap scenesMap;\n    int scenes_size = 0;\n    int lightstates_size = 0;\n    {\n        std::vector<Group>::iterator g = groups.begin();\n        std::vector<Group>::iterator g_end = groups.end();\n        for (; g != g_end; ++g)\n        {\n            scenes_size += g->scenes.size();\n            std::vector<Scene>::const_iterator s = g->scenes.begin();\n            std::vector<Scene>::const_iterator s_end = g->scenes.end();\n            for (; s != s_end; ++s)\n            {\n                lightstates_size += s->lights().size();\n            }\n        }\n    }\n    scenesMap[QLatin1String(\"available\")] = MAX_SCENES - scenes_size;\n    scenesMap[QLatin1String(\"total\")] = MAX_SCENES;\n    QVariantMap lightstatesMap;\n    lightstatesMap[QLatin1String(\"available\")] = MAX_LIGHTSTATES - lightstates_size;\n    lightstatesMap[QLatin1String(\"total\")] = MAX_LIGHTSTATES;\n    scenesMap[QLatin1String(\"lightstates\")] = lightstatesMap;\n    rsp.map[QLatin1String(\"scenes\")] = scenesMap;\n\n    QVariantMap schedulesMap;\n    schedulesMap[QLatin1String(\"available\")] = static_cast<double>(MAX_SCHEDULES - schedules.size());\n    schedulesMap[QLatin1String(\"total\")] = MAX_SCHEDULES;\n    rsp.map[QLatin1String(\"schedules\")] = schedulesMap;\n\n    QVariantMap rulesMap;\n    int conditions_size = 0;\n    int actions_size = 0;\n    {\n        std::vector<Rule>::const_iterator r = rules.begin();\n        std::vector<Rule>::const_iterator r_end = rules.end();\n        for (; r != r_end; ++r)\n        {\n            conditions_size += r->conditions().size();\n            actions_size += r->actions().size();\n        }\n    }\n    rulesMap[QLatin1String(\"available\")] = static_cast<double>(MAX_RULES - rules.size());\n    rulesMap[QLatin1String(\"total\")] = MAX_RULES;\n    QVariantMap conditionsMap;\n    conditionsMap[QLatin1String(\"available\")] = MAX_CONDITIONS - conditions_size;\n    conditionsMap[QLatin1String(\"total\")] = MAX_CONDITIONS;\n    rulesMap[QLatin1String(\"conditions\")] = conditionsMap;\n    QVariantMap actionsMap;\n    actionsMap[QLatin1String(\"available\")] = MAX_ACTIONS - actions_size;\n    actionsMap[QLatin1String(\"total\")] = MAX_ACTIONS;\n    rulesMap[QLatin1String(\"actions\")] = actionsMap;\n    rsp.map[QLatin1String(\"rules\")] = rulesMap;\n\n    QVariantMap resourcelinksMap;\n    resourcelinksMap[QLatin1String(\"available\")] = static_cast<double>(MAX_RESOURCELINKS - resourcelinks.size());\n    resourcelinksMap[QLatin1String(\"total\")] = MAX_RESOURCELINKS;\n    rsp.map[QLatin1String(\"resourcelinks\")] = resourcelinksMap;\n\n    QVariantMap streamingMap;\n    streamingMap[QLatin1String(\"available\")] = MAX_STREAMING;\n    streamingMap[QLatin1String(\"total\")] = MAX_STREAMING;\n    streamingMap[QLatin1String(\"channels\")] = MAX_CHANNELS;\n    rsp.map[QLatin1String(\"streaming\")] = streamingMap;\n\n    QVariantMap tzs;\n    tzs[\"values\"] = getTimezones();\n    rsp.map[\"timezones\"] = tzs;\n\n    rsp.httpStatus = HttpStatusOk;\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rest_configuration.cpp",
          "type": "blob",
          "size": 129.0390625,
          "content": "/*\r\n * Copyright (c) 2013-2021 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QApplication>\r\n#include <QCryptographicHash>\r\n#include <QMessageAuthenticationCode>\r\n#include <QDesktopServices>\r\n#include <QFile>\r\n#include <QString>\r\n#include <QTcpSocket>\r\n#include <QVariantMap>\r\n#include <QNetworkInterface>\r\n#include <QProcessEnvironment>\r\n#include <math.h>\r\n#include \"rest_alarmsystems.h\"\r\n#include \"daylight.h\"\r\n#include \"de_web_plugin.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"json.h\"\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <QProcess>\r\n#include \"backup.h\"\r\n#include \"crypto/password.h\"\r\n#include \"crypto/random.h\"\r\n#include \"gateway.h\"\r\n#include \"utils/utils.h\"\r\n#ifdef Q_OS_LINUX\r\n  #include <unistd.h>\r\n  #include <sys/time.h>\r\n#endif // Q_OS_LINUX\r\n\r\n/*! Constructor. */\r\nApiConfig::ApiConfig() :\r\n    Resource(RConfig)\r\n{\r\n}\r\n\r\n/*! Init the configuration. */\r\nvoid DeRestPluginPrivate::initConfig()\r\n{\r\n    QString dataPath = deCONZ::getStorageLocation(deCONZ::ApplicationsDataLocation);\r\n\r\n    pollDatabaseWifiTimer = nullptr;\r\n\r\n    // default configuration\r\n    gwWifiLastUpdated = 0;\r\n    gwRunFromShellScript = false;\r\n    gwDeleteUnknownRules = (deCONZ::appArgumentNumeric(\"--delete-unknown-rules\", 1) == 1) ? true : false;\r\n    gwRfConnected = false; // will be detected later\r\n    gwRfConnectedExpected = (deCONZ::appArgumentNumeric(\"--auto-connect\", 1) == 1) ? true : false;\r\n    gwPermitJoinDuration = 0;\r\n    gwNetworkOpenDuration = 60;\r\n    gwWifiState = WifiStateInitMgmt;\r\n    gwWifiMgmt = 0;\r\n    gwWifi = QLatin1String(\"not-configured\");\r\n    gwWifiStateString = QLatin1String(\"not-configured\");\r\n    gwWifiType = QLatin1String(\"accesspoint\");\r\n    gwWifiName = QString();\r\n    gwWifiEth0 = QString();\r\n    gwWifiWlan0 = QString();\r\n    gwWifiClientName = QString();\r\n    gwWifiChannel = \"1\";\r\n    gwWifiIp = QLatin1String(\"192.168.8.1\");\r\n    gwWifiPw = \"\";\r\n    gwWifiClientPw = \"\";\r\n    //gwWifiApPw = \"\";\r\n    gwWifiPageActive = false;\r\n    gwHomebridge = QLatin1String(\"not-managed\");\r\n    gwHomebridgeVersion = QString();\r\n    gwHomebridgeUpdateVersion = QString();\r\n    gwHomebridgeUpdate = false;\r\n    gwHomebridgePin = QString();\r\n    gwRgbwDisplay = \"1\";\r\n    gwTimeFormat = \"12h\";\r\n    gwZigbeeChannel = 0;\r\n    gwGroup0 = 0;\r\n    gwName = GW_DEFAULT_NAME;\r\n    gwUpdateVersion = GW_SW_VERSION; // will be replaced by discovery handler\r\n    {\r\n        const QDateTime d = QDateTime::fromMSecsSinceEpoch(GW_SW_DATE * 1000LLU);\r\n        gwUpdateDate = d.toString(\"yyyy-MM-ddTHH:mm:ss\"); // ISO 8601;\r\n    }\r\n    gwSwUpdateState = swUpdateState.noUpdate;\r\n    gwUpdateChannel = \"stable\";\r\n    gwReportingEnabled = (deCONZ::appArgumentNumeric(\"--reporting\", 1) == 1) ? true : false;\r\n    gwFirmwareNeedUpdate = false;\r\n    gwFirmwareVersion = \"0x00000000\"; // query later\r\n    gwFirmwareVersionUpdate = \"\";\r\n    gwMAC = \"38:60:77:7c:53:18\";\r\n    gwIPAddress = \"127.0.0.1\";\r\n    gwPort = (apsCtrl ? apsCtrl->getParameter(deCONZ::ParamHttpPort) : static_cast<quint16>(deCONZ::appArgumentNumeric(\"--http-port\", 80)));\r\n    gwNetMask = \"255.0.0.0\";\r\n    gwHueMode = (deCONZ::appArgumentNumeric(\"--hue-mode\", 0) == 1);\r\n    gwLANBridgeId = (deCONZ::appArgumentNumeric(\"--lan-bridgeid\", 0) == 1) || gwHueMode;\r\n    gwBridgeId = \"0000000000000000\";\r\n    gwAllowLocal = (deCONZ::appArgumentNumeric(\"--allow-local\", 1) == 1);\r\n    gwConfig[\"websocketport\"] = 443;\r\n    fwUpdateState = FW_Idle;\r\n\r\n    wifiPageActiveTimer = new QTimer(this);\r\n    wifiPageActiveTimer->setSingleShot(true);\r\n\r\n    connect(wifiPageActiveTimer, SIGNAL(timeout()),\r\n            this, SLOT(wifiPageActiveTimerFired()));\r\n\r\n    QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\r\n\r\n    if (env.contains(QLatin1String(\"INVOCATION_ID\")))\r\n    {\r\n        // deCONZ is startet from a systemd unit\r\n        //   -- deconz.service or deconz-gui.service\r\n        if (env.contains(QLatin1String(\"DISPLAY\")))\r\n        {\r\n            gwRunMode = QLatin1String(\"systemd/gui\");\r\n        }\r\n        else\r\n        {\r\n            gwRunMode = QLatin1String(\"systemd/headless\");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        gwRunMode = QLatin1String(\"normal\");\r\n\r\n#ifdef Q_OS_LINUX\r\n        // check if we run from shell script\r\n        QFile pproc(QString(\"/proc/%1/cmdline\").arg(getppid()));\r\n\r\n        if (pproc.exists() && pproc.open(QIODevice::ReadOnly))\r\n        {\r\n            QByteArray name = pproc.readAll();\r\n            if (name.endsWith(\".sh\"))\r\n            {\r\n                DBG_Printf(DBG_INFO, \"runs in shell script %s\\n\", qPrintable(name));\r\n                gwRunFromShellScript = true;\r\n                gwRunMode = QLatin1String(\"shellscript\");\r\n            }\r\n            else\r\n            {\r\n                gwRunFromShellScript = false;\r\n                DBG_Printf(DBG_INFO, \"parent process %s\\n\", qPrintable(name));\r\n            }\r\n        }\r\n\r\n        QFile cgroups(\"/proc/1/cgroup\");\r\n        if (cgroups.exists() && cgroups.open(QIODevice::ReadOnly))\r\n        {\r\n            QByteArray content = cgroups.readAll();\r\n            if (content.contains(\"/docker/\"))\r\n            {\r\n                // https://github.com/marthoc/docker-deconz/blob/master/amd64-hassio-addon/run.sh\r\n                if (QFile::exists(\"/data/options.json\"))\r\n                {\r\n                    gwRunMode = QLatin1String(\"docker/hassio\");\r\n                }\r\n                else\r\n                {\r\n                    gwRunMode = QLatin1String(\"docker\");\r\n                }\r\n            }\r\n        }\r\n#else\r\n        gwRunFromShellScript = false;\r\n#endif\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"gw run mode: %s\\n\", qPrintable(gwRunMode));\r\n\r\n    // offical dresden elektronik sd-card image?\r\n    {\r\n        QFile f(dataPath + QLatin1String(\"/gw-version\"));\r\n        if (f.exists() && f.open(QFile::ReadOnly))\r\n        {\r\n            gwSdImageVersion = f.readAll().trimmed();\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"GW sd-card image version file does not exist: %s\\n\", qPrintable(f.fileName()));\r\n        }\r\n    }\r\n\r\n    if (!gwSdImageVersion.isEmpty())\r\n    {\r\n        DBG_Printf(DBG_INFO, \"GW sd-card image version: %s\\n\", qPrintable(gwSdImageVersion));\r\n    }\r\n\r\n#ifdef Q_OS_LINUX\r\n#ifdef ARCH_ARM\r\n    {\r\n        QFile f(\"/sys/block/mmcblk0/device/cid\");\r\n        if (f.exists() && f.open(QFile::ReadOnly))\r\n        {\r\n            QByteArray cid = f.readAll().left(32);\r\n            // wipe serial number\r\n            for (int i = 18; i < (18 + 8); i++)\r\n            { cid[i] = 'f'; }\r\n            DBG_Printf(DBG_INFO, \"sd-card cid: %s\\n\", qPrintable(cid));\r\n        }\r\n    }\r\n#endif\r\n#endif\r\n\r\n    config.addItem(DataTypeTime, RConfigLocalTime);\r\n\r\n    {\r\n        QHttpRequestHeader hdr;\r\n        QStringList path;\r\n        QString content;\r\n        ApiRequest dummyReq(hdr, path, nullptr, content);\r\n        dummyReq.version = ApiVersion_1_DDEL;\r\n        configToMap(dummyReq, gwConfig);\r\n    }\r\n\r\n    gwProxyPort = 0;\r\n    gwProxyAddress = \"none\";\r\n\r\n    timeManagerState = TM_Init;\r\n    ntpqProcess = nullptr;\r\n    QTimer::singleShot(2000, this, SLOT(timeManagerTimerFired()));\r\n\r\n    pollSwUpdateStateTimer = new QTimer(this);\r\n    pollSwUpdateStateTimer->setSingleShot(false);\r\n    connect(pollSwUpdateStateTimer, SIGNAL(timeout()),\r\n            this, SLOT(pollSwUpdateStateTimerFired()));\r\n\r\n    connect(deCONZ::ApsController::instance(), &deCONZ::ApsController::configurationChanged,\r\n            this, &DeRestPluginPrivate::configurationChanged);\r\n\r\n#if DECONZ_LIB_VERSION >= 0x010C00\r\n    connect(deCONZ::ApsController::instance(), &deCONZ::ApsController::networkStateChangeRequest,\r\n            this, &DeRestPluginPrivate::networkStateChangeRequest);\r\n#endif\r\n}\r\n\r\n/*! Init timezone. */\r\nvoid DeRestPluginPrivate::initTimezone()\r\n{\r\n#ifdef Q_OS_LINUX\r\n#ifdef ARCH_ARM\r\n    QFile file;\r\n    QString timezone;\r\n    QString timedatectl(\"/usr/bin/timedatectl\");\r\n    file.setFileName(\"/etc/timezone\");\r\n\r\n    // first try to query systemd via timedatectl\r\n    // needed on distributions not having /etc/timezone, or being it a directory (Arch Linux)\r\n    if (QFile::exists(timedatectl))\r\n    {\r\n        QProcess pr;\r\n        pr.start(timedatectl, {\"status\"});\r\n        pr.waitForFinished();\r\n        QTextStream ts(&pr);\r\n\r\n        QString line;\r\n        while (ts.readLineInto(&line, 1024))\r\n        {\r\n            line = line.trimmed();\r\n            if (line.startsWith(QLatin1String(\"Time zone:\")))\r\n            {\r\n                // split at first space after timezone value\r\n                // Europe/Berlin (CEST, +0200) --> Europe/Berlin\r\n                int beg = line.indexOf(':') + 1;\r\n                int end = line.indexOf(' ', beg + 4); // might be -1 (ok)\r\n                int length = end > beg ? end - beg : -1;\r\n                timezone = line.mid(beg, length).trimmed();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (timezone.isEmpty() && file.exists())\r\n    {\r\n        file.open(QIODevice::ReadOnly | QIODevice::Text);\r\n        QTextStream stream(&file);\r\n\r\n        if (!stream.readLineInto(&timezone, 100))\r\n        {\r\n            DBG_Printf(DBG_INFO, \"[ERROR] - Timezone could not be read from file system (/etc/timezone)...\\n\");\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"[INFO] - Timezone read is '%s'\\n\", qPrintable(timezone));\r\n        }\r\n\r\n        file.close();\r\n    }\r\n\r\n    if (!timezone.isEmpty())\r\n    {\r\n        gwTimezone = timezone;\r\n    }\r\n    else\r\n    {\r\n        if (gwTimezone.isEmpty())\r\n        {\r\n            gwTimezone = QLatin1String(\"Etc/GMT\");\r\n        }\r\n    }\r\n\r\n    if (getenv(\"TZ\") == NULL)\r\n    {\r\n        file.setFileName(\"/etc/localtime\");\r\n        QString tzValue;\r\n\r\n        if (file.exists())\r\n        {\r\n            tzValue = \":/etc/localtime\";\r\n        }\r\n        else if (!timezone.isEmpty())\r\n        {\r\n            tzValue = timezone;\r\n        }\r\n        else\r\n        {\r\n            tzValue = gwTimezone;\r\n        }\r\n\r\n        DBG_Printf(DBG_INFO, \"[INFO] - Setting environment variable 'TZ=%s'...\\n\", qPrintable(tzValue));\r\n        setenv(\"TZ\", qPrintable(tzValue), 1);\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_INFO, \"[INFO] - Environment variable TZ found: %s...\\n\", qPrintable(getenv(\"TZ\")));\r\n    }\r\n#endif\r\n#endif\r\n\r\n    if (daylightSensorId.isEmpty())\r\n    {\r\n        Sensor dl;\r\n        ResourceItem *item;\r\n        openDb();\r\n        daylightSensorId = QString::number(getFreeSensorId());\r\n        closeDb();\r\n        dl.setId(daylightSensorId);\r\n        dl.setType(QLatin1String(\"Daylight\"));\r\n        dl.setName(QLatin1String(\"Daylight\"));\r\n        item = dl.addItem(DataTypeBool, RConfigConfigured);\r\n        item->setValue(false);\r\n        item = dl.addItem(DataTypeInt8, RConfigSunriseOffset);\r\n        item->setValue(30);\r\n        item = dl.addItem(DataTypeInt8, RConfigSunsetOffset);\r\n        item->setValue(-30);\r\n        item = dl.addItem(DataTypeBool, RStateDaylight);\r\n        item->setValue(QVariant());\r\n        item = dl.addItem(DataTypeBool, RStateDark);\r\n        item->setValue(QVariant());\r\n        item = dl.addItem(DataTypeInt32, RStateStatus);\r\n        item->setValue(QVariant());\r\n        item = dl.addItem(DataTypeString, RConfigLat);\r\n        item->setIsPublic(false);\r\n        item = dl.addItem(DataTypeString, RConfigLong);\r\n        item->setIsPublic(false);\r\n\r\n        dl.removeItem(RConfigReachable);\r\n        dl.removeItem(RAttrLastAnnounced);\r\n        dl.removeItem(RAttrLastSeen);\r\n\r\n        dl.setModelId(QLatin1String(\"PHDL00\"));\r\n        dl.setManufacturer(QLatin1String(\"Philips\"));\r\n        dl.setSwVersion(QLatin1String(\"1.0\"));\r\n        dl.item(RConfigOn)->setValue(true);\r\n        dl.setNeedSaveDatabase(true);\r\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\r\n        sensors.push_back(dl);\r\n    }\r\n\r\n    QTimer *daylighTimer = new QTimer(this);\r\n    connect(daylighTimer, SIGNAL(timeout()), this, SLOT(daylightTimerFired()));\r\n    daylighTimer->setSingleShot(false);\r\n    daylighTimer->start(10000);\r\n\r\n    daylightTimerFired();\r\n}\r\n\r\n/*! Init the network info. */\r\nvoid DeRestPluginPrivate::initNetworkInfo()\r\n{\r\n    bool ok = false;\r\n    bool retry = false;\r\n\r\n    QList<QNetworkInterface> ifaces = QNetworkInterface::allInterfaces();\r\n    QList<QNetworkInterface>::Iterator i = ifaces.begin();\r\n    QList<QNetworkInterface>::Iterator end = ifaces.end();\r\n\r\n    // optimistic approach chose the first available ethernet interface\r\n    for (; !ok && i != end; ++i)\r\n    {\r\n        if (i->name() == QLatin1String(\"tun0\"))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        retry = true;\r\n        if ((i->flags() & QNetworkInterface::IsUp) &&\r\n            (i->flags() & QNetworkInterface::IsRunning) &&\r\n            !(i->flags() & QNetworkInterface::IsLoopBack))\r\n        {\r\n            //DBG_Printf(DBG_INFO, \"%s (%s)\\n\", qPrintable(i->name()), qPrintable(i->humanReadableName()));\r\n\r\n            QList<QNetworkAddressEntry> addresses = i->addressEntries();\r\n\r\n            if (ok || addresses.isEmpty())\r\n            {\r\n                continue;\r\n            }\r\n\r\n            QList<QNetworkAddressEntry>::Iterator a = addresses.begin();\r\n            QList<QNetworkAddressEntry>::Iterator aend = addresses.end();\r\n\r\n            for (; a != aend; ++a)\r\n            {\r\n                if (a->ip().protocol() != QAbstractSocket::IPv4Protocol)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                quint32 ipv4 = a->ip().toIPv4Address();\r\n                if ((ipv4 & 0xff000000UL) == 0x7f000000UL)\r\n                {\r\n                    // 127.x.x.x\r\n                    continue;\r\n                }\r\n\r\n                if ((ipv4 & 0x80000000UL) != 0x00000000UL && // class A 0xxx xxxx\r\n                    (ipv4 & 0xc0000000UL) != 0x80000000UL && // class B 10xx xxxx\r\n                    (ipv4 & 0xe0000000UL) != 0xc0000000UL)   // class C 110x xxxx\r\n                {\r\n                    // unsupported network\r\n                    continue;\r\n                }\r\n\r\n                if ((ipv4 & 0xFFFF0000ul) == 0xA9FE0000ul)\r\n                {\r\n                    // link local ip\r\n                    // 169.254.0.0 - 169.254.255.255\r\n                    continue;\r\n                }\r\n\r\n                QString mac = i->hardwareAddress().toLower();\r\n                gwMAC = mac;\r\n                if (gwLANBridgeId) {\r\n                    gwBridgeId = (mac.mid(0,2) + mac.mid(3,2) + mac.mid(6,2) + \"fffe\" + mac.mid(9,2) + mac.mid(12,2) + mac.mid(15,2)).toUpper();\r\n                    if (!gwConfig.contains(\"bridgeid\") || gwConfig[\"bridgeid\"] != gwBridgeId)\r\n                    {\r\n                        DBG_Printf(DBG_INFO, \"Set bridgeid to %s\\n\", qPrintable(gwBridgeId));\r\n                        gwConfig[\"bridgeid\"] = gwBridgeId;\r\n                        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n                    }\r\n                }\r\n                gwIPAddress = a->ip().toString();\r\n                gwConfig[\"ipaddress\"] = gwIPAddress;\r\n                gwNetMask = a->netmask().toString();\r\n                initDescriptionXml();\r\n                ok = true;\r\n                retry = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!ok)\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"No valid ethernet interface found\\n\");\r\n    }\r\n\r\n    if (retry)\r\n    {\r\n        QTimer::singleShot(10000, this, SLOT(initNetworkInfo()));\r\n    }\r\n}\r\n\r\n/*! Init WiFi parameters if necessary. */\r\nvoid DeRestPluginPrivate::initWiFi()\r\n{\r\n#if !defined(ARCH_ARM)\r\n    gwWifi = QLatin1String(\"not-available\");\r\n    return;\r\n#else\r\n    bool retry = false;\r\n    QList<QNetworkInterface> ifaces = QNetworkInterface::allInterfaces();\r\n    QList<QNetworkInterface>::Iterator i = ifaces.begin();\r\n    QList<QNetworkInterface>::Iterator end = ifaces.end();\r\n\r\n    bool wifiAvailable = false;\r\n    // only show wifi if wlan0 interface is found\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->name() == QLatin1String(\"wlan0\"))\r\n        {\r\n            wifiAvailable = true;\r\n        }\r\n    }\r\n    // or rpi3 is used\r\n    // 3A+ = 9020e0; 3B+ = a020d3; 3B(Embest) = a22082; 3B(Sony UK) = a02082; 3B(Sony Jp) = a32082; 3B(Stadium) = a52082;\r\n    if (piRevision == \"9020e0\" || piRevision == \"a020d3\" || piRevision == \"a22082\" ||\r\n        piRevision == \"a02082\" || piRevision == \"a32082\" || piRevision == \"a52082\")\r\n    {\r\n        wifiAvailable = true;\r\n    }\r\n\r\n    if (!wifiAvailable)\r\n    {\r\n        gwWifi = QLatin1String(\"not-available\");\r\n        return;\r\n    }\r\n\r\n    // only configure for official image\r\n    if (gwSdImageVersion.isEmpty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwWifiLastUpdated == 0)\r\n    {\r\n        QDateTime currentDateTime = QDateTime::currentDateTimeUtc();\r\n        gwWifiLastUpdated = currentDateTime.toTime_t();\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    if (gwWifiState == WifiStateInitMgmt)\r\n    {\r\n        retry = true;\r\n    }\r\n\r\n    if (gwBridgeId.isEmpty() || gwBridgeId.endsWith(QLatin1String(\"0000\")))\r\n    {\r\n        retry = true;\r\n    }\r\n\r\n    quint32 fwVersion = apsCtrl->getParameter(deCONZ::ParamFirmwareVersion);\r\n    if (fwVersion < 0x261e0500) // first version to support security material set\r\n    {\r\n        retry = true;\r\n    }\r\n\r\n    if (gwWifi != QLatin1String(\"not-configured\"))\r\n    {\r\n        retry = true;\r\n    }\r\n\r\n    QByteArray sec0 = apsCtrl->getParameter(deCONZ::ParamSecurityMaterial0);\r\n    if (sec0.isEmpty())\r\n    {\r\n        retry = true;\r\n    }\r\n\r\n    if (retry)\r\n    {\r\n        QTimer::singleShot(10000, this, SLOT(initWiFi()));\r\n        return;\r\n    }\r\n\r\n    if (!pollDatabaseWifiTimer)\r\n    {\r\n        pollDatabaseWifiTimer = new QTimer(this);\r\n        pollDatabaseWifiTimer->setSingleShot(false);\r\n        connect(pollDatabaseWifiTimer, SIGNAL(timeout()),\r\n                this, SLOT(pollDatabaseWifiTimerFired()));\r\n        pollDatabaseWifiTimer->start(10000);\r\n    }\r\n\r\n    if (gwWifiMgmt & WIFI_MGMT_ACTIVE)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (gwWifiName == QLatin1String(\"Phoscon-Gateway-0000\"))\r\n    {\r\n        // proceed to correct these\r\n        gwWifiName.clear();\r\n    }\r\n\r\n    gwWifi = QLatin1String(\"configured\");\r\n    gwWifiType = QLatin1String(\"accesspoint\");\r\n    gwWifiStateString = QLatin1String(\"configured-ap\");\r\n\r\n    if (gwWifiName.isEmpty() || gwWifiName == QLatin1String(\"Not set\"))\r\n    {\r\n        gwWifiName = QString(\"Phoscon-Gateway-%1\").arg(gwBridgeId.right(4));\r\n        gwWifiBackupName = gwWifiName;\r\n    }\r\n\r\n    if (gwWifiPw.isEmpty() || gwWifiPw.length() < 8)\r\n    {\r\n        gwWifiPw = sec0.mid(16, 16).toUpper();\r\n        gwWifiBackupPw = gwWifiPw;\r\n    }\r\n\r\n    queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n#endif\r\n}\r\n\r\n/*! Handle deCONZ::ApsController::configurationChanged() event.\r\n    This will be called when the configuration was changed via deCONZ network settings.\r\n */\r\nvoid DeRestPluginPrivate::configurationChanged()\r\n{\r\n    if (!apsCtrl)\r\n    {\r\n        return;\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"deCONZ configuration changed\");\r\n\r\n    bool update = false;\r\n\r\n    const quint64 macAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\r\n    //const quint16 nwkAddress = apsCtrl->getParameter(deCONZ::ParamNwkAddress);\r\n    if (macAddress != 0 && gwDeviceAddress.ext() != macAddress)\r\n    {\r\n        gwDeviceAddress = {}; // reset let idle timer update bridgeid\r\n        update = true;\r\n    }\r\n\r\n    const quint8 channel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\r\n    if (channel >= 11 && channel <= 26 && gwZigbeeChannel != channel)\r\n    {\r\n        gwZigbeeChannel = channel;\r\n        update = true;\r\n    }\r\n\r\n    if (update)\r\n    {\r\n        updateZigBeeConfigDb();\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n    }\r\n}\r\n\r\n/*! Network state change request received from deCONZ core (e.g. Join/Leave clicked)\r\n */\r\nvoid DeRestPluginPrivate::networkStateChangeRequest(bool shouldConnect)\r\n{\r\n    if (gwRfConnectedExpected != shouldConnect)\r\n    {\r\n        gwRfConnectedExpected = shouldConnect;\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n    }\r\n}\r\n\r\n/*! Configuration REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleConfigBasicApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    // POST /api\r\n    if ((req.path.size() == 1) && (req.hdr.method() == QLatin1String(\"POST\")))\r\n    {\r\n        return createUser(req, rsp);\r\n    }\r\n    // GET /api/challenge\r\n    else if ((req.path.size() == 2) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[1] == QLatin1String(\"challenge\")))\r\n    {\r\n        return getChallenge(req, rsp);\r\n    }\r\n    // GET /api/config\r\n    else if ((req.path.size() == 2) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[1] == QLatin1String(\"config\")))\r\n    {\r\n        return getBasicConfig(req, rsp);\r\n    }\r\n    // DELETE /api/config/password\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == QLatin1String(\"DELETE\")) && (req.path[1] == QLatin1String(\"config\")) && (req.path[2] == QLatin1String(\"password\")))\r\n    {\r\n        return deletePassword(req, rsp);\r\n    }\r\n    // GET /api/<nouser>/config\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[2] == QLatin1String(\"config\")))\r\n    {\r\n        return getBasicConfig(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! Configuration REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleConfigLocalApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    // GET api/<localuser>/config/wifi\r\n    if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"wifi\")))\r\n    {\r\n        return getWifiState(req, rsp);\r\n    }\r\n    // PUT /api/<localuser>/config/wifi/updated\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"wifi\")) && (req.path[4] == QLatin1String(\"updated\")))\r\n    {\r\n        return putWifiUpdated(req, rsp);\r\n    }\r\n    // PUT /api/<localuser>/config/homebridge/updated\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"homebridge\")) && (req.path[4] == QLatin1String(\"updated\")))\r\n    {\r\n        return putHomebridgeUpdated(req, rsp);\r\n    }\r\n    // PUT /api/<localuser>/config/wifi/scanresult\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"wifi\")) && (req.path[4] == QLatin1String(\"scanresult\")))\r\n    {\r\n        return putWifiScanResult(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! Configuration REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleConfigFullApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    // GET /api/<apikey>/config\r\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\") && (req.path[2] == \"config\"))\r\n    {\r\n        return getConfig(req, rsp);\r\n    }\r\n    // GET api/<apikey>/config/wifi\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\") && (req.path[2] == \"config\") && (req.path[3] == \"wifi\"))\r\n    {\r\n        return getWifiState(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/config/wifi\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\") && (req.path[2] == \"config\") && (req.path[3] == \"wifi\"))\r\n    {\r\n        return configureWifi(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/config/wifi/restore\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"PUT\") && (req.path[2] == \"config\") && (req.path[3] == \"wifi\") && (req.path[4] == \"restore\"))\r\n    {\r\n        return restoreWifiConfig(req, rsp);\r\n    }\r\n    // GET /api/config/zigbee\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"zigbee\")))\r\n    {\r\n        return getZigbeeConfig(req, rsp);\r\n    }\r\n    // PUT /api/config/zigbee/<id>\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\")) && (req.path[2] == QLatin1String(\"config\")) && (req.path[3] == QLatin1String(\"zigbee\")))\r\n    {\r\n        return putZigbeeConfig(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/config/homebridge/reset\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"PUT\") && (req.path[2] == \"config\") && (req.path[3] == \"homebridge\") && (req.path[4] == \"reset\"))\r\n    {\r\n        return resetHomebridge(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/config\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\") && (req.path[2] == \"config\"))\r\n    {\r\n        return modifyConfig(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/config/whitelist/<username2>\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"DELETE\") && (req.path[2] == \"config\") && (req.path[3] == \"whitelist\"))\r\n    {\r\n        return deleteUser(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/update\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"update\"))\r\n    {\r\n        return updateSoftware(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/restart\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"restart\"))\r\n    {\r\n        return restartGateway(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/restartapp\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"restartapp\"))\r\n    {\r\n        return restartApp(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/shutdown\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"shutdown\"))\r\n    {\r\n        return shutDownGateway(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/updatefirmware\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"updatefirmware\"))\r\n    {\r\n        return updateFirmware(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/export\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"export\"))\r\n    {\r\n        return exportConfig(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/import\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"import\"))\r\n    {\r\n        return importConfig(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/reset\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"reset\"))\r\n    {\r\n        return resetConfig(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/config/wifiscan\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[2] == \"config\") && (req.path[3] == \"wifiscan\"))\r\n    {\r\n        return scanWifiNetworks(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/config/password\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\") && (req.path[2] == \"config\") && (req.path[3] == \"password\"))\r\n    {\r\n        return changePassword(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! POST /api\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::createUser(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    bool found = false; // already exist?\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    ApiAuth auth;\r\n    QHostAddress localHost(QHostAddress::LocalHost);\r\n\r\n    if (!gwLinkButton)\r\n    {\r\n        QString host = req.hdr.value(QLatin1String(\"Host\"));\r\n        if (host.indexOf(':') > 0)\r\n        {\r\n            host = host.split(':')[0];\r\n        }\r\n\r\n        if (gwAllowLocal && req.sock->peerAddress() == localHost && (host == QLatin1String(\"127.0.0.1\") || host == QLatin1String(\"localhost\")))\r\n        {\r\n            // proceed\r\n        }\r\n        else if (!allowedToCreateApikey(req, rsp, map))\r\n        {\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QLatin1String(\"/\"), QLatin1String(\"body contains invalid JSON\")));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!map.contains(\"devicetype\")) // required\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QLatin1String(\"/\"), QLatin1String(\"missing parameters in body\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    auth.setDeviceType(map[\"devicetype\"].toString());\r\n\r\n    if (map.contains(\"username\")) // optional (note username = apikey)\r\n    {\r\n        if ((map[\"username\"].type() != QVariant::String) ||\r\n            (map[\"username\"].toString().length() < 10))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/\"), QString(\"invalid value, %1, for parameter, username\").arg(map[\"username\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        auth.apikey = map[\"username\"].toString();\r\n\r\n        // check if this apikey is already known\r\n        std::vector<ApiAuth>::const_iterator i = apiAuths.begin();\r\n        std::vector<ApiAuth>::const_iterator end = apiAuths.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (auth.apikey == i->apikey && i->state == ApiAuth::StateNormal)\r\n            {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // check for glitches from some devices registering too fast (Amazon Echo)\r\n        std::vector<ApiAuth>::const_iterator i = apiAuths.begin();\r\n        std::vector<ApiAuth>::const_iterator end = apiAuths.end();\r\n\r\n        for (; i != end && !found ; ++i)\r\n        {\r\n            if (auth.devicetype == i->devicetype && i->state == ApiAuth::StateNormal)\r\n            {\r\n                if (i->createDate.secsTo(QDateTime::currentDateTimeUtc()) < 30)\r\n                {\r\n                    auth = *i;\r\n                    found = true;\r\n                    DBG_Printf(DBG_INFO, \"reuse recently created auth username: %s, devicetype: %s\\n\", qPrintable(auth.apikey), qPrintable(auth.devicetype));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!found)\r\n        {\r\n            // create a random key (used only if not provided)\r\n            unsigned char rnd[5];\r\n            CRYPTO_RandomBytes(&rnd[0], sizeof(rnd));\r\n            for (int i = 0; i < 5; i++)\r\n            {\r\n                QString frac = QString(\"%1\").arg(rnd[i], 2, 16, QLatin1Char('0')).toUpper();\r\n                auth.apikey.append(frac);\r\n            }\r\n        }\r\n    }\r\n\r\n    QVariantMap map1;\r\n    QVariantMap map2;\r\n    map1[\"username\"] = auth.apikey;\r\n    map2[\"success\"] = map1;\r\n    rsp.list.append(map2);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!found)\r\n    {\r\n        auth.createDate = QDateTime::currentDateTimeUtc();\r\n        auth.lastUseDate = QDateTime::currentDateTimeUtc();\r\n        auth.needSaveDatabase = true;\r\n        apiAuths.push_back(auth);\r\n        queSaveDb(DB_AUTH, DB_SHORT_SAVE_DELAY);\r\n        updateEtag(gwConfigEtag);\r\n        DBG_Printf(DBG_INFO, \"created username: %s, devicetype: %s\\n\", qPrintable(auth.apikey), qPrintable(auth.devicetype));\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_INFO, \"apikey username: %s, devicetype: %s already exists\\n\", qPrintable(auth.apikey), qPrintable(auth.devicetype));\r\n    }\r\n\r\n    rsp.etag = gwConfigEtag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Puts all parameters in a map for later JSON serialization.\r\n */\r\nvoid DeRestPluginPrivate::configToMap(const ApiRequest &req, QVariantMap &map)\r\n{\r\n    QVariantMap whitelist;\r\n    QVariantMap swupdate;\r\n    QVariantMap swupdate2;\r\n    QVariantMap autoinstall;\r\n    QVariantMap bridge;\r\n    QVariantMap devicetypes;\r\n    QVariantMap portalstate;\r\n    QVariantMap internetservices;\r\n    QVariantMap backup;\r\n    QDateTime datetime = QDateTime::currentDateTimeUtc();\r\n    QDateTime localtime = QDateTime::currentDateTime();\r\n\r\n    basicConfigToMap(req, map);\r\n    map[\"ipaddress\"] = gwIPAddress;\r\n    map[\"netmask\"] = gwNetMask;\r\n\r\n    std::vector<ApiAuth>::const_iterator i = apiAuths.begin();\r\n    std::vector<ApiAuth>::const_iterator end = apiAuths.end();\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state == ApiAuth::StateNormal)\r\n        {\r\n            QVariantMap au;\r\n            au[\"last use date\"] = i->lastUseDate.toString(\"yyyy-MM-ddTHH:mm:ss\"); // ISO 8601\r\n            au[\"create date\"] = i->createDate.toString(\"yyyy-MM-ddTHH:mm:ss\"); // ISO 8601\r\n            au[\"name\"] = i->devicetype;\r\n            whitelist[i->apikey] = au;\r\n        }\r\n    }\r\n\r\n    if (req.apiVersion() >= ApiVersion_1_DDEL)\r\n    {\r\n        map[\"permitjoin\"] = static_cast<double>(qMin(gwPermitJoinDuration, 254));\r\n        map[\"permitjoinfull\"] = static_cast<double>(gwPermitJoinDuration);\r\n        map[\"otauactive\"] = isOtauActive();\r\n        map[\"otaustate\"] = (isOtauBusy() ? \"busy\" : (isOtauActive() ? \"idle\" : \"off\"));\r\n        map[\"groupdelay\"] = static_cast<double>(gwGroupSendDelay);\r\n        map[\"discovery\"] = (gwAnnounceInterval > 0);\r\n        map[\"updatechannel\"] = gwUpdateChannel;\r\n        map[\"fwneedupdate\"] = gwFirmwareNeedUpdate;\r\n        map[\"runmode\"] = gwRunMode;\r\n        if (gwFirmwareNeedUpdate)\r\n        {\r\n            map[\"fwversionupdate\"] = gwFirmwareVersionUpdate;\r\n        }\r\n\r\n        switch (fwUpdateState)\r\n        {\r\n        case FW_DisconnectDevice:\r\n        case FW_Update:\r\n        case FW_UpdateWaitFinished:\r\n        { map[QLatin1String(\"fwupdatestate\")] = QLatin1String(\"running\"); }\r\n            break;\r\n\r\n        default:\r\n        { map[QLatin1String(\"fwupdatestate\")] = QLatin1String(\"idle\"); }\r\n            break;\r\n        }\r\n\r\n        map[\"announceurl\"] = gwAnnounceUrl;\r\n        map[\"announceinterval\"] = static_cast<double>(gwAnnounceInterval);\r\n        map[\"swversion\"] = QLatin1String(GW_SW_VERSION);\r\n        map[\"swcommit\"] = QLatin1String(GIT_COMMMIT);\r\n        swupdate[\"version\"] = gwUpdateVersion;\r\n        swupdate[\"updatestate\"] = static_cast<double>(0);\r\n        swupdate[\"url\"] = \"\";\r\n        swupdate[\"text\"] = \"\";\r\n        swupdate[\"notify\"] = false;\r\n        map[\"swupdate\"] = swupdate;\r\n        map[\"port\"] = gwPort;\r\n        // since api version 1.2.1\r\n        map[\"apiversion\"] = QLatin1String(GW_SW_VERSION);\r\n        map[\"system\"] = \"other\";\r\n#ifdef ARCH_ARM\r\n#ifdef Q_OS_LINUX\r\n        map[\"system\"] = \"linux-gw\";\r\n#endif\r\n        map[\"wifi\"] = gwWifi;\r\n        map[\"homebridge\"] = gwHomebridge;\r\n        map[\"homebridgepin\"] = gwHomebridgePin;\r\n        map[\"homebridgeversion\"] = gwHomebridgeVersion;\r\n        map[\"homebridgeupdateversion\"] = gwHomebridgeUpdateVersion;\r\n        map[\"homebridgeupdate\"] = gwHomebridgeUpdate;\r\n#else\r\n        map[\"wifi\"] = QLatin1String(\"not-available\");\r\n        map[\"homebridge\"] = QLatin1String(\"not-available\");\r\n#endif\r\n        map[\"wifiavailable\"] = gwWifiAvailable;\r\n        map[\"wifitype\"] = gwWifiType;\r\n        map[\"wifiname\"] = gwWifiName;\r\n        map[\"wificlientname\"] = gwWifiClientName;\r\n        map[\"wifichannel\"] = gwWifiChannel;\r\n        map[\"wifimgmt\"] = static_cast<double>(gwWifiMgmt);\r\n        map[\"wifiip\"] = gwWifiIp;\r\n//        map[\"wifiappw\"] = gwWifiPw;\r\n//        map[\"wifiappw\"] = QString(); // TODO add secured transfer via PKI\r\n//        map[\"wificlientpw\"] = QString(); // TODO add secured transfer via PKI\r\n    }\r\n    else\r\n    {\r\n        devicetypes[\"bridge\"] = false;\r\n        devicetypes[\"lights\"] = QVariantList();\r\n        devicetypes[\"sensors\"] = QVariantList();\r\n        swupdate[\"devicetypes\"] = devicetypes;\r\n        swupdate[\"updatestate\"] = static_cast<double>(0);\r\n        swupdate[\"checkforupdate\"] = false;\r\n        swupdate[\"url\"] = \"\";\r\n        swupdate[\"text\"] = \"\";\r\n        swupdate[\"notify\"] = false;\r\n        map[\"portalconnection\"] = QLatin1String(\"disconnected\");\r\n        portalstate[\"signedon\"] = false;\r\n        portalstate[\"incoming\"] = false;\r\n        portalstate[\"outgoing\"] = false;\r\n        portalstate[\"communication\"] = QLatin1String(\"disconnected\");\r\n        map[\"portalstate\"] = portalstate;\r\n        internetservices[\"internet\"] = QLatin1String(\"connected\");\r\n        internetservices[\"remoteaccess\"] = QLatin1String(\"disconnected\");\r\n        internetservices[\"time\"] = QLatin1String(\"connected\");\r\n        internetservices[\"swupdate\"] = QLatin1String(\"connected\");\r\n        map[\"internetservices\"] = internetservices;\r\n        backup[\"status\"] = QLatin1String(\"idle\");\r\n        backup[\"errorcode\"] = 0;\r\n        map[\"backup\"] = backup;\r\n        map[\"swupdate\"] = swupdate;\r\n    }\r\n\r\n    bridge[\"state\"] = gwSwUpdateState;\r\n    bridge[\"lastinstall\"] = gwUpdateDate;\r\n    swupdate2[\"bridge\"] = bridge;\r\n    swupdate2[\"checkforupdate\"] = false;\r\n    swupdate2[\"state\"] = gwSwUpdateState;\r\n    autoinstall[\"updatetime\"] = \"\";\r\n    autoinstall[\"on\"] = false;\r\n    swupdate2[\"autoinstall\"] = autoinstall;\r\n    swupdate2[\"lastchange\"] = \"\";\r\n    map[\"swupdate2\"] = swupdate2;\r\n\r\n    map[\"fwversion\"] = gwFirmwareVersion;\r\n    map[\"rfconnected\"] = gwRfConnected;\r\n    map[\"uuid\"] = gwUuid;\r\n    if (apsCtrl)\r\n    {\r\n        map[\"zigbeechannel\"] = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\r\n        map[\"panid\"] = apsCtrl->getParameter(deCONZ::ParamPANID);\r\n    }\r\n    else\r\n    {\r\n        map[\"zigbeechannel\"] = static_cast<double>(gwZigbeeChannel);\r\n    }\r\n\r\n    if (gwConfig.contains(QLatin1String(\"ntp\")))\r\n    {\r\n        map[\"ntp\"] = gwConfig[\"ntp\"];\r\n    }\r\n\r\n    map[\"dhcp\"] = true; // dummy\r\n    map[\"proxyaddress\"] = gwProxyAddress;\r\n    map[\"proxyport\"] = static_cast<double>(gwProxyPort);\r\n    map[\"UTC\"] = datetime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\")); // ISO 8601\r\n    map[\"localtime\"] = localtime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\")); // ISO 8601\r\n    map[\"timezone\"] = gwTimezone;\r\n    map[\"networkopenduration\"] = gwNetworkOpenDuration;\r\n    map[\"timeformat\"] = gwTimeFormat;\r\n    map[\"whitelist\"] = whitelist;\r\n    map[\"lightlastseeninterval\"] = gwLightLastSeenInterval;\r\n    map[\"linkbutton\"] = gwLinkButton;\r\n    map[\"portalservices\"] = false;\r\n    map[\"websocketport\"] = static_cast<double>(gwConfig[\"websocketport\"].toUInt());\r\n    map[\"websocketnotifyall\"] = gwWebSocketNotifyAll;\r\n    map[\"disablePermitJoinAutoOff\"] = gwdisablePermitJoinAutoOff;\r\n\r\n    QStringList ipv4 = gwIPAddress.split(\".\");\r\n\r\n    if (ipv4.size() == 4)\r\n    {\r\n        ipv4.removeLast();\r\n        ipv4.append(\"1\");\r\n        map[\"gateway\"] = ipv4.join(\".\");\r\n    }\r\n    else\r\n    {\r\n        map[\"gateway\"] = \"0.0.0.0\";\r\n    }\r\n}\r\n\r\n/*! Puts all parameters in a map for later JSON serialization.\r\n */\r\nvoid DeRestPluginPrivate::basicConfigToMap(const ApiRequest &req, QVariantMap &map)\r\n{\r\n    map[\"name\"] = gwName;\r\n    if (req.mode == ApiModeNormal)\r\n    {\r\n        map[\"modelid\"] = QLatin1String(\"deCONZ\");\r\n        const QStringList versions = QString(GW_SW_VERSION).split('.');\r\n        const QString swversion = QString(\"%1.%2.%3\").arg(versions[0].toInt()).arg(versions[1].toInt()).arg(versions[2].toInt());\r\n        map[\"swversion\"] = swversion;\r\n        map[\"apiversion\"] = QString(GW_API_VERSION);\r\n        map[\"datastoreversion\"] = QLatin1String(\"93\");\r\n    }\r\n    else\r\n    {\r\n        map[\"modelid\"] = QLatin1String(\"BSB002\");\r\n        map[\"swversion\"] = QLatin1String(\"1942135050\");\r\n        map[\"apiversion\"] = QLatin1String(\"1.42.0\");\r\n        map[\"datastoreversion\"] = QLatin1String(\"98\");\r\n    }\r\n    map[\"mac\"] = gwMAC;\r\n    map[\"bridgeid\"] = gwBridgeId;\r\n    map[\"factorynew\"] = false;\r\n    map[\"replacesbridgeid\"] = QVariant();\r\n    map[\"starterkitid\"] = QLatin1String(\"\");\r\n\r\n    if (!apsCtrl->getParameter(deCONZ::ParamDeviceName).isEmpty())\r\n    {\r\n        map[\"devicename\"] = apsCtrl->getParameter(deCONZ::ParamDeviceName);\r\n    }\r\n}\r\n\r\n/*! GET /api/<apikey>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getFullState(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    checkRfConnectState();\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (gwConfigEtag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    QVariantMap lightsMap;\r\n    QVariantMap groupsMap;\r\n    QVariantMap schedulesMap;\r\n    QVariantMap scenesMap;\r\n    QVariantMap sensorsMap;\r\n    QVariantMap rulesMap;\r\n    QVariantMap configMap;\r\n    QVariantMap resourcelinksMap;\r\n\r\n    // lights\r\n    {\r\n        std::vector<LightNode>::const_iterator i = nodes.begin();\r\n        std::vector<LightNode>::const_iterator end = nodes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->state() == LightNode::StateDeleted)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            QVariantMap map;\r\n            if (lightToMap(req, &(*i), map))\r\n            {\r\n                lightsMap[i->id()] = map;\r\n            }\r\n        }\r\n    }\r\n\r\n    // groups\r\n    {\r\n        std::vector<Group>::const_iterator i = groups.begin();\r\n        std::vector<Group>::const_iterator end = groups.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            // ignore deleted groups\r\n            if (i->state() == Group::StateDeleted || i->state() == Group::StateDeleteFromDB)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (i->address() != gwGroup0) // don't return special group 0\r\n            {\r\n                QVariantMap map;\r\n                if (groupToMap(req, &(*i), map))\r\n                {\r\n                    groupsMap[i->id()] = map;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // schedules\r\n    {\r\n        std::vector<Schedule>::const_iterator i = schedules.begin();\r\n        std::vector<Schedule>::const_iterator end = schedules.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->state == Schedule::StateDeleted)\r\n            {\r\n                continue;\r\n            }\r\n            schedulesMap[i->id] = i->jsonMap;\r\n        }\r\n    }\r\n\r\n    // sensors\r\n    {\r\n        std::vector<Sensor>::const_iterator i = sensors.begin();\r\n        std::vector<Sensor>::const_iterator end = sensors.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->deletedState() == Sensor::StateDeleted)\r\n            {\r\n                continue;\r\n            }\r\n            QVariantMap map;\r\n            if (sensorToMap(&(*i), map, req))\r\n            {\r\n                sensorsMap[i->id()] = map;\r\n            }\r\n        }\r\n    }\r\n\r\n    // resourcelinks\r\n    {\r\n        std::vector<Resourcelinks>::const_iterator i = resourcelinks.begin();\r\n        std::vector<Resourcelinks>::const_iterator end = resourcelinks.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->state != Resourcelinks::StateNormal)\r\n            {\r\n                continue;\r\n            }\r\n            resourcelinksMap[i->id] = i->data;\r\n        }\r\n    }\r\n\r\n    // rules\r\n    {\r\n        std::vector<Rule>::const_iterator i = rules.begin();\r\n        std::vector<Rule>::const_iterator end = rules.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->state() == Rule::StateDeleted)\r\n            {\r\n                continue;\r\n            }\r\n            QVariantMap map;\r\n            if (ruleToMap(&(*i), map))\r\n            {\r\n                rulesMap[i->id()] = map;\r\n            }\r\n        }\r\n    }\r\n\r\n    // alarm systems\r\n    rsp.map[QLatin1String(\"alarmsystems\")] = AS_AlarmSystemsToMap(*alarmSystems);\r\n\r\n    configToMap(req, configMap);\r\n\r\n    rsp.map[\"lights\"] = lightsMap;\r\n    rsp.map[\"groups\"] = groupsMap;\r\n    rsp.map[\"schedules\"] = schedulesMap;\r\n    rsp.map[\"scenes\"] = scenesMap;\r\n    rsp.map[\"sensors\"] = sensorsMap;\r\n    rsp.map[\"rules\"] = rulesMap;\r\n    rsp.map[\"config\"] = configMap;\r\n    rsp.map[\"resourcelinks\"] = resourcelinksMap;\r\n    rsp.etag = gwConfigEtag;\r\n    rsp.httpStatus = HttpStatusOk;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/config\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    checkRfConnectState();\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (gwConfigEtag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    configToMap(req, rsp.map);\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = gwConfigEtag;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/config\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getBasicConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    checkRfConnectState();\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (gwConfigEtag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n    basicConfigToMap(req, rsp.map);\r\n\r\n    // include devicename attribute in web based requests\r\n    if (!apsCtrl->getParameter(deCONZ::ParamDeviceName).isEmpty() && req.hdr.hasKey(QLatin1String(\"User-Agent\")))\r\n    {\r\n        const QString ua = req.hdr.value(QLatin1String(\"User-Agent\"));\r\n        if (ua.startsWith(QLatin1String(\"Mozilla\"))) // all browser UA start with Mozilla/5.0\r\n        {\r\n            rsp.map[\"devicename\"] = apsCtrl->getParameter(deCONZ::ParamDeviceName);\r\n        }\r\n    }\r\n\r\n    // add more details if this was requested from discover page\r\n    // this should speedup multi-gateway discovery\r\n    if (!gateways.empty())\r\n    {\r\n        // restrict info TODO more limited \"Origin\"\r\n        QString referer = req.hdr.value(QLatin1String(\"Referer\"));\r\n        if (referer.contains(QLatin1String(\"js/scanner-worker.js\")))\r\n        {\r\n            QVariantList ls;\r\n            for (const Gateway *gw : gateways)\r\n            {\r\n                DBG_Assert(gw);\r\n                if (gw)\r\n                {\r\n                    QVariantMap g;\r\n                    g[\"host\"] = gw->address().toString();\r\n                    g[\"port\"] = gw->port();\r\n                    ls.push_back(g);\r\n                }\r\n            }\r\n\r\n            if (!ls.empty())\r\n            {\r\n                rsp.map[\"gateways\"] = ls;\r\n            }\r\n        }\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = gwConfigEtag;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/config/zigbee\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getZigbeeConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    getZigbeeConfigDb(rsp.list);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    //rsp.etag = gwConfigEtag;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/zigbee/<id>\r\n\r\n    Activates a certain known zigbee configuration.\r\n\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::putZigbeeConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    getZigbeeConfigDb(rsp.list);\r\n\r\n    QVariantMap cfg;\r\n    const QString id = req.path[4];\r\n    for (const QVariant &c : rsp.list)\r\n    {\r\n        if (c.toMap().value(QLatin1String(\"id\")) == id)\r\n        {\r\n            cfg = c.toMap();\r\n            break;\r\n        }\r\n    }\r\n\r\n    const std::vector<const char*> requiredFields = {\r\n        \"deviceType\", \"panId\", \"extPanId\", \"apsUseExtPanId\", \"macAddress\", \"staticNwkAddress\",\r\n        \"nwkAddress\", \"curChannel\", \"tcAddress\", \"networkKey\", \"nwkUpdateId\"\r\n    };\r\n\r\n    bool ok = true;\r\n\r\n    for (const auto *key : requiredFields)\r\n    {\r\n        if (!cfg.contains(QLatin1String(key)))\r\n        {\r\n            ok = false;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    quint8 deviceType = ok ? cfg[\"deviceType\"].toUInt(&ok) : 0;\r\n    if (ok && deviceType != deCONZ::Coordinator) { ok = false; } // only coordinator supported currently\r\n\r\n    quint16 panId =  ok ? cfg[\"panId\"].toString().toUShort(&ok, 16) : 0;\r\n    if (ok && panId == 0) { ok = false; }\r\n\r\n    quint64 extPanId =  ok ? cfg[\"extPanId\"].toString().toULongLong(&ok, 16) : 0;\r\n    if (ok && extPanId == 0) { ok = false; }\r\n\r\n    quint64 apsUseExtPanId = ok ? cfg[\"apsUseExtPanId\"].toString().toULongLong(&ok, 16) : 1;\r\n    if (ok && apsUseExtPanId != 0) { ok = false; } // must be zero\r\n\r\n    quint64 curMacAddress = apsCtrl->getParameter(deCONZ::ParamMacAddress);\r\n    quint64 macAddress =  ok ? cfg[\"macAddress\"].toString().toULongLong(&ok, 16) : 0;\r\n    if (ok && macAddress == 0) { ok = false; }\r\n\r\n    quint8 staticNwkAddress = cfg[\"staticNwkAddress\"].toBool() ? 1 : 0;\r\n    quint16 nwkAddress = cfg[\"nwkAddress\"].toString().toUInt(&ok, 16);\r\n    if (ok && nwkAddress != 0x0000) { ok = false; } // coordinator\r\n\r\n    //map[\"channelMask\"] = channelMask;\r\n    quint8 curChannel = ok ? cfg[\"curChannel\"].toUInt(&ok) : 0;\r\n    if (ok && (curChannel < 11 || curChannel > 26)) { ok = false; }\r\n\r\n    quint8 securityMode = 3; // High - No Master but TC Link key\r\n\r\n    quint64 tcAddress =  ok ? cfg[\"tcAddress\"].toString().toULongLong(&ok, 16) : 0;\r\n    if (ok && tcAddress != macAddress)\r\n    {\r\n        tcAddress = macAddress; // auto correct\r\n    }\r\n    QByteArray nwkKey = QByteArray::fromHex(cfg[\"networkKey\"].toByteArray());\r\n\r\n    cfg[\"tcLinkKey\"] = QLatin1String(\"5a6967426565416c6c69616e63653039\"); // HA default TC link key\r\n\r\n    QByteArray tcLinkKey = QByteArray::fromHex(cfg[\"tcLinkKey\"].toByteArray());\r\n\r\n    quint8 nwkUpdateId = ok ? cfg[\"nwkUpdateId\"].toUInt(&ok) : 0;\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    apsCtrl->setParameter(deCONZ::ParamDeviceType, deviceType);\r\n    apsCtrl->setParameter(deCONZ::ParamPredefinedPanId, 1);\r\n    apsCtrl->setParameter(deCONZ::ParamPANID, panId);\r\n    apsCtrl->setParameter(deCONZ::ParamExtendedPANID, extPanId);\r\n    apsCtrl->setParameter(deCONZ::ParamApsUseExtendedPANID, apsUseExtPanId);\r\n    if (curMacAddress != macAddress)\r\n    {\r\n        apsCtrl->setParameter(deCONZ::ParamCustomMacAddress, 1);\r\n    }\r\n    apsCtrl->setParameter(deCONZ::ParamMacAddress, macAddress);\r\n    apsCtrl->setParameter(deCONZ::ParamStaticNwkAddress, staticNwkAddress);\r\n    apsCtrl->setParameter(deCONZ::ParamNwkAddress, nwkAddress);\r\n\r\n    // channelMask\r\n    apsCtrl->setParameter(deCONZ::ParamCurrentChannel, curChannel);\r\n    apsCtrl->setParameter(deCONZ::ParamSecurityMode, securityMode);\r\n    apsCtrl->setParameter(deCONZ::ParamTrustCenterAddress, tcAddress);\r\n    apsCtrl->setParameter(deCONZ::ParamNetworkKey, nwkKey);\r\n    apsCtrl->setParameter(deCONZ::ParamTrustCenterLinkKey, tcLinkKey);\r\n    apsCtrl->setParameter(deCONZ::ParamNetworkUpdateId, nwkUpdateId);\r\n\r\n    // HA endpoint\r\n    QVariantMap endpoint1;\r\n    endpoint1[\"endpoint\"] = QLatin1String(\"0x01\");\r\n    endpoint1[\"profileId\"] = QLatin1String(\"0x0104\");\r\n    endpoint1[\"deviceId\"] = QLatin1String(\"0x05\");\r\n    endpoint1[\"deviceVersion\"] = QLatin1String(\"0x01\");\r\n    endpoint1[\"inClusters\"] = QVariantList({\"0x0000\" , \"0x000A\", \"0x0019\"});\r\n    endpoint1[\"outClusters\"] = QVariantList({\"0x0500\"});\r\n    endpoint1[\"index\"] = static_cast<double>(0);\r\n\r\n    // green power endpoint\r\n    QVariantMap endpoint2;\r\n    endpoint2[\"endpoint\"] = QLatin1String(\"0xf2\");\r\n    endpoint2[\"profileId\"] = QLatin1String(\"0xA1E0\");\r\n    endpoint2[\"deviceId\"] = QLatin1String(\"0x0064\");\r\n    endpoint2[\"deviceVersion\"] = QLatin1String(\"0x01\");\r\n    endpoint2[\"inClusters\"] = QVariantList();\r\n    endpoint2[\"outClusters\"] = QVariantList({ \"0x0021\"});\r\n    endpoint2[\"index\"] = static_cast<double>(1);\r\n\r\n    apsCtrl->setParameter(deCONZ::ParamHAEndpoint, endpoint1);\r\n    apsCtrl->setParameter(deCONZ::ParamHAEndpoint, endpoint2);\r\n\r\n    needRestartApp = true;\r\n    QTimer::singleShot(SET_ENDPOINTCONFIG_DURATION, this, SLOT(restartAppTimerFired()));\r\n\r\n    if (gwZigbeeChannel != curChannel)\r\n    {\r\n        gwZigbeeChannel = curChannel;\r\n        saveDatabaseItems |= DB_CONFIG;\r\n    }\r\n    updateZigBeeConfigDb(); // put new entry in database as latest valid configuration\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n\r\n    rsp.list.clear();\r\n\r\n    rspItemState[QString(\"/config/zigbee/%1\").arg(id)] = \"restoring\";\r\n    rspItem[\"success\"] = rspItemState;\r\n\r\n    rsp.list.append(rspItem);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/challenge\r\n    Creates a new authentication challenge which should be used as HMAC-Sha256(challenge, install code).\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getChallenge(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    QDateTime now = QDateTime::currentDateTime();\r\n\r\n    if (!apsCtrl || (gwLastChallenge.isValid() && gwLastChallenge.secsTo(now) < 5))\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/api/challenge\"), QString(\"too many requests, try again later\")));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    QByteArray challange(64, '\\0');\r\n    CRYPTO_RandomBytes((unsigned char*)challange.data(), challange.size());\r\n\r\n    gwLastChallenge = now;\r\n    gwChallenge = QCryptographicHash::hash(challange, QCryptographicHash::Sha256).toHex();\r\n    rsp.map[\"challenge\"] = gwChallenge;\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/config\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::modifyConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    bool changed = false;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    DBG_Assert(apsCtrl);\r\n\r\n    if (!apsCtrl)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, \"\", \"body contains invalid JSON\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (map.contains(\"name\")) // optional\r\n    {\r\n        if ((map[\"name\"].type() != QVariant::String) ||\r\n            (map[\"name\"].toString().length() > 16)) // TODO allow longer names\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/name\"), QString(\"invalid value, %1, for parameter, name\").arg(map[\"name\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        QString name = map[\"name\"].toString();\r\n\r\n        if (gwName != name)\r\n        {\r\n            gwName = name;\r\n\r\n            if (gwName.isEmpty())\r\n            {\r\n                gwName = GW_DEFAULT_NAME;\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/name\"] = gwName;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n\r\n        // sync database\r\n        gwConfig[\"name\"] = gwName;\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    if (map.contains(\"rfconnected\")) // optional\r\n    {\r\n        if (map[\"rfconnected\"].type() != QVariant::Bool)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/rfconnected\"), QString(\"invalid value, %1, for parameter, rfconnected\").arg(map[\"rfconnected\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        // don't change network state if touchlink is busy\r\n        if (touchlinkState != TL_Idle)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/config/rfconnected\"), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        bool rfconnected = map[\"rfconnected\"].toBool();\r\n\r\n        if (gwRfConnected != rfconnected)\r\n        {\r\n            gwRfConnected = rfconnected;\r\n            changed = true;\r\n        }\r\n\r\n        // also check if persistent settings changed\r\n        if (gwRfConnectedExpected != rfconnected)\r\n        {\r\n            gwRfConnectedExpected = rfconnected;\r\n            queSaveDb(DB_CONFIG, DB_LONG_SAVE_DELAY);\r\n        }\r\n\r\n        if (apsCtrl->setNetworkState(gwRfConnected ? deCONZ::InNetwork : deCONZ::NotInNetwork) == deCONZ::Success)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[\"/config/rfconnected\"] = gwRfConnected;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/config/rfconnected\"), QString(\"Error, rfconnected, is not modifiable. Device is set to off.\")));\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"updatechannel\")) // optional\r\n    {\r\n        QString updatechannel = map[\"updatechannel\"].toString();\r\n\r\n        if ((map[\"updatechannel\"].type() != QVariant::String) ||\r\n               ! ((updatechannel == \"stable\") ||\r\n                  (updatechannel == \"alpha\") ||\r\n                  (updatechannel == \"beta\")))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/updatechannel\"), QString(\"invalid value, %1, for parameter, updatechannel\").arg(map[\"updatechannel\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwUpdateChannel != updatechannel)\r\n        {\r\n            gwUpdateChannel = updatechannel;\r\n            gwUpdateVersion = GW_SW_VERSION; // will be replaced by discovery handler\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/updatechannel\"] = updatechannel;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"permitjoin\")) // optional\r\n    {\r\n        int seconds = map[\"permitjoin\"].toInt(&ok);\r\n        if (!ok || !(seconds >= 0))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/permitjoin\"), QString(\"invalid value, %1, for parameter, permitjoin\").arg(map[\"permitjoin\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (seconds == 0)\r\n        {\r\n            // workaround that only initial caller can disable permit join\r\n            if (req.apikey() == permitJoinApiKey)\r\n            {\r\n                gwPermitJoinDuration = 0;\r\n                changed = true;\r\n            }\r\n        }\r\n        else if (gwPermitJoinDuration != seconds)\r\n        {\r\n            permitJoinApiKey = req.apikey();\r\n            gwPermitJoinDuration = seconds;\r\n            changed = true;\r\n        }\r\n\r\n        if (seconds > 0)\r\n        {\r\n            startSearchLights();\r\n            startSearchSensors();\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/permitjoin\"] = static_cast<double>(seconds);\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"groupdelay\")) // optional\r\n    {\r\n        int milliseconds = map[\"groupdelay\"].toInt(&ok);\r\n        if (!ok || !((milliseconds >= 0) && (milliseconds <= MAX_GROUP_SEND_DELAY)))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/groupdelay\"), QString(\"invalid value, %1, for parameter, groupdelay\").arg(map[\"groupdelay\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwGroupSendDelay != milliseconds)\r\n        {\r\n            gwGroupSendDelay = milliseconds;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            changed = true;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/groupdelay\"] = static_cast<double>(milliseconds);\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"rgbwdisplay\")) // optional\r\n    {\r\n        QString rgbwDisplay = map[\"rgbwdisplay\"].toString();\r\n        if (rgbwDisplay != \"1\" && rgbwDisplay != \"2\")\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/rgbwdisplay\"), QString(\"invalid value, %1, for parameter, rgbwdisplay\").arg(map[\"rgbwdisplay\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwRgbwDisplay != rgbwDisplay)\r\n        {\r\n            gwRgbwDisplay = rgbwDisplay;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            changed = true;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/rgbwdisplay\"] = rgbwDisplay;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"otauactive\")) // optional\r\n    {\r\n        bool otauActive = map[\"otauactive\"].toBool();\r\n\r\n        if (map[\"otauactive\"].type() != QVariant::Bool)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/otauactive\"), QString(\"invalid value, %1, for parameter, otauactive\").arg(map[\"otauactive\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (isOtauActive() != otauActive)\r\n        {\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        apsCtrl->setParameter(deCONZ::ParamOtauActive, otauActive ? 1 : 0);\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/otauactive\"] = otauActive;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"homebridgeupdate\")) // optional\r\n    {\r\n        bool homebridgeUpdate = map[\"homebridgeupdate\"].toBool();\r\n\r\n        if (map[\"homebridgeupdate\"].type() != QVariant::Bool)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/homebridgeupdate\"), QString(\"invalid value, %1, for parameter, homebridgeupdate\").arg(map[\"homebridgeupdate\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwHomebridgeUpdate != homebridgeUpdate)\r\n        {\r\n            gwHomebridgeUpdate = homebridgeUpdate;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/homebridgeupdate\"] = homebridgeUpdate;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"discovery\")) // optional\r\n    {\r\n        bool discovery = map[\"discovery\"].toBool();\r\n\r\n        if (map[\"discovery\"].type() != QVariant::Bool)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/discovery\"), QString(\"invalid value, %1, for parameter, discovery\").arg(map[\"discovery\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        int minutes = gwAnnounceInterval;\r\n\r\n        if (discovery)\r\n        {\r\n            setInternetDiscoveryInterval(ANNOUNCE_INTERVAL);\r\n        }\r\n        else\r\n        {\r\n            setInternetDiscoveryInterval(0);\r\n        }\r\n\r\n        if (minutes != gwAnnounceInterval)\r\n        {\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            changed = true;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/discovery\"] = discovery;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"unlock\")) // optional\r\n    {\r\n        uint seconds = map[\"unlock\"].toUInt(&ok);\r\n\r\n        if (!ok || (seconds > MAX_UNLOCK_GATEWAY_TIME))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/unlock\"), QString(\"invalid value, %1, for parameter, unlock\").arg(map[\"unlock\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        lockGatewayTimer->stop();\r\n        changed = true;\r\n\r\n        if (seconds > 0)\r\n        {\r\n            gwLinkButton = true;\r\n            lockGatewayTimer->start(seconds * 1000);\r\n            DBG_Printf(DBG_INFO, \"gateway unlocked\\n\");\r\n        }\r\n        else\r\n        {\r\n            gwLinkButton = false;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/unlock\"] = static_cast<double>(seconds);\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"zigbeechannel\")) // optional\r\n    {\r\n        uint zigbeechannel = map[\"zigbeechannel\"].toUInt(&ok);\r\n\r\n        if (!ok || ((zigbeechannel != 0) && (zigbeechannel != 11) && (zigbeechannel != 15) && (zigbeechannel != 20) && (zigbeechannel != 25)))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/zigbeechannel\"), QString(\"invalid value, %1, for parameter, zigbeechannel\").arg(map[\"zigbeechannel\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n            if (startChannelChange(zigbeechannel))\r\n            {\r\n                changed = true;\r\n            }\r\n            else\r\n            {\r\n                // not connected\r\n            }\r\n\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/zigbeechannel\"] = static_cast<double>(zigbeechannel);\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"networkopenduration\")) // optional\r\n    {\r\n        int seconds = map[\"networkopenduration\"].toInt(&ok);\r\n\r\n        if (!ok || seconds < 0 || seconds > UINT16_MAX)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/networkopenduration\"), QString(\"invalid value, %1, for parameter, networkopenduration\").arg(map[\"networkopenduration\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwNetworkOpenDuration != seconds)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"set gwNetworkOpenDuration to: %u\\n\", seconds);\r\n            gwNetworkOpenDuration = static_cast<quint16>(seconds);\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/networkopenduration\"] = static_cast<double>(seconds);\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"timezone\")) // optional\r\n    {\r\n        QString timezone = map[\"timezone\"].toString();\r\n\r\n        if (map[\"timezone\"].type() != QVariant::String)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/timezone\"), QString(\"invalid value, %1, for parameter, timezone\").arg(map[\"timezone\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwTimezone != timezone)\r\n        {\r\n            gwTimezone = timezone;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            changed = true;\r\n#ifdef ARCH_ARM\r\n            const QString tzFilespec = QString(\":\") + timezone;\r\n            int rc = setenv(\"TZ\", qPrintable(tzFilespec), 1);\r\n            tzset();\r\n\r\n            //also set zoneinfo on RPI\r\n            //char param1[100];\r\n            //strcpy(param1, \"/usr/share/zoneinfo/\");\r\n            //strcpy(param1, qPrintable(timezone));\r\n\r\n            //if (symlink(param1, \"/etc/localtime\") == -1)\r\n            //{\r\n                //DBG_Printf(DBG_INFO, \"Create symlink to timezone failed with errno: %s\\n\", strerror(errno));\r\n                //rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/config/timezone\"), QString(\"Link timezone failed with errno: %1\\n\").arg(strerror(errno))));\r\n                //rsp.httpStatus = HttpStatusServiceUnavailable;\r\n                //return REQ_READY_SEND;\r\n            //}\r\n\r\n            if (rc != 0)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/config/timezone\"), QString(\"Error setting timezone\")));\r\n                rsp.httpStatus = HttpStatusServiceUnavailable;\r\n                return REQ_READY_SEND;\r\n            }\r\n#endif\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/timezone\"] = timezone;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    // old versions used lower case utc, support both styles\r\n    if (map.contains(\"UTC\") && !map.contains(\"utc\"))\r\n    {\r\n        map[\"utc\"] = map[\"UTC\"];\r\n    }\r\n\r\n    if (map.contains(\"utc\")) // optional\r\n    {\r\n        bool error = false;\r\n        if ((map[\"utc\"].type() != QVariant::String))\r\n        {\r\n            error = true;\r\n        }\r\n        else\r\n        {\r\n            QDateTime utc = QDateTime::fromString(map[\"utc\"].toString(),\"yyyy-MM-ddTHH:mm:ss\");\r\n            if (!utc.isValid() || map[\"utc\"].toString().length() != 19)\r\n            {\r\n                error = true;\r\n            }\r\n        }\r\n\r\n        if (error)\r\n        {\r\n            if (map.contains(\"UTC\"))\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/UTC\"), QString(\"invalid value, %1, for parameter, UTC\").arg(map[\"UTC\"].toString())));\r\n            }\r\n            else if (map.contains(\"utc\"))\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/utc\"), QString(\"invalid value, %1, for parameter, utc\").arg(map[\"utc\"].toString())));\r\n            }\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n#ifdef ARCH_ARM\r\n        int ret = 0;\r\n        std::string date = map[\"utc\"].toString().toStdString();\r\n\r\n        time_t mytime = time(0);\r\n        struct tm* tm_ptr = gmtime(&mytime); // gmtime instead localtime\r\n\r\n        if (tm_ptr)\r\n        {\r\n            tm_ptr->tm_year = atoi(date.substr(0,4).c_str()) - 1900;\r\n            tm_ptr->tm_mon  = atoi(date.substr(5,2).c_str()) - 1;\r\n            tm_ptr->tm_mday = atoi(date.substr(8,2).c_str());\r\n            tm_ptr->tm_hour  = atoi(date.substr(11,2).c_str());\r\n            tm_ptr->tm_min  = atoi(date.substr(14,2).c_str());\r\n            tm_ptr->tm_sec  = atoi(date.substr(17,2).c_str());\r\n\r\n            const struct timeval tv = {mktime(tm_ptr), 0};\r\n            ret = settimeofday(&tv, NULL);\r\n        }\r\n\r\n        if (ret != 0)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/config/utc\"), QString(\"Error setting date and time\")));\r\n            rsp.httpStatus = HttpStatusServiceUnavailable;\r\n            return REQ_READY_SEND;\r\n        }\r\n#endif\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/utc\"] = map[\"utc\"];\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n\r\n    }\r\n\r\n    if (map.contains(\"localtime\")) // optional\r\n    {\r\n        bool error = false;\r\n        if ((map[\"localtime\"].type() != QVariant::String))\r\n        {\r\n            error = true;\r\n        }\r\n        else\r\n        {\r\n            QDateTime localtime = QDateTime::fromString(map[\"localtime\"].toString(),\"yyyy-MM-ddTHH:mm:ss\");\r\n            if (!localtime.isValid() || map[\"localtime\"].toString().length() != 19)\r\n            {\r\n                error = true;\r\n            }\r\n        }\r\n\r\n        if (error)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/localtime\"), QString(\"invalid value, %1, for parameter, localtime\").arg(map[\"localtime\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n#ifdef ARCH_ARM\r\n        int ret = 0;\r\n        std::string date = map[\"localtime\"].toString().toStdString();\r\n\r\n        time_t mytime = time(0);\r\n        struct tm* tm_ptr = localtime(&mytime);\r\n        if (tm_ptr)\r\n        {\r\n            tm_ptr->tm_year = atoi(date.substr(0,4).c_str()) - 1900;\r\n            tm_ptr->tm_mon  = atoi(date.substr(5,2).c_str()) - 1;\r\n            tm_ptr->tm_mday = atoi(date.substr(8,2).c_str());\r\n            tm_ptr->tm_hour  = atoi(date.substr(11,2).c_str());\r\n            tm_ptr->tm_min  = atoi(date.substr(14,2).c_str());\r\n            tm_ptr->tm_sec  = atoi(date.substr(17,2).c_str());\r\n\r\n            const struct timeval tv = {mktime(tm_ptr), 0};\r\n            ret = settimeofday(&tv, NULL);\r\n        }\r\n\r\n        if (ret != 0)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/config/localtime\"), QString(\"Error setting date and time\")));\r\n            rsp.httpStatus = HttpStatusServiceUnavailable;\r\n            return REQ_READY_SEND;\r\n        }\r\n#endif\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/localtime\"] = map[\"localtime\"];\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n\r\n    }\r\n\r\n    if (map.contains(\"timeformat\")) // optional\r\n    {\r\n        QString timeFormat = map[\"timeformat\"].toString();\r\n\r\n        if ((map[\"timeformat\"].type() != QVariant::String) ||\r\n               !((timeFormat == \"12h\") || (timeFormat == \"24h\"))\r\n           )\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/timeformat\"), QString(\"invalid value, %1, for parameter, timeformat\").arg(map[\"timeformat\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwTimeFormat != timeFormat)\r\n        {\r\n            gwTimeFormat = timeFormat;\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/timeformat\"] = timeFormat;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"websocketnotifyall\")) // optional\r\n    {\r\n        bool notifyAll = map[\"websocketnotifyall\"].toBool();\r\n\r\n        if (gwWebSocketNotifyAll != notifyAll)\r\n        {\r\n            gwWebSocketNotifyAll = notifyAll;\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/websocketnotifyall\"] = notifyAll;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (map.contains(\"disablePermitJoinAutoOff\")) // optional\r\n    {\r\n        bool v = map[\"disablePermitJoinAutoOff\"].toBool();\r\n\r\n        if (gwdisablePermitJoinAutoOff != v)\r\n        {\r\n            gwdisablePermitJoinAutoOff = v;\r\n            changed = true;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        }\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/disablePermitJoinAutoOff\"] = v;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n    if (map.contains(\"lightlastseeninterval\")) // optional\r\n    {\r\n        int lightLastSeen = map[\"lightlastseeninterval\"].toInt(&ok);\r\n        if (!ok || lightLastSeen <= 0 || lightLastSeen > 65535)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/lightlastseeninterval\"), QString(\"invalid value, %1, for parameter, lightlastseeninterval\").arg(map[\"lightlastseeninterval\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwLightLastSeenInterval != lightLastSeen)\r\n        {\r\n            gwLightLastSeenInterval = lightLastSeen;\r\n            queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n            changed = true;\r\n        }\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/lightlastseeninterval\"] = lightLastSeen;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (changed)\r\n    {\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n\r\n    rsp.etag = gwConfigEtag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/config/whitelist/<username2>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::deleteUser(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString username2 = req.path[4];\r\n\r\n    std::vector<ApiAuth>::iterator i = apiAuths.begin();\r\n    std::vector<ApiAuth>::iterator end = apiAuths.end();\r\n\r\n    // TODO compare error not found on hue bridge\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (username2 == i->apikey && i->state == ApiAuth::StateNormal)\r\n        {\r\n            i->needSaveDatabase = true;\r\n            i->state = ApiAuth::StateDeleted;\r\n            queSaveDb(DB_AUTH, DB_LONG_SAVE_DELAY);\r\n\r\n            QVariantMap rspItem;\r\n            rspItem[\"success\"] = QString(\"/config/whitelist/%1 deleted.\").arg(username2);\r\n            rsp.list.append(rspItem);\r\n            rsp.httpStatus = HttpStatusOk;\r\n\r\n            updateEtag(gwConfigEtag);\r\n\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    rsp.str = \"[]\"; // empty\r\n    rsp.httpStatus = HttpStatusOk;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/update\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::updateSoftware(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    rsp.httpStatus = HttpStatusOk;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    if (gwSwUpdateState != swUpdateState.transferring)\r\n    {\r\n        gwSwUpdateState = swUpdateState.transferring;\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n        pollSwUpdateStateTimer->start(5000);\r\n    }\r\n\r\n    rspItemState[\"/config/update\"] = gwUpdateVersion;\r\n#ifdef ARCH_ARM\r\n    rspItemState[\"/config/swupdate2/state\"] = gwSwUpdateState;\r\n#endif\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/restart\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::restartGateway(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    rsp.httpStatus = HttpStatusOk;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/restart\"] = true;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n#ifdef ARCH_ARM\r\n        openDb();\r\n        saveDb();\r\n        closeDb();\r\n\r\n        QTimer *restartTimer = new QTimer(this);\r\n        restartTimer->setSingleShot(true);\r\n        connect(restartTimer, SIGNAL(timeout()),\r\n                this, SLOT(restartGatewayTimerFired()));\r\n        restartTimer->start(500);\r\n#endif // ARCH_ARM\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/restartapp\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::restartApp(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    rsp.httpStatus = HttpStatusOk;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/restartapp\"] = true;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n    QTimer *restartTimer = new QTimer(this);\r\n    restartTimer->setSingleShot(true);\r\n    connect(restartTimer, SIGNAL(timeout()),\r\n            this, SLOT(simpleRestartAppTimerFired()));\r\n    restartTimer->start(500);\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/shutdown\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::shutDownGateway(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    rsp.httpStatus = HttpStatusOk;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/shutdown\"] = true;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n#ifdef ARCH_ARM\r\n        openDb();\r\n        saveDb();\r\n        closeDb();\r\n\r\n        QTimer *shutdownTimer = new QTimer(this);\r\n        shutdownTimer->setSingleShot(true);\r\n        connect(shutdownTimer, SIGNAL(timeout()),\r\n                this, SLOT(shutDownGatewayTimerFired()));\r\n        shutdownTimer->start(500);\r\n#endif // ARCH_ARM\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/updatefirmware\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::updateFirmware(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    if (startUpdateFirmware())\r\n    {\r\n        rsp.httpStatus = HttpStatusOk;\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/updatefirmware\"] = gwFirmwareVersionUpdate;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n    else\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/export\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::exportConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"backup: failed to export - ZigBee network is down\\n\");\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    ttlDataBaseConnection = 0;\r\n    closeDb();\r\n\r\n    if (dbIsOpen())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"backup: failed to export - database busy\\n\");\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (BAK_ExportConfiguration(deCONZ::ApsController::instance()))\r\n    {\r\n        rsp.httpStatus = HttpStatusOk;\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/export\"] = \"success\";\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n    else\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/import\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::importConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    // prevent overwrite database with content of current memory\r\n    // will be reset after application soft restart\r\n    ttlDataBaseConnection = 0;\r\n    saveDatabaseItems |= DB_NOSAVE;\r\n    closeDb();\r\n\r\n    if (dbIsOpen())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"backup: failed to import - database busy\\n\");\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (BAK_ImportConfiguration(deCONZ::ApsController::instance()))\r\n    {\r\n        openDb();\r\n        saveApiKey(req.apikey());\r\n        closeDb();\r\n\r\n        rsp.httpStatus = HttpStatusOk;\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/import\"] = \"success\";\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n\r\n        needRestartApp = true;\r\n        QTimer *restartTimer = new QTimer(this);\r\n        restartTimer->setSingleShot(true);\r\n        connect(restartTimer, SIGNAL(timeout()),\r\n                this, SLOT(restartAppTimerFired()));\r\n        restartTimer->start(SET_ENDPOINTCONFIG_DURATION);\r\n\r\n        auto curChannel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\r\n        if (gwZigbeeChannel != curChannel)\r\n        {\r\n            gwZigbeeChannel = curChannel;\r\n            saveDatabaseItems |= DB_CONFIG;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n    }\r\n\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/reset\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::resetConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool resetGW = false;\r\n    bool deleteDB = false;\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, \"\", \"body contains invalid JSON\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if ((!map.contains(\"resetGW\")) || (!map.contains(\"deleteDB\")))\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, \"/config/reset\", \"missing parameters in body\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (map[\"resetGW\"].type() != QVariant::Bool)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/reset\"), QString(\"invalid value, %1, for parameter, resetGW\").arg(map[\"resetGW\"].toString())));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n    if (map[\"deleteDB\"].type() != QVariant::Bool)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/config/reset\"), QString(\"invalid value, %1, for parameter, deleteDB\").arg(map[\"deleteDB\"].toString())));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n    resetGW = map[\"resetGW\"].toBool();\r\n    deleteDB = map[\"deleteDB\"].toBool();\r\n\r\n    // prevent overwrite database with content of current memory\r\n    // will be reset after application soft restart\r\n    ttlDataBaseConnection = 0;\r\n    saveDatabaseItems |= DB_NOSAVE;\r\n    closeDb();\r\n\r\n    if (dbIsOpen())\r\n    {\r\n        DBG_Printf(DBG_ERROR, \"backup: failed to import - database busy\\n\");\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (BAK_ResetConfiguration(deCONZ::ApsController::instance(), resetGW, deleteDB))\r\n    {\r\n        rsp.httpStatus = HttpStatusOk;\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/reset\"] = \"success\";\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n        //wait some seconds that deCONZ can finish Enpoint config,\r\n        //then restart app to apply network config (only on raspbee gw)\r\n\r\n        gwZigbeeChannel = apsCtrl->getParameter(deCONZ::ParamCurrentChannel);\r\n        saveDatabaseItems |= DB_CONFIG;\r\n        needRestartApp = true;\r\n        QTimer *restartTimer = new QTimer(this);\r\n        restartTimer->setSingleShot(true);\r\n        connect(restartTimer, SIGNAL(timeout()),\r\n                this, SLOT(restartAppTimerFired()));\r\n        restartTimer->start(SET_ENDPOINTCONFIG_DURATION);\r\n    }\r\n    else\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/<apikey>/config/password\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::changePassword(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, \"/config/password\", \"body contains invalid JSON\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (map.contains(\"username\") && map.contains(\"oldhash\") && map.contains(\"newhash\"))\r\n    {\r\n        QString username = map[\"username\"].toString();\r\n        QString oldhash = map[\"oldhash\"].toString();\r\n        QString newhash = map[\"newhash\"].toString();\r\n\r\n        if ((map[\"username\"].type() != QVariant::String) || (username != gwAdminUserName))\r\n        {\r\n            rsp.httpStatus = HttpStatusUnauthorized;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/password\", QString(\"invalid value, %1 for parameter, username\").arg(username)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if ((map[\"oldhash\"].type() != QVariant::String) || oldhash.isEmpty())\r\n        {\r\n            rsp.httpStatus = HttpStatusUnauthorized;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/password\", QString(\"invalid value, %1 for parameter, oldhash\").arg(oldhash)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if ((map[\"newhash\"].type() != QVariant::String) || newhash.isEmpty())\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/password\", QString(\"invalid value, %1 for parameter, newhash\").arg(newhash)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        std::string enc = CRYPTO_EncryptGatewayPassword(oldhash.toStdString());\r\n\r\n        if (enc != gwAdminPasswordHash)\r\n        {\r\n            if (oldhash.toStdString() != gwAdminPasswordHash) // on Windows plain hash was stored\r\n            {\r\n                rsp.httpStatus = HttpStatusUnauthorized;\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/password\", QString(\"invalid value, %1 for parameter, oldhash\").arg(oldhash)));\r\n                return REQ_READY_SEND;\r\n            }\r\n        }\r\n\r\n        // username and old hash are okay\r\n        // take the new hash and salt it\r\n        enc = CRYPTO_EncryptGatewayPassword(newhash.toStdString());\r\n        gwAdminPasswordHash = enc;\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n\r\n        DBG_Printf(DBG_INFO, \"Updated password hash\\n\");\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"/config/password\"] = \"changed\";\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n        return REQ_READY_SEND;\r\n    }\r\n    else\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, \"/config/password\", \"missing parameters in body\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/config/password\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::deletePassword(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok = true;\r\n\r\n    // reset only allowed within first 10 minutes after startup\r\n    if (getUptime() > 600)\r\n    {\r\n        ok = false;\r\n    }\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.httpStatus = HttpStatusForbidden;\r\n        rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, \"/\" + req.path.join(\"/\"), \"unauthorized user\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // create default password\r\n    gwConfig.remove(\"gwusername\");\r\n    gwConfig.remove(\"gwpassword\");\r\n\r\n    initAuthentication();\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Locks the gateway.\r\n */\r\nvoid DeRestPluginPrivate::lockGatewayTimerFired()\r\n{\r\n    if (gwLinkButton)\r\n    {\r\n        gwLinkButton = false;\r\n        updateEtag(gwConfigEtag);\r\n        DBG_Printf(DBG_INFO, \"gateway locked\\n\");\r\n    }\r\n}\r\n\r\n/*! Helper to update the config Etag then rfconnect state changes.\r\n */\r\nvoid DeRestPluginPrivate::checkRfConnectState()\r\n{\r\n    if (apsCtrl)\r\n    {\r\n        // while touchlink is active always report connected: true\r\n        if (isTouchlinkActive())\r\n        {\r\n            if (!gwRfConnected)\r\n            {\r\n                gwRfConnected = true;\r\n                updateEtag(gwConfigEtag);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            bool connected = isInNetwork();\r\n\r\n            if (connected != gwRfConnected)\r\n            {\r\n                gwRfConnected = connected;\r\n                updateEtag(gwConfigEtag);\r\n            }\r\n        }\r\n\r\n        const quint32 fwVersion = apsCtrl->getParameter(deCONZ::ParamFirmwareVersion);\r\n        QString str = QString(\"0x%1\").arg(fwVersion, 8, 16, QLatin1Char('0'));\r\n\r\n        if (gwFirmwareVersion != str)\r\n        {\r\n            gwFirmwareVersion = str;\r\n            gwConfig[\"fwversion\"] = str;\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n\r\n        // upgrade setting if needed\r\n        if (!gwRfConnectedExpected && gwRfConnected)\r\n        {\r\n            gwRfConnectedExpected = true;\r\n            queSaveDb(DB_CONFIG, DB_LONG_SAVE_DELAY);\r\n        }\r\n    }\r\n}\r\n\r\n/*! GET /api/config/wifi\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getWifiState(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    rsp.map[\"wifi\"] = gwWifi;\r\n    rsp.map[\"wifitype\"] = gwWifiType;\r\n    rsp.map[\"wifiname\"] = gwWifiName;\r\n    rsp.map[\"wifichannel\"] = gwWifiChannel;\r\n    rsp.map[\"wifiip\"] = gwWifiIp;\r\n    rsp.map[\"state\"] = gwWifiStateString;\r\n    rsp.map[\"type\"] = gwWifiType;\r\n    rsp.map[\"ip\"] = gwWifiIp;\r\n    rsp.map[\"name\"] = gwWifiName;\r\n    rsp.map[\"pw\"] = QString();\r\n    rsp.map[\"workingtype\"] = gwWifiWorkingType;\r\n    rsp.map[\"workingname\"] = gwWifiWorkingName;\r\n    rsp.map[\"workingpw\"] = QString();\r\n    // rsp.map[\"wifiappw\"] = gwWifiPw;\r\n    // rsp.map[\"wifiappw\"] = QString();\r\n    rsp.map[\"wifiavailable\"] = gwWifiAvailable;\r\n    rsp.map[\"lastupdated\"] = gwWifiLastUpdated;\r\n    rsp.map[\"eth0\"] = gwWifiEth0;\r\n    rsp.map[\"wlan0\"] = gwWifiWlan0;\r\n    rsp.map[\"active\"] = gwWifiActive;\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/wifi\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::configureWifi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    bool changed = false;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, \"/config/wifi\", \"body contains invalid JSON\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (map.contains(\"pageactive\"))\r\n    {\r\n        bool active = map[\"pageactive\"].toBool();\r\n\r\n        if (map[\"pageactive\"].type() != QVariant::Bool)\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, pageactive\").arg(active)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (active)\r\n        {\r\n            if (wifiPageActiveTimer->isActive())\r\n            {\r\n                wifiPageActiveTimer->stop();\r\n                wifiPageActiveTimer->start(6000);\r\n            }\r\n            else\r\n            {\r\n                if (!gwWifiPageActive)\r\n                {\r\n                    gwWifiPageActive = true;\r\n                    queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n                    wifiPageActiveTimer->start(6000);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"type\"))\r\n    {\r\n        QString type = map[\"type\"].toString();\r\n\r\n        if ((map[\"type\"].type() != QVariant::String) || ((type != \"accesspoint\") && (type != \"client\")))\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, type\").arg(type)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwWifiType != type)\r\n        {\r\n            changed = true;\r\n            gwWifiType = type;\r\n            gwWifi = \"configured\";\r\n        }\r\n    }\r\n    if (map.contains(\"name\"))\r\n    {\r\n        QString name = map[\"name\"].toString();\r\n\r\n        if ((map[\"name\"].type() != QVariant::String) || name.isEmpty())\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, name\").arg(name)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwWifiName != name)\r\n        {\r\n            changed = true;\r\n            gwWifiName = name;\r\n        }\r\n    }\r\n    if (map.contains(\"password\"))\r\n    {\r\n        QString password = map[\"password\"].toString();\r\n\r\n        if ((map[\"password\"].type() != QVariant::String) || password.isEmpty())\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, password\").arg(password)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (gwWifiPw != password)\r\n        {\r\n            changed = true;\r\n            gwWifiPw = password;\r\n        }\r\n    }\r\n    if (map.contains(\"wifi\"))\r\n    {\r\n        QString wifi = map[\"wifi\"].toString();\r\n\r\n        if ((map[\"wifi\"].type() != QVariant::String) || ((wifi != \"configured\") && (wifi != \"not-configured\") && (wifi != \"new-configured\") && (wifi != \"deactivated\")))\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, wifi\").arg(wifi)));\r\n            return REQ_READY_SEND;\r\n        }\r\n        if (gwWifi != wifi)\r\n        {\r\n            changed = true;\r\n            gwWifi = wifi;\r\n        }\r\n    }\r\n\r\n    /*\r\n            if (map.contains(\"channel\"))\r\n            {\r\n                bool ok;\r\n                int channel = map[\"channel\"].toInt(&ok);\r\n                if (ok && channel >= 1 && channel <= 11)\r\n                {\r\n                    gwWifiChannel = channel;\r\n                }\r\n                else\r\n                {\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, \"/config/wifi\", QString(\"invalid value, %1 for parameter, channel\").arg(channel)));\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n    */\r\n\r\n    if (changed)\r\n    {\r\n        QDateTime currentDateTime = QDateTime::currentDateTimeUtc();\r\n        gwWifiLastUpdated = currentDateTime.toTime_t();\r\n\r\n        updateEtag(gwConfigEtag);\r\n        queSaveDb(DB_CONFIG | DB_SYNC, DB_FAST_SAVE_DELAY);\r\n    }\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/wifi/\"] = gwWifi;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/wifi/restore\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::restoreWifiConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/wifi/restore\"] = \"original configuration restored\";\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/wifi/scanresult\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::putWifiScanResult(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QHostAddress localHost(QHostAddress::LocalHost);\r\n    rsp.httpStatus = HttpStatusForbidden;\r\n\r\n    if (req.sock->peerAddress() != localHost)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, \"/\" + req.path.join(\"/\"), \"unauthorized user\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    if (ok)\r\n    {\r\n        gwWifiAvailable = var.toList();\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/wifi/updated (wifi service notifications)\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::putWifiUpdated(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QHostAddress localHost(QHostAddress::LocalHost);\r\n    rsp.httpStatus = HttpStatusForbidden;\r\n\r\n    if (req.sock->peerAddress() != localHost)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, \"/\" + req.path.join(\"/\"), \"unauthorized user\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    pid_t pid = req.path[1].toInt();\r\n    if (gwWifiPID != pid)\r\n    {\r\n        gwWifiPID = pid;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (req.content.isEmpty())\r\n    {\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // TODO forward events\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    QString status;\r\n\r\n    if (map.contains(\"status\"))\r\n    {\r\n        status = map[\"status\"].toString();\r\n    }\r\n\r\n    if (status == QLatin1String(\"current-config\") && map.contains(\"mgmt\"))\r\n    {\r\n        quint32 mgmt = map[\"mgmt\"].toUInt();\r\n\r\n        if (gwWifiMgmt != mgmt)\r\n        {\r\n            gwWifiMgmt = mgmt;\r\n\r\n            if (gwWifiMgmt & WIFI_MGMT_ACTIVE)\r\n            {\r\n                gwWifiActive = QLatin1String(\"active\");\r\n            }\r\n            else\r\n            {\r\n                gwWifiActive = QLatin1String(\"inactive\");\r\n                gwWifiWorkingName = QString();\r\n                gwWifiWorkingType = QString();\r\n            }\r\n\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n\r\n        QString type;\r\n        QString ssid;\r\n\r\n        if (map.contains(\"type\")) { type = map[\"type\"].toString(); }\r\n        if (map.contains(\"ssid\")) { ssid = map[\"ssid\"].toString(); }\r\n\r\n        if (gwWifiState == WifiStateInitMgmt)\r\n        {\r\n            gwWifiState = WifiStateIdle;\r\n\r\n            if (type == QLatin1String(\"accesspoint\") && !ssid.isEmpty())\r\n            {\r\n                if (gwWifi != QLatin1String(\"not-configured\") && (gwWifiMgmt & WIFI_MGTM_HOSTAPD) == 0)\r\n                {\r\n                    gwWifi = QLatin1String(\"not-configured\"); // not configured by deCONZ\r\n                }\r\n\r\n                if (gwWifiMgmt & WIFI_MGMT_ACTIVE)\r\n                {\r\n                    gwWifiActive = QLatin1String(\"active\");\r\n                    gwWifiWorkingName = ssid;\r\n                    gwWifiWorkingType = type;\r\n                }\r\n                else\r\n                {\r\n                    gwWifiActive = QLatin1String(\"inactive\");\r\n                    gwWifiWorkingName = QString();\r\n                    gwWifiWorkingType = QString();\r\n                }\r\n            }\r\n\r\n            if (type == QLatin1String(\"client\") && !ssid.isEmpty())\r\n            {\r\n                if (gwWifi != QLatin1String(\"not-configured\") && (gwWifiMgmt & WIFI_MGTM_WPA_SUPPLICANT) == 0)\r\n                {\r\n                    gwWifi = QLatin1String(\"not-configured\"); // not configured by deCONZ\r\n                }\r\n\r\n                if (gwWifiMgmt & WIFI_MGMT_ACTIVE)\r\n                {\r\n                    gwWifiActive = QLatin1String(\"active\");\r\n                    gwWifiWorkingName = ssid;\r\n                    gwWifiWorkingType = type;\r\n                }\r\n                else\r\n                {\r\n                    gwWifiActive = QLatin1String(\"inactive\");\r\n                    gwWifiWorkingName = QString();\r\n                    gwWifiWorkingType = QString();\r\n                }\r\n                gwWifiClientName = ssid;\r\n            }\r\n\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n    }\r\n    else if (status == QLatin1String(\"current-config\"))\r\n    {\r\n        QString workingtype;\r\n        QString workingname;\r\n        QString workingpw;\r\n        QString wifipw;\r\n        QString wifiname;\r\n        QString wifitype;\r\n        QString wifi;\r\n        QString wifipwenc;\r\n        QString workingpwenc;\r\n        QString wifibackuppwenc;\r\n\r\n        if (map.contains(\"workingtype\")) { workingtype = map[\"workingtype\"].toString(); }\r\n        if (map.contains(\"workingname\")) { workingname = map[\"workingname\"].toString(); }\r\n        if (map.contains(\"workingpw\")) { workingpw = map[\"workingpw\"].toString(); }\r\n        if (map.contains(\"wifipw\")) { wifipw = map[\"wifipw\"].toString(); }\r\n        if (map.contains(\"wifiname\")) { wifiname = map[\"wifiname\"].toString(); }\r\n        if (map.contains(\"wifitype\")) { wifitype = map[\"wifitype\"].toString(); }\r\n        if (map.contains(\"wifi\")) { wifi = map[\"wifi\"].toString(); }\r\n        if (map.contains(\"wifipwenc\")) { wifipwenc = map[\"wifipwenc\"].toString(); }\r\n        if (map.contains(\"workingpwenc\")) { workingpwenc = map[\"workingpwenc\"].toString(); }\r\n        if (map.contains(\"wifibackuppwenc\")) { wifibackuppwenc = map[\"wifibackuppwenc\"].toString(); }\r\n\r\n        bool changed = false;\r\n        if (!workingtype.isEmpty() && gwWifiWorkingType != workingtype)\r\n        {\r\n            gwWifiWorkingType = workingtype;\r\n            changed = true;\r\n        }\r\n\r\n        if (!workingname.isEmpty() && gwWifiWorkingName != workingname)\r\n        {\r\n            gwWifiWorkingName = workingname;\r\n            changed = true;\r\n        }\r\n\r\n        if (!workingpw.isEmpty() && gwWifiWorkingPw != workingpw)\r\n        {\r\n            if (gwWifi == \"not-configured\")\r\n            {\r\n                gwWifiWorkingPw = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiWorkingPw = workingpw;\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        if (!wifipw.isEmpty() && gwWifiPw != wifipw)\r\n        {\r\n            if (gwWifi == \"not-configured\")\r\n            {\r\n                gwWifiPw = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiPw = wifipw;\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        if (!wifiname.isEmpty() && gwWifiName != wifiname)\r\n        {\r\n            gwWifiName = wifiname;\r\n            changed = true;\r\n        }\r\n\r\n        if (!wifitype.isEmpty() && gwWifiType != wifitype)\r\n        {\r\n            gwWifiType = wifitype;\r\n            changed = true;\r\n        }\r\n\r\n        if (!wifi.isEmpty() && gwWifi != wifi)\r\n        {\r\n            gwWifi = wifi;\r\n            changed = true;\r\n        }\r\n\r\n        if (wifi == \"not-configured\")\r\n        {\r\n            if (!gwWifiPw.isEmpty())\r\n            {\r\n                gwWifiPw = QString();\r\n                changed = true;\r\n            }\r\n            if (!gwWifiWorkingPw.isEmpty())\r\n            {\r\n                gwWifiWorkingPw = QString();\r\n                changed = true;\r\n            }\r\n            if (!gwWifiBackupPw.isEmpty())\r\n            {\r\n                gwWifiBackupPw = QString();\r\n                changed = true;\r\n            }\r\n            if (!gwWifiPwEnc.isEmpty())\r\n            {\r\n                gwWifiPwEnc = QString();\r\n                changed = true;\r\n            }\r\n            if (!gwWifiWorkingPwEnc.isEmpty())\r\n            {\r\n                gwWifiWorkingPwEnc = QString();\r\n                changed = true;\r\n            }\r\n            if (!gwWifiBackupPwEnc.isEmpty())\r\n            {\r\n                gwWifiBackupPwEnc = QString();\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (workingtype == \"accesspoint\")\r\n        {\r\n            if (!workingname.isEmpty() && gwWifiBackupName != workingname)\r\n            {\r\n                gwWifiBackupName = workingname;\r\n                changed = true;\r\n            }\r\n            if (!workingpw.isEmpty() && gwWifiBackupPw != workingpw)\r\n            {\r\n                if (gwWifi == \"not-configured\")\r\n                {\r\n                    gwWifiBackupPw = QString();\r\n                }\r\n                else\r\n                {\r\n                    gwWifiBackupPw = workingpw;\r\n                }\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (!wifipwenc.isEmpty() && gwWifiPwEnc != wifipwenc)\r\n        {\r\n            if (gwWifi == \"not-configured\")\r\n            {\r\n                gwWifiPwEnc = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiPwEnc = wifipwenc;\r\n                gwWifiPw = QString();\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        if (!workingpwenc.isEmpty() && gwWifiWorkingPwEnc != workingpwenc)\r\n        {\r\n            if (gwWifi == \"not-configured\")\r\n            {\r\n                gwWifiWorkingPwEnc = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiWorkingPwEnc = workingpwenc;\r\n                gwWifiWorkingPw = QString();\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        if (!wifibackuppwenc.isEmpty() && gwWifiBackupPwEnc != wifibackuppwenc)\r\n        {\r\n            if (gwWifi == \"not-configured\")\r\n            {\r\n                gwWifiBackupPwEnc = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiBackupPwEnc = wifibackuppwenc;\r\n                gwWifiBackupPw = QString();\r\n            }\r\n            changed = true;\r\n        }\r\n\r\n        if (changed)\r\n        {\r\n            updateEtag(gwConfigEtag);\r\n            queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n        }\r\n    }\r\n\r\n    else if (status == QLatin1String(\"got-ip\"))\r\n    {\r\n        QString ip = map[\"ipv4\"].toString();\r\n\r\n        if (!ip.isEmpty() && gwWifiIp != ip)\r\n        {\r\n            if (gwWifiActive != QLatin1String(\"active\"))\r\n            {\r\n                gwWifiActive = QLatin1String(\"active\");\r\n            }\r\n\r\n            gwWifiIp = ip;\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n\r\n        if (gwWifiWlan0 != ip)\r\n        {\r\n            if (ip.isEmpty())\r\n            {\r\n                gwWifiWlan0 = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiWlan0 = ip;\r\n            }\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n    }\r\n    else if (status == QLatin1String(\"got-ip-eth0\"))\r\n    {\r\n        QString ip = map[\"ipv4\"].toString();\r\n\r\n        if (gwWifiEth0 != ip)\r\n        {\r\n            if (ip.isEmpty())\r\n            {\r\n                gwWifiEth0 = QString();\r\n            }\r\n            else\r\n            {\r\n                gwWifiEth0 = ip;\r\n            }\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n    }\r\n    else if (status == QLatin1String(\"ap-connecting\") && gwWifiStateString != QLatin1String(\"ap-connecting\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"ap-connecting\");\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"client-connecting\") && gwWifiStateString != QLatin1String(\"client-connecting\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"client-connecting\");\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"ap-configured\") && gwWifiStateString != QLatin1String(\"ap-configured\"))\r\n    {\r\n        bool changed = false;\r\n        gwWifiStateString = QLatin1String(\"ap-configured\");\r\n\r\n        if (gwWifiWorkingType != QLatin1String(\"accesspoint\"))\r\n        {\r\n            gwWifiWorkingType = QLatin1String(\"accesspoint\");\r\n            changed = true;\r\n        }\r\n\r\n        if (gwWifiActive != QLatin1String(\"active\"))\r\n        {\r\n            gwWifiActive = QLatin1String(\"active\");\r\n            changed = true;\r\n        }\r\n\r\n        updateEtag(gwConfigEtag);\r\n\r\n        if (changed)\r\n        {\r\n            queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n        }\r\n    }\r\n    else if (status == QLatin1String(\"client-configured\") && gwWifiStateString != QLatin1String(\"client-configured\"))\r\n    {\r\n        bool changed = false;\r\n        gwWifiStateString = QLatin1String(\"client-configured\");\r\n\r\n        if (gwWifiWorkingType != QLatin1String(\"client\"))\r\n        {\r\n            gwWifiWorkingType = QLatin1String(\"client\");\r\n            changed = true;\r\n        }\r\n\r\n        if (gwWifiActive != QLatin1String(\"active\"))\r\n        {\r\n            gwWifiActive = QLatin1String(\"active\");\r\n            changed = true;\r\n        }\r\n\r\n        updateEtag(gwConfigEtag);\r\n\r\n        if (changed)\r\n        {\r\n            queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n        }\r\n    }\r\n    else if (status == QLatin1String(\"ap-connect-fail\") && gwWifiStateString != QLatin1String(\"ap-connect-fail\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"ap-connect-fail\");\r\n\r\n        if (gwWifiActive != QLatin1String(\"inactive\"))\r\n        {\r\n            gwWifiActive = QLatin1String(\"inactive\");\r\n        }\r\n\r\n        bool changed = false;\r\n        if (gwWifiName != \"invalid\")\r\n        {\r\n            gwWifiName = \"invalid\";\r\n            changed = true;\r\n        }\r\n        if (gwWifiPw != \"invalid\")\r\n        {\r\n            gwWifiPw = \"invalid\";\r\n            changed = true;\r\n        }\r\n        if (gwWifiType != \"invalid\")\r\n        {\r\n            gwWifiType = \"invalid\";\r\n            changed = true;\r\n        }\r\n        gwWifiWorkingName = QString();\r\n        gwWifiWorkingPw = QString();\r\n        //gwWifiWorkingType = QString();\r\n\r\n        if (changed)\r\n        {\r\n            queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"client-connect-fail\") && gwWifiStateString != QLatin1String(\"client-connect-fail\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"client-connect-fail\");\r\n\r\n        if (gwWifiActive != QLatin1String(\"inactive\"))\r\n        {\r\n            gwWifiActive = QLatin1String(\"inactive\");\r\n        }\r\n\r\n        bool changed = false;\r\n        if (gwWifiName != \"invalid\")\r\n        {\r\n            gwWifiName = \"invalid\";\r\n            changed = true;\r\n        }\r\n        if (gwWifiPw != \"invalid\")\r\n        {\r\n            gwWifiPw = \"invalid\";\r\n            changed = true;\r\n        }\r\n        if (gwWifiType != \"invalid\")\r\n        {\r\n            gwWifiType = \"invalid\";\r\n            changed = true;\r\n        }\r\n        gwWifiWorkingName = QString();\r\n        gwWifiWorkingPw = QString();\r\n        //gwWifiWorkingType = QString();\r\n\r\n        if (changed)\r\n        {\r\n            queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n        }\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"check-ap\") && gwWifiStateString != QLatin1String(\"check-ap\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"check-ap\");\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"check-client\") && gwWifiStateString != QLatin1String(\"check-client\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"check-client\");\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"not-configured\") && gwWifiStateString != QLatin1String(\"not-configured\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"not-configured\");\r\n\r\n        if (gwWifi != QLatin1String(\"not-configured\"))\r\n        {\r\n            gwWifi = QLatin1String(\"not-configured\");\r\n        }\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"deactivated\") && gwWifiStateString != QLatin1String(\"deactivated\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"deactivated\");\r\n\r\n        if (gwWifi != QLatin1String(\"deactivated\"))\r\n        {\r\n            gwWifi = QLatin1String(\"deactivated\");\r\n        }\r\n\r\n        if (gwWifiActive != QLatin1String(\"inactive\"))\r\n        {\r\n            gwWifiActive = QLatin1String(\"inactive\");\r\n        }\r\n\r\n        gwWifiWorkingName = QString();\r\n        gwWifiWorkingPw = QString();\r\n        gwWifiWorkingType = QString();\r\n\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"check-config\") && gwWifiStateString != QLatin1String(\"check-config\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"check-config\");\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"last-working-config\") && gwWifiStateString != QLatin1String(\"last-working-config\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"last-working-config\");\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n    else if (status == QLatin1String(\"ap-backup\") && gwWifiStateString != QLatin1String(\"ap-backup\"))\r\n    {\r\n        gwWifiStateString = QLatin1String(\"ap-backup\");\r\n        updateEtag(gwConfigEtag);\r\n    }\r\n\r\n    DBG_Printf(DBG_HTTP, \"wifi: %s\\n\", qPrintable(req.content));\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/homebridge/updated\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::putHomebridgeUpdated(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QHostAddress localHost(QHostAddress::LocalHost);\r\n    rsp.httpStatus = HttpStatusForbidden;\r\n\r\n    if (req.sock->peerAddress() != localHost)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_UNAUTHORIZED_USER, \"/\" + req.path.join(\"/\"), \"unauthorized user\"));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (req.content.isEmpty())\r\n    {\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // TODO forward events\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    QString homebridge;\r\n    QString homebridgePin;\r\n    QString homebridgeVersion;\r\n    QString homebridgeUpdateVersion;\r\n    bool changed = false;\r\n\r\n    if (map.contains(\"homebridge\"))\r\n    {\r\n        homebridge = map[\"homebridge\"].toString();\r\n\r\n        if (homebridge == QLatin1String(\"not-managed\"))\r\n        {\r\n            if (gwHomebridge != homebridge)\r\n            {\r\n                gwHomebridge = homebridge;\r\n                changed = true;\r\n            }\r\n        }\r\n        else if (homebridge == QLatin1String(\"managed\"))\r\n        {\r\n            if (gwHomebridge != homebridge)\r\n            {\r\n                gwHomebridge = homebridge;\r\n                changed = true;\r\n            }\r\n        }\r\n        else if (homebridge == QLatin1String(\"installing\"))\r\n        {\r\n            if (gwHomebridge != homebridge)\r\n            {\r\n                gwHomebridge = homebridge;\r\n                changed = true;\r\n            }\r\n        }\r\n        else if (homebridge == QLatin1String(\"install-error\"))\r\n        {\r\n            if (gwHomebridge != homebridge)\r\n            {\r\n                gwHomebridge = homebridge;\r\n                changed = true;\r\n            }\r\n        }\r\n        else if (homebridge == QLatin1String(\"updated\"))\r\n        {\r\n            if (gwHomebridge != homebridge)\r\n            {\r\n                gwHomebridge = homebridge;\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    if (map.contains(\"homebridgepin\"))\r\n    {\r\n        homebridgePin = map[\"homebridgepin\"].toString();\r\n        if (gwHomebridgePin != homebridgePin)\r\n        {\r\n            gwHomebridgePin = homebridgePin;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"homebridgeversion\"))\r\n    {\r\n        homebridgeVersion = map[\"homebridgeversion\"].toString();\r\n        if (gwHomebridgeVersion != homebridgeVersion)\r\n        {\r\n            gwHomebridgeVersion = homebridgeVersion;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"homebridgeupdateversion\"))\r\n    {\r\n        homebridgeUpdateVersion = map[\"homebridgeupdateversion\"].toString();\r\n        if (gwHomebridgeUpdateVersion != homebridgeUpdateVersion)\r\n        {\r\n            gwHomebridgeUpdateVersion = homebridgeUpdateVersion;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    if (changed)\r\n    {\r\n        updateEtag(gwConfigEtag);\r\n        queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"homebridge: %s\\n\", qPrintable(req.content));\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/config/wifiscan\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::scanWifiNetworks(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    QVariantMap cells;\r\n    rsp.map[\"cells\"] = cells;\r\n    rsp.httpStatus = HttpStatusOk;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/config/homebridge/reset\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::resetHomebridge(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n#ifdef ARCH_ARM\r\n    gwHomebridge = QLatin1String(\"reset\");\r\n    queSaveDb(DB_CONFIG | DB_SYNC, DB_SHORT_SAVE_DELAY);\r\n#endif\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"/config/homebridge/reset\"] = \"success\";\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Checks that the daylight sensor is configured properly.\r\n    Also sets the uniqueid of the sensor if needed.\r\n    \\return true if the sensor is configured and \\p lat and \\p lng are written\r\n */\r\nbool DeRestPluginPrivate::checkDaylightSensorConfiguration(Sensor *sensor, const QString &gwBridgeId, double *lat, double *lng)\r\n{\r\n    DBG_Assert(sensor != nullptr);\r\n    DBG_Assert(lat != nullptr);\r\n    DBG_Assert(lng != nullptr);\r\n    if (!sensor || !lat || !lng)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    ResourceItem *configured = sensor->item(RConfigConfigured);\r\n    ResourceItem *ilat = sensor->item(RConfigLat);\r\n    ResourceItem *ilng = sensor->item(RConfigLong);\r\n\r\n    DBG_Assert(configured != nullptr);\r\n    DBG_Assert(ilat != nullptr);\r\n    DBG_Assert(ilng != nullptr);\r\n    if (!configured || !ilat || !ilng)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    bool ok;\r\n    static bool uidChecked = false;\r\n\r\n    // check uniqueid once per deCONZ start\r\n    if (!uidChecked && !gwBridgeId.isEmpty())\r\n    {\r\n        qulonglong extAddr = gwBridgeId.toULongLong(&ok, 16);\r\n        if (ok && extAddr != 0)\r\n        {\r\n            // 00:21:2e:ff:ff:00:aa:bb-01\r\n            // note: might change if device is changed\r\n            QString uniqueid = generateUniqueId(extAddr, 1, 0);\r\n            ResourceItem *item = sensor->item(RAttrUniqueId);\r\n\r\n            if (!item || (item->toString() != uniqueid))\r\n            {\r\n                item = sensor->addItem(DataTypeString, RAttrUniqueId);\r\n                item->setValue(uniqueid);\r\n                sensor->setNeedSaveDatabase(true);\r\n                queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            uidChecked = true;\r\n        }\r\n    }\r\n\r\n    bool ok1 = false;\r\n    bool ok2 = false;\r\n    *lat = ilat->toString().toDouble(&ok1);\r\n    *lng = ilng->toString().toDouble(&ok2);\r\n    ok = ok1 && ok2;\r\n\r\n    if (ok != configured->toBool())\r\n    {\r\n        configured->setValue(ok);\r\n        sensor->setNeedSaveDatabase(true);\r\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    return ok;\r\n}\r\n\r\nsize_t DeRestPluginPrivate::calcDaylightOffsets(Sensor *daylightSensor, size_t iter)\r\n{\r\n    if (!daylightSensor)\r\n    {\r\n        return iter;\r\n    }\r\n\r\n    if (iter >= sensors.size())\r\n    {\r\n        iter = 0;\r\n    }\r\n\r\n    ResourceItem *sunrise = daylightSensor->item(RStateSunrise);\r\n    ResourceItem *sunset = daylightSensor->item(RStateSunset);\r\n    if (!sunrise || !sunset)\r\n    {\r\n        return iter;\r\n    }\r\n\r\n    QElapsedTimer t; // don't block too long\r\n    t.start();\r\n    while (iter < sensors.size() && t.elapsed() < 3)\r\n    {\r\n        Sensor &s = sensors[iter];\r\n        iter++;\r\n\r\n        if (s.type() != QLatin1String(\"CLIPDaylightOffset\"))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        ResourceItem *mode = s.item(RConfigMode);\r\n        ResourceItem *offset = s.item(RConfigOffset);\r\n        ResourceItem *localTime = s.item(RStateLocaltime);\r\n\r\n        if (!mode || !offset || !localTime)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        qint64 tref = -1;\r\n\r\n        if (mode->toString() == QLatin1String(\"sunrise\"))\r\n        {\r\n            tref = sunrise->toNumber() + offset->toNumber() * 60 * 1000;\r\n        }\r\n        else if (mode->toString() == QLatin1String(\"sunset\"))\r\n        {\r\n            tref = sunset->toNumber() + offset->toNumber() * 60 * 1000;\r\n        }\r\n        else if (mode->toString() == QLatin1String(\"fix\"))\r\n        {\r\n            auto dt = QDateTime::fromMSecsSinceEpoch(localTime->toNumber());\r\n            const auto today = QDate::currentDate();\r\n            if (dt.date() != today)\r\n            {\r\n                dt.setDate(today);\r\n            }\r\n            tref = dt.toMSecsSinceEpoch();\r\n        }\r\n\r\n        if (tref > 0 && tref != localTime->toNumber())\r\n        {\r\n            localTime->setValue(tref);\r\n            s.updateStateTimestamp();\r\n            enqueueEvent(Event(RSensors, RStateLastUpdated, s.id()));\r\n            s.setNeedSaveDatabase(true);\r\n            saveDatabaseItems |= DB_SENSORS;\r\n            iter++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return iter;\r\n}\r\n\r\n/* Check daylight state */\r\nvoid DeRestPluginPrivate::daylightTimerFired()\r\n{\r\n    double lat = nan(\"\");\r\n    double lng = nan(\"\");\r\n    Sensor *sensor = getSensorNodeForId(daylightSensorId);\r\n\r\n    if (!checkDaylightSensorConfiguration(sensor, gwBridgeId, &lat, &lng))\r\n    {\r\n        return;\r\n    }\r\n\r\n    struct DL_MapEntry {\r\n        const char *state;\r\n        ResourceItem * stateItem;\r\n        const char *offset;\r\n        int weight;\r\n    };\r\n\r\n    std::vector<DL_MapEntry> dlmap = {\r\n        { RStateSunrise, nullptr, RConfigSunriseOffset, DL_SUNRISE_START },\r\n        { RStateSunset, nullptr, RConfigSunsetOffset, DL_SUNSET_END }\r\n    };\r\n\r\n    // dynamically add state items to daylight sensor if not already existing\r\n    for (auto &e : dlmap)\r\n    {\r\n        e.stateItem = sensor->addItem(DataTypeTime, e.state);\r\n        DBG_Assert(e.stateItem);\r\n    }\r\n\r\n    ResourceItem *daylight = sensor->item(RStateDaylight);\r\n    ResourceItem *dark = sensor->item(RStateDark);\r\n    ResourceItem *status = sensor->item(RStateStatus);\r\n    ResourceItem *sunriseOffset = sensor->item(RConfigSunriseOffset);\r\n    ResourceItem *sunsetOffset = sensor->item(RConfigSunsetOffset);\r\n    DBG_Assert(daylight && status && sunriseOffset && sunsetOffset);\r\n    if (!daylight || !dark || !status || !sunriseOffset || !sunsetOffset)\r\n    {\r\n        return;\r\n    }\r\n\r\n    daylightTimes.clear();\r\n\r\n    const qint64 nowMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\r\n    getDaylightTimes(nowMs, lat, lng, daylightTimes);\r\n\r\n    const char *curDayPhaseName = nullptr;\r\n    int curDayPhase = 0;\r\n    qint64 sunrise = 0;\r\n    qint64 sunset = 0;\r\n    qint64 dawn = 0;\r\n    qint64 dusk = 0;\r\n\r\n    for (const DL_Result &r : daylightTimes)\r\n    {\r\n        //qDebug() << r.name << QDateTime::fromMSecsSinceEpoch(r.msecsSinceEpoch).toString();\r\n\r\n        if (r.msecsSinceEpoch <= nowMs)\r\n        {\r\n            curDayPhaseName = r.name;\r\n            curDayPhase = r.weight;\r\n        }\r\n\r\n        if      (r.weight == DL_SUNRISE_START)  { sunrise = r.msecsSinceEpoch; }\r\n        else if (r.weight == DL_SUNSET_END)     { sunset = r.msecsSinceEpoch; }\r\n        else if (r.weight == DL_DAWN)           { dawn = r.msecsSinceEpoch; }\r\n        else if (r.weight == DL_DUSK)           { dusk = r.msecsSinceEpoch; }\r\n\r\n        const auto k = std::find_if(dlmap.begin(), dlmap.end(), [r](const DL_MapEntry &e) { return e.weight == r.weight; });\r\n        if (k != dlmap.end() && k->stateItem)\r\n        {\r\n            if (k->stateItem->toNumber() != r.msecsSinceEpoch)\r\n            {\r\n                k->stateItem->setValue(r.msecsSinceEpoch);\r\n            }\r\n        }\r\n    }\r\n\r\n    bool isDaylight = false;\r\n    if (sunrise > 0 && sunset > 0)\r\n    {\r\n        sunrise += (sunriseOffset->toNumber() * 60 * 1000);\r\n        sunset += (sunsetOffset->toNumber() * 60 * 1000);\r\n\r\n        if (nowMs > sunrise && nowMs < sunset)\r\n        {\r\n            isDaylight = true;\r\n        }\r\n    }\r\n\r\n    bool isDark = true;\r\n    if (dawn > 0 && dusk > 0)\r\n    {\r\n        dawn += (sunriseOffset->toNumber() * 60 * 1000);\r\n        dusk += (sunsetOffset->toNumber() * 60 * 1000);\r\n\r\n        if (nowMs > dawn && nowMs < dusk)\r\n        {\r\n            isDark = false;\r\n        }\r\n    }\r\n\r\n    bool updated = false;\r\n\r\n    if (!daylight->lastSet().isValid() || daylight->toBool() != isDaylight)\r\n    {\r\n        daylight->setValue(isDaylight);\r\n        Event e(RSensors, RStateDaylight, sensor->id(), daylight);\r\n        enqueueEvent(e);\r\n        updated = true;\r\n    }\r\n\r\n    if (!dark->lastSet().isValid() || dark->toBool() != isDark)\r\n    {\r\n        dark->setValue(isDark);\r\n        Event e(RSensors, RStateDark, sensor->id(), dark);\r\n        enqueueEvent(e);\r\n        updated = true;\r\n    }\r\n\r\n    if (curDayPhase && curDayPhase != status->toNumber())\r\n    {\r\n        status->setValue(curDayPhase);\r\n        Event e(RSensors, RStateStatus, sensor->id(), status);\r\n        enqueueEvent(e);\r\n        updated = true;\r\n    }\r\n\r\n    if (updated)\r\n    {\r\n        sensor->updateStateTimestamp();\r\n        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\r\n        sensor->setNeedSaveDatabase(true);\r\n        saveDatabaseItems |= DB_SENSORS;\r\n    }\r\n\r\n    daylightOffsetIter = calcDaylightOffsets(sensor, daylightOffsetIter);\r\n\r\n    if (curDayPhaseName)\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"Daylight now: %s, status: %d, daylight: %d, dark: %d\\n\", curDayPhaseName, curDayPhase, isDaylight, isDark);\r\n    }\r\n}\r\n\r\n/*! Manager to asure gateway has proper time.\r\n */\r\nvoid DeRestPluginPrivate::timeManagerTimerFired()\r\n{\r\n    if (timeManagerState == TM_Init)\r\n    {\r\n        DBG_Assert(ntpqProcess == nullptr);\r\n        timeManagerState = TM_WaitNtpq;\r\n        ntpqProcess = new QProcess(this);\r\n        connect(ntpqProcess, SIGNAL(finished(int)), this, SLOT(ntpqFinished()));\r\n        QStringList args;\r\n        args << \"-c\" << \"rv\";\r\n        ntpqProcess->start(QLatin1String(\"ntpq\"), args);\r\n    }\r\n}\r\n\r\n/*! Timer that indicates that phoscon app wifi page is inactive.\r\n */\r\nvoid DeRestPluginPrivate::wifiPageActiveTimerFired()\r\n{\r\n    if (gwWifiPageActive)\r\n    {\r\n        gwWifiPageActive = false;\r\n        queSaveDb(DB_CONFIG, DB_SHORT_SAVE_DELAY);\r\n    }\r\n}\r\n\r\n/*! Manager to asure gateway has proper time.\r\n */\r\nvoid DeRestPluginPrivate::ntpqFinished()\r\n{\r\n    DBG_Assert(ntpqProcess);\r\n    DBG_Assert(timeManagerState == TM_WaitNtpq);\r\n    if (timeManagerState == TM_WaitNtpq && ntpqProcess)\r\n    {\r\n        QByteArray data = ntpqProcess->readAll();\r\n        //DBG_Printf(DBG_INFO, \"NTP exit %d, %s\\n\", ntpqProcess->exitCode(), qPrintable(data));\r\n\r\n        QString ntpState;\r\n\r\n        if (ntpqProcess->exitCode() != 0 ||\r\n            data.contains(\"sync_unspec\")) // ntp not yet synchronized\r\n        {\r\n            ntpState = QLatin1String(\"unsynced\");\r\n            timeManagerState = TM_Init;\r\n            QTimer::singleShot(60000, this, SLOT(timeManagerTimerFired()));\r\n        }\r\n        else // synced somehow sync_*\r\n        {\r\n            timeManagerState = TM_NtpRunning;\r\n            ntpState = QLatin1String(\"synced\");\r\n            QTimer::singleShot(30 * 60 * 1000, this, SLOT(timeManagerTimerFired()));\r\n        }\r\n\r\n        if (gwConfig[\"ntp\"] != ntpState)\r\n        {\r\n            gwConfig[\"ntp\"] = ntpState;\r\n            updateEtag(gwConfigEtag);\r\n        }\r\n\r\n        ntpqProcess->deleteLater();\r\n        ntpqProcess = nullptr;\r\n    }\r\n}\r\n"
        },
        {
          "name": "rest_ddf.cpp",
          "type": "blob",
          "size": 20.9814453125,
          "content": "/*\n * Copyright (c) 2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QTcpSocket>\n#include <deconz/dbg_trace.h>\n#include \"device_ddf_bundle.h\"\n#include \"rest_api.h\"\n#include \"rest_ddf.h\"\n#include \"json.h\"\n#include \"deconz/u_assert.h\"\n#include \"deconz/file.h\"\n#include \"deconz/u_sstream.h\"\n#include \"deconz/u_memory.h\"\n#include \"deconz/util.h\"\n#include \"utils/scratchmem.h\"\n\n#define MAX_PATH_LENGTH 2048\n\n/*!\n    Converts data into hex-ascii string.\n\n    The memory area \\p ascii must have at least the\n    size \\p 2 * length + 1 bytes.\n\n    A terminating zero will be appended at the end.\n\n    \\returns a pointer to the last byte (zero).\n */\nstatic unsigned char *BinToHexAscii(const void *hex, unsigned length, void *ascii)\n{\n    unsigned i;\n    unsigned char *h;\n    unsigned char *a;\n\n    static char lookup[] = { '0', '1', '2','3','4','5','6','7','8','9','a','b','c','d','e','f' };\n\n    if (!hex || length == 0 || !ascii)\n        return 0;\n\n    h = (unsigned char*)hex;\n    a = (unsigned char*)ascii;\n\n    for (i = 0; i < length; i++)\n    {\n        *a++ = lookup[(h[i] & 0xf0) >> 4];\n        *a++ = lookup[h[i] & 0xf];\n    }\n\n    *a = '\\0';\n\n    return a;\n}\n\n/*\n\nTest upload of .ddf file\n\ncurl -F 'data=@/home/mpi/some.ddb' 127.0.0.1:8090/api/12345/ddf\n\n*/\n\nstatic int WriteBundleDescriptorToResponse(U_BStream *bs, U_SStream *ss, unsigned nRecords)\n{\n    cj_ctx cj;\n    cj_token tokens[2048];\n    cj_token *tok;\n    char ibuf[512];\n    unsigned chunkSize;\n    unsigned char sha256[U_SHA256_HASH_SIZE];\n    char sha256Str[(U_SHA256_HASH_SIZE * 2) + 1];\n\n    if (DDFB_FindChunk(bs, \"RIFF\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    if (DDFB_FindChunk(bs, \"DDFB\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    {\n        // Bundle hash over DDFB chunk (header + data)\n        if (U_Sha256(&bs->data[bs->pos - 8], chunkSize + 8, sha256) == 0)\n        {\n            U_ASSERT(0 && \"SHA-256 not working\");\n            return 0; // should not happen\n        }\n\n        BinToHexAscii(sha256, U_SHA256_HASH_SIZE, sha256Str);\n    }\n\n    U_BStream bsDDFB;\n    U_bstream_init(&bsDDFB, &bs->data[bs->pos], chunkSize);\n\n    // check DESC JSON has required fields\n    if (DDFB_FindChunk(&bsDDFB, \"DESC\", &chunkSize) == 0)\n    {\n        return 0;\n    }\n\n    U_ASSERT(chunkSize > 32);\n\n    cj_parse_init(&cj, (char*)&bsDDFB.data[bsDDFB.pos], chunkSize, tokens, sizeof(tokens)/sizeof(tokens[0]));\n    cj_parse(&cj);\n    U_ASSERT(cj.status == CJ_OK);\n\n    if (cj.status != CJ_OK)\n    {\n        return 0;\n    }\n\n    U_ASSERT(cj.tokens_pos > 0);\n    U_ASSERT(cj.tokens[0].type == CJ_TOKEN_OBJECT_BEG);\n    U_ASSERT(cj.tokens[cj.tokens_pos - 1].type == CJ_TOKEN_OBJECT_END);\n\n    // enough space for descriptor | hash key | file hash\n    if ((ss->pos + chunkSize + 128 + 128 + 96) < ss->len)\n    {\n        if (nRecords > 0)\n            U_sstream_put_str(ss, \",\");\n\n        U_sstream_put_str(ss, \"\\\"\");\n        U_sstream_put_str(ss, sha256Str);\n        U_sstream_put_str(ss, \"\\\":\");\n\n        // copy all tokens except closing '}'\n        for (cj_size i = 0; i < cj.tokens_pos - 1; i++)\n        {\n            tok = &cj.tokens[i];\n            U_ASSERT(tok->len != 0);\n            if (sizeof(ibuf) - 1 < tok->len)\n            {\n                U_ASSERT(0 && \"unexpected large JSON token\");\n                return 0; // should not happen\n            }\n\n            if (tok->type == CJ_TOKEN_STRING) // include quotes\n            {\n                U_ASSERT(tok->pos != 0);\n                U_memcpy(ibuf, &cj.buf[tok->pos - 1], tok->len + 2);\n                ibuf[tok->len + 2] = '\\0';\n            }\n            else\n            {\n                U_memcpy(ibuf, &cj.buf[tok->pos], tok->len);\n                ibuf[tok->len] = '\\0';\n            }\n\n            U_sstream_put_str(ss, ibuf);\n            U_ASSERT(ss->status == U_SSTREAM_OK);\n        }\n\n        // hash over complete bundle file\n        if (U_Sha256(&bs->data[0], bs->size, sha256) == 0)\n        {\n            U_ASSERT(0 && \"SHA-256 not working\");\n            return 0; // should not happen\n        }\n\n        BinToHexAscii(sha256, U_SHA256_HASH_SIZE, sha256Str);\n\n        // add \"file_hash\" at the end\n        U_sstream_put_str(ss, \", \\\"file_hash\\\": \\\"\");\n        U_sstream_put_str(ss, sha256Str);\n        U_sstream_put_str(ss, \"\\\"}\");\n        return ss->status == U_SSTREAM_OK;\n\n    }\n\n    return 0;\n}\n\nint REST_DDF_GetDescriptors(const ApiRequest &req, ApiResponse &rsp)\n{\n    // TEST call\n\n    // curl -vv 127.0.0.1:8090/api/12345/ddf/descriptors\n    // curl -vv 127.0.0.1:8090/api/12345/ddf/descriptors?next=<token>\n    unsigned reqCursor = 1;\n    unsigned curCursor = 1;\n    unsigned nextCursor = 0;\n    unsigned nRecords = 0;\n    unsigned maxRecords = 64;\n\n    auto url = req.hdr.url();\n\n    { // get page from query string if exist\n        U_SStream ss;\n        U_sstream_init(&ss, (void*)url.data(), (unsigned)url.size());\n\n        if (U_sstream_find(&ss, \"?next=\"))\n        {\n            U_sstream_find(&ss, \"=\");\n            ss.pos++;\n            long n = U_sstream_get_long(&ss);\n            if (ss.status == U_SSTREAM_OK && n > 0)\n            {\n                reqCursor = (unsigned)n;\n            }\n            else\n            {\n                rsp.httpStatus = HttpStatusBadRequest;\n                return REQ_READY_SEND;\n            }\n        }\n    }\n\n    unsigned maxResponseSize = 1 << 20;  // 1 MB\n    char *bundleData = SCRATCH_ALLOC(char*, MAX_BUNDLE_SIZE);\n    char *path = SCRATCH_ALLOC(char*, MAX_PATH_LENGTH);\n    char *rspData = SCRATCH_ALLOC(char*, maxResponseSize);\n\n    if (!bundleData || !path || !rspData)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    FS_Dir dir;\n    FS_File fp;\n    U_SStream ss;\n    U_SStream ssRsp;\n    unsigned basePathLength;\n\n    deCONZ::StorageLocation locations[2] = { deCONZ::DdfBundleUserLocation, deCONZ::DdfBundleLocation };\n\n    U_sstream_init(&ssRsp, rspData, maxResponseSize);\n    U_sstream_put_str(&ssRsp, \"{\");\n\n    for (int locIt = 0; locIt < 2; locIt++)\n    {\n        {\n            QString loc = deCONZ::getStorageLocation(locations[locIt]);\n            U_sstream_init(&ss, path, MAX_PATH_LENGTH);\n            U_sstream_put_str(&ss, qPrintable(loc));\n            basePathLength = ss.pos;\n        }\n\n        if (FS_OpenDir(&dir, path))\n        {\n            for (;FS_ReadDir(&dir);)\n            {\n                if (dir.entry.type != FS_TYPE_FILE)\n                    continue;\n\n                U_sstream_init(&ss, dir.entry.name, strlen(dir.entry.name));\n\n                if (U_sstream_find(&ss, \".ddf\") == 0 && U_sstream_find(&ss, \".ddb\") == 0)\n                    continue;\n\n                if (curCursor < reqCursor)\n                {\n                    curCursor++;\n                    continue;\n                }\n\n                if (nRecords < maxRecords)\n                {\n                    U_sstream_init(&ss, path, MAX_PATH_LENGTH);\n                    ss.pos = basePathLength; // reuse path and append the filename to existing base path\n                    U_sstream_put_str(&ss, \"/\");\n                    U_sstream_put_str(&ss, dir.entry.name);\n\n                    if (FS_OpenFile(&fp, FS_MODE_R, path))\n                    {\n                        long n = FS_ReadFile(&fp, bundleData, MAX_BUNDLE_SIZE);\n                        if (n > 32)\n                        {\n                            U_BStream bs;\n                            U_bstream_init(&bs, bundleData, (unsigned)n);\n                            if (WriteBundleDescriptorToResponse(&bs, &ssRsp, nRecords))\n                            {\n                                curCursor++;\n                                nRecords++;\n                            }\n                        }\n\n                        FS_CloseFile(&fp);\n                    }\n                }\n                else\n                {\n                    nextCursor = curCursor;\n                    break;\n                }\n\n                DBG_Printf(DBG_INFO, \"BUNDLE: %s\\n\", ss.str);\n            }\n\n            if (nextCursor != 0)\n            {\n                U_sstream_put_str(&ssRsp, \",\\\"next\\\":\");\n                U_sstream_put_long(&ssRsp, (long)nextCursor);\n            }\n\n            FS_CloseDir(&dir);\n        }\n    }\n\n    U_sstream_put_str(&ssRsp, \"}\");\n\n    rsp.httpStatus = HttpStatusOk;\n    rsp.str = ssRsp.str;\n\n    return REQ_READY_SEND;\n}\n\nint REST_DDF_GetBundle(const ApiRequest &req, ApiResponse &rsp)\n{\n    // TEST call\n    // curl -vv -O --remote-header-name 127.0.0.1:8090/api/12345/ddf/bundles/0a34938f63f0ccb40e1672799c898889989574f617c103fb64496e9ad78c29a2\n    // wget --content-disposition 127.0.0.1:8090/api/12345/ddf/bundles/0a34938f63f0ccb40e1672799c898889989574f617c103fb64496e9ad78c29a2\n\n    FS_File fp;\n    FS_Dir dir;\n    unsigned basePathLength;\n    char bundleHashStr[U_SHA256_HASH_SIZE * 2 + 1];\n\n    {\n        auto urlBundleHash = req.hdr.pathAt(4);\n\n        if (urlBundleHash.size() != (U_SHA256_HASH_SIZE * 2))\n        {\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n\n        U_memcpy(bundleHashStr, urlBundleHash.data(), U_SHA256_HASH_SIZE * 2);\n        bundleHashStr[U_SHA256_HASH_SIZE * 2] = '\\0';\n\n        if (!DDFB_SanitizeBundleHashString(bundleHashStr, U_SHA256_HASH_SIZE * 2))\n        {\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    unsigned maxFileNameLength = 72;\n    char *path = SCRATCH_ALLOC(char*, MAX_PATH_LENGTH);\n    char *fileName = SCRATCH_ALLOC(char*, maxFileNameLength);\n    rsp.bin = SCRATCH_ALLOC(char*, MAX_BUNDLE_SIZE);\n\n    if (!path || !fileName || !rsp.bin)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    {\n        U_SStream ssFileName;\n        U_sstream_init(&ssFileName, fileName, maxFileNameLength);\n        U_sstream_put_str(&ssFileName, bundleHashStr);\n        U_sstream_put_str(&ssFileName, \".ddb\");\n    }\n\n    deCONZ::StorageLocation locations[2] = { deCONZ::DdfBundleUserLocation, deCONZ::DdfBundleLocation };\n\n    for (int locIt = 0; locIt < 2; locIt++)\n    {\n        U_SStream ss;\n        {\n            QString loc = deCONZ::getStorageLocation(locations[locIt]);\n            U_sstream_init(&ss, path, MAX_PATH_LENGTH);\n            U_sstream_put_str(&ss, qPrintable(loc));\n            basePathLength = ss.pos;\n        }\n\n        if (FS_OpenDir(&dir, path))\n        {\n            for (;FS_ReadDir(&dir);)\n            {\n                if (dir.entry.type != FS_TYPE_FILE)\n                    continue;\n\n                U_sstream_init(&ss, dir.entry.name, strlen(dir.entry.name));\n\n                if (U_sstream_find(&ss, \".ddf\") == 0 && U_sstream_find(&ss, \".ddb\") == 0)\n                    continue;\n\n                U_sstream_init(&ss, path, MAX_PATH_LENGTH);\n                ss.pos = basePathLength; // reuse path and append the filename to existing base path\n                U_sstream_put_str(&ss, \"/\");\n                U_sstream_put_str(&ss, dir.entry.name);\n\n                if (FS_OpenFile(&fp, FS_MODE_R, path))\n                {\n                    long fileSize = FS_GetFileSize(&fp);\n                    if (fileSize > 0 && fileSize <= MAX_BUNDLE_SIZE)\n                    {\n                        if (FS_ReadFile(&fp, rsp.bin, fileSize) == fileSize)\n                        {\n                            U_BStream bs;\n                            uint8_t sha256[U_SHA256_HASH_SIZE];\n\n                            U_bstream_init(&bs, rsp.bin, fileSize);\n\n                            if (IsValidDDFBundle(&bs, sha256))\n                            {\n                                char sha256Str[(U_SHA256_HASH_SIZE * 2) + 1];\n                                BinToHexAscii(sha256, U_SHA256_HASH_SIZE, sha256Str);\n\n                                if (U_memcmp(bundleHashStr, sha256Str, U_SHA256_HASH_SIZE * 2) == 0)\n                                {\n                                    FS_CloseFile(&fp);\n                                    FS_CloseDir(&dir);\n\n                                    rsp.contentLength = (unsigned)fileSize;\n                                    rsp.fileName = fileName;\n                                    rsp.httpStatus = HttpStatusOk;\n                                    rsp.contentType = HttpContentOctetStream;\n                                    return REQ_READY_SEND;\n                                }\n                            }\n                        }\n                    }\n\n                    FS_CloseFile(&fp);\n                }\n            }\n\n            FS_CloseDir(&dir);\n        }\n    }\n\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE,\n                               QString(\"/ddf/bundles/%1\").arg(bundleHashStr),\n                               QString(\"resource, /ddf/bundles/%1, not available\").arg(bundleHashStr)));\n    }\n\n    return REQ_READY_SEND;\n}\n\nint REST_DDF_PostBundles(const ApiRequest &req, ApiResponse &rsp)\n{\n    ScratchMemWaypoint swp;\n\n    // general error response\n    const QVariantMap errInvalidData = errorToMap(ERR_INVALID_DDF_BUNDLE, \"/ddf/bundles\", \"body contains invalid DDF bundle(s) data\");\n    const QVariantMap errServiceNotAvailable = errorToMap(ERR_INTERNAL_ERROR, \"/ddf/bundles\", \"Internal error, can't process request\");\n\n    // TEST call\n    // curl -F 'data=@./starkvind_air_purifier_toolbox.ddb' 127.0.0.1:8090/api/12345/ddf/bundles\n\n    if (req.hdr.contentLength() < 32 || req.hdr.contentLength() > 512000)\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // TODO(mpi) upload via multipart/form-data should be moved to generic http handling\n\n    // Content-Type HTTP header contains the boundary:\n    //    \"Content-Type: multipart/form-data; boundary=------------------------Y8hknTumhcaM4YjkoVup1T\"\n\n    QLatin1String contentType = req.hdr.value(QLatin1String(\"Content-Type\"));\n\n    U_SStream ss;\n    U_sstream_init(&ss, (void*)contentType.data(), contentType.size());\n\n    if (U_sstream_starts_with(&ss, \"multipart/form-data\") == 0)\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errInvalidData);\n        return REQ_READY_SEND;\n    }\n\n    if (U_sstream_find(&ss, \"boundary=\") == 0) // no boundary marker?\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errInvalidData);\n        return REQ_READY_SEND;\n    }\n\n    if (U_sstream_find(&ss, \"=\") == 0)\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errInvalidData);\n        return REQ_READY_SEND;\n    }\n    ss.pos++;\n    const unsigned boundaryLen = ss.len - ss.pos;\n    //boundary = static_cast<char*>(ScratchMemAlloc((boundaryLen) + 8));\n    char *boundary = SCRATCH_ALLOC(char*, boundaryLen + 8);\n\n    if (!boundary)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        rsp.list.append(errServiceNotAvailable);\n        return REQ_READY_SEND;\n    }\n    U_memcpy(boundary, &ss.str[ss.pos], boundaryLen);\n    boundary[boundaryLen] = '\\0';\n\n    unsigned dataSize = req.hdr.contentLength() + 1;\n    if (MAX_BUNDLE_SIZE < dataSize)\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errInvalidData);\n        return REQ_READY_SEND;\n    }\n\n    char *data = SCRATCH_ALLOC(char*, dataSize);\n\n    if (!data)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        rsp.list.append(errServiceNotAvailable);\n        return REQ_READY_SEND;\n    }\n\n    unsigned binStart = 0;\n    unsigned binEnd = 0;\n    int n = req.sock->read(data, dataSize - 1);\n\n    if (n > 0)\n    {\n        data[dataSize - 1] = '\\0';\n\n        U_sstream_init(&ss, data, n);\n\n        if (U_sstream_find(&ss, boundary) == 0) // there might be a preample before the first boundary\n        {\n            rsp.httpStatus = HttpStatusBadRequest;\n            rsp.list.append(errInvalidData);\n            return REQ_READY_SEND;\n        }\n\n        // actual data starts behind first two CRLF\n        //\n        // --------------------------Y8hknTumhcaM4YjkoVup1T\n        // Content-Disposition: form-data; name=\"data\"; filename=\"steam.md\"\n        // Content-Type: application/octet-stream\n        // \\r\\n\\r\\n\n        if (U_sstream_find(&ss, \"\\r\\n\\r\\n\") == 0)\n        {\n            return REQ_NOT_HANDLED;\n        }\n\n        ss.pos += 4;\n        binStart = ss.pos;\n\n        if (U_sstream_find(&ss, boundary) == 0)\n        {\n            rsp.httpStatus = HttpStatusBadRequest;\n            rsp.list.append(errInvalidData);\n            return REQ_READY_SEND;\n        }\n\n        binEnd = ss.pos;\n    }\n\n    if (binStart < binEnd && (binEnd - binStart) > 16) // TODO use some reasonable min. size instead 16\n    {\n        if (data[binEnd - 1] == '-' && data[binEnd - 2] == '-')\n        {\n            binEnd -= 2; // end boundary preceeded by two dashes\n        }\n\n        if (data[binEnd - 1] == '\\n' && data[binEnd - 2] == '\\r')\n        {\n            binEnd -= 2; // end boundary also preceeded with CRLF\n        }\n\n        data[binEnd] = '\\0';\n\n        U_BStream bs;\n\n        U_bstream_init(&bs, &data[binStart], binEnd - binStart);\n\n        // unsigned char bundleHash[U_SHA256_HASH_SIZE] = {0};\n        // char bundleHashStr[(U_SHA256_HASH_SIZE * 2) + 1];\n\n        unsigned char *bundleHash = SCRATCH_ALLOC(unsigned char*, U_SHA256_HASH_SIZE);\n        char *bundleHashStr = SCRATCH_ALLOC(char*, (U_SHA256_HASH_SIZE * 2) + 1);\n\n        if (!bundleHash || !bundleHashStr)\n        {\n            rsp.httpStatus = HttpStatusServiceUnavailable;\n            rsp.list.append(errServiceNotAvailable);\n            return REQ_READY_SEND;\n        }\n\n\n        if (IsValidDDFBundle(&bs, bundleHash) == 0)\n        {\n            rsp.httpStatus = HttpStatusBadRequest;\n            rsp.list.append(errInvalidData);\n            return REQ_READY_SEND;\n        }\n\n        BinToHexAscii(bundleHash, U_SHA256_HASH_SIZE, bundleHashStr);\n        DBG_Printf(DBG_INFO, \"received %d bytes (binary: %u), bundle-hash: %s\\n\", n, binEnd - binStart, bundleHashStr);\n\n        QString loc = deCONZ::getStorageLocation(deCONZ::DdfBundleUserLocation);\n\n        FS_File fp;\n        char *bundlePath = SCRATCH_ALLOC(char*, MAX_PATH_LENGTH);\n\n        if (!bundlePath)\n        {\n            rsp.httpStatus = HttpStatusServiceUnavailable;\n            rsp.list.append(errServiceNotAvailable);\n            return REQ_READY_SEND;\n        }\n\n#if 1\n        // The file extension was changed from .ddf to .ddb in v2.27.4-beta.\n        // In case the same bundle with .ddf extension exists, the file will be deleted\n        // so that only a .ddb will exists.\n    {\n        {\n            U_SStream ssPath;\n            U_sstream_init(&ssPath, bundlePath, MAX_PATH_LENGTH);\n            U_sstream_put_str(&ssPath, qPrintable(loc));\n            U_sstream_put_str(&ssPath, \"/\");\n            U_sstream_put_str(&ssPath, bundleHashStr);\n            U_sstream_put_str(&ssPath, \".ddf\");\n        }\n\n        if (FS_OpenFile(&fp, FS_MODE_R, bundlePath))\n        {\n            FS_CloseFile(&fp);\n            FS_DeleteFile(bundlePath);\n        }\n    }\n#endif\n\n        {\n            U_SStream ssPath;\n            U_sstream_init(&ssPath, bundlePath, MAX_PATH_LENGTH);\n            U_sstream_put_str(&ssPath, qPrintable(loc));\n            U_sstream_put_str(&ssPath, \"/\");\n            U_sstream_put_str(&ssPath, bundleHashStr);\n            U_sstream_put_str(&ssPath, \".ddb\");\n        }\n\n        if (FS_OpenFile(&fp, FS_MODE_R, bundlePath))\n        {\n            FS_CloseFile(&fp);\n            // TODO alreadly exists, delete and create fresh one (might have different signatures)\n            FS_DeleteFile(bundlePath);\n        }\n\n        if (FS_OpenFile(&fp, FS_MODE_RW, bundlePath))\n        {\n            long n = FS_WriteFile(&fp, bs.data, bs.size);\n            FS_CloseFile(&fp);\n            if (n != bs.size)\n            {\n                rsp.httpStatus = HttpStatusServiceUnavailable;\n                rsp.list.append(errServiceNotAvailable);\n                return REQ_READY_SEND;\n            }\n\n            // notify device descriptions to trigger reload\n            DEV_DDF_BundleUpdated((uint8_t*)&data[binStart], binEnd - binStart);\n\n            DBG_Printf(DBG_INFO, \"DDF bundle written: %s\\n\", bundlePath);\n\n            rsp.httpStatus = HttpStatusOk;\n            QVariantMap result;\n            QVariantMap item;\n\n            item[\"id\"] = bundleHashStr;\n            result[\"success\"] = item;\n            rsp.list.append(result);\n            return REQ_READY_SEND;\n        }\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\nint REST_DDF_HandleApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    // GET /api/<apikey>/ddf/descriptors\n    if (req.hdr.pathComponentsCount() == 4 && req.hdr.httpMethod() == HttpGet && req.hdr.pathAt(3) == \"descriptors\")\n    {\n        return REST_DDF_GetDescriptors(req, rsp);\n    }\n\n    // GET /api/<apikey>/ddf/bundles/<sha256-hash>\n    if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpGet && req.hdr.pathAt(3) == \"bundles\")\n    {\n        return REST_DDF_GetBundle(req, rsp);\n    }\n\n    // POST /api/<apikey>/ddf/bundles\n    if (req.hdr.pathComponentsCount() == 4 && req.hdr.httpMethod() == HttpPost && req.hdr.pathAt(3) == \"bundles\")\n    {\n        return REST_DDF_PostBundles(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n"
        },
        {
          "name": "rest_ddf.h",
          "type": "blob",
          "size": 0.634765625,
          "content": "/*\n * Copyright (c) 2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_DDF_H\n#define REST_DDF_H\n\nclass ApiRequest;\nclass ApiResponse;\n\n/*! REST-API endpoint for DDF. */\nint REST_DDF_HandleApi(const ApiRequest &req, ApiResponse &rsp);\n\n/*! Callback for POST DDF bundle request to notify device description code\n    of updated bundle data.\n */\nvoid DEV_DDF_BundleUpdated(unsigned char *data, unsigned dataSize);\n\n#endif // REST_DDF_H\n"
        },
        {
          "name": "rest_devices.cpp",
          "type": "blob",
          "size": 38.7333984375,
          "content": "/*\n * Copyright (c) 2013-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n#include <QVariantMap>\n#include <QProcess>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"product_match.h\"\n#include \"database.h\"\n#include \"device_descriptions.h\"\n#include \"device_ddf_bundle.h\"\n#include \"deconz/u_assert.h\"\n#include \"deconz/u_sstream_ex.h\"\n#include \"deconz/u_memory.h\"\n#include \"rest_devices.h\"\n#include \"utils/scratchmem.h\"\n#include \"json.h\"\n#include \"crypto/mmohash.h\"\n#include \"utils/ArduinoJson.h\"\n#include \"utils/utils.h\"\n\nusing JsonDoc = StaticJsonDocument<1024 * 1024 * 2>; // 2 megabytes\n\n\nstatic void putJsonQVariantValue(JsonObject &obj, std::string key, const QVariant &value);\nstatic void putJsonArrayQVariantValue(JsonArray &arr, const QVariant &value);\n\n\nstatic RestDevicesPrivate *priv_;\n\nclass RestDevicesPrivate\n{\npublic:\n    JsonDoc json;\n\n    char jsonBuffer[1024 * 1024];\n};\n\nRestDevices::RestDevices(QObject *parent) :\n    QObject(parent)\n{\n    d = new RestDevicesPrivate;\n    priv_ = d;\n    plugin = qobject_cast<DeRestPluginPrivate*>(parent);\n    Q_ASSERT(plugin);\n}\n\nRestDevices::~RestDevices()\n{\n    priv_ = nullptr;\n    delete d;\n}\n\n/*! Devices REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint RestDevices::handleApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    // GET /api/<apikey>/devices\n    if (req.hdr.pathComponentsCount() == 3 && req.hdr.httpMethod() == HttpGet)\n    {\n        return getAllDevices(req, rsp);\n    }\n    // GET /api/<apikey>/devices/<uniqueid>\n    else if (req.hdr.pathComponentsCount() == 4 && req.hdr.httpMethod() == HttpGet)\n    {\n        return getDevice(req, rsp);\n    }\n    // PUT /api/<apikey>/devices/<uniqueid>/ddf/reload\n    else if (req.path.size() == 6 && req.hdr.method() == QLatin1String(\"PUT\") && req.path[4] == QLatin1String(\"ddf\") && req.path[5] == QLatin1String(\"reload\"))\n    {\n        return putDeviceReloadDDF(req, rsp);\n    }\n    // PUT /api/<apikey>/devices/<uniqueid>/ddf/policy\n    else if (req.path.size() == 6 && req.hdr.method() == QLatin1String(\"PUT\") && req.path[4] == QLatin1String(\"ddf\") && req.path[5] == QLatin1String(\"policy\"))\n    {\n        return putDeviceSetDDFPolicy(req, rsp);\n    }\n    // GET /api/<apikey>/devices/<uniqueid>/ddf\n    else if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpGet && req.hdr.pathAt(4) == QLatin1String(\"ddf\"))\n    {\n        return getDeviceDDF(req, rsp);\n    }\n    // GET /api/<apikey>/devices/<uniqueid>/ddffull\n    else if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpGet && req.hdr.pathAt(4) == QLatin1String(\"ddffull\"))\n    {\n        return getDeviceDDF(req, rsp);\n    }\n    // GET /api/<apikey>/devices/<uniuqueid>/introspect\n    else if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpGet && req.hdr.pathAt(4) == QLatin1String(\"introspect\"))\n    {\n        return RIS_GetDeviceIntrospect(req, rsp);\n    }\n    // GET /api/<apikey>/devices/<uniqueid>/[<prefix>/]<item>/introspect\n    else if (req.hdr.pathComponentsCount() > 5 && req.hdr.httpMethod() == HttpGet &&\n             req.hdr.pathAt(req.hdr.pathComponentsCount() - 1) == QLatin1String(\"introspect\"))\n    {\n        return RIS_GetDeviceItemIntrospect(req, rsp);\n    }\n    // PUT /api/<apikey>/devices/<uniqueid>/installcode\n    else if (req.hdr.pathComponentsCount() == 5 && req.hdr.httpMethod() == HttpPut && req.hdr.pathAt(4) == QLatin1String(\"installcode\"))\n    {\n        return putDeviceInstallCode(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\nstatic DeviceKey getDeviceKey(QLatin1String uniqueid)\n{\n    DeviceKey result = 0;\n    const char *str = uniqueid.data();\n\n    if (uniqueid.size() < 23)\n        return result;\n\n    // 00:11:22:33:44:55:66:77\n    for (int pos = 0; pos < 23; pos++)\n    {\n        uint64_t ch = (unsigned)str[pos];\n        if (ch == ':' && (pos % 3) == 2) // ensure color only every 3rd pos\n            continue;\n\n        result <<= 4;\n\n        if      (ch >= '0' && ch <= '9') ch = ch - '0';\n        else if (ch >= 'a' && ch <= 'f') ch = (ch - 'a') + 10;\n        else if (ch >= 'A' && ch <= 'F') ch = (ch - 'A') + 10;\n        else\n        {\n            result = 0;\n            break;\n        }\n\n        result |= (ch & 0x0F);\n    }\n\n    return result;\n}\n\n/*! Deletes a Sensor as a side effect it will be removed from the REST API\n    and a ZDP reset will be send if possible.\n */\nbool deleteSensor(Sensor *sensor, DeRestPluginPrivate *plugin)\n{\n    if (sensor && plugin && sensor->deletedState() == Sensor::StateNormal)\n    {\n        sensor->setDeletedState(Sensor::StateDeleted);\n        sensor->setNeedSaveDatabase(true);\n        sensor->setResetRetryCount(10);\n\n        enqueueEvent(Event(sensor->prefix(), REventDeleted, sensor->id()));\n        return true;\n    }\n\n    return false;\n}\n\n/*! Deletes a LightNode as a side effect it will be removed from the REST API\n    and a ZDP reset will be send if possible.\n */\nbool deleteLight(LightNode *lightNode, DeRestPluginPrivate *plugin)\n{\n    if (lightNode && plugin && lightNode->state() == LightNode::StateNormal)\n    {\n        lightNode->setState(LightNode::StateDeleted);\n        lightNode->setResetRetryCount(10);\n        lightNode->setNeedSaveDatabase(true);\n\n        // delete all group membership from light (todo this is messy)\n        for (auto &group : lightNode->groups())\n        {\n            //delete Light from all scenes.\n            plugin->deleteLightFromScenes(lightNode->id(), group.id);\n\n            //delete Light from all groups\n            group.actions &= ~GroupInfo::ActionAddToGroup;\n            group.actions |= GroupInfo::ActionRemoveFromGroup;\n            if (group.state != GroupInfo::StateNotInGroup)\n            {\n                group.state = GroupInfo::StateNotInGroup;\n            }\n        }\n\n        enqueueEvent(Event(lightNode->prefix(), REventDeleted, lightNode->id()));\n        return true;\n    }\n\n    return false;\n}\n\n/*! Deletes all resources related to a device from the REST API.\n */\nbool RestDevices::deleteDevice(quint64 extAddr)\n{\n    int count = 0;\n\n    for (auto &sensor : plugin->sensors)\n    {\n        if (sensor.address().ext() == extAddr && deleteSensor(&sensor, plugin))\n        {\n            count++;\n        }\n    }\n\n    for (auto &lightNode : plugin->nodes)\n    {\n        if (lightNode.address().ext() == extAddr && deleteLight(&lightNode, plugin))\n        {\n            count++;\n        }\n    }\n\n    if (count > 0)\n    {\n        plugin->queSaveDb(DB_SENSORS | DB_LIGHTS | DB_GROUPS | DB_SCENES, DB_SHORT_SAVE_DELAY);\n    }\n\n    // delete device entry, regardless if REST resources exists\n    plugin->deleteDeviceDb(generateUniqueId(extAddr, 0, 0));\n\n    enqueueEvent(Event(RDevices, REventDeleted, 0, extAddr));\n\n    return count > 0;\n}\n\nvoid RestDevices::handleEvent(const Event &event)\n{\n    if (event.resource() == RDevices && event.what() == REventDeleted)\n    {\n        DEV_RemoveDevice(plugin->m_devices, event.deviceKey());\n    }\n}\n\n/*! GET /api/<apikey>/devices\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint RestDevices::getAllDevices(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req)\n\n    rsp.httpStatus = HttpStatusOk;\n\n    for (const auto &d : plugin->m_devices)\n    {\n        Q_ASSERT(d);\n        rsp.list.push_back(d->item(RAttrUniqueId)->toString());\n    }\n\n    if (rsp.list.isEmpty())\n    {\n        rsp.str = QLatin1String(\"[]\"); // return empty list\n    }\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/devices/<uniqueid>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n\n    Unstable API to experiment: don't use in production!\n */\nint RestDevices::getDevice(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n\n    const auto deviceKey = extAddressFromUniqueId(req.hdr.pathAt(3));\n\n    Device *device = DEV_GetDevice(plugin->m_devices, deviceKey);\n\n    rsp.httpStatus = device ? HttpStatusOk : HttpStatusNotFound;\n\n    if (!device)\n    {\n        return REQ_READY_SEND;\n    }\n\n    const DeviceDescription &ddf = plugin->deviceDescriptions->get(device);\n\n    if (ddf.isValid())\n    {\n        rsp.map[\"productid\"] = ddf.product;\n    }\n\n    {\n        const ResourceItem *ddfPolicyItem = device->item(RAttrDdfPolicy);\n        if (ddfPolicyItem)\n        {\n            rsp.map[\"ddf_policy\"] = ddfPolicyItem->toString();\n        }\n    }\n\n    if (ddf.storageLocation == deCONZ::DdfBundleLocation || ddf.storageLocation == deCONZ::DdfBundleUserLocation)\n    {\n        const ResourceItem *ddfHashItem = device->item(RAttrDdfHash);\n        if (ddfHashItem && ddfHashItem->toCString()[0] != '\\0')\n        {\n            rsp.map[\"ddf_hash\"] = ddfHashItem->toString();\n        }\n    }\n\n    QVariantList subDevices;\n\n    for (const auto &sub : device->subDevices())\n    {\n        QVariantMap map;\n\n        for (int i = 0; i < sub->itemCount(); i++)\n        {\n            auto *item = sub->itemForIndex(i);\n            Q_ASSERT(item);\n\n            if (item->descriptor().suffix == RStateLastUpdated ||\n                item->descriptor().suffix == RAttrId)\n            {\n                continue;\n            }\n\n            if (!item->isPublic())\n            {\n                continue;\n            }\n\n            const auto ls = QString(QLatin1String(item->descriptor().suffix)).split(QLatin1Char('/'));\n\n            if (ls.size() == 2)\n            {\n                if (item->descriptor().suffix == RAttrLastSeen || item->descriptor().suffix == RAttrLastAnnounced ||\n                    item->descriptor().suffix == RAttrManufacturerName || item->descriptor().suffix == RAttrModelId ||\n                    item->descriptor().suffix == RAttrSwVersion || item->descriptor().suffix == RAttrName)\n                {\n                    if (!rsp.map.contains(ls.at(1)))\n                    {\n                        rsp.map[ls.at(1)] = item->toString(); // top level attribute\n                    }\n                }\n                else if (ls.at(0) == QLatin1String(\"attr\"))\n                {\n                    map[ls.at(1)] = item->toVariant(); // sub device top level attribute\n                }\n                else\n                {\n                    QVariantMap m2;\n                    if (map.contains(ls.at(0)))\n                    {\n                        m2 = map[ls.at(0)].toMap();\n                    }\n\n                    QVariantMap itemMap;\n\n                    itemMap[QLatin1String(\"value\")] = item->toVariant();\n\n                    QDateTime dt = item->lastChanged().isValid() ? item->lastChanged() : item->lastSet();\n                    // UTC in msec resolution\n                    dt.setOffsetFromUtc(0);\n                    itemMap[QLatin1String(\"lastupdated\")] = dt.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\"));\n\n\n                    m2[ls.at(1)] = itemMap;\n                    map[ls.at(0)] = m2;\n                }\n            }\n        }\n\n        subDevices.push_back(map);\n    }\n\n    rsp.map[\"uniqueid\"] = device->item(RAttrUniqueId)->toString();\n    rsp.map[\"subdevices\"] = subDevices;\n\n    return REQ_READY_SEND;\n}\n\nstatic void putJsonArrayQVariantValue(JsonArray &arr, const QVariant &value)\n{\n    if (value.type() == QVariant::String)\n    {\n        arr.add(value.toString().toStdString());\n    }\n    else if (value.type() == QVariant::Bool)\n    {\n        arr.add(value.toBool());\n    }\n    else if (value.type() == QVariant::Double)\n    {\n        arr.add(value.toDouble());\n    }\n    else if (value.type() == QVariant::Int)\n    {\n        arr.add(value.toInt());\n    }\n    else if (value.type() == QVariant::UInt)\n    {\n        arr.add(value.toUInt());\n    }\n    else if (value.type() == QVariant::ULongLong)\n    {\n        arr.add(uint64_t(value.toULongLong()));\n    }\n    else if (value.type() == QVariant::LongLong)\n    {\n        arr.add(int64_t(value.toLongLong()));\n    }\n    else if (value.type() == QVariant::List)\n    {\n        JsonArray arr1 = arr.createNestedArray();\n        const QVariantList ls = value.toList();\n\n        for (const auto &v : ls)\n        {\n            putJsonArrayQVariantValue(arr1, v);\n        }\n    }\n    else if (value.type() == QVariant::Map)\n    {\n        JsonObject obj1 = arr.createNestedObject();\n        const QVariantMap map = value.toMap();\n\n        auto i = map.constBegin();\n        const auto end = map.constEnd();\n        for (; i != end; ++i)\n        {\n            putJsonQVariantValue(obj1, i.key().toStdString(), i.value());\n        }\n    }\n    else\n    {\n        DBG_Printf(DBG_DDF, \"DDF TODO %s:%d arr add type: %s\\n\", __FILE__, __LINE__, QVariant::typeToName(value.type()));\n    }\n}\n\nstatic void putJsonQVariantValue(JsonObject &obj, std::string key, const QVariant &value)\n{\n    if (value.type() == QVariant::String)\n    {\n        obj[key] = value.toString().toStdString();\n    }\n    else if (value.type() == QVariant::Bool)\n    {\n        obj[key] = value.toBool();\n    }\n    else if (value.type() == QVariant::Double)\n    {\n        obj[key] = value.toDouble();\n    }\n    else if (value.type() == QVariant::Int)\n    {\n        obj[key] = value.toInt();\n    }\n    else if (value.type() == QVariant::UInt)\n    {\n        obj[key] = value.toUInt();\n    }\n    else if (value.type() == QVariant::ULongLong)\n    {\n        obj[key] = uint64_t(value.toULongLong());\n    }\n    else if (value.type() == QVariant::LongLong)\n    {\n        obj[key] = int64_t(value.toLongLong());\n    }\n    else if (value.type() == QVariant::List)\n    {\n        JsonArray arr = obj.createNestedArray(key);\n        const QVariantList ls = value.toList();\n\n        for (const auto &v : ls)\n        {\n            putJsonArrayQVariantValue(arr, v);\n        }\n    }\n    else if (value.type() == QVariant::Map)\n    {\n        JsonObject obj1 = obj.createNestedObject(key);\n        const QVariantMap map = value.toMap();\n\n        auto i = map.constBegin();\n        const auto end = map.constEnd();\n        for (; i != end; ++i)\n        {\n            putJsonQVariantValue(obj1, i.key().toStdString(), i.value());\n        }\n    }\n    else\n    {\n        DBG_Printf(DBG_DDF, \"DDF TODO %s:%d obj.%s type: %s\\n\", __FILE__, __LINE__, key.c_str(), QVariant::typeToName(value.type()));\n    }\n}\n\nstatic void putItemParameter(JsonObject &item, const char *name, const QVariantMap &param)\n{\n    JsonObject parse = item.createNestedObject(name);\n\n    const auto end = param.constEnd();\n    for (auto cur = param.constBegin(); cur != end; cur++)\n    {\n        if (cur.key() == QLatin1String(\"eval\"))\n        {\n            // no script cached 'eval' value\n            if (!param.contains(QLatin1String(\"script\")))\n            {\n                putJsonQVariantValue(parse, \"eval\", cur.value());\n            }\n        }\n        else\n        {\n            putJsonQVariantValue(parse, cur.key().toStdString(), cur.value());\n        }\n    }\n}\n\nbool ddfSerializeV1(JsonDoc &doc, const DeviceDescription &ddf, char *buf, size_t bufsize, bool ddfFull, bool prettyPrint)\n{\n    doc.clear();\n\n    doc[\"schema\"] = \"devcap1.schema.json\";\n\n    if (ddf.manufacturerNames.size() == 1)\n    {\n        doc[\"manufacturername\"] = ddf.manufacturerNames.front().toStdString();\n    }\n    else\n    {\n        JsonArray arr = doc.createNestedArray(\"manufacturername\");\n        for (const QString &i : ddf.manufacturerNames)\n        {\n            arr.add(i.toStdString());\n        }\n    }\n\n    if (ddf.modelIds.size() == 1)\n    {\n        doc[\"modelid\"] = ddf.modelIds.front().toStdString();\n    }\n    else\n    {\n        JsonArray arr = doc.createNestedArray(\"modelid\");\n        for (const QString &i : ddf.modelIds)\n        {\n            arr.add(i.toStdString());\n        }\n    }\n\n    if (!ddf.vendor.isEmpty())\n    {\n        doc[\"vendor\"] = ddf.vendor.toStdString();\n    }\n\n    if (!ddf.product.isEmpty())\n    {\n        doc[\"product\"] = ddf.product.toStdString();\n    }\n\n    if (ddf.sleeper >= 0)\n    {\n        doc[\"sleeper\"] = ddf.sleeper > 0;\n    }\n\n    doc[\"status\"] = ddf.status.toStdString();\n\n    if (!ddf.matchExpr.isEmpty())\n    {\n        doc[\"matchexpr\"] = ddf.matchExpr.toStdString();\n    }\n\n    if (!ddf.path.isEmpty())\n    {\n        int idx = ddf.path.indexOf(QLatin1String(\"/devices/\"));\n\n        if (idx >= 0)\n        {\n            doc[\"path\"] = ddf.path.mid(idx).toStdString();\n        }\n    }\n\n    {\n        JsonArray subDevices = doc.createNestedArray(\"subdevices\");\n\n        for (const DeviceDescription::SubDevice &sub : ddf.subDevices)\n        {\n            JsonObject subDevice = subDevices.createNestedObject();\n\n            subDevice[\"type\"] = sub.type.toStdString();\n            subDevice[\"restapi\"] = sub.restApi.toStdString();\n\n            JsonArray uuid = subDevice.createNestedArray(\"uuid\");\n            for (const QString &i : sub.uniqueId)\n            {\n                uuid.add(i.toStdString());\n            }\n\n            if (!sub.meta.isEmpty())\n            {\n                putJsonQVariantValue(subDevice, \"meta\", sub.meta);\n            }\n\n            if (isValid(sub.fingerPrint))\n            {\n                // \"fingerprint\": { \"profile\": \"0x0104\", \"device\": \"0x0107\", \"endpoint\": \"0x02\", \"in\": [\"0x0000\", \"0x0001\", \"0x0402\"] },\n\n                char buf[16];\n\n                JsonObject fp = subDevice.createNestedObject(\"fingerprint\");\n\n                snprintf(buf, sizeof(buf), \"0x%04X\", sub.fingerPrint.profileId);\n                fp[\"profile\"] = std::string(buf);\n\n                snprintf(buf, sizeof(buf), \"0x%04X\", sub.fingerPrint.deviceId);\n                fp[\"device\"] = std::string(buf);\n\n                snprintf(buf, sizeof(buf), \"0x%02X\", sub.fingerPrint.endpoint);\n                fp[\"endpoint\"] = std::string(buf);\n\n                if (!sub.fingerPrint.inClusters.empty())\n                {\n                    JsonArray inClusters = fp.createNestedArray(\"in\");\n\n                    for (const auto clusterId : sub.fingerPrint.inClusters)\n                    {\n                        snprintf(buf, sizeof(buf), \"0x%04X\", clusterId);\n                        inClusters.add(std::string(buf));\n                    }\n                }\n\n                if (!sub.fingerPrint.outClusters.empty())\n                {\n                    JsonArray outClusters = fp.createNestedArray(\"out\");\n\n                    for (const auto clusterId : sub.fingerPrint.outClusters)\n                    {\n                        snprintf(buf, sizeof(buf), \"0x%04X\", clusterId);\n                        outClusters.add(std::string(buf));\n                    }\n                }\n            }\n\n            JsonArray items = subDevice.createNestedArray(\"items\");\n\n            for (const DeviceDescription::Item &i : sub.items)\n            {\n                JsonObject item = items.createNestedObject();\n\n                if (i.isImplicit && !ddfFull)\n                {\n                    item[\"name\"] = i.name.c_str();\n                    continue;\n                }\n\n                item[\"name\"] = i.name.c_str();\n                if (!i.isPublic) { item[\"public\"] = false; }\n                if (i.awake)     { item[\"awake\"] = true; }\n\n                if (!i.description.isEmpty())\n                {\n                    item[\"description\"] = i.description.toStdString();\n                }\n\n                if (i.refreshInterval > 0)\n                {\n                    item[\"refresh.interval\"] = i.refreshInterval;\n                }\n\n                if (!i.isStatic)\n                {\n                    if (!i.readParameters.isNull()  && (ddfFull || !i.isGenericRead))  { putItemParameter(item, \"read\", i.readParameters.toMap()); }\n                    if (!i.writeParameters.isNull() && (ddfFull || !i.isGenericWrite)) { putItemParameter(item, \"write\", i.writeParameters.toMap()); }\n                    if (!i.parseParameters.isNull() && (ddfFull || !i.isGenericParse)) { putItemParameter(item, \"parse\", i.parseParameters.toMap()); }\n                }\n                if (!i.defaultValue.isNull())\n                {\n                    if (i.isStatic)\n                    {\n                        putJsonQVariantValue(item, \"static\", i.defaultValue);\n                    }\n                    else\n                    {\n                        putJsonQVariantValue(item, \"default\", i.defaultValue);\n                    }\n                }\n            }\n        }\n    }\n\n    if (!ddf.bindings.empty())\n    {\n        JsonArray bindings = doc.createNestedArray(\"bindings\");\n\n        for (const DDF_Binding &bnd : ddf.bindings)\n        {\n            JsonObject binding = bindings.createNestedObject();\n\n            if      (bnd.isUnicastBinding) { binding[\"bind\"] = \"unicast\"; }\n            else if (bnd.isGroupBinding)\n            {\n                binding[\"bind\"] = \"groupcast\";\n                binding[\"config.group\"] = bnd.configGroup;\n            }\n\n            binding[\"src.ep\"] = bnd.srcEndpoint;\n\n            if (bnd.dstEndpoint > 0) { binding[\"dst.ep\"] = bnd.dstEndpoint; }\n\n            char buf[16];\n\n            snprintf(buf, sizeof(buf), \"0x%04X\", bnd.clusterId);\n\n            binding[\"cl\"] = std::string(buf);\n\n            if (!bnd.reporting.empty())\n            {\n                JsonArray reportings = binding.createNestedArray(\"report\");\n\n                for (const DDF_ZclReport &rep: bnd.reporting)\n                {\n                    JsonObject report = reportings.createNestedObject();\n\n                    snprintf(buf, sizeof(buf), \"0x%04X\", rep.attributeId);\n                    report[\"at\"] = std::string(buf);\n\n                    // TODO ZCLDB names\n                    snprintf(buf, sizeof(buf), \"0x%02X\", rep.dataType);\n                    report[\"dt\"] = std::string(buf);\n\n                    if (rep.manufacturerCode > 0)\n                    {\n                        snprintf(buf, sizeof(buf), \"0x%04X\", rep.manufacturerCode);\n                        report[\"mf\"] = std::string(buf);\n                    }\n\n                    report[\"min\"] = rep.minInterval;\n                    report[\"max\"] = rep.maxInterval;\n\n                    if (rep.reportableChange > 0)\n                    {\n                        snprintf(buf, sizeof(buf), \"0x%08X\", rep.reportableChange); // TODO proper length\n                        report[\"change\"] = std::string(buf);\n                    }\n                }\n            }\n        }\n    }\n\n    size_t sz = 0;\n\n    if (prettyPrint)\n    {\n        sz = serializeJsonPretty(doc, buf, bufsize);\n    }\n    else\n    {\n        sz = serializeJson(doc, buf, bufsize);\n    }\n    U_ASSERT(sz < bufsize);\n\n    DBG_Printf(DBG_INFO, \"JSON serialized size %d\\n\", int(sz));\n\n    return sz > 0 && sz < bufsize;\n}\n\nQString DDF_ToJsonPretty(const DeviceDescription &ddf)\n{\n    QString result;\n\n    if (priv_ && ddfSerializeV1(priv_->json, ddf, priv_->jsonBuffer, sizeof(priv_->jsonBuffer), false, true))\n    {\n        result = priv_->jsonBuffer;\n    }\n\n    return result;\n}\n\nint RestDevices::getDeviceDDF(const ApiRequest &req, ApiResponse &rsp)\n{\n    const auto deviceKey = extAddressFromUniqueId(req.hdr.pathAt(3));\n\n    bool ddfFull = req.hdr.pathAt(4) == QLatin1String(\"ddffull\");\n\n    Device *device = DEV_GetDevice(plugin->m_devices, deviceKey);\n\n    rsp.httpStatus = device ? HttpStatusOk : HttpStatusNotFound;\n\n    if (!device)\n    {\n        return REQ_READY_SEND;\n    }\n\n    DeviceDescription ddf = DeviceDescriptions::instance()->get(device);\n\n    if (ddf.isValid())\n    {\n        if (ddf.bindings.empty())\n        {\n            ddf.bindings = device->bindings();\n        }\n\n        if (ddfSerializeV1(d->json, ddf, d->jsonBuffer, sizeof(d->jsonBuffer), ddfFull, false))\n        {\n            rsp.str = d->jsonBuffer;\n        }\n        else\n        {\n            // error\n        }\n    }\n    else\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.str = QLatin1String(\"{}\");\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/devices/<uniqueid>/introspect\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n\n    Unstable API to experiment: don't use in production!\n */\nint RIS_GetDeviceIntrospect(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req)\n    rsp.str = QLatin1String(\"{\\\"introspect\\\": false}\");\n    return REQ_READY_SEND;\n}\n\n/*! Returns string form of a ApiDataType.\n */\nQLatin1String RIS_DataTypeToString(ApiDataType type)\n{\n    static const std::array<QLatin1String, 14> map = {\n         QLatin1String(\"unknown\"),\n         QLatin1String(\"bool\"),\n         QLatin1String(\"uint8\"),\n         QLatin1String(\"uint16\"),\n         QLatin1String(\"uint32\"),\n         QLatin1String(\"uint64\"),\n         QLatin1String(\"int8\"),\n         QLatin1String(\"int16\"),\n         QLatin1String(\"int32\"),\n         QLatin1String(\"int64\"),\n         QLatin1String(\"double\"),\n         QLatin1String(\"string\"),\n         QLatin1String(\"time\"),\n         QLatin1String(\"timepattern\")\n    };\n\n    if (type < map.size())\n    {\n\n        return map[type];\n    }\n\n    return map[0];\n}\n\n/*! Returns string form of \\c state/buttonevent action part.\n */\nQLatin1String RIS_ButtonEventActionToString(int buttonevent)\n{\n    const uint action = buttonevent % 1000;\n\n    static std::array<QLatin1String, 11> map = {\n         QLatin1String(\"INITIAL_PRESS\"),\n         QLatin1String(\"HOLD\"),\n         QLatin1String(\"SHORT_RELEASE\"),\n         QLatin1String(\"LONG_RELEASE\"),\n         QLatin1String(\"DOUBLE_PRESS\"),\n         QLatin1String(\"TREBLE_PRESS\"),\n         QLatin1String(\"QUADRUPLE_PRESS\"),\n         QLatin1String(\"SHAKE\"),\n         QLatin1String(\"DROP\"),\n         QLatin1String(\"TILT\"),\n         QLatin1String(\"MANY_PRESS\")\n    };\n\n    if (action < map.size())\n    {\n\n        return map[action];\n    }\n\n    return QLatin1String(\"UNKNOWN\");\n}\n\n/*! Returns generic introspection for a \\c ResourceItem.\n */\nQVariantMap RIS_IntrospectGenericItem(const ResourceItemDescriptor &rid)\n{\n    QVariantMap result;\n\n    result[QLatin1String(\"type\")] = RIS_DataTypeToString(rid.type);\n\n    if (rid.validMin != 0 || rid.validMax != 0)\n    {\n        result[QLatin1String(\"minval\")] = rid.validMin;\n        result[QLatin1String(\"maxval\")] = rid.validMax;\n    }\n\n    return result;\n}\n\n/*! Returns introspection for \\c state/buttonevent.\n */\nQVariantMap RIS_IntrospectButtonEventItem(const ResourceItemDescriptor &rid, const Resource *r)\n{\n    QVariantMap result = RIS_IntrospectGenericItem(rid);\n\n    Q_ASSERT(r->prefix() == RSensors);\n    const auto *sensor = static_cast<const Sensor*>(r);\n\n    if (!sensor)\n    {\n        return result;\n    }\n\n    const deCONZ::Node *node = getCoreNode(sensor->address().ext(), deCONZ::ApsController::instance());\n\n    if (!node)\n    {\n        return result;\n    }\n\n    // TODO dependency on plugin needs to be removed to make this testable\n    const auto &buttonMapButtons = plugin->buttonMeta;\n    const auto &buttonMapData = plugin->buttonMaps;\n    const auto &buttonMapForModelId = plugin->buttonProductMap;\n\n    const auto *buttonData = BM_ButtonMapForProduct(productHash(r), buttonMapData, buttonMapForModelId);\n\n    if (!buttonData)\n    {\n        return result;\n    }\n\n    int buttonBits = 0; // button 1 = 1 << 1, button 2 = 1 << 2 ...\n\n    {\n        QVariantMap values;\n\n        for (const auto &btn : buttonData->buttons)\n        {\n\n            const auto sd = std::find_if(node->simpleDescriptors().cbegin(), node->simpleDescriptors().cend(),\n                                         [&btn](const deCONZ::SimpleDescriptor &x){ return x.endpoint() == btn.endpoint; });\n\n            if (sd == node->simpleDescriptors().cend())\n            {\n                continue;\n            }\n\n            buttonBits |= 1 << int(btn.button / 1000);\n\n            QVariantMap m;\n            m[QLatin1String(\"button\")] = int(btn.button / 1000);\n            m[QLatin1String(\"action\")] = RIS_ButtonEventActionToString(btn.button);\n            values[QString::number(btn.button)] = m;\n        }\n        result[QLatin1String(\"values\")] = values;\n    }\n\n    const auto buttonsMeta = std::find_if(buttonMapButtons.cbegin(), buttonMapButtons.cend(),\n                                          [buttonData](const auto &meta){ return meta.buttonMapRef.hash == buttonData->buttonMapRef.hash; });\n\n    QVariantMap buttons;\n\n    if (buttonsMeta != buttonMapButtons.cend())\n    {\n        for (const auto &button : buttonsMeta->buttons)\n        {\n            if (buttonBits & (1 << button.button))\n            {\n                QVariantMap m;\n                m[QLatin1String(\"name\")] = button.name;\n                buttons[QString::number(button.button)] = m;\n            }\n        }\n    }\n    else // fallback if no \"buttons\" is defined in the button map, generate a generic one\n    {\n        for (int i = 1 ; i < 32; i++)\n        {\n            if (buttonBits & (1 << i))\n            {\n                QVariantMap m;\n                m[QLatin1String(\"name\")] = QString(\"Button %1\").arg(i);\n                buttons[QString::number(i)] = m;\n            }\n        }\n    }\n\n    result[QLatin1String(\"buttons\")] = buttons;\n\n    return result;\n}\n\n/*! /api/<apikey>/devices/<uniqueid>/[<prefix>/]<item>/introspect\n\n    Fills ResourceItemDescriptor \\p rid for the '[<prefix>/]<item>' part of the URL.\n\n    \\note The verification that the URL has enough segments must be done by the caller.\n*/\nbool RIS_ResourceItemDescriptorFromHeader(const QHttpRequestHeader &hdr, ResourceItemDescriptor *rid)\n{\n    const auto last = hdr.pathAt(hdr.pathComponentsCount() - 2);\n    const char *beg = hdr.pathAt(4).data();\n    const char *end = last.data() + last.size();\n\n    if (beg && end && beg < end)\n    {\n        const QLatin1String suffix(beg, end - beg);\n\n        if (getResourceItemDescriptor(suffix, *rid))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*! Returns the Resource for a given \\p uniqueid.\n */\nstatic Resource *resourceForUniqueId(const QLatin1String &uniqueid)\n{\n    Resource *r = plugin->getResource(RSensors, uniqueid);\n\n    if (!r)\n    {\n        plugin->getResource(RLights, uniqueid);\n    }\n\n    return r;\n}\n\n/*! GET /api/<apikey>/devices/<uniqueid>/[<prefix>/]<item>/introspect\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint RIS_GetDeviceItemIntrospect(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n    const Resource *r = resourceForUniqueId(req.hdr.pathAt(3));\n\n    if (!r)\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    ResourceItemDescriptor rid;\n\n    if (!RIS_ResourceItemDescriptorFromHeader(req.hdr, &rid))\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    if (rid.suffix == RStateButtonEvent)\n    {\n        rsp.map = RIS_IntrospectButtonEventItem(rid, r);\n    }\n    else\n    {\n        rsp.map = RIS_IntrospectGenericItem(rid);\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! PUT /api/<apikey>/devices/<uniqueid>/installcode\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n\n    Adds an Zigbee 3.0 Install Code for a device to let it securely join.\n    Unstable API to experiment: don't use in production!\n */\nint RestDevices::putDeviceInstallCode(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 5);\n\n    bool ok;\n    const QString &uniqueid = req.path[3];\n\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/devices/%1/installcode\").arg(uniqueid), QString(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    // installcode\n    if (map.contains(\"installcode\"))\n    {\n        std::string installCode = map[\"installcode\"].toString().toStdString();\n\n        if (map[\"installcode\"].type() == QVariant::String && !installCode.empty())\n        {\n            char mmoHashHex[128] = {0};\n            std::vector<unsigned char> mmoHash;\n\n            if (!CRYPTO_GetMmoHashFromInstallCode(installCode, mmoHash))\n            {\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QLatin1String(\"/devices\"), QLatin1String(\"internal error, failed to calc mmo hash, occured\")));\n                rsp.httpStatus = HttpStatusServiceUnavailable;\n                return REQ_READY_SEND;\n            }\n\n#if DECONZ_LIB_VERSION >= 0x010B00\n            QVariantMap m;\n            m[\"mac\"] = uniqueid.toULongLong(&ok, 16);\n\n            if (mmoHash.size() == 16)\n            {\n                DBG_HexToAscii(&mmoHash[0], mmoHash.size(), reinterpret_cast<unsigned char*>(&mmoHashHex[0]));\n            }\n            m[\"key\"] = &mmoHashHex[0];\n            if (ok && strlen(mmoHashHex) == 32)\n            {\n                ok = deCONZ::ApsController::instance()->setParameter(deCONZ::ParamLinkKey, m);\n            }\n#endif\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[\"installcode\"] = installCode.data();\n            rspItemState[\"mmohash\"] = &mmoHashHex[0];\n            rspItem[\"success\"] = rspItemState;\n            rsp.list.append(rspItem);\n            rsp.httpStatus = HttpStatusOk;\n            return REQ_READY_SEND;\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/devices\"), QString(\"invalid value, %1, for parameter, installcode\").arg(installCode.data())));\n            rsp.httpStatus = HttpStatusBadRequest;\n        }\n    }\n    else\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/devices/%1/installcode\").arg(uniqueid), QString(\"missing parameters in body\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n    }\n\n    return REQ_READY_SEND;\n}\n\nint RestDevices::putDeviceReloadDDF(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 6);\n\n    rsp.httpStatus = HttpStatusOk;\n\n    QLatin1String uniqueId = req.hdr.pathAt(3);\n    DeviceKey deviceKey = getDeviceKey(uniqueId);\n\n    if (deviceKey)\n    {\n        Device *device = DEV_GetDevice(plugin->m_devices, deviceKey);\n        if (device)\n        {\n            DeviceDescriptions::instance()->reloadAllRawJsonAndBundles(device);\n        }\n\n        QVariantMap rspItem;\n        QVariantMap rspItemState;\n        rspItemState[\"reload\"] = req.path.at(3);\n        rspItem[\"success\"] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusOk;\n    }\n    else\n    {\n        // TODO\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*\n\n    curl -X PUT -H \"Content-Type: application/json\" -d '{\"policy\": \"nope\", \"hash\":\"value\"}' 127.0.0.1:8090/api/12345/devices/00.99/ddf/policy\n\n\n*/\nint RestDevices::putDeviceSetDDFPolicy(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 6);\n\n    Device *device = nullptr;\n    QLatin1String uniqueId = req.hdr.pathAt(3);\n    DeviceKey deviceKey = getDeviceKey(uniqueId);\n\n    const QByteArray content = req.content.toUtf8();\n    const QString errAddr = QString(\"/devices/%1/ddf/policy\").arg(uniqueId);\n\n    U_SStream ss;\n\n    cj_ctx cj;\n    std::array<cj_token, 16> tokens;\n    cj_token_ref refParent = 0;\n    cj_token_ref refPolicy;\n\n    char policyBuf[32];\n    char bundleHashBuf[96];\n    unsigned bundleHashLen = 0;\n    unsigned policyLen = 0;\n\n    if (deviceKey != 0)\n    {\n        device = DEV_GetDevice(plugin->m_devices, deviceKey);\n    }\n\n    if (!device)\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, errAddr, QString(\"resource, /devices/%1, not available\").arg(uniqueId)));\n\n        return REQ_READY_SEND;\n    }\n\n    cj_parse_init(&cj, content.data(), (cj_size)content.size(), tokens.data(), tokens.size());\n    cj_parse(&cj);\n\n    if (cj.status != CJ_OK)\n    {\n\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, errAddr, \"body contains invalid JSON\"));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n\n    if (cj_copy_value(&cj, policyBuf, sizeof(policyBuf), refParent, \"policy\") == 0)\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, errAddr, \"missing parameters in body\"));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    /*\n     * Verify it's a valid policy value.\n     */\n\n    policyLen = U_strlen(policyBuf);\n    const char *validValues[5] = { \"latest_prefer_stable\", \"latest\", \"pin\", \"raw_json\", nullptr };\n\n    U_sstream_init(&ss, policyBuf, policyLen);\n\n    int v = 0;\n    for (; validValues[v]; v++)\n    {\n        unsigned len = U_strlen(validValues[v]);\n        if (policyLen == len && U_sstream_starts_with(&ss, validValues[v]))\n            break;\n    }\n\n    if (validValues[v] == nullptr)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, errAddr, QString(\"invalid value, %1, for parameter, policy\").arg(policyBuf)));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    /*\n     * The 'pin' policy requires a 'hash' value to be specified.\n     */\n\n    if (U_sstream_starts_with(&ss, \"pin\"))\n    {\n        if (cj_copy_value(&cj, bundleHashBuf, sizeof(bundleHashBuf), refParent, \"hash\") == 0)\n        {\n            rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, errAddr, \"missing parameters in body\"));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n\n        bundleHashLen = U_strlen(bundleHashBuf);\n        if (!DDFB_SanitizeBundleHashString(bundleHashBuf, bundleHashLen))\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, errAddr, QString(\"invalid value, %1, for parameter, hash\").arg(bundleHashBuf)));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    bool needReload = false;\n    ResourceItem *ddfPolicyItem = device->item(RAttrDdfPolicy);\n    ResourceItem *ddfHashItem = device->item(RAttrDdfHash);\n    U_ASSERT(ddfPolicyItem);\n    U_ASSERT(ddfHashItem);\n\n    if (!ddfPolicyItem->equalsString(policyBuf, policyLen))\n    {\n        ddfPolicyItem->setValue(policyBuf, policyLen, ResourceItem::SourceApi);\n        needReload = true;\n\n        DB_ResourceItem2 dbItem;\n        dbItem.name = RAttrDdfPolicy;\n        U_memcpy(dbItem.value, policyBuf, policyLen);\n        dbItem.value[policyLen] = '\\0';\n        dbItem.valueSize = policyLen;\n        dbItem.timestampMs = ddfPolicyItem->lastSet().toMSecsSinceEpoch();\n        DB_StoreDeviceItem(device->deviceId(), dbItem);\n    }\n\n    if (bundleHashLen != 0 && !ddfHashItem->equalsString(bundleHashBuf, bundleHashLen))\n    {\n        ddfHashItem->setValue(bundleHashBuf, bundleHashLen, ResourceItem::SourceApi);\n        needReload = true;\n\n        DB_ResourceItem2 dbItem;\n        dbItem.name = RAttrDdfHash;\n        U_memcpy(dbItem.value, bundleHashBuf, bundleHashLen);\n        dbItem.value[bundleHashLen] = '\\0';\n        dbItem.valueSize = bundleHashLen;\n        dbItem.timestampMs = ddfHashItem->lastSet().toMSecsSinceEpoch();\n        DB_StoreDeviceItem(device->deviceId(), dbItem);\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    {\n        QVariantMap result;\n        QVariantMap item;\n\n        item[QString(\"/devices/%1/ddf/policy\").arg(uniqueId)] = policyBuf;\n        result[\"success\"] = item;\n        rsp.list.append(result);\n    }\n\n    if (bundleHashLen != 0)\n    {\n        QVariantMap result;\n        QVariantMap item;\n        item[QString(\"/devices/%1/ddf/hash\").arg(uniqueId)] = bundleHashBuf;\n        result[\"success\"] = item;\n        rsp.list.append(result);\n    }\n\n    if (needReload)\n    {\n        emit eventNotify(Event(RDevices, REventDDFReload, 0, deviceKey));\n    }\n\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rest_devices.h",
          "type": "blob",
          "size": 1.59765625,
          "content": "/*\n * Copyright (c) 2013-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_DEVICES_H\n#define REST_DEVICES_H\n\n#include <QObject>\n\nclass DeRestPluginPrivate;\nclass DeviceDescription;\nclass ApiRequest;\nclass ApiResponse;\nclass Event;\n\nclass RestDevicesPrivate;\n\n/*! \\class RestDevices\n\n    REST-API endpoint for devices.\n */\n\nclass RestDevices : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit RestDevices(QObject *parent = nullptr);\n    ~RestDevices();\n    int handleApi(const ApiRequest &req, ApiResponse &rsp);\n\n    bool deleteDevice(quint64 extAddr);\n\nQ_SIGNALS:\n    void eventNotify(const Event &);\n\npublic Q_SLOTS:\n    void handleEvent(const Event &event);\n\nprivate:\n    int getAllDevices(const ApiRequest &req, ApiResponse &rsp);\n    int getDevice(const ApiRequest &req, ApiResponse &rsp);\n    int getDeviceDDF(const ApiRequest &req, ApiResponse &rsp);\n    int putDeviceInstallCode(const ApiRequest &req, ApiResponse &rsp);\n    int putDeviceReloadDDF(const ApiRequest &req, ApiResponse &rsp);\n    int putDeviceSetDDFPolicy(const ApiRequest &req, ApiResponse &rsp);\n\n    DeRestPluginPrivate *plugin = nullptr;\n    RestDevicesPrivate *d = nullptr;\n};\n\n// Resource Introspection (RIS)\nint RIS_GetDeviceIntrospect(const ApiRequest &req, ApiResponse &rsp);\nint RIS_GetDeviceItemIntrospect(const ApiRequest &req, ApiResponse &rsp);\n\nQString DDF_ToJsonPretty(const DeviceDescription &ddf);\n\n#endif // REST_DEVICES_H\n"
        },
        {
          "name": "rest_gateways.cpp",
          "type": "blob",
          "size": 13.8837890625,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QApplication>\n#include <QDesktopServices>\n#include <QFile>\n#include <QString>\n#include <QVariantMap>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"gateway.h\"\n#include \"gateway_scanner.h\"\n#include \"json.h\"\n#include <stdlib.h>\n\n/*! Gateways REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleGatewaysApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.path[2] != QLatin1String(\"gateways\"))\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // GET /api/<apikey>/gateways\n    if ((req.path.size() == 3) && (req.hdr.method() == QLatin1String(\"GET\")))\n    {\n        return getAllGateways(req, rsp);\n    }\n    // GET /api/<apikey>/gateways/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"GET\")))\n    {\n        return getGatewayState(req, rsp);\n    }\n    // PUT /api/<apikey>/gateways/<id>/state\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\")) && (req.path[4] == QLatin1String(\"state\")))\n    {\n        return setGatewayState(req, rsp);\n    }\n    // POST /api/<apikey>/gateways/<id>/cascadegroup\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"POST\")) && (req.path[4] == QLatin1String(\"cascadegroup\")))\n    {\n        return addCascadeGroup(req, rsp);\n    }\n    // DELETE /api/<apikey>/gateways/<id>/cascadegroup\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"DELETE\")) && (req.path[4] == QLatin1String(\"cascadegroup\")))\n    {\n        return deleteCascadeGroup(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\nint DeRestPluginPrivate::getAllGateways(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n    rsp.httpStatus = HttpStatusOk;\n\n    for (size_t i = 0; i < gateways.size(); i++)\n    {\n        QVariantMap map;\n        gatewayToMap(req, gateways[i], map);\n        if (!map.isEmpty())\n        {\n            rsp.map[QString::number(i + 1)] = map;\n        }\n    }\n\n    // user is on the gateway page, run scanner in background\n    if (!gwScanner->isRunning())\n    {\n//        gwScanner->startScan();\n    }\n\n    if (rsp.map.isEmpty())\n    {\n        rsp.str = \"{}\";\n        return REQ_READY_SEND;\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/gateways/<id>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getGatewayState(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    bool ok;\n    size_t idx = req.path[3].toUInt(&ok);\n\n    if (!ok || idx == 0 || (idx - 1) >= gateways.size())\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/gateways/%1\").arg(req.path[3]), QString(\"resource, /gateways/%1, not available\").arg(req.path[3])));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    idx -= 1;\n\n    gatewayToMap(req, gateways[idx], rsp.map);\n\n    if (rsp.map.isEmpty())\n    {\n        rsp.str = \"{}\";\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! PUT /api/<apikey>/gateways/<id>/state\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::setGatewayState(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    bool ok;\n    const QString &id = req.path[3];\n    size_t idx = id.toUInt(&ok);\n\n    if (!ok || idx == 0 || (idx - 1) >= gateways.size())\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/gateways/%1\").arg(id), QString(\"resource, /gateways/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    Gateway *gw = gateways[idx - 1];\n\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/gateways/%1/state\").arg(id), QLatin1String(\"body contains invalid JSON\")));\n        return REQ_READY_SEND;\n    }\n\n    if (map.contains(QLatin1String(\"pairing\")))\n    {\n        if (map[QLatin1String(\"pairing\")].type() == QVariant::Bool)\n        {\n            bool pairing = map[QLatin1String(\"pairing\")].toBool();\n            if (gw->pairingEnabled() != pairing)\n            {\n                gw->setPairingEnabled(pairing);\n            }\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[QString(\"/gateways/%1/state/pairing\").arg(id)] = map[QLatin1String(\"pairing\")];\n            rspItem[QLatin1String(\"success\")] = rspItemState;\n            rsp.list.append(rspItem);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/gateways/%1/state/pairing\").arg(id), QString(\"invalid value, %1, for parameter, pairing\").arg(map[QLatin1String(\"pairing\")].toString())));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    if (gw->needSaveDatabase())\n    {\n        queSaveDb(DB_GATEWAYS, DB_SHORT_SAVE_DELAY);\n    }\n\n    if (!rsp.list.empty())\n    {\n        return REQ_READY_SEND;\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! POST /api/<apikey>/gateways/<id>/cascadegroup\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::addCascadeGroup(const ApiRequest &req, ApiResponse &rsp)\n{\n    bool ok;\n    const QString &id = req.path[3];\n    size_t idx = id.toUInt(&ok);\n\n    if (!ok || idx == 0 || (idx - 1) >= gateways.size())\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/gateways/%1\").arg(id), QString(\"resource, /gateways/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/gateways/%1/cascadegroup\").arg(id), QLatin1String(\"body contains invalid JSON\")));\n        return REQ_READY_SEND;\n    }\n\n    if (!map.contains(QLatin1String(\"local\")) || !map.contains(QLatin1String(\"remote\")))\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/gateways/%1/casecadegroup\").arg(id), \"missing parameters in body\"));\n        return REQ_READY_SEND;\n    }\n\n    double lg = map[QLatin1String(\"local\")].toDouble(&ok);\n    if (!ok || lg < 0 || lg > 0xffff)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/gateways/%1/casecadegroup/local\").arg(id), QString(\"invalid value, %1, for parameter, local\").arg(map[QLatin1String(\"local\")].toString())));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    double rg = map[QLatin1String(\"remote\")].toDouble(&ok);\n    if (!ok || rg < 0 || rg > 0xffff)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/gateways/%1/casecadegroup/remote\").arg(id), QString(\"invalid value, %1, for parameter, remote\").arg(map[QLatin1String(\"remote\")].toString())));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n    Gateway *gw = gateways[idx - 1];\n    gw->addCascadeGroup(lg, rg);\n\n    if (gw->needSaveDatabase())\n    {\n        queSaveDb(DB_GATEWAYS, DB_SHORT_SAVE_DELAY);\n    }\n\n    DBG_Printf(DBG_INFO, \"Add cascade group %u||%u\\n\", (quint16)lg, (quint16)rg);\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n    rspItemState[QString(\"/gateways/%1/casecadegroup\").arg(id)] = map;\n    rspItem[QLatin1String(\"success\")] = rspItemState;\n    rsp.list.append(rspItem);\n\n    return REQ_READY_SEND;\n}\n\n/*! DELETE /api/<apikey>/gateways/<id>/cascadegroup\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::deleteCascadeGroup(const ApiRequest &req, ApiResponse &rsp)\n{\n    bool ok;\n    const QString &id = req.path[3];\n    size_t idx = id.toUInt(&ok);\n\n    if (!ok || idx == 0 || (idx - 1) >= gateways.size())\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/gateways/%1\").arg(id), QString(\"resource, /gateways/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok || map.isEmpty())\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/gateways/%1/cascadegroup\").arg(id), QLatin1String(\"body contains invalid JSON\")));\n        return REQ_READY_SEND;\n    }\n\n    if (!map.contains(QLatin1String(\"local\")) || !map.contains(QLatin1String(\"remote\")))\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/gateways/%1/casecadegroup\").arg(id), \"missing parameters in body\"));\n        return REQ_READY_SEND;\n    }\n\n    double lg = map[QLatin1String(\"local\")].toDouble(&ok);\n    if (!ok || lg < 0 || lg > 0xffff)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/gateways/%1/casecadegroup/local\").arg(id), QString(\"invalid value, %1, for parameter, local\").arg(map[QLatin1String(\"local\")].toString())));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    double rg = map[QLatin1String(\"remote\")].toDouble(&ok);\n    if (!ok || rg < 0 || rg > 0xffff)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/gateways/%1/casecadegroup/remote\").arg(id), QString(\"invalid value, %1, for parameter, remote\").arg(map[QLatin1String(\"remote\")].toString())));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n    Gateway *gw = gateways[idx - 1];\n    gw->removeCascadeGroup(lg, rg);\n\n    if (gw->needSaveDatabase())\n    {\n        queSaveDb(DB_GATEWAYS, DB_SHORT_SAVE_DELAY);\n    }\n\n    DBG_Printf(DBG_INFO, \"Remove cascade group %u||%u\\n\", (quint16)lg, (quint16)rg);\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n    rspItemState[QString(\"/gateways/%1/casecadegroup\").arg(id)] = map;\n    rspItem[QLatin1String(\"success\")] = rspItemState;\n    rsp.list.append(rspItem);\n\n    return REQ_READY_SEND;\n}\n\n/*! Puts all parameters in a map for later JSON serialization.\n */\nvoid DeRestPluginPrivate::gatewayToMap(const ApiRequest &req, const Gateway *gw, QVariantMap &map)\n{\n    Q_UNUSED(req);\n\n    if (!gw)\n    {\n        return;\n    }\n\n    if (!gw->uuid().isEmpty())\n    {\n        map[QLatin1String(\"uuid\")] = gw->uuid();\n    }\n    if (!gw->name().isEmpty())\n    {\n        map[QLatin1String(\"name\")] = gw->name();\n    }\n    map[QLatin1String(\"ip\")] = gw->address().toString();\n    map[QLatin1String(\"port\")] = (double)gw->port();\n    map[QLatin1String(\"pairing\")] = gw->pairingEnabled();\n\n    if (!gw->groups().empty())\n    {\n        QVariantMap groups;\n\n        for (size_t i = 0; i < gw->groups().size(); i++)\n        {\n            const Gateway::Group &g = gw->groups()[i];\n            groups[g.id] = g.name;\n        }\n\n        map[QLatin1String(\"groups\")] = groups;\n    }\n\n    if (!gw->cascadeGroups().empty())\n    {\n        QVariantList cgs;\n\n        for (size_t i = 0; i < gw->cascadeGroups().size(); i++)\n        {\n            const Gateway::CascadeGroup &g = gw->cascadeGroups()[i];\n            QVariantMap cg;\n            cg[QLatin1String(\"local\")] = QString::number(g.local);\n            cg[QLatin1String(\"remote\")] = QString::number(g.remote);\n            cgs.push_back(cg);\n        }\n\n        map[QLatin1String(\"cascadegroups\")] = cgs;\n    }\n\n    switch (gw->state())\n    {\n    case Gateway::StateConnected:\n    {\n        if (gw->pairingEnabled())\n        {\n            map[QLatin1String(\"state\")] = QLatin1String(\"connected\");\n        }\n        else\n        {\n            map[QLatin1String(\"state\")] = QLatin1String(\"not authorized\");\n        }\n    }\n        break;\n    case Gateway::StateNotAuthorized: { map[QLatin1String(\"state\")] = QLatin1String(\"not authorized\"); } break;\n    case Gateway::StateOffline:       { map[QLatin1String(\"state\")] = QLatin1String(\"offline\"); } break;\n    default:                          { map[QLatin1String(\"state\")] = QLatin1String(\"unknown\"); }\n        break;\n    }\n}\n\nvoid DeRestPluginPrivate::foundGateway(const QHostAddress &host, quint16 port, const QString &uuid, const QString &name)\n{\n    if (uuid.isEmpty())\n    {\n        return;\n    }\n\n    for (size_t i = 0; i < gateways.size(); i++)\n    {\n        Gateway *gw = gateways[i];\n        Q_ASSERT(gw);\n\n        if (gw && gw->uuid() == uuid)\n        {\n            if (gw->address().toIPv4Address() != host.toIPv4Address() || gw->port() != port)\n            {\n                gw->setAddress(host);\n                gw->setPort(port);\n\n            }\n\n            if (gw->name() != name && !name.isEmpty())\n            {\n                gw->setName(name);\n            }\n\n            if (gw->needSaveDatabase())\n            {\n                queSaveDb(DB_GATEWAYS, DB_SHORT_SAVE_DELAY);\n            }\n\n            return; // already known\n        }\n    }\n\n    Q_ASSERT(gwUuid.length() >= 10);\n    QString gwApikey = gwUuid.left(10);\n\n    Gateway *gw = new Gateway(this);\n    gw->setAddress(host);\n    gw->setPort(port);\n    gw->setUuid(uuid);\n    gw->setName(name);\n    gw->setApiKey(gwApikey);\n    DBG_Printf(DBG_INFO, \"found gateway %s:%u\\n\", qPrintable(gw->address().toString()), port);\n    gateways.push_back(gw);\n    updateEtag(gwConfigEtag);\n}\n\n\nvoid DeRestPluginPrivate::handleClusterIndicationGateways(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (ind.dstAddressMode() != deCONZ::ApsGroupAddress)\n    {\n        return;\n    }\n\n    for (size_t i = 0; i < gateways.size(); i++)\n    {\n        Gateway *gw = gateways[i];\n        gw->handleGroupCommand(ind, zclFrame);\n    }\n}\n"
        },
        {
          "name": "rest_groups.cpp",
          "type": "blob",
          "size": 122.8818359375,
          "content": "/*\r\n * Copyright (c) 2013-2019 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QString>\r\n#include <QTextCodec>\r\n#include <QTcpSocket>\r\n#include <QVariantMap>\r\n#include \"colorspace.h\"\r\n#include \"de_web_plugin.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"json.h\"\r\n\r\n/*! Groups and scenes REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleGroupsApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    if (req.path[2] != QLatin1String(\"groups\"))\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    // GET /api/<apikey>/groups\r\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getAllGroups(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/groups\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"POST\"))\r\n    {\r\n        return createGroup(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/groups/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getGroupAttributes(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/groups/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\"))\r\n    {\r\n        return setGroupAttributes(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/groups/<id>/action\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\") && (req.path[4] == \"action\"))\r\n    {\r\n        return setGroupState(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/groups/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\"))\r\n    {\r\n        return deleteGroup(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/groups/<group_id>/scenes\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"POST\")  && (req.path[4] == \"scenes\"))\r\n    {\r\n        return createScene(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/groups/<group_id>/scenes\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"GET\")  && (req.path[4] == \"scenes\"))\r\n    {\r\n        return getAllScenes(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    else if ((req.path.size() == 6) && (req.hdr.method() == \"GET\")  && (req.path[4] == \"scenes\"))\r\n    {\r\n        return getSceneAttributes(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    else if ((req.path.size() == 6) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\")  && (req.path[4] == \"scenes\"))\r\n    {\r\n        return setSceneAttributes(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/groups/<group_id>/scenes/<scene_id>/store\r\n    else if ((req.path.size() == 7) && (req.hdr.method() == \"PUT\")  && (req.path[4] == \"scenes\") && (req.path[6] == \"store\"))\r\n    {\r\n        return storeScene(req, rsp);\r\n    }\r\n    // PUT /api/<apikey>/groups/<group_id>/scenes/<scene_id>/recall\r\n    else if ((req.path.size() == 7) && (req.hdr.method() == \"PUT\")  && (req.path[4] == \"scenes\") && (req.path[6] == \"recall\"))\r\n    {\r\n        return recallScene(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/groups/<group_id>/scenes/<scene_id>/lights/<light_id>/state\r\n    else if ((req.path.size() == 9) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\")  && (req.path[4] == \"scenes\") && (req.path[6] == \"lights\"))\r\n    {\r\n        return modifyScene(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    else if ((req.path.size() == 6) && (req.hdr.method() == \"DELETE\")  && (req.path[4] == \"scenes\"))\r\n    {\r\n        return deleteScene(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! GET /api/<apikey>/groups\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getAllGroups(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (gwGroupsEtag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    std::vector<Group>::const_iterator i = groups.begin();\r\n    std::vector<Group>::const_iterator end = groups.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        // ignore deleted groups\r\n        if (i->state() == Group::StateDeleted || i->state() == Group::StateDeleteFromDB)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (i->address() != gwGroup0) // don't return special group 0\r\n        {\r\n            QVariantMap mnode;\r\n            groupToMap(req, &(*i), mnode);\r\n            rsp.map[i->id()] = mnode;\r\n        }\r\n    }\r\n\r\n    if (rsp.map.isEmpty())\r\n    {\r\n        rsp.str = \"{}\"; // return empty object\r\n    }\r\n\r\n    rsp.etag = gwGroupsEtag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/groups\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::createGroup(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    bool ok;\r\n    Group group;\r\n    QString type;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    userActivity();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups\"), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // type\r\n    if (map.contains(\"type\"))\r\n    {\r\n        ok = false;\r\n        type = map[\"type\"].toString();\r\n        if (map[\"type\"].type() == QVariant::String)\r\n        {\r\n            for (const char *t : { \"LightGroup\", \"Luminaire\", \"Lightsource\", \"Room\" })\r\n            {\r\n                if (type == QLatin1String(t))\r\n                {\r\n                    ok = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!ok)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups\"), QString(\"invalid value, %1, for parameter, type\").arg(type)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        ResourceItem *item = group.item(RAttrType);\r\n        DBG_Assert(item != 0);\r\n        item->setValue(type);\r\n    }\r\n\r\n    // class\r\n    if (type == \"Room\" && map.contains(\"class\"))\r\n    {\r\n        ok = false;\r\n        QString gclass = map[\"class\"].toString();\r\n        if (map[\"class\"].type() == QVariant::String && type == QLatin1String(\"Room\"))\r\n        {\r\n            for (const char *c : { \"Living room\", \"Kitchen\", \"Dining\", \"Bedroom\", \"Kids bedroom\",\r\n                                   \"Bathroom\", \"Nursery\", \"Recreation\", \"Office\", \"Gym\", \"Hallway\",\r\n                                   \"Toilet\", \"Front door\", \"Garage\", \"Terrace\", \"Garden\", \"Driveway\",\r\n                                   \"Carport\", \"Other\",\r\n                                   \"Home\", \"Downstairs\", \"Upstairs\", \"Top floor\", \"Attic\", \"Guest room\",\r\n                                   \"Staircase\", \"Lounge\", \"Man cave\", \"Computer\", \"Studio\", \"Music\",\r\n                                   \"TV\", \"Reading\", \"Closet\", \"Storage\", \"Laundry room\", \"Balcony\",\r\n                                   \"Porch\", \"Barbecue\", \"Pool\" })\r\n            {\r\n                if (gclass == QLatin1String(c))\r\n                {\r\n                    ok = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!ok)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups\"), QString(\"invalid value, %1, for parameter, class\").arg(gclass)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        ResourceItem *item = group.item(RAttrClass);\r\n        DBG_Assert(item != 0);\r\n        item->setValue(gclass);\r\n    }\r\n\r\n    // uniqueid\r\n    if (map.contains(\"uniqueid\"))\r\n    {\r\n        QString uniqueid = map[\"uniqueid\"].toString();\r\n        // AA:BB:CC:DD or AA:BB:CC:DD-XX\r\n        if (uniqueid.size() == 11 || uniqueid.size() == 14)\r\n        {\r\n            ResourceItem *item = group.addItem(DataTypeString, RAttrUniqueId);\r\n            DBG_Assert(item != 0);\r\n            item->setValue(uniqueid);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups\"), QString(\"invalid value, %1, for parameter, uniqueid\").arg(uniqueid)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // name\r\n    if (map.contains(\"name\"))\r\n    {\r\n        QString name = map[\"name\"].toString().trimmed();\r\n\r\n        if (map[\"name\"].type() == QVariant::String && !name.isEmpty())\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n\r\n#if 0 // this is check under application control\r\n            Group *group1 = getGroupForName(name);\r\n\r\n            // already exist? .. do nothing\r\n            if (group1)\r\n            {\r\n                // If a group with the same name was deleted before\r\n                // a new group with a different id will be created\r\n                // TODO: same behavoir as for creating duplicated scenes\r\n                if (group1->state() != Group::StateDeleted && group1->state() != Group::StateDeleteFromDB)\r\n                {\r\n                    rspItemState[\"id\"] = group1->id();\r\n                    rspItem[\"success\"] = rspItemState;\r\n                    rsp.list.append(rspItem);\r\n                    rsp.httpStatus = HttpStatusOk;\r\n                    return REQ_READY_SEND;\r\n                }\r\n                else\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"create group with same name as prior deleted group. but use different id\\n\");\r\n                }\r\n            }\r\n            // does not exist, create group\r\n#endif\r\n\r\n            // create a new group id\r\n            group.setAddress(1);\r\n\r\n            do {\r\n                ok = true;\r\n                std::vector<Group>::iterator i = groups.begin();\r\n                std::vector<Group>::iterator end = groups.end();\r\n\r\n                for (; i != end; ++i)\r\n                {\r\n                    if (i->address() == group.address())\r\n                    {\r\n                        group.setAddress(i->address() + 1);\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (group.address() == 0) // overflow\r\n                {\r\n                    break;\r\n                }\r\n            } while (!ok);\r\n\r\n            if (!ok)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_BRIDGE_GROUP_TABLE_FULL, QString(\"/groups\"), QString(\"group could not be created. Group table is full.\")));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n\r\n            ResourceItem *item = group.item(RAttrName);\r\n            DBG_Assert(item != 0);\r\n            item->setValue(name);\r\n\r\n            group.colorX = 0;\r\n            group.colorY = 0;\r\n            group.setIsOn(false);\r\n            group.level = 128;\r\n            group.hue = 0;\r\n            group.hueReal = 0.0f;\r\n            group.sat = 128;\r\n            groups.push_back(group);\r\n            updateGroupEtag(&groups.back());\r\n            queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n\r\n            rspItemState[\"id\"] = group.id();\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.httpStatus = HttpStatusOk;\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups\"), QString(\"invalid value, %1, for parameter, name\").arg(name)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/groups\"), QString(\"missing parameters in body\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/groups/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getGroupAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!group || group->state() == Group::StateDeleted || group->state() == Group::StateDeleteFromDB)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (group->etag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    groupToMap(req, group, rsp.map);\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/groups/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setGroupAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    bool ok;\r\n    bool changed = false;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n\r\n    userActivity();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // class\r\n    if (map.contains(\"class\"))\r\n    {\r\n        ok = false;\r\n        QString gclass = map[\"class\"].toString();\r\n        if (map[\"class\"].type() == QVariant::String &&\r\n            group->item(RAttrType)->toString() == QLatin1String(\"Room\"))\r\n        {\r\n            for (const char *c : { \"Living room\", \"Kitchen\", \"Dining\", \"Bedroom\", \"Kids bedroom\",\r\n                                   \"Bathroom\", \"Nursery\", \"Recreation\", \"Office\", \"Gym\", \"Hallway\",\r\n                                   \"Toilet\", \"Front door\", \"Garage\", \"Terrace\", \"Garden\", \"Driveway\",\r\n                                   \"Carport\", \"Other\",\r\n                                   \"Home\", \"Downstairs\", \"Upstairs\", \"Top floor\", \"Attic\", \"Guest room\",\r\n                                   \"Staircase\", \"Lounge\", \"Man cave\", \"Computer\", \"Studio\", \"Music\",\r\n                                   \"TV\", \"Reading\", \"Closet\", \"Storage\", \"Laundry room\", \"Balcony\",\r\n                                   \"Porch\", \"Barbecue\", \"Pool\" })\r\n            {\r\n                if (gclass == QLatin1String(c))\r\n                {\r\n                    ok = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!ok)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups\"), QString(\"invalid value, %1, for parameter, class\").arg(gclass)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        ResourceItem *item = group->item(RAttrClass);\r\n        DBG_Assert(item != 0);\r\n        if (item && item->toString() != gclass)\r\n        {\r\n            item->setValue(gclass);\r\n            Event e(RGroups, RAttrClass, group->address());\r\n            enqueueEvent(e);\r\n        }\r\n    }\r\n\r\n    // name\r\n    if (map.contains(\"name\"))\r\n    {\r\n        QString name = map[\"name\"].toString().trimmed();\r\n\r\n        if (map[\"name\"].type() == QVariant::String)\r\n        {\r\n            if (name.size() <= 32)\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/name\").arg(id)] = name;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n\r\n                if (group->name() != name)\r\n                {\r\n                    group->setName(name);\r\n                    changed = true;\r\n                    Event e(RGroups, RAttrName, group->address());\r\n                    enqueueEvent(e);\r\n                    queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1\").arg(id), QString(\"invalid value, %1, for parameter, /groups/%2/name\").arg(name).arg(id)));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1\").arg(id), QString(\"invalid value, %1, for parameter, /groups/%2/name\").arg(name).arg(id)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n        }\r\n    }\r\n\r\n    // hidden\r\n    if (map.contains(\"hidden\"))\r\n    {\r\n        bool hidden = map[\"hidden\"].toBool();\r\n\r\n        if (map[\"hidden\"].type() == QVariant::Bool)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/groups/%1/hidden\").arg(id)] = (hidden == true) ? \"true\" : \"false\";\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            if (group->hidden != hidden)\r\n            {\r\n                group->hidden = hidden;\r\n                changed = true;\r\n                queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1\").arg(id), QString(\"invalid value for parameter, /groups/%2/hidden\").arg(id)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n        }\r\n    }\r\n\r\n    // check optional parameter lights\r\n    if (map.contains(\"lights\"))\r\n    {\r\n        QVariantList lights = map[\"lights\"].toList();\r\n        uint8_t groupCount;\r\n        uint8_t groupCapacity;\r\n\r\n        // for each node in the list send a add to group request (unicast)\r\n        // note: nodes which are currently switched off will not be added to the group\r\n        QVariantList::iterator i = lights.begin();\r\n        QVariantList::iterator end = lights.end();\r\n\r\n        QStringList lids;\r\n\r\n        ok = true;\r\n\r\n        for (;i != end; ++i)\r\n        {\r\n            if (i->type() == QVariant::String)\r\n            {\r\n                QString lid = i->toString();\r\n                lids.append(lid);\r\n                DBG_Printf(DBG_INFO, \"group %u member %u\\n\", group->address(), lid.toUInt());\r\n\r\n                LightNode *lightNode = getLightNodeForId(lid);\r\n\r\n                if (lightNode)\r\n                {\r\n                    groupCount = lightNode->groupCount();\r\n                    groupCapacity = lightNode->groupCapacity();\r\n\r\n                    if (groupCapacity > 0 || (groupCapacity == 0 && groupCount == 0)) // xxx workaround\r\n                    {\r\n                        GroupInfo *groupInfo = getGroupInfo(lightNode, group->address());\r\n\r\n                        if (!groupInfo)\r\n                        {\r\n                            groupInfo = createGroupInfo(lightNode, group->address());\r\n                            lightNode->setNeedSaveDatabase(true);\r\n                        }\r\n\r\n                        DBG_Assert(groupInfo != 0);\r\n                        if (groupInfo)\r\n                        {\r\n                            groupInfo->actions &= ~GroupInfo::ActionRemoveFromGroup; // sanity\r\n                            groupInfo->actions |= GroupInfo::ActionAddToGroup;\r\n\r\n                            if (groupInfo->state != GroupInfo::StateInGroup)\r\n                            {\r\n                                lightNode->setNeedSaveDatabase(true);\r\n                                groupInfo->state = GroupInfo::StateInGroup;\r\n                                ResourceItem *item = lightNode->item(RStateOn);\r\n                                if (item && item->toBool())\r\n                                {\r\n                                    group->setIsOn(true);\r\n                                    item = lightNode->item(RStateBri);\r\n                                    group->level = item ? item->toNumber() : 254;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        changed = true; // necessary for adding last available light to group from main view.\r\n                    }\r\n                    else\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_DEVICE_GROUP_TABLE_FULL, QString(\"/groups/%1/lights/%2\").arg(id).arg(lid), QString(\" Could not add %1 to group. Group capacity of the device is reached.\").arg(qPrintable(lightNode->name()))));\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    ok = false;\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/lights\").arg(id), QString(\" device, %1, could not be added to group. Device does not exist.\").arg(lid)));\r\n                }\r\n            }\r\n            else\r\n            {\r\n                ok = false;\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                // TODO: return error\r\n            }\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/groups/%1/lights\").arg(id)] = map[\"lights\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            Event e(RGroups, REventCheckGroupAnyOn, int(group->address()));\r\n            enqueueEvent(e);\r\n\r\n            // for each node which are currently in the group but not in the list send a remove group command (unicast)\r\n            // note: nodes which are currently switched off will not be removed from the group\r\n            std::vector<LightNode>::iterator j = nodes.begin();\r\n            std::vector<LightNode>::iterator jend = nodes.end();\r\n            for (; j != jend; ++j)\r\n            {\r\n                if (lids.contains(j->id()))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                std::vector<GroupInfo>::iterator k = j->groups().begin();\r\n                std::vector<GroupInfo>::iterator kend = j->groups().end();\r\n\r\n                for (; k != kend; ++k)\r\n                {\r\n                    if (k->id == group->address())\r\n                    {\r\n                        k->actions &= ~GroupInfo::ActionAddToGroup; // sanity\r\n                        k->actions |= GroupInfo::ActionRemoveFromGroup;\r\n                        k->state = GroupInfo::StateNotInGroup;\r\n                        j->setNeedSaveDatabase(true);\r\n\r\n                        //delete Light from all scenes\r\n                        deleteLightFromScenes(j->id(), k->id);\r\n\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // check optional parameter multideviceids\r\n        if (map.contains(\"multideviceids\"))\r\n        {\r\n            group->m_multiDeviceIds.clear();\r\n\r\n            QStringList multiIds = map[\"multideviceids\"].toStringList();\r\n\r\n            QStringList::const_iterator m = multiIds.begin();\r\n            QStringList::const_iterator m_end = multiIds.end();\r\n\r\n            for (;m != m_end; ++m)\r\n            {\r\n                group->m_multiDeviceIds.push_back(*m);\r\n            }\r\n        }\r\n        queSaveDb(DB_LIGHTS | DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    // check optional lightsequence\r\n    if (map.contains(\"lightsequence\"))\r\n    {\r\n        changed = true;\r\n        group->m_lightsequence.clear();\r\n\r\n        QStringList lightsequence = map[\"lightsequence\"].toStringList();\r\n\r\n        QStringList::const_iterator l = lightsequence.begin();\r\n        QStringList::const_iterator l_end = lightsequence.end();\r\n\r\n        for (;l != l_end; ++l)\r\n        {\r\n            group->m_lightsequence.push_back(*l);\r\n        }\r\n        queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[QString(\"/groups/%1/lightsequence\").arg(id)] = map[\"lightsequence\"];\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    if (changed)\r\n    {\r\n        updateGroupEtag(group);\r\n    }\r\n\r\n    rsp.etag = group->etag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Helper to generate a new task with new task and req id based on a reference */\r\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\r\n{\r\n    b.req.dstAddress() = a.req.dstAddress();\r\n    b.req.setDstAddressMode(a.req.dstAddressMode());\r\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\r\n    b.req.setDstEndpoint(a.req.dstEndpoint());\r\n    b.req.setRadius(a.req.radius());\r\n    b.transitionTime = a.transitionTime;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/groups/<id>/action\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setGroupState(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    TaskItem taskRef;\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n\r\n    if (req.sock)\r\n    {\r\n        userActivity();\r\n    }\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/action\").arg(id), \"Not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() != Group::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    // set destination parameters\r\n    taskRef.req.dstAddress().setGroup(group->address());\r\n    taskRef.req.setDstAddressMode(deCONZ::ApsGroupAddress);\r\n    taskRef.req.setDstEndpoint(0xFF); // broadcast endpoint\r\n    taskRef.req.setSrcEndpoint(getSrcEndpoint(0, taskRef.req));\r\n\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1/action\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    bool hasOn = map.contains(\"on\");\r\n    bool hasOnTime = map.contains(\"ontime\");\r\n    bool hasOpen = map.contains(\"open\");\r\n    bool hasBri = map.contains(\"bri\");\r\n    bool hasHue = map.contains(\"hue\");\r\n    bool hasSat = map.contains(\"sat\");\r\n    bool hasXy = map.contains(\"xy\");\r\n    bool hasCt = map.contains(\"ct\");\r\n    bool hasCtInc = map.contains(\"ct_inc\");\r\n    bool hasBriInc = map.contains(\"bri_inc\");\r\n    bool hasEffect = map.contains(\"effect\");\r\n    bool hasEffectColorLoop = false;\r\n    bool hasAlert = map.contains(\"alert\");\r\n    bool hasToggle = map.contains(\"toggle\");\r\n    bool hasWrap = map.contains(\"wrap\");\r\n\r\n    bool on = false;\r\n    bool targetOpen = false;\r\n    uint bri = 0;\r\n    uint hue = UINT_MAX;\r\n    uint sat = UINT_MAX;\r\n    double x = 0;\r\n    double y = 0;\r\n    uint ct = 0;\r\n\r\n    // transition time\r\n    if (map.contains(\"transitiontime\"))\r\n    {\r\n        uint tt = map[\"transitiontime\"].toUInt(&ok);\r\n\r\n        if (ok && tt < 0xFFFFUL)\r\n        {\r\n            taskRef.transitionTime = tt;\r\n        }\r\n    }\r\n\r\n    // toggle\r\n    if (hasToggle)\r\n    {\r\n        if (map[\"toggle\"].type() == QVariant::Bool)\r\n        {\r\n            if (map[\"toggle\"] == true)\r\n            {\r\n                map[\"on\"] = group->item(RStateAnyOn)->toBool() ? false : true;\r\n                hasOn = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/toggle\").arg(id), QString(\"invalid value, %1, for parameter, toggle\").arg(map[\"toggle\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // on/off\r\n    if (hasOn)\r\n    {\r\n        hasOn = false;\r\n        if (map[\"on\"].type() == QVariant::Bool)\r\n        {\r\n            hasOn = true;\r\n            on = map[\"on\"].toBool();\r\n            group->setIsOn(on);\r\n            quint16 ontime = 0;\r\n            quint8 command = on ? ONOFF_COMMAND_ON : ONOFF_COMMAND_OFF;\r\n            quint8 flags = 0;\r\n            if (on)\r\n            {\r\n                if (hasOnTime && map[\"ontime\"].type() == QVariant::Double)\r\n                {\r\n                    uint ot = map[\"ontime\"].toUInt(&ok);\r\n                    if (ok && ot <= 65535)\r\n                    {\r\n                        ontime = static_cast<quint16>(ot);\r\n                        command = ONOFF_COMMAND_ON_WITH_TIMED_OFF;\r\n                    }\r\n\r\n                    if (ok && map.contains(\"onoffcontrol\"))\r\n                    {\r\n                        uint ooc = map[\"onoffcontrol\"].toUInt(&ok);\r\n                        if (ok && ooc & 1) // accept only when on\r\n                        {\r\n                            flags |= 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (group->isColorLoopActive())\r\n            {\r\n                TaskItem task;\r\n                copyTaskReq(taskRef, task);\r\n                addTaskSetColorLoop(task, false, 15);\r\n                group->setColorLoopActive(false); // deactivate colorloop if active\r\n            }\r\n            std::vector<LightNode>::iterator i = nodes.begin();\r\n            std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n            for (; i != end; ++i)\r\n            {\r\n                if (isLightNodeInGroup(&(*i), group->address()))\r\n                {\r\n                    if (i->isColorLoopActive() && i->isAvailable() && i->state() != LightNode::StateDeleted)\r\n                    {\r\n                        TaskItem task2;\r\n                        task2.lightNode = &(*i);\r\n                        task2.req.dstAddress() = task2.lightNode->address();\r\n                        task2.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\r\n                        task2.req.setDstEndpoint(task2.lightNode->haEndpoint().endpoint());\r\n                        task2.req.setSrcEndpoint(getSrcEndpoint(task2.lightNode, task2.req));\r\n                        task2.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n\r\n                        addTaskSetColorLoop(task2, false, 15);\r\n                        i->setColorLoopActive(false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            if (hasBri ||\r\n                addTaskSetOnOff(task, command, ontime, flags)) // onOff task only if no bri is given\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/on\").arg(id)] = on;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/on\").arg(id), QString(\"invalid value, %1, for parameter, on\").arg(map[\"on\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    if (hasOpen)\r\n    {\r\n        hasOpen = false;\r\n        if (map[\"open\"].type() == QVariant::Bool)\r\n        {\r\n            hasOpen = true;\r\n            targetOpen = map[\"open\"].toBool();\r\n\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            if (addTaskWindowCovering(task, targetOpen ? WINDOW_COVERING_COMMAND_OPEN : WINDOW_COVERING_COMMAND_CLOSE, 0, 0))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/open\").arg(id)] = targetOpen;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/open\").arg(id), QString(\"invalid value, %1, for parameter, on\").arg(map[\"on\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // brightness\r\n    if (hasBri)\r\n    {\r\n        hasBri = false;\r\n        bri = map[\"bri\"].toUInt(&ok);\r\n\r\n        if ((map[\"bri\"].type() == QVariant::String) && map[\"bri\"].toString() == \"stop\")\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            if (addTaskIncBrightness(task, 0))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/bri\").arg(id)] = map[\"bri\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                taskToLocalData(task);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else if (ok && (map[\"bri\"].type() == QVariant::Double) && (bri < 256))\r\n        {\r\n            hasBri = true;\r\n            group->level = bri;\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            if (addTaskSetBrightness(task, bri, hasOn))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/bri\").arg(id)] = map[\"bri\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/bri\").arg(id), QString(\"invalid value, %1, for parameter, bri\").arg(map[\"bri\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // hue\r\n    if (hasHue)\r\n    {\r\n        hasHue = false;\r\n        uint hue2 = map[\"hue\"].toUInt(&ok);\r\n\r\n        if (ok && (map[\"hue\"].type() == QVariant::Double) && (hue2 <= MAX_ENHANCED_HUE))\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            hasHue = true;\r\n            hue = hue2;\r\n            { // TODO: this is needed if saturation is set and addTaskSetEnhancedHue() will not be called\r\n                task.hueReal = (double)hue / (360.0f * 182.04444f);\r\n\r\n                if (task.hueReal < 0.0)\r\n                {\r\n                    task.hueReal = 0.0;\r\n                }\r\n                else if (task.hueReal > 1.0)\r\n                {\r\n                    task.hueReal = 1.0;\r\n                }\r\n                task.hue = task.hueReal * 254.0;\r\n                if (hue > MAX_ENHANCED_HUE_Z)\r\n                {\r\n                    hue = MAX_ENHANCED_HUE_Z;\r\n                }\r\n                task.enhancedHue = hue;\r\n                task.taskType = TaskSetEnhancedHue;\r\n\r\n                group->hue = hue;\r\n                group->hueReal = task.hueReal;\r\n                group->colormode = QLatin1String(\"hs\");\r\n            }\r\n\r\n            if (!hasXy && !hasSat)\r\n            {\r\n                double r, g, b;\r\n                double x, y;\r\n                double h = ((360.0 / 65535.0) * hue);\r\n                double s = group->sat / 255.0;\r\n                double v = 1.0;\r\n\r\n                Hsv2Rgb(&r, &g, &b, h, s, v);\r\n                Rgb2xy(&x, &y, r, g, b);\r\n\r\n                if (x < 0) { x = 0; }\r\n                else if (x > 1) { x = 1; }\r\n\r\n                if (y < 0) { y = 0; }\r\n                else if (y > 1) { y = 1; }\r\n\r\n                DBG_Printf(DBG_INFO, \"x: %f, y: %f\\n\", x, y);\r\n                group->colorX = static_cast<quint16>(x * 65535.0);\r\n                group->colorY = static_cast<quint16>(y * 65535.0);\r\n\r\n                if (group->colorX > 65279) { group->colorX = 65279; }\r\n                else if (group->colorX == 0) { group->colorX = 1; }\r\n\r\n                if (group->colorY > 65279) { group->colorY = 65279; }\r\n                else if (group->colorY == 0) { group->colorY = 1; }\r\n            }\r\n\r\n            if (hasSat || // merge later to set hue and saturation\r\n                hasXy || hasCt || hasEffectColorLoop ||\r\n                addTaskSetEnhancedHue(task, hue)) // will only be evaluated if no sat is set\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/hue\").arg(id)] = map[\"hue\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/hue\").arg(id), QString(\"invalid value, %1, for parameter, hue\").arg(map[\"hue\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // saturation\r\n    if (hasSat)\r\n    {\r\n        hasSat = false;\r\n        uint sat2 = map[\"sat\"].toUInt(&ok);\r\n\r\n        if (ok && (map[\"sat\"].type() == QVariant::Double) && (sat2 < 256))\r\n        {\r\n            hasSat = true;\r\n            if (sat2 >= 255)\r\n            {\r\n                sat2 = 254; // max valid value for level attribute\r\n            }\r\n\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            sat = sat2;\r\n            task.sat = sat;\r\n            task.taskType = TaskSetSat;\r\n            group->sat = sat;\r\n            group->colormode = QLatin1String(\"hs\");\r\n\r\n            if (!hasXy && !hasHue)\r\n            {\r\n                double r, g, b;\r\n                double x, y;\r\n                double h = ((360.0 / 65535.0) * group->hue);\r\n                double s = sat / 254.0;\r\n                double v = 1.0;\r\n\r\n                Hsv2Rgb(&r, &g, &b, h, s, v);\r\n                Rgb2xy(&x, &y, r, g, b);\r\n\r\n                if (x < 0) { x = 0; }\r\n                else if (x > 1) { x = 1; }\r\n\r\n                if (y < 0) { y = 0; }\r\n                else if (y > 1) { y = 1; }\r\n\r\n                DBG_Printf(DBG_INFO, \"x: %f, y: %f\\n\", x, y);\r\n                group->colorX = static_cast<quint16>(x * 65535.0);\r\n                group->colorY = static_cast<quint16>(y * 65535.0);\r\n\r\n                if (group->colorX > 65279) { group->colorX = 65279; }\r\n                else if (group->colorX == 0) { group->colorX = 1; }\r\n\r\n                if (group->colorY > 65279) { group->colorY = 65279; }\r\n                else if (group->colorY == 0) { group->colorY = 1; }\r\n            }\r\n\r\n            if (hasXy || hasCt\r\n               || (!hasEffectColorLoop && hasHue && (hue != UINT_MAX)) // merge later to set hue and saturation\r\n               || addTaskSetSaturation(task, sat)) // will only be evaluated if no hue is set\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/sat\").arg(id)] = map[\"sat\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/sat\").arg(id), QString(\"invalid value, %1, for parameter, sat\").arg(map[\"sat\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // hue and saturation\r\n    if (hasHue && hasSat && (!hasXy && !hasCt))\r\n    {\r\n        if (!hasEffectColorLoop && (hue != UINT_MAX) && (sat != UINT_MAX))\r\n        {\r\n            // need 8 bit hue\r\n            qreal f = (qreal)hue / 182.04444f;\r\n\r\n            f /= 360.0f;\r\n\r\n            if (f > 1.0f)\r\n            {\r\n                f = 1.0f;\r\n            }\r\n\r\n            hue = f * 254.0f;\r\n\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            DBG_Printf(DBG_INFO, \"hue: %u, sat: %u\\n\", hue, sat);\r\n            if (!addTaskSetHueAndSaturation(task, hue, sat))\r\n            {\r\n                DBG_Printf(DBG_INFO, \"cant send task set hue and saturation\\n\");\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"cant merge hue and saturation: invalid value(s) hue: %u, sat: %u\\n\", hue, sat);\r\n        }\r\n    }\r\n\r\n    // xy\r\n    if (hasXy)\r\n    {\r\n        hasXy = false;\r\n        QVariantList ls = map[\"xy\"].toList();\r\n\r\n        if ((ls.size() == 2) && (ls[0].type() == QVariant::Double) && (ls[1].type() == QVariant::Double))\r\n        {\r\n            x = ls[0].toDouble(&ok);\r\n            y = ok ? ls[1].toDouble(&ok) : 0;\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n\r\n            if (!ok || (x < 0.0) || (x > 1.0) || (y < 0.0) || (y > 1.0))\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1\").arg(id), QString(\"invalid value, [%1,%2], for parameter, /groups/%3/xy\").arg(x).arg(y).arg(id)));\r\n                hasXy = false;\r\n            }\r\n            else if (hasEffectColorLoop ||\r\n                     addTaskSetXyColor(task, x, y))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/xy\").arg(id)] = map[\"xy\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                hasXy = true;\r\n                group->colormode = QLatin1String(\"xy\");\r\n                group->colorX = static_cast<quint16>(x * 65535.0); // current X in range 0 .. 65279\r\n                group->colorY = static_cast<quint16>(y * 65535.0); // current Y in range 0 .. 65279\r\n\r\n                if (group->colorX > 65279) { group->colorX = 65279; }\r\n                else if (group->colorX == 0) { group->colorX = 1; }\r\n\r\n                if (group->colorY > 65279) { group->colorY = 65279; }\r\n                else if (group->colorY == 0) { group->colorY = 1; }\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/xy\").arg(id), QString(\"invalid value, %1, for parameter, xy\").arg(map[\"xy\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // ct_inc\r\n    if (hasCtInc)\r\n    {\r\n        int ct_inc = map[\"ct_inc\"].toInt(&ok);\r\n\r\n        if (hasCt)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/groups/%1\").arg(id), QString(\"parameter, /lights/%1/ct_inc, is not modifiable. ct was specified.\").arg(id)));\r\n        }\r\n        else if (ok && (map[\"ct_inc\"].type() == QVariant::Double) && (ct_inc >= -65534 && ct_inc <= 65534))\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            task.inc = ct_inc;\r\n            task.taskType = TaskIncColorTemperature;\r\n\r\n            group->colormode = QLatin1String(\"ct\");\r\n\r\n            if (addTaskIncColorTemperature(task, ct_inc)) // will only be evaluated if no ct is set\r\n            {\r\n                taskToLocalData(task);\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/ct\").arg(id)] = group->colorTemperature;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/ct_inc\").arg(id), QString(\"invalid value, %1, for parameter, ct_inc\").arg(map[\"ct_inc\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // bri_inc\r\n    if (hasBriInc && !hasBri)\r\n    {\r\n        int briInc = map[\"bri_inc\"].toInt(&ok);\r\n        if (hasWrap && map[\"wrap\"].type() == QVariant::Bool && map[\"wrap\"].toBool() == true)\r\n        {\r\n            std::vector<LightNode>::iterator i = nodes.begin();\r\n            std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n            // Find the highest and lowest brightness lights\r\n            int hiBri = -1, loBri = 255;\r\n            for (; i != end; ++i)\r\n            {\r\n                if (isLightNodeInGroup(&(*i), group->address()))\r\n                {\r\n                    ResourceItem *item = i->item(RStateBri);\r\n                    if (item && i->isAvailable() && i->state() != LightNode::StateDeleted)\r\n                    {\r\n                        const int bri = static_cast<int>(item->toNumber());\r\n                        hiBri = (bri > hiBri) ? bri : hiBri;\r\n                        loBri = (bri < loBri) ? bri : loBri;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check if we need to wrap around\r\n            if (hiBri >= 0 && loBri < 255)\r\n            {\r\n                if (briInc < 0 && loBri + briInc <= -briInc)\r\n                {\r\n                    briInc = 254;\r\n                }\r\n                else if (briInc > 0 && hiBri + briInc >= 254)\r\n                {\r\n                    briInc = -254;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ok && (map[\"bri_inc\"].type() == QVariant::Double) && (briInc >= -254 && briInc <= 254))\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            task.inc = briInc;\r\n            task.taskType = TaskIncBrightness;\r\n\r\n            if (addTaskIncBrightness(task, briInc))\r\n            {\r\n                taskToLocalData(task);\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/bri_inc\").arg(id)] = briInc;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/bri_inc\").arg(id), QString(\"invalid value, %1, for parameter, bri_inc\").arg(map[\"bri_inc\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // color temperature\r\n    if (hasCt)\r\n    {\r\n        hasCt = false;\r\n        ct = map[\"ct\"].toUInt(&ok);\r\n\r\n        if (ok && (map[\"ct\"].type() == QVariant::Double))\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            group->colorTemperature = ct;\r\n            group->colormode = QLatin1String(\"ct\");\r\n            if (addTaskSetColorTemperature(task, ct))\r\n            {\r\n                hasCt = true;\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/ct\").arg(id)] = map[\"ct\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/ct\").arg(id), QString(\"invalid value, %1, for parameter, ct\").arg(map[\"ct\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // alert\r\n    if (hasAlert)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n        QString alert = map[\"alert\"].toString();\r\n\r\n        if (alert == \"none\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = 0;\r\n        }\r\n        else if (alert == \"select\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = 2;    // Hue lights don't react to 1.\r\n        }\r\n        else if (alert == \"lselect\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = 15;   // Default for Philips Hue bridge\r\n        }\r\n        else if (alert == \"blink\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x00;\r\n        }\r\n        else if (alert == \"breathe\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x01;\r\n        }\r\n        else if (alert == \"okay\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x02;\r\n        }\r\n        else if (alert == \"channelchange\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x0b;\r\n        }\r\n        else if (alert == \"finish\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0xfe;\r\n        }\r\n        else if (alert == \"stop\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0xff;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/alert\").arg(id), QString(\"invalid value, %1, for parameter, alert\").arg(map[\"alert\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        group->alert = QLatin1String(\"alert\");\r\n        taskToLocalData(task);\r\n\r\n        if ((task.taskType == TaskIdentify && addTaskIdentify(task, task.identifyTime)) ||\r\n            (task.taskType == TaskTriggerEffect && addTaskTriggerEffect(task, task.effectIdentifier)))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/groups/%1/action/alert\").arg(id)] = map[\"alert\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // colorloop\r\n    if (hasEffect)\r\n    {\r\n        QString effect = map[\"effect\"].toString();\r\n\r\n        if ((effect == \"none\") || (effect == \"colorloop\"))\r\n        {\r\n            hasEffectColorLoop = effect == \"colorloop\";\r\n            uint speed = 15;\r\n\r\n            if (hasEffectColorLoop)\r\n            {\r\n                if (map.contains(\"colorloopspeed\"))\r\n                {\r\n                    speed = map[\"colorloopspeed\"].toUInt(&ok);\r\n                    if (ok && (map[\"colorloopspeed\"].type() == QVariant::Double) && (speed < 256) && (speed > 0))\r\n                    {\r\n                        // ok\r\n                        std::vector<LightNode>::iterator i = nodes.begin();\r\n                        std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n                        for (; i != end; ++i)\r\n                        {\r\n                            if (isLightNodeInGroup(&(*i), group->address()))\r\n                            {\r\n                                i->setColorLoopSpeed(speed);\r\n                            }\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state/colorloopspeed\").arg(id), QString(\"invalid value, %1, for parameter, colorloopspeed\").arg(map[\"colorloopspeed\"].toString())));\r\n                    }\r\n                }\r\n            }\r\n\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            if (addTaskSetColorLoop(task, hasEffectColorLoop, speed))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/groups/%1/action/effect\").arg(id)] = map[\"effect\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                taskToLocalData(task);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/groups/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/action/effect\").arg(id), QString(\"invalid value, %1, for parameter, effect\").arg(map[\"effect\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    { // update lights state\r\n        std::vector<LightNode>::iterator i = nodes.begin();\r\n        std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (/*i->isAvailable() &&*/ i->state() != LightNode::StateDeleted && isLightNodeInGroup(&*i, group->address()))\r\n            {\r\n                ResourceItem *item = i->item(RStateOn);\r\n                bool modified = false;\r\n                if (hasOn && item && group->isOn() != item->toBool())\r\n                {\r\n                    item->setValue(group->isOn());\r\n                    Event e(RLights, RStateOn, i->id(), item);\r\n                    enqueueEvent(e);\r\n                    modified = true;\r\n                }\r\n\r\n                item = i->item(RStateBri);\r\n                if (hasBri && item && group->level != item->toNumber())\r\n                {\r\n                    item->setValue(group->level);\r\n                    Event e(RLights, RStateBri, i->id(), item);\r\n                    enqueueEvent(e);\r\n                    modified = true;\r\n                }\r\n\r\n                item = i->item(RStateColorMode);\r\n                if (item)\r\n                {\r\n                    if (hasXy && i->modelId() != QLatin1String(\"FLS-PP\")) // don't use xy for old black FLS-PP\r\n                    {\r\n                        if (item->toString() != QLatin1String(\"xy\"))\r\n                        {\r\n                            item->setValue(QVariant(QLatin1String(\"xy\")));\r\n                            Event e(RLights, RStateColorMode, i->id());\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n\r\n                        quint16 colorX = static_cast<quint16>(x * 65535.0); // current X in range 0 .. 65279\r\n                        quint16 colorY = static_cast<quint16>(y * 65535.0); // current Y in range 0 .. 65279\r\n\r\n                        if (colorX > 65279) { colorX = 65279; }\r\n                        else if (colorX == 0) { colorX = 1; }\r\n\r\n                        if (colorY > 65279) { colorY = 65279; }\r\n                        else if (colorY == 0) { colorY = 1; }\r\n\r\n                        item = i->item(RStateX);\r\n                        if (item && item->toNumber() != colorX)\r\n                        {\r\n                            item->setValue(colorX);\r\n                            Event e(RLights, RStateX, i->id(), item);\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n\r\n                        item = i->item(RStateY);\r\n                        if (item && item->toNumber() != colorY)\r\n                        {\r\n                            item->setValue(colorY);\r\n                            Event e(RLights, RStateY, i->id(), item);\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n                    }\r\n                    else if (hasCt && i->item(RStateCt))\r\n                    {\r\n                        if (item->toString() != QLatin1String(\"ct\"))\r\n                        {\r\n                            item->setValue(QVariant(QLatin1String(\"ct\")));\r\n                            Event e(RLights, RStateColorMode, i->id());\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n\r\n                        item = i->item(RStateCt);\r\n                        DBG_Assert(item);\r\n\r\n                        if (item && item->toNumber() != ct)\r\n                        {\r\n                            item->setValue(ct);\r\n                            Event e(RLights, RStateCt, i->id(), item);\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n                    }\r\n                    else if (hasHue)\r\n                    {\r\n                        if (item->toString() != QLatin1String(\"hs\"))\r\n                        {\r\n                            item->setValue(QVariant(QLatin1String(\"hs\")));\r\n                            Event e(RLights, RStateColorMode, i->id());\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n\r\n                        item = i->item(RStateHue);\r\n\r\n                        if (item && item->toNumber() != group->hue)\r\n                        {\r\n                            item->setValue(group->hue);\r\n                            Event e(RLights, RStateHue, i->id(), item);\r\n                            enqueueEvent(e);\r\n\r\n                            item = i->item(RStateSat);\r\n\r\n                            if (item && !hasXy && !hasSat)\r\n                            {\r\n                                double r, g, b;\r\n                                double x, y;\r\n                                double h = ((360.0 / 65535.0) * hue);\r\n                                double s = item->toNumber() / 255.0;\r\n                                double v = 1.0;\r\n\r\n                                Hsv2Rgb(&r, &g, &b, h, s, v);\r\n                                Rgb2xy(&x, &y, r, g, b);\r\n\r\n                                if (x < 0) { x = 0; }\r\n                                else if (x > 1) { x = 1; }\r\n\r\n                                if (y < 0) { y = 0; }\r\n                                else if (y > 1) { y = 1; }\r\n\r\n                                DBG_Printf(DBG_INFO, \"x: %f, y: %f\\n\", x, y);\r\n                                item = i->item(RStateX);\r\n                                if (item)\r\n                                {\r\n                                    x = x * 65535.0;\r\n                                    if (x > 65279) { x = 65279; }\r\n                                    else if (x < 1) { x = 1; }\r\n                                    item->setValue(static_cast<quint16>(x));\r\n                                }\r\n                                item = i->item(RStateY);\r\n                                if (item)\r\n                                {\r\n                                    y = y * 65535.0;\r\n                                    if (y > 65279) { y = 65279; }\r\n                                    else if (y < 1) { y = 1; }\r\n                                    item->setValue(static_cast<quint16>(y));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    // TODO case hasHue && hasSat not handled\r\n                    else if (hasSat)\r\n                    {\r\n                        if (item->toString() != QLatin1String(\"hs\"))\r\n                        {\r\n                            item->setValue(QVariant(QLatin1String(\"hs\")));\r\n                            Event e(RLights, RStateColorMode, i->id());\r\n                            enqueueEvent(e);\r\n                            modified = true;\r\n                        }\r\n\r\n                        item = i->item(RStateSat);\r\n\r\n                        if (item && item->toNumber() != group->sat)\r\n                        {\r\n                            item->setValue(group->sat);\r\n                            Event e(RLights, RStateSat, i->id(), item);\r\n                            enqueueEvent(e);\r\n\r\n                            if (!hasXy)\r\n                            {\r\n                                quint16 enhancedHue = 0;\r\n                                {\r\n                                    ResourceItem *item2 = i->item(RStateHue);\r\n                                    if (item2)\r\n                                    {\r\n                                        enhancedHue = static_cast<quint16>(item2->toNumber());\r\n                                    }\r\n                                }\r\n\r\n                                double r, g, b;\r\n                                double x, y;\r\n                                double h = (!hasHue) ? ((360.0 / 65535.0) * enhancedHue) : ((360.0 / 65535.0) * hue);\r\n                                double s = sat / 254.0;\r\n                                double v = 1.0;\r\n\r\n                                Hsv2Rgb(&r, &g, &b, h, s, v);\r\n                                Rgb2xy(&x, &y, r, g, b);\r\n\r\n                                if (x < 0) { x = 0; }\r\n                                else if (x > 1) { x = 1; }\r\n\r\n                                if (y < 0) { y = 0; }\r\n                                else if (y > 1) { y = 1; }\r\n\r\n                                DBG_Printf(DBG_INFO, \"x: %f, y: %f\\n\", x, y);\r\n                                item = i->item(RStateX);\r\n                                if (item)\r\n                                {\r\n                                    x = x * 65535.0;\r\n                                    if (x > 65279) { x = 65279; }\r\n                                    else if (x < 1) { x = 1; }\r\n                                    item->setValue(static_cast<quint16>(x));\r\n                                }\r\n                                item = i->item(RStateY);\r\n                                if (item)\r\n                                {\r\n                                    y = y * 65535.0;\r\n                                    if (y > 65279) { y = 65279; }\r\n                                    else if (y < 1) { y = 1; }\r\n                                    item->setValue(static_cast<quint16>(y));\r\n                                }\r\n                            }\r\n\r\n                            modified = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (modified)\r\n                {\r\n                    updateLightEtag(&*i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateGroupEtag(group);\r\n    rsp.etag = group->etag;\r\n\r\n    processTasks();\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/groups/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n    \\note currently not in Philips API 1.0\r\n */\r\nint DeRestPluginPrivate::deleteGroup(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n\r\n    userActivity();\r\n\r\n    if (!group || (group->state() == Group::StateDeleted) || (group->address() == gwGroup0))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    group->setState(Group::StateDeleted);\r\n    group->m_deviceMemberships.clear();\r\n\r\n    // remove any known scene\r\n    group->scenes.clear();\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"id\"] = id;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    queSaveDb(DB_GROUPS | DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n\r\n    // for each node which is part of this group send a remove group request (will be unicast)\r\n    // note: nodes which are curently switched off will not be removed!\r\n    std::vector<LightNode>::iterator i = nodes.begin();\r\n    std::vector<LightNode>::iterator end = nodes.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        GroupInfo *groupInfo = getGroupInfo(&(*i), group->address());\r\n\r\n        if (groupInfo)\r\n        {\r\n            i->setNeedSaveDatabase(true);\r\n            groupInfo->actions &= ~GroupInfo::ActionAddToGroup; // sanity\r\n            groupInfo->actions |= GroupInfo::ActionRemoveFromGroup;\r\n            groupInfo->state = GroupInfo::StateNotInGroup;\r\n        }\r\n    }\r\n\r\n    updateGroupEtag(group);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Adds a new group with unique id. */\r\nGroup *DeRestPluginPrivate::addGroup()\r\n{\r\n    for (quint16 id = 1 ; id < 5000; id++)\r\n    {\r\n        if (!getGroupForId(id))\r\n        {\r\n            Group group;\r\n            group.setAddress(id);\r\n            groups.push_back(group);\r\n            updateGroupEtag(&groups.back());\r\n            queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n            return &groups.back();\r\n        }\r\n    }\r\n\r\n    return nullptr;\r\n}\r\n\r\n/*! Put all parameters in a map for later json serialization.\r\n    \\return true - on success\r\n            false - on error\r\n */\r\nbool DeRestPluginPrivate::groupToMap(const ApiRequest &req, const Group *group, QVariantMap &map)\r\n{\r\n    if (!group)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    QVariantMap action;\r\n    QVariantMap state;\r\n    QVariantList scenes;\r\n\r\n    action[\"on\"] = group->isOn();\r\n    action[\"hue\"] = (double)((uint16_t)(group->hueReal * 65535));\r\n    action[\"effect\"] = group->isColorLoopActive() ? QLatin1String(\"colorloop\") : QLatin1String(\"none\");\r\n    action[\"bri\"] = (double)group->level;\r\n    action[\"sat\"] = (double)group->sat;\r\n    action[\"ct\"] = (double)group->colorTemperature;\r\n    action[\"alert\"] = group->alert;\r\n    QVariantList xy;\r\n\r\n    double colorX = group->colorX;\r\n    double colorY = group->colorY;\r\n    // sanity for colorX\r\n    if (colorX > 65279)\r\n    {\r\n        colorX = 65279;\r\n    }\r\n    // sanity for colorY\r\n    if (colorY > 65279)\r\n    {\r\n        colorY = 65279;\r\n    }\r\n    // x = CurrentX / 65536 (CurrentX in the range 0 to 65279 inclusive)\r\n    const double x = colorX / 65535.0; // normalize to 0 .. 1\r\n    const double y = colorY / 65535.0; // normalize to 0 .. 1\r\n    xy.append(x);\r\n    xy.append(y);\r\n    action[\"xy\"] = xy;\r\n    action[\"colormode\"] = group->colormode; // TODO\r\n\r\n    for (int i = 0; i < group->itemCount(); i++)\r\n    {\r\n        const ResourceItem *item = group->itemForIndex(i);\r\n        DBG_Assert(item != nullptr);\r\n        if (item->descriptor().suffix == RStateAllOn) { state[\"all_on\"] = item->toBool(); }\r\n        else if (item->descriptor().suffix == RStateAnyOn) { state[\"any_on\"] = item->toBool(); }\r\n        else if (item->descriptor().suffix == RActionScene) { action[\"scene\"] = item->toVariant(); }\r\n        else if (item->descriptor().suffix == RAttrName) { map[\"name\"] = item->toString(); }\r\n        else if (item->descriptor().suffix == RAttrType) { map[\"type\"] = item->toString(); }\r\n        else if (item->descriptor().suffix == RAttrClass) { map[\"class\"] = item->toString(); }\r\n        else if (item->descriptor().suffix == RAttrUniqueId) { map[\"uniqueid\"] = item->toString(); }\r\n    }\r\n    if (map[\"type\"] != QLatin1String(\"Room\"))\r\n    {\r\n        map.remove(\"class\");\r\n    }\r\n\r\n    map[\"id\"] = group->id();\r\n    QString etag = group->etag;\r\n    etag.remove('\"'); // no quotes allowed in string\r\n    map[\"etag\"] = etag;\r\n    map[\"action\"] = action;\r\n    map[\"state\"] = state;\r\n\r\n    // following attributes are only shown for Phoscon App\r\n    if (req.apiVersion() >= ApiVersion_1_DDEL)\r\n    {\r\n        QStringList multis;\r\n        auto m = group->m_multiDeviceIds.begin();\r\n        auto mend = group->m_multiDeviceIds.end();\r\n\r\n        for ( ;m != mend; ++m)\r\n        {\r\n            multis.append(*m);\r\n        }\r\n\r\n        map[\"hidden\"] = group->hidden;\r\n        map[\"multideviceids\"] = multis;\r\n\r\n        QStringList lightsequence;\r\n        auto l = group->m_lightsequence.begin();\r\n        auto lend = group->m_lightsequence.end();\r\n\r\n        for ( ;l != lend; ++l)\r\n        {\r\n            lightsequence.append(*l);\r\n        }\r\n\r\n        map[\"lightsequence\"] = lightsequence;\r\n    }\r\n\r\n    QStringList deviceIds;\r\n    auto d = group->m_deviceMemberships.begin();\r\n    auto dend = group->m_deviceMemberships.end();\r\n\r\n    for ( ;d != dend; ++d)\r\n    {\r\n        deviceIds.append(*d);\r\n    }\r\n\r\n    map[\"devicemembership\"] = deviceIds;\r\n\r\n    // append lights which are known members in this group\r\n    QVariantList lights;\r\n    std::vector<LightNode>::const_iterator i = nodes.begin();\r\n    std::vector<LightNode>::const_iterator end = nodes.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state() == LightNode::StateDeleted)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        std::vector<GroupInfo>::const_iterator ii = i->groups().begin();\r\n        std::vector<GroupInfo>::const_iterator eend = i->groups().end();\r\n\r\n        for (; ii != eend; ++ii)\r\n        {\r\n            if (ii->id == group->address())\r\n            {\r\n                if (ii->state == GroupInfo::StateInGroup)\r\n                {\r\n                    lights.append(i->id());\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    map[\"lights\"] = lights;\r\n\r\n    std::vector<Scene>::const_iterator si = group->scenes.begin();\r\n    std::vector<Scene>::const_iterator send = group->scenes.end();\r\n\r\n    for ( ;si != send; ++si)\r\n    {\r\n        if (si->state != Scene::StateDeleted)\r\n        {\r\n            QVariantMap scene;\r\n            QString sid = QString::number(si->id);\r\n            scene[\"id\"] = sid;\r\n            scene[\"name\"] = si->name;\r\n            scene[\"transitiontime\"] = si->transitiontime();\r\n            scene[\"lightcount\"] = (double)si->lights().size();\r\n\r\n            scenes.append(scene);\r\n        }\r\n    }\r\n\r\n    map[\"scenes\"] = scenes;\r\n\r\n    return true;\r\n}\r\n\r\n/*! POST /api/<apikey>/groups/<group_id>/scenes\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::createScene(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    Scene scene;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    userActivity();\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes\").arg(id), \"Not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() != Group::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    scene.setTransitiontime(10);\r\n\r\n    // name\r\n    if (map.contains(\"name\")) // required\r\n    {\r\n        QString name = map[\"name\"].toString().trimmed();\r\n\r\n        if (map[\"name\"].type() == QVariant::String)\r\n        {\r\n            if (name.size() <= 32)\r\n            {\r\n                scene.name = name;\r\n\r\n                std::vector<Scene>::const_iterator i = group->scenes.begin();\r\n                std::vector<Scene>::const_iterator end = group->scenes.end();\r\n\r\n                for (; i != end; ++i)\r\n                {\r\n                    if ((i->name == name) && (i->state != Scene::StateDeleted))\r\n                    {\r\n                        DBG_Printf(DBG_INFO, \"Scene with name %s already exist\\n\", qPrintable(name));\r\n\r\n                        rsp.list.append(errorToMap(ERR_DUPLICATE_EXIST, QString(\"/groups/%1/scenes\").arg(id), QString(\"resource, /groups/%1/scenes/%2, already exists\").arg(id).arg(name)));\r\n                        rsp.httpStatus = HttpStatusBadRequest;\r\n                        return REQ_READY_SEND;\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/name\").arg(id), QString(\"invalid value, %1, for parameter, /groups/%2/scenes/name\").arg(name).arg(id)));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/name\").arg(id), QString(\"invalid value, %1, for parameter, /groups/%2/scenes/name\").arg(name).arg(id)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    scene.id = 1;\r\n\r\n    // id\r\n    if (map.contains(\"id\")) // optional\r\n    {\r\n        uint sid = map[\"id\"].toUInt(&ok);\r\n        if (ok && sid < 256)\r\n        {\r\n            scene.id = sid;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/id\").arg(id), QString(\"invalid value, %1, for parameter, /groups/%2/scenes/id\").arg(map[\"id\"].toString()).arg(id)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        Scene *s = getSceneForId(group->address(), sid);\r\n\r\n        if (s && s->state == Scene::StateNormal)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DUPLICATE_EXIST, QString(\"/groups/%1/scenes\").arg(id), QString(\"resource, /groups/%1/scenes/%2, already exists\").arg(id).arg(sid)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // search a unused id\r\n    bool ommit = false;\r\n\r\n    if (group->m_deviceMemberships.size() >= 1)\r\n    {\r\n        QString deviceId = group->m_deviceMemberships[0];\r\n        Sensor *s = getSensorNodeForId(deviceId);\r\n        if (s && s->modelId() == QLatin1String(\"Lighting Switch\"))\r\n        {\r\n            ommit = true; // ommit scene 2 and 3 for Lighting Switch\r\n        }\r\n    }\r\n\r\n    do {\r\n        ok = true; // will be false if a scene.id is already used\r\n        std::vector<Scene>::iterator i = group->scenes.begin();\r\n        std::vector<Scene>::iterator end = group->scenes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (ommit && (scene.id == 2 || scene.id == 3))\r\n            {\r\n                scene.id++;\r\n                ok = false;\r\n            }\r\n            else if (i->id == scene.id)\r\n            {\r\n                if (i->state == Scene::StateDeleted)\r\n                {\r\n                    group->scenes.erase(i); // ok, replace\r\n                }\r\n                else\r\n                {\r\n                    scene.id++;\r\n                    ok = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    } while (!ok);\r\n\r\n    scene.groupAddress = group->address();\r\n\r\n    if (scene.name.isEmpty())\r\n    {\r\n        scene.name = tr(\"Scene %1\").arg(scene.id);\r\n    }\r\n\r\n    std::vector<LightNode>::iterator ni = nodes.begin();\r\n    std::vector<LightNode>::iterator nend = nodes.end();\r\n    for (; ni != nend; ++ni)\r\n    {\r\n        LightNode *lightNode = &(*ni);\r\n\r\n        if (lightNode->isAvailable() &&\r\n            isLightNodeInGroup(lightNode, group->address()))\r\n        {\r\n            if (lightNode->sceneCapacity() <= 0)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_DEVICE_SCENES_TABLE_FULL, QString(\"/groups/%1/scenes/lights/%2\").arg(id).arg(lightNode->id()), QString(\"Could not set scene for %1. Scene capacity of the device is reached.\").arg(qPrintable(lightNode->name()))));\r\n                continue;\r\n            }\r\n\r\n            LightState state;\r\n            state.setLightId(lightNode->id());\r\n            state.setTransitionTime(10);\r\n            ResourceItem *item = lightNode->item(RStateOn);\r\n            DBG_Assert(item != 0);\r\n            if (item)\r\n            {\r\n                state.setOn(item->toBool());\r\n            }\r\n            item = lightNode->item(RStateBri);\r\n            if (item)\r\n            {\r\n                state.setBri(qMin((quint16)item->toNumber(), (quint16)254));\r\n            }\r\n\r\n            item = lightNode->item(RStateColorMode);\r\n            if (item)\r\n            {\r\n                if (item->toString() == QLatin1String(\"xy\") || item->toString() == QLatin1String(\"hs\"))\r\n                {\r\n                    item = lightNode->item(RStateX);\r\n                    if (item)\r\n                    {\r\n                        state.setX(item->toNumber());\r\n                    }\r\n                    item = lightNode->item(RStateY);\r\n                    if (item)\r\n                    {\r\n                        state.setY(item->toNumber());\r\n                    }\r\n                    item = lightNode->item(RStateHue);\r\n                    if (item)\r\n                    {\r\n                        state.setEnhancedHue(item->toNumber());\r\n                    }\r\n                    item = lightNode->item(RStateSat);\r\n                    if (item)\r\n                    {\r\n                        state.setSaturation(item->toNumber());\r\n                    }\r\n                }\r\n                else if (item->toString() == QLatin1String(\"ct\"))\r\n                {\r\n                    item = lightNode->item(RStateCt);\r\n                    DBG_Assert(item != 0);\r\n                    if (item)\r\n                    {\r\n                        state.setColorTemperature(item->toNumber());\r\n                    }\r\n                }\r\n\r\n                state.setColorloopActive(lightNode->isColorLoopActive());\r\n                state.setColorloopTime(lightNode->colorLoopSpeed());\r\n                state.setColorMode(lightNode->toString(RStateColorMode));\r\n            }\r\n            else\r\n            {\r\n                state.setColorMode(QLatin1String(\"none\"));\r\n            }\r\n\r\n            scene.addLightState(state);\r\n            queSaveDb(DB_SCENES, DB_LONG_SAVE_DELAY);\r\n        }\r\n    }\r\n\r\n    group->scenes.push_back(scene);\r\n    updateGroupEtag(group);\r\n    queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n\r\n    if (!storeScene(group, scene.id))\r\n    {\r\n        rsp.list.append(errorToMap(ERR_BRIDGE_BUSY, QString(\"/groups/%1/scenes/%2\").arg(id).arg(scene.id), QString(\"gateway busy\")));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rspItemState[\"id\"] = QString::number(scene.id);\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/groups/<group_id>/scenes\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getAllScenes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n    Group *group = getGroupForId(id);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!group || (group->state() == Group::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1\").arg(id), QString(\"resource, /groups/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    std::vector<Scene>::const_iterator i = group->scenes.begin();\r\n    std::vector<Scene>::const_iterator end = group->scenes.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state != Scene::StateDeleted)\r\n        {\r\n            QString sceneId = QString::number(i->id);\r\n            QVariantMap scene;\r\n            scene[\"name\"] = i->name;\r\n\r\n            QVariantList lights;\r\n            std::vector<LightState>::const_iterator l = i->lights().begin();\r\n            std::vector<LightState>::const_iterator lend = i->lights().end();\r\n            for (; l != lend; ++l)\r\n            {\r\n                lights.append(l->lid());\r\n            }\r\n            scene[\"lights\"] = lights;\r\n            scene[\"transitiontime\"] = i->transitiontime();\r\n\r\n            rsp.map[sceneId] = scene;\r\n        }\r\n    }\r\n\r\n    if (rsp.map.isEmpty())\r\n    {\r\n        rsp.str = \"{}\"; // return empty object\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getSceneAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QString gid = req.path[3];\r\n    QString sid = req.path[5];\r\n    Group *group = getGroupForId(gid);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!group || (group->state() == Group::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    std::vector<Scene>::const_iterator i = group->scenes.begin();\r\n    std::vector<Scene>::const_iterator end = group->scenes.end();\r\n\r\n    uint sceneId = sid.toUInt(&ok);\r\n\r\n    if (ok)\r\n    {\r\n        for (; i != end; ++i)\r\n        {\r\n            if ((i->id == sceneId) && (i->state == Scene::StateNormal))\r\n            {\r\n                QVariantList lights;\r\n                std::vector<LightState>::const_iterator l = i->lights().begin();\r\n                std::vector<LightState>::const_iterator lend = i->lights().end();\r\n                for (; l != lend; ++l)\r\n                {\r\n                    QVariantMap lstate;\r\n                    lstate[\"id\"] = l->lid();\r\n                    lstate[\"on\"] = l->on();\r\n                    lstate[\"bri\"] = l->bri();\r\n                    LightNode *lightNode = getLightNodeForId(l->lid());\r\n                    if (lightNode && lightNode->hasColor()) // TODO store hasColor in LightState\r\n                    {\r\n                        if (l->colorMode() == QLatin1String(\"xy\"))\r\n                        {\r\n                            double x = l->x() / 65535.0;\r\n                            double y = l->y() / 65535.0;\r\n                            if (x > 0.9961) { x = 0.9961; }\r\n                            else if (x < 0) { x = 0; }\r\n                            if (y > 0.9961) { y = 0.9961; }\r\n                            else if (y < 0) { y = 0; }\r\n                            lstate[\"x\"] = x;\r\n                            lstate[\"y\"] = y;\r\n                        }\r\n                        else if (l->colorMode() == QLatin1String(\"ct\"))\r\n                        {\r\n                            lstate[\"ct\"] = (double)l->colorTemperature();\r\n                        }\r\n                        else if (l->colorMode() == QLatin1String(\"hs\"))\r\n                        {\r\n                            lstate[\"hue\"] = (double)l->enhancedHue();\r\n                            lstate[\"sat\"] = (double)l->saturation();\r\n                        }\r\n\r\n                        lstate[\"colormode\"] = l->colorMode();\r\n                    }\r\n                    lstate[\"transitiontime\"] = l->transitionTime();\r\n\r\n                    lights.append(lstate);\r\n                }\r\n                rsp.map[\"name\"] = i->name;\r\n                rsp.map[\"lights\"] = lights;\r\n                rsp.map[\"state\"] = i->state;\r\n                return REQ_READY_SEND;\r\n            }\r\n        }\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusNotFound;\r\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n    return REQ_READY_SEND;\r\n\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setSceneAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QString gid = req.path[3];\r\n    QString sid = req.path[5];\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    Group *group = getGroupForId(gid);\r\n    QString name;\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() == Group::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // name\r\n    if (map.contains(\"name\")) // optional\r\n    {\r\n        name = map[\"name\"].toString().trimmed();\r\n\r\n        if (map[\"name\"].type() == QVariant::String)\r\n        {\r\n            if (name.size() > MAX_SCENE_NAME_LENGTH)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/name\").arg(gid).arg(sid), QString(\"invalid value, %1, for parameter, /groups/%2/scenes/%3/name\").arg(name).arg(gid).arg(sid)));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/name\").arg(gid).arg(sid), QString(\"invalid value, %1, for parameter, /groups/%2/scenes/%3/name\").arg(name).arg(gid).arg(sid)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    std::vector<Scene>::iterator i = group->scenes.begin();\r\n    std::vector<Scene>::iterator end = group->scenes.end();\r\n\r\n    uint sceneId = sid.toUInt(&ok);\r\n\r\n    if (ok)\r\n    {\r\n        for (; i != end; ++i)\r\n        {\r\n            if ((i->id == sceneId) && (i->state != Scene::StateDeleted))\r\n            {\r\n                if (!name.isEmpty())\r\n                {\r\n                    if (i->name != name)\r\n                    {\r\n                        i->name = name;\r\n                        updateGroupEtag(group);\r\n                        queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n                    }\r\n\r\n                    rspItemState[QString(\"/groups/%1/scenes/%2/name\").arg(gid).arg(sid)] = name;\r\n                    rspItem[\"success\"] = rspItemState;\r\n                    rsp.list.append(rspItem);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusNotFound;\r\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT /api/<apikey>/groups/<group_id>/scenes/<scene_id>/store\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::storeScene(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    const QString &gid = req.path[3];\r\n    const QString &sid = req.path[5];\r\n    Group *group = getGroupForId(gid);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    userActivity();\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), \"not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() != Group::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // check if scene exists\r\n    uint8_t sceneId = sid.toUInt(&ok);\r\n    Scene *scene = ok ? group->getScene(sceneId) : 0;\r\n\r\n    if (!scene || (scene->state != Scene::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (map.contains(\"transitiontime\"))\r\n    {\r\n        uint tt = map[\"transitiontime\"].toUInt(&ok);\r\n\r\n        if (ok && tt < 0xFFFFUL)\r\n        {\r\n            scene->setTransitiontime(tt);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/transitiontime\").arg(gid).arg(sid), QString(\"invalid value, %1, for parameter transitiontime\").arg(tt)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        scene->setTransitiontime(10);\r\n    }\r\n\r\n    if (scene->externalMaster)\r\n    {\r\n        // we take control over scene\r\n        scene->externalMaster = false;\r\n    }\r\n\r\n    if (!storeScene(group, scene->id))\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        rsp.list.append(errorToMap(ERR_BRIDGE_BUSY, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"gateway busy\")));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // search for lights that have their scenes capacity reached or need to be updated\r\n    std::vector<LightNode>::iterator ni = nodes.begin();\r\n    std::vector<LightNode>::iterator nend = nodes.end();\r\n    for (; ni != nend; ++ni)\r\n    {\r\n        LightNode *lightNode = &*ni;\r\n        if (!lightNode->isAvailable())\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (!isLightNodeInGroup(lightNode, group->address()))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        bool needModify = false;\r\n        LightState *ls = scene->getLightState(lightNode->id());\r\n\r\n        if (!ls)\r\n        {\r\n            LightState lsnew;\r\n            lsnew.setLightId(lightNode->id());\r\n\r\n            /*if (lightNode->sceneCapacity() <= 0)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_DEVICE_SCENES_TABLE_FULL, QString(\"/groups/%1/scenes/lights/%2\").arg(gid).arg(lightNode->id()), QString(\"Could not set scene for %1. Scene capacity of the device is reached.\").arg(qPrintable(lightNode->name()))));\r\n            }*/\r\n\r\n            scene->addLightState(lsnew);\r\n            ls = scene->getLightState(lightNode->id());\r\n            needModify = true;\r\n        }\r\n\r\n        if (!ls)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (req.sock != nullptr) // this isn't done by a rule (sensor pir control)\r\n        {\r\n            ls->setNeedRead(true);\r\n        }\r\n\r\n        lightNode->clearRead(READ_SCENE_DETAILS | READ_SCENES); // prevent reading before writing\r\n\r\n        ResourceItem *item = lightNode->item(RStateOn);\r\n        DBG_Assert(item != 0);\r\n\r\n        if (item && ls->on() != item->toBool())\r\n        {\r\n            ls->setOn(item->toBool());\r\n            needModify = true;\r\n        }\r\n\r\n        item = lightNode->item(RStateBri);\r\n\r\n        if (item && ls->bri() != item->toNumber())\r\n        {\r\n            ls->setBri(qMin((quint16)item->toNumber(), (quint16)254));\r\n            needModify = true;\r\n        }\r\n\r\n        item = lightNode->item(RStateColorMode);\r\n\r\n        if (item)\r\n        {\r\n            if (ls->colorMode() != item->toString())\r\n            {\r\n                ls->setColorMode(item->toString());\r\n                needModify = true;\r\n            }\r\n\r\n            if (item->toString() == QLatin1String(\"xy\") ||\r\n                item->toString() == QLatin1String(\"hs\"))\r\n            {\r\n                item = lightNode->item(RStateHue);\r\n                DBG_Assert(item != 0);\r\n                if (item && item->toNumber() != ls->enhancedHue())\r\n                {\r\n                    ls->setEnhancedHue(item->toNumber());\r\n                    needModify = true;\r\n                }\r\n\r\n                item = lightNode->item(RStateSat);\r\n                DBG_Assert(item != 0);\r\n                if (item && item->toNumber() != ls->saturation())\r\n                {\r\n                    ls->setSaturation(item->toNumber());\r\n                    needModify = true;\r\n                }\r\n\r\n                item = lightNode->item(RStateX);\r\n                DBG_Assert(item != 0);\r\n                if (item && item->toNumber() != ls->x())\r\n                {\r\n                    ls->setX(item->toNumber());\r\n                    needModify = true;\r\n                }\r\n\r\n                item = lightNode->item(RStateY);\r\n                DBG_Assert(item != 0);\r\n                if (item && item->toNumber() != ls->y())\r\n                {\r\n                    ls->setY(item->toNumber());\r\n                    needModify = true;\r\n                }\r\n            }\r\n            else if (item->toString() == QLatin1String(\"ct\"))\r\n            {\r\n                item = lightNode->item(RStateCt);\r\n                DBG_Assert(item != 0);\r\n                if (item && item->toNumber() != ls->colorTemperature())\r\n                {\r\n                    ls->setColorTemperature(item->toNumber());\r\n                    needModify = true;\r\n                }\r\n            }\r\n        }\r\n        else if (ls->colorMode() != QLatin1String(\"none\"))\r\n        {\r\n            ls->setColorMode(QLatin1String(\"none\"));\r\n            needModify = true;\r\n        }\r\n\r\n        if (ls->transitionTime() != scene->transitiontime())\r\n        {\r\n            ls->setTransitionTime(scene->transitiontime());\r\n            needModify = true;\r\n        }\r\n\r\n        if (needModify)\r\n        {\r\n            queSaveDb(DB_SCENES, DB_LONG_SAVE_DELAY);\r\n        }\r\n\r\n        if (req.sock != nullptr)\r\n        {\r\n            ls->tVerified.invalidate(); // invalidate, trigger verify or add\r\n        }\r\n    }\r\n\r\n    updateGroupEtag(group);\r\n\r\n    rspItemState[\"id\"] = sid;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Scenes for IKEA lights with state.on = false don't work.\r\n    This functions sends a OFF_WITH_EFFECT command which forces the light to turn off (normal off doesn't work).\r\n    TODO remove when IKEA has fixed the bug in firmware.\r\n*/\r\nstatic void ikeaTurnLightOffInSceneHack(DeRestPluginPrivate *d, LightNode *lightNode)\r\n{\r\n    TaskItem task;\r\n    task.lightNode = lightNode;\r\n    task.req.dstAddress() = task.lightNode->address();\r\n    task.req.setDstEndpoint(task.lightNode->haEndpoint().endpoint());\r\n    task.req.setSrcEndpoint(d->getSrcEndpoint(task.lightNode, task.req));\r\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n    d->addTaskSetOnOff(task, ONOFF_COMMAND_OFF_WITH_EFFECT, 0, 0);\r\n}\r\n\r\n/*! GLEDOPTO extended color lights do not correctly recall scenes that\r\n    were created with color temperature. Thus, RGB leds are used instead of the\r\n    cct. workaround is to send a unicast to switch to ct mode.\r\n*/\r\nstatic void gledoptoSetColorTemperatureInSceneHack(DeRestPluginPrivate *d, LightNode *lightNode)\r\n{\r\n    TaskItem task;\r\n    task.lightNode = lightNode;\r\n    task.req.dstAddress() = task.lightNode->address();\r\n    // task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\r\n    task.req.setDstEndpoint(task.lightNode->haEndpoint().endpoint());\r\n    task.req.setSrcEndpoint(d->getSrcEndpoint(task.lightNode, task.req));\r\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n    d->addTaskSetColorTemperature(task, static_cast<double>(lightNode->item(RStateCt)->toNumber()));\r\n}\r\n\r\n/*! Checks the lights states in a scene:\r\n    - Creates unicast tasks for colorloop turn on/off\r\n    - Creates unicast tasks for IKEA lights which are off in a scene -> hack.\r\n    - Sets group.on according to the light states\r\n*/\r\nstatic void recallSceneCheckGroupChanges(DeRestPluginPrivate *d, Group *group, Scene *scene)\r\n{\r\n    bool groupOn = false;\r\n    bool groupOnChanged = false;\r\n    bool groupBriChanged = false;\r\n    bool groupHueSatChanged = false;\r\n    bool groupCtChanged = false;\r\n    bool groupColorModeChanged = false;\r\n\r\n    auto ls = scene->lights().cbegin();\r\n    const auto lsend = scene->lights().cend();\r\n\r\n    for (; ls != lsend; ++ls)\r\n    {\r\n        LightNode *lightNode = d->getLightNodeForId(ls->lid());\r\n\r\n        if (!lightNode || lightNode->state() != LightNode::StateNormal || !lightNode->isAvailable())\r\n        {\r\n            continue;\r\n        }\r\n\r\n        bool changed = false;\r\n\r\n        if (ls->on())\r\n        {\r\n            groupOn = true;\r\n        }\r\n        else if (lightNode->manufacturerCode() == VENDOR_IKEA)\r\n        {\r\n            ikeaTurnLightOffInSceneHack(d, lightNode);\r\n        }\r\n\r\n        {\r\n            const bool supportsColorLoop = lightNode->supportsColorLoop();\r\n            const bool colorLoopActive = ls->on() && supportsColorLoop && ls->colorloopActive();\r\n            if (supportsColorLoop && lightNode->isColorLoopActive() != colorLoopActive)\r\n            {\r\n                // this is called in rare cases to turn colorloop on/off for supported lights\r\n                TaskItem task2;\r\n                task2.lightNode = lightNode;\r\n                task2.req.dstAddress() = task2.lightNode->address();\r\n                //task2.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\r\n                task2.req.setDstEndpoint(task2.lightNode->haEndpoint().endpoint());\r\n                task2.req.setSrcEndpoint(d->getSrcEndpoint(task2.lightNode, task2.req));\r\n                task2.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n\r\n                lightNode->setColorLoopActive(colorLoopActive);\r\n\r\n                if (lightNode->isColorLoopActive())\r\n                {\r\n                    lightNode->setColorLoopSpeed(ls->colorloopTime());\r\n                }\r\n\r\n                d->addTaskSetColorLoop(task2, colorLoopActive, ls->colorloopTime());\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        // TODO the following is fake, better let ZCL reporting and Poll manager let this figure out?!\r\n\r\n        ResourceItem *item = lightNode->item(RStateOn);\r\n        if (item && item->toBool() != ls->on())\r\n        {\r\n            item->setValue(ls->on());\r\n            enqueueEvent(Event(RLights, RStateOn, lightNode->id(), item));\r\n            changed = true;\r\n            groupOnChanged = true;\r\n        }\r\n\r\n        item = lightNode->item(RStateBri);\r\n        if (item && ls->bri() != item->toNumber())\r\n        {\r\n            item->setValue(ls->bri());\r\n            enqueueEvent(Event(RLights, RStateBri, lightNode->id(), item));\r\n            changed = true;\r\n            groupBriChanged = true;\r\n        }\r\n\r\n        item = lightNode->item(RStateColorMode);\r\n        if (item)\r\n        {\r\n            if (ls->colorMode() != item->toString())\r\n            {\r\n                item->setValue(ls->colorMode());\r\n                enqueueEvent(Event(RLights, RStateColorMode, lightNode->id()));\r\n                changed = true;\r\n                groupColorModeChanged = true;\r\n            }\r\n\r\n            if (ls->colorMode() == QLatin1String(\"xy\"))\r\n            {\r\n                item = lightNode->item(RStateX);\r\n                if (item && ls->x() != item->toNumber())\r\n                {\r\n                    item->setValue(ls->x());\r\n                    enqueueEvent(Event(RLights, RStateX, lightNode->id(), item));\r\n                    changed = true;\r\n                }\r\n                item = lightNode->item(RStateY);\r\n                if (item && ls->y() != item->toNumber())\r\n                {\r\n                    item->setValue(ls->y());\r\n                    enqueueEvent(Event(RLights, RStateY, lightNode->id(), item));\r\n                    changed = true;\r\n                }\r\n            }\r\n            else if(ls->colorMode() == QLatin1String(\"ct\"))\r\n            {\r\n                if (lightNode->manufacturer() == QLatin1String(\"GLEDOPTO\") &&\r\n                    lightNode->type() == QLatin1String(\"Extended color light\"))\r\n                {\r\n                    gledoptoSetColorTemperatureInSceneHack(d, lightNode);\r\n                }\r\n                item = lightNode->item(RStateCt);\r\n                if (item && ls->colorTemperature() != item->toNumber())\r\n                {\r\n                    item->setValue(ls->colorTemperature());\r\n                    enqueueEvent(Event(RLights, RStateCt, lightNode->id(), item));\r\n                    changed = true;\r\n                    groupCtChanged = true;\r\n                }\r\n            }\r\n            else if (ls->colorMode() == QLatin1String(\"hs\"))\r\n            {\r\n                item = lightNode->item(RStateHue);\r\n                if (item && ls->enhancedHue() != item->toNumber())\r\n                {\r\n                    item->setValue(ls->enhancedHue());\r\n                    enqueueEvent(Event(RLights, RStateHue, lightNode->id(), item));\r\n                    changed = true;\r\n                    groupHueSatChanged = true;\r\n                }\r\n\r\n                item = lightNode->item(RStateSat);\r\n                if (item && ls->saturation() != item->toNumber())\r\n                {\r\n                    item->setValue(ls->saturation());\r\n                    enqueueEvent(Event(RLights, RStateSat, lightNode->id(), item));\r\n                    changed = true;\r\n                    groupHueSatChanged = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (changed)\r\n        {\r\n            d->updateLightEtag(lightNode);\r\n        }\r\n    }\r\n\r\n    if (groupOnChanged || groupBriChanged || groupHueSatChanged || groupCtChanged || groupColorModeChanged)\r\n    {\r\n        if (groupOn && !group->isOn())\r\n        {\r\n            group->setIsOn(true);\r\n            d->updateGroupEtag(group);\r\n        }\r\n    }\r\n}\r\n\r\n/*! PUT /api/<apikey>/groups/<group_id>/scenes/<scene_id>/recall\r\n    PUT /api/<apikey>/groups/<group_id>/scenes/next/recall\r\n    PUT /api/<apikey>/groups/<group_id>/scenes/prev/recall\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::recallScene(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    const QString &gid = req.path[3];\r\n    const QString &sid = req.path[5];\r\n    Group *group = getGroupForId(gid);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (req.sock)\r\n    {\r\n        userActivity();\r\n    }\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), \"not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() != Group::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // check if scene exists\r\n    Scene *scene = nullptr;\r\n    uint8_t sceneId = 0;\r\n    ok = false;\r\n    if (sid == QLatin1String(\"next\") || sid == QLatin1String(\"prev\"))\r\n    {\r\n        ResourceItem *item = group->item(RActionScene);\r\n        DBG_Assert(item != 0);\r\n        uint lastSceneId = 0;\r\n        if (item && !item->toString().isEmpty())\r\n        {\r\n            lastSceneId = item->toString().toUInt(&ok);\r\n        }\r\n\r\n        int idx = -1;\r\n        std::vector<quint8> scenes; // available scenes\r\n\r\n        for (const Scene &s : group->scenes)\r\n        {\r\n            if (s.state != Scene::StateNormal)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (lastSceneId == s.id)\r\n            {\r\n                idx = scenes.size(); // remember current index\r\n            }\r\n            scenes.emplace_back(s.id);\r\n        }\r\n\r\n        if (scenes.size() == 1)\r\n        {\r\n            ok = true;\r\n            sceneId = scenes[0];\r\n        }\r\n        else if (scenes.size() > 1)\r\n        {\r\n            ok = true;\r\n            if (idx == -1) // not found\r\n            {\r\n                idx = 0; // use first\r\n            }\r\n            else if (sid[0] == 'p') // prev\r\n            {\r\n                if (idx > 0)  { idx--; }\r\n                else          { idx = scenes.size() - 1; } // jump to last scene\r\n            }\r\n            else // next\r\n            {\r\n                if (idx < int(scenes.size() - 1)) { idx++; }\r\n                else  { idx = 0; } // jump to first scene\r\n            }\r\n            DBG_Assert(idx >= 0 && idx < int(scenes.size()));\r\n            sceneId = scenes[idx];\r\n        }\r\n        // else ok == false\r\n    }\r\n    else\r\n    {\r\n        sceneId = sid.toUInt(&ok);\r\n    }\r\n\r\n    scene = ok ? group->getScene(sceneId) : nullptr;\r\n\r\n    if (!scene || (scene->state != Scene::StateNormal))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!callScene(group, sceneId))\r\n    {\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        rsp.list.append(errorToMap(ERR_BRIDGE_BUSY, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"gateway busy\")));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    {\r\n        const QString scid = QString::number(sceneId);\r\n        ResourceItem *item = group->item(RActionScene);\r\n        if (item && item->toString() != scid)\r\n        {\r\n            item->setValue(scid);\r\n            updateGroupEtag(group);\r\n            Event e(RGroups, RActionScene, group->id(), item);\r\n            enqueueEvent(e);\r\n        }\r\n    }\r\n\r\n    recallSceneCheckGroupChanges(this, group, scene);\r\n\r\n    updateEtag(gwConfigEtag);\r\n\r\n    rspItemState[\"id\"] = sid;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    processTasks();\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/groups/<group_id>/scenes/<scene_id>/lights/<light_id>/state\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::modifyScene(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    Scene scene;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QString gid = req.path[3];\r\n    QString sid = req.path[5];\r\n    QString lid = req.path[7];\r\n    Group *group = getGroupForId(gid);\r\n    LightNode *light = getLightNodeForId(lid);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    userActivity();\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), \"Not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() == Group::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"resource, /groups/%1, not available\").arg(gid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!light || (light->state() == LightNode::StateDeleted) || !light->isAvailable())\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"resource, /lights/%1, not available\").arg(lid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    bool on;\r\n    uint bri = 0;\r\n    uint tt = 0;\r\n    uint16_t xy_x;\r\n    uint16_t xy_y;\r\n    uint16_t ct = 0;\r\n\r\n    bool hasOn = false;\r\n    bool hasBri = false;\r\n    bool hasTt = false;\r\n    bool hasXy = false;\r\n    bool hasCt = false;\r\n\r\n    // on\r\n    if (map.contains(\"on\"))\r\n    {\r\n        on = map[\"on\"].toBool();\r\n\r\n        if (map[\"on\"].type() == QVariant::Bool)\r\n        {\r\n            hasOn = true;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/lights/%3/state/on\").arg(gid).arg(sid).arg(lid), QString(\"invalid value, %1, for parameter on\").arg(on)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // bri\r\n    if (map.contains(\"bri\"))\r\n    {\r\n        bool ok;\r\n        bri = map[\"bri\"].toUInt(&ok);\r\n\r\n        if (ok && map[\"bri\"].type() == QVariant::Double && (bri < 256))\r\n        {\r\n            hasBri = true;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/lights/%3/state/bri\").arg(gid).arg(sid).arg(lid), QString(\"invalid value, %1, for parameter bri\").arg(bri)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // transitiontime\r\n    if (map.contains(\"transitiontime\"))\r\n    {\r\n        bool ok;\r\n        tt = map[\"transitiontime\"].toUInt(&ok);\r\n\r\n        if (ok && tt < 0xFFFFUL)\r\n        {\r\n            hasTt = true;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/lights/%3/state/bri\").arg(gid).arg(sid).arg(lid), QString(\"invalid value, %1, for parameter bri\").arg(tt)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"ct\"))\r\n    {\r\n        bool ok;\r\n        ct = map[\"ct\"].toUInt(&ok);\r\n\r\n        if (ok && map[\"ct\"].type() == QVariant::Double && (ct < 1000))\r\n        {\r\n            hasCt = true;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/lights/%3/state/ct\").arg(gid).arg(sid).arg(lid), QString(\"invalid value, %1, for parameter ct\").arg(ct)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // xy\r\n    if (map.contains(\"xy\"))\r\n    {\r\n        QVariantList xy = map[\"xy\"].toList();\r\n\r\n        if ((xy.size() == 2) && (xy[0].type() == QVariant::Double) && (xy[1].type() == QVariant::Double))\r\n        {\r\n            double x = xy[0].toDouble(&ok);\r\n            double y = ok ? xy[1].toDouble() : 0;\r\n\r\n            if (!ok || (x < 0.0) || (x > 1.0) || (y < 0.0) || (y > 1.0))\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1\").arg(lid), QString(\"invalid value, [%1,%2], for parameter, /lights/%3/xy\").arg(x).arg(y).arg(lid)));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n            else\r\n            {\r\n                hasXy = true;\r\n                xy_x = static_cast<quint16>(x * 65535.0);\r\n                xy_y = static_cast<quint16>(y * 65535.0);\r\n\r\n                if (xy_x > 65279) { xy_x = 65279; }\r\n                else if (xy_x == 0) { xy_x = 1; }\r\n\r\n                if (xy_y > 65279) { xy_y = 65279; }\r\n                else if (xy_y == 0) { xy_y = 1; }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/groups/%1/scenes/%2/lights/%3/state/xy\").arg(gid).arg(sid).arg(lid), QString(\"invalid value, %1, for parameter xy\").arg(xy[0].toString()).arg(xy[1].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    std::vector<Scene>::iterator i = group->scenes.begin();\r\n    std::vector<Scene>::iterator end = group->scenes.end();\r\n\r\n    bool foundScene = false;\r\n    bool foundLightState = false;\r\n\r\n    for ( ;i != end; ++i)\r\n    {\r\n        if (QString::number(i->id) == sid && i->state != Scene::StateDeleted)\r\n        {\r\n            foundScene = true;\r\n            scene = *i;\r\n\r\n            std::vector<LightState>::iterator l = i->lights().begin();\r\n            std::vector<LightState>::iterator lend = i->lights().end();\r\n\r\n            for ( ;l != lend; ++l)\r\n            {\r\n                if (l->lid() == lid)\r\n                {\r\n                    foundLightState = true;\r\n\r\n                    if (hasOn)\r\n                    {\r\n                        l->setOn(on);\r\n                    }\r\n                    if (hasBri)\r\n                    {\r\n                        l->setBri(bri);\r\n                    }\r\n                    if (hasTt)\r\n                    {\r\n                        l->setTransitionTime(tt);\r\n                    }\r\n                    if (hasXy)\r\n                    {\r\n                        l->setColorMode(QLatin1String(\"xy\"));\r\n                        l->setX(xy_x);\r\n                        l->setY(xy_y);\r\n                    }\r\n                    else if (hasCt)\r\n                    {\r\n                        l->setColorMode(QLatin1String(\"ct\"));\r\n                        l->setColorTemperature(ct);\r\n                    }\r\n\r\n                    if (!modifyScene(group, i->id))\r\n                    {\r\n                        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n                        rsp.list.append(errorToMap(ERR_BRIDGE_BUSY, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"gateway busy\")));\r\n                        return REQ_READY_SEND;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!foundLightState)\r\n            {\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"Light %1 is not available in scene.\").arg(lid)));\r\n                return REQ_READY_SEND;\r\n\r\n                /* //TODO or not TODO: add light to scene, when light is not a member of the scene. Error Message when ScenesTable of device is full.\r\n                if (hasOn && hasBri && hastt && hasXy)\r\n                {\r\n                    LightState state;\r\n                    state.setOn(on);\r\n                    state.setBri(bri);\r\n                    state.setTransitiontime(tt);\r\n                    state.setX(xy_x);\r\n                    state.setY(xy_y);\r\n                    state.setLid(lid);\r\n\r\n                    if (!modifyScene(group, i->id))\r\n                    {\r\n                        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n                        rsp.list.append(errorToMap(ERR_BRIDGE_BUSY, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"gateway busy\")));\r\n                        return REQ_READY_SEND;\r\n                    }\r\n\r\n                    i->m_lights.push_back(state);\r\n                }\r\n                else\r\n                {\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"Light %1 not available in scene. Missing parameters to add light to scene.\").arg(lid)));\r\n                    return REQ_READY_SEND;\r\n                }\r\n                */\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!foundScene)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2/lights/%3/state\").arg(gid).arg(sid).arg(lid), QString(\"resource, /scenes/%1, not available\").arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    updateGroupEtag(group);\r\n\r\n    queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n\r\n    rspItemState[\"id\"] = sid;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/groups/<group_id>/scenes/<scene_id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::deleteScene(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    QString gid = req.path[3];\r\n    QString sid = req.path[5];\r\n    Group *group = getGroupForId(gid);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    userActivity();\r\n\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), \"Not connected\"));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!group || (group->state() == Group::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // check if scene exists\r\n    Scene scene;\r\n    std::vector<Scene>::iterator i = group->scenes.begin();\r\n    std::vector<Scene>::iterator end = group->scenes.end();\r\n\r\n    uint8_t sceneId = sid.toUInt(&ok);\r\n\r\n    if (ok)\r\n    {\r\n        ok = false;\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->id == sceneId)\r\n            {\r\n                scene = *i;\r\n\r\n                if (!removeScene(group, scene.id))\r\n                {\r\n                    rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), \"gateway busy\"));\r\n                    rsp.httpStatus = HttpStatusServiceUnavailable;\r\n                    return REQ_READY_SEND;\r\n                }\r\n\r\n                ok = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/groups/%1/scenes/%2\").arg(gid).arg(sid), QString(\"resource, /groups/%1/scenes/%2, not available\").arg(gid).arg(sid)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    updateGroupEtag(group);\r\n    queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n\r\n    rspItemState[\"id\"] = QString::number(scene.id);\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\nvoid DeRestPluginPrivate::handleGroupEvent(const Event &e)\r\n{\r\n    DBG_Assert(e.resource() == RGroups);\r\n    DBG_Assert(e.what() != nullptr);\r\n    DBG_Assert(e.num() >= 0);\r\n    DBG_Assert(e.num() <= UINT16_MAX);\r\n\r\n    if (e.num() < 0 || e.num() > UINT16_MAX)\r\n    {\r\n        return;\r\n    }\r\n\r\n    const quint16 groupId = static_cast<quint16>(e.num());\r\n    Group *group = getGroupForId(groupId);\r\n\r\n    if (!group)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (e.what() == REventCheckGroupAnyOn)\r\n    {\r\n        int on = 0;\r\n        int count = 0;\r\n\r\n        std::vector<LightNode>::const_iterator i = nodes.begin();\r\n        std::vector<LightNode>::const_iterator end = nodes.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (!isLightNodeInGroup(&*i, group->address()))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const ResourceItem *item = i->item(RStateOn);\r\n\r\n            if (i->isAvailable() && item)\r\n            {\r\n                count++;\r\n                if (item->toBool()) { on++; }\r\n            }\r\n        }\r\n\r\n        ResourceItem *item = group->item(RStateAllOn);\r\n        DBG_Assert(item != nullptr);\r\n        if (item && (item->toBool() != (on > 0 && on == count) || !item->lastSet().isValid()))\r\n        {\r\n            item->setValue(on > 0 && on == count);\r\n            updateGroupEtag(group);\r\n            Event e(RGroups, RStateAllOn, group->address());\r\n            enqueueEvent(e);\r\n        }\r\n        item = group->item(RStateAnyOn);\r\n        DBG_Assert(item != nullptr);\r\n        if (item && (item->toBool() != (on > 0) || !item->lastSet().isValid()))\r\n        {\r\n            item->setValue(on > 0);\r\n            updateGroupEtag(group);\r\n            Event e(RGroups, RStateAnyOn, group->address());\r\n            enqueueEvent(e);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // push state updates through websocket\r\n    if (strncmp(e.what(), \"state/\", 6) == 0)\r\n    {\r\n        ResourceItem *item = group->item(e.what());\r\n        if (item)\r\n        {\r\n            if (!(item->needPushSet() || item->needPushChange()))\r\n            {\r\n                return; // already pushed\r\n            }\r\n\r\n            QVariantMap map;\r\n            map[\"t\"] = QLatin1String(\"event\");\r\n            map[\"e\"] = QLatin1String(\"changed\");\r\n            map[\"r\"] = QLatin1String(\"groups\");\r\n            map[\"id\"] = group->id();\r\n            QVariantMap state;\r\n\r\n            for (int i = 0; i < group->itemCount(); i++)\r\n            {\r\n                item = group->itemForIndex(i);\r\n                const ResourceItemDescriptor &rid = item->descriptor();\r\n\r\n                if (strncmp(rid.suffix, \"state/\", 6) == 0)\r\n                {\r\n                    const char *key = item->descriptor().suffix + 6;\r\n\r\n                    if (gwWebSocketNotifyAll || item->needPushChange())\r\n                    {\r\n                        state[key] = item->toVariant();\r\n                        item->clearNeedPush();\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            if (!state.isEmpty())\r\n            {\r\n                map[\"state\"] = state;\r\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n                updateGroupEtag(group);\r\n                plugin->saveDatabaseItems |= DB_GROUPS;\r\n                plugin->queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n        }\r\n    }\r\n    else if (strncmp(e.what(), \"attr/\", 5) == 0)\r\n    {\r\n        ResourceItem *item = group->item(e.what());\r\n        if (item)\r\n        {\r\n            QVariantMap map;\r\n            map[\"t\"] = QLatin1String(\"event\");\r\n            map[\"e\"] = QLatin1String(\"changed\");\r\n            map[\"r\"] = QLatin1String(\"groups\");\r\n            map[\"id\"] = group->id();\r\n            map[e.what() + 5] = item->toVariant();\r\n\r\n            webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n        }\r\n    }\r\n    else if (e.what() == REventAdded)\r\n    {\r\n        QVariantMap map;\r\n        map[\"t\"] = QLatin1String(\"event\");\r\n        map[\"e\"] = QLatin1String(\"added\");\r\n        map[\"r\"] = QLatin1String(\"groups\");\r\n        map[\"id\"] = e.id();\r\n\r\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n    }\r\n    else if (e.what() == REventDeleted)\r\n    {\r\n        QVariantMap map;\r\n        map[\"t\"] = QLatin1String(\"event\");\r\n        map[\"e\"] = QLatin1String(\"deleted\");\r\n        map[\"r\"] = QLatin1String(\"groups\");\r\n        map[\"id\"] = e.id();\r\n\r\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n    }\r\n}\r\n"
        },
        {
          "name": "rest_info.cpp",
          "type": "blob",
          "size": 1.060546875,
          "content": "/*\n * Copyright (c) 2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n/*! Info REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleInfoApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    // GET /api/<apikey>/info/timezones\n    if ((req.path.size() == 4) && (req.hdr.method() == \"GET\") && (req.path[3] == \"timezones\"))\n    {\n        return getInfoTimezones(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! GET /api/<apikey>/info/timezones\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getInfoTimezones(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n\n    rsp.list = getTimezones();\n\n    rsp.httpStatus = HttpStatusOk;\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rest_lights.cpp",
          "type": "blob",
          "size": 172.0478515625,
          "content": "/*\r\n * Copyright (c) 2013-2023 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QString>\r\n#include <QTextCodec>\r\n#include <QTcpSocket>\r\n#include <QUrlQuery>\r\n#include <QVariantMap>\r\n#include <math.h>\r\n#include \"database.h\"\r\n#include \"de_web_plugin.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"device_descriptions.h\"\r\n#include \"json.h\"\r\n#include \"colorspace.h\"\r\n#include \"product_match.h\"\r\n#include \"tuya.h\"\r\n\r\n#define COLOR_CAPABILITIES_HS 0x01\r\n#define COLOR_CAPABILITIES_ENHANCED_HS 0x02\r\n#define COLOR_CAPABILITIES_COLORLOOP 0x04\r\n#define COLOR_CAPABILITIES_XY 0x08\r\n#define COLOR_CAPABILITIES_CT 0x10\r\n\r\n/*! Lights REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleLightsApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    if (req.path[2] != QLatin1String(\"lights\"))\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    // GET /api/<apikey>/lights\r\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getAllLights(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/lights\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"POST\"))\r\n    {\r\n        return searchNewLights(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/lights/new\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\") && (req.path[3] == \"new\"))\r\n    {\r\n        return getNewLights(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/lights/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getLightState(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/lights/<id>/data?maxrecords=<maxrecords>&fromtime=<ISO 8601>\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"GET\") && (req.path[4] == \"data\"))\r\n    {\r\n        return getLightData(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/lights/<id>/state\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\") && (req.path[4] == \"state\"))\r\n    {\r\n        return setLightState(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/lights/<id>/config\r\n    else if ((req.path.size() == 5) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\") && (req.path[4] == \"config\"))\r\n    {\r\n        return setLightConfig(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/lights/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\"))\r\n    {\r\n        return setLightAttributes(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/lights/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\"))\r\n    {\r\n        return deleteLight(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/lights/<id>/scenes\r\n    else if ((req.path.size() == 5) && (req.path[4] == \"scenes\") && (req.hdr.method() == \"DELETE\"))\r\n    {\r\n        return removeAllScenes(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/lights/<id>/groups\r\n    else if ((req.path.size() == 5) && (req.path[4] == \"groups\") && (req.hdr.method() == \"DELETE\"))\r\n    {\r\n        return removeAllGroups(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! GET /api/<apikey>/lights\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getAllLights(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (gwLightsEtag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    std::vector<LightNode>::const_iterator i = nodes.begin();\r\n    std::vector<LightNode>::const_iterator end = nodes.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state() == LightNode::StateDeleted)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        QVariantMap mnode;\r\n        if (lightToMap(req, &*i, mnode))\r\n        {\r\n            rsp.map[i->id()] = mnode;\r\n        }\r\n    }\r\n\r\n    if (rsp.map.isEmpty())\r\n    {\r\n        rsp.str = \"{}\"; // return empty object\r\n    }\r\n\r\n    rsp.etag = gwLightsEtag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/lights\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::searchNewLights(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    if (!isInNetwork())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QLatin1String(\"/lights\"), QLatin1String(\"Not connected\")));\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    permitJoinApiKey = req.apikey();\r\n    startSearchLights();\r\n    {\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[QLatin1String(\"/lights\")] = QLatin1String(\"Searching for new devices\");\r\n        rspItemState[QLatin1String(\"/lights/duration\")] = (double)searchLightsTimeout;\r\n        rspItem[QLatin1String(\"success\")] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/lights/new\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getNewLights(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req);\r\n\r\n    if (!searchLightsResult.isEmpty() &&\r\n        (searchLightsState == SearchLightsActive || searchLightsState == SearchLightsDone))\r\n    {\r\n\r\n        rsp.map = searchLightsResult;\r\n    }\r\n\r\n    if (searchLightsState == SearchLightsActive)\r\n    {\r\n        rsp.map[\"lastscan\"] = QLatin1String(\"active\");\r\n    }\r\n    else if (searchLightsState == SearchLightsDone)\r\n    {\r\n        rsp.map[\"lastscan\"] = lastLightsScan;\r\n    }\r\n    else\r\n    {\r\n        rsp.map[\"lastscan\"] = QLatin1String(\"none\");\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\nstatic void toXy(double x,  double y, QVariantList &xy)\r\n{\r\n    if (x > 0xFEFF) x = 0xFEFF;\r\n    if (y > 0xFEFF) y = 0xFEFF;\r\n    xy.append(round(x / 6.5535) / 10000.0);\r\n    xy.append(round(y / 6.5535) / 10000.0);\r\n}\r\n\r\n/*! Put all parameters in a map for later json serialization.\r\n    \\return true - on success\r\n            false - on error\r\n */\r\nbool DeRestPluginPrivate::lightToMap(const ApiRequest &req, const LightNode *lightNode, QVariantMap &attr)\r\n{\r\n    Q_UNUSED(req);\r\n\r\n    if (!lightNode)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    QVariantMap capabilities;\r\n    QVariantMap capabilitiesBri;\r\n    QVariantMap capabilitiesColor;\r\n    const ResourceItem *itemColorCapabilties = nullptr;\r\n    const ResourceItem *itemCapColorEffects = nullptr;\r\n    QVariantMap capabilitiesColorCt;\r\n    QVariantMap capabilitiesColorGradient;\r\n    QVariantMap capabilitiesColorXy;\r\n    const ResourceItem *ibluex = nullptr;\r\n    const ResourceItem *ibluey = nullptr;\r\n    const ResourceItem *igreenx = nullptr;\r\n    const ResourceItem *igreeny = nullptr;\r\n    const ResourceItem *iredx = nullptr;\r\n    const ResourceItem *iredy = nullptr;\r\n    QVariantMap capabilitiesOtau;\r\n\r\n    QVariantMap config;\r\n    bool groups = true;\r\n    QVariantMap configBri;\r\n    QVariantMap configColor;\r\n    QVariantMap configColorCt;\r\n    QVariantMap configColorGradient;\r\n    QVariantMap configColorXy;\r\n    const ResourceItem *isx = nullptr;\r\n    const ResourceItem *isy = nullptr;\r\n    QVariantMap configOn;\r\n\r\n    QVariantMap state;\r\n    const ResourceItem *ialert = nullptr;\r\n    const QStringList *capabilitiesAlerts = &RStateAlertValues;\r\n    const ResourceItem *ix = nullptr;\r\n    const ResourceItem *iy = nullptr;\r\n\r\n    for (int i = 0; i < lightNode->itemCount(); i++)\r\n    {\r\n        const ResourceItem *item = lightNode->itemForIndex(static_cast<size_t>(i));\r\n        DBG_Assert(item);\r\n        if (!item->isPublic())\r\n        {\r\n            continue;\r\n        }\r\n        const ResourceItemDescriptor &rid = item->descriptor();\r\n\r\n        if      (rid.suffix == RAttrConfigId) { attr[\"configid\"] = item->toNumber(); }\r\n        else if (rid.suffix == RAttrLastAnnounced) { attr[\"lastannounced\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrLastSeen) { attr[\"lastseen\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrLevelMin) { attr[\"levelmin\"] = item->toNumber(); }\r\n        else if (rid.suffix == RAttrName) { attr[\"name\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrPowerOnLevel) { attr[\"poweronlevel\"] = item->toNumber(); }\r\n        else if (rid.suffix == RAttrPowerOnCt) { attr[\"poweronct\"] = item->toNumber(); }\r\n        else if (rid.suffix == RAttrPowerup) { attr[\"powerup\"] = item->toNumber(); }\r\n        else if (rid.suffix == RAttrProductId) { attr[\"productid\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrProductName) { attr[\"productname\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrSwconfigid) {attr[\"swconfigid\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrType) { attr[\"type\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrUniqueId) { attr[\"uniqueid\"] = item->toString(); }\r\n        else if (rid.suffix == RAttrZoneType) { attr[\"zonetype\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapAlertTriggerEffect) { capabilitiesAlerts = &RStateAlertValuesTriggerEffect; }\r\n        else if (rid.suffix == RCapBriMinDimLevel) { capabilitiesBri[\"min_dim_level\"] = round(item->toNumber() / 10.0) / 100.0; }\r\n        else if (rid.suffix == RCapColorCapabilities) { itemColorCapabilties = item; }\r\n        else if (rid.suffix == RCapColorCtComputesXy) { capabilitiesColorCt[\"computes_xy\"] = item->toBool(); }\r\n        else if (rid.suffix == RCapColorCtMax)\r\n        {\r\n            if (req.apiVersion() < ApiVersion_3_DDEL)\r\n            {\r\n                attr[\"ctmax\"] = item->toNumber();\r\n            }\r\n            capabilitiesColorCt[\"max\"] = item->toNumber();\r\n        }\r\n        else if (rid.suffix == RCapColorCtMin)\r\n        {\r\n            if (req.apiVersion() < ApiVersion_3_DDEL)\r\n            {\r\n                attr[\"ctmin\"] = item->toNumber();\r\n            }\r\n            capabilitiesColorCt[\"min\"] = item->toNumber();\r\n        }\r\n        else if (rid.suffix == RCapColorEffects) { itemCapColorEffects = item; }\r\n        else if (rid.suffix == RCapColorGamutType) { capabilitiesColor[\"gamut_type\"] = item->toString(); }\r\n        else if (rid.suffix == RCapColorGradientMaxSegments) { capabilitiesColorGradient[\"max_segments\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapColorGradientPixelCount) { capabilitiesColorGradient[\"pixel_count\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapColorGradientPixelLength) { capabilitiesColorGradient[\"pixel_length\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapColorGradientStyles) { capabilitiesColorGradient[\"styles\"] = getHueGradientStyleNames(item->toNumber()); }\r\n        else if (rid.suffix == RCapColorXyBlueX) { ibluex = item; }\r\n        else if (rid.suffix == RCapColorXyBlueY) { ibluey = item; }\r\n        else if (rid.suffix == RCapColorXyGreenX) { igreenx = item; }\r\n        else if (rid.suffix == RCapColorXyGreenY) { igreeny = item; }\r\n        else if (rid.suffix == RCapColorXyRedX) { iredx = item; }\r\n        else if (rid.suffix == RCapColorXyRedY) { iredy = item; }\r\n        else if (rid.suffix == RCapGroupsNotSupported) { groups = false; }\r\n        else if (rid.suffix == RCapOtauFileVersion) { capabilitiesOtau[\"file_version\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapOtauImageType) { capabilitiesOtau[\"image_type\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapOtauManufacturerCode) { capabilitiesOtau[\"manufacturer_code\"] = item->toNumber(); }\r\n        else if (rid.suffix == RCapSleeper) { capabilities[\"sleeper\"] = true; }\r\n        else if (rid.suffix == RCapTransitionBlock) { capabilities[\"transition_block\"] = true; }\r\n        else if (rid.suffix == RConfigBriCoupleCt) { configBri[\"couple_ct\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigBriExecuteIfOff) { configBri[\"execute_if_off\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigBriMax) { configBri[\"max\"] = item->toNumber(); }\r\n        else if (rid.suffix == RConfigBriMin) { configBri[\"min\"] = item->toNumber(); }\r\n        else if (rid.suffix == RConfigBriOnLevel) { configBri[\"on_level\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n        else if (rid.suffix == RConfigBriOnOffTransitiontime) { configBri[\"onoff_transitiontime\"] = item->toNumber(); }\r\n        else if (rid.suffix == RConfigBriMin) { configBri[\"onoff_transition_time\"] = item->toNumber(); }\r\n        else if (rid.suffix == RConfigBriStartup) { configBri[\"startup\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n        else if (rid.suffix == RConfigColorCtStartup) { configColorCt[\"startup\"] = item->toNumber() == 0xFFFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n        else if (rid.suffix == RConfigColorExecuteIfOff) { configColor[\"execute_if_off\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigColorGradientPixelCount) { configColorGradient[\"pixel_count\"] = item->toNumber(); }\r\n        else if (rid.suffix == RConfigColorGradientReversed) { configColorGradient[\"reversed\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigColorXyStartupX) { isx = item; }\r\n        else if (rid.suffix == RConfigColorXyStartupY) { isy = item; }\r\n        else if (rid.suffix == RConfigLocked) { config[\"locked\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigOnStartup) { configOn[\"startup\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toBool(); }\r\n        else if (rid.suffix == RConfigReversed) { config[\"reversed\"] = item->toBool(); }\r\n        else if (rid.suffix == RConfigSpeed) { config[\"speed\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateAlert) { ialert = item; }\r\n        else if (rid.suffix == RStateBri) { state[\"bri\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateColorMode) { state[\"colormode\"] = item->toString(); }\r\n        else if (rid.suffix == RStateCt) { state[\"ct\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateEffect) { state[\"effect\"] = item->toString(); }\r\n        else if (rid.suffix == RStateGradient)\r\n        {\r\n            bool ok;\r\n            QVariant var = Json::parse(item->toString(), ok);\r\n            if (ok)\r\n            {\r\n                QVariantMap map = var.toMap();\r\n                state[\"gradient\"] = map;\r\n            }\r\n        }\r\n        else if (rid.suffix == RStateHue) { state[\"hue\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateLift) { state[\"lift\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateOn) { state[\"on\"] = item->toBool(); }\r\n        else if (rid.suffix == RStateOpen) { state[\"open\"] = item->toBool(); }\r\n        else if (rid.suffix == RStateMusicSync) { state[\"music_sync\"] = item->toBool(); }\r\n        else if (rid.suffix == RStateReachable) { state[\"reachable\"] = item->toBool(); }\r\n        else if (rid.suffix == RStateSat) { state[\"sat\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateSpeed) { state[\"speed\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateTilt) { state[\"tilt\"] = item->toNumber(); }\r\n        else if (rid.suffix == RStateX) { ix = item; }\r\n        else if (rid.suffix == RStateY) { iy = item; }\r\n    }\r\n\r\n    if (groups)\r\n    {\r\n        QStringList groups;\r\n        std::vector<GroupInfo>::const_iterator g = lightNode->groups().begin();\r\n        std::vector<GroupInfo>::const_iterator gend = lightNode->groups().end();\r\n        for (; g != gend; ++g)\r\n        {\r\n            if (g->state == GroupInfo::StateInGroup)\r\n            {\r\n                groups.append(QVariant(g->id == gwGroup0 ? 0 : g->id).toString());\r\n            }\r\n        }\r\n        config[\"groups\"] = groups;\r\n    }\r\n\r\n    if (itemColorCapabilties)\r\n    {\r\n        const int cc = itemColorCapabilties->toNumber();\r\n        QStringList colorModes;\r\n\r\n        if (cc & COLOR_CAPABILITIES_CT) colorModes.push_back(QLatin1String(\"ct\"));\r\n        if (cc & COLOR_CAPABILITIES_COLORLOOP)\r\n        {\r\n            if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // colorloop and Hue special effects\r\n            {\r\n                colorModes.push_back(QLatin1String(\"effect\"));\r\n                capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), true);\r\n            }\r\n            else if (lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n            {\r\n                colorModes.push_back(QLatin1String(\"effect\"));\r\n                capabilitiesColor[\"effects\"] = RStateEffectValuesMueller;\r\n            }\r\n            else\r\n            {\r\n                capabilitiesColor[\"effects\"] = RStateEffectValues;\r\n            }\r\n        }\r\n        else if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // no colorloop, but Hue special effects\r\n        {\r\n            colorModes.push_back(QLatin1String(\"effect\"));\r\n            capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), false);\r\n        }\r\n        else if (isXmasLightStrip(lightNode))\r\n        {\r\n            colorModes.push_back(QLatin1String(\"effect\"));\r\n            capabilitiesColor[\"effects\"] = RStateEffectValuesXmasLightStrip;\r\n        }\r\n        if (!capabilitiesColorGradient.isEmpty()) colorModes.push_back(QLatin1String(\"gradient\"));\r\n        if (cc & COLOR_CAPABILITIES_HS || cc & COLOR_CAPABILITIES_ENHANCED_HS) colorModes.push_back(QLatin1String(\"hs\"));\r\n        if (cc & COLOR_CAPABILITIES_XY) colorModes.push_back(QLatin1String(\"xy\"));\r\n\r\n        if (req.apiVersion() <= ApiVersion_1_DDEL)\r\n        {\r\n            attr[\"colorcapabilities\"] = cc;\r\n        }\r\n        else if (req.apiVersion() < ApiVersion_3_DDEL)\r\n        {\r\n            attr[\"colorcapabilities\"] = colorModes;\r\n        }\r\n        capabilitiesColor[\"modes\"] = colorModes;\r\n    }\r\n    else if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // no color capabilities, but Hue special effects\r\n    {\r\n        capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), false);\r\n    }\r\n\r\n    if (ibluex && ibluey && igreenx && igreeny && iredx && iredy)\r\n    {\r\n        QVariantList blue, green, red;\r\n\r\n        toXy(ibluex->toNumber(), ibluey->toNumber(), blue);\r\n        toXy(igreenx->toNumber(), igreeny->toNumber(), green);\r\n        toXy(iredx->toNumber(), iredy->toNumber(), red);\r\n        capabilitiesColorXy[\"blue\"] = blue;\r\n        capabilitiesColorXy[\"green\"] = green;\r\n        capabilitiesColorXy[\"red\"] = red;\r\n    }\r\n\r\n    if (isx && isy)\r\n    {\r\n        double colorX = isx->toNumber();\r\n        double colorY = isy->toNumber();\r\n\r\n        if (colorX == 0xFFFF && colorY == 0xFFFF)\r\n        {\r\n            configColorXy[\"startup\"] = QLatin1String(\"previous\");\r\n        }\r\n        else\r\n        {\r\n            QVariantList xy;\r\n\r\n            toXy(colorX, colorY, xy);\r\n            configColorXy[\"startup\"] = xy;\r\n        }\r\n    }\r\n\r\n    if (ialert)\r\n    {\r\n        state[\"alert\"] = QLatin1String(\"none\");\r\n        capabilities[\"alerts\"] = *capabilitiesAlerts;\r\n    }\r\n\r\n    if (ix && iy)\r\n    {\r\n        QVariantList xy;\r\n\r\n        toXy(ix->toNumber(), iy->toNumber(), xy);\r\n        state[\"xy\"] = xy;\r\n    }\r\n\r\n    // Amazon Echo quirks mode\r\n    if (req.mode == ApiModeEcho)\r\n    {\r\n        // OSRAM plug + Ubisys S1/S2\r\n        if (lightNode->type().startsWith(QLatin1String(\"On/Off\")))\r\n        {\r\n            attr[\"modelid\"] = QLatin1String(\"LWB010\");\r\n            attr[\"manufacturername\"] = QLatin1String(\"Philips\");\r\n            attr[\"type\"] = QLatin1String(\"Dimmable light\");\r\n            state[\"bri\"] = (double) 254;\r\n        }\r\n    }\r\n\r\n    if (req.path.size() > 2 && req.path[2] == QLatin1String(\"devices\"))\r\n    {\r\n        // don't add in sub device\r\n    }\r\n    else\r\n    {\r\n        if (req.mode != ApiModeEcho && req.apiVersion() < ApiVersion_3_DDEL)\r\n        {\r\n            attr[\"hascolor\"] = lightNode->hasColor();\r\n        }\r\n\r\n        attr[\"manufacturername\"] = lightNode->manufacturer();\r\n        attr[\"modelid\"] = lightNode->modelId(); // real model id\r\n        attr[\"swversion\"] = lightNode->swBuildId();\r\n        QString etag = lightNode->etag;\r\n        etag.remove('\"'); // no quotes allowed in string\r\n        attr[\"etag\"] = etag;\r\n\r\n        if (req.apiVersion() >= ApiVersion_2_DDEL)\r\n        {\r\n            QVariantMap links;\r\n            QVariantMap self;\r\n            self[\"href\"] = QString(\"%1/%2\").arg(req.hdr.path()).arg(lightNode->uniqueId());\r\n            links[\"self\"] = self;\r\n            attr[\"_links\"] = links;\r\n        }\r\n    }\r\n    if (!state.isEmpty()) attr[\"state\"] = state;\r\n    if (!capabilitiesBri.isEmpty()) capabilities[\"bri\"] = capabilitiesBri;\r\n    if (!capabilitiesColorCt.isEmpty()) capabilitiesColor[\"ct\"] = capabilitiesColorCt;\r\n    if (!capabilitiesColorGradient.isEmpty()) capabilitiesColor[\"gradient\"] = capabilitiesColorGradient;\r\n    if (!capabilitiesColorXy.isEmpty()) capabilitiesColor[\"xy\"] = capabilitiesColorXy;\r\n    if (!capabilitiesColor.isEmpty()) capabilities[\"color\"] = capabilitiesColor;\r\n    if (!capabilitiesOtau.isEmpty()) capabilities[\"otau\"] = capabilitiesOtau;\r\n    if (!capabilities.isEmpty()) attr[\"capabilities\"] = capabilities;\r\n    if (!configBri.isEmpty()) config[\"bri\"] = configBri;\r\n    if (!configColorCt.isEmpty()) configColor[\"ct\"] = configColorCt;\r\n    if (!configColorGradient.isEmpty()) configColor[\"gradient\"] = configColorGradient;\r\n    if (!configColorXy.isEmpty()) configColor[\"xy\"] = configColorXy;\r\n    if (!configColor.isEmpty()) config[\"color\"] = configColor;\r\n    if (!configOn.isEmpty()) config[\"on\"] = configOn;\r\n    if (!config.isEmpty()) attr[\"config\"] = config;\r\n\r\n    return true;\r\n}\r\n\r\n/*! GET /api/<apikey>/lights/<id>/data?maxrecords=<maxrecords>&fromtime=<ISO 8601>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getLightData(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 5);\r\n\r\n    if (req.path.size() != 5)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    QString id = req.path[3];\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    if (!lightNode || (lightNode->state() != LightNode::StateNormal))\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1/\").arg(id), QString(\"resource, /lights/%1/, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    bool ok;\r\n    QUrl url(req.hdr.url());\r\n    QUrlQuery query(url);\r\n\r\n    const int maxRecords = query.queryItemValue(QLatin1String(\"maxrecords\")).toInt(&ok);\r\n    if (!ok || maxRecords <= 0)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/maxrecords\"), QString(\"invalid value, %1, for parameter, maxrecords\").arg(query.queryItemValue(\"maxrecords\"))));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    QString t = query.queryItemValue(QLatin1String(\"fromtime\"));\r\n    QDateTime dt = QDateTime::fromString(t, QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n    if (!dt.isValid())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/fromtime\"), QString(\"invalid value, %1, for parameter, fromtime\").arg(query.queryItemValue(\"fromtime\"))));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    const qint64 fromTime = dt.toMSecsSinceEpoch() / 1000;\r\n\r\n    openDb();\r\n    loadLightDataFromDb(lightNode, rsp.list, fromTime, maxRecords);\r\n    closeDb();\r\n\r\n    if (rsp.list.isEmpty())\r\n    {\r\n        rsp.str = QLatin1String(\"[]\"); // return empty list\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/lights/<id>\r\n    \\return 0 - on success\r\n           -1 - on error\r\n */\r\nint DeRestPluginPrivate::getLightState(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 4);\r\n\r\n    if (req.path.size() != 4)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    const QString &id = req.path[3];\r\n\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    if (!lightNode || lightNode->state() == LightNode::StateDeleted)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // handle ETag\r\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\r\n    {\r\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\r\n\r\n        if (lightNode->etag == etag)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotModified;\r\n            rsp.etag = etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    lightToMap(req, lightNode, rsp.map);\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = lightNode->etag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Helper to generate a new task with new task and req id based on a reference */\r\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\r\n{\r\n    b.req.dstAddress() = a.req.dstAddress();\r\n    b.req.setDstAddressMode(a.req.dstAddressMode());\r\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\r\n    b.req.setDstEndpoint(a.req.dstEndpoint());\r\n    b.req.setRadius(a.req.radius());\r\n    b.req.setTxOptions(a.req.txOptions());\r\n    b.req.setSendDelay(a.req.sendDelay());\r\n    b.transitionTime = a.transitionTime;\r\n    b.onTime = a.onTime;\r\n    b.lightNode = a.lightNode;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>/state\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setLightState(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    TaskItem taskRef;\r\n    QString id = req.path[3];\r\n    taskRef.lightNode = getLightNodeForId(id);\r\n\r\n    if (req.sock)\r\n    {\r\n        userActivity();\r\n    }\r\n\r\n    if (!taskRef.lightNode || taskRef.lightNode->state() == LightNode::StateDeleted)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    Device *device = static_cast<Device*>(taskRef.lightNode->parentResource());\r\n    Resource *rsub = nullptr;\r\n    StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, taskRef.lightNode->haEndpoint().endpoint());\r\n    if (device && device->managed())\r\n    {\r\n        rsub = DEV_GetSubDevice(device, nullptr, taskRef.lightNode->uniqueId());\r\n    }\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!taskRef.lightNode->isAvailable())\r\n    {\r\n        rsp.httpStatus = HttpStatusOk;\r\n        rsp.list.append(errorToMap(ERR_DEVICE_NOT_REACHABLE, QString(\"/lights/%1/state\").arg(id), QString(\"resource, /lights/%1/state, is not modifiable. Device is not reachable.\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // set destination parameters\r\n    taskRef.req.dstAddress() = taskRef.lightNode->address();\r\n    taskRef.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\r\n    taskRef.req.setDstEndpoint(taskRef.lightNode->haEndpoint().endpoint());\r\n    taskRef.req.setSrcEndpoint(getSrcEndpoint(taskRef.lightNode, taskRef.req));\r\n    taskRef.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n    taskRef.transitionTime = 4;\r\n    taskRef.onTime = 0;\r\n\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/lights/%1/state\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // FIXME: use cluster instead of device type.\r\n    if (taskRef.lightNode->type() == QLatin1String(\"Window covering controller\") ||\r\n        taskRef.lightNode->type() == QLatin1String(\"Window covering device\"))\r\n    {\r\n        return setWindowCoveringState(req, rsp, taskRef, map);\r\n    }\r\n    else if (isXmasLightStrip(taskRef.lightNode))\r\n    {\r\n        return setXmasLightStripState(req, rsp, taskRef, map);\r\n    }\r\n    else if (UseTuyaCluster(taskRef.lightNode->manufacturer()))\r\n    {\r\n        //tuya window covering\r\n        if (R_GetProductId(taskRef.lightNode).startsWith(QLatin1String(\"Tuya_COVD\")))\r\n        {\r\n            return setWindowCoveringState(req, rsp, taskRef, map);\r\n        }\r\n        // light, don't use tuya stuff (for the moment)\r\n        else if (taskRef.lightNode->item(RStateColorMode))\r\n        {\r\n        }\r\n        // handle by device code\r\n        else if (device && device->managed())\r\n        {\r\n        }\r\n        //switch and siren\r\n        else\r\n        {\r\n            return setTuyaDeviceState(req, rsp, taskRef, map);\r\n        }\r\n    }\r\n    else if (taskRef.lightNode->type() == QLatin1String(\"Warning device\")) // Put it here because some tuya device are Warning device but need to be process by tuya part\r\n    {\r\n        return setWarningDeviceState(req, rsp, taskRef, map);\r\n    }\r\n    else if (taskRef.lightNode->type() == QLatin1String(\"Door Lock\"))\r\n    {\r\n        return setDoorLockState(req, rsp, taskRef, map);\r\n    }\r\n\r\n    const QStringList *alertList = &RStateAlertValuesTriggerEffect; // TODO: check RCapAlertTriggerEffect\r\n    QStringList effectList = RStateEffectValues;\r\n    bool colorloop = false;\r\n    {\r\n        ResourceItem *itemColorCapabilties = taskRef.lightNode->item(RCapColorCapabilities);\r\n        int cc = itemColorCapabilties ? itemColorCapabilties->toNumber() : 0;\r\n        colorloop = (cc & COLOR_CAPABILITIES_COLORLOOP) != 0;\r\n    }\r\n    if (taskRef.lightNode->item(RCapColorEffects) && taskRef.lightNode->manufacturerCode() == VENDOR_PHILIPS)\r\n    {\r\n        effectList = getHueEffectNames(taskRef.lightNode->item(RCapColorEffects)->toNumber(), colorloop);\r\n    }\r\n    else if (taskRef.lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n    {\r\n        effectList = RStateEffectValuesMueller;\r\n    }\r\n\r\n    bool hasCmd = false;\r\n    bool isOn = false;\r\n    bool hasOn = false;\r\n    bool targetOn = false;\r\n    bool hasBri = false;\r\n    quint8 targetBri = 0;\r\n    bool hasBriInc = false;\r\n    qint16 targetBriInc = 0;\r\n    bool hasWrap = false;\r\n    bool wrap = false;\r\n    bool hasXy = false;\r\n    double targetX = 0.0;\r\n    double targetY = 0.0;\r\n    bool hasCt = false;\r\n    quint16 targetCt = 0;\r\n    bool hasCtInc = false;\r\n    qint16 targetCtInc = 0;\r\n    bool hasHue = false;\r\n    quint16 targetHue = 0;\r\n    bool hasSat = false;\r\n    quint8 targetSat = 0;\r\n    QString effect;\r\n    bool hasColorloopSpeed = false;\r\n    quint16 colorloopSpeed = 25;\r\n    bool hasGradient = false;\r\n    QVariantMap gradient;\r\n    bool hasMusicSync = false;\r\n    bool targetMusicSync = false;\r\n    QString alert;\r\n    bool hasSpeed = false;\r\n    quint8 targetSpeed = 0;\r\n    bool hasTransitionTime = false;\r\n\r\n    // Check parameters.\r\n    for (QVariantMap::const_iterator p = map.begin(); p != map.end(); p++)\r\n    {\r\n        bool paramOk = false;\r\n        bool valueOk = false;\r\n        QString param = p.key();\r\n        if (param == \"on\" && taskRef.lightNode->item(RStateOn))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasOn = true;\r\n                targetOn = map[param].toBool();\r\n            }\r\n        }\r\n        else if (param == \"bri\" && taskRef.lightNode->item(RStateBri))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint bri = map[param].toUInt(&ok);\r\n                if (ok && bri <= 0xFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasBri = true;\r\n                    targetBri = bri > 0xFE ? 0xFE : bri;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"bri_inc\"  && taskRef.lightNode->item(RStateBri))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const int briInc = map[param].toInt(&ok);\r\n                if (ok && briInc >= -0xFF && briInc <= 0xFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasBriInc = true;\r\n                    targetBriInc = briInc < -0xFE ? -0xFE : briInc > 0xFE ? 0xFE : briInc;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"xy\"  && taskRef.lightNode->item(RStateX) && taskRef.lightNode->item(RStateY) &&\r\n                 taskRef.lightNode->modelId() != QLatin1String(\"FLS-PP\"))\r\n        {\r\n            // @manup: is check for FLS-PP needed, or is this already handled by check for state.x and state.y?\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::List)\r\n            {\r\n                QVariantList xy = map[\"xy\"].toList();\r\n                if (xy[0].type() == QVariant::Double && xy[1].type() == QVariant::Double)\r\n                {\r\n                    const double x = xy[0].toDouble(&ok);\r\n                    const double y = ok ? xy[1].toDouble(&ok) : 0;\r\n                    if (ok && x >= 0.0 && x <= 1.0 && y >= 0.0 && y <= 1.0)\r\n                    {\r\n                        valueOk = true;\r\n                        hasXy = true;\r\n                        targetX = x > 0.9961 ? 0.9961 : x;\r\n                        targetY = y > 0.9961 ? 0.9961 : y;\r\n                    }\r\n                    else\r\n                    {\r\n                        valueOk = true;\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state/xy\").arg(id), QString(\"invalid value, [%1,%2], for parameter, xy\").arg(xy[0].toString()).arg(xy[1].toString())));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"ct\") // FIXME workaround for lights that support color tempeature, but API doesn't expose ct.\r\n        // else if (param == \"ct\"  && (taskRef.lightNode->item(RStateCt))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const quint16 ctMin = taskRef.lightNode->toNumber(RCapColorCtMin);\r\n                const quint16 ctMax = taskRef.lightNode->toNumber(RCapColorCtMax);\r\n                const uint ct = map[param].toUInt(&ok);\r\n                if (ok && ct <= 0xFFFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasCt = true;\r\n                    targetCt = (ctMin < 500 && ct < ctMin) ? ctMin : (ctMax > ctMin && ct > ctMax) ? ctMax : ct;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"ct_inc\"  && taskRef.lightNode->item(RStateCt))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                int ct = taskRef.lightNode->toNumber(RStateCt);\r\n                const quint16 ctMin = taskRef.lightNode->toNumber(RCapColorCtMin);\r\n                const quint16 ctMax = taskRef.lightNode->toNumber(RCapColorCtMax);\r\n                const int ctInc = map[param].toInt(&ok);\r\n                if (ok && ctInc >= -0xFFFF && ctInc <= 0xFFFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasCtInc = true;\r\n                    targetCtInc = ctInc;\r\n                    ct += ctInc;\r\n                    ct = ct < 0 ? 0 : ct > 0xFEFF ? 0xFEFF : ct;\r\n                    targetCt = (ctMin < 500 && ct < ctMin) ? ctMin : (ctMax > ctMin && ct > ctMax) ? ctMax : ct;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"hue\" && taskRef.lightNode->item(RStateHue) && taskRef.lightNode->item(RStateSat))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            const uint hue = map[param].toUInt(&ok);\r\n            if (ok && hue <= 0xFFFF)\r\n            {\r\n                valueOk = true;\r\n                hasHue = true;\r\n                targetHue = hue; // Funny: max CurrentHue is 0xFE, max EnhancedCurrentHue is 0xFFFF\r\n            }\r\n        }\r\n        else if (param == \"sat\" && taskRef.lightNode->item(RStateHue) && taskRef.lightNode->item(RStateSat))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            const uint sat = map[param].toUInt(&ok);\r\n            if (ok && sat <= 0xFF)\r\n            {\r\n                valueOk = true;\r\n                hasSat = true;\r\n                targetSat = sat > 0xFE ? 0xFE : sat;\r\n            }\r\n        }\r\n        else if (param == \"effect\" && taskRef.lightNode->item(RStateEffect))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::String)\r\n            {\r\n                QString e = map[param].toString();\r\n                if (effectList.indexOf(e) >= 0)\r\n                {\r\n                    valueOk = true;\r\n                    effect = e;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"music_sync\" && taskRef.lightNode->item(RStateMusicSync))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasMusicSync = true;\r\n                targetMusicSync = map[param].toBool();\r\n            }\r\n        }\r\n        else if (param == \"colorloopspeed\" && taskRef.lightNode->item(RStateEffect))\r\n        {\r\n            paramOk = true;\r\n            const uint speed = map[param].toUInt(&ok);\r\n            if (ok && speed <= 0xFFFF)\r\n            {\r\n                valueOk = true;\r\n                hasColorloopSpeed = true;\r\n                colorloopSpeed = speed < 1 ? 1 : speed;\r\n            }\r\n        }\r\n        else if (param == \"gradient\" && taskRef.lightNode->item(RStateGradient))\r\n        {\r\n            quint16 styleBitmap = taskRef.lightNode->toNumber(RCapColorGradientStyles);\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Map)\r\n            {\r\n                gradient = map[param].toMap();\r\n                if (validateHueGradient(req, rsp, gradient, styleBitmap))\r\n                {\r\n                    hasCmd = true;\r\n                    hasGradient = true;\r\n                }\r\n                valueOk = true;\r\n            }\r\n        }\r\n        else if (param == \"colormode\" && taskRef.lightNode->item(RStateColorMode))\r\n        {\r\n            paramOk = true;\r\n            valueOk = true;\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/colormode\").arg(id).arg(param), QString(\"parameter, colormode, is not modifiable.\")));\r\n        }\r\n        else if (param == \"alert\" && taskRef.lightNode->item(RStateAlert))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::String)\r\n            {\r\n                alert = map[param].toString();\r\n                valueOk = alertList->contains(alert);\r\n            }\r\n        }\r\n        else if (param == \"speed\" && taskRef.lightNode->item(RStateSpeed))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint speed = map[param].toUInt(&ok);\r\n                if (ok && speed <= 0xFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasSpeed = true;\r\n                    targetSpeed = speed > 6 ? 6 : speed;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"transitiontime\")\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint tt = map[param].toUInt(&ok);\r\n                if (ok && tt <= 0xFFFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasTransitionTime = true;\r\n                    taskRef.transitionTime = tt > 0xFFFE ? 0xFFFE : tt;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"ontime\")\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint ot = map[param].toUInt(&ok);\r\n                if (ok && ot <= 0xFFFF)\r\n                {\r\n                    valueOk = true;\r\n                    taskRef.onTime = ot;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"wrap\")\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasWrap = true;\r\n                wrap = map[param].toBool();\r\n            }\r\n        }\r\n        if (!paramOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state/%2\").arg(id).arg(param), QString(\"parameter, %1, not available\").arg(param)));\r\n        }\r\n        else if (!valueOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state/%2\").arg(id).arg(param), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\r\n        }\r\n    }\r\n    if (taskRef.onTime > 0 && !hasOn && alert.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, on or alert, for parameter, ontime\")));\r\n    }\r\n    if (hasWrap && !hasBriInc)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, bri_inc, for parameter, wrap\")));\r\n    }\r\n    if (hasColorloopSpeed && effect != \"colorloop\")\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, effect, for parameter, colorloopspeed\")));\r\n    }\r\n    if (!hasCmd)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter to set light state\")));\r\n    }\r\n\r\n    // Check whether light is on.\r\n    isOn = taskRef.lightNode->toBool(RStateOn);\r\n\r\n    // Special part for Profalux device\r\n    // This device is a shutter but is used as a dimmable light, so need some hack\r\n    if (taskRef.lightNode->modelId() == QLatin1String(\"PFLX Shutter\"))\r\n    {\r\n        if (hasOn && !hasBri)\r\n        {\r\n            hasBri = true;\r\n            targetBri = targetOn ? 0xFE : 0x00;\r\n        }\r\n        hasOn = false; // use bri instead\r\n\r\n        if (hasBriInc)\r\n        {\r\n            targetBriInc = 0; // only use for stop\r\n            hasBri = false;\r\n        }\r\n        else\r\n        {\r\n            isOn = true; // to force bri even when off\r\n            if (targetBri > 0xFE) { targetBri = 0xFE; }\r\n            if (targetBri < 1) { targetBri = 0x01; }\r\n        }\r\n    }\r\n\r\n    // state.on: true\r\n    if (hasOn && targetOn)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (taskRef.lightNode->toBool(RCapBriMoveWithOnOff) && !isOn && hasBri && taskRef.onTime == 0)\r\n        {\r\n            // if a light is off and should transition from 0 to new brightness\r\n            // turn light on at lowest brightness first\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            task.transitionTime = 0;\r\n\r\n            ok = addTaskSetBrightness(task, 2, true);\r\n        }\r\n        else\r\n        {\r\n            const quint8 cmd = taskRef.onTime > 0\r\n                    ? ONOFF_COMMAND_ON_WITH_TIMED_OFF\r\n                    : ONOFF_COMMAND_ON;\r\n            ok = addTaskSetOnOff(task, cmd, taskRef.onTime, 0);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            isOn = true;\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = targetOn;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            taskRef.lightNode->setValue(RStateOn, targetOn);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/on\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // state.bri has priority over state.bri_inc\r\n    if (hasBri)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigBriExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/bri\").arg(id), QString(\"parameter, bri, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (hasOn && !targetOn && hasTransitionTime)\r\n        {\r\n            // Handled by state.on: false\r\n        }\r\n        else if (addTaskSetBrightness(task, targetBri, false))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/bri\").arg(id)] = targetBri;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateBri, targetBri);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/bri\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasBriInc)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n        int bri = taskRef.lightNode->toNumber(RStateBri);\r\n\r\n        if (wrap)\r\n        {\r\n            if (bri + targetBriInc < 1)\r\n            {\r\n                targetBriInc += 254;\r\n            }\r\n            else if (bri + targetBriInc > 254)\r\n            {\r\n                targetBriInc -= 254;\r\n            }\r\n        }\r\n        bri += targetBriInc;\r\n        targetBri = bri < 0 ? 0 : bri > 254 ? 254 : bri;\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigBriExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/bri_inc\").arg(id), QString(\"parameter, bri_inc, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (addTaskIncBrightness(task, targetBriInc))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/bri\").arg(id)] = targetBri;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateBri, targetBri);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/bri_inc\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // state.effect: \"none\"\r\n    if (effect == \"none\")\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/effect\").arg(id), QString(\"parameter, effect, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else \r\n        {\r\n            if (colorloop)\r\n            {\r\n                ok = addTaskSetColorLoop(task, false, colorloopSpeed);\r\n            }\r\n            if (ok && taskRef.lightNode->item(RCapColorEffects) && taskRef.lightNode->manufacturerCode() == VENDOR_PHILIPS)\r\n            {\r\n                ok = addTaskHueEffect(taskRef, effect);\r\n            }\r\n            else if (ok && taskRef.lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n            {\r\n                const quint64 value = 0;\r\n                deCONZ::ZclAttribute attr(0x4005, deCONZ::Zcl8BitUint, \"scene\", deCONZ::ZclReadWrite, true);\r\n                attr.setValue(value);\r\n                ok = writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), BASIC_CLUSTER_ID, attr, VENDOR_MUELLER);\r\n            }\r\n\r\n            if (ok)\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/lights/%1/state/effect\").arg(id)] = effect;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n\r\n                taskRef.lightNode->setValue(RStateEffect, effect);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/effect\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // state.xy trumps state.ct trumps state.ct_inc trumps state.hue, state.sat\r\n    if (hasXy)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/xy\").arg(id), QString(\"parameter, xy, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (taskRef.lightNode->isColorLoopActive())\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/xy\").arg(id), QString(\"parameter, xy, is not modifiable. Colorloop is active.\")));\r\n        }\r\n        else if (addTaskSetXyColor(task, targetX, targetY))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            QVariantList xy;\r\n            xy.append(targetX);\r\n            xy.append(targetY);\r\n            rspItemState[QString(\"/lights/%1/state/xy\").arg(id)] = xy;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateX, targetX * 65535);\r\n            taskRef.lightNode->setValue(RStateY, targetY * 65535);\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"xy\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/xy\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasCt)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/ct\").arg(id), QString(\"parameter, ct, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (taskRef.lightNode->isColorLoopActive())\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/ct\").arg(id), QString(\"parameter, ct, is not modifiable. Colorloop is active.\")));\r\n        }\r\n        else if (addTaskSetColorTemperature(task, targetCt))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/ct\").arg(id)] = targetCt;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateCt, targetCt);\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"ct\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/ct\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasCtInc)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/ct_inc\").arg(id), QString(\"parameter, ct_inc, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (taskRef.lightNode->isColorLoopActive())\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/ct_inc\").arg(id), QString(\"parameter, ct_inc, is not modifiable. Colorloop is active.\")));\r\n        }\r\n        else if (addTaskIncColorTemperature(task, targetCtInc))\r\n        {\r\n            taskToLocalData(task);\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/ct\").arg(id)] = targetCt;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateCt, targetCt);\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"ct\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/ct_inc\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasHue || hasSat)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            if (hasHue)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/hue\").arg(id), QString(\"parameter, hue, is not modifiable. Device is set to off.\")));\r\n            }\r\n            if (hasSat)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/sat\").arg(id), QString(\"parameter, sat, is not modifiable. Device is set to off.\")));\r\n            }\r\n        }\r\n        else if (taskRef.lightNode->isColorLoopActive())\r\n        {\r\n            if (hasHue)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/hue\").arg(id), QString(\"parameter, hue, is not modifiable. Colorloop is active.\")));\r\n            }\r\n            if (hasSat)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/lights/%1/state/sat\").arg(id), QString(\"parameter, sat, is not modifiable. Colorloop is active.\")));\r\n            }\r\n        }\r\n        else if (!hasSat) // only state.hue\r\n        {\r\n            ok = addTaskSetEnhancedHue(task, targetHue);\r\n            // FIXME: handle lights that don't support Enhanced Current Hue (like Müller)\r\n        }\r\n        else if (!hasHue) // only state.sat\r\n        {\r\n            ok = addTaskSetSaturation(task, targetSat);\r\n        }\r\n        else // both state.hue and state.sat\r\n        {\r\n            const quint8 hue = targetHue / 256;\r\n            ok = addTaskSetHueAndSaturation(task, hue, targetSat); // FIXME\r\n            // ok = addTaskSetEnhancedHueAndSaturation(task, targetHue, targetSat);\r\n        }\r\n        if (ok)\r\n        {\r\n            if (hasHue)\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/lights/%1/state/hue\").arg(id)] = targetHue;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n\r\n                taskRef.lightNode->setValue(RStateHue, targetHue);\r\n            }\r\n            if (hasSat)\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/lights/%1/state/sat\").arg(id)] = targetSat;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n\r\n                taskRef.lightNode->setValue(RStateSat, targetSat);\r\n            }\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"hs\"));\r\n        }\r\n        else\r\n        {\r\n            if (hasHue)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/hue\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n            if (hasSat)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/sat\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // state.effect: \"colorloop\"\r\n    if (effect == \"colorloop\")\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/effect\").arg(id), QString(\"parameter, effect, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (addTaskSetColorLoop(task, true, colorloopSpeed))\r\n        {\r\n            if (taskRef.lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n            {\r\n                quint64 value = 0;\r\n                deCONZ::ZclAttribute attr(0x4005, deCONZ::Zcl8BitUint, \"scene\", deCONZ::ZclReadWrite, true);\r\n                attr.setValue(value);\r\n                writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), BASIC_CLUSTER_ID, attr, VENDOR_MUELLER);\r\n            }\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/effect\").arg(id)] = effect;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateEffect, effect);\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"hs\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/effect\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (!effect.isEmpty() && effect != \"none\")\r\n    {\r\n        if (!isOn && !taskRef.lightNode->toBool(RConfigColorExecuteIfOff))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state/effect\").arg(id), QString(\"parameter, effect, is not modifiable. Device is set to off.\")));\r\n        }\r\n        else if (taskRef.lightNode->item(RCapColorEffects) && taskRef.lightNode->manufacturerCode() == VENDOR_PHILIPS)\r\n        {\r\n            ok = addTaskHueEffect(taskRef, effect);\r\n        }\r\n        else if (taskRef.lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n        {\r\n            const quint64 value = effectList.indexOf(effect) - 1;\r\n            deCONZ::ZclAttribute attr(0x4005, deCONZ::Zcl8BitUint, \"scene\", deCONZ::ZclReadWrite, true);\r\n            attr.setValue(value);\r\n            ok = writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), BASIC_CLUSTER_ID, attr, VENDOR_MUELLER);\r\n        }\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/effect\").arg(id)] = effect;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateEffect, effect);\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"effect\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/effect\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (hasGradient)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (taskRef.lightNode->manufacturerCode() == VENDOR_PHILIPS)\r\n        {\r\n            ok = addTaskHueGradient(taskRef, gradient);\r\n        }\r\n        ok = true;\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/gradient\").arg(id)] = gradient;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // taskRef.lightNode->setValue(RStateGradient, QString(Json::serialize(gradient)));\r\n            taskRef.lightNode->setValue(RStateColorMode, QString(\"gradient\"));\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/gradient\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (hasMusicSync)\r\n    {\r\n        change.addTargetValue(RStateMusicSync, targetMusicSync);\r\n        taskRef.lightNode->setValue(RStateMusicSync, targetMusicSync);\r\n        DB_StoreSubDeviceItem(taskRef.lightNode, taskRef.lightNode->item(RStateMusicSync));\r\n\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[QString(\"/lights/%1/state/music_sync\").arg(id)] = targetMusicSync;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    // state.alert\r\n    if (!alert.isEmpty())\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (alert == \"none\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = 0;\r\n        }\r\n        else if (alert == \"select\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = 2;    // Hue lights don't react to 1.\r\n        }\r\n        else if (alert == \"lselect\")\r\n        {\r\n            task.taskType = TaskIdentify;\r\n            task.identifyTime = taskRef.onTime > 0 ? taskRef.onTime : 15; // Default for Philips Hue bridge\r\n        }\r\n        else if (alert == \"blink\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x00;\r\n        }\r\n        else if (alert == \"breathe\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x01;\r\n        }\r\n        else if (alert == \"okay\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x02;\r\n        }\r\n        else if (alert == \"channelchange\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0x0b;\r\n        }\r\n        else if (alert == \"finish\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0xfe;\r\n        }\r\n        else if (alert == \"stop\")\r\n        {\r\n            task.taskType = TaskTriggerEffect;\r\n            task.effectIdentifier = 0xff;\r\n        }\r\n\r\n        if ((task.taskType == TaskIdentify && addTaskIdentify(task, task.identifyTime)) ||\r\n            (task.taskType == TaskTriggerEffect && addTaskTriggerEffect(task, task.effectIdentifier)))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = alert;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Don't update write-only state.alert.\r\n        }\r\n        else if (task.taskType == TaskIdentify || task.taskType == TaskTriggerEffect)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/alert\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // state.speed\r\n    if (hasSpeed)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        deCONZ::ZclAttribute attr(0x0000, deCONZ::Zcl8BitEnum, \"speed\", deCONZ::ZclReadWrite, true);\r\n        attr.setValue(QVariant(targetSpeed));\r\n\r\n        if (writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), FAN_CONTROL_CLUSTER_ID, attr))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/speed\").arg(id)] = targetSpeed;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            taskRef.lightNode->setValue(RStateSpeed, targetSpeed);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/speed\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // state.on: false\r\n    if (hasOn && !targetOn)\r\n    {\r\n        if (taskRef.lightNode->isColorLoopActive())\r\n        {\r\n            TaskItem task;\r\n            copyTaskReq(taskRef, task);\r\n            addTaskSetColorLoop(task, false, colorloopSpeed);\r\n        }\r\n\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n        if (hasBri && hasTransitionTime && taskRef.lightNode->toBool(RCapBriMoveWithOnOff))\r\n        {\r\n            ok = addTaskSetBrightness(task, 0, true);\r\n        }\r\n        else\r\n        {\r\n            const quint8 cmd = taskRef.lightNode->toBool(RCapOnOffWithEffect)\r\n                    ? ONOFF_COMMAND_OFF_WITH_EFFECT\r\n                    : ONOFF_COMMAND_OFF;\r\n            ok = addTaskSetOnOff(task, cmd, 0, 0);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = targetOn;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            taskRef.lightNode->setValue(RStateOn, targetOn);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/on\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (!taskRef.lightNode->stateChanges().empty())\r\n    {\r\n        DBG_Printf(DBG_INFO, \"emit event/tick: \" FMT_MAC \"\\n\", (unsigned long long)taskRef.lightNode->address().ext());\r\n        enqueueEvent({taskRef.lightNode->prefix(), REventTick, taskRef.lightNode->uniqueId(), taskRef.lightNode->address().ext()});\r\n    }\r\n\r\n    rsp.etag = taskRef.lightNode->etag;\r\n    if (rsub)\r\n    {\r\n        rsub->addStateChange(change);\r\n    }\r\n    processTasks();\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>/config\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setLightConfig(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/lights/%1/state\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!lightNode || lightNode->state() == LightNode::StateDeleted)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    ok = false;\r\n    Device *device = static_cast<Device *>(lightNode->parentResource());\r\n    Resource *rsub;\r\n    if (device && device->managed())\r\n    {\r\n        rsub = DEV_GetSubDevice(device, nullptr, lightNode->uniqueId());\r\n        if (rsub)\r\n        {\r\n            ok = true;\r\n        }\r\n    }\r\n    if (!ok)\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1/config\").arg(id), QString(\"resource, /lights/%1/config, is not modifyable. Device is not managed through DDF.\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!lightNode->isAvailable())\r\n    {\r\n        rsp.httpStatus = HttpStatusOk;\r\n        rsp.list.append(errorToMap(ERR_DEVICE_NOT_REACHABLE, QString(\"/lights/%1/config\").arg(id), QString(\"resource, /lights/%1/config, is not modifiable. Device is not reachable.\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (req.sock)\r\n    {\r\n        userActivity();\r\n    }\r\n\r\n    StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, lightNode->haEndpoint().endpoint());\r\n\r\n    for (QVariantMap::const_iterator p = map.begin(); p != map.end(); p++)\r\n    {\r\n        bool isMap = false;\r\n        bool paramOk = false;\r\n        bool valueOk = false;\r\n        QString key = p.key();\r\n        QString path = QString(\"/lights/%1/config/%2\").arg(id).arg(key);\r\n        QVariant value = map[key];\r\n\r\n        if (key == \"bri\")\r\n        {\r\n            paramOk = true;\r\n            if (value.type() == QVariant::Map)\r\n            {\r\n                valueOk = true;\r\n                isMap = true;\r\n                QVariantMap map1 = value.toMap();\r\n                for (QVariantMap::const_iterator q = map1.begin(); q != map1.end(); q++)\r\n                {\r\n                    bool paramOk = false;\r\n                    bool valueOk = false;\r\n                    key = q.key();\r\n                    QString path1 = QString(\"%1/%2\").arg(path).arg(key);\r\n                    value = map1[key];\r\n\r\n                    if (key == \"couple_ct\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriCoupleCt);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Bool)\r\n                            {\r\n                                valueOk = true;\r\n                                change.addTargetValue(RConfigBriCoupleCt, value.toBool());\r\n                                lightNode->setValue(RConfigBriCoupleCt, value.toBool());\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"execute_if_off\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriExecuteIfOff);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Bool)\r\n                            {\r\n                                valueOk = true;\r\n                                change.addTargetValue(RConfigBriExecuteIfOff, value.toBool());\r\n                                lightNode->setValue(RConfigBriExecuteIfOff, value.toBool());\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"max\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriMax);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Double)\r\n                            {\r\n                                const quint8 bri = value.toUInt(&ok);\r\n                                if (ok)\r\n                                {\r\n                                    valueOk = true;\r\n                                    quint8 targetBriMax = bri > 0xFE ? 0xFE : bri;\r\n                                    value = QVariant(targetBriMax);\r\n                                    change.addTargetValue(RConfigBriMax, targetBriMax);\r\n                                    lightNode->setValue(RConfigBriMax, bri > 0xFE ? 0xFE : bri);\r\n                                    DB_StoreSubDeviceItem(lightNode, item);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"min\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriMin);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Double)\r\n                            {\r\n                                const quint8 bri = value.toUInt(&ok);\r\n                                if (ok)\r\n                                {\r\n                                    valueOk = true;\r\n                                    quint8 targetBriMin = bri > 0xFE ? 0xFE : bri;\r\n                                    value = QVariant(targetBriMin);\r\n                                    change.addTargetValue(RConfigBriMin, targetBriMin);\r\n                                    lightNode->setValue(RConfigBriMin, targetBriMin);\r\n                                    DB_StoreSubDeviceItem(lightNode, item);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"on_level\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriOnLevel);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            quint8 targetBriOnLevel;\r\n                            if (value.type() == QVariant::Double)\r\n                            {\r\n                                const quint8 bri = value.toUInt(&ok);\r\n                                if (ok)\r\n                                {\r\n                                    valueOk = true;\r\n                                    targetBriOnLevel = bri > 0xFE ? 0xFE : bri;\r\n                                    value = QVariant(targetBriOnLevel);\r\n                                }\r\n                            }\r\n                            else if (value.type() == QVariant::String && value.toString() == QLatin1String(\"previous\"))\r\n                            {\r\n                                valueOk = true;\r\n                                targetBriOnLevel = 0xFF;\r\n                            }\r\n                            if (valueOk)\r\n                            {\r\n                                change.addTargetValue(RConfigBriOnLevel, targetBriOnLevel);\r\n                                lightNode->setValue(RConfigBriOnLevel, targetBriOnLevel);\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"onoff_transitiontime\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriOnOffTransitiontime);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Double)\r\n                            {\r\n                                const quint16 tt = value.toUInt(&ok);\r\n                                if (ok)\r\n                                {\r\n                                    valueOk = true;\r\n                                    change.addTargetValue(RConfigBriOnOffTransitiontime, tt);\r\n                                    lightNode->setValue(RConfigBriOnOffTransitiontime, tt);\r\n                                    DB_StoreSubDeviceItem(lightNode, item);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"startup\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigBriStartup);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            quint8 targetBriStartup;\r\n                            if (value.type() == QVariant::Double)\r\n                            {\r\n                                const quint8 bri = value.toUInt(&ok);\r\n                                if (ok)\r\n                                {\r\n                                    valueOk = true;\r\n                                    targetBriStartup = bri > 0xFE ? 0xFE : bri;\r\n                                    value = QVariant(targetBriStartup);\r\n                                }\r\n                            }\r\n                            else if (value.type() == QVariant::String && value.toString() == QLatin1String(\"previous\"))\r\n                            {\r\n                                valueOk = true;\r\n                                targetBriStartup = 0xFF;\r\n                            }\r\n                            if (valueOk)\r\n                            {\r\n                                change.addTargetValue(RConfigBriStartup, targetBriStartup);\r\n                                lightNode->setValue(RConfigBriStartup, targetBriStartup);\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!paramOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path1, QString(\"parameter, %1, not available\").arg(key)));\r\n                    }\r\n                    else if (!valueOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, path1, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n                    }\r\n                    else\r\n                    {\r\n                        QVariantMap rspItem;\r\n                        QVariantMap rspItemState;\r\n                        rspItemState[path1] = value;\r\n                        rspItem[\"success\"] = rspItemState;\r\n                        rsp.list.append(rspItem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"color\")\r\n        {\r\n            paramOk = true;\r\n            if (value.type() == QVariant::Map)\r\n            {\r\n                valueOk = true;\r\n                isMap = true;\r\n                QVariantMap map1 = value.toMap();\r\n                for (QVariantMap::const_iterator q = map1.begin(); q != map1.end(); q++)\r\n                {\r\n                    bool paramOk = false;\r\n                    bool valueOk = false;\r\n                    bool isMap = false;\r\n                    key = q.key();\r\n                    QString path1 = QString(\"%1/%2\").arg(path).arg(key);\r\n                    value = map1[key];\r\n\r\n                    if (key == \"ct\")\r\n                    {\r\n                        paramOk = true;\r\n                        if (value.type() == QVariant::Map)\r\n                        {\r\n                            valueOk = true;\r\n                            isMap = true;\r\n                            QVariantMap map2 = value.toMap();\r\n                            for (QVariantMap::const_iterator r = map2.begin(); r != map2.end(); r++)\r\n                            {\r\n                                bool paramOk = false;\r\n                                bool valueOk = false;\r\n                                key = r.key();\r\n                                QString path2 = QString(\"%1/%2\").arg(path1).arg(key);\r\n                                value = map2[key];\r\n\r\n                                if (key == \"startup\")\r\n                                {\r\n                                    ResourceItem *item = lightNode->item(RConfigColorCtStartup);\r\n                                    if (item)\r\n                                    {\r\n                                        paramOk = true;\r\n                                        quint16 targetCtStartup;\r\n                                        if (value.type() == QVariant::Double)\r\n                                        {\r\n                                            const quint16 ctMin = lightNode->toNumber(RCapColorCtMin);\r\n                                            const quint16 ctMax = lightNode->toNumber(RCapColorCtMax);\r\n                                            const quint16 ct = value.toUInt(&ok);\r\n                                            if (ok)\r\n                                            {\r\n                                                valueOk = true;\r\n                                                targetCtStartup = (ctMin < 500 && ct < ctMin) ? ctMin : (ctMax > ctMin && ct > ctMax) ? ctMax : ct;\r\n                                                value = QVariant(targetCtStartup);\r\n                                            }\r\n                                        }\r\n                                        else if (value.type() == QVariant::String && value.toString() == QLatin1String(\"previous\"))\r\n                                        {\r\n                                            valueOk = true;\r\n                                            targetCtStartup = 0xFFFF;\r\n                                        }\r\n                                        if (valueOk)\r\n                                        {\r\n                                            change.addTargetValue(RConfigColorCtStartup, targetCtStartup);\r\n                                            lightNode->setValue(RConfigColorCtStartup, targetCtStartup);\r\n                                            DB_StoreSubDeviceItem(lightNode, item);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!paramOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path2, QString(\"parameter, %1, not available\").arg(key)));\r\n                                }\r\n                                else if (!valueOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, path2, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n                                }\r\n                                else\r\n                                {\r\n                                    QVariantMap rspItem;\r\n                                    QVariantMap rspItemState;\r\n                                    rspItemState[path2] = value;\r\n                                    rspItem[\"success\"] = rspItemState;\r\n                                    rsp.list.append(rspItem);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"execute_if_off\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigColorExecuteIfOff);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            if (value.type() == QVariant::Bool)\r\n                            {\r\n                                valueOk = true;\r\n                                change.addTargetValue(RConfigColorExecuteIfOff, value.toBool());\r\n                                lightNode->setValue(RConfigColorExecuteIfOff, value.toBool());\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"gradient\")\r\n                    {\r\n                        paramOk = true;\r\n                        if (value.type() == QVariant::Map)\r\n                        {\r\n                            valueOk = true;\r\n                            isMap = true;\r\n                            QVariantMap map2 = value.toMap();\r\n                            for (QVariantMap::const_iterator r = map2.begin(); r != map2.end(); r++)\r\n                            {\r\n                                bool paramOk = false;\r\n                                bool valueOk = false;\r\n                                key = r.key();\r\n                                QString path2 = QString(\"%1/%2\").arg(path1).arg(key);\r\n                                value = map2[key];\r\n\r\n                                if (key == \"pixel_count\")\r\n                                {\r\n                                    ResourceItem *item = lightNode->item(RConfigColorGradientPixelCount);\r\n                                    if (item)\r\n                                    {\r\n                                        paramOk = true;\r\n                                        if (value.type() == QVariant::Double)\r\n                                        {\r\n                                            const quint8 pixelCount = value.toUInt(&ok);\r\n                                            if (ok)\r\n                                            {\r\n                                                valueOk = true;\r\n                                                change.addTargetValue(RConfigColorGradientPixelCount, pixelCount);\r\n                                                lightNode->setValue(RConfigColorGradientPixelCount, pixelCount);\r\n                                                DB_StoreSubDeviceItem(lightNode, item);\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                                else if (key == \"reversed\")\r\n                                {\r\n                                    ResourceItem *item = lightNode->item(RConfigColorGradientReversed);\r\n                                    if (item)\r\n                                    {\r\n                                        paramOk = true;\r\n                                        if (value.type() == QVariant::Bool)\r\n                                        {\r\n                                            valueOk = true;\r\n                                            change.addTargetValue(RConfigColorGradientReversed, value.toBool());\r\n                                            lightNode->setValue(RConfigColorGradientReversed, value.toBool());\r\n                                            DB_StoreSubDeviceItem(lightNode, item);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!paramOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path2, QString(\"parameter, %1, not available\").arg(key)));\r\n                                }\r\n                                else if (!valueOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, path2, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n                                }\r\n                                else\r\n                                {\r\n                                    QVariantMap rspItem;\r\n                                    QVariantMap rspItemState;\r\n                                    rspItemState[path2] = value;\r\n                                    rspItem[\"success\"] = rspItemState;\r\n                                    rsp.list.append(rspItem);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (key == \"xy\")\r\n                    {\r\n                        paramOk = true;\r\n                        if (value.type() == QVariant::Map)\r\n                        {\r\n                            valueOk = true;\r\n                            isMap = true;\r\n                            QVariantMap map2 = value.toMap();\r\n                            for (QVariantMap::const_iterator r = map2.begin(); r != map2.end(); r++)\r\n                            {\r\n                                bool paramOk = false;\r\n                                bool valueOk = false;\r\n                                key = r.key();\r\n                                QString path2 = QString(\"%1/%2\").arg(path1).arg(key);\r\n                                value = map2[key];\r\n\r\n                                if (key == \"startup\")\r\n                                {\r\n                                    ResourceItem *itemX = lightNode->item(RConfigColorXyStartupX);\r\n                                    ResourceItem *itemY = lightNode->item(RConfigColorXyStartupY);\r\n                                    if (itemX && itemY)\r\n                                    {\r\n                                        paramOk = true;\r\n                                        quint16 targetXyStartupX, targetXyStartupY;\r\n                                        if (value.type() == QVariant::List)\r\n                                        {\r\n                                            QVariantList xy = value.toList();\r\n                                            if (xy[0].type() == QVariant::Double && xy[1].type() == QVariant::Double)\r\n                                            {\r\n                                                const double x = xy[0].toDouble(&ok);\r\n                                                const double y = ok ? xy[1].toDouble(&ok) : 0;\r\n                                                if (ok && x >= 0.0 && x <= 1.0 && y >= 0.0 && y <= 1.0)\r\n                                                {\r\n                                                    valueOk = true;\r\n                                                    targetXyStartupX = static_cast<quint16>(x * 65535.0);\r\n                                                    if (targetXyStartupX > 0xFEFF) { targetXyStartupX = 0xFEFF; }\r\n                                                    else if (targetXyStartupX == 0) { targetXyStartupX = 1; }\r\n                                                    targetXyStartupY = static_cast<quint16>(y * 65535.0);\r\n                                                    if (targetXyStartupY > 0xFEFF) { targetXyStartupY = 0xFEFF; }\r\n                                                    else if (targetXyStartupY == 0) { targetXyStartupY = 1; }\r\n                                                    QVariantList xy;\r\n                                                    toXy(targetXyStartupX, targetXyStartupY, xy);\r\n                                                    value = xy;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if (value.type() == QVariant::String && value.toString() == QLatin1String(\"previous\"))\r\n                                        {\r\n                                            valueOk = true;\r\n                                            targetXyStartupX = 0xFFFF;\r\n                                            targetXyStartupY = 0xFFFF;\r\n                                        }\r\n                                        if (valueOk)\r\n                                        {\r\n                                            change.addTargetValue(RConfigColorXyStartupX, targetXyStartupX);\r\n                                            change.addTargetValue(RConfigColorXyStartupY, targetXyStartupY);\r\n                                            lightNode->setValue(RConfigColorXyStartupX, targetXyStartupX);\r\n                                            lightNode->setValue(RConfigColorXyStartupY, targetXyStartupY);\r\n                                            DB_StoreSubDeviceItem(lightNode, itemX);\r\n                                            DB_StoreSubDeviceItem(lightNode, itemY);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!paramOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path2, QString(\"parameter, %1, not available\").arg(key)));\r\n                                }\r\n                                else if (!valueOk)\r\n                                {\r\n                                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, path2, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n                                }\r\n                                else\r\n                                {\r\n                                    QVariantMap rspItem;\r\n                                    QVariantMap rspItemState;\r\n                                    rspItemState[path2] = value;\r\n                                    rspItem[\"success\"] = rspItemState;\r\n                                    rsp.list.append(rspItem);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!paramOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path1, QString(\"parameter, %1, not available\").arg(key)));\r\n                    }\r\n                    else if (!valueOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, path1, QString(\"invalid value, %1, for parameter, color/%2\").arg(value.toString()).arg(key)));\r\n                    }\r\n                    else if (!isMap)\r\n                    {\r\n                        QVariantMap rspItem;\r\n                        QVariantMap rspItemState;\r\n                        rspItemState[path1] = value;\r\n                        rspItem[\"success\"] = rspItemState;\r\n                        rsp.list.append(rspItem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"groups\")\r\n        {\r\n            paramOk = true;\r\n            valueOk = true;\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, path, QString(\"parameter, %1, is not modifiable.\").arg(key)));\r\n        }\r\n        else if (key == \"locked\")\r\n        {\r\n            ResourceItem *item = lightNode->item(RConfigLocked);\r\n            if (item)\r\n            {\r\n                paramOk = true;\r\n                if (value.type() == QVariant::Bool)\r\n                {\r\n                    valueOk = true;\r\n                    change.addTargetValue(RConfigLocked, value.toBool());\r\n                    lightNode->setValue(RConfigLocked, value.toBool());\r\n                    DB_StoreSubDeviceItem(lightNode, item);\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"on\")\r\n        {\r\n            paramOk = true;\r\n            if (value.type() == QVariant::Map)\r\n            {\r\n                valueOk = true;\r\n                isMap = true;\r\n                QVariantMap map1 = value.toMap();\r\n                for (QVariantMap::const_iterator q = map1.begin(); q != map1.end(); q++)\r\n                {\r\n                    bool paramOk = false;\r\n                    bool valueOk = false;\r\n                    key = q.key();\r\n                    QString path1 = QString(\"%1/%2\").arg(path).arg(key);\r\n                    value = map1[key];\r\n\r\n                    if (key == \"startup\")\r\n                    {\r\n                        ResourceItem *item = lightNode->item(RConfigOnStartup);\r\n                        if (item)\r\n                        {\r\n                            paramOk = true;\r\n                            quint8 targetOnStartup;\r\n                            if (value.type() == QVariant::Bool)\r\n                            {\r\n                                valueOk = true;\r\n                                targetOnStartup = value.toBool() ? 1 : 0;\r\n                            }\r\n                            else if (value.type() == QVariant::String && value.toString() == QLatin1String(\"previous\"))\r\n                            {\r\n                                valueOk = true;\r\n                                targetOnStartup = 0xFF;\r\n                            }\r\n                            if (valueOk)\r\n                            {\r\n                                change.addTargetValue(RConfigOnStartup, targetOnStartup);\r\n                                lightNode->setValue(RConfigOnStartup, targetOnStartup);\r\n                                DB_StoreSubDeviceItem(lightNode, item);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!paramOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path1, QString(\"parameter, %1, not available\").arg(key)));\r\n                    }\r\n                    else if (!valueOk)\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, path1, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n                    }\r\n                    else\r\n                    {\r\n                        QVariantMap rspItem;\r\n                        QVariantMap rspItemState;\r\n                        rspItemState[path1] = value;\r\n                        rspItem[\"success\"] = rspItemState;\r\n                        rsp.list.append(rspItem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"reversed\")\r\n        {\r\n            ResourceItem *item = lightNode->item(RConfigReversed);\r\n            if (item)\r\n            {\r\n                paramOk = true;\r\n                if (value.type() == QVariant::Bool)\r\n                {\r\n                    valueOk = true;\r\n                    change.addTargetValue(RConfigReversed, value.toBool());\r\n                    lightNode->setValue(RConfigReversed, value.toBool());\r\n                    DB_StoreSubDeviceItem(lightNode, item);\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"speed\")\r\n        {\r\n            ResourceItem *item = lightNode->item(RConfigSpeed);\r\n            if (item)\r\n            {\r\n                paramOk = true;\r\n                if (value.type() == QVariant::Double)\r\n                {\r\n                    const quint8 speed = value.toUInt(&ok);\r\n                    if (ok)\r\n                    {\r\n                        valueOk = true;\r\n                        change.addTargetValue(RConfigSpeed, speed);\r\n                        lightNode->setValue(RConfigSpeed, speed);\r\n                        DB_StoreSubDeviceItem(lightNode, item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!paramOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, path, QString(\"parameter, %1, not available\").arg(key)));\r\n        }\r\n        else if (!valueOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, path, QString(\"invalid value, %1, for parameter, %2\").arg(value.toString()).arg(key)));\r\n        }\r\n        else if (!isMap)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[path] = value;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n    }\r\n\r\n    rsub->addStateChange(change);\r\n    processTasks();\r\n    return REQ_READY_SEND;\r\n}\r\n\r\nenum MultiStateOutputValue {\r\n  Down = 0,\r\n  Up = 1,\r\n  Stop = 2,\r\n  Toggle = 3,\r\n  Blocked = 4,\r\n  StepDown = 5,\r\n  StepUp = 6\r\n};\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>/state for Window covering \"lights\".\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setWindowCoveringState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map)\r\n{\r\n    static const QStringList alertList({\r\n        \"none\", \"select\"\r\n    });\r\n    bool ok;\r\n    bool supportsLiftInc = false;\r\n    QString id = req.path[3];\r\n    quint16 cluster = WINDOW_COVERING_CLUSTER_ID;\r\n    // if (taskRef.lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain\"))) // FIXME - for testing only.\r\n    if (taskRef.lightNode->modelId() != QLatin1String(\"lumi.curtain.agl001\") &&\r\n        taskRef.lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain.\")))\r\n    {\r\n        cluster = ANALOG_OUTPUT_CLUSTER_ID;\r\n        supportsLiftInc = taskRef.lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain.acn002\"));\r\n    }\r\n\r\n    if (R_GetProductId(taskRef.lightNode).startsWith(QLatin1String(\"Tuya_COVD\")))\r\n    {\r\n        cluster = TUYA_CLUSTER_ID;\r\n    }\r\n\r\n    bool requestOk = true;\r\n    bool hasOpen = false;\r\n    bool targetOpen = false;\r\n    bool hasLift = false;\r\n    bool hasLiftInc = false;\r\n    bool hasStop = false;\r\n    quint8 targetLift = 0;\r\n    quint8 targetLiftZigBee = 0;\r\n    qint8 targetLiftInc = 0;\r\n    bool hasTilt = false;\r\n    quint8 targetTilt = 0;\r\n    QString alert;\r\n    bool hasSpeed = false;\r\n    quint8 targetSpeed = 0;\r\n\r\n    // Check parameters.\r\n    const auto mapEnd = map.cend();\r\n    for (auto p = map.cbegin(); p != mapEnd; ++p)\r\n    {\r\n        bool paramOk = false;\r\n        bool valueOk = false;\r\n        QString param = p.key();\r\n        if (param == \"open\" && taskRef.lightNode->item(RStateOpen))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasOpen = true;\r\n                targetOpen = map[param].toBool();\r\n            }\r\n        }\r\n        else if (param == \"on\" && taskRef.lightNode->item(RStateOn))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasOpen = true;\r\n                targetOpen = !(map[param].toBool());\r\n            }\r\n        }\r\n        else if (param == \"stop\" && taskRef.lightNode->item(RStateOpen))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasStop = true;\r\n            }\r\n        }\r\n        else if (param == \"lift\" && taskRef.lightNode->item(RStateLift))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::String && map[param].toString() == \"stop\")\r\n            {\r\n                valueOk = true;\r\n                hasStop = true;\r\n            }\r\n            else if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint lift = map[param].toUInt(&ok);\r\n                if (ok && lift <= 100)\r\n                {\r\n                    valueOk = true;\r\n                    hasLift = true;\r\n                    targetLift = lift;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"lift_inc\" && taskRef.lightNode->item(RStateLift))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const int liftInc = map[param].toUInt(&ok);\r\n                if (ok && liftInc == 0)\r\n                {\r\n                    valueOk = true;\r\n                    hasStop = true;\r\n                }\r\n                else if (ok && liftInc >= -100 && liftInc <= 100 && supportsLiftInc)\r\n                {\r\n                    valueOk = true;\r\n                    hasLiftInc = true;\r\n                    targetLiftInc = liftInc;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"bri\" && taskRef.lightNode->item(RStateBri))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::String && map[param].toString() == \"stop\")\r\n            {\r\n                valueOk = true;\r\n                hasStop = true;\r\n            }\r\n            else if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint bri = map[param].toUInt(&ok);\r\n                if (ok && bri <= 0xFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasLift = true;\r\n                    targetLift = bri * 100 / 254;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"bri_inc\" && taskRef.lightNode->item(RStateBri))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const int bri_inc = map[param].toInt(&ok);\r\n                if (ok && bri_inc == 0)\r\n                {\r\n                    valueOk = true;\r\n                    hasStop = true;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"tilt\" && taskRef.lightNode->item(RStateTilt))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint tilt = map[param].toUInt(&ok);\r\n                if (ok && tilt <= 100)\r\n                {\r\n                    valueOk = true;\r\n                    hasTilt = true;\r\n                    targetTilt = tilt;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"sat\" && taskRef.lightNode->item(RStateSat))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint sat = map[param].toUInt(&ok);\r\n                if (ok && sat <= 255)\r\n                {\r\n                    valueOk = true;\r\n                    hasTilt = true;\r\n                    targetTilt = sat * 100 / 254;\r\n                }\r\n            }\r\n        }\r\n        else if (param == \"alert\" && taskRef.lightNode->item(RStateAlert))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::String)\r\n            {\r\n                alert = map[param].toString();\r\n                valueOk = alertList.contains(alert);\r\n            }\r\n        }\r\n        else if (param == \"speed\" && taskRef.lightNode->item(RStateSpeed))\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint speed = map[param].toUInt(&ok);\r\n                if (ok && speed <= 0xFF)\r\n                {\r\n                    valueOk = true;\r\n                    hasSpeed = true;\r\n                    targetSpeed = speed > 2 ? 2 : speed;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!paramOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, %1, not available\").arg(param)));\r\n            requestOk = false;\r\n        }\r\n        else if (!valueOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\r\n            requestOk = false;\r\n        }\r\n    }\r\n    if (!requestOk)\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // Some devices invert LiftPct.\r\n    if (hasLift)\r\n    {\r\n        if (taskRef.lightNode->modelId().startsWith(QLatin1String(\"lumi.curtain\")) ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"11830304 Switch\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Zigbee dual curtain switch\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Covering Switch ESW-2ZAD-EU\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"QS-Zigbee-C01 Module\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Zigbee curtain switch\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD YS-MT750\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD DS82\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\") ||\r\n            taskRef.lightNode->modelId() == QLatin1String(\"Motor Controller\"))\r\n        {\r\n            targetLiftZigBee = 100 - targetLift;\r\n        }\r\n        else if (taskRef.lightNode->modelId() == QLatin1String(\"Shutter switch with neutral\") ||\r\n                 taskRef.lightNode->modelId() == QLatin1String(\"Shutter SW with level control\"))\r\n        {\r\n            // Legrand invert bri and don't support other value than 0\r\n            bool bStatus = false;\r\n            uint nHex = taskRef.lightNode->swBuildId().toUInt(&bStatus, 16);\r\n            if (bStatus && nHex < 28)\r\n            {\r\n                targetLiftZigBee = targetLift == 0 ? 100 : 0;\r\n            }\r\n            else if (bStatus && nHex < 44)\r\n            {\r\n                targetLiftZigBee = targetLift == 100 ? 100 : 0;\r\n            }\r\n            else\r\n            {\r\n                // New devices no need thoses previous hack\r\n                targetLiftZigBee = targetLift;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            targetLiftZigBee = targetLift;\r\n        }\r\n    }\r\n\r\n    //Some device don't support lift, but third app can use it\r\n    if (hasLift)\r\n    {\r\n        if (taskRef.lightNode->manufacturer() == QLatin1String(\"_TYZB01_dazsid15\") ||\r\n            taskRef.lightNode->modelId() == QLatin1String(\"FB56+CUR17SB2.2\"))\r\n        {\r\n            hasLift = false;\r\n            hasOpen = true;\r\n            if (targetLiftZigBee > 0)\r\n            {\r\n                targetOpen = false;\r\n            }\r\n            else\r\n            {\r\n                targetOpen = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Send command(s) to device.  stop trumps lift trumps lift_inc trumps open.\r\n    if (hasStop)\r\n    {\r\n        bool ok;\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (cluster == TUYA_CLUSTER_ID)\r\n        {\r\n            if (R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\"))\r\n            {\r\n                //This device use bad command\r\n                ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_CONTROL, QByteArray(\"\\x00\", 1));\r\n            }\r\n            else\r\n            {\r\n                ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_CONTROL, QByteArray(\"\\x01\", 1));\r\n            }\r\n        }\r\n        else if (cluster == ANALOG_OUTPUT_CLUSTER_ID)\r\n        {\r\n            quint16 value = MultiStateOutputValue::Stop;\r\n\r\n            deCONZ::ZclAttribute attr(0x0055, deCONZ::Zcl16BitUint, \"value\", deCONZ::ZclReadWrite, true);\r\n            attr.setValue(QVariant(value));\r\n            taskRef.lightNode->rx(); // Tell writeAttribute() device is awake.\r\n            ok = writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), MULTISTATE_OUTPUT_CLUSTER_ID, attr);\r\n        }\r\n        else\r\n        {\r\n            ok = addTaskWindowCovering(task, WINDOW_COVERING_COMMAND_STOP, 0, 0);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/stop\").arg(id)] = true;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Rely on attribute reporting to update the light state.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/stop\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasLift)\r\n    {\r\n        bool ok;\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (cluster == TUYA_CLUSTER_ID)\r\n        {\r\n            QByteArray lev = QByteArray(\"\\x00\\x00\\x00\", 3);\r\n            lev.append(targetLiftZigBee);\r\n            ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_VALUE, DP_IDENTIFIER_PERCENT_CONTROL, lev);\r\n        }\r\n        else if (cluster == ANALOG_OUTPUT_CLUSTER_ID)\r\n        {\r\n            float value = targetLiftZigBee;\r\n\r\n            deCONZ::ZclAttribute attr(0x0055, deCONZ::ZclSingleFloat, \"value\", deCONZ::ZclReadWrite, true);\r\n            attr.setValue(QVariant(value));\r\n            taskRef.lightNode->rx(); // Tell writeAttribute() device is awake.\r\n            ok = writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), cluster, attr);\r\n        }\r\n        else\r\n        {\r\n            ok = addTaskWindowCovering(task, WINDOW_COVERING_COMMAND_GOTO_LIFT_PCT, 0, targetLiftZigBee);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/lift\").arg(id)] = targetLift;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n\r\n            // I m using this code only for Legrand ATM but can be used for other device.\r\n            // Because the attribute reporting take realy long time to be done, can be 2 minutes\r\n            // Or it can be changed only after this time, so using an read attribute don't give usable value\r\n            // And can cause issue on some third app\r\n            if (taskRef.lightNode->modelId() == QLatin1String(\"Shutter switch with neutral\") ||\r\n                taskRef.lightNode->modelId() == QLatin1String(\"Shutter SW with level control\"))\r\n            {\r\n                taskRef.lightNode->setValue(RStateLift, 50);\r\n                taskRef.lightNode->setValue(RStateBri, 127);\r\n            }\r\n\r\n            // Rely on attribute reporting to update the light state.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/lift\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n    else if (hasLiftInc)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (cluster == ANALOG_OUTPUT_CLUSTER_ID)\r\n        {\r\n            quint16 value;\r\n            if (targetLiftInc == 0)\r\n            {\r\n                value = MultiStateOutputValue::Stop;\r\n            } else if (targetLiftInc > 0)\r\n            {\r\n                value = MultiStateOutputValue::StepDown;\r\n                targetLiftInc = 1;\r\n            } else {\r\n                value = MultiStateOutputValue::StepUp;\r\n                targetLiftInc = -1;\r\n            }\r\n            deCONZ::ZclAttribute attr(0x0055, deCONZ::Zcl16BitUint, \"value\", deCONZ::ZclReadWrite, true);\r\n            attr.setValue(QVariant(value));\r\n            taskRef.lightNode->rx(); // Tell writeAttribute() device is awake.\r\n            if (writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), MULTISTATE_OUTPUT_CLUSTER_ID, attr))\r\n            {\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/lights/%1/state/lift_inc\").arg(id)] = targetLiftInc;\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/lift_inc\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n            }\r\n        }\r\n    }\r\n    else if (hasOpen)\r\n    {\r\n        bool ok;\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (cluster == TUYA_CLUSTER_ID)\r\n        {\r\n            // Reverse side for open/close command\r\n            bool targetOpen2 = targetOpen;\r\n            if (R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD M515EGB\"))\r\n            {\r\n                targetOpen2 = !targetOpen;\r\n            }\r\n\r\n            if (targetOpen2)\r\n            {\r\n                ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_CONTROL, QByteArray(\"\\x02\", 1));\r\n            }\r\n            else\r\n            {\r\n                if (R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\"))\r\n                {\r\n                    //This device use bad command\r\n                    ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_CONTROL, QByteArray(\"\\x01\", 1));\r\n                }\r\n                else\r\n                {\r\n                    ok = sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_CONTROL, QByteArray(\"\\x00\", 1));\r\n                }\r\n            }\r\n        }\r\n        else if (cluster == ANALOG_OUTPUT_CLUSTER_ID)\r\n        {\r\n            quint16 value = targetOpen ? MultiStateOutputValue::Up : MultiStateOutputValue::Down;\r\n\r\n            deCONZ::ZclAttribute attr(0x0055, deCONZ::Zcl16BitUint, \"value\", deCONZ::ZclReadWrite, true);\r\n            attr.setValue(QVariant(value));\r\n            taskRef.lightNode->rx(); // Tell writeAttribute() device is awake.\r\n            ok = writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), MULTISTATE_OUTPUT_CLUSTER_ID, attr);\r\n        }\r\n        else\r\n        {\r\n            ok = addTaskWindowCovering(task, targetOpen ? WINDOW_COVERING_COMMAND_OPEN : WINDOW_COVERING_COMMAND_CLOSE, 0, 0);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/open\").arg(id)] = targetOpen;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // I m using this code only for Legrand ATM but can be used for other device.\r\n            // Because the attribute reporting take realy long time to be done, can be 2 minutes\r\n            // Or it can be changed only after this time, so using an read attribute don't give usable value\r\n            // And can cause issue on some third app\r\n            if (taskRef.lightNode->modelId() == QLatin1String(\"Shutter switch with neutral\") ||\r\n                taskRef.lightNode->modelId() == QLatin1String(\"Shutter SW with level control\"))\r\n            {\r\n                taskRef.lightNode->setValue(RStateLift, 50);\r\n                taskRef.lightNode->setValue(RStateBri, 127);\r\n            }\r\n\r\n            // Rely on attribute reporting to update the light state.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/open\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // Handle tilt independently from stop/lift/lift_inc/open.\r\n    if (hasTilt)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (addTaskWindowCovering(task, WINDOW_COVERING_COMMAND_GOTO_TILT_PCT, 0, targetTilt))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/tilt\").arg(id)] = targetTilt;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Rely on attribute reporting to update the light state.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/tilt\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (!alert.isEmpty())\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n        task.taskType = TaskIdentify;\r\n        task.identifyTime = alert == \"select\" ? 2 : 0;\r\n\r\n        if (addTaskIdentify(task, task.identifyTime))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = alert;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Don't update write-only state.alert.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/alert\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (hasSpeed)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        deCONZ::ZclAttribute attr(0x0408, deCONZ::Zcl8BitUint, \"speed\", deCONZ::ZclReadWrite, true);\r\n        attr.setValue(QVariant(targetSpeed));\r\n        taskRef.lightNode->rx(); // Tell writeAttribute() device is awake.\r\n        if (writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), XIAOMI_CLUSTER_ID, attr, VENDOR_XIAOMI))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/speed\").arg(id)] = targetSpeed;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Rely on attribute reporting to update the light state.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/speed\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    rsp.etag = taskRef.lightNode->etag;\r\n    processTasks();\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n//\r\n// Tuya Devices\r\n//\r\nint DeRestPluginPrivate::setTuyaDeviceState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map)\r\n{\r\n    QString id = req.path[3];\r\n\r\n    bool targetOn = false;\r\n    bool hasOn = false;\r\n    bool hasBri = false;\r\n    bool hasAlert = false;\r\n    uint targetBri = 0;\r\n\r\n    bool ok = false;\r\n\r\n    //Parse all parameters\r\n    for (QVariantMap::const_iterator p = map.begin(); p != map.end(); p++)\r\n    {\r\n        if (p.key() == \"bri\" && R_GetProductId(taskRef.lightNode).startsWith(QLatin1String(\"Tuya_DIMSWITCH\")))\r\n        {\r\n            if (map[p.key()].type() == QVariant::Double)\r\n            {\r\n                targetBri = map[\"bri\"].toUInt(&ok);\r\n                if (ok && targetBri <= 0xFF)\r\n                {\r\n                    hasBri = true;\r\n                }\r\n            }\r\n\r\n            if (!hasBri)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1\").arg(id), QString(\"invalid value, %1, for parameter, bri\").arg(map[\"bri\"].toString())));\r\n            }\r\n        }\r\n\r\n        else if (p.key() == \"on\" && taskRef.lightNode->item(RStateOn))\r\n        {\r\n            if (map[p.key()].type() == QVariant::Bool)\r\n            {\r\n                hasOn = true;\r\n                targetOn = map[\"on\"].toBool();\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, on\").arg(map[\"on\"].toString())));\r\n            }\r\n        }\r\n\r\n        else if (p.key() == \"alert\")\r\n        {\r\n            if (map[p.key()].type() == QVariant::String)\r\n            {\r\n                hasAlert = true;\r\n            }\r\n        }\r\n\r\n        //Not used but can cause error\r\n        else if (p.key() == \"transitiontime\")\r\n        {\r\n        }\r\n\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, %1, not available\").arg(p.key())));\r\n        }\r\n    }\r\n\r\n    // Return direct if there is already error\r\n    if (!rsp.list.isEmpty())\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (hasBri)\r\n    {\r\n        quint16 bri = targetBri * 1000 / 254;\r\n        QByteArray data = QByteArray(\"\\x00\\x00\", 2);\r\n        data.append(static_cast<qint8>((bri >> 8) & 0xff));\r\n        data.append(static_cast<qint8>(bri & 0xff));\r\n\r\n        if (R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_DIMSWITCH Earda Dimmer\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_DIMSWITCH MS-105Z\") ||\r\n            R_GetProductId(taskRef.lightNode) == QLatin1String(\"Tuya_DIMSWITCH EDM-1ZAA-EU\"))\r\n        {\r\n            ok = sendTuyaRequest(taskRef, TaskTuyaRequest, DP_TYPE_VALUE, DP_IDENTIFIER_DIMMER_LEVEL_MODE2, data);\r\n        }\r\n        else\r\n        {\r\n            ok = sendTuyaRequest(taskRef, TaskTuyaRequest, DP_TYPE_VALUE, DP_IDENTIFIER_DIMMER_LEVEL_MODE1, data);\r\n        }\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/bri\").arg(id)] = targetBri;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    if (hasOn)\r\n    {\r\n        qint8 button = DP_IDENTIFIER_BUTTON_1;\r\n        QByteArray data;\r\n\r\n        //Retreive Fake endpoint, and change button value\r\n        const auto ep = taskRef.lightNode->haEndpoint().endpoint();\r\n        if      (ep == 0x02) { button = DP_IDENTIFIER_BUTTON_2; }\r\n        else if (ep == 0x03) { button = DP_IDENTIFIER_BUTTON_3; }\r\n\r\n        //Use only the first endpoint for command\r\n        taskRef.req.setDstEndpoint(0x01);\r\n\r\n        DBG_Printf(DBG_INFO, \"Tuya debug 10: EP: %d ID : %s\\n\", ep, qPrintable(id));\r\n\r\n        if (targetOn)\r\n        {\r\n            data = QByteArray(\"\\x01\", 1);\r\n        }\r\n        else\r\n        {\r\n            data = QByteArray(\"\\x00\", 1);\r\n        }\r\n\r\n        ok = sendTuyaRequest(taskRef, TaskTuyaRequest, DP_TYPE_BOOL, button, data);\r\n\r\n        if (ok)\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = targetOn;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n\r\n    }\r\n\r\n    if (hasAlert)\r\n    {\r\n        QByteArray data(\"\\x00\", 1);\r\n\r\n        if (map[\"alert\"].toString() == \"lselect\")\r\n        {\r\n            data = QByteArray(\"\\x01\",1);\r\n        }\r\n\r\n        if (sendTuyaRequest(taskRef, TaskTuyaRequest, DP_TYPE_BOOL, DP_IDENTIFIER_ALARM, data))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = map[\"alert\"].toString();\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>/state for Warning device \"lights\".\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setWarningDeviceState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map)\r\n{\r\n    bool ok;\r\n    QString id = req.path[3];\r\n\r\n    bool requestOk = true;\r\n    bool hasCmd = false;\r\n    QString alert;\r\n    quint16 onTime = 0;\r\n    static const QStringList alertList({ \"none\", \"select\", \"lselect\", \"blink\", \"all\" });\r\n\r\n    // Check parameters.\r\n    for (QVariantMap::const_iterator p = map.begin(); p != map.end(); p++)\r\n    {\r\n        bool paramOk = false;\r\n        bool valueOk = false;\r\n        QString param = p.key();\r\n\r\n        if (param == \"alert\" && taskRef.lightNode->item(RStateAlert))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::String)\r\n            {\r\n                alert = map[param].toString();\r\n                valueOk = alertList.contains(alert);\r\n            }\r\n        }\r\n        else if (param == \"ontime\")\r\n        {\r\n            paramOk = true;\r\n            if (map[param].type() == QVariant::Double)\r\n            {\r\n                const uint ot = map[param].toUInt(&ok);\r\n                if (ok && ot < 0xFFFF)\r\n                {\r\n                    valueOk = true;\r\n                    onTime = ot;\r\n                }\r\n            }\r\n        }\r\n        if (!paramOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id).arg(param), QString(\"parameter, %1, not available\").arg(param)));\r\n            requestOk = false;\r\n        }\r\n        else if (!valueOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state/%2\").arg(id).arg(param), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\r\n            requestOk = false;\r\n        }\r\n    }\r\n    if (onTime > 0 && alert.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, alert, for parameter, ontime\")));\r\n        requestOk = false;\r\n    }\r\n    if (requestOk && !hasCmd)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter to set warning device state\")));\r\n        requestOk = false;\r\n    }\r\n    if (!requestOk)\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (taskRef.lightNode->node()->isZombie() || !taskRef.lightNode->lastRx().isValid())\r\n    {\r\n        DBG_Printf(DBG_INFO,\"0x%016llX: resurrecting zombie siren\\n\", taskRef.lightNode->address().ext());\r\n        taskRef.lightNode->rx(); // FIXME: this incorrectly updates `lastseen`\r\n    }\r\n\r\n    TaskItem task;\r\n    copyTaskReq(taskRef, task);\r\n    task.taskType = TaskWarning;\r\n\r\n    if (!alert.isEmpty())\r\n    {\r\n        Device *device = static_cast<Device*>(task.lightNode->parentResource());\r\n        \r\n        if (device && device->managed())\r\n        {\r\n            if (alert == \"none\" || alert == \"select\")\r\n            {\r\n                ResourceItem *item = task.lightNode->item(RStateAlert);\r\n                const auto ddfItem = DDF_GetItem(item);\r\n\r\n                if (!ddfItem.writeParameters.isNull())\r\n                {\r\n                    StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, task.req.dstEndpoint());\r\n                    change.addTargetValue(RStateAlert, alert);\r\n                    task.lightNode->addStateChange(change);\r\n                    \r\n                    QVariantMap rspItem;\r\n                    QVariantMap rspItemState;\r\n                    rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = alert;\r\n                    rspItem[\"success\"] = rspItemState;\r\n                    rsp.list.append(rspItem);\r\n                    // Don't update write-only state.alert.\r\n                    \r\n                    rsp.etag = taskRef.lightNode->etag;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (alert == \"none\")\r\n        {\r\n            task.options = 0x00; // Warning mode 0 (no warning), No strobe, Low sound\r\n            task.duration = 0;\r\n        }\r\n        else if (alert == \"select\")\r\n        {\r\n            task.options = 0x17; // Warning mode 1 (burglar), Strobe, Very high sound\r\n            if (taskRef.lightNode->modelId().startsWith(QLatin1String(\"902010/24\")) ||\r\n                taskRef.lightNode->modelId() == QLatin1String(\"902010/29\"))\r\n            {\r\n                task.options = 0x12;    // Warning mode 1 (burglar), no Strobe, high sound\r\n            }\r\n            else if (taskRef.lightNode->modelId() == QLatin1String(\"SIRZB-110\"))    // Doesn't support strobe\r\n            {\r\n                task.options = 0xC1;    // Warning mode 1 (burglar), no Strobe, Very high sound, Develco uses inversed bit order\r\n            }\r\n            else if (taskRef.lightNode->modelId() == QLatin1String(\"TS0219\"))\r\n            {\r\n                task.options = 0x24;    // Only supported combination\r\n            }\r\n            task.duration = 1;\r\n        }\r\n        else if (alert == \"lselect\")\r\n        {\r\n            task.options = 0x17; // Warning mode 1 (burglar), Strobe, Very high sound\r\n            if (taskRef.lightNode->modelId().startsWith(QLatin1String(\"902010/24\")) ||\r\n                taskRef.lightNode->modelId() == QLatin1String(\"902010/29\"))\r\n            {\r\n                task.options = 0x12;    // Warning mode 1 (burglar), no Strobe, high sound\r\n            }\r\n            else if (taskRef.lightNode->modelId() == QLatin1String(\"SIRZB-110\"))    // Doesn't support strobe\r\n            {\r\n                task.options = 0xC1;    // Warning mode 1 (burglar), no Strobe, Very high sound, Develco uses inversed bit order\r\n            }\r\n            task.duration = onTime > 0 ? onTime : 300;\r\n        }\r\n        else if (alert == \"blink\")\r\n        {\r\n            task.options = 0x04; // Warning mode 0 (no warning), Strobe, Low sound\r\n            task.duration = onTime > 0 ? onTime : 300;\r\n        }\r\n        else if (alert == \"all\")\r\n        {\r\n            // FXIME: Dirty hack to send a network-wide broadcast to activate all sirens.\r\n            task.req.dstAddress().setNwk(deCONZ::BroadcastAll);\r\n            task.req.setDstAddressMode(deCONZ::ApsNwkAddress);\r\n            // task.req.setTxOptions(0);\r\n            task.req.setDstEndpoint(0xFF);\r\n            task.options = 0x17; // Warning mode 1 (burglar), Strobe, Very high sound\r\n            task.duration = onTime > 0 ? onTime : 1;\r\n        }\r\n\r\n        if (addTaskWarning(task, task.options, task.duration))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = alert;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            // Don't update write-only state.alert.\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/alert\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    rsp.etag = taskRef.lightNode->etag;\r\n    processTasks();\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>/state for Door Lock \"lights\".\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setDoorLockState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map)\r\n{\r\n    static const QStringList alertList({\r\n        \"none\", \"select\"\r\n    });\r\n    QString id = req.path[3];\r\n\r\n    bool requestOk = true;\r\n    bool hasCmd = false;\r\n    bool hasOn = false;\r\n    bool targetOn = false;\r\n    QString alert;\r\n\r\n    // Check parameters.\r\n    for (QVariantMap::const_iterator p = map.begin(); p != map.end(); p++)\r\n    {\r\n        bool paramOk = false;\r\n        bool valueOk = false;\r\n        QString param = p.key();\r\n\r\n        if (param == \"on\" && taskRef.lightNode->item(RStateOn))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::Bool)\r\n            {\r\n                valueOk = true;\r\n                hasOn = true;\r\n                targetOn = map[param].toBool();\r\n            }\r\n        }\r\n        else if (param == \"alert\" && taskRef.lightNode->item(RStateAlert))\r\n        {\r\n            paramOk = true;\r\n            hasCmd = true;\r\n            if (map[param].type() == QVariant::String)\r\n            {\r\n                alert = map[param].toString();\r\n                valueOk = alertList.contains(alert);\r\n            }\r\n        }\r\n        if (!paramOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id).arg(param), QString(\"parameter, %1, not available\").arg(param)));\r\n            requestOk = false;\r\n        }\r\n        else if (!valueOk)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state/%2\").arg(id).arg(param), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\r\n            requestOk = false;\r\n        }\r\n    }\r\n    if (requestOk && !hasCmd)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter to set door lock state\")));\r\n        requestOk = false;\r\n    }\r\n    if (!requestOk)\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // state.on\r\n    if (hasOn)\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n\r\n        if (addTaskDoorLockUnlock(task, targetOn ? 0x00 /*Lock*/ : 0x01 /*Unlock*/))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = targetOn;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/on\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    // state.alert\r\n    if (!alert.isEmpty())\r\n    {\r\n        TaskItem task;\r\n        copyTaskReq(taskRef, task);\r\n        task.taskType = TaskIdentify;\r\n\r\n        if (alert == \"none\")\r\n        {\r\n            task.identifyTime = 0;\r\n        }\r\n        else if (alert == \"select\")\r\n        {\r\n            task.identifyTime = 2;    // Hue lights don't react to 1.\r\n        }\r\n        else if (alert == \"lselect\")\r\n        {\r\n            task.identifyTime = taskRef.onTime > 0 ? taskRef.onTime : 15; // Default for Philips Hue bridge\r\n        }\r\n\r\n        if (addTaskIdentify(task, task.identifyTime))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/state/alert\").arg(id)] = alert;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            // Don't update write-only state.alert.\r\n        }\r\n        else if (task.taskType == TaskIdentify || task.taskType == TaskTriggerEffect)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\r\n        }\r\n    }\r\n\r\n    rsp.etag = taskRef.lightNode->etag;\r\n    processTasks();\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/lights/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setLightAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QString id = req.path[3];\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!lightNode || lightNode->state() == LightNode::StateDeleted)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/lights/%1\").arg(id), QString(\"body contains invalid JSON\")));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // name\r\n    if (map.contains(\"name\"))\r\n    {\r\n        QString name = map[\"name\"].toString().trimmed();\r\n\r\n        if (name.size() <= 32)\r\n        {\r\n            // if zero length set default name\r\n            // TODO use model description from basic cluster\r\n            if (name.size() == 0)\r\n            {\r\n                name = lightNode->id();\r\n            }\r\n\r\n            if (lightNode->node())\r\n            {\r\n                lightNode->node()->setUserDescriptor(name);\r\n            }\r\n            if (lightNode->name() != name)\r\n            {\r\n                lightNode->setName(name);\r\n\r\n                updateLightEtag(lightNode);\r\n                lightNode->setNeedSaveDatabase(true);\r\n                queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n\r\n                Event e(RLights, RAttrName, lightNode->id(), lightNode->item(RAttrName));\r\n                enqueueEvent(e);\r\n            }\r\n\r\n            Q_Q(DeRestPlugin);\r\n            q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"name\"), name);\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/name\").arg(id)] = map[\"name\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.etag = lightNode->etag;\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1\").arg(id), QString(\"invalid value, %1, for parameter, /lights/%2/name\").arg(name).arg(id)));\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // powerup options\r\n    if (map.contains(\"powerup\"))\r\n    {\r\n        ResourceItem *item = lightNode->item(RAttrPowerup);\r\n\r\n        if (!item)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"parameter, /lights/%1/powerup, is not available\").arg(id)));\r\n            rsp.httpStatus = HttpStatusNotFound;\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (item->setValue(map[\"powerup\"]))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/powerup\").arg(id)] = map[\"powerup\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.etag = lightNode->etag;\r\n\r\n            if (item->lastSet() == item->lastChanged())\r\n            {\r\n                Event e(RLights, RAttrPowerup, lightNode->id(), item);\r\n                enqueueEvent(e);\r\n                lightNode->setNeedSaveDatabase(true);\r\n                queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/powerup\").arg(id), QString(\"invalid value, %1, for parameter powerup\").arg(map[\"powerup\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // Tuya options\r\n    // Reverse covering\r\n    if (map.contains(\"reverse\"))\r\n    {\r\n\r\n        TaskItem taskRef;\r\n        taskRef.lightNode = getLightNodeForId(id);\r\n\r\n        if (!taskRef.lightNode || taskRef.lightNode->state() == LightNode::StateDeleted)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotFound;\r\n            rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (!taskRef.lightNode->isAvailable())\r\n        {\r\n            rsp.httpStatus = HttpStatusOk;\r\n            rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        // set destination parameters\r\n        taskRef.req.dstAddress() = taskRef.lightNode->address();\r\n        taskRef.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\r\n        taskRef.req.setDstEndpoint(taskRef.lightNode->haEndpoint().endpoint());\r\n        taskRef.req.setSrcEndpoint(getSrcEndpoint(taskRef.lightNode, taskRef.req));\r\n        taskRef.req.setDstAddressMode(deCONZ::ApsExtAddress);\r\n        //taskRef.transitionTime = 4;\r\n        //taskRef.onTime = 0;\r\n\r\n        QByteArray direction = QByteArray(\"\\x00\", 1);\r\n        if (map[\"reverse\"].toBool())\r\n        {\r\n            direction = QByteArray(\"\\x01\", 1);\r\n        }\r\n\r\n        if (sendTuyaRequest(taskRef, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_WORK_STATE, direction))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/reverse\").arg(id)] = map[\"reverse\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.etag = lightNode->etag;\r\n\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/reverse\").arg(id), QString(\"invalid value, %1, for parameter reverse\").arg(map[\"reverse\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    // Calibration command used for covering\r\n    if (map.contains(\"calibration\"))\r\n    {\r\n\r\n        TaskItem taskRef;\r\n        taskRef.lightNode = getLightNodeForId(id);\r\n\r\n        if (!taskRef.lightNode || taskRef.lightNode->state() == LightNode::StateDeleted)\r\n        {\r\n            rsp.httpStatus = HttpStatusNotFound;\r\n            rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        if (!taskRef.lightNode->isAvailable())\r\n        {\r\n            rsp.httpStatus = HttpStatusOk;\r\n            rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n            return REQ_READY_SEND;\r\n        }\r\n\r\n        qint64 value = 0x00;\r\n        if (map[\"calibration\"].toBool())\r\n        {\r\n            value = 0x01;\r\n        }\r\n\r\n        deCONZ::ZclAttribute attr(0xf001, deCONZ::Zcl8BitEnum, \"calibration\", deCONZ::ZclReadWrite, true);\r\n        attr.setValue(value);\r\n\r\n        if (writeAttribute(taskRef.lightNode, taskRef.lightNode->haEndpoint().endpoint(), WINDOW_COVERING_CLUSTER_ID, attr))\r\n        {\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/calibration\").arg(id)] = map[\"calibration\"];\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.etag = lightNode->etag;\r\n\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/calibration\").arg(id), QString(\"invalid value, %1, for parameter calibration\").arg(map[\"calibration\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    /*else\r\n    {\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1\").arg(id), QString(\"missing parameters in body\")));\r\n        return REQ_READY_SEND;\r\n    }*/\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/lights/<id>\r\n    \\return 0 - on success\r\n           -1 - on error\r\n */\r\nint DeRestPluginPrivate::deleteLight(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 4);\r\n\r\n    if (req.path.size() != 4)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    const QString &id = req.path[3];\r\n\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    if (!lightNode || lightNode->state() == LightNode::StateDeleted)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    bool ok;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/lights/%1\").arg(id), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    bool hasReset = map.contains(\"reset\");\r\n\r\n    if (hasReset)\r\n    {\r\n        if (map[\"reset\"].type() == QVariant::Bool)\r\n        {\r\n            bool reset = map[\"reset\"].toBool();\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/lights/%1/reset\").arg(id)] = reset;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n\r\n            if (reset)\r\n            {\r\n                lightNode->setResetRetryCount(10);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/reset\").arg(id), QString(\"invalid value, %1, for parameter, reset\").arg(map[\"reset\"].toString())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"id\"] = id;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    // delete all group membership from light\r\n    std::vector<GroupInfo>::iterator g = lightNode->groups().begin();\r\n    std::vector<GroupInfo>::iterator gend = lightNode->groups().end();\r\n\r\n    for (; g != gend; ++g)\r\n    {\r\n        //delete Light from all scenes.\r\n        deleteLightFromScenes(id, g->id);\r\n\r\n        //delete Light from all groups\r\n        g->actions &= ~GroupInfo::ActionAddToGroup;\r\n        g->actions |= GroupInfo::ActionRemoveFromGroup;\r\n        if (g->state != GroupInfo::StateNotInGroup)\r\n        {\r\n            g->state = GroupInfo::StateNotInGroup;\r\n        }\r\n    }\r\n\r\n    if (lightNode->state() != LightNode::StateDeleted)\r\n    {\r\n        lightNode->setState(LightNode::StateDeleted);\r\n        lightNode->setNeedSaveDatabase(true);\r\n    }\r\n\r\n    {\r\n        Q_Q(DeRestPlugin);\r\n        q->nodeUpdated(lightNode->address().ext(), QLatin1String(\"deleted\"), QLatin1String(\"\"));\r\n    }\r\n\r\n    updateLightEtag(lightNode);\r\n    queSaveDb(DB_LIGHTS | DB_GROUPS | DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = lightNode->etag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/lights/<id>/scenes\r\n    \\return 0 - on success\r\n           -1 - on error\r\n */\r\nint DeRestPluginPrivate::removeAllScenes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 5);\r\n\r\n    if (req.path.size() != 5)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    const QString &id = req.path[3];\r\n\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    if (!lightNode)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    else\r\n    {\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[\"id\"] = id;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n    }\r\n\r\n    //delete Light from all scenes.\r\n    std::vector<GroupInfo>::iterator g = lightNode->groups().begin();\r\n    std::vector<GroupInfo>::iterator gend = lightNode->groups().end();\r\n\r\n    for (; g != gend; ++g)\r\n    {\r\n        deleteLightFromScenes(id, g->id);\r\n    }\r\n\r\n    queSaveDb(DB_SCENES, DB_SHORT_SAVE_DELAY);\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = lightNode->etag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/lights/<id>/groups\r\n    \\return 0 - on success\r\n           -1 - on error\r\n */\r\nint DeRestPluginPrivate::removeAllGroups(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 5);\r\n\r\n    if (req.path.size() != 5)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    const QString &id = req.path[3];\r\n\r\n    LightNode *lightNode = getLightNodeForId(id);\r\n\r\n    if (!lightNode)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/lights/%1\").arg(id), QString(\"resource, /lights/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"id\"] = id;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n\r\n    // delete all group membership from light\r\n    std::vector<GroupInfo>::iterator g = lightNode->groups().begin();\r\n    std::vector<GroupInfo>::iterator gend = lightNode->groups().end();\r\n\r\n    for (; g != gend; ++g)\r\n    {\r\n        //delete Light from all scenes.\r\n        deleteLightFromScenes(id, g->id);\r\n\r\n        //delete Light from all groups\r\n        g->actions &= ~GroupInfo::ActionAddToGroup;\r\n        g->actions |= GroupInfo::ActionRemoveFromGroup;\r\n        if (g->state != GroupInfo::StateNotInGroup)\r\n        {\r\n            g->state = GroupInfo::StateNotInGroup;\r\n            lightNode->setNeedSaveDatabase(true);\r\n        }\r\n    }\r\n\r\n    updateLightEtag(lightNode);\r\n    queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    rsp.etag = lightNode->etag;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\nvoid DeRestPluginPrivate::handleLightEvent(const Event &e)\r\n{\r\n    DBG_Assert(e.resource() == RLights);\r\n    DBG_Assert(e.what() != nullptr);\r\n\r\n    LightNode *lightNode = getLightNodeForId(e.id());\r\n\r\n    if (!lightNode)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (strncmp(e.what(), \"attr/\", 5) == 0 || strncmp(e.what(), \"cap/\", 4) == 0 ||\r\n        strncmp(e.what(), \"config/\", 7) == 0 || strncmp(e.what(), \"state/\", 6) == 0)\r\n    {\r\n        ResourceItem *item = lightNode->item(e.what());\r\n        if (item)\r\n        {\r\n            if (!(item->needPushSet() || item->needPushChange()))\r\n            {\r\n                return; // already pushed\r\n            }\r\n\r\n            bool pushAttr = false;\r\n            bool pushCap = false;\r\n            bool pushConfig = false;\r\n            bool pushState = false;\r\n\r\n            QVariantMap attr;\r\n\r\n            QVariantMap capabilities;\r\n            QVariantMap capabilitiesBri;\r\n            QVariantMap capabilitiesColor;\r\n            ResourceItem *itemColorCapabilties = nullptr;\r\n            ResourceItem *itemCapColorEffects = nullptr;\r\n            QVariantMap capabilitiesColorCt;\r\n            QVariantMap capabilitiesColorGradient;\r\n            QVariantMap capabilitiesColorXy;\r\n            ResourceItem *ibluex = nullptr;\r\n            ResourceItem *ibluey = nullptr;\r\n            ResourceItem *igreenx = nullptr;\r\n            ResourceItem *igreeny = nullptr;\r\n            ResourceItem *iredx = nullptr;\r\n            ResourceItem *iredy = nullptr;\r\n            QStringList effectList = RStateEffectValues;\r\n            QVariantMap capabilitiesOtau;\r\n\r\n            QVariantMap config;\r\n            QVariantMap configBri;\r\n            QVariantMap configColor;\r\n            QVariantMap configColorCt;\r\n            QVariantMap configColorGradient;\r\n            QVariantMap configColorXy;\r\n            ResourceItem *isx = nullptr;\r\n            ResourceItem *isy = nullptr;\r\n            QVariantMap configOn;\r\n\r\n            QVariantMap state;\r\n            ResourceItem *ialert = nullptr;\r\n            const QStringList *capabilitiesAlerts = &RStateAlertValues;\r\n            ResourceItem *ix = nullptr;\r\n            ResourceItem *iy = nullptr;\r\n\r\n            for (int i = 0; i < lightNode->itemCount(); i++)\r\n            {\r\n                item = lightNode->itemForIndex(static_cast<size_t>(i));\r\n                DBG_Assert(item);\r\n\r\n                const ResourceItemDescriptor &rid = item->descriptor();\r\n\r\n                if (item->needPushChange())\r\n                {\r\n                    // TODO make declarative\r\n                    if (strncmp(rid.suffix, \"attr/\", 5) == 0) { pushAttr = true; }\r\n                    if (strncmp(rid.suffix, \"cap/\", 4) == 0) { pushCap = true; }\r\n                    if (strncmp(rid.suffix, \"config/\", 7) == 0) { pushConfig = true; }\r\n                    if (strncmp(rid.suffix, \"state/\", 6) == 0) { pushState = true; }\r\n                }\r\n\r\n                if      (rid.suffix == RCapColorCapabilities) { itemColorCapabilties = item; }\r\n                else if (rid.suffix == RCapColorXyBlueX) { ibluex = item; }\r\n                else if (rid.suffix == RCapColorXyBlueY) { ibluey = item; }\r\n                else if (rid.suffix == RCapColorXyGreenX) { igreenx = item; }\r\n                else if (rid.suffix == RCapColorXyGreenY) { igreeny = item; }\r\n                else if (rid.suffix == RCapColorXyRedX) { iredx = item; }\r\n                else if (rid.suffix == RCapColorXyRedY) { iredy = item; }\r\n                else if (rid.suffix == RConfigColorXyStartupX) { isx = item; }\r\n                else if (rid.suffix == RConfigColorXyStartupY) { isy = item; }\r\n                else if (rid.suffix == RStateAlert) { ialert = item; }\r\n                else if (rid.suffix == RStateX) { ix = item; }\r\n                else if (rid.suffix == RStateY) { iy = item; }\r\n                else if (gwWebSocketNotifyAll || item->needPushChange())\r\n                {\r\n                    if      (rid.suffix == RAttrConfigId) { attr[\"configid\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RAttrId) { attr[\"id\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrLastAnnounced) { attr[\"lastannounced\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrLastSeen) { attr[\"lastseen\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrLevelMin) { attr[\"levelmin\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RAttrManufacturerName) { attr[\"manufacturername\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrModelId) { attr[\"modelid\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrName) { attr[\"name\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrPowerOnLevel) { attr[\"poweronlevel\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RAttrPowerOnCt) { attr[\"poweronct\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RAttrPowerup) { attr[\"powerup\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RAttrProductId) { attr[\"productid\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrProductName) { attr[\"productname\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrSwconfigid) {attr[\"swconfigid\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrSwVersion) { attr[\"swversion\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrType) { attr[\"type\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrUniqueId) { attr[\"uniqueid\"] = item->toString(); }\r\n                    else if (rid.suffix == RAttrZoneType) { attr[\"zonetype\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapAlertTriggerEffect) { capabilitiesAlerts = &RStateAlertValuesTriggerEffect; }\r\n                    else if (rid.suffix == RCapBriMinDimLevel) { capabilitiesBri[\"min_dim_level\"] = round(item->toNumber() / 10.0) / 100.0; }\r\n                    else if (rid.suffix == RCapColorCtComputesXy) { capabilitiesColorCt[\"computes_xy\"] = item->toBool(); }\r\n                    else if (rid.suffix == RCapColorCtMax)\r\n                    {\r\n                        attr[\"ctmax\"] = item->toNumber();\r\n                        if (item->needPushChange()) { pushAttr = true; }\r\n                        capabilitiesColorCt[\"max\"] = item->toNumber();\r\n                    }\r\n                    else if (rid.suffix == RCapColorCtMin)\r\n                    {\r\n                        attr[\"ctmin\"] = item->toNumber();\r\n                        if (item->needPushChange()) { pushAttr = true; }\r\n                        capabilitiesColorCt[\"min\"] = item->toNumber();\r\n                    }\r\n                    else if (rid.suffix == RCapColorEffects) { itemCapColorEffects = item; }\r\n                    else if (rid.suffix == RCapColorGamutType) { capabilitiesColor[\"gamut_type\"] = item->toString(); }\r\n                    else if (rid.suffix == RCapColorGradientMaxSegments) { capabilitiesColorGradient[\"max_segments\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapColorGradientPixelCount) { capabilitiesColorGradient[\"pixel_count\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapColorGradientPixelLength) { capabilitiesColorGradient[\"pixel_length\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapColorGradientStyles) { capabilitiesColorGradient[\"styles\"] = getHueGradientStyleNames(item->toNumber()); }\r\n                    else if (rid.suffix == RCapOtauFileVersion) { capabilitiesOtau[\"file_version\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapOtauImageType) { capabilitiesOtau[\"image_type\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapOtauManufacturerCode) { capabilitiesOtau[\"manufacturer_code\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RCapSleeper) { capabilities[\"sleeper\"] = true; }\r\n                    else if (rid.suffix == RCapTransitionBlock) { capabilities[\"transition_block\"] = true; }\r\n                    else if (rid.suffix == RConfigBriCoupleCt) { configBri[\"couple_ct\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigBriExecuteIfOff) { configBri[\"execute_if_off\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigBriMax) { configBri[\"max\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RConfigBriMin) { configBri[\"min\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RConfigBriOnLevel) { configBri[\"on_level\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n                    else if (rid.suffix == RConfigBriOnOffTransitiontime) { configBri[\"onoff_transitiontime\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RConfigBriMin) { configBri[\"onoff_transition_time\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RConfigBriStartup) { configBri[\"startup\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n                    else if (rid.suffix == RConfigColorCtStartup) { configColorCt[\"startup\"] = item->toNumber() == 0xFFFF ? QVariant(QLatin1String(\"previous\")) : item->toNumber(); }\r\n                    else if (rid.suffix == RConfigColorExecuteIfOff) { configColor[\"execute_if_off\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigColorGradientPixelCount) { configColorGradient[\"pixel_count\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RConfigColorGradientReversed) { configColorGradient[\"reversed\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigLocked) { config[\"locked\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigOnStartup) { configOn[\"startup\"] = item->toNumber() == 0xFF ? QVariant(QLatin1String(\"previous\")) : item->toBool(); }\r\n                    else if (rid.suffix == RConfigReversed) { config[\"reversed\"] = item->toBool(); }\r\n                    else if (rid.suffix == RConfigSpeed) { config[\"speed\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateBri) { state[\"bri\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateColorMode) { state[\"colormode\"] = item->toString(); }\r\n                    else if (rid.suffix == RStateCt) { state[\"ct\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateEffect) { state[\"effect\"] = item->toString(); }\r\n                    else if (rid.suffix == RStateGradient)\r\n                    {\r\n                        bool ok;\r\n                        QVariant var = Json::parse(item->toString(), ok);\r\n                        if (ok)\r\n                        {\r\n                            QVariantMap map = var.toMap();\r\n                            state[\"gradient\"] = map;\r\n                        }\r\n                    }\r\n                    else if (rid.suffix == RStateHue) { state[\"hue\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateLift) { state[\"lift\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateOn) { state[\"on\"] = item->toBool(); }\r\n                    else if (rid.suffix == RStateOpen) { state[\"open\"] = item->toBool(); }\r\n                    else if (rid.suffix == RStateMusicSync) { state[\"music_sync\"] = item->toBool(); }\r\n                    else if (rid.suffix == RStateReachable) { state[\"reachable\"] = item->toBool(); }\r\n                    else if (rid.suffix == RStateSat) { state[\"sat\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateSpeed) { state[\"speed\"] = item->toNumber(); }\r\n                    else if (rid.suffix == RStateTilt) { state[\"tilt\"] = item->toNumber(); }\r\n                    else\r\n                    {\r\n                        item->clearNeedPush();\r\n                    }\r\n\r\n                    // TODO make declarative\r\n                    if ((rid.suffix == RStateOn || rid.suffix == RStateReachable) &&\r\n                        item->needPushChange() && !lightNode->groups().empty())\r\n                    {\r\n                        std::vector<GroupInfo>::const_iterator g = lightNode->groups().begin();\r\n                        std::vector<GroupInfo>::const_iterator gend = lightNode->groups().end();\r\n                        for (; g != gend; ++g)\r\n                        {\r\n                            if (g->state == GroupInfo::StateInGroup)\r\n                            {\r\n                                Event e(RGroups, REventCheckGroupAnyOn, int(g->id));\r\n                                enqueueEvent(e);\r\n                            }\r\n                        }\r\n                    }\r\n                    item->clearNeedPush();\r\n                }\r\n            }\r\n            \r\n            if (itemColorCapabilties)\r\n            {\r\n                if (gwWebSocketNotifyAll || itemColorCapabilties->needPushChange())\r\n                {\r\n                    const int cc = itemColorCapabilties->toNumber();\r\n                    QStringList colorModes;\r\n\r\n                    if (cc & COLOR_CAPABILITIES_CT) colorModes.push_back(QLatin1String(\"ct\"));\r\n                    if (cc & COLOR_CAPABILITIES_COLORLOOP)\r\n                    {\r\n                        if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // colorloop and Hue special effects\r\n                        {\r\n                            colorModes.push_back(QLatin1String(\"effect\"));\r\n                            capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), true);\r\n                        }\r\n                        else if (lightNode->manufacturerCode() == VENDOR_MUELLER)\r\n                        {\r\n                            colorModes.push_back(QLatin1String(\"effect\"));\r\n                            capabilitiesColor[\"effects\"] = RStateEffectValuesMueller;\r\n                        }\r\n                        else\r\n                        {\r\n                            capabilitiesColor[\"effects\"] = RStateEffectValues;\r\n                        }\r\n                    }\r\n                    else if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // no colorloop, but Hue special effects\r\n                    {\r\n                        colorModes.push_back(QLatin1String(\"effect\"));\r\n                        capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), false);\r\n                    }\r\n                    else if (isXmasLightStrip(lightNode))\r\n                    {\r\n                        colorModes.push_back(QLatin1String(\"effect\"));\r\n                        capabilitiesColor[\"effects\"] = RStateEffectValuesXmasLightStrip;\r\n                    }\r\n                    if (!capabilitiesColorGradient.isEmpty()) colorModes.push_back(QLatin1String(\"gradient\"));\r\n                    if (cc & COLOR_CAPABILITIES_HS || cc & COLOR_CAPABILITIES_ENHANCED_HS) colorModes.push_back(QLatin1String(\"hs\"));\r\n                    if (cc & COLOR_CAPABILITIES_XY) colorModes.push_back(QLatin1String(\"xy\"));\r\n\r\n                    attr[\"colorcapabilities\"] = cc;\r\n                    if (itemColorCapabilties->needPushChange()) { pushAttr = true; }\r\n                    capabilitiesColor[\"modes\"] = colorModes;\r\n                    itemColorCapabilties->clearNeedPush();\r\n                }\r\n            }\r\n            else if (itemCapColorEffects && lightNode->manufacturerCode() == VENDOR_PHILIPS) // no color capabilities, but Hue special effects\r\n            {\r\n                capabilitiesColor[\"effects\"] = getHueEffectNames(itemCapColorEffects->toNumber(), false);\r\n            }\r\n\r\n            if (ibluex && ibluey && igreenx && igreeny && iredx && iredy)\r\n            {\r\n                if (gwWebSocketNotifyAll || ibluex->needPushChange() || ibluey->needPushChange() ||\r\n                    igreenx->needPushChange() || igreeny->needPushChange() || iredx->needPushChange() || iredy->needPushChange())\r\n                {\r\n                    QVariantList blue, green, red;\r\n\r\n                    toXy(ibluex->toNumber(), ibluey->toNumber(), blue);\r\n                    toXy(igreenx->toNumber(), igreeny->toNumber(), green);\r\n                    toXy(iredx->toNumber(), iredy->toNumber(), red);\r\n                    capabilitiesColorXy[\"blue\"] = blue;\r\n                    capabilitiesColorXy[\"green\"] = green;\r\n                    capabilitiesColorXy[\"red\"] = red;\r\n                    ibluex->clearNeedPush();\r\n                    ibluey->clearNeedPush();\r\n                    igreenx->clearNeedPush();\r\n                    igreeny->clearNeedPush();\r\n                    iredx->clearNeedPush();\r\n                    iredy->clearNeedPush();\r\n                }\r\n            }\r\n\r\n            if (isx && isy)\r\n            {\r\n                if (gwWebSocketNotifyAll || isx->needPushChange() || isy->needPushChange())\r\n                {\r\n                    double colorX = isx->toNumber();\r\n                    double colorY = isy->toNumber();\r\n\r\n                    if (colorX == 0xFFFF && colorY == 0xFFFF)\r\n                    {\r\n                        configColorXy[\"startup\"] = QLatin1String(\"previous\");\r\n                    }\r\n                    else\r\n                    {\r\n                        QVariantList xy;\r\n\r\n                        toXy(colorX, colorY, xy);\r\n                        configColorXy[\"startup\"] = xy;\r\n                    }\r\n                    isx->clearNeedPush();\r\n                    isy->clearNeedPush();\r\n                }\r\n            }\r\n\r\n            if (ialert)\r\n            {\r\n                if (gwWebSocketNotifyAll || ialert->needPushChange())\r\n                {\r\n                    state[\"alert\"] = QLatin1String(\"none\");\r\n                    ialert->clearNeedPush();\r\n                }\r\n            }\r\n\r\n            if (ix && iy)\r\n            {\r\n                if (gwWebSocketNotifyAll || ix->needPushChange() || iy->needPushChange())\r\n                {\r\n                    QVariantList xy;\r\n\r\n                    toXy(ix->toNumber(), iy->toNumber(), xy);\r\n                    state[\"xy\"] = xy;\r\n                    ix->clearNeedPush();\r\n                    iy->clearNeedPush();\r\n                }\r\n            }\r\n\r\n            if (pushAttr)\r\n            {\r\n                QVariantMap map;\r\n                map[\"t\"] = QLatin1String(\"event\");\r\n                map[\"e\"] = QLatin1String(\"changed\");\r\n                map[\"r\"] = QLatin1String(\"lights\");\r\n                map[\"id\"] = e.id();\r\n                map[\"uniqueid\"] = lightNode->uniqueId();\r\n                map[\"attr\"] = attr;\r\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n                updateLightEtag(lightNode);\r\n                plugin->saveDatabaseItems |= DB_LIGHTS;\r\n                plugin->queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            if (!capabilitiesBri.isEmpty()) capabilities[\"bri\"] = capabilitiesBri;\r\n            if (!capabilitiesColorCt.isEmpty()) capabilitiesColor[\"ct\"] = capabilitiesColorCt;\r\n            if (!capabilitiesColorGradient.isEmpty()) capabilitiesColor[\"gradient\"] = capabilitiesColorGradient;\r\n            if (!capabilitiesColorXy.isEmpty()) capabilitiesColor[\"xy\"] = capabilitiesColorXy;\r\n            if (!capabilitiesColor.isEmpty()) capabilities[\"color\"] = capabilitiesColor;\r\n            if (!capabilitiesOtau.isEmpty()) capabilities[\"otau\"] = capabilitiesOtau;\r\n            if (pushCap)\r\n            {\r\n                if (ialert && gwWebSocketNotifyAll)\r\n                {\r\n                    capabilities[\"alerts\"] = *capabilitiesAlerts;\r\n                }\r\n\r\n                QVariantMap map;\r\n                map[\"t\"] = QLatin1String(\"event\");\r\n                map[\"e\"] = QLatin1String(\"changed\");\r\n                map[\"r\"] = QLatin1String(\"lights\");\r\n                map[\"id\"] = e.id();\r\n                map[\"uniqueid\"] = lightNode->uniqueId();\r\n                map[\"capabilities\"] = capabilities;\r\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n                updateLightEtag(lightNode);\r\n                plugin->saveDatabaseItems |= DB_LIGHTS;\r\n                plugin->queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            if (!configBri.isEmpty()) config[\"bri\"] = configBri;\r\n            if (!configColorCt.isEmpty()) configColor[\"ct\"] = configColorCt;\r\n            if (!configColorGradient.isEmpty()) configColor[\"gradient\"] = configColorGradient;\r\n            if (!configColorXy.isEmpty()) configColor[\"xy\"] = configColorXy;\r\n            if (!configColor.isEmpty()) config[\"color\"] = configColor;\r\n            if (!configOn.isEmpty()) config[\"on\"] = configOn;\r\n            if (pushConfig)\r\n            {\r\n                QVariantMap map;\r\n                map[\"t\"] = QLatin1String(\"event\");\r\n                map[\"e\"] = QLatin1String(\"changed\");\r\n                map[\"r\"] = QLatin1String(\"lights\");\r\n                map[\"id\"] = e.id();\r\n                map[\"uniqueid\"] = lightNode->uniqueId();\r\n                map[\"config\"] = config;\r\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n                updateLightEtag(lightNode);\r\n                plugin->saveDatabaseItems |= DB_LIGHTS;\r\n                plugin->queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            if (pushState)\r\n            {\r\n                QVariantMap map;\r\n                map[\"t\"] = QLatin1String(\"event\");\r\n                map[\"e\"] = QLatin1String(\"changed\");\r\n                map[\"r\"] = QLatin1String(\"lights\");\r\n                map[\"id\"] = e.id();\r\n                map[\"uniqueid\"] = lightNode->uniqueId();\r\n                map[\"state\"] = state;\r\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n                updateLightEtag(lightNode);\r\n                plugin->saveDatabaseItems |= DB_LIGHTS;\r\n                plugin->queSaveDb(DB_LIGHTS, DB_SHORT_SAVE_DELAY);\r\n            }\r\n        }\r\n    }\r\n    else if (e.what() == REventAdded)\r\n    {\r\n        QVariantMap res;\r\n        res[\"name\"] = lightNode->name();\r\n        searchLightsResult[lightNode->id()] = res;\r\n\r\n        QVariantMap lmap;\r\n        QHttpRequestHeader hdr;  // dummy\r\n        QStringList path;  // dummy\r\n        ApiRequest req(hdr, path, nullptr, QLatin1String(\"\")); // dummy\r\n        req.mode = ApiModeNormal;\r\n        lightToMap(req, lightNode, lmap);\r\n\r\n        QVariantMap map;\r\n        map[\"t\"] = QLatin1String(\"event\");\r\n        map[\"e\"] = QLatin1String(\"added\");\r\n        map[\"r\"] = QLatin1String(\"lights\");\r\n        map[\"id\"] = e.id();\r\n        map[\"uniqueid\"] = lightNode->uniqueId();\r\n        map[\"light\"] = lmap;\r\n\r\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n    }\r\n    else if (e.what() == REventDeleted)\r\n    {\r\n        QVariantMap map;\r\n        map[\"t\"] = QLatin1String(\"event\");\r\n        map[\"e\"] = QLatin1String(\"deleted\");\r\n        map[\"r\"] = QLatin1String(\"lights\");\r\n        map[\"id\"] = e.id();\r\n        map[\"uniqueid\"] = lightNode->uniqueId();\r\n\r\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\r\n    }\r\n}\r\n\r\n/*! Starts the search for new lights.\r\n */\r\nvoid DeRestPluginPrivate::startSearchLights()\r\n{\r\n    if (searchLightsState == SearchLightsIdle || searchLightsState == SearchLightsDone)\r\n    {\r\n        pollNodes.clear();\r\n        searchLightsResult.clear();\r\n        lastLightsScan = QDateTime::currentDateTimeUtc().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n        QTimer::singleShot(1000, this, SLOT(searchLightsTimerFired()));\r\n        searchLightsState = SearchLightsActive;\r\n    }\r\n    else\r\n    {\r\n        DBG_Assert(searchLightsState == SearchLightsActive);\r\n    }\r\n\r\n    searchLightsTimeout = gwNetworkOpenDuration;\r\n    setPermitJoinDuration(searchLightsTimeout);\r\n}\r\n\r\n/*! Handler for search lights active state.\r\n */\r\nvoid DeRestPluginPrivate::searchLightsTimerFired()\r\n{\r\n    if (gwPermitJoinDuration == 0)\r\n    {\r\n        searchLightsTimeout = 0; // done\r\n    }\r\n\r\n    if (searchLightsTimeout > 0)\r\n    {\r\n        searchLightsTimeout--;\r\n        QTimer::singleShot(1000, this, SLOT(searchLightsTimerFired()));\r\n    }\r\n\r\n    if (searchLightsTimeout == 0)\r\n    {\r\n        searchLightsState = SearchLightsDone;\r\n    }\r\n}\r\n"
        },
        {
          "name": "rest_node_base.cpp",
          "type": "blob",
          "size": 10.2568359375,
          "content": "/*\n * Copyright (c) 2016-2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QTime>\n#include \"de_web_plugin_private.h\"\n\n/*! Constructor.\n */\nRestNodeBase::RestNodeBase() :\n    m_node(0),\n    m_mgmtBindSupported(true),\n    m_needSaveDatabase(false),\n    m_read(0),\n    m_lastRead(0),\n    m_lastAttributeReportBind(0)\n{\n    QTime t = QTime::currentTime();\n\n    for (int i = 0; i < 16; i++)\n    {\n        m_lastRead.push_back(0);\n        m_nextReadTime.push_back(t);\n    }\n}\n\n/*! Deconstructor.\n */\nRestNodeBase::~RestNodeBase()\n{\n}\n\n/*! Returns the core node object.\n */\ndeCONZ::Node *RestNodeBase::node()\n{\n    return m_node;\n}\n\n/*! Sets the core node object.\n    \\param node the core node\n */\nvoid RestNodeBase::setNode(deCONZ::Node *node)\n{\n    m_node = node;\n}\n\n/*! Returns the modifiable address.\n */\ndeCONZ::Address &RestNodeBase::address()\n{\n    return m_addr;\n}\n\n/*! Returns the const address.\n */\nconst deCONZ::Address &RestNodeBase::address() const\n{\n    return m_addr;\n}\n\n/*! Returns true if the node is available.\n */\nbool RestNodeBase::isAvailable() const\n{\n    return false;\n}\n\n/*! Returns if the data needs to be saved to database.\n */\nbool RestNodeBase::needSaveDatabase() const\n{\n    return m_needSaveDatabase;\n}\n\n/*! Sets if the data needs to be saved to database.\n    \\param needSave true if needs to be saved\n */\nvoid RestNodeBase::setNeedSaveDatabase(bool needSave)\n{\n    m_needSaveDatabase = needSave;\n}\n\n/*! Returns the unique identifier of the node.\n */\nconst QString &RestNodeBase::id() const\n{\n    const Resource *r = dynamic_cast<const Resource*>(this);\n    const ResourceItem *item = r ? r->item(RAttrId) : nullptr;\n    if (item)\n    {\n        return item->toString();\n    }\n    return m_id;\n}\n\n/*! Sets the identifier of the node.\n    \\param id the unique identifier\n */\nvoid RestNodeBase::setId(const QString &id)\n{\n    Resource *r = dynamic_cast<Resource*>(this);\n    ResourceItem *item = r ? r->item(RAttrId) : nullptr;\n    if (item)\n    {\n        item->setValue(id);\n    }\n    m_id = id;\n}\n\n/*! Returns the nodes unique Id.\n    The MAC address of the device with a unique endpoint id in the form: AA:BB:CC:DD:EE:FF:00:11-XX\n */\nconst QString &RestNodeBase::uniqueId() const\n{\n    const Resource *r = dynamic_cast<const Resource*>(this);\n    const ResourceItem *item = r ? r->item(RAttrUniqueId) : 0;\n    if (item)\n    {\n        return item->toString();\n    }\n    return m_uid;\n}\n\n/*! Sets the sensor unique Id.\n    The MAC address of the device with a unique endpoint id in the form: AA:BB:CC:DD:EE:FF:00:11-XX\n    \\param uid the sensor unique Id\n */\nvoid RestNodeBase::setUniqueId(const QString &uid)\n{\n    Resource *r = dynamic_cast<Resource*>(this);\n    ResourceItem *item = r ? r->addItem(DataTypeString, RAttrUniqueId) : 0;\n    if (item)\n    {\n        item->setValue(uid);\n    }\n    m_uid = uid;\n}\n\n/*! Check if some data must be queried from the node.\n    \\param readFlags or combined bitmap of READ_* values\n    \\return true if every flag in readFlags is set\n*/\nbool RestNodeBase::mustRead(uint32_t readFlags)\n{\n    if ((m_read & readFlags) == readFlags)\n    {\n        return true;\n    }\n\n    return false;\n}\n\n/*! Enables all flags given in \\p readFlags in the read set.\n    \\param readFlags or combined bitmap of READ_* values\n */\nvoid RestNodeBase::enableRead(uint32_t readFlags)\n{\n    m_read |= readFlags;\n}\n\n/*! Clears all flags given in \\p readFlags in the read set.\n    \\param readFlags or combined bitmap of READ_* values\n */\nvoid RestNodeBase::clearRead(uint32_t readFlags)\n{\n    m_read &= ~readFlags;\n}\n\n/*! Returns the time than the next auto reading is queued.\n    \\param item the item to read\n */\nconst QTime &RestNodeBase::nextReadTime(uint32_t item) const\n{\n    for (size_t i = 0; i < m_nextReadTime.size(); i++)\n    {\n        if ((1u << i) == item)\n        {\n            return m_nextReadTime[i];\n        }\n    }\n    Q_ASSERT(0 || \"m_nextReadTime[] too small\");\n    return m_invalidTime;\n}\n\n/*! Sets the time than the next auto reading should be queued.\n    \\param item the item to read\n    \\param time the time for reading\n */\nvoid RestNodeBase::setNextReadTime(uint32_t item, const QTime &time)\n{\n    for (size_t i = 0; i < m_nextReadTime.size(); i++)\n    {\n        if ((1u << i) == item)\n        {\n            m_nextReadTime[i] = time;\n            return;\n        }\n    }\n    Q_ASSERT(0 || \"m_nextReadTime[] too small\");\n}\n\n/*! Returns the value of the idleTotalCounter than the last reading happend.\n    \\param item the item to read\n */\nint RestNodeBase::lastRead(uint32_t item) const\n{\n    for (size_t i = 0; i < m_lastRead.size(); i++)\n    {\n        if ((1u << i) == item)\n        {\n            return m_lastRead[i];\n        }\n    }\n    Q_ASSERT(0 || \"m_lastRead[] too small\");\n    return 0;\n}\n\n/*! Sets the last read counter.\n    \\param item the item to read\n    \\param lastRead copy of idleTotalCounter\n */\nvoid RestNodeBase::setLastRead(uint32_t item, int lastRead)\n{\n    for (size_t i = 0; i < m_lastRead.size(); i++)\n    {\n        if ((1u << i) == item)\n        {\n            m_lastRead[i] = lastRead;\n            return;\n        }\n    }\n    Q_ASSERT(0 || \"m_lastRead[] too small\");\n}\n\n/*! Returns the value of the idleTotalCounter than the last attribute report binding was done.\n */\nint RestNodeBase::lastAttributeReportBind() const\n{\n    return m_lastAttributeReportBind;\n}\n\n/*! Sets idleTotalCounter of last attribute report binding.\n    \\param lastBind copy of idleTotalCounter\n */\nvoid RestNodeBase::setLastAttributeReportBind(int lastBind)\n{\n    m_lastAttributeReportBind = lastBind;\n}\n\n/*! Returns true if mgmt bind request/response are supported.\n */\nbool RestNodeBase::mgmtBindSupported() const\n{\n    return m_mgmtBindSupported;\n}\n\n/*! Sets the query binding table supported flag;\n    \\param supported - query binding table supported flag\n */\nvoid RestNodeBase::setMgmtBindSupported(bool supported)\n{\n    m_mgmtBindSupported = supported;\n}\n\n/*! Sets a numeric ZCL attribute value.\n\n    A timestamp will begenerated automatically.\n    \\param updateType - specifies if value came by ZCL attribute read or report command\n    \\param clusterId - the cluster id of the value\n    \\param attributeId - the attribute id of the value\n    \\param value - the value data\n */\nvoid RestNodeBase::setZclValue(NodeValue::UpdateType updateType, quint8 endpoint, quint16 clusterId, quint16 attributeId, const deCONZ::NumericUnion &value)\n{\n    QDateTime now = QDateTime::currentDateTime();\n    std::vector<NodeValue>::iterator i = m_values.begin();\n    std::vector<NodeValue>::iterator end = m_values.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->endpoint == endpoint &&\n            i->clusterId == clusterId &&\n            i->attributeId == attributeId)\n        {\n            i->updateType = updateType;\n            i->value = value;\n            i->timestamp = now;\n\n            if (updateType == NodeValue::UpdateByZclReport)\n            {\n                i->timestampLastReport = now;\n            }\n\n            if (DBG_IsEnabled(DBG_INFO_L2))\n            {\n                DBG_Printf(DBG_INFO_L2, \"0x%016llX: update ZCL value 0x%02X/0x%04X/0x%04X after %lld s\\n\", address().ext(), endpoint, clusterId, attributeId, i->timestamp.secsTo(now));\n            }\n            return;\n        }\n    }\n\n    NodeValue val;\n    val.timestamp = now;\n    if (updateType == NodeValue::UpdateByZclReport)\n    {\n        val.timestampLastReport = now;\n    }\n    val.endpoint = endpoint;\n    val.clusterId = clusterId;\n    val.attributeId = attributeId;\n    val.updateType = updateType;\n    val.value = value;\n\n    DBG_Printf(DBG_INFO_L2, \"0x%016llX: added ZCL value 0x%02X/0x%04X/0x%04X\\n\", address().ext(), endpoint, clusterId, attributeId);\n\n    m_values.push_back(val);\n}\n\n/*! Returns a numeric ZCL attribute value.\n\n    If the value couldn't be found the NodeValue::timestamp field holds a invalid QTime.\n    \\param clusterId - the cluster id of the value\n    \\param attributeId - the attribute id of the value\n    \\param endpoint - the endpoint of the value, optional: 0 means no check\n */\nconst NodeValue &RestNodeBase::getZclValue(quint16 clusterId, quint16 attributeId, quint8 endpoint) const\n{\n    std::vector<NodeValue>::const_iterator i = m_values.begin();\n    std::vector<NodeValue>::const_iterator end = m_values.end();\n\n    for (; i != end; ++i)\n    {\n        if (endpoint > 0 && i->endpoint != endpoint)\n        {\n            continue;\n        }\n\n        if (i->clusterId == clusterId &&\n            i->attributeId == attributeId)\n        {\n            return *i;\n        }\n    }\n\n    return m_invalidValue;\n}\n\n/*! Returns a numeric ZCL attribute value.\n\n    If the value couldn't be found the NodeValue::timestamp field holds a invalid QTime.\n    \\param clusterId - the cluster id of the value\n    \\param attributeId - the attribute id of the value\n    \\param endpoint - the endpoint of the value, optional: 0 means no check\n */\nNodeValue &RestNodeBase::getZclValue(quint16 clusterId, quint16 attributeId, quint8 endpoint)\n{\n    std::vector<NodeValue>::iterator i = m_values.begin();\n    std::vector<NodeValue>::iterator end = m_values.end();\n\n    for (; i != end; ++i)\n    {\n        if (endpoint > 0 && i->endpoint != endpoint)\n        {\n            continue;\n        }\n\n        if (i->clusterId == clusterId &&\n            i->attributeId == attributeId)\n        {\n            return *i;\n        }\n    }\n\n    return m_invalidValue;\n}\n\n/*! Returns ZCL attribute values.\n */\nstd::vector<NodeValue> &RestNodeBase::zclValues()\n{\n    return m_values;\n}\n\n/*! Returns ZCL attribute values.\n */\nconst std::vector<NodeValue> &RestNodeBase::zclValues() const\n{\n    return m_values;\n}\n\n/*! Returns timestamp of last rx. */\nconst QDateTime &RestNodeBase::lastRx() const\n{\n    return m_lastRx;\n}\n\n/*! Mark received command. */\nvoid RestNodeBase::rx()\n{\n    m_lastRx = QDateTime::currentDateTime();\n}\n\nconst deCONZ::SimpleDescriptor *getSimpleDescriptor(const deCONZ::Node *node, quint8 ep)\n{\n    if (!node)\n    {\n        return nullptr;\n    }\n\n    const auto i = std::find_if(node->simpleDescriptors().cbegin(), node->simpleDescriptors().cend(),\n                                [ep](const auto &sd){ return sd.endpoint() == ep; });\n\n    if (i != node->simpleDescriptors().cend())\n    {\n        return &*i;\n    }\n\n    return nullptr;\n}\n"
        },
        {
          "name": "rest_node_base.h",
          "type": "blob",
          "size": 3.3134765625,
          "content": "/*\n * Copyright (c) 2017-2020 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef REST_NODE_BASE_H\n#define REST_NODE_BASE_H\n\n#include <QDateTime>\n#include <deconz.h>\n\n/*! \\class NodeValue\n\n    Holds bookkeeping data for numeric ZCL values.\n */\nclass NodeValue\n{\npublic:\n    enum UpdateType { UpdateInvalid, UpdateByZclReport, UpdateByZclRead };\n\n    NodeValue() :\n        updateType(UpdateInvalid),\n        endpoint(0),\n        clusterId(0),\n        attributeId(0),\n        minInterval(0),\n        maxInterval(0),\n        zclSeqNum(0)\n    {\n        value.u64 = 0;\n    }\n    bool isValid() const { return updateType != UpdateInvalid; }\n\n    QDateTime timestamp;\n    QDateTime timestampLastReport;\n    QDateTime timestampLastReadRequest;\n    QDateTime timestampLastConfigured;\n    UpdateType updateType;\n    quint8 endpoint;\n    quint16 clusterId;\n    quint16 attributeId;\n    quint16 minInterval;\n    quint16 maxInterval;\n    quint8 zclSeqNum; // sequence number for configure reporting\n    deCONZ::NumericUnion value;\n};\n\n\n/*! \\class RestNodeBase\n\n    The base class for all device representations.\n */\nclass RestNodeBase\n{\npublic:\n    RestNodeBase();\n    virtual ~RestNodeBase();\n    deCONZ::Node *node();\n    void setNode(deCONZ::Node *node);\n    deCONZ::Address &address();\n    const deCONZ::Address &address() const;\n    virtual bool isAvailable() const;\n    bool needSaveDatabase() const;\n    void setNeedSaveDatabase(bool needSave);\n    const QString &id() const;\n    void setId(const QString &id);\n    const QString &uniqueId() const;\n    void setUniqueId(const QString &uid);\n    bool mustRead(uint32_t readFlags);\n    void enableRead(uint32_t readFlags);\n    void clearRead(uint32_t readFlags);\n    const QTime &nextReadTime(uint32_t item) const;\n    void setNextReadTime(uint32_t item, const QTime &time);\n    int lastRead(uint32_t item) const;\n    void setLastRead(uint32_t item, int lastRead);\n    int lastAttributeReportBind() const;\n    void setLastAttributeReportBind(int lastBind);\n    bool mgmtBindSupported() const;\n    void setMgmtBindSupported(bool supported);\n    void setZclValue(NodeValue::UpdateType updateType, quint8 endpoint, quint16 clusterId, quint16 attributeId, const deCONZ::NumericUnion &value);\n    const NodeValue &getZclValue(quint16 clusterId, quint16 attributeId, quint8 endpoint = 0) const;\n    NodeValue &getZclValue(quint16 clusterId, quint16 attributeId, quint8 endpoint = 0);\n    std::vector<NodeValue> &zclValues();\n    const std::vector<NodeValue> &zclValues() const;\n    const QDateTime &lastRx() const;\n    void rx();\n\nprotected:\n    deCONZ::Node *m_node;\nprivate:\n    deCONZ::Address m_addr;\n    QString m_id;\n    QString m_uid;\n    bool m_mgmtBindSupported;\n    bool m_needSaveDatabase;\n\n    uint32_t m_read; // bitmap of READ_* flags\n    std::vector<int> m_lastRead; // copy of idleTotalCounter\n    int m_lastAttributeReportBind; // copy of idleTotalCounter\n    std::vector<QTime> m_nextReadTime;\n    QDateTime m_lastRx;\n\n    NodeValue m_invalidValue;\n    std::vector<NodeValue> m_values;\n    QTime m_invalidTime;\n};\n\nconst deCONZ::SimpleDescriptor *getSimpleDescriptor(const deCONZ::Node *node, quint8 ep);\n\n#endif // REST_NODE_BASE_H\n"
        },
        {
          "name": "rest_resourcelinks.cpp",
          "type": "blob",
          "size": 10.8115234375,
          "content": "/*\n * Copyright (c) 2017 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n#include <QTextCodec>\n#include <QTcpSocket>\n#include <QVariantMap>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"json.h\"\n\n/*! Resourcelinks REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleResourcelinksApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.path[2] != QLatin1String(\"resourcelinks\"))\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // GET /api/<apikey>/resourcelinks\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\n    {\n        return getAllResourcelinks(req, rsp);\n    }\n    // GET /api/<apikey>/resourcelinks/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\"))\n    {\n        return getResourcelinks(req, rsp);\n    }\n    // POST /api/<apikey>/resourcelinks\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"POST\"))\n    {\n        return createResourcelinks(req, rsp);\n    }\n    // PUT, PATCH /api/<apikey>/resourcelinks/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\"))\n    {\n        return updateResourcelinks(req, rsp);\n    }\n    // DELETE /api/<apikey>/resourcelinks/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\"))\n    {\n        return deleteResourcelinks(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! GET /api/<apikey>/resourcelinks\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getAllResourcelinks(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n    for (const Resourcelinks &rl : resourcelinks)\n    {\n        if (rl.state == Resourcelinks::StateNormal)\n        {\n            rsp.map[rl.id] = rl.data;\n        }\n    }\n\n    if (rsp.map.keys().isEmpty())\n    {\n        rsp.str = \"{}\"; // empty\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/resourcelinks/<id>\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getResourcelinks(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n    const QString &id = req.path[3];\n    rsp.httpStatus = HttpStatusOk;\n\n    for (const Resourcelinks &rl : resourcelinks)\n    {\n        if (id == rl.id && rl.state == Resourcelinks::StateNormal)\n        {\n            rsp.map = rl.data;\n            return REQ_READY_SEND;\n        }\n    }\n\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/resourcelinks/%1\").arg(id), QString(\"resource, /resourcelinks/%1, not available\").arg(id)));\n    rsp.httpStatus = HttpStatusNotFound;\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/resourcelinks\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::createResourcelinks(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    bool ok;\n    int errors = 0;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    Resourcelinks rl;\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/resourcelinks\"), QString(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    userActivity();\n\n    //check required parameters\n    {\n        QStringList required({\"name\", \"classid\", \"links\"});\n\n        for (const QString &param : required)\n        {\n            if (!map.contains(param))\n            {\n                rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/resourcelinks/%1\").arg(param), QString(\"invalid/missing parameters in body\")));\n                rsp.httpStatus = HttpStatusBadRequest;\n                errors++;\n            }\n        }\n\n        if (errors > 0)\n        {\n            return REQ_READY_SEND;\n        }\n    }\n\n    //check available and valid parameters\n    {\n        QVariantMap available;\n        available[\"name\"] = static_cast<uint>(QVariant::String);\n        available[\"description\"] = static_cast<uint>(QVariant::String);\n        available[\"type\"] = static_cast<uint>(QVariant::String);\n        available[\"classid\"] = static_cast<uint>(QVariant::Double);\n        available[\"links\"] = static_cast<uint>(QVariant::List);\n        available[\"recycle\"] = static_cast<uint>(QVariant::Bool);\n        QStringList availableKeys = available.keys();\n\n        for (const QString &param : map.keys())\n        {\n            if (!availableKeys.contains(param))\n            {\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/resourcelinks/%1\").arg(param), QString(\"parameter, %1, not available\").arg(param)));\n                rsp.httpStatus = HttpStatusBadRequest;\n                errors++;\n            }\n            else if (available[param].toUInt() != map[param].type())\n            {\n                DBG_Printf(DBG_INFO, \"%d -- %d\\n\", available[param].toUInt(), map[param].type());\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/resourcelinks/%1\").arg(param), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\n                rsp.httpStatus = HttpStatusBadRequest;\n                errors++;\n            }\n        }\n\n        if (errors > 0)\n        {\n            return REQ_READY_SEND;\n        }\n    }\n\n    // generate id\n    int id = 1;\n    rl.id.setNum(id);\n    while (std::find_if(resourcelinks.begin(), resourcelinks.end(),\n                        [&rl](Resourcelinks &rl2) { return rl2.id == rl.id; }) != resourcelinks.end())\n    {\n        id++;\n        rl.id.setNum(id);\n    }\n\n    rl.setNeedSaveDatabase(true);\n    rl.data = map;\n    rl.data[\"type\"]  = QLatin1String(\"Link\");\n    rl.data[\"owner\"] = req.path[1];\n\n    if (!rl.data.contains(QLatin1String(\"description\")) || rl.data[\"description\"].toString().isNull())\n    {\n        rl.data[\"description\"] = QLatin1String(\"\");\n    }\n\n    if (!rl.data.contains(QLatin1String(\"recycle\")))\n    {\n        rl.data[\"recycle\"] = false;\n    }\n\n    resourcelinks.push_back(rl);\n    queSaveDb(DB_RESOURCELINKS, DB_SHORT_SAVE_DELAY);\n\n    QVariantMap rspItemState;\n    QVariantMap rspItem;\n\n    rspItemState[\"id\"] = rl.id;\n    rspItem[\"success\"] = rspItemState;\n    rsp.list.append(rspItem);\n\n    return REQ_READY_SEND;\n}\n\n/*! PUT,PATCH /api/<apikey>/resourcelinks/<id>\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::updateResourcelinks(const ApiRequest &req, ApiResponse &rsp)\n{\n    bool ok;\n    int errors = 0;\n    DBG_Assert(req.path.size() == 4);\n    const QString &id = req.path[3];\n    rsp.httpStatus = HttpStatusOk;\n    Resourcelinks *rl = nullptr;\n\n    for (Resourcelinks &r : resourcelinks)\n    {\n        if (id == r.id && r.state == Resourcelinks::StateNormal)\n        {\n            rl = &r;\n            break;\n        }\n    }\n\n    if (!rl)\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/resourcelinks/%1\").arg(id), QString(\"resource, /resourcelinks/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/resourcelinks\"), QString(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    userActivity();\n\n    //check available and valid parameters\n    {\n        QVariantMap available;\n        available[\"name\"] = static_cast<uint>(QVariant::String);\n        available[\"description\"] = static_cast<uint>(QVariant::String);\n        available[\"classid\"] = static_cast<uint>(QVariant::Double);\n        available[\"links\"] = static_cast<uint>(QVariant::List);\n        available[\"recycle\"] = static_cast<uint>(QVariant::Bool);\n        QStringList availableKeys = available.keys();\n\n        for (const QString &param : map.keys())\n        {\n            if (!availableKeys.contains(param))\n            {\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/resourcelinks/%1\").arg(param), QString(\"parameter, %1, not available\").arg(param)));\n                rsp.httpStatus = HttpStatusBadRequest;\n                errors++;\n            }\n            else if (available[param].toUInt() != map[param].type())\n            {\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/resourcelinks/%1\").arg(param), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\n                rsp.httpStatus = HttpStatusBadRequest;\n                errors++;\n            }\n        }\n\n        if (errors > 0)\n        {\n            return REQ_READY_SEND;\n        }\n    }\n\n    for (const QString &param : map.keys())\n    {\n        rl->data[param] = map[param];\n        QVariantMap rspItemState;\n        QVariantMap rspItem;\n        rspItemState[QString(\"/resourcelinks/%1/%2\").arg(id).arg(param)] = map[param];\n        rspItem[\"success\"] = rspItemState;\n        rsp.list.push_back(rspItem);\n    }\n\n    if (!rl->data.contains(QLatin1String(\"description\")) || rl->data[\"description\"].toString().isNull())\n    {\n        rl->data[\"description\"] = QLatin1String(\"\");\n    }\n\n    rl->setNeedSaveDatabase(true);\n    queSaveDb(DB_RESOURCELINKS, DB_SHORT_SAVE_DELAY);\n\n    if (rsp.list.empty())\n    {\n        rsp.str = QLatin1String(\"[]\"); // empty\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! DELETE /api/<apikey>/resourcelinks/<id>\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::deleteResourcelinks(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n    const QString &id = req.path[3];\n    rsp.httpStatus = HttpStatusOk;\n\n    for (Resourcelinks &rl : resourcelinks)\n    {\n        if (id == rl.id && rl.state == Resourcelinks::StateNormal)\n        {\n            rl.state = Resourcelinks::StateDeleted;\n            rl.setNeedSaveDatabase(true);\n            queSaveDb(DB_RESOURCELINKS, DB_SHORT_SAVE_DELAY);\n\n            QVariantMap rspItem;\n            rspItem[\"success\"] = QString(\"/resourcelinks/%1 deleted.\").arg(id);\n            rsp.list.append(rspItem);\n            return REQ_READY_SEND;\n        }\n    }\n\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/resourcelinks/%1\").arg(id), QString(\"resource, /resourcelinks/%1, not available\").arg(id)));\n    rsp.httpStatus = HttpStatusNotFound;\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rest_rules.cpp",
          "type": "blob",
          "size": 47.841796875,
          "content": "/*\r\n * Copyright (c) 2016-2021 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QBuffer>\r\n#include <QString>\r\n#include <QVariantMap>\r\n#include <QRegExp>\r\n#include <QStringBuilder>\r\n#include <QNetworkAccessManager>\r\n#include <QNetworkReply>\r\n#include \"de_web_plugin.h\"\r\n#include \"de_web_plugin_private.h\"\r\n#include \"json.h\"\r\n#include \"rest_alarmsystems.h\"\r\n\r\n#define MAX_RULES_COUNT 500\r\n#define FAST_RULE_CHECK_INTERVAL_MS 10\r\n#define NORMAL_RULE_CHECK_INTERVAL_MS 100\r\n\r\n/*! Rules REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleRulesApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    // GET /api/<apikey>/rules\r\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\")  && (req.path[2] == \"rules\"))\r\n    {\r\n        return getAllRules(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/rules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\") && (req.path[2] == \"rules\"))\r\n    {\r\n        return getRule(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/rules\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"POST\") && (req.path[2] == \"rules\"))\r\n    {\r\n        return createRule(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/rules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\") && (req.path[2] == \"rules\"))\r\n    {\r\n        return updateRule(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/rules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\") && (req.path[2] == \"rules\"))\r\n    {\r\n        return deleteRule(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n\r\n/*! GET /api/<apikey>/rules\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getAllRules(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req)\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    auto i = rules.cbegin();\r\n    const auto end = rules.cend();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        // ignore deleted rules\r\n        if (i->state() == Rule::StateDeleted)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        QVariantMap rule;\r\n\r\n        auto c = i->conditions().cbegin();\r\n        const auto cend = i->conditions().cend();\r\n\r\n        QVariantList conditions;\r\n\r\n        for (; c != cend; ++c)\r\n        {\r\n            QVariantMap condition;\r\n            condition[\"address\"] = c->address();\r\n            condition[\"operator\"] = c->ooperator();\r\n            if (c->value().isValid())\r\n            {\r\n                condition[\"value\"] = c->value().toString();\r\n            }\r\n            conditions.append(condition);\r\n        }\r\n\r\n        auto a = i->actions().cbegin();\r\n        const auto aend = i->actions().cend();\r\n\r\n        QVariantList actions;\r\n\r\n        for (; a != aend; ++a)\r\n        {\r\n            QVariantMap action;\r\n            action[\"address\"] = a->address();\r\n            action[\"method\"] = a->method();\r\n\r\n            //parse body\r\n            bool ok;\r\n            QVariant body = Json::parse(a->body(), ok);\r\n\r\n            if (ok)\r\n            {\r\n                action[\"body\"] = body;\r\n                actions.append(action);\r\n            }\r\n        }\r\n\r\n        rule[\"name\"] = i->name();\r\n        if (i->lastTriggered().isValid())\r\n        {\r\n            rule[\"lasttriggered\"] = i->lastTriggered().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n        }\r\n        else\r\n        {\r\n            rule[\"lasttriggered\"] = QLatin1String(\"none\");\r\n        }\r\n        rule[\"created\"] = i->creationtime();\r\n        rule[\"timestriggered\"] = i->timesTriggered();\r\n        rule[\"owner\"] = i->owner();\r\n        rule[\"status\"] = i->status();\r\n        rule[\"conditions\"] = conditions;\r\n        rule[\"actions\"] = actions;\r\n        rule[\"periodic\"] = static_cast<double>(i->triggerPeriodic());\r\n\r\n        QString etag = i->etag;\r\n        etag.remove('\"'); // no quotes allowed in string\r\n        rule[\"etag\"] = etag;\r\n\r\n        rsp.map[i->id()] = rule;\r\n    }\r\n\r\n    if (rsp.map.isEmpty())\r\n    {\r\n        rsp.str = \"{}\"; // return empty object\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Put all parameters in a map for later json serialization.\r\n    \\return true - on success\r\n            false - on error\r\n */\r\nbool DeRestPluginPrivate::ruleToMap(const Rule *rule, QVariantMap &map)\r\n{\r\n    if (!rule)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    auto c = rule->conditions().cbegin();\r\n    const auto c_end = rule->conditions().cend();\r\n\r\n    QVariantList conditions;\r\n\r\n    for (; c != c_end; ++c)\r\n    {\r\n        QVariantMap condition;\r\n        condition[\"address\"] = c->address();\r\n        condition[\"operator\"] = c->ooperator();\r\n        if (c->value().isValid())\r\n        {\r\n            condition[\"value\"] = c->value().toString();\r\n        }\r\n        conditions.append(condition);\r\n    }\r\n\r\n    auto a = rule->actions().cbegin();\r\n    const auto a_end = rule->actions().cend();\r\n\r\n    QVariantList actions;\r\n\r\n    for (; a != a_end; ++a)\r\n    {\r\n        QVariantMap action;\r\n        action[\"address\"] = a->address();\r\n        action[\"method\"] = a->method();\r\n\r\n        //parse body\r\n        bool ok;\r\n        QVariant body = Json::parse(a->body(), ok);\r\n        QVariantMap bodymap = body.toMap();\r\n\r\n        auto b = bodymap.cbegin();\r\n        const auto b_end = bodymap.cend();\r\n\r\n        QVariantMap resultmap;\r\n\r\n        for (; b != b_end; ++b)\r\n        {\r\n            resultmap[b.key()] = b.value();\r\n        }\r\n\r\n        action[\"body\"] = resultmap;\r\n        actions.append(action);\r\n    }\r\n\r\n    map[\"actions\"] = actions;\r\n    map[\"conditions\"] = conditions;\r\n    map[\"created\"] = rule->creationtime();\r\n    if (rule->lastTriggered().isValid())\r\n    {\r\n        map[\"lasttriggered\"] = rule->lastTriggered().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n    }\r\n    else\r\n    {\r\n        map[\"lasttriggered\"] = QLatin1String(\"none\");\r\n    }\r\n    map[\"name\"] = rule->name();\r\n    map[\"owner\"] = rule->owner();\r\n    map[\"periodic\"] = rule->triggerPeriodic();\r\n    map[\"status\"] = rule->status();\r\n    map[\"timestriggered\"] = rule->timesTriggered();\r\n    QString etag = rule->etag;\r\n    etag.remove('\"'); // no quotes allowed in string\r\n    map[\"etag\"] = etag;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/*! GET /api/<apikey>/rules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getRule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    DBG_Assert(req.path.size() == 4);\r\n\r\n    if (req.path.size() != 4)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    const QString &id = req.path[3];\r\n\r\n    Rule *rule = getRuleForId(id);\r\n\r\n    if (!rule || (rule->state() == Rule::StateDeleted))\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/rules/%1\").arg(id), QString(\"resource, /rules/%1, not available\").arg(id)));\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    auto c = rule->conditions().cbegin();\r\n    const auto c_end = rule->conditions().cend();\r\n\r\n    QVariantList conditions;\r\n\r\n    for (; c != c_end; ++c)\r\n    {\r\n        QVariantMap condition;\r\n        condition[\"address\"] = c->address();\r\n        condition[\"operator\"] = c->ooperator();\r\n        if (c->value().isValid())\r\n        {\r\n            condition[\"value\"] = c->value().toString();\r\n        }\r\n        conditions.append(condition);\r\n    }\r\n\r\n    auto a = rule->actions().cbegin();\r\n    const auto a_end = rule->actions().cend();\r\n\r\n    QVariantList actions;\r\n\r\n    for (; a != a_end; ++a)\r\n    {\r\n        QVariantMap action;\r\n        action[\"address\"] = a->address();\r\n        action[\"method\"] = a->method();\r\n\r\n        //parse body\r\n        bool ok;\r\n        QVariant body = Json::parse(a->body(), ok);\r\n        QVariantMap bodymap = body.toMap();\r\n\r\n        auto b = bodymap.cbegin();\r\n        const auto b_end = bodymap.cend();\r\n\r\n        QVariantMap resultmap;\r\n\r\n        for (; b != b_end; ++b)\r\n        {\r\n            resultmap[b.key()] = b.value();\r\n        }\r\n\r\n        action[\"body\"] = resultmap;\r\n        actions.append(action);\r\n    }\r\n\r\n    rsp.map[\"name\"] = rule->name();\r\n    if (rule->lastTriggered().isValid())\r\n    {\r\n        rsp.map[\"lasttriggered\"] = rule->lastTriggered().toString(\"yyyy-MM-ddTHH:mm:ss\");\r\n    }\r\n    else\r\n    {\r\n        rsp.map[\"lasttriggered\"] = QLatin1String(\"none\");\r\n    }\r\n    rsp.map[\"created\"] = rule->creationtime();\r\n    rsp.map[\"timestriggered\"] = rule->timesTriggered();\r\n    rsp.map[\"owner\"] = rule->owner();\r\n    rsp.map[\"status\"] = rule->status();\r\n    rsp.map[\"conditions\"] = conditions;\r\n    rsp.map[\"actions\"] = actions;\r\n    rsp.map[\"periodic\"] = static_cast<double>(rule->triggerPeriodic());\r\n\r\n    QString etag = rule->etag;\r\n    etag.remove('\"'); // no quotes allowed in string\r\n    rsp.map[\"etag\"] = etag;\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/rules\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::createRule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool error = false;\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n    const QString &apikey = req.path[1];\r\n\r\n    bool ok;\r\n    Rule rule;\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QVariantList conditionsList = map[\"conditions\"].toList();\r\n    QVariantList actionsList = map[\"actions\"].toList();\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/rules\"), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    userActivity();\r\n/*\r\n    if (rules.size() >= MAX_RULES_COUNT) //deletet rules will be count\r\n    {\r\n        rsp.list.append(errorToMap(ERR_RULE_ENGINE_FULL , QString(\"/rules/\"), QString(\"The Rule Engine has reached its maximum capacity of %1 rules\").arg(MAX_RULES_COUNT)));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n*/\r\n    //check invalid parameter\r\n\r\n    if (!map.contains(\"name\"))\r\n    {\r\n        error = true;\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/rules/name\"), QString(\"invalid/missing parameters in body\")));\r\n    }\r\n\r\n    if (conditionsList.size() < 1)\r\n    {\r\n        error = true;\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/rules/conditions\"), QString(\"invalid/missing parameters in body\")));\r\n    }\r\n\r\n    if (actionsList.size() < 1)\r\n    {\r\n        error = true;\r\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/rules/actions\"), QString(\"invalid/missing parameters in body\")));\r\n    }\r\n\r\n    if (conditionsList.size() > 8)\r\n    {\r\n        error = true;\r\n        rsp.list.append(errorToMap(ERR_TOO_MANY_ITEMS, QString(\"/rules/conditions\"), QString(\"too many items in list\")));\r\n    }\r\n\r\n    if (actionsList.size() > 8)\r\n    {\r\n        error = true;\r\n        rsp.list.append(errorToMap(ERR_TOO_MANY_ITEMS, QString(\"/rules/actions\"), QString(\"too many items in list\")));\r\n    }\r\n\r\n    if (map.contains(\"status\")) // optional\r\n    {\r\n        QString status = map[\"status\"].toString();\r\n        if (!(status == \"disabled\" || status == \"enabled\"))\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/status\"), QString(\"invalid value, %1, for parameter, status\").arg(status)));\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"periodic\")) // optional\r\n    {\r\n        int periodic = map[\"periodic\"].toInt(&ok);\r\n\r\n        if (!ok)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/periodic\"), QString(\"invalid value, %1, for parameter, peridoc\").arg(map[\"periodic\"].toString())));\r\n        }\r\n        else\r\n        {\r\n            rule.setTriggerPeriodic(periodic);\r\n        }\r\n    }\r\n\r\n    //resolve errors\r\n    if (error)\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n    else\r\n    {\r\n        QString name = map[\"name\"].toString();\r\n\r\n        if ((map[\"name\"].type() == QVariant::String) && !name.isEmpty())\r\n        {\r\n            if (name.size() > MAX_RULE_NAME_LENGTH)\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/name\"), QString(\"invalid/missing parameters in body\")));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n\r\n            // create a new rule id\r\n            rule.setId(\"1\");\r\n\r\n            do {\r\n                ok = true;\r\n                auto i = rules.cbegin();\r\n                const auto end = rules.cend();\r\n\r\n                for (; i != end; ++i)\r\n                {\r\n                    if (i->id() == rule.id())\r\n                    {\r\n                        rule.setId(QString::number(i->id().toInt() + 1));\r\n                        ok = false;\r\n                    }\r\n                }\r\n            } while (!ok);\r\n\r\n            //setName\r\n            rule.setName(name);\r\n            rule.setOwner(apikey);\r\n            rule.setCreationtime(QDateTime::currentDateTimeUtc().toString(\"yyyy-MM-ddTHH:mm:ss\"));\r\n\r\n            //setStatus optional\r\n            if (map.contains(\"status\"))\r\n            {\r\n                rule.setStatus(map[\"status\"].toString());\r\n            }\r\n\r\n            //setActions\r\n            if (checkActions(actionsList, rsp))\r\n            {\r\n                std::vector<RuleAction> actions;\r\n                auto ai = actionsList.cbegin();\r\n                const auto aend = actionsList.cend();\r\n\r\n                for (; ai != aend; ++ai)\r\n                {\r\n                    RuleAction newAction;\r\n                    const QVariantMap m = ai->toMap();\r\n                    newAction.setAddress(m[\"address\"].toString());\r\n                    newAction.setBody(Json::serialize(m[\"body\"].toMap()));\r\n                    newAction.setMethod(m[\"method\"].toString());\r\n                    actions.push_back(newAction);\r\n                }\r\n\r\n                rule.setActions(actions);\r\n            }\r\n            else\r\n            {\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n\r\n            //setConditions\r\n            if (checkConditions(conditionsList, rsp))\r\n            {\r\n                std::vector<RuleCondition> conditions;\r\n                auto ci = conditionsList.cbegin();\r\n                const auto cend = conditionsList.cend();\r\n\r\n                for (; ci != cend; ++ci)\r\n                {\r\n                    const RuleCondition cond(ci->toMap());\r\n                    if (cond.isValid())\r\n                    {\r\n                        conditions.push_back(cond);\r\n                    }\r\n                }\r\n\r\n                rule.setConditions(conditions);\r\n            }\r\n            else\r\n            {\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                return REQ_READY_SEND;\r\n            }\r\n\r\n            updateEtag(rule.etag);\r\n            updateEtag(gwConfigEtag);\r\n\r\n            DBG_Printf(DBG_INFO, \"create rule %s: %s\\n\", qPrintable(rule.id()), qPrintable(rule.name()));\r\n            rules.push_back(rule);\r\n            rules.back().setNeedSaveDatabase();\r\n            indexRulesTriggers();\r\n            queSaveDb(DB_RULES, DB_SHORT_SAVE_DELAY);\r\n\r\n            rspItemState[\"id\"] = rule.id();\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            rsp.httpStatus = HttpStatusOk;\r\n            return REQ_READY_SEND;\r\n        }\r\n        else\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/rules\"), QString(\"body contains invalid JSON\")));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n        }\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n\r\n/*! PUT, PATCH /api/<apikey>/rules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::updateRule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    bool ok;\r\n    bool error = false;\r\n    bool changed = false;\r\n\r\n    QString id = req.path[3];\r\n\r\n    Rule *rule = getRuleForId(id);\r\n\r\n    if (!rule || (rule->state() == Rule::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/rules/%1\").arg(id), QString(\"resource, /rules/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"update rule %s: %s\\n\", qPrintable(id), qPrintable(rule->name()));\r\n\r\n    QVariant var = Json::parse(req.content, ok);\r\n    QVariantMap map = var.toMap();\r\n    QVariantList conditionsList;\r\n    QVariantList actionsList;\r\n\r\n    QString name;\r\n    QString status;\r\n    int periodic = 0;\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    if (!ok)\r\n    {\r\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/rules\"), QString(\"body contains invalid JSON\")));\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    userActivity();\r\n\r\n    //check invalid parameter\r\n    auto pi = map.cbegin();\r\n    const auto pend = map.cend();\r\n\r\n    for (; pi != pend; ++pi)\r\n    {\r\n        if(!((pi.key() == QLatin1String(\"name\")) || (pi.key() == QLatin1String(\"status\")) || (pi.key() == QLatin1String(\"actions\")) || (pi.key() == QLatin1String(\"conditions\")) || (pi.key() == QLatin1String(\"periodic\"))))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/rules/%1/%2\").arg(id).arg(pi.key()), QString(\"parameter, %1, not available\").arg(pi.key())));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"name\")) // optional\r\n    {\r\n        name = map[\"name\"].toString();\r\n\r\n        if ((map[\"name\"].type() == QVariant::String) && !(name.isEmpty()))\r\n        {\r\n            if (name.size() > MAX_RULE_NAME_LENGTH)\r\n            {\r\n                error = true;\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/%1/name\").arg(id), QString(\"invalid value, %1, for parameter, /rules/%2/name\").arg(name).arg(id)));\r\n                rsp.httpStatus = HttpStatusBadRequest;\r\n                name = QString();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/%1/name\").arg(id), QString(\"invalid value, %1, for parameter, /rules/%2/name\").arg(name).arg(id)));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            name = QString();\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"conditions\")) //optional\r\n    {\r\n        conditionsList = map[\"conditions\"].toList();\r\n        if (conditionsList.size() < 1)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/rules/conditions\"), QString(\"invalid/missing parameters in body\")));\r\n        }\r\n\r\n        if (conditionsList.size() > 8)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_TOO_MANY_ITEMS, QString(\"/rules/conditions\"), QString(\"too many items in list\")));\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"actions\")) //optional\r\n    {\r\n        actionsList = map[\"actions\"].toList();\r\n        if (actionsList.size() < 1)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/rules/actions\"), QString(\"invalid/missing parameters in body\")));\r\n        }\r\n\r\n        if (actionsList.size() > 8)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_TOO_MANY_ITEMS, QString(\"/rules/actions\"), QString(\"too many items in list\")));\r\n        }\r\n    }\r\n    if (map.contains(\"status\")) // optional\r\n    {\r\n        status = map[\"status\"].toString();\r\n        if (!(status == \"disabled\" || status == \"enabled\"))\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/status\"), QString(\"invalid value, %1, for parameter, status\").arg(status)));\r\n        }\r\n    }\r\n\r\n    if (map.contains(\"periodic\")) // optional\r\n    {\r\n        periodic = map[\"periodic\"].toInt(&ok);\r\n\r\n        if (!ok)\r\n        {\r\n            error = true;\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/rules/periodic\"), QString(\"invalid value, %1, for parameter, peridoc\").arg(map[\"periodic\"].toString())));\r\n        }\r\n    }\r\n\r\n    //resolve errors\r\n    if (error)\r\n    {\r\n        rsp.httpStatus = HttpStatusBadRequest;\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // first delete old binding if present then create new binding with updated rule\r\n    if (map.contains(\"actions\") || map.contains(\"conditions\"))\r\n    {\r\n        rule->setStatus(\"disabled\");\r\n    }\r\n\r\n    //setName optional\r\n    if (!name.isEmpty())\r\n    {\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[QString(\"/rules/%1/name\").arg(id)] = name;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n        if (rule->name() != name)\r\n        {\r\n            changed = true;\r\n            rule->setName(name);\r\n        }\r\n    }\r\n\r\n    //setStatus optional\r\n    if (map.contains(\"status\"))\r\n    {\r\n        QVariantMap rspItem;\r\n        QVariantMap rspItemState;\r\n        rspItemState[QString(\"/rules/%1/status\").arg(id)] = status;\r\n        rspItem[\"success\"] = rspItemState;\r\n        rsp.list.append(rspItem);\r\n        if (rule->status() != status)\r\n        {\r\n            changed = true;\r\n            rule->setStatus(status);\r\n        }\r\n    }\r\n\r\n    // periodic optional\r\n    if (map.contains(\"periodic\"))\r\n    {\r\n        if (rule->triggerPeriodic() != periodic)\r\n        {\r\n            changed = true;\r\n            rule->setTriggerPeriodic(periodic);\r\n        }\r\n    }\r\n\r\n    //setActions optional\r\n    if (map.contains(\"actions\"))\r\n    {\r\n        changed = true;\r\n        if (checkActions(actionsList,rsp))\r\n        {\r\n            std::vector<RuleAction> actions;\r\n            auto ai = actionsList.cbegin();\r\n            const auto aend = actionsList.cend();\r\n\r\n            for (; ai != aend; ++ai)\r\n            {\r\n                RuleAction newAction;\r\n                newAction.setAddress(ai->toMap()[\"address\"].toString());\r\n                newAction.setBody(Json::serialize(ai->toMap()[\"body\"].toMap()));\r\n                newAction.setMethod(ai->toMap()[\"method\"].toString());\r\n                actions.push_back(newAction);\r\n            }\r\n            rule->setActions(actions);\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/rules/%1/actions\").arg(id)] = actionsList;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n        }\r\n        else\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    //setConditions optional\r\n    if (map.contains(\"conditions\"))\r\n    {\r\n        changed = true;\r\n        if (checkConditions(conditionsList, rsp))\r\n        {\r\n            std::vector<RuleCondition> conditions;\r\n            auto ci = conditionsList.cbegin();\r\n            const auto cend = conditionsList.cend();\r\n\r\n            for (; ci != cend; ++ci)\r\n            {\r\n                const RuleCondition cond(ci->toMap());\r\n                if (cond.isValid())\r\n                {\r\n                    conditions.push_back(cond);\r\n                }\r\n            }\r\n            rule->setConditions(conditions);\r\n\r\n            QVariantMap rspItem;\r\n            QVariantMap rspItemState;\r\n            rspItemState[QString(\"/rules/%1/conditions\").arg(id)] = conditionsList;\r\n            rspItem[\"success\"] = rspItemState;\r\n            rsp.list.append(rspItem);\r\n            indexRulesTriggers();\r\n        }\r\n        else\r\n        {\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    if (!map.contains(\"status\"))\r\n    {\r\n        rule->setStatus(\"enabled\");\r\n    }\r\n\r\n    if (changed)\r\n    {\r\n        updateEtag(rule->etag);\r\n        updateEtag(gwConfigEtag);\r\n        rule->setNeedSaveDatabase();\r\n        queSaveDb(DB_RULES, DB_SHORT_SAVE_DELAY);\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n\r\n/*! Validate rule actions.\r\n    \\param actionsList the actionsList\r\n */\r\nbool DeRestPluginPrivate::checkActions(QVariantList actionsList, ApiResponse &rsp)\r\n{\r\n    auto ai = actionsList.cbegin();\r\n    const auto aend = actionsList.cend();\r\n\r\n    for (; ai != aend; ++ai)\r\n    {\r\n        QString address = ai->toMap()[\"address\"].toString();\r\n        QString method = ai->toMap()[\"method\"].toString();\r\n        QString body = ai->toMap()[\"body\"].toString();\r\n\r\n        QStringList addrList = ai->toMap()[\"address\"].toString().split('/', SKIP_EMPTY_PARTS);\r\n\r\n        //check addresses\r\n        //address must begin with / and a valid resource\r\n        // /<ressouce>/<id>\r\n        // /groups/7/action\r\n        // /lights/1/state\r\n        // /schedules/5\r\n        // /sensors/2\r\n\r\n        if (addrList.size() < 2)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_ACTION_ERROR, QString(address),\r\n                            QString(\"Rule actions contain errors or an action on a unsupported resource\")));\r\n            return false;\r\n        }\r\n\r\n        //no dublicate addresses allowed\r\n        const char *resources[] = { \"groups\", \"lights\", \"schedules\", \"scenes\", \"sensors\", \"rules\", \"alarmsystems\", nullptr };\r\n\r\n        for (int i = 0; ; i++)\r\n        {\r\n            if (address.startsWith(QLatin1String(\"http\"))) // webhook http/https\r\n            {\r\n                break; // supported\r\n            }\r\n\r\n            if (!resources[i])\r\n            {\r\n                rsp.list.append(errorToMap(ERR_ACTION_ERROR, address, QLatin1String(\"Rule actions contain errors or an action on a unsupported resource\")));\r\n                return false;\r\n            }\r\n\r\n            if (addrList[0] == QLatin1String(resources[i]))\r\n            {\r\n                break; // supported\r\n            }\r\n        }\r\n\r\n        //check methods\r\n        if(!(method == QLatin1String(\"PUT\") || method == QLatin1String(\"POST\") || method == QLatin1String(\"DELETE\") || method == QLatin1String(\"GET\")))\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE , QLatin1String(\"rules/method\"), QString(\"invalid value, %1, for parameter, method\").arg(method)));\r\n            return false;\r\n        }\r\n\r\n        //check body\r\n        bool ok;\r\n        Json::parse(body, ok);\r\n        if (!ok)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_JSON, QLatin1String(\"/rules/\"), QLatin1String(\"body contains invalid JSON\")));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*! Rule conditions contain errors or operator combination is not allowed.\r\n    \\param conditionsList the conditionsList\r\n */\r\nbool DeRestPluginPrivate::checkConditions(QVariantList conditionsList, ApiResponse &rsp)\r\n{\r\n    auto ci = conditionsList.cbegin();\r\n    const auto cend = conditionsList.cend();\r\n\r\n    for (; ci != cend; ++ci)\r\n    {\r\n        const RuleCondition cond(ci->toMap());\r\n\r\n        Resource *resource = cond.isValid() ? getResource(cond.resource(), cond.id()) : nullptr;\r\n        ResourceItem *item = resource ? resource->item(cond.suffix()) : nullptr;\r\n\r\n        if (!resource || !item)\r\n        {\r\n            rsp.list.append(errorToMap(ERR_CONDITION_ERROR, QString(cond.address()), QLatin1String(\"Condition error\")));\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/rules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::deleteRule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n    Rule *rule = getRuleForId(id);\r\n\r\n    userActivity();\r\n\r\n    if (!rule || (rule->state() == Rule::StateDeleted))\r\n    {\r\n        rsp.httpStatus = HttpStatusNotFound;\r\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/rules/%1\").arg(id), QString(\"resource, /rules/%1, not available\").arg(id)));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    rule->setState(Rule::StateDeleted);\r\n    rule->setStatus(\"disabled\");\r\n\r\n    DBG_Printf(DBG_INFO, \"delete rule %s: %s\\n\", qPrintable(id), qPrintable(rule->name()));\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"id\"] = id;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    updateEtag(gwConfigEtag);\r\n    updateEtag(rule->etag);\r\n    rule->setNeedSaveDatabase();\r\n\r\n    queSaveDb(DB_RULES, DB_SHORT_SAVE_DELAY);\r\n\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! Evaluates rule.\r\n    \\param rule - the rule to check\r\n    \\param e - the trigger event\r\n    \\param eResource - the event resource\r\n    \\param eItem - the event resource item\r\n    \\param now - the current date/time to check the rule against\r\n    \\return true if rule can be triggered\r\n */\r\nbool DeRestPluginPrivate::evaluateRule(Rule &rule, const Event &e, Resource *eResource, ResourceItem *eItem, QDateTime now, QDateTime previousNow)\r\n{\r\n    if (!apsCtrl || !eItem || !eResource || (apsCtrl->networkState() != deCONZ::InNetwork))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (rule.state() != Rule::StateNormal || !rule.isEnabled())\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (rule.triggerPeriodic() < 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (rule.triggerPeriodic() > 0)\r\n    {\r\n        if (rule.lastTriggered().isValid() &&\r\n            rule.lastTriggered().addMSecs(rule.triggerPeriodic()) > now)\r\n        {\r\n            // not yet time\r\n            return false;\r\n        }\r\n    }\r\n\r\n    auto c = rule.conditions().cbegin();\r\n    const auto cend = rule.conditions().cend();\r\n\r\n    for (; c != cend; ++c)\r\n    {\r\n        Resource *resource = getResource(c->resource(), c->id());\r\n        ResourceItem *item = resource ? resource->item(c->suffix()) : nullptr;\r\n\r\n        // the condition value might refer to another resource\r\n        Resource *valueResource = c->valueResource() ? getResource(c->valueResource(), c->valueId()) : nullptr;\r\n        ResourceItem *valueItem = valueResource ? valueResource->item(c->valueSuffix()) : nullptr;\r\n\r\n        if (!resource || !item)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"rule: %s, resource %s : %s id: %s (cond: %s) not found\\n\",\r\n                       qPrintable(rule.id()), c->resource(), c->suffix(),\r\n                       qPrintable(c->id()), qPrintable(c->address()));\r\n\r\n            if (!resource)\r\n            {\r\n                DBG_Printf(DBG_INFO, \"\\tdisable rule %s: %s\\n\", qPrintable(rule.id()), qPrintable(rule.name()));\r\n                rule.setStatus(QLatin1String(\"disabled\"));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (!item->lastSet().isValid()) { return false; }\r\n\r\n        if (resource->prefix() == RSensors && c->suffix() != RConfigOn)\r\n        {\r\n            // don't trigger rule if sensor is disabled\r\n            ResourceItem *item2 = resource->item(RConfigOn);\r\n            if (item2 && !item2->toBool())\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (c->op() == RuleCondition::OpEqual)\r\n        {\r\n            if (c->numericValue() != item->toNumber())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (item == eItem && e.num() == e.numPrevious())\r\n            {\r\n                return false; // item was not changed\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpNotEqual)\r\n        {\r\n            if (c->numericValue() == item->toNumber())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (item == eItem && e.num() == e.numPrevious())\r\n            {\r\n                return false; // item was not changed\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpGreaterThan && item->descriptor().suffix == RStateLocaltime)\r\n        {\r\n            if (valueItem && valueItem->descriptor().suffix == RStateLocaltime)\r\n            {\r\n                if (valueItem->toNumber() < item->toNumber())\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (valueItem && valueItem->descriptor().suffix == RConfigLocalTime)\r\n            {\r\n                const QDateTime t1 = QDateTime::fromMSecsSinceEpoch(item->toNumber());\r\n                if (now.time() < t1.time())\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpLowerThan && item->descriptor().suffix == RStateLocaltime)\r\n        {\r\n            if (valueItem && valueItem->descriptor().suffix == RStateLocaltime)\r\n            {\r\n                if (valueItem->toNumber() > item->toNumber())\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (valueItem && valueItem->descriptor().suffix == RConfigLocalTime)\r\n            {\r\n                const QDateTime t1 = QDateTime::fromMSecsSinceEpoch(item->toNumber());\r\n                if (now.time() > t1.time())\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpGreaterThan)\r\n        {\r\n            if (item->toNumber() <= c->numericValue())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (item == eItem && e.numPrevious() > c->numericValue())\r\n            {\r\n                return false; // must become >\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpLowerThan)\r\n        {\r\n            if (item->toNumber() >= c->numericValue())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (item == eItem && e.numPrevious() < c->numericValue())\r\n            {\r\n                return false; // must become <\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpDx)\r\n        {\r\n            if (item != eItem)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (eItem->descriptor().suffix == RStateLastUpdated)\r\n            {}\r\n            else if (eItem->descriptor().suffix == RAttrLastAnnounced)\r\n            {}\r\n            else if (eItem->descriptor().suffix == RConfigLocalTime)\r\n            {}\r\n            else if (e.num() == e.numPrevious())\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpDdx)\r\n        {\r\n            if (eItem->descriptor().suffix != RConfigLocalTime)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (!item->lastChanged().isValid())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            QDateTime dt = item->lastChanged().addSecs(c->seconds());\r\n            if (dt <= previousNow || dt > now)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpStable)\r\n        {\r\n            if (!item->lastSet().isValid())\r\n            {\r\n                return false;\r\n            }\r\n\r\n            QDateTime dt = item->lastChanged().addSecs(c->seconds());\r\n            if (now.secsTo(dt) > 0)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpIn && c->suffix() == RConfigLocalTime)\r\n        {\r\n            const QTime t = now.time();\r\n            const QTime pt = previousNow.time();\r\n\r\n            if (eItem->descriptor().suffix == RConfigLocalTime && (c->time0() <= pt || c->time0() > t))\r\n            {\r\n                return false; // Only trigger on start time\r\n            }\r\n\r\n            if (!c->weekDayEnabled(now.date().dayOfWeek()))\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (c->time0() < c->time1() && // 8:00 - 16:00\r\n                (t >= c->time0() && t <= c->time1()))\r\n            {\r\n            }\r\n            else if (c->time0() > c->time1() && // 20:00 - 4:00\r\n                (t >= c->time0() || t <= c->time1()))\r\n                // 20:00 - 0:00  ||  0:00 - 4:00\r\n            {\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else if (c->op() == RuleCondition::OpNotIn && c->suffix() == RConfigLocalTime)\r\n        {\r\n            const QTime t = now.time();\r\n            const QTime pt = previousNow.time();\r\n\r\n            if (eItem->descriptor().suffix == RConfigLocalTime && (c->time1() <= pt || c->time1() > t))\r\n            {\r\n                return false; // Only trigger on end time\r\n            }\r\n\r\n            if (!c->weekDayEnabled(now.date().dayOfWeek()))\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (c->time0() < c->time1() && // 8:00 - 16:00\r\n                (t <= c->time0() || t >= c->time1()))\r\n                // 0:00 - 8:00   || 16.00 - 0.00\r\n            {\r\n            }\r\n            else if (c->time0() > c->time1() && // 20:00 - 4:00\r\n                (t <= c->time0() && t >= c->time1()))\r\n            {\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_ERROR, \"error: rule (%s) operator %s not supported\\n\", qPrintable(rule.id()), qPrintable(c->ooperator()));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/*! Index rules related resource item triggers.\r\n    \\param rule - the rule to index\r\n */\r\nvoid DeRestPluginPrivate::indexRuleTriggers(Rule &rule)\r\n{\r\n    ResourceItem *itemDx = nullptr;\r\n    ResourceItem *itemDdx = nullptr;\r\n    std::vector<ResourceItem*> items;\r\n\r\n    for (const RuleCondition &c : rule.conditions())\r\n    {\r\n        Resource *resource = getResource(c.resource(), c.id());\r\n        ResourceItem *item = resource ? resource->item(c.suffix()) : nullptr;\r\n\r\n        if (!resource || !item)\r\n        {\r\n            continue;\r\n//            DBG_Printf(DBG_INFO, \"resource %s : %s id: %s (cond: %s) not found --> disable rule\\n\",\r\n//                       c->resource(), c->suffix(),\r\n//                       qPrintable(c->id()), qPrintable(c->address()));\r\n        }\r\n\r\n        if (!c.id().isEmpty())\r\n        {\r\n            DBG_Printf(DBG_INFO_L2, \"\\t%s/%s/%s op: %s\\n\", c.resource(), qPrintable(c.id()), c.suffix(), qPrintable(c.ooperator()));\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO_L2, \"\\t%s : %s op: %s\\n\", c.resource(), c.suffix(), qPrintable(c.ooperator()));\r\n        }\r\n\r\n        if (c.op() == RuleCondition::OpDx)\r\n        {\r\n            DBG_Assert(itemDx == nullptr);\r\n            DBG_Assert(itemDdx == nullptr);\r\n            itemDx = item;\r\n        }\r\n        else if (c.op() == RuleCondition::OpDdx)\r\n        {\r\n            DBG_Assert(itemDx == nullptr);\r\n            DBG_Assert(itemDdx == nullptr);\r\n            itemDdx = item;\r\n        }\r\n        else if (c.op() == RuleCondition::OpStable) { }\r\n        else if (c.op() == RuleCondition::OpNotStable) { }\r\n        else\r\n        {\r\n            items.push_back(item);\r\n        }\r\n    }\r\n\r\n    if (itemDx)\r\n    {\r\n        items.clear();\r\n        items.push_back(itemDx);\r\n    }\r\n    else if (itemDdx)\r\n    {\r\n        Resource *r = getResource(RConfig);\r\n        itemDdx = r ? r->item(RConfigLocalTime) : nullptr;\r\n        DBG_Assert(r != nullptr);\r\n        DBG_Assert(itemDdx != nullptr);\r\n        items.clear();\r\n        if (itemDdx)\r\n        {\r\n            items.push_back(itemDdx);\r\n        }\r\n    }\r\n\r\n    for (ResourceItem *item : items)\r\n    {\r\n        item->inRule(rule.handle());\r\n        DBG_Printf(DBG_INFO_L2, \"\\t%s (trigger)\\n\", item->descriptor().suffix);\r\n    }\r\n}\r\n\r\n/*! Triggers actions of a rule.\r\n    \\param rule - the rule to trigger\r\n */\r\nvoid DeRestPluginPrivate::triggerRule(Rule &rule)\r\n{\r\n    if (rule.state() != Rule::StateNormal || !rule.isEnabled())\r\n    {\r\n        return;\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"trigger rule %s - %s\\n\", qPrintable(rule.id()), qPrintable(rule.name()));\r\n\r\n    bool triggered = false;\r\n    auto ai = rule.actions().cbegin();\r\n    const auto aend = rule.actions().cend();\r\n\r\n    for (; ai != aend; ++ai)\r\n    {\r\n        // check webhook\r\n        if (ai->address().startsWith(QLatin1String(\"http\")))\r\n        {\r\n            if (handleWebHook(*ai) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n            continue;\r\n        }\r\n\r\n        if (ai->method() != QLatin1String(\"PUT\") && ai->method() != QLatin1String(\"POST\"))\r\n            return;\r\n\r\n\r\n        QStringList path = ai->address().split(QChar('/'), SKIP_EMPTY_PARTS);\r\n\r\n        if (path.isEmpty()) // at least: /config, /groups, /lights, /sensors\r\n            return;\r\n\r\n        QHttpRequestHeader hdr(ai->method(), ai->address());\r\n\r\n        // paths start with /api/<apikey/ ...>\r\n        path.prepend(rule.owner()); // apikey\r\n        path.prepend(QLatin1String(\"api\")); // api\r\n\r\n        ApiRequest req(hdr, path, nullptr, ai->body());\r\n        ApiResponse rsp;\r\n        rsp.httpStatus = HttpStatusServiceUnavailable;\r\n\r\n        // todo, dispatch request function\r\n        if (path[2] == QLatin1String(\"groups\"))\r\n        {\r\n            if (handleGroupsApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"lights\"))\r\n        {\r\n            if (handleLightsApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"schedules\"))\r\n        {\r\n            if (handleSchedulesApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"scenes\"))\r\n        {\r\n            if (handleScenesApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"sensors\"))\r\n        {\r\n            if (handleSensorsApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"config\"))\r\n        {\r\n            if (handleConfigFullApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"rules\"))\r\n        {\r\n            if (handleRulesApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else if (path[2] == QLatin1String(\"alarmsystems\"))\r\n        {\r\n            if (AS_handleAlarmSystemsApi(req, rsp, *alarmSystems, eventEmitter) == REQ_NOT_HANDLED)\r\n            {\r\n                return;\r\n            }\r\n            triggered = true;\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"unsupported rule action address %s\\n\", qPrintable(ai->address()));\r\n            return;\r\n        }\r\n\r\n        if (rsp.httpStatus != HttpStatusOk)\r\n        {\r\n            DBG_Printf(DBG_INFO, \"trigger rule %s - %s failed with status %s\\n\", qPrintable(rule.id()), qPrintable(rule.name()), rsp.httpStatus);\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (triggered)\r\n    {\r\n        rule.m_lastTriggered = QDateTime::currentDateTimeUtc();\r\n        rule.setTimesTriggered(rule.timesTriggered() + 1);\r\n        rule.setNeedSaveDatabase();\r\n        updateEtag(rule.etag);\r\n        updateEtag(gwConfigEtag);\r\n        //queSaveDb(DB_RULES, DB_HUGE_SAVE_DELAY);\r\n    }\r\n}\r\n\r\n/*! Sends a HTTP request aka webhook based on a rule action.\r\n    \\param action - the action holding the request details\r\n */\r\nint DeRestPluginPrivate::handleWebHook(const RuleAction &action)\r\n{\r\n    QNetworkRequest req(QUrl(action.address()));\r\n\r\n    QBuffer *data = new QBuffer(this);\r\n    DBG_Assert(data);\r\n    if (!data)\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    data->setData(action.body().toUtf8());\r\n\r\n    QNetworkReply *reply = webhookManager->sendCustomRequest(req, action.method().toLatin1(), data);\r\n    DBG_Assert(reply);\r\n    if (reply)\r\n    {\r\n        reply->setProperty(\"buf\", QVariant::fromValue(data));\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! Handler for finished webhooks.\r\n  */\r\nvoid DeRestPluginPrivate::webhookFinishedRequest(QNetworkReply *reply)\r\n{\r\n    if (!reply)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (reply->property(\"buf\").canConvert<QBuffer*>())\r\n    {\r\n        QBuffer *buf  = reply->property(\"buf\").value<QBuffer*>();\r\n        buf->deleteLater();\r\n    }\r\n\r\n    DBG_Printf(DBG_INFO, \"Webhook finished: %s (code: %d)\\n\", qPrintable(reply->url().toString()), reply->error());\r\n\r\n    if (DBG_IsEnabled(DBG_HTTP))\r\n    {\r\n        for (const auto &hdr : reply->rawHeaderPairs())\r\n        {\r\n            DBG_Printf(DBG_HTTP, \"%s: %s\\n\", qPrintable(hdr.first), qPrintable(hdr.second));\r\n        }\r\n\r\n        QByteArray data = reply->readAll();\r\n        if (!data.isEmpty())\r\n        {\r\n            DBG_Printf(DBG_HTTP, \"%s\\n\", qPrintable(data));\r\n        }\r\n    }\r\n\r\n    reply->deleteLater();\r\n}\r\n\r\n/*! Trigger fast checking of rules related to the resource. */\r\nvoid DeRestPluginPrivate::indexRulesTriggers()\r\n{\r\n    fastRuleCheck.clear();\r\n    for (const Rule &rule : rules)\r\n    {\r\n        if (rule.status().startsWith('e')) // enabled\r\n        {\r\n            fastRuleCheck.push_back(rule.handle());\r\n        }\r\n    }\r\n\r\n    if (!fastRuleCheckTimer->isActive() && !fastRuleCheck.empty())\r\n    {\r\n        fastRuleCheckTimer->start();\r\n    }\r\n}\r\n\r\n/*! Checks one rule from the fast check queue per event loop cycle. */\r\nvoid DeRestPluginPrivate::fastRuleCheckTimerFired()\r\n{\r\n    for (int &handle : fastRuleCheck)\r\n    {\r\n        if (handle == 0)\r\n        {\r\n            continue;  // already checked\r\n        }\r\n\r\n        for (Rule &rule: rules)\r\n        {\r\n            if (rule.handle() == handle)\r\n            {\r\n                DBG_Printf(DBG_INFO_L2, \"index resource items for rules, handle: %d (%s)\\n\", rule.handle(), qPrintable(rule.name()));\r\n                indexRuleTriggers(rule);\r\n                fastRuleCheckTimer->start(); // handle in next event loop cycle\r\n                handle = 0; // mark checked\r\n                return;\r\n            }\r\n        }\r\n        handle = 0; // mark checked (2)\r\n    }\r\n\r\n    // all done\r\n    fastRuleCheck.clear();\r\n}\r\n\r\n/*! Triggers rules based on events. */\r\nvoid DeRestPluginPrivate::handleRuleEvent(const Event &e)\r\n{\r\n    if (e.resource() == RDevices)\r\n    {\r\n        return; // todo\r\n    }\r\n\r\n    Resource *resource = getResource(e.resource(), e.id());\r\n    ResourceItem *item = resource ? resource->item(e.what()) : nullptr;\r\n    const ResourceItem *localTime = config.item(RConfigLocalTime);\r\n    const QDateTime now = localTime\r\n      ? QDateTime::fromMSecsSinceEpoch(localTime->toNumber())\r\n      : QDateTime::currentDateTime();\r\n    const QDateTime previousNow = (localTime && localTime->toNumberPrevious() > 0)\r\n      ? QDateTime::fromMSecsSinceEpoch(localTime->toNumberPrevious())\r\n      : now.addSecs(-1);\r\n\r\n    if (!resource || !item || item->rulesInvolved().empty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!e.id().isEmpty())\r\n    {\r\n        DBG_Printf(DBG_INFO, \"rule event %s/%s/%s: %d -> %d\\n\", e.resource(), qPrintable(e.id()), e.what(), e.numPrevious(), e.num());\r\n    }\r\n    else\r\n    {\r\n        DBG_Printf(DBG_INFO_L2, \"rule event /%s: %s -> %s (%lldms)\\n\", e.what(), qPrintable(previousNow.toString(\"hh:mm:ss.zzz\")), qPrintable(now.toString(\"hh:mm:ss.zzz\")), previousNow.msecsTo(now));\r\n    }\r\n\r\n\r\n    // QElapsedTimer t;\r\n    // t.start();\r\n    std::vector<size_t> rulesToTrigger;\r\n    for (int handle : item->rulesInvolved())\r\n    {\r\n        for (size_t i = 0; i < rules.size(); i++)\r\n        {\r\n            if (rules[i].handle() != handle)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (evaluateRule(rules[i], e, resource, item, now, previousNow))\r\n            {\r\n                rulesToTrigger.push_back(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (size_t i : rulesToTrigger)\r\n    {\r\n        DBG_Assert(i < rules.size());\r\n        if (i < rules.size())\r\n        {\r\n            triggerRule(rules[i]);\r\n        }\r\n    }\r\n\r\n    // int dt = t.elapsed();\r\n    // if (dt > 0)\r\n    // {\r\n    //     DBG_Printf(DBG_INFO_L2, \"trigger rule events took %d ms\\n\", dt);\r\n    // }\r\n}\r\n"
        },
        {
          "name": "rest_scenes.cpp",
          "type": "blob",
          "size": 0.7529296875,
          "content": "/*\n * Copyright (c) 2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\n/*! Scenes REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleScenesApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n    if (rsp.map.isEmpty())\n    {\n        rsp.str = \"{}\"; // return empty object\n    }\n    rsp.httpStatus = HttpStatusOk;\n    return REQ_READY_SEND;\n    // return REQ_NOT_HANDLED;\n}\n"
        },
        {
          "name": "rest_schedules.cpp",
          "type": "blob",
          "size": 51.2080078125,
          "content": "/*\r\n * Copyright (c) 2016-2024 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include <QString>\r\n#include <QTcpSocket>\r\n#include <QVariantMap>\r\n#include <QRegExp>\r\n#include \"de_web_plugin_private.h\"\r\n#include \"json.h\"\r\n#include \"deconz/u_rand32.h\"\r\n\r\n/*! Inits the schedules manager.\r\n */\r\nvoid DeRestPluginPrivate::initSchedules()\r\n{\r\n    scheduleTimer = new QTimer(this);\r\n    scheduleTimer->setSingleShot(false);\r\n    connect(scheduleTimer, SIGNAL(timeout()),\r\n            this, SLOT(scheduleTimerFired()));\r\n    scheduleTimer->start(SCHEDULE_CHECK_PERIOD);\r\n}\r\n\r\n/*! Schedules REST API broker.\r\n    \\param req - request data\r\n    \\param rsp - response data\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::handleSchedulesApi(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    if (req.path[2] != QLatin1String(\"schedules\"))\r\n    {\r\n        return REQ_NOT_HANDLED;\r\n    }\r\n\r\n    // GET /api/<apikey>/schedules\r\n    if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getAllSchedules(req, rsp);\r\n    }\r\n    // POST /api/<apikey>/schedules\r\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"POST\"))\r\n    {\r\n        return createSchedule(req, rsp);\r\n    }\r\n    // GET /api/<apikey>/schedules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\"))\r\n    {\r\n        return getScheduleAttributes(req, rsp);\r\n    }\r\n    // PUT, PATCH /api/<apikey>/schedules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\"))\r\n    {\r\n        return setScheduleAttributes(req, rsp);\r\n    }\r\n    // DELETE /api/<apikey>/schedules/<id>\r\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\"))\r\n    {\r\n        return deleteSchedule(req, rsp);\r\n    }\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! GET /api/<apikey>/schedules\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getAllSchedules(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    Q_UNUSED(req);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    std::vector<Schedule>::const_iterator i = schedules.begin();\r\n    std::vector<Schedule>::const_iterator end = schedules.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state == Schedule::StateNormal)\r\n        {\r\n            QVariantMap mnode;\r\n\r\n            mnode[\"name\"] = i->name;\r\n            mnode[\"description\"] = i->description;\r\n            mnode[\"command\"] = i->jsonMap[\"command\"];\r\n            mnode[\"time\"] = i->time;\r\n            if (!i->localtime.isEmpty())\r\n            {\r\n                mnode[\"localtime\"] = i->localtime;\r\n            }\r\n            if (i->type == Schedule::TypeTimer)\r\n            {\r\n                mnode[\"starttime\"] = i->starttime;\r\n            }\r\n            if (i->jsonMap.contains(\"created\"))\r\n            {\r\n                mnode[\"created\"] = i->jsonMap[\"created\"];\r\n            }\r\n            mnode[\"status\"] = i->status;\r\n            mnode[\"activation\"] = i->activation;\r\n            mnode[\"autodelete\"] = i->autodelete;\r\n            QString etag = i->etag;\r\n            etag.remove('\"'); // no quotes allowed in string\r\n            mnode[\"etag\"] = etag;\r\n            rsp.map[i->id] = mnode;\r\n        }\r\n    }\r\n\r\n    if (rsp.map.isEmpty())\r\n    {\r\n        rsp.str = \"{}\"; // return empty object\r\n    }\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! POST /api/<apikey>/schedules\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::createSchedule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    Schedule schedule;\r\n\r\n    if (!jsonToSchedule(req.content, schedule, &rsp))\r\n    {\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n    // search new id\r\n    std::vector<Schedule>::const_iterator i = schedules.begin();\r\n    std::vector<Schedule>::const_iterator end = schedules.end();\r\n\r\n    uint id = 1;\r\n    uint idmax = 0;\r\n    for (; i != end; ++i)\r\n    {\r\n        uint id2 = i->id.toUInt();\r\n        if (idmax < id2)\r\n        {\r\n            idmax = id2;\r\n        }\r\n\r\n        if (id == id2)\r\n        {\r\n            id = ++idmax;\r\n        }\r\n    }\r\n\r\n    schedule.id = QString::number(id);\r\n\r\n    if (schedule.name.isEmpty())\r\n    {\r\n        schedule.name = QString(\"Schedule %1\").arg(schedule.id);\r\n    }\r\n\r\n    // append schedule\r\n    schedules.push_back(schedule);\r\n\r\n    QVariantMap rspItem;\r\n    QVariantMap rspItemState;\r\n    rspItemState[\"id\"] = schedule.id;\r\n    rspItem[\"success\"] = rspItemState;\r\n    rsp.list.append(rspItem);\r\n    rsp.httpStatus = HttpStatusOk;\r\n\r\n    queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! GET /api/<apikey>/schedules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::getScheduleAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n\r\n    std::vector<Schedule>::const_iterator i = schedules.begin();\r\n    std::vector<Schedule>::const_iterator end = schedules.end();\r\n\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->id == id)\r\n        {\r\n            rsp.map[\"name\"] = i->name;\r\n            rsp.map[\"description\"] = i->description;\r\n            rsp.map[\"command\"] = i->jsonMap[\"command\"];\r\n            rsp.map[\"time\"] = i->time;\r\n            if (!i->localtime.isEmpty())\r\n            {\r\n                rsp.map[\"localtime\"] = i->localtime;\r\n            }\r\n            if (i->type == Schedule::TypeTimer)\r\n            {\r\n                rsp.map[\"starttime\"] = i->starttime;\r\n            }\r\n            if (i->jsonMap.contains(\"created\"))\r\n            {\r\n                rsp.map[\"created\"] = i->jsonMap[\"created\"];\r\n            }\r\n            rsp.map[\"status\"] = i->status;\r\n            rsp.map[\"activation\"] = i->activation;\r\n            rsp.map[\"autodelete\"] = i->autodelete;\r\n            QString etag = i->etag;\r\n            etag.remove('\"'); // no quotes allowed in string\r\n            rsp.map[\"etag\"] = etag;\r\n            rsp.httpStatus = HttpStatusOk;\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusNotFound;\r\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/schedules/%1\").arg(id), QString(\"resource, /schedules/%1, not available\").arg(id)));\r\n\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! PUT, PATCH /api/<apikey>/schedules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::setScheduleAttributes(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n\r\n    std::vector<Schedule>::iterator i = schedules.begin();\r\n    std::vector<Schedule>::iterator end = schedules.end();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n\r\n        if (i->state != Schedule::StateNormal || i->id != id)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        bool ok;\r\n        QVariant var = Json::parse(req.content, ok);\r\n        QVariantMap map = var.toMap();\r\n\r\n        if (!ok || map.isEmpty())\r\n        {\r\n            rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/schedules/%1\").arg(id), QString(\"body contains invalid JSON\")));\r\n            rsp.httpStatus = HttpStatusBadRequest;\r\n            return false;\r\n        }\r\n\r\n        if (map.contains(\"name\") && (map[\"name\"].type() == QVariant::String))\r\n        {\r\n            QString name = map[\"name\"].toString();\r\n\r\n            if (name.size() > 0 && name.size() <= 32)\r\n            {\r\n                i->name = name;\r\n                i->jsonMap[\"name\"] = map[\"name\"];\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/name\").arg(id)] = map[\"name\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter name\").arg(map[\"name\"].toString())));\r\n            }\r\n        }\r\n\r\n        if (map.contains(\"description\") && (map[\"description\"].type() == QVariant::String))\r\n        {\r\n            QString description = map[\"description\"].toString();\r\n\r\n            if (description.size() > 0 && description.size() <= 32)\r\n            {\r\n                i->description = description;\r\n                i->jsonMap[\"description\"] = map[\"description\"];\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/description\").arg(id)] = map[\"description\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter description\").arg(map[\"description\"].toString())));\r\n            }\r\n        }\r\n\r\n        if (map.contains(\"status\") && (map[\"status\"].type() == QVariant::String))\r\n        {\r\n            QString status = map[\"status\"].toString();\r\n\r\n            if ((status == \"enabled\") || (status == \"disabled\"))\r\n            {\r\n                i->status = status;\r\n                i->jsonMap[\"status\"] = map[\"status\"];\r\n\r\n                if (i->status == QLatin1String(\"disabled\"))\r\n                {\r\n                    i->endtime = QDateTime();\r\n                }\r\n\r\n                // randomize time again\r\n                if (status == \"enabled\" && i->time.contains(\"A\"))\r\n                {\r\n                    map[\"time\"] = i->time;\r\n                }\r\n                if (status == \"enabled\" && i->localtime.contains(\"A\"))\r\n                {\r\n                    map[\"localtime\"] = i->localtime;\r\n                }\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/status\").arg(id)] = map[\"status\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter status\").arg(map[\"status\"].toString())));\r\n            }\r\n        }\r\n\r\n        if (map.contains(\"activation\") && (map[\"activation\"].type() == QVariant::String))\r\n        {\r\n            QString activation = map[\"activation\"].toString();\r\n\r\n            if ((activation == \"start\") || (activation == \"end\"))\r\n            {\r\n                i->activation = activation;\r\n                i->jsonMap[\"activation\"] = map[\"activation\"];\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/activation\").arg(id)] = map[\"activation\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter activation\").arg(map[\"activation\"].toString())));\r\n            }\r\n        }\r\n\r\n        if (map.contains(\"command\") && (map[\"command\"].type() == QVariant::Map))\r\n        {\r\n            QVariantMap cmd = map[\"command\"].toMap();\r\n\r\n            if (!cmd.isEmpty() && cmd.contains(\"address\") && cmd.contains(\"method\") && cmd.contains(\"body\"))\r\n            {\r\n                i->command = Json::serialize(cmd);\r\n                i->jsonMap[\"command\"] = map[\"command\"];\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/command\").arg(id)] = map[\"command\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter command\").arg(map[\"command\"].toString())));\r\n            }\r\n        }\r\n\r\n        if (map.contains(\"autodelete\"))\r\n        {\r\n            if (map[\"autodelete\"].type() == QVariant::Bool)\r\n            {\r\n                bool autodelete = map[\"autodelete\"].toBool();\r\n                i->autodelete = autodelete;\r\n                i->jsonMap[\"autodelete\"] = map[\"autodelete\"];\r\n\r\n                QVariantMap rspItem;\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/autodelete\").arg(id)] = map[\"autodelete\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n                rsp.httpStatus = HttpStatusOk;\r\n            }\r\n            else\r\n            {\r\n                rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules/%1\").arg(id), QString(\"invalid value, %1, for parameter autodelete\").arg(map[\"autodelete\"].toString())));\r\n            }\r\n        }\r\n\r\n        // time\r\n        QString time;\r\n        Qt::TimeSpec timeSpec = Qt::UTC;\r\n        int randomTime = 0;\r\n        int randomMax = 0;\r\n\r\n        // time (deprecated)\r\n        if (map.contains(\"time\") && (map[\"time\"].type() == QVariant::String))\r\n        {\r\n            time = map[\"time\"].toString();\r\n            timeSpec = Qt::UTC;\r\n        }\r\n\r\n        // localtime (overwrites UTC)\r\n        if (map.contains(\"localtime\") && (map[\"localtime\"].type() == QVariant::String))\r\n        {\r\n            time = map[\"localtime\"].toString();\r\n            timeSpec = Qt::LocalTime;\r\n        }\r\n\r\n        if (!time.isEmpty())\r\n        {\r\n            i->lastTriggerDatetime = QDateTime(); // reset\r\n\r\n            if (time.contains(\"A\"))\r\n            {\r\n                // cutoff random part, A[hh]:[mm]:[ss] (it will be added later)\r\n                QStringList ls = time.split(\"A\");\r\n\r\n                if (ls.size() == 2)\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"random part: %s\\n\", qPrintable(ls[1]));\r\n                    time = ls.first();\r\n                }\r\n\r\n                QRegExp rnd(\"(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n                if (rnd.exactMatch(ls[1]))\r\n                {\r\n                    // TODO(mpi): the following code could use a refactor\r\n                    randomMax = rnd.cap(1).toInt() * 60 * 60 + // h\r\n                        rnd.cap(2).toInt() * 60 +   // m\r\n                        rnd.cap(3).toInt(); // s\r\n\r\n                    if (randomMax == 0)\r\n                    {\r\n                        randomTime = 0;\r\n                    }\r\n                    else\r\n                    {\r\n                        randomTime = (U_rand32() % ((randomMax + 1) - 1) + 1);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for random part of parameter time\").arg(map[\"time\"].toString())));\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n            // Recurring timer\r\n            // R[nn]/PT[hh]:[mm]:[ss]\r\n            if (time.startsWith(\"R\") && time.contains(\"PT\"))\r\n            {\r\n                QRegExp rx(\"R([0-9]{0,2})/PT(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n                if (rx.exactMatch(time))\r\n                {\r\n                    // offset always from current localtime?\r\n                    i->timeout = rx.cap(2).toInt() * 60 * 60 + // h\r\n                            rx.cap(3).toInt() * 60 +   // m\r\n                            rx.cap(4).toInt() + // s\r\n                            randomTime; // randomTime in seconds\r\n                    i->currentTimeout = i->timeout;\r\n                    QDateTime now = QDateTime::currentDateTimeUtc();\r\n                    i->starttime = now.toString(\"yyyy-MM-ddThh:mm:ss\");\r\n                    if (i->status == QLatin1String(\"enabled\"))\r\n                    {\r\n                        if (timeSpec == Qt::UTC)\r\n                        {\r\n                            i->endtime = QDateTime::currentDateTimeUtc().addSecs(i->timeout);\r\n                            int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                            i->endtime = i->endtime.addSecs(toffset);\r\n                            i->endtime.setOffsetFromUtc(toffset);\r\n                            i->endtime.setTimeSpec(Qt::LocalTime);\r\n                        }\r\n                        else if (timeSpec == Qt::LocalTime)\r\n                        {\r\n                            i->endtime = QDateTime::currentDateTime().addSecs(i->timeout);\r\n                        }\r\n                    }\r\n\r\n                    QString R = rx.cap(1);\r\n                    if (!R.isEmpty())\r\n                    {\r\n                        i->recurring = R.toUInt();\r\n                    }\r\n                    else\r\n                    {\r\n                        i->recurring = 0; // runs forever\r\n                    }\r\n\r\n                    if (i->timeout > 0)\r\n                    {\r\n                        i->type = Schedule::TypeTimer;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter time\").arg(map[\"time\"].toString())));\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n            // Timer expiring after given time\r\n            // PT[hh]:[mm]:[ss]\r\n            else if (time.startsWith(\"PT\"))\r\n            {\r\n                QRegExp rx(\"PT(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n                if (rx.exactMatch(time))\r\n                {\r\n                    // offset always from current localtime?\r\n                    i->timeout = rx.cap(1).toInt() * 60 * 60 + // h\r\n                                 rx.cap(2).toInt() * 60 +   // m\r\n                                 rx.cap(4).toInt() + // s\r\n                                 randomTime; // randomTime in seconds\r\n                    i->currentTimeout = i->timeout;\r\n                    i->recurring = 1;\r\n                    QDateTime now = QDateTime::currentDateTimeUtc();\r\n                    i->starttime = now.toString(\"yyyy-MM-ddThh:mm:ss\");\r\n                    if (i->status == QLatin1String(\"enabled\"))\r\n                    {\r\n                        if (timeSpec == Qt::UTC)\r\n                        {\r\n                            i->endtime = QDateTime::currentDateTimeUtc().addSecs(i->timeout);\r\n                            int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                            i->endtime = i->endtime.addSecs(toffset);\r\n                            i->endtime.setOffsetFromUtc(toffset);\r\n                            i->endtime.setTimeSpec(Qt::LocalTime);\r\n                        }\r\n                        else if (timeSpec == Qt::LocalTime)\r\n                        {\r\n                            i->endtime = QDateTime::currentDateTime().addSecs(i->timeout);\r\n                        }\r\n                    }\r\n\r\n                    if (i->timeout > 0)\r\n                    {\r\n                        i->type = Schedule::TypeTimer;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter time\").arg(map[\"time\"].toString())));\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n            // Every weekday given by bbb at given left side time, randomized by right side time.\r\n            // Right side time has to be smaller than 12 hours\r\n            // W[bbb]/T[hh]:[mm]:[ss]A[hh]:[mm]:[ss]\r\n            else if (time.startsWith(\"W\") && time.contains(\"T\") && time.contains(\"A\"))\r\n            {\r\n                //            schedule.type = Schedule::TypeRecurringTime;\r\n            }\r\n            // Every day of the week  given by bbb at given time\r\n            // W[bbb]/T[hh]:[mm]:[ss]\r\n            else if (time.startsWith(\"W\") && time.contains(\"T\"))\r\n            {\r\n                QRegExp rx(\"W([0-9]{1,3})/T(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n                if (randomTime > 43200) {\r\n                    randomTime = 43200; // random time has to be smaller than 12 hours\r\n                }\r\n\r\n                if (rx.exactMatch(time))\r\n                {\r\n                    i->type = Schedule::TypeRecurringTime;\r\n                    i->weekBitmap = rx.cap(1).toUInt();\r\n                    //dummy date needed when recurring alarm timout fired\r\n                    if (timeSpec == Qt::UTC)\r\n                    {\r\n                        i->datetime = QDateTime::currentDateTimeUtc();\r\n                    }\r\n                    else\r\n                    {\r\n                        i->datetime = QDateTime::currentDateTime();\r\n                    }\r\n                    i->datetime.setTime(QTime(rx.cap(2).toUInt(),   // h\r\n                                              rx.cap(3).toUInt(),   // m\r\n                                              rx.cap(4).toUInt())); // s\r\n                    i->datetime = i->datetime.addSecs(randomTime);\r\n\r\n                    // conversion to localtime\r\n                    if (timeSpec == Qt::UTC)\r\n                    {\r\n                        int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                        i->datetime = i->datetime.addSecs(toffset);\r\n                        i->datetime.setOffsetFromUtc(toffset);\r\n                        i->datetime.setTimeSpec(Qt::LocalTime);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter time\").arg(map[\"time\"].toString())));\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n            // Absolute time\r\n            else\r\n            {\r\n                QDateTime checkTime = QDateTime::fromString(time, Qt::ISODate);\r\n                checkTime.setTimeSpec(timeSpec);\r\n                checkTime = checkTime.addSecs(randomTime);\r\n\r\n                // conversion to localtime\r\n                if (checkTime.isValid() && timeSpec == Qt::UTC)\r\n                {\r\n                    int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                    checkTime = checkTime.addSecs(toffset);\r\n                    checkTime.setOffsetFromUtc(toffset);\r\n                    checkTime.setTimeSpec(Qt::LocalTime);\r\n                }\r\n\r\n                if (checkTime.isValid())\r\n                {\r\n                    i->datetime = checkTime;\r\n                    i->endtime = checkTime;\r\n                    if (!map.contains(QLatin1String(\"time\")))\r\n                    {\r\n                        i->time = checkTime.toUTC().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n                    }\r\n                    if (!map.contains(QLatin1String(\"localtime\")))\r\n                    {\r\n                        i->localtime = checkTime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n                    }\r\n                    i->type = Schedule::TypeAbsoluteTime;\r\n                }\r\n                else\r\n                {\r\n                    if (map.contains(QLatin1String(\"localtime\")))\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter localtime\").arg(map[\"localtime\"].toString())));\r\n                    }\r\n                    else\r\n                    {\r\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter time\").arg(map[\"time\"].toString())));\r\n                    }\r\n                    rsp.httpStatus = HttpStatusBadRequest;\r\n                    return REQ_READY_SEND;\r\n                }\r\n            }\r\n\r\n            QVariantMap rspItem;\r\n            if (map.contains(QLatin1String(\"localtime\")))\r\n            {\r\n                i->localtime = map[\"localtime\"].toString();\r\n                i->jsonMap[\"localtime\"] = i->localtime;\r\n\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/localtime\").arg(id)] = map[\"localtime\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n\r\n            if (map.contains(QLatin1String(\"time\")))\r\n            {\r\n                i->time = map[\"time\"].toString();\r\n                i->jsonMap[\"time\"] = i->time;\r\n\r\n                QVariantMap rspItemState;\r\n                rspItemState[QString(\"/schedules/%1/time\").arg(id)] = map[\"time\"];\r\n                rspItem[\"success\"] = rspItemState;\r\n                rsp.list.append(rspItem);\r\n            }\r\n\r\n            rsp.httpStatus = HttpStatusOk;\r\n        }\r\n\r\n        updateEtag(i->etag);\r\n\r\n        i->jsonMap[\"etag\"] = i->etag.remove('\"'); // no quotes allowed in string;\r\n        i->jsonString = Json::serialize(i->jsonMap);\r\n        queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n\r\n        return REQ_READY_SEND;\r\n    }\r\n\r\n\r\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/schedules/%1\").arg(id), QString(\"resource, /schedules/%1, not available\").arg(id)));\r\n    rsp.httpStatus = HttpStatusNotFound;\r\n    return REQ_READY_SEND;\r\n}\r\n\r\n/*! DELETE /api/<apikey>/schedules/<id>\r\n    \\return REQ_READY_SEND\r\n            REQ_NOT_HANDLED\r\n */\r\nint DeRestPluginPrivate::deleteSchedule(const ApiRequest &req, ApiResponse &rsp)\r\n{\r\n    QString id = req.path[3];\r\n\r\n    std::vector<Schedule>::iterator i = schedules.begin();\r\n    std::vector<Schedule>::iterator end = schedules.end();\r\n\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if ((i->id == id) && (i->state == Schedule::StateNormal))\r\n        {\r\n            QVariantMap rspItem;\r\n            rspItem[\"success\"] = QString(\"/schedules/%1 deleted.\").arg(id);\r\n            rsp.list.append(rspItem);\r\n            rsp.httpStatus = HttpStatusOk;\r\n\r\n            DBG_Printf(DBG_INFO, \"/schedules/%s deleted\\n\", qPrintable(id));\r\n            i->state = Schedule::StateDeleted;\r\n            queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n            return REQ_READY_SEND;\r\n        }\r\n    }\r\n\r\n    rsp.httpStatus = HttpStatusNotFound;\r\n    rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/schedules/%1\").arg(id), QString(\"resource, /schedules/%1, not available\").arg(id)));\r\n\r\n    return REQ_NOT_HANDLED;\r\n}\r\n\r\n/*! Parses a JSON string into Schedule object.\r\n    \\return true on success\r\n            false on failure\r\n */\r\nbool DeRestPluginPrivate::jsonToSchedule(const QString &jsonString, Schedule &schedule, ApiResponse *rsp)\r\n{\r\n    bool ok;\r\n    QVariant var = Json::parse(jsonString, ok);\r\n    QVariantMap map = var.toMap();\r\n\r\n    if (!ok || map.isEmpty())\r\n    {\r\n        if (rsp)\r\n        {\r\n            rsp->list.append(errorToMap(ERR_INVALID_JSON, QString(\"/schedules\"), QString(\"body contains invalid JSON\")));\r\n            rsp->httpStatus = HttpStatusBadRequest;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // check required parameters\r\n    if (!(map.contains(\"command\") && (map.contains(\"time\") || map.contains(\"localtime\"))))\r\n    {\r\n        if (rsp)\r\n        {\r\n            rsp->list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/schedules\"), QString(\"missing parameters in body\")));\r\n            rsp->httpStatus = HttpStatusBadRequest;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // name\r\n    if (map.contains(\"name\") && (map[\"name\"].type() == QVariant::String) && (map[\"name\"].toString().length() <= 32))\r\n    {\r\n        schedule.name = map[\"name\"].toString();\r\n\r\n        std::vector<Schedule>::const_iterator i = schedules.begin();\r\n        std::vector<Schedule>::const_iterator end = schedules.end();\r\n\r\n        for (; i != end; ++i)\r\n        {\r\n            if (i->name == schedule.name)\r\n            {   // append a number to prevent duplicated names\r\n                schedule.name.append(QString(\" %1\").arg(schedules.size() + 1));\r\n                break;\r\n            }\r\n        }\r\n    } // else use default name \"schedule\"\r\n\r\n    // description\r\n    if (map.contains(\"description\") && (map[\"description\"].type() == QVariant::String) && (map[\"description\"].toString().length() <= 64))\r\n    {\r\n        schedule.description = map[\"description\"].toString();\r\n    } // else ignore use empty description\r\n\r\n    // command\r\n    DBG_Assert(map.contains(\"command\"));\r\n    if (map.contains(\"command\") && (map[\"command\"].type() == QVariant::Map))\r\n    {\r\n        QVariantMap cmd = map[\"command\"].toMap();\r\n\r\n        if (cmd.isEmpty() || !cmd.contains(\"address\") || !cmd.contains(\"method\") || !cmd.contains(\"body\"))\r\n        {\r\n            if (rsp)\r\n            {\r\n                rsp->list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter command\").arg(map[\"command\"].toString())));\r\n                rsp->httpStatus = HttpStatusBadRequest;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        schedule.command = Json::serialize(cmd);\r\n    }\r\n    else\r\n    {\r\n        if (rsp)\r\n        {\r\n            rsp->list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter command\").arg(map[\"command\"].toString())));\r\n            rsp->httpStatus = HttpStatusBadRequest;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // status\r\n    if (map.contains(\"status\") && (map[\"status\"].type() == QVariant::String) && ((map[\"status\"].toString() == \"enabled\") || (map[\"status\"].toString() == \"disabled\")))\r\n    {\r\n        schedule.status = map[\"status\"].toString();\r\n        if (schedule.status == QLatin1String(\"disabled\"))\r\n        {\r\n            schedule.endtime = QDateTime();\r\n        }\r\n    }// else status enabled is used\r\n\r\n    // activation\r\n    if (map.contains(\"activation\") && (map[\"activation\"].type() == QVariant::String) && ((map[\"activation\"].toString() == \"start\") || (map[\"activation\"].toString() == \"end\")))\r\n    {\r\n        schedule.activation = map[\"activation\"].toString();\r\n    }// else activation start is used\r\n\r\n    // autodelete\r\n    if (map.contains(\"autodelete\") && (map[\"autodelete\"].type() == QVariant::Bool))\r\n    {\r\n        schedule.autodelete = map[\"autodelete\"].toBool();\r\n    }// else autodelete true is used\r\n\r\n    // time\r\n    QString time;\r\n    Qt::TimeSpec timeSpec = Qt::UTC;\r\n    int randomTime = 0;\r\n    int randomMax = 0;\r\n\r\n    // time (deprecated)\r\n    if (map.contains(\"time\") && (map[\"time\"].type() == QVariant::String))\r\n    {\r\n        schedule.time = map[\"time\"].toString();\r\n        time = schedule.time;\r\n        timeSpec = Qt::UTC;\r\n    }\r\n\r\n    // localtime (overwrites UTC)\r\n    if (map.contains(\"localtime\") && (map[\"localtime\"].type() == QVariant::String))\r\n    {\r\n        schedule.localtime = map[\"localtime\"].toString();\r\n        time = schedule.localtime;\r\n        timeSpec = Qt::LocalTime;\r\n    }\r\n\r\n    if (time.isEmpty())\r\n    {\r\n        DBG_Assert(map.contains(\"time\") || map.contains(\"localtime\"));\r\n        if (rsp)\r\n        {\r\n            rsp->list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/schedules\"), QString(\"missing parameter time or localtime\")));\r\n            rsp->httpStatus = HttpStatusBadRequest;\r\n        }\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        //schedule.time = map[\"time\"].toString();\r\n\r\n        // Timer with random element\r\n        // PT[hh]:[mm]:[ss]A[hh]:[mm]:[ss]\r\n        // if (time.startsWith(\"PT\") && time.contains(\"A\"))\r\n        //{\r\n//            schedule.type = Schedule::TypeTimer;\r\n        //}\r\n        // Recurring timer with random element\r\n        // R[nn]/PT[hh]:[mm]:[ss]A[hh]:[mm]:[ss]\r\n        //else if (time.startsWith(\"R\") && time.contains(\"PT\") && time.contains(\"A\"))\r\n        //{\r\n//            schedule.type = Schedule::TypeTimer;\r\n        //}\r\n        // Recurring timer\r\n        // R[nn]/PT[hh]:[mm]:[ss]\r\n        if (time.contains(\"A\"))\r\n        {\r\n            // cutoff random part, A[hh]:[mm]:[ss] (it will be added later)\r\n            QStringList ls = time.split(\"A\");\r\n\r\n            if (ls.size() == 2)\r\n            {\r\n                DBG_Printf(DBG_INFO, \"random part: %s\\n\", qPrintable(ls[1]));\r\n                time = ls.first();\r\n            }\r\n\r\n            QRegExp rnd(\"(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n            if (rnd.exactMatch(ls[1]))\r\n            {\r\n                randomMax = rnd.cap(1).toInt() * 60 * 60 + // h\r\n                    rnd.cap(2).toInt() * 60 +   // m\r\n                    rnd.cap(3).toInt(); // s\r\n\r\n                if (randomMax == 0)\r\n                {\r\n                    randomTime = 0;\r\n                }\r\n                else\r\n                {\r\n                    randomTime = (U_rand32() % ((randomMax + 1) - 1) + 1);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (rsp)\r\n                {\r\n                    rsp->list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for random part of parameter time\").arg(map[\"time\"].toString())));\r\n                    rsp->httpStatus = HttpStatusBadRequest;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        if (time.startsWith(\"R\") && time.contains(\"PT\"))\r\n        {\r\n            QRegExp rx(\"R([0-9]{0,2})/PT(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n            if (rx.exactMatch(time))\r\n            {\r\n                // offset always from current localtime?\r\n                schedule.timeout = rx.cap(2).toInt() * 60 * 60 + // h\r\n                                   rx.cap(3).toInt() * 60 +   // m\r\n                                   rx.cap(4).toInt() + // s\r\n                                   randomTime; // randomTime in seconds\r\n                schedule.currentTimeout = schedule.timeout;\r\n                QDateTime now = QDateTime::currentDateTimeUtc();\r\n                schedule.starttime = now.toString(QLatin1String(\"yyyy-MM-ddThh:mm:ss\"));\r\n                if (schedule.status == QLatin1String(\"enabled\"))\r\n                {\r\n                    if (timeSpec == Qt::UTC)\r\n                    {\r\n                        schedule.endtime = QDateTime::currentDateTimeUtc().addSecs(schedule.timeout);\r\n                        int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                        schedule.endtime = schedule.endtime.addSecs(toffset);\r\n                        schedule.endtime.setOffsetFromUtc(toffset);\r\n                        schedule.endtime.setTimeSpec(Qt::LocalTime);\r\n                    }\r\n                    else if (timeSpec == Qt::LocalTime)\r\n                    {\r\n                        schedule.endtime = QDateTime::currentDateTime().addSecs(schedule.timeout);\r\n                    }\r\n                }\r\n\r\n                QString R = rx.cap(1);\r\n                if (!R.isEmpty())\r\n                {\r\n                    schedule.recurring = R.toUInt();\r\n                }\r\n                else\r\n                {\r\n                    schedule.recurring = 0; // runs forever\r\n                }\r\n\r\n                if (schedule.timeout > 0)\r\n                {\r\n                    schedule.type = Schedule::TypeTimer;\r\n                }\r\n            }\r\n        }\r\n        // Timer expiring at given time\r\n        // PT[hh]:[mm]:[ss]\r\n        else if (time.startsWith(\"PT\"))\r\n        {\r\n            QRegExp rx(\"PT(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n            if (rx.exactMatch(time))\r\n            {\r\n                // offset always from current localtime?\r\n                schedule.timeout = rx.cap(1).toInt() * 60 * 60 + // h\r\n                                   rx.cap(2).toInt() * 60 +   // m\r\n                                   rx.cap(3).toInt() + // s\r\n                                   randomTime; // randomTime in seconds\r\n                schedule.currentTimeout = schedule.timeout;\r\n                schedule.recurring = 1;\r\n                QDateTime now = QDateTime::currentDateTimeUtc();\r\n                schedule.starttime = now.toString(\"yyyy-MM-ddThh:mm:ss\");\r\n                if (schedule.status == QLatin1String(\"enabled\"))\r\n                {\r\n                    if (timeSpec == Qt::UTC)\r\n                    {\r\n                        schedule.endtime = QDateTime::currentDateTimeUtc().addSecs(schedule.timeout);\r\n                        int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                        schedule.endtime = schedule.endtime.addSecs(toffset);\r\n                        schedule.endtime.setOffsetFromUtc(toffset);\r\n                        schedule.endtime.setTimeSpec(Qt::LocalTime);\r\n                    }\r\n                    else if (timeSpec == Qt::LocalTime)\r\n                    {\r\n                        schedule.endtime = QDateTime::currentDateTime().addSecs(schedule.timeout);\r\n                    }\r\n                }\r\n\r\n                if (schedule.timeout > 0)\r\n                {\r\n                    schedule.type = Schedule::TypeTimer;\r\n                }\r\n            }\r\n        }\r\n        // Every weekday given by bbb at given left side time, randomized by right side time.\r\n        // Right side time has to be smaller than 12 hours\r\n        // W[bbb]/T[hh]:[mm]:[ss]A[hh]:[mm]:[ss]\r\n        else if (time.startsWith(\"W\") && time.contains(\"T\") && time.contains(\"A\"))\r\n        {\r\n//            schedule.type = Schedule::TypeRecurringTime;\r\n        }\r\n        // Every day of the week  given by bbb at given time\r\n        // W[bbb]/T[hh]:[mm]:[ss]\r\n        else if (time.startsWith(\"W\") && time.contains(\"T\"))\r\n        {\r\n            QRegExp rx(\"W([0-9]{1,3})/T(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n            if (randomTime > 43200) {\r\n                randomTime = 43200; // random time has to be smaller than 12 hours\r\n            }\r\n\r\n            if (rx.exactMatch(time))\r\n            {\r\n                schedule.type = Schedule::TypeRecurringTime;\r\n                schedule.weekBitmap = rx.cap(1).toUInt();\r\n\r\n                if (timeSpec == Qt::UTC)\r\n                {\r\n                    schedule.datetime = QDateTime::currentDateTimeUtc();\r\n                }\r\n                else\r\n                {\r\n                    schedule.datetime = QDateTime::currentDateTime();\r\n                }\r\n                schedule.datetime.setTime(QTime(rx.cap(2).toUInt(),   // h\r\n                                                rx.cap(3).toUInt(),   // m\r\n                                                rx.cap(4).toUInt())); // s\r\n                schedule.datetime = schedule.datetime.addSecs(randomTime);\r\n\r\n                // conversion to localtime\r\n                if (timeSpec == Qt::UTC)\r\n                {\r\n                    int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                    schedule.datetime = schedule.datetime.addSecs(toffset);\r\n                    schedule.datetime.setOffsetFromUtc(toffset);\r\n                    schedule.datetime.setTimeSpec(Qt::LocalTime);\r\n                }\r\n            }\r\n        }\r\n        // Absolute time\r\n        else\r\n        {\r\n            schedule.datetime = QDateTime::fromString(time, Qt::ISODate);\r\n            schedule.datetime.setTimeSpec(timeSpec);\r\n            schedule.datetime = schedule.datetime.addSecs(randomTime);\r\n\r\n            // conversion to localtime\r\n            if (timeSpec == Qt::UTC)\r\n            {\r\n                int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                schedule.datetime = schedule.datetime.addSecs(toffset);\r\n                schedule.datetime.setOffsetFromUtc(toffset);\r\n                schedule.datetime.setTimeSpec(Qt::LocalTime);\r\n            }\r\n\r\n            if (schedule.time.isEmpty())\r\n            {\r\n                schedule.time = schedule.datetime.toUTC().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n            }\r\n\r\n            if (schedule.localtime.isEmpty())\r\n            {\r\n                schedule.localtime = schedule.datetime.toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n            }\r\n\r\n            schedule.endtime = QDateTime();\r\n            if (schedule.datetime.isValid())\r\n            {\r\n                schedule.endtime = schedule.datetime;\r\n                schedule.type = Schedule::TypeAbsoluteTime;\r\n            }\r\n        }\r\n\r\n        if (schedule.type == Schedule::TypeInvalid)\r\n        {\r\n            if (rsp)\r\n            {\r\n                rsp->list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/schedules\"), QString(\"invalid value, %1, for parameter time\").arg(map[\"time\"].toString())));\r\n                rsp->httpStatus = HttpStatusBadRequest;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    updateEtag(schedule.etag);\r\n    map[\"etag\"] = schedule.etag.remove('\"'); // no quotes allowed in string\r\n\r\n    if (rsp)\r\n    {\r\n        map[\"created\"] = QDateTime::currentDateTimeUtc().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\r\n    }\r\n    schedule.jsonString = Json::serialize(map);\r\n    schedule.jsonMap = map;\r\n\r\n    return true;\r\n}\r\n\r\n/*! Processes any schedules.\r\n */\r\nvoid DeRestPluginPrivate::scheduleTimerFired()\r\n{\r\n    if (schedules.empty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    std::vector<Schedule>::iterator i = schedules.begin();\r\n    std::vector<Schedule>::iterator end = schedules.end();\r\n\r\n    QDateTime now = QDateTime::currentDateTime();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        if (i->state != Schedule::StateNormal ||\r\n            i->status != QLatin1String(\"enabled\"))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        qint64 diff = 0;\r\n\r\n        if (i->type == Schedule::TypeAbsoluteTime)\r\n        {\r\n            if (i->endtime.isValid())\r\n            {\r\n                diff = now.secsTo(i->datetime);\r\n            }\r\n        }\r\n        else if (i->type == Schedule::TypeTimer)\r\n        {\r\n            if (i->endtime.isValid() && i->endtime > now)\r\n            {\r\n                DBG_Printf(DBG_INFO, \"schedule %s timeout in %d s\\n\", qPrintable(i->id), (int)now.secsTo(i->endtime));\r\n                continue;\r\n            }\r\n            else if (i->endtime.isValid())\r\n            {\r\n                diff = now.secsTo(i->endtime);\r\n                if (i->recurring != 1)\r\n                {\r\n                    i->endtime = now.addSecs(i->timeout);\r\n                }\r\n            }\r\n\r\n            if (i->recurring == 1)\r\n            {\r\n                // last trigger\r\n                if (i->autodelete)\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"schedule %s deleted\\n\", qPrintable(i->name));\r\n                    i->state = Schedule::StateDeleted;\r\n                }\r\n                else\r\n                {\r\n                    DBG_Printf(DBG_INFO, \"schedule %s disabled\\n\", qPrintable(i->name));\r\n                    i->status = QLatin1String(\"disabled\");\r\n                    i->jsonMap[\"status\"] = i->status;\r\n                    i->jsonString = Json::serialize(i->jsonMap);\r\n                }\r\n                queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n            }\r\n            else if (i->recurring > 0)\r\n            {\r\n                i->recurring--;\r\n            }\r\n        }\r\n        else if (i->type == Schedule::TypeRecurringTime)\r\n        {\r\n            // bbb = 0MTWTFSS – So only Tuesdays is 00100000 = 32\r\n            quint8 day = now.date().dayOfWeek(); // Mon-Sun: 1-7\r\n            quint8 bit = (1 << (7 - day));\r\n\r\n            if (i->weekBitmap & bit)\r\n            {\r\n                //DBG_Printf(DBG_INFO, \"actual day\\n\");\r\n\r\n                if (i->lastTriggerDatetime.date() .isValid() &&\r\n                    i->lastTriggerDatetime.date() == now.date())\r\n                {\r\n                    //recurring alarm should trigger again on same day if updated with future time\r\n                    if (i->datetime.time() <= now.time())\r\n                    {\r\n                        // already fired today\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                diff = now.time().secsTo(i->datetime.time());\r\n\r\n                if (diff > 0)\r\n                {\r\n                    DBG_Printf(DBG_INFO_L2, \"schedule %s diff %lld, %s\\n\", qPrintable(i->id), diff, qPrintable(i->datetime.toString()));\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                continue;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // not supported yet\r\n            i->state = Schedule::StateDeleted;\r\n            queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n            continue;\r\n        }\r\n\r\n        if (diff <= -5 && i->type != Schedule::TypeRecurringTime)\r\n        {\r\n            i->status = QLatin1String(\"disabled\");\r\n            i->jsonMap[\"status\"] = i->status;\r\n            i->jsonString = Json::serialize(i->jsonMap);\r\n            if (i->autodelete)\r\n            {\r\n                DBG_Printf(DBG_INFO, \"schedule %s: %s deleted (too old)\\n\", qPrintable(i->id), qPrintable(i->name));\r\n                i->state = Schedule::StateDeleted;\r\n            }\r\n            else\r\n            {\r\n                DBG_Printf(DBG_INFO, \"schedule %s: %s disabled (too old)\\n\", qPrintable(i->id), qPrintable(i->name));\r\n            }\r\n            queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n            continue;\r\n        }\r\n\r\n        if (diff <= -5 && i->type == Schedule::TypeRecurringTime) //do nothing and trigger alarm next week\r\n        {\r\n            continue;\r\n        }\r\n        else if (diff <= 0)\r\n        {\r\n            i->lastTriggerDatetime = now;\r\n            DBG_Printf(DBG_INFO, \"schedule %s: %s trigger\\n\", qPrintable(i->id), qPrintable(i->name));\r\n\r\n            if (i->type == Schedule::TypeAbsoluteTime)\r\n            {\r\n                if (i->autodelete)\r\n                {\r\n                    i->state = Schedule::StateDeleted;\r\n                    DBG_Printf(DBG_INFO, \"schedule %s removed\\n\", qPrintable(i->id));\r\n                }\r\n                else\r\n                {\r\n                    i->status = QLatin1String(\"disabled\");\r\n                    i->jsonMap[\"status\"] = i->status;\r\n                    i->jsonString = Json::serialize(i->jsonMap);\r\n                }\r\n                queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n            }\r\n\r\n            // randomize time again\r\n            if (i->type == Schedule::TypeRecurringTime || i->type == Schedule::TypeTimer)\r\n            {\r\n                if (i->time.contains((\"A\")) || i->localtime.contains(\"A\"))\r\n                {\r\n                    QString time = \"\";\r\n                    Qt::TimeSpec timeSpec = Qt::UTC;\r\n                    int randomMax = 0;\r\n                    int randomTime = 0;\r\n                    if (i->time.contains(\"A\"))\r\n                    {\r\n                        time = i->time;\r\n                        timeSpec = Qt::UTC;\r\n                    }\r\n                    if (i->localtime.contains(\"A\"))\r\n                    {\r\n                        time = i->localtime;\r\n                        timeSpec = Qt::LocalTime;\r\n                    }\r\n\r\n                    // cutoff random part, A[hh]:[mm]:[ss] (it will be added later)\r\n                    QStringList ls = time.split(\"A\");\r\n\r\n                    if (ls.size() == 2)\r\n                    {\r\n                        DBG_Printf(DBG_INFO, \"random part: %s\\n\", qPrintable(ls[1]));\r\n                        time = ls.first();\r\n                    }\r\n\r\n                    QRegExp rnd(\"(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n                    if (rnd.exactMatch(ls[1]))\r\n                    {\r\n                        randomMax = rnd.cap(1).toInt() * 60 * 60 + // h\r\n                            rnd.cap(2).toInt() * 60 +   // m\r\n                            rnd.cap(3).toInt(); // s\r\n\r\n                        if (randomMax == 0)\r\n                        {\r\n                            randomTime = 0;\r\n                        }\r\n                        else\r\n                        {\r\n                            randomTime = (U_rand32() % ((randomMax + 1) - 1) + 1);\r\n                        }\r\n                    }\r\n\r\n                    if (randomTime > 43200) {\r\n                        randomTime = 43200; // random time has to be smaller than 12 hours\r\n                    }\r\n\r\n                    if (timeSpec == Qt::UTC)\r\n                    {\r\n                        i->datetime = QDateTime::currentDateTimeUtc();\r\n                    }\r\n                    else\r\n                    {\r\n                        i->datetime = QDateTime::currentDateTime();\r\n                    }\r\n\r\n                    QRegExp rx(\"W([0-9]{1,3})/T(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)\");\r\n\r\n                    if (rx.exactMatch(time))\r\n                    {\r\n                        i->datetime.setTime(QTime(rx.cap(2).toUInt(),   // h\r\n                                                  rx.cap(3).toUInt(),   // m\r\n                                                  rx.cap(4).toUInt())); // s\r\n                        i->datetime = i->datetime.addSecs(randomTime);\r\n\r\n                        // conversion to localtime\r\n                        if (timeSpec == Qt::UTC)\r\n                        {\r\n                            int toffset = QDateTime::currentDateTime().offsetFromUtc();\r\n                            i->datetime = i->datetime.addSecs(toffset);\r\n                            i->datetime.setOffsetFromUtc(toffset);\r\n                            i->datetime.setTimeSpec(Qt::LocalTime);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            QVariantMap cmd = i->jsonMap[\"command\"].toMap();\r\n\r\n            // check if fields are given\r\n            if (cmd.isEmpty() || !cmd.contains(\"address\") || !cmd.contains(\"method\") || !cmd.contains(\"body\"))\r\n            {\r\n                DBG_Printf(DBG_INFO, \"schedule %s ignored, invalid command %s\\n\",  qPrintable(i->id), qPrintable(i->command));\r\n                return;\r\n            }\r\n            QString method = cmd[\"method\"].toString();\r\n            QString address = cmd[\"address\"].toString();\r\n            QString content = Json::serialize(cmd[\"body\"].toMap());\r\n\r\n            // check if fields contain data\r\n            if (method.isEmpty() || address.isEmpty() || content.isEmpty())\r\n            {\r\n                i->state = Schedule::StateDeleted;\r\n                queSaveDb(DB_SCHEDULES, DB_SHORT_SAVE_DELAY);\r\n                DBG_Printf(DBG_INFO, \"schedule %s ignored and removed, invalid command %s\\n\", qPrintable(i->id), qPrintable(i->command));\r\n                return;\r\n            }\r\n\r\n            QHttpRequestHeader hdr(method, address);\r\n            QStringList path = QString(hdr.path()).split('/', SKIP_EMPTY_PARTS);\r\n\r\n            ApiRequest req(hdr, path, nullptr, content);\r\n            ApiResponse rsp; // dummy\r\n            rsp.httpStatus = HttpStatusOk;\r\n\r\n            DBG_Printf(DBG_INFO, \"schedule %s body: %s\\n\",  qPrintable(i->id), qPrintable(content));\r\n\r\n            if (handleLightsApi(req, rsp) == REQ_NOT_HANDLED)\r\n            {\r\n                if (handleGroupsApi(req, rsp) == REQ_NOT_HANDLED)\r\n                {\r\n                    if (handleSensorsApi(req, rsp) == REQ_NOT_HANDLED)\r\n                    {\r\n                        DBG_Printf(DBG_INFO, \"schedule was neither light nor group nor sensor request.\\n\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (rsp.httpStatus != HttpStatusOk && DBG_IsEnabled(DBG_INFO) && rsp.list.size() > 0)\r\n            {\r\n                QString err = Json::serialize(rsp.list);\r\n                DBG_Printf(DBG_INFO, \"schedule failed: %s %s\\n\", rsp.httpStatus, qPrintable(err));\r\n            }\r\n\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            DBG_Printf(DBG_INFO, \"schedule %s diff %lld, %s\\n\", qPrintable(i->id), diff, qPrintable(i->datetime.toString()));\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "name": "rest_sensors.cpp",
          "type": "blob",
          "size": 159.6171875,
          "content": "/*\n * Copyright (c) 2013-2019 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n#include <QTextCodec>\n#include <QTcpSocket>\n#include <QUrlQuery>\n#include <QVariantMap>\n#include <QtCore/qmath.h>\n#include \"database.h\"\n#include \"device_descriptions.h\"\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"json.h\"\n#include \"product_match.h\"\n#include \"fan_control.h\"\n#include \"ias_ace.h\"\n#include \"simple_metering.h\"\n#include \"thermostat.h\"\n#include \"thermostat_ui_configuration.h\"\n#include \"tuya.h\"\n#include \"utils/utils.h\"\n\n/*! In a DDF a sub device can specify valid keyvalue pairs for a ResourceItem.suffix in the meta object.\n\n    Example of Ikea Starkvind:\n\n    \"meta\": {\n      \"values\": {\n        \"config/mode\": {\"off\": 0, \"auto\": 1, \"speed_1\": 10, \"speed_2\": 20, \"speed_3\": 30, \"speed_4\": 40, \"speed_5\": 50}\n      }\n    }\n\n    This function returns the map for the ResourceItem.\n*/\nstatic QVariantMap DDF_GetMetaKeyValues(const Resource *r, const ResourceItem *item)\n{\n    QVariantMap m;\n\n    if (!r || !item)\n    {\n        return m;\n    }\n\n    auto *dd = DeviceDescriptions::instance();\n    const auto &sub = dd->getSubDevice(r);\n\n    const QLatin1String kvalues(\"values\");\n    const QLatin1String ksuffix(item->descriptor().suffix);\n\n    if (sub.isValid() && sub.meta.contains(kvalues))\n    {\n        m = sub.meta.value(kvalues).toMap();\n        if (m.contains(ksuffix))\n        {\n            m = m.value(ksuffix).toMap();\n        }\n    }\n\n    return m;\n}\n\n/*! Sensors REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleSensorsApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.path[2] != QLatin1String(\"sensors\"))\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // GET /api/<apikey>/sensors\n    if ((req.path.size() == 3) && (req.hdr.method() == QLatin1String(\"GET\")))\n    {\n        return getAllSensors(req, rsp);\n    }\n    // GET /api/<apikey>/sensors/new\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[3] == QLatin1String(\"new\")))\n    {\n        return getNewSensors(req, rsp);\n    }\n    // GET /api/<apikey>/sensors/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"GET\")))\n    {\n        return getSensor(req, rsp);\n    }\n    // GET /api/<apikey>/sensors/<id>/data?maxrecords=<maxrecords>&fromtime=<ISO 8601>\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"GET\")) && (req.path[4] == QLatin1String(\"data\")))\n    {\n        return getSensorData(req, rsp);\n    }\n    // POST /api/<apikey>/sensors\n    else if ((req.path.size() == 3) && (req.hdr.method() == QLatin1String(\"POST\")))\n    {\n        bool ok;\n        QVariant var = Json::parse(req.content, ok);\n        QVariantMap map = var.toMap();\n\n        if (map.isEmpty())\n        {\n            return searchNewSensors(req, rsp);\n        }\n        else\n        {\n            return createSensor(req, rsp);\n        }\n    }\n    // PUT, PATCH /api/<apikey>/sensors/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"PUT\") || req.hdr.method() == QLatin1String(\"PATCH\")))\n    {\n        return updateSensor(req, rsp);\n    }\n    // DELETE /api/<apikey>/sensors/<id>\n    else if ((req.path.size() == 4) && (req.hdr.method() == QLatin1String(\"DELETE\")))\n    {\n        return deleteSensor(req, rsp);\n    }\n    // PUT, PATCH /api/<apikey>/sensors/<id>/config\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\") || req.hdr.method() == QLatin1String(\"PATCH\")) && (req.path[4] == QLatin1String(\"config\")))\n    {\n        return changeSensorConfig(req, rsp);\n    }\n    // PUT, PATCH /api/<apikey>/sensors/<id>/state\n    else if ((req.path.size() == 5) && (req.hdr.method() == QLatin1String(\"PUT\") || req.hdr.method() == QLatin1String(\"PATCH\")) && (req.path[4] == QLatin1String(\"state\")))\n    {\n        return changeSensorState(req, rsp);\n    }\n    // POST, DELETE /api/<apikey>/sensors/<id>/config/schedule/Wbbb\n    else if ((req.path.size() == 7) && (req.hdr.method() == QLatin1String(\"POST\") || req.hdr.method() == QLatin1String(\"DELETE\")) && (req.path[4] == QLatin1String(\"config\")) && (req.path[5] == QLatin1String(\"schedule\")))\n    {\n        return changeThermostatSchedule(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! GET /api/<apikey>/sensors\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getAllSensors(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n    rsp.httpStatus = HttpStatusOk;\n\n    // handle ETag\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\n    {\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\n\n        if (gwSensorsEtag == etag)\n        {\n            rsp.httpStatus = HttpStatusNotModified;\n            rsp.etag = etag;\n            return REQ_READY_SEND;\n        }\n    }\n\n    std::vector<Sensor>::iterator i = sensors.begin();\n    std::vector<Sensor>::iterator end = sensors.end();\n\n    for (; i != end; ++i)\n    {\n        // ignore deleted sensors\n        if (i->deletedState() == Sensor::StateDeleted)\n        {\n            continue;\n        }\n\n        if (i->modelId().isEmpty())\n        {\n            continue;\n        }\n\n        QVariantMap map;\n        if (sensorToMap(&*i, map, req))\n        {\n            rsp.map[i->id()] = map;\n        }\n    }\n\n    if (rsp.map.isEmpty())\n    {\n        rsp.str = QLatin1String(\"{}\"); // return empty object\n    }\n\n    rsp.etag = gwSensorsEtag;\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/sensors/<id>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getSensor(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n\n    if (req.path.size() != 4)\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    const QString &id = req.path[3];\n\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    // handle ETag\n    if (req.hdr.hasKey(QLatin1String(\"If-None-Match\")))\n    {\n        QString etag = req.hdr.value(QLatin1String(\"If-None-Match\"));\n\n        if (sensor->etag == etag)\n        {\n            rsp.httpStatus = HttpStatusNotModified;\n            rsp.etag = etag;\n            return REQ_READY_SEND;\n        }\n    }\n\n    sensorToMap(sensor, rsp.map, req);\n    rsp.httpStatus = HttpStatusOk;\n    rsp.etag = sensor->etag;\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/sensors/<id>/data?maxrecords=<maxrecords>&fromtime=<ISO 8601>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getSensorData(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 5);\n\n    if (req.path.size() != 5)\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    QString id = req.path[3];\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1/\").arg(id), QString(\"resource, /sensors/%1/, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    bool ok;\n    QUrl url(req.hdr.url());\n    QUrlQuery query(url);\n\n    const int maxRecords = query.queryItemValue(QLatin1String(\"maxrecords\")).toInt(&ok);\n    if (!ok || maxRecords <= 0)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/maxrecords\"), QString(\"invalid value, %1, for parameter, maxrecords\").arg(query.queryItemValue(\"maxrecords\"))));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    QString t = query.queryItemValue(QLatin1String(\"fromtime\"));\n    QDateTime dt = QDateTime::fromString(t, QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\n    if (!dt.isValid())\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/fromtime\"), QString(\"invalid value, %1, for parameter, fromtime\").arg(query.queryItemValue(\"fromtime\"))));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    const qint64 fromTime = dt.toMSecsSinceEpoch() / 1000;\n\n    openDb();\n    loadSensorDataFromDb(sensor, rsp.list, fromTime, maxRecords);\n    closeDb();\n\n    if (rsp.list.isEmpty())\n    {\n        rsp.str = QLatin1String(\"[]\"); // return empty list\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/sensors\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::createSensor(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    bool ok;\n    QVariant var = Json::parse(req.content, ok);\n    const QVariantMap map = var.toMap();\n    const QString type = map[QLatin1String(\"type\")].toString();\n    Sensor sensor;\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QLatin1String(\"/sensors\"), QLatin1String(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    userActivity();\n\n    if (sensors.size() >= MAX_SENSORS)\n    {\n        rsp.list.append(errorToMap(ERR_SENSOR_LIST_FULL, QLatin1String(\"/sensors/\"), QString(\"The Sensor List has reached its maximum capacity of %1 sensors\").arg(MAX_SENSORS)));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    //check required parameter\n    if (!map.contains(QLatin1String(\"name\")) || !map.contains(QLatin1String(\"modelid\")) || !map.contains(QLatin1String(\"swversion\")) || !map.contains(QLatin1String(\"type\")) || !map.contains(QLatin1String(\"uniqueid\")) || !map.contains(QLatin1String(\"manufacturername\")))\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QLatin1String(\"/sensors\"), QLatin1String(\"invalid/missing parameters in body\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    //check invalid parameter\n    const QStringList allowedAttributes = { \"name\", \"modelid\", \"swversion\", \"type\", \"uniqueid\", \"manufacturername\", \"state\", \"config\", \"recycle\" };\n\n    for (const QString &attr : map.keys())\n    {\n        if (!allowedAttributes.contains(attr))\n        {\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%2\").arg(attr), QString(\"parameter, %1, not available\").arg(attr)));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    if (!type.startsWith(QLatin1String(\"CLIP\")))\n    {\n        rsp.list.append(errorToMap(ERR_NOT_ALLOWED_SENSOR_TYPE, QLatin1String(\"/sensors\"), QLatin1String(\"Not allowed to create sensor type\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n        ResourceItem *item = nullptr;\n        QVariantMap rspItem;\n        QVariantMap rspItemState;\n\n        // create a new sensor id\n        openDb();\n        sensor.setId(QString::number(getFreeSensorId()));\n        closeDb();\n\n        sensor.setName(map[QLatin1String(\"name\")].toString().trimmed());\n        sensor.setManufacturer(map[QLatin1String(\"manufacturername\")].toString());\n        sensor.setModelId(map[QLatin1String(\"modelid\")].toString());\n        sensor.setUniqueId(map[QLatin1String(\"uniqueid\")].toString());\n        sensor.setSwVersion(map[QLatin1String(\"swversion\")].toString());\n        sensor.setType(type);\n\n        sensor.removeItem(RAttrLastAnnounced);\n        sensor.removeItem(RAttrLastSeen);\n\n        if (getSensorNodeForUniqueId(sensor.uniqueId()))\n        {\n            rsp.list.append(errorToMap(ERR_DUPLICATE_EXIST, QLatin1String(\"/sensors\"), QString(\"sensor with uniqueid, %1, already exists\").arg(sensor.uniqueId())));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n\n        if      (type == QLatin1String(\"CLIPAlarm\")) { item = sensor.addItem(DataTypeBool, RStateAlarm); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPBattery\")) { item = sensor.addItem(DataTypeUInt8, RStateBattery); item->setValue(100); }\n        else if (type == QLatin1String(\"CLIPCarbonMonoxide\")) { item = sensor.addItem(DataTypeBool, RStateCarbonMonoxide); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPConsumption\")) { item = sensor.addItem(DataTypeUInt64, RStateConsumption); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPDaylightOffset\")) { item = sensor.addItem(DataTypeInt16, RConfigOffset); item->setValue(0);\n                                                                item = sensor.addItem(DataTypeString, RConfigMode);\n                                                                item = sensor.addItem(DataTypeTime, RStateLocaltime); }\n        else if (type == QLatin1String(\"CLIPFire\")) { item = sensor.addItem(DataTypeBool, RStateFire); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPGenericFlag\")) { item = sensor.addItem(DataTypeBool, RStateFlag); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPGenericStatus\")) { item = sensor.addItem(DataTypeInt32, RStateStatus); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPHumidity\")) { item = sensor.addItem(DataTypeUInt16, RStateHumidity); item->setValue(0);\n                                                          item = sensor.addItem(DataTypeInt16, RConfigOffset); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPLightLevel\")) { item = sensor.addItem(DataTypeUInt16, RStateLightLevel); item->setValue(0);\n                                                            item = sensor.addItem(DataTypeUInt32, RStateLux); item->setValue(0);\n                                                            item = sensor.addItem(DataTypeBool, RStateDark); item->setValue(true);\n                                                            item = sensor.addItem(DataTypeBool, RStateDaylight); item->setValue(false);\n                                                            item = sensor.addItem(DataTypeUInt16, RConfigTholdDark); item->setValue(R_THOLDDARK_DEFAULT);\n                                                            item = sensor.addItem(DataTypeUInt16, RConfigTholdOffset); item->setValue(R_THOLDOFFSET_DEFAULT); }\n        else if (type == QLatin1String(\"CLIPOpenClose\")) { item = sensor.addItem(DataTypeBool, RStateOpen); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPPower\")) { item = sensor.addItem(DataTypeInt16, RStatePower); item->setValue(0);\n                                                       item = sensor.addItem(DataTypeUInt16, RStateVoltage); item->setValue(0);\n                                                       item = sensor.addItem(DataTypeUInt16, RStateCurrent); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPPresence\")) { item = sensor.addItem(DataTypeBool, RStatePresence); item->setValue(false);\n                                                          item = sensor.addItem(DataTypeUInt16, RConfigDuration); item->setValue(60); }\n        else if (type == QLatin1String(\"CLIPPressure\")) { item = sensor.addItem(DataTypeInt16, RStatePressure); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPSwitch\")) { item = sensor.addItem(DataTypeInt32, RStateButtonEvent); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPTemperature\")) { item = sensor.addItem(DataTypeInt16, RStateTemperature); item->setValue(0);\n                                                             item = sensor.addItem(DataTypeInt16, RConfigOffset); item->setValue(0); }\n        else if (type == QLatin1String(\"CLIPVibration\")) { item = sensor.addItem(DataTypeBool, RStateVibration); item->setValue(false); }\n        else if (type == QLatin1String(\"CLIPWater\")) { item = sensor.addItem(DataTypeBool, RStateWater); item->setValue(false); }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/sensors\"), QString(\"invalid value, %1, for parameter, type\").arg(type)));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n\n        //setState optional\n        if (map.contains(QLatin1String(\"state\")))\n        {\n            //check invalid parameter\n            const QVariantMap state = map[QLatin1String(\"state\")].toMap();\n            const QStringList allowedKeys = { \"alarm\", \"battery\", \"buttonevent\", \"carbonmonoxide\", \"consumption\", \"current\", \"fire\", \"flag\", \"humidity\", \"lightlevel\", \"localtime\", \"lowbattery\",\n                                              \"open\", \"presence\", \"pressure\", \"power\", \"status\", \"tampered\", \"temperature\", \"vibration\", \"voltage\", \"water\" };\n\n            const QStringList optionalKeys = { \"lowbattery\", \"tampered\" };\n\n            for  (const auto &key : state.keys())\n            {\n                if (!allowedKeys.contains(key))\n                {\n                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%2\").arg(key), QString(\"parameter, %1, not available\").arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n\n                ResourceItemDescriptor rid;\n                item = nullptr;\n                if (getResourceItemDescriptor(QString(\"state/%1\").arg(key), rid))\n                {\n                    item = sensor.item(rid.suffix);\n\n                    if (!item && optionalKeys.contains(key))\n                    {\n                        item = sensor.addItem(rid.type, rid.suffix);\n                    }\n                }\n\n                if (!item)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/sensors\"), QString(\"parameter, %1, not available\").arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n\n                if (!item->setValue(state.value(key)))\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/sensors/state\"), QString(\"invalid value, %1, for parameter %2\").arg(state.value(key).toString()).arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n            }\n        }\n\n        item = sensor.item(RConfigOn);\n        item->setValue(true); // default\n\n        item = sensor.item(RConfigReachable);\n        item->setValue(true); //default\n\n        //setConfig optional\n        if (map.contains(QLatin1String(\"config\")))\n        {\n            //check invalid parameter\n            const QVariantMap config = map[QLatin1String(\"config\")].toMap();\n            const QStringList allowedKeys = { \"battery\", \"duration\", \"delay\", \"mode\", \"offset\", \"on\", \"reachable\", \"url\" };\n            const QStringList optionalKeys = { \"battery\", \"url\" };\n\n            for  (const auto &key : config.keys())\n            {\n                if (!allowedKeys.contains(key))\n                {\n                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%2\").arg(key), QString(\"parameter, %1, not available\").arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n\n                ResourceItemDescriptor rid;\n                item = nullptr;\n                if (getResourceItemDescriptor(QString(\"config/%1\").arg(key), rid))\n                {\n                    item = sensor.item(rid.suffix);\n\n                    if (!item && optionalKeys.contains(key))\n                    {\n                        item = sensor.addItem(rid.type, rid.suffix);\n                    }\n                }\n\n                if (!item)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/sensors\"), QString(\"parameter, %1, not available\").arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n\n                if (!item->setValue(config.value(key)))\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QLatin1String(\"/sensors/config\"), QString(\"invalid value, %1, for parameter %2\").arg(config.value(key).toString()).arg(key)));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n            }\n        }\n        updateSensorEtag(&sensor);\n        sensor.setNeedSaveDatabase(true);\n        sensors.push_back(sensor);\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n\n        rspItemState[QLatin1String(\"id\")] = sensor.id();\n        rspItem[QLatin1String(\"success\")] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusOk;\n        return REQ_READY_SEND;\n}\n\n/*! PUT, PATCH /api/<apikey>/sensors/<id>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::updateSensor(const ApiRequest &req, ApiResponse &rsp)\n{\n    const QLatin1String id = req.hdr.pathAt(3);\n    Sensor *sensor = id.size() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n    bool ok;\n    const QVariantMap map = Json::parse(req.content, ok).toMap();\n\n    rsp.httpStatus = HttpStatusOk;\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QLatin1String(\"/sensors\"), QLatin1String(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        return REQ_READY_SEND;\n    }\n\n    if (req.sock)\n    {\n        userActivity();\n    }\n\n    {   //check invalid parameter\n        auto pi = map.cbegin();\n        const auto pend = map.cend();\n\n        const std::array<QLatin1String, 3> modifiableAttributes { QLatin1String(\"name\"), QLatin1String(\"mode\"), QLatin1String(\"config\") };\n\n        for (; pi != pend; ++pi)\n        {\n            const auto i = std::find_if(modifiableAttributes.cbegin(), modifiableAttributes.cend(), [&pi](const auto attr){ return pi.key() == attr; });\n\n            if (i == modifiableAttributes.cend())\n            {\n                ResourceItemDescriptor rid;\n\n                if (getResourceItemDescriptor(QString(\"attr/%1\").arg(pi.key()), rid))\n                {\n                    rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/sensors/%1/%2\").arg(id, pi.key()), QString(\"parameter, %1, not modifiable\").arg(pi.key())));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%1/%2\").arg(id, pi.key()), QString(\"parameter, %1, not available\").arg(pi.key())));\n                rsp.httpStatus = HttpStatusBadRequest;\n                return REQ_READY_SEND;\n            }\n\n            // TODO further checks and clarification.\n            // 'mode' is only available for ZHASwitch sensors and refers to 'attr/mode' (but there is no ResourceItem for it).\n            // Consider moving this to 'config/mode' or 'config/devicemode'?\n            if (pi.key() == QLatin1String(\"mode\") && !sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")))\n            {\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/sensors/%1/%2\").arg(id, pi.key()), QString(\"parameter, %1, not modifiable\").arg(pi.key())));\n                rsp.httpStatus = HttpStatusBadRequest;\n                return REQ_READY_SEND;\n            }\n        }\n    }\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    if (map.contains(QLatin1String(\"name\"))) // optional\n    {\n        const QString name = map[QLatin1String(\"name\")].toString().trimmed();\n\n        if (map[QLatin1String(\"name\")].type() == QVariant::String && !name.isEmpty() && name.size() <= MAX_SENSOR_NAME_LENGTH)\n        {\n            if (sensor->name() != name)\n            {\n                sensor->setName(name);\n                sensor->setNeedSaveDatabase(true);\n                queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                updateSensorEtag(sensor);\n\n                enqueueEvent(Event(RSensors, RAttrName, sensor->id(), sensor->item(RAttrName)));\n            }\n            if (!sensor->type().startsWith(QLatin1String(\"CLIP\")))\n            {\n                pushSensorInfoToCore(sensor);\n            }\n            rspItemState[QString(\"/sensors/%1/name\").arg(id)] = name;\n            rspItem[QLatin1String(\"success\")] = rspItemState;\n            rsp.list.append(rspItem);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/name\").arg(id), QString(\"invalid value, %1, for parameter, /sensors/%2/name\").arg(name).arg(id)));\n            rsp.httpStatus = HttpStatusBadRequest;\n        }\n    }\n\n    if (map.contains(QLatin1String(\"mode\"))) // optional\n    {\n        Sensor::SensorMode mode = (Sensor::SensorMode)map[QLatin1String(\"mode\")].toUInt(&ok);\n\n        if (ok && map[QLatin1String(\"mode\")].type() == QVariant::Double\n            && sensor->modelId().startsWith(QLatin1String(\"SYMFONISK\")) && (mode == Sensor::ModeScenes || mode == Sensor::ModeDimmer))\n        {\n            if (sensor->mode() != mode)\n            {\n                sensor->setNeedSaveDatabase(true);\n                sensor->setMode(mode);\n                queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                updateSensorEtag(sensor);\n            }\n\n            rspItemState[QString(\"/sensors/%1/mode\").arg(id)] = (double)mode;\n            rspItem[QLatin1String(\"success\")] = rspItemState;\n            rsp.list.append(rspItem);\n            updateEtag(sensor->etag);\n            updateEtag(gwConfigEtag);\n            queSaveDb(DB_SENSORS | DB_GROUPS, DB_SHORT_SAVE_DELAY);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/mode\").arg(id), QString(\"invalid value, %1, for parameter, /sensors/%2/mode\").arg((int)mode).arg(id)));\n            rsp.httpStatus = HttpStatusBadRequest;\n        }\n    }\n\n    // TODO this appears to be a hack, check with REST API clients if this is used at all and consider removal\n    if (map.contains(QLatin1String(\"config\"))) // optional\n    {\n        QStringList path = req.path;\n        path.append(QLatin1String(\"config\"));\n        QString content = Json::serialize(map[QLatin1String(\"config\")].toMap());\n        ApiRequest req2(req.hdr, path, NULL, content);\n        return changeSensorConfig(req2, rsp);\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! PUT, PATCH /api/<apikey>/sensors/<id>/config\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::changeSensorConfig(const ApiRequest &req, ApiResponse &rsp)\n{\n    TaskItem task;\n    QString id = req.path[3];\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n    bool ok;\n    bool updated;\n    bool save = false;\n    quint32 hostFlags = 0;\n    bool offsetUpdated = false;\n    qint16 offset = 0;\n    QMap<quint16, quint32> attributeList;\n    bool tholdUpdated = false;\n    quint16 pendingMask = 0;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    rsp.httpStatus = HttpStatusOk;\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QLatin1String(\"/sensors/config\"), QLatin1String(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    Device *device = static_cast<Device*>(sensor->parentResource());\n    Resource *rsub = sensor;\n    bool devManaged = false;\n\n    if (device)\n    {\n        rsub = DEV_GetSubDevice(device, nullptr, sensor->uniqueId());\n        devManaged = device->managed();\n    }\n\n    bool isClip = sensor->type().startsWith(QLatin1String(\"CLIP\"));\n\n    if (req.sock)\n    {\n        userActivity();\n    }\n\n    // set destination parameters\n    task.req.dstAddress() = sensor->address();\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(sensor->fingerPrint().endpoint);\n    task.req.setSrcEndpoint(getSrcEndpoint(sensor, task.req));\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n\n    StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, task.req.dstEndpoint());\n\n    //check invalid parameter\n    auto pi = map.cbegin();\n    const auto pend = map.cend();\n\n    for (; pi != pend; ++pi)\n    {\n        ResourceItemDescriptor rid;\n        ResourceItem *item = nullptr;\n        if (getResourceItemDescriptor(QString(\"config/%1\").arg(pi.key()), rid))\n        {\n            updated = false;\n\n            // Changing these values of zigbee sensors is not allowed, read-only.\n            if (rid.suffix == RConfigPending || rid.suffix == RConfigSensitivityMax || rid.suffix == RConfigHostFlags || rid.suffix == RConfigLastChangeAmount ||\n                rid.suffix == RConfigLastChangeSource || rid.suffix == RConfigLastChangeTime || rid.suffix == RConfigEnrolled ||\n                (!isClip && (rid.suffix == RConfigBattery || rid.suffix == RConfigReachable)))\n            {\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_MODIFIABLE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                           QString(\"parameter, %1, not modifiable\").arg(pi.key())));\n                continue;\n            }\n            //else if (rid.suffix == RConfigDuration && sensor->modelId() == QLatin1String(\"TRADFRI motion sensor\"))\n            //{\n                // duration can be written for ikea motion sensor\n                // values 0, 60 — 600 will be replaced by hardware settings TODO error message\n            //}\n            else\n            {\n                item = sensor->item(rid.suffix);\n            }\n\n            if (item)\n            {\n                QVariant val = map[pi.key()];\n                RestData data = verifyRestData(rid, val);\n\n                if (!data.valid)\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                               QString(\"invalid value, %1, for parameter %2\").arg(map[pi.key()].toString()).arg(pi.key())));\n                    continue;\n                }\n\n                const auto &ddfItem = DDF_GetItem(item);\n\n                if (!ddfItem.writeParameters.isNull())\n                {\n                    const auto writeParam = ddfItem.writeParameters.toMap();\n                    if (writeParam.contains(QLatin1String(\"state.timeout\")))\n                    {\n                        int stateTimeout = writeParam.value(QLatin1String(\"state.timeout\")).toInt(&ok);\n\n                        if (ok && stateTimeout > 0)\n                        {\n                            change.setStateTimeoutMs(1000 * stateTimeout);\n                        }\n                    }\n                    \n                    if (writeParam.contains(QLatin1String(\"change.timeout\")))\n                    {\n                        int changeTimeout = writeParam.value(QLatin1String(\"change.timeout\")).toInt(&ok);\n\n                        if (ok && changeTimeout > 0)\n                        {\n                            change.setChangeTimeoutMs(1000 * changeTimeout);\n                        }\n                    }\n                }\n\n                if (sensor->modelId().startsWith(QLatin1String(\"SPZB\")) && hostFlags == 0) // Eurotronic Spirit\n                {\n                    ResourceItem *item = sensor->item(RConfigHostFlags);\n                    if (item)\n                    {\n                        hostFlags = item->toNumber();\n                    }\n                    else\n                    {\n                        rsp.list.append(errorToMap(ERR_ACTION_ERROR, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                                   QLatin1String(\"Could not set attribute\")));\n                        continue;\n                    }\n                }\n\n                if (rid.suffix == RConfigDeviceMode) // String\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.string);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigClickMode) // String\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.string);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigTholdDark || rid.suffix == RConfigTholdOffset) // Unsigned integer\n                {\n                    tholdUpdated = true;\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigDelay) // Unsigned integer\n                {\n                    if (!devManaged &&\n                        sensor->modelId() == QLatin1String(\"lumi.motion.agl04\"))  // Xiaomi Aqara RTCGQ13LM high precision motion sensor\n                    {\n                        pendingMask |= R_PENDING_DELAY;\n                        sensor->enableRead(WRITE_DELAY);\n                        sensor->setNextReadTime(WRITE_DELAY, QTime::currentTime());\n                    }\n                    else\n                    {\n                        if (devManaged && rsub)\n                        {\n                            change.addTargetValue(rid.suffix, data.uinteger);\n                            rsub->addStateChange(change);\n                        }\n                    }\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigDuration) // Unsigned integer\n                {\n                    if (sensor->modelId() == QLatin1String(\"TRADFRI motion sensor\"))\n                    {\n                        if (data.uinteger < 1 || data.uinteger > 60)\n                        {\n                            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                                       QString(\"invalid value, %1, for parameter %2\").arg(map[pi.key()].toString()).arg(pi.key())));\n                            continue;\n                        }\n                    }\n                    else if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                    }\n\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigLedIndication) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigTriggerDistance) // String\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.string);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigSensitivity) // Unsigned integer\n                {\n                    if (!devManaged)\n                    {\n                        pendingMask |= R_PENDING_SENSITIVITY;\n                        sensor->enableRead(WRITE_SENSITIVITY);\n                        sensor->setNextReadTime(WRITE_SENSITIVITY, QTime::currentTime());\n                        updated = true;\n                    }\n                    else\n                    {\n                        if (rsub)\n                        {\n                            change.addTargetValue(rid.suffix, data.uinteger);\n                            rsub->addStateChange(change);\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigUsertest) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigLat || rid.suffix == RConfigLong) // String\n                {\n                    double coordinate = data.string.toDouble(&ok);\n                    Q_UNUSED(coordinate);\n                    if (!ok || data.string.isEmpty())\n                    {\n                        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                                   QString(\"invalid value, %1, for parameter %2\").arg(map[pi.key()].toString()).arg(pi.key())));\n                        continue;\n                    }\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigSunriseOffset || rid.suffix == RConfigSunsetOffset)\n                {\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigOn) // Boolean\n                {\n                    updated = true;\n                }\n                else if (rid.suffix == RConfigResetPresence) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigDetectionRange) // uint32\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigSelfTest) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigAlert) // String\n                {\n                    const std::array<KeyValMap, 3> RConfigAlertValues = { { {QLatin1String(\"none\"), 0}, {QLatin1String(\"select\"), 2}, {QLatin1String(\"lselect\"), 15} } };\n\n                    const auto match = matchKeyValue(data.string, RConfigAlertValues);\n\n                    if (isValid(match))\n                    {\n                        task.taskType = TaskIdentify;\n                        taskToLocalData(task);\n\n                        if (addTaskIdentify(task, match.value))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigLock) // Boolean\n                {\n                    data.boolean = !data.boolean;     // Flip bool value as 0 means lock and 1 means unlock\n\n                    if (addTaskDoorLockUnlock(task, data.boolean))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigMelody) // Unsigned integer\n                {\n                    if (data.uinteger > 18) { data.uinteger = 18; }\n                    if (data.uinteger < 1) { data.uinteger = 1; }\n\n                    QByteArray tuyaData;\n                    tuyaData.append(static_cast<qint8>(data.uinteger & 0xff));\n\n                    if (sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_MELODY, tuyaData))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigVolume) // Unsigned integer\n                {\n                    if (data.uinteger > 2) { data.uinteger = 2; } // Volume level, max = 2\n\n                    QByteArray tuyaData;\n                    tuyaData.append(static_cast<qint8>(data.uinteger & 0xff));\n\n                    if (sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_ENUM, DP_IDENTIFIER_VOLUME, tuyaData))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigTempMinThreshold || rid.suffix == RConfigTempMaxThreshold || rid.suffix == RConfigHumiMinThreshold || rid.suffix == RConfigHumiMaxThreshold)\n                // Use signed, a temperature can be negative, but untested.\n                {\n                    QByteArray tuyaData = QByteArray(\"\\x00\\x00\\x00\",3);\n                    tuyaData.append(static_cast<qint8>(data.integer));\n                    quint8 dpIdentifier = 0;\n\n                    //if      (data.integer <= -25 || data.integer >= 25) { invalidValue = true; }  // What are the valid boundaries?\n                    if      (rid.suffix == RConfigTempMinThreshold) { dpIdentifier = DP_IDENTIFIER_TRESHOLDTEMPMINI; }\n                    else if (rid.suffix == RConfigTempMaxThreshold) { dpIdentifier = DP_IDENTIFIER_TRESHOLDTEMPMAXI; }\n                    else if (rid.suffix == RConfigHumiMinThreshold) { dpIdentifier = DP_IDENTIFIER_TRESHOLDTHUMIMINI; }\n                    else if (rid.suffix == RConfigHumiMaxThreshold) { dpIdentifier = DP_IDENTIFIER_TRESHOLDHUMIMAXI; }\n\n                    if (sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_VALUE, dpIdentifier, tuyaData))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigOffset) // Signed integer\n                {\n                    offset = data.integer - item->toNumber();\n\n                    data.integer = data.integer / 10;\n\n                    if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\"))\n                    {\n                        QByteArray tuyaData;\n                        bool alternative = false;\n\n                        qint32 offset2 = data.integer / 10;\n\n                        if (offset2 > 6)  { offset2 = 6;  } // offset, min = -60, max = 60\n                        if (offset2 < -6) { offset2 = -6; }\n\n                        if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\")) // Moes\n                        {\n                            if (offset2 < 0)\n                            {\n                                offset2 = 4096 + offset2;\n                            }\n\n                            alternative = true;\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") || // Saswell\n                                 R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                                 R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n                        {\n                            alternative = true;\n                        }\n                        else // others\n                        {\n                            offset2 = offset2 * 10;\n                        }\n\n                        tuyaData.append((qint8)((offset2 >> 24) & 0xff));\n                        tuyaData.append((qint8)((offset2 >> 16) & 0xff));\n                        tuyaData.append((qint8)((offset2 >> 8) & 0xff));\n                        tuyaData.append((qint8)(offset2 & 0xff));\n\n                        if (!alternative)\n                        {\n                            if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_VALUE, DP_IDENTIFIER_THERMOSTAT_CALIBRATION_2, tuyaData)) // Others\n                            {\n                                updated = true;\n                            }\n                        }\n                        else\n                        {\n                            if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_VALUE, DP_IDENTIFIER_THERMOSTAT_CALIBRATION_1, tuyaData)) // Moes and Saswell\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (sensor->type() == \"ZHAThermostat\")\n                    {\n                        if (!devManaged)\n                        {\n                            if (data.integer < -25) { data.integer = -25; }\n                            if (data.integer > 25)  { data.integer = 25; }\n\n                            if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_LOCAL_TEMPERATURE_CALIBRATION, deCONZ::Zcl8BitInt, data.integer))\n                            {\n                                updated = true;\n                            }\n                        }\n                        else if (devManaged && rsub)\n                        {\n                            change.addTargetValue(rid.suffix, data.integer * 10);\n                            rsub->addStateChange(change);\n                            updated = true;\n                        }\n                    }\n                    else\n                    {\n                        offsetUpdated = true;   // Consider offset only for temperature, humidity, and pressure cluster\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigScheduleOn) // Boolean\n                {\n                    if (sensor->modelId() == QLatin1String(\"Thermostat\")) { data.boolean = !data.boolean; } // eCozy, flip true and false\n\n                    if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_THERMOSTAT_PROGRAMMING_OPERATION_MODE, deCONZ::Zcl8BitBitMap, data.boolean))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigUnoccupiedHeatSetpoint) // Signed integer\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.integer);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigHeatSetpoint) // Signed integer\n                {\n                    if (sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                    {\n                        // Older models of the Eurotroninc Spirit updated the heat set point via the manufacturer custom attribute 0x4003.\n                        // For newer models it is not possible to write to this attribute.\n                        // Newer models must use the standard Occupied Heating Setpoint value (0x0012) using a default (or none) manufacturer.\n                        // See GitHub issue #1098\n                        // UPD 16-11-2020: Since there is no way to reckognize older and newer models correctly and a new firmware version is on its way this\n                        //                 'fix' is changed to a more robust but ugly implementation by simply sending both codes to the device. One of the commands\n                        //                 will be accepted while the other one will be refused. Let's hope this code can be removed in a future release.\n\n                        TaskItem task2 ;\n                        task2.req.dstAddress() = sensor->address();\n                        task2.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n                        task2.req.setDstEndpoint(sensor->fingerPrint().endpoint);\n                        task2.req.setSrcEndpoint(getSrcEndpoint(sensor, task2.req));\n                        task2.req.setDstAddressMode(deCONZ::ApsExtAddress);\n                        task2.req.setSendDelay(1000);\n\n                        if (addTaskThermostatReadWriteAttribute(task,  deCONZ::ZclWriteAttributesId, VENDOR_JENNIC, THERM_ATTRID_CURRENT_TEMPERATURE_SETPOINT, deCONZ::Zcl16BitInt, data.integer) &&\n                            addTaskThermostatReadWriteAttribute(task2, deCONZ::ZclWriteAttributesId, VENDOR_NONE,   THERM_ATTRID_OCCUPIED_HEATING_SETPOINT, deCONZ::Zcl16BitInt, data.integer))\n                        {\n                            // Setting the heat setpoint disables off/boost modes, but this is not reported back by the thermostat.\n                            // Hence, the off/boost flags will be removed here to reflect the actual operating state.\n                            hostFlags &= ~0x04; // clear `boost` flag\n                            hostFlags |=  0x10; // set `disable off` flag\n\n                            updated = true;\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n                    {\n                        data.integer = data.integer / 10;\n                        QByteArray tuyaData = QByteArray(\"\\x00\\x00\", 2);\n                        qint8 dp = DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT;\n\n                        if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\"))\n                        {\n                            data.integer = data.integer / 10;\n\n                            ResourceItem *item = sensor->item(RConfigMode);\n                            ResourceItem *item2 = sensor->item(RConfigPreset);\n\n                            if (data.integer > 5 && item) // reverse setting for fake off mode\n                            {\n                                if (item->toString() == QLatin1String(\"off\"))\n                                {\n                                    QString mode = QLatin1String(\"heat\");\n                                    item->setValue(mode);\n                                }\n                                else if (item->toString() == QLatin1String(\"auto\") &&\n                                         item2 && item2->toString() == QLatin1String(\"auto\")) // change mode to manual if mode and preset have been auto\n                                {\n                                    QString mode = QLatin1String(\"heat\");\n                                    QString preset = QLatin1String(\"manual\");\n                                    item->setValue(mode);\n                                    item2->setValue(preset);\n                                }\n                            }\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                            R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                            R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n                        {\n                            dp = DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_2;\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n                        {\n                            dp = DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_3;\n                            data.integer = data.integer / 10;\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\"))\n                        {\n                            ResourceItem *item2 = sensor->item(RConfigMode);\n\n                            if (item2 && item2->toString() == QLatin1String(\"heat\"))\n                            {\n                                dp = DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_3;\n                            }\n                            else\n                            {\n                                dp = DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_4;\n                            }\n\n                            data.integer = data.integer * 2 / 10;\n                        }\n\n                        tuyaData.append(static_cast<qint8>((data.integer >> 8) & 0xff));\n                        tuyaData.append(static_cast<qint8>(data.integer & 0xff));\n\n                        if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_VALUE, dp, tuyaData))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (devManaged && rsub) // Managed by DDF ?\n                    {\n                        change.addTargetValue(rid.suffix, data.integer);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                    else\n                    {\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_OCCUPIED_HEATING_SETPOINT, deCONZ::Zcl16BitInt, data.integer))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigCoolSetpoint) // Signed integer\n                {\n                    if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_OCCUPIED_COOLING_SETPOINT, deCONZ::Zcl16BitInt, data.integer))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigMode) // String\n                {\n                    ok = false;\n\n                    if (devManaged && rsub)\n                    {\n                        const QVariantMap m = DDF_GetMetaKeyValues(sensor, item);\n\n                        if (m.contains(data.string))\n                        {\n                            change.addTargetValue(rid.suffix, data.string);\n                            rsub->addStateChange(change);\n                            updated = true;\n                            ok = true; // mark handled\n                        }\n                    }\n\n                    if (ok)\n                    {\n                        // handled by DDF \"meta\": { \"<item.suffix>\": {...}}\n                    }\n                    else if (sensor->modelId() == QLatin1String(\"Cable outlet\")) // Legrand cable outlet\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeLegrandValues);\n\n                        if (isValid(match))\n                        {\n                            if (addTaskControlModeCmd(task, 0x00, match.value))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesTuya1);\n\n                        if (isValid(match))\n                        {\n                            QByteArray tuyaData = QByteArray::fromRawData(match.value, 1);\n                            quint8 dpIdentifier = DP_IDENTIFIER_THERMOSTAT_MODE_1;\n\n                            if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\"))\n                            {\n                                dpIdentifier = DP_IDENTIFIER_THERMOSTAT_MODE_2;\n                            }\n\n                            if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, dpIdentifier, tuyaData))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesTuya2);\n\n                        if (isValid(match))\n                        {\n                            QByteArray tuyaData = QByteArray::fromRawData(match.value, 1);\n\n                            if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, 0x01, tuyaData))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesTuya1);\n\n                        if (isValid(match))\n                        {\n                            if (match.key == QLatin1String(\"off\")) // Fake off mode\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, DP_IDENTIFIER_THERMOSTAT_MODE_4, QByteArray(\"\\x01\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_VALUE, DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT, QByteArray(\"\\x00\\x00\\x00\\x05\", 4))) // mode manual and Set heat point 5 °C\n                                {\n                                    updated = true;\n                                }\n                            }\n                            else if (match.key == QLatin1String(\"heat\"))\n                            {\n                                ResourceItem *item = sensor->item(RConfigHeatSetpoint);\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, DP_IDENTIFIER_THERMOSTAT_MODE_4, QByteArray(\"\\x01\", 1))) // mode manual\n                                {\n                                    if(item->toNumber() <= 500) // reverse fake off mode by setting temp to 20°C\n                                    {\n                                        sendTuyaRequest(task, TaskThermostat, DP_TYPE_VALUE, DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT, QByteArray(\"\\x00\\x00\\x00\\x14\", 4));\n                                    }\n                                    updated = true;\n                                }\n                            }\n                            else\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, DP_IDENTIFIER_THERMOSTAT_MODE_4, QByteArray(\"\\x00\", 1))) // mode auto\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                             R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesTuya1);\n\n                        if (isValid(match))\n                        {\n                            if (match.key == QLatin1String(\"off\"))\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_ENABLE, QByteArray(\"\\x00\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_MODE_3, QByteArray(\"\\x00\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                            else if (match.key == QLatin1String(\"heat\"))\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_ENABLE, QByteArray(\"\\x00\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_MODE_3, QByteArray(\"\\x01\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                            else // auto\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_ENABLE, QByteArray(\"\\x01\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_MODE_3, QByteArray(\"\\x01\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesEurotronic);\n\n                        if (isValid(match))\n                        {\n                            if (match.key == QLatin1String(\"off\"))\n                            {\n                                hostFlags |= 0x000020; // set enable off\n                                hostFlags &= 0xffffeb; // clear boost, clear disable off\n                            }\n                            else if (match.key == QLatin1String(\"heat\"))\n                            {\n                                hostFlags |= 0x000014; // set boost, set disable off\n                            }\n                            else if (match.key == QLatin1String(\"auto\"))\n                            {\n                                hostFlags &= 0xfffffb; // clear boost\n                                hostFlags |= 0x000010; // set disable off\n                            }\n\n                            if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, VENDOR_JENNIC, THERM_ATTRID_HOST_FLAGS, deCONZ::Zcl24BitUint, hostFlags))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValues);\n\n                        if (isValid(match))\n                        {\n                            if (sensor->modelId() == QLatin1String(\"Super TR\")) // Set device on/off state through mode via device specific attribute\n                            {\n                                if (match.value != 0x00 && match.value != 0x04) { }\n                                else\n                                {\n                                    bool data = match.value == 0x00 ? false : true;\n\n                                    if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_DEVICE_ON, deCONZ::ZclBoolean, data))\n                                    {\n                                        updated = true;\n                                    }\n                                }\n                            }\n                            else if (sensor->modelId().startsWith(QLatin1String(\"SLR2\")) ||\n                                     sensor->modelId() == QLatin1String(\"SLR1b\"))\n                            {\n                                attributeList.insert(THERM_ATTRID_SYSTEM_MODE, (quint32)match.value);\n\n                                // Change automatically the Setpoint Hold\n                                // Add a timer for Boost mode\n                                if      (match.value == 0x00) { attributeList.insert(THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD, (quint32)0x00); }\n                                else if (match.value == 0x04) { attributeList.insert(THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD, (quint32)0x01); }\n                                else if (match.value == 0x05)\n                                {\n                                    attributeList.insert(THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD, (quint32)0x01);\n                                    attributeList.insert(THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD_DURATION, (quint32)0x003C);\n                                }\n\n                                if (!attributeList.isEmpty())\n                                {\n                                    if (addTaskThermostatWriteAttributeList(task, 0, attributeList))\n                                    {\n                                     updated = true;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_SYSTEM_MODE, deCONZ::Zcl8BitEnum, match.value))\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                        else if (isClip)\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigPreset) // String\n                {\n                    if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigPresetValuesTuya);\n\n                        if (isValid(match))\n                        {\n                            QByteArray tuyaData = QByteArray::fromRawData(match.value, 1);\n\n                            if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, 0x04, tuyaData))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigModeValuesTuya3);\n\n                        if (isValid(match))\n                        {\n                            QByteArray tuyaData = QByteArray::fromRawData(match.value, 1);\n\n                            if (match.key == QLatin1String(\"boost\")) //start boost\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_BOOST, QByteArray(\"\\x01\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                            else // stop boost\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, DP_IDENTIFIER_THERMOSTAT_MODE_4, tuyaData) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_BOOST, QByteArray(\"\\x00\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigPresetValuesTuya2);\n\n                        if (isValid(match))\n                        {\n                            if (match.key == QLatin1String(\"auto\"))\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, 0x02, QByteArray(\"\\x01\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, 0x03, QByteArray(\"\\x00\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                            else if (match.key == QLatin1String(\"program\"))\n                            {\n                                if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, 0x02, QByteArray(\"\\x00\", 1)) &&\n                                    sendTuyaRequest(task, TaskThermostat, DP_TYPE_ENUM, 0x03, QByteArray(\"\\x01\", 1)))\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (R_GetProductId(sensor) == QLatin1String(\"NAS-AB02B0 Siren\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigPresetValuesTuya3);\n\n                        if (isValid(match))\n                        {\n                            QByteArray tuyaData1;\n                            QByteArray tuyaData2;\n                            quint8 dpIdentifier1 = DP_IDENTIFIER_TEMPERATURE_ALARM;\n                            quint8 dpIdentifier2 = DP_IDENTIFIER_HUMIDITY_ALARM;\n\n                            if (match.key == QLatin1String(\"both\"))\n                            {\n                                tuyaData1 = tuyaData2 = QByteArray(\"\\x01\", 1);\n                            }\n                            else if (match.key == QLatin1String(\"humidity\"))\n                            {\n                                tuyaData1 = QByteArray(\"\\x00\", 1);\n                                tuyaData2 = QByteArray(\"\\x01\", 1);\n                            }\n                            else if (match.key == QLatin1String(\"temperature\"))\n                            {\n                                tuyaData1 = QByteArray(\"\\x01\", 1);\n                                tuyaData2 = QByteArray(\"\\x00\", 1);\n                            }\n                            else if (match.key == QLatin1String(\"off\"))\n                            {\n                                tuyaData1 = tuyaData2 = QByteArray(\"\\x00\", 1);\n                            }\n\n                            if (sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_BOOL, dpIdentifier1, tuyaData1) &&\n                                sendTuyaRequest(task, TaskTuyaRequest, DP_TYPE_BOOL, dpIdentifier2, tuyaData2))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                    else if (devManaged && rsub) // Managed by DDF ?\n                    {\n                        DBG_Printf(DBG_INFO_L2, \"debug test send preset\\n\");\n                        change.addTargetValue(rid.suffix, data.string);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigLocked) // Boolean\n                {\n                    if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\") ||\n                        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\"))\n                    {\n                        QByteArray tuyaData = QByteArray(\"\\x00\", 1);\n                        qint8 dpIdentifier = DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_1;\n\n                        if (data.boolean) { tuyaData = QByteArray(\"\\x01\", 1); }\n\n                        if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\") ||\n                            R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\"))\n                        {\n                            dpIdentifier = DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_2;\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD MOES TRV\"))\n                        {\n                            dpIdentifier = DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_3;\n                        }\n                        else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\"))\n                        {\n                            dpIdentifier = DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_4;\n                        }\n\n                        if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, dpIdentifier, tuyaData))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (sensor->modelId() == QLatin1String(\"Super TR\"))\n                    {\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_CHILD_LOCK, deCONZ::ZclBoolean, data.boolean))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                    {\n                        if (data.boolean) { hostFlags |= 0x000080; } // set locked\n                        else              { hostFlags &= 0xffff6f; } // clear locked, clear disable off\n\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, VENDOR_JENNIC, THERM_ATTRID_HOST_FLAGS, deCONZ::Zcl24BitUint, hostFlags))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (devManaged && rsub) // Managed by DDF ? why integer ?\n                    {\n                        data.uinteger = data.boolean; // Use integer representation\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                    else\n                    {\n                        data.uinteger = data.boolean; // Use integer representation\n\n                        if (addTaskThermostatUiConfigurationReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, THERM_UI_ATTRID_KEYPAD_LOCKOUT, deCONZ::Zcl8BitEnum, data.uinteger))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigDisplayFlipped) // Boolean\n                {\n                    if (sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                    {\n                        if (data.boolean) { hostFlags |= 0x000002; } // set flipped\n                        else              { hostFlags &= 0xffffed; } // clear flipped, clear disable off\n\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, VENDOR_JENNIC, THERM_ATTRID_HOST_FLAGS, deCONZ::Zcl24BitUint, hostFlags))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (devManaged && rsub)\n                    {\n                        data.uinteger = data.boolean; // Use integer representation\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigMountingMode) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigExternalTemperatureSensor) // Signed integer\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.integer);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigExternalWindowOpen) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigSetValve) // Boolean\n                {\n                    QByteArray tuyaData = QByteArray(\"\\x00\", 1);\n\n                    if (data.boolean)\n                    {\n                        tuyaData = QByteArray(\"\\x01\", 1);\n                    }\n\n                    if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, DP_IDENTIFIER_THERMOSTAT_VALVE, tuyaData))\n                    {\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigTemperatureMeasurement) // String\n                {\n                    if (sensor->modelId() == QLatin1String(\"Super TR\"))\n                    {\n                        const auto match = matchKeyValue(data.string, RConfigTemperatureMeasurementValues);\n\n                        if (isValid(match))\n                        {\n                            if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_TEMPERATURE_MEASUREMENT, deCONZ::Zcl8BitEnum, match.value))\n                            {\n                                updated = true;\n                            }\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigWindowOpen) // Boolean\n                {\n                    if (!devManaged)\n                    {\n                        QByteArray tuyaData = QByteArray(\"\\x00\", 1); // Config on / off\n\n                        if (data.boolean) { tuyaData = QByteArray(\"\\x01\", 1); }\n\n                        qint8 dpIdentifier = DP_IDENTIFIER_WINDOW_OPEN;\n\n                        if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\") ||\n                            R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BRT-100\"))\n                        {\n                            dpIdentifier = DP_IDENTIFIER_WINDOW_OPEN2;\n                        }\n\n                        if (sendTuyaRequest(task, TaskThermostat, DP_TYPE_BOOL, dpIdentifier, tuyaData))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (devManaged && rsub) // Managed by DDF ?\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigWindowOpenDetectionEnabled) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigRadiatorCovered) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigLoadBalancing) // Boolean\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigSwingMode) // String\n                {\n                    const auto match = matchKeyValue(data.string, RConfigSwingModeValues);\n\n                    if (isValid(match))\n                    {\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_AC_LOUVER_POSITION, deCONZ::Zcl8BitEnum, match.value))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigFanMode) // String\n                {\n                    const auto match = matchKeyValue(data.string, RConfigFanModeValues);\n\n                    if (isValid(match))\n                    {\n                        if (addTaskFanControlReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, FAN_CTRL_ATTRID_FAN_MODE, deCONZ::Zcl8BitEnum, match.value))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigControlSequence) // Unsigned integer\n                {\n                    const auto match = matchKeyValue(data.uinteger, RConfigControlSequenceValues);\n\n                    if (match.key)\n                    {\n                        if (addTaskThermostatReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, 0x0000, THERM_ATTRID_CONTROL_SEQUENCE_OF_OPERATION, deCONZ::Zcl8BitEnum, match.value))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigPulseConfiguration) // Unsigned integer\n                {\n                    if (!devManaged)\n                    {\n                        if (data.uinteger <= UINT16_MAX &&\n                        addTaskSimpleMeteringReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, METERING_ATTRID_PULSE_CONFIGURATION, deCONZ::Zcl16BitUint, data.uinteger, VENDOR_DEVELCO))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (rid.suffix == RConfigInterfaceMode) // Unsigned integer\n                {\n                    if (!devManaged)\n                    {\n                        if (sensor->modelId().startsWith(QLatin1String(\"EMIZB-1\")))\n                        {\n                            const auto match = matchKeyValue(data.uinteger, RConfigInterfaceModeValuesEMIZB);\n\n                            if (match.key)\n                            {\n                                if (addTaskSimpleMeteringReadWriteAttribute(task, deCONZ::ZclWriteAttributesId, METERING_ATTRID_INTERFACE_MODE, deCONZ::Zcl16BitEnum, match.value, VENDOR_DEVELCO))\n                                {\n                                    updated = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.uinteger);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                if (rid.suffix == RConfigWindowCoveringType) // Unsigned integer\n                {\n                    if (sensor->modelId().startsWith(QLatin1String(\"J1\")))\n                    {\n                        if (addTaskWindowCoveringCalibrate(task, data.uinteger))\n                        {\n                            updated = true;\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigGroup) // String\n                {\n                    data.valid = isValidRConfigGroup(data.string);\n                    if (data.valid)\n                    {\n                        updated = true;\n\n                        if (device && device->managed())\n                        {\n                            // if the device has groupcast bindings check for reconfiguration\n                            enqueueEvent(Event(RDevices, REventDDFReload, 0, sensor->address().ext()));\n                        }\n                    }\n                }\n                else if (rid.suffix == RConfigReportGrid)\n                {\n                    if (devManaged && rsub)\n                    {\n                        change.addTargetValue(rid.suffix, data.boolean);\n                        rsub->addStateChange(change);\n                        updated = true;\n                    }\n                }\n                else if (QString(rid.suffix).startsWith(\"config/ubisys_j1_\")) // Unsigned integer\n                {\n                    uint16_t mfrCode = VENDOR_UBISYS;\n                    uint16_t attrId = 0xFFFF;\n                    uint8_t attrType = deCONZ::Zcl16BitUint;\n                    if (rid.suffix == RConfigUbisysJ1Mode)\n                    {\n                        mfrCode = 0x0000;\n                        attrId = 0x0017;\n                        attrType = deCONZ::Zcl8BitBitMap;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1WindowCoveringType)\n                    {\n                        attrId = 0x0000;\n                        attrType = deCONZ::Zcl8BitEnum;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1ConfigurationAndStatus)\n                    {\n                        attrId = 0x0007;\n                        attrType = deCONZ::Zcl8BitBitMap;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1InstalledOpenLimitLift)\n                    {\n                        attrId = 0x0010;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1InstalledClosedLimitLift)\n                    {\n                        attrId = 0x0011;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1InstalledOpenLimitTilt)\n                    {\n                        attrId = 0x0012;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1InstalledClosedLimitTilt)\n                    {\n                        attrId = 0x0013;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1TurnaroundGuardTime)\n                    {\n                        attrId = 0x1000;\n                        attrType = deCONZ::Zcl8BitUint;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1LiftToTiltTransitionSteps)\n                    {\n                        attrId = 0x1001;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1TotalSteps)\n                    {\n                        attrId = 0x1002;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1LiftToTiltTransitionSteps2)\n                    {\n                        attrId = 0x1003;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1TotalSteps2)\n                    {\n                        attrId = 0x1004;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1AdditionalSteps)\n                    {\n                        attrId = 0x1005;\n                        attrType = deCONZ::Zcl8BitUint;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1InactivePowerThreshold)\n                    {\n                        attrId = 0x1006;\n                    }\n                    else if (rid.suffix == RConfigUbisysJ1StartupSteps)\n                    {\n                        attrId = 0x1007;\n                    }\n\n                    if (attrId != 0xFFFF)\n                    {\n                        if (addTaskWindowCoveringSetAttr(task, mfrCode, attrId, attrType, data.uinteger))\n                        {\n                            updated = true;\n                        }\n                    }\n                    else\n                    {\n                        rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                                   QString(\"parameter, %1, not available\").arg(pi.key())));\n                    }\n                }\n\n                if (updated)\n                {\n                    if (item->setValue(val))\n                    {\n                        QVariantMap rspItem;\n                        QVariantMap rspItemState;\n                        rspItemState[QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key())] = val;\n                        rspItem[QLatin1String(\"success\")] = rspItemState;\n                        rsp.list.append(rspItem);\n                        Event e(RSensors, rid.suffix, id, item);\n                        enqueueEvent(e);\n\n                        if (device && device->managed())\n                        {\n                            DB_StoreSubDeviceItem(sensor, item);\n                        }\n                    }\n\n                    save = true;\n                }\n                else\n                {\n                    rsp.list.append(errorToMap(ERR_ACTION_ERROR, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                               QLatin1String(\"Could not set attribute\")));\n                }\n            }\n            else // Resource item not found ifor sensor\n            {\n                rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                           QString(\"parameter, %1, not available\").arg(pi.key())));\n            }\n        }\n        else // Resource item not found in general\n        {\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%1/config/%2\").arg(id).arg(pi.key()),\n                                       QString(\"parameter, %1, not available\").arg(pi.key())));\n        }\n    }\n\n    if (tholdUpdated)\n    {\n        ResourceItem *item = sensor->item(RStateLightLevel);\n        if (item)\n        {\n            quint16 lightlevel = item->toNumber();\n\n            item = sensor->item(RConfigTholdDark);\n            if (item)\n            {\n                quint16 tholddark = item->toNumber();\n\n                item = sensor->item(RConfigTholdOffset);\n                if (item)\n                {\n                    quint16 tholdoffset = item->toNumber();\n\n                    bool dark = lightlevel <= tholddark;\n                    bool daylight = lightlevel >= tholddark + tholdoffset;\n\n                    item = sensor->item(RStateDark);\n                    if (!item)\n                    {\n                        item = sensor->addItem(DataTypeBool, RStateDark);\n                    }\n                    if (item && item->setValue(dark))\n                    {\n                        if (item->lastChanged() == item->lastSet())\n                        {\n                            Event e(RSensors, RStateDark, sensor->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n\n                    item = sensor->item(RStateDaylight);\n                    if (!item)\n                    {\n                        item = sensor->addItem(DataTypeBool, RStateDaylight);\n                    }\n                    if (item && item->setValue(daylight))\n                    {\n                        if (item->lastChanged() == item->lastSet())\n                        {\n                            Event e(RSensors, RStateDaylight, sensor->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (offsetUpdated)\n    {\n        ResourceItem *item = sensor->item(RStateTemperature);\n        if (item)\n        {\n            qint16 temp = item->toNumber();\n            temp += offset;\n            if (item->setValue(temp))\n            {\n                Event e(RSensors, RStateTemperature, sensor->id(), item);\n                enqueueEvent(e);\n            }\n        }\n\n        item = sensor->item(RStateHumidity);\n        if (item)\n        {\n            quint16 humidity = item->toNumber();\n            qint16 _humidity = humidity + offset;\n            humidity = _humidity < 0 ? 0 : _humidity > 10000 ? 10000 : _humidity;\n            if (item->setValue(humidity))\n            {\n                Event e(RSensors, RStateHumidity, sensor->id(), item);\n                enqueueEvent(e);\n            }\n        }\n    }\n\n    if (pendingMask)\n    {\n        ResourceItem *item = sensor->item(RConfigPending);\n        if (item)\n        {\n            quint16 mask = item->toNumber();\n            mask |= pendingMask;\n            item->setValue(mask);\n            Event e(RSensors, RConfigPending, sensor->id(), item);\n            enqueueEvent(e);\n        }\n    }\n\n    updateSensorEtag(sensor);\n\n    if (save)\n    {\n        sensor->setNeedSaveDatabase(true);\n        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n    }\n\n    processTasks();\n\n    return REQ_READY_SEND;\n}\n\n/*! POST, DELETE /api/<apikey>/sensors/<id>/config/schedule/Wbbb\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::changeThermostatSchedule(const ApiRequest &req, ApiResponse &rsp)\n{\n    rsp.httpStatus = HttpStatusOk;\n\n    // Get the /sensors/id resource.\n    QString id = req.path[3];\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        return REQ_READY_SEND;\n    }\n\n    // Check that it has config/schedule.\n    ResourceItem *item = sensor->item(RConfigSchedule);\n    if (!item)\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1/config/schedule\").arg(id), QString(\"resource, /sensors/%1/config/schedule, not available\").arg(id)));\n        return REQ_READY_SEND;\n    }\n\n    // Check valid weekday pattern\n    bool ok;\n    uint bbb = req.path[6].mid(1).toUInt(&ok);\n    if (req.path[6].left(1) != \"W\" || !ok || bbb < 1 || bbb > 127)\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1/config/schedule/%2\").arg(id).arg(req.path[6]), QString(\"resource, /sensors/%1/config/schedule/%2, not available\").arg(id).arg(req.path[6])));\n        return REQ_READY_SEND;\n    }\n    quint8 weekdays = bbb;\n\n    // Check body\n    QString transitions = QString(\"\");\n    if (req.hdr.method() == QLatin1String(\"POST\"))\n    {\n        QVariant var = Json::parse(req.content, ok);\n        if (!ok)\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/sensors/%1/config/schedule/%2\").arg(id).arg(req.path[6]), QLatin1String(\"body contains invalid JSON\")));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n        QVariantList list = var.toList();\n        // QString transitions = QString(\"\");\n        if (!serialiseThermostatTransitions(list, &transitions))\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/sensors/%1/config/schedule/%2\").arg(id).arg(req.path[6]), QLatin1String(\"body contains invalid list of transitions\")));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    if (req.sock)\n    {\n        userActivity();\n    }\n\n    bool ok2 = false;\n    // Queue task.\n    TaskItem task;\n    task.req.dstAddress() = sensor->address();\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(sensor->fingerPrint().endpoint);\n    task.req.setSrcEndpoint(getSrcEndpoint(sensor, task.req));\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n\n    if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY369 TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD HY368 TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD GS361A-H04 TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Essentials TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD Smart radiator TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD NX-4911-675 TRV\") ||\n        R_GetProductId(sensor) == QLatin1String(\"Tuya_THD SEA801-ZIGBEE TRV\"))\n    {\n        ok2 = sendTuyaRequestThermostatSetWeeklySchedule(task, weekdays, transitions, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_2);\n    }\n    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD BTH-002 Thermostat\"))\n    {\n        ok2 = sendTuyaRequestThermostatSetWeeklySchedule(task, weekdays, transitions, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_1);\n    }\n    else if (R_GetProductId(sensor) == QLatin1String(\"Tuya_THD WZB-TRVL TRV\"))\n    {\n        ok2 = sendTuyaRequestThermostatSetWeeklySchedule(task, weekdays, transitions, DP_IDENTIFIER_THERMOSTAT_SCHEDULE_4);\n    }\n    else\n    {\n        ok2 = addTaskThermostatSetWeeklySchedule(task, weekdays, transitions);\n    }\n\n    if (!ok2)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/config/schedule/%2\").arg(id).arg(req.path[6]), QLatin1String(\"could not set schedule\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n    if (req.hdr.method() == QLatin1String(\"POST\"))\n    {\n        QVariantList l;\n        deserialiseThermostatTransitions(transitions, &l);\n        rspItemState[QString(\"/config/schedule/W%1\").arg(weekdays)] = l;\n        rspItem[QLatin1String(\"success\")] = rspItemState;\n    }\n    else\n    {\n        rspItem[QLatin1String(\"success\")] = QString(\"/sensors/%1/config/schedule/W%2 deleted.\").arg(id).arg(weekdays);\n    }\n    rsp.list.append(rspItem);\n\n    updateThermostatSchedule(sensor, weekdays, transitions);\n\n    processTasks();\n\n    return REQ_READY_SEND;\n}\n\n/*! PUT, PATCH /api/<apikey>/sensors/<id>/state\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::changeSensorState(const ApiRequest &req, ApiResponse &rsp)\n{\n    QString id = req.path[3];\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n    bool ok;\n    bool updated = false;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    rsp.httpStatus = HttpStatusOk;\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/sensors/%1/state\").arg(id), QLatin1String(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        return REQ_READY_SEND;\n    }\n\n    bool isClip = sensor->type().startsWith(QLatin1String(\"CLIP\"));\n\n    if (req.sock)\n    {\n        userActivity();\n    }\n\n    //check invalid parameter\n    QVariantMap::const_iterator pi = map.begin();\n    QVariantMap::const_iterator pend = map.end();\n\n    for (; pi != pend; ++pi)\n    {\n        ResourceItem *item = nullptr;\n        ResourceItemDescriptor rid;\n        if (getResourceItemDescriptor(QString(\"state/%1\").arg(pi.key()), rid))\n        {\n            if (rid.suffix == RStateButtonEvent)\n            {\n                // allow modify physical switch buttonevent via api\n            }\n            else if (!isClip)\n            {\n                continue;\n            }\n\n            if (rid.suffix != RStateLux && rid.suffix != RStateDark && rid.suffix != RStateDaylight)\n            {\n                item = sensor->item(rid.suffix);\n            }\n            if (item)\n            {\n                QVariant val = map[pi.key()];\n                if (rid.suffix == RStateTemperature || rid.suffix == RStateHumidity || rid.suffix == RStatePressure)\n                {\n                    ResourceItem *item2 = sensor->item(RConfigOffset);\n                    if (item2 && item2->toNumber() != 0)\n                    {\n                        val = val.toInt() + item2->toNumber();\n                        if (rid.suffix == RStateHumidity)\n                        {\n                            val = val.toInt() < 0 ? 0 : val.toInt() > 10000 ? 10000 : val;\n                        }\n                    }\n                }\n\n                if (rid.suffix == RStateLocaltime)\n                {\n                    // convert to QDateTime here, otherwise the time string would be interpretet\n                    // as UTC in item->setValue()\n                    const auto str = val.toString();\n                    auto fmt = str.contains('.') ? QLatin1String(\"yyyy-MM-ddTHH:mm:ss.zzz\")\n                                                 : QLatin1String(\"yyyy-MM-ddTHH:mm:ss\");\n                    auto dt = QDateTime::fromString(str, fmt);\n\n                    if (dt.isValid()) { val = dt; }\n                    else              { val = \"\"; } // mark invalid but keep processing to return proper error\n                }\n\n                if (item->setValue(val))\n                {\n                    rspItemState[QString(\"/sensors/%1/state/%2\").arg(id).arg(pi.key())] = val;\n                    rspItem[QLatin1String(\"success\")] = rspItemState;\n\n                    if (rid.suffix == RStateButtonEvent ||  // always fire events for buttons\n                        item->lastChanged() == item->lastSet())\n                    {\n                        updated = true;\n                        Event e(RSensors, rid.suffix, id, item);\n                        enqueueEvent(e);\n                    }\n                    sensor->updateStateTimestamp();\n                    enqueueEvent(Event(RSensors, RStateLastUpdated, id));\n\n                    if (rid.suffix == RStateLightLevel)\n                    {\n                        ResourceItem *item2 = 0;\n                        quint16 measuredValue = val.toUInt();\n\n                        quint16 tholddark = R_THOLDDARK_DEFAULT;\n                        quint16 tholdoffset = R_THOLDOFFSET_DEFAULT;\n                        item2 = sensor->item(RConfigTholdDark);\n                        if (item2)\n                        {\n                            tholddark = item2->toNumber();\n                        }\n                        item2 = sensor->item(RConfigTholdOffset);\n                        if (item2)\n                        {\n                            tholdoffset = item2->toNumber();\n                        }\n                        bool dark = measuredValue <= tholddark;\n                        bool daylight = measuredValue >= tholddark + tholdoffset;\n\n                        item2 = sensor->item(RStateDark);\n                        if (!item2)\n                        {\n                            item2 = sensor->addItem(DataTypeBool, RStateDark);\n                        }\n                        if (item2->setValue(dark))\n                        {\n                            if (item2->lastChanged() == item2->lastSet())\n                            {\n                                Event e(RSensors, RStateDark, id, item2);\n                                enqueueEvent(e);\n                            }\n                        }\n\n                        item2 = sensor->item(RStateDaylight);\n                        if (!item2)\n                        {\n                            item2 = sensor->addItem(DataTypeBool, RStateDaylight);\n                        }\n                        if (item2->setValue(daylight))\n                        {\n                            if (item2->lastChanged() == item2->lastSet())\n                            {\n                                Event e(RSensors, RStateDaylight, id, item2);\n                                enqueueEvent(e);\n                            }\n                        }\n\n                        item2 = sensor->item(RStateLux);\n                        if (!item2)\n                        {\n                            item2 = sensor->addItem(DataTypeUInt32, RStateLux);\n                        }\n                        quint32 lux = 0;\n                        if (measuredValue > 0 && measuredValue < 0xffff)\n                        {\n                            // valid values are 1 - 0xfffe\n                            // 0, too low to measure\n                            // 0xffff invalid value\n\n                            // ZCL Attribute = 10.000 * log10(Illuminance (lx)) + 1\n                            // lux = 10^((ZCL Attribute - 1)/10.000)\n                            qreal exp = measuredValue - 1;\n                            qreal l = qPow(10, exp / 10000.0f);\n                            l += 0.5;   // round value\n                            lux = static_cast<quint32>(l);\n                        }\n                        item2->setValue(lux);\n                        if (item2->lastChanged() == item2->lastSet())\n                        {\n                            Event e(RSensors, RStateLux, id, item2);\n                            enqueueEvent(e);\n                        }\n                    }\n                    else if (rid.suffix == RStatePresence)\n                    {\n                        ResourceItem *item2 = sensor->item(RConfigDuration);\n                        if (item2 && item2->toNumber() > 0)\n                        {\n                            sensor->durationDue = QDateTime::currentDateTime().addSecs(item2->toNumber()).addMSecs(-500);\n                        }\n                    }\n                }\n                else // invalid\n                {\n                    rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/state/%2\").arg(id).arg(pi.key()),\n                                               QString(\"invalid value, %1, for parameter %2\").arg(val.toString()).arg(pi.key())));\n                    rsp.httpStatus = HttpStatusBadRequest;\n                    return REQ_READY_SEND;\n                }\n            }\n        }\n\n        if (!item)\n        {\n            // not found\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/sensors/%1/state/%2\").arg(id).arg(pi.key()), QString(\"parameter, %1, not available\").arg(pi.key())));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n\n    rsp.list.append(rspItem);\n    updateSensorEtag(sensor);\n    if (updated)\n    {\n        sensor->setNeedSaveDatabase(true);\n        queSaveDb(DB_SENSORS, DB_HUGE_SAVE_DELAY);\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! DELETE /api/<apikey>/sensors/<id>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::deleteSensor(const ApiRequest &req, ApiResponse &rsp)\n{\n    QString id = req.path[3];\n    Sensor *sensor = id.length() < MIN_UNIQUEID_LENGTH ? getSensorNodeForId(id) : getSensorNodeForUniqueId(id);\n\n    userActivity();\n\n    if (!sensor || (sensor->deletedState() == Sensor::StateDeleted))\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        rsp.list.append(errorToMap(ERR_RESOURCE_NOT_AVAILABLE, QString(\"/sensors/%1\").arg(id), QString(\"resource, /sensors/%1, not available\").arg(id)));\n        return REQ_READY_SEND;\n    }\n\n    bool ok;\n    QVariant var = Json::parse(req.content, ok);\n    QVariantMap map = var.toMap();\n\n    if (!ok)\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_JSON, QString(\"/sensors/%1\").arg(id), QLatin1String(\"body contains invalid JSON\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    sensor->setDeletedState(Sensor::StateDeleted);\n    sensor->setNeedSaveDatabase(true);\n\n    Event e(RSensors, REventDeleted, sensor->id());\n    enqueueEvent(e);\n\n    bool hasReset = map.contains(QLatin1String(\"reset\"));\n\n    if (hasReset)\n    {\n        if (map[QLatin1String(\"reset\")].type() == QVariant::Bool)\n        {\n            bool reset = map[QLatin1String(\"reset\")].toBool();\n\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[QString(\"/sensors/%1/reset\").arg(id)] = reset;\n            rspItem[QLatin1String(\"success\")] = rspItemState;\n            rsp.list.append(rspItem);\n\n            if (reset)\n            {\n                sensor->setResetRetryCount(10);\n            }\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/sensors/%1/reset\").arg(id), QString(\"invalid value, %1, for parameter, reset\").arg(map[QLatin1String(\"reset\")].toString())));\n            rsp.httpStatus = HttpStatusBadRequest;\n            return REQ_READY_SEND;\n        }\n    }\n    else\n    {\n        QVariantMap rspItem;\n        QVariantMap rspItemState;\n        rspItemState[QLatin1String(\"id\")] = id;\n        rspItem[QLatin1String(\"success\")] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusOk;\n    }\n\n    {\n        Q_Q(DeRestPlugin);\n        q->nodeUpdated(sensor->address().ext(), QLatin1String(\"deleted\"), QLatin1String(\"\"));\n    }\n\n    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n\n    updateSensorEtag(sensor);\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/sensors\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::searchNewSensors(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (!isInNetwork())\n    {\n        rsp.list.append(errorToMap(ERR_NOT_CONNECTED, QLatin1String(\"/sensors\"), QLatin1String(\"Not connected\")));\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    permitJoinApiKey = req.apikey();\n    startSearchSensors();\n    {\n        QVariantMap rspItem;\n        QVariantMap rspItemState;\n        rspItemState[QLatin1String(\"/sensors\")] = QLatin1String(\"Searching for new devices\");\n        rspItemState[QLatin1String(\"/sensors/duration\")] = (double)searchSensorsTimeout;\n        rspItem[QLatin1String(\"success\")] = rspItemState;\n        rsp.list.append(rspItem);\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/sensors/new\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getNewSensors(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n\n    if (!searchSensorsResult.isEmpty() &&\n        (searchSensorsState == SearchSensorsActive || searchSensorsState == SearchSensorsDone))\n    {\n\n        rsp.map = searchSensorsResult;\n    }\n\n    if (searchSensorsState == SearchSensorsActive)\n    {\n        rsp.map[QLatin1String(\"lastscan\")] = QLatin1String(\"active\");\n    }\n    else if (searchSensorsState == SearchSensorsDone)\n    {\n        rsp.map[QLatin1String(\"lastscan\")] = lastSensorsScan;\n    }\n    else\n    {\n        rsp.map[QLatin1String(\"lastscan\")] = QLatin1String(\"none\");\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n    return REQ_READY_SEND;\n}\n\n/*! Put all sensor parameters in a map.\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::sensorToMap(const Sensor *sensor, QVariantMap &map, const ApiRequest &req)\n{\n    if (!sensor)\n    {\n        return false;\n    }\n\n    QVariantMap state;\n    const ResourceItem *iox = nullptr;\n    const ResourceItem *ioy = nullptr;\n    const ResourceItem *ioz = nullptr;\n    QVariantList orientation;\n    const ResourceItem *ix = nullptr;\n    const ResourceItem *iy = nullptr;\n    QVariantList xy;\n    QVariantMap cap;\n    QVariantMap measuredValue;\n    QVariantMap otau;\n    QVariantMap config;\n    const ResourceItem *ilcs = nullptr;\n    const ResourceItem *ilca = nullptr;\n    const ResourceItem *ilct = nullptr;\n    QVariantMap lastchange;\n\n    for (int i = 0; i < sensor->itemCount(); i++)\n    {\n        const ResourceItem *item = sensor->itemForIndex(static_cast<size_t>(i));\n        DBG_Assert(item);\n        const ResourceItemDescriptor &rid = item->descriptor();\n\n        if (!item->isPublic())\n        {\n            continue;\n        }\n\n        if (rid.suffix == RConfigReachable &&\n            sensor->type().startsWith(QLatin1String(\"ZGP\")))\n        {\n            continue; // don't provide reachable for green power devices\n        }\n\n        if (rid.suffix == RAttrMode)\n        {\n            continue; // handled later on\n        }\n\n        if (strncmp(rid.suffix, \"config/\", 7) == 0)\n        {\n            const char *key = item->descriptor().suffix + 7;\n            if (rid.suffix == RConfigPending)\n            {\n                QVariantList pending;\n                auto value = item->toNumber();\n\n                if (value & R_PENDING_DELAY)\n                {\n                    pending.append(QLatin1String(\"delay\"));\n                }\n                if (value & R_PENDING_SENSITIVITY)\n                {\n                    pending.append(QLatin1String(\"sensitivity\"));\n                }\n                config[key] = pending;\n            }\n            else if (rid.suffix == RConfigLastChangeSource)\n            {\n                ilcs = item;\n            }\n            else if (rid.suffix == RConfigLastChangeAmount)\n            {\n                ilca = item;\n            }\n            else if (rid.suffix == RConfigLastChangeTime)\n            {\n                ilct = item;\n            }\n            else if (rid.suffix == RConfigSchedule)\n            {\n                QVariantMap schedule;\n                deserialiseThermostatSchedule(item->toString(), &schedule);\n                config[key] = schedule;\n            }\n            else\n            {\n                config[key] = item->toVariant();\n            }\n        }\n        else if (strncmp(rid.suffix, \"state/\", 6) == 0)\n        {\n            const char *key = item->descriptor().suffix + 6;\n\n            if (rid.suffix == RStateLastUpdated)\n            {\n                if (!item->lastSet().isValid() || item->lastSet().date().year() < 2000)\n                {\n                    state[key] = QLatin1String(\"none\");\n                }\n                else\n                {\n                    state[key] = item->toVariant().toDateTime().toString(\"yyyy-MM-ddTHH:mm:ss.zzz\");\n                }\n            }\n            else if (rid.suffix == RStateOrientationX)\n            {\n                iox = item;\n            }\n            else if (rid.suffix == RStateOrientationY)\n            {\n                ioy = item;\n            }\n            else if (rid.suffix == RStateOrientationZ)\n            {\n                ioz = item;\n            }\n            else if (rid.suffix == RStateX)\n            {\n                ix = item;\n            }\n            else if (rid.suffix == RStateY)\n            {\n                iy = item;\n            }\n            else\n            {\n                state[key] = item->toVariant();\n            }\n        }\n        else if (strncmp(rid.suffix, \"cap/\", 4) == 0)\n        {\n            const char *key = item->descriptor().suffix + 4;\n\n            if (strncmp(key, \"measured_value/\", 15) == 0)\n            {\n                measuredValue[key + 15] = item->toVariant();\n            }\n            else if (strncmp(key, \"otau/\", 5) == 0)\n            {\n                otau[key + 5] = item->toVariant();\n            }\n            else\n            {\n                cap[key] = item->toVariant();\n            }\n        }\n        else if (rid.suffix == RAttrLastAnnounced) { map[\"lastannounced\"] = item->toString(); }\n        else if (rid.suffix == RAttrLastSeen) { map[\"lastseen\"] = item->toString(); }\n        else if (rid.suffix == RAttrProductId) { map[\"productid\"] = item->toString(); }\n        else if (rid.suffix == RAttrProductName) { map[\"productname\"] = item->toString(); }\n        else if (rid.suffix == RAttrZoneType) { map[\"zonetype\"] = item->toNumber(); }\n    }\n    if (iox && ioy && ioz)\n    {\n        orientation.append(iox->toNumber());\n        orientation.append(ioy->toNumber());\n        orientation.append(ioz->toNumber());\n        state[QLatin1String(\"orientation\")] = orientation;\n    }\n    if (ix && iy)\n    {\n        xy.append(round(ix->toNumber() / 6.5535) / 10000.0);\n        xy.append(round(iy->toNumber() / 6.5535) / 10000.0);\n        state[QLatin1String(\"xy\")] = xy;\n    }\n    if (ilcs && ilca && ilct)\n    {\n        lastchange[QLatin1String(\"source\")] = RConfigLastChangeSourceValues[ilcs->toNumber()];\n        lastchange[QLatin1String(\"amount\")] = ilca->toNumber();\n        lastchange[QLatin1String(\"time\")] = ilct->toVariant().toDateTime().toString(\"yyyy-MM-ddTHH:mm:ssZ\");\n        config[QLatin1String(\"lastchange\")] = lastchange;\n    }\n\n    //sensor\n    map[QLatin1String(\"name\")] = sensor->name();\n    map[QLatin1String(\"type\")] = sensor->type();\n\n    if (req.path.size() > 2 && req.path[2] == QLatin1String(\"devices\"))\n    {\n        // don't add in sub device\n    }\n    else\n    {\n        if (!sensor->modelId().isEmpty())\n        {\n            map[QLatin1String(\"modelid\")] = sensor->modelId();\n        }\n        if (!sensor->manufacturer().isEmpty())\n        {\n            map[QLatin1String(\"manufacturername\")] = sensor->manufacturer();\n        }\n        if (!sensor->swVersion().isEmpty() && !sensor->type().startsWith(QLatin1String(\"ZGP\")))\n        {\n            map[QLatin1String(\"swversion\")] = sensor->swVersion();\n        }\n        if (sensor->fingerPrint().endpoint != INVALID_ENDPOINT)\n        {\n            map[QLatin1String(\"ep\")] = sensor->fingerPrint().endpoint;\n        }\n        QString etag = sensor->etag;\n        etag.remove('\"'); // no quotes allowed in string\n        map[QLatin1String(\"etag\")] = etag;\n    }\n\n    // whitelist, HueApp crashes on ZHAAlarm and ZHAPressure\n    if (req.mode == ApiModeHue)\n    {\n        if (!(sensor->type() == QLatin1String(\"Daylight\") ||\n              sensor->type() == QLatin1String(\"CLIPGenericFlag\") ||\n              sensor->type() == QLatin1String(\"CLIPGenericStatus\") ||\n              sensor->type() == QLatin1String(\"CLIPSwitch\") ||\n              sensor->type() == QLatin1String(\"CLIPOpenClose\") ||\n              sensor->type() == QLatin1String(\"CLIPPresence\") ||\n              sensor->type() == QLatin1String(\"CLIPTemperature\") ||\n              sensor->type() == QLatin1String(\"CLIPHumidity\") ||\n              sensor->type() == QLatin1String(\"CLIPLightlevel\") ||\n              sensor->type() == QLatin1String(\"ZGPSwitch\") ||\n              sensor->type() == QLatin1String(\"ZHASwitch\") ||\n              sensor->type() == QLatin1String(\"ZHAOpenClose\") ||\n              sensor->type() == QLatin1String(\"ZHAPresence\") ||\n              sensor->type() == QLatin1String(\"ZHATemperature\") ||\n              sensor->type() == QLatin1String(\"ZHAHumidity\") ||\n              sensor->type() == QLatin1String(\"ZHALightLevel\")))\n        {\n            return false;\n        }\n        // mimic Hue Dimmer Switch\n        if (sensor->modelId() == QLatin1String(\"TRADFRI wireless dimmer\") ||\n            sensor->modelId() == QLatin1String(\"lumi.sensor_switch.aq2\"))\n        {\n            map[QLatin1String(\"manufacturername\")] = QLatin1String(\"Philips\");\n            map[QLatin1String(\"modelid\")] = QLatin1String(\"RWL021\");\n        }\n        // mimic Hue motion sensor\n        else if (false)\n        {\n            map[QLatin1String(\"manufacturername\")] = QLatin1String(\"Philips\");\n            map[QLatin1String(\"modelid\")] = QLatin1String(\"SML001\");\n        }\n    }\n\n    if (req.mode != ApiModeNormal &&\n        sensor->manufacturer().startsWith(QLatin1String(\"Philips\")) &&\n        sensor->type().startsWith(QLatin1String(\"ZHA\")))\n    {\n        QString type = sensor->type();\n        type.replace(QLatin1String(\"ZHA\"), QLatin1String(\"ZLL\"));\n        map[QLatin1String(\"type\")] = type;\n    }\n\n    if (sensor->mode() != Sensor::ModeNone &&\n        sensor->type().endsWith(QLatin1String(\"Switch\")))\n    {\n        map[QLatin1String(\"mode\")] = (double)sensor->mode();\n    }\n\n    const ResourceItem *item = sensor->item(RAttrUniqueId);\n    if (item)\n    {\n        map[QLatin1String(\"uniqueid\")] = item->toString();\n    }\n    map[QLatin1String(\"state\")] = state;\n    map[QLatin1String(\"config\")] = config;\n    if (!measuredValue.isEmpty()) cap[QLatin1String(\"measured_value\")] = measuredValue;\n    if (!otau.isEmpty()) cap[QLatin1String(\"otau\")] = otau;\n    if (!cap.isEmpty()) map[QLatin1String(\"capabilities\")] = cap;\n\n    return true;\n}\n\nvoid DeRestPluginPrivate::handleSensorEvent(const Event &e)\n{\n    DBG_Assert(e.resource() == RSensors);\n    DBG_Assert(e.what() != nullptr);\n\n    Sensor *sensor = getSensorNodeForId(e.id());\n\n    if (!sensor)\n    {\n        return;\n    }\n\n    Device *device = DEV_ParentDevice(sensor);\n\n    if (device && device->managed())\n    {\n        if (e.what() == RStatePresence || e.what() == RStateVibration)\n        {\n            ResourceItem *item = sensor->item(e.what());\n            if (item && item->toBool()) {\n                ResourceItem *item2 = sensor->item(RConfigDuration);\n                if (item2 && item2->toNumber() > 0)\n                {\n                    DBG_Printf(DBG_DDF, \"%s/%s auto reset in %us\\n\", sensor->item(RAttrUniqueId)->toCString(), qPrintable(e.what()), (quint16) item2->toNumber());\n                    sensor->durationDue = item->lastSet().addSecs(item2->toNumber());\n                }\n            }\n        }\n    }\n\n    // speedup sensor state check\n    if ((e.what() == RStatePresence || e.what() == RStateButtonEvent || e.what() == RStateVibration) &&\n        sensor && sensor->durationDue.isValid())\n    {\n        sensorCheckFast = CHECK_SENSOR_FAST_ROUNDS;\n    }\n\n    // push sensor state updates through websocket\n    if (strncmp(e.what(), \"state/\", 6) == 0)\n    {\n        ResourceItem *item = sensor->item(e.what());\n        if (item && item->isPublic())\n        {\n            if (item->descriptor().suffix == RStatePresence && item->toBool())\n            {\n                globalLastMotion = item->lastSet(); // remember\n            }\n\n            if (e.what() == RStateBattery)\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(e.what()), QString::number(item->toNumber()));\n            }\n\n            if (!(item->needPushSet() || item->needPushChange()))\n            {\n                return; // already pushed\n            }\n\n            QVariantMap map;\n            map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n            map[QLatin1String(\"e\")] = QLatin1String(\"changed\");\n            map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n            map[QLatin1String(\"id\")] = e.id();\n            map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n            QVariantMap state;\n            ResourceItem *iox = nullptr;\n            ResourceItem *ioy = nullptr;\n            ResourceItem *ioz = nullptr;\n            ResourceItem *ix = nullptr;\n            ResourceItem *iy = nullptr;\n\n            for (int i = 0; i < sensor->itemCount(); i++)\n            {\n                item = sensor->itemForIndex(i);\n                const ResourceItemDescriptor &rid = item->descriptor();\n\n                if (strncmp(rid.suffix, \"state/\", 6) == 0)\n                {\n                    const char *key = item->descriptor().suffix + 6;\n\n                    if (rid.suffix == RStateOrientationX)\n                    {\n                        iox = item;\n                    }\n                    else if (rid.suffix == RStateOrientationY)\n                    {\n                        ioy = item;\n                    }\n                    else if (rid.suffix == RStateOrientationZ)\n                    {\n                        ioz = item;\n                    }\n                    else if (rid.suffix == RStateX)\n                    {\n                        ix = item;\n                    }\n                    else if (rid.suffix == RStateY)\n                    {\n                        iy = item;\n                    }\n                    else if (item->isPublic() && (gwWebSocketNotifyAll || rid.suffix == RStateButtonEvent || item->needPushChange()))\n                    {\n                        state[key] = item->toVariant();\n                        item->clearNeedPush();\n                    }\n                }\n            }\n\n            if (iox && ioy && ioz)\n            {\n                if (gwWebSocketNotifyAll || iox->needPushChange() || ioy->needPushChange() || ioz->needPushChange())\n                {\n                    iox->clearNeedPush();\n                    ioy->clearNeedPush();\n                    ioz->clearNeedPush();\n\n                    QVariantList orientation;\n                    orientation.append(iox->toNumber());\n                    orientation.append(ioy->toNumber());\n                    orientation.append(ioz->toNumber());\n                    state[QLatin1String(\"orientation\")] = orientation;\n                }\n            }\n\n            if (ix && iy)\n            {\n                if (gwWebSocketNotifyAll || ix->needPushChange() || iy->needPushChange())\n                {\n                    ix->clearNeedPush();\n                    iy->clearNeedPush();\n\n                    QVariantList xy;\n                    xy.append(round(ix->toNumber() / 6.5535) / 10000.0);\n                    xy.append(round(iy->toNumber() / 6.5535) / 10000.0);\n                    state[QLatin1String(\"xy\")] = xy;\n                }\n            }\n\n            if (!state.isEmpty())\n            {\n                map[QLatin1String(\"state\")] = state;\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\n                updateSensorEtag(sensor);\n                plugin->saveDatabaseItems |= DB_SENSORS;\n                plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n    else if (strncmp(e.what(), \"config/\", 7) == 0)\n    {\n        ResourceItem *item = sensor->item(e.what());\n        if (item && item->isPublic())\n        {\n            if (e.what() == RConfigGroup)\n            {\n                checkSensorBindingsForClientClusters(sensor);\n            }\n\n            if (e.what() == RConfigBattery)\n            {\n                DEV_ForwardNodeChange(device, QLatin1String(e.what()), QString::number(item->toNumber()));\n            }\n\n            if (!(item->needPushSet() || item->needPushChange()))\n            {\n                return; // already pushed\n            }\n\n            QVariantMap map;\n            map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n            map[QLatin1String(\"e\")] = QLatin1String(\"changed\");\n            map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n            map[QLatin1String(\"id\")] = e.id();\n            map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n            QVariantMap config;\n            ResourceItem *ilcs = nullptr;\n            ResourceItem *ilca = nullptr;\n            ResourceItem *ilct = nullptr;\n\n            for (int i = 0; i < sensor->itemCount(); i++)\n            {\n                item = sensor->itemForIndex(i);\n                const ResourceItemDescriptor &rid = item->descriptor();\n\n                if (strncmp(rid.suffix, \"config/\", 7) == 0)\n                {\n                    const char *key = item->descriptor().suffix + 7;\n\n                    if (rid.suffix == RConfigLastChangeSource)\n                    {\n                        ilcs = item;\n                    }\n                    else if (rid.suffix == RConfigLastChangeAmount)\n                    {\n                        ilca = item;\n                    }\n                    else if (rid.suffix == RConfigLastChangeTime)\n                    {\n                        ilct = item;\n                    }\n                    else if (item->isPublic() && (gwWebSocketNotifyAll || item->needPushChange()))\n                    {\n                        if (rid.suffix == RConfigSchedule)\n                        {\n                            QVariantMap schedule;\n                            deserialiseThermostatSchedule(item->toString(), &schedule);\n                            config[key] = schedule;\n                        }\n                        else if (rid.suffix == RConfigPending)\n                        {\n                            QVariantList pending;\n                            auto value = item->toNumber();\n\n                            if (value & R_PENDING_DELAY)\n                            {\n                                pending.append(QLatin1String(\"delay\"));\n                            }\n                            if (value & R_PENDING_SENSITIVITY)\n                            {\n                                pending.append(QLatin1String(\"sensitivity\"));\n                            }\n                            config[key] = pending;\n                        }\n                        else\n                        {\n                            config[key] = item->toVariant();\n                        }\n                        item->clearNeedPush();\n                    }\n                }\n            }\n            if (ilcs && ilca && ilct)\n            {\n                if (gwWebSocketNotifyAll || ilcs->needPushChange() || ilca->needPushChange() || ilct->needPushChange())\n                {\n                    ilcs->clearNeedPush();\n                    ilca->clearNeedPush();\n                    ilct->clearNeedPush();\n\n                    QVariantMap lastchange;\n                    lastchange[QLatin1String(\"source\")] = RConfigLastChangeSourceValues[ilcs->toNumber()];\n                    lastchange[QLatin1String(\"amount\")] = ilca->toNumber();\n                    lastchange[QLatin1String(\"time\")] = ilct->toVariant().toDateTime().toString(\"yyyy-MM-ddTHH:mm:ssZ\");\n                    config[QLatin1String(\"lastchange\")] = lastchange;\n                }\n            }\n\n            if (!config.isEmpty())\n            {\n                map[QLatin1String(\"config\")] = config;\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\n                updateSensorEtag(sensor);\n                plugin->saveDatabaseItems |= DB_SENSORS;\n                plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n    else if (strncmp(e.what(), \"cap/\", 4) == 0)\n    {\n        ResourceItem *item = sensor->item(e.what());\n        if (item && item->isPublic())\n        {\n            if (!(item->needPushSet() || item->needPushChange()))\n            {\n                return; // already pushed\n            }\n\n            QVariantMap map;\n            map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n            map[QLatin1String(\"e\")] = QLatin1String(\"changed\");\n            map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n            map[QLatin1String(\"id\")] = e.id();\n            map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n\n            QVariantMap cap;\n            QVariantMap measuredValue;\n            QVariantMap otau;\n\n            for (int i = 0; i < sensor->itemCount(); i++)\n            {\n                item = sensor->itemForIndex(i);\n                const ResourceItemDescriptor &rid = item->descriptor();\n\n                if (strncmp(rid.suffix, \"cap/\", 4) == 0)\n                {\n                    const char *key = item->descriptor().suffix + 4;\n\n                    if (gwWebSocketNotifyAll || item->needPushChange())\n                    {\n                        if (strncmp(key, \"measured_value/\", 15) == 0)\n                        {\n                            measuredValue[key + 15] = item->toVariant();\n                        }\n                        else if (strncmp(key, \"otau/\", 5) == 0)\n                        {\n                            otau[key + 5] = item->toVariant();\n                        }\n                        else\n                        {\n                            cap[key] = item->toVariant();\n                        }\n                        item->clearNeedPush();\n                    }\n                }\n            }\n\n            if (!measuredValue.isEmpty())\n            {\n                cap[QLatin1String(\"measured_value\")] = measuredValue;\n            }\n            if (!otau.isEmpty())\n            {\n                cap[QLatin1String(\"otau\")] = otau;\n            }\n            if (!cap.isEmpty())\n            {\n                map[QLatin1String(\"capabilities\")] = cap;\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\n                updateSensorEtag(sensor);\n                plugin->saveDatabaseItems |= DB_SENSORS;\n                plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n    else if (strncmp(e.what(), \"attr/\", 5) == 0)\n    {\n        ResourceItem *item = sensor->item(e.what());\n        if (item && item->isPublic())\n        {\n            if (!(item->needPushSet() || item->needPushChange()))\n            {\n                return; // already pushed\n            }\n\n            QVariantMap map;\n            map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n            map[QLatin1String(\"e\")] = QLatin1String(\"changed\");\n            map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n            map[QLatin1String(\"id\")] = e.id();\n            map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n\n            QVariantMap attr;\n            QVariantMap attrOtau;\n\n            for (int i = 0; i < sensor->itemCount(); i++)\n            {\n                item = sensor->itemForIndex(i);\n                const ResourceItemDescriptor &rid = item->descriptor();\n\n                if (strncmp(rid.suffix, \"attr/\", 5) == 0)\n                {\n                    const char *key = item->descriptor().suffix + 5;\n\n                    if (gwWebSocketNotifyAll || item->needPushChange())\n                    {\n                        attr[key] = item->toVariant();\n                        item->clearNeedPush();\n                    }\n                }\n            }\n\n            if (!attrOtau.isEmpty())\n            {\n                attr[\"otau\"] = attrOtau;\n            }\n            if (!attr.isEmpty())\n            {\n                map[\"attr\"] = attr;\n                webSocketServer->broadcastTextMessage(Json::serialize(map));\n                updateSensorEtag(sensor);\n                plugin->saveDatabaseItems |= DB_SENSORS;\n                plugin->queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n    else if (e.what() == REventAdded)\n    {\n        checkSensorGroup(sensor);\n        checkSensorBindingsForAttributeReporting(sensor);\n        checkSensorBindingsForClientClusters(sensor);\n\n        pushSensorInfoToCore(sensor);\n\n        QVariantMap res;\n        res[QLatin1String(\"name\")] = sensor->name();\n        searchSensorsResult[sensor->id()] = res;\n\n        QVariantMap map;\n        map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n        map[QLatin1String(\"e\")] = QLatin1String(\"added\");\n        map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n\n        QVariantMap smap;\n\n        QHttpRequestHeader hdr;  // dummy\n        QStringList path;  // dummy\n        ApiRequest req(hdr, path, nullptr, QLatin1String(\"\")); // dummy\n\n        req.mode = ApiModeNormal;\n        sensorToMap(sensor, smap, req);\n        map[QLatin1String(\"id\")] = sensor->id();\n        map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n        smap[QLatin1String(\"id\")] = sensor->id();\n        map[QLatin1String(\"sensor\")] = smap;\n\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\n    }\n    else if (e.what() == REventDeleted)\n    {\n        deleteGroupsWithDeviceMembership(e.id());\n\n        QVariantMap map;\n        map[QLatin1String(\"t\")] = QLatin1String(\"event\");\n        map[QLatin1String(\"e\")] = QLatin1String(\"deleted\");\n        map[QLatin1String(\"r\")] = QLatin1String(\"sensors\");\n\n        QVariantMap smap;\n        map[QLatin1String(\"id\")] = e.id();\n        map[QLatin1String(\"uniqueid\")] = sensor->uniqueId();\n        smap[QLatin1String(\"id\")] = e.id();\n        map[QLatin1String(\"sensor\")] = smap;\n\n        webSocketServer->broadcastTextMessage(Json::serialize(map));\n    }\n    else if (e.what() == REventValidGroup)\n    {\n        checkOldSensorGroups(sensor);\n\n        ResourceItem *item = sensor->item(RConfigGroup);\n        DBG_Assert(item != nullptr);\n        if (!item)\n        {\n            return;\n        }\n\n        QStringList gids = item->toString().split(',', SKIP_EMPTY_PARTS);\n\n        for (int j = 0; j < gids.size(); j++)\n        {\n            const QString gid = gids[j];\n\n            if (gid == QLatin1String(\"0\"))\n            {\n                continue;\n            }\n\n            Group *group = getGroupForId(gid);\n\n            if (group && group->state() != Group::StateNormal)\n            {\n                DBG_Printf(DBG_INFO, \"reanimate group %s for sensor %s\\n\", qPrintable(gid), qPrintable(sensor->id()));\n                group->setState(Group::StateNormal);\n                group->setName(sensor->modelId() + QLatin1String(\" \") + sensor->id());\n                updateGroupEtag(group);\n                queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\n            }\n\n            if (group && group->addDeviceMembership(sensor->id()))\n            {\n                DBG_Printf(DBG_INFO, \"attach group %s to sensor %s\\n\", qPrintable(gid), qPrintable(sensor->id()));\n                queSaveDb(DB_GROUPS, DB_LONG_SAVE_DELAY);\n                updateGroupEtag(group);\n            }\n\n            if (!group) // create\n            {\n                DBG_Printf(DBG_INFO, \"create group %s for sensor %s\\n\", qPrintable(gid), qPrintable(sensor->id()));\n                Group g;\n                g.setAddress(gid.toUInt());\n                g.setName(sensor->modelId() + QLatin1String(\" \") + sensor->id());\n                g.addDeviceMembership(sensor->id());\n                ResourceItem *item2 = g.addItem(DataTypeString, RAttrUniqueId);\n                DBG_Assert(item2);\n                if (item2)\n                {\n                    // FIXME: use the endpoint from which the group command was sent.\n                    const QString uid = generateUniqueId(sensor->address().ext(), 0, 0);\n                    item2->setValue(uid);\n                }\n                groups.push_back(g);\n                updateGroupEtag(&groups.back());\n                queSaveDb(DB_GROUPS, DB_SHORT_SAVE_DELAY);\n                checkSensorBindingsForClientClusters(sensor);\n            }\n        }\n    }\n}\n\n/*! Starts the search for new sensors.\n */\nvoid DeRestPluginPrivate::startSearchSensors()\n{\n    if (searchSensorsState == SearchSensorsIdle || searchSensorsState == SearchSensorsDone)\n    {\n        pollNodes.clear();\n        bindingQueue.clear();\n        sensors.reserve(sensors.size() + 10);\n        searchSensorsCandidates.clear();\n        searchSensorsResult.clear();\n        lastSensorsScan = QDateTime::currentDateTimeUtc().toString(QLatin1String(\"yyyy-MM-ddTHH:mm:ss\"));\n        QTimer::singleShot(1000, this, SLOT(searchSensorsTimerFired()));\n        searchSensorGppPairCounter = 0;\n        searchSensorsState = SearchSensorsActive;\n    }\n    else\n    {\n        Q_ASSERT(searchSensorsState == SearchSensorsActive);\n    }\n\n    searchSensorsTimeout = gwNetworkOpenDuration;\n    setPermitJoinDuration(searchSensorsTimeout);\n}\n\n/*! Handler for search sensors active state.\n */\nvoid DeRestPluginPrivate::searchSensorsTimerFired()\n{\n    if (gwPermitJoinDuration == 0)\n    {\n        searchSensorsTimeout = 0; // done\n    }\n\n    if (searchSensorsTimeout > 0)\n    {\n        searchSensorsTimeout--;\n        QTimer::singleShot(1000, this, SLOT(searchSensorsTimerFired()));\n    }\n\n    if (searchSensorsTimeout == 0)\n    {\n        DBG_Printf(DBG_INFO, \"Search sensors done\\n\");\n        fastProbeAddr = deCONZ::Address();\n        fastProbeIndications.clear();\n        searchSensorsState = SearchSensorsDone;\n    }\n}\n\n/*! Validate sensor states. */\nvoid DeRestPluginPrivate::checkSensorStateTimerFired()\n{\n    if (sensors.empty())\n    {\n        return;\n    }\n\n    if (sensorCheckIter >= sensors.size())\n    {\n        sensorCheckIter = 0;\n        sensorCheckFast = (sensorCheckFast > 0) ? sensorCheckFast - 1 : 0;\n    }\n\n    for (int i = 0; i < CHECK_SENSORS_MAX; i++)\n    {\n        if (sensorCheckIter >= sensors.size())\n        {\n            break;\n        }\n\n        Sensor *sensor = &sensors[sensorCheckIter];\n        sensorCheckIter++;\n\n        if (sensor->deletedState() != Sensor::StateNormal)\n        {\n            continue;\n        }\n\n        if (sensor->durationDue.isValid())\n        {\n            if (sensor->durationDue <= QDateTime::currentDateTime())\n            {\n                // automatically set presence to false, if not triggered in config.duration\n                ResourceItem *item = sensor->item(RStatePresence);\n                if (item && item->toBool())\n                {\n                    DBG_Printf(DBG_INFO, \"sensor %s (%s): disable presence\\n\", qPrintable(sensor->id()), qPrintable(sensor->modelId()));\n                    item->setValue(false);\n                    sensor->updateStateTimestamp();\n                    sensor->setNeedSaveDatabase(true);\n                    enqueueEvent(Event(RSensors, RStatePresence, sensor->id(), item));\n                    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                    updateSensorEtag(sensor);\n                    for (quint16 clusterId : sensor->fingerPrint().inClusters)\n                    {\n                        if (sensor->modelId().startsWith(QLatin1String(\"TRADFRI\")))\n                        {\n                            clusterId = OCCUPANCY_SENSING_CLUSTER_ID; // workaround\n                        }\n\n                        if (clusterId == IAS_ZONE_CLUSTER_ID || clusterId == OCCUPANCY_SENSING_CLUSTER_ID)\n                        {\n                            pushZclValueDb(sensor->address().ext(), sensor->fingerPrint().endpoint, clusterId, 0x0000, 0);\n                            break;\n                        }\n                    }\n                }\n                else if (!item && sensor->modelId() == QLatin1String(\"lumi.sensor_switch\"))\n                {\n                    // Xiaomi round button (WXKG01LM)\n                    // generate artificial hold event\n                    item = sensor->item(RStateButtonEvent);\n                    if (item && item->toNumber() == (S_BUTTON_1 + S_BUTTON_ACTION_INITIAL_PRESS))\n                    {\n                        item->setValue(S_BUTTON_1 + S_BUTTON_ACTION_HOLD);\n                        DBG_Printf(DBG_INFO, \"[INFO] - Button %u Hold %s\\n\", item->toNumber(), qPrintable(sensor->modelId()));\n                        sensor->updateStateTimestamp();\n                        sensor->setNeedSaveDatabase(true);\n                        enqueueEvent(Event(RSensors, RStateButtonEvent, sensor->id(), item));\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                        updateSensorEtag(sensor);\n                    }\n                }\n                else if (sensor->modelId() == QLatin1String(\"FOHSWITCH\"))\n                {\n                    // Friends of Hue switch\n                    // generate artificial hold event\n                    item = sensor->item(RStateButtonEvent);\n                    quint32 btn = item ? static_cast<quint32>(item->toNumber()) : 0;\n                    const quint32 action = btn & 0x03;\n                    if (btn >= S_BUTTON_1 && btn <= S_BUTTON_6 && action == S_BUTTON_ACTION_INITIAL_PRESS)\n                    {\n                        btn &= ~0x03;\n                        item->setValue(btn + S_BUTTON_ACTION_HOLD);\n                        DBG_Printf(DBG_INFO, \"FoH switch button %d Hold %s\\n\", item->toNumber(), qPrintable(sensor->modelId()));\n                        sensor->updateStateTimestamp();\n                        sensor->setNeedSaveDatabase(true);\n                        enqueueEvent(Event(RSensors, RStateButtonEvent, sensor->id(), item));\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                        updateSensorEtag(sensor);\n                    }\n                }\n                else if (!item && sensor->modelId().startsWith(QLatin1String(\"lumi.vibration\")) && sensor->type() == QLatin1String(\"ZHAVibration\"))\n                {\n                    item = sensor->item(RStateVibration);\n                    if (item && item->toBool())\n                    {\n                        DBG_Printf(DBG_INFO, \"sensor %s (%s): disable vibration\\n\", qPrintable(sensor->id()), qPrintable(sensor->modelId()));\n                        item->setValue(false);\n                        sensor->setNeedSaveDatabase(true);\n                        sensor->updateStateTimestamp();\n                        enqueueEvent(Event(RSensors, RStateVibration, sensor->id(), item));\n                        enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                        updateSensorEtag(sensor);\n                    }\n                }\n                else if (sensor->type().endsWith(QLatin1String(\"AncillaryControl\")))\n                {\n                    DBG_Printf(DBG_IAS, \"[IAS ACE] - Reseting counter\\n\");\n                }\n\n                sensor->durationDue = QDateTime();\n            }\n            else\n            {\n                sensorCheckFast = CHECK_SENSOR_FAST_ROUNDS;\n            }\n        }\n    }\n\n    // adjust check speed if needed\n    int interval = (sensorCheckFast > 0) ? CHECK_SENSOR_FAST_INTERVAL\n                                         : CHECK_SENSOR_INTERVAL;\n    if (interval != checkSensorsTimer->interval())\n    {\n        DBG_Printf(DBG_INFO, \"Set sensor check interval to %d milliseconds\\n\", interval);\n        checkSensorsTimer->setInterval(interval);\n    }\n}\n\n/*! Check insta mac address to model identifier.\n */\nvoid DeRestPluginPrivate::checkInstaModelId(Sensor *sensor)\n{\n    if (sensor && existDevicesWithVendorCodeForMacPrefix(sensor->address(), VENDOR_INSTA))\n    {\n        if (!sensor->modelId().endsWith(QLatin1String(\"_1\")))\n        {   // extract model identifier from mac address 6th byte\n            const quint64 model = (sensor->address().ext() >> 16) & 0xff;\n            QString modelId;\n            if      (model == 0x01) { modelId = QLatin1String(\"HS_4f_GJ_1\"); }\n            else if (model == 0x02) { modelId = QLatin1String(\"WS_4f_J_1\"); }\n            else if (model == 0x03) { modelId = QLatin1String(\"WS_3f_G_1\"); }\n\n            if (!modelId.isEmpty() && sensor->modelId() != modelId)\n            {\n                sensor->setModelId(modelId);\n                sensor->setNeedSaveDatabase(true);\n                updateSensorEtag(sensor);\n            }\n        }\n    }\n}\n\n/*! Heuristic to detect the type and configuration of devices.\n */\nvoid DeRestPluginPrivate::handleIndicationSearchSensors(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (searchSensorsState != SearchSensorsActive)\n    {\n        return;\n    }\n\n    if (DEV_TestManaged())\n    {\n        return;\n    }\n\n    Device *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n    if (device && device->managed())\n    {\n        return;\n    }\n\n    if (isSameAddress(ind.srcAddress(), fastProbeAddr))\n    {\n        DBG_Printf(DBG_INFO, \"FP indication 0x%04X / 0x%04X (0x%016llX / 0x%04X)\\n\", ind.profileId(), ind.clusterId(), ind.srcAddress().ext(), ind.srcAddress().nwk());\n        DBG_Printf(DBG_INFO, \"                      ...     (0x%016llX / 0x%04X)\\n\", fastProbeAddr.ext(), fastProbeAddr.nwk());\n    }\n\n    if (ind.profileId() == ZDP_PROFILE_ID && ind.clusterId() == ZDP_DEVICE_ANNCE_CLID)\n    {\n        QDataStream stream(ind.asdu());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint8 seq;\n        quint16 nwk;\n        quint64 ext;\n        quint8 macCapabilities;\n\n        stream >> seq;\n        stream >> nwk;\n        stream >> ext;\n        stream >> macCapabilities;\n\n        DBG_Printf(DBG_INFO, \"device announce 0x%016llX (0x%04X) mac capabilities 0x%02X\\n\", ext, nwk, macCapabilities);\n\n        // filter supported devices\n\n        // Busch-Jaeger\n        if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_BUSCH_JAEGER))\n        {\n        }\n        else if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_UBISYS))\n        {\n        }\n        else if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_SUNRICHER))\n        {\n        }\n        else if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_BOSCH))\n        { // macCapabilities == 0\n        }\n        else if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_DEVELCO))\n        { // macCapabilities == 0\n        }\n        else if (macCapabilities & deCONZ::MacDeviceIsFFD)\n        {\n            if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_LDS))\n            { //  Fix to allow Samsung SmartThings plug sensors to be created (7A-PL-Z-J3, modelId ZB-ONOFFPlug-D0005)\n            }\n            else if (existDevicesWithVendorCodeForMacPrefix(ext, VENDOR_JASCO))\n            { //  Fix to support GE mains powered switches\n            }\n            else\n            {\n                return;\n            }\n        }\n        else if (macCapabilities == 0)\n        {\n            return;\n        }\n\n        if (fastProbeAddr.hasExt())\n        {\n            return;\n        }\n\n        DBG_Printf(DBG_INFO, \"set fast probe address to 0x%016llX (0x%04X)\\n\", ext, nwk);\n        fastProbeAddr.setExt(ext);\n        fastProbeAddr.setNwk(nwk);\n        if (!fastProbeTimer->isActive())\n        {\n            fastProbeTimer->start(900);\n        }\n\n        fastProbeIndications.clear();\n        fastProbeIndications.push_back(ind);\n\n        std::vector<SensorCandidate>::iterator i = searchSensorsCandidates.begin();\n        std::vector<SensorCandidate>::iterator end = searchSensorsCandidates.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->address.ext() == ext || i->address.nwk() == nwk)\n            {\n                i->waitIndicationClusterId = 0xffff;\n                i->timeout.invalidate();\n                i->address = deCONZ::Address(); // clear\n            }\n        }\n\n        SensorCandidate sc;\n        sc.waitIndicationClusterId = 0xffff;\n        sc.address.setExt(ext);\n        sc.address.setNwk(nwk);\n        sc.macCapabilities = macCapabilities;\n        searchSensorsCandidates.push_back(sc);\n        return;\n    }\n    else if (ind.profileId() == ZDP_PROFILE_ID)\n    {\n        if (ind.clusterId() == ZDP_MATCH_DESCRIPTOR_CLID)\n        {\n            return;\n        }\n\n        if (!isSameAddress(ind.srcAddress(), fastProbeAddr))\n        {\n            return;\n        }\n\n        std::vector<SensorCandidate>::iterator i = searchSensorsCandidates.begin();\n        std::vector<SensorCandidate>::iterator end = searchSensorsCandidates.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->address.ext() == fastProbeAddr.ext())\n            {\n                DBG_Printf(DBG_INFO, \"ZDP indication search sensors 0x%016llX (0x%04X) cluster 0x%04X\\n\", ind.srcAddress().ext(), ind.srcAddress().nwk(), ind.clusterId());\n\n                if (ind.clusterId() == i->waitIndicationClusterId && i->timeout.isValid())\n                {\n                    DBG_Printf(DBG_INFO, \"ZDP indication search sensors 0x%016llX (0x%04X) clear timeout on cluster 0x%04X\\n\", ind.srcAddress().ext(), ind.srcAddress().nwk(), ind.clusterId());\n                    i->timeout.invalidate();\n                    i->waitIndicationClusterId = 0xffff;\n                }\n\n                if (ind.clusterId() & 0x8000)\n                {\n                    fastProbeIndications.push_back(ind); // remember responses\n                }\n\n                fastProbeTimer->stop();\n                fastProbeTimer->start(5);\n                break;\n            }\n        }\n        return;\n    }\n    else if (ind.profileId() == ZLL_PROFILE_ID || ind.profileId() == HA_PROFILE_ID)\n    {\n        switch (ind.clusterId())\n        {\n        case ONOFF_CLUSTER_ID:\n        case SCENE_CLUSTER_ID:\n        case LEVEL_CLUSTER_ID:\n        case VENDOR_CLUSTER_ID:\n            if ((zclFrame.frameControl() & deCONZ::ZclFCClusterCommand) == 0)\n            {\n                return;\n            }\n\n            if (zclFrame.frameControl() & deCONZ::ZclFCDirectionServerToClient)\n            {\n                return;\n            }\n            break; // ok\n\n        case BASIC_CLUSTER_ID:\n            if (!zclFrame.isProfileWideCommand())\n            {\n                return;\n            }\n\n            if (zclFrame.commandId() != deCONZ::ZclReadAttributesResponseId && zclFrame.commandId() != deCONZ::ZclReportAttributesId)\n            {\n                return;\n            }\n            break; // ok\n\n        case IAS_ZONE_CLUSTER_ID:\n            break; // ok\n\n        default:\n            return;\n        }\n    }\n    else\n    {\n        return;\n    }\n\n    if (ind.dstAddressMode() != deCONZ::ApsGroupAddress && ind.dstAddressMode() != deCONZ::ApsNwkAddress)\n    {\n        return;\n    }\n\n    SensorCandidate *sc = nullptr;\n    {\n        std::vector<SensorCandidate>::iterator i = searchSensorsCandidates.begin();\n        std::vector<SensorCandidate>::iterator end = searchSensorsCandidates.end();\n\n        for (; i != end; ++i)\n        {\n            if (isSameAddress(ind.srcAddress(), i->address))\n            {\n                sc = &*i;\n                break;\n            }\n        }\n    }\n\n    if (sc && fastProbeAddr.hasExt() && sc->address.ext() == fastProbeAddr.ext())\n    {\n        if (zclFrame.manufacturerCode() == VENDOR_XIAOMI || zclFrame.manufacturerCode() == VENDOR_DSR)\n        {\n            DBG_Printf(DBG_INFO, \"Remember Xiaomi special for 0x%016llX\\n\", ind.srcAddress().ext());\n            fastProbeIndications.push_back(ind); // remember Xiaomi special report\n        }\n\n        if (!fastProbeTimer->isActive())\n        {\n            fastProbeTimer->start(5);\n        }\n\n        if (ind.profileId() == ZLL_PROFILE_ID || ind.profileId() == HA_PROFILE_ID)\n        {\n            if (ind.clusterId() == sc->waitIndicationClusterId && sc->timeout.isValid())\n            {\n                DBG_Printf(DBG_INFO, \"Clear fast probe timeout for cluster 0x%04X, 0x%016llX\\n\", ind.clusterId(), ind.srcAddress().ext());\n                sc->timeout.invalidate();\n                sc->waitIndicationClusterId = 0xffff;\n            }\n        }\n    }\n\n    quint8 macCapabilities = 0;\n    deCONZ::Address indAddress;\n    if (!sc)\n    {\n        Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n\n        if (sensor)\n        {\n            indAddress = sensor->address();\n            if (sensor->node())\n            {\n                macCapabilities = (int)sensor->node()->macCapabilities();\n            }\n        }\n\n        if (apsCtrl && (!sensor || (macCapabilities == 0)))\n        {\n            int i = 0;\n            const deCONZ::Node *node;\n\n            while (apsCtrl->getNode(i, &node) == 0)\n            {\n                /*if (node->macCapabilities() == 0)\n                {\n                    // ignore\n                }\n                else*/\n\n                if (isSameAddress(node->address(), ind.srcAddress()))\n                {\n                    indAddress = node->address();\n                    macCapabilities = node->macCapabilities();\n                    break;\n                }\n\n                i++;\n            }\n        }\n    }\n\n    // currently only end-devices are supported\n    if (!sc && (macCapabilities == 0 || (macCapabilities & deCONZ::MacDeviceIsFFD)))\n    {\n        return;\n    }\n\n    if (!sc && indAddress.hasExt() && indAddress.hasNwk())\n    {\n        SensorCandidate sc2;\n        sc2.address = indAddress;\n        sc2.macCapabilities = macCapabilities;\n        searchSensorsCandidates.push_back(sc2);\n        sc = &searchSensorsCandidates.back();\n    }\n\n    if (!sc) // we need a valid candidate from device announce or cache\n    {\n        return;\n    }\n\n    if (existDevicesWithVendorCodeForMacPrefix(sc->address, VENDOR_IKEA))\n    {\n        if (sc->macCapabilities & deCONZ::MacDeviceIsFFD) // end-devices only\n            return;\n\n        if (ind.profileId() != HA_PROFILE_ID)\n            return;\n\n        // filter for remote control toggle command (large button)\n        if (ind.srcEndpoint() == 0x01 && ind.clusterId() == SCENE_CLUSTER_ID  && zclFrame.manufacturerCode() == VENDOR_IKEA &&\n                 zclFrame.commandId() == 0x07 && zclFrame.payload().at(0) == 0x02)\n        {\n            // TODO move following legacy cleanup code in Phoscon App / switch editor\n            DBG_Printf(DBG_INFO, \"ikea remote setup button\\n\");\n\n            Sensor *s = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n            if (!s)\n            {\n                return;\n            }\n\n            std::vector<Rule>::iterator ri = rules.begin();\n            std::vector<Rule>::iterator rend = rules.end();\n\n            QString sensorAddress(QLatin1String(\"/sensors/\"));\n            sensorAddress.append(s->id());\n\n            bool changed = false;\n\n            for (; ri != rend; ++ri)\n            {\n                if (ri->state() != Rule::StateNormal)\n                {\n                    continue;\n                }\n\n                std::vector<RuleCondition>::const_iterator ci = ri->conditions().begin();\n                std::vector<RuleCondition>::const_iterator cend = ri->conditions().end();\n\n                for (; ci != cend; ++ci)\n                {\n                    if (ci->address().startsWith(sensorAddress))\n                    {\n                        if (ri->name().startsWith(QLatin1String(\"default-ct\")) && ri->owner() == QLatin1String(\"deCONZ\"))\n                        {\n                            DBG_Printf(DBG_INFO, \"ikea remote delete legacy rule %s\\n\", qPrintable(ri->name()));\n                            ri->setState(Rule::StateDeleted);\n                            ri->setNeedSaveDatabase();\n                            changed = true;\n                        }\n                    }\n                }\n            }\n\n            if (changed)\n            {\n                needRuleCheck = RULE_CHECK_DELAY;\n                queSaveDb(DB_RULES, DB_SHORT_SAVE_DELAY);\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "rest_touchlink.cpp",
          "type": "blob",
          "size": 25.7470703125,
          "content": "/*\n * Copyright (c) 2016-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QApplication>\n#include <QString>\n#include <QTcpSocket>\n#include <QVariantMap>\n#include \"de_web_plugin_private.h\"\n#include \"deconz/u_rand32.h\"\n\n// duration to wait for scan responses\n#define TL_SCAN_WAIT_TIME 250\n#define TL_TRANSACTION_TIMEOUT 7000 // default 8s, subtract 1s for sanity\n\n#define TL_RECONNECT_NOW          100 // small delay to prevent false positives\n#define TL_RECONNECT_CHECK_DELAY  5000\n#define TL_DISCONNECT_CHECK_DELAY 100\n\n#define TL_SCAN_COUNT (touchlinkChannel == 11 ? 5 : 1)\n\n// Touchlink ZCL command ids\n#define TL_CMD_SCAN_REQ                    0x00\n#define TL_CMD_SCAN_RSP                    0x01\n#define TL_CMD_DEVICE_INFORMATION_REQ      0x02\n#define TL_CMD_DEVICE_INFORMATION_RSP      0x03\n#define TL_CMD_IDENTIFY_REQ                0x06\n#define TL_CMD_RESET_TO_FACTORY_NEW_REQ    0x07\n#define TL_CMD_NETWORK_START_REQ           0x10\n#define TL_CMD_NETWORK_START_RSP           0x11\n#define TL_CMD_NETWORK_JOIN_ROUTER_REQ     0x12\n#define TL_CMD_NETWORK_JOIN_ROUTER_RSP     0x13\n#define TL_CMD_NETWORK_JOIN_ENDDEVICE_REQ  0x14\n#define TL_CMD_NETWORK_JOIN_ENDDEVICE_RSP  0x15\n#define TL_CMD_NETWORK_UPDATE_REQ          0x16\n#define TL_CMD_ENDPOINT_INFORMATION        0x40\n\n// flag for factory new in scan response 9th byte\n#define FACTORY_NEW_FLAG 0x01\n\n#define NETWORK_ATTEMPS 10\n\n/*! Init the touchlink api and helpers.\n */\nvoid DeRestPluginPrivate::initTouchlinkApi()\n{\n    touchlinkState = TL_Idle;\n    touchlinkCtrl = deCONZ::TouchlinkController::instance();\n\n    DBG_Assert(touchlinkCtrl != 0);\n\n    connect(touchlinkCtrl, SIGNAL(startInterpanModeConfirm(deCONZ::TouchlinkStatus)),\n            this, SLOT(startTouchlinkModeConfirm(deCONZ::TouchlinkStatus)));\n\n    connect(touchlinkCtrl, SIGNAL(sendInterpanConfirm(deCONZ::TouchlinkStatus)),\n            this, SLOT(sendTouchlinkConfirm(deCONZ::TouchlinkStatus)));\n\n    connect(touchlinkCtrl, SIGNAL(interpanIndication(QByteArray)),\n            this, SLOT(interpanDataIndication(QByteArray)));\n\n    touchlinkTimer = new QTimer(this);\n    touchlinkTimer->setSingleShot(true);\n    connect(touchlinkTimer, SIGNAL(timeout()),\n            this, SLOT(touchlinkTimerFired()));\n}\n\n/*! Touchlink REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleTouchlinkApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.path[2] != \"touchlink\")\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // POST /api/<apikey>/touchlink/scan\n    if ((req.path.size() == 4) && (req.hdr.method() == \"POST\") && (req.path[3] == \"scan\"))\n    {\n        return touchlinkScan(req, rsp);\n    }\n    // GET /api/<apikey>/touchlink/scan\n    if ((req.path.size() == 4) && (req.hdr.method() == \"GET\") && (req.path[3] == \"scan\"))\n    {\n        return getTouchlinkScanResults(req, rsp);\n    }\n    // POST /api/<apikey>/touchlink/<id>/identify\n    if ((req.path.size() == 5) && (req.hdr.method() == \"POST\") && (req.path[4] == \"identify\"))\n    {\n        return identifyLight(req, rsp);\n    }\n    // POST /api/<apikey>/touchlink/<id>/reset\n    if ((req.path.size() == 5) && (req.hdr.method() == \"POST\") && (req.path[4] == \"reset\"))\n    {\n        return resetLight(req, rsp);\n    }\n\n    return REQ_NOT_HANDLED;\n}\n\n/*! POST /api/<apikey>/touchlink/scan\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::touchlinkScan(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n\n    if (touchlinkState != TL_Idle)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    uint32_t transactionId = U_rand32();\n\n    if (transactionId == 0)\n    {\n        transactionId++;\n    }\n\n    touchlinkAction = TouchlinkScan;\n    touchlinkChannel = 11; // start channel\n    touchlinkScanCount = 0;\n    touchlinkScanResponses.clear();\n    touchlinkScanTime = QDateTime::currentDateTime();\n    touchlinkReq.setTransactionId(transactionId);\n\n    touchlinkDisconnectNetwork();\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/touchlink/scan\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getTouchlinkScanResults(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n    rsp.httpStatus = HttpStatusOk;\n\n    bool scanning = false;\n\n    if ((touchlinkAction == TouchlinkScan) && (touchlinkState != TL_Idle))\n    {\n        scanning = true;\n    }\n\n    rsp.map[\"scanstate\"] = (scanning ? \"scanning\" : \"idle\");\n    rsp.map[\"lastscan\"] = touchlinkScanTime.toString(\"yyyy-MM-ddTHH:mm:ss\");\n\n    QVariantMap result;\n\n\n    std::vector<ScanResponse>::const_iterator i = touchlinkScanResponses.begin();\n    std::vector<ScanResponse>::const_iterator end = touchlinkScanResponses.end();\n\n    for (; i != end; ++i)\n    {\n        QVariantMap item;\n        item[\"address\"] = QString(\"0x%1\").arg(i->address.ext(), int(16), int(16), QChar('0'));\n        item[\"factorynew\"] = i->factoryNew;\n        item[\"rssi\"] = (double)i->rssi;\n        item[\"channel\"] = (double)i->channel;\n        item[\"panid\"] = (double)i->panid;\n        result[i->id] = item;\n    }\n\n    rsp.map[\"result\"] = result;\n\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/touchlink/<id>/identify\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::identifyLight(const ApiRequest &req, ApiResponse &rsp)\n{\n    /*\n     * - disconnect\n     * - start interpan mode\n     * - send interpan scan request\n     * - send interpan identify\n     * - reconnect\n     */\n\n    if (touchlinkState != TL_Idle)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    QString id = req.path[3];\n\n    touchlinkDevice.id.clear(); // mark as undefined\n\n    { // search the device according to its id\n        std::vector<ScanResponse>::const_iterator i = touchlinkScanResponses.begin();\n        std::vector<ScanResponse>::const_iterator end = touchlinkScanResponses.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == id)\n            {\n                touchlinkDevice = *i;\n                break;\n            }\n        }\n    }\n\n    if (touchlinkDevice.id.isEmpty())\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    uint32_t transactionId = U_rand32();\n\n    if (transactionId == 0)\n    {\n        transactionId++;\n    }\n\n    touchlinkReq.setTransactionId(transactionId);\n    touchlinkAction = TouchlinkIdentify;\n    touchlinkChannel = touchlinkDevice.channel;\n\n    touchlinkDisconnectNetwork();\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/touchlink/<id>/reset\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::resetLight(const ApiRequest &req, ApiResponse &rsp)\n{\n    /*\n     * - disconnect\n     * - start interpan mode\n     * - send interpan scan request\n     * - send interpan reset to factory new request\n     * - reconnect\n     */\n\n    if (touchlinkState != TL_Idle)\n    {\n        rsp.httpStatus = HttpStatusServiceUnavailable;\n        return REQ_READY_SEND;\n    }\n\n    QString id = req.path[3];\n\n    touchlinkDevice.id.clear(); // mark as undefined\n\n    { // search the device according to its id\n        std::vector<ScanResponse>::const_iterator i = touchlinkScanResponses.begin();\n        std::vector<ScanResponse>::const_iterator end = touchlinkScanResponses.end();\n\n        for (; i != end; ++i)\n        {\n            if (i->id == id)\n            {\n                touchlinkDevice = *i;\n                break;\n            }\n        }\n    }\n\n    if (touchlinkDevice.id.isEmpty())\n    {\n        rsp.httpStatus = HttpStatusNotFound;\n        return REQ_READY_SEND;\n    }\n\n    uint32_t transactionId = U_rand32();\n\n    if (transactionId == 0)\n    {\n        transactionId++;\n    }\n\n    touchlinkReq.setTransactionId(transactionId);\n    touchlinkAction = TouchlinkReset;\n    touchlinkChannel = touchlinkDevice.channel;\n\n    DBG_Printf(DBG_TLINK, \"start touchlink reset for 0x%016llX\\n\", touchlinkDevice.address.ext());\n\n    touchlinkDisconnectNetwork();\n\n    rsp.httpStatus = HttpStatusOk;\n\n    return REQ_READY_SEND;\n}\n\n/*! Starts the interpan mode.\n    \\param channel the channel which shall be used for interpan communication\n */\nvoid DeRestPluginPrivate::startTouchlinkMode(uint8_t channel)\n{\n    DBG_Printf(DBG_TLINK, \"start interpan mode on channel %u\\n\", channel);\n    touchlinkChannel = channel;\n    touchlinkState = TL_StartingInterpanMode;\n\n    if (touchlinkCtrl->startInterpanMode(touchlinkChannel) != 0)\n    {\n        DBG_Printf(DBG_TLINK, \"start interpan mode on channel %u failed\\n\", channel);\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n    }\n}\n\n/*! Callback slot for the touchlink mode confirmation.\n    \\param status tells if starting the touchlink mode was successful\n */\nvoid DeRestPluginPrivate::startTouchlinkModeConfirm(deCONZ::TouchlinkStatus status)\n{\n    DBG_Printf(DBG_TLINK, \"start touchlink mode %s\\n\", (status == deCONZ::TouchlinkSuccess ? \"success\" : \"failed\"));\n\n    if (touchlinkState != TL_StartingInterpanMode)\n    {\n        return;\n    }\n\n    if (status != deCONZ::TouchlinkSuccess)\n    {\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n        return;\n    }\n\n    if (touchlinkAction == TouchlinkScan)\n    {\n        sendTouchlinkScanRequest();\n    }\n    else if (touchlinkAction == TouchlinkIdentify)\n    {\n        // must be send prior to identify request because we need a valid transaction id\n        sendTouchlinkScanRequest();\n    }\n    else if (touchlinkAction == TouchlinkReset)\n    {\n        // must be send prior to identify request because we need a valid transaction id\n        sendTouchlinkScanRequest();\n    }\n    else\n    {\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n    }\n}\n\n/*! Request to disconnect from network.\n */\nvoid DeRestPluginPrivate::touchlinkDisconnectNetwork()\n{\n    DBG_Assert(touchlinkState == TL_Idle);\n\n    if (touchlinkState != TL_Idle)\n    {\n        return;\n    }\n\n    DBG_Assert(apsCtrl != 0);\n\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    touchlinkNetworkDisconnectAttempts = NETWORK_ATTEMPS;\n    touchlinkNetworkConnectedBefore = gwRfConnectedExpected;\n    touchlinkState = TL_DisconnectingNetwork;\n\n    apsCtrl->setNetworkState(deCONZ::NotInNetwork);\n\n    touchlinkTimer->start(TL_DISCONNECT_CHECK_DELAY);\n}\n\n/*! Checks if network is disconnected to proceed with further actions.\n */\nvoid DeRestPluginPrivate::checkTouchlinkNetworkDisconnected()\n{\n    if (touchlinkState != TL_DisconnectingNetwork)\n    {\n        return;\n    }\n\n    if (touchlinkNetworkDisconnectAttempts > 0)\n    {\n        touchlinkNetworkDisconnectAttempts--;\n    }\n\n    if (isInNetwork())\n    {\n        if (touchlinkNetworkDisconnectAttempts == 0)\n        {\n            DBG_Printf(DBG_TLINK, \"disconnect from network failed, abort touchlink action\\n\");\n\n            // even if we seem to be connected force a delayed reconnect attemp to\n            // prevent the case that the disconnect happens shortly after here\n            touchlinkStartReconnectNetwork(TL_RECONNECT_CHECK_DELAY);\n        }\n        else\n        {\n            DBG_Assert(apsCtrl != 0);\n            if (apsCtrl)\n            {\n                DBG_Printf(DBG_TLINK, \"disconnect from network failed, try again\\n\");\n                apsCtrl->setNetworkState(deCONZ::NotInNetwork);\n                touchlinkTimer->start(TL_DISCONNECT_CHECK_DELAY);\n            }\n            else\n            {   // sanity\n                touchlinkState = TL_Idle;\n            }\n        }\n\n        return;\n    }\n\n    startTouchlinkMode(touchlinkChannel);\n}\n\n/*! Sends the touchlink scan request as broadcast.\n */\nvoid DeRestPluginPrivate::sendTouchlinkScanRequest()\n{\n    touchlinkReq.setChannel(touchlinkChannel);\n    touchlinkReq.setDstAddressMode(deCONZ::ApsNwkAddress);\n    touchlinkReq.dstAddress().setNwk(0xFFFF);\n    touchlinkReq.setPanId(0xFFFF);\n    touchlinkReq.setClusterId(0x1000);\n    touchlinkReq.setProfileId(ZLL_PROFILE_ID);\n\n    touchlinkReq.asdu().clear();\n\n    QDataStream stream(&touchlinkReq.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    uint8_t cmd = TL_CMD_SCAN_REQ;\n    uint8_t frameControl = deCONZ::ZclFCProfileCommand | deCONZ::ZclFCDirectionClientToServer;\n    uint8_t seq = touchlinkReq.transactionId();\n\n    uint8_t zigbeeInfo = 0x02; // 0x01 /* router */ | 0x04 /* rx on when idle */;\n    uint8_t zllInfo = 0x33;\n\n    stream << frameControl;\n    stream << seq;\n    stream << cmd;\n    stream << touchlinkReq.transactionId();\n    stream << zigbeeInfo;\n    stream << zllInfo;\n\n    touchlinkScanCount++;\n\n    DBG_Printf(DBG_TLINK, \"send scan request TrId: 0x%08X\\n\", touchlinkReq.transactionId());\n\n    if (touchlinkCtrl->sendInterpanRequest(touchlinkReq) == 0)\n    {\n        touchlinkState = TL_SendingScanRequest;\n    }\n    else\n    {\n        DBG_Printf(DBG_TLINK, \"touchlink send scan request failed\\n\");\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n        return;\n    }\n}\n\n/*! Sends the touchlink identify request to a device.\n */\nvoid DeRestPluginPrivate::sendTouchlinkIdentifyRequest()\n{\n    touchlinkReq.setChannel(touchlinkChannel);\n    touchlinkReq.setDstAddressMode(deCONZ::ApsExtAddress);\n    touchlinkReq.dstAddress() = touchlinkDevice.address;\n    touchlinkReq.setPanId(touchlinkDevice.panid);\n    touchlinkReq.setClusterId(0x1000);\n    touchlinkReq.setProfileId(ZLL_PROFILE_ID);\n\n    touchlinkReq.asdu().clear();\n\n    QDataStream stream(&touchlinkReq.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    uint8_t cmd = TL_CMD_IDENTIFY_REQ;\n    uint8_t frameControl = deCONZ::ZclFCProfileCommand | deCONZ::ZclFCDirectionClientToServer;\n    uint8_t seq = touchlinkReq.transactionId();\n\n    uint16_t duration = 5;\n\n    stream << frameControl;\n    stream << seq;\n    stream << cmd;\n    stream << touchlinkReq.transactionId();\n    stream << duration;\n\n    DBG_Printf(DBG_TLINK, \"send identify request TrId: 0x%08X\\n\", touchlinkReq.transactionId());\n    if (touchlinkCtrl->sendInterpanRequest(touchlinkReq) == 0)\n    {\n        touchlinkState = TL_SendingIdentifyRequest;\n    }\n    else\n    {\n        DBG_Printf(DBG_TLINK, \"touchlink send identify request failed\\n\");\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n    }\n}\n\n/*! Sends the touchlink reset request to a device.\n */\nvoid DeRestPluginPrivate::sendTouchlinkResetRequest()\n{\n    touchlinkReq.setChannel(touchlinkChannel);\n    touchlinkReq.setDstAddressMode(deCONZ::ApsExtAddress);\n    touchlinkReq.dstAddress() = touchlinkDevice.address;\n    touchlinkReq.setPanId(touchlinkDevice.panid);\n    touchlinkReq.setClusterId(0x1000);\n    touchlinkReq.setProfileId(ZLL_PROFILE_ID);\n\n    touchlinkReq.asdu().clear();\n\n    QDataStream stream(&touchlinkReq.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    uint8_t cmd = TL_CMD_RESET_TO_FACTORY_NEW_REQ;\n    uint8_t frameControl = deCONZ::ZclFCProfileCommand | deCONZ::ZclFCDirectionClientToServer;\n    uint8_t seq = touchlinkReq.transactionId();\n\n    stream << frameControl;\n    stream << seq;\n    stream << cmd;\n    stream << touchlinkReq.transactionId();\n\n    DBG_Printf(DBG_TLINK, \"send reset request TrId: 0x%08X\\n\", touchlinkReq.transactionId());\n    if (touchlinkCtrl->sendInterpanRequest(touchlinkReq) == 0)\n    {\n        touchlinkState = TL_SendingResetRequest;\n    }\n    else\n    {\n        DBG_Printf(DBG_TLINK, \"touchlink send reset request failed\\n\");\n        // abort and restore previous network state\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n    }\n}\n\n/*! Starts a delayed action based on current touchlink state.\n */\nvoid DeRestPluginPrivate::touchlinkTimerFired()\n{\n    switch (touchlinkState)\n    {\n    case TL_Idle:\n        break;\n\n    case TL_WaitScanResponses:\n        touchlinkScanTimeout();\n        break;\n\n    case TL_ReconnectNetwork:\n        touchlinkReconnectNetwork();\n        break;\n\n    case TL_DisconnectingNetwork:\n        checkTouchlinkNetworkDisconnected();\n        break;\n\n    case TL_SendingScanRequest:\n        sendTouchlinkScanRequest();\n        break;\n\n    default:\n        DBG_Printf(DBG_TLINK, \"touchlinkTimerFired() unhandled state %d\\n\", touchlinkState);\n        break;\n    }\n}\n\n/*! Confirmation callback for a interpan request.\n    \\param status tells if the request was sent\n */\nvoid DeRestPluginPrivate::sendTouchlinkConfirm(deCONZ::TouchlinkStatus status)\n{\n    if (status != deCONZ::TouchlinkSuccess)\n    {\n        DBG_Printf(DBG_TLINK, \"touchlink confirm status %d for action %d\\n\", status, touchlinkAction);\n    }\n\n    if (touchlinkState == TL_SendingScanRequest)\n    {\n        switch (touchlinkAction)\n        {\n        case TouchlinkScan:\n        {\n            if (touchlinkScanCount > TL_SCAN_COUNT)\n            {\n                touchlinkState = TL_WaitScanResponses;\n                touchlinkTimer->start(TL_SCAN_WAIT_TIME);\n            }\n            else\n            {\n                touchlinkTimer->start(1);\n            }\n\n        }\n            break;\n\n        case TouchlinkIdentify:\n        case TouchlinkReset:\n        {\n            touchlinkState = TL_WaitScanResponses;\n            touchlinkTimer->start(TL_TRANSACTION_TIMEOUT);\n        }\n            break;\n\n        default:\n        {\n            DBG_Printf(DBG_TLINK, \"unknown touchlink action: %d, abort\\n\", touchlinkAction);\n            // abort and restore previous network state\n            touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n        }\n            break;\n        }\n    }\n    else if (touchlinkState == TL_WaitScanResponses)\n    {\n        // empty\n    }\n    else if ((touchlinkState == TL_SendingIdentifyRequest) ||\n             (touchlinkState == TL_SendingResetRequest))\n    {\n        if (status == deCONZ::TouchlinkSuccess)\n        {\n            // mark the reset node as not available\n            if (touchlinkState == TL_SendingResetRequest)\n            {\n                std::vector<LightNode>::iterator i = nodes.begin();\n                std::vector<LightNode>::iterator end = nodes.end();\n\n                for (; i != end; ++i)\n                {\n                    if (i->address().ext() == touchlinkDevice.address.ext())\n                    {\n                        // TODO: remove the node from groups\n                        i->item(RStateReachable)->setValue(false);\n                        updateEtag(i->etag);\n                        updateEtag(gwConfigEtag);\n                    }\n                }\n            }\n        }\n\n        // finished go back to normal operationg state and reconnect to network\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n    }\n    else if (touchlinkState != TL_Idle)\n    {\n        DBG_Printf(DBG_TLINK, \"touchlink send confirm in unexpected state: %d\\n\", touchlinkState);\n    }\n}\n\n/*! Timer callback than duration for scan responses expires.\n */\nvoid DeRestPluginPrivate::touchlinkScanTimeout()\n{\n    if (touchlinkState != TL_WaitScanResponses)\n    {\n        return;\n    }\n\n    if (touchlinkAction == TouchlinkReset || touchlinkAction == TouchlinkIdentify)\n    {\n        DBG_Printf(DBG_TLINK, \"wait for scan response before reset/identify to fn timeout\\n\");\n        touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n        return;\n    }\n    else if (touchlinkAction == TouchlinkScan)\n    {\n        if (touchlinkChannel < 26)\n        {\n            touchlinkChannel++;\n            touchlinkScanCount = 0;\n            startTouchlinkMode(touchlinkChannel);\n        }\n        else\n        {\n            DBG_Printf(DBG_TLINK, \"scan finished found %u device(s)\\n\", (uint)touchlinkScanResponses.size());\n            touchlinkStartReconnectNetwork(TL_RECONNECT_NOW);\n        }\n    }\n}\n\n/*! Callback if interpan data like touchlink frames are received.\n    \\param data the indication data\n */\nvoid DeRestPluginPrivate::interpanDataIndication(const QByteArray &data)\n{\n    if (touchlinkState == TL_Idle)\n    {\n        DBG_Printf(DBG_TLINK, \"discard ipan frame in TL_Idle state\\n\");\n        return;\n    }\n\n    QDataStream stream(data);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    uint16_t srcPanId;\n    quint64 srcAddress;\n    uint16_t dstPanId;\n    uint8_t  dstAddressMode;\n    quint64 dstExtAddress; // if dstAddressMode is 0x3\n    uint16_t dstNwkAddress; // if dstAddressMode is 0x2 or 0x01\n    uint16_t profileId;\n    uint16_t clusterId;\n    uint8_t asduLength;\n    //uint8_t asdu[asduLength];\n    uint8_t lqi;\n    int8_t rssi;\n\n    stream >> srcPanId;\n    stream >> srcAddress;\n    stream >> dstPanId;\n    stream >> dstAddressMode;\n\n    if (dstAddressMode == 0x03)\n    {\n        stream >> dstExtAddress;\n    }\n    else\n    {\n        stream >> dstNwkAddress;\n    }\n\n    stream >> profileId;\n    stream >> clusterId;\n    stream >> asduLength;\n\n    QByteArray asdu;\n\n    for (uint i = 0; i < asduLength; i++)\n    {\n        uint8_t byte;\n        stream >> byte;\n        asdu.append(byte);\n    }\n\n    stream >> lqi;\n    stream >> rssi;\n\n    // check if ZLL specific\n    if ((profileId == ZLL_PROFILE_ID) && (clusterId == 0x1000) && (asdu.size() >= 3))\n    {\n//        uint8_t frameControl = asdu[0];\n//        uint8_t seq = asdu[1];\n        uint8_t cmd = asdu[2];\n\n        ScanResponse scanResponse;\n\n        if (cmd == TL_CMD_SCAN_RSP)\n        {\n            scanResponse.id = QString::number(touchlinkScanResponses.size() + 1);\n            scanResponse.address.setExt(srcAddress);\n            scanResponse.factoryNew = ((asdu[9] & FACTORY_NEW_FLAG) != 0);\n            scanResponse.channel = touchlinkChannel;\n            scanResponse.panid = srcPanId;\n            scanResponse.transactionId = touchlinkReq.transactionId();\n            scanResponse.rssi = rssi;\n\n            DBG_Printf(DBG_TLINK, \"scan response \" FMT_MAC \", fn=%u, channel=%u rssi=%d TrId=0x%08X in state=%d action=%d\\n\",\n                       (unsigned long long)scanResponse.address.ext(),\n                       scanResponse.factoryNew, touchlinkChannel, rssi, scanResponse.transactionId,\n                       touchlinkState, touchlinkAction);\n\n            if (touchlinkAction == TouchlinkScan)\n            {\n                if (asdu.size() >= 9)\n                {\n                    std::vector<ScanResponse>::iterator i = touchlinkScanResponses.begin();\n                    std::vector<ScanResponse>::iterator end = touchlinkScanResponses.end();\n\n                    // check if already known\n                    for (; i != end; ++i)\n                    {\n                        if (i->address.ext() == srcAddress)\n                        {\n                            // update transaction id\n                            i->transactionId = touchlinkReq.transactionId();\n                            return;\n                        }\n                    }\n\n                    touchlinkScanResponses.push_back(scanResponse);\n                }\n            }\n            else if (touchlinkAction == TouchlinkReset)\n            {\n                if (scanResponse.address.ext() == touchlinkDevice.address.ext())\n                {\n                    touchlinkTimer->stop();\n                    sendTouchlinkResetRequest();\n                }\n            }\n            else if (touchlinkAction == TouchlinkIdentify)\n            {\n                if (scanResponse.address.ext() == touchlinkDevice.address.ext())\n                {\n                    touchlinkTimer->stop();\n                    sendTouchlinkIdentifyRequest();\n                }\n            }\n        }\n    }\n}\n\n/*! Reconnect to previous network state, trying serveral times if necessary.\n    \\param delay - the delay after which reconnecting shall be started\n */\nvoid DeRestPluginPrivate::touchlinkStartReconnectNetwork(int delay)\n{\n    touchlinkState = TL_ReconnectNetwork;\n    touchlinkNetworkReconnectAttempts = NETWORK_ATTEMPS;\n\n    DBG_Printf(DBG_TLINK, \"start reconnect to network\\n\");\n\n    touchlinkTimer->stop();\n    if (delay > 0)\n    {\n        touchlinkTimer->start(delay);\n    }\n    else\n    {\n        touchlinkReconnectNetwork();\n    }\n}\n\n/*! Helper to reconnect to previous network state, trying serveral times if necessary.\n */\nvoid DeRestPluginPrivate::touchlinkReconnectNetwork()\n{\n    if (touchlinkState != TL_ReconnectNetwork)\n    {\n        return;\n    }\n\n    if (isInNetwork())\n    {\n        touchlinkState = TL_Idle;\n        DBG_Printf(DBG_TLINK, \"reconnect network done\\n\");\n        return;\n    }\n\n    // respect former state\n    if (!touchlinkNetworkConnectedBefore)\n    {\n        touchlinkState = TL_Idle;\n        DBG_Printf(DBG_TLINK, \"network was not connected before\\n\");\n        return;\n    }\n\n    if (touchlinkNetworkReconnectAttempts > 0)\n    {\n        if (apsCtrl->networkState() != deCONZ::Connecting)\n        {\n            touchlinkNetworkReconnectAttempts--;\n\n            if (apsCtrl->setNetworkState(deCONZ::InNetwork) != deCONZ::Success)\n            {\n                DBG_Printf(DBG_TLINK, \"touchlink failed to reconnect to network try=%d\\n\", (NETWORK_ATTEMPS - touchlinkNetworkReconnectAttempts));\n            }\n            else\n            {\n                DBG_Printf(DBG_TLINK, \"touchlink try to reconnect to network try=%d\\n\", (NETWORK_ATTEMPS - touchlinkNetworkReconnectAttempts));\n            }\n        }\n\n        touchlinkTimer->start(TL_RECONNECT_CHECK_DELAY);\n    }\n    else\n    {\n        touchlinkState = TL_Idle;\n        DBG_Printf(DBG_TLINK, \"reconnect network failed\\n\");\n    }\n}\n\n/*! Returns true while touchlink is running.\n */\nbool DeRestPluginPrivate::isTouchlinkActive()\n{\n    return (touchlinkState != TL_Idle);\n}\n"
        },
        {
          "name": "rest_userparameter.cpp",
          "type": "blob",
          "size": 7.423828125,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QApplication>\n#include <QDesktopServices>\n#include <QString>\n#include <QTcpSocket>\n#include <QVariantMap>\n#include <QNetworkInterface>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"json.h\"\n#include <stdlib.h>\n\n/*! Configuration REST API broker.\n    \\param req - request data\n    \\param rsp - response data\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::handleUserparameterApi(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.path[2] != QLatin1String(\"userparameter\"))\n    {\n        return REQ_NOT_HANDLED;\n    }\n\n    // POST /api/<apikey>/userparameter/\n    if ((req.path.size() == 3) && (req.hdr.method() == \"POST\"))\n    {\n        return createUserParameter(req, rsp);\n    }\n    // POST /api/<apikey>/userparameter/<parameter>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"POST\"))\n    {\n        return addUserParameter(req, rsp);\n    }\n    // PUT /api/<apikey>/userparameter/<parameter>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"PUT\" || req.hdr.method() == \"PATCH\"))\n    {\n        return modifyUserParameter(req, rsp);\n    }\n    // GET /api/<apikey>/userparameter\n    else if ((req.path.size() == 3) && (req.hdr.method() == \"GET\"))\n    {\n        return getAllUserParameter(req, rsp);\n    }\n    // GET /api/<apikey>/userparameter/<parameter>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"GET\"))\n    {\n        return getUserParameter(req, rsp);\n    }\n    // DELETE /api/<apikey>/userparameter/<parameter>\n    else if ((req.path.size() == 4) && (req.hdr.method() == \"DELETE\"))\n    {\n        return deleteUserParameter(req, rsp);\n    }\n    return REQ_NOT_HANDLED;\n}\n\n/*! POST /api/<apikey>/userparameter\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::createUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    if (req.content.isEmpty())\n    {\n        rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/userparameter\"), QString(\"invalid value for userparameter\")));\n        rsp.httpStatus = HttpStatusBadRequest;\n        return REQ_READY_SEND;\n    }\n\n    rsp.httpStatus = HttpStatusOk;\n\n    // generate id\n    int i = 1;\n    while (gwUserParameter.contains(QString::number(i)))\n    {\n        i++;\n    }\n\n    QString id = QString::number(i);\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    gwUserParameter.insert(id, req.content);\n    rspItemState[\"id\"] = id;\n    rspItem[\"success\"] = rspItemState;\n    rsp.list.append(rspItem);\n\n    queSaveDb(DB_USERPARAM, DB_SHORT_SAVE_DELAY);\n    return REQ_READY_SEND;\n}\n\n/*! POST /api/<apikey>/userparameter/<parameter>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::addUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n\n    if (req.path.size() != 4)\n    {\n        return -1;\n    }\n\n    const QString &key = req.path[3];\n\n    rsp.httpStatus = HttpStatusOk;\n\n    //don't overwrite existing parameters if POST request\n    if (gwUserParameter.contains(key))\n    {\n        rsp.httpStatus = HttpStatusBadRequest;\n        rsp.list.append(errorToMap(ERR_DUPLICATE_EXIST ,\n        QString(\"config/userparameter\"), QString(\"key %1 already exists\").arg(key)));\n        return REQ_READY_SEND;\n    }\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    gwUserParameter.insert(key, req.content);\n    rspItemState[\"/config/userparameter\"] = QString(\"added new %1\").arg(key);\n    rspItem[\"success\"] = rspItemState;\n    rsp.list.append(rspItem);\n\n    queSaveDb(DB_USERPARAM, DB_SHORT_SAVE_DELAY);\n    return REQ_READY_SEND;\n}\n\n/*! PUT /api/<apikey>/userparameter/<parameter>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::modifyUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n\n    if (req.path.size() != 4)\n    {\n        return -1;\n    }\n\n    const QString &key = req.path[3];\n\n    rsp.httpStatus = HttpStatusOk;\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    //overwrite existing parameters if PUT request\n    if (gwUserParameter.contains(key))\n    {\n        QVariantMap::iterator it = gwUserParameter.find(key);\n\n        if (*it != req.content)\n        {\n            gwUserParameter.erase(it);\n            gwUserParameter.insert(key, req.content);\n            queSaveDb(DB_USERPARAM, DB_SHORT_SAVE_DELAY);\n        }\n\n        rspItemState[\"/config/userparameter\"] = QString(\"updated %1\").arg(key);\n        rspItem[\"success\"] = rspItemState;\n        rsp.list.append(rspItem);\n    }\n    else\n    {\n        gwUserParameter.insert(key, req.content);\n        rspItemState[\"/config/userparameter\"] = QString(\"added new %1\").arg(key);\n        rspItem[\"success\"] = rspItemState;\n        rsp.list.append(rspItem);\n        queSaveDb(DB_USERPARAM, DB_SHORT_SAVE_DELAY);\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/userparameter\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getAllUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n\n    rsp.httpStatus = HttpStatusOk;\n\n    QVariantMap::const_iterator k = gwUserParameter.begin();\n    QVariantMap::const_iterator kend = gwUserParameter.end();\n\n    for (; k != kend; ++k)\n    {\n        rsp.map[k.key()] = gwUserParameter.value(k.key());\n    }\n\n    if (rsp.map.isEmpty())\n    {\n        rsp.str = \"{}\"; // return empty object\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! GET /api/<apikey>/userparameter/<parameter>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::getUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    Q_UNUSED(req);\n\n    DBG_Assert(req.path.size() == 4);\n\n    if (req.path.size() != 4)\n    {\n        return -1;\n    }\n\n    const QString &key = req.path[3];\n\n    rsp.httpStatus = HttpStatusOk;\n\n    if (gwUserParameter.contains(key))\n    {\n        rsp.map[key] =  gwUserParameter.value(key);\n    }\n    else\n    {\n        QVariantMap rspItem;\n        QVariantMap rspItemState;\n        rspItemState[\"/config/userparameter\"] = QString(\"key %1 not found\").arg(key);\n        rspItem[\"error\"] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusNotFound;\n    }\n\n    return REQ_READY_SEND;\n}\n\n/*! DELETE /api/<apikey>/userparameter/<parameter>\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::deleteUserParameter(const ApiRequest &req, ApiResponse &rsp)\n{\n    DBG_Assert(req.path.size() == 4);\n\n    if (req.path.size() != 4)\n    {\n        return -1;\n    }\n\n    const QString &key = req.path[3];\n\n    QVariantMap rspItem;\n    QVariantMap rspItemState;\n\n    if (gwUserParameter.contains(key))\n    {\n        gwUserParameter.remove(key);\n        gwUserParameterToDelete.push_back(key);\n        rspItemState[\"/config/userparameter\"] = QString(\"key %1 removed\").arg(key);\n        rspItem[\"success\"] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusOk;\n        queSaveDb(DB_USERPARAM, DB_SHORT_SAVE_DELAY);\n    }\n    else\n    {\n        rspItemState[\"/config/userparameter\"] = QString(\"key %1 not found\").arg(key);\n        rspItem[\"error\"] = rspItemState;\n        rsp.list.append(rspItem);\n        rsp.httpStatus = HttpStatusNotFound;\n    }\n\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "rule.cpp",
          "type": "blob",
          "size": 19.1298828125,
          "content": "/*\r\n * Copyright (c) 2017-2021 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#include \"ias_ace.h\"\r\n#include \"rule.h\"\r\n\r\nstatic int _ruleHandle = 1;\r\n\r\n/*! Constructor. */\r\nRule::Rule() :\r\n    m_state(StateNormal),\r\n    //m_id(QLatin1String(\"none\")),\r\n    m_handle(-1),\r\n    //m_name(\"notSet\"),\r\n    //m_creationtime(\"notSet\"),\r\n    m_timesTriggered(0),\r\n    m_triggerPeriodic(0),\r\n    //m_owner(\"notSet\"),\r\n    m_status(\"enabled\")\r\n{\r\n}\r\n\r\n/*! Returns the rule state.\r\n */\r\nRule::State Rule::state() const\r\n{\r\n    return m_state;\r\n}\r\n\r\n/*! Sets the rule state.\r\n    \\param state the rule state\r\n */\r\nvoid Rule::setState(State state)\r\n{\r\n    m_state = state;\r\n}\r\n\r\n/*! Returns the rule id.\r\n */\r\nconst QString &Rule::id() const\r\n{\r\n    return m_id;\r\n}\r\n\r\n/*! Sets the rule id.\r\n    \\param id the rule id\r\n */\r\nvoid Rule::setId(const QString &id)\r\n{\r\n    m_id = id;\r\n    m_handle = _ruleHandle++;\r\n}\r\n\r\n/*! Returns the rule name.\r\n */\r\nconst QString &Rule::name() const\r\n{\r\n    return m_name;\r\n}\r\n\r\n/*! Sets the rule name.\r\n    \\param name the rule name\r\n */\r\nvoid Rule::setName(const QString &name)\r\n{\r\n    m_name = name;\r\n}\r\n\r\n/*! Returns the timestamp the rule was last triggered.\r\n */\r\nconst QDateTime &Rule::lastTriggered() const\r\n{\r\n    return m_lastTriggered;\r\n}\r\n\r\n/*! Returns the date the rule was created.\r\n */\r\nconst QString &Rule::creationtime() const\r\n{\r\n    return this->m_creationtime;\r\n}\r\n\r\n/*! Sets the date the rule was created.\r\n    \\param creationtime the date the rule was created\r\n */\r\nvoid Rule::setCreationtime(const QString &creationtime)\r\n{\r\n    this->m_creationtime = creationtime;\r\n}\r\n\r\n/*! Returns the count the rule was triggered.\r\n */\r\nquint32 Rule::timesTriggered() const\r\n{\r\n    return m_timesTriggered;\r\n}\r\n\r\n/*! Sets the count the rule was triggered.\r\n    \\param timesTriggered the count the rule was triggered\r\n */\r\nvoid Rule::setTimesTriggered(quint32 timesTriggered)\r\n{\r\n    m_timesTriggered = timesTriggered;\r\n}\r\n\r\n/*! Returns the trigger periodic time value in milliseconds.\r\n      val  < 0 trigger disabled\r\n      val == 0 trigger on event\r\n      val  > 0 trigger every <val> ms\r\n */\r\nint Rule::triggerPeriodic() const\r\n{\r\n    return m_triggerPeriodic;\r\n}\r\n\r\nvoid Rule::setTriggerPeriodic(int ms)\r\n{\r\n    m_triggerPeriodic = ms;\r\n}\r\n\r\n/*! Returns the owner of the rule.\r\n */\r\nconst QString &Rule::owner() const\r\n{\r\n    return this->m_owner;\r\n}\r\n\r\n/*! Sets the owner of the rule.\r\n    \\param owner the owner of the rule\r\n */\r\nvoid Rule::setOwner(const QString &owner)\r\n{\r\n    this->m_owner = owner;\r\n}\r\n\r\n/*! Returns the status of the rule.\r\n */\r\nconst QString &Rule::status() const\r\n{\r\n    return this->m_status;\r\n}\r\n\r\n/*! Sets the status of the rule.\r\n    \\param status the status of the rule\r\n */\r\nvoid Rule::setStatus(const QString &status)\r\n{\r\n    this->m_status = status;\r\n}\r\n\r\n/*! Returns the rule conditions.\r\n */\r\nconst std::vector<RuleCondition> &Rule::conditions() const\r\n{\r\n    return this->m_conditions;\r\n}\r\n\r\n/*! Sets the rule conditions.\r\n    \\param conditions the rule conditions\r\n */\r\nvoid Rule::setConditions(const std::vector<RuleCondition> &conditions)\r\n{\r\n    this->m_conditions = conditions;\r\n}\r\n\r\n/*! Returns the rule actions.\r\n */\r\nconst std::vector<RuleAction> &Rule::actions() const\r\n{\r\n    return this->m_actions;\r\n}\r\n\r\n/*! Sets the rule actions.\r\n    \\param actions the rule actions\r\n */\r\nvoid Rule::setActions(const std::vector<RuleAction> &actions)\r\n{\r\n    this->m_actions = actions;\r\n}\r\n\r\n/*! Returns true if rule is enabled.\r\n */\r\nbool Rule::isEnabled() const\r\n{\r\n    return m_status == QLatin1String(\"enabled\");\r\n}\r\n\r\n/*! Returns the unique rule handle (only valid for this session).\r\n */\r\nint Rule::handle() const\r\n{\r\n    return m_handle;\r\n}\r\n\r\n/*! Transfers actions into JSONString.\r\n    \\param actions vector<Action>\r\n */\r\nQString Rule::actionsToString(const std::vector<RuleAction> &actions)\r\n{\r\n    QString jsonString = QLatin1String(\"[\");\r\n    auto i = actions.cbegin();\r\n    const auto i_end = actions.cend();\r\n\r\n    for (; i != i_end; ++i)\r\n    {\r\n        jsonString.append(QLatin1String(\"{\\\"address\\\":\"));\r\n        jsonString.append(QLatin1String(\"\\\"\") + i->address() + QLatin1String(\"\\\",\"));\r\n        jsonString.append(QLatin1String(\"\\\"body\\\":\") + i->body() + QLatin1String(\",\"));\r\n        jsonString.append(QLatin1String(\"\\\"method\\\":\\\"\") + i->method() + QLatin1String(\"\\\"},\"));\r\n    }\r\n    jsonString.chop(1);\r\n    jsonString.append(QLatin1String(\"]\"));\r\n\r\n    return jsonString;\r\n}\r\n\r\n/*! Transfers conditions into JSONString.\r\n    \\param conditions vector<Condition>\r\n */\r\nQString Rule::conditionsToString(const std::vector<RuleCondition> &conditions)\r\n{\r\n    QVariantList ls;\r\n\r\n    auto i = conditions.cbegin();\r\n    const auto iend = conditions.cend();\r\n\r\n    for (; i != iend; ++i)\r\n    {\r\n        QVariantMap map;\r\n        map[\"address\"] = i->address();\r\n        map[\"operator\"] = i->ooperator();\r\n        if (i->value().isValid())\r\n        {\r\n            map[\"value\"] = i->value();\r\n        }\r\n        ls.append(map);\r\n    }\r\n\r\n    return Json::serialize(ls);\r\n}\r\n\r\n/*! Parse a JSON string into RuleAction array.\r\n    \\param json - a JSON list of actions\r\n */\r\nstd::vector<RuleAction> Rule::jsonToActions(const QString &json)\r\n{\r\n    bool ok;\r\n    std::vector<RuleAction> actions;\r\n    QVariantList var = Json::parse(json, ok).toList();\r\n\r\n    if (!ok)\r\n    {\r\n        return actions;\r\n    }\r\n\r\n    auto i = var.cbegin();\r\n    const auto end = var.cend();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        RuleAction action;\r\n        QVariantMap map = i->toMap();\r\n        action.setAddress(map[\"address\"].toString());\r\n\r\n        QVariantMap bodymap = i->toMap()[\"body\"].toMap();\r\n        action.setBody(Json::serialize(bodymap));\r\n        action.setMethod(map[\"method\"].toString());\r\n        actions.push_back(action);\r\n    }\r\n\r\n    return actions;\r\n}\r\n\r\nstd::vector<RuleCondition> Rule::jsonToConditions(const QString &json)\r\n{\r\n    bool ok;\r\n    QVariantList var = Json::parse(json, ok).toList();\r\n    std::vector<RuleCondition> conditions;\r\n\r\n    if (!ok)\r\n    {\r\n        DBG_Printf(DBG_INFO, \"failed to parse rule conditions: %s\\n\", qPrintable(json));\r\n        return conditions;\r\n    }\r\n\r\n    auto i = var.cbegin();\r\n    const auto end = var.cend();\r\n\r\n    for (; i != end; ++i)\r\n    {\r\n        const RuleCondition cond(i->toMap());\r\n        if (cond.isValid())\r\n        {\r\n            conditions.push_back(cond);\r\n        }\r\n    }\r\n\r\n    return conditions;\r\n}\r\n\r\n\r\n// Action\r\n\r\nRuleAction::RuleAction() :\r\n    m_address(\"\"),\r\n    m_method(\"\"),\r\n    m_body(\"\")\r\n{\r\n}\r\n\r\n/*! Sets the action address.\r\n    Path to a light resource, a group resource or any other bridge resource\r\n    \\param address the action address\r\n */\r\nvoid RuleAction::setAddress(const QString &address)\r\n{\r\n    m_address = address;\r\n}\r\n\r\n/*! Returns the action address.\r\n */\r\nconst QString &RuleAction::address() const\r\n{\r\n    return m_address;\r\n}\r\n\r\n/*! Sets the action method.\r\n    The HTTP method used to send the body to the given address.\r\n    Either \"POST\", \"PUT\", \"DELETE\" for local addresses.\r\n    \\param method the action method\r\n */\r\nvoid RuleAction::setMethod(const QString &method)\r\n{\r\n    DBG_Assert(method == \"POST\" || method == \"PUT\" || method == \"DELETE\" || method == \"GET\");\r\n    if (!(method == \"POST\" || method == \"PUT\" || method == \"DELETE\" || method == \"GET\"))\r\n    {\r\n        DBG_Printf(DBG_INFO, \"actions method must be either GET, POST, PUT or DELETE\\n\");\r\n        return;\r\n    }\r\n    m_method = method;\r\n}\r\n\r\n/*! Returns the action method.\r\n */\r\nconst QString &RuleAction::method() const\r\n{\r\n    return m_method;\r\n}\r\n\r\n/*! Sets the action body.\r\n    JSON string to be send to the relevant resource.\r\n    \\param body the action body\r\n */\r\nvoid RuleAction::setBody(const QString &body)\r\n{\r\n    QString str = body;\r\n    m_body = str.replace( \" \", \"\" );\r\n}\r\n\r\nbool RuleAction::operator==(const RuleAction &other) const\r\n{\r\n    return(m_address == other.m_address &&\r\n           m_body == other.m_body &&\r\n           m_method == other.m_method);\r\n}\r\n\r\n/*! Returns the action body.\r\n */\r\nconst QString &RuleAction::body() const\r\n{\r\n    return m_body;\r\n}\r\n\r\n\r\n// Condition\r\nRuleCondition::RuleCondition() :\r\n    m_prefix(nullptr),\r\n    m_suffix(nullptr),\r\n    m_op(OpUnknown),\r\n    m_num(0),\r\n    m_weekDays(127) // default all days enabled\r\n{\r\n}\r\n\r\n/*! Constructs a RuleCondition from the data given in \\p map.\r\n\r\n    The RuleCondition::isValid() method should be used to verify\r\n    the object was constructed sucessfully.\r\n */\r\nRuleCondition::RuleCondition(const QVariantMap &map)\r\n{\r\n    bool ok = false;\r\n    m_address = map[\"address\"].toString();\r\n    m_operator = map[\"operator\"].toString();\r\n    m_value = map[\"value\"];\r\n\r\n    // cache id\r\n    if (m_address.startsWith(QLatin1String(RSensors)) ||\r\n        m_address.startsWith(QLatin1String(RGroups)) ||\r\n        m_address.startsWith(QLatin1String(RLights)) ||\r\n        m_address.startsWith(QLatin1String(RAlarmSystems))) // /sensors/<id>/state/buttonevent, ...\r\n    {\r\n        QStringList addrList = m_address.split('/', SKIP_EMPTY_PARTS);\r\n        if (addrList.size() > 1)\r\n        {\r\n            m_id = addrList[1];\r\n        }\r\n    }\r\n\r\n    if (m_address.startsWith(QLatin1String(RSensors)))\r\n    {\r\n        m_prefix = RSensors;\r\n        if (m_address.endsWith(QLatin1String(\"/illuminance\")))\r\n        { // convert old to new style\r\n            m_address.replace(QLatin1String(\"/illuminance\"), QLatin1String(\"/lux\"));\r\n        }\r\n    }\r\n    else if (m_address.startsWith(QLatin1String(RConfig)))\r\n    {\r\n        m_prefix = RConfig;\r\n    }\r\n    else if (m_address.startsWith(QLatin1String(RGroups)))\r\n    {\r\n        m_prefix = RGroups;\r\n    }\r\n    else if (m_address.startsWith(QLatin1String(RLights)))\r\n    {\r\n        m_prefix = RLights;\r\n    }\r\n    else if (m_address.startsWith(QLatin1String(RAlarmSystems)))\r\n    {\r\n        m_prefix = RAlarmSystems;\r\n\r\n\r\n    }\r\n\r\n    ResourceItemDescriptor rid;\r\n\r\n    m_suffix = getResourceItemDescriptor(m_address, rid) ? rid.suffix\r\n                                                         : RInvalidSuffix;\r\n\r\n    if (m_operator == QLatin1String(\"eq\")) { m_op = OpEqual; }\r\n    else if (m_operator == QLatin1String(\"ne\")) { m_op = OpNotEqual; }\r\n    else if (m_operator == QLatin1String(\"gt\")) { m_op = OpGreaterThan; }\r\n    else if (m_operator == QLatin1String(\"lt\")) { m_op = OpLowerThan; }\r\n    else if (m_operator == QLatin1String(\"dx\")) { m_op = OpDx; }\r\n    else if (m_operator == QLatin1String(\"ddx\")) { m_op = OpDdx; }\r\n    else if (m_operator == QLatin1String(\"in\")) { m_op = OpIn; }\r\n    else if (m_operator == QLatin1String(\"not in\")) { m_op = OpNotIn; }\r\n    else if (m_operator == QLatin1String(\"stable\")) { m_op = OpStable; }\r\n    else { m_op = OpUnknown; }\r\n\r\n    // extract proper datatype\r\n    if (m_value.type() == QVariant::String)\r\n    {\r\n        const QString str = m_value.toString();\r\n\r\n        if (m_op == OpDdx || m_op == OpStable)\r\n        {\r\n            QTime t = QTime::fromString(str, \"'PT'hh:mm:ss\");\r\n            if (!t.isValid())\r\n            {\r\n                m_op = OpUnknown; // invalid\r\n                return;\r\n            }\r\n            m_time0 = t;\r\n            // cache duration in seconds\r\n            m_num = QTime(0,0,0).secsTo(t);\r\n        }\r\n        else if (m_op == OpIn || m_op == OpNotIn)\r\n        {\r\n            QStringList interval = str.split('/', SKIP_EMPTY_PARTS);\r\n            if (interval.size() == 3)\r\n            {\r\n                const QRegExp rx(\"W([0-9]{1,3})\");\r\n                const QString weekDays = interval.takeFirst();\r\n                if (rx.exactMatch(weekDays))\r\n                {\r\n                    const uint w = rx.cap(1).toUInt(&ok);\r\n                    if (!ok || w > 127)\r\n                    {\r\n                        return; // invalid\r\n                    }\r\n\r\n                    m_weekDays = static_cast<quint8>(w);\r\n                }\r\n            }\r\n\r\n            if (interval.size() != 2)\r\n            {\r\n                m_op = OpUnknown; // invalid\r\n                return;\r\n            }\r\n\r\n            QTime t0 = QTime::fromString(interval[0], \"'T'hh:mm:ss\");\r\n            QTime t1 = QTime::fromString(interval[1], \"'T'hh:mm:ss\");\r\n            if (t0.isValid() && t1.isValid())\r\n            {\r\n                m_time0 = t0;\r\n                m_time1 = t1;\r\n            } else { m_op = OpUnknown; } // mark invalid\r\n        }\r\n        else if (str == QLatin1String(\"true\") ||\r\n                 str == QLatin1String(\"false\"))\r\n        {\r\n            m_value = m_value.toBool();\r\n        }\r\n        else if ((m_op == OpGreaterThan || m_op == OpLowerThan) && m_suffix == RStateLocaltime && str.endsWith(QLatin1String(\"/localtime\")))\r\n        {\r\n            // TODO dynamically referring to other resources in conditions might be useful in general\r\n\r\n            // /config/localtime\r\n            if (str.endsWith(QLatin1String(RConfigLocalTime)))\r\n            {\r\n                m_valuePrefix = RConfig;\r\n                m_valueSuffix = RConfigLocalTime;\r\n            }\r\n            // /sensors/51/state/localtime\r\n            else if (str.startsWith(QLatin1String(RSensors)) && str.endsWith(QLatin1String(RStateLocaltime)))\r\n            {\r\n                const QStringList ls = str.split('/', SKIP_EMPTY_PARTS); // cache resource id\r\n                // [ \"sensors\", \"51\", \"state\", \"localtime\" ]\r\n                if (ls.size() == 4)\r\n                {\r\n                    m_valuePrefix = RSensors;\r\n                    m_valueSuffix = RStateLocaltime;\r\n                    m_valueId = ls[1];\r\n                }\r\n                else\r\n                {\r\n                    m_op = OpUnknown; // invalid\r\n                }\r\n            }\r\n            else\r\n            {\r\n                m_op = OpUnknown; // invalid\r\n            }\r\n        }\r\n        else if (m_op == OpEqual || m_op == OpNotEqual || m_op == OpGreaterThan || m_op == OpLowerThan)\r\n        {\r\n            if (rid.suffix == RStateArmState)\r\n            {\r\n                // transform from string to number\r\n                int num = IAS_PanelStatusFromString(str);\r\n                if (num >= 0)\r\n                {\r\n                    m_num = num;\r\n                } else { m_op = OpUnknown; } // mark invalid\r\n            }\r\n            else\r\n            {\r\n                int num = str.toInt(&ok);\r\n                if (ok)\r\n                {\r\n                    m_value = static_cast<double>(num);\r\n                } else { m_op = OpUnknown; } // mark invalid\r\n            }\r\n        }\r\n    }\r\n\r\n    if (m_value.type() == QVariant::Double ||\r\n        m_value.type() == QVariant::UInt ||\r\n        m_value.type() == QVariant::Int)\r\n    {\r\n        m_num = m_value.toInt(&ok);\r\n        if (!ok) { m_num = 0; m_op = OpUnknown; }\r\n    }\r\n    else if (m_value.type() == QVariant::Bool)\r\n    {\r\n        m_num = m_value.toBool() ? 1 : 0;\r\n    }\r\n    else if (m_value.type() == QVariant::Time)\r\n    {\r\n    }\r\n}\r\n\r\n/*! Sets the condition address.\r\n    Path to an attribute of a sensor resource.\r\n    \\param address the condition address\r\n */\r\nvoid RuleCondition::setAddress(const QString &address)\r\n{\r\n    m_address = address;\r\n}\r\n\r\n/*! Returns the condition address.\r\n */\r\nconst QString &RuleCondition::address() const\r\n{\r\n    return m_address;\r\n}\r\n\r\n/*! Sets the condition operator.\r\n    The operator can be 'eq', 'gt', 'lt' or 'dx'\r\n    \\param operator the condition operator\r\n */\r\nvoid RuleCondition::setOperator(const QString &aOperator)\r\n{\r\n    DBG_Assert((aOperator == \"eq\") || (aOperator == \"ne\") || (aOperator == \"gt\") || (aOperator == \"lt\") || (aOperator == \"dx\"));\r\n    if (!((aOperator == \"eq\") || (aOperator == \"ne\") || (aOperator == \"gt\") || (aOperator == \"lt\") || (aOperator == \"dx\")))\r\n    {\r\n        DBG_Printf(DBG_INFO, \"actions operator must be either 'eq', 'ne', 'gt', 'lt' or 'dx'\\n\");\r\n        return;\r\n    }\r\n\r\n    m_operator = aOperator;\r\n}\r\n\r\n/*! Returns the condition address.\r\n */\r\nconst QString &RuleCondition::ooperator() const\r\n{\r\n    return m_operator;\r\n}\r\n\r\n/*! Returns the condition value.\r\n */\r\nconst QVariant &RuleCondition::value() const\r\n{\r\n    return m_value;\r\n}\r\n\r\n/*! Sets the condition value.\r\n    The resource attribute is compared to this value using the given operator.\r\n    The value is cast to the data type of the resource attribute (in case of time, casted to a timePattern).\r\n    If the cast fails or the operator does not support the data type the value is cast to the rule is rejected.\r\n    \\param value the condition value\r\n */\r\nvoid RuleCondition::setValue(const QVariant &value)\r\n{\r\n    m_value = value;\r\n}\r\n\r\nbool RuleCondition::operator==(const RuleCondition &other) const\r\n{\r\n    return (m_address == other.m_address &&\r\n            m_operator == other.m_operator &&\r\n            m_value == other.m_value);\r\n}\r\n\r\n/*! Returns operator as enum.\r\n */\r\nRuleCondition::Operator RuleCondition::op() const\r\n{\r\n    return m_op;\r\n}\r\n\r\n/*! Returns resource id of address.\r\n */\r\nconst QString &RuleCondition::id() const\r\n{\r\n    return m_id;\r\n}\r\n\r\n/*! Returns resource id of address given in a value.\r\n */\r\nconst QString &RuleCondition::valueId() const\r\n{\r\n    return m_valueId;\r\n}\r\n\r\n/*! Returns value as int (for numeric and bool types).\r\n */\r\nint RuleCondition::numericValue() const\r\n{\r\n    return m_num;\r\n}\r\n\r\n/*! Returns value as duration in seconds (for operators OpDdx, OpStable, OpIn and OpNotIn).\r\n */\r\nint RuleCondition::seconds() const\r\n{\r\n    return m_num;\r\n}\r\n\r\n/*! Returns start time (for operators OpIn and OpNotIn).\r\n */\r\nconst QTime &RuleCondition::time0() const\r\n{\r\n    return m_time0;\r\n}\r\n\r\n/*! Returns end time (for operators OpIn and OpNotIn).\r\n */\r\nconst QTime &RuleCondition::time1() const\r\n{\r\n    return m_time1;\r\n}\r\n\r\n/*! Returns true if the given weekday is enabled (for operators OpIn and OpNotIn).\r\n\r\n    The condition needs format of W[bbb]/T[hh]:[mm]:[ss]/T[hh]:[mm]:[ss].\r\n    If W[bbb] is not specified all days are enabled as of W127.\r\n    \\param day - 1 Monday .. 7 Sunday\r\n */\r\nbool RuleCondition::weekDayEnabled(const int day) const\r\n{\r\n    // bbb = 0MTWTFSS – e.g. Tuesdays is 00100000 = 32\r\n    DBG_Assert(day >= 0 && day <= 7);\r\n    return (m_weekDays & (1 << (7 - day))) != 0;\r\n}\r\n\r\n/*! Returns the related Resource prefix like RSensors, RLights, etc.\r\n */\r\nconst char *RuleCondition::resource() const\r\n{\r\n    return m_prefix;\r\n}\r\n\r\n/*! Returns the Resource suffix like RStateButtonevent.\r\n */\r\nconst char *RuleCondition::suffix() const\r\n{\r\n    return m_suffix;\r\n}\r\n\r\n/*! Returns the related Resource prefix like RSensors, RLights, etc. of the value,\r\n    if value is pointing to another resource. Otherwise \\p nullptr is returned.\r\n */\r\nconst char *RuleCondition::valueResource() const\r\n{\r\n    return m_valuePrefix;\r\n}\r\n\r\n/*! Returns the Resource suffix like RStateButtonevent of the value,\r\n    if value is pointing to another resource. Otherwise \\p nullptr is returned.\r\n */\r\nconst char *RuleCondition::valueSuffix() const\r\n{\r\n    return m_valueSuffix;\r\n}\r\n\r\n/*! Returns true if two BindingTasks are equal.\r\n */\r\nbool BindingTask::operator==(const BindingTask &rhs) const\r\n{\r\n    if (rhs.action == action &&\r\n        rhs.binding == binding)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/*! Returns true if two BindingTasks are unequal.\r\n */\r\nbool BindingTask::operator!=(const BindingTask &rhs) const\r\n{\r\n    return !(*this == rhs);\r\n}\r\n"
        },
        {
          "name": "rule.h",
          "type": "blob",
          "size": 5.5068359375,
          "content": "/*\r\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\r\n * All rights reserved.\r\n *\r\n * The software in this package is published under the terms of the BSD\r\n * style license a copy of which has been included with this distribution in\r\n * the LICENSE.txt file.\r\n *\r\n */\r\n\r\n#ifndef RULE_H\r\n#define RULE_H\r\n\r\n#include <stdint.h>\r\n#include <QString>\r\n#include <vector>\r\n#include <QDateTime>\r\n#include <deconz.h>\r\n#include \"resource.h\"\r\n#include \"bindings.h\"\r\n#include \"json.h\"\r\n\r\nclass RuleCondition;\r\nclass RuleAction;\r\nclass RestNodeBase;\r\n\r\n/*! Helper class to handle ZigBee binding/unbinding for Rules. */\r\nclass BindingTask\r\n{\r\npublic:\r\n    enum Constants\r\n    {\r\n        Timeout = 20,\r\n        TimeoutEndDevice = 90,\r\n        Retries = 2\r\n    };\r\n\r\n    enum State\r\n    {\r\n        StateIdle,\r\n        StateInProgress,\r\n        StateCheck,\r\n        StateFinished\r\n    };\r\n\r\n    enum Action\r\n    {\r\n        ActionBind,\r\n        ActionUnbind\r\n    };\r\n\r\n    BindingTask():\r\n        action(ActionBind),\r\n        state(StateCheck),\r\n        timeout(BindingTask::Timeout),\r\n        retries(BindingTask::Retries),\r\n        restNode(0)\r\n    {\r\n    }\r\n\r\n    bool operator==(const BindingTask &rhs) const;\r\n    bool operator!=(const BindingTask &rhs) const;\r\n\r\n    Action action;\r\n    State state;\r\n\r\n    quint8 zdpSeqNum;\r\n    int timeout; // seconds\r\n    int retries;\r\n    RestNodeBase *restNode; // TODO refactor, this can become dangling pointer after each nodes, sensors .push_back()\r\n\r\n    Binding binding;\r\n};\r\n\r\n/*! \\class Rule\r\n\r\n    Represents a Rest API Rule.\r\n */\r\nclass Rule\r\n{\r\npublic:\r\n    Rule();\r\n\r\n    enum State\r\n    {\r\n        StateNormal,\r\n        StateDeleted\r\n    };\r\n\r\n    State state() const;\r\n    void setState(State state);\r\n    const QString &id() const;\r\n    void setId(const QString &id);\r\n    const QString &name() const;\r\n    void setName(const QString &name);\r\n    const QDateTime &lastTriggered() const;\r\n    const QString &creationtime() const;\r\n    void setCreationtime(const QString &creationtime);\r\n    quint32 timesTriggered() const;\r\n    void setTimesTriggered(quint32 timesTriggered);\r\n    int triggerPeriodic() const;\r\n    void setTriggerPeriodic(int ms);\r\n    const QString &owner() const;\r\n    void setOwner(const QString &owner);\r\n    const QString &status() const;\r\n    void setStatus(const QString &status);\r\n    const std::vector<RuleCondition> &conditions() const;\r\n    void setConditions(const std::vector<RuleCondition> &conditions);\r\n    const std::vector<RuleAction> &actions() const;\r\n    void setActions(const std::vector<RuleAction> &actions);\r\n    bool isEnabled() const;\r\n    int handle() const;\r\n    bool needSaveDatabase() const { return m_needSave; }\r\n    void setNeedSaveDatabase() { m_needSave = true; }\r\n    void clearNeedSaveDatabase() { m_needSave = false; }\r\n\r\n    static QString actionsToString(const std::vector<RuleAction> &actions);\r\n    static QString conditionsToString(const std::vector<RuleCondition> &conditions);\r\n\r\n    static std::vector<RuleAction> jsonToActions(const QString &json);\r\n    static std::vector<RuleCondition> jsonToConditions(const QString &json);\r\n\r\n    QString etag;\r\n    QDateTime lastVerify;\r\n    QDateTime m_lastTriggered;\r\n\r\nprivate:\r\n    bool m_needSave = false;\r\n    State m_state;\r\n    QString m_id;\r\n    int m_handle;\r\n    QString m_name;\r\n    QString m_creationtime;\r\n    quint32 m_timesTriggered;\r\n    int m_triggerPeriodic;\r\n    QString m_owner;\r\n    QString m_status;\r\n    std::vector<RuleCondition> m_conditions;\r\n    std::vector<RuleAction> m_actions;\r\n};\r\n\r\nclass RuleAction\r\n{\r\npublic:\r\n    RuleAction();\r\n\r\n    const QString &address() const;\r\n    void setAddress(const QString &address);\r\n    const QString &method() const;\r\n    void setMethod(const QString &method);\r\n    const QString &body() const;\r\n    void setBody(const QString &body);\r\n    bool operator==(const RuleAction &other) const;\r\n\r\nprivate:\r\n    QString m_address;\r\n    QString m_method;\r\n    QString m_body;\r\n};\r\n\r\n\r\nclass RuleCondition\r\n{\r\npublic:\r\n    enum Operator\r\n    {\r\n        OpEqual,\r\n        OpNotEqual,\r\n        OpGreaterThan,\r\n        OpLowerThan,\r\n        OpDx,\r\n        OpDdx,\r\n        OpIn,\r\n        OpNotIn,\r\n        OpStable,\r\n        OpNotStable,\r\n\r\n        OpUnknown\r\n    };\r\n\r\n    RuleCondition();\r\n    RuleCondition(const QVariantMap &map);\r\n\r\n    const QString &address() const;\r\n    void setAddress(const QString &address);\r\n    const QString &ooperator() const;\r\n    void setOperator(const QString &ooperator);\r\n    const QVariant &value() const;\r\n    void setValue(const QVariant &value);\r\n    bool operator==(const RuleCondition &other) const;\r\n\r\n    bool isValid() const { return m_op != OpUnknown; }\r\n    Operator op() const;\r\n    const QString &id() const;\r\n    const QString &valueId() const;\r\n    int numericValue() const;\r\n    int seconds() const;\r\n    const QTime &time0() const;\r\n    const QTime &time1() const;\r\n    bool weekDayEnabled(const int day) const;\r\n    const char *resource() const;\r\n    const char *suffix() const;\r\n    const char *valueResource() const;\r\n    const char *valueSuffix() const;\r\n\r\nprivate:\r\n    QString m_address;\r\n    QString m_operator;\r\n    QVariant m_value;\r\n\r\n    // internal calculated values for faster access\r\n    const char *m_prefix = nullptr;\r\n    const char *m_suffix = nullptr;\r\n    const char *m_valuePrefix = nullptr;\r\n    const char *m_valueSuffix = nullptr;\r\n    QString m_id;\r\n    QString m_valueId;\r\n    Operator m_op = OpUnknown;\r\n    int m_num = 0;\r\n    quint8 m_weekDays = 127; // default all days enabled\r\n    QTime m_time0;\r\n    QTime m_time1;\r\n\r\n};\r\n#endif // RULE_H\r\n"
        },
        {
          "name": "scene.cpp",
          "type": "blob",
          "size": 10.8974609375,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n#include <QStringBuilder>\n#include \"scene.h\"\n\n/*! Constructor.\n */\nScene::Scene() :\n    state(StateNormal),\n    externalMaster(false),\n    groupAddress(0),\n    id(0),\n    m_transitiontime(0)\n{\n}\n\n/*! Returns the transitiontime of the scene.\n */\nconst uint16_t &Scene::transitiontime() const\n{\n    return m_transitiontime;\n}\n\n/*! Sets the transitiontime of the scene.\n    \\param transitiontime the transitiontime of the scene\n */\nvoid Scene::setTransitiontime(const uint16_t &transitiontime)\n{\n    m_transitiontime = transitiontime;\n}\n\n/*! Returns the lights of the scene.\n */\nstd::vector<LightState> &Scene::lights()\n{\n    return m_lights;\n}\n\n/*! Returns the lights of the scene.\n */\nconst std::vector<LightState> &Scene::lights() const\n{\n    return m_lights;\n}\n\n/*! Sets the lights of the scene.\n    \\param lights the lights of the scene\n */\nvoid Scene::setLights(const std::vector<LightState> &lights)\n{\n    m_lights = lights;\n}\n\n/*! Adds a light to the lights of the scene.\n    \\param light the light that should be added\n */\nvoid Scene::addLightState(const LightState &light)\n{\n    m_lights.push_back(light);\n}\n\n/*! removes a light from the lights of the scene if present.\n    \\param lid the lightId that should be removed\n    \\return true if light was found and removed\n */\nbool Scene::deleteLight(const QString &lid)\n{\n    std::vector<LightState>::const_iterator l = m_lights.begin();\n    std::vector<LightState>::const_iterator lend = m_lights.end();\n    int position = 0;\n    for (; l != lend; ++l)\n    {\n        if (l->lid() == lid)\n        {\n            m_lights.erase(m_lights.begin() + position);\n            // delete scene if it contains no lights\n            if (m_lights.size() == 0)\n            {\n                state = Scene::StateDeleted;\n            }\n            return true;\n        }\n        position++;\n    }\n    return false;\n}\n\n/*! Returns light satte for given light id of the scene if present.\n    \\param lid the lightId\n    \\return the light state or 0 if not found\n */\nLightState *Scene::getLightState(const QString &lid)\n{\n    std::vector<LightState>::iterator i = m_lights.begin();\n    std::vector<LightState>::iterator end = m_lights.end();\n\n    for (; i != end; ++i)\n    {\n        if (i->lid() == lid)\n        {\n           return &*i;\n        }\n    }\n    return 0;\n}\n\n/*! Transfers lights of the scene into JSONString.\n    \\param lights vector<LightState>\n */\nQString Scene::lightsToString(const std::vector<LightState> &lights)\n{\n    std::vector<LightState>::const_iterator i = lights.begin();\n    std::vector<LightState>::const_iterator i_end = lights.end();\n    QVariantList ls;\n\n    for (; i != i_end; ++i)\n    {\n        QVariantMap map;\n        map[QLatin1String(\"lid\")] = i->lid();\n        map[QLatin1String(\"on\")] = i->on();\n        map[QLatin1String(\"bri\")] = (double)i->bri();\n        map[QLatin1String(\"tt\")] = (double)i->transitionTime();\n        map[QLatin1String(\"cm\")] = i->colorMode();\n\n        if (i->colorMode() != QLatin1String(\"none\"))\n        {\n            map[QLatin1String(\"x\")] = (double)i->x();\n            map[QLatin1String(\"y\")] = (double)i->y();\n\n            if (i->colorMode() == QLatin1String(\"hs\"))\n            {\n                map[QLatin1String(\"ehue\")] = (double)i->enhancedHue();\n                map[QLatin1String(\"sat\")] = (double)i->saturation();\n            }\n            else if (i->colorMode() == QLatin1String(\"ct\"))\n            {\n                map[QLatin1String(\"ct\")] = (double)i->colorTemperature();\n            }\n\n            map[QLatin1String(\"cl\")] = i->colorloopActive();\n            map[QLatin1String(\"clTime\")] = (double)i->colorloopTime();\n        }\n\n        ls.append(map);\n    }\n\n    return Json::serialize(ls);\n}\n\nstd::vector<LightState> Scene::jsonToLights(const QString &json)\n{\n    bool ok;\n    QVariantList var = Json::parse(json, ok).toList();\n    QVariantMap map;\n    std::vector<LightState> lights;\n\n    QVariantList::const_iterator i = var.begin();\n    QVariantList::const_iterator i_end = var.end();\n\n    if (!ok)\n    {\n        return lights;\n    }\n\n    for (; i != i_end; ++i)\n    {\n        LightState state;\n        map = i->toMap();\n        state.setLightId(map[QLatin1String(\"lid\")].toString());\n        state.setOn(map[QLatin1String(\"on\")].toBool());\n        state.setBri(map[QLatin1String(\"bri\")].toUInt());\n        state.setTransitionTime(map[QLatin1String(\"tt\")].toUInt());\n\n        if (map.contains(QLatin1String(\"x\")) && map.contains(QLatin1String(\"y\")))\n        {\n            state.setX(map[QLatin1String(\"x\")].toUInt());\n            state.setY(map[QLatin1String(\"y\")].toUInt());\n\n            if (!map.contains(QLatin1String(\"cm\")))\n            {\n                state.setColorMode(QLatin1String(\"xy\")); // backward compatibility\n            }\n        }\n\n        if (map.contains(QLatin1String(\"cl\")) && map.contains(QLatin1String(\"clTime\")))\n        {\n            state.setColorloopActive(map[QLatin1String(\"cl\")].toBool());\n            state.setColorloopTime(map[QLatin1String(\"clTime\")].toUInt());\n        }\n\n        if (map.contains(QLatin1String(\"cm\")))\n        {\n            QString colorMode = map[QLatin1String(\"cm\")].toString();\n            if (!colorMode.isEmpty())\n            {\n                state.setColorMode(colorMode);\n            }\n        }\n\n        if (state.colorMode() == QLatin1String(\"ct\") && map.contains(QLatin1String(\"ct\")))\n        {\n            quint16 ct = map[QLatin1String(\"ct\")].toUInt(&ok);\n            if (ok)\n            {\n                state.setColorTemperature(ct);\n            }\n        }\n        else if (state.colorMode() == QLatin1String(\"hs\") && map.contains(QLatin1String(\"ehue\")) && map.contains(QLatin1String(\"sat\")))\n        {\n            quint16 ehue = map[QLatin1String(\"ehue\")].toUInt(&ok);\n            if (ok)\n            {\n                quint16 sat = map[QLatin1String(\"sat\")].toUInt(&ok);\n                if (ok)\n                {\n                    state.setEnhancedHue(ehue);\n                    state.setSaturation(sat);\n                }\n            }\n        }\n\n        lights.push_back(state);\n    }\n\n    return lights;\n}\n\n\n// LightState\n\n/*! Constructor.\n */\nLightState::LightState() :\n    m_lid(\"\"),\n    m_on(false),\n    m_needRead(false),\n    m_bri(0),\n    m_x(0),\n    m_y(0),\n    m_enhancedHue(0),\n    m_saturation(0),\n    m_colorloopActive(false),\n    m_colorloopDirection(0),\n    m_colorloopTime(0),\n    m_colorMode(QLatin1String(\"none\")),\n    m_transitiontime(0)\n{\n}\n\n/*! Returns the id of the light of the scene.\n */\nconst QString &LightState::lid() const\n{\n    return m_lid;\n}\n\n/*! Sets the id of the light of the scene.\n    \\param state the rule state\n */\nvoid LightState::setLightId(const QString &lid)\n{\n    m_lid = lid;\n}\n\n/*! Returns the on status of the light of the scene.\n */\nbool LightState::on() const\n{\n    return m_on;\n}\n\n/*! Sets the on status of the light of the scene.\n    \\param on the on status of the light\n */\nvoid LightState::setOn(const bool &on)\n{\n    m_on = on;\n}\n\n/*! Returns the brightness of the light of the scene.\n */\nconst uint8_t &LightState::bri() const\n{\n    return m_bri;\n}\n\n/*! Sets the brightness of the light of the scene.\n    \\param bri the brightness of the light\n */\nvoid LightState::setBri(const uint8_t &bri)\n{\n    m_bri = bri;\n}\n\n/*! Returns the colorX value of the light of the scene.\n */\nconst uint16_t &LightState::x() const\n{\n    return m_x;\n}\n\n/*! Sets the colorX value of the light of the scene.\n    \\param x the colorX value of the light\n */\nvoid LightState::setX(const uint16_t &x)\n{\n    m_x = x;\n}\n\n/*! Returns the colorY value of the light of the scene.\n */\nconst uint16_t &LightState::y() const\n{\n    return m_y;\n}\n\n/*! Sets the colorY value of the light of the scene.\n    \\param y the colorY value of the light\n */\nvoid LightState::setY(const uint16_t &y)\n{\n    m_y = y;\n}\n\n/*! Returns the color temperature value of the light in the scene.\n */\nuint16_t LightState::colorTemperature() const\n{\n    return m_colorTemperature;\n}\n\n/*! Sets the color temperature value of the light in the scene.\n    \\param colorTemperature the color temperature value of the light\n */\nvoid LightState::setColorTemperature(uint16_t colorTemperature)\n{\n    m_colorTemperature = colorTemperature;\n}\n\n/*! Returns the enhancedHue value of the light of the scene.\n */\nconst uint16_t &LightState::enhancedHue() const\n{\n    return m_enhancedHue;\n}\n\n/*! Sets the enhancedHue value of the light of the scene.\n    \\param enhancedHue the enhancedHue value of the light\n */\nvoid LightState::setEnhancedHue(const uint16_t &enhancedHue)\n{\n    m_enhancedHue = enhancedHue;\n}\n\n/*! Returns the saturation of the light of the scene.\n */\nconst uint8_t &LightState::saturation() const\n{\n    return m_saturation;\n}\n\n/*! Sets the saturation of the light of the scene.\n    \\param sat the saturation of the light\n */\nvoid LightState::setSaturation(const uint8_t &sat)\n{\n    m_saturation = sat;\n}\n\n/*! Returns the colorloopActive status of the light of the scene.\n */\nconst bool &LightState::colorloopActive() const\n{\n    return m_colorloopActive;\n}\n\n/*! Sets the colorloopActive status of the light of the scene.\n    \\param active the colorloopActive status of the light\n */\nvoid LightState::setColorloopActive(const bool &active)\n{\n    m_colorloopActive = active;\n}\n\n/*! Returns the colorloopDirection of the light of the scene.\n */\nconst uint8_t &LightState::colorloopDirection() const\n{\n    return m_colorloopDirection;\n}\n\n/*! Sets the colorloopDirection of the light of the scene.\n    \\param direction the colorloopDirection of the light\n */\nvoid LightState::setColorloopDirection(const uint8_t &direction)\n{\n    m_colorloopDirection = direction;\n}\n\n/*! Returns the colorloopTime of the light of the scene.\n */\nconst uint8_t &LightState::colorloopTime() const\n{\n    return m_colorloopTime;\n}\n\n/*! Sets the colorloopTime of the light of the scene.\n    \\param time the colorloopTime of the light\n */\nvoid LightState::setColorloopTime(const uint8_t &time)\n{\n    m_colorloopTime = time;\n}\n\n/*! Returns the color mode of the light in the scene.\n */\nconst QString &LightState::colorMode() const\n{\n    return m_colorMode;\n}\n\n/*! Sets the color mode of the light in the scene.\n    \\param colorMode the color mode of the light\n */\nvoid LightState::setColorMode(const QString &colorMode)\n{\n    if (m_colorMode != colorMode)\n    {\n        m_colorMode = colorMode;\n    }\n}\n\n/*! Returns the transitiontime of the scene.\n */\nconst uint16_t &LightState::transitionTime() const\n{\n    return m_transitiontime;\n}\n\n/*! Sets the transitiontime of the scene.\n    \\param transitiontime the transitiontime of the scene\n */\nvoid LightState::setTransitionTime(uint16_t transitiontime)\n{\n    m_transitiontime = transitiontime;\n}\n\n/*! Sets need read flag.\n    \\param needRead - true if attribute should be queried by view scene command\n */\nvoid LightState::setNeedRead(bool needRead)\n{\n    m_needRead = needRead;\n}\n"
        },
        {
          "name": "scene.h",
          "type": "blob",
          "size": 2.931640625,
          "content": "/*\n * Copyright (c) 2016 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef SCENE_H\n#define SCENE_H\n\n#include <stdint.h>\n#include <QString>\n#include <vector>\n#include <QElapsedTimer>\n#include \"json.h\"\n\nclass LightState;\n\n/*! \\class Scene\n\n    Represents a Rest API Scene.\n */\nclass Scene\n{\n\npublic:\n    enum State\n    {\n        StateNormal,\n        StateDeleted\n    };\n\n    Scene();\n    State state;\n    bool externalMaster;\n    uint16_t groupAddress;\n    uint8_t id;\n    QString name;\n\n    const uint16_t &transitiontime() const;\n    void setTransitiontime(const uint16_t &transitiontime);\n\n    std::vector<LightState> &lights();\n    const std::vector<LightState> &lights() const;\n    void setLights(const std::vector<LightState> &lights);\n    void addLightState(const LightState &light);\n    bool deleteLight(const QString &lid);\n    LightState *getLightState(const QString &lid);\n\n    static QString lightsToString(const std::vector<LightState> &lights);\n    static std::vector<LightState> jsonToLights(const QString &json);\n\nprivate:\n    uint16_t m_transitiontime;\n    std::vector<LightState> m_lights;\n};\n\n\n/*! \\class LightState\n\n    Represents the State of a Light of a Scene.\n */\nclass LightState\n{\n\npublic:\n    LightState();\n\n    const QString &lid() const;\n    void setLightId(const QString &lid);\n    bool on() const;\n    void setOn(const bool &on);\n    const uint8_t &bri() const;\n    void setBri(const uint8_t &bri);\n    const uint16_t &x() const;\n    void setX(const uint16_t &x);\n    const uint16_t &y() const;\n    void setY(const uint16_t &y);\n    uint16_t colorTemperature() const;\n    void setColorTemperature(uint16_t colorTemperature);\n    const uint16_t &enhancedHue() const;\n    void setEnhancedHue(const uint16_t &enhancedHue);\n    const uint8_t &saturation() const;\n    void setSaturation(const uint8_t &sat);\n    const bool &colorloopActive() const;\n    void setColorloopActive(const bool &active);\n    const uint8_t &colorloopDirection() const;\n    void setColorloopDirection(const uint8_t &direction);\n    const uint8_t &colorloopTime() const;\n    void setColorloopTime(const uint8_t &time);\n    const QString &colorMode() const;\n    void setColorMode(const QString &colorMode);\n    const uint16_t &transitionTime() const;\n    void setTransitionTime(uint16_t transitionTime);\n    bool needRead() const { return m_needRead; }\n    void setNeedRead(bool needRead);\n\n    QElapsedTimer tVerified;\n\nprivate:\n    QString m_lid;\n    bool m_on;\n    bool m_needRead;\n    uint8_t m_bri;\n    uint16_t m_x;\n    uint16_t m_y;\n    uint16_t m_colorTemperature;\n    uint16_t m_enhancedHue;\n    uint8_t m_saturation;\n    bool m_colorloopActive;\n    uint8_t m_colorloopDirection;\n    uint8_t m_colorloopTime;\n    QString m_colorMode;\n    uint16_t m_transitiontime;\n};\n\n#endif // SCENE_H\n"
        },
        {
          "name": "sensor.cpp",
          "type": "blob",
          "size": 14.2734375,
          "content": "/*\n * Copyright (c) 2013-2024 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"sensor.h\"\n#include \"json.h\"\n#include \"product_match.h\"\n\n/*! Returns a fingerprint as JSON string. */\nQString SensorFingerprint::toString() const\n{\n    if (endpoint == 0xFF || profileId == 0xFFFF)\n    {\n        return QString();\n    }\n\n    QVariantMap map;\n    map[\"ep\"] = (double)endpoint;\n    map[\"p\"] = (double)profileId;\n    map[\"d\"] = (double)deviceId;\n\n    if (!inClusters.empty())\n    {\n        QVariantList ls;\n        for (uint  i = 0; i < inClusters.size(); i++)\n        {\n            ls.append((double)inClusters[i]);\n        }\n        map[\"in\"] = ls;\n    }\n\n    if (!outClusters.empty())\n    {\n        QVariantList ls;\n        for (uint  i = 0; i < outClusters.size(); i++)\n        {\n            ls.append((double)outClusters[i]);\n        }\n        map[\"out\"] = ls;\n    }\n\n    return Json::serialize(map);\n}\n\n/*! Parses a fingerprint from JSON string.\n    \\returns true on success\n*/\nbool SensorFingerprint::readFromJsonString(const QString &json)\n{\n    if (json.isEmpty())\n    {\n        return false;\n    }\n\n    bool ok = false;\n    QVariant var = Json::parse(json, ok);\n\n    if (!ok)\n    {\n        return false;\n    }\n\n    QVariantMap map = var.toMap();\n\n    if (map.contains(\"ep\") && map.contains(\"p\") && map.contains(\"d\"))\n    {\n        endpoint = map[\"ep\"].toString().toUInt(&ok, 0);\n        if (!ok) { return false; }\n        profileId = map[\"p\"].toString().toUInt(&ok, 0);\n        if (!ok) { return false; }\n        deviceId = map[\"d\"].toString().toUInt(&ok, 0);\n        if (!ok) { return false; }\n\n        inClusters.clear();\n        outClusters.clear();\n\n        if (map.contains(\"in\") && map[\"in\"].type() == QVariant::List)\n        {\n            QVariantList ls = map[\"in\"].toList();\n            QVariantList::const_iterator i = ls.constBegin();\n            QVariantList::const_iterator end = ls.constEnd();\n            for (; i != end; ++i)\n            {\n                const quint16 clusterId = i->toString().toUInt(&ok, 0);\n                if (ok)\n                {\n                    inClusters.push_back(clusterId);\n                }\n            }\n        }\n\n        if (map.contains(\"out\") && map[\"out\"].type() == QVariant::List)\n        {\n            QVariantList ls = map[\"out\"].toList();\n            QVariantList::const_iterator i = ls.constBegin();\n            QVariantList::const_iterator end = ls.constEnd();\n            for (; i != end; ++i)\n            {\n                const quint16 clusterId = i->toString().toUInt(&ok, 0);\n                if (ok)\n                {\n                    outClusters.push_back(clusterId);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/*! Returns true if server cluster is part of the finger print.\n */\nbool SensorFingerprint::hasInCluster(quint16 clusterId) const\n{\n    for (size_t i = 0; i < inClusters.size(); i++)\n    {\n        if (inClusters[i] == clusterId)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*! Returns true if server cluster is part of the finger print.\n */\nbool SensorFingerprint::hasOutCluster(quint16 clusterId) const\n{\n    for (size_t i = 0; i < outClusters.size(); i++)\n    {\n        if (outClusters[i] == clusterId)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*! Constructor. */\nSensor::Sensor() :\n    Resource(RSensors),\n    m_deletedstate(Sensor::StateNormal),\n    m_resetRetryCount(0)\n{\n    durationDue = QDateTime();\n\n    // common sensor items\n    addItem(DataTypeString, RAttrName);\n    addItem(DataTypeString, RAttrManufacturerName);\n    addItem(DataTypeUInt32, RAttrMode)->setValue(ModeScenes);\n    addItem(DataTypeString, RAttrModelId);\n    addItem(DataTypeString, RAttrType);\n    addItem(DataTypeString, RAttrSwVersion);\n    addItem(DataTypeString, RAttrId);\n    addItem(DataTypeString, RAttrUniqueId);\n    addItem(DataTypeTime, RAttrLastAnnounced);\n    addItem(DataTypeTime, RAttrLastSeen);\n    addItem(DataTypeBool, RConfigOn);\n    addItem(DataTypeBool, RConfigReachable);\n    addItem(DataTypeTime, RStateLastUpdated);\n\n    previousDirection = 0xFF;\n    previousCt = 0xFFFF;\n    previousSequenceNumber = 0xFF;\n    previousCommandId = 0xFF;    \n}\n\n/*! Returns the sensor deleted state.\n */\nSensor::DeletedState Sensor::deletedState() const\n{\n    return m_deletedstate;\n}\n\n/*! Sets the sensor deleted state.\n    \\param deletedState the sensor deleted state\n */\nvoid Sensor::setDeletedState(DeletedState deletedstate)\n{\n    m_deletedstate = deletedstate;\n}\n\n/*! Returns true if the sensor is reachable.\n */\nbool Sensor::isAvailable() const\n{\n    const ResourceItem *i = item(RConfigReachable);\n    if (i)\n    {\n        return i->toBool();\n    }\n    return true;\n}\n\n/*! Returns the sensor name.\n */\nconst QString &Sensor::name() const\n{\n   return item(RAttrName)->toString();\n}\n\n/*! Sets the sensor name.\n    \\param name the sensor name\n */\nvoid Sensor::setName(const QString &name)\n{\n    item(RAttrName)->setValue(name);\n}\n\n/*! Returns the sensor mode.\n */\nSensor::SensorMode Sensor::mode() const\n{\n   return static_cast<Sensor::SensorMode>(item(RAttrMode)->toNumber());\n}\n\n/*! Sets the sensor mode\n    \\param mode the sensor mode\n */\nvoid Sensor::setMode(SensorMode mode)\n{\n    item(RAttrMode)->setValue(static_cast<qint64>(mode));\n}\n\n/*! Returns the sensor type.\n */\nconst QString &Sensor::type() const\n{\n    return item(RAttrType)->toString();\n}\n\n/*! Sets the sensor type.\n    \\param type the sensor type\n */\nvoid Sensor::setType(const QString &type)\n{\n    item(RAttrType)->setValue(type);\n}\n\n/*! Returns the sensor modelId.\n */\nconst QString &Sensor::modelId() const\n{\n    return item(RAttrModelId)->toString();\n}\n\n/*! Sets the sensor modelId.\n    \\param mid the sensor modelId\n */\nvoid Sensor::setModelId(const QString &mid)\n{\n    item(RAttrModelId)->setValue(mid.trimmed());\n}\n/*! Handles admin when ResourceItem value has been set.\n * \\param i ResourceItem\n */\nvoid Sensor::didSetValue(ResourceItem *i)\n{\n    enqueueEvent(Event(RSensors, i->descriptor().suffix, id(), i));\n    if (i->descriptor().suffix != RAttrLastSeen) // prevent flooding database writes\n    {\n        setNeedSaveDatabase(true);\n    }\n}\n\n/*! Mark received command and update lastseen. */\nvoid Sensor::rx()\n{\n    RestNodeBase *b = static_cast<RestNodeBase *>(this);\n    b->rx();\n    if (lastRx() >= item(RAttrLastSeen)->lastChanged().addSecs(plugin->gwLightLastSeenInterval))\n    {\n        setValue(RAttrLastSeen, lastRx().toUTC());\n    }\n}\n\n/*! Returns the resetRetryCount.\n */\nuint8_t Sensor::resetRetryCount() const\n{\n    return m_resetRetryCount;\n}\n\n/*! Sets the resetRetryCount.\n    \\param resetRetryCount the resetRetryCount\n */\nvoid Sensor::setResetRetryCount(uint8_t resetRetryCount)\n{\n    m_resetRetryCount = resetRetryCount;\n}\n\n/*! Returns the zdpResetSeq number.\n */\nuint8_t Sensor::zdpResetSeq() const\n{\n    return m_zdpResetSeq;\n}\n\n/*! Sets the zdpResetSeq number.\n    \\param resetRetryCount the resetRetryCount\n */\nvoid Sensor::setZdpResetSeq(uint8_t zdpResetSeq)\n{\n    m_zdpResetSeq = zdpResetSeq;\n}\n\nvoid Sensor::updateStateTimestamp()\n{\n    ResourceItem *i = item(RStateLastUpdated);\n    if (i)\n    {\n        i->setValue(QDateTime::currentDateTimeUtc());\n    }\n}\n\n/*! Returns the sensor manufacturer.\n */\nconst QString &Sensor::manufacturer() const\n{\n    return item(RAttrManufacturerName)->toString();\n}\n\n/*! Sets the sensor manufacturer.\n    \\param manufacturer the sensor manufacturer\n */\nvoid Sensor::setManufacturer(const QString &manufacturer)\n{\n    item(RAttrManufacturerName)->setValue(manufacturer.trimmed());\n}\n\n/*! Returns the sensor software version.\n    Not supported for ZGP Sensortype\n */\nconst QString &Sensor::swVersion() const\n{\n    return item(RAttrSwVersion)->toString();\n}\n\n/*! Sets the sensor software version.\n    \\param swVersion the sensor software version\n */\nvoid Sensor::setSwVersion(const QString &swversion)\n{\n    item(RAttrSwVersion)->setValue(swversion.trimmed());\n}\n\n/*! Returns the sensor last seen timestamp.\n */\nconst QString &Sensor::lastSeen() const\n{\n    static const QString s = QString(\"\");\n\n    const ResourceItem *i = item(RAttrLastSeen);\n    return i ? i->toString() : s;\n}\n\n/*! Sets the sensor last seen timestamp.\n    \\param lastseen the sensor last seen timestamp\n */\nvoid Sensor::setLastSeen(const QString &lastseen)\n{\n    ResourceItem *i = item(RAttrLastSeen);\n    if (i)\n    {\n        QDateTime ls = QDateTime::fromString(lastseen, QLatin1String(\"yyyy-MM-ddTHH:mmZ\"));\n        ls.setTimeSpec(Qt::UTC);\n        i->setValue(ls);\n    }\n}\n\n/*! Returns the sensor last announced timestamp.\n */\nconst QString &Sensor::lastAnnounced() const\n{\n    static const QString s = QString(\"\");\n\n    const ResourceItem *i = item(RAttrLastAnnounced);\n    return i ? i->toString() : s;\n}\n\n/*! Sets the sensor last announced timestamp.\n    \\param lastannounced the sensor last announced timestamp\n */\nvoid Sensor::setLastAnnounced(const QString &lastannounced)\n{\n    ResourceItem *i = item(RAttrLastAnnounced);\n    if (i)\n    {\n        QDateTime la = QDateTime::fromString(lastannounced, QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\"));\n        la.setTimeSpec(Qt::UTC);\n        i->setValue(la);\n    }\n}\n\n/*! Transfers state into JSONString.\n */\nQString Sensor::stateToString()\n{\n    QVariantMap map;\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const ResourceItemDescriptor &rid = item->descriptor();\n\n        if (strncmp(rid.suffix, \"state/\", 6) == 0)\n        {\n            const char *key = item->descriptor().suffix + 6;\n            map[key] = item->toVariant();\n        }\n    }\n\n    return Json::serialize(map);\n}\n\n/*! Transfers config into JSONString.\n */\nQString Sensor::configToString()\n{\n    QVariantMap map;\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const ResourceItemDescriptor &rid = item->descriptor();\n\n        if (strncmp(rid.suffix, \"config/\", 7) == 0)\n        {\n            const char *key = item->descriptor().suffix + 7;\n            map[key] = item->toVariant();\n        }\n    }\n\n    return Json::serialize(map);\n}\n\n/*! Parse the sensor state from a JSON string. */\nvoid Sensor::jsonToState(const QString &json)\n{\n    bool ok;\n    QVariant var = Json::parse(json, ok);\n\n    if (!ok)\n    {\n        return;\n    }\n\n    QVariantMap map = var.toMap();\n\n    if (map.contains(\"lastset\"))\n    {\n        QString lastset = map[\"lastset\"].toString();\n        QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\");\n        QDateTime ls = QDateTime::fromString(lastset, format);\n        ls.setTimeSpec(Qt::UTC);\n        map[\"lastset\"] = ls;\n    }\n\n    // use old time stamp before deCONZ was started\n    QDateTime dt = QDateTime::currentDateTime().addSecs(-120);\n    if (map.contains(\"lastupdated\"))\n    {\n        QString lastupdated = map[\"lastupdated\"].toString();\n        QString format = lastupdated.length() == 19 ? QLatin1String(\"yyyy-MM-ddTHH:mm:ss\") : QLatin1String(\"yyyy-MM-ddTHH:mm:ss.zzz\");\n        QDateTime lu = QDateTime::fromString(lastupdated, format);\n        if (lu < dt)\n        {\n            dt = lu;\n        }\n        lu.setTimeSpec(Qt::UTC);\n        map[\"lastupdated\"] = lu;\n    }\n\n    if (map.contains(\"localtime\"))\n    {\n        QString localtime = map[\"localtime\"].toString();\n        QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ss\");\n        QDateTime lt = QDateTime::fromString(localtime, format);\n        map[\"localtime\"] = lt;\n    }\n\n    if (map.contains(\"utc\"))\n    {\n        QString utc = map[\"utc\"].toString();\n        QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\");\n        QDateTime u = QDateTime::fromString(utc, format);\n        u.setTimeSpec(Qt::UTC);\n        map[\"utc\"] = u;\n    }\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const ResourceItemDescriptor &rid = item->descriptor();\n\n        if (strncmp(rid.suffix, \"state/\", 6) == 0)\n        {\n            const char *key = item->descriptor().suffix + 6;\n\n            if (map.contains(QLatin1String(key)))\n            {\n                item->setValue(map[key]);\n                item->setTimeStamps(dt);\n            }\n        }\n    }\n}\n\n/*! Parse the sensor config from a JSON string. */\nvoid Sensor::jsonToConfig(const QString &json)\n{\n    bool ok;\n\n    QVariant var = Json::parse(json, ok);\n\n    if (!ok)\n    {\n        return;\n    }\n    QVariantMap map = var.toMap();\n\n    if (map.contains(\"lastchange_time\"))\n    {\n        QString lastchange_time = map[\"lastchange_time\"].toString();\n        QString format = QLatin1String(\"yyyy-MM-ddTHH:mm:ssZ\");\n        QDateTime lct = QDateTime::fromString(lastchange_time, format);\n        lct.setTimeSpec(Qt::UTC);\n        map[\"lastchange_time\"] = lct;\n    }\n\n    if (map.contains(\"battery\") && type().startsWith(QLatin1String(\"CLIP\")))\n    {\n        addItem(DataTypeUInt8, RConfigBattery);\n    }\n\n    QDateTime dt = QDateTime::currentDateTime().addSecs(-120);\n\n    for (int i = 0; i < itemCount(); i++)\n    {\n        ResourceItem *item = itemForIndex(i);\n        const ResourceItemDescriptor &rid = item->descriptor();\n\n        if (type().startsWith(QLatin1String(\"CLIP\")))\n        {}\n        else if (item->descriptor().suffix == RConfigReachable)\n        { // set only from live data\n            item->setValue(false);\n            continue;\n        }\n\n        if (strncmp(rid.suffix, \"config/\", 7) == 0 && rid.suffix != RConfigPending)\n        {\n            const char *key = item->descriptor().suffix + 7;\n\n            if (map.contains(QLatin1String(key)))\n            {\n                QVariant val = map[key];\n\n                if (val.isNull())\n                {\n                    if (rid.suffix == RConfigOn)\n                    {\n                        map[key] = true; // default value\n                        setNeedSaveDatabase(true);\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n\n                item->setValue(map[key]);\n                item->setTimeStamps(dt);\n            }\n        }\n    }\n}\n\n/*! Returns the sensor fingerprint. */\nSensorFingerprint &Sensor::fingerPrint()\n{\n    return m_fingerPrint;\n}\n\n/*! Returns the sensor fingerprint. */\nconst SensorFingerprint &Sensor::fingerPrint() const\n{\n    return m_fingerPrint;\n}\n"
        },
        {
          "name": "sensor.h",
          "type": "blob",
          "size": 4.65234375,
          "content": "/*\n * Copyright (c) 2017-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef SENSOR_H\n#define SENSOR_H\n\n#include <QString>\n#include \"button_maps.h\"\n#include \"resource.h\"\n#include \"rest_node_base.h\"\n\n// Sensor State\n#define INVALID_ENDPOINT 0xff\n#define SENSOR_CHECK_COUNTER_INIT 10\n#define S_BUTTON_ACTION_INITIAL_PRESS   0\n#define S_BUTTON_ACTION_HOLD            1\n#define S_BUTTON_ACTION_SHORT_RELEASED  2\n#define S_BUTTON_ACTION_LONG_RELEASED   3\n#define S_BUTTON_ACTION_DOUBLE_PRESS    4\n#define S_BUTTON_ACTION_TREBLE_PRESS    5\n#define S_BUTTON_ACTION_QUADRUPLE_PRESS 6\n#define S_BUTTON_ACTION_SHAKE           7\n#define S_BUTTON_ACTION_DROP            8\n#define S_BUTTON_ACTION_TILT            9\n#define S_BUTTON_ACTION_MANY_PRESS      10\n\n#define GESTURE_NONE                     0\n#define GESTURE_SHAKE                    1\n#define GESTURE_DROP                     2\n#define GESTURE_FLIP_90                  3\n#define GESTURE_FLIP_180                 4\n#define GESTURE_PUSH                     5\n#define GESTURE_DOUBLE_TAP               6\n#define GESTURE_ROTATE_CLOCKWISE         7\n#define GESTURE_ROTATE_COUNTER_CLOCKWISE 8\n\n#define S_BUTTON_1   1000\n#define S_BUTTON_2   2000\n#define S_BUTTON_3   3000\n#define S_BUTTON_4   4000\n#define S_BUTTON_5   5000\n#define S_BUTTON_6   6000\n#define S_BUTTON_7   7000\n#define S_BUTTON_8   8000\n#define S_BUTTON_9   9000\n#define S_BUTTON_10  10000\n#define S_BUTTON_11  11000\n#define S_BUTTON_12  12000\n\nstruct SensorFingerprint\n{\n    SensorFingerprint() : checkCounter(0), endpoint(INVALID_ENDPOINT), profileId(0xffff), deviceId(0xffff) {}\n    bool operator==(const SensorFingerprint &rhs) const\n    {\n        return (endpoint == rhs.endpoint &&\n                profileId == rhs.profileId &&\n                deviceId == rhs.deviceId &&\n                inClusters == rhs.inClusters &&\n                outClusters == rhs.outClusters);\n    }\n    QString toString() const;\n    bool readFromJsonString(const QString &json);\n    bool hasEndpoint() const { return endpoint != 0xFF; }\n    bool hasInCluster(quint16 clusterId) const;\n    bool hasOutCluster(quint16 clusterId) const;\n    int checkCounter;\n    quint8 endpoint;\n    quint16 profileId;\n    quint16 deviceId;\n    std::vector<quint16> inClusters;\n    std::vector<quint16> outClusters;\n};\n\ninline bool isValid(const SensorFingerprint &fp)\n{\n    return fp.endpoint != INVALID_ENDPOINT;\n}\n\n/*! \\class Sensor\n\n    Represents a HA based Sensor.\n */\nclass Sensor : public Resource,\n               public RestNodeBase\n{\npublic:\n    enum SensorMode\n    {\n        ModeNone = 0,\n        ModeScenes = 1,\n        ModeTwoGroups = 2,\n        ModeColorTemperature = 3,\n        ModeDimmer = 4\n    };\n\n    enum DeletedState\n    {\n        StateNormal,\n        StateDeleted\n    };\n\n    Sensor();\n\n    DeletedState deletedState() const;\n    void setDeletedState(DeletedState deletedstate);\n    bool isAvailable() const override;\n    const QString &name() const;\n    void setName(const QString &name);\n    const QString &type() const;\n    void setType(const QString &type);\n    const QString &modelId() const;\n    void setModelId(const QString &mid);\n    const QString &manufacturer() const;\n    void setManufacturer(const QString &manufacturer);\n    const QString &swVersion() const;\n    void setSwVersion(const QString &swversion);\n    SensorMode mode() const;\n    void setMode(SensorMode mode);\n    const QString &lastSeen() const;\n    void setLastSeen(const QString &ls);\n    const QString &lastAnnounced() const;\n    void setLastAnnounced(const QString &la);\n    void didSetValue(ResourceItem *i) override;\n    void rx();\n    uint8_t resetRetryCount() const;\n    void setResetRetryCount(uint8_t resetRetryCount);\n    uint8_t zdpResetSeq() const;\n    void setZdpResetSeq(uint8_t zdpResetSeq);\n    void updateStateTimestamp();\n\n    QString stateToString();\n    QString configToString();\n\n    void jsonToState(const QString &json);\n    void jsonToConfig(const QString &json);\n    SensorFingerprint &fingerPrint();\n    const SensorFingerprint &fingerPrint() const;\n    ButtonMapRef buttonMapRef() const { return m_buttonMapRef; }\n    void setButtonMapRef(ButtonMapRef ref) { m_buttonMapRef = ref; }\n\n    QString etag;\n    uint8_t previousDirection;\n    quint16 previousCt;\n    QDateTime durationDue;\n    uint16_t previousSequenceNumber = 0xffff;\n    uint8_t previousCommandId;\n\nprivate:\n    DeletedState m_deletedstate;\n    SensorFingerprint m_fingerPrint;\n    uint8_t m_resetRetryCount;\n    uint8_t m_zdpResetSeq;\n    ButtonMapRef m_buttonMapRef{};\n};\n\n#endif // SENSOR_H\n"
        },
        {
          "name": "simple_metering.cpp",
          "type": "blob",
          "size": 11.482421875,
          "content": "#include <math.h>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"device_descriptions.h\"\n#include \"simple_metering.h\"\n\nconst std::array<KeyValMapInt, 5> RConfigInterfaceModeValuesEMIZB = { { {1, NORWEGIAN_HAN}, {2, NORWEGIAN_HAN_EXTRA_LOAD}, {3, AIDON_METER},\n                                                                               {4, KAIFA_KAMSTRUP_METERS}, {5, AUTO_DETECT} } };\n\n/*! Handle packets related to the ZCL simple metering cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the simple metering cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleSimpleMeteringClusterIndication(const deCONZ::ApsDataIndication &ind, const deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n    \n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAConsumption\"));\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No consumption sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const auto modelId = sensor->modelId();\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            ResourceItem *item = nullptr;\n\n            switch (attrId)\n            {\n            case METERING_ATTRID_CURRENT_SUMMATION_DELIVERED:\n            {\n                quint64 consumption = attr.numericValue().u64;\n                item = sensor->item(RStateConsumption);\n\n                if (modelId == QLatin1String(\"SmartPlug\") ||                      // Heiman\n                    modelId.startsWith(QLatin1String(\"PSMP5_\")) ||                // Climax\n                    modelId.startsWith(QLatin1String(\"SKHMP30\")) ||               // GS smart plug\n                    modelId.startsWith(QLatin1String(\"E13-\")) ||                  // Sengled PAR38 Bulbs\n                    modelId.startsWith(QLatin1String(\"Z01-A19\")))                 // Sengled smart led\n                {\n                    consumption = static_cast<quint64>(round((double)consumption / 10.0)); // 0.1 Wh -> Wh\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Math.round(Attr.val / 10)\");\n                }\n                else if (modelId == QLatin1String(\"Smart plug Zigbee PE\") ||      // Niko Smart Plug 552-80699\n                         modelId == QLatin1String(\"TS011F\") ||                    // Tuya / Blitzwolf \n                         modelId == QLatin1String(\"TS0121\"))                      // Tuya / Blitzwolf\n                {\n                    consumption *= 10; // 0.01 kWh = 10 Wh -> Wh\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Attr.val * 10\");\n                }\n                else if (modelId.startsWith(QLatin1String(\"SZ-ESW01\"))) // Sercomm / Telstra smart plug\n                {\n                    consumption = static_cast<quint64>(round((double)consumption / 1000.0)); // -> Wh\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Math.round(Attr.val / 1000)\");\n                }\n                else if (modelId.startsWith(QLatin1String(\"ROB_200\")) ||            // ROBB Smarrt micro dimmer\n                         modelId.startsWith(QLatin1String(\"Micro Smart Dimmer\")) || // Sunricher Micro Smart Dimmer\n                         modelId.startsWith(QLatin1String(\"SPW35Z\")))               // RT-RK OBLO SPW35ZD0 smart plug\n                {\n                    consumption = static_cast<quint64>(round((double)consumption / 3600.0)); // -> Wh\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Math.round(Attr.val / 3600)\");\n                }\n                else\n                {\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Attr.val\");\n                }\n\n                if (item && item->toNumber() != static_cast<qint64>(consumption))\n                {\n                    item->setValue(consumption); // in Wh (0.001 kWh)\n                    enqueueEvent(Event(RSensors, RStateConsumption, sensor->id(), item));\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), METERING_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            case METERING_ATTRID_INTERFACE_MODE:\n            {\n                if (zclFrame.manufacturerCode() == VENDOR_DEVELCO)\n                {\n                    const quint16 interfaceMode = attr.numericValue().u16;\n                    item = sensor->item(RConfigInterfaceMode);\n                    quint8 mode = 0;\n                    \n                    if (modelId.startsWith(QLatin1String(\"EMIZB-1\")))\n                    {\n                        if      (interfaceMode == NORWEGIAN_HAN)            { mode = 1; }\n                        else if (interfaceMode == NORWEGIAN_HAN_EXTRA_LOAD) { mode = 2; }\n                        else if (interfaceMode == AIDON_METER)              { mode = 3; }\n                        else if (interfaceMode == KAIFA_KAMSTRUP_METERS)    { mode = 4; }\n                        else if (interfaceMode == AUTO_DETECT)              { mode = 5; }                        \n                    }\n\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"console.log('todo script')\");\n                    \n                    if (item && mode != 0 && item->toNumber() != mode)\n                    {\n                        item->setValue(mode);\n                        enqueueEvent(Event(RSensors, RConfigInterfaceMode, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), METERING_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case METERING_ATTRID_INSTANTANEOUS_DEMAND:\n            {\n                qint32 power = attr.numericValue().s32;\n                item = sensor->item(RStatePower);\n\n                if (modelId == QLatin1String(\"SmartPlug\") ||                  // Heiman\n                    modelId == QLatin1String(\"902010/25\") ||                  // Bitron\n                    modelId.startsWith(QLatin1String(\"Z01-A19\")) ||           // Sengled smart led\n                    modelId.startsWith(QLatin1String(\"PSMP5_\")) ||            // Climax\n                    modelId.startsWith(QLatin1String(\"SKHMP30\")) ||           // GS smart plug\n                    modelId.startsWith(QLatin1String(\"160-01\")))              // Plugwise smart plug\n                {\n                    power = static_cast<qint32>(round((double)power / 10.0)); // 0.1W -> W\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Math.round(Attr.val / 10)\");\n                }\n                else if (modelId.startsWith(QLatin1String(\"SZ-ESW01\")))       // Sercomm / Telstra smart plug\n                {\n                    power = static_cast<qint32>(round((double)power / 1000.0)); // -> W\n                    DDF_AnnoteZclParse(sensor, item, ind.srcEndpoint(), ind.clusterId(), attrId, \"Item.val = Math.round(Attr.val / 1000)\");\n                }\n\n                if (item && item->toNumber() != power)\n                {\n                    item->setValue(power); // in W\n                    enqueueEvent(Event(RSensors, RStatePower, sensor->id(), item));\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), METERING_CLUSTER_ID, attrId, attr.numericValue());\n                stateUpdated = true;\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n}\n\n/*! Write Attribute on thermostat cluster.\n *  Iterate over every day and get schedule for each day.\n   \\param task - the task item\n   \\param attrId\n   \\param attrType\n   \\param attrValue\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskSimpleMeteringReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode)\n{\n    if (readOrWriteCmd != deCONZ::ZclReadAttributesId && readOrWriteCmd != deCONZ::ZclWriteAttributesId)\n    {\n        DBG_Printf(DBG_INFO, \"Invalid command for simple metering cluster %d\\n\", readOrWriteCmd);\n        return false;\n    }\n\n    task.taskType = TaskSimpleMetering;\n\n    task.req.setClusterId(METERING_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(readOrWriteCmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n            deCONZ::ZclFCDirectionClientToServer |\n            deCONZ::ZclFCDisableDefaultResponse);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (readOrWriteCmd == deCONZ::ZclWriteAttributesId)\n    {\n        stream << attrId;\n        stream << attrType;\n        \n        deCONZ::ZclAttribute attr(attrId, attrType, QLatin1String(\"\"), deCONZ::ZclWrite, true);\n        attr.setValue(QVariant(attrValue));\n\n        if (!attr.writeToStream(stream))\n        {\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "simple_metering.h",
          "type": "blob",
          "size": 0.8076171875,
          "content": "#ifndef SIMPLE_METERING_H\n#define SIMPLE_METERING_H\n\n#include \"utils/utils.h\"\n\n//Attribute IDs\n#define METERING_ATTRID_CURRENT_SUMMATION_DELIVERED             0x0000\n#define METERING_ATTRID_PULSE_CONFIGURATION                     0x0300  // Develco specific\n#define METERING_ATTRID_INTERFACE_MODE                          0x0302  // Develco specific\n#define METERING_ATTRID_INSTANTANEOUS_DEMAND                    0x0400\n\n// Values for attribute Interface Mode (0x0302), Develco specific\n#define NORWEGIAN_HAN                   0x0200\n#define NORWEGIAN_HAN_EXTRA_LOAD        0x0201\n#define AIDON_METER                     0x0202\n#define KAIFA_KAMSTRUP_METERS           0x0203\n#define AUTO_DETECT                     0x0204\n\nextern const std::array<KeyValMapInt, 5> RConfigInterfaceModeValuesEMIZB;\n\n#endif // SIMPLE_METERING_H\n"
        },
        {
          "name": "sqlite3",
          "type": "tree",
          "content": null
        },
        {
          "name": "state_change.cpp",
          "type": "blob",
          "size": 9.7099609375,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include \"device_descriptions.h\"\n#include \"resource.h\"\n#include \"state_change.h\"\n\n#define ONOFF_CLUSTER_ID      0x0006\n#define ONOFF_COMMAND_OFF     0x00\n#define ONOFF_COMMAND_ON      0x01\n#define ONOFF_COMMAND_OFF_WITH_EFFECT  0x040\n\nquint8 zclNextSequenceNumber(); // todo defined in de_web_plugin_private.h\n\nStateChange::StateChange(StateChange::State initialState, StateChangeFunction_t fn, quint8 dstEndpoint) :\n    m_state(initialState),\n    m_changeFunction(fn),\n    m_dstEndpoint(dstEndpoint)\n{\n    Q_ASSERT(initialState == StateCallFunction || initialState == StateWaitSync);\n    Q_ASSERT(fn);\n\n    m_stateTimer.start();\n    m_changeTimer.start();\n}\n\n/*! Tick function for the inner state machine.\n\n    Is called from the Device state machine on certain events.\n    \\returns 0 when nothing was sent, 1 if an APS request was enqueued\n*/\nint StateChange::tick(uint64_t extAddr, Resource *r, deCONZ::ApsController *apsCtrl)\n{\n    int result = 0;\n\n    if (m_state == StateFinished || m_state == StateFailed)\n    {\n        return result;\n    }\n\n    Q_ASSERT(m_stateTimer.isValid());\n    Q_ASSERT(m_changeTimer.isValid());\n\n    const char *uniqueId = \"\";\n\n    {\n        const ResourceItem *item = r->item(RAttrUniqueId);\n        if (item)\n        {\n            uniqueId = item->toCString();\n        }\n    }\n\n    if (m_state == StateWaitSync)\n    {\n        if (m_stateTimer.elapsed() > m_stateTimeoutMs)\n        {\n            m_state = StateCallFunction;\n\n            for (auto &i : m_items)\n            {\n                if (i.verified == VerifyUnknown) // didn't receive a ZCL attribute read or report command\n                {\n                    m_state = StateRead;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (m_state == StateFailed)\n    {\n\n    }\n    else if (m_changeTimeoutMs > 0 && m_changeTimer.elapsed() > m_changeTimeoutMs)\n    {\n        m_state = StateFailed;\n    }\n    else if (DA_ApsUnconfirmedRequests() > 5)\n    {\n        // wait\n    }\n    else if (m_state == StateCallFunction && m_changeFunction)\n    {\n        DBG_Printf(DBG_INFO, \"SC tick --> StateCallFunction\\n\");\n        if (m_changeFunction(r, this, apsCtrl) == 0)\n        {\n            for (auto &i : m_items)\n            {\n                if (i.verified == VerifyNotSynced)\n                {\n                    i.verified = VerifyUnknown; // read again\n                }\n            }\n            m_stateTimer.start();\n            m_state = StateWaitSync;\n            result = 1;\n        }\n    }\n    else if (m_state == StateRead && DA_ApsUnconfirmedRequestsForExtAddress(extAddr) == 0)\n    {\n        ResourceItem *item = nullptr;\n        for (auto &i : m_items)\n        {\n            if (i.verified == VerifyUnknown)\n            {\n                item = r->item(i.suffix);\n                break;\n            }\n        }\n\n        m_state = StateFailed;\n        m_readResult = {};\n        if (item)\n        {\n            const auto &ddfItem = DDF_GetItem(item);\n            const auto readFunction = DA_GetReadFunction(ddfItem.readParameters);\n            if (readFunction && ddfItem.isValid())\n            {\n                m_readResult = readFunction(r, item, apsCtrl, ddfItem.readParameters);\n\n                if (m_readResult.isEnqueued)\n                {\n                    DBG_Printf(DBG_INFO, \"SC tick --> StateRead %s, %s\\n\", item->descriptor().suffix, uniqueId);\n                    result = 1;\n                }\n\n                m_stateTimer.start();\n                m_state = StateWaitSync;\n            }\n        }\n    }\n\n    return result;\n}\n\n/*! Should be called when the item was set by a ZCL read or report attribute command.\n\n    When all items are verified the StateChange::state() is set to StateFinished.\n */\nvoid StateChange::verifyItemChange(const ResourceItem *item)\n{\n    Q_ASSERT(item);\n\n    size_t syncedItems = 0;\n\n    if (item->valueSource() != ResourceItem::SourceDevice)\n    {\n        return;\n    }\n\n    for (auto &i : m_items)\n    {\n        if (i.suffix == item->descriptor().suffix)\n        {\n            if (i.targetValue == item->toVariant())\n            {\n                i.verified = VerifySynced;\n                DBG_Printf(DBG_INFO, \"SC %s: synced\\n\", i.suffix);\n            }\n            else\n            {\n                i.verified = VerifyNotSynced;\n                DBG_Printf(DBG_INFO, \"SC %s: not synced\\n\", i.suffix);\n            }\n        }\n\n        if (i.verified == VerifySynced)\n        {\n            syncedItems++;\n        }\n    }\n\n    if (syncedItems == m_items.size() && m_state != StateFinished)\n    {\n        m_state = StateFinished;\n        DBG_Printf(DBG_INFO, \"SC --> StateFinished\\n\");\n    }\n}\n\n/*! Adds a target value. */\nvoid StateChange::addTargetValue(const char *suffix, const QVariant &value)\n{\n    if (value.isValid())\n    {\n        m_items.push_back({suffix, value});\n    }\n    else\n    {\n        DBG_Printf(DBG_ERROR, \"SC add invalid traget value for: %s\\n\", suffix);\n    }\n}\n\n/*! Adds a parameter. If the parameter already exsits it will be replaced. */\nvoid StateChange::addParameter(const QString &name, const QVariant &value)\n{\n    auto i = std::find_if(m_parameters.begin(), m_parameters.end(), [name](const Param &x){\n        return x.name == name;\n    });\n\n    if (i != m_parameters.end())\n    {\n        i->value = value;\n    }\n    else\n    {\n        m_parameters.push_back({name, value});\n    }\n}\n\nbool StateChange::operator==(const StateChange &other) const\n{\n     if (m_changeFunction == other.m_changeFunction && m_items.size() == other.m_items.size())\n     {\n         for (size_t i = 0; i < m_items.size(); i++)\n         {\n             if (m_items[i].suffix != other.m_items[i].suffix)\n             {\n                 return false;\n             }\n         }\n         return true;\n     }\n     return false;\n}\n\n/*! Calls the ZCL write function of item(s) to write target value(s).\n\n    \\returns 0 - if the command has been enqueued, or a negative number on failure.\n */\nint SC_WriteZclAttribute(const Resource *r, const StateChange *stateChange, deCONZ::ApsController *apsCtrl)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(stateChange);\n    Q_ASSERT(apsCtrl);\n\n    int written = 0;\n\n    for (const auto &i : stateChange->items())\n    {\n        const auto *item = r->item(i.suffix);\n\n        if (!item)\n        {\n            return -1;\n        }\n\n        const auto ddfItem = DDF_GetItem(item);\n\n        if (ddfItem.writeParameters.isNull())\n        {\n            return -2;\n        }\n\n        const auto fn = DA_GetWriteFunction(ddfItem.writeParameters);\n\n        if (!fn)\n        {\n            return -3;\n        }\n\n        // create a copy since item is const\n        ResourceItem copy(item->descriptor());\n        copy.setValue(i.targetValue);\n\n        if (!fn(r, &copy, apsCtrl, ddfItem.writeParameters))\n        {\n            return -4;\n        }\n\n        written++;\n    }\n\n    return written > 0 ? 0 : -5;\n}\n\n/*! Sends a ZCL command to the on/off cluster.\n\n    StateChange::parameters() -> \"cmd\"\n\n        ONOFF_COMMAND_ON\n        ONOFF_COMMAND_OFF\n        ONOFF_COMMAND_OFF_WITH_EFFECT\n\n    \\returns 0 - if the command has been enqueued, or a negative number on failure.\n */\nint SC_SetOnOff(const Resource *r, const StateChange *stateChange, deCONZ::ApsController *apsCtrl)\n{\n    Q_ASSERT(r);\n    Q_ASSERT(stateChange);\n    Q_ASSERT(apsCtrl);\n\n    quint8 cmd = 0xff;\n\n    if (r->parentResource())\n    {\n        r = r->parentResource(); // Device* has nwk/ext address\n    }\n\n    for (const auto &i : stateChange->parameters())\n    {\n        if (i.name == QLatin1String(\"cmd\"))\n        {\n            bool ok;\n            auto val =  i.value.toUInt(&ok);\n\n            if (ok && (val == ONOFF_COMMAND_ON || val == ONOFF_COMMAND_OFF || val == ONOFF_COMMAND_OFF_WITH_EFFECT))\n            {\n                cmd = static_cast<quint8>(val);\n            }\n            break;\n        }\n    }\n\n    if (cmd == 0xff)\n    {\n        return -1;\n    }\n\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame zclFrame;\n\n    req.setClusterId(ONOFF_CLUSTER_ID);\n    req.setProfileId(HA_PROFILE_ID);\n    req.dstAddress().setNwk(r->item(RAttrNwkAddress)->toNumber());\n    req.dstAddress().setExt(r->item(RAttrExtAddress)->toNumber());\n    req.setDstAddressMode(deCONZ::ApsNwkAddress);\n    req.setDstEndpoint(stateChange->dstEndpoint());\n    req.setSrcEndpoint(0x01);\n\n    zclFrame.payload().clear();\n    zclFrame.setSequenceNumber(zclNextSequenceNumber());\n    zclFrame.setCommandId(cmd);\n    zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n\n    if (cmd == ONOFF_COMMAND_OFF_WITH_EFFECT)\n    {\n        const quint8 effect = 0;\n        const quint8 variant = 0;\n        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        stream << effect;\n        stream << variant;\n    }\n//    else if (cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF)\n//    {\n//        const quint16 offWaitTime = 0;\n//        QDataStream stream(&zclFrame.payload(), QIODevice::WriteOnly);\n//        stream.setByteOrder(QDataStream::LittleEndian);\n//        // stream << (quint8)0x80; // 0x01 accept only when on --> no, 0x80 overwrite ontime (yes, non standard)\n//        stream << flags;\n//        stream << ontime;\n//        stream << offWaitTime;\n//    }\n\n    QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n    zclFrame.writeToStream(stream);\n\n    DBG_Printf(DBG_INFO, \"SC_SetOnOff()\\n\");\n\n    return apsCtrl->apsdeDataRequest(req) == deCONZ::Success ? 0 : -2;\n}\n"
        },
        {
          "name": "state_change.h",
          "type": "blob",
          "size": 4.982421875,
          "content": "/*\n * Copyright (c) 2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef STATE_CHANGE_H\n#define STATE_CHANGE_H\n\n#include <QVariant>\n#include <QElapsedTimer>\n#include \"device_access_fn.h\"\n\nclass Resource;\nclass ResourceItem;\nclass StateChange;\n\nnamespace deCONZ {\n    class ApsController;\n}\n\nint SC_WriteZclAttribute(const Resource *r, const StateChange *stateChange, deCONZ::ApsController *apsCtrl);\nint SC_SetOnOff(const Resource *r, const StateChange *stateChange, deCONZ::ApsController *apsCtrl);\n\n/*! \\fn StateChangeFunction_t\n\n    A state change function sends a certain ZCL command to a device to set a target state.\n    For example: Sending On/off command to the on/off cluster.\n\n    \\returns 0 if the command was sent, or a negative number on failure.\n */\ntypedef int (*StateChangeFunction_t)(const Resource *r, const StateChange *stateChange, deCONZ::ApsController *apsCtrl);\n\n/*! \\class StateChange\n\n    A generic helper to robustly set and verify state changes using ResourceItems.\n\n    The main purpose of this helper is to ensure that a state will be set: For example\n    a group cast to turn on 20 lights might not turn on all lights, in this case the\n    StateChange detects that a light has not been turned on and can retry the respective command.\n\n    A StateChange may have an arbitrary long \"change-timeout\" to support changing configurations\n    for sleeping or not yet powered devices.\n\n    StateChange is bound to a Resource and can be added by Resource::addStateChange(). Multiple\n    StateChange items may be added if needed, for example to set on, brightness and color or to verify that a\n    scene is called correctly, even if the scene cluster doesn't have the correct values stored in\n    the device NVRAM.\n */\nclass StateChange\n{\npublic:\n    enum State\n    {\n        StateCallFunction, //! Calls the change function.\n        StateWaitSync,     //! Waits until state is verified or a state-timeout occurs.\n        StateRead,         //! When StateWaitSync timedout without receiving a value from the device.\n        StateFinished,     //! The target state has been verified.\n        StateFailed        //! The state changed failed after change-timeout.\n    };\n\n    enum SyncResult\n    {\n        VerifyUnknown,\n        VerifySynced,\n        VerifyNotSynced\n    };\n\n    /*! \\struct StateChange::Item\n\n        Specifies the target value of a specific item.\n        There can be multiple Items involved in one state change.\n     */\n    struct Item\n    {\n        Item(const char *s, const QVariant &v) : suffix(s), targetValue(v) { }\n        const char *suffix = nullptr; //! RStateOn, RStateBri, ...\n        QVariant targetValue; //! The target value.\n        SyncResult verified = VerifyUnknown;\n    };\n\n    /*! \\struct StateChange::Param\n\n        Specifies an extra parameter which might be needed to carry out a command.\n        A Param usually isn't available as a ResourceItem, e.g. the transitiontime for a brightness change.\n     */\n    struct Param\n    {\n        QString name;\n        QVariant value;\n    };\n\n    /*! Constructs a new StateChange.\n        \\param initialState - StateCallFunction or StateWaitSync.\n        \\param fn - the state change function.\n        \\param dstEndpoint - the endpoint to which the command should be send.\n\n        StateCallFunction will call the state function in the next tick().\n        StateWaitSync should be used when a command has already been sent, the state function will only\n        be called when the state change can't be verified after state-timeout.\n     */\n    explicit StateChange(State initialState, StateChangeFunction_t fn, quint8 dstEndpoint);\n    State state() const { return m_state; }\n    int tick(uint64_t extAddr, Resource *r, deCONZ::ApsController *apsCtrl);\n    void verifyItemChange(const ResourceItem *item);\n    void addTargetValue(const char *suffix, const QVariant &value);\n    void addParameter(const QString &name, const QVariant &value);\n    bool operator==(const StateChange &other) const;\n    const std::vector<Item> &items() const { return m_items; }\n    const std::vector<Param> &parameters() const { return m_parameters; }\n    quint8 dstEndpoint() const { return m_dstEndpoint; }\n    void setChangeTimeoutMs(int timeout) { m_changeTimeoutMs = timeout; }\n    void setStateTimeoutMs(int timeout) { m_stateTimeoutMs = timeout; }\n\nprivate:\n    State m_state = StateCallFunction;\n    StateChangeFunction_t m_changeFunction = nullptr; //! The function to send a respective ZCL command.\n\n    DA_ReadResult m_readResult;\n    quint8 m_dstEndpoint;\n    int m_stateTimeoutMs = 1000 * 5; //! Inner timeout for states.\n    int m_changeTimeoutMs = 1000 * 180; //! Max. duration for the whole change.\n    QElapsedTimer m_stateTimer;\n    QElapsedTimer m_changeTimer; //! Started once in the constructor.\n    std::vector<Item> m_items;\n    std::vector<Param> m_parameters;\n};\n\n#endif // STATE_CHANGE_H\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "thermostat.cpp",
          "type": "blob",
          "size": 51.244140625,
          "content": "/*\n * thermostat.cpp\n *\n * Add Support for Thermostat Cluster 0x0201 and Bitron Thermostat 902010/32\n *\n * A sensor type ZHAThermostat is created with the following options in state and config:\n *\n * option             | read/write | attribute | description\n * -------------------|------------|-----------|---------------------\n * state.on           | read only  | 0x0029    | running state on/off\n * state.temperature  | read only  | 0x0000    | measured temperature\n * config.heatsetpoint| read write | 0x0012    | heating setpoint\n * config.mode        | read write | 0x001C    | System mode\n * config.scheduleron | read write | 0x0025    | scheduler on/off\n * config.offset      | read write | 0x0010    | temperature offset\n * config.scheduler   | read write | (command) | scheduled setpoints\n *\n *\n * Example sensor:\n *\n * /api/<apikey>/sensors/<id>/\n *    {\n *       config: {\n *          \"heatsetpoint\": 2200,\n *          \"offset\": 0,\n *          \"scheduler\": \"Monday,Tuesday,Wednesday,Thursday,Friday 05:00 2200 19:00 1800;Saturday,Sunday 06:00 2100 19:00 1800;\"\n *          \"scheduleron\": true\n *       },\n *       state: {\n *          \"on\": true,\n *          \"temperature\": 2150\n *        },\n *       \"ep\": 1,\n *       \"manufacturername\": \"Bitron Home\",\n *       \"modelid\": \"902010/32\",\n *        \"type\": \"ZHAThermostat\",\n *       ...\n *    }\n *\n * Rest API example commands:\n * -X PUT /api/<apikey>/sensors/<id>/config -d '{ \"heatsetpoint\": 1800 }'\n * -X PUT /api/<apikey>/sensors/<id>/config -d '{ \"scheduleron\": true }'\n * -X PUT /api/<apikey>/sensors/<id>/config -d '{ \"offset\": 0 }'\n * -X PUT /api/<apikey>/sensors/<id>/config -d '{ \"scheduler\": \"Monday 05:00 2200 19:00 1800;\" }'\n *                                          -d '{ \"scheduler\": \"\" }'  (send get scheduler command)\n *\n *\n * Attributes (only a subset):\n *   ID      Type  Type    Description                     Default\n *   0x0000  0x29  int16s  Local Temperature               --\n *   0x0010  0x28  int8s   Local Temperature Calibration   --\n *   0x0012  0x29  int16s  Occupied Heating Setpoint       2000 (20 °C)\n *   0x0025  0x18  bit8    Programming Operation Mode      0\n *                         Bit#0 of this attribute controls\n *                         the enabling of the Thermostat Scheduler.\n *   0x0029  0x19  bit16   Thermostat Running State        0\n *                         Bit0=Heat State On\n *                         Bit1=Cool State On\n *\n *   Commands Received (Client to Server):\n *   Command-ID  Name\n *   0x00        Setpoint Raise/Lower\n *   0x01        Set Weekly Schedule\n *   0x02        Get Weekly Schedule\n *   0x03        Clear Weekly Schedule\n *\n *   Commands Generated (Server to Client):\n *   Command-ID  Name\n *   0x00        Current Weekly Schedule\n *\n *   Weekly Schedule format\n *   Octets 1           1       1     2           2/0         2/0       ...   2   2/0   2/0\n *   Type   enum8       bit8    bit8  int16u      int16s      int16s\n *   Name   Number      Day of  Mode  Transition  Heat        Cool\n *          Transitions Week    (1,2) Time 1      Setpoint 1  Setpoint1\n *\n *   Day of Week: bitmap8 [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Away]\n *                bit         0       1       2         3        4         5        6       7\n *   Example:\n *   Monday, Tuesday, Thursday, Friday = 0011 0110 = 0x36\n *        |        |         |     ^-------^|  ||\n *        |        |          ---------------  ||\n *        |        -----------------------------|\n *        ---------------------------------------\n *\n */\n\n#include <bitset>\n#include <QJsonDocument>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"thermostat.h\"\n\nconst std::array<KeyValMap, 6> RConfigModeLegrandValues = { { {QLatin1String(\"confort\"), 0}, {QLatin1String(\"confort-1\"), 1}, {QLatin1String(\"confort-2\"), 2},\n                                                              {QLatin1String(\"eco\"), 3}, {QLatin1String(\"hors gel\"), 4}, {QLatin1String(\"off\"), 5} } };\n\nconst std::array<KeyValMapTuyaSingle, 3> RConfigModeValuesTuya1 = { { {QLatin1String(\"auto\"), {0x00}}, {QLatin1String(\"heat\"), {0x01}}, {QLatin1String(\"off\"), {0x02}} } };\n\nconst std::array<KeyValMapTuyaSingle, 2> RConfigModeValuesTuya2 = { { {QLatin1String(\"off\"), {0x00}}, {QLatin1String(\"heat\"), {0x01}} } };\n\nconst std::array<KeyValMapTuyaSingle, 4> RConfigModeValuesTuya3 = { { {QLatin1String(\"auto\"), {0x00}}, {QLatin1String(\"manual\"), {0x01}}, {QLatin1String(\"boost\"), {0x02}}, {QLatin1String(\"holiday\"), {0x03}}} };\n\nconst std::array<KeyValMapTuyaSingle, 2> RConfigModeValuesTuya4 = { { {QLatin1String(\"auto\"), {0x00}}, {QLatin1String(\"heat\"), {0x01}} } };\n\nconst std::array<KeyValMap, 9> RConfigModeValues = { { {QLatin1String(\"off\"), 0}, {QLatin1String(\"auto\"), 1}, {QLatin1String(\"cool\"), 3}, {QLatin1String(\"heat\"), 4},\n                                                              {QLatin1String(\"emergency heating\"), 5}, {QLatin1String(\"precooling\"), 6}, {QLatin1String(\"fan only\"), 7},\n                                                              {QLatin1String(\"dry\"), 8}, {QLatin1String(\"sleep\"), 9} } };\n\nconst std::array<KeyValMapTuyaSingle, 7> RConfigPresetValuesTuya = { { {QLatin1String(\"holiday\"), {0x00}}, {QLatin1String(\"auto\"), {0x01}}, {QLatin1String(\"manual\"), {0x02}},\n                                                                              {QLatin1String(\"comfort\"), {0x04}}, {QLatin1String(\"eco\"), {0x05}}, {QLatin1String(\"boost\"), {0x06}},\n                                                                              {QLatin1String(\"complex\"), {0x07}} } };\n\nconst std::array<KeyMap, 2> RConfigPresetValuesTuya2 = { { {QLatin1String(\"auto\")}, {QLatin1String(\"program\")} } };\n\nconst std::array<KeyMap, 4> RConfigPresetValuesTuya3 = { { {QLatin1String(\"both\")}, {QLatin1String(\"humidity\")}, {QLatin1String(\"temperature\")}, {QLatin1String(\"off\")} } };\n\nconst std::array<KeyValMap, 3> RConfigTemperatureMeasurementValues = { { {QLatin1String(\"air sensor\"), 0}, {QLatin1String(\"floor sensor\"), 1},\n                                                                                {QLatin1String(\"floor protection\"), 3} } };\n\nconst std::array<KeyValMap, 5> RConfigSwingModeValues = { { {QLatin1String(\"fully closed\"), 1}, {QLatin1String(\"fully open\"), 2}, {QLatin1String(\"quarter open\"), 3},\n                                                                   {QLatin1String(\"half open\"), 4}, {QLatin1String(\"three quarters open\"), 5} } };\n\nconst std::array<KeyValMapInt, 6> RConfigControlSequenceValues = { { {1, COOLING_ONLY}, {2, COOLING_WITH_REHEAT}, {3, HEATING_ONLY}, {4, HEATING_WITH_REHEAT},\n                                                                            {5, COOLING_AND_HEATING_4PIPES}, {6, COOLING_AND_HEATING_4PIPES_WITH_REHEAT} } };\n\nconst std::array<KeyMap, 3> RConfigModeValuesEurotronic = { { {QLatin1String(\"off\")}, {QLatin1String(\"heat\")}, {QLatin1String(\"auto\")} } };\n\n/*! Covert Zigbee weekdays bitmap to ISO or v.v.\n */\nstatic quint8 convertWeekdayBitmap(const quint8 weekdayBitmap)\n{\n    quint8 result = 0;\n    if (weekdayBitmap & 0b00000001) { result |= 0b00000001; }\n    if (weekdayBitmap & 0b00000010) { result |= 0b01000000; }\n    if (weekdayBitmap & 0b00000100) { result |= 0b00100000; }\n    if (weekdayBitmap & 0b00001000) { result |= 0b00010000; }\n    if (weekdayBitmap & 0b00010000) { result |= 0b00001000; }\n    if (weekdayBitmap & 0b00100000) { result |= 0b00000100; }\n    if (weekdayBitmap & 0b01000000) { result |= 0b00000010; }\n    return result;\n}\n\n/*! Serialise a list of transitions.\n * \\param transitions the list of transitions\n * \\param s the serialised transitions\n */\nbool DeRestPluginPrivate::serialiseThermostatTransitions(const QVariantList &transitions, QString *s)\n{\n    *s = \"\";\n    if (transitions.size() < 1 || transitions.size() > 10)\n    {\n        return false;\n    }\n    for (const QVariant &entry : transitions)\n    {\n        QVariantMap transition = entry.toMap();\n        for (const QString &key : transition.keys())\n        {\n            if (key != QLatin1String(\"localtime\") && key != QLatin1String(\"heatsetpoint\"))\n            {\n                return false;\n            }\n        }\n        if (!transition.contains(QLatin1String(\"localtime\")) || !transition.contains(QLatin1String(\"heatsetpoint\")) ||\n            transition[QLatin1String(\"localtime\")].type() != QVariant::String || transition[QLatin1String(\"heatsetpoint\")].type() != QVariant::Double)\n        {\n            return false;\n        }\n        bool ok;\n        int heatsetpoint = transition[QLatin1String(\"heatsetpoint\")].toInt(&ok);\n        if (!ok || heatsetpoint < 500 || heatsetpoint > 3000)\n        {\n            return false;\n        }\n        QString localtime = transition[QLatin1String(\"localtime\")].toString();\n        int hh, mm;\n        ok = (localtime.size() == 6 && localtime.mid(0, 1) == \"T\" && localtime.mid(3, 1) == \":\");\n        if (ok)\n        {\n            hh = localtime.mid(1, 2).toInt(&ok);\n        }\n        if (ok)\n        {\n            mm = localtime.mid(4, 2).toInt(&ok);\n        }\n        if (!ok)\n        {\n            return false;\n        }\n        *s += QString(\"T%1:%2|%3\")\n            .arg(hh, 2, 10, QChar('0'))\n            .arg(mm, 2, 10, QChar('0'))\n            .arg(heatsetpoint);\n    }\n    return true;\n}\n\n/*! Deserialise a list of transitions.\n * \\param s the serialised transitions\n * \\param transitions the list of transitions\n */\nbool DeRestPluginPrivate::deserialiseThermostatTransitions(const QString &s, QVariantList *transitions)\n{\n    transitions->clear();\n    QStringList list = s.split(\"T\", SKIP_EMPTY_PARTS);\n    for (const QString &entry : list)\n    {\n        QStringList attributes = entry.split(\"|\");\n        if (attributes.size() != 2)\n        {\n            transitions->clear();\n            return false;\n        }\n        QVariantMap map;\n        map[QLatin1String(\"localtime\")] = \"T\" + attributes.at(0);\n        map[QLatin1String(\"heatsetpoint\")] = attributes.at(1).toInt();\n        transitions->push_back(map);\n    }\n    return true;\n}\n\n/*! Serialise a thermostat schedule\n * \\param schedule the schedule\n * \\param s the serialised schedule\n */\nbool DeRestPluginPrivate::serialiseThermostatSchedule(const QVariantMap &schedule, QString *s)\n{\n    *s = \"\";\n    for (const QString &key : schedule.keys())\n    {\n        QString transitions;\n\n        *s += QString(\"%1/\").arg(key);\n        if (!serialiseThermostatTransitions(schedule[key].toList(), &transitions))\n        {\n            return false;\n        }\n        *s += transitions;\n    }\n    return true;\n}\n\n/*! Deserialise a thermostat schedule\n * \\param s the serialised schedule\n * \\param schedule the schedule\n */\nbool DeRestPluginPrivate::deserialiseThermostatSchedule(const QString &s, QVariantMap *schedule)\n{\n    schedule->clear();\n    QStringList list = s.split(\"W\", SKIP_EMPTY_PARTS);\n    for (const QString &entry : list)\n    {\n        QStringList attributes = entry.split(\"/\");\n        QVariantList list;\n        if (attributes.size() != 2 || !deserialiseThermostatTransitions(attributes.at(1), &list))\n        {\n            schedule->clear();\n            return false;\n        }\n        (*schedule)[\"W\" + attributes.at(0)] = list;\n    }\n    return true;\n}\n\n/*! Update thermostat schedule with new transitions\n * \\param sensor the sensorNode\n * \\param newWeekdays the ISO bitmap of the weekdays\n * \\param transitions the serialised list of transitions\n */\nvoid DeRestPluginPrivate::updateThermostatSchedule(Sensor *sensor, quint8 newWeekdays, QString &transitions)\n{\n    // Deserialise currently saved schedule, without newWeekdays.\n    bool ok = true;\n    ResourceItem *item = sensor->item(RConfigSchedule);\n    if (!item)\n    {\n        return;\n    }\n    QMap<quint8, QString> map;\n    QStringList list = item->toString().split(\"W\", SKIP_EMPTY_PARTS);\n    for (const QString &entry : list)\n    {\n        QStringList attributes = entry.split(\"/\");\n        quint8 weekdays = attributes.at(0).toUInt(&ok);\n        if (!ok)\n        {\n            break;\n        }\n        weekdays &= ~newWeekdays;\n        if (weekdays != 0)\n        {\n            map[weekdays] = attributes.at(1);\n        }\n    }\n    if (!ok)\n    {\n        map.clear();\n    }\n\n    // Check if we already have an entry with these transitions.\n    if (transitions.size() > 0)\n    {\n        ok = false;\n        for (const quint8 weekdays : map.keys())\n        {\n            if (map[weekdays] == transitions)\n            {\n                // Merge the entries.\n                map.remove(weekdays);\n                map[weekdays | newWeekdays] = transitions;\n                ok = true;\n                break;\n            }\n        }\n        if (!ok)\n        {\n            // Create new entry.\n            map[newWeekdays] = transitions;\n        }\n    }\n\n    // Store the updated schedule.\n    QString s = QString(\"\");\n    for (const quint8 weekdays : map.keys())\n    {\n        s += QString(\"W%1/\").arg(weekdays) + map[weekdays];\n    }\n    item->setValue(s, ResourceItem::SourceDevice);\n    enqueueEvent(Event(RSensors, RConfigSchedule, sensor->id(), item));\n    updateSensorEtag(&*sensor);\n    sensor->setNeedSaveDatabase(true);\n    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n}\n\n\n// static const QStringList weekday({\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Away\"});\nstatic int dayofweekTimer = 0;\n\n/*! Handle packets related to the ZCL Thermostat cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Thermostat cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleThermostatClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAThermostat\"));\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No thermostat sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    bool isClusterCmd = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n    if ((zclFrame.frameControl() & 0x09) == (deCONZ::ZclFCDirectionServerToClient | deCONZ::ZclFCClusterCommand))\n    {\n        isClusterCmd = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            ResourceItem *item = nullptr;\n\n            switch (attrId)\n            {\n            case 0x0000: // Local Temperature\n            {\n                qint16 temperature = attr.numericValue().s16;\n                item = sensor->item(RStateTemperature);\n                if (item)\n                {\n                    if (updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item->toNumber() != temperature)\n                    {\n                        item->setValue(temperature);\n                        enqueueEvent(Event(RSensors, RStateTemperature, sensor->id(), item));\n                        stateUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0008:  // Pi Heating Demand\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"SPZB\")) || // Eurotronic Spirit\n                    sensor->modelId() == QLatin1String(\"Thermostat\"))      // eCozy\n                {\n                    quint8 valve = attr.numericValue().u8;\n                    bool on = valve > 3;\n                    item = sensor->item(RStateOn);\n                    if (item)\n                    {\n                        if (updateType == NodeValue::UpdateByZclReport)\n                        {\n                            stateUpdated = true;\n                        }\n                        if (item->toBool() != on)\n                        {\n                            item->setValue(on);\n                            enqueueEvent(Event(RSensors, RStateOn, sensor->id(), item));\n                            stateUpdated = true;\n                        }\n                    }\n                    item = sensor->item(RStateValve);\n                    if (item)\n                    {\n                        if (updateType == NodeValue::UpdateByZclReport)\n                        {\n                            stateUpdated = true;\n                        }\n                        if (item && item->toNumber() != valve)\n                        {\n                            item->setValue(valve);\n                            enqueueEvent(Event(RSensors, RStateValve, sensor->id(), item));\n                            stateUpdated = true;\n                        }\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0010: // Local Temperature Calibration (offset in 0.1 °C steps, from -2,5 °C to +2,5 °C)\n            {\n                qint16 config = attr.numericValue().s8 * 10;\n                item = sensor->item(RConfigOffset);\n                \n                if (item && item->toNumber() != config)\n                {\n                    item->setValue(config);\n                    enqueueEvent(Event(RSensors, RConfigOffset, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0011: // Occupied Cooling Setpoint\n            {\n                qint16 coolSetpoint = attr.numericValue().s16;\n                item = sensor->item(RConfigCoolSetpoint);\n                if (item && item->toNumber() != coolSetpoint)\n                {\n                    item->setValue(coolSetpoint);\n                    enqueueEvent(Event(RSensors, RConfigCoolSetpoint, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0012: // Occupied Heating Setpoint\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                {\n                    // Use 0x4003 instead.\n                }\n                else\n                {\n                    qint16 heatSetpoint = attr.numericValue().s16;\n                    item = sensor->item(RConfigHeatSetpoint);\n                    if (item && item->toNumber() != heatSetpoint)\n                    {\n                        item->setValue(heatSetpoint);\n                        enqueueEvent(Event(RSensors, RConfigHeatSetpoint, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x001B: // Control Sequence of Operation\n            {\n                quint16 controlSequence = attr.numericValue().u16;\n                quint8 mode = 0;\n\n                if      (controlSequence == COOLING_ONLY)                           { mode = 1; }\n                else if (controlSequence == COOLING_WITH_REHEAT)                    { mode = 2; }\n                else if (controlSequence == HEATING_ONLY)                           { mode = 3; }\n                else if (controlSequence == HEATING_WITH_REHEAT)                    { mode = 4; }\n                else if (controlSequence == COOLING_AND_HEATING_4PIPES)             { mode = 5; }\n                else if (controlSequence == COOLING_AND_HEATING_4PIPES_WITH_REHEAT) { mode = 6; }\n\n                item = sensor->item(RConfigControlSequence);\n                if (item && item->toNumber() != mode && mode > 0 && mode <= 6)\n                {\n                    item->setValue(mode);\n                    enqueueEvent(Event(RSensors, RConfigControlSequence, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x001C: // System Mode\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"SLR2\")) ||   // Hive\n                    sensor->modelId().startsWith(QLatin1String(\"SLR1b\")) ||  // Hive\n                    sensor->modelId().startsWith(QLatin1String(\"Zen-01\")))   // Zen\n                {\n                    qint8 mode = attr.numericValue().s8;\n                    QString modeSet;\n\n                    if      (mode == 0x01) { modeSet = QLatin1String(\"auto\"); }\n                    else if (mode == 0x03) { modeSet = QLatin1String(\"cool\"); }\n                    else if (mode == 0x04) { modeSet = QLatin1String(\"heat\"); }\n                    else if (mode == 0x05) { modeSet = QLatin1String(\"emergency heating\"); }\n                    else if (mode == 0x06) { modeSet = QLatin1String(\"precooling\"); }\n                    else if (mode == 0x07) { modeSet = QLatin1String(\"fan only\"); }\n                    else if (mode == 0x08) { modeSet = QLatin1String(\"dry\"); }\n                    else if (mode == 0x09) { modeSet = QLatin1String(\"sleep\"); }\n                    else                   { modeSet = QLatin1String(\"off\"); }\n\n                    item = sensor->item(RConfigMode);\n                    if (item && !item->toString().isEmpty() && item->toString() != modeSet)\n                    {\n                        item->setValue(modeSet);\n                        enqueueEvent(Event(RSensors, RConfigMode, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0023: // Temperature Setpoint Hold\n            {\n                if (sensor->modelId() == QLatin1String(\"Thermostat\")) // eCozy\n                {\n                    bool scheduleOn = (attr.numericValue().u8 == 0x00); // setpoint hold off -> schedule enabled\n\n                    item = sensor->item(RConfigScheduleOn);\n                    if (item && item->toBool() != scheduleOn)\n                    {\n                        item->setValue(scheduleOn);\n                        enqueueEvent(Event(RSensors, RConfigScheduleOn, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0025:  // Thermostat Programming Operation Mode, default 0 (bit#0 = disable/enable Scheduler)\n            {\n                bool on = attr.bitmap() & 0x01 ? true : false;\n                item = sensor->item(RConfigScheduleOn);\n                if (item && item->toBool() != on)\n                {\n                    item->setValue(on);\n                    enqueueEvent(Event(RSensors, RConfigScheduleOn, sensor->id(), item));\n                    configUpdated = true;\n\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0029:  // Thermostat Running State (bit0=Heat State On/Off, bit1=Cool State On/Off)\n            {\n                bool on = attr.bitmap() > 0;\n                item = sensor->item(RStateOn);\n\n                if (item && updateType == NodeValue::UpdateByZclReport)\n                {\n                    stateUpdated = true;\n                }\n                if (item && item->toBool() != on)\n                {\n                    item->setValue(on);\n                    enqueueEvent(Event(RSensors, RStateOn, sensor->id(), item));\n                    stateUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0030: // Setpoint Change Source\n            {\n                quint8 source = attr.numericValue().u8;\n                item = sensor->item(RConfigLastChangeSource);\n                if (item && item->toNumber() != source && source <= 2)\n                {\n                    item->setValue(source);\n                    enqueueEvent(Event(RSensors, RConfigLastChangeSource, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0031: // Setpoint Change Amount\n            {\n                qint16 amount = attr.numericValue().s16;\n                item = sensor->item(RConfigLastChangeAmount);\n                if (item && item->toNumber() != amount && amount > -32768)\n                {\n                    item->setValue(amount);\n                    enqueueEvent(Event(RSensors, RConfigLastChangeAmount, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0032: // Setpoint Change Timestamp\n            {\n                const QDateTime epoch = QDateTime(QDate(2000, 1, 1), QTime(0, 0), Qt::UTC);\n                QDateTime time = epoch.addSecs(attr.numericValue().u32 - QDateTime::currentDateTime().offsetFromUtc());\n                item = sensor->item(RConfigLastChangeTime);\n                if (item) // && item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                {\n                    item->setValue(time);\n                    enqueueEvent(Event(RSensors, RConfigLastChangeTime, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0045: // AC Louvers Position\n            {\n                qint8 mode = attr.numericValue().s8;\n                QString modeSet;\n\n                if      (mode == 0x01) { modeSet = QLatin1String(\"fully closed\"); }\n                else if (mode == 0x02) { modeSet = QLatin1String(\"fully open\"); }\n                else if (mode == 0x03) { modeSet = QLatin1String(\"quarter open\"); }\n                else if (mode == 0x04) { modeSet = QLatin1String(\"half open\"); }\n                else if (mode == 0x05) { modeSet = QLatin1String(\"three quarters open\"); }\n                else                   { modeSet = QLatin1String(\"fully closed\"); }\n\n                item = sensor->item(RConfigSwingMode);\n                if (item && !item->toString().isEmpty() && item->toString() != modeSet)\n                {\n                    item->setValue(modeSet);\n                    enqueueEvent(Event(RSensors, RConfigSwingMode, sensor->id(), item));\n                    configUpdated = true;\n                }\n\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0403: // Temperature measurement\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"Super TR\"))) // ELKO\n                {\n                    quint8 mode = attr.numericValue().u8;\n                    QString modeset;\n\n                    if      (mode == 0x00) { modeset = QLatin1String(\"air sensor\"); }\n                    else if (mode == 0x01) { modeset = QLatin1String(\"floor sensor\"); }\n                    else if (mode == 0x03) { modeset = QLatin1String(\"floor protection\"); }\n\n                    item = sensor->item(RConfigTemperatureMeasurement);\n\n                    if (item && item->toString() != modeset)\n                    {\n                        item->setValue(modeset);\n                        enqueueEvent(Event(RSensors, RConfigTemperatureMeasurement, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0406: // Device on/off\n            {\n                if (sensor->modelId() == QLatin1String(\"Super TR\")) // ELKO\n                {\n                    bool on = attr.numericValue().u8 > 0 ? true : false;\n                    item = sensor->item(RStateOn);\n\n                    if (item && updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item && item->toBool() != on)\n                    {\n                        item->setValue(on);\n                        enqueueEvent(Event(RSensors, RStateOn, sensor->id(), item));\n                        stateUpdated  = true;\n                    }\n\n                    // Set config/mode to have an adequate representation based on this attribute\n                    QString modeset;\n                    if (on == true)  { modeset = QLatin1String(\"heat\"); }\n                    else             { modeset = QLatin1String(\"off\"); }\n\n                    item = sensor->item(RConfigMode);\n                    if (item && !item->toString().isEmpty() && item->toString() != modeset)\n                    {\n                        item->setValue(modeset);\n                        enqueueEvent(Event(RSensors, RConfigMode, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n                }\n            }\n                break;\n\n            case 0x0409: // Floor temperature\n            {\n                if (sensor->modelId().startsWith(QLatin1String(\"Super TR\"))) // ELKO\n                {\n                    qint16 floortemp = attr.numericValue().s16;\n                    item = sensor->item(RStateFloorTemperature);\n\n                    if (item && updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item && item->toNumber() != floortemp)\n                    {\n                        item->setValue(floortemp);\n                        enqueueEvent(Event(RSensors, RStateFloorTemperature, sensor->id(), item));\n                        stateUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x0413: // Child lock\n            {\n                if (sensor->modelId() == QLatin1String(\"Super TR\")) // ELKO\n                {\n                    bool enabled = attr.numericValue().u8 > 0 ? true : false;\n                    item = sensor->item(RConfigLocked);\n                    \n                    if (item && item->toBool() != enabled)\n                    {\n                        item->setValue(enabled);\n                        enqueueEvent(Event(RSensors, RConfigLocked, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n                }\n            }\n                break;\n\n            case 0x0415: // Heating active/inactive\n            {\n                if (sensor->modelId() == QLatin1String(\"Super TR\")) // ELKO\n                {\n                    bool on = attr.numericValue().u8 > 0 ? true : false;\n                    item = sensor->item(RStateHeating);\n\n                    if (item && updateType == NodeValue::UpdateByZclReport)\n                    {\n                        stateUpdated = true;\n                    }\n                    if (item && item->toBool() != on)\n                    {\n                        item->setValue(on);\n                        enqueueEvent(Event(RSensors, RStateHeating, sensor->id(), item));\n                        stateUpdated  = true;\n                    }\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n                }\n            }\n                break;\n\n            // manufacturerspecific reported by Eurotronic SPZB0001\n            // https://eurotronic.org/wp-content/uploads/2019/01/Spirit_ZigBee_BAL_web_DE_view_V9.pdf\n            case 0x4000: // enum8 (0x30): value 0x02, TRV mode\n            {\n                if (zclFrame.manufacturerCode() == VENDOR_JENNIC)\n                {\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x4001: // U8 (0x20): value 0x00, valve position\n            case 0x4002: // U8 (0x20): value 0x00, errors\n            {\n                if (zclFrame.manufacturerCode() == VENDOR_JENNIC)\n                {\n                }\n            }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n                break;\n\n            case 0x4003:\n            {   // Current temperature set point - this will be reported when manually changing the temperature\n                if (zclFrame.manufacturerCode() == VENDOR_JENNIC && sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                {\n                    qint16 heatSetpoint = attr.numericValue().s16;\n                    item = sensor->item(RConfigHeatSetpoint);\n                    \n                    if (item)\n                    {\n                        if (updateType == NodeValue::UpdateByZclReport)\n                        {\n                            stateUpdated = true;\n                        }\n                        if (item->toNumber() != heatSetpoint)\n                        {\n                            item->setValue(heatSetpoint);\n                            enqueueEvent(Event(RSensors, RConfigHeatSetpoint, sensor->id(), item));\n                            stateUpdated = true;\n                        }\n                    }\n                }\n                \n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            case 0x4008: // U24 (0x22): 0x000001, host flags\n            {\n                if (zclFrame.manufacturerCode() == VENDOR_JENNIC && sensor->modelId().startsWith(QLatin1String(\"SPZB\"))) // Eurotronic Spirit\n                {\n                    quint32 hostFlags = attr.numericValue().u32;\n                    bool flipped = hostFlags & 0x000002;\n                    QString mode = hostFlags & 0x000010 ? \"off\" : hostFlags & 0x000004 ? \"heat\" : \"auto\";\n                    bool locked = hostFlags & 0x000080;\n                    item = sensor->item(RConfigHostFlags);\n                    if (item && item->toNumber() != hostFlags)\n                    {\n                        item->setValue(hostFlags);\n                        // Hidden attribute - no event\n                        configUpdated = true; // but do save database\n                    }\n                    item = sensor->item(RConfigDisplayFlipped);\n                    if (item && item->toBool() != flipped)\n                    {\n                        item->setValue(flipped);\n                        enqueueEvent(Event(RSensors, RConfigDisplayFlipped, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                    item = sensor->item(RConfigLocked);\n                    if (item && item->toBool() != locked)\n                    {\n                        item->setValue(locked);\n                        enqueueEvent(Event(RSensors, RConfigLocked, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                    item = sensor->item(RConfigMode);\n                    if (item && item->toString() != mode)\n                    {\n                        item->setValue(mode);\n                        enqueueEvent(Event(RSensors, RConfigMode, sensor->id(), item));\n                        configUpdated = true;\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            // Manufacturer Specific for Danfoss Icon Floor Heating Controller\n            case 0x4110:  // Danfoss Output Status\n            {\n                if (sensor->modelId() == QLatin1String(\"0x8020\") || // Danfoss RT24V Display thermostat\n                    sensor->modelId() == QLatin1String(\"0x8021\") || // Danfoss RT24V Display thermostat with floor sensor\n                    sensor->modelId() == QLatin1String(\"0x8030\") || // Danfoss RTbattery Display thermostat\n                    sensor->modelId() == QLatin1String(\"0x8031\") || // Danfoss RTbattery Display thermostat with infrared\n                    sensor->modelId() == QLatin1String(\"0x8034\") || // Danfoss RTbattery Dial thermostat\n                    sensor->modelId() == QLatin1String(\"0x8035\"))   // Danfoss RTbattery Dial thermostat with infrared\n                {\n                    quint8 outputStatus = attr.numericValue().u8;\n                    bool on = outputStatus > 0;\n                    item = sensor->item(RStateOn);\n                    if (item)\n                    {\n                        if (updateType == NodeValue::UpdateByZclReport)\n                        {\n                            stateUpdated = true;\n                        }\n                        if (item->toBool() != on)\n                        {\n                            item->setValue(on);\n                            enqueueEvent(Event(RSensors, RStateOn, sensor->id(), item));\n                            stateUpdated = true;\n                        }\n                    }\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n\n    // Read ZCL Cluster Command Response\n    if (isClusterCmd && zclFrame.commandId() == 0x00) // Get Weekly Schedule Response\n    {\n        // Read command parameters into serialised string.\n        QString transitions = QString(\"\");\n        quint8 numberOfTransitions = 0;\n        quint8 dayOfWeek = 0;\n        quint8 mode = 0;\n\n        stream >> numberOfTransitions;\n        stream >> dayOfWeek;\n        stream >> mode;\n\n        for (quint8 i = 0; i < numberOfTransitions; i++)\n        {\n            quint16 transitionTime;\n            qint16 heatSetpoint;\n            qint16 coolSetpoint;\n\n            stream >> transitionTime;\n            if (mode & 0x01) // bit 0: heat setpoint\n            {\n                stream >> heatSetpoint;\n                transitions += QString(\"T%1:%2|%3\")\n                    .arg(transitionTime / 60, 2, 10, QChar('0'))\n                    .arg(transitionTime % 60, 2, 10, QChar('0'))\n                    .arg(heatSetpoint);\n            }\n            if (mode & 0x02) // bit 1: cold setpoint\n            {\n                stream >> coolSetpoint;\n                // ignored for now\n                break;\n            }\n        }\n        if (stream.status() == QDataStream::ReadPastEnd)\n        {\n            return;\n        }\n\n        const quint8 newWeekdays = convertWeekdayBitmap(dayOfWeek);\n        updateThermostatSchedule(sensor, newWeekdays, transitions);\n    }\n}\n\n/*! Adds a thermostat command task to the queue.\n\n   \\param task - the task item\n   \\param cmdId - 0x00 setpoint raise/lower\n                  0x02 get schedule\n                  0x03 clear schedule\n   \\param setpoint - raise/lower value\n   \\param days - days to return schedule\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskThermostatCmd(TaskItem &task, uint16_t mfrCode, uint8_t cmd, int16_t setpoint, uint8_t daysToReturn)\n{\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(THERMOSTAT_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(cmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n            deCONZ::ZclFCDirectionClientToServer);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (cmd == 0x00)\n    {\n        stream << (qint8) 0x02;  // Enum 8 Both (adjust Heat Setpoint and Cool Setpoint)\n        stream << (qint8) setpoint;  // 8-bit raise/lower\n    }\n    else if (cmd == 0x02)  // get schedule\n    {\n        stream << (quint8) daysToReturn;\n        stream << (quint8) 0x01; // mode heat\n    }\n    else if (cmd == 0x03)  // clear schedule\n    {\n        // no payload\n    }\n    else\n    {\n        return false;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Adds a Set Weekly Schedule command to the queue.\n   \\param task - the task item\n   \\param weekdays - the ISO-bitmap of weekdays\n   \\param transitions - the serialised list of transitions\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskThermostatSetWeeklySchedule(TaskItem &task, quint8 weekdays, const QString &transitions)\n{\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(THERMOSTAT_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x01); // Set Weekly Schedule\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCDirectionClientToServer);\n\n    QStringList list = transitions.split(\"T\", SKIP_EMPTY_PARTS);\n    quint8 numberOfTransitions = list.size();\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    stream << numberOfTransitions;\n    stream << convertWeekdayBitmap(weekdays);\n    stream << (quint8) 0x01; // Mode: heat\n\n    for (const QString &entry : list)\n    {\n        QStringList attributes = entry.split(\"|\");\n        if (attributes.size() != 2)\n        {\n            return false;\n        }\n        const quint16 hh = attributes.at(0).mid(0, 2).toUInt();\n        const quint16 mm = attributes.at(0).mid(3, 2).toUInt();\n        const quint16 time = 60 * hh + mm;\n        const qint16 heatSetpoint = attributes.at(1).toInt();\n        stream << time;\n        stream << heatSetpoint;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Helper to generate a new task with new task and req id based on a reference */\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\n{\n    b.req.dstAddress() = a.req.dstAddress();\n    b.req.setDstAddressMode(a.req.dstAddressMode());\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\n    b.req.setDstEndpoint(a.req.dstEndpoint());\n    b.req.setRadius(a.req.radius());\n    b.req.setTxOptions(a.req.txOptions());\n    b.req.setSendDelay(a.req.sendDelay());\n    b.zclFrame.payload().clear();\n}\n\nbool DeRestPluginPrivate::addTaskThermostatGetSchedule(TaskItem &task)\n{\n    copyTaskReq(task, taskScheduleTimer);\n\n    dayofweekTimer = 0;\n\n    for (int i = 0; i < 7; i++)\n    {\n        // use QTimer to send a command once every second to battery Endpoints\n        QTimer::singleShot(1000 * (i + 2), this, SLOT(addTaskThermostatGetScheduleTimer()));\n    }\n\n    return true;\n}\n\nvoid DeRestPluginPrivate::addTaskThermostatGetScheduleTimer()\n{\n    TaskItem task;\n    copyTaskReq(taskScheduleTimer, task);\n\n    uint8_t dayofweek = (1 << dayofweekTimer);\n    dayofweekTimer++;\n\n    addTaskThermostatCmd(task, 0, 0x02, 0, dayofweek);  // get schedule\n}\n\n/*! Write Attribute on thermostat cluster.\n *  Iterate over every day and get schedule for each day.\n   \\param task - the task item\n   \\param attrId\n   \\param attrType\n   \\param attrValue\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskThermostatReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t mfrCode, uint16_t attrId, uint8_t attrType, int attrValue)\n{\n    if (readOrWriteCmd != deCONZ::ZclReadAttributesId && readOrWriteCmd != deCONZ::ZclWriteAttributesId)\n    {\n        DBG_Printf(DBG_INFO, \"Thermostat invalid parameter readOrWriteCmd %d\\n\", readOrWriteCmd);\n        return false;\n    }\n\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(THERMOSTAT_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(readOrWriteCmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n            deCONZ::ZclFCDirectionClientToServer |\n            deCONZ::ZclFCDisableDefaultResponse);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (readOrWriteCmd == deCONZ::ZclWriteAttributesId)\n    {\n        stream << attrId;\n        stream << attrType;\n\n        deCONZ::ZclAttribute attr(attrId, attrType, QLatin1String(\"\"), deCONZ::ZclWrite, true);\n        attr.setValue(QVariant(attrValue));\n\n        if (!attr.writeToStream(stream))\n        {\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Write Attribute List on thermostat cluster.\n   \\param task - the task item\n   \\param AttributeList\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskThermostatWriteAttributeList(TaskItem &task, uint16_t mfrCode, QMap<quint16, quint32> &AttributeList )\n{\n\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(THERMOSTAT_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n            deCONZ::ZclFCDirectionClientToServer |\n            deCONZ::ZclFCDisableDefaultResponse);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    quint16 attrId;\n    quint32 attrValue;\n\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    QMapIterator<quint16, quint32> i(AttributeList);\n    while (i.hasNext()) {\n        i.next();\n        attrId = i.key();\n        attrValue = i.value();\n\n        //attribute\n        stream << (quint16) attrId;\n\n        //type and value\n        switch (attrId)\n        {\n            case 0x0023:\n            case 0x001C:\n                stream << (quint8) deCONZ::Zcl8BitEnum;\n                stream << (quint8) attrValue;\n                break;\n            case 0x0012:\n            case 0x0024:\n                stream << (quint8) deCONZ::Zcl16BitInt;\n                stream << (quint16) attrValue;\n                break;\n            default:\n            {\n                // to avoid\n            }\n            break;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Adds a control mode command task to the queue. Used by Legrand\n\n   \\param task - the task item\n   \\param cmdId - 0x00 set heating mode\n   \\param mode\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskControlModeCmd(TaskItem &task, uint8_t cmdId, int8_t mode)\n{\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(LEGRAND_CONTROL_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(cmdId);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n            deCONZ::ZclFCDirectionClientToServer);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (cmdId == 0x00)\n    {\n        stream << (qint8) mode;\n    }\n    else\n    {\n        return false;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "thermostat.h",
          "type": "blob",
          "size": 2.3603515625,
          "content": "#ifndef THERMOSTAT_H\n#define THERMOSTAT_H\n\n#include \"utils/utils.h\"\n\n//Attribute IDs\n#define THERM_ATTRID_LOCAL_TEMPERATURE_CALIBRATION           0x0010\n#define THERM_ATTRID_OCCUPIED_COOLING_SETPOINT               0x0011\n#define THERM_ATTRID_OCCUPIED_HEATING_SETPOINT               0x0012\n#define THERM_ATTRID_CONTROL_SEQUENCE_OF_OPERATION           0x001B\n#define THERM_ATTRID_SYSTEM_MODE                             0x001C\n#define THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD               0x0023\n#define THERM_ATTRID_TEMPERATURE_SETPOINT_HOLD_DURATION      0x0024\n#define THERM_ATTRID_THERMOSTAT_PROGRAMMING_OPERATION_MODE   0x0025\n#define THERM_ATTRID_AC_LOUVER_POSITION                      0x0045\n#define THERM_ATTRID_TEMPERATURE_MEASUREMENT                 0x0403 // ELKO specific\n#define THERM_ATTRID_DEVICE_ON                               0x0406 // ELKO specific\n#define THERM_ATTRID_CHILD_LOCK                              0x0413 // ELKO specific\n#define THERM_ATTRID_CURRENT_TEMPERATURE_SETPOINT            0x4003 // Eurotronic specific\n#define THERM_ATTRID_HOST_FLAGS                              0x4008 // Eurotronic specific\n\n// Values for attribute Control Sequence of Operation (0x001B)\n#define COOLING_ONLY                            0x00\n#define COOLING_WITH_REHEAT                     0x01\n#define HEATING_ONLY                            0x02\n#define HEATING_WITH_REHEAT                     0x03\n#define COOLING_AND_HEATING_4PIPES              0x04\n#define COOLING_AND_HEATING_4PIPES_WITH_REHEAT  0x05\n\nextern const std::array<KeyValMap, 6> RConfigModeLegrandValues;\nextern const std::array<KeyValMapTuyaSingle, 3> RConfigModeValuesTuya1;\nextern const std::array<KeyValMapTuyaSingle, 2> RConfigModeValuesTuya2;\nextern const std::array<KeyValMapTuyaSingle, 4> RConfigModeValuesTuya3;\nextern const std::array<KeyValMapTuyaSingle, 2> RConfigModeValuesTuya4;\nextern const std::array<KeyValMap, 9> RConfigModeValues;\nextern const std::array<KeyValMapTuyaSingle, 7> RConfigPresetValuesTuya;\nextern const std::array<KeyMap, 2> RConfigPresetValuesTuya2;\nextern const std::array<KeyMap, 4> RConfigPresetValuesTuya3;\nextern const std::array<KeyValMap, 3> RConfigTemperatureMeasurementValues;\nextern const std::array<KeyValMap, 5> RConfigSwingModeValues;\nextern const std::array<KeyValMapInt, 6> RConfigControlSequenceValues;\nextern const std::array<KeyMap, 3> RConfigModeValuesEurotronic;\n\n#endif // THERMOSTAT_H\n"
        },
        {
          "name": "thermostat_ui_configuration.cpp",
          "type": "blob",
          "size": 5.2919921875,
          "content": "#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"thermostat_ui_configuration.h\"\n\n/*! Handle packets related to the ZCL Thermostat UI Configration cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Thermostat cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleThermostatUiConfigurationClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAThermostat\"));\n\n    if (!sensor)\n    {\n        DBG_Printf(DBG_INFO, \"No thermostat sensor found for 0x%016llX, endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        bool configUpdated = false;\n        bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            ResourceItem *item = nullptr;\n\n            switch (attrId)\n            {\n            case THERM_UI_ATTRID_KEYPAD_LOCKOUT:\n            {\n                bool locked = attr.numericValue().u8 > 0 ? true : false;\n                item = sensor->item(RConfigLocked);\n\n                if (item && item->toBool() != locked)\n                {\n                    item->setValue(locked);\n                    enqueueEvent(Event(RSensors, RConfigLocked, sensor->id(), item));\n                    configUpdated = true;\n                }\n                sensor->setZclValue(updateType, ind.srcEndpoint(), THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID, attrId, attr.numericValue());\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        if (stateUpdated)\n        {\n            sensor->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n        }\n\n        if (configUpdated || stateUpdated)\n        {\n            updateSensorEtag(&*sensor);\n            sensor->setNeedSaveDatabase(true);\n            queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n        }\n    }\n}\n\n/*! Write Attribute on thermostat ui configuration cluster.\n   \\param task - the task item\n   \\param attrId\n   \\param attrType\n   \\param attrValue\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskThermostatUiConfigurationReadWriteAttribute(TaskItem &task, uint8_t readOrWriteCmd, uint16_t attrId, uint8_t attrType, uint32_t attrValue, uint16_t mfrCode)\n{\n    if (readOrWriteCmd != deCONZ::ZclReadAttributesId && readOrWriteCmd != deCONZ::ZclWriteAttributesId)\n    {\n        DBG_Printf(DBG_INFO, \"Thermostat invalid parameter readOrWriteCmd %d\\n\", readOrWriteCmd);\n        return false;\n    }\n\n    task.taskType = TaskThermostat;\n\n    task.req.setClusterId(THERMOSTAT_UI_CONFIGURATION_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(readOrWriteCmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n            deCONZ::ZclFCDirectionClientToServer |\n            deCONZ::ZclFCDisableDefaultResponse);\n\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    if (readOrWriteCmd == deCONZ::ZclWriteAttributesId)\n    {\n        stream << attrId;\n        stream << attrType;\n\n        deCONZ::ZclAttribute attr(attrId, attrType, QLatin1String(\"\"), deCONZ::ZclWrite, true);\n\n        attr.setValue(QVariant(attrValue));\n\n        if (!attr.writeToStream(stream))\n        {\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "thermostat_ui_configuration.h",
          "type": "blob",
          "size": 0.1845703125,
          "content": "#ifndef THERMOSTAT_UI_CONFIGURATION_H\n#define THERMOSTAT_UI_CONFIGURATION_H\n\n#define THERM_UI_ATTRID_KEYPAD_LOCKOUT                          0x0001\n\n#endif // THERMOSTAT_UI_CONFIGURATION_H\n"
        },
        {
          "name": "time.cpp",
          "type": "blob",
          "size": 17.05859375,
          "content": "/*\n * time.cpp\n *\n * Full implementation of Time cluster server.\n * Send ZCL attribute response to read request on Time Cluster attributes.\n *\n * 0x0000 Time         / UTC Time seconds from 1/1/2000\n * 0x0001 TimeStatus   / Master(bit-0)=1, Superseding(bit-3)= 1, MasterZoneDst(bit-2)=1\n * 0x0002 TimeZone     / offset seconds from UTC\n * 0x0003 DstStart     / daylight savings time start\n * 0x0004 DstEnd       / daylight savings time end\n * 0x0005 DstShift     / daylight savings offset\n * 0x0006 StandardTime / StandardTime = Time + TimeZone\n * 0x0007 LocalTime    / LocalTime = StandardTime (during winter time)\n *                       LocalTime = StandardTime + DstShift (during summer time)\n * 0x0008 LastSetTime\n * 0x0009 ValidUnilTime\n *\n */\n\n#include <QTimeZone>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n\nvoid getTime(quint32 *time, qint32 *tz, quint32 *dstStart, quint32 *dstEnd, qint32 *dstShift, quint32 *standardTime, quint32 *localTime, quint8 mode)\n{\n    const QDateTime now = QDateTime::currentDateTimeUtc();\n    const QDateTime yearStart(QDate(QDate::currentDate().year(), 1, 1), QTime(0, 0), Qt::UTC);\n    const QTimeZone timeZone(QTimeZone::systemTimeZoneId());\n\n    QDateTime epoch;\n\n    DBG_Assert(mode == UNIX_EPOCH || mode == J2000_EPOCH);\n    if (mode == UNIX_EPOCH)\n    {\n        epoch = QDateTime(QDate(1970, 1, 1), QTime(0, 0), Qt::UTC);\n    }\n    else if (mode == J2000_EPOCH)\n    {\n        epoch = QDateTime(QDate(2000, 1, 1), QTime(0, 0), Qt::UTC);;\n    }\n    else\n    {\n        return;\n    }\n\n    *time = *standardTime = *localTime = epoch.secsTo(now);\n    *tz = timeZone.offsetFromUtc(yearStart);\n    if (timeZone.hasTransitions())\n    {\n        const QTimeZone::OffsetData dstStartOffsetData = timeZone.nextTransition(yearStart);\n        const QTimeZone::OffsetData dstEndOffsetData = timeZone.nextTransition(dstStartOffsetData.atUtc);\n        *dstStart = epoch.secsTo(dstStartOffsetData.atUtc);\n        *dstEnd = epoch.secsTo(dstEndOffsetData.atUtc);\n        *dstShift = dstStartOffsetData.daylightTimeOffset;\n        *standardTime += *tz;\n        *localTime += *tz + ((*time >= *dstStart && *time <= *dstEnd) ? *dstShift : 0);\n    }\n}\n\n/*! Handle packets related to the ZCL Time cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the read attribute request\n */\nvoid DeRestPluginPrivate::handleTimeClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.commandId() == deCONZ::ZclReadAttributesId)\n    {\n           sendTimeClusterResponse(ind, zclFrame);\n    }\n    else\n    {\n        auto *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n        const bool devManaged = device && device->managed();\n\n        if (!devManaged)\n        {\n            Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHATime\"));\n\n            if (!sensor)\n            {\n                DBG_Printf(DBG_INFO, \"0x%016llX No sensor having time cluster found for endpoint: 0x%02X\\n\", ind.srcAddress().ext(), ind.srcEndpoint());\n                return;\n            }\n\n            bool isReadAttr = false;\n            bool isReporting = false;\n            bool isWriteResponse = false;\n\n            if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n            {\n                isReadAttr = true;\n            }\n            if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n            {\n                isReporting = true;\n            }\n            if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclWriteAttributesResponseId)\n            {\n                isWriteResponse = true;\n            }\n\n            // Read ZCL reporting and ZCL Read Attributes Response\n            if (isReadAttr || isReporting)\n            {\n                const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n                bool stateUpdated = false;\n                const QDateTime epoch = QDateTime(QDate(2000, 1, 1), QTime(0, 0), Qt::UTC);\n\n                QDataStream stream(zclFrame.payload());\n                stream.setByteOrder(QDataStream::LittleEndian);\n\n                while (!stream.atEnd())\n                {\n                    quint16 attrId;\n                    quint8 attrTypeId;\n\n                    stream >> attrId;\n                    if (isReadAttr)\n                    {\n                        quint8 status;\n                        stream >> status;  // Read Attribute Response status\n                        if (status != deCONZ::ZclSuccessStatus)\n                        {\n                            continue;\n                        }\n                    }\n                    stream >> attrTypeId;\n\n                    deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n                    if (!attr.readFromStream(stream))\n                    {\n                        continue;\n                    }\n\n                    switch (attrId)\n                    {\n                        case 0x0000: // Time (utc, in UTC)\n                        {\n                            QDateTime time = epoch.addSecs(attr.numericValue().u32);\n                            ResourceItem *item = sensor->item(RStateUtc);\n\n                            if (item && item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                            {\n                                item->setValue(time);\n                                enqueueEvent(Event(RSensors, RStateUtc, sensor->id(), item));\n                                stateUpdated = true;\n                            }\n\n                            const qint32 drift = QDateTime::currentDateTimeUtc().secsTo(time);\n                            DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: drift %d\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()), drift);\n\n                            if (drift < -10 || drift > 10)\n                            {\n                                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: drift: %d: set WRITE_TIME\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()), drift);\n                                sensor->setNextReadTime(WRITE_TIME, queryTime);\n                                sensor->setLastRead(WRITE_TIME, idleTotalCounter);\n                                sensor->enableRead(WRITE_TIME);\n                                queryTime = queryTime.addSecs(1);\n                            }\n                            else\n                            {\n                                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: NO CONSIDERABLE TIME DRIFT\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()));\n                            }\n\n                            sensor->setZclValue(updateType, ind.srcEndpoint(), TIME_CLUSTER_ID, attrId, attr.numericValue());\n                        }\n                            break;\n\n                        case 0x0007: // Local Time (u32, in local time)\n                        {\n                            QDateTime time = epoch.addSecs(attr.numericValue().u32 - QDateTime::currentDateTime().offsetFromUtc());\n                            ResourceItem *item = sensor->item(RStateLocaltime);\n\n                            if (item && item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                            {\n                                item->setValue(time);\n                                enqueueEvent(Event(RSensors, RStateLocaltime, sensor->id(), item));\n                                stateUpdated = true;\n                            }\n\n                            sensor->setZclValue(updateType, ind.srcEndpoint(), TIME_CLUSTER_ID, attrId, attr.numericValue());\n                        }\n                            break;\n\n                        case 0x0008: // Last set time (utc, in UTC)\n                        {\n                            QDateTime time = epoch.addSecs(attr.numericValue().u32);\n                            ResourceItem *item = sensor->item(RStateLastSet);\n\n                            if (item && item->toVariant().toDateTime().toMSecsSinceEpoch() != time.toMSecsSinceEpoch())\n                            {\n                                item->setValue(time);\n                                enqueueEvent(Event(RSensors, RStateLastSet, sensor->id(), item));\n                                stateUpdated = true;\n                            }\n\n                            sensor->setZclValue(updateType, ind.srcEndpoint(), TIME_CLUSTER_ID, attrId, attr.numericValue());\n                        }\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n\n                if (stateUpdated)\n                {\n                    sensor->updateStateTimestamp();\n                    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                    updateSensorEtag(&*sensor);\n                    sensor->setNeedSaveDatabase(true);\n                    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                }\n            }\n\n            // ZCL Write Attributes Response\n            if (isWriteResponse)\n            {\n                DBG_Printf(DBG_INFO, \"  >>> %s sensor %s: set READ_TIME from handleTimeClusterIndication()\\n\", qPrintable(sensor->type()), qPrintable(sensor->name()));\n                sensor->setNextReadTime(READ_TIME, queryTime);\n                sensor->setLastRead(READ_TIME, idleTotalCounter);\n                sensor->enableRead(READ_TIME);\n                queryTime = queryTime.addSecs(1);\n            }\n        }\n    }\n}\n\n/*! Sends read attributes response to Time client.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the read attributes request\n */\nvoid DeRestPluginPrivate::sendTimeClusterResponse(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    deCONZ::ApsDataRequest req;\n    deCONZ::ZclFrame outZclFrame;\n\n    req.setProfileId(ind.profileId());\n    req.setClusterId(ind.clusterId());\n    req.setDstAddressMode(ind.srcAddressMode());\n    req.dstAddress() = ind.srcAddress();\n    req.setDstEndpoint(ind.srcEndpoint());\n    req.setSrcEndpoint(endpoint());\n\n    outZclFrame.setSequenceNumber(zclFrame.sequenceNumber());\n    outZclFrame.setCommandId(deCONZ::ZclReadAttributesResponseId);\n\n    outZclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                deCONZ::ZclFCDirectionServerToClient |\n                                deCONZ::ZclFCDisableDefaultResponse);\n\n    quint32 time_now = 0xFFFFFFFF;              // id 0x0000 Time\n    qint8 time_status = 0x0D;                   // id 0x0001 TimeStatus Master|MasterZoneDst|Superseding\n    qint32 time_zone = 0xFFFFFFFF;              // id 0x0002 TimeZone\n    quint32 time_dst_start = 0xFFFFFFFF;        // id 0x0003 DstStart\n    quint32 time_dst_end = 0xFFFFFFFF;          // id 0x0004 DstEnd\n    qint32 time_dst_shift = 0xFFFFFFFF;         // id 0x0005 DstShift\n    quint32 time_std_time = 0xFFFFFFFF;         // id 0x0006 StandardTime\n    quint32 time_local_time = 0xFFFFFFFF;       // id 0x0007 LocalTime\n    quint32 time_valid_until_time = 0xFFFFFFFF; // id 0x0009 ValidUntilTime\n\n    getTime(&time_now, &time_zone, &time_dst_start, &time_dst_end, &time_dst_shift, &time_std_time, &time_local_time, J2000_EPOCH);\n    time_valid_until_time = time_now + (3600 * 24 * 30 * 12);\n\n    { // payload\n        QDataStream stream(&outZclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        QDataStream instream(zclFrame.payload());\n        instream.setByteOrder(QDataStream::LittleEndian);\n        quint8 code = 0x00; // success\n        quint16 attr;\n\n        while (!instream.atEnd())\n        {\n        \tinstream >> attr;\n        \tstream << attr;\n\n        \tswitch(attr)\n        \t{\n        \tcase 0x0000:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::ZclUtcTime;\n        \t\tstream << time_now;\n        \t\tbreak;\n\n        \tcase 0x0001:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl8BitBitMap;\n        \t\tstream << time_status;\n        \t\tbreak;\n\n        \tcase 0x0002:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl32BitInt;\n        \t\tstream << time_zone;\n        \t\tbreak;\n\n        \tcase 0x0003:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl32BitUint;\n        \t\tstream << time_dst_start;\n        \t\tbreak;\n\n        \tcase 0x0004:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl32BitUint;\n        \t\tstream << time_dst_end;\n        \t\tbreak;\n\n        \tcase 0x0005:\n           \t\tstream << code;\n           \t\tstream << (quint8) deCONZ::Zcl32BitInt;\n           \t\tstream << time_dst_shift;\n        \t\tbreak;\n\n        \tcase 0x0006:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl32BitUint;\n        \t\tstream << time_std_time;\n        \t\tbreak;\n\n        \tcase 0x0007:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::Zcl32BitUint;\n        \t\tstream << time_local_time;\n        \t\tbreak;\n\n        \tcase 0x0008:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::ZclUtcTime;\n        \t\tstream << time_now;\n        \t\tbreak;\n\n        \tcase 0x0009:\n        \t\tstream << code;\n        \t\tstream << (quint8) deCONZ::ZclUtcTime;\n        \t\tstream << time_valid_until_time;\n        \t\tbreak;\n\n        \tdefault:\n        \t{\n        \t\tstream << (quint8) 0x86;  // unsupported_attribute\n        \t}\n        \tbreak;\n        \t}\n        }\n    }\n\n    { // ZCL frame\n        QDataStream stream(&req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        outZclFrame.writeToStream(stream);\n    }\n\n    if (apsCtrlWrapper.apsdeDataRequest(req) != deCONZ::Success)\n    {\n        DBG_Printf(DBG_INFO, \"Time failed to send reponse\\n\");\n    }\n}\n\n/*! Get all available timezone identifiers.\n */\nQVariantList DeRestPluginPrivate::getTimezones()\n{\n    QVariantList list;\n    const auto tzs = QTimeZone::availableTimeZoneIds();\n\n    for (const QByteArray &tz : tzs)\n    {\n        list.append(tz);\n    }\n\n\treturn list;\n}\n\n/*! Sync a sensor's on-device real-time clock.\n * \\param sensor the ZHATime sensor\n */\nbool DeRestPluginPrivate::addTaskSyncTime(Sensor *sensor)\n{\n    if (!sensor || !sensor->isAvailable())\n    {\n        return false;\n    }\n\n    TaskItem task;\n    task.taskType = TaskSyncTime;\n\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstEndpoint(sensor->fingerPrint().endpoint);\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.dstAddress() = sensor->address();\n    task.req.setClusterId(TIME_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n    task.req.setSrcEndpoint(getSrcEndpoint(sensor, task.req));\n\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n\n    quint32 time_now = 0xFFFFFFFF;              // id 0x0000 Time\n    qint8 time_status = 0x02;                   // id 0x0001 TimeStatus Synchronized\n    qint32 time_zone = 0xFFFFFFFF;              // id 0x0002 TimeZone\n    quint32 time_dst_start = 0xFFFFFFFF;        // id 0x0003 DstStart\n    quint32 time_dst_end = 0xFFFFFFFF;          // id 0x0004 DstEnd\n    qint32 time_dst_shift = 0xFFFFFFFF;         // id 0x0005 DstShift\n    quint32 time_std_time = 0xFFFFFFFF;         // id 0x0006 StandardTime\n    quint32 time_local_time = 0xFFFFFFFF;       // id 0x0007 LocalTime\n    quint32 time_valid_until_time = 0xFFFFFFFF; // id 0x0009 ValidUntilTime\n\n    getTime(&time_now, &time_zone, &time_dst_start, &time_dst_end, &time_dst_shift, &time_std_time, &time_local_time, J2000_EPOCH);\n    time_valid_until_time = time_now + (3600 * 24);\n\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    stream << (quint16) 0x0000; // Time\n    stream << (quint8) deCONZ::ZclUtcTime;\n    stream << time_now;\n\n    stream << (quint16) 0x0001; // Time Status\n    stream << (quint8) deCONZ::Zcl8BitBitMap;\n    stream << time_status;\n\n    stream << (quint16) 0x0002; // Time Zone\n    stream << (quint8) deCONZ::Zcl32BitInt;\n    stream << time_zone;\n\n    stream << (quint16) 0x0003; // Dst Start\n    stream << (quint8) deCONZ::Zcl32BitUint;\n    stream << time_dst_start;\n\n    stream << (quint16) 0x0004; // Dst End\n    stream << (quint8) deCONZ::Zcl32BitUint;\n    stream << time_dst_end;\n\n    stream << (quint16) 0x0005; // Dst Shift\n    stream << (quint8) deCONZ::Zcl32BitInt;\n    stream << time_dst_shift;\n\n    stream << (quint16) 0x0009; // Valid Until Time\n    stream << (quint8) deCONZ::ZclUtcTime;\n    stream << time_valid_until_time;\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "tuya.cpp",
          "type": "blob",
          "size": 67.865234375,
          "content": "/*\n * tuya.cpp\n *\n * Implementation of Tuya cluster.\n *\n */\n\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"tuya.h\"\n#include \"product_match.h\"\n\n//***********************************************************************************\n\n// Value for dp_type\n// ------------------\n// 0x00 \tDP_TYPE_RAW \t?\n// 0x01 \tDP_TYPE_BOOL \t?\n// 0x02 \tDP_TYPE_VALUE \t4 byte unsigned integer\n// 0x03 \tDP_TYPE_STRING \tvariable length string\n// 0x04 \tDP_TYPE_ENUM \t1 byte enum\n// 0x05 \tDP_TYPE_FAULT \t1 byte bitmap (didn't test yet)\n\n// Value for dp_identifier (it s device dependent)\n//\n\n// Value For Various sensor\n// -------------------------\n// 0x03     Presence detection (with 0x04)\n// 0x65     Water leak (with 0x01)\n\n// List of tuya command\n// ---------------------\n// Cmd ID       Description\n// 0x01        Product Information Inquiry / Reporting\n// 0x02        Device Status Query / Report\n// 0x03        Zigbee Device Reset\n// 0x04        Order Issuance\n// 0x05        Status Report\n// 0x06        Status Search\n// 0x07        reserved\n// 0x08        Zigbee Device Functional Test\n// 0x09        Query key information (only scene switch devices are valid)\n// 0x0A        Scene wakeup command (only scene switch device is valid)\n// 0x0A-0x23   reserved\n// 0x24        Time synchronization\n\n//******************************************************************************************\n\n/*! Helper to generate a new task with new task and req id based on a reference */\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\n{\n    b.req.dstAddress() = a.req.dstAddress();\n    b.req.setDstAddressMode(a.req.dstAddressMode());\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\n    b.req.setDstEndpoint(a.req.dstEndpoint());\n    b.req.setRadius(a.req.radius());\n    b.req.setTxOptions(a.req.txOptions());\n    b.req.setSendDelay(a.req.sendDelay());\n    b.zclFrame.payload().clear();\n}\n\nbool UseTuyaCluster(const QString &manufacturer)\n{\n    // https://docs.tuya.com/en/iot/device-development/module/zigbee-module/zigbeetyzs11module?id=K989rik5nkhez\n    //_TZ3000 don't use tuya cluster\n    //_TYZB01 don't use tuya cluster\n    //_TYZB02 don't use tuya cluster\n    //_TZ3400 don't use tuya cluster\n\n    if (manufacturer.startsWith(QLatin1String(\"_TZE200_\")) || // Tuya clutster visible\n        manufacturer.startsWith(QLatin1String(\"Tuya_C_\")) ||  // Used by fake device\n        manufacturer.startsWith(QLatin1String(\"_TYST11_\")))   // Tuya cluster invisible\n    {\n        return true;\n    }\n    return false;\n}\n\n// Time sync command\n// https://developer.tuya.com/en/docs/iot/device-development/embedded-software-development/mcu-development-access/zigbee-general-solution/tuya-zigbee-module-uart-communication-protocol\nstatic void handleTuyaTimeSyncRequest(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    DBG_Printf(DBG_INFO, \"Tuya Time sync request: 0x%016llx\\n\", ind.srcAddress().ext());\n\n    quint16 seqno;\n\n    {\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::BigEndian);\n        stream >> seqno;\n    }\n\n    // This is disabled for the moment, need investigations\n    // It seem some device send a UnknowHeader = 0x0000\n    // it s always 0x0000 for device > gateway\n    // And always 0x0008 for gateway > device (0x0008 is the payload size)\n    //\n    //if (unknowHeader == 0x0000)\n    //{\n    //}\n\n    quint32 timeNow = 0xFFFFFFFF;              // id 0x0000 Time\n    qint32 timeZone = 0xFFFFFFFF;              // id 0x0002 TimeZone\n    quint32 timeDstStart = 0xFFFFFFFF;        // id 0x0003 DstStart\n    quint32 timeDstEnd = 0xFFFFFFFF;          // id 0x0004 DstEnd\n    qint32 timeDstShift = 0xFFFFFFFF;         // id 0x0005 DstShift\n    quint32 timeStdTime = 0xFFFFFFFF;         // id 0x0006 StandardTime\n    quint32 timeLocalTime = 0xFFFFFFFF;       // id 0x0007 LocalTime\n\n    getTime(&timeNow, &timeZone, &timeDstStart, &timeDstEnd, &timeDstShift, &timeStdTime, &timeLocalTime, UNIX_EPOCH);\n\n    QByteArray data;\n    QDataStream stream(&data, QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian);\n\n    stream << seqno;\n    stream << timeNow;       // UTC time\n    stream << timeLocalTime; // local time\n\n    plugin->sendTuyaCommand(ind, TUYA_TIME_SYNCHRONISATION, data);\n}\n\n/*! Handle packets related to Tuya 0xEF00 cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the scene cluster reponse\n\n    Taken from https://medium.com/@dzegarra/zigbee2mqtt-how-to-add-support-for-a-new-tuya-based-device-part-2-5492707e882d\n */\n\nvoid DeRestPluginPrivate::handleTuyaClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame, Device *device)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    if (zclFrame.commandId() == TUYA_TIME_SYNCHRONISATION)\n    {\n        handleTuyaTimeSyncRequest(ind, zclFrame);\n        return;\n    }\n\n    // Note(mpi) DDF devices that are using {\"parse\": \"fn\": \"tuya\"} are expected\n    // to not use this function other than for time sync.\n    if (device && device->managed())\n    {\n        // clumsy workaround to not interfere with DDF handlers\n        for (const Resource *r : device->subDevices())\n        {\n            for (int i = 0; i < r->itemCount(); i++)\n            {\n                if (r->itemForIndex(size_t(i))->parseFunction() == parseTuyaData)\n                {\n                    return;\n                }\n            }\n        }\n    }\n\n    bool update = false;\n\n    LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n    Sensor *sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n\n    if (!sensorNode && !lightNode)\n    {\n        return;\n    }\n    \n    QString productId;\n    if (lightNode)\n    {\n        productId = R_GetProductId(lightNode);\n    }\n    else\n    {\n        productId = R_GetProductId(sensorNode);\n    }\n    \n    DBG_Printf(DBG_INFO_L2, \"Tuya debug Request : Address 0x%016llX, Endpoint 0x%02X, Command 0x%02X, Payload %s\\n\", ind.srcAddress().ext(), ind.srcEndpoint(), zclFrame.commandId(), qPrintable(zclFrame.payload().toHex()));\n\n    if (zclFrame.commandId() == TUYA_REQUEST)\n    {\n        // 0x00 : TUYA_REQUEST > Used to send command, so not used here\n    }\n    else if (zclFrame.commandId() == TUYA_REPORTING || zclFrame.commandId() == TUYA_QUERY || zclFrame.commandId() == TUYA_STATUS_SEARCH)\n    {\n        // 0x01 : TUYA_REPORTING > Used to inform of changes in its state.\n        // 0x02 : TUYA_QUERY > Send after receiving a 0x00 command.\n        // 0x06 : TUYA_STATUS_SEARCH > kind of reporting.\n\n        if (zclFrame.payload().size() < 7)\n        {\n            DBG_Printf(DBG_INFO, \"Tuya : Payload too short\\n\");\n            return;\n        }\n\n        QDataStream stream(zclFrame.payload());\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        // \"dp\" field describes the action/message of a command frame and was composed by a type and an identifier\n        // Composed by a type (dp_type) and an identifier (dp_identifier), the identifier is device dependant.\n        // \"transid\" is just a \"counter\", a response will have the same transif than the command.\n        // \"Status\" and \"fn\" are always 0\n        // More explanations at top of file\n\n        quint8 status;\n        quint8 transid;\n        quint16 dp;\n        quint8 fn;\n        quint8 length = 0;\n        qint32 data = 0;\n\n        quint8 dp_type;\n        quint8 dp_identifier;\n        quint8 dummy = 0;\n\n        stream >> status;\n        stream >> transid;\n        stream >> dp;\n        stream >> fn;\n\n        //Convertion octet string to decimal value\n        stream >> length;\n\n        //security, it seem 4 is the maximum\n        if (length > 4)\n        {\n            DBG_Printf(DBG_INFO, \"Tuya : Schedule command\\n\");\n        }\n        else\n        {\n            for (; length > 0; length--)\n            {\n                stream >> dummy;\n                data = data << 8;\n                data = data + dummy;\n            }\n        }\n\n        //To be more precise\n        dp_identifier = (dp & 0xFF);\n        dp_type = ((dp >> 8) & 0xFF);\n\n        DBG_Printf(DBG_INFO, \"Tuya debug 4 : Address 0x%016llX Payload %s\\n\", ind.srcAddress().ext(), qPrintable(zclFrame.payload().toHex()));\n        DBG_Printf(DBG_INFO, \"Tuya debug 5 : Status: %u Transid: %u Dp: %u (0x%02X,0x%02X) Fn: %u Data %d\\n\", status, transid, dp, dp_type, dp_identifier, fn, data);\n\n        if (length > 4) //schedule command\n        {\n\n            // Monday = 64, Tuesday = 32, Wednesday = 16, Thursday = 8, Friday = 4, Saturday = 2, Sunday = 1\n            // If you want your schedule to run only on workdays, the value would be W124. (64+32+16+8+4 = 124)\n            // The API specifies 3 numbers, so a schedule that runs on Monday would be W064.\n            //\n            // Workday = W124\n            // Not working day = W003\n            // Saturday = W002\n            // Sunday = W001\n            // All days = W127\n\n            QString transitions;\n            \n            quint8 Scheduledatalength = zclFrame.payload().size() - 6;\n            quint8 blocklength = 0;\n            quint8 values_to_read = 0;\n\n            quint8 hour;\n            quint8 minut;\n            quint8 heatSetpoint;\n            \n            quint16 minut16;\n            quint16 heatSetpoint16;\n\n            quint8 part = 0;\n            QList<int> listday;\n            \n            switch (dp)\n            {\n                case 0x0070: //work days (6)\n                {\n                    part = 1;\n                    listday << 124;\n                    values_to_read = 3;\n                    blocklength = length / values_to_read;\n                }\n                break;\n                case 0x0071: // holiday = Not working day (6)\n                {\n                    part = 1;\n                    listday << 3;\n                    values_to_read = 3;\n                    blocklength = length / values_to_read;\n                }\n                break;\n                case 0x0065: // Moe thermostat W124 (4) + W002 (4) + W001 (4)\n                {\n                    part = length / 3;\n                    listday << 124 << 2 << 1;\n                    values_to_read = 3;\n                    blocklength = length / values_to_read;\n                }\n                break;\n                // Daily schedule (mode 8)(minut 16)(temperature 16)(minut 16)(temperature 16)(minut 16)(temperature 16)(minut 16)(temperature 16)\n                case 0x007B: // Sunday\n                case 0x007C: // Monday\n                case 0x007D: // Thuesday\n                case 0x007E: // Wednesday\n                case 0x007F: // Thursday\n                case 0x0080: // Friday\n                case 0x0081: // Saturday\n                {\n                    const std::array<int, 7> t = {1,64,32,46,8,4,2};\n                    part = 1;\n                    \n                    if (dp < 0x007B || (dp - 0x007B) >= static_cast<int>(t.size()))\n                    {\n                        DBG_Printf(DBG_INFO, \"Tuya unsupported daily schedule dp value: 0x%04X\\n\", dp);\n                        return; // bail out early\n                    }\n                    \n                    listday << t[dp - 0x007B];\n                    \n                    values_to_read = 2;\n                    blocklength = (length - 1) / values_to_read;\n                    \n                    quint8 mode;\n                    stream >> mode; // First octet is the mode\n                    Scheduledatalength-=1;\n                    \n                    break;\n\n                }\n                default:\n                {\n                    DBG_Printf(DBG_INFO, \"Tuya : Unknow Schedule mode\\n\");\n                }\n                break;\n            }\n            \n            //Sanitary check\n            if (Scheduledatalength < (part * blocklength * values_to_read))\n            {\n                DBG_Printf(DBG_INFO, \"Tuya : Schedule data error\\n\");\n                return;\n            }\n            \n            \n            for (; part > 0; part--)\n            {\n                for (; blocklength > 0; blocklength--)\n                {\n                    if (dp >= 0x007B && dp <= 0x0081)\n                    {\n                        stream >> minut16;\n                        stream >> heatSetpoint16;\n                        hour = static_cast<quint8>((minut16 / 60) & 0xff);\n                        minut = static_cast<quint8>((minut16 - 60 * hour) & 0xff);\n                        heatSetpoint = static_cast<quint8>((heatSetpoint16 / 10) & 0xff);\n                    }\n                    else\n                    {\n                        stream >> hour;\n                        stream >> minut;\n                        stream >> heatSetpoint;\n                    }\n\n                    transitions += QString(\"T%1:%2|%3\")\n                        .arg(hour, 2, 10, QChar('0'))\n                        .arg(minut, 2, 10, QChar('0'))\n                        .arg(heatSetpoint);\n\n                    if (part > 0 && listday.size() >= static_cast<int>(part))\n                    {\n                        updateThermostatSchedule(sensorNode, listday.at(part - 1), transitions);\n                    }\n                }\n            }\n\n            return;\n        }\n\n        // Sensor and light use same cluster, so need to make a choice for device that have both\n        // Some device have sensornode AND lightnode, so need to use the good one.\n        if (sensorNode && lightNode)\n        {\n            if (dp == 0x0215) // battery\n            {\n                lightNode = nullptr;\n            }\n\n            if (sensorNode->type() == QLatin1String(\"ZHAThermostat\"))\n            {\n                lightNode = nullptr;\n            }\n            if (productId == QLatin1String(\"NAS-AB02B0 Siren\"))\n            {\n                if (dp == 0x0168) // Siren alarm\n                {\n                    sensorNode = nullptr;\n                }\n                else\n                {\n                    lightNode = nullptr;\n                }\n            }\n        }\n\n        //Some device are more than 1 sensors for the same endpoint, so trying to take the good one\n        if (sensorNode && productId == QLatin1String(\"NAS-AB02B0 Siren\"))\n        {\n            switch (dp)\n            {\n                //temperature\n                case 0x0269:\n                {\n                    sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHATemperature\"));\n                }\n                break;\n                //Humidity\n                case 0x026A:\n                {\n                    sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAHumidity\"));\n                }\n                break;\n                default:\n                // All other are for the alarm sensor\n                {\n                    sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint(), QLatin1String(\"ZHAAlarm\"));\n                }\n                break;\n            }\n        }\n\n        //Some device have sensor created on other endpoint and other cluster but are using the endpoint 0x01 and the cluster 0xEF00\n        if (sensorNode && R_GetProductId(sensorNode) == QLatin1String(\"Tuya_SEN Multi-sensor\"))\n        {\n            switch (dp)\n            {\n                //temperature\n                case 0x026B:\n                {\n                    sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), 0x02, QLatin1String(\"ZHATemperature\"));\n                }\n                break;\n                //Humidity\n                case 0x026C:\n                {\n                    sensorNode = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), 0x02, QLatin1String(\"ZHAHumidity\"));\n                }\n                break;\n                default:\n                break;\n            }\n        }\n\n        if (lightNode)\n        {\n            //Window covering ?\n            if (productId.startsWith(QLatin1String(\"Tuya_COVD\")))\n            {\n                // This device don't use same command, so I m using this hack to keep an uniform code\n                if (productId == QLatin1String(\"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\"))\n                {\n                    if (dp == 0x0401)\n                    {\n                        if (data == 0x01) { data = 0x00; }\n                        else if (data == 0x00) { data = 0x01; }\n                    }\n                }\n\n                switch (dp)\n                {\n                    // 0x0407 > starting moving\n                    // 0x0105 > configuration done\n                    case 0x0401:\n                    {\n                        if (data == 0x02) //open\n                        {\n                            lightNode->setValue(RStateOpen, true);\n                            lightNode->setValue(RStateOn, false);\n                        }\n                        else if (data == 0x00) //close\n                        {\n                            lightNode->setValue(RStateOpen, false);\n                            lightNode->setValue(RStateOn, true);\n                        }\n                        else if (data == 0x01) //stop\n                        {\n                        }\n                    }\n                    break;\n                    case 0x0202: // going to position\n                    case 0x0203: // position reached (more usefull I think)\n                    {\n                        quint8 lift = static_cast<quint8>(data);\n                        \n                        // Need reverse\n                        if (productId.startsWith(QLatin1String(\"Tuya_COVD YS-MT750\")) ||\n                            productId.startsWith(QLatin1String(\"Tuya_COVD AM43-0.45/40-ES-EZ(TY)\")) ||\n                            productId.startsWith(QLatin1String(\"Tuya_COVD DS82\")))\n                        {\n                            lift = 100 - lift;\n                        }\n                        \n                        bool open = lift < 100;\n                        lightNode->setValue(RStateLift, lift);\n                        lightNode->setValue(RStateOpen, open);\n\n                        quint8 level = lift * 254 / 100;\n                        bool on = level > 0;\n                        lightNode->setValue(RStateBri, level);\n                        lightNode->setValue(RStateOn, on);\n                    }\n                    break;\n                    case 0x0405: // rotation direction\n                    {\n                        DBG_Printf(DBG_INFO, \"Tuya debug 3 : Covering motor direction %ld\\n\", data);\n                    }\n                    break;\n\n                    //other\n                    default:\n                    break;\n\n                }\n            }\n            //siren\n            else if (productId == QLatin1String(\"NAS-AB02B0 Siren\"))\n            {\n                if (dp == 0x0168)\n                {\n                    if (data == 0x00)\n                    {\n                        lightNode->setValue(RStateAlert, QString(\"none\"));\n                    }\n                    else\n                    {\n                        lightNode->setValue(RStateAlert, QString(\"lselect\"));\n                    }\n\n                     update = true;\n                }\n            }\n            else\n            {\n                // Switch device 1/2/3 gangs or dimmer\n                switch (dp)\n                {\n                    // State\n                    case 0x0101:\n                    case 0x0102:\n                    case 0x0103:\n                    {\n                        bool onoff = (data == 0) ? false : true;\n\n                        {\n                            uint ep = 0x01;\n                            if (dp == 0x0102) { ep = 0x02; }\n                            if (dp == 0x0103) { ep = 0x03; }\n\n                            LightNode *lightNode2 = lightNode;\n                            lightNode = getLightNodeForAddress(ind.srcAddress(), ep);\n\n                            if (!lightNode)\n                            {\n                                return;\n                            }\n\n                            //Find model id if missing (modelId().isEmpty ?) and complete it\n                            if (lightNode->modelId().isNull() || lightNode->manufacturer().isNull())\n                            {\n                                DBG_Printf(DBG_INFO, \"Tuya debug 10 : Updating model ID\\n\");\n                                if (!lightNode2->modelId().isNull())\n                                {\n                                    lightNode->setModelId(lightNode2->modelId());\n                                }\n                                if (lightNode2->manufacturer().startsWith(QLatin1String(\"_T\")))\n                                {\n                                    lightNode->setManufacturerName(lightNode2->manufacturer());\n                                }\n                            }\n\n                            ResourceItem *item = lightNode->item(RStateOn);\n                            if (item && item->toBool() != onoff)\n                            {\n                                item->setValue(onoff);\n                                Event e(RLights, RStateOn, lightNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n                    \n                    // Dimmer level for mode 1\n                    case 0x0202:\n                    {\n                        if (productId == QLatin1String(\"Tuya_DIMSWITCH Earda Dimmer\") ||\n                            productId == QLatin1String(\"Tuya_DIMSWITCH MS-105Z\") ||\n                            productId == QLatin1String(\"Tuya_DIMSWITCH EDM-1ZAA-EU\"))\n                        {\n                            const qint64 bri = data * 254 / 1000; // 0 to 1000 value\n                            \n                            ResourceItem *item = lightNode->item(RStateBri);\n                            if (item && item->toNumber() != bri)\n                            {\n                                item->setValue(bri);\n                                Event e(RLights, RStateBri, lightNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n                    // Dimmer level for mode 2\n                    case 0x0203:\n                    {\n                        if (productId == QLatin1String(\"Tuya_DIMSWITCH Not model found yet\"))\n                        {\n                            const qint64 bri = data * 254 / 1000; // 0 to 1000 value\n                            \n                            ResourceItem *item = lightNode->item(RStateBri);\n                            if (item && item->toNumber() != bri)\n                            {\n                                item->setValue(bri);\n                                Event e(RLights, RStateBri, lightNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n\n                    //other\n                    default:\n                    break;\n                }\n            }\n        }\n        else if (sensorNode)\n        {\n            //Special part just for siren\n            if (productId == QLatin1String(\"NAS-AB02B0 Siren\")) //siren\n            {\n                switch (dp)\n                {\n                    case 0x0171: // Alarm siren temperature\n                    {\n                        ResourceItem *item = sensorNode->item(RConfigPreset);\n                        \n                        if (item)\n                        {\n                            QString mode;\n                            if (data == 0)\n                            {\n                                if (item->toString() == \"both\")\n                                {\n                                    mode = QLatin1String(\"humidity\");\n                                }\n                                else\n                                {\n                                    mode = QLatin1String(\"off\");\n                                }\n                            }\n                            else if (data == 1)\n                            {\n                                if (item->toString() == \"humidity\")\n                                {\n                                    mode = QLatin1String(\"both\");\n                                }\n                                else\n                                {\n                                    mode = QLatin1String(\"temperature\");\n                                }\n                            }\n                            else\n                            {\n                                return;\n                            }\n\n                            if (item->toString() != mode)\n                            {\n                                update = true;\n                                \n                                item->setValue(mode);\n                                Event e(RSensors, RConfigPreset, sensorNode->id(), item);\n                                enqueueEvent(e);\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0172: // Alarm siren humidity\n                    {\n                        ResourceItem *item = sensorNode->item(RConfigPreset);\n                        \n                        if (item)\n                        {\n                            QString mode;\n                            if (data == 0)\n                            {\n                                if (item->toString() == \"both\")\n                                {\n                                    mode = QLatin1String(\"temperature\");\n                                }\n                                else\n                                {\n                                    mode = QLatin1String(\"off\");\n                                }\n                            }\n                            else if (data == 1)\n                            {\n                                if (item->toString() == \"temperature\")\n                                {\n                                    mode = QLatin1String(\"both\");\n                                }\n                                else\n                                {\n                                    mode = QLatin1String(\"humidity\");\n                                }\n                            }\n                            else\n                            {\n                                return;\n                            }\n\n                            if (item->toString() != mode)\n                            {\n                                update = true;\n                                \n                                item->setValue(mode);\n                                Event e(RSensors, RConfigPreset, sensorNode->id(), item);\n                                enqueueEvent(e);\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0269: // siren temperature\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10 + 200;\n                        ResourceItem *item = sensorNode->item(RStateTemperature);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RStateTemperature, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n\n                    }\n                    break;\n                    case 0x026A : // Siren Humidity\n                    {\n                        qint16 Hum = static_cast<qint16>(data & 0xFFFF) * 100;\n                        ResourceItem *item = sensorNode->item(RStateHumidity);\n\n                        if (item && item->toNumber() != Hum)\n                        {\n                            item->setValue(Hum);\n                            Event e(RSensors, RStateHumidity, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x026B : // min alarm temperature threshold\n                    {\n                        qint8 min = static_cast<qint8>(data & 0xFF);\n                        ResourceItem *item = sensorNode->item(RConfigTempMinThreshold);\n\n                        if (item && item->toNumber() != min)\n                        {\n                            item->setValue(min);\n                            Event e(RSensors, RConfigTempMinThreshold, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            \n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x026C : // max alarm temperature threshold\n                    {\n                        qint8 max = static_cast<qint8>(data & 0xFF);\n                        ResourceItem *item = sensorNode->item(RConfigTempMaxThreshold);\n\n                        if (item && item->toNumber() != max)\n                        {\n                            item->setValue(max);\n                            Event e(RSensors, RConfigTempMaxThreshold, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            \n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x026D : // min alarm humidity threshold\n                    {\n                        qint8 min = static_cast<qint8>(data & 0xFF);\n                        ResourceItem *item = sensorNode->item(RConfigHumiMinThreshold);\n\n                        if (item && item->toNumber() != min)\n                        {\n                            item->setValue(min);\n                            Event e(RSensors, RConfigHumiMinThreshold, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            \n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x026E : // max alarm humidity threshold\n                    {\n                        qint8 max = static_cast<qint8>(data & 0xFF);\n                        ResourceItem *item = sensorNode->item(RConfigHumiMaxThreshold);\n\n                        if (item && item->toNumber() != max)\n                        {\n                            item->setValue(max);\n                            Event e(RSensors, RConfigHumiMaxThreshold, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            \n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x0466 : // melody\n                    {\n                        quint8 melody = static_cast<qint8>(data & 0xFF);\n\n                        ResourceItem *item = sensorNode->item(RConfigMelody);\n\n                        if (item && item->toNumber() != melody)\n                        {\n                            item->setValue(melody);\n                            enqueueEvent(Event(RSensors, RConfigMelody, sensorNode->id(), item));\n                            update = true;\n                        }\n                        \n                    }\n                    break;\n                    case 0x0474 : // volume\n                    {\n                        quint8 volume = static_cast<qint8>(data & 0xFF);\n\n                        ResourceItem *item = sensorNode->item(RConfigVolume);\n\n                        if (item && item->toNumber() != volume)\n                        {\n                            item->setValue(volume);\n                            enqueueEvent(Event(RSensors, RConfigVolume, sensorNode->id(), item));\n                            update = true;\n                        }\n                    }\n                    break;\n                    default:\n                    break;\n                }\n            }\n            else\n            {\n                // Generic part\n                switch (dp)\n                {\n                    case 0x0068: // window open information\n                    {\n                    }\n                    break;\n                    case 0x0101: // off / running for Moe, or state for other\n                    {\n                        QString mode;\n                        if      (data == 0) { mode = QLatin1String(\"off\"); }\n                        else if (data == 1) { mode = QLatin1String(\"heat\"); }\n                        else\n                        {\n                            return;\n                        }\n\n                        ResourceItem *item = sensorNode->item(RConfigMode);\n\n                        if (item && item->toString() != mode)\n                        {\n                            item->setValue(mode);\n                            enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                        }\n                    }\n                    break;\n                    case 0x0104: // Boost on Moes\n                    {\n                        if (productId == \"Tuya_THD BRT-100\")\n                        {\n                            QString preset;\n                            if (data == 0) { preset = QLatin1String(\"manual\"); } //stop boosting\n                            else { preset = QLatin1String(\"boost\"); } //start boosting\n\n                            ResourceItem *item = sensorNode->item(RConfigPreset);\n\n                            if (item && item->toString() != preset && preset == QLatin1String(\"boost\"))\n                            {\n                                // only change preset if it's not boosting or was boosting before\n                                if (preset == QLatin1String(\"boost\") || item->toString() == QLatin1String(\"boost\"))\n                                {\n                                    item->setValue(preset);\n                                    enqueueEvent(Event(RSensors, RConfigPreset, sensorNode->id(), item));\n                                }\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0107 : // Childlock status\n                    {\n                        bool locked = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RConfigLocked);\n\n                        if (item && item->toBool() != locked)\n                        {\n                            item->setValue(locked);\n                            Event e(RSensors, RConfigLocked, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0108 : // Woox test alarm\n                    {\n                        bool fire = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RStateFire);\n\n                        if (item && item->toBool() != fire)\n                        {\n                            item->setValue(fire);\n                            Event e(RSensors, RStateFire, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n\t\t\t\t\tcase 0x010D : // Childlock status for BRT-100\n                    {\n                        bool locked = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RConfigLocked);\n\n                        if (item && item->toBool() != locked)\n                        {\n                            item->setValue(locked);\n                            Event e(RSensors, RConfigLocked, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x010E : // Woox Low Battery\n                    {\n                        bool lowbat = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RStateLowBattery);\n\n                        if (item && item->toBool() != lowbat)\n                        {\n                            item->setValue(lowbat);\n                            Event e(RSensors, RStateLowBattery, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0112 : // Window open status\n                    {\n                        bool winopen = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RConfigWindowOpen);\n\n                        if (item && item->toBool() != winopen)\n                        {\n                            item->setValue(winopen);\n                            Event e(RSensors, RConfigWindowOpen, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0114: // Valve state report : on / off\n                    {\n                        bool onoff = false;\n                        if (data == 1) { onoff = true; }\n\n                        ResourceItem *item = sensorNode->item(RConfigSetValve);\n\n                        if (item && item->toBool() != onoff)\n                        {\n                            item->setValue(onoff);\n                            Event e(RSensors, RConfigSetValve, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x011E :\n                    case 0x0128 : // Childlock status for moe\n                    {\n                        bool locked = (data == 0) ? false : true;\n                        ResourceItem *item = sensorNode->item(RConfigLocked);\n\n                        if (item && item->toBool() != locked)\n                        {\n                            item->setValue(locked);\n                            Event e(RSensors, RConfigLocked, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0165: // off / on > [off = off, on = heat] for Saswell devices\n                    {\n                        QString mode;\n                        if      (data == 0) { mode = QLatin1String(\"off\"); }\n                        else if (data == 1) { mode = QLatin1String(\"auto\"); }\n                        else\n                        {\n                            return;\n                        }\n\n                        ResourceItem *item = sensorNode->item(RConfigMode);\n\n                        if (item && item->toString() != mode && \n                           (mode == QLatin1String(\"off\") || item->toString() == QLatin1String(\"off\"))) // Only change if the state is off or become off\n                        {\n                            item->setValue(mode);\n                            enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x016A: // Away mode for Saswell\n                    {\n                        //bool away = false;\n                        //if (data == 1) { away = true; }\n                    }\n                    break;\n                    case 0x016c: // manual / auto : Schedule mode for Saswell devices\n                    {\n                        ResourceItem *item = sensorNode->item(RConfigMode);\n                        \n                        if (item)\n                        {\n                            QString mode;\n                            if      (data == 0) { mode = QLatin1String(\"heat\"); } // can be \"off\" or \"heat\"\n                            else if (data == 1) { mode = QLatin1String(\"auto\"); } // \"auto\" for sure\n                            else\n                            {\n                                return;\n                            }\n\n                            if (item->toString() != mode && \n                               (mode == QLatin1String(\"auto\") || item->toString() == QLatin1String(\"auto\"))) // Only change if the state is auto or become auto\n                            {\n                                item->setValue(mode);\n                                enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n                    case 0x016E: // Low battery\n                    {\n                        bool bat = false;\n                        if (data == 1) { bat = true; }\n\n                        ResourceItem *item = sensorNode->item(RStateLowBattery);\n\n                        if (item && item->toBool() != bat)\n                        {\n                            item->setValue(bat);\n                            Event e(RSensors, RStateLowBattery, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x0170: // Reporting\n                    {\n                        DBG_Printf(DBG_INFO, \"Tuya device 0x%016llX reporting status state : %ld\\n\", ind.srcAddress().ext(), data);\n                    }\n                    break;\n                    case 0x0202: // Thermostat heatsetpoint\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                        \n                        if (productId == \"Tuya_THD BRT-100\")\n                        {\n                            temp = temp * 10;\n                            \n                            //change the mode too ? only if temp <5°C change it to off\n                            ResourceItem *item = sensorNode->item(RConfigMode);\n\n                            if (temp <= 500) {\n                                QString mode = QLatin1String(\"off\");\n                                if (item && item->toString() != mode)\n                                {\n                                    item->setValue(mode);\n                                    enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                                }\n                            }\n                        }\n                        \n                        ResourceItem *item = sensorNode->item(RConfigHeatSetpoint);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            enqueueEvent(Event(RSensors, RConfigHeatSetpoint, sensorNode->id(), item));\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x0203: // Thermostat current temperature\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                        ResourceItem *item = sensorNode->item(RStateTemperature);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RStateTemperature, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x0210: // Thermostat heatsetpoint for moe\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 100;\n                        \n                        if (productId == \"Tuya_THD MOES TRV\")\n                        {\n                            temp = static_cast<qint16>(data & 0xFFFF) * 100 / 2;\n                        }\n                        \n                        ResourceItem *item = sensorNode->item(RConfigHeatSetpoint);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RConfigHeatSetpoint, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x020E: // battery\n                    case 0x0215: // battery\n                    {\n                        quint8 bat = static_cast<qint8>(data & 0xFF);\n                        if (bat > 100) { bat = 100; }\n                        ResourceItem *item = sensorNode->item(RConfigBattery);\n\n                        if (!item && bat > 0) // valid value: create resource item\n                        {\n                            item = sensorNode->addItem(DataTypeUInt8, RConfigBattery);\n                        }\n\n                        if (item && item->toNumber() != bat)\n                        {\n                            item->setValue(bat);\n                            Event e(RSensors, RConfigBattery, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0218: // Thermostat current temperature for moe\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                        ResourceItem *item = sensorNode->item(RStateTemperature);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RStateTemperature, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x021B : // temperature calibration (offset in degree) for Moes and Saswell\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF);\n                        \n                        if (productId == \"Tuya_THD BTH-002 Thermostat\") // Only Moes\n                        {\n                            if (temp > 2048)\n                            {\n                                temp = temp - 4096;\n                            }\n                        }\n                        \n                        temp = temp * 100;\n                        \n                        ResourceItem *item = sensorNode->item(RConfigOffset);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RConfigOffset, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x022c : // temperature calibration (offset in degree)\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                        ResourceItem *item = sensorNode->item(RConfigOffset);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RConfigOffset, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n                    case 0x0266: // min temperature limit\n                    {\n                        //Can be Temperature for some device\n                        if (productId == \"Tuya_THD SEA801-ZIGBEE TRV\" ||\n                            productId == \"Tuya_THD Smart radiator TRV\" ||\n                            productId == \"Tuya_THD WZB-TRVL TRV\")\n                        {\n                            qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                            ResourceItem *item = sensorNode->item(RStateTemperature);\n\n                            if (item && item->toNumber() != temp)\n                            {\n                                item->setValue(temp);\n                                Event e(RSensors, RStateTemperature, sensorNode->id(), item);\n                                enqueueEvent(e);\n\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0267: // max temperature limit\n                    {\n                        //can be setpoint for some device\n                        if (productId == \"Tuya_THD SEA801-ZIGBEE TRV\" ||\n                            productId == \"Tuya_THD Smart radiator TRV\" ||\n                            productId == \"Tuya_THD WZB-TRVL TRV\")\n                        {\n                            qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                            ResourceItem *item = sensorNode->item(RConfigHeatSetpoint);\n\n                            if (item && item->toNumber() != temp)\n                            {\n                                item->setValue(temp);\n                                Event e(RSensors, RConfigHeatSetpoint, sensorNode->id(), item);\n                                enqueueEvent(e);\n\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0268 : // Valve position in % for Moe\n                    {\n                        quint8 valve = static_cast<qint8>(data & 0xFF);\n\n                        ResourceItem *item = sensorNode->item(RStateValve);\n                        if (item && item->toNumber() != valve)\n                        {\n                            item->setValue(valve);\n                            enqueueEvent(Event(RSensors, RStateValve, sensorNode->id(), item));\n                        }\n                    }\n                    break;\n                    case 0x0269: // Boost time in second or Heatpoint\n                    {\n                        if (productId == \"Tuya_THD MOES TRV\")\n                        {\n                            qint16 temp = static_cast<qint16>(data & 0xFFFF) * 100 / 2;\n   \n                            ResourceItem *item = sensorNode->item(RConfigHeatSetpoint);\n\n                            if (item && item->toNumber() != temp)\n                            {\n                                item->setValue(temp);\n                                Event e(RSensors, RConfigHeatSetpoint, sensorNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n                    case 0x026B: // Temperature for Multi sensor\n                    {\n                        if (productId == \"Tuya_SEN Multi-sensor\")\n                        {\n                            qint16 temp = static_cast<qint16>(data & 0xFFFF) * 10;\n                            ResourceItem *item = sensorNode->item(RStateTemperature);\n\n                            if (item && item->toNumber() != temp)\n                            {\n                                item->setValue(temp);\n                                Event e(RSensors, RStateTemperature, sensorNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                    }\n                    break;\n                    case 0x026C: // Humidity\n                    {\n                        qint16 temp = static_cast<qint16>(data & 0xFFFF) * 100;\n                        ResourceItem *item = sensorNode->item(RStateHumidity);\n\n                        if (item && item->toNumber() != temp)\n                        {\n                            item->setValue(temp);\n                            Event e(RSensors, RStateHumidity, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x026D : // Valve position in %\n                    {\n                        quint8 valve = static_cast<qint8>(data & 0xFF);\n                        bool on = valve > 3;\n\n                        ResourceItem *item = sensorNode->item(RStateOn);\n                        if (item)\n                        {\n                            if (item->toBool() != on)\n                            {\n                                item->setValue(on);\n                                enqueueEvent(Event(RSensors, RStateOn, sensorNode->id(), item));\n                            }\n                        }\n                        item = sensorNode->item(RStateValve);\n                        if (item && item->toNumber() != valve)\n                        {\n                            item->setValue(valve);\n                            enqueueEvent(Event(RSensors, RStateValve, sensorNode->id(), item));\n                        }\n                    }\n                    break;\n                    case 0x0401: // Preset for Moes or Alamr for Woox\n                        if (productId == \"Tuya_OTH R7049 Smoke Alarm\")\n                        {\n                            bool fire = (data == 0) ? true : false;\n                            ResourceItem *item = sensorNode->item(RStateFire);\n\n                            if (item && item->toBool() != fire)\n                            {\n                                item->setValue(fire);\n                                Event e(RSensors, RStateFire, sensorNode->id(), item);\n                                enqueueEvent(e);\n                                update = true;\n                            }\n                        }\n                        else if (productId == \"Tuya_THD BRT-100\")\n                        {\n                            QString mode;\n                            QString preset;\n                            if (data == 0) { //programming\n                                mode = QLatin1String(\"auto\");\n                                preset = QLatin1String(\"auto\");\n                            }\n                            else if (data == 1) { //manual\n                                mode = QLatin1String(\"heat\");\n                                preset = QLatin1String(\"manual\");\n                            }\n                            else if (data == 2) { //temporary_manual\n                                mode = QLatin1String(\"heat\");\n                                preset = QLatin1String(\"manual\");\n                            }\n                            //temporary_manual\n                            else if (data == 3) { //holiday\n                                mode = QLatin1String(\"auto\");\n                                preset = QLatin1String(\"holiday\");\n                            }\n                            else\n                            {\n                                return;\n                            }\n                            \n                            ResourceItem *item_mode = sensorNode->item(RConfigMode);\n\n                            if (item_mode && item_mode->toString() != mode)\n                            {\n                                item_mode->setValue(mode);\n                                enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item_mode));\n                            }\n\n                            ResourceItem *item_preset = sensorNode->item(RConfigPreset);\n\n                            if (item_preset && item_preset->toString() != preset)\n                            {\n                                item_preset->setValue(preset);\n                                enqueueEvent(Event(RSensors, RConfigPreset, sensorNode->id(), item_preset));\n                            }\n                        }\n                    break;\n                    case 0x0402 : // preset for moe or mode\n                    case 0x0403 : // preset for moe\n                    {\n                        if (productId == \"Tuya_THD MOES TRV\")\n                        {\n                            QString mode;\n                            if (data == 0) { mode = QLatin1String(\"auto\"); } //schedule\n                            else if (data == 1) { mode = QLatin1String(\"heat\"); } //manual\n                            else if (data == 2) { mode = QLatin1String(\"off\"); } //away\n                            else\n                            {\n                                return;\n                            }\n                            \n                            ResourceItem *item = sensorNode->item(RConfigMode);\n\n                            if (item && item->toString() != mode)\n                            {\n                                item->setValue(mode);\n                                enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                            }\n                        }\n                        else\n                        {\n                            QString preset;\n                            if (dp == 0x0402) { preset = QLatin1String(\"auto\"); }\n                            else if (dp == 0x0403) { preset = QLatin1String(\"program\"); }\n                            else\n                            {\n                                return;\n                            }\n\n                            ResourceItem *item = sensorNode->item(RConfigPreset);\n\n                            if (item && item->toString() != preset)\n                            {\n                                item->setValue(preset);\n                                enqueueEvent(Event(RSensors, RConfigPreset, sensorNode->id(), item));\n                            }\n                        }\n                    }\n                    break;\n                    case 0x0404 : // preset\n                    {\n                        QString preset;\n                        if (data == 0) { preset = QLatin1String(\"holiday\"); }\n                        else if (data == 1) { preset = QLatin1String(\"auto\"); }\n                        else if (data == 2) { preset = QLatin1String(\"manual\"); }\n                        else if (data == 3) { preset = QLatin1String(\"comfort\"); }\n                        else if (data == 4) { preset = QLatin1String(\"eco\"); }\n                        else if (data == 5) { preset = QLatin1String(\"boost\"); }\n                        else if (data == 6) { preset = QLatin1String(\"complex\"); }\n                        else\n                        {\n                            return;\n                        }\n\n                        ResourceItem *item = sensorNode->item(RConfigPreset);\n\n                        if (item && item->toString() != preset)\n                        {\n                            item->setValue(preset);\n                            enqueueEvent(Event(RSensors, RConfigPreset, sensorNode->id(), item));\n                        }\n                    }\n                    break;\n                    case 0x0407 : // valve open / closed for Moes\n                    {\n                        bool on = data < 0x01; // 0x01 = off, 0x00 = on\n\n                        ResourceItem *item = sensorNode->item(RStateOn);\n                        if (item)\n                        {\n                            if (item->toBool() != on)\n                            {\n                                item->setValue(on);\n                                enqueueEvent(Event(RSensors, RStateOn, sensorNode->id(), item));\n                            }\n                        }\n                    }\n                    break;\n                    case 0x040E: // Low battery\n                    {\n                        // 2 above 2,8v\n                        // 1 above 2.6v\n                        // 0 at 2.6v and below (beeps ocassionally)\n\n                        bool lowbat = true;\n                        if (data == 2) { lowbat = false; }\n\n                        ResourceItem *item = sensorNode->item(RStateLowBattery);\n\n                        if (item && item->toBool() != lowbat)\n                        {\n                            item->setValue(lowbat);\n                            Event e(RSensors, RStateLowBattery, sensorNode->id(), item);\n                            enqueueEvent(e);\n                            update = true;\n                        }\n                    }\n                    break;\n                    case 0x046a : // Force mode : normal/open/close\n                    {\n                        QString mode;\n                        if (data == 0) { mode = QLatin1String(\"auto\"); }\n                        else if (data == 1) { mode = QLatin1String(\"heat\"); }\n                        else if (data == 2) { mode = QLatin1String(\"off\"); }\n                        else\n                        {\n                            return;\n                        }\n\n                        ResourceItem *item = sensorNode->item(RConfigMode);\n\n                        if (item && item->toString() != mode)\n                        {\n                            item->setValue(mode);\n                            enqueueEvent(Event(RSensors, RConfigMode, sensorNode->id(), item));\n                        }\n                    }\n                    break;\n                    case 0x0569 : // Low battery\n                    {\n                        bool bat = false;\n                        if (data == 1) { bat = true; }\n\n                        ResourceItem *item = sensorNode->item(RStateLowBattery);\n\n                        if (item && item->toBool() != bat)\n                        {\n                            item->setValue(bat);\n                            Event e(RSensors, RStateLowBattery, sensorNode->id(), item);\n                            enqueueEvent(e);\n                        }\n                    }\n                    break;\n\n                    default:\n                    break;\n                }\n            }\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"Tuya debug 6 : No device found\\n\");\n        }\n\n    }\n    else\n    {\n        return;\n    }\n\n    if (update)\n    {\n        if (lightNode)\n        {\n            // Update Node light\n            updateLightEtag(&*lightNode);\n            lightNode->setNeedSaveDatabase(true);\n            saveDatabaseItems |= DB_LIGHTS;\n        }\n        if (sensorNode)\n        {\n            updateSensorEtag(&*sensorNode);\n\n            sensorNode->updateStateTimestamp();\n            enqueueEvent(Event(RSensors, RStateLastUpdated, sensorNode->id()));\n\n            sensorNode->setNeedSaveDatabase(true);\n        }\n    }\n\n}\n\nbool DeRestPluginPrivate::sendTuyaRequestThermostatSetWeeklySchedule(TaskItem &taskRef, quint8 weekdays, const QString &transitions, qint8 Dp_identifier)\n{\n    QByteArray data;\n\n    const QStringList list = transitions.split(\"T\", SKIP_EMPTY_PARTS);\n\n    quint8 hh;\n    quint8 mm;\n    quint8 heatSetpoint;\n\n    if (Dp_identifier == DP_IDENTIFIER_THERMOSTAT_SCHEDULE_1)\n    {\n        //To finish\n    }\n    else if (Dp_identifier == DP_IDENTIFIER_THERMOSTAT_SCHEDULE_4)\n    {\n        //To finish\n    }\n    else\n    {\n        if (weekdays == 3)\n        {\n            Dp_identifier = DP_IDENTIFIER_THERMOSTAT_SCHEDULE_3;\n        }\n        if (list.size() != 6)\n        {\n            DBG_Printf(DBG_INFO, \"Tuya : Schedule command error, need to have 6 values\\n\");\n        }\n    }\n\n    for (const QString &entry : list)\n    {\n        QStringList attributes = entry.split(\"|\");\n        if (attributes.size() != 2)\n        {\n            return false;\n        }\n        hh = attributes.at(0).midRef(0, 2).toUInt();\n        mm = attributes.at(0).midRef(3, 2).toUInt();\n        heatSetpoint = attributes.at(1).toInt();\n\n        data.append(QByteArray::number(hh, 16));\n        data.append(QByteArray::number(mm, 16));\n        data.append(QByteArray::number(heatSetpoint, 16));\n    }\n\n    return sendTuyaRequest(taskRef, TaskThermostat, DP_TYPE_RAW, Dp_identifier, data);\n}\n\nbool DeRestPluginPrivate::sendTuyaRequest(deCONZ::Address srcAddress, quint8 srcEndpoint, qint8 Dp_type, qint8 Dp_identifier, const QByteArray &data)\n{\n    TaskItem task;\n\n    task.req.dstAddress() = srcAddress;\n    task.req.setTxOptions(deCONZ::ApsTxAcknowledgedTransmission);\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.setDstEndpoint(srcEndpoint);\n    task.req.setSrcEndpoint(endpoint());\n\n    return sendTuyaRequest(task, TaskTuyaRequest, Dp_type, Dp_identifier, data);\n}\n\n//\n// Tuya Devices\n//\nbool DeRestPluginPrivate::sendTuyaRequest(TaskItem &taskRef, TaskType taskType, qint8 Dp_type, qint8 Dp_identifier, const QByteArray &data)\n{\n    DBG_Printf(DBG_INFO, \"Send Tuya request 0x%016llX : Dp_type: 0x%02X, Dp_identifier 0x%02X, data: %s\\n\", taskRef.req.dstAddress().ext(), Dp_type, Dp_identifier, qPrintable(data.toHex()));\n    \n    const quint8 seq = zclSeq++;\n\n    TaskItem task;\n    copyTaskReq(taskRef, task);\n\n    //Tuya task\n    task.taskType = taskType;\n\n    task.req.setClusterId(TUYA_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(seq);\n    task.zclFrame.setCommandId(0x00); // Command 0x00\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand | deCONZ::ZclFCDirectionClientToServer | deCONZ::ZclFCDisableDefaultResponse);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian); // TODO(mpi): should be big endian for Tuya\n\n    stream << static_cast<qint8>(0x00);          // Status always 0x00\n    stream << static_cast<qint8>(seq);           // TransID, use seq\n    stream << static_cast<qint8>(Dp_identifier); // Dp_indentifier\n    stream << static_cast<qint8>(Dp_type);       // Dp_type\n    // TODO(mpi): there is no Fn field, length is 16-bit and big endian, that's why the first byte is always 0x00\n    stream << static_cast<qint8>(0x00);          // Fn, always 0\n    // Data\n    // TODO(mpi): we should replace QByteArray data with int and write data and length according Dp_type\n    stream << static_cast<qint8>(data.length()); // length (can be 0 for Dp_identifier = enums)\n    for (int i = 0; i < data.length(); i++)\n    {\n        stream << static_cast<quint8>(data[i]);\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    if (!addTask(task))\n    {\n        return false;\n    }\n\n    processTasks();\n\n    return true;\n}\n\nbool DeRestPluginPrivate::sendTuyaCommand(const deCONZ::ApsDataIndication &ind, qint8 commandId, const QByteArray &data)\n{\n    DBG_Printf(DBG_INFO, \"Send Tuya command 0x%02X, data: %s\\n\", commandId, qPrintable(data.toHex()));\n\n    TaskItem task;\n\n    //Tuya task\n    task.taskType = TaskTuyaRequest;\n\n    task.req.dstAddress() = ind.srcAddress();\n    task.req.setDstAddressMode(deCONZ::ApsExtAddress);\n    task.req.setDstEndpoint(ind.srcEndpoint());\n    task.req.setSrcEndpoint(endpoint());\n    task.req.setClusterId(TUYA_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(commandId); // Command\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    // Data\n    for (int i = 0; i < data.length(); i++)\n    {\n        stream << static_cast<quint8>(data[i]);\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    if (!addTask(task))\n    {\n        DBG_Printf(DBG_INFO, \"Failed to send Tuya command 0x%02X, data: %s\\n\", commandId, qPrintable(data.toHex()));\n        return false;\n    }\n\n    processTasks();\n\n    return true;\n} \n"
        },
        {
          "name": "tuya.h",
          "type": "blob",
          "size": 5.001953125,
          "content": "/*\n * Copyright (c)2018-2021 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifndef TUYA_H\n#define TUYA_H\n\n// Value for dp_type\n// ------------------    \n// 0x00 \tDP_TYPE_RAW \t?\n// 0x01 \tDP_TYPE_BOOL \t?\n// 0x02 \tDP_TYPE_VALUE \t4 byte unsigned integer\n// 0x03 \tDP_TYPE_STRING \tvariable length string\n// 0x04 \tDP_TYPE_ENUM \t1 byte enum\n// 0x05 \tDP_TYPE_FAULT \t1 byte bitmap (didn't test yet)\n\n#define DP_TYPE_RAW 0x00\n#define DP_TYPE_BOOL 0x01\n#define DP_TYPE_VALUE 0x02\n#define DP_TYPE_STRING 0x03\n#define DP_TYPE_ENUM 0x04\n#define DP_TYPE_FAULT 0x05\n\n// Value for dp_identifier for different sensor\n//--------------------------------------------\n\n\n// Value for thermostat\n//---------------------\n\n// Value for thermostat\n//---------------------\n// 0x04     Preset\n// 0x6C     Auto / Manu\n// 0x65     Manu / Off\n// 0x6E     Low battery\n// 0x02     Actual temperature\n// 0x03     Thermostat temperature\n// 0x14     Valve\n// 0x15     Battery level\n// 0x6A     Mode\n\n#define DP_IDENTIFIER_WINDOW_OPEN 0x12\n#define DP_IDENTIFIER_WINDOW_OPEN2 0x08\n#define DP_IDENTIFIER_THERMOSTAT_SCHEDULE_1 0x65 // Moe thermostat W124 (4) + W002 (4) + W001 (4)\n#define DP_IDENTIFIER_THERMOSTAT_SCHEDULE_2 0x70 // work days (6)\n#define DP_IDENTIFIER_THERMOSTAT_SCHEDULE_3 0x71 // holiday = Not working day (6)\n#define DP_IDENTIFIER_THERMOSTAT_SCHEDULE_4 0x6D // Not finished\n#define DP_IDENTIFIER_THERMOSTAT_SCHEDULE_ENABLE 0x6C // Enable schedule mode for Saswell\n\n#define DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT 0x02 // Heatsetpoint\n#define DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_2 0x67 // Heatsetpoint for Moe\n#define DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_3 0x10 // Heatsetpoint for TRV_MOE mode heat\n#define DP_IDENTIFIER_THERMOSTAT_HEATSETPOINT_4 0x69 // Heatsetpoint for TRV_MOE mode auto\n#define DP_IDENTIFIER_THERMOSTAT_VALVE 0x14 // Valve\n#define DP_IDENTIFIER_THERMOSTAT_VALVE_2 0x68 // Valve\n#define DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_1 0x07\n#define DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_2 0x28\n#define DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_3 0x1E // For Moe device\n#define DP_IDENTIFIER_THERMOSTAT_CHILDLOCK_4 0x0D\n\n#define DP_IDENTIFIER_THERMOSTAT_MODE_1 0x6A // mode used with DP_TYPE_ENUM\n#define DP_IDENTIFIER_THERMOSTAT_MODE_2 0x02 // mode for Moe device used with DP_TYPE_ENUM\n#define DP_IDENTIFIER_THERMOSTAT_MODE_3 0x65 // mode for Saswell device used with DP_TYPE_BOOL\n#define DP_IDENTIFIER_THERMOSTAT_MODE_4 0x01 // mode for Moes device used with DP_TYPE_ENUM\n\n#define DP_IDENTIFIER_THERMOSTAT_BOOST 0x04 // Boost for Moes\n\n#define DP_IDENTIFIER_THERMOSTAT_CALIBRATION_1 0x1B // Calibration offset used by Moes and Saswell\n#define DP_IDENTIFIER_THERMOSTAT_CALIBRATION_2 0x2C // Calibration offset used by others\n\n// Value for dp_identifier for covering\n//-----------------------------------\n\n// Value for windows covering\n//-----------------------------------------------------\n// 0x01 \tcontrol         \tenum \topen, stop, close, continue\n// 0x02 \tpercent_control \tvalue \t0-100% control\n// 0x03 \tpercent_state \t    value \tReport from motor about current percentage\n// 0x04 \tcontrol_back     \tenum \tConfigures motor direction (untested)\n// 0x05 \twork_state       \tenum \tSupposedly shows if motor is opening or closing, always 0 for me though\n// 0x06 \tsituation_set \t    enum \tConfigures if 100% equals to fully closed or fully open (untested)\n// 0x07 \tfault           \tbitmap \tAnything but 0 means something went wrong (untested)\n\n#define DP_IDENTIFIER_CONTROL 0x01\n#define DP_IDENTIFIER_PERCENT_CONTROL 0x02\n#define DP_IDENTIFIER_POSITION_REACHED 0x03\n#define DP_IDENTIFIER_WORK_STATE 0x05\n#define DP_IDENTIFIER_POSITION_MOVING 0x07\n\n// Value for dp_identifier for switches\n//-----------------------------------\n#define DP_IDENTIFIER_BUTTON_1 0x01\n#define DP_IDENTIFIER_BUTTON_2 0x02\n#define DP_IDENTIFIER_BUTTON_3 0x03\n#define DP_IDENTIFIER_BUTTON_ALL 0x0D\n#define DP_IDENTIFIER_DIMMER_LEVEL_MODE1 0x03\n#define DP_IDENTIFIER_DIMMER_LEVEL_MODE2 0x02\n\n// Value for dp_identifier for siren\n//-----------------------------------\n#define DP_IDENTIFIER_MELODY 0x66\n#define DP_IDENTIFIER_ALARM 0x68\n#define DP_IDENTIFIER_TRESHOLDTEMPMINI 0x6B\n#define DP_IDENTIFIER_TRESHOLDTEMPMAXI 0x6C\n#define DP_IDENTIFIER_TRESHOLDTHUMIMINI 0x6D\n#define DP_IDENTIFIER_TRESHOLDHUMIMAXI 0x6E\n#define DP_IDENTIFIER_TEMPERATURE_ALARM 0x71\n#define DP_IDENTIFIER_HUMIDITY_ALARM 0x72\n#define DP_IDENTIFIER_VOLUME 0x74\n\n// Value for dp_identifier for sensor\n//-----------------------------------\n#define DP_IDENTIFIER_REPORTING_TIME 0x62\n#define DP_IDENTIFIER_TEMPERATURE 0x6B\n#define DP_IDENTIFIER_HUMIDITY 0x6C\n#define DP_IDENTIFIER_BATTERY 0x6E\n#define DP_IDENTIFIER_REPORTING 0x70\n\n// Value for tuya command\n//-----------------------\n#define TUYA_REQUEST 0x00\n#define TUYA_REPORTING 0x01\n#define TUYA_QUERY 0x02\n#define TUYA_STATUS_SEARCH 0x06\n#define TUYA_TIME_SYNCHRONISATION 0x24\n\nbool UseTuyaCluster(const QString &manufacturer);\n\n#endif // TUYA_H\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "upnp.cpp",
          "type": "blob",
          "size": 11.015625,
          "content": "/*\n * Copyright (c) 2016-2023 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n#include <QTextStream>\n#include <QTcpSocket>\n#include <QTimer>\n#include <QFile>\n#include <QUdpSocket>\n#include <QVariantMap>\n#include \"de_web_plugin_private.h\"\n#include \"gateway_scanner.h\"\n\n/*! Inits the UPnP discorvery. */\nvoid DeRestPluginPrivate::initUpnpDiscovery()\n{\n    DBG_Assert(udpSock == 0);\n\n    initDescriptionXml();\n\n    if (deCONZ::appArgumentNumeric(\"--upnp\", 1) == 0)\n    {\n        udpSock = 0;\n        joinedMulticastGroup = false;\n        return;\n    }\n\n    udpSock = new QUdpSocket(this);\n    joinedMulticastGroup = false;\n\n    connect(udpSock, SIGNAL(readyRead()),\n            this, SLOT(upnpReadyRead()));\n\n    upnpTimer = new QTimer(this);\n    upnpTimer->setSingleShot(false);\n    connect(upnpTimer, SIGNAL(timeout()),\n            this, SLOT(announceUpnp()));\n    upnpTimer->start(1000); // setup phase fast interval\n}\n\n/*! Replaces description_in.xml template with dynamic content. */\nvoid DeRestPluginPrivate::initDescriptionXml()\n{\n    if (!apsCtrl)\n    {\n        return;\n    }\n\n    QString serverRoot = apsCtrl->getParameter(deCONZ::ParamHttpRoot);\n\n    if (!serverRoot.isEmpty())\n    {\n        descriptionXml.clear();\n        QFile f(serverRoot + \"/description_in.xml\");\n\n        if (f.open(QFile::ReadOnly))\n        {\n            const QString gwPortStr = QString::number(gwPort);\n            const QString gwSerial = gwBridgeId.left(6) + gwBridgeId.right(6);\n\n            QTextStream stream(&f);\n            while (!stream.atEnd())\n            {\n                QString line = stream.readLine(320);\n\n                if (!line.isEmpty())\n                {\n                    line.replace(QLatin1String(\"{{IPADDRESS}}\"), gwIPAddress);\n                    line.replace(QLatin1String(\"{{PORT}}\"), gwPortStr);\n                    line.replace(QLatin1String(\"{{GWNAME}}\"), gwName);\n                    line.replace(QLatin1String(\"{{SERIAL}}\"), gwSerial);\n                    line.replace(QLatin1String(\"{{UUID}}\"), gwUuid);\n                    descriptionXml.append(line.toUtf8());\n                }\n            }\n        }\n    }\n}\n\n/*! Sends SSDP broadcast for announcement. */\nvoid DeRestPluginPrivate::announceUpnp()\n{\n    if (udpSock->state() != QAbstractSocket::BoundState)\n    {\n        joinedMulticastGroup = false;\n        DBG_Printf(DBG_ERROR, \"UPNP socket not bound, state: %d\\n\", udpSock->state());\n        // retry\n        if (!udpSock->bind(QHostAddress(\"0.0.0.0\"), 1900, QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint)) // SSDP\n        {\n            DBG_Printf(DBG_ERROR, \"UPNP error %s\\n\", qPrintable(udpSock->errorString()));\n        }\n        return;\n    }\n\n    if (!joinedMulticastGroup)\n    {\n        QHostAddress groupAddress(\"239.255.255.250\");\n        if (!udpSock->joinMulticastGroup(groupAddress))\n        {\n            DBG_Printf(DBG_ERROR, \"UPNP error %s\\n\", qPrintable(udpSock->errorString()));\n            return;\n        }\n        joinedMulticastGroup = true;\n    }\n\n    if (upnpTimer->interval() != (20 * 1000))\n        upnpTimer->start(20 * 1000);\n\n    QByteArray datagram = QString(QLatin1String(\n        \"NOTIFY * HTTP/1.1\\r\\n\"\n        \"HOST: 239.255.255.250:1900\\r\\n\"\n        \"CACHE-CONTROL: max-age=100\\r\\n\"\n        \"LOCATION: http://%1:%2/description.xml\\r\\n\"\n        \"SERVER: Linux/3.14.0 UPnP/1.0 IpBridge/1.26.0\\r\\n\"\n        \"GWID.phoscon.de: %3\\r\\n\"\n        \"hue-bridgeid: %3\\r\\n\"\n        \"NTS: ssdp:alive\\r\\n\"))\n            .arg(gwConfig[\"ipaddress\"].toString())\n            .arg(gwConfig[\"port\"].toDouble())\n            .arg(gwBridgeId.toUpper()).toLocal8Bit();\n    QByteArray nt1 = QString(QLatin1String(\n        \"NT: upnp:rootdevice\\r\\n\"\n        \"USN: uuid:%1::upnp:rootdevice\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n    QByteArray nt2 = QString(QLatin1String(\n        \"NT: uuid:%1\\r\\n\"\n        \"USN: uuid:%1\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n    QByteArray nt3 = QString(QLatin1String(\n        \"NT: urn:schemas-upnp-org:device:basic:1\\r\\n\"\n        \"USN: uuid:%1::urn:schemas-upnp-org:device:basic:1\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n\n    quint16 port = 1900;\n    QHostAddress host;\n    host.setAddress(QLatin1String(\"239.255.255.250\"));\n\n    if (udpSock->writeDatagram(datagram + nt1 + \"\\r\\n\", host, port) == -1)\n    {\n        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n    }\n    if (udpSock->writeDatagram(datagram + nt2 + \"\\r\\n\", host, port) == -1)\n    {\n        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n    }\n    if (udpSock->writeDatagram(datagram + nt3 + \"\\r\\n\", host, port) == -1)\n    {\n        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n    }\n}\n\n/*! Handles SSDP packets. */\nvoid DeRestPluginPrivate::upnpReadyRead()\n{\n    while (udpSock->hasPendingDatagrams())\n    {\n        quint16 port;\n        QHostAddress host;\n        QByteArray datagram;\n        datagram.resize(udpSock->pendingDatagramSize());\n        udpSock->readDatagram(datagram.data(), datagram.size(), &host, &port);\n\n        QTextStream stream(datagram);\n        enum ST { SearchTargetOther, SearchTargetAll, SearchTargetRoot, SearchTargetUUID, SearchTargetBasic };\n        ST st = SearchTargetOther;\n        QString location;\n        QString gwid;\n\n        if (DBG_IsEnabled(DBG_HTTP))\n        {\n            DBG_Printf(DBG_HTTP, \"%s\\n\", qPrintable(datagram));\n        }\n\n        if (datagram.startsWith(\"M-SEARCH *\"))\n        {\n            while (!stream.atEnd())\n            {\n                QString line = stream.readLine();\n                if (line.startsWith(QLatin1String(\"ST:\")))\n                {\n                    if (line.contains(QLatin1String(\"ssdp:all\")))\n                    {\n                        st = SearchTargetAll;\n                        break;\n                    }\n                    else if (line.contains(QLatin1String(\"upnp:rootdevice\")))\n                    {\n                        st = SearchTargetRoot;\n                        break;\n                    }\n                    else if (line.contains(QString(QLatin1String(\"ST: uuid:%1\")).arg(gwConfig[\"uuid\"].toString())))\n                    {\n                        st = SearchTargetUUID;\n                        break;\n                    }\n                    else if (line.contains(QLatin1String(\"urn:schemas-upnp-org:device:basic:1\")))\n                    {\n                        st = SearchTargetBasic;\n                        break;\n                    }\n                }\n            }\n\n            if (st != SearchTargetOther)\n            {\n                QByteArray response = QString(QLatin1String(\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"CACHE-CONTROL: max-age=100\\r\\n\"\n                    \"EXT:\\r\\n\"\n                    \"LOCATION: http://%1:%2/description.xml\\r\\n\"\n                    \"SERVER: Linux/3.14.0 UPnP/1.0 IpBridge/1.26.0\\r\\n\"\n                    \"GWID.phoscon.de: %3\\r\\n\"\n                    \"hue-bridgeid: %3\\r\\n\"))\n                        .arg(gwConfig[\"ipaddress\"].toString())\n                        .arg(gwConfig[\"port\"].toDouble())\n                        .arg(gwBridgeId.toUpper()).toLocal8Bit();\n                QByteArray st1 = QString(QLatin1String(\n                    \"ST: upnp:rootdevice\\r\\n\"\n                    \"USN: uuid:%1::upnp:rootdevice\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n                QByteArray st2 = QString(QLatin1String(\n                    \"ST: uuid:%1\\r\\n\"\n                    \"USN: uuid:%1\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n                QByteArray st3 = QString(QLatin1String(\n                    \"ST: urn:schemas-upnp-org:device:basic:1\\r\\n\"\n                    \"USN: uuid:%1::urn:schemas-upnp-org:device:basic:1\\r\\n\")).arg(gwConfig[\"uuid\"].toString()).toLocal8Bit();\n\n                datagram.clear();\n                if (st == SearchTargetAll || st == SearchTargetRoot)\n                {\n                    datagram.append(response);\n                    datagram.append(st1);\n                    datagram.append(\"\\r\\n\");\n                    if (udpSock->writeDatagram(datagram.data(), datagram.size(), host, port) == -1)\n                    {\n                        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n                    }\n                    datagram.clear();\n                }\n                if (st == SearchTargetAll || st == SearchTargetUUID)\n                {\n                    datagram.append(response);\n                    datagram.append(st2);\n                    datagram.append(\"\\r\\n\");\n                    if (udpSock->writeDatagram(datagram.data(), datagram.size(), host, port) == -1)\n                    {\n                        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n                    }\n                    datagram.clear();\n                }\n                if (st == SearchTargetAll || st == SearchTargetBasic)\n                {\n                    datagram.append(response);\n                    datagram.append(st3);\n                    datagram.append(\"\\r\\n\");\n                    if (udpSock->writeDatagram(datagram.data(), datagram.size(), host, port) == -1)\n                    {\n                        DBG_Printf(DBG_ERROR, \"UDP send error %s\\n\", qPrintable(udpSock->errorString()));\n                    }\n                    datagram.clear();\n                }\n            }\n            else if (datagram.startsWith(\"NOTIFY *\") && !location.isEmpty())\n            {\n                while (!stream.atEnd())\n                {\n                    QString line = stream.readLine();\n                    if (line.startsWith(QLatin1String(\"LOCATION:\")))\n                    {\n                        location = line;\n                    }\n                    else if (line.startsWith(QLatin1String(\"GWID.phoscon.de\")))\n                    {\n                        gwid = line;\n                        break;\n                    }\n                    else if (line.startsWith(QLatin1String(\"hue-bridgeid\")))\n                    {\n                        gwid = line;\n                        break;\n                    }\n                }\n\n                // phoscon gateway or hue bridge\n                QStringList ls = gwid.split(' ');\n                if (ls.size() != 2)\n                {\n                    continue;\n                }\n\n                if (ls[1] == gwBridgeId)\n                {\n                    continue; // self\n                }\n\n                ls = location.split(' ');\n                if (ls.size() != 2 || !ls[1].startsWith(QLatin1String(\"http://\")))\n                {\n                    continue;\n                }\n\n                // http://192.168.14.103:80/description.xml\n\n                QUrl url(ls[1]);\n                location = QString(\"http://%1:%2/api/config\").arg(url.host()).arg(url.port(80));\n                gwScanner->queryGateway(location);\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "websocket_server.cpp",
          "type": "blob",
          "size": 5.19140625,
          "content": "/*\n * Copyright (c) 2017-2018 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#ifdef USE_WEBSOCKETS\n\n#include \"deconz/dbg_trace.h\"\n#include \"deconz/util.h\"\n#include \"websocket_server.h\"\n\n/*! Constructor.\n */\nWebSocketServer::WebSocketServer(QObject *parent, quint16 port) :\n    QObject(parent)\n{\n    srv = new QWebSocketServer(\"deconz\", QWebSocketServer::NonSecureMode, this);\n\n    quint16 p = 0;\n    quint16 ports[] = { 443, 443, 8080, 8088, 20877, 0 }; // start with proxy frinedly ports first, use random port as fallback\n    if (port > 0)\n    {\n        ports[0] = port;\n    }\n\n    QHostAddress address;\n    QString addrArg = deCONZ::appArgumentString(\"--http-listen\", QString());\n\n    if (addrArg.isEmpty()) // Tie websocket server to specified IP, if any\n    {\n        address = QHostAddress::AnyIPv4;\n    }\n    else\n    {\n        address = QHostAddress(addrArg);\n    }\n\n    while (!srv->listen(address, ports[p]))\n    {\n        if (ports[p] == 0)\n        {\n            DBG_Printf(DBG_ERROR, \"Giveup starting websocket server on %s, port: %u. error: %s\\n\", qPrintable(address.toString()), ports[p], qPrintable(srv->errorString()));\n            break;\n        }\n\n        DBG_Printf(DBG_ERROR, \"Failed to start websocket server on %s, port: %u. error: %s\\n\", qPrintable(address.toString()), ports[p], qPrintable(srv->errorString()));\n        p++;\n    }\n\n    if (srv->isListening())\n    {\n        DBG_Printf(DBG_INFO, \"Started websocket server on %s, port: %u\\n\", qPrintable(address.toString()), srv->serverPort());\n        connect(srv, SIGNAL(newConnection()), this, SLOT(onNewConnection()));\n    }\n}\n\n/*! Returns the websocket server port.\n    \\return the active server port, or 0 if not active\n */\nquint16 WebSocketServer::port() const\n{\n    return srv->isListening() ? srv->serverPort() : 0;\n}\n\n/*! Handler for new client connections.\n */\nvoid WebSocketServer::onNewConnection()\n{\n    while (srv->hasPendingConnections())\n    {\n        QWebSocket *sock = srv->nextPendingConnection();\n        DBG_Printf(DBG_INFO, \"New websocket %s:%u (state: %d) \\n\", qPrintable(sock->peerAddress().toString()), sock->peerPort(), sock->state());\n        connect(sock, SIGNAL(disconnected()), this, SLOT(onSocketDisconnected()));\n        connect(sock, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(onSocketError(QAbstractSocket::SocketError)));\n        clients.push_back(sock);\n    }\n}\n\n/*! Handle websocket disconnected signal.\n */\nvoid WebSocketServer::onSocketDisconnected()\n{\n    for (size_t i = 0; i < clients.size(); i++)\n    {\n        QWebSocket *sock = qobject_cast<QWebSocket*>(sender());\n        DBG_Assert(sock);\n        if (sock && clients[i] == sock)\n        {\n            DBG_Printf(DBG_INFO, \"Websocket disconnected %s:%u, state: %d, close-code: %d, reason: %s\\n\", qPrintable(sock->peerAddress().toString()), sock->peerPort(), sock->state(), sock->closeCode(), qPrintable(sock->closeReason()));\n            sock->deleteLater();\n            clients[i] = clients.back();\n            clients.pop_back();\n        }\n    }\n}\n\n/*! Handle websocket error signal.\n    \\param err - the error which occured\n */\nvoid WebSocketServer::onSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    for (size_t i = 0; i < clients.size(); i++)\n    {\n        QWebSocket *sock = qobject_cast<QWebSocket*>(sender());\n        DBG_Assert(sock);\n        if (sock && clients[i] == sock)\n        {\n            DBG_Printf(DBG_INFO, \"Remove websocket %s:%u after error %s, close-code: %d, reason: %s\\n\",\n                       qPrintable(sock->peerAddress().toString()), sock->peerPort(), qPrintable(sock->errorString()), sock->closeCode(), qPrintable(sock->closeReason()));\n            sock->deleteLater();\n            clients[i] = clients.back();\n            clients.pop_back();\n        }\n    }\n}\n\n/*! Broadcasts a message to all connected clients.\n    \\param msg the message as JSON string\n */\nvoid WebSocketServer::broadcastTextMessage(const QString &msg)\n{\n    for (size_t i = 0; i < clients.size(); i++)\n    {\n        QWebSocket *sock = clients[i];\n\n        if (sock->state() != QAbstractSocket::ConnectedState)\n        {\n            DBG_Printf(DBG_INFO, \"Websocket %s:%u unexpected state: %d\\n\", qPrintable(sock->peerAddress().toString()), sock->peerPort(), sock->state());\n        }\n\n        qint64 ret = sock->sendTextMessage(msg);\n        DBG_Printf(DBG_INFO_L2, \"Websocket %s:%u send message: %s (ret = %d)\\n\", qPrintable(sock->peerAddress().toString()), sock->peerPort(), qPrintable(msg), ret);\n        sock->flush();\n    }\n}\n\n/*! Flush the sockets of all connected clients.\n */\nvoid WebSocketServer::flush()\n{\n    for (size_t i = 0; i < clients.size(); i++)\n    {\n        QWebSocket *sock = clients[i];\n\n        if (sock->state() == QAbstractSocket::ConnectedState)\n        {\n            sock->flush();\n        }\n    }\n}\n\n#else // no websockets\n  WebSocketServer::WebSocketServer(QObject *parent) :\n      QObject(parent)\n  { }\n  void WebSocketServer::onNewConnection() { }\n  void WebSocketServer::broadcastTextMessage(const QString &) { }\n  quint16 WebSocketServer::port() const {  return 0; }\n#endif\n"
        },
        {
          "name": "websocket_server.h",
          "type": "blob",
          "size": 0.79296875,
          "content": "#ifndef WEBSOCKET_SERVER_H\n#define WEBSOCKET_SERVER_H\n\n#include <QObject>\n#include <vector>\n#ifdef USE_WEBSOCKETS\n#include <QWebSocket>\n#include <QWebSocketServer>\n#endif // USE_WEBSOCKETS\n\nclass QWebSocket;\nclass QWebSocketServer;\n\n/*! \\class WebSocketServer\n\n    Basic websocket server to broadcast messages to clients.\n */\nclass WebSocketServer : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit WebSocketServer(QObject *parent, quint16 port);\n    quint16 port() const;\n\nsignals:\n\npublic slots:\n    void broadcastTextMessage(const QString &msg);\n    void flush();\n\nprivate slots:\n    void onNewConnection();\n    void onSocketDisconnected();\n    void onSocketError(QAbstractSocket::SocketError err);\n\nprivate:\n    QWebSocketServer *srv;\n    std::vector<QWebSocket*> clients;\n};\n\n#endif // WEBSOCKET_SERVER_H\n"
        },
        {
          "name": "window_covering.cpp",
          "type": "blob",
          "size": 27.0732421875,
          "content": "/*\n * window_covering.cpp\n *\n *\n *\n *\n * ZigBee Home Automation Public Application Profile Document 05-3520-29\n * Chapter 9.3 Window Covering Cluster\n *\n * Cluster Id 0x0102 Window Covering Cluster\n * Attributes\n * 0x0000 enum8,      WindowCoveringType\n * 0x0003 unsinged16, CurrentPositionLift\n * 0x0004 unsinged16, CurrentPositionTilt\n * 0x0008 unsinged8,  CurrentPositionLiftPercentage\n * 0x0009 unsinged8,  CurrentPositionTiltPercentage\n * 0x000A bitmap8,    OperationalStatus (This attribute contains two bits which will be set while the motor is active)\n * 0x0011 unsinged16, InstalledClosedLimitLift (Specifies a bound for the bottom position (lift height), in centimeters)\n * 0x0013 unsinged16, InstalledClosedLimitTilt (Specifies a bound for the closed position (tilt angle), in units of 0.1°)\n * 0x0017 bitmap8,    Mode (bit0=if the motor direction is reversed, bit1=the device is in calibration, bit2=maintenance mode)\n *\n * Commands\n * 0x00 Move up/open, Move upwards, towards the fully open position.\n * 0x01 Move down/close, Move downwards, towards the fully closed position.\n * 0x02 Stop, Stop all motion.\n * 0x04 Go to Lift Value, Moves to the specified lift value. Unsigned 16-bit integer.\n * 0x05 Go to Lift Percentage, Moves to the specified lift percentage. Unsigned 8-bit integer.\n * 0x07 Go to Tilt Value, Move to the specified tilt value. Unsigned 16-bit integer.\n * 0x08 Go to Tilt Percentage, Move to the specified tilt percentage. Unsigned 8-bit integer.\n *\n *\n * Ubisys Shutter Control J1\n *\n * http://www.ubisys.de/downloads/ubisys-j1-technical-reference.pdf\n * page 18, chapter 7.2.5.1. Calibration\n *\n * Step 1\n *    In order to calibrate the device, first choose the appropriate device type.\n *    0 = Roller Shade Lift only, ..., 6 = Shutter Tilt only, ..., 8 Tilt Blind Lift & Tilt\n *    Write attribute 0x10F2:0x0000 (“WindowCoveringType”) accordingly.\n * Step 2\n *    Prepare calibration by setting these values:\n *    Write attribute 0x10F2:0x0010 (“InstalledOpenLimitLift”) as 0x0000 = 0cm.\n *    Write attribute 0x10F2:0x0011 (“InstalledClosedLimitLift”) as 0x00F0 = 240cm.\n *    Write attribute 0x10F2:0x0012 (“InstalledOpenLimitTilt”) as 0x0000 = 0°.\n *    Write attribute 0x10F2:0x0013 (“InstalledClosedLimitTilt”) as 0x0384 = 90.0°.\n *    Write attribute 0x10F2:0x1001 (“LiftToTiltTransitionSteps”) as 0xFFFF = invalid.\n *    Write attribute 0x10F2:0x1002 (“TotalSteps”) as 0xFFFF = invalid.\n *    Write attribute 0x10F2:0x1003 (“LiftToTiltTransitionSteps2”) as 0xFFFF = invalid.\n *    Write attribute 0x10F2:0x1004 (“TotalSteps2”) as 0xFFFF = invalid\n * Step 3\n *    Enter calibration mode:\n *    Write attribute 0x0017 (“Mode”) as 0x02.\n * Step 4\n *    Send the \"move down\" command and \"stop\" after a few centimeters.\n * Step 5\n *    Send the “move up” command. When the device reaches its top position,\n *    J1 will recognize the upper bound.\n * Step 6\n *    After J1 has reached the top position and the motor has stopped, send the “move down” command.\n * Step 7\n *    After J1 has reached the lower bound and the motor has stopped, send the “move up” command.\n *    J1 will search for the upper bound. Once the top position is reached,\n *    calibration of the total steps in both directions is complete.\n * Step 8\n *    In case of a tilt blind set attribute 0x10F2:0x1001 and 0x10F2:0x1003 to the time it takes for a lift-to tilt\n *    transition (down) or a tilt-to-lift transition (up), respectively. Otherwise proceed with the next step.\n * Step 9\n *    To leave calibration mode, clear bit #1 in the Mode attribute, e.g. write attribute 0x0017 as 0x00.\n */\n\n#include \"de_web_plugin_private.h\"\n#include \"product_match.h\"\n\nint calibrationStep = 0;\nint operationalStatus = 0;\n\n/*! Handle packets related to the ZCL Window Covering cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Window Covering command or attribute\n */\nvoid DeRestPluginPrivate::handleWindowCoveringClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    // FIXME: You're only handling ZclReadAttributesResponse and ZclReportAttributes - no other commands\n    //        why not call this from deCONZ::NodeEvent instead that has already parsed the payload\n\n    Q_UNUSED(ind);\n\n    LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n\n    if (!lightNode)\n    {\n        // was no relevant node\n        return;\n    }\n\n    deCONZ::NumericUnion numericValue{};\n    quint16 attrid = 0x0000;\n    quint8 attrTypeId = 0x00;\n    quint8 attrValue = 0x00;\n    quint8 status = 0x00;\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    NodeValue::UpdateType updateType = NodeValue::UpdateInvalid;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        updateType = NodeValue::UpdateByZclRead;\n    }\n    else if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        updateType = NodeValue::UpdateByZclReport;\n    }\n\n    const QString modelId = lightNode->modelId();\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (updateType != NodeValue::UpdateInvalid)\n    {\n        while (!stream.atEnd())\n        {\n            stream >> attrid;\n            if (updateType == NodeValue::UpdateByZclRead)\n            {\n                stream >> status;  // Read Attribute Response status\n                if (status != 0)\n                {\n                    return;\n                }\n            }\n            stream >> attrTypeId;\n            switch (attrTypeId)\n            {\n                case deCONZ::Zcl8BitData:\n                case deCONZ::ZclBoolean:\n                case deCONZ::Zcl8BitBitMap:\n                case deCONZ::Zcl8BitUint:\n                case deCONZ::Zcl8BitInt:\n                case deCONZ::Zcl8BitEnum:\n                    stream >> attrValue;\n                    break;\n                case deCONZ::Zcl16BitData:\n                case deCONZ::Zcl16BitBitMap:\n                case deCONZ::Zcl16BitUint:\n                case deCONZ::Zcl16BitInt:\n                case deCONZ::Zcl16BitEnum:\n                    quint16 attrVal16;\n                    stream >> attrVal16;\n                    break;\n                default:\n                    // unsupported data type\n                    return;\n            }\n\n            if (attrid == 0x0008) // current CurrentPositionLiftPercentage 0-100\n            {\n                // Update value in the GUI.\n                numericValue.u8 = attrValue;\n                lightNode->setZclValue(updateType, ind.srcEndpoint(), WINDOW_COVERING_CLUSTER_ID, attrid, numericValue);\n\n                quint8 lift = attrValue;\n                // Reverse value for somes curtains\n                if (modelId.startsWith(QLatin1String(\"lumi.curtain\")) ||\n                    modelId == QLatin1String(\"D10110\") ||\n                    modelId == QLatin1String(\"Motor Controller\"))\n                {\n                    lift = 100 - lift;\n                }\n                // Reverse value for Legrand but only for old value\n                else if (modelId == QLatin1String(\"Shutter SW with level control\") ||\n                         modelId == QLatin1String(\"Shutter switch with neutral\"))\n                {\n                    bool bStatus = false;\n                    uint nHex = lightNode->swBuildId().toUInt(&bStatus,16);\n                    if (bStatus && (nHex < 28))\n                    {\n                        lift = 100 - lift;\n                    }\n                }\n                // Reverse for some tuya covering\n                else if (R_GetProductId(lightNode) == QLatin1String(\"11830304 Switch\") ||\n                         R_GetProductId(lightNode) == QLatin1String(\"Zigbee curtain switch\") ||\n                         R_GetProductId(lightNode) == QLatin1String(\"Zigbee dual curtain switch\") ||\n                         R_GetProductId(lightNode) == QLatin1String(\"Covering Switch ESW-2ZAD-EU\") ||\n                         R_GetProductId(lightNode) == QLatin1String(\"QS-Zigbee-C01 Module\"))\n                {\n                    lift = 100 - lift;\n                }\n\n                bool open = lift < 100;\n\n                if (lightNode->setValue(RStateLift, lift))\n                {\n                    pushZclValueDb(lightNode->address().ext(), lightNode->haEndpoint().endpoint(), WINDOW_COVERING_CLUSTER_ID, attrid, attrValue);\n                }\n                lightNode->setValue(RStateOpen, open);\n\n                // FIXME: deprecate\n                quint8 level = lift * 254 / 100;\n                bool on = level > 0;\n                lightNode->setValue(RStateBri, level);\n                lightNode->setValue(RStateOn, on);\n                // END FIXME: deprecate\n            }\n            else if (attrid == 0x0009) // current CurrentPositionTiltPercentage 0-100\n            {\n                numericValue.u8 = attrValue;\n                lightNode->setZclValue(updateType, ind.srcEndpoint(), WINDOW_COVERING_CLUSTER_ID, attrid, numericValue);\n\n                quint8 tilt = attrValue;\n                if (lightNode->setValue(RStateTilt, tilt))\n                {\n                    pushZclValueDb(lightNode->address().ext(), lightNode->haEndpoint().endpoint(), WINDOW_COVERING_CLUSTER_ID, attrid, attrValue);\n                }\n\n                // FIXME: deprecate\n                quint8 sat = attrValue * 254 / 100;\n                lightNode->setValue(RStateSat, sat);\n                // END FIXME: deprecate\n            }\n            else if (attrid == 0x000A)  // read attribute 0x000A OperationalStatus\n            {\n                if (calibrationStep != 0 && ind.srcAddress().ext() == calibrationTask.req.dstAddress().ext())\n                {\n                    operationalStatus = attrValue;\n                }\n            }\n            else if (attrid == 0x0000)  // read attribute 0x0000 WindowConveringType\n            {\n                Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), 0x02);\n                if (sensor)\n                {\n                    ResourceItem *item = sensor->item(RConfigWindowCoveringType);\n\n                    if (item)\n                    {\n                        item->setValue(attrValue);\n                        sensor->setNeedSaveDatabase(true);\n                        queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/*! Adds a window covering task to the queue.\n\n   \\param task - the task item\n   \\param cmdId - moveUp/Down/stop/moveTo/moveToPct\n   \\param pos - position centimeter\n   \\param pct - position percent\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskWindowCovering(TaskItem &task, uint8_t cmd, uint16_t pos, uint8_t pct)\n{\n    task.taskType = TaskWindowCovering;\n\n    task.req.setClusterId(WINDOW_COVERING_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(cmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n\n    if (cmd == 0x04 || cmd == 0x05 || cmd == 0x07 || cmd == 0x08)\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        if (cmd == 0x04 || cmd == 0x07)\n        {\n            stream << pos;  // 16-bit moveToPosition\n        }\n        if (cmd == 0x05 || cmd == 0x08)\n        {\n            stream << pct;  // 8-bit moveToPct\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\nbool DeRestPluginPrivate::addTaskWindowCoveringSetAttr(TaskItem &task, uint16_t mfrCode, uint16_t attrId, uint8_t attrType, uint16_t attrValue)\n{\n    DBG_Printf(DBG_INFO, \"addTaskWindowCoveringSetAttr: mfrCode = 0x%04x, attrId = 0x%04x, attrType = 0x%02x, attrValue = 0x%04x\\n\", mfrCode, attrId, attrType, attrValue);\n\n    task.taskType = TaskWindowCovering;\n\n    task.req.setDstEndpoint(0x01);\n    task.req.setClusterId(WINDOW_COVERING_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n\n    task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                            deCONZ::ZclFCDirectionClientToServer |\n                            deCONZ::ZclFCDisableDefaultResponse);\n    if (mfrCode != 0x0000)\n    {\n        task.zclFrame.setFrameControl(task.zclFrame.frameControl() | deCONZ::ZclFCManufacturerSpecific);\n        task.zclFrame.setManufacturerCode(mfrCode);\n    }\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        stream << (quint16) attrId;\n        stream << (quint8) attrType;\n        if (attrType == deCONZ::Zcl8BitEnum || attrType == deCONZ::Zcl8BitBitMap || attrType == deCONZ::Zcl8BitUint)\n        {\n            stream << (quint8) attrValue;\n        }\n        else if (attrType == deCONZ::Zcl16BitUint)\n        {\n            stream << (quint16) attrValue;\n        }\n        else\n        {\n            DBG_Printf(DBG_INFO, \"unsupported attribute type 0x%04x\\n\", attrType);\n            return false;\n        }\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Helper to generate a new task with new task and req id based on a reference */\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\n{\n    b.req.dstAddress() = a.req.dstAddress();\n    b.req.setDstAddressMode(a.req.dstAddressMode());\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\n    b.req.setDstEndpoint(a.req.dstEndpoint());\n    b.req.setRadius(a.req.radius());\n    b.req.setTxOptions(a.req.txOptions());\n    b.req.setSendDelay(a.req.sendDelay());\n    b.transitionTime = a.transitionTime;\n    b.lightNode = a.lightNode;\n    b.taskType = TaskWindowCovering;\n    b.req.setClusterId(WINDOW_COVERING_CLUSTER_ID);\n    b.req.setProfileId(HA_PROFILE_ID);\n    b.zclFrame.payload().clear();\n}\n\n/*! Configures window covering cluster.\n * Creates Binding from Target Device Endpoint to Coordinator Endpoint\n * and configures Reporting on Cluster 0x0102 Attributes 0x0008, 0x0009, 0x000A.\n * and starts calibration on ubisys J1\n *\n * Value   WindowCoveringType      Capabilities\n * 0    Roller Shade                = Lift only\n * 1    Roller Shade two motors     = Lift only\n * 2    Roller Shade exterior       = Lift only\n * 3    Roller Shade two motors ext = Lift only\n * 4    Drapery                     = Lift only\n * 5    Awning                      = Lift only\n * 6    Shutter                     = Tilt only\n * 7    Tilt Blind Lift only        = Tilt only\n * 8    Tilt Blind lift & tilt      = Lift & Tilt\n * 9    Projector Screen            = Lift only\n\n   \\param task - the task item\n   \\parma deviceType - WindowCoveringType 0-9\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskWindowCoveringCalibrate(TaskItem &taskRef, int WindowCoveringType)\n{\n    LightNode *lightNode = getLightNodeForAddress(taskRef.req.dstAddress(), 0x01);  // Endpoint 0x01\n\n    if (lightNode)\n    {\n        if (WindowCoveringType == 6 || WindowCoveringType == 7 || WindowCoveringType == 8)\n        {\n            lightNode->addItem(DataTypeUInt8, RStateSat);  // add sat for Tilt\n        }\n        else\n        {\n            lightNode->removeItem(RStateSat);\n        }\n        lightNode->setNeedSaveDatabase(true);\n        saveDatabaseItems |= DB_LIGHTS;\n    }\n\n    Sensor *sensor = getSensorNodeForAddressAndEndpoint(taskRef.req.dstAddress(), 0x02); // Endpoint 0x02\n\n    if (!sensor || !sensor->modelId().startsWith(QLatin1String(\"J1\")))\n    {\n        return false;\n    }\n\n    taskRef.req.setDstEndpoint(0x01);  // Window_Covering Server Cluster is on Endpoint 0x01\n\n    TaskItem task;\n    copyTaskReq(taskRef, task);\n    copyTaskReq(taskRef, calibrationTask);\n\n    // Create Binding\n    BindingTask bt;\n\n    bt.state = BindingTask::StateIdle;\n    bt.action = BindingTask::ActionBind;\n    bt.restNode = sensor; //task.lightNode;\n    Binding &bnd = bt.binding;\n    bnd.srcAddress = task.req.dstAddress().ext();\n    bnd.dstAddrMode = deCONZ::ApsExtAddress;\n    bnd.srcEndpoint = task.req.srcEndpoint();\n    bnd.clusterId = WINDOW_COVERING_CLUSTER_ID;\n    bnd.dstAddress.ext = apsCtrl->getParameter(deCONZ::ParamMacAddress);\n    bnd.dstEndpoint = endpoint();\n\n    if (bnd.dstEndpoint > 0) // valid gateway endpoint?\n    {\n        DBG_Printf(DBG_INFO_L2, \"create binding for attribute reporting of cluster 0x%04X\\n\", WINDOW_COVERING_CLUSTER_ID);\n        queueBindingTask(bt);\n    }\n    else\n    {\n        return false;\n    }\n\n    if (!bindingTimer->isActive())\n    {\n        bindingTimer->start();\n    }\n\n    // Configure Reporting on Cluster 0x0102 Attributes 0x0008, 0x0009, 0x000A\n    ConfigureReportingRequest rq;\n\n    rq.zclSeqNum = zclSeq++; // to match in configure reporting response handler\n    rq.dataType = deCONZ::Zcl8BitUint;\n    rq.attributeId = 0x0008; // CurrentPositionLiftPercentage\n    rq.minInterval = 1;\n    rq.maxInterval = 600;\n    rq.reportableChange8bit = 1;\n\n    ConfigureReportingRequest rq2;\n    rq2.dataType = deCONZ::Zcl8BitUint;\n    rq2.attributeId = 0x0009; // CurrentPositionTiltPercentage\n    rq2.minInterval = 1;\n    rq2.maxInterval = 600;\n    rq2.reportableChange8bit = 1;\n\n    ConfigureReportingRequest rq3;\n    rq3.dataType = deCONZ::Zcl8BitBitMap;\n    rq3.attributeId = 0x000A; // OperationalStatus\n    rq3.minInterval = 1;\n    rq3.maxInterval = 600;\n\n    std::vector<ConfigureReportingRequest> out = {rq, rq2, rq3};\n\n    DBG_Printf(DBG_INFO, \"ubisys addTaskWindowCoveringCalibrate task4 deviceType = %d\\n\", WindowCoveringType);\n\n    TaskItem task2;\n    copyTaskReq(taskRef, task2);\n\n    // ZDP Header\n    task2.zclFrame.setSequenceNumber(zclSeq++);\n    task2.zclFrame.setCommandId(deCONZ::ZclConfigureReportingId);\n    task2.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                   deCONZ::ZclFCDirectionClientToServer |\n                                   deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task2.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        for (const ConfigureReportingRequest &rq : out)\n        {\n            stream << rq.direction;\n            stream << rq.attributeId;\n            stream << rq.dataType;\n            stream << rq.minInterval;\n            stream << rq.maxInterval;\n\n            if (rq.reportableChange16bit != 0xFFFF)\n            {\n                stream << rq.reportableChange16bit;\n            }\n            else if (rq.reportableChange8bit != 0xFF)\n            {\n                stream << rq.reportableChange8bit;\n            }\n            else if (rq.reportableChange24bit != 0xFFFFFF)\n            {\n                stream << (qint8) (rq.reportableChange24bit & 0xFF);\n                stream << (qint8) ((rq.reportableChange24bit >> 8) & 0xFF);\n                stream << (qint8) ((rq.reportableChange24bit >> 16) & 0xFF);\n            }\n            else if (rq.reportableChange48bit != 0xFFFFFFFF)\n            {\n                stream << (qint8) (rq.reportableChange48bit & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 8) & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 16) & 0xFF);\n                stream << (qint8) ((rq.reportableChange48bit >> 24) & 0xFF);\n                stream << (qint8) 0x00;\n                stream << (qint8) 0x00;\n            }\n            DBG_Printf(DBG_INFO_L2, \"configure reporting for 0x%016llX, attribute 0x%04X/0x%04X\\n\", bt.restNode->address().ext(), bt.binding.clusterId, rq.attributeId);\n        }\n    }\n\n    { // ZCL frame\n        task2.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task2.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task2.zclFrame.writeToStream(stream);\n    }\n\n    if (!addTask(task2))\n    {\n        return false;\n    }\n\n    // Calibration Step 1 and Step 2\n    TaskItem task3;\n    copyTaskReq(taskRef, task3);\n\n    task3.zclFrame.setSequenceNumber(zclSeq++);\n    task3.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n    task3.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                   deCONZ::ZclFCManufacturerSpecific |\n                                   deCONZ::ZclFCDirectionClientToServer |\n                                   deCONZ::ZclFCDisableDefaultResponse);\n    task3.zclFrame.setManufacturerCode(0x10F2);  // Manufacturer code 0x10F2\n\n    { // payload\n        QDataStream stream(&task3.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        quint8 attrTypeId = deCONZ::Zcl16BitUint; // type-id 0x21 = unsigned16\n\n        stream << (quint16) 0x0000;\n        stream << (quint8) deCONZ::Zcl8BitEnum;\n        stream << (quint8) WindowCoveringType; // WindowCoveringType attribute 0x0000\n\n        stream << (quint16) 0x0010;\n        stream << attrTypeId;\n        stream << (quint16) 0x0000;  // Write attribute 0x10F2:0x0010 as 0x0000 = 0cm, typeid = 0x21\n\n        stream << (quint16) 0x0011;\n        stream << attrTypeId;\n        stream << (quint16) 0x00F0;  // Write attribute 0x10F2:0x0011 as 0x00F0 = 240cm, typeid = 0x21\n\n        stream << (quint16) 0x0012;\n        stream << attrTypeId;\n        stream << (quint16) 0x0000;  // Write attribute 0x10F2:0x0012 as 0x0000 = 0°, typeid = 0x21\n\n        stream << (quint16) 0x0013;\n        stream << attrTypeId;\n        stream << (quint16) 0x0384;  // Write attribute 0x10F2:0x0013 as 0x0384 = 90.0°, typeid = 0x21\n\n        stream << (quint16) 0x1001;\n        stream << attrTypeId;\n        stream << (quint16) 0xFFFF;  // Write attribute 0x10F2:0x1001 as 0xFFFF = invalid, typeid = 0x21\n\n        stream << (quint16) 0x1002;\n        stream << attrTypeId;\n        stream << (quint16) 0xFFFF;  // Write attribute 0x10F2:0x1002 as 0xFFFF = invalid, typeid = 0x21\n\n        stream << (quint16) 0x1003;\n        stream << attrTypeId;\n        stream << (quint16) 0xFFFF;  // Write attribute 0x10F2:0x1003 as 0xFFFF = invalid, typeid = 0x21\n\n        stream << (quint16) 0x1004;\n        stream << attrTypeId;\n        stream << (quint16) 0xFFFF;  // Write attribute 0x10F2:0x1004 as 0xFFFF = invalid, typeid = 0x21\n     }\n\n    { // ZCL frame\n        task3.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task3.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task3.zclFrame.writeToStream(stream);\n    }\n\n    if (!addTask(task3))\n    {\n        return false;\n    }\n\n    // Calibration Step 3\n    TaskItem task4;\n    copyTaskReq(taskRef, task4);\n\n    task4.zclFrame.setSequenceNumber(zclSeq++);\n    task4.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n    task4.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                   deCONZ::ZclFCDirectionClientToServer |\n                                   deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task4.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << (quint16) 0x0017;\n        stream << (quint8) deCONZ::Zcl8BitBitMap;\n        stream << (quint8) 0x02; // Write attribute Mode 0x0017 as 0x02, typeid = 0x18\n    }\n\n    { // ZCL frame\n        task4.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task4.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task4.zclFrame.writeToStream(stream);\n    }\n\n    if (!addTask(task4))\n    {\n        return false;\n    }\n\n    // start timer for next step\n    calibrationStep = 3;\n    QTimer::singleShot(2000, this, SLOT(calibrateWindowCoveringNextStep()));\n\n    return true;\n}\n\nvoid DeRestPluginPrivate::calibrateWindowCoveringNextStep()\n{\n    TaskItem task;\n    copyTaskReq(calibrationTask, task);\n\n    DBG_Printf(DBG_INFO, \"ubisys NextStep calibrationStep = %d, task=\" FMT_MAC \" calibrationTask = \" FMT_MAC \"\\n\",\n               calibrationStep,\n               (unsigned long long)task.req.dstAddress().ext(),\n               (unsigned long long)calibrationTask.req.dstAddress().ext());\n\n    switch(calibrationStep)\n    {\n    case 3:\n        calibrationStep = 4;\n        QTimer::singleShot(2000, this, SLOT(calibrateWindowCoveringNextStep()));\n        addTaskWindowCovering(task, 0x01 /*move down*/, 0, 0);\n        break;\n\n    case 4:\n        calibrationStep = 5;\n        QTimer::singleShot(4000, this, SLOT(calibrateWindowCoveringNextStep()));\n        addTaskWindowCovering(task, 0x00 /*move up*/, 0, 0);\n        break;\n\n    case 5:\n        if (operationalStatus == 0)\n        {\n            calibrationStep = 6;\n            addTaskWindowCovering(task, 0x01 /*move down*/, 0, 0);\n        }\n        QTimer::singleShot(30000, this, SLOT(calibrateWindowCoveringNextStep()));\n        break;\n\n    case 6:\n        if (operationalStatus == 0)\n        {\n            calibrationStep = 7;\n            addTaskWindowCovering(task, 0x00 /*move up*/, 0, 0);\n        }\n        QTimer::singleShot(30000, this, SLOT(calibrateWindowCoveringNextStep()));\n        break;\n\n    case 7:\n        if (operationalStatus == 0)\n        {\n            calibrationStep = 8;\n        }\n        QTimer::singleShot(30000, this, SLOT(calibrateWindowCoveringNextStep()));\n        break;\n\n    case 8:\n        if (operationalStatus == 0)\n        {\n            calibrationStep = 0;\n\n            // leave calibration mode\n            task.zclFrame.setSequenceNumber(zclSeq++);\n            task.zclFrame.setCommandId(deCONZ::ZclWriteAttributesId);\n            task.zclFrame.setFrameControl(deCONZ::ZclFCProfileCommand |\n                                          deCONZ::ZclFCDirectionClientToServer |\n                                          deCONZ::ZclFCDisableDefaultResponse);\n\n            { // payload\n                QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n                stream.setByteOrder(QDataStream::LittleEndian);\n\n                stream << (quint16) 0x0017;\n                stream << (quint8) deCONZ::Zcl8BitBitMap;\n                stream << (quint8) 0x00; // Write attribute Mode 0x0017 as 0x00, typeid = 0x18\n            }\n\n            { // ZCL frame\n                task.req.asdu().clear(); // cleanup old request data if there is any\n                QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n                stream.setByteOrder(QDataStream::LittleEndian);\n                task.zclFrame.writeToStream(stream);\n            }\n\n            addTask(task);\n\n        }\n        break;\n\n    default:\n        {\n        }\n        break;\n    }\n}\n"
        },
        {
          "name": "xiaomi.cpp",
          "type": "blob",
          "size": 35.978515625,
          "content": "#include <math.h>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"utils/utils.h\"\n#include \"xiaomi.h\"\n\n/*! Handle packets related to the Xiaomi/Lumi FCC0 cluster.\n    \\param ind the APS level data indication containing the ZCL packet\n    \\param zclFrame the actual ZCL frame which holds the Xiaomi/Lumi FCC0 cluster command or attribute\n */\nvoid DeRestPluginPrivate::handleXiaomiLumiClusterIndication(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (zclFrame.isDefaultResponse())\n    {\n        return;\n    }\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n\n    bool isReadAttr = false;\n    bool isReporting = false;\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReadAttributesResponseId)\n    {\n        isReadAttr = true;\n    }\n    if (zclFrame.isProfileWideCommand() && zclFrame.commandId() == deCONZ::ZclReportAttributesId)\n    {\n        isReporting = true;\n    }\n\n    // Read ZCL reporting and ZCL Read Attributes Response\n    if (isReadAttr || isReporting)\n    {\n        const NodeValue::UpdateType updateType = isReadAttr ? NodeValue::UpdateByZclRead : NodeValue::UpdateByZclReport;\n\n        // bool configUpdated = false;\n        // bool stateUpdated = false;\n\n        while (!stream.atEnd())\n        {\n            quint16 attrId;\n            quint8 attrTypeId;\n\n            stream >> attrId;\n            if (isReadAttr)\n            {\n                quint8 status;\n                stream >> status;  // Read Attribute Response status\n                if (status != deCONZ::ZclSuccessStatus)\n                {\n                    continue;\n                }\n            }\n            stream >> attrTypeId;\n\n            deCONZ::ZclAttribute attr(attrId, attrTypeId, QLatin1String(\"\"), deCONZ::ZclRead, false);\n\n            if (!attr.readFromStream(stream))\n            {\n                continue;\n            }\n\n            switch (attrId)\n            {\n            case XIAOMI_ATTRID_SPECIAL_REPORT:\n            {\n                handleZclAttributeReportIndicationXiaomiSpecial(ind, zclFrame);\n            }\n                break;\n\n            case XIAOMI_ATTRID_DEVICE_MODE:\n            {\n\n            }\n                break;\n\n            case XIAOMI_ATTRID_MOTION_SENSITIVITY:\n            {\n                Sensor *sensor = getSensorNodeForAddressEndpointAndCluster(ind.srcAddress(), ind.srcEndpoint(), XIAOMI_CLUSTER_ID);\n\n                if (sensor)\n                {\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), XIAOMI_CLUSTER_ID, XIAOMI_ATTRID_MOTION_SENSITIVITY, attr.numericValue());\n\n                    quint8 sensitivity = attr.numericValue().u8;\n                    sensor->setValue(RConfigSensitivity, sensitivity);\n                }\n            }\n                break;\n\n            case XIAOMI_ATTRID_P1_MOTION_DETECTION:\n            {\n                // Workaround to set P1 presence sensor back to unoccupied, as the pure reception of this report is considered\n                // as presence = true state, but this is not reset by the device automatically. Ideally, deCONZ will have some timers\n                // for such cases available in future.\n                Sensor *sensor = getSensorNodeForAddressAndEndpoint(ind.srcAddress(), ind.srcEndpoint());\n                \n                if (sensor)\n                {\n                    bool occupancy = true;\n                    ResourceItem *item = nullptr;\n                    item = sensor->item(RStatePresence);\n                    \n                    if (item)\n                    {\n                        item->setValue(occupancy);\n                        enqueueEvent(Event(RSensors, RStatePresence, sensor->id(), item));\n    \n                        ResourceItem *item2 = nullptr;\n                        item2 = sensor->item(RConfigDuration);\n    \n                        if (item2 && item2->toNumber() > 0)\n                        {\n                            // As unoccupied state is not reportable, add duration seconds after a occupied = true to automatically set to false\n                            sensor->durationDue = item->lastSet().addSecs(item2->toNumber());\n                        }\n                    }\n    \n                    deCONZ::NumericUnion occ;\n                    occ.u64 = occupancy;\n    \n                    sensor->setZclValue(updateType, ind.srcEndpoint(), OCCUPANCY_SENSING_CLUSTER_ID, XIAOMI_ATTRID_P1_MOTION_DETECTION, occ);\n    \n                    sensor->updateStateTimestamp();\n                    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor->id()));\n                    updateSensorEtag(&*sensor);\n                    sensor->setNeedSaveDatabase(true);\n                    queSaveDb(DB_SENSORS, DB_SHORT_SAVE_DELAY);\n                }\n            }\n                break;\n\n            case XIAOMI_ATTRID_SPEED:\n            {\n                LightNode *lightNode = getLightNodeForAddress(ind.srcAddress(), ind.srcEndpoint());\n\n                if (lightNode)\n                {\n                    lightNode->setZclValue(updateType, ind.srcEndpoint(), XIAOMI_CLUSTER_ID, XIAOMI_ATTRID_SPEED, attr.numericValue());\n                    quint8 speed = attr.numericValue().u8;\n                    lightNode->setValue(RStateSpeed, speed);\n                }\n            }\n                break;\n\n            case XIAOMI_ATTRID_CHARGING:\n            {\n                Sensor *sensor = getSensorNodeForAddressEndpointAndCluster(ind.srcAddress(), ind.srcEndpoint(), XIAOMI_CLUSTER_ID);\n\n                if (sensor)\n                {\n                    sensor->setZclValue(updateType, ind.srcEndpoint(), XIAOMI_CLUSTER_ID, XIAOMI_ATTRID_CHARGING, attr.numericValue());\n                    bool charging = attr.numericValue().u8 == 1;\n                    sensor->setValue(RStateCharging, charging);\n                }\n\n            }\n                break;\n\n            default:\n                break;\n            }\n        }\n    }\n}\n\n/*! Handle manufacturer specific Xiaomi ZCL attribute report commands to basic cluster.\n */\nvoid DeRestPluginPrivate::handleZclAttributeReportIndicationXiaomiSpecial(const deCONZ::ApsDataIndication &ind, deCONZ::ZclFrame &zclFrame)\n{\n    if (ind.srcAddress().hasExt())\n    {\n        Device *device = DEV_GetDevice(m_devices, ind.srcAddress().ext());\n        if (device)\n        {\n            enqueueEvent(Event(device->prefix(), REventAwake, 0, device->key()));\n            if (device->managed())\n            {\n                return;\n            }\n        }\n    }\n\n    quint16 attrId = 0;\n    quint8 dataType = 0;\n    quint8 length = 0;\n\n    QDataStream stream(zclFrame.payload());\n    stream.setByteOrder(QDataStream::LittleEndian);\n    stream.setFloatingPointPrecision(QDataStream::SinglePrecision);\n\n    while (attrId == 0)\n    {\n        if (stream.atEnd())\n        {\n            break;\n        }\n\n        quint16 a;\n        stream >> a;\n        stream >> dataType;\n\n        if (dataType == deCONZ::ZclCharacterString || dataType == deCONZ::ZclOctedString)\n        {\n            stream >> length;\n        }\n\n        if (a == 0xff01 && dataType == deCONZ::ZclCharacterString)\n        {\n            attrId = a;\n        }\n        else if (a == 0xff02 && dataType == 0x4c /*deCONZ::ZclStruct*/)\n        {\n            attrId = a;\n        }\n        else if (a == 0x00f7 && dataType == deCONZ::ZclOctedString)\n        {\n            attrId = a;\n        }\n\n        if (dataType == deCONZ::ZclCharacterString && attrId != 0xff01)\n        {\n            DBG_Printf(DBG_INFO_L2, \"0x%016llX skip Xiaomi attribute 0x%04X\\n\", ind.srcAddress().ext(), attrId);\n            for (; length > 0; length--) // skip\n            {\n                quint8 dummy;\n                stream >> dummy;\n            }\n        }\n    }\n\n    if (stream.atEnd() || attrId == 0)\n    {\n        return;\n    }\n\n    quint8 structIndex = 0; // only attribute id 0xff02\n    quint16 structSize = 0; // only attribute id 0xff02\n\n    quint8 batteryPercentage = UINT8_MAX;\n    quint16 battery = 0;\n    quint8 charging = UINT8_MAX;\n    quint32 lightlevel = UINT32_MAX; // use 32-bit to mark invalid and support 0xffff value\n    qint16 temperature = INT16_MIN;\n    quint16 humidity = UINT16_MAX;\n    qint16 pressure = INT16_MIN;\n    quint8 onOff = UINT8_MAX;\n    quint8 onOff2 = UINT8_MAX;\n    quint8 lift = UINT8_MAX;\n    quint32 power = UINT32_MAX;\n    quint32 consumption = UINT32_MAX;\n    quint32 current = UINT32_MAX;\n    quint32 voltage = UINT32_MAX;\n    QString firmware;\n\n    DBG_Printf(DBG_INFO, \"0x%016llX extract Xiaomi special attribute 0x%04X\\n\", ind.srcAddress().ext(), attrId);\n\n    QString dateCode;\n\n    while (!stream.atEnd())\n    {\n        qint8 s8;\n        qint16 s16;\n        quint8 u8;\n        quint16 u16;\n        qint32 s32;\n        quint32 u32;\n        quint64 u64;\n        float f;\n\n        quint8 tag = 0;\n\n        if (attrId == 0xff01 || attrId == 0x00f7)\n        {\n            stream >> tag;\n        }\n        else if (attrId == 0xff02)\n        {\n            if (structIndex == 0)\n            {\n                stream >> structSize; // number of elements\n            }\n            structIndex++;\n        }\n\n        stream >> dataType;\n\n        switch (dataType)\n        {\n        case deCONZ::ZclBoolean: stream >> u8; break;\n        case deCONZ::Zcl8BitInt: stream >> s8; break;\n        case deCONZ::Zcl8BitUint: stream >> u8; break;\n        case deCONZ::Zcl16BitInt: stream >> s16; break;\n        case deCONZ::Zcl16BitUint: stream >> u16; break;\n        case deCONZ::Zcl32BitInt: stream >> s32; break;\n        case deCONZ::Zcl32BitUint: stream >> u32; break;\n        case deCONZ::Zcl40BitUint:\n            u64 = 0;\n            for (int i = 0; i < 5; i++)\n            {\n                u64 <<= 8;\n                stream >> u8;\n                u64 |= u8;\n            }\n            break;\n        case deCONZ::Zcl48BitUint:\n            u64 = 0;\n            for (int i = 0; i < 6; i++)\n            {\n                u64 <<= 8;\n                stream >> u8;\n                u64 |= u8;\n            }\n            break;\n        case deCONZ::Zcl64BitUint: stream >> u64; break;\n        case deCONZ::ZclSingleFloat: stream >> f; break;\n        default:\n        {\n            DBG_Printf(DBG_INFO, \"\\tUnsupported datatype 0x%02X (tag 0x%02X)\\n\", dataType, tag);\n        }\n            return;\n        }\n\n        if ((tag == 0x01 || structIndex == 0x02) && dataType == deCONZ::Zcl16BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t01 battery %u (0x%04X)\\n\", u16, u16);\n            battery = u16;\n        }\n        else if (tag == 0x03 && dataType == deCONZ::Zcl8BitInt)\n        {\n            DBG_Printf(DBG_INFO, \"\\t03 Device temperature %d °C\\n\", int(s8)); // Device temperature for lumi.plug.mmeu01\n            temperature = qint16(s8) * 100;\n        }\n        else if ((tag == 0x04 || structIndex == 0x03) && dataType == deCONZ::Zcl16BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t04 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x05 && dataType == deCONZ::Zcl16BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t05 RSSI dB (?) %u (0x%04X)\\n\", u16, u16); // Power outages for lumi.plug.mmeu01\n        }\n        else if ((tag == 0x06 || structIndex == 0x04) && dataType == deCONZ::Zcl40BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t06 LQI (?) %llu (0x%010llX)\\n\", u64, u64);\n        }\n        else if (tag == 0x07 && dataType == deCONZ::Zcl64BitUint) // lumi.ctrl_ln2\n        {\n            DBG_Printf(DBG_INFO, \"\\t07 unknown %llu (0x%016llX)\\n\", u64, u64);\n        }\n        else if (tag == 0x08 && dataType == deCONZ::Zcl16BitUint) // lumi.ctrl_ln2\n        {\n            DBG_Printf(DBG_INFO, \"\\t08 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x09 && dataType == deCONZ::Zcl16BitUint) // lumi.ctrl_ln2\n        {\n            DBG_Printf(DBG_INFO, \"\\t09 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x0a && dataType == deCONZ::Zcl16BitUint) // lumi.vibration.aq1\n        {\n            DBG_Printf(DBG_INFO, \"\\t0a Parent NWK %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x0b && dataType == deCONZ::Zcl16BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t0b lightlevel %u (0x%04X)\\n\", u16, u16);\n            lightlevel = u16;\n        }\n        else if (tag == 0x0b && dataType == deCONZ::Zcl8BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t0b unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x0c && dataType == deCONZ::Zcl8BitUint) // lumi.remote.b28ac1\n        {\n            DBG_Printf(DBG_INFO, \"\\t0c unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x0d && dataType == deCONZ::Zcl32BitUint) // lumi.switch.n2aeu1\n        {\n            firmware = QString(\"%1.%2.%3_%4%5\")\n                .arg((u32 & 0xF0000000) >> 28)\n                .arg((u32 & 0x0F000000) >> 24)\n                .arg((u32 & 0x00FF0000) >> 16)\n                .arg((u32 & 0x0000FF00) >> 8)\n                .arg(u32 & 0xFF);\n            DBG_Printf(DBG_INFO, \"\\t0d firmware %s (0x%08X)\\n\", qPrintable(firmware), u32);\n        }\n        else if (tag == 0x0e && dataType == deCONZ::Zcl32BitUint) // lumi.switch.n2aeu1\n        {\n            DBG_Printf(DBG_INFO, \"\\t0e unknown %u (0x%08X)\\n\", u32, u32);\n        }\n        else if (tag == 0x0f && dataType == deCONZ::Zcl32BitUint) // lumi.switch.n2aeu1\n        {\n            DBG_Printf(DBG_INFO, \"\\t0f unknown %u (0x%08X)\\n\", u32, u32);\n        }\n        else if (tag == 0x011 && dataType == deCONZ::Zcl32BitUint) // lumi.curtain.acn002\n        {\n            DBG_Printf(DBG_INFO, \"\\t11 unknown %u (0x%08X)\\n\", u32, u32);\n        }\n        else if ((tag == 0x64 || structIndex == 0x01) && dataType == deCONZ::ZclBoolean) // lumi.ctrl_ln2 endpoint 01\n        {\n            DBG_Printf(DBG_INFO, \"\\t64 on/off %u\\n\", u8);\n            onOff = u8;\n        }\n        else if (tag == 0x64 && dataType == deCONZ::Zcl8BitUint) // lumi.curtain\n        {\n            if (u8 <= 100)\n            {\n                lift = 100 - u8;\n            }\n            DBG_Printf(DBG_INFO, \"\\t64 lift %u (%u%%)\\n\", u8, lift);\n            DBG_Printf(DBG_INFO, \"\\t64 smoke/gas density %u (0x%02X)\\n\", u8, u8);   // lumi.sensor_smoke/lumi.sensor_natgas\n        }\n        else if (tag == 0x64 && dataType == deCONZ::Zcl16BitInt)\n        {\n            if (int(s16) == -10000)\n            {\n                DBG_Printf(DBG_INFO, \"\\t64 temperature %d (ignored)\\n\", int(s16));\n            }\n            else\n            {\n                DBG_Printf(DBG_INFO, \"\\t64 temperature %d\\n\", int(s16));\n                temperature = s16;\n            }\n        }\n        else if (tag == 0x65 && dataType == deCONZ::ZclBoolean) // lumi.ctrl_ln2 endpoint 02\n        {\n            DBG_Printf(DBG_INFO, \"\\t65 on/off %d\\n\", u8);\n            onOff2 = u8;\n        }\n        else if (tag == 0x65 && dataType == deCONZ::Zcl8BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t65 battery %u%%\\n\", u8);\n            batteryPercentage = u8;\n        }\n        else if (tag == 0x65 && dataType == deCONZ::Zcl16BitUint)\n        {\n            DBG_Printf(DBG_INFO, \"\\t65 humidity %u\\n\", u16); // Mi\n            humidity = u16;\n        }\n        else if (tag == 0x66)\n        {\n            if (dataType == deCONZ::Zcl8BitUint) // lumi.remote.b28ac1\n            {\n                DBG_Printf(DBG_INFO, \"\\t66 unknown %u (0x%02X)\\n\", u8, u8);\n            }\n            else if (dataType == deCONZ::Zcl16BitUint)\n            {\n                DBG_Printf(DBG_INFO, \"\\t66 unknown %u (0x%04X)\\n\", u16, u16);\n            }\n            else if (dataType == deCONZ::Zcl32BitInt) // lumi.weather\n            {\n                pressure = (s32 + 50) / 100;\n                DBG_Printf(DBG_INFO, \"\\t66 pressure %d (%d)\\n\", s32, pressure);\n            }\n        }\n        else if (tag == 0x67 && dataType == deCONZ::Zcl8BitUint) // lumi.switch.n2aeu1\n        {\n            DBG_Printf(DBG_INFO, \"\\t67 unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x69 && dataType == deCONZ::Zcl8BitUint) // lumi.switch.n2aeu1\n        {\n            charging = u8;\n            DBG_Printf(DBG_INFO, \"\\t69 charging %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x6a && dataType == deCONZ::Zcl16BitUint) // lumi.switch.n2aeu1\n        {\n            DBG_Printf(DBG_INFO, \"\\t6a unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x6b && dataType == deCONZ::Zcl8BitUint) // lumi.switch.n2aeu1\n        {\n            DBG_Printf(DBG_INFO, \"\\t6b unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x6e && dataType == deCONZ::Zcl8BitUint) // lumi.ctrl_neutral2\n        {\n            DBG_Printf(DBG_INFO, \"\\t6e unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x6f && dataType == deCONZ::Zcl8BitUint) // lumi.ctrl_neutral2\n        {\n            DBG_Printf(DBG_INFO, \"\\t6f unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x94 && dataType == deCONZ::Zcl8BitUint) // lumi.relay.c2acn01\n        {\n            DBG_Printf(DBG_INFO, \"\\t6f unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x95 && dataType == deCONZ::ZclSingleFloat) // lumi.ctrl_ln2\n        {\n            consumption = static_cast<qint32>(round(f * 1000)); // convert to Wh\n            DBG_Printf(DBG_INFO, \"\\t95 consumption %f (%d)\\n\", f, consumption);\n        }\n        else if (tag == 0x96 && dataType == deCONZ::ZclSingleFloat) // lumi.plug.mmeu01\n        {\n            voltage = static_cast<qint32>(round(f / 10)); // convert to V\n            DBG_Printf(DBG_INFO, \"\\t96 voltage %f (%d)\\n\", f, voltage);\n        }\n        else if (tag == 0x96 && dataType == deCONZ::Zcl32BitUint) // lumi.sensor_smoke\n        {\n            DBG_Printf(DBG_INFO, \"\\t96 unknown %u (0x%08X)\\n\", u32, u32);\n        }\n        else if (tag == 0x97 && dataType == deCONZ::Zcl16BitUint) // lumi.sensor_cube\n        {\n            DBG_Printf(DBG_INFO, \"\\t97 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x97 && dataType == deCONZ::ZclSingleFloat) // lumi.plug.mmeu01\n        {\n            current = static_cast<qint32>(round(f));  // already in mA\n            DBG_Printf(DBG_INFO, \"\\t97 current %f (%d)\\n\", f, current);\n        }\n        else if (tag == 0x98 && dataType == deCONZ::Zcl16BitUint) // lumi.sensor_cube\n        {\n            DBG_Printf(DBG_INFO, \"\\t98 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x98 && dataType == deCONZ::ZclSingleFloat) // lumi.ctrl_ln2\n        {\n            power = static_cast<qint32>(round(f));  // already in W\n            DBG_Printf(DBG_INFO, \"\\t98 power %f (%d)\\n\", f, power);\n        }\n        else if (tag == 0x99 && dataType == deCONZ::Zcl16BitUint) // lumi.sensor_cube\n        {\n            DBG_Printf(DBG_INFO, \"\\t99 unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x99 && dataType == deCONZ::Zcl32BitUint) // lumi.ctrl_neutral2\n        {\n            DBG_Printf(DBG_INFO, \"\\t99 unknown %u (0x%08X)\\n\", u32, u32);\n        }\n        else if (tag == 0x9a && dataType == deCONZ::Zcl8BitUint) // lumi.ctrl_ln2\n        {\n            DBG_Printf(DBG_INFO, \"\\t9a unknown %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag == 0x9a && dataType == deCONZ::Zcl16BitUint) // lumi.sensor_cube\n        {\n            DBG_Printf(DBG_INFO, \"\\t9a unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x9a && dataType == deCONZ::Zcl48BitUint) // lumi.vibration.aq1\n        {\n            DBG_Printf(DBG_INFO, \"\\t9a unknown %llu (0x%012llX)\\n\", u64, u64);\n        }\n        else if (tag == 0x9b && dataType == deCONZ::Zcl16BitUint) // lumi.ctrl_neutral2\n        {\n            DBG_Printf(DBG_INFO, \"\\t9b unknown %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (tag == 0x9b && dataType == deCONZ::ZclBoolean) // lumi.plug.mmeu01\n        {\n            DBG_Printf(DBG_INFO, \"\\t9b Consumer connected (yes/no) %d\\n\", u8);\n        }\n        else if (structIndex == 0x05 && dataType == deCONZ::Zcl16BitUint) // lumi.sensor_magnet\n        {\n            DBG_Printf(DBG_INFO, \"\\tStruct index 05 unknown (counter?) %u (0x%04X)\\n\", u16, u16);\n        }\n        else if (structIndex == 0x06 && dataType == deCONZ::Zcl8BitUint) // lumi.sensor_magnet\n        {\n            DBG_Printf(DBG_INFO, \"\\tStruct index 06 unknown (counter?) %u (0x%02X)\\n\", u8, u8);\n        }\n        else if (tag)\n        {\n            DBG_Printf(DBG_INFO, \"\\t%02X unsupported tag (data type 0x%02X)\\n\", tag, dataType);\n        }\n        else if (structIndex)\n        {\n            DBG_Printf(DBG_INFO, \"\\t%02X unsupported index (data type 0x%02X)\\n\", structIndex, dataType);\n        }\n    }\n\n    RestNodeBase *restNodePending = nullptr;\n    ResourceItem *item = nullptr;\n    QString modelId;\n\n    for (LightNode &lightNode: nodes)\n    {\n        if (!lightNode.modelId().startsWith(QLatin1String(\"lumi.\"))) { continue; }\n        if (!isSameAddress(lightNode.address(), ind.srcAddress()))   { continue; }\n\n        quint8 stateOnOff = UINT8_MAX;\n        ResourceItem *item;\n\n        if (lightNode.modelId().startsWith(QLatin1String(\"lumi.ctrl_neutral\")) ||\n            lightNode.modelId() == QLatin1String(\"lumi.switch.b1lacn02\") ||\n            lightNode.modelId() == QLatin1String(\"lumi.switch.b2lacn02\"))\n        {\n            if (lightNode.haEndpoint().endpoint() == 0x02 && onOff != UINT8_MAX)\n            {\n                stateOnOff = onOff;\n\n            }\n            else if (lightNode.haEndpoint().endpoint() == 0x03 && onOff2 != UINT8_MAX)\n            {\n                stateOnOff = onOff2;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        else if (lightNode.modelId().startsWith(QLatin1String(\"lumi.ctrl_ln\")))\n        {\n            if (lightNode.haEndpoint().endpoint() == 0x01 && onOff != UINT8_MAX)\n            {\n                stateOnOff = onOff;\n            }\n            else if (lightNode.haEndpoint().endpoint() == 0x02 && onOff2 != UINT8_MAX)\n            {\n                stateOnOff = onOff2;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        else if (lightNode.modelId().startsWith(QLatin1String(\"lumi.curtain\")) && lift != UINT8_MAX)\n        {\n            item = lightNode.item(RStateLift);\n            if (item)\n            {\n                item->setValue(lift);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n            }\n            // FIXME: deprecate\n            item = lightNode.item(RStateBri);\n            if (item)\n            {\n                const uint bri = lift * 254 / 100;\n                item->setValue(bri);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n                stateOnOff = bri != 0;\n            }\n            // END FIXME: deprecate\n            item = lightNode.item(RStateOpen);\n            bool open = lift < 100;\n            if (item)\n            {\n                item->setValue(open);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n            }\n            item = lightNode.item(RAttrSwVersion);\n            if (item && !firmware.isEmpty() && firmware != item->toString())\n            {\n                item->setValue(firmware);\n                enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n                Q_Q(DeRestPlugin);\n                emit q->nodeUpdated(lightNode.address().ext(), QLatin1String(\"version\"), firmware);\n            }\n        }\n        else if (onOff != UINT8_MAX)\n        {\n            stateOnOff = onOff;\n        }\n\n        lightNode.rx();\n        item = lightNode.item(RStateReachable);\n        if (item && !item->toBool())\n        {\n            item->setValue(true);\n            enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n        }\n        item = lightNode.item(RStateOn);\n        if (item && stateOnOff != UINT8_MAX) // updated?\n        {\n            DBG_Assert(stateOnOff == 0 || stateOnOff == 1);\n\n            deCONZ::NumericUnion onOffValue;\n            onOffValue.u8 = stateOnOff;\n            lightNode.setZclValue(NodeValue::UpdateByZclReport, ind.srcEndpoint(), ONOFF_CLUSTER_ID, 0x0000, onOffValue);\n\n            item->setValue(stateOnOff);\n            enqueueEvent(Event(RLights, item->descriptor().suffix, lightNode.id(), item));\n        }\n        updateLightEtag(&lightNode);\n        lightNode.setNeedSaveDatabase(true);\n        saveDatabaseItems |= DB_LIGHTS;\n    }\n\n    for (Sensor &sensor : sensors)\n    {\n        if (sensor.deletedState() != Sensor::StateNormal || !sensor.node()) { continue; }\n        if (!sensor.modelId().startsWith(QLatin1String(\"lumi.\")))           { continue; }\n        if (!isSameAddress(sensor.address(), ind.srcAddress()))             { continue; }\n\n        if (modelId.isEmpty())\n        {\n            modelId = sensor.modelId();\n        }\n\n        sensor.rx();\n        bool updated = false;\n        restNodePending = &sensor; // remember one sensor for pending tasks\n\n        {\n            item = sensor.item(RConfigReachable);\n            if (item && !item->toBool())\n            {\n                item->setValue(true);\n                enqueueEvent(Event(RSensors, RConfigReachable, sensor.id(), item));\n                updated = true;\n            }\n        }\n\n        // Battery percentage trumps battery voltage.\n        if (batteryPercentage != UINT8_MAX)\n        {\n            item = sensor.item(RStateBattery);\n            if (item)\n            {\n                item->setValue(batteryPercentage);\n                enqueueEvent(Event(RSensors, RStateBattery, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                if (item->lastSet() == item->lastChanged())\n                {\n                    updated = true;\n                }\n            }\n        }\n        else if (battery != 0)\n        {\n            item = sensor.item(RConfigBattery);\n            // DBG_Assert(item != 0); // expected - no, lumi.ctrl_neutral2\n            if (item)\n            {\n                // 2.7-3.0V taken from:\n                // https://github.com/snalee/Xiaomi/blob/master/devicetypes/a4refillpad/xiaomi-zigbee-button.src/xiaomi-zigbee-button.groovy\n                const float vmin = 2700;\n                const float vmax = 3000;\n                float bat = battery;\n\n                if      (bat > vmax) { bat = vmax; }\n                else if (bat < vmin) { bat = vmin; }\n\n                bat = ((bat - vmin) /(vmax - vmin)) * 100;\n\n                if      (bat > 100) { bat = 100; }\n                else if (bat <= 0)  { bat = 1; } // ?\n\n                item->setValue(quint8(bat));\n                enqueueEvent(Event(RSensors, RConfigBattery, sensor.id(), item));\n\n                if (item->lastSet() == item->lastChanged())\n                {\n                    updated = true;\n                }\n            }\n        }\n\n        if (charging != UINT8_MAX)\n        {\n            item = sensor.item(RStateCharging);\n            if (item)\n            {\n                item->setValue(charging == 1);\n                enqueueEvent(Event(RSensors, RStateCharging, sensor.id(), item));\n                emit q_ptr->nodeUpdated(sensor.address().ext(), QLatin1String(item->descriptor().suffix), QString::number(charging));\n                sensor.updateStateTimestamp();\n                if (item->lastSet() == item->lastChanged())\n                {\n                    updated = true;\n                }\n            }\n        }\n\n        if (temperature != INT16_MIN)\n        {\n            item = sensor.item(RStateTemperature);\n            if (item)\n            {\n                ResourceItem *item2 = sensor.item(RConfigOffset);\n                if (item2 && item2->toNumber() != 0)\n                {\n                    temperature += item2->toNumber();\n                }\n            }\n            else\n            {\n                item = sensor.item(RConfigTemperature);\n            }\n            if (item)\n            {\n                item->setValue(temperature);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n\n                if (item->lastSet() == item->lastChanged())\n                {\n                    updated = true;\n                }\n                if (item->descriptor().suffix == RStateTemperature)\n                {\n                    sensor.updateStateTimestamp();\n                    enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                    updated = true;\n                }\n            }\n        }\n\n        if (humidity != UINT16_MAX)\n        {\n            item = sensor.item(RStateHumidity);\n            if (item)\n            {\n                ResourceItem *item2 = sensor.item(RConfigOffset);\n                if (item2 && item2->toNumber() != 0)\n                {\n                    humidity += item2->toNumber();\n                }\n                item->setValue(humidity);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (pressure != INT16_MIN)\n        {\n            item = sensor.item(RStatePressure);\n            if (item)\n            {\n                ResourceItem *item2 = sensor.item(RConfigOffset);\n                if (item2 && item2->toNumber() != 0)\n                {\n                    pressure += item2->toNumber();\n                }\n                item->setValue(pressure);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (power != UINT32_MAX)\n        {\n            item = sensor.item(RStatePower);\n            if (item)\n            {\n                item->setValue(power);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (consumption != UINT32_MAX)\n        {\n            item = sensor.item(RStateConsumption);\n            if (item)\n            {\n                item->setValue(consumption);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (voltage != UINT32_MAX)\n        {\n            item = sensor.item(RStateVoltage);\n            if (item)\n            {\n                item->setValue(voltage);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (current != UINT32_MAX)\n        {\n            item = sensor.item(RStateCurrent);\n            if (item)\n            {\n                item->setValue(current);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        if (lightlevel != UINT32_MAX &&\n            sensor.type() == QLatin1String(\"ZHALightLevel\") &&\n            sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\n        {\n            updateSensorLightLevel(sensor, lightlevel);\n            updated = true;\n        }\n\n        if (onOff != UINT8_MAX)\n        {   // don't add, just update, useful since door/window and presence sensors otherwise only report on activation\n            item = sensor.item(RStateOpen);\n            item = item ? item : sensor.item(RStatePresence);\n            // item = item ? item : sensor.item(RStateWater);  // lumi.sensor_wleak.aq1, ignore, value is not reliable\n            if (attrId == 0xff02)\n            {\n                // don't update Mija devices\n                // e.g. lumi.sensor_motion always reports 1\n            }\n            else if (sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_motion\")))\n            {\n                // don't update Motion sensor state.\n                // Imcompatibility with delay feature, and not really usefull\n               sensor.updateStateTimestamp();\n               enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n               updated = true;\n            }\n            else if (sensor.modelId().startsWith(QLatin1String(\"lumi.sensor_wleak\")))\n            {\n                // only update state timestamp assuming last known value is valid\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n            else if (item)\n            {\n                item->setValue(onOff);\n                enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n                sensor.updateStateTimestamp();\n                enqueueEvent(Event(RSensors, RStateLastUpdated, sensor.id()));\n                updated = true;\n            }\n        }\n\n        item = sensor.item(RAttrSwVersion);\n        if (item && !firmware.isEmpty() && firmware != item->toString())\n        {\n            item->setValue(firmware);\n            enqueueEvent(Event(RSensors, item->descriptor().suffix, sensor.id(), item));\n            updated = true;\n            Q_Q(DeRestPlugin);\n            emit q->nodeUpdated(sensor.address().ext(), QLatin1String(\"version\"), firmware);\n        }\n        if (item && dateCode.isEmpty() && !item->toString().isEmpty() && !item->toString().startsWith(\"3000\"))\n        {\n            dateCode = item->toString();\n        }\n\n        if (updated)\n        {\n            updateSensorEtag(&sensor);\n            sensor.setNeedSaveDatabase(true);\n            saveDatabaseItems |= DB_SENSORS;\n        }\n    }\n\n    if (searchSensorsState == SearchSensorsActive)\n    {\n        return;\n    }\n\n    if  (!restNodePending)\n    {\n        return;\n    }\n\n    Resource *r = dynamic_cast<Resource*>(restNodePending);\n    DBG_Assert(r != nullptr);\n\n    if (!r)\n    {\n        return;\n    }\n\n    item = r->item(RAttrModelId);\n\n    if (item && item->toString().endsWith(QLatin1String(\"86opcn01\")))\n    {\n        auto *item2 = r->item(RConfigPending);\n\n        if (item2 && (item2->toNumber() & R_PENDING_MODE))\n        {\n            // Aqara switches need to be configured to send proper button events\n            // send the magic word\n            DBG_Printf(DBG_INFO, \"Write Aqara switch 0x%016llX mode attribute 0x0009 = 1\\n\", ind.srcAddress().ext());\n            deCONZ::ZclAttribute attr(0x0009, deCONZ::Zcl8BitUint, QLatin1String(\"mode\"), deCONZ::ZclReadWrite, false);\n            attr.setValue(static_cast<quint64>(1));\n            writeAttribute(restNodePending, 0x01, XIAOMI_CLUSTER_ID, attr, VENDOR_XIAOMI);\n\n            item2->setValue(item2->toNumber() & ~R_PENDING_MODE);\n        }\n    }\n\n    if (dateCode.isEmpty() && restNodePending)\n    {\n        // read datecode, will be applied to all sensors of this device\n        readAttributes(restNodePending, ind.srcEndpoint(), BASIC_CLUSTER_ID, { 0x0006 });\n        return;\n    }\n\n    if (item && item->toString().startsWith(QLatin1String(\"lumi.vibration\")))\n    {\n        ResourceItem *item2 = r->item(RConfigPending);\n        ResourceItem *item3 = r->item(RConfigSensitivity);\n        DBG_Assert(item2);\n        DBG_Assert(item3);\n\n        if (!item3->lastSet().isValid() || item2->toNumber() == 0)\n        {\n            if (readAttributes(restNodePending, ind.srcEndpoint(), BASIC_CLUSTER_ID, { 0xff0d }, VENDOR_XIAOMI))\n            {\n                return;\n            }\n        }\n        else\n        {\n            if (item2 && item2->toNumber() & R_PENDING_SENSITIVITY)\n            {\n                deCONZ::ZclAttribute attr(0xff0d, deCONZ::Zcl8BitUint, \"sensitivity\", deCONZ::ZclReadWrite, true);\n                attr.setValue(static_cast<quint64>(item3->toNumber()));\n\n                if (writeAttribute(restNodePending, ind.srcEndpoint(), BASIC_CLUSTER_ID, attr, VENDOR_XIAOMI))\n                {\n                    item2->setValue(item2->toNumber() & ~R_PENDING_SENSITIVITY);\n                    return;\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "xiaomi.h",
          "type": "blob",
          "size": 0.388671875,
          "content": "#ifndef XIAOMI_H\n#define XIAOMI_H\n\n#define XIAOMI_ATTRID_DEVICE_MODE         0x0009\n#define XIAOMI_ATTRID_SPECIAL_REPORT      0x00F7\n#define XIAOMI_ATTRID_MOTION_SENSITIVITY  0x010C\n#define XIAOMI_ATTRID_P1_MOTION_DETECTION 0x0112\n#define XIAOMI_ATTRID_MULTICLICK_MODE     0x0125\n#define XIAOMI_ATTRID_SPEED               0x0408\n#define XIAOMI_ATTRID_CHARGING            0x0409\n\n#endif // XIAOMI_H\n"
        },
        {
          "name": "xmas.cpp",
          "type": "blob",
          "size": 21.546875,
          "content": "/* Merry Christmas!\n *\n * Handle LIDL Melinera Smart LED lightstrip (for Xmas tree).\n */\n\n#include <math.h>\n#include \"de_web_plugin_private.h\"\n#include \"utils/utils.h\"\n\n#define TUYA_COMMAND_SET 0x00\n\nenum XmasLightStripAttribute\n{\n    AttrOn = 1,\n    AttrMode = 2,\n    AttrBri = 3,\n    AttrColour = 5,\n    AttrEffect = 6\n};\n\nenum XmasLightStripDataType\n{\n    TypeBool = 1,\n    TypeNumber = 2,\n    TypeString = 3,\n    TypeEnum = 4\n};\n\nconst QStringList RStateEffectValuesXmasLightStrip({\n    \"none\",\n    \"steady\", \"snow\", \"rainbow\", \"snake\",\n    \"twinkle\", \"fireworks\", \"flag\", \"waves\",\n    \"updown\", \"vintage\", \"fading\", \"collide\",\n    \"strobe\", \"sparkles\", \"carnival\", \"glow\"\n});\n#define R_EFFECT_NONE               0\n\nstatic void initTask(TaskItem &task, quint8 seq)\n{\n    task.taskType = TaskXmasLightStrip;\n\n    task.req.setClusterId(TUYA_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(seq);\n    task.zclFrame.setCommandId(TUYA_COMMAND_SET); // Set\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCDirectionClientToServer);\n}\n\nstatic void tlvOn(QDataStream &stream, bool on)\n{\n    stream << (quint8) AttrOn;\n    stream << (quint8) TypeBool;\n    stream << (quint16) 1;\n    stream << (quint8) (on ? 1 : 0);\n}\n\nstatic void tlvMode(QDataStream &stream, XmasLightStripMode mode)\n{\n    stream << (quint8) AttrMode;\n    stream << (quint8) TypeEnum;\n    stream << (quint16) 1;\n    stream << (quint8) mode;\n}\n\nstatic void tlvBrightness(QDataStream &stream, quint8 bri)\n{\n    stream << (quint8) AttrBri;\n    stream << (quint8) TypeNumber;\n    stream << (quint16) 4;\n    stream << (quint32) bri * 10;\n}\n\nstatic void tlvColour(QDataStream &stream, quint16 hue, quint8 sat, quint8 bri)\n{\n    char s[13];\n    snprintf(s, sizeof(s), \"%04x%04x%04x\", hue, sat * 10, bri * 10);\n    s[12] = '\\0';\n\n    stream << (quint8) AttrColour;\n    stream << (quint8) TypeString;\n    stream << (quint16) U_StringLength(s);\n    stream.writeRawData(s, U_StringLength(s));\n}\n\nstatic void tlvEffect(QDataStream &stream, XmasLightStripEffect effect, quint8 speed, const QList<QList<quint8>> &colours)\n{\n    char s[41];\n    snprintf(s, sizeof(s), \"%02x%02x\", effect, speed);\n    int i = 4;\n    int j = 0;\n    for (const QList<quint8> &colour: colours)\n    {\n        snprintf(s + i, sizeof(s) - i, \"%02x%02x%02x\", colour[0], colour[1], colour[2]);\n        i += 6;\n        j++;\n        if (j == 6) // write at most 6 entries\n            break;\n    }\n    s[40] = '\\0';\n\n    stream << (quint8) AttrEffect;\n    stream << (quint8) TypeString;\n    stream << (quint16) U_StringLength(s);\n    stream.writeRawData(s, U_StringLength(s));\n}\n\n/*! Check whether LightNode is the LIDL Melinera Smart LED lightstrip.\n    \\param lightNode - the indication primitive\n */\nbool DeRestPluginPrivate::isXmasLightStrip(const LightNode *lightNode)\n{\n    return lightNode != nullptr &&\n           (lightNode->modelId() == QLatin1String(\"HG06467\") ||\n            lightNode->manufacturer() == QLatin1String(\"_TZE200_s8gkrkxk\"));\n}\n\nQString XmasEffectName(quint8 effect)\n{\n    return RStateEffectValuesXmasLightStrip[effect];\n}\n\n/*! Switch the lightstrip on or off.\n    \\param task - the task item\n    \\param on - on (true) or off (false)\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::addTaskXmasLightStripOn(TaskItem &task, bool on)\n{\n    const quint8 seq = zclSeq++;\n    initTask(task, seq);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian); // !\n    stream << (quint8) 0; // Status\n    stream << (quint8) seq; // Transaction ID\n\n    tlvOn(stream, on);\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Switch the lightstrip on or off.\n    \\param task - the task item\n    \\param on - on (true) or off (false)\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::addTaskXmasLightStripMode(TaskItem &task, XmasLightStripMode mode)\n{\n    const quint8 seq = zclSeq++;\n    initTask(task, seq);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian); // !\n    stream << (quint8) 0; // Status\n    stream << (quint8) seq; // Transaction ID\n\n    tlvMode(stream, mode);\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Switch the lightstrip on, set it to white mode, and set the brightness.\n    \\param task - the task item\n    \\param bri - the brightness, between 0 and 100\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::addTaskXmasLightStripWhite(TaskItem &task, quint8 bri)\n{\n    const quint8 seq = zclSeq++;\n    initTask(task, seq);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian); // !\n    stream << (quint8) 0; // Status\n    stream << (quint8) seq; // Transaction ID\n\n    // tlvOn(stream, true);\n    // tlvMode(stream, ModeWhite);\n    tlvBrightness(stream, bri);\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Switch the lightstrip on, set it to colour mode, and set the colour.\n    \\param task - the task item\n    \\param hue - the hue, between 0 and 360\n    \\param sat - the saturation, between 0 and 100\n    \\param bri - the level, between 0 and 100\n    \\note The lightstrip uses HSL values to set the colour and brightness.\n */\nbool DeRestPluginPrivate::addTaskXmasLightStripColour(TaskItem &task, quint16 hue, quint8 sat, quint8 bri)\n{\n    const quint8 seq = zclSeq++;\n    initTask(task, seq);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian); // !\n    stream << (quint8) 0; // Status\n    stream << (quint8) seq; // Transaction ID\n\n    // tlvOn(stream, true);\n    // tlvMode(stream, ModeColour);\n    tlvColour(stream, hue, sat, bri);\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Switch the lightstrip on, set it to effect mode, and set the effect.\n    \\param task - the task item\n    \\param effect - the effect, between 0 and 15\n    \\param speed - the effect speed, between 0 and 100\n    \\param colours - a list of 0 to 6 RGB colours.  Each colour is a list of 3 quint8 values.\n    \\note The lightstrip uses RGB values to set the effect colours.\n */\nbool DeRestPluginPrivate::addTaskXmasLightStripEffect(TaskItem &task, XmasLightStripEffect effect, quint8 speed, const QList<QList<quint8>> &colours)\n{\n    const quint8 seq = zclSeq++;\n    initTask(task, seq);\n\n    // payload\n    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::BigEndian); // !\n    stream << (quint8) 0; // Status\n    stream << (quint8) seq; // Transaction ID\n\n    // tlvOn(stream, true);\n    tlvMode(stream, ModeEffect);\n    tlvEffect(stream, effect, speed, colours);\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Helper to generate a new task with new task and req id based on a reference */\nstatic void copyTaskReq(TaskItem &a, TaskItem &b)\n{\n    b.req.dstAddress() = a.req.dstAddress();\n    b.req.setDstAddressMode(a.req.dstAddressMode());\n    b.req.setSrcEndpoint(a.req.srcEndpoint());\n    b.req.setDstEndpoint(a.req.dstEndpoint());\n    b.req.setRadius(a.req.radius());\n    b.req.setTxOptions(a.req.txOptions());\n    b.req.setSendDelay(a.req.sendDelay());\n    b.transitionTime = a.transitionTime;\n    b.onTime = a.onTime;\n    b.lightNode = a.lightNode;\n}\n\n/*! PUT, PATCH /api/<apikey>/lights/<id>/state for Xmas lights.\n    \\return REQ_READY_SEND\n            REQ_NOT_HANDLED\n */\nint DeRestPluginPrivate::setXmasLightStripState(const ApiRequest &req, ApiResponse &rsp, TaskItem &taskRef, QVariantMap &map)\n{\n    bool ok;\n    QString id = req.path[3];\n\n    bool hasCmd = false;\n    bool isOn = false;\n    bool hasOn = false;\n    bool targetOn = false;\n    bool hasBri = false;\n    quint8 targetBri = 0;\n    bool hasHue = false;\n    quint16 targetHue = 0;\n    bool hasSat = false;\n    quint8 targetSat = 0;\n    int effect = -1;\n    bool hasEffectSpeed = false;\n    quint16 effectSpeed = 50;\n    QList<QList<quint8>> effectColours;\n\n    // Check parameters.\n    const auto mapEnd = map.cend();\n    for (auto p = map.cbegin(); p != mapEnd; ++p)\n    {\n        bool paramOk = false;\n        bool valueOk = false;\n        QString param = p.key();\n        if (param == \"on\" && taskRef.lightNode->item(RStateOn))\n        {\n            paramOk = true;\n            hasCmd = true;\n            if (map[param].type() == QVariant::Bool)\n            {\n                valueOk = true;\n                hasOn = true;\n                targetOn = map[param].toBool();\n            }\n        }\n        else if (param == \"bri\" && taskRef.lightNode->item(RStateBri))\n        {\n            paramOk = true;\n            hasCmd = true;\n            if (map[param].type() == QVariant::Double)\n            {\n                const uint bri = map[param].toUInt(&ok);\n                if (ok && bri <= 0xFF)\n                {\n                    valueOk = true;\n                    hasBri = true;\n                    targetBri = bri > 0xFE ? 0xFE : bri;\n                }\n            }\n        }\n        else if (param == \"hue\" && taskRef.lightNode->item(RStateHue) && taskRef.lightNode->item(RStateSat))\n        {\n            paramOk = true;\n            hasCmd = true;\n            if (map[param].type() == QVariant::Double)\n            {\n                const uint hue = map[param].toUInt(&ok);\n                if (ok && hue <= 0xFFFF)\n                {\n                    valueOk = true;\n                    hasHue = true;\n                    targetHue = hue; // Funny: max CurrentHue is 0xFE, max EnhancedCurrentHue is 0xFFFF\n                }\n            }\n        }\n        else if (param == \"sat\" && taskRef.lightNode->item(RStateHue) && taskRef.lightNode->item(RStateSat))\n        {\n            paramOk = true;\n            hasCmd = true;\n            if (map[param].type() == QVariant::Double)\n            {\n                const uint sat = map[param].toUInt(&ok);\n                if (ok && sat <= 0xFF)\n                {\n                    valueOk = true;\n                    hasSat = true;\n                    targetSat = sat > 0xFE ? 0xFE : sat;\n                }\n            }\n        }\n        else if (param == \"effect\" && taskRef.lightNode->item(RStateEffect))\n        {\n            paramOk = true;\n            hasCmd = true;\n            if (map[param].type() == QVariant::String)\n            {\n                effect = RStateEffectValuesXmasLightStrip.indexOf(map[param].toString());\n                valueOk = effect >= 0;\n            }\n        }\n        else if (param == \"effectSpeed\" && taskRef.lightNode->item(RStateEffect))\n        {\n            paramOk = true;\n            if (map[param].type() == QVariant::Double)\n            {\n                const uint speed = map[param].toUInt(&ok);\n                if (ok && speed <= 100)\n                {\n                    valueOk = true;\n                    effectSpeed = speed < 1 ? 1 : speed;\n                }\n            }\n        }\n        else if (param == \"effectColours\" && taskRef.lightNode->item(RStateEffect))\n        {\n            paramOk = true;\n            ok = true;\n            if (map[param].type() == QVariant::List)\n            {\n                const QVariantList colours = map[\"effectColours\"].toList();\n                if (colours.length() <= 6)\n                {\n                    for (const QVariant &colour: colours)\n                    {\n                        if (colour.type() == QVariant::List)\n                        {\n                            QVariantList rgb = colour.toList();\n                            if (rgb.length() != 3)\n                            {\n                                ok = false;\n                                break;\n                            }\n                            const uint r = rgb[0].toUInt(&ok);\n                            if (!ok)\n                            {\n                                break;\n                            }\n                            const uint g = rgb[1].toUInt(&ok);\n                            if (!ok)\n                            {\n                                break;\n                            }\n                            const uint b = rgb[2].toUInt(&ok);\n                            if (!ok)\n                            {\n                                break;\n                            }\n                            if (r > 0xFF || g > 0xFF || b > 0xFF)\n                            {\n                                ok = false;\n                                break;\n                            }\n                            effectColours.push_back({(quint8) r, (quint8) g, (quint8) b});\n                        }\n                    }\n                    if (ok)\n                    {\n                        valueOk = true;\n                    }\n                    else\n                    {\n                        effectColours = {};\n                    }\n                }\n            }\n        }\n        if (!paramOk)\n        {\n            rsp.list.append(errorToMap(ERR_PARAMETER_NOT_AVAILABLE, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, %1, not available\").arg(param)));\n        }\n        else if (!valueOk)\n        {\n            rsp.list.append(errorToMap(ERR_INVALID_VALUE, QString(\"/lights/%1/state\").arg(id), QString(\"invalid value, %1, for parameter, %2\").arg(map[param].toString()).arg(param)));\n        }\n    }\n    if (taskRef.onTime > 0 && !hasOn)\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, on, for parameter, ontime\")));\n    }\n    if (hasEffectSpeed && effect < 1)\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, effect, for parameter, effectSpeed\")));\n    }\n    if (effectColours.length() > 0 && effect < 1)\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter, effect, for parameter, effectSpeed\")));\n    }\n    if (!hasCmd)\n    {\n        rsp.list.append(errorToMap(ERR_MISSING_PARAMETER, QString(\"/lights/%1/state\").arg(id), QString(\"missing parameter to set light state\")));\n    }\n\n    // Check whether light is on.\n    isOn = taskRef.lightNode->toBool(RStateOn);\n\n    // state.on: true\n    if (hasOn && targetOn)\n    {\n        TaskItem task;\n        copyTaskReq(taskRef, task);\n\n        if (addTaskSetOnOff(task, ONOFF_COMMAND_ON, 0, 0))\n        {\n            isOn = true;\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = true;\n            rspItem[\"success\"] = rspItemState;\n            rsp.list.append(rspItem);\n            taskRef.lightNode->setValue(RStateOn, targetOn);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/on\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n        }\n    }\n\n    if (effect >= 0)\n    {\n        TaskItem task;\n        copyTaskReq(taskRef, task);\n\n        if (!isOn) {\n            rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, effect, is not modifiable. Device is set to off.\")));\n        }\n        if (effect == R_EFFECT_NONE)\n        {\n            if (!hasSat)\n            {\n                targetSat = taskRef.lightNode->toNumber(RStateSat);\n            }\n            ok = addTaskXmasLightStripMode(task, targetSat > 0 ? ModeColour : ModeWhite);\n        }\n        else\n        {\n            ok = addTaskXmasLightStripEffect(task, XmasLightStripEffect(effect - 1), effectSpeed, effectColours);\n        }\n        if (ok)\n        {\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[QString(\"/lights/%1/state/effect\").arg(id)] = RStateEffectValuesXmasLightStrip[effect];\n            rspItem[\"success\"] = rspItemState;\n            rsp.list.append(rspItem);\n\n            taskRef.lightNode->setValue(RStateEffect, RStateEffectValuesXmasLightStrip[effect]);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/effect\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n        }\n    }\n\n    if ((hasBri || hasHue || hasSat) && effect <= 0)\n    {\n        TaskItem task;\n        copyTaskReq(taskRef, task);\n\n        if (!isOn)\n        {\n            if (hasHue)\n            {\n                rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, hue, is not modifiable. Device is set to off.\")));\n            }\n            if (hasSat)\n            {\n                rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, sat, is not modifiable. Device is set to off.\")));\n            }\n            if (hasBri)\n            {\n                rsp.list.append(errorToMap(ERR_DEVICE_OFF, QString(\"/lights/%1/state\").arg(id), QString(\"parameter, bri, is not modifiable. Device is set to off.\")));\n            }\n        }\n        if (!hasHue) // only state.sat\n        {\n            targetHue = taskRef.lightNode->toNumber(RStateHue);\n        }\n        if (!hasSat) // only state.hue\n        {\n            targetSat = taskRef.lightNode->toNumber(RStateSat);\n        }\n        if (!hasBri)\n        {\n            targetBri = taskRef.lightNode->toNumber(RStateBri);\n        }\n\n        if (targetSat == 0)\n        {\n            quint8 bri = round(targetBri * 100.0 / 0xFF);\n            ok = addTaskXmasLightStripWhite(task, bri);\n        }\n        else\n        {\n            quint16 h = round(targetHue * 360.0 / 0xFFFF);\n            quint8 s = round(targetSat * 100.0 / 0xFF);\n            quint8 l = round(targetBri * 100.0 / 0xFF);\n            ok = addTaskXmasLightStripColour(task, h, s, l);\n        }\n        if (ok)\n        {\n            if (hasBri)\n            {\n                QVariantMap rspItem;\n                QVariantMap rspItemState;\n                rspItemState[QString(\"/lights/%1/state/bri\").arg(id)] = targetBri;\n                rspItem[\"success\"] = rspItemState;\n                rsp.list.append(rspItem);\n\n                taskRef.lightNode->setValue(RStateBri, targetBri);\n            }\n            if (hasHue)\n            {\n                QVariantMap rspItem;\n                QVariantMap rspItemState;\n                rspItemState[QString(\"/lights/%1/state/hue\").arg(id)] = targetHue;\n                rspItem[\"success\"] = rspItemState;\n                rsp.list.append(rspItem);\n\n                taskRef.lightNode->setValue(RStateHue, targetHue);\n            }\n            if (hasSat)\n            {\n                QVariantMap rspItem;\n                QVariantMap rspItemState;\n                rspItemState[QString(\"/lights/%1/state/sat\").arg(id)] = targetSat;\n                rspItem[\"success\"] = rspItemState;\n                rsp.list.append(rspItem);\n\n                taskRef.lightNode->setValue(RStateSat, targetSat);\n            }\n            taskRef.lightNode->setValue(RStateEffect, RStateEffectValuesXmasLightStrip[R_EFFECT_NONE]);\n        }\n        else\n        {\n            if (hasBri)\n            {\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/bri\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n            }\n            if (hasHue)\n            {\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/hue\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n            }\n            if (hasSat)\n            {\n                rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/sat\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n            }\n        }\n    }\n\n    // state.on: false\n    if (hasOn && !targetOn)\n    {\n        TaskItem task;\n        copyTaskReq(taskRef, task);\n\n        if (addTaskSetOnOff(task, ONOFF_COMMAND_OFF, 0, 0))\n        {\n            QVariantMap rspItem;\n            QVariantMap rspItemState;\n            rspItemState[QString(\"/lights/%1/state/on\").arg(id)] = targetOn;\n            rspItem[\"success\"] = rspItemState;\n            rsp.list.append(rspItem);\n            taskRef.lightNode->setValue(RStateOn, targetOn);\n        }\n        else\n        {\n            rsp.list.append(errorToMap(ERR_INTERNAL_ERROR, QString(\"/lights/%1/state/on\").arg(id), QString(\"Internal error, %1\").arg(ERR_BRIDGE_BUSY)));\n        }\n    }\n\n    rsp.etag = taskRef.lightNode->etag;\n    processTasks();\n    return REQ_READY_SEND;\n}\n"
        },
        {
          "name": "zcl",
          "type": "tree",
          "content": null
        },
        {
          "name": "zcl_tasks.cpp",
          "type": "blob",
          "size": 48.5390625,
          "content": "/*\n * Copyright (c) 2013-2019 dresden elektronik ingenieurtechnik gmbh.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n */\n\n#include <QString>\n#include <QVariantMap>\n#include <math.h>\n#include \"de_web_plugin.h\"\n#include \"de_web_plugin_private.h\"\n#include \"colorspace.h\"\n#include \"device_descriptions.h\"\n\n/** @brief Min of A and B */\n#define MIN(A,B)\t(((A) <= (B)) ? (A) : (B))\n\n/** @brief Max of A and B */\n#define MAX(A,B)\t(((A) >= (B)) ? (A) : (B))\n\n/** @brief Min of A, B, and C */\n#define MIN3(A,B,C)\t(((A) <= (B)) ? MIN(A,C) : MIN(B,C))\n\n/** @brief Max of A, B, and C */\n#define MAX3(A,B,C)\t(((A) >= (B)) ? MAX(A,C) : MAX(B,C))\n\n/*! Add a MoveLevel task to the queue\n\n    \\param task - the task item\n    \\param withOnOff - if true command is send with on/off\n    \\param upDirection - true is up, false is down\n    \\param rate - the move rate\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::addTaskMoveLevel(TaskItem &task, bool withOnOff, bool upDirection, quint8 rate)\n{\n    task.taskType = TaskMoveLevel;\n\n    task.req.setClusterId(LEVEL_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    if (rate > 0)\n    {\n        if (withOnOff)\n        {\n            task.zclFrame.setCommandId(0x05); // move level with on/off\n        }\n        else\n        {\n            task.zclFrame.setCommandId(0x01); // move level\n        }\n    }\n    else\n    {\n        task.zclFrame.setCommandId(0x03); // stop\n    }\n\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n\n    if (rate > 0)\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        quint8 direction = upDirection ? 0x00 : 0x01;\n        stream << direction;\n        stream << rate;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a OnOff task to the queue\n *\n * \\param task - the task item\n * \\param cmd - command to send ONOFF_COMMAND_ON, ONOFF_COMMAND_OFF, ONOFF_COMMAND_TOGGLE or ONOFF_COMMAND_ON_WITH_TIMED_OFF\n * \\param ontime - ontime, used only for command ONOFF_COMMAND_ON_WITH_TIMED_OFF\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetOnOff(TaskItem &task, quint8 cmd, quint16 ontime, quint8 flags)\n{\n    DBG_Assert(cmd == ONOFF_COMMAND_ON || cmd == ONOFF_COMMAND_OFF || cmd == ONOFF_COMMAND_TOGGLE || cmd == ONOFF_COMMAND_OFF_WITH_EFFECT || cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF);\n    if (!(cmd == ONOFF_COMMAND_ON || cmd == ONOFF_COMMAND_OFF || cmd == ONOFF_COMMAND_TOGGLE || cmd == ONOFF_COMMAND_OFF_WITH_EFFECT || cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF))\n    {\n        return false;\n    }\n\n    if (task.lightNode && task.lightNode->parentResource())\n    {\n        Device *device = static_cast<Device*>(task.lightNode->parentResource());\n\n        if (device && device->managed())\n        {\n            uint target = 0;\n            ResourceItem *onItem = task.lightNode->item(RStateOn);\n            const auto ddfItem = DDF_GetItem(onItem);\n\n            if (cmd == ONOFF_COMMAND_ON || cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF)\n            {\n                target = 1;\n            }\n\n            if (!ddfItem.writeParameters.isNull())\n            {\n                StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, task.req.dstEndpoint());\n                change.addTargetValue(RStateOn, target);\n                task.lightNode->addStateChange(change);\n                return true;\n            }\n            else // only verify after classic command\n            {\n                StateChange change(StateChange::StateWaitSync, SC_SetOnOff, task.req.dstEndpoint());\n                change.addTargetValue(RStateOn, target);\n                change.addParameter(QLatin1String(\"cmd\"), cmd);\n                if (cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF)\n                {\n                    change.addParameter(QLatin1String(\"ontime\"), ontime);\n                }\n                task.lightNode->addStateChange(change);\n            }\n        }\n    }\n\n    task.taskType = TaskSendOnOffToggle;\n    task.onOff = cmd == ONOFF_COMMAND_ON || cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF; // FIXME - what about ONOFF_COMMAND_TOGGLE ?!\n\n    task.req.setClusterId(ONOFF_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(cmd);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    if (cmd == ONOFF_COMMAND_OFF_WITH_EFFECT)\n    {\n        const quint8 effect = 0;\n        const quint8 variant = 0;\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        stream << effect;\n        stream << variant;\n    }\n    else if (cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF)\n    {\n        const quint16 offWaitTime = 0;\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        // stream << (quint8)0x80; // 0x01 accept only when on --> no, 0x80 overwrite ontime (yes, non standard)\n        stream << flags;\n        stream << ontime;\n        stream << offWaitTime;\n    }\n\n\n    task.req.asdu().clear(); // cleanup old request data if there is any\n    QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n    stream.setByteOrder(QDataStream::LittleEndian);\n    task.zclFrame.writeToStream(stream);\n\n    return addTask(task);\n}\n\n/*!\n * Add a brightness task to the queue\n *\n * \\param task - the task item\n * \\param bri - brightness level 0..255\n * \\param withOnOff - also set onOff state\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetBrightness(TaskItem &task, uint8_t bri, bool withOnOff)\n{\n    if (task.lightNode && task.lightNode->parentResource())\n    {\n        Device *device = static_cast<Device*>(task.lightNode->parentResource());\n\n        if (device && device->managed())\n        {\n            uint target = bri;\n            ResourceItem *briItem = task.lightNode->item(RStateBri);\n            const auto ddfItem = DDF_GetItem(briItem);\n\n            if (!ddfItem.writeParameters.isNull())\n            {\n                if (withOnOff) // onoff is a dependency, check if there is a write funtion for it\n                {\n                    ResourceItem *onItem = task.lightNode->item(RStateOn);\n                    const auto ddfItem2 = DDF_GetItem(onItem);\n\n                    if (!ddfItem2.writeParameters.isNull())\n                    {\n                        StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, task.req.dstEndpoint());\n                        change.addTargetValue(RStateOn, bri > 0 ? 1 : 0);\n                        task.lightNode->addStateChange(change);\n                    }\n                }\n\n                StateChange change(StateChange::StateCallFunction, SC_WriteZclAttribute, task.req.dstEndpoint());\n                change.addTargetValue(RStateBri, target);\n                task.lightNode->addStateChange(change);\n                return true;\n            }\n        }\n    }\n\n    task.taskType = TaskSetLevel;\n    task.level = bri;\n    task.onOff = withOnOff; // FIXME abuse of taks.onOff\n    task.req.setClusterId(LEVEL_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    if (withOnOff)\n    {\n        task.zclFrame.setCommandId(0x04); // Move to level (with on/off)\n    }\n    else\n    {\n        task.zclFrame.setCommandId(0x00); // Move to level\n    }\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.level;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a color temperature increase task to the queue\n *\n * \\param task - the task item\n * \\param ct - step size -65534 ..65534, 0 to stop running step\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskIncColorTemperature(TaskItem &task, int32_t ct)\n{\n    task.taskType = TaskIncColorTemperature;\n\n    task.inc = ct;\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n\n    if (ct == 0)\n    {\n        task.zclFrame.setCommandId(0x47); // Stop move step\n    }\n    else\n    { // payload\n        task.zclFrame.setCommandId(0x4C); // Step color temperature\n\n        quint8 direction = ct > 0 ? 1 : 3; // up, down\n        quint16 stepSize = ct > 0 ? ct : -ct;\n\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << direction;\n        stream << stepSize;\n        stream << task.transitionTime;\n        stream << (quint16)0; // min dummy\n        stream << (quint16)0; // max dummy\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a brightness increase task to the queue\n *\n * \\param task - the task item\n * \\param bri - step size -254 ..254, 0 to stop running step\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskIncBrightness(TaskItem &task, int16_t bri)\n{\n    task.taskType = TaskIncBrightness;\n\n    task.inc = bri;\n    task.req.setClusterId(LEVEL_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    if (bri == 0)\n    {\n        task.zclFrame.setCommandId(0x03); // Stop\n    }\n    else\n    { // payload\n        task.zclFrame.setCommandId(0x02); // Step level\n        quint8 mode = bri > 0 ? 0 : 1; // up, down\n        quint8 stepSize = (bri > 0) ? bri : bri * -1;\n\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << mode;\n        stream << stepSize;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set color temperature task to the queue\n *\n * \\param task - the task item\n * \\param ct - mired color temperature\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetColorTemperature(TaskItem &task, uint16_t ct)\n{\n    // Workaround for interim FLS-H\n    // which does not support the color temperature ZCL command\n    if (task.lightNode && (task.lightNode->manufacturerCode() == VENDOR_ATMEL) && (task.lightNode->modelId() == \"FLS-H\"))\n    {\n        float ctMin = 153;\n        float ctMax = 500;\n        float sat = (static_cast<float>(ct) - ctMin) / (ctMax - ctMin) * 254;\n        if (sat > 254)\n        {\n            sat = 254;\n        }\n\n        bool ret = addTaskSetSaturation(task, static_cast<quint8>(sat));\n        // overwrite for later use\n        task.taskType = TaskSetColorTemperature;\n        task.colorTemperature = ct;\n        if (task.lightNode)\n        {\n            if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"ct\"))\n            {\n                task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"ct\")));\n            }\n        }\n        return ret;\n    }\n\n    if (task.lightNode)\n    {\n        ResourceItem *ctMin = task.lightNode->item(RCapColorCtMin);\n        ResourceItem *ctMax = task.lightNode->item(RCapColorCtMax);\n\n        // keep ct in supported bounds\n        if (ctMin && ctMax && ctMin->toNumber() > 0 && ctMax->toNumber() > 0)\n        {\n            if      (ct < ctMin->toNumber()) { ct = static_cast<quint16>(ctMin->toNumber()); }\n            else if (ct > ctMax->toNumber()) { ct = static_cast<quint16>(ctMax->toNumber()); }\n        }\n\n        if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"ct\"))\n        {\n            task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"ct\")));\n        }\n\n        // If light does not support \"ct\" but does suport \"xy\", we can emulate the former:\n        ResourceItem *colorCaps = task.lightNode->item(RCapColorCapabilities);\n        bool supportsXy = colorCaps && colorCaps->toNumber() & 0x0008;\n        bool supportsCt = colorCaps && colorCaps->toNumber() & 0x0010;\n        bool useXy = supportsXy && !supportsCt;\n\n        if (useXy)\n        {\n            quint16 x;\n            quint16 y;\n            MiredColorTemperatureToXY(ct, &x, &y);\n            qreal xr = x / 65535.0;\n            qreal yr = y / 65535.0;\n            if      (xr < 0) { xr = 0; }\n            else if (xr > 1) { xr = 1; }\n            if      (yr < 0) { yr = 0; }\n            else if (yr > 1) { yr = 1; }\n            return addTaskSetXyColor(task, xr, yr);\n        }\n\n        DBG_Printf(DBG_INFO, \"send move to color temperature %u to 0x%016llX\\n\", ct, task.lightNode->address().ext());\n    }\n\n    task.taskType = TaskSetColorTemperature;\n    task.colorTemperature = ct;\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x0a); // Move to color temperature\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.colorTemperature;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set enhanced hue task to the queue\n *\n * \\param task - the task item\n * \\param hue - brightness level 0..65535\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetEnhancedHue(TaskItem &task, uint16_t hue)\n{\n    task.taskType = TaskSetEnhancedHue;\n    task.hueReal = hue / (360.0 * 182.04444);\n\n    if (task.lightNode)\n    {\n        if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"hs\"))\n        {\n            task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"hs\")));\n        }\n    }\n\n    if (task.hueReal < 0.0)\n    {\n        task.hueReal = 0.0;\n    }\n    else if (task.hueReal > 1.0)\n    {\n        task.hueReal = 1.0;\n    }\n    task.hue = static_cast<quint8>(task.hueReal * 254.0);\n//    task.enhancedHue = hue * 360.0 * 182.04444;\n    task.enhancedHue = hue;\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x40); // Enhanced move to hue\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        uint8_t direction = 0x00;\n        stream << task.enhancedHue;\n        stream << direction;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set saturation task to the queue\n *\n * \\param task - the task item\n * \\param sat - brightness level 0..255\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetSaturation(TaskItem &task, uint8_t sat)\n{\n    task.taskType = TaskSetSat;\n    task.sat = sat;\n\n    if (task.lightNode)\n    {\n        if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"hs\"))\n        {\n            task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"hs\")));\n        }\n    }\n\n    if (sat == 255)\n    {\n        sat = 254;\n    }\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x03); // Move to saturation\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.sat;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set hue and saturation task to the queue\n *\n * \\param task - the task item\n * \\param sat - brightness level 0..254\n * \\param hue - hue 0..254\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetHueAndSaturation(TaskItem &task, uint8_t hue, uint8_t sat)\n{\n    task.taskType = TaskSetHueAndSaturation;\n    task.sat = sat;\n    task.hue = hue;\n    task.hueReal = hue / 254.0;\n    task.enhancedHue = static_cast<quint16>(task.hueReal * 360.0 * 182.04444);\n\n    if (task.lightNode)\n    {\n        if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"hs\"))\n        {\n            task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"hs\")));\n        }\n    }\n\n    if (sat == 255)\n    {\n        sat = 254;\n    }\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x06); // Move to hue and saturation\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.hue;\n        stream << task.sat;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set xy color task but as hue and saturation task to the queue\n *\n * \\param task - the task item\n * \\param x - normalized x coordinate  0.0 .. 1.0\n * \\param y - normalized y coordinate  0.0 .. 1.0\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetXyColorAsHueAndSaturation(TaskItem &task, double x, double y)\n{\n    num r, g, b;\n    num h, s, v;\n    num X, Y, Z;\n\n    // prevent division through zero\n    if (x <= 0.0) {\n        x = 0.00000001;\n    }\n\n    // prevent division through zero\n    if (y <= 0.0) {\n        y = 0.00000001;\n    }\n\n    if (task.lightNode)\n    {\n        ResourceItem *item = task.lightNode->item(RStateBri);\n        if (item)\n        {\n            Y = item->toNumber() / 255.0;\n        }\n        else\n        {\n            Y = 1.0;\n        }\n    }\n    else {\n        Y = 1.0;\n    }\n    X = (Y / y) * x;\n    Z = (Y / y) * (1.0 - x - y);\n\n    num min = MIN3(X,Y,Z);\n    if (min < 0)\n    {\n        X += min;\n        Y += min;\n        Z += min;\n    }\n\n    num max = MAX3(X,Y,Z);\n    if (max > 1)\n    {\n        X /= max;\n        Y /= max;\n        Z /= max;\n    }\n\n    DBG_Printf(DBG_INFO, \"xy = (%f, %f), XYZ = (%f, %f, %f)\\n\",x, y,  X, Y, Z);\n\n    r = (num)( 3.2406*X - 1.5372*Y - 0.4986*Z);\n    g = (num)(-0.9689*X + 1.8758*Y + 0.0415*Z);\n    b = (num)( 0.0557*X - 0.2040*Y + 1.0570*Z);\n\n    // clip\n    if (r > 1) r = 1;\n    if (r < 0) r = 0;\n    if (g > 1) g = 1;\n    if (g < 0) g = 0;\n    if (b > 1) b = 1;\n    if (b < 0) b = 0;\n\n    Rgb2Hsv(&h, &s, &v, r, g, b);\n\n    // normalize\n    h /= 360.0;\n\n    if (h > 1.0)\n    {\n        h = 1.0;\n    }\n    else if (h < 0.0)\n    {\n        h = 0.0;\n    }\n\n    uint8_t hue = h * 254.0;\n    uint8_t sat = s * 254.0;\n\n    return addTaskSetHueAndSaturation(task, hue, sat);\n}\n\n/*!\n * Add a set xy color task to the queue\n *\n * \\param task - the task item\n * \\param x - normalized x coordinate  0.0 .. 1.0\n * \\param y - normalized y coordinate  0.0 .. 1.0\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetXyColor(TaskItem &task, double x, double y)\n{\n    task.taskType = TaskSetXyColor;\n    DBG_Assert(x >= 0);\n    DBG_Assert(x <= 1);\n    DBG_Assert(y >= 0);\n    DBG_Assert(y <= 1);\n    // The CurrentX attribute contains the current value of the normalized chromaticity value x\n    // The value of x SHALL be related to the CurrentX attribute by the relationship\n    // x = CurrentX / 65536 (CurrentX in the range 0 to 65279 inclusive)\n\n    task.colorX = static_cast<quint16>(x * 65535.0); // current X in range 0 .. 65279\n    task.colorY = static_cast<quint16>(y * 65535.0); // current Y in range 0 .. 65279\n\n    if (task.colorX > 65279) { task.colorX = 65279; }\n    else if (task.colorX == 0) { task.colorX = 1; }\n\n    if (task.colorY > 65279) { task.colorY = 65279; }\n    else if (task.colorY == 0) { task.colorY = 1; }\n\n    if (task.lightNode)\n    {\n        if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"xy\"))\n        {\n            task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"xy\")));\n        }\n\n        // convert xy coordinates to hue and saturation\n        // due the old FLS-PP don't support this mode\n        if (task.lightNode->manufacturerCode() == VENDOR_ATMEL && task.lightNode->modelId() == QLatin1String(\"FLS-PP\"))\n        {\n            task.lightNode->setValue(RStateX, task.colorX); // update here\n            task.lightNode->setValue(RStateY, task.colorY); // update here\n            return addTaskSetXyColorAsHueAndSaturation(task, x, y);\n        }\n    }\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x07); // Move to color\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.colorX;\n        stream << task.colorY;\n        stream << task.transitionTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*!\n * Add a set color loop task to the queue\n *\n * \\param task - the task item\n * \\param colorLoopActive - wherever the color loop shall be activated\n * \\param speed - time in seconds for a whole color loop cycle\n * \\return true - on success\n *         false - on error\n */\nbool DeRestPluginPrivate::addTaskSetColorLoop(TaskItem &task, bool colorLoopActive, uint8_t speed)\n{\n    task.colorLoop = colorLoopActive;\n    task.taskType = TaskSetColorLoop;\n\n    if (task.lightNode)\n    {\n        if (!task.lightNode->supportsColorLoop())\n        {\n            return false;\n        }\n\n        task.lightNode->setColorLoopActive(colorLoopActive);\n        task.lightNode->setColorLoopSpeed(speed);\n        if (colorLoopActive)\n        {\n            if (task.lightNode->toString(RStateColorMode) != QLatin1String(\"hs\"))\n            {\n                task.lightNode->setValue(RStateColorMode, QString(QLatin1String(\"hs\")));\n            }\n        }\n    }\n\n    task.req.setClusterId(COLOR_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x44); // Color loop set\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        uint8_t updateFlags = 0x07; // update action 0x1, direction 0x02, time 0x04\n        uint8_t action = colorLoopActive ? 0x02 /* activate color loop from current hue */\n                                         : 0x00 /* stop color loop */;\n        uint8_t direction = 0x01; // up\n        uint16_t time = speed; // seconds to go through whole color loop. default: 15\n        uint16_t startHue = 0; // start hue\n\n        stream << updateFlags;\n        stream << action;\n        stream << direction;\n        stream << time;\n        stream << startHue;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a identify task to the queue.\n\n   \\param task - the task item\n   \\param identifyTime - the time in seconds to identify\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskIdentify(TaskItem &task, uint16_t identifyTime)\n{\n    task.taskType = TaskIdentify;\n    task.identifyTime = identifyTime;\n\n    task.req.setClusterId(IDENTIFY_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x00); // Identify\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.identifyTime;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a trigger effect task to the queue.\n\n   \\param task - the task item\n   \\param effectIdentifier - the effect\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskTriggerEffect(TaskItem &task, uint8_t effectIdentifier)\n{\n    task.taskType = TaskTriggerEffect;\n    task.effectIdentifier = effectIdentifier;\n\n    task.req.setClusterId(IDENTIFY_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x40); // Trigger Effect\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.effectIdentifier;\n        stream << (uint8_t) 0x00; // default effectVariant\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a warning task to the queue.\n\n   \\param task - the task item\n   \\param options - the options\n   \\param duration - the duration\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskWarning(TaskItem &task, uint8_t options, uint16_t duration)\n{\n    task.taskType = TaskWarning;\n    task.options = options;\n    task.duration = duration;\n    uint8_t strobe_duty_cycle = 10;\n    uint8_t strobe_level = 0;\n\n    task.req.setClusterId(IAS_WD_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x00); // Start Warning\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.options;\n        stream << task.duration;\n        stream << strobe_duty_cycle;\n        stream << strobe_level;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n// Danalock support. To control the lock from the REST API, you need to create a new routine addTaskDoorLock() in zcl_tasks.cpp, cf. the addTaskWarning() I created to control the Siren.\n// Based on a lock state parameter, add a task with a Lock Door or Unlock Door command\n/*! Add door unlock task to the queue.\n\n    \\param task - the task item\n    \\return true - on success\n            false - on error\n */\nbool DeRestPluginPrivate::addTaskDoorLockUnlock(TaskItem &task, uint8_t cmd)\n{\n    task.taskType = TaskDoorLock;\n\n    task.req.setClusterId(DOOR_LOCK_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(cmd); // Start Unlocking\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a add to group task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group to which a node shall be added\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskAddToGroup(TaskItem &task, uint16_t groupId)\n{\n    task.taskType = TaskAddToGroup;\n    task.groupId = groupId;\n\n    task.req.setClusterId(GROUP_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x00); // Add to group\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.groupId;\n        uint8_t cstrlen = 0;\n        stream << cstrlen; // mandatory parameter\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a view group task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group which shall be viewed\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskViewGroup(TaskItem &task, uint16_t groupId)\n{\n    task.taskType = TaskViewGroup;\n    task.groupId = groupId;\n\n    task.req.setClusterId(GROUP_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x01); // View group\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.groupId;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Add a remove from group task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group from which a node shall be removed\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskRemoveFromGroup(TaskItem &task, uint16_t groupId)\n{\n    task.taskType = TaskRemoveFromGroup;\n    task.groupId = groupId;\n\n    task.req.setClusterId(GROUP_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x03); // Remove from group\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << task.groupId;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n\n/*! Adds a store scene task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group to which the scene belongs\n   \\param sceneId - the scene which shall be added\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskStoreScene(TaskItem &task, uint16_t groupId, uint8_t sceneId)\n{\n    task.taskType = TaskStoreScene;\n\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x04); // store scene\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << groupId;\n        stream << sceneId;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    DBG_Printf(DBG_INFO, \"add store scene task, aps-req-id: %u\\n\", task.req.id());\n    return addTask(task);\n}\n\n/*! Adds a add scene task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group to which the scene belongs\n   \\param sceneId - the scene which shall be added\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskAddEmptyScene(TaskItem &task, quint16 groupId, quint8 sceneId, quint16 transitionTime)\n{\n    task.taskType = TaskAddScene;\n    task.groupId = groupId;\n    task.sceneId = sceneId;\n    task.transitionTime = transitionTime;\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                  deCONZ::ZclFCDirectionClientToServer |\n                                  deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        if (transitionTime >= 10)\n        {\n            task.zclFrame.setCommandId(0x00); // add scene\n            transitionTime = floor(transitionTime / 10); //deci-seconds -> seconds\n        }\n        else\n        {\n            task.zclFrame.setCommandId(0x40); // enhanced add scene\n        }\n\n        stream << groupId;\n        stream << sceneId;\n        stream << transitionTime;\n\n        stream << (uint8_t)0x00; // length of name\n        //stream << i->name;     // name not supported\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    queryTime = queryTime.addSecs(2);\n    return addTask(task);\n}\n\n/*! Adds a add scene task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group to which the scene belongs\n   \\param sceneId - the scene which shall be added\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskAddScene(TaskItem &task, uint16_t groupId, uint8_t sceneId, const QString &lightId)\n{\n    DBG_Assert(task.lightNode);\n    if (!task.lightNode)\n    {\n        return false;\n    }\n\n    Group *group = getGroupForId(groupId);\n\n    std::vector<Scene>::iterator i = group->scenes.begin();\n    std::vector<Scene>::iterator end = group->scenes.end();\n\n    for ( ;i != end; ++i)\n    {\n        if (i->id == sceneId && i->state != Scene::StateDeleted)\n        {\n            std::vector<LightState>::iterator l = i->lights().begin();\n            std::vector<LightState>::iterator lend = i->lights().end();\n\n            for ( ;l != lend; ++l)\n            {\n                if (l->lid() != lightId)\n                {\n                    continue;\n                }\n\n                task.taskType = TaskAddScene;\n\n                task.req.setClusterId(SCENE_CLUSTER_ID);\n                task.req.setProfileId(HA_PROFILE_ID);\n\n                task.zclFrame.payload().clear();\n                task.zclFrame.setSequenceNumber(zclSeq++);\n\n                task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                                              deCONZ::ZclFCDirectionClientToServer |\n                                              deCONZ::ZclFCDisableDefaultResponse);\n\n                { // payload\n                    QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n                    stream.setByteOrder(QDataStream::LittleEndian);\n\n                    uint8_t on = (l->on()) ? 0x01 : 0x00;\n                    uint16_t tt;\n\n                    if (l->transitionTime() >= 10)\n                    {\n                        task.zclFrame.setCommandId(0x00); // add scene\n                        tt = floor(l->transitionTime() / 10); //deci-seconds -> seconds\n                    }\n                    else\n                    {\n                        task.zclFrame.setCommandId(0x40); // enhanced add scene\n                        tt = l->transitionTime();\n                    }\n\n                    stream << groupId;\n                    stream << sceneId;\n                    stream << tt;\n\n                    stream << (uint8_t)0x00; // length of name\n                    //stream << i->name;     // name not supported\n                    stream << (uint16_t)0x0006; // on/off cluster\n                    stream << (uint8_t)0x01;\n                    stream << on;\n                    stream << (uint16_t)0x0008; // level cluster\n                    stream << (uint8_t)0x01;\n                    stream << l->bri();\n\n                    ResourceItem *item = task.lightNode->item(RStateColorMode);\n                    if (item &&\n                            !task.lightNode->modelId().startsWith(QLatin1String(\"FLS-PP3\"))) // color in add scene not supported well\n                    {\n                        stream << (uint16_t)0x0300; // color cluster\n                        stream << (uint8_t)11; // size\n                        if (l->colorMode() == QLatin1String(\"ct\"))\n                        {\n                            quint16 x,y;\n                            quint16 enhancedHue = 0;\n                            ResourceItem *ctMin = task.lightNode->item(RCapColorCtMin);\n                            ResourceItem *ctMax = task.lightNode->item(RCapColorCtMax);\n\n                            if (task.lightNode->modelId().startsWith(QLatin1String(\"FLS-H\")))\n                            {\n                                // quirks mode FLS-H stores color temperature in x\n                                x = l->colorTemperature();\n                                y = 0;\n                            }\n                            else if (task.lightNode->modelId().startsWith(QLatin1String(\"FLS-CT\")))\n                            {\n                                // quirks mode FLS-CT stores color temperature in x\n                                x = l->colorTemperature();\n                                y = 0;\n                            }\n                            else if (task.lightNode->modelId().startsWith(QLatin1String(\"Ribag Air O\")))\n                            {\n                                // quirks mode Ribag Air O stores color temperature in x\n                                x = l->colorTemperature();\n                                y = 0;\n                            }\n                            else if (task.lightNode->modelId().startsWith(QLatin1String(\"ICZB-F\")) ||\n                                     task.lightNode->manufacturerCode() == VENDOR_MUELLER)\n                            {\n                                // quirks mode these lights store color temperature in hue\n                                enhancedHue = l->colorTemperature();\n                                x = 0;\n                                y = 0;\n                            }\n                            else\n                            {\n                                quint16 ct = l->colorTemperature();\n                                if (ctMin && ctMax && ctMin->toNumber() > 0 && ctMax->toNumber() > 0)\n                                {\n                                    if      (ct < ctMin->toNumber()) { ct = static_cast<quint16>(ctMin->toNumber()); }\n                                    else if (ct > ctMax->toNumber()) { ct = static_cast<quint16>(ctMax->toNumber()); }\n                                }\n\n                                MiredColorTemperatureToXY(ct, &x, &y);\n                                if (x > 65279) { x = 65279; }\n                                else if (x == 0) { x = 1; }\n\n                                if (y > 65279) { y = 65279; }\n                                else if (y == 0) { y = 1; }\n                            }\n\n                            // view scene command will be used to verify x, y values\n                            if (l->x() != x || l->y() != y)\n                            {\n                                l->setX(x);\n                                l->setY(y);\n                            }\n\n                            stream << x;\n                            stream << y;\n                            stream << enhancedHue;\n                            stream << (quint8)0; // saturation\n                        }\n                        else\n                        {\n                            stream << l->x();\n                            stream << l->y();\n                            stream << l->enhancedHue();\n                            stream << l->saturation();\n                        }\n                        stream << (quint8)l->colorloopActive();\n                        stream << (quint8)l->colorloopDirection();\n                        stream << (quint16)l->colorloopTime();\n                    }\n                }\n\n                { // ZCL frame\n                    task.req.asdu().clear(); // cleanup old request data if there is any\n                    QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n                    stream.setByteOrder(QDataStream::LittleEndian);\n                    task.zclFrame.writeToStream(stream);\n                }\n\n                queryTime = queryTime.addSecs(2);\n\n                return addTask(task);\n            }\n            return false;\n        }\n    }\n    return false;\n}\n\n/*! Adds a remove scene task to the queue.\n\n   \\param task - the task item\n   \\param groupId - the group to which the scene belongs\n   \\param sceneId - the scene which shall be removed\n   \\return true - on success\n           false - on error\n */\nbool DeRestPluginPrivate::addTaskRemoveScene(TaskItem &task, uint16_t groupId, uint8_t sceneId)\n{\n    task.taskType = TaskStoreScene;\n\n    task.req.setClusterId(SCENE_CLUSTER_ID);\n    task.req.setProfileId(HA_PROFILE_ID);\n\n    task.zclFrame.payload().clear();\n    task.zclFrame.setSequenceNumber(zclSeq++);\n    task.zclFrame.setCommandId(0x02); // remove scene\n    task.zclFrame.setFrameControl(deCONZ::ZclFCClusterCommand |\n                             deCONZ::ZclFCDirectionClientToServer |\n                             deCONZ::ZclFCDisableDefaultResponse);\n\n    { // payload\n        QDataStream stream(&task.zclFrame.payload(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n\n        stream << groupId;\n        stream << sceneId;\n    }\n\n    { // ZCL frame\n        task.req.asdu().clear(); // cleanup old request data if there is any\n        QDataStream stream(&task.req.asdu(), QIODevice::WriteOnly);\n        stream.setByteOrder(QDataStream::LittleEndian);\n        task.zclFrame.writeToStream(stream);\n    }\n\n    return addTask(task);\n}\n"
        },
        {
          "name": "zdp",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}