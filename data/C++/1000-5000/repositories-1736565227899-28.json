{
  "metadata": {
    "timestamp": 1736565227899,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wangyu-/UDPspeeder",
      "stars": 4788,
      "defaultBranch": "branch_libev",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0693359375,
          "content": "SortIncludes: false\nBasedOnStyle: Google\nColumnLimit: 0\nIndentWidth: 4\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.025390625,
          "content": "libev/* linguist-vendored\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.994140625,
          "content": "#note: experimental\n#      currently only used for generating `compile_commands.json` for clangd\n#      to build this project, it's suggested to use `makefile` instead\n\ncmake_minimum_required(VERSION 3.7)\nproject(speederv2)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nset(CMAKE_CXX_STANDARD 11)\n\nset(SOURCE_FILES\n        main.cpp\n        log.cpp\n        common.cpp\n        lib/fec.cpp\n        lib/rs.cpp\n        packet.cpp\n        delay_manager.cpp\n        fd_manager.cpp\n        connection.cpp\n        fec_manager.cpp\n        misc.cpp\n        tunnel_client.cpp\n        tunnel_server.cpp\n        my_ev.cpp\n)\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers -O2 -g -fsanitize=address,undefined\")\n\n#target_include_directories(speederv2 PRIVATE .)\n#set(CMAKE_LINK_LIBRARY_FLAG \"-lrt\")\nadd_executable(speederv2 ${SOURCE_FILES})\ntarget_link_libraries(speederv2 rt)\ntarget_link_libraries(speederv2 pthread)\ninclude_directories(SYSTEM \"libev\")\ninclude_directories(\".\")\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.013671875,
          "content": "English Only.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0625,
          "content": "MIT License\n\nCopyright (c) 2017 Yu Wang (wangyucn at gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.087890625,
          "content": "# UDPspeeder\n\nA Tunnel which Improves your Network Quality on a High-latency Lossy Link by using Forward Error Correction.\n\nWhen used alone, UDPspeeder improves only UDP connection. Nevertheless, if you used UDPspeeder + any UDP-based VPN together,\nyou can improve any traffic(include TCP/UDP/ICMP), currently OpenVPN/L2TP/ShadowVPN are confirmed to be supported。\n\n![](/images/en/udpspeeder.PNG)\n\nor\n\n![image_vpn](/images/en/udpspeeder+openvpn3.PNG)\n\nAssume your local network to your server is lossy. Just establish a VPN connection to your server with UDPspeeder + any UDP-based VPN, access your server via this VPN connection, then your connection quality will be significantly improved. With well-tuned parameters , you can easily reduce IP or UDP/ICMP packet-loss-rate to less than 0.01% . Besides reducing packet-loss-rate, UDPspeeder can also significantly improve your TCP latency and TCP single-thread download speed.\n\n[UDPspeeder Wiki](https://github.com/wangyu-/UDPspeeder/wiki)\n\n[简体中文](/doc/README.zh-cn.md)\n\n# Efficacy\ntested on a link with 100ms latency and 10% packet loss at both direction\n\n### Ping Packet Loss\n![](/images/en/ping_compare_mode1.png)\n\n### SCP Copy Speed\n![](/images/en/scp_compare2.PNG)\n\n# Supported Platforms\nLinux host (including desktop Linux,Android phone/tablet, OpenWRT router, or Raspberry PI).\n\nFor Windows and MacOS You can run UDPspeeder inside [this](https://github.com/wangyu-/udp2raw-tunnel/releases/download/20171108.0/lede-17.01.2-x86_virtual_machine_image.zip) 7.5mb virtual machine image.\n\n# How does it work\n\nUDPspeeder uses FEC(Forward Error Correction) to reduce packet loss rate, at the cost of addtional bandwidth. The algorithm for FEC is called Reed-Solomon.\n\n![image0](/images/en/fec.PNG)\n\n### Reed-Solomon\n\n`\nIn coding theory, the Reed–Solomon code belongs to the class of non-binary cyclic error-correcting codes. The Reed–Solomon code is based on univariate polynomials over finite fields.\n`\n\n`\nIt is able to detect and correct multiple symbol errors. By adding t check symbols to the data, a Reed–Solomon code can detect any combination of up to t erroneous symbols, or correct up to ⌊t/2⌋ symbols. As an erasure code, it can correct up to t known erasures, or it can detect and correct combinations of errors and erasures. Reed–Solomon codes are also suitable as multiple-burst bit-error correcting codes, since a sequence of b + 1 consecutive bit errors can affect at most two symbols of size b. The choice of t is up to the designer of the code, and may be selected within wide limits.\n`\n\n![](/images/en/rs.png)\n\nCheck wikipedia for more info, https://en.wikipedia.org/wiki/Reed–Solomon_error_correction\n\n# Getting Started\n\n### Installing\nDownload binary release from https://github.com/wangyu-/UDPspeeder/releases\n\n### Running (improves UDP traffic only)\nAssume your server ip is 44.55.66.77, you have a service listening on udp port 7777.\n\n```bash\n# Run at server side:\n./speederv2 -s -l0.0.0.0:4096 -r 127.0.0.1:7777  -f20:10 -k \"passwd\"\n\n# Run at client side\n./speederv2 -c -l0.0.0.0:3333  -r44.55.66.77:4096 -f20:10 -k \"passwd\"\n```\n\nNow connecting to UDP port 3333 at the client side is equivalent to connecting to port 7777 at the server side, and the connection has been boosted by UDPspeeder.\n\n##### Note\n\n`-f20:10` means sending 10 redundant packets for every 20 original packets.\n\n`-k` enables simple XOR encryption\n\n\n# Improves all traffic with OpenVPN + UDPspeeder\n\nSee [UDPspeeder + openvpn config guide](https://github.com/wangyu-/UDPspeeder/wiki/UDPspeeder-openvpn-config-guide).\n\n# Advanced Topic\n\n### Full Options\n```\nUDPspeeder V2\ngit version: 3e248b414c    build date: Aug  5 2018 21:59:52\nrepository: https://github.com/wangyu-/UDPspeeder\n\nusage:\n    run as client: ./this_program -c -l local_listen_ip:local_port -r server_ip:server_port  [options]\n    run as server: ./this_program -s -l server_listen_ip:server_port -r remote_ip:remote_port  [options]\n\ncommon options, must be same on both sides:\n    -k,--key              <string>        key for simple xor encryption. if not set, xor is disabled\nmain options:\n    -f,--fec              x:y             forward error correction, send y redundant packets for every x packets\n    --timeout             <number>        how long could a packet be held in queue before doing fec, unit: ms, default: 8ms\n    --report              <number>        turn on send/recv report, and set a period for reporting, unit: s\nadvanced options:\n    --mode                <number>        fec-mode,available values: 0,1; mode 0(default) costs less bandwidth,no mtu problem.\n                                          mode 1 usually introduces less latency, but you have to care about mtu.\n    --mtu                 <number>        mtu. for mode 0, the program will split packet to segment smaller than mtu value.\n                                          for mode 1, no packet will be split, the program just check if the mtu is exceed.\n                                          default value: 1250. you typically shouldnt change this value.\n    -q,--queue-len        <number>        fec queue len, only for mode 0, fec will be performed immediately after queue is full.\n                                          default value: 200. \n    -j,--jitter           <number>        simulated jitter. randomly delay first packet for 0~<number> ms, default value: 0.\n                                          do not use if you dont know what it means.\n    -i,--interval         <number>        scatter each fec group to a interval of <number> ms, to protect burst packet loss.\n                                          default value: 0. do not use if you dont know what it means.\n    -f,--fec              x1:y1,x2:y2,..  similiar to -f/--fec above,fine-grained fec parameters,may help save bandwidth.\n                                          example: \"-f 1:3,2:4,10:6,20:10\". check repo for details\n    --random-drop         <number>        simulate packet loss, unit: 0.01%. default value: 0.\n    --disable-obscure     <number>        disable obscure, to save a bit bandwidth and cpu.\ndeveloper options:\n    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program, so that you\n                                          can change fec encode parameters dynamically, check readme.md in repository for\n                                          supported commands.\n    -j ,--jitter          jmin:jmax       similiar to -j above, but create jitter randomly between jmin and jmax\n    -i,--interval         imin:imax       similiar to -i above, but scatter randomly between imin and imax\n    --decode-buf          <number>        size of buffer of fec decoder,u nit: packet, default: 2000\n    --fix-latency         <number>        try to stabilize latency, only for mode 0\n    --delay-capacity      <number>        max number of delayed packets\n    --disable-fec         <number>        completely disable fec, turn the program into a normal udp tunnel\n    --sock-buf            <number>        buf size for socket, >=10 and <=10240, unit: kbyte, default: 1024\nlog and help options:\n    --log-level           <number>        0: never    1: fatal   2: error   3: warn \n                                          4: info (default)      5: debug   6: trace\n    --log-position                        enable file name, function name, line number in log\n    --disable-color                       disable log color\n    -h,--help                             print this help message\n\n```\n#### `--fifo` option\nUse a fifo(named pipe) for sending commands to the running program. For example `--fifo fifo.file`, you can use following commands to change parameters dynamically:\n```\necho fec 19:9 > fifo.file\necho mtu 1100 > fifo.file\necho timeout 5 > fifo.file\necho queue-len 100 > fifo.file\necho mode 0 > fifo.file\n```\n\n\n# wiki\nCheck wiki for more info:\n\nhttps://github.com/wangyu-/UDPspeeder/wiki\n\n# Related repo\n\nYou can also try tinyfecVPN, a lightweight high-performance VPN with UDPspeeder's function built-in, repo:\n\nhttps://github.com/wangyu-/tinyfecVPN\n\nYou can use udp2raw with UDPspeeder together to get better speed on some ISP with UDP QoS(UDP throttling), repo: \n\nhttps://github.com/wangyu-/udp2raw-tunnel\n"
        },
        {
          "name": "common.cpp",
          "type": "blob",
          "size": 24.2802734375,
          "content": "/*\n * comm.cpp\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n\n#include \"common.h\"\n#include \"log.h\"\n\n#include <random>\n#include <cmath>\n\nint about_to_exit = 0;\n\nraw_mode_t raw_mode = mode_faketcp;\nunordered_map<int, const char *> raw_mode_tostring = {{mode_faketcp, \"faketcp\"}, {mode_udp, \"udp\"}, {mode_icmp, \"icmp\"}};\n\n// static int random_number_fd=-1;\nchar iptables_rule[200] = \"\";\n// int is_client = 0, is_server = 0;\n\nprogram_mode_t program_mode = unset_mode;  // 0 unset; 1client 2server\n\nworking_mode_t working_mode = tunnel_mode;\n\nint socket_buf_size = 1024 * 1024;\n\nint init_ws() {\n#if defined(__MINGW32__)\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        printf(\"WSAStartup failed with error: %d\\n\", err);\n        exit(-1);\n    }\n\n    /* Confirm that the WinSock DLL supports 2.2.*/\n    /* Note that if the DLL supports versions greater    */\n    /* than 2.2 in addition to 2.2, it will still return */\n    /* 2.2 in wVersion since that is the version we      */\n    /* requested.                                        */\n\n    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {\n        /* Tell the user that we could not find a usable */\n        /* WinSock DLL.                                  */\n        printf(\"Could not find a usable version of Winsock.dll\\n\");\n        WSACleanup();\n        exit(-1);\n    } else {\n        printf(\"The Winsock 2.2 dll was found okay\");\n    }\n\n    int tmp[] = {0, 100, 200, 300, 500, 800, 1000, 2000, 3000, 4000, -1};\n    int succ = 0;\n    for (int i = 1; tmp[i] != -1; i++) {\n        if (_setmaxstdio(100) == -1)\n            break;\n        else\n            succ = i;\n    }\n    printf(\", _setmaxstdio() was set to %d\\n\", tmp[succ]);\n#endif\n    return 0;\n}\n\n#if defined(__MINGW32__)\nint inet_pton(int af, const char *src, void *dst) {\n    struct sockaddr_storage ss;\n    int size = sizeof(ss);\n    char src_copy[INET6_ADDRSTRLEN + 1];\n\n    ZeroMemory(&ss, sizeof(ss));\n    /* stupid non-const API */\n    strncpy(src_copy, src, INET6_ADDRSTRLEN + 1);\n    src_copy[INET6_ADDRSTRLEN] = 0;\n\n    if (WSAStringToAddress(src_copy, af, NULL, (struct sockaddr *)&ss, &size) == 0) {\n        switch (af) {\n            case AF_INET:\n                *(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;\n                return 1;\n            case AF_INET6:\n                *(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;\n                return 1;\n        }\n    }\n    return 0;\n}\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {\n    struct sockaddr_storage ss;\n    unsigned long s = size;\n\n    ZeroMemory(&ss, sizeof(ss));\n    ss.ss_family = af;\n\n    switch (af) {\n        case AF_INET:\n            ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;\n            break;\n        case AF_INET6:\n            ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;\n            break;\n        default:\n            return NULL;\n    }\n    /* cannot direclty use &size because of strict aliasing rules */\n    return (WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) == 0) ? dst : NULL;\n}\nchar *get_sock_error() {\n    static char buf[1000];\n    int e = WSAGetLastError();\n    wchar_t *s = NULL;\n    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                   NULL, e,\n                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                   (LPWSTR)&s, 0, NULL);\n    sprintf(buf, \"%d:%S\", e, s);\n    int len = strlen(buf);\n    if (len > 0 && buf[len - 1] == '\\n') buf[len - 1] = 0;\n    LocalFree(s);\n    return buf;\n}\nint get_sock_errno() {\n    return WSAGetLastError();\n}\n#else\nchar *get_sock_error() {\n    static char buf[1000];\n    sprintf(buf, \"%d:%s\", errno, strerror(errno));\n    return buf;\n}\nint get_sock_errno() {\n    return errno;\n}\n#endif\n\nstruct my_random_t {\n    std::random_device rd;\n    std::mt19937 gen;\n    std::uniform_int_distribution<u64_t> dis64;\n    std::uniform_int_distribution<u32_t> dis32;\n\n    std::uniform_int_distribution<unsigned char> dis8;\n\n    my_random_t() {\n        std::mt19937 gen_tmp(rd());\n        gen = gen_tmp;\n        gen.discard(700000);  // magic\n    }\n    u64_t gen64() {\n        return dis64(gen);\n    }\n    u32_t gen32() {\n        return dis32(gen);\n    }\n\n    unsigned char gen8() {\n        return dis8(gen);\n    }\n    /*int random_number_fd;\n    random_fd_t()\n    {\n                    random_number_fd=open(\"/dev/urandom\",O_RDONLY);\n\n                    if(random_number_fd==-1)\n                    {\n                            mylog(log_fatal,\"error open /dev/urandom\\n\");\n                            myexit(-1);\n                    }\n                    setnonblocking(random_number_fd);\n    }\n    int get_fd()\n    {\n            return random_number_fd;\n    }*/\n} my_random;\n\nint address_t::from_str(char *str) {\n    clear();\n\n    char ip_addr_str[100];\n    u32_t port;\n    mylog(log_info, \"parsing address: %s\\n\", str);\n    int is_ipv6 = 0;\n    if (sscanf(str, \"[%[^]]]:%u\", ip_addr_str, &port) == 2) {\n        mylog(log_info, \"its an ipv6 adress\\n\");\n        inner.ipv6.sin6_family = AF_INET6;\n        is_ipv6 = 1;\n    } else if (sscanf(str, \"%[^:]:%u\", ip_addr_str, &port) == 2) {\n        mylog(log_info, \"its an ipv4 adress\\n\");\n        inner.ipv4.sin_family = AF_INET;\n    } else {\n        mylog(log_error, \"failed to parse\\n\");\n        myexit(-1);\n    }\n\n    mylog(log_info, \"ip_address is {%s}, port is {%u}\\n\", ip_addr_str, port);\n\n    if (port > 65535) {\n        mylog(log_error, \"invalid port: %d\\n\", port);\n        myexit(-1);\n    }\n\n    int ret = -100;\n    if (is_ipv6) {\n        ret = inet_pton(AF_INET6, ip_addr_str, &(inner.ipv6.sin6_addr));\n        inner.ipv6.sin6_port = htons(port);\n        if (ret == 0)  // 0 if address type doesnt match\n        {\n            mylog(log_error, \"ip_addr %s is not an ipv6 address, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        } else if (ret == 1)  // inet_pton returns 1 on success\n        {\n            // okay\n        } else {\n            mylog(log_error, \"ip_addr %s is invalid, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        }\n    } else {\n        ret = inet_pton(AF_INET, ip_addr_str, &(inner.ipv4.sin_addr));\n        inner.ipv4.sin_port = htons(port);\n\n        if (ret == 0) {\n            mylog(log_error, \"ip_addr %s is not an ipv4 address, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        } else if (ret == 1) {\n            // okay\n        } else {\n            mylog(log_error, \"ip_addr %s is invalid, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        }\n    }\n\n    return 0;\n}\n\nint address_t::from_str_ip_only(char *str) {\n    clear();\n\n    u32_t type;\n\n    if (strchr(str, ':') == NULL)\n        type = AF_INET;\n    else\n        type = AF_INET6;\n\n    ((sockaddr *)&inner)->sa_family = type;\n\n    int ret;\n    if (type == AF_INET) {\n        ret = inet_pton(type, str, &inner.ipv4.sin_addr);\n    } else {\n        ret = inet_pton(type, str, &inner.ipv6.sin6_addr);\n    }\n\n    if (ret == 0)  // 0 if address type doesnt match\n    {\n        mylog(log_error, \"confusion in parsing %s, %d\\n\", str, ret);\n        myexit(-1);\n    } else if (ret == 1)  // inet_pton returns 1 on success\n    {\n        // okay\n    } else {\n        mylog(log_error, \"ip_addr %s is invalid, %d\\n\", str, ret);\n        myexit(-1);\n    }\n    return 0;\n}\n\nchar *address_t::get_str() {\n    static char res[max_addr_len];\n    to_str(res);\n    return res;\n}\nvoid address_t::to_str(char *s) {\n    // static char res[max_addr_len];\n    char ip_addr[max_addr_len];\n    u32_t port;\n    const char *ret = 0;\n    if (get_type() == AF_INET6) {\n        ret = inet_ntop(AF_INET6, &inner.ipv6.sin6_addr, ip_addr, max_addr_len);\n        port = inner.ipv6.sin6_port;\n    } else if (get_type() == AF_INET) {\n        ret = inet_ntop(AF_INET, &inner.ipv4.sin_addr, ip_addr, max_addr_len);\n        port = inner.ipv4.sin_port;\n    } else {\n        assert(0 == 1);\n    }\n\n    if (ret == 0)  // NULL on failure\n    {\n        mylog(log_error, \"inet_ntop failed\\n\");\n        myexit(-1);\n    }\n\n    port = ntohs(port);\n\n    ip_addr[max_addr_len - 1] = 0;\n    if (get_type() == AF_INET6) {\n        sprintf(s, \"[%s]:%u\", ip_addr, (u32_t)port);\n    } else {\n        sprintf(s, \"%s:%u\", ip_addr, (u32_t)port);\n    }\n\n    // return res;\n}\n\nchar *address_t::get_ip() {\n    char ip_addr[max_addr_len];\n    static char s[max_addr_len];\n    const char *ret = 0;\n    if (get_type() == AF_INET6) {\n        ret = inet_ntop(AF_INET6, &inner.ipv6.sin6_addr, ip_addr, max_addr_len);\n    } else if (get_type() == AF_INET) {\n        ret = inet_ntop(AF_INET, &inner.ipv4.sin_addr, ip_addr, max_addr_len);\n    } else {\n        assert(0 == 1);\n    }\n\n    if (ret == 0)  // NULL on failure\n    {\n        mylog(log_error, \"inet_ntop failed\\n\");\n        myexit(-1);\n    }\n\n    ip_addr[max_addr_len - 1] = 0;\n    if (get_type() == AF_INET6) {\n        sprintf(s, \"%s\", ip_addr);\n    } else {\n        sprintf(s, \"%s\", ip_addr);\n    }\n\n    return s;\n}\n\nint address_t::from_sockaddr(sockaddr *addr, socklen_t slen) {\n    clear();\n    // memset(&inner,0,sizeof(inner));\n    if (addr->sa_family == AF_INET6) {\n        assert(slen == sizeof(sockaddr_in6));\n        // inner.ipv6= *( (sockaddr_in6*) addr );\n        memcpy(&inner, addr, slen);\n    } else if (addr->sa_family == AF_INET) {\n        assert(slen == sizeof(sockaddr_in));\n        // inner.ipv4= *( (sockaddr_in*) addr );\n        memcpy(&inner, addr, slen);\n    } else {\n        assert(0 == 1);\n    }\n    return 0;\n}\n\nint address_t::new_connected_udp_fd() {\n    int new_udp_fd;\n    new_udp_fd = socket(get_type(), SOCK_DGRAM, IPPROTO_UDP);\n    if (new_udp_fd < 0) {\n        mylog(log_warn, \"create udp_fd error\\n\");\n        return -1;\n    }\n    setnonblocking(new_udp_fd);\n    set_buf_size(new_udp_fd, socket_buf_size);\n\n    mylog(log_debug, \"created new udp_fd %d\\n\", new_udp_fd);\n    int ret = connect(new_udp_fd, (struct sockaddr *)&inner, get_len());\n    if (ret != 0) {\n        mylog(log_warn, \"udp fd connect fail %d %s\\n\", ret, strerror(errno));\n        // sock_close(new_udp_fd);\n        close(new_udp_fd);\n        return -1;\n    }\n\n    return new_udp_fd;\n}\n\nvoid get_fake_random_chars(char *s, int len) {\n    char *p = s;\n    int left = len;\n\n    while (left >= (int)sizeof(u64_t)) {\n        //*((u64_t*)p)=my_random.gen64();  //this may break strict-alias  ,  also p may not point to a multiple of sizeof(u64_t)\n\n        u64_t tmp = my_random.gen64();\n        memcpy(p, &tmp, sizeof(u64_t));  // so,use memcpy instead.\n\n        p += sizeof(u64_t);\n        left -= sizeof(u64_t);\n    }\n    if (left) {\n        u64_t tmp = my_random.gen64();\n        memcpy(p, &tmp, left);\n    }\n}\n\nint random_between(u32_t a, u32_t b) {\n    if (a > b) {\n        mylog(log_fatal, \"min >max?? %d %d\\n\", a, b);\n        myexit(1);\n    }\n    if (a == b)\n        return a;\n    else\n        return a + get_fake_random_number() % (b + 1 - a);\n}\n\n/*\nu64_t get_current_time()//ms\n{\n        timespec tmp_time;\n        clock_gettime(CLOCK_MONOTONIC, &tmp_time);\n        return ((u64_t)tmp_time.tv_sec)*1000llu+((u64_t)tmp_time.tv_nsec)/(1000*1000llu);\n}\n\nu64_t get_current_time_us()\n{\n        timespec tmp_time;\n        clock_gettime(CLOCK_MONOTONIC, &tmp_time);\n        return (uint64_t(tmp_time.tv_sec))*1000llu*1000llu+ (uint64_t(tmp_time.tv_nsec))/1000llu;\n}*/\n\nu64_t get_current_time_us() {\n    static u64_t value_fix = 0;\n    static u64_t largest_value = 0;\n\n    u64_t raw_value = (u64_t)(ev_time() * 1000 * 1000);\n\n    u64_t fixed_value = raw_value + value_fix;\n\n    if (fixed_value < largest_value) {\n        value_fix += largest_value - fixed_value;\n    } else {\n        largest_value = fixed_value;\n    }\n\n    // printf(\"<%lld,%lld,%lld>\\n\",raw_value,value_fix,raw_value + value_fix);\n    return raw_value + value_fix;  // new fixed value\n}\n\nu64_t get_current_time() {\n    return get_current_time_us() / 1000lu;\n}\n\nu64_t pack_u64(u32_t a, u32_t b) {\n    u64_t ret = a;\n    ret <<= 32u;\n    ret += b;\n    return ret;\n}\nu32_t get_u64_h(u64_t a) {\n    return a >> 32u;\n}\nu32_t get_u64_l(u64_t a) {\n    return (a << 32u) >> 32u;\n}\n\nvoid write_u16(char *p, u16_t w) {\n    *(unsigned char *)(p + 1) = (w & 0xff);\n    *(unsigned char *)(p + 0) = (w >> 8);\n}\nu16_t read_u16(char *p) {\n    u16_t res;\n    res = *(const unsigned char *)(p + 0);\n    res = *(const unsigned char *)(p + 1) + (res << 8);\n    return res;\n}\n\nvoid write_u32(char *p, u32_t l) {\n    *(unsigned char *)(p + 3) = (unsigned char)((l >> 0) & 0xff);\n    *(unsigned char *)(p + 2) = (unsigned char)((l >> 8) & 0xff);\n    *(unsigned char *)(p + 1) = (unsigned char)((l >> 16) & 0xff);\n    *(unsigned char *)(p + 0) = (unsigned char)((l >> 24) & 0xff);\n}\nu32_t read_u32(char *p) {\n    u32_t res;\n    res = *(const unsigned char *)(p + 0);\n    res = *(const unsigned char *)(p + 1) + (res << 8);\n    res = *(const unsigned char *)(p + 2) + (res << 8);\n    res = *(const unsigned char *)(p + 3) + (res << 8);\n    return res;\n}\n\nvoid write_u64(char *s, u64_t a) {\n    assert(0 == 1);\n}\nu64_t read_u64(char *s) {\n    assert(0 == 1);\n    return 0;\n}\n\nchar *my_ntoa(u32_t ip) {\n    in_addr a;\n    a.s_addr = ip;\n    return inet_ntoa(a);\n}\n\nu64_t get_fake_random_number_64() {\n    // u64_t ret;\n    // int size=read(random_fd.get_fd(),&ret,sizeof(ret));\n    // if(size!=sizeof(ret))\n    //{\n    //\tmylog(log_fatal,\"get random number failed %d\\n\",size);\n\n    //\tmyexit(-1);\n    //}\n\n    return my_random.gen64();\n}\nu32_t get_fake_random_number() {\n    // u32_t ret;\n    // int size=read(random_fd.get_fd(),&ret,sizeof(ret));\n    // if(size!=sizeof(ret))\n    //{\n    //\tmylog(log_fatal,\"get random number failed %d\\n\",size);\n    //\tmyexit(-1);\n    // }\n    return my_random.gen32();\n}\nu32_t get_fake_random_number_nz()  // nz for non-zero\n{\n    u32_t ret = 0;\n    while (ret == 0) {\n        ret = get_fake_random_number();\n    }\n    return ret;\n}\n\n/*\nu64_t ntoh64(u64_t a)\n{\n        if(__BYTE_ORDER == __LITTLE_ENDIAN)\n        {\n                return __bswap_64( a);\n        }\n        else return a;\n\n}\nu64_t hton64(u64_t a)\n{\n        if(__BYTE_ORDER == __LITTLE_ENDIAN)\n        {\n                return __bswap_64( a);\n        }\n        else return a;\n\n}*/\n\nvoid setnonblocking(int sock) {\n#if !defined(__MINGW32__)\n    int opts;\n    opts = fcntl(sock, F_GETFL);\n\n    if (opts < 0) {\n        mylog(log_fatal, \"fcntl(sock,GETFL)\\n\");\n        // perror(\"fcntl(sock,GETFL)\");\n        myexit(1);\n    }\n    opts = opts | O_NONBLOCK;\n    if (fcntl(sock, F_SETFL, opts) < 0) {\n        mylog(log_fatal, \"fcntl(sock,SETFL,opts)\\n\");\n        // perror(\"fcntl(sock,SETFL,opts)\");\n        myexit(1);\n    }\n#else\n    int iResult;\n    u_long iMode = 1;\n    iResult = ioctlsocket(sock, FIONBIO, &iMode);\n    if (iResult != NO_ERROR)\n        printf(\"ioctlsocket failed with error: %d\\n\", iResult);\n\n#endif\n}\n\n/*\n    Generic checksum calculation function\n*/\nunsigned short csum(const unsigned short *ptr, int nbytes) {\n    long sum;\n    unsigned short oddbyte;\n    short answer;\n\n    sum = 0;\n    while (nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum >> 16) + (sum & 0xffff);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n\n    return (answer);\n}\n\nunsigned short tcp_csum(const pseudo_header &ph, const unsigned short *ptr, int nbytes) {  // works both for big and little endian\n\n    long sum;\n    unsigned short oddbyte;\n    short answer;\n\n    sum = 0;\n    unsigned short *tmp = (unsigned short *)&ph;\n    for (int i = 0; i < 6; i++) {\n        sum += *tmp++;\n    }\n\n    while (nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum >> 16) + (sum & 0xffff);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n\n    return (answer);\n}\n\nint set_buf_size(int fd, int socket_buf_size) {\n    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n        mylog(log_fatal, \"SO_SNDBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, get_sock_error());\n        myexit(1);\n    }\n    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n        mylog(log_fatal, \"SO_RCVBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, get_sock_error());\n        myexit(1);\n    }\n    return 0;\n}\n\nvoid myexit(int a) {\n    if (enable_log_color)\n        printf(\"%s\\n\", RESET);\n    // clear_iptables_rule();\n    exit(a);\n}\nvoid signal_handler(int sig) {\n    about_to_exit = 1;\n    // myexit(0);\n}\n/*\nint numbers_to_char(id_t id1,id_t id2,id_t id3,char * &data,int &len)\n{\n        static char buf[buf_len];\n        data=buf;\n        id_t tmp=htonl(id1);\n        memcpy(buf,&tmp,sizeof(tmp));\n\n        tmp=htonl(id2);\n        memcpy(buf+sizeof(tmp),&tmp,sizeof(tmp));\n\n        tmp=htonl(id3);\n        memcpy(buf+sizeof(tmp)*2,&tmp,sizeof(tmp));\n\n        len=sizeof(id_t)*3;\n        return 0;\n}\n\n\nint char_to_numbers(const char * data,int len,id_t &id1,id_t &id2,id_t &id3)\n{\n        if(len<int(sizeof(id_t)*3)) return -1;\n        id1=ntohl(  *((id_t*)(data+0)) );\n        id2=ntohl(  *((id_t*)(data+sizeof(id_t))) );\n        id3=ntohl(  *((id_t*)(data+sizeof(id_t)*2)) );\n        return 0;\n}\n*/\n\n/*\nint set_timer_ms(int epollfd,int &timer_fd,u32_t timer_interval)\n{\n        int ret;\n        epoll_event ev;\n\n        itimerspec its;\n        memset(&its,0,sizeof(its));\n\n        if((timer_fd=timerfd_create(CLOCK_MONOTONIC,TFD_NONBLOCK)) < 0)\n        {\n                mylog(log_fatal,\"timer_fd create error\\n\");\n                myexit(1);\n        }\n        its.it_interval.tv_sec=(timer_interval/1000);\n        its.it_interval.tv_nsec=(timer_interval%1000)*1000ll*1000ll;\n        its.it_value.tv_nsec=1; //imidiately\n        timerfd_settime(timer_fd,0,&its,0);\n\n\n        ev.events = EPOLLIN;\n        ev.data.fd = timer_fd;\n\n        ret=epoll_ctl(epollfd, EPOLL_CTL_ADD, timer_fd, &ev);\n        if (ret < 0) {\n                mylog(log_fatal,\"epoll_ctl return %d\\n\", ret);\n                myexit(-1);\n        }\n        return 0;\n}*/\n/*\nint create_new_udp(int &new_udp_fd,int remote_address_uint32,int remote_port)\n{\n        struct sockaddr_in remote_addr_in;\n\n        socklen_t slen = sizeof(sockaddr_in);\n        memset(&remote_addr_in, 0, sizeof(remote_addr_in));\n        remote_addr_in.sin_family = AF_INET;\n        remote_addr_in.sin_port = htons(remote_port);\n        remote_addr_in.sin_addr.s_addr = remote_address_uint32;\n\n        new_udp_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n        if (new_udp_fd < 0) {\n                mylog(log_warn, \"create udp_fd error\\n\");\n                return -1;\n        }\n        setnonblocking(new_udp_fd);\n        set_buf_size(new_udp_fd);\n\n        mylog(log_debug, \"created new udp_fd %d\\n\", new_udp_fd);\n        int ret = connect(new_udp_fd, (struct sockaddr *) &remote_addr_in, slen);\n        if (ret != 0) {\n                mylog(log_warn, \"udp fd connect fail %d %s\\n\",ret,strerror(errno));\n                close(new_udp_fd);\n                return -1;\n        }\n        return 0;\n}*/\n\nint round_up_div(int a, int b) {\n    return (a + b - 1) / b;\n}\n\nint create_fifo(char *file) {\n#if !defined(__MINGW32__)\n    if (mkfifo(file, 0666) != 0) {\n        if (errno == EEXIST) {\n            mylog(log_warn, \"warning fifo file %s exist\\n\", file);\n        } else {\n            mylog(log_fatal, \"create fifo file %s failed\\n\", file);\n            myexit(-1);\n        }\n    }\n    int fifo_fd = open(file, O_RDWR);\n    if (fifo_fd < 0) {\n        mylog(log_fatal, \"create fifo file %s failed\\n\", file);\n        myexit(-1);\n    }\n    struct stat st;\n    if (fstat(fifo_fd, &st) != 0) {\n        mylog(log_fatal, \"fstat failed for fifo file %s\\n\", file);\n        myexit(-1);\n    }\n\n    if (!S_ISFIFO(st.st_mode)) {\n        mylog(log_fatal, \"%s is not a fifo\\n\", file);\n        myexit(-1);\n    }\n\n    setnonblocking(fifo_fd);\n    return fifo_fd;\n#else\n    assert(0 == 1 && \"not supported\\n\");\n    return 0;\n#endif\n}\n\n/*\nint new_listen_socket(int &fd,u32_t ip,int port)\n{\n        fd =socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n        int yes = 1;\n        //setsockopt(udp_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n\n        struct sockaddr_in local_me={0};\n\n        socklen_t slen = sizeof(sockaddr_in);\n        //memset(&local_me, 0, sizeof(local_me));\n        local_me.sin_family = AF_INET;\n        local_me.sin_port = htons(port);\n        local_me.sin_addr.s_addr = ip;\n\n        if (::bind(fd, (struct sockaddr*) &local_me, slen) == -1) {\n                mylog(log_fatal,\"socket bind error\\n\");\n                //perror(\"socket bind error\");\n                myexit(1);\n        }\n        setnonblocking(fd);\n    set_buf_size(fd,socket_buf_size);\n\n    mylog(log_debug,\"local_listen_fd=%d\\n\",fd);\n\n        return 0;\n}\nint new_connected_socket(int &fd,u32_t ip,int port)\n{\n        char ip_port[40];\n        sprintf(ip_port,\"%s:%d\",my_ntoa(ip),port);\n\n        struct sockaddr_in remote_addr_in = { 0 };\n\n        socklen_t slen = sizeof(sockaddr_in);\n        //memset(&remote_addr_in, 0, sizeof(remote_addr_in));\n        remote_addr_in.sin_family = AF_INET;\n        remote_addr_in.sin_port = htons(port);\n        remote_addr_in.sin_addr.s_addr = ip;\n\n        fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n        if (fd < 0) {\n                mylog(log_warn, \"[%s]create udp_fd error\\n\", ip_port);\n                return -1;\n        }\n        setnonblocking(fd);\n        set_buf_size(fd, socket_buf_size);\n\n        mylog(log_debug, \"[%s]created new udp_fd %d\\n\", ip_port, fd);\n        int ret = connect(fd, (struct sockaddr *) &remote_addr_in, slen);\n        if (ret != 0) {\n                mylog(log_warn, \"[%s]fd connect fail\\n\",ip_port);\n                sock_close(fd);\n                return -1;\n        }\n        return 0;\n}\n*/\nint new_listen_socket2(int &fd, address_t &addr) {\n    fd = socket(addr.get_type(), SOCK_DGRAM, IPPROTO_UDP);\n\n    int yes = 1;\n\n    if (::bind(fd, (struct sockaddr *)&addr.inner, addr.get_len()) == -1) {\n        mylog(log_fatal, \"socket bind error=%s\\n\", get_sock_error());\n        // perror(\"socket bind error\");\n        myexit(1);\n    }\n    setnonblocking(fd);\n    set_buf_size(fd, socket_buf_size);\n\n    mylog(log_debug, \"local_listen_fd=%d\\n\", fd);\n\n    return 0;\n}\nint new_connected_socket2(int &fd, address_t &addr, address_t *bind_addr, char *interface_string) {\n    fd = socket(addr.get_type(), SOCK_DGRAM, IPPROTO_UDP);\n    if (fd < 0) {\n        mylog(log_warn, \"[%s]create udp_fd error\\n\", addr.get_str());\n        return -1;\n    }\n\n    if (bind_addr && ::bind(fd, (struct sockaddr *)&bind_addr->inner, bind_addr->get_len()) == -1) {\n        mylog(log_fatal, \"socket bind error=%s\\n\", get_sock_error());\n        // perror(\"socket bind error\");\n        myexit(1);\n    }\n\n#ifdef __linux__\n    if (interface_string && ::setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, interface_string, strlen(interface_string)) < 0) {\n        mylog(log_fatal, \"socket interface bind error=%s\\n\", get_sock_error());\n        // perror(\"socket bind error\");\n        myexit(1);\n    }\n#endif\n\n    setnonblocking(fd);\n    set_buf_size(fd, socket_buf_size);\n\n    mylog(log_debug, \"[%s]created new udp_fd %d\\n\", addr.get_str(), fd);\n    int ret = connect(fd, (struct sockaddr *)&addr.inner, addr.get_len());\n    if (ret != 0) {\n        mylog(log_warn, \"[%s]fd connect fail\\n\", addr.get_str());\n        sock_close(fd);\n        return -1;\n    }\n    return 0;\n}\n\nu32_t djb2(unsigned char *str, int len) {\n    u32_t hash = 5381;\n    int c;\n    for (int i=0; i<len ;i++) {\n        c = *(str++);\n        hash = ((hash << 5) + hash) ^ c; /* (hash * 33) ^ c */\n    }\n\n    hash = htonl(hash);\n    return hash;\n}\n\nu32_t sdbm(unsigned char *str, int len) {\n    u32_t hash = 0;\n    int c;\n    for (int i=0; i<len ;i++) {\n        c = *(str++);\n        hash = c + (hash << 6) + (hash << 16) - hash;\n    }\n    // hash=htonl(hash);\n    return hash;\n}\n\n\nvector<string> string_to_vec(const char *s, const char *sp) {\n    vector<string> res;\n    string str = s;\n    char *p = strtok((char *)str.c_str(), sp);\n    while (p != NULL) {\n        res.push_back(p);\n        // printf (\"%s\\n\",p);\n        p = strtok(NULL, sp);\n    }\n\n    /* for(int i=0;i<(int)res.size();i++)\n     {\n             printf(\"<<%s>>\\n\",res[i].c_str());\n     }*/\n    return res;\n}\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 12.2841796875,
          "content": "/*\n * common.h\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n\n#ifndef COMMON_H_\n#define COMMON_H_\n//#define __STDC_FORMAT_MACROS 1\n#include <inttypes.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <getopt.h>\n\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>  //for exit(0);\n#include <errno.h>   //For errno - the error number\n//#include <netinet/tcp.h>   //Provides declarations for tcp header\n//#include <netinet/udp.h>\n//#include <netinet/ip.h>    //Provides declarations for ip header\n//#include <netinet/if_ether.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <time.h>\n//#include <netinet/in.h>\n//#include <net/if.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#if !defined(NO_LIBEV_EMBED)\n#include <my_ev.h>\n#else\n#include \"ev.h\"\n#endif\n\n#if defined(__MINGW32__)\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#endif\n\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <list>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long u64_t;  // this works on most platform,avoid using the PRId64\ntypedef long long i64_t;\n\ntypedef unsigned int u32_t;\ntypedef int i32_t;\n\ntypedef unsigned short u16_t;\ntypedef short i16_t;\n\n#if defined(__MINGW32__)\nint inet_pton(int af, const char *src, void *dst);\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n#define setsockopt(a, b, c, d, e) setsockopt(a, b, c, (const char *)(d), e)\n#endif\n\nchar *get_sock_error();\nint get_sock_errno();\nint init_ws();\n\n#if defined(__MINGW32__)\ntypedef SOCKET my_fd_t;\ninline int sock_close(my_fd_t fd) {\n    return closesocket(fd);\n}\n#else\ntypedef int my_fd_t;\ninline int sock_close(my_fd_t fd) {\n    return close(fd);\n}\n\n#endif\n\nstruct my_itimerspec {\n    struct timespec it_interval; /* Timer interval */\n    struct timespec it_value;    /* Initial expiration */\n};\n\ntypedef u64_t my_time_t;\n\nconst int max_addr_len = 100;\nconst int max_data_len = 3600;\nconst int buf_len = max_data_len + 200;\n\nconst int default_mtu = 1250;\n\n// const u32_t timer_interval=400;\n////const u32_t conv_timeout=180000;\n// const u32_t conv_timeout=40000;//for test\nconst u32_t conv_timeout = 180000;\nconst int max_conv_num = 10000;\nconst int max_conn_num = 200;\n\n/*\nconst u32_t max_handshake_conn_num=10000;\nconst u32_t max_ready_conn_num=1000;\n//const u32_t anti_replay_window_size=1000;\n\n\nconst u32_t client_handshake_timeout=5000;\nconst u32_t client_retry_interval=1000;\n\nconst u32_t server_handshake_timeout=10000;// this should be much longer than clients. client retry initially ,server retry passtively*/\n\nconst int conv_clear_ratio = 30;  // conv grabage collecter check 1/30 of all conv one time\nconst int conn_clear_ratio = 50;\nconst int conv_clear_min = 1;\nconst int conn_clear_min = 1;\n\nconst u32_t conv_clear_interval = 1000;\nconst u32_t conn_clear_interval = 1000;\n\nconst i32_t max_fail_time = 0;  // disable\n\nconst u32_t heartbeat_interval = 1000;\n\nconst u32_t timer_interval = 400;  // this should be smaller than heartbeat_interval and retry interval;\n\n// const uint32_t conv_timeout=120000; //120 second\n// const u32_t conv_timeout=120000; //for test\n\nconst u32_t client_conn_timeout = 10000;\nconst u32_t client_conn_uplink_timeout = client_conn_timeout + 2000;\n\n// const uint32_t server_conn_timeout=conv_timeout+60000;//this should be 60s+ longer than conv_timeout,so that conv_manager can destruct convs gradually,to avoid latency glicth\nconst u32_t server_conn_timeout = conv_timeout + 20000;  // for test\n\nextern int about_to_exit;\n\nenum raw_mode_t { mode_faketcp = 0,\n                  mode_udp,\n                  mode_icmp,\n                  mode_end };\nextern raw_mode_t raw_mode;\nenum program_mode_t { unset_mode = 0,\n                      client_mode,\n                      server_mode };\nextern program_mode_t program_mode;\nextern unordered_map<int, const char *> raw_mode_tostring;\n\nenum working_mode_t { unset_working_mode = 0,\n                      tunnel_mode,\n                      tun_dev_mode };\nextern working_mode_t working_mode;\n\nextern int socket_buf_size;\n\n// typedef u32_t id_t;\n\ntypedef u64_t iv_t;\n\ntypedef u64_t padding_t;\n\ntypedef u64_t anti_replay_seq_t;\n\ntypedef u64_t fd64_t;\n\n// enum dest_type{none=0,type_fd64_ip_port,type_fd64,type_fd64_ip_port_conv,type_fd64_conv/*,type_fd*/};\nenum dest_type { none = 0,\n                 type_fd64_addr,\n                 type_fd64,\n                 type_fd,\n                 type_write_fd,\n                 type_fd_addr /*,type_fd*/ };\n\n/*\nstruct ip_port_t\n{\n        u32_t ip;\n        int port;\n        void from_u64(u64_t u64);\n        u64_t to_u64();\n        char * to_s();\n};\n\nstruct fd64_ip_port_t\n{\n        fd64_t fd64;\n        ip_port_t ip_port;\n};\nstruct fd_ip_port_t\n{\n        int fd;\n        ip_port_t ip_port;\n};*/\n\nstruct pseudo_header {\n    u32_t source_address;\n    u32_t dest_address;\n    unsigned char placeholder;\n    unsigned char protocol;\n    unsigned short tcp_length;\n};\n\nu32_t djb2(unsigned char *str, int len);\nu32_t sdbm(unsigned char *str, int len);\n\nstruct address_t  // TODO scope id\n{\n    struct hash_function {\n        u32_t operator()(const address_t &key) const {\n            return sdbm((unsigned char *)&key.inner, sizeof(key.inner));\n        }\n    };\n\n    union storage_t  // sockaddr_storage is too huge, we dont use it.\n    {\n        sockaddr_in ipv4;\n        sockaddr_in6 ipv6;\n    };\n    storage_t inner;\n\n    /*address_t()\n    {\n            clear();\n    }*/\n    void clear() {\n        memset(&inner, 0, sizeof(inner));\n    }\n    /*\n    int from_ip_port(u32_t  ip, int port)\n    {\n            clear();\n            inner.ipv4.sin_family=AF_INET;\n            inner.ipv4.sin_port=htons(port);\n            inner.ipv4.sin_addr.s_addr=ip;\n            return 0;\n    }*/\n\n    int from_ip_port_new(int type, void *ip, int port) {\n        clear();\n        if (type == AF_INET) {\n            inner.ipv4.sin_family = AF_INET;\n            inner.ipv4.sin_port = htons(port);\n            inner.ipv4.sin_addr.s_addr = *((u32_t *)ip);\n        } else if (type == AF_INET6) {\n            inner.ipv6.sin6_family = AF_INET6;\n            inner.ipv6.sin6_port = htons(port);\n            inner.ipv6.sin6_addr = *((in6_addr *)ip);\n        }\n        return 0;\n    }\n\n    int from_str(char *str);\n\n    int from_str_ip_only(char *str);\n\n    int from_sockaddr(sockaddr *, socklen_t);\n\n    char *get_str();\n    void to_str(char *);\n\n    inline int is_vaild() {\n        u32_t ret = ((sockaddr *)&inner)->sa_family;\n        return (ret == AF_INET || ret == AF_INET6);\n    }\n\n    inline u32_t get_type() {\n        assert(is_vaild());\n        u32_t ret = ((sockaddr *)&inner)->sa_family;\n        return ret;\n    }\n\n    inline u32_t get_len() {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                return sizeof(sockaddr_in);\n            case AF_INET6:\n                return sizeof(sockaddr_in6);\n            default:\n                assert(0 == 1);\n        }\n        return -1;\n    }\n\n    inline u32_t get_port() {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                return ntohs(inner.ipv4.sin_port);\n            case AF_INET6:\n                return ntohs(inner.ipv6.sin6_port);\n            default:\n                assert(0 == 1);\n        }\n        return -1;\n    }\n\n    inline void set_port(int port) {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                inner.ipv4.sin_port = htons(port);\n                break;\n            case AF_INET6:\n                inner.ipv6.sin6_port = htons(port);\n                break;\n            default:\n                assert(0 == 1);\n        }\n        return;\n    }\n\n    bool operator==(const address_t &b) const {\n        // return this->data==b.data;\n        return memcmp(&this->inner, &b.inner, sizeof(this->inner)) == 0;\n    }\n\n    int new_connected_udp_fd();\n\n    char *get_ip();\n};\n\nnamespace std {\ntemplate <>\nstruct hash<address_t> {\n    std::size_t operator()(const address_t &key) const {\n        // return address_t::hash_function(k);\n        return sdbm((unsigned char *)&key.inner, sizeof(key.inner));\n    }\n};\n}  // namespace std\n\nstruct fd64_addr_t {\n    fd64_t fd64;\n    address_t addr;\n};\nstruct fd_addr_t {\n    int fd;\n    address_t addr;\n};\nunion inner_t {\n    fd64_t fd64;\n    int fd;\n    fd64_addr_t fd64_addr;\n    fd_addr_t fd_addr;\n};\nstruct dest_t {\n    dest_type type;\n    inner_t inner;\n    u32_t conv;\n    int cook = 0;\n};\n\nstruct fd_info_t {\n    address_t addr;\n    ev_io io_watcher;\n};\n\nu64_t get_current_time();\n// u64_t get_current_time_rough();\nu64_t get_current_time_us();\nu64_t pack_u64(u32_t a, u32_t b);\n\nu32_t get_u64_h(u64_t a);\n\nu32_t get_u64_l(u64_t a);\n\nvoid write_u16(char *, u16_t a);\nu16_t read_u16(char *);\n\nvoid write_u32(char *, u32_t a);\nu32_t read_u32(char *);\n\nvoid write_u64(char *, u64_t a);\nu64_t read_uu64(char *);\n\nchar *my_ntoa(u32_t ip);\n\nvoid myexit(int a);\nvoid init_random_number_fd();\nu64_t get_fake_random_number_64();\nu32_t get_fake_random_number();\nu32_t get_fake_random_number_nz();\nu64_t ntoh64(u64_t a);\nu64_t hton64(u64_t a);\nbool larger_than_u16(uint16_t a, uint16_t b);\nbool larger_than_u32(u32_t a, u32_t b);\nvoid setnonblocking(int sock);\nint set_buf_size(int fd, int socket_buf_size);\n\nunsigned short csum(const unsigned short *ptr, int nbytes);\nunsigned short tcp_csum(const pseudo_header &ph, const unsigned short *ptr, int nbytes);\n\nvoid signal_handler(int sig);\n// int numbers_to_char(id_t id1,id_t id2,id_t id3,char * &data,int &len);\n// int char_to_numbers(const char * data,int len,id_t &id1,id_t &id2,id_t &id3);\n\nvoid myexit(int a);\n\nint add_iptables_rule(char *);\n\nint clear_iptables_rule();\nvoid get_fake_random_chars(char *s, int len);\nint random_between(u32_t a, u32_t b);\n\nint set_timer_ms(int epollfd, int &timer_fd, u32_t timer_interval);\n\nint round_up_div(int a, int b);\n\nint create_fifo(char *file);\n/*\nint create_new_udp(int &new_udp_fd,int remote_address_uint32,int remote_port);\n*/\n\nint new_listen_socket(int &fd, u32_t ip, int port);\n\nint new_connected_socket(int &fd, u32_t ip, int port);\n\nint new_listen_socket2(int &fd, address_t &addr);\nint new_connected_socket2(int &fd, address_t &addr, address_t *bind_addr, char *out_interface);\n\nstruct not_copy_able_t {\n    not_copy_able_t() {\n    }\n    not_copy_able_t(const not_copy_able_t &other) {\n        assert(0 == 1);\n    }\n    const not_copy_able_t &operator=(const not_copy_able_t &other) {\n        assert(0 == 1);\n        return other;\n    }\n};\n\ntemplate <class key_t>\nstruct lru_collector_t : not_copy_able_t {\n    // typedef void* key_t;\n    //#define key_t void*\n    struct lru_pair_t {\n        key_t key;\n        my_time_t ts;\n    };\n\n    unordered_map<key_t, typename list<lru_pair_t>::iterator> mp;\n\n    list<lru_pair_t> q;\n    int update(key_t key) {\n        assert(mp.find(key) != mp.end());\n        auto it = mp[key];\n        q.erase(it);\n\n        my_time_t value = get_current_time();\n        if (!q.empty()) {\n            assert(value >= q.front().ts);\n        }\n        lru_pair_t tmp;\n        tmp.key = key;\n        tmp.ts = value;\n        q.push_front(tmp);\n        mp[key] = q.begin();\n\n        return 0;\n    }\n    int new_key(key_t key) {\n        assert(mp.find(key) == mp.end());\n\n        my_time_t value = get_current_time();\n        if (!q.empty()) {\n            assert(value >= q.front().ts);\n        }\n        lru_pair_t tmp;\n        tmp.key = key;\n        tmp.ts = value;\n        q.push_front(tmp);\n        mp[key] = q.begin();\n\n        return 0;\n    }\n    int size() {\n        return q.size();\n    }\n    int empty() {\n        return q.empty();\n    }\n    void clear() {\n        mp.clear();\n        q.clear();\n    }\n    my_time_t ts_of(key_t key) {\n        assert(mp.find(key) != mp.end());\n        return mp[key]->ts;\n    }\n\n    my_time_t peek_back(key_t &key) {\n        assert(!q.empty());\n        auto it = q.end();\n        it--;\n        key = it->key;\n        return it->ts;\n    }\n    void erase(key_t key) {\n        assert(mp.find(key) != mp.end());\n        q.erase(mp[key]);\n        mp.erase(key);\n    }\n    /*\n    void erase_back()\n    {\n            assert(!q.empty());\n            auto it=q.end(); it--;\n            key_t key=it->key;\n            erase(key);\n    }*/\n};\n\nvector<string> string_to_vec(const char *s, const char *sp);\n\n#endif /* COMMON_H_ */\n"
        },
        {
          "name": "connection.cpp",
          "type": "blob",
          "size": 3.8544921875,
          "content": "/*\n * connection.cpp\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n\n#include \"connection.h\"\n\n// const int disable_conv_clear=0;//a udp connection in the multiplexer is called conversation in this program,conv for short.\n\nconst int disable_conn_clear = 0;  // a raw connection is called conn.\n\nint report_interval = 0;\n\nvoid server_clear_function(u64_t u64)  // used in conv_manager in server mode.for server we have to use one udp fd for one conv(udp connection),\n// so we have to close the fd when conv expires\n{\n    fd64_t fd64 = u64;\n    assert(fd_manager.exist(fd64));\n    ev_io &watcher = fd_manager.get_info(fd64).io_watcher;\n\n    address_t &addr = fd_manager.get_info(fd64).addr;            //\n    assert(conn_manager.exist(addr));                            //\n    struct ev_loop *loop = conn_manager.find_insert(addr).loop;  // overkill ? should we just use ev_default_loop(0)?\n\n    ev_io_stop(loop, &watcher);\n\n    fd_manager.fd64_close(fd64);\n}\n\n////////////////////////////////////////////////////////////////////\n\nconn_manager_t::conn_manager_t() {\n    mp.reserve(10007);\n    last_clear_time = 0;\n}\nint conn_manager_t::exist(address_t addr) {\n    if (mp.find(addr) != mp.end()) {\n        return 1;\n    }\n    return 0;\n}\n\nconn_info_t *&conn_manager_t::find_insert_p(address_t addr)  // be aware,the adress may change after rehash\n{\n    // u64_t u64=0;\n    // u64=ip;\n    // u64<<=32u;\n    // u64|=port;\n    unordered_map<address_t, conn_info_t *>::iterator it = mp.find(addr);\n    if (it == mp.end()) {\n        mp[addr] = new conn_info_t;\n        // lru.new_key(addr);\n    } else {\n        // lru.update(addr);\n    }\n    return mp[addr];\n}\nconn_info_t &conn_manager_t::find_insert(address_t addr)  // be aware,the adress may change after rehash\n{\n    // u64_t u64=0;\n    // u64=ip;\n    // u64<<=32u;\n    // u64|=port;\n    unordered_map<address_t, conn_info_t *>::iterator it = mp.find(addr);\n    if (it == mp.end()) {\n        mp[addr] = new conn_info_t;\n        // lru.new_key(addr);\n    } else {\n        // lru.update(addr);\n    }\n    return *mp[addr];\n}\nint conn_manager_t::erase(unordered_map<address_t, conn_info_t *>::iterator erase_it) {\n    delete (erase_it->second);\n    mp.erase(erase_it->first);\n    return 0;\n}\nint conn_manager_t::clear_inactive() {\n    if (get_current_time() - last_clear_time > conn_clear_interval) {\n        last_clear_time = get_current_time();\n        return clear_inactive0();\n    }\n    return 0;\n}\n\nint conn_manager_t::clear_inactive0() {\n    // mylog(log_info,\"called\\n\");\n    unordered_map<address_t, conn_info_t *>::iterator it;\n    unordered_map<address_t, conn_info_t *>::iterator old_it;\n\n    if (disable_conn_clear) return 0;\n\n    // map<uint32_t,uint64_t>::iterator it;\n    int cnt = 0;\n    it = clear_it;  // TODO,write it back\n    int size = mp.size();\n    int num_to_clean = size / conn_clear_ratio + conn_clear_min;  // clear 1/10 each time,to avoid latency glitch\n\n    // mylog(log_trace,\"mp.size() %d\\n\", size);\n\n    num_to_clean = min(num_to_clean, (int)mp.size());\n    u64_t current_time = get_current_time();\n\n    // mylog(log_info,\"here size=%d\\n\",(int)mp.size());\n    for (;;) {\n        if (cnt >= num_to_clean) break;\n        if (mp.begin() == mp.end()) break;\n        if (it == mp.end()) {\n            it = mp.begin();\n        }\n\n        if (it->second->conv_manager.s.get_size() > 0) {\n            // mylog(log_info,\"[%s:%d]size %d \\n\",my_ntoa(get_u64_h(it->first)),get_u64_l(it->first),(int)it->second->conv_manager.get_size());\n            it++;\n        } else if (current_time < it->second->last_active_time + server_conn_timeout) {\n            it++;\n        } else {\n            address_t tmp_addr = it->first;  // avoid making get_str() const;\n            mylog(log_info, \"{%s} inactive conn cleared \\n\", tmp_addr.get_str());\n            old_it = it;\n            it++;\n            erase(old_it);\n        }\n        cnt++;\n    }\n    clear_it = it;\n    return 0;\n}\n"
        },
        {
          "name": "connection.h",
          "type": "blob",
          "size": 9.9111328125,
          "content": "/*\n * connection.h\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n\n#ifndef CONNECTION_H_\n#define CONNECTION_H_\n\nextern int disable_anti_replay;\n\n#include \"connection.h\"\n#include \"common.h\"\n#include \"log.h\"\n#include \"delay_manager.h\"\n#include \"fd_manager.h\"\n#include \"fec_manager.h\"\n\nextern int report_interval;\n\nconst int disable_conv_clear = 0;\n\nvoid server_clear_function(u64_t u64);\n\ntemplate <class T>\nstruct conv_manager_t  // manage the udp connections\n{\n    // typedef hash_map map;\n    unordered_map<T, u32_t> data_to_conv;  // conv and u64 are both supposed to be uniq\n    unordered_map<u32_t, T> conv_to_data;\n\n    lru_collector_t<u32_t> lru;\n    // unordered_map<u32_t,u64_t> conv_last_active_time;\n\n    // unordered_map<u32_t,u64_t>::iterator clear_it;\n\n    void (*additional_clear_function)(T data) = 0;\n\n    long long last_clear_time;\n\n    conv_manager_t() {\n        // clear_it=conv_last_active_time.begin();\n        long long last_clear_time = 0;\n        additional_clear_function = 0;\n    }\n    ~conv_manager_t() {\n        clear();\n    }\n    int get_size() {\n        return conv_to_data.size();\n    }\n    void reserve() {\n        data_to_conv.reserve(10007);\n        conv_to_data.reserve(10007);\n        // conv_last_active_time.reserve(10007);\n\n        lru.mp.reserve(10007);\n    }\n    void clear() {\n        if (disable_conv_clear) return;\n\n        if (additional_clear_function != 0) {\n            for (auto it = conv_to_data.begin(); it != conv_to_data.end(); it++) {\n                // int fd=int((it->second<<32u)>>32u);\n                additional_clear_function(it->second);\n            }\n        }\n        data_to_conv.clear();\n        conv_to_data.clear();\n\n        lru.clear();\n        // conv_last_active_time.clear();\n\n        // clear_it=conv_last_active_time.begin();\n    }\n    u32_t get_new_conv() {\n        u32_t conv = get_fake_random_number_nz();\n        while (conv_to_data.find(conv) != conv_to_data.end()) {\n            conv = get_fake_random_number_nz();\n        }\n        return conv;\n    }\n    int is_conv_used(u32_t conv) {\n        return conv_to_data.find(conv) != conv_to_data.end();\n    }\n    int is_data_used(T data) {\n        return data_to_conv.find(data) != data_to_conv.end();\n    }\n    u32_t find_conv_by_data(T data) {\n        return data_to_conv[data];\n    }\n    T find_data_by_conv(u32_t conv) {\n        return conv_to_data[conv];\n    }\n    int update_active_time(u32_t conv) {\n        // return conv_last_active_time[conv]=get_current_time();\n        lru.update(conv);\n        return 0;\n    }\n    int insert_conv(u32_t conv, T data) {\n        data_to_conv[data] = conv;\n        conv_to_data[conv] = data;\n        // conv_last_active_time[conv]=get_current_time();\n        lru.new_key(conv);\n        return 0;\n    }\n    int erase_conv(u32_t conv) {\n        if (disable_conv_clear) return 0;\n        T data = conv_to_data[conv];\n        if (additional_clear_function != 0) {\n            additional_clear_function(data);\n        }\n        conv_to_data.erase(conv);\n        data_to_conv.erase(data);\n        // conv_last_active_time.erase(conv);\n        lru.erase(conv);\n        return 0;\n    }\n    int clear_inactive(char *info = 0) {\n        if (get_current_time() - last_clear_time > conv_clear_interval) {\n            last_clear_time = get_current_time();\n            return clear_inactive0(info);\n        }\n        return 0;\n    }\n    int clear_inactive0(char *info) {\n        if (disable_conv_clear) return 0;\n\n        unordered_map<u32_t, u64_t>::iterator it;\n        unordered_map<u32_t, u64_t>::iterator old_it;\n\n        // map<uint32_t,uint64_t>::iterator it;\n        int cnt = 0;\n        // it=clear_it;\n        int size = lru.size();\n        int num_to_clean = size / conv_clear_ratio + conv_clear_min;  // clear 1/10 each time,to avoid latency glitch\n\n        num_to_clean = min(num_to_clean, size);\n\n        my_time_t current_time = get_current_time();\n        for (;;) {\n            if (cnt >= num_to_clean) break;\n            if (lru.empty()) break;\n\n            u32_t conv;\n            my_time_t ts = lru.peek_back(conv);\n\n            if (current_time - ts < conv_timeout) break;\n\n            erase_conv(conv);\n            if (info == 0) {\n                mylog(log_info, \"conv %x cleared\\n\", conv);\n            } else {\n                mylog(log_info, \"[%s]conv %x cleared\\n\", info, conv);\n            }\n            cnt++;\n        }\n        return 0;\n    }\n\n    /*\nconv_manager_t();\n~conv_manager_t();\nint get_size();\nvoid reserve();\nvoid clear();\nu32_t get_new_conv();\nint is_conv_used(u32_t conv);\nint is_u64_used(T u64);\nu32_t find_conv_by_u64(T u64);\nT find_u64_by_conv(u32_t conv);\nint update_active_time(u32_t conv);\nint insert_conv(u32_t conv,T u64);\nint erase_conv(u32_t conv);\nint clear_inactive(char * ip_port=0);\nint clear_inactive0(char * ip_port);*/\n};  // g_conv_manager;\n\nstruct inner_stat_t {\n    u64_t input_packet_num;\n    u64_t input_packet_size;\n    u64_t output_packet_num;\n    u64_t output_packet_size;\n};\nstruct stat_t {\n    u64_t last_report_time;\n    inner_stat_t normal_to_fec;\n    inner_stat_t fec_to_normal;\n    stat_t() {\n        clear();\n    }\n    void clear(){\n        memset(this, 0, sizeof(stat_t));\n    }\n    void report_as_client() {\n        if (report_interval != 0 && get_current_time() - last_report_time > u64_t(report_interval) * 1000) {\n            last_report_time = get_current_time();\n            inner_stat_t &a = normal_to_fec;\n            inner_stat_t &b = fec_to_normal;\n            mylog(log_info, \"[report]client-->server:(original:%llu pkt;%llu byte) (fec:%llu pkt,%llu byte)  server-->client:(original:%llu pkt;%llu byte) (fec:%llu pkt;%llu byte)\\n\",\n                  a.input_packet_num, a.input_packet_size, a.output_packet_num, a.output_packet_size,\n                  b.output_packet_num, b.output_packet_size, b.input_packet_num, b.input_packet_size);\n        }\n    }\n    void report_as_server(address_t &addr) {\n        if (report_interval != 0 && get_current_time() - last_report_time > u64_t(report_interval) * 1000) {\n            last_report_time = get_current_time();\n            inner_stat_t &a = fec_to_normal;\n            inner_stat_t &b = normal_to_fec;\n            mylog(log_info, \"[report][%s]client-->server:(original:%llu pkt;%llu byte) (fec:%llu pkt;%llu byte)  server-->client:(original:%llu pkt;%llu byte) (fec:%llu pkt;%llu byte)\\n\",\n                  addr.get_str(),\n                  a.output_packet_num, a.output_packet_size, a.input_packet_num, a.input_packet_size,\n                  b.input_packet_num, b.input_packet_size, b.output_packet_num, b.output_packet_size);\n        }\n    }\n};\n\nstruct conn_info_t : not_copy_able_t  // stores info for a raw connection.for client ,there is only one connection,for server there can be thousand of connection since server can\n// handle multiple clients\n{\n    union tmp_union_t {\n        conv_manager_t<address_t> c;\n        conv_manager_t<u64_t> s;\n        // avoid templates here and there, avoid pointer and type cast\n        tmp_union_t() {\n            if (program_mode == client_mode) {\n                new (&c) conv_manager_t<address_t>();\n            } else {\n                assert(program_mode == server_mode);\n                new (&s) conv_manager_t<u64_t>();\n            }\n        }\n        ~tmp_union_t() {\n            if (program_mode == client_mode) {\n                c.~conv_manager_t<address_t>();\n            } else {\n                assert(program_mode == server_mode);\n                s.~conv_manager_t<u64_t>();\n            }\n        }\n    } conv_manager;\n\n    fec_encode_manager_t fec_encode_manager;\n    fec_decode_manager_t fec_decode_manager;\n    ev_timer timer;\n    // my_timer_t timer;\n\n    u64_t last_active_time;\n    stat_t stat;\n\n    struct ev_loop *loop = 0;\n    int local_listen_fd;\n\n    int remote_fd;       // only used for client\n    fd64_t remote_fd64;  // only used for client\n\n    // ip_port_t ip_port;\n    address_t addr;  // only used for server\n\n    conn_info_t() {\n        if (program_mode == server_mode) {\n            conv_manager.s.additional_clear_function = server_clear_function;\n        } else {\n            assert(program_mode == client_mode);\n        }\n    }\n\n    ~conn_info_t() {\n        if (loop)\n            ev_timer_stop(loop, &timer);\n    }\n    void update_active_time() {\n        last_active_time = get_current_time();\n    }\n    /*\n    conn_info_t(const conn_info_t &b)\n    {\n            assert(0==1);\n    }*/\n};\n/*\nstruct conn_manager_t  //manager for connections. for client,we dont need conn_manager since there is only one connection.for server we use one conn_manager for all connections\n{\n\n        unordered_map<u64_t,conn_info_t*> mp;//<ip,port> to conn_info_t;\n        unordered_map<u64_t,conn_info_t*>::iterator clear_it;\n        long long last_clear_time;\n\n        conn_manager_t();\n        conn_manager_t(const conn_info_t &b)\n        {\n                assert(0==1);\n        }\n        int exist(ip_port_t);\n        conn_info_t *& find_p(ip_port_t);  //be aware,the adress may change after rehash\n        conn_info_t & find(ip_port_t) ; //be aware,the adress may change after rehash\n        int insert(ip_port_t);\n\n        int erase(unordered_map<u64_t,conn_info_t*>::iterator erase_it);\n        int clear_inactive();\n        int clear_inactive0();\n\n};*/\n\nstruct conn_manager_t  // manager for connections. for client,we dont need conn_manager since there is only one connection.for server we use one conn_manager for all connections\n{\n    unordered_map<address_t, conn_info_t *> mp;  // put it at end so that it de-consturcts first\n    unordered_map<address_t, conn_info_t *>::iterator clear_it;\n\n    long long last_clear_time;\n\n    conn_manager_t();\n    int exist(address_t addr);\n    conn_info_t *&find_insert_p(address_t addr);  // be aware,the adress may change after rehash //not true?\n    conn_info_t &find_insert(address_t addr);     // be aware,the adress may change after rehash\n\n    int erase(unordered_map<address_t, conn_info_t *>::iterator erase_it);\n    int clear_inactive();\n    int clear_inactive0();\n};\n\nextern conn_manager_t conn_manager;\n\n#endif /* CONNECTION_H_ */\n"
        },
        {
          "name": "delay_manager.cpp",
          "type": "blob",
          "size": 3.11328125,
          "content": "/*\n * delay_manager.cpp\n *\n *  Created on: Sep 15, 2017\n *      Author: root\n */\n#include \"delay_manager.h\"\n#include \"log.h\"\n#include \"packet.h\"\n\nint delay_data_t::handle() {\n    return my_send(dest, data, len) >= 0;\n}\n\ndelay_manager_t::delay_manager_t() {\n    capacity = 0;\n\n    // if ((timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)) < 0)\n    //{\n    //\tmylog(log_fatal,\"timer_fd create error\");\n    //\tmyexit(1);\n    // }\n\n    // itimerspec zero_its;\n    // memset(&zero_its, 0, sizeof(zero_its));\n\n    // timerfd_settime(timer_fd, TFD_TIMER_ABSTIME, &zero_its, 0);\n}\ndelay_manager_t::~delay_manager_t() {\n    // TODO ,we currently dont need to deconstruct it\n}\n\n/*\nint delay_manager_t::get_timer_fd()\n{\n        return timer_fd;\n}*/\n\n// int add(my_time_t delay,const dest_t &dest,const char *data,int len);\nint delay_manager_t::add(my_time_t delay, const dest_t &dest, char *data, int len) {\n    delay_data_t delay_data;\n    delay_data.dest = dest;\n    // delay_data.data=data;\n    delay_data.len = len;\n\n    if (capacity != 0 && int(delay_mp.size()) >= capacity) {\n        mylog(log_warn, \"max pending packet reached,ignored\\n\");\n        return -1;\n    }\n    if (delay == 0) {\n        static char buf[buf_len];\n        delay_data.data = buf;\n        memcpy(buf, data, len);\n        int ret = delay_data.handle();\n        if (ret != 0) {\n            mylog(log_trace, \"handle() return %d\\n\", ret);\n        }\n        return 0;\n    }\n\n    delay_data_t tmp = delay_data;\n    tmp.data = (char *)malloc(delay_data.len + 100);\n    if (!tmp.data) {\n        mylog(log_warn, \"malloc() returned null in delay_manager_t::add()\");\n        return -1;\n    }\n    memcpy(tmp.data, data, delay_data.len);\n\n    my_time_t tmp_time = get_current_time_us();\n    tmp_time += delay;\n\n    delay_mp.insert(make_pair(tmp_time, tmp));\n\n    ////check();  check everytime when add, is it better ??\n\n    return 0;\n}\n\nint delay_manager_t::check() {\n    if (!delay_mp.empty()) {\n        my_time_t current_time;\n\n        multimap<my_time_t, delay_data_t>::iterator it;\n        while (1) {\n            int ret = 0;\n            it = delay_mp.begin();\n            if (it == delay_mp.end()) break;\n\n            current_time = get_current_time_us();\n            if (it->first <= current_time) {\n                ret = it->second.handle();\n                if (ret != 0) {\n                    mylog(log_trace, \"handle() return %d\\n\", ret);\n                }\n                free(it->second.data);\n                delay_mp.erase(it);\n            } else {\n                break;\n            }\n        }\n        if (!delay_mp.empty()) {\n            const double m = 1000 * 1000;\n            double timer_value = delay_mp.begin()->first / m - get_current_time_us() / m;  // be aware of negative value, and be aware of uint\n            if (timer_value < 0) timer_value = 0;                                          // set it to 0 if negative, although libev support negative value\n            ev_timer_stop(loop, &timer);\n            ev_timer_set(&timer, timer_value, 0);\n            ev_timer_start(loop, &timer);\n        } else {\n            ev_timer_stop(loop, &timer);  // not necessary\n        }\n    }\n    return 0;\n}\n"
        },
        {
          "name": "delay_manager.h",
          "type": "blob",
          "size": 3.7353515625,
          "content": "/*\n * delay_manager.h\n *\n *  Created on: Sep 15, 2017\n *      Author: root\n */\n\n#ifndef DELAY_MANAGER_H_\n#define DELAY_MANAGER_H_\n\n#include \"common.h\"\n#include \"packet.h\"\n#include \"log.h\"\n\n// enum delay_type_t {none=0,enum_sendto_u64,enum_send_fd,client_to_local,client_to_remote,server_to_local,server_to_remote};\n\n/*\nstruct fd_ip_port_t\n{\n        int fd;\n        u32_t ip;\n        u32_t port;\n};\nunion dest_t\n{\n        fd_ip_port_t fd_ip_port;\n        int fd;\n        u64_t u64;\n};\n*/\n/*\nstruct my_timer_t\n{\n        int timer_fd;\n        fd64_t timer_fd64;\n        my_timer_t()\n        {\n                if ((timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)) < 0)\n                {\n                        mylog(log_fatal,\"timer_fd create error\");\n                        myexit(1);\n                }\n                timer_fd64=fd_manager.create(timer_fd);\n        }\n        my_timer_t(const my_timer_t &b)\n        {\n                assert(0==1);\n        }\n        ~my_timer_t()\n        {\n                fd_manager.fd64_close(timer_fd64);\n        }\n        int add_fd_to_epoll(int epoll_fd)\n        {\n                epoll_event ev;;\n                ev.events = EPOLLIN;\n                ev.data.u64 = timer_fd;\n                int ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, timer_fd, &ev);\n                if (ret!= 0) {\n                        mylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n                        myexit(-1);\n                }\n                return 0;\n        }\n        int add_fd64_to_epoll(int epoll_fd)\n        {\n                epoll_event ev;;\n                ev.events = EPOLLIN;\n                ev.data.u64 = timer_fd64;\n                int ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, timer_fd, &ev);\n                if (ret!= 0) {\n                        mylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n                        myexit(-1);\n                }\n                return 0;\n        }\n        int get_timer_fd()\n        {\n                return timer_fd;\n        }\n        fd64_t get_timer_fd64()\n        {\n                return timer_fd64;\n        }\n        int set_timer_repeat_us(my_time_t my_time)\n        {\n                itimerspec its;\n                memset(&its,0,sizeof(its));\n                its.it_interval.tv_sec=my_time/1000000llu;\n                its.it_interval.tv_nsec=my_time%1000000llu*1000llu;\n                its.it_value.tv_nsec=1; //imidiately\n                timerfd_settime(timer_fd,0,&its,0);\n                return 0;\n        }\n        int set_timer_abs_us(my_time_t my_time)\n        {\n                itimerspec its;\n                memset(&its,0,sizeof(its));\n                its.it_value.tv_sec=my_time/1000000llu;\n                its.it_value.tv_nsec=my_time%1000000llu*1000llu;\n                timerfd_settime(timer_fd,TFD_TIMER_ABSTIME,&its,0);\n                return 0;\n        }\n};*/\n\nstruct delay_data_t {\n    dest_t dest;\n    // int left_time;//\n    char *data;\n    int len;\n    int handle();\n};\n\nstruct delay_manager_t {\n    ev_timer timer;\n    struct ev_loop *loop = 0;\n    void (*cb)(struct ev_loop *loop, struct ev_timer *watcher, int revents) = 0;\n\n    // int timer_fd;\n    int capacity;\n    multimap<my_time_t, delay_data_t> delay_mp;  // unit us,1 us=0.001ms\n    delay_manager_t();\n    delay_manager_t(delay_manager_t &b) {\n        assert(0 == 1);\n    }\n    void set_loop_and_cb(struct ev_loop *loop, void (*cb)(struct ev_loop *loop, struct ev_timer *watcher, int revents)) {\n        this->loop = loop;\n        this->cb = cb;\n        ev_init(&timer, cb);\n    }\n    int set_capacity(int a) {\n        capacity = a;\n        return 0;\n    }\n    ~delay_manager_t();\n    ev_timer &get_timer();\n    int check();\n    int add(my_time_t delay, const dest_t &dest, char *data, int len);\n};\n\n#endif /* DELAY_MANAGER_H_ */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "fd_manager.cpp",
          "type": "blob",
          "size": 1.2216796875,
          "content": "/*\n * fd_manager.cpp\n *\n *  Created on: Sep 25, 2017\n *      Author: root\n */\n\n#include \"fd_manager.h\"\nint fd_manager_t::fd_exist(int fd) {\n    return fd_to_fd64_mp.find(fd) != fd_to_fd64_mp.end();\n}\nint fd_manager_t::exist(fd64_t fd64) {\n    return fd64_to_fd_mp.find(fd64) != fd64_to_fd_mp.end();\n}\nint fd_manager_t::to_fd(fd64_t fd64) {\n    assert(exist(fd64));\n    return fd64_to_fd_mp[fd64];\n}\nvoid fd_manager_t::fd64_close(fd64_t fd64) {\n    assert(exist(fd64));\n    int fd = fd64_to_fd_mp[fd64];\n    fd64_to_fd_mp.erase(fd64);\n    fd_to_fd64_mp.erase(fd);\n    if (exist_info(fd64)) {\n        fd_info_mp.erase(fd64);\n    }\n    sock_close(fd);\n}\nvoid fd_manager_t::reserve(int n) {\n    fd_to_fd64_mp.reserve(n);\n    fd64_to_fd_mp.reserve(n);\n    fd_info_mp.reserve(n);\n}\nu64_t fd_manager_t::create(int fd) {\n    assert(!fd_exist(fd));\n    fd64_t fd64 = counter++;\n    fd_to_fd64_mp[fd] = fd64;\n    fd64_to_fd_mp[fd64] = fd;\n    return fd64;\n}\nfd_manager_t::fd_manager_t() {\n    counter = u32_t(-1);\n    counter += 100;\n    reserve(10007);\n}\nfd_info_t& fd_manager_t::get_info(fd64_t fd64) {\n    assert(exist(fd64));\n    return fd_info_mp[fd64];\n}\nint fd_manager_t::exist_info(fd64_t fd64) {\n    return fd_info_mp.find(fd64) != fd_info_mp.end();\n}\n"
        },
        {
          "name": "fd_manager.h",
          "type": "blob",
          "size": 0.8828125,
          "content": "/*\n * fd_manager.h\n *\n *  Created on: Sep 25, 2017\n *      Author: root\n */\n\n#ifndef FD_MANAGER_H_\n#define FD_MANAGER_H_\n\n#include \"common.h\"\n#include \"packet.h\"\n\nstruct fd_manager_t  // conver fd to a uniq 64bit number,avoid fd value conflict caused by close and re-create\n// this class is not strictly necessary,it just makes epoll fd handling easier\n{\n    fd_info_t& get_info(fd64_t fd64);\n    int exist_info(fd64_t);\n    int exist(fd64_t fd64);\n    int to_fd(fd64_t);\n    void fd64_close(fd64_t fd64);\n    void reserve(int n);\n    u64_t create(int fd);\n    fd_manager_t();\n\n   private:\n    u64_t counter;\n    unordered_map<int, fd64_t> fd_to_fd64_mp;\n    unordered_map<fd64_t, int> fd64_to_fd_mp;\n    unordered_map<fd64_t, fd_info_t> fd_info_mp;\n    int fd_exist(int fd);\n    // void remove_fd(int fd);\n    // fd64_t fd_to_fd64(int fd);\n};\n\nextern fd_manager_t fd_manager;\n#endif /* FD_MANAGER_H_ */\n"
        },
        {
          "name": "fec_manager.cpp",
          "type": "blob",
          "size": 27.2919921875,
          "content": "/*\n * fec_manager.cpp\n *\n *  Created on: Sep 27, 2017\n *      Author: root\n */\n\n#include \"fec_manager.h\"\n#include \"log.h\"\n#include \"common.h\"\n#include \"lib/rs.h\"\n#include \"fd_manager.h\"\n\n// int g_fec_data_num=20;\n// int g_fec_redundant_num=10;\n// int g_fec_mtu=1250;\n// int g_fec_queue_len=200;\n// int g_fec_timeout=8*1000; //8ms\n// int g_fec_mode=0;\n\nfec_parameter_t g_fec_par;\n\nint debug_fec_enc = 0;\nint debug_fec_dec = 0;\n// int dynamic_update_fec=1;\n\nconst int encode_fast_send = 1;\nconst int decode_fast_send = 1;\n\nint short_packet_optimize = 1;\nint header_overhead = 40;\n\nu32_t fec_buff_num = 2000;  // how many packet can fec_decode_manager hold. shouldnt be very large,or it will cost huge memory\n\nblob_encode_t::blob_encode_t() {\n    clear();\n}\nint blob_encode_t::clear() {\n    counter = 0;\n    current_len = (int)sizeof(u32_t);\n    return 0;\n}\n\nint blob_encode_t::get_num() {\n    return counter;\n}\nint blob_encode_t::get_shard_len(int n) {\n    return round_up_div(current_len, n);\n}\n\nint blob_encode_t::get_shard_len(int n, int next_packet_len) {\n    return round_up_div(current_len + (int)sizeof(u16_t) + next_packet_len, n);\n}\n\nint blob_encode_t::input(char *s, int len) {\n    assert(current_len + len + sizeof(u16_t) + 100 < sizeof(input_buf));\n    assert(len <= 65535 && len >= 0);\n    counter++;\n    assert(counter <= max_blob_packet_num);\n    write_u16(input_buf + current_len, len);\n    current_len += sizeof(u16_t);\n    memcpy(input_buf + current_len, s, len);\n    current_len += len;\n    return 0;\n}\n\nint blob_encode_t::output(int n, char **&s_arr, int &len) {\n    len = round_up_div(current_len, n);\n    write_u32(input_buf, counter);\n    for (int i = 0; i < n; i++) {\n        output_buf[i] = input_buf + len * i;\n    }\n    s_arr = output_buf;\n    return 0;\n}\nblob_decode_t::blob_decode_t() {\n    clear();\n}\nint blob_decode_t::clear() {\n    current_len = 0;\n    last_len = -1;\n    counter = 0;\n    return 0;\n}\nint blob_decode_t::input(char *s, int len) {\n    if (last_len != -1) {\n        assert(last_len == len);\n    }\n    counter++;\n    assert(counter <= max_fec_packet_num);\n    last_len = len;\n    assert(current_len + len + 100 < (int)sizeof(input_buf));  // avoid overflow\n    memcpy(input_buf + current_len, s, len);\n    current_len += len;\n    return 0;\n}\nint blob_decode_t::output(int &n, char **&s_arr, int *&len_arr) {\n    int parser_pos = 0;\n\n    if (parser_pos + (int)sizeof(u32_t) > current_len) {\n        mylog(log_info, \"failed 0\\n\");\n        return -1;\n    }\n\n    n = (int)read_u32(input_buf + parser_pos);\n    if (n > max_blob_packet_num) {\n        mylog(log_info, \"failed 1\\n\");\n        return -1;\n    }\n    s_arr = output_buf;\n    len_arr = output_len;\n\n    parser_pos += sizeof(u32_t);\n    for (int i = 0; i < n; i++) {\n        if (parser_pos + (int)sizeof(u16_t) > current_len) {\n            mylog(log_info, \"failed2 \\n\");\n            return -1;\n        }\n        len_arr[i] = (int)read_u16(input_buf + parser_pos);\n        parser_pos += (int)sizeof(u16_t);\n        if (parser_pos + len_arr[i] > current_len) {\n            mylog(log_info, \"failed 3 %d  %d %d\\n\", parser_pos, len_arr[i], current_len);\n            return -1;\n        }\n        s_arr[i] = input_buf + parser_pos;\n        parser_pos += len_arr[i];\n    }\n    return 0;\n}\n\nfec_encode_manager_t::~fec_encode_manager_t() {\n    clear_all();\n    // fd_manager.fd64_close(timer_fd64);\n}\n/*\nu64_t fec_encode_manager_t::get_timer_fd64()\n{\n        return timer_fd64;\n}*/\n\nfec_encode_manager_t::fec_encode_manager_t() {\n    // int timer_fd;\n\n    /*\n    if ((timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)) < 0)\n    {\n            mylog(log_fatal,\"timer_fd create error\");\n            myexit(1);\n    }\n    timer_fd64=fd_manager.create(timer_fd);*/\n\n    /////reset_fec_parameter(g_fec_data_num,g_fec_redundant_num,g_fec_mtu,g_fec_queue_len,g_fec_timeout,g_fec_mode);\n\n    fec_par.clone(g_fec_par);\n    clear_data();\n}\n/*\nint fec_encode_manager_t::reset_fec_parameter(int data_num,int redundant_num,int mtu,int queue_len,int timeout,int mode)\n{\n        fec_data_num=data_num;\n        fec_redundant_num=redundant_num;\n        fec_mtu=mtu;\n        fec_queue_len=queue_len;\n        fec_timeout=timeout;\n        fec_mode=mode;\n\n        assert(data_num+redundant_num<max_fec_packet_num);\n\n        //clear();\n\n        clear_data();\n        return 0;\n}*/\nint fec_encode_manager_t::append(char *s, int len /*,int &is_first_packet*/) {\n    if (counter == 0) {\n        first_packet_time = get_current_time_us();\n\n        const double m = 1000 * 1000;\n\n        ev_timer_stop(loop, &timer);\n        ev_timer_set(&timer, fec_par.timeout / m, 0);\n        ev_timer_start(loop, &timer);\n    }\n    if (fec_par.mode == 0)  // for type 0 use blob\n    {\n        assert(blob_encode.input(s, len) == 0);\n    } else if (fec_par.mode == 1)  // for tpe 1 use  input_buf and counter\n    {\n        mylog(log_trace, \"counter=%d\\n\", counter);\n        assert(len <= 65535 && len >= 0);\n        // assert(len<=fec_mtu);//relax this limitation\n        char *p = input_buf[counter] + sizeof(u32_t) + 4 * sizeof(char);  // copy directly to final position,avoid unnecessary copy.\n        // remember to change this,if protocol is modified\n\n        write_u16(p, (u16_t)((u32_t)len));  // TODO  omit this u16 for data packet while sending\n        p += sizeof(u16_t);\n        memcpy(p, s, len);\n        input_len[counter] = len + sizeof(u16_t);\n    } else {\n        assert(0 == 1);\n    }\n    counter++;\n    return 0;\n}\nint fec_encode_manager_t::input(char *s, int len /*,int &is_first_packet*/) {\n    if (counter == 0 && fec_par.version != g_fec_par.version) {\n        fec_par.clone(g_fec_par);\n    }\n\n    int about_to_fec = 0;\n    int delayed_append = 0;\n    // int counter_back=counter;\n    assert(fec_par.mode == 0 || fec_par.mode == 1);\n\n    if (fec_par.mode == 0 && s != 0 && counter == 0) {\n        int out_len = blob_encode.get_shard_len(fec_par.get_tail().x, len);\n        if (out_len > fec_par.mtu) {\n            mylog(log_warn, \"message too long ori_len=%d out_len=%d fec_mtu=%d,ignored\\n\", len, out_len, fec_par.mtu);\n            return -1;\n        }\n    }\n    if (fec_par.mode == 1 && s != 0 && len > fec_par.mtu) {\n        mylog(log_warn, \"mode==1,message len=%d,len>fec_mtu,fec_mtu=%d,packet may not be delivered\\n\", len, fec_par.mtu);\n        // return -1;\n    }\n    if (s == 0 && counter == 0) {\n        mylog(log_warn, \"unexpected s==0&&counter==0\\n\");\n        return -1;\n    }\n    if (s == 0) about_to_fec = 1;  // now\n\n    if (fec_par.mode == 0 && blob_encode.get_shard_len(fec_par.get_tail().x, len) > fec_par.mtu) {\n        about_to_fec = 1;\n        delayed_append = 1;\n    }  // fec then add packet\n\n    if (fec_par.mode == 0) assert(counter < fec_par.queue_len);  // counter will never equal fec_pending_num,if that happens fec should already been done.\n    if (fec_par.mode == 1) assert(counter < fec_par.get_tail().x);\n\n    if (s != 0 && !delayed_append) {\n        append(s, len);\n    }\n\n    if (fec_par.mode == 0 && counter == fec_par.queue_len) about_to_fec = 1;\n\n    if (fec_par.mode == 1 && counter == fec_par.get_tail().x) about_to_fec = 1;\n\n    if (about_to_fec) {\n        char **blob_output = 0;\n        int fec_len = -1;\n        mylog(log_trace, \"counter=%d\\n\", counter);\n\n        if (counter == 0) {\n            mylog(log_warn, \"unexpected counter==0 here\\n\");\n            return -1;\n        }\n\n        int actual_data_num;\n        int actual_redundant_num;\n\n        if (fec_par.mode == 0) {\n            int tail_x = fec_par.get_tail().x;\n            int tail_y = fec_par.get_tail().y;\n            actual_data_num = tail_x;\n            actual_redundant_num = tail_y;\n\n            if (short_packet_optimize) {\n                u32_t best_len = (blob_encode.get_shard_len(tail_x, 0) + header_overhead) * (tail_x + tail_y);\n                int best_data_num = tail_x;\n                assert(tail_x <= fec_par.rs_cnt);\n                for (int i = 1; i < tail_x; i++) {\n                    assert(fec_par.rs_par[i - 1].x == i);\n                    int tmp_x = fec_par.rs_par[i - 1].x;\n                    int tmp_y = fec_par.rs_par[i - 1].y;\n                    assert(tmp_x == i);\n                    u32_t shard_len = blob_encode.get_shard_len(tmp_x, 0);\n                    if (shard_len > (u32_t)fec_par.mtu) continue;\n\n                    u32_t new_len = (shard_len + header_overhead) * (tmp_x + tmp_y);\n                    if (new_len < best_len) {\n                        best_len = new_len;\n                        best_data_num = tmp_x;\n                    }\n                }\n                actual_data_num = best_data_num;\n                assert(best_data_num >= 1 && best_data_num <= fec_par.rs_cnt);\n                actual_redundant_num = fec_par.rs_par[best_data_num - 1].y;\n            }\n\n            assert(blob_encode.output(actual_data_num, blob_output, fec_len) == 0);\n\n            if (debug_fec_enc)\n                mylog(log_debug, \"[enc]seq=%08x x=%d y=%d len=%d cnt=%d\\n\", seq, actual_data_num, actual_redundant_num, fec_len, counter);\n            else\n                mylog(log_trace, \"[enc]seq=%08x x=%d y=%d len=%d cnt=%d\\n\", seq, actual_data_num, actual_redundant_num, fec_len, counter);\n        } else {\n            assert(counter <= fec_par.rs_cnt);\n            actual_data_num = counter;\n            actual_redundant_num = fec_par.rs_par[counter - 1].y;\n\n            int sum_ori = 0;\n            for (int i = 0; i < counter; i++) {\n                sum_ori += input_len[i];\n                assert(input_len[i] >= 0);\n                if (input_len[i] > fec_len) fec_len = input_len[i];\n            }\n\n            int sum = fec_len * counter;\n\n            if (debug_fec_enc)\n                mylog(log_debug, \"[enc]seq=%08x x=%d y=%d len=%d sum_ori=%d sum=%d\\n\", seq, actual_data_num, actual_redundant_num, fec_len, sum_ori, sum);\n            else\n                mylog(log_trace, \"[enc]seq=%08x x=%d y=%d len=%d sum_ori=%d sum=%d\\n\", seq, actual_data_num, actual_redundant_num, fec_len, sum_ori, sum);\n        }\n\n        // mylog(log_trace,\"%d %d %d\\n\",actual_data_num,actual_redundant_num,fec_len);\n\n        char *tmp_output_buf[max_fec_packet_num + 5] = {0};\n        for (int i = 0; i < actual_data_num + actual_redundant_num; i++) {\n            int tmp_idx = 0;\n\n            write_u32(input_buf[i] + tmp_idx, seq);\n            tmp_idx += sizeof(u32_t);\n            input_buf[i][tmp_idx++] = (unsigned char)fec_par.mode;\n            if (fec_par.mode == 1 && i < actual_data_num) {\n                input_buf[i][tmp_idx++] = (unsigned char)0;\n                input_buf[i][tmp_idx++] = (unsigned char)0;\n            } else {\n                input_buf[i][tmp_idx++] = (unsigned char)actual_data_num;\n                input_buf[i][tmp_idx++] = (unsigned char)actual_redundant_num;\n            }\n            input_buf[i][tmp_idx++] = (unsigned char)i;\n\n            tmp_output_buf[i] = input_buf[i] + tmp_idx;  //////caution ,trick here.\n\n            if (fec_par.mode == 0) {\n                output_len[i] = tmp_idx + fec_len;\n                if (i < actual_data_num) {\n                    memcpy(input_buf[i] + tmp_idx, blob_output[i], fec_len);\n                }\n            } else {\n                if (i < actual_data_num) {\n                    output_len[i] = tmp_idx + input_len[i];\n                    memset(tmp_output_buf[i] + input_len[i], 0, fec_len - input_len[i]);\n                } else\n                    output_len[i] = tmp_idx + fec_len;\n            }\n            output_buf[i] = input_buf[i];  // output_buf points to same block of memory with different offset\n        }\n\n        if (0) {\n            printf(\"seq=%u,fec_len=%d,%d %d,before fec\\n\", seq, fec_len, actual_data_num, actual_redundant_num);\n\n            for (int i = 0; i < actual_data_num; i++) {\n                printf(\"{\");\n                for (int j = 0; j < 8 + fec_len; j++) {\n                    log_bare(log_warn, \"0x%02x,\", (u32_t)(unsigned char)input_buf[i][j]);\n                }\n                printf(\"},\\n\");\n                // log_bare(log_warn,\"\")\n            }\n        }\n        // output_len=blob_len+sizeof(u32_t)+4*sizeof(char);/////remember to change this 4,if modified the protocol\n        rs_encode2(actual_data_num, actual_data_num + actual_redundant_num, tmp_output_buf, fec_len);\n\n        if (0) {\n            printf(\"seq=%u,fec_len=%d,%d %d,after fec\\n\", seq, fec_len, actual_data_num, actual_redundant_num);\n            for (int i = 0; i < actual_data_num + actual_redundant_num; i++) {\n                printf(\"{\");\n                for (int j = 0; j < 8 + fec_len; j++) {\n                    log_bare(log_warn, \"0x%02x,\", (u32_t)(unsigned char)output_buf[i][j]);\n                }\n                printf(\"},\\n\");\n                // log_bare(log_warn,\"\")\n            }\n        }\n\n        // mylog(log_trace,\"!!! s= %d\\n\");\n        assert(ready_for_output == 0);\n        ready_for_output = 1;\n        first_packet_time_for_output = first_packet_time;\n        first_packet_time = 0;\n        seq++;\n        counter = 0;\n        output_n = actual_data_num + actual_redundant_num;\n        blob_encode.clear();\n\n        my_itimerspec its;\n        memset(&its, 0, sizeof(its));\n        ev_timer_stop(loop, &timer);\n        // timerfd_settime(timer_fd,TFD_TIMER_ABSTIME,&its,0);\n\n        if (encode_fast_send && fec_par.mode == 1) {\n            int packet_to_send[max_fec_packet_num + 5] = {0};\n            int packet_to_send_counter = 0;\n\n            // assert(counter!=0);\n            if (s != 0)\n                packet_to_send[packet_to_send_counter++] = actual_data_num - 1;\n            for (int i = actual_data_num; i < actual_data_num + actual_redundant_num; i++) {\n                packet_to_send[packet_to_send_counter++] = i;\n            }\n            output_n = packet_to_send_counter;  // re write\n            for (int i = 0; i < packet_to_send_counter; i++) {\n                output_buf[i] = output_buf[packet_to_send[i]];\n                output_len[i] = output_len[packet_to_send[i]];\n            }\n        }\n    } else {\n        if (encode_fast_send && s != 0 && fec_par.mode == 1) {\n            assert(counter >= 1);\n            assert(counter <= 255);\n            int input_buf_idx = counter - 1;\n            assert(ready_for_output == 0);\n            ready_for_output = 1;\n            first_packet_time_for_output = 0;\n            output_n = 1;\n\n            int tmp_idx = 0;\n            write_u32(input_buf[input_buf_idx] + tmp_idx, seq);\n            tmp_idx += sizeof(u32_t);\n\n            input_buf[input_buf_idx][tmp_idx++] = (unsigned char)fec_par.mode;\n            input_buf[input_buf_idx][tmp_idx++] = (unsigned char)0;\n            input_buf[input_buf_idx][tmp_idx++] = (unsigned char)0;\n            input_buf[input_buf_idx][tmp_idx++] = (unsigned char)((u32_t)input_buf_idx);\n\n            output_len[0] = input_len[input_buf_idx] + tmp_idx;\n            output_buf[0] = input_buf[input_buf_idx];\n\n            if (0) {\n                printf(\"seq=%u,buf_idx=%d\\n\", seq, input_buf_idx);\n                for (int j = 0; j < output_len[0]; j++) {\n                    log_bare(log_warn, \"0x%02x,\", (u32_t)(unsigned char)output_buf[0][j]);\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n\n    if (s != 0 && delayed_append) {\n        assert(fec_par.mode != 1);\n        append(s, len);\n    }\n\n    return 0;\n}\n\nint fec_encode_manager_t::output(int &n, char **&s_arr, int *&len) {\n    if (!ready_for_output) {\n        n = -1;\n        len = 0;\n        s_arr = 0;\n    } else {\n        n = output_n;\n        len = output_len;\n        s_arr = output_buf;\n        ready_for_output = 0;\n    }\n    return 0;\n}\n/*\nint fec_decode_manager_t::re_init()\n{\n        clear();\n        return 0;\n}*/\n\nint fec_decode_manager_t::input(char *s, int len) {\n    assert(s != 0);\n    assert(len + 100 < buf_len);  // guarenteed by upper level\n\n    int tmp_idx = 0;\n    int tmp_header_len = sizeof(u32_t) + sizeof(char) * 4;\n    if (len < tmp_header_len) {\n        mylog(log_warn, \"len =%d\\n\", len);\n        return -1;\n    }\n    u32_t seq = read_u32(s + tmp_idx);\n    tmp_idx += sizeof(u32_t);\n    int type = (unsigned char)s[tmp_idx++];\n    int data_num = (unsigned char)s[tmp_idx++];\n    int redundant_num = (unsigned char)s[tmp_idx++];\n    int inner_index = (unsigned char)s[tmp_idx++];\n    len = len - tmp_idx;\n\n    // mylog(log_trace,\"input\\n\");\n\n    if (len < 0) {\n        mylog(log_warn, \"len<0\\n\");\n        return -1;\n    }\n\n    if (type == 1) {\n        if (len < (int)sizeof(u16_t)) {\n            mylog(log_warn, \"type==1&&len<2\\n\");\n            return -1;\n        }\n        if (data_num == 0 && (int)(read_u16(s + tmp_idx) + sizeof(u16_t)) != len) {\n            mylog(log_warn, \"inner_index<data_num&&read_u16(s+tmp_idx)+sizeof(u16_t)!=len    %d %d\\n\", (int)(read_u16(s + tmp_idx) + sizeof(u16_t)), len);\n            return -1;\n        }\n    }\n\n    if (type == 0 && data_num == 0) {\n        mylog(log_warn, \"unexpected type==0&&data_num==0\\n\");\n        return -1;\n    }\n    if (data_num + redundant_num >= max_fec_packet_num) {\n        mylog(log_warn, \"data_num+redundant_num>=max_fec_packet_num\\n\");\n        return -1;\n    }\n    if (!anti_replay.is_vaild(seq)) {\n        mylog(log_trace, \"!anti_replay.is_vaild(seq) ,seq =%u\\n\", seq);\n        return 0;\n    }\n\n    if (mp[seq].fec_done != 0) {\n        mylog(log_debug, \"fec already done, ignore, seq=%u\\n\", seq);\n        return -1;\n    }\n\n    if (mp[seq].group_mp.find(inner_index) != mp[seq].group_mp.end()) {\n        mylog(log_debug, \"dup fec index\\n\");  // duplicate can happen on  a normal network, so its just log_debug\n        return -1;\n    }\n\n    if (mp[seq].type == -1)\n        mp[seq].type = type;\n    else {\n        if (mp[seq].type != type) {\n            mylog(log_warn, \"type mismatch\\n\");\n            return -1;\n        }\n    }\n\n    if (data_num != 0) {\n        // mp[seq].data_counter++;\n\n        if (mp[seq].data_num == -1) {\n            mp[seq].data_num = data_num;\n            mp[seq].redundant_num = redundant_num;\n            mp[seq].len = len;\n        } else {\n            if (mp[seq].data_num != data_num || mp[seq].redundant_num != redundant_num || mp[seq].len != len) {\n                mylog(log_warn, \"unexpected mp[seq].data_num!=data_num||mp[seq].redundant_num!=redundant_num||mp[seq].len!=len\\n\");\n                return -1;\n            }\n        }\n    }\n\n    // mylog(log_info,\"mp.size()=%d index=%d\\n\",mp.size(),index);\n\n    if (fec_data[index].used != 0) {\n        u32_t tmp_seq = fec_data[index].seq;\n        anti_replay.set_invaild(tmp_seq);\n\n        auto tmp_it = mp.find(tmp_seq);\n        if (tmp_it != mp.end()) {\n            int x = tmp_it->second.data_num;\n            int y = tmp_it->second.redundant_num;\n            int cnt = tmp_it->second.group_mp.size();\n\n            if (cnt < x) {\n                if (debug_fec_dec)\n                    mylog(log_debug, \"[dec][failed]seq=%08x x=%d y=%d cnt=%d\\n\", tmp_seq, x, y, cnt);\n                else\n                    mylog(log_trace, \"[dec][failed]seq=%08x x=%d y=%d cnt=%d\\n\", tmp_seq, x, y, cnt);\n            }\n            mp.erase(tmp_it);\n        }\n        if (tmp_seq == seq) {\n            mylog(log_warn, \"unexpected tmp_seq==seq ,seq=%d\\n\", seq);\n            return -1;\n        }\n    }\n\n    fec_data[index].used = 1;\n    fec_data[index].seq = seq;\n    fec_data[index].type = type;\n    fec_data[index].data_num = data_num;\n    fec_data[index].redundant_num = redundant_num;\n    fec_data[index].idx = inner_index;\n    fec_data[index].len = len;\n    assert(0 <= index && index < (int)fec_buff_num);\n    assert(len + 100 < buf_len);\n    memcpy(fec_data[index].buf, s + tmp_idx, len);\n    mp[seq].group_mp[inner_index] = index;\n    // index++ at end of function\n\n    map<int, int> &inner_mp = mp[seq].group_mp;\n\n    int about_to_fec = 0;\n    if (type == 0) {\n        // assert((int)inner_mp.size()<=data_num);\n        if ((int)inner_mp.size() > data_num) {\n            mylog(log_warn, \"inner_mp.size()>data_num\\n\");\n            anti_replay.set_invaild(seq);\n            goto end;\n        }\n        if ((int)inner_mp.size() == data_num)\n            about_to_fec = 1;\n    } else {\n        if (mp[seq].data_num != -1) {\n            if ((int)inner_mp.size() > mp[seq].data_num + 1) {\n                mylog(log_warn, \"inner_mp.size()>data_num+1\\n\");\n                anti_replay.set_invaild(seq);\n                goto end;\n            }\n            if ((int)inner_mp.size() >= mp[seq].data_num) {\n                about_to_fec = 1;\n            }\n        }\n    }\n\n    if (about_to_fec) {\n        int group_data_num = mp[seq].data_num;\n        int group_redundant_num = mp[seq].redundant_num;\n\n        int x_got = 0;\n        int y_got = 0;\n        // mylog(log_error,\"fec here!\\n\");\n        if (type == 0) {\n            char *fec_tmp_arr[max_fec_packet_num + 5] = {0};\n            for (auto it = inner_mp.begin(); it != inner_mp.end(); it++) {\n                if (it->first < group_data_num)\n                    x_got++;\n                else\n                    y_got++;\n                fec_tmp_arr[it->first] = fec_data[it->second].buf;\n            }\n            assert(rs_decode2(group_data_num, group_data_num + group_redundant_num, fec_tmp_arr, len) == 0);  // the input data has been modified in-place\n            // this line should always succeed\n            mp[seq].fec_done = 1;\n\n            if (debug_fec_dec)\n                mylog(log_debug, \"[dec]seq=%08x x=%d y=%d len=%d cnt=%d X=%d Y=%d\\n\", seq, group_data_num, group_redundant_num, len, int(inner_mp.size()), x_got, y_got);\n            else\n                mylog(log_trace, \"[dec]seq=%08x x=%d y=%d len=%d cnt=%d X=%d Y=%d\\n\", seq, group_data_num, group_redundant_num, len, int(inner_mp.size()), x_got, y_got);\n\n            blob_decode.clear();\n            for (int i = 0; i < group_data_num; i++) {\n                blob_decode.input(fec_tmp_arr[i], len);\n            }\n            if (blob_decode.output(output_n, output_s_arr, output_len_arr) != 0) {\n                mylog(log_warn, \"blob_decode failed\\n\");\n                // ready_for_output=0;\n                anti_replay.set_invaild(seq);\n                goto end;\n            }\n            assert(ready_for_output == 0);\n            ready_for_output = 1;\n            anti_replay.set_invaild(seq);\n        } else  // type==1\n        {\n            int max_len = -1;\n            int fec_result_ok = 1;\n            int data_check_ok = 1;\n            int debug_num = inner_mp.size();\n\n            int missed_packet[max_fec_packet_num + 5];\n            int missed_packet_counter = 0;\n\n            // outupt_s_arr_buf[max_fec_packet_num+5]={0};\n\n            // memset(output_s_arr_buf,0,sizeof(output_s_arr_buf));//in efficient\n\n            for (int i = 0; i < group_data_num + group_redundant_num; i++) {\n                output_s_arr_buf[i] = 0;\n            }\n            for (auto it = inner_mp.begin(); it != inner_mp.end(); it++) {\n                if (it->first < group_data_num)\n                    x_got++;\n                else\n                    y_got++;\n\n                output_s_arr_buf[it->first] = fec_data[it->second].buf;\n                if (fec_data[it->second].len < (int)sizeof(u16_t)) {\n                    mylog(log_warn, \"fec_data[it->second].len<(int)sizeof(u16_t)\");\n                    data_check_ok = 0;\n                }\n\n                if (fec_data[it->second].len > max_len)\n                    max_len = fec_data[it->second].len;\n            }\n            if (max_len != mp[seq].len) {\n                data_check_ok = 0;\n                mylog(log_warn, \"max_len!=mp[seq].len\");\n            }\n            if (data_check_ok == 0) {\n                // ready_for_output=0;\n                mylog(log_warn, \"data_check_ok==0\\n\");\n                anti_replay.set_invaild(seq);\n                goto end;\n            }\n            for (auto it = inner_mp.begin(); it != inner_mp.end(); it++) {\n                int tmp_idx = it->second;\n                assert(max_len >= fec_data[tmp_idx].len);  // guarenteed by data_check_ok\n                memset(fec_data[tmp_idx].buf + fec_data[tmp_idx].len, 0, max_len - fec_data[tmp_idx].len);\n            }\n\n            for (int i = 0; i < group_data_num; i++) {\n                if (output_s_arr_buf[i] == 0 || i == inner_index)  // only missed packet +current packet\n                {\n                    missed_packet[missed_packet_counter++] = i;\n                }\n            }\n            mylog(log_trace, \"fec done,%d %d,missed_packet_counter=%d\\n\", group_data_num, group_redundant_num, missed_packet_counter);\n\n            assert(rs_decode2(group_data_num, group_data_num + group_redundant_num, output_s_arr_buf, max_len) == 0);  // this should always succeed\n            mp[seq].fec_done = 1;\n\n            int sum_ori = 0;\n\n            for (int i = 0; i < group_data_num; i++) {\n                output_len_arr_buf[i] = read_u16(output_s_arr_buf[i]);\n                sum_ori += output_len_arr_buf[i];\n                output_s_arr_buf[i] += sizeof(u16_t);\n                if (output_len_arr_buf[i] > max_data_len) {\n                    mylog(log_warn, \"invaild len %d,seq= %u,data_num= %d r_num= %d,i= %d\\n\", output_len_arr_buf[i], seq, group_data_num, group_redundant_num, i);\n                    fec_result_ok = 0;\n                    for (int i = 0; i < missed_packet_counter; i++) {\n                        log_bare(log_warn, \"%d \", missed_packet[i]);\n                    }\n                    log_bare(log_warn, \"\\n\");\n                    // break;\n                }\n            }\n\n            int sum = max_len * group_data_num;\n\n            if (debug_fec_dec)\n                mylog(log_debug, \"[dec]seq=%08x x=%d y=%d len=%d sum_ori=%d sum=%d X=%d Y=%d\\n\", seq, group_data_num, group_redundant_num, max_len, sum_ori, sum, x_got, y_got);\n            else\n                mylog(log_trace, \"[dec]seq=%08x x=%d y=%d len=%d sum_ori=%d sum=%d X=%d Y=%d\\n\", seq, group_data_num, group_redundant_num, max_len, sum_ori, sum, x_got, y_got);\n\n            if (fec_result_ok) {\n                output_n = group_data_num;\n\n                if (decode_fast_send) {\n                    output_n = missed_packet_counter;\n                    for (int i = 0; i < missed_packet_counter; i++) {\n                        output_s_arr_buf[i] = output_s_arr_buf[missed_packet[i]];\n                        output_len_arr_buf[i] = output_len_arr_buf[missed_packet[i]];\n                    }\n                }\n\n                output_s_arr = output_s_arr_buf;\n                output_len_arr = output_len_arr_buf;\n                assert(ready_for_output == 0);\n                ready_for_output = 1;\n            } else {\n                // fec_not_ok:\n                ready_for_output = 0;\n            }\n            anti_replay.set_invaild(seq);\n        }   // end of type==1\n    } else  // not about_to_fec\n    {\n        if (decode_fast_send) {\n            if (type == 1 && data_num == 0) {\n                assert(ready_for_output == 0);\n                output_n = 1;\n                int check_len = read_u16(fec_data[index].buf);\n                output_s_arr_buf[0] = fec_data[index].buf + sizeof(u16_t);\n                output_len_arr_buf[0] = fec_data[index].len - sizeof(u16_t);\n\n                if (output_len_arr_buf[0] != check_len) {\n                    mylog(log_warn, \"len mismatch %d %d\\n\", output_len_arr_buf[0], check_len);\n                }\n                output_s_arr = output_s_arr_buf;\n                output_len_arr = output_len_arr_buf;\n\n                ready_for_output = 1;\n            }\n        }\n    }\n\nend:\n    index++;\n    if (index == int(fec_buff_num)) index = 0;\n\n    return 0;\n}\nint fec_decode_manager_t::output(int &n, char **&s_arr, int *&len_arr) {\n    if (!ready_for_output) {\n        n = -1;\n        s_arr = 0;\n        len_arr = 0;\n    } else {\n        ready_for_output = 0;\n        n = output_n;\n        s_arr = output_s_arr;\n        len_arr = output_len_arr;\n    }\n    return 0;\n}\n"
        },
        {
          "name": "fec_manager.h",
          "type": "blob",
          "size": 11.9580078125,
          "content": "/*\n * fec_manager.h\n *\n *  Created on: Sep 27, 2017\n *      Author: root\n */\n\n#ifndef FEC_MANAGER_H_\n#define FEC_MANAGER_H_\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"lib/rs.h\"\n\nconst int max_blob_packet_num = 30000;      // how many packet can be contain in a blob_t ,can be set very large\nconst u32_t anti_replay_buff_size = 30000;  // can be set very large\n\nconst int max_fec_packet_num = 255;  // this is the limitation of the rs lib\nextern u32_t fec_buff_num;\n\nconst int rs_str_len = max_fec_packet_num * 10 + 100;\nextern int header_overhead;\nextern int debug_fec_enc;\nextern int debug_fec_dec;\n\nstruct fec_parameter_t {\n    int version = 0;\n    int mtu = default_mtu;\n    int queue_len = 200;\n    int timeout = 8 * 1000;\n    int mode = 0;\n\n    int rs_cnt = 0;\n    struct rs_parameter_t  // parameters for reed solomon\n    {\n        unsigned char x;  // AKA fec_data_num  (x should be same as <index of rs_par>+1 at the moment)\n        unsigned char y;  // fec_redundant_num\n    } rs_par[max_fec_packet_num + 10];\n\n    int rs_from_str(char *s)  // todo inefficient\n    {\n        vector<string> str_vec = string_to_vec(s, \",\");\n        if (str_vec.size() < 1) {\n            mylog(log_warn, \"failed to parse [%s]\\n\", s);\n            return -1;\n        }\n        vector<rs_parameter_t> par_vec;\n        for (int i = 0; i < (int)str_vec.size(); i++) {\n            rs_parameter_t tmp_par;\n            string &tmp_str = str_vec[i];\n            int x, y;\n            if (sscanf((char *)tmp_str.c_str(), \"%d:%d\", &x, &y) != 2) {\n                mylog(log_warn, \"failed to parse [%s]\\n\", tmp_str.c_str());\n                return -1;\n            }\n            if (x < 1 || y < 0 || x + y > max_fec_packet_num) {\n                mylog(log_warn, \"invaild value x=%d y=%d, x should >=1, y should >=0, x +y should <%d\\n\", x, y, max_fec_packet_num);\n                return -1;\n            }\n            tmp_par.x = x;\n            tmp_par.y = y;\n            par_vec.push_back(tmp_par);\n        }\n        assert(par_vec.size() == str_vec.size());\n\n        int found_problem = 0;\n        for (int i = 1; i < (int)par_vec.size(); i++) {\n            if (par_vec[i].x <= par_vec[i - 1].x) {\n                mylog(log_warn, \"error in [%s], x in x:y should be in ascend order\\n\", s);\n                return -1;\n            }\n            int now_x = par_vec[i].x;\n            int now_y = par_vec[i].y;\n            int pre_x = par_vec[i - 1].x;\n            int pre_y = par_vec[i - 1].y;\n\n            double now_ratio = double(par_vec[i].y) / par_vec[i].x;\n            double pre_ratio = double(par_vec[i - 1].y) / par_vec[i - 1].x;\n\n            if (pre_ratio + 0.0001 < now_ratio) {\n                if (found_problem == 0) {\n                    mylog(log_warn, \"possible problems: %d/%d<%d/%d\", pre_y, pre_x, now_y, now_x);\n                    found_problem = 1;\n                } else {\n                    log_bare(log_warn, \", %d/%d<%d/%d\", pre_y, pre_x, now_y, now_x);\n                }\n            }\n        }\n        if (found_problem) {\n            log_bare(log_warn, \" in %s\\n\", s);\n        }\n\n        {  // special treatment for first parameter\n            int x = par_vec[0].x;\n            int y = par_vec[0].y;\n            for (int i = 1; i <= x; i++) {\n                rs_par[i - 1].x = i;\n                rs_par[i - 1].y = y;\n            }\n        }\n\n        for (int i = 1; i < (int)par_vec.size(); i++) {\n            int now_x = par_vec[i].x;\n            int now_y = par_vec[i].y;\n            int pre_x = par_vec[i - 1].x;\n            int pre_y = par_vec[i - 1].y;\n            rs_par[now_x - 1].x = now_x;\n            rs_par[now_x - 1].y = now_y;\n\n            double now_ratio = double(par_vec[i].y) / par_vec[i].x;\n            double pre_ratio = double(par_vec[i - 1].y) / par_vec[i - 1].x;\n\n            // double k= double(now_y-pre_y)/double(now_x-pre_x);\n            for (int j = pre_x + 1; j <= now_x - 1; j++) {\n                int in_x = j;\n\n                ////////\tint in_y= double(pre_y) + double(in_x-pre_x)*k+ 0.9999;// round to upper\n\n                double distance = now_x - pre_x;\n                ///////\tdouble in_ratio=pre_ratio*(1.0-(in_x-pre_x)/distance)   +   now_ratio *(1.0- (now_x-in_x)/distance);\n                //////\tint in_y= in_x*in_ratio + 0.9999;\n                int in_y = pre_y + (now_y - pre_y) * (in_x - pre_x) / distance + 0.9999;\n\n                if (in_x + in_y > max_fec_packet_num) {\n                    in_y = max_fec_packet_num - in_x;\n                    assert(in_y >= 0 && in_y <= max_fec_packet_num);\n                }\n\n                rs_par[in_x - 1].x = in_x;\n                rs_par[in_x - 1].y = in_y;\n            }\n        }\n        rs_cnt = par_vec[par_vec.size() - 1].x;\n\n        return 0;\n    }\n\n    char *rs_to_str()  // todo inefficient\n    {\n        static char res[rs_str_len];\n        string tmp_string;\n        char tmp_buf[100];\n        assert(rs_cnt >= 1);\n        for (int i = 0; i < rs_cnt; i++) {\n            sprintf(tmp_buf, \"%d:%d\", int(rs_par[i].x), int(rs_par[i].y));\n            if (i != 0)\n                tmp_string += \",\";\n            tmp_string += tmp_buf;\n        }\n        strcpy(res, tmp_string.c_str());\n        return res;\n    }\n\n    rs_parameter_t get_tail() {\n        assert(rs_cnt >= 1);\n        return rs_par[rs_cnt - 1];\n    }\n\n    int clone(fec_parameter_t &other) {\n        version = other.version;\n        mtu = other.mtu;\n        queue_len = other.queue_len;\n        timeout = other.timeout;\n        mode = other.mode;\n\n        assert(other.rs_cnt >= 1);\n        rs_cnt = other.rs_cnt;\n        memcpy(rs_par, other.rs_par, sizeof(rs_parameter_t) * rs_cnt);\n\n        return 0;\n    }\n\n    int copy_fec(fec_parameter_t &other) {\n        assert(other.rs_cnt >= 1);\n        rs_cnt = other.rs_cnt;\n        memcpy(rs_par, other.rs_par, sizeof(rs_parameter_t) * rs_cnt);\n\n        return 0;\n    }\n};\n\nextern fec_parameter_t g_fec_par;\n// extern int dynamic_update_fec;\n\nconst int anti_replay_timeout = 120 * 1000;  // 120s\n\nstruct anti_replay_t {\n    struct info_t {\n        my_time_t my_time;\n        int index;\n    };\n\n    u64_t replay_buffer[anti_replay_buff_size];\n    unordered_map<u32_t, info_t> mp;\n    int index;\n    anti_replay_t() {\n        clear();\n    }\n    int clear() {\n        memset(replay_buffer, -1, sizeof(replay_buffer));\n        mp.clear();\n        mp.rehash(anti_replay_buff_size * 3);\n        index = 0;\n        return 0;\n    }\n    void set_invaild(u32_t seq) {\n        if (is_vaild(seq) == 0) {\n            mylog(log_trace, \"seq %u exist\\n\", seq);\n            // assert(mp.find(seq)!=mp.end());\n            // mp[seq].my_time=get_current_time_rough();\n            return;\n        }\n        if (replay_buffer[index] != u64_t(i64_t(-1))) {\n            assert(mp.find(replay_buffer[index]) != mp.end());\n            mp.erase(replay_buffer[index]);\n        }\n        replay_buffer[index] = seq;\n        assert(mp.find(seq) == mp.end());\n        mp[seq].my_time = get_current_time();\n        mp[seq].index = index;\n        index++;\n        if (index == int(anti_replay_buff_size)) index = 0;\n    }\n    int is_vaild(u32_t seq) {\n        if (mp.find(seq) == mp.end()) return 1;\n\n        if (get_current_time() - mp[seq].my_time > anti_replay_timeout) {\n            replay_buffer[mp[seq].index] = u64_t(i64_t(-1));\n            mp.erase(seq);\n            return 1;\n        }\n\n        return 0;\n    }\n};\n\nstruct blob_encode_t {\n    char input_buf[(max_fec_packet_num + 5) * buf_len];\n    int current_len;\n    int counter;\n\n    char *output_buf[max_fec_packet_num + 100];\n\n    blob_encode_t();\n\n    int clear();\n\n    int get_num();\n    int get_shard_len(int n);\n    int get_shard_len(int n, int next_packet_len);\n\n    int input(char *s, int len);  // len=use len=0 for second and following packet\n    int output(int n, char **&s_arr, int &len);\n};\n\nstruct blob_decode_t {\n    char input_buf[(max_fec_packet_num + 5) * buf_len];\n    int current_len;\n    int last_len;\n    int counter;\n\n    char *output_buf[max_blob_packet_num + 100];\n    int output_len[max_blob_packet_num + 100];\n\n    blob_decode_t();\n    int clear();\n    int input(char *input, int len);\n    int output(int &n, char **&output, int *&len_arr);\n};\n\nclass fec_encode_manager_t : not_copy_able_t {\n   private:\n    u32_t seq;\n\n    // int fec_mode;\n    // int fec_data_num,fec_redundant_num;\n    // int fec_mtu;\n    // int fec_queue_len;\n    // int fec_timeout;\n    fec_parameter_t fec_par;\n\n    my_time_t first_packet_time;\n    my_time_t first_packet_time_for_output;\n\n    blob_encode_t blob_encode;\n    char input_buf[max_fec_packet_num + 5][buf_len];\n    int input_len[max_fec_packet_num + 100];\n\n    char *output_buf[max_fec_packet_num + 100];\n    int output_len[max_fec_packet_num + 100];\n\n    int counter;\n    // int timer_fd;\n    // u64_t timer_fd64;\n\n    int ready_for_output;\n    u32_t output_n;\n\n    int append(char *s, int len);\n\n    ev_timer timer;\n    struct ev_loop *loop = 0;\n    void (*cb)(struct ev_loop *loop, struct ev_timer *watcher, int revents) = 0;\n\n   public:\n    fec_encode_manager_t();\n    ~fec_encode_manager_t();\n\n    fec_parameter_t &get_fec_par() {\n        return fec_par;\n    }\n    void set_data(void *data) {\n        timer.data = data;\n    }\n\n    void set_loop_and_cb(struct ev_loop *loop, void (*cb)(struct ev_loop *loop, struct ev_timer *watcher, int revents)) {\n        this->loop = loop;\n        this->cb = cb;\n        ev_init(&timer, cb);\n    }\n\n    int clear_data() {\n        counter = 0;\n        blob_encode.clear();\n        ready_for_output = 0;\n\n        seq = (u32_t)get_fake_random_number();  // TODO temp solution for a bug.\n\n        if (loop) {\n            ev_timer_stop(loop, &timer);\n        }\n        return 0;\n    }\n    int clear_all() {\n        // itimerspec zero_its;\n        // memset(&zero_its, 0, sizeof(zero_its));\n        // timerfd_settime(timer_fd, TFD_TIMER_ABSTIME, &zero_its, 0);\n\n        if (loop) {\n            ev_timer_stop(loop, &timer);\n            loop = 0;\n            cb = 0;\n        }\n\n        clear_data();\n\n        return 0;\n    }\n\n    my_time_t get_first_packet_time() {\n        return first_packet_time_for_output;\n    }\n\n    int get_pending_time() {\n        return fec_par.timeout;\n    }\n\n    int get_type() {\n        return fec_par.mode;\n    }\n    // u64_t get_timer_fd64();\n    int reset_fec_parameter(int data_num, int redundant_num, int mtu, int pending_num, int pending_time, int type);\n    int input(char *s, int len /*,int &is_first_packet*/);\n    int output(int &n, char **&s_arr, int *&len);\n};\nstruct fec_data_t {\n    int used;\n    u32_t seq;\n    int type;\n    int data_num;\n    int redundant_num;\n    int idx;\n    char buf[buf_len];\n    int len;\n};\nstruct fec_group_t {\n    int type = -1;\n    int data_num = -1;\n    int redundant_num = -1;\n    int len = -1;\n    int fec_done = 0;\n    // int data_counter=0;\n    map<int, int> group_mp;\n};\nclass fec_decode_manager_t : not_copy_able_t {\n    anti_replay_t anti_replay;\n    fec_data_t *fec_data = 0;\n    unordered_map<u32_t, fec_group_t> mp;\n    blob_decode_t blob_decode;\n\n    int index;\n\n    int output_n;\n    char **output_s_arr;\n    int *output_len_arr;\n    int ready_for_output;\n\n    char *output_s_arr_buf[max_fec_packet_num + 100];  // only for type=1,for type=0 the buf inside blot_t is used\n    int output_len_arr_buf[max_fec_packet_num + 100];  // same\n\n   public:\n    fec_decode_manager_t() {\n        fec_data = new fec_data_t[fec_buff_num + 5];\n        assert(fec_data != 0);\n        clear();\n    }\n    /*\n    fec_decode_manager_t(const fec_decode_manager_t &b)\n    {\n            assert(0==1);//not allowed to copy\n    }*/\n    ~fec_decode_manager_t() {\n        mylog(log_debug, \"fec_decode_manager destroyed\\n\");\n        if (fec_data != 0) {\n            mylog(log_debug, \"fec_data freed\\n\");\n            delete[] fec_data;\n        }\n    }\n    int clear() {\n        anti_replay.clear();\n        mp.clear();\n        mp.rehash(fec_buff_num * 3);\n\n        for (int i = 0; i < (int)fec_buff_num; i++)\n            fec_data[i].used = 0;\n        ready_for_output = 0;\n        index = 0;\n\n        return 0;\n    }\n\n    // int re_init();\n    int input(char *s, int len);\n    int output(int &n, char **&s_arr, int *&len_arr);\n};\n\n#endif /* FEC_MANAGER_H_ */\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libev",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.cpp",
          "type": "blob",
          "size": 1.3427734375,
          "content": "#include <common.h>\n#include <log.h>\n\nint log_level = log_info;\n\nint enable_log_position = 0;\nint enable_log_color = 1;\n\nvoid log0(const char* file, const char* function, int line, int level, const char* str, ...) {\n    if (level > log_level) return;\n    if (level > log_trace || level < 0) return;\n\n    time_t timer;\n    char buffer[100];\n    struct tm* tm_info;\n\n    time(&timer);\n    tm_info = localtime(&timer);\n\n    if (enable_log_color)\n        printf(\"%s\", log_color[level]);\n\n    strftime(buffer, 100, \"%Y-%m-%d %H:%M:%S\", tm_info);\n    printf(\"[%s][%s]\", buffer, log_text[level]);\n\n    if (enable_log_position) printf(\"[%s,func:%s,line:%d]\", file, function, line);\n\n    va_list vlist;\n    va_start(vlist, str);\n    vfprintf(stdout, str, vlist);\n    va_end(vlist);\n    if (enable_log_color)\n        printf(\"%s\", RESET);\n\n    // printf(\"\\n\");\n    // if(enable_log_color)\n    // printf(log_color[level]);\n    fflush(stdout);\n\n    if (log_level == log_fatal) {\n        about_to_exit = 1;\n    }\n}\n\nvoid log_bare(int level, const char* str, ...) {\n    if (level > log_level) return;\n    if (level > log_trace || level < 0) return;\n    if (enable_log_color)\n        printf(\"%s\", log_color[level]);\n    va_list vlist;\n    va_start(vlist, str);\n    vfprintf(stdout, str, vlist);\n    va_end(vlist);\n    if (enable_log_color)\n        printf(\"%s\", RESET);\n    fflush(stdout);\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 1.1953125,
          "content": "\n#ifndef _LOG_MYLOG_H_\n#define _LOG_MYLOG_H_\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <getopt.h>\n#include <unistd.h>\n#include <errno.h>\n#include <time.h>\n\n#include <set>\n\nusing namespace std;\n\n#define RED \"\\x1B[31m\"\n#define GRN \"\\x1B[32m\"\n#define YEL \"\\x1B[33m\"\n#define BLU \"\\x1B[34m\"\n#define MAG \"\\x1B[35m\"\n#define CYN \"\\x1B[36m\"\n#define WHT \"\\x1B[37m\"\n#define RESET \"\\x1B[0m\"\n\nconst int log_never = 0;\nconst int log_fatal = 1;\nconst int log_error = 2;\nconst int log_warn = 3;\nconst int log_info = 4;\nconst int log_debug = 5;\nconst int log_trace = 6;\nconst int log_end = 7;\n\nconst char log_text[][20] = {\"NEVER\", \"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\", \"TRACE\", \"\"};\nconst char log_color[][20] = {RED, RED, RED, YEL, GRN, MAG, \"\"};\n\nextern int log_level;\nextern int enable_log_position;\nextern int enable_log_color;\n\n#ifdef MY_DEBUG\n#define mylog(__first_argu__dummy_abcde__, ...) printf(__VA_ARGS__)\n\n#else\n#define mylog(...) log0(__FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)\n#endif\n\n//#define mylog(__first_argu__dummy_abcde__,...) {;}\n\nvoid log0(const char* file, const char* function, int line, int level, const char* str, ...);\n\nvoid log_bare(int level, const char* str, ...);\n\n#endif\n"
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 7.443359375,
          "content": "#include \"common.h\"\n#include \"log.h\"\n\n#include \"lib/rs.h\"\n#include \"packet.h\"\n#include \"connection.h\"\n#include \"fd_manager.h\"\n#include \"delay_manager.h\"\n#include \"fec_manager.h\"\n#include \"misc.h\"\n#include \"tunnel.h\"\n//#include \"tun_dev.h\"\n#include \"git_version.h\"\nusing namespace std;\n\nstatic void print_help() {\n    char git_version_buf[100] = {0};\n    strncpy(git_version_buf, gitversion, 10);\n\n    printf(\"UDPspeeder V2\\n\");\n    printf(\"git version: %s    \", git_version_buf);\n    printf(\"build date: %s %s\\n\", __DATE__, __TIME__);\n    printf(\"repository: https://github.com/wangyu-/UDPspeeder\\n\");\n    printf(\"\\n\");\n    printf(\"usage:\\n\");\n    printf(\"    run as client: ./this_program -c -l local_listen_ip:local_port -r server_ip:server_port  [options]\\n\");\n    printf(\"    run as server: ./this_program -s -l server_listen_ip:server_port -r remote_ip:remote_port  [options]\\n\");\n    printf(\"\\n\");\n    printf(\"common options, must be same on both sides:\\n\");\n    printf(\"    -k,--key              <string>        key for simple xor encryption. if not set, xor is disabled\\n\");\n\n    printf(\"main options:\\n\");\n    printf(\"    -f,--fec              x:y             forward error correction, send y redundant packets for every x packets\\n\");\n    printf(\"    --timeout             <number>        how long could a packet be held in queue before doing fec, unit: ms, default: 8ms\\n\");\n    printf(\"    --report              <number>        turn on send/recv report, and set a period for reporting, unit: s\\n\");\n\n    printf(\"advanced options:\\n\");\n    printf(\"    --mode                <number>        fec-mode,available values: 0,1; mode 0(default) costs less bandwidth,no mtu problem.\\n\");\n    printf(\"                                          mode 1 usually introduces less latency, but you have to care about mtu.\\n\");\n    printf(\"    --mtu                 <number>        mtu. for mode 0, the program will split packet to segment smaller than mtu value.\\n\");\n    printf(\"                                          for mode 1, no packet will be split, the program just check if the mtu is exceed.\\n\");\n    printf(\"                                          default value: 1250. you typically shouldnt change this value.\\n\");\n    printf(\"    -j,--jitter           <number>        simulated jitter. randomly delay first packet for 0~<number> ms, default value: 0.\\n\");\n    printf(\"                                          do not use if you dont know what it means.\\n\");\n    printf(\"    -i,--interval         <number>        scatter each fec group to a interval of <number> ms, to defend burst packet loss.\\n\");\n    printf(\"                                          default value: 0. do not use if you dont know what it means.\\n\");\n    printf(\"    -f,--fec              x1:y1,x2:y2,..  similiar to -f/--fec above,fine-grained fec parameters,may help save bandwidth.\\n\");\n    printf(\"                                          example: \\\"-f 1:3,2:4,10:6,20:10\\\". check repo for details\\n\");\n    printf(\"    --random-drop         <number>        simulate packet loss, unit: 0.01%%. default value: 0.\\n\");\n    printf(\"    --disable-obscure     <number>        disable obscure, to save a bit bandwidth and cpu\\n\");\n    printf(\"    --disable-checksum    <number>        disable checksum to save a bit bandwdith and cpu\\n\");\n    // printf(\"    --disable-xor         <number>        disable xor\\n\");\n\n    printf(\"developer options:\\n\");\n    printf(\"    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program, so that you\\n\");\n    printf(\"                                          can change fec encode parameters dynamically, check readme.md in repository for\\n\");\n    printf(\"                                          supported commands.\\n\");\n    printf(\"    -j ,--jitter          jmin:jmax       similiar to -j above, but create jitter randomly between jmin and jmax\\n\");\n    printf(\"    -i,--interval         imin:imax       similiar to -i above, but scatter randomly between imin and imax\\n\");\n    printf(\"    -q,--queue-len        <number>        fec queue len, only for mode 0, fec will be performed immediately after queue is full.\\n\");\n    printf(\"                                          default value: 200. \\n\");\n    printf(\"    --decode-buf          <number>        size of buffer of fec decoder,unit: packet, default: 2000\\n\");\n    //    printf(\"    --fix-latency         <number>        try to stabilize latency, only for mode 0\\n\");\n    printf(\"    --delay-capacity      <number>        max number of delayed packets, 0 means unlimited, default: 0\\n\");\n    printf(\"    --disable-fec         <number>        completely disable fec, turn the program into a normal udp tunnel\\n\");\n    printf(\"    --sock-buf            <number>        buf size for socket, >=10 and <=10240, unit: kbyte, default: 1024\\n\");\n    printf(\"    --out-addr            ip:port         force all output packets of '-r' end to go through this address, port 0 for random port.\\n\");\n#ifdef __linux__\n    printf(\"    --out-interface       <string>        force all output packets of '-r' end to go through this interface.\\n\");\n#endif\n    printf(\"log and help options:\\n\");\n    printf(\"    --log-level           <number>        0: never    1: fatal   2: error   3: warn \\n\");\n    printf(\"                                          4: info (default)      5: debug   6: trace\\n\");\n    printf(\"    --log-position                        enable file name, function name, line number in log\\n\");\n    printf(\"    --disable-color                       disable log color\\n\");\n    printf(\"    -h,--help                             print this help message\\n\");\n\n    // printf(\"common options,these options must be same on both side\\n\");\n}\n\nvoid sigpipe_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigpipe, ignored\");\n}\n\nvoid sigterm_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigterm, exit\");\n    myexit(0);\n}\n\nvoid sigint_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigint, exit\");\n    myexit(0);\n}\n\nint main(int argc, char *argv[]) {\n    working_mode = tunnel_mode;\n    init_ws();\n    // unit_test();\n\n    struct ev_loop *loop = ev_default_loop(0);\n#if !defined(__MINGW32__)\n    ev_signal signal_watcher_sigpipe;\n    ev_signal_init(&signal_watcher_sigpipe, sigpipe_cb, SIGPIPE);\n    ev_signal_start(loop, &signal_watcher_sigpipe);\n#else\n    enable_log_color = 0;\n#endif\n\n    ev_signal signal_watcher_sigterm;\n    ev_signal_init(&signal_watcher_sigterm, sigterm_cb, SIGTERM);\n    ev_signal_start(loop, &signal_watcher_sigterm);\n\n    ev_signal signal_watcher_sigint;\n    ev_signal_init(&signal_watcher_sigint, sigint_cb, SIGINT);\n    ev_signal_start(loop, &signal_watcher_sigint);\n\n    assert(sizeof(u64_t) == 8);\n    assert(sizeof(i64_t) == 8);\n    assert(sizeof(u32_t) == 4);\n    assert(sizeof(i32_t) == 4);\n    assert(sizeof(u16_t) == 2);\n    assert(sizeof(i16_t) == 2);\n    dup2(1, 2);  // redirect stderr to stdout\n    int i, j, k;\n\n    if (argc == 1) {\n        print_help();\n        myexit(-1);\n    }\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n            print_help();\n            myexit(0);\n        }\n    }\n\n    process_arg(argc, argv);\n\n    delay_manager.set_capacity(delay_capacity);\n\n    if (strlen(tun_dev) == 0) {\n        sprintf(tun_dev, \"tun%u\", get_fake_random_number() % 1000);\n    }\n\n    if (program_mode == client_mode) {\n        tunnel_client_event_loop();\n    } else {\n        tunnel_server_event_loop();\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 5.064453125,
          "content": "cc_cross=/home/wangyu/Desktop/arm-2014.05/bin/arm-none-linux-gnueabi-g++\ncc_local=g++\ncc_mips24kc_be=/toolchains/lede-sdk-17.01.2-ar71xx-generic_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mips_24kc_gcc-5.4.0_musl-1.1.16/bin/mips-openwrt-linux-musl-g++\ncc_mips24kc_le=/toolchains/lede-sdk-17.01.2-ramips-mt7621_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.16/bin/mipsel-openwrt-linux-musl-g++\ncc_arm= /toolchains/lede-sdk-17.01.2-bcm53xx_gcc-5.4.0_musl-1.1.16_eabi.Linux-x86_64/staging_dir/toolchain-arm_cortex-a9_gcc-5.4.0_musl-1.1.16_eabi/bin/arm-openwrt-linux-c++\ncc_mingw_cross=i686-w64-mingw32-g++-posix\ncc_mac_cross=o64-clang++ -stdlib=libc++\ncc_x86=/toolchains/lede-sdk-17.01.2-x86-generic_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-i386_pentium4_gcc-5.4.0_musl-1.1.16/bin/i486-openwrt-linux-c++\ncc_amd64=/toolchains/lede-sdk-17.01.2-x86-64_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-x86_64_gcc-5.4.0_musl-1.1.16/bin/x86_64-openwrt-linux-c++\n#cc_bcm2708=/home/wangyu/raspberry/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++ \n\n\nSOURCES0=main.cpp log.cpp common.cpp lib/fec.cpp lib/rs.cpp packet.cpp delay_manager.cpp fd_manager.cpp connection.cpp fec_manager.cpp misc.cpp tunnel_client.cpp tunnel_server.cpp\nSOURCES=${SOURCES0} my_ev.cpp -isystem libev \nNAME=speederv2\n\n\nFLAGS= -std=c++11   -Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers ${OPT}\n\nTARGETS=amd64 arm mips24kc_be x86  mips24kc_le\n\nTAR=${NAME}_binaries.tar.gz `echo ${TARGETS}|sed -r 's/([^ ]+)/${NAME}_\\1/g'` version.txt\n\nexport STAGING_DIR=/tmp/    #just for supress warning of staging_dir not define\n\n# targets for nativei (non-cross) compile \nall:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb -static -O2\n\nfreebsd:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb -static -O2\n\nmingw:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS}  -ggdb -static -O2 -lws2_32\n\nmingw_wepoll:git_version    #to compile you need a pacthed version of libev with wepoll backend\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES0} ${FLAGS}  -ggdb -static -O2   -DNO_LIBEV_EMBED -D_WIN32 -lev -lws2_32 \n\nmac:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS}  -ggdb -O2\n\ncygwin:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb -static -O2 -D_GNU_SOURCE\n\n#targes for general cross compile\n\ncross:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -O2\n\ncross2:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -lgcc_eh -O2\n\ncross3:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -O2\n\n#targets only for debug purpose\nfast: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb\ndebug: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -D MY_DEBUG -ggdb\ndebug2: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -ggdb\n\n#targets only for 'make release'\n\nmips24kc_be: git_version\n\t${cc_mips24kc_be}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O2\n\nmips24kc_le: git_version\n\t${cc_mips24kc_le}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O2\n\namd64:git_version\n\t${cc_amd64}   -o ${NAME}_$@    -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh -ggdb\n\nx86:git_version          #to build this you need 'g++-multilib' installed \n\t${cc_x86}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh -ggdb\narm:git_version\n\t${cc_arm}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh\n\n\nrelease: ${TARGETS}\n\tcp git_version.h version.txt\n\ttar -zcvf ${TAR}\n\n#targets for cross compile windows targets on linux \n\nmingw_cross:git_version   #to build this and the below one you need 'mingw-w64' installed (the cross compile version on linux)\n\t${cc_mingw_cross}   -o ${NAME}.exe          -I. ${SOURCES} ${FLAGS}  -ggdb -static -O2 -lws2_32\n\nmingw_cross_wepoll:git_version    #to compile you need a pacthed version of libev with wepoll backend installed\n\t${cc_mingw_cross}   -o ${NAME}_wepoll.exe       -I. ${SOURCES0} ${FLAGS}  -ggdb -static -O2   -DNO_LIBEV_EMBED -D_WIN32 -lev -lws2_32\n\n#targets for cross compile macos targets on linux \n\nmac_cross:git_version   #need to install 'osxcross' first.\n\t${cc_mac_cross}   -o ${NAME}_mac          -I. ${SOURCES} ${FLAGS}  -ggdb -O2\n\n#release2 includes all binary in 'release' plus win and mac cross compile targets\n\nrelease2: ${TARGETS} mingw_cross mingw_cross_wepoll mac_cross\n\tcp git_version.h version.txt\n\ttar -zcvf ${TAR} ${NAME}.exe ${NAME}_wepoll.exe ${NAME}_mac\n\nclean:\t\n\trm -f ${TAR}\n\trm -f ${NAME} ${NAME}_cross ${NAME}.exe ${NAME}_wepoll.exe ${NAME}_mac\n\trm -f git_version.h\n\ngit_version:\n\t    echo \"const char *gitversion = \\\"$(shell git rev-parse HEAD)\\\";\" > git_version.h\n"
        },
        {
          "name": "misc.cpp",
          "type": "blob",
          "size": 31.1826171875,
          "content": "/*\n * misc.cpp\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#include \"misc.h\"\n\nchar fifo_file[1000] = \"\";\n\nint mtu_warn = 1350;\n\nint disable_mtu_warn = 1;\nint disable_fec = 0;\nint disable_checksum = 0;\n\nint debug_force_flush_fec = 0;\n\nint jitter_min = 0 * 1000;\nint jitter_max = 0 * 1000;\n\nint output_interval_min = 0 * 1000;\nint output_interval_max = 0 * 1000;\n\nint fix_latency = 0;\n\naddress_t local_addr, remote_addr;\naddress_t *out_addr = 0;\nchar *out_interface = 0;\n// u32_t local_ip_uint32,remote_ip_uint32=0;\n// char local_ip[100], remote_ip[100];\n// int local_port = -1, remote_port = -1;\n\nconn_manager_t conn_manager;\ndelay_manager_t delay_manager;\nfd_manager_t fd_manager;\n\nint time_mono_test = 0;\n\nint delay_capacity = 0;\n\nchar sub_net[100] = \"10.22.22.0\";\nu32_t sub_net_uint32 = 0;\n\nchar tun_dev[100] = \"\";\n\nint keep_reconnect = 0;\n\nint tun_mtu = 1500;\n\nint mssfix = default_mtu;\n\nint manual_set_tun = 0;\nint persist_tun = 0;\n\nchar rs_par_str[rs_str_len] = \"20:10\";\n\nint from_normal_to_fec(conn_info_t &conn_info, char *data, int len, int &out_n, char **&out_arr, int *&out_len, my_time_t *&out_delay) {\n    static my_time_t out_delay_buf[max_fec_packet_num + 100] = {0};\n    // static int out_len_buf[max_fec_packet_num+100]={0};\n    // static int counter=0;\n    out_delay = out_delay_buf;\n    // out_len=out_len_buf;\n    inner_stat_t &inner_stat = conn_info.stat.normal_to_fec;\n    if (disable_fec) {\n        if (data == 0) {\n            out_n = 0;\n            return 0;\n        }\n        // assert(data!=0);\n        inner_stat.input_packet_num++;\n        inner_stat.input_packet_size += len;\n        inner_stat.output_packet_num++;\n        inner_stat.output_packet_size += len;\n\n        out_n = 1;\n        static char *data_static;\n        data_static = data;\n        static int len_static;\n        len_static = len;\n        out_arr = &data_static;\n        out_len = &len_static;\n        out_delay[0] = 0;\n\n    } else {\n        if (data != 0) {\n            inner_stat.input_packet_num++;\n            inner_stat.input_packet_size += len;\n        }\n        // counter++;\n\n        conn_info.fec_encode_manager.input(data, len);\n\n        // if(counter%5==0)\n        // conn_info.fec_encode_manager.input(0,0);\n\n        // int n;\n        // char **s_arr;\n        // int s_len;\n\n        conn_info.fec_encode_manager.output(out_n, out_arr, out_len);\n\n        if (out_n > 0) {\n            my_time_t common_latency = 0;\n            my_time_t first_packet_time = conn_info.fec_encode_manager.get_first_packet_time();\n\n            if (fix_latency == 1 && conn_info.fec_encode_manager.get_type() == 0) {\n                my_time_t current_time = get_current_time_us();\n                my_time_t tmp;\n                assert(first_packet_time != 0);\n                // mylog(log_info,\"current_time=%llu first_packlet_time=%llu   fec_pending_time=%llu\\n\",current_time,first_packet_time,(my_time_t)fec_pending_time);\n                if ((my_time_t)conn_info.fec_encode_manager.get_pending_time() >= (current_time - first_packet_time)) {\n                    tmp = (my_time_t)conn_info.fec_encode_manager.get_pending_time() - (current_time - first_packet_time);\n                    // mylog(log_info,\"tmp=%llu\\n\",tmp);\n                } else {\n                    tmp = 0;\n                    // mylog(log_info,\"0\\n\");\n                }\n                common_latency += tmp;\n            }\n\n            common_latency += random_between(jitter_min, jitter_max);\n\n            out_delay_buf[0] = common_latency;\n\n            for (int i = 1; i < out_n; i++) {\n                out_delay_buf[i] = out_delay_buf[i - 1] + (my_time_t)(random_between(output_interval_min, output_interval_max) / (out_n - 1));\n            }\n        }\n\n        if (out_n > 0) {\n            log_bare(log_trace, \"seq= %u \", read_u32(out_arr[0]));\n        }\n        for (int i = 0; i < out_n; i++) {\n            inner_stat.output_packet_num++;\n            inner_stat.output_packet_size += out_len[i];\n\n            log_bare(log_trace, \"%d \", out_len[i]);\n        }\n\n        log_bare(log_trace, \"\\n\");\n    }\n\n    mylog(log_trace, \"from_normal_to_fec input_len=%d,output_n=%d\\n\", len, out_n);\n\n    // for(int i=0;i<n;i++)\n    //{\n    // delay_send(0,dest,s_arr[i],s_len);\n    //}\n    // delay_send(0,dest,data,len);\n    // delay_send(1000*1000,dest,data,len);\n    return 0;\n}\nint from_fec_to_normal(conn_info_t &conn_info, char *data, int len, int &out_n, char **&out_arr, int *&out_len, my_time_t *&out_delay) {\n    static my_time_t out_delay_buf[max_blob_packet_num + 100] = {0};\n    out_delay = out_delay_buf;\n    inner_stat_t &inner_stat = conn_info.stat.fec_to_normal;\n    if (disable_fec) {\n        assert(data != 0);\n        inner_stat.input_packet_num++;\n        inner_stat.input_packet_size += len;\n        inner_stat.output_packet_num++;\n        inner_stat.output_packet_size += len;\n\n        if (data == 0) {\n            out_n = 0;\n            return 0;\n        }\n        out_n = 1;\n        static char *data_static;\n        data_static = data;\n        static int len_static;\n        len_static = len;\n        out_arr = &data_static;\n        out_len = &len_static;\n        out_delay[0] = 0;\n    } else {\n        if (data != 0) {\n            inner_stat.input_packet_num++;\n            inner_stat.input_packet_size += len;\n        }\n\n        conn_info.fec_decode_manager.input(data, len);\n\n        // int n;char ** s_arr;int* len_arr;\n        conn_info.fec_decode_manager.output(out_n, out_arr, out_len);\n        for (int i = 0; i < out_n; i++) {\n            out_delay_buf[i] = 0;\n\n            inner_stat.output_packet_num++;\n            inner_stat.output_packet_size += out_len[i];\n        }\n    }\n\n    mylog(log_trace, \"from_fec_to_normal input_len=%d,output_n=%d,input_seq=%u\\n\", len, out_n, read_u32(data));\n\n    //\tprintf(\"<n:%d>\",n);\n    /*\n    for(int i=0;i<n;i++)\n    {\n            delay_send(0,dest,s_arr[i],len_arr[i]);\n            //s_arr[i][len_arr[i]]=0;\n            //printf(\"<%s>\\n\",s_arr[i]);\n    }*/\n    // my_send(dest,data,len);\n    return 0;\n}\n\nint delay_send(my_time_t delay, const dest_t &dest, char *data, int len) {\n    // int rand=random()%100;\n    // mylog(log_info,\"rand = %d\\n\",rand);\n\n    if (dest.cook && random_drop != 0) {\n        if (get_fake_random_number() % 10000 < (u32_t)random_drop) {\n            return 0;\n        }\n    }\n    return delay_manager.add(delay, dest, data, len);\n    ;\n}\n\nint print_parameter() {\n    mylog(log_info, \"jitter_min=%d jitter_max=%d output_interval_min=%d output_interval_max=%d fec_timeout=%d fec_mtu=%d fec_queue_len=%d fec_mode=%d\\n\",\n          jitter_min / 1000, jitter_max / 1000, output_interval_min / 1000, output_interval_max / 1000, g_fec_par.timeout / 1000, g_fec_par.mtu, g_fec_par.queue_len, g_fec_par.mode);\n    mylog(log_info, \"fec_str=%s\\n\", rs_par_str);\n    mylog(log_info, \"fec_inner_parameter=%s\\n\", g_fec_par.rs_to_str());\n    return 0;\n}\nint handle_command(char *s) {\n    int len = strlen(s);\n    while (len >= 1 && s[len - 1] == '\\n')\n        s[len - 1] = 0;\n    mylog(log_info, \"got data from fifo,len=%d,s=[%s]\\n\", len, s);\n    int a = -1, b = -1;\n    if (strncmp(s, \"fec\", strlen(\"fec\")) == 0) {\n        mylog(log_info, \"got command [fec]\\n\");\n        char tmp_str[max_fec_packet_num * 10 + 100];\n        fec_parameter_t tmp_par;\n        sscanf(s, \"fec %s\", tmp_str);\n        /*\n        if(a<1||b<0||a+b>254)\n        {\n                mylog(log_warn,\"invaild value\\n\");\n                return -1;\n        }*/\n        int ret = tmp_par.rs_from_str(tmp_str);\n        if (ret != 0) {\n            mylog(log_warn, \"failed to parse [%s]\\n\", tmp_str);\n            return -1;\n        }\n        int version = g_fec_par.version;\n        g_fec_par.copy_fec(tmp_par);\n        g_fec_par.version = version + 1;\n        strcpy(rs_par_str, tmp_str);\n        // g_fec_data_num=a;\n        // g_fec_redundant_num=b;\n    } else if (strncmp(s, \"mtu\", strlen(\"mtu\")) == 0) {\n        mylog(log_info, \"got command [mtu]\\n\");\n        sscanf(s, \"mtu %d\", &a);\n        if (a < 100 || a > 2000) {\n            mylog(log_warn, \"invaild value\\n\");\n            return -1;\n        }\n        g_fec_par.mtu = a;\n    } else if (strncmp(s, \"queue-len\", strlen(\"queue-len\")) == 0) {\n        mylog(log_info, \"got command [queue-len]\\n\");\n        sscanf(s, \"queue-len %d\", &a);\n        if (a < 1 || a > 10000) {\n            mylog(log_warn, \"invaild value\\n\");\n            return -1;\n        }\n        g_fec_par.queue_len = a;\n    } else if (strncmp(s, \"mode\", strlen(\"mode\")) == 0) {\n        mylog(log_info, \"got command [mode]\\n\");\n        sscanf(s, \"mode %d\", &a);\n        if (a != 0 && a != 1) {\n            mylog(log_warn, \"invaild value\\n\");\n            return -1;\n        }\n        if (g_fec_par.mode != a) {\n            g_fec_par.mode = a;\n\n            assert(g_fec_par.rs_from_str(rs_par_str) == 0);  // re parse rs_par_str,not necessary at the moment, for futher use\n            g_fec_par.version++;\n        }\n    } else if (strncmp(s, \"timeout\", strlen(\"timeout\")) == 0) {\n        mylog(log_info, \"got command [timeout]\\n\");\n        sscanf(s, \"timeout %d\", &a);\n        if (a < 0 || a > 1000) {\n            mylog(log_warn, \"invaild value\\n\");\n            return -1;\n        }\n        g_fec_par.timeout = a * 1000;\n    } else {\n        mylog(log_info, \"unknown command\\n\");\n    }\n    print_parameter();\n\n    return 0;\n}\n\nstatic void empty_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n}\nint unit_test() {\n    {\n        union test_t {\n            u64_t u64;\n            char arry[8];\n        } test111;\n\n        assert((void *)&test111.u64 == (void *)&test111.arry[0]);\n        // printf(\"%llx,%llx\\n\",&ttt.u64,&ttt.arry[0]);\n\n        //\t\tprintf(\"%lld\\n\",get_fake_random_number_64());\n        //\t\tprintf(\"%lld\\n\",get_fake_random_number_64());\n        //\t\tprintf(\"%lld\\n\",get_fake_random_number_64());\n\n        //\t\tprintf(\"%x\\n\",get_fake_random_number());\n        //\t\tprintf(\"%x\\n\",get_fake_random_number());\n        //\t\tprintf(\"%x\\n\",get_fake_random_number());\n\n        char buf[10];\n        get_fake_random_chars(buf, 10);\n        for (int i = 0; i < 10; i++)\n            printf(\"<%d>\", (int)buf[i]);\n        printf(\"\\n\");\n\n        get_fake_random_chars(buf, 10);\n        for (int i = 0; i < 10; i++)\n            printf(\"<%d>\", (int)buf[i]);\n        printf(\"\\n\");\n    }\n\n    int i, j, k;\n    void *code = fec_new(3, 6);\n    char arr[6][100] =\n        {\n            \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\", \"fff\"};\n    char *data[6];\n    for (i = 0; i < 6; i++) {\n        data[i] = arr[i];\n    }\n    rs_encode2(3, 6, data, 3);\n    // printf(\"%d %d\",(int)(unsigned char)arr[5][0],(int)('a'^'b'^'c'^'d'^'e'));\n\n    for (i = 0; i < 6; i++) {\n        printf(\"<%s>\", data[i]);\n    }\n\n    data[0] = 0;\n    // data[1]=0;\n    // data[5]=0;\n\n    int ret = rs_decode2(3, 6, data, 3);\n    printf(\"ret:%d\\n\", ret);\n\n    for (i = 0; i < 6; i++) {\n        printf(\"<%s>\", data[i]);\n    }\n    fec_free(code);\n\n    char arr2[6][100] =\n        {\n            \"aaa11111\", \"\", \"ccc333333333\", \"ddd444\", \"eee5555\", \"ff6666\"};\n    blob_encode_t blob_encode;\n    for (int i = 0; i < 6; i++)\n        blob_encode.input(arr2[i], strlen(arr2[i]));\n\n    char **output;\n    int shard_len;\n    blob_encode.output(7, output, shard_len);\n\n    printf(\"<shard_len:%d>\", shard_len);\n    blob_decode_t blob_decode;\n    for (int i = 0; i < 7; i++) {\n        blob_decode.input(output[i], shard_len);\n    }\n\n    char **decode_output;\n    int *len_arr;\n    int num;\n\n    ret = blob_decode.output(num, decode_output, len_arr);\n\n    printf(\"<num:%d,ret:%d>\\n\", num, ret);\n    for (int i = 0; i < num; i++) {\n        char buf[1000] = {0};\n        memcpy(buf, decode_output[i], len_arr[i]);\n        printf(\"<%d:%s>\", len_arr[i], buf);\n    }\n    printf(\"\\n\");\n    static fec_encode_manager_t fec_encode_manager;\n    static fec_decode_manager_t fec_decode_manager;\n\n    // dynamic_update_fec=0;\n\n    fec_encode_manager.set_loop_and_cb(ev_default_loop(0), empty_cb);\n\n    {\n        string a = \"11111\";\n        string b = \"22\";\n        string c = \"33333333\";\n\n        fec_encode_manager.input((char *)a.c_str(), a.length());\n        fec_encode_manager.input((char *)b.c_str(), b.length());\n        fec_encode_manager.input((char *)c.c_str(), c.length());\n        fec_encode_manager.input(0, 0);\n\n        int n;\n        char **s_arr;\n        int *len;\n\n        fec_encode_manager.output(n, s_arr, len);\n        printf(\"<n:%d,len:%d>\", n, len[0]);\n\n        for (int i = 0; i < n; i++) {\n            fec_decode_manager.input(s_arr[i], len[i]);\n        }\n\n        {\n            int n;\n            char **s_arr;\n            int *len_arr;\n            fec_decode_manager.output(n, s_arr, len_arr);\n            printf(\"<n:%d>\", n);\n            for (int i = 0; i < n; i++) {\n                s_arr[i][len_arr[i]] = 0;\n                printf(\"<%s>\\n\", s_arr[i]);\n            }\n        }\n    }\n\n    {\n        string a = \"aaaaaaa\";\n        string b = \"bbbbbbbbbbbbb\";\n        string c = \"ccc\";\n\n        fec_encode_manager.input((char *)a.c_str(), a.length());\n        fec_encode_manager.input((char *)b.c_str(), b.length());\n        fec_encode_manager.input((char *)c.c_str(), c.length());\n        fec_encode_manager.input(0, 0);\n\n        int n;\n        char **s_arr;\n        int *len;\n\n        fec_encode_manager.output(n, s_arr, len);\n        printf(\"<n:%d,len:%d>\", n, len[0]);\n\n        for (int i = 0; i < n; i++) {\n            if (i == 1 || i == 3 || i == 5 || i == 0)\n                fec_decode_manager.input(s_arr[i], len[i]);\n        }\n\n        {\n            int n;\n            char **s_arr;\n            int *len_arr;\n            fec_decode_manager.output(n, s_arr, len_arr);\n            printf(\"<n:%d>\", n);\n            for (int i = 0; i < n; i++) {\n                s_arr[i][len_arr[i]] = 0;\n                printf(\"<%s>\\n\", s_arr[i]);\n            }\n        }\n    }\n\n    printf(\"ok here.\\n\");\n    for (int i = 0; i < 10; i++) {\n        string a = \"aaaaaaaaaaaaaaaaaaaaaaa\";\n        string b = \"bbbbbbbbbbbbb\";\n        string c = \"cccccccccccccccccc\";\n\n        printf(\"======\\n\");\n        int n;\n        char **s_arr;\n        int *len;\n        fec_decode_manager.output(n, s_arr, len);\n\n        // fec_encode_manager.reset_fec_parameter(3,2,g_fec_mtu,g_fec_queue_len,g_fec_timeout,1);\n\n        fec_parameter_t &fec_par = fec_encode_manager.get_fec_par();\n        fec_par.mtu = g_fec_par.mtu;\n        fec_par.queue_len = g_fec_par.queue_len;\n        fec_par.timeout = g_fec_par.timeout;\n        fec_par.mode = 1;\n        fec_par.rs_from_str((char *)\"3:2\");\n\n        fec_encode_manager.input((char *)a.c_str(), a.length());\n        fec_encode_manager.output(n, s_arr, len);\n\n        printf(\"n=<%d>\\n\", n);\n        assert(n == 1);\n\n        fec_decode_manager.input(s_arr[0], len[0]);\n\n        fec_decode_manager.output(n, s_arr, len);\n        assert(n == 1);\n        printf(\"%s\\n\", s_arr[0]);\n\n        fec_encode_manager.input((char *)b.c_str(), b.length());\n        fec_encode_manager.output(n, s_arr, len);\n        assert(n == 1);\n        // fec_decode_manager.input(s_arr[0],len[0]);\n\n        fec_encode_manager.input((char *)c.c_str(), c.length());\n        fec_encode_manager.output(n, s_arr, len);\n\n        assert(n == 3);\n\n        fec_decode_manager.input(s_arr[0], len[0]);\n        // printf(\"n=%d\\n\",n);\n\n        {\n            int n;\n            char **s_arr;\n            int *len;\n            fec_decode_manager.output(n, s_arr, len);\n            assert(n == 1);\n            printf(\"%s\\n\", s_arr[0]);\n        }\n\n        fec_decode_manager.input(s_arr[1], len[1]);\n\n        {\n            int n;\n            char **s_arr;\n            int *len;\n            fec_decode_manager.output(n, s_arr, len);\n            assert(n == 1);\n            printf(\"n=%d\\n\", n);\n            s_arr[0][len[0]] = 0;\n            printf(\"%s\\n\", s_arr[0]);\n        }\n    }\n\n    myexit(0);\n    return 0;\n}\n\nvoid process_arg(int argc, char *argv[]) {\n    int is_client = 0, is_server = 0;\n    int i, j, k;\n    int opt;\n    static struct option long_options[] =\n        {\n            {\"log-level\", required_argument, 0, 1},\n            {\"log-position\", no_argument, 0, 1},\n            {\"disable-color\", no_argument, 0, 1},\n            {\"enable-color\", no_argument, 0, 1},\n            {\"disable-filter\", no_argument, 0, 1},\n            {\"disable-fec\", no_argument, 0, 1},\n            {\"disable-obscure\", no_argument, 0, 1},\n            {\"disable-xor\", no_argument, 0, 1},\n            {\"disable-checksum\", no_argument, 0, 1},\n            {\"fix-latency\", no_argument, 0, 1},\n            {\"sock-buf\", required_argument, 0, 1},\n            {\"random-drop\", required_argument, 0, 1},\n            {\"report\", required_argument, 0, 1},\n            {\"delay-capacity\", required_argument, 0, 1},\n            {\"mtu\", required_argument, 0, 1},\n            {\"mode\", required_argument, 0, 1},\n            {\"timeout\", required_argument, 0, 1},\n            {\"decode-buf\", required_argument, 0, 1},\n            {\"queue-len\", required_argument, 0, 'q'},\n            {\"fec\", required_argument, 0, 'f'},\n            {\"jitter\", required_argument, 0, 'j'},\n            {\"out-addr\", required_argument, 0, 1},\n            {\"out-interface\", required_argument, 0, 1},\n            {\"key\", required_argument, 0, 'k'},\n            {\"header-overhead\", required_argument, 0, 1},\n            //{\"debug-fec\", no_argument,    0, 1},\n            {\"debug-fec-enc\", no_argument, 0, 1},\n            {\"debug-fec-dec\", no_argument, 0, 1},\n            {\"fifo\", required_argument, 0, 1},\n            {\"sub-net\", required_argument, 0, 1},\n            {\"tun-dev\", required_argument, 0, 1},\n            {\"tun-mtu\", required_argument, 0, 1},\n            {\"mssfix\", required_argument, 0, 1},\n            {\"keep-reconnect\", no_argument, 0, 1},\n            {\"persist-tun\", no_argument, 0, 1},\n            {\"manual-set-tun\", no_argument, 0, 1},\n            {\"interval\", required_argument, 0, 'i'},\n            {NULL, 0, 0, 0}};\n    int option_index = 0;\n    assert(g_fec_par.rs_from_str(rs_par_str) == 0);\n\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--unit-test\") == 0) {\n            unit_test();\n            myexit(0);\n        }\n    }\n\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--log-level\") == 0) {\n            if (i < argc - 1) {\n                sscanf(argv[i + 1], \"%d\", &log_level);\n                if (0 <= log_level && log_level < log_end) {\n                } else {\n                    log_bare(log_fatal, \"invalid log_level\\n\");\n                    myexit(-1);\n                }\n            }\n        }\n        if (strcmp(argv[i], \"--enable-color\") == 0) {\n            enable_log_color = 1;\n        }\n        if (strcmp(argv[i], \"--disable-color\") == 0) {\n            enable_log_color = 0;\n        }\n    }\n\n    mylog(log_info, \"argc=%d \", argc);\n\n    for (i = 0; i < argc; i++) {\n        log_bare(log_info, \"%s \", argv[i]);\n    }\n    log_bare(log_info, \"\\n\");\n\n    int no_l = 1, no_r = 1;\n    while ((opt = getopt_long(argc, argv, \"l:r:hcsk:j:f:p:n:i:q:\", long_options, &option_index)) != -1) {\n        // string opt_key;\n        // opt_key+=opt;\n        switch (opt) {\n            case 'k':\n                sscanf(optarg, \"%s\\n\", key_string);\n                mylog(log_debug, \"key=%s\\n\", key_string);\n                if (strlen(key_string) == 0) {\n                    mylog(log_fatal, \"key len=0??\\n\");\n                    myexit(-1);\n                }\n                break;\n            case 'j':\n                if (strchr(optarg, ':') == 0) {\n                    int jitter;\n                    sscanf(optarg, \"%d\\n\", &jitter);\n                    if (jitter < 0 || jitter > 1000 * 10) {\n                        mylog(log_fatal, \"jitter must be between 0 and 10,000(10 second)\\n\");\n                        myexit(-1);\n                    }\n                    jitter_min = 0;\n                    jitter_max = jitter;\n\n                } else {\n                    sscanf(optarg, \"%d:%d\\n\", &jitter_min, &jitter_max);\n                    if (jitter_min < 0 || jitter_max < 0 || jitter_min > jitter_max) {\n                        mylog(log_fatal, \" must satisfy  0<=jmin<=jmax\\n\");\n                        myexit(-1);\n                    }\n                }\n                jitter_min *= 1000;\n                jitter_max *= 1000;\n                break;\n            case 'i':\n                if (strchr(optarg, ':') == 0) {\n                    int output_interval = -1;\n                    sscanf(optarg, \"%d\\n\", &output_interval);\n                    if (output_interval < 0 || output_interval > 1000 * 10) {\n                        mylog(log_fatal, \"output_interval must be between 0 and 10,000(10 second)\\n\");\n                        myexit(-1);\n                    }\n                    output_interval_min = output_interval_max = output_interval;\n                } else {\n                    sscanf(optarg, \"%d:%d\\n\", &output_interval_min, &output_interval_max);\n                    if (output_interval_min < 0 || output_interval_max < 0 || output_interval_min > output_interval_max) {\n                        mylog(log_fatal, \" must satisfy  0<=output_interval_min<=output_interval_max\\n\");\n                        myexit(-1);\n                    }\n                }\n                output_interval_min *= 1000;\n                output_interval_max *= 1000;\n                break;\n            case 'f':\n                if (strchr(optarg, ':') == 0) {\n                    mylog(log_fatal, \"invalid format for f\");\n                    myexit(-1);\n                } else {\n                    strcpy(rs_par_str, optarg);\n                    // sscanf(optarg,\"%d:%d\\n\",&g_fec_data_num,&g_fec_redundant_num);\n                    /*\n                    if(g_fec_data_num<1 ||g_fec_redundant_num<0||g_fec_data_num+g_fec_redundant_num>254)\n                    {\n                            mylog(log_fatal,\"fec_data_num<1 ||fec_redundant_num<0||fec_data_num+fec_redundant_num>254\\n\");\n                            myexit(-1);\n                    }*/\n                }\n                break;\n            case 'q':\n                sscanf(optarg, \"%d\", &g_fec_par.queue_len);\n                if (g_fec_par.queue_len < 1 || g_fec_par.queue_len > 10000) {\n                    mylog(log_fatal, \"fec_pending_num should be between 1 and 10000\\n\");\n                    myexit(-1);\n                }\n                break;\n            case 'c':\n                is_client = 1;\n                break;\n            case 's':\n                is_server = 1;\n                break;\n            case 'l':\n                no_l = 0;\n                local_addr.from_str(optarg);\n                break;\n            case 'r':\n                no_r = 0;\n                remote_addr.from_str(optarg);\n                break;\n            case 'h':\n                break;\n            case 1:\n                if (strcmp(long_options[option_index].name, \"log-level\") == 0) {\n                } else if (strcmp(long_options[option_index].name, \"disable-filter\") == 0) {\n                    disable_replay_filter = 1;\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"disable-color\") == 0) {\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"enable-color\") == 0) {\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"disable-fec\") == 0) {\n                    disable_fec = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-obscure\") == 0) {\n                    mylog(log_info, \"obscure disabled\\n\");\n                    disable_obscure = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-xor\") == 0) {\n                    mylog(log_info, \"xor disabled\\n\");\n                    disable_xor = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-checksum\") == 0) {\n                    disable_checksum = 1;\n                    mylog(log_warn, \"checksum disabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"fix-latency\") == 0) {\n                    mylog(log_info, \"fix-latency enabled\\n\");\n                    fix_latency = 1;\n                }\n\n                else if (strcmp(long_options[option_index].name, \"log-position\") == 0) {\n                    enable_log_position = 1;\n                } else if (strcmp(long_options[option_index].name, \"random-drop\") == 0) {\n                    sscanf(optarg, \"%d\", &random_drop);\n                    if (random_drop < 0 || random_drop > 10000) {\n                        mylog(log_fatal, \"random_drop must be between 0 10000 \\n\");\n                        myexit(-1);\n                    }\n                    mylog(log_info, \"random_drop=%d\\n\", random_drop);\n                } else if (strcmp(long_options[option_index].name, \"delay-capacity\") == 0) {\n                    sscanf(optarg, \"%d\", &delay_capacity);\n\n                    if (delay_capacity < 0) {\n                        mylog(log_fatal, \"delay_capacity must be >=0 \\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"report\") == 0) {\n                    sscanf(optarg, \"%d\", &report_interval);\n\n                    if (report_interval <= 0) {\n                        mylog(log_fatal, \"report_interval must be >0 \\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"sock-buf\") == 0) {\n                    int tmp = -1;\n                    sscanf(optarg, \"%d\", &tmp);\n                    if (10 <= tmp && tmp <= 10 * 1024) {\n                        socket_buf_size = tmp * 1024;\n                    } else {\n                        mylog(log_fatal, \"sock-buf value must be between 1 and 10240 (kbyte) \\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"decode-buf\") == 0) {\n                    sscanf(optarg, \"%d\", &fec_buff_num);\n                    if (fec_buff_num < 300 || fec_buff_num > 20000) {\n                        mylog(log_fatal, \"decode-buf value must be between 300 and 20000 (kbyte) \\n\");\n                        myexit(-1);\n                    }\n                    mylog(log_info, \"decode-buf=%d\\n\", fec_buff_num);\n                } else if (strcmp(long_options[option_index].name, \"mode\") == 0) {\n                    sscanf(optarg, \"%d\", &g_fec_par.mode);\n                    if (g_fec_par.mode != 0 && g_fec_par.mode != 1) {\n                        mylog(log_fatal, \"mode should be 0 or 1\\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"mtu\") == 0) {\n                    sscanf(optarg, \"%d\", &g_fec_par.mtu);\n                    if (g_fec_par.mtu < 100 || g_fec_par.mtu > 2000) {\n                        mylog(log_fatal, \"fec_mtu should be between 100 and 2000\\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"out-addr\") == 0) {\n                    // has_b = true;\n                    mylog(log_debug, \"out-addr=%s\\n\", optarg);\n                    out_addr = new address_t();\n                    out_addr->from_str(optarg);\n                } else if (strcmp(long_options[option_index].name, \"out-interface\") == 0) {\n                    out_interface = new char[strlen(optarg) + 10];\n                    sscanf(optarg, \"%s\\n\", out_interface);\n                    mylog(log_debug, \"out-interface=%s\\n\", out_interface);\n                    if (strlen(out_interface) == 0) {\n                        mylog(log_fatal, \"out_interface string len=0??\\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"timeout\") == 0) {\n                    sscanf(optarg, \"%d\", &g_fec_par.timeout);\n                    if (g_fec_par.timeout < 0 || g_fec_par.timeout > 1000) {\n                        mylog(log_fatal, \"fec_pending_time should be between 0 and 1000(1s)\\n\");\n                        myexit(-1);\n                    }\n                    g_fec_par.timeout *= 1000;\n                } else if (strcmp(long_options[option_index].name, \"debug-fec-enc\") == 0) {\n                    debug_fec_enc = 1;\n                    mylog(log_info, \"debug_fec_enc enabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"debug-fec-dec\") == 0) {\n                    debug_fec_dec = 1;\n                    mylog(log_info, \"debug_fec_dec enabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"fifo\") == 0) {\n                    sscanf(optarg, \"%s\", fifo_file);\n\n                    mylog(log_info, \"fifo_file =%s \\n\", fifo_file);\n                } else if (strcmp(long_options[option_index].name, \"keep-reconnect\") == 0) {\n                    keep_reconnect = 1;\n                    mylog(log_info, \"keep_reconnect enabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"manual-set-tun\") == 0) {\n                    manual_set_tun = 1;\n                    mylog(log_info, \"manual_set_tun enabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"persist-tun\") == 0) {\n                    persist_tun = 1;\n                    mylog(log_info, \"persist_tun enabled\\n\");\n                } else if (strcmp(long_options[option_index].name, \"sub-net\") == 0) {\n                    sscanf(optarg, \"%s\", sub_net);\n                    mylog(log_info, \"sub_net %s\\n\", sub_net);\n\n                } else if (strcmp(long_options[option_index].name, \"tun-dev\") == 0) {\n                    sscanf(optarg, \"%s\", tun_dev);\n                    mylog(log_info, \"tun_dev=%s\\n\", tun_dev);\n\n                } else if (strcmp(long_options[option_index].name, \"tun-mtu\") == 0) {\n                    sscanf(optarg, \"%d\", &tun_mtu);\n                    mylog(log_warn, \"changed tun_mtu,tun_mtu=%d\\n\", tun_mtu);\n                } else if (strcmp(long_options[option_index].name, \"header-overhead\") == 0) {\n                    sscanf(optarg, \"%d\", &header_overhead);\n                    mylog(log_warn, \"changed header_overhead,header_overhead=%d\\n\", header_overhead);\n                } else if (strcmp(long_options[option_index].name, \"mssfix\") == 0) {\n                    sscanf(optarg, \"%d\", &mssfix);\n                    mylog(log_warn, \"mssfix=%d\\n\", mssfix);\n                } else {\n                    mylog(log_fatal, \"unknown option\\n\");\n                    myexit(-1);\n                }\n                break;\n            default:\n                mylog(log_fatal, \"unknown option <%x>\", opt);\n                myexit(-1);\n        }\n    }\n\n    if (is_client == 0 && is_server == 0) {\n        mylog(log_fatal, \"-s -c hasnt been set\\n\");\n        myexit(-1);\n    }\n    if (is_client == 1 && is_server == 1) {\n        mylog(log_fatal, \"-s -c cant be both set\\n\");\n        myexit(-1);\n    }\n    if (is_client == 1) {\n        program_mode = client_mode;\n    } else {\n        program_mode = server_mode;\n    }\n\n    if (working_mode == tunnel_mode) {\n        if (no_l)\n            mylog(log_fatal, \"error: -l not found\\n\");\n        if (no_r)\n            mylog(log_fatal, \"error: -r not found\\n\");\n        if (no_l || no_r)\n            myexit(-1);\n    } else if (working_mode == tun_dev_mode) {\n        if (program_mode == client_mode && no_r) {\n            mylog(log_fatal, \"error: -r not found\\n\");\n            myexit(-1);\n        } else if (program_mode == server_mode && no_l) {\n            mylog(log_fatal, \"error: -l not found\\n\");\n            myexit(-1);\n        }\n    }\n\n    int ret = g_fec_par.rs_from_str(rs_par_str);\n    if (ret != 0) {\n        mylog(log_fatal, \"failed to parse [%s]\\n\", rs_par_str);\n        myexit(-1);\n    }\n\n    print_parameter();\n}\n"
        },
        {
          "name": "misc.h",
          "type": "blob",
          "size": 1.6005859375,
          "content": "/*\n * misc.h\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#ifndef MISC_H_\n#define MISC_H_\n\n#include \"common.h\"\n#include \"connection.h\"\n#include \"fd_manager.h\"\n#include \"delay_manager.h\"\n#include \"fec_manager.h\"\n\nextern char fifo_file[1000];\n\nextern int mtu_warn;\n\nextern int disable_mtu_warn;\nextern int disable_fec;\nextern int disable_checksum;\n\nextern int debug_force_flush_fec;\n\nextern int jitter_min;\nextern int jitter_max;\n\nextern int output_interval_min;\nextern int output_interval_max;\n\nextern int fix_latency;\n\n// extern u32_t local_ip_uint32,remote_ip_uint32;\n// extern char local_ip[100], remote_ip[100];\n// extern int local_port, remote_port;\n\nextern address_t local_addr, remote_addr;\n\nextern address_t *out_addr;\nextern char *out_interface;\n\nextern conn_manager_t conn_manager;\nextern delay_manager_t delay_manager;\nextern fd_manager_t fd_manager;\n\nextern int time_mono_test;\n\nextern int delay_capacity;\n\nextern int keep_reconnect;\n\nextern int tun_mtu;\n\nextern int mssfix;\n\nextern int manual_set_tun;\nextern int persist_tun;\n\nint from_normal_to_fec(conn_info_t &conn_info, char *data, int len, int &out_n, char **&out_arr, int *&out_len, my_time_t *&out_delay);\nint from_fec_to_normal(conn_info_t &conn_info, char *data, int len, int &out_n, char **&out_arr, int *&out_len, my_time_t *&out_delay);\n\nint delay_send(my_time_t delay, const dest_t &dest, char *data, int len);\nint print_parameter();\nint handle_command(char *s);\n\nint unit_test();\n\n// void print_help();\n\nvoid process_arg(int argc, char *argv[]);\n\nextern char sub_net[100];\nextern u32_t sub_net_uint32;\nextern char tun_dev[100];\n\n#endif /* MISC_H_ */\n"
        },
        {
          "name": "my_ev.cpp",
          "type": "blob",
          "size": 0.443359375,
          "content": "#pragma GCC diagnostic push\n\n#pragma GCC diagnostic ignored \"-Wextra\"\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wcomment\"\n#pragma GCC diagnostic ignored \"-Wparentheses\"\n#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#pragma GCC diagnostic ignored \"-Wunused-value\"\n\n#pragma GCC diagnostic ignored \"-Wall\"\n#pragma GCC diagnostic ignored \"-W\"\n\n#include \"my_ev_common.h\"\n#include \"ev.c\"\n\n#pragma GCC diagnostic pop\n"
        },
        {
          "name": "my_ev.h",
          "type": "blob",
          "size": 0.0546875,
          "content": "#pragma once\n\n#include \"my_ev_common.h\"\n#include \"ev.h\"\n"
        },
        {
          "name": "my_ev_common.h",
          "type": "blob",
          "size": 0.318359375,
          "content": "\n#define EV_STANDALONE 1\n#define EV_COMMON \\\n    void *data;   \\\n    unsigned long long u64;\n#define EV_COMPAT3 0\n//#define EV_VERIFY 2\n\n#if defined(__MINGW32__)\n#define EV_FD_TO_WIN32_HANDLE(fd) (fd)\n#define EV_WIN32_HANDLE_TO_FD(handle) (handle)\n#define EV_WIN32_CLOSE_FD(fd) closesocket(fd)\n#define FD_SETSIZE 4096\n\n#endif\n"
        },
        {
          "name": "packet.cpp",
          "type": "blob",
          "size": 9.951171875,
          "content": "/*\n * packet.cpp\n *\n *  Created on: Sep 15, 2017\n *      Author: root\n */\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"misc.h\"\n\nint iv_min = 4;\nint iv_max = 32;  //< 256;\nu64_t packet_send_count = 0;\nu64_t dup_packet_send_count = 0;\nu64_t packet_recv_count = 0;\nu64_t dup_packet_recv_count = 0;\n\ntypedef u64_t anti_replay_seq_t;\nint disable_replay_filter = 0;\n\nint disable_obscure = 0;\nint disable_xor = 0;\n\nint random_drop = 0;\n\nchar key_string[1000] = \"\";\n\n// int local_listen_fd=-1;\n\nvoid encrypt_0(char *input, int &len, char *key) {\n    int i, j;\n    if (key[0] == 0) return;\n    for (i = 0, j = 0; i < len; i++, j++) {\n        if (key[j] == 0) j = 0;\n        input[i] ^= key[j];\n    }\n}\n\nvoid decrypt_0(char *input, int &len, char *key) {\n    int i, j;\n    if (key[0] == 0) return;\n    for (i = 0, j = 0; i < len; i++, j++) {\n        if (key[j] == 0) j = 0;\n        input[i] ^= key[j];\n    }\n}\nint do_obscure_old(const char *input, int in_len, char *output, int &out_len) {\n    // memcpy(output,input,in_len);\n    //\tout_len=in_len;\n    // return 0;\n\n    int i, j, k;\n    if (in_len > 65535 || in_len < 0)\n        return -1;\n    int iv_len = iv_min + rand() % (iv_max - iv_min);\n    get_fake_random_chars(output, iv_len);\n    memcpy(output + iv_len, input, in_len);\n\n    output[iv_len + in_len] = (uint8_t)iv_len;\n\n    output[iv_len + in_len] ^= output[0];\n    output[iv_len + in_len] ^= key_string[0];\n\n    for (i = 0, j = 0, k = 1; i < in_len; i++, j++, k++) {\n        if (j == iv_len) j = 0;\n        if (key_string[k] == 0) k = 0;\n        output[iv_len + i] ^= output[j];\n        output[iv_len + i] ^= key_string[k];\n    }\n\n    out_len = iv_len + in_len + 1;\n    return 0;\n}\n\nint do_obscure(char *data, int &len) {\n    assert(len >= 0);\n    assert(len < buf_len);\n\n    int iv_len = random_between(iv_min, iv_max);\n    get_fake_random_chars(data + len, iv_len);\n    data[iv_len + len] = (uint8_t)iv_len;\n    for (int i = 0, j = 0; i < len; i++, j++) {\n        if (j == iv_len) j = 0;\n        data[i] ^= data[len + j];\n    }\n\n    len = len + iv_len + 1;\n    return 0;\n}\n\nint de_obscure(char *data, int &len) {\n    if (len < 1) return -1;\n    int iv_len = int((uint8_t)data[len - 1]);\n\n    if (len < 1 + iv_len) return -1;\n\n    len = len - 1 - iv_len;\n    for (int i = 0, j = 0; i < len; i++, j++) {\n        if (j == iv_len) j = 0;\n        data[i] ^= data[len + j];\n    }\n\n    return 0;\n}\nint de_obscure_old(const char *input, int in_len, char *output, int &out_len) {\n    // memcpy(output,input,in_len);\n    // out_len=in_len;\n    // return 0;\n\n    int i, j, k;\n    if (in_len > 65535 || in_len < 0) {\n        mylog(log_debug, \"in_len > 65535||in_len<0 ,  %d\", in_len);\n        return -1;\n    }\n    int iv_len = int((uint8_t)(input[in_len - 1] ^ input[0] ^ key_string[0]));\n    out_len = in_len - 1 - iv_len;\n    if (out_len < 0) {\n        mylog(log_debug, \"%d %d\\n\", in_len, out_len);\n        return -1;\n    }\n    for (i = 0, j = 0, k = 1; i < in_len; i++, j++, k++) {\n        if (j == iv_len) j = 0;\n        if (key_string[k] == 0) k = 0;\n        output[i] = input[iv_len + i] ^ input[j] ^ key_string[k];\n    }\n    dup_packet_recv_count++;\n    return 0;\n}\n\n/*\nint sendto_fd_ip_port (int fd,u32_t ip,int port,char * buf, int len,int flags)\n{\n\n        sockaddr_in tmp_sockaddr;\n\n        memset(&tmp_sockaddr,0,sizeof(tmp_sockaddr));\n        tmp_sockaddr.sin_family = AF_INET;\n        tmp_sockaddr.sin_addr.s_addr = ip;\n        tmp_sockaddr.sin_port = htons(uint16_t(port));\n\n        return sendto(fd, buf,\n                        len , 0,\n                        (struct sockaddr *) &tmp_sockaddr,\n                        sizeof(tmp_sockaddr));\n}*/\n\nint sendto_fd_addr(int fd, address_t addr, char *buf, int len, int flags) {\n    return sendto(fd, buf,\n                  len, 0,\n                  (struct sockaddr *)&addr.inner,\n                  addr.get_len());\n}\n/*\nint sendto_ip_port (u32_t ip,int port,char * buf, int len,int flags)\n{\n        return sendto_fd_ip_port(local_listen_fd,ip,port,buf,len,flags);\n}*/\n\nint send_fd(int fd, char *buf, int len, int flags) {\n    return send(fd, buf, len, flags);\n}\n\nint my_send(const dest_t &dest, char *data, int len) {\n    if (dest.cook) {\n        do_cook(data, len);\n    }\n    switch (dest.type) {\n        case type_fd_addr: {\n            return sendto_fd_addr(dest.inner.fd, dest.inner.fd_addr.addr, data, len, 0);\n            break;\n        }\n        case type_fd64_addr: {\n            if (!fd_manager.exist(dest.inner.fd64)) return -1;\n            int fd = fd_manager.to_fd(dest.inner.fd64);\n\n            return sendto_fd_addr(fd, dest.inner.fd64_addr.addr, data, len, 0);\n            break;\n        }\n        case type_fd: {\n            return send_fd(dest.inner.fd, data, len, 0);\n            break;\n        }\n        case type_write_fd: {\n            return write(dest.inner.fd, data, len);\n            break;\n        }\n        case type_fd64: {\n            if (!fd_manager.exist(dest.inner.fd64)) return -1;\n            int fd = fd_manager.to_fd(dest.inner.fd64);\n\n            return send_fd(fd, data, len, 0);\n            break;\n        }\n        /*\n        case type_fd64_ip_port_conv:\n        {\n                if(!fd_manager.exist(dest.inner.fd64)) return -1;\n                int fd=fd_manager.to_fd(dest.inner.fd64);\n\n                char *new_data;\n                int new_len;\n\n                put_conv(dest.conv,data,len,new_data,new_len);\n                return sendto_fd_ip_port(fd,dest.inner.fd64_ip_port.ip_port.ip,dest.inner.fd64_ip_port.ip_port.port,new_data,new_len,0);\n                break;\n        }*/\n\n        /*\n        case type_fd64_conv:\n        {\n                char *new_data;\n                int new_len;\n                put_conv(dest.conv,data,len,new_data,new_len);\n\n                if(!fd_manager.exist(dest.inner.fd64)) return -1;\n                int fd=fd_manager.to_fd(dest.inner.fd64);\n                return send_fd(fd,new_data,new_len,0);\n        }*/\n        /*\n        case type_fd:\n        {\n                send_fd(dest.inner.fd,data,len,0);\n                break;\n        }*/\n        default:\n            assert(0 == 1);\n    }\n    return 0;\n}\n\n/*\n *  this function comes from  http://www.hackersdelight.org/hdcodetxt/crc.c.txt\n */\nunsigned int crc32h(unsigned char *message, int len) {\n    assert(len >= 0);\n    int i, crc;\n    unsigned int byte, c;\n    const unsigned int g0 = 0xEDB88320, g1 = g0 >> 1,\n                       g2 = g0 >> 2, g3 = g0 >> 3, g4 = g0 >> 4, g5 = g0 >> 5,\n                       g6 = (g0 >> 6) ^ g0, g7 = ((g0 >> 6) ^ g0) >> 1;\n\n    i = 0;\n    crc = 0xFFFFFFFF;\n    while (i != len) {  // Get next byte.\n        byte = message[i];\n        crc = crc ^ byte;\n        c = ((crc << 31 >> 31) & g7) ^ ((crc << 30 >> 31) & g6) ^\n            ((crc << 29 >> 31) & g5) ^ ((crc << 28 >> 31) & g4) ^\n            ((crc << 27 >> 31) & g3) ^ ((crc << 26 >> 31) & g2) ^\n            ((crc << 25 >> 31) & g1) ^ ((crc << 24 >> 31) & g0);\n        crc = ((unsigned)crc >> 8) ^ c;\n        i = i + 1;\n    }\n    return ~crc;\n}\n\nint put_conv0(u32_t conv, const char *input, int len_in, char *&output, int &len_out) {\n    assert(len_in >= 0);\n    static char buf[buf_len];\n    output = buf;\n    u32_t n_conv = htonl(conv);\n    memcpy(output, &n_conv, sizeof(n_conv));\n    memcpy(output + sizeof(n_conv), input, len_in);\n    u32_t crc32 = crc32h((unsigned char *)output, len_in + sizeof(crc32));\n    u32_t crc32_n = htonl(crc32);\n    len_out = len_in + (int)(sizeof(n_conv)) + (int)sizeof(crc32_n);\n    memcpy(output + len_in + (int)(sizeof(n_conv)), &crc32_n, sizeof(crc32_n));\n    return 0;\n}\nint get_conv0(u32_t &conv, const char *input, int len_in, char *&output, int &len_out) {\n    assert(len_in >= 0);\n    u32_t n_conv;\n    memcpy(&n_conv, input, sizeof(n_conv));\n    conv = ntohl(n_conv);\n    output = (char *)input + sizeof(n_conv);\n    u32_t crc32_n;\n    len_out = len_in - (int)sizeof(n_conv) - (int)sizeof(crc32_n);\n    if (len_out < 0) {\n        mylog(log_debug, \"len_out<0\\n\");\n        return -1;\n    }\n    memcpy(&crc32_n, input + len_in - (int)sizeof(crc32_n), sizeof(crc32_n));\n    u32_t crc32 = ntohl(crc32_n);\n    if (crc32 != crc32h((unsigned char *)input, len_in - (int)sizeof(crc32_n))) {\n        mylog(log_debug, \"crc32 check failed\\n\");\n        return -1;\n    }\n    return 0;\n}\nint put_crc32(char *s, int &len) {\n    if (disable_checksum) return 0;\n    assert(len >= 0);\n    // if(len<0) return -1;\n    u32_t crc32 = crc32h((unsigned char *)s, len);\n    write_u32(s + len, crc32);\n    len += sizeof(u32_t);\n\n    return 0;\n}\n\nint do_cook(char *data, int &len) {\n    put_crc32(data, len);\n    if (!disable_obscure) do_obscure(data, len);\n    if (!disable_xor) encrypt_0(data, len, key_string);\n    return 0;\n}\n\nint de_cook(char *s, int &len) {\n    if (!disable_xor) decrypt_0(s, len, key_string);\n    if (!disable_obscure) {\n        int ret = de_obscure(s, len);\n        if (ret != 0) {\n            mylog(log_debug, \"de_obscure fail\\n\");\n            return ret;\n        }\n    }\n    int ret = rm_crc32(s, len);\n    if (ret != 0) {\n        mylog(log_debug, \"rm_crc32 fail\\n\");\n        return ret;\n    }\n    return 0;\n}\nint rm_crc32(char *s, int &len) {\n    if (disable_checksum) return 0;\n    assert(len >= 0);\n    len -= sizeof(u32_t);\n    if (len < 0) return -1;\n    u32_t crc32_in = read_u32(s + len);\n    u32_t crc32 = crc32h((unsigned char *)s, len);\n    if (crc32 != crc32_in) return -1;\n    return 0;\n}\n/*\nint do_obs()\n{\n\n}\nint de_obs()*/\nint put_conv(u32_t conv, const char *input, int len_in, char *&output, int &len_out) {\n    static char buf[buf_len];\n    output = buf;\n    u32_t n_conv = htonl(conv);\n    memcpy(output, &n_conv, sizeof(n_conv));\n    memcpy(output + sizeof(n_conv), input, len_in);\n    len_out = len_in + (int)(sizeof(n_conv));\n\n    return 0;\n}\nint get_conv(u32_t &conv, const char *input, int len_in, char *&output, int &len_out) {\n    u32_t n_conv;\n    memcpy(&n_conv, input, sizeof(n_conv));\n    conv = ntohl(n_conv);\n    output = (char *)input + sizeof(n_conv);\n    len_out = len_in - (int)sizeof(n_conv);\n    if (len_out < 0) {\n        mylog(log_debug, \"len_out<0\\n\");\n        return -1;\n    }\n    return 0;\n}\n"
        },
        {
          "name": "packet.h",
          "type": "blob",
          "size": 1.3623046875,
          "content": "/*\n * packet.h\n *\n *  Created on: Sep 15, 2017\n *      Author: root\n */\n\n#ifndef PACKET_H_\n#define PACKET_H_\n\n#include \"common.h\"\n#include \"fd_manager.h\"\n\nextern int iv_min;\nextern int iv_max;  //< 256;\n\nextern u64_t packet_send_count;\nextern u64_t dup_packet_send_count;\nextern u64_t packet_recv_count;\nextern u64_t dup_packet_recv_count;\nextern char key_string[1000];\nextern int disable_replay_filter;\nextern int random_drop;\nextern int disable_obscure;\nextern int disable_xor;\n\nint my_send(const dest_t &dest, char *data, int len);\n\nvoid encrypt_0(char *input, int &len, char *key);\nvoid decrypt_0(char *input, int &len, char *key);\nint add_seq(char *data, int &data_len);\nint remove_seq(char *data, int &data_len);\nint do_obscure(const char *input, int in_len, char *output, int &out_len);\nint de_obscure(const char *input, int in_len, char *output, int &out_len);\n\n// int sendto_fd_u64 (int fd,u64_t u64,char * buf, int len,int flags);\nint sendto_ip_port(u32_t ip, int port, char *buf, int len, int flags);\nint send_fd(int fd, char *buf, int len, int flags);\n\nint put_conv(u32_t conv, const char *input, int len_in, char *&output, int &len_out);\nint get_conv(u32_t &conv, const char *input, int len_in, char *&output, int &len_out);\nint put_crc32(char *s, int &len);\nint rm_crc32(char *s, int &len);\nint do_cook(char *data, int &len);\nint de_cook(char *s, int &len);\n#endif /* PACKET_H_ */\n"
        },
        {
          "name": "tunnel.h",
          "type": "blob",
          "size": 0.2119140625,
          "content": "/*\n * tunnel.h\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#ifndef TUNNEL_H_\n#define TUNNEL_H_\n\n#include \"misc.h\"\n\nint tunnel_client_event_loop();\nint tunnel_server_event_loop();\n\n#endif /* TUNNEL_H_ */\n"
        },
        {
          "name": "tunnel_client.cpp",
          "type": "blob",
          "size": 13.78125,
          "content": "#include \"tunnel.h\"\n\nvoid data_from_local_or_fec_timeout(conn_info_t &conn_info, int is_time_out) {\n    fd64_t &remote_fd64 = conn_info.remote_fd64;\n    int &local_listen_fd = conn_info.local_listen_fd;\n\n    char data[buf_len];\n    int data_len;\n    address_t addr;\n    u32_t conv;\n    int out_n;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n    dest_t dest;\n    dest.type = type_fd64;\n    dest.inner.fd64 = remote_fd64;\n    dest.cook = 1;\n\n    if (is_time_out) {\n        // fd64_t fd64=events[idx].data.u64;\n        mylog(log_trace, \"events[idx].data.u64 == conn_info.fec_encode_manager.get_timer_fd64()\\n\");\n\n        // uint64_t value;\n        // if(!fd_manager.exist(fd64))   //fd64 has been closed\n        //{\n        //\tmylog(log_trace,\"!fd_manager.exist(fd64)\");\n        //\tcontinue;\n        // }\n        // if((ret=read(fd_manager.to_fd(fd64), &value, 8))!=8)\n        //{\n        //\tmylog(log_trace,\"(ret=read(fd_manager.to_fd(fd64), &value, 8))!=8,ret=%d\\n\",ret);\n        //\tcontinue;\n        // }\n        // if(value==0)\n        //{\n        //\tmylog(log_debug,\"value==0\\n\");\n        //\tcontinue;\n        // }\n        // assert(value==1);\n        from_normal_to_fec(conn_info, 0, 0, out_n, out_arr, out_len, out_delay);\n    } else  // events[idx].data.u64 == (u64_t)local_listen_fd\n    {\n        mylog(log_trace, \"events[idx].data.u64 == (u64_t)local_listen_fd\\n\");\n        address_t::storage_t udp_new_addr_in = {0};\n        socklen_t udp_new_addr_len = sizeof(address_t::storage_t);\n        if ((data_len = recvfrom(local_listen_fd, data, max_data_len + 1, 0,\n                                 (struct sockaddr *)&udp_new_addr_in, &udp_new_addr_len)) == -1) {\n            mylog(log_debug, \"recv_from error,this shouldnt happen,err=%s,but we can try to continue\\n\", get_sock_error());\n            return;\n        };\n\n        if (data_len == max_data_len + 1) {\n            mylog(log_warn, \"huge packet from upper level, data_len > %d, packet truncated, dropped\\n\", max_data_len);\n            return;\n        }\n\n        if (!disable_mtu_warn && data_len >= mtu_warn) {\n            mylog(log_warn, \"huge packet,data len=%d (>=%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", data_len, mtu_warn);\n        }\n\n        addr.from_sockaddr((struct sockaddr *)&udp_new_addr_in, udp_new_addr_len);\n\n        mylog(log_trace, \"Received packet from %s, len: %d\\n\", addr.get_str(), data_len);\n\n        // u64_t u64=ip_port.to_u64();\n\n        if (!conn_info.conv_manager.c.is_data_used(addr)) {\n            if (conn_info.conv_manager.c.get_size() >= max_conv_num) {\n                mylog(log_warn, \"ignored new udp connect bc max_conv_num exceed\\n\");\n                return;\n            }\n            conv = conn_info.conv_manager.c.get_new_conv();\n            conn_info.conv_manager.c.insert_conv(conv, addr);\n            mylog(log_info, \"new packet from %s,conv_id=%x\\n\", addr.get_str(), conv);\n        } else {\n            conv = conn_info.conv_manager.c.find_conv_by_data(addr);\n            mylog(log_trace, \"conv=%d\\n\", conv);\n        }\n        conn_info.conv_manager.c.update_active_time(conv);\n        char *new_data;\n        int new_len;\n        put_conv(conv, data, data_len, new_data, new_len);\n\n        mylog(log_trace, \"data_len=%d new_len=%d\\n\", data_len, new_len);\n        from_normal_to_fec(conn_info, new_data, new_len, out_n, out_arr, out_len, out_delay);\n    }\n    mylog(log_trace, \"out_n=%d\\n\", out_n);\n    for (int i = 0; i < out_n; i++) {\n        delay_send(out_delay[i], dest, out_arr[i], out_len[i]);\n    }\n}\nstatic void local_listen_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    data_from_local_or_fec_timeout(conn_info, 0);\n}\n\nstatic void remote_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    char data[buf_len];\n    if (!fd_manager.exist(watcher->u64))  // fd64 has been closed\n    {\n        mylog(log_trace, \"!fd_manager.exist(events[idx].data.u64)\");\n        return;\n    }\n    fd64_t &remote_fd64 = conn_info.remote_fd64;\n    int &remote_fd = conn_info.remote_fd;\n\n    assert(watcher->u64 == remote_fd64);\n\n    int fd = fd_manager.to_fd(remote_fd64);\n\n    int data_len = recv(fd, data, max_data_len + 1, 0);\n\n    if (data_len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d, packet truncated, dropped\\n\", max_data_len);\n        return;\n    }\n\n    mylog(log_trace, \"received data from udp fd %d, len=%d\\n\", remote_fd, data_len);\n    if (data_len < 0) {\n        if (get_sock_errno() == ECONNREFUSED) {\n            mylog(log_debug, \"recv failed %d ,udp_fd%d,errno:%s\\n\", data_len, remote_fd, get_sock_error());\n        }\n\n        mylog(log_warn, \"recv failed %d ,udp_fd%d,errno:%s\\n\", data_len, remote_fd, get_sock_error());\n        return;\n    }\n    if (!disable_mtu_warn && data_len > mtu_warn) {\n        mylog(log_warn, \"huge packet,data len=%d (>%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", data_len, mtu_warn);\n    }\n\n    if (de_cook(data, data_len) != 0) {\n        mylog(log_debug, \"de_cook error\");\n        return;\n    }\n\n    int out_n;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n    from_fec_to_normal(conn_info, data, data_len, out_n, out_arr, out_len, out_delay);\n\n    mylog(log_trace, \"out_n=%d\\n\", out_n);\n\n    for (int i = 0; i < out_n; i++) {\n        u32_t conv;\n        char *new_data;\n        int new_len;\n        if (get_conv(conv, out_arr[i], out_len[i], new_data, new_len) != 0) {\n            mylog(log_debug, \"get_conv(conv,out_arr[i],out_len[i],new_data,new_len)!=0\");\n            continue;\n        }\n        if (!conn_info.conv_manager.c.is_conv_used(conv)) {\n            mylog(log_trace, \"!conn_info.conv_manager.is_conv_used(conv)\");\n            continue;\n        }\n\n        conn_info.conv_manager.c.update_active_time(conv);\n\n        address_t addr = conn_info.conv_manager.c.find_data_by_conv(conv);\n        dest_t dest;\n        dest.inner.fd_addr.fd = conn_info.local_listen_fd;\n        dest.inner.fd_addr.addr = addr;\n        dest.type = type_fd_addr;\n\n        delay_send(out_delay[i], dest, new_data, new_len);\n    }\n}\n\nstatic void fifo_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n    int fifo_fd = watcher->fd;\n\n    char buf[buf_len];\n    int len = read(fifo_fd, buf, sizeof(buf));\n    if (len < 0) {\n        mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, get_sock_error());\n        return;\n    }\n    buf[len] = 0;\n    handle_command(buf);\n}\n\nstatic void delay_manager_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    // uint64_t value;\n    // read(delay_manager.get_timer_fd(), &value, 8);\n    // mylog(log_trace,\"events[idx].data.u64 == (u64_t)delay_manager.get_timer_fd()\\n\");\n\n    // do nothing\n}\n\nstatic void fec_encode_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    data_from_local_or_fec_timeout(conn_info, 1);\n}\n\nstatic void conn_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    uint64_t value;\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    // read(conn_info.timer.get_timer_fd(), &value, 8);\n    conn_info.conv_manager.c.clear_inactive();\n    mylog(log_trace, \"events[idx].data.u64==(u64_t)conn_info.timer.get_timer_fd()\\n\");\n\n    conn_info.stat.report_as_client();\n\n    if (debug_force_flush_fec) {\n        int out_n;\n        char **out_arr;\n        int *out_len;\n        my_time_t *out_delay;\n        dest_t dest;\n        dest.type = type_fd64;\n        dest.inner.fd64 = conn_info.remote_fd64;\n        dest.cook = 1;\n        from_normal_to_fec(conn_info, 0, 0, out_n, out_arr, out_len, out_delay);\n        for (int i = 0; i < out_n; i++) {\n            delay_send(out_delay[i], dest, out_arr[i], out_len[i]);\n        }\n    }\n}\n\nstatic void prepare_cb(struct ev_loop *loop, struct ev_prepare *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    delay_manager.check();\n}\n\nint tunnel_client_event_loop() {\n    int i, j, k;\n    int ret;\n    int yes = 1;\n    // int epoll_fd;\n\n    conn_info_t *conn_info_p = new conn_info_t;\n    conn_info_t &conn_info = *conn_info_p;  // huge size of conn_info,do not allocate on stack\n\n    int &local_listen_fd = conn_info.local_listen_fd;\n    new_listen_socket2(local_listen_fd, local_addr);\n\n    // epoll_fd = epoll_create1(0);\n    // assert(epoll_fd>0);\n\n    // const int max_events = 4096;\n    // struct epoll_event ev, events[max_events];\n    // if (epoll_fd < 0) {\n    //\tmylog(log_fatal,\"epoll return %d\\n\", epoll_fd);\n    //\tmyexit(-1);\n    // }\n\n    struct ev_loop *loop = ev_default_loop(0);\n    assert(loop != NULL);\n\n    conn_info.loop = loop;\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = local_listen_fd;\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, local_listen_fd, &ev);\n    // if (ret!=0) {\n    //\tmylog(log_fatal,\"add  udp_listen_fd error\\n\");\n    //\tmyexit(-1);\n    // }\n    struct ev_io local_listen_watcher;\n    local_listen_watcher.data = &conn_info;\n\n    ev_io_init(&local_listen_watcher, local_listen_cb, local_listen_fd, EV_READ);\n    ev_io_start(loop, &local_listen_watcher);\n\n    int &remote_fd = conn_info.remote_fd;\n    fd64_t &remote_fd64 = conn_info.remote_fd64;\n\n    assert(new_connected_socket2(remote_fd, remote_addr, out_addr, out_interface) == 0);\n    remote_fd64 = fd_manager.create(remote_fd);\n\n    mylog(log_debug, \"remote_fd64=%llu\\n\", remote_fd64);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = remote_fd64;\n\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, remote_fd, &ev);\n    // if (ret!= 0) {\n    //\tmylog(log_fatal,\"add raw_fd error\\n\");\n    //\tmyexit(-1);\n    // }\n\n    struct ev_io remote_watcher;\n    remote_watcher.data = &conn_info;\n    remote_watcher.u64 = remote_fd64;\n\n    ev_io_init(&remote_watcher, remote_cb, remote_fd, EV_READ);\n    ev_io_start(loop, &remote_watcher);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = delay_manager.get_timer_fd();\n\n    // mylog(log_debug,\"delay_manager.get_timer_fd()=%d\\n\",delay_manager.get_timer_fd());\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, delay_manager.get_timer_fd(), &ev);\n    // if (ret!= 0) {\n    //\tmylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n    //\tmyexit(-1);\n    // }\n\n    delay_manager.set_loop_and_cb(loop, delay_manager_cb);\n\n    conn_info.fec_encode_manager.set_data(&conn_info);\n    conn_info.fec_encode_manager.set_loop_and_cb(loop, fec_encode_cb);\n\n    // u64_t tmp_fd64=conn_info.fec_encode_manager.get_timer_fd64();\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = tmp_fd64;\n\n    // mylog(log_debug,\"conn_info.fec_encode_manager.get_timer_fd64()=%llu\\n\",conn_info.fec_encode_manager.get_timer_fd64());\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd_manager.to_fd(tmp_fd64), &ev);\n    // if (ret!= 0) {\n    //\tmylog(log_fatal,\"add fec_encode_manager.get_timer_fd64() error\\n\");\n    //\tmyexit(-1);\n    // }\n\n    conn_info.timer.data = &conn_info;\n    ev_init(&conn_info.timer, conn_timer_cb);\n    ev_timer_set(&conn_info.timer, 0, timer_interval / 1000.0);\n    ev_timer_start(loop, &conn_info.timer);\n    // conn_info.timer.add_fd_to_epoll(epoll_fd);\n    // conn_info.timer.set_timer_repeat_us(timer_interval*1000);\n\n    // mylog(log_debug,\"conn_info.timer.get_timer_fd()=%d\\n\",conn_info.timer.get_timer_fd());\n\n    struct ev_io fifo_watcher;\n\n    int fifo_fd = -1;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n        // ev.events = EPOLLIN;\n        // ev.data.u64 = fifo_fd;\n\n        // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fifo_fd, &ev);\n        // if (ret!= 0) {\n        //\tmylog(log_fatal,\"add fifo_fd to epoll error %s\\n\",strerror(errno));\n        //\tmyexit(-1);\n        // }\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n\n        ev_io_init(&fifo_watcher, fifo_cb, fifo_fd, EV_READ);\n        ev_io_start(loop, &fifo_watcher);\n    }\n\n    ev_prepare prepare_watcher;\n    ev_init(&prepare_watcher, prepare_cb);\n    ev_prepare_start(loop, &prepare_watcher);\n\n    mylog(log_info, \"now listening at %s\\n\", local_addr.get_str());\n\n    ev_run(loop, 0);\n\n    mylog(log_warn, \"ev_run returned\\n\");\n    myexit(0);\n\n    /*\n    while(1)////////////////////////\n    {\n            if(about_to_exit) myexit(0);\n\n            int nfds = epoll_wait(epoll_fd, events, max_events, 180 * 1000);\n            if (nfds < 0) {  //allow zero\n                    if(errno==EINTR  )\n                    {\n                            mylog(log_info,\"epoll interrupted by signal continue\\n\");\n                    }\n                    else\n                    {\n                            mylog(log_fatal,\"epoll_wait return %d,%s\\n\", nfds,strerror(errno));\n                            myexit(-1);\n                    }\n            }\n            int idx;\n            for (idx = 0; idx < nfds; ++idx) {\n                    if(events[idx].data.u64==(u64_t)conn_info.timer.get_timer_fd())\n                    {\n\n                    }\n\n                    else if (events[idx].data.u64 == (u64_t)fifo_fd)\n                    {\n\n                    }\n                    else if (events[idx].data.u64 == (u64_t)local_listen_fd||events[idx].data.u64 == conn_info.fec_encode_manager.get_timer_fd64())\n                    {\n\n                    }\n                else if (events[idx].data.u64 == (u64_t)delay_manager.get_timer_fd()) {\n\n                    }\n                    else if(events[idx].data.u64>u32_t(-1) )\n                    {\n\n                    }\n                    else\n                    {\n                            mylog(log_fatal,\"unknown fd,this should never happen\\n\");\n                            myexit(-1);\n                    }\n            }\n            //delay_manager.check();\n    }*/\n    return 0;\n}\n"
        },
        {
          "name": "tunnel_server.cpp",
          "type": "blob",
          "size": 14.740234375,
          "content": "/*\n * tunnel.cpp\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#include \"tunnel.h\"\n\nstatic void conn_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents);\nstatic void fec_encode_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents);\nstatic void remote_cb(struct ev_loop *loop, struct ev_io *watcher, int revents);\n\nenum tmp_mode_t { is_from_remote = 0,\n                  is_fec_timeout,\n                  is_conn_timer };\n\nvoid data_from_remote_or_fec_timeout_or_conn_timer(conn_info_t &conn_info, fd64_t fd64, tmp_mode_t mode) {\n    int ret;\n\n    char data[buf_len];\n    int data_len;\n    u32_t conv;\n    // fd64_t fd64=events[idx].data.u64;\n    // mylog(log_trace,\"events[idx].data.u64 >u32_t(-1),%llu\\n\",(u64_t)events[idx].data.u64);\n\n    // assert(fd_manager.exist_info(fd64));\n    // ip_port_t ip_port=fd_manager.get_info(fd64).ip_port;\n\n    // conn_info_t &conn_info=conn_manager.find(ip_port);\n    address_t &addr = conn_info.addr;\n    assert(conn_manager.exist(addr));\n\n    int &local_listen_fd = conn_info.local_listen_fd;\n\n    int out_n = -2;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n\n    dest_t dest;\n    dest.inner.fd_addr.fd = local_listen_fd;\n    dest.inner.fd_addr.addr = addr;\n    dest.type = type_fd_addr;\n    dest.cook = 1;\n\n    if (mode == is_fec_timeout) {\n        assert(fd64 == 0);\n        // uint64_t value;\n        // if((ret=read(fd_manager.to_fd(fd64), &value, 8))!=8)\n        //{\n        //\tmylog(log_trace,\"fd_manager.to_fd(fd64), &value, 8)!=8 ,%d\\n\",ret);\n        //\tcontinue;\n        // }\n        // if(value==0)\n        //{\n        //\tmylog(log_trace,\"value==0\\n\");\n        //\tcontinue;\n        // }\n        // assert(value==1);\n        from_normal_to_fec(conn_info, 0, 0, out_n, out_arr, out_len, out_delay);\n    } else if (mode == is_conn_timer) {\n        assert(fd64 == 0);\n        // uint64_t value;\n        // read(conn_info.timer.get_timer_fd(), &value, 8);\n        conn_info.conv_manager.s.clear_inactive();\n        if (debug_force_flush_fec) {\n            from_normal_to_fec(conn_info, 0, 0, out_n, out_arr, out_len, out_delay);\n        }\n\n        conn_info.stat.report_as_server(addr);\n        return;\n    } else if (mode == is_from_remote) {\n        if (!fd_manager.exist(fd64))  // fd64 has been closed\n        {\n            mylog(log_warn, \"!fd_manager.exist(fd64)\\n\");\n            return;\n        }\n\n        // fd64_t &fd64 =conn_info.remote_fd64;\n        assert(conn_info.conv_manager.s.is_data_used(fd64));\n\n        conv = conn_info.conv_manager.s.find_conv_by_data(fd64);\n        conn_info.conv_manager.s.update_active_time(conv);\n        conn_info.update_active_time();\n\n        int fd = fd_manager.to_fd(fd64);\n        data_len = recv(fd, data, max_data_len + 1, 0);\n\n        if (data_len == max_data_len + 1) {\n            mylog(log_warn, \"huge packet from upper level, data_len > %d, packet truncated, dropped\\n\", max_data_len);\n            return;\n        }\n\n        mylog(log_trace, \"received a packet from udp_fd,len:%d,conv=%d\\n\", data_len, conv);\n\n        if (data_len < 0) {\n            mylog(log_debug, \"udp fd,recv_len<0 continue,%s\\n\", get_sock_error());\n\n            return;\n        }\n\n        if (!disable_mtu_warn && data_len >= mtu_warn) {\n            mylog(log_warn, \"huge packet,data len=%d (>=%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", data_len, mtu_warn);\n        }\n\n        char *new_data;\n        int new_len;\n        put_conv(conv, data, data_len, new_data, new_len);\n\n        from_normal_to_fec(conn_info, new_data, new_len, out_n, out_arr, out_len, out_delay);\n    } else {\n        assert(0 == 1);\n    }\n\n    mylog(log_trace, \"out_n=%d\\n\", out_n);\n    for (int i = 0; i < out_n; i++) {\n        delay_send(out_delay[i], dest, out_arr[i], out_len[i]);\n    }\n}\n\nstatic void local_listen_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    int local_listen_fd = watcher->fd;\n    int ret;\n\n    mylog(log_trace, \"events[idx].data.u64 == (u64_t)local_listen_fd\\n\");\n    char data[buf_len];\n    int data_len;\n    address_t::storage_t udp_new_addr_in = {0};\n    socklen_t udp_new_addr_len = sizeof(address_t::storage_t);\n    if ((data_len = recvfrom(local_listen_fd, data, max_data_len + 1, 0,\n                             (struct sockaddr *)&udp_new_addr_in, &udp_new_addr_len)) == -1) {\n        mylog(log_error, \"recv_from error,this shouldnt happen,err=%s,but we can try to continue\\n\", get_sock_error());\n        return;\n    };\n\n    if (data_len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d, packet truncated, dropped\\n\", max_data_len);\n        return;\n    }\n\n    address_t addr;\n    addr.from_sockaddr((struct sockaddr *)&udp_new_addr_in, udp_new_addr_len);\n\n    mylog(log_trace, \"Received packet from %s,len: %d\\n\", addr.get_str(), data_len);\n\n    if (!disable_mtu_warn && data_len >= mtu_warn)  ///////////////////////delete this for type 0 in furture\n    {\n        mylog(log_warn, \"huge packet,data len=%d (>=%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", data_len, mtu_warn);\n    }\n\n    if (de_cook(data, data_len) != 0) {\n        mylog(log_debug, \"de_cook error\");\n        return;\n    }\n\n    if (!conn_manager.exist(addr)) {\n        if (conn_manager.mp.size() >= max_conn_num) {\n            mylog(log_warn, \"new connection %s ignored bc max_conn_num exceed\\n\", addr.get_str());\n            return;\n        }\n\n        // conn_manager.insert(addr);\n        conn_info_t &conn_info = conn_manager.find_insert(addr);\n        conn_info.addr = addr;\n        conn_info.loop = ev_default_loop(0);\n        conn_info.local_listen_fd = local_listen_fd;\n\n        // u64_t fec_fd64=conn_info.fec_encode_manager.get_timer_fd64();\n        // mylog(log_debug,\"fec_fd64=%llu\\n\",fec_fd64);\n        // ev.events = EPOLLIN;\n        // ev.data.u64 = fec_fd64;\n        // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd_manager.to_fd(fec_fd64), &ev);\n\n        // fd_manager.get_info(fec_fd64).ip_port=ip_port;\n\n        conn_info.timer.data = &conn_info;\n        ev_init(&conn_info.timer, conn_timer_cb);\n        ev_timer_set(&conn_info.timer, 0, timer_interval / 1000.0);\n        ev_timer_start(loop, &conn_info.timer);\n\n        // conn_info.timer.add_fd64_to_epoll(epoll_fd);\n        // conn_info.timer.set_timer_repeat_us(timer_interval*1000);\n\n        // mylog(log_debug,\"conn_info.timer.get_timer_fd64()=%llu\\n\",conn_info.timer.get_timer_fd64());\n\n        // u64_t timer_fd64=conn_info.timer.get_timer_fd64();\n        // fd_manager.get_info(timer_fd64).ip_port=ip_port;\n\n        conn_info.fec_encode_manager.set_data(&conn_info);\n        conn_info.fec_encode_manager.set_loop_and_cb(loop, fec_encode_cb);\n\n        mylog(log_info, \"new connection from %s\\n\", addr.get_str());\n    }\n    conn_info_t &conn_info = conn_manager.find_insert(addr);\n\n    conn_info.update_active_time();\n    int out_n;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n    from_fec_to_normal(conn_info, data, data_len, out_n, out_arr, out_len, out_delay);\n\n    mylog(log_trace, \"out_n= %d\\n\", out_n);\n    for (int i = 0; i < out_n; i++) {\n        u32_t conv;\n        char *new_data;\n        int new_len;\n        if (get_conv(conv, out_arr[i], out_len[i], new_data, new_len) != 0) {\n            mylog(log_debug, \"get_conv failed\");\n            continue;\n        }\n\n        if (!conn_info.conv_manager.s.is_conv_used(conv)) {\n            if (conn_info.conv_manager.s.get_size() >= max_conv_num) {\n                mylog(log_warn, \"ignored new udp connect bc max_conv_num exceed\\n\");\n                continue;\n            }\n\n            int new_udp_fd;\n            ret = new_connected_socket2(new_udp_fd, remote_addr, out_addr, out_interface);\n\n            if (ret != 0) {\n                mylog(log_warn, \"[%s]new_connected_socket failed\\n\", addr.get_str());\n                continue;\n            }\n\n            fd64_t fd64 = fd_manager.create(new_udp_fd);\n            // ev.events = EPOLLIN;\n            // ev.data.u64 = fd64;\n            // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, new_udp_fd, &ev);\n\n            conn_info.conv_manager.s.insert_conv(conv, fd64);\n            fd_manager.get_info(fd64).addr = addr;\n\n            ev_io &io_watcher = fd_manager.get_info(fd64).io_watcher;\n            io_watcher.u64 = fd64;\n            io_watcher.data = &conn_info;\n\n            ev_init(&io_watcher, remote_cb);\n            ev_io_set(&io_watcher, new_udp_fd, EV_READ);\n            ev_io_start(conn_info.loop, &io_watcher);\n\n            mylog(log_info, \"[%s]new conv %x,fd %d created,fd64=%llu\\n\", addr.get_str(), conv, new_udp_fd, fd64);\n        }\n        conn_info.conv_manager.s.update_active_time(conv);\n        fd64_t fd64 = conn_info.conv_manager.s.find_data_by_conv(conv);\n        dest_t dest;\n        dest.type = type_fd64;\n        dest.inner.fd64 = fd64;\n        delay_send(out_delay[i], dest, new_data, new_len);\n    }\n}\n\nstatic void remote_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n    fd64_t fd64 = watcher->u64;\n\n    data_from_remote_or_fec_timeout_or_conn_timer(conn_info, fd64, is_from_remote);\n}\n\nstatic void fifo_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    int fifo_fd = watcher->fd;\n\n    char buf[buf_len];\n    int len = read(fifo_fd, buf, sizeof(buf));\n    if (len < 0) {\n        mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, get_sock_error());\n        return;\n    }\n    buf[len] = 0;\n    handle_command(buf);\n}\n\nstatic void delay_manager_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    // uint64_t value;\n    // read(delay_manager.get_timer_fd(), &value, 8);\n    // mylog(log_trace,\"events[idx].data.u64 == (u64_t)delay_manager.get_timer_fd()\\n\");\n\n    // do nothing\n}\n\nstatic void fec_encode_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    data_from_remote_or_fec_timeout_or_conn_timer(conn_info, 0, is_fec_timeout);\n}\n\nstatic void conn_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    data_from_remote_or_fec_timeout_or_conn_timer(conn_info, 0, is_conn_timer);\n}\n\nstatic void prepare_cb(struct ev_loop *loop, struct ev_prepare *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    delay_manager.check();\n}\n\nstatic void global_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    // uint64_t value;\n    // read(timer.get_timer_fd(), &value, 8);\n    conn_manager.clear_inactive();\n    mylog(log_trace, \"events[idx].data.u64==(u64_t)timer.get_timer_fd()\\n\");\n}\n\nint tunnel_server_event_loop() {\n    int i, j, k;\n    int ret;\n    int yes = 1;\n    // int epoll_fd;\n    // int remote_fd;\n\n    int local_listen_fd;\n    new_listen_socket2(local_listen_fd, local_addr);\n\n    // epoll_fd = epoll_create1(0);\n    // assert(epoll_fd>0);\n\n    // const int max_events = 4096;\n    // struct epoll_event ev, events[max_events];\n    // if (epoll_fd < 0) {\n    //\tmylog(log_fatal,\"epoll return %d\\n\", epoll_fd);\n    //\tmyexit(-1);\n    // }\n\n    struct ev_loop *loop = ev_default_loop(0);\n    assert(loop != NULL);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = local_listen_fd;\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, local_listen_fd, &ev);\n    // if (ret!=0) {\n    //\tmylog(log_fatal,\"add  udp_listen_fd error\\n\");\n    //\tmyexit(-1);\n    // }\n    struct ev_io local_listen_watcher;\n    ev_io_init(&local_listen_watcher, local_listen_cb, local_listen_fd, EV_READ);\n    ev_io_start(loop, &local_listen_watcher);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = delay_manager.get_timer_fd();\n    // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, delay_manager.get_timer_fd(), &ev);\n    // if (ret!= 0) {\n    //\tmylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n    //\tmyexit(-1);\n    // }\n\n    delay_manager.set_loop_and_cb(loop, delay_manager_cb);\n\n    // mylog(log_debug,\" delay_manager.get_timer_fd() =%d\\n\", delay_manager.get_timer_fd());\n\n    mylog(log_info, \"now listening at %s\\n\", local_addr.get_str());\n\n    // my_timer_t timer;\n    // timer.add_fd_to_epoll(epoll_fd);\n    // timer.set_timer_repeat_us(timer_interval*1000);\n\n    ev_timer global_timer;\n    ev_init(&global_timer, global_timer_cb);\n    ev_timer_set(&global_timer, 0, timer_interval / 1000.0);\n    ev_timer_start(loop, &global_timer);\n\n    // mylog(log_debug,\" timer.get_timer_fd() =%d\\n\",timer.get_timer_fd());\n\n    struct ev_io fifo_watcher;\n\n    int fifo_fd = -1;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n        // ev.events = EPOLLIN;\n        // ev.data.u64 = fifo_fd;\n\n        // ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fifo_fd, &ev);\n        // if (ret!= 0) {\n        // mylog(log_fatal,\"add fifo_fd to epoll error %s\\n\",strerror(errno));\n        // myexit(-1);\n        //}\n        ev_io_init(&fifo_watcher, fifo_cb, fifo_fd, EV_READ);\n        ev_io_start(loop, &fifo_watcher);\n\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n    }\n\n    ev_prepare prepare_watcher;\n    ev_init(&prepare_watcher, prepare_cb);\n    ev_prepare_start(loop, &prepare_watcher);\n\n    ev_run(loop, 0);\n\n    mylog(log_warn, \"ev_run returned\\n\");\n    myexit(0);\n\n    /*\n    while(1)////////////////////////\n    {\n\n            if(about_to_exit) myexit(0);\n\n            int nfds = epoll_wait(epoll_fd, events, max_events, 180 * 1000);\n            if (nfds < 0) {  //allow zero\n                    if(errno==EINTR  )\n                    {\n                            mylog(log_info,\"epoll interrupted by signal,continue\\n\");\n                    }\n                    else\n                    {\n                            mylog(log_fatal,\"epoll_wait return %d,%s\\n\", nfds,strerror(errno));\n                            myexit(-1);\n                    }\n            }\n            int idx;\n            for (idx = 0; idx < nfds; ++idx)\n            {\n                    if(events[idx].data.u64==(u64_t)timer.get_timer_fd())\n                    {\n\n                    }\n\n                    else if (events[idx].data.u64 == (u64_t)fifo_fd)\n                    {\n\n                    }\n\n                    else if (events[idx].data.u64 == (u64_t)local_listen_fd)\n                    {\n\n\n                    }\n                else if (events[idx].data.u64 == (u64_t)delay_manager.get_timer_fd()) {\n\n                    }\n                    else if (events[idx].data.u64 >u32_t(-1))\n                    {\n\n\n                    }\n                    else\n                    {\n                            mylog(log_fatal,\"unknown fd,this should never happen\\n\");\n                            myexit(-1);\n                    }\n            }\n\n    }*/\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}