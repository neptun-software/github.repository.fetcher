{
  "metadata": {
    "timestamp": 1736565331709,
    "page": 154,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "OneLoneCoder/olcPixelGameEngine",
      "stars": 3886,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.302734375,
          "content": "ï»¿################################################################################\n# This .gitignore file was automatically created by Microsoft(R) Visual Studio.\n################################################################################\n\n/.vs\n/utilities/olcUTIL_AffineView.h\n/utilities/olcUTIL_Maths.h\n"
        },
        {
          "name": "LICENCE.md",
          "type": "blob",
          "size": 1.541015625,
          "content": "# License (OLC-3)\n\nCopyright 2018-2023 OneLoneCoder.com\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions or derivations of source code must retain the above \n   copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions or derivative works in binary form must reproduce \n   the above copyright notice. This list of conditions and the following \n   disclaimer must be reproduced in the documentation and/or other \n   materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its \n   contributors may be used to endorse or promote products derived \n   from this software without specific prior written permission.\n    \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0458984375,
          "content": "<p align=\"center\">\n  <a href=\"https://discord.gg/WhwHUMV\"> <img src=\"https://img.shields.io/discord/380484403458998276?logo=discord\"> </a>\n</p>\nHang on! I'm looking for Javidx9's video source code! It's moved here: https://github.com/OneLoneCoder/Javidx9\n\n# Shameless Promotion\nThere is a feature rich and working fork of this repo aimed at Android & IOS development: https://github.com/Johnnyg63/OLCPGEMobileVisualStudio\n\n# olcPixelGameEngine\nThe official distribution of olcPixelGameEngine, a tool used in javidx9's YouTube videos and projects.\n\n**You only need the one file - olcPixelGameEngine.h - included in your project!**\n\nProvides a fast, richly featured, cross platform pixel drawing and user interface framework for\n * The development of games\n * Visualisation of algorithms\n * Prototyping and experimentation\n * Education\n\nolcPixelGameEngine is easily extended! for example:\n * 2D Affine transforms\n * 3D Software renderer\n * Controller input\n * Sound\n * Hardware interfaces\n \nolcPixelGameEngine is easy to port! Runs on:\n * Windows (all)\n * Linux / Raspberry Pi / ChromeOS\n * MacOS (coming soon to official, but already available in \"Contributors\")\n * PSP & Switch (Not supported by OneLoneCoder)\n \nolcPixelGameEngine has been reimplemented in other languages!\n * C#\n * Rust\n * Lua\n * Java\n  \nolcPixelGameEngine is actively maintained and developed!\n\nolcPixelGameEngine is used by 100s, if not 1000s of programmers at all levels of ability!\n\n\n# Documentation\nPlease see https://github.com/OneLoneCoder/olcPixelGameEngine/wiki\n\n# License (OLC-3)\nCopyright 2018 - 2024 OneLoneCoder.com\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions or derivations of source code must retain the above \n   copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions or derivative works in binary form must reproduce \n   the above copyright notice. This list of conditions and the following \n   disclaimer must be reproduced in the documentation and/or other \n   materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its \n   contributors may be used to endorse or promote products derived \n   from this software without specific prior written permission.\n    \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "contributions",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "olcExampleProgram.cpp",
          "type": "blob",
          "size": 0.607421875,
          "content": "#define OLC_PGE_APPLICATION\n#include \"olcPixelGameEngine.h\"\n\nclass Example : public olc::PixelGameEngine\n{\npublic:\n\tExample()\n\t{\n\t\tsAppName = \"Example\";\n\t}\n\npublic:\n\tbool OnUserCreate() override\n\t{\n\t\t// Called once at the start, so create things here\n\t\treturn true;\n\t}\n\n\tbool OnUserUpdate(float fElapsedTime) override\n\t{\n\t\t// called once per frame\n\t\tfor (int x = 0; x < ScreenWidth(); x++)\n\t\t\tfor (int y = 0; y < ScreenHeight(); y++)\n\t\t\t\tDraw(x, y, olc::Pixel(rand() % 255, rand() % 255, rand()% 255));\t\n\t\treturn true;\n\t}\n};\n\n\nint main()\n{\n\tExample demo;\n\tif (demo.Construct(256, 240, 4, 4))\n\t\tdemo.Start();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "olcPixelGameEngine.h",
          "type": "blob",
          "size": 256.9345703125,
          "content": "#pragma region license_and_help\r\n/*\r\n\tolcPixelGameEngine.h\r\n\r\n\t+-------------------------------------------------------------+\r\n\t|           OneLoneCoder Pixel Game Engine v2.28              |\r\n\t|  \"What do you need? Pixels... Lots of Pixels...\" - javidx9  |\r\n\t+-------------------------------------------------------------+\r\n\r\n\tWhat is this?\r\n\t~~~~~~~~~~~~~\r\n\tolc::PixelGameEngine is a single file, cross platform graphics and userinput\r\n\tframework used for games, visualisations, algorithm exploration and learning.\r\n\tIt was developed by YouTuber \"javidx9\" as an assistive tool for many of his\r\n\tvideos. The goal of this project is to provide high speed graphics with\r\n\tminimal project setup complexity, to encourage new programmers, younger people,\r\n\tand anyone else that wants to make fun things.\r\n\r\n\tHowever, olc::PixelGameEngine is not a toy! It is a powerful and fast utility\r\n\tcapable of delivering high resolution, high speed, high quality applications\r\n\twhich behave the same way regardless of the operating system or platform.\r\n\r\n\tThis file provides the core utility set of the olc::PixelGameEngine, including\r\n\twindow creation, keyboard/mouse input, main game thread, timing, pixel drawing\r\n\troutines, image/sprite loading and drawing routines, and a bunch of utility\r\n\ttypes to make rapid development of games/visualisations possible.\r\n\r\n\r\n\tLicense (OLC-3)\r\n\t~~~~~~~~~~~~~~~\r\n\r\n\tCopyright 2018 - 2024 OneLoneCoder.com\r\n\r\n\tRedistribution and use in source and binary forms, with or without modification,\r\n\tare permitted provided that the following conditions are met:\r\n\r\n\t1. Redistributions or derivations of source code must retain the above copyright\r\n\tnotice, this list of conditions and the following disclaimer.\r\n\r\n\t2. Redistributions or derivative works in binary form must reproduce the above\r\n\tcopyright notice. This list of conditions and the following\tdisclaimer must be\r\n\treproduced in the documentation and/or other materials provided with the distribution.\r\n\r\n\t3. Neither the name of the copyright holder nor the names of its contributors may\r\n\tbe used to endorse or promote products derived from this software without specific\r\n\tprior written permission.\r\n\r\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\t\"AS IS\" AND ANY\r\n\tEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n\tOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\r\n\tSHALL THE COPYRIGHT\tHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n\tINCIDENTAL,\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\r\n\tTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\n\tBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n\tCONTRACT, STRICT LIABILITY, OR TORT\t(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n\tANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n\tSUCH DAMAGE.\r\n\r\n\tLinks\r\n\t~~~~~\r\n\tYouTube:\thttps://www.youtube.com/javidx9\r\n\t\t\t\thttps://www.youtube.com/javidx9extra\r\n\tDiscord:\thttps://discord.gg/WhwHUMV\r\n\tTwitter:\thttps://www.twitter.com/javidx9\r\n\tTwitch:\t\thttps://www.twitch.tv/javidx9\r\n\tGitHub:\t\thttps://www.github.com/onelonecoder\r\n\tHomepage:\thttps://www.onelonecoder.com\r\n\tPatreon:\thttps://www.patreon.com/javidx9\r\n\tCommunity:  https://community.onelonecoder.com\r\n\r\n\r\n\r\n\tCompiling in Linux\r\n\t~~~~~~~~~~~~~~~~~~\r\n\tYou will need a modern C++ compiler, so update yours!\r\n\tTo compile use the command:\r\n\r\n\tg++ -o YourProgName YourSource.cpp -lX11 -lGL -lpthread -lpng -lstdc++fs -std=c++17\r\n\r\n\tOn some Linux configurations, the frame rate is locked to the refresh\r\n\trate of the monitor. This engine tries to unlock it but may not be\r\n\table to, in which case try launching your program like this:\r\n\r\n\tvblank_mode=0 ./YourProgName\r\n\r\n\r\n\r\n\tCompiling in Code::Blocks on Windows\r\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\tWell I wont judge you, but make sure your Code::Blocks installation\r\n\tis really up to date - you may even consider updating your C++ toolchain\r\n\tto use MinGW32-W64.\r\n\r\n\tGuide for installing recent GCC for Windows:\r\n\thttps://www.msys2.org/\r\n\tGuide for configuring code::blocks:\r\n\thttps://solarianprogrammer.com/2019/11/05/install-gcc-windows/\r\n\thttps://solarianprogrammer.com/2019/11/16/install-codeblocks-gcc-windows-build-c-cpp-fortran-programs/\r\n\r\n\tAdd these libraries to \"Linker Options\":\r\n\tuser32 gdi32 opengl32 gdiplus Shlwapi dwmapi stdc++fs\r\n\r\n\tSet these compiler options: -std=c++17\r\n\r\n\r\n\r\n\tCompiling on Mac - EXPERIMENTAL! PROBABLY HAS BUGS\r\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\tYes yes, people use Macs for C++ programming! Who knew? Anyway, enough\r\n\targuing, thanks to Mumflr the PGE is now supported on Mac. Now I know nothing\r\n\tabout Mac, so if you need support, I suggest checking out the instructions\r\n\there: https://github.com/MumflrFumperdink/olcPGEMac\r\n\r\n\tclang++ -arch x86_64 -std=c++17 -mmacosx-version-min=10.15 -Wall -framework OpenGL \r\n\t\t-framework GLUT -framework Carbon -lpng YourSource.cpp -o YourProgName\r\n\r\n\r\n\r\n\tCompiling with Emscripten (New & Experimental)\r\n\t~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\tEmscripten compiler will turn your awesome C++ PixelGameEngine project into WASM!\r\n\tThis means you can run your application in teh browser, great for distributing\r\n\tand submission in to jams and things! It's a bit new at the moment. \r\n\r\n\tem++ -std=c++17 -O2 -s ALLOW_MEMORY_GROWTH=1 -s MAX_WEBGL_VERSION=2 -s MIN_WEBGL_VERSION=2 -s USE_LIBPNG=1 ./YourSource.cpp -o pge.html\r\n\r\n\r\n\r\n\tUsing stb_image.h\r\n\t~~~~~~~~~~~~~~~~~\r\n\tThe PGE will load png images by default (with help from libpng on non-windows systems).\r\n\tHowever, the excellent \"stb_image.h\" can be used instead, supporting a variety of\r\n\timage formats, and has no library dependence - something we like at OLC studios ;)\r\n\tTo use stb_image.h, make sure it's in your code base, and simply:\r\n\r\n\t#define OLC_IMAGE_STB\r\n\r\n\tBefore including the olcPixelGameEngine.h header file. stb_image.h works on many systems\r\n\tand can be downloaded here: https://github.com/nothings/stb/blob/master/stb_image.h\r\n\r\n\r\n\r\n\tMultiple cpp file projects?\r\n\t~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\tAs a single header solution, the OLC_PGE_APPLICATION definition is used to\r\n\tinsert the engine implementation at a project location of your choosing.\r\n\tThe simplest way to setup multifile projects is to create a file called\r\n\t\"olcPixelGameEngine.cpp\" which includes the following:\r\n\r\n\t#define OLC_PGE_APPLICATION\r\n\t#include \"olcPixelGameEngine.h\"\r\n\r\n\tThat's all it should include. You can also include PGEX includes and \r\n\tdefines in here too. With this in place, you dont need to \r\n\t#define OLC_PGE_APPLICATION anywhere, and can simply include this \r\n\theader file as an when you need to.\r\n\r\n\r\n\r\n\tPorts\r\n\t~~~~~\r\n\tolc::PixelGameEngine has been ported and tested with varying degrees of\r\n\tsuccess to: WinXP, Win7, Win8, Win10, Various Linux, Raspberry Pi,\r\n\tChromebook, Playstation Portable (PSP) and Nintendo Switch. If you are\r\n\tinterested in the details of these ports, come and visit the Discord!\r\n\r\n\r\n\r\n\tThanks\r\n\t~~~~~~\r\n\tI'd like to extend thanks to Ian McKay, Bispoo, Eremiell, slavka, Kwizatz77, gurkanctn, Phantim,\r\n\tIProgramInCPP, JackOJC, KrossX, Huhlig, Dragoneye, Appa, JustinRichardsMusic, SliceNDice, \r\n\tdandistine,\tRalakus, Gorbit99, raoul, joshinils, benedani, Moros1138, Alexio, SaladinAkara \r\n\t& MagetzUb for advice, ideas and testing, and I'd like to extend my appreciation to the\r\n\t250K YouTube followers,\t80+ Patreons, 4.8K Twitch followers and 10K Discord server members \r\n\twho give me\tthe motivation to keep going with all this :D\r\n\r\n\tSignificant Contributors: @Moros1138, @SaladinAkara, @MaGetzUb, @slavka,\r\n\t\t\t\t\t\t\t  @Dragoneye, @Gorbit99, @dandistine & @Mumflr\r\n\r\n\tSpecial thanks to those who bring gifts!\r\n\tGnarGnarHead.......Domina\r\n\tGorbit99...........Bastion, Ori & The Blind Forest, Terraria, Spelunky 2, Skully\r\n\tMarti Morta........Gris\r\n\tDanicron...........Terraria\r\n\tSaladinAkara.......Aseprite, Inside, Quern: Undying Thoughts, Outer Wilds\r\n\tAlterEgo...........Final Fantasy XII - The Zodiac Age\r\n\tSlicEnDicE.........Noita, Inside\r\n\tTGD................Voucher Gift\r\n\tDragoneye..........Lucas Arts Adventure Game Pack\r\n\tAnonymous Pirate...Return To Monkey Island\r\n\r\n\tSpecial thanks to my Patreons too - I wont name you on here, but I've\r\n\tcertainly enjoyed my tea and flapjacks :D\r\n\r\n\t- In Memory of SaladinAkara 25.06.2023 -\r\n\r\n\tAuthor\r\n\t~~~~~~\r\n\tDavid Barr, aka javidx9, (c) OneLoneCoder 2018, 2019, 2020, 2021, 2022, 2023, 2024\r\n*/\r\n#pragma endregion\r\n\r\n#pragma region version_history\r\n/*\r\n\t2.01: Made renderer and platform static for multifile projects\r\n\t2.02: Added Decal destructor, optimised Pixel constructor\r\n\t2.03: Added FreeBSD flags, Added DrawStringDecal()\r\n\t2.04: Windows Full-Screen bug fixed\r\n\t2.05: +DrawPartialWarpedDecal() - draws a warped decal from a subset image\r\n\t\t  +DrawPartialRotatedDecal() - draws a rotated decal from a subset image\r\n\t2.06: +GetTextSize() - returns area occupied by multiline string\r\n\t\t  +GetWindowSize() - returns actual window size\r\n\t\t  +GetElapsedTime() - returns last calculated fElapsedTime\r\n\t\t  +GetWindowMouse() - returns actual mouse location in window\r\n\t\t  +DrawExplicitDecal() - bow-chikka-bow-bow\r\n\t\t  +DrawPartialDecal(pos, size) - draws a partial decal to specified area\r\n\t\t  +FillRectDecal() - draws a flat shaded rectangle as a decal\r\n\t\t  +GradientFillRectDecal() - draws a rectangle, with unique colour corners\r\n\t\t  +Modified DrawCircle() & FillCircle() - Thanks IanM-Matrix1 (#PR121)\r\n\t\t  +Gone someway to appeasing pedants\r\n\t2.07: +GetPixelSize() - returns user specified pixel size\r\n\t\t  +GetScreenPixelSize() - returns actual size in monitor pixels\r\n\t\t  +Pixel Cohesion Mode (flag in Construct()) - disallows arbitrary window scaling\r\n\t\t  +Working VSYNC in Windows windowed application - now much smoother\r\n\t\t  +Added string conversion for olc::vectors\r\n\t\t  +Added comparator operators for olc::vectors\r\n\t\t  +Added DestroyWindow() on windows platforms for serial PGE launches\r\n\t\t  +Added GetMousePos() to stop TarriestPython whinging\r\n\t2.08: Fix SetScreenSize() aspect ratio pre-calculation\r\n\t\t  Fix DrawExplicitDecal() - stupid oversight with multiple decals\r\n\t\t  Disabled olc::Sprite copy constructor\r\n\t\t  +olc::Sprite Duplicate() - produces a new clone of the sprite\r\n\t\t  +olc::Sprite Duplicate(pos, size) - produces a new sprite from the region defined\r\n\t\t  +Unary operators for vectors\r\n\t\t  +More pedant mollification - Thanks TheLandfill\r\n\t\t  +ImageLoader modules - user selectable image handling core, gdi+, libpng, stb_image\r\n\t\t  +Mac Support via GLUT - thanks Mumflr!\r\n\t2.09: Fix olc::Renderable Image load error - Thanks MaGetzUb & Zij-IT for finding and moaning about it\r\n\t\t  Fix file rejection in image loaders when using resource packs\r\n\t\t  Tidied Compiler defines per platform - Thanks slavka\r\n\t\t  +Pedant fixes, const correctness in parts\r\n\t\t  +DecalModes - Normal, Additive, Multiplicative blend modes\r\n\t\t  +Pixel Operators & Lerping\r\n\t\t  +Filtered Decals - If you hate pixels, then erase this file\r\n\t\t  +DrawStringProp(), GetTextSizeProp(), DrawStringPropDecal() - Draws non-monospaced font\r\n\t2.10: Fix PixelLerp() - oops my bad, lerped the wrong way :P\r\n\t\t  Fix \"Shader\" support for strings - thanks Megarev for crying about it\r\n\t\t  Fix GetTextSizeProp() - Height was just plain wrong...\r\n\t\t  +vec2d operator overloads (element wise *=, /=)\r\n\t\t  +vec2d comparison operators... :| yup... hmmmm...\r\n\t\t  +vec2d ceil(), floor(), min(), max() functions - surprising how often I do it manually\r\n\t\t  +DrawExplicitDecal(... uint32_t elements) - complete control over convex polygons and lines\r\n\t\t  +DrawPolygonDecal() - to keep Bispoo happy, required significant rewrite of EVERYTHING, but hey ho\r\n\t\t  +Complete rewrite of decal renderer\r\n\t\t  +OpenGL 3.3 Renderer (also supports Raspberry Pi)\r\n\t\t  +PGEX Break-In Hooks - with a push from Dandistine\r\n\t\t  +Wireframe Decal Mode - For debug overlays\r\n\t2.11: Made PGEX hooks optional - (provide true to super constructor)\r\n\t2.12: Fix for MinGW compiler non-compliance :( - why is its sdk structure different?? why???\r\n\t2.13: +GetFontSprite() - allows access to font data\t \r\n\t2.14: Fix WIN32 Definition reshuffle\r\n\t\t  Fix DrawPartialDecal() - messed up dimension during renderer experiment, didnt remove junk code, thanks Alexio\r\n\t\t  Fix? Strange error regarding GDI+ Image Loader not knowing about COM, SDK change?\r\n\t2.15: Big Reformat\r\n\t\t  +WASM Platform (via Emscripten) - Big Thanks to OLC Community - See Platform for details\t\t  \r\n\t\t  +Sample Mode for Decals\r\n\t\t  +Made olc_ConfigureSystem() accessible\r\n\t\t  +Added OLC_----_CUSTOM_EX for externalised platforms, renderers and image loaders\r\n\t\t  =Refactored olc::Sprite pixel data store\r\n\t\t  -Deprecating LoadFromPGESprFile()\r\n\t\t  -Deprecating SaveToPGESprFile()\r\n\t\t  Fix Pixel -= operator (thanks Au Lit)\r\n\t2.16: FIX Emscripten JS formatting in VS IDE (thanks Moros)\r\n\t\t  +\"Headless\" Mode\r\n\t\t  +DrawLineDecal()\r\n\t\t  +Mouse Button Constants\r\n\t\t  +Move Constructor for olc::Renderable\r\n\t\t  +Polar/Cartesian conversion for v2d_generic\r\n\t\t  +DrawRotatedStringDecal()/DrawRotatedStringPropDecal() (thanks Oso-Grande/Sopadeoso (PR #209))\r\n\t\t  =Using olc::Renderable for layer surface\r\n\t\t  +Major Mac and GLUT Update (thanks Mumflr)\r\n\t2.17: +Clipping for DrawLine() functions\r\n\t\t  +Reintroduced sub-pixel decals\r\n\t\t  +Modified DrawPartialDecal() to quantise and correctly sample from tile atlasses\r\n\t\t  +olc::Sprite::GetPixel() - Clamp Mode\r\n\t2.18: +Option to not \"dirty\" layers with SetDrawTarget() - Thanks TerasKasi!\r\n\t\t  =Detection for Mac M1, fix for scroll wheel interrogation - Thanks ruarq!\r\n\t2.19: Textual Input(of)course Edition!\r\n\t      =Built in font is now olc::Renderable\r\n\t\t  +EnablePixelTransfer() - Gate if layer content transfers occur (speedup in decal only apps)\r\n\t\t  +TextEntryEnable() - Enables/Disables text entry mode\r\n\t\t  +TextEntryGetString() - Gets the current accumulated string in text entry mode\r\n\t\t  +TextEntryGetCursor() - Gets the current cursor position in text entry mode\r\n\t\t  +IsTextEntryEnabled() - Returns true if text entry mode is activated\r\n\t\t  +OnTextEntryComplete() - Override is called when user presses \"ENTER\" in text entry mode\r\n\t\t  +Potential for regional keyboard mappings - needs volunteers to do this\r\n\t\t  +ConsoleShow() - Opens built in command console\r\n\t\t  +ConsoleClear() - Clears built in command console output\r\n\t\t  +ConsoleOut() - Stream strings to command console output\r\n\t\t  +ConsoleCaptureStdOut() - Capture std::cout by redirecting to built-in console\r\n\t\t  +OnConsoleCommand() - Override is called when command is entered into built in console\r\n\t2.20: +DrawRectDecal() - Keeps OneSketchyGuy quiet\r\n\t      +GetScreenSize()\r\n\t\t  +olc::Sprite::Size() - returns size of sprite in vector format\r\n\t2.21: Emscripten Overhaul - Thanks Moros!\r\n\t\t  +DrawPolygonDecal() tint overload, can now tint a polygon accounting for vertex colours\r\n\t\t  +Multiplicative Pixel overload\r\n\t\t  +v2d_generic clamp()\r\n\t\t  +v2d_generic lerp()\r\n\t\t  +GetDroppedFiles() - returns files dropped onto engine window for that frame (MSW only)\r\n\t\t  +GetDroppedFilesPoint() - returns location of dropped files (MSW only)\r\n\t\t  +Exposed OpenGL33 Loader interface so the typedefs can be shared with PGEX & user\r\n\t\t  +Fix OGL33 DecalStructure types - wow, how did that one get missed?? lol\r\n\t\t  +FillTexturedTriangle() - Software rasterizes a textured, coloured, triangle\r\n\t\t  +FillTexturedPolygon() - Hijacks DecalStructure for configuration\r\n\t\t  +olc::vf2d arguments for Sprite::Sample() functions\r\n\t2.22: = Fix typo on dragged file buffers for unicode builds\r\n\t2.23: Fixed Emscripten host sizing errors - Thanks Moros\r\n\t\t  Fixed v2d_generic.clamp() function\r\n\t2.24: Fix FillTexturedTriangle() to remove const-ref\r\n\t2.25: +DrawPolygonDecal(pos, tex, w, col)\r\n\t2.26: Window Manipulation Update! (MS Windows only right now... need volunteers!)\r\n\t\t  +1:1 \"Real Window\" mode which follows resizing - Construct(...)\r\n\t\t  +SetWindowSize() - Sets Position/Size of window\r\n\t\t  +ShowWindowFrame() - Enables/Disables window furniture\r\n\t\t  +olc_UpdateWindowPos() - Break in to set position of window\r\n\t\t  +adv_ManualRenderEnable() - [ADVANCED] To be PGE or not be PGE...\r\n\t\t  +adv_HardwareClip() - [ADVANCED] Specify target clip region\r\n\t\t  +adv_FlushLayer() - [ADVANCED] Force layer update to buffer\r\n\t\t  +adv_FlushLayerDecals() - [ADVANCED] Force layer's decal render to buffer\r\n\t\t  +FillTriangleDecal() - Draws a triangle decal\r\n\t\t  +GradientTriangleDecal() - Draws a triangle decal with unique vertex colours\r\n\t2.27: Restructuring of connected files (post-jam clean up)\r\n\t\t  +Guarding olc::v_2d with less faff\r\n\t\t  +Updated olcUTIL_Geometry2D.h\r\n\t\t  +Updated olcUTIL_QuadTree.h\r\n\t\t  +Updated olcUTIL_Animate2D.h\r\n\t\t  +Updated olcUTIL_SplashScreen.h\r\n\t\t  +File Resolution for PGEtinker.com\r\n\t2.28: Brought olc::v_2d inline with other sources\r\n\t\t  \r\n    !! Apple Platforms will not see these updates immediately - Sorry, I dont have a mac to test... !!\r\n\t!!   Volunteers willing to help appreciated, though PRs are manually integrated with credit     !!\r\n*/\r\n#pragma endregion\r\n\r\n#pragma region hello_world_example\r\n// O------------------------------------------------------------------------------O\r\n// | Example \"Hello World\" Program (main.cpp)                                     |\r\n// O------------------------------------------------------------------------------O\r\n/*\r\n\r\n#define OLC_PGE_APPLICATION\r\n#include \"olcPixelGameEngine.h\"\r\n\r\n// Override base class with your custom functionality\r\nclass Example : public olc::PixelGameEngine\r\n{\r\npublic:\r\n\tExample()\r\n\t{\r\n\t\t// Name your application\r\n\t\tsAppName = \"Example\";\r\n\t}\r\n\r\npublic:\r\n\tbool OnUserCreate() override\r\n\t{\r\n\t\t// Called once at the start, so create things here\r\n\t\treturn true;\r\n\t}\r\n\r\n\tbool OnUserUpdate(float fElapsedTime) override\r\n\t{\r\n\t\t// Called once per frame, draws random coloured pixels\r\n\t\tfor (int x = 0; x < ScreenWidth(); x++)\r\n\t\t\tfor (int y = 0; y < ScreenHeight(); y++)\r\n\t\t\t\tDraw(x, y, olc::Pixel(rand() % 256, rand() % 256, rand() % 256));\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tExample demo;\r\n\tif (demo.Construct(256, 240, 4, 4))\r\n\t\tdemo.Start();\r\n\treturn 0;\r\n}\r\n\r\n*/\r\n#pragma endregion\r\n\r\n#ifndef OLC_PGE_DEF\r\n#define OLC_PGE_DEF\r\n\r\n#pragma region std_includes\r\n// O------------------------------------------------------------------------------O\r\n// | STANDARD INCLUDES                                                            |\r\n// O------------------------------------------------------------------------------O\r\n#include <cmath>\r\n#include <cstdint>\r\n#include <string>\r\n#include <iostream>\r\n#include <streambuf>\r\n#include <sstream>\r\n#include <chrono>\r\n#include <vector>\r\n#include <list>\r\n#include <thread>\r\n#include <atomic>\r\n#include <fstream>\r\n#include <map>\r\n#include <functional>\r\n#include <algorithm>\r\n#include <array>\r\n#include <cstring>\r\n#pragma endregion\r\n\r\n#define PGE_VER 228\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | COMPILER CONFIGURATION ODDITIES                                              |\r\n// O------------------------------------------------------------------------------O\r\n#pragma region compiler_config\r\n#define USE_EXPERIMENTAL_FS\r\n#if defined(_WIN32)\r\n\t#if _MSC_VER >= 1920 && _MSVC_LANG >= 201703L\r\n\t\t#undef USE_EXPERIMENTAL_FS\r\n\t#endif\r\n#endif\r\n#if defined(__linux__) || defined(__MINGW32__) || defined(__EMSCRIPTEN__) || defined(__FreeBSD__) || defined(__APPLE__)\r\n\t#if __cplusplus >= 201703L\r\n\t\t#undef USE_EXPERIMENTAL_FS\r\n\t#endif\r\n#endif\r\n\r\n#if !defined(OLC_KEYBOARD_UK)\r\n\t#define OLC_KEYBOARD_UK\r\n#endif\r\n\r\n\r\n#if defined(USE_EXPERIMENTAL_FS) || defined(FORCE_EXPERIMENTAL_FS)\r\n\t// C++14\r\n\t#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING\r\n\t#include <experimental/filesystem>\r\n\tnamespace _gfs = std::experimental::filesystem::v1;\r\n#else\r\n\t// C++17\r\n\t#include <filesystem>\r\n\tnamespace _gfs = std::filesystem;\r\n#endif\r\n\r\n#if defined(UNICODE) || defined(_UNICODE)\r\n\t#define olcT(s) L##s\r\n#else\r\n\t#define olcT(s) s\r\n#endif\r\n\r\n#define UNUSED(x) (void)(x)\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | PLATFORM SELECTION CODE, Thanks slavka!                                      |\r\n// O------------------------------------------------------------------------------O\r\n\r\n#if defined(OLC_PGE_HEADLESS)\r\n\t#define OLC_PLATFORM_HEADLESS\r\n\t#define OLC_GFX_HEADLESS\r\n\t#if !defined(OLC_IMAGE_STB) && !defined(OLC_IMAGE_GDI) && !defined(OLC_IMAGE_LIBPNG)\r\n\t\t#define OLC_IMAGE_HEADLESS\r\n\t#endif\r\n#endif\r\n\r\n// Platform\r\n#if !defined(OLC_PLATFORM_WINAPI) && !defined(OLC_PLATFORM_X11) && !defined(OLC_PLATFORM_GLUT) && !defined(OLC_PLATFORM_EMSCRIPTEN) && !defined(OLC_PLATFORM_HEADLESS)\r\n\t#if !defined(OLC_PLATFORM_CUSTOM_EX)\r\n\t\t#if defined(_WIN32)\r\n\t\t\t#define OLC_PLATFORM_WINAPI\r\n\t\t#endif\r\n\t\t#if defined(__linux__) || defined(__FreeBSD__)\r\n\t\t\t#define OLC_PLATFORM_X11\r\n\t\t#endif\r\n\t\t#if defined(__APPLE__)\r\n\t\t\t#define GL_SILENCE_DEPRECATION\r\n\t\t\t#define OLC_PLATFORM_GLUT\r\n\t\t#endif\r\n\t\t#if defined(__EMSCRIPTEN__)\r\n\t\t\t#define OLC_PLATFORM_EMSCRIPTEN\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n// Start Situation\r\n#if defined(OLC_PLATFORM_GLUT) || defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t#define PGE_USE_CUSTOM_START\r\n#endif\r\n\r\n\r\n\r\n// Renderer\r\n#if !defined(OLC_GFX_OPENGL10) && !defined(OLC_GFX_OPENGL33) && !defined(OLC_GFX_DIRECTX10) && !defined(OLC_GFX_HEADLESS)\r\n\t#if !defined(OLC_GFX_CUSTOM_EX)\r\n\t\t#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\t#define OLC_GFX_OPENGL33\r\n\t\t#else\r\n\t\t\t#define OLC_GFX_OPENGL10\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n// Image loader\r\n#if !defined(OLC_IMAGE_STB) && !defined(OLC_IMAGE_GDI) && !defined(OLC_IMAGE_LIBPNG) && !defined(OLC_IMAGE_HEADLESS)\r\n\t#if !defined(OLC_IMAGE_CUSTOM_EX)\r\n\t\t#if defined(_WIN32)\r\n\t\t\t#define\tOLC_IMAGE_GDI\r\n\t\t#endif\r\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__)\r\n\t\t\t#define\tOLC_IMAGE_LIBPNG\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n// File resolver for runtime FS access of emscripten builds\r\n#if defined(__EMSCRIPTEN__)\r\n#include <emscripten.h>\r\n#define FILE_RESOLVE(url, file) emscripten_wget(url, file); emscripten_sleep(0)\r\n#else\r\n#define FILE_RESOLVE(url, file)\r\n#endif\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | PLATFORM-SPECIFIC DEPENDENCIES                                               |\r\n// O------------------------------------------------------------------------------O\r\n#if !defined(OLC_PGE_HEADLESS)\r\n#if defined(OLC_PLATFORM_WINAPI)\t\r\n\t#define _WINSOCKAPI_ // Thanks Cornchipss\r\n\t\t#if !defined(VC_EXTRALEAN)\r\n\t\t#define VC_EXTRALEAN\r\n\t#endif\r\n\t#if !defined(NOMINMAX)\r\n\t\t#define NOMINMAX\r\n\t#endif\r\n\r\n\t// In Code::Blocks\r\n\t#if !defined(_WIN32_WINNT)\r\n\t\t#ifdef HAVE_MSMF\r\n\t\t\t#define _WIN32_WINNT 0x0600 // Windows Vista\r\n\t\t#else\r\n\t\t\t#define _WIN32_WINNT 0x0500 // Windows 2000\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#include <windows.h>\r\n\t#undef _WINSOCKAPI_\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\tnamespace X11\r\n\t{\r\n\t\t#include <X11/X.h>\r\n\t\t#include <X11/Xlib.h>\r\n\t}\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t#if defined(__linux__)\r\n\t\t#include <GL/glut.h>\r\n\t\t#include <GL/freeglut_ext.h>\r\n\t#endif\r\n\t#if defined(__APPLE__)\r\n\t\t#include <GLUT/glut.h>\r\n\t#include <objc/message.h>\r\n\t#include <objc/NSObjCRuntime.h>\r\n\t#endif\r\n#endif\r\n#endif\r\n\r\n#if defined(OLC_PGE_HEADLESS)\r\n#if defined max\r\n#undef max\r\n#endif\r\n#if defined min\r\n#undef min\r\n#endif\r\n#endif\r\n#pragma endregion\r\n\r\n\r\n\r\n#if !defined(OLC_VECTOR2D_DEFINED)\r\n\tnamespace olc\r\n\t{\r\n\t\t/*\r\n\t\t\tA complete 2D geometric vector structure, with a variety\r\n\t\t\tof useful utility functions and operator overloads\r\n\t\t*/\r\n\t\ttemplate<class T>\r\n\t\tstruct v_2d\r\n\t\t{\r\n\t\t\tstatic_assert(std::is_arithmetic<T>::value, \"olc::v_2d<type> must be numeric\");\r\n\r\n\t\t\t// x-axis component\r\n\t\t\tT x = 0;\r\n\t\t\t// y-axis component\r\n\t\t\tT y = 0;\r\n\r\n\t\t\t// Default constructor\r\n\t\t\tinline constexpr v_2d() = default;\r\n\r\n\t\t\t// Specific constructor\r\n\t\t\tinline constexpr v_2d(T _x, T _y) : x(_x), y(_y)\r\n\t\t\t{}\r\n\r\n\t\t\t// Copy constructor\r\n\t\t\tinline constexpr v_2d(const v_2d& v) = default;\r\n\r\n\t\t\t// Assignment operator\r\n\t\t\tinline constexpr v_2d& operator=(const v_2d& v) = default;\r\n\r\n\r\n\t\t\t// Returns rectangular area of vector\r\n\t\t\tinline constexpr auto area() const\r\n\t\t\t{\r\n\t\t\t\treturn x * y;\r\n\t\t\t}\r\n\r\n\t\t\t// Returns magnitude of vector\r\n\t\t\tinline auto mag() const\r\n\t\t\t{\r\n\t\t\t\treturn std::sqrt(x * x + y * y);\r\n\t\t\t}\r\n\r\n\t\t\t// Returns magnitude squared of vector (useful for fast comparisons)\r\n\t\t\tinline constexpr T mag2() const\r\n\t\t\t{\r\n\t\t\t\treturn x * x + y * y;\r\n\t\t\t}\r\n\r\n\t\t\t// Returns normalised version of vector\r\n\t\t\tinline v_2d norm() const\r\n\t\t\t{\r\n\t\t\t\tauto r = 1 / mag();\r\n\t\t\t\treturn v_2d(x * r, y * r);\r\n\t\t\t}\r\n\r\n\t\t\t// Returns vector at 90 degrees to this one\r\n\t\t\tinline constexpr v_2d perp() const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(-y, x);\r\n\t\t\t}\r\n\r\n\t\t\t// Rounds both components down\r\n\t\t\tinline constexpr v_2d floor() const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(std::floor(x), std::floor(y));\r\n\t\t\t}\r\n\r\n\t\t\t// Rounds both components up\r\n\t\t\tinline constexpr v_2d ceil() const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(std::ceil(x), std::ceil(y));\r\n\t\t\t}\r\n\r\n\t\t\t// Returns 'element-wise' max of this and another vector\r\n\t\t\tinline constexpr v_2d max(const v_2d& v) const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(std::max(x, v.x), std::max(y, v.y));\r\n\t\t\t}\r\n\r\n\t\t\t// Returns 'element-wise' min of this and another vector\r\n\t\t\tinline constexpr v_2d min(const v_2d& v) const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(std::min(x, v.x), std::min(y, v.y));\r\n\t\t\t}\r\n\r\n\t\t\t// Calculates scalar dot product between this and another vector\r\n\t\t\tinline constexpr auto dot(const v_2d& rhs) const\r\n\t\t\t{\r\n\t\t\t\treturn this->x * rhs.x + this->y * rhs.y;\r\n\t\t\t}\r\n\r\n\t\t\t// Calculates 'scalar' cross product between this and another vector (useful for winding orders)\r\n\t\t\tinline constexpr auto cross(const v_2d& rhs) const\r\n\t\t\t{\r\n\t\t\t\treturn this->x * rhs.y - this->y * rhs.x;\r\n\t\t\t}\r\n\r\n\t\t\t// Treat this as polar coordinate (R, Theta), return cartesian equivalent (X, Y)\r\n\t\t\tinline constexpr v_2d cart() const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(std::cos(y) * x, std::sin(y) * x);\r\n\t\t\t}\r\n\r\n\t\t\t// Treat this as cartesian coordinate (X, Y), return polar equivalent (R, Theta)\r\n\t\t\tinline constexpr v_2d polar() const\r\n\t\t\t{\r\n\t\t\t\treturn v_2d(mag(), std::atan2(y, x));\r\n\t\t\t}\r\n\r\n\t\t\t// Clamp the components of this vector in between the 'element-wise' minimum and maximum of 2 other vectors\r\n\t\t\tinline constexpr v_2d clamp(const v_2d& v1, const v_2d& v2) const\r\n\t\t\t{\r\n\t\t\t\treturn this->max(v1).min(v2);\r\n\t\t\t}\r\n\r\n\t\t\t// Linearly interpolate between this vector, and another vector, given normalised parameter 't'\r\n\t\t\tinline constexpr v_2d lerp(const v_2d& v1, const double t) const\r\n\t\t\t{\r\n\t\t\t\treturn (*this) * (T(1.0 - t)) + (v1 * T(t));\r\n\t\t\t}\r\n\r\n\t\t\t// Compare if this vector is numerically equal to another\r\n\t\t\tinline constexpr bool operator == (const v_2d& rhs) const\r\n\t\t\t{\r\n\t\t\t\treturn (this->x == rhs.x && this->y == rhs.y);\r\n\t\t\t}\r\n\r\n\t\t\t// Compare if this vector is not numerically equal to another\r\n\t\t\tinline constexpr bool operator != (const v_2d& rhs) const\r\n\t\t\t{\r\n\t\t\t\treturn (this->x != rhs.x || this->y != rhs.y);\r\n\t\t\t}\r\n\r\n\t\t\t// Return this vector as a std::string, of the form \"(x,y)\"\r\n\t\t\tinline std::string str() const\r\n\t\t\t{\r\n\t\t\t\treturn std::string(\"(\") + std::to_string(this->x) + \",\" + std::to_string(this->y) + \")\";\r\n\t\t\t}\r\n\r\n\t\t\t// Assuming this vector is incident, given a normal, return the reflection\r\n\t\t\tinline constexpr v_2d reflect(const v_2d& n) const\r\n\t\t\t{\r\n\t\t\t\treturn (*this) - 2.0 * (this->dot(n) * n);\r\n\t\t\t}\r\n\r\n\t\t\t// Allow 'casting' from other v_2d types\r\n\t\t\ttemplate<class F>\r\n\t\t\tinline constexpr operator v_2d<F>() const\r\n\t\t\t{\r\n\t\t\t\treturn { static_cast<F>(this->x), static_cast<F>(this->y) };\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Multiplication operator overloads between vectors and scalars, and vectors and vectors\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator * (const TL& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs * rhs.x, lhs * rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator * (const v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x * rhs, lhs.y * rhs);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator * (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x * rhs.x, lhs.y * rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator *= (v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\tlhs = lhs * rhs;\r\n\t\t\treturn lhs;\r\n\t\t}\r\n\r\n\t\t// Division operator overloads between vectors and scalars, and vectors and vectors\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator / (const TL& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs / rhs.x, lhs / rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator / (const v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x / rhs, lhs.y / rhs);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator / (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x / rhs.x, lhs.y / rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator /= (v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\tlhs = lhs / rhs;\r\n\t\t\treturn lhs;\r\n\t\t}\r\n\r\n\t\t// Unary Addition operator (pointless but i like the platinum trophies)\r\n\t\ttemplate<class T>\r\n\t\tinline constexpr auto operator + (const v_2d<T>& lhs)\r\n\t\t{\r\n\t\t\treturn v_2d(+lhs.x, +lhs.y);\r\n\t\t}\r\n\r\n\t\t// Addition operator overloads between vectors and scalars, and vectors and vectors\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator + (const TL& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs + rhs.x, lhs + rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator + (const v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x + rhs, lhs.y + rhs);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator + (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x + rhs.x, lhs.y + rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator += (v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\tlhs = lhs + rhs;\r\n\t\t\treturn lhs;\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator += (v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\tlhs = lhs + rhs;\r\n\t\t\treturn lhs;\r\n\t\t}\r\n\r\n\t\t// Unary negation operator overoad for inverting a vector\r\n\t\ttemplate<class T>\r\n\t\tinline constexpr auto operator - (const v_2d<T>& lhs)\r\n\t\t{\r\n\t\t\treturn v_2d(-lhs.x, -lhs.y);\r\n\t\t}\r\n\r\n\t\t// Subtraction operator overloads between vectors and scalars, and vectors and vectors\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator - (const TL& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs - rhs.x, lhs - rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator - (const v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x - rhs, lhs.y - rhs);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator - (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn v_2d(lhs.x - rhs.x, lhs.y - rhs.y);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr auto operator -= (v_2d<TL>& lhs, const TR& rhs)\r\n\t\t{\r\n\t\t\tlhs = lhs - rhs;\r\n\t\t\treturn lhs;\r\n\t\t}\r\n\r\n\t\t// Greater/Less-Than Operator overloads - mathematically useless, but handy for \"sorted\" container storage\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr bool operator < (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn (lhs.y < rhs.y) || (lhs.y == rhs.y && lhs.x < rhs.x);\r\n\t\t}\r\n\r\n\t\ttemplate<class TL, class TR>\r\n\t\tinline constexpr bool operator > (const v_2d<TL>& lhs, const v_2d<TR>& rhs)\r\n\t\t{\r\n\t\t\treturn (lhs.y > rhs.y) || (lhs.y == rhs.y && lhs.x > rhs.x);\r\n\t\t}\r\n\r\n\t\t// Allow olc::v_2d to play nicely with std::cout\r\n\t\ttemplate<class T>\r\n\t\tinline constexpr std::ostream& operator << (std::ostream& os, const v_2d<T>& rhs)\r\n\t\t{\r\n\t\t\tos << rhs.str();\r\n\t\t\treturn os;\r\n\t\t}\r\n\r\n\t\t// Convenient types ready-to-go\r\n\t\ttypedef v_2d<int32_t> vi2d;\r\n\t\ttypedef v_2d<uint32_t> vu2d;\r\n\t\ttypedef v_2d<float> vf2d;\r\n\t\ttypedef v_2d<double> vd2d;\r\n\t}\r\n#define OLC_VECTOR2D_DEFINED 1\r\n#endif\r\n\r\n\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine INTERFACE DECLARATION                                     |\r\n// O------------------------------------------------------------------------------O\r\n#pragma region pge_declaration\r\nnamespace olc\r\n{\r\n\tclass PixelGameEngine;\r\n\tclass Sprite;\r\n\r\n\t// Pixel Game Engine Advanced Configuration\r\n\tconstexpr uint8_t  nMouseButtons = 5;\r\n\tconstexpr uint8_t  nDefaultAlpha = 0xFF;\r\n\tconstexpr uint32_t nDefaultPixel = uint32_t(nDefaultAlpha << 24);\r\n\tconstexpr uint8_t  nTabSizeInSpaces = 4;\r\n\tconstexpr size_t OLC_MAX_VERTS = 128;\r\n\tenum rcode { FAIL = 0, OK = 1, NO_FILE = -1 };\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Pixel - Represents a 32-Bit RGBA colour                                 |\r\n\t// O------------------------------------------------------------------------------O\r\n#if !defined(OLC_IGNORE_PIXEL)\r\n\tstruct Pixel\r\n\t{\r\n\t\tunion\r\n\t\t{\r\n\t\t\tuint32_t n = nDefaultPixel;\r\n\t\t\tstruct { uint8_t r; uint8_t g; uint8_t b; uint8_t a; };\r\n\t\t};\r\n\r\n\t\tenum Mode { NORMAL, MASK, ALPHA, CUSTOM };\r\n\r\n\t\tPixel();\r\n\t\tPixel(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha = nDefaultAlpha);\r\n\t\tPixel(uint32_t p);\r\n\t\tPixel& operator = (const Pixel& v) = default;\r\n\t\tbool   operator ==(const Pixel& p) const;\r\n\t\tbool   operator !=(const Pixel& p) const;\r\n\t\tPixel  operator * (const float i) const;\r\n\t\tPixel  operator / (const float i) const;\r\n\t\tPixel& operator *=(const float i);\r\n\t\tPixel& operator /=(const float i);\r\n\t\tPixel  operator + (const Pixel& p) const;\r\n\t\tPixel  operator - (const Pixel& p) const;\r\n\t\tPixel& operator +=(const Pixel& p);\r\n\t\tPixel& operator -=(const Pixel& p);\r\n\t\tPixel  operator * (const Pixel& p) const;\r\n\t\tPixel& operator *=(const Pixel& p);\r\n\t\tPixel  inv() const;\r\n\t};\r\n\r\n\tPixel PixelF(float red, float green, float blue, float alpha = 1.0f);\r\n\tPixel PixelLerp(const olc::Pixel& p1, const olc::Pixel& p2, float t);\r\n\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | USEFUL CONSTANTS                                                             |\r\n\t// O------------------------------------------------------------------------------O\r\n\tstatic const Pixel\r\n\t\tGREY(192, 192, 192), DARK_GREY(128, 128, 128), VERY_DARK_GREY(64, 64, 64),\r\n\t\tRED(255, 0, 0), DARK_RED(128, 0, 0), VERY_DARK_RED(64, 0, 0),\r\n\t\tYELLOW(255, 255, 0), DARK_YELLOW(128, 128, 0), VERY_DARK_YELLOW(64, 64, 0),\r\n\t\tGREEN(0, 255, 0), DARK_GREEN(0, 128, 0), VERY_DARK_GREEN(0, 64, 0),\r\n\t\tCYAN(0, 255, 255), DARK_CYAN(0, 128, 128), VERY_DARK_CYAN(0, 64, 64),\r\n\t\tBLUE(0, 0, 255), DARK_BLUE(0, 0, 128), VERY_DARK_BLUE(0, 0, 64),\r\n\t\tMAGENTA(255, 0, 255), DARK_MAGENTA(128, 0, 128), VERY_DARK_MAGENTA(64, 0, 64),\r\n\t\tWHITE(255, 255, 255), BLACK(0, 0, 0), BLANK(0, 0, 0, 0);\r\n#endif\r\n\t// Thanks to scripticuk and others for updating the key maps\r\n\t// NOTE: The GLUT platform will need updating, open to contributions ;)\r\n\tenum Key\r\n\t{\r\n\t\tNONE,\r\n\t\tA, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,\r\n\t\tK0, K1, K2, K3, K4, K5, K6, K7, K8, K9,\r\n\t\tF1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,\r\n\t\tUP, DOWN, LEFT, RIGHT,\r\n\t\tSPACE, TAB, SHIFT, CTRL, INS, DEL, HOME, END, PGUP, PGDN,\r\n\t\tBACK, ESCAPE, RETURN, ENTER, PAUSE, SCROLL,\r\n\t\tNP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9,\r\n\t\tNP_MUL, NP_DIV, NP_ADD, NP_SUB, NP_DECIMAL, PERIOD,\r\n\t\tEQUALS, COMMA, MINUS,\r\n\t\tOEM_1, OEM_2, OEM_3, OEM_4, OEM_5, OEM_6, OEM_7, OEM_8,\r\n\t\tCAPS_LOCK, ENUM_END\r\n\t};\r\n\r\n\tnamespace Mouse\r\n\t{\r\n\t\tstatic constexpr int32_t LEFT = 0;\r\n\t\tstatic constexpr int32_t RIGHT = 1;\r\n\t\tstatic constexpr int32_t MIDDLE = 2;\r\n\t};\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::HWButton - Represents the state of a hardware button (mouse/key/joy)    |\r\n\t// O------------------------------------------------------------------------------O\r\n\tstruct HWButton\r\n\t{\r\n\t\tbool bPressed = false;\t// Set once during the frame the event occurs\r\n\t\tbool bReleased = false;\t// Set once during the frame the event occurs\r\n\t\tbool bHeld = false;\t\t// Set true for all frames between pressed and released events\r\n\t};\r\n\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::ResourcePack - A virtual scrambled filesystem to pack your assets into  |\r\n\t// O------------------------------------------------------------------------------O\r\n\tstruct ResourceBuffer : public std::streambuf\r\n\t{\r\n\t\tResourceBuffer(std::ifstream& ifs, uint32_t offset, uint32_t size);\r\n\t\tstd::vector<char> vMemory;\r\n\t};\r\n\r\n\tclass ResourcePack : public std::streambuf\r\n\t{\r\n\tpublic:\r\n\t\tResourcePack();\r\n\t\t~ResourcePack();\r\n\t\tbool AddFile(const std::string& sFile);\r\n\t\tbool LoadPack(const std::string& sFile, const std::string& sKey);\r\n\t\tbool SavePack(const std::string& sFile, const std::string& sKey);\r\n\t\tResourceBuffer GetFileBuffer(const std::string& sFile);\r\n\t\tbool Loaded();\r\n\tprivate:\r\n\t\tstruct sResourceFile { uint32_t nSize; uint32_t nOffset; };\r\n\t\tstd::map<std::string, sResourceFile> mapFiles;\r\n\t\tstd::ifstream baseFile;\r\n\t\tstd::vector<char> scramble(const std::vector<char>& data, const std::string& key);\r\n\t\tstd::string makeposix(const std::string& path);\r\n\t};\r\n\r\n\r\n\tclass ImageLoader\r\n\t{\r\n\tpublic:\r\n\t\tImageLoader() = default;\r\n\t\tvirtual ~ImageLoader() = default;\r\n\t\tvirtual olc::rcode LoadImageResource(olc::Sprite* spr, const std::string& sImageFile, olc::ResourcePack* pack) = 0;\r\n\t\tvirtual olc::rcode SaveImageResource(olc::Sprite* spr, const std::string& sImageFile) = 0;\r\n\t};\r\n\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Sprite - An image represented by a 2D array of olc::Pixel               |\r\n\t// O------------------------------------------------------------------------------O\r\n\tclass Sprite\r\n\t{\r\n\tpublic:\r\n\t\tSprite();\r\n\t\tSprite(const std::string& sImageFile, olc::ResourcePack* pack = nullptr);\r\n\t\tSprite(int32_t w, int32_t h);\r\n\t\tSprite(const olc::Sprite&) = delete;\r\n\t\t~Sprite();\r\n\r\n\tpublic:\r\n\t\tolc::rcode LoadFromFile(const std::string& sImageFile, olc::ResourcePack* pack = nullptr);\r\n\r\n\tpublic:\r\n\t\tint32_t width = 0;\r\n\t\tint32_t height = 0;\r\n\t\tenum Mode { NORMAL, PERIODIC, CLAMP };\r\n\t\tenum Flip { NONE = 0, HORIZ = 1, VERT = 2 };\r\n\r\n\tpublic:\r\n\t\tvoid SetSampleMode(olc::Sprite::Mode mode = olc::Sprite::Mode::NORMAL);\r\n\t\tPixel GetPixel(int32_t x, int32_t y) const;\r\n\t\tbool  SetPixel(int32_t x, int32_t y, Pixel p);\r\n\t\tPixel GetPixel(const olc::vi2d& a) const;\r\n\t\tbool  SetPixel(const olc::vi2d& a, Pixel p);\r\n\t\tPixel Sample(float x, float y) const;\r\n\t\tPixel Sample(const olc::vf2d& uv) const;\r\n\t\tPixel SampleBL(float u, float v) const;\r\n\t\tPixel SampleBL(const olc::vf2d& uv) const;\r\n\t\tPixel* GetData();\r\n\t\tolc::Sprite* Duplicate();\r\n\t\tolc::Sprite* Duplicate(const olc::vi2d& vPos, const olc::vi2d& vSize);\r\n\t\tolc::vi2d Size() const;\r\n\t\tvoid SetSize(int32_t w, int32_t h);\r\n\t\tstd::vector<olc::Pixel> pColData;\r\n\t\tMode modeSample = Mode::NORMAL;\r\n\r\n\t\tstatic std::unique_ptr<olc::ImageLoader> loader;\r\n\t};\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Decal - A GPU resident storage of an olc::Sprite                        |\r\n\t// O------------------------------------------------------------------------------O\r\n\tclass Decal\r\n\t{\r\n\tpublic:\r\n\t\tDecal(olc::Sprite* spr, bool filter = false, bool clamp = true);\r\n\t\tDecal(const uint32_t nExistingTextureResource, olc::Sprite* spr);\r\n\t\tvirtual ~Decal();\r\n\t\tvoid Update();\r\n\t\tvoid UpdateSprite();\r\n\r\n\tpublic: // But dont touch\r\n\t\tint32_t id = -1;\r\n\t\tolc::Sprite* sprite = nullptr;\r\n\t\tolc::vf2d vUVScale = { 1.0f, 1.0f };\r\n\t};\r\n\r\n\tenum class DecalMode\r\n\t{\r\n\t\tNORMAL,\r\n\t\tADDITIVE,\r\n\t\tMULTIPLICATIVE,\r\n\t\tSTENCIL,\r\n\t\tILLUMINATE,\r\n\t\tWIREFRAME,\r\n\t};\r\n\r\n\tenum class DecalStructure\r\n\t{\r\n\t\tLINE,\r\n\t\tFAN,\r\n\t\tSTRIP,\r\n\t\tLIST\r\n\t};\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Renderable - Convenience class to keep a sprite and decal together      |\r\n\t// O------------------------------------------------------------------------------O\r\n\tclass Renderable\r\n\t{\r\n\tpublic:\r\n\t\tRenderable() = default;\t\t\r\n\t\tRenderable(Renderable&& r) = default; \r\n\t\tRenderable& operator=(Renderable&& r) = default;\r\n\t\tRenderable(const Renderable&) = delete;\r\n\t\tolc::rcode Load(const std::string& sFile, ResourcePack* pack = nullptr, bool filter = false, bool clamp = true);\r\n\t\tvoid Create(uint32_t width, uint32_t height, bool filter = false, bool clamp = true);\r\n\t\tolc::Decal* Decal() const;\r\n\t\tolc::Sprite* Sprite() const;\r\n\r\n\r\n\tprivate:\r\n\t\tstd::unique_ptr<olc::Sprite> pSprite = nullptr;\r\n\t\tstd::unique_ptr<olc::Decal> pDecal = nullptr;\r\n\t};\r\n\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | Auxilliary components internal to engine                                     |\r\n\t// O------------------------------------------------------------------------------O\r\n\r\n\tstruct DecalInstance\r\n\t{\r\n\t\tolc::Decal* decal = nullptr;\r\n\t\tstd::vector<olc::vf2d> pos;\r\n\t\tstd::vector<olc::vf2d> uv;\r\n\t\tstd::vector<float> w;\r\n\t\tstd::vector<float> z;\r\n\t\tstd::vector<olc::Pixel> tint;\r\n\t\tolc::DecalMode mode = olc::DecalMode::NORMAL;\r\n\t\tolc::DecalStructure structure = olc::DecalStructure::FAN;\r\n\t\tuint32_t points = 0;\r\n\t\tbool depth = false;\r\n\t};\r\n\r\n\tstruct LayerDesc\r\n\t{\r\n\t\tolc::vf2d vOffset = { 0, 0 };\r\n\t\tolc::vf2d vScale = { 1, 1 };\r\n\t\tbool bShow = false;\r\n\t\tbool bUpdate = false;\r\n\t\tolc::Renderable pDrawTarget;\r\n\t\tuint32_t nResID = 0;\r\n\t\tstd::vector<DecalInstance> vecDecalInstance;\r\n\t\tolc::Pixel tint = olc::WHITE;\r\n\t\tstd::function<void()> funcHook = nullptr;\r\n\t};\r\n\r\n\tclass Renderer\r\n\t{\r\n\tpublic:\r\n\t\tvirtual ~Renderer() = default;\r\n\t\tvirtual void       PrepareDevice() = 0;\r\n\t\tvirtual olc::rcode CreateDevice(std::vector<void*> params, bool bFullScreen, bool bVSYNC) = 0;\r\n\t\tvirtual olc::rcode DestroyDevice() = 0;\r\n\t\tvirtual void       DisplayFrame() = 0;\r\n\t\tvirtual void       PrepareDrawing() = 0;\r\n\t\tvirtual void\t   SetDecalMode(const olc::DecalMode& mode) = 0;\r\n\t\tvirtual void       DrawLayerQuad(const olc::vf2d& offset, const olc::vf2d& scale, const olc::Pixel tint) = 0;\r\n\t\tvirtual void       DrawDecal(const olc::DecalInstance& decal) = 0;\r\n\t\tvirtual uint32_t   CreateTexture(const uint32_t width, const uint32_t height, const bool filtered = false, const bool clamp = true) = 0;\r\n\t\tvirtual void       UpdateTexture(uint32_t id, olc::Sprite* spr) = 0;\r\n\t\tvirtual void       ReadTexture(uint32_t id, olc::Sprite* spr) = 0;\r\n\t\tvirtual uint32_t   DeleteTexture(const uint32_t id) = 0;\r\n\t\tvirtual void       ApplyTexture(uint32_t id) = 0;\r\n\t\tvirtual void       UpdateViewport(const olc::vi2d& pos, const olc::vi2d& size) = 0;\r\n\t\tvirtual void       ClearBuffer(olc::Pixel p, bool bDepth) = 0;\r\n\t\tstatic olc::PixelGameEngine* ptrPGE;\r\n\t};\r\n\r\n\tclass Platform\r\n\t{\r\n\tpublic:\r\n\t\tvirtual ~Platform() = default;\r\n\t\tvirtual olc::rcode ApplicationStartUp() = 0;\r\n\t\tvirtual olc::rcode ApplicationCleanUp() = 0;\r\n\t\tvirtual olc::rcode ThreadStartUp() = 0;\r\n\t\tvirtual olc::rcode ThreadCleanUp() = 0;\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) = 0;\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) = 0;\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) = 0;\r\n\t\tvirtual olc::rcode ShowWindowFrame(const bool bShowFrame = true) = 0;\r\n\t\tvirtual olc::rcode SetWindowSize(const olc::vi2d& vWindowPos, const olc::vi2d& vWindowSize) = 0;\r\n\t\tvirtual olc::rcode StartSystemEventLoop() = 0;\r\n\t\tvirtual olc::rcode HandleSystemEvent() = 0;\r\n\t\tstatic olc::PixelGameEngine* ptrPGE;\r\n\t};\r\n\r\n\tclass PGEX;\r\n\r\n\t// The Static Twins (plus one)\r\n\tstatic std::unique_ptr<Renderer> renderer;\r\n\tstatic std::unique_ptr<Platform> platform;\r\n\tstatic std::map<size_t, uint8_t> mapKeys;\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::PixelGameEngine - The main BASE class for your application              |\r\n\t// O------------------------------------------------------------------------------O\r\n\tclass PixelGameEngine\r\n\t{\r\n\tpublic:\r\n\t\tPixelGameEngine();\r\n\t\tvirtual ~PixelGameEngine();\r\n\tpublic:\r\n\t\tolc::rcode Construct(int32_t screen_w, int32_t screen_h, int32_t pixel_w, int32_t pixel_h,\r\n\t\t\tbool full_screen = false, bool vsync = false, bool cohesion = false, bool realwindow = false);\r\n\t\tolc::rcode Start();\r\n\r\n\tpublic: // User Override Interfaces\r\n\t\t// Called once on application startup, use to load your resources\r\n\t\tvirtual bool OnUserCreate();\r\n\t\t// Called every frame, and provides you with a time per frame value\r\n\t\tvirtual bool OnUserUpdate(float fElapsedTime);\r\n\t\t// Called once on application termination, so you can be one clean coder\r\n\t\tvirtual bool OnUserDestroy();\r\n\r\n\t\t// Called when a text entry is confirmed with \"enter\" key\r\n\t\tvirtual void OnTextEntryComplete(const std::string& sText);\r\n\t\t// Called when a console command is executed\r\n\t\tvirtual bool OnConsoleCommand(const std::string& sCommand);\r\n\r\n\r\n\tpublic: // Hardware Interfaces\r\n\t\t// Returns true if window is currently in focus\r\n\t\tbool IsFocused() const;\r\n\t\t// Get the state of a specific keyboard button\r\n\t\tHWButton GetKey(Key k) const;\r\n\t\t// Get the state of a specific mouse button\r\n\t\tHWButton GetMouse(uint32_t b) const;\r\n\t\t// Get Mouse X coordinate in \"pixel\" space\r\n\t\tint32_t GetMouseX() const;\r\n\t\t// Get Mouse Y coordinate in \"pixel\" space\r\n\t\tint32_t GetMouseY() const;\r\n\t\t// Get Mouse Wheel Delta\r\n\t\tint32_t GetMouseWheel() const;\r\n\t\t// Get the mouse in window space\r\n\t\tconst olc::vi2d& GetWindowMouse() const;\r\n\t\t// Gets the mouse as a vector to keep Tarriest happy\r\n\t\tconst olc::vi2d& GetMousePos() const;\r\n\r\n\t\tstatic const std::map<size_t, uint8_t>& GetKeyMap() { return mapKeys; }\r\n\r\n\t\t// Muck about with the GUI\r\n\t\tolc::rcode SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize);\r\n\t\tolc::rcode ShowWindowFrame(const bool bShowFrame);\r\n\r\n\tpublic: // Utility\r\n\t\t// Returns the width of the screen in \"pixels\"\r\n\t\tint32_t ScreenWidth() const;\r\n\t\t// Returns the height of the screen in \"pixels\"\r\n\t\tint32_t ScreenHeight() const;\r\n\t\t// Returns the width of the currently selected drawing target in \"pixels\"\r\n\t\tint32_t GetDrawTargetWidth() const;\r\n\t\t// Returns the height of the currently selected drawing target in \"pixels\"\r\n\t\tint32_t GetDrawTargetHeight() const;\r\n\t\t// Returns the currently active draw target\r\n\t\tolc::Sprite* GetDrawTarget() const;\r\n\t\t// Resize the primary screen sprite\r\n\t\tvoid SetScreenSize(int w, int h);\r\n\t\t// Specify which Sprite should be the target of drawing functions, use nullptr\r\n\t\t// to specify the primary screen\r\n\t\tvoid SetDrawTarget(Sprite* target);\r\n\t\t// Gets the current Frames Per Second\r\n\t\tuint32_t GetFPS() const;\r\n\t\t// Gets last update of elapsed time\r\n\t\tfloat GetElapsedTime() const;\r\n\t\t// Gets Actual Window size\r\n\t\tconst olc::vi2d& GetWindowSize() const;\r\n\t\t// Gets Actual Window position\r\n\t\tconst olc::vi2d& GetWindowPos() const;\r\n\t\t// Gets pixel scale\r\n\t\tconst olc::vi2d& GetPixelSize() const;\r\n\t\t// Gets actual pixel scale\r\n\t\tconst olc::vi2d& GetScreenPixelSize() const;\r\n\t\t// Gets \"screen\" size\r\n\t\tconst olc::vi2d& GetScreenSize() const;\r\n\t\t// Gets any files dropped this frame\r\n\t\tconst std::vector<std::string>& GetDroppedFiles() const;\r\n\t\tconst olc::vi2d& GetDroppedFilesPoint() const;\r\n\r\n\tpublic: // CONFIGURATION ROUTINES\r\n\t\t// Layer targeting functions\r\n\t\tvoid SetDrawTarget(uint8_t layer, bool bDirty = true);\r\n\t\tvoid EnableLayer(uint8_t layer, bool b);\r\n\t\tvoid SetLayerOffset(uint8_t layer, const olc::vf2d& offset);\r\n\t\tvoid SetLayerOffset(uint8_t layer, float x, float y);\r\n\t\tvoid SetLayerScale(uint8_t layer, const olc::vf2d& scale);\r\n\t\tvoid SetLayerScale(uint8_t layer, float x, float y);\r\n\t\tvoid SetLayerTint(uint8_t layer, const olc::Pixel& tint);\r\n\t\tvoid SetLayerCustomRenderFunction(uint8_t layer, std::function<void()> f);\r\n\r\n\t\tstd::vector<LayerDesc>& GetLayers();\r\n\t\tuint32_t CreateLayer();\r\n\r\n\t\t// Change the pixel mode for different optimisations\r\n\t\t// olc::Pixel::NORMAL = No transparency\r\n\t\t// olc::Pixel::MASK   = Transparent if alpha is < 255\r\n\t\t// olc::Pixel::ALPHA  = Full transparency\r\n\t\tvoid SetPixelMode(Pixel::Mode m);\r\n\t\tPixel::Mode GetPixelMode();\r\n\t\t// Use a custom blend function\r\n\t\tvoid SetPixelMode(std::function<olc::Pixel(const int x, const int y, const olc::Pixel& pSource, const olc::Pixel& pDest)> pixelMode);\r\n\t\t// Change the blend factor from between 0.0f to 1.0f;\r\n\t\tvoid SetPixelBlend(float fBlend);\r\n\r\n\t\t// [ADVANCED] For those that really want to dick about with PGE :P\r\n\t\t// Note: Normal use of olc::PGE does not require you use these functions\r\n\t\tvoid adv_ManualRenderEnable(const bool bEnable);\r\n\t\tvoid adv_HardwareClip(const bool bScale, const olc::vi2d& viewPos, const olc::vi2d& viewSize, const bool bClear = false);\r\n\t\tvoid adv_FlushLayer(const size_t nLayerID);\r\n\t\tvoid adv_FlushLayerDecals(const size_t nLayerID);\r\n\r\n\tpublic: // DRAWING ROUTINES\r\n\t\t// Draws a single Pixel\r\n\t\tvirtual bool Draw(int32_t x, int32_t y, Pixel p = olc::WHITE);\r\n\t\tbool Draw(const olc::vi2d& pos, Pixel p = olc::WHITE);\r\n\t\t// Draws a line from (x1,y1) to (x2,y2)\r\n\t\tvoid DrawLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, Pixel p = olc::WHITE, uint32_t pattern = 0xFFFFFFFF);\r\n\t\tvoid DrawLine(const olc::vi2d& pos1, const olc::vi2d& pos2, Pixel p = olc::WHITE, uint32_t pattern = 0xFFFFFFFF);\r\n\t\t// Draws a circle located at (x,y) with radius\r\n\t\tvoid DrawCircle(int32_t x, int32_t y, int32_t radius, Pixel p = olc::WHITE, uint8_t mask = 0xFF);\r\n\t\tvoid DrawCircle(const olc::vi2d& pos, int32_t radius, Pixel p = olc::WHITE, uint8_t mask = 0xFF);\r\n\t\t// Fills a circle located at (x,y) with radius\r\n\t\tvoid FillCircle(int32_t x, int32_t y, int32_t radius, Pixel p = olc::WHITE);\r\n\t\tvoid FillCircle(const olc::vi2d& pos, int32_t radius, Pixel p = olc::WHITE);\r\n\t\t// Draws a rectangle at (x,y) to (x+w,y+h)\r\n\t\tvoid DrawRect(int32_t x, int32_t y, int32_t w, int32_t h, Pixel p = olc::WHITE);\r\n\t\tvoid DrawRect(const olc::vi2d& pos, const olc::vi2d& size, Pixel p = olc::WHITE);\r\n\t\t// Fills a rectangle at (x,y) to (x+w,y+h)\r\n\t\tvoid FillRect(int32_t x, int32_t y, int32_t w, int32_t h, Pixel p = olc::WHITE);\r\n\t\tvoid FillRect(const olc::vi2d& pos, const olc::vi2d& size, Pixel p = olc::WHITE);\r\n\t\t// Draws a triangle between points (x1,y1), (x2,y2) and (x3,y3)\r\n\t\tvoid DrawTriangle(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x3, int32_t y3, Pixel p = olc::WHITE);\r\n\t\tvoid DrawTriangle(const olc::vi2d& pos1, const olc::vi2d& pos2, const olc::vi2d& pos3, Pixel p = olc::WHITE);\r\n\t\t// Flat fills a triangle between points (x1,y1), (x2,y2) and (x3,y3)\r\n\t\tvoid FillTriangle(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x3, int32_t y3, Pixel p = olc::WHITE);\r\n\t\tvoid FillTriangle(const olc::vi2d& pos1, const olc::vi2d& pos2, const olc::vi2d& pos3, Pixel p = olc::WHITE);\r\n\t\t// Fill a textured and coloured triangle\r\n\t\tvoid FillTexturedTriangle(std::vector<olc::vf2d> vPoints, std::vector<olc::vf2d> vTex, std::vector<olc::Pixel> vColour, olc::Sprite* sprTex);\r\n\t\tvoid FillTexturedPolygon(const std::vector<olc::vf2d>& vPoints, const std::vector<olc::vf2d>& vTex, const std::vector<olc::Pixel>& vColour, olc::Sprite* sprTex, olc::DecalStructure structure = olc::DecalStructure::LIST);\r\n\t\t// Draws an entire sprite at location (x,y)\r\n\t\tvoid DrawSprite(int32_t x, int32_t y, Sprite* sprite, uint32_t scale = 1, uint8_t flip = olc::Sprite::NONE);\r\n\t\tvoid DrawSprite(const olc::vi2d& pos, Sprite* sprite, uint32_t scale = 1, uint8_t flip = olc::Sprite::NONE);\r\n\t\t// Draws an area of a sprite at location (x,y), where the\r\n\t\t// selected area is (ox,oy) to (ox+w,oy+h)\r\n\t\tvoid DrawPartialSprite(int32_t x, int32_t y, Sprite* sprite, int32_t ox, int32_t oy, int32_t w, int32_t h, uint32_t scale = 1, uint8_t flip = olc::Sprite::NONE);\r\n\t\tvoid DrawPartialSprite(const olc::vi2d& pos, Sprite* sprite, const olc::vi2d& sourcepos, const olc::vi2d& size, uint32_t scale = 1, uint8_t flip = olc::Sprite::NONE);\r\n\t\t// Draws a single line of text - traditional monospaced\r\n\t\tvoid DrawString(int32_t x, int32_t y, const std::string& sText, Pixel col = olc::WHITE, uint32_t scale = 1);\r\n\t\tvoid DrawString(const olc::vi2d& pos, const std::string& sText, Pixel col = olc::WHITE, uint32_t scale = 1);\r\n\t\tolc::vi2d GetTextSize(const std::string& s);\r\n\t\t// Draws a single line of text - non-monospaced\r\n\t\tvoid DrawStringProp(int32_t x, int32_t y, const std::string& sText, Pixel col = olc::WHITE, uint32_t scale = 1);\r\n\t\tvoid DrawStringProp(const olc::vi2d& pos, const std::string& sText, Pixel col = olc::WHITE, uint32_t scale = 1);\r\n\t\tolc::vi2d GetTextSizeProp(const std::string& s);\r\n\r\n\t\t// Decal Quad functions\r\n\t\tvoid SetDecalMode(const olc::DecalMode& mode);\r\n\t\tvoid SetDecalStructure(const olc::DecalStructure& structure);\r\n\t\t// Draws a whole decal, with optional scale and tinting\r\n\t\tvoid DrawDecal(const olc::vf2d& pos, olc::Decal* decal, const olc::vf2d& scale = { 1.0f,1.0f }, const olc::Pixel& tint = olc::WHITE);\r\n\t\t// Draws a region of a decal, with optional scale and tinting\r\n\t\tvoid DrawPartialDecal(const olc::vf2d& pos, olc::Decal* decal, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::vf2d& scale = { 1.0f,1.0f }, const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawPartialDecal(const olc::vf2d& pos, const olc::vf2d& size, olc::Decal* decal, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint = olc::WHITE);\r\n\t\t// Draws fully user controlled 4 vertices, pos(pixels), uv(pixels), colours\r\n\t\tvoid DrawExplicitDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::vf2d* uv, const olc::Pixel* col, uint32_t elements = 4);\r\n\t\t// Draws a decal with 4 arbitrary points, warping the texture to look \"correct\"\r\n\t\tvoid DrawWarpedDecal(olc::Decal* decal, const olc::vf2d(&pos)[4], const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawWarpedDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawWarpedDecal(olc::Decal* decal, const std::array<olc::vf2d, 4>& pos, const olc::Pixel& tint = olc::WHITE);\r\n\t\t// As above, but you can specify a region of a decal source sprite\r\n\t\tvoid DrawPartialWarpedDecal(olc::Decal* decal, const olc::vf2d(&pos)[4], const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawPartialWarpedDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawPartialWarpedDecal(olc::Decal* decal, const std::array<olc::vf2d, 4>& pos, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint = olc::WHITE);\r\n\t\t// Draws a decal rotated to specified angle, wit point of rotation offset\r\n\t\tvoid DrawRotatedDecal(const olc::vf2d& pos, olc::Decal* decal, const float fAngle, const olc::vf2d& center = { 0.0f, 0.0f }, const olc::vf2d& scale = { 1.0f,1.0f }, const olc::Pixel& tint = olc::WHITE);\r\n\t\tvoid DrawPartialRotatedDecal(const olc::vf2d& pos, olc::Decal* decal, const float fAngle, const olc::vf2d& center, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::vf2d& scale = { 1.0f, 1.0f }, const olc::Pixel& tint = olc::WHITE);\r\n\t\t// Draws a multiline string as a decal, with tiniting and scaling\r\n\t\tvoid DrawStringDecal(const olc::vf2d& pos, const std::string& sText, const Pixel col = olc::WHITE, const olc::vf2d& scale = { 1.0f, 1.0f });\r\n\t\tvoid DrawStringPropDecal(const olc::vf2d& pos, const std::string& sText, const Pixel col = olc::WHITE, const olc::vf2d& scale = { 1.0f, 1.0f });\r\n\t\t// Draws a single shaded filled rectangle as a decal\r\n\t\tvoid DrawRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel col = olc::WHITE);\r\n\t\tvoid FillRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel col = olc::WHITE);\r\n\t\t// Draws a corner shaded rectangle as a decal\r\n\t\tvoid GradientFillRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel colTL, const olc::Pixel colBL, const olc::Pixel colBR, const olc::Pixel colTR);\t\t\r\n\t\t// Draws a single shaded filled triangle as a decal\r\n\t\tvoid FillTriangleDecal(const olc::vf2d& p0, const olc::vf2d& p1, const olc::vf2d& p2, const olc::Pixel col = olc::WHITE);\r\n\t\t// Draws a corner shaded triangle as a decal\r\n\t\tvoid GradientTriangleDecal(const olc::vf2d& p0, const olc::vf2d& p1, const olc::vf2d& p2, const olc::Pixel c0, const olc::Pixel c1, const olc::Pixel c2);\r\n\t\t// Draws an arbitrary convex textured polygon using GPU\r\n\t\tvoid DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const olc::Pixel tint = olc::WHITE);\r\n\t\tvoid DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<float>& depth, const std::vector<olc::vf2d>& uv, const olc::Pixel tint = olc::WHITE);\r\n\t\tvoid DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel>& tint);\r\n\t\tvoid DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel>& colours, const olc::Pixel tint);\r\n\t\tvoid DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<float>& depth, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel>& colours, const olc::Pixel tint);\r\n\r\n\t\t// Draws a line in Decal Space\r\n\t\tvoid DrawLineDecal(const olc::vf2d& pos1, const olc::vf2d& pos2, Pixel p = olc::WHITE);\r\n\t\tvoid DrawRotatedStringDecal(const olc::vf2d& pos, const std::string& sText, const float fAngle, const olc::vf2d& center = { 0.0f, 0.0f }, const olc::Pixel col = olc::WHITE, const olc::vf2d& scale = { 1.0f, 1.0f });\r\n\t\tvoid DrawRotatedStringPropDecal(const olc::vf2d& pos, const std::string& sText, const float fAngle, const olc::vf2d& center = { 0.0f, 0.0f }, const olc::Pixel col = olc::WHITE, const olc::vf2d& scale = { 1.0f, 1.0f });\r\n\t\t// Clears entire draw target to Pixel\r\n\t\tvoid Clear(Pixel p);\r\n\t\t// Clears the rendering back buffer\r\n\t\tvoid ClearBuffer(Pixel p, bool bDepth = true);\r\n\t\t// Returns the font image\r\n\t\tolc::Sprite* GetFontSprite();\r\n\r\n\t\t// Clip a line segment to visible area\r\n\t\tbool ClipLineToScreen(olc::vi2d& in_p1, olc::vi2d& in_p2);\r\n\r\n\t\t// Dont allow PGE to mark layers as dirty, so pixel graphics don't update\r\n\t\tvoid EnablePixelTransfer(const bool bEnable = true);\r\n\r\n\t\t// Command Console Routines\r\n\t\tvoid ConsoleShow(const olc::Key &keyExit, bool bSuspendTime = true);\r\n\t\tbool IsConsoleShowing() const;\r\n\t\tvoid ConsoleClear();\r\n\t\tstd::stringstream& ConsoleOut();\r\n\t\tvoid ConsoleCaptureStdOut(const bool bCapture);\r\n\r\n\t\t// Text Entry Routines\r\n\t\tvoid TextEntryEnable(const bool bEnable, const std::string& sText = \"\");\r\n\t\tstd::string TextEntryGetString() const;\r\n\t\tint32_t TextEntryGetCursor() const;\r\n\t\tbool IsTextEntryEnabled() const;\r\n\r\n\r\n\r\n\tprivate:\r\n\t\tvoid UpdateTextEntry();\r\n\t\tvoid UpdateConsole();\r\n\r\n\tpublic:\r\n\r\n\t\t// Experimental Lightweight 3D Routines ================\r\n#ifdef OLC_ENABLE_EXPERIMENTAL\r\n\t\t// Set Manual View Matrix\r\n\t\tvoid LW3D_View(const std::array<float, 16>& m);\r\n\t\t// Set Manual World Matrix\r\n\t\tvoid LW3D_World(const std::array<float, 16>& m);\r\n\t\t// Set Manual Projection Matrix\r\n\t\tvoid LW3D_Projection(const std::array<float, 16>& m);\r\n\t\t\r\n\t\t// Draws a vector of vertices, interprted as individual triangles\r\n\t\tvoid LW3D_DrawTriangles(olc::Decal* decal, const std::vector<std::array<float,3>>& pos, const std::vector<olc::vf2d>& tex, const std::vector<olc::Pixel>& col);\r\n\t\tvoid LW3D_DrawWarpedDecal(olc::Decal* decal, const std::vector<std::array<float, 3>>& pos, const olc::Pixel& tint);\r\n\r\n\t\tvoid LW3D_ModelTranslate(const float x, const float y, const float z);\r\n\t\t\r\n\t\t// Camera convenience functions\r\n\t\tvoid LW3D_SetCameraAtTarget(const float fEyeX, const float fEyeY, const float fEyeZ,\r\n\t\t\tconst float fTargetX, const float fTargetY, const float fTargetZ,\r\n\t\t\tconst float fUpX = 0.0f, const float fUpY = 1.0f, const float fUpZ = 0.0f);\r\n\t\tvoid LW3D_SetCameraAlongDirection(const float fEyeX, const float fEyeY, const float fEyeZ,\r\n\t\t\tconst float fDirX, const float fDirY, const float fDirZ,\r\n\t\t\tconst float fUpX = 0.0f, const float fUpY = 1.0f, const float fUpZ = 0.0f);\r\n\r\n\t\t// 3D Rendering Flags\r\n\t\tvoid LW3D_EnableDepthTest(const bool bEnableDepth);\r\n\t\tvoid LW3D_EnableBackfaceCulling(const bool bEnableCull);\r\n#endif\r\n\tpublic: // Branding\r\n\t\tstd::string sAppName;\r\n\r\n\tprivate: // Inner mysterious workings\r\n\t\tolc::Sprite*     pDrawTarget = nullptr;\r\n\t\tPixel::Mode\tnPixelMode = Pixel::NORMAL;\r\n\t\tfloat\t\tfBlendFactor = 1.0f;\r\n\t\tolc::vi2d\tvScreenSize = { 256, 240 };\r\n\t\tolc::vf2d\tvInvScreenSize = { 1.0f / 256.0f, 1.0f / 240.0f };\r\n\t\tolc::vi2d\tvPixelSize = { 4, 4 };\r\n\t\tolc::vi2d   vScreenPixelSize = { 4, 4 };\r\n\t\tolc::vi2d\tvMousePos = { 0, 0 };\r\n\t\tint32_t\t\tnMouseWheelDelta = 0;\r\n\t\tolc::vi2d\tvMousePosCache = { 0, 0 };\r\n\t\tolc::vi2d   vMouseWindowPos = { 0, 0 };\r\n\t\tint32_t\t\tnMouseWheelDeltaCache = 0;\r\n\t\tolc::vi2d\tvWindowPos = { 0, 0 };\r\n\t\tolc::vi2d\tvWindowSize = { 0, 0 };\r\n\t\tolc::vi2d\tvViewPos = { 0, 0 };\r\n\t\tolc::vi2d\tvViewSize = { 0,0 };\r\n\t\tbool\t\tbFullScreen = false;\r\n\t\tolc::vf2d\tvPixel = { 1.0f, 1.0f };\r\n\t\tbool\t\tbHasInputFocus = false;\r\n\t\tbool\t\tbHasMouseFocus = false;\r\n\t\tbool\t\tbEnableVSYNC = false;\r\n\t\tbool\t\tbRealWindowMode = false;\r\n\t\tbool\t\tbResizeRequested = false;\r\n\t\tolc::vi2d\tvResizeRequested = { 0, 0 };\r\n\t\tfloat\t\tfFrameTimer = 1.0f;\r\n\t\tfloat\t\tfLastElapsed = 0.0f;\r\n\t\tint\t\t\tnFrameCount = 0;\t\t\r\n\t\tbool bSuspendTextureTransfer = false;\r\n\t\tRenderable  fontRenderable;\r\n\t\tstd::vector<LayerDesc> vLayers;\r\n\t\tuint8_t\t\tnTargetLayer = 0;\r\n\t\tuint32_t\tnLastFPS = 0;\r\n\t\tbool\t\tbManualRenderEnable = false;\r\n\t\tbool        bPixelCohesion = false;\r\n\t\tDecalMode   nDecalMode = DecalMode::NORMAL;\r\n\t\tDecalStructure nDecalStructure = DecalStructure::FAN;\r\n\t\tstd::function<olc::Pixel(const int x, const int y, const olc::Pixel&, const olc::Pixel&)> funcPixelMode;\r\n\t\tstd::chrono::time_point<std::chrono::system_clock> m_tp1, m_tp2;\r\n\t\tstd::vector<olc::vi2d> vFontSpacing;\r\n\t\tstd::vector<std::string> vDroppedFiles;\r\n\t\tstd::vector<std::string> vDroppedFilesCache;\r\n\t\tolc::vi2d vDroppedFilesPoint;\r\n\t\tolc::vi2d vDroppedFilesPointCache;\r\n\r\n\t\t// Command Console Specific\r\n\t\tbool bConsoleShow = false;\r\n\t\tbool bConsoleSuspendTime = false;\r\n\t\tolc::Key keyConsoleExit = olc::Key::F1;\r\n\t\tstd::stringstream ssConsoleOutput;\r\n\t\tstd::streambuf* sbufOldCout = nullptr;\r\n\t\tolc::vi2d vConsoleSize;\r\n\t\tolc::vi2d vConsoleCursor = { 0,0 };\r\n\t\tolc::vf2d vConsoleCharacterScale = { 1.0f, 2.0f };\r\n\t\tstd::vector<std::string> sConsoleLines;\r\n\t\tstd::list<std::string> sCommandHistory;\r\n\t\tstd::list<std::string>::iterator sCommandHistoryIt;\r\n\r\n\t\t// Text Entry Specific\r\n\t\tbool bTextEntryEnable = false;\r\n\t\tstd::string sTextEntryString = \"\";\r\n\t\tint32_t nTextEntryCursor = 0;\r\n\t\tstd::vector<std::tuple<olc::Key, std::string, std::string>> vKeyboardMap;\r\n\r\n\r\n\r\n\t\t// State of keyboard\t\t\r\n\t\tbool\t\tpKeyNewState[256] = { 0 };\r\n\t\tbool\t\tpKeyOldState[256] = { 0 };\r\n\t\tHWButton\tpKeyboardState[256] = { 0 };\r\n\r\n\t\t// State of mouse\r\n\t\tbool\t\tpMouseNewState[nMouseButtons] = { 0 };\r\n\t\tbool\t\tpMouseOldState[nMouseButtons] = { 0 };\r\n\t\tHWButton\tpMouseState[nMouseButtons] = { 0 };\r\n\r\n\t\t// The main engine thread\r\n\t\tvoid\t\tEngineThread();\r\n\r\n\r\n\t\t// If anything sets this flag to false, the engine\r\n\t\t// \"should\" shut down gracefully\r\n\t\tstatic std::atomic<bool> bAtomActive;\r\n\r\n\tpublic:\r\n\t\t// \"Break In\" Functions\r\n\t\tvoid olc_UpdateMouse(int32_t x, int32_t y);\r\n\t\tvoid olc_UpdateMouseWheel(int32_t delta);\r\n\t\tvoid olc_UpdateWindowPos(int32_t x, int32_t y);\r\n\t\tvoid olc_UpdateWindowSize(int32_t x, int32_t y);\r\n\t\tvoid olc_UpdateViewport();\r\n\t\tvoid olc_ConstructFontSheet();\r\n\t\tvoid olc_CoreUpdate();\r\n\t\tvoid olc_PrepareEngine();\r\n\t\tvoid olc_UpdateMouseState(int32_t button, bool state);\r\n\t\tvoid olc_UpdateKeyState(int32_t key, bool state);\r\n\t\tvoid olc_UpdateMouseFocus(bool state);\r\n\t\tvoid olc_UpdateKeyFocus(bool state);\r\n\t\tvoid olc_Terminate();\r\n\t\tvoid olc_DropFiles(int32_t x, int32_t y, const std::vector<std::string>& vFiles);\r\n\t\tvoid olc_Reanimate();\r\n\t\tbool olc_IsRunning();\r\n\r\n\t\t// At the very end of this file, chooses which\r\n\t\t// components to compile\r\n\t\tvirtual void olc_ConfigureSystem();\r\n\r\n\t\t// NOTE: Items Here are to be deprecated, I have left them in for now\r\n\t\t// in case you are using them, but they will be removed.\r\n\t\t// olc::vf2d\tvSubPixelOffset = { 0.0f, 0.0f };\r\n\r\n\tpublic: // PGEX Stuff\r\n\t\tfriend class PGEX;\r\n\t\tvoid pgex_Register(olc::PGEX* pgex);\r\n\r\n\tprivate:\r\n\t\tstd::vector<olc::PGEX*> vExtensions;\r\n\t};\r\n\r\n\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | PGE EXTENSION BASE CLASS - Permits access to PGE functions from extension    |\r\n\t// O------------------------------------------------------------------------------O\r\n\tclass PGEX\r\n\t{\r\n\t\tfriend class olc::PixelGameEngine;\r\n\tpublic:\r\n\t\tPGEX(bool bHook = false);\r\n\r\n\tprotected:\r\n\t\tvirtual void OnBeforeUserCreate();\r\n\t\tvirtual void OnAfterUserCreate();\r\n\t\tvirtual bool OnBeforeUserUpdate(float &fElapsedTime);\r\n\t\tvirtual void OnAfterUserUpdate(float fElapsedTime);\r\n\r\n\tprotected:\r\n\t\tstatic PixelGameEngine* pge;\r\n\t};\r\n}\r\n\r\n#pragma endregion\r\n\r\n\r\n#pragma region opengl33_iface\r\n// In order to facilitate more advanced graphics features, some PGEX\r\n// will rely on shaders. Instead of having each PGEX responsible for\r\n// managing this, for convenience, this interface exists.\r\n\r\n#if defined(OLC_GFX_OPENGL33)\r\n\r\n\t#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t#include <gl/GL.h>\r\n\t\t#define CALLSTYLE __stdcall\r\n\t#endif\r\n\r\n\t#if defined(__linux__) || defined(__FreeBSD__)\r\n\t\t#include <GL/gl.h>\r\n\t#endif\r\n\r\n\t#if defined(OLC_PLATFORM_X11)\r\n\t\tnamespace X11 {\r\n\t\t\t#include <GL/glx.h>\r\n\t\t}\r\n\t\t#define CALLSTYLE \r\n\t#endif\r\n\r\n\t#if defined(__APPLE__)\r\n\t\t#define GL_SILENCE_DEPRECATION\r\n\t\t#include <OpenGL/OpenGL.h>\r\n\t\t#include <OpenGL/gl.h>\r\n\t\t#include <OpenGL/glu.h>\r\n\t#endif\r\n\r\n\t#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t#include <EGL/egl.h>\r\n\t\t#include <GLES2/gl2.h>\r\n\t\t#define GL_GLEXT_PROTOTYPES\r\n\t\t#include <GLES2/gl2ext.h>\r\n\t\t#include <emscripten/emscripten.h>\r\n\t\t#define CALLSTYLE\r\n\t\t#define GL_CLAMP GL_CLAMP_TO_EDGE\r\n\t#endif\r\n\r\nnamespace olc\r\n{\r\n\ttypedef char GLchar;\r\n\ttypedef ptrdiff_t GLsizeiptr;\r\n\r\n\ttypedef GLuint CALLSTYLE locCreateShader_t(GLenum type);\r\n\ttypedef GLuint CALLSTYLE locCreateProgram_t(void);\r\n\ttypedef void CALLSTYLE locDeleteShader_t(GLuint shader);\r\n\ttypedef void CALLSTYLE locCompileShader_t(GLuint shader);\r\n\ttypedef void CALLSTYLE locLinkProgram_t(GLuint program);\r\n\ttypedef void CALLSTYLE locDeleteProgram_t(GLuint program);\r\n\ttypedef void CALLSTYLE locAttachShader_t(GLuint program, GLuint shader);\r\n\ttypedef void CALLSTYLE locBindBuffer_t(GLenum target, GLuint buffer);\r\n\ttypedef void CALLSTYLE locBufferData_t(GLenum target, GLsizeiptr size, const void* data, GLenum usage);\r\n\ttypedef void CALLSTYLE locGenBuffers_t(GLsizei n, GLuint* buffers);\r\n\ttypedef void CALLSTYLE locVertexAttribPointer_t(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);\r\n\ttypedef void CALLSTYLE locEnableVertexAttribArray_t(GLuint index);\r\n\ttypedef void CALLSTYLE locUseProgram_t(GLuint program);\r\n\ttypedef void CALLSTYLE locBindVertexArray_t(GLuint array);\r\n\ttypedef void CALLSTYLE locGenVertexArrays_t(GLsizei n, GLuint* arrays);\r\n\ttypedef void CALLSTYLE locGetShaderInfoLog_t(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);\r\n\ttypedef GLint CALLSTYLE locGetUniformLocation_t(GLuint program, const GLchar* name);\r\n\ttypedef void CALLSTYLE locUniform1f_t(GLint location, GLfloat v0);\r\n\ttypedef void CALLSTYLE locUniform1i_t(GLint location, GLint v0);\r\n\ttypedef void CALLSTYLE locUniform2fv_t(GLint location, GLsizei count, const GLfloat* value);\r\n\ttypedef void CALLSTYLE locActiveTexture_t(GLenum texture);\r\n\ttypedef void CALLSTYLE locGenFrameBuffers_t(GLsizei n, GLuint* ids);\r\n\ttypedef void CALLSTYLE locBindFrameBuffer_t(GLenum target, GLuint fb);\r\n\ttypedef GLenum CALLSTYLE locCheckFrameBufferStatus_t(GLenum target);\r\n\ttypedef void CALLSTYLE locDeleteFrameBuffers_t(GLsizei n, const GLuint* fbs);\r\n\ttypedef void CALLSTYLE locFrameBufferTexture2D_t(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);\r\n\ttypedef void CALLSTYLE locDrawBuffers_t(GLsizei n, const GLenum* bufs);\r\n\ttypedef void CALLSTYLE locBlendFuncSeparate_t(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);\r\n\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\ttypedef void __stdcall locSwapInterval_t(GLsizei n);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\ttypedef int(locSwapInterval_t)(X11::Display* dpy, X11::GLXDrawable drawable, int interval);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\ttypedef void CALLSTYLE locShaderSource_t(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);\r\n\ttypedef EGLBoolean(locSwapInterval_t)(EGLDisplay display, EGLint interval);\r\n#else\r\n\ttypedef void CALLSTYLE locShaderSource_t(GLuint shader, GLsizei count, const GLchar** string, const GLint* length);\r\n#endif\r\n\r\n} // olc namespace\r\n#endif // OpenGL33 Definitions\r\n#pragma endregion\r\n\r\n\r\n#endif // OLC_PGE_DEF\r\n\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | START OF OLC_PGE_APPLICATION                                                 |\r\n// O------------------------------------------------------------------------------O\r\n#ifdef OLC_PGE_APPLICATION\r\n#undef OLC_PGE_APPLICATION\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine INTERFACE IMPLEMENTATION (CORE)                           |\r\n// | Note: The core implementation is platform independent                        |\r\n// O------------------------------------------------------------------------------O\r\n#pragma region pge_implementation\r\nnamespace olc\r\n{\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Pixel IMPLEMENTATION                                                    |\r\n\t// O------------------------------------------------------------------------------O\r\n#if !defined(OLC_IGNORE_PIXEL)\r\n\tPixel::Pixel()\r\n\t{ r = 0; g = 0; b = 0; a = nDefaultAlpha; }\r\n\r\n\tPixel::Pixel(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha)\r\n\t{ n = red | (green << 8) | (blue << 16) | (alpha << 24); } // Thanks jarekpelczar \r\n\r\n\tPixel::Pixel(uint32_t p)\r\n\t{ n = p; }\r\n\r\n\tbool Pixel::operator==(const Pixel& p) const\r\n\t{ return n == p.n; }\r\n\r\n\tbool Pixel::operator!=(const Pixel& p) const\r\n\t{ return n != p.n; }\r\n\r\n\tPixel  Pixel::operator * (const float i) const\r\n\t{\r\n\t\tfloat fR = std::min(255.0f, std::max(0.0f, float(r) * i));\r\n\t\tfloat fG = std::min(255.0f, std::max(0.0f, float(g) * i));\r\n\t\tfloat fB = std::min(255.0f, std::max(0.0f, float(b) * i));\r\n\t\treturn Pixel(uint8_t(fR), uint8_t(fG), uint8_t(fB), a);\r\n\t}\r\n\r\n\tPixel  Pixel::operator / (const float i) const\r\n\t{\r\n\t\tfloat fR = std::min(255.0f, std::max(0.0f, float(r) / i));\r\n\t\tfloat fG = std::min(255.0f, std::max(0.0f, float(g) / i));\r\n\t\tfloat fB = std::min(255.0f, std::max(0.0f, float(b) / i));\r\n\t\treturn Pixel(uint8_t(fR), uint8_t(fG), uint8_t(fB), a);\r\n\t}\r\n\r\n\tPixel& Pixel::operator *=(const float i)\r\n\t{\r\n\t\tthis->r = uint8_t(std::min(255.0f, std::max(0.0f, float(r) * i)));\r\n\t\tthis->g = uint8_t(std::min(255.0f, std::max(0.0f, float(g) * i)));\r\n\t\tthis->b = uint8_t(std::min(255.0f, std::max(0.0f, float(b) * i)));\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPixel& Pixel::operator /=(const float i)\r\n\t{\r\n\t\tthis->r = uint8_t(std::min(255.0f, std::max(0.0f, float(r) / i)));\r\n\t\tthis->g = uint8_t(std::min(255.0f, std::max(0.0f, float(g) / i)));\r\n\t\tthis->b = uint8_t(std::min(255.0f, std::max(0.0f, float(b) / i)));\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPixel  Pixel::operator + (const Pixel& p) const\r\n\t{\r\n\t\tuint8_t nR = uint8_t(std::min(255, std::max(0, int(r) + int(p.r))));\r\n\t\tuint8_t nG = uint8_t(std::min(255, std::max(0, int(g) + int(p.g))));\r\n\t\tuint8_t nB = uint8_t(std::min(255, std::max(0, int(b) + int(p.b))));\r\n\t\treturn Pixel(nR, nG, nB, a);\r\n\t}\r\n\r\n\tPixel  Pixel::operator - (const Pixel& p) const\r\n\t{\r\n\t\tuint8_t nR = uint8_t(std::min(255, std::max(0, int(r) - int(p.r))));\r\n\t\tuint8_t nG = uint8_t(std::min(255, std::max(0, int(g) - int(p.g))));\r\n\t\tuint8_t nB = uint8_t(std::min(255, std::max(0, int(b) - int(p.b))));\r\n\t\treturn Pixel(nR, nG, nB, a);\r\n\t}\r\n\r\n\tPixel& Pixel::operator += (const Pixel& p)\r\n\t{\r\n\t\tthis->r = uint8_t(std::min(255, std::max(0, int(r) + int(p.r))));\r\n\t\tthis->g = uint8_t(std::min(255, std::max(0, int(g) + int(p.g))));\r\n\t\tthis->b = uint8_t(std::min(255, std::max(0, int(b) + int(p.b))));\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPixel& Pixel::operator -= (const Pixel& p) // Thanks Au Lit\r\n\t{\r\n\t\tthis->r = uint8_t(std::min(255, std::max(0, int(r) - int(p.r))));\r\n\t\tthis->g = uint8_t(std::min(255, std::max(0, int(g) - int(p.g))));\r\n\t\tthis->b = uint8_t(std::min(255, std::max(0, int(b) - int(p.b))));\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPixel Pixel::operator * (const Pixel& p) const\r\n\t{\r\n\t\tuint8_t nR = uint8_t(std::min(255.0f, std::max(0.0f, float(r) * float(p.r) / 255.0f)));\r\n\t\tuint8_t nG = uint8_t(std::min(255.0f, std::max(0.0f, float(g) * float(p.g) / 255.0f)));\r\n\t\tuint8_t nB = uint8_t(std::min(255.0f, std::max(0.0f, float(b) * float(p.b) / 255.0f)));\r\n\t\tuint8_t nA = uint8_t(std::min(255.0f, std::max(0.0f, float(a) * float(p.a) / 255.0f)));\r\n\t\treturn Pixel(nR, nG, nB, nA);\r\n\t}\r\n\r\n\tPixel& Pixel::operator *=(const Pixel& p)\r\n\t{\r\n\t\tthis->r = uint8_t(std::min(255.0f, std::max(0.0f, float(r) * float(p.r) / 255.0f)));\r\n\t\tthis->g = uint8_t(std::min(255.0f, std::max(0.0f, float(g) * float(p.g) / 255.0f)));\r\n\t\tthis->b = uint8_t(std::min(255.0f, std::max(0.0f, float(b) * float(p.b) / 255.0f)));\r\n\t\tthis->a = uint8_t(std::min(255.0f, std::max(0.0f, float(a) * float(p.a) / 255.0f)));\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPixel Pixel::inv() const\r\n\t{\r\n\t\tuint8_t nR = uint8_t(std::min(255, std::max(0, 255 - int(r))));\r\n\t\tuint8_t nG = uint8_t(std::min(255, std::max(0, 255 - int(g))));\r\n\t\tuint8_t nB = uint8_t(std::min(255, std::max(0, 255 - int(b))));\r\n\t\treturn Pixel(nR, nG, nB, a);\r\n\t}\r\n\r\n\tPixel PixelF(float red, float green, float blue, float alpha)\r\n\t{ return Pixel(uint8_t(red * 255.0f), uint8_t(green * 255.0f), uint8_t(blue * 255.0f), uint8_t(alpha * 255.0f)); }\r\n\r\n\tPixel PixelLerp(const olc::Pixel& p1, const olc::Pixel& p2, float t)\r\n\t{ return (p2 * t) + p1 * (1.0f - t); }\r\n#endif\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Sprite IMPLEMENTATION                                                   |\r\n\t// O------------------------------------------------------------------------------O\r\n\tSprite::Sprite()\r\n\t{ width = 0; height = 0; }\r\n\r\n\tSprite::Sprite(const std::string& sImageFile, olc::ResourcePack* pack)\r\n\t{ LoadFromFile(sImageFile, pack); }\r\n\r\n\tSprite::Sprite(int32_t w, int32_t h)\r\n\t{\t\t\r\n\t\tSetSize(w, h);\r\n\t}\r\n\r\n\tvoid Sprite::SetSize(int32_t w, int32_t h)\r\n\t{\r\n\t\twidth = w;\t\theight = h;\r\n\t\tpColData.resize(width * height, nDefaultPixel);\r\n\t}\r\n\r\n\tSprite::~Sprite()\r\n\t{ pColData.clear();\t}\r\n\r\n\tvoid Sprite::SetSampleMode(olc::Sprite::Mode mode)\r\n\t{ modeSample = mode; }\r\n\r\n\tPixel Sprite::GetPixel(const olc::vi2d& a) const\r\n\t{ return GetPixel(a.x, a.y); }\r\n\r\n\tbool Sprite::SetPixel(const olc::vi2d& a, Pixel p)\r\n\t{ return SetPixel(a.x, a.y, p); }\r\n\r\n\tPixel Sprite::GetPixel(int32_t x, int32_t y) const\r\n\t{\r\n\t\tif (modeSample == olc::Sprite::Mode::NORMAL)\r\n\t\t{\r\n\t\t\tif (x >= 0 && x < width && y >= 0 && y < height)\r\n\t\t\t\treturn pColData[y * width + x];\r\n\t\t\telse\r\n\t\t\t\treturn Pixel(0, 0, 0, 0);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (modeSample == olc::Sprite::Mode::PERIODIC)\r\n\t\t\t\treturn pColData[abs(y % height) * width + abs(x % width)];\r\n\t\t\telse\r\n\t\t\t\treturn pColData[std::max(0, std::min(y, height-1)) * width + std::max(0, std::min(x, width-1))];\r\n\t\t}\r\n\t}\r\n\r\n\tbool Sprite::SetPixel(int32_t x, int32_t y, Pixel p)\r\n\t{\r\n\t\tif (x >= 0 && x < width && y >= 0 && y < height)\r\n\t\t{\r\n\t\t\tpColData[y * width + x] = p;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\tPixel Sprite::Sample(float x, float y) const\r\n\t{\r\n\t\tint32_t sx = std::min((int32_t)((x * (float)width)), width - 1);\r\n\t\tint32_t sy = std::min((int32_t)((y * (float)height)), height - 1);\r\n\t\treturn GetPixel(sx, sy);\r\n\t}\r\n\r\n\tPixel Sprite::Sample(const olc::vf2d& uv) const\r\n\t{\r\n\t\treturn Sample(uv.x, uv.y);\r\n\t}\r\n\r\n\tPixel Sprite::SampleBL(float u, float v) const\r\n\t{\r\n\t\tu = u * width - 0.5f;\r\n\t\tv = v * height - 0.5f;\r\n\t\tint x = (int)floor(u); // cast to int rounds toward zero, not downward\r\n\t\tint y = (int)floor(v); // Thanks @joshinils\r\n\t\tfloat u_ratio = u - x;\r\n\t\tfloat v_ratio = v - y;\r\n\t\tfloat u_opposite = 1 - u_ratio;\r\n\t\tfloat v_opposite = 1 - v_ratio;\r\n\r\n\t\tolc::Pixel p1 = GetPixel(std::max(x, 0), std::max(y, 0));\r\n\t\tolc::Pixel p2 = GetPixel(std::min(x + 1, (int)width - 1), std::max(y, 0));\r\n\t\tolc::Pixel p3 = GetPixel(std::max(x, 0), std::min(y + 1, (int)height - 1));\r\n\t\tolc::Pixel p4 = GetPixel(std::min(x + 1, (int)width - 1), std::min(y + 1, (int)height - 1));\r\n\r\n\t\treturn olc::Pixel(\r\n\t\t\t(uint8_t)((p1.r * u_opposite + p2.r * u_ratio) * v_opposite + (p3.r * u_opposite + p4.r * u_ratio) * v_ratio),\r\n\t\t\t(uint8_t)((p1.g * u_opposite + p2.g * u_ratio) * v_opposite + (p3.g * u_opposite + p4.g * u_ratio) * v_ratio),\r\n\t\t\t(uint8_t)((p1.b * u_opposite + p2.b * u_ratio) * v_opposite + (p3.b * u_opposite + p4.b * u_ratio) * v_ratio));\r\n\t}\r\n\r\n\tPixel Sprite::SampleBL(const olc::vf2d& uv) const\r\n\t{\r\n\t\treturn SampleBL(uv.x, uv.y);\r\n\t}\r\n\r\n\tPixel* Sprite::GetData()\r\n\t{ return pColData.data(); }\r\n\r\n\r\n\tolc::rcode Sprite::LoadFromFile(const std::string& sImageFile, olc::ResourcePack* pack)\r\n\t{\r\n\t\tUNUSED(pack);\r\n\t\treturn loader->LoadImageResource(this, sImageFile, pack);\r\n\t}\r\n\r\n\tolc::Sprite* Sprite::Duplicate()\r\n\t{\r\n\t\tolc::Sprite* spr = new olc::Sprite(width, height);\r\n\t\tstd::memcpy(spr->GetData(), GetData(), width * height * sizeof(olc::Pixel));\r\n\t\tspr->modeSample = modeSample;\r\n\t\treturn spr;\r\n\t}\r\n\r\n\tolc::Sprite* Sprite::Duplicate(const olc::vi2d& vPos, const olc::vi2d& vSize)\r\n\t{\r\n\t\tolc::Sprite* spr = new olc::Sprite(vSize.x, vSize.y);\r\n\t\tfor (int y = 0; y < vSize.y; y++)\r\n\t\t\tfor (int x = 0; x < vSize.x; x++)\r\n\t\t\t\tspr->SetPixel(x, y, GetPixel(vPos.x + x, vPos.y + y));\r\n\t\treturn spr;\r\n\t}\r\n\r\n\tolc::vi2d olc::Sprite::Size() const\r\n\t{\r\n\t\treturn { width, height };\r\n\t}\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::Decal IMPLEMENTATION                                                    |\r\n\t// O------------------------------------------------------------------------------O\r\n\tDecal::Decal(olc::Sprite* spr, bool filter, bool clamp)\r\n\t{\r\n\t\tid = -1;\r\n\t\tif (spr == nullptr) return;\r\n\t\tsprite = spr;\r\n\t\tid = renderer->CreateTexture(sprite->width, sprite->height, filter, clamp);\r\n\t\tUpdate();\r\n\t}\r\n\r\n\tDecal::Decal(const uint32_t nExistingTextureResource, olc::Sprite* spr)\r\n\t{\r\n\t\tif (spr == nullptr) return;\r\n\t\tid = nExistingTextureResource;\r\n\t}\r\n\r\n\tvoid Decal::Update()\r\n\t{\r\n\t\tif (sprite == nullptr) return;\r\n\t\tvUVScale = { 1.0f / float(sprite->width), 1.0f / float(sprite->height) };\r\n\t\trenderer->ApplyTexture(id);\r\n\t\trenderer->UpdateTexture(id, sprite);\r\n\t}\r\n\r\n\tvoid Decal::UpdateSprite()\r\n\t{\r\n\t\tif (sprite == nullptr) return;\r\n\t\trenderer->ApplyTexture(id);\r\n\t\trenderer->ReadTexture(id, sprite);\r\n\t}\r\n\r\n\tDecal::~Decal()\r\n\t{\r\n\t\tif (id != -1)\r\n\t\t{\r\n\t\t\trenderer->DeleteTexture(id);\r\n\t\t\tid = -1;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid Renderable::Create(uint32_t width, uint32_t height, bool filter, bool clamp)\r\n\t{\r\n\t\tpSprite = std::make_unique<olc::Sprite>(width, height);\r\n\t\tpDecal = std::make_unique<olc::Decal>(pSprite.get(), filter, clamp);\r\n\t}\r\n\r\n\tolc::rcode Renderable::Load(const std::string& sFile, ResourcePack* pack, bool filter, bool clamp)\r\n\t{\r\n\t\tpSprite = std::make_unique<olc::Sprite>();\r\n\t\tif (pSprite->LoadFromFile(sFile, pack) == olc::rcode::OK)\r\n\t\t{\r\n\t\t\tpDecal = std::make_unique<olc::Decal>(pSprite.get(), filter, clamp);\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpSprite.release();\r\n\t\t\tpSprite = nullptr;\r\n\t\t\treturn olc::rcode::NO_FILE;\r\n\t\t}\r\n\t}\r\n\r\n\tolc::Decal* Renderable::Decal() const\r\n\t{ return pDecal.get(); }\r\n\r\n\tolc::Sprite* Renderable::Sprite() const\r\n\t{ return pSprite.get(); }\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::ResourcePack IMPLEMENTATION                                             |\r\n\t// O------------------------------------------------------------------------------O\r\n\r\n\r\n\t//=============================================================\r\n\t// Resource Packs - Allows you to store files in one large \r\n\t// scrambled file - Thanks MaGetzUb for debugging a null char in std::stringstream bug\r\n\tResourceBuffer::ResourceBuffer(std::ifstream& ifs, uint32_t offset, uint32_t size)\r\n\t{\r\n\t\tvMemory.resize(size);\r\n\t\tifs.seekg(offset); ifs.read(vMemory.data(), vMemory.size());\r\n\t\tsetg(vMemory.data(), vMemory.data(), vMemory.data() + size);\r\n\t}\r\n\r\n\tResourcePack::ResourcePack() { }\r\n\tResourcePack::~ResourcePack() { baseFile.close(); }\r\n\r\n\tbool ResourcePack::AddFile(const std::string& sFile)\r\n\t{\r\n\t\tconst std::string file = makeposix(sFile);\r\n\r\n\t\tif (_gfs::exists(file))\r\n\t\t{\r\n\t\t\tsResourceFile e;\r\n\t\t\te.nSize = (uint32_t)_gfs::file_size(file);\r\n\t\t\te.nOffset = 0; // Unknown at this stage\t\t\t\r\n\t\t\tmapFiles[file] = e;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tbool ResourcePack::LoadPack(const std::string& sFile, const std::string& sKey)\r\n\t{\r\n\t\t// Open the resource file\r\n\t\tbaseFile.open(sFile, std::ifstream::binary);\r\n\t\tif (!baseFile.is_open()) return false;\r\n\r\n\t\t// 1) Read Scrambled index\r\n\t\tuint32_t nIndexSize = 0;\r\n\t\tbaseFile.read((char*)&nIndexSize, sizeof(uint32_t));\r\n\r\n\t\tstd::vector<char> buffer(nIndexSize);\r\n\t\tfor (uint32_t j = 0; j < nIndexSize; j++)\r\n\t\t\tbuffer[j] = baseFile.get();\r\n\r\n\t\tstd::vector<char> decoded = scramble(buffer, sKey);\r\n\t\tsize_t pos = 0;\r\n\t\tauto read = [&decoded, &pos](char* dst, size_t size) {\r\n\t\t\tmemcpy((void*)dst, (const void*)(decoded.data() + pos), size);\r\n\t\t\tpos += size;\r\n\t\t};\r\n\r\n\t\tauto get = [&read]() -> int { char c; read(&c, 1); return c; };\r\n\r\n\t\t// 2) Read Map\r\n\t\tuint32_t nMapEntries = 0;\r\n\t\tread((char*)&nMapEntries, sizeof(uint32_t));\r\n\t\tfor (uint32_t i = 0; i < nMapEntries; i++)\r\n\t\t{\r\n\t\t\tuint32_t nFilePathSize = 0;\r\n\t\t\tread((char*)&nFilePathSize, sizeof(uint32_t));\r\n\r\n\t\t\tstd::string sFileName(nFilePathSize, ' ');\r\n\t\t\tfor (uint32_t j = 0; j < nFilePathSize; j++)\r\n\t\t\t\tsFileName[j] = get();\r\n\r\n\t\t\tsResourceFile e;\r\n\t\t\tread((char*)&e.nSize, sizeof(uint32_t));\r\n\t\t\tread((char*)&e.nOffset, sizeof(uint32_t));\r\n\t\t\tmapFiles[sFileName] = e;\r\n\t\t}\r\n\r\n\t\t// Don't close base file! we will provide a stream\r\n\t\t// pointer when the file is requested\r\n\t\treturn true;\r\n\t}\r\n\r\n\tbool ResourcePack::SavePack(const std::string& sFile, const std::string& sKey)\r\n\t{\r\n\t\t// Create/Overwrite the resource file\r\n\t\tstd::ofstream ofs(sFile, std::ofstream::binary);\r\n\t\tif (!ofs.is_open()) return false;\r\n\r\n\t\t// Iterate through map\r\n\t\tuint32_t nIndexSize = 0; // Unknown for now\r\n\t\tofs.write((char*)&nIndexSize, sizeof(uint32_t));\r\n\t\tuint32_t nMapSize = uint32_t(mapFiles.size());\r\n\t\tofs.write((char*)&nMapSize, sizeof(uint32_t));\r\n\t\tfor (auto& e : mapFiles)\r\n\t\t{\r\n\t\t\t// Write the path of the file\r\n\t\t\tsize_t nPathSize = e.first.size();\r\n\t\t\tofs.write((char*)&nPathSize, sizeof(uint32_t));\r\n\t\t\tofs.write(e.first.c_str(), nPathSize);\r\n\r\n\t\t\t// Write the file entry properties\r\n\t\t\tofs.write((char*)&e.second.nSize, sizeof(uint32_t));\r\n\t\t\tofs.write((char*)&e.second.nOffset, sizeof(uint32_t));\r\n\t\t}\r\n\r\n\t\t// 2) Write the individual Data\r\n\t\tstd::streampos offset = ofs.tellp();\r\n\t\tnIndexSize = (uint32_t)offset;\r\n\t\tfor (auto& e : mapFiles)\r\n\t\t{\r\n\t\t\t// Store beginning of file offset within resource pack file\r\n\t\t\te.second.nOffset = (uint32_t)offset;\r\n\r\n\t\t\t// Load the file to be added\r\n\t\t\tstd::vector<uint8_t> vBuffer(e.second.nSize);\r\n\t\t\tstd::ifstream i(e.first, std::ifstream::binary);\r\n\t\t\ti.read((char*)vBuffer.data(), e.second.nSize);\r\n\t\t\ti.close();\r\n\r\n\t\t\t// Write the loaded file into resource pack file\r\n\t\t\tofs.write((char*)vBuffer.data(), e.second.nSize);\r\n\t\t\toffset += e.second.nSize;\r\n\t\t}\r\n\r\n\t\t// 3) Scramble Index\r\n\t\tstd::vector<char> stream;\r\n\t\tauto write = [&stream](const char* data, size_t size) {\r\n\t\t\tsize_t sizeNow = stream.size();\r\n\t\t\tstream.resize(sizeNow + size);\r\n\t\t\tmemcpy(stream.data() + sizeNow, data, size);\r\n\t\t};\r\n\r\n\t\t// Iterate through map\r\n\t\twrite((char*)&nMapSize, sizeof(uint32_t));\r\n\t\tfor (auto& e : mapFiles)\r\n\t\t{\r\n\t\t\t// Write the path of the file\r\n\t\t\tsize_t nPathSize = e.first.size();\r\n\t\t\twrite((char*)&nPathSize, sizeof(uint32_t));\r\n\t\t\twrite(e.first.c_str(), nPathSize);\r\n\r\n\t\t\t// Write the file entry properties\r\n\t\t\twrite((char*)&e.second.nSize, sizeof(uint32_t));\r\n\t\t\twrite((char*)&e.second.nOffset, sizeof(uint32_t));\r\n\t\t}\r\n\t\tstd::vector<char> sIndexString = scramble(stream, sKey);\r\n\t\tuint32_t nIndexStringLen = uint32_t(sIndexString.size());\r\n\t\t// 4) Rewrite Map (it has been updated with offsets now)\r\n\t\t// at start of file\r\n\t\tofs.seekp(0, std::ios::beg);\r\n\t\tofs.write((char*)&nIndexStringLen, sizeof(uint32_t));\r\n\t\tofs.write(sIndexString.data(), nIndexStringLen);\r\n\t\tofs.close();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tResourceBuffer ResourcePack::GetFileBuffer(const std::string& sFile)\r\n\t{ return ResourceBuffer(baseFile, mapFiles[sFile].nOffset, mapFiles[sFile].nSize); }\r\n\r\n\tbool ResourcePack::Loaded()\r\n\t{ return baseFile.is_open(); }\r\n\r\n\tstd::vector<char> ResourcePack::scramble(const std::vector<char>& data, const std::string& key)\r\n\t{\r\n\t\tif (key.empty()) return data;\r\n\t\tstd::vector<char> o;\r\n\t\tsize_t c = 0;\r\n\t\tfor (auto s : data)\to.push_back(s ^ key[(c++) % key.size()]);\r\n\t\treturn o;\r\n\t};\r\n\r\n\tstd::string ResourcePack::makeposix(const std::string& path)\r\n\t{\r\n\t\tstd::string o;\r\n\t\tfor (auto s : path) o += std::string(1, s == '\\\\' ? '/' : s);\r\n\t\treturn o;\r\n\t};\r\n\r\n\t// O------------------------------------------------------------------------------O\r\n\t// | olc::PixelGameEngine IMPLEMENTATION                                          |\r\n\t// O------------------------------------------------------------------------------O\r\n\tPixelGameEngine::PixelGameEngine()\r\n\t{\r\n\t\tsAppName = \"Undefined\";\r\n\t\tolc::PGEX::pge = this;\r\n\r\n\t\t// Bring in relevant Platform & Rendering systems depending\r\n\t\t// on compiler parameters\r\n\t\tolc_ConfigureSystem();\r\n\t}\r\n\r\n\tPixelGameEngine::~PixelGameEngine()\r\n\t{}\r\n\r\n\r\n\tolc::rcode PixelGameEngine::Construct(int32_t screen_w, int32_t screen_h, int32_t pixel_w, int32_t pixel_h, bool full_screen, bool vsync, bool cohesion, bool realwindow)\r\n\t{\r\n\t\tbPixelCohesion = cohesion;\r\n\t\tbRealWindowMode = realwindow;\r\n\t\tvScreenSize = { screen_w, screen_h };\r\n\t\tvInvScreenSize = { 1.0f / float(screen_w), 1.0f / float(screen_h) };\r\n\t\tvPixelSize = { pixel_w, pixel_h };\r\n\t\tvWindowSize = vScreenSize * vPixelSize;\r\n\t\tbFullScreen = full_screen;\r\n\t\tbEnableVSYNC = vsync;\r\n\t\tvPixel = 2.0f / vScreenSize;\r\n\r\n\t\tif (vPixelSize.x <= 0 || vPixelSize.y <= 0 || vScreenSize.x <= 0 || vScreenSize.y <= 0)\r\n\t\t\treturn olc::FAIL;\r\n\t\treturn olc::OK;\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::SetScreenSize(int w, int h)\r\n\t{\r\n\t\tvScreenSize = { w, h };\r\n\t\tvInvScreenSize = { 1.0f / float(w), 1.0f / float(h) };\r\n\t\tfor (auto& layer : vLayers)\r\n\t\t{\r\n\t\t\tlayer.pDrawTarget.Create(vScreenSize.x, vScreenSize.y);\r\n\t\t\tlayer.bUpdate = true;\r\n\t\t}\r\n\t\tSetDrawTarget(nullptr);\r\n\t\tif (!bRealWindowMode)\r\n\t\t{\r\n\t\t\t// Flush backbuffer\r\n\t\t\trenderer->ClearBuffer(olc::BLACK, true);\r\n\t\t\trenderer->DisplayFrame();\r\n\t\t\trenderer->ClearBuffer(olc::BLACK, true);\r\n\t\t}\r\n\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t}\r\n\r\n#if !defined(PGE_USE_CUSTOM_START)\r\n\tolc::rcode PixelGameEngine::Start()\r\n\t{\r\n\t\tif (platform->ApplicationStartUp() != olc::OK) return olc::FAIL;\r\n\r\n\t\t// Construct the window\r\n\t\tif (platform->CreateWindowPane({ 30,30 }, vWindowSize, bFullScreen) != olc::OK) return olc::FAIL;\r\n\t\tolc_UpdateWindowSize(vWindowSize.x, vWindowSize.y);\r\n\r\n\t\t// Start the thread\r\n\t\tbAtomActive = true;\r\n\t\tstd::thread t = std::thread(&PixelGameEngine::EngineThread, this);\r\n\r\n\t\t// Some implementations may form an event loop here\r\n\t\tplatform->StartSystemEventLoop();\r\n\r\n\t\t// Wait for thread to be exited\r\n\t\tt.join();\r\n\r\n\t\tif (platform->ApplicationCleanUp() != olc::OK) return olc::FAIL;\r\n\r\n\t\treturn olc::OK;\r\n\t}\r\n#endif\r\n\r\n\tvoid PixelGameEngine::SetDrawTarget(Sprite* target)\r\n\t{\r\n\t\tif (target)\r\n\t\t{\r\n\t\t\tpDrawTarget = target;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnTargetLayer = 0;\r\n\t\t\tif(!vLayers.empty())\r\n\t\t\t\tpDrawTarget = vLayers[0].pDrawTarget.Sprite();\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::SetDrawTarget(uint8_t layer, bool bDirty)\r\n\t{\r\n\t\tif (layer < vLayers.size())\r\n\t\t{\r\n\t\t\tpDrawTarget = vLayers[layer].pDrawTarget.Sprite();\r\n\t\t\tvLayers[layer].bUpdate = bDirty;\r\n\t\t\tnTargetLayer = layer;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::EnableLayer(uint8_t layer, bool b)\r\n\t{ if (layer < vLayers.size()) vLayers[layer].bShow = b; }\r\n\r\n\tvoid PixelGameEngine::SetLayerOffset(uint8_t layer, const olc::vf2d& offset)\r\n\t{ SetLayerOffset(layer, offset.x, offset.y); }\r\n\r\n\tvoid PixelGameEngine::SetLayerOffset(uint8_t layer, float x, float y)\r\n\t{ if (layer < vLayers.size()) vLayers[layer].vOffset = { x, y }; }\r\n\r\n\tvoid PixelGameEngine::SetLayerScale(uint8_t layer, const olc::vf2d& scale)\r\n\t{ SetLayerScale(layer, scale.x, scale.y); }\r\n\r\n\tvoid PixelGameEngine::SetLayerScale(uint8_t layer, float x, float y)\r\n\t{ if (layer < vLayers.size()) vLayers[layer].vScale = { x, y }; }\r\n\r\n\tvoid PixelGameEngine::SetLayerTint(uint8_t layer, const olc::Pixel& tint)\r\n\t{ if (layer < vLayers.size()) vLayers[layer].tint = tint; }\r\n\r\n\tvoid PixelGameEngine::SetLayerCustomRenderFunction(uint8_t layer, std::function<void()> f)\r\n\t{ if (layer < vLayers.size()) vLayers[layer].funcHook = f; }\r\n\r\n\tstd::vector<LayerDesc>& PixelGameEngine::GetLayers()\r\n\t{ return vLayers; }\r\n\r\n\tuint32_t PixelGameEngine::CreateLayer()\r\n\t{\r\n\t\tLayerDesc ld;\r\n\t\tld.pDrawTarget.Create(vScreenSize.x, vScreenSize.y);\r\n\t\tvLayers.push_back(std::move(ld));\r\n\t\treturn uint32_t(vLayers.size()) - 1;\r\n\t}\r\n\r\n\tSprite* PixelGameEngine::GetDrawTarget() const\r\n\t{ return pDrawTarget; }\r\n\r\n\tint32_t PixelGameEngine::GetDrawTargetWidth() const\r\n\t{\r\n\t\tif (pDrawTarget)\r\n\t\t\treturn pDrawTarget->width;\r\n\t\telse\r\n\t\t\treturn 0;\r\n\t}\r\n\r\n\tint32_t PixelGameEngine::GetDrawTargetHeight() const\r\n\t{\r\n\t\tif (pDrawTarget)\r\n\t\t\treturn pDrawTarget->height;\r\n\t\telse\r\n\t\t\treturn 0;\r\n\t}\r\n\r\n\tuint32_t PixelGameEngine::GetFPS() const\r\n\t{ return nLastFPS; }\r\n\r\n\tbool PixelGameEngine::IsFocused() const\r\n\t{ return bHasInputFocus; }\r\n\r\n\tHWButton PixelGameEngine::GetKey(Key k) const\r\n\t{ return pKeyboardState[k];\t}\r\n\r\n\tHWButton PixelGameEngine::GetMouse(uint32_t b) const\r\n\t{ return pMouseState[b]; }\r\n\r\n\tint32_t PixelGameEngine::GetMouseX() const\r\n\t{ return vMousePos.x; }\r\n\r\n\tint32_t PixelGameEngine::GetMouseY() const\r\n\t{ return vMousePos.y; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetMousePos() const\r\n\t{ return vMousePos; }\r\n\r\n\tint32_t PixelGameEngine::GetMouseWheel() const\r\n\t{ return nMouseWheelDelta; }\r\n\r\n\tint32_t PixelGameEngine::ScreenWidth() const\r\n\t{ return vScreenSize.x; }\r\n\r\n\tint32_t PixelGameEngine::ScreenHeight() const\r\n\t{ return vScreenSize.y; }\r\n\r\n\tfloat PixelGameEngine::GetElapsedTime() const\r\n\t{ return fLastElapsed; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetWindowSize() const\r\n\t{ return vWindowSize; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetWindowPos() const\r\n\t{ return vWindowPos; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetPixelSize() const\r\n\t{ return vPixelSize; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetScreenPixelSize() const\r\n\t{ return vScreenPixelSize; }\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetScreenSize() const\r\n\t{ return vScreenSize;\t}\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetWindowMouse() const\r\n\t{ return vMouseWindowPos; }\r\n\r\n\tbool PixelGameEngine::Draw(const olc::vi2d& pos, Pixel p)\r\n\t{ return Draw(pos.x, pos.y, p); }\r\n\r\n\t// This is it, the critical function that plots a pixel\r\n\tbool PixelGameEngine::Draw(int32_t x, int32_t y, Pixel p)\r\n\t{\r\n\t\tif (!pDrawTarget) return false;\r\n\r\n\t\tif (nPixelMode == Pixel::NORMAL)\r\n\t\t{\r\n\t\t\treturn pDrawTarget->SetPixel(x, y, p);\r\n\t\t}\r\n\r\n\t\tif (nPixelMode == Pixel::MASK)\r\n\t\t{\r\n\t\t\tif (p.a == 255)\r\n\t\t\t\treturn pDrawTarget->SetPixel(x, y, p);\r\n\t\t}\r\n\r\n\t\tif (nPixelMode == Pixel::ALPHA)\r\n\t\t{\r\n\t\t\tPixel d = pDrawTarget->GetPixel(x, y);\r\n\t\t\tfloat a = (float)(p.a / 255.0f) * fBlendFactor;\r\n\t\t\tfloat c = 1.0f - a;\r\n\t\t\tfloat r = a * (float)p.r + c * (float)d.r;\r\n\t\t\tfloat g = a * (float)p.g + c * (float)d.g;\r\n\t\t\tfloat b = a * (float)p.b + c * (float)d.b;\r\n\t\t\treturn pDrawTarget->SetPixel(x, y, Pixel((uint8_t)r, (uint8_t)g, (uint8_t)b/*, (uint8_t)(p.a * fBlendFactor)*/));\r\n\t\t}\r\n\r\n\t\tif (nPixelMode == Pixel::CUSTOM)\r\n\t\t{\r\n\t\t\treturn pDrawTarget->SetPixel(x, y, funcPixelMode(x, y, p, pDrawTarget->GetPixel(x, y)));\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::DrawLine(const olc::vi2d& pos1, const olc::vi2d& pos2, Pixel p, uint32_t pattern)\r\n\t{ DrawLine(pos1.x, pos1.y, pos2.x, pos2.y, p, pattern); }\r\n\r\n\tvoid PixelGameEngine::DrawLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, Pixel p, uint32_t pattern)\r\n\t{\r\n\t\tint x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;\r\n\t\tdx = x2 - x1; dy = y2 - y1;\r\n\r\n\t\tauto rol = [&](void) { pattern = (pattern << 1) | (pattern >> 31); return pattern & 1; };\r\n\r\n\t\tolc::vi2d p1(x1, y1), p2(x2, y2);\r\n\t\tif (!ClipLineToScreen(p1, p2))\r\n\t\t\treturn;\r\n\t\tx1 = p1.x; y1 = p1.y;\r\n\t\tx2 = p2.x; y2 = p2.y;\r\n\r\n\t\t// straight lines idea by gurkanctn\r\n\t\tif (dx == 0) // Line is vertical\r\n\t\t{\r\n\t\t\tif (y2 < y1) std::swap(y1, y2);\r\n\t\t\tfor (y = y1; y <= y2; y++) if (rol()) Draw(x1, y, p);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (dy == 0) // Line is horizontal\r\n\t\t{\r\n\t\t\tif (x2 < x1) std::swap(x1, x2);\r\n\t\t\tfor (x = x1; x <= x2; x++) if (rol()) Draw(x, y1, p);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Line is Funk-aye\r\n\t\tdx1 = abs(dx); dy1 = abs(dy);\r\n\t\tpx = 2 * dy1 - dx1;\tpy = 2 * dx1 - dy1;\r\n\t\tif (dy1 <= dx1)\r\n\t\t{\r\n\t\t\tif (dx >= 0)\r\n\t\t\t{\r\n\t\t\t\tx = x1; y = y1; xe = x2;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx = x2; y = y2; xe = x1;\r\n\t\t\t}\r\n\r\n\t\t\tif (rol()) Draw(x, y, p);\r\n\r\n\t\t\tfor (i = 0; x < xe; i++)\r\n\t\t\t{\r\n\t\t\t\tx = x + 1;\r\n\t\t\t\tif (px < 0)\r\n\t\t\t\t\tpx = px + 2 * dy1;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) y = y + 1; else y = y - 1;\r\n\t\t\t\t\tpx = px + 2 * (dy1 - dx1);\r\n\t\t\t\t}\r\n\t\t\t\tif (rol()) Draw(x, y, p);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (dy >= 0)\r\n\t\t\t{\r\n\t\t\t\tx = x1; y = y1; ye = y2;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx = x2; y = y2; ye = y1;\r\n\t\t\t}\r\n\r\n\t\t\tif (rol()) Draw(x, y, p);\r\n\r\n\t\t\tfor (i = 0; y < ye; i++)\r\n\t\t\t{\r\n\t\t\t\ty = y + 1;\r\n\t\t\t\tif (py <= 0)\r\n\t\t\t\t\tpy = py + 2 * dx1;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) x = x + 1; else x = x - 1;\r\n\t\t\t\t\tpy = py + 2 * (dx1 - dy1);\r\n\t\t\t\t}\r\n\t\t\t\tif (rol()) Draw(x, y, p);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawCircle(const olc::vi2d& pos, int32_t radius, Pixel p, uint8_t mask)\r\n\t{ DrawCircle(pos.x, pos.y, radius, p, mask); }\r\n\r\n\tvoid PixelGameEngine::DrawCircle(int32_t x, int32_t y, int32_t radius, Pixel p, uint8_t mask)\r\n\t{ // Thanks to IanM-Matrix1 #PR121\r\n\t\tif (radius < 0 || x < -radius || y < -radius || x - GetDrawTargetWidth() > radius || y - GetDrawTargetHeight() > radius)\r\n\t\t\treturn;\r\n\r\n\t\tif (radius > 0)\r\n\t\t{\r\n\t\t\tint x0 = 0;\r\n\t\t\tint y0 = radius;\r\n\t\t\tint d = 3 - 2 * radius;\r\n\r\n\t\t\twhile (y0 >= x0) // only formulate 1/8 of circle\r\n\t\t\t{\r\n\t\t\t\t// Draw even octants\r\n\t\t\t\tif (mask & 0x01) Draw(x + x0, y - y0, p);// Q6 - upper right right\r\n\t\t\t\tif (mask & 0x04) Draw(x + y0, y + x0, p);// Q4 - lower lower right\r\n\t\t\t\tif (mask & 0x10) Draw(x - x0, y + y0, p);// Q2 - lower left left\r\n\t\t\t\tif (mask & 0x40) Draw(x - y0, y - x0, p);// Q0 - upper upper left\r\n\t\t\t\tif (x0 != 0 && x0 != y0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (mask & 0x02) Draw(x + y0, y - x0, p);// Q7 - upper upper right\r\n\t\t\t\t\tif (mask & 0x08) Draw(x + x0, y + y0, p);// Q5 - lower right right\r\n\t\t\t\t\tif (mask & 0x20) Draw(x - y0, y + x0, p);// Q3 - lower lower left\r\n\t\t\t\t\tif (mask & 0x80) Draw(x - x0, y - y0, p);// Q1 - upper left left\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (d < 0)\r\n\t\t\t\t\td += 4 * x0++ + 6;\r\n\t\t\t\telse\r\n\t\t\t\t\td += 4 * (x0++ - y0--) + 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tDraw(x, y, p);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillCircle(const olc::vi2d& pos, int32_t radius, Pixel p)\r\n\t{ FillCircle(pos.x, pos.y, radius, p); }\r\n\r\n\tvoid PixelGameEngine::FillCircle(int32_t x, int32_t y, int32_t radius, Pixel p)\r\n\t{ // Thanks to IanM-Matrix1 #PR121\r\n\t\tif (radius < 0 || x < -radius || y < -radius || x - GetDrawTargetWidth() > radius || y - GetDrawTargetHeight() > radius)\r\n\t\t\treturn;\r\n\r\n\t\tif (radius > 0)\r\n\t\t{\r\n\t\t\tint x0 = 0;\r\n\t\t\tint y0 = radius;\r\n\t\t\tint d = 3 - 2 * radius;\r\n\r\n\t\t\tauto drawline = [&](int sx, int ex, int y)\r\n\t\t\t{\r\n\t\t\t\tfor (int x = sx; x <= ex; x++)\r\n\t\t\t\t\tDraw(x, y, p);\r\n\t\t\t};\r\n\r\n\t\t\twhile (y0 >= x0)\r\n\t\t\t{\r\n\t\t\t\tdrawline(x - y0, x + y0, y - x0);\r\n\t\t\t\tif (x0 > 0)\tdrawline(x - y0, x + y0, y + x0);\r\n\r\n\t\t\t\tif (d < 0)\r\n\t\t\t\t\td += 4 * x0++ + 6;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (x0 != y0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdrawline(x - x0, x + x0, y - y0);\r\n\t\t\t\t\t\tdrawline(x - x0, x + x0, y + y0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\td += 4 * (x0++ - y0--) + 10;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tDraw(x, y, p);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawRect(const olc::vi2d& pos, const olc::vi2d& size, Pixel p)\r\n\t{ DrawRect(pos.x, pos.y, size.x, size.y, p); }\r\n\r\n\tvoid PixelGameEngine::DrawRect(int32_t x, int32_t y, int32_t w, int32_t h, Pixel p)\r\n\t{\r\n\t\tDrawLine(x, y, x + w, y, p);\r\n\t\tDrawLine(x + w, y, x + w, y + h, p);\r\n\t\tDrawLine(x + w, y + h, x, y + h, p);\r\n\t\tDrawLine(x, y + h, x, y, p);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::Clear(Pixel p)\r\n\t{\r\n\t\tint pixels = GetDrawTargetWidth() * GetDrawTargetHeight();\r\n\t\tPixel* m = GetDrawTarget()->GetData();\r\n\t\tfor (int i = 0; i < pixels; i++) m[i] = p;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::ClearBuffer(Pixel p, bool bDepth)\r\n\t{ renderer->ClearBuffer(p, bDepth);\t}\r\n\r\n\tolc::Sprite* PixelGameEngine::GetFontSprite()\r\n\t{ return fontRenderable.Sprite(); }\r\n\r\n\tbool PixelGameEngine::ClipLineToScreen(olc::vi2d& in_p1, olc::vi2d& in_p2)\r\n\t{\r\n\t\t// https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm\r\n\t\tstatic constexpr int SEG_I = 0b0000, SEG_L = 0b0001, SEG_R = 0b0010, SEG_B = 0b0100, SEG_T = 0b1000;\r\n\t\tauto Segment = [&vScreenSize = vScreenSize](const olc::vi2d& v)\r\n\t\t{\r\n\t\t\tint i = SEG_I;\r\n\t\t\tif (v.x < 0) i |= SEG_L; else if (v.x > vScreenSize.x) i |= SEG_R;\r\n\t\t\tif (v.y < 0) i |= SEG_B; else if (v.y > vScreenSize.y) i |= SEG_T;\r\n\t\t\treturn i;\r\n\t\t};\r\n\r\n\t\tint s1 = Segment(in_p1), s2 = Segment(in_p2);\r\n\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tif (!(s1 | s2))\t  return true;\r\n\t\t\telse if (s1 & s2) return false;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint s3 = s2 > s1 ? s2 : s1;\r\n\t\t\t\tolc::vi2d n;\r\n\t\t\t\tif (s3 & SEG_T) { n.x = in_p1.x + (in_p2.x - in_p1.x) * (vScreenSize.y - in_p1.y) / (in_p2.y - in_p1.y); n.y = vScreenSize.y; }\r\n\t\t\t\telse if (s3 & SEG_B) { n.x = in_p1.x + (in_p2.x - in_p1.x) * (0 - in_p1.y) / (in_p2.y - in_p1.y); n.y = 0; }\r\n\t\t\t\telse if (s3 & SEG_R) { n.x = vScreenSize.x; n.y = in_p1.y + (in_p2.y - in_p1.y) * (vScreenSize.x - in_p1.x) / (in_p2.x - in_p1.x); }\r\n\t\t\t\telse if (s3 & SEG_L) { n.x = 0; n.y = in_p1.y + (in_p2.y - in_p1.y) * (0 - in_p1.x) / (in_p2.x - in_p1.x); }\r\n\t\t\t\tif (s3 == s1) { in_p1 = n; s1 = Segment(in_p1); }\r\n\t\t\t\telse { in_p2 = n; s2 = Segment(in_p2); }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::EnablePixelTransfer(const bool bEnable)\r\n\t{\r\n\t\tbSuspendTextureTransfer = !bEnable;\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::FillRect(const olc::vi2d& pos, const olc::vi2d& size, Pixel p)\r\n\t{ FillRect(pos.x, pos.y, size.x, size.y, p); }\r\n\r\n\tvoid PixelGameEngine::FillRect(int32_t x, int32_t y, int32_t w, int32_t h, Pixel p)\r\n\t{\r\n\t\tint32_t x2 = x + w;\r\n\t\tint32_t y2 = y + h;\r\n\r\n\t\tif (x < 0) x = 0;\r\n\t\tif (x >= (int32_t)GetDrawTargetWidth()) x = (int32_t)GetDrawTargetWidth();\r\n\t\tif (y < 0) y = 0;\r\n\t\tif (y >= (int32_t)GetDrawTargetHeight()) y = (int32_t)GetDrawTargetHeight();\r\n\r\n\t\tif (x2 < 0) x2 = 0;\r\n\t\tif (x2 >= (int32_t)GetDrawTargetWidth()) x2 = (int32_t)GetDrawTargetWidth();\r\n\t\tif (y2 < 0) y2 = 0;\r\n\t\tif (y2 >= (int32_t)GetDrawTargetHeight()) y2 = (int32_t)GetDrawTargetHeight();\r\n\r\n\t\tfor (int i = x; i < x2; i++)\r\n\t\t\tfor (int j = y; j < y2; j++)\r\n\t\t\t\tDraw(i, j, p);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawTriangle(const olc::vi2d& pos1, const olc::vi2d& pos2, const olc::vi2d& pos3, Pixel p)\r\n\t{ DrawTriangle(pos1.x, pos1.y, pos2.x, pos2.y, pos3.x, pos3.y, p); }\r\n\r\n\tvoid PixelGameEngine::DrawTriangle(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x3, int32_t y3, Pixel p)\r\n\t{\r\n\t\tDrawLine(x1, y1, x2, y2, p);\r\n\t\tDrawLine(x2, y2, x3, y3, p);\r\n\t\tDrawLine(x3, y3, x1, y1, p);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillTriangle(const olc::vi2d& pos1, const olc::vi2d& pos2, const olc::vi2d& pos3, Pixel p)\r\n\t{ FillTriangle(pos1.x, pos1.y, pos2.x, pos2.y, pos3.x, pos3.y, p); }\r\n\r\n\t// https://www.avrfreaks.net/sites/default/files/triangles.c\r\n\tvoid PixelGameEngine::FillTriangle(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x3, int32_t y3, Pixel p)\r\n\t{\r\n\t\tauto drawline = [&](int sx, int ex, int ny) { for (int i = sx; i <= ex; i++) Draw(i, ny, p); };\r\n\r\n\t\tint t1x, t2x, y, minx, maxx, t1xp, t2xp;\r\n\t\tbool changed1 = false;\r\n\t\tbool changed2 = false;\r\n\t\tint signx1, signx2, dx1, dy1, dx2, dy2;\r\n\t\tint e1, e2;\r\n\t\t// Sort vertices\r\n\t\tif (y1 > y2) { std::swap(y1, y2); std::swap(x1, x2); }\r\n\t\tif (y1 > y3) { std::swap(y1, y3); std::swap(x1, x3); }\r\n\t\tif (y2 > y3) { std::swap(y2, y3); std::swap(x2, x3); }\r\n\r\n\t\tt1x = t2x = x1; y = y1;   // Starting points\r\n\t\tdx1 = (int)(x2 - x1);\r\n\t\tif (dx1 < 0) { dx1 = -dx1; signx1 = -1; }\r\n\t\telse signx1 = 1;\r\n\t\tdy1 = (int)(y2 - y1);\r\n\r\n\t\tdx2 = (int)(x3 - x1);\r\n\t\tif (dx2 < 0) { dx2 = -dx2; signx2 = -1; }\r\n\t\telse signx2 = 1;\r\n\t\tdy2 = (int)(y3 - y1);\r\n\r\n\t\tif (dy1 > dx1) { std::swap(dx1, dy1); changed1 = true; }\r\n\t\tif (dy2 > dx2) { std::swap(dy2, dx2); changed2 = true; }\r\n\r\n\t\te2 = (int)(dx2 >> 1);\r\n\t\t// Flat top, just process the second half\r\n\t\tif (y1 == y2) goto next;\r\n\t\te1 = (int)(dx1 >> 1);\r\n\r\n\t\tfor (int i = 0; i < dx1;) {\r\n\t\t\tt1xp = 0; t2xp = 0;\r\n\t\t\tif (t1x < t2x) { minx = t1x; maxx = t2x; }\r\n\t\t\telse { minx = t2x; maxx = t1x; }\r\n\t\t\t// process first line until y value is about to change\r\n\t\t\twhile (i < dx1) {\r\n\t\t\t\ti++;\r\n\t\t\t\te1 += dy1;\r\n\t\t\t\twhile (e1 >= dx1) {\r\n\t\t\t\t\te1 -= dx1;\r\n\t\t\t\t\tif (changed1) t1xp = signx1;//t1x += signx1;\r\n\t\t\t\t\telse          goto next1;\r\n\t\t\t\t}\r\n\t\t\t\tif (changed1) break;\r\n\t\t\t\telse t1x += signx1;\r\n\t\t\t}\r\n\t\t\t// Move line\r\n\t\tnext1:\r\n\t\t\t// process second line until y value is about to change\r\n\t\t\twhile (1) {\r\n\t\t\t\te2 += dy2;\r\n\t\t\t\twhile (e2 >= dx2) {\r\n\t\t\t\t\te2 -= dx2;\r\n\t\t\t\t\tif (changed2) t2xp = signx2;//t2x += signx2;\r\n\t\t\t\t\telse          goto next2;\r\n\t\t\t\t}\r\n\t\t\t\tif (changed2)     break;\r\n\t\t\t\telse              t2x += signx2;\r\n\t\t\t}\r\n\t\tnext2:\r\n\t\t\tif (minx > t1x) minx = t1x;\r\n\t\t\tif (minx > t2x) minx = t2x;\r\n\t\t\tif (maxx < t1x) maxx = t1x;\r\n\t\t\tif (maxx < t2x) maxx = t2x;\r\n\t\t\tdrawline(minx, maxx, y);    // Draw line from min to max points found on the y\r\n\t\t\t\t\t\t\t\t\t\t// Now increase y\r\n\t\t\tif (!changed1) t1x += signx1;\r\n\t\t\tt1x += t1xp;\r\n\t\t\tif (!changed2) t2x += signx2;\r\n\t\t\tt2x += t2xp;\r\n\t\t\ty += 1;\r\n\t\t\tif (y == y2) break;\r\n\t\t}\r\n\tnext:\r\n\t\t// Second half\r\n\t\tdx1 = (int)(x3 - x2); if (dx1 < 0) { dx1 = -dx1; signx1 = -1; }\r\n\t\telse signx1 = 1;\r\n\t\tdy1 = (int)(y3 - y2);\r\n\t\tt1x = x2;\r\n\r\n\t\tif (dy1 > dx1) {   // swap values\r\n\t\t\tstd::swap(dy1, dx1);\r\n\t\t\tchanged1 = true;\r\n\t\t}\r\n\t\telse changed1 = false;\r\n\r\n\t\te1 = (int)(dx1 >> 1);\r\n\r\n\t\tfor (int i = 0; i <= dx1; i++) {\r\n\t\t\tt1xp = 0; t2xp = 0;\r\n\t\t\tif (t1x < t2x) { minx = t1x; maxx = t2x; }\r\n\t\t\telse { minx = t2x; maxx = t1x; }\r\n\t\t\t// process first line until y value is about to change\r\n\t\t\twhile (i < dx1) {\r\n\t\t\t\te1 += dy1;\r\n\t\t\t\twhile (e1 >= dx1) {\r\n\t\t\t\t\te1 -= dx1;\r\n\t\t\t\t\tif (changed1) { t1xp = signx1; break; }//t1x += signx1;\r\n\t\t\t\t\telse          goto next3;\r\n\t\t\t\t}\r\n\t\t\t\tif (changed1) break;\r\n\t\t\t\telse   \t   \t  t1x += signx1;\r\n\t\t\t\tif (i < dx1) i++;\r\n\t\t\t}\r\n\t\tnext3:\r\n\t\t\t// process second line until y value is about to change\r\n\t\t\twhile (t2x != x3) {\r\n\t\t\t\te2 += dy2;\r\n\t\t\t\twhile (e2 >= dx2) {\r\n\t\t\t\t\te2 -= dx2;\r\n\t\t\t\t\tif (changed2) t2xp = signx2;\r\n\t\t\t\t\telse          goto next4;\r\n\t\t\t\t}\r\n\t\t\t\tif (changed2)     break;\r\n\t\t\t\telse              t2x += signx2;\r\n\t\t\t}\r\n\t\tnext4:\r\n\r\n\t\t\tif (minx > t1x) minx = t1x;\r\n\t\t\tif (minx > t2x) minx = t2x;\r\n\t\t\tif (maxx < t1x) maxx = t1x;\r\n\t\t\tif (maxx < t2x) maxx = t2x;\r\n\t\t\tdrawline(minx, maxx, y);\r\n\t\t\tif (!changed1) t1x += signx1;\r\n\t\t\tt1x += t1xp;\r\n\t\t\tif (!changed2) t2x += signx2;\r\n\t\t\tt2x += t2xp;\r\n\t\t\ty += 1;\r\n\t\t\tif (y > y3) return;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillTexturedTriangle(std::vector<olc::vf2d> vPoints, std::vector<olc::vf2d> vTex, std::vector<olc::Pixel> vColour, olc::Sprite* sprTex)\r\n\t{\r\n\t\tolc::vi2d p1 = vPoints[0];\r\n\t\tolc::vi2d p2 = vPoints[1];\r\n\t\tolc::vi2d p3 = vPoints[2];\r\n\r\n\t\tif (p2.y < p1.y){std::swap(p1.y, p2.y); std::swap(p1.x, p2.x); std::swap(vTex[0].x, vTex[1].x); std::swap(vTex[0].y, vTex[1].y); std::swap(vColour[0], vColour[1]);}\r\n\t\tif (p3.y < p1.y){std::swap(p1.y, p3.y); std::swap(p1.x, p3.x); std::swap(vTex[0].x, vTex[2].x); std::swap(vTex[0].y, vTex[2].y); std::swap(vColour[0], vColour[2]);}\r\n\t\tif (p3.y < p2.y){std::swap(p2.y, p3.y); std::swap(p2.x, p3.x); std::swap(vTex[1].x, vTex[2].x); std::swap(vTex[1].y, vTex[2].y); std::swap(vColour[1], vColour[2]);}\r\n\r\n\t\tolc::vi2d dPos1 = p2 - p1;\r\n\t\tolc::vf2d dTex1 = vTex[1] - vTex[0];\r\n\t\tint dcr1 = vColour[1].r - vColour[0].r;\r\n\t\tint dcg1 = vColour[1].g - vColour[0].g;\r\n\t\tint dcb1 = vColour[1].b - vColour[0].b;\r\n\t\tint dca1 = vColour[1].a - vColour[0].a;\r\n\r\n\t\tolc::vi2d dPos2 = p3 - p1;\r\n\t\tolc::vf2d dTex2 = vTex[2] - vTex[0];\r\n\t\tint dcr2 = vColour[2].r - vColour[0].r;\r\n\t\tint dcg2 = vColour[2].g - vColour[0].g;\r\n\t\tint dcb2 = vColour[2].b - vColour[0].b;\r\n\t\tint dca2 = vColour[2].a - vColour[0].a;\r\n\r\n\t\tfloat dax_step = 0, dbx_step = 0, dcr1_step = 0, dcr2_step = 0,\tdcg1_step = 0, dcg2_step = 0, dcb1_step = 0, dcb2_step = 0,\tdca1_step = 0, dca2_step = 0;\r\n\t\tolc::vf2d vTex1Step, vTex2Step;\r\n\r\n\t\tif (dPos1.y)\r\n\t\t{\r\n\t\t\tdax_step = dPos1.x / (float)abs(dPos1.y);\r\n\t\t\tvTex1Step = dTex1 / (float)abs(dPos1.y);\r\n\t\t\tdcr1_step = dcr1 / (float)abs(dPos1.y);\r\n\t\t\tdcg1_step = dcg1 / (float)abs(dPos1.y);\r\n\t\t\tdcb1_step = dcb1 / (float)abs(dPos1.y);\r\n\t\t\tdca1_step = dca1 / (float)abs(dPos1.y);\r\n\t\t}\r\n\r\n\t\tif (dPos2.y)\r\n\t\t{\r\n\t\t\tdbx_step = dPos2.x / (float)abs(dPos2.y);\r\n\t\t\tvTex2Step = dTex2 / (float)abs(dPos2.y);\r\n\t\t\tdcr2_step = dcr2 / (float)abs(dPos2.y);\r\n\t\t\tdcg2_step = dcg2 / (float)abs(dPos2.y);\r\n\t\t\tdcb2_step = dcb2 / (float)abs(dPos2.y);\r\n\t\t\tdca2_step = dca2 / (float)abs(dPos2.y);\r\n\t\t}\r\n\r\n\t\tolc::vi2d vStart;\r\n\t\tolc::vi2d vEnd;\r\n\t\tint vStartIdx;\r\n\r\n\t\tfor (int pass = 0; pass < 2; pass++)\r\n\t\t{\r\n\t\t\tif (pass == 0)\r\n\t\t\t{\r\n\t\t\t\tvStart = p1; vEnd = p2;\tvStartIdx = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdPos1 = p3 - p2;\r\n\t\t\t\tdTex1 = vTex[2] - vTex[1];\r\n\t\t\t\tdcr1 = vColour[2].r - vColour[1].r;\r\n\t\t\t\tdcg1 = vColour[2].g - vColour[1].g;\r\n\t\t\t\tdcb1 = vColour[2].b - vColour[1].b;\r\n\t\t\t\tdca1 = vColour[2].a - vColour[1].a;\r\n\t\t\t\tdcr1_step = 0; dcg1_step = 0; dcb1_step = 0; dca1_step = 0;\r\n\r\n\t\t\t\tif (dPos2.y) dbx_step = dPos2.x / (float)abs(dPos2.y);\r\n\t\t\t\tif (dPos1.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tdax_step = dPos1.x / (float)abs(dPos1.y);\r\n\t\t\t\t\tvTex1Step = dTex1 / (float)abs(dPos1.y);\r\n\t\t\t\t\tdcr1_step = dcr1 / (float)abs(dPos1.y);\r\n\t\t\t\t\tdcg1_step = dcg1 / (float)abs(dPos1.y);\r\n\t\t\t\t\tdcb1_step = dcb1 / (float)abs(dPos1.y);\r\n\t\t\t\t\tdca1_step = dca1 / (float)abs(dPos1.y);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvStart = p2; vEnd = p3; vStartIdx = 1;\r\n\t\t\t}\r\n\r\n\t\t\tif (dPos1.y)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = vStart.y; i <= vEnd.y; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint ax = int(vStart.x + (float)(i - vStart.y) * dax_step);\r\n\t\t\t\t\tint bx = int(p1.x + (float)(i - p1.y) * dbx_step);\r\n\r\n\t\t\t\t\tolc::vf2d tex_s(vTex[vStartIdx].x + (float)(i - vStart.y) * vTex1Step.x, vTex[vStartIdx].y + (float)(i - vStart.y) * vTex1Step.y);\r\n\t\t\t\t\tolc::vf2d tex_e(vTex[0].x + (float)(i - p1.y) * vTex2Step.x, vTex[0].y + (float)(i - p1.y) * vTex2Step.y);\r\n\r\n\t\t\t\t\tolc::Pixel col_s(vColour[vStartIdx].r + uint8_t((float)(i - vStart.y) * dcr1_step), vColour[vStartIdx].g + uint8_t((float)(i - vStart.y) * dcg1_step),\r\n\t\t\t\t\t\tvColour[vStartIdx].b + uint8_t((float)(i - vStart.y) * dcb1_step), vColour[vStartIdx].a + uint8_t((float)(i - vStart.y) * dca1_step));\r\n\r\n\t\t\t\t\tolc::Pixel col_e(vColour[0].r + uint8_t((float)(i - p1.y) * dcr2_step), vColour[0].g + uint8_t((float)(i - p1.y) * dcg2_step),\r\n\t\t\t\t\t\tvColour[0].b + uint8_t((float)(i - p1.y) * dcb2_step), vColour[0].a + uint8_t((float)(i - p1.y) * dca2_step));\r\n\r\n\t\t\t\t\tif (ax > bx) { std::swap(ax, bx); std::swap(tex_s, tex_e); std::swap(col_s, col_e); }\r\n\r\n\t\t\t\t\tfloat tstep = 1.0f / ((float)(bx - ax));\r\n\t\t\t\t\tfloat t = 0.0f;\r\n\r\n\t\t\t\t\tfor (int j = ax; j < bx; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tolc::Pixel pixel = PixelLerp(col_s, col_e, t);\r\n\t\t\t\t\t\tif (sprTex != nullptr) pixel *= sprTex->Sample(tex_s.lerp(tex_e, t));\r\n\t\t\t\t\t\tDraw(j, i, pixel);\r\n\t\t\t\t\t\tt += tstep;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\t\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillTexturedPolygon(const std::vector<olc::vf2d>& vPoints, const std::vector<olc::vf2d>& vTex, const std::vector<olc::Pixel>& vColour, olc::Sprite* sprTex, olc::DecalStructure structure)\r\n\t{\r\n\t\tif (structure == olc::DecalStructure::LINE)\r\n\t\t{\r\n\t\t\treturn; // Meaningless, so do nothing\r\n\t\t}\r\n\r\n\t\tif (vPoints.size() < 3 || vTex.size() < 3 || vColour.size() < 3)\r\n\t\t\treturn;\r\n\r\n\t\tif (structure == olc::DecalStructure::LIST)\r\n\t\t{\t\t\t\r\n\t\t\tfor (size_t tri = 0; tri < vPoints.size() / 3; tri++)\r\n\t\t\t{\r\n\t\t\t\tstd::vector<olc::vf2d> vP = { vPoints[tri * 3 + 0], vPoints[tri * 3 + 1], vPoints[tri * 3 + 2] };\r\n\t\t\t\tstd::vector<olc::vf2d> vT = { vTex[tri * 3 + 0], vTex[tri * 3 + 1], vTex[tri * 3 + 2] };\r\n\t\t\t\tstd::vector<olc::Pixel> vC = { vColour[tri * 3 + 0], vColour[tri * 3 + 1], vColour[tri * 3 + 2] };\r\n\t\t\t\tFillTexturedTriangle(vP, vT, vC, sprTex);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (structure == olc::DecalStructure::STRIP)\r\n\t\t{\r\n\t\t\tfor (size_t tri = 2; tri < vPoints.size(); tri++)\r\n\t\t\t{\r\n\t\t\t\tstd::vector<olc::vf2d> vP = { vPoints[tri - 2], vPoints[tri-1], vPoints[tri] };\r\n\t\t\t\tstd::vector<olc::vf2d> vT = { vTex[tri - 2], vTex[tri - 1], vTex[tri] };\r\n\t\t\t\tstd::vector<olc::Pixel> vC = { vColour[tri - 2], vColour[tri - 1], vColour[tri] };\r\n\t\t\t\tFillTexturedTriangle(vP, vT, vC, sprTex);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (structure == olc::DecalStructure::FAN)\r\n\t\t{\r\n\t\t\tfor (size_t tri = 2; tri < vPoints.size(); tri++)\r\n\t\t\t{\r\n\t\t\t\tstd::vector<olc::vf2d> vP = { vPoints[0], vPoints[tri - 1], vPoints[tri] };\r\n\t\t\t\tstd::vector<olc::vf2d> vT = { vTex[0], vTex[tri - 1], vTex[tri] };\r\n\t\t\t\tstd::vector<olc::Pixel> vC = { vColour[0], vColour[tri - 1], vColour[tri] };\r\n\t\t\t\tFillTexturedTriangle(vP, vT, vC, sprTex);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::DrawSprite(const olc::vi2d& pos, Sprite* sprite, uint32_t scale, uint8_t flip)\r\n\t{ DrawSprite(pos.x, pos.y, sprite, scale, flip); }\r\n\r\n\tvoid PixelGameEngine::DrawSprite(int32_t x, int32_t y, Sprite* sprite, uint32_t scale, uint8_t flip)\r\n\t{\r\n\t\tif (sprite == nullptr)\r\n\t\t\treturn;\r\n\r\n\t\tint32_t fxs = 0, fxm = 1, fx = 0;\r\n\t\tint32_t fys = 0, fym = 1, fy = 0;\r\n\t\tif (flip & olc::Sprite::Flip::HORIZ) { fxs = sprite->width - 1; fxm = -1; }\r\n\t\tif (flip & olc::Sprite::Flip::VERT) { fys = sprite->height - 1; fym = -1; }\r\n\r\n\t\tif (scale > 1)\r\n\t\t{\r\n\t\t\tfx = fxs;\r\n\t\t\tfor (int32_t i = 0; i < sprite->width; i++, fx += fxm)\r\n\t\t\t{\r\n\t\t\t\tfy = fys;\r\n\t\t\t\tfor (int32_t j = 0; j < sprite->height; j++, fy += fym)\r\n\t\t\t\t\tfor (uint32_t is = 0; is < scale; is++)\r\n\t\t\t\t\t\tfor (uint32_t js = 0; js < scale; js++)\r\n\t\t\t\t\t\t\tDraw(x + (i * scale) + is, y + (j * scale) + js, sprite->GetPixel(fx, fy));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfx = fxs;\r\n\t\t\tfor (int32_t i = 0; i < sprite->width; i++, fx += fxm)\r\n\t\t\t{\r\n\t\t\t\tfy = fys;\r\n\t\t\t\tfor (int32_t j = 0; j < sprite->height; j++, fy += fym)\r\n\t\t\t\t\tDraw(x + i, y + j, sprite->GetPixel(fx, fy));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPartialSprite(const olc::vi2d& pos, Sprite* sprite, const olc::vi2d& sourcepos, const olc::vi2d& size, uint32_t scale, uint8_t flip)\r\n\t{ DrawPartialSprite(pos.x, pos.y, sprite, sourcepos.x, sourcepos.y, size.x, size.y, scale, flip); }\r\n\r\n\tvoid PixelGameEngine::DrawPartialSprite(int32_t x, int32_t y, Sprite* sprite, int32_t ox, int32_t oy, int32_t w, int32_t h, uint32_t scale, uint8_t flip)\r\n\t{\r\n\t\tif (sprite == nullptr)\r\n\t\t\treturn;\r\n\r\n\t\tint32_t fxs = 0, fxm = 1, fx = 0;\r\n\t\tint32_t fys = 0, fym = 1, fy = 0;\r\n\t\tif (flip & olc::Sprite::Flip::HORIZ) { fxs = w - 1; fxm = -1; }\r\n\t\tif (flip & olc::Sprite::Flip::VERT) { fys = h - 1; fym = -1; }\r\n\r\n\t\tif (scale > 1)\r\n\t\t{\r\n\t\t\tfx = fxs;\r\n\t\t\tfor (int32_t i = 0; i < w; i++, fx += fxm)\r\n\t\t\t{\r\n\t\t\t\tfy = fys;\r\n\t\t\t\tfor (int32_t j = 0; j < h; j++, fy += fym)\r\n\t\t\t\t\tfor (uint32_t is = 0; is < scale; is++)\r\n\t\t\t\t\t\tfor (uint32_t js = 0; js < scale; js++)\r\n\t\t\t\t\t\t\tDraw(x + (i * scale) + is, y + (j * scale) + js, sprite->GetPixel(fx + ox, fy + oy));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfx = fxs;\r\n\t\t\tfor (int32_t i = 0; i < w; i++, fx += fxm)\r\n\t\t\t{\r\n\t\t\t\tfy = fys;\r\n\t\t\t\tfor (int32_t j = 0; j < h; j++, fy += fym)\r\n\t\t\t\t\tDraw(x + i, y + j, sprite->GetPixel(fx + ox, fy + oy));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::SetDecalMode(const olc::DecalMode& mode)\r\n\t{ nDecalMode = mode; }\r\n\r\n\tvoid PixelGameEngine::SetDecalStructure(const olc::DecalStructure& structure)\r\n\t{ nDecalStructure = structure; }\r\n\r\n\tvoid PixelGameEngine::DrawPartialDecal(const olc::vf2d& pos, olc::Decal* decal, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::vf2d& scale, const olc::Pixel& tint)\r\n\t{\r\n\t\tolc::vf2d vScreenSpacePos =\r\n\t\t{\r\n\t\t\t  (pos.x * vInvScreenSize.x) * 2.0f - 1.0f,\r\n\t\t\t-((pos.y * vInvScreenSize.y) * 2.0f - 1.0f)\r\n\t\t};\r\n\r\n\t\t\r\n\t\tolc::vf2d vScreenSpaceDim =\r\n\t\t{\r\n\t\t\t  ((pos.x + source_size.x * scale.x) * vInvScreenSize.x) * 2.0f - 1.0f,\r\n\t\t\t-(((pos.y + source_size.y * scale.y) * vInvScreenSize.y) * 2.0f - 1.0f)\r\n\t\t};\r\n\r\n\t\tolc::vf2d vWindow = olc::vf2d(vViewSize);\r\n\t\tolc::vf2d vQuantisedPos = ((vScreenSpacePos * vWindow) + olc::vf2d(0.5f, 0.5f)).floor() / vWindow;\r\n\t\tolc::vf2d vQuantisedDim = ((vScreenSpaceDim * vWindow) + olc::vf2d(0.5f, -0.5f)).ceil() / vWindow;\r\n\r\n\t\tDecalInstance di;\r\n\t\tdi.points = 4;\r\n\t\tdi.decal = decal;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.pos = { { vQuantisedPos.x, vQuantisedPos.y }, { vQuantisedPos.x, vQuantisedDim.y }, { vQuantisedDim.x, vQuantisedDim.y }, { vQuantisedDim.x, vQuantisedPos.y } };\r\n\t\tolc::vf2d uvtl = (source_pos + olc::vf2d(0.0001f, 0.0001f)) * decal->vUVScale;\r\n\t\tolc::vf2d uvbr = (source_pos + source_size - olc::vf2d(0.0001f, 0.0001f)) * decal->vUVScale;\r\n\t\tdi.uv = { { uvtl.x, uvtl.y }, { uvtl.x, uvbr.y }, { uvbr.x, uvbr.y }, { uvbr.x, uvtl.y } };\r\n\t\tdi.w = { 1,1,1,1 };\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPartialDecal(const olc::vf2d& pos, const olc::vf2d& size, olc::Decal* decal, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint)\r\n\t{\r\n\t\tolc::vf2d vScreenSpacePos =\r\n\t\t{\r\n\t\t\t(pos.x * vInvScreenSize.x) * 2.0f - 1.0f,\r\n\t\t\t((pos.y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f\r\n\t\t};\r\n\r\n\t\tolc::vf2d vScreenSpaceDim =\r\n\t\t{\r\n\t\t\tvScreenSpacePos.x + (2.0f * size.x * vInvScreenSize.x),\r\n\t\t\tvScreenSpacePos.y - (2.0f * size.y * vInvScreenSize.y)\r\n\t\t};\r\n\r\n\t\tDecalInstance di;\r\n\t\tdi.points = 4;\r\n\t\tdi.decal = decal;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.pos = { { vScreenSpacePos.x, vScreenSpacePos.y }, { vScreenSpacePos.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpacePos.y } };\r\n\t\tolc::vf2d uvtl = (source_pos) * decal->vUVScale;\r\n\t\tolc::vf2d uvbr = uvtl + ((source_size) * decal->vUVScale);\r\n\t\tdi.uv = { { uvtl.x, uvtl.y }, { uvtl.x, uvbr.y }, { uvbr.x, uvbr.y }, { uvbr.x, uvtl.y } };\r\n\t\tdi.w = { 1,1,1,1 };\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::DrawDecal(const olc::vf2d& pos, olc::Decal* decal, const olc::vf2d& scale, const olc::Pixel& tint)\r\n\t{\r\n\t\tolc::vf2d vScreenSpacePos =\r\n\t\t{\r\n\t\t\t(pos.x * vInvScreenSize.x) * 2.0f - 1.0f,\r\n\t\t\t((pos.y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f\r\n\t\t};\r\n\r\n\t\tolc::vf2d vScreenSpaceDim =\r\n\t\t{\r\n\t\t\tvScreenSpacePos.x + (2.0f * (float(decal->sprite->width) * vInvScreenSize.x)) * scale.x,\r\n\t\t\tvScreenSpacePos.y - (2.0f * (float(decal->sprite->height) * vInvScreenSize.y)) * scale.y\r\n\t\t};\r\n\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = 4;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.pos = { { vScreenSpacePos.x, vScreenSpacePos.y }, { vScreenSpacePos.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpacePos.y } };\r\n\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawExplicitDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::vf2d* uv, const olc::Pixel* col, uint32_t elements)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.pos.resize(elements);\r\n\t\tdi.uv.resize(elements);\r\n\t\tdi.w.resize(elements);\r\n\t\tdi.tint.resize(elements);\r\n\t\tdi.points = elements;\r\n\t\tfor (uint32_t i = 0; i < elements; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\tdi.uv[i] = uv[i];\r\n\t\t\tdi.tint[i] = col[i];\r\n\t\t\tdi.w[i] = 1.0f;\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const olc::Pixel tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = uint32_t(pos.size());\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tfor (uint32_t i = 0; i < di.points; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\tdi.uv[i] = uv[i];\r\n\t\t\tdi.tint[i] = tint;\r\n\t\t\tdi.w[i] = 1.0f;\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel> &tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = uint32_t(pos.size());\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tfor (uint32_t i = 0; i < di.points; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\tdi.uv[i] = uv[i];\r\n\t\t\tdi.tint[i] = tint[i];\r\n\t\t\tdi.w[i] = 1.0f;\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel>& colours, const olc::Pixel tint)\r\n\t{\r\n\t\tstd::vector<olc::Pixel> newColours(colours.size(), olc::WHITE);\r\n\t\tstd::transform(colours.begin(), colours.end(), newColours.begin(),\r\n\t\t\t[&tint](const olc::Pixel pin) {\treturn pin * tint; });\r\n\t\tDrawPolygonDecal(decal, pos, uv, newColours);\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<float>& depth, const std::vector<olc::vf2d>& uv, const olc::Pixel tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = uint32_t(pos.size());\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tfor (uint32_t i = 0; i < di.points; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\tdi.uv[i] = uv[i];\r\n\t\t\tdi.tint[i] = tint;\r\n\t\t\tdi.w[i] = depth[i];\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPolygonDecal(olc::Decal* decal, const std::vector<olc::vf2d>& pos, const std::vector<float>& depth, const std::vector<olc::vf2d>& uv, const std::vector<olc::Pixel>& colours, const olc::Pixel tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = uint32_t(pos.size());\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tfor (uint32_t i = 0; i < di.points; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\tdi.uv[i] = uv[i];\r\n\t\t\tdi.tint[i] = colours[i] * tint;\r\n\t\t\tdi.w[i] = depth[i];\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n#ifdef OLC_ENABLE_EXPERIMENTAL\r\n\t// Lightweight 3D\r\n\tvoid PixelGameEngine::LW3D_DrawTriangles(olc::Decal* decal, const std::vector<std::array<float, 3>>& pos, const std::vector<olc::vf2d>& tex, const std::vector<olc::Pixel>& col)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = uint32_t(pos.size());\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.z.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tfor (uint32_t i = 0; i < di.points; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = { pos[i][0], pos[i][1] };\r\n\t\t\tdi.w[i] = pos[i][2];\r\n\t\t\tdi.z[i] = pos[i][2];\r\n\t\t\tdi.uv[i] = tex[i];\r\n\t\t\tdi.tint[i] = col[i];\t\t\t\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = DecalStructure::LIST;\r\n\t\tdi.depth = true;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::LW3D_DrawWarpedDecal(olc::Decal* decal, const std::vector<std::array<float, 3>>& pos, const olc::Pixel& tint)\r\n\t{\r\n\t\t// Thanks Nathan Reed, a brilliant article explaining whats going on here\r\n\t\t// http://www.reedbeta.com/blog/quadrilateral-interpolation-part-1/\r\n\t\tDecalInstance di;\r\n\t\tdi.points = 4;\r\n\t\tdi.decal = decal;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.z = { 1, 1, 1, 1 };\r\n\t\tdi.pos.resize(4);\r\n\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\tolc::vf2d center;\r\n\t\tfloat rd = ((pos[2][0] - pos[0][0]) * (pos[3][1] - pos[1][1]) - (pos[3][0] - pos[1][0]) * (pos[2][1] - pos[0][1]));\r\n\t\tif (rd != 0)\r\n\t\t{\r\n\t\t\trd = 1.0f / rd;\r\n\t\t\tfloat rn = ((pos[3][0] - pos[1][0]) * (pos[0][1] - pos[1][1]) - (pos[3][1] - pos[1][1]) * (pos[0][0] - pos[1][0])) * rd;\r\n\t\t\tfloat sn = ((pos[2][0] - pos[0][0]) * (pos[0][1] - pos[1][1]) - (pos[2][1] - pos[0][1]) * (pos[0][0] - pos[1][0])) * rd;\r\n\t\t\tif (!(rn < 0.f || rn > 1.f || sn < 0.f || sn > 1.f))\r\n\t\t\t{\r\n\t\t\t\tcenter.x = pos[0][0] + rn * (pos[2][0] - pos[0][0]);\r\n\t\t\t\tcenter.y = pos[0][1] + rn * (pos[2][1] - pos[0][1]);\r\n\t\t\t}\r\n\t\t\tfloat d[4];\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t\td[i] = std::sqrt((pos[i][0] - center.x) * (pos[i][0] - center.x) + (pos[i][1] - center.y) * (pos[i][1] - center.y));\r\n\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tfloat q = d[i] == 0.0f ? 1.0f : (d[i] + d[(i + 2) & 3]) / d[(i + 2) & 3];\r\n\t\t\t\tdi.uv[i] *= q; \r\n\t\t\t\tdi.w[i] *= q;\r\n\t\t\t\tdi.z[i] = pos[i][2];\r\n\t\t\t\tdi.pos[i] = { (pos[i][0] * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i][1] * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\t}\r\n\t\t\tdi.mode = nDecalMode;\r\n\t\t\tdi.structure = nDecalStructure;\r\n\t\t\tdi.depth = true;\r\n\t\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tvoid PixelGameEngine::DrawLineDecal(const olc::vf2d& pos1, const olc::vf2d& pos2, Pixel p)\r\n\t{\r\n\t\tauto m = nDecalMode;\r\n\t\tnDecalMode = olc::DecalMode::WIREFRAME;\r\n\t\tDrawPolygonDecal(nullptr, { pos1, pos2 }, { {0, 0}, {0,0} }, p);\r\n\t\tnDecalMode = m;\r\n\r\n\t\t/*DecalInstance di;\r\n\t\tdi.decal = nullptr;\r\n\t\tdi.points = uint32_t(2);\r\n\t\tdi.pos.resize(di.points);\r\n\t\tdi.uv.resize(di.points);\r\n\t\tdi.w.resize(di.points);\r\n\t\tdi.tint.resize(di.points);\r\n\t\tdi.pos[0] = { (pos1.x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos1.y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\tdi.uv[0] = { 0.0f, 0.0f };\r\n\t\tdi.tint[0] = p;\r\n\t\tdi.w[0] = 1.0f;\r\n\t\tdi.pos[1] = { (pos2.x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos2.y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\tdi.uv[1] = { 0.0f, 0.0f };\r\n\t\tdi.tint[1] = p;\r\n\t\tdi.w[1] = 1.0f;\r\n\t\tdi.mode = olc::DecalMode::WIREFRAME;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);*/\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel col)\r\n\t{\r\n\t\tauto m = nDecalMode;\r\n\t\tSetDecalMode(olc::DecalMode::WIREFRAME);\r\n\t\tolc::vf2d vNewSize = size;// (size - olc::vf2d(0.375f, 0.375f)).ceil();\r\n\t\tstd::array<olc::vf2d, 4> points = { { {pos}, {pos.x, pos.y + vNewSize.y}, {pos + vNewSize}, {pos.x + vNewSize.x, pos.y} } };\r\n\t\tstd::array<olc::vf2d, 4> uvs = { {{0,0},{0,0},{0,0},{0,0}} };\r\n\t\tstd::array<olc::Pixel, 4> cols = { {col, col, col, col} };\r\n\t\tDrawExplicitDecal(nullptr, points.data(), uvs.data(), cols.data(), 4);\r\n\t\tSetDecalMode(m);\r\n\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel col)\r\n\t{\r\n\t\tolc::vf2d vNewSize = size;// (size - olc::vf2d(0.375f, 0.375f)).ceil();\r\n\t\tstd::array<olc::vf2d, 4> points = { { {pos}, {pos.x, pos.y + vNewSize.y}, {pos + vNewSize}, {pos.x + vNewSize.x, pos.y} } };\r\n\t\tstd::array<olc::vf2d, 4> uvs = { {{0,0},{0,0},{0,0},{0,0}} };\r\n\t\tstd::array<olc::Pixel, 4> cols = { {col, col, col, col} };\r\n\t\tDrawExplicitDecal(nullptr, points.data(), uvs.data(), cols.data(), 4);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::GradientFillRectDecal(const olc::vf2d& pos, const olc::vf2d& size, const olc::Pixel colTL, const olc::Pixel colBL, const olc::Pixel colBR, const olc::Pixel colTR)\r\n\t{\r\n\t\tstd::array<olc::vf2d, 4> points = { { {pos}, {pos.x, pos.y + size.y}, {pos + size}, {pos.x + size.x, pos.y} } };\r\n\t\tstd::array<olc::vf2d, 4> uvs = { {{0,0},{0,0},{0,0},{0,0}} };\r\n\t\tstd::array<olc::Pixel, 4> cols = { {colTL, colBL, colBR, colTR} };\r\n\t\tDrawExplicitDecal(nullptr, points.data(), uvs.data(), cols.data(), 4);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::FillTriangleDecal(const olc::vf2d& p0, const olc::vf2d& p1, const olc::vf2d& p2, const olc::Pixel col)\r\n\t{\t\t\r\n\t\tstd::array<olc::vf2d, 4> points = { { p0, p1, p2 } };\r\n\t\tstd::array<olc::vf2d, 4> uvs = { {{0,0},{0,0},{0,0}} };\r\n\t\tstd::array<olc::Pixel, 4> cols = { {col, col, col} };\r\n\t\tDrawExplicitDecal(nullptr, points.data(), uvs.data(), cols.data(), 3);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::GradientTriangleDecal(const olc::vf2d& p0, const olc::vf2d& p1, const olc::vf2d& p2, const olc::Pixel c0, const olc::Pixel c1, const olc::Pixel c2)\r\n\t{\r\n\t\tstd::array<olc::vf2d, 4> points = { { p0, p1, p2 } };\r\n\t\tstd::array<olc::vf2d, 4> uvs = { {{0,0},{0,0},{0,0}} };\r\n\t\tstd::array<olc::Pixel, 4> cols = { {c0, c1, c2} };\r\n\t\tDrawExplicitDecal(nullptr, points.data(), uvs.data(), cols.data(), 3);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawRotatedDecal(const olc::vf2d& pos, olc::Decal* decal, const float fAngle, const olc::vf2d& center, const olc::vf2d& scale, const olc::Pixel& tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.pos.resize(4);\r\n\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.points = 4;\r\n\t\tdi.pos[0] = (olc::vf2d(0.0f, 0.0f) - center) * scale;\r\n\t\tdi.pos[1] = (olc::vf2d(0.0f, float(decal->sprite->height)) - center) * scale;\r\n\t\tdi.pos[2] = (olc::vf2d(float(decal->sprite->width), float(decal->sprite->height)) - center) * scale;\r\n\t\tdi.pos[3] = (olc::vf2d(float(decal->sprite->width), 0.0f) - center) * scale;\r\n\t\tfloat c = cos(fAngle), s = sin(fAngle);\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = pos + olc::vf2d(di.pos[i].x * c - di.pos[i].y * s, di.pos[i].x * s + di.pos[i].y * c);\r\n\t\t\tdi.pos[i] = di.pos[i] * vInvScreenSize * 2.0f - olc::vf2d(1.0f, 1.0f);\r\n\t\t\tdi.pos[i].y *= -1.0f;\r\n\t\t\tdi.w[i] = 1;\r\n\t\t}\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::DrawPartialRotatedDecal(const olc::vf2d& pos, olc::Decal* decal, const float fAngle, const olc::vf2d& center, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::vf2d& scale, const olc::Pixel& tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.decal = decal;\r\n\t\tdi.points = 4;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.pos.resize(4);\r\n\t\tdi.pos[0] = (olc::vf2d(0.0f, 0.0f) - center) * scale;\r\n\t\tdi.pos[1] = (olc::vf2d(0.0f, source_size.y) - center) * scale;\r\n\t\tdi.pos[2] = (olc::vf2d(source_size.x, source_size.y) - center) * scale;\r\n\t\tdi.pos[3] = (olc::vf2d(source_size.x, 0.0f) - center) * scale;\r\n\t\tfloat c = cos(fAngle), s = sin(fAngle);\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tdi.pos[i] = pos + olc::vf2d(di.pos[i].x * c - di.pos[i].y * s, di.pos[i].x * s + di.pos[i].y * c);\r\n\t\t\tdi.pos[i] = di.pos[i] * vInvScreenSize * 2.0f - olc::vf2d(1.0f, 1.0f);\r\n\t\t\tdi.pos[i].y *= -1.0f;\r\n\t\t}\r\n\r\n\t\tolc::vf2d uvtl = source_pos * decal->vUVScale;\r\n\t\tolc::vf2d uvbr = uvtl + (source_size * decal->vUVScale);\r\n\t\tdi.uv = { { uvtl.x, uvtl.y }, { uvtl.x, uvbr.y }, { uvbr.x, uvbr.y }, { uvbr.x, uvtl.y } };\r\n\t\tdi.mode = nDecalMode;\r\n\t\tdi.structure = nDecalStructure;\r\n\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawPartialWarpedDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint)\r\n\t{\r\n\t\tDecalInstance di;\r\n\t\tdi.points = 4;\r\n\t\tdi.decal = decal;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.pos.resize(4);\r\n\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\tolc::vf2d center;\r\n\t\tfloat rd = ((pos[2].x - pos[0].x) * (pos[3].y - pos[1].y) - (pos[3].x - pos[1].x) * (pos[2].y - pos[0].y));\r\n\t\tif (rd != 0)\r\n\t\t{\r\n\t\t\tolc::vf2d uvtl = source_pos * decal->vUVScale;\r\n\t\t\tolc::vf2d uvbr = uvtl + (source_size * decal->vUVScale);\r\n\t\t\tdi.uv = { { uvtl.x, uvtl.y }, { uvtl.x, uvbr.y }, { uvbr.x, uvbr.y }, { uvbr.x, uvtl.y } };\r\n\r\n\t\t\trd = 1.0f / rd;\r\n\t\t\tfloat rn = ((pos[3].x - pos[1].x) * (pos[0].y - pos[1].y) - (pos[3].y - pos[1].y) * (pos[0].x - pos[1].x)) * rd;\r\n\t\t\tfloat sn = ((pos[2].x - pos[0].x) * (pos[0].y - pos[1].y) - (pos[2].y - pos[0].y) * (pos[0].x - pos[1].x)) * rd;\r\n\t\t\tif (!(rn < 0.f || rn > 1.f || sn < 0.f || sn > 1.f)) center = pos[0] + rn * (pos[2] - pos[0]);\r\n\t\t\tfloat d[4];\tfor (int i = 0; i < 4; i++)\td[i] = (pos[i] - center).mag();\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tfloat q = d[i] == 0.0f ? 1.0f : (d[i] + d[(i + 2) & 3]) / d[(i + 2) & 3];\r\n\t\t\t\tdi.uv[i] *= q; di.w[i] *= q;\r\n\t\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\t}\r\n\t\t\tdi.mode = nDecalMode;\r\n\t\t\tdi.structure = nDecalStructure;\r\n\t\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawWarpedDecal(olc::Decal* decal, const olc::vf2d* pos, const olc::Pixel& tint)\r\n\t{\r\n\t\t// Thanks Nathan Reed, a brilliant article explaining whats going on here\r\n\t\t// http://www.reedbeta.com/blog/quadrilateral-interpolation-part-1/\r\n\t\tDecalInstance di;\r\n\t\tdi.points = 4;\r\n\t\tdi.decal = decal;\r\n\t\tdi.tint = { tint, tint, tint, tint };\r\n\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\tdi.pos.resize(4);\r\n\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\tolc::vf2d center;\r\n\t\tfloat rd = ((pos[2].x - pos[0].x) * (pos[3].y - pos[1].y) - (pos[3].x - pos[1].x) * (pos[2].y - pos[0].y));\r\n\t\tif (rd != 0)\r\n\t\t{\r\n\t\t\trd = 1.0f / rd;\r\n\t\t\tfloat rn = ((pos[3].x - pos[1].x) * (pos[0].y - pos[1].y) - (pos[3].y - pos[1].y) * (pos[0].x - pos[1].x)) * rd;\r\n\t\t\tfloat sn = ((pos[2].x - pos[0].x) * (pos[0].y - pos[1].y) - (pos[2].y - pos[0].y) * (pos[0].x - pos[1].x)) * rd;\r\n\t\t\tif (!(rn < 0.f || rn > 1.f || sn < 0.f || sn > 1.f)) center = pos[0] + rn * (pos[2] - pos[0]);\r\n\t\t\tfloat d[4];\tfor (int i = 0; i < 4; i++)\td[i] = (pos[i] - center).mag();\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tfloat q = d[i] == 0.0f ? 1.0f : (d[i] + d[(i + 2) & 3]) / d[(i + 2) & 3];\r\n\t\t\t\tdi.uv[i] *= q; di.w[i] *= q;\r\n\t\t\t\tdi.pos[i] = { (pos[i].x * vInvScreenSize.x) * 2.0f - 1.0f, ((pos[i].y * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f };\r\n\t\t\t}\r\n\t\t\tdi.mode = nDecalMode;\r\n\t\t\tdi.structure = nDecalStructure;\r\n\t\t\tvLayers[nTargetLayer].vecDecalInstance.push_back(di);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawWarpedDecal(olc::Decal* decal, const std::array<olc::vf2d, 4>& pos, const olc::Pixel& tint)\r\n\t{ DrawWarpedDecal(decal, pos.data(), tint); }\r\n\r\n\tvoid PixelGameEngine::DrawWarpedDecal(olc::Decal* decal, const olc::vf2d(&pos)[4], const olc::Pixel& tint)\r\n\t{ DrawWarpedDecal(decal, &pos[0], tint); }\r\n\r\n\tvoid PixelGameEngine::DrawPartialWarpedDecal(olc::Decal* decal, const std::array<olc::vf2d, 4>& pos, const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint)\r\n\t{ DrawPartialWarpedDecal(decal, pos.data(), source_pos, source_size, tint); }\r\n\r\n\tvoid PixelGameEngine::DrawPartialWarpedDecal(olc::Decal* decal, const olc::vf2d(&pos)[4], const olc::vf2d& source_pos, const olc::vf2d& source_size, const olc::Pixel& tint)\r\n\t{ DrawPartialWarpedDecal(decal, &pos[0], source_pos, source_size, tint); }\r\n\r\n\tvoid PixelGameEngine::DrawStringDecal(const olc::vf2d& pos, const std::string& sText, const Pixel col, const olc::vf2d& scale)\r\n\t{\r\n\t\tolc::vf2d spos = { 0.0f, 0.0f };\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tspos.x = 0; spos.y += 8.0f * scale.y;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tspos.x += 8.0f * float(nTabSizeInSpaces) * scale.x;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\t\t\t\tDrawPartialDecal(pos + spos, fontRenderable.Decal(), {float(ox) * 8.0f, float(oy) * 8.0f}, {8.0f, 8.0f}, scale, col);\r\n\t\t\t\tspos.x += 8.0f * scale.x;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawStringPropDecal(const olc::vf2d& pos, const std::string& sText, const Pixel col, const olc::vf2d& scale)\r\n\t{\r\n\t\tolc::vf2d spos = { 0.0f, 0.0f };\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tspos.x = 0; spos.y += 8.0f * scale.y;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tspos.x += 8.0f * float(nTabSizeInSpaces) * scale.x;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\t\t\t\tDrawPartialDecal(pos + spos, fontRenderable.Decal(), { float(ox) * 8.0f + float(vFontSpacing[c - 32].x), float(oy) * 8.0f }, { float(vFontSpacing[c - 32].y), 8.0f }, scale, col);\r\n\t\t\t\tspos.x += float(vFontSpacing[c - 32].y) * scale.x;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Thanks Oso-Grande/Sopadeoso For these awesom and stupidly clever Text Rotation routines... duh XD\r\n\tvoid PixelGameEngine::DrawRotatedStringDecal(const olc::vf2d& pos, const std::string& sText, const float fAngle, const olc::vf2d& center, const Pixel col, const olc::vf2d& scale)\r\n\t{\r\n\t\tolc::vf2d spos = center;\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tspos.x = center.x; spos.y -= 8.0f;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tspos.x += 8.0f * float(nTabSizeInSpaces) * scale.x;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\t\t\t\tDrawPartialRotatedDecal(pos, fontRenderable.Decal(), fAngle, spos, { float(ox) * 8.0f, float(oy) * 8.0f }, { 8.0f, 8.0f }, scale, col);\r\n\t\t\t\tspos.x -= 8.0f;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawRotatedStringPropDecal(const olc::vf2d& pos, const std::string& sText, const float fAngle, const olc::vf2d& center, const Pixel col, const olc::vf2d& scale)\r\n\t{\r\n\t\tolc::vf2d spos = center;\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tspos.x = center.x; spos.y -= 8.0f;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tspos.x += 8.0f * float(nTabSizeInSpaces) * scale.x;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\t\t\t\tDrawPartialRotatedDecal(pos, fontRenderable.Decal(), fAngle, spos, { float(ox) * 8.0f + float(vFontSpacing[c - 32].x), float(oy) * 8.0f }, { float(vFontSpacing[c - 32].y), 8.0f }, scale, col);\r\n\t\t\t\tspos.x -= float(vFontSpacing[c - 32].y);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tolc::vi2d PixelGameEngine::GetTextSize(const std::string& s)\r\n\t{\r\n\t\tolc::vi2d size = { 0,1 };\r\n\t\tolc::vi2d pos = { 0,1 };\r\n\t\tfor (auto c : s)\r\n\t\t{\r\n\t\t\tif (c == '\\n') { pos.y++;  pos.x = 0; }\r\n\t\t\telse if (c == '\\t') { pos.x += nTabSizeInSpaces; }\r\n\t\t\telse pos.x++;\r\n\t\t\tsize.x = std::max(size.x, pos.x);\r\n\t\t\tsize.y = std::max(size.y, pos.y);\r\n\t\t}\r\n\t\treturn size * 8;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawString(const olc::vi2d& pos, const std::string& sText, Pixel col, uint32_t scale)\r\n\t{ DrawString(pos.x, pos.y, sText, col, scale); }\r\n\r\n\tvoid PixelGameEngine::DrawString(int32_t x, int32_t y, const std::string& sText, Pixel col, uint32_t scale)\r\n\t{\r\n\t\tint32_t sx = 0;\r\n\t\tint32_t sy = 0;\r\n\t\tPixel::Mode m = nPixelMode;\r\n\t\t// Thanks @tucna, spotted bug with col.ALPHA :P\r\n\t\tif (m != Pixel::CUSTOM) // Thanks @Megarev, required for \"shaders\"\r\n\t\t{\r\n\t\t\tif (col.a != 255)\t\tSetPixelMode(Pixel::ALPHA);\r\n\t\t\telse\t\t\t\t\tSetPixelMode(Pixel::MASK);\r\n\t\t}\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tsx = 0; sy += 8 * scale;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tsx += 8 * nTabSizeInSpaces * scale;\r\n\t\t\t}\r\n\t\t\telse\t\t\t\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\r\n\t\t\t\tif (scale > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (uint32_t i = 0; i < 8; i++)\r\n\t\t\t\t\t\tfor (uint32_t j = 0; j < 8; j++)\r\n\t\t\t\t\t\t\tif (fontRenderable.Sprite()->GetPixel(i + ox * 8, j + oy * 8).r > 0)\r\n\t\t\t\t\t\t\t\tfor (uint32_t is = 0; is < scale; is++)\r\n\t\t\t\t\t\t\t\t\tfor (uint32_t js = 0; js < scale; js++)\r\n\t\t\t\t\t\t\t\t\t\tDraw(x + sx + (i * scale) + is, y + sy + (j * scale) + js, col);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (uint32_t i = 0; i < 8; i++)\r\n\t\t\t\t\t\tfor (uint32_t j = 0; j < 8; j++)\r\n\t\t\t\t\t\t\tif (fontRenderable.Sprite()->GetPixel(i + ox * 8, j + oy * 8).r > 0)\r\n\t\t\t\t\t\t\t\tDraw(x + sx + i, y + sy + j, col);\r\n\t\t\t\t}\r\n\t\t\t\tsx += 8 * scale;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSetPixelMode(m);\r\n\t}\r\n\r\n\tolc::vi2d PixelGameEngine::GetTextSizeProp(const std::string& s)\r\n\t{\r\n\t\tolc::vi2d size = { 0,1 };\r\n\t\tolc::vi2d pos = { 0,1 };\r\n\t\tfor (auto c : s)\r\n\t\t{\r\n\t\t\tif (c == '\\n') { pos.y += 1;  pos.x = 0; }\r\n\t\t\telse if (c == '\\t') { pos.x += nTabSizeInSpaces * 8; }\r\n\t\t\telse pos.x += vFontSpacing[c - 32].y;\r\n\t\t\tsize.x = std::max(size.x, pos.x);\r\n\t\t\tsize.y = std::max(size.y, pos.y);\r\n\t\t}\r\n\r\n\t\tsize.y *= 8;\r\n\t\treturn size;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::DrawStringProp(const olc::vi2d& pos, const std::string& sText, Pixel col, uint32_t scale)\r\n\t{ DrawStringProp(pos.x, pos.y, sText, col, scale); }\r\n\r\n\tvoid PixelGameEngine::DrawStringProp(int32_t x, int32_t y, const std::string& sText, Pixel col, uint32_t scale)\r\n\t{\r\n\t\tint32_t sx = 0;\r\n\t\tint32_t sy = 0;\r\n\t\tPixel::Mode m = nPixelMode;\r\n\r\n\t\tif (m != Pixel::CUSTOM)\r\n\t\t{\r\n\t\t\tif (col.a != 255)\t\tSetPixelMode(Pixel::ALPHA);\r\n\t\t\telse\t\t\t\t\tSetPixelMode(Pixel::MASK);\r\n\t\t}\r\n\t\tfor (auto c : sText)\r\n\t\t{\r\n\t\t\tif (c == '\\n')\r\n\t\t\t{\r\n\t\t\t\tsx = 0; sy += 8 * scale;\r\n\t\t\t}\r\n\t\t\telse if (c == '\\t')\r\n\t\t\t{\r\n\t\t\t\tsx += 8 * nTabSizeInSpaces * scale;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint32_t ox = (c - 32) % 16;\r\n\t\t\t\tint32_t oy = (c - 32) / 16;\r\n\r\n\t\t\t\tif (scale > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int32_t i = 0; i < vFontSpacing[c - 32].y; i++)\r\n\t\t\t\t\t\tfor (int32_t j = 0; j < 8; j++)\r\n\t\t\t\t\t\t\tif (fontRenderable.Sprite()->GetPixel(i + ox * 8 + vFontSpacing[c - 32].x, j + oy * 8).r > 0)\r\n\t\t\t\t\t\t\t\tfor (int32_t is = 0; is < int(scale); is++)\r\n\t\t\t\t\t\t\t\t\tfor (int32_t js = 0; js < int(scale); js++)\r\n\t\t\t\t\t\t\t\t\t\tDraw(x + sx + (i * scale) + is, y + sy + (j * scale) + js, col);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int32_t i = 0; i < vFontSpacing[c - 32].y; i++)\r\n\t\t\t\t\t\tfor (int32_t j = 0; j < 8; j++)\r\n\t\t\t\t\t\t\tif (fontRenderable.Sprite()->GetPixel(i + ox * 8 + vFontSpacing[c - 32].x, j + oy * 8).r > 0)\r\n\t\t\t\t\t\t\t\tDraw(x + sx + i, y + sy + j, col);\r\n\t\t\t\t}\r\n\t\t\t\tsx += vFontSpacing[c - 32].y * scale;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSetPixelMode(m);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::SetPixelMode(Pixel::Mode m)\r\n\t{ nPixelMode = m; }\r\n\r\n\tPixel::Mode PixelGameEngine::GetPixelMode()\r\n\t{ return nPixelMode; }\r\n\r\n\tvoid PixelGameEngine::SetPixelMode(std::function<olc::Pixel(const int x, const int y, const olc::Pixel&, const olc::Pixel&)> pixelMode)\r\n\t{\r\n\t\tfuncPixelMode = pixelMode;\r\n\t\tnPixelMode = Pixel::Mode::CUSTOM;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::SetPixelBlend(float fBlend)\r\n\t{\r\n\t\tfBlendFactor = fBlend;\r\n\t\tif (fBlendFactor < 0.0f) fBlendFactor = 0.0f;\r\n\t\tif (fBlendFactor > 1.0f) fBlendFactor = 1.0f;\r\n\t}\r\n\r\n\tstd::stringstream& PixelGameEngine::ConsoleOut()\r\n\t{ return ssConsoleOutput; }\r\n\r\n\tbool PixelGameEngine::IsConsoleShowing() const\r\n\t{ return bConsoleShow; }\r\n\r\n\tvoid PixelGameEngine::ConsoleShow(const olc::Key& keyExit, bool bSuspendTime)\r\n\t{\r\n\t\tif (bConsoleShow)\r\n\t\t\treturn;\r\n\r\n\t\tbConsoleShow = true;\t\t\r\n\t\tbConsoleSuspendTime = bSuspendTime;\r\n\t\tTextEntryEnable(true);\r\n\t\tkeyConsoleExit = keyExit;\r\n\t\tpKeyboardState[keyConsoleExit].bHeld = false;\r\n\t\tpKeyboardState[keyConsoleExit].bPressed = false;\r\n\t\tpKeyboardState[keyConsoleExit].bReleased = true;\r\n\t}\r\n\t\r\n\tvoid PixelGameEngine::ConsoleClear()\r\n\t{ sConsoleLines.clear(); }\r\n\r\n\tvoid PixelGameEngine::ConsoleCaptureStdOut(const bool bCapture)\r\n\t{\r\n\t\tif(bCapture)\r\n\t\t\tsbufOldCout = std::cout.rdbuf(ssConsoleOutput.rdbuf());\r\n\t\telse\r\n\t\t\tstd::cout.rdbuf(sbufOldCout);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::UpdateConsole()\r\n\t{\r\n\t\tif (GetKey(keyConsoleExit).bPressed)\r\n\t\t{\r\n\t\t\tTextEntryEnable(false);\r\n\t\t\tbConsoleSuspendTime = false;\r\n\t\t\tbConsoleShow = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Keep Console sizes based in real screen dimensions\r\n\t\tvConsoleCharacterScale = olc::vf2d(1.0f, 2.0f) / (olc::vf2d(vViewSize) * vInvScreenSize);\r\n\t\tvConsoleSize = (vViewSize / olc::vi2d(8, 16)) - olc::vi2d(2, 4);\r\n\r\n\t\t// If console has changed size, simply reset it\r\n\t\tif (vConsoleSize.y != sConsoleLines.size())\r\n\t\t{\r\n\t\t\tvConsoleCursor = { 0,0 };\r\n\t\t\tsConsoleLines.clear();\r\n\t\t\tsConsoleLines.resize(vConsoleSize.y);\r\n\t\t}\r\n\r\n\t\tauto TypeCharacter = [&](const char c)\r\n\t\t{\r\n\t\t\tif (c >= 32 && c < 127)\r\n\t\t\t{\r\n\t\t\t\tsConsoleLines[vConsoleCursor.y].append(1, c);\r\n\t\t\t\tvConsoleCursor.x++;\r\n\t\t\t}\r\n\r\n\t\t\tif( c == '\\n' || vConsoleCursor.x >= vConsoleSize.x)\r\n\t\t\t{\r\n\t\t\t\tvConsoleCursor.y++; vConsoleCursor.x = 0;\t\t\t\t\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\tif (vConsoleCursor.y >= vConsoleSize.y)\r\n\t\t\t{\r\n\t\t\t\tvConsoleCursor.y = vConsoleSize.y - 1;\r\n\t\t\t\tfor (int i = 1; i < vConsoleSize.y; i++)\r\n\t\t\t\t\tsConsoleLines[i - 1] = sConsoleLines[i];\r\n\t\t\t\tsConsoleLines[vConsoleCursor.y].clear();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Empty out \"std::cout\", parsing as we go\r\n\t\twhile (ssConsoleOutput.rdbuf()->sgetc() != -1)\r\n\t\t{\r\n\t\t\tchar c = ssConsoleOutput.rdbuf()->sbumpc();\r\n\t\t\tTypeCharacter(c);\r\n\t\t}\r\n\r\n\t\t// Draw Shadow\r\n\t\tGradientFillRectDecal({ 0,0 }, olc::vf2d(vScreenSize), olc::PixelF(0, 0, 0.5f, 0.5f), olc::PixelF(0, 0, 0.25f, 0.5f), olc::PixelF(0, 0, 0.25f, 0.5f), olc::PixelF(0, 0, 0.25f, 0.5f));\r\n\t\t\t\t\r\n\t\t// Draw the console buffer\r\n\t\tSetDecalMode(olc::DecalMode::NORMAL);\r\n\t\tfor (int32_t nLine = 0; nLine < vConsoleSize.y; nLine++)\r\n\t\t\tDrawStringDecal(olc::vf2d( 1, 1 + float(nLine) ) * vConsoleCharacterScale * 8.0f, sConsoleLines[nLine], olc::WHITE, vConsoleCharacterScale);\r\n\r\n\t\t// Draw Input State\r\n\t\tFillRectDecal(olc::vf2d(1 + float((TextEntryGetCursor() + 1)), 1 + float((vConsoleSize.y - 1))) * vConsoleCharacterScale * 8.0f, olc::vf2d(8, 8) * vConsoleCharacterScale, olc::DARK_CYAN);\r\n\t\tDrawStringDecal(olc::vf2d(1, 1 + float((vConsoleSize.y - 1))) * vConsoleCharacterScale * 8.0f, std::string(\">\") + TextEntryGetString(), olc::YELLOW, vConsoleCharacterScale);\t\t\r\n\t}\r\n\r\n\r\n\tconst std::vector<std::string>& PixelGameEngine::GetDroppedFiles() const\r\n\t{ return vDroppedFiles;\t}\r\n\r\n\tconst olc::vi2d& PixelGameEngine::GetDroppedFilesPoint() const\r\n\t{ return vDroppedFilesPoint; }\r\n\r\n\r\n\tvoid PixelGameEngine::TextEntryEnable(const bool bEnable, const std::string& sText)\r\n\t{\r\n\t\tif (bEnable)\r\n\t\t{\r\n\t\t\tnTextEntryCursor = int32_t(sText.size());\r\n\t\t\tsTextEntryString = sText;\r\n\t\t\tbTextEntryEnable = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbTextEntryEnable = false;\r\n\t\t}\r\n\t}\r\n\r\n\tstd::string PixelGameEngine::TextEntryGetString() const\r\n\t{ return sTextEntryString; }\r\n\r\n\tint32_t PixelGameEngine::TextEntryGetCursor() const\r\n\t{ return nTextEntryCursor; }\r\n\r\n\tbool PixelGameEngine::IsTextEntryEnabled() const\r\n\t{ return bTextEntryEnable; }\r\n\r\n\r\n\tvoid PixelGameEngine::UpdateTextEntry()\r\n\t{\r\n\t\t// Check for typed characters\r\n\t\tfor (const auto& key : vKeyboardMap)\r\n\t\t\tif (GetKey(std::get<0>(key)).bPressed)\r\n\t\t\t{\r\n\t\t\t\tsTextEntryString.insert(nTextEntryCursor, GetKey(olc::Key::SHIFT).bHeld ? std::get<2>(key) : std::get<1>(key));\r\n\t\t\t\tnTextEntryCursor++;\r\n\t\t\t}\r\n\r\n\t\t// Check for command characters\r\n\t\tif (GetKey(olc::Key::LEFT).bPressed)\r\n\t\t\tnTextEntryCursor = std::max(0, nTextEntryCursor - 1);\r\n\t\tif (GetKey(olc::Key::RIGHT).bPressed)\r\n\t\t\tnTextEntryCursor = std::min(int32_t(sTextEntryString.size()), nTextEntryCursor + 1);\r\n\t\tif (GetKey(olc::Key::BACK).bPressed && nTextEntryCursor > 0)\r\n\t\t{\r\n\t\t\tsTextEntryString.erase(nTextEntryCursor-1, 1);\r\n\t\t\tnTextEntryCursor = std::max(0, nTextEntryCursor - 1);\r\n\t\t}\r\n\t\tif (GetKey(olc::Key::DEL).bPressed && size_t(nTextEntryCursor) < sTextEntryString.size())\r\n\t\t\tsTextEntryString.erase(nTextEntryCursor, 1);\t\r\n\r\n\t\tif (GetKey(olc::Key::UP).bPressed)\r\n\t\t{\r\n\t\t\tif (!sCommandHistory.empty())\r\n\t\t\t{\r\n\t\t\t\tif (sCommandHistoryIt != sCommandHistory.begin())\r\n\t\t\t\t\tsCommandHistoryIt--;\r\n\r\n\t\t\t\tnTextEntryCursor = int32_t(sCommandHistoryIt->size());\r\n\t\t\t\tsTextEntryString = *sCommandHistoryIt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (GetKey(olc::Key::DOWN).bPressed)\r\n\t\t{\t\r\n\t\t\tif (!sCommandHistory.empty())\r\n\t\t\t{\r\n\t\t\t\tif (sCommandHistoryIt != sCommandHistory.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tsCommandHistoryIt++;\r\n\t\t\t\t\tif (sCommandHistoryIt != sCommandHistory.end())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnTextEntryCursor = int32_t(sCommandHistoryIt->size());\r\n\t\t\t\t\t\tsTextEntryString = *sCommandHistoryIt;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnTextEntryCursor = 0;\r\n\t\t\t\t\t\tsTextEntryString = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (GetKey(olc::Key::ENTER).bPressed)\r\n\t\t{\r\n\t\t\tif (bConsoleShow)\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \">\" + sTextEntryString + \"\\n\";\r\n\t\t\t\tif (OnConsoleCommand(sTextEntryString))\r\n\t\t\t\t{\r\n\t\t\t\t\tsCommandHistory.push_back(sTextEntryString);\r\n\t\t\t\t\tsCommandHistoryIt = sCommandHistory.end();\r\n\t\t\t\t}\r\n\t\t\t\tsTextEntryString.clear();\r\n\t\t\t\tnTextEntryCursor = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tOnTextEntryComplete(sTextEntryString);\r\n\t\t\t\tTextEntryEnable(false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// User must override these functions as required. I have not made\r\n\t// them abstract because I do need a default behaviour to occur if\r\n\t// they are not overwritten\r\n\r\n\tbool PixelGameEngine::OnUserCreate()\r\n\t{ return false;\t}\r\n\r\n\tbool PixelGameEngine::OnUserUpdate(float fElapsedTime)\r\n\t{ UNUSED(fElapsedTime);  return false; }\r\n\r\n\tbool PixelGameEngine::OnUserDestroy()\r\n\t{ return true; }\r\n\r\n\tvoid PixelGameEngine::OnTextEntryComplete(const std::string& sText) { UNUSED(sText); }\r\n\tbool PixelGameEngine::OnConsoleCommand(const std::string& sCommand) { UNUSED(sCommand); return false; }\r\n\t\r\n\r\n\tolc::rcode PixelGameEngine::SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize)\r\n\t{\r\n\t\tif (platform)\r\n\t\t\treturn platform->SetWindowSize(vPos, vSize);\r\n\t\telse\r\n\t\t\treturn olc::FAIL;\r\n\t}\r\n\t\r\n\tolc::rcode PixelGameEngine::ShowWindowFrame(const bool bShowFrame)\r\n\t{\r\n\t\tif (platform)\r\n\t\t\treturn platform->ShowWindowFrame(bShowFrame);\r\n\t\telse\r\n\t\t\treturn olc::FAIL;\r\n\t}\r\n\r\n\r\n\t// Externalised API\r\n\tvoid PixelGameEngine::olc_UpdateViewport()\r\n\t{\r\n\t\tif (bRealWindowMode)\r\n\t\t{\r\n\t\t\tvPixelSize = { 1,1 };\r\n\t\t\tvViewSize = vScreenSize;\r\n\t\t\tvViewPos = { 0,0 };\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint32_t ww = vScreenSize.x * vPixelSize.x;\r\n\t\tint32_t wh = vScreenSize.y * vPixelSize.y;\r\n\t\tfloat wasp = (float)ww / (float)wh;\r\n\r\n\t\tif (bPixelCohesion)\r\n\t\t{\r\n\t\t\tvScreenPixelSize = (vWindowSize / vScreenSize);\r\n\t\t\tvViewSize = (vWindowSize / vScreenSize) * vScreenSize;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvViewSize.x = (int32_t)vWindowSize.x;\r\n\t\t\tvViewSize.y = (int32_t)((float)vViewSize.x / wasp);\r\n\r\n\t\t\tif (vViewSize.y > vWindowSize.y)\r\n\t\t\t{\r\n\t\t\t\tvViewSize.y = vWindowSize.y;\r\n\t\t\t\tvViewSize.x = (int32_t)((float)vViewSize.y * wasp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvViewPos = (vWindowSize - vViewSize) / 2;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_UpdateWindowPos(int32_t x, int32_t y)\r\n\t{\r\n\t\tvWindowPos = { x, y };\t\r\n\t\tolc_UpdateViewport();\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_UpdateWindowSize(int32_t x, int32_t y)\r\n\t{\r\n\t\tvWindowSize = { x, y };\r\n\r\n\t\tif (bRealWindowMode)\r\n\t\t{\r\n\t\t\tvResizeRequested = vWindowSize;\r\n\t\t\tbResizeRequested = true;\t\t\t\r\n\t\t}\r\n\r\n\t\tolc_UpdateViewport();\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_UpdateMouseWheel(int32_t delta)\r\n\t{ nMouseWheelDeltaCache += delta; }\r\n\r\n\tvoid PixelGameEngine::olc_UpdateMouse(int32_t x, int32_t y)\r\n\t{\r\n\t\t// Mouse coords come in screen space\r\n\t\t// But leave in pixel space\r\n\t\tbHasMouseFocus = true;\r\n\t\tvMouseWindowPos = { x, y };\r\n\t\t// Full Screen mode may have a weird viewport we must clamp to\r\n\t\tx -= vViewPos.x;\r\n\t\ty -= vViewPos.y;\r\n\t\tvMousePosCache.x = (int32_t)(((float)x / (float)(vWindowSize.x - (vViewPos.x * 2)) * (float)vScreenSize.x));\r\n\t\tvMousePosCache.y = (int32_t)(((float)y / (float)(vWindowSize.y - (vViewPos.y * 2)) * (float)vScreenSize.y));\r\n\t\tif (vMousePosCache.x >= (int32_t)vScreenSize.x)\tvMousePosCache.x = vScreenSize.x - 1;\r\n\t\tif (vMousePosCache.y >= (int32_t)vScreenSize.y)\tvMousePosCache.y = vScreenSize.y - 1;\r\n\t\tif (vMousePosCache.x < 0) vMousePosCache.x = 0;\r\n\t\tif (vMousePosCache.y < 0) vMousePosCache.y = 0;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_UpdateMouseState(int32_t button, bool state)\r\n\t{ pMouseNewState[button] = state; }\r\n\r\n\tvoid PixelGameEngine::olc_UpdateKeyState(int32_t key, bool state)\r\n\t{ pKeyNewState[key] = state; }\r\n\r\n\tvoid PixelGameEngine::olc_UpdateMouseFocus(bool state)\r\n\t{ bHasMouseFocus = state; }\r\n\r\n\tvoid PixelGameEngine::olc_UpdateKeyFocus(bool state)\r\n\t{ bHasInputFocus = state; }\r\n\r\n\tvoid PixelGameEngine::olc_DropFiles(int32_t x, int32_t y, const std::vector<std::string>& vFiles)\r\n\t{ \r\n\t\tx -= vViewPos.x;\r\n\t\ty -= vViewPos.y;\r\n\t\tvDroppedFilesPointCache.x = (int32_t)(((float)x / (float)(vWindowSize.x - (vViewPos.x * 2)) * (float)vScreenSize.x));\r\n\t\tvDroppedFilesPointCache.y = (int32_t)(((float)y / (float)(vWindowSize.y - (vViewPos.y * 2)) * (float)vScreenSize.y));\r\n\t\tif (vDroppedFilesPointCache.x >= (int32_t)vScreenSize.x)\tvDroppedFilesPointCache.x = vScreenSize.x - 1;\r\n\t\tif (vDroppedFilesPointCache.y >= (int32_t)vScreenSize.y)\tvDroppedFilesPointCache.y = vScreenSize.y - 1;\r\n\t\tif (vDroppedFilesPointCache.x < 0) vDroppedFilesPointCache.x = 0;\r\n\t\tif (vDroppedFilesPointCache.y < 0) vDroppedFilesPointCache.y = 0;\r\n\t\tvDroppedFilesCache = vFiles; \r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_Reanimate()\r\n\t{ bAtomActive = true; }\r\n\r\n\tbool PixelGameEngine::olc_IsRunning()\r\n\t{ return bAtomActive; }\r\n\r\n\tvoid PixelGameEngine::olc_Terminate()\r\n\t{ bAtomActive = false; }\r\n\r\n\tvoid PixelGameEngine::EngineThread()\r\n\t{\r\n\t\t// Allow platform to do stuff here if needed, since its now in the\r\n\t\t// context of this thread\r\n\t\tif (platform->ThreadStartUp() == olc::FAIL)\treturn;\r\n\r\n\t\t// Do engine context specific initialisation\r\n\t\tolc_PrepareEngine();\r\n\r\n\t\t// Create user resources as part of this thread\r\n\t\tfor (auto& ext : vExtensions) ext->OnBeforeUserCreate();\r\n\t\tif (!OnUserCreate()) bAtomActive = false;\r\n\t\tfor (auto& ext : vExtensions) ext->OnAfterUserCreate();\r\n\r\n\t\twhile (bAtomActive)\r\n\t\t{\r\n\t\t\t// Run as fast as possible\r\n\t\t\twhile (bAtomActive) { olc_CoreUpdate(); }\r\n\r\n\t\t\t// Allow the user to free resources if they have overrided the destroy function\r\n\t\t\tif (!OnUserDestroy())\r\n\t\t\t{\r\n\t\t\t\t// User denied destroy for some reason, so continue running\r\n\t\t\t\tbAtomActive = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tplatform->ThreadCleanUp();\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_PrepareEngine()\r\n\t{\r\n\t\t// Start OpenGL, the context is owned by the game thread\r\n\t\tif (platform->CreateGraphics(bFullScreen, bEnableVSYNC, vViewPos, vViewSize) == olc::FAIL) return;\r\n\r\n\t\t// Construct default font sheet\r\n\t\tolc_ConstructFontSheet();\r\n\r\n\t\t// Create Primary Layer \"0\"\r\n\t\tCreateLayer();\r\n\t\tvLayers[0].bUpdate = true;\r\n\t\tvLayers[0].bShow = true;\r\n\t\tSetDrawTarget(nullptr);\r\n\r\n\t\tm_tp1 = std::chrono::system_clock::now();\r\n\t\tm_tp2 = std::chrono::system_clock::now();\r\n\t}\r\n\r\n\r\n\tvoid PixelGameEngine::adv_ManualRenderEnable(const bool bEnable)\r\n\t{\r\n\t\tbManualRenderEnable = bEnable;\r\n\t}\r\n\r\n\tvoid PixelGameEngine::adv_HardwareClip(const bool bClipAndScale, const olc::vi2d & viewPos, const olc::vi2d & viewSize, const bool bClear)\r\n\t{\r\n\t\tolc::vf2d vNewSize = olc::vf2d(viewSize) / olc::vf2d(vScreenSize);\r\n\t\tolc::vf2d vNewPos = olc::vf2d(viewPos) / olc::vf2d(vScreenSize);\r\n\t\trenderer->UpdateViewport(vViewPos + vNewPos * vViewSize, vNewSize * vViewSize);\r\n\r\n\t\tif (bClear)\r\n\t\t\trenderer->ClearBuffer(olc::BLACK, true);\r\n\r\n\t\tSetDecalMode(DecalMode::NORMAL);\r\n\t\trenderer->PrepareDrawing();\r\n\r\n\t\tif(!bClipAndScale)\r\n\t\t\tvInvScreenSize = 1.0f / olc::vf2d(viewSize);\r\n\t\telse\r\n\t\t\tvInvScreenSize = 1.0f / olc::vf2d(vScreenSize);\r\n\t}\r\n\r\n\tvoid PixelGameEngine::adv_FlushLayer(const size_t nLayerID)\r\n\t{\r\n\t\tauto& layer = vLayers[nLayerID];\r\n\r\n\t\tif (layer.bShow)\r\n\t\t{\r\n\t\t\tif (layer.funcHook == nullptr)\r\n\t\t\t{\r\n\t\t\t\trenderer->ApplyTexture(layer.pDrawTarget.Decal()->id);\r\n\t\t\t\tif (!bSuspendTextureTransfer)\r\n\t\t\t\t{\r\n\t\t\t\t\tlayer.pDrawTarget.Decal()->Update();\r\n\t\t\t\t\tlayer.bUpdate = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Can't use this as it assumes full screen coords\r\n\t\t\t\t// renderer->DrawLayerQuad(layer.vOffset, layer.vScale, layer.tint);\t\t\t\r\n\t\t\t\t// Instead, render a textured decal\r\n\r\n\t\t\t\tolc::vf2d vScreenSpacePos =\r\n\t\t\t\t{\r\n\t\t\t\t\t(layer.vOffset.x  * vInvScreenSize.x) * 2.0f - 1.0f,\r\n\t\t\t\t\t((layer.vOffset.y  * vInvScreenSize.y) * 2.0f - 1.0f) * -1.0f\r\n\t\t\t\t};\r\n\r\n\t\t\t\tolc::vf2d vScreenSpaceDim =\r\n\t\t\t\t{\r\n\t\t\t\t\tvScreenSpacePos.x + (2.0f * (float(layer.pDrawTarget.Sprite()->width) * vInvScreenSize.x)) * layer.vScale.x,\r\n\t\t\t\t\tvScreenSpacePos.y - (2.0f * (float(layer.pDrawTarget.Sprite()->height) * vInvScreenSize.y)) * layer.vScale.y\r\n\t\t\t\t};\r\n\r\n\t\t\t\tDecalInstance di;\r\n\t\t\t\tdi.decal = layer.pDrawTarget.Decal();\r\n\t\t\t\tdi.points = 4;\r\n\t\t\t\tdi.tint = { olc::WHITE, olc::WHITE, olc::WHITE, olc::WHITE };\r\n\t\t\t\tdi.pos = { { vScreenSpacePos.x, vScreenSpacePos.y }, { vScreenSpacePos.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpaceDim.y }, { vScreenSpaceDim.x, vScreenSpacePos.y } };\r\n\t\t\t\tdi.uv = { { 0.0f, 0.0f}, {0.0f, 1.0f}, {1.0f, 1.0f}, {1.0f, 0.0f} };\r\n\t\t\t\tdi.w = { 1, 1, 1, 1 };\r\n\t\t\t\tdi.mode = DecalMode::NORMAL;\r\n\t\t\t\tdi.structure = DecalStructure::FAN;\r\n\t\t\t\trenderer->DrawDecal(di);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Mwa ha ha.... Have Fun!!!\r\n\t\t\t\tlayer.funcHook();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::adv_FlushLayerDecals(const size_t nLayerID)\r\n\t{\r\n\t\t// Display Decals in order for this layer\r\n\t\tauto& layer = vLayers[nLayerID];\r\n\t\tfor (auto& decal : layer.vecDecalInstance)\r\n\t\t\trenderer->DrawDecal(decal);\r\n\t\tlayer.vecDecalInstance.clear();\r\n\t}\r\n\r\n\r\n\r\n\tvoid PixelGameEngine::olc_CoreUpdate()\r\n\t{\r\n\t\t// Handle Timing\r\n\t\tm_tp2 = std::chrono::system_clock::now();\r\n\t\tstd::chrono::duration<float> elapsedTime = m_tp2 - m_tp1;\r\n\t\tm_tp1 = m_tp2;\r\n\r\n\t\t// Our time per frame coefficient\r\n\t\tfloat fElapsedTime = elapsedTime.count();\r\n\t\tfLastElapsed = fElapsedTime;\r\n\r\n\t\tif (bConsoleSuspendTime)\r\n\t\t\tfElapsedTime = 0.0f;\r\n\r\n\t\t// Some platforms will need to check for events\r\n\t\tplatform->HandleSystemEvent();\r\n\r\n\t\t// Compare hardware input states from previous frame\r\n\t\tauto ScanHardware = [&](HWButton* pKeys, bool* pStateOld, bool* pStateNew, uint32_t nKeyCount)\r\n\t\t{\r\n\t\t\tfor (uint32_t i = 0; i < nKeyCount; i++)\r\n\t\t\t{\r\n\t\t\t\tpKeys[i].bPressed = false;\r\n\t\t\t\tpKeys[i].bReleased = false;\r\n\t\t\t\tif (pStateNew[i] != pStateOld[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pStateNew[i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpKeys[i].bPressed = !pKeys[i].bHeld;\r\n\t\t\t\t\t\tpKeys[i].bHeld = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpKeys[i].bReleased = true;\r\n\t\t\t\t\t\tpKeys[i].bHeld = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tpStateOld[i] = pStateNew[i];\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tScanHardware(pKeyboardState, pKeyOldState, pKeyNewState, 256);\r\n\t\tScanHardware(pMouseState, pMouseOldState, pMouseNewState, nMouseButtons);\r\n\r\n\t\t// Cache mouse coordinates so they remain consistent during frame\r\n\t\tvMousePos = vMousePosCache;\r\n\t\tnMouseWheelDelta = nMouseWheelDeltaCache;\r\n\t\tnMouseWheelDeltaCache = 0;\r\n\r\n\t\tvDroppedFiles = vDroppedFilesCache;\r\n\t\tvDroppedFilesPoint = vDroppedFilesPointCache;\r\n\t\tvDroppedFilesCache.clear();\r\n\r\n\t\tif (bTextEntryEnable)\r\n\t\t{\r\n\t\t\tUpdateTextEntry();\r\n\t\t}\r\n\r\n\t\t// Handle Frame Update\r\n\t\tbool bExtensionBlockFrame = false;\t\t\r\n\t\tfor (auto& ext : vExtensions) bExtensionBlockFrame |= ext->OnBeforeUserUpdate(fElapsedTime);\r\n\t\tif (!bExtensionBlockFrame)\r\n\t\t{\r\n\t\t\tif (!OnUserUpdate(fElapsedTime)) bAtomActive = false;\r\n\t\t\t\r\n\t\t}\r\n\t\tfor (auto& ext : vExtensions) ext->OnAfterUserUpdate(fElapsedTime);\r\n\r\n\t\t\r\n\r\n\t\tif (bRealWindowMode)\r\n\t\t{\r\n\t\t\tvPixelSize = { 1,1 };\r\n\t\t\tvViewSize = vScreenSize;\r\n\t\t\tvViewPos = { 0,0 };\r\n\t\t}\r\n\r\n\t\tif (!bManualRenderEnable)\r\n\t\t{\r\n\t\t\tif (bConsoleShow)\r\n\t\t\t{\r\n\t\t\t\tSetDrawTarget((uint8_t)0);\r\n\t\t\t\tUpdateConsole();\r\n\t\t\t}\r\n\r\n\t\t\t// Display Frame\r\n\t\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t\t\trenderer->ClearBuffer(olc::BLACK, true);\r\n\r\n\t\t\t// Layer 0 must always exist\r\n\t\t\tvLayers[0].bUpdate = true;\r\n\t\t\tvLayers[0].bShow = true;\r\n\t\t\tSetDecalMode(DecalMode::NORMAL);\r\n\t\t\trenderer->PrepareDrawing();\r\n\r\n\t\t\tfor (auto layer = vLayers.rbegin(); layer != vLayers.rend(); ++layer)\r\n\t\t\t{\r\n\t\t\t\tif (layer->bShow)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (layer->funcHook == nullptr)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trenderer->ApplyTexture(layer->pDrawTarget.Decal()->id);\r\n\t\t\t\t\t\tif (!bSuspendTextureTransfer && layer->bUpdate)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlayer->pDrawTarget.Decal()->Update();\r\n\t\t\t\t\t\t\tlayer->bUpdate = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trenderer->DrawLayerQuad(layer->vOffset, layer->vScale, layer->tint);\r\n\r\n\t\t\t\t\t\t// Display Decals in order for this layer\r\n\t\t\t\t\t\tfor (auto& decal : layer->vecDecalInstance)\r\n\t\t\t\t\t\t\trenderer->DrawDecal(decal);\r\n\t\t\t\t\t\tlayer->vecDecalInstance.clear();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Mwa ha ha.... Have Fun!!!\r\n\t\t\t\t\t\tlayer->funcHook();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\r\n\r\n\t\t// Present Graphics to screen\r\n\t\trenderer->DisplayFrame();\r\n\r\n\t\tif (bResizeRequested)\r\n\t\t{\r\n\t\t\tbResizeRequested = false;\r\n\t\t\tSetScreenSize(vWindowSize.x, vWindowSize.y);\r\n\t\t\trenderer->UpdateViewport({ 0,0 }, vWindowSize);\r\n\t\t}\r\n\r\n\t\t// Update Title Bar\r\n\t\tfFrameTimer += fElapsedTime;\r\n\t\tnFrameCount++;\r\n\t\tif (fFrameTimer >= 1.0f)\r\n\t\t{\r\n\t\t\tnLastFPS = nFrameCount;\r\n\t\t\tfFrameTimer -= 1.0f;\r\n\t\t\tstd::string sTitle = \"OneLoneCoder.com - Pixel Game Engine - \" + sAppName + \" - FPS: \" + std::to_string(nFrameCount);\r\n\t\t\tplatform->SetWindowTitle(sTitle);\r\n\t\t\tnFrameCount = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid PixelGameEngine::olc_ConstructFontSheet()\r\n\t{\r\n\t\tstd::string data;\r\n\t\tdata += \"?Q`0001oOch0o01o@F40o0<AGD4090LAGD<090@A7ch0?00O7Q`0600>00000000\";\r\n\t\tdata += \"O000000nOT0063Qo4d8>?7a14Gno94AA4gno94AaOT0>o3`oO400o7QN00000400\";\r\n\t\tdata += \"Of80001oOg<7O7moBGT7O7lABET024@aBEd714AiOdl717a_=TH013Q>00000000\";\r\n\t\tdata += \"720D000V?V5oB3Q_HdUoE7a9@DdDE4A9@DmoE4A;Hg]oM4Aj8S4D84@`00000000\";\r\n\t\tdata += \"OaPT1000Oa`^13P1@AI[?g`1@A=[OdAoHgljA4Ao?WlBA7l1710007l100000000\";\r\n\t\tdata += \"ObM6000oOfMV?3QoBDD`O7a0BDDH@5A0BDD<@5A0BGeVO5ao@CQR?5Po00000000\";\r\n\t\tdata += \"Oc``000?Ogij70PO2D]??0Ph2DUM@7i`2DTg@7lh2GUj?0TO0C1870T?00000000\";\r\n\t\tdata += \"70<4001o?P<7?1QoHg43O;`h@GT0@:@LB@d0>:@hN@L0@?aoN@<0O7ao0000?000\";\r\n\t\tdata += \"OcH0001SOglLA7mg24TnK7ln24US>0PL24U140PnOgl0>7QgOcH0K71S0000A000\";\r\n\t\tdata += \"00H00000@Dm1S007@DUSg00?OdTnH7YhOfTL<7Yh@Cl0700?@Ah0300700000000\";\r\n\t\tdata += \"<008001QL00ZA41a@6HnI<1i@FHLM81M@@0LG81?O`0nC?Y7?`0ZA7Y300080000\";\r\n\t\tdata += \"O`082000Oh0827mo6>Hn?Wmo?6HnMb11MP08@C11H`08@FP0@@0004@000000000\";\r\n\t\tdata += \"00P00001Oab00003OcKP0006@6=PMgl<@440MglH@000000`@000001P00000000\";\r\n\t\tdata += \"Ob@8@@00Ob@8@Ga13R@8Mga172@8?PAo3R@827QoOb@820@0O`0007`0000007P0\";\r\n\t\tdata += \"O`000P08Od400g`<3V=P0G`673IP0`@3>1`00P@6O`P00g`<O`000GP800000000\";\r\n\t\tdata += \"?P9PL020O`<`N3R0@E4HC7b0@ET<ATB0@@l6C4B0O`H3N7b0?P01L3R000000020\";\r\n\r\n\t\tfontRenderable.Create(128, 48);\r\n\r\n\t\tint px = 0, py = 0;\r\n\t\tfor (size_t b = 0; b < 1024; b += 4)\r\n\t\t{\r\n\t\t\tuint32_t sym1 = (uint32_t)data[b + 0] - 48;\r\n\t\t\tuint32_t sym2 = (uint32_t)data[b + 1] - 48;\r\n\t\t\tuint32_t sym3 = (uint32_t)data[b + 2] - 48;\r\n\t\t\tuint32_t sym4 = (uint32_t)data[b + 3] - 48;\r\n\t\t\tuint32_t r = sym1 << 18 | sym2 << 12 | sym3 << 6 | sym4;\r\n\r\n\t\t\tfor (int i = 0; i < 24; i++)\r\n\t\t\t{\r\n\t\t\t\tint k = r & (1 << i) ? 255 : 0;\r\n\t\t\t\tfontRenderable.Sprite()->SetPixel(px, py, olc::Pixel(k, k, k, k));\r\n\t\t\t\tif (++py == 48) { px++; py = 0; }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfontRenderable.Decal()->Update();\r\n\r\n\t\tconstexpr std::array<uint8_t, 96> vSpacing = { {\r\n\t\t\t0x03,0x25,0x16,0x08,0x07,0x08,0x08,0x04,0x15,0x15,0x08,0x07,0x15,0x07,0x24,0x08,\r\n\t\t\t0x08,0x17,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x24,0x15,0x06,0x07,0x16,0x17,\r\n\t\t\t0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x17,0x08,0x08,0x17,0x08,0x08,0x08,\r\n\t\t\t0x08,0x08,0x08,0x08,0x17,0x08,0x08,0x08,0x08,0x17,0x08,0x15,0x08,0x15,0x08,0x08,\r\n\t\t\t0x24,0x18,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x33,0x17,0x17,0x33,0x18,0x17,0x17,\r\n\t\t\t0x17,0x17,0x17,0x17,0x07,0x17,0x17,0x18,0x18,0x17,0x17,0x07,0x33,0x07,0x08,0x00, } };\r\n\r\n\t\tfor (auto c : vSpacing) vFontSpacing.push_back({ c >> 4, c & 15 });\r\n\r\n\t\t// UK Standard Layout\r\n#ifdef OLC_KEYBOARD_UK\r\n\t\tvKeyboardMap =\r\n\t\t{\r\n\t\t\t{olc::Key::A, \"a\", \"A\"}, {olc::Key::B, \"b\", \"B\"}, {olc::Key::C, \"c\", \"C\"}, {olc::Key::D, \"d\", \"D\"}, {olc::Key::E, \"e\", \"E\"},\r\n\t\t\t{olc::Key::F, \"f\", \"F\"}, {olc::Key::G, \"g\", \"G\"}, {olc::Key::H, \"h\", \"H\"}, {olc::Key::I, \"i\", \"I\"}, {olc::Key::J, \"j\", \"J\"},\r\n\t\t\t{olc::Key::K, \"k\", \"K\"}, {olc::Key::L, \"l\", \"L\"}, {olc::Key::M, \"m\", \"M\"}, {olc::Key::N, \"n\", \"N\"}, {olc::Key::O, \"o\", \"O\"},\r\n\t\t\t{olc::Key::P, \"p\", \"P\"}, {olc::Key::Q, \"q\", \"Q\"}, {olc::Key::R, \"r\", \"R\"}, {olc::Key::S, \"s\", \"S\"}, {olc::Key::T, \"t\", \"T\"},\r\n\t\t\t{olc::Key::U, \"u\", \"U\"}, {olc::Key::V, \"v\", \"V\"}, {olc::Key::W, \"w\", \"W\"}, {olc::Key::X, \"x\", \"X\"}, {olc::Key::Y, \"y\", \"Y\"},\r\n\t\t\t{olc::Key::Z, \"z\", \"Z\"},\r\n\r\n\t\t\t{olc::Key::K0, \"0\", \")\"}, {olc::Key::K1, \"1\", \"!\"}, {olc::Key::K2, \"2\", \"\\\"\"}, {olc::Key::K3, \"3\", \"#\"},\t{olc::Key::K4, \"4\", \"$\"},\r\n\t\t\t{olc::Key::K5, \"5\", \"%\"}, {olc::Key::K6, \"6\", \"^\"}, {olc::Key::K7, \"7\", \"&\"}, {olc::Key::K8, \"8\", \"*\"},\t{olc::Key::K9, \"9\", \"(\"},\r\n\r\n\t\t\t{olc::Key::NP0, \"0\", \"0\"}, {olc::Key::NP1, \"1\", \"1\"}, {olc::Key::NP2, \"2\", \"2\"}, {olc::Key::NP3, \"3\", \"3\"},\t{olc::Key::NP4, \"4\", \"4\"},\r\n\t\t\t{olc::Key::NP5, \"5\", \"5\"}, {olc::Key::NP6, \"6\", \"6\"}, {olc::Key::NP7, \"7\", \"7\"}, {olc::Key::NP8, \"8\", \"8\"},\t{olc::Key::NP9, \"9\", \"9\"},\r\n\t\t\t{olc::Key::NP_MUL, \"*\", \"*\"}, {olc::Key::NP_DIV, \"/\", \"/\"}, {olc::Key::NP_ADD, \"+\", \"+\"}, {olc::Key::NP_SUB, \"-\", \"-\"},\t{olc::Key::NP_DECIMAL, \".\", \".\"},\r\n\r\n\t\t\t{olc::Key::PERIOD, \".\", \">\"}, {olc::Key::EQUALS, \"=\", \"+\"}, {olc::Key::COMMA, \",\", \"<\"}, {olc::Key::MINUS, \"-\", \"_\"}, {olc::Key::SPACE, \" \", \" \"},\r\n\r\n\t\t\t{olc::Key::OEM_1, \";\", \":\"}, {olc::Key::OEM_2, \"/\", \"?\"}, {olc::Key::OEM_3, \"\\'\", \"@\"}, {olc::Key::OEM_4, \"[\", \"{\"},\r\n\t\t\t{olc::Key::OEM_5, \"\\\\\", \"|\"}, {olc::Key::OEM_6, \"]\", \"}\"}, {olc::Key::OEM_7, \"#\", \"~\"}, \r\n\t\t\t\r\n\t\t\t// {olc::Key::TAB, \"\\t\", \"\\t\"}\r\n\t\t};\r\n#endif\r\n\t}\r\n\r\n\tvoid PixelGameEngine::pgex_Register(olc::PGEX* pgex)\r\n\t{\r\n\t\tif (std::find(vExtensions.begin(), vExtensions.end(), pgex) == vExtensions.end())\r\n\t\t\tvExtensions.push_back(pgex);\t\t\t\r\n\t}\r\n\r\n\r\n\tPGEX::PGEX(bool bHook) { if(bHook) pge->pgex_Register(this); }\r\n\tvoid PGEX::OnBeforeUserCreate() {}\r\n\tvoid PGEX::OnAfterUserCreate()\t{}\r\n\tbool PGEX::OnBeforeUserUpdate(float& fElapsedTime) { return false; }\r\n\tvoid PGEX::OnAfterUserUpdate(float fElapsedTime) {}\r\n\r\n\t// Need a couple of statics as these are singleton instances\r\n\t// read from multiple locations\r\n\tstd::atomic<bool> PixelGameEngine::bAtomActive{ false };\r\n\tolc::PixelGameEngine* olc::PGEX::pge = nullptr;\r\n\tolc::PixelGameEngine* olc::Platform::ptrPGE = nullptr;\r\n\tolc::PixelGameEngine* olc::Renderer::ptrPGE = nullptr;\r\n\tstd::unique_ptr<ImageLoader> olc::Sprite::loader = nullptr;\r\n};\r\n#pragma endregion \r\n\r\n\r\n#pragma region platform_headless\r\nnamespace olc\r\n{\r\n#if defined(OLC_GFX_HEADLESS)\r\n\tclass Renderer_Headless : public olc::Renderer\r\n\t{\r\n\tpublic:\r\n\t\tvirtual void       PrepareDevice() {};\r\n\t\tvirtual olc::rcode CreateDevice(std::vector<void*> params, bool bFullScreen, bool bVSYNC) { return olc::rcode::OK;\t\t}\r\n\t\tvirtual olc::rcode DestroyDevice() { return olc::rcode::OK; }\r\n\t\tvirtual void       DisplayFrame() {}\r\n\t\tvirtual void       PrepareDrawing() {}\r\n\t\tvirtual void\t   SetDecalMode(const olc::DecalMode& mode) {}\r\n\t\tvirtual void       DrawLayerQuad(const olc::vf2d& offset, const olc::vf2d& scale, const olc::Pixel tint) {}\r\n\t\tvirtual void       DrawDecal(const olc::DecalInstance& decal) {}\r\n\t\tvirtual uint32_t   CreateTexture(const uint32_t width, const uint32_t height, const bool filtered = false, const bool clamp = true) {return 1;};\r\n\t\tvirtual void       UpdateTexture(uint32_t id, olc::Sprite* spr) {}\r\n\t\tvirtual void       ReadTexture(uint32_t id, olc::Sprite* spr) {}\r\n\t\tvirtual uint32_t   DeleteTexture(const uint32_t id) {return 1;}\r\n\t\tvirtual void       ApplyTexture(uint32_t id) {}\r\n\t\tvirtual void       UpdateViewport(const olc::vi2d& pos, const olc::vi2d& size) {}\r\n\t\tvirtual void       ClearBuffer(olc::Pixel p, bool bDepth) {}\r\n\t};\r\n#endif\r\n#if defined(OLC_PLATFORM_HEADLESS)\r\n\tclass Platform_Headless : public olc::Platform\r\n\t{\r\n\tpublic:\r\n\t\tvirtual olc::rcode SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize) override\r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ShowWindowFrame(const bool bShowFrame = true) override\r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ApplicationStartUp() { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode ApplicationCleanUp() { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode ThreadStartUp() { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode ThreadCleanUp() { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode StartSystemEventLoop() { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode HandleSystemEvent() { return olc::rcode::OK; }\r\n\t};\r\n#endif\r\n}\r\n#pragma endregion\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine Renderers - the draw-y bits                               |\r\n// O------------------------------------------------------------------------------O\r\n\r\n#pragma region image_stb\r\n// O------------------------------------------------------------------------------O\r\n// | START IMAGE LOADER: stb_image.h, all systems, very fast                      |\r\n// O------------------------------------------------------------------------------O\r\n// Thanks to Sean Barrett - https://github.com/nothings/stb/blob/master/stb_image.h\r\n// MIT License - Copyright(c) 2017 Sean Barrett\r\n\r\n// Note you need to download the above file into your project folder, and\r\n// #define OLC_IMAGE_STB \r\n// #define OLC_PGE_APPLICATION\r\n// #include \"olcPixelGameEngine.h\"\r\n\r\n#if defined(OLC_IMAGE_STB)\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"stb_image.h\"\r\nnamespace olc\r\n{\r\n\tclass ImageLoader_STB : public olc::ImageLoader\r\n\t{\r\n\tpublic:\r\n\t\tImageLoader_STB() : ImageLoader()\r\n\t\t{}\r\n\r\n\t\tolc::rcode LoadImageResource(olc::Sprite* spr, const std::string& sImageFile, olc::ResourcePack* pack) override\r\n\t\t{\r\n\t\t\tUNUSED(pack);\r\n\t\t\t// clear out existing sprite\r\n\t\t\tspr->pColData.clear();\r\n\t\t\t// Open file\r\n\t\t\tstbi_uc* bytes = nullptr;\r\n\t\t\tint w = 0, h = 0, cmp = 0;\r\n\t\t\tif (pack != nullptr)\r\n\t\t\t{\r\n\t\t\t\tResourceBuffer rb = pack->GetFileBuffer(sImageFile);\r\n\t\t\t\tbytes = stbi_load_from_memory((unsigned char*)rb.vMemory.data(), rb.vMemory.size(), &w, &h, &cmp, 4);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Check file exists\r\n\t\t\t\tif (!_gfs::exists(sImageFile)) return olc::rcode::NO_FILE;\r\n\t\t\t\tbytes = stbi_load(sImageFile.c_str(), &w, &h, &cmp, 4);\r\n\t\t\t}\r\n\r\n\t\t\tif (!bytes) return olc::rcode::FAIL;\r\n\t\t\tspr->width = w; spr->height = h;\r\n\t\t\tspr->pColData.resize(spr->width * spr->height);\r\n\t\t\tstd::memcpy(spr->pColData.data(), bytes, spr->width * spr->height * 4);\r\n\t\t\tdelete[] bytes;\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode SaveImageResource(olc::Sprite* spr, const std::string& sImageFile) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | START IMAGE LOADER: stb_image.h                                              |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n\r\n\r\n#if !defined(OLC_PGE_HEADLESS)\r\n\r\n#pragma region renderer_ogl10\r\n// O------------------------------------------------------------------------------O\r\n// | START RENDERER: OpenGL 1.0 (the original, the best...)                       |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_GFX_OPENGL10)\r\n\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t#include <dwmapi.h>\r\n\t#include <GL/gl.h>\r\n\t#if !defined(__MINGW32__)\r\n\t\t#pragma comment(lib, \"Dwmapi.lib\")\r\n\t#endif\r\n\ttypedef BOOL(WINAPI wglSwapInterval_t) (int interval);\r\n\tstatic wglSwapInterval_t* wglSwapInterval = nullptr;\r\n\ttypedef HDC glDeviceContext_t;\r\n\ttypedef HGLRC glRenderContext_t;\r\n#endif\r\n\r\n#if defined(__linux__) || defined(__FreeBSD__)\r\n\t#include <GL/gl.h>\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\tnamespace X11\r\n\t{\r\n\t\t#include <GL/glx.h>\r\n\t}\r\n\ttypedef int(glSwapInterval_t)(X11::Display* dpy, X11::GLXDrawable drawable, int interval);\r\n\tstatic glSwapInterval_t* glSwapIntervalEXT;\r\n\ttypedef X11::GLXContext glDeviceContext_t;\r\n\ttypedef X11::GLXContext glRenderContext_t;\r\n#endif\r\n\r\n#if defined(__APPLE__)\r\n\t#define GL_SILENCE_DEPRECATION\r\n\t#include <OpenGL/OpenGL.h>\r\n\t#include <OpenGL/gl.h>\r\n\t#include <OpenGL/glu.h>\r\n#endif\r\n\r\nnamespace olc\r\n{\r\n\tclass Renderer_OGL10 : public olc::Renderer\r\n\t{\r\n\tprivate:\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\tbool mFullScreen = false;\r\n#else\r\n\t\tglDeviceContext_t glDeviceContext = 0;\r\n\t\tglRenderContext_t glRenderContext = 0;\r\n#endif\r\n\r\n\t\tbool bSync = false;\r\n\t\tolc::DecalMode nDecalMode = olc::DecalMode(-1); // Thanks Gusgo & Bispoo\r\n\t\tolc::DecalStructure nDecalStructure = olc::DecalStructure(-1);\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\tX11::Display* olc_Display = nullptr;\r\n\t\tX11::Window* olc_Window = nullptr;\r\n\t\tX11::XVisualInfo* olc_VisualInfo = nullptr;\r\n#endif\r\n\r\n\tpublic:\r\n\t\tvoid PrepareDevice() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\t//glutInit has to be called with main() arguments, make fake ones\r\n\t\t\tint argc = 0;\r\n\t\t\tchar* argv[1] = { (char*)\"\" };\r\n\t\t\tglutInit(&argc, argv);\r\n\t\t\tglutInitWindowPosition(0, 0);\r\n\t\t\tglutInitWindowSize(512, 512);\r\n\t\t\tglutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);\r\n\t\t\t// Creates the window and the OpenGL context for it\r\n\t\t\tglutCreateWindow(\"OneLoneCoder.com - Pixel Game Engine\");\r\n\t\t\tglEnable(GL_TEXTURE_2D); // Turn on texturing\r\n\t\t\tglHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\r\n#endif\r\n\t\t}\r\n\r\n\t\tolc::rcode CreateDevice(std::vector<void*> params, bool bFullScreen, bool bVSYNC) override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\t// Create Device Context\r\n\t\t\tglDeviceContext = GetDC((HWND)(params[0]));\r\n\t\t\tPIXELFORMATDESCRIPTOR pfd =\r\n\t\t\t{\r\n\t\t\t\tsizeof(PIXELFORMATDESCRIPTOR), 1,\r\n\t\t\t\tPFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,\r\n\t\t\t\tPFD_TYPE_RGBA, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n\t\t\t\tPFD_MAIN_PLANE, 0, 0, 0, 0\r\n\t\t\t};\r\n\r\n\t\t\tint pf = 0;\r\n\t\t\tif (!(pf = ChoosePixelFormat(glDeviceContext, &pfd))) return olc::FAIL;\r\n\t\t\tSetPixelFormat(glDeviceContext, pf, &pfd);\r\n\r\n\t\t\tif (!(glRenderContext = wglCreateContext(glDeviceContext))) return olc::FAIL;\r\n\t\t\twglMakeCurrent(glDeviceContext, glRenderContext);\r\n\r\n\t\t\t// Remove Frame cap\r\n\t\t\twglSwapInterval = (wglSwapInterval_t*)wglGetProcAddress(\"wglSwapIntervalEXT\");\r\n\t\t\tif (wglSwapInterval && !bVSYNC) wglSwapInterval(0);\r\n\t\t\tbSync = bVSYNC;\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tusing namespace X11;\r\n\t\t\t// Linux has tighter coupling between OpenGL and X11, so we store\r\n\t\t\t// various \"platform\" handles in the renderer\r\n\t\t\tolc_Display = (X11::Display*)(params[0]);\r\n\t\t\tolc_Window = (X11::Window*)(params[1]);\r\n\t\t\tolc_VisualInfo = (X11::XVisualInfo*)(params[2]);\r\n\r\n\t\t\tglDeviceContext = glXCreateContext(olc_Display, olc_VisualInfo, nullptr, GL_TRUE);\r\n\t\t\tglXMakeCurrent(olc_Display, *olc_Window, glDeviceContext);\r\n\r\n\t\t\tXWindowAttributes gwa;\r\n\t\t\tXGetWindowAttributes(olc_Display, *olc_Window, &gwa);\r\n\t\t\tglViewport(0, 0, gwa.width, gwa.height);\r\n\r\n\t\t\tglSwapIntervalEXT = nullptr;\r\n\t\t\tglSwapIntervalEXT = (glSwapInterval_t*)glXGetProcAddress((unsigned char*)\"glXSwapIntervalEXT\");\r\n\r\n\t\t\tif (glSwapIntervalEXT == nullptr && !bVSYNC)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"NOTE: Could not disable VSYNC, glXSwapIntervalEXT() was not found!\\n\");\r\n\t\t\t\tprintf(\"      Don't worry though, things will still work, it's just the\\n\");\r\n\t\t\t\tprintf(\"      frame rate will be capped to your monitors refresh rate - javidx9\\n\");\r\n\t\t\t}\r\n\r\n\t\t\tif (glSwapIntervalEXT != nullptr && !bVSYNC)\r\n\t\t\t\tglSwapIntervalEXT(olc_Display, *olc_Window, 0);\r\n#endif\t\t\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tmFullScreen = bFullScreen;\r\n\t\t\tif (!bVSYNC)\r\n\t\t\t{\r\n#if defined(__APPLE__)\r\n\t\t\t\tGLint sync = 0;\r\n\t\t\t\tCGLContextObj ctx = CGLGetCurrentContext();\r\n\t\t\t\tif (ctx) CGLSetParameter(ctx, kCGLCPSwapInterval, &sync);\r\n#endif\r\n\t\t\t}\r\n#else\r\n\t\t\tglEnable(GL_TEXTURE_2D); // Turn on texturing\r\n\t\t\tglHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\r\n#endif\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode DestroyDevice() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\twglDeleteContext(glRenderContext);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tglXMakeCurrent(olc_Display, None, NULL);\r\n\t\t\tglXDestroyContext(olc_Display, glDeviceContext);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tglutDestroyWindow(glutGetWindow());\r\n#endif\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvoid DisplayFrame() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\tSwapBuffers(glDeviceContext);\r\n\t\t\tif (bSync) DwmFlush(); // Woooohooooooo!!!! SMOOOOOOOTH!\r\n#endif\t\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tX11::glXSwapBuffers(olc_Display, *olc_Window);\r\n#endif\t\t\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tglutSwapBuffers();\r\n#endif\r\n\t\t}\r\n\r\n\t\tvoid PrepareDrawing() override\r\n\t\t{\r\n\t\t\t\r\n\t\t\t//ClearBuffer(olc::GREEN, true);\r\n\t\t\tglEnable(GL_BLEND);\r\n\t\t\tnDecalMode = DecalMode::NORMAL;\r\n\t\t\tnDecalStructure = DecalStructure::FAN;\r\n\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t}\r\n\r\n\t\tvoid SetDecalMode(const olc::DecalMode& mode)\r\n\t\t{\r\n\t\t\tif (mode != nDecalMode)\r\n\t\t\t{\r\n\t\t\t\tswitch (mode)\r\n\t\t\t\t{\r\n\t\t\t\tcase olc::DecalMode::NORMAL:\r\n\t\t\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase olc::DecalMode::ADDITIVE:\r\n\t\t\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase olc::DecalMode::MULTIPLICATIVE:\r\n\t\t\t\t\tglBlendFunc(GL_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase olc::DecalMode::STENCIL:\r\n\t\t\t\t\tglBlendFunc(GL_ZERO, GL_SRC_ALPHA);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase olc::DecalMode::ILLUMINATE:\r\n\t\t\t\t\tglBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase olc::DecalMode::WIREFRAME:\r\n\t\t\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnDecalMode = mode;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid DrawLayerQuad(const olc::vf2d& offset, const olc::vf2d& scale, const olc::Pixel tint) override\r\n\t\t{\r\n\t\t\tglBegin(GL_QUADS);\r\n\t\t\tglColor4ub(tint.r, tint.g, tint.b, tint.a);\r\n\t\t\tglTexCoord2f(0.0f * scale.x + offset.x, 1.0f * scale.y + offset.y);\r\n\t\t\tglVertex3f(-1.0f /*+ vSubPixelOffset.x*/, -1.0f /*+ vSubPixelOffset.y*/, 0.0f);\r\n\t\t\tglTexCoord2f(0.0f * scale.x + offset.x, 0.0f * scale.y + offset.y);\r\n\t\t\tglVertex3f(-1.0f /*+ vSubPixelOffset.x*/, 1.0f /*+ vSubPixelOffset.y*/, 0.0f);\r\n\t\t\tglTexCoord2f(1.0f * scale.x + offset.x, 0.0f * scale.y + offset.y);\r\n\t\t\tglVertex3f(1.0f /*+ vSubPixelOffset.x*/, 1.0f /*+ vSubPixelOffset.y*/, 0.0f);\r\n\t\t\tglTexCoord2f(1.0f * scale.x + offset.x, 1.0f * scale.y + offset.y);\r\n\t\t\tglVertex3f(1.0f /*+ vSubPixelOffset.x*/, -1.0f /*+ vSubPixelOffset.y*/, 0.0f);\r\n\t\t\tglEnd();\r\n\t\t}\r\n\r\n\t\tvoid DrawDecal(const olc::DecalInstance& decal) override\r\n\t\t{\r\n\t\t\tSetDecalMode(decal.mode);\r\n\r\n\t\t\tif (decal.decal == nullptr)\r\n\t\t\t\tglBindTexture(GL_TEXTURE_2D, 0);\r\n\t\t\telse\r\n\t\t\t\tglBindTexture(GL_TEXTURE_2D, decal.decal->id);\r\n\t\t\t\r\n\t\t\tif (decal.depth)\r\n\t\t\t{\r\n\t\t\t\tglEnable(GL_DEPTH_TEST);\r\n\t\t\t}\r\n\r\n\t\t\tif (nDecalMode == DecalMode::WIREFRAME)\r\n\t\t\t\tglBegin(GL_LINE_LOOP);\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif(decal.structure == olc::DecalStructure::FAN)\r\n\t\t\t\t\tglBegin(GL_TRIANGLE_FAN);\r\n\t\t\t\telse if(decal.structure == olc::DecalStructure::STRIP)\r\n\t\t\t\t\tglBegin(GL_TRIANGLE_STRIP);\r\n\t\t\t\telse if(decal.structure == olc::DecalStructure::LIST)\r\n\t\t\t\t\tglBegin(GL_TRIANGLES);\r\n\t\t\t}\r\n\r\n\t\t\tif (decal.depth)\r\n\t\t\t{\r\n\r\n\t\t\t\t// Render as 3D Spatial Entity\r\n\t\t\t\tfor (uint32_t n = 0; n < decal.points; n++)\r\n\t\t\t\t{\r\n\t\t\t\t\tglColor4ub(decal.tint[n].r, decal.tint[n].g, decal.tint[n].b, decal.tint[n].a);\r\n\t\t\t\t\tglTexCoord4f(decal.uv[n].x, decal.uv[n].y, 0.0f, decal.w[n]);\r\n\t\t\t\t\tglVertex3f(decal.pos[n].x, decal.pos[n].y, decal.z[n]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Render as 2D Spatial entity\r\n\t\t\t\tfor (uint32_t n = 0; n < decal.points; n++)\r\n\t\t\t\t{\r\n\t\t\t\t\tglColor4ub(decal.tint[n].r, decal.tint[n].g, decal.tint[n].b, decal.tint[n].a);\r\n\t\t\t\t\tglTexCoord4f(decal.uv[n].x, decal.uv[n].y, 0.0f, decal.w[n]);\r\n\t\t\t\t\tglVertex2f(decal.pos[n].x, decal.pos[n].y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tglEnd();\r\n\r\n\t\t\tif (decal.depth)\r\n\t\t\t{\r\n\t\t\t\tglDisable(GL_DEPTH_TEST);\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\r\n\t\tuint32_t CreateTexture(const uint32_t width, const uint32_t height, const bool filtered, const bool clamp) override\r\n\t\t{\r\n\t\t\tUNUSED(width);\r\n\t\t\tUNUSED(height);\r\n\t\t\tuint32_t id = 0;\r\n\t\t\tglGenTextures(1, &id);\r\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\r\n\t\t\tif (filtered)\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\r\n\t\t\t}\r\n\r\n\t\t\tif (clamp)\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n\t\t\t}\r\n\r\n\t\t\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\tuint32_t DeleteTexture(const uint32_t id) override\r\n\t\t{\r\n\t\t\tglDeleteTextures(1, &id);\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\tvoid UpdateTexture(uint32_t id, olc::Sprite* spr) override\r\n\t\t{\r\n\t\t\tUNUSED(id);\r\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, spr->width, spr->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, spr->GetData());\r\n\t\t}\r\n\r\n\t\tvoid ReadTexture(uint32_t id, olc::Sprite* spr) override\r\n\t\t{\r\n\t\t\tglReadPixels(0, 0, spr->width, spr->height, GL_RGBA, GL_UNSIGNED_BYTE, spr->GetData());\r\n\t\t}\r\n\r\n\t\tvoid ApplyTexture(uint32_t id) override\r\n\t\t{\r\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\r\n\t\t}\r\n\r\n\t\tvoid ClearBuffer(olc::Pixel p, bool bDepth) override\r\n\t\t{\r\n\t\t\tglClearColor(float(p.r) / 255.0f, float(p.g) / 255.0f, float(p.b) / 255.0f, float(p.a) / 255.0f);\r\n\t\t\tglClear(GL_COLOR_BUFFER_BIT);\r\n\t\t\tif (bDepth) glClear(GL_DEPTH_BUFFER_BIT);\r\n\t\t}\r\n\r\n\t\tvoid UpdateViewport(const olc::vi2d& pos, const olc::vi2d& size) override\r\n\t\t{\r\n\t\t\tglViewport(pos.x, pos.y, size.x, size.y);\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END RENDERER: OpenGL 1.0 (the original, the best...)                         |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n#pragma region renderer_ogl33\r\n// O------------------------------------------------------------------------------O\r\n// | START RENDERER: OpenGL 3.3 (3.0 es) (sh-sh-sh-shaders....)                   |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_GFX_OPENGL33)\r\n\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t#include <dwmapi.h>\r\n\t//#include <gl/GL.h>\r\n\t#if !defined(__MINGW32__)\r\n\t\t#pragma comment(lib, \"Dwmapi.lib\")\r\n\t#endif\t\t\r\n\t//typedef void __stdcall locSwapInterval_t(GLsizei n);\r\n\ttypedef HDC glDeviceContext_t;\r\n\ttypedef HGLRC glRenderContext_t;\r\n\t//#define CALLSTYLE __stdcall\r\n\t#define OGL_LOAD(t, n) (t*)wglGetProcAddress(#n)\r\n#endif\r\n//\r\n//#if defined(__linux__) || defined(__FreeBSD__)\r\n//\t#include <GL/gl.h>\r\n//#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t/*namespace X11\r\n\t{\r\n\t\t#include <GL/glx.h>\r\n\t}\r\n\ttypedef int(locSwapInterval_t)(X11::Display* dpy, X11::GLXDrawable drawable, int interval);*/\r\n\ttypedef X11::GLXContext glDeviceContext_t;\r\n\ttypedef X11::GLXContext glRenderContext_t;\r\n\t//#define CALLSTYLE \r\n\t#define OGL_LOAD(t, n) (t*)glXGetProcAddress((unsigned char*)#n);\r\n#endif\r\n\r\n//#if defined(__APPLE__)\r\n//\t#define GL_SILENCE_DEPRECATION\r\n//\t#include <OpenGL/OpenGL.h>\r\n//\t#include <OpenGL/gl.h>\r\n//\t#include <OpenGL/glu.h>\r\n//#endif\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t#include <EGL/egl.h>\r\n\t#include <GLES2/gl2.h>\r\n\t#define GL_GLEXT_PROTOTYPES\r\n\t#include <GLES2/gl2ext.h>\r\n\t#include <emscripten/emscripten.h>\r\n\t#define CALLSTYLE\r\n\ttypedef EGLBoolean(locSwapInterval_t)(EGLDisplay display, EGLint interval);\r\n\t#define GL_CLAMP GL_CLAMP_TO_EDGE\r\n\t#define OGL_LOAD(t, n) n;\r\n#endif\r\n\r\nnamespace olc\r\n{\r\n//\ttypedef char GLchar;\r\n//\ttypedef ptrdiff_t GLsizeiptr;\r\n//\ttypedef GLuint CALLSTYLE locCreateShader_t(GLenum type);\r\n//\ttypedef GLuint CALLSTYLE locCreateProgram_t(void);\r\n//\ttypedef void CALLSTYLE locDeleteShader_t(GLuint shader);\r\n//#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n//\ttypedef void CALLSTYLE locShaderSource_t(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);\r\n//#else\r\n//\ttypedef void CALLSTYLE locShaderSource_t(GLuint shader, GLsizei count, const GLchar** string, const GLint* length);\r\n//#endif\r\n//\ttypedef void CALLSTYLE locCompileShader_t(GLuint shader);\r\n//\ttypedef void CALLSTYLE locLinkProgram_t(GLuint program);\r\n//\ttypedef void CALLSTYLE locDeleteProgram_t(GLuint program);\r\n//\ttypedef void CALLSTYLE locAttachShader_t(GLuint program, GLuint shader);\r\n//\ttypedef void CALLSTYLE locBindBuffer_t(GLenum target, GLuint buffer);\r\n//\ttypedef void CALLSTYLE locBufferData_t(GLenum target, GLsizeiptr size, const void* data, GLenum usage);\r\n//\ttypedef void CALLSTYLE locGenBuffers_t(GLsizei n, GLuint* buffers);\r\n//\ttypedef void CALLSTYLE locVertexAttribPointer_t(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);\r\n//\ttypedef void CALLSTYLE locEnableVertexAttribArray_t(GLuint index);\r\n//\ttypedef void CALLSTYLE locUseProgram_t(GLuint program);\r\n//\ttypedef void CALLSTYLE locBindVertexArray_t(GLuint array);\r\n//\ttypedef void CALLSTYLE locGenVertexArrays_t(GLsizei n, GLuint* arrays);\r\n//\ttypedef void CALLSTYLE locGetShaderInfoLog_t(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);\r\n//\ttypedef GLint CALLSTYLE locGetUniformLocation_t(GLuint program, const GLchar* name);\r\n//\ttypedef void CALLSTYLE locUniform1f_t(GLint location, GLfloat v0);\r\n//\ttypedef void CALLSTYLE locUniform1i_t(GLint location, GLint v0);\r\n//\ttypedef void CALLSTYLE locUniform2fv_t(GLint location, GLsizei count, const GLfloat* value);\r\n//\ttypedef void CALLSTYLE locActiveTexture_t(GLenum texture);\r\n//\ttypedef void CALLSTYLE locGenFrameBuffers_t(GLsizei n, GLuint* ids);\r\n//\ttypedef void CALLSTYLE locBindFrameBuffer_t(GLenum target, GLuint fb);\r\n//\ttypedef GLenum CALLSTYLE locCheckFrameBufferStatus_t(GLenum target);\r\n//\ttypedef void CALLSTYLE locDeleteFrameBuffers_t(GLsizei n, const GLuint* fbs);\r\n//\ttypedef void CALLSTYLE locFrameBufferTexture2D_t(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);\r\n//\ttypedef void CALLSTYLE locDrawBuffers_t(GLsizei n, const GLenum* bufs);\r\n//\ttypedef void CALLSTYLE locBlendFuncSeparate_t(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);\r\n\r\n\t\r\n\r\n\tclass Renderer_OGL33 : public olc::Renderer\r\n\t{\r\n\tprivate:\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\tEGLDisplay olc_Display;\r\n\t\tEGLConfig olc_Config;\r\n\t\tEGLContext olc_Context;\r\n\t\tEGLSurface olc_Surface;\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\tbool mFullScreen = false;\r\n#else\r\n\t#if !defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\tglDeviceContext_t glDeviceContext = 0;\r\n\t\tglRenderContext_t glRenderContext = 0;\r\n\t#endif\r\n#endif\r\n\t\tbool bSync = false;\r\n\t\tolc::DecalMode nDecalMode = olc::DecalMode(-1); // Thanks Gusgo & Bispoo\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\tX11::Display* olc_Display = nullptr;\r\n\t\tX11::Window* olc_Window = nullptr;\r\n\t\tX11::XVisualInfo* olc_VisualInfo = nullptr;\r\n#endif\r\n\r\n\tprivate:\r\n\t\tlocCreateShader_t* locCreateShader = nullptr;\r\n\t\tlocShaderSource_t* locShaderSource = nullptr;\r\n\t\tlocCompileShader_t* locCompileShader = nullptr;\r\n\t\tlocDeleteShader_t* locDeleteShader = nullptr;\r\n\t\tlocCreateProgram_t* locCreateProgram = nullptr;\r\n\t\tlocDeleteProgram_t* locDeleteProgram = nullptr;\r\n\t\tlocLinkProgram_t* locLinkProgram = nullptr;\r\n\t\tlocAttachShader_t* locAttachShader = nullptr;\r\n\t\tlocBindBuffer_t* locBindBuffer = nullptr;\r\n\t\tlocBufferData_t* locBufferData = nullptr;\r\n\t\tlocGenBuffers_t* locGenBuffers = nullptr;\r\n\t\tlocVertexAttribPointer_t* locVertexAttribPointer = nullptr;\r\n\t\tlocEnableVertexAttribArray_t* locEnableVertexAttribArray = nullptr;\r\n\t\tlocUseProgram_t* locUseProgram = nullptr;\r\n\t\tlocBindVertexArray_t* locBindVertexArray = nullptr;\r\n\t\tlocGenVertexArrays_t* locGenVertexArrays = nullptr;\r\n\t\tlocSwapInterval_t* locSwapInterval = nullptr;\r\n\t\tlocGetShaderInfoLog_t* locGetShaderInfoLog = nullptr;\r\n\r\n\t\tuint32_t m_nFS = 0;\r\n\t\tuint32_t m_nVS = 0;\r\n\t\tuint32_t m_nQuadShader = 0;\r\n\t\tuint32_t m_vbQuad = 0;\r\n\t\tuint32_t m_vaQuad = 0;\r\n\r\n\t\tstruct locVertex\r\n\t\t{\r\n\t\t\tfloat pos[3];\r\n\t\t\tolc::vf2d tex;\r\n\t\t\tolc::Pixel col;\r\n\t\t};\r\n\r\n\t\tlocVertex pVertexMem[OLC_MAX_VERTS];\r\n\r\n\t\tolc::Renderable rendBlankQuad;\r\n\r\n\tpublic:\r\n\t\tvoid PrepareDevice() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\t//glutInit has to be called with main() arguments, make fake ones\r\n\t\t\tint argc = 0;\r\n\t\t\tchar* argv[1] = { (char*)\"\" };\r\n\t\t\tglutInit(&argc, argv);\r\n\t\t\tglutInitWindowPosition(0, 0);\r\n\t\t\tglutInitWindowSize(512, 512);\r\n\t\t\tglutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);\r\n\t\t\t// Creates the window and the OpenGL context for it\r\n\t\t\tglutCreateWindow(\"OneLoneCoder.com - Pixel Game Engine\");\r\n\t\t\tglEnable(GL_TEXTURE_2D); // Turn on texturing\r\n\t\t\tglHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\r\n#endif\r\n\t\t}\r\n\r\n\t\tolc::rcode CreateDevice(std::vector<void*> params, bool bFullScreen, bool bVSYNC) override\r\n\t\t{\r\n\t\t\t// Create OpenGL Context\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\t// Create Device Context\r\n\t\t\tglDeviceContext = GetDC((HWND)(params[0]));\r\n\t\t\tPIXELFORMATDESCRIPTOR pfd =\r\n\t\t\t{\r\n\t\t\t\tsizeof(PIXELFORMATDESCRIPTOR), 1,\r\n\t\t\t\tPFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,\r\n\t\t\t\tPFD_TYPE_RGBA, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n\t\t\t\tPFD_MAIN_PLANE, 0, 0, 0, 0\r\n\t\t\t};\r\n\r\n\t\t\tint pf = 0;\r\n\t\t\tif (!(pf = ChoosePixelFormat(glDeviceContext, &pfd))) return olc::FAIL;\r\n\t\t\tSetPixelFormat(glDeviceContext, pf, &pfd);\r\n\r\n\t\t\tif (!(glRenderContext = wglCreateContext(glDeviceContext))) return olc::FAIL;\r\n\t\t\twglMakeCurrent(glDeviceContext, glRenderContext);\r\n\r\n\t\t\t// Set Vertical Sync\r\n\t\t\tlocSwapInterval = OGL_LOAD(locSwapInterval_t, wglSwapIntervalEXT);\r\n\t\t\tif (locSwapInterval && !bVSYNC) locSwapInterval(0);\r\n\t\t\tbSync = bVSYNC;\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tusing namespace X11;\r\n\t\t\t// Linux has tighter coupling between OpenGL and X11, so we store\r\n\t\t\t// various \"platform\" handles in the renderer\r\n\t\t\tolc_Display = (X11::Display*)(params[0]);\r\n\t\t\tolc_Window = (X11::Window*)(params[1]);\r\n\t\t\tolc_VisualInfo = (X11::XVisualInfo*)(params[2]);\r\n\r\n\t\t\tglDeviceContext = glXCreateContext(olc_Display, olc_VisualInfo, nullptr, GL_TRUE);\r\n\t\t\tglXMakeCurrent(olc_Display, *olc_Window, glDeviceContext);\r\n\r\n\t\t\tXWindowAttributes gwa;\r\n\t\t\tXGetWindowAttributes(olc_Display, *olc_Window, &gwa);\r\n\t\t\tglViewport(0, 0, gwa.width, gwa.height);\r\n\r\n\t\t\tlocSwapInterval = OGL_LOAD(locSwapInterval_t, glXSwapIntervalEXT);\r\n\r\n\t\t\tif (locSwapInterval == nullptr && !bVSYNC)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"NOTE: Could not disable VSYNC, glXSwapIntervalEXT() was not found!\\n\");\r\n\t\t\t\tprintf(\"      Don't worry though, things will still work, it's just the\\n\");\r\n\t\t\t\tprintf(\"      frame rate will be capped to your monitors refresh rate - javidx9\\n\");\r\n\t\t\t}\r\n\r\n\t\t\tif (locSwapInterval != nullptr && !bVSYNC)\r\n\t\t\t\tlocSwapInterval(olc_Display, *olc_Window, 0);\r\n#endif\t\t\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\tEGLint const attribute_list[] = { EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_NONE };\r\n\t\t\tEGLint const context_config[] = { EGL_CONTEXT_CLIENT_VERSION , 2, EGL_NONE };\r\n\t\t\tEGLint num_config;\r\n\r\n\t\t\tolc_Display = eglGetDisplay(EGL_DEFAULT_DISPLAY);\r\n\t\t\teglInitialize(olc_Display, nullptr, nullptr);\r\n\t\t\teglChooseConfig(olc_Display, attribute_list, &olc_Config, 1, &num_config);\r\n\r\n\t\t\t/* create an EGL rendering context */\r\n\t\t\tolc_Context = eglCreateContext(olc_Display, olc_Config, EGL_NO_CONTEXT, context_config);\r\n\t\t\tolc_Surface = eglCreateWindowSurface(olc_Display, olc_Config, NULL, nullptr);\r\n\t\t\teglMakeCurrent(olc_Display, olc_Surface, olc_Surface, olc_Context);\r\n\t\t\t//eglSwapInterval is currently a NOP, plement anyways in case it becomes supported\r\n\t\t\tlocSwapInterval = &eglSwapInterval;\r\n\t\t\tlocSwapInterval(olc_Display, bVSYNC ? 1 : 0);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tmFullScreen = bFullScreen;\r\n\t\t\tif (!bVSYNC)\r\n\t\t\t{\r\n#if defined(__APPLE__)\r\n\t\t\t\tGLint sync = 0;\r\n\t\t\t\tCGLContextObj ctx = CGLGetCurrentContext();\r\n\t\t\t\tif (ctx) CGLSetParameter(ctx, kCGLCPSwapInterval, &sync);\r\n#endif\r\n\t\t\t}\r\n#else\r\n\t#if !defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\tglEnable(GL_TEXTURE_2D); // Turn on texturing\r\n\t\t\tglHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\r\n\t#endif\r\n#endif\r\n\t\t\t// Load External OpenGL Functions\r\n\t\t\tlocCreateShader = OGL_LOAD(locCreateShader_t, glCreateShader);\r\n\t\t\tlocCompileShader = OGL_LOAD(locCompileShader_t, glCompileShader);\r\n\t\t\tlocShaderSource = OGL_LOAD(locShaderSource_t, glShaderSource);\r\n\t\t\tlocDeleteShader = OGL_LOAD(locDeleteShader_t, glDeleteShader);\r\n\t\t\tlocCreateProgram = OGL_LOAD(locCreateProgram_t, glCreateProgram);\r\n\t\t\tlocDeleteProgram = OGL_LOAD(locDeleteProgram_t, glDeleteProgram);\r\n\t\t\tlocLinkProgram = OGL_LOAD(locLinkProgram_t, glLinkProgram);\r\n\t\t\tlocAttachShader = OGL_LOAD(locAttachShader_t, glAttachShader);\r\n\t\t\tlocBindBuffer = OGL_LOAD(locBindBuffer_t, glBindBuffer);\r\n\t\t\tlocBufferData = OGL_LOAD(locBufferData_t, glBufferData);\r\n\t\t\tlocGenBuffers = OGL_LOAD(locGenBuffers_t, glGenBuffers);\r\n\t\t\tlocVertexAttribPointer = OGL_LOAD(locVertexAttribPointer_t, glVertexAttribPointer);\r\n\t\t\tlocEnableVertexAttribArray = OGL_LOAD(locEnableVertexAttribArray_t, glEnableVertexAttribArray);\r\n\t\t\tlocUseProgram = OGL_LOAD(locUseProgram_t, glUseProgram);\r\n\t\t\tlocGetShaderInfoLog = OGL_LOAD(locGetShaderInfoLog_t, glGetShaderInfoLog);\r\n#if !defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\tlocBindVertexArray = OGL_LOAD(locBindVertexArray_t, glBindVertexArray);\r\n\t\t\tlocGenVertexArrays = OGL_LOAD(locGenVertexArrays_t, glGenVertexArrays);\r\n#else\r\n\t\t\tlocBindVertexArray = glBindVertexArrayOES;\r\n\t\t\tlocGenVertexArrays = glGenVertexArraysOES;\r\n#endif\r\n\r\n\t\t\t// Load & Compile Quad Shader - assumes no errors\r\n\t\t\tm_nFS = locCreateShader(0x8B30);\r\n\t\t\tconst GLchar* strFS =\r\n#if defined(__arm__) || defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\t\t\"#version 300 es\\n\"\r\n\t\t\t\t\"precision mediump float;\"\r\n#else\r\n\t\t\t\t\"#version 330 core\\n\"\r\n#endif\r\n\t\t\t\t\"out vec4 pixel;\\n\"\"in vec2 oTex;\\n\"\r\n\t\t\t\t\"in vec4 oCol;\\n\"\"uniform sampler2D sprTex;\\n\"\"void main(){pixel = texture(sprTex, oTex) * oCol;}\";\r\n\t\t\tlocShaderSource(m_nFS, 1, &strFS, NULL);\r\n\t\t\tlocCompileShader(m_nFS);\r\n\r\n\t\t\tm_nVS = locCreateShader(0x8B31);\r\n\t\t\tconst GLchar* strVS =\r\n#if defined(__arm__) || defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\t\t\"#version 300 es\\n\"\r\n\t\t\t\t\"precision mediump float;\"\r\n#else\r\n\t\t\t\t\"#version 330 core\\n\"\r\n#endif\r\n\t\t\t\t\"layout(location = 0) in vec3 aPos;\\n\"\"layout(location = 1) in vec2 aTex;\\n\"\r\n\t\t\t\t\"layout(location = 2) in vec4 aCol;\\n\"\"out vec2 oTex;\\n\"\"out vec4 oCol;\\n\"\r\n\t\t\t\t\"void main(){ float p = 1.0 / aPos.z; gl_Position = p * vec4(aPos.x, aPos.y, 0.0, 1.0); oTex = p * aTex; oCol = aCol;}\";\r\n\t\t\tlocShaderSource(m_nVS, 1, &strVS, NULL);\r\n\t\t\tlocCompileShader(m_nVS);\r\n\r\n\t\t\tm_nQuadShader = locCreateProgram();\r\n\t\t\tlocAttachShader(m_nQuadShader, m_nFS);\r\n\t\t\tlocAttachShader(m_nQuadShader, m_nVS);\r\n\t\t\tlocLinkProgram(m_nQuadShader);\r\n\r\n\t\t\t// Create Quad\r\n\t\t\tlocGenBuffers(1, &m_vbQuad);\r\n\t\t\tlocGenVertexArrays(1, &m_vaQuad);\r\n\t\t\tlocBindVertexArray(m_vaQuad);\r\n\t\t\tlocBindBuffer(0x8892, m_vbQuad);\r\n\r\n\t\t\tlocVertex verts[OLC_MAX_VERTS];\r\n\t\t\tlocBufferData(0x8892, sizeof(locVertex) * OLC_MAX_VERTS, verts, 0x88E0);\r\n\t\t\tlocVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(locVertex), 0); locEnableVertexAttribArray(0);\r\n\t\t\tlocVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(locVertex), (void*)(3 * sizeof(float))); locEnableVertexAttribArray(1);\r\n\t\t\tlocVertexAttribPointer(2, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(locVertex), (void*)(5 * sizeof(float)));\tlocEnableVertexAttribArray(2);\r\n\t\t\tlocBindBuffer(0x8892, 0);\r\n\t\t\tlocBindVertexArray(0);\r\n\r\n\t\t\t// Create blank texture for spriteless decals\r\n\t\t\trendBlankQuad.Create(1, 1);\r\n\t\t\trendBlankQuad.Sprite()->GetData()[0] = olc::WHITE;\r\n\t\t\trendBlankQuad.Decal()->Update();\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode DestroyDevice() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\twglDeleteContext(glRenderContext);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tglXMakeCurrent(olc_Display, None, NULL);\r\n\t\t\tglXDestroyContext(olc_Display, glDeviceContext);\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tglutDestroyWindow(glutGetWindow());\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\teglMakeCurrent(olc_Display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\r\n\t\t\teglDestroyContext(olc_Display, olc_Context);\r\n\t\t\teglDestroySurface(olc_Display, olc_Surface);\r\n\t\t\teglTerminate(olc_Display);\r\n\t\t\tolc_Display = EGL_NO_DISPLAY;\r\n\t\t\tolc_Surface = EGL_NO_SURFACE;\r\n\t\t\tolc_Context = EGL_NO_CONTEXT;\r\n#endif\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvoid DisplayFrame() override\r\n\t\t{\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\t\tSwapBuffers(glDeviceContext);\r\n\t\t\tif (bSync) DwmFlush(); // Woooohooooooo!!!! SMOOOOOOOTH!\r\n#endif\t\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\t\tX11::glXSwapBuffers(olc_Display, *olc_Window);\r\n#endif\t\t\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\t\tglutSwapBuffers();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\teglSwapBuffers(olc_Display, olc_Surface);\r\n#endif\r\n\t\t}\r\n\r\n\t\tvoid PrepareDrawing() override\r\n\t\t{\r\n\t\t\tglEnable(GL_BLEND);\r\n\t\t\tnDecalMode = DecalMode::NORMAL;\r\n\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\t\tlocUseProgram(m_nQuadShader);\r\n\t\t\tlocBindVertexArray(m_vaQuad);\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\tlocVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(locVertex), 0); locEnableVertexAttribArray(0);\r\n\t\t\tlocVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(locVertex), (void*)(3 * sizeof(float))); locEnableVertexAttribArray(1);\r\n\t\t\tlocVertexAttribPointer(2, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(locVertex), (void*)(5 * sizeof(float)));\tlocEnableVertexAttribArray(2);\r\n#endif\r\n\t\t}\r\n\r\n\t\tvoid SetDecalMode(const olc::DecalMode& mode) override\r\n\t\t{\r\n\t\t\tif (mode != nDecalMode)\r\n\t\t\t{\r\n\t\t\t\tswitch (mode)\r\n\t\t\t\t{\r\n\t\t\t\tcase olc::DecalMode::NORMAL: glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\tbreak;\r\n\t\t\t\tcase olc::DecalMode::ADDITIVE: glBlendFunc(GL_SRC_ALPHA, GL_ONE); break;\r\n\t\t\t\tcase olc::DecalMode::MULTIPLICATIVE: glBlendFunc(GL_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA);\tbreak;\r\n\t\t\t\tcase olc::DecalMode::STENCIL: glBlendFunc(GL_ZERO, GL_SRC_ALPHA); break;\r\n\t\t\t\tcase olc::DecalMode::ILLUMINATE: glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);\tbreak;\r\n\t\t\t\tcase olc::DecalMode::WIREFRAME: glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnDecalMode = mode;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid DrawLayerQuad(const olc::vf2d& offset, const olc::vf2d& scale, const olc::Pixel tint) override\r\n\t\t{\r\n\t\t\tlocBindBuffer(0x8892, m_vbQuad);\r\n\t\t\tlocVertex verts[4] = {\r\n\t\t\t\t{{-1.0f, -1.0f, 1.0}, {0.0f * scale.x + offset.x, 1.0f * scale.y + offset.y}, tint},\r\n\t\t\t\t{{+1.0f, -1.0f, 1.0}, {1.0f * scale.x + offset.x, 1.0f * scale.y + offset.y}, tint},\r\n\t\t\t\t{{-1.0f, +1.0f, 1.0}, {0.0f * scale.x + offset.x, 0.0f * scale.y + offset.y}, tint},\r\n\t\t\t\t{{+1.0f, +1.0f, 1.0}, {1.0f * scale.x + offset.x, 0.0f * scale.y + offset.y}, tint},\r\n\t\t\t};\r\n\r\n\t\t\tlocBufferData(0x8892, sizeof(locVertex) * 4, verts, 0x88E0);\r\n\t\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\r\n\t\t}\r\n\r\n\t\tvoid DrawDecal(const olc::DecalInstance& decal) override\r\n\t\t{\r\n\t\t\tSetDecalMode(decal.mode);\r\n\t\t\tif (decal.decal == nullptr)\r\n\t\t\t\tglBindTexture(GL_TEXTURE_2D, rendBlankQuad.Decal()->id);\r\n\t\t\telse\r\n\t\t\t\tglBindTexture(GL_TEXTURE_2D, decal.decal->id);\r\n\r\n\t\t\tlocBindBuffer(0x8892, m_vbQuad);\r\n\r\n\t\t\tfor (uint32_t i = 0; i < decal.points; i++)\r\n\t\t\t\tpVertexMem[i] = { { decal.pos[i].x, decal.pos[i].y, decal.w[i] }, { decal.uv[i].x, decal.uv[i].y }, decal.tint[i] };\r\n\r\n\t\t\tlocBufferData(0x8892, sizeof(locVertex) * decal.points, pVertexMem, 0x88E0);\r\n\r\n\t\t\tif (nDecalMode == DecalMode::WIREFRAME)\r\n\t\t\t\tglDrawArrays(GL_LINE_LOOP, 0, decal.points);\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (decal.structure == olc::DecalStructure::FAN)\r\n\t\t\t\t\tglDrawArrays(GL_TRIANGLE_FAN, 0, decal.points);\r\n\t\t\t\telse if (decal.structure == olc::DecalStructure::STRIP)\r\n\t\t\t\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, decal.points);\r\n\t\t\t\telse if (decal.structure == olc::DecalStructure::LIST)\r\n\t\t\t\t\tglDrawArrays(GL_TRIANGLES, 0, decal.points);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint32_t CreateTexture(const uint32_t width, const uint32_t height, const bool filtered, const bool clamp) override\r\n\t\t{\r\n\t\t\tUNUSED(width);\r\n\t\t\tUNUSED(height);\r\n\t\t\tuint32_t id = 0;\r\n\t\t\tglGenTextures(1, &id);\r\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\r\n\r\n\t\t\tif (filtered)\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\r\n\t\t\t}\r\n\r\n\t\t\tif (clamp)\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n\t\t\t}\r\n#if !defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\t\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\r\n#endif\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\tuint32_t DeleteTexture(const uint32_t id) override\r\n\t\t{\r\n\t\t\tglDeleteTextures(1, &id);\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\tvoid UpdateTexture(uint32_t id, olc::Sprite* spr) override\r\n\t\t{\r\n\t\t\tUNUSED(id);\r\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, spr->width, spr->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, spr->GetData());\r\n\t\t}\r\n\r\n\t\tvoid ReadTexture(uint32_t id, olc::Sprite* spr) override\r\n\t\t{\r\n\t\t\tglReadPixels(0, 0, spr->width, spr->height, GL_RGBA, GL_UNSIGNED_BYTE, spr->GetData());\r\n\t\t}\r\n\r\n\t\tvoid ApplyTexture(uint32_t id) override\r\n\t\t{\r\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\r\n\t\t}\r\n\r\n\t\tvoid ClearBuffer(olc::Pixel p, bool bDepth) override\r\n\t\t{\r\n\t\t\tglClearColor(float(p.r) / 255.0f, float(p.g) / 255.0f, float(p.b) / 255.0f, float(p.a) / 255.0f);\r\n\t\t\tglClear(GL_COLOR_BUFFER_BIT);\r\n\t\t\tif (bDepth) glClear(GL_DEPTH_BUFFER_BIT);\r\n\t\t}\r\n\r\n\t\tvoid UpdateViewport(const olc::vi2d& pos, const olc::vi2d& size) override\r\n\t\t{\r\n\t\t\tglViewport(pos.x, pos.y, size.x, size.y);\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END RENDERER: OpenGL 3.3 (3.0 es) (sh-sh-sh-shaders....)                     |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine Image loaders                                             |\r\n// O------------------------------------------------------------------------------O\r\n\r\n#pragma region image_gdi\r\n// O------------------------------------------------------------------------------O\r\n// | START IMAGE LOADER: GDI+, Windows Only, always exists, a little slow         |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_IMAGE_GDI)\r\n\r\n#define min(a, b) ((a < b) ? a : b)\r\n#define max(a, b) ((a > b) ? a : b)\r\n#include <objidl.h>\r\n#include <gdiplus.h>\r\n#if defined(__MINGW32__) // Thanks Gusgo & Dandistine, but c'mon mingw!! wtf?!\r\n\t#include <gdiplus/gdiplusinit.h>\r\n#else\r\n\t#include <gdiplusinit.h>\r\n#endif\r\n#include <shlwapi.h>\r\n#undef min\r\n#undef max\r\n\r\n#if !defined(__MINGW32__)\r\n\t#pragma comment(lib, \"gdiplus.lib\")\r\n\t#pragma comment(lib, \"Shlwapi.lib\")\r\n#endif\r\n\r\nnamespace olc\r\n{\r\n\t// Thanks @MaGetzUb for this, which allows sprites to be defined\r\n\t// at construction, by initialising the GDI subsystem\r\n\tstatic class GDIPlusStartup\r\n\t{\r\n\tpublic:\r\n\t\tGDIPlusStartup()\r\n\t\t{\t\t\t\r\n\t\t\tGdiplus::GdiplusStartupInput startupInput;\r\n\t\t\tGdiplusStartup(&token, &startupInput, NULL);\r\n\t\t}\r\n\r\n\t\tULONG_PTR\ttoken;\r\n\t\t\r\n\t\t~GDIPlusStartup()\r\n\t\t{\r\n\t\t\t// Well, MarcusTU thought this was important :D\r\n\t\t\tGdiplus::GdiplusShutdown(token);\r\n\t\t}\r\n\t} gdistartup;\r\n\r\n\tclass ImageLoader_GDIPlus : public olc::ImageLoader\r\n\t{\r\n\tprivate:\r\n\t\tstd::wstring ConvertS2W(std::string s)\r\n\t\t{\r\n#ifdef __MINGW32__\r\n\t\t\twchar_t* buffer = new wchar_t[s.length() + 1];\r\n\t\t\tmbstowcs(buffer, s.c_str(), s.length());\r\n\t\t\tbuffer[s.length()] = L'\\0';\r\n#else\r\n\t\t\tint count = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, NULL, 0);\r\n\t\t\twchar_t* buffer = new wchar_t[count];\r\n\t\t\tMultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, buffer, count);\r\n#endif\r\n\t\t\tstd::wstring w(buffer);\r\n\t\t\tdelete[] buffer;\r\n\t\t\treturn w;\r\n\t\t}\r\n\r\n\tpublic:\r\n\t\tImageLoader_GDIPlus() : ImageLoader()\r\n\t\t{}\r\n\r\n\t\tolc::rcode LoadImageResource(olc::Sprite* spr, const std::string& sImageFile, olc::ResourcePack* pack) override\r\n\t\t{\r\n\t\t\t// clear out existing sprite\r\n\t\t\tspr->pColData.clear();\r\n\r\n\t\t\t// Open file\r\n\t\t\tUNUSED(pack);\r\n\t\t\tGdiplus::Bitmap* bmp = nullptr;\r\n\t\t\tif (pack != nullptr)\r\n\t\t\t{\r\n\t\t\t\t// Load sprite from input stream\r\n\t\t\t\tResourceBuffer rb = pack->GetFileBuffer(sImageFile);\r\n\t\t\t\tbmp = Gdiplus::Bitmap::FromStream(SHCreateMemStream((BYTE*)rb.vMemory.data(), UINT(rb.vMemory.size())));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Check file exists\r\n\t\t\t\tif (!_gfs::exists(sImageFile)) return olc::rcode::NO_FILE;\r\n\r\n\t\t\t\t// Load sprite from file\r\n\t\t\t\tbmp = Gdiplus::Bitmap::FromFile(ConvertS2W(sImageFile).c_str());\r\n\t\t\t}\r\n\r\n\t\t\tif (bmp->GetLastStatus() != Gdiplus::Ok) return olc::rcode::FAIL;\r\n\t\t\tspr->width = bmp->GetWidth();\r\n\t\t\tspr->height = bmp->GetHeight();\r\n\r\n\t\t\tspr->pColData.resize(spr->width * spr->height);\r\n\r\n\t\t\tfor (int y = 0; y < spr->height; y++)\r\n\t\t\t\tfor (int x = 0; x < spr->width; x++)\r\n\t\t\t\t{\r\n\t\t\t\t\tGdiplus::Color c;\r\n\t\t\t\t\tbmp->GetPixel(x, y, &c);\r\n\t\t\t\t\tspr->SetPixel(x, y, olc::Pixel(c.GetRed(), c.GetGreen(), c.GetBlue(), c.GetAlpha()));\r\n\t\t\t\t}\r\n\t\t\tdelete bmp;\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode SaveImageResource(olc::Sprite* spr, const std::string& sImageFile) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END IMAGE LOADER: GDI+                                                       |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n#pragma region image_libpng\r\n// O------------------------------------------------------------------------------O\r\n// | START IMAGE LOADER: libpng, default on linux, requires -lpng  (libpng-dev)   |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_IMAGE_LIBPNG)\r\n#include <png.h>\r\nnamespace olc\r\n{\r\n\tvoid pngReadStream(png_structp pngPtr, png_bytep data, png_size_t length)\r\n\t{\r\n\t\tpng_voidp a = png_get_io_ptr(pngPtr);\r\n\t\t((std::istream*)a)->read((char*)data, length);\r\n\t}\r\n\r\n\tclass ImageLoader_LibPNG : public olc::ImageLoader\r\n\t{\r\n\tpublic:\r\n\t\tImageLoader_LibPNG() : ImageLoader()\r\n\t\t{}\r\n\r\n\t\tolc::rcode LoadImageResource(olc::Sprite* spr, const std::string& sImageFile, olc::ResourcePack* pack) override\r\n\t\t{\r\n\t\t\tUNUSED(pack);\r\n\r\n\t\t\t// clear out existing sprite\r\n\t\t\tspr->pColData.clear();\r\n\r\n\t\t\t////////////////////////////////////////////////////////////////////////////\r\n\t\t\t// Use libpng, Thanks to Guillaume Cottenceau\r\n\t\t\t// https://gist.github.com/niw/5963798\r\n\t\t\t// Also reading png from streams\r\n\t\t\t// http://www.piko3d.net/tutorials/libpng-tutorial-loading-png-files-from-streams/\r\n\t\t\tpng_structp png;\r\n\t\t\tpng_infop info;\r\n\r\n\t\t\tauto loadPNG = [&]()\r\n\t\t\t{\r\n\t\t\t\tpng_read_info(png, info);\r\n\t\t\t\tpng_byte color_type;\r\n\t\t\t\tpng_byte bit_depth;\r\n\t\t\t\tpng_bytep* row_pointers;\r\n\t\t\t\tspr->width = png_get_image_width(png, info);\r\n\t\t\t\tspr->height = png_get_image_height(png, info);\r\n\t\t\t\tcolor_type = png_get_color_type(png, info);\r\n\t\t\t\tbit_depth = png_get_bit_depth(png, info);\r\n\t\t\t\tif (bit_depth == 16) png_set_strip_16(png);\r\n\t\t\t\tif (color_type == PNG_COLOR_TYPE_PALETTE) png_set_palette_to_rgb(png);\r\n\t\t\t\tif (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\tpng_set_expand_gray_1_2_4_to_8(png);\r\n\t\t\t\tif (png_get_valid(png, info, PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png);\r\n\t\t\t\tif (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_PALETTE)\r\n\t\t\t\t\tpng_set_filler(png, 0xFF, PNG_FILLER_AFTER);\r\n\t\t\t\tif (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n\t\t\t\t\tpng_set_gray_to_rgb(png);\r\n\t\t\t\tpng_read_update_info(png, info);\r\n\t\t\t\trow_pointers = (png_bytep*)malloc(sizeof(png_bytep) * spr->height);\r\n\t\t\t\tfor (int y = 0; y < spr->height; y++) {\r\n\t\t\t\t\trow_pointers[y] = (png_byte*)malloc(png_get_rowbytes(png, info));\r\n\t\t\t\t}\r\n\t\t\t\tpng_read_image(png, row_pointers);\r\n\t\t\t\t////////////////////////////////////////////////////////////////////////////\r\n\t\t\t\t// Create sprite array\r\n\t\t\t\tspr->pColData.resize(spr->width * spr->height);\r\n\t\t\t\t// Iterate through image rows, converting into sprite format\r\n\t\t\t\tfor (int y = 0; y < spr->height; y++)\r\n\t\t\t\t{\r\n\t\t\t\t\tpng_bytep row = row_pointers[y];\r\n\t\t\t\t\tfor (int x = 0; x < spr->width; x++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpng_bytep px = &(row[x * 4]);\r\n\t\t\t\t\t\tspr->SetPixel(x, y, Pixel(px[0], px[1], px[2], px[3]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int y = 0; y < spr->height; y++) // Thanks maksym33\r\n\t\t\t\t\tfree(row_pointers[y]);\r\n\t\t\t\tfree(row_pointers);\r\n\t\t\t\tpng_destroy_read_struct(&png, &info, nullptr);\r\n\t\t\t};\r\n\r\n\t\t\tpng = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\r\n\t\t\tif (!png) goto fail_load;\r\n\r\n\t\t\tinfo = png_create_info_struct(png);\r\n\t\t\tif (!info) goto fail_load;\r\n\r\n\t\t\tif (setjmp(png_jmpbuf(png))) goto fail_load;\r\n\r\n\t\t\tif (pack == nullptr)\r\n\t\t\t{\r\n\t\t\t\tFILE* f = fopen(sImageFile.c_str(), \"rb\");\r\n\t\t\t\tif (!f) return olc::rcode::NO_FILE;\r\n\t\t\t\tpng_init_io(png, f);\r\n\t\t\t\tloadPNG();\r\n\t\t\t\tfclose(f);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tResourceBuffer rb = pack->GetFileBuffer(sImageFile);\r\n\t\t\t\tstd::istream is(&rb);\r\n\t\t\t\tpng_set_read_fn(png, (png_voidp)&is, pngReadStream);\r\n\t\t\t\tloadPNG();\r\n\t\t\t}\r\n\r\n\t\t\treturn olc::rcode::OK;\r\n\r\n\t\tfail_load:\r\n\t\t\tspr->width = 0;\r\n\t\t\tspr->height = 0;\r\n\t\t\tspr->pColData.clear();\r\n\t\t\treturn olc::rcode::FAIL;\r\n\t\t}\r\n\r\n\t\tolc::rcode SaveImageResource(olc::Sprite* spr, const std::string& sImageFile) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END IMAGE LOADER:                                                            |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine Platforms                                                 |\r\n// O------------------------------------------------------------------------------O\r\n\r\n#pragma region platform_windows\r\n// O------------------------------------------------------------------------------O\r\n// | START PLATFORM: MICROSOFT WINDOWS XP, VISTA, 7, 8, 10                        |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\r\n#if defined(_WIN32) && !defined(__MINGW32__)\r\n\t#pragma comment(lib, \"user32.lib\")\t\t// Visual Studio Only\r\n\t#pragma comment(lib, \"gdi32.lib\")\t\t// For other Windows Compilers please add\r\n\t#pragma comment(lib, \"opengl32.lib\")\t// these libs to your linker input\r\n#endif\r\n\r\nnamespace olc\r\n{\r\n\tclass Platform_Windows : public olc::Platform\r\n\t{\r\n\tprivate:\r\n\t\tHWND olc_hWnd = nullptr;\r\n\t\tstd::wstring wsAppName;\r\n\t\tinline static olc::vi2d vWinPos;\r\n\t\tinline static olc::vi2d vWinSize;\r\n\r\n\t\tstd::wstring ConvertS2W(std::string s)\r\n\t\t{\r\n#ifdef __MINGW32__\r\n\t\t\twchar_t* buffer = new wchar_t[s.length() + 1];\r\n\t\t\tmbstowcs(buffer, s.c_str(), s.length());\r\n\t\t\tbuffer[s.length()] = L'\\0';\r\n#else\r\n\t\t\tint count = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, NULL, 0);\r\n\t\t\twchar_t* buffer = new wchar_t[count];\r\n\t\t\tMultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, buffer, count);\r\n#endif\r\n\t\t\tstd::wstring w(buffer);\r\n\t\t\tdelete[] buffer;\r\n\t\t\treturn w;\r\n\t\t}\r\n\r\n\r\n\r\n\tpublic:\r\n\t\tvirtual olc::rcode ApplicationStartUp() override { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode ApplicationCleanUp() override { return olc::rcode::OK; }\r\n\t\tvirtual olc::rcode ThreadStartUp() override { return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ThreadCleanUp() override\r\n\t\t{\r\n\t\t\trenderer->DestroyDevice();\r\n\t\t\tPostMessage(olc_hWnd, WM_DESTROY, 0, 0);\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) override\r\n\t\t{\r\n\t\t\tif (renderer->CreateDevice({ olc_hWnd }, bFullScreen, bEnableVSYNC) == olc::rcode::OK)\r\n\t\t\t{\r\n\t\t\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t\t\t\treturn olc::rcode::OK;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\treturn olc::rcode::FAIL;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) override\r\n\t\t{\r\n\t\t\tWNDCLASS wc;\r\n\t\t\twc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n\t\t\twc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n\t\t\twc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;\r\n\t\t\twc.hInstance = GetModuleHandle(nullptr);\r\n\t\t\twc.lpfnWndProc = olc_WindowEvent;\r\n\t\t\twc.cbClsExtra = 0;\r\n\t\t\twc.cbWndExtra = 0;\r\n\t\t\twc.lpszMenuName = nullptr;\r\n\t\t\twc.hbrBackground = nullptr;\r\n\t\t\twc.lpszClassName = olcT(\"OLC_PIXEL_GAME_ENGINE\");\r\n\t\t\tRegisterClass(&wc);\r\n\r\n\t\t\tvWinPos = vWindowPos;\r\n\t\t\tvWinSize = vWindowSize;\r\n\r\n\t\t\t// Define window furniture\r\n\t\t\tDWORD dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\r\n\t\t\tDWORD dwStyle = WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME;\r\n\r\n\t\t\tolc::vi2d vTopLeft = vWindowPos;\r\n\r\n\t\t\t// Handle Fullscreen\r\n\t\t\tif (bFullScreen)\r\n\t\t\t{\r\n\t\t\t\tdwExStyle = 0;\r\n\t\t\t\tdwStyle = WS_VISIBLE | WS_POPUP;\r\n\t\t\t\tHMONITOR hmon = MonitorFromWindow(olc_hWnd, MONITOR_DEFAULTTONEAREST);\r\n\t\t\t\tMONITORINFO mi = { sizeof(mi) };\r\n\t\t\t\tif (!GetMonitorInfo(hmon, &mi)) return olc::rcode::FAIL;\r\n\t\t\t\tvWindowSize = { mi.rcMonitor.right, mi.rcMonitor.bottom };\r\n\t\t\t\tvTopLeft.x = 0;\r\n\t\t\t\tvTopLeft.y = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Keep client size as requested\r\n\t\t\tRECT rWndRect = { 0, 0, vWindowSize.x, vWindowSize.y };\r\n\t\t\tAdjustWindowRectEx(&rWndRect, dwStyle, FALSE, dwExStyle);\r\n\t\t\tint width = rWndRect.right - rWndRect.left;\r\n\t\t\tint height = rWndRect.bottom - rWndRect.top;\r\n\r\n\t\t\tolc_hWnd = CreateWindowEx(dwExStyle, olcT(\"OLC_PIXEL_GAME_ENGINE\"), olcT(\"\"), dwStyle,\r\n\t\t\t\tvTopLeft.x, vTopLeft.y, width, height, NULL, NULL, GetModuleHandle(nullptr), this);\r\n\r\n\t\t\tDragAcceptFiles(olc_hWnd, true);\r\n\r\n\t\t\t// Create Keyboard Mapping\r\n\t\t\tmapKeys[0x00] = Key::NONE;\r\n\t\t\tmapKeys[0x41] = Key::A; mapKeys[0x42] = Key::B; mapKeys[0x43] = Key::C; mapKeys[0x44] = Key::D; mapKeys[0x45] = Key::E;\r\n\t\t\tmapKeys[0x46] = Key::F; mapKeys[0x47] = Key::G; mapKeys[0x48] = Key::H; mapKeys[0x49] = Key::I; mapKeys[0x4A] = Key::J;\r\n\t\t\tmapKeys[0x4B] = Key::K; mapKeys[0x4C] = Key::L; mapKeys[0x4D] = Key::M; mapKeys[0x4E] = Key::N; mapKeys[0x4F] = Key::O;\r\n\t\t\tmapKeys[0x50] = Key::P; mapKeys[0x51] = Key::Q; mapKeys[0x52] = Key::R; mapKeys[0x53] = Key::S; mapKeys[0x54] = Key::T;\r\n\t\t\tmapKeys[0x55] = Key::U; mapKeys[0x56] = Key::V; mapKeys[0x57] = Key::W; mapKeys[0x58] = Key::X; mapKeys[0x59] = Key::Y;\r\n\t\t\tmapKeys[0x5A] = Key::Z;\r\n\r\n\t\t\tmapKeys[VK_F1] = Key::F1; mapKeys[VK_F2] = Key::F2; mapKeys[VK_F3] = Key::F3; mapKeys[VK_F4] = Key::F4;\r\n\t\t\tmapKeys[VK_F5] = Key::F5; mapKeys[VK_F6] = Key::F6; mapKeys[VK_F7] = Key::F7; mapKeys[VK_F8] = Key::F8;\r\n\t\t\tmapKeys[VK_F9] = Key::F9; mapKeys[VK_F10] = Key::F10; mapKeys[VK_F11] = Key::F11; mapKeys[VK_F12] = Key::F12;\r\n\r\n\t\t\tmapKeys[VK_DOWN] = Key::DOWN; mapKeys[VK_LEFT] = Key::LEFT; mapKeys[VK_RIGHT] = Key::RIGHT; mapKeys[VK_UP] = Key::UP;\r\n\t\t\t//mapKeys[VK_RETURN] = Key::ENTER;// mapKeys[VK_RETURN] = Key::RETURN;\r\n\t\t\t\r\n\t\t\tmapKeys[VK_BACK] = Key::BACK; mapKeys[VK_ESCAPE] = Key::ESCAPE; mapKeys[VK_RETURN] = Key::ENTER; mapKeys[VK_PAUSE] = Key::PAUSE;\r\n\t\t\tmapKeys[VK_SCROLL] = Key::SCROLL; mapKeys[VK_TAB] = Key::TAB; mapKeys[VK_DELETE] = Key::DEL; mapKeys[VK_HOME] = Key::HOME;\r\n\t\t\tmapKeys[VK_END] = Key::END; mapKeys[VK_PRIOR] = Key::PGUP; mapKeys[VK_NEXT] = Key::PGDN; mapKeys[VK_INSERT] = Key::INS;\r\n\t\t\tmapKeys[VK_SHIFT] = Key::SHIFT; mapKeys[VK_CONTROL] = Key::CTRL;\r\n\t\t\tmapKeys[VK_SPACE] = Key::SPACE;\r\n\r\n\t\t\tmapKeys[0x30] = Key::K0; mapKeys[0x31] = Key::K1; mapKeys[0x32] = Key::K2; mapKeys[0x33] = Key::K3; mapKeys[0x34] = Key::K4;\r\n\t\t\tmapKeys[0x35] = Key::K5; mapKeys[0x36] = Key::K6; mapKeys[0x37] = Key::K7; mapKeys[0x38] = Key::K8; mapKeys[0x39] = Key::K9;\r\n\r\n\t\t\tmapKeys[VK_NUMPAD0] = Key::NP0; mapKeys[VK_NUMPAD1] = Key::NP1; mapKeys[VK_NUMPAD2] = Key::NP2; mapKeys[VK_NUMPAD3] = Key::NP3; mapKeys[VK_NUMPAD4] = Key::NP4;\r\n\t\t\tmapKeys[VK_NUMPAD5] = Key::NP5; mapKeys[VK_NUMPAD6] = Key::NP6; mapKeys[VK_NUMPAD7] = Key::NP7; mapKeys[VK_NUMPAD8] = Key::NP8; mapKeys[VK_NUMPAD9] = Key::NP9;\r\n\t\t\tmapKeys[VK_MULTIPLY] = Key::NP_MUL; mapKeys[VK_ADD] = Key::NP_ADD; mapKeys[VK_DIVIDE] = Key::NP_DIV; mapKeys[VK_SUBTRACT] = Key::NP_SUB; mapKeys[VK_DECIMAL] = Key::NP_DECIMAL;\r\n\r\n\t\t\t// Thanks scripticuk\r\n\t\t\tmapKeys[VK_OEM_1] = Key::OEM_1;\t\t\t// On US and UK keyboards this is the ';:' key\r\n\t\t\tmapKeys[VK_OEM_2] = Key::OEM_2;\t\t\t// On US and UK keyboards this is the '/?' key\r\n\t\t\tmapKeys[VK_OEM_3] = Key::OEM_3;\t\t\t// On US keyboard this is the '~' key\r\n\t\t\tmapKeys[VK_OEM_4] = Key::OEM_4;\t\t\t// On US and UK keyboards this is the '[{' key\r\n\t\t\tmapKeys[VK_OEM_5] = Key::OEM_5;\t\t\t// On US keyboard this is '\\|' key.\r\n\t\t\tmapKeys[VK_OEM_6] = Key::OEM_6;\t\t\t// On US and UK keyboards this is the ']}' key\r\n\t\t\tmapKeys[VK_OEM_7] = Key::OEM_7;\t\t\t// On US keyboard this is the single/double quote key. On UK, this is the single quote/@ symbol key\r\n\t\t\tmapKeys[VK_OEM_8] = Key::OEM_8;\t\t\t// miscellaneous characters. Varies by keyboard\r\n\t\t\tmapKeys[VK_OEM_PLUS] = Key::EQUALS;\t\t// the '+' key on any keyboard\r\n\t\t\tmapKeys[VK_OEM_COMMA] = Key::COMMA;\t\t// the comma key on any keyboard\r\n\t\t\tmapKeys[VK_OEM_MINUS] = Key::MINUS;\t\t// the minus key on any keyboard\r\n\t\t\tmapKeys[VK_OEM_PERIOD] = Key::PERIOD;\t// the period key on any keyboard\r\n\t\t\tmapKeys[VK_CAPITAL] = Key::CAPS_LOCK;\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) override\r\n\t\t{\r\n#ifdef UNICODE\r\n\t\t\tSetWindowText(olc_hWnd, ConvertS2W(s).c_str());\r\n#else\r\n\t\t\tSetWindowText(olc_hWnd, s.c_str());\r\n#endif\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode ShowWindowFrame(const bool bShowFrame)\r\n\t\t{\r\n\t\t\t// Oooooooof... yeah....\r\n\t\t\tDWORD dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\r\n\t\t\tDWORD dwStyle = WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME;\r\n\t\t\t\r\n\t\t\tRECT rWndRect, rWndRectNow;\r\n\t\t\tGetWindowRect(olc_hWnd, &rWndRectNow);\r\n\t\t\t\r\n\t\t\tif (!bShowFrame)\r\n\t\t\t{\r\n\t\t\t\tLONG_PTR lp = GetWindowLongPtr(olc_hWnd, GWL_STYLE);\r\n\t\t\t\tSetWindowLongPtr(olc_hWnd, GWL_STYLE, lp & ~(WS_CAPTION | WS_SYSMENU | WS_POPUPWINDOW | WS_THICKFRAME));\t\t\t\t\t\t\t\t\r\n\t\t\t\tlp = GetWindowLongPtr(olc_hWnd, GWL_EXSTYLE);\r\n\t\t\t\tSetWindowLongPtr(olc_hWnd, GWL_EXSTYLE, lp & ~(WS_EX_WINDOWEDGE));\r\n\t\t\t\tdwExStyle = WS_EX_APPWINDOW;\r\n\t\t\t\tdwStyle = 0;\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLONG_PTR lp = GetWindowLongPtr(olc_hWnd, GWL_STYLE);\r\n\t\t\t\tSetWindowLongPtr(olc_hWnd, GWL_STYLE, lp | (WS_CAPTION | WS_SYSMENU | WS_POPUPWINDOW|WS_THICKFRAME));\r\n\t\t\t\tlp = GetWindowLongPtr(olc_hWnd, GWL_EXSTYLE);\r\n\t\t\t\tSetWindowLongPtr(olc_hWnd, GWL_EXSTYLE, lp | (WS_EX_WINDOWEDGE));\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\trWndRectNow.right = rWndRectNow.left + vWinSize.x;\r\n\t\t\trWndRectNow.bottom = rWndRectNow.top + vWinSize.y;\r\n\t\t\trWndRect = rWndRectNow;\r\n\t\t\tAdjustWindowRectEx(&rWndRect, dwStyle, FALSE, dwExStyle);\r\n\t\t\tint width = rWndRect.right - rWndRect.left;\r\n\t\t\tint height = rWndRect.bottom - rWndRect.top;\r\n\t\t\tvWinPos = { rWndRect.left, rWndRect.top };\r\n\t\t\tvWinSize = { width, height };\r\n\t\t\tSetWindowPos(olc_hWnd, NULL, rWndRectNow.left, rWndRectNow.top, width, height, SWP_SHOWWINDOW);\r\n\r\n\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tolc::rcode SetWindowSize(const olc::vi2d& vWindowPos, const olc::vi2d& vWindowSize)\r\n\t\t{\r\n\t\t\tvWinPos = vWindowPos;\r\n\t\t\tvWinSize = vWindowSize;\r\n\t\t\tRECT rWndRect;\r\n\t\t\trWndRect.left = vWinPos.x;\r\n\t\t\trWndRect.top = vWinPos.y;\r\n\t\t\trWndRect.right = rWndRect.left + vWinSize.x;\r\n\t\t\trWndRect.bottom = rWndRect.top + vWinSize.y;\r\n\t\t\trWndRect = rWndRect;\r\n\t\t\tDWORD dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\r\n\t\t\tDWORD dwStyle = WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME;\r\n\t\t\tAdjustWindowRectEx(&rWndRect, dwStyle, FALSE, dwExStyle);\r\n\t\t\tint width = rWndRect.right - rWndRect.left;\r\n\t\t\tint height = rWndRect.bottom - rWndRect.top;\r\n\t\t\tvWinPos = { rWndRect.left, rWndRect.top };\r\n\t\t\tvWinSize = { width, height };\r\n\t\t\tSetWindowPos(olc_hWnd, NULL, vWinPos.x, vWinPos.y, width, height, SWP_SHOWWINDOW);\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode StartSystemEventLoop() override\r\n\t\t{\r\n\t\t\tMSG msg;\r\n\t\t\twhile (GetMessage(&msg, NULL, 0, 0) > 0)\r\n\t\t\t{\r\n\t\t\t\tTranslateMessage(&msg);\r\n\t\t\t\tDispatchMessage(&msg);\r\n\t\t\t}\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode HandleSystemEvent() override { return olc::rcode::FAIL; }\r\n\r\n\t\t// Windows Event Handler - this is statically connected to the windows event system\r\n\t\tstatic LRESULT CALLBACK olc_WindowEvent(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n\t\t{\r\n\t\t\tswitch (uMsg)\r\n\t\t\t{\r\n\t\t\tcase WM_MOUSEMOVE:\r\n\t\t\t{\r\n\t\t\t\t// Thanks @ForAbby (Discord)\r\n\t\t\t\tuint16_t x = lParam & 0xFFFF; uint16_t y = (lParam >> 16) & 0xFFFF;\r\n\t\t\t\tint16_t ix = *(int16_t*)&x;   int16_t iy = *(int16_t*)&y;\r\n\t\t\t\tptrPGE->olc_UpdateMouse(ix, iy);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tcase WM_MOVE:       vWinPos = olc::vi2d(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF);  ptrPGE->olc_UpdateWindowPos(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF);\treturn 0;\r\n\t\t\tcase WM_SIZE:       vWinSize = olc::vi2d(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF);  ptrPGE->olc_UpdateWindowSize(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF);\treturn 0;\r\n\t\t\tcase WM_MOUSEWHEEL:\tptrPGE->olc_UpdateMouseWheel(GET_WHEEL_DELTA_WPARAM(wParam));           return 0;\r\n\t\t\tcase WM_MOUSELEAVE: ptrPGE->olc_UpdateMouseFocus(false);                                    return 0;\r\n\t\t\tcase WM_SETFOCUS:\tptrPGE->olc_UpdateKeyFocus(true);                                       return 0;\r\n\t\t\tcase WM_KILLFOCUS:\tptrPGE->olc_UpdateKeyFocus(false);                                      return 0;\r\n\t\t\tcase WM_KEYDOWN:\tptrPGE->olc_UpdateKeyState(mapKeys[wParam], true);                      return 0;\r\n\t\t\tcase WM_KEYUP:\t\tptrPGE->olc_UpdateKeyState(mapKeys[wParam], false);                     return 0;\r\n\t\t\tcase WM_SYSKEYDOWN: ptrPGE->olc_UpdateKeyState(mapKeys[wParam], true);\t\t\t\t\t\treturn 0;\r\n\t\t\tcase WM_SYSKEYUP:\tptrPGE->olc_UpdateKeyState(mapKeys[wParam], false);\t\t\t\t\t\treturn 0;\r\n\t\t\tcase WM_LBUTTONDOWN:ptrPGE->olc_UpdateMouseState(0, true);                                  return 0;\r\n\t\t\tcase WM_LBUTTONUP:\tptrPGE->olc_UpdateMouseState(0, false);                                 return 0;\r\n\t\t\tcase WM_RBUTTONDOWN:ptrPGE->olc_UpdateMouseState(1, true);                                  return 0;\r\n\t\t\tcase WM_RBUTTONUP:\tptrPGE->olc_UpdateMouseState(1, false);                                 return 0;\r\n\t\t\tcase WM_MBUTTONDOWN:ptrPGE->olc_UpdateMouseState(2, true);                                  return 0;\r\n\t\t\tcase WM_MBUTTONUP:\tptrPGE->olc_UpdateMouseState(2, false);                                 return 0;\r\n\t\t\tcase WM_DROPFILES:\r\n\t\t\t{\r\n\t\t\t\t// This is all eww...\r\n\t\t\t\tHDROP drop = (HDROP)wParam;\r\n\t\t\t\t\r\n\t\t\t\tuint32_t nFiles = DragQueryFile(drop, 0xFFFFFFFF, nullptr, 0);\r\n\t\t\t\tstd::vector<std::string> vFiles;\r\n\t\t\t\tfor (uint32_t i = 0; i < nFiles; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tTCHAR dfbuffer[256]{};\r\n\t\t\t\t\tuint32_t len = DragQueryFile(drop, i, nullptr, 0);\r\n\t\t\t\t\tDragQueryFile(drop, i, dfbuffer, 256);\r\n#ifdef UNICODE\r\n\t#ifdef __MINGW32__\r\n\t\t\t\t\tchar* buffer = new char[len + 1];\r\n\t\t\t\t\twcstombs(buffer, dfbuffer, len);\r\n\t\t\t\t\tbuffer[len] = '\\0';\r\n\t#else\r\n\t\t\t\t\tint count = WideCharToMultiByte(CP_UTF8, 0, dfbuffer, -1, NULL, 0, NULL, NULL);\r\n\t\t\t\t\tchar* buffer = new char[count];\r\n\t\t\t\t\tWideCharToMultiByte(CP_UTF8, 0, dfbuffer, -1, buffer, count, NULL, NULL);\r\n\t#endif\t\t\t\t\r\n\t\t\t\t\tvFiles.push_back(std::string(buffer));\r\n\t\t\t\t\tdelete[] buffer;\r\n#else\r\n\t\t\t\t\tvFiles.push_back(std::string(dfbuffer));\r\n#endif\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Even more eww...\r\n\t\t\t\tPOINT p; DragQueryPoint(drop, &p);\r\n\t\t\t\tptrPGE->olc_DropFiles(p.x, p.y, vFiles);\r\n\t\t\t\tDragFinish(drop);\r\n\t\t\t\treturn 0;\r\n\t\t\t} \r\n\t\t\tbreak;\r\n\r\n\r\n\t\t\tcase WM_CLOSE:\t\tptrPGE->olc_Terminate();                                                return 0;\r\n\t\t\tcase WM_DESTROY:\tPostQuitMessage(0); DestroyWindow(hWnd);\t\t\t\t\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END PLATFORM: MICROSOFT WINDOWS XP, VISTA, 7, 8, 10                          |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion \r\n\r\n#pragma region platform_linux\r\n// O------------------------------------------------------------------------------O\r\n// | START PLATFORM: LINUX                                                        |\r\n// O------------------------------------------------------------------------------O\r\n#if defined(OLC_PLATFORM_X11)\r\nnamespace olc\r\n{\r\n\tclass Platform_Linux : public olc::Platform\r\n\t{\r\n\tprivate:\r\n\t\tX11::Display* olc_Display = nullptr;\r\n\t\tX11::Window\t\t\t\t\t olc_WindowRoot;\r\n\t\tX11::Window\t\t\t\t\t olc_Window;\r\n\t\tX11::XVisualInfo* olc_VisualInfo;\r\n\t\tX11::Colormap                olc_ColourMap;\r\n\t\tX11::XSetWindowAttributes    olc_SetWindowAttribs;\r\n\r\n\tpublic:\r\n\t\tvirtual olc::rcode ApplicationStartUp() override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ApplicationCleanUp() override\r\n\t\t{\r\n\t\t\tXDestroyWindow(olc_Display, olc_Window);\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ThreadStartUp() override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ThreadCleanUp() override\r\n\t\t{\r\n\t\t\trenderer->DestroyDevice();\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) override\r\n\t\t{\r\n\t\t\tif (renderer->CreateDevice({ olc_Display, &olc_Window, olc_VisualInfo }, bFullScreen, bEnableVSYNC) == olc::rcode::OK)\r\n\t\t\t{\r\n\t\t\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t\t\t\treturn olc::rcode::OK;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\treturn olc::rcode::FAIL;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) override\r\n\t\t{\r\n\t\t\tusing namespace X11;\r\n\t\t\tXInitThreads();\r\n\r\n\t\t\t// Grab the deafult display and window\r\n\t\t\tolc_Display = XOpenDisplay(NULL);\r\n\t\t\tolc_WindowRoot = DefaultRootWindow(olc_Display);\r\n\r\n\t\t\t// Based on the display capabilities, configure the appearance of the window\r\n\t\t\tGLint olc_GLAttribs[] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };\r\n\t\t\tolc_VisualInfo = glXChooseVisual(olc_Display, 0, olc_GLAttribs);\r\n\t\t\tolc_ColourMap = XCreateColormap(olc_Display, olc_WindowRoot, olc_VisualInfo->visual, AllocNone);\r\n\t\t\tolc_SetWindowAttribs.colormap = olc_ColourMap;\r\n\r\n\t\t\t// Register which events we are interested in receiving\r\n\t\t\tolc_SetWindowAttribs.event_mask = ExposureMask | KeyPressMask | KeyReleaseMask |\r\n\t\t\t\tButtonPressMask | ButtonReleaseMask | PointerMotionMask | FocusChangeMask | StructureNotifyMask;\r\n\r\n\t\t\t// Create the window\r\n\t\t\tolc_Window = XCreateWindow(olc_Display, olc_WindowRoot, vWindowPos.x, vWindowPos.y,\r\n\t\t\t\tvWindowSize.x, vWindowSize.y,\r\n\t\t\t\t0, olc_VisualInfo->depth, InputOutput, olc_VisualInfo->visual,\r\n\t\t\t\tCWColormap | CWEventMask, &olc_SetWindowAttribs);\r\n\r\n\t\t\tAtom wmDelete = XInternAtom(olc_Display, \"WM_DELETE_WINDOW\", true);\r\n\t\t\tXSetWMProtocols(olc_Display, olc_Window, &wmDelete, 1);\r\n\r\n\t\t\tXMapWindow(olc_Display, olc_Window);\r\n\t\t\tXStoreName(olc_Display, olc_Window, \"OneLoneCoder.com - Pixel Game Engine\");\r\n\r\n\t\t\tif (bFullScreen) // Thanks DragonEye, again :D\r\n\t\t\t{\r\n\t\t\t\tAtom wm_state;\r\n\t\t\t\tAtom fullscreen;\r\n\t\t\t\twm_state = XInternAtom(olc_Display, \"_NET_WM_STATE\", False);\r\n\t\t\t\tfullscreen = XInternAtom(olc_Display, \"_NET_WM_STATE_FULLSCREEN\", False);\r\n\t\t\t\tXEvent xev{ 0 };\r\n\t\t\t\txev.type = ClientMessage;\r\n\t\t\t\txev.xclient.window = olc_Window;\r\n\t\t\t\txev.xclient.message_type = wm_state;\r\n\t\t\t\txev.xclient.format = 32;\r\n\t\t\t\txev.xclient.data.l[0] = (bFullScreen ? 1 : 0);   // the action (0: off, 1: on, 2: toggle)\r\n\t\t\t\txev.xclient.data.l[1] = fullscreen;             // first property to alter\r\n\t\t\t\txev.xclient.data.l[2] = 0;                      // second property to alter\r\n\t\t\t\txev.xclient.data.l[3] = 0;                      // source indication\r\n\t\t\t\tXMapWindow(olc_Display, olc_Window);\r\n\t\t\t\tXSendEvent(olc_Display, DefaultRootWindow(olc_Display), False,\r\n\t\t\t\t\tSubstructureRedirectMask | SubstructureNotifyMask, &xev);\r\n\t\t\t\tXFlush(olc_Display);\r\n\t\t\t\tXWindowAttributes gwa;\r\n\t\t\t\tXGetWindowAttributes(olc_Display, olc_Window, &gwa);\r\n\t\t\t\tvWindowSize.x = gwa.width;\r\n\t\t\t\tvWindowSize.y = gwa.height;\r\n\t\t\t}\r\n\r\n\t\t\t// Create Keyboard Mapping\r\n\t\t\tmapKeys[0x00] = Key::NONE;\r\n\t\t\tmapKeys[0x61] = Key::A; mapKeys[0x62] = Key::B; mapKeys[0x63] = Key::C; mapKeys[0x64] = Key::D; mapKeys[0x65] = Key::E;\r\n\t\t\tmapKeys[0x66] = Key::F; mapKeys[0x67] = Key::G; mapKeys[0x68] = Key::H; mapKeys[0x69] = Key::I; mapKeys[0x6A] = Key::J;\r\n\t\t\tmapKeys[0x6B] = Key::K; mapKeys[0x6C] = Key::L; mapKeys[0x6D] = Key::M; mapKeys[0x6E] = Key::N; mapKeys[0x6F] = Key::O;\r\n\t\t\tmapKeys[0x70] = Key::P; mapKeys[0x71] = Key::Q; mapKeys[0x72] = Key::R; mapKeys[0x73] = Key::S; mapKeys[0x74] = Key::T;\r\n\t\t\tmapKeys[0x75] = Key::U; mapKeys[0x76] = Key::V; mapKeys[0x77] = Key::W; mapKeys[0x78] = Key::X; mapKeys[0x79] = Key::Y;\r\n\t\t\tmapKeys[0x7A] = Key::Z;\r\n\r\n\t\t\tmapKeys[XK_F1] = Key::F1; mapKeys[XK_F2] = Key::F2; mapKeys[XK_F3] = Key::F3; mapKeys[XK_F4] = Key::F4;\r\n\t\t\tmapKeys[XK_F5] = Key::F5; mapKeys[XK_F6] = Key::F6; mapKeys[XK_F7] = Key::F7; mapKeys[XK_F8] = Key::F8;\r\n\t\t\tmapKeys[XK_F9] = Key::F9; mapKeys[XK_F10] = Key::F10; mapKeys[XK_F11] = Key::F11; mapKeys[XK_F12] = Key::F12;\r\n\r\n\t\t\tmapKeys[XK_Down] = Key::DOWN; mapKeys[XK_Left] = Key::LEFT; mapKeys[XK_Right] = Key::RIGHT; mapKeys[XK_Up] = Key::UP;\r\n\t\t\tmapKeys[XK_KP_Enter] = Key::ENTER; mapKeys[XK_Return] = Key::ENTER;\r\n\r\n\t\t\tmapKeys[XK_BackSpace] = Key::BACK; mapKeys[XK_Escape] = Key::ESCAPE; mapKeys[XK_Linefeed] = Key::ENTER;\tmapKeys[XK_Pause] = Key::PAUSE;\r\n\t\t\tmapKeys[XK_Scroll_Lock] = Key::SCROLL; mapKeys[XK_Tab] = Key::TAB; mapKeys[XK_Delete] = Key::DEL; mapKeys[XK_Home] = Key::HOME;\r\n\t\t\tmapKeys[XK_End] = Key::END; mapKeys[XK_Page_Up] = Key::PGUP; mapKeys[XK_Page_Down] = Key::PGDN;\tmapKeys[XK_Insert] = Key::INS;\r\n\t\t\tmapKeys[XK_Shift_L] = Key::SHIFT; mapKeys[XK_Shift_R] = Key::SHIFT; mapKeys[XK_Control_L] = Key::CTRL; mapKeys[XK_Control_R] = Key::CTRL;\r\n\t\t\tmapKeys[XK_space] = Key::SPACE; mapKeys[XK_period] = Key::PERIOD;\r\n\r\n\t\t\tmapKeys[XK_0] = Key::K0; mapKeys[XK_1] = Key::K1; mapKeys[XK_2] = Key::K2; mapKeys[XK_3] = Key::K3; mapKeys[XK_4] = Key::K4;\r\n\t\t\tmapKeys[XK_5] = Key::K5; mapKeys[XK_6] = Key::K6; mapKeys[XK_7] = Key::K7; mapKeys[XK_8] = Key::K8; mapKeys[XK_9] = Key::K9;\r\n\r\n\t\t\tmapKeys[XK_KP_0] = Key::NP0; mapKeys[XK_KP_1] = Key::NP1; mapKeys[XK_KP_2] = Key::NP2; mapKeys[XK_KP_3] = Key::NP3; mapKeys[XK_KP_4] = Key::NP4;\r\n\t\t\tmapKeys[XK_KP_5] = Key::NP5; mapKeys[XK_KP_6] = Key::NP6; mapKeys[XK_KP_7] = Key::NP7; mapKeys[XK_KP_8] = Key::NP8; mapKeys[XK_KP_9] = Key::NP9;\r\n\t\t\tmapKeys[XK_KP_Multiply] = Key::NP_MUL; mapKeys[XK_KP_Add] = Key::NP_ADD; mapKeys[XK_KP_Divide] = Key::NP_DIV; mapKeys[XK_KP_Subtract] = Key::NP_SUB; mapKeys[XK_KP_Decimal] = Key::NP_DECIMAL;\r\n\r\n\t\t\t// These keys vary depending on the keyboard. I've included comments for US and UK keyboard layouts\r\n\t\t\tmapKeys[XK_semicolon] = Key::OEM_1;\t\t// On US and UK keyboards this is the ';:' key\r\n\t\t\tmapKeys[XK_slash] = Key::OEM_2;\t\t\t// On US and UK keyboards this is the '/?' key\r\n\t\t\tmapKeys[XK_asciitilde] = Key::OEM_3;\t// On US keyboard this is the '~' key\r\n\t\t\tmapKeys[XK_bracketleft] = Key::OEM_4;\t// On US and UK keyboards this is the '[{' key\r\n\t\t\tmapKeys[XK_backslash] = Key::OEM_5;\t\t// On US keyboard this is '\\|' key.\r\n\t\t\tmapKeys[XK_bracketright] = Key::OEM_6;\t// On US and UK keyboards this is the ']}' key\r\n\t\t\tmapKeys[XK_apostrophe] = Key::OEM_7;\t// On US keyboard this is the single/double quote key. On UK, this is the single quote/@ symbol key\r\n\t\t\tmapKeys[XK_numbersign] = Key::OEM_8;\t// miscellaneous characters. Varies by keyboard. I believe this to be the '#~' key on UK keyboards\r\n\t\t\tmapKeys[XK_equal] = Key::EQUALS;\t\t// the '+' key on any keyboard\r\n\t\t\tmapKeys[XK_comma] = Key::COMMA;\t\t\t// the comma key on any keyboard\r\n\t\t\tmapKeys[XK_minus] = Key::MINUS;\t\t\t// the minus key on any keyboard\t\t\t\r\n\r\n\t\t\tmapKeys[XK_Caps_Lock] = Key::CAPS_LOCK;\r\n\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) override\r\n\t\t{\r\n\t\t\tX11::XStoreName(olc_Display, olc_Window, s.c_str());\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ShowWindowFrame(const bool bShowFrame = true) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\r\n\t\tvirtual olc::rcode StartSystemEventLoop() override\r\n\t\t{\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode HandleSystemEvent() override\r\n\t\t{\r\n\t\t\tusing namespace X11;\r\n\t\t\t// Handle Xlib Message Loop - we do this in the\r\n\t\t\t// same thread that OpenGL was created so we dont\r\n\t\t\t// need to worry too much about multithreading with X11\r\n\t\t\tXEvent xev;\r\n\t\t\twhile (XPending(olc_Display))\r\n\t\t\t{\r\n\t\t\t\tXNextEvent(olc_Display, &xev);\r\n\t\t\t\tif (xev.type == Expose)\r\n\t\t\t\t{\r\n\t\t\t\t\tXWindowAttributes gwa;\r\n\t\t\t\t\tXGetWindowAttributes(olc_Display, olc_Window, &gwa);\r\n\t\t\t\t\tptrPGE->olc_UpdateWindowSize(gwa.width, gwa.height);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == ConfigureNotify)\r\n\t\t\t\t{\r\n\t\t\t\t\tXConfigureEvent xce = xev.xconfigure;\r\n\t\t\t\t\tptrPGE->olc_UpdateWindowSize(xce.width, xce.height);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == KeyPress)\r\n\t\t\t\t{\r\n\t\t\t\t\tKeySym sym = XLookupKeysym(&xev.xkey, 0);\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[sym], true);\r\n\t\t\t\t\tXKeyEvent* e = (XKeyEvent*)&xev; // Because DragonEye loves numpads\r\n\t\t\t\t\tXLookupString(e, NULL, 0, &sym, NULL);\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[sym], true);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == KeyRelease)\r\n\t\t\t\t{\r\n\t\t\t\t\tKeySym sym = XLookupKeysym(&xev.xkey, 0);\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[sym], false);\r\n\t\t\t\t\tXKeyEvent* e = (XKeyEvent*)&xev;\r\n\t\t\t\t\tXLookupString(e, NULL, 0, &sym, NULL);\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[sym], false);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == ButtonPress)\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch (xev.xbutton.button)\r\n\t\t\t\t\t{\r\n\t\t\t\t\tcase 1:\tptrPGE->olc_UpdateMouseState(0, true); break;\r\n\t\t\t\t\tcase 2:\tptrPGE->olc_UpdateMouseState(2, true); break;\r\n\t\t\t\t\tcase 3:\tptrPGE->olc_UpdateMouseState(1, true); break;\r\n\t\t\t\t\tcase 4:\tptrPGE->olc_UpdateMouseWheel(120); break;\r\n\t\t\t\t\tcase 5:\tptrPGE->olc_UpdateMouseWheel(-120); break;\r\n\t\t\t\t\tdefault: break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == ButtonRelease)\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch (xev.xbutton.button)\r\n\t\t\t\t\t{\r\n\t\t\t\t\tcase 1:\tptrPGE->olc_UpdateMouseState(0, false); break;\r\n\t\t\t\t\tcase 2:\tptrPGE->olc_UpdateMouseState(2, false); break;\r\n\t\t\t\t\tcase 3:\tptrPGE->olc_UpdateMouseState(1, false); break;\r\n\t\t\t\t\tdefault: break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == MotionNotify)\r\n\t\t\t\t{\r\n\t\t\t\t\tptrPGE->olc_UpdateMouse(xev.xmotion.x, xev.xmotion.y);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == FocusIn)\r\n\t\t\t\t{\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyFocus(true);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == FocusOut)\r\n\t\t\t\t{\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyFocus(false);\r\n\t\t\t\t}\r\n\t\t\t\telse if (xev.type == ClientMessage)\r\n\t\t\t\t{\r\n\t\t\t\t\tptrPGE->olc_Terminate();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\t};\r\n}\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END PLATFORM: LINUX                                                          |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n#pragma region platform_glut\r\n// O------------------------------------------------------------------------------O\r\n// | START PLATFORM: GLUT (used to make it simple for Apple)                      |\r\n// O------------------------------------------------------------------------------O\r\n//\r\n// VERY IMPORTANT!!! The Apple port was originally created by @Mumflr (discord)\r\n// and the repo for the development of this project can be found here:\r\n// https://github.com/MumflrFumperdink/olcPGEMac which contains maccy goodness\r\n// and support on how to setup your build environment.\r\n//\r\n// \"MASSIVE MASSIVE THANKS TO MUMFLR\" - Javidx9\r\n#if defined(OLC_PLATFORM_GLUT)\r\nnamespace olc {\r\n\r\n\tclass Platform_GLUT : public olc::Platform\r\n\t{\r\n\tpublic:\r\n\t\tstatic std::atomic<bool>* bActiveRef;\r\n\r\n\t\tvirtual olc::rcode SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ShowWindowFrame(const bool bShowFrame = true) override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\r\n\t\tvirtual olc::rcode ApplicationStartUp() override {\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ApplicationCleanUp() override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ThreadStartUp() override\r\n\t\t{\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode ThreadCleanUp() override\r\n\t\t{\r\n\t\t\trenderer->DestroyDevice();\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) override\r\n\t\t{\r\n\t\t\tif (renderer->CreateDevice({}, bFullScreen, bEnableVSYNC) == olc::rcode::OK)\r\n\t\t\t{\r\n\t\t\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t\t\t\treturn olc::rcode::OK;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\treturn olc::rcode::FAIL;\r\n\t\t}\r\n\r\n\t\tstatic void ExitMainLoop() {\r\n\t\t\tif (!ptrPGE->OnUserDestroy()) {\r\n\t\t\t\t*bActiveRef = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tplatform->ThreadCleanUp();\r\n\t\t\tplatform->ApplicationCleanUp();\r\n\t\t\texit(0);\r\n\t\t}\r\n\r\n#if defined(__APPLE__)\r\n\t\tstatic void scrollWheelUpdate(id selff, SEL _sel, id theEvent) {\r\n\t\t\tstatic const SEL deltaYSel = sel_registerName(\"deltaY\");\r\n\r\n#if defined(__aarch64__) // Thanks ruarq!\r\n\t\t\tdouble deltaY = ((double (*)(id, SEL))objc_msgSend)(theEvent, deltaYSel);\r\n#else\r\n\t\t\tdouble deltaY = ((double (*)(id, SEL))objc_msgSend_fpret)(theEvent, deltaYSel);\r\n#endif\r\n\r\n\t\t\tfor (int i = 0; i < abs(deltaY); i++) {\r\n\t\t\t\tif (deltaY > 0) {\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseWheel(-1);\r\n\t\t\t\t}\r\n\t\t\t\telse if (deltaY < 0) {\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseWheel(1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n\t\tstatic void ThreadFunct() {\r\n#if defined(__APPLE__)\r\n\t\t\tstatic bool hasEnabledCocoa = false;\r\n\t\t\tif (!hasEnabledCocoa) {\r\n\t\t\t\t// Objective-C Wizardry\r\n\t\t\t\tClass NSApplicationClass = objc_getClass(\"NSApplication\");\r\n\r\n\t\t\t\t// NSApp = [NSApplication sharedApplication]\r\n\t\t\t\tSEL sharedApplicationSel = sel_registerName(\"sharedApplication\");\r\n\t\t\t\tid NSApp = ((id(*)(Class, SEL))objc_msgSend)(NSApplicationClass, sharedApplicationSel);\r\n\t\t\t\t// window = [NSApp mainWindow]\r\n\t\t\t\tSEL mainWindowSel = sel_registerName(\"mainWindow\");\r\n\t\t\t\tid window = ((id(*)(id, SEL))objc_msgSend)(NSApp, mainWindowSel);\r\n\r\n\t\t\t\t// [window setStyleMask: NSWindowStyleMaskClosable | ~NSWindowStyleMaskResizable]\r\n\t\t\t\tSEL setStyleMaskSel = sel_registerName(\"setStyleMask:\");\r\n\t\t\t\t((void (*)(id, SEL, NSUInteger))objc_msgSend)(window, setStyleMaskSel, 7);\r\n\r\n\t\t\t\thasEnabledCocoa = true;\r\n\t\t\t}\r\n#endif\r\n\t\t\tif (!*bActiveRef) {\r\n\t\t\t\tExitMainLoop();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tglutPostRedisplay();\r\n\t\t}\r\n\r\n\t\tstatic void DrawFunct() {\r\n\t\t\tptrPGE->olc_CoreUpdate();\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) override\r\n\t\t{\r\n#if defined(__APPLE__)\r\n\t\t\tClass GLUTViewClass = objc_getClass(\"GLUTView\");\r\n\r\n\t\t\tSEL scrollWheelSel = sel_registerName(\"scrollWheel:\");\r\n\t\t\tbool resultAddMethod = class_addMethod(GLUTViewClass, scrollWheelSel, (IMP)scrollWheelUpdate, \"v@:@\");\r\n\t\t\tassert(resultAddMethod);\r\n#endif\r\n\r\n\t\t\trenderer->PrepareDevice();\r\n\r\n\t\t\tif (bFullScreen)\r\n\t\t\t{\r\n\t\t\t\tvWindowSize.x = glutGet(GLUT_SCREEN_WIDTH);\r\n\t\t\t\tvWindowSize.y = glutGet(GLUT_SCREEN_HEIGHT);\r\n\t\t\t\tglutFullScreen();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (vWindowSize.x > glutGet(GLUT_SCREEN_WIDTH) || vWindowSize.y > glutGet(GLUT_SCREEN_HEIGHT))\r\n\t\t\t\t{\r\n\t\t\t\t\tperror(\"ERROR: The specified window dimensions do not fit on your screen\\n\");\r\n\t\t\t\t\treturn olc::FAIL;\r\n\t\t\t\t}\r\n\t\t\t\tglutReshapeWindow(vWindowSize.x, vWindowSize.y - 1);\r\n\t\t\t}\r\n\r\n\t\t\t// Create Keyboard Mapping\r\n\t\t\tmapKeys[0x00] = Key::NONE;\r\n\t\t\tmapKeys['A'] = Key::A; mapKeys['B'] = Key::B; mapKeys['C'] = Key::C; mapKeys['D'] = Key::D; mapKeys['E'] = Key::E;\r\n\t\t\tmapKeys['F'] = Key::F; mapKeys['G'] = Key::G; mapKeys['H'] = Key::H; mapKeys['I'] = Key::I; mapKeys['J'] = Key::J;\r\n\t\t\tmapKeys['K'] = Key::K; mapKeys['L'] = Key::L; mapKeys['M'] = Key::M; mapKeys['N'] = Key::N; mapKeys['O'] = Key::O;\r\n\t\t\tmapKeys['P'] = Key::P; mapKeys['Q'] = Key::Q; mapKeys['R'] = Key::R; mapKeys['S'] = Key::S; mapKeys['T'] = Key::T;\r\n\t\t\tmapKeys['U'] = Key::U; mapKeys['V'] = Key::V; mapKeys['W'] = Key::W; mapKeys['X'] = Key::X; mapKeys['Y'] = Key::Y;\r\n\t\t\tmapKeys['Z'] = Key::Z;\r\n\r\n\t\t\tmapKeys[GLUT_KEY_F1] = Key::F1; mapKeys[GLUT_KEY_F2] = Key::F2; mapKeys[GLUT_KEY_F3] = Key::F3; mapKeys[GLUT_KEY_F4] = Key::F4;\r\n\t\t\tmapKeys[GLUT_KEY_F5] = Key::F5; mapKeys[GLUT_KEY_F6] = Key::F6; mapKeys[GLUT_KEY_F7] = Key::F7; mapKeys[GLUT_KEY_F8] = Key::F8;\r\n\t\t\tmapKeys[GLUT_KEY_F9] = Key::F9; mapKeys[GLUT_KEY_F10] = Key::F10; mapKeys[GLUT_KEY_F11] = Key::F11; mapKeys[GLUT_KEY_F12] = Key::F12;\r\n\r\n\t\t\tmapKeys[GLUT_KEY_DOWN] = Key::DOWN; mapKeys[GLUT_KEY_LEFT] = Key::LEFT; mapKeys[GLUT_KEY_RIGHT] = Key::RIGHT; mapKeys[GLUT_KEY_UP] = Key::UP;\r\n\t\t\tmapKeys[13] = Key::ENTER;\r\n\r\n\t\t\tmapKeys[127] = Key::BACK; mapKeys[27] = Key::ESCAPE;\r\n\t\t\tmapKeys[9] = Key::TAB;  mapKeys[GLUT_KEY_HOME] = Key::HOME;\r\n\t\t\tmapKeys[GLUT_KEY_END] = Key::END; mapKeys[GLUT_KEY_PAGE_UP] = Key::PGUP; mapKeys[GLUT_KEY_PAGE_DOWN] = Key::PGDN;    mapKeys[GLUT_KEY_INSERT] = Key::INS;\r\n\t\t\tmapKeys[32] = Key::SPACE; mapKeys[46] = Key::PERIOD;\r\n\r\n\t\t\tmapKeys[48] = Key::K0; mapKeys[49] = Key::K1; mapKeys[50] = Key::K2; mapKeys[51] = Key::K3; mapKeys[52] = Key::K4;\r\n\t\t\tmapKeys[53] = Key::K5; mapKeys[54] = Key::K6; mapKeys[55] = Key::K7; mapKeys[56] = Key::K8; mapKeys[57] = Key::K9;\r\n\r\n\t\t\t// NOTE: MISSING KEYS :O\r\n\r\n\t\t\tglutKeyboardFunc([](unsigned char key, int x, int y) -> void {\r\n\t\t\t\tswitch (glutGetModifiers()) {\r\n\t\t\t\tcase 0: //This is when there are no modifiers\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_SHIFT:\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(Key::SHIFT, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_CTRL:\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(Key::CTRL, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_ALT:\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapKeys[key])\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[key], true);\r\n\t\t\t\t});\r\n\r\n\t\t\tglutKeyboardUpFunc([](unsigned char key, int x, int y) -> void {\r\n\t\t\t\tswitch (glutGetModifiers()) {\r\n\t\t\t\tcase 0: //This is when there are no modifiers\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_SHIFT:\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(Key::SHIFT, false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_CTRL:\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(Key::CTRL, false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_ACTIVE_ALT:\r\n\t\t\t\t\tif ('a' <= key && key <= 'z') key -= 32;\r\n\t\t\t\t\t//No ALT in PGE\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapKeys[key])\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[key], false);\r\n\t\t\t\t});\r\n\r\n\t\t\t//Special keys\r\n\t\t\tglutSpecialFunc([](int key, int x, int y) -> void {\r\n\t\t\t\tif (mapKeys[key])\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[key], true);\r\n\t\t\t\t});\r\n\r\n\t\t\tglutSpecialUpFunc([](int key, int x, int y) -> void {\r\n\t\t\t\tif (mapKeys[key])\r\n\t\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[key], false);\r\n\t\t\t\t});\r\n\r\n\t\t\tglutMouseFunc([](int button, int state, int x, int y) -> void {\r\n\t\t\t\tswitch (button) {\r\n\t\t\t\tcase GLUT_LEFT_BUTTON:\r\n\t\t\t\t\tif (state == GLUT_UP) ptrPGE->olc_UpdateMouseState(0, false);\r\n\t\t\t\t\telse if (state == GLUT_DOWN) ptrPGE->olc_UpdateMouseState(0, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_MIDDLE_BUTTON:\r\n\t\t\t\t\tif (state == GLUT_UP) ptrPGE->olc_UpdateMouseState(2, false);\r\n\t\t\t\t\telse if (state == GLUT_DOWN) ptrPGE->olc_UpdateMouseState(2, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GLUT_RIGHT_BUTTON:\r\n\t\t\t\t\tif (state == GLUT_UP) ptrPGE->olc_UpdateMouseState(1, false);\r\n\t\t\t\t\telse if (state == GLUT_DOWN) ptrPGE->olc_UpdateMouseState(1, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\tauto mouseMoveCall = [](int x, int y) -> void {\r\n\t\t\t\tptrPGE->olc_UpdateMouse(x, y);\r\n\t\t\t};\r\n\r\n\t\t\tglutMotionFunc(mouseMoveCall);\r\n\t\t\tglutPassiveMotionFunc(mouseMoveCall);\r\n\r\n\t\t\tglutEntryFunc([](int state) -> void {\r\n\t\t\t\tif (state == GLUT_ENTERED) ptrPGE->olc_UpdateKeyFocus(true);\r\n\t\t\t\telse if (state == GLUT_LEFT) ptrPGE->olc_UpdateKeyFocus(false);\r\n\t\t\t\t});\r\n\r\n\t\t\tglutDisplayFunc(DrawFunct);\r\n\t\t\tglutIdleFunc(ThreadFunct);\r\n\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) override\r\n\t\t{\r\n\t\t\tglutSetWindowTitle(s.c_str());\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode StartSystemEventLoop() override {\r\n\t\t\tglutMainLoop();\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode HandleSystemEvent() override\r\n\t\t{\r\n\t\t\treturn olc::OK;\r\n\t\t}\r\n\t};\r\n\r\n\tstd::atomic<bool>* Platform_GLUT::bActiveRef{ nullptr };\r\n\r\n\t//Custom Start\r\n\tolc::rcode PixelGameEngine::Start()\r\n\t{\r\n\t\tif (platform->ApplicationStartUp() != olc::OK) return olc::FAIL;\r\n\r\n\t\t// Construct the window\r\n\t\tif (platform->CreateWindowPane({ 30,30 }, vWindowSize, bFullScreen) != olc::OK) return olc::FAIL;\r\n\t\tolc_UpdateWindowSize(vWindowSize.x, vWindowSize.y);\r\n\r\n\t\tif (platform->ThreadStartUp() == olc::FAIL)  return olc::FAIL;\r\n\t\tolc_PrepareEngine();\r\n\t\tif (!OnUserCreate()) return olc::FAIL;\r\n\t\tPlatform_GLUT::bActiveRef = &bAtomActive;\r\n\t\tglutWMCloseFunc(Platform_GLUT::ExitMainLoop);\r\n\t\tbAtomActive = true;\r\n\t\tplatform->StartSystemEventLoop();\r\n\r\n\t\t//This code will not even be run but why not\r\n\t\tif (platform->ApplicationCleanUp() != olc::OK) return olc::FAIL;\r\n\r\n\t\treturn olc::OK;\r\n\t}\r\n}\r\n\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END PLATFORM: GLUT                                                           |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion \r\n\r\n\r\n\r\n\r\n\r\n#pragma region platform_emscripten\r\n// O------------------------------------------------------------------------------O\r\n// | START PLATFORM: Emscripten - Totally Game Changing...                        |\r\n// O------------------------------------------------------------------------------O\r\n\r\n//\r\n//\tFirstly a big mega thank you to members of the OLC Community for sorting this \r\n//\tout. Making a browser compatible version has been a priority for quite some\r\n//\ttime, but I lacked the expertise to do it. This awesome feature is possible\r\n//\tbecause a group of former strangers got together and formed friendships over\r\n//\ttheir shared passion for code. If anything demonstrates how powerful helping\r\n//\teach other can be, it's this. - Javidx9\r\n\r\n//\tEmscripten Platform: MaGetzUb, Moros1138, Slavka, Dandistine, Gorbit99, Bispoo\r\n//\t\t\t\t   also: Ishidex, Gusgo99, SlicEnDicE, Alexio\r\n\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\r\n#include <emscripten/html5.h>\r\n#include <emscripten/key_codes.h>\r\n\r\nextern \"C\" \r\n{\r\n\tEMSCRIPTEN_KEEPALIVE inline int olc_OnPageUnload()\r\n\t{ olc::platform->ApplicationCleanUp(); return 0; }\r\n}\r\n\r\nnamespace olc\r\n{\r\n\tclass Platform_Emscripten : public olc::Platform\r\n\t{\r\n\tpublic:\r\n\r\n\t\tvirtual olc::rcode SetWindowSize(const olc::vi2d& vPos, const olc::vi2d& vSize) override\r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ShowWindowFrame(const bool bShowFrame = true) override\r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ApplicationStartUp() override \r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ApplicationCleanUp() override \r\n\t\t{ ThreadCleanUp(); return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ThreadStartUp() override\r\n\t\t{ return olc::rcode::OK; }\r\n\r\n\t\tvirtual olc::rcode ThreadCleanUp() override\r\n\t\t{ renderer->DestroyDevice(); return olc::OK; }\r\n\r\n\t\tvirtual olc::rcode CreateGraphics(bool bFullScreen, bool bEnableVSYNC, const olc::vi2d& vViewPos, const olc::vi2d& vViewSize) override\r\n\t\t{\r\n\t\t\tif (renderer->CreateDevice({}, bFullScreen, bEnableVSYNC) == olc::rcode::OK)\r\n\t\t\t{\r\n\t\t\t\trenderer->UpdateViewport(vViewPos, vViewSize);\r\n\t\t\t\treturn olc::rcode::OK;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\treturn olc::rcode::FAIL;\r\n\t\t}\r\n\r\n\t\tvirtual olc::rcode CreateWindowPane(const olc::vi2d& vWindowPos, olc::vi2d& vWindowSize, bool bFullScreen) override\r\n\t\t{\r\n\t\t\temscripten_set_canvas_element_size(\"#canvas\", vWindowSize.x, vWindowSize.y);\r\n\r\n\t\t\tmapKeys[DOM_PK_UNKNOWN] = Key::NONE;\r\n\t\t\tmapKeys[DOM_PK_A] = Key::A; mapKeys[DOM_PK_B] = Key::B; mapKeys[DOM_PK_C] = Key::C; mapKeys[DOM_PK_D] = Key::D;\r\n\t\t\tmapKeys[DOM_PK_E] = Key::E; mapKeys[DOM_PK_F] = Key::F; mapKeys[DOM_PK_G] = Key::G; mapKeys[DOM_PK_H] = Key::H;\r\n\t\t\tmapKeys[DOM_PK_I] = Key::I; mapKeys[DOM_PK_J] = Key::J; mapKeys[DOM_PK_K] = Key::K; mapKeys[DOM_PK_L] = Key::L;\r\n\t\t\tmapKeys[DOM_PK_M] = Key::M; mapKeys[DOM_PK_N] = Key::N; mapKeys[DOM_PK_O] = Key::O; mapKeys[DOM_PK_P] = Key::P;\r\n\t\t\tmapKeys[DOM_PK_Q] = Key::Q; mapKeys[DOM_PK_R] = Key::R; mapKeys[DOM_PK_S] = Key::S; mapKeys[DOM_PK_T] = Key::T;\r\n\t\t\tmapKeys[DOM_PK_U] = Key::U; mapKeys[DOM_PK_V] = Key::V; mapKeys[DOM_PK_W] = Key::W; mapKeys[DOM_PK_X] = Key::X;\r\n\t\t\tmapKeys[DOM_PK_Y] = Key::Y; mapKeys[DOM_PK_Z] = Key::Z;\r\n\t\t\tmapKeys[DOM_PK_0] = Key::K0; mapKeys[DOM_PK_1] = Key::K1; mapKeys[DOM_PK_2] = Key::K2;\r\n\t\t\tmapKeys[DOM_PK_3] = Key::K3; mapKeys[DOM_PK_4] = Key::K4; mapKeys[DOM_PK_5] = Key::K5;\r\n\t\t\tmapKeys[DOM_PK_6] = Key::K6; mapKeys[DOM_PK_7] = Key::K7; mapKeys[DOM_PK_8] = Key::K8;\r\n\t\t\tmapKeys[DOM_PK_9] = Key::K9;\r\n\t\t\tmapKeys[DOM_PK_F1] = Key::F1; mapKeys[DOM_PK_F2] = Key::F2; mapKeys[DOM_PK_F3] = Key::F3; mapKeys[DOM_PK_F4] = Key::F4;\r\n\t\t\tmapKeys[DOM_PK_F5] = Key::F5; mapKeys[DOM_PK_F6] = Key::F6; mapKeys[DOM_PK_F7] = Key::F7; mapKeys[DOM_PK_F8] = Key::F8;\r\n\t\t\tmapKeys[DOM_PK_F9] = Key::F9; mapKeys[DOM_PK_F10] = Key::F10; mapKeys[DOM_PK_F11] = Key::F11; mapKeys[DOM_PK_F12] = Key::F12;\r\n\t\t\tmapKeys[DOM_PK_ARROW_UP] = Key::UP; mapKeys[DOM_PK_ARROW_DOWN] = Key::DOWN;\r\n\t\t\tmapKeys[DOM_PK_ARROW_LEFT] = Key::LEFT; mapKeys[DOM_PK_ARROW_RIGHT] = Key::RIGHT;\r\n\t\t\tmapKeys[DOM_PK_SPACE] = Key::SPACE; mapKeys[DOM_PK_TAB] = Key::TAB;\r\n\t\t\tmapKeys[DOM_PK_SHIFT_LEFT] = Key::SHIFT; mapKeys[DOM_PK_SHIFT_RIGHT] = Key::SHIFT;\r\n\t\t\tmapKeys[DOM_PK_CONTROL_LEFT] = Key::CTRL; mapKeys[DOM_PK_CONTROL_RIGHT] = Key::CTRL;\r\n\t\t\tmapKeys[DOM_PK_INSERT] = Key::INS; mapKeys[DOM_PK_DELETE] = Key::DEL; mapKeys[DOM_PK_HOME] = Key::HOME;\r\n\t\t\tmapKeys[DOM_PK_END] = Key::END; mapKeys[DOM_PK_PAGE_UP] = Key::PGUP; mapKeys[DOM_PK_PAGE_DOWN] = Key::PGDN;\r\n\t\t\tmapKeys[DOM_PK_BACKSPACE] = Key::BACK; mapKeys[DOM_PK_ESCAPE] = Key::ESCAPE;\r\n\t\t\tmapKeys[DOM_PK_ENTER] = Key::ENTER; mapKeys[DOM_PK_NUMPAD_EQUAL] = Key::EQUALS;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_ENTER] = Key::ENTER; mapKeys[DOM_PK_PAUSE] = Key::PAUSE;\r\n\t\t\tmapKeys[DOM_PK_SCROLL_LOCK] = Key::SCROLL;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_0] = Key::NP0; mapKeys[DOM_PK_NUMPAD_1] = Key::NP1; mapKeys[DOM_PK_NUMPAD_2] = Key::NP2;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_3] = Key::NP3; mapKeys[DOM_PK_NUMPAD_4] = Key::NP4; mapKeys[DOM_PK_NUMPAD_5] = Key::NP5;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_6] = Key::NP6; mapKeys[DOM_PK_NUMPAD_7] = Key::NP7; mapKeys[DOM_PK_NUMPAD_8] = Key::NP8;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_9] = Key::NP9;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_MULTIPLY] = Key::NP_MUL; mapKeys[DOM_PK_NUMPAD_DIVIDE] = Key::NP_DIV;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_ADD] = Key::NP_ADD; mapKeys[DOM_PK_NUMPAD_SUBTRACT] = Key::NP_SUB;\r\n\t\t\tmapKeys[DOM_PK_NUMPAD_DECIMAL] = Key::NP_DECIMAL;\r\n\t\t\tmapKeys[DOM_PK_PERIOD] = Key::PERIOD; mapKeys[DOM_PK_EQUAL] = Key::EQUALS;\r\n\t\t\tmapKeys[DOM_PK_COMMA] = Key::COMMA; mapKeys[DOM_PK_MINUS] = Key::MINUS;\r\n\t\t\tmapKeys[DOM_PK_CAPS_LOCK] = Key::CAPS_LOCK;\r\n\t\t\tmapKeys[DOM_PK_SEMICOLON] = Key::OEM_1;\tmapKeys[DOM_PK_SLASH] = Key::OEM_2; mapKeys[DOM_PK_BACKQUOTE] = Key::OEM_3;\r\n\t\t\tmapKeys[DOM_PK_BRACKET_LEFT] = Key::OEM_4; mapKeys[DOM_PK_BACKSLASH] = Key::OEM_5; mapKeys[DOM_PK_BRACKET_RIGHT] = Key::OEM_6;\r\n\t\t\tmapKeys[DOM_PK_QUOTE] = Key::OEM_7; mapKeys[DOM_PK_BACKSLASH] = Key::OEM_8;\r\n\r\n\t\t\t// Keyboard Callbacks\r\n\t\t\temscripten_set_keydown_callback(\"#canvas\", 0, 1, keyboard_callback);\r\n\t\t\temscripten_set_keyup_callback(\"#canvas\", 0, 1, keyboard_callback);\r\n\r\n\t\t\t// Mouse Callbacks\r\n\t\t\temscripten_set_wheel_callback(\"#canvas\", 0, 1, wheel_callback);\r\n\t\t\temscripten_set_mousedown_callback(\"#canvas\", 0, 1, mouse_callback);\r\n\t\t\temscripten_set_mouseup_callback(\"#canvas\", 0, 1, mouse_callback);\r\n\t\t\temscripten_set_mousemove_callback(\"#canvas\", 0, 1, mouse_callback);\r\n\r\n\t\t\t// Touch Callbacks\r\n\t\t\temscripten_set_touchstart_callback(\"#canvas\", 0, 1, touch_callback);\r\n\t\t\temscripten_set_touchmove_callback(\"#canvas\", 0, 1, touch_callback);\r\n\t\t\temscripten_set_touchend_callback(\"#canvas\", 0, 1, touch_callback);\r\n\r\n\t\t\t// Canvas Focus Callbacks\r\n\t\t\temscripten_set_blur_callback(\"#canvas\", 0, 1, focus_callback);\r\n\t\t\temscripten_set_focus_callback(\"#canvas\", 0, 1, focus_callback);\r\n\t\t\t\r\n#pragma warning disable format\r\n\t\t\tEM_ASM( window.onunload = Module._olc_OnPageUnload; );\r\n\r\n\t\t\t// IMPORTANT! - Sorry About This...\r\n\t\t\t//\r\n\t\t\t//\tIn order to handle certain browser based events, such as resizing and\r\n\t\t\t//\tgoing to full screen, we have to effectively inject code into the container\r\n\t\t\t//\trunning the PGE. Yes, I vomited about 11 times too when the others were\r\n\t\t\t//\tconvincing me this is the future. Well, this isnt the future, and if it\r\n\t\t\t//\twere to be, I want no part of what must be a miserable distopian free\r\n\t\t\t//\tfor all of anarchic code injection to get rudimentary events like \"Resize()\".\r\n\t\t\t//\r\n\t\t\t//\tWake up people! Of course theres a spoon. There has to be to keep feeding\r\n\t\t\t//\tthe giant web baby.\r\n\t\t\t\r\n\r\n\t\t\tEM_ASM({\r\n\r\n\t\t\t// olc_ApsectRatio\r\n\t\t\t// \r\n\t\t\t// Used by olc_ResizeHandler to calculate the viewport from the\r\n\t\t\t// dimensions of the canvas container's element.\r\n\t\t\tModule.olc_AspectRatio = $0 / $1;\r\n\r\n\t\t\t// HACK ALERT!\r\n\t\t\t// \r\n\t\t\t// Here we assume any html shell that uses 3 or more instance of the class \"emscripten\"\r\n\t\t\t// is using one of the default or minimal emscripten page layouts\r\n\t\t\tModule.olc_AssumeDefaultShells = (document.querySelectorAll('.emscripten').length >= 3) ? true : false;\r\n\r\n\t\t\t// olc_ResizeHandler\r\n\t\t\t// \r\n\t\t\t// Used by olc_Init, and is called when a resize observer and fullscreenchange event is triggered.\r\n\t\t\tvar olc_ResizeHandler = function()\r\n\t\t\t{\r\n\t\t\t\t// are we in fullscreen mode?\r\n\t\t\t\tlet isFullscreen = (document.fullscreenElement != null);\r\n\r\n\t\t\t\t// get the width of the containing element\r\n\t\t\t\tlet width  = (isFullscreen) ? window.innerWidth  : Module.canvas.parentNode.clientWidth;\r\n\t\t\t\tlet height = (isFullscreen) ? window.innerHeight : Module.canvas.parentNode.clientHeight;\r\n\r\n\t\t\t\t// calculate the expected viewport size\r\n\t\t\t\tlet viewWidth  = width;\r\n\t\t\t\tlet viewHeight = width / Module.olc_AspectRatio;\r\n\r\n\t\t\t\t// if we're taller than the containing element, recalculate based on height\r\n\t\t\t\tif(viewHeight > height)\r\n\t\t\t\t{\r\n\t\t\t\t\tviewWidth  = height * Module.olc_AspectRatio;\r\n\t\t\t\t\tviewHeight = height;\r\n\t\t\t\t}\r\n    \r\n\t\t\t\t// ensure resulting viewport is in integer space\r\n\t\t\t\tviewWidth  = parseInt(viewWidth);\r\n\t\t\t\tviewHeight = parseInt(viewHeight);\r\n\r\n\t\t\t\tsetTimeout(function()\r\n\t\t\t\t{\r\n\t\t\t\t\t// if default shells, apply default styles\r\n\t\t\t\t\tif(Module.olc_AssumeDefaultShells)\r\n\t\t\t\t\t\tModule.canvas.parentNode.setAttribute('style', 'width: 100%; height: 70vh; margin-left: auto; margin-right: auto;');\r\n\t\t\t\t\r\n\t\t\t\t\t// apply viewport dimensions to teh canvas\r\n\t\t\t\t\tModule.canvas.setAttribute('width', viewWidth);\r\n\t\t\t\t\tModule.canvas.setAttribute('height', viewHeight);\r\n\t\t\t\t\tModule.canvas.setAttribute('style', `width: ${viewWidth}px; height: ${viewHeight}px;`);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update the PGE window size\r\n\t\t\t\t\tModule._olc_PGE_UpdateWindowSize(viewWidth, viewHeight);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// force focus on our PGE canvas\r\n\t\t\t\t\tModule.canvas.focus();\r\n\t\t\t\t}, 200);\r\n\t\t\t};\r\n\r\n\t\t\t\r\n\t\t\t// olc_Init\r\n\t\t\t// \r\n\t\t\t// set up resize observer and fullscreenchange event handler\r\n\t\t\tvar olc_Init = function()\r\n\t\t\t{\r\n\t\t\t\tif(Module.olc_AspectRatio === undefined)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetTimeout(function() { Module.olc_Init(); }, 50);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\tlet resizeObserver = new ResizeObserver(function(entries)\r\n\t\t\t\t{\r\n\t\t\t\t\tModule.olc_ResizeHandler();\r\n\t\t\t\t}).observe(Module.canvas.parentNode);\r\n\r\n\t\t\t\tlet mutationObserver = new MutationObserver(function(mutationsList, observer)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetTimeout(function() { Module.olc_ResizeHandler(); },  200);\r\n\t\t\t\t}).observe(Module.canvas.parentNode, { attributes: false, childList: true, subtree: false });\r\n\r\n\t\t\t\twindow.addEventListener('fullscreenchange', function(e)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetTimeout(function() { Module.olc_ResizeHandler();},  200);\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// set up hooks\r\n\t\t\tModule.olc_ResizeHandler = (Module.olc_ResizeHandler != undefined) ? Module.olc_ResizeHandler : olc_ResizeHandler;\r\n\t\t\tModule.olc_Init          = (Module.olc_Init          != undefined) ? Module.olc_Init : olc_Init;\r\n\r\n\t\t\t// run everything!\r\n\t\t\tModule.olc_Init();\r\n\r\n\t\t\t}, vWindowSize.x, vWindowSize.y); // Fullscreen and Resize Observers\r\n#pragma warning restore format\r\n\t\t\treturn olc::rcode::OK;\r\n\t\t}\r\n\r\n\t\t// Interface PGE's UpdateWindowSize, for use in Javascript\r\n\t\tvoid UpdateWindowSize(int width, int height)\r\n\t\t{\r\n\t\t\tptrPGE->olc_UpdateWindowSize(width, height);\r\n\t\t}\r\n\r\n\t\t//TY Gorbit\r\n\t\tstatic EM_BOOL focus_callback(int eventType, const EmscriptenFocusEvent* focusEvent, void* userData) \r\n\t\t{\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_BLUR)\r\n\t\t\t{\r\n\t\t\t\tptrPGE->olc_UpdateKeyFocus(false);\r\n\t\t\t\tptrPGE->olc_UpdateMouseFocus(false);\r\n\t\t\t}\r\n\t\t\telse if (eventType == EMSCRIPTEN_EVENT_FOCUS)\r\n\t\t\t{\r\n\t\t\t\tptrPGE->olc_UpdateKeyFocus(true);\r\n\t\t\t\tptrPGE->olc_UpdateMouseFocus(true);\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t//TY Moros\r\n\t\tstatic EM_BOOL keyboard_callback(int eventType, const EmscriptenKeyboardEvent* e, void* userData)\r\n\t\t{\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_KEYDOWN)\r\n\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[emscripten_compute_dom_pk_code(e->code)], true);\r\n\r\n\t\t\t// THANK GOD!! for this compute function. And thanks Dandistine for pointing it out!\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_KEYUP)\r\n\t\t\t\tptrPGE->olc_UpdateKeyState(mapKeys[emscripten_compute_dom_pk_code(e->code)], false);\r\n\r\n\t\t\t//Consume keyboard events so that keys like F1 and F5 don't do weird things\r\n\t\t\treturn EM_TRUE;\r\n\t\t}\r\n\r\n\t\t//TY Moros\r\n\t\tstatic EM_BOOL wheel_callback(int eventType, const EmscriptenWheelEvent* e, void* userData)\r\n\t\t{\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_WHEEL)\r\n\t\t\t\tptrPGE->olc_UpdateMouseWheel(-1 * e->deltaY);\r\n\r\n\t\t\treturn EM_TRUE;\r\n\t\t}\r\n\r\n\t\t//TY Bispoo\r\n\t\tstatic EM_BOOL touch_callback(int eventType, const EmscriptenTouchEvent* e, void* userData)\r\n\t\t{\r\n\t\t\t// Move\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE)\r\n\t\t\t{\r\n\t\t\t\tptrPGE->olc_UpdateMouse(e->touches->targetX, e->touches->targetY);\r\n\t\t\t}\r\n\r\n\t\t\t// Start\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_TOUCHSTART)\r\n\t\t\t{\r\n\t\t\t\tptrPGE->olc_UpdateMouse(e->touches->targetX, e->touches->targetY);\r\n\t\t\t\tptrPGE->olc_UpdateMouseState(0, true);\r\n\t\t\t}\r\n\r\n\t\t\t// End\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_TOUCHEND)\r\n\t\t\t{\r\n\t\t\t\tptrPGE->olc_UpdateMouseState(0, false);\r\n\t\t\t}\r\n\r\n\t\t\treturn EM_TRUE;\r\n\t\t}\r\n\r\n\t\t//TY Moros\r\n\t\tstatic EM_BOOL mouse_callback(int eventType, const EmscriptenMouseEvent* e, void* userData)\r\n\t\t{\r\n\t\t\t//Mouse Movement\r\n\t\t\tif (eventType == EMSCRIPTEN_EVENT_MOUSEMOVE)\r\n\t\t\t\tptrPGE->olc_UpdateMouse(e->targetX, e->targetY);\r\n\r\n\r\n\t\t\t//Mouse button press\r\n\t\t\tif (e->button == 0) // left click\r\n\t\t\t{\r\n\t\t\t\tif (eventType == EMSCRIPTEN_EVENT_MOUSEDOWN)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(0, true);\r\n\t\t\t\telse if (eventType == EMSCRIPTEN_EVENT_MOUSEUP)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(0, false);\r\n\t\t\t}\r\n\r\n\t\t\tif (e->button == 2) // right click\r\n\t\t\t{\r\n\t\t\t\tif (eventType == EMSCRIPTEN_EVENT_MOUSEDOWN)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(1, true);\r\n\t\t\t\telse if (eventType == EMSCRIPTEN_EVENT_MOUSEUP)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(1, false);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (e->button == 1) // middle click\r\n\t\t\t{\r\n\t\t\t\tif (eventType == EMSCRIPTEN_EVENT_MOUSEDOWN)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(2, true);\r\n\t\t\t\telse if (eventType == EMSCRIPTEN_EVENT_MOUSEUP)\r\n\t\t\t\t\tptrPGE->olc_UpdateMouseState(2, false);\r\n\r\n\t\t\t\t//at the moment only middle mouse needs to consume events.\r\n\t\t\t\treturn EM_TRUE;\r\n\t\t\t}\r\n\r\n\t\t\treturn EM_FALSE;\r\n\t\t}\r\n\r\n\r\n\t\tvirtual olc::rcode SetWindowTitle(const std::string& s) override\r\n\t\t{ emscripten_set_window_title(s.c_str()); return olc::OK; }\r\n\r\n\t\tvirtual olc::rcode StartSystemEventLoop() override \r\n\t\t{ return olc::OK; }\r\n\r\n\t\tvirtual olc::rcode HandleSystemEvent() override\r\n\t\t{ return olc::OK; }\r\n\r\n\t\tstatic void MainLoop()\r\n\t\t{\r\n\t\t\tolc::Platform::ptrPGE->olc_CoreUpdate();\r\n\t\t\tif (!ptrPGE->olc_IsRunning())\r\n\t\t\t{\r\n\t\t\t\tif (ptrPGE->OnUserDestroy())\r\n\t\t\t\t{\r\n\t\t\t\t\temscripten_cancel_main_loop();\r\n\t\t\t\t\tplatform->ApplicationCleanUp();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tptrPGE->olc_Reanimate();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t//Emscripten needs a special Start function\r\n\t//Much of this is usually done in EngineThread, but that isn't used here\r\n\tolc::rcode PixelGameEngine::Start()\r\n\t{\r\n\t\tif (platform->ApplicationStartUp() != olc::OK) return olc::FAIL;\r\n\r\n\t\t// Construct the window\r\n\t\tif (platform->CreateWindowPane({ 30,30 }, vWindowSize, bFullScreen) != olc::OK) return olc::FAIL;\r\n\t\tolc_UpdateWindowSize(vWindowSize.x, vWindowSize.y);\r\n\r\n\t\t// Some implementations may form an event loop here\r\n\t\tif (platform->ThreadStartUp() == olc::FAIL)\treturn olc::FAIL;\r\n\r\n\t\t// Do engine context specific initialisation\r\n\t\tolc_PrepareEngine();\r\n\r\n\t\t// Consider the \"thread\" started\r\n\t\tbAtomActive = true;\r\n\r\n\t\t// Create user resources as part of this thread\r\n\t\tfor (auto& ext : vExtensions) ext->OnBeforeUserCreate();\r\n\t\tif (!OnUserCreate()) bAtomActive = false;\r\n\t\tfor (auto& ext : vExtensions) ext->OnAfterUserCreate();\r\n\r\n\t\tplatform->StartSystemEventLoop();\r\n\r\n\t\t//This causes a heap memory corruption in Emscripten for some reason\r\n\t\t//Platform_Emscripten::bActiveRef = &bAtomActive;\r\n\t\temscripten_set_main_loop(&Platform_Emscripten::MainLoop, 0, 1);\r\n\r\n\t\t// Wait for thread to be exited\r\n\t\tif (platform->ApplicationCleanUp() != olc::OK) return olc::FAIL;\r\n\t\treturn olc::OK;\r\n\t}\r\n}\r\n\r\nextern \"C\" \r\n{\r\n\tEMSCRIPTEN_KEEPALIVE inline void olc_PGE_UpdateWindowSize(int width, int height)\r\n\t{\r\n\t\temscripten_set_canvas_element_size(\"#canvas\", width, height);\r\n\t\t// Thanks slavka\r\n\t\t((olc::Platform_Emscripten*)olc::platform.get())->UpdateWindowSize(width, height);\r\n\t}\r\n}\r\n\r\n#endif\r\n// O------------------------------------------------------------------------------O\r\n// | END PLATFORM: Emscripten                                                     |\r\n// O------------------------------------------------------------------------------O\r\n#pragma endregion\r\n\r\n\r\n#endif // Headless\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | olcPixelGameEngine Auto-Configuration                                        |\r\n// O------------------------------------------------------------------------------O\r\n#pragma region pge_config\r\nnamespace olc\r\n{\r\n\tvoid PixelGameEngine::olc_ConfigureSystem()\r\n\t{\r\n\r\n//#if !defined(OLC_PGE_HEADLESS)\r\n\r\n\t\tolc::Sprite::loader = nullptr;\r\n\r\n#if defined(OLC_IMAGE_GDI)\r\n\t\tolc::Sprite::loader = std::make_unique<olc::ImageLoader_GDIPlus>();\r\n#endif\r\n\r\n#if defined(OLC_IMAGE_LIBPNG)\r\n\t\tolc::Sprite::loader = std::make_unique<olc::ImageLoader_LibPNG>();\r\n#endif\r\n\r\n#if defined(OLC_IMAGE_STB)\r\n\t\tolc::Sprite::loader = std::make_unique<olc::ImageLoader_STB>();\r\n#endif\r\n\r\n#if defined(OLC_IMAGE_CUSTOM_EX)\r\n\t\tolc::Sprite::loader = std::make_unique<OLC_IMAGE_CUSTOM_EX>();\r\n#endif\r\n\r\n\r\n#if defined(OLC_PLATFORM_HEADLESS)\r\n\t\tplatform = std::make_unique<olc::Platform_Headless>();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_WINAPI)\r\n\t\tplatform = std::make_unique<olc::Platform_Windows>();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_X11)\r\n\t\tplatform = std::make_unique<olc::Platform_Linux>();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_GLUT)\r\n\t\tplatform = std::make_unique<olc::Platform_GLUT>();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_EMSCRIPTEN)\r\n\t\tplatform = std::make_unique<olc::Platform_Emscripten>();\r\n#endif\r\n\r\n#if defined(OLC_PLATFORM_CUSTOM_EX)\r\n\t\tplatform = std::make_unique<OLC_PLATFORM_CUSTOM_EX>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_HEADLESS)\r\n\t\trenderer = std::make_unique<olc::Renderer_Headless>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_OPENGL10)\r\n\t\trenderer = std::make_unique<olc::Renderer_OGL10>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_OPENGL33)\r\n\t\trenderer = std::make_unique<olc::Renderer_OGL33>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_OPENGLES2)\r\n\t\trenderer = std::make_unique<olc::Renderer_OGLES2>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_DIRECTX10)\r\n\t\trenderer = std::make_unique<olc::Renderer_DX10>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_DIRECTX11)\r\n\t\trenderer = std::make_unique<olc::Renderer_DX11>();\r\n#endif\r\n\r\n#if defined(OLC_GFX_CUSTOM_EX)\r\n\t\trenderer = std::make_unique<OLC_RENDERER_CUSTOM_EX>();\r\n#endif\r\n\r\n\t\t// Associate components with PGE instance\r\n\t\tplatform->ptrPGE = this;\r\n\t\trenderer->ptrPGE = this;\r\n//#else\r\n//\t\tolc::Sprite::loader = nullptr;\r\n//\t\tplatform = nullptr;\r\n//\t\trenderer = nullptr;\r\n//#endif\r\n\t}\r\n}\r\n\r\n#pragma endregion\r\n\r\n#endif // End OLC_PGE_APPLICATION\r\n\r\n// O------------------------------------------------------------------------------O\r\n// | END OF OLC_PGE_APPLICATION                                                   |\r\n// O------------------------------------------------------------------------------O\r\n\r\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "utilities",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}