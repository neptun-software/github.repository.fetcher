{
  "metadata": {
    "timestamp": 1736565501076,
    "page": 366,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PlatformLab/NanoLog",
      "stars": 3067,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0556640625,
          "content": ".idea/\nCMakeLists.txt\ncmake-build-debug/\nmake-all.sh\n\n._*"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.08984375,
          "content": "[submodule \"googletest\"]\n\tpath = googletest\n\turl = https://github.com/google/googletest.git\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7333984375,
          "content": "ISC License\n\nCopyright (c) 2016-2018 Stanford University\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "NanoLogMakeFrag",
          "type": "blob",
          "size": 3.783203125,
          "content": "########\n## This file expresses the rules required to compile with Preprocessor NanoLog.\n## It defines a macro (run-cxx) to preprocess and compile user source files,\n## and the rules required to build the NanoLog library.\n##\n## Users are expected to:\n##\t 1) Define the macro NANOLOG_DIR to point to the NanoLog directory\n##      and the macro USER_OBJS to list all *.o to be produced by the\n##      user executing run-cxx on their source files.\n##\t 2) Use run-cxx to compile their sources (see documentation below)\n##   3) Add the following variable definition in their sources\n##\t\t\t\t\tEXTRA_NANOLOG_FLAGS=-DPREPROCESSOR_NANOLOG\n##   4) Include this MakeFrag in their main GNUmakefile\n##\n## The sample_preprocessor/GNUmakefile shows an example of the integration.\n#######\n\nRUNTIME_DIR=$(NANOLOG_DIR)/runtime\nPREPROC_DIR=$(NANOLOG_DIR)/preprocessor\n\n# run-cxx:\n# Compile a user C++ source file to an object file using the NanoLog system.\n# The first parameter $(1) should be the output filename (*.o)\n# The second parameter $(2) should be the input filename (*.cc)\n# The optional third parameter $(3) should be additional options compiler options.\n# The optional fourth parameter ($4) should be gnu preprocessor options.\ndefine run-cxx\n\t$(CXX) -E -I $(RUNTIME_DIR) $(2) -o $(2).i -std=c++11 $(4)\n\t@mkdir -p generated\n\tpython $(PREPROC_DIR)/parser.py --mapOutput=\"generated/$(2).map\" $(2).i\n\t$(CXX) -I $(RUNTIME_DIR) -c -o $(1) $(2).ii $(3)\n\t@rm -f $(2).i $(2).ii generated/GeneratedCode.cc\nendef\n\nRUNTIME_CXX_FLAGS= -std=c++11 -O3 -DNDEBUG -g\nNANO_LOG_LIBRARY_LIBS=-lrt -pthread\n\nCOMWARNS := -Wall -Wformat=2 -Wextra \\\n           -Wwrite-strings -Wno-unused-parameter -Wmissing-format-attribute\nCWARNS   := $(COMWARNS) -Wmissing-prototypes -Wmissing-declarations -Wshadow \\\n\t\t-Wbad-function-cast\nCXXWARNS := $(COMWARNS) -Wno-non-template-friend -Woverloaded-virtual \\\n\t\t-Wcast-qual -Wcast-align -Wno-address-of-packed-member -Wconversion -Weffc++\n\nLIB_SRCFILES=Cycles.cc NanoLog.cc Util.cc Log.cc RuntimeLogger.cc TimeTrace.cc\nRUNTIME_CC=$(addprefix $(RUNTIME_DIR)/,$(LIB_SRCFILES))\nRUNTIME_OBJS=$(addprefix generated/library/, $(LIB_SRCFILES:.cc=.o))\n\n.PHONY: all\nall:\n\n# Collates the metadata generated by run-cxx and constructs a generated source\n# file and its object file\ngenerated/GeneratedCode.o: $(USER_OBJS)\n\t@mkdir -p generated\n\tpython $(PREPROC_DIR)/parser.py --combinedOutput=\"generated/GeneratedCode.cc\" $(shell find generated -type f -name \"*.map\" -printf ' \"%h/%f\" ')\n\t$(CXX) $(RUNTIME_CXX_FLAGS) $(CXXWARNS) -c -o $@ generated/GeneratedCode.cc -I $(RUNTIME_DIR) -Igenerated\n\n# Builds the static parts of the NanoLog library that don't change\ngenerated/library/%.o: $(RUNTIME_DIR)/%.cc\n\t@mkdir -p generated/library\n\t$(CXX) $(RUNTIME_CXX_FLAGS) $(CXXWARNS) -c -I $(RUNTIME_DIR) -Igenerated $(EXTRA_NANOLOG_FLAGS) -o $@ $<\n\n# Constructs the customized NanoLog library and decompressor for this compilation.\n# It is unique per user source compilation via the dependency on GeneratedCode.o -> $(USER_OBJS)\nlibNanoLog.a: $(RUNTIME_OBJS) generated/GeneratedCode.o decompressor\n\tar -cr libNanoLog.a $(RUNTIME_OBJS) generated/GeneratedCode.o\n\ndecompressor: $(RUNTIME_OBJS) generated/GeneratedCode.o $(RUNTIME_DIR)/LogDecompressor.cc\n\t$(CXX) $(RUNTIME_CXX_FLAGS) $(CXXWARNS) $^ -I$(RUNTIME_DIR) -Igenerated $(NANO_LOG_LIBRARY_LIBS) $(EXTRA_NANOLOG_FLAGS) -o decompressor\n\nclean-all: clean\n\t@rm -f libNanoLog.a $(RUNTIME_OBJS) decompressor\n\t@rm -rf generated $(RUNTIME_DIR)/.depend\n\n# Automatic rules to build *.h dependencies for NanoLog. Taken from\n# https://stackoverflow.com/questions/2394609/makefile-header-dependencies\ndepend: .depend_nanolog\n\n.depend_nanolog: $(RUNTIME_CC)\n\t@rm -f $(RUNTIME_DIR)/.depend\n\t$(CXX) $(RUNTIME_CXX_FLAGS) -I $(RUNTIME_DIR) -MM $^  > .depend_nanolog;\n\t@sed -i -E \"s#(^[^ ])#$(RUNTIME_DIR)/\\1#\" .depend_nanolog\n\ninclude .depend_nanolog\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.2158203125,
          "content": "# NanoLog\n![](https://github.com/PlatformLab/NanoLog/workflows/Build%20Tests/badge.svg)\n\nNanolog is an extremely performant nanosecond scale logging system for C++ that exposes a simple printf-like API and achieves over 80 *million* logs/second at a median latency of just over *7 nanoseconds*.\n\nHow it achieves this insane performance is by extracting static log information at compile-time, only logging the dynamic components in runtime hotpath, and deferring formatting to an offline process. This basically shifts work out of the runtime and into the compilation and post-execution phases.\n\nFor more information about the techniques used in this logging system, please refer to either the [NanoLog Paper](https://www.usenix.org/conference/atc18/presentation/yang-stephen) published in the 2018 USENIX Annual Technical Conference or the original author's [doctoral thesis](https://web.stanford.edu/~ouster/cgi-bin/papers/YangPhD.pdf).\n\n## Performance\n\nThis section shows the performance of NanoLog with existing logging systems such as [spdlog v1.1.0](https://github.com/gabime/spdlog), [Log4j2 v2.8](https://logging.apache.org/log4j/2.x/), [Boost 1.55](http://www.boost.org), [glog v0.3.5](https://github.com/google/glog), and Windows Event Tracing with Windows Software Trace Preprocessor on Windows 10 [(WPP)](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing).\n\n### Throughput\n\nMaximum throughput measured with 1 million messages logged back to back with no delay and 1-16 logging threads (NanoLog logged 100 million messages to generate a log file of comparable size). ETW is \"Event Tracing for Windows.\" The log messages used can be found in the [Log Message Map below](#Log-Messages-Map).\n![N|Solid](https://raw.githubusercontent.com/wiki/PlatformLab/NanoLog/systemComparison.svg?sanitize=true)\n\n### Runtime Latency\nMeasured in nanoseconds and each cell represents the 50th / 99.9th tail latencies. The log messages used can be found in the [Log Message Map below](#Log-Messages-Map).\n\n| Message | NanoLog | spdlog | Log4j2 | glog | Boost | ETW |\n|---------|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n|staticString | 7/ 37| 214/ 2546| 174 / 3364 | 1198/ 5968| 1764/ 3772| 161/ 2967|\n|stringConcat | 7/ 36| 279/ 905| 256 / 25087 | 1212/ 5881| 1829/ 5548| 191/ 3365|\n|singleInteger | 7/ 32| 268/ 855| 180 / 9305 | 1242/ 5482| 1914/ 5759| 167/ 3007|\n|twoIntegers | 8/ 62| 437/ 1416| 183 / 10896 | 1399/ 6100| 2333/ 7235| 177/ 3183|\n|singleDouble | 8/ 43| 585/ 1562| 175 / 4351 | 1983/ 6957| 2610/ 7079| 165/ 3182|\n|complexFormat | 8/ 40| 1776/ 5267| 202 / 18207 | 2569/ 8877| 3334/ 11038| 218/ 3426|\n\n#### Log Messages Map\n\nLog messages used in the benchmarks above. *Italics* indicate dynamic log arguments.\n\n| Message ID | Log Message Used |\n|--------------|:--------|\n|staticString  | Starting backup replica garbage collector thread |\n|singleInteger | Backup storage speeds (min): *181* MB/s read |\n|twoIntegers   | buffer has consumed *1032024* bytes of extra storage, current allocation: *1016544* bytes |\n|singleDouble  | Using tombstone ratio balancer with ratio = *0.4* |\n|complexFormat | Initialized InfUdDriver buffers: *50000* receive buffers (*97* MB), *50* transmit buffers (*0* MB), took *26.2* ms |\n|stringConcat  | Opened session with coordinator at *basic+udp:host=192.168.1.140,port=12246* |\n\n# Using NanoLog\n\n## Prerequisites\nCurrently NanoLog only works for Linux-based systems and depends on the following:\n* C++17 Compiler: [GNU g++ 7.5.0](https://gcc.gnu.org) or newer\n* [GNU Make 4.0](https://www.gnu.org/software/make/) or greater\n* [Python 3.4.2](https://www.python.org) or greater\n* POSIX AIO and Threads (usually installed with Linux)\n\n## NanoLog Pipeline\nThe NanoLog system enables low latency logging by deduplicating static log metadata and outputting the dynamic log data in a binary format. This means that log files produced by NanoLog are in binary and must be passed through a separate decompression program to produce the full, human readable ASCII log.\n\n## Compiling NanoLog\nThere are two versions of NanoLog (Preprocessor version and C++17 version) and you must chose **one** to use with your application as they’re not interoperable. The biggest difference between the two is that the Preprocessor version requires one to integrate a Python script in their build chain while the C++17 version is closer to a regular library (simply build and link against it). The benefit of using the Preprocessor version is that it performs more work at compile-time, resulting in a slightly more optimized runtime.\n\nIf you don’t know which one to use, go with C++17 NanoLog as it’s easier to use.\n\n### C++17 NanoLog\nThe C++17 version of NanoLog works like a traditional library; just [``#include \"NanoLogCpp17.h\"``](./runtime/NanoLogCpp17.h) and link against the NanoLog library. A sample application can be found in the [sample directory](./sample).\n\nTo build the C++17 NanoLog Runtime library, go in the [runtime directory](./runtime/) and invoke ```make```. This will produce ```./libNanoLog.a``` to against link your application and a ```./decompressor``` application that can be used to re-inflate the binary logs.\n\nWhen you compile your application, be sure to include the NanoLog header directory ([``-I ./runtime``](./runtime/)), link against NanoLog, pthreads, and POSIX AIO (``-L ./runtime/ -lNanoLog -lrt -pthread``), and enable format checking in the compiler (e.g. passing in ``-Werror=format`` as a compilation flag). The latter step is incredibly important as format errors may silently corrupt the log file at runtime. Sample g++ invocations can be found in the [sample GNUmakefile](./sample/GNUmakefile).\n\nAfter you compile and run the application, the log file generated can then be passed to the ```./decompressor``` application to generate the full human-readable log file (instructions below).\n\n### Preprocessor NanoLog\nThe Preprocessor version of NanoLog requires a tighter integration with the user build chain and is only for advanced/extreme users.\n\nIt *requires* the user's GNUmakefile to include the [NanoLogMakeFrag](./NanoLogMakeFrag), declare USR_SRCS and USR_OBJS variables to list all app’s source and object files respectively, and use the pre-defined ```run-cxx``` macro to compile *ALL* the user .cc files into .o files instead of ``g++``. See the [preprocessor sample GNUmakefile](./sample_preprocessor/GNUmakefile) for more details.\n\nInternally, the ```run-cxx``` invocation will run a Python script over the source files and generate library code that is *specific* to each compilation of the user application. In other words, the compilation builds a version of the NanoLog library that is __non-portable, even between compilations of the same application__ and each ```make``` invocation rebuilds this library.\n\nAdditionally, the compilation should also generate a ```./decompressor``` executable in the app directory and this can be used to reconstitute the full human-readable log file (instructions below).\n\n## Sample Applications\nThe sample applications are intended as a guide for how users are to interface with the NanoLog library. Users can modify these applications to test NanoLog's various API and functionality. The C++17 and Preprocessor versions of these applications reside in [./sample](./sample) and [./sample_preprocessor](./sample_preprocessor) respectively. One can modify ```main.cc``` in each directory, build/run the application, and execute the decompressor to examine the results.\n\nBelow is an example for C++17 NanoLog's [sample application](./sample).\n```bash\ncd sample\n\n# Modify the application\nnano main.cc\n\nmake clean-all\nmake\n./sampleApplication\n./decompressor decompress /tmp/logFile\n```\nNote: The sample application sets the log file to ```/tmp/logFile```.\n\n## NanoLog API\nTo use the NanoLog system in the code, one just has to include the NanoLog header (either [NanoLogCpp17.h](./runtime/NanoLogCpp17.h) for C++17 NanoLog or [NanoLog.h](./runtime/NanoLog.h) for Preprocessor NanoLog) and invoke the ```NANO_LOG()``` function in a similar fashion to printf, with the exception of a log level before it. Example below:\n\n```cpp\n#include \"NanoLogCpp17.h\"\nusing namespace NanoLog::LogLevels;\n\nint main() \n{\n  NANO_LOG(NOTICE, \"Hello World! This is an integer %d and a double %lf\\r\\n\", 1, 2.0);\n  return 0;\n}\n```\n\nValid log levels are DEBUG, NOTICE, WARNING, and ERROR and the logging level can be set via ```NanoLog::setLogLevel(...)```\n\nThe rest of the NanoLog API is documented in the [NanoLog.h](./runtime/NanoLog.h) header file.\n\n## Post-Execution Log Decompressor\nThe execution of the user application should generate a compressed, binary log file (default locations: ./compressedLog or /tmp/logFile). To make the log file human-readable, simply invoke the ```decompressor``` application with the log file.\n\n```\n./decompressor decompress ./compressedLog\n```\n\nAfter building the NanoLog library, the decompressor executable can be found in either the [./runtime directory](./runtime/) (for C++17 NanoLog) or the user app directory (for Preprocessor NanoLog).\n\n## Unit Tests\nThe NanoLog project contains a plethora of tests to ensure correctness. Below is a description of each and how to access/build/execute them.\n\n\n#### Integration Tests\nThe integration tests build and test the Nanolog system end-to-end. For both C++17 NanoLog and Preprocessor NanoLog, it compiles a client application with the NanoLog library, executes the application, and runs the resulting log file through the decompressor. It additionally compares the output of the decompressor to ensure that the log contents match the expected result.\n\nOne can execute these tests with the following commands:\n```bash\ncd integrationTest\n./run.sh\n```\n\n#### Preprocessor and Library Unit Tests\nThe NanoLog Library and Preprocessor engine also contain a suit of their own unit tests. These will test the inner-workings of each component by invoking individual functions and checking their returns match the expected results.\n\nTo run the NanoLog preprocessor unit tests, execute the following commands:\n```bash\ncd preprocessor\npython UnitTests.py\n```\n\nTo build and run the NanoLog library unit tests, execute the following commands:\n```bash\ngit submodule update --init\n\ncd runtime\nmake clean\nmake test\n./test --gtest_filter=-*assert*\n```\nNote: The gtest filter is used to removed tests with assert death statements in them.\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "googletest",
          "type": "commit",
          "content": null
        },
        {
          "name": "integrationTest",
          "type": "tree",
          "content": null
        },
        {
          "name": "preprocessor",
          "type": "tree",
          "content": null
        },
        {
          "name": "runtime",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample_preprocessor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}