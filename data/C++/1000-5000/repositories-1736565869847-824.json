{
  "metadata": {
    "timestamp": 1736565869847,
    "page": 824,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "facebookresearch/ELF",
      "stars": 2086,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.125,
          "content": "*.so\n*.pyc\n*.o\n*.d\n*.bin\n*__pycache__*\ntags\n*.ropeproject*\n*.rep\n*.swp\n*.swo\n*.DS_Store\nbuild\nCMakeFiles\nCMakeCache.txt\nlatest?\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.0830078125,
          "content": "#########################\n# project configuration #\n#########################\n\ncache:\n  apt: true\n  directories:\n    - $HOME/deps\n\n# C++ project\nlanguage: cpp\npython:\n  - 3.6\ncompiler:\n  - gcc\n  - clang\naddons:\n  apt:\n    sources:\n    - ubuntu-toolchain-r-test\n    packages:\n    - gcc-4.9\n    - g++-4.9\n    - clang\n    - libpython3-dev\n    - libtbb-dev\ninstall:\n  # create deps dir if not existing\n  - DEPS_DIR=${HOME}/deps\n  - mkdir -p ${DEPS_DIR} && cd ${DEPS_DIR}\n  - python3-config --cflags --ldflags\n  - |\n    CMAKE_URL=\"http://www.cmake.org/files/v3.3/cmake-3.3.2-Linux-x86_64.tar.gz\"\n    mkdir cmake && travis_retry wget --no-check-certificate --quiet -O - ${CMAKE_URL} | tar --strip-components=1 -xz -C cmake\n    export PATH=${DEPS_DIR}/cmake/bin:${PATH}\n  - cd -\n\nscript:\n  - if [ \"$CXX\" = \"g++\" ]; then export CXX=\"g++-4.9\" CC=\"gcc-4.9\"; fi\n  - (mkdir rts/build_MC && cd rts/build_MC && cmake .. -DGAME_DIR=../game_MC && make)\n  - (mkdir rts/build_CF && cd rts/build_CF && cmake .. -DGAME_DIR=../game_CF && make)\n  - (mkdir rts/build_TD && cd rts/build_TD && cmake .. -DGAME_DIR=../game_TD && make)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2353515625,
          "content": "# Code of Conduct\nFacebook has adopted a Code of Conduct that we expect project participants to adhere to. Please [read the full text](https://code.fb.com/codeofconduct) so that you can understand what actions will and will not be tolerated."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.6435546875,
          "content": "# Contributing to ELF\nWe want to make contributing to this project as easy and transparent as possible.  \nWe also welcome any fork attempt from this project.  \n\n## Our Development Process\nELF is developed mainly by Yuandong Tian, Qucheng Gong and Yuxin Wu from Facebook AI Research since Jan. 2017.\nSince it opens to the public, its future development will be conducted in this open source branch.  \n\n## Bug reports\nPlease follow the steps when you find a bug:\n\n1. use the Github issue search to check if the issue has been addressed before. \n2. Make sure if the issue has been fixed by synchronizing the most recent branch in the repository. \n3. Write a simple and easy-to-understand test case that reveals the issue. We use github issues to track public bugs. please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.\n\n## Pull Requests\nWe actively welcome your pull requests.\n\n1. Fork the repo and create your branch from `master`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://code.facebook.com/cla>\n\n## Coding Style  \n* 2 spaces for indentation rather than tabs\n* 80 character line length\n\n## License\nBy contributing to ELF, you agree that your contributions will be licensed under its BSD license.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.48828125,
          "content": "BSD License\n\nFor ELF software\n\nCopyright (c) 2017-present, Facebook, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n * Neither the name Facebook nor the names of its contributors may be used to\n   endorse or promote products derived from this software without specific\n   prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.0029296875,
          "content": "# ELF: An Extensive, Lightweight and Flexible Platform for Game Research\n\nOverview\n===============\n\nELF is an **E**xtensive, **L**ightweight and **F**lexible platform for game research, in particular for real-time strategy (RTS) games. On the C++-side, ELF hosts multiple games in parallel with C++ threading. On the Python side, ELF returns one batch of game state at a time, making it very friendly for modern RL. In comparison, other platforms (e.g., OpenAI Gym) wraps one single game instance with one Python interface. This makes concurrent game execution a bit complicated, which is a requirement of many modern reinforcement learning algorithms.\n\nBesides, ELF now also provides a Python version for running concurrent game environments, by Python multiprocessing with ZeroMQ inter-process communication. See `./ex_elfpy.py` for a simple example. \n\nFor research on RTS games, ELF comes with an fast RTS engine, and three concrete environments: MiniRTS, Capture the Flag and Tower Defense. MiniRTS has all the key dynamics of a real-time strategy game, including gathering resources, building facilities and troops, scouting the unknown territories outside the perceivable regions, and defend/attack the enemy. User can access its internal representation and can freely change the game setting.\n\n![Overview](./overview.png)\n\nELF has the following characteristics:\n\n* *End-to-End*: ELF offers an end-to-end solution to game research. It provides miniature real-time strategy game environments, concurrent simulation, intuitive APIs, web-based visualzation, and also comes with a reinforcement learning backend empowered by [Pytorch](https://github.com/pytorch/pytorch) with minimal resource requirement.  \n\n* *Extensive*: Any game with C/C++ interface can be plugged into this framework by writing a simple wrapper. As an example, we already incorporate Atari games into our framework and show that the simulation speed per core is comparable with single-core version, and is thus much faster than implementation using either multiprocessing or Python multithreading. In the future, we plan to incorporate more environments, e.g., DarkForest Go engine.\n\n* *Lightweight*: ELF runs very fast with minimal overhead. ELF with a simple game (MiniRTS) built on RTS engine runs **40K frame per second per core** on a MacBook Pro. Training a model from scratch to play MiniRTS **takes a day on 6 CPU + 1 GPU**.  \n\n* *Flexible*: Pairing between environments and actors is very flexible, e.g., one environment with one agent (e.g., Vanilla A3C), one environment with multiple agents (e.g., Self-play/MCTS), or multiple environment with one actor (e.g., BatchA3C, GA3C). Also, any game built on top of the RTS engine offers full access to its internal representation and dynamics. Besides efficient simulators, we also provide a lightweight yet powerful Reinforcement Learning framework. This framework can host most existing RL algorithms. In this open source release, we have provided state-of-the-art actor-critic algorithms, written in [PyTorch](https://github.com/pytorch/pytorch).\n\nTutorials  \n=============\nSee [here](http://yuandong-tian.com/elf-tutorial/tutorial.html).\n\nInstall scripts\n================\nYou need to have ```cmake``` >= 3.8, ```gcc``` >= 4.9 and ```tbb``` (linux ```libtbb-dev```) in order to install this script successfully.\n\n```\n# Download miniconda and install. \nwget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O $HOME/miniconda.sh\n/bin/bash $HOME/miniconda.sh -b\n$HOME/miniconda3/bin/conda update -y --all python=3\n\n# Add the following to ~/.bash_profile (if you haven't already) and source it:\nexport PATH=$HOME/miniconda3/bin:$PATH\n\n# Create a new conda environment and install the necessary packages:\nconda create -n elf python=3\nsource activate elf\n# If you use cuda 8.0\n# conda install pytorch cuda80 -c soumith\nconda install pytorch -c soumith \n\npip install --upgrade pip\npip install msgpack_numpy\nconda install tqdm\nconda install libgcc\n\n# Install cmake >= 3.8, gcc >= 4.9 and libtbb-dev\n# This is platform-dependent.\n\n# Clone and build the repository:\ncd ~\ngit clone https://github.com/facebookresearch/ELF\ncd ELF/rts/\nmkdir build && cd build\ncmake .. -DPYTHON_EXECUTABLE=$HOME/miniconda3/bin/python\nmake\n\n# Train the model\ncd ../..\nsh ./train_minirts.sh --gpu 0\n```\n\nSupported Environments   \n========================\nAny game with C/C++ interface can be plugged into this framework by writing a simple wrapper. Currently we have the following environment:\n\n1. **MiniRTS and its extensions** (`./rts`)  \nA miniature real-time strategy game that captures the key dynamics of its genre, including building workers, collecting resources, exploring unseen territories, defend the enemy and attack them back. The game runs extremely fast (40K FPS per core on a laptop) to faciliate the usage of many existing on-policy reinforcement learning approaches.  \n\n2. **Atari games** (`./atari`)  \nWe incorporate Arcade Learning Environment (ALE) into ELF so that you can load any rom and run 1000 concurrent game instances easily. \n\n3. **Go engine** (`./go`)  \nWe reimplement our [DarkForest Go engine](https://github.com/facebookresearch/darkforestGo) in ELF platform. Now you can easily load a bunch of .sgf files and train your own Go AI with minimal resource requirements (i.e., a single GPU plus a week). \n\n\nReference  \n=============\n\nWhen you use ELF, please reference the [paper](https://arxiv.org/abs/1707.01067) with the following BibTex entry:\n\n```\nELF: An Extensive, Lightweight and Flexible Research Platform for Real-time Strategy Games\nYuandong Tian, Qucheng Gong, Wenling Shang, Yuxin Wu, C. Lawrence Zitnick\nNIPS 2017\n\n@article{tian2017elf, \n  title={ELF: An Extensive, Lightweight and Flexible Research Platform for Real-time Strategy Games},\n  author={Yuandong Tian and Qucheng Gong and Wenling Shang and Yuxin Wu and C. Lawrence Zitnick},\n  journal={Advances in Neural Information Processing Systems (NIPS)},\n  year={2017}\n}\n```\n\nRelevant Materials \n=============\n[Slides](http://www.yuandong-tian.com/icml17_workshop.pdf) in ICML Video Games and Machine Learning (VGML) workshop. \n\n[Demo](https://www.youtube.com/watch?v=YgZyWobkqfw). Top-left is trained bot while bottom-right is rule-based bot.\n\n\nDocumentation  \n=================\nCheck [here](http://yuandong-tian.com/html_elf) for detailed documentation. You can also compile your version in `./doc` using `sphinx`. \n\nBasic Usage  \n==============\nELF is very easy to use. The initialization looks like the following:\n\n```python\n# We run 1024 games concurrently.\nnum_games = 1024\n\n# Wait for a batch of 256 games.\nbatchsize = 256  \n\n# The return states contain key 's', 'r' and 'terminal'\n# The reply contains key 'a' to be filled from the Python side.\n# The definitions of the keys are in the wrapper of the game.  \ninput_spec = dict(s='', r='', terminal='')\nreply_spec = dict(a='')\n\ncontext = Init(num_games, batchsize, input_spec, reply_spec)\n```\n\nThe main loop is also very simple:\n\n```python\n# Start all game threads and enter main loop.\ncontext.Start()  \nwhile True:\n    # Wait for a batch of game states to be ready\n    # These games will be blocked, waiting for replies.\n    batch = context.Wait()\n\n    # Apply a model to the game state. The output has key 'pi'\n    # You can do whatever you want here. E.g., applying your favorite RL algorithms.\n    output = model(batch)\n\n    # Sample from the output to get the actions of this batch.\n    reply['a'][:] = SampleFromDistribution(output)\n\n    # Resume games.\n    context.Steps()   \n\n# Stop all game threads.\ncontext.Stop()  \n```\n\nPlease check `train.py` and `eval.py` for actual runnable codes.\n\nDependency    \n===============\nC++ compiler with C++11 support (e.g., gcc >= 4.9) is required. The following libraries are required `tbb`. CMake >=3.8 is also required.\n\nPython 3.x is required. In addition, you need to install following package: [PyTorch](http://pytorch.org/) version 0.2.0+, `tqdm`, `zmq`, `msgpack`, `msgpack_numpy`\n\nHow to train    \n===============\nTo train a model for MiniRTS, please first compile `./rts/game_MC` (See the instruction in `./rts/` using `cmake`). Note that a compilation of `./rts/backend` is not necessary for training, unless you want to see visualization. \n\nThen please run the following commands in the current directory (you can also reference `train_minirts.sh`):\n\n```bash\ngame=./rts/game_MC/game model=actor_critic model_file=./rts/game_MC/model \\ \npython3 train.py \n    --num_games 1024 --batchsize 128                                                                  # Set number of games to be 1024 and batchsize to be 128.  \n    --freq_update 50                                                                                  # Update behavior policy after 50 updates of the model.\n    --players \"fs=50,type=AI_NN,args=backup/AI_SIMPLE|delay/0.99|start/500;fs=20,type=AI_SIMPLE\"      # Specify AI and its opponent, separated by semicolon. `fs` is frameskip that specifies How often your opponent makes a decision (e.g., fs=20 means it acts every 20 ticks)\n                                                                                                      # If `backup` is specified in `args`, then we use rule-based AI for the first `start` ticks, then trained AI takes over. `start` decays with rate `decay`. \n    --tqdm                                                                  # Show progress bar.\n    --gpu 0                                                                 # Use first gpu. If you don't specify gpu, it will run on CPUs. \n    --T 20                                                                  # 20 step actor-critic\n    --additional_labels id,last_terminal         \n    --trainer_stats winrate                                                 # If you want to see the winrate over iterations. \n                                                                            # Note that the winrate is computed when the action is sampled from the multinomial distribution (not greedy policy). \n                                                                            # To evaluate your model more accurately, please use eval.py.\n```\n\nNote that long horizon (e.g., `--T 20`) could make the training much faster and (at the same time) stable. With long horizon, you should be able to train it to 70% winrate within 12 hours with 16CPU and 1GPU.  You can control the number of CPUs used in the training using `taskset -c`. \n\nHere is one [trained model](http://yuandong-tian.com/model-winrate-80.0-357800.bin) with 80% winrate against `AI_SIMPLE` for frameskip=50. Here is one game [replay](https://www.youtube.com/watch?v=YgZyWobkqfw). \n\nThe following is a sample output during training:\n```\nVersion:  bf1304010f9609b2114a1adff4aa2eb338695b9d_staged\nNum Actions:  9\nNum unittype:  6\n100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 5000/5000 [01:35<00:00, 52.37it/s]\n[2017-07-12 09:04:13.212017][128] Iter[0]:\nTrain count: 820/5000, actor count: 4180/5000\nSave to ./\nFilename = ./save-820.bin\nCommand arguments run.py --batchsize 128 --freq_update 50 --fs_opponent 20 --latest_start 500 --latest_start_decay 0.99 --num_games 1024 --opponent_type AI_SIMPLE --tqdm\n0:acc_reward[4100]: avg: -0.34079, min: -0.58232[1580], max: 0.25949[185]\n0:cost[4100]: avg: 2.15912, min: 1.97886[2140], max: 2.31487[1173]\n0:entropy_err[4100]: avg: -2.13493, min: -2.17945[438], max: -2.04809[1467]\n0:init_reward[820]: avg: -0.34093, min: -0.56980[315], max: 0.26211[37]\n0:policy_err[4100]: avg: 2.16714, min: 1.98384[1520], max: 2.31068[1176]\n0:predict_reward[4100]: avg: -0.33676, min: -1.36083[1588], max: 0.39551[195]\n0:reward[4100]: avg: -0.01153, min: -0.13281[1109], max: 0.04688[124]\n0:rms_advantage[4100]: avg: 0.15646, min: 0.02189[800], max: 0.79827[564]\n0:value_err[4100]: avg: 0.01333, min: 0.00024[800], max: 0.06569[1549]\n\n 86%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▉                    | 4287/5000 [01:23<00:15, 46.97it/s]\n```\n\nTo evaluate a model for MiniRTS, try the following command (you can also reference `eval_minirts.sh`):\n```bash\ngame=./rts/game_MC/game model=actor_critic model_file=./rts/game_MC/model \\ \npython3 eval.py \n    --load [your model]\n    --batchsize 128 \n    --players \"fs=50,type=AI_NN;fs=20,type=AI_SIMPLE\"  \n    --num_games 1024 \n    --num_eval 10000\n    --tqdm                          # Nice progress bar\n    --gpu 0                         # Use GPU 0 as the evaluation gpu.\n    --additional_labels id          # Tell the game environment to output additional dict entries.\n    --greedy                        # Use greedy policy to evaluate your model. If not specified, then it will sample from the action distributions. \n```\n\nHere is an example output (it takes 1 min 40 seconds to evaluate 10k games with 12 CPUs):\n```\nVersion:  dc895b8ea7df8ef7f98a1a031c3224ce878d52f0_\nNum Actions:  9\nNum unittype:  6\nLoad from ./save-212808.bin\nVersion:  dc895b8ea7df8ef7f98a1a031c3224ce878d52f0_\nNum Actions:  9\nNum unittype:  6\n100%|████████████████████████████████████████████████████████████████████████████████████████████| 10000/10000 [01:40<00:00, 99.94it/s]\nstr_acc_win_rate: Accumulated win rate: 0.735 [7295/2628/9923]\nbest_win_rate: 0.7351607376801297\nnew_record: True\ncount: 0\nstr_win_rate: [0] Win rate: 0.735 [7295/2628/9923], Best win rate: 0.735 [0]\nStop all game threads ...\n```\n\nSelfPlay\n=============\nTry the following script if you want to do self-play in Minirts. It will start with two bots, both starting with the pre-trained model. One bot will be trained over time, while the other is held fixed. If you just want to check their winrate without training, try `--actor_only`.\n```\nsh ./selfplay_minirts.sh [your pre-trained model] \n```\n\nVisualization  \n==============\n\nTo visualize a trained bot, you can specify `--save_replay_prefix [replay_file_prefix]` when running `eval.py` to save (lots of) replays. Note that the same flag can also be applied to training/selfplay. \n\nAll replay files contain action sequences, are in `.rep` and should reproduce the exact same game when loaded. To load the replay in the command line, using the following:\n```bash\n./minirts-backend replay --load_replay [your replay] --vis_after 0\n```\nand open the webpage `./rts/frontend/minirts.html` to check the game. To load and run the replay in the command line only (e.g, if you just want to quickly see who win the game), try:\n```bash\n./minirts-backend replay_cmd --load_replay [your replay]\n```\n\n"
        },
        {
          "name": "atari",
          "type": "tree",
          "content": null
        },
        {
          "name": "check.py",
          "type": "blob",
          "size": 3.6513671875,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n# \n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom datetime import datetime\n\nimport sys\nimport os\nimport random\nfrom collections import defaultdict\n\nfrom rlpytorch import load_module, SingleProcessRun, ArgsProvider, load_env\n\nclass StatsCollector:\n    def __init__(self):\n        self.id2seqs_actor = defaultdict(lambda : -1)\n        self.idgseq2action = defaultdict(lambda : -1)\n        self.id2seqs_train = defaultdict(lambda : -1)\n\n    def set_params(self, params):\n        self.params = params\n\n    def _title(self, prompt, sel, t, i):\n        return \"[%s][id=%d][batchidx=%d][t=%d][seq=%d][game_counter=%d]: \" % (prompt, sel[\"id\"][t][i], i, t, sel[\"seq\"][t][i], sel[\"game_counter\"][t][i])\n\n    def _debug(self, prompt):\n        import pdb\n        pdb.set_trace()\n        raise ValueError(prompt)\n\n    def actor(self, sel, sel_gpu):\n        '''Check the states for an episode.'''\n        b = sel.hist(0)\n        batchsize = b[\"id\"].size(0)\n        # import pdb\n        # pdb.set_trace()\n        # Return random actions.\n        actions = [random.randint(0, self.params[\"num_action\"]-1) for i in range(batchsize)]\n\n        # Check whether id is duplicated.\n        ids = set()\n        for i, (id, seq, game_counter, last_terminal, a) in enumerate(zip(b[\"id\"], b[\"seq\"], b[\"game_counter\"], b[\"last_terminal\"], actions)):\n            # print(\"[%d] actor %d, seq %d\" % (i, id, seq))\n            prompt = self._title(\"actor\", sel, 0, i)\n            if id not in ids:\n                ids.add(id)\n            else:\n                self._debug(\"%s, id duplicated!\" % prompt)\n\n            if last_terminal:\n                self.id2seqs_actor[id] = -1\n            predicted = self.id2seqs_actor[id] + 1\n            if seq != predicted:\n                self._debug(\"%s, should be seq = %d\" % (prompt, predicted))\n            self.id2seqs_actor[id] += 1\n\n            key = (id, seq, game_counter)\n            self.idgseq2action[key] = a\n\n        return dict(a=actions)\n\n    def train(self, sel, sel_gpu):\n        T = sel[\"id\"].size(0)\n        batchsize = sel[\"id\"].size(1)\n\n        # Check whether the states are consecutive\n        for i in range(batchsize):\n            id = sel[\"id\"][0][i]\n            last_seq = self.id2seqs_train[id]\n            # print(\"train %d, last_seq: %d\" % (id, last_seq))\n            for t in range(T):\n                prompt = self._title(\"train\", sel, t, i)\n\n                if sel[\"last_terminal\"][t][i]:\n                    last_seq = -1\n                if sel[\"seq\"][t][i] != last_seq + 1:\n                    self._debug(\"%s. Invalid next seq. seq should be %d\" % (prompt, last_seq + 1))\n                last_seq += 1\n\n                # Check whether the actions remains the same.\n                if t < T - 1:\n                    key = (id, sel[\"seq\"][t][i], sel[\"game_counter\"][t][i])\n                    recorded_a = self.idgseq2action[key]\n                    actual_a = sel[\"a\"][t][i]\n                    if recorded_a != actual_a:\n                        self._debug(\"%s Action was different. recorded %d, actual %d\" % (prompt, recorded_a, actual_a))\n\n            # Overlapped by 1.\n            self.id2seqs_train[id] = last_seq - 1\n\nif __name__ == '__main__':\n    collector = StatsCollector()\n    runner = SingleProcessRun()\n    env, all_args = load_env(os.environ, collector=collector, runner=runner)\n\n    GC = env[\"game\"].initialize()\n    # GC.setup_gpu(0)\n    collector.set_params(GC.params)\n\n    GC.reg_callback(\"actor\", collector.actor)\n    GC.reg_callback(\"train\", collector.train)\n    GC.reg_sig_int()\n\n    runner.setup(GC)\n    runner.run()\n"
        },
        {
          "name": "console_df.sh",
          "type": "blob",
          "size": 0.0947265625,
          "content": "game=./go/game model=df_policy model_file=./go/df_model python3 df_console.py --mode online \"$@\"\n"
        },
        {
          "name": "console_df_check_train.sh",
          "type": "blob",
          "size": 0.134765625,
          "content": "game=./go/game model=df_policy model_file=./go/df_model python3 df_console.py --list_file ~/local/go/go_gogod/train.lst --data_aug 0 \"$@\"\n"
        },
        {
          "name": "console_df_mcts.sh",
          "type": "blob",
          "size": 0.1005859375,
          "content": "game=./go/game model=df_policy model_file=./go/df_model python3 df_console.py --online --use_mcts \"$@\"\n"
        },
        {
          "name": "df_console.py",
          "type": "blob",
          "size": 7.0029296875,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n# Console for DarkForest\nimport sys\nimport os\nfrom collections import Counter\nfrom rlpytorch import load_env, Evaluator, ModelInterface, ArgsProvider, EvalIters\n\ndef move2xy(v):\n    x = ord(v[0].lower()) - ord('a')\n    # Skip 'i'\n    if x >= 9: x -= 1\n    y = int(v[1:]) - 1\n    return x, y\n\ndef move2action(v):\n    x, y = move2xy(v)\n    return x * 19 + y\n\ndef xy2move(x, y):\n    if x >= 8: x += 1\n    return chr(x + 65) + str(y + 1)\n\ndef action2move(a):\n    x = a // 19\n    y = a % 19\n    return xy2move(x, y)\n\ndef plot_plane(v):\n    s = \"\"\n    for j in range(v.size(1)):\n        for i in range(v.size(0)):\n            if v[i, v.size(1) - 1 - j] != 0:\n                s += \"o \"\n            else:\n                s += \". \"\n        s += \"\\n\"\n    print(s)\n\n\ndef topk_accuracy2(batch, state_curr, topk=(1,)):\n    pi = state_curr[\"pi\"]\n    import torch\n    if isinstance(pi, torch.autograd.Variable):\n        pi = pi.data\n    score, indices = pi.sort(dim=1, descending=True)\n\n    maxk = max(topk)\n    topn_count = [0] * maxk\n\n    for ind, gt in zip(indices, batch[\"offline_a\"][0]):\n        for i in range(maxk):\n            if ind[i] == gt[0]:\n                topn_count[i] += 1\n\n    for i in range(maxk):\n        topn_count[i] /= indices.size(0)\n\n    return [ topn_count[i - 1] for i in topk ]\n\n\nclass DFConsole:\n    def __init__(self):\n        self.exit = False\n\n    def check(self, batch):\n        reply = self.evaluator.actor(batch)\n        topk = topk_accuracy2(batch, reply, topk=(1,2,3,4,5))\n        for i, v in enumerate(topk):\n            self.check_stats[i] += v\n        if sum(topk) == 0: self.check_stats[-1] += 1\n\n    def actor(self, batch):\n        reply = self.evaluator.actor(batch)\n        return reply\n\n    def prompt(self, prompt_str, batch):\n        if self.last_move_idx is not None:\n            curr_move_idx = batch[\"move_idx\"][0][0]\n            if curr_move_idx - self.last_move_idx == 1:\n                self.check(batch)\n                self.last_move_idx = curr_move_idx\n                return\n            else:\n                n = sum(self.check_stats.values())\n                print(\"#Move: \" + str(n))\n                accu = 0\n                for i in range(5):\n                    accu += self.check_stats[i]\n                    print(\"Top %d: %.3f\" % (i, accu / n))\n                self.last_move_idx = None\n\n        print(batch.GC.ShowBoard(0))\n        # Ask user to choose\n        while True:\n            if getattr(self, \"repeat\", 0) > 0:\n                self.repeat -= 1\n                cmd = self.repeat_cmd\n            else:\n                cmd = input(prompt_str)\n            items = cmd.split()\n            if len(items) < 1:\n                print(\"Invalid input\")\n\n            reply = dict(pi=None, a=None)\n\n            try:\n                if items[0] == 'p':\n                    reply[\"a\"] = move2action(items[1])\n                    return reply\n                elif items[0] == 'c':\n                    return self.evaluator.actor(batch)\n                elif items[0] == \"s\":\n                    channel_id = int(items[1])\n                    plot_plane(batch[\"s\"][0][0][channel_id])\n                elif items[0] == \"u\":\n                    batch.GC.UndoMove(0)\n                    print(batch.GC.ShowBoard(0))\n                elif items[0] == \"h\":\n                    handicap = int(items[1])\n                    batch.GC.ApplyHandicap(0, handicap)\n                    print(batch.GC.ShowBoard(0))\n                elif items[0] == \"a\":\n                    reply = self.evaluator.actor(batch)\n                    if \"pi\" in reply:\n                        score, indices = reply[\"pi\"].squeeze().sort(dim=0, descending=True)\n                        first_n = int(items[1])\n                        for i in range(first_n):\n                            print(\"%s: %.3f\" % (action2move(indices[i]), score[i]))\n                    else:\n                        print(\"No key \\\"pi\\\"\")\n                elif items[0] == \"check\":\n                    print(\"Top %d\" % self.check(batch))\n\n                elif items[0] == 'check2end':\n                    self.check_stats = Counter()\n                    self.check(batch)\n                    self.last_move_idx = batch[\"move_idx\"][0][0]\n                    if len(items) == 2:\n                        self.repeat = int(items[1])\n                        self.repeat_cmd = \"check2end_cont\"\n                    return\n\n                elif items[0] == \"check2end_cont\":\n                    if not hasattr(self, \"check_stats\"):\n                        self.check_stats = Counter()\n                    self.check(batch)\n                    self.last_move_idx = batch[\"move_idx\"][0][0]\n                    return\n\n                elif items[0] == \"aug\":\n                    print(batch[\"aug_code\"][0][0])\n                elif items[0] == \"show\":\n                    print(batch.GC.ShowBoard(0))\n                elif items[0] == \"dbg\":\n                    import pdb\n                    pdb.set_trace()\n                elif items[0] == 'offline_a':\n                    if \"offline_a\" in batch:\n                        for i, offline_a in enumerate(batch[\"offline_a\"][0][0]):\n                            print(\"[%d]: %s\" % (i, action2move(offline_a)))\n                    else:\n                        print(\"No offline_a available!\")\n                elif items[0] == \"exit\":\n                    self.exit = True\n                    return reply\n                else:\n                    print(\"Invalid input: \" + cmd + \". Please try again\")\n            except Exception as e:\n                print(\"Something wrong! \" + str(e))\n\n    def main_loop(self):\n        evaluator = Evaluator(stats=False)\n        # Set game to online model.\n        env, args = load_env(os.environ, evaluator=evaluator, overrides=dict(num_games=1, batchsize=1, num_games_per_thread=1, greedy=True, T=1, additional_labels=\"aug_code,move_idx\"))\n\n        GC = env[\"game\"].initialize()\n        model = env[\"model_loaders\"][0].load_model(GC.params)\n        mi = ModelInterface()\n        mi.add_model(\"model\", model)\n        mi.add_model(\"actor\", model, copy=True, cuda=args.gpu is not None, gpu_id=args.gpu)\n        mi[\"model\"].eval()\n        mi[\"actor\"].eval()\n\n        self.evaluator = evaluator\n        self.last_move_idx = None\n\n        def human_actor(batch):\n            print(\"In human_actor\")\n            return self.prompt(\"DF> \", batch)\n\n        def actor(batch):\n            return self.actor(batch)\n\n        def train(batch):\n            self.prompt(\"DF Train> \", batch)\n\n        evaluator.setup(sampler=env[\"sampler\"], mi=mi)\n\n        GC.reg_callback_if_exists(\"actor\", actor)\n        GC.reg_callback_if_exists(\"human_actor\", human_actor)\n        GC.reg_callback_if_exists(\"train\", train)\n\n        GC.Start()\n\n        evaluator.episode_start(0)\n\n        while True:\n            GC.Run()\n            if self.exit: break\n        GC.Stop()\n\nif __name__ == '__main__':\n    console = DFConsole()\n    console.main_loop()\n"
        },
        {
          "name": "df_selfplay.py",
          "type": "blob",
          "size": 1.5390625,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n# Console for DarkForest\nimport sys\nimport os\nfrom rlpytorch import load_env, Evaluator, ModelInterface, ArgsProvider, EvalIters\n\nif __name__ == '__main__':\n    evaluator = Evaluator(stats=False)\n    # Set game to online model.\n    env, args = load_env(os.environ, evaluator=evaluator, overrides=dict(mode=\"selfplay\", T=1))\n\n    GC = env[\"game\"].initialize()\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    mi = ModelInterface()\n    mi.add_model(\"model\", model)\n    mi.add_model(\"actor\", model, copy=True, cuda=args.gpu is not None, gpu_id=args.gpu)\n    mi[\"model\"].eval()\n    mi[\"actor\"].eval()\n\n    evaluator.setup(mi=mi)\n\n    total_batchsize = 0\n    total_sel_batchsize = 0\n\n    def actor(batch):\n        global total_batchsize, total_sel_batchsize\n        reply = evaluator.actor(batch)\n        total_sel_batchsize += batch.batchsize\n        total_batchsize += batch.max_batchsize\n\n        if total_sel_batchsize >= 5000:\n            print(\"Batch usage: %d/%d (%.2f%%)\" %\n                  (total_sel_batchsize, total_batchsize, 100.0 * total_sel_batchsize / total_batchsize))\n            total_sel_batchsize = 0\n            total_batchsize = 0\n        # import pdb\n        # pdb.set_trace()\n        return reply\n\n    GC.reg_callback_if_exists(\"actor\", actor)\n\n    GC.Start()\n\n    evaluator.episode_start(0)\n\n    while True:\n        GC.Run()\n\n    GC.Stop()\n"
        },
        {
          "name": "df_selfplay.sh",
          "type": "blob",
          "size": 0.091796875,
          "content": "game=./go/game model=df model_file=./go/df_model2 python3 df_selfplay.py --mode selfplay \"$@\"\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "elf",
          "type": "tree",
          "content": null
        },
        {
          "name": "elf_python",
          "type": "tree",
          "content": null
        },
        {
          "name": "eval.py",
          "type": "blob",
          "size": 1.3876953125,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import load_env, Evaluator, ArgsProvider, EvalIters\n\nif __name__ == '__main__':\n    evaluator = Evaluator(stats=False)\n    eval_iters = EvalIters()\n    env, args = load_env(os.environ, overrides=dict(actor_only=True), evaluator=evaluator, eval_iters=eval_iters)\n\n    GC = env[\"game\"].initialize()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    env[\"mi\"].add_model(\"actor\", model, cuda=not args.gpu is None, gpu_id=args.gpu)\n    env[\"mi\"][\"actor\"].eval()\n\n    def actor(batch):\n        reply = evaluator.actor(batch)\n        '''\n        s = batch[\"s\"][0][0]\n        seq = batch[\"seq\"][0][0]\n        for i in range(s.size(0)):\n            print(\"[seq=%d][c=%d]: %s\" % (seq, i, str(s[i])))\n        print(\"[seq=%d]: %s\" % (seq, str(reply[\"pi\"][0])))\n        print(\"[seq=%d]: %s\" % (seq, str(reply[\"a\"][0])))\n        '''\n        eval_iters.stats.feed_batch(batch)\n        return reply\n\n    evaluator.setup(sampler=env[\"sampler\"], mi=env[\"mi\"])\n\n    GC.reg_callback(\"actor\", actor)\n    GC.Start()\n\n    evaluator.episode_start(0)\n\n    for n in eval_iters.iters():\n        GC.Run()\n    GC.Stop()\n\n"
        },
        {
          "name": "eval_atari.sh",
          "type": "blob",
          "size": 0.2861328125,
          "content": "ROM=$1\nMODEL=$2\nGPU=$3\n\ngame=./atari/game model=actor_critic model_file=./atari/model python3 eval.py --num_games 128 --batchsize 32 --tqdm --gpu $GPU --rom_file $ROM --load $MODEL --eval_stats rewards --reward_clip -1 --num_eval 500 --additional_labels id,last_terminal --keys_in_reply V,rv \n"
        },
        {
          "name": "eval_checkforward.py",
          "type": "blob",
          "size": 4.634765625,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport argparse\nfrom datetime import datetime\nfrom collections import deque, defaultdict\nfrom torch.autograd import Variable\n\nimport sys\nimport os\n\nfrom rlpytorch import *\nfrom rlpytorch.stats import Stats\nfrom rlpytorch.utils import HistState\n\ndef tensor2str(t):\n    return \",\".join([\"%.6f\" % ele for ele in t])\n\ndef merge(t, templ=None):\n    output = defaultdict(lambda : list())\n    for item in t:\n        for k, v in item.items():\n            output[k].append(v)\n\n    output2 = dict()\n    for k, v in output.items():\n        if isinstance(v[0], (float, int)):\n            vv = templ.clone().resize_(len(v))\n            for i, entry in enumerate(v):\n                vv[i] = entry\n        else:\n            vv = v[0].clone().resize_(len(v), *list(v[0].size()))\n            for i, entry in enumerate(v):\n                vv[i, :] = entry\n        output2[k] = vv\n\n    return output2\n\nclass ForwardActor:\n    def __init__(self):\n        self.args = ArgsProvider(\n            call_from = self,\n            define_args = [\n                (\"delay_T\", 5),\n                (\"use_delayed_state\", dict(action=\"store_true\")),\n            ],\n            on_get_args = self._on_get_args\n        )\n\n        self.t0 = 0\n\n    def _on_get_args(self, _):\n        self.hs = HistState(self.args.delay_T + 1)\n\n    def set(self, mi, sampler):\n        self.mi = mi\n        self.sampler = sampler\n\n    def actor_use_delayed(self, batch):\n        mi = self.mi\n        T = self.args.delay_T\n\n        # actor model.\n        state_curr = mi[\"actor\"](batch.hist(0))\n        actions = self.sampler.sample(state_curr)[\"a\"]\n        batchsize = state_curr[\"h\"].size(0)\n        d = state_curr[\"h\"].size(1)\n\n        # Then given the previous state, perform a few forwarding.\n\n        ids = batch[\"id\"][0]\n        Vs = state_curr[\"V\"].data\n        seqs = batch[\"seq\"][0]\n\n        entry = [ dict(a=a, V=V) for a, V in zip(actions, Vs) ]\n\n        self.hs.preprocess(ids, seqs)\n        self.hs.feed(ids, entry)\n        old_entries = self.hs.oldest(ids, self.t0)\n        reply_msg = merge(old_entries, templ=Vs[0])\n\n        eval_iters.stats.feed_batch(batch)\n        # reply_msg[\"rv\"] = mi[\"actor\"].step\n        reply_msg[\"pi\"] = None\n        return reply_msg\n\n\n    def actor(self, batch):\n        mi = self.mi\n        T = self.args.delay_T\n\n        # actor model.\n        state_curr = mi[\"actor\"](batch.hist(0))\n        batchsize = state_curr[\"h\"].size(0)\n        d = state_curr[\"h\"].size(1)\n\n        # Then given the previous state, perform a few forwarding.\n        # state_hs = state_curr[\"h\"].data[0].clone().resize_(batchsize, d)\n\n        ids = batch[\"id\"][0]\n        hs = state_curr[\"h\"].data\n        seqs = batch[\"seq\"][0]\n\n        self.hs.preprocess(ids, seqs)\n        self.hs.feed(ids, hs)\n        state_hs = self.hs.oldest(ids, self.t0)\n\n        # forward..\n        state_curr_given_h = mi[\"actor\"].decision(Variable(state_hs))\n        # save the current state.\n        action = self.sampler.sample(state_curr_given_h)[\"a\"]\n        # action = self.sampler.sample(state_curr)\n\n        # move things forward.\n        self.hs.map(ids, lambda hs: mi[\"actor\"].transition(Variable(hs), action)[\"hf\"].data)\n        eval_iters.stats.feed_batch(batch)\n        reply_msg = dict(pi=state_curr_given_h[\"pi\"].data, a=action, V=state_curr_given_h[\"V\"].data)\n        # rv=mi[\"actor\"].step\n\n        if batchsize == 1:\n            print(\"================\")\n            print(\"[%d] Predict with forward model: \" % seqs[0])\n            print(tensor2str(state_curr_given_h[\"pi\"].data[0]))\n            print(\"action = \" + str(action[0]))\n            print(\"[%d] Predict using current observation\" % seqs[0])\n            print(tensor2str(state_curr[\"pi\"].data[0]))\n            print(\"================\")\n\n        return reply_msg\n\n\nif __name__ == '__main__':\n    eval_iters = EvalIters()\n    forward_actor = ForwardActor()\n    env, args = load_env(os.environ, overrides=dict(actor_only=True), eval_iters=eval_iters, forward_actor=forward_actor)\n\n    GC = env[\"game\"].initialize()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    mi = env[\"mi\"]\n    mi.add_model(\"model\", model)\n    mi.add_model(\"actor\", model, copy=True, cuda=True, gpu_id=args.gpu)\n\n    forward_actor.set(mi, env[\"sampler\"])\n    if args.use_delayed_state:\n        GC.reg_callback(\"actor\", forward_actor.actor_use_delayed)\n    else:\n        GC.reg_callback(\"actor\", forward_actor.actor)\n    GC.Start()\n\n    for n in eval_iters.iters():\n        GC.Run()\n    GC.Stop()\n\n"
        },
        {
          "name": "eval_lstm.py",
          "type": "blob",
          "size": 1.1728515625,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport argparse\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import LSTMTrainer, Sampler, EvalIters, load_env, ModelLoader, ArgsProvider, ModelInterface\n\nif __name__ == '__main__':\n    trainer = LSTMTrainer()\n    eval_iters = EvalIters()\n    env, all_args = load_env(os.environ, overrides=dict(actor_only=True), trainer=trainer, eval_iters=eval_iters)\n\n    GC = env[\"game\"].initialize()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    mi = ModelInterface()\n    mi.add_model(\"model\", model)\n    mi.add_model(\"actor\", model, copy=True, cuda=all_args.gpu is not None, gpu_id=all_args.gpu)\n\n    trainer.setup(sampler=env[\"sampler\"], mi=env[\"mi\"])\n\n    def actor(batch):\n        reply = trainer.actor(batch)\n        eval_iters.stats.feed_batch(batch)\n        return reply\n\n    GC.reg_callback(\"actor\", actor)\n    GC.Start()\n\n    trainer.episode_start(0)\n\n    for n in eval_iters.iters():\n        GC.Run()\n\n    GC.Stop()\n"
        },
        {
          "name": "eval_minirts.sh",
          "type": "blob",
          "size": 0.419921875,
          "content": "MODEL=$1\nFRAMESKIP=$2\nNUM_EVAL=10000\n\ngame=./rts/game_MC/game model_file=./rts/game_MC/model model=actor_critic python3 eval.py  --num_games 1024 --batchsize 128 --tqdm --load ${MODEL} --gpu 0 --players \"fs=50,type=AI_NN;fs=${FRAMESKIP},type=AI_SIMPLE\" --eval_stats winrate --num_eval $NUM_EVAL --additional_labels id,last_terminal,seq --shuffle_player --num_frames_in_state 1 --greedy --keys_in_reply V #--omit_keys Wt,Wt2,Wt3 #\n"
        },
        {
          "name": "eval_minirts2.sh",
          "type": "blob",
          "size": 0.3642578125,
          "content": "MODEL=$1\nFRAMESKIP=$2\n\ngame=./rts/game_MC/game model_file=./rts/game_MC/model model=actor_critic taskset -c 30-40 python3 eval.py  --num_games 128 --batchsize 32 --tqdm --load ${MODEL} --gpu 4 --fs_opponent ${FRAMESKIP} --latest_start 0 --opponent_type AI_SIMPLE --eval_stats winrate --num_eval 10000 --additional_labels id,last_terminal --arch \"ccpccp;-,-,-,-,-\" --greedy\n"
        },
        {
          "name": "eval_reduced_mcts.py",
          "type": "blob",
          "size": 1.7421875,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import load_env, Evaluator, ArgsProvider, EvalIters\n\nif __name__ == '__main__':\n    evaluator = Evaluator(stats=False)\n    eval_iters = EvalIters()\n    env, args = load_env(os.environ, overrides=dict(actor_only=True), eval_iters=eval_iters, evaluator=evaluator)\n\n    GC = env[\"game\"].initialize_reduced_service()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    mi = env[\"mi\"]\n    mi.add_model(\"actor\", model, cuda=args.gpu is not None, gpu_id=args.gpu)\n\n    def reduced_project(batch):\n        output = mi[\"actor\"].forward(batch.hist(0))\n        eval_iters.stats.feed_batch(batch)\n        return dict(reduced_s=output[\"h\"].data)\n\n    def reduced_forward(batch):\n        b = batch.hist(0)\n        output = mi[\"actor\"].transition(b[\"reduced_s\"], b[\"a\"])\n        return dict(reduced_next_s=output[\"hf\"].data)\n\n    def reduced_predict(batch):\n        b = batch.hist(0)\n        output = mi[\"actor\"].decision(b[\"reduced_s\"])\n        return dict(pi=output[\"pi\"].data, V=output[\"V\"].data)\n\n    def actor(batch):\n        return evaluator.actor(batch)\n\n    evaluator.setup(mi=mi, sampler=env[\"sampler\"])\n    if GC.reg_has_callback(\"actor\"):\n        GC.reg_callback(\"actor\", actor)\n\n    GC.reg_callback(\"reduced_predict\", reduced_predict)\n    GC.reg_callback(\"reduced_forward\", reduced_forward)\n    GC.reg_callback(\"reduced_project\", reduced_project)\n\n    evaluator.episode_start(0)\n    GC.Start()\n\n    for n in eval_iters.iters():\n        GC.Run()\n    GC.Stop()\n\n"
        },
        {
          "name": "eval_selfplay_aivsai.py",
          "type": "blob",
          "size": 1.2060546875,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport argparse\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import *\n\nif __name__ == '__main__':\n    verbose = False\n    runner = SingleProcessRun()\n    evaluators = [ Evaluator(name=\"eval\" + str(i), verbose=verbose) for i in range(2) ]\n    env, all_args = load_env(os.environ, num_models=2, evaluators=evaluators, runner=runner, overrides=dict(actor_only=True))\n\n    GC = env[\"game\"].initialize_selfplay()\n\n    for i, (model_loader, e) in enumerate(zip(env[\"model_loaders\"], evaluators)):\n        model = model_loader.load_model(GC.params)\n        mi = ModelInterface()\n        mi.add_model(\"actor\", model, copy=False)\n        e.setup(sampler=env[\"sampler\"], mi=mi)\n        GC.reg_callback(\"actor%d\" % i, e.actor)\n\n    def summary(i):\n        for e in evaluators:\n            e.episode_summary(i)\n\n    def start(i):\n        for e in evaluators:\n            e.episode_start(i)\n\n    runner.setup(GC, episode_summary=summary, episode_start=start)\n    runner.run()\n\n"
        },
        {
          "name": "ex_elfpy.py",
          "type": "blob",
          "size": 2.7939453125,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\nfrom elf_python import GCWrapper, Simulator\nimport random\nimport tqdm\n\n'''Minimal example that uses the Python version of concurrent environment from ELF'''\n\nclass SimpleGame(Simulator):\n    MAX_STATE = 6\n    def __init__(self, id, desc):\n        super(SimpleGame, self).__init__(id, desc)\n\n    def restart(self):\n        # print(\"[%s] Game restarts. game_counter = %d, seq = %d\" % (self.agent_name, self.game_counter, self.seq))\n        self.state = 0\n\n    @property\n    def terminal(self):\n        # print(\"[%s] Game end. game_counter = %d, seq = %d\" % (self.agent_name, self.game_counter, self.seq))\n        return self.state == SimpleGame.MAX_STATE\n\n    def get_key(self, key):\n        if key == \"s\":\n            # print(\"[%s] Getting state, state = %d\" % (self.agent_name, self.state))\n            return self.state\n        elif key == \"r\":\n            reward = 1 if self.state == 4 else 0\n            # print(\"[%s] Getting reward, reward = %d\" % (self.agent_name, reward))\n            return reward\n        else:\n            raise ValueError(\"Unknown key (in get_key): \" + key)\n\n    def set_key(self, key, value):\n        if key == \"a\":\n            # Get next action, proceed!\n            # print(\"[%s] receiving action = %d\" % (self.agent_name, value))\n            self._forward(value)\n        else:\n            raise ValueError(\"Unknown key (in set_key): \" + key + \" value: \" + str(value))\n\n    def _forward(self, action):\n        if action == 0:\n            self.state += 1\n            if self.state >= SimpleGame.MAX_STATE:\n                self.state = SimpleGame.MAX_STATE\n        elif action == 1:\n            self.state -= 1\n            if self.state < 0:\n                self.state = 0\n\nclass Trainer:\n    def __init__(self):\n        pass\n\n    def train(self, cpu_batch, gpu_batch):\n        pass\n\n    def actor(self, cpu_batch, gpu_batch):\n        # Random\n        batchsize = cpu_batch[0][\"s\"].size(0)\n        action = torch.IntTensor(batchsize)\n        for i in range(batchsize):\n            action[i] = random.randint(0, 1)\n        return dict(a = action)\n\nif __name__ == '__main__':\n    desc = dict(\n        actor=dict(\n            input = dict(s=\"\"),\n            reply = dict(a=\"\"),\n            connector = \"actor-connector\"\n        ),\n        train=dict(\n            input = dict(s=\"\", r=\"\"),\n            reply = None,\n            connector = \"trainer-connector\"\n        )\n    )\n    wrapper = GCWrapper(SimpleGame, desc, 32, 8, 1)\n    trainer = Trainer()\n    wrapper.reg_callback(\"train\", trainer.train)\n    wrapper.reg_callback(\"actor\", trainer.actor)\n\n    for i in tqdm.trange(1000):\n        wrapper.Run()\n\n    print(\"Done\")\n"
        },
        {
          "name": "go",
          "type": "tree",
          "content": null
        },
        {
          "name": "overview.png",
          "type": "blob",
          "size": 255.9033203125,
          "content": null
        },
        {
          "name": "rlpytorch",
          "type": "tree",
          "content": null
        },
        {
          "name": "rts",
          "type": "tree",
          "content": null
        },
        {
          "name": "selfplay.py",
          "type": "blob",
          "size": 1.4365234375,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport argparse\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import *\n\nif __name__ == '__main__':\n    verbose = False\n\n    trainer = Trainer(verbose=verbose)\n    runner = SingleProcessRun()\n    evaluator = Evaluator(stats=False, verbose=verbose)\n    env, all_args = load_env(os.environ, trainer=trainer, runner=runner, evaluator=evaluator)\n\n    GC = env[\"game\"].initialize_selfplay()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    env[\"mi\"].add_model(\"model\", model, opt=True)\n    env[\"mi\"].add_model(\"actor\", model, copy=True, cuda=all_args.gpu is not None, gpu_id=all_args.gpu)\n\n    trainer.setup(sampler=env[\"sampler\"], mi=env[\"mi\"], rl_method=env[\"method\"])\n    evaluator.setup(sampler=env[\"sampler\"], mi=env[\"mi\"].clone(gpu=all_args.gpu))\n\n    if not all_args.actor_only:\n        GC.reg_callback(\"train1\", trainer.train)\n    GC.reg_callback(\"actor1\", trainer.actor)\n    GC.reg_callback(\"actor0\", evaluator.actor)\n\n    def summary(i):\n        trainer.episode_summary(i)\n        evaluator.episode_summary(i)\n\n    def start(i):\n        trainer.episode_start(i)\n        evaluator.episode_start(i)\n\n    runner.setup(GC, episode_summary=summary, episode_start=start)\n    runner.run()\n\n"
        },
        {
          "name": "selfplay_aivsai.sh",
          "type": "blob",
          "size": 0.455078125,
          "content": "game=./rts/game_MC/game model=actor_critic model_file=./rts/game_MC/model python3 eval_selfplay_aivsai.py --num_games 1024 --batchsize 128 --tqdm --players \"fs=50,type=AI_NN;fs=50,type=AI_NN\" --eval0_stats winrate --eval1_stats winrate --additional_labels id,last_terminal,seq --load0 /home/yuandong/private_models/model-winrate-80.0-357800.bin --load1 /home/yuandong/private_models/model-minirts-selfplay-0.5old-0.5simpleai.bin  --gpu 2 --T 1 --shuffle_player \"$@\"\n"
        },
        {
          "name": "selfplay_minirts.sh",
          "type": "blob",
          "size": 0.2978515625,
          "content": "MODEL=$1\n\ngame=./rts/game_MC/game model_file=./rts/game_MC/model model=actor_critic python3 selfplay.py  --num_games 1024 --batchsize 128 --tqdm --players \"fs=50,type=AI_NN;fs=50,type=AI_NN\" --trainer_stats winrate --additional_labels id,last_terminal,seq --load ${MODEL} --gpu 2 --T 20 --shuffle_player \n"
        },
        {
          "name": "train.py",
          "type": "blob",
          "size": 1.0087890625,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\nimport sys\nimport os\n\nfrom rlpytorch import *\n\nif __name__ == '__main__':\n    trainer = Trainer()\n    runner = SingleProcessRun()\n    env, all_args = load_env(os.environ, trainer=trainer, runner=runner)\n\n    GC = env[\"game\"].initialize()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    env[\"mi\"].add_model(\"model\", model, opt=True)\n    env[\"mi\"].add_model(\"actor\", model, copy=True, cuda=all_args.gpu is not None, gpu_id=all_args.gpu)\n\n    trainer.setup(sampler=env[\"sampler\"], mi=env[\"mi\"], rl_method=env[\"method\"])\n\n    GC.reg_callback(\"train\", trainer.train)\n    GC.reg_callback(\"actor\", trainer.actor)\n    runner.setup(GC, episode_summary=trainer.episode_summary,\n                episode_start=trainer.episode_start)\n\n    runner.run()\n\n"
        },
        {
          "name": "train_atari.sh",
          "type": "blob",
          "size": 0.2490234375,
          "content": "ROM=$1\nGPU=$2\n\ngame=./atari/game model=actor_critic model_file=./atari/model python3 train.py --rom_file $ROM --batchsize 4 --freq_update 1 --num_games 16 --tqdm --gpu $GPU --trainer_stats rewards --additional_labels id,last_terminal --keys_in_reply V,rv\n"
        },
        {
          "name": "train_df.sh",
          "type": "blob",
          "size": 0.212890625,
          "content": "game=./go/game model=df_policy model_file=./go/df_model python3 train.py --batchsize 128 --freq_update 1 --num_games 512 --T 1 --tqdm --list_file /home/yuandong/local/go/go_gogod/train.lst --trainer_stats rewards \"$@\"\n"
        },
        {
          "name": "train_lstm.py",
          "type": "blob",
          "size": 1.1416015625,
          "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport argparse\nfrom datetime import datetime\n\nimport sys\nimport os\n\nfrom rlpytorch import LSTMTrainer, Sampler, SingleProcessRun, load_env, ModelLoader, ArgsProvider, ModelInterface\n\nif __name__ == '__main__':\n    trainer = LSTMTrainer()\n    runner = SingleProcessRun()\n    env, all_args = load_env(os.environ, trainer=trainer, runner=runner)\n\n    GC = env[\"game\"].initialize()\n\n    model = env[\"model_loaders\"][0].load_model(GC.params)\n    mi = ModelInterface()\n    mi.add_model(\"model\", model, optim_params={ \"lr\" : 0.001})\n    mi.add_model(\"actor\", model, copy=True, cuda=all_args.gpu is not None, gpu_id=all_args.gpu)\n\n    trainer.setup(sampler=env[\"sampler\"], mi=mi, rl_method=env[\"method\"])\n\n    GC.reg_callback(\"train\", trainer.train)\n    GC.reg_callback(\"actor\", trainer.actor)\n    runner.setup(GC, episode_summary=trainer.episode_summary,\n                episode_start=trainer.episode_start)\n\n    runner.run()\n\n"
        },
        {
          "name": "train_minirts.sh",
          "type": "blob",
          "size": 0.3359375,
          "content": "#!/bin/bash\n\ngame=./rts/game_MC/game model=actor_critic model_file=./rts/game_MC/model python3 train.py --batchsize 128 --freq_update 1 --players \"type=AI_NN,fs=50,args=backup/AI_SIMPLE|start/500|decay/0.99;type=AI_SIMPLE,fs=20\" --num_games 1024 --tqdm --T 20 --additional_labels id,last_terminal --trainer_stats winrate --keys_in_reply V \"$@\"\n"
        },
        {
          "name": "train_minirts_unitcmd.sh",
          "type": "blob",
          "size": 0.314453125,
          "content": "game=./rts/game_MC/game model=actor_critic model_file=./rts/game_MC/model_unit_cmd python3 train.py --batchsize 128 --freq_update 1 --players \"type=AI_NN,fs=50,args=backup/AI_SIMPLE|start/500|decay/0.99;type=AI_SIMPLE,fs=20\" --num_games 1024 --tqdm --T 20 --additional_labels id,last_terminal --trainer_stats winrate \"$@\"\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}