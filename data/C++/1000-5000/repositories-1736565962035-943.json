{
  "metadata": {
    "timestamp": 1736565962035,
    "page": 943,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tsoding/olive.c",
      "stars": 1923,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "*.ppm\nbuild/\n*.swp\nnobuild\nnobuild.old"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "Copyright 2022 Alexey Kutepov <reximkut@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.4833984375,
          "content": "# Olive.c\n\n<p align=\"center\">\n<a href=\"https://tsoding.github.io/olive.c/\"><img src=\"./assets/olivec-200.png\"></a>\n</p>\n\n> [!WARNING]\n> THIS LIBRARY IS A WORK IN PROGRESS! ANYTHING CAN CHANGE AT ANY MOMENT WITHOUT ANY NOTICE! USE THIS LIBRARY AT YOUR OWN RISK!\n\nSimple graphics library that does not have any dependencies and renders everything into the given memory pixel by pixel.\n\nVisit [https://tsoding.github.io/olive.c/](https://tsoding.github.io/olive.c/) to see some demos.\n\nThe library is not concerned with displaying the image. It only fills up the memory with pixels. It's up to you what to do with those pixels.\n\nThe name is pronounced as \"olivets'\" which is a Ukrainian word for \"pencil\" ([\"олівець\"](https://translate.google.com/?sl=uk&tl=en&text=%D0%BE%D0%BB%D1%96%D0%B2%D0%B5%D1%86%D1%8C&op=translate)).\n\nThe library itself does not require any special building. You can simply copy-paste [./olive.c](./olive.c) to your project and `#include` it. (Because the truly reusable code is the one that you can simply copy-paste).\n\nOlive.c is a classical [stb-style](https://github.com/nothings/stb) single header library. That is by default it acts like a header, but if you `#define OLIVEC_IMPLEMENTATION` prior including the library it acts like a source file. The `.c` extension might be confusing, but it's a part of the name of the library (why JavaScript people can use `.js` as part of the name of a library and I cannot?)\n\n## Quick Example (Flag of Japan)\n\n> [!WARNING]\n> Always initialize your Canvas with a color that has Non-Zero Alpha Channel! A lot of functions use `olivec_blend_color()` function to blend with the Background which preserves the original Alpha of the Background. So you may easily end up with a result that is perceptually transparent if the Alpha is Zero.\n\n*This example also uses [stb_image_write.h](https://raw.githubusercontent.com/nothings/stb/master/stb_image_write.h) to create the PNG image*\n\n```c\n// flag_jp.c\n#define OLIVEC_IMPLEMENTATION\n#include \"olive.c\"\n\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#include \"stb_image_write.h\"\n\n#define WIDTH 900\n#define HEIGHT 600\n\nuint32_t pixels[WIDTH*HEIGHT];\n\nint main(void)\n{\n    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);\n    // Taken from https://upload.wikimedia.org/wikipedia/en/9/9e/Flag_of_Japan.svg\n    olivec_fill(oc, 0xFFFFFFFF);\n    olivec_circle(oc, WIDTH/2, HEIGHT/2, 180, 0xFF2D00BC);\n\n    const char *file_path = \"flag_jp.png\";\n    if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, sizeof(uint32_t)*WIDTH)) {\n        fprintf(stderr, \"ERROR: could not write %s\\n\", file_path);\n        return 1;\n    }\n    return 0;\n}\n```\n\n## Building the Tests and Demos\n\nEven though the library does not require any special building, the tests and demos do. We use [nobuild](https://github.com/tsoding/nobuild) build system:\n\n```console\n$ clang -o nobuild nobuild.c\n$ ./nobuild\n```\n\n## Tests\n\nRun the tests:\n\n```console\n$ ./build/test run\n```\n\nIf the expected behavior of the library has changed in the way that breaks current test cases, you probably want to update them:\n\n```console\n$ ./build/test update\n```\n\nFor more info see the help:\n\n```console\n$ ./build/test help\n```\n\n## Demos\n\nThe source code for demos is located at [demos](./demos/). Each demo is compiled for 3 different \"platforms\" that is 3 different ways to display the generated images:\n\n1. [SDL](https://www.libsdl.org/) -- displays the images via [SDL_Texture](https://wiki.libsdl.org/SDL_Texture).\n2. Terminal -- converts the images into ASCII art and prints them into the terminal.\n3. WASM -- displays the images in [HTML5 canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)\n\nTo run the SDL version of a demo do\n\n```console\n$ ./build/demos/<demo>.sdl\n```\n\nTo run the Terminal version of a demo do\n\n```console\n$ ./build/demos/<demo>.term\n```\n\nTo run the WASM versions of the demos from [https://tsoding.github.io/olive.c/](https://tsoding.github.io/olive.c/) locally do\n\n```console\n$ python3 -m http.server 6969\n$ iexplore.exe http://localhost:6969/\n```\n\n### Virtual Console\n\nThe support for several platforms is provided by Demo Virtual Console. It is implemented in two files:\n\n- [./demos/vc.c](./demos/vc.c) -- the C runtime required by all platforms.\n- [./js/vc.js](./js/vc.js) -- the JavaScript runtime for running in a browser when compiled to WebAssembly.\n\nThe Demo Virtual Console is not part of the main library and is designed specifically for demos. (I do consider including it into the main library, 'cause it looks pretty useful. The library is still in development).\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "css",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "dev-deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 4.6748046875,
          "content": "<html>\n  <head>\n    <title>Olive.c</title>\n    <link rel=\"stylesheet\" href=\"css/reset.css\" />\n    <link rel=\"stylesheet\" href=\"css/index.css\" />\n  </head>\n  <body>\n    <h1>Olive.c Demos</h1>\n    <p>Olive.c is a simple graphics library that does not have any dependencies and renders everything into the given memory pixel by pixel.</p>\n    <p>Below is a bunch of demos written in C using this library compiled to WebAssembly. Every frame of the animations is generated pixel by pixel on CPU without using any special GPU APIs like OpenGL, Metal, etc. </p>\n    <p>The source code of the library and the demos is available on GitHub: <a href=\"https://github.com/tsoding/olive.c\">https://github.com/tsoding/olive.c</a></p>\n\n    <div id=\"sec-triangle\">\n      <h2 id=\"demo-triangle\"><a href=\"#demo-triangle\">Triangle</a></h2>\n      <p>Rainbow triangle together with a transparent circle. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/triangle.c\">demos/triangle.c</a></p>\n      <canvas id=\"app-triangle\"></canvas>\n    </div>\n\n    <div id=\"sec-dots3d\">\n      <h2 id=\"demo-dots3d\"><a href=\"#demo-dots3d\">Dots 3D</a></h2>\n      <p>A bunch of 3D dots projected onto your 2D screen plus a text with a builtin monospaced font. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/dots3d.c\">demos/dots3d.c</a></p>\n      <canvas id=\"app-dots3d\"></canvas>\n    </div>\n\n    <div id=\"sec-squish\">\n      <h2 id=\"demo-squish\"><a href=\"#demo-squish\">Squish</a></h2>\n      <p>Resizing images on the fly. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/squish.c\">demos/squish.c</a></p>\n      <canvas id=\"app-squish\"></canvas>\n    </div>\n\n    <div id=\"sec-triangle3d\">\n      <h2 id=\"demo-triangle3d\"><a href=\"#demo-triangle3d\">Triangle 3D</a></h2>\n      <p>Rotating rainbow triangle in 3D. Unlike <a href=\"#demo-3d\">3D dots above</a> this is a solid shape. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/triangle3d.c\">demos/triangle3d.c</a></p>\n      <canvas id=\"app-triangle3d\"></canvas>\n    </div>\n\n    <div id=\"sec-triangleTex\">\n      <h2 id=\"demo-triangleTex\"><a href=\"#demo-triangleTex\">Rotating 2D Textures</a></h2>\n      <p>Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/triangleTex.c\">demos/triangleTex.c</a></p>\n      <canvas id=\"app-triangleTex\"></canvas>\n    </div>\n\n    <div id=\"sec-triangle3dTex\">\n      <h2 id=\"demo-triangle3dTex\"><a href=\"#demo-triangle3dTex\">Rotating 3D Textures</a></h2>\n      <p>Textures by <a href=\"https://opengameart.org/content/handpainted-stone-texture\">MELLE</a>. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/triangle3dTex.c\">demos/triangle3dTex.c</a></p>\n      <canvas id=\"app-triangle3dTex\"></canvas>\n    </div>\n\n    <div id=\"sec-cup3d\">\n      <h2 id=\"demo-cup3d\"><a href=\"#demo-cup3d\">Cup 3D</a></h2>\n      <p>Design by <a href=\"https://github.com/rexim\">rexim</a>. 3D model by <a href=\"https://github.com/kolumb\">kolumb</a>. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/cup3d.c\">demos/cup3d.c</a></p>\n      <canvas id=\"app-cup3d\"></canvas>\n    </div>\n\n    <div id=\"sec-teapot3d\">\n      <h2 id=\"demo-teapot3d\"><a href=\"#demo-teapot3d\">Utah Teapot</a></h2>\n      <p>Famous <a href=\"https://en.wikipedia.org/wiki/Utah_teapot\">Utah Teapot</a>. Model by <a href=\"https://graphics.stanford.edu/courses/cs148-10-summer/as3/code/as3/teapot.obj\">Standford University</a>. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/teapot3d.c\">demos/teapot3d.c</a></p>\n      <p>(I have no idea why it runs with a reasonable FPS)</p>\n      <canvas id=\"app-teapot3d\"></canvas>\n    </div>\n\n    <div id=\"sec-penger3d\">\n      <h2 id=\"demo-penger3d\"><a href=\"#demo-penger3d\">Penger</a></h2>\n      <p><a href=\"https://penger.neocities.org/\">Penger</a> - The Mascot of Tsoding Discord Community. The character design by <a href=\"https://github.com/LainLayer\">LainLayer</a>. The model by <a href=\"https://github.com/Max-Kawula\">Max-Kawula</a>. Source:&nbsp;<a href=\"https://github.com/tsoding/olive.c/blob/master/demos/penger3d.c\">demos/penger3d.c</a></p>\n      <canvas id=\"app-penger3d\"></canvas>\n    </div>\n\n    <script src=\"js/vc.js\"></script>\n    <script>\n      startDemo(\"triangle\", \"./wasm/triangle.wasm\");\n      startDemo(\"dots3d\", \"./wasm/dots3d.wasm\");\n      startDemo(\"squish\", \"./wasm/squish.wasm\");\n      startDemo(\"triangle3d\", \"./wasm/triangle3d.wasm\");\n      startDemo(\"triangleTex\", \"./wasm/triangleTex.wasm\");\n      startDemo(\"triangle3dTex\", \"./wasm/triangle3dTex.wasm\");\n      startDemo(\"cup3d\", \"./wasm/cup3d.wasm\");\n      startDemo(\"teapot3d\", \"./wasm/teapot3d.wasm\");\n      startDemo(\"penger3d\", \"./wasm/penger3d.wasm\");\n    </script>\n  </body>\n</html>\n"
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "nobuild.c",
          "type": "blob",
          "size": 10.306640625,
          "content": "#define NOBUILD_IMPLEMENTATION\n#include \"./nobuild.h\"\n\n#define COMMON_CFLAGS \"-Wall\", \"-Wextra\", \"-pedantic\", \"-std=c11\", \"-ggdb\", \"-I.\", \"-I./build/\", \"-I./dev-deps/\"\n\nvoid build_tools(void)\n{\n    MKDIRS(\"build\", \"tools\");\n    CMD(\"clang\", COMMON_CFLAGS, \"-o\", \"./build/tools/png2c\", \"./tools/png2c.c\", \"-lm\");\n    CMD(\"clang\", COMMON_CFLAGS, \"-o\", \"./build/tools/obj2c\", \"./tools/obj2c.c\", \"-lm\");\n}\n\nvoid build_assets(void)\n{\n    MKDIRS(\"build\", \"assets\");\n    CMD(\"./build/tools/png2c\", \"-n\", \"tsodinPog\", \"-o\", \"./build/assets/tsodinPog.c\", \"./assets/tsodinPog.png\");\n    CMD(\"./build/tools/png2c\", \"-n\", \"tsodinCup\", \"-o\", \"./build/assets/tsodinCup.c\", \"./assets/tsodinCup.png\");\n    CMD(\"./build/tools/png2c\", \"-n\", \"oldstone\", \"-o\", \"./build/assets/oldstone.c\", \"./assets/oldstone.png\");\n    CMD(\"./build/tools/png2c\", \"-n\", \"lavastone\", \"-o\", \"./build/assets/lavastone.c\", \"./assets/lavastone.png\");\n    CMD(\"./build/tools/obj2c\", \"-o\", \"./build/assets/tsodinCupLowPoly.c\", \"./assets/tsodinCupLowPoly.obj\");\n    CMD(\"./build/tools/obj2c\", \"-s\", \"0.40\", \"-o\", \"./build/assets/utahTeapot.c\", \"./assets/utahTeapot.obj\");\n    CMD(\"./build/tools/obj2c\", \"-s\", \"1.5\", \"-o\", \"./build/assets/penger.c\", \"./assets/penger_obj/penger.obj\");\n}\n\nvoid build_tests(void)\n{\n    CMD(\"clang\", COMMON_CFLAGS, \"-fsanitize=memory\", \"-o\", \"./build/test\", \"test.c\", \"-lm\");\n}\n\n// TODO: move copy_file to nobuild.h\n// Maybe even use platform dependent APIs to make it better.\nvoid copy_file(const char *src_file_path, const char *dst_file_path)\n{\n    INFO(\"Copying %s -> %s\", src_file_path, dst_file_path);\n    size_t buffer_sz = 32*1024;\n    char *buffer = malloc(buffer_sz);\n    if (buffer == NULL) {\n        PANIC(\"Could not allocate memory to copy file %s -> %s\", src_file_path, dst_file_path);\n    }\n\n    FILE *src = fopen(src_file_path, \"rb\");\n    if (src == NULL) {\n        PANIC(\"Could not open file %s for reading: %s\", src_file_path, strerror(errno));\n    }\n    FILE *dst = fopen(dst_file_path, \"wb\");\n    if (dst == NULL) {\n        PANIC(\"Could not open file %s for writing: %s\", dst_file_path, strerror(errno));\n    }\n    while (!feof(src)) {\n        size_t n = fread(buffer, 1, buffer_sz, src);\n        if (ferror(src)) {\n            PANIC(\"Could not read from file %s: %s\", src_file_path, strerror(errno));\n        }\n        size_t m = 0;\n        while (m < n) {\n            m += fwrite(buffer + m, 1, n - m, dst);\n            if (ferror(dst)) {\n                PANIC(\"Could not write to file %s: %s\", dst_file_path, strerror(errno));\n            }\n        }\n    }\n    if (fclose(dst) < 0) PANIC(\"Could not close file %s: %s\", dst_file_path, strerror(errno));\n    if (fclose(src) < 0) PANIC(\"Could not close file %s: %s\", src_file_path, strerror(errno));\n}\n\nPid build_wasm_demo(const char *name)\n{\n    Cmd cmd = {\n        .line = cstr_array_make(\"clang\", COMMON_CFLAGS, \"-O2\", \"-fno-builtin\", \"--target=wasm32\", \"--no-standard-libraries\", \"-Wl,--no-entry\", \"-Wl,--export=vc_render\", \"-Wl,--export=__heap_base\", \"-Wl,--allow-undefined\", \"-o\", CONCAT(\"./build/demos/\", name, \".wasm\"), \"-DVC_PLATFORM=VC_WASM_PLATFORM\", CONCAT(\"./demos/\", name, \".c\"), NULL)\n    };\n    INFO(\"CMD: %s\", cmd_show(cmd));\n    return cmd_run_async(cmd, NULL, NULL);\n}\n\nPid build_term_demo(const char *name)\n{\n    Cmd cmd = {\n        .line = cstr_array_make(\"clang\", COMMON_CFLAGS, \"-O2\", \"-o\", CONCAT(\"./build/demos/\", name, \".term\"), \"-DVC_PLATFORM=VC_TERM_PLATFORM\", \"-D_XOPEN_SOURCE=600\", CONCAT(\"./demos/\", name, \".c\"), \"-lm\", NULL)\n    };\n    INFO(\"CMD: %s\", cmd_show(cmd));\n    return cmd_run_async(cmd, NULL, NULL);\n}\n\nPid build_sdl_demo(const char *name)\n{\n    Cmd cmd = {\n        .line = cstr_array_make(\"clang\", COMMON_CFLAGS, \"-O2\", \"-o\", CONCAT(\"./build/demos/\", name, \".sdl\"), \"-DVC_PLATFORM=VC_SDL_PLATFORM\", CONCAT(\"./demos/\", name, \".c\"), \"-lm\", \"-lSDL2\", NULL)\n    };\n    INFO(\"CMD: %s\", cmd_show(cmd));\n    return cmd_run_async(cmd, NULL, NULL);\n}\n\n// TODO: move struct Pids, pids_wait() and da_append() to nobuild.h\n\ntypedef struct {\n    Pid *items;\n    size_t count;\n    size_t capacity;\n} Pids;\n\nvoid pids_wait(Pids pids)\n{\n    for (size_t i = 0; i < pids.count; ++i) {\n        pid_wait(pids.items[i]);\n    }\n}\n\n#define DA_INIT_CAPACITY 8192\n#define DA_REALLOC(oldptr, oldsz, newsz) realloc(oldptr, newsz)\n#define da_append(da, item)                                                 \\\n    do {                                                                    \\\n        if ((da)->count >= (da)->capacity) {                                \\\n            size_t new_capacity = (da)->capacity*2;                         \\\n            if (new_capacity == 0) {                                        \\\n                new_capacity = DA_INIT_CAPACITY;                            \\\n            }                                                               \\\n                                                                            \\\n            (da)->items = DA_REALLOC((da)->items,                           \\\n                                     (da)->capacity*sizeof((da)->items[0]), \\\n                                     new_capacity*sizeof((da)->items[0]));  \\\n            (da)->capacity = new_capacity;                                  \\\n        }                                                                   \\\n                                                                            \\\n        (da)->items[(da)->count++] = (item);                                \\\n    } while (0)\n\nvoid build_vc_demo(const char *name, Pids *pids)\n{\n    da_append(pids, build_wasm_demo(name));\n    da_append(pids, build_term_demo(name));\n    da_append(pids, build_sdl_demo(name));\n}\n\nvoid build_all_vc_demos(void)\n{\n    MKDIRS(\"build\", \"demos\");\n    const char *names[] = {\n        \"triangle\",\n        \"dots3d\",\n        \"squish\",\n        \"triangle3d\",\n        \"triangleTex\",\n        \"triangle3dTex\",\n        \"cup3d\",\n        \"teapot3d\",\n        \"penger3d\",\n    };\n    size_t names_sz = sizeof(names)/sizeof(names[0]);\n    size_t thread_count = 6;\n\n    Pids pids = {0};\n    for (size_t i = 0; i < names_sz; ++i) {\n        build_vc_demo(names[i], &pids);\n        if (pids.count >= thread_count) {\n            pids_wait(pids);\n            pids.count = 0;\n        }\n    }\n    pids_wait(pids);\n\n    for (size_t i = 0; i < names_sz; ++i) {\n        copy_file(CONCAT(\"./build/demos/\", names[i], \".wasm\"), CONCAT(\"./wasm/\", names[i], \".wasm\"));\n    }\n}\n\nvoid usage(const char *program)\n{\n    INFO(\"Usage: %s [<subcommand>]\", program);\n    INFO(\"Subcommands:\");\n    INFO(\"    tools\");\n    INFO(\"        Build all the tools. Things like png2c, obj2c, etc.\");\n    INFO(\"    assets\");\n    INFO(\"        Build the assets in the assets/ folder.\");\n    INFO(\"        Basically convert their data to C code so we can bake them in demos.\");\n    INFO(\"    test[s] [<args>]\");\n    INFO(\"        Build and run test.c\");\n    INFO(\"        If <args> are provided the test utility is run with them.\");\n    INFO(\"    demos [<platform>] [run]\");\n    INFO(\"        Build demos.\");\n    INFO(\"        Available platforms are: sdl, term, or wasm.\");\n    INFO(\"        Optional [run] runs the demo after the build.\");\n    INFO(\"        [run] is not available for wasm platform.\");\n    INFO(\"    help\");\n    INFO(\"         Print this message\");\n}\n\nint main(int argc, char **argv)\n{\n    GO_REBUILD_URSELF(argc, argv);\n\n    const char *program = shift_args(&argc, &argv);\n\n    if (argc > 0) {\n        const char *subcmd = shift_args(&argc, &argv);\n        if (strcmp(subcmd, \"tools\") == 0) {\n            build_tools();\n        } else if (strcmp(subcmd, \"assets\") == 0) {\n            build_assets();\n        } else if (strcmp(subcmd, \"tests\") == 0 || strcmp(subcmd, \"test\") == 0) {\n            build_tests();\n            if (argc > 0) {\n                Cmd cmd = {0};\n                cmd.line = cstr_array_append(cmd.line, \"./build/test\");\n                for (int i = 0; i < argc; ++i) {\n                    cmd.line = cstr_array_append(cmd.line, argv[i]);\n                }\n                cmd.line = cstr_array_append(cmd.line, NULL);\n                cmd_run_sync(cmd);\n            }\n        } else if (strcmp(subcmd, \"demos\") == 0) {\n            if (argc > 0) {\n                const char *name = shift_args(&argc, &argv);\n\n                if (argc > 0) {\n                    const char *platform = shift_args(&argc, &argv);\n                    if (strcmp(platform, \"sdl\") == 0) {\n                        pid_wait(build_sdl_demo(name));\n\n                        if (argc > 0) {\n                            const char *run = shift_args(&argc, &argv);\n                            if (strcmp(run, \"run\") != 0) {\n                                usage(program);\n                                PANIC(\"unknown action `%s` for SDL demo: %s\", run, name);\n                            }\n                            CMD(CONCAT(\"./build/demos/\", name, \".sdl\"));\n                        }\n                    } else if (strcmp(platform, \"term\") == 0) {\n                        pid_wait(build_term_demo(name));\n\n                        if (argc > 0) {\n                            const char *run = shift_args(&argc, &argv);\n                            if (strcmp(run, \"run\") != 0) {\n                                usage(program);\n                                PANIC(\"unknown action `%s` for Terminal demo: %s\", run, name);\n                            }\n                            CMD(CONCAT(\"./build/demos/\", name, \".term\"));\n                        }\n                    } else if (strcmp(platform, \"wasm\") == 0) {\n                        pid_wait(build_wasm_demo(name));\n                        copy_file(CONCAT(\"./build/demos/\", name, \".wasm\"), CONCAT(\"./wasm/\", name, \".wasm\"));\n                    } else {\n                        usage(program);\n                        PANIC(\"unknown demo platform %s\", platform);\n                    }\n                } else {\n                    Pids pids = {0};\n                    build_vc_demo(name, &pids);\n                    pids_wait(pids);\n                    copy_file(CONCAT(\"./build/demos/\", name, \".wasm\"), CONCAT(\"./wasm/\", name, \".wasm\"));\n                }\n            } else {\n                build_all_vc_demos();\n            }\n        } else if(strcmp(subcmd, \"help\") == 0) {\n            usage(program);\n        } else {\n            usage(program);\n            PANIC(\"Unknown command `%s`\", subcmd);\n        }\n    } else {\n        build_tools();\n        build_assets();\n        build_tests();\n        build_all_vc_demos();\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "nobuild.h",
          "type": "blob",
          "size": 31.421875,
          "content": "#ifndef NOBUILD_H_\n#define NOBUILD_H_\n\n#ifndef _WIN32\n#    define _POSIX_C_SOURCE 200809L\n#    include <sys/types.h>\n#    include <sys/wait.h>\n#    include <sys/stat.h>\n#    include <unistd.h>\n#    include <dirent.h>\n#    include <fcntl.h>\n#    define PATH_SEP \"/\"\ntypedef pid_t Pid;\ntypedef int Fd;\n#else\n#    define WIN32_MEAN_AND_LEAN\n#    include \"windows.h\"\n#    include <process.h>\n#    define PATH_SEP \"\\\\\"\ntypedef HANDLE Pid;\ntypedef HANDLE Fd;\n// minirent.h HEADER BEGIN ////////////////////////////////////////\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// ============================================================\n//\n// minirent — 0.0.1 — A subset of dirent interface for Windows.\n//\n// https://github.com/tsoding/minirent\n//\n// ============================================================\n//\n// ChangeLog (https://semver.org/ is implied)\n//\n//    0.0.1 First Official Release\n\n#ifndef MINIRENT_H_\n#define MINIRENT_H_\n\n#define WIN32_LEAN_AND_MEAN\n#include \"windows.h\"\n\nstruct dirent {\n    char d_name[MAX_PATH+1];\n};\n\ntypedef struct DIR DIR;\n\nDIR *opendir(const char *dirpath);\nstruct dirent *readdir(DIR *dirp);\nint closedir(DIR *dirp);\n\n#endif  // MINIRENT_H_\n// minirent.h HEADER END ////////////////////////////////////////\n\n// TODO(#28): use GetLastErrorAsString everywhere on Windows error reporting\nLPSTR GetLastErrorAsString(void);\n\n#endif  // _WIN32\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n\n#define FOREACH_ARRAY(type, elem, array, body)  \\\n    for (size_t elem_##index = 0;                           \\\n         elem_##index < array.count;                        \\\n         ++elem_##index)                                    \\\n    {                                                       \\\n        type *elem = &array.elems[elem_##index];            \\\n        body;                                               \\\n    }\n\ntypedef const char * Cstr;\n\nint cstr_ends_with(Cstr cstr, Cstr postfix);\n#define ENDS_WITH(cstr, postfix) cstr_ends_with(cstr, postfix)\n\nCstr cstr_no_ext(Cstr path);\n#define NOEXT(path) cstr_no_ext(path)\n\ntypedef struct {\n    Cstr *elems;\n    size_t count;\n} Cstr_Array;\n\nCstr_Array cstr_array_make(Cstr first, ...);\nCstr_Array cstr_array_append(Cstr_Array cstrs, Cstr cstr);\nCstr cstr_array_join(Cstr sep, Cstr_Array cstrs);\n\n#define JOIN(sep, ...) cstr_array_join(sep, cstr_array_make(__VA_ARGS__, NULL))\n#define CONCAT(...) JOIN(\"\", __VA_ARGS__)\n#define PATH(...) JOIN(PATH_SEP, __VA_ARGS__)\n\ntypedef struct {\n    Fd read;\n    Fd write;\n} Pipe;\n\nPipe pipe_make(void);\n\ntypedef struct {\n    Cstr_Array line;\n} Cmd;\n\nFd fd_open_for_read(Cstr path);\nFd fd_open_for_write(Cstr path);\nvoid fd_close(Fd fd);\nvoid pid_wait(Pid pid);\nCstr cmd_show(Cmd cmd);\nPid cmd_run_async(Cmd cmd, Fd *fdin, Fd *fdout);\nvoid cmd_run_sync(Cmd cmd);\n\ntypedef struct {\n    Cmd *elems;\n    size_t count;\n} Cmd_Array;\n\n// TODO(#1): no way to disable echo in nobuild scripts\n// TODO(#2): no way to ignore fails\n#define CMD(...)                                        \\\n    do {                                                \\\n        Cmd cmd = {                                     \\\n            .line = cstr_array_make(__VA_ARGS__, NULL)  \\\n        };                                              \\\n        INFO(\"CMD: %s\", cmd_show(cmd));                 \\\n        cmd_run_sync(cmd);                              \\\n    } while (0)\n\ntypedef enum {\n    CHAIN_TOKEN_END = 0,\n    CHAIN_TOKEN_IN,\n    CHAIN_TOKEN_OUT,\n    CHAIN_TOKEN_CMD\n} Chain_Token_Type;\n\n// A single token for the CHAIN(...) DSL syntax\ntypedef struct {\n    Chain_Token_Type type;\n    Cstr_Array args;\n} Chain_Token;\n\n// TODO(#17): IN and OUT are already taken by WinAPI\n#define IN(path) \\\n    (Chain_Token) { \\\n        .type = CHAIN_TOKEN_IN, \\\n        .args = cstr_array_make(path, NULL) \\\n    }\n\n#define OUT(path) \\\n    (Chain_Token) { \\\n        .type = CHAIN_TOKEN_OUT, \\\n        .args = cstr_array_make(path, NULL) \\\n    }\n\n#define CHAIN_CMD(...) \\\n    (Chain_Token) { \\\n        .type = CHAIN_TOKEN_CMD, \\\n        .args = cstr_array_make(__VA_ARGS__, NULL) \\\n    }\n\n// TODO(#20): pipes do not allow redirecting stderr\ntypedef struct {\n    Cstr input_filepath;\n    Cmd_Array cmds;\n    Cstr output_filepath;\n} Chain;\n\nChain chain_build_from_tokens(Chain_Token first, ...);\nvoid chain_run_sync(Chain chain);\nvoid chain_echo(Chain chain);\n\n// TODO(#15): PIPE does not report where exactly a syntactic error has happened\n#define CHAIN(...)                                                      \\\n    do {                                                                \\\n        Chain chain = chain_build_from_tokens(__VA_ARGS__, (Chain_Token) {0}); \\\n        chain_echo(chain);                                              \\\n        chain_run_sync(chain);                                          \\\n    } while(0)\n\n#ifndef REBUILD_URSELF\n#  if _WIN32\n#    if defined(__GNUC__)\n#       define REBUILD_URSELF(binary_path, source_path) CMD(\"gcc\", \"-o\", binary_path, source_path)\n#    elif defined(__clang__)\n#       define REBUILD_URSELF(binary_path, source_path) CMD(\"clang\", \"-o\", binary_path, source_path)\n#    elif defined(_MSC_VER)\n#       define REBUILD_URSELF(binary_path, source_path) CMD(\"cl.exe\", source_path)\n#    endif\n#  else\n#    define REBUILD_URSELF(binary_path, source_path) CMD(\"cc\", \"-o\", binary_path, source_path)\n#  endif\n#endif\n\n// Go Rebuild Urself™ Technology\n//\n//   How to use it:\n//     int main(int argc, char** argv) {\n//         GO_REBUILD_URSELF(argc, argv);\n//         // actual work\n//         return 0;\n//     }\n//\n//   After your added this macro every time you run ./nobuild it will detect\n//   that you modified its original source code and will try to rebuild itself\n//   before doing any actual work. So you only need to bootstrap your build system\n//   once.\n//\n//   The modification is detected by comparing the last modified times of the executable\n//   and its source code. The same way the make utility usually does it.\n//\n//   The rebuilding is done by using the REBUILD_URSELF macro which you can redefine\n//   if you need a special way of bootstraping your build system. (which I personally\n//   do not recommend since the whole idea of nobuild is to keep the process of bootstrapping\n//   as simple as possible and doing all of the actual work inside of the nobuild)\n//\n#define GO_REBUILD_URSELF(argc, argv)                                  \\\n    do {                                                               \\\n        const char *source_path = __FILE__;                            \\\n        assert(argc >= 1);                                             \\\n        const char *binary_path = argv[0];                             \\\n                                                                       \\\n        if (is_path1_modified_after_path2(source_path, binary_path)) { \\\n            RENAME(binary_path, CONCAT(binary_path, \".old\"));          \\\n            REBUILD_URSELF(binary_path, source_path);                  \\\n            Cmd cmd = {                                                \\\n                .line = {                                              \\\n                    .elems = (Cstr*) argv,                             \\\n                    .count = argc,                                     \\\n                },                                                     \\\n            };                                                         \\\n            INFO(\"CMD: %s\", cmd_show(cmd));                            \\\n            cmd_run_sync(cmd);                                         \\\n            exit(0);                                                   \\\n        }                                                              \\\n    } while(0)\n// The implementation idea is stolen from https://github.com/zhiayang/nabs\n\nvoid rebuild_urself(const char *binary_path, const char *source_path);\n\nint path_is_dir(Cstr path);\n#define IS_DIR(path) path_is_dir(path)\n\nint path_exists(Cstr path);\n#define PATH_EXISTS(path) path_exists(path)\n\nvoid path_mkdirs(Cstr_Array path);\n#define MKDIRS(...)                                             \\\n    do {                                                        \\\n        Cstr_Array path = cstr_array_make(__VA_ARGS__, NULL);   \\\n        INFO(\"MKDIRS: %s\", cstr_array_join(PATH_SEP, path));    \\\n        path_mkdirs(path);                                      \\\n    } while (0)\n\nvoid path_rename(Cstr old_path, Cstr new_path);\n#define RENAME(old_path, new_path)                    \\\n    do {                                              \\\n        INFO(\"RENAME: %s -> %s\", old_path, new_path); \\\n        path_rename(old_path, new_path);              \\\n    } while (0)\n\nvoid path_rm(Cstr path);\n#define RM(path)                                \\\n    do {                                        \\\n        INFO(\"RM: %s\", path);                   \\\n        path_rm(path);                          \\\n    } while(0)\n\n#define FOREACH_FILE_IN_DIR(file, dirpath, body)        \\\n    do {                                                \\\n        struct dirent *dp = NULL;                       \\\n        DIR *dir = opendir(dirpath);                    \\\n        if (dir == NULL) {                              \\\n            PANIC(\"could not open directory %s: %s\",    \\\n                  dirpath, strerror(errno));            \\\n        }                                               \\\n        errno = 0;                                      \\\n        while ((dp = readdir(dir))) {                   \\\n            const char *file = dp->d_name;              \\\n            body;                                       \\\n        }                                               \\\n                                                        \\\n        if (errno > 0) {                                \\\n            PANIC(\"could not read directory %s: %s\",    \\\n                  dirpath, strerror(errno));            \\\n        }                                               \\\n                                                        \\\n        closedir(dir);                                  \\\n    } while(0)\n\n#if defined(__GNUC__) || defined(__clang__)\n// https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html\n#define NOBUILD_PRINTF_FORMAT(STRING_INDEX, FIRST_TO_CHECK) __attribute__ ((format (printf, STRING_INDEX, FIRST_TO_CHECK)))\n#else\n#define NOBUILD_PRINTF_FORMAT(STRING_INDEX, FIRST_TO_CHECK)\n#endif\n\nvoid VLOG(FILE *stream, Cstr tag, Cstr fmt, va_list args);\nvoid INFO(Cstr fmt, ...) NOBUILD_PRINTF_FORMAT(1, 2);\nvoid WARN(Cstr fmt, ...) NOBUILD_PRINTF_FORMAT(1, 2);\nvoid ERRO(Cstr fmt, ...) NOBUILD_PRINTF_FORMAT(1, 2);\nvoid PANIC(Cstr fmt, ...) NOBUILD_PRINTF_FORMAT(1, 2);\n\nchar *shift_args(int *argc, char ***argv);\n\n#endif  // NOBUILD_H_\n\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef NOBUILD_IMPLEMENTATION\n\n#ifdef _WIN32\nLPSTR GetLastErrorAsString(void)\n{\n    // https://stackoverflow.com/questions/1387064/how-to-get-the-error-message-from-the-error-code-returned-by-getlasterror\n\n    DWORD errorMessageId = GetLastError();\n    assert(errorMessageId != 0);\n\n    LPSTR messageBuffer = NULL;\n\n    DWORD size =\n        FormatMessage(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, // DWORD   dwFlags,\n            NULL, // LPCVOID lpSource,\n            errorMessageId, // DWORD   dwMessageId,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // DWORD   dwLanguageId,\n            (LPSTR) &messageBuffer, // LPTSTR  lpBuffer,\n            0, // DWORD   nSize,\n            NULL // va_list *Arguments\n        );\n\n    return messageBuffer;\n}\n\n// minirent.h IMPLEMENTATION BEGIN ////////////////////////////////////////\nstruct DIR {\n    HANDLE hFind;\n    WIN32_FIND_DATA data;\n    struct dirent *dirent;\n};\n\nDIR *opendir(const char *dirpath)\n{\n    assert(dirpath);\n\n    char buffer[MAX_PATH];\n    snprintf(buffer, MAX_PATH, \"%s\\\\*\", dirpath);\n\n    DIR *dir = (DIR*)calloc(1, sizeof(DIR));\n\n    dir->hFind = FindFirstFile(buffer, &dir->data);\n    if (dir->hFind == INVALID_HANDLE_VALUE) {\n        errno = ENOSYS;\n        goto fail;\n    }\n\n    return dir;\n\nfail:\n    if (dir) {\n        free(dir);\n    }\n\n    return NULL;\n}\n\nstruct dirent *readdir(DIR *dirp)\n{\n    assert(dirp);\n\n    if (dirp->dirent == NULL) {\n        dirp->dirent = (struct dirent*)calloc(1, sizeof(struct dirent));\n    } else {\n        if(!FindNextFile(dirp->hFind, &dirp->data)) {\n            if (GetLastError() != ERROR_NO_MORE_FILES) {\n                errno = ENOSYS;\n            }\n\n            return NULL;\n        }\n    }\n\n    memset(dirp->dirent->d_name, 0, sizeof(dirp->dirent->d_name));\n\n    strncpy(\n        dirp->dirent->d_name,\n        dirp->data.cFileName,\n        sizeof(dirp->dirent->d_name) - 1);\n\n    return dirp->dirent;\n}\n\nint closedir(DIR *dirp)\n{\n    assert(dirp);\n\n    if(!FindClose(dirp->hFind)) {\n        errno = ENOSYS;\n        return -1;\n    }\n\n    if (dirp->dirent) {\n        free(dirp->dirent);\n    }\n    free(dirp);\n\n    return 0;\n}\n// minirent.h IMPLEMENTATION END ////////////////////////////////////////\n#endif // _WIN32\n\nCstr_Array cstr_array_append(Cstr_Array cstrs, Cstr cstr)\n{\n    Cstr_Array result = {\n        .count = cstrs.count + 1\n    };\n    result.elems = malloc(sizeof(result.elems[0]) * result.count);\n    memcpy(result.elems, cstrs.elems, cstrs.count * sizeof(result.elems[0]));\n    result.elems[cstrs.count] = cstr;\n    return result;\n}\n\nint cstr_ends_with(Cstr cstr, Cstr postfix)\n{\n    const size_t cstr_len = strlen(cstr);\n    const size_t postfix_len = strlen(postfix);\n    return postfix_len <= cstr_len\n           && strcmp(cstr + cstr_len - postfix_len, postfix) == 0;\n}\n\nCstr cstr_no_ext(Cstr path)\n{\n    size_t n = strlen(path);\n    while (n > 0 && path[n - 1] != '.') {\n        n -= 1;\n    }\n\n    if (n > 0) {\n        char *result = malloc(n);\n        memcpy(result, path, n);\n        result[n - 1] = '\\0';\n\n        return result;\n    } else {\n        return path;\n    }\n}\n\nCstr_Array cstr_array_make(Cstr first, ...)\n{\n    Cstr_Array result = {0};\n\n    if (first == NULL) {\n        return result;\n    }\n\n    result.count += 1;\n\n    va_list args;\n    va_start(args, first);\n    for (Cstr next = va_arg(args, Cstr);\n            next != NULL;\n            next = va_arg(args, Cstr)) {\n        result.count += 1;\n    }\n    va_end(args);\n\n    result.elems = malloc(sizeof(result.elems[0]) * result.count);\n    if (result.elems == NULL) {\n        PANIC(\"could not allocate memory: %s\", strerror(errno));\n    }\n    result.count = 0;\n\n    result.elems[result.count++] = first;\n\n    va_start(args, first);\n    for (Cstr next = va_arg(args, Cstr);\n            next != NULL;\n            next = va_arg(args, Cstr)) {\n        result.elems[result.count++] = next;\n    }\n    va_end(args);\n\n    return result;\n}\n\nCstr cstr_array_join(Cstr sep, Cstr_Array cstrs)\n{\n    if (cstrs.count == 0) {\n        return \"\";\n    }\n\n    const size_t sep_len = strlen(sep);\n    size_t len = 0;\n    for (size_t i = 0; i < cstrs.count; ++i) {\n        len += strlen(cstrs.elems[i]);\n    }\n\n    const size_t result_len = (cstrs.count - 1) * sep_len + len + 1;\n    char *result = malloc(sizeof(char) * result_len);\n    if (result == NULL) {\n        PANIC(\"could not allocate memory: %s\", strerror(errno));\n    }\n\n    len = 0;\n    for (size_t i = 0; i < cstrs.count; ++i) {\n        if (i > 0) {\n            memcpy(result + len, sep, sep_len);\n            len += sep_len;\n        }\n\n        size_t elem_len = strlen(cstrs.elems[i]);\n        memcpy(result + len, cstrs.elems[i], elem_len);\n        len += elem_len;\n    }\n    result[len] = '\\0';\n\n    return result;\n}\n\nPipe pipe_make(void)\n{\n    Pipe pip = {0};\n\n#ifdef _WIN32\n    // https://docs.microsoft.com/en-us/windows/win32/ProcThread/creating-a-child-process-with-redirected-input-and-output\n\n    SECURITY_ATTRIBUTES saAttr = {0};\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n\n    if (!CreatePipe(&pip.read, &pip.write, &saAttr, 0)) {\n        PANIC(\"Could not create pipe: %s\", GetLastErrorAsString());\n    }\n#else\n    Fd pipefd[2];\n    if (pipe(pipefd) < 0) {\n        PANIC(\"Could not create pipe: %s\", strerror(errno));\n    }\n\n    pip.read = pipefd[0];\n    pip.write = pipefd[1];\n#endif // _WIN32\n\n    return pip;\n}\n\nFd fd_open_for_read(Cstr path)\n{\n#ifndef _WIN32\n    Fd result = open(path, O_RDONLY);\n    if (result < 0) {\n        PANIC(\"Could not open file %s: %s\", path, strerror(errno));\n    }\n    return result;\n#else\n    // https://docs.microsoft.com/en-us/windows/win32/fileio/opening-a-file-for-reading-or-writing\n    SECURITY_ATTRIBUTES saAttr = {0};\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n\n    Fd result = CreateFile(\n                    path,\n                    GENERIC_READ,\n                    0,\n                    &saAttr,\n                    OPEN_EXISTING,\n                    FILE_ATTRIBUTE_READONLY,\n                    NULL);\n\n    if (result == INVALID_HANDLE_VALUE) {\n        PANIC(\"Could not open file %s\", path);\n    }\n\n    return result;\n#endif // _WIN32\n}\n\nFd fd_open_for_write(Cstr path)\n{\n#ifndef _WIN32\n    Fd result = open(path,\n                     O_WRONLY | O_CREAT | O_TRUNC,\n                     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n    if (result < 0) {\n        PANIC(\"could not open file %s: %s\", path, strerror(errno));\n    }\n    return result;\n#else\n    SECURITY_ATTRIBUTES saAttr = {0};\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n\n    Fd result = CreateFile(\n                    path,                  // name of the write\n                    GENERIC_WRITE,         // open for writing\n                    0,                     // do not share\n                    &saAttr,               // default security\n                    CREATE_NEW,            // create new file only\n                    FILE_ATTRIBUTE_NORMAL, // normal file\n                    NULL                   // no attr. template\n                );\n\n    if (result == INVALID_HANDLE_VALUE) {\n        PANIC(\"Could not open file %s: %s\", path, GetLastErrorAsString());\n    }\n\n    return result;\n#endif // _WIN32\n}\n\nvoid fd_close(Fd fd)\n{\n#ifdef _WIN32\n    CloseHandle(fd);\n#else\n    close(fd);\n#endif // _WIN32\n}\n\nvoid pid_wait(Pid pid)\n{\n#ifdef _WIN32\n    DWORD result = WaitForSingleObject(\n                       pid,     // HANDLE hHandle,\n                       INFINITE // DWORD  dwMilliseconds\n                   );\n\n    if (result == WAIT_FAILED) {\n        PANIC(\"could not wait on child process: %s\", GetLastErrorAsString());\n    }\n\n    DWORD exit_status;\n    if (GetExitCodeProcess(pid, &exit_status) == 0) {\n        PANIC(\"could not get process exit code: %lu\", GetLastError());\n    }\n\n    if (exit_status != 0) {\n        PANIC(\"command exited with exit code %lu\", exit_status);\n    }\n\n    CloseHandle(pid);\n#else\n    for (;;) {\n        int wstatus = 0;\n        if (waitpid(pid, &wstatus, 0) < 0) {\n            PANIC(\"could not wait on command (pid %d): %s\", pid, strerror(errno));\n        }\n\n        if (WIFEXITED(wstatus)) {\n            int exit_status = WEXITSTATUS(wstatus);\n            if (exit_status != 0) {\n                PANIC(\"command exited with exit code %d\", exit_status);\n            }\n\n            break;\n        }\n\n        if (WIFSIGNALED(wstatus)) {\n            PANIC(\"command process was terminated by %s\", strsignal(WTERMSIG(wstatus)));\n        }\n    }\n\n#endif // _WIN32\n}\n\nCstr cmd_show(Cmd cmd)\n{\n    // TODO(#31): cmd_show does not render the command line properly\n    // - No string literals when arguments contains space\n    // - No escaping of special characters\n    // - Etc.\n    return cstr_array_join(\" \", cmd.line);\n}\n\nPid cmd_run_async(Cmd cmd, Fd *fdin, Fd *fdout)\n{\n#ifdef _WIN32\n    // https://docs.microsoft.com/en-us/windows/win32/procthread/creating-a-child-process-with-redirected-input-and-output\n\n    STARTUPINFO siStartInfo;\n    ZeroMemory(&siStartInfo, sizeof(siStartInfo));\n    siStartInfo.cb = sizeof(STARTUPINFO);\n    // NOTE: theoretically setting NULL to std handles should not be a problem\n    // https://docs.microsoft.com/en-us/windows/console/getstdhandle?redirectedfrom=MSDN#attachdetach-behavior\n    siStartInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n    // TODO(#32): check for errors in GetStdHandle\n    siStartInfo.hStdOutput = fdout ? *fdout : GetStdHandle(STD_OUTPUT_HANDLE);\n    siStartInfo.hStdInput = fdin ? *fdin : GetStdHandle(STD_INPUT_HANDLE);\n    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;\n\n    PROCESS_INFORMATION piProcInfo;\n    ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));\n\n    BOOL bSuccess =\n        CreateProcess(\n            NULL,\n            // TODO(#33): cmd_run_async on Windows does not render command line properly\n            // It may require wrapping some arguments with double-quotes if they contains spaces, etc.\n            cstr_array_join(\" \", cmd.line),\n            NULL,\n            NULL,\n            TRUE,\n            0,\n            NULL,\n            NULL,\n            &siStartInfo,\n            &piProcInfo\n        );\n\n    if (!bSuccess) {\n        PANIC(\"Could not create child process %s: %s\\n\",\n              cmd_show(cmd), GetLastErrorAsString());\n    }\n\n    CloseHandle(piProcInfo.hThread);\n\n    return piProcInfo.hProcess;\n#else\n    pid_t cpid = fork();\n    if (cpid < 0) {\n        PANIC(\"Could not fork child process: %s: %s\",\n              cmd_show(cmd), strerror(errno));\n    }\n\n    if (cpid == 0) {\n        Cstr_Array args = cstr_array_append(cmd.line, NULL);\n\n        if (fdin) {\n            if (dup2(*fdin, STDIN_FILENO) < 0) {\n                PANIC(\"Could not setup stdin for child process: %s\", strerror(errno));\n            }\n        }\n\n        if (fdout) {\n            if (dup2(*fdout, STDOUT_FILENO) < 0) {\n                PANIC(\"Could not setup stdout for child process: %s\", strerror(errno));\n            }\n        }\n\n        if (execvp(args.elems[0], (char * const*) args.elems) < 0) {\n            PANIC(\"Could not exec child process: %s: %s\",\n                  cmd_show(cmd), strerror(errno));\n        }\n    }\n\n    return cpid;\n#endif // _WIN32\n}\n\nvoid cmd_run_sync(Cmd cmd)\n{\n    pid_wait(cmd_run_async(cmd, NULL, NULL));\n}\n\nstatic void chain_set_input_output_files_or_count_cmds(Chain *chain, Chain_Token token)\n{\n    switch (token.type) {\n    case CHAIN_TOKEN_CMD: {\n        chain->cmds.count += 1;\n    }\n    break;\n\n    case CHAIN_TOKEN_IN: {\n        if (chain->input_filepath) {\n            PANIC(\"Input file path was already set\");\n        }\n\n        chain->input_filepath = token.args.elems[0];\n    }\n    break;\n\n    case CHAIN_TOKEN_OUT: {\n        if (chain->output_filepath) {\n            PANIC(\"Output file path was already set\");\n        }\n\n        chain->output_filepath = token.args.elems[0];\n    }\n    break;\n\n    case CHAIN_TOKEN_END:\n    default: {\n        assert(0 && \"unreachable\");\n        exit(1);\n    }\n    }\n}\n\nstatic void chain_push_cmd(Chain *chain, Chain_Token token)\n{\n    if (token.type == CHAIN_TOKEN_CMD) {\n        chain->cmds.elems[chain->cmds.count++] = (Cmd) {\n            .line = token.args\n        };\n    }\n}\n\nChain chain_build_from_tokens(Chain_Token first, ...)\n{\n    Chain result = {0};\n\n    chain_set_input_output_files_or_count_cmds(&result, first);\n    va_list args;\n    va_start(args, first);\n    Chain_Token next = va_arg(args, Chain_Token);\n    while (next.type != CHAIN_TOKEN_END) {\n        chain_set_input_output_files_or_count_cmds(&result, next);\n        next = va_arg(args, Chain_Token);\n    }\n    va_end(args);\n\n    result.cmds.elems = malloc(sizeof(result.cmds.elems[0]) * result.cmds.count);\n    if (result.cmds.elems == NULL) {\n        PANIC(\"could not allocate memory: %s\", strerror(errno));\n    }\n    result.cmds.count = 0;\n\n    chain_push_cmd(&result, first);\n\n    va_start(args, first);\n    next = va_arg(args, Chain_Token);\n    while (next.type != CHAIN_TOKEN_END) {\n        chain_push_cmd(&result, next);\n        next = va_arg(args, Chain_Token);\n    }\n    va_end(args);\n\n    return result;\n}\n\nvoid chain_run_sync(Chain chain)\n{\n    if (chain.cmds.count == 0) {\n        return;\n    }\n\n    Pid *cpids = malloc(sizeof(Pid) * chain.cmds.count);\n\n    Pipe pip = {0};\n    Fd fdin = 0;\n    Fd *fdprev = NULL;\n\n    if (chain.input_filepath) {\n        fdin = fd_open_for_read(chain.input_filepath);\n        if (fdin < 0) {\n            PANIC(\"could not open file %s: %s\", chain.input_filepath, strerror(errno));\n        }\n        fdprev = &fdin;\n    }\n\n    for (size_t i = 0; i < chain.cmds.count - 1; ++i) {\n        pip = pipe_make();\n\n        cpids[i] = cmd_run_async(\n                       chain.cmds.elems[i],\n                       fdprev,\n                       &pip.write);\n\n        if (fdprev) fd_close(*fdprev);\n        fd_close(pip.write);\n        fdprev = &fdin;\n        fdin = pip.read;\n    }\n\n    {\n        Fd fdout = 0;\n        Fd *fdnext = NULL;\n\n        if (chain.output_filepath) {\n            fdout = fd_open_for_write(chain.output_filepath);\n            if (fdout < 0) {\n                PANIC(\"could not open file %s: %s\",\n                      chain.output_filepath,\n                      strerror(errno));\n            }\n            fdnext = &fdout;\n        }\n\n        const size_t last = chain.cmds.count - 1;\n        cpids[last] =\n            cmd_run_async(\n                chain.cmds.elems[last],\n                fdprev,\n                fdnext);\n\n        if (fdprev) fd_close(*fdprev);\n        if (fdnext) fd_close(*fdnext);\n    }\n\n    for (size_t i = 0; i < chain.cmds.count; ++i) {\n        pid_wait(cpids[i]);\n    }\n}\n\nvoid chain_echo(Chain chain)\n{\n    printf(\"[INFO] CHAIN:\");\n    if (chain.input_filepath) {\n        printf(\" %s\", chain.input_filepath);\n    }\n\n    FOREACH_ARRAY(Cmd, cmd, chain.cmds, {\n        printf(\" |> %s\", cmd_show(*cmd));\n    });\n\n    if (chain.output_filepath) {\n        printf(\" |> %s\", chain.output_filepath);\n    }\n\n    printf(\"\\n\");\n}\n\nint path_exists(Cstr path)\n{\n#ifdef _WIN32\n    DWORD dwAttrib = GetFileAttributes(path);\n    return (dwAttrib != INVALID_FILE_ATTRIBUTES);\n#else\n    struct stat statbuf = {0};\n    if (stat(path, &statbuf) < 0) {\n        if (errno == ENOENT) {\n            errno = 0;\n            return 0;\n        }\n\n        PANIC(\"could not retrieve information about file %s: %s\",\n              path, strerror(errno));\n    }\n\n    return 1;\n#endif\n}\n\nint path_is_dir(Cstr path)\n{\n#ifdef _WIN32\n    DWORD dwAttrib = GetFileAttributes(path);\n\n    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&\n            (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));\n#else\n    struct stat statbuf = {0};\n    if (stat(path, &statbuf) < 0) {\n        if (errno == ENOENT) {\n            errno = 0;\n            return 0;\n        }\n\n        PANIC(\"could not retrieve information about file %s: %s\",\n              path, strerror(errno));\n    }\n\n    return S_ISDIR(statbuf.st_mode);\n#endif // _WIN32\n}\n\nvoid path_rename(const char *old_path, const char *new_path)\n{\n#ifdef _WIN32\n    if (!MoveFileEx(old_path, new_path, MOVEFILE_REPLACE_EXISTING)) {\n        PANIC(\"could not rename %s to %s: %s\", old_path, new_path,\n              GetLastErrorAsString());\n    }\n#else\n    if (rename(old_path, new_path) < 0) {\n        PANIC(\"could not rename %s to %s: %s\", old_path, new_path,\n              strerror(errno));\n    }\n#endif // _WIN32\n}\n\nvoid path_mkdirs(Cstr_Array path)\n{\n    if (path.count == 0) {\n        return;\n    }\n\n    size_t len = 0;\n    for (size_t i = 0; i < path.count; ++i) {\n        len += strlen(path.elems[i]);\n    }\n\n    size_t seps_count = path.count - 1;\n    const size_t sep_len = strlen(PATH_SEP);\n\n    char *result = malloc(len + seps_count * sep_len + 1);\n\n    len = 0;\n    for (size_t i = 0; i < path.count; ++i) {\n        size_t n = strlen(path.elems[i]);\n        memcpy(result + len, path.elems[i], n);\n        len += n;\n\n        if (seps_count > 0) {\n            memcpy(result + len, PATH_SEP, sep_len);\n            len += sep_len;\n            seps_count -= 1;\n        }\n\n        result[len] = '\\0';\n\n        if (mkdir(result, 0755) < 0) {\n            if (errno == EEXIST) {\n                errno = 0;\n                WARN(\"directory %s already exists\", result);\n            } else {\n                PANIC(\"could not create directory %s: %s\", result, strerror(errno));\n            }\n        }\n    }\n}\n\nvoid path_rm(Cstr path)\n{\n    if (IS_DIR(path)) {\n        FOREACH_FILE_IN_DIR(file, path, {\n            if (strcmp(file, \".\") != 0 && strcmp(file, \"..\") != 0)\n            {\n                path_rm(PATH(path, file));\n            }\n        });\n\n        if (rmdir(path) < 0) {\n            if (errno == ENOENT) {\n                errno = 0;\n                WARN(\"directory %s does not exist\", path);\n            } else {\n                PANIC(\"could not remove directory %s: %s\", path, strerror(errno));\n            }\n        }\n    } else {\n        if (unlink(path) < 0) {\n            if (errno == ENOENT) {\n                errno = 0;\n                WARN(\"file %s does not exist\", path);\n            } else {\n                PANIC(\"could not remove file %s: %s\", path, strerror(errno));\n            }\n        }\n    }\n}\n\nint is_path1_modified_after_path2(const char *path1, const char *path2)\n{\n#ifdef _WIN32\n    FILETIME path1_time, path2_time;\n\n    Fd path1_fd = fd_open_for_read(path1);\n    if (!GetFileTime(path1_fd, NULL, NULL, &path1_time)) {\n        PANIC(\"could not get time of %s: %s\", path1, GetLastErrorAsString());\n    }\n    fd_close(path1_fd);\n\n    Fd path2_fd = fd_open_for_read(path2);\n    if (!GetFileTime(path2_fd, NULL, NULL, &path2_time)) {\n        PANIC(\"could not get time of %s: %s\", path2, GetLastErrorAsString());\n    }\n    fd_close(path2_fd);\n\n    return CompareFileTime(&path1_time, &path2_time) == 1;\n#else\n    struct stat statbuf = {0};\n\n    if (stat(path1, &statbuf) < 0) {\n        PANIC(\"could not stat %s: %s\\n\", path1, strerror(errno));\n    }\n    int path1_time = statbuf.st_mtime;\n\n    if (stat(path2, &statbuf) < 0) {\n        PANIC(\"could not stat %s: %s\\n\", path2, strerror(errno));\n    }\n    int path2_time = statbuf.st_mtime;\n\n    return path1_time > path2_time;\n#endif\n}\n\nvoid VLOG(FILE *stream, Cstr tag, Cstr fmt, va_list args)\n{\n    fprintf(stream, \"[%s] \", tag);\n    vfprintf(stream, fmt, args);\n    fprintf(stream, \"\\n\");\n}\n\nvoid INFO(Cstr fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    VLOG(stderr, \"INFO\", fmt, args);\n    va_end(args);\n}\n\nvoid WARN(Cstr fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    VLOG(stderr, \"WARN\", fmt, args);\n    va_end(args);\n}\n\nvoid ERRO(Cstr fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    VLOG(stderr, \"ERRO\", fmt, args);\n    va_end(args);\n}\n\nvoid PANIC(Cstr fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    VLOG(stderr, \"ERRO\", fmt, args);\n    va_end(args);\n    exit(1);\n}\n\nchar *shift_args(int *argc, char ***argv)\n{\n    assert(*argc > 0);\n    char *result = **argv;\n    *argc -= 1;\n    *argv += 1;\n    return result;\n}\n\n#endif // NOBUILD_IMPLEMENTATION\n"
        },
        {
          "name": "olive.c",
          "type": "blob",
          "size": 32.453125,
          "content": "// Copyright 2022 Alexey Kutepov <reximkut@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#ifndef OLIVE_C_\n#define OLIVE_C_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#ifndef OLIVECDEF\n#define OLIVECDEF static inline\n#endif\n\n#ifndef OLIVEC_AA_RES\n#define OLIVEC_AA_RES 2\n#endif\n\n#define OLIVEC_SWAP(T, a, b) do { T t = a; a = b; b = t; } while (0)\n#define OLIVEC_SIGN(T, x) ((T)((x) > 0) - (T)((x) < 0))\n#define OLIVEC_ABS(T, x) (OLIVEC_SIGN(T, x)*(x))\n\ntypedef struct {\n    size_t width, height;\n    const char *glyphs;\n} Olivec_Font;\n\n#define OLIVEC_DEFAULT_FONT_HEIGHT 6\n#define OLIVEC_DEFAULT_FONT_WIDTH 6\n// TODO: allocate proper descender and acender areas for the default font\nstatic char olivec_default_glyphs[128][OLIVEC_DEFAULT_FONT_HEIGHT][OLIVEC_DEFAULT_FONT_WIDTH] = {\n    ['a'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 0, 0},\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['b'] = {\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 1, 1, 0, 0},\n    },\n    ['c'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 0, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['d'] = {\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['e'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 1, 1, 1, 0},\n        {1, 0, 0, 0, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['f'] = {\n        {0, 0, 1, 1, 0},\n        {0, 1, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n    },\n    ['g'] = {\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['h'] = {\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n    },\n    ['i'] = {\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n    },\n    ['j'] = {\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {1, 0, 1, 0, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['k'] = {\n        {1, 0, 0, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 1, 0, 0},\n        {1, 1, 0, 0, 0},\n        {1, 0, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n    },\n    ['l'] = {\n        {0, 1, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['m'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 0, 1, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n    },\n    ['n'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n    },\n    ['o'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['p'] = {\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 0, 0, 0, 0},\n    },\n    ['q'] = {\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 0, 0, 1, 0},\n    },\n    ['r'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 1, 1, 0},\n        {1, 1, 0, 0, 1},\n        {1, 0, 0, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 0, 0, 0, 0},\n    },\n    ['s'] = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 1, 0},\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {1, 1, 1, 0, 0},\n    },\n    ['t'] = {\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['u'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['v'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['w'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 0, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {0, 1, 1, 1, 1},\n    },\n    ['x'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 1, 0, 0},\n        {1, 0, 1, 0, 0},\n        {0, 1, 0, 0, 0},\n        {1, 0, 1, 0, 0},\n        {1, 0, 1, 0, 0},\n    },\n    ['y'] = {\n        {0, 0, 0, 0, 0},\n        {1, 0, 1, 0, 0},\n        {1, 0, 1, 0, 0},\n        {1, 0, 1, 0, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n    },\n    ['z'] = {\n        {0, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n    },\n\n    ['A'] = {0},\n    ['B'] = {0},\n    ['C'] = {0},\n    ['D'] = {0},\n    ['E'] = {0},\n    ['F'] = {0},\n    ['G'] = {0},\n    ['H'] = {0},\n    ['I'] = {0},\n    ['J'] = {0},\n    ['K'] = {0},\n    ['L'] = {0},\n    ['M'] = {0},\n    ['N'] = {0},\n    ['O'] = {0},\n    ['P'] = {0},\n    ['Q'] = {0},\n    ['R'] = {0},\n    ['S'] = {0},\n    ['T'] = {0},\n    ['U'] = {0},\n    ['V'] = {0},\n    ['W'] = {0},\n    ['X'] = {0},\n    ['Y'] = {0},\n    ['Z'] = {0},\n\n    ['0'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['1'] = {\n        {0, 0, 1, 0, 0},\n        {0, 1, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 1, 1, 1, 0},\n    },\n    ['2'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n    },\n    ['3'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['4'] = {\n        {0, 0, 1, 1, 0},\n        {0, 1, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {1, 1, 1, 1, 1},\n        {0, 0, 0, 1, 0},\n        {0, 0, 0, 1, 0},\n    },\n    ['5'] = {\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 0, 0},\n        {0, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['6'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 0, 0},\n        {1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n    ['7'] = {\n        {1, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 0, 1, 0, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n        {0, 1, 0, 0, 0},\n    },\n    ['8'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n\n    },\n    ['9'] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 1, 0},\n        {0, 1, 1, 1, 0},\n        {0, 0, 0, 1, 0},\n        {0, 1, 1, 0, 0},\n    },\n\n    [','] = {\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 1, 0},\n        {0, 0, 1, 0, 0},\n    },\n\n    ['.'] = {\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0},\n    },\n    ['-'] = {\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n    },\n};\n\nstatic Olivec_Font olivec_default_font = {\n    .glyphs = &olivec_default_glyphs[0][0][0],\n    .width = OLIVEC_DEFAULT_FONT_WIDTH,\n    .height = OLIVEC_DEFAULT_FONT_HEIGHT,\n};\n\n// WARNING! Always initialize your Canvas with a color that has Non-Zero Alpha Channel!\n// A lot of functions use `olivec_blend_color()` function to blend with the Background\n// which preserves the original Alpha of the Background. So you may easily end up with\n// a result that is perceptually transparent if the Alpha is Zero.\ntypedef struct {\n    uint32_t *pixels;\n    size_t width;\n    size_t height;\n    size_t stride;\n} Olivec_Canvas;\n\n#define OLIVEC_CANVAS_NULL ((Olivec_Canvas) {0})\n#define OLIVEC_PIXEL(oc, x, y) (oc).pixels[(y)*(oc).stride + (x)]\n\nOLIVECDEF Olivec_Canvas olivec_canvas(uint32_t *pixels, size_t width, size_t height, size_t stride);\nOLIVECDEF Olivec_Canvas olivec_subcanvas(Olivec_Canvas oc, int x, int y, int w, int h);\nOLIVECDEF bool olivec_in_bounds(Olivec_Canvas oc, int x, int y);\nOLIVECDEF void olivec_blend_color(uint32_t *c1, uint32_t c2);\nOLIVECDEF void olivec_fill(Olivec_Canvas oc, uint32_t color);\nOLIVECDEF void olivec_rect(Olivec_Canvas oc, int x, int y, int w, int h, uint32_t color);\nOLIVECDEF void olivec_frame(Olivec_Canvas oc, int x, int y, int w, int h, size_t thiccness, uint32_t color);\nOLIVECDEF void olivec_circle(Olivec_Canvas oc, int cx, int cy, int r, uint32_t color);\nOLIVECDEF void olivec_ellipse(Olivec_Canvas oc, int cx, int cy, int rx, int ry, uint32_t color);\n// TODO: lines with different thiccness\nOLIVECDEF void olivec_line(Olivec_Canvas oc, int x1, int y1, int x2, int y2, uint32_t color);\nOLIVECDEF bool olivec_normalize_triangle(size_t width, size_t height, int x1, int y1, int x2, int y2, int x3, int y3, int *lx, int *hx, int *ly, int *hy);\nOLIVECDEF bool olivec_barycentric(int x1, int y1, int x2, int y2, int x3, int y3, int xp, int yp, int *u1, int *u2, int *det);\nOLIVECDEF void olivec_triangle(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color);\nOLIVECDEF void olivec_triangle3c(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t c1, uint32_t c2, uint32_t c3);\nOLIVECDEF void olivec_triangle3z(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float z1, float z2, float z3);\nOLIVECDEF void olivec_triangle3uv(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture);\nOLIVECDEF void olivec_triangle3uv_bilinear(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture);\nOLIVECDEF void olivec_text(Olivec_Canvas oc, const char *text, int x, int y, Olivec_Font font, size_t size, uint32_t color);\nOLIVECDEF void olivec_sprite_blend(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);\nOLIVECDEF void olivec_sprite_copy(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);\nOLIVECDEF void olivec_sprite_copy_bilinear(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);\nOLIVECDEF uint32_t olivec_pixel_bilinear(Olivec_Canvas sprite, int nx, int ny, int w, int h);\n\ntypedef struct {\n    // Safe ranges to iterate over.\n    int x1, x2;\n    int y1, y2;\n\n    // Original uncut ranges some parts of which may be outside of the canvas boundaries.\n    int ox1, ox2;\n    int oy1, oy2;\n} Olivec_Normalized_Rect;\n\n// The point of this function is to produce two ranges x1..x2 and y1..y2 that are guaranteed to be safe to iterate over the canvas of size pixels_width by pixels_height without any boundary checks.\n//\n// Olivec_Normalized_Rect nr = {0};\n// if (olivec_normalize_rect(x, y, w, h, WIDTH, HEIGHT, &nr)) {\n//     for (int x = nr.x1; x <= nr.x2; ++x) {\n//         for (int y = nr.y1; y <= nr.y2; ++y) {\n//             OLIVEC_PIXEL(oc, x, y) = 0x69696969;\n//         }\n//     }\n// } else {\n//     // Rectangle is invisible cause it's completely out-of-bounds\n// }\nOLIVECDEF bool olivec_normalize_rect(int x, int y, int w, int h,\n                                     size_t canvas_width, size_t canvas_height,\n                                     Olivec_Normalized_Rect *nr);\n\n#endif // OLIVE_C_\n\n#ifdef OLIVEC_IMPLEMENTATION\n\nOLIVECDEF Olivec_Canvas olivec_canvas(uint32_t *pixels, size_t width, size_t height, size_t stride)\n{\n    Olivec_Canvas oc = {\n        .pixels = pixels,\n        .width  = width,\n        .height = height,\n        .stride = stride,\n    };\n    return oc;\n}\n\nOLIVECDEF bool olivec_normalize_rect(int x, int y, int w, int h,\n                                     size_t canvas_width, size_t canvas_height,\n                                     Olivec_Normalized_Rect *nr)\n{\n    // No need to render empty rectangle\n    if (w == 0) return false;\n    if (h == 0) return false;\n\n    nr->ox1 = x;\n    nr->oy1 = y;\n\n    // Convert the rectangle to 2-points representation\n    nr->ox2 = nr->ox1 + OLIVEC_SIGN(int, w)*(OLIVEC_ABS(int, w) - 1);\n    if (nr->ox1 > nr->ox2) OLIVEC_SWAP(int, nr->ox1, nr->ox2);\n    nr->oy2 = nr->oy1 + OLIVEC_SIGN(int, h)*(OLIVEC_ABS(int, h) - 1);\n    if (nr->oy1 > nr->oy2) OLIVEC_SWAP(int, nr->oy1, nr->oy2);\n\n    // Cull out invisible rectangle\n    if (nr->ox1 >= (int) canvas_width) return false;\n    if (nr->ox2 < 0) return false;\n    if (nr->oy1 >= (int) canvas_height) return false;\n    if (nr->oy2 < 0) return false;\n\n    nr->x1 = nr->ox1;\n    nr->y1 = nr->oy1;\n    nr->x2 = nr->ox2;\n    nr->y2 = nr->oy2;\n\n    // Clamp the rectangle to the boundaries\n    if (nr->x1 < 0) nr->x1 = 0;\n    if (nr->x2 >= (int) canvas_width) nr->x2 = (int) canvas_width - 1;\n    if (nr->y1 < 0) nr->y1 = 0;\n    if (nr->y2 >= (int) canvas_height) nr->y2 = (int) canvas_height - 1;\n\n    return true;\n}\n\nOLIVECDEF Olivec_Canvas olivec_subcanvas(Olivec_Canvas oc, int x, int y, int w, int h)\n{\n    Olivec_Normalized_Rect nr = {0};\n    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return OLIVEC_CANVAS_NULL;\n    oc.pixels = &OLIVEC_PIXEL(oc, nr.x1, nr.y1);\n    oc.width = nr.x2 - nr.x1 + 1;\n    oc.height = nr.y2 - nr.y1 + 1;\n    return oc;\n}\n\n// TODO: custom pixel formats\n// Maybe we can store pixel format info in Olivec_Canvas\n#define OLIVEC_RED(color)   (((color)&0x000000FF)>>(8*0))\n#define OLIVEC_GREEN(color) (((color)&0x0000FF00)>>(8*1))\n#define OLIVEC_BLUE(color)  (((color)&0x00FF0000)>>(8*2))\n#define OLIVEC_ALPHA(color) (((color)&0xFF000000)>>(8*3))\n#define OLIVEC_RGBA(r, g, b, a) ((((r)&0xFF)<<(8*0)) | (((g)&0xFF)<<(8*1)) | (((b)&0xFF)<<(8*2)) | (((a)&0xFF)<<(8*3)))\n\nOLIVECDEF void olivec_blend_color(uint32_t *c1, uint32_t c2)\n{\n    uint32_t r1 = OLIVEC_RED(*c1);\n    uint32_t g1 = OLIVEC_GREEN(*c1);\n    uint32_t b1 = OLIVEC_BLUE(*c1);\n    uint32_t a1 = OLIVEC_ALPHA(*c1);\n\n    uint32_t r2 = OLIVEC_RED(c2);\n    uint32_t g2 = OLIVEC_GREEN(c2);\n    uint32_t b2 = OLIVEC_BLUE(c2);\n    uint32_t a2 = OLIVEC_ALPHA(c2);\n\n    r1 = (r1*(255 - a2) + r2*a2)/255; if (r1 > 255) r1 = 255;\n    g1 = (g1*(255 - a2) + g2*a2)/255; if (g1 > 255) g1 = 255;\n    b1 = (b1*(255 - a2) + b2*a2)/255; if (b1 > 255) b1 = 255;\n\n    *c1 = OLIVEC_RGBA(r1, g1, b1, a1);\n}\n\nOLIVECDEF void olivec_fill(Olivec_Canvas oc, uint32_t color)\n{\n    for (size_t y = 0; y < oc.height; ++y) {\n        for (size_t x = 0; x < oc.width; ++x) {\n            OLIVEC_PIXEL(oc, x, y) = color;\n        }\n    }\n}\n\nOLIVECDEF void olivec_rect(Olivec_Canvas oc, int x, int y, int w, int h, uint32_t color)\n{\n    Olivec_Normalized_Rect nr = {0};\n    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;\n    for (int x = nr.x1; x <= nr.x2; ++x) {\n        for (int y = nr.y1; y <= nr.y2; ++y) {\n            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);\n        }\n    }\n}\n\nOLIVECDEF void olivec_frame(Olivec_Canvas oc, int x, int y, int w, int h, size_t t, uint32_t color)\n{\n    if (t == 0) return; // Nothing to render\n\n    // Convert the rectangle to 2-points representation\n    int x1 = x;\n    int y1 = y;\n    int x2 = x1 + OLIVEC_SIGN(int, w)*(OLIVEC_ABS(int, w) - 1);\n    if (x1 > x2) OLIVEC_SWAP(int, x1, x2);\n    int y2 = y1 + OLIVEC_SIGN(int, h)*(OLIVEC_ABS(int, h) - 1);\n    if (y1 > y2) OLIVEC_SWAP(int, y1, y2);\n\n    olivec_rect(oc, x1 - t/2, y1 - t/2, (x2 - x1 + 1) + t/2*2, t, color);  // Top\n    olivec_rect(oc, x1 - t/2, y1 - t/2, t, (y2 - y1 + 1) + t/2*2, color);  // Left\n    olivec_rect(oc, x1 - t/2, y2 + t/2, (x2 - x1 + 1) + t/2*2, -t, color); // Bottom\n    olivec_rect(oc, x2 + t/2, y1 - t/2, -t, (y2 - y1 + 1) + t/2*2, color); // Right\n}\n\nOLIVECDEF void olivec_ellipse(Olivec_Canvas oc, int cx, int cy, int rx, int ry, uint32_t color)\n{\n    Olivec_Normalized_Rect nr = {0};\n    int rx1 = rx + OLIVEC_SIGN(int, rx);\n    int ry1 = ry + OLIVEC_SIGN(int, ry);\n    if (!olivec_normalize_rect(cx - rx1, cy - ry1, 2*rx1, 2*ry1, oc.width, oc.height, &nr)) return;\n\n    for (int y = nr.y1; y <= nr.y2; ++y) {\n        for (int x = nr.x1; x <= nr.x2; ++x) {\n            float nx = (x + 0.5 - nr.x1)/(2.0f*rx1);\n            float ny = (y + 0.5 - nr.y1)/(2.0f*ry1);\n            float dx = nx - 0.5;\n            float dy = ny - 0.5;\n            if (dx*dx + dy*dy <= 0.5*0.5) {\n                OLIVEC_PIXEL(oc, x, y) = color;\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_circle(Olivec_Canvas oc, int cx, int cy, int r, uint32_t color)\n{\n    Olivec_Normalized_Rect nr = {0};\n    int r1 = r + OLIVEC_SIGN(int, r);\n    if (!olivec_normalize_rect(cx - r1, cy - r1, 2*r1, 2*r1, oc.width, oc.height, &nr)) return;\n\n    for (int y = nr.y1; y <= nr.y2; ++y) {\n        for (int x = nr.x1; x <= nr.x2; ++x) {\n            int count = 0;\n            for (int sox = 0; sox < OLIVEC_AA_RES; ++sox) {\n                for (int soy = 0; soy < OLIVEC_AA_RES; ++soy) {\n                    // TODO: switch to 64 bits to make the overflow less likely\n                    // Also research the probability of overflow\n                    int res1 = (OLIVEC_AA_RES + 1);\n                    int dx = (x*res1*2 + 2 + sox*2 - res1*cx*2 - res1);\n                    int dy = (y*res1*2 + 2 + soy*2 - res1*cy*2 - res1);\n                    if (dx*dx + dy*dy <= res1*res1*r*r*2*2) count += 1;\n                }\n            }\n            uint32_t alpha = ((color&0xFF000000)>>(3*8))*count/OLIVEC_AA_RES/OLIVEC_AA_RES;\n            uint32_t updated_color = (color&0x00FFFFFF)|(alpha<<(3*8));\n            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), updated_color);\n        }\n    }\n}\n\nOLIVECDEF bool olivec_in_bounds(Olivec_Canvas oc, int x, int y)\n{\n    return 0 <= x && x < (int) oc.width && 0 <= y && y < (int) oc.height;\n}\n\n// TODO: AA for line\nOLIVECDEF void olivec_line(Olivec_Canvas oc, int x1, int y1, int x2, int y2, uint32_t color)\n{\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n\n    // If both of the differences are 0 there will be a division by 0 below.\n    if (dx == 0 && dy == 0) {\n        if (olivec_in_bounds(oc, x1, y1)) {\n            olivec_blend_color(&OLIVEC_PIXEL(oc, x1, y1), color);\n        }\n        return;\n    }\n\n    if (OLIVEC_ABS(int, dx) > OLIVEC_ABS(int, dy)) {\n        if (x1 > x2) {\n            OLIVEC_SWAP(int, x1, x2);\n            OLIVEC_SWAP(int, y1, y2);\n        }\n\n        for (int x = x1; x <= x2; ++x) {\n            int y = dy*(x - x1)/dx + y1;\n            // TODO: move boundary checks out side of the loops in olivec_draw_line\n            if (olivec_in_bounds(oc, x, y)) {\n                olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);\n            }\n        }\n    } else {\n        if (y1 > y2) {\n            OLIVEC_SWAP(int, x1, x2);\n            OLIVEC_SWAP(int, y1, y2);\n        }\n\n        for (int y = y1; y <= y2; ++y) {\n            int x = dx*(y - y1)/dy + x1;\n            // TODO: move boundary checks out side of the loops in olivec_draw_line\n            if (olivec_in_bounds(oc, x, y)) {\n                olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);\n            }\n        }\n    }\n}\n\nOLIVECDEF uint32_t mix_colors2(uint32_t c1, uint32_t c2, int u1, int det)\n{\n    // TODO: estimate how much overflows are an issue in integer only environment\n    int64_t r1 = OLIVEC_RED(c1);\n    int64_t g1 = OLIVEC_GREEN(c1);\n    int64_t b1 = OLIVEC_BLUE(c1);\n    int64_t a1 = OLIVEC_ALPHA(c1);\n\n    int64_t r2 = OLIVEC_RED(c2);\n    int64_t g2 = OLIVEC_GREEN(c2);\n    int64_t b2 = OLIVEC_BLUE(c2);\n    int64_t a2 = OLIVEC_ALPHA(c2);\n\n    if (det != 0) {\n        int u2 = det - u1;\n        int64_t r4 = (r1*u2 + r2*u1)/det;\n        int64_t g4 = (g1*u2 + g2*u1)/det;\n        int64_t b4 = (b1*u2 + b2*u1)/det;\n        int64_t a4 = (a1*u2 + a2*u1)/det;\n\n        return OLIVEC_RGBA(r4, g4, b4, a4);\n    }\n\n    return 0;\n}\n\nOLIVECDEF uint32_t mix_colors3(uint32_t c1, uint32_t c2, uint32_t c3, int u1, int u2, int det)\n{\n    // TODO: estimate how much overflows are an issue in integer only environment\n    int64_t r1 = OLIVEC_RED(c1);\n    int64_t g1 = OLIVEC_GREEN(c1);\n    int64_t b1 = OLIVEC_BLUE(c1);\n    int64_t a1 = OLIVEC_ALPHA(c1);\n\n    int64_t r2 = OLIVEC_RED(c2);\n    int64_t g2 = OLIVEC_GREEN(c2);\n    int64_t b2 = OLIVEC_BLUE(c2);\n    int64_t a2 = OLIVEC_ALPHA(c2);\n\n    int64_t r3 = OLIVEC_RED(c3);\n    int64_t g3 = OLIVEC_GREEN(c3);\n    int64_t b3 = OLIVEC_BLUE(c3);\n    int64_t a3 = OLIVEC_ALPHA(c3);\n\n    if (det != 0) {\n        int u3 = det - u1 - u2;\n        int64_t r4 = (r1*u1 + r2*u2 + r3*u3)/det;\n        int64_t g4 = (g1*u1 + g2*u2 + g3*u3)/det;\n        int64_t b4 = (b1*u1 + b2*u2 + b3*u3)/det;\n        int64_t a4 = (a1*u1 + a2*u2 + a3*u3)/det;\n\n        return OLIVEC_RGBA(r4, g4, b4, a4);\n    }\n\n    return 0;\n}\n\n// NOTE: we imply u3 = det - u1 - u2\nOLIVECDEF bool olivec_barycentric(int x1, int y1, int x2, int y2, int x3, int y3, int xp, int yp, int *u1, int *u2, int *det)\n{\n    *det = ((x1 - x3)*(y2 - y3) - (x2 - x3)*(y1 - y3));\n    *u1  = ((y2 - y3)*(xp - x3) + (x3 - x2)*(yp - y3));\n    *u2  = ((y3 - y1)*(xp - x3) + (x1 - x3)*(yp - y3));\n    int u3 = *det - *u1 - *u2;\n    return (\n               (OLIVEC_SIGN(int, *u1) == OLIVEC_SIGN(int, *det) || *u1 == 0) &&\n               (OLIVEC_SIGN(int, *u2) == OLIVEC_SIGN(int, *det) || *u2 == 0) &&\n               (OLIVEC_SIGN(int, u3) == OLIVEC_SIGN(int, *det) || u3 == 0)\n           );\n}\n\nOLIVECDEF bool olivec_normalize_triangle(size_t width, size_t height, int x1, int y1, int x2, int y2, int x3, int y3, int *lx, int *hx, int *ly, int *hy)\n{\n    *lx = x1;\n    *hx = x1;\n    if (*lx > x2) *lx = x2;\n    if (*lx > x3) *lx = x3;\n    if (*hx < x2) *hx = x2;\n    if (*hx < x3) *hx = x3;\n    if (*lx < 0) *lx = 0;\n    if ((size_t) *lx >= width) return false;;\n    if (*hx < 0) return false;;\n    if ((size_t) *hx >= width) *hx = width-1;\n\n    *ly = y1;\n    *hy = y1;\n    if (*ly > y2) *ly = y2;\n    if (*ly > y3) *ly = y3;\n    if (*hy < y2) *hy = y2;\n    if (*hy < y3) *hy = y3;\n    if (*ly < 0) *ly = 0;\n    if ((size_t) *ly >= height) return false;;\n    if (*hy < 0) return false;;\n    if ((size_t) *hy >= height) *hy = height-1;\n\n    return true;\n}\n\nOLIVECDEF void olivec_triangle3c(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3,\n                                 uint32_t c1, uint32_t c2, uint32_t c3)\n{\n    int lx, hx, ly, hy;\n    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {\n        for (int y = ly; y <= hy; ++y) {\n            for (int x = lx; x <= hx; ++x) {\n                int u1, u2, det;\n                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {\n                    olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), mix_colors3(c1, c2, c3, u1, u2, det));\n                }\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_triangle3z(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float z1, float z2, float z3)\n{\n    int lx, hx, ly, hy;\n    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {\n        for (int y = ly; y <= hy; ++y) {\n            for (int x = lx; x <= hx; ++x) {\n                int u1, u2, det;\n                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {\n                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;\n                    OLIVEC_PIXEL(oc, x, y) = *(uint32_t*)&z;\n                }\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_triangle3uv(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture)\n{\n    int lx, hx, ly, hy;\n    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {\n        for (int y = ly; y <= hy; ++y) {\n            for (int x = lx; x <= hx; ++x) {\n                int u1, u2, det;\n                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {\n                    int u3 = det - u1 - u2;\n                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;\n                    float tx = tx1*u1/det + tx2*u2/det + tx3*u3/det;\n                    float ty = ty1*u1/det + ty2*u2/det + ty3*u3/det;\n\n                    int texture_x = tx/z*texture.width;\n                    if (texture_x < 0) texture_x = 0;\n                    if ((size_t) texture_x >= texture.width) texture_x = texture.width - 1;\n\n                    int texture_y = ty/z*texture.height;\n                    if (texture_y < 0) texture_y = 0;\n                    if ((size_t) texture_y >= texture.height) texture_y = texture.height - 1;\n                    OLIVEC_PIXEL(oc, x, y) = OLIVEC_PIXEL(texture, (int)texture_x, (int)texture_y);\n                }\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_triangle3uv_bilinear(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture)\n{\n    int lx, hx, ly, hy;\n    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {\n        for (int y = ly; y <= hy; ++y) {\n            for (int x = lx; x <= hx; ++x) {\n                int u1, u2, det;\n                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {\n                    int u3 = det - u1 - u2;\n                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;\n                    float tx = tx1*u1/det + tx2*u2/det + tx3*u3/det;\n                    float ty = ty1*u1/det + ty2*u2/det + ty3*u3/det;\n\n                    float texture_x = tx/z*texture.width;\n                    if (texture_x < 0) texture_x = 0;\n                    if (texture_x >= (float) texture.width) texture_x = texture.width - 1;\n\n                    float texture_y = ty/z*texture.height;\n                    if (texture_y < 0) texture_y = 0;\n                    if (texture_y >= (float) texture.height) texture_y = texture.height - 1;\n\n                    int precision = 100;\n                    OLIVEC_PIXEL(oc, x, y) = olivec_pixel_bilinear(\n                                                 texture,\n                                                 texture_x*precision, texture_y*precision,\n                                                 precision, precision);\n                }\n            }\n        }\n    }\n}\n\n// TODO: AA for triangle\nOLIVECDEF void olivec_triangle(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color)\n{\n    int lx, hx, ly, hy;\n    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {\n        for (int y = ly; y <= hy; ++y) {\n            for (int x = lx; x <= hx; ++x) {\n                int u1, u2, det;\n                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {\n                    olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);\n                }\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_text(Olivec_Canvas oc, const char *text, int tx, int ty, Olivec_Font font, size_t glyph_size, uint32_t color)\n{\n    for (size_t i = 0; *text; ++i, ++text) {\n        int gx = tx + i*font.width*glyph_size;\n        int gy = ty;\n        const char *glyph = &font.glyphs[(*text)*sizeof(char)*font.width*font.height];\n        for (int dy = 0; (size_t) dy < font.height; ++dy) {\n            for (int dx = 0; (size_t) dx < font.width; ++dx) {\n                int px = gx + dx*glyph_size;\n                int py = gy + dy*glyph_size;\n                if (0 <= px && px < (int) oc.width && 0 <= py && py < (int) oc.height) {\n                    if (glyph[dy*font.width + dx]) {\n                        olivec_rect(oc, px, py, glyph_size, glyph_size, color);\n                    }\n                }\n            }\n        }\n    }\n}\n\nOLIVECDEF void olivec_sprite_blend(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)\n{\n    if (sprite.width == 0) return;\n    if (sprite.height == 0) return;\n\n    Olivec_Normalized_Rect nr = {0};\n    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;\n\n    int xa = nr.ox1;\n    if (w < 0) xa = nr.ox2;\n    int ya = nr.oy1;\n    if (h < 0) ya = nr.oy2;\n    for (int y = nr.y1; y <= nr.y2; ++y) {\n        for (int x = nr.x1; x <= nr.x2; ++x) {\n            size_t nx = (x - xa)*((int) sprite.width)/w;\n            size_t ny = (y - ya)*((int) sprite.height)/h;\n            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), OLIVEC_PIXEL(sprite, nx, ny));\n        }\n    }\n}\n\nOLIVECDEF void olivec_sprite_copy(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)\n{\n    if (sprite.width == 0) return;\n    if (sprite.height == 0) return;\n\n    // TODO: consider introducing flip parameter instead of relying on negative width and height\n    // Similar to how SDL_RenderCopyEx does that\n    Olivec_Normalized_Rect nr = {0};\n    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;\n\n    int xa = nr.ox1;\n    if (w < 0) xa = nr.ox2;\n    int ya = nr.oy1;\n    if (h < 0) ya = nr.oy2;\n    for (int y = nr.y1; y <= nr.y2; ++y) {\n        for (int x = nr.x1; x <= nr.x2; ++x) {\n            size_t nx = (x - xa)*((int) sprite.width)/w;\n            size_t ny = (y - ya)*((int) sprite.height)/h;\n            OLIVEC_PIXEL(oc, x, y) = OLIVEC_PIXEL(sprite, nx, ny);\n        }\n    }\n}\n\n// TODO: olivec_pixel_bilinear does not check for out-of-bounds\n// But maybe it shouldn't. Maybe it's a responsibility of the caller of the function.\nOLIVECDEF uint32_t olivec_pixel_bilinear(Olivec_Canvas sprite, int nx, int ny, int w, int h)\n{\n    int px = nx%w;\n    int py = ny%h;\n\n    int x1 = nx/w, x2 = nx/w;\n    int y1 = ny/h, y2 = ny/h;\n    if (px < w/2) {\n        // left\n        px += w/2;\n        x1 -= 1;\n        if (x1 < 0) x1 = 0;\n    } else {\n        // right\n        px -= w/2;\n        x2 += 1;\n        if ((size_t) x2 >= sprite.width) x2 = sprite.width - 1;\n    }\n\n    if (py < h/2) {\n        // top\n        py += h/2;\n        y1 -= 1;\n        if (y1 < 0) y1 = 0;\n    } else {\n        // bottom\n        py -= h/2;\n        y2 += 1;\n        if ((size_t) y2 >= sprite.height) y2 = sprite.height - 1;\n    }\n\n    return mix_colors2(mix_colors2(OLIVEC_PIXEL(sprite, x1, y1),\n                                   OLIVEC_PIXEL(sprite, x2, y1),\n                                   px, w),\n                       mix_colors2(OLIVEC_PIXEL(sprite, x1, y2),\n                                   OLIVEC_PIXEL(sprite, x2, y2),\n                                   px, w),\n                       py, h);\n}\n\nOLIVECDEF void olivec_sprite_copy_bilinear(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)\n{\n    // TODO: support negative size in olivec_sprite_copy_bilinear()\n    if (w <= 0) return;\n    if (h <= 0) return;\n\n    Olivec_Normalized_Rect nr = {0};\n    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;\n\n    for (int y = nr.y1; y <= nr.y2; ++y) {\n        for (int x = nr.x1; x <= nr.x2; ++x) {\n            size_t nx = (x - nr.ox1)*sprite.width;\n            size_t ny = (y - nr.oy1)*sprite.height;\n            OLIVEC_PIXEL(oc, x, y) = olivec_pixel_bilinear(sprite, nx, ny, w, h);\n        }\n    }\n}\n\n#endif // OLIVEC_IMPLEMENTATION\n\n// TODO: Benchmarking\n// TODO: SIMD implementations\n// TODO: bezier curves\n// TODO: olivec_ring\n// TODO: fuzzer\n// TODO: Stencil\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 24.0634765625,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"./assets/tsodinPog.c\"\n#include \"./assets/tsodinCup.c\"\n\n#define PI 3.14159265359\n\n#define return_defer(value) do { result = (value); goto defer; } while (0)\n#define UNUSED(x) (void)(x)\n#define UNIMPLEMENTED(message) \\\n    do { \\\n        fprintf(stderr, \"%s:%d: UNIMPLEMENTED: %s\\n\", __FILE__, __LINE__, message); \\\n        exit(1); \\\n    } while (0)\n#define UNREACHABLE(message) \\\n    do { \\\n        fprintf(stderr, \"%s:%d: UNREACHABLE: %s\\n\", __FILE__, __LINE__, message); \\\n        exit(1); \\\n    } while (0)\n\n#define ARENA_IMPLEMENTATION\n#include \"./arena.h\"\n\nstatic Arena default_arena = {0};\nstatic Arena *context_arena = &default_arena;\n\nstatic void *context_alloc(size_t size)\n{\n    assert(context_arena);\n    return arena_alloc(context_arena, size);\n}\n\nstatic void *context_realloc(void *oldp, size_t oldsz, size_t newsz)\n{\n    if (newsz <= oldsz) return oldp;\n    return memcpy(context_alloc(newsz), oldp, oldsz);\n}\n\n#define STBI_MALLOC context_alloc\n#define STBI_FREE UNUSED\n#define STBI_REALLOC_SIZED context_realloc\n#define STB_IMAGE_IMPLEMENTATION\n#include \"./stb_image.h\"\n\n#define STBIW_MALLOC STBI_MALLOC\n#define STBIW_FREE STBI_FREE\n#define STBIW_REALLOC_SIZED STBI_REALLOC_SIZED\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#include \"./stb_image_write.h\"\n\n#define OLIVEC_IMPLEMENTATION\n#include \"olive.c\"\n\n#define BACKGROUND_COLOR 0xFF202020\n#define FOREGROUND_COLOR 0xFF2020FF\n#define WHITE_COLOR 0xFFAAAAAA\n#define RED_COLOR 0xFF2020AA\n#define GREEN_COLOR 0xFF20AA20\n#define BLUE_COLOR 0xFFAA2020\n#define ERROR_COLOR 0xFFFF00FF\n\n#define TEST_DIR_PATH \"./test\"\n\nbool canvas_stbi_load(const char *file_path, Olivec_Canvas *oc)\n{\n    int width, height;\n    uint32_t *pixels = (uint32_t*) stbi_load(file_path, &width, &height, NULL, 4);\n    if (pixels == NULL) return false;\n    *oc = olivec_canvas(pixels, width, height, width);\n    return true;\n}\n\nbool canvas_stbi_save(Olivec_Canvas oc, const char *file_path)\n{\n    return stbi_write_png(file_path, oc.width, oc.height, 4, oc.pixels, sizeof(uint32_t)*oc.stride);\n}\n\ntypedef struct {\n    Olivec_Canvas (*generate_actual_canvas)(void);\n    const char *id;\n    const char *expected_file_path;\n    const char *actual_file_path;\n    const char *diff_file_path;\n} Test_Case;\n\n#define DEFINE_TEST_CASE(name) \\\n    { \\\n        .generate_actual_canvas = test_##name, \\\n        .id = #name, \\\n        .expected_file_path = TEST_DIR_PATH \"/\" #name \"_expected.png\", \\\n        .actual_file_path = TEST_DIR_PATH \"/\" #name \"_actual.png\", \\\n        .diff_file_path = TEST_DIR_PATH \"/\" #name \"_diff.png\", \\\n    }\n\nbool update_test_case(const Test_Case *tc)\n{\n    Olivec_Canvas actual_canvas = tc->generate_actual_canvas();\n    const char *expected_file_path = tc->expected_file_path;\n\n    if (!canvas_stbi_save(actual_canvas, expected_file_path)) {\n        fprintf(stderr, \"ERROR: could not write file %s: %s\\n\", expected_file_path, strerror(errno));\n        return(false);\n    }\n    printf(\"%s: Generated %s\\n\", tc->id, expected_file_path);\n    return(true);\n}\n\nOlivec_Canvas canvas_alloc(size_t width, size_t height)\n{\n    uint32_t *pixels = context_alloc(sizeof(uint32_t)*width*height);\n    return olivec_canvas(pixels, width, height, width);\n}\n\ntypedef enum {\n    REPLAY_PASSED,\n    REPLAY_FAILED,\n    REPLAY_ERRORED,\n} Replay_Result;\n\nstatic inline size_t min_size(size_t a, size_t b)\n{\n    if (a < b) return a;\n    return b;\n}\n\nstatic inline size_t max_size(size_t a, size_t b)\n{\n    if (a > b) return a;\n    return b;\n}\n\nReplay_Result run_test_case(const char *program_path, const Test_Case *tc)\n{\n    printf(\"%s:\", tc->id);\n    fflush(stdout);\n\n    const char *expected_file_path = tc->expected_file_path;\n    const char *actual_file_path = tc->actual_file_path;\n    const char *diff_file_path = tc->diff_file_path;\n\n    Olivec_Canvas actual_canvas = tc->generate_actual_canvas();\n\n    Olivec_Canvas expected_canvas;\n    if (!canvas_stbi_load(expected_file_path, &expected_canvas)) {\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"  ERROR: could not read %s: %s\\n\", expected_file_path, stbi_failure_reason());\n        if (errno == ENOENT) {\n            fprintf(stderr, \"  HINT: Consider running `$ %s update %s` to create it\\n\", program_path, tc->id);\n        }\n        return(REPLAY_ERRORED);\n    }\n\n    bool failed = false;\n\n    if (expected_canvas.width != actual_canvas.width || expected_canvas.height != actual_canvas.height) {\n        failed = true;\n    }\n\n    Olivec_Canvas diff_canvas =\n        canvas_alloc(\n            max_size(expected_canvas.width, actual_canvas.width),\n            max_size(expected_canvas.height, actual_canvas.height));\n    olivec_fill(diff_canvas, ERROR_COLOR);\n\n    for (size_t y = 0; y < min_size(expected_canvas.height, actual_canvas.height); ++y) {\n        for (size_t x = 0; x < min_size(expected_canvas.width, actual_canvas.width); ++x) {\n            uint32_t expected_pixel = OLIVEC_PIXEL(expected_canvas, x, y);\n            uint32_t actual_pixel = OLIVEC_PIXEL(actual_canvas, x, y);\n            if (expected_pixel != actual_pixel) {\n                OLIVEC_PIXEL(diff_canvas, x, y) = ERROR_COLOR;\n                failed = true;\n            } else {\n                OLIVEC_PIXEL(diff_canvas, x, y) = expected_pixel;\n            }\n        }\n    }\n\n    if (failed) {\n        fprintf(stderr, \"\\n\");\n\n        if (!canvas_stbi_save(actual_canvas, actual_file_path)) {\n            fprintf(stderr, \"  ERROR: could not write image file with actual pixels %s: %s\\n\", actual_file_path, strerror(errno));\n            return(REPLAY_ERRORED);\n        }\n\n        if (!canvas_stbi_save(diff_canvas, diff_file_path)) {\n            fprintf(stderr, \"  ERROR: could not wrilte diff image file %s: %s\\n\", diff_file_path, strerror(errno));\n            return(REPLAY_ERRORED);\n        }\n\n        fprintf(stderr, \"  TEST FAILURE: unexpected pixels in generated image\\n\");\n        fprintf(stderr, \"    Expected: %s\\n\", expected_file_path);\n        fprintf(stderr, \"    Actual:   %s\\n\", actual_file_path);\n        fprintf(stderr, \"    Diff:     %s\\n\", diff_file_path);\n        fprintf(stderr, \"  HINT: If this behaviour is intentional confirm that by updating the image with `$ %s update`\\n\", program_path);\n        return(REPLAY_FAILED);\n    }\n\n    printf(\" OK\\n\");\n\n    return(REPLAY_PASSED);\n}\n\nOlivec_Canvas test_fill_rect(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_rect(oc, width/2 - width/8, height/2 - height/8, width/4, height/4, RED_COLOR);\n    olivec_rect(oc, width - 1, height - 1, -width/2, -height/2, GREEN_COLOR);\n    olivec_rect(oc, -width/4, -height/4, width/2, height/2, BLUE_COLOR);\n    return oc;\n}\n\nOlivec_Canvas test_fill_circle(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_circle(oc, 0, 0, width/2, RED_COLOR);\n    olivec_circle(oc, width/2, height/2, width/4, BLUE_COLOR);\n    olivec_circle(oc, width*3/4, height*3/4, -width/4, GREEN_COLOR);\n    return oc;\n}\n\nOlivec_Canvas test_draw_line(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_line(oc, 0, 0, width, height, RED_COLOR);\n    olivec_line(oc, width, 0, 0, height, BLUE_COLOR);\n    olivec_line(oc, width/2, 0, width/2, height, GREEN_COLOR);\n    return oc;\n}\n\nOlivec_Canvas test_fill_triangle(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n\n    olivec_fill(oc, BACKGROUND_COLOR);\n\n    {\n        int x1 = width/2,   y1 = height/8;\n        int x2 = width/8,   y2 = height/2;\n        int x3 = width*7/8, y3 = height*7/8;\n        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, RED_COLOR);\n    }\n\n    {\n        int x1 = width/2,   y1 = height*2/8;\n        int x2 = width*2/8, y2 = height/2;\n        int x3 = width*6/8, y3 = height/2;\n        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, GREEN_COLOR);\n    }\n\n    {\n        int x1 = width/8,   y1 = height/8;\n        int x2 = width/8,   y2 = height*3/8;\n        int x3 = width*3/8, y3 = height*3/8;\n        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, BLUE_COLOR);\n    }\n\n    return oc;\n}\n\nOlivec_Canvas test_alpha_blending(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_rect(oc, 0, 0, width*3/4, height*3/4, RED_COLOR);\n    olivec_rect(oc, width-1, height-1, -width*3/4, -height*3/4, 0x5520AA20);\n    olivec_circle(oc, width/2, height/2, width/4, 0xBBAA2020);\n    olivec_triangle(oc, 0, height-1, width-1, height-1, width/2, 0, 0xBB20AAAA);\n    olivec_triangle3c(oc, 0, 0, width-1, 0, width/2, height-1, 0xBB2020AA, 0xBB20AA20, 0xBBAA2020);\n    return oc;\n}\n\nOlivec_Canvas test_checker_example(void)\n{\n    int width = 800/2;\n    int height = 600/2;\n    int cols = (8*2);\n    int rows = (6*2);\n    int cell_width = (width/cols);\n    int cell_height = (height/rows);\n    Olivec_Canvas oc = canvas_alloc(width, height);\n\n    olivec_fill(oc, BACKGROUND_COLOR);\n\n    for (int y = 0; y < rows; ++y) {\n        for (int x = 0; x < cols; ++x) {\n            uint32_t color = BACKGROUND_COLOR;\n            if ((x + y)%2 == 0) {\n                color = 0xFF2020FF;\n            }\n            olivec_rect(oc, x*cell_width, y*cell_height, cell_width, cell_height, color);\n        }\n    }\n\n    return oc;\n}\n\nOlivec_Canvas test_circle_example(void)\n{\n    int width = 800/2;\n    int height = 600/2;\n    int cols = (8*2);\n    int rows = (6*2);\n    int cell_width = (width/cols);\n    int cell_height = (height/rows);\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n\n    for (int y = 0; y < rows; ++y) {\n        for (int x = 0; x < cols; ++x) {\n            float u = (float)x/cols;\n            float v = (float)y/rows;\n            float t = (u + v)/2;\n\n            int radius = cell_width;\n            if (cell_height < radius) radius = cell_height;\n\n            olivec_circle(oc,\n                          x*cell_width + cell_width/2, y*cell_height + cell_height/2,\n                          (size_t) (radius/8*(1 - t) + radius/2*t),\n                          FOREGROUND_COLOR);\n        }\n    }\n\n    return oc;\n}\n\nOlivec_Canvas test_lines_circle(void)\n{\n    int width = 800/2;\n    int height = 600/2;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n\n    size_t n = 20;\n    float angle = 2*PI/n;\n    float length = width;\n    if (length > height) length = height;\n    length /= 3;\n    float x1 = width/2;\n    float y1 = height/2;\n    for (size_t i = 0; i < n; ++i) {\n        float x2 = x1 + cosf(angle*i)*length;\n        float y2 = y1 + sinf(angle*i)*length;\n        olivec_line(oc, x1, y1, x2, y2, 0xFF1818FF);\n    }\n\n    return oc;\n}\n\nOlivec_Canvas test_lines_example(void)\n{\n    int width = 800/2;\n    int height = 600/2;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_line(oc, 0, 0, width, height, FOREGROUND_COLOR);\n    olivec_line(oc, width, 0, 0, height, FOREGROUND_COLOR);\n    olivec_line(oc, 0, 0, width/4, height, 0xFF20FF20);\n    olivec_line(oc, width/4, 0, 0, height, 0xFF20FF20);\n    olivec_line(oc, width, 0, width/4*3, height, 0xFF20FF20);\n    olivec_line(oc, width/4*3, 0, width, height, 0xFF20FF20);\n    olivec_line(oc, 0, height/2, width, height/2, 0xFFFF3030);\n    olivec_line(oc, width/2, 0, width/2, height, 0xFFFF3030);\n\n    return oc;\n}\n\nOlivec_Canvas test_hello_world_text_rendering(void)\n{\n    size_t size = 5;\n    const char *text = \"hello, world\";\n    size_t text_len = strlen(text);\n    Olivec_Canvas oc = canvas_alloc(400, 150);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    olivec_text(oc, text, oc.width/2 - OLIVEC_DEFAULT_FONT_WIDTH*size*text_len/2, oc.height/2 - OLIVEC_DEFAULT_FONT_HEIGHT*size/2, olivec_default_font, size, FOREGROUND_COLOR);\n    return oc;\n}\n\nOlivec_Canvas test_line_edge_cases(void)\n{\n    size_t width = 10;\n    size_t height = 10;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n    // One pixel line\n    olivec_line(oc, width/2, height/2, width/2, height/2, FOREGROUND_COLOR);\n    // Out-of-bounds horizontally\n    olivec_line(oc, width + 10, height/2, width + 20, height/2, FOREGROUND_COLOR);\n    // Out-of-bounds vertically\n    olivec_line(oc, width/2, height + 10, width/2, height + 20, FOREGROUND_COLOR);\n    return oc;\n}\n\nOlivec_Canvas test_frame(void)\n{\n    size_t width = 256;\n    size_t height = 128;\n    Olivec_Canvas oc = canvas_alloc(width, height);\n    olivec_fill(oc, BACKGROUND_COLOR);\n\n    {\n        size_t w = width/2;\n        size_t h = height/2;\n        olivec_frame(oc, 0, 0, w, h, 1, RED_COLOR);\n    }\n\n    {\n        olivec_frame(oc, width/2, height/2, width, height, 1, GREEN_COLOR);\n    }\n\n    // Odd thiccness\n    {\n        size_t w = width/2;\n        size_t h = height/2;\n        size_t t = 5;\n        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);\n        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, 1, RED_COLOR);\n    }\n\n    // Even thiccness\n    {\n        size_t w = width/4 + 1;\n        size_t h = height/4;\n        size_t t = 6;\n        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);\n        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, 1, RED_COLOR);\n    }\n\n    // Zero thiccness\n    {\n        size_t w = width/8;\n        size_t h = height/8;\n        size_t t = 0;\n        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);\n    }\n\n    return oc;\n}\n\nOlivec_Canvas test_sprite_blend(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas dst = canvas_alloc(width, height);\n    olivec_fill(dst, RED_COLOR);\n    Olivec_Canvas src = canvas_alloc(width, height);\n\n    for (size_t y = 0; y < src.height; ++y) {\n        for (size_t x = 0; x < src.width; ++x) {\n            if ((x + y)%2 == 0) {\n                OLIVEC_PIXEL(src, x, y) = 0;\n            } else {\n                OLIVEC_PIXEL(src, x, y) = GREEN_COLOR;\n            }\n        }\n    }\n\n    olivec_sprite_blend(dst, 0, 0, width, height, src);\n\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_out_of_bounds_cut(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas dst = canvas_alloc(width, height);\n    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);\n    olivec_fill(dst, RED_COLOR);\n    olivec_sprite_blend(dst, -width/2, -height/2, width, height, src);\n    olivec_sprite_blend(dst, width/2, -height/2, width, height, src);\n    olivec_sprite_blend(dst, -width/2, height/2, width, height, src);\n    olivec_sprite_blend(dst, width/2, height/2, width, height, src);\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_flip(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas dst = canvas_alloc(width, height);\n    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);\n    olivec_fill(dst, RED_COLOR);\n    olivec_sprite_blend(dst, 0, 0, width/2, height/2, src);\n    olivec_sprite_blend(dst, width - 1, 0, -width/2, height/2, src);\n    olivec_sprite_blend(dst, 0, height - 1, width/2, -height/2, src);\n    olivec_sprite_blend(dst, width - 1, height - 1, -width/2, -height/2, src);\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_flip_cut(void)\n{\n    size_t width = 128;\n    size_t height = 128;\n    Olivec_Canvas dst = canvas_alloc(width, height);\n    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);\n    olivec_fill(dst, RED_COLOR);\n    olivec_sprite_blend(dst, -width/2, -height/2, width, height, src);\n    olivec_sprite_blend(dst, width - 1 + width/2, -height/2, -width, height, src);\n    olivec_sprite_blend(dst, -width/2, height - 1 + height/2, width, -height, src);\n    olivec_sprite_blend(dst, width - 1 + width/2, height - 1 + height/2, -width, -height, src);\n    return dst;\n}\n\nOlivec_Canvas test_empty_rect(void)\n{\n    size_t w = 8;\n    size_t h = 8;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    olivec_fill(dst, BACKGROUND_COLOR);\n    olivec_rect(dst, w/2, h/2, 0, 0, FOREGROUND_COLOR);\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_empty_rect(void)\n{\n    size_t w = 8;\n    size_t h = 8;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);\n    olivec_fill(dst, BACKGROUND_COLOR);\n    olivec_sprite_blend(dst, 0, 0, 0, 0, src);\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_null(void)\n{\n    size_t w = 8;\n    size_t h = 8;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    olivec_fill(dst, BACKGROUND_COLOR);\n    olivec_sprite_blend(dst, 0, 0, w, h, OLIVEC_CANVAS_NULL);\n    return dst;\n}\n\nOlivec_Canvas test_sprite_blend_vs_copy(void)\n{\n    Olivec_Canvas tsodinCup = olivec_canvas(tsodinCup_pixels, tsodinCup_width, tsodinCup_height, tsodinCup_width);\n    size_t w = tsodinCup.width;\n    size_t h = tsodinCup.height*2;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    olivec_fill(dst, RED_COLOR);\n    olivec_sprite_blend(dst, 0, 0, tsodinCup.width, tsodinCup.height, tsodinCup);\n    olivec_sprite_copy(dst, 0, tsodinCup.height, tsodinCup.width, tsodinCup.height, tsodinCup);\n    return dst;\n}\n\nOlivec_Canvas test_barycentric_overflow(void)\n{\n    size_t w = 256;\n    size_t h = 256;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    olivec_fill(dst, 0xFF181818);\n    olivec_triangle3c(dst, w/4, h/4, w/2, 0, 0, h, 0xFF0000FF, 0xFF00FF00, 0xFFFF0000);\n    return dst;\n}\n\nOlivec_Canvas test_triangle_order_flip(void)\n{\n    size_t w = 256;\n    size_t h = 256;\n    Olivec_Canvas dst = canvas_alloc(w, h);\n    olivec_fill(dst, 0xFF181818);\n    olivec_triangle3c(\n        dst,\n        w/4, h/4,\n        0, h,\n        w, 0,\n        0xFF00FF00,\n        0xFFFF0000,\n        0xFF0000FF);\n    return dst;\n}\n\nOlivec_Canvas test_bilinear_interpolation(void)\n{\n    size_t factor = 2;\n    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);\n    Olivec_Canvas dst = canvas_alloc(src.width*factor*2, src.height*factor);\n    olivec_fill(dst, RED_COLOR);\n    olivec_sprite_copy(dst, 0, 0, src.width*factor, src.height*factor, src);\n    olivec_sprite_copy_bilinear(dst, src.width*factor, 0, src.width*factor, src.height*factor, src);\n    return dst;\n}\n\nOlivec_Canvas test_fill_ellipse(void)\n{\n    size_t factor = 3;\n    Olivec_Canvas dst = canvas_alloc(100*factor, 50*factor);\n    olivec_fill(dst, BACKGROUND_COLOR);\n    olivec_ellipse(dst, dst.width/2, dst.height/2, dst.width/3, dst.height/3, RED_COLOR);\n    return dst;\n}\n\nOlivec_Canvas test_line_bug_offset(void)\n{\n    size_t factor = 3;\n    size_t width = 100*factor;\n    size_t height = 50*factor;\n    Olivec_Canvas dst = canvas_alloc(width, height);\n    olivec_fill(dst, BACKGROUND_COLOR);\n    int x1 = 50;\n    int y1 = 100;\n    int x2 = 0;\n    int y2 = -100;\n    olivec_line(dst, x1, y1, x2, y2, GREEN_COLOR);\n    olivec_circle(dst, x1, y1, 5, RED_COLOR);\n    return dst;\n}\n\nTest_Case test_cases[] = {\n    DEFINE_TEST_CASE(fill_rect),\n    DEFINE_TEST_CASE(fill_circle),\n    DEFINE_TEST_CASE(draw_line),\n    DEFINE_TEST_CASE(fill_triangle),\n    DEFINE_TEST_CASE(alpha_blending),\n    DEFINE_TEST_CASE(checker_example),\n    DEFINE_TEST_CASE(circle_example),\n    DEFINE_TEST_CASE(lines_example),\n    DEFINE_TEST_CASE(hello_world_text_rendering),\n    DEFINE_TEST_CASE(lines_circle),\n    DEFINE_TEST_CASE(line_edge_cases),\n    DEFINE_TEST_CASE(frame),\n    DEFINE_TEST_CASE(sprite_blend),\n    DEFINE_TEST_CASE(sprite_blend_out_of_bounds_cut),\n    DEFINE_TEST_CASE(sprite_blend_flip),\n    DEFINE_TEST_CASE(sprite_blend_flip_cut),\n    DEFINE_TEST_CASE(sprite_blend_empty_rect),\n    DEFINE_TEST_CASE(empty_rect),\n    DEFINE_TEST_CASE(sprite_blend_null),\n    DEFINE_TEST_CASE(sprite_blend_vs_copy),\n    DEFINE_TEST_CASE(triangle_order_flip),\n    DEFINE_TEST_CASE(barycentric_overflow),\n    DEFINE_TEST_CASE(bilinear_interpolation),\n    DEFINE_TEST_CASE(fill_ellipse),\n    DEFINE_TEST_CASE(line_bug_offset),\n};\n#define TEST_CASES_COUNT (sizeof(test_cases)/sizeof(test_cases[0]))\n\nconst char *shift(int *argc, char ***argv)\n{\n    assert(*argc > 0);\n    const char *result = *argv[0];\n    *argc -= 1;\n    *argv += 1;\n    return result;\n}\n\nvoid list_available_tests(void)\n{\n    fprintf(stderr, \"Available tests:\\n\");\n    for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {\n        fprintf(stderr, \"    %s\\n\", test_cases[i].id);\n    }\n}\n\nTest_Case *find_test_case_by_id(const char *id)\n{\n    for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {\n        if (strcmp(test_cases[i].id, id) == 0) {\n            return &test_cases[i];\n        }\n    }\n    return NULL;\n}\ntypedef struct {\n    int (*run)(const char *program_path, int argc, char **argv);\n    const char *id;\n    const char *description;\n} Subcmd;\n\nvoid usage(const char *program_path);\n\nint subcmd_run(const char *program_path, int argc, char **argv)\n{\n    if (argc <= 0) {\n        for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {\n            if (run_test_case(program_path, &test_cases[i]) == REPLAY_ERRORED) return(1);\n            arena_reset(&default_arena);\n        }\n    } else {\n        const char *test_case_id = shift(&argc, &argv);\n        Test_Case *tc = find_test_case_by_id(test_case_id);\n        if (tc == NULL) {\n            list_available_tests();\n            fprintf(stderr, \"ERROR: could not find test case `%s`\\n\", test_case_id);\n            return(1);\n        }\n\n        if (run_test_case(program_path, tc) == REPLAY_ERRORED) return(1);\n    }\n\n    return 0;\n}\n\nint subcmd_update(const char *program_path, int argc, char **argv)\n{\n    UNUSED(program_path);\n\n    if (argc <= 0) {\n        for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {\n            if (!update_test_case(&test_cases[i])) return(1);\n            arena_reset(&default_arena);\n        }\n    } else {\n        const char *test_case_id = shift(&argc, &argv);\n        Test_Case *tc = find_test_case_by_id(test_case_id);\n        if (tc == NULL) {\n            list_available_tests();\n            fprintf(stderr, \"ERROR: could not find test case `%s`\\n\", test_case_id);\n            return(1);\n        }\n\n        if (!update_test_case(tc)) return(1);\n    }\n\n    return 0;\n}\n\nint subcmd_list(const char *program_path, int argc, char **argv)\n{\n    UNUSED(program_path);\n    UNUSED(argc);\n    UNUSED(argv);\n    list_available_tests();\n    return 0;\n}\n\nint subcmd_help(const char *program_path, int argc, char **argv)\n{\n    UNUSED(argc);\n    UNUSED(argv);\n    usage(program_path);\n    return 0;\n}\n\n#define DEFINE_SUBCMD(name, desc) \\\n    { \\\n        .run = subcmd_##name, \\\n        .id = #name, \\\n        .description = desc, \\\n    }\n\nSubcmd subcmds[] = {\n    DEFINE_SUBCMD(run, \"Run the tests\"),\n    DEFINE_SUBCMD(update, \"Update the tests\"),\n    DEFINE_SUBCMD(list, \"List all available tests\"),\n    DEFINE_SUBCMD(help, \"Print this help message\"),\n};\n#define SUBCMDS_COUNT (sizeof(subcmds)/sizeof(subcmds[0]))\n\nSubcmd *find_subcmd_by_id(const char *id)\n{\n    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {\n        if (strcmp(subcmds[i].id, id) == 0) {\n            return &subcmds[i];\n        }\n    }\n    return NULL;\n}\n\nvoid usage(const char *program_path)\n{\n    fprintf(stderr, \"Usage: %s [Subcommand]\\n\", program_path);\n    fprintf(stderr, \"Subcommands:\\n\");\n\n    int width = 0;\n    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {\n        int len = strlen(subcmds[i].id);\n        if (width < len) width = len;\n    }\n\n    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {\n        fprintf(stderr, \"    %-*s - %s\\n\", width, subcmds[i].id, subcmds[i].description);\n    }\n}\n\nint main(int argc, char **argv)\n{\n    int result = 0;\n\n    {\n        const char *program_path = shift(&argc,  &argv);\n\n        if (argc <= 0) {\n            usage(program_path);\n            fprintf(stderr, \"ERROR: no subcommand is provided\\n\");\n            return_defer(1);\n        }\n\n        const char *subcmd_id = shift(&argc, &argv);\n        Subcmd *subcmd = find_subcmd_by_id(subcmd_id);\n        if (subcmd != NULL) {\n            return_defer(subcmd->run(program_path, argc, argv));\n        } else {\n            usage(program_path);\n            fprintf(stderr, \"ERROR: unknown subcommand `%s`\\n\", subcmd_id);\n            return_defer(1);\n        }\n    }\n\ndefer:\n    arena_free(&default_arena);\n    return result;\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "wasm",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}