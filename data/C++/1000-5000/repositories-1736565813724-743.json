{
  "metadata": {
    "timestamp": 1736565813724,
    "page": 743,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thepowersgang/mrustc",
      "stars": 2224,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.89453125,
          "content": "\n.*\n*.gch\n*.gch.dep\n*.sw[po]\n*~\n\n/obj\n/bin\n/mrustc.depend\n/mrustc.layout\n/rustc-*-src.tar.gz\n/rustc-*-src\n/rustc_bootstrap\n/crates.io\n/test_deps_run-pass.mk\n\n/tools/bin\n\n/output\n/output-*\n\n/vsproject/Win32\n/vsproject/x64\n/vsproject/*/Win32\n/vsproject/*/x64\n/vsproject/packages\n/vsproject/*.sdf\n/vsproject/*.VC.db\n/vsproject/*.depend\n/vsproject/*.opendb\n/vsproject/*.user\n/vsproject/*/*.opendb\n/vsproject/*/*.user\n/vsproject/output\n/vsproject/output-*\n/vsproject/output_mmir\n/vsproject/*.obj\n/vsproject/*.pdb\n/vsproject/smiri.log\n/vsproject/*.dmp\n/vsproject/*/*.dmp\n/vsproject/*.txt\n\n\n/run_rustc/output\n/run_rustc/output-*\n\n/gitstats\n\n/lib/libproc_macro/Cargo.lock\n/lib/libproc_macro/target\n/lib/libproc_macro/tools/dump.exe\n/lib/libproc_macro/tools/dump.pdb\n\n/bnf/*.o\n/bnf/*.dep\n/bnf/.gen/\n/bnf/output/\n/bnf/.rust.y\n/bnf/rust.lex.c\n/bnf/rust.tab.c\n/bnf/rust.tab.h\n/bnf/rust.output\n/bnf/test.bin\n/scripts/__pycache__\n"
        },
        {
          "name": ".lvimrc",
          "type": "blob",
          "size": 0.232421875,
          "content": "set expandtab\nset sts=4 ts=4 sw=4\nset list\nset listchars=eol:$,tab:>-\n\"set textwidth=118\n\"set tw=118\nset autoindent\n\nhighlight ExtraWhitespace ctermbg=darkgreen guibg=darkgreen\nautocmd Syntax * syn match ExtraWhitespace /\\s\\+$\\| \\+\\ze\\t/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.03125,
          "content": "language: cpp\n\nsudo: false\n\nmatrix:\n  include:\n   # Linux\n   - os: linux\n     before_install:\n      - export CC=gcc-6\n#      - export CC-x86_64-linux-gnu=gcc-6\n      - export CXX=g++-6\n     addons:\n      apt:\n       sources:\n         - ubuntu-toolchain-r-test\n       packages:\n         - g++-6\n         - zlib1g-dev\n         - valgrind\n   # OSX\n   - os: osx\n  allow_failures:\n   - os: osx\n\ninstall:\n # Build mrustc\n - make RUSTCSRC\n - make -j 2\n - make -C tools/minicargo\n - make -C tools/mir_opt_test\n\nscript:\n - set -e\n - make -C tools/mir_opt_test run\n - make -f minicargo.mk output/libtest.rlib      # libstd\n - make test    # hello_world\n# Tests\n - set +e\n - make local_tests -k || (sh -c 'cat output/local_tests/*.out_failed'; false)\n# - make rust_tests -k\n - set -e\n# rustc_driver - Takes too long\n# - RUST_CHECK=1 make -f minicargo.mk output/rustc-build/librustc_driver.rlib\n# rustc (DISABLED: llvm build)\n# - make -f minicargo.mk output/rustc\n# cargo (DISABLED: why?)\n# - make -f minicargo.mk output/cargo\n# - cat output/cargo-build/cargo_dbg.txt\n"
        },
        {
          "name": "LICENCE-MIT",
          "type": "blob",
          "size": 1.029296875,
          "content": "Copyright (c) 2015 John Hodge\n\nPermission is hereby granted, free of charge, to any\nperson obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without\nlimitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice\nshall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.1513671875,
          "content": "# MRustC - Rust Compiler\n# - By John Hodge (Mutabah/thePowersGang)\n#\n# Makefile\n#\n# - Compiles mrustc\n# - Provides shortcuts to tasks done in minicargo.mk\n#\n# DEPENDENCIES\n# - zlib (-dev)\n# - curl (bin, for downloading libstd source)\n\nifeq ($(OS),Windows_NT)\n  EXESUF ?= .exe\nelse\n  EXESUF ?=\nendif\n# CXX : C++ compiler\nCXX ?= g++\n# V (or VERBOSE) : If set, prints all important commands\nV ?= !\n# GPROF : If set, enables the generation of a gprof annotated executable\nGPROF ?=\n\nOBJCOPY ?= objcopy\nSTRIP ?= strip\n\nifneq ($(VERBOSE),)\n V :=\nendif\nifeq ($(V),!)\n  V := @\nelse\n  V :=\nendif\n\nTAIL_COUNT ?= 10\n\n# - Disable implicit rules\n.SUFFIXES:\n# - Disable deleting intermediate files\n.SECONDARY:\n\nLINKFLAGS := -g\nLIBS := -lz\nCXXFLAGS := -g -Wall\nCXXFLAGS += -std=c++14\n#CXXFLAGS += -Wextra\nCXXFLAGS += -O2\nCXXFLAGS += $(CXXFLAGS_EXTRA)\n\nCPPFLAGS := -I src/include/ -I src/\nCPPFLAGS += -I tools/common/\n\nCXXFLAGS += -Wno-pessimizing-move\nCXXFLAGS += -Wno-misleading-indentation\n#CXXFLAGS += -Wno-unused-private-field\n#CXXFLAGS += -Wno-unknown-warning-option\n\nCXXFLAGS += -Werror=return-type\nCXXFLAGS += -Werror=switch\n\n# Force the use of `bash` as the shell\nSHELL = bash\n\nOBJDIR = .obj/\n\nifneq ($(GPROF),)\n  OBJDIR := .obj-gprof/\n  CXXFLAGS += -pg -no-pie\n  LINKFLAGS += -pg -no-pie\n  EXESUF := -gprof$(EXESUF)\nendif\n\nLINKFLAGS += $(LINKFLAGS_EXTRA)\n\nBIN := bin/mrustc$(EXESUF)\n\nOBJ := main.o version.o\nOBJ += span.o rc_string.o debug.o ident.o\nOBJ += ast/ast.o\nOBJ +=  ast/types.o ast/crate.o ast/path.o ast/expr.o ast/pattern.o\nOBJ +=  ast/dump.o\nOBJ += parse/parseerror.o\nOBJ +=  parse/token.o parse/tokentree.o parse/interpolated_fragment.o\nOBJ +=  parse/tokenstream.o parse/lex.o parse/ttstream.o\nOBJ +=  parse/root.o parse/paths.o parse/types.o parse/expr.o parse/pattern.o\nOBJ += expand/mod.o expand/macro_rules.o expand/cfg.o\nOBJ +=  expand/format_args.o expand/asm.o\nOBJ +=  expand/concat.o expand/stringify.o expand/file_line.o\nOBJ +=  expand/derive.o expand/lang_item.o\nOBJ +=  expand/std_prelude.o expand/crate_tags.o\nOBJ +=  expand/include.o\nOBJ +=  expand/env.o\nOBJ +=  expand/test.o\nOBJ +=  expand/rustc_diagnostics.o\nOBJ +=  expand/proc_macro.o\nOBJ +=  expand/assert.o expand/compile_error.o\nOBJ +=  expand/codegen.o expand/doc.o expand/lints.o expand/misc_attrs.o expand/stability.o\nOBJ +=  expand/panic.o\nOBJ +=  expand/rustc_box.o\nOBJ += expand/test_harness.o\nOBJ += macro_rules/mod.o macro_rules/eval.o macro_rules/parse.o\nOBJ += resolve/use.o resolve/index.o resolve/absolute.o resolve/common.o\nOBJ += hir/from_ast.o hir/from_ast_expr.o\nOBJ +=  hir/dump.o\nOBJ +=  hir/hir.o hir/hir_ops.o hir/generic_params.o\nOBJ +=  hir/crate_ptr.o hir/expr_ptr.o\nOBJ +=  hir/type.o hir/path.o hir/expr.o hir/pattern.o\nOBJ +=  hir/visitor.o hir/crate_post_load.o\nOBJ +=  hir/inherent_cache.o\nOBJ += hir_conv/expand_type.o hir_conv/constant_evaluation.o hir_conv/resolve_ufcs.o hir_conv/bind.o hir_conv/markings.o\nOBJ +=  hir_conv/lifetime_elision.o\nOBJ += hir_typeck/outer.o hir_typeck/common.o hir_typeck/helpers.o hir_typeck/static.o hir_typeck/impl_ref.o\nOBJ +=  hir_typeck/resolve_common.o\nOBJ +=  hir_typeck/expr_visit.o\nOBJ +=  hir_typeck/expr_cs.o hir_typeck/expr_cs__enum.o\nOBJ +=  hir_typeck/expr_check.o\nOBJ += hir_expand/annotate_value_usage.o hir_expand/closures.o\nOBJ +=  hir_expand/ufcs_everything.o\nOBJ +=  hir_expand/reborrow.o hir_expand/erased_types.o hir_expand/vtable.o\nOBJ +=  hir_expand/static_borrow_constants.o\nOBJ +=  hir_expand/lifetime_infer.o\nOBJ += mir/mir.o mir/mir_ptr.o\nOBJ +=  mir/dump.o mir/helpers.o mir/visit_crate_mir.o\nOBJ +=  mir/from_hir.o mir/from_hir_match.o mir/mir_builder.o\nOBJ +=  mir/check.o mir/cleanup.o mir/optimise.o\nOBJ +=  mir/check_full.o\nOBJ +=  mir/borrow_check.o\nOBJ += hir/serialise.o hir/deserialise.o hir/serialise_lowlevel.o\nOBJ += trans/trans_list.o trans/mangling_v2.o\nOBJ +=  trans/enumerate.o trans/auto_impls.o trans/monomorphise.o trans/codegen.o\nOBJ +=  trans/codegen_c.o trans/codegen_c_structured.o trans/codegen_mmir.o\nOBJ +=  trans/target.o trans/allocator.o\n\n# TODO is this needed? (or worth it)\nPCHS := ast/ast.hpp\n\nOBJ := $(addprefix $(OBJDIR),$(OBJ))\n\n.PHONY: all clean\n\nall: $(BIN)\n\nclean:\n\t$(RM) -rf -- $(BIN) $(OBJ) bin/mrustc.a\n\n\n#\n# Defer to minicargo.mk for some common operations\n#\n.PHONY: rust_tests-libs\n.PHONY: local_tests\n.PHONY: RUSTCSRC\n.PHONY: test\n.PHONY: LIBS\nrust_tests-libs local_tests RUSTCSRC test LIBS:\n\t$(MAKE) -f minicargo.mk $@\n\n# -------------------------------\n# Compile rules for mrustc itself\n# -------------------------------\nbin/mrustc.a: $(filter-out $(OBJDIR)main.o, $(OBJ))\n\t@+mkdir -p $(dir $@)\n\t@echo [AR] $@\n\t$V$(AR) crs $@ $(filter-out $(OBJDIR)main.o, $(OBJ))\n\n$(BIN): $(OBJDIR)main.o bin/mrustc.a bin/common_lib.a\n\t@+mkdir -p $(dir $@)\n\t@echo [CXX] -o $@\nifeq ($(OS),Windows_NT)\n\t$V$(CXX) -o $@ $(LINKFLAGS) $(OBJDIR)main.o -Wl,--whole-archive bin/mrustc.a bin/common_lib.a -Wl,--no-whole-archive $(LIBS)\nelse ifeq ($(shell uname -s || echo not),Darwin)\n\t$V$(CXX) -o $@ $(LINKFLAGS) $(OBJDIR)main.o -Wl,-all_load bin/mrustc.a bin/common_lib.a $(LIBS)\nelse\n\t$V$(CXX) -o $@ $(LINKFLAGS) $(OBJDIR)main.o -Wl,--whole-archive bin/mrustc.a -Wl,--no-whole-archive bin/common_lib.a $(LIBS)\n\t$(OBJCOPY) --only-keep-debug $(BIN) $(BIN).debug\n\t$(OBJCOPY) --add-gnu-debuglink=$(BIN).debug $(BIN)\n\t$(STRIP) $(BIN)\nendif\n\n$(OBJDIR)%.o: src/%.cpp\n\t@+mkdir -p $(dir $@)\n\t@echo [CXX] -o $@\n\t$V$(CXX) -o $@ -c $< $(CXXFLAGS) $(CPPFLAGS) -MMD -MP -MF $@.dep\n$(OBJDIR)version.o: $(OBJDIR)%.o: src/%.cpp $(filter-out $(OBJDIR)version.o,$(OBJ)) Makefile\n\t@+mkdir -p $(dir $@)\n\t@echo [CXX] -o $@\n\t$V$(CXX) -o $@ -c $< $(CXXFLAGS) $(CPPFLAGS) -MMD -MP -MF $@.dep -D VERSION_GIT_FULLHASH=\\\"$(shell git show --pretty=%H -s --no-show-signature)\\\" -D VERSION_GIT_BRANCH=\"\\\"$(shell git symbolic-ref -q --short HEAD || git describe --tags --exact-match)\\\"\" -D VERSION_GIT_SHORTHASH=\\\"$(shell git show -s --pretty=%h --no-show-signature)\\\" -D VERSION_BUILDTIME=\"\\\"$(shell date -uR)\\\"\" -D VERSION_GIT_ISDIRTY=$(shell git diff-index --quiet HEAD; echo $$?)\n\nsrc/main.cpp: $(PCHS:%=src/%.gch)\n\n%.hpp.gch: %.hpp\n\t@echo [CXX] -o $@\n\t$V$(CXX) -std=c++14 -o $@ $< $(CPPFLAGS) -MMD -MP -MF $@.dep\n\nbin/common_lib.a: $(wildcard tools/common/*)\n\t$(MAKE) -C tools/common\n\t\n-include $(OBJ:%=%.dep)\n\n# vim: noexpandtab ts=4\n\n"
        },
        {
          "name": "Notes",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.89453125,
          "content": "# Mutabah's Rust Compiler\n\n_In-progress_ alternative rust compiler. Capable of building a fully-working copy of rustc, but not suitable for everyday use (due to terrible error messages).\n\n[![Build Status: windows](https://ci.appveyor.com/api/projects/status/96y4ui20pl8xjm2h/branch/master?svg=true)](https://ci.appveyor.com/project/thepowersgang/mrustc/branch/master)\n[![C/C++ CI](https://github.com/thepowersgang/mrustc/actions/workflows/c-cpp.yml/badge.svg)](https://github.com/thepowersgang/mrustc/actions/workflows/c-cpp.yml)\n\nIntro\n===\nThis project is a \"simple\" rust compiler written in C++ that is able to bootstrap a \"recent\" rustc.\n\nAs `mrustc`'s primary goal is bootstrapping `rustc`, and as such it tends to assume that the code it's compiling is valid (and any errors in the generated code are mrustc bugs). Code generation is done by emitting a high-level assembly (currently very ugly C, but LLVM/cretone/GIMPLE/... could work) and getting an external tool (i.e. `gcc`) to do the heavy-lifting of optimising and machine code generation.\n\nProgress\n--------\n\n- Builds working copies of `rustc` and `cargo` from a release source tarball\n  - Supports (and can bootstrap) rustc 1.19.0, 1.29.0, 1.39.0, 1.54.0, and 1.74.0\n  - NOTE: Older versions (1.29 and older) don't build on modern systems, due to outdated openssl bindings\n- Supported Targets (CI tested for libstd):\n  - x86-64 linux GNU (should always work, fully bootstrap tested)\n  - x86-64 windows MSVC (Status: runnable executables on Windows 10, but bootstrap hasn't ever been fully tested)\n  - Secondary Targets\n    - x86-64 and arm64 macOS\n    - (incomplete) x86 windows MSVC\n- `rustc` bootstrap tested and validated (1.19.0 isn't fully repeatable, but later versions are)\n  - See the script `TestRustcBootstrap.sh` for how this was done.\n\n\nGetting Started\n===============\n\nYou can set the number of jobs (parallel builds) by setting the enviromment variable `PARLEVEL`, e.g. `PARLEVEL=$(nproc)` for CPU core count. This can and will break at times, as such outside of toying around, it's best to do `PARLEVEL=1` or let mrustc figure it out by itself.\n\nDependencies\n------------\n- C++14-compatible compiler (tested with gcc 5.4 and gcc 6, and MSVC 2015)\n- C11 compatible C compiler (for output, see above)\n- `make` (for the mrustc makefiles)\n- `patch` (For doing minor edits to the rustc source)\n- `libz-dev` (used to reduce size of bytecode files, linux only - windows uses vcpkg to download it)\n- `curl` (for downloading the rust source, linux only)\n- `cmake` (at least 3.4.3, required for building llvm in rustc)\n- `pkg-config` (required for find crate build deps, i.e libssl)\n- `python3` (required for building llvm in rustc)\n\nLinux GNU and macOS\n-----\n- `make RUSTCSRC` - Downloads the rustc source tarball (1.29.0 by default)\n- `make -f minicargo.mk` - Builds `mrustc` and `minicargo`, then builds `libstd`, `libtest`, finally `rustc` and `cargo`\n- `make -C run_rustc` - Build `libstd` and a \"hello, world\" using the above-built rustc\n\nBSD\n---\nSimilar to Linux, but you might need to\n- specify the rustc default target explicitly\n- specify the compiler\n- use `gmake` to run GNU make\n\ne.g. `gmake CC=cc RUSTC_TARGET=x86_64-unknown-freebsd -f minicargo.mk`\n\nWindows\n--------\n(Tested with VS2015)\n- Download and extract `rustc-1.29.0-src.tar.gz` to the repository root (such that the `rustc-1.29.0-src` directory is present)\n  - NOTE: I am open to suggestions for how to automate that step\n- Open `vsproject/mrustc.sln` and build minicargo\n- Run `vsproject/run_hello.cmd` to build libstd and \"hello, world\", and run it\n  - There are other similar scripts for building cargo and rustc. Cargo works,\n    but rustc hasn't fully been tested (building LLVM on windows has been a challenge)\n\n\nBuilding non-rustc code\n=======================\n\nTo build your own code with mrustc, first you need to build at least libcore (and probably the full standard library).\nThis can be done on Linux or macOS by running `make -f minicargo.mk LIBS`, or on windows with `build_std.cmd`.\n\nNext, run\n- `minicargo -L <path_to_libstd> <crate_path>` to build a cargo project.\n- or, `mrustc -L <path_to_libstd> --out-dir <output_directory> <path_to_main.rs>` to directly invoke mrustc.\n\nFor additional options, both programs have a `--help` option.\n\nDiagnosing Issues and Reporting Bugs\n====================================\n\nDebugging\n---------\nBoth the makefiles and `minicargo` write the compiler's stdout to a file in the output directory, e.g. when building\n`output/libcore.hir` it'll save to `output/libcore.hir_dbg.txt`.\nTo get full debug output for a compilation run, set the environment variable `MRUSTC_DEBUG` to a : separated list of the passes you want to debug\n(pass names are printed in every log line). E.g. `MRUSTC_DEBUG=Expand:Parse make -f minicargo.mk`\n\nBug Reports\n-----------\nPlease try to include the following when submitting a bug report:\n- What you're trying to build\n- Your host system version (e.g. Ubuntu 17.10)\n- C/C++ compiler version\n- Revision of the mrustc repo that you're running\n\nSupport and Discussion\n----------------------\nFor problems that don't warrant opening an issue (e.g. help in running the compiler), join the IRC channel - `irc.libera.chat#mrustc`\n\n\nCurrent Features\n================\n- Full compilation chain including HIR and MIR stages (outputting to C)\n- MIR optimisations (to take some load off the C compiler)\n- Optional exhaustive MIR validation (set the `MRUSTC_FULL_VALIDATE` environment variable)\n- Functional cargo clone (minicargo)\n  - Includes build script support\n- Procedural macros (custom derive)\n- Custom target specifications\n  - See `docs/target.md`\n\nPlans\n=====\n\nShort-term\n----------\n- Fix currently-failing tests (mostly in type inference)\n- Fix all known TODOs in MIR generation (still some possible leaks)\n\nMedium-term\n-----------\n- Implement MIR borrow checker\n- Emit C code that is (more) human readable (uses names from the original source, reduced/no gotos)\n- Add alternate backends (e.g. LLVM IR, cretonne, ...)\n\n"
        },
        {
          "name": "ReleaseNotes.md",
          "type": "blob",
          "size": 2.37109375,
          "content": "# 2021-04-04: rustc 1.39.0 bootstrap\n\nNew/interesting supported features since 1.29\n* Basic/minimal constant generics\n  * This forced a much-needed internal cleanup of generic/monomorphisation handling\n* Generators (needed for one small bit in `librustc_interface`)\n* Much better handling of editions and the mess involved around handling different editions across macros\n* By-value trait object methods (lots of hackery here)\n\nProminent internal changes\n* Type resolution (`hir_typeck/expr_cs.cpp`) completely reviewed and mostly justified (see `Notes/TypecheckIssues.md`)\n  to hopefully finally stop typecheck errors being the bane of my existence\n* `HIR::TypeRef` reworked to actually be a \"Ref\" (reference counted pointer). This was profiled to save quite a bit of\n  memory via de-duplication and reduction of inline sizes\n* Enum niche optimisation implemented (including a correct implementation of `repr(Rust,uNN)` layouts\n* Full MIRI constant evaluation (near-complete removal of the `HIR::Literal` type).\n  * Resolved statics and constants are now stored as bytes with relocations\n* `proc_macro` library expanded to support new features (and allow better testing)\n* `minicargo` supports overriding parts of crate manifests (as an alternative to doing source patches)\n* `minicargo` can now handle `rustc` as well as `mrustc`\n* Cleaned up handling of hygine (attaching directly to idents)\n* `macro_rules` handling reworked to pre-calculate looping logic\n* Classification of named patterns into structs and enums deferred until after associated type expansion\n* De-duplication of impl resolution logic for looking up values (for better and more consistent support of impl specialisation)\n* Specialised `RcString::ord` for interned strings (using a lazily cached ordering) for faster lookups)\n* Explicit MIR-level generation of vtables and drop glue (`trans/auto_impls.cpp`)\n\nMinor/notable changes\n* Improved macro resolution logic\n* Cleanup to AST path handling\n* Support for one AST path referring to two different items (e.g. a type and a function, via colliding `use` statements)\n* Unified trait impl lists after HIR generation (to avoid searching `n_crates` different impl lists)\n* LOTS of usage of `TU_MATCH`/`TU_MATCH_DEF` replaced with `TU_MATCH_HDRA`\n* HIR serialisation reworked to support some encoded structure (for better error diagnosis)\n* Speed up Trans Enumerate by caching paths/types needed by a function\n\n"
        },
        {
          "name": "TestRustcBootstrap.sh",
          "type": "blob",
          "size": 3.751953125,
          "content": "#!/bin/bash\n# Builds rustc with the mrustc stage0 and downloaded stage0\nset -e  # Quit script on error\nset -u  # Error on unset variables\n\nWORKDIR=${WORKDIR:-rustc_bootstrap}/\n\nRUSTC_TARGET=${RUSTC_TARGET:-x86_64-unknown-linux-gnu}\nRUSTC_VERSION=${*-1.29.0}\nRUN_RUSTC_SUF=\"\"\nif [[ \"$RUSTC_VERSION\" == \"1.29.0\" ]]; then\n    RUSTC_VERSION_NEXT=1.30.0\nelif [[ \"$RUSTC_VERSION\" == \"1.19.0\" ]]; then\n    RUSTC_VERSION_NEXT=1.20.0\n    RUN_RUSTC_SUF=-1.19.0\nelif [[ \"$RUSTC_VERSION\" == \"1.39.0\" ]]; then\n    RUSTC_VERSION_NEXT=1.40.0\n    RUN_RUSTC_SUF=-1.39.0\nelif [[ \"$RUSTC_VERSION\" == \"1.54.0\" ]]; then\n    RUSTC_VERSION_NEXT=1.55.0\n    RUN_RUSTC_SUF=-1.54.0\nelif [[ \"$RUSTC_VERSION\" == \"1.74.0\" ]]; then\n    RUSTC_VERSION_NEXT=1.75.0\n    RUN_RUSTC_SUF=-1.74.0\nelse\n    echo \"Unknown rustc version\"\nfi\n\nMAKEFLAGS=-j8\nexport MAKEFLAGS\n\necho \"=== Building stage0 rustc (with libstd)\"\nmake -C run_rustc RUSTC_VERSION=${RUSTC_VERSION}\n\nPREFIX=${PWD}/run_rustc/output${RUN_RUSTC_SUF}/prefix/\n\nif [ ! -e rustc-${RUSTC_VERSION_NEXT}-src.tar.gz ]; then\n    wget https://static.rust-lang.org/dist/rustc-${RUSTC_VERSION_NEXT}-src.tar.gz\nfi\n\necho \"--- Working in directory ${WORKDIR}\"\necho \"=== Cleaning up\"\nrm -rf ${WORKDIR}build\n#\n# Build rustc using entirely mrustc-built tools\n#\necho \"=== Building rustc bootstrap mrustc stage0\"\nmkdir -p ${WORKDIR}mrustc/\ntar -xf rustc-${RUSTC_VERSION_NEXT}-src.tar.gz -C ${WORKDIR}mrustc/\ncat - > ${WORKDIR}mrustc/rustc-${RUSTC_VERSION_NEXT}-src/config.toml <<EOF\n[build]\ncargo = \"${PREFIX}bin/cargo\"\nrustc = \"${PREFIX}bin/rustc\"\nfull-bootstrap = true\nvendor = true\nextended = true\n[llvm]\nninja = false\ndownload-ci-llvm = false\nEOF\necho \"--- Running x.py, see ${WORKDIR}mrustc.log for progress\"\n(cd ${WORKDIR} && mv mrustc build)\ncleanup_mrustc() {\n    (cd ${WORKDIR} && mv build mrustc)\n}\ntrap cleanup_mrustc EXIT\nrm -rf ${WORKDIR}build/rustc-${RUSTC_VERSION_NEXT}-src/build\n(cd ${WORKDIR}build/rustc-${RUSTC_VERSION_NEXT}-src/ && LD_LIBRARY_PATH=${PREFIX}lib/rustlib/${RUSTC_TARGET}/lib ./x.py build --stage 3) > ${WORKDIR}mrustc.log 2>&1\ncleanup_mrustc\ntrap - EXIT\nrm -rf ${WORKDIR}mrustc-output\nrm -rf ${WORKDIR}output\ncp -r ${WORKDIR}mrustc/rustc-${RUSTC_VERSION_NEXT}-src/build/${RUSTC_TARGET}/stage3 ${WORKDIR}output\ncp ${WORKDIR}mrustc/rustc-${RUSTC_VERSION_NEXT}-src/build/${RUSTC_TARGET}/stage3-tools-bin/* ${WORKDIR}output/bin/\nrm -rf ${WORKDIR}output/lib/rustlib/src ${WORKDIR}output/lib/rustlib/rustc-src\ntar --mtime=\"@0\" --sort=name -czf ${WORKDIR}mrustc.tar.gz -C ${WORKDIR} output\nmv ${WORKDIR}output ${WORKDIR}mrustc-output\n\n#\n# Build rustc by downloading the previous version of rustc (and its matching cargo)\n#\necho \"=== Building rustc bootstrap downloaded stage0\"\nmkdir -p ${WORKDIR}official/\ntar -xf rustc-${RUSTC_VERSION_NEXT}-src.tar.gz -C ${WORKDIR}official/\ncat - > ${WORKDIR}official/rustc-${RUSTC_VERSION_NEXT}-src/config.toml <<EOF\n[build]\nfull-bootstrap = true\nvendor = true\nextended = true\n[llvm]\nninja = false\ndownload-ci-llvm = false\nEOF\necho \"--- Running x.py, see ${WORKDIR}official.log for progress\"\n(cd ${WORKDIR} && mv official build)\n(cd ${WORKDIR}build/rustc-${RUSTC_VERSION_NEXT}-src/ && ./x.py build --stage 3) > ${WORKDIR}official.log 2>&1\n(cd ${WORKDIR} && mv build official)\nrm -rf ${WORKDIR}official-output\nrm -rf ${WORKDIR}output\ncp -r ${WORKDIR}official/rustc-${RUSTC_VERSION_NEXT}-src/build/${RUSTC_TARGET}/stage3 ${WORKDIR}output\ncp ${WORKDIR}official/rustc-${RUSTC_VERSION_NEXT}-src/build/${RUSTC_TARGET}/stage3-tools-bin/* ${WORKDIR}output/bin/\nrm -rf ${WORKDIR}output/lib/rustlib/src ${WORKDIR}output/lib/rustlib/rustc-src\ntar --mtime=\"@0\" --sort=name -czf ${WORKDIR}official.tar.gz -C ${WORKDIR} output\nmv ${WORKDIR}output ${WORKDIR}official-output\n\n#\n# Compare mrustc-built and official build artifacts\n#\ndiff -qs ${WORKDIR}mrustc.tar.gz ${WORKDIR}official.tar.gz\n"
        },
        {
          "name": "build-1.19.0.sh",
          "type": "blob",
          "size": 0.39453125,
          "content": "#!/bin/bash\nset -e\nexport RUSTC_VERSION=1.19.0 MRUSTC_TARGET_VER=1.19 OUTDIR_SUF=-1.19.0\nmake\nmake -f minicargo.mk RUSTCSRC\nmake -f minicargo.mk LIBS\nmake -f minicargo.mk test\nmake -f minicargo.mk output-1.19.0/stdtest/rustc_data_structures-test_out.txt\nmake -f minicargo.mk output-1.19.0/rustc -j ${PARLEVEL:-1}\nmake -f minicargo.mk output-1.19.0/cargo -j ${PARLEVEL:-1}\n./output-1.19.0/cargo --version\n"
        },
        {
          "name": "build-1.29.0.sh",
          "type": "blob",
          "size": 0.2978515625,
          "content": "#!/bin/bash\nset -e\nexport RUSTC_VERSION=1.29.0 MRUSTC_TARGET_VER=1.29 OUTDIR_SUF=-1.29.0\nmake\nmake -f minicargo.mk RUSTCSRC $@\nmake -f minicargo.mk LIBS $@\nmake -f minicargo.mk test $@\nmake -f minicargo.mk output-1.29.0/rustc $@\nmake -f minicargo.mk output-1.29.0/cargo $@\n./output-1.29.0/cargo --version\n"
        },
        {
          "name": "build-1.39.0.sh",
          "type": "blob",
          "size": 0.4208984375,
          "content": "#!/bin/bash\nset -e\nexport RUSTC_VERSION=1.39.0 MRUSTC_TARGET_VER=1.39 OUTDIR_SUF=-1.39.0\nmake\nmake -f minicargo.mk RUSTCSRC $@\nmake -f minicargo.mk LIBS $@\nmake -f minicargo.mk test $@\nmake -f minicargo.mk local_tests $@\nRUSTC_INSTALL_BINDIR=bin make -f minicargo.mk output-1.39.0/rustc $@ -j ${PARLEVEL:-1}\nLIBGIT2_SYS_USE_PKG_CONFIG=1 make -f minicargo.mk output-1.39.0/cargo $@ -j ${PARLEVEL:-1}\n./output-1.39.0/cargo --version\n"
        },
        {
          "name": "build-1.54.0.sh",
          "type": "blob",
          "size": 0.5244140625,
          "content": "#!/bin/bash\nset -e\nexport RUSTC_VERSION=1.54.0 MRUSTC_TARGET_VER=1.54 OUTDIR_SUF=-1.54.0\nmake\nmake RUSTCSRC\nmake -f minicargo.mk LIBS $@\nmake test $@\nmake local_tests $@\n## Build just rustc-driver BEFORE building llvm\n#RUSTC_INSTALL_BINDIR=bin make -f minicargo.mk output-1.54.0/rustc-build/librustc_driver.rlib\nRUSTC_INSTALL_BINDIR=bin make -f minicargo.mk output-1.54.0/rustc $@\n./output-1.54.0/rustc --version\n\nLIBGIT2_SYS_USE_PKG_CONFIG=1 make -f minicargo.mk output-1.54.0/cargo $@ -j ${PARLEVEL:-1}\n./output-1.54.0/cargo --version\n"
        },
        {
          "name": "build-1.74.0.sh",
          "type": "blob",
          "size": 0.591796875,
          "content": "#!/bin/bash\nset -e\nexport RUSTC_VERSION=1.74.0 MRUSTC_TARGET_VER=1.74 OUTDIR_SUF=-1.74.0\n# Enables use of ccache in mrustc if it's available (i.e. ccache is on PATH)\ncommand -v ccache >/dev/null && export MRUSTC_CCACHE=1\nmake\nmake RUSTCSRC\nmake -f minicargo.mk LIBS $@\nmake test $@\nmake local_tests $@\n\nRUSTC_INSTALL_BINDIR=bin make -f minicargo.mk output-1.74.0/rustc $@\n./output-1.74.0/rustc --version\n\nLIBGIT2_SYS_USE_PKG_CONFIG=1 make -f minicargo.mk -j ${PARLEVEL:-1} output-1.74.0/cargo $@\n./output-1.74.0/cargo --version\n\n./output-1.74.0/rustc samples/no_core.rs\n#./output-1.74.0/rustc samples/1.rs\n"
        },
        {
          "name": "disabled_tests_run-pass.txt",
          "type": "blob",
          "size": 17.1005859375,
          "content": "# COMMANDLINE\ncfg-in-crate-1  # MISSING: `-D warning` (deny warnings)\ncrate-name-attr-used    # `-F unused-attributes`\ncrt-static-off-works    # -C target-feature=-crt-static -Z unstable-options\ncrt-static-on-works     # -C target-feature=+crt-static -Z unstable-options\ndebuginfo-lto           # -C lto\nint-abs-overflow    # -Z force-overflow-checks=on\nissue-38226 # -Cno-prepopulate-passes\niter-step-overflow-debug    # -C debug_assertions=yes\niter-step-overflow-ndebug   # -C debug_assertions=no\niter-sum-overflow-debug     # -C debug_assertions=yes\niter-sum-overflow-ndebug    # -C debug_assertions=no\niter-sum-overflow-overflow-checks   # -C overflow-checks\nlint-cap    # --cap-lints allow\nparallel-codegen-closures   # -C codegen-units\nsepcomp-fns         # ^\nsepcomp-cci         # ^\nsepcomp-extern      # ^\nsepcomp-fns-backwards   # ^\nsepcomp-statics     # ^\nsepcomp-unwind      # ^\nsepcomp-lib-lto     # -C lto\nlto-many-codegen-units      # ^\nlto-still-runs-thread-dtor  # ^\nmir_overflow_off    # -Z force-overflow-checks=off\nno-landing-pads     # -Z no-landing-pads\nnum-wrapping        # -C debug-assertions\nshift-near-oflo     # ^\nslice-of-zero-size-elements # ^\noptimization-fuel-0 # -Z fuel=foo=0\noptimization-fuel-1 # ^\nwarn-ctypes-inhibit # -D improper-ctypes\nz-crate-attr        # -Z crate-attr\nthin-lto-global-allocator   # -Z thinlto\n\n# Requires unwinding panics\nunwind-resource\nbacktrace\nbacktrace-debuginfo\nbacktrace-debuginfo-aux\nissue-24313     # Not sure if this is unwinding or TLS problems...\nbox-of-array-of-drop-1\nbox-of-array-of-drop-2\ncatch-unwind-bang\ncleanup-rvalue-temp-during-incomplete-alloc\ndrop-trait-enum\ndynamic-drop\nintrinsic-move-val-cleanups\nissue-14875\nissue-25089\nissue-26655\nissue-29485\nissue-29948\nissue-30018-panic\nissue-8460  # .. except it fails because there's no overflow checks\nmulti-panic\nnested-vec-3\npanic-handler-chain\npanic-handler-flail-wildly\npanic-handler-set-twice\npanic-in-dtor-drops-fields\npanic-recover-propagate\nreachable-unnameable-items\nslice-panic-1\nslice-panic-2\ntask-stderr\nterminate-in-initializer\ntest-should-fail-good-message\nunit-like-struct-drop-run\nunwind-unique\nvector-sort-panic-safe\ntest-allow-fail-attr\n\n# LEX\nlex-bare-cr-nondoc-comment  # Don't treat \\r as a new line\n\n# PARSE\nalign-struct\t# repr(align(2)) - Need to support integers in attributes\ncatch-expr  # MISSING: `do catch {}` syntax\nloop-break-value    # TODO: Handle loop labels in expression position.\nmatch-range # TODO: Exlusive ranges in patterns\npaths-in-macro-invocations  # TODO: Handle path macros at root.\ntrait-object-lifetime-first # TODO: Handle lifetime annotations before traits in trait objects\nvec-matching    # TODO: Nested slice patterns\n\n# EXPAND\ntydesc-name # Difference in printing of paths\nmacro-use-one\t# Selective macro_use\ntwo-macro-use   # ^\nempty_global_asm\t# global_asm! macro not implemented\nsimple_global_asm   # ^\nissue-38715     # BUG: macro_export doesn't shadow correctly\nconcat  # BUG: Slight difference in printing of some tokens\nderiving-copyclone  # BUG: `derive(Copy,Clone)` generates a standard clone impl\nformat-ref-cell     # BUG: format_args! ordering\nifmt    # MISSING: Support for * in format_args!\nhygiene # TODO: Attempted to copy a :expr fragment (shouldn't error, bug in impl?)\nissue-11085 # MISSING: cfg() on enum variants\nissue-15221     # BUG: macro_rules eval - :pat in :pat\nissue-18859     # BUG: module_path! doesn't include crate name\nhygienic-labels         # BUG: hygine doesn't apply to loop labels\nhygienic-labels-in-let  # ^\nissue-26322 # BUG: line/column macros aren't quite correct\nsyntax-extension-source-utils   # ^\nissue-40469 # BUG: macro invocation results expanded after rest of module\nissue-41803 # BUG: ^\nlexer-crlf-line-endings-string-literal-doc-comment  # Unknown: \\r\\n lost as part of include_str?\nlink-cfg-works  # TODO: #[link(.., cfg(bar)]\nlog_syntax-trace_macros-macro-locations # trace_macros!\nmacro-doc-raw-str-hashes    # TODO: stringify! on :meta\nmacro-interpolation # TODO: Allow :block for function body\nmacro-stmt          # ^\nmacro-pub-matcher   # TODO: macro_rules :vis fragment\nmacro-reexport-no-intermediate-use  # #[macro_reexport]\nmacro-use-all-and-none  # TODO: #[macro_use(foo)]\nmacro-use-both  # ^\nsimd-intrinsic-generic-cast     # TODO: concat_idents! macro\nsimd-intrinsic-generic-comparison   # ^\nsmallest-hello-world    # Unknown lang item \"eh_unwind_resume\"\nstmt_expr_attr_macro_parse  # macro_rules - attributes not consumed as part of :expr\nsync-send-iterators-in-libcollections   # macro_rules - :expr matching bare ..\ntrait-item-inside-macro # TODO: Allow macro invocations in traits\ntry-operator-custom # TODO: use the ops::Try trait instead of try! desugar\ntype-macros-simple  # macro_rules ordering with nested items\n\n# RESOLVE\nissue-33687\t\t# Calling a unit-like struct with Fn* traits - \"Pointed struct in TupleVariant (::Test) isn't a Tuple\"\nstatic-function-pointer-xc\t# Calling a static function pointer\nconst-block         # ^\nconst-block-cross-crate-fn  # ^\nconst-block-item    # ^\nrfc1623             # ^\nstatic-function-pointer # ^\nissue-17718         # ^ (const here, but same idea)\nissue-27890         # ^\nempty-struct-braces # MISSING: Full support for braced initialisers for unit-like structs/variants\nissue-22546         # ^\nissue-29540     # Errors out on very deep method call list.\nissue-34751     # Treats unit-like structs as refutable patterns\nmir_ascription_coercion # TODO: Either visit expected types, or make a type annotation its own node type\ntype-ascription     # ^\n\n# CONST EVAL\nassociated-const-type-parameters    # TODO: Associated const referred from associated const\ncheck-static-mut-slices # MISSING: \"Only shared borrows are allowed in constants\"\nconst-vec-of-fns        # ^\ncheck-static-slice      # TODO: \"LValue::Deref\"\nconst-deref             # ^\nconst-enum-vec-index    # ^\nconst-fields-and-indexing   # ^\nissue-17233             # ^\nclosure-to-fn-coercion  # TODO: Allow closures in consts\nconst-autoderef # Autoderef in Const\nconst-binops    # TODO: Branching in MIR Consteval\nconst-contents  # BUG: !true evaluates to true\nconst-enum-cast         # TODO: Allow casting enum to integer\nenum-vec-initializer    # ^\nissue-38942     # ^ (but to float)\nissue-41394     # ^\nconst-err       # TODO: Comparisons (in HIR consteval)\nissue-39548     # ^\nconst-fn        # ERROR: Unable to infer in consteval (\"Indexing non-array - _\")\nconst-fn-method # ^\nconst-region-ptrs-noncopy   # BUG: Borrows from another static different pointer.\ndiscriminant_value  # BUG: No truncation of descriminant numbers\nissue-23968-const-not-overflow  # BUG: operations work on u64 and don't saturate correctly,\nissue-25757 # TODO: Handle <Foo>::bar borrows\nufcs-polymorphic-paths  # ^\nissue-38002         # TODO: Enum variants\nmatch-arm-statics   # ^\nissue-9837  # BUG: No truncation on cast\nmir_refs_correct    # TODO: Struct constructor to function pointer\nsigned-shift-const-eval # BUG: Signed shift incorrect value\n\n# HIR GENERAL\nfn-item-type-zero-sized # fn types\ngeneric-default-type-params # Bind - TODO \"Monomorphise in fix_param_count\"\nissue-39367     # ^\nhuge-largest-array  # `unsigned int` too small to hold array size\nvec-fixed-length    # ^\nissue-15523-big # 64-bit enum reprs\nissue-2718      # isize enum repr\nsmall-enum-range-edge   # i8 enum repr\nissue-22258     # BUG: Incorrect handling of trait param defaults\nmultiple-reprs  # BUG: Incorrect handling of multiple reprs\nplacement-in-syntax # BUG: Can't find impl in optimise\nstruct-path-associated-type # HUH? `T::A { ... }` struct literal with (bounded) associated const\nstruct-path-self    # TODO: Handle `Self` in patterns\nissue-17170     # TODO: #[repr(simd)]\nsimd-size-align # ^\nsimd-type       # ^\nsimd-upgraded   # ^\n\n# TYPECHECK\nassociated-types-doubleendediterator-object # BUG BUG: Validation failed\nautoderef-privacy   # KNOWN BUG: Privacy isn't applied\nintrinsic-move-val  # ^\ncast-rfc0401    # MISSING: Doesn't allow casts from array borrows to inner-type rawptrs\nclosure_to_fn_coercion-expected-types   # MISSING: Closures to fn types\ncoerce-overloaded-autoderef # TODO: Failure in deref coercions\nissue-7784      # BUG: PartialEq and deref coercion not working correctly.\nconst-cast  # TODO: Allow cast of fn() to *const _\nmir_misc_casts  # ^\ndiscrim-explicit-23030  # BUG: Enum variant types\nissue-13902             # ^\nissue-15523             # ^\nissue-38727     # ^\nissue-42007     # ^\nissue-23304-1   # ^ (float)\nissue-23304-2   # ^\nissue-23898     # ^ \nempty-types-in-patterns # Inferrence failure in empty match\ngeneric-default-type-params-cross-crate # Inferrence failure (not using type defaults)\nissue-11205     # Inferrence failure (doesn't consider trait impls in inferrence)\nissue-9951      # ^\ntrait-copy-guessing # ^\ntrait-default-method-xc # ^\ntrait-impl      # ^\nissue-20575     # Inferrence failure (closure return type from Fn bound)\nissue-26805     # Inferrence failure (doesn't use associated types)\nlast-use-in-cap-clause  # ^\noverloaded-calls-object-zero-args   # ^\nregions-infer-borrow-scope-addr-of  # Inferrence failure with `&isize` and `&{int}\nswap-2          # ^\nslice_binary_search     # Inferrence failure with &String and &str\nnever-result    # Inferrence failure: Race with !\nnew-box-syntax  # Inferrence failure: Box syntax and literals\nissue-21245     # BUG: Method lookup doesn't consider IntoIterator on an Iterator\nissue-23208     # Trait lookup not considering supertraits.\ntraits-issue-26339  # ^\ntraits-repeated-supertrait  # Multiple supertraits confusing inferrence\nissue-21410     # Infinite Recursion on closure type.\nissue-25439     # ^\nproject-cache-issue-31849   # Excessive typecheck time\nissue-21486     # Diverging function - in struct literal\nissue-30371     # Match of !\nissue-21922     # BUG: Missed coercion point.\nmir_coercions   # TODO: Coerce to unsafe fn\ntypeck-fn-to-unsafe-fn-ptr  # ^\nunsafe-coercion # ^\nnever_coercions # Failed to coerce (related to !?)\nvariadic-ffi    # Assertion failure caused by variadic function pointer\nweird-exprs     # Return in a let not triggering diverge.\nwrapping-int-api    # Implicit integer truncation with `<large_literal> as u64`\n# -> Unsize failures\nfat-ptr-cast    # Array unsize missed\nissue-20797     # Trait unsize runthrough\nissue-26905     # Manual CoerceUnsized not working?\n# - Unsupported features\nunsized-tuple-impls # Unsized tuples, no CoerceUnsized impl\n\n# MIR GEN:\nissue-18352     # append_from_lit - Match literal Borrow\nissue-11940     # ^\nmir_build_match_comparisons # ^\nissue-36936     # Identity casts are removed.\nbinary-heap-panic-safe  # TODO Attempts to move out of a Deref operator... failed &mut reborrow?\nissue-28839     # ^\nissue-21306     # ^ Likely caused by bad Fn* selection\nbyte-literals   # \"Attempting to match on an Array (should have been destructured)\"\ncast            # TODO: Allow cast char -> i32\ncleanup-rvalue-during-if-and-while  # BUG: Temporaries created in conditions not dropped at right time.\nmir_drop_order      # BUG: incorrect drop ordering with borrows\ncleanup-rvalue-scopes   # BUG: Incorrect drop ordering around `box ref` patterns\nconst-str-ptr   # TODO: MIR Cleanup \"BorrowOf into pointer\"\nissue-13620     # TODO: MIR Cleanup - fn pointer\ndiverging-fallback-control-flow # \"No value avaliable\"\ndiverging-fallback-option       # ^\nissue-15763                     # ^\nissue-18110             # ^\nissue-30018-nopanic     # ^\nmatch-bot-2             # ^\nunreachable-code        # ^\ndiverging-fn-tail-35849         # Validation error, assign to ! (return value) in unreachable branch\nif-ret  # \"If condition wasn't bool\"\nissue-15080 # XXX: SplitSlice match edge case leading to DIVERGE being hit\nissue-17877 # TODO: SplitSlice on array\nvec-matching-fixed  # ^\nvec-tail-matching   # Trailing SplitSlice\nzero_sized_subslice_match   # ^\nissue-23311 # TODO: rules_overlap - byte string and slice pattern\nissue-23338-ensure-param-drop-order # BUG: Incorrect ordering of parameter drop.\nissue-27054-primitive-binary-ops    # BUG: LHS of operator read after RHS evaluated\nissue-28950 # BUG? Stack overflow not prevented\nmir_heavy_promoted  # ^\nissue-32805\t# BUG: Possible f32 literal rounding isue\nissue-4734      # BUG: Unused values not dropped.\nmatch-byte-array-patterns   # ASSERTION (column_weights vs arms)\nmatch-ref-unsized   # TODO: Allow `ref v = *\"string\"` (ref to unsized value)\nmir_raw_fat_ptr # TODO: Handle ordering comparisons on raw pointers\nmove-guard-const    # NOT A BUG: rustc allows match guards to move, mrustc does not.\nstruct-order-of-eval-1  # BUG: Use of non-valid local\nstruct-order-of-eval-3  # ^\n# > Cleanup\nissue-6919  # Handle function pointer from Literal\n\n\n# TRANS\nenum-discrim-autosizing     # Incorrect enum descrim auto-selection (0x80 picks i16)\nenum-discrim-width-stuff    # ^\nnonzero-enum                # No packing of None into invalid inner variants\ntype-sizes                  # Inefficient field packing in enum variants\nfloat_math  # Missing intrinsic (fadd_fast)\nissue-38074 # Missing intrinsic (simd_shuffle)\nsimd-generics       # Missing intrinsic (simd_*)\nsimd-intrinsic-generic-arithmetic   # ^\nsimd-intrinsic-generic-elements     # ^\nraw-fat-ptr # Ordering comparisons of raw pointers\nabi-sysv64-register-usage   # asm! register translation\nallocator-override          # asm! translation - \"TODO: Handle asm! output leader 'r'\"\ni128                        # ^\nissue-32947                 # ^\nissue-41696                 # ^\nu128                        # ^\nasm-in-out-operand          # asm! translation - \"Assembly output specifiers must start with =\"\nasm-indirect-memory         # ^\nissue-14936                 # ^\nasm-out-assign              # asm! translation\ndrop-struct-as-object   # BUG: Box destructor doesn't call inner destructor?\ninit-res-into-things    # ^\nissue-10802             # ^\nmir_fat_ptr_drop    # ^\ndst-field-align     # BUG: Alignment of DST fields not valid.\nenum-discr          # Signed discriminants\nenum-disr-val-pretty    # ^\ntag-variant-disr-val    # ^\nenum-discrim-manual-sizing  # TODO: Enum reprs not being correctly used (signed reprs?)\nenum-univariant-repr        # ^\nenum-layout-optimization    # BUG: Option size optimisation not applied\nenum-null-pointer-opt       # ^\nnullable-pointer-size       # ^\nexplicit-self-generic       # BUG: Incorrect method lookup (doesn't try autoderef, picks ExactSizeIterator)\ni128-ffi    # UNK: i128 is hard (TODO: TRIAGE)\nintrinsic-alignment # MISSING: intrinsic `pref_align_of`\nintrinsics-integer  # `ctpop` signed negative returns OOB value (e.g. 32 instead of 8 on i8)\nissue-21058     # BUG: Enumerate doesn't handle data-less trait objects (e.g. `dyn Send`)\nissue-25515     # ^\nissue-26709     # ^\nissue-35815     # ^\nissue-34796     # BUG: Missing vtable type.\nmir_calls_to_shims   # BUG: Missing functions (bad enumerate?)\nnewtype     # Incorrect error when a struct is used in a function pointer to itself\ntrans-object-shim   # BUG: Doesn't generate `<(Foo) as Foo>::bar` function.\ntransmute-specialization    # BUG: Enumerate hit an opaque type\ntype-id-higher-rank     # BUG: type_id returns the same value for `for<'a> fn(&'a T)` as `fn(&'static T)`\ntype-id-higher-rank-2   # ^ (test failed)\nunsized3    # BUG: Incorrect dst type annotation for struct containing `str`\nutf8_idents # BUG: No escaping of utf8 in symbols, GCC doesn't like this\nabi-sysv64-arg-passing  # ERROR: Empty struct arguments to FFI aren't actually empty\nextern-pass-empty   # ^\nthread-local-extern-static  # TODO: #[no_mangle] on statatic definition\n\n# SIMD (minimal support in mrustc, all SIMD ops abort)\nsimd-intrinsic-float-math\nsimd-intrinsic-float-minmax\nsimd-intrinsic-generic-gather\nsimd-intrinsic-generic-reduction\nsimd-intrinsic-generic-select\n\n# HIR MISC\nxcrate-associated-type-defaults\t# type_is_specialisable - Handle missing type in impl(0x17e3018) ::\"xcrate_associated_type_defaults\"::Foo<u32,> for () {}, name = Out\ndefault-associated-types        # ^\nissue-25180     # Closure in const\nissue-27268     # ^\nissue-28189     # ^\nself-impl   # Can't find impl in Expand UFCS\n\n# MISC\nallocator-default\t# Needs alloc_jealloc, which isn't built\nlib-defaults    # Crate type \"staticlib\"\nlinkage1    # \"extern_weak\" linkage\nreexport-test-harness-main  # NOT A BUG: Tests an implementation detail of the test harness\ntest-runner-hides-start # BUG: Test harness doesn't hide #[start]\ntls-dtors-are-run-in-a-static-binary    # Thread-local destructors aren't being run.\nissue-42747 # 27 deep enum chain, VERY long time in gcc\n\n# TEST RUNNER\nexec-env    # Runtime environment variable\nextern-crosscrate   # test runner params with no leading space\n\n# Requires unwinding panics\nunwind-resource\nbacktrace\nbacktrace-debuginfo\nbacktrace-debuginfo-aux\nissue-24313     # Not sure if this is unwinding or TLS problems...\nbox-of-array-of-drop-1\nbox-of-array-of-drop-2\nbuiltin-clone-unwind\ncatch-unwind-bang\ncleanup-rvalue-temp-during-incomplete-alloc\ndrop-trait-enum\ndynamic-drop\nintrinsic-move-val-cleanups\nissue-14875\nissue-25089\nissue-26655\nissue-29485\nissue-29948\nissue-30018-panic\nissue-42148\nissue-8460  # .. except it fails because there's no overflow checks\nmulti-panic\nnested-vec-3\npanic-handler-chain\npanic-handler-flail-wildly\npanic-handler-set-twice\npanic-in-dtor-drops-fields\npanic-recover-propagate\nreachable-unnameable-items\nslice-panic-1\nslice-panic-2\ntask-stderr\nterminate-in-initializer\ntest-should-fail-good-message\nunit-like-struct-drop-run\nunwind-unique\nvector-sort-panic-safe\n\n# vim: ft=make expandtab ts=4\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "minicargo.mk",
          "type": "blob",
          "size": 17.8349609375,
          "content": "#\n# minicargo.mk - Makefile that handles invoking `minicargo` to build libstd, rustc, and cargo\n#\n\n\nEXESUF :=\nifeq ($(OS),Windows_NT)\n  EXESUF := .exe\nendif\n\n# -------------------\n# ----- INPUTS ------\n# -------------------\n\n# RUSTC_VERSION : Version of rustc to load (picks source dir)\nRUSTC_VERSION_DEF := $(shell cat rust-version)\nRUSTC_VERSION ?= $(RUSTC_VERSION_DEF)\n\n# OUTDIR_SUF : Output directory suffix\nifeq ($(RUSTC_VERSION),$(RUSTC_VERSION_DEF))\n  OUTDIR_SUF_DEF :=\nelse\n  OUTDIR_SUF_DEF := -$(RUSTC_VERSION)\nendif\nOUTDIR_SUF ?= $(OUTDIR_SUF_DEF)\n\n# MMIR : Set to non-empty to compile Monomorphised MIR\nMMIR ?=\n# RUSTC_CHANNEL : `rustc` release channel (picks source dir)\nRUSTC_CHANNEL ?= stable\n# PARLEVEL : `minicargo`'s job count\nPARLEVEL ?= 1\n# Additional flags for `minicargo` (e.g. library paths)\nMINICARGO_FLAGS ?=\n# RUST_TESTS_FINAL_STAGE : Final stage for tests run as part of the rust_tests target.\n#  VALID OPTIONS: parse, expand, mir, ALL\nRUST_TESTS_FINAL_STAGE ?= ALL\n# MRUSTC : Executable path to `mrustc`\nMRUSTC ?= bin/mrustc$(EXESUF)\n# MINICARGO : Executable path to `minicargo`\nMINICARGO ?= bin/minicargo$(EXESUF)\n# LLVM_TARGETS : Target list for llvm\nLLVM_TARGETS ?= X86;ARM;AArch64#;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\n\nifeq ($(OS),Windows_NT)\n  OVERRIDE_SUFFIX ?= -windows\nelse ifeq ($(shell uname -s || echo not),Darwin)\n  OVERRIDE_SUFFIX ?= -macos\nelse\n  OVERRIDE_SUFFIX ?= -linux\nendif\n\n# --- Pepare minicargo flags etc ---\n# Set up for MMIR mode\nifneq ($(MMIR),)\n  OUTDIR_SUF := $(OUTDIR_SUF)-mmir\n  MINICARGO_FLAGS += -Z emit-mmir\nendif\n# Job count\nifneq ($(PARLEVEL),1)\n  MINICARGO_FLAGS += -j $(PARLEVEL)\nendif\n# Target override\nifeq ($(MRUSTC_TARGET),)\nelse\n  MINICARGO_FLAGS += --target $(MRUSTC_TARGET)\n  OUTDIR_SUF := $(OUTDIR_SUF)-$(MRUSTC_TARGET)\nendif\n\nOUTDIR := output$(OUTDIR_SUF)/\n\nCARGO_ENV_VARS :=\nUSE_MERGED_BUILD=1\nifeq ($(RUSTC_VERSION),1.19.0)\n  RUSTC_OUT_BIN := rustc\n  USE_MERGED_BUILD=0\nelse ifeq ($(RUSTC_VERSION),1.29.0)\n  # Diabled due to linking issues\n  # - libssh uses an openssl feature that isn't enabled (\"engines\"), see openssl-src/src/lib.rs:106\n  # - But if that feature is enabled, then libcurl doesn't compile :(\n  #MINICARGO_FLAGS_$(OUTDIR)cargo := --features vendored-openssl\n  #CARGO_ENV_VARS += LIBCURL_NO_PKG_CONFIG=1\n  RUSTC_OUT_BIN := rustc_binary\n  USE_MERGED_BUILD=0\nelse ifeq ($(RUSTC_VERSION),1.39.0)\n  MINICARGO_FLAGS_$(OUTDIR)cargo := --features vendored-openssl\n  RUSTC_OUT_BIN := rustc_binary\nelse\n  MINICARGO_FLAGS_$(OUTDIR)cargo := --features vendored-openssl\n  MINICARGO_FLAGS_$(OUTDIR)rustc := --features llvm\n  RUSTC_OUT_BIN := rustc_main\nendif\n\nifeq ($(RUSTC_CHANNEL),nightly)\n  RUSTCSRC := rustc-nightly-src/\nelse\n  RUSTCSRC := rustc-$(RUSTC_VERSION)-src/\nendif\nRUSTC_SRC_DL := $(RUSTCSRC)/dl-version\nifeq ($(RUSTC_VERSION),1.19.0)\n  VENDOR_DIR := $(RUSTCSRC)src/vendor\nelse ifeq ($(RUSTC_VERSION),1.29.0)\n  VENDOR_DIR := $(RUSTCSRC)src/vendor\nelse\n  VENDOR_DIR := $(RUSTCSRC)vendor\n  MINICARGO_FLAGS += --manifest-overrides rustc-$(RUSTC_VERSION)-overrides.toml\nendif\nifeq ($(RUSTC_VERSION),1.54.0)\n  RUST_LIB_PREFIX := library/\nelse ifeq ($(RUSTC_VERSION),1.74.0)\n  RUST_LIB_PREFIX := library/\nelse\n  RUST_LIB_PREFIX := src/lib\nendif\n\nifeq ($(RUSTC_VERSION),1.19.0)\n  LLVM_DIR := src/llvm\nelse ifeq ($(RUSTC_VERSION),1.29.0)\n  LLVM_DIR := src/llvm\nelse\n  LLVM_DIR := src/llvm-project/llvm\nendif\n\nSRCDIR_RUSTC := src/rustc\nSRCDIR_RUSTC_DRIVER := src/librustc_driver\nifeq ($(RUSTC_VERSION),1.54.0)\n  SRCDIR_RUSTC := compiler/rustc\n  SRCDIR_RUSTC_DRIVER := compiler/rustc_driver\nendif\nifeq ($(RUSTC_VERSION),1.74.0)\n  SRCDIR_RUSTC := compiler/rustc\n  SRCDIR_RUSTC_DRIVER := compiler/rustc_driver\nendif\n\nSRCDIR_RUST_TESTS := $(RUSTCSRC)src/test/\nifeq ($(RUSTC_VERSION),1.74.0)\nSRCDIR_RUST_TESTS := $(RUSTCSRC)tests/\nendif\n\nLLVM_CONFIG := $(RUSTCSRC)build/bin/llvm-config\nifeq ($(shell uname -s || echo not),Darwin)\n # /usr/bin/uname because uname might call coreutils\n # which can make the arm64 uname called when\n # running under the Rosetta execution environment.\n ifeq ($(shell /usr/bin/uname -m || echo not),arm64)\n   RUSTC_TARGET ?= aarch64-apple-darwin\n else\n   RUSTC_TARGET ?= x86_64-apple-darwin\n endif\nelse ifeq ($(OS),Windows_NT)\n  RUSTC_TARGET ?= x86_64-windows-gnu\nelse\n  RUSTC_TARGET ?= x86_64-unknown-linux-gnu\nendif\n# Directory for minicargo build script overrides\nOVERRIDE_DIR := script-overrides/$(RUSTC_CHANNEL)-$(RUSTC_VERSION)$(OVERRIDE_SUFFIX)/\n\n\n# ---------------------------------------------------------------------\n#  Top-level targets\n# ---------------------------------------------------------------------\n\n.PHONY: $(OUTDIR)libstd.rlib $(OUTDIR)libtest.rlib $(OUTDIR)libpanic_unwind.rlib $(OUTDIR)libproc_macro.rlib\n.PHONY: $(OUTDIR)rustc $(OUTDIR)cargo\n\n.PHONY: all test LIBS\n.PHONY: RUSTCSRC\n\n\nall: $(OUTDIR)rustc\n\ntest: $(OUTDIR)rust/test_run-pass_hello_out.txt\n\nRUSTCSRC: $(RUSTC_SRC_DL)\n\n.PHONY: rust_tests local_tests\nrust_tests: RUST_TESTS_run-pass\n# rust_tests-run-fail\n# rust_tests-compile-fail\n\n# --- Ensure that mrustc/minicargo are built ---\n.PHONY: bin/mrustc$(EXESUF) bin/minicargo$(EXESUF) bin/testrunner$(EXESUF) bin/standalone_miri$(EXESUF)\nbin/mrustc$(EXESUF):\n\t$(MAKE) -f Makefile all\n\ttest -e $@\n\nifeq ($(MMIR),)\n  MINICARGO_DEP_SMIRI=\nelse\n  MINICARGO_DEP_SMIRI=bin/standalone_miri$(EXESUF)\nendif\n\nbin/minicargo$(EXESUF): $(MINICARGO_DEP_SMIRI)\n\t$(MAKE) -C tools/minicargo/\n\ttest -e $@\nbin/standalone_miri$(EXESUF):\n\t$(MAKE) -C tools/minicargo/\n\ttest -e $@\nbin/testrunner$(EXESUF):\n\t$(MAKE) -C tools/testrunner/\n\ttest -e $@\n\n\n#\n# rustc (with std/cargo) source download\n#\nRUSTC_SRC_TARBALL := rustc-$(RUSTC_VERSION)-src.tar.gz\n$(RUSTC_SRC_TARBALL):\n\t@echo [CURL] $@\n\t@rm -f $@\n\t@curl -sS https://static.rust-lang.org/dist/$@ -o $@\nrustc-$(RUSTC_VERSION)-src/extracted: $(RUSTC_SRC_TARBALL)\n\ttar -xf $(RUSTC_SRC_TARBALL)\n\ttouch $@\n$(RUSTC_SRC_DL): rustc-$(RUSTC_VERSION)-src/extracted rustc-$(RUSTC_VERSION)-src.patch\n\tcd $(RUSTCSRC) && patch -p0 < ../rustc-$(RUSTC_VERSION)-src.patch;\n\ttouch $@\n\n# Standard library crates\n# - libstd, libpanic_unwind, libtest and libgetopts\n# - libproc_macro (mrustc)\nifeq ($(USE_MERGED_BUILD),1)\n$(RUSTCSRC)mrustc-stdlib/Cargo.toml: $(RUSTC_SRC_DL) minicargo.mk\n\t@mkdir -p $(dir $@)\n\t@echo \"#![no_core]\" > $(dir $@)/lib.rs\n\t@echo \"[package]\" > $@\n\t@echo \"name = \\\"mrustc_standard_library\\\"\" >> $@\n\t@echo \"version = \\\"0.0.0\\\"\" >> $@\n\t@echo \"[lib]\" >> $@\n\t@echo \"path = \\\"lib.rs\\\"\" >> $@\n\t@echo \"[dependencies]\" >> $@\n\t@echo \"std = { path = \\\"../$(RUST_LIB_PREFIX)std\\\" }\" >> $@\n\t@echo \"panic_unwind = { path = \\\"../$(RUST_LIB_PREFIX)panic_unwind\\\" }\" >> $@\n\t@echo \"test = { path = \\\"../$(RUST_LIB_PREFIX)test\\\" }\" >> $@\nLIBS: $(RUSTCSRC)mrustc-stdlib/Cargo.toml $(MRUSTC) $(MINICARGO)\n\t+$(MINICARGO) --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) $(RUSTCSRC)mrustc-stdlib/\n\t+$(MINICARGO) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) lib/libproc_macro\nelse\nLIBS: $(MRUSTC) $(MINICARGO) $(RUSTC_SRC_DL)\n\t+$(MINICARGO) --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) $(RUSTCSRC)$(RUST_LIB_PREFIX)std\n\t+$(MINICARGO) --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) $(RUSTCSRC)$(RUST_LIB_PREFIX)panic_unwind\n\t+$(MINICARGO) --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) $(RUSTCSRC)$(RUST_LIB_PREFIX)test\n\t+$(MINICARGO) --output-dir $(OUTDIR) $(MINICARGO_FLAGS) lib/libproc_macro\nendif\n\n# Dynamically linked version of the standard library\n$(OUTDIR)test/libtest.so: $(RUSTC_SRC_DL)\n\tmkdir -p $(dir $@)\n\t+MINICARGO_DYLIB=1 $(MINICARGO) $(RUSTCSRC)$(RUST_LIB_PREFIX)std          --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(dir $@) $(MINICARGO_FLAGS)\n\t+MINICARGO_DYLIB=1 $(MINICARGO) $(RUSTCSRC)$(RUST_LIB_PREFIX)panic_unwind --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(dir $@) $(MINICARGO_FLAGS)\n\t+MINICARGO_DYLIB=1 $(MINICARGO) $(RUSTCSRC)$(RUST_LIB_PREFIX)test         --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) $(MINICARGO_FLAGS)\n\ttest -e $@\n\nRUSTC_ENV_VARS := CFG_COMPILER_HOST_TRIPLE=$(RUSTC_TARGET)\nRUSTC_ENV_VARS += LLVM_CONFIG=$(abspath $(LLVM_CONFIG))\nRUSTC_ENV_VARS += CFG_RELEASE=$(RUSTC_VERSION)\t# Claiming stable\nRUSTC_ENV_VARS += CFG_RELEASE_CHANNEL=$(RUSTC_CHANNEL)\nRUSTC_ENV_VARS += CFG_VERSION=$(RUSTC_VERSION)-$(RUSTC_CHANNEL)-mrustc\nRUSTC_ENV_VARS += CFG_PREFIX=mrustc\nRUSTC_ENV_VARS += CFG_LIBDIR_RELATIVE=lib\nRUSTC_ENV_VARS += LD_LIBRARY_PATH=$(abspath $(OUTDIR))\nRUSTC_ENV_VARS += REAL_LIBRARY_PATH_VAR=LD_LIBRARY_PATH\nRUSTC_ENV_VARS += RUSTC_INSTALL_BINDIR=bin\n\n$(OUTDIR)rustc: $(MRUSTC) $(MINICARGO) LIBS $(LLVM_CONFIG)\n\tmkdir -p $(OUTDIR)rustc-build\n\t+$(RUSTC_ENV_VARS) $(MINICARGO) $(RUSTCSRC)$(SRCDIR_RUSTC) --vendor-dir $(VENDOR_DIR) --output-dir $(OUTDIR)rustc-build -L $(OUTDIR) $(MINICARGO_FLAGS) $(MINICARGO_FLAGS_$@)\n\ttest -e $@ -a ! $(OUTDIR)rustc-build/$(RUSTC_OUT_BIN) -nt $@ || cp $(OUTDIR)rustc-build/$(RUSTC_OUT_BIN) $@\n$(OUTDIR)rustc-build/librustc_driver.rlib: $(MRUSTC) $(MINICARGO) LIBS\n\tmkdir -p $(OUTDIR)rustc-build\n\t+$(RUSTC_ENV_VARS) $(MINICARGO) $(RUSTCSRC)$(SRCDIR_RUSTC_DRIVER) --vendor-dir $(VENDOR_DIR) --output-dir $(OUTDIR)rustc-build -L $(OUTDIR) $(MINICARGO_FLAGS) $(MINICARGO_FLAGS_$(OUTDIR)rustc)\n$(OUTDIR)cargo: $(MRUSTC) LIBS\n\tmkdir -p $(OUTDIR)cargo-build\n\t+$(CARGO_ENV_VARS) $(MINICARGO) $(RUSTCSRC)src/tools/cargo --vendor-dir $(VENDOR_DIR) --output-dir $(OUTDIR)cargo-build -L $(OUTDIR) $(MINICARGO_FLAGS) $(MINICARGO_FLAGS_$@)\n\ttest -e $@ -a ! $(OUTDIR)cargo-build/cargo -nt $@ || cp $(OUTDIR)cargo-build/cargo $@\n\n# Reference $(RUSTCSRC)src/bootstrap/native.rs for these values\nLLVM_CMAKE_OPTS := LLVM_TARGET_ARCH=$(firstword $(subst -, ,$(RUSTC_TARGET))) LLVM_DEFAULT_TARGET_TRIPLE=$(RUSTC_TARGET)\nLLVM_CMAKE_OPTS += LLVM_TARGETS_TO_BUILD=\"$(LLVM_TARGETS)\"\nLLVM_CMAKE_OPTS += LLVM_ENABLE_ASSERTIONS=OFF\nLLVM_CMAKE_OPTS += LLVM_INCLUDE_EXAMPLES=OFF LLVM_INCLUDE_TESTS=OFF LLVM_INCLUDE_DOCS=OFF\nLLVM_CMAKE_OPTS += LLVM_INCLUDE_BENCHMARKS=OFF\nLLVM_CMAKE_OPTS += LLVM_ENABLE_ZLIB=OFF LLVM_ENABLE_TERMINFO=OFF LLVM_ENABLE_LIBEDIT=OFF WITH_POLLY=OFF\nLLVM_CMAKE_OPTS += CMAKE_CXX_COMPILER=\"$(CXX)\" CMAKE_C_COMPILER=\"$(CC)\"\nLLVM_CMAKE_OPTS += CMAKE_BUILD_TYPE=Release\nLLVM_CMAKE_OPTS += $(LLVM_CMAKE_OPTS_EXTRA)\n\n\n$(RUSTCSRC)build/bin/llvm-config: $(RUSTCSRC)build/Makefile\n\t$Vcd $(RUSTCSRC)build && $(MAKE) -j $(PARLEVEL)\n\n$(RUSTCSRC)build/Makefile: $(RUSTCSRC)$(LLVM_DIR)/CMakeLists.txt\n\t@mkdir -p $(RUSTCSRC)build\n\t$Vcd $(RUSTCSRC)build && cmake $(addprefix -D , $(LLVM_CMAKE_OPTS)) ../$(LLVM_DIR)\n\n#\n# Developement-only targets\n#\n$(OUTDIR)libcore.rlib: $(MRUSTC) $(MINICARGO)\n\t$(MINICARGO) $(RUSTCSRC)src/libcore --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)liballoc.rlib: $(MRUSTC) $(MINICARGO)\n\t$(MINICARGO) $(RUSTCSRC)src/liballoc --vendor-dir $(VENDOR_DIR) --script-overrides $(OVERRIDE_DIR) --output-dir $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)rustc-build/librustdoc.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(RUSTCSRC)src/librustdoc --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) $(MINICARGO_FLAGS)\n#$(OUTDIR)cargo-build/libserde-1_0_6.rlib: $(MRUSTC) LIBS\n#\t$(MINICARGO) $(VENDOR_DIR)/serde --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)cargo-build/libgit2-0_6_6.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(VENDOR_DIR)/git2 --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) --features ssh,https,curl,openssl-sys,openssl-probe $(MINICARGO_FLAGS)\n$(OUTDIR)cargo-build/libserde_json-1_0_2.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(VENDOR_DIR)/serde_json --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)cargo-build/libcurl-0_4_6.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(VENDOR_DIR)/curl --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)cargo-build/libterm-0_4_5.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(VENDOR_DIR)/term --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) $(MINICARGO_FLAGS)\n$(OUTDIR)cargo-build/libfailure-0_1_2.rlib: $(MRUSTC) LIBS\n\t$(MINICARGO) $(VENDOR_DIR)/failure --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR) --features std,derive,backtrace,failure_derive $(MINICARGO_FLAGS)\n\n\n#\n# TEST: Rust standard library and the \"hello, world\" run-pass test\n#\n\nHELLO_TEST := ui/hello.rs\nifeq ($(RUSTC_VERSION),1.19.0)\n  HELLO_TEST := run-pass/hello.rs\nelse ifeq ($(RUSTC_VERSION),1.29.0)\n  HELLO_TEST := run-pass/hello.rs\nendif\n\n# \"hello, world\" test - Invoked by the `make test` target\n$(OUTDIR)rust/test_run-pass_hello: $(SRCDIR_RUST_TESTS)$(HELLO_TEST) LIBS\n\t@mkdir -p $(dir $@)\n\t@echo \"--- [MRUSTC] -o $@\"\n\t$(DBG) $(MRUSTC) $< -o $@ --cfg debug_assertions -g -O -L $(OUTDIR) > $@_dbg.txt\n$(OUTDIR)rust/test_run-pass_hello_out.txt: $(OUTDIR)rust/test_run-pass_hello\n\t@echo \"--- [$<]\"\n\t@./$< | tee $@\n\n# \n# RUSTC TESTS\n# \n\n.PHONY: RUST_TESTS RUST_TESTS_run-pass\nRUST_TESTS: RUST_TESTS_run-pass\nRUST_TESTS_run-pass: output$(OUTDIR_SUF)/test/librust_test_helpers.a LIBS bin/testrunner$(EXESUF)\n\t@mkdir -p $(OUTDIR)rust_tests/run-pass\n\t./bin/testrunner$(EXESUF) -L $(OUTDIR) -L $(OUTDIR)test -o $(OUTDIR)rust_tests/run-pass $(SRCDIR_RUST_TESTS)run-pass --exceptions disabled_tests_run-pass.txt\n$(OUTDIR)test/librust_test_helpers.a: $(OUTDIR)test/rust_test_helpers.o\n\t@mkdir -p $(dir $@)\n\tar cur $@ $<\nifeq ($(RUSTC_VERSION),1.19.0)\nRUST_TEST_HELPERS_C := $(RUSTCSRC)src/rt/rust_test_helpers.c\nelse\nRUST_TEST_HELPERS_C := $(RUSTCSRC)src/test/auxiliary/rust_test_helpers.c\nendif\noutput$(OUTDIR_SUF)/test/rust_test_helpers.o: $(RUST_TEST_HELPERS_C)\n\t@mkdir -p $(dir $@)\n\t$(CC) -c $< -o $@\n\n#\n# MRUSTC-specific tests\n# \n.PHONY: local_tests\nlocal_tests: $(TEST_DEPS)\n\t@$(MAKE) -C tools/testrunner\n\t@mkdir -p output$(OUTDIR_SUF)/local_tests\n\t./bin/testrunner -o output$(OUTDIR_SUF)/local_tests -L output$(OUTDIR_SUF) samples/test\n\n#\n# Testing\n#\n.PHONY: rust_tests-libs\n\nLIB_TESTS := \nLIB_TESTS += alloc\nLIB_TESTS += std\nLIB_TESTS += rustc_data_structures\n#LIB_TESTS += rustc\nrust_tests-libs: $(patsubst %,$(OUTDIR)stdtest/%-test_out.txt, $(LIB_TESTS))\nrust_tests-libs: $(OUTDIR)stdtest/collectionstests_out.txt\n.PRECIOUS: $(OUTDIR)stdtest/alloc-test\n.PRECIOUS: $(OUTDIR)stdtest/std-test\n.PRECIOUS: $(OUTDIR)stdtest/rustc_data_structures-test\n#.PRECIOUS: $(OUTDIR)stdtest/rustc-test\n\nRUNTIME_ARGS_$(OUTDIR)stdtest/alloc-test := --test-threads 1\nRUNTIME_ARGS_$(OUTDIR)stdtest/alloc-test += --skip ::collections::linked_list::tests::test_fuzz\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test := --test-threads 1\n# VVV Requires panic destructors (unwinding panics)\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::io::stdio::tests::panic_doesnt_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::io::buffered::tests::panic_in_write_doesnt_flush_in_drop\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mutex::tests::test_arc_condvar_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mutex::tests::test_mutex_arc_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::once::tests::poison_bad\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::once::tests::wait_for_force_to_finish\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_rw_arc_no_poison_rw\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_rw_arc_poison_wr\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_rw_arc_poison_ww\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sys_common::remutex::tests::poison_works\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::thread::local::tests::dtors_in_dtors_in_dtors\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::thread::local::tests::smoke_dtor\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mutex::tests::test_get_mut_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mutex::tests::test_into_inner_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mutex::tests::test_mutex_arc_access_in_unwind\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_get_mut_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_into_inner_poison\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::rwlock::tests::test_rw_arc_access_in_unwind\n#RUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mpsc::sync_tests::oneshot_multi_task_recv_then_close\n#RUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mpsc::sync_tests::oneshot_multi_thread_recv_close_stress\n#RUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::sync::mpsc::sync_tests::oneshot_single_thread_recv_chan_close\n# VVV Requires u128 literals\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::net::ip::tests::test_ipv6_to_int\nRUNTIME_ARGS_$(OUTDIR)stdtest/std-test += --skip ::net::ip::tests::test_int_to_ipv6\nRUNTIME_ARGS_$(OUTDIR)stdtest/rustc_data_structures-test := --test-threads 1\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests := --test-threads 1\n# VVV Requires unwinding panics\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests += --skip ::slice::test_box_slice_clone_panics\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests += --skip ::slice::panic_safe\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests += --skip ::vec::drain_filter_consumed_panic\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests += --skip ::vec::drain_filter_unconsumed_panic\n# No support for custom alignment\nRUNTIME_ARGS_$(OUTDIR)stdtest/collectionstests += --skip ::vec::overaligned_allocations\n\n#ENV_$(OUTDIR)stdtest/rustc-test := \n#ENV_$(OUTDIR)stdtest/rustc-test += CFG_COMPILER_HOST_TRIPLE=$(RUSTC_TARGET)\n\n$(OUTDIR)stdtest/%-test: $(RUSTCSRC)src/lib%/lib.rs LIBS\n\t+MRUSTC_LIBDIR=$(abspath $(OUTDIR)) $(MINICARGO) --test $(RUSTCSRC)src/lib$* --vendor-dir $(VENDOR_DIR) --output-dir $(dir $@) -L $(OUTDIR)\n$(OUTDIR)stdtest/collectionstests: $(OUTDIR)stdtest/alloc-test\n\ttest -e $@\n$(OUTDIR)collectionstest_out.txt: $(OUTDIR)%\n$(OUTDIR)%_out.txt: $(OUTDIR)% minicargo.mk\n\t@echo \"--- [$<]\"\n\t$(ENV_$<) $V./$< $(RUNTIME_ARGS_$<) > $@ 2>&1 || (tail -n 1 $@; mv $@ $@_fail; false)\n"
        },
        {
          "name": "mrustc.cbp",
          "type": "blob",
          "size": 1.9853515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_project_file>\n\t<FileVersion major=\"1\" minor=\"6\" />\n\t<Project>\n\t\t<Option title=\"mrustc\" />\n\t\t<Option pch_mode=\"2\" />\n\t\t<Option compiler=\"gcc\" />\n\t\t<Build>\n\t\t\t<Target title=\"Debug\">\n\t\t\t\t<Option output=\"bin/Debug/mrustc\" prefix_auto=\"1\" extension_auto=\"1\" />\n\t\t\t\t<Option object_output=\"obj/Debug/\" />\n\t\t\t\t<Option type=\"1\" />\n\t\t\t\t<Option compiler=\"gcc\" />\n\t\t\t\t<Compiler>\n\t\t\t\t\t<Add option=\"-g\" />\n\t\t\t\t\t<Add directory=\"parse\" />\n\t\t\t\t</Compiler>\n\t\t\t</Target>\n\t\t\t<Target title=\"Release\">\n\t\t\t\t<Option output=\"bin/Release/mrustc\" prefix_auto=\"1\" extension_auto=\"1\" />\n\t\t\t\t<Option object_output=\"obj/Release/\" />\n\t\t\t\t<Option type=\"1\" />\n\t\t\t\t<Option compiler=\"gcc\" />\n\t\t\t\t<Compiler>\n\t\t\t\t\t<Add option=\"-O2\" />\n\t\t\t\t\t<Add directory=\"parse\" />\n\t\t\t\t</Compiler>\n\t\t\t\t<Linker>\n\t\t\t\t\t<Add option=\"-s\" />\n\t\t\t\t</Linker>\n\t\t\t</Target>\n\t\t</Build>\n\t\t<Compiler>\n\t\t\t<Add option=\"-Wall\" />\n\t\t\t<Add option=\"-fexceptions\" />\n\t\t</Compiler>\n\t\t<Unit filename=\"src/ast/ast.cpp\" />\n\t\t<Unit filename=\"src/ast/ast.hpp\" />\n\t\t<Unit filename=\"src/ast/path.hpp\" />\n\t\t<Unit filename=\"src/common.hpp\" />\n\t\t<Unit filename=\"src/convert/flatten.cpp\" />\n\t\t<Unit filename=\"src/convert/render.cpp\" />\n\t\t<Unit filename=\"src/convert/resolve.cpp\" />\n\t\t<Unit filename=\"src/coretypes.hpp\" />\n\t\t<Unit filename=\"src/macros.cpp\" />\n\t\t<Unit filename=\"src/main.cpp\" />\n\t\t<Unit filename=\"src/parse/common.hpp\" />\n\t\t<Unit filename=\"src/parse/expr.cpp\" />\n\t\t<Unit filename=\"src/parse/lex.cpp\" />\n\t\t<Unit filename=\"src/parse/lex.hpp\" />\n\t\t<Unit filename=\"src/parse/parseerror.cpp\" />\n\t\t<Unit filename=\"src/parse/parseerror.hpp\" />\n\t\t<Unit filename=\"src/parse/preproc.cpp\" />\n\t\t<Unit filename=\"src/parse/preproc.hpp\" />\n\t\t<Unit filename=\"src/parse/root.cpp\" />\n\t\t<Unit filename=\"src/samples/1.rs\" />\n\t\t<Unit filename=\"src/types.cpp\" />\n\t\t<Unit filename=\"src/types.hpp\" />\n\t\t<Extensions>\n\t\t\t<code_completion />\n\t\t\t<envvars />\n\t\t\t<debugger />\n\t\t\t<lib_finder disable_auto=\"1\" />\n\t\t</Extensions>\n\t</Project>\n</CodeBlocks_project_file>\n"
        },
        {
          "name": "run_rustc",
          "type": "tree",
          "content": null
        },
        {
          "name": "rust-nightly-date",
          "type": "blob",
          "size": 0.0107421875,
          "content": "2018-07-09\n"
        },
        {
          "name": "rust-version",
          "type": "blob",
          "size": 0.0068359375,
          "content": "1.29.0\n"
        },
        {
          "name": "rustc-1.19.0-src.patch",
          "type": "blob",
          "size": 0.9599609375,
          "content": "--- src/libcore/intrinsics.rs\n+++ src/libcore/intrinsics.rs\n@@ -691,6 +691,10 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n+    /// Obtain the length of a slice pointer\n+    #[cfg(rust_compiler=\"mrustc\")]\n+    pub fn mrustc_slice_len<T>(pointer: *const [T]) -> usize;\n+\n     /// Gets a static string slice containing the name of a type.\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n--- src/libcore/slice/mod.rs\n+++ src/libcore/slice/mod.rs\n@@ -412,9 +412,11 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn len(&self) -> usize {\n-        unsafe {\n-            mem::transmute::<&[T], Repr<T>>(self).len\n-        }\n+        #[cfg(not(rust_compiler=\"mrustc\"))]\n+        let rv = unsafe { mem::transmute::<&[T], Repr<T>>(self).len };\n+        #[cfg(rust_compiler=\"mrustc\")]\n+        let rv = unsafe { ::intrinsics::mrustc_slice_len(self) };\n+        rv\n     }\n \n     #[inline]\n"
        },
        {
          "name": "rustc-1.29.0-src.patch",
          "type": "blob",
          "size": 14.2978515625,
          "content": "# Add mrustc slice length intrinsics\n--- src/libcore/intrinsics.rs\n+++ src/libcore/intrinsics.rs\n@@ -689,6 +689,10 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n+    /// Obtain the length of a slice pointer\n+    #[cfg(rust_compiler=\"mrustc\")]\n+    pub fn mrustc_slice_len<T>(pointer: *const [T]) -> usize;\n+\n     /// Gets a static string slice containing the name of a type.\n     pub fn type_name<T: ?Sized>() -> &'static str;\n\n--- src/libcore/slice/mod.rs\n+++ src/libcore/slice/mod.rs\n@@ -128,9 +128,11 @@ impl<T> [T] {\n     #[inline]\n     #[rustc_const_unstable(feature = \"const_slice_len\")]\n     pub const fn len(&self) -> usize {\n-        unsafe {\n-            Repr { rust: self }.raw.len\n-        }\n+        #[cfg(not(rust_compiler=\"mrustc\"))]\n+        const fn len_inner<T>(s: &[T]) -> usize { unsafe { Repr { rust: s }.raw.len } };\n+        #[cfg(rust_compiler=\"mrustc\")]\n+        const fn len_inner<T>(s: &[T]) -> usize { unsafe { ::intrinsics::mrustc_slice_len(s) } }\n+        len_inner(self)\n     }\n \n     /// Returns `true` if the slice has a length of 0.\n\n# macOS on Apple Silicon support\n--- src/liblibc/src/unix/bsd/apple/mod.rs\n+++ src/liblibc/src/unix/bsd/apple/mod.rs\n@@ -2388,9 +2388,9 @@ extern {\n     pub fn __error() -> *mut ::c_int;\n     pub fn backtrace(buf: *mut *mut ::c_void,\n                      sz: ::c_int) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"statfs$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"statfs$INODE64\")]\n     pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstatfs$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstatfs$INODE64\")]\n     pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n     pub fn kevent(kq: ::c_int,\n                   changelist: *const ::kevent,\n\n--- src/liblibc/src/unix/bsd/mod.rs\n+++ src/liblibc/src/unix/bsd/mod.rs\n@@ -402,7 +402,7 @@ extern {\n                       euid: *mut ::uid_t,\n                       egid: *mut ::gid_t) -> ::c_int;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"glob$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"glob$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__glob30\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"glob@FBSD_1.0\")]\n     pub fn glob(pattern: *const ::c_char,\n\n--- src/liblibc/src/unix/mod.rs\n+++ src/liblibc/src/unix/mod.rs\n@@ -390,14 +390,14 @@ extern {\n                link_name = \"fchmod$UNIX2003\")]\n     pub fn fchmod(fd: ::c_int, mode: mode_t) -> ::c_int;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__fstat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"fstat@FBSD_1.0\")]\n     pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n \n     pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"stat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"stat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__stat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"stat@FBSD_1.0\")]\n     pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n@@ -431,11 +431,11 @@ extern {\n                link_name = \"fdopendir$INODE64$UNIX2003\")]\n     pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"readdir$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"readdir$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__readdir30\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"readdir@FBSD_1.0\")]\n     pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"readdir_r$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"readdir_r$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__readdir_r30\")]\n     #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_readdir_r\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"readdir_r@FBSD_1.0\")]\n@@ -460,7 +460,7 @@ extern {\n     pub fn fchownat(dirfd: ::c_int, pathname: *const ::c_char,\n                     owner: ::uid_t, group: ::gid_t,\n                     flags: ::c_int) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstatat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstatat$INODE64\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"fstatat@FBSD_1.1\")]\n     pub fn fstatat(dirfd: ::c_int, pathname: *const ::c_char,\n                    buf: *mut stat, flags: ::c_int) -> ::c_int;\n@@ -613,7 +613,7 @@ extern {\n     pub fn if_indextoname(ifindex: ::c_uint,\n                           ifname: *mut ::c_char) -> *mut ::c_char;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"lstat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"lstat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__lstat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"lstat@FBSD_1.0\")]\n     pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;\n\n# mrustc can't represent a 24 byte version of this enum (no way of storing the\n# tag in padding)\n--- src/librustc/ty/context.rs\n+++ src/librustc/ty/context.rs\n@@ -802,10 +802,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         // Ensure our type representation does not grow\n-        #[cfg(target_pointer_width = \"64\")]\n-        assert!(mem::size_of::<ty::TypeVariants>() <= 24);\n-        #[cfg(target_pointer_width = \"64\")]\n-        assert!(mem::size_of::<ty::TyS>() <= 32);\n+        //#[cfg(target_pointer_width = \"64\")]\n+        //assert!(mem::size_of::<ty::TypeVariants>() <= 24);\n+        //#[cfg(target_pointer_width = \"64\")]\n+        //assert!(mem::size_of::<ty::TyS>() <= 32);\n \n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n\n# Static-link rustc_codegen_llvm because mrustc doesn't have dylib support\n--- src/librustc_driver/Cargo.toml\n+++ src/librustc_driver/Cargo.toml\n@@ -37,3 +37,4 @@ serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_codegen_llvm = { path = \"../librustc_codegen_llvm\" }\n\n--- src/librustc_driver/lib.rs\n+++ src/librustc_driver/lib.rs\n@@ -61,6 +61,7 @@ extern crate log;\n extern crate syntax;\n extern crate syntax_ext;\n extern crate syntax_pos;\n+extern crate rustc_codegen_llvm;\n \n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n@@ -294,6 +295,10 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n         return rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::new\n     }\n \n+    if backend_name == \"llvm\" {\n+        return rustc_codegen_llvm::__rustc_codegen_backend;\n+    }\n+\n     let target = session::config::host_triple();\n     let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n     let path = current_dll_path()\n\n# A strange bug in `librustc_mir`\n# - The signature of the impl block is `impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx>`\n# - But the closure argument uses `'gcx, 'tcx` (switching the order of the two args)\n# MIGHT BE A RUSTC BUG?\n--- src/librustc_mir/borrow_check/nll/invalidation.rs\n+++ src/librustc_mir/borrow_check/nll/invalidation.rs\n@@ -298,4 +298,4 @@ fn visit_terminator_drop(\n         let drop_field = |\n-            ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n+            ig: &mut InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx>,\n             (index, field): (usize, ty::Ty<'gcx>),\n         | {\n\n--- src/stdsimd/stdsimd/arch/detect/os/x86.rs\n+++ src/stdsimd/stdsimd/arch/detect/os/x86.rs\n@@ -13,9 +13,15 @@ use arch::detect::bit;\n \n /// Performs run-time feature detection.\n #[inline]\n+#[cfg(not(rust_compiler=\"mrustc\"))]\n pub fn check_for(x: Feature) -> bool {\n     cache::test(x as u32, detect_features)\n }\n+#[inline]\n+#[cfg(rust_compiler=\"mrustc\")]\n+pub fn check_for(x: Feature) -> bool {\n+    false\n+}\n \n /// Run-time feature detection on x86 works by using the CPUID instruction.\n ///\n\n# No workspace support in minicargo, patch cargo's Cargo.toml\n--- src/tools/cargo/Cargo.toml\n+++ src/tools/cargo/Cargo.toml\n@@ -60,7 +60,7 @@ openssl = { version = '0.10.11', optional = true }\n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n-rustc-workspace-hack = \"1.0.0\"\n+rustc-workspace-hack = { path = \"../rustc-workspace-hack\" }\n \n [target.'cfg(target_os = \"macos\")'.dependencies]\n core-foundation = { version = \"0.6.0\", features = [\"mac_os_10_7_support\"] }\n\n--- src/vendor/core-foundation-sys/src/attributed_string.rs\n+++ src/vendor/core-foundation-sys/src/attributed_string.rs\n@@ -52,5 +52,4 @@ extern {\n         value: CFTypeRef,\n     );\n \n-    pub fn CFMutableAttributedStringGetTypeID() -> CFTypeID;\n }\n\n# Backport of https://github.com/servo/core-foundation-rs/commit/aa6d1cd4c15561b48c24322527e3d9e60f603db4\n--- src/vendor/core-foundation/src/attributed_string.rs\n+++ src/vendor/core-foundation/src/attributed_string.rs\n@@ -41,7 +41,7 @@ impl CFAttributedString {\n declare_TCFType!{\n     CFMutableAttributedString, CFMutableAttributedStringRef\n }\n-impl_TCFType!(CFMutableAttributedString, CFMutableAttributedStringRef, CFMutableAttributedStringGetTypeID);\n+impl_TCFType!(CFMutableAttributedString, CFMutableAttributedStringRef, CFAttributedStringGetTypeID);\n \n impl CFMutableAttributedString {\n     #[inline]\n@@ -77,3 +77,15 @@ impl CFMutableAttributedString {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn attributed_string_type_id_comparison() {\n+        // CFMutableAttributedString TypeID must be equal to CFAttributedString TypeID.\n+        // Compilation must not fail.\n+        assert_eq!(<CFAttributedString as TCFType>::type_id(), <CFMutableAttributedString as TCFType>::type_id());\n+    }\n+}\n\n--- src/vendor/libc/src/unix/bsd/apple/mod.rs\n+++ src/vendor/libc/src/unix/bsd/apple/mod.rs\n@@ -2376,9 +2376,9 @@ extern {\n     pub fn __error() -> *mut ::c_int;\n     pub fn backtrace(buf: *mut *mut ::c_void,\n                      sz: ::c_int) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"statfs$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"statfs$INODE64\")]\n     pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstatfs$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstatfs$INODE64\")]\n     pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n     pub fn kevent(kq: ::c_int,\n                   changelist: *const ::kevent,\n\n--- src/vendor/libc/src/unix/mod.rs\n+++ src/vendor/libc/src/unix/mod.rs\n@@ -382,14 +382,14 @@ extern {\n                link_name = \"fchmod$UNIX2003\")]\n     pub fn fchmod(fd: ::c_int, mode: mode_t) -> ::c_int;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__fstat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"fstat@FBSD_1.0\")]\n     pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n \n     pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"stat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"stat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__stat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"stat@FBSD_1.0\")]\n     pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n@@ -416,11 +416,11 @@ extern {\n                link_name = \"opendir$INODE64$UNIX2003\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__opendir30\")]\n     pub fn opendir(dirname: *const c_char) -> *mut ::DIR;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"readdir$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"readdir$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__readdir30\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"readdir@FBSD_1.0\")]\n     pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"readdir_r$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"readdir_r$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__readdir_r30\")]\n     #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_readdir_r\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"readdir_r@FBSD_1.0\")]\n@@ -445,7 +445,7 @@ extern {\n     pub fn fchownat(dirfd: ::c_int, pathname: *const ::c_char,\n                     owner: ::uid_t, group: ::gid_t,\n                     flags: ::c_int) -> ::c_int;\n-    #[cfg_attr(target_os = \"macos\", link_name = \"fstatat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"fstatat$INODE64\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"fstatat@FBSD_1.1\")]\n     pub fn fstatat(dirfd: ::c_int, pathname: *const ::c_char,\n                    buf: *mut stat, flags: ::c_int) -> ::c_int;\n@@ -598,7 +598,7 @@ extern {\n     pub fn if_indextoname(ifindex: ::c_uint,\n                           ifname: *mut ::c_char) -> *mut ::c_char;\n \n-    #[cfg_attr(target_os = \"macos\", link_name = \"lstat$INODE64\")]\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), link_name = \"lstat$INODE64\")]\n     #[cfg_attr(target_os = \"netbsd\", link_name = \"__lstat50\")]\n     #[cfg_attr(target_os = \"freebsd\", link_name = \"lstat@FBSD_1.0\")]\n     pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;\n\n--- src/llvm/lib/Demangle/ItaniumDemangle.cpp\n+++ src/llvm/lib/Demangle/ItaniumDemangle.cpp\n@@ -19,6 +19,7 @@\n #include <cstdio>\n #include <cstdlib>\n #include <cstring>\n+#include <limits>\n #include <numeric>\n #include <vector>\n"
        },
        {
          "name": "rustc-1.39.0-overrides.toml",
          "type": "blob",
          "size": 1.4931640625,
          "content": "#\n# minicargo overrides file\n#\n\n# rustc's libsyntax needs rustc's libproc_macro (not mrustc's)\n[add.'src/libsyntax'.dependencies]\nproc_macro = { path = \"../libproc_macro\" }\n[add.'src/libsyntax_ext'.dependencies]\nproc_macro = { path = \"../libproc_macro\" }\n[add.'src/librustc_metadata'.dependencies]\nproc_macro = { path = \"../libproc_macro\" }\n\n[delete]\n# Allow rustc's libproc_macro to build by removing the std dependency (it's built during rustc build, not during std build)\n'src/libproc_macro' = [\n\t\"dependencies.std\",\n\t]\n# mrustc has already built a proc_macro, remove it from libtest's deps\n'src/libtest' = [\n\t\"dependencies.proc_macro\",\n\t]\n\n# Add librustc_codegen_llvm as a dep to the main binary\n[add.'src/rustc'.dependencies]\nrustc_codegen_llvm = { path = \"../librustc_codegen_llvm\" }\n# And explicit dependencies for librustc_codegen_llvm's implicit deps\n[add.'src/librustc_codegen_llvm'.dependencies]\nrustc-demangle = \"0.1\"\nflate2 = \"1.0\"\nbitflags = \"1.1\"\nlibc = \"0.2\"\nrustc = { path = \"../librustc\" }\nrustc_target = { path = \"../librustc_target\" }\nrustc_data_structures = { path = \"../librustc_data_structures\" }\nrustc_incremental = { path = \"../librustc_incremental\" }\nrustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\nrustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\nrustc_fs_util = { path = \"../librustc_fs_util\" }\nrustc_driver = { path = \"../librustc_driver\" }\nlog = \"0.4\"\nsyntax = { path = \"../libsyntax\" }\nsyntax_pos = { path = \"../libsyntax_pos\" }\nrustc_errors = { path = \"../librustc_errors\" }\n\n"
        },
        {
          "name": "rustc-1.39.0-src.patch",
          "type": "blob",
          "size": 3.9462890625,
          "content": "# Add mrustc slice length intrinsics\n--- src/libcore/intrinsics.rs\n+++ src/libcore/intrinsics.rs\n@@ -684,6 +684,10 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n+    /// Obtain the length of a slice pointer\n+    #[cfg(rust_compiler=\"mrustc\")]\n+    pub fn mrustc_slice_len<T>(pointer: *const [T]) -> usize;\n+\n     /// Gets a static string slice containing the name of a type.\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n--- src/libcore/slice/mod.rs\n+++ src/libcore/slice/mod.rs\n@@ -66,9 +66,12 @@ impl<T> [T] {\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n     #[cfg_attr(not(bootstrap), allow_internal_unstable(const_fn_union))]\n     pub const fn len(&self) -> usize {\n-        unsafe {\n-            crate::ptr::Repr { rust: self }.raw.len\n-        }\n+        #[cfg(not(rust_compiler=\"mrustc\"))]\n+        #[cfg_attr(not(bootstrap), allow_internal_unstable(const_fn_union))]\n+        const fn len_inner<T>(s: &[T]) -> usize { unsafe { crate::ptr::Repr { rust: s }.raw.len } };\n+        #[cfg(rust_compiler=\"mrustc\")]\n+        const fn len_inner<T>(s: &[T]) -> usize { unsafe { crate::intrinsics::mrustc_slice_len(s) } }\n+        len_inner(self)\n     }\n \n     /// Returns `true` if the slice has a length of 0.\n\n#\n# Static-link rustc_codegen_llvm so the generated rustc is standalone\n# > Note: Interacts with `rustc-1.39.0-overrides.toml`\n#\n--- src/librustc_interface/util.rs\n+++ src/librustc_interface/util.rs\n@@ -417,6 +417,8 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n }\n \n pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+    #[cfg(rust_compiler=\"mrustc\")]\n+    { if(backend_name == \"llvm\") { extern \"Rust\" { fn __rustc_codegen_backend() -> Box<dyn CodegenBackend>; } return || unsafe { __rustc_codegen_backend() } } }\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In\n     // general this assertion never trips due to the once guard in `get_codegen_backend`,\n\n--- src/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangleNodes.h\n+++ src/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangleNodes.h\n@@ -16,6 +16,8 @@\n #include \"llvm/Demangle/DemangleConfig.h\"\n #include \"llvm/Demangle/StringView.h\"\n #include <array>\n+#include <cstdint>\n+#include <string>\n \n namespace llvm {\n namespace itanium_demangle {\n\n# Disable most architecture intrinsics\n--- src/stdarch/crates/std_detect/src/detect/mod.rs\n+++ src/stdarch/crates/std_detect/src/detect/mod.rs\n@@ -72,6 +72,9 @@ cfg_if! {\n         // this run-time detection logic is never called.\n         #[path = \"os/other.rs\"]\n         mod os;\n+    } else if #[cfg(rust_compiler=\"mrustc\")] {\n+        #[path = \"os/other.rs\"]\n+        mod os;\n     } else if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n         // On x86/x86_64 no OS specific functionality is required.\n         #[path = \"os/x86.rs\"]\n\n--- vendor/ppv-lite86/src/lib.rs\n+++ vendor/ppv-lite86/src/lib.rs\n@@ -9,14 +9,14 @@ mod soft;\n mod types;\n pub use self::types::*;\n \n-#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri)))]\n+#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri), not(rust_compiler=\"mrustc\")))]\n pub mod x86_64;\n-#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri)))]\n+#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri), not(rust_compiler=\"mrustc\")))]\n use self::x86_64 as arch;\n \n-#[cfg(any(miri, not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n+#[cfg(any(miri, rust_compiler=\"mrustc\", not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n pub mod generic;\n-#[cfg(any(miri, not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n+#[cfg(any(miri, rust_compiler=\"mrustc\", not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n use self::generic as arch;\n \n pub use self::arch::{vec128_storage, vec256_storage, vec512_storage};\n"
        },
        {
          "name": "rustc-1.54.0-overrides.toml",
          "type": "blob",
          "size": 1.111328125,
          "content": "#\n# minicargo overrides file\n#\n\n# rustc needs rustc's libproc_macro (not mrustc's)\n[add.'compiler/rustc_expand'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n[add.'compiler/rustc_builtin_macros'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n[add.'compiler/rustc_metadata'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n\n# Add an exact version of `regex` to account for there being two versions in the `vendor` dir\n# - The higher one depends on a version of of `aho-corasick` that isn't vendored\n[add.'compiler/rustc_driver'.dependencies]\nregex = \"=1.4.3\"\n[add.'tools/cargo'.dependencies]\nregex = \"=1.4.3\"\n\n[add.'library/std'.dependencies.compiler_builtins]\nfeatures = [\"no-asm\"]\n[add.'library/panic_unwind'.dependencies.compiler_builtins]\nfeatures = [\"no-asm\"]\n\n\n[delete]\n# Allow rustc's libproc_macro to build by removing the std dependency (it's built during rustc build, not during std build)\n'library/proc_macro' = [\n\t\"dependencies.std\",\n\t]\n# mrustc has already built a proc_macro, remove it from libtest's deps (used on linux)\n'library/test' = [\n\t\"dependencies.proc_macro\",\n\t]\n"
        },
        {
          "name": "rustc-1.54.0-src.patch",
          "type": "blob",
          "size": 11.3671875,
          "content": "# mrustc is much better at enum packing, so causes almost all of these to be smaller by one pointer\n--- compiler/rustc_ast/src/ast.rs\n+++ compiler/rustc_ast/src/ast.rs\n@@ -1075,7 +1075,7 @@ pub struct Expr {\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Expr, 104);\n \n impl Expr {\n@@ -2779,7 +2779,7 @@ pub enum AssocItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n \n impl AssocItemKind {\n@@ -2831,7 +2831,7 @@ pub enum ForeignItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler=\"mrustc\"),target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n \n impl From<ForeignItemKind> for ItemKind {\n\n--- compiler/rustc_hir/src/hir.rs\n+++ compiler/rustc_hir/src/hir.rs\n@@ -3048,7 +3048,7 @@ impl<'hir> Node<'hir> {\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler=\"mrustc\"),target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n     rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n\n--- compiler/rustc_middle/src/mir/interpret/error.rs\n+++ compiler/rustc_middle/src/mir/interpret/error.rs\n@@ -449,7 +449,7 @@ impl dyn MachineStopType {\n     }\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler=\"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(InterpError<'_>, 64);\n \n pub enum InterpError<'tcx> {\n\n--- compiler/rustc_middle/src/mir/mod.rs\n+++ compiler/rustc_middle/src/mir/mod.rs\n@@ -2200,7 +2200,7 @@ pub enum AggregateKind<'tcx> {\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(not(rust_compiler=\"mrustc\"), target_arch = \"x86_64\"))]\n static_assert_size!(AggregateKind<'_>, 48);\n \n #[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n\n--- compiler/rustc_middle/src/thir.rs\n+++ compiler/rustc_middle/src/thir.rs\n@@ -144,7 +144,7 @@ pub enum StmtKind<'tcx> {\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler=\"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n \n /// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n\n--- compiler/rustc_mir/src/interpret/operand.rs\n+++ compiler/rustc_mir/src/interpret/operand.rs\n@@ -32,7 +32,7 @@ pub enum Immediate<Tag = ()> {\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Immediate, 56);\n \n impl<Tag> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n@@ -87,7 +87,7 @@ pub struct ImmTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n \n impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n\n--- compiler/rustc_mir/src/interpret/place.rs\n+++ compiler/rustc_mir/src/interpret/place.rs\n@@ -88,7 +88,7 @@ pub enum Place<Tag = ()> {\n     Local { frame: usize, local: mir::Local },\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Place, 64);\n \n #[derive(Copy, Clone, Debug)]\n@@ -97,7 +97,7 @@ pub struct PlaceTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(not(rust_compiler = \"mrustc\"), target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PlaceTy<'_>, 80);\n \n impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n\n#\n# Disable std_detect's detection logic (use the same logic as miri)\n#\n--- library/stdarch/crates/std_detect/src/detect/mod.rs\n+++ library/stdarch/crates/std_detect/src/detect/mod.rs\n@@ -86,7 +86,7 @@ mod bit;\n mod cache;\n \n cfg_if! {\n-    if #[cfg(miri)] {\n+    if #[cfg(any(miri, rust_compiler = \"mrustc\"))] {\n         // When running under miri all target-features that are not enabled at\n         // compile-time are reported as disabled at run-time.\n         //\n\n#\n# Disable crc32fast's use of stdarch\n#\n--- vendor/crc32fast/src/specialized/mod.rs\n+++ vendor/crc32fast/src/specialized/mod.rs\n@@ -1,5 +1,6 @@\n cfg_if! {\n     if #[cfg(all(\n+        not(rust_compiler = \"mrustc\"),\n         crc32fast_stdarchx86,\n         any(target_arch = \"x86\", target_arch = \"x86_64\")\n     ))] {\n\n#\n# Backport which is required to support arm64 on macOS 12\n# See: https://github.com/alexcrichton/curl-rust/commit/0aea09c428b9bc2bcf46da0fc33959fe3f03c74a\n#\n--- vendor/curl/src/lib.rs\n+++ vendor/curl/src/lib.rs\n@@ -82,6 +82,9 @@ pub mod easy;\n pub mod multi;\n mod panic;\n \n+#[cfg(test)]\n+static INITIALIZED: std::sync::atomic::AtomicBool = std::sync::atomic::AtomicBool::new(false);\n+\n /// Initializes the underlying libcurl library.\n ///\n /// The underlying libcurl library must be initialized before use, and must be\n@@ -102,46 +105,62 @@ pub fn init() {\n     /// Used to prevent concurrent or duplicate initialization.\n     static INIT: Once = Once::new();\n \n-    /// An exported constructor function. On supported platforms, this will be\n-    /// invoked automatically before the program's `main` is called.\n-    #[cfg_attr(\n-        any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"android\"),\n-        link_section = \".init_array\"\n-    )]\n-    #[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\n-    #[cfg_attr(target_os = \"windows\", link_section = \".CRT$XCU\")]\n-    static INIT_CTOR: extern \"C\" fn() = init_inner;\n+    INIT.call_once(|| {\n+        #[cfg(need_openssl_init)]\n+        openssl_probe::init_ssl_cert_env_vars();\n+        #[cfg(need_openssl_init)]\n+        openssl_sys::init();\n+\n+        unsafe {\n+            assert_eq!(curl_sys::curl_global_init(curl_sys::CURL_GLOBAL_ALL), 0);\n+        }\n+\n+        #[cfg(test)]\n+        {\n+            INITIALIZED.store(true, std::sync::atomic::Ordering::SeqCst);\n+        }\n+\n+        // Note that we explicitly don't schedule a call to\n+        // `curl_global_cleanup`. The documentation for that function says\n+        //\n+        // > You must not call it when any other thread in the program (i.e. a\n+        // > thread sharing the same memory) is running. This doesn't just mean\n+        // > no other thread that is using libcurl.\n+        //\n+        // We can't ever be sure of that, so unfortunately we can't call the\n+        // function.\n+    });\n+}\n \n+/// An exported constructor function. On supported platforms, this will be\n+/// invoked automatically before the program's `main` is called. This is done\n+/// for the convenience of library users since otherwise the thread-safety rules\n+/// around initialization can be difficult to fulfill.\n+///\n+/// This is a hidden public item to ensure the symbol isn't optimized away by a\n+/// rustc/LLVM bug: https://github.com/rust-lang/rust/issues/47384. As long as\n+/// any item in this module is used by the final binary (which `init` will be)\n+/// then this symbol should be preserved.\n+#[used]\n+#[doc(hidden)]\n+#[cfg_attr(\n+    any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"android\"),\n+    link_section = \".init_array\"\n+)]\n+#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\n+#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XCU\")]\n+pub static INIT_CTOR: extern \"C\" fn() = {\n     /// This is the body of our constructor function.\n     #[cfg_attr(\n         any(target_os = \"linux\", target_os = \"android\"),\n         link_section = \".text.startup\"\n     )]\n-    extern \"C\" fn init_inner() {\n-        INIT.call_once(|| {\n-            #[cfg(need_openssl_init)]\n-            openssl_sys::init();\n-\n-            unsafe {\n-                assert_eq!(curl_sys::curl_global_init(curl_sys::CURL_GLOBAL_ALL), 0);\n-            }\n-\n-            // Note that we explicitly don't schedule a call to\n-            // `curl_global_cleanup`. The documentation for that function says\n-            //\n-            // > You must not call it when any other thread in the program (i.e.\n-            // > a thread sharing the same memory) is running. This doesn't just\n-            // > mean no other thread that is using libcurl.\n-            //\n-            // We can't ever be sure of that, so unfortunately we can't call the\n-            // function.\n-        });\n+    extern \"C\" fn init_ctor() {\n+        init();\n     }\n \n-    // We invoke our init function through our static to ensure the symbol isn't\n-    // optimized away by a bug: https://github.com/rust-lang/rust/issues/47384\n-    INIT_CTOR();\n-}\n+    init_ctor\n+};\n \n unsafe fn opt_str<'a>(ptr: *const libc::c_char) -> Option<&'a str> {\n     if ptr.is_null() {\n@@ -158,3 +177,20 @@ fn cvt(r: curl_sys::CURLcode) -> Result<(), Error> {\n         Err(Error::new(r))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    #[cfg(any(\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"windows\",\n+        target_os = \"freebsd\",\n+        target_os = \"android\"\n+    ))]\n+    fn is_initialized_before_main() {\n+        assert!(INITIALIZED.load(std::sync::atomic::Ordering::SeqCst));\n+    }\n+}\n\n# PPV-Lite also needs to know that we're pretending to be miri\n--- vendor/ppv-lite86/src/lib.rs\n+++ vendor/ppv-lite86/src/lib.rs\n@@ -9,14 +9,14 @@ mod soft;\n mod types;\n pub use self::types::*;\n \n-#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri)))]\n+#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri), not(rust_compiler = \"mrustc\")))]\n pub mod x86_64;\n-#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri)))]\n+#[cfg(all(feature = \"simd\", target_arch = \"x86_64\", not(miri), not(rust_compiler = \"mrustc\")))]\n use self::x86_64 as arch;\n \n-#[cfg(any(miri, not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n+#[cfg(any(miri, rust_compiler = \"mrustc\", not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n pub mod generic;\n-#[cfg(any(miri, not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n+#[cfg(any(miri, rust_compiler = \"mrustc\", not(all(feature = \"simd\", any(target_arch = \"x86_64\")))))]\n use self::generic as arch;\n \n pub use self::arch::{vec128_storage, vec256_storage, vec512_storage};\n\n--- src/llvm-project/llvm/include/llvm/Support/Signals.h\n+++ src/llvm-project/llvm/include/llvm/Support/Signals.h\n@@ -14,6 +14,7 @@\n #ifndef LLVM_SUPPORT_SIGNALS_H\n #define LLVM_SUPPORT_SIGNALS_H\n \n+#include <cstdint>\n #include <string>\n \n namespace llvm {\n"
        },
        {
          "name": "rustc-1.74.0-overrides.toml",
          "type": "blob",
          "size": 0.86328125,
          "content": "#\n# minicargo overrides file\n#\n\n## rustc needs rustc's libproc_macro (not mrustc's)\n[add.'compiler/rustc_expand'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n[add.'compiler/rustc_builtin_macros'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n[add.'compiler/rustc_metadata'.dependencies]\nproc_macro = { path = \"../../library/proc_macro\" }\n\n\n#[add.'library/std'.dependencies.compiler_builtins]\n#features = [\"no-asm\"]\n#[add.'library/panic_unwind'.dependencies.compiler_builtins]\n#features = [\"no-asm\"]\n\n\n[delete]\n# Allow rustc's libproc_macro to build by removing the std dependency (it's built during rustc build, not during std build)\n'library/proc_macro' = [\n\t\"dependencies.std\",\n\t\"dependencies.core\",\n\t]\n## mrustc has already built a proc_macro, remove it from libtest's deps (used on linux)\n#'library/test' = [\n#\t\"dependencies.proc_macro\",\n#\t]\n"
        },
        {
          "name": "rustc-1.74.0-src.patch",
          "type": "blob",
          "size": 5.5693359375,
          "content": "# mrustc doesn't have as good non-zero niche optimisation\n--- compiler/rustc_parse_format/src/lib.rs\n+++ compiler/rustc_parse_format/src/lib.rs\n@@ -1052,3 +1052,3 @@ \n // Assert a reasonable size for `Piece`\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n rustc_index::static_assert_size!(Piece<'_>, 16);\n--- compiler/rustc_ast/src/ast.rs\n+++ compiler/rustc_ast/src/ast.rs\n@@ -3167,4 +3167,4 @@\n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n     use super::*;\n--- compiler/rustc_hir/src/hir.rs\n+++ compiler/rustc_hir/src/hir.rs\n@@ -4078,4 +4078,4 @@\n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n     use super::*;\n--- compiler/rustc_errors/src/lib.rs\n+++ compiler/rustc_errors/src/lib.rs\n@@ -87,7 +87,7 @@\n // (See also the comment on `DiagnosticBuilderInner`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n--- compiler/rustc_const_eval/src/interpret/operand.rs\n+++ compiler/rustc_const_eval/src/interpret/operand.rs\n@@ -755,5 +755,5 @@\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n     use super::*;\n--- compiler/rustc_const_eval/src/interpret/place.rs\n+++ compiler/rustc_const_eval/src/interpret/place.rs\n@@ -1091,5 +1091,5 @@\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n     use super::*;\n--- compiler/rustc_index/src/bit_set.rs\n+++ compiler/rustc_index/src/bit_set.rs\n@@ -411,3 +411,3 @@\n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n crate::static_assert_size!(Chunk, 16);\n#\n# HACK! Avoid an unsoundness in `Path` by making `Wtf8Buf` start with `Vec<u8>`\n#\n--- library/std/src/sys_common/wtf8.rs\n+++ library/std/src/sys_common/wtf8.rs\n@@ -135,3 +135,4 @@\n #[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\n+#[cfg_attr(rust_compiler = \"mrustc\", repr(C))]\n pub struct Wtf8Buf {\n     bytes: Vec<u8>,\n\n#\n# Size checks without updated sorting\n#\n--- compiler/rustc_ast/src/tokenstream.rs\n+++ compiler/rustc_ast/src/tokenstream.rs\n@@ -739,3 +739,3 @@\n // Some types are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n--- compiler/rustc_middle/src/mir/consts.rs\n+++ compiler/rustc_middle/src/mir/consts.rs\n@@ -72,3 +72,3 @@\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n static_assert_size!(ConstValue<'_>, 24);\n--- compiler/rustc_middle/src/mir/interpret/value.rs\n+++ compiler/rustc_middle/src/mir/interpret/value.rs\n@@ -36,3 +36,3 @@\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n static_assert_size!(Scalar, 24);\n--- compiler/rustc_middle/src/mir/syntax.rs\n+++ compiler/rustc_middle/src/mir/syntax.rs\n@@ -1423,3 +1423,3 @@\n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n--- compiler/rustc_middle/src/mir/mod.rs\n+++ compiler/rustc_middle/src/mir/mod.rs\n@@ -1617,3 +1617,3 @@\n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n mod size_asserts {\n--- compiler/rustc_middle/src/ty/consts/kind.rs\n+++ compiler/rustc_middle/src/ty/consts/kind.rs\n@@ -74,3 +74,3 @@\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n static_assert_size!(Expr<'_>, 24);\n\n# MSVC Cannot handle structs larger than 32-bit, so disable this for windows with mrustc\n--- vendor/hex/src/lib.rs\n+++ vendor/hex/src/lib.rs\n@@ -238,3 +238,3 @@\n \n-#[cfg(target_pointer_width = \"64\")]\n+#[cfg(all(target_pointer_width = \"64\", not(rust_compiler = \"mrustc\")))]\n from_hex_array_impl! {\n\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "script-overrides",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_smiri.sh",
          "type": "blob",
          "size": 0.435546875,
          "content": "#!/bin/sh\nset -e\ncd $(dirname $0)\nmake all\nmake -C tools/standalone_miri || exit 1\nmake -f minicargo.mk MMIR=1 LIBS V= || exit 1\necho \"--- mrustc -o output-mmir/hello\"\n./bin/mrustc rustc-1.19.0-src/src/test/run-pass/hello.rs -O -C codegen-type=monomir -o output-mmir/hello -L output-mmir/ > output-mmir/hello_dbg.txt || exit 1\necho \"--- standalone_miri output-mmir/hello.mir\"\n./bin/standalone_miri output-mmir/hello.mir --logfile smiri_hello.log\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "vsproject",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}