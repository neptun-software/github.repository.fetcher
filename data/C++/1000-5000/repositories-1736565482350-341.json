{
  "metadata": {
    "timestamp": 1736565482350,
    "page": 341,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "adafruit/Adafruit_NeoPixel",
      "stars": 3157,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0751953125,
          "content": "# Our handy .gitignore for automation ease\nDoxyfile*\ndoxygen_sqlite3.db\nhtml\n"
        },
        {
          "name": "Adafruit_NeoPixel.cpp",
          "type": "blob",
          "size": 126.86328125,
          "content": "/*!\r\n * @file Adafruit_NeoPixel.cpp\r\n *\r\n * @mainpage Arduino Library for driving Adafruit NeoPixel addressable LEDs,\r\n * FLORA RGB Smart Pixels and compatible devicess -- WS2811, WS2812, WS2812B,\r\n * SK6812, etc.\r\n *\r\n * @section intro_sec Introduction\r\n *\r\n * This is the documentation for Adafruit's NeoPixel library for the\r\n * Arduino platform, allowing a broad range of microcontroller boards\r\n * (most AVR boards, many ARM devices, ESP8266 and ESP32, among others)\r\n * to control Adafruit NeoPixels, FLORA RGB Smart Pixels and compatible\r\n * devices -- WS2811, WS2812, WS2812B, SK6812, etc.\r\n *\r\n * Adafruit invests time and resources providing this open source code,\r\n * please support Adafruit and open-source hardware by purchasing products\r\n * from Adafruit!\r\n *\r\n * @section author Author\r\n *\r\n * Written by Phil \"Paint Your Dragon\" Burgess for Adafruit Industries,\r\n * with contributions by PJRC, Michael Miller and other members of the\r\n * open source community.\r\n *\r\n * @section license License\r\n *\r\n * This file is part of the Adafruit_NeoPixel library.\r\n *\r\n * Adafruit_NeoPixel is free software: you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public License as\r\n * published by the Free Software Foundation, either version 3 of the\r\n * License, or (at your option) any later version.\r\n *\r\n * Adafruit_NeoPixel is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with NeoPixel. If not, see\r\n * <http://www.gnu.org/licenses/>.\r\n *\r\n */\r\n\r\n#include \"Adafruit_NeoPixel.h\"\r\n\r\n#if defined(TARGET_LPC1768)\r\n#include <time.h>\r\n#endif\r\n\r\n#if defined(NRF52) || defined(NRF52_SERIES)\r\n#include \"nrf.h\"\r\n\r\n// Interrupt is only disabled if there is no PWM device available\r\n// Note: Adafruit Bluefruit nrf52 does not use this option\r\n//#define NRF52_DISABLE_INT\r\n#endif\r\n\r\n#if defined(ARDUINO_ARCH_NRF52840)\r\n#if defined __has_include\r\n#if __has_include(<pinDefinitions.h>)\r\n#include <pinDefinitions.h>\r\n#endif\r\n#endif\r\n#endif\r\n\r\n/*!\r\n  @brief   NeoPixel constructor when length, pin and pixel type are known\r\n           at compile-time.\r\n  @param   n  Number of NeoPixels in strand.\r\n  @param   p  Arduino pin number which will drive the NeoPixel data in.\r\n  @param   t  Pixel type -- add together NEO_* constants defined in\r\n              Adafruit_NeoPixel.h, for example NEO_GRB+NEO_KHZ800 for\r\n              NeoPixels expecting an 800 KHz (vs 400 KHz) data stream\r\n              with color bytes expressed in green, red, blue order per\r\n              pixel.\r\n  @return  Adafruit_NeoPixel object. Call the begin() function before use.\r\n*/\r\nAdafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, int16_t p, neoPixelType t)\r\n    : begun(false), brightness(0), pixels(NULL), endTime(0) {\r\n  updateType(t);\r\n  updateLength(n);\r\n  setPin(p);\r\n#if defined(ARDUINO_ARCH_RP2040)\r\n  // Find a free SM on one of the PIO's\r\n  sm = pio_claim_unused_sm(pio, false); // don't panic\r\n  // Try pio1 if SM not found\r\n  if (sm < 0) {\r\n    pio = pio1;\r\n    sm = pio_claim_unused_sm(pio, true); // panic if no SM is free\r\n  }\r\n  init = true;\r\n#endif\r\n}\r\n\r\n/*!\r\n  @brief   \"Empty\" NeoPixel constructor when length, pin and/or pixel type\r\n           are not known at compile-time, and must be initialized later with\r\n           updateType(), updateLength() and setPin().\r\n  @return  Adafruit_NeoPixel object. Call the begin() function before use.\r\n  @note    This function is deprecated, here only for old projects that\r\n           may still be calling it. New projects should instead use the\r\n           'new' keyword with the first constructor syntax (length, pin,\r\n           type).\r\n*/\r\nAdafruit_NeoPixel::Adafruit_NeoPixel()\r\n    :\r\n#if defined(NEO_KHZ400)\r\n      is800KHz(true),\r\n#endif\r\n      begun(false), numLEDs(0), numBytes(0), pin(-1), brightness(0),\r\n      pixels(NULL), rOffset(1), gOffset(0), bOffset(2), wOffset(1), endTime(0) {\r\n}\r\n\r\n/*!\r\n  @brief   Deallocate Adafruit_NeoPixel object, set data pin back to INPUT.\r\n*/\r\nAdafruit_NeoPixel::~Adafruit_NeoPixel() {\r\n  free(pixels);\r\n  if (pin >= 0)\r\n    pinMode(pin, INPUT);\r\n}\r\n\r\n/*!\r\n  @brief   Configure NeoPixel pin for output.\r\n*/\r\nvoid Adafruit_NeoPixel::begin(void) {\r\n  if (pin >= 0) {\r\n    pinMode(pin, OUTPUT);\r\n    digitalWrite(pin, LOW);\r\n  }\r\n  begun = true;\r\n}\r\n\r\n/*!\r\n  @brief   Change the length of a previously-declared Adafruit_NeoPixel\r\n           strip object. Old data is deallocated and new data is cleared.\r\n           Pin number and pixel format are unchanged.\r\n  @param   n  New length of strip, in pixels.\r\n  @note    This function is deprecated, here only for old projects that\r\n           may still be calling it. New projects should instead use the\r\n           'new' keyword with the first constructor syntax (length, pin,\r\n           type).\r\n*/\r\nvoid Adafruit_NeoPixel::updateLength(uint16_t n) {\r\n  free(pixels); // Free existing data (if any)\r\n\r\n  // Allocate new data -- note: ALL PIXELS ARE CLEARED\r\n  numBytes = n * ((wOffset == rOffset) ? 3 : 4);\r\n  if ((pixels = (uint8_t *)malloc(numBytes))) {\r\n    memset(pixels, 0, numBytes);\r\n    numLEDs = n;\r\n  } else {\r\n    numLEDs = numBytes = 0;\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Change the pixel format of a previously-declared\r\n           Adafruit_NeoPixel strip object. If format changes from one of\r\n           the RGB variants to an RGBW variant (or RGBW to RGB), the old\r\n           data will be deallocated and new data is cleared. Otherwise,\r\n           the old data will remain in RAM and is not reordered to the\r\n           new format, so it's advisable to follow up with clear().\r\n  @param   t  Pixel type -- add together NEO_* constants defined in\r\n              Adafruit_NeoPixel.h, for example NEO_GRB+NEO_KHZ800 for\r\n              NeoPixels expecting an 800 KHz (vs 400 KHz) data stream\r\n              with color bytes expressed in green, red, blue order per\r\n              pixel.\r\n  @note    This function is deprecated, here only for old projects that\r\n           may still be calling it. New projects should instead use the\r\n           'new' keyword with the first constructor syntax\r\n           (length, pin, type).\r\n*/\r\nvoid Adafruit_NeoPixel::updateType(neoPixelType t) {\r\n  bool oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW\r\n\r\n  wOffset = (t >> 6) & 0b11; // See notes in header file\r\n  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets\r\n  gOffset = (t >> 2) & 0b11;\r\n  bOffset = t & 0b11;\r\n#if defined(NEO_KHZ400)\r\n  is800KHz = (t < 256); // 400 KHz flag is 1<<8\r\n#endif\r\n\r\n  // If bytes-per-pixel has changed (and pixel data was previously\r\n  // allocated), re-allocate to new size. Will clear any data.\r\n  if (pixels) {\r\n    bool newThreeBytesPerPixel = (wOffset == rOffset);\r\n    if (newThreeBytesPerPixel != oldThreeBytesPerPixel)\r\n      updateLength(numLEDs);\r\n  }\r\n}\r\n\r\n// RP2040 specific driver\r\n#if defined(ARDUINO_ARCH_RP2040)\r\nvoid Adafruit_NeoPixel::rp2040Init(uint8_t pin, bool is800KHz)\r\n{\r\n  uint offset = pio_add_program(pio, &ws2812_program);\r\n\r\n  if (is800KHz)\r\n  {\r\n    // 800kHz, 8 bit transfers\r\n    ws2812_program_init(pio, sm, offset, pin, 800000, 8);\r\n  }\r\n  else\r\n  {\r\n    // 400kHz, 8 bit transfers\r\n    ws2812_program_init(pio, sm, offset, pin, 400000, 8);\r\n  }\r\n}\r\n// Not a user API\r\nvoid  Adafruit_NeoPixel::rp2040Show(uint8_t pin, uint8_t *pixels, uint32_t numBytes, bool is800KHz)\r\n{\r\n  if (this->init)\r\n  {\r\n    // On first pass through initialise the PIO\r\n    rp2040Init(pin, is800KHz);\r\n    this->init = false;\r\n  }\r\n\r\n  while(numBytes--)\r\n    // Bits for transmission must be shifted to top 8 bits\r\n    pio_sm_put_blocking(pio, sm, ((uint32_t)*pixels++)<< 24);\r\n}\r\n#elif defined(ARDUINO_ARCH_CH32)\r\n\r\n// F_CPU is defined to SystemCoreClock (not constant number)\r\n#if SYSCLK_FREQ_144MHz_HSE == 144000000 || SYSCLK_FREQ_HSE == 144000000 || \\\r\n  SYSCLK_FREQ_144MHz_HSI == 144000000 || SYSCLK_FREQ_HSI == 144000000\r\n#define CH32_F_CPU 144000000\r\n\r\n#elif SYSCLK_FREQ_120MHz_HSE == 120000000 || SYSCLK_FREQ_HSE == 120000000 || \\\r\n  SYSCLK_FREQ_120MHz_HSI == 120000000 || SYSCLK_FREQ_HSI == 120000000\r\n#define CH32_F_CPU 120000000\r\n\r\n#elif SYSCLK_FREQ_96MHz_HSE == 96000000 || SYSCLK_FREQ_HSE == 96000000 || \\\r\n  SYSCLK_FREQ_96MHz_HSI == 96000000 || SYSCLK_FREQ_HSI == 96000000\r\n#define CH32_F_CPU 96000000\r\n\r\n#elif SYSCLK_FREQ_72MHz_HSE == 72000000 || SYSCLK_FREQ_HSE == 72000000 || \\\r\n  SYSCLK_FREQ_72MHz_HSI == 72000000 || SYSCLK_FREQ_HSI == 72000000\r\n#define CH32_F_CPU 72000000\r\n\r\n#elif SYSCLK_FREQ_56MHz_HSE == 56000000 || SYSCLK_FREQ_HSE == 56000000 || \\\r\n  SYSCLK_FREQ_56MHz_HSI == 56000000 || SYSCLK_FREQ_HSI == 56000000\r\n#define CH32_F_CPU 56000000\r\n\r\n#elif SYSCLK_FREQ_48MHz_HSE == 48000000 || SYSCLK_FREQ_HSE == 48000000 || \\\r\n  SYSCLK_FREQ_48MHz_HSI == 48000000 || SYSCLK_FREQ_HSI == 48000000\r\n#define CH32_F_CPU 48000000\r\n\r\n#endif\r\n\r\nstatic void ch32Show(GPIO_TypeDef* ch_port, uint32_t ch_pin, uint8_t* pixels, uint32_t numBytes, bool is800KHz) {\r\n  // not support 400khz\r\n  if (!is800KHz) return;\r\n\r\n  volatile uint32_t* set = &ch_port->BSHR;\r\n  volatile uint32_t* clr = &ch_port->BCR;\r\n\r\n  uint8_t* ptr = pixels;\r\n  uint8_t* end = ptr + numBytes;\r\n  uint8_t p = *ptr++;\r\n  uint8_t bitMask = 0x80;\r\n\r\n  // NVIC_DisableIRQ(SysTicK_IRQn);\r\n\r\n  while (1) {\r\n    if (p & bitMask) { // ONE\r\n      // High 800ns\r\n      *set = ch_pin;\r\n      __asm volatile (\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop;\"\r\n#if CH32_F_CPU >= 72000000\r\n        \"nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 96000000\r\n        \"nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 120000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 144000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n        );\r\n\r\n      // Low 450ns\r\n      *clr = ch_pin;\r\n      __asm volatile (\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop;\"\r\n#if CH32_F_CPU >= 72000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 96000000\r\n        \"nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 120000000\r\n        \"nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 144000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n        );\r\n    } else {   // ZERO\r\n      // High 400ns\r\n      *set = ch_pin;\r\n      __asm volatile (\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop;\"\r\n#if CH32_F_CPU >= 72000000\r\n        \"nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 96000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 120000000\r\n        \"nop; nop; nop; \"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 144000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n        );\r\n\r\n      // Low 850ns\r\n      *clr = ch_pin;\r\n      __asm volatile (\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop;\"\r\n#if CH32_F_CPU >= 72000000\r\n        \"nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 96000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 120000000\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n#if CH32_F_CPU >= 144000000\r\n        \"nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n#endif\r\n        );\r\n    }\r\n\r\n    if (bitMask >>= 1) {\r\n      // Move on to the next pixel\r\n      asm(\"nop;\");\r\n    }\r\n    else {\r\n      if (ptr >= end) {\r\n        break;\r\n      }\r\n      p = *ptr++;\r\n      bitMask = 0x80;\r\n    }\r\n  }\r\n\r\n  // NVIC_EnableIRQ(SysTicK_IRQn);\r\n}\r\n#endif\r\n\r\n#if defined(ESP8266)\r\n// ESP8266 show() is external to enforce ICACHE_RAM_ATTR execution\r\nextern \"C\" IRAM_ATTR void espShow(uint16_t pin, uint8_t *pixels,\r\n                                  uint32_t numBytes, uint8_t type);\r\n#elif defined(ESP32)\r\nextern \"C\" void espShow(uint16_t pin, uint8_t *pixels, uint32_t numBytes,\r\n                        uint8_t type);\r\n#endif // ESP8266\r\n\r\n#if defined(K210)\r\n#define KENDRYTE_K210 1\r\n#endif\r\n\r\n#if defined(KENDRYTE_K210)\r\nextern \"C\" void k210Show(uint8_t pin, uint8_t *pixels, uint32_t numBytes,\r\n                         boolean is800KHz);\r\n#endif // KENDRYTE_K210\r\n/*!\r\n  @brief   Transmit pixel data in RAM to NeoPixels.\r\n  @note    On most architectures, interrupts are temporarily disabled in\r\n           order to achieve the correct NeoPixel signal timing. This means\r\n           that the Arduino millis() and micros() functions, which require\r\n           interrupts, will lose small intervals of time whenever this\r\n           function is called (about 30 microseconds per RGB pixel, 40 for\r\n           RGBW pixels). There's no easy fix for this, but a few\r\n           specialized alternative or companion libraries exist that use\r\n           very device-specific peripherals to work around it.\r\n*/\r\nvoid Adafruit_NeoPixel::show(void) {\r\n\r\n  if (!pixels)\r\n    return;\r\n\r\n  // Data latch = 300+ microsecond pause in the output stream. Rather than\r\n  // put a delay at the end of the function, the ending time is noted and\r\n  // the function will simply hold off (if needed) on issuing the\r\n  // subsequent round of data until the latch time has elapsed. This\r\n  // allows the mainline code to start generating the next frame of data\r\n  // rather than stalling for the latch.\r\n  while (!canShow())\r\n    ;\r\n    // endTime is a private member (rather than global var) so that multiple\r\n    // instances on different pins can be quickly issued in succession (each\r\n    // instance doesn't delay the next).\r\n\r\n    // In order to make this code runtime-configurable to work with any pin,\r\n    // SBI/CBI instructions are eschewed in favor of full PORT writes via the\r\n    // OUT or ST instructions. It relies on two facts: that peripheral\r\n    // functions (such as PWM) take precedence on output pins, so our PORT-\r\n    // wide writes won't interfere, and that interrupts are globally disabled\r\n    // while data is being issued to the LEDs, so no other code will be\r\n    // accessing the PORT. The code takes an initial 'snapshot' of the PORT\r\n    // state, computes 'pin high' and 'pin low' values, and writes these back\r\n    // to the PORT register as needed.\r\n\r\n  // NRF52 may use PWM + DMA (if available), may not need to disable interrupt\r\n  // ESP32 may not disable interrupts because espShow() uses RMT which tries to acquire locks\r\n#if !(defined(NRF52) || defined(NRF52_SERIES) || defined(ESP32))\r\n  noInterrupts(); // Need 100% focus on instruction timing\r\n#endif\r\n\r\n#if defined(__AVR__)\r\n  // AVR MCUs -- ATmega & ATtiny (no XMEGA) ---------------------------------\r\n\r\n  volatile uint16_t i = numBytes; // Loop counter\r\n  volatile uint8_t *ptr = pixels, // Pointer to next byte\r\n      b = *ptr++,                 // Current byte value\r\n      hi,                         // PORT w/output bit set high\r\n      lo;                         // PORT w/output bit set low\r\n\r\n  // Hand-tuned assembly code issues data to the LED drivers at a specific\r\n  // rate. There's separate code for different CPU speeds (8, 12, 16 MHz)\r\n  // for both the WS2811 (400 KHz) and WS2812 (800 KHz) drivers. The\r\n  // datastream timing for the LED drivers allows a little wiggle room each\r\n  // way (listed in the datasheets), so the conditions for compiling each\r\n  // case are set up for a range of frequencies rather than just the exact\r\n  // 8, 12 or 16 MHz values, permitting use with some close-but-not-spot-on\r\n  // devices (e.g. 16.5 MHz DigiSpark). The ranges were arrived at based\r\n  // on the datasheet figures and have not been extensively tested outside\r\n  // the canonical 8/12/16 MHz speeds; there's no guarantee these will work\r\n  // close to the extremes (or possibly they could be pushed further).\r\n  // Keep in mind only one CPU speed case actually gets compiled; the\r\n  // resulting program isn't as massive as it might look from source here.\r\n\r\n// 8 MHz(ish) AVR ---------------------------------------------------------\r\n#if (F_CPU >= 7400000UL) && (F_CPU <= 9500000UL)\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n\r\n    volatile uint8_t n1, n2 = 0; // First, next bits out\r\n\r\n    // Squeezing an 800 KHz stream out of an 8 MHz chip requires code\r\n    // specific to each PORT register.\r\n\r\n    // 10 instruction clocks per bit: HHxxxxxLLL\r\n    // OUT instructions:              ^ ^    ^   (T=0,2,7)\r\n\r\n    // PORTD OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTD)\r\n#if defined(PORTB) || defined(PORTC) || defined(PORTF)\r\n    if (port == &PORTD) {\r\n#endif // defined(PORTB/C/F)\r\n\r\n      hi = PORTD | pinMask;\r\n      lo = PORTD & ~pinMask;\r\n      n1 = lo;\r\n      if (b & 0x80)\r\n        n1 = hi;\r\n\r\n      // Dirty trick: RJMPs proceeding to the next instruction are used\r\n      // to delay two clock cycles in one instruction word (rather than\r\n      // using two NOPs). This was necessary in order to squeeze the\r\n      // loop down to exactly 64 words -- the maximum possible for a\r\n      // relative branch.\r\n\r\n      asm volatile(\r\n          \"headD:\"\r\n          \"\\n\\t\" // Clk  Pseudocode\r\n                 // Bit 7:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n2   = lo\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\" // 1    PORT = n1\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 6\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x40)\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n2 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 6:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n1   = lo\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\" // 1    PORT = n2\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 5\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x20)\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n1 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 5:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n2   = lo\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\" // 1    PORT = n1\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 4\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x10)\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n2 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 4:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n1   = lo\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\" // 1    PORT = n2\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 3\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x08)\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n1 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 3:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n2   = lo\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\" // 1    PORT = n1\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 2\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x04)\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n2 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 2:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n1   = lo\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\" // 1    PORT = n2\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 1\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x02)\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n1 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          // Bit 1:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n2   = lo\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\" // 1    PORT = n1\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\" // 2    nop nop\r\n          \"sbrc %[byte] , 0\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x01)\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n2 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"sbiw %[count], 1\"\r\n          \"\\n\\t\" // 2    i-- (don't act on Z flag yet)\r\n          // Bit 0:\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\" // 1    PORT = hi\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\" // 1    n1   = lo\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\" // 1    PORT = n2\r\n          \"ld   %[byte] , %a[ptr]+\"\r\n          \"\\n\\t\" // 2    b = *ptr++\r\n          \"sbrc %[byte] , 7\"\r\n          \"\\n\\t\" // 1-2  if(b & 0x80)\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\" // 0-1   n1 = hi\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\" // 1    PORT = lo\r\n          \"brne headD\"\r\n          \"\\n\" // 2    while(i) (Z flag set above)\r\n          : [byte] \"+r\"(b), [n1] \"+r\"(n1), [n2] \"+r\"(n2), [count] \"+w\"(i)\r\n          : [port] \"I\"(_SFR_IO_ADDR(PORTD)), [ptr] \"e\"(ptr), [hi] \"r\"(hi),\r\n            [lo] \"r\"(lo));\r\n\r\n#if defined(PORTB) || defined(PORTC) || defined(PORTF)\r\n    } else // other PORT(s)\r\n#endif // defined(PORTB/C/F)\r\n#endif // defined(PORTD)\r\n\r\n    // PORTB OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTB)\r\n#if defined(PORTD) || defined(PORTC) || defined(PORTF)\r\n        if (port == &PORTB) {\r\n#endif // defined(PORTD/C/F)\r\n\r\n      // Same as above, just switched to PORTB and stripped of comments.\r\n      hi = PORTB | pinMask;\r\n      lo = PORTB & ~pinMask;\r\n      n1 = lo;\r\n      if (b & 0x80)\r\n        n1 = hi;\r\n\r\n      asm volatile(\r\n          \"headB:\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 6\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 5\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 4\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 3\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 2\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 1\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 0\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"sbiw %[count], 1\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"ld   %[byte] , %a[ptr]+\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 7\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"brne headB\"\r\n          \"\\n\"\r\n          : [byte] \"+r\"(b), [n1] \"+r\"(n1), [n2] \"+r\"(n2), [count] \"+w\"(i)\r\n          : [port] \"I\"(_SFR_IO_ADDR(PORTB)), [ptr] \"e\"(ptr), [hi] \"r\"(hi),\r\n            [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTC) || defined(PORTF)\r\n    }\r\n#endif\r\n#if defined(PORTC) || defined(PORTF)\r\n    else\r\n#endif // defined(PORTC/F)\r\n#endif // defined(PORTB)\r\n\r\n    // PORTC OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTC)\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTF)\r\n        if (port == &PORTC) {\r\n#endif // defined(PORTD/B/F)\r\n\r\n      // Same as above, just switched to PORTC and stripped of comments.\r\n      hi = PORTC | pinMask;\r\n      lo = PORTC & ~pinMask;\r\n      n1 = lo;\r\n      if (b & 0x80)\r\n        n1 = hi;\r\n\r\n      asm volatile(\r\n          \"headC:\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 6\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 5\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 4\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 3\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 2\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 1\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 0\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"sbiw %[count], 1\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"ld   %[byte] , %a[ptr]+\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 7\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"brne headC\"\r\n          \"\\n\"\r\n          : [byte] \"+r\"(b), [n1] \"+r\"(n1), [n2] \"+r\"(n2), [count] \"+w\"(i)\r\n          : [port] \"I\"(_SFR_IO_ADDR(PORTC)), [ptr] \"e\"(ptr), [hi] \"r\"(hi),\r\n            [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTF)\r\n    }\r\n#endif // defined(PORTD/B/F)\r\n#if defined(PORTF)\r\n    else\r\n#endif\r\n#endif // defined(PORTC)\r\n\r\n    // PORTF OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTF)\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTC)\r\n        if (port == &PORTF) {\r\n#endif // defined(PORTD/B/C)\r\n\r\n      hi = PORTF | pinMask;\r\n      lo = PORTF & ~pinMask;\r\n      n1 = lo;\r\n      if (b & 0x80)\r\n        n1 = hi;\r\n\r\n      asm volatile(\r\n          \"headF:\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 6\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 5\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 4\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 3\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 2\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 1\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n2]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n1]\"\r\n          \"\\n\\t\"\r\n          \"rjmp .+0\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 0\"\r\n          \"\\n\\t\"\r\n          \"mov %[n2]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"sbiw %[count], 1\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"mov  %[n1]   , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[n2]\"\r\n          \"\\n\\t\"\r\n          \"ld   %[byte] , %a[ptr]+\"\r\n          \"\\n\\t\"\r\n          \"sbrc %[byte] , 7\"\r\n          \"\\n\\t\"\r\n          \"mov %[n1]   , %[hi]\"\r\n          \"\\n\\t\"\r\n          \"out  %[port] , %[lo]\"\r\n          \"\\n\\t\"\r\n          \"brne headF\"\r\n          \"\\n\"\r\n          : [byte] \"+r\"(b), [n1] \"+r\"(n1), [n2] \"+r\"(n2), [count] \"+w\"(i)\r\n          : [port] \"I\"(_SFR_IO_ADDR(PORTF)), [ptr] \"e\"(ptr), [hi] \"r\"(hi),\r\n            [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTC)\r\n    }\r\n#endif // defined(PORTD/B/C)\r\n#endif // defined(PORTF)\r\n\r\n#if defined(NEO_KHZ400)\r\n  } else { // end 800 KHz, do 400 KHz\r\n\r\n    // Timing is more relaxed; unrolling the inner loop for each bit is\r\n    // not necessary. Still using the peculiar RJMPs as 2X NOPs, not out\r\n    // of need but just to trim the code size down a little.\r\n    // This 400-KHz-datastream-on-8-MHz-CPU code is not quite identical\r\n    // to the 800-on-16 code later -- the hi/lo timing between WS2811 and\r\n    // WS2812 is not simply a 2:1 scale!\r\n\r\n    // 20 inst. clocks per bit: HHHHxxxxxxLLLLLLLLLL\r\n    // ST instructions:         ^   ^     ^          (T=0,4,10)\r\n\r\n    volatile uint8_t next, bit;\r\n\r\n    hi = *port | pinMask;\r\n    lo = *port & ~pinMask;\r\n    next = lo;\r\n    bit = 8;\r\n\r\n    asm volatile(\"head20:\"\r\n                 \"\\n\\t\" // Clk  Pseudocode    (T =  0)\r\n                 \"st   %a[port], %[hi]\"\r\n                 \"\\n\\t\" // 2    PORT = hi     (T =  2)\r\n                 \"sbrc %[byte] , 7\"\r\n                 \"\\n\\t\" // 1-2  if(b & 128)\r\n                 \"mov  %[next], %[hi]\"\r\n                 \"\\n\\t\" // 0-1   next = hi    (T =  4)\r\n                 \"st   %a[port], %[next]\"\r\n                 \"\\n\\t\" // 2    PORT = next   (T =  6)\r\n                 \"mov  %[next] , %[lo]\"\r\n                 \"\\n\\t\" // 1    next = lo     (T =  7)\r\n                 \"dec  %[bit]\"\r\n                 \"\\n\\t\" // 1    bit--         (T =  8)\r\n                 \"breq nextbyte20\"\r\n                 \"\\n\\t\" // 1-2  if(bit == 0)\r\n                 \"rol  %[byte]\"\r\n                 \"\\n\\t\" // 1    b <<= 1       (T = 10)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 12)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 14)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 16)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 18)\r\n                 \"rjmp head20\"\r\n                 \"\\n\\t\" // 2    -> head20 (next bit out)\r\n                 \"nextbyte20:\"\r\n                 \"\\n\\t\" //                    (T = 10)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 12)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 13)\r\n                 \"ldi  %[bit]  , 8\"\r\n                 \"\\n\\t\" // 1    bit = 8       (T = 14)\r\n                 \"ld   %[byte] , %a[ptr]+\"\r\n                 \"\\n\\t\" // 2    b = *ptr++    (T = 16)\r\n                 \"sbiw %[count], 1\"\r\n                 \"\\n\\t\" // 2    i--           (T = 18)\r\n                 \"brne head20\"\r\n                 \"\\n\" // 2    if(i != 0) -> (next byte)\r\n                 : [port] \"+e\"(port), [byte] \"+r\"(b), [bit] \"+r\"(bit),\r\n                   [next] \"+r\"(next), [count] \"+w\"(i)\r\n                 : [hi] \"r\"(hi), [lo] \"r\"(lo), [ptr] \"e\"(ptr));\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n// 12 MHz(ish) AVR --------------------------------------------------------\r\n#elif (F_CPU >= 11100000UL) && (F_CPU <= 14300000UL)\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n\r\n    // In the 12 MHz case, an optimized 800 KHz datastream (no dead time\r\n    // between bytes) requires a PORT-specific loop similar to the 8 MHz\r\n    // code (but a little more relaxed in this case).\r\n\r\n    // 15 instruction clocks per bit: HHHHxxxxxxLLLLL\r\n    // OUT instructions:              ^   ^     ^     (T=0,4,10)\r\n\r\n    volatile uint8_t next;\r\n\r\n    // PORTD OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTD)\r\n#if defined(PORTB) || defined(PORTC) || defined(PORTF)\r\n    if (port == &PORTD) {\r\n#endif // defined(PORTB/C/F)\r\n\r\n      hi = PORTD | pinMask;\r\n      lo = PORTD & ~pinMask;\r\n      next = lo;\r\n      if (b & 0x80)\r\n        next = hi;\r\n\r\n      // Don't \"optimize\" the OUT calls into the bitTime subroutine;\r\n      // we're exploiting the RCALL and RET as 3- and 4-cycle NOPs!\r\n      asm volatile(\"headD:\"\r\n                   \"\\n\\t\" //        (T =  0)\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\" //        (T =  1)\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 7  (T = 15)\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 6\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 5\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 4\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 3\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 2\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeD\"\r\n                   \"\\n\\t\" // Bit 1\r\n                   // Bit 0:\r\n                   \"out  %[port] , %[hi]\"\r\n                   \"\\n\\t\" // 1    PORT = hi    (T =  1)\r\n                   \"rjmp .+0\"\r\n                   \"\\n\\t\" // 2    nop nop      (T =  3)\r\n                   \"ld   %[byte] , %a[ptr]+\"\r\n                   \"\\n\\t\" // 2    b = *ptr++   (T =  5)\r\n                   \"out  %[port] , %[next]\"\r\n                   \"\\n\\t\" // 1    PORT = next  (T =  6)\r\n                   \"mov  %[next] , %[lo]\"\r\n                   \"\\n\\t\" // 1    next = lo    (T =  7)\r\n                   \"sbrc %[byte] , 7\"\r\n                   \"\\n\\t\" // 1-2  if(b & 0x80) (T =  8)\r\n                   \"mov %[next] , %[hi]\"\r\n                   \"\\n\\t\" // 0-1    next = hi  (T =  9)\r\n                   \"nop\"\r\n                   \"\\n\\t\" // 1                 (T = 10)\r\n                   \"out  %[port] , %[lo]\"\r\n                   \"\\n\\t\" // 1    PORT = lo    (T = 11)\r\n                   \"sbiw %[count], 1\"\r\n                   \"\\n\\t\" // 2    i--          (T = 13)\r\n                   \"brne headD\"\r\n                   \"\\n\\t\" // 2    if(i != 0) -> (next byte)\r\n                   \"rjmp doneD\"\r\n                   \"\\n\\t\"\r\n                   \"bitTimeD:\"\r\n                   \"\\n\\t\" //      nop nop nop     (T =  4)\r\n                   \"out  %[port], %[next]\"\r\n                   \"\\n\\t\" // 1    PORT = next     (T =  5)\r\n                   \"mov  %[next], %[lo]\"\r\n                   \"\\n\\t\" // 1    next = lo       (T =  6)\r\n                   \"rol  %[byte]\"\r\n                   \"\\n\\t\" // 1    b <<= 1         (T =  7)\r\n                   \"sbrc %[byte], 7\"\r\n                   \"\\n\\t\" // 1-2  if(b & 0x80)    (T =  8)\r\n                   \"mov %[next], %[hi]\"\r\n                   \"\\n\\t\" // 0-1   next = hi      (T =  9)\r\n                   \"nop\"\r\n                   \"\\n\\t\" // 1                    (T = 10)\r\n                   \"out  %[port], %[lo]\"\r\n                   \"\\n\\t\" // 1    PORT = lo       (T = 11)\r\n                   \"ret\"\r\n                   \"\\n\\t\" // 4    nop nop nop nop (T = 15)\r\n                   \"doneD:\"\r\n                   \"\\n\"\r\n                   : [byte] \"+r\"(b), [next] \"+r\"(next), [count] \"+w\"(i)\r\n                   : [port] \"I\"(_SFR_IO_ADDR(PORTD)), [ptr] \"e\"(ptr),\r\n                     [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n\r\n#if defined(PORTB) || defined(PORTC) || defined(PORTF)\r\n    } else // other PORT(s)\r\n#endif // defined(PORTB/C/F)\r\n#endif // defined(PORTD)\r\n\r\n    // PORTB OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTB)\r\n#if defined(PORTD) || defined(PORTC) || defined(PORTF)\r\n        if (port == &PORTB) {\r\n#endif // defined(PORTD/C/F)\r\n\r\n      hi = PORTB | pinMask;\r\n      lo = PORTB & ~pinMask;\r\n      next = lo;\r\n      if (b & 0x80)\r\n        next = hi;\r\n\r\n      // Same as above, just set for PORTB & stripped of comments\r\n      asm volatile(\"headB:\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeB\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp .+0\"\r\n                   \"\\n\\t\"\r\n                   \"ld   %[byte] , %a[ptr]+\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte] , 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbiw %[count], 1\"\r\n                   \"\\n\\t\"\r\n                   \"brne headB\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp doneB\"\r\n                   \"\\n\\t\"\r\n                   \"bitTimeB:\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"rol  %[byte]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte], 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"ret\"\r\n                   \"\\n\\t\"\r\n                   \"doneB:\"\r\n                   \"\\n\"\r\n                   : [byte] \"+r\"(b), [next] \"+r\"(next), [count] \"+w\"(i)\r\n                   : [port] \"I\"(_SFR_IO_ADDR(PORTB)), [ptr] \"e\"(ptr),\r\n                     [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTC) || defined(PORTF)\r\n    }\r\n#endif\r\n#if defined(PORTC) || defined(PORTF)\r\n    else\r\n#endif // defined(PORTC/F)\r\n#endif // defined(PORTB)\r\n\r\n    // PORTC OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTC)\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTF)\r\n        if (port == &PORTC) {\r\n#endif // defined(PORTD/B/F)\r\n\r\n      hi = PORTC | pinMask;\r\n      lo = PORTC & ~pinMask;\r\n      next = lo;\r\n      if (b & 0x80)\r\n        next = hi;\r\n\r\n      // Same as above, just set for PORTC & stripped of comments\r\n      asm volatile(\"headC:\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp .+0\"\r\n                   \"\\n\\t\"\r\n                   \"ld   %[byte] , %a[ptr]+\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte] , 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbiw %[count], 1\"\r\n                   \"\\n\\t\"\r\n                   \"brne headC\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp doneC\"\r\n                   \"\\n\\t\"\r\n                   \"bitTimeC:\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"rol  %[byte]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte], 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"ret\"\r\n                   \"\\n\\t\"\r\n                   \"doneC:\"\r\n                   \"\\n\"\r\n                   : [byte] \"+r\"(b), [next] \"+r\"(next), [count] \"+w\"(i)\r\n                   : [port] \"I\"(_SFR_IO_ADDR(PORTC)), [ptr] \"e\"(ptr),\r\n                     [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTF)\r\n    }\r\n#endif // defined(PORTD/B/F)\r\n#if defined(PORTF)\r\n    else\r\n#endif\r\n#endif // defined(PORTC)\r\n\r\n    // PORTF OUTPUT ----------------------------------------------------\r\n\r\n#if defined(PORTF)\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTC)\r\n        if (port == &PORTF) {\r\n#endif // defined(PORTD/B/C)\r\n\r\n      hi = PORTF | pinMask;\r\n      lo = PORTF & ~pinMask;\r\n      next = lo;\r\n      if (b & 0x80)\r\n        next = hi;\r\n\r\n      // Same as above, just set for PORTF & stripped of comments\r\n      asm volatile(\"headF:\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out   %[port], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rcall bitTimeC\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp .+0\"\r\n                   \"\\n\\t\"\r\n                   \"ld   %[byte] , %a[ptr]+\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte] , 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next] , %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port] , %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"sbiw %[count], 1\"\r\n                   \"\\n\\t\"\r\n                   \"brne headF\"\r\n                   \"\\n\\t\"\r\n                   \"rjmp doneC\"\r\n                   \"\\n\\t\"\r\n                   \"bitTimeC:\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[next]\"\r\n                   \"\\n\\t\"\r\n                   \"mov  %[next], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"rol  %[byte]\"\r\n                   \"\\n\\t\"\r\n                   \"sbrc %[byte], 7\"\r\n                   \"\\n\\t\"\r\n                   \"mov %[next], %[hi]\"\r\n                   \"\\n\\t\"\r\n                   \"nop\"\r\n                   \"\\n\\t\"\r\n                   \"out  %[port], %[lo]\"\r\n                   \"\\n\\t\"\r\n                   \"ret\"\r\n                   \"\\n\\t\"\r\n                   \"doneC:\"\r\n                   \"\\n\"\r\n                   : [byte] \"+r\"(b), [next] \"+r\"(next), [count] \"+w\"(i)\r\n                   : [port] \"I\"(_SFR_IO_ADDR(PORTF)), [ptr] \"e\"(ptr),\r\n                     [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n\r\n#if defined(PORTD) || defined(PORTB) || defined(PORTC)\r\n    }\r\n#endif // defined(PORTD/B/C)\r\n#endif // defined(PORTF)\r\n\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz\r\n\r\n    // 30 instruction clocks per bit: HHHHHHxxxxxxxxxLLLLLLLLLLLLLLL\r\n    // ST instructions:               ^     ^        ^    (T=0,6,15)\r\n\r\n    volatile uint8_t next, bit;\r\n\r\n    hi = *port | pinMask;\r\n    lo = *port & ~pinMask;\r\n    next = lo;\r\n    bit = 8;\r\n\r\n    asm volatile(\"head30:\"\r\n                 \"\\n\\t\" // Clk  Pseudocode    (T =  0)\r\n                 \"st   %a[port], %[hi]\"\r\n                 \"\\n\\t\" // 2    PORT = hi     (T =  2)\r\n                 \"sbrc %[byte] , 7\"\r\n                 \"\\n\\t\" // 1-2  if(b & 128)\r\n                 \"mov  %[next], %[hi]\"\r\n                 \"\\n\\t\" // 0-1   next = hi    (T =  4)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T =  6)\r\n                 \"st   %a[port], %[next]\"\r\n                 \"\\n\\t\" // 2    PORT = next   (T =  8)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 10)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 12)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 14)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 15)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 17)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 19)\r\n                 \"dec  %[bit]\"\r\n                 \"\\n\\t\" // 1    bit--         (T = 20)\r\n                 \"breq nextbyte30\"\r\n                 \"\\n\\t\" // 1-2  if(bit == 0)\r\n                 \"rol  %[byte]\"\r\n                 \"\\n\\t\" // 1    b <<= 1       (T = 22)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 24)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 26)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 28)\r\n                 \"rjmp head30\"\r\n                 \"\\n\\t\" // 2    -> head30 (next bit out)\r\n                 \"nextbyte30:\"\r\n                 \"\\n\\t\" //                    (T = 22)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 23)\r\n                 \"ldi  %[bit]  , 8\"\r\n                 \"\\n\\t\" // 1    bit = 8       (T = 24)\r\n                 \"ld   %[byte] , %a[ptr]+\"\r\n                 \"\\n\\t\" // 2    b = *ptr++    (T = 26)\r\n                 \"sbiw %[count], 1\"\r\n                 \"\\n\\t\" // 2    i--           (T = 28)\r\n                 \"brne head30\"\r\n                 \"\\n\" // 1-2  if(i != 0) -> (next byte)\r\n                 : [port] \"+e\"(port), [byte] \"+r\"(b), [bit] \"+r\"(bit),\r\n                   [next] \"+r\"(next), [count] \"+w\"(i)\r\n                 : [hi] \"r\"(hi), [lo] \"r\"(lo), [ptr] \"e\"(ptr));\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n// 16 MHz(ish) AVR --------------------------------------------------------\r\n#elif (F_CPU >= 15400000UL) && (F_CPU <= 19000000L)\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n\r\n    // WS2811 and WS2812 have different hi/lo duty cycles; this is\r\n    // similar but NOT an exact copy of the prior 400-on-8 code.\r\n\r\n    // 20 inst. clocks per bit: HHHHHxxxxxxxxLLLLLLL\r\n    // ST instructions:         ^   ^        ^       (T=0,5,13)\r\n\r\n    volatile uint8_t next, bit;\r\n\r\n    hi = *port | pinMask;\r\n    lo = *port & ~pinMask;\r\n    next = lo;\r\n    bit = 8;\r\n\r\n    asm volatile(\"head20:\"\r\n                 \"\\n\\t\" // Clk  Pseudocode    (T =  0)\r\n                 \"st   %a[port],  %[hi]\"\r\n                 \"\\n\\t\" // 2    PORT = hi     (T =  2)\r\n                 \"sbrc %[byte],  7\"\r\n                 \"\\n\\t\" // 1-2  if(b & 128)\r\n                 \"mov  %[next], %[hi]\"\r\n                 \"\\n\\t\" // 0-1   next = hi    (T =  4)\r\n                 \"dec  %[bit]\"\r\n                 \"\\n\\t\" // 1    bit--         (T =  5)\r\n                 \"st   %a[port],  %[next]\"\r\n                 \"\\n\\t\" // 2    PORT = next   (T =  7)\r\n                 \"mov  %[next] ,  %[lo]\"\r\n                 \"\\n\\t\" // 1    next = lo     (T =  8)\r\n                 \"breq nextbyte20\"\r\n                 \"\\n\\t\" // 1-2  if(bit == 0) (from dec above)\r\n                 \"rol  %[byte]\"\r\n                 \"\\n\\t\" // 1    b <<= 1       (T = 10)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 12)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 13)\r\n                 \"st   %a[port],  %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 15)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 16)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 18)\r\n                 \"rjmp head20\"\r\n                 \"\\n\\t\" // 2    -> head20 (next bit out)\r\n                 \"nextbyte20:\"\r\n                 \"\\n\\t\" //                    (T = 10)\r\n                 \"ldi  %[bit]  ,  8\"\r\n                 \"\\n\\t\" // 1    bit = 8       (T = 11)\r\n                 \"ld   %[byte] ,  %a[ptr]+\"\r\n                 \"\\n\\t\" // 2    b = *ptr++    (T = 13)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 15)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 16)\r\n                 \"sbiw %[count], 1\"\r\n                 \"\\n\\t\" // 2    i--           (T = 18)\r\n                 \"brne head20\"\r\n                 \"\\n\" // 2    if(i != 0) -> (next byte)\r\n                 : [port] \"+e\"(port), [byte] \"+r\"(b), [bit] \"+r\"(bit),\r\n                   [next] \"+r\"(next), [count] \"+w\"(i)\r\n                 : [ptr] \"e\"(ptr), [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz\r\n\r\n    // The 400 KHz clock on 16 MHz MCU is the most 'relaxed' version.\r\n\r\n    // 40 inst. clocks per bit: HHHHHHHHxxxxxxxxxxxxLLLLLLLLLLLLLLLLLLLL\r\n    // ST instructions:         ^       ^           ^         (T=0,8,20)\r\n\r\n    volatile uint8_t next, bit;\r\n\r\n    hi = *port | pinMask;\r\n    lo = *port & ~pinMask;\r\n    next = lo;\r\n    bit = 8;\r\n\r\n    asm volatile(\"head40:\"\r\n                 \"\\n\\t\" // Clk  Pseudocode    (T =  0)\r\n                 \"st   %a[port], %[hi]\"\r\n                 \"\\n\\t\" // 2    PORT = hi     (T =  2)\r\n                 \"sbrc %[byte] , 7\"\r\n                 \"\\n\\t\" // 1-2  if(b & 128)\r\n                 \"mov  %[next] , %[hi]\"\r\n                 \"\\n\\t\" // 0-1   next = hi    (T =  4)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T =  6)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T =  8)\r\n                 \"st   %a[port], %[next]\"\r\n                 \"\\n\\t\" // 2    PORT = next   (T = 10)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 12)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 14)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 16)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 18)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 20)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 22)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 23)\r\n                 \"mov  %[next] , %[lo]\"\r\n                 \"\\n\\t\" // 1    next = lo     (T = 24)\r\n                 \"dec  %[bit]\"\r\n                 \"\\n\\t\" // 1    bit--         (T = 25)\r\n                 \"breq nextbyte40\"\r\n                 \"\\n\\t\" // 1-2  if(bit == 0)\r\n                 \"rol  %[byte]\"\r\n                 \"\\n\\t\" // 1    b <<= 1       (T = 27)\r\n                 \"nop\"\r\n                 \"\\n\\t\" // 1    nop           (T = 28)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 30)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 32)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 34)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 36)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 38)\r\n                 \"rjmp head40\"\r\n                 \"\\n\\t\" // 2    -> head40 (next bit out)\r\n                 \"nextbyte40:\"\r\n                 \"\\n\\t\" //                    (T = 27)\r\n                 \"ldi  %[bit]  , 8\"\r\n                 \"\\n\\t\" // 1    bit = 8       (T = 28)\r\n                 \"ld   %[byte] , %a[ptr]+\"\r\n                 \"\\n\\t\" // 2    b = *ptr++    (T = 30)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 32)\r\n                 \"st   %a[port], %[lo]\"\r\n                 \"\\n\\t\" // 2    PORT = lo     (T = 34)\r\n                 \"rjmp .+0\"\r\n                 \"\\n\\t\" // 2    nop nop       (T = 36)\r\n                 \"sbiw %[count], 1\"\r\n                 \"\\n\\t\" // 2    i--           (T = 38)\r\n                 \"brne head40\"\r\n                 \"\\n\" // 1-2  if(i != 0) -> (next byte)\r\n                 : [port] \"+e\"(port), [byte] \"+r\"(b), [bit] \"+r\"(bit),\r\n                   [next] \"+r\"(next), [count] \"+w\"(i)\r\n                 : [ptr] \"e\"(ptr), [hi] \"r\"(hi), [lo] \"r\"(lo));\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n#else\r\n#error \"CPU SPEED NOT SUPPORTED\"\r\n#endif // end F_CPU ifdefs on __AVR__\r\n\r\n  // END AVR ----------------------------------------------------------------\r\n\r\n#elif defined(__arm__)\r\n\r\n    // ARM MCUs -- Teensy 3.0, 3.1, LC, Arduino Due, RP2040 -------------------\r\n\r\n#if defined(ARDUINO_ARCH_RP2040)\r\n  // Use PIO\r\n  rp2040Show(pin, pixels, numBytes, is800KHz);\r\n\r\n#elif defined(TEENSYDUINO) &&                                                  \\\r\n    defined(KINETISK) // Teensy 3.0, 3.1, 3.2, 3.5, 3.6\r\n#define CYCLES_800_T0H (F_CPU / 4000000)\r\n#define CYCLES_800_T1H (F_CPU / 1250000)\r\n#define CYCLES_800 (F_CPU / 800000)\r\n#define CYCLES_400_T0H (F_CPU / 2000000)\r\n#define CYCLES_400_T1H (F_CPU / 833333)\r\n#define CYCLES_400 (F_CPU / 400000)\r\n\r\n  uint8_t *p = pixels, *end = p + numBytes, pix, mask;\r\n  volatile uint8_t *set = portSetRegister(pin), *clr = portClearRegister(pin);\r\n  uint32_t cyc;\r\n\r\n  ARM_DEMCR |= ARM_DEMCR_TRCENA;\r\n  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_800;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = 1;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T0H)\r\n            ;\r\n        }\r\n        *clr = 1;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n      ;\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 kHz bitstream\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_400;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = 1;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T0H)\r\n            ;\r\n        }\r\n        *clr = 1;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n      ;\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n#elif defined(TEENSYDUINO) && (defined(__IMXRT1052__) || defined(__IMXRT1062__))\r\n#define CYCLES_800_T0H (F_CPU_ACTUAL / 4000000)\r\n#define CYCLES_800_T1H (F_CPU_ACTUAL / 1250000)\r\n#define CYCLES_800 (F_CPU_ACTUAL / 800000)\r\n#define CYCLES_400_T0H (F_CPU_ACTUAL / 2000000)\r\n#define CYCLES_400_T1H (F_CPU_ACTUAL / 833333)\r\n#define CYCLES_400 (F_CPU_ACTUAL / 400000)\r\n\r\n  uint8_t *p = pixels, *end = p + numBytes, pix, mask;\r\n  volatile uint32_t *set = portSetRegister(pin), *clr = portClearRegister(pin);\r\n  uint32_t cyc, msk = digitalPinToBitMask(pin);\r\n\r\n  ARM_DEMCR |= ARM_DEMCR_TRCENA;\r\n  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_800;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = msk;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T0H)\r\n            ;\r\n        }\r\n        *clr = msk;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n      ;\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 kHz bitstream\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_400;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = msk;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T0H)\r\n            ;\r\n        }\r\n        *clr = msk;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n      ;\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n#elif defined(TEENSYDUINO) && defined(__MKL26Z64__) // Teensy-LC\r\n\r\n#if F_CPU == 48000000\r\n  uint8_t *p = pixels, pix, count, dly, bitmask = digitalPinToBitMask(pin);\r\n  volatile uint8_t *reg = portSetRegister(pin);\r\n  uint32_t num = numBytes;\r\n  asm volatile(\"L%=_begin:\"\r\n               \"\\n\\t\"\r\n               \"ldrb  %[pix], [%[p], #0]\"\r\n               \"\\n\\t\"\r\n               \"lsl   %[pix], #24\"\r\n               \"\\n\\t\"\r\n               \"movs  %[count], #7\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop:\"\r\n               \"\\n\\t\"\r\n               \"lsl   %[pix], #1\"\r\n               \"\\n\\t\"\r\n               \"bcs   L%=_loop_one\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_zero:\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #0]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #4\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_delay_T0H:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_loop_delay_T0H\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #4]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #13\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_delay_T0L:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_loop_delay_T0L\"\r\n               \"\\n\\t\"\r\n               \"b     L%=_next\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_one:\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #0]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #13\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_delay_T1H:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_loop_delay_T1H\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #4]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #4\"\r\n               \"\\n\\t\"\r\n               \"L%=_loop_delay_T1L:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_loop_delay_T1L\"\r\n               \"\\n\\t\"\r\n               \"nop\"\r\n               \"\\n\\t\"\r\n               \"L%=_next:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[count], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_loop\"\r\n               \"\\n\\t\"\r\n               \"lsl   %[pix], #1\"\r\n               \"\\n\\t\"\r\n               \"bcs   L%=_last_one\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_zero:\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #0]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #4\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_delay_T0H:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_last_delay_T0H\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #4]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #10\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_delay_T0L:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_last_delay_T0L\"\r\n               \"\\n\\t\"\r\n               \"b     L%=_repeat\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_one:\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #0]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #13\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_delay_T1H:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_last_delay_T1H\"\r\n               \"\\n\\t\"\r\n               \"strb  %[bitmask], [%[reg], #4]\"\r\n               \"\\n\\t\"\r\n               \"movs  %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"L%=_last_delay_T1L:\"\r\n               \"\\n\\t\"\r\n               \"sub   %[dly], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_last_delay_T1L\"\r\n               \"\\n\\t\"\r\n               \"nop\"\r\n               \"\\n\\t\"\r\n               \"L%=_repeat:\"\r\n               \"\\n\\t\"\r\n               \"add   %[p], #1\"\r\n               \"\\n\\t\"\r\n               \"sub   %[num], #1\"\r\n               \"\\n\\t\"\r\n               \"bne   L%=_begin\"\r\n               \"\\n\\t\"\r\n               \"L%=_done:\"\r\n               \"\\n\\t\"\r\n               : [p] \"+r\"(p), [pix] \"=&r\"(pix), [count] \"=&r\"(count),\r\n                 [dly] \"=&r\"(dly), [num] \"+r\"(num)\r\n               : [bitmask] \"r\"(bitmask), [reg] \"r\"(reg));\r\n#else\r\n#error \"Sorry, only 48 MHz is supported, please set Tools > CPU Speed to 48 MHz\"\r\n#endif // F_CPU == 48000000\r\n\r\n  // Begin of support for nRF52 based boards  -------------------------\r\n\r\n#elif defined(NRF52) || defined(NRF52_SERIES)\r\n// [[[Begin of the Neopixel NRF52 EasyDMA implementation\r\n//                                    by the Hackerspace San Salvador]]]\r\n// This technique uses the PWM peripheral on the NRF52. The PWM uses the\r\n// EasyDMA feature included on the chip. This technique loads the duty\r\n// cycle configuration for each cycle when the PWM is enabled. For this\r\n// to work we need to store a 16 bit configuration for each bit of the\r\n// RGB(W) values in the pixel buffer.\r\n// Comparator values for the PWM were hand picked and are guaranteed to\r\n// be 100% organic to preserve freshness and high accuracy. Current\r\n// parameters are:\r\n//   * PWM Clock: 16Mhz\r\n//   * Minimum step time: 62.5ns\r\n//   * Time for zero in high (T0H): 0.31ms\r\n//   * Time for one in high (T1H): 0.75ms\r\n//   * Cycle time:  1.25us\r\n//   * Frequency: 800Khz\r\n// For 400Khz we just double the calculated times.\r\n// ---------- BEGIN Constants for the EasyDMA implementation -----------\r\n// The PWM starts the duty cycle in LOW. To start with HIGH we\r\n// need to set the 15th bit on each register.\r\n\r\n// WS2812 (rev A) timing is 0.35 and 0.7us\r\n//#define MAGIC_T0H               5UL | (0x8000) // 0.3125us\r\n//#define MAGIC_T1H              12UL | (0x8000) // 0.75us\r\n\r\n// WS2812B (rev B) timing is 0.4 and 0.8 us\r\n#define MAGIC_T0H 6UL | (0x8000) // 0.375us\r\n#define MAGIC_T1H 13UL | (0x8000) // 0.8125us\r\n\r\n// WS2811 (400 khz) timing is 0.5 and 1.2\r\n#define MAGIC_T0H_400KHz 8UL | (0x8000) // 0.5us\r\n#define MAGIC_T1H_400KHz 19UL | (0x8000) // 1.1875us\r\n\r\n// For 400Khz, we double value of CTOPVAL\r\n#define CTOPVAL 20UL // 1.25us\r\n#define CTOPVAL_400KHz 40UL // 2.5us\r\n\r\n// ---------- END Constants for the EasyDMA implementation -------------\r\n//\r\n// If there is no device available an alternative cycle-counter\r\n// implementation is tried.\r\n// The nRF52 runs with a fixed clock of 64Mhz. The alternative\r\n// implementation is the same as the one used for the Teensy 3.0/1/2 but\r\n// with the Nordic SDK HAL & registers syntax.\r\n// The number of cycles was hand picked and is guaranteed to be 100%\r\n// organic to preserve freshness and high accuracy.\r\n// ---------- BEGIN Constants for cycle counter implementation ---------\r\n#define CYCLES_800_T0H 18 // ~0.36 uS\r\n#define CYCLES_800_T1H 41 // ~0.76 uS\r\n#define CYCLES_800 71 // ~1.25 uS\r\n\r\n#define CYCLES_400_T0H 26 // ~0.50 uS\r\n#define CYCLES_400_T1H 70 // ~1.26 uS\r\n#define CYCLES_400 156 // ~2.50 uS\r\n  // ---------- END of Constants for cycle counter implementation --------\r\n\r\n  // To support both the SoftDevice + Neopixels we use the EasyDMA\r\n  // feature from the NRF25. However this technique implies to\r\n  // generate a pattern and store it on the memory. The actual\r\n  // memory used in bytes corresponds to the following formula:\r\n  //              totalMem = numBytes*8*2+(2*2)\r\n  // The two additional bytes at the end are needed to reset the\r\n  // sequence.\r\n  //\r\n  // If there is not enough memory, we will fall back to cycle counter\r\n  // using DWT\r\n  uint32_t pattern_size =\r\n      numBytes * 8 * sizeof(uint16_t) + 2 * sizeof(uint16_t);\r\n  uint16_t *pixels_pattern = NULL;\r\n\r\n  NRF_PWM_Type *pwm = NULL;\r\n\r\n  // Try to find a free PWM device, which is not enabled\r\n  // and has no connected pins\r\n  NRF_PWM_Type *PWM[] = {\r\n    NRF_PWM0,\r\n    NRF_PWM1,\r\n    NRF_PWM2\r\n#if defined(NRF_PWM3)\r\n    ,\r\n    NRF_PWM3\r\n#endif\r\n  };\r\n\r\n  for (unsigned int device = 0; device < (sizeof(PWM) / sizeof(PWM[0]));\r\n       device++) {\r\n    if ((PWM[device]->ENABLE == 0) &&\r\n        (PWM[device]->PSEL.OUT[0] & PWM_PSEL_OUT_CONNECT_Msk) &&\r\n        (PWM[device]->PSEL.OUT[1] & PWM_PSEL_OUT_CONNECT_Msk) &&\r\n        (PWM[device]->PSEL.OUT[2] & PWM_PSEL_OUT_CONNECT_Msk) &&\r\n        (PWM[device]->PSEL.OUT[3] & PWM_PSEL_OUT_CONNECT_Msk)) {\r\n      pwm = PWM[device];\r\n      break;\r\n    }\r\n  }\r\n\r\n  // only malloc if there is PWM device available\r\n  if (pwm != NULL) {\r\n#if defined(ARDUINO_NRF52_ADAFRUIT) // use thread-safe malloc\r\n    pixels_pattern = (uint16_t *)rtos_malloc(pattern_size);\r\n#else\r\n    pixels_pattern = (uint16_t *)malloc(pattern_size);\r\n#endif\r\n  }\r\n\r\n  // Use the identified device to choose the implementation\r\n  // If a PWM device is available use DMA\r\n  if ((pixels_pattern != NULL) && (pwm != NULL)) {\r\n    uint16_t pos = 0; // bit position\r\n\r\n    for (uint16_t n = 0; n < numBytes; n++) {\r\n      uint8_t pix = pixels[n];\r\n\r\n      for (uint8_t mask = 0x80; mask > 0; mask >>= 1) {\r\n#if defined(NEO_KHZ400)\r\n        if (!is800KHz) {\r\n          pixels_pattern[pos] =\r\n              (pix & mask) ? MAGIC_T1H_400KHz : MAGIC_T0H_400KHz;\r\n        } else\r\n#endif\r\n        {\r\n          pixels_pattern[pos] = (pix & mask) ? MAGIC_T1H : MAGIC_T0H;\r\n        }\r\n\r\n        pos++;\r\n      }\r\n    }\r\n\r\n    // Zero padding to indicate the end of que sequence\r\n    pixels_pattern[pos++] = 0 | (0x8000); // Seq end\r\n    pixels_pattern[pos++] = 0 | (0x8000); // Seq end\r\n\r\n    // Set the wave mode to count UP\r\n    pwm->MODE = (PWM_MODE_UPDOWN_Up << PWM_MODE_UPDOWN_Pos);\r\n\r\n    // Set the PWM to use the 16MHz clock\r\n    pwm->PRESCALER =\r\n        (PWM_PRESCALER_PRESCALER_DIV_1 << PWM_PRESCALER_PRESCALER_Pos);\r\n\r\n    // Setting of the maximum count\r\n    // but keeping it on 16Mhz allows for more granularity just\r\n    // in case someone wants to do more fine-tuning of the timing.\r\n#if defined(NEO_KHZ400)\r\n    if (!is800KHz) {\r\n      pwm->COUNTERTOP = (CTOPVAL_400KHz << PWM_COUNTERTOP_COUNTERTOP_Pos);\r\n    } else\r\n#endif\r\n    {\r\n      pwm->COUNTERTOP = (CTOPVAL << PWM_COUNTERTOP_COUNTERTOP_Pos);\r\n    }\r\n\r\n    // Disable loops, we want the sequence to repeat only once\r\n    pwm->LOOP = (PWM_LOOP_CNT_Disabled << PWM_LOOP_CNT_Pos);\r\n\r\n    // On the \"Common\" setting the PWM uses the same pattern for the\r\n    // for supported sequences. The pattern is stored on half-word\r\n    // of 16bits\r\n    pwm->DECODER = (PWM_DECODER_LOAD_Common << PWM_DECODER_LOAD_Pos) |\r\n                   (PWM_DECODER_MODE_RefreshCount << PWM_DECODER_MODE_Pos);\r\n\r\n    // Pointer to the memory storing the patter\r\n    pwm->SEQ[0].PTR = (uint32_t)(pixels_pattern) << PWM_SEQ_PTR_PTR_Pos;\r\n\r\n    // Calculation of the number of steps loaded from memory.\r\n    pwm->SEQ[0].CNT = (pattern_size / sizeof(uint16_t)) << PWM_SEQ_CNT_CNT_Pos;\r\n\r\n    // The following settings are ignored with the current config.\r\n    pwm->SEQ[0].REFRESH = 0;\r\n    pwm->SEQ[0].ENDDELAY = 0;\r\n\r\n    // The Neopixel implementation is a blocking algorithm. DMA\r\n    // allows for non-blocking operation. To \"simulate\" a blocking\r\n    // operation we enable the interruption for the end of sequence\r\n    // and block the execution thread until the event flag is set by\r\n    // the peripheral.\r\n    //    pwm->INTEN |= (PWM_INTEN_SEQEND0_Enabled<<PWM_INTEN_SEQEND0_Pos);\r\n\r\n// PSEL must be configured before enabling PWM\r\n#if defined(ARDUINO_ARCH_NRF52840)\r\n    pwm->PSEL.OUT[0] = g_APinDescription[pin].name;\r\n#else\r\n    pwm->PSEL.OUT[0] = g_ADigitalPinMap[pin];\r\n#endif\r\n\r\n    // Enable the PWM\r\n    pwm->ENABLE = 1;\r\n\r\n    // After all of this and many hours of reading the documentation\r\n    // we are ready to start the sequence...\r\n    pwm->EVENTS_SEQEND[0] = 0;\r\n    pwm->TASKS_SEQSTART[0] = 1;\r\n\r\n    // But we have to wait for the flag to be set.\r\n    while (!pwm->EVENTS_SEQEND[0]) {\r\n#if defined(ARDUINO_NRF52_ADAFRUIT) || defined(ARDUINO_ARCH_NRF52840)\r\n      yield();\r\n#endif\r\n    }\r\n\r\n    // Before leave we clear the flag for the event.\r\n    pwm->EVENTS_SEQEND[0] = 0;\r\n\r\n    // We need to disable the device and disconnect\r\n    // all the outputs before leave or the device will not\r\n    // be selected on the next call.\r\n    // TODO: Check if disabling the device causes performance issues.\r\n    pwm->ENABLE = 0;\r\n\r\n    pwm->PSEL.OUT[0] = 0xFFFFFFFFUL;\r\n\r\n#if defined(ARDUINO_NRF52_ADAFRUIT) // use thread-safe free\r\n    rtos_free(pixels_pattern);\r\n#else\r\n    free(pixels_pattern);\r\n#endif\r\n  } // End of DMA implementation\r\n  // ---------------------------------------------------------------------\r\n  else {\r\n#ifndef ARDUINO_ARCH_NRF52840\r\n// Fall back to DWT\r\n#if defined(ARDUINO_NRF52_ADAFRUIT)\r\n    // Bluefruit Feather 52 uses freeRTOS\r\n    // Critical Section is used since it does not block SoftDevice execution\r\n    taskENTER_CRITICAL();\r\n#elif defined(NRF52_DISABLE_INT)\r\n    // If you are using the Bluetooth SoftDevice we advise you to not disable\r\n    // the interrupts. Disabling the interrupts even for short periods of time\r\n    // causes the SoftDevice to stop working.\r\n    // Disable the interrupts only in cases where you need high performance for\r\n    // the LEDs and if you are not using the EasyDMA feature.\r\n    __disable_irq();\r\n#endif\r\n\r\n    NRF_GPIO_Type *nrf_port = (NRF_GPIO_Type *)digitalPinToPort(pin);\r\n    uint32_t pinMask = digitalPinToBitMask(pin);\r\n\r\n    uint32_t CYCLES_X00 = CYCLES_800;\r\n    uint32_t CYCLES_X00_T1H = CYCLES_800_T1H;\r\n    uint32_t CYCLES_X00_T0H = CYCLES_800_T0H;\r\n\r\n#if defined(NEO_KHZ400)\r\n    if (!is800KHz) {\r\n      CYCLES_X00 = CYCLES_400;\r\n      CYCLES_X00_T1H = CYCLES_400_T1H;\r\n      CYCLES_X00_T0H = CYCLES_400_T0H;\r\n    }\r\n#endif\r\n\r\n    // Enable DWT in debug core\r\n    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;\r\n    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;\r\n\r\n    // Tries to re-send the frame if is interrupted by the SoftDevice.\r\n    while (1) {\r\n      uint8_t *p = pixels;\r\n\r\n      uint32_t cycStart = DWT->CYCCNT;\r\n      uint32_t cyc = 0;\r\n\r\n      for (uint16_t n = 0; n < numBytes; n++) {\r\n        uint8_t pix = *p++;\r\n\r\n        for (uint8_t mask = 0x80; mask; mask >>= 1) {\r\n          while (DWT->CYCCNT - cyc < CYCLES_X00)\r\n            ;\r\n          cyc = DWT->CYCCNT;\r\n\r\n          nrf_port->OUTSET |= pinMask;\r\n\r\n          if (pix & mask) {\r\n            while (DWT->CYCCNT - cyc < CYCLES_X00_T1H)\r\n              ;\r\n          } else {\r\n            while (DWT->CYCCNT - cyc < CYCLES_X00_T0H)\r\n              ;\r\n          }\r\n\r\n          nrf_port->OUTCLR |= pinMask;\r\n        }\r\n      }\r\n      while (DWT->CYCCNT - cyc < CYCLES_X00)\r\n        ;\r\n\r\n      // If total time longer than 25%, resend the whole data.\r\n      // Since we are likely to be interrupted by SoftDevice\r\n      if ((DWT->CYCCNT - cycStart) < (8 * numBytes * ((CYCLES_X00 * 5) / 4))) {\r\n        break;\r\n      }\r\n\r\n      // re-send need 300us delay\r\n      delayMicroseconds(300);\r\n    }\r\n\r\n// Enable interrupts again\r\n#if defined(ARDUINO_NRF52_ADAFRUIT)\r\n    taskEXIT_CRITICAL();\r\n#elif defined(NRF52_DISABLE_INT)\r\n    __enable_irq();\r\n#endif\r\n#endif\r\n  }\r\n  // END of NRF52 implementation\r\n\r\n#elif defined(__SAMD21E17A__) || defined(__SAMD21G18A__) || \\\r\n      defined(__SAMD21E18A__) || defined(__SAMD21J18A__) || \\\r\n      defined(__SAMD11C14A__) || defined(__SAMD21G17A__)\r\n  // Arduino Zero, Gemma/Trinket M0, SODAQ Autonomo\r\n  // and others\r\n  // Tried this with a timer/counter, couldn't quite get adequate\r\n  // resolution. So yay, you get a load of goofball NOPs...\r\n\r\n  uint8_t *ptr, *end, p, bitMask, portNum;\r\n  uint32_t pinMask;\r\n\r\n  portNum = g_APinDescription[pin].ulPort;\r\n  pinMask = 1ul << g_APinDescription[pin].ulPin;\r\n  ptr = pixels;\r\n  end = ptr + numBytes;\r\n  p = *ptr++;\r\n  bitMask = 0x80;\r\n\r\n  volatile uint32_t *set = &(PORT->Group[portNum].OUTSET.reg),\r\n                    *clr = &(PORT->Group[portNum].OUTCLR.reg);\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    for (;;) {\r\n      *set = pinMask;\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      if (p & bitMask) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop;\");\r\n        *clr = pinMask;\r\n      } else {\r\n        *clr = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop;\");\r\n      }\r\n      if (bitMask >>= 1) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      } else {\r\n        if (ptr >= end)\r\n          break;\r\n        p = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz bitstream\r\n    for (;;) {\r\n      *set = pinMask;\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      if (p & bitMask) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop;\");\r\n        *clr = pinMask;\r\n      } else {\r\n        *clr = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop;\");\r\n      }\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      if (bitMask >>= 1) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop;\");\r\n      } else {\r\n        if (ptr >= end)\r\n          break;\r\n        p = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n  }\r\n#endif\r\n\r\n//----\r\n#elif defined(XMC1100_XMC2GO) || defined(XMC1100_H_BRIDGE2GO) || defined(XMC1100_Boot_Kit)  || defined(XMC1300_Boot_Kit)\r\n\r\n  // XMC1100/1200/1300 with ARM Cortex M0 are running with 32MHz, XMC1400 runs with 48MHz so may not work\r\n  // Tried this with a timer/counter, couldn't quite get adequate\r\n  // resolution.  So yay, you get a load of goofball NOPs...\r\n\r\n  uint8_t  *ptr, *end, p, bitMask, portNum;\r\n  uint32_t  pinMask;\r\n\r\n  ptr     =  pixels;\r\n  end     =  ptr + numBytes;\r\n  p       = *ptr++;\r\n  bitMask =  0x80;\r\n\r\n  XMC_GPIO_PORT_t*  XMC_port = mapping_port_pin[ pin ].port;\r\n  uint8_t  XMC_pin           = mapping_port_pin[ pin ].pin;\r\n\r\n\tuint32_t omrhigh = (uint32_t)XMC_GPIO_OUTPUT_LEVEL_HIGH << XMC_pin;\r\n\tuint32_t omrlow  = (uint32_t)XMC_GPIO_OUTPUT_LEVEL_LOW << XMC_pin;\r\n\r\n#ifdef NEO_KHZ400 // 800 KHz check needed only if 400 KHz support enabled\r\n  if(is800KHz) {\r\n#endif\r\n    for(;;) {\r\n\t\t\tXMC_port->OMR = omrhigh;\r\n      asm(\"nop; nop; nop; nop;\");\r\n      if(p & bitMask) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop;\");\r\n\t\t\t  XMC_port->OMR = omrlow;\r\n      } else {\r\n\t\t\t\tXMC_port->OMR = omrlow;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop;\");\r\n      }\r\n      if(bitMask >>= 1) {\r\n        asm(\"nop; nop; nop; nop; nop;\");\r\n      } else {\r\n        if(ptr >= end) break;\r\n        p       = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n#ifdef NEO_KHZ400 // untested code\r\n  } else { // 400 KHz bitstream\r\n    for(;;) {\r\n      XMC_port->OMR = omrhigh;\r\n      asm(\"nop; nop; nop; nop; nop;\");\r\n      if(p & bitMask) {\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop;\");\r\n        XMC_port->OMR = omrlow;\r\n      } else {\r\n        XMC_port->OMR = omrlow;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop;\");\r\n      }\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      if(bitMask >>= 1) {\r\n        asm(\"nop; nop; nop;\");\r\n      } else {\r\n        if(ptr >= end) break;\r\n        p       = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n  }\r\n\r\n#endif\r\n//----\r\n\r\n//----\r\n#elif defined(XMC4700_Relax_Kit) || defined(XMC4800_Relax_Kit)\r\n\r\n// XMC4700 and XMC4800 with ARM Cortex M4 are running with 144MHz\r\n// Tried this with a timer/counter, couldn't quite get adequate\r\n// resolution.  So yay, you get a load of goofball NOPs...\r\n\r\nuint8_t  *ptr, *end, p, bitMask, portNum;\r\nuint32_t  pinMask;\r\n\r\nptr     =  pixels;\r\nend     =  ptr + numBytes;\r\np       = *ptr++;\r\nbitMask =  0x80;\r\n\r\nXMC_GPIO_PORT_t*   XMC_port = mapping_port_pin[ pin ].port;\r\nuint8_t            XMC_pin  = mapping_port_pin[ pin ].pin;\r\n\r\nuint32_t omrhigh = (uint32_t)XMC_GPIO_OUTPUT_LEVEL_HIGH << XMC_pin;\r\nuint32_t omrlow  = (uint32_t)XMC_GPIO_OUTPUT_LEVEL_LOW << XMC_pin;\r\n\r\n#ifdef NEO_KHZ400 // 800 KHz check needed only if 400 KHz support enabled\r\nif(is800KHz) {\r\n#endif\r\n\r\n  for(;;) {\r\n    XMC_port->OMR = omrhigh;\r\n    asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n        \"nop; nop; nop; nop;\");\r\n    if(p & bitMask) {\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n      XMC_port->OMR = omrlow;\r\n    } else {\r\n      XMC_port->OMR = omrlow;\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n    }\r\n    if(bitMask >>= 1) {\r\n      asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n          \"nop; nop; nop; nop; nop; nop; nop; nop;\");\r\n    } else {\r\n      if(ptr >= end) break;\r\n      p       = *ptr++;\r\n      bitMask = 0x80;\r\n    }\r\n  }\r\n\r\n\r\n#ifdef NEO_KHZ400\r\n  } else { // 400 KHz bitstream\r\n    // ToDo!\r\n  }\r\n#endif\r\n//----\r\n\r\n#elif defined(__SAMD51__) // M4\r\n\r\n  uint8_t *ptr, *end, p, bitMask, portNum, bit;\r\n  uint32_t pinMask;\r\n\r\n  portNum = g_APinDescription[pin].ulPort;\r\n  pinMask = 1ul << g_APinDescription[pin].ulPin;\r\n  ptr = pixels;\r\n  end = ptr + numBytes;\r\n  p = *ptr++;\r\n  bitMask = 0x80;\r\n\r\n  volatile uint32_t *set = &(PORT->Group[portNum].OUTSET.reg),\r\n                    *clr = &(PORT->Group[portNum].OUTCLR.reg);\r\n\r\n  // SAMD51 overclock-compatible timing is only a mild abomination.\r\n  // It uses SysTick for a consistent clock reference regardless of\r\n  // optimization / cache settings.  That's the good news.  The bad news,\r\n  // since SysTick->VAL is a volatile type it's slow to access...and then,\r\n  // with the SysTick interval that Arduino sets up (1 ms), this would\r\n  // require a subtract and MOD operation for gauging elapsed time, and\r\n  // all taken in combination that lacks adequate temporal resolution\r\n  // for NeoPixel timing.  So a kind of horrible thing is done here...\r\n  // since interrupts are turned off anyway and it's generally accepted\r\n  // by now that we're gonna lose track of time in the NeoPixel lib,\r\n  // the SysTick timer is reconfigured for a period matching the NeoPixel\r\n  // bit timing (either 800 or 400 KHz) and we watch SysTick->VAL very\r\n  // closely (just a threshold, no subtract or MOD or anything) and that\r\n  // seems to work just well enough.  When finished, the SysTick\r\n  // peripheral is set back to its original state.\r\n\r\n  uint32_t t0, t1, top, ticks, saveLoad = SysTick->LOAD, saveVal = SysTick->VAL;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    top = (uint32_t)(F_CPU * 0.00000125);      // Bit hi + lo = 1.25 uS\r\n    t0 = top - (uint32_t)(F_CPU * 0.00000040); // 0 = 0.4 uS hi\r\n    t1 = top - (uint32_t)(F_CPU * 0.00000080); // 1 = 0.8 uS hi\r\n#if defined(NEO_KHZ400)\r\n  } else {                                     // 400 KHz bitstream\r\n    top = (uint32_t)(F_CPU * 0.00000250);      // Bit hi + lo = 2.5 uS\r\n    t0 = top - (uint32_t)(F_CPU * 0.00000050); // 0 = 0.5 uS hi\r\n    t1 = top - (uint32_t)(F_CPU * 0.00000120); // 1 = 1.2 uS hi\r\n  }\r\n#endif\r\n\r\n  SysTick->LOAD = top; // Config SysTick for NeoPixel bit freq\r\n  SysTick->VAL = top;  // Set to start value (counts down)\r\n  (void)SysTick->VAL;  // Dummy read helps sync up 1st bit\r\n\r\n  for (;;) {\r\n    *set = pinMask;                  // Set output high\r\n    ticks = (p & bitMask) ? t1 : t0; // SysTick threshold,\r\n    while (SysTick->VAL > ticks)\r\n      ;                     // wait for it\r\n    *clr = pinMask;         // Set output low\r\n    if (!(bitMask >>= 1)) { // Next bit for this byte...done?\r\n      if (ptr >= end)\r\n        break;        // If last byte sent, exit loop\r\n      p = *ptr++;     // Fetch next byte\r\n      bitMask = 0x80; // Reset bitmask\r\n    }\r\n    while (SysTick->VAL <= ticks)\r\n      ; // Wait for rollover to 'top'\r\n  }\r\n\r\n  SysTick->LOAD = saveLoad; // Restore SysTick rollover to 1 ms\r\n  SysTick->VAL = saveVal;   // Restore SysTick value\r\n\r\n#elif defined(ARDUINO_STM32_FEATHER) // FEATHER WICED (120MHz)\r\n\r\n  // Tried this with a timer/counter, couldn't quite get adequate\r\n  // resolution. So yay, you get a load of goofball NOPs...\r\n\r\n  uint8_t *ptr, *end, p, bitMask;\r\n  uint32_t pinMask;\r\n\r\n  pinMask = BIT(PIN_MAP[pin].gpio_bit);\r\n  ptr = pixels;\r\n  end = ptr + numBytes;\r\n  p = *ptr++;\r\n  bitMask = 0x80;\r\n\r\n  volatile uint16_t *set = &(PIN_MAP[pin].gpio_device->regs->BSRRL);\r\n  volatile uint16_t *clr = &(PIN_MAP[pin].gpio_device->regs->BSRRH);\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    for (;;) {\r\n      if (p & bitMask) { // ONE\r\n        // High 800ns\r\n        *set = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop;\");\r\n        // Low 450ns\r\n        *clr = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop;\");\r\n      } else { // ZERO\r\n        // High 400ns\r\n        *set = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop;\");\r\n        // Low 850ns\r\n        *clr = pinMask;\r\n        asm(\"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop; nop; nop; nop; nop;\"\r\n            \"nop; nop; nop; nop;\");\r\n      }\r\n      if (bitMask >>= 1) {\r\n        // Move on to the next pixel\r\n        asm(\"nop;\");\r\n      } else {\r\n        if (ptr >= end)\r\n          break;\r\n        p = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz bitstream\r\n    // ToDo!\r\n  }\r\n#endif\r\n\r\n#elif defined(TARGET_LPC1768)\r\n  uint8_t *ptr, *end, p, bitMask;\r\n  ptr = pixels;\r\n  end = ptr + numBytes;\r\n  p = *ptr++;\r\n  bitMask = 0x80;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    for (;;) {\r\n      if (p & bitMask) {\r\n        // data ONE high\r\n        // min: 550 typ: 700 max: 5,500\r\n        gpio_set(pin);\r\n        time::delay_ns(550);\r\n        // min: 450 typ: 600 max: 5,000\r\n        gpio_clear(pin);\r\n        time::delay_ns(450);\r\n      } else {\r\n        // data ZERO high\r\n        // min: 200  typ: 350 max: 500\r\n        gpio_set(pin);\r\n        time::delay_ns(200);\r\n        // data low\r\n        // min: 450 typ: 600 max: 5,000\r\n        gpio_clear(pin);\r\n        time::delay_ns(450);\r\n      }\r\n      if (bitMask >>= 1) {\r\n        // Move on to the next pixel\r\n        asm(\"nop;\");\r\n      } else {\r\n        if (ptr >= end)\r\n          break;\r\n        p = *ptr++;\r\n        bitMask = 0x80;\r\n      }\r\n    }\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz bitstream\r\n    // ToDo!\r\n  }\r\n#endif\r\n#elif defined(ARDUINO_ARCH_STM32) || defined(ARDUINO_ARCH_ARDUINO_CORE_STM32)\r\n  uint8_t *p = pixels, *end = p + numBytes, pix = *p++, mask = 0x80;\r\n  uint32_t cyc;\r\n  uint32_t saveLoad = SysTick->LOAD, saveVal = SysTick->VAL;\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    uint32_t top = (F_CPU / 800000);       // 1.25s\r\n    uint32_t t0 = top - (F_CPU / 2500000); // 0.4s\r\n    uint32_t t1 = top - (F_CPU / 1250000); // 0.8s\r\n    SysTick->LOAD = top - 1; // Config SysTick for NeoPixel bit freq\r\n    SysTick->VAL = 0;        // Set to start value\r\n    for (;;) {\r\n      LL_GPIO_SetOutputPin(gpioPort, gpioPin);\r\n      cyc = (pix & mask) ? t1 : t0;\r\n      while (SysTick->VAL > cyc)\r\n        ;\r\n      LL_GPIO_ResetOutputPin(gpioPort, gpioPin);\r\n      if (!(mask >>= 1)) {\r\n        if (p >= end)\r\n          break;\r\n        pix = *p++;\r\n        mask = 0x80;\r\n      }\r\n      while (SysTick->VAL <= cyc)\r\n        ;\r\n    }\r\n#if defined(NEO_KHZ400)\r\n  } else {                                 // 400 kHz bitstream\r\n    uint32_t top = (F_CPU / 400000);       // 2.5s\r\n    uint32_t t0 = top - (F_CPU / 2000000); // 0.5s\r\n    uint32_t t1 = top - (F_CPU / 833333);  // 1.2s\r\n    SysTick->LOAD = top - 1; // Config SysTick for NeoPixel bit freq\r\n    SysTick->VAL = 0;        // Set to start value\r\n    for (;;) {\r\n      LL_GPIO_SetOutputPin(gpioPort, gpioPin);\r\n      cyc = (pix & mask) ? t1 : t0;\r\n      while (SysTick->VAL > cyc)\r\n        ;\r\n      LL_GPIO_ResetOutputPin(gpioPort, gpioPin);\r\n      if (!(mask >>= 1)) {\r\n        if (p >= end)\r\n          break;\r\n        pix = *p++;\r\n        mask = 0x80;\r\n      }\r\n      while (SysTick->VAL <= cyc)\r\n        ;\r\n    }\r\n  }\r\n#endif // NEO_KHZ400\r\n  SysTick->LOAD = saveLoad; // Restore SysTick rollover to 1 ms\r\n  SysTick->VAL = saveVal;   // Restore SysTick value\r\n#elif defined(NRF51)\r\n  uint8_t *p = pixels, pix, count, mask;\r\n  int32_t num = numBytes;\r\n  unsigned int bitmask = (1 << g_ADigitalPinMap[pin]);\r\n  // https://github.com/sandeepmistry/arduino-nRF5/blob/dc53980c8bac27898fca90d8ecb268e11111edc1/variants/BBCmicrobit/variant.cpp\r\n\r\n  volatile unsigned int *reg = (unsigned int *)(0x50000000UL + 0x508);\r\n\r\n  // https://github.com/sandeepmistry/arduino-nRF5/blob/dc53980c8bac27898fca90d8ecb268e11111edc1/cores/nRF5/SDK/components/device/nrf51.h\r\n  // http://www.iot-programmer.com/index.php/books/27-micro-bit-iot-in-c/chapters-micro-bit-iot-in-c/47-micro-bit-iot-in-c-fast-memory-mapped-gpio?showall=1\r\n  // https://github.com/Microsoft/pxt-neopixel/blob/master/sendbuffer.asm\r\n\r\n  asm volatile(\r\n      // \"cpsid i\" ; disable irq\r\n\r\n      //    b .start\r\n      \"b  L%=_start\"\r\n      \"\\n\\t\"\r\n      // .nextbit:               ;            C0\r\n      \"L%=_nextbit:\"\r\n      \"\\n\\t\" //;            C0\r\n      //    str r1, [r3, #0]    ; pin := hi  C2\r\n      \"strb %[bitmask], [%[reg], #0]\"\r\n      \"\\n\\t\" //; pin := hi  C2\r\n      //    tst r6, r0          ;            C3\r\n      \"tst %[mask], %[pix]\"\r\n      \"\\n\\t\" //          ;            C3\r\n      //    bne .islate         ;            C4\r\n      \"bne L%=_islate\"\r\n      \"\\n\\t\" //;            C4\r\n      //    str r1, [r2, #0]    ; pin := lo  C6\r\n      \"strb %[bitmask], [%[reg], #4]\"\r\n      \"\\n\\t\" //; pin := lo  C6\r\n      // .islate:\r\n      \"L%=_islate:\"\r\n      \"\\n\\t\"\r\n      //    lsrs r6, r6, #1     ; r6 >>= 1   C7\r\n      \"lsr %[mask], %[mask], #1\"\r\n      \"\\n\\t\" //; r6 >>= 1   C7\r\n      //    bne .justbit        ;            C8\r\n      \"bne L%=_justbit\"\r\n      \"\\n\\t\" //;            C8\r\n\r\n      //    ; not just a bit - need new byte\r\n      //    adds r4, #1         ; r4++       C9\r\n      \"add %[p], #1\"\r\n      \"\\n\\t\" //; r4++       C9\r\n      //    subs r5, #1         ; r5--       C10\r\n      \"sub %[num], #1\"\r\n      \"\\n\\t\" //; r5--       C10\r\n      //    bcc .stop           ; if (r5<0) goto .stop  C11\r\n      \"bcc L%=_stop\"\r\n      \"\\n\\t\" //; if (r5<0) goto .stop  C11\r\n      // .start:\r\n      \"L%=_start:\"\r\n      //    movs r6, #0x80      ; reset mask C12\r\n      \"movs %[mask], #0x80\"\r\n      \"\\n\\t\" //; reset mask C12\r\n      //    nop                 ;            C13\r\n      \"nop\"\r\n      \"\\n\\t\" //;            C13\r\n\r\n      // .common:               ;             C13\r\n      \"L%=_common:\"\r\n      \"\\n\\t\" //;            C13\r\n      //    str r1, [r2, #0]   ; pin := lo   C15\r\n      \"strb %[bitmask], [%[reg], #4]\"\r\n      \"\\n\\t\" //; pin := lo  C15\r\n      //    ; always re-load byte - it just fits with the cycles better this way\r\n      //    ldrb r0, [r4, #0]  ; r0 := *r4   C17\r\n      \"ldrb  %[pix], [%[p], #0]\"\r\n      \"\\n\\t\" //; r0 := *r4   C17\r\n      //    b .nextbit         ;             C20\r\n      \"b L%=_nextbit\"\r\n      \"\\n\\t\" //;             C20\r\n\r\n      // .justbit: ; C10\r\n      \"L%=_justbit:\"\r\n      \"\\n\\t\" //; C10\r\n      //    ; no nops, branch taken is already 3 cycles\r\n      //    b .common ; C13\r\n      \"b L%=_common\"\r\n      \"\\n\\t\" //; C13\r\n\r\n      // .stop:\r\n      \"L%=_stop:\"\r\n      \"\\n\\t\"\r\n      //    str r1, [r2, #0]   ; pin := lo\r\n      \"strb %[bitmask], [%[reg], #4]\"\r\n      \"\\n\\t\" //; pin := lo\r\n      //    cpsie i            ; enable irq\r\n\r\n      : [p] \"+r\"(p), [pix] \"=&r\"(pix), [count] \"=&r\"(count), [mask] \"=&r\"(mask),\r\n        [num] \"+r\"(num)\r\n      : [bitmask] \"r\"(bitmask), [reg] \"r\"(reg));\r\n\r\n#elif defined(__SAM3X8E__) // Arduino Due\r\n\r\n#define SCALE VARIANT_MCK / 2UL / 1000000UL\r\n#define INST (2UL * F_CPU / VARIANT_MCK)\r\n#define TIME_800_0 ((int)(0.40 * SCALE + 0.5) - (5 * INST))\r\n#define TIME_800_1 ((int)(0.80 * SCALE + 0.5) - (5 * INST))\r\n#define PERIOD_800 ((int)(1.25 * SCALE + 0.5) - (5 * INST))\r\n#define TIME_400_0 ((int)(0.50 * SCALE + 0.5) - (5 * INST))\r\n#define TIME_400_1 ((int)(1.20 * SCALE + 0.5) - (5 * INST))\r\n#define PERIOD_400 ((int)(2.50 * SCALE + 0.5) - (5 * INST))\r\n\r\n  int pinMask, time0, time1, period, t;\r\n  Pio *port;\r\n  volatile WoReg *portSet, *portClear, *timeValue, *timeReset;\r\n  uint8_t *p, *end, pix, mask;\r\n\r\n  pmc_set_writeprotect(false);\r\n  pmc_enable_periph_clk((uint32_t)TC3_IRQn);\r\n  TC_Configure(TC1, 0,\r\n               TC_CMR_WAVE | TC_CMR_WAVSEL_UP | TC_CMR_TCCLKS_TIMER_CLOCK1);\r\n  TC_Start(TC1, 0);\r\n\r\n  pinMask = g_APinDescription[pin].ulPin;  // Don't 'optimize' these into\r\n  port = g_APinDescription[pin].pPort;     // declarations above. Want to\r\n  portSet = &(port->PIO_SODR);             // burn a few cycles after\r\n  portClear = &(port->PIO_CODR);           // starting timer to minimize\r\n  timeValue = &(TC1->TC_CHANNEL[0].TC_CV); // the initial 'while'.\r\n  timeReset = &(TC1->TC_CHANNEL[0].TC_CCR);\r\n  p = pixels;\r\n  end = p + numBytes;\r\n  pix = *p++;\r\n  mask = 0x80;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    time0 = TIME_800_0;\r\n    time1 = TIME_800_1;\r\n    period = PERIOD_800;\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 KHz bitstream\r\n    time0 = TIME_400_0;\r\n    time1 = TIME_400_1;\r\n    period = PERIOD_400;\r\n  }\r\n#endif\r\n\r\n  for (t = time0;; t = time0) {\r\n    if (pix & mask)\r\n      t = time1;\r\n    while (*timeValue < (unsigned)period)\r\n      ;\r\n    *portSet = pinMask;\r\n    *timeReset = TC_CCR_CLKEN | TC_CCR_SWTRG;\r\n    while (*timeValue < (unsigned)t)\r\n      ;\r\n    *portClear = pinMask;\r\n    if (!(mask >>= 1)) { // This 'inside-out' loop logic utilizes\r\n      if (p >= end)\r\n        break; // idle time to minimize inter-byte delays.\r\n      pix = *p++;\r\n      mask = 0x80;\r\n    }\r\n  }\r\n  while (*timeValue < (unsigned)period)\r\n    ; // Wait for last bit\r\n  TC_Stop(TC1, 0);\r\n\r\n\r\n// RENESAS including UNO R4\r\n#elif defined(ARDUINO_ARCH_RENESAS) || defined(ARDUINO_ARCH_RENESAS_UNO) || defined(ARDUINO_ARCH_RENESAS_PORTENTA)\r\n\r\n// Definition for a single channel clockless controller for RA4M1 (Cortex M4)\r\n// See clockless.h for detailed info on how the template parameters are used.\r\n#define ARM_DEMCR               (*(volatile uint32_t *)0xE000EDFC) // Debug Exception and Monitor Control\r\n#define ARM_DEMCR_TRCENA                (1 << 24)        // Enable debugging & monitoring blocks\r\n#define ARM_DWT_CTRL            (*(volatile uint32_t *)0xE0001000) // DWT control register\r\n#define ARM_DWT_CTRL_CYCCNTENA          (1 << 0)                // Enable cycle count\r\n#define ARM_DWT_CYCCNT          (*(volatile uint32_t *)0xE0001004) // Cycle count register\r\n\r\n#define F_CPU 48000000\r\n#define CYCLES_800_T0H (F_CPU / 4000000)\r\n#define CYCLES_800_T1H (F_CPU / 1250000)\r\n#define CYCLES_800 (F_CPU / 800000)\r\n#define CYCLES_400_T0H (F_CPU / 2000000)\r\n#define CYCLES_400_T1H (F_CPU / 833333)\r\n#define CYCLES_400 (F_CPU / 400000)\r\n\r\n  uint8_t *p = pixels, *end = p + numBytes, pix, mask;\r\n\r\n  bsp_io_port_pin_t io_pin = g_pin_cfg[pin].pin;\r\n  #define PIN_IO_PORT_ADDR(pn)      (R_PORT0 + ((uint32_t) (R_PORT1 - R_PORT0) * ((pn) >> 8u)))\r\n\r\n  volatile uint16_t *set = &(PIN_IO_PORT_ADDR(io_pin)->POSR);\r\n  volatile uint16_t *clr = &(PIN_IO_PORT_ADDR(io_pin)->PORR);\r\n  uint16_t msk = (1U << (io_pin & 0xFF));\r\n\r\n  uint32_t cyc;\r\n\r\n  ARM_DEMCR |= ARM_DEMCR_TRCENA;\r\n  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;\r\n\r\n#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled\r\n  if (is800KHz) {\r\n#endif\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_800;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = msk;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_800_T0H)\r\n            ;\r\n        }\r\n        *clr = msk;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_800)\r\n      ;\r\n#if defined(NEO_KHZ400)\r\n  } else { // 400 kHz bitstream\r\n    cyc = ARM_DWT_CYCCNT + CYCLES_400;\r\n    while (p < end) {\r\n      pix = *p++;\r\n      for (mask = 0x80; mask; mask >>= 1) {\r\n        while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n          ;\r\n        cyc = ARM_DWT_CYCCNT;\r\n        *set = msk;\r\n        if (pix & mask) {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T1H)\r\n            ;\r\n        } else {\r\n          while (ARM_DWT_CYCCNT - cyc < CYCLES_400_T0H)\r\n            ;\r\n        }\r\n        *clr = msk;\r\n      }\r\n    }\r\n    while (ARM_DWT_CYCCNT - cyc < CYCLES_400)\r\n      ;\r\n  }\r\n#endif // NEO_KHZ400\r\n\r\n#endif // ARM\r\n\r\n  // END ARM ----------------------------------------------------------------\r\n\r\n#elif defined(ESP8266) || defined(ESP32)\r\n\r\n  // ESP8266 ----------------------------------------------------------------\r\n\r\n  // ESP8266 show() is external to enforce ICACHE_RAM_ATTR execution\r\n  espShow(pin, pixels, numBytes, is800KHz);\r\n\r\n#elif defined(KENDRYTE_K210)\r\n\r\n  k210Show(pin, pixels, numBytes, is800KHz);\r\n\r\n#elif defined(__ARDUINO_ARC__)\r\n\r\n    // Arduino 101  -----------------------------------------------------------\r\n\r\n#define NOPx7                                                                  \\\r\n  {                                                                            \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n    __builtin_arc_nop();                                                       \\\r\n  }\r\n\r\n  PinDescription *pindesc = &g_APinDescription[pin];\r\n  register uint32_t loop =\r\n      8 * numBytes; // one loop to handle all bytes and all bits\r\n  register uint8_t *p = pixels;\r\n  register uint32_t currByte = (uint32_t)(*p);\r\n  register uint32_t currBit = 0x80 & currByte;\r\n  register uint32_t bitCounter = 0;\r\n  register uint32_t first = 1;\r\n\r\n  // The loop is unusual. Very first iteration puts all the way LOW to the wire\r\n  // - constant LOW does not affect NEOPIXEL, so there is no visible effect\r\n  // displayed. During that very first iteration CPU caches instructions in the\r\n  // loop. Because of the caching process, \"CPU slows down\". NEOPIXEL pulse is\r\n  // very time sensitive that's why we let the CPU cache first and we start\r\n  // regular pulse from 2nd iteration\r\n  if (pindesc->ulGPIOType == SS_GPIO) {\r\n    register uint32_t reg = pindesc->ulGPIOBase + SS_GPIO_SWPORTA_DR;\r\n    uint32_t reg_val = __builtin_arc_lr((volatile uint32_t)reg);\r\n    register uint32_t reg_bit_high = reg_val | (1 << pindesc->ulGPIOId);\r\n    register uint32_t reg_bit_low = reg_val & ~(1 << pindesc->ulGPIOId);\r\n\r\n    loop += 1; // include first, special iteration\r\n    while (loop--) {\r\n      if (!first) {\r\n        currByte <<= 1;\r\n        bitCounter++;\r\n      }\r\n\r\n      // 1 is >550ns high and >450ns low; 0 is 200..500ns high and >450ns low\r\n      __builtin_arc_sr(first ? reg_bit_low : reg_bit_high,\r\n                       (volatile uint32_t)reg);\r\n      if (currBit) { // ~400ns HIGH (740ns overall)\r\n        NOPx7 NOPx7\r\n      }\r\n      // ~340ns HIGH\r\n      NOPx7 __builtin_arc_nop();\r\n\r\n      // 820ns LOW; per spec, max allowed low here is 5000ns */\r\n      __builtin_arc_sr(reg_bit_low, (volatile uint32_t)reg);\r\n      NOPx7 NOPx7\r\n\r\n          if (bitCounter >= 8) {\r\n        bitCounter = 0;\r\n        currByte = (uint32_t)(*++p);\r\n      }\r\n\r\n      currBit = 0x80 & currByte;\r\n      first = 0;\r\n    }\r\n  } else if (pindesc->ulGPIOType == SOC_GPIO) {\r\n    register uint32_t reg = pindesc->ulGPIOBase + SOC_GPIO_SWPORTA_DR;\r\n    uint32_t reg_val = MMIO_REG_VAL(reg);\r\n    register uint32_t reg_bit_high = reg_val | (1 << pindesc->ulGPIOId);\r\n    register uint32_t reg_bit_low = reg_val & ~(1 << pindesc->ulGPIOId);\r\n\r\n    loop += 1; // include first, special iteration\r\n    while (loop--) {\r\n      if (!first) {\r\n        currByte <<= 1;\r\n        bitCounter++;\r\n      }\r\n      MMIO_REG_VAL(reg) = first ? reg_bit_low : reg_bit_high;\r\n      if (currBit) { // ~430ns HIGH (740ns overall)\r\n        NOPx7 NOPx7 __builtin_arc_nop();\r\n      }\r\n      // ~310ns HIGH\r\n      NOPx7\r\n\r\n          // 850ns LOW; per spec, max allowed low here is 5000ns */\r\n          MMIO_REG_VAL(reg) = reg_bit_low;\r\n      NOPx7 NOPx7\r\n\r\n          if (bitCounter >= 8) {\r\n        bitCounter = 0;\r\n        currByte = (uint32_t)(*++p);\r\n      }\r\n\r\n      currBit = 0x80 & currByte;\r\n      first = 0;\r\n    }\r\n  }\r\n\r\n#elif defined(ARDUINO_ARCH_CH32)\r\n  ch32Show(gpioPort, gpioPin, pixels, numBytes, is800KHz);\r\n#else\r\n#error Architecture not supported\r\n#endif\r\n\r\n  // END ARCHITECTURE SELECT ------------------------------------------------\r\n\r\n#if !(defined(NRF52) || defined(NRF52_SERIES) || defined(ESP32))\r\n  interrupts();\r\n#endif\r\n\r\n  endTime = micros(); // Save EOD time for latch on next call\r\n}\r\n\r\n/*!\r\n  @brief   Set/change the NeoPixel output pin number. Previous pin,\r\n           if any, is set to INPUT and the new pin is set to OUTPUT.\r\n  @param   p  Arduino pin number (-1 = no pin).\r\n*/\r\nvoid Adafruit_NeoPixel::setPin(int16_t p) {\r\n  if (begun && (pin >= 0))\r\n    pinMode(pin, INPUT); // Disable existing out pin\r\n  pin = p;\r\n  if (begun) {\r\n    pinMode(p, OUTPUT);\r\n    digitalWrite(p, LOW);\r\n  }\r\n#if defined(__AVR__)\r\n  port = portOutputRegister(digitalPinToPort(p));\r\n  pinMask = digitalPinToBitMask(p);\r\n#endif\r\n#if defined(ARDUINO_ARCH_STM32) || defined(ARDUINO_ARCH_ARDUINO_CORE_STM32)\r\n  gpioPort = digitalPinToPort(p);\r\n  gpioPin = STM_LL_GPIO_PIN(digitalPinToPinName(p));\r\n#elif defined(ARDUINO_ARCH_CH32)\r\n  PinName const pin_name = digitalPinToPinName(pin);\r\n  gpioPort = get_GPIO_Port(CH_PORT(pin_name));\r\n  gpioPin = CH_GPIO_PIN(pin_name);\r\n  #if defined (CH32V20x_D6)\r\n  if (gpioPort == GPIOC && ((*(volatile uint32_t*)0x40022030) & 0x0F000000) == 0) {\r\n    gpioPin = gpioPin >> 13;\r\n  }\r\n  #endif\r\n#endif\r\n}\r\n\r\n/*!\r\n  @brief   Set a pixel's color using separate red, green and blue\r\n           components. If using RGBW pixels, white will be set to 0.\r\n  @param   n  Pixel index, starting from 0.\r\n  @param   r  Red brightness, 0 = minimum (off), 255 = maximum.\r\n  @param   g  Green brightness, 0 = minimum (off), 255 = maximum.\r\n  @param   b  Blue brightness, 0 = minimum (off), 255 = maximum.\r\n*/\r\nvoid Adafruit_NeoPixel::setPixelColor(uint16_t n, uint8_t r, uint8_t g,\r\n                                      uint8_t b) {\r\n\r\n  if (n < numLEDs) {\r\n    if (brightness) { // See notes in setBrightness()\r\n      r = (r * brightness) >> 8;\r\n      g = (g * brightness) >> 8;\r\n      b = (b * brightness) >> 8;\r\n    }\r\n    uint8_t *p;\r\n    if (wOffset == rOffset) { // Is an RGB-type strip\r\n      p = &pixels[n * 3];     // 3 bytes per pixel\r\n    } else {                  // Is a WRGB-type strip\r\n      p = &pixels[n * 4];     // 4 bytes per pixel\r\n      p[wOffset] = 0;         // But only R,G,B passed -- set W to 0\r\n    }\r\n    p[rOffset] = r; // R,G,B always stored\r\n    p[gOffset] = g;\r\n    p[bOffset] = b;\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Set a pixel's color using separate red, green, blue and white\r\n           components (for RGBW NeoPixels only).\r\n  @param   n  Pixel index, starting from 0.\r\n  @param   r  Red brightness, 0 = minimum (off), 255 = maximum.\r\n  @param   g  Green brightness, 0 = minimum (off), 255 = maximum.\r\n  @param   b  Blue brightness, 0 = minimum (off), 255 = maximum.\r\n  @param   w  White brightness, 0 = minimum (off), 255 = maximum, ignored\r\n              if using RGB pixels.\r\n*/\r\nvoid Adafruit_NeoPixel::setPixelColor(uint16_t n, uint8_t r, uint8_t g,\r\n                                      uint8_t b, uint8_t w) {\r\n\r\n  if (n < numLEDs) {\r\n    if (brightness) { // See notes in setBrightness()\r\n      r = (r * brightness) >> 8;\r\n      g = (g * brightness) >> 8;\r\n      b = (b * brightness) >> 8;\r\n      w = (w * brightness) >> 8;\r\n    }\r\n    uint8_t *p;\r\n    if (wOffset == rOffset) { // Is an RGB-type strip\r\n      p = &pixels[n * 3];     // 3 bytes per pixel (ignore W)\r\n    } else {                  // Is a WRGB-type strip\r\n      p = &pixels[n * 4];     // 4 bytes per pixel\r\n      p[wOffset] = w;         // Store W\r\n    }\r\n    p[rOffset] = r; // Store R,G,B\r\n    p[gOffset] = g;\r\n    p[bOffset] = b;\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Set a pixel's color using a 32-bit 'packed' RGB or RGBW value.\r\n  @param   n  Pixel index, starting from 0.\r\n  @param   c  32-bit color value. Most significant byte is white (for RGBW\r\n              pixels) or ignored (for RGB pixels), next is red, then green,\r\n              and least significant byte is blue.\r\n*/\r\nvoid Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {\r\n  if (n < numLEDs) {\r\n    uint8_t *p, r = (uint8_t)(c >> 16), g = (uint8_t)(c >> 8), b = (uint8_t)c;\r\n    if (brightness) { // See notes in setBrightness()\r\n      r = (r * brightness) >> 8;\r\n      g = (g * brightness) >> 8;\r\n      b = (b * brightness) >> 8;\r\n    }\r\n    if (wOffset == rOffset) {\r\n      p = &pixels[n * 3];\r\n    } else {\r\n      p = &pixels[n * 4];\r\n      uint8_t w = (uint8_t)(c >> 24);\r\n      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;\r\n    }\r\n    p[rOffset] = r;\r\n    p[gOffset] = g;\r\n    p[bOffset] = b;\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Fill all or part of the NeoPixel strip with a color.\r\n  @param   c      32-bit color value. Most significant byte is white (for\r\n                  RGBW pixels) or ignored (for RGB pixels), next is red,\r\n                  then green, and least significant byte is blue. If all\r\n                  arguments are unspecified, this will be 0 (off).\r\n  @param   first  Index of first pixel to fill, starting from 0. Must be\r\n                  in-bounds, no clipping is performed. 0 if unspecified.\r\n  @param   count  Number of pixels to fill, as a positive value. Passing\r\n                  0 or leaving unspecified will fill to end of strip.\r\n*/\r\nvoid Adafruit_NeoPixel::fill(uint32_t c, uint16_t first, uint16_t count) {\r\n  uint16_t i, end;\r\n\r\n  if (first >= numLEDs) {\r\n    return; // If first LED is past end of strip, nothing to do\r\n  }\r\n\r\n  // Calculate the index ONE AFTER the last pixel to fill\r\n  if (count == 0) {\r\n    // Fill to end of strip\r\n    end = numLEDs;\r\n  } else {\r\n    // Ensure that the loop won't go past the last pixel\r\n    end = first + count;\r\n    if (end > numLEDs)\r\n      end = numLEDs;\r\n  }\r\n\r\n  for (i = first; i < end; i++) {\r\n    this->setPixelColor(i, c);\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Convert hue, saturation and value into a packed 32-bit RGB color\r\n           that can be passed to setPixelColor() or other RGB-compatible\r\n           functions.\r\n  @param   hue  An unsigned 16-bit value, 0 to 65535, representing one full\r\n                loop of the color wheel, which allows 16-bit hues to \"roll\r\n                over\" while still doing the expected thing (and allowing\r\n                more precision than the wheel() function that was common to\r\n                prior NeoPixel examples).\r\n  @param   sat  Saturation, 8-bit value, 0 (min or pure grayscale) to 255\r\n                (max or pure hue). Default of 255 if unspecified.\r\n  @param   val  Value (brightness), 8-bit value, 0 (min / black / off) to\r\n                255 (max or full brightness). Default of 255 if unspecified.\r\n  @return  Packed 32-bit RGB with the most significant byte set to 0 -- the\r\n           white element of WRGB pixels is NOT utilized. Result is linearly\r\n           but not perceptually correct, so you may want to pass the result\r\n           through the gamma32() function (or your own gamma-correction\r\n           operation) else colors may appear washed out. This is not done\r\n           automatically by this function because coders may desire a more\r\n           refined gamma-correction function than the simplified\r\n           one-size-fits-all operation of gamma32(). Diffusing the LEDs also\r\n           really seems to help when using low-saturation colors.\r\n*/\r\nuint32_t Adafruit_NeoPixel::ColorHSV(uint16_t hue, uint8_t sat, uint8_t val) {\r\n\r\n  uint8_t r, g, b;\r\n\r\n  // Remap 0-65535 to 0-1529. Pure red is CENTERED on the 64K rollover;\r\n  // 0 is not the start of pure red, but the midpoint...a few values above\r\n  // zero and a few below 65536 all yield pure red (similarly, 32768 is the\r\n  // midpoint, not start, of pure cyan). The 8-bit RGB hexcone (256 values\r\n  // each for red, green, blue) really only allows for 1530 distinct hues\r\n  // (not 1536, more on that below), but the full unsigned 16-bit type was\r\n  // chosen for hue so that one's code can easily handle a contiguous color\r\n  // wheel by allowing hue to roll over in either direction.\r\n  hue = (hue * 1530L + 32768) / 65536;\r\n  // Because red is centered on the rollover point (the +32768 above,\r\n  // essentially a fixed-point +0.5), the above actually yields 0 to 1530,\r\n  // where 0 and 1530 would yield the same thing. Rather than apply a\r\n  // costly modulo operator, 1530 is handled as a special case below.\r\n\r\n  // So you'd think that the color \"hexcone\" (the thing that ramps from\r\n  // pure red, to pure yellow, to pure green and so forth back to red,\r\n  // yielding six slices), and with each color component having 256\r\n  // possible values (0-255), might have 1536 possible items (6*256),\r\n  // but in reality there's 1530. This is because the last element in\r\n  // each 256-element slice is equal to the first element of the next\r\n  // slice, and keeping those in there this would create small\r\n  // discontinuities in the color wheel. So the last element of each\r\n  // slice is dropped...we regard only elements 0-254, with item 255\r\n  // being picked up as element 0 of the next slice. Like this:\r\n  // Red to not-quite-pure-yellow is:        255,   0, 0 to 255, 254,   0\r\n  // Pure yellow to not-quite-pure-green is: 255, 255, 0 to   1, 255,   0\r\n  // Pure green to not-quite-pure-cyan is:     0, 255, 0 to   0, 255, 254\r\n  // and so forth. Hence, 1530 distinct hues (0 to 1529), and hence why\r\n  // the constants below are not the multiples of 256 you might expect.\r\n\r\n  // Convert hue to R,G,B (nested ifs faster than divide+mod+switch):\r\n  if (hue < 510) { // Red to Green-1\r\n    b = 0;\r\n    if (hue < 255) { //   Red to Yellow-1\r\n      r = 255;\r\n      g = hue;       //     g = 0 to 254\r\n    } else {         //   Yellow to Green-1\r\n      r = 510 - hue; //     r = 255 to 1\r\n      g = 255;\r\n    }\r\n  } else if (hue < 1020) { // Green to Blue-1\r\n    r = 0;\r\n    if (hue < 765) { //   Green to Cyan-1\r\n      g = 255;\r\n      b = hue - 510;  //     b = 0 to 254\r\n    } else {          //   Cyan to Blue-1\r\n      g = 1020 - hue; //     g = 255 to 1\r\n      b = 255;\r\n    }\r\n  } else if (hue < 1530) { // Blue to Red-1\r\n    g = 0;\r\n    if (hue < 1275) { //   Blue to Magenta-1\r\n      r = hue - 1020; //     r = 0 to 254\r\n      b = 255;\r\n    } else { //   Magenta to Red-1\r\n      r = 255;\r\n      b = 1530 - hue; //     b = 255 to 1\r\n    }\r\n  } else { // Last 0.5 Red (quicker than % operator)\r\n    r = 255;\r\n    g = b = 0;\r\n  }\r\n\r\n  // Apply saturation and value to R,G,B, pack into 32-bit result:\r\n  uint32_t v1 = 1 + val;  // 1 to 256; allows >>8 instead of /255\r\n  uint16_t s1 = 1 + sat;  // 1 to 256; same reason\r\n  uint8_t s2 = 255 - sat; // 255 to 0\r\n  return ((((((r * s1) >> 8) + s2) * v1) & 0xff00) << 8) |\r\n         (((((g * s1) >> 8) + s2) * v1) & 0xff00) |\r\n         (((((b * s1) >> 8) + s2) * v1) >> 8);\r\n}\r\n\r\n/*!\r\n  @brief   Query the color of a previously-set pixel.\r\n  @param   n  Index of pixel to read (0 = first).\r\n  @return  'Packed' 32-bit RGB or WRGB value. Most significant byte is white\r\n           (for RGBW pixels) or 0 (for RGB pixels), next is red, then green,\r\n           and least significant byte is blue.\r\n  @note    If the strip brightness has been changed from the default value\r\n           of 255, the color read from a pixel may not exactly match what\r\n           was previously written with one of the setPixelColor() functions.\r\n           This gets more pronounced at lower brightness levels.\r\n*/\r\nuint32_t Adafruit_NeoPixel::getPixelColor(uint16_t n) const {\r\n  if (n >= numLEDs)\r\n    return 0; // Out of bounds, return no color.\r\n\r\n  uint8_t *p;\r\n\r\n  if (wOffset == rOffset) { // Is RGB-type device\r\n    p = &pixels[n * 3];\r\n    if (brightness) {\r\n      // Stored color was decimated by setBrightness(). Returned value\r\n      // attempts to scale back to an approximation of the original 24-bit\r\n      // value used when setting the pixel color, but there will always be\r\n      // some error -- those bits are simply gone. Issue is most\r\n      // pronounced at low brightness levels.\r\n      return (((uint32_t)(p[rOffset] << 8) / brightness) << 16) |\r\n             (((uint32_t)(p[gOffset] << 8) / brightness) << 8) |\r\n             ((uint32_t)(p[bOffset] << 8) / brightness);\r\n    } else {\r\n      // No brightness adjustment has been made -- return 'raw' color\r\n      return ((uint32_t)p[rOffset] << 16) | ((uint32_t)p[gOffset] << 8) |\r\n             (uint32_t)p[bOffset];\r\n    }\r\n  } else { // Is RGBW-type device\r\n    p = &pixels[n * 4];\r\n    if (brightness) { // Return scaled color\r\n      return (((uint32_t)(p[wOffset] << 8) / brightness) << 24) |\r\n             (((uint32_t)(p[rOffset] << 8) / brightness) << 16) |\r\n             (((uint32_t)(p[gOffset] << 8) / brightness) << 8) |\r\n             ((uint32_t)(p[bOffset] << 8) / brightness);\r\n    } else { // Return raw color\r\n      return ((uint32_t)p[wOffset] << 24) | ((uint32_t)p[rOffset] << 16) |\r\n             ((uint32_t)p[gOffset] << 8) | (uint32_t)p[bOffset];\r\n    }\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Adjust output brightness. Does not immediately affect what's\r\n           currently displayed on the LEDs. The next call to show() will\r\n           refresh the LEDs at this level.\r\n  @param   b  Brightness setting, 0=minimum (off), 255=brightest.\r\n  @note    This was intended for one-time use in one's setup() function,\r\n           not as an animation effect in itself. Because of the way this\r\n           library \"pre-multiplies\" LED colors in RAM, changing the\r\n           brightness is often a \"lossy\" operation -- what you write to\r\n           pixels isn't necessary the same as what you'll read back.\r\n           Repeated brightness changes using this function exacerbate the\r\n           problem. Smart programs therefore treat the strip as a\r\n           write-only resource, maintaining their own state to render each\r\n           frame of an animation, not relying on read-modify-write.\r\n*/\r\nvoid Adafruit_NeoPixel::setBrightness(uint8_t b) {\r\n  // Stored brightness value is different than what's passed.\r\n  // This simplifies the actual scaling math later, allowing a fast\r\n  // 8x8-bit multiply and taking the MSB. 'brightness' is a uint8_t,\r\n  // adding 1 here may (intentionally) roll over...so 0 = max brightness\r\n  // (color values are interpreted literally; no scaling), 1 = min\r\n  // brightness (off), 255 = just below max brightness.\r\n  uint8_t newBrightness = b + 1;\r\n  if (newBrightness != brightness) { // Compare against prior value\r\n    // Brightness has changed -- re-scale existing data in RAM,\r\n    // This process is potentially \"lossy,\" especially when increasing\r\n    // brightness. The tight timing in the WS2811/WS2812 code means there\r\n    // aren't enough free cycles to perform this scaling on the fly as data\r\n    // is issued. So we make a pass through the existing color data in RAM\r\n    // and scale it (subsequent graphics commands also work at this\r\n    // brightness level). If there's a significant step up in brightness,\r\n    // the limited number of steps (quantization) in the old data will be\r\n    // quite visible in the re-scaled version. For a non-destructive\r\n    // change, you'll need to re-render the full strip data. C'est la vie.\r\n    uint8_t c, *ptr = pixels,\r\n               oldBrightness = brightness - 1; // De-wrap old brightness value\r\n    uint16_t scale;\r\n    if (oldBrightness == 0)\r\n      scale = 0; // Avoid /0\r\n    else if (b == 255)\r\n      scale = 65535 / oldBrightness;\r\n    else\r\n      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;\r\n    for (uint16_t i = 0; i < numBytes; i++) {\r\n      c = *ptr;\r\n      *ptr++ = (c * scale) >> 8;\r\n    }\r\n    brightness = newBrightness;\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief   Retrieve the last-set brightness value for the strip.\r\n  @return  Brightness value: 0 = minimum (off), 255 = maximum.\r\n*/\r\nuint8_t Adafruit_NeoPixel::getBrightness(void) const { return brightness - 1; }\r\n\r\n/*!\r\n  @brief   Fill the whole NeoPixel strip with 0 / black / off.\r\n*/\r\nvoid Adafruit_NeoPixel::clear(void) { memset(pixels, 0, numBytes); }\r\n\r\n// A 32-bit variant of gamma8() that applies the same function\r\n// to all components of a packed RGB or WRGB value.\r\nuint32_t Adafruit_NeoPixel::gamma32(uint32_t x) {\r\n  uint8_t *y = (uint8_t *)&x;\r\n  // All four bytes of a 32-bit value are filtered even if RGB (not WRGB),\r\n  // to avoid a bunch of shifting and masking that would be necessary for\r\n  // properly handling different endianisms (and each byte is a fairly\r\n  // trivial operation, so it might not even be wasting cycles vs a check\r\n  // and branch for the RGB case). In theory this might cause trouble *if*\r\n  // someone's storing information in the unused most significant byte\r\n  // of an RGB value, but this seems exceedingly rare and if it's\r\n  // encountered in reality they can mask values going in or coming out.\r\n  for (uint8_t i = 0; i < 4; i++)\r\n    y[i] = gamma8(y[i]);\r\n  return x; // Packed 32-bit return\r\n}\r\n\r\n/*!\r\n  @brief   Fill NeoPixel strip with one or more cycles of hues.\r\n           Everyone loves the rainbow swirl so much, now it's canon!\r\n  @param   first_hue   Hue of first pixel, 0-65535, representing one full\r\n                       cycle of the color wheel. Each subsequent pixel will\r\n                       be offset to complete one or more cycles over the\r\n                       length of the strip.\r\n  @param   reps        Number of cycles of the color wheel over the length\r\n                       of the strip. Default is 1. Negative values can be\r\n                       used to reverse the hue order.\r\n  @param   saturation  Saturation (optional), 0-255 = gray to pure hue,\r\n                       default = 255.\r\n  @param   brightness  Brightness/value (optional), 0-255 = off to max,\r\n                       default = 255. This is distinct and in combination\r\n                       with any configured global strip brightness.\r\n  @param   gammify     If true (default), apply gamma correction to colors\r\n                       for better appearance.\r\n*/\r\nvoid Adafruit_NeoPixel::rainbow(uint16_t first_hue, int8_t reps,\r\n  uint8_t saturation, uint8_t brightness, bool gammify) {\r\n  for (uint16_t i=0; i<numLEDs; i++) {\r\n    uint16_t hue = first_hue + (i * reps * 65536) / numLEDs;\r\n    uint32_t color = ColorHSV(hue, saturation, brightness);\r\n    if (gammify) color = gamma32(color);\r\n    setPixelColor(i, color);\r\n  }\r\n}\r\n\r\n/*!\r\n  @brief  Convert pixel color order from string (e.g. \"BGR\") to NeoPixel\r\n          color order constant (e.g. NEO_BGR). This may be helpful for code\r\n          that initializes from text configuration rather than compile-time\r\n          constants.\r\n  @param   v  Input string. Should be reasonably sanitized (a 3- or 4-\r\n              character NUL-terminated string) or undefined behavior may\r\n              result (output is still a valid NeoPixel order constant, but\r\n              might not present as expected). Garbage in, garbage out.\r\n  @return  One of the NeoPixel color order constants (e.g. NEO_BGR).\r\n           NEO_KHZ400 or NEO_KHZ800 bits are not included, nor needed (all\r\n           NeoPixels actually support 800 KHz it's been found, and this is\r\n           the default state if no KHZ bits set).\r\n  @note    This function is declared static in the class so it can be called\r\n           without a NeoPixel object (since it's not likely been declared\r\n           in the code yet). Use Adafruit_NeoPixel::str2order().\r\n*/\r\nneoPixelType Adafruit_NeoPixel::str2order(const char *v) {\r\n  int8_t r = 0, g = 0, b = 0, w = -1;\r\n  if (v) {\r\n    char c;\r\n    for (uint8_t i=0; ((c = tolower(v[i]))); i++) {\r\n      if (c == 'r') r = i;\r\n      else if (c == 'g') g = i;\r\n      else if (c == 'b') b = i;\r\n      else if (c == 'w') w = i;\r\n    }\r\n    r &= 3;\r\n  }\r\n  if (w < 0) w = r; // If 'w' not specified, duplicate r bits\r\n  return (w << 6) | (r << 4) | ((g & 3) << 2) | (b & 3);\r\n}\r\n"
        },
        {
          "name": "Adafruit_NeoPixel.h",
          "type": "blob",
          "size": 19.61328125,
          "content": "/*!\n * @file Adafruit_NeoPixel.h\n *\n * This is part of Adafruit's NeoPixel library for the Arduino platform,\n * allowing a broad range of microcontroller boards (most AVR boards,\n * many ARM devices, ESP8266 and ESP32, among others) to control Adafruit\n * NeoPixels, FLORA RGB Smart Pixels and compatible devices -- WS2811,\n * WS2812, WS2812B, SK6812, etc.\n *\n * Adafruit invests time and resources providing this open source code,\n * please support Adafruit and open-source hardware by purchasing products\n * from Adafruit!\n *\n * Written by Phil \"Paint Your Dragon\" Burgess for Adafruit Industries,\n * with contributions by PJRC, Michael Miller and other members of the\n * open source community.\n *\n * This file is part of the Adafruit_NeoPixel library.\n *\n * Adafruit_NeoPixel is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * Adafruit_NeoPixel is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with NeoPixel.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n */\n\n#ifndef ADAFRUIT_NEOPIXEL_H\n#define ADAFRUIT_NEOPIXEL_H\n\n#ifdef ARDUINO\n#if (ARDUINO >= 100)\n#include <Arduino.h>\n#else\n#include <WProgram.h>\n#include <pins_arduino.h>\n#endif\n\n#ifdef USE_TINYUSB // For Serial when selecting TinyUSB\n#include <Adafruit_TinyUSB.h>\n#endif\n\n#endif\n\n#ifdef TARGET_LPC1768\n#include <Arduino.h>\n#endif\n\n#if defined(ARDUINO_ARCH_RP2040)\n#include <stdlib.h>\n#include \"hardware/pio.h\"\n#include \"hardware/clocks.h\"\n#include \"rp2040_pio.h\"\n#endif\n\n// The order of primary colors in the NeoPixel data stream can vary among\n// device types, manufacturers and even different revisions of the same\n// item.  The third parameter to the Adafruit_NeoPixel constructor encodes\n// the per-pixel byte offsets of the red, green and blue primaries (plus\n// white, if present) in the data stream -- the following #defines provide\n// an easier-to-use named version for each permutation. e.g. NEO_GRB\n// indicates a NeoPixel-compatible device expecting three bytes per pixel,\n// with the first byte transmitted containing the green value, second\n// containing red and third containing blue. The in-memory representation\n// of a chain of NeoPixels is the same as the data-stream order; no\n// re-ordering of bytes is required when issuing data to the chain.\n// Most of these values won't exist in real-world devices, but it's done\n// this way so we're ready for it (also, if using the WS2811 driver IC,\n// one might have their pixels set up in any weird permutation).\n\n// Bits 5,4 of this value are the offset (0-3) from the first byte of a\n// pixel to the location of the red color byte.  Bits 3,2 are the green\n// offset and 1,0 are the blue offset.  If it is an RGBW-type device\n// (supporting a white primary in addition to R,G,B), bits 7,6 are the\n// offset to the white byte...otherwise, bits 7,6 are set to the same value\n// as 5,4 (red) to indicate an RGB (not RGBW) device.\n// i.e. binary representation:\n// 0bWWRRGGBB for RGBW devices\n// 0bRRRRGGBB for RGB\n\n// RGB NeoPixel permutations; white and red offsets are always same\n// Offset:        W          R          G          B\n#define NEO_RGB ((0 << 6) | (0 << 4) | (1 << 2) | (2)) ///< Transmit as R,G,B\n#define NEO_RBG ((0 << 6) | (0 << 4) | (2 << 2) | (1)) ///< Transmit as R,B,G\n#define NEO_GRB ((1 << 6) | (1 << 4) | (0 << 2) | (2)) ///< Transmit as G,R,B\n#define NEO_GBR ((2 << 6) | (2 << 4) | (0 << 2) | (1)) ///< Transmit as G,B,R\n#define NEO_BRG ((1 << 6) | (1 << 4) | (2 << 2) | (0)) ///< Transmit as B,R,G\n#define NEO_BGR ((2 << 6) | (2 << 4) | (1 << 2) | (0)) ///< Transmit as B,G,R\n\n// RGBW NeoPixel permutations; all 4 offsets are distinct\n// Offset:         W          R          G          B\n#define NEO_WRGB ((0 << 6) | (1 << 4) | (2 << 2) | (3)) ///< Transmit as W,R,G,B\n#define NEO_WRBG ((0 << 6) | (1 << 4) | (3 << 2) | (2)) ///< Transmit as W,R,B,G\n#define NEO_WGRB ((0 << 6) | (2 << 4) | (1 << 2) | (3)) ///< Transmit as W,G,R,B\n#define NEO_WGBR ((0 << 6) | (3 << 4) | (1 << 2) | (2)) ///< Transmit as W,G,B,R\n#define NEO_WBRG ((0 << 6) | (2 << 4) | (3 << 2) | (1)) ///< Transmit as W,B,R,G\n#define NEO_WBGR ((0 << 6) | (3 << 4) | (2 << 2) | (1)) ///< Transmit as W,B,G,R\n\n#define NEO_RWGB ((1 << 6) | (0 << 4) | (2 << 2) | (3)) ///< Transmit as R,W,G,B\n#define NEO_RWBG ((1 << 6) | (0 << 4) | (3 << 2) | (2)) ///< Transmit as R,W,B,G\n#define NEO_RGWB ((2 << 6) | (0 << 4) | (1 << 2) | (3)) ///< Transmit as R,G,W,B\n#define NEO_RGBW ((3 << 6) | (0 << 4) | (1 << 2) | (2)) ///< Transmit as R,G,B,W\n#define NEO_RBWG ((2 << 6) | (0 << 4) | (3 << 2) | (1)) ///< Transmit as R,B,W,G\n#define NEO_RBGW ((3 << 6) | (0 << 4) | (2 << 2) | (1)) ///< Transmit as R,B,G,W\n\n#define NEO_GWRB ((1 << 6) | (2 << 4) | (0 << 2) | (3)) ///< Transmit as G,W,R,B\n#define NEO_GWBR ((1 << 6) | (3 << 4) | (0 << 2) | (2)) ///< Transmit as G,W,B,R\n#define NEO_GRWB ((2 << 6) | (1 << 4) | (0 << 2) | (3)) ///< Transmit as G,R,W,B\n#define NEO_GRBW ((3 << 6) | (1 << 4) | (0 << 2) | (2)) ///< Transmit as G,R,B,W\n#define NEO_GBWR ((2 << 6) | (3 << 4) | (0 << 2) | (1)) ///< Transmit as G,B,W,R\n#define NEO_GBRW ((3 << 6) | (2 << 4) | (0 << 2) | (1)) ///< Transmit as G,B,R,W\n\n#define NEO_BWRG ((1 << 6) | (2 << 4) | (3 << 2) | (0)) ///< Transmit as B,W,R,G\n#define NEO_BWGR ((1 << 6) | (3 << 4) | (2 << 2) | (0)) ///< Transmit as B,W,G,R\n#define NEO_BRWG ((2 << 6) | (1 << 4) | (3 << 2) | (0)) ///< Transmit as B,R,W,G\n#define NEO_BRGW ((3 << 6) | (1 << 4) | (2 << 2) | (0)) ///< Transmit as B,R,G,W\n#define NEO_BGWR ((2 << 6) | (3 << 4) | (1 << 2) | (0)) ///< Transmit as B,G,W,R\n#define NEO_BGRW ((3 << 6) | (2 << 4) | (1 << 2) | (0)) ///< Transmit as B,G,R,W\n\n// Add NEO_KHZ400 to the color order value to indicate a 400 KHz device.\n// All but the earliest v1 NeoPixels expect an 800 KHz data stream, this is\n// the default if unspecified. Because flash space is very limited on ATtiny\n// devices (e.g. Trinket, Gemma), v1 NeoPixels aren't handled by default on\n// those chips, though it can be enabled by removing the ifndef/endif below,\n// but code will be bigger. Conversely, can disable the NEO_KHZ400 line on\n// other MCUs to remove v1 support and save a little space.\n\n#define NEO_KHZ800 0x0000 ///< 800 KHz data transmission\n#ifndef __AVR_ATtiny85__\n#define NEO_KHZ400 0x0100 ///< 400 KHz data transmission\n#endif\n\n// If 400 KHz support is enabled, the third parameter to the constructor\n// requires a 16-bit value (in order to select 400 vs 800 KHz speed).\n// If only 800 KHz is enabled (as is default on ATtiny), an 8-bit value\n// is sufficient to encode pixel color order, saving some space.\n\n#ifdef NEO_KHZ400\ntypedef uint16_t neoPixelType; ///< 3rd arg to Adafruit_NeoPixel constructor\n#else\ntypedef uint8_t neoPixelType; ///< 3rd arg to Adafruit_NeoPixel constructor\n#endif\n\n// These two tables are declared outside the Adafruit_NeoPixel class\n// because some boards may require oldschool compilers that don't\n// handle the C++11 constexpr keyword.\n\n/* A PROGMEM (flash mem) table containing 8-bit unsigned sine wave (0-255).\n   Copy & paste this snippet into a Python REPL to regenerate:\nimport math\nfor x in range(256):\n    print(\"{:3},\".format(int((math.sin(x/128.0*math.pi)+1.0)*127.5+0.5))),\n    if x&15 == 15: print\n*/\nstatic const uint8_t PROGMEM _NeoPixelSineTable[256] = {\n    128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 162, 165, 167, 170,\n    173, 176, 179, 182, 185, 188, 190, 193, 196, 198, 201, 203, 206, 208, 211,\n    213, 215, 218, 220, 222, 224, 226, 228, 230, 232, 234, 235, 237, 238, 240,\n    241, 243, 244, 245, 246, 248, 249, 250, 250, 251, 252, 253, 253, 254, 254,\n    254, 255, 255, 255, 255, 255, 255, 255, 254, 254, 254, 253, 253, 252, 251,\n    250, 250, 249, 248, 246, 245, 244, 243, 241, 240, 238, 237, 235, 234, 232,\n    230, 228, 226, 224, 222, 220, 218, 215, 213, 211, 208, 206, 203, 201, 198,\n    196, 193, 190, 188, 185, 182, 179, 176, 173, 170, 167, 165, 162, 158, 155,\n    152, 149, 146, 143, 140, 137, 134, 131, 128, 124, 121, 118, 115, 112, 109,\n    106, 103, 100, 97,  93,  90,  88,  85,  82,  79,  76,  73,  70,  67,  65,\n    62,  59,  57,  54,  52,  49,  47,  44,  42,  40,  37,  35,  33,  31,  29,\n    27,  25,  23,  21,  20,  18,  17,  15,  14,  12,  11,  10,  9,   7,   6,\n    5,   5,   4,   3,   2,   2,   1,   1,   1,   0,   0,   0,   0,   0,   0,\n    0,   1,   1,   1,   2,   2,   3,   4,   5,   5,   6,   7,   9,   10,  11,\n    12,  14,  15,  17,  18,  20,  21,  23,  25,  27,  29,  31,  33,  35,  37,\n    40,  42,  44,  47,  49,  52,  54,  57,  59,  62,  65,  67,  70,  73,  76,\n    79,  82,  85,  88,  90,  93,  97,  100, 103, 106, 109, 112, 115, 118, 121,\n    124};\n\n/* Similar to above, but for an 8-bit gamma-correction table.\n   Copy & paste this snippet into a Python REPL to regenerate:\nimport math\ngamma=2.6\nfor x in range(256):\n    print(\"{:3},\".format(int(math.pow((x)/255.0,gamma)*255.0+0.5))),\n    if x&15 == 15: print\n*/\nstatic const uint8_t PROGMEM _NeoPixelGammaTable[256] = {\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1,   1,   1,   1,\n    1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,   2,   2,   2,   3,\n    3,   3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,   5,   6,\n    6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,   10,  10,  10,\n    11,  11,  11,  12,  12,  13,  13,  13,  14,  14,  15,  15,  16,  16,  17,\n    17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,\n    25,  26,  27,  27,  28,  29,  29,  30,  31,  31,  32,  33,  34,  34,  35,\n    36,  37,  38,  38,  39,  40,  41,  42,  42,  43,  44,  45,  46,  47,  48,\n    49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n    64,  65,  66,  68,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,\n    82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  96,  97,  99,  100, 102,\n    103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 119, 120, 122, 124, 125,\n    127, 129, 130, 132, 134, 136, 137, 139, 141, 143, 145, 146, 148, 150, 152,\n    154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,\n    184, 186, 188, 191, 193, 195, 197, 199, 202, 204, 206, 209, 211, 213, 215,\n    218, 220, 223, 225, 227, 230, 232, 235, 237, 240, 242, 245, 247, 250, 252,\n    255};\n\n/*!\n    @brief  Class that stores state and functions for interacting with\n            Adafruit NeoPixels and compatible devices.\n*/\nclass Adafruit_NeoPixel {\n\npublic:\n  // Constructor: number of LEDs, pin number, LED type\n  Adafruit_NeoPixel(uint16_t n, int16_t pin = 6,\n                    neoPixelType type = NEO_GRB + NEO_KHZ800);\n  Adafruit_NeoPixel(void);\n  ~Adafruit_NeoPixel();\n\n  void begin(void);\n  void show(void);\n  void setPin(int16_t p);\n  void setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b);\n  void setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b, uint8_t w);\n  void setPixelColor(uint16_t n, uint32_t c);\n  void fill(uint32_t c = 0, uint16_t first = 0, uint16_t count = 0);\n  void setBrightness(uint8_t);\n  void clear(void);\n  void updateLength(uint16_t n);\n  void updateType(neoPixelType t);\n  /*!\n    @brief   Check whether a call to show() will start sending data\n             immediately or will 'block' for a required interval. NeoPixels\n             require a short quiet time (about 300 microseconds) after the\n             last bit is received before the data 'latches' and new data can\n             start being received. Usually one's sketch is implicitly using\n             this time to generate a new frame of animation...but if it\n             finishes very quickly, this function could be used to see if\n             there's some idle time available for some low-priority\n             concurrent task.\n    @return  1 or true if show() will start sending immediately, 0 or false\n             if show() would block (meaning some idle time is available).\n  */\n  bool canShow(void) {\n    // It's normal and possible for endTime to exceed micros() if the\n    // 32-bit clock counter has rolled over (about every 70 minutes).\n    // Since both are uint32_t, a negative delta correctly maps back to\n    // positive space, and it would seem like the subtraction below would\n    // suffice. But a problem arises if code invokes show() very\n    // infrequently...the micros() counter may roll over MULTIPLE times in\n    // that interval, the delta calculation is no longer correct and the\n    // next update may stall for a very long time. The check below resets\n    // the latch counter if a rollover has occurred. This can cause an\n    // extra delay of up to 300 microseconds in the rare case where a\n    // show() call happens precisely around the rollover, but that's\n    // neither likely nor especially harmful, vs. other code that might\n    // stall for 30+ minutes, or having to document and frequently remind\n    // and/or provide tech support explaining an unintuitive need for\n    // show() calls at least once an hour.\n    uint32_t now = micros();\n    if (endTime > now) {\n      endTime = now;\n    }\n    return (now - endTime) >= 300L;\n  }\n  /*!\n    @brief   Get a pointer directly to the NeoPixel data buffer in RAM.\n             Pixel data is stored in a device-native format (a la the NEO_*\n             constants) and is not translated here. Applications that access\n             this buffer will need to be aware of the specific data format\n             and handle colors appropriately.\n    @return  Pointer to NeoPixel buffer (uint8_t* array).\n    @note    This is for high-performance applications where calling\n             setPixelColor() on every single pixel would be too slow (e.g.\n             POV or light-painting projects). There is no bounds checking\n             on the array, creating tremendous potential for mayhem if one\n             writes past the ends of the buffer. Great power, great\n             responsibility and all that.\n  */\n  uint8_t *getPixels(void) const { return pixels; };\n  uint8_t getBrightness(void) const;\n  /*!\n    @brief   Retrieve the pin number used for NeoPixel data output.\n    @return  Arduino pin number (-1 if not set).\n  */\n  int16_t getPin(void) const { return pin; };\n  /*!\n    @brief   Return the number of pixels in an Adafruit_NeoPixel strip object.\n    @return  Pixel count (0 if not set).\n  */\n  uint16_t numPixels(void) const { return numLEDs; }\n  uint32_t getPixelColor(uint16_t n) const;\n  /*!\n    @brief   An 8-bit integer sine wave function, not directly compatible\n             with standard trigonometric units like radians or degrees.\n    @param   x  Input angle, 0-255; 256 would loop back to zero, completing\n                the circle (equivalent to 360 degrees or 2 pi radians).\n                One can therefore use an unsigned 8-bit variable and simply\n                add or subtract, allowing it to overflow/underflow and it\n                still does the expected contiguous thing.\n    @return  Sine result, 0 to 255, or -128 to +127 if type-converted to\n             a signed int8_t, but you'll most likely want unsigned as this\n             output is often used for pixel brightness in animation effects.\n  */\n  static uint8_t sine8(uint8_t x) {\n    return pgm_read_byte(&_NeoPixelSineTable[x]); // 0-255 in, 0-255 out\n  }\n  /*!\n    @brief   An 8-bit gamma-correction function for basic pixel brightness\n             adjustment. Makes color transitions appear more perceptially\n             correct.\n    @param   x  Input brightness, 0 (minimum or off/black) to 255 (maximum).\n    @return  Gamma-adjusted brightness, can then be passed to one of the\n             setPixelColor() functions. This uses a fixed gamma correction\n             exponent of 2.6, which seems reasonably okay for average\n             NeoPixels in average tasks. If you need finer control you'll\n             need to provide your own gamma-correction function instead.\n  */\n  static uint8_t gamma8(uint8_t x) {\n    return pgm_read_byte(&_NeoPixelGammaTable[x]); // 0-255 in, 0-255 out\n  }\n  /*!\n    @brief   Convert separate red, green and blue values into a single\n             \"packed\" 32-bit RGB color.\n    @param   r  Red brightness, 0 to 255.\n    @param   g  Green brightness, 0 to 255.\n    @param   b  Blue brightness, 0 to 255.\n    @return  32-bit packed RGB value, which can then be assigned to a\n             variable for later use or passed to the setPixelColor()\n             function. Packed RGB format is predictable, regardless of\n             LED strand color order.\n  */\n  static uint32_t Color(uint8_t r, uint8_t g, uint8_t b) {\n    return ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;\n  }\n  /*!\n    @brief   Convert separate red, green, blue and white values into a\n             single \"packed\" 32-bit WRGB color.\n    @param   r  Red brightness, 0 to 255.\n    @param   g  Green brightness, 0 to 255.\n    @param   b  Blue brightness, 0 to 255.\n    @param   w  White brightness, 0 to 255.\n    @return  32-bit packed WRGB value, which can then be assigned to a\n             variable for later use or passed to the setPixelColor()\n             function. Packed WRGB format is predictable, regardless of\n             LED strand color order.\n  */\n  static uint32_t Color(uint8_t r, uint8_t g, uint8_t b, uint8_t w) {\n    return ((uint32_t)w << 24) | ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;\n  }\n  static uint32_t ColorHSV(uint16_t hue, uint8_t sat = 255, uint8_t val = 255);\n  /*!\n    @brief   A gamma-correction function for 32-bit packed RGB or WRGB\n             colors. Makes color transitions appear more perceptially\n             correct.\n    @param   x  32-bit packed RGB or WRGB color.\n    @return  Gamma-adjusted packed color, can then be passed in one of the\n             setPixelColor() functions. Like gamma8(), this uses a fixed\n             gamma correction exponent of 2.6, which seems reasonably okay\n             for average NeoPixels in average tasks. If you need finer\n             control you'll need to provide your own gamma-correction\n             function instead.\n  */\n  static uint32_t gamma32(uint32_t x);\n\n  void rainbow(uint16_t first_hue = 0, int8_t reps = 1,\n               uint8_t saturation = 255, uint8_t brightness = 255,\n               bool gammify = true);\n\n  static neoPixelType str2order(const char *v);\n\nprivate:\n#if defined(ARDUINO_ARCH_RP2040)\n  void  rp2040Init(uint8_t pin, bool is800KHz);\n  void  rp2040Show(uint8_t pin, uint8_t *pixels, uint32_t numBytes, bool is800KHz);\n#endif\n\nprotected:\n#ifdef NEO_KHZ400 // If 400 KHz NeoPixel support enabled...\n  bool is800KHz; ///< true if 800 KHz pixels\n#endif\n  bool begun;         ///< true if begin() previously called\n  uint16_t numLEDs;   ///< Number of RGB LEDs in strip\n  uint16_t numBytes;  ///< Size of 'pixels' buffer below\n  int16_t pin;        ///< Output pin number (-1 if not yet set)\n  uint8_t brightness; ///< Strip brightness 0-255 (stored as +1)\n  uint8_t *pixels;    ///< Holds LED color values (3 or 4 bytes each)\n  uint8_t rOffset;    ///< Red index within each 3- or 4-byte pixel\n  uint8_t gOffset;    ///< Index of green byte\n  uint8_t bOffset;    ///< Index of blue byte\n  uint8_t wOffset;    ///< Index of white (==rOffset if no white)\n  uint32_t endTime;   ///< Latch timing reference\n#ifdef __AVR__\n  volatile uint8_t *port; ///< Output PORT register\n  uint8_t pinMask;        ///< Output PORT bitmask\n#endif\n#if defined(ARDUINO_ARCH_STM32) || defined(ARDUINO_ARCH_ARDUINO_CORE_STM32) || defined(ARDUINO_ARCH_CH32)\n  GPIO_TypeDef *gpioPort; ///< Output GPIO PORT\n  uint32_t gpioPin;       ///< Output GPIO PIN\n#endif\n#if defined(ARDUINO_ARCH_RP2040)\n  PIO pio = pio0;\n  int sm = 0;\n  bool init = true;\n#endif\n};\n\n#endif // ADAFRUIT_NEOPIXEL_H\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2578125,
          "content": "# Contribution Guidelines\n\nThis library is the culmination of the expertise of many members of the open source community who have dedicated their time and hard work. The best way to ask for help or propose a new idea is to [create a new issue](https://github.com/adafruit/Adafruit_NeoPixel/issues/new) while creating a Pull Request with your code changes allows you to share your own innovations with the rest of the community.\n\nThe following are some guidelines to observe when creating issues or PRs:\n\n- Be friendly; it is important that we can all enjoy a safe space as we are all working on the same project and it is okay for people to have different ideas\n\n- [Use code blocks](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#code); it helps us help you when we can read your code! On that note also refrain from pasting more than 30 lines of code in a post, instead [create a gist](https://gist.github.com/) if you need to share large snippets\n\n- Use reasonable titles; refrain from using overly long or capitalized titles as they are usually annoying and do little to encourage others to help :smile:\n\n- Be detailed; refrain from mentioning code problems without sharing your source code and always give information regarding your board and version of the library\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 7.4716796875,
          "content": "                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.138671875,
          "content": "# Adafruit NeoPixel Library [![Build Status](https://github.com/adafruit/Adafruit_NeoPixel/workflows/Arduino%20Library%20CI/badge.svg)](https://github.com/adafruit/Adafruit_NeoPixel/actions)[![Documentation](https://github.com/adafruit/ci-arduino/blob/master/assets/doxygen_badge.svg)](http://adafruit.github.io/Adafruit_NeoPixel/html/index.html)\n\nArduino library for controlling single-wire-based LED pixels and strip such as the [Adafruit 60 LED/meter Digital LED strip][strip], the [Adafruit FLORA RGB Smart Pixel][flora], the [Adafruit Breadboard-friendly RGB Smart Pixel][pixel], the [Adafruit NeoPixel Stick][stick], and the [Adafruit NeoPixel Shield][shield].\n\nAfter downloading, rename folder to 'Adafruit_NeoPixel' and install in Arduino Libraries folder. Restart Arduino IDE, then open File->Sketchbook->Library->Adafruit_NeoPixel->strandtest sketch.\n\nCompatibility notes: Port A is not supported on any AVR processors at this time\n\n[flora]:  http://adafruit.com/products/1060\n[strip]:  http://adafruit.com/products/1138\n[pixel]:  http://adafruit.com/products/1312\n[stick]:  http://adafruit.com/products/1426\n[shield]: http://adafruit.com/products/1430\n\n---\n\n## Installation\n\n### First Method\n\n![image](https://user-images.githubusercontent.com/36513474/68967967-3e37f480-0803-11ea-91d9-601848c306ee.png)\n\n1. In the Arduino IDE, navigate to Sketch > Include Library > Manage Libraries\n1. Then the Library Manager will open and you will find a list of libraries that are already installed or ready for installation.\n1. Then search for Neopixel strip using the search bar.\n1. Click on the text area and then select the specific version and install it.\n\n### Second Method\n\n1. Navigate to the [Releases page](https://github.com/adafruit/Adafruit_NeoPixel/releases).\n1. Download the latest release.\n1. Extract the zip file\n1. In the Arduino IDE, navigate to Sketch > Include Library > Add .ZIP Library\n\n## Features\n\n- ### Simple to use\n\n  Controlling NeoPixels from scratch is quite a challenge, so we provide a library letting you focus on the fun and interesting bits.\n\n- ### Give back\n\n  The library is free; you dont have to pay for anything. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit!\n\n- ### Supported Chipsets\n\n  We have included code for the following chips - sometimes these break for exciting reasons that we can't control in which case please open an issue!\n\n  - AVR ATmega and ATtiny (any 8-bit) - 8 MHz, 12 MHz and 16 MHz\n  - Teensy 3.x and LC\n  - Arduino Due\n  - Arduino 101\n  - ATSAMD21 (Arduino Zero/M0 and other SAMD21 boards) @ 48 MHz\n  - ATSAMD51 @ 120 MHz\n  - Adafruit STM32 Feather @ 120 MHz\n  - ESP8266 any speed\n  - ESP32 any speed\n  - Nordic nRF52 (Adafruit Feather nRF52), nRF51 (micro:bit)\n  - Infineon XMC1100 BootKit @ 32 MHz\n  - Infineon XMC1100 2Go @ 32 MHz\n  - Infineon XMC1300 BootKit  @ 32 MHz\n  - Infineon XMC4700 RelaxKit, XMC4800 RelaxKit, XMC4800 IoT Amazon FreeRTOS Kit @ 144 MHz\n\n  Check forks for other architectures not listed here!\n\n- ### GNU Lesser General Public License\n\n  Adafruit_NeoPixel is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\n## Functions\n\n- begin()\n- updateLength()\n- updateType()\n- show()\n- delay_ns()\n- setPin()\n- setPixelColor()\n- fill()\n- ColorHSV()\n- getPixelColor()\n- setBrightness()\n- getBrightness()\n- clear()\n- gamma32()\n\n## Examples\n\nThere are many examples implemented in this library. One of the examples is below. You can find other examples [here](https://github.com/adafruit/Adafruit_NeoPixel/tree/master/examples)\n\n### Simple\n\n```Cpp\n#include <Adafruit_NeoPixel.h>\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n#define PIN        6\n#define NUMPIXELS 16\n\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n#define DELAYVAL 500\n\nvoid setup() {\n#if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)\n  clock_prescale_set(clock_div_1);\n#endif\n\n  pixels.begin();\n}\n\nvoid loop() {\n  pixels.clear();\n\n  for(int i=0; i<NUMPIXELS; i++) {\n\n    pixels.setPixelColor(i, pixels.Color(0, 150, 0));\n    pixels.show();\n    delay(DELAYVAL);\n  }\n}\n```\n\n## Contributing\n\nIf you want to contribute to this project:\n\n- Report bugs and errors\n- Ask for enhancements\n- Create issues and pull requests\n- Tell others about this library\n- Contribute new protocols\n\nPlease read [CONTRIBUTING.md](https://github.com/adafruit/Adafruit_NeoPixel/blob/master/CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.\n\n### Roadmap\n\nThe PRIME DIRECTIVE is to maintain backward compatibility with existing Arduino sketches -- many are hosted elsewhere and don't track changes here, some are in print and can never be changed!\n\nPlease don't reformat code for the sake of reformatting code. The resulting large \"visual diff\" makes it impossible to untangle actual bug fixes from merely rearranged lines. Also, don't bother with PRs for timing adjustments \"to better match the datasheet,\" because the datasheet isn't really true to begin with.\n\nThings I'd Like To Do But There's No Official Timeline So Please Don't Count On Any Of This Ever Being Canonical:\n\n- 400 KHz support can be removed, turns out it was never actually necessary; even the earliest NeoPixels can ingest 800 KHz data. Of course the #defines should remain so old sketches still compile, but both can be set to 0 and would have no effect on anything.\n- For the show() function (with all the delicate pixel timing stuff), break out each architecture into separate source files rather than the current unmaintainable tangle of #ifdef statements!\n- Please don't use updateLength() or updateType() in new code. They should not have been implemented this way (use the C++ 'new' operator with the regular constructor instead) and are only sticking around because of the Prime Directive. setPin() is OK for now though, it's a trick we can use to 'recycle' pixel memory across multiple strips.\n- In the M0 and M4 code, use the hardware systick counter for bit timing rather than hand-tweaked NOPs (a temporary kludge at the time because I wasn't reading systick correctly). (As of 1.4.2, systick is used on M4 devices and it appears to be overclock-compatible. Not for M0 yet, which is why this item is still here.)\n- As currently written, brightness scaling is still a \"destructive\" operation -- pixel values are altered in RAM and the original value as set can't be accurately read back, only approximated, which has been confusing and frustrating to users. It was done this way at the time because NeoPixel timing is strict, AVR microcontrollers (all we had at the time) are limited, and assembly language is hard. All the 32-bit architectures should have no problem handling nondestructive brightness scaling -- calculating each byte immediately before it's sent out the wire, maintaining the original set value in RAM -- the work just hasn't been done. There's a fair chance even the AVR code could manage it with some intense focus. (The DotStar library achieves nondestructive brightness scaling because it doesn't have to manage data timing so carefully...every architecture, even ATtiny, just takes whatever cycles it needs for the multiply/shift operations.)\n\n## Credits\n\nThis library is written by Phil \"Paint Your Dragon\" Burgess for Adafruit Industries, with contributions by PJRC, Michael Miller and other members of the open source community.\n\n## License\n\nAdafruit_NeoPixel is free software: you can redistribute it and/or  modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nAdafruit_NeoPixel is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the [GNU Lesser General Public License](https://www.gnu.org/licenses/lgpl-3.0.en.html) for more details.\nYou should have received a copy of the GNU Lesser General Public License along with NeoPixel.  If not, see [this](https://www.gnu.org/licenses/)\n"
        },
        {
          "name": "esp.c",
          "type": "blob",
          "size": 6.625,
          "content": "// Implements the RMT peripheral on Espressif SoCs\n// Copyright (c) 2020 Lucian Copeland for Adafruit Industries\n\n/* Uses code from Espressif RGB LED Strip demo and drivers\n * Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#if defined(ESP32)\n\n#include <Arduino.h>\n\n#if defined(ESP_IDF_VERSION)\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)\n#define HAS_ESP_IDF_4\n#endif\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)\n#define HAS_ESP_IDF_5\n#endif\n#endif\n\n\n\n#ifdef HAS_ESP_IDF_5\n\nvoid espShow(uint8_t pin, uint8_t *pixels, uint32_t numBytes, boolean is800KHz) {\n  rmt_data_t led_data[numBytes * 8];\n\n  if (!rmtInit(pin, RMT_TX_MODE, RMT_MEM_NUM_BLOCKS_1, 10000000)) {\n    log_e(\"Failed to init RMT TX mode on pin %d\", pin);\n    return;\n  }\n\n  int i=0;\n  for (int b=0; b < numBytes; b++) {\n    for (int bit=0; bit<8; bit++){\n      if ( pixels[b] & (1<<(7-bit)) ) {\n        led_data[i].level0 = 1;\n        led_data[i].duration0 = 8;\n        led_data[i].level1 = 0;\n        led_data[i].duration1 = 4;\n      } else {\n        led_data[i].level0 = 1;\n        led_data[i].duration0 = 4;\n        led_data[i].level1 = 0;\n        led_data[i].duration1 = 8;\n      }\n      i++;\n    }\n  }\n\n  //pinMode(pin, OUTPUT);  // don't do this, will cause the rmt to disable!\n  rmtWrite(pin, led_data, numBytes * 8, RMT_WAIT_FOR_EVER);\n}\n\n\n\n#else\n\n#include \"driver/rmt.h\"\n\n\n// This code is adapted from the ESP-IDF v3.4 RMT \"led_strip\" example, altered\n// to work with the Arduino version of the ESP-IDF (3.2)\n\n#define WS2812_T0H_NS (400)\n#define WS2812_T0L_NS (850)\n#define WS2812_T1H_NS (800)\n#define WS2812_T1L_NS (450)\n\n#define WS2811_T0H_NS (500)\n#define WS2811_T0L_NS (2000)\n#define WS2811_T1H_NS (1200)\n#define WS2811_T1L_NS (1300)\n\nstatic uint32_t t0h_ticks = 0;\nstatic uint32_t t1h_ticks = 0;\nstatic uint32_t t0l_ticks = 0;\nstatic uint32_t t1l_ticks = 0;\n\n// Limit the number of RMT channels available for the Neopixels. Defaults to all\n// channels (8 on ESP32, 4 on ESP32-S2 and S3). Redefining this value will free\n// any channels with a higher number for other uses, such as IR send-and-recieve\n// libraries. Redefine as 1 to restrict Neopixels to only a single channel.\n#define ADAFRUIT_RMT_CHANNEL_MAX RMT_CHANNEL_MAX\n\n#define RMT_LL_HW_BASE  (&RMT)\n\nbool rmt_reserved_channels[ADAFRUIT_RMT_CHANNEL_MAX];\n\nstatic void IRAM_ATTR ws2812_rmt_adapter(const void *src, rmt_item32_t *dest, size_t src_size,\n        size_t wanted_num, size_t *translated_size, size_t *item_num)\n{\n    if (src == NULL || dest == NULL) {\n        *translated_size = 0;\n        *item_num = 0;\n        return;\n    }\n    const rmt_item32_t bit0 = {{{ t0h_ticks, 1, t0l_ticks, 0 }}}; //Logical 0\n    const rmt_item32_t bit1 = {{{ t1h_ticks, 1, t1l_ticks, 0 }}}; //Logical 1\n    size_t size = 0;\n    size_t num = 0;\n    uint8_t *psrc = (uint8_t *)src;\n    rmt_item32_t *pdest = dest;\n    while (size < src_size && num < wanted_num) {\n        for (int i = 0; i < 8; i++) {\n            // MSB first\n            if (*psrc & (1 << (7 - i))) {\n                pdest->val =  bit1.val;\n            } else {\n                pdest->val =  bit0.val;\n            }\n            num++;\n            pdest++;\n        }\n        size++;\n        psrc++;\n    }\n    *translated_size = size;\n    *item_num = num;\n}\n\nvoid espShow(uint8_t pin, uint8_t *pixels, uint32_t numBytes, boolean is800KHz) {\n    // Reserve channel\n    rmt_channel_t channel = ADAFRUIT_RMT_CHANNEL_MAX;\n    for (size_t i = 0; i < ADAFRUIT_RMT_CHANNEL_MAX; i++) {\n        if (!rmt_reserved_channels[i]) {\n            rmt_reserved_channels[i] = true;\n            channel = i;\n            break;\n        }\n    }\n    if (channel == ADAFRUIT_RMT_CHANNEL_MAX) {\n        // Ran out of channels!\n        return;\n    }\n\n#if defined(HAS_ESP_IDF_4)\n    rmt_config_t config = RMT_DEFAULT_CONFIG_TX(pin, channel);\n    config.clk_div = 2;\n#else\n    // Match default TX config from ESP-IDF version 3.4\n    rmt_config_t config = {\n        .rmt_mode = RMT_MODE_TX,\n        .channel = channel,\n        .gpio_num = pin,\n        .clk_div = 2,\n        .mem_block_num = 1,\n        .tx_config = {\n            .carrier_freq_hz = 38000,\n            .carrier_level = RMT_CARRIER_LEVEL_HIGH,\n            .idle_level = RMT_IDLE_LEVEL_LOW,\n            .carrier_duty_percent = 33,\n            .carrier_en = false,\n            .loop_en = false,\n            .idle_output_en = true,\n        }\n    };\n#endif\n    rmt_config(&config);\n    rmt_driver_install(config.channel, 0, 0);\n\n    // Convert NS timings to ticks\n    uint32_t counter_clk_hz = 0;\n\n#if defined(HAS_ESP_IDF_4)\n    rmt_get_counter_clock(channel, &counter_clk_hz);\n#else\n    // this emulates the rmt_get_counter_clock() function from ESP-IDF 3.4\n    if (RMT_LL_HW_BASE->conf_ch[config.channel].conf1.ref_always_on == RMT_BASECLK_REF) {\n        uint32_t div_cnt = RMT_LL_HW_BASE->conf_ch[config.channel].conf0.div_cnt;\n        uint32_t div = div_cnt == 0 ? 256 : div_cnt;\n        counter_clk_hz = REF_CLK_FREQ / (div);\n    } else {\n        uint32_t div_cnt = RMT_LL_HW_BASE->conf_ch[config.channel].conf0.div_cnt;\n        uint32_t div = div_cnt == 0 ? 256 : div_cnt;\n        counter_clk_hz = APB_CLK_FREQ / (div);\n    }\n#endif\n\n    // NS to tick converter\n    float ratio = (float)counter_clk_hz / 1e9;\n\n    if (is800KHz) {\n        t0h_ticks = (uint32_t)(ratio * WS2812_T0H_NS);\n        t0l_ticks = (uint32_t)(ratio * WS2812_T0L_NS);\n        t1h_ticks = (uint32_t)(ratio * WS2812_T1H_NS);\n        t1l_ticks = (uint32_t)(ratio * WS2812_T1L_NS);\n    } else {\n        t0h_ticks = (uint32_t)(ratio * WS2811_T0H_NS);\n        t0l_ticks = (uint32_t)(ratio * WS2811_T0L_NS);\n        t1h_ticks = (uint32_t)(ratio * WS2811_T1H_NS);\n        t1l_ticks = (uint32_t)(ratio * WS2811_T1L_NS);\n    }\n\n    // Initialize automatic timing translator\n    rmt_translator_init(config.channel, ws2812_rmt_adapter);\n\n    // Write and wait to finish\n    rmt_write_sample(config.channel, pixels, (size_t)numBytes, true);\n    rmt_wait_tx_done(config.channel, pdMS_TO_TICKS(100));\n\n    // Free channel again\n    rmt_driver_uninstall(config.channel);\n    rmt_reserved_channels[channel] = false;\n\n    gpio_set_direction(pin, GPIO_MODE_OUTPUT);\n}\n\n#endif // ifndef IDF5\n \n\n#endif // ifdef(ESP32)\n"
        },
        {
          "name": "esp8266.c",
          "type": "blob",
          "size": 2.3935546875,
          "content": "// This is a mash-up of the Due show() code + insights from Michael Miller's\n// ESP8266 work for the NeoPixelBus library: github.com/Makuna/NeoPixelBus\n// Needs to be a separate .c file to enforce ICACHE_RAM_ATTR execution.\n\n#if defined(ESP8266)\n\n#include <Arduino.h>\n#ifdef ESP8266\n#include <eagle_soc.h>\n#endif\n\nstatic uint32_t _getCycleCount(void) __attribute__((always_inline));\nstatic inline uint32_t _getCycleCount(void) {\n  uint32_t ccount;\n  __asm__ __volatile__(\"rsr %0,ccount\":\"=a\" (ccount));\n  return ccount;\n}\n\n#ifdef ESP8266\nIRAM_ATTR void espShow(\n uint8_t pin, uint8_t *pixels, uint32_t numBytes, __attribute__((unused)) boolean is800KHz) {\n#else\nvoid espShow(\n uint8_t pin, uint8_t *pixels, uint32_t numBytes, boolean is800KHz) {\n#endif\n\n#define CYCLES_800_T0H  (F_CPU / 2500001) // 0.4us\n#define CYCLES_800_T1H  (F_CPU / 1250001) // 0.8us\n#define CYCLES_800      (F_CPU /  800001) // 1.25us per bit\n#define CYCLES_400_T0H  (F_CPU / 2000000) // 0.5uS\n#define CYCLES_400_T1H  (F_CPU /  833333) // 1.2us\n#define CYCLES_400      (F_CPU /  400000) // 2.5us per bit\n\n  uint8_t *p, *end, pix, mask;\n  uint32_t t, time0, time1, period, c, startTime;\n\n#ifdef ESP8266\n  uint32_t pinMask;\n  pinMask   = _BV(pin);\n#endif\n\n  p         =  pixels;\n  end       =  p + numBytes;\n  pix       = *p++;\n  mask      = 0x80;\n  startTime = 0;\n\n#ifdef NEO_KHZ400\n  if(is800KHz) {\n#endif\n    time0  = CYCLES_800_T0H;\n    time1  = CYCLES_800_T1H;\n    period = CYCLES_800;\n#ifdef NEO_KHZ400\n  } else { // 400 KHz bitstream\n    time0  = CYCLES_400_T0H;\n    time1  = CYCLES_400_T1H;\n    period = CYCLES_400;\n  }\n#endif\n\n  for(t = time0;; t = time0) {\n    if(pix & mask) t = time1;                             // Bit high duration\n    while(((c = _getCycleCount()) - startTime) < period); // Wait for bit start\n#ifdef ESP8266\n    GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, pinMask);       // Set high\n#else\n    gpio_set_level(pin, HIGH);\n#endif\n    startTime = c;                                        // Save start time\n    while(((c = _getCycleCount()) - startTime) < t);      // Wait high duration\n#ifdef ESP8266\n    GPIO_REG_WRITE(GPIO_OUT_W1TC_ADDRESS, pinMask);       // Set low\n#else\n    gpio_set_level(pin, LOW);\n#endif\n    if(!(mask >>= 1)) {                                   // Next bit/byte\n      if(p >= end) break;\n      pix  = *p++;\n      mask = 0x80;\n    }\n  }\n  while((_getCycleCount() - startTime) < period); // Wait for last bit\n}\n\n#endif // ESP8266\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "kendyte_k210.c",
          "type": "blob",
          "size": 2.06640625,
          "content": "// This is a mash-up of the Due show() code + insights from Michael Miller's\n// ESP8266 work for the NeoPixelBus library: github.com/Makuna/NeoPixelBus\n// Needs to be a separate .c file to enforce ICACHE_RAM_ATTR execution.\n#if defined(K210) \n#define KENDRYTE_K210 1\n#endif\n\n#if defined(KENDRYTE_K210)\n\n#include <Arduino.h>\n#include \"sysctl.h\"\n\nvoid  k210Show(\n    uint8_t pin, uint8_t *pixels, uint32_t numBytes, boolean is800KHz)\n{\n\n#define CYCLES_800_T0H (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 2500000) // 0.4us\n#define CYCLES_800_T1H (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 1250000) // 0.8us\n#define CYCLES_800 (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 800000)      // 1.25us per bit\n#define CYCLES_400_T0H (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 2000000) // 0.5uS\n#define CYCLES_400_T1H (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 833333)  // 1.2us\n#define CYCLES_400 (sysctl_clock_get_freq(SYSCTL_CLOCK_CPU) / 400000)      // 2.5us per bit\n\n    uint8_t *p, *end, pix, mask;\n    uint32_t t, time0, time1, period, c, startTime;\n\n    p = pixels;\n    end = p + numBytes;\n    pix = *p++;\n    mask = 0x80;\n    startTime = 0;\n\n#ifdef NEO_KHZ400\n    if (is800KHz)\n    {\n#endif\n        time0 = CYCLES_800_T0H;\n        time1 = CYCLES_800_T1H;\n        period = CYCLES_800;\n#ifdef NEO_KHZ400\n    }\n    else\n    { // 400 KHz bitstream\n        time0 = CYCLES_400_T0H;\n        time1 = CYCLES_400_T1H;\n        period = CYCLES_400;\n    }\n#endif\n\n    for (t = time0;; t = time0)\n    {\n        if (pix & mask)\n            t = time1; // Bit high duration\n        while (((c = read_cycle()) - startTime) < period)\n            ; // Wait for bit start\n        digitalWrite(pin, HIGH);\n        startTime = c; // Save start time\n        while (((c = read_cycle()) - startTime) < t)\n            ; // Wait high duration\n        digitalWrite(pin, LOW);\n\n        if (!(mask >>= 1))\n        { // Next bit/byte\n            if (p >= end)\n                break;\n            pix = *p++;\n            mask = 0x80;\n        }\n    }\n    while ((read_cycle() - startTime) < period)\n        ; // Wait for last bit\n}\n\n#endif // KENDRYTE_K210\n"
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 1.4150390625,
          "content": "#######################################\n# Syntax Coloring Map For Adafruit_NeoPixel\n#######################################\n# Class\n#######################################\n\nAdafruit_NeoPixel\tKEYWORD1\n\n#######################################\n# Methods and Functions\n#######################################\t\n\nbegin\t\t\tKEYWORD2\nshow\t\t\tKEYWORD2\nsetPin\t\t\tKEYWORD2\nsetPixelColor\t\tKEYWORD2\nfill\t\t\tKEYWORD2\nsetBrightness\t\tKEYWORD2\nclear\t\t\tKEYWORD2\nupdateLength\t\tKEYWORD2\nupdateType\t\tKEYWORD2\ncanShow\t\t\tKEYWORD2\ngetPixels\t\tKEYWORD2\ngetBrightness\t\tKEYWORD2\ngetPin\t\t\tKEYWORD2\nnumPixels\t\tKEYWORD2\ngetPixelColor\t\tKEYWORD2\nsine8\t\t\tKEYWORD2\ngamma8\t\t\tKEYWORD2\nColor\t\t\tKEYWORD2\nColorHSV\t\tKEYWORD2\ngamma32\t\t\tKEYWORD2\n\n#######################################\n# Constants\n#######################################\n\nNEO_COLMASK\t\tLITERAL1\nNEO_SPDMASK\t\tLITERAL1\nNEO_KHZ800\t\tLITERAL1\nNEO_KHZ400\t\tLITERAL1\nNEO_RGB\t\t\tLITERAL1\nNEO_RBG\t\t\tLITERAL1\nNEO_GRB\t\t\tLITERAL1\nNEO_GBR\t\t\tLITERAL1\nNEO_BRG\t\t\tLITERAL1\nNEO_BGR\t\t\tLITERAL1\nNEO_WRGB\t\tLITERAL1\nNEO_WRBG\t\tLITERAL1\nNEO_WGRB\t\tLITERAL1\nNEO_WGBR\t\tLITERAL1\nNEO_WBRG\t\tLITERAL1\nNEO_WBGR\t\tLITERAL1\nNEO_RWGB\t\tLITERAL1\nNEO_RWBG\t\tLITERAL1\nNEO_RGWB\t\tLITERAL1\nNEO_RGBW\t\tLITERAL1\nNEO_RBWG\t\tLITERAL1\nNEO_RBGW\t\tLITERAL1\nNEO_GWRB\t\tLITERAL1\nNEO_GWBR\t\tLITERAL1\nNEO_GRWB\t\tLITERAL1\nNEO_GRBW\t\tLITERAL1\nNEO_GBWR\t\tLITERAL1\nNEO_GBRW\t\tLITERAL1\nNEO_BWRG\t\tLITERAL1\nNEO_BWGR\t\tLITERAL1\nNEO_BRWG\t\tLITERAL1\nNEO_BRGW\t\tLITERAL1\nNEO_BGWR\t\tLITERAL1\nNEO_BGRW\t\tLITERAL1\n\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.3603515625,
          "content": "name=Adafruit NeoPixel\nversion=1.12.3\nauthor=Adafruit\nmaintainer=Adafruit <info@adafruit.com>\nsentence=Arduino library for controlling single-wire-based LED pixels and strip.\nparagraph=Arduino library for controlling single-wire-based LED pixels and strip.\ncategory=Display\nurl=https://github.com/adafruit/Adafruit_NeoPixel\narchitectures=*\nincludes=Adafruit_NeoPixel.h\n"
        },
        {
          "name": "rp2040_pio.h",
          "type": "blob",
          "size": 1.9423828125,
          "content": "// -------------------------------------------------- //\n// This file is autogenerated by pioasm; do not edit! //\n// -------------------------------------------------- //\n\n// Unless you know what you are doing...\n// Lines 47 and 52 have been edited to set transmit bit count\n\n#if !PICO_NO_HARDWARE\n#include \"hardware/pio.h\"\n#endif\n\n// ------ //\n// ws2812 //\n// ------ //\n\n#define ws2812_wrap_target 0\n#define ws2812_wrap 3\n\n#define ws2812_T1 2\n#define ws2812_T2 5\n#define ws2812_T3 3\n\nstatic const uint16_t ws2812_program_instructions[] = {\n    //     .wrap_target\n    0x6221, //  0: out    x, 1            side 0 [2]\n    0x1123, //  1: jmp    !x, 3           side 1 [1]\n    0x1400, //  2: jmp    0               side 1 [4]\n    0xa442, //  3: nop                    side 0 [4]\n            //     .wrap\n};\n\n#if !PICO_NO_HARDWARE\nstatic const struct pio_program ws2812_program = {\n    .instructions = ws2812_program_instructions,\n    .length = 4,\n    .origin = -1,\n};\n\nstatic inline pio_sm_config ws2812_program_get_default_config(uint offset) {\n  pio_sm_config c = pio_get_default_sm_config();\n  sm_config_set_wrap(&c, offset + ws2812_wrap_target, offset + ws2812_wrap);\n  sm_config_set_sideset(&c, 1, false, false);\n  return c;\n}\n\n#include \"hardware/clocks.h\"\nstatic inline void ws2812_program_init(PIO pio, uint sm, uint offset, uint pin,\n                                       float freq, uint bits) {\n  pio_gpio_init(pio, pin);\n  pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);\n  pio_sm_config c = ws2812_program_get_default_config(offset);\n  sm_config_set_sideset_pins(&c, pin);\n  sm_config_set_out_shift(&c, false, true,\n                          bits); // <----<<< Length changed to \"bits\"\n  sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);\n  int cycles_per_bit = ws2812_T1 + ws2812_T2 + ws2812_T3;\n  float div = clock_get_hz(clk_sys) / (freq * cycles_per_bit);\n  sm_config_set_clkdiv(&c, div);\n  pio_sm_init(pio, sm, offset, &c);\n  pio_sm_set_enabled(pio, sm, true);\n}\n\n#endif\n"
        }
      ]
    }
  ]
}