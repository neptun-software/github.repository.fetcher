{
  "metadata": {
    "timestamp": 1736565528352,
    "page": 402,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "GodotSteam/GodotSteam",
      "stars": 2978,
      "defaultBranch": "godot4",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.392578125,
          "content": "# C/C++ generated\n*.a\n*.ax\n*.d\n*.dll\n*.lib\n*.lo\n*.o\n*.os\n*.ox\n*.Plo\n*.so\n\n# Python generated\n__pycache__/\n*.pyc\n\n# Steam SDK\nsdk/*\n!sdk/put SDK here\n\n# Doxygen\ndoxygen/\n\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.tlog\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.759765625,
          "content": "# Contributing Code To GodotSteam\n\nThanks for contributing to the GodotSteam source code! We only have a few minor rules for contributing code to make the whole process easier for everyone.\n\n1. Use camel-case for any new Steam function names; ie. newSteamFunction(), you can use snake_case for anything else.\n2. Use all lower-case, underscore-separated names for all variables and arguments; ie. new_argument, new_variable\n3. Make sure your new function names, variables, and argument clearly state what they are.\n4. Make sure your code compiles before submitting a pull-request.  You may want to use `scons platform=[your platform] production=yes target=editot` to test your editor build.\n\nSo far that's it!  Thanks again for helping make the project useful for the community!\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.35546875,
          "content": "# GodotSteam for Godot Engine 4.x | Community Edition\nAn ecosystem of tools for [Godot Engine](https://godotengine.org) and [Valve's Steam](https://store.steampowered.com). For the Windows, Linux, and Mac platforms.\n\nAdditional Flavors\n---\nPre-Compiles | Plug-ins | Server | Examples\n--- | --- | --- | ---\n[Godot 2.x](https://github.com/GodotSteam/GodotSteam/tree/godot2) | [GDNative](https://github.com/GodotSteam/GodotSteam/tree/gdnative) | [Server 3.x](https://github.com/GodotSteam/GodotSteam-Server/tree/godot3) | [Skillet](https://github.com/GodotSteam/Skillet)\n[Godot 3.x](https://github.com/GodotSteam/GodotSteam/tree/godot3) | [GDExtension](https://github.com/GodotSteam/GodotSteam/tree/gdextension) | [Server 4.x](https://github.com/GodotSteam/GodotSteam-Server/tree/godot4) | ---\n[Godot 4.x](https://github.com/GodotSteam/GodotSteam/tree/godot4) | --- | [GDNative](https://github.com/GodotSteam/GodotSteam-Server/tree/gdnative) | ---\n[MultiplayerPeer](https://github.com/GodotSteam/MultiplayerPeer)| --- | [GDExtension](https://github.com/GodotSteam/GodotSteam-Server/tree/gdextension) | ---\n\nDocumentation\n---\n[Documentation is available here](https://godotsteam.com). You can also check out the Search Help section inside Godot Engine.\n\nFeel free to chat with us about GodotSteam or ask for assistance on the [Discord server](https://discord.gg/SJRSq6K).\n\nDonate\n---\nPull-requests are the best way to help the project out but you can also donate through [Github Sponsors](https://github.com/sponsors/Gramps)!\n\nCurrent Build\n---\nYou can [download pre-compiled versions of this repo here](https://github.com/GodotSteam/GodotSteam/releases).\n\n**Version 4.12 Changes**\n- Added: new Timeline functions, call results, and enums\n- Added: new Inputs enums for Horipad; `INPUT_ACTION_ORIGIN`\n- Added: new Networking config enum `NETWORKING_CONFIG_SEND_TIME_SINCE_PREVIOUS_PACKET`\n- Added: new Networking config enums for fake packet jitter; `NETWORKING_CONFIG_FAKE_JITTER_`\n- Changed: `equipped_profile_items` callback now sends `from_cache` bool\n- Changed: first argument for `steamInit` and `steamInitEx` no longer calls for stats as they are synced by client; left to prevent compatibility breakage\n- Fixed: `getAchievement` and related achievement functions breaking under rare conditions\n- Fixed: incorrect type for `set_inventory_update_handle`\n- Removed: `setTimelineGameMode` function which was removed in 1.61\n- Removed: `current_stats_received` callback removed for redundancy\n- Removed: Google Stadia, Nintendo, Epic Games, and WeGame Networking identity types fully removed, from 1.61\n- Removed: unncessary commenting\n\n[You can read more change-logs here](https://godotsteam.com/changelog/godot4/).\n\nCompatibility\n---\nWhile rare, sometimes Steamworks SDK updates will break compatilibity with older GodotSteam versions. Any compatability breaks are noted below. Newer API files (dll, so, dylib) _should_ still work for older versions.\n\nSteamworks SDK Version | GodotSteam Version\n---|---\n1.61 or newer | 4.12 or newer\n1.60 | 4.6 to 4.11\n1.59 | 4.6 to 4.8\n1.58a or older | 4.5.4 or older\n\nVersions of GodotSteam that have compatibility breaks introduced.\n\nGodotSteam Version | Broken Compatibility\n---|---\n4.8 | Networking identity system removed, replaced with Steam IDs\n4.9 | sendMessages returns an Array\n4.11 | setLeaderboardDetailsMax removed\n\nKnown Issues\n---\n- Steam overlay will not work when running your game from the editor if you are using Forward+ as the renderer.  It does work with Compatibility though.  Your exported project will work perfectly fine in the Steam client, however.\n- When self-compiling, **do not** use MinGW as it will cause crashes.\n\nQuick How-To\n---\nFor complete instructions on how to build the Godot 4.x version of GodotSteam from scratch, [please refer to our documentation's 'How-To Modules' section.](https://godotsteam.com/howto/modules/) It will have the most up-to-date information.\n\nAlternatively, you can just [download the pre-compiled versions in our Releases section](https://github.com/GodotSteam/GodotSteam/releases) and skip compiling it yourself!\n\n[To start, check out our tutorial on initializing Steam.](https://godotsteam.com/tutorials/initializing/)  There are additional tutorials with more in the works.  You can also [check out additional Godot and Steam related videos, text, additional tools, plug-ins, etc. here.](https://godotsteam.com/tutorials/external/)\n\nLicense\n---\nMIT license\n"
        },
        {
          "name": "SCsub",
          "type": "blob",
          "size": 1.31640625,
          "content": "# SCsub\nImport('env')\n\nmodule_path = Dir('.').srcnode().abspath\n\nenv.Append(CPPPATH=[\"%s/sdk/public/\" % module_path])\n\n# If compiling Linux\nif env[\"platform\"]== \"linuxbsd\" or env[\"platform\"] == \"server\":\n\tenv.Append(LIBS=[\"steam_api\"])\n\tenv.Append(RPATH=env.Literal('\\\\$$ORIGIN'))\n\tif env['arch'] == \"x86_32\":\n\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin/linux32\" % module_path])\n\telse: # 64 bit\n\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin/linux64\" % module_path])\n\n# If compiling Windows\nelif env[\"platform\"] == \"windows\":\n\t# Mostly VisualStudio\n\tif env[\"CC\"] == \"cl\":\n\t\tif env['arch'] == \"x86_32\":\n\t\t\tenv.Append(LINKFLAGS=[\"steam_api.lib\"])\n\t\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin\" % module_path])\n\t\telse: # 64 bit\n\t\t\tenv.Append(LINKFLAGS=[\"steam_api64.lib\"])\n\t\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin/win64\" % module_path])\n\t\n\t# Mostly \"GCC\"\n\telse:\n\t\tif env['arch'] == \"x86_32\":\n\t\t\tenv.Append(LIBS=[\"steam_api\"])\n\t\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin\" % module_path])\n\t\telse: # 64 bit\n\t\t\tenv.Append(LIBS=[\"steam_api64\"])\n\t\t\tenv.Append(LIBPATH=[\"%s/sdk/redistributable_bin/win64\" % module_path])\n\n# If compiling OSX\nelif env[\"platform\"] == \"macos\":\n\tenv.Append(LIBS=[\"steam_api\"])\n\tenv.Append(LIBPATH=['%s/sdk/redistributable_bin/osx' % module_path])\n\nenv.add_source_files(env.modules_sources,\"*.cpp\")\n"
        },
        {
          "name": "config.py",
          "type": "blob",
          "size": 0.2373046875,
          "content": "def can_build(env, platform):\n\treturn platform==\"linuxbsd\" or platform==\"windows\" or platform==\"macos\" or platform==\"server\"\n\ndef configure(env):\n\tpass\n\ndef get_doc_classes():\n\treturn [\n\t\t\"Steam\",\n\t]\n\ndef get_doc_path():\n\treturn \"doc_classes\"\n"
        },
        {
          "name": "doc_classes",
          "type": "tree",
          "content": null
        },
        {
          "name": "godotsteam.cpp",
          "type": "blob",
          "size": 636.0966796875,
          "content": "// Turn off MSVC-only warning about strcpy\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS 1\n#pragma warning(disable : 4996)\n#pragma warning(disable : 4828)\n#endif\n\n\n// Include GodotSteam header\n#include \"godotsteam.h\"\n\n// Include some system headers\n#include \"fstream\"\n#include \"vector\"\n\n\nSteam *Steam::singleton = NULL;\n\n\nSteam::Steam() :\n\t// Apps\n\tcallbackDLCInstalled(this, &Steam::dlc_installed),\n\tcallbackFileDetailsResult(this, &Steam::file_details_result),\n\tcallbackNewLaunchURLParameters(this, &Steam::new_launch_url_parameters),\n\tcallbackTimedTrialStatus(this, &Steam::timed_trial_status),\n\n\t// Friends\n\tcallbackAvatarLoaded(this, &Steam::avatar_loaded),\n\tcallbackAvatarImageLoaded(this, &Steam::avatar_image_loaded),\n\tcallbackClanActivityDownloaded(this, &Steam::clan_activity_downloaded),\n\tcallbackFriendRichPresenceUpdate(this, &Steam::friend_rich_presence_update),\n\tcallbackConnectedChatJoin(this, &Steam::connected_chat_join),\n\tcallbackConnectedChatLeave(this, &Steam::connected_chat_leave),\n\tcallbackConnectedClanChatMessage(this, &Steam::connected_clan_chat_message),\n\tcallbackConnectedFriendChatMessage(this, &Steam::connected_friend_chat_message),\n\tcallbackJoinRequested(this, &Steam::join_requested),\n\tcallbackOverlayToggled(this, &Steam::overlay_toggled),\n\tcallbackJoinGameRequested(this, &Steam::join_game_requested),\n\tcallbackChangeServerRequested(this, &Steam::change_server_requested),\n\tcallbackJoinClanChatComplete(this, &Steam::join_clan_chat_complete),\n\tcallbackPersonaStateChange(this, &Steam::persona_state_change),\n\tcallbackNameChanged(this, &Steam::name_changed),\n\tcallbackOverlayBrowserProtocol(this, &Steam::overlay_browser_protocol),\n\tcallbackUnreadChatMessagesChanged(this, &Steam::unread_chat_messages_changed),\n\tcallbackEquippedProfileItemsChanged(this, &Steam::equipped_profile_items_changed),\n\n\t// Game Search\n\tcallbackSearchForGameProgress(this, &Steam::search_for_game_progress),\n\tcallbackSearchForGameResult(this, &Steam::search_for_game_result),\n\tcallbackRequestPlayersForGameProgress(this, &Steam::request_players_for_game_progress),\n\tcallbackRequestPlayersForGameResult(this, &Steam::request_players_for_game_result),\n\tcallbackRequestPlayersForGameFinalResult(this, &Steam::request_players_for_game_final_result),\n\tcallbackSubmitPlayerResult(this, &Steam::submit_player_result),\n\tcallbackEndGameResult(this, &Steam::end_game_result),\n\n\t// HTML Surface\n\tcallbackHTMLCanGoBackandforward(this, &Steam::html_can_go_backandforward),\n\tcallbackHTMLChangedTitle(this, &Steam::html_changed_title),\n\tcallbackHTMLCloseBrowser(this, &Steam::html_close_browser),\n\tcallbackHTMLFileOpenDialog(this, &Steam::html_file_open_dialog),\n\tcallbackHTMLFinishedRequest(this, &Steam::html_finished_request),\n\tcallbackHTMLHideTooltip(this, &Steam::html_hide_tooltip),\n\tcallbackHTMLHorizontalScroll(this, &Steam::html_horizontal_scroll),\n\tcallbackHTMLJSAlert(this, &Steam::html_js_alert),\n\tcallbackHTMLJSConfirm(this, &Steam::html_js_confirm),\n\tcallbackHTMLLinkAtPosition(this, &Steam::html_link_at_position),\n\tcallbackHTMLNeedsPaint(this, &Steam::html_needs_paint),\n\tcallbackHTMLNewWindow(this, &Steam::html_new_window),\n\tcallbackHTMLOpenLinkInNewTab(this, &Steam::html_open_link_in_new_tab),\n\tcallbackHTMLSearchResults(this, &Steam::html_search_results),\n\tcallbackHTMLSetCursor(this, &Steam::html_set_cursor),\n\tcallbackHTMLShowTooltip(this, &Steam::html_show_tooltip),\n\tcallbackHTMLStartRequest(this, &Steam::html_start_request),\n\tcallbackHTMLStatusText(this, &Steam::html_status_text),\n\tcallbackHTMLUpdateTooltip(this, &Steam::html_update_tooltip),\n\tcallbackHTMLURLChanged(this, &Steam::html_url_changed),\n\tcallbackHTMLVerticalScroll(this, &Steam::html_vertical_scroll),\n\n\t// HTTP\n\tcallbackHTTPRequestCompleted(this, &Steam::http_request_completed),\n\tcallbackHTTPRequestDataReceived(this, &Steam::http_request_data_received),\n\tcallbackHTTPRequestHeadersReceived(this, &Steam::http_request_headers_received),\n\n\t// Input\n\tcallbackInputDeviceConnected(this, &Steam::input_device_connected),\n\tcallbackInputDeviceDisconnected(this, &Steam::input_device_disconnected),\n\tcallbackInputConfigurationLoaded(this, &Steam::input_configuration_loaded),\n\tcallbackInputGamePadSlotChange(this, &Steam::input_gamepad_slot_change),\n\n\t// Inventory\n\tcallbackInventoryDefinitionUpdate(this, &Steam::inventory_definition_update),\n\tcallbackInventoryFullUpdate(this, &Steam::inventory_full_update),\n\tcallbackInventoryResultReady(this, &Steam::inventory_result_ready),\n\n\t// Matchmaking\n\tcallbackFavoritesListAccountsUpdated(this, &Steam::favorites_list_accounts_updated),\n\tcallbackFavoritesListChanged(this, &Steam::favorites_list_changed),\n\tcallbackLobbyMessage(this, &Steam::lobby_message),\n\tcallbackLobbyChatUpdate(this, &Steam::lobby_chat_update),\n\tcallbackLobbyDataUpdate(this, &Steam::lobby_data_update),\n\tcallbackLobbyJoined(this, &Steam::lobby_joined),\n\tcallbackLobbyGameCreated(this, &Steam::lobby_game_created),\n\tcallbackLobbyInvite(this, &Steam::lobby_invite),\n\tcallbackLobbyKicked(this, &Steam::lobby_kicked),\n\n\t// Music\n\tcallbackMusicPlaybackStatusHasChanged(this, &Steam::music_playback_status_has_changed),\n\tcallbackMusicVolumeHasChanged(this, &Steam::music_volume_has_changed),\n\n\t// Music Remote\n\tcallbackMusicPlayerRemoteToFront(this, &Steam::music_player_remote_to_front),\n\tcallbackMusicPlayerRemoteWillActivate(this, &Steam::music_player_remote_will_activate),\n\tcallbackMusicPlayerRemoteWillDeactivate(this, &Steam::music_player_remote_will_deactivate),\n\tcallbackMusicPlayerSelectsPlaylistEntry(this, &Steam::music_player_selects_playlist_entry),\n\tcallbackMusicPlayerSelectsQueueEntry(this, &Steam::music_player_selects_queue_entry),\n\tcallbackMusicPlayerWantsLooped(this, &Steam::music_player_wants_looped),\n\tcallbackMusicPlayerWantsPause(this, &Steam::music_player_wants_pause),\n\tcallbackMusicPlayerWantsPlayingRepeatStatus(this, &Steam::music_player_wants_playing_repeat_status),\n\tcallbackMusicPlayerWantsPlayNext(this, &Steam::music_player_wants_play_next),\n\tcallbackMusicPlayerWantsPlayPrevious(this, &Steam::music_player_wants_play_previous),\n\tcallbackMusicPlayerWantsPlay(this, &Steam::music_player_wants_play),\n\tcallbackMusicPlayerWantsShuffled(this, &Steam::music_player_wants_shuffled),\n\tcallbackMusicPlayerWantsVolume(this, &Steam::music_player_wants_volume),\n\tcallbackMusicPlayerWillQuit(this, &Steam::music_player_will_quit),\n\n\t// Networking\n\tcallbackP2PSessionConnectFail(this, &Steam::p2p_session_connect_fail),\n\tcallbackP2PSessionRequest(this, &Steam::p2p_session_request),\n\n\t// Networking Messages\n\tcallbackNetworkMessagesSessionRequest(this, &Steam::network_messages_session_request),\n\tcallbackNetworkMessagesSessionFailed(this, &Steam::network_messages_session_failed),\n\n\t// Networking Sockets\n\tcallbackNetworkConnectionStatusChanged(this, &Steam::network_connection_status_changed),\n\tcallbackNetworkAuthenticationStatus(this, &Steam::network_authentication_status),\n\tcallbackNetworkingFakeIPResult(this, &Steam::fake_ip_result),\n\n\t// Networking Utils\n\tcallbackRelayNetworkStatus(this, &Steam::relay_network_status),\n\n\t// Parental Settings\n\tcallbackParentlSettingChanged(this, &Steam::parental_setting_changed),\n\n\t// Parties\n\tcallbackReserveNotification(this, &Steam::reservation_notification),\n\tcallbackAvailableBeaconLocationsUpdated(this, &Steam::available_beacon_locations_updated),\n\tcallbackActiveBeaconsUpdated(this, &Steam::active_beacons_updated),\n\n\t// Remote Play\n\tcallbackRemotePlaySessionConnected(this, &Steam::remote_play_session_connected),\n\tcallbackRemotePlaySessionDisconnected(this, &Steam::remote_play_session_disconnected),\n\n\t// Remote Storage\n\tcallbackLocalFileChanged(this, &Steam::local_file_changed),\n\n\t// Screenshot\n\tcallbackScreenshotReady(this, &Steam::screenshot_ready),\n\tcallbackScreenshotRequested(this, &Steam::screenshot_requested),\n\n\t// UGC\n\tcallbackItemDownloaded(this, &Steam::item_downloaded),\n\tcallbackItemInstalled(this, &Steam::item_installed),\n\tcallbackUserSubscribedItemsListChanged(this, &Steam::user_subscribed_items_list_changed),\n\n\t// User\n\tcallbackClientGameServerDeny(this, &Steam::client_game_server_deny),\n\tcallbackGameWebCallback(this, &Steam::game_web_callback),\n\tcallbackGetAuthSessionTicketResponse(this, &Steam::get_auth_session_ticket_response),\n\tcallbackGetTicketForWebApiResponse(this, &Steam::get_ticket_for_web_api),\n\tcallbackIPCFailure(this, &Steam::ipc_failure),\n\tcallbackLicensesUpdated(this, &Steam::licenses_updated),\n\tcallbackMicrotransactionAuthResponse(this, &Steam::microtransaction_auth_response),\n\tcallbackSteamServerConnected(this, &Steam::steam_server_connected),\n\tcallbackSteamServerDisconnected(this, &Steam::steam_server_disconnected),\n\tcallbackValidateAuthTicketResponse(this, &Steam::validate_auth_ticket_response),\n\n\t// User Stats\n\tcallbackUserAchievementIconFetched(this, &Steam::user_achievement_icon_fetched),\n\tcallbackUserAchievementStored(this, &Steam::user_achievement_stored),\n\tcallbackUserStatsStored(this, &Steam::user_stats_stored),\n\tcallbackUserStatsUnloaded(this, &Steam::user_stats_unloaded),\n\n\t// Utility\n\tcallbackGamepadTextInputDismissed(this, &Steam::gamepad_text_input_dismissed),\n\tcallbackIPCountry(this, &Steam::ip_country),\n\tcallbackLowPower(this, &Steam::low_power),\n\tcallbackSteamAPICallCompleted(this, &Steam::steam_api_call_completed),\n\tcallbackSteamShutdown(this, &Steam::steam_shutdown),\n\tcallbackAppResumingFromSuspend(this, &Steam::app_resuming_from_suspend),\n\tcallbackFloatingGamepadTextInputDismissed(this, &Steam::floating_gamepad_text_input_dismissed),\n\tcallbackFilterTextDictionaryChanged(this, &Steam::filter_text_dictionary_changed),\n\n\t// Video\n\tcallbackGetOPFSettingsResult(this, &Steam::get_opf_settings_result),\n\tcallbackGetVideoResult(this, &Steam::get_video_result)\n{\n\tis_init_success = false;\n\tsingleton = this;\n\twere_callbacks_embedded = false;\n}\n\n\n///// INTERNAL\n\n// Helper function to turn an array of options into an array of SteamNetworkingConfigValue_t structs\n// These arrays contain dictionaries of { NetworkingConfigValue enum : value for config }\nconst SteamNetworkingConfigValue_t *Steam::convert_config_options(Dictionary config_options) {\n\tuint32 options_size = config_options.size();\n\tSteamNetworkingConfigValue_t *option_array = new SteamNetworkingConfigValue_t[options_size];\n\n\tif (options_size > 0) {\n\t\tfor (uint32 i = 0; i < options_size; i++) {\n\t\t\tSteamNetworkingConfigValue_t this_option;\n\t\t\tint sent_option = (int)config_options.keys()[i];\n\n\t\t\t// Get the configuration value.\n\t\t\t// This is a convoluted way of doing it but can't seem to cast the value as an enum so here we are.\n\t\t\tESteamNetworkingConfigValue this_value = ESteamNetworkingConfigValue((int)sent_option);\n\t\t\tVariant::Type value_type = config_options[sent_option].get_type();\n\t\t\tif (value_type == Variant::INT) {\n\t\t\t\tif (sent_option == NETWORKING_CONFIG_CONNECTION_USER_DATA) {\n\t\t\t\t\tthis_option.SetInt64(this_value, config_options[sent_option]);\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tthis_option.SetInt32(this_value, config_options[sent_option]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (value_type == Variant::FLOAT) {\n\t\t\t\tthis_option.SetFloat(this_value, config_options[sent_option]);\n\t\t\t}\n\t\t\telse if (value_type == Variant::STRING) {\n\t\t\t\tthis_option.SetString(this_value, String(config_options[sent_option]).utf8().get_data());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject *this_pointer;\n\t\t\t\tthis_pointer = config_options[sent_option];\n\t\t\t\tthis_option.SetPtr(this_value, this_pointer);\n\t\t\t}\n\t\t\toption_array[i] = this_option;\n\t\t}\n\t}\n\treturn option_array;\n}\n\n// Creating a Steam ID for internal use\nCSteamID Steam::createSteamID(uint64_t steam_id, AccountType account_type) {\n\tCSteamID converted_steam_id;\n\tif (account_type < 0 || account_type >= AccountType(k_EAccountTypeMax)) {\n\t\taccount_type = ACCOUNT_TYPE_INDIVIDUAL;\n\t}\n\tconverted_steam_id.Set(steam_id, k_EUniversePublic, EAccountType(account_type));\n\treturn converted_steam_id;\n}\n\n// A helper function for creating game server dictionaries\nDictionary Steam::gameServerItemToDictionary(gameserveritem_t *server_item) {\n\tDictionary game_server;\n\tif (server_item != NULL) {\n\t\tgame_server[\"name\"] = server_item->GetName();\n\t\tgame_server[\"connection_address\"] = server_item->m_NetAdr.GetConnectionAddressString();\n\t\tgame_server[\"query_address\"] = server_item->m_NetAdr.GetQueryAddressString();\n\t\tgame_server[\"ping\"] = server_item->m_nPing;\n\t\tgame_server[\"success_response\"] = server_item->m_bHadSuccessfulResponse;\n\t\tgame_server[\"no_refresh\"] = server_item->m_bDoNotRefresh;\n\t\tgame_server[\"game_dir\"] = server_item->m_szGameDir;\n\t\tgame_server[\"map\"] = server_item->m_szMap;\n\t\tgame_server[\"description\"] = server_item->m_szGameDescription;\n\t\tgame_server[\"app_id\"] = server_item->m_nAppID;\n\t\tgame_server[\"players\"] = server_item->m_nPlayers;\n\t\tgame_server[\"max_players\"] = server_item->m_nMaxPlayers;\n\t\tgame_server[\"bot_players\"] = server_item->m_nBotPlayers;\n\t\tgame_server[\"password\"] = server_item->m_bPassword;\n\t\tgame_server[\"secure\"] = server_item->m_bSecure;\n\t\tgame_server[\"last_played\"] = server_item->m_ulTimeLastPlayed;\n\t\tgame_server[\"server_version\"] = server_item->m_nServerVersion;\n\t\tgame_server[\"game_tags\"] = server_item->m_szGameTags;\n\t\tgame_server[\"steam_id\"] = (uint64_t)server_item->m_steamID.ConvertToUint64();\n\t}\n\treturn game_server;\n}\n\n// Get the Steam singleton, obviously\nSteam *Steam::get_singleton() {\n\treturn singleton;\n}\n\n// Convert a Steam ID to a Steam Identity\nSteamNetworkingIdentity Steam::getIdentityFromSteamID(uint64_t steam_id) {\n\tSteamNetworkingIdentity remote_identity;\n\tremote_identity.SetSteamID64(steam_id);\n\treturn remote_identity;\n}\n\n// Convert a string IP address to an integer\nuint32 Steam::getIPFromString(String ip_string) {\n\tuint32 ip_address = 0;\n\n\tSteamNetworkingIPAddr this_address;\n\tthis_address.Clear();\n\t\n\tif (this_address.ParseString(ip_string.utf8().get_data())) {\n\t\tip_address = this_address.GetIPv4();\n\t}\n\treturn ip_address;\n}\n\n// Convert a Steam IP Address object to an integer\nuint32 Steam::getIPFromSteamIP(SteamNetworkingIPAddr this_address) {\n\treturn this_address.GetIPv4();\n}\n\n// Get the Steam ID from an identity struct\nuint64_t Steam::getSteamIDFromIdentity(SteamNetworkingIdentity this_identity) {\n\tuint64_t this_steam_id = this_identity.GetSteamID64();\n\treturn this_steam_id;\n}\n\n// Convert an integer to a Steam IP Address\nSteamNetworkingIPAddr Steam::getSteamIPFromInt(uint32 ip_integer) {\n\tSteamNetworkingIPAddr this_address;\n\tthis_address.Clear();\n\n\tif (ip_integer > 0) {\n\t\tthis_address.SetIPv4(ip_integer, 0);\n\t}\n\treturn this_address;\n}\n\n// Convert an IP string to a Steam IP Address\nSteamNetworkingIPAddr Steam::getSteamIPFromString(String ip_string) {\n\tSteamNetworkingIPAddr this_address;\n\tthis_address.Clear();\n\t\n\tif (this_address.ParseString(ip_string.utf8().get_data())) {\n\t\tthis_address.GetIPv4();\n\t}\n\treturn this_address;\n}\n\n// Convert an integer IP address to a string\nString Steam::getStringFromIP(uint32 ip_integer) {\n\tString ip_address = \"\";\n\n\tSteamNetworkingIPAddr this_address;\n\tthis_address.Clear();\n\n\tif (ip_integer > 0) {\n\t\tthis_address.SetIPv4(ip_integer, 0);\n\t\tchar this_ip[SteamNetworkingIPAddr::k_cchMaxString];\n\t\tthis_address.ToString(this_ip, std::size(this_ip), false);\n\t\tip_address = String(this_ip);\n\t}\n\treturn ip_address;\n}\n\n// Convert a Steam IP Address to a string\nString Steam::getStringFromSteamIP(SteamNetworkingIPAddr this_address) {\n\tchar this_ip[SteamNetworkingIPAddr::k_cchMaxString];\n\tthis_address.ToString(this_ip, std::size(this_ip), false);\n\treturn String(this_ip);\n}\n\n\n///// MAIN FUNCTIONS\n\n// Convert a SteamID64 into a SteamID\nuint32_t Steam::getSteamID32(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.GetAccountID();\n}\n\n// Is this an anonymous account?\nbool Steam::isAnonAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BAnonAccount();\n}\n\n// Is this an anonymous user account? Used to create an account or reset a password, but do not try to do this.\nbool Steam::isAnonUserAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BAnonUserAccount();\n}\n\n// Is this a chat account ID?\nbool Steam::isChatAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BChatAccount();\n}\n\n// Is this a clan account ID?\nbool Steam::isClanAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BClanAccount();\n}\n\n// Is this a faked up Steam ID for a PSN friend account?\nbool Steam::isConsoleUserAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BConsoleUserAccount();\n}\n\n// Is this an individual user account ID?\nbool Steam::isIndividualAccount(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.BIndividualAccount();\n}\n\n// Is this a lobby account ID?\nbool Steam::isLobby(uint64_t steam_id) {\n\tCSteamID this_steam_id = (uint64)steam_id;\n\treturn this_steam_id.IsLobby();\n}\n\n// Returns true/false if Steam is running.\nbool Steam::isSteamRunning(void) {\n\treturn SteamAPI_IsSteamRunning();\n}\n\n// Checks if your executable was launched through Steam and relaunches it through Steam if it wasn't.\nbool Steam::restartAppIfNecessary(uint32 app_id) {\n\treturn SteamAPI_RestartAppIfNecessary((AppId_t)app_id);\n}\n\n// Initialize the SDK, without worrying about the cause of failure.\nDictionary Steam::steamInit(bool retrieve_stats, uint32_t app_id, bool embed_callbacks) {\n\tif (app_id != 0) {\n\t\tOS::get_singleton()->set_environment(\"SteamAppId\", itos(app_id));\n\t\tOS::get_singleton()->set_environment(\"SteamGameId\", itos(app_id));\n\t}\n\n\tDictionary initialize;\n\tis_init_success = SteamAPI_Init();\n\n\tint status = RESULT_FAIL;\n\tString verbal = \"Steamworks failed to initialize.\";\n\n\tif (is_init_success) {\n\t\tstatus = RESULT_OK;\n\t\tverbal = \"Steamworks active.\";\n\n\t\tcurrent_app_id = app_id;\n\t\tcurrent_steam_id = SteamUser()->GetSteamID().ConvertToUint64();\n\n\t\t// Attach the callbacks, if set\n\t\tif (embed_callbacks) {\n\t\t\twere_callbacks_embedded = true;\n\n\t\t\tauto callbacks = callable_mp(Steam::singleton, &Steam::run_callbacks);\n\t\t\tSceneTree::get_singleton()->connect(\"process_frame\", callbacks);\n\t\t}\n\t}\n\telse {\n\t\t// The Steam client is not running\n\t\tif (!isSteamRunning()) {\n\t\t\tstatus = RESULT_SERVICE_UNAVAILABLE;\n\t\t\tverbal = \"Steam not running\";\n\t\t}\n\t\t// I'm not totally sure how this actually means the app ID isn't installed?  This basically says that\n\t\t// Steamworks isn't present or that specific class.\n\t\telse if (SteamUser() == NULL) {\n\t\t\tstatus = RESULT_UNEXPECTED_ERROR;\n\t\t\tverbal = \"Invalid app ID or app not installed\";\n\t\t}\n\t}\n\n\tinitialize[\"status\"] = status;\n\tinitialize[\"verbal\"] = verbal;\n\n\treturn initialize;\n}\n\n// Initialize the Steamworks SDK. On success STEAM_API_INIT_RESULT_OK is returned.\n// Otherwise, if error_message is non-NULL, it will receive a non-localized message that explains the reason for the failure.\nDictionary Steam::steamInitEx(bool retrieve_stats, uint32_t app_id, bool embed_callbacks) {\n\t// Set the app ID\n\tif (app_id != 0) {\n\t\tOS::get_singleton()->set_environment(\"SteamAppId\", itos(app_id));\n\t\tOS::get_singleton()->set_environment(\"SteamGameId\", itos(app_id));\n\t}\n\t\n\t// Start the initialization process\n\tDictionary initialize;\n\tchar error_message[STEAM_MAX_ERROR_MESSAGE];\n\tESteamAPIInitResult initialize_result;\n\n\tinitialize_result = SteamAPI_InitEx(&error_message);\n\n\tif (initialize_result == (ESteamAPIInitResult)STEAM_API_INIT_RESULT_OK) {\n\t\tis_init_success = true;\n\t\tcurrent_app_id = app_id;\n\t\tcurrent_steam_id = SteamUser()->GetSteamID().ConvertToUint64();\n\n\t\t// Attach the callbacks, if set\n\t\tif (embed_callbacks) {\n\t\t\twere_callbacks_embedded = true;\n\n\t\t\tauto callbacks = callable_mp(Steam::singleton, &Steam::run_callbacks);\n\t\t\tSceneTree::get_singleton()->connect(\"process_frame\", callbacks);\n\t\t}\n\t}\n\tinitialize[\"status\"] = initialize_result;\n\tinitialize[\"verbal\"] = error_message;\n\n\treturn initialize;\n}\n\n// Shuts down the Steamworks API, releases pointers and frees memory.\nvoid Steam::steamShutdown() {\n\tSteamAPI_Shutdown();\n\n\t// If callbacks were connected internally\n\tif (were_callbacks_embedded) {\n\t\twere_callbacks_embedded = false;\n\n\t\tauto callbacks = callable_mp(Steam::singleton, &Steam::run_callbacks);\n\t\tSceneTree::get_singleton()->disconnect(\"process_frame\", callbacks);\n\t}\n}\n\n\n///// APPS\n\n// Return the build ID for this app; will change based on backend updates.\nint Steam::getAppBuildId() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, 0, \"[STEAM] Apps class not found when calling: getAppBuildId\");\n\treturn SteamApps()->GetAppBuildId();\n}\n\n// Gets the install folder for a specific AppID.\nDictionary Steam::getAppInstallDir(uint32_t app_id) {\n\tDictionary app_install;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, app_install, \"[STEAM] Apps class not found when calling: getAppInstallDir\");\n\tchar buffer[STEAM_BUFFER_SIZE]{};\n\tuint32 install_size = SteamApps()->GetAppInstallDir((AppId_t)app_id, buffer, STEAM_BUFFER_SIZE);\n\tString install_directory = buffer;\n\t// If we get no install directory, mention a possible cause\n\tif (install_directory.is_empty()) {\n\t\tinstall_directory = \"Possible wrong app ID or missing depot\";\n\t}\n\tapp_install[\"directory\"] = install_directory;\n\tapp_install[\"install_size\"] = install_size;\n\treturn app_install;\n}\n\n// Gets the Steam ID of the original owner of the current app. If it's different from the current user then it is borrowed.\nuint64_t Steam::getAppOwner() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, 0, \"[STEAM] Apps class not found when calling: getAppOwner\");\n\tCSteamID converted_steam_id = SteamApps()->GetAppOwner();\n\treturn converted_steam_id.ConvertToUint64();\n}\n\n// Gets a comma separated list of the languages the current app supports.\nString Steam::getAvailableGameLanguages() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, \"None\", \"[STEAM] Apps class not found when calling: getAppOwner\");\n\treturn SteamApps()->GetAvailableGameLanguages();\n}\n\n// Return beta branch details, name, description, current build ID and state flags (BetaBranchFlags).\nDictionary Steam::getBetaInfo() {\n\tDictionary beta_info;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, beta_info, \"[STEAM] Apps class not found when calling: getBetaInfo\");\n\tint beta_index = 0;\n\tuint32 beta_flags = 0;\n\tuint32 beta_build_id = 0;\n\tchar beta_name[STEAM_LARGE_BUFFER_SIZE];\n\tchar beta_description[STEAM_LARGE_BUFFER_SIZE];\n\tif (SteamApps()->GetBetaInfo(beta_index, &beta_flags, &beta_build_id, beta_name, STEAM_LARGE_BUFFER_SIZE, beta_description, STEAM_LARGE_BUFFER_SIZE)){\n\t\tbeta_info[\"index\"] = beta_index;\n\t\tbeta_info[\"flags\"] = beta_flags;\n\t\tbeta_info[\"build_id\"] = beta_build_id;\n\t\tbeta_info[\"name\"] = String(beta_name);\n\t\tbeta_info[\"description\"] = String(beta_description);\n\t}\n\treturn beta_info;\n}\n\n// Checks if the user is running from a beta branch, and gets the name of the branch if they are.\nString Steam::getCurrentBetaName() {\n\tString beta_name = \"\";\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, beta_name, \"[STEAM] Apps class not found when calling: getCurrentBetaName\");\n\tchar name_string[STEAM_LARGE_BUFFER_SIZE];\n\tif (SteamApps()->GetCurrentBetaName(name_string, STEAM_LARGE_BUFFER_SIZE)) {\n\t\tbeta_name = String(name_string);\n\t}\n\treturn beta_name;\n}\n\n// Gets the current language that the user has set.\nString Steam::getCurrentGameLanguage() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, \"\", \"[STEAM] Apps class not found when calling: getCurrentGameLanguage\");\n\treturn SteamApps()->GetCurrentGameLanguage();\n}\n\n// Get the number of DLC the user owns for a parent application/game.\nint Steam::getDLCCount() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, 0, \"[STEAM] Apps class not found when calling: getDLCCount\");\n\treturn SteamApps()->GetDLCCount();\n}\n\n// Get the DLC data in one shot\nArray Steam::getDLCData() {\n\tArray dlc_data;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, dlc_data, \"[STEAM] Apps class not found when calling: getDLCData\");\n\tint32 count = SteamApps()->GetDLCCount();\n\tfor (int i = 0; i < count; i++) {\n\t\tdlc_data.append(getDLCDataByIndex(i));\n\t}\n\treturn dlc_data;\n}\n\n// Returns metadata for a DLC by index.\nDictionary Steam::getDLCDataByIndex(uint32_t this_dlc_index) {\n\tDictionary dlc_data;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, dlc_data, \"[STEAM] Apps class not found when calling: getDLCDataByIndex\");\n\tAppId_t app_id = 0;\n\tbool available = false;\n\tchar name[STEAM_BUFFER_SIZE];\n\n\tdlc_data[\"success\"] = SteamApps()->BGetDLCDataByIndex(this_dlc_index, &app_id, &available, name, STEAM_BUFFER_SIZE);\n\tif (dlc_data[\"success\"]) {\n\t\tdlc_data[\"id\"] = app_id;\n\t\tdlc_data[\"available\"] = available;\n\t\tdlc_data[\"name\"] = name;\n\t}\n\treturn dlc_data;\n}\n\n// Gets the download progress for optional DLC.\nDictionary Steam::getDLCDownloadProgress(uint32_t dlc_id) {\n\tDictionary progress;\n\tprogress[\"ret\"] = false;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, progress, \"[STEAM] Apps class not found when calling: getDLCDownloadProgress\");\n\tuint64 downloaded = 0;\n\tuint64 total = 0;\n\t// Get the progress\n\tprogress[\"ret\"] = SteamApps()->GetDlcDownloadProgress((AppId_t)dlc_id, &downloaded, &total);\n\tif (progress[\"ret\"]) {\n\t\tprogress[\"downloaded\"] = uint64_t(downloaded);\n\t\tprogress[\"total\"] = uint64_t(total);\n\t}\n\treturn progress;\n}\n\n// Gets the time of purchase of the specified app in Unix epoch format (time since Jan 1st, 1970).\nuint32_t Steam::getEarliestPurchaseUnixTime(uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, 0, \"[STEAM] Apps class not found when calling: getEarliestPurchaseUnixTime\");\n\treturn SteamApps()->GetEarliestPurchaseUnixTime((AppId_t)app_id);\n}\n\n// Asynchronously retrieves metadata details about a specific file in the depot manifest.\nvoid Steam::getFileDetails(const String &filename) {\n\tERR_FAIL_COND_MSG(SteamApps() == NULL, \"[STEAM] Apps class not found when calling: getFileDetails\");\n\tSteamApps()->GetFileDetails(filename.utf8().get_data());\n}\n\n// Gets a list of all installed depots for a given App ID.\n// @param app_id App ID to check.\n// @return Array of the installed depots, returned in mount order.\nArray Steam::getInstalledDepots(uint32_t app_id) {\n\tArray installed_depots;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, installed_depots, \"[STEAM] Apps class not found when calling: getInstalledDepots\");\n\tDepotId_t depots[32];\n\tuint32 installed = SteamApps()->GetInstalledDepots((AppId_t)app_id, depots, 32);\n\tfor (uint32 i = 0; i < installed; i++) {\n\t\tinstalled_depots.append(depots[i]);\n\t}\n\treturn installed_depots;\n}\n\n// Gets the command line if the game was launched via Steam URL, e.g. steam://run/<appid>//<command line>/. This method is\n// preferable to launching with a command line via the operating system, which can be a security risk. In order for rich presence\n// joins to go through this and not be placed on the OS command line, you must enable \"Use launch command line\" from the\n// Installation > General page on your app.\nString Steam::getLaunchCommandLine() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, \"\", \"[STEAM] Apps class not found when calling: getLaunchCommandLine\");\n\tchar commands[STEAM_BUFFER_SIZE]{};\n\tSteamApps()->GetLaunchCommandLine(commands, STEAM_BUFFER_SIZE);\n\treturn commands;\n}\n\n// Gets the associated launch parameter if the game is run via steam://run/<appid>/?param1=value1;param2=value2;param3=value3 etc.\nString Steam::getLaunchQueryParam(const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, \"\", \"[STEAM] Apps class not found when calling: getLaunchQueryParam\");\n\treturn SteamApps()->GetLaunchQueryParam(key.utf8().get_data());\n}\n\n// Returns total number of known app beta branches (including default \"public\" branch).\nDictionary Steam::getNumBetas() {\n\tDictionary beta_branches;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, beta_branches, \"[STEAM] Apps class not found when calling: getNumBetas\");\n\tint available_betas = 0;\n\tint private_betas = 0;\n\tint all_betas = SteamApps()->GetNumBetas(&available_betas, &private_betas);\n\tbeta_branches[\"available\"] = available_betas;\n\tbeta_branches[\"private\"] = private_betas;\n\tbeta_branches[\"total\"] = all_betas;\n\treturn beta_branches;\n}\n\n// Allows you to install an optional DLC.\nvoid Steam::installDLC(uint32_t dlc_id) {\n\tERR_FAIL_COND_MSG(SteamApps() == NULL, \"[STEAM] Apps class not found when calling: installDLC\");\n\tSteamApps()->InstallDLC((AppId_t)dlc_id);\n}\n\n// Check if given application/game is installed, not necessarily owned.\nbool Steam::isAppInstalled(uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isAppInstalled\");\n\treturn SteamApps()->BIsAppInstalled((AppId_t)app_id);\n}\n\n// Checks whether the current App ID is for Cyber Cafes.\nbool Steam::isCybercafe() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isCybercafe\");\n\treturn SteamApps()->BIsCybercafe();\n}\n\n// Checks if the user owns a specific DLC and if the DLC is installed\nbool Steam::isDLCInstalled(uint32_t dlc_id) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isDLCInstalled\");\n\treturn SteamApps()->BIsDlcInstalled((AppId_t)dlc_id);\n}\n\n// Checks if the license owned by the user provides low violence depots.\nbool Steam::isLowViolence() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isLowViolence\");\n\treturn SteamApps()->BIsLowViolence();\n}\n\n// Checks if the active user is subscribed to the current App ID.\nbool Steam::isSubscribed() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isSubscribed\");\n\treturn SteamApps()->BIsSubscribed();\n}\n\n// Checks if the active user is subscribed to a specified AppId.\nbool Steam::isSubscribedApp(uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isSubscribedApp\");\n\treturn SteamApps()->BIsSubscribedApp((AppId_t)app_id);\n}\n\n// Checks if the active user is accessing the current app_id via a temporary Family Shared license owned by another user.\n// If you need to determine the steam_id of the permanent owner of the license, use getAppOwner.\nbool Steam::isSubscribedFromFamilySharing() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isSubscribedFromFamilySharing\");\n\treturn SteamApps()->BIsSubscribedFromFamilySharing();\n}\n\n// Checks if the user is subscribed to the current app through a free weekend.\n// This function will return false for users who have a retail or other type of license.\n// Suggested you contact Valve on how to package and secure your free weekend properly.\nbool Steam::isSubscribedFromFreeWeekend() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isSubscribedFromFreeWeekend\");\n\treturn SteamApps()->BIsSubscribedFromFreeWeekend();\n}\n\n// Check if game is a timed trial with limited playtime.\nDictionary Steam::isTimedTrial() {\n\tDictionary trial;\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, trial, \"[STEAM] Apps class not found when calling: isTimedTrial\");\n\tuint32 allowed = 0;\n\tuint32 played = 0;\n\tif (SteamApps()->BIsTimedTrial(&allowed, &played)) {\n\t\ttrial[\"seconds_allowed\"] = allowed;\n\t\ttrial[\"seconds_played\"] = played;\n\t}\n\treturn trial;\n}\n\n// Checks if the user has a VAC ban on their account.\nbool Steam::isVACBanned() {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: isVACBanned\");\n\treturn SteamApps()->BIsVACBanned();\n}\n\n// Allows you to force verify game content on next launch.\nbool Steam::markContentCorrupt(bool missing_files_only) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: markContentCorrupt\");\n\treturn SteamApps()->MarkContentCorrupt(missing_files_only);\n}\n\n// Select this beta branch for this app as active, might need the game to restart so Steam can update to that branch.\nbool Steam::setActiveBeta(String beta_name) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: setActiveBeta\");\n\treturn SteamApps()->SetActiveBeta(beta_name.utf8().get_data());\n}\n\n// Set current DLC AppID being played (or 0 if none). Allows Steam to track usage of major DLC extensions.\nbool Steam::setDLCContext(uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamApps() == NULL, false, \"[STEAM] Apps class not found when calling: setDLCContext\");\n\treturn SteamApps()->SetDlcContext((AppId_t)app_id);\n}\n\n// Allows you to uninstall an optional DLC.\nvoid Steam::uninstallDLC(uint32_t dlc_id) {\n\tERR_FAIL_COND_MSG(SteamApps() == NULL, \"[STEAM] Apps class not found when calling: uninstallDLC\");\n\tSteamApps()->UninstallDLC((AppId_t)dlc_id);\n}\n\n\n///// FRIENDS\n\n// Activates the overlay with optional dialog to open the following: \"Friends\", \"Community\", \"Players\", \"Settings\",\n// \"OfficialGameGroup\", \"Stats\", \"Achievements\", \"LobbyInvite\".\nvoid Steam::activateGameOverlay(const String &url) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlay\");\n\tSteamFriends()->ActivateGameOverlay(url.utf8().get_data());\n}\n\n// Activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.\nvoid Steam::activateGameOverlayInviteDialog(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlayInviteDialog\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamFriends()->ActivateGameOverlayInviteDialog(user_id);\n}\n\n// Activates the game overlay to open an invite dialog that will send the provided Rich Presence connect string to selected friends.\nvoid Steam::activateGameOverlayInviteDialogConnectString(const String &connect_string) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlayInviteDialogConnectString\");\n\tSteamFriends()->ActivateGameOverlayInviteDialogConnectString(connect_string.utf8().get_data());\n}\n\n// Activates the overlay with the application/game Steam store page.\nvoid Steam::activateGameOverlayToStore(uint32_t app_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlayToStore\");\n\tSteamFriends()->ActivateGameOverlayToStore(AppId_t(app_id), EOverlayToStoreFlag(0));\n}\n\n// Activates the overlay to the following: \"steamid\", \"chat\", \"jointrade\", \"stats\", \"achievements\", \"friendadd\", \"friendremove\",\n// \"friendrequestaccept\", \"friendrequestignore\".\nvoid Steam::activateGameOverlayToUser(const String &url, uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlayToUser\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamFriends()->ActivateGameOverlayToUser(url.utf8().get_data(), user_id);\n}\n\n// Activates the overlay with specified web address.\nvoid Steam::activateGameOverlayToWebPage(const String &url) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: activateGameOverlayToWebPage\");\n\tSteamFriends()->ActivateGameOverlayToWebPage(url.utf8().get_data());\n}\n\n// Clear the game information in Steam; used in 'View Game Info'.\nvoid Steam::clearRichPresence() {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: clearRichPresence\");\n\tSteamFriends()->ClearRichPresence();\n}\n\n// Closes the specified Steam group chat room in the Steam UI.\nbool Steam::closeClanChatWindowInSteam(uint64_t chat_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Apps class not found when calling: closeClanChatWindowInSteam\");\n\tCSteamID chat = (uint64)chat_id;\n\treturn SteamFriends()->CloseClanChatWindowInSteam(chat);\n}\n\n// For clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the\n// info to have the latest.\nvoid Steam::downloadClanActivityCounts(uint64_t clan_id, int clans_to_request) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: downloadClanActivityCounts\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tSteamFriends()->DownloadClanActivityCounts(&clan, clans_to_request);\n}\n\n// Gets the list of users that the current user is following.\nvoid Steam::enumerateFollowingList(uint32 start_index) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: enumerateFollowingList\");\n\tSteamAPICall_t api_call = SteamFriends()->EnumerateFollowingList(start_index);\n\tcallResultEnumerateFollowingList.Set(api_call, this, &Steam::enumerate_following_list);\n}\n\n// Gets the Steam ID at the given index in a Steam group chat.\nuint64_t Steam::getChatMemberByIndex(uint64_t clan_id, int user) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getChatMemberByIndex\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tCSteamID chat_id = SteamFriends()->GetChatMemberByIndex(clan, user);\n\treturn chat_id.ConvertToUint64();\n}\n\n// Gets the most recent information we have about what the users in a Steam Group are doing.\nDictionary Steam::getClanActivityCounts(uint64_t clan_id) {\n\tDictionary activity;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, activity, \"[STEAM] Friends class not found when calling: getClanActivityCounts\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tint online = 0;\n\tint ingame = 0;\n\tint chatting = 0;\n\tbool success = SteamFriends()->GetClanActivityCounts(clan, &online, &ingame, &chatting);\n\t// Add these to the dictionary if successful\n\tif (success) {\n\t\tactivity[\"clan\"] = clan_id;\n\t\tactivity[\"online\"] = online;\n\t\tactivity[\"ingame\"] = ingame;\n\t\tactivity[\"chatting\"] = chatting;\n\t}\n\treturn activity;\n}\n\n// Gets the Steam group's Steam ID at the given index.\nuint64_t Steam::getClanByIndex(int clan_index) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanByIndex\");\n\treturn SteamFriends()->GetClanByIndex(clan_index).ConvertToUint64();\n}\n\n// Get the number of users in a Steam group chat.\nint Steam::getClanChatMemberCount(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanChatMemberCount\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn SteamFriends()->GetClanChatMemberCount(clan);\n}\n\n//  Gets the data from a Steam group chat room message.  This should only ever be called in response to a\n// GameConnectedClanChatMsg_t callback.\nDictionary Steam::getClanChatMessage(uint64_t chat_id, int message) {\n\tDictionary chat_message;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, chat_message, \"[STEAM] Friends class not found when calling: getClanChatMessage\");\n\tCSteamID chat = (uint64)chat_id;\n\tchar text[STEAM_LARGE_BUFFER_SIZE]{};\n\tEChatEntryType type = k_EChatEntryTypeInvalid;\n\tCSteamID user_id;\n\tchat_message[\"ret\"] = SteamFriends()->GetClanChatMessage(chat, message, text, STEAM_LARGE_BUFFER_SIZE, &type, &user_id);\n\tchat_message[\"text\"] = String(text);\n\tchat_message[\"type\"] = type;\n\tuint64_t user = user_id.ConvertToUint64();\n\tchat_message[\"chatter\"] = user;\n\treturn chat_message;\n}\n\n// Gets the number of Steam groups that the current user is a member of.  This is used for iteration, after calling this then\n// GetClanByIndex can be used to get the Steam ID of each Steam group.\nint Steam::getClanCount() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanCount\");\n\treturn SteamFriends()->GetClanCount();\n}\n\n// Gets the display name for the specified Steam group; if the local client knows about it.\nString Steam::getClanName(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getClanName\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn String::utf8(SteamFriends()->GetClanName(clan));\n}\n\n// Returns the steam_id of a clan officer, by index, of range [0,GetClanOfficerCount).\nuint64_t Steam::getClanOfficerByIndex(uint64_t clan_id, int officer) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanOfficerByIndex\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tCSteamID officer_id = SteamFriends()->GetClanOfficerByIndex(clan, officer);\n\treturn officer_id.ConvertToUint64();\n}\n\n// Returns the number of officers in a clan (including the owner).\nint Steam::getClanOfficerCount(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanOfficerCount\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn SteamFriends()->GetClanOfficerCount(clan);\n}\n\n// Returns the steam_id of the clan owner.\nuint64_t Steam::getClanOwner(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getClanOwner\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tCSteamID owner_id = SteamFriends()->GetClanOwner(clan);\n\treturn owner_id.ConvertToUint64();\n}\n\n// Gets the unique tag (abbreviation) for the specified Steam group; If the local client knows about it.  The Steam group\n// abbreviation is a unique way for people to identify the group and is limited to 12 characters. In some games this will appear\n// next to the name of group members.\nString Steam::getClanTag(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getClanTag\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn String::utf8(SteamFriends()->GetClanTag(clan));\n}\n\n// Gets the Steam ID of the recently played with user at the given index.\nuint64_t Steam::getCoplayFriend(int friend_number) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getCoplayFriend\");\n\tCSteamID friend_id = SteamFriends()->GetCoplayFriend(friend_number);\n\treturn friend_id.ConvertToUint64();\n}\n\n// Gets the number of players that the current users has recently played with, across all games.  This is used for iteration,\n// after calling this then GetCoplayFriend can be used to get the Steam ID of each player.  These players are have been set with\n// previous calls to SetPlayedWith.\nint Steam::getCoplayFriendCount() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getCoplayFriendCount\");\n\treturn SteamFriends()->GetCoplayFriendCount();\n}\n\n// Gets the number of users following the specified user.\nvoid Steam::getFollowerCount(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: getFollowerCount\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamAPICall_t api_call = SteamFriends()->GetFollowerCount(user_id);\n\tcallResultFollowerCount.Set(api_call, this, &Steam::get_follower_count);\n}\n\n// Returns the Steam ID of a user.\nuint64_t Steam::getFriendByIndex(int friend_number, BitField<FriendFlags> friend_flags) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendByIndex\");\n\tCSteamID friend_id = SteamFriends()->GetFriendByIndex(friend_number, (int)friend_flags);\n\treturn friend_id.ConvertToUint64();\n}\n\n// Gets the app ID of the game that user played with someone on their recently-played-with list.\nuint32 Steam::getFriendCoplayGame(uint64_t friend_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendCoplayGame\");\n\tCSteamID steam_id = (uint64)friend_id;\n\treturn SteamFriends()->GetFriendCoplayGame(steam_id);\n}\n\n// Gets the timestamp of when the user played with someone on their recently-played-with list.  The time is provided in Unix epoch\n// format (seconds since Jan 1st 1970).\nint Steam::getFriendCoplayTime(uint64_t friend_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendCoplayTime\");\n\tCSteamID steam_id = (uint64)friend_id;\n\treturn SteamFriends()->GetFriendCoplayTime(steam_id);\n}\n\n// Get number of friends user has.\nint Steam::getFriendCount(BitField<FriendFlags> friend_flags) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendCount\");\n\treturn SteamFriends()->GetFriendCount(friend_flags);\n}\n\n// Iterators for getting users in a chat room, lobby, game server or clan.\nint Steam::getFriendCountFromSource(uint64_t source_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendCountFromSource\");\n\tCSteamID source = (uint64)source_id;\n\treturn SteamFriends()->GetFriendCountFromSource(source);\n}\n\n// Gets the Steam ID at the given index from a source (Steam group, chat room, lobby, or game server).\nuint64_t Steam::getFriendFromSourceByIndex(uint64_t source_id, int friend_number) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendFromSourceByIndex\");\n\tCSteamID source = (uint64)source_id;\n\tCSteamID friend_id = SteamFriends()->GetFriendFromSourceByIndex(source, friend_number);\n\treturn friend_id.ConvertToUint64();\n}\n\n// Returns dictionary of friend game played if valid\nDictionary Steam::getFriendGamePlayed(uint64_t steam_id) {\n\tDictionary friend_game;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, friend_game, \"[STEAM] Friends class not found when calling: getFriendGamePlayed\");\n\tFriendGameInfo_t game_info;\n\tCSteamID user_id = (uint64)steam_id;\n\tbool success = SteamFriends()->GetFriendGamePlayed(user_id, &game_info);\n\t// If successful\n\tif (success) {\n\t\t// Is there a valid lobby?\n\t\tif (game_info.m_steamIDLobby.IsValid()) {\n\t\t\tfriend_game[\"id\"] = game_info.m_gameID.AppID();\n\t\t\tfriend_game[\"ip\"] = getStringFromIP(game_info.m_unGameIP);\n\t\t\tfriend_game[\"game_port\"] = game_info.m_usGamePort;\n\t\t\tfriend_game[\"query_port\"] = game_info.m_usQueryPort;\n\t\t\tfriend_game[\"lobby\"] = uint64_t(game_info.m_steamIDLobby.ConvertToUint64());\n\t\t}\n\t\telse {\n\t\t\tfriend_game[\"id\"] = game_info.m_gameID.AppID();\n\t\t\tfriend_game[\"ip\"] = \"0.0.0.0\";\n\t\t\tfriend_game[\"game_port\"] = 0;\n\t\t\tfriend_game[\"query_port\"] = 0;\n\t\t\tfriend_game[\"lobby\"] = 0; // No valid lobby\n\t\t}\n\t}\n\treturn friend_game;\n}\n\n// Gets the data from a Steam friends message. This should only ever be called in response to a GameConnectedFriendChatMsg_t\n// callback.\nDictionary Steam::getFriendMessage(uint64_t friend_id, int message) {\n\tDictionary chat;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, chat, \"[STEAM] Friends class not found when calling: getFriendMessage\");\n\tchar text[STEAM_LARGE_BUFFER_SIZE]{};\n\tEChatEntryType type = k_EChatEntryTypeInvalid;\n\tchat[\"ret\"] = SteamFriends()->GetFriendMessage(createSteamID(friend_id), message, text, STEAM_LARGE_BUFFER_SIZE, &type);\n\tchat[\"text\"] = String(text);\n\tchat[\"type\"] = type;\n\treturn chat;\n}\n\n// Get given friend's Steam username.\nString Steam::getFriendPersonaName(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getFriendPersonaName\");\n\tERR_FAIL_COND_V_MSG(steam_id <= 0, \"\", \"[STEAM] Invalid Steam ID sent to getFriendPersonaName\");\n\tCSteamID user_id = (uint64)steam_id;\n\tbool is_data_loading = SteamFriends()->RequestUserInformation(user_id, true);\n\tif (!is_data_loading) {\n\t\treturn String::utf8(SteamFriends()->GetFriendPersonaName(user_id));\n\t}\n\treturn \"\";\n}\n\n// Accesses old friends names; returns an empty string when there are no more items in the history.\nString Steam::getFriendPersonaNameHistory(uint64_t steam_id, int name_history) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getFriendPersonaNameHistory\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn String::utf8(SteamFriends()->GetFriendPersonaNameHistory(user_id, name_history));\n}\n\n// Returns the current status of the specified user.\nPersonaState Steam::getFriendPersonaState(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, PERSONA_STATE_OFFLINE, \"[STEAM] Friends class not found when calling: getFriendPersonaState\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn PersonaState(SteamFriends()->GetFriendPersonaState(user_id));\n}\n\n// Returns a relationship to a user.\nFriendRelationship Steam::getFriendRelationship(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, FRIEND_RELATION_NONE, \"[STEAM] Friends class not found when calling: getFriendRelationship\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn FriendRelationship(SteamFriends()->GetFriendRelationship(user_id));\n}\n\n// Get a Rich Presence value from a specified friend (typically only used for debugging).\nString Steam::getFriendRichPresence(uint64_t friend_id, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getFriendRichPresence\");\n\tCSteamID user = (uint64)friend_id;\n\treturn SteamFriends()->GetFriendRichPresence(user, key.utf8().get_data());\n}\n\n// Gets the number of Rich Presence keys that are set on the specified user.\nint Steam::getFriendRichPresenceKeyCount(uint64_t friend_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendRichPresenceKeyCount\");\n\tCSteamID user = (uint64)friend_id;\n\treturn SteamFriends()->GetFriendRichPresenceKeyCount(user);\n}\n\n// Returns an empty string (\"\") if the index is invalid or the specified user has no Rich Presence data available.\nString Steam::getFriendRichPresenceKeyByIndex(uint64_t friend_id, int key) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getFriendRichPresenceKeyByIndex\");\n\tCSteamID user = (uint64)friend_id;\n\treturn SteamFriends()->GetFriendRichPresenceKeyByIndex(user, key);\n}\n\n// Gets the number of friends groups (tags) the user has created.  This is used for iteration, after calling this then\n// GetFriendsGroupIDByIndex can be used to get the ID of each friend group.  This is not to be confused with Steam groups. Those\n// can be obtained with GetClanCount.\nint Steam::getFriendsGroupCount() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendsGroupCount\");\n\treturn SteamFriends()->GetFriendsGroupCount();\n}\n\n// Gets the friends group ID for the given index.\nint16 Steam::getFriendsGroupIDByIndex(int16 friend_group) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendsGroupIDByIndex\");\n\treturn SteamFriends()->GetFriendsGroupIDByIndex(friend_group);\n}\n\n// Gets the number of friends in a given friends group.  This should be called before getting the list of friends with\n// GetFriendsGroupMembersList.\nint Steam::getFriendsGroupMembersCount(int16 friend_group) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendsGroupMembersCount\");\n\treturn SteamFriends()->GetFriendsGroupMembersCount(friend_group);\n}\n\n// Gets the number of friends in the given friends group.  If fewer friends exist than requested those positions' Steam IDs will\n// be invalid.  You must call GetFriendsGroupMembersCount before calling this to set up the pOutSteamIDMembers array with an\n// appropriate size!\nArray Steam::getFriendsGroupMembersList(int16 friend_group, int member_count) {\n\tArray member_list;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, member_list, \"[STEAM] Friends class not found when calling: getFriendsGroupMembersList\");\n\tCSteamID friend_ids;\n\tSteamFriends()->GetFriendsGroupMembersList((FriendsGroupID_t)friend_group, &friend_ids, member_count);\n\tuint64_t friends = friend_ids.ConvertToUint64();\n\tmember_list.append(friends);\n\treturn member_list;\n}\n\n// Gets the name for the given friends group.\nString Steam::getFriendsGroupName(int16 friend_group) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getFriendsGroupName\");\n\treturn String::utf8(SteamFriends()->GetFriendsGroupName(friend_group));\n}\n\n// Get friend's steam level, obviously.\nint Steam::getFriendSteamLevel(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getFriendSteamLevel\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->GetFriendSteamLevel(user_id);\n}\n\n// Gets the large (184x184) avatar of the current user, which is a handle to be used in GetImageRGBA(), or 0 if none set.\nint Steam::getLargeFriendAvatar(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getLargeFriendAvatar\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->GetLargeFriendAvatar(user_id);\n}\n\n// Gets the medium (64x64) avatar of the current user, which is a handle to be used in GetImageRGBA(), or 0 if none set.\nint Steam::getMediumFriendAvatar(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getMediumFriendAvatar\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->GetMediumFriendAvatar(user_id);\n}\n\n// Get the user's Steam username.\nString Steam::getPersonaName() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getPersonaName\");\n\treturn String::utf8(SteamFriends()->GetPersonaName());\n}\n\n// Gets the status of the current user.\nPersonaState Steam::getPersonaState() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, PERSONA_STATE_OFFLINE, \"[STEAM] Friends class not found when calling: getPersonaState\");\n\treturn PersonaState(SteamFriends()->GetPersonaState());\n}\n\n// Get player's avatar.\nvoid Steam::getPlayerAvatar(int size, uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: getPlayerAvatar\");\n\tif (steam_id == 0) {\n\t\tsteam_id = SteamUser()->GetSteamID().ConvertToUint64();\n\t}\n\n\tuint32_t handle = -2;\n\tif (size == 1) {\n\t\thandle = getSmallFriendAvatar(steam_id);\n\t\tsize = 32;\n\t}\n\telse if (size == 2) {\n\t\thandle = getMediumFriendAvatar(steam_id);\n\t\tsize = 64;\n\t}\n\telse {\n\t\thandle = getLargeFriendAvatar(steam_id);\n\t\tsize = 184;\n\t}\n\n\tAvatarImageLoaded_t avatar_data;\n\tCSteamID avatar_id = (uint64)steam_id;\n\tavatar_data.m_steamID = avatar_id;\n\tavatar_data.m_iImage = handle;\n\tavatar_data.m_iWide = size;\n\tavatar_data.m_iTall = size;\n\tavatar_loaded(&avatar_data);\n}\n\n// Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.\nString Steam::getPlayerNickname(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getPlayerNickname\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn String::utf8(SteamFriends()->GetPlayerNickname(user_id));\n}\n\n// Returns a string property for a user's equipped profile item.\nString Steam::getProfileItemPropertyString(uint64_t steam_id, CommunityProfileItemType item_type, CommunityProfileItemProperty item_property) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, \"\", \"[STEAM] Friends class not found when calling: getProfileItemPropertyString\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn String::utf8(SteamFriends()->GetProfileItemPropertyString(user_id, (ECommunityProfileItemType)item_type, (ECommunityProfileItemProperty)item_property));\n}\n\n// Returns an unsigned integer property for a user's equipped profile item.\nuint32 Steam::getProfileItemPropertyInt(uint64_t steam_id, CommunityProfileItemType item_type, CommunityProfileItemProperty item_property) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getProfileItemPropertyInt\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->GetProfileItemPropertyUint(user_id, (ECommunityProfileItemType)item_type, (ECommunityProfileItemProperty)item_property);\n}\n\n// Get list of players user has recently played game with.\nArray Steam::getRecentPlayers() {\n\tArray recents;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, recents, \"[STEAM] Friends class not found when calling: getRecentPlayers\");\n\tint count = SteamFriends()->GetCoplayFriendCount();\n\tfor (int i = 0; i < count; i++) {\n\t\tCSteamID player_id = SteamFriends()->GetCoplayFriend(i);\n\t\tif (SteamFriends()->GetFriendCoplayGame(player_id) == SteamUtils()->GetAppID()) {\n\t\t\tDictionary player;\n\t\t\tint time = SteamFriends()->GetFriendCoplayTime(player_id);\n\t\t\tint status = SteamFriends()->GetFriendPersonaState(player_id);\n\t\t\tplayer[\"id\"] = (uint64_t)player_id.ConvertToUint64();\n\t\t\tplayer[\"name\"] = String::utf8(SteamFriends()->GetFriendPersonaName(player_id));\n\t\t\tplayer[\"time\"] = time;\n\t\t\tplayer[\"status\"] = status;\n\t\t\trecents.append(player);\n\t\t}\n\t}\n\treturn recents;\n}\n\n// Gets the small (32x32) avatar of the current user, which is a handle to be used in GetImageRGBA(), or 0 if none set.\nint Steam::getSmallFriendAvatar(uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getSmallFriendAvatar\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->GetSmallFriendAvatar(user_id);\n}\n\n// Get list of friends groups (tags) the user has created. This is not to be confused with Steam groups.\nArray Steam::getUserFriendsGroups() {\n\tArray friends_groups;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, friends_groups, \"[STEAM] Friends class not found when calling: getUserFriendsGroups\");\n\tint tag_count = SteamFriends()->GetFriendsGroupCount();\n\t\n\tfor (int i = 0; i < tag_count; i++) {\n\t\tDictionary tags;\n\t\tint16 friends_group_id = SteamFriends()->GetFriendsGroupIDByIndex(i);\n\t\tString group_name = SteamFriends()->GetFriendsGroupName(friends_group_id);\n\t\tint group_members = SteamFriends()->GetFriendsGroupMembersCount(friends_group_id);\n\t\ttags[\"id\"] = friends_group_id;\n\t\ttags[\"name\"] = group_name;\n\t\ttags[\"members\"] = group_members;\n\t\tfriends_groups.append(tags);\n\t}\n\treturn friends_groups;\n}\n\n// If current user is chat restricted, he can't send or receive any text/voice chat messages. The user can't see custom avatars.\n// But the user can be online and send/recv game invites.\nuint32 Steam::getUserRestrictions() {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, 0, \"[STEAM] Friends class not found when calling: getUserRestrictions\");\n\treturn SteamFriends()->GetUserRestrictions();\n}\n\n// Get a list of user's Steam friends; a mix of different Steamworks API friend functions.\nArray Steam::getUserSteamFriends() {\n\tArray steam_friends;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, steam_friends, \"[STEAM] Friends class not found when calling: getUserSteamFriends\");\n\tint count = SteamFriends()->GetFriendCount(FRIEND_FLAG_ALL);\n\tfor (int i = 0; i < count; i++) {\n\t\tDictionary friends;\n\t\tCSteamID friend_id = SteamFriends()->GetFriendByIndex(i, FRIEND_FLAG_ALL);\n\t\tint status = SteamFriends()->GetFriendPersonaState(friend_id);\n\t\tfriends[\"id\"] = (uint64_t)friend_id.ConvertToUint64();\n\t\tfriends[\"name\"] = String::utf8(SteamFriends()->GetFriendPersonaName(friend_id));\n\t\tfriends[\"status\"] = status;\n\t\tsteam_friends.append(friends);\n\t}\n\treturn steam_friends;\n}\n\n// Get list of user's Steam groups; a mix of different Steamworks API group functions.\nArray Steam::getUserSteamGroups() {\n\tArray steam_groups;\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, steam_groups, \"[STEAM] Friends class not found when calling: getUserSteamGroups\");\n\tint group_count = SteamFriends()->GetClanCount();\n\tfor (int i = 0; i < group_count; i++) {\n\t\tDictionary groups;\n\t\tCSteamID group_id = SteamFriends()->GetClanByIndex(i);\n\t\tString name = SteamFriends()->GetClanName(group_id);\n\t\tString tag = SteamFriends()->GetClanTag(group_id);\n\t\tgroups[\"id\"] = (uint64_t)group_id.ConvertToUint64();\n\t\tgroups[\"name\"] = name;\n\t\tgroups[\"tag\"] = tag;\n\t\tsteam_groups.append(groups);\n\t}\n\treturn steam_groups;\n}\n\n// After calling RequestEquippedProfileItems, you can use this function to check if the user has a type of profile item equipped\n// or not.\nbool Steam::hasEquippedProfileItem(uint64_t steam_id, CommunityProfileItemType item_type) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: hasEquippedProfileItem\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->BHasEquippedProfileItem(user_id, (ECommunityProfileItemType)item_type);\n}\n\n// Returns true if the specified user meets any of the criteria specified in iFriendFlags.\nbool Steam::hasFriend(uint64_t steam_id, BitField<FriendFlags> friend_flags) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: hasFriend\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->HasFriend(user_id, (int)friend_flags);\n}\n\n// Invite friend to current game/lobby.\nbool Steam::inviteUserToGame(uint64_t steam_id, const String &connect_string) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: inviteUserToGame\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->InviteUserToGame(user_id, connect_string.utf8().get_data());\n}\n\n// Checks if a user in the Steam group chat room is an admin.\nbool Steam::isClanChatAdmin(uint64_t chat_id, uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: isClanChatAdmin\");\n\tCSteamID chat = (uint64)chat_id;\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->IsClanChatAdmin(chat, user_id);\n}\n\n// Checks if the Steam group is public.\nbool Steam::isClanPublic(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: isClanPublic\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn SteamFriends()->IsClanPublic(clan);\n}\n\n// Checks if the Steam group is an official game group/community hub.\nbool Steam::isClanOfficialGameGroup(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: isClanOfficialGameGroup\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn SteamFriends()->IsClanOfficialGameGroup(clan);\n}\n\n// Checks if the Steam Group chat room is open in the Steam UI.\nbool Steam::isClanChatWindowOpenInSteam(uint64_t chat_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: isClanChatWindowOpenInSteam\");\n\tCSteamID chat = (uint64)chat_id;\n\treturn SteamFriends()->IsClanChatWindowOpenInSteam(chat);\n}\n\n// Checks if the current user is following the specified user.\nvoid Steam::isFollowing(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: isFollowing\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamAPICall_t api_call = SteamFriends()->IsFollowing(user_id);\n\tcallResultIsFollowing.Set(api_call, this, &Steam::is_following);\n}\n\n// Returns true if the local user can see that steam_id_user is a member or in source_id.\nbool Steam::isUserInSource(uint64_t steam_id, uint64_t source_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: isUserInSource\");\n\tCSteamID user_id = (uint64)steam_id;\n\tCSteamID source = (uint64)source_id;\n\treturn SteamFriends()->IsUserInSource(user_id, source);\n}\n\n// Allows the user to join Steam group (clan) chats right within the game.\nvoid Steam::joinClanChatRoom(uint64_t clan_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: joinClanChatRoom\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tSteamFriends()->JoinClanChatRoom(clan);\n}\n\n// Leaves a Steam group chat that the user has previously entered with JoinClanChatRoom.\nbool Steam::leaveClanChatRoom(uint64_t clan_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: leaveClanChatRoom\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\treturn SteamFriends()->LeaveClanChatRoom(clan);\n}\n\n// Opens the specified Steam group chat room in the Steam UI.\nbool Steam::openClanChatWindowInSteam(uint64_t chat_id) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: openClanChatWindowInSteam\");\n\tCSteamID chat = (uint64)chat_id;\n\treturn SteamFriends()->OpenClanChatWindowInSteam(chat);\n}\n\n// Call this before calling ActivateGameOverlayToWebPage() to have the Steam Overlay Browser block navigations to your specified\n// protocol (scheme) uris and instead dispatch a OverlayBrowserProtocolNavigation_t callback to your game.\nbool Steam::registerProtocolInOverlayBrowser(const String &protocol) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: registerProtocolInOverlayBrowser\");\n\treturn SteamFriends()->RegisterProtocolInOverlayBrowser(protocol.utf8().get_data());\n}\n\n// Sends a message to a Steam friend.\nbool Steam::replyToFriendMessage(uint64_t steam_id, const String &message) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: replyToFriendMessage\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->ReplyToFriendMessage(user_id, message.utf8().get_data());\n}\n\n// Requests information about a clan officer list; when complete, data is returned in ClanOfficerListResponse_t call result.\nvoid Steam::requestClanOfficerList(uint64_t clan_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: requestClanOfficerList\");\n\tcurrent_clan_id = clan_id;\n\tCSteamID clan = (uint64)current_clan_id;\n\tSteamAPICall_t api_call = SteamFriends()->RequestClanOfficerList(clan);\n\tcallResultClanOfficerList.Set(api_call, this, &Steam::request_clan_officer_list);\n}\n\n// Requests the list of equipped Steam Community profile items for the given user from Steam.\nvoid Steam::requestEquippedProfileItems(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: requestEquippedProfileItems\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamAPICall_t api_call = SteamFriends()->RequestEquippedProfileItems(user_id);\n\tcallResultEquippedProfileItems.Set(api_call, this, &Steam::equipped_profile_items);\n}\n\n// Requests rich presence for a specific user.\nvoid Steam::requestFriendRichPresence(uint64_t friend_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: requestFriendRichPresence\");\n\tCSteamID user = (uint64)friend_id;\n\treturn SteamFriends()->RequestFriendRichPresence(user);\n}\n\n// Requests information about a user - persona name & avatar; if bRequireNameOnly is set, then the avatar of a user isn't downloaded.\nbool Steam::requestUserInformation(uint64_t steam_id, bool require_name_only) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: requestUserInformation\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamFriends()->RequestUserInformation(user_id, require_name_only);\n}\n\n// Sends a message to a Steam group chat room.\nbool Steam::sendClanChatMessage(uint64_t chat_id, const String &text) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: sendClanChatMessage\");\n\tCSteamID chat = (uint64)chat_id;\n\treturn SteamFriends()->SendClanChatMessage(chat, text.utf8().get_data());\n}\n\n// User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI).\nvoid Steam::setInGameVoiceSpeaking(uint64_t steam_id, bool speaking) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: setInGameVoiceSpeaking\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamFriends()->SetInGameVoiceSpeaking(user_id, speaking);\n}\n\n// Listens for Steam friends chat messages.\nbool Steam::setListenForFriendsMessages(bool intercept) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: setListenForFriendsMessages\");\n\treturn SteamFriends()->SetListenForFriendsMessages(intercept);\n}\n\n// Sets the player name, stores it on the server and publishes the changes to all friends who are online.\nvoid Steam::setPersonaName(const String &name) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: setPersonaName\");\n\tSteamFriends()->SetPersonaName(name.utf8().get_data());\n}\n\n// Set player as 'Played With' for game.\nvoid Steam::setPlayedWith(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamFriends() == NULL, \"[STEAM] Friends class not found when calling: setPlayedWith\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamFriends()->SetPlayedWith(user_id);\n}\n\n// Set the game information in Steam; used in 'View Game Info'. Rich presence data is automatically shared between friends in the same\n// game. Each user has a set of key/value pairs, up to 20 can be set. Two magic keys (status, connect).  setGameInfo() to an empty\n// string deletes the key.\nbool Steam::setRichPresence(const String &key, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamFriends() == NULL, false, \"[STEAM] Friends class not found when calling: setRichPresence\");\n\treturn SteamFriends()->SetRichPresence(key.utf8().get_data(), value.utf8().get_data());\n}\n\n\n///// GAME SEARCH\n/////////////////////////////////////////////////\n//\n// A keyname and a list of comma separated values: one of which is must be found in order for the match to qualify; fails if a\n// search is currently in progress.\nint Steam::addGameSearchParams(const String &key, const String &values) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: addGameSearchParams\");\n\treturn SteamGameSearch()->AddGameSearchParams(key.utf8().get_data(), values.utf8().get_data());\n}\n\n// All players in lobby enter the queue and await a SearchForGameNotificationCallback_t callback. Fails if another search is\n// currently in progress. If not the owner of the lobby or search already in progress this call fails. Periodic callbacks will be\n// sent as queue time estimates change.\nint Steam::searchForGameWithLobby(uint64_t lobby_id, int player_min, int player_max) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: searchForGameWithLobby\");\n\tCSteamID lobby = (uint64)lobby_id;\n\treturn SteamGameSearch()->SearchForGameWithLobby(lobby, player_min, player_max);\n}\n\n// User enter the queue and await a SearchForGameNotificationCallback_t callback. fails if another search is currently in progress.\n// Periodic callbacks will be sent as queue time estimates change.\nint Steam::searchForGameSolo(int player_min, int player_max) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: searchForGameSolo\");\n\treturn SteamGameSearch()->SearchForGameSolo(player_min, player_max);\n}\n\n// After receiving SearchForGameResultCallback_t, accept or decline the game. Multiple SearchForGameResultCallback_t will follow\n// as players accept game until the host starts or cancels the game.\nint Steam::acceptGame() {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: acceptGame\");\n\treturn SteamGameSearch()->AcceptGame();\n}\n\n// After receiving SearchForGameResultCallback_t, accept or decline the game. Multiple SearchForGameResultCallback_t will follow\n// as players accept game until the host starts or cancels the game.\nint Steam::declineGame() {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: declineGame\");\n\treturn SteamGameSearch()->DeclineGame();\n}\n\n// After receiving GameStartedByHostCallback_t get connection details to server.\nString Steam::retrieveConnectionDetails(uint64_t host_id) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, \"\", \"[STEAM] Game Search class not found when calling: retrieveConnectionDetails\");\n\tCSteamID host = (uint64)host_id;\n\tchar connection_details[256 + 1]{};\n\tSteamGameSearch()->RetrieveConnectionDetails(host, connection_details, 256);\n\treturn connection_details;\n}\n\n// Leaves queue if still waiting.\nint Steam::endGameSearch() {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: endGameSearch\");\n\treturn SteamGameSearch()->EndGameSearch();\n}\n\n// A keyname and a list of comma separated values: all the values you allow.\nint Steam::setGameHostParams(const String &key, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: setGameHostParams\");\n\treturn SteamGameSearch()->SetGameHostParams(key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Set connection details for players once game is found so they can connect to this server.\nint Steam::setConnectionDetails(const String &details, int connection_details) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: setConnectionDetails\");\n\treturn SteamGameSearch()->SetConnectionDetails(details.utf8().get_data(), connection_details);\n}\n\n// Mark server as available for more players with nPlayerMin,nPlayerMax desired. Accept no lobbies with playercount greater than\n// nMaxTeamSize.\nint Steam::requestPlayersForGame(int player_min, int player_max, int max_team_size) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: requestPlayersForGame\");\n\treturn SteamGameSearch()->RequestPlayersForGame(player_min, player_max, max_team_size);\n}\n\n// Accept the player list and release connection details to players.\nint Steam::hostConfirmGameStart(uint64_t game_id) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: hostConfirmGameStart\");\n\treturn SteamGameSearch()->HostConfirmGameStart(game_id);\n}\n\n// Cancel request and leave the pool of game hosts looking for players.\nint Steam::cancelRequestPlayersForGame() {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: cancelRequestPlayersForGame\");\n\treturn SteamGameSearch()->CancelRequestPlayersForGame();\n}\n\n// Submit a result for one player. does not end the game. ullUniqueGameID continues to describe this game.\nint Steam::submitPlayerResult(uint64_t game_id, uint64_t player_id, PlayerResult player_result) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: submitPlayerResult\");\n\tCSteamID player = (uint64)player_id;\n\treturn SteamGameSearch()->SubmitPlayerResult(game_id, player, (EPlayerResult_t)player_result);\n}\n\n// Ends the game. no further SubmitPlayerResults for ullUniqueGameID will be accepted.\nint Steam::endGame(uint64_t game_id) {\n\tERR_FAIL_COND_V_MSG(SteamGameSearch() == NULL, 9, \"[STEAM] Game Search class not found when calling: endGame\");\n\treturn SteamGameSearch()->EndGame(game_id);\n}\n\n\n///// HTML SURFACE\n\n// Add a header to any HTTP requests from this browser.\nvoid Steam::addHeader(const String &key, const String &value, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: addHeader\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->AddHeader(this_handle, key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Sets whether a pending load is allowed or if it should be canceled.  NOTE:You MUST call this in response to a HTML_StartRequest_t\n// callback.\nvoid Steam::allowStartRequest(bool allowed, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: allowStartRequest\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->AllowStartRequest(this_handle, allowed);\n}\n\n// Copy the currently selected text from the current page in an HTML surface into the local clipboard.\nvoid Steam::copyToClipboard(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: copyToClipboard\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->CopyToClipboard(this_handle);\n}\n\n// Create a browser object for displaying of an HTML page. NOTE: You MUST call RemoveBrowser when you are done using this browser\n// to free up the resources associated with it. Failing to do so will result in a memory leak.\nvoid Steam::createBrowser(const String &user_agent, const String &user_css) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: createBrowser\");\n\tauto user_agent_utf8 = user_agent.utf8();\n\tconst char *this_user_agent = nullptr;\n\tif (!user_agent.is_empty()) {\n\t\tthis_user_agent = user_agent_utf8.get_data();\n\t}\n\n\tauto user_css_utf8 = user_css.utf8();\n\tconst char *this_user_css = nullptr;\n\tif (!user_css.is_empty()) {\n\t\tthis_user_css = user_css_utf8.get_data();\n\t}\n\n\tSteamAPICall_t api_call = SteamHTMLSurface()->CreateBrowser(this_user_agent, this_user_css);\n\tcallResultHTMLBrowserReady.Set(api_call, this, &Steam::html_browser_ready);\n}\n\n// Run a javascript script in the currently loaded page.\nvoid Steam::executeJavascript(const String &javascript, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: executeJavascript\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->ExecuteJavascript(this_handle, javascript.utf8().get_data());\n}\n\n// Find a string in the current page of an HTML surface. This is the equivalent of \"ctrl+f\" in your browser of choice. It will\n// highlight all of the matching strings. You should call StopFind when the input string has changed or you want to stop searching.\nvoid Steam::find(const String &search, bool currently_in_find, bool reverse, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: find\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->Find(this_handle, search.utf8().get_data(), currently_in_find, reverse);\n}\n\n// Retrieves details about a link at a specific position on the current page in an HTML surface.\nvoid Steam::getLinkAtPosition(int x, int y, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: getLinkAtPosition\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->GetLinkAtPosition(this_handle, x, y);\n}\n\n// Navigate back in the page history.\nvoid Steam::goBack(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: goBack\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->GoBack(this_handle);\n}\n\n// Navigate forward in the page history\nvoid Steam::goForward(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: goForward\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->GoForward(this_handle);\n}\n\n// Initializes the HTML Surface API. This must be called prior to using any other functions in this interface. You MUST call\n// Shutdown when you are done using the interface to free up the resources associated with it. Failing to do so will result in a\n// memory leak!\nbool Steam::htmlInit() {\n\tERR_FAIL_COND_V_MSG(SteamHTMLSurface() == NULL, false, \"[STEAM] HTML Surface class not found when calling: htmlInit\");\n\treturn SteamHTMLSurface()->Init();\n}\n\n// Allows you to react to a page wanting to open a javascript modal dialog notification.\nvoid Steam::jsDialogResponse(bool result, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: jsDialogResponse\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->JSDialogResponse(this_handle, result);\n}\n\n// cUnicodeChar is the unicode character point for this keypress (and potentially multiple chars per press).\nvoid Steam::keyChar(uint32 unicode_char, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: keyChar\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->KeyChar(this_handle, unicode_char, (ISteamHTMLSurface::EHTMLKeyModifiers)(int64_t)key_modifiers);\n}\n\n// Keyboard interactions, native keycode is the virtual key code value from your OS.\nvoid Steam::keyDown(uint32 native_key_code, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: keyDown\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->KeyDown(this_handle, native_key_code, (ISteamHTMLSurface::EHTMLKeyModifiers)(int64_t)key_modifiers);\n}\n\n// Keyboard interactions, native keycode is the virtual key code value from your OS.\nvoid Steam::keyUp(uint32 native_key_code, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: keyUp\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->KeyUp(this_handle, native_key_code, (ISteamHTMLSurface::EHTMLKeyModifiers)(int64_t)key_modifiers);\n}\n\n// Navigate to a specified URL. If you send POST data with pchPostData then the data should be formatted as:\n// name1=value1&name2=value2. You can load any URI scheme supported by Chromium Embedded Framework including but not limited to:\n// http://, https://, ftp://, and file:///. If no scheme is specified then http:// is used.\nvoid Steam::loadURL(const String &url, const String &post_data, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: loadURL\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->LoadURL(this_handle, url.utf8().get_data(), post_data.utf8().get_data());\n}\n\n// Tells an HTML surface that a mouse button has been double clicked. The click will occur where the surface thinks the mouse is\n// based on the last call to MouseMove.\nvoid Steam::mouseDoubleClick(HTMLMouseButton mouse_button, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: mouseDoubleClick\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->MouseDoubleClick(this_handle, (ISteamHTMLSurface::EHTMLMouseButton)mouse_button);\n}\n\n// Tells an HTML surface that a mouse button has been pressed. The click will occur where the surface thinks the mouse is based on\n// the last call to MouseMove.\nvoid Steam::mouseDown(HTMLMouseButton mouse_button, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: mouseDown\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->MouseDown(this_handle, (ISteamHTMLSurface::EHTMLMouseButton)mouse_button);\n}\n\n// Tells an HTML surface where the mouse is.\nvoid Steam::mouseMove(int x, int y, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: mouseMove\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->MouseMove(this_handle, x, y);\n}\n\n// Tells an HTML surface that a mouse button has been released. The click will occur where the surface thinks the mouse is based on\n// the last call to MouseMove.\nvoid Steam::mouseUp(HTMLMouseButton mouse_button, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: mouseUp\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->MouseUp(this_handle, (ISteamHTMLSurface::EHTMLMouseButton)mouse_button);\n}\n\n// Tells an HTML surface that the mouse wheel has moved.\nvoid Steam::mouseWheel(int32 delta, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: mouseWheel\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->MouseWheel(this_handle, delta);\n}\n\n// Paste from the local clipboard to the current page in an HTML surface.\nvoid Steam::pasteFromClipboard(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: pasteFromClipboard\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->PasteFromClipboard(this_handle);\n}\n\n// Refreshes the current page. The reload will most likely hit the local cache instead of going over the network. This is\n// equivalent to F5 or Ctrl+R in your browser of choice.\nvoid Steam::reload(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: reload\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->Reload(this_handle);\n}\n\n// You MUST call this when you are done with an HTML surface, freeing the resources associated with it. Failing to call this will\n// result in a memory leak!\nvoid Steam::removeBrowser(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: removeBrowser\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->RemoveBrowser(this_handle);\n}\n\n// Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are more aggressively\n// purged from memory, and audio/video elements are paused. When background mode is enabled, all HTML5 video and audio objects\n// will execute \".pause()\" and gain the property \"._steam_background_paused = 1\". When background mode is disabled, any video or\n// audio objects with that property will resume with \".play()\".\nvoid Steam::setBackgroundMode(bool background_mode, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setBackgroundMode\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetBackgroundMode(this_handle, background_mode);\n}\n\n// Set a webcookie for a specific hostname. You can read more about the specifics of setting cookies here on wikipedia.\nvoid Steam::setCookie(const String &hostname, const String &key, const String &value, const String &path, uint32 expires, bool secure, bool http_only) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setCookie\");\n\tSteamHTMLSurface()->SetCookie(hostname.utf8().get_data(), key.utf8().get_data(), value.utf8().get_data(), path.utf8().get_data(), expires, secure, http_only);\n}\n\n// Scroll the current page horizontally.\nvoid Steam::setHorizontalScroll(uint32 absolute_pixel_scroll, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setHorizontalScroll\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetHorizontalScroll(this_handle, absolute_pixel_scroll);\n}\n\n// Tell a HTML surface if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things.\nvoid Steam::setKeyFocus(bool has_key_focus, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setKeyFocus\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetKeyFocus(this_handle, has_key_focus);\n}\n\n// Zoom the current page in an HTML surface. The current scale factor is available from HTML_NeedsPaint_t.flPageScale,\n// HTML_HorizontalScroll_t.flPageScale, and HTML_VerticalScroll_t.flPageScale.\nvoid Steam::setPageScaleFactor(float zoom, int point_x, int point_y, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setPageScaleFactor\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetPageScaleFactor(this_handle, zoom, point_x, point_y);\n}\n\n// Sets the display size of a surface in pixels.\nvoid Steam::setSize(uint32 width, uint32 height, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setSize\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetSize((HHTMLBrowser)this_handle, width, height);\n}\n\n// Scroll the current page vertically.\nvoid Steam::setVerticalScroll(uint32 absolute_pixel_scroll, uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: setVerticalScroll\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->SetVerticalScroll(this_handle, absolute_pixel_scroll);\n}\n\n// Shutdown the ISteamHTMLSurface interface, releasing the memory and handles. You MUST call this when you are done using this\n// interface to prevent memory and handle leaks. After calling this then all of the functions provided in this interface will fail\n// until you call Init to reinitialize again.\nbool Steam::htmlShutdown() {\n\tERR_FAIL_COND_V_MSG(SteamHTMLSurface() == NULL, false, \"[STEAM] HTML Surface class not found when calling: htmlShutdown\");\n\treturn SteamHTMLSurface()->Shutdown();\n}\n\n// Cancel a currently running find.\nvoid Steam::stopFind(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: stopFind\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->StopFind(this_handle);\n}\n\n// Stop the load of the current HTML page.\nvoid Steam::stopLoad(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: stopLoad\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->StopLoad(this_handle);\n}\n\n// Open the current pages HTML source code in default local text editor, used for debugging.\nvoid Steam::viewSource(uint32 this_handle) {\n\tERR_FAIL_COND_MSG(SteamHTMLSurface() == NULL, \"[STEAM] HTML Surface class not found when calling: viewSource\");\n\tif (this_handle == 0) {\n\t\tthis_handle = browser_handle;\n\t}\n\tSteamHTMLSurface()->ViewSource(this_handle);\n}\n\n\n///// HTTP\n\n// Creates a cookie container to store cookies during the lifetime of the process. This API is just for during process lifetime,\n// after steam restarts no cookies are persisted and you have no way to access the cookie container across repeat executions of\n// your process.\nuint32_t Steam::createCookieContainer(bool allow_responses_to_modify) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, 0, \"[STEAM] HTTP class not found when calling: createCookieContainer\");\n\treturn SteamHTTP()->CreateCookieContainer(allow_responses_to_modify);\n}\n\n// Initializes a new HTTP request.\nuint32_t Steam::createHTTPRequest(HTTPMethod request_method, const String &absolute_url) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, HTTPREQUEST_INVALID_HANDLE, \"[STEAM] HTTP class not found when calling: createCookieContainer\");\n\treturn SteamHTTP()->CreateHTTPRequest((EHTTPMethod)request_method, absolute_url.utf8().get_data());\n}\n\n// Defers a request which has already been sent by moving it at the back of the queue.\nbool Steam::deferHTTPRequest(uint32 request_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: deferHTTPRequest\");\n\treturn SteamHTTP()->DeferHTTPRequest(request_handle);\n}\n\n// Gets progress on downloading the body for the request.\nfloat Steam::getHTTPDownloadProgressPct(uint32 request_handle) {\n\tfloat percent_one = 0.0;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, percent_one, \"[STEAM] HTTP class not found when calling: getHTTPDownloadProgressPct\");\n\tSteamHTTP()->GetHTTPDownloadProgressPct(request_handle, &percent_one);\n\treturn percent_one;\n}\n\n// Check if the reason the request failed was because we timed it out (rather than some harder failure).\nbool Steam::getHTTPRequestWasTimedOut(uint32 request_handle) {\n\tbool was_timed_out = false;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, was_timed_out, \"[STEAM] HTTP class not found when calling: getHTTPRequestWasTimedOut\");\n\tSteamHTTP()->GetHTTPRequestWasTimedOut(request_handle, &was_timed_out);\n\treturn was_timed_out;\n}\n\n// Gets the body data from an HTTP response.\nPackedByteArray Steam::getHTTPResponseBodyData(uint32 request_handle, uint32 buffer_size) {\n\tPackedByteArray body_data;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, body_data, \"[STEAM] HTTP class not found when calling: getHTTPResponseBodyData\");\n\tbody_data.resize(buffer_size);\n\tSteamHTTP()->GetHTTPResponseBodyData(request_handle, body_data.ptrw(), buffer_size);\n\treturn body_data;\n}\n\n// Gets the size of the body data from an HTTP response.\nuint32 Steam::getHTTPResponseBodySize(uint32 request_handle) {\n\tuint32 body_size = 0;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, body_size, \"[STEAM] HTTP class not found when calling: getHTTPResponseBodySize\");\n\tSteamHTTP()->GetHTTPResponseBodySize(request_handle, &body_size);\n\treturn body_size;\n}\n\n// Checks if a header is present in an HTTP response and returns its size.\nuint32 Steam::getHTTPResponseHeaderSize(uint32 request_handle, const String &header_name) {\n\tuint32 response_header_size = 0;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, response_header_size, \"[STEAM] HTTP class not found when calling: getHTTPResponseHeaderSize\");\n\tSteamHTTP()->GetHTTPResponseHeaderSize(request_handle, header_name.utf8().get_data(), &response_header_size);\n\treturn response_header_size;\n}\n\n// Gets a header value from an HTTP response.\nPackedByteArray Steam::getHTTPResponseHeaderValue(uint32 request_handle, const String &header_name, uint32 buffer_size) {\n\tPackedByteArray header_data;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, header_data, \"[STEAM] HTTP class not found when calling: getHTTPResponseHeaderValue\");\n\theader_data.resize(buffer_size);\n\tSteamHTTP()->GetHTTPResponseHeaderValue(request_handle, header_name.utf8().get_data(), header_data.ptrw(), buffer_size);\n\treturn header_data;\n}\n\n// Gets the body data from a streaming HTTP response.\nPackedByteArray Steam::getHTTPStreamingResponseBodyData(uint32 request_handle, uint32 offset, uint32 buffer_size) {\n\tPackedByteArray body_data;\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, body_data, \"[STEAM] HTTP class not found when calling: getHTTPStreamingResponseBodyData\");\n\tbody_data.resize(buffer_size);\n\tSteamHTTP()->GetHTTPStreamingResponseBodyData(request_handle, offset, body_data.ptrw(), buffer_size);\n\treturn body_data;\n}\n\n// Prioritizes a request which has already been sent by moving it at the front of the queue.\nbool Steam::prioritizeHTTPRequest(uint32 request_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: prioritizeHTTPRequest\");\n\treturn SteamHTTP()->PrioritizeHTTPRequest(request_handle);\n}\n\n// Releases a cookie container, freeing the memory allocated within Steam.\nbool Steam::releaseCookieContainer(uint32 cookie_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: releaseCookieContainer\");\n\treturn SteamHTTP()->ReleaseCookieContainer(cookie_handle);\n}\n\n// Releases an HTTP request handle, freeing the memory allocated within Steam.\nbool Steam::releaseHTTPRequest(uint32 request_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: releaseHTTPRequest\");\n\treturn SteamHTTP()->ReleaseHTTPRequest(request_handle);\n}\n\n// Sends an HTTP request.\nbool Steam::sendHTTPRequest(uint32 request_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: sendHTTPRequest\");\n\tSteamAPICall_t call_handle;\n\treturn SteamHTTP()->SendHTTPRequest(request_handle, &call_handle);\n}\n\n// Sends an HTTP request and streams the response back in chunks.\nbool Steam::sendHTTPRequestAndStreamResponse(uint32 request_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: sendHTTPRequestAndStreamResponse\");\n\tSteamAPICall_t call_handle;\n\treturn SteamHTTP()->SendHTTPRequestAndStreamResponse(request_handle, &call_handle);\n}\n\n// Adds a cookie to the specified cookie container that will be used with future requests.\nbool Steam::setHTTPCookie(uint32 cookie_handle, const String &host, const String &url, const String &cookie) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPCookie\");\n\treturn SteamHTTP()->SetCookie(cookie_handle, host.utf8().get_data(), url.utf8().get_data(), cookie.utf8().get_data());\n}\n\n// Set an absolute timeout in milliseconds for the HTTP request. This is the total time timeout which is different than the\n// network activity timeout which is set with SetHTTPRequestNetworkActivityTimeout which can bump everytime we get more data.\nbool Steam::setHTTPRequestAbsoluteTimeoutMS(uint32 request_handle, uint32 milliseconds) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestAbsoluteTimeoutMS\");\n\treturn SteamHTTP()->SetHTTPRequestAbsoluteTimeoutMS(request_handle, milliseconds);\n}\n\n// Set a context value for the request, which will be returned in the HTTPRequestCompleted_t callback after sending the request.\n// This is just so the caller can easily keep track of which callbacks go with which request data. Must be called before sending\n// the request.\nbool Steam::setHTTPRequestContextValue(uint32 request_handle, uint64_t context_value) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestContextValue\");\n\treturn SteamHTTP()->SetHTTPRequestContextValue(request_handle, context_value);\n}\n\n// Associates a cookie container to use for an HTTP request.\nbool Steam::setHTTPRequestCookieContainer(uint32 request_handle, uint32 cookie_handle) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestCookieContainer\");\n\treturn SteamHTTP()->SetHTTPRequestCookieContainer(request_handle, cookie_handle);\n}\n\n// Set a GET or POST parameter value on the HTTP request. Must be called prior to sending the request.\nbool Steam::setHTTPRequestGetOrPostParameter(uint32 request_handle, const String &name, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestGetOrPostParameter\");\n\treturn SteamHTTP()->SetHTTPRequestGetOrPostParameter(request_handle, name.utf8().get_data(), value.utf8().get_data());\n}\n\n// Set a request header value for the HTTP request. Must be called before sending the request.\nbool Steam::setHTTPRequestHeaderValue(uint32 request_handle, const String &header_name, const String &header_value) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestHeaderValue\");\n\treturn SteamHTTP()->SetHTTPRequestHeaderValue(request_handle, header_name.utf8().get_data(), header_value.utf8().get_data());\n}\n\n// Set the timeout in seconds for the HTTP request.\nbool Steam::setHTTPRequestNetworkActivityTimeout(uint32 request_handle, uint32 timeout_seconds) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestNetworkActivityTimeout\");\n\treturn SteamHTTP()->SetHTTPRequestNetworkActivityTimeout(request_handle, timeout_seconds);\n}\n\n// Sets the body for an HTTP Post request.\nbool Steam::setHTTPRequestRawPostBody(uint32 request_handle, const String &content_type, const String &body) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestRawPostBody\");\n\tauto body_utf8 = body.utf8();\n\treturn SteamHTTP()->SetHTTPRequestRawPostBody(request_handle, content_type.utf8().get_data(), reinterpret_cast<uint8 *>(body_utf8.ptrw()), body_utf8.size());\n}\n\n// Sets that the HTTPS request should require verified SSL certificate via machines certificate trust store. This currently only\n// works Windows and macOS.\nbool Steam::setHTTPRequestRequiresVerifiedCertificate(uint32 request_handle, bool require_verified_certificate) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestNetworkActivityTimeout\");\n\treturn SteamHTTP()->SetHTTPRequestRequiresVerifiedCertificate(request_handle, require_verified_certificate);\n}\n\n// Set additional user agent info for a request.\nbool Steam::setHTTPRequestUserAgentInfo(uint32 request_handle, const String &user_agent_info) {\n\tERR_FAIL_COND_V_MSG(SteamHTTP() == NULL, false, \"[STEAM] HTTP class not found when calling: setHTTPRequestNetworkActivityTimeout\");\n\treturn SteamHTTP()->SetHTTPRequestUserAgentInfo(request_handle, user_agent_info.utf8().get_data());\n}\n\n\n///// INPUT\n\n// Reconfigure the controller to use the specified action set.\nvoid Steam::activateActionSet(uint64_t input_handle, uint64_t action_set_handle) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: activateActionSet\");\n\tSteamInput()->ActivateActionSet((InputHandle_t)input_handle, (ControllerActionSetHandle_t)action_set_handle);\n}\n\n// Reconfigure the controller to use the specified action set layer.\nvoid Steam::activateActionSetLayer(uint64_t input_handle, uint64_t action_set_layer_handle) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: activateActionSetLayer\");\n\tSteamInput()->ActivateActionSetLayer((InputHandle_t)input_handle, (ControllerActionSetHandle_t)action_set_layer_handle);\n}\n\n// Reconfigure the controller to stop using the specified action set.\nvoid Steam::deactivateActionSetLayer(uint64_t input_handle, uint64_t action_set_handle) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL,  \"[STEAM] Input not found when calling: deactivateActionSetLayer\");\n\tSteamInput()->DeactivateActionSetLayer((InputHandle_t)input_handle, (ControllerActionSetHandle_t)action_set_handle);\n}\n\n// Reconfigure the controller to stop using all action set layers.\nvoid Steam::deactivateAllActionSetLayers(uint64_t input_handle) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: deactivateAllActionSetLayers\");\n\tSteamInput()->DeactivateAllActionSetLayers((InputHandle_t)input_handle);\n}\n\n// Enable SteamInputActionEvent_t callbacks. Directly calls your callback function for lower latency than standard Steam callbacks.\n// Supports one callback at a time.\n// Note: this is called within either SteamInput()->RunFrame or by SteamAPI_RunCallbacks\nvoid Steam::enableActionEventCallbacks() {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: enableActionEventCallbacks\");\n\tSteamInputActionEventCallbackPointer callback = [](SteamInputActionEvent_t *call_data){\n\t\tSteam::get_singleton()->inputActionEventCallback(call_data);\n\t};\n\tSteamInput()->EnableActionEventCallbacks(callback);\n}\n\n// Enable SteamInputDeviceConnected_t and SteamInputDeviceDisconnected_t callbacks. Each controller that is already connected\n// will generate a device connected callback when you enable them.\nvoid Steam::enableDeviceCallbacks() {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: enableDeviceCallbacks\");\n\tSteamInput()->EnableDeviceCallbacks();\n}\n\n// Lookup the handle for an Action Set. Best to do this once on startup, and store the handles for all future API calls.\nuint64_t Steam::getActionSetHandle(const String &action_set_name) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: activateActionSet\");\n\treturn (uint64_t)SteamInput()->GetActionSetHandle(action_set_name.utf8().get_data());\n}\n\n// Get an action origin that you can use in your glyph look up table or passed into GetGlyphForActionOrigin or\n// GetStringForActionOrigin.\nInputActionOrigin Steam::getActionOriginFromXboxOrigin(uint64_t input_handle, int origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, INPUT_ACTION_ORIGIN_NONE, \"[STEAM] Input not found when calling: getActionOriginFromXboxOrigin\");\n\treturn InputActionOrigin(SteamInput()->GetActionOriginFromXboxOrigin((InputHandle_t)input_handle, (EXboxOrigin)origin));\n}\n\n// Fill an array with all of the currently active action set layers for a specified controller handle.\nArray Steam::getActiveActionSetLayers(uint64_t input_handle) {\n\tArray handles;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, handles, \"[STEAM] Input not found when calling: getActiveActionSetLayers\");\n\tInputActionSetHandle_t out[INPUT_MAX_COUNT];\n\tint ret = SteamInput()->GetActiveActionSetLayers(input_handle, out);\n\tfor (int i = 0; i < ret; i++) {\n\t\thandles.push_back((uint64_t)out[i]);\n\t}\n\treturn handles;\n}\n\n// Returns the current state of the supplied analog game action.\nDictionary Steam::getAnalogActionData(uint64_t input_handle, uint64_t analog_action_handle) {\n\tDictionary action_data;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, action_data, \"[STEAM] Input not found when calling: getAnalogActionData\");\n\tControllerAnalogActionData_t data;\n\tmemset(&data, 0, sizeof(data));\n\tif (SteamInput() != NULL) {\n\t\tdata = SteamInput()->GetAnalogActionData((InputHandle_t)input_handle, (ControllerAnalogActionHandle_t)analog_action_handle);\n\t}\n\taction_data[\"mode\"] = data.eMode;\n\taction_data[\"x\"] = data.x;\n\taction_data[\"y\"] = data.y;\n\taction_data[\"active\"] = data.bActive;\n\treturn action_data;\n}\n\n// Get the handle of the specified Analog action.\nuint64_t Steam::getAnalogActionHandle(const String &action_name) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getAnalogActionHandle\");\n\treturn (uint64_t)SteamInput()->GetAnalogActionHandle(action_name.utf8().get_data());\n}\n\n// Get the origin(s) for an analog action within an action.\nArray Steam::getAnalogActionOrigins(uint64_t input_handle, uint64_t action_set_handle, uint64_t analog_action_handle) {\n\tArray list;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, list, \"[STEAM] Input not found when calling: getAnalogActionOrigins\");\n\tEInputActionOrigin out[STEAM_CONTROLLER_MAX_ORIGINS];\n\tint ret = SteamInput()->GetAnalogActionOrigins((InputHandle_t)input_handle, (ControllerActionSetHandle_t)action_set_handle, (ControllerAnalogActionHandle_t)analog_action_handle, out);\n\tfor (int i = 0; i < ret; i++) {\n\t\tlist.push_back((int)out[i]);\n\t}\n\treturn list;\n}\n\n// Get current controllers handles.\nArray Steam::getConnectedControllers() {\n\tArray list;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, list, \"[STEAM] Input not found when calling: getConnectedControllers\");\n\tInputHandle_t handles[INPUT_MAX_COUNT];\n\tint ret = SteamInput()->GetConnectedControllers(handles);\n\tprintf(\"[Steam] Inputs found %d controllers.\", ret);\n\tfor (int i = 0; i < ret; i++) {\n\t\tlist.push_back((uint64_t)handles[i]);\n\t}\n\treturn list;\n}\n\n// Returns the associated controller handle for the specified emulated gamepad.\nuint64_t Steam::getControllerForGamepadIndex(int index) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getControllerForGamepadIndex\");\n\treturn (uint64_t)SteamInput()->GetControllerForGamepadIndex(index);\n}\n\n// Get the currently active action set for the specified controller.\nuint64_t Steam::getCurrentActionSet(uint64_t input_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getCurrentActionSet\");\n\treturn (uint64_t)SteamInput()->GetCurrentActionSet((InputHandle_t)input_handle);\n}\n\n// Get's the major and minor device binding revisions for Steam Input API configurations. Minor revisions are for small changes\n// such as adding a new option action or updating localization in the configuration. When updating a Minor revision only one new\n// configuration needs to be update with the \"Use Action Block\" flag set. Major revisions are to be used when changing the number\n// of action sets or otherwise reworking configurations to the degree that older configurations are no longer usable. When a\n// user's binding disagree's with the major revision of the current official configuration Steam will forcibly update the user to\n// the new configuration. New configurations will need to be made for every controller when updating the Major revision.\nArray Steam::getDeviceBindingRevision(uint64_t input_handle) {\n\tArray revision;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, revision, \"[STEAM] Input not found when calling: getDeviceBindingRevision\");\n\tint major = 0;\n\tint minor = 0;\n\tbool success = SteamInput()->GetDeviceBindingRevision((InputHandle_t)input_handle, &major, &minor);\n\tif (success) {\n\t\trevision.append(major);\n\t\trevision.append(minor);\n\t}\n\treturn revision;\n}\n\n// Returns the current state of the supplied digital game action.\nDictionary Steam::getDigitalActionData(uint64_t input_handle, uint64_t digital_action_handle) {\n\tDictionary digital_action;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, digital_action, \"[STEAM] Input not found when calling: getDigitalActionData\");\n\tInputDigitalActionData_t data;\n\tmemset(&data, 0, sizeof(data));\n\tif (SteamInput() != NULL) {\n\t\tdata = SteamInput()->GetDigitalActionData((InputHandle_t)input_handle, (ControllerDigitalActionHandle_t)digital_action_handle);\n\t}\n\tdigital_action[\"state\"] = data.bState;\n\tdigital_action[\"active\"] = data.bActive;\n\treturn digital_action;\n}\n\n// Get the handle of the specified digital action.\nuint64_t Steam::getDigitalActionHandle(const String &action_name) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getDigitalActionHandle\");\n\treturn (uint64_t)SteamInput()->GetDigitalActionHandle(action_name.utf8().get_data());\n}\n\n// Get the origin(s) for an analog action within an action.\nArray Steam::getDigitalActionOrigins(uint64_t input_handle, uint64_t action_set_handle, uint64_t digital_action_handle) {\n\tArray list;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, list, \"[STEAM] Input not found when calling: getDigitalActionOrigins\");\n\tEInputActionOrigin out[STEAM_CONTROLLER_MAX_ORIGINS];\n\tint ret = SteamInput()->GetDigitalActionOrigins((InputHandle_t)input_handle, (ControllerActionSetHandle_t)action_set_handle, (ControllerDigitalActionHandle_t)digital_action_handle, out);\n\tfor (int i = 0; i < ret; i++) {\n\t\tlist.push_back((int)out[i]);\n\t}\n\treturn list;\n}\n\n// Returns the associated gamepad index for the specified controller.\nint Steam::getGamepadIndexForController(uint64_t input_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, -1, \"[STEAM] Input not found when calling: getGamepadIndexForController\");\n\treturn SteamInput()->GetGamepadIndexForController((InputHandle_t)input_handle);\n}\n\n// Get a local path to art for on-screen glyph for a particular origin.\nString Steam::getGlyphForActionOrigin(InputActionOrigin origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getGlyphForActionOrigin\");\n\tERR_FAIL_COND_V_MSG(origin < 0 || origin > InputActionOrigin(k_EInputActionOrigin_MaximumPossibleValue), \"\", \"[Steam] origin is invalid for getGlyphForActionOrigin\");\n\treturn SteamInput()->GetGlyphForActionOrigin_Legacy((EInputActionOrigin)origin);\n}\n\n// Get a local path to art for on-screen glyph for a particular Xbox controller origin\nString Steam::getGlyphForXboxOrigin(int origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getGlyphForXboxOrigin\");\n\treturn SteamInput()->GetGlyphForXboxOrigin((EXboxOrigin)origin);\n}\n\n// Get a local path to a PNG file for the provided origin's glyph.\nString Steam::getGlyphPNGForActionOrigin(InputActionOrigin origin, InputGlyphSize size, uint32 flags) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getGlyphPNGForActionOrigin\");\n\treturn SteamInput()->GetGlyphPNGForActionOrigin((EInputActionOrigin)origin, (ESteamInputGlyphSize)size, flags);\n}\n\n// Get a local path to a SVG file for the provided origin's glyph.\nString Steam::getGlyphSVGForActionOrigin(InputActionOrigin origin, uint32 flags) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getGlyphSVGForActionOrigin\");\n\treturn SteamInput()->GetGlyphSVGForActionOrigin((EInputActionOrigin)origin, flags);\n}\n\n// Get the input type (device model) for the specified controller.\nInputType Steam::getInputTypeForHandle(uint64_t input_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, INPUT_TYPE_UNKNOWN, \"[STEAM] Input not found when calling: getInputTypeForHandle\");\n\tESteamInputType this_input_type = SteamInput()->GetInputTypeForHandle((InputHandle_t)input_handle);\n\treturn (InputType)this_input_type;\n}\n\n// Returns raw motion data for the specified controller.\nDictionary Steam::getMotionData(uint64_t input_handle) {\n\tDictionary motion_data;\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, motion_data, \"[STEAM] Input not found when calling: getMotionData\");\n\tControllerMotionData_t data;\n\tmemset(&data, 0, sizeof(data));\n\tdata = SteamInput()->GetMotionData((InputHandle_t)input_handle);\n\n\tmotion_data[\"rot_quat_x\"] = data.rotQuatX;\n\tmotion_data[\"rot_quat_y\"] = data.rotQuatY;\n\tmotion_data[\"rot_quat_z\"] = data.rotQuatZ;\n\tmotion_data[\"rot_quat_w\"] = data.rotQuatW;\n\tmotion_data[\"pos_accel_x\"] = data.posAccelX;\n\tmotion_data[\"pos_accel_y\"] = data.posAccelY;\n\tmotion_data[\"pos_accel_z\"] = data.posAccelZ;\n\tmotion_data[\"rot_vel_x\"] = data.rotVelX;\n\tmotion_data[\"rot_vel_y\"] = data.rotVelY;\n\tmotion_data[\"rot_vel_z\"] = data.rotVelZ;\n\treturn motion_data;\n}\n\n// Get the Steam Remote Play session ID associated with a device, or 0 if there is no session associated with it. See\n// isteamremoteplay.h for more information on Steam Remote Play sessions.\nint Steam::getRemotePlaySessionID(uint64_t input_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getRemotePlaySessionID\");\n\treturn SteamInput()->GetRemotePlaySessionID((InputHandle_t)input_handle);\n}\n\n// Get a bitmask of the Steam Input Configuration types opted in for the current session. Returns ESteamInputConfigurationEnableType\n// values.\n// Note: user can override the settings from the Steamworks Partner site so the returned values may not exactly match your default\n// configuration.\nuint16 Steam::getSessionInputConfigurationSettings() {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: getSessionInputConfigurationSettings\");\n\treturn SteamInput()->GetSessionInputConfigurationSettings();\n}\n\n// Returns a localized string (from Steam's language setting) for the specified origin.\nString Steam::getStringForActionOrigin(InputActionOrigin origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getStringForActionOrigin\");\n\treturn SteamInput()->GetStringForActionOrigin((EInputActionOrigin)origin);\n}\n\n// Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.\nString Steam::getStringForAnalogActionName(uint64_t action_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getStringForAnalogActionName\");\n\treturn SteamInput()->GetStringForAnalogActionName((InputAnalogActionHandle_t)action_handle);\n}\n\n// Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.\nString Steam::getStringForDigitalActionName(uint64_t action_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getStringForDigitalActionName\");\n\treturn SteamInput()->GetStringForDigitalActionName((InputDigitalActionHandle_t)action_handle);\n}\n\n// Returns a localized string (from Steam's language setting) for the specified Xbox controller origin.\nString Steam::getStringForXboxOrigin(int origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, \"\", \"[STEAM] Input not found when calling: getStringForXboxOrigin\");\n\treturn SteamInput()->GetStringForXboxOrigin((EXboxOrigin)origin);\n}\n\n// Start SteamInputs interface.\nbool Steam::inputInit(bool explicitly_call_runframe) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: inputInit\");\n\treturn SteamInput()->Init(explicitly_call_runframe);\n}\n\n// Stop SteamInputs interface.\nbool Steam::inputShutdown() {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: inputShutdown\");\n\treturn SteamInput()->Shutdown();\n}\n\n// Returns true if new data has been received since the last time action data was accessed via GetDigitalActionData or\n// GetAnalogActionData. The game will still need to call SteamInput()->RunFrame() or SteamAPI_RunCallbacks() before this to update\n// the data stream.\nbool Steam::newDataAvailable() {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: newDataAvailable\");\n\treturn SteamInput()->BNewDataAvailable();\n}\n\n// Syncronize controllers.\nvoid Steam::runFrame(bool reserved_value) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: runFrame\");\n\tSteamInput()->RunFrame(reserved_value);\n}\n\n// Set the trigger effect for a DualSense controller\nvoid Steam::setDualSenseTriggerEffect(uint64_t input_handle, int parameter_index, int trigger_mask, SCEPadTriggerEffectMode effect_mode, int position, int amplitude, int frequency) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: getActiveActionSetLayers\");\n\tScePadTriggerEffectParam these_parameters;\n\tmemset(&these_parameters, 0, sizeof(these_parameters));\n\tthese_parameters.triggerMask = trigger_mask;\n\n\tif (effect_mode == 0) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_OFF;\n\t}\n\telse if (effect_mode == 1) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_FEEDBACK;\n\t}\n\telse if (effect_mode == 2) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_WEAPON;\n\t}\n\telse if (effect_mode == 3) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_VIBRATION;\n\t}\n\telse if (effect_mode == 4) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_FEEDBACK;\n\t}\n\telse if (effect_mode == 5) {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_SLOPE_FEEDBACK;\n\t}\n\telse {\n\t\tthese_parameters.command[parameter_index].mode = SCE_PAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_VIBRATION;\n\t}\n\tthese_parameters.command[parameter_index].commandData.vibrationParam.position = position;\n\tthese_parameters.command[parameter_index].commandData.vibrationParam.amplitude = amplitude;\n\tthese_parameters.command[parameter_index].commandData.vibrationParam.frequency = frequency;\n\tSteamInput()->SetDualSenseTriggerEffect((InputHandle_t)input_handle, &these_parameters);\n}\n\n// Set the absolute path to the Input Action Manifest file containing the in-game actions and file paths to the official\n// configurations. Used in games that bundle Steam Input configurations inside of the game depot instead of using the Steam Workshop.\nbool Steam::setInputActionManifestFilePath(const String &manifest_path) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: setInputActionManifestFilePath\");\n\treturn SteamInput()->SetInputActionManifestFilePath(manifest_path.utf8().get_data());\n}\n\n// Set the controller LED color on supported controllers.\nvoid Steam::setLEDColor(uint64_t input_handle, int color_r, int color_g, int color_b, int flags) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: setLEDColor\");\n\tSteamInput()->SetLEDColor((InputHandle_t)input_handle, color_r, color_g, color_b, flags);\n}\n\n// Invokes the Steam overlay and brings up the binding screen.\nbool Steam::showBindingPanel(uint64_t input_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: showBindingPanel\");\n\treturn SteamInput()->ShowBindingPanel((InputHandle_t)input_handle);\n}\n\n// Stops the momentum of an analog action (where applicable, ie a touchpad w/ virtual trackball settings).\nvoid Steam::stopAnalogActionMomentum(uint64_t input_handle, uint64_t action) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: stopAnalogActionMomentum\");\n\tSteamInput()->StopAnalogActionMomentum((InputHandle_t)input_handle, (InputAnalogActionHandle_t)action);\n}\n\n// Get the equivalent origin for a given controller type or the closest controller type that existed in the SDK you built into\n// your game if eDestinationInputType is k_ESteamInputType_Unknown. This action origin can be used in your glyph look up table\n// or passed into GetGlyphForActionOrigin or GetStringForActionOrigin.\nint Steam::translateActionOrigin(InputType destination_input, InputActionOrigin source_origin) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, 0, \"[STEAM] Input not found when calling: translateActionOrigin\");\n\treturn SteamInput()->TranslateActionOrigin((ESteamInputType)destination_input, (EInputActionOrigin)source_origin);\n}\n\n// Triggers a (low-level) haptic pulse on supported controllers.\nvoid Steam::triggerHapticPulse(uint64_t input_handle, int target_pad, int duration) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: triggerHapticPulse\");\n\tSteamInput()->Legacy_TriggerHapticPulse((InputHandle_t)input_handle, (ESteamControllerPad)target_pad, duration);\n}\n\n// Triggers a repeated haptic pulse on supported controllers.\nvoid Steam::triggerRepeatedHapticPulse(uint64_t input_handle, int target_pad, int duration, int offset, int repeat, int flags) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: triggerRepeatedHapticPulse\");\n\tSteamInput()->Legacy_TriggerRepeatedHapticPulse((InputHandle_t)input_handle, (ESteamControllerPad)target_pad, duration, offset, repeat, flags);\n}\n\n// Send a haptic pulse, works on Steam Deck and Steam Controller devices.\nvoid Steam::triggerSimpleHapticEvent(uint64_t input_handle, int haptic_location, uint8 intensity, const String &gain_db, uint8 other_intensity, const String &other_gain_db) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: triggerSimpleHapticEvent\");\n\tchar gain = gain_db[0];\n\tchar other_gain = other_gain_db[0];\n\tSteamInput()->TriggerSimpleHapticEvent((InputHandle_t)input_handle, (EControllerHapticLocation)haptic_location, intensity, gain, other_intensity, other_gain);\n}\n\n// Trigger a vibration event on supported controllers.\nvoid Steam::triggerVibration(uint64_t input_handle, uint16_t left_speed, uint16_t right_speed) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: triggerVibration\");\n\tSteamInput()->TriggerVibration((InputHandle_t)input_handle, (unsigned short)left_speed, (unsigned short)right_speed);\n}\n\n// Trigger a vibration event on supported controllers including Xbox trigger impulse rumble - Steam will translate these commands\n// into haptic pulses for Steam Controllers.\nvoid Steam::triggerVibrationExtended(uint64_t input_handle, uint16_t left_speed, uint16_t right_speed, uint16_t left_trigger_speed, uint16_t right_trigger_speed) {\n\tERR_FAIL_COND_MSG(SteamInput() == NULL, \"[STEAM] Input not found when calling: triggerVibrationExtended\");\n\tSteamInput()->TriggerVibrationExtended((InputHandle_t)input_handle, (unsigned short)left_speed, (unsigned short)right_speed, (unsigned short)left_trigger_speed, (unsigned short)right_trigger_speed);\n}\n\n// Waits on an IPC event from Steam sent when there is new data to be fetched from the data drop. Returns true when data was\n// recievied before the timeout expires. Useful for games with a dedicated input thread.\nbool Steam::waitForData(bool wait_forever, uint32 timeout) {\n\tERR_FAIL_COND_V_MSG(SteamInput() == NULL, false, \"[STEAM] Input not found when calling: waitForData\");\n\treturn SteamInput()->BWaitForData(wait_forever, timeout);\n}\n\n\n///// INVENTORY\n\n///// When dealing with any inventory handles, you should call CheckResultSteamID on the result handle when it completes to verify\n///// that a remote player is not pretending to have a different user's inventory.\n///// Also, you must call DestroyResult on the provided inventory result when you are done with it.\n\n// Grant a specific one-time promotional item to the current user.\nint32 Steam::addPromoItem(uint32 item) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: addPromoItem\");\n\tif (SteamInventory()->AddPromoItem(&new_inventory_handle, item)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Grant a specific one-time promotional items to the current user.\nint32 Steam::addPromoItems(PackedInt64Array items) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: addPromoItems\");\n\tint count = items.size();\n\tSteamItemDef_t *new_items = new SteamItemDef_t[items.size()];\n\n\tfor (int i = 0; i < count; i++) {\n\t\tnew_items[i] = items[i];\n\t}\n\t\t\n\tif (SteamInventory()->AddPromoItems(&new_inventory_handle, new_items, count)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\tdelete[] new_items;\n\treturn new_inventory_handle;\n}\n\n// Checks whether an inventory result handle belongs to the specified Steam ID.\nbool Steam::checkResultSteamID(uint64_t steam_id_expected, int32 this_inventory_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: checkResultSteamID\");\n\tCSteamID steam_id = (uint64)steam_id_expected;\n\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\treturn SteamInventory()->CheckResultSteamID((SteamInventoryResult_t)this_inventory_handle, steam_id);\n}\n\n// Consumes items from a user's inventory. If the quantity of the given item goes to zero, it is permanently removed.\nint32 Steam::consumeItem(uint64_t item_consume, uint32 quantity) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: consumeItem\");\n\tif (SteamInventory()->ConsumeItem(&new_inventory_handle, (SteamItemInstanceID_t)item_consume, quantity)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Deserializes a result set and verifies the signature bytes.\nint32 Steam::deserializeResult(PackedByteArray buffer) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, 0, \"[STEAM] Inventory class not found when calling: deserializeResult\");\n\tif (SteamInventory()->DeserializeResult(&new_inventory_handle, buffer.ptr(), buffer.size(), false)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Destroys a result handle and frees all associated memory.\nvoid Steam::destroyResult(int this_inventory_handle) {\n\tERR_FAIL_COND_MSG(SteamInventory() == NULL, \"[STEAM] Inventory class not found when calling: destroyResult\");\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\tSteamInventory()->DestroyResult((SteamInventoryResult_t)this_inventory_handle);\n}\n\n// Grant one item in exchange for a set of other items.\nint32 Steam::exchangeItems(const PackedInt64Array output_items, const PackedInt32Array output_quantity, const PackedInt64Array input_items, const PackedInt32Array input_quantity) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: exchangeItems\");\n\tuint32 total_output = output_items.size();\n\tSteamItemDef_t *generated_items = new SteamItemDef_t[total_output];\n\tfor (uint32 i = 0; i < total_output; i++) {\n\t\tgenerated_items[i] = output_items[i];\n\t}\n\n\tuint32_t *quantity_out = (uint32*) output_quantity.ptr();\n\tuint32_t *quantity_in = (uint32*) input_quantity.ptr();\n\t\n\tuint32 array_size = input_items.size();\n\tSteamItemInstanceID_t *input_item_ids = new SteamItemInstanceID_t[array_size];\n\tfor (uint32 i = 0; i < array_size; i++) {\n\t\tinput_item_ids[i] = input_items[i];\n\t}\n\tconst SteamItemInstanceID_t *these_item_ids = input_item_ids;\n\n\tif (SteamInventory()->ExchangeItems(&new_inventory_handle, generated_items, quantity_out, total_output, these_item_ids, quantity_in, array_size)) {\n\t\t// Update the internally stored handle\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\tdelete[] generated_items;\n\tdelete[] input_item_ids;\n\treturn new_inventory_handle;\n}\n\n// Grants specific items to the current user, for developers only.\nint32 Steam::generateItems(const PackedInt64Array items, const PackedInt32Array quantity) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: generateItems\");\n\tuint32 total_quantity = items.size();\n\tSteamItemDef_t *generated_items = new SteamItemDef_t[total_quantity];\n\n\tfor (uint32 i = 0; i < total_quantity; i++) {\n\t\tgenerated_items[i] = items[i];\n\t}\n\n\tuint32_t *this_quantity = (uint32*) quantity.ptr();\n\tif (SteamInventory()->GenerateItems(&new_inventory_handle, generated_items, this_quantity, items.size())) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\tdelete[] generated_items;\n\treturn new_inventory_handle;\n}\n\n// Start retrieving all items in the current users inventory.\nint32 Steam::getAllItems() {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: getAllItems\");\n\tif (SteamInventory()->GetAllItems(&new_inventory_handle)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Gets a string property from the specified item definition.  Gets a property value for a specific item definition.\nString Steam::getItemDefinitionProperty(uint32 definition, const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, \"\", \"[STEAM] Inventory class not found when calling: getItemDefinitionProperty\");\n\tchar buffer[STEAM_BUFFER_SIZE];\n\tuint32 buffer_size = std::size(buffer);\n\tSteamInventory()->GetItemDefinitionProperty(definition, name.utf8().get_data(), buffer, &buffer_size);\n\tString property = String::utf8(buffer, buffer_size);\n\treturn property;\n}\n\n// After a successful call to RequestPrices, you can call this method to get the pricing for a specific item definition.\nDictionary Steam::getItemPrice(uint32 definition) {\n\tDictionary prices;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, prices, \"[STEAM] Inventory class not found when calling: getItemPrice\");\n\tuint64 price = 0;\n\tuint64 base_price = 0;\n\tSteamInventory()->GetItemPrice(definition, &price, &base_price);\n\tprices[\"price\"] = (uint64_t)price;\n\tprices[\"base_price\"] = (uint64_t)base_price;\n\treturn prices;\n}\n\n// Gets the state of a subset of the current user's inventory.\nint32 Steam::getItemsByID(const PackedInt64Array id_array) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: getItemsByID\");\n\tuint32 array_size = id_array.size();\n\tSteamItemInstanceID_t *item_ids = new SteamItemInstanceID_t[array_size];\n\n\tfor (uint32 i = 0; i < array_size; i++) {\n\t\titem_ids[i] = id_array[i];\n\t}\n\tconst SteamItemInstanceID_t *these_item_ids = item_ids;\n\n\tif (SteamInventory()->GetItemsByID(&new_inventory_handle, these_item_ids, array_size)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\tdelete[] item_ids;\n\treturn new_inventory_handle;\n}\n\n// After a successful call to RequestPrices, you can call this method to get all the pricing for applicable item definitions. Use\n// the result of GetNumItemsWithPrices as the the size of the arrays that you pass in.\nArray Steam::getItemsWithPrices() {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, Array(), \"[STEAM] Inventory class not found when calling: getItemsWithPrices\");\n\tuint32 valid_prices = SteamInventory()->GetNumItemsWithPrices();\n\tArray price_array;\n\tSteamItemDef_t *ids = new SteamItemDef_t[valid_prices];\n\tuint64 *prices = new uint64[valid_prices];\n\tuint64 *base_prices = new uint64[valid_prices];\n\n\tif (SteamInventory()->GetItemsWithPrices(ids, prices, base_prices, valid_prices)) {\n\t\tfor (uint32 i = 0; i < valid_prices; i++) {\n\t\t\tDictionary price_group;\n\t\t\tprice_group[\"item\"] = ids[i];\n\t\t\tprice_group[\"price\"] = (uint64_t)prices[i];\n\t\t\tprice_group[\"base_prices\"] = (uint64_t)base_prices[i];\n\t\t\tprice_array.append(price_group);\n\t\t}\n\t}\n\tdelete[] ids;\n\tdelete[] prices;\n\tdelete[] base_prices;\n\treturn price_array;\n}\n\n// Gets the dynamic properties from an item in an inventory result set.\nString Steam::getResultItemProperty(uint32 index, const String &name, int32 this_inventory_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, \"\", \"[STEAM] Inventory class not found when calling: getResultItemProperty\");\n\tchar value[256];\n\tuint32 buffer_size = std::size(value);\n\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\n\tif (name.is_empty()) {\n\t\tSteamInventory()->GetResultItemProperty((SteamInventoryResult_t)this_inventory_handle, index, NULL, value, &buffer_size);\n\t}\n\telse {\n\t\tSteamInventory()->GetResultItemProperty((SteamInventoryResult_t)this_inventory_handle, index, name.utf8().get_data(), value, &buffer_size);\n\t}\n\treturn String::utf8(value, buffer_size);\n}\n\n// Get the items associated with an inventory result handle.\nArray Steam::getResultItems(int32 this_inventory_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, Array(), \"[STEAM] Inventory class not found when calling: getResultItems\");\n\tArray items;\n\tuint32 size = 0;\n\n\tif (SteamInventory()->GetResultItems((SteamInventoryResult_t)this_inventory_handle, NULL, &size)) {\n\t\tSteamItemDetails_t *item_array = new SteamItemDetails_t[size];\n\t\tif (this_inventory_handle == 0) {\n\t\t\tthis_inventory_handle = inventory_handle;\n\t\t}\n\t\tif (SteamInventory()->GetResultItems((SteamInventoryResult_t)this_inventory_handle, item_array, &size)) {\n\t\t\tfor (uint32 i = 0; i < size; i++) {\n\t\t\t\tDictionary item_info;\n\t\t\t\titem_info[\"item_id\"] = (uint64_t)item_array[i].m_itemId;\n\t\t\t\titem_info[\"item_definition\"] = item_array[i].m_iDefinition;\n\t\t\t\titem_info[\"flags\"] = item_array[i].m_unFlags;\n\t\t\t\titem_info[\"quantity\"] = item_array[i].m_unQuantity;\n\t\t\t\titems.append(item_info);\n\t\t\t}\n\t\t}\n\t\tdelete[] item_array;\n\t}\n\treturn items;\n}\n\n// Find out the status of an asynchronous inventory result handle.\nResult Steam::getResultStatus(int32 this_inventory_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, RESULT_FAIL, \"[STEAM] Inventory class not found when calling: getResultStatus\");\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\treturn (Result)SteamInventory()->GetResultStatus((SteamInventoryResult_t)this_inventory_handle);\n}\n\n// Gets the server time at which the result was generated.\nuint32 Steam::getResultTimestamp(int32 this_inventory_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, 0, \"[STEAM] Inventory class not found when calling: getResultTimestamp\");\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\treturn SteamInventory()->GetResultTimestamp((SteamInventoryResult_t)this_inventory_handle);\n}\n\n// Grant all potential one-time promotional items to the current user.\nint32 Steam::grantPromoItems() {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: grantPromoItems\");\n\tif (SteamInventory()->GrantPromoItems(&new_inventory_handle)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Triggers an asynchronous load and refresh of item definitions.\nbool Steam::loadItemDefinitions() {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: loadItemDefinitions\");\n\treturn SteamInventory()->LoadItemDefinitions();\n}\n\n// Removes a dynamic property for the given item.\nbool Steam::removeProperty(uint64_t item_id, const String &name, uint64_t this_inventory_update_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: removeProperty\");\n\t// If no inventory update handle is passed, use internal one\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\treturn SteamInventory()->RemoveProperty((SteamInventoryUpdateHandle_t)this_inventory_update_handle, (SteamItemInstanceID_t)item_id, name.utf8().get_data());\n}\n\n// Request the list of \"eligible\" promo items that can be manually granted to the given user.\nvoid Steam::requestEligiblePromoItemDefinitionsIDs(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamInventory() == NULL, \"[STEAM] Inventory class not found when calling: requestEligiblePromoItemDefinitionsIDs\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamAPICall_t api_call = SteamInventory()->RequestEligiblePromoItemDefinitionsIDs(user_id);\n\tcallResultEligiblePromoItemDefIDs.Set(api_call, this, &Steam::inventory_eligible_promo_item);\n}\n\n// Request prices for all item definitions that can be purchased in the user's local currency. A\n// SteamInventoryRequestPricesResult_t call result will be returned with the user's local currency code. After that, you can call\n// GetNumItemsWithPrices and GetItemsWithPrices to get prices for all the known item definitions, or GetItemPrice for a specific\n// item definition.\nvoid Steam::requestPrices() {\n\tERR_FAIL_COND_MSG(SteamInventory() == NULL, \"[STEAM] Inventory class not found when calling: requestPrices\");\n\tSteamAPICall_t api_call = SteamInventory()->RequestPrices();\n\tcallResultRequestPrices.Set(api_call, this, &Steam::inventory_request_prices_result);\n}\n\n// Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.\nPackedByteArray Steam::serializeResult(int32 this_inventory_handle) {\n\tPackedByteArray result_serialized;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, result_serialized, \"[STEAM] Inventory class not found when calling: serializeResult\");\n\tif (this_inventory_handle == 0) {\n\t\tthis_inventory_handle = inventory_handle;\n\t}\n\n\tuint32 buffer_size = STEAM_BUFFER_SIZE;\n\tPackedByteArray buffer;\n\tbuffer.resize(buffer_size);\n\tif (SteamInventory()->SerializeResult((SteamInventoryResult_t)this_inventory_handle, buffer.ptrw(), &buffer_size)) {\n\t\tbuffer.resize(buffer_size);\n\t\tresult_serialized = buffer;\n\t}\n\treturn result_serialized;\n}\n\n// Sets a dynamic property for the given item. Supported value types are boolean.\nbool Steam::setPropertyBool(uint64_t item_id, const String &name, bool value, uint64_t this_inventory_update_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: setPropertyBool\");\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\treturn SteamInventory()->SetProperty((SteamInventoryUpdateHandle_t)this_inventory_update_handle, (SteamItemInstanceID_t)item_id, name.utf8().get_data(), value);\n}\n\n// Sets a dynamic property for the given item. Supported value types are 32 bit floats.\nbool Steam::setPropertyFloat(uint64_t item_id, const String &name, float value, uint64_t this_inventory_update_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: setPropertyFloat\");\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\treturn SteamInventory()->SetProperty((SteamInventoryUpdateHandle_t)this_inventory_update_handle, (SteamItemInstanceID_t)item_id, name.utf8().get_data(), value);\n}\n\n// Sets a dynamic property for the given item. Supported value types are 64 bit integers.\nbool Steam::setPropertyInt(uint64_t item_id, const String &name, uint64_t value, uint64_t this_inventory_update_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: setPropertyInt\");\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\treturn SteamInventory()->SetProperty((SteamInventoryUpdateHandle_t)this_inventory_update_handle, (SteamItemInstanceID_t)item_id, name.utf8().get_data(), (int64)value);\n}\n\n// Sets a dynamic property for the given item. Supported value types are strings.\nbool Steam::setPropertyString(uint64_t item_id, const String &name, const String &value, uint64_t this_inventory_update_handle) {\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, false, \"[STEAM] Inventory class not found when calling: setPropertyString\");\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\treturn SteamInventory()->SetProperty((SteamInventoryUpdateHandle_t)this_inventory_update_handle, (SteamItemInstanceID_t)item_id, name.utf8().get_data(), value.utf8().get_data());\n}\n\n// Starts the purchase process for the user, given a \"shopping cart\" of item definitions that the user would like to buy. The user\n// will be prompted in the Steam Overlay to complete the purchase in their local currency, funding their Steam Wallet if necessary,\n// etc.\nvoid Steam::startPurchase(const PackedInt64Array items, const PackedInt32Array quantity) {\n\tERR_FAIL_COND_MSG(SteamInventory() == NULL, \"[STEAM] Inventory class not found when calling: startPurchase\");\n\tuint32 total_items = items.size();\n\tSteamItemDef_t *purchases = new SteamItemDef_t[total_items];\n\tfor (uint32 i = 0; i < total_items; i++) {\n\t\tpurchases[i] = items[i];\n\t}\n\n\tuint32_t *these_quantities = (uint32*) quantity.ptr();\n\tSteamAPICall_t api_call = SteamInventory()->StartPurchase(purchases, these_quantities, total_items);\n\tcallResultStartPurchase.Set(api_call, this, &Steam::inventory_start_purchase_result);\n\tdelete[] purchases;\n}\n\n// Starts a transaction request to update dynamic properties on items for the current user. This call is rate-limited by user, so\n// property modifications should be batched as much as possible (e.g. at the end of a map or game session). After calling\n// SetProperty or RemoveProperty for all the items that you want to modify, you will need to call SubmitUpdateProperties to send\n// the request to the Steam servers. A SteamInventoryResultReady_t callback will be fired with the results of the operation.\nvoid Steam::startUpdateProperties() {\n\tERR_FAIL_COND_MSG(SteamInventory() == NULL, \"[STEAM] Inventory class not found when calling: startUpdateProperties\");\n\tinventory_update_handle = SteamInventory()->StartUpdateProperties();\n}\n\n// Submits the transaction request to modify dynamic properties on items for the current user. See StartUpdateProperties.\nint32 Steam::submitUpdateProperties(uint64_t this_inventory_update_handle) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: submitUpdateProperties\");\n\tif (this_inventory_update_handle == 0) {\n\t\tthis_inventory_update_handle = inventory_update_handle;\n\t}\n\n\tif (SteamInventory()->SubmitUpdateProperties((SteamInventoryUpdateHandle_t)this_inventory_update_handle, &new_inventory_handle)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n// Transfer items between stacks within a user's inventory.\nint32 Steam::transferItemQuantity(uint64_t item_id, uint32 quantity, uint64_t item_destination, bool split) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: transferItemQuantity\");\n\tif (split) {\n\t\tif (SteamInventory()->TransferItemQuantity(&new_inventory_handle, (SteamItemInstanceID_t)item_id, quantity, k_SteamItemInstanceIDInvalid)) {\n\t\t\tinventory_handle = new_inventory_handle;\n\t\t}\n\t}\n\telse {\n\t\tif (SteamInventory()->TransferItemQuantity(&new_inventory_handle, (SteamItemInstanceID_t)item_id, quantity, (SteamItemInstanceID_t)item_destination)) {\n\t\t\tinventory_handle = new_inventory_handle;\n\t\t}\n\t}\n\treturn new_inventory_handle;\n}\n\n// Trigger an item drop if the user has played a long enough period of time.\nint32 Steam::triggerItemDrop(uint32 definition) {\n\tint32 new_inventory_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamInventory() == NULL, new_inventory_handle, \"[STEAM] Inventory class not found when calling: triggerItemDrop\");\n\tif (SteamInventory()->TriggerItemDrop(&new_inventory_handle, (SteamItemDef_t)definition)) {\n\t\tinventory_handle = new_inventory_handle;\n\t}\n\treturn new_inventory_handle;\n}\n\n\n///// MATCHMAKING\n\n// Adds the game server to the local list; updates the time played of the server if it already exists in the list.\nint Steam::addFavoriteGame(String ip, uint16 port, uint16 query_port, uint32 flags, uint32 last_played) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, 0, \"[STEAM] Matchmaking class not found when calling: addFavoriteGame\");\n\treturn SteamMatchmaking()->AddFavoriteGame((AppId_t)current_app_id, getIPFromString(ip), port, query_port, flags, last_played);\n}\n\n// Sets the distance for which we should search for lobbies (based on users IP address to location map on the Steam backed).\nvoid Steam::addRequestLobbyListDistanceFilter(LobbyDistanceFilter distance_filter) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListDistanceFilter\");\n\tSteamMatchmaking()->AddRequestLobbyListDistanceFilter((ELobbyDistanceFilter)distance_filter);\n}\n\n// Returns only lobbies with the specified number of slots available.\nvoid Steam::addRequestLobbyListFilterSlotsAvailable(int slots_available) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListFilterSlotsAvailable\");\n\tSteamMatchmaking()->AddRequestLobbyListFilterSlotsAvailable(slots_available);\n}\n\n// Returns results closest to the specified value. Multiple near filters can be added, with early filters taking precedence.\nvoid Steam::addRequestLobbyListNearValueFilter(const String &key_to_match, int value_to_be_close_to) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListNearValueFilter\");\n\tSteamMatchmaking()->AddRequestLobbyListNearValueFilter(key_to_match.utf8().get_data(), value_to_be_close_to);\n}\n\n// Adds a numerical comparison filter to the next RequestLobbyList call.\nvoid Steam::addRequestLobbyListNumericalFilter(const String &key_to_match, int value_to_match, LobbyComparison comparison_type) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListNumericalFilter\");\n\tSteamMatchmaking()->AddRequestLobbyListNumericalFilter(key_to_match.utf8().get_data(), value_to_match, (ELobbyComparison)comparison_type);\n}\n\n// Sets how many results to return, the lower the count the faster it is to download the lobby results & details to the client.\nvoid Steam::addRequestLobbyListResultCountFilter(int max_results) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListResultCountFilter\");\n\tSteamMatchmaking()->AddRequestLobbyListResultCountFilter(max_results);\n}\n\n// Adds a string comparison filter to the next RequestLobbyList call.\nvoid Steam::addRequestLobbyListStringFilter(const String &key_to_match, const String &value_to_match, LobbyComparison comparison_type) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: addRequestLobbyListStringFilter\");\n\tSteamMatchmaking()->AddRequestLobbyListStringFilter(key_to_match.utf8().get_data(), value_to_match.utf8().get_data(), (ELobbyComparison)comparison_type);\n}\n\n// Create a lobby on the Steam servers, if private the lobby will not be returned by any RequestLobbyList() call.\nvoid Steam::createLobby(LobbyType lobby_type, int max_members) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: createLobby\");\n\tSteamAPICall_t api_call = SteamMatchmaking()->CreateLobby((ELobbyType)lobby_type, max_members);\n\tcallResultCreateLobby.Set(api_call, this, &Steam::lobby_created);\n}\n\n// Removes a metadata key from the lobby.\nbool Steam::deleteLobbyData(uint64_t steam_lobby_id, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: deleteLobbyData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->DeleteLobbyData(lobby_id, key.utf8().get_data());\n}\n\n// Get lobby data by the lobby's ID\nDictionary Steam::getAllLobbyData(uint64_t steam_lobby_id) {\n\tDictionary all_data;\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, all_data, \"[STEAM] Matchmaking class not found when calling: getAllLobbyData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tint data_count = SteamMatchmaking()->GetLobbyDataCount(lobby_id);\n\tchar key[MAX_LOBBY_KEY_LENGTH];\n\tchar value[CHAT_METADATA_MAX];\n\tfor (int i = 0; i < data_count; i++) {\n\t\tbool success = SteamMatchmaking()->GetLobbyDataByIndex(lobby_id, i, key, MAX_LOBBY_KEY_LENGTH, value, CHAT_METADATA_MAX);\n\t\tif (success) {\n\t\t\tDictionary data;\n\t\t\tdata[\"index\"] = i;\n\t\t\tdata[\"key\"] = key;\n\t\t\tdata[\"value\"] = value;\n\t\t\tall_data[i] = data;\n\t\t}\n\t}\n\treturn all_data;\n}\n\n// Gets an array of the details of the favorite game servers.\nArray Steam::getFavoriteGames() {\n\tArray favorites;\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, favorites, \"[STEAM] Matchmaking class not found when calling: getFavoriteGames\");\n\tint count = SteamMatchmaking()->GetFavoriteGameCount();\n\tfor (int i = 0; i < count; i++) {\n\t\tDictionary favorite;\n\t\tAppId_t app_id = 0;\n\t\tuint32 ip = 0;\n\t\tuint16 port = 0;\n\t\tuint16 query_port = 0;\n\t\tuint32 flags = 0;\n\t\tuint32 last_played = 0;\n\t\tfavorite[\"ret\"] = SteamMatchmaking()->GetFavoriteGame(i, &app_id, &ip, &port, &query_port, &flags, &last_played);\n\t\tif (favorite[\"ret\"]) {\n\t\t\tfavorite[\"app\"] = app_id;\n\t\t\tfavorite[\"ip\"] = getStringFromIP(ip);\n\t\t\tfavorite[\"game_port\"] = port;\n\t\t\tfavorite[\"query_port\"] = query_port;\n\t\t\tfavorite[\"flags\"] = flags;\n\t\t\tfavorite[\"played\"] = last_played;\n\t\t\tfavorites.append(favorite);\n\t\t}\n\t}\n\treturn favorites;\n}\n\n// Get data associated with this lobby.\nString Steam::getLobbyData(uint64_t steam_lobby_id, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, \"\", \"[STEAM] Matchmaking class not found when calling: getLobbyData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn String::utf8(SteamMatchmaking()->GetLobbyData(lobby_id, key.utf8().get_data()));\n}\n\n// Returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist.\nDictionary Steam::getLobbyGameServer(uint64_t steam_lobby_id) {\n\tDictionary game_server;\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, game_server, \"[STEAM] Matchmaking class not found when calling: getLobbyGameServer\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tuint32 server_ip = 0;\n\tuint16 server_port = 0;\n\tCSteamID server_id;\n\tgame_server[\"ret\"] = SteamMatchmaking()->GetLobbyGameServer(lobby_id, &server_ip, &server_port, &server_id);\n\tif (game_server[\"ret\"]) {\n\t\tgame_server[\"ip\"] = getStringFromIP(server_ip);\n\t\tgame_server[\"port\"] = server_port;\n\t\t// Convert the server ID\n\t\tuint64_t server = server_id.ConvertToUint64();\n\t\tgame_server[\"id\"] = server;\n\t}\n\treturn game_server;\n}\n\n// Returns the CSteamID of a user in the lobby.\nuint64_t Steam::getLobbyMemberByIndex(uint64_t steam_lobby_id, int member) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, 0, \"[STEAM] Matchmaking class not found when calling: getLobbyMemberByIndex\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tCSteamID lobbyMember = SteamMatchmaking()->GetLobbyMemberByIndex(lobby_id, member);\n\treturn lobbyMember.ConvertToUint64();\n}\n\n// Gets per-user metadata for someone in this lobby.\nString Steam::getLobbyMemberData(uint64_t steam_lobby_id, uint64_t steam_id_user, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, \"\", \"[STEAM] Matchmaking class not found when calling: getLobbyMemberData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tCSteamID user_id = (uint64)steam_id_user;\n\treturn SteamMatchmaking()->GetLobbyMemberData(lobby_id, user_id, key.utf8().get_data());\n}\n\n// Returns the current limit on the # of users who can join the lobby; returns 0 if no limit is defined.\nint Steam::getLobbyMemberLimit(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, 0, \"[STEAM] Matchmaking class not found when calling: getLobbyMemberLimit\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->GetLobbyMemberLimit(lobby_id);\n}\n\n// Returns the current lobby owner.\nuint64_t Steam::getLobbyOwner(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, 0, \"[STEAM] Matchmaking class not found when calling: getLobbyOwner\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tCSteamID owner_id = SteamMatchmaking()->GetLobbyOwner(lobby_id);\n\treturn owner_id.ConvertToUint64();\n}\n\n// Lobby iteration, for viewing details of users in a lobby.\nint Steam::getNumLobbyMembers(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, 0, \"[STEAM] Matchmaking class not found when calling: getNumLobbyMembers\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->GetNumLobbyMembers(lobby_id);\n}\n\n// Invite another user to the lobby, the target user will receive a LobbyInvite_t callback, will return true if the invite is\n// successfully sent, whether or not the target responds.\nbool Steam::inviteUserToLobby(uint64_t steam_lobby_id, uint64_t steam_id_invitee) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: inviteUserToLobby\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tCSteamID invitee_id = (uint64)steam_id_invitee;\n\treturn SteamMatchmaking()->InviteUserToLobby(lobby_id, invitee_id);\n}\n\n// Join an existing lobby.\nvoid Steam::joinLobby(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: joinLobby\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tSteamMatchmaking()->JoinLobby(lobby_id);\n}\n\n// Leave a lobby, this will take effect immediately on the client side, other users will be notified by LobbyChatUpdate_t callback.\nvoid Steam::leaveLobby(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: leaveLobby\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tSteamMatchmaking()->LeaveLobby(lobby_id);\n}\n\n// Removes the game server from the local storage; returns true if one was removed.\nbool Steam::removeFavoriteGame(uint32 app_id, String ip, uint16 port, uint16 query_port, uint32 flags) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: removeFavoriteGame\");\n\treturn SteamMatchmaking()->RemoveFavoriteGame((AppId_t)app_id, getIPFromString(ip), port, query_port, flags);\n}\n\n// Refreshes metadata for a lobby you're not necessarily in right now.\nbool Steam::requestLobbyData(uint64_t steam_lobby_id) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: requestLobbyData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->RequestLobbyData(lobby_id);\n}\n\n// Get a list of relevant lobbies.\nvoid Steam::requestLobbyList() {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: requestLobbyList\");\n\tSteamAPICall_t api_call = SteamMatchmaking()->RequestLobbyList();\n\tcallResultLobbyList.Set(api_call, this, &Steam::lobby_match_list);\n}\n\n// Broadcasts a chat message to the all the users in the lobby.\nbool Steam::sendLobbyChatMsg(uint64_t steam_lobby_id, const String &message_body) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: sendLobbyChatMsg\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->SendLobbyChatMsg(lobby_id, message_body.utf8().get_data(), strlen(message_body.utf8().get_data()) + 1);\n}\n\n// Sets a key/value pair in the lobby metadata.\nbool Steam::setLobbyData(uint64_t steam_lobby_id, const String &key, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: setLobbyData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->SetLobbyData(lobby_id, key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Sets the game server associated with the lobby.\nvoid Steam::setLobbyGameServer(uint64_t steam_lobby_id, const String &server_ip, uint16 server_port, uint64_t steam_id_game_server) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: setLobbyGameServer\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tif (steam_id_game_server == 0) {\n\t\tSteamMatchmaking()->SetLobbyGameServer(lobby_id, getIPFromString(server_ip), server_port, k_steamIDNil);\n\t}\n\telse {\n\t\tCSteamID game_id = (uint64)steam_id_game_server;\n\t\tSteamMatchmaking()->SetLobbyGameServer(lobby_id, getIPFromString(server_ip), server_port, game_id);\n\t}\n}\n\n// Sets whether or not a lobby is joinable - defaults to true for a new lobby.\nbool Steam::setLobbyJoinable(uint64_t steam_lobby_id, bool joinable) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: setLobbyJoinable\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->SetLobbyJoinable(lobby_id, joinable);\n}\n\n// Sets per-user metadata (for the local user implicitly).\nvoid Steam::setLobbyMemberData(uint64_t steam_lobby_id, const String &key, const String &value) {\n\tERR_FAIL_COND_MSG(SteamMatchmaking() == NULL, \"[STEAM] Matchmaking class not found when calling: setLobbyMemberData\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tSteamMatchmaking()->SetLobbyMemberData(lobby_id, key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Set the limit on the # of users who can join the lobby.\nbool Steam::setLobbyMemberLimit(uint64_t steam_lobby_id, int max_members) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: setLobbyMemberLimit\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->SetLobbyMemberLimit(lobby_id, max_members);\n}\n\n// Changes who the lobby owner is.\nbool Steam::setLobbyOwner(uint64_t steam_lobby_id, uint64_t steam_id_new_owner) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: setLobbyOwner\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\tCSteamID owner_id = (uint64)steam_id_new_owner;\n\treturn SteamMatchmaking()->SetLobbyOwner(lobby_id, owner_id);\n}\n\n// Updates which type of lobby it is.\nbool Steam::setLobbyType(uint64_t steam_lobby_id, LobbyType lobby_type) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmaking() == NULL, false, \"[STEAM] Matchmaking class not found when calling: setLobbyType\");\n\tCSteamID lobby_id = (uint64)steam_lobby_id;\n\treturn SteamMatchmaking()->SetLobbyType(lobby_id, (ELobbyType)lobby_type);\n}\n\n\n///// MATCHMAKING SERVERS\n\n// Cancel an outstanding server list request.\nvoid Steam::cancelQuery(uint64_t this_server_list_request) {\n\tERR_FAIL_COND_MSG(SteamMatchmakingServers() == NULL, \"[STEAM] Matchmaking Servers class not found when calling: cancelQuery\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\tSteamMatchmakingServers()->CancelQuery((HServerListRequest)this_server_list_request);\n}\n\n// Cancel an outstanding individual server query.\nvoid Steam::cancelServerQuery(int server_query) {\n\tERR_FAIL_COND_MSG(SteamMatchmakingServers() == NULL, \"[STEAM] Matchmaking Servers class not found when calling: cancelServerQuery\");\n\tSteamMatchmakingServers()->CancelServerQuery((HServerQuery)server_query);\n}\n\n// Convert an array of filters to a contiguous vector.\nstatic std::vector<MatchMakingKeyValuePair_t> filters_array_to_vector(const Array &filters) {\n\tuint32 filter_size = filters.size();\n\tstd::vector<MatchMakingKeyValuePair_t> filters_array(filter_size);\n\tfor (uint32 i = 0; i < filter_size; i++) {\n\t\t// Get the key/value pair\n\t\tArray pair = filters[i];\n\t\t// Get the key from the filter pair\n\t\tString key = pair[0];\n\t\t// Get the value from the filter pair\n\t\tString value = pair[1];\n\t\t// Create a new filter pair to populate\n\t\tfilters_array[i] = MatchMakingKeyValuePair_t(key.utf8(), value.utf8());\n\t}\n\treturn filters_array;\n}\n\n// Gets the number of servers in the given list.\nint Steam::getServerCount(uint64_t this_server_list_request) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: getServerCount\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\treturn SteamMatchmakingServers()->GetServerCount((HServerListRequest)this_server_list_request);\n}\n\n// Get the details of a given server in the list.\nDictionary Steam::getServerDetails(int server, uint64_t this_server_list_request) {\n\tDictionary game_server;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, game_server, \"[STEAM] Matchmaking Servers class not found when calling: getServerDetails\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\tgameserveritem_t *server_item = SteamMatchmakingServers()->GetServerDetails((HServerListRequest)this_server_list_request, server);\n\tgame_server = gameServerItemToDictionary(server_item);\n\treturn game_server;\n}\n\n// Returns true if the list is currently refreshing its server list.\nbool Steam::isRefreshing(uint64_t this_server_list_request) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, false, \"[STEAM] Matchmaking Servers class not found when calling: isRefreshing\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\treturn SteamMatchmakingServers()->IsRefreshing((HServerListRequest)this_server_list_request);\n}\n\n// Queries an individual game servers directly via IP/Port to request an updated ping time and other details from the server.\nint Steam::pingServer(const String &ip, uint16 port) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: pingServer\");\n\treturn SteamMatchmakingServers()->PingServer(getIPFromString(ip), port, ping_response);\n}\n\n// Request the list of players currently playing on a server.\nint Steam::playerDetails(const String &ip, uint16 port) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: playerDetails\");\n\treturn SteamMatchmakingServers()->PlayerDetails(getIPFromString(ip), port, players_response);\n}\n\n// Ping every server in your list again but don't update the list of servers. Query callback installed when the server list was\n// requested will be used again to post notifications and RefreshComplete, so the callback must remain valid until another\n// RefreshComplete is called on it or the request is released with ReleaseRequest( hRequest ).\nvoid Steam::refreshQuery(uint64_t this_server_list_request) {\n\tERR_FAIL_COND_MSG(SteamMatchmakingServers() == NULL, \"[STEAM] Matchmaking Servers class not found when calling: refreshQuery\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\tSteamMatchmakingServers()->RefreshQuery((HServerListRequest)this_server_list_request);\n}\n\n// Refresh a single server inside of a query (rather than all the servers).\nvoid Steam::refreshServer(int server, uint64_t this_server_list_request) {\n\tERR_FAIL_COND_MSG(SteamMatchmakingServers() == NULL, \"[STEAM] Matchmaking Servers class not found when calling: refreshServer\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\tSteamMatchmakingServers()->RefreshServer((HServerListRequest)this_server_list_request, server);\n}\n\n// Releases the asynchronous request object and cancels any pending query on it if there's a pending query in progress.\nvoid Steam::releaseRequest(uint64_t this_server_list_request) {\n\tERR_FAIL_COND_MSG(SteamMatchmakingServers() == NULL, \"[STEAM] Matchmaking Servers class not found when calling: releaseRequest\");\n\tif (this_server_list_request == 0) {\n\t\tthis_server_list_request = (uint64)server_list_request;\n\t}\n\tSteamMatchmakingServers()->ReleaseRequest((HServerListRequest)this_server_list_request);\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestFavoritesServerList(uint32 app_id, Array filters) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestFavoritesServerList\");\n\tauto filters_storage = filters_array_to_vector(filters);\n\tMatchMakingKeyValuePair_t *filters_array = filters_storage.data();\n\tserver_list_request = SteamMatchmakingServers()->RequestFavoritesServerList((AppId_t)app_id, &filters_array, filters_storage.size(), server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestFriendsServerList(uint32 app_id, Array filters) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestFriendsServerList\");\n\tauto filters_storage = filters_array_to_vector(filters);\n\tMatchMakingKeyValuePair_t *filters_array = filters_storage.data();\n\tserver_list_request = SteamMatchmakingServers()->RequestFriendsServerList((AppId_t)app_id, &filters_array, filters_storage.size(), server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestHistoryServerList(uint32 app_id, Array filters) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestHistoryServerList\");\n\tauto filters_storage = filters_array_to_vector(filters);\n\tMatchMakingKeyValuePair_t *filters_array = filters_storage.data();\n\tserver_list_request = SteamMatchmakingServers()->RequestHistoryServerList((AppId_t)app_id, &filters_array, filters_storage.size(), server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestInternetServerList(uint32 app_id, Array filters) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestInternetServerList\");\n\tauto filters_storage = filters_array_to_vector(filters);\n\tMatchMakingKeyValuePair_t *filters_array = filters_storage.data();\n\tserver_list_request = SteamMatchmakingServers()->RequestInternetServerList((AppId_t)app_id, &filters_array, filters_storage.size(), server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestLANServerList(uint32 app_id) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestLANServerList\");\n\tserver_list_request = SteamMatchmakingServers()->RequestLANServerList((AppId_t)app_id, server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\nuint64_t Steam::requestSpectatorServerList(uint32 app_id, Array filters) {\n\tserver_list_request = 0;\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: requestSpectatorServerList\");\n\tauto filters_storage = filters_array_to_vector(filters);\n\tMatchMakingKeyValuePair_t *filters_array = filters_storage.data();\n\tserver_list_request = SteamMatchmakingServers()->RequestSpectatorServerList((AppId_t)app_id, &filters_array, filters_storage.size(), server_list_response);\n\treturn (uint64)server_list_request;\n}\n\n// Request the list of rules that the server is running (See ISteamGameServer::SetKeyValue() to set the rules server side)\nint Steam::serverRules(const String &ip, uint16 port) {\n\tERR_FAIL_COND_V_MSG(SteamMatchmakingServers() == NULL, 0, \"[STEAM] Matchmaking Servers class not found when calling: serverRules\");\n\treturn SteamMatchmakingServers()->ServerRules(getIPFromString(ip), port, rules_response);\n}\n\n\n///// MUSIC\n\n// Is Steam music enabled.\nbool Steam::musicIsEnabled() {\n\tERR_FAIL_COND_V_MSG(SteamMusic() == NULL, false, \"[STEAM] Music class not found when calling: musicIsEnabled\");\n\treturn SteamMusic()->BIsEnabled();\n}\n\n// Is Steam music playing something.\nbool Steam::musicIsPlaying() {\n\tERR_FAIL_COND_V_MSG(SteamMusic() == NULL, false, \"[STEAM] Music class not found when calling: musicIsPlaying\");\n\treturn SteamMusic()->BIsPlaying();\n}\n\n// Gets the current status of the Steam Music player\nAudioPlaybackStatus Steam::getPlaybackStatus() {\n\tERR_FAIL_COND_V_MSG(SteamMusic() == NULL, AUDIO_PLAYBACK_UNDEFINED, \"[STEAM] Music class not found when calling: getPlaybackStatus\");\n\treturn AudioPlaybackStatus(SteamMusic()->GetPlaybackStatus());\n}\n\n// Get the volume level of the music.\nfloat Steam::musicGetVolume() {\n\tERR_FAIL_COND_V_MSG(SteamMusic() == NULL, 0.0, \"[STEAM] Music class not found when calling: musicGetVolume\");\n\treturn SteamMusic()->GetVolume();\n}\n\n// Pause whatever Steam music is playing.\nvoid Steam::musicPause() {\n\tERR_FAIL_COND_MSG(SteamMusic() == NULL, \"[STEAM] Music class not found when calling: musicPause\");\n\tSteamMusic()->Pause();\n}\n\n// Play current track/album.\nvoid Steam::musicPlay() {\n\tERR_FAIL_COND_MSG(SteamMusic() == NULL, \"[STEAM] Music class not found when calling: musicPlay\");\n\tSteamMusic()->Play();\n}\n\n// Play next track/album.\nvoid Steam::musicPlayNext() {\n\tERR_FAIL_COND_MSG(SteamMusic() == NULL, \"[STEAM] Music class not found when calling: musicPlayNext\");\n\tSteamMusic()->PlayNext();\n}\n\n// Play previous track/album.\nvoid Steam::musicPlayPrev() {\n\tERR_FAIL_COND_MSG(SteamMusic() == NULL, \"[STEAM] Music class not found when calling: musicPlayPrev\");\n\tSteamMusic()->PlayPrevious();\n}\n\n// Set the volume of Steam music.\nvoid Steam::musicSetVolume(float volume) {\n\tERR_FAIL_COND_MSG(SteamMusic() == NULL, \"[STEAM] Music class not found when calling: musicSetVolume\");\n\tSteamMusic()->SetVolume(volume);\n}\n\n\n///// MUSIC REMOTE\n\n// These functions do not have any offical notes or comments.  All descriptions are assumed.\n//\n// If remote access was successfully activated.\nbool Steam::activationSuccess(bool activate) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: activationSuccess\");\n\treturn SteamMusicRemote()->BActivationSuccess(activate);\n}\n\n// Did the currenty music entry just change?\nbool Steam::currentEntryDidChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: currentEntryDidChange\");\n\treturn SteamMusicRemote()->CurrentEntryDidChange();\n}\n\n// Is the current music entry available?\nbool Steam::currentEntryIsAvailable(bool available) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: currentEntryIsAvailable\");\n\treturn SteamMusicRemote()->CurrentEntryIsAvailable(available);\n}\n\n// Will the current music entry change?\nbool Steam::currentEntryWillChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: currentEntryWillChange\");\n\treturn SteamMusicRemote()->CurrentEntryWillChange();\n}\n\n// Disconnect from remote music client / host.\nbool Steam::deregisterSteamMusicRemote() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: deregisterSteamMusicRemote\");\n\treturn SteamMusicRemote()->DeregisterSteamMusicRemote();\n}\n\n// Enable track loop on client.\nbool Steam::enableLooped(bool loop) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnableLooped(loop);\n}\n\n// Enable playlists on client.\nbool Steam::enablePlaylists(bool playlists) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnablePlaylists(playlists);\n}\n\n// Play the next track on client.\nbool Steam::enablePlayNext(bool next) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnablePlayNext(next);\n}\n\n// Play previous track on client.\nbool Steam::enablePlayPrevious(bool previous) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnablePlayPrevious(previous);\n}\n\n// Enable the music queue on the client.\nbool Steam::enableQueue(bool queue) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnableQueue(queue);\n}\n\n// Enable shuffle on the client.\nbool Steam::enableShuffled(bool shuffle) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->EnableShuffled(shuffle);\n}\n\n// Is a remote music client / host connected?\nbool Steam::isCurrentMusicRemote() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: isCurrentMusicRemote\");\n\treturn SteamMusicRemote()->BIsCurrentMusicRemote();\n}\n\n// Has the playlist changed?\nbool Steam::playlistDidChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->PlaylistDidChange();\n}\n\n// Will the playlist change?\nbool Steam::playlistWillChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->PlaylistWillChange();\n}\n\n// Did the song queue change?\nbool Steam::queueDidChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->QueueDidChange();\n}\n\n// Will the song queue change?\nbool Steam::queueWillChange() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->QueueWillChange();\n}\n\n// Connect to a music remote client / host?\nbool Steam::registerSteamMusicRemote(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->RegisterSteamMusicRemote(name.utf8().get_data());\n}\n\n// Reset the playlist entries.\nbool Steam::resetPlaylistEntries() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: enableLooped\");\n\treturn SteamMusicRemote()->ResetPlaylistEntries();\n}\n\n// Reset the song queue entries.\nbool Steam::resetQueueEntries() {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: resetQueueEntries\");\n\treturn SteamMusicRemote()->ResetQueueEntries();\n}\n\n// Set a new current playlist.\nbool Steam::setCurrentPlaylistEntry(int id) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setCurrentPlaylistEntry\");\n\treturn SteamMusicRemote()->SetCurrentPlaylistEntry(id);\n}\n\n// Set a new current song queue.\nbool Steam::setCurrentQueueEntry(int id) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setCurrentQueueEntry\");\n\treturn SteamMusicRemote()->SetCurrentQueueEntry(id);\n}\n\n// Set a new display name.\nbool Steam::setDisplayName(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setDisplayName\");\n\treturn SteamMusicRemote()->SetDisplayName(name.utf8().get_data());\n}\n\n// Set a new playlist entry.\nbool Steam::setPlaylistEntry(int id, int position, const String &entry_text) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setPlaylistEntry\");\n\treturn SteamMusicRemote()->SetPlaylistEntry(id, position, entry_text.utf8().get_data());\n}\n\n// Set a PNG icon for a song? A playlist?\nbool Steam::setPNGIcon64x64(PackedByteArray icon) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setPNGIcon64x64\");\n\tuint32 icon_size = icon.size();\n\treturn SteamMusicRemote()->SetPNGIcon_64x64((void *)icon.ptr(), icon_size);\n}\n\n// Set a new queue entry.\nbool Steam::setQueueEntry(int id, int position, const String &entry_text) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: setQueueEntry\");\n\treturn SteamMusicRemote()->SetQueueEntry(id, position, entry_text.utf8().get_data());\n}\n\n// Update the current song entry's cover art.\nbool Steam::updateCurrentEntryCoverArt(PackedByteArray art) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateCurrentEntryCoverArt\");\n\tuint32 art_size = art.size();\n\treturn SteamMusicRemote()->UpdateCurrentEntryCoverArt((void *)art.ptr(), art_size);\n}\n\n// Update the current seconds that have elapsed for an entry.\nbool Steam::updateCurrentEntryElapsedSeconds(int seconds) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateCurrentEntryElapsedSeconds\");\n\treturn SteamMusicRemote()->UpdateCurrentEntryElapsedSeconds(seconds);\n}\n\n// Update the current song entry's text?\nbool Steam::updateCurrentEntryText(const String &text) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateCurrentEntryText\");\n\treturn SteamMusicRemote()->UpdateCurrentEntryText(text.utf8().get_data());\n}\n\n// Update looped or not.\nbool Steam::updateLooped(bool looped) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateLooped\");\n\treturn SteamMusicRemote()->UpdateLooped(looped);\n}\n\n// Update the current playback status; 0 - undefined, 1 - playing, 2 - paused, 3 - idle.\nbool Steam::updatePlaybackStatus(AudioPlaybackStatus status) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updatePlaybackStatus\");\n\treturn SteamMusicRemote()->UpdatePlaybackStatus((AudioPlayback_Status)status);\n}\n\n// Update whether to shuffle or not.\nbool Steam::updateShuffled(bool shuffle) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateShuffled\");\n\treturn SteamMusicRemote()->UpdateShuffled(shuffle);\n}\n\n// Volume is between 0.0 and 1.0.\nbool Steam::updateVolume(float volume) {\n\tERR_FAIL_COND_V_MSG(SteamMusicRemote() == NULL, false, \"[STEAM] Music Remote class not found when calling: updateVolume\");\n\treturn SteamMusicRemote()->UpdateVolume(volume);\n}\n\n\n///// NETWORKING\n\n// This allows the game to specify accept an incoming packet.\nbool Steam::acceptP2PSessionWithUser(uint64_t remote_steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, false, \"[STEAM] Game Server class not found when calling: acceptP2PSessionWithUser\");\n\tCSteamID steam_id = createSteamID(remote_steam_id);\n\treturn SteamNetworking()->AcceptP2PSessionWithUser(steam_id);\n}\n\n// Allow or disallow P2P connections to fall back to being relayed through the Steam servers if a direct connection or\n// NAT-traversal cannot be established.\nbool Steam::allowP2PPacketRelay(bool allow) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, false, \"[STEAM] Game Server class not found when calling: allowP2PPacketRelay\");\n\treturn SteamNetworking()->AllowP2PPacketRelay(allow);\n}\n\n// Closes a P2P channel when you're done talking to a user on the specific channel.\nbool Steam::closeP2PChannelWithUser(uint64_t remote_steam_id, int channel) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, false, \"[STEAM] Game Server class not found when calling: closeP2PChannelWithUser\");\n\tCSteamID steam_id = createSteamID(remote_steam_id);\n\treturn SteamNetworking()->CloseP2PChannelWithUser(steam_id, channel);\n}\n\n// This should be called when you're done communicating with a user, as this will free up all of the resources allocated for the\n// connection under-the-hood.\nbool Steam::closeP2PSessionWithUser(uint64_t remote_steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, false, \"[STEAM] Game Server class not found when calling: closeP2PSessionWithUser\");\n\tCSteamID steam_id = createSteamID(remote_steam_id);\n\treturn SteamNetworking()->CloseP2PSessionWithUser(steam_id);\n}\n\n// Fills out a P2PSessionState_t structure with details about the connection like whether or not there is an active connection.\nDictionary Steam::getP2PSessionState(uint64_t remote_steam_id) {\n\tDictionary result;\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, result, \"[STEAM] Game Server class not found when calling: getP2PSessionState\");\n\tCSteamID steam_id = createSteamID(remote_steam_id);\n\tP2PSessionState_t p2pSessionState;\n\tif (SteamNetworking()->GetP2PSessionState(steam_id, &p2pSessionState)) {\n\t\tresult[\"connection_active\"] = p2pSessionState.m_bConnectionActive; // true if we've got an active open connection\n\t\tresult[\"connecting\"] = p2pSessionState.m_bConnecting; // true if we're currently trying to establish a connection\n\t\tresult[\"session_error\"] = p2pSessionState.m_eP2PSessionError; // last error recorded (see enum in isteamnetworking.h)\n\t\tresult[\"using_relay\"] = p2pSessionState.m_bUsingRelay; // true if it's going through a relay server (TURN)\n\t\tresult[\"bytes_queued_for_send\"] = p2pSessionState.m_nBytesQueuedForSend;\n\t\tresult[\"packets_queued_for_send\"] = p2pSessionState.m_nPacketsQueuedForSend;\n\t\tresult[\"remote_ip\"] = p2pSessionState.m_nRemoteIP; // potential IP:Port of remote host. Could be TURN server.\n\t\tresult[\"remote_port\"] = p2pSessionState.m_nRemotePort; // Only exists for compatibility with older authentication api's\n\t}\n\treturn result;\n}\n\n// Calls IsP2PPacketAvailable() under the hood, returns the size of the available packet or zero if there is no such packet.\nuint32_t Steam::getAvailableP2PPacketSize(int channel) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, 0, \"[STEAM] Game Server class not found when calling: getAvailableP2PPacketSize\");\n\tuint32_t message_size = 0;\n\treturn (SteamNetworking()->IsP2PPacketAvailable(&message_size, channel)) ? message_size : 0;\n}\n\n// Reads in a packet that has been sent from another user via SendP2PPacket.\nDictionary Steam::readP2PPacket(uint32_t packet, int channel) {\n\tDictionary result;\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, result, \"[STEAM] Game Server class not found when calling: readP2PPacket\");\n\tPackedByteArray data;\n\tdata.resize(packet);\n\tCSteamID steam_id;\n\tuint32_t bytes_read = 0;\n\n\tif (SteamNetworking()->ReadP2PPacket(data.ptrw(), packet, &bytes_read, &steam_id, channel)) {\n\t\tdata.resize(bytes_read);\n\t\tuint64_t remote_steam_id = steam_id.ConvertToUint64();\n\t\tresult[\"data\"] = data;\n\t\tresult[\"remote_steam_id\"] = remote_steam_id;\n\t}\n\telse {\n\t\tdata.resize(0);\n\t}\n\treturn result;\n}\n\n// Sends a P2P packet to the specified user.\nbool Steam::sendP2PPacket(uint64_t remote_steam_id, PackedByteArray data, P2PSend send_type, int channel) {\n\tERR_FAIL_COND_V_MSG(SteamNetworking() == NULL, false, \"[STEAM] Game Server class not found when calling: sendP2PPacket\");\n\tCSteamID steam_id = createSteamID(remote_steam_id);\n\treturn SteamNetworking()->SendP2PPacket(steam_id, data.ptr(), data.size(), EP2PSend(send_type), channel);\n}\n\n\n///// NETWORKING MESSAGES\n\n// AcceptSessionWithUser() should only be called in response to a SteamP2PSessionRequest_t callback SteamP2PSessionRequest_t \n// will be posted if another user tries to send you a message, and you haven't tried to talk to them.\nbool Steam::acceptSessionWithUser(uint64_t remote_steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] Networking Messages class not found when calling: acceptSessionWithUser\");\n\treturn SteamNetworkingMessages()->AcceptSessionWithUser(getIdentityFromSteamID(remote_steam_id));\n}\n\n// Call this  when you're done talking to a user on a specific channel. Once all open channels to a user have been closed,\n// the open session to the user will be closed, and any new data from this user will trigger a SteamP2PSessionRequest_t callback.\nbool Steam::closeChannelWithUser(uint64_t remote_steam_id, int channel) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] Networking Messages class not found when calling: closeChannelWithUser\");\n\treturn SteamNetworkingMessages()->CloseChannelWithUser(getIdentityFromSteamID(remote_steam_id), channel);\n}\n\n// Call this when you're done talking to a user to immediately free up resources under-the-hood.\nbool Steam::closeSessionWithUser(uint64_t remote_steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] Networking Messages class not found when calling: closeSessionWithUser\");\n\treturn SteamNetworkingMessages()->CloseSessionWithUser(getIdentityFromSteamID(remote_steam_id));\n}\n\n// Returns information about the latest state of a connection, if any, with the given peer.\nDictionary Steam::getSessionConnectionInfo(uint64_t remote_steam_id, bool get_connection, bool get_status) {\n\tDictionary connection_info;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, connection_info, \"[STEAM] Networking Messages class not found when calling: getSessionConnectionInfo\");\n\tSteamNetConnectionInfo_t this_info;\n\tSteamNetConnectionRealTimeStatus_t this_status;\n\tint connection_state = SteamNetworkingMessages()->GetSessionConnectionInfo(getIdentityFromSteamID(remote_steam_id), &this_info, &this_status);\n\t// Parse the data to a dictionary\n\tconnection_info[\"connection_state\"] = connection_state;\n\n\t// If getting the connection information\n\tif (get_connection) {\n\t\tconnection_info[\"identity\"] = getSteamIDFromIdentity(this_info.m_identityRemote);\n\t\tconnection_info[\"user_data\"] = (uint64_t)this_info.m_nUserData;\n\t\tconnection_info[\"listen_socket\"] = this_info.m_hListenSocket;\n\t\tconnection_info[\"remote_address\"] = getStringFromSteamIP(this_info.m_addrRemote);\n\t\tconnection_info[\"remote_pop\"] = this_info.m_idPOPRemote;\n\t\tconnection_info[\"pop_relay\"] = this_info.m_idPOPRelay;\n\t\tconnection_info[\"connection_state\"] = this_info.m_eState;\n\t\tconnection_info[\"end_reason\"] = this_info.m_eEndReason;\n\t\tconnection_info[\"end_debug\"] = this_info.m_szEndDebug;\n\t\tconnection_info[\"debug_description\"] = this_info.m_szConnectionDescription;\n\t\tconnection_info[\"info_flags\"] = this_info.m_nFlags;\n\t}\n\n\t// If getting the quick status\n\tif (get_status) {\n\t\tconnection_info[\"state\"] = this_status.m_eState;\n\t\tconnection_info[\"ping\"] = this_status.m_nPing;\n\t\tconnection_info[\"local_quality\"] = this_status.m_flConnectionQualityLocal;\n\t\tconnection_info[\"remote_quality\"] = this_status.m_flConnectionQualityRemote;\n\t\tconnection_info[\"packets_out_per_second\"] = this_status.m_flOutPacketsPerSec;\n\t\tconnection_info[\"bytes_out_per_second\"] = this_status.m_flOutBytesPerSec;\n\t\tconnection_info[\"packets_in_per_second\"] = this_status.m_flInPacketsPerSec;\n\t\tconnection_info[\"bytes_in_per_second\"] = this_status.m_flInBytesPerSec;\n\t\tconnection_info[\"send_rate\"] = this_status.m_nSendRateBytesPerSecond;\n\t\tconnection_info[\"pending_unreliable\"] = this_status.m_cbPendingUnreliable;\n\t\tconnection_info[\"pending_reliable\"] = this_status.m_cbPendingReliable;\n\t\tconnection_info[\"sent_unacknowledged_reliable\"] = this_status.m_cbSentUnackedReliable;\n\t\tconnection_info[\"queue_time\"] = (uint64_t)this_status.m_usecQueueTime;\n\t}\n\treturn connection_info;\n}\n\n// Reads the next message that has been sent from another user via SendMessageToUser() on the given channel. Returns number of\n// messages returned into your list.  (0 if no message are available on that channel.)\nArray Steam::receiveMessagesOnChannel(int channel, int max_messages) {\n\tArray messages;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, messages, \"[STEAM] Networking Messages class not found when calling: receiveMessagesOnChannel\");\n\t// Allocate the space for the messages\n\tSteamNetworkingMessage_t **channel_messages = new SteamNetworkingMessage_t *[max_messages];\n\t// Get the messages\n\tint available_messages = SteamNetworkingMessages()->ReceiveMessagesOnChannel(channel, channel_messages, max_messages);\n\n\t// Loop through and create the messages as dictionaries then add to the messages array\n\tfor (int i = 0; i < available_messages; i++) {\n\t\t// Set up the mesage dictionary\n\t\tDictionary message;\n\t\t// Get the data / message\n\t\tint message_size = channel_messages[i]->m_cbSize;\n\t\tPackedByteArray data;\n\t\tdata.resize(message_size);\n\t\tuint8_t *source_data = (uint8_t *)channel_messages[i]->m_pData;\n\t\tuint8_t *output_data = data.ptrw();\n\t\tfor (int j = 0; j < message_size; j++) {\n\t\t\toutput_data[j] = source_data[j];\n\t\t}\n\t\tmessage[\"payload\"] = data;\n\t\tmessage[\"size\"] = message_size;\n\t\tmessage[\"connection\"] = channel_messages[i]->m_conn;\n\t\tmessage[\"identity\"] = getSteamIDFromIdentity(channel_messages[i]->m_identityPeer);\n\t\tmessage[\"receiver_user_data\"] = (uint64_t)channel_messages[i]->m_nConnUserData; // Not used when sending messages\n\t\tmessage[\"time_received\"] = (uint64_t)channel_messages[i]->m_usecTimeReceived;\n\t\tmessage[\"message_number\"] = (uint64_t)channel_messages[i]->m_nMessageNumber;\n\t\tmessage[\"channel\"] = channel_messages[i]->m_nChannel;\n\t\tmessage[\"flags\"] = channel_messages[i]->m_nFlags;\n\t\tmessage[\"sender_user_data\"] = (uint64_t)channel_messages[i]->m_nUserData; // Not used when receiving messages\n\t\tmessages.append(message);\n\t\t// Release the message\n\t\tchannel_messages[i]->Release();\n\t}\n\tdelete[] channel_messages;\n\treturn messages;\n}\n\n// Sends a message to the specified host. If we don't already have a session with that user, a session is implicitly created.\n// There might be some handshaking that needs to happen before we can actually begin sending message data.\nint Steam::sendMessageToUser(uint64_t remote_steam_id, const PackedByteArray data, int flags, int channel) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] Networking Messages class not found when calling: sendMessageToUser\");\n\treturn SteamNetworkingMessages()->SendMessageToUser(getIdentityFromSteamID(remote_steam_id), data.ptr(), data.size(), flags, channel);\n}\n\n\n///// NETWORKING SOCKETS\n\n// Creates a \"server\" socket that listens for clients to connect to by calling ConnectByIPAddress, over ordinary UDP (IPv4 or IPv6)\nuint32 Steam::createListenSocketIP(String ip_address, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: createListenSocketIP\");\n\tuint32 listen_socket = SteamNetworkingSockets()->CreateListenSocketIP(getSteamIPFromString(ip_address), config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// Like CreateListenSocketIP, but clients will connect using ConnectP2P. The connection will be relayed through the Valve network.\nuint32 Steam::createListenSocketP2P(int virtual_port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: createListenSocketP2P\");\n\tuint32 listen_socket = SteamNetworkingSockets()->CreateListenSocketP2P(virtual_port, config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// Begin connecting to a server that is identified using a platform-specific identifier. This uses the default rendezvous service,\n// which depends on the platform and library configuration. (E.g. on Steam, it goes through the steam backend.) The traffic is\n// relayed over the Steam Datagram Relay network.\nuint32 Steam::connectP2P(uint64_t remote_steam_id, int virtual_port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: connectP2P\");\n\tuint32 listen_socket = SteamNetworkingSockets()->ConnectP2P(getIdentityFromSteamID(remote_steam_id), virtual_port, config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// Begin connecting to a server listen socket that is identified using an [ip-address]:[port], i.e. 127.0.0.1:27015. Used with\n// createListenSocketIP\nuint32 Steam::connectByIPAddress(String ip_address_with_port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: connectByIPAddress\");\n\treturn SteamNetworkingSockets()->ConnectByIPAddress(getSteamIPFromString(ip_address_with_port), config_options.size(), convert_config_options(config_options));\n}\n\n// Client call to connect to a server hosted in a Valve data center, on the specified virtual port. You must have placed a ticket\n// for this server into the cache, or else this connect attempt will fail!\nuint32 Steam::connectToHostedDedicatedServer(uint64_t remote_steam_id, int virtual_port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: connectToHostedDedicatedServer\");\n\tuint32 listen_socket = SteamNetworkingSockets()->ConnectToHostedDedicatedServer(getIdentityFromSteamID(remote_steam_id), virtual_port, config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// Accept an incoming connection that has been received on a listen socket.\nint Steam::acceptConnection(uint32 connection_handle) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: acceptConnection\");\n\treturn SteamNetworkingSockets()->AcceptConnection((HSteamNetConnection)connection_handle);\n}\n\n// Disconnects from the remote host and invalidates the connection handle. Any unread data on the connection is discarded.\nbool Steam::closeConnection(uint32 peer, int reason, const String &debug_message, bool linger) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, false, \"[STEAM] Networking Sockets class not found when calling: closeConnection\");\n\treturn SteamNetworkingSockets()->CloseConnection((HSteamNetConnection)peer, reason, debug_message.utf8().get_data(), linger);\n}\n\n// Destroy a listen socket. All the connections that were accepted on the listen socket are closed ungracefully.\nbool Steam::closeListenSocket(uint32 socket) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, false, \"[STEAM] Networking Sockets class not found when calling: closeListenSocket\");\n\treturn SteamNetworkingSockets()->CloseListenSocket((HSteamListenSocket)socket);\n}\n\n// Create a pair of connections that are talking to each other, e.g. a loopback connection. This is very useful for testing, or so\n// that your client/server code can work the same even when you are running a local \"server\".\nDictionary Steam::createSocketPair(bool loopback, uint64_t remote_steam_id1, uint64_t remote_steam_id2) {\n\tDictionary connection_pair;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, connection_pair, \"[STEAM] Networking Sockets class not found when calling: createSocketPair\");\n\tuint32 connection1 = 0;\n\tuint32 connection2 = 0;\n\tSteamNetworkingIdentity remote_identity1 = getIdentityFromSteamID(remote_steam_id1);\n\tSteamNetworkingIdentity remote_identity2 = getIdentityFromSteamID(remote_steam_id2);\n\tbool success = SteamNetworkingSockets()->CreateSocketPair(&connection1, &connection2, loopback, &remote_identity1, &remote_identity2);\n\t// Populate the dictionary\n\tconnection_pair[\"success\"] = success;\n\tconnection_pair[\"connection1\"] = connection1;\n\tconnection_pair[\"connection2\"] = connection2;\n\treturn connection_pair;\n}\n\n// Send a message to the remote host on the specified connection.\nDictionary Steam::sendMessageToConnection(uint32 connection_handle, const PackedByteArray data, int flags) {\n\tDictionary message_response;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, message_response, \"[STEAM] Networking Sockets class not found when calling: sendMessageToConnection\");\n\tint64 number;\n\tint result = SteamNetworkingSockets()->SendMessageToConnection((HSteamNetConnection)connection_handle, data.ptr(), data.size(), flags, &number);\n\t// Populate the dictionary\n\tmessage_response[\"result\"] = result;\n\tmessage_response[\"message_number\"] = (uint64_t)number;\n\treturn message_response;\n}\n\n// Send one or more messages without copying the message payload. This is the most efficient way to send messages. To use this\n// function, you must first allocate a message object using ISteamNetworkingUtils::AllocateMessage. (Do not declare one on the\n// stack or allocate your own.)\n// Current does not compile on Windows but does on Linux\n// Array Steam::sendMessages(Array messages, uint32 connection_handle, int flags) {\n// \tArray result;\n// \tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, result, \"[STEAM SERVER] Networking Sockets class not found when calling: sendMessages\");\n\n// \tint total_messages = messages.size();\n// \tSteamNetworkingMessage_t *messages_payload[total_messages];\n\n// \tfor(int m = 0; m < total_messages; m++) {\n// \t\tSteamNetworkingMessage_t *network_message = SteamNetworkingUtils()->AllocateMessage(sizeof(messages[m]));\n// \t\tnetwork_message->m_pData = messages[m];\n// \t\tnetwork_message->m_conn = (HSteamNetConnection)connection_handle;\n// \t\tnetwork_message->m_nFlags = flags;\n\n// \t\tmessages_payload[m] = network_message;\n// \t\t// Can or should we release this here?\n// \t\tnetwork_message->Release();\n// \t}\n\n// \tint64 *message_num_or_result = new int64[messages.size()];\n// \tSteamNetworkingSockets()->SendMessages(total_messages, messages_payload, message_num_or_result);\n\n// \tfor (int i = 0; i < messages.size(); i++ ) {\n// \t\tresult.append( (int)message_num_or_result[i] );\n// \t}\n\n// \tdelete[] message_num_or_result;\n// \treturn result;\n// }\n\n// Flush any messages waiting on the Nagle timer and send them at the next transmission opportunity (often that means right now).\nint Steam::flushMessagesOnConnection(uint32 connection_handle) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: flushMessagesOnConnection\");\n\treturn SteamNetworkingSockets()->FlushMessagesOnConnection((HSteamNetConnection)connection_handle);\n}\n\n// Fetch the next available message(s) from the connection, if any. Returns the number of messages returned into your array, up\n// to nMaxMessages. If the connection handle is invalid, -1 is returned. If no data is available, 0, is returned.\nArray Steam::receiveMessagesOnConnection(uint32 connection_handle, int max_messages) {\n\tArray messages;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, messages, \"[STEAM] Networking Sockets class not found when calling: receiveMessagesOnConnection\");\n\tSteamNetworkingMessage_t **connection_messages = new SteamNetworkingMessage_t *[max_messages];\n\tint available_messages = SteamNetworkingSockets()->ReceiveMessagesOnConnection((HSteamNetConnection)connection_handle, connection_messages, max_messages);\n\n\tfor (int i = 0; i < available_messages; i++) {\n\t\tDictionary message;\n\t\tint message_size = connection_messages[i]->m_cbSize;\n\t\tPackedByteArray data;\n\t\tdata.resize(message_size);\n\t\tuint8_t *source_data = (uint8_t *)connection_messages[i]->m_pData;\n\t\tuint8_t *output_data = data.ptrw();\n\n\t\tfor (int j = 0; j < message_size; j++) {\n\t\t\toutput_data[j] = source_data[j];\n\t\t}\n\t\tmessage[\"payload\"] = data;\n\t\tmessage[\"size\"] = message_size;\n\t\tmessage[\"connection\"] = connection_messages[i]->m_conn;\n\t\tmessage[\"identity\"] = getSteamIDFromIdentity(connection_messages[i]->m_identityPeer);\n\t\tmessage[\"receiver_user_data\"] = (uint64_t)connection_messages[i]->m_nConnUserData; // Not used when sending messages\n\t\tmessage[\"time_received\"] = (uint64_t)connection_messages[i]->m_usecTimeReceived;\n\t\tmessage[\"message_number\"] = (uint64_t)connection_messages[i]->m_nMessageNumber;\n\t\tmessage[\"channel\"] = connection_messages[i]->m_nChannel;\n\t\tmessage[\"flags\"] = connection_messages[i]->m_nFlags;\n\t\tmessage[\"sender_user_data\"] = (uint64_t)connection_messages[i]->m_nUserData; // Not used when receiving messages\n\t\tmessages.append(message);\n\t\t// Release the message\n\t\tconnection_messages[i]->Release();\n\t}\n\tdelete[] connection_messages;\n\treturn messages;\n}\n\n// Create a new poll group.\nuint32 Steam::createPollGroup() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: createPollGroup\");\n\treturn SteamNetworkingSockets()->CreatePollGroup();\n}\n\n// Destroy a poll group created with CreatePollGroup.\nbool Steam::destroyPollGroup(uint32 poll_group) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, false, \"[STEAM] Networking Sockets class not found when calling: destroyPollGroup\");\n\treturn SteamNetworkingSockets()->DestroyPollGroup((HSteamNetPollGroup)poll_group);\n}\n\n// Assign a connection to a poll group. Note that a connection may only belong to a single poll group. Adding a connection to a\n// poll group implicitly removes it from any other poll group it is in.\nbool Steam::setConnectionPollGroup(uint32 connection_handle, uint32 poll_group) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, false, \"[STEAM] Networking Sockets class not found when calling: setConnectionPollGroup\");\n\treturn SteamNetworkingSockets()->SetConnectionPollGroup((HSteamNetConnection)connection_handle, (HSteamNetPollGroup)poll_group);\n}\n\n// Same as ReceiveMessagesOnConnection, but will return the next messages available on any connection in the poll group. Examine\n// SteamNetworkingMessage_t::m_conn to know which connection. (SteamNetworkingMessage_t::m_nConnUserData might also be useful.)\nArray Steam::receiveMessagesOnPollGroup(uint32 poll_group, int max_messages) {\n\tArray messages;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, messages, \"[STEAM] Networking Sockets class not found when calling: receiveMessagesOnPollGroup\");\n\tSteamNetworkingMessage_t** poll_messages = new SteamNetworkingMessage_t *[max_messages];\n\tint available_messages = SteamNetworkingSockets()->ReceiveMessagesOnPollGroup((HSteamNetPollGroup)poll_group, poll_messages, max_messages);\n\t\t\n\tfor(int i = 0; i < available_messages; i++) {\n\t\tDictionary message;\n\n\t\tint message_size = poll_messages[i]->m_cbSize;\n\t\tPackedByteArray data;\n\t\tdata.resize(message_size);\n\t\tuint8_t* source_data = (uint8_t*)poll_messages[i]->m_pData;\n\t\tuint8_t* output_data = data.ptrw();\n\t\tfor(int j = 0; j < message_size; j++) {\n\t\t\toutput_data[j] = source_data[j];\n\t\t}\n\n\t\tmessage[\"payload\"] = data;\n\t\tmessage[\"size\"] = message_size;\n\t\tmessage[\"connection\"] = poll_messages[i]->m_conn;\n\t\tmessage[\"identity\"] = getSteamIDFromIdentity(poll_messages[i]->m_identityPeer);\n\t\tmessage[\"receiver_user_data\"] = (uint64_t)poll_messages[i]->m_nConnUserData;\n\t\tmessage[\"time_received\"] = (uint64_t)poll_messages[i]->m_usecTimeReceived;\n\t\tmessage[\"message_number\"] = (uint64_t)poll_messages[i]->m_nMessageNumber;\n\t\tmessage[\"channel\"] = poll_messages[i]->m_nChannel;\n\t\tmessage[\"flags\"] = poll_messages[i]->m_nFlags;\n\t\tmessage[\"sender_user_data\"] = (uint64_t)poll_messages[i]->m_nUserData;\n\t\tmessages.append(message);\n\n\t\tpoll_messages[i]->Release();\n\t}\n\tdelete [] poll_messages;\n\treturn messages;\n}\n\n// Returns basic information about the high-level state of the connection. Returns false if the connection handle is invalid.\nDictionary Steam::getConnectionInfo(uint32 connection_handle) {\n\tDictionary connection_info;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, connection_info, \"[STEAM] Networking Sockets class not found when calling: getConnectionInfo\");\n\tSteamNetConnectionInfo_t info;\n\tif (SteamNetworkingSockets()->GetConnectionInfo((HSteamNetConnection)connection_handle, &info)) {\n\t\tconnection_info[\"identity\"] = getSteamIDFromIdentity(info.m_identityRemote);\n\t\tconnection_info[\"user_data\"] = (uint64_t)info.m_nUserData;\n\t\tconnection_info[\"listen_socket\"] = info.m_hListenSocket;\n\t\tconnection_info[\"remote_address\"] = getStringFromSteamIP(info.m_addrRemote);\n\t\tconnection_info[\"remote_pop\"] = info.m_idPOPRemote;\n\t\tconnection_info[\"pop_relay\"] = info.m_idPOPRelay;\n\t\tconnection_info[\"connection_state\"] = info.m_eState;\n\t\tconnection_info[\"end_reason\"] = info.m_eEndReason;\n\t\tconnection_info[\"end_debug\"] = info.m_szEndDebug;\n\t\tconnection_info[\"debug_description\"] = info.m_szConnectionDescription;\n\t\tconnection_info[\"info_flags\"] = info.m_nFlags;\n\t}\n\treturn connection_info;\n}\n\n// Returns very detailed connection stats in diagnostic text format. Useful for dumping to a log, etc. The format of this\n// information is subject to change.\nDictionary Steam::getDetailedConnectionStatus(uint32 connection) {\n\tDictionary connection_status;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, connection_status, \"[STEAM] Networking Sockets class not found when calling: getDetailedConnectionStatus\");\n\tchar buffer[STEAM_LARGE_BUFFER_SIZE];\n\tint success = SteamNetworkingSockets()->GetDetailedConnectionStatus((HSteamNetConnection)connection, buffer, STEAM_LARGE_BUFFER_SIZE);\n\n\tconnection_status[\"success\"] = success;\n\tconnection_status[\"status\"] = buffer;\n\treturn connection_status; \n}\n\n// Fetch connection user data. Returns -1 if handle is invalid or if you haven't set any userdata on the connection.\nuint64_t Steam::getConnectionUserData(uint32 peer) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: getConnectionUserData\");\n\treturn SteamNetworkingSockets()->GetConnectionUserData((HSteamNetConnection)peer);\n}\n\n// Set a name for the connection, used mostly for debugging\nvoid Steam::setConnectionName(uint32 peer, const String &name) {\n\tERR_FAIL_COND_MSG(SteamNetworkingSockets() == NULL, \"[STEAM] Networking Sockets class not found when calling: setConnectionName\");\n\tSteamNetworkingSockets()->SetConnectionName((HSteamNetConnection)peer, name.utf8().get_data());\n}\n\n// Fetch connection name into your buffer, which is at least nMaxLen bytes. Returns false if handle is invalid.\nString Steam::getConnectionName(uint32 peer) {\n\tString connection_name = \"\";\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, connection_name, \"[STEAM] Networking Sockets class not found when calling: getConnectionName\");\n\tchar name[STEAM_BUFFER_SIZE];\n\tif (SteamNetworkingSockets()->GetConnectionName((HSteamNetConnection)peer, name, STEAM_BUFFER_SIZE)) {\n\t\tconnection_name += name;\n\t}\n\treturn connection_name;\n}\n\n// Returns local IP and port that a listen socket created using CreateListenSocketIP is bound to.\nString Steam::getListenSocketAddress(uint32 socket, bool with_port) {\n\tString socket_address = \"\";\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, socket_address, \"[STEAM] Networking Sockets class not found when calling: getListenSocketAddress\");\n\tSteamNetworkingIPAddr address;\n\tif (SteamNetworkingSockets()->GetListenSocketAddress((HSteamListenSocket)socket, &address)) {\n\t\tsocket_address = getStringFromSteamIP(address);\n\t}\n\treturn socket_address;\n}\n\n// Indicate our desire to be ready participate in authenticated communications. If we are currently not ready, then steps will be\n// taken to obtain the necessary certificates. (This includes a certificate for us, as well as any CA certificates needed to\n// authenticate peers.)\nNetworkingAvailability Steam::initAuthentication() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, NETWORKING_AVAILABILITY_UNKNOWN, \"[STEAM] Networking Sockets class not found when calling: initAuthentication\");\n\treturn NetworkingAvailability(SteamNetworkingSockets()->InitAuthentication());\n}\n\n// Query our readiness to participate in authenticated communications. A SteamNetAuthenticationStatus_t callback is posted any\n// time this status changes, but you can use this function to query it at any time.\nNetworkingAvailability Steam::getAuthenticationStatus() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, NETWORKING_AVAILABILITY_UNKNOWN, \"[STEAM] Networking Sockets class not found when calling: getAuthenticationStatus\");\n\treturn NetworkingAvailability(SteamNetworkingSockets()->GetAuthenticationStatus(NULL));\n}\n\n// Call this when you receive a ticket from your backend / matchmaking system. Puts the ticket into a persistent cache, and\n// optionally returns the parsed ticket.\n// Dictionary Steam::receivedRelayAuthTicket() {\n// \tDictionary ticket;\n// \tif (SteamNetworkingSockets() != NULL) {\n// \t\tSteamDatagramRelayAuthTicket parsed_ticket;\n// \t\tPackedByteArray incoming_ticket;\n// \t\tincoming_ticket.resize(512);\n// \t\tif (SteamNetworkingSockets()->ReceivedRelayAuthTicket(incoming_ticket.ptrw(), 512, &parsed_ticket)) {\n// \t\t\tticket[\"game_server\"] = getSteamIDFromIdentity(parsed_ticket.m_identityGameserver);\n// \t\t\tticket[\"authorized_client\"] = getSteamIDFromIdentity(parsed_ticket.m_identityAuthorizedClient);\n// \t\t\tticket[\"public_ip\"] = getStringFromIP(parsed_ticket.m_unPublicIP);\t\t// uint32\n// \t\t\tticket[\"expiry\"] = parsed_ticket.m_rtimeTicketExpiry;\t// RTime32\n// \t\t\tticket[\"routing\"] = parsed_ticket.m_routing.GetPopID();\t\t\t// SteamDatagramHostAddress\n// \t\t\tticket[\"app_id\"] = parsed_ticket.m_nAppID;\t\t\t\t// uint32\n// \t\t\tticket[\"restrict_to_v_port\"] = parsed_ticket.m_nRestrictToVirtualPort;\t// int\n// \t\t\tticket[\"number_of_extras\"] = parsed_ticket.m_nExtraFields;\t\t// int\n// \t\t\tticket[\"extra_fields\"] = parsed_ticket.m_vecExtraFields;\t\t// ExtraField\n// \t\t}\n// \t}\n// \treturn ticket;\n// }\n\n// Search cache for a ticket to talk to the server on the specified virtual port. If found, returns the number of seconds until\n// the ticket expires, and optionally the complete cracked ticket. Returns 0 if we don't have a ticket.\n//int Steam::findRelayAuthTicketForServer(int port) {\n//\tint expires_in_seconds = 0;\n//\tif (SteamNetworkingSockets() != NULL) {\n//\t\texpires_in_seconds = SteamNetworkingSockets()->FindRelayAuthTicketForServer(game_server, port, &relay_auth_ticket);\n//\t}\n//\treturn expires_in_seconds;\n//}\n\n// Returns the value of the SDR_LISTEN_PORT environment variable. This is the UDP server your server will be listening on. This\n// will configured automatically for you in production environments.\nuint16 Steam::getHostedDedicatedServerPort() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: getHostedDedicatedServerPort\");\n\treturn SteamNetworkingSockets()->GetHostedDedicatedServerPort();\n}\n\n// Returns 0 if SDR_LISTEN_PORT is not set. Otherwise, returns the data center the server is running in. This will be\n// k_SteamDatagramPOPID_dev in non-production environment.\nuint32 Steam::getHostedDedicatedServerPOPId() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: getHostedDedicatedServerPOPId\");\n\treturn SteamNetworkingSockets()->GetHostedDedicatedServerPOPID();\n}\n\n// Return info about the hosted server. This contains the PoPID of the server, and opaque routing information that can be used by\n// the relays to send traffic to your server.\n//int Steam::getHostedDedicatedServerAddress() {\n//\tint result = 2;\n//\tif (SteamNetworkingSockets() != NULL) {\n//\t\tresult = SteamNetworkingSockets()->GetHostedDedicatedServerAddress(&hosted_address);\n//\t}\n//\treturn result;\n//}\n\n// Create a listen socket on the specified virtual port. The physical UDP port to use will be determined by the SDR_LISTEN_PORT\n// environment variable. If a UDP port is not configured, this call will fail.\nuint32 Steam::createHostedDedicatedServerListenSocket(int port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: createHostedDedicatedServerListenSocket\");\n\tuint32 listen_socket = SteamGameServerNetworkingSockets()->CreateHostedDedicatedServerListenSocket(port, config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// Generate an authentication blob that can be used to securely login with your backend, using SteamDatagram_ParseHostedServerLogin.\n// (See steamdatagram_gamecoordinator.h)\n//int Steam::getGameCoordinatorServerLogin(const String& app_data) {\n//\tint result = 2;\n//\tif (SteamNetworkingSockets() != NULL) {\n//\t\tSteamDatagramGameCoordinatorServerLogin *server_login = new SteamDatagramGameCoordinatorServerLogin;\n//\t\tserver_login->m_cbAppData = app_data.size();\n//\t\tstrcpy(server_login->m_appData, app_data.utf8().get_data());\n//\t\tint signed_blob = k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized;\n//\t\trouting_blob.resize(signed_blob);\n//\t\tresult = SteamNetworkingSockets()->GetGameCoordinatorServerLogin(server_login, &signed_blob, routing_blob.ptrw());\n//\t\tdelete server_login;\n//\t}\n//\treturn result;\n//}\n\n// Returns a small set of information about the real-time state of the connection and the queue status of each lane.\nDictionary Steam::getConnectionRealTimeStatus(uint32 connection, int lanes, bool get_status) {\n\t// Create the dictionary for returning\n\tDictionary real_time_status;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, real_time_status, \"[STEAM] Networking Sockets class not found when calling: getConnectionRealTimeStatus\");\n\tSteamNetConnectionRealTimeStatus_t this_status;\n\tSteamNetConnectionRealTimeLaneStatus_t *lanes_array = new SteamNetConnectionRealTimeLaneStatus_t[lanes];\n\tint result = SteamNetworkingSockets()->GetConnectionRealTimeStatus((HSteamNetConnection)connection, &this_status, lanes, lanes_array);\n\t\n\treal_time_status[\"response\"] = result;\n\tif (result == RESULT_OK) {\n\n\t\tDictionary connection_status;\n\t\tif (get_status) {\n\t\t\tconnection_status[\"state\"] = this_status.m_eState;\n\t\t\tconnection_status[\"ping\"] = this_status.m_nPing;\n\t\t\tconnection_status[\"local_quality\"] = this_status.m_flConnectionQualityLocal;\n\t\t\tconnection_status[\"remote_quality\"] = this_status.m_flConnectionQualityRemote;\n\t\t\tconnection_status[\"packets_out_per_second\"] = this_status.m_flOutPacketsPerSec;\n\t\t\tconnection_status[\"bytes_out_per_second\"] = this_status.m_flOutBytesPerSec;\n\t\t\tconnection_status[\"packets_in_per_second\"] = this_status.m_flInPacketsPerSec;\n\t\t\tconnection_status[\"bytes_in_per_second\"] = this_status.m_flInBytesPerSec;\n\t\t\tconnection_status[\"send_rate\"] = this_status.m_nSendRateBytesPerSecond;\n\t\t\tconnection_status[\"pending_unreliable\"] = this_status.m_cbPendingUnreliable;\n\t\t\tconnection_status[\"pending_reliable\"] = this_status.m_cbPendingReliable;\n\t\t\tconnection_status[\"sent_unacknowledged_reliable\"] = this_status.m_cbSentUnackedReliable;\n\t\t\tconnection_status[\"queue_time\"] = (uint64_t)this_status.m_usecQueueTime;\n\t\t}\n\t\treal_time_status[\"connection_status\"] = connection_status;\n\n\t\tArray lanes_status;\n\t\tfor (int i = 0; i < lanes; i++) {\n\t\t\tDictionary lane_status;\n\t\t\tlane_status[\"pending_unreliable\"] = lanes_array[i].m_cbPendingUnreliable;\n\t\t\tlane_status[\"pending_reliable\"] = lanes_array[i].m_cbPendingReliable;\n\t\t\tlane_status[\"sent_unacknowledged_reliable\"] = lanes_array[i].m_cbSentUnackedReliable;\n\t\t\tlane_status[\"queue_time\"] = (uint64_t)lanes_array[i].m_usecQueueTime;\n\t\t\tlanes_status.append(lane_status);\n\t\t}\n\t\treal_time_status[\"lanes_status\"] = lanes_status;\n\t}\n\tdelete[] lanes_array;\n\treturn real_time_status;\n}\n\n// Configure multiple outbound messages streams (\"lanes\") on a connection, and control head-of-line blocking between them.\n// Messages within a given lane are always sent in the order they are queued, but messages from different lanes may be sent out of\n// order.\n// Each lane has its own message number sequence.  The first message sent on each lane will be assigned the number 1.\nint Steam::configureConnectionLanes(uint32 connection, uint32 lanes, Array priorities, Array weights) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: configureConnectionLanes\");\n\tint *lane_priorities = new int[lanes];\n\tfor (uint32 i = 0; i < lanes; i++) {\n\t\tlane_priorities[i] = priorities[i];\n\t}\n\n\tuint16 *lane_weights = new uint16[lanes];\n\tfor (uint32 i = 0; i < lanes; i++) {\n\t\tlane_weights[i] = weights[i];\n\t}\n\tint result = SteamNetworkingSockets()->ConfigureConnectionLanes((HSteamNetConnection)connection, lanes, lane_priorities, lane_weights);\n\tdelete[] lane_priorities;\n\tdelete[] lane_weights;\n\treturn result;\n}\n\n// Certificate provision by the application. On Steam, we normally handle all this automatically and you will not need to use\n// these advanced functions.\nDictionary Steam::getCertificateRequest() {\n\tDictionary cert_information;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, cert_information, \"[STEAM] Networking Sockets class not found when calling: getCertificateRequest\");\n\tPackedByteArray certificate;\n\tcertificate.resize(512);\n\tint cert_size = certificate.size();\n\tSteamNetworkingErrMsg error_message;\n\tif (SteamNetworkingSockets()->GetCertificateRequest(&cert_size, certificate.ptrw(), error_message)) {\n\t\tcertificate.resize(cert_size);\n\t\tcert_information[\"certificate\"] = certificate;\n\t\tcert_information[\"error_message\"] = error_message;\n\t}\n\treturn cert_information;\n}\n\n// Set the certificate. The certificate blob should be the output of SteamDatagram_CreateCert.\nDictionary Steam::setCertificate(const PackedByteArray &certificate) {\n\tDictionary certificate_data;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, certificate_data, \"[STEAM] Networking Sockets class not found when calling: setCertificate\");\n\tbool success = false;\n\tSteamNetworkingErrMsg error_message;\n\n\tsuccess = SteamNetworkingSockets()->SetCertificate((void *)certificate.ptr(), certificate.size(), error_message);\n\tif (success) {\n\t\tcertificate_data[\"response\"] = success;\n\t\tcertificate_data[\"error\"] = error_message;\n\t}\n\treturn certificate_data;\n}\n\n// Reset the identity associated with this instance. Any open connections are closed.  Any previous certificates, etc are discarded.\n// You can pass a specific identity that you want to use, or you can pass NULL, in which case the identity will be invalid until\n// you set it using SetCertificate.\n// NOTE: This function is not actually supported on Steam!  It is included for use on other platforms where the active user can\n// sign out and a new user can sign in.\nvoid Steam::resetIdentity(uint64_t remote_steam_id) {\n\tERR_FAIL_COND_MSG(SteamNetworkingSockets() == NULL, \"[STEAM] Networking Sockets class not found when calling: resetIdentity\");\n\tSteamNetworkingIdentity resetting_identity = getIdentityFromSteamID(remote_steam_id);\n\tSteamNetworkingSockets()->ResetIdentity(&resetting_identity);\n}\n\n// Invoke all callback functions queued for this interface. See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc.\n// You don't need to call this if you are using Steam's callback dispatch mechanism (SteamAPI_RunCallbacks and\n// SteamGameserver_RunCallbacks).\nvoid Steam::runNetworkingCallbacks() {\n\tERR_FAIL_COND_MSG(SteamNetworkingSockets() == NULL, \"[STEAM] Networking Sockets class not found when calling: runNetworkingCallbacks\");\n\tSteamNetworkingSockets()->RunCallbacks();\n}\n\n// Begin asynchronous process of allocating a fake IPv4 address that other peers can use to contact us via P2P.\n// IP addresses returned by this function are globally unique for a given appid.\n// Returns false if a request was already in progress, true if a new request was started.\n// A SteamNetworkingFakeIPResult_t will be posted when the request completes.\nbool Steam::beginAsyncRequestFakeIP(int num_ports) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, false, \"[STEAM] Networking Sockets class not found when calling: beginAsyncRequestFakeIP\");\n\treturn SteamNetworkingSockets()->BeginAsyncRequestFakeIP(num_ports);\n}\n\n// Return info about the FakeIP and port(s) that we have been assigned, if any.\n// idxFirstPort is currently reserved and must be zero. Make sure and check SteamNetworkingFakeIPResult_t::m_eResult\nDictionary Steam::getFakeIP(int first_port) {\n\tDictionary fake_ip;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, fake_ip, \"[STEAM] Networking Sockets class not found when calling: getFakeIP\");\n\tSteamNetworkingFakeIPResult_t fake_ip_result;\n\tSteamNetworkingSockets()->GetFakeIP(first_port, &fake_ip_result);\n\t\n\tfake_ip[\"result\"] = fake_ip_result.m_eResult;\n\tfake_ip[\"identity_type\"] = fake_ip_result.m_identity.m_eType;\n\tfake_ip[\"ip\"] = getStringFromIP(fake_ip_result.m_unIP);\n\t\t\n\tPackedInt32Array ports;\n\tports.resize(SteamNetworkingFakeIPResult_t::k_nMaxReturnPorts);\n\tfor (size_t i = 0; i < SteamNetworkingFakeIPResult_t::k_nMaxReturnPorts; i++) {\n\t\tports.write[i] = fake_ip_result.m_unPorts[i];\n\t}\n\tfake_ip[\"ports\"] = ports;\n\treturn fake_ip;\n}\n\n// Create a listen socket that will listen for P2P connections sent to our FakeIP.\n// A peer can initiate connections to this listen socket by calling ConnectByIPAddress.\nuint32 Steam::createListenSocketP2PFakeIP(int fake_port, Dictionary config_options) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, 0, \"[STEAM] Networking Sockets class not found when calling: createListenSocketP2PFakeIP\");\n\tuint32 listen_socket = SteamNetworkingSockets()->CreateListenSocketP2PFakeIP(fake_port, config_options.size(), convert_config_options(config_options));\n\treturn listen_socket;\n}\n\n// If the connection was initiated using the \"FakeIP\" system, then we we can get an IP address for the remote host.  If the remote\n// host had a global FakeIP at the time the connection was established, this function will return that global IP.\n// Otherwise, a FakeIP that is unique locally will be allocated from the local FakeIP address space, and that will be returned.\nDictionary Steam::getRemoteFakeIPForConnection(uint32 connection) {\n\tDictionary this_fake_address;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingSockets() == NULL, this_fake_address, \"[STEAM] Networking Sockets class not found when calling: getRemoteFakeIPForConnection\");\n\tSteamNetworkingIPAddr fake_address;\n\tint result = SteamNetworkingSockets()->GetRemoteFakeIPForConnection((HSteamNetConnection)connection, &fake_address);\n\t\n\tthis_fake_address[\"result\"] = result;\n\tthis_fake_address[\"ip_address\"] = getStringFromSteamIP(fake_address);\n\tthis_fake_address[\"port\"] = fake_address.m_port;\n\tthis_fake_address[\"ip_type\"] = fake_address.GetFakeIPType();\n\treturn this_fake_address;\n}\n\n// Get an interface that can be used like a UDP port to send/receive datagrams to a FakeIP address.\n// This is intended to make it easy to port existing UDP-based code to take advantage of SDR.\n// To create a \"client\" port (e.g. the equivalent of an ephemeral UDP port) pass -1.\nvoid Steam::createFakeUDPPort(int fake_server_port_index) {\n\tERR_FAIL_COND_MSG(SteamNetworkingSockets() == NULL, \"[STEAM] Networking Sockets class not found when calling: createFakeUDPPort\");\n\tSteamNetworkingSockets()->CreateFakeUDPPort(fake_server_port_index);\n}\n\n\n///// NETWORKING UTILS\n\n// If you know that you are going to be using the relay network (for example, because you anticipate making P2P connections), call\n// this to initialize the relay network. If you do not call this, the initialization will be delayed until the first time you use\n// a feature that requires access to the relay network, which will delay that first access.\nvoid Steam::initRelayNetworkAccess() {\n\tERR_FAIL_COND_MSG(SteamNetworkingUtils() == NULL, \"[STEAM] Networking Utils class not found when calling: initRelayNetworkAccess\");\n\tSteamNetworkingUtils()->InitRelayNetworkAccess();\n}\n\n// Fetch current status of the relay network.  If you want more details, you can pass a non-NULL value.\nNetworkingAvailability Steam::getRelayNetworkStatus() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, NETWORKING_AVAILABILITY_UNKNOWN, \"[STEAM] Networking Utils class not found when calling: getRelayNetworkStatus\");\n\treturn NetworkingAvailability(SteamNetworkingUtils()->GetRelayNetworkStatus(NULL));\n}\n\n// Return location info for the current host. Returns the approximate age of the data, in seconds, or -1 if no data is available.\nDictionary Steam::getLocalPingLocation() {\nDictionary ping_location;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, ping_location, \"[STEAM] Networking Utils class not found when calling: getLocalPingLocation\");\n\tSteamNetworkPingLocation_t location;\n\tfloat age = SteamNetworkingUtils()->GetLocalPingLocation(location);\n\n\tPackedByteArray data;\n\tdata.resize(512);\n\tuint8_t* output_data = data.ptrw();\n\tfor(int j = 0; j < 512; j++) {\n\t\toutput_data[j] = location.m_data[j];\n\t}\n\tping_location[\"age\"] = age;\n\tping_location[\"location\"] = data;\n\treturn ping_location;\n}\n\n// Estimate the round-trip latency between two arbitrary locations, in milliseconds. This is a conservative estimate, based on\n// routing through the relay network. For most basic relayed connections, this ping time will be pretty accurate, since it will\n// be based on the route likely to be actually used.\nint Steam::estimatePingTimeBetweenTwoLocations(PackedByteArray location1, PackedByteArray location2) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, 0, \"[STEAM] Networking Utils class not found when calling: estimatePingTimeBetweenTwoLocations\");\n\tSteamNetworkPingLocation_t ping_location1;\n\tSteamNetworkPingLocation_t ping_location2;\n\tuint8_t *input_location_1 = (uint8 *)location1.ptr();\n\tfor (int j = 0; j < 512; j++) {\n\t\tping_location1.m_data[j] = input_location_1[j];\n\t}\n\n\tuint8_t *input_location_2 = (uint8 *)location2.ptr();\n\tfor (int j = 0; j < 512; j++) {\n\t\tping_location2.m_data[j] = (uint8)input_location_2[j];\n\t}\n\treturn SteamNetworkingUtils()->EstimatePingTimeBetweenTwoLocations(ping_location1, ping_location2);\n}\n\n// Same as EstimatePingTime, but assumes that one location is the local host. This is a bit faster, especially if you need to\n// calculate a bunch of these in a loop to find the fastest one.\nint Steam::estimatePingTimeFromLocalHost(PackedByteArray location) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, 0, \"[STEAM] Networking Utils class not found when calling: estimatePingTimeFromLocalHost\");\n\tSteamNetworkPingLocation_t ping_location;\n\tuint8_t *input_location = (uint8 *)location.ptr();\n\tfor (int j = 0; j < 512; j++) {\n\t\tping_location.m_data[j] = input_location[j];\n\t}\n\treturn SteamNetworkingUtils()->EstimatePingTimeFromLocalHost(ping_location);\n}\n\n// Convert a ping location into a text format suitable for sending over the wire. The format is a compact and human readable.\n// However, it is subject to change so please do not parse it yourself. Your buffer must be at least\n// k_cchMaxSteamNetworkingPingLocationString bytes.\nString Steam::convertPingLocationToString(PackedByteArray location) {\n\tString location_string = \"\";\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, location_string, \"[STEAM] Networking Utils class not found when calling: convertPingLocationToString\");\n\tSteamNetworkPingLocation_t ping_location;\n\tuint8_t *input_location = (uint8 *)location.ptr();\n\tfor (int j = 0; j < 512; j++) {\n\t\tping_location.m_data[j] = input_location[j];\n\t}\n\n\tchar buffer[512 + 1]{};\n\tSteamNetworkingUtils()->ConvertPingLocationToString(ping_location, buffer, k_cchMaxSteamNetworkingPingLocationString);\n\tlocation_string += buffer;\n\treturn location_string;\n}\n\n// Parse back SteamNetworkPingLocation_t string. Returns false if we couldn't understand the string.\nDictionary Steam::parsePingLocationString(const String &location_string) {\n\tDictionary parse_string;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, parse_string, \"[STEAM] Networking Utils class not found when calling: parsePingLocationString\");\n\tSteamNetworkPingLocation_t result;\n\tbool success = SteamNetworkingUtils()->ParsePingLocationString(location_string.utf8().get_data(), result);\n\t\n\tPackedByteArray data;\n\tdata.resize(512);\n\tuint8_t *output_data = data.ptrw();\n\tfor (int j = 0; j < 512; j++) {\n\t\toutput_data[j] = result.m_data[j];\n\t}\n\tparse_string[\"success\"] = success;\n\tparse_string[\"ping_location\"] = data;\n\treturn parse_string;\n}\n\n// Check if the ping data of sufficient recency is available, and if it's too old, start refreshing it.\nbool Steam::checkPingDataUpToDate(float max_age_in_seconds) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: checkPingDataUpToDate\");\n\treturn SteamNetworkingUtils()->CheckPingDataUpToDate(max_age_in_seconds);\n}\n\n// Fetch ping time of best available relayed route from this host to the specified data center.\nDictionary Steam::getPingToDataCenter(uint32 pop_id) {\n\tDictionary data_center_ping;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, data_center_ping, \"[STEAM] Networking Utils class not found when calling: getPingToDataCenter\");\n\tSteamNetworkingPOPID via_relay_pop;\n\tint ping = SteamNetworkingUtils()->GetPingToDataCenter((SteamNetworkingPOPID)pop_id, &via_relay_pop);\n\n\tdata_center_ping[\"pop_relay\"] = via_relay_pop;\n\tdata_center_ping[\"ping\"] = ping;\n\treturn data_center_ping;\n}\n\n// Get *direct* ping time to the relays at the point of presence.\nint Steam::getDirectPingToPOP(uint32 pop_id) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, 0, \"[STEAM] Networking Utils class not found when calling: getDirectPingToPOP\");\n\treturn SteamNetworkingUtils()->GetDirectPingToPOP((SteamNetworkingPOPID)pop_id);\n}\n\n// Get number of network points of presence in the config\nint Steam::getPOPCount() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, 0, \"[STEAM] Networking Utils class not found when calling: getPOPCount\");\n\treturn SteamNetworkingUtils()->GetPOPCount();\n}\n\n// Get list of all POP IDs. Returns the number of entries that were filled into your list.\nArray Steam::getPOPList() {\n\tArray pop_list;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, pop_list, \"[STEAM] Networking Utils class not found when calling: getPOPList\");\n\tSteamNetworkingPOPID list[256];\n\tint pops = SteamNetworkingUtils()->GetPOPList(list, 256);\n\t\n\tfor (int i = 0; i < pops; i++) {\n\t\tint pop_id = list[i];\n\t\tpop_list.append(pop_id);\n\t}\n\treturn pop_list;\n}\n\n// Set a configuration value.\n//bool Steam::setConfigValue(NetworkingConfigValue setting, NetworkingConfigScope scope_type, uint32_t connection_handle, NetworkingConfigDataType data_type, auto value) {\n//\tERR_FAIL_COND_V_MSG(SteamGameServer() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setConfigValue\");\n//\treturn SteamNetworkingUtils()->SetConfigValue((ESteamNetworkingConfigValue)setting, (ESteamNetworkingConfigScope)scope_type, connection_handle, (ESteamNetworkingConfigDataType)data_type, value);\n//}\n\n// Get a configuration value.\nDictionary Steam::getConfigValue(NetworkingConfigValue config_value, NetworkingConfigScope scope_type, uint32_t connection_handle) {\n\tDictionary config_info;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, config_info, \"[STEAM] Networking Utils class not found when calling: getConfigValue\");\n\tESteamNetworkingConfigDataType data_type;\n\tsize_t buffer_size;\n\tPackedByteArray config_result;\n\tint result = SteamNetworkingUtils()->GetConfigValue((ESteamNetworkingConfigValue)config_value, (ESteamNetworkingConfigScope)scope_type, connection_handle, &data_type, &config_result, &buffer_size);\n\t\n\tconfig_info[\"result\"] = result;\n\tconfig_info[\"type\"] = data_type;\n\tconfig_info[\"value\"] = config_result;\n\tconfig_info[\"buffer\"] = (uint64_t)buffer_size;\n\treturn config_info;\n}\n\n// Returns info about a configuration value.\nDictionary Steam::getConfigValueInfo(NetworkingConfigValue config_value) {\n\tDictionary config_info;\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, config_info, \"[STEAM] Networking Utils class not found when calling: getConfigValueInfo\");\n\tESteamNetworkingConfigDataType data_type;\n\tESteamNetworkingConfigScope scope;\n\tif (SteamNetworkingUtils()->GetConfigValueInfo((ESteamNetworkingConfigValue)config_value, &data_type, &scope)) {\n\t\tconfig_info[\"type\"] = data_type;\n\t\tconfig_info[\"scope\"] = scope;\n\t}\n\treturn config_info;\n}\n\n// The following functions are handy shortcuts for common use cases.\nbool Steam::setGlobalConfigValueInt32(NetworkingConfigValue config, int32 value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setGlobalConfigValueInt32\");\n\treturn SteamNetworkingUtils()->SetGlobalConfigValueInt32((ESteamNetworkingConfigValue)config, value);\n}\n\nbool Steam::setGlobalConfigValueFloat(NetworkingConfigValue config, float value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setGlobalConfigValueFloat\");\n\treturn SteamNetworkingUtils()->SetGlobalConfigValueFloat((ESteamNetworkingConfigValue)config, value);\n}\n\nbool Steam::setGlobalConfigValueString(NetworkingConfigValue config, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setGlobalConfigValueString\");\n\treturn SteamNetworkingUtils()->SetGlobalConfigValueString((ESteamNetworkingConfigValue)config, value.utf8().get_data());\n}\n\nbool Steam::setConnectionConfigValueInt32(uint32 connection, NetworkingConfigValue config, int32 value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setConnectionConfigValueInt32\");\n\treturn SteamNetworkingUtils()->SetConnectionConfigValueInt32(connection, (ESteamNetworkingConfigValue)config, value);\n}\n\nbool Steam::setConnectionConfigValueFloat(uint32 connection, NetworkingConfigValue config, float value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setConnectionConfigValueFloat\");\n\treturn SteamNetworkingUtils()->SetConnectionConfigValueFloat(connection, (ESteamNetworkingConfigValue)config, value);\n}\n\nbool Steam::setConnectionConfigValueString(uint32 connection, NetworkingConfigValue config, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, false, \"[STEAM] Networking Utils class not found when calling: setConnectionConfigValueString\");\n\treturn SteamNetworkingUtils()->SetConnectionConfigValueString(connection, (ESteamNetworkingConfigValue)config, value.utf8().get_data());\n}\n\n// A general purpose high resolution local timer with the following properties: Monotonicity is guaranteed. The initial value will\n// be at least 24*3600*30*1e6, i.e. about 30 days worth of microseconds. In this way, the timestamp value of 0 will always be at\n// least \"30 days ago\". Also, negative numbers will never be returned. Wraparound / overflow is not a practical concern.\nuint64_t Steam::getLocalTimestamp() {\n\tERR_FAIL_COND_V_MSG(SteamNetworkingUtils() == NULL, 0, \"[STEAM] Networking Utils class not found when calling: getLocalTimestamp\");\n\treturn SteamNetworkingUtils()->GetLocalTimestamp();\n}\n\n\n///// PARENTAL SETTINGS\n\n// There are no notes about these functions, names can assume functionality.\nbool Steam::isAppBlocked(uint32 app_id) {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isAppBlocked\");\n\treturn SteamParentalSettings()->BIsAppBlocked((AppId_t)app_id);\n}\n\nbool Steam::isAppInBlockList(uint32 app_id) {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isAppInBlockList\");\n\treturn SteamParentalSettings()->BIsAppInBlockList((AppId_t)app_id);\n}\n\nbool Steam::isFeatureBlocked(ParentalFeature feature) {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isFeatureBlocked\");\n\treturn SteamParentalSettings()->BIsFeatureBlocked((EParentalFeature)feature);\n}\n\nbool Steam::isFeatureInBlockList(ParentalFeature feature) {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isFeatureInBlockList\");\n\treturn SteamParentalSettings()->BIsFeatureInBlockList((EParentalFeature)feature);\n}\n\nbool Steam::isParentalLockEnabled() {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isParentalLockEnabled\");\n\treturn SteamParentalSettings()->BIsParentalLockEnabled();\n}\n\nbool Steam::isParentalLockLocked() {\n\tERR_FAIL_COND_V_MSG(SteamParentalSettings() == NULL, false, \"[STEAM] Parental Settings class not found when calling: isParentalLockLocked\");\n\treturn SteamParentalSettings()->BIsParentalLockLocked();\n}\n\n\n///// PARTIES\n\n// To cancel a reservation (due to timeout or user input), call this. Steam will open a new reservation slot. Note: The user may\n// already be in-flight to your game, so it's possible they will still connect and try to join your party.\nvoid Steam::cancelReservation(uint64_t beacon_id, uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamParties() == NULL, \"[STEAM] Parties class not found when calling: cancelReservation\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamParties()->CancelReservation(beacon_id, user_id);\n}\n\n// If a user joins your party through other matchmaking (perhaps a direct Steam friend, or your own matchmaking system), your game\n// should reduce the number of open slots that Steam is managing through the party beacon. For example, if you created a beacon\n// with five slots, and Steam sent you two ReservationNotificationCallback_t callbacks, and then a third user joined directly,\n// you would want to call ChangeNumOpenSlots with a value of 2 for unOpenSlots. That value represents the total number of new users\n// that you would like Steam to send to your party.\nvoid Steam::changeNumOpenSlots(uint64_t beacon_id, uint32 open_slots) {\n\tERR_FAIL_COND_MSG(SteamParties() == NULL, \"[STEAM] Parties class not found when calling: changeNumOpenSlots\");\n\tSteamAPICall_t api_call = SteamParties()->ChangeNumOpenSlots(beacon_id, open_slots);\n\tcallResultChangeNumOpenSlots.Set(api_call, this, &Steam::change_num_open_slots);\n}\n\n// Create a beacon. You can only create one beacon at a time. Steam will display the beacon in the specified location, and let up\n// to unOpenSlots users \"follow\" the beacon to your party.\nvoid Steam::createBeacon(uint32 open_slots, uint64_t location, PartyBeaconLocationType type, const String &connect_string, const String &beacon_metadata) {\n\tERR_FAIL_COND_MSG(SteamParties() == NULL, \"[STEAM] Parties class not found when calling: createBeacon\");\n\tSteamPartyBeaconLocation_t beacon_data;\n\tbeacon_data.m_eType = (ESteamPartyBeaconLocationType)type;\n\tbeacon_data.m_ulLocationID = location;\n\tSteamAPICall_t api_call = SteamParties()->CreateBeacon(open_slots, &beacon_data, connect_string.utf8().get_data(), beacon_metadata.utf8().get_data());\n\tcallResultCreateBeacon.Set(api_call, this, &Steam::create_beacon);\n}\n\n// Call this method to destroy the Steam party beacon. This will immediately cause Steam to stop showing the beacon in the target\n// location. Note that any users currently in-flight may still arrive at your party expecting to join.\nbool Steam::destroyBeacon(uint64_t beacon_id) {\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, false, \"[STEAM] Parties class not found when calling: destroyBeacon\");\n\treturn SteamParties()->DestroyBeacon(beacon_id);\n}\n\n// Get the list of locations in which you can post a party beacon.\nArray Steam::getAvailableBeaconLocations(uint32 max) {\n\tArray beacon_locations;\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, beacon_locations, \"[STEAM] Parties class not found when calling: getAvailableBeaconLocations\");\n\tuint32 locations = 0;\n\tSteamPartyBeaconLocation_t beacons[256];\n\tif (SteamParties()->GetNumAvailableBeaconLocations(&locations)) {\n\t\t// If max is lower than locations, set it to locations\n\t\tif (max < locations) {\n\t\t\tmax = locations;\n\t\t}\n\t\t// Now get the beacon location list\n\t\tif (SteamParties()->GetAvailableBeaconLocations(beacons, max)) {\n\t\t\tfor (uint32 i = 0; i < max; i++) {\n\t\t\t\tDictionary beacon_data;\n\t\t\t\tbeacon_data[\"type\"] = beacons[i].m_eType;\n\t\t\t\tbeacon_data[\"location_id\"] = (uint64_t)beacons[i].m_ulLocationID;\n\t\t\t\tbeacon_locations.append(beacon_data);\n\t\t\t}\n\t\t}\n\t}\n\treturn beacon_locations;\n}\n\n// Use with ISteamParties::GetNumActiveBeacons to iterate the active beacons visible to the current user. unIndex is a zero-based\n// index, so iterate over the range [0, GetNumActiveBeacons() - 1]. The return is a PartyBeaconID_t that can be used with\n// getBeaconDetails to get information about the beacons suitable for display to the user.\nuint64_t Steam::getBeaconByIndex(uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, 0, \"[STEAM] Parties class not found when calling: getBeaconByIndex\");\n\treturn SteamParties()->GetBeaconByIndex(index);\n}\n\n// Get details about the specified beacon. You can use the ISteamFriends API to get further details about pSteamIDBeaconOwner, and\n// getBeaconLocationData to get further details about pLocation. The pchMetadata contents are specific to your game, and will be\n// whatever was set (if anything) by the game process that created the beacon.\nDictionary Steam::getBeaconDetails(uint64_t beacon_id) {\n\tDictionary details;\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, details, \"[STEAM] Parties class not found when calling: getBeaconDetails\");\n\tCSteamID owner;\n\tSteamPartyBeaconLocation_t location;\n\tchar beacon_metadata[STEAM_LARGE_BUFFER_SIZE];\n\tif (SteamParties()->GetBeaconDetails(beacon_id, &owner, &location, beacon_metadata, STEAM_LARGE_BUFFER_SIZE)) {\n\t\tdetails[\"beacon_id\"] = beacon_id;\n\t\tdetails[\"owner_id\"] = (uint64_t)owner.ConvertToUint64();\n\t\tdetails[\"type\"] = location.m_eType;\n\t\tdetails[\"location_id\"] = (uint64_t)location.m_ulLocationID;\n\t\tdetails[\"metadata\"] = beacon_metadata;\n\t}\n\treturn details;\n}\n\n// Query general metadata for the given beacon location. For instance the Name, or the URL for an icon if the location type\n// supports icons (for example, the icon for a Steam Chat Room Group).\nString Steam::getBeaconLocationData(uint64_t location_id, PartyBeaconLocationType location_type, PartyBeaconLocationData location_data) {\n\tString beacon_location_data = \"\";\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, beacon_location_data, \"[STEAM] Parties class not found when calling: getBeaconLocationData\");\n\tchar beacon_data[2048 + 1]{};\n\tSteamPartyBeaconLocation_t beacon;\n\tbeacon.m_eType = (ESteamPartyBeaconLocationType)location_type;\n\tbeacon.m_ulLocationID = location_id;\n\tif (SteamParties()->GetBeaconLocationData(beacon, (ESteamPartyBeaconLocationData)location_data, beacon_data, 2048)) {\n\t\tbeacon_location_data = beacon_data;\n\t}\n\treturn beacon_location_data;\n}\n\n// Get the number of active party beacons created by other users for your game, that are visible to the current user.\nuint32 Steam::getNumActiveBeacons() {\n\tERR_FAIL_COND_V_MSG(SteamParties() == NULL, 0, \"[STEAM] Parties class not found when calling: getNumActiveBeacons\");\n\treturn SteamParties()->GetNumActiveBeacons();\n}\n\n// When the user indicates they wish to join the party advertised by a given beacon, call this method. On success, Steam will\n// reserve a slot for this user in the party and return the necessary \"join game\" string to use to complete the connection.\nvoid Steam::joinParty(uint64_t beacon_id) {\n\tERR_FAIL_COND_MSG(SteamParties() == NULL, \"[STEAM] Parties class not found when calling: joinParty\");\n\tSteamAPICall_t api_call = SteamParties()->JoinParty(beacon_id);\n\tcallResultJoinParty.Set(api_call, this, &Steam::join_party);\n}\n\n// When a user follows your beacon, Steam will reserve one of the open party slots for them, and send your game a\n// ReservationNotificationCallback_t callback. When that user joins your party, call OnReservationCompleted to notify Steam that\n// the user has joined successfully.\nvoid Steam::onReservationCompleted(uint64_t beacon_id, uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamParties() == NULL, \"[STEAM] Parties class not found when calling: onReservationCompleted\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamParties()->OnReservationCompleted(beacon_id, user_id);\n}\n\n\n///// REMOTE PLAY\n\n// Get the number of currently connected Steam Remote Play sessions.\nuint32 Steam::getSessionCount() {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, 0, \"[STEAM] Remote Play class not found when calling: getSessionCount\");\n\treturn SteamRemotePlay()->GetSessionCount();\n}\n\n// Get the currently connected Steam Remote Play session ID at the specified index.\nuint32 Steam::getSessionID(uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, 0, \"[STEAM] Remote Play class not found when calling: getSessionID\");\n\treturn SteamRemotePlay()->GetSessionID(index);\n}\n\n// Get the SteamID of the connected user.\nuint64_t Steam::getSessionSteamID(uint32 session_id) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, 0, \"[STEAM] Remote Play class not found when calling: getSessionSteamID\");\n\tCSteamID steam_id = SteamRemotePlay()->GetSessionSteamID(session_id);\n\treturn steam_id.ConvertToUint64();\n}\n\n// Get the name of the session client device.\nString Steam::getSessionClientName(uint32 session_id) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, \"\", \"[STEAM] Remote Play class not found when calling: getSessionClientName\");\n\treturn SteamRemotePlay()->GetSessionClientName(session_id);\n}\n\n// Get the form factor of the session client device.\nint Steam::getSessionClientFormFactor(uint32 session_id) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, 0, \"[STEAM] Remote Play class not found when calling: getSessionClientFormFactor\");\n\treturn SteamRemotePlay()->GetSessionClientFormFactor(session_id);\n}\n\n// Get the resolution, in pixels, of the session client device. This is set to 0x0 if the resolution is not available.\nDictionary Steam::getSessionClientResolution(uint32 session_id) {\n\tDictionary resolution;\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, resolution, \"[STEAM] Remote Play class not found when calling: getSessionClientResolution\");\n\tint resolutionX = 0;\n\tint resolutionY = 0;\n\n\tbool success = SteamRemotePlay()->BGetSessionClientResolution(session_id, &resolutionX, &resolutionY);\n\tif (success) {\n\t\tresolution[\"success\"] = success;\n\t\tresolution[\"x\"] = resolutionX;\n\t\tresolution[\"y\"] = resolutionY;\n\t}\n\treturn resolution;\n}\n\n// Invite a friend to join the game using Remote Play Together\nbool Steam::sendRemotePlayTogetherInvite(uint64_t friend_id) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, false, \"[STEAM] Remote Play class not found when calling: sendRemotePlayTogetherInvite\");\n\tCSteamID steam_id = (uint64)friend_id;\n\treturn SteamRemotePlay()->BSendRemotePlayTogetherInvite(steam_id);\n}\n\n//\nbool Steam::startRemotePlayTogether(bool show_overlay) {\n\tERR_FAIL_COND_V_MSG(SteamRemotePlay() == NULL, false, \"[STEAM] Remote Play class not found when calling: startRemotePlayTogether\");\n\treturn SteamRemotePlay()->BStartRemotePlayTogether(show_overlay);\n}\n\n\n///// REMOTE STORAGE\n\n// Indicate to Steam the beginning / end of a set of local file operations - for example, writing a game save that requires\n// updating two files.\nbool Steam::beginFileWriteBatch() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: beginFileWriteBatch\");\n\treturn SteamRemoteStorage()->BeginFileWriteBatch();\n}\n\n// Indicate to Steam the beginning / end of a set of local file operations - for example, writing a game save that requires\n// updating two files.\nbool Steam::endFileWriteBatch() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: endFileWriteBatch\");\n\treturn SteamRemoteStorage()->EndFileWriteBatch();\n}\n\n// Delete a given file in Steam Cloud.\nbool Steam::fileDelete(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileDelete\");\n\treturn SteamRemoteStorage()->FileDelete(file.utf8().get_data());\n}\n\n// Check if a given file exists in Steam Cloud.\nbool Steam::fileExists(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileExists\");\n\treturn SteamRemoteStorage()->FileExists(file.utf8().get_data());\n}\n\n// Delete file from remote storage but leave it on local disk to remain accessible.\nbool Steam::fileForget(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileForget\");\n\treturn SteamRemoteStorage()->FileForget(file.utf8().get_data());\n}\n\n// Check if a given file is persisted in Steam Cloud.\nbool Steam::filePersisted(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: filePersisted\");\n\treturn SteamRemoteStorage()->FilePersisted(file.utf8().get_data());\n}\n\n// Read given file from Steam Cloud.\nDictionary Steam::fileRead(const String &file, int32_t data_to_read) {\n\tDictionary file_data;\n\tfile_data[\"ret\"] = false;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, file_data, \"[STEAM] Remote Storage class not found when calling: fileRead\");\n\tPackedByteArray data;\n\tdata.resize(data_to_read);\n\tfile_data[\"ret\"] = SteamRemoteStorage()->FileRead(file.utf8().get_data(), data.ptrw(), data_to_read);\n\tfile_data[\"buf\"] = data;\n\treturn file_data;\n}\n\n// Starts an asynchronous read from a file. The offset and amount to read should be valid for the size of the file, as indicated by\n// GetFileSize or GetFileTimestamp.\nvoid Steam::fileReadAsync(const String &file, uint32 offset, uint32_t data_to_read) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: fileReadAsync\");\n\tSteamAPICall_t api_call = SteamRemoteStorage()->FileReadAsync(file.utf8().get_data(), offset, data_to_read);\n\tcallResultFileReadAsyncComplete.Set(api_call, this, &Steam::file_read_async_complete);\n}\n\n// Share a file.\nvoid Steam::fileShare(const String &file) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: fileShare\");\n\tSteamAPICall_t api_call = SteamRemoteStorage()->FileShare(file.utf8().get_data());\n\tcallResultFileShareResult.Set(api_call, this, &Steam::file_share_result);\n}\n\n// Write to given file from Steam Cloud.\nbool Steam::fileWrite(const String &file, PackedByteArray data, int32 size) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileWrite\");\n\tint32 data_size = data.size();\n\tif (size > 0) {\n\t\tdata_size = size;\n\t}\n\treturn SteamRemoteStorage()->FileWrite(file.utf8().get_data(), data.ptr(), data_size);\n}\n\n// Creates a new file and asynchronously writes the raw byte data to the Steam Cloud, and then closes the file. If the target file\n// already exists, it is overwritten.\nvoid Steam::fileWriteAsync(const String &file, PackedByteArray data, int32 size) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: fileWriteAsync\");\n\tint32 data_size = data.size();\n\tif (size > 0) {\n\t\tdata_size = size;\n\t}\n\tSteamAPICall_t api_call = SteamRemoteStorage()->FileWriteAsync(file.utf8().get_data(), data.ptr(), data_size);\n\tcallResultFileWriteAsyncComplete.Set(api_call, this, &Steam::file_write_async_complete);\n}\n\n// Cancels a file write stream that was started by FileWriteStreamOpen.  This trashes all of the data written and closes the write\n// stream, but if there was an existing file with this name, it remains untouched.\nbool Steam::fileWriteStreamCancel(uint64_t write_handle) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileWriteStreamCancel\");\n\treturn SteamRemoteStorage()->FileWriteStreamCancel((UGCFileWriteStreamHandle_t)write_handle);\n}\n\n// Closes a file write stream that was started by FileWriteStreamOpen. This flushes the stream to the disk, overwriting the\n// existing file if there was one.\nbool Steam::fileWriteStreamClose(uint64_t write_handle) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileWriteStreamClose\");\n\treturn SteamRemoteStorage()->FileWriteStreamClose((UGCFileWriteStreamHandle_t)write_handle);\n}\n\n// Creates a new file output stream allowing you to stream out data to the Steam Cloud file in chunks. If the target file already\n// exists, it is not overwritten until FileWriteStreamClose has been called. To write data out to this stream you can use\n// FileWriteStreamWriteChunk, and then to close or cancel you use FileWriteStreamClose and FileWriteStreamCancel respectively.\nuint64_t Steam::fileWriteStreamOpen(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, 0, \"[STEAM] Remote Storage class not found when calling: fileWriteStreamOpen\");\n\treturn SteamRemoteStorage()->FileWriteStreamOpen(file.utf8().get_data());\n}\n\n// Writes a blob of data to the file write stream.\nbool Steam::fileWriteStreamWriteChunk(uint64_t write_handle, PackedByteArray data) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: fileWriteStreamWriteChunk\");\n\treturn SteamRemoteStorage()->FileWriteStreamWriteChunk((UGCFileWriteStreamHandle_t)write_handle, data.ptr(), data.size());\n}\n\n// Gets the number of cached UGC.\nint32 Steam::getCachedUGCCount() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, 0, \"[STEAM] Remote Storage class not found when calling: getCachedUGCCount\");\n\treturn SteamRemoteStorage()->GetCachedUGCCount();\n}\n\n// Gets the cached UGC's handle.\nuint64_t Steam::getCachedUGCHandle(int32 content) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, 0, \"[STEAM] Remote Storage class not found when calling: getCachedUGCHandle\");\n\treturn SteamRemoteStorage()->GetCachedUGCHandle(content);\n}\n\n// Gets the total number of local files synchronized by Steam Cloud.\nint32_t Steam::getFileCount() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, 0, \"[STEAM] Remote Storage class not found when calling: getFileCount\");\n\treturn SteamRemoteStorage()->GetFileCount();\n}\n\n// Gets the file name and size of a file from the index.\nDictionary Steam::getFileNameAndSize(int file) {\n\tDictionary file_data;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, file_data, \"[STEAM] Remote Storage class not found when calling: getFileNameAndSize\");\n\tint32_t size = 0;\n\tfile_data[\"name\"] = String(SteamRemoteStorage()->GetFileNameAndSize(file, &size));\n\tfile_data[\"size\"] = size;\n\treturn file_data;\n}\n\n// Get the size of a given file.\nint32_t Steam::getFileSize(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, -1, \"[STEAM] Remote Storage class not found when calling: getFileSize\");\n\treturn SteamRemoteStorage()->GetFileSize(file.utf8().get_data());\n}\n\n// Get the timestamp of when the file was uploaded/changed.\nint64_t Steam::getFileTimestamp(const String &file) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, -1, \"[STEAM] Remote Storage class not found when calling: getFileTimestamp\");\n\treturn SteamRemoteStorage()->GetFileTimestamp(file.utf8().get_data());\n}\n\n// Cloud dynamic state change notification, for iteration with getLocalFileChangeCount\nDictionary Steam::getLocalFileChange(int file) {\n\tDictionary file_change;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, file_change, \"[STEAM] Remote Storage class not found when calling: getLocalFileChange\");\n\tERemoteStorageLocalFileChange change_type;\n\tERemoteStorageFilePathType file_path_type;\n\tString changed_file = SteamRemoteStorage()->GetLocalFileChange(file, &change_type, &file_path_type);\n\t\n\tfile_change[\"file\"] = changed_file;\n\tfile_change[\"change_type\"] = change_type;\n\tfile_change[\"path_type\"] = file_path_type;\n\treturn file_change;\n}\n\n// Cloud dynamic state change notification, used to get the total number of files changed; paired with getLocalFileChange\nuint32_t Steam::getLocalFileChangeCount() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, 0, \"[STEAM] Remote Storage class not found when calling: getLocalFileChangeCount\");\n\treturn SteamRemoteStorage()->GetLocalFileChangeCount();\n}\n\n// Gets the number of bytes available, and used on the users Steam Cloud storage.\nDictionary Steam::getQuota() {\n\tDictionary quota_data;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, quota_data, \"[STEAM] Remote Storage class not found when calling: getFileNameAndSize\");\n\tuint64_t total = 0;\n\tuint64_t available = 0;\n\tSteamRemoteStorage()->GetQuota((uint64 *)&total, (uint64 *)&available);\n\n\tquota_data[\"total_bytes\"] = total;\n\tquota_data[\"available_bytes\"] = available;\n\treturn quota_data;\n}\n\n// Obtains the platforms that the specified file will syncronize to.\nDictionary Steam::getSyncPlatforms(const String &file) {\n\tDictionary platforms;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, platforms, \"[STEAM] Remote Storage class not found when calling: getSyncPlatforms\");\n\tuint32_t platform = SteamRemoteStorage()->GetSyncPlatforms(file.utf8().get_data());\n\n\tplatforms[\"bitwise\"] = platform;\n\tif (platform == 0) {\n\t\tplatforms[\"verbose\"] = \"none\";\n\t}\n\telse if (platform == (1 << 0)) {\n\t\tplatforms[\"verbose\"] = \"windows\";\n\t}\n\telse if (platform == (1 << 1)) {\n\t\tplatforms[\"verbose\"] = \"osx\";\n\t}\n\telse if (platform == (1 << 2)) {\n\t\tplatforms[\"verbose\"] = \"playstation 3\";\n\t}\n\telse if (platform == (1 << 3)) {\n\t\tplatforms[\"verbose\"] = \"linux / steamos\";\n\t}\n\telse if (platform == (1 << 4)) {\n\t\tplatforms[\"verbose\"] = \"reserved\";\n\t}\n\telse {\n\t\tplatforms[\"verbose\"] = \"all\";\n\t}\n\treturn platforms;\n}\n\n// Gets metadata for a file after it has been downloaded. This is the same metadata given in the RemoteStorageDownloadUGCResult_t\n// call result.\nDictionary Steam::getUGCDetails(uint64_t content) {\n\tDictionary ugc_details;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, ugc_details, \"[STEAM] Remote Storage class not found when calling: getUGCDetails\");\n\tAppId_t app_id;\n\tchar *filename;\n\tint32 file_size;\n\tCSteamID steam_owner_id;\n\tif (SteamRemoteStorage()->GetUGCDetails((UGCHandle_t)content, &app_id, &filename, &file_size, &steam_owner_id)) {\n\t\tugc_details[\"handle\"] = content;\n\t\tugc_details[\"app_id\"] = app_id;\n\t\tugc_details[\"size\"] = file_size;\n\t\tugc_details[\"filename\"] = filename;\n\t\tugc_details[\"owner_id\"] = (uint64_t)steam_owner_id.ConvertToUint64();\n\t}\n\treturn ugc_details;\n}\n\n// Gets the amount of data downloaded so far for a piece of content. pnBytesExpected can be 0 if function returns false or if the\n// transfer hasn't started yet, so be careful to check for that before dividing to get a percentage.\nDictionary Steam::getUGCDownloadProgress(uint64_t content) {\n\tDictionary ugc_download_progress;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, ugc_download_progress, \"[STEAM] Remote Storage class not found when calling: getUGCDownloadProgress\");\n\tint32 bytes_downloaded;\n\tint32 bytes_expected;\n\tif (SteamRemoteStorage()->GetUGCDownloadProgress((UGCHandle_t)content, &bytes_downloaded, &bytes_expected)) {\n\t\tugc_download_progress[\"bytes_downloaded\"] = bytes_downloaded;\n\t\tugc_download_progress[\"bytes_expected\"] = bytes_expected;\n\t}\n\treturn ugc_download_progress;\n}\n\n// Is Steam Cloud enabled on the user's account?\nbool Steam::isCloudEnabledForAccount() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: isCloudEnabledForAccount\");\n\treturn SteamRemoteStorage()->IsCloudEnabledForAccount();\n}\n\n// Is Steam Cloud enabled for this application?\nbool Steam::isCloudEnabledForApp() {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: isCloudEnabledForApp\");\n\treturn SteamRemoteStorage()->IsCloudEnabledForApp();\n}\n\n// Set Steam Cloud enabled for this application.\nvoid Steam::setCloudEnabledForApp(bool enabled) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: setCloudEnabledForApp\");\n\tSteamRemoteStorage()->SetCloudEnabledForApp(enabled);\n}\n\n// Allows you to specify which operating systems a file will be synchronized to. Use this if you have a multiplatform game but have\n// data which is incompatible between platforms.\nbool Steam::setSyncPlatforms(const String &file, int platform) {\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, false, \"[STEAM] Remote Storage class not found when calling: setSyncPlatforms\");\n\treturn SteamRemoteStorage()->SetSyncPlatforms(file.utf8().get_data(), (ERemoteStoragePlatform)platform);\n}\n\n// Downloads a UGC file.  A priority value of 0 will download the file immediately, otherwise it will wait to download the file\n// until all downloads with a lower priority value are completed.  Downloads with equal priority will occur simultaneously.\nvoid Steam::ugcDownload(uint64_t content, uint32 priority) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: ugcDownload\");\n\tSteamAPICall_t api_call = SteamRemoteStorage()->UGCDownload((UGCHandle_t)content, priority);\n\tcallResultDownloadUGCResult.Set(api_call, this, &Steam::download_ugc_result);\n}\n\n// Downloads a UGC file to a specific location.\nvoid Steam::ugcDownloadToLocation(uint64_t content, const String &location, uint32 priority) {\n\tERR_FAIL_COND_MSG(SteamRemoteStorage() == NULL, \"[STEAM] Remote Storage class not found when calling: ugcDownloadToLocation\");\n\tSteamAPICall_t api_call = SteamRemoteStorage()->UGCDownloadToLocation((UGCHandle_t)content, location.utf8().get_data(), priority);\n\tcallResultDownloadUGCResult.Set(api_call, this, &Steam::download_ugc_result);\n}\n\n// After download, gets the content of the file.\nPackedByteArray Steam::ugcRead(uint64_t content, int32 data_size, uint32 offset, UGCReadAction action) {\n\tPackedByteArray file_contents;\n\tERR_FAIL_COND_V_MSG(SteamRemoteStorage() == NULL, file_contents, \"[STEAM] Remote Storage class not found when calling: setSyncPlatforms\");\n\tfile_contents.resize(data_size);\n\tSteamRemoteStorage()->UGCRead((UGCHandle_t)content, file_contents.ptrw(), data_size, offset, (EUGCReadAction)action);\n\treturn file_contents;\n}\n\n\n///// SCREENSHOTS\n\n// Adds a screenshot to the user's Steam screenshot library from disk.\nuint32_t Steam::addScreenshotToLibrary(const String &filename, const String &thumbnail_filename, int width, int height) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, 0, \"[STEAM] Screenshots class not found when calling: addScreenshotToLibrary\");\n\treturn SteamScreenshots()->AddScreenshotToLibrary(filename.utf8().get_data(), thumbnail_filename.utf8().get_data(), width, height);\n}\n\n// Adds a VR screenshot to the user's Steam screenshot library from disk in the supported type.\nuint32_t Steam::addVRScreenshotToLibrary(VRScreenshotType type, const String &filename, const String &vr_filename) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, 0, \"[STEAM] Screenshots class not found when calling: addVRScreenshotToLibrary\");\n\treturn SteamScreenshots()->AddVRScreenshotToLibrary((EVRScreenshotType)type, filename.utf8().get_data(), vr_filename.utf8().get_data());\n}\n\n// Toggles whether the overlay handles screenshots.\nvoid Steam::hookScreenshots(bool hook) {\n\tERR_FAIL_COND_MSG(SteamScreenshots() == NULL, \"[STEAM] Screenshots class not found when calling: hookScreenshots\");\n\tSteamScreenshots()->HookScreenshots(hook);\n}\n\n// Checks if the app is hooking screenshots.\nbool Steam::isScreenshotsHooked() {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, false, \"[STEAM] Screenshots class not found when calling: isScreenshotsHooked\");\n\treturn SteamScreenshots()->IsScreenshotsHooked();\n}\n\n// Sets optional metadata about a screenshot's location.\nbool Steam::setLocation(uint32_t screenshot, const String &location) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, false, \"[STEAM] Screenshots class not found when calling: setLocation\");\n\tScreenshotHandle handle = (ScreenshotHandle)screenshot;\n\treturn SteamScreenshots()->SetLocation(handle, location.utf8().get_data());\n}\n\n// Tags a published file as being visible in the screenshot.\nbool Steam::tagPublishedFile(uint32_t screenshot, uint64_t file_id) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, false, \"[STEAM] Screenshots class not found when calling: tagPublishedFile\");\n\tPublishedFileId_t file = (uint64)file_id;\n\treturn SteamScreenshots()->TagPublishedFile((ScreenshotHandle)screenshot, file);\n}\n\n// Tags a Steam user as being visible in the screenshot.  You can tag up to the value declared by k_nScreenshotMaxTaggedUsers in\n// a single screenshot. Tagging more users than that will just be discarded.  This function has a built in delay before saving\n// the tag which allows you to call it repeatedly for each item.  You can get the handle to tag the screenshot once it has been\n// successfully saved from the ScreenshotReady_t callback or via the WriteScreenshot, AddScreenshotToLibrary,\n// AddVRScreenshotToLibrary calls.\nbool Steam::tagUser(uint32 screenshot, uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, false, \"[STEAM] Screenshots class not found when calling: tagUser\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamScreenshots()->TagUser((ScreenshotHandle)screenshot, user_id);\n}\n\n// Causes Steam overlay to take a screenshot.\nvoid Steam::triggerScreenshot() {\n\tERR_FAIL_COND_MSG(SteamScreenshots() == NULL, \"[STEAM] Screenshots class not found when calling: triggerScreenshot\");\n\tSteamScreenshots()->TriggerScreenshot();\n}\n\n// Writes a screenshot to the user's Steam screenshot library.\nuint32_t Steam::writeScreenshot(const PackedByteArray &rgb, int width, int height) {\n\tERR_FAIL_COND_V_MSG(SteamScreenshots() == NULL, 0, \"[STEAM] Screenshots class not found when calling: writeScreenshot\");\n\treturn SteamScreenshots()->WriteScreenshot((void *)rgb.ptr(), rgb.size(), width, height);\n}\n\n\n///// TIMELINE\n\n// Add a tag that applies to the entire phase.\nvoid Steam::addGamePhaseTag(const String &tag_name, const String &tag_icon, const String &tag_group, uint32 priority ){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: addGamePhaseTag\");\n\tSteamTimeline()->AddGamePhaseTag(tag_name.utf8().get_data(), tag_icon.utf8().get_data(), tag_group.utf8().get_data(), priority);\n}\n\n// Use this to mark an event (A) on the Timeline. This event will be instantaneous. (See addRangeTimelineEvent to add events that happened over time.)\nuint64_t Steam::addInstantaneousTimelineEvent(const String &title, const String &description, const String &icon, uint32 icon_priority, float start_offset_seconds, TimelineEventClipPriority possible_clip){\n\tERR_FAIL_COND_V_MSG(SteamTimeline() == NULL, 0, \"[STEAM] Timeline class not found when calling: addInstantaneousTimelineEvent\");\n\treturn SteamTimeline()->AddInstantaneousTimelineEvent(title.utf8().get_data(), description.utf8().get_data(), icon.utf8().get_data(), icon_priority, start_offset_seconds, (ETimelineEventClipPriority)possible_clip);\n}\n\n// Use this to mark an event (A) on the Timeline that takes some amount of time to complete.\nuint64_t Steam::addRangeTimelineEvent(const String &title, const String &description, const String &icon, uint32 icon_priority, float start_offset_seconds, float duration, TimelineEventClipPriority possible_clip){\n\tERR_FAIL_COND_V_MSG(SteamTimeline() == NULL, 0, \"[STEAM] Timeline class not found when calling: addRangeTimelineEvent\");\n\treturn (uint64_t)SteamTimeline()->AddRangeTimelineEvent(title.utf8().get_data(), description.utf8().get_data(), icon.utf8().get_data(), icon_priority, start_offset_seconds, duration, (ETimelineEventClipPriority)possible_clip);\n}\n\n// Removes the description set for the specific clip.\nvoid Steam::clearTimelineTooltip(float time_delta) {\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: clearTimelineTooltip\");\n\tSteamTimeline()->ClearTimelineTooltip(time_delta);\t\t\n}\n\n// Add a tag to whatever time range is represented by the event.\nvoid Steam::doesEventRecordingExist(uint64_t this_event){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: doesEventRecordingExist\");\n\tSteamAPICall_t api_call = SteamTimeline()->DoesEventRecordingExist(this_event);\n\tcallResultTimelineEvenRecordingExists.Set(api_call, this, &Steam::timeline_event_recording_exists);\n}\n\n// Use this to determine if video recordings exist for the specified game phase. Steam will sent a timeline_game_phase_recording_exists callback with the result.\n// This can be useful when the game needs to decide whether or not to show a control that will call openOverlayToGamePhase.\nvoid Steam::doesGamePhaseRecordingExist(const String &phase_id){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: doesGamePhaseRecordingExist\");\n\tSteamAPICall_t api_call = SteamTimeline()->DoesGamePhaseRecordingExist(phase_id.utf8().get_data());\n\tcallResultTimelineGamePhaseRecordingExists.Set(api_call, this, &Steam::timeline_game_phase_recording_exists);\n}\n\n// Use this to end a game phase that was started with startGamePhase.\nvoid Steam::endGamePhase(){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: endGamePhase\");\n\tSteamTimeline()->EndGamePhase();\n}\n\n// Ends a range timeline event and shows it in the UI.\nvoid Steam::endRangeTimelineEvent(uint64_t this_event, float end_offset_seconds){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: endRangeTimelineEvent\");\n\tSteamTimeline()->EndRangeTimelineEvent(this_event, end_offset_seconds);\n}\n\n// Opens the Steam overlay to a game phase.\nvoid Steam::openOverlayToGamePhase(const String &phase_id){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: openOverlayToGamePhase\");\n\tSteamTimeline()->OpenOverlayToGamePhase(phase_id.utf8().get_data());\n}\n\n// Opens the Steam overlay to a timeline event.\nvoid Steam::openOverlayToTimelineEvent(const uint64_t this_event){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: openOverlayToTimelineEvent\");\n\tSteamTimeline()->OpenOverlayToTimelineEvent(this_event);\n}\n\n// Delete the event from the timeline. This can be called on a timeline event from AddInstantaneousTimelineEvent,\n// AddRangeTimelineEvent, or StartRangeTimelineEvent/EndRangeTimelineEvent. The timeline event handle must be from the\n// current game process.\nvoid Steam::removeTimelineEvent(uint64_t this_event){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: removeTimelineEvent\");\n\tSteamTimeline()->RemoveTimelineEvent(this_event);\n}\n\n// Add a text attribute that applies to the entire phase.\nvoid Steam::setGamePhaseAttribute(const String &attribute_group, const String &attribute_value, uint32 priority){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: setGamePhaseAttribute\");\n\tSteamTimeline()->SetGamePhaseAttribute(attribute_group.utf8().get_data(), attribute_value.utf8().get_data(), priority);\n}\n\n// Games can set a phase ID so they can refer back to a phase in OpenOverlayToPhase.\nvoid Steam::setGamePhaseID(const String &phase_id){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: setGamePhaseID\");\n\tSteamTimeline()->SetGamePhaseID(phase_id.utf8().get_data());\n}\n\n// Changes the color of the timeline bar. See ETimelineGameMode comments for how to use each value\nvoid Steam::setTimelineGameMode(TimelineGameMode mode){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: setTimelineGameMode\");\n\tSteamTimeline()->SetTimelineGameMode((ETimelineGameMode)mode);\n}\n\n// Sets a description for the current game state in the timeline. These help the user to find specific\n// moments in the timeline when saving clips. Setting a new state description replaces any previous description.\nvoid Steam::setTimelineTooltip(String description, float time_delta){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: setTimelineTooltip\");\n\tSteamTimeline()->SetTimelineTooltip(description.utf8().get_data(), time_delta);\n}\n\n// Use this to start a game phase. Game phases allow the user to navigate their background recordings and clips. Exactly what a game phase means will vary game to game, but the game phase\n// should be a section of gameplay that is usually between 10 minutes and a few hours in length, and should be the main way a user would think to divide up the game. These are presented to\n// the user in a UI that shows the date the game was played, with one row per game slice. Game phases should be used to mark sections of gameplay that the user might be interested in watching.\nvoid Steam::startGamePhase(){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: startGamePhase\");\n\tSteamTimeline()->StartGamePhase();\n}\n\n// Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with EndRangeTimelineEvent.\n// Any timeline events that have not been ended when the game exits will be discarded.\nuint64_t Steam::startRangeTimelineEvent(const String &title, const String &description, const String &icon, uint32 priority, float start_offset_seconds, TimelineEventClipPriority possible_clip){\n\tERR_FAIL_COND_V_MSG(SteamTimeline() == NULL, 0, \"[STEAM] Timeline class not found when calling: startRangeTimelineEvent\");\n\treturn (uint64_t)SteamTimeline()->StartRangeTimelineEvent(title.utf8().get_data(), description.utf8().get_data(), icon.utf8().get_data(), priority, start_offset_seconds, (ETimelineEventClipPriority)possible_clip);\n}\n\n// Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.\nvoid Steam::updateRangeTimelineEvent(uint64_t this_event, const String &title, const String &description, const String &icon, uint32 priority, TimelineEventClipPriority possible_clip){\n\tERR_FAIL_COND_MSG(SteamTimeline() == NULL, \"[STEAM] Timeline class not found when calling: updateRangeTimelineEvent\");\n\tSteamTimeline()->UpdateRangeTimelineEvent(this_event, title.utf8().get_data(), description.utf8().get_data(), icon.utf8().get_data(), priority, (ETimelineEventClipPriority)possible_clip);\n}\n\n\n///// UGC\n\n// Adds a dependency between the given item and the appid. This list of dependencies can be retrieved by calling GetAppDependencies.\n// This is a soft-dependency that is displayed on the web. It is up to the application to determine whether the item can actually\n// be used or not.\nvoid Steam::addAppDependency(uint64_t published_file_id, uint32_t app_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: addAppDependency\");\n\tSteamAPICall_t api_call = SteamUGC()->AddAppDependency((PublishedFileId_t)published_file_id, (AppId_t)app_id);\n\tcallResultAddAppDependency.Set(api_call, this, &Steam::add_app_dependency_result);\n}\n\nbool Steam::addContentDescriptor(uint64_t update_handle, int descriptor_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addContentDescriptor\");\n\treturn SteamUGC()->AddContentDescriptor((UGCUpdateHandle_t)update_handle, (EUGCContentDescriptorID)descriptor_id);\n}\n\n// Adds a workshop item as a dependency to the specified item. If the nParentPublishedFileID item is of type\n// k_EWorkshopFileTypeCollection, than the nChildPublishedFileID is simply added to that collection.\n// Otherwise, the dependency is a soft one that is displayed on the web and can be retrieved via the ISteamUGC API using a\n// combination of the m_unNumChildren member variable of the SteamUGCDetails_t struct and GetQueryUGCChildren.\nvoid Steam::addDependency(uint64_t published_file_id, uint64_t child_published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: addDependency\");\n\tSteamAPICall_t api_call = SteamUGC()->AddDependency((PublishedFileId_t)published_file_id, (PublishedFileId_t)child_published_file_id);\n\tcallResultAddUGCDependency.Set(api_call, this, &Steam::add_ugc_dependency_result);\n}\n\n// Adds a excluded tag to a pending UGC Query. This will only return UGC without the specified tag.\nbool Steam::addExcludedTag(uint64_t query_handle, const String &tag_name) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addExcludedTag\");\n\treturn SteamUGC()->AddExcludedTag((UGCQueryHandle_t)query_handle, tag_name.utf8().get_data());\n}\n\n// Adds a key-value tag pair to an item. Keys can map to multiple different values (1-to-many relationship).\nbool Steam::addItemKeyValueTag(uint64_t update_handle, const String &key, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addItemKeyValueTag\");\n\treturn SteamUGC()->AddItemKeyValueTag((UGCUpdateHandle_t)update_handle, key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Adds an additional preview file for the item.\nbool Steam::addItemPreviewFile(uint64_t query_handle, const String &preview_file, ItemPreviewType type) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addItemPreviewFile\");\n\treturn SteamUGC()->AddItemPreviewFile((UGCQueryHandle_t)query_handle, preview_file.utf8().get_data(), (EItemPreviewType)type);\n}\n\n// Adds an additional video preview from YouTube for the item.\nbool Steam::addItemPreviewVideo(uint64_t query_handle, const String &video_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addItemPreviewVideo\");\n\treturn SteamUGC()->AddItemPreviewVideo((UGCQueryHandle_t)query_handle, video_id.utf8().get_data());\n}\n\n// Adds a workshop item to the users favorites list.\nvoid Steam::addItemToFavorites(uint32_t app_id, uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: addItemToFavorites\");\n\tAppId_t app = (uint32_t)app_id;\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->AddItemToFavorites(app, file_id);\n\tcallResultFavoriteItemListChanged.Set(api_call, this, &Steam::user_favorite_items_list_changed);\n}\n\n// Adds a required key-value tag to a pending UGC Query. This will only return workshop items that have a key = pKey and a\n// value = pValue.\nbool Steam::addRequiredKeyValueTag(uint64_t query_handle, const String &key, const String &value) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addRequiredKeyValueTag\");\n\treturn SteamUGC()->AddRequiredKeyValueTag((UGCQueryHandle_t)query_handle, key.utf8().get_data(), value.utf8().get_data());\n}\n\n// Adds a required tag to a pending UGC Query. This will only return UGC with the specified tag.\nbool Steam::addRequiredTag(uint64_t query_handle, const String &tag_name) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: addRequiredTag\");\n\treturn SteamUGC()->AddRequiredTag((UGCQueryHandle_t)query_handle, tag_name.utf8().get_data());\n}\n\n// Adds the requirement that the returned items from the pending UGC Query have at least one of the tags in the given set (logical\n// \"or\"). For each tag group that is added, at least one tag from each group is required to be on the matching items.\nbool Steam::addRequiredTagGroup(uint64_t query_handle, Array tag_array) {\n\tbool added_tag_group = false;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, added_tag_group, \"[STEAM] UGC class not found when calling: addRequiredTagGroup\");\n\tUGCQueryHandle_t handle = uint64(query_handle);\n\tstd::vector<CharString> string_store(tag_array.size());\n\tstd::vector<const char *> strings(tag_array.size());\n\tuint32 str_count = tag_array.size();\n\tfor (uint32 i = 0; i < str_count; i++) {\n\t\tString str = tag_array[i];\n\t\tstring_store[i] = str.utf8();\n\t\tstrings[i] = string_store[i].get_data();\n\t}\n\tSteamParamStringArray_t tag;\n\ttag.m_nNumStrings = strings.size();\n\ttag.m_ppStrings = strings.data();\n\tadded_tag_group = SteamUGC()->AddRequiredTagGroup(handle, &tag);\n\treturn added_tag_group;\n}\n\n// Lets game servers set a specific workshop folder before issuing any UGC commands.\nbool Steam::initWorkshopForGameServer(uint32_t workshop_depot_id, String folder) {\n\tbool initialized_workshop = false;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, initialized_workshop, \"[STEAM] UGC class not found when calling: initWorkshopForGameServer\");\n\tDepotId_t workshop = (uint32_t)workshop_depot_id;\n\tinitialized_workshop = SteamUGC()->BInitWorkshopForGameServer(workshop, folder.utf8());\n\treturn initialized_workshop;\n}\n\n// Creates a new workshop item with no content attached yet.\nvoid Steam::createItem(uint32 app_id, WorkshopFileType file_type) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: createItem\");\n\tSteamAPICall_t api_call = SteamUGC()->CreateItem((AppId_t)app_id, (EWorkshopFileType)file_type);\n\tcallResultItemCreate.Set(api_call, this, &Steam::item_created);\n}\n\n// Query for all matching UGC. You can use this to list all of the available UGC for your app.\nuint64_t Steam::createQueryAllUGCRequest(UGCQuery query_type, UGCMatchingUGCType matching_type, uint32_t creator_id, uint32_t consumer_id, uint32 page) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: createQueryAllUGCRequest\");\n\tAppId_t creator = (uint32_t)creator_id;\n\tAppId_t consumer = (uint32_t)consumer_id;\n\tUGCQueryHandle_t handle = SteamUGC()->CreateQueryAllUGCRequest((EUGCQuery)query_type, (EUGCMatchingUGCType)matching_type, creator, consumer, page);\n\treturn (uint64_t)handle;\n}\n\n// Query for the details of specific workshop items.\nuint64_t Steam::createQueryUGCDetailsRequest(Array published_file_ids) {\n\tuint64_t this_handle = 0;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, this_handle, \"[STEAM] UGC class not found when calling: createQueryUGCDetailsRequest\");\n\tuint32 file_count = published_file_ids.size();\n\tif (file_count != 0) {\n\t\tPublishedFileId_t *file_ids = new PublishedFileId_t[file_count];\n\t\tfor (uint32 i = 0; i < file_count; i++) {\n\t\t\tfile_ids[i] = (uint64_t)published_file_ids[i];\n\t\t}\n\t\tUGCQueryHandle_t handle = SteamUGC()->CreateQueryUGCDetailsRequest(file_ids, file_count);\n\t\tdelete[] file_ids;\n\t\tthis_handle = (uint64_t)handle;\n\t}\n\treturn this_handle;\n}\n\n// Query UGC associated with a user. You can use this to list the UGC the user is subscribed to amongst other things.\nuint64_t Steam::createQueryUserUGCRequest(uint64_t steam_id, UserUGCList list_type, UGCMatchingUGCType matching_ugc_type, UserUGCListSortOrder sort_order, uint32_t creator_id, uint32_t consumer_id, uint32 page) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: createQueryUGCDetailsRequest\");\n\t// Get tue universe ID from the Steam ID\n\tCSteamID user_id = (uint64)steam_id;\n\tAccountID_t account = (AccountID_t)user_id.ConvertToUint64();\n\tAppId_t creator = (int)creator_id;\n\tAppId_t consumer = (int)consumer_id;\n\tUGCQueryHandle_t handle = SteamUGC()->CreateQueryUserUGCRequest(account, (EUserUGCList)list_type, (EUGCMatchingUGCType)matching_ugc_type, (EUserUGCListSortOrder)sort_order, creator, consumer, page);\n\treturn (uint64_t)handle;\n}\n\n// Deletes the item without prompting the user.\nvoid Steam::deleteItem(uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: deleteItem\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->DeleteItem(file_id);\n\tcallResultDeleteItem.Set(api_call, this, &Steam::item_deleted);\n}\n\n// Download new or update already installed item. If returns true, wait for DownloadItemResult_t. If item is already installed,\n// then files on disk should not be used until callback received.\n// If item is not subscribed to, it will be cached for some time. If bHighPriority is set, any other item download will be\n// suspended and this item downloaded ASAP.\nbool Steam::downloadItem(uint64_t published_file_id, bool high_priority) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: downloadItem\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\treturn SteamUGC()->DownloadItem(file_id, high_priority);\n}\n\n// Returns any app dependencies that are associated with the given item.\nvoid Steam::getAppDependencies(uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: getAppDependencies\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->GetAppDependencies(file_id);\n\tcallResultGetAppDependencies.Set(api_call, this, &Steam::get_app_dependencies_result);\n}\n\n// Get info about a pending download of a workshop item that has k_EItemStateNeedsUpdate set.\nDictionary Steam::getItemDownloadInfo(uint64_t published_file_id) {\n\tDictionary info;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, info, \"[STEAM] UGC class not found when calling: getItemDownloadInfo\");\n\tuint64 downloaded = 0;\n\tuint64 total = 0;\n\tinfo[\"ret\"] = SteamUGC()->GetItemDownloadInfo((PublishedFileId_t)published_file_id, &downloaded, &total);\n\tif (info[\"ret\"]) {\n\t\tinfo[\"downloaded\"] = uint64_t(downloaded);\n\t\tinfo[\"total\"] = uint64_t(total);\n\t}\n\treturn info;\n}\n\n// Gets info about currently installed content on the disc for workshop items that have k_EItemStateInstalled set.\nDictionary Steam::getItemInstallInfo(uint64_t published_file_id) {\n\tDictionary info;\n\tinfo[\"ret\"] = false;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, info, \"[STEAM] UGC class not found when calling: getItemInstallInfo\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tuint64 size_on_disk;\n\tchar folder[1024] = { 0 };\n\tuint32 time_stamp;\n\tinfo[\"ret\"] = SteamUGC()->GetItemInstallInfo((PublishedFileId_t)file_id, &size_on_disk, folder, sizeof(folder), &time_stamp);\n\tif (info[\"ret\"]) {\n\t\tinfo[\"size\"] = (uint64_t)size_on_disk;\n\t\tinfo[\"folder\"] = folder;\n\t\tinfo[\"timestamp\"] = time_stamp;\n\t}\n\treturn info;\n}\n\n// Gets the current state of a workshop item on this client.\nuint32 Steam::getItemState(uint64_t published_file_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getItemState\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\treturn SteamUGC()->GetItemState(file_id);\n}\n\n// Gets the progress of an item update.\nDictionary Steam::getItemUpdateProgress(uint64_t update_handle) {\n\tDictionary update_progress;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, update_progress, \"[STEAM] UGC class not found when calling: getItemUpdateProgress\");\n\tUGCUpdateHandle_t handle = (uint64_t)update_handle;\n\tuint64 processed = 0;\n\tuint64 total = 0;\n\tEItemUpdateStatus status = SteamUGC()->GetItemUpdateProgress(handle, &processed, &total);\n\tupdate_progress[\"status\"] = status;\n\tupdate_progress[\"processed\"] = uint64_t(processed);\n\tupdate_progress[\"total\"] = uint64_t(total);\n\treturn update_progress;\n}\n\n// Gets the total number of items the current user is subscribed to for the game or application.\nuint32 Steam::getNumSubscribedItems() {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getNumSubscribedItems\");\n\treturn SteamUGC()->GetNumSubscribedItems();\n}\n\n// Get the number of supported game versions for this UGC content.\nuint32 Steam::getNumSupportedGameVersions(uint64_t query_handle, uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getNumSupportedGameVersions\");\n\treturn SteamUGC()->GetNumSupportedGameVersions((UGCQueryHandle_t)query_handle, index);\n}\n\n// Retrieve the details of an additional preview associated with an individual workshop item after receiving a querying UGC call\n// result.\nDictionary Steam::getQueryUGCAdditionalPreview(uint64_t query_handle, uint32 index, uint32 preview_index) {\n\tDictionary preview;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, preview, \"[STEAM] UGC class not found when calling: getQueryUGCAdditionalPreview\");\n\tchar url_or_video_id[256 + 1]{};\n\tchar original_filename[256 + 1]{};\n\tEItemPreviewType previewType;\n\tbool success = SteamUGC()->GetQueryUGCAdditionalPreview((UGCQueryHandle_t)query_handle, index, preview_index, url_or_video_id, 256, original_filename, 256, &previewType);\n\tif (success) {\n\t\tpreview[\"success\"] = success;\n\t\tpreview[\"handle\"] = query_handle;\n\t\tpreview[\"index\"] = index;\n\t\tpreview[\"preview\"] = preview_index;\n\t\tpreview[\"urlOrVideo\"] = url_or_video_id;\n\t\tpreview[\"filename\"] = original_filename;\n\t\tpreview[\"type\"] = previewType;\n\t}\n\treturn preview;\n}\n\n// Retrieve the ids of any child items of an individual workshop item after receiving a querying UGC call result. These items can\n// either be a part of a collection or some other dependency (see AddDependency).\nDictionary Steam::getQueryUGCChildren(uint64_t query_handle, uint32 index, uint32_t child_count) {\n\tDictionary children;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, children, \"[STEAM] UGC class not found when calling: getQueryUGCChildren\");\n\tPackedVector2Array vec;\n\tvec.resize(child_count);\n\tbool success = SteamUGC()->GetQueryUGCChildren((UGCQueryHandle_t)query_handle, index, (PublishedFileId_t *)vec.ptrw(), child_count);\n\tif (success) {\n\t\tArray godot_arr;\n\t\tgodot_arr.resize(child_count);\n\t\tfor (uint32_t i = 0; i < child_count; i++) {\n\t\t\tgodot_arr[i] = vec[i];\n\t\t}\n\n\t\tchildren[\"success\"] = success;\n\t\tchildren[\"handle\"] = query_handle;\n\t\tchildren[\"index\"] = index;\n\t\tchildren[\"children\"] = godot_arr;\n\t}\n\treturn children;\n}\n\nDictionary Steam::getQueryUGCContentDescriptors(uint64_t query_handle, uint32 index, uint32_t max_entries) {\n\tDictionary descriptors;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, descriptors, \"[STEAM] UGC class not found when calling: getQueryUGCContentDescriptors\");\n\tPackedVector2Array vec;\n\tvec.resize(max_entries);\n\tuint32_t result = SteamUGC()->GetQueryUGCContentDescriptors((UGCQueryHandle_t)query_handle, index, (EUGCContentDescriptorID *)vec.ptrw(), max_entries);\n\tArray descriptor_array;\n\tdescriptor_array.resize(max_entries);\n\tfor (uint32_t i = 0; i < max_entries; i++) {\n\t\tdescriptor_array[i] = vec[i];\n\t}\n\tdescriptors[\"result\"] = result;\n\tdescriptors[\"handle\"] = query_handle;\n\tdescriptors[\"index\"] = index;\n\tdescriptors[\"descriptors\"] = descriptor_array;\n\treturn descriptors;\n}\n\n// Retrieve the details of a key-value tag associated with an individual workshop item after receiving a querying UGC call result.\nDictionary Steam::getQueryUGCKeyValueTag(uint64_t query_handle, uint32 index, uint32 key_value_tag_index) {\n\tDictionary tag;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, tag, \"[STEAM] UGC class not found when calling: getQueryUGCKeyValueTag\");\n\tchar key[256 + 1]{};\n\tchar value[256 + 1]{};\n\tbool success = SteamUGC()->GetQueryUGCKeyValueTag((UGCQueryHandle_t)query_handle, index, key_value_tag_index, key, 256, value, 256);\n\tif (success) {\n\t\ttag[\"success\"] = success;\n\t\ttag[\"handle\"] = query_handle;\n\t\ttag[\"index\"] = index;\n\t\ttag[\"tag\"] = key_value_tag_index;\n\t\ttag[\"key\"] = key;\n\t\ttag[\"value\"] = value;\n\t}\n\treturn tag;\n}\n\n// Retrieve the developer set metadata of an individual workshop item after receiving a querying UGC call result.\nString Steam::getQueryUGCMetadata(uint64_t query_handle, uint32 index) {\n\tString query_ugc_metadata = \"\";\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, query_ugc_metadata, \"[STEAM] UGC class not found when calling: getQueryUGCMetadata\");\n\tchar ugc_metadata[5000 + 1]{};\n\tbool success = SteamUGC()->GetQueryUGCMetadata((UGCQueryHandle_t)query_handle, index, ugc_metadata, 5000);\n\tif (success) {\n\t\tquery_ugc_metadata = ugc_metadata;\n\t}\n\treturn query_ugc_metadata;\n}\n\n// Retrieve the number of additional previews of an individual workshop item after receiving a querying UGC call result.\nuint32 Steam::getQueryUGCNumAdditionalPreviews(uint64_t query_handle, uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getQueryUGCNumAdditionalPreviews\");\n\treturn SteamUGC()->GetQueryUGCNumAdditionalPreviews((UGCQueryHandle_t)query_handle, index);\n}\n\n// Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.\nuint32 Steam::getQueryUGCNumKeyValueTags(uint64_t query_handle, uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getQueryUGCNumKeyValueTags\");\n\treturn SteamUGC()->GetQueryUGCNumKeyValueTags((UGCQueryHandle_t)query_handle, index);\n}\n\n// Retrieve the number of tags for an individual workshop item after receiving a querying UGC call result. You should call this in\n// a loop to get the details of all the workshop items returned.\nuint32 Steam::getQueryUGCNumTags(uint64_t query_handle, uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: getQueryUGCNumTags\");\n\treturn SteamUGC()->GetQueryUGCNumTags((UGCQueryHandle_t)query_handle, index);\n}\n\n// Retrieve the URL to the preview image of an individual workshop item after receiving a querying UGC call result.\nString Steam::getQueryUGCPreviewURL(uint64_t query_handle, uint32 index) {\n\tString query_ugc_preview_url = \"\";\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, query_ugc_preview_url, \"[STEAM] UGC class not found when calling: getQueryUGCPreviewURL\");\n\tchar url[256 + 1]{};\n\tbool success = SteamUGC()->GetQueryUGCPreviewURL((UGCQueryHandle_t)query_handle, index, url, 256);\n\tif (success) {\n\t\tquery_ugc_preview_url = url;\n\t}\n\treturn query_ugc_preview_url;\n}\n\n// Retrieve the details of an individual workshop item after receiving a querying UGC call result.\nDictionary Steam::getQueryUGCResult(uint64_t query_handle, uint32 index) {\n\tDictionary ugc_result;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, ugc_result, \"[STEAM] UGC class not found when calling: getQueryUGCResult\");\n\tSteamUGCDetails_t query_details;\n\tbool success = SteamUGC()->GetQueryUGCResult((UGCQueryHandle_t)query_handle, index, &query_details);\n\tif (success) {\n\t\tugc_result[\"result\"] = (uint64_t)query_details.m_eResult;\n\t\tugc_result[\"file_id\"] = (uint64_t)query_details.m_nPublishedFileId;\n\t\tugc_result[\"file_type\"] = (uint64_t)query_details.m_eFileType;\n\t\tugc_result[\"creator_app_id\"] = (uint32_t)query_details.m_nCreatorAppID;\n\t\tugc_result[\"consumer_app_id\"] = (uint32_t)query_details.m_nConsumerAppID;\n\t\tugc_result[\"title\"] = String::utf8(query_details.m_rgchTitle);\n\t\tugc_result[\"description\"] = String::utf8(query_details.m_rgchDescription);\n\t\tugc_result[\"steam_id_owner\"] = (uint64_t)query_details.m_ulSteamIDOwner;\n\t\tugc_result[\"time_created\"] = query_details.m_rtimeCreated;\n\t\tugc_result[\"time_updated\"] = query_details.m_rtimeUpdated;\n\t\tugc_result[\"time_added_to_user_list\"] = query_details.m_rtimeAddedToUserList;\n\t\tugc_result[\"visibility\"] = (uint64_t)query_details.m_eVisibility;\n\t\tugc_result[\"banned\"] = query_details.m_bBanned;\n\t\tugc_result[\"accepted_for_use\"] = query_details.m_bAcceptedForUse;\n\t\tugc_result[\"tags_truncated\"] = query_details.m_bTagsTruncated;\n\t\tugc_result[\"tags\"] = query_details.m_rgchTags;\n\t\tugc_result[\"handle_file\"] = (uint64_t)query_details.m_hFile;\n\t\tugc_result[\"handle_preview_file\"] = (uint64_t)query_details.m_hPreviewFile;\n\t\tugc_result[\"file_name\"] = query_details.m_pchFileName;\n\t\tugc_result[\"file_size\"] = query_details.m_nFileSize;\n\t\tugc_result[\"preview_file_size\"] = query_details.m_nPreviewFileSize;\n\t\tugc_result[\"url\"] = query_details.m_rgchURL;\n\t\tugc_result[\"votes_up\"] = query_details.m_unVotesUp;\n\t\tugc_result[\"votes_down\"] = query_details.m_unVotesDown;\n\t\tugc_result[\"score\"] = query_details.m_flScore;\n\t\tugc_result[\"num_children\"] = query_details.m_unNumChildren;\n\t\tugc_result[\"total_files_size\"] = (uint64_t)query_details.m_ulTotalFilesSize;\n\t}\n\treturn ugc_result;\n}\n\n// Retrieve various statistics of an individual workshop item after receiving a querying UGC call result.\nDictionary Steam::getQueryUGCStatistic(uint64_t query_handle, uint32 index, ItemStatistic stat_type) {\n\tDictionary ugc_stat;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, ugc_stat, \"[STEAM] UGC class not found when calling: getQueryUGCStatistic\");\n\tuint64 value = 0;\n\tbool success = SteamUGC()->GetQueryUGCStatistic((UGCQueryHandle_t)query_handle, index, (EItemStatistic)stat_type, &value);\n\tif (success) {\n\t\tugc_stat[\"success\"] = success;\n\t\tugc_stat[\"handle\"] = query_handle;\n\t\tugc_stat[\"index\"] = index;\n\t\tugc_stat[\"type\"] = stat_type;\n\t\tugc_stat[\"value\"] = (uint64_t)value;\n\t}\n\treturn ugc_stat;\n}\n\n// Retrieve the \"nth\" tag associated with an individual workshop item after receiving a querying UGC call result.\n// You should call this in a loop to get the details of all the workshop items returned.\nString Steam::getQueryUGCTag(uint64_t query_handle, uint32 index, uint32 tag_index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, \"\", \"[STEAM] UGC class not found when calling: getQueryUGCTag\");\n\tchar tag[64 + 1]{};\n\tSteamUGC()->GetQueryUGCTag((UGCQueryHandle_t)query_handle, index, tag_index, tag, 64);\n\treturn tag;\n}\n\n// Retrieve the \"nth\" display string (usually localized) for a tag, which is associated with an individual workshop item after\n// receiving a querying UGC call result.\n// You should call this in a loop to get the details of all the workshop items returned.\nString Steam::getQueryUGCTagDisplayName(uint64_t query_handle, uint32 index, uint32 tag_index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, \"\", \"[STEAM] UGC class not found when calling: getQueryUGCTagDisplayName\");\n\tchar tag[256 + 1]{};\n\tSteamUGC()->GetQueryUGCTagDisplayName((UGCQueryHandle_t)query_handle, index, tag_index, tag, 256);\n\treturn tag;\n}\n\n// Gets a list of all of the items the current user is subscribed to for the current game.\nArray Steam::getSubscribedItems() {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, Array(), \"[STEAM] UGC class not found when calling: getSubscribedItems\");\n\tArray subscribed;\n\tuint32 num_items = SteamUGC()->GetNumSubscribedItems();\n\tPublishedFileId_t *items = new PublishedFileId_t[num_items];\n\tuint32 item_list = SteamUGC()->GetSubscribedItems(items, num_items);\n\tfor (uint32 i = 0; i < item_list; i++) {\n\t\tsubscribed.append((uint64_t)items[i]);\n\t}\n\tdelete[] items;\n\treturn subscribed;\n}\n\n// Some items can specify that they have a version that is valid for a range of game versions (Steam branch).\nDictionary Steam::getSupportedGameVersionData(uint64_t query_handle, uint32 index, uint32 version_index) {\n\tDictionary supported_version;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, supported_version, \"[STEAM] UGC class not found when calling: getSupportedGameVersionData\");\n\tchar branch_min[STEAM_BUFFER_SIZE];\n\tchar branch_max[STEAM_BUFFER_SIZE];\n\tuint32 branch_size = 0;\n\tif (SteamUGC()->GetSupportedGameVersionData((UGCQueryHandle_t)query_handle, index, version_index, branch_min, branch_max, branch_size)) {\n\t\tsupported_version[\"min\"] = branch_min;\n\t\tsupported_version[\"max\"] = branch_max;\n\t\tsupported_version[\"size\"] = branch_size;\n\t}\n\treturn supported_version;\n}\n\n// Return the user's community content descriptor preferences\n// Information is unclear how this actually works so here goes nothing!\nArray Steam::getUserContentDescriptorPreferences(uint32 max_entries) {\n\tArray descriptors;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, descriptors, \"[STEAM] UGC class not found when calling: getUserContentDescriptorPreferences\");\n\tEUGCContentDescriptorID *descriptor_list = new EUGCContentDescriptorID[max_entries];\n\tuint32 num_descriptors = SteamUGC()->GetUserContentDescriptorPreferences(descriptor_list, max_entries);\n\tfor (uint32 i = 0; i < num_descriptors; i++) {\n\t\tdescriptors.append(descriptor_list[i]);\n\t}\n\treturn descriptors;\n}\n\n// Gets the users vote status on a workshop item.\nvoid Steam::getUserItemVote(uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: getUserItemVote\");\t\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->GetUserItemVote(file_id);\n\tcallResultGetUserItemVote.Set(api_call, this, &Steam::get_item_vote_result);\n}\n\n// Retrieve information related to the user's acceptance or not of the app's specific Workshop EULA.\nvoid Steam::getWorkshopEULAStatus() {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: subscribeItem\");\n\tSteamAPICall_t api_call = SteamUGC()->GetWorkshopEULAStatus();\n\tcallResultWorkshopEULAStatus.Set(api_call, this, &Steam::workshop_eula_status);\n}\n\n// Releases a UGC query handle when you are done with it to free up memory.\nbool Steam::releaseQueryUGCRequest(uint64_t query_handle) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: releaseQueryUGCRequest\");\n\treturn SteamUGC()->ReleaseQueryUGCRequest((UGCQueryHandle_t)query_handle);\n}\n\n// Removes the dependency between the given item and the appid. This list of dependencies can be retrieved by calling\n// GetAppDependencies.\nvoid Steam::removeAppDependency(uint64_t published_file_id, uint32_t app_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: removeAppDependency\");\t\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tAppId_t app = (uint32_t)app_id;\n\tSteamAPICall_t api_call = SteamUGC()->RemoveAppDependency(file_id, app);\n\tcallResultRemoveAppDependency.Set(api_call, this, &Steam::remove_app_dependency_result);\n}\n\nbool Steam::removeContentDescriptor(uint64_t update_handle, int descriptor_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: removeContentDescriptor\");\n\treturn SteamUGC()->RemoveContentDescriptor((UGCUpdateHandle_t)update_handle, (EUGCContentDescriptorID)descriptor_id);\n}\n\n// Removes a workshop item as a dependency from the specified item.\nvoid Steam::removeDependency(uint64_t published_file_id, uint64_t child_published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: removeDependency\");\t\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tPublishedFileId_t childID = (uint64_t)child_published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->RemoveDependency(file_id, childID);\n\tcallResultRemoveUGCDependency.Set(api_call, this, &Steam::remove_ugc_dependency_result);\n}\n\n// Removes a workshop item from the users favorites list.\nvoid Steam::removeItemFromFavorites(uint32_t app_id, uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: removeItemFromFavorites\");\t\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tAppId_t app = (uint32_t)app_id;\n\tSteamAPICall_t api_call = SteamUGC()->RemoveItemFromFavorites(app, file_id);\n\tcallResultFavoriteItemListChanged.Set(api_call, this, &Steam::user_favorite_items_list_changed);\n}\n\n// Removes an existing key value tag from an item.\nbool Steam::removeItemKeyValueTags(uint64_t update_handle, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: removeItemKeyValueTags\");\n\treturn SteamUGC()->RemoveItemKeyValueTags((UGCUpdateHandle_t)update_handle, key.utf8().get_data());\n}\n\n// Removes an existing preview from an item.\nbool Steam::removeItemPreview(uint64_t update_handle, uint32 index) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: removeItemPreview\");\n\treturn SteamUGC()->RemoveItemPreview((UGCUpdateHandle_t)update_handle, index);\n}\n\n// Send a UGC query to Steam.\nvoid Steam::sendQueryUGCRequest(uint64_t update_handle) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: sendQueryUGCRequest\");\t\n\tSteamAPICall_t api_call = SteamUGC()->SendQueryUGCRequest((UGCUpdateHandle_t)update_handle);\n\tcallResultUGCQueryCompleted.Set(api_call, this, &Steam::ugc_query_completed);\n}\n\n// Admin queries return hidden items.\nbool Steam::setAdminQuery(uint64_t update_handle, bool admin_query) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setAdminQuery\");\n\treturn SteamUGC()->SetAdminQuery((UGCUpdateHandle_t)update_handle, admin_query);\n}\n\n// Sets whether results will be returned from the cache for the specific period of time on a pending UGC Query.\nbool Steam::setAllowCachedResponse(uint64_t update_handle, uint32 max_age_seconds) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setAllowCachedResponse\");\n\treturn SteamUGC()->SetAllowCachedResponse((UGCUpdateHandle_t)update_handle, max_age_seconds);\n}\n\n// Sets to only return items that have a specific filename on a pending UGC Query.\nbool Steam::setCloudFileNameFilter(uint64_t update_handle, const String &match_cloud_filename) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setCloudFileNameFilter\");\n\treturn SteamUGC()->SetCloudFileNameFilter((UGCUpdateHandle_t)update_handle, match_cloud_filename.utf8().get_data());\n}\n\n// Sets the folder that will be stored as the content for an item.\nbool Steam::setItemContent(uint64_t update_handle, const String &content_folder) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemContent\");\n\treturn SteamUGC()->SetItemContent((UGCUpdateHandle_t)update_handle, content_folder.utf8().get_data());\n}\n\n// Sets a new description for an item.\nbool Steam::setItemDescription(uint64_t update_handle, const String &description) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemDescription\");\n\tif ((uint32_t)description.length() > (uint32_t)k_cchPublishedDocumentDescriptionMax) {\n\t\tprintf(\"Description cannot have more than %d ASCII characters. Description not set.\", k_cchPublishedDocumentDescriptionMax);\n\t\treturn false;\n\t}\n\treturn SteamUGC()->SetItemDescription((UGCUpdateHandle_t)update_handle, description.utf8().get_data());\n}\n\n// Sets arbitrary metadata for an item. This metadata can be returned from queries without having to download and install the\n// actual content.\nbool Steam::setItemMetadata(uint64_t update_handle, const String &ugc_metadata) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemMetadata\");\n\tif (ugc_metadata.utf8().length() > 5000) {\n\t\tprintf(\"Metadata cannot be more than %d bytes. Metadata not set.\", 5000);\n\t}\n\treturn SteamUGC()->SetItemMetadata((UGCUpdateHandle_t)update_handle, ugc_metadata.utf8().get_data());\n}\n\n// Sets the primary preview image for the item.\nbool Steam::setItemPreview(uint64_t update_handle, const String &preview_file) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemPreview\");\n\treturn SteamUGC()->SetItemPreview((UGCUpdateHandle_t)update_handle, preview_file.utf8().get_data());\n}\n\n// Sets arbitrary developer specified tags on an item.\nbool Steam::setItemTags(uint64_t update_handle, Array tag_array, bool allow_admin_tags) {\n\tbool tags_set = false;\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemTags\");\n\tstd::vector<CharString> string_store(tag_array.size());\n\tstd::vector<const char *> strings(tag_array.size());\n\tuint32 str_count = tag_array.size();\n\tfor (uint32 i = 0; i < str_count; i++) {\n\t\tString str = tag_array[i];\n\t\tstring_store[i] = str.utf8();\n\t\tstrings[i] = string_store[i].get_data();\n\t}\n\tSteamParamStringArray_t tag;\n\ttag.m_nNumStrings = strings.size();\n\ttag.m_ppStrings = strings.data();\n\ttags_set = SteamUGC()->SetItemTags((UGCUpdateHandle_t)update_handle, &tag, allow_admin_tags);\n\treturn tags_set;\n}\n\n// Sets a new title for an item.\nbool Steam::setItemTitle(uint64_t update_handle, const String &title) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemTitle\");\n\tif (title.length() > 255) {\n\t\tprintf(\"Title cannot have more than %d ASCII characters. Title not set.\", 255);\n\t\treturn false;\n\t}\n\treturn SteamUGC()->SetItemTitle((UGCUpdateHandle_t)update_handle, title.utf8().get_data());\n}\n\n// Sets the language of the title and description that will be set in this item update.\nbool Steam::setItemUpdateLanguage(uint64_t update_handle, const String &language) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemUpdateLanguage\");\n\treturn SteamUGC()->SetItemUpdateLanguage((UGCUpdateHandle_t)update_handle, language.utf8().get_data());\n}\n\n// Sets the visibility of an item.\nbool Steam::setItemVisibility(uint64_t update_handle, RemoteStoragePublishedFileVisibility visibility) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setItemVisibility\");\n\treturn SteamUGC()->SetItemVisibility((UGCUpdateHandle_t)update_handle, (ERemoteStoragePublishedFileVisibility)visibility);\n}\n\n// Sets the language to return the title and description in for the items on a pending UGC Query.\nbool Steam::setLanguage(uint64_t query_handle, const String &language) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setLanguage\");\n\treturn SteamUGC()->SetLanguage((UGCQueryHandle_t)query_handle, language.utf8().get_data());\n}\n\n// Sets whether workshop items will be returned if they have one or more matching tag, or if all tags need to match on a pending\n// UGC Query.\nbool Steam::setMatchAnyTag(uint64_t query_handle, bool match_any_tag) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setMatchAnyTag\");\n\treturn SteamUGC()->SetMatchAnyTag((UGCQueryHandle_t)query_handle, match_any_tag);\n}\n\n// Sets whether the order of the results will be updated based on the rank of items over a number of days on a pending UGC Query.\nbool Steam::setRankedByTrendDays(uint64_t query_handle, uint32 days) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setRankedByTrendDays\");\n\treturn SteamUGC()->SetRankedByTrendDays((UGCQueryHandle_t)query_handle, days);\n}\n\n// An empty string for either parameter means that it will match any version on that end of the range. This will only be applied\n// if the actual content has been changed.\nbool Steam::setRequiredGameVersions(uint64_t query_handle, String game_branch_min, String game_branch_max) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setRequiredGameVersions\");\n\treturn SteamUGC()->SetRequiredGameVersions((UGCQueryHandle_t)query_handle, game_branch_min.utf8().get_data(), game_branch_max.utf8().get_data());\n}\n\n// Sets whether to return any additional images/videos attached to the items on a pending UGC Query.\nbool Steam::setReturnAdditionalPreviews(uint64_t query_handle, bool return_additional_previews) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnAdditionalPreviews\");\n\treturn SteamUGC()->SetReturnAdditionalPreviews((UGCQueryHandle_t)query_handle, return_additional_previews);\n}\n\n// Sets whether to return the IDs of the child items of the items on a pending UGC Query.\nbool Steam::setReturnChildren(uint64_t query_handle, bool return_children) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnChildren\");\n\treturn SteamUGC()->SetReturnChildren((UGCQueryHandle_t)query_handle, return_children);\n}\n\n// Sets whether to return any key-value tags for the items on a pending UGC Query.\nbool Steam::setReturnKeyValueTags(uint64_t query_handle, bool return_key_value_tags) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnKeyValueTags\");\n\treturn SteamUGC()->SetReturnKeyValueTags((UGCQueryHandle_t)query_handle, return_key_value_tags);\n}\n\n// Sets whether to return the full description for the items on a pending UGC Query.\nbool Steam::setReturnLongDescription(uint64_t query_handle, bool return_long_description) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnLongDescription\");\n\treturn SteamUGC()->SetReturnLongDescription((UGCQueryHandle_t)query_handle, return_long_description);\n}\n\n// Sets whether to return the developer specified metadata for the items on a pending UGC Query.\nbool Steam::setReturnMetadata(uint64_t query_handle, bool return_metadata) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnMetadata\");\n\treturn SteamUGC()->SetReturnMetadata((UGCQueryHandle_t)query_handle, return_metadata);\n}\n\n// Sets whether to only return IDs instead of all the details on a pending UGC Query.\nbool Steam::setReturnOnlyIDs(uint64_t query_handle, bool return_only_ids) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnOnlyIDs\");\n\treturn SteamUGC()->SetReturnOnlyIDs((UGCQueryHandle_t)query_handle, return_only_ids);\n}\n\n// Sets whether to return the the playtime stats on a pending UGC Query.\nbool Steam::setReturnPlaytimeStats(uint64_t query_handle, uint32 days) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnPlaytimeStats\");\n\treturn SteamUGC()->SetReturnPlaytimeStats((UGCQueryHandle_t)query_handle, days);\n}\n\n// Sets whether to only return the the total number of matching items on a pending UGC Query.\nbool Steam::setReturnTotalOnly(uint64_t query_handle, bool return_total_only) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setReturnTotalOnly\");\n\treturn SteamUGC()->SetReturnTotalOnly((UGCQueryHandle_t)query_handle, return_total_only);\n}\n\n// Sets a string to that items need to match in either the title or the description on a pending UGC Query.\nbool Steam::setSearchText(uint64_t query_handle, const String &search_text) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setSearchText\");\n\treturn SteamUGC()->SetSearchText((UGCQueryHandle_t)query_handle, search_text.utf8().get_data());\n}\n\n// Set the time range this item was created.\nbool Steam::setTimeCreatedDateRange(uint64_t update_handle, uint32 start, uint32 end) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setTimeCreatedDateRange\");\n\treturn SteamUGC()->SetTimeCreatedDateRange((UGCUpdateHandle_t)update_handle, start, end);\n}\n\n// Set the time range this item was updated.\nbool Steam::setTimeUpdatedDateRange(uint64_t update_handle, uint32 start, uint32 end) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: setTimeUpdatedDateRange\");\n\treturn SteamUGC()->SetTimeUpdatedDateRange((UGCUpdateHandle_t)update_handle, start, end);\n}\n\n// Allows the user to rate a workshop item up or down.\nvoid Steam::setUserItemVote(uint64_t published_file_id, bool vote_up) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: setUserItemVote\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->SetUserItemVote(file_id, vote_up);\n\tcallResultSetUserItemVote.Set(api_call, this, &Steam::set_user_item_vote);\n}\n\n// Show the app's latest Workshop EULA to the user in an overlay window, where they can accept it or not.\nbool Steam::showWorkshopEULA() {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: showWorkshopEULA\");\n\treturn SteamUGC()->ShowWorkshopEULA();\n}\n\n// Starts the item update process.\nuint64_t Steam::startItemUpdate(uint32_t app_id, uint64_t published_file_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, 0, \"[STEAM] UGC class not found when calling: startItemUpdate\");\n\tAppId_t app = (uint32_t)app_id;\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\treturn SteamUGC()->StartItemUpdate(app, file_id);\n}\n\n// Start tracking playtime on a set of workshop items.\nvoid Steam::startPlaytimeTracking(Array published_file_ids) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: startPlaytimeTracking\");\n\tuint32 file_count = published_file_ids.size();\n\tif (file_count > 0) {\n\t\tPublishedFileId_t *file_ids = new PublishedFileId_t[file_count];\n\t\tfor (uint32 i = 0; i < file_count; i++) {\n\t\t\tfile_ids[i] = (uint64_t)published_file_ids[i];\n\t\t}\n\t\tSteamAPICall_t api_call = SteamUGC()->StartPlaytimeTracking(file_ids, file_count);\n\t\tcallResultStartPlaytimeTracking.Set(api_call, this, &Steam::start_playtime_tracking);\n\t\tdelete[] file_ids;\n\t}\n}\n\n// Stop tracking playtime on a set of workshop items.\nvoid Steam::stopPlaytimeTracking(Array published_file_ids) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: stopPlaytimeTracking\");\n\tuint32 file_count = published_file_ids.size();\n\tif (file_count > 0) {\n\t\tPublishedFileId_t *file_ids = new PublishedFileId_t[file_count];\n\t\tArray files;\n\t\tfor (uint32 i = 0; i < file_count; i++) {\n\t\t\tfile_ids[i] = (uint64_t)published_file_ids[i];\n\t\t}\n\t\tSteamAPICall_t api_call = SteamUGC()->StopPlaytimeTracking(file_ids, file_count);\n\t\tcallResultStopPlaytimeTracking.Set(api_call, this, &Steam::stop_playtime_tracking);\n\t\tdelete[] file_ids;\n\t}\n}\n\n// Stop tracking playtime of all workshop items.\nvoid Steam::stopPlaytimeTrackingForAllItems() {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: stopPlaytimeTrackingForAllItems\");\n\tSteamAPICall_t api_call = SteamUGC()->StopPlaytimeTrackingForAllItems();\n\tcallResultStopPlaytimeTracking.Set(api_call, this, &Steam::stop_playtime_tracking);\n}\n\n// Uploads the changes made to an item to the Steam Workshop; to be called after setting your changes.\nvoid Steam::submitItemUpdate(uint64_t update_handle, const String &change_note) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: submitItemUpdate\");\n\tSteamAPICall_t api_call;\n\tif (change_note.length() == 0) {\n\t\tapi_call = SteamUGC()->SubmitItemUpdate((UGCUpdateHandle_t)update_handle, NULL);\n\t}\n\telse {\n\t\tapi_call = SteamUGC()->SubmitItemUpdate((UGCUpdateHandle_t)update_handle, change_note.utf8().get_data());\n\t}\n\tcallResultItemUpdate.Set(api_call, this, &Steam::item_updated);\n}\n\n// Subscribe to a workshop item. It will be downloaded and installed as soon as possible.\nvoid Steam::subscribeItem(uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: subscribeItem\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->SubscribeItem(file_id);\n\tcallResultSubscribeItem.Set(api_call, this, &Steam::subscribe_item);\n}\n\n// SuspendDownloads( true ) will suspend all workshop downloads until SuspendDownloads( false ) is called or the game ends.\nvoid Steam::suspendDownloads(bool suspend) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: suspendDownloads\");\n\tSteamUGC()->SuspendDownloads(suspend);\n}\n\n// Unsubscribe from a workshop item. This will result in the item being removed after the game quits.\nvoid Steam::unsubscribeItem(uint64_t published_file_id) {\n\tERR_FAIL_COND_MSG(SteamUGC() == NULL, \"[STEAM] UGC class not found when calling: unsubscribeItem\");\n\tPublishedFileId_t file_id = (uint64_t)published_file_id;\n\tSteamAPICall_t api_call = SteamUGC()->UnsubscribeItem(file_id);\n\tcallResultUnsubscribeItem.Set(api_call, this, &Steam::unsubscribe_item);\n}\n\n// Updates an existing additional preview file for the item.\nbool Steam::updateItemPreviewFile(uint64_t update_handle, uint32 index, const String &preview_file) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: updateItemPreviewFile\");\n\treturn SteamUGC()->UpdateItemPreviewFile((UGCUpdateHandle_t)update_handle, index, preview_file.utf8().get_data());\n}\n\n// Updates an additional video preview from YouTube for the item.\nbool Steam::updateItemPreviewVideo(uint64_t update_handle, uint32 index, const String &video_id) {\n\tERR_FAIL_COND_V_MSG(SteamUGC() == NULL, false, \"[STEAM] UGC class not found when calling: updateItemPreviewVideo\");\n\treturn SteamUGC()->UpdateItemPreviewVideo((UGCUpdateHandle_t)update_handle, index, video_id.utf8().get_data());\n}\n\n\n///// USERS\n\n// Set the rich presence data for an unsecured game server that the user is playing on. This allows friends to be able to view the\n// game info and join your game.\nvoid Steam::advertiseGame(const String &server_ip, int port) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: advertiseGame\");\n\tCSteamID game_server_id = SteamUser()->GetSteamID();\n\tSteamUser()->AdvertiseGame(game_server_id, getIPFromString(server_ip), port);\n}\n\n// Authenticate the ticket from the entity Steam ID to be sure it is valid and isn't reused.\nBeginAuthSessionResult Steam::beginAuthSession(PackedByteArray ticket, int ticket_size, uint64_t steam_id) {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, BeginAuthSessionResult(-1), \"[STEAM] User class not found when calling: beginAuthSession\");\n\tCSteamID auth_steam_id = createSteamID(steam_id);\n\treturn BeginAuthSessionResult(SteamUser()->BeginAuthSession(ticket.ptr(), ticket_size, auth_steam_id));\n}\n\n// Cancels an auth ticket.\nvoid Steam::cancelAuthTicket(uint32_t auth_ticket) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: cancelAuthTicket\");\n\tSteamUser()->CancelAuthTicket(auth_ticket);\n}\n\n// Decodes the compressed voice data returned by GetVoice.\nDictionary Steam::decompressVoice(const PackedByteArray &voice, uint32 sample_rate, uint32 buffer_size_override) {\n\tDictionary decompressed;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, decompressed, \"[STEAM] User class not found when calling: decompressVoice\");\n\tuint32 written = 0;\n\tPackedByteArray output_buffer;\n\toutput_buffer.resize(buffer_size_override);\n\n\tint result = SteamUser()->DecompressVoice(voice.ptr(), voice.size(), output_buffer.ptrw(), output_buffer.size(), &written, sample_rate);\n\tdecompressed[\"result\"] = result;\n\tdecompressed[\"size\"] = written;\n\tdecompressed[\"uncompressed\"] = output_buffer;\n\treturn decompressed;\n}\n\n// Ends an auth session.\nvoid Steam::endAuthSession(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: endAuthSession\");\n\tCSteamID auth_steam_id = createSteamID(steam_id);\n\tSteamUser()->EndAuthSession(auth_steam_id);\n}\n\n// Get the authentication ticket data.\nDictionary Steam::getAuthSessionTicket(uint64_t remote_steam_id) {\n\tDictionary auth_ticket;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, auth_ticket, \"[STEAM] User class not found when calling: getAuthSessionTicket\");\n\tuint32_t id = 0;\n\tuint32_t ticket_size = 1024;\n\tPackedByteArray buffer;\n\tbuffer.resize(ticket_size);\n\tif (remote_steam_id != 0) {\n\t\tSteamNetworkingIdentity auth_identity = getIdentityFromSteamID(remote_steam_id);\n\t\tid = SteamUser()->GetAuthSessionTicket(buffer.ptrw(), ticket_size, &ticket_size, &auth_identity);\n\t}\n\telse {\n\t\tid = SteamUser()->GetAuthSessionTicket(buffer.ptrw(), ticket_size, &ticket_size, NULL);\n\t}\n\tauth_ticket[\"id\"] = id;\n\tauth_ticket[\"buffer\"] = buffer;\n\tauth_ticket[\"size\"] = ticket_size;\n\treturn auth_ticket;\n}\n\n// Request a ticket which will be used for webapi \"ISteamUserAuth\\AuthenticateUserTicket\" pchIdentity is an optional input\n// parameter to identify the service the ticket will be sent to the ticket will be returned in callback GetTicketForWebApiResponse_t\nuint32 Steam::getAuthTicketForWebApi(const String &service_identity) {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 0, \"[STEAM] User class not found when calling: getAuthTicketForWebApi\");\n\tif (service_identity != \"\") {\n\t\treturn SteamUser()->GetAuthTicketForWebApi(service_identity.utf8().get_data());\n\t}\n\telse {\n\t\treturn SteamUser()->GetAuthTicketForWebApi(NULL);\n\t}\n}\n\n// Checks to see if there is captured audio data available from GetVoice, and gets the size of the data.\nDictionary Steam::getAvailableVoice() {\n\tDictionary voice_data;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, voice_data, \"[STEAM] User class not found when calling: getAvailableVoice\");\n\tuint32 bytes_available = 0;\n\tint result = SteamUser()->GetAvailableVoice(&bytes_available, NULL, 0);\n\t\n\tvoice_data[\"result\"] = result;\n\tvoice_data[\"buffer\"] = bytes_available;\n\treturn voice_data;\n}\n\n// Dictionary Steam::getDecompressedVoice(uint32 buffer_in_size_override, uint32 buffer_out_size_override, uint32 sample_rate_override) {\n// \tDictionary voice_data;\n// \tERR_FAIL_COND_V_MSG(SteamUser() == NULL, voice_data, \"[STEAM] User class not found when calling: getDecompressedVoice\");\n// \tuint32 buffer_size = buffer_in_size_override;\n// \tif (buffer_size == 0) {\n// \t\tSteamUser()->GetAvailableVoice(&buffer_size);\n// \t}\n\n// \tvoid *buffer = new uint8[buffer_size];\n\n// \tuint32 compressed_written = 0;\n// \tEVoiceResult compressed_result = SteamUser()->GetVoice(true, buffer, buffer_size, &compressed_written);\n\n// \tuint32 sample_rate = sample_rate_override;\n// \tif (sample_rate == 0) {\n// \t\tsample_rate = SteamUser()->GetVoiceOptimalSampleRate();\n// \t}\n\n// \tPackedByteArray output_buffer;\n// \toutput_buffer.resize(buffer_out_size_override);\n\n// \tuint32 output_written = 0;\t\t\n// \tint result = SteamUser()->DecompressVoice(buffer, compressed_written, output_buffer.ptrw(), output_buffer.size(), &output_written, sample_rate);\n// \tif (result == k_EVoiceResultBufferTooSmall) {\n// \t\toutput_buffer.resize(output_written);\n// \t}\n// \tdelete[] buffer;\n\n// \tvoice_data[\"compressed_result\"] = compressed_result;\n// \tvoice_data[\"compressed_written\"] = compressed_written;\n// \tvoice_data[\"output_result\"] = result;\n// \tvoice_data[\"output_buffer\"] = output_buffer;\n// \tvoice_data[\"output_written\"] = output_written;\n// \treturn voice_data;\n// }\n\n// Retrieves anti indulgence / duration control for current user / game combination.\nvoid Steam::getDurationControl() {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: getDurationControl\");\n\tSteamAPICall_t api_call = SteamUser()->GetDurationControl();\n\tcallResultDurationControl.Set(api_call, this, &Steam::duration_control);\n}\n\n// Retrieve an encrypted ticket. This should be called after requesting an encrypted app ticket with RequestEncryptedAppTicket and\n// receiving the EncryptedAppTicketResponse_t call result.\nDictionary Steam::getEncryptedAppTicket() {\n\tDictionary encrypted;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, encrypted, \"[STEAM] User class not found when calling: getEncryptedAppTicket\");\n\tuint32_t ticket_size = 1024;\n\tPackedByteArray buffer;\n\tbuffer.resize(ticket_size);\n\tif (SteamUser()->GetEncryptedAppTicket(buffer.ptrw(), ticket_size, &ticket_size)) {\n\t\tencrypted[\"buffer\"] = buffer;\n\t\tencrypted[\"size\"] = ticket_size;\n\t}\n\treturn encrypted;\n}\n\n// Trading Card badges data access, if you only have one set of cards, the series will be 1.\n// The user has can have two different badges for a series; the regular (max level 5) and the foil (max level 1).\nint Steam::getGameBadgeLevel(int series, bool foil) {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 0, \"[STEAM] User class not found when calling: getGameBadgeLevel\");\n\treturn SteamUser()->GetGameBadgeLevel(series, foil);\n}\n\n// Get the user's Steam level.\nint Steam::getPlayerSteamLevel() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 0, \"[STEAM] User class not found when calling: getPlayerSteamLevel\");\n\treturn SteamUser()->GetPlayerSteamLevel();\n}\n\n// Get user's Steam ID.\nuint64_t Steam::getSteamID() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 0, \"[STEAM] User class not found when calling: getSteamID\");\n\tCSteamID steam_id = SteamUser()->GetSteamID();\n\treturn steam_id.ConvertToUint64();\n}\n\n// Read captured audio data from the microphone buffer.\nDictionary Steam::getVoice(uint32 buffer_size_override) {\n\tDictionary voice_data;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, voice_data, \"[STEAM] User class not found when calling: getVoice\");\n\tuint32 buffer_size = buffer_size_override;\n\tif (buffer_size == 0) {\n\t\tSteamUser()->GetAvailableVoice(&buffer_size);\t\t\t\n\t}\n\n\tPackedByteArray buffer = PackedByteArray();\n\tbuffer.resize(buffer_size);\n\n\tuint32 written = 0;\n\tint result = SteamUser()->GetVoice(true, buffer.ptrw(), buffer_size, &written, false, NULL, 0, NULL, 0);\n\tbuffer.resize(written);\n\n\tvoice_data[\"result\"] = result;\n\tvoice_data[\"buffer\"] = buffer;\n\tvoice_data[\"written\"] = written;\n\treturn voice_data;\n}\n\n// Gets the native sample rate of the Steam voice decoder.\nuint32 Steam::getVoiceOptimalSampleRate() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 0, \"[STEAM] User class not found when calling: getVoiceOptimalSampleRate\");\n\treturn SteamUser()->GetVoiceOptimalSampleRate();\n}\n\n// This starts the state machine for authenticating the game client with the game server. It is the client portion of a three-way\n// handshake between the client, the game server, and the steam servers.\nDictionary Steam::initiateGameConnection(uint64_t server_id, String server_ip, uint16 server_port, bool secure) {\n\tDictionary connection;\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, connection, \"[STEAM] User class not found when calling: initiateGameConnection\");\n\tPackedByteArray auth;\n\tint auth_size = 2048;\n\tauth.resize(auth_size);\n\tCSteamID server = (uint64)server_id;\n\tif (SteamUser()->InitiateGameConnection_DEPRECATED(&auth, auth_size, server, getIPFromString(server_ip), server_port, secure) > 0) {\n\t\tconnection[\"auth_blob\"] = auth;\n\t\tconnection[\"server_id\"] = server_id;\n\t\tconnection[\"server_ip\"] = server_ip;\n\t\tconnection[\"server_port\"] = server_port;\n\t}\n\treturn connection;\n}\n\n// Checks if the current users looks like they are behind a NAT device.\nbool Steam::isBehindNAT() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: isBehindNAT\");\n\treturn SteamUser()->BIsBehindNAT();\n}\n\n// Checks whether the user's phone number is used to uniquely identify them.\nbool Steam::isPhoneIdentifying() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: isPhoneIdentifying\");\n\treturn SteamUser()->BIsPhoneIdentifying();\n}\n\n// Checks whether the current user's phone number is awaiting (re)verification.\nbool Steam::isPhoneRequiringVerification() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: isPhoneRequiringVerification\");\n\treturn SteamUser()->BIsPhoneRequiringVerification();\n}\n\n// Checks whether the current user has verified their phone number.\nbool Steam::isPhoneVerified() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: isPhoneVerified\");\n\treturn SteamUser()->BIsPhoneVerified();\n}\n\n// Checks whether the current user has Steam Guard two factor authentication enabled on their account.\nbool Steam::isTwoFactorEnabled() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: isTwoFactorEnabled\");\n\treturn SteamUser()->BIsTwoFactorEnabled();\n}\n\n// Check, true/false, if user is logged into Steam currently.\nbool Steam::loggedOn() {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: loggedOn\");\n\treturn SteamUser()->BLoggedOn();\n}\n\n// Requests an application ticket encrypted with the secret \"encrypted app ticket key\".\nvoid Steam::requestEncryptedAppTicket(const String &secret) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: requestEncryptedAppTicket\");\n\tauto secret_utf8 = secret.utf8();\n\tSteamAPICall_t api_call = SteamUser()->RequestEncryptedAppTicket((void *)secret_utf8.get_data(), secret_utf8.size());\n\tcallResultEncryptedAppTicketResponse.Set(api_call, this, &Steam::encrypted_app_ticket_response);\n}\n\n// Requests a URL which authenticates an in-game browser for store check-out, and then redirects to the specified URL.\nvoid Steam::requestStoreAuthURL(const String &redirect) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: requestStoreAuthURL\");\n\tSteamAPICall_t api_call = SteamUser()->RequestStoreAuthURL(redirect.utf8().get_data());\n\tcallResultStoreAuthURLResponse.Set(api_call, this, &Steam::store_auth_url_response);\n}\n\n// Starts voice recording.\nvoid Steam::startVoiceRecording() {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: startVoiceRecording\");\n\tSteamUser()->StartVoiceRecording();\n}\n\n//\nbool Steam::setDurationControlOnlineState(int new_state) {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, false, \"[STEAM] User class not found when calling: setDurationControlOnlineState\");\n\treturn SteamUser()->BSetDurationControlOnlineState((EDurationControlOnlineState)new_state);\n}\n\n// Stops voice recording.\nvoid Steam::stopVoiceRecording() {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: stopVoiceRecording\");\n\tSteamUser()->StopVoiceRecording();\n}\n\n// Notify the game server that we are disconnecting. NOTE: This is part of the old user authentication API and should not be mixed\n// with the new API.\nvoid Steam::terminateGameConnection(String server_ip, uint16 server_port) {\n\tERR_FAIL_COND_MSG(SteamUser() == NULL, \"[STEAM] User class not found when calling: terminateGameConnection\");\n\tSteamUser()->TerminateGameConnection_DEPRECATED(getIPFromString(server_ip), server_port);\n}\n\n// Checks if the user owns a specific piece of Downloadable Content (DLC). This can only be called after sending the users auth\n// ticket to ISteamGameServer::BeginAuthSession.\nint Steam::userHasLicenseForApp(uint64_t steam_id, uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamUser() == NULL, 2, \"[STEAM] User class not found when calling: userHasLicenseForApp\");\n\tCSteamID user_id = (uint64)steam_id;\n\treturn SteamUser()->UserHasLicenseForApp(user_id, (AppId_t)app_id);\n}\n\n\n///// USER STATS\n\n// Attaches a piece of user generated content the current user's entry on a leaderboard.\nvoid Steam::attachLeaderboardUGC(uint64_t ugc_handle, uint64_t this_leaderboard) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: attachLeaderboardUGC\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\tSteamAPICall_t api_call = SteamUserStats()->AttachLeaderboardUGC((SteamLeaderboard_t)this_leaderboard, (UGCHandle_t)ugc_handle);\n\tcallResultLeaderboardUGCSet.Set(api_call, this, &Steam::leaderboard_ugc_set);\n}\n\n// Clears a given achievement.\nbool Steam::clearAchievement(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: clearAchievement\");\n\treturn SteamUserStats()->ClearAchievement(name.utf8().get_data());\n}\n\n// Request all rows for friends of user.\nvoid Steam::downloadLeaderboardEntries(int start, int end, LeaderboardDataRequest type, uint64_t this_leaderboard) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: downloadLeaderboardEntries\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\tSteamAPICall_t api_call = SteamUserStats()->DownloadLeaderboardEntries((SteamLeaderboard_t)this_leaderboard, ELeaderboardDataRequest(type), start, end);\n\tcallResultEntries.Set(api_call, this, &Steam::leaderboard_scores_downloaded);\n}\n\n// Request a maximum of 100 users with only one outstanding call at a time.\nvoid Steam::downloadLeaderboardEntriesForUsers(Array users_id, uint64_t this_leaderboard) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: downloadLeaderboardEntriesForUsers\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\tint usersCount = users_id.size();\n\tif (usersCount > 0) {\n\t\tCSteamID *users = new CSteamID[usersCount];\n\t\tfor (int i = 0; i < usersCount; i++) {\n\t\t\tCSteamID user = createSteamID(users_id[i]);\n\t\t\tusers[i] = user;\n\t\t}\n\t\tSteamAPICall_t api_call = SteamUserStats()->DownloadLeaderboardEntriesForUsers((SteamLeaderboard_t)this_leaderboard, users, usersCount);\n\t\tcallResultEntries.Set(api_call, this, &Steam::leaderboard_scores_downloaded);\n\t\tdelete[] users;\n\t}\n}\n\n// Find a given leaderboard, by name.\nvoid Steam::findLeaderboard(const String &name) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: findLeaderboard\");\n\tSteamAPICall_t api_call = SteamUserStats()->FindLeaderboard(name.utf8().get_data());\n\tcallResultFindLeaderboard.Set(api_call, this, &Steam::leaderboard_find_result);\n}\n\n// Gets a leaderboard by name, it will create it if it's not yet created.\nvoid Steam::findOrCreateLeaderboard(const String &name, LeaderboardSortMethod sort_method, LeaderboardDisplayType display_type) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: findOrCreateLeaderboard\");\n\tSteamAPICall_t api_call = SteamUserStats()->FindOrCreateLeaderboard(name.utf8().get_data(), (ELeaderboardSortMethod)sort_method, (ELeaderboardDisplayType)display_type);\n\tcallResultFindLeaderboard.Set(api_call, this, &Steam::leaderboard_find_result);\n}\n\n// Return true/false if user has given achievement and the bool status of it being achieved or not.\nDictionary Steam::getAchievement(const String &name) {\n\tDictionary achieve;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, achieve, \"[STEAM] User Stats class not found when calling: getAchievement\");\n\tbool achieved = false;\n\tbool achieve_exists = SteamUserStats()->GetAchievement(name.utf8().get_data(), &achieved);\n\tachieve[\"ret\"] = achieve_exists;\n\tachieve[\"achieved\"] = achieved;\n\treturn achieve;\n}\n\n// Returns the percentage of users who have unlocked the specified achievement.\nDictionary Steam::getAchievementAchievedPercent(const String &name) {\n\tDictionary achieve;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, achieve, \"[STEAM] User Stats class not found when calling: getAchievementAchievedPercent\");\n\tfloat percent = 0.f;\n\tbool achieve_exists = SteamUserStats()->GetAchievementAchievedPercent(name.utf8().get_data(), &percent);\n\tachieve[\"ret\"] = achieve_exists;\n\tachieve[\"percent\"] = percent;\n\treturn achieve;\n}\n\n// Get the achievement status, and the time it was unlocked if unlocked (in seconds since January 1, 19).\nDictionary Steam::getAchievementAndUnlockTime(const String &name) {\n\tDictionary achieve;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, achieve, \"[STEAM] User Stats class not found when calling: getAchievementAndUnlockTime\");\n\tbool achieved = false;\n\tuint32 unlock_time = 0;\n\tbool achieve_exists = SteamUserStats()->GetAchievementAndUnlockTime(name.utf8().get_data(), &achieved, &unlock_time);\n\tachieve[\"ret\"] = achieve_exists;\n\tachieve[\"achieved\"] = achieved;\n\tachieve[\"unlocked\"] = unlock_time;\n\treturn achieve;\n}\n\n// Get general attributes for an achievement\nString Steam::getAchievementDisplayAttribute(const String &name, const String &key) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, \"\", \"[STEAM] User Stats class not found when calling: getAchievementDisplayAttribute\");\n\treturn SteamUserStats()->GetAchievementDisplayAttribute(name.utf8().get_data(), key.utf8().get_data());\n}\n\n// Gets the icon for an achievement\nint Steam::getAchievementIcon(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0, \"[STEAM] User Stats class not found when calling: getAchievementIcon\");\n\treturn SteamUserStats()->GetAchievementIcon(name.utf8().get_data());\n}\n\n// Gets the 'API name' for an achievement index\nString Steam::getAchievementName(uint32_t achievement) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, \"\", \"[STEAM] User Stats class not found when calling: getAchievementName\");\n\treturn SteamUserStats()->GetAchievementName(achievement);\n}\n\n// For achievements that have related Progress stats, use this to query what the bounds of that progress are. You may want this\n// info to selectively call IndicateAchievementProgress when appropriate milestones of progress have been made, to show a progress\n// notification to the user.\nDictionary Steam::getAchievementProgressLimitsInt(const String &name) {\n\tDictionary progress;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, progress, \"[STEAM] User Stats class not found when calling: getAchievementProgressLimitsInt\");\n\tint32 min = 0;\n\tint32 max = 0;\n\tif (SteamUserStats()->GetAchievementProgressLimits(name.utf8().get_data(), &min, &max)) {\n\t\tprogress[\"name\"] = name;\n\t\tprogress[\"min\"] = min;\n\t\tprogress[\"max\"] = max;\n\t}\n\treturn progress;\n}\n\n// For achievements that have related Progress stats, use this to query what the bounds of that progress are. You may want this\n// info to selectively call IndicateAchievementProgress when appropriate milestones of progress have been made, to show a progress\n// notification to the user.\nDictionary Steam::getAchievementProgressLimitsFloat(const String &name) {\n\tDictionary progress;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, progress, \"[STEAM] User Stats class not found when calling: getAchievementProgressLimitsFloat\");\n\tfloat min = 0.0;\n\tfloat max = 0.0;\n\tif (SteamUserStats()->GetAchievementProgressLimits(name.utf8().get_data(), &min, &max)) {\n\t\tprogress[\"name\"] = name;\n\t\tprogress[\"min\"] = min;\n\t\tprogress[\"max\"] = max;\n\t}\n\treturn progress;\n}\n\n// Gets the lifetime totals for an aggregated stat; as an int\nuint64_t Steam::getGlobalStatInt(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0, \"[STEAM] User Stats class not found when calling: getGlobalStatInt\");\n\tint64 stat = 0;\n\tSteamUserStats()->GetGlobalStat(name.utf8().get_data(), &stat);\n\treturn (uint64_t)stat;\n}\n\n// Gets the lifetime totals for an aggregated stat; as an int\ndouble Steam::getGlobalStatFloat(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0.0, \"[STEAM] User Stats class not found when calling: getGlobalStatFloat\");\n\tdouble stat = 0;\n\tSteamUserStats()->GetGlobalStat(name.utf8().get_data(), &stat);\n\treturn stat;\n}\n\n// Gets the daily history for an aggregated stat; int.\nPackedInt64Array Steam::getGlobalStatIntHistory(const String &name) {\n\tPackedInt64Array history_ints;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, history_ints, \"[STEAM] User Stats class not found when calling: getGlobalStatIntHistory\");\n\tuint32 history_size = 0;\n\tint64 *history;\n\tint32 histories = SteamUserStats()->GetGlobalStatHistory(name.utf8().get_data(), history, history_size);\n\tfor (int32 i = 0; i < histories; i++) {\n\t\thistory_ints.append(history[i]);\n\t}\n\treturn history_ints;\n}\n\n// Gets the daily history for an aggregated stat; float / double.\nPackedFloat64Array Steam::getGlobalStatFloatHistory(const String &name) {\n\tPackedFloat64Array history_floats;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, history_floats, \"[STEAM] User Stats class not found when calling: getGlobalStatFloatHistory\");\n\tuint32 history_size = 0;\n\tdouble *history;\n\tint32 histories = SteamUserStats()->GetGlobalStatHistory(name.utf8().get_data(), history, history_size);\n\tfor (int32 i = 0; i < histories; i++) {\n\t\thistory_floats.append(history[i]);\n\t}\n\treturn history_floats;\n}\n\n// Returns the display type of a leaderboard handle.\nDictionary Steam::getLeaderboardDisplayType(uint64_t this_leaderboard) {\n\tDictionary display;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, display, \"[STEAM] User Stats class not found when calling: getLeaderboardDisplayType\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\n\tint display_type = SteamUserStats()->GetLeaderboardDisplayType((SteamLeaderboard_t)this_leaderboard);\n\tif (display_type == 3) {\n\t\tdisplay[\"result\"] = 3;\n\t\tdisplay[\"verbal\"] = \"Display is time in milliseconds\";\n\t}\n\telse if (display_type == 2) {\n\t\tdisplay[\"result\"] = 2;\n\t\tdisplay[\"verbal\"] = \"Display is time in seconds\";\n\t}\n\telse if (display_type == 1) {\n\t\tdisplay[\"result\"] = 1;\n\t\tdisplay[\"verbal\"] = \"Display is simple numerical value\";\n\t}\n\telse {\n\t\tdisplay[\"result\"] = 0;\n\t\tdisplay[\"verbal\"] = \"Display type or leaderboard handle is invalid\";\n\t}\n\treturn display;\n}\n\n// Get the total number of entries in a leaderboard, as of the last request.\nint Steam::getLeaderboardEntryCount(uint64_t this_leaderboard) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, -1, \"[STEAM] User Stats class not found when calling: getLeaderboardEntryCount\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\treturn SteamUserStats()->GetLeaderboardEntryCount((SteamLeaderboard_t)this_leaderboard);\n}\n\n// Get the name of a leaderboard.\nString Steam::getLeaderboardName(uint64_t this_leaderboard) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, \"\", \"[STEAM] User Stats class not found when calling: getLeaderboardName\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\treturn SteamUserStats()->GetLeaderboardName((SteamLeaderboard_t)this_leaderboard);\n}\n\n// Returns the sort order of a leaderboard handle.\nDictionary Steam::getLeaderboardSortMethod(uint64_t this_leaderboard) {\n\tDictionary sort;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, sort, \"[STEAM] User Stats class not found when calling: getLeaderboardSortMethod\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\t\n\tint sort_method = SteamUserStats()->GetLeaderboardSortMethod((SteamLeaderboard_t)this_leaderboard);\n\t\n\tif (sort_method == 2) {\n\t\tsort[\"result\"] = 2;\n\t\tsort[\"verbal\"] = \"Top score is highest number\";\n\t}\n\telse if (sort_method == 1) {\n\t\tsort[\"result\"] = 1;\n\t\tsort[\"verbal\"] = \"Top score is lowest number\";\n\t}\n\telse {\n\t\tsort[\"result\"] = 0;\n\t\tsort[\"verbal\"] = \"Sort method or leaderboard handle is invalid\";\n\t}\n\treturn sort;\n}\n\n// Gets the info on the most achieved achievement for the game.\nDictionary Steam::getMostAchievedAchievementInfo() {\n\tDictionary entry;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, entry, \"[STEAM] User Stats class not found when calling: getMostAchievedAchievementInfo\");\n\tchar name[64 + 1]{};\n\tfloat percent = 0;\n\tbool achieved = false;\n\n\tint result = SteamUserStats()->GetMostAchievedAchievementInfo(name, 64, &percent, &achieved);\n\tif (result > -1) {\n\t\tentry[\"rank\"] = result;\n\t\tentry[\"name\"] = name;\n\t\tentry[\"percent\"] = percent;\n\t\tentry[\"achieved\"] = achieved;\n\t}\n\treturn entry;\n}\n\n// Gets the info on the next most achieved achievement for the game.\nDictionary Steam::getNextMostAchievedAchievementInfo(int iterator) {\n\tDictionary entry;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, entry, \"[STEAM] User Stats class not found when calling: getNextMostAchievedAchievementInfo\");\n\tchar name[64 + 1]{};\n\tfloat percent = 0;\n\tbool achieved = false;\n\n\tint result = SteamUserStats()->GetNextMostAchievedAchievementInfo(iterator, name, 64, &percent, &achieved);\n\tif (result > -1) {\n\t\tentry[\"rank\"] = result;\n\t\tentry[\"name\"] = name;\n\t\tentry[\"percent\"] = percent;\n\t\tentry[\"achieved\"] = achieved;\n\t}\n\treturn entry;\n}\n\n// Get the number of achievements.\nuint32_t Steam::getNumAchievements() {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0, \"[STEAM] User Stats class not found when calling: getNumAchievements\");\n\treturn SteamUserStats()->GetNumAchievements();\n}\n\n//  Get the amount of players currently playing the current game (online + offline).\nvoid Steam::getNumberOfCurrentPlayers() {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: getNumberOfCurrentPlayers\");\n\tSteamAPICall_t api_call = SteamUserStats()->GetNumberOfCurrentPlayers();\n\tcallResultNumberOfCurrentPlayers.Set(api_call, this, &Steam::number_of_current_players);\n}\n\n// Get the value of a float statistic.\nfloat Steam::getStatFloat(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0.0, \"[STEAM] User Stats class not found when calling: getStatFloat\");\n\tfloat stat_value = 0.0;\n\tSteamUserStats()->GetStat(name.utf8().get_data(), &stat_value);\n\treturn stat_value;\n}\n\n// Get the value of an integer statistic.\nint Steam::getStatInt(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0, \"[STEAM] User Stats class not found when calling: getStatInt\");\n\tint32_t stat_value = 0;\n\tSteamUserStats()->GetStat(name.utf8().get_data(), &stat_value);\n\treturn stat_value;\n}\n\n// Gets the unlock status of the Achievement.\nDictionary Steam::getUserAchievement(uint64_t steam_id, const String &name) {\n\tDictionary achieve;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, achieve, \"[STEAM] User Stats class not found when calling: getUserAchievement\");\n\tbool achieved = false;\n\tCSteamID user_id = (uint64)steam_id;\n\n\tbool success = SteamUserStats()->GetUserAchievement(user_id, name.utf8().get_data(), &achieved);\n\tif (success) {\n\t\tachieve[\"steam_id\"] = steam_id;\n\t\tachieve[\"retrieved\"] = success;\n\t\tachieve[\"name\"] = name;\n\t\tachieve[\"achieved\"] = achieved;\n\t}\n\treturn achieve;\n}\n\n// Gets the achievement status, and the time it was unlocked if unlocked.\nDictionary Steam::getUserAchievementAndUnlockTime(uint64_t steam_id, const String &name) {\n\tDictionary achieve;\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, achieve, \"[STEAM] User Stats class not found when calling: getUserAchievementAndUnlockTime\");\n\tbool achieved = false;\n\tuint32 unlocked = 0;\n\tCSteamID user_id = (uint64)steam_id;\n\n\tbool success = SteamUserStats()->GetUserAchievementAndUnlockTime(user_id, name.utf8().get_data(), &achieved, &unlocked);\n\tif (success) {\n\t\tachieve[\"retrieved\"] = success;\n\t\tachieve[\"name\"] = name;\n\t\tachieve[\"achieved\"] = achieved;\n\t\tachieve[\"unlocked\"] = unlocked;\n\t}\n\treturn achieve;\n}\n\n// Gets the current value of a float stat for the specified user.\nfloat Steam::getUserStatFloat(uint64_t steam_id, const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0.0, \"[STEAM] User Stats class not found when calling: getUserStatFloat\");\n\tfloat stat_value = 0.0;\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamUserStats()->GetUserStat(user_id, name.utf8().get_data(), &stat_value);\n\treturn stat_value;\n}\n\n// Gets the current value of an integer stat for the specified user.\nint Steam::getUserStatInt(uint64_t steam_id, const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, 0, \"[STEAM] User Stats class not found when calling: getUserStatInt\");\n\tint32_t stat_value = 0;\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamUserStats()->GetUserStat(user_id, name.utf8().get_data(), &stat_value);\n\treturn stat_value;\n}\n\n// Achievement progress, triggers an AchievementProgress callback, that is all.\n// Calling this with X out of X progress will NOT set the achievement, the game must still do that.\nbool Steam::indicateAchievementProgress(const String &name, int current_progress, int max_progress) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: indicateAchievementProgress\");\n\treturn SteamUserStats()->IndicateAchievementProgress(name.utf8().get_data(), current_progress, max_progress);\n}\n\n// Asynchronously fetch the data for the percentages.\nvoid Steam::requestGlobalAchievementPercentages() {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: requestGlobalAchievementPercentages\");\n\tSteamAPICall_t api_call = SteamUserStats()->RequestGlobalAchievementPercentages();\n\tcallResultGlobalAchievementPercentagesReady.Set(api_call, this, &Steam::global_achievement_percentages_ready);\n}\n\n// Asynchronously fetches global stats data, which is available for stats marked as \"aggregated\" in the App Admin panel of the\n// Steamworks website.  The limit is 60.\nvoid Steam::requestGlobalStats(int history_days) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: requestGlobalStats\");\n\tSteamAPICall_t api_call = SteamUserStats()->RequestGlobalStats(history_days);\n\tcallResultGlobalStatsReceived.Set(api_call, this, &Steam::global_stats_received);\n}\n\n// Asynchronously downloads stats and achievements for the specified user from the server.\nvoid Steam::requestUserStats(uint64_t steam_id) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: requestUserStats\");\n\tCSteamID user_id = (uint64)steam_id;\n\tSteamAPICall_t api_call = SteamUserStats()->RequestUserStats(user_id);\n\tcallResultUserStatsReceived.Set(api_call, this, &Steam::user_stats_received);\n}\n\n// Reset all Steam statistics; optional to reset achievements.\nbool Steam::resetAllStats(bool achievements_too) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: resetAllStats\");\n\treturn SteamUserStats()->ResetAllStats(achievements_too);\n}\n\n// Set a given achievement.\nbool Steam::setAchievement(const String &name) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: setAchievement\");\n\treturn SteamUserStats()->SetAchievement(name.utf8().get_data());\n}\n\n// Set a float statistic.\nbool Steam::setStatFloat(const String &name, float value) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: setStatFloat\");\n\treturn SteamUserStats()->SetStat(name.utf8().get_data(), value);\n}\n\n// Set an integer statistic.\nbool Steam::setStatInt(const String &name, int value) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: setStatInt\");\n\treturn SteamUserStats()->SetStat(name.utf8().get_data(), value);\n}\n\n// Store all statistics, and achievements, on Steam servers; must be called to \"pop\" achievements.\nbool Steam::storeStats() {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: storeStats\");\n\treturn SteamUserStats()->StoreStats();\n}\n\n// Updates an AVGRATE stat with new values.\nbool Steam::updateAvgRateStat(const String &name, float this_session, double session_length) {\n\tERR_FAIL_COND_V_MSG(SteamUserStats() == NULL, false, \"[STEAM] User Stats class not found when calling: updateAvgRateStat\");\n\treturn SteamUserStats()->UpdateAvgRateStat(name.utf8().get_data(), this_session, session_length);\n}\n\n// Upload a leaderboard score for the user.\nvoid Steam::uploadLeaderboardScore(int score, bool keep_best, PackedInt32Array details, uint64_t this_leaderboard) {\n\tERR_FAIL_COND_MSG(SteamUserStats() == NULL, \"[STEAM] User Stats class not found when calling: uploadLeaderboardScore\");\n\tif (this_leaderboard == 0) {\n\t\tthis_leaderboard = leaderboard_handle;\n\t}\n\n\tELeaderboardUploadScoreMethod method = keep_best ? k_ELeaderboardUploadScoreMethodKeepBest : k_ELeaderboardUploadScoreMethodForceUpdate;\n\tint details_size = details.size();\n\tconst int32 *details_pointer = NULL;\n\tif (details_size > 0) {\n\t\tdetails_pointer = details.ptr();\n\t}\n\tSteamAPICall_t api_call = SteamUserStats()->UploadLeaderboardScore((SteamLeaderboard_t)this_leaderboard, method, (int32)score, details_pointer, details_size);\n\tcallResultUploadScore.Set(api_call, this, &Steam::leaderboard_score_uploaded);\n}\n\n\n///// UTILS\n\n// Dismisses the floating keyboard.\nbool Steam::dismissFloatingGamepadTextInput() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: dismissFloatingGamepadTextInput\");\n\treturn SteamUtils()->DismissFloatingGamepadTextInput();\n}\n\n// Dismisses the full-screen text input dialog.\nbool Steam::dismissGamepadTextInput() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: dismissGamepadTextInput\");\n\treturn SteamUtils()->DismissGamepadTextInput();\n}\n\n// Filters the provided input message and places the filtered result into pchOutFilteredText.\nString Steam::filterText(TextFilteringContext context, uint64_t steam_id, const String &message) {\n\tString new_message = \"\";\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, new_message, \"[STEAM] Utils class not found when calling: filterText\");\n\tauto utf8_input = message.utf8();\n\tchar *filtered = new char[utf8_input.length() + 1]{};\n\tCSteamID source_id = (uint64)steam_id;\n\tSteamUtils()->FilterText((ETextFilteringContext)context, source_id, utf8_input.get_data(), filtered, utf8_input.length() + 1);\n\tnew_message = filtered;\n\tdelete[] filtered;\n\treturn new_message;\n}\n\n// Used to get the failure reason of a call result. The primary usage for this function is debugging. The failure reasons are\n// typically out of your control and tend to not be very important. Just keep retrying your API Call until it works.\nString Steam::getAPICallFailureReason() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, \"\", \"[STEAM] Utils class not found when calling: getAPICallFailureReason\");\n\tint failure = SteamUtils()->GetAPICallFailureReason(api_handle);\n\tif (failure == k_ESteamAPICallFailureSteamGone) {\n\t\treturn \"The local Steam process has stopped responding, it may have been forcefully closed or is frozen.\";\n\t}\n\telse if (failure == k_ESteamAPICallFailureNetworkFailure) {\n\t\treturn \"The network connection to the Steam servers has been lost, or was already broken.\";\n\t}\n\telse if (failure == k_ESteamAPICallFailureInvalidHandle) {\n\t\treturn \"The SteamAPICall_t handle passed in no longer exists.\";\n\t}\n\telse if (failure == k_ESteamAPICallFailureMismatchedCallback) {\n\t\treturn \"GetAPICallResult was called with the wrong callback type for this API call.\";\n\t}\n\telse {\n\t\treturn \"No failure.\";\n\t}\n}\n\n// Get the Steam ID of the running application/game.\nuint32_t Steam::getAppID() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getAppID\");\n\treturn SteamUtils()->GetAppID();\n}\n\n// Get the amount of battery power, clearly for laptops.\nint Steam::getCurrentBatteryPower() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getCurrentBatteryPower\");\n\treturn SteamUtils()->GetCurrentBatteryPower();\n}\n\n// Gets the image bytes from an image handle.\nDictionary Steam::getImageRGBA(int image) {\n\tDictionary image_data;\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, image_data, \"[STEAM] Utils class not found when calling: getImageRGBA\");\n\tuint32 width;\n\tuint32 height;\n\timage_data[\"success\"] = SteamUtils()->GetImageSize(image, &width, &height);\n\tif (image_data[\"success\"]) {\n\t\tPackedByteArray data;\n\t\tdata.resize(width * height * 4);\n\t\tif (SteamUtils()->GetImageRGBA(image, data.ptrw(), data.size())) {\n\t\t\timage_data[\"buffer\"] = data;\n\t\t}\n\t}\n\treturn image_data;\n}\n\n// Gets the size of a Steam image handle.\nDictionary Steam::getImageSize(int image) {\n\tDictionary image_data;\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, image_data, \"[STEAM] Utils class not found when calling: getImageSize\");\n\tuint32 width;\n\tuint32 height;\n\timage_data[\"success\"] = SteamUtils()->GetImageSize(image, &width, &height);\n\timage_data[\"width\"] = width;\n\timage_data[\"height\"] = height;\n\treturn image_data;\n}\n\n// Returns the number of IPC calls made since the last time this function was called.\nuint32 Steam::getIPCCallCount() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getIPCCallCount\");\n\treturn SteamUtils()->GetIPCCallCount();\n}\n\n// Get the user's country by IP.\nString Steam::getIPCountry() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, \"\", \"[STEAM] Utils class not found when calling: getIPCountry\");\n\treturn SteamUtils()->GetIPCountry();\n}\n\n// Return amount of time, in seconds, user has spent in this session.\nint Steam::getSecondsSinceAppActive() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getSecondsSinceAppActive\");\n\treturn SteamUtils()->GetSecondsSinceAppActive();\n}\n\n// Returns the number of seconds since the user last moved the mouse.\nint Steam::getSecondsSinceComputerActive() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getSecondsSinceComputerActive\");\n\treturn SteamUtils()->GetSecondsSinceComputerActive();\n}\n\n// Get the actual time.\nint Steam::getServerRealTime() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, 0, \"[STEAM] Utils class not found when calling: getServerRealTime\");\n\treturn SteamUtils()->GetServerRealTime();\n}\n\n// Get the Steam user interface language.\nString Steam::getSteamUILanguage() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, \"\", \"[STEAM] Utils class not found when calling: getSteamUILanguage\");\n\treturn SteamUtils()->GetSteamUILanguage();\n}\n\n// Initializes text filtering. Returns false if filtering is unavailable for the language the user is currently running in. If the\n// language is unsupported, the FilterText API will act as a passthrough.\nbool Steam::initFilterText() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: initFilterText\");\n\treturn SteamUtils()->InitFilterText();\n}\n\n// Checks if an API Call is completed. Provides the backend of the CallResult wrapper.\nDictionary Steam::isAPICallCompleted() {\n\tDictionary completed;\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, completed, \"[STEAM] Utils class not found when calling: isAPICallCompleted\");\n\tbool failed = false;\n\tcompleted[\"completed\"] = SteamUtils()->IsAPICallCompleted(api_handle, &failed);\n\tcompleted[\"failed\"] = failed;\n\treturn completed;\n}\n\n// Returns true/false if Steam overlay is enabled.\nbool Steam::isOverlayEnabled() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isOverlayEnabled\");\n\treturn SteamUtils()->IsOverlayEnabled();\n}\n\n// Returns whether the current launcher is a Steam China launcher. You can cause the client to behave as the Steam China launcher\n// by adding -dev -steamchina to the command line when running Steam.\nbool Steam::isSteamChinaLauncher() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isSteamChinaLauncher\");\n\treturn SteamUtils()->IsSteamChinaLauncher();\n}\n\n// Returns true if Steam & the Steam Overlay are running in Big Picture mode.\nbool Steam::isSteamInBigPictureMode() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isSteamInBigPictureMode\");\n\treturn SteamUtils()->IsSteamInBigPictureMode();\n}\n\n// Is Steam running in VR?\nbool Steam::isSteamRunningInVR() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isSteamRunningInVR\");\n\treturn SteamUtils()->IsSteamRunningInVR();\n}\n\n// Returns true if currently running on the Steam Deck device\nbool Steam::isSteamRunningOnSteamDeck() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isSteamRunningOnSteamDeck\");\n\treturn SteamUtils()->IsSteamRunningOnSteamDeck();\n}\n\n// Checks if the HMD view will be streamed via Steam In-Home Streaming.\nbool Steam::isVRHeadsetStreamingEnabled() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: isVRHeadsetStreamingEnabled\");\n\treturn SteamUtils()->IsVRHeadsetStreamingEnabled();\n}\n\n// Checks if the Overlay needs a present. Only required if using event driven render updates.\nbool Steam::overlayNeedsPresent() {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: overlayNeedsPresent\");\n\treturn SteamUtils()->BOverlayNeedsPresent();\n}\n\n// Activates the Big Picture text input dialog which only supports gamepad input.\nbool Steam::showGamepadTextInput(GamepadTextInputMode input_mode, GamepadTextInputLineMode line_input_mode, const String &description, uint32 max_text, const String &preset_text) {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: showGamepadTextInput\");\n\treturn SteamUtils()->ShowGamepadTextInput((EGamepadTextInputMode)input_mode, (EGamepadTextInputLineMode)line_input_mode, description.utf8().get_data(), max_text, preset_text.utf8().get_data());\n}\n\n// Opens a floating keyboard over the game content and sends OS keyboard keys directly to the game.\n// The text field position is specified in pixels relative the origin of the game window and is used to position the floating\n// keyboard in a way that doesn't cover the text field\nbool Steam::showFloatingGamepadTextInput(FloatingGamepadTextInputMode input_mode, int text_field_x_position, int text_field_y_position, int text_field_width, int text_field_height) {\n\tERR_FAIL_COND_V_MSG(SteamUtils() == NULL, false, \"[STEAM] Utils class not found when calling: showFloatingGamepadTextInput\");\n\treturn SteamUtils()->ShowFloatingGamepadTextInput((EFloatingGamepadTextInputMode)input_mode, text_field_x_position, text_field_y_position, text_field_width, text_field_height);\n}\n\n// In game launchers that don't have controller support you can call this to have Steam Input translate the controller input into\n// mouse/kb to navigate the launcher\nvoid Steam::setGameLauncherMode(bool mode) {\n\tERR_FAIL_COND_MSG(SteamUtils() == NULL, \"[STEAM] Utils class not found when calling: setGameLauncherMode\");\n\tSteamUtils()->SetGameLauncherMode(mode);\n}\n\n// Sets the inset of the overlay notification from the corner specified by SetOverlayNotificationPosition.\nvoid Steam::setOverlayNotificationInset(int horizontal, int vertical) {\n\tERR_FAIL_COND_MSG(SteamUtils() == NULL, \"[STEAM] Utils class not found when calling: setOverlayNotificationInset\");\n\tSteamUtils()->SetOverlayNotificationInset(horizontal, vertical);\n}\n\n// Set the position where overlay shows notifications.\nvoid Steam::setOverlayNotificationPosition(int pos) {\n\tERR_FAIL_COND_MSG(SteamUtils() == NULL, \"[STEAM] Utils class not found when calling: setOverlayNotificationPosition\");\n\tSteamUtils()->SetOverlayNotificationPosition(ENotificationPosition(pos));\n}\n\n// Set whether the HMD content will be streamed via Steam In-Home Streaming.\nvoid Steam::setVRHeadsetStreamingEnabled(bool enabled) {\n\tERR_FAIL_COND_MSG(SteamUtils() == NULL, \"[STEAM] Utils class not found when calling: setVRHeadsetStreamingEnabled\");\n\tSteamUtils()->SetVRHeadsetStreamingEnabled(enabled);\n}\n\n// Ask SteamUI to create and render its OpenVR dashboard.\nvoid Steam::startVRDashboard() {\n\tERR_FAIL_COND_MSG(SteamUtils() == NULL, \"[STEAM] Utils class not found when calling: startVRDashboard\");\n\tSteamUtils()->StartVRDashboard();\n}\n\n\n///// VIDEO\n\n// Get the OPF details for 360 video playback.\nvoid Steam::getOPFSettings(uint32_t app_id) {\n\tERR_FAIL_COND_MSG(SteamVideo() == NULL, \"[STEAM] Video class not found when calling: getOPFSettings\");\n\tSteamVideo()->GetOPFSettings((AppId_t)app_id);\n}\n\n// Gets the OPF string for the specified video App ID.\nString Steam::getOPFStringForApp(uint32_t app_id) {\n\tERR_FAIL_COND_V_MSG(SteamVideo() == NULL, \"\", \"[STEAM] Utils class not found when calling: getOPFStringForApp\");\n\tString opf_string = \"\";\n\tint32 size = 48000;\n\tchar *buffer = new char[size]{};\n\tif (SteamVideo()->GetOPFStringForApp((AppId_t)app_id, buffer, &size)) {\n\t\topf_string = buffer;\n\t}\n\tdelete[] buffer;\n\treturn opf_string;\n}\n\n// Asynchronously gets the URL suitable for streaming the video associated with the specified video app ID.\nvoid Steam::getVideoURL(uint32_t app_id) {\n\tERR_FAIL_COND_MSG(SteamVideo() == NULL, \"[STEAM] Video class not found when calling: getVideoURL\");\n\tSteamVideo()->GetVideoURL((AppId_t)app_id);\n}\n\n// Checks if the user is currently live broadcasting and gets the number of users.\nDictionary Steam::isBroadcasting() {\n\tDictionary broadcast;\n\tERR_FAIL_COND_V_MSG(SteamVideo() == NULL, broadcast, \"[STEAM] Utils class not found when calling: isBroadcasting\");\n\tint viewers = 0;\n\tbool broadcasting = SteamVideo()->IsBroadcasting(&viewers);\n\t\n\tbroadcast[\"broadcasting\"] = broadcasting;\n\tbroadcast[\"viewers\"] = viewers;\n\treturn broadcast;\n}\n\n\n///// SIGNALS / CALLBACKS\n\n///// APPS\n\n// Triggered after the current user gains ownership of DLC and that DLC is installed.\nvoid Steam::dlc_installed(DlcInstalled_t *call_data) {\n\tuint32_t app_id = (AppId_t)call_data->m_nAppID;\n\temit_signal(\"dlc_installed\", app_id);\n}\n\n// Called after requesting the details of a specific file.\nvoid Steam::file_details_result(FileDetailsResult_t *file_data) {\n\tuint32_t result = file_data->m_eResult;\n\tuint64_t file_size = file_data->m_ulFileSize;\n\tuint32_t flags = file_data->m_unFlags;\n\tuint8 *file_hash = file_data->m_FileSHA;\n\temit_signal(\"file_details_result\", result, file_size, file_hash, flags);\n}\n\n// Posted after the user executes a steam url with command line or query parameters such as\n// steam://run/<appid>//?param1=value1;param2=value2;param3=value3; while the game is already running. The new params can be\n// queried with getLaunchCommandLine and getLaunchQueryParam.\nvoid Steam::new_launch_url_parameters(NewUrlLaunchParameters_t *call_data) {\n\temit_signal(\"new_launch_url_parameters\");\n}\n\n// Purpose: called for games in Timed Trial mode\nvoid Steam::timed_trial_status(TimedTrialStatus_t *call_data) {\n\tuint32_t app_id = call_data->m_unAppID;\n\tbool is_offline = call_data->m_bIsOffline;\n\tuint32 seconds_allowed = call_data->m_unSecondsAllowed;\n\tuint32 seconds_played = call_data->m_unSecondsPlayed;\n\temit_signal(\"timed_trial_status\", app_id, is_offline, seconds_allowed, seconds_played);\n}\n\n\n///// FRIENDS\n\n// Called when a large avatar is loaded if you have tried requesting it when it was unavailable.\nvoid Steam::avatar_loaded(AvatarImageLoaded_t *avatar_data) {\n\tuint32 width, height;\n\tbool success = SteamUtils()->GetImageSize(avatar_data->m_iImage, &width, &height);\n\tif (!success) {\n\t\tprintf(\"[Steam] Failed to get image size.\\n\");\n\t\treturn;\n\t}\n\tPackedByteArray data;\n\tdata.resize(width * height * 4);\n\tsuccess = SteamUtils()->GetImageRGBA(avatar_data->m_iImage, data.ptrw(), data.size());\n\tif (!success) {\n\t\tprintf(\"[Steam] Failed to load image buffer from callback\\n\");\n\t\treturn;\n\t}\n\tCSteamID steam_id = avatar_data->m_steamID;\n\tuint64_t avatar_id = steam_id.ConvertToUint64();\n\tcall_deferred(\"emit_signal\", \"avatar_loaded\", avatar_id, width, data);\n}\n\n// Called when a large avatar is loaded if you have tried requesting it when it was unavailable.\nvoid Steam::avatar_image_loaded(AvatarImageLoaded_t *avatar_data) {\n\tuint32 width = avatar_data->m_iWide;\n\tuint32 height = avatar_data->m_iTall;\n\tint avatar_index = avatar_data->m_iImage;\n\tCSteamID steam_id = avatar_data->m_steamID;\n\tuint64_t avatar_id = steam_id.ConvertToUint64();\n\tcall_deferred(\"emit_signal\", \"avatar_image_loaded\", avatar_id, avatar_index, width, height);\n}\n\n// Called when a Steam group activity has received.\nvoid Steam::clan_activity_downloaded(DownloadClanActivityCountsResult_t *call_data) {\n\tbool success = call_data->m_bSuccess;\n\t// Set up the dictionary to populate\n\tDictionary activity;\n\tif (success) {\n\t\tint online = 0;\n\t\tint in_game = 0;\n\t\tint chatting = 0;\n\t\tCSteamID clan = (uint64)current_clan_id;\n\t\tactivity[\"ret\"] = SteamFriends()->GetClanActivityCounts(clan, &online, &in_game, &chatting);\n\t\tif (activity[\"ret\"]) {\n\t\t\tactivity[\"online\"] = online;\n\t\t\tactivity[\"ingame\"] = in_game;\n\t\t\tactivity[\"chatting\"] = chatting;\n\t\t}\n\t}\n\temit_signal(\"clan_activity_downloaded\", activity);\n}\n\n// Called when Rich Presence data has been updated for a user, this can happen automatically when friends in the same game update\n// their rich presence, or after a call to requestFriendRichPresence.\nvoid Steam::friend_rich_presence_update(FriendRichPresenceUpdate_t *call_data) {\n\tuint64_t steam_id = call_data->m_steamIDFriend.ConvertToUint64();\n\tAppId_t app_id = call_data->m_nAppID;\n\temit_signal(\"friend_rich_presence_updated\", steam_id, app_id);\n}\n\n// Called when a user has joined a Steam group chat that the we are in.\nvoid Steam::connected_chat_join(GameConnectedChatJoin_t *call_data) {\n\tuint64_t chat_id = call_data->m_steamIDClanChat.ConvertToUint64();\n\tuint64_t steam_id = call_data->m_steamIDUser.ConvertToUint64();\n\temit_signal(\"chat_joined\", chat_id, steam_id);\n}\n\n// Called when a user has left a Steam group chat that the we are in.\nvoid Steam::connected_chat_leave(GameConnectedChatLeave_t *call_data) {\n\tuint64_t chat_id = call_data->m_steamIDClanChat.ConvertToUint64();\n\tuint64_t steam_id = call_data->m_steamIDUser.ConvertToUint64();\n\tbool kicked = call_data->m_bKicked;\n\tbool dropped = call_data->m_bDropped;\n\temit_signal(\"chat_left\", chat_id, steam_id, kicked, dropped);\n}\n\n// Called when a chat message has been received in a Steam group chat that we are in.\nvoid Steam::connected_clan_chat_message(GameConnectedClanChatMsg_t *call_data) {\n\tDictionary chat;\n\tchar text[2048]{};\n\tEChatEntryType type = k_EChatEntryTypeInvalid;\n\tCSteamID user_id;\n\tchat[\"ret\"] = SteamFriends()->GetClanChatMessage(call_data->m_steamIDClanChat, call_data->m_iMessageID, text, 2048, &type, &user_id);\n\tchat[\"text\"] = String(text);\n\tchat[\"type\"] = type;\n\tchat[\"chatter\"] = uint64_t(user_id.ConvertToUint64());\n\temit_signal(\"clan_chat_message\", chat);\n}\n\n// Called when chat message has been received from a friend\nvoid Steam::connected_friend_chat_message(GameConnectedFriendChatMsg_t *call_data) {\n\tuint64_t steam_id = call_data->m_steamIDUser.ConvertToUint64();\n\tint message = call_data->m_iMessageID;\n\tDictionary chat;\n\tchar text[2048]{};\n\tEChatEntryType type = k_EChatEntryTypeInvalid;\n\tchat[\"ret\"] = SteamFriends()->GetFriendMessage(createSteamID(steam_id), message, text, 2048, &type);\n\tchat[\"text\"] = String(text);\n\tchat[\"type\"] = type;\n\temit_signal(\"connected_friend_chat_message\", chat);\n}\n\n// Called when the user tries to join a lobby from their friends list or from an invite. The game client should attempt to connect\n// to specified lobby when this is received. If the game isn't running yet then the game will be automatically launched with the\n// command line parameter +connect_lobby <64-bit lobby Steam ID> instead.\nvoid Steam::join_requested(GameLobbyJoinRequested_t *call_data) {\n\tCSteamID lobby_id = call_data->m_steamIDLobby;\n\tuint64_t lobby = lobby_id.ConvertToUint64();\n\tCSteamID friend_id = call_data->m_steamIDFriend;\n\tuint64_t steam_id = friend_id.ConvertToUint64();\n\temit_signal(\"join_requested\", lobby, steam_id);\n}\n\n// Posted when the Steam Overlay activates or deactivates. The game can use this to be pause or resume single player games.\nvoid Steam::overlay_toggled(GameOverlayActivated_t *call_data) {\n\tbool user_initiated = call_data->m_bUserInitiated;\n\tuint32_t app_id = call_data->m_nAppID;\n\tif (call_data->m_bActive) {\n\t\temit_signal(\"overlay_toggled\", true, user_initiated, app_id);\n\t}\n\telse {\n\t\temit_signal(\"overlay_toggled\", false, user_initiated, app_id);\n\t}\n}\n\n// Called when the user tries to join a game from their friends list or after a user accepts an invite by a friend with\n// inviteUserToGame.\nvoid Steam::join_game_requested(GameRichPresenceJoinRequested_t *call_data) {\n\tCSteamID steam_id = call_data->m_steamIDFriend;\n\tuint64_t user = steam_id.ConvertToUint64();\n\tString connect = call_data->m_rgchConnect;\n\temit_signal(\"join_game_requested\", user, connect);\n}\n\n// This callback is made when joining a game. If the user is attempting to join a lobby, then the callback GameLobbyJoinRequested_t\n// will be made.\nvoid Steam::change_server_requested(GameServerChangeRequested_t *call_data) {\n\tString server = call_data->m_rgchServer;\n\tString password = call_data->m_rgchPassword;\n\temit_signal(\"change_server_requested\", server, password);\n}\n\n//\nvoid Steam::join_clan_chat_complete(JoinClanChatRoomCompletionResult_t *call_data) {\n\tuint64_t chat_id = call_data->m_steamIDClanChat.ConvertToUint64();\n\tEChatRoomEnterResponse response = call_data->m_eChatRoomEnterResponse;\n\temit_signal(\"chat_join_complete\", chat_id, response);\n}\n\n// Signal for a user change\nvoid Steam::persona_state_change(PersonaStateChange_t *call_data) {\n\tuint64_t steam_id = call_data->m_ulSteamID;\n\tint flags = call_data->m_nChangeFlags;\n\temit_signal(\"persona_state_change\", steam_id, flags);\n}\n\n// Reports the result of an attempt to change the user's persona name.\nvoid Steam::name_changed(SetPersonaNameResponse_t *call_data) {\n\tbool success = call_data->m_bSuccess;\n\tbool local_success = call_data->m_bLocalSuccess;\n\tEResult result = call_data->m_result;\n\temit_signal(\"name_changed\", success, local_success, result);\n}\n\n// Dispatched when an overlay browser instance is navigated to a protocol/scheme registered by RegisterProtocolInOverlayBrowser().\nvoid Steam::overlay_browser_protocol(OverlayBrowserProtocolNavigation_t *call_data) {\n\tString uri = call_data->rgchURI;\n\temit_signal(\"overlay_browser_protocol\", uri);\n}\n\n// Purpose: Invoked when the status of unread messages changes\nvoid Steam::unread_chat_messages_changed(UnreadChatMessagesChanged_t *call_data) {\n\temit_signal(\"unread_chat_messages_changed\");\n}\n\n// Callback for when a user's equipped Steam Commuity profile items have changed. This can be for the current user or their friends.\nvoid Steam::equipped_profile_items_changed(EquippedProfileItemsChanged_t *call_data) {\n\tCSteamID this_steam_id = call_data->m_steamID;\n\tuint64_t steam_id = this_steam_id.ConvertToUint64();\n\temit_signal(\"equipped_profile_items_changed\", steam_id);\n}\n\n\n///// GAME SEARCH\n\n// There are no notes about this in Valve's header files or documentation.\nvoid Steam::search_for_game_progress(SearchForGameProgressCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t search_id = call_data->m_ullSearchID;\n\tuint64_t lobby_id = call_data->m_lobbyID.ConvertToUint64();\n\tuint64_t steamIDEndedSearch = call_data->m_steamIDEndedSearch.ConvertToUint64();\n\t// Create a dictionary for search progress\n\tDictionary search_progress;\n\tsearch_progress[\"lobby_id\"] = lobby_id;\n\tsearch_progress[\"ended_search_id\"] = steamIDEndedSearch;\n\tsearch_progress[\"seconds_remaining_estimate\"] = call_data->m_nSecondsRemainingEstimate;\n\tsearch_progress[\"players_searching\"] = call_data->m_cPlayersSearching;\n\temit_signal(\"search_for_game_progress\", result, search_id, search_progress);\n}\n\n// Notification to all players searching that a game has been found.\nvoid Steam::search_for_game_result(SearchForGameResultCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t search_id = call_data->m_ullSearchID;\n\tuint64_t host_id = call_data->m_steamIDHost.ConvertToUint64();\n\t// Create a dictionary for search results\n\tDictionary search_result;\n\tsearch_result[\"count_players_ingame\"] = call_data->m_nCountPlayersInGame;\n\tsearch_result[\"count_accepted_game\"] = call_data->m_nCountAcceptedGame;\n\tsearch_result[\"host_id\"] = host_id;\n\tsearch_result[\"final_callback\"] = call_data->m_bFinalCallback;\n\temit_signal(\"search_for_game_result\", result, search_id, search_result);\n}\n\n// Callback from RequestPlayersForGame when the matchmaking service has started or ended search; callback will also follow a call\n// from CancelRequestPlayersForGame - m_bSearchInProgress will be false.\nvoid Steam::request_players_for_game_progress(RequestPlayersForGameProgressCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t search_id = call_data->m_ullSearchID;\n\temit_signal(\"request_players_for_game_progress\", result, search_id);\n}\n\n// Callback from RequestPlayersForGame, one of these will be sent per player followed by additional callbacks when players accept\n// or decline the game.\nvoid Steam::request_players_for_game_result(RequestPlayersForGameResultCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t search_id = call_data->m_ullSearchID;\n\tuint64_t player_id = call_data->m_SteamIDPlayerFound.ConvertToUint64();\n\tuint64_t lobby_id = call_data->m_SteamIDLobby.ConvertToUint64();\n\tuint64_t unique_game_id = call_data->m_ullUniqueGameID;\n\t// Create a dictionary for the player data\n\tDictionary player_data;\n\tplayer_data[\"player_id\"] = player_id;\n\tplayer_data[\"lobby_id\"] = lobby_id;\n\tplayer_data[\"player_accept_state\"] = call_data->m_ePlayerAcceptState;\n\tplayer_data[\"player_index\"] = call_data->m_nPlayerIndex;\n\tplayer_data[\"total_players\"] = call_data->m_nTotalPlayersFound;\n\tplayer_data[\"total_players_accepted_game\"] = call_data->m_nTotalPlayersAcceptedGame;\n\tplayer_data[\"suggested_team_index\"] = call_data->m_nSuggestedTeamIndex;\n\tplayer_data[\"unique_game_id\"] = unique_game_id;\n\t// Send the data back via signal\n\temit_signal(\"request_players_for_game_result\", result, search_id, player_data);\n}\n\n// There are no notes about this in Valve's header files or documentation.\nvoid Steam::request_players_for_game_final_result(RequestPlayersForGameFinalResultCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t search_id = call_data->m_ullSearchID;\n\tuint64_t game_id = call_data->m_ullUniqueGameID;\n\temit_signal(\"request_players_for_game_final\", result, search_id, game_id);\n}\n\n// This callback confirms that results were received by the matchmaking service for this player.\nvoid Steam::submit_player_result(SubmitPlayerResultResultCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t game_id = call_data->ullUniqueGameID;\n\tuint64_t player_id = call_data->steamIDPlayer.ConvertToUint64();\n\temit_signal(\"submit_player_result\", result, game_id, player_id);\n}\n\n// This callback confirms that the game is recorded as complete on the matchmaking service, the next call to RequestPlayersForGame\n// will generate a new unique game ID.\nvoid Steam::end_game_result(EndGameResultCallback_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tuint64_t game_id = call_data->ullUniqueGameID;\n\temit_signal(\"end_game_result\", result, game_id);\n}\n\n\n///// HTML SURFACE\n\n// Called when page history status has changed the ability to go backwards and forward.\nvoid Steam::html_can_go_backandforward(HTML_CanGoBackAndForward_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tbool go_back = call_data->bCanGoBack;\n\tbool go_forward = call_data->bCanGoForward;\n\temit_signal(\"html_can_go_backandforward\", browser_handle, go_back, go_forward);\n}\n\n// Called when the current page in a browser gets a new title.\nvoid Steam::html_changed_title(HTML_ChangedTitle_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &title = call_data->pchTitle;\n\temit_signal(\"html_changed_title\", browser_handle, title);\n}\n\n// Called when the browser has been requested to close due to user interaction; usually because of a javascript window.close() call.\nvoid Steam::html_close_browser(HTML_CloseBrowser_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\temit_signal(\"html_close_browser\", browser_handle);\n}\n\n// Called when a browser surface has received a file open dialog from a <input type=\"file\"> click or similar, you must call\n// FileLoadDialogResponse with the file(s) the user selected.\nvoid Steam::html_file_open_dialog(HTML_FileOpenDialog_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &title = call_data->pchTitle;\n\tconst String &initial_file = call_data->pchInitialFile;\n\t// Allows you to react to a page wanting to open a file load dialog. NOTE: You MUST call this in response to a\n\t// HTML_FileOpenDialog_t callback.\n\t// So it is added here unless there is a case to use it separately.\n\tSteamHTMLSurface()->FileLoadDialogResponse(browser_handle, &call_data->pchInitialFile);\n\t// Send the signal back to the user\n\temit_signal(\"html_file_open_dialog\", browser_handle, title, initial_file);\n}\n\n// Called when a browser has finished loading a page.\nvoid Steam::html_finished_request(HTML_FinishedRequest_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &url = call_data->pchURL;\n\tconst String &title = call_data->pchPageTitle;\n\temit_signal(\"html_finished_request\", browser_handle, url, title);\n}\n\n// Called when a a browser wants to hide a tooltip.\nvoid Steam::html_hide_tooltip(HTML_HideToolTip_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\temit_signal(\"html_hide_tooltip\", browser_handle);\n}\n\n// Provides details on the visibility and size of the horizontal scrollbar.\nvoid Steam::html_horizontal_scroll(HTML_HorizontalScroll_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create dictionary to bypass argument limit in Godot\n\tDictionary scroll_data;\n\tscroll_data[\"scroll_max\"] = call_data->unScrollMax;\n\tscroll_data[\"scroll_current\"] = call_data->unScrollCurrent;\n\tscroll_data[\"page_scale\"] = call_data->flPageScale;\n\tscroll_data[\"visible\"] = call_data->bVisible;\n\tscroll_data[\"page_size\"] = call_data->unPageSize;\n\temit_signal(\"html_horizontal_scroll\", browser_handle, scroll_data);\n}\n\n// Called when the browser wants to display a Javascript alert dialog, call JSDialogResponse when the user dismisses this dialog;\n// or right away to ignore it.\nvoid Steam::html_js_alert(HTML_JSAlert_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &message = call_data->pchMessage;\n\temit_signal(\"html_js_alert\", browser_handle, message);\n}\n\n// Called when the browser wants to display a Javascript confirmation dialog, call JSDialogResponse when the user dismisses this\n// dialog; or right away to ignore it.\nvoid Steam::html_js_confirm(HTML_JSConfirm_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &message = call_data->pchMessage;\n\temit_signal(\"html_js_confirm\", browser_handle, message);\n}\n\n// Result of a call to GetLinkAtPosition.\nvoid Steam::html_link_at_position(HTML_LinkAtPosition_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create dictionary to bypass Godot argument limit\n\tDictionary link_data;\n\tlink_data[\"x\"] = call_data->x;\n\tlink_data[\"y\"] = call_data->y;\n\tlink_data[\"url\"] = call_data->pchURL;\n\tlink_data[\"input\"] = call_data->bInput;\n\tlink_data[\"live_link\"] = call_data->bLiveLink;\n\temit_signal(\"html_link_at_position\", browser_handle, link_data);\n}\n\n// Called when a browser surface has a pending paint. This is where you get the actual image data to render to the screen.\nvoid Steam::html_needs_paint(HTML_NeedsPaint_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create dictionary to bypass Godot argument limit\n\tDictionary page_data;\n\tpage_data[\"bgra\"] = call_data->pBGRA;\n\tpage_data[\"wide\"] = call_data->unWide;\n\tpage_data[\"tall\"] = call_data->unTall;\n\tpage_data[\"update_x\"] = call_data->unUpdateX;\n\tpage_data[\"update_y\"] = call_data->unUpdateY;\n\tpage_data[\"update_wide\"] = call_data->unUpdateWide;\n\tpage_data[\"update_tall\"] = call_data->unUpdateTall;\n\tpage_data[\"scroll_x\"] = call_data->unScrollX;\n\tpage_data[\"scroll_y\"] = call_data->unScrollY;\n\tpage_data[\"page_scale\"] = call_data->flPageScale;\n\tpage_data[\"page_serial\"] = call_data->unPageSerial;\n\temit_signal(\"html_needs_paint\", browser_handle, page_data);\n}\n\n// A browser has created a new HTML window.\nvoid Steam::html_new_window(HTML_NewWindow_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create a dictionary to bypass Godot argument limit\n\tDictionary window_data;\n\twindow_data[\"url\"] = call_data->pchURL;\n\twindow_data[\"x\"] = call_data->unX;\n\twindow_data[\"y\"] = call_data->unY;\n\twindow_data[\"wide\"] = call_data->unWide;\n\twindow_data[\"tall\"] = call_data->unTall;\n\twindow_data[\"new_handle\"] = call_data->unNewWindow_BrowserHandle_IGNORE;\n\temit_signal(\"html_new_window\", browser_handle, window_data);\n}\n\n// The browser has requested to load a url in a new tab.\nvoid Steam::html_open_link_in_new_tab(HTML_OpenLinkInNewTab_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &url = call_data->pchURL;\n\temit_signal(\"html_open_link_in_new_tab\", browser_handle, url);\n}\n\n// Results from a search.\nvoid Steam::html_search_results(HTML_SearchResults_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tuint32 results = call_data->unResults;\n\tuint32 current_match = call_data->unCurrentMatch;\n\temit_signal(\"html_search_results\", browser_handle, results, current_match);\n}\n\n// Called when a browser wants to change the mouse cursor.\nvoid Steam::html_set_cursor(HTML_SetCursor_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tuint32 mouse_cursor = call_data->eMouseCursor;\n\temit_signal(\"html_set_cursor\", browser_handle, mouse_cursor);\n}\n\n// Called when a browser wants to display a tooltip.\nvoid Steam::html_show_tooltip(HTML_ShowToolTip_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &message = call_data->pchMsg;\n\temit_signal(\"html_show_tooltip\", browser_handle, message);\n}\n\n// Called when a browser wants to navigate to a new page.\nvoid Steam::html_start_request(HTML_StartRequest_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &url = call_data->pchURL;\n\tconst String &target = call_data->pchTarget;\n\tconst String &post_data = call_data->pchPostData;\n\tbool redirect = call_data->bIsRedirect;\n\temit_signal(\"html_start_request\", browser_handle, url, target, post_data, redirect);\n}\n\n// Called when a browser wants you to display an informational message. This is most commonly used when you hover over links.\nvoid Steam::html_status_text(HTML_StatusText_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &message = call_data->pchMsg;\n\temit_signal(\"html_status_text\", browser_handle, message);\n}\n\n// Called when the text of an existing tooltip has been updated.\nvoid Steam::html_update_tooltip(HTML_UpdateToolTip_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\tconst String &message = call_data->pchMsg;\n\temit_signal(\"html_update_tooltip\", browser_handle, message);\n}\n\n// Called when the browser is navigating to a new url.\nvoid Steam::html_url_changed(HTML_URLChanged_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create a dictionary to bypass Godot argument limit\n\tDictionary url_data;\n\turl_data[\"url\"] = call_data->pchURL;\n\turl_data[\"post_data\"] = call_data->pchPostData;\n\turl_data[\"redirect\"] = call_data->bIsRedirect;\n\turl_data[\"title\"] = call_data->pchPageTitle;\n\turl_data[\"new_navigation\"] = call_data->bNewNavigation;\n\temit_signal(\"html_url_changed\", browser_handle, url_data);\n}\n\n// Provides details on the visibility and size of the vertical scrollbar.\nvoid Steam::html_vertical_scroll(HTML_VerticalScroll_t *call_data) {\n\tbrowser_handle = call_data->unBrowserHandle;\n\t// Create dictionary to bypass argument limit in Godot\n\tDictionary scroll_data;\n\tscroll_data[\"scroll_max\"] = call_data->unScrollMax;\n\tscroll_data[\"scroll_current\"] = call_data->unScrollCurrent;\n\tscroll_data[\"page_scale\"] = call_data->flPageScale;\n\tscroll_data[\"visible\"] = call_data->bVisible;\n\tscroll_data[\"page_size\"] = call_data->unPageSize;\n\temit_signal(\"html_vertical_scroll\", browser_handle, scroll_data);\n}\n\n\n///// HTTP\n\n// Result when an HTTP request completes. If you're using GetHTTPStreamingResponseBodyData then you should be using the\n// HTTPRequestHeadersReceived_t or HTTPRequestDataReceived_t.\nvoid Steam::http_request_completed(HTTPRequestCompleted_t *call_data) {\n\tuint32 cookie_handle = call_data->m_hRequest;\n\tuint64_t context_value = call_data->m_ulContextValue;\n\tbool request_success = call_data->m_bRequestSuccessful;\n\tint status_code = call_data->m_eStatusCode;\n\tuint32 body_size = call_data->m_unBodySize;\n\temit_signal(\"http_request_completed\", cookie_handle, context_value, request_success, status_code, body_size);\n}\n\n// Triggered when a chunk of data is received from a streaming HTTP request.\nvoid Steam::http_request_data_received(HTTPRequestDataReceived_t *call_data) {\n\tuint32 cookie_handle = call_data->m_hRequest;\n\tuint64_t context_value = call_data->m_ulContextValue;\n\tuint32 offset = call_data->m_cOffset;\n\tuint32 bytes_received = call_data->m_cBytesReceived;\n\temit_signal(\"http_request_data_received\", cookie_handle, context_value, offset, bytes_received);\n}\n\n// Triggered when HTTP headers are received from a streaming HTTP request.\nvoid Steam::http_request_headers_received(HTTPRequestHeadersReceived_t *call_data) {\n\tuint32 cookie_handle = call_data->m_hRequest;\n\tuint64_t context_value = call_data->m_ulContextValue;\n\temit_signal(\"http_request_headers_received\", cookie_handle, context_value);\n}\n\n\n///// INPUT\n\n// Purpose: when callbacks are enabled this fires each time a controller action state changes\nvoid Steam::inputActionEventCallback(SteamInputActionEvent_t *call_data) {\n\tuint64_t input_handle = call_data->controllerHandle;\n\tESteamInputActionEventType event_type = call_data->eEventType;\n\n\tbool is_active;\n\tDictionary data;\n\tuint64_t action_handle;\n\n\tswitch (event_type) {\n\t\tcase ESteamInputActionEventType_AnalogAction: {\n\t\t\tis_active = call_data->analogAction.analogActionData.bActive;\n\t\t\taction_handle = call_data->analogAction.actionHandle;\n\n\t\t\tdata[\"mode\"] = call_data->analogAction.analogActionData.eMode;\n\t\t\tdata[\"x\"] = call_data->analogAction.analogActionData.x;\n\t\t\tdata[\"y\"] = call_data->analogAction.analogActionData.y;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase ESteamInputActionEventType_DigitalAction: {\n\t\t\tis_active = call_data->digitalAction.digitalActionData.bActive;\n\t\t\taction_handle = call_data->digitalAction.actionHandle;\n\n\t\t\tdata[\"state\"] = call_data->digitalAction.digitalActionData.bState;\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn;\n\t}\n\temit_signal(\"input_action_event\", input_handle, event_type, action_handle, is_active, data);\n}\n\n// Purpose: called when a new controller has been connected, will fire once per controller if multiple new controllers connect in\n// the same frame\nvoid Steam::input_device_connected(SteamInputDeviceConnected_t *call_data) {\n\tuint64_t input_handle = call_data->m_ulConnectedDeviceHandle;\n\temit_signal(\"input_device_connected\", input_handle);\n}\n\n// Purpose: called when a new controller has been connected, will fire once per controller if multiple new controllers connect in\n// the same frame\nvoid Steam::input_device_disconnected(SteamInputDeviceDisconnected_t *call_data) {\n\tuint64_t input_handle = call_data->m_ulDisconnectedDeviceHandle;\n\temit_signal(\"input_device_disconnected\", input_handle);\n}\n\n// Purpose: called when a controller configuration has been loaded, will fire once per controller per focus change for Steam Input\n// enabled controllers\nvoid Steam::input_configuration_loaded(SteamInputConfigurationLoaded_t *call_data) {\n\tuint32_t app_id = call_data->m_unAppID;\n\tuint64_t device_handle = call_data->m_ulDeviceHandle;\n\t// Split into a dictionary since Godot won't allow more than 6 arguments sent back\n\tDictionary config_data;\n\tuint64_t mapping_creator = call_data->m_ulMappingCreator.ConvertToUint64();\n\tconfig_data[\"mapping_creator\"] = mapping_creator;\n\tconfig_data[\"major_revision\"] = call_data->m_unMajorRevision; // uint32\n\tconfig_data[\"minor_revision\"] = call_data->m_unMinorRevision; // uint32\n\tconfig_data[\"uses_steam_input_api\"] = call_data->m_bUsesSteamInputAPI; // bool\n\tconfig_data[\"uses_gamepad_api\"] = call_data->m_bUsesGamepadAPI; // bool\n\temit_signal(\"input_configuration_loaded\", app_id, device_handle, config_data);\n}\n\n// Called when controller gamepad slots change - on Linux/macOS these slots are shared for all running apps.\nvoid Steam::input_gamepad_slot_change(SteamInputGamepadSlotChange_t *call_data) {\n\tuint32_t app_id = call_data->m_unAppID;\n\tuint64_t device_handle = call_data->m_ulDeviceHandle;\n\tint device_type = call_data->m_eDeviceType;\n\tint old_gamepad_slot = call_data->m_nOldGamepadSlot;\n\tint new_gamepad_slot = call_data->m_nNewGamepadSlot;\n\temit_signal(\"input_gamepad_slot_change\", app_id, device_handle, device_type, old_gamepad_slot, new_gamepad_slot);\n}\n\n\n///// INVENTORY\n\n// This callback is triggered whenever item definitions have been updated, which could be in response to LoadItemDefinitions or\n// any time new item definitions are available (eg, from the dynamic addition of new item types while players are still in-game).\nvoid Steam::inventory_definition_update(SteamInventoryDefinitionUpdate_t *call_data) {\n\t// Create the return array\n\tArray definitions;\n\t// Set the array size variable\n\tuint32 size = 0;\n\t// Get the item defition IDs\n\tif (SteamInventory()->GetItemDefinitionIDs(NULL, &size)) {\n\t\tSteamItemDef_t *id_array = new SteamItemDef_t[size];\n\t\tif (SteamInventory()->GetItemDefinitionIDs(id_array, &size)) {\n\t\t\t// Loop through the temporary array and populate the return array\n\t\t\tfor (uint32 i = 0; i < size; i++) {\n\t\t\t\tdefinitions.append(id_array[i]);\n\t\t\t}\n\t\t}\n\t\t// Delete the temporary array\n\t\tdelete[] id_array;\n\t}\n\t// Return the item array as a signal\n\temit_signal(\"inventory_definition_update\", definitions);\n}\n\n// Triggered when GetAllItems successfully returns a result which is newer / fresher than the last known result. (It will not\n// trigger if the inventory hasn't changed, or if results from two overlapping calls are reversed in flight and the earlier\n// result is already known to be stale/out-of-date.)\n// The regular SteamInventoryResultReady_t callback will still be triggered immediately afterwards; this is an additional\n// notification for your convenience.\nvoid Steam::inventory_full_update(SteamInventoryFullUpdate_t *call_data) {\n\t// Set the handle\n\tinventory_handle = call_data->m_handle;\n\t// Send the handle back to the user\n\temit_signal(\"inventory_full_update\", call_data->m_handle);\n}\n\n// This is fired whenever an inventory result transitions from k_EResultPending to any other completed state, see GetResultStatus\n// for the complete list of states. There will always be exactly one callback per handle.\nvoid Steam::inventory_result_ready(SteamInventoryResultReady_t *call_data) {\n\t// Get the result\n\tint result = call_data->m_result;\n\t// Get the handle and pass it over\n\tinventory_handle = call_data->m_handle;\n\temit_signal(\"inventory_result_ready\", result, inventory_handle);\n}\n\n\n///// MATCHMAKING\n\n// Called when an account on your favorites list is updated\nvoid Steam::favorites_list_accounts_updated(FavoritesListAccountsUpdated_t *call_data) {\n\tint result = call_data->m_eResult;\n\temit_signal(\"favorites_list_accounts_updated\", result);\n}\n\n// A server was added/removed from the favorites list, you should refresh now.\nvoid Steam::favorites_list_changed(FavoritesListChanged_t *call_data) {\n\tDictionary favorite;\n\tfavorite[\"ip\"] = getStringFromIP(call_data->m_nIP);\n\tfavorite[\"query_port\"] = call_data->m_nQueryPort;\n\tfavorite[\"connection_port\"] = call_data->m_nConnPort;\n\tfavorite[\"app_id\"] = call_data->m_nAppID;\n\tfavorite[\"flags\"] = call_data->m_nFlags;\n\tfavorite[\"add\"] = call_data->m_bAdd;\n\tfavorite[\"account_id\"] = call_data->m_unAccountId;\n\temit_signal(\"favorites_list_changed\", favorite);\n}\n\n// Signal when a lobby chat message is received\nvoid Steam::lobby_message(LobbyChatMsg_t *call_data) {\n\tCSteamID lobby_id = call_data->m_ulSteamIDLobby;\n\tCSteamID user_id = call_data->m_ulSteamIDUser;\n\tuint8 chat_type = call_data->m_eChatEntryType;\n\t// Convert the chat type over\n\tEChatEntryType type = (EChatEntryType)chat_type;\n\t// Get the chat message data\n\tchar buffer[STEAM_LARGE_BUFFER_SIZE];\n\tint size = SteamMatchmaking()->GetLobbyChatEntry(lobby_id, call_data->m_iChatID, &user_id, &buffer, STEAM_LARGE_BUFFER_SIZE, &type);\n\tuint64_t lobby = lobby_id.ConvertToUint64();\n\tuint64_t user = user_id.ConvertToUint64();\n\temit_signal(\"lobby_message\", lobby, user, String::utf8(buffer, size), chat_type);\n}\n\n// A lobby chat room state has changed, this is usually sent when a user has joined or left the lobby.\nvoid Steam::lobby_chat_update(LobbyChatUpdate_t *call_data) {\n\tuint64_t lobby_id = call_data->m_ulSteamIDLobby;\n\tuint64_t changed_id = call_data->m_ulSteamIDUserChanged;\n\tuint64_t making_change_id = call_data->m_ulSteamIDMakingChange;\n\tuint32 chat_state = call_data->m_rgfChatMemberStateChange;\n\temit_signal(\"lobby_chat_update\", lobby_id, changed_id, making_change_id, chat_state);\n}\n\n// The lobby metadata has changed.\nvoid Steam::lobby_data_update(LobbyDataUpdate_t *call_data) {\n\tuint64_t member_id = call_data->m_ulSteamIDMember;\n\tuint64_t lobby_id = call_data->m_ulSteamIDLobby;\n\tuint8 success = call_data->m_bSuccess;\n\temit_signal(\"lobby_data_update\", success, lobby_id, member_id);\n}\n\n// Posted if a user is forcefully removed from a lobby; can occur if a user loses connection to Steam.\nvoid Steam::lobby_kicked(LobbyKicked_t *call_data) {\n\tCSteamID steam_lobby_id = call_data->m_ulSteamIDLobby;\n\tuint64_t lobby_id = steam_lobby_id.ConvertToUint64();\n\tCSteamID steam_admin_id = call_data->m_ulSteamIDAdmin;\n\tuint64_t admin_id = steam_admin_id.ConvertToUint64();\n\tuint8 due_to_disconnect = call_data->m_bKickedDueToDisconnect;\n\temit_signal(\"lobby_kicked\", lobby_id, admin_id, due_to_disconnect);\n}\n\n// Received upon attempting to enter a lobby. Lobby metadata is available to use immediately after receiving this.\nvoid Steam::lobby_joined(LobbyEnter_t *lobby_data) {\n\tCSteamID steam_lobby_id = lobby_data->m_ulSteamIDLobby;\n\tuint64_t lobby_id = steam_lobby_id.ConvertToUint64();\n\tuint32_t permissions = lobby_data->m_rgfChatPermissions;\n\tbool locked = lobby_data->m_bLocked;\n\tuint32_t response = lobby_data->m_EChatRoomEnterResponse;\n\temit_signal(\"lobby_joined\", lobby_id, permissions, locked, response);\n}\n\n// A game server has been set via SetLobbyGameServer for all of the members of the lobby to join. It's up to the individual\n// clients to take action on this; the typical game behavior is to leave the lobby and connect to the specified game server; but\n// the lobby may stay open throughout the session if desired.\nvoid Steam::lobby_game_created(LobbyGameCreated_t *call_data) {\n\tuint64_t lobby_id = call_data->m_ulSteamIDLobby;\n\tuint64_t server_id = call_data->m_ulSteamIDGameServer;\n\tuint32 ip = call_data->m_unIP;\n\tuint16 port = call_data->m_usPort;\n\temit_signal(\"lobby_game_created\", lobby_id, server_id, getStringFromIP(ip), port);\n}\n\n// Someone has invited you to join a Lobby. Normally you don't need to do anything with this, as the Steam UI will also display\n// a '<user> has invited you to the lobby, join?' notification and message. If the user outside a game chooses to join, your game\n// will be launched with the parameter +connect_lobby <64-bit lobby id>, or with the callback GameLobbyJoinRequested_t if they're\n// already in-game.\nvoid Steam::lobby_invite(LobbyInvite_t *lobby_data) {\n\tCSteamID inviter_id = lobby_data->m_ulSteamIDUser;\n\tuint64_t inviter = inviter_id.ConvertToUint64();\n\tCSteamID lobby_id = lobby_data->m_ulSteamIDLobby;\n\tuint64_t lobby = lobby_id.ConvertToUint64();\n\tCSteamID game_id = lobby_data->m_ulGameID;\n\tuint64_t game = game_id.ConvertToUint64();\n\temit_signal(\"lobby_invite\", inviter, lobby, game);\n}\n\n\n///// MATCHMAKING SERVER\n\n// A server has responded to a list request.\nvoid Steam::ServerResponded(HServerListRequest list_request_handle, int server){\n\temit_signal(\"request_server_list_server_responded\", (uint64_t)list_request_handle, server);\n}\n\n// A server has failed to respond to a list request.\nvoid Steam::ServerFailedToRespond(HServerListRequest list_request_handle, int server){\n\temit_signal(\"request_server_list_server_failed_to_respond\", (uint64_t)list_request_handle, server);\n}\n\n// A server list request has completed.\nvoid Steam::RefreshComplete(HServerListRequest list_request_handle, EMatchMakingServerResponse response){\n\temit_signal(\"request_server_list_refresh_complete\", (uint64_t)list_request_handle, MatchMakingServerResponse(response));\n}\n\n// The server has responded to a ping request.\nvoid Steam::ServerResponded(gameserveritem_t &server){\n\temit_signal(\"ping_server_responded\", gameServerItemToDictionary(&server));\n}\n\n// The server has failed to respond to a ping request.\nvoid Steam::ServerFailedToRespond(){\n\temit_signal(\"ping_server_failed_to_respond\");\n}\n\n// The server has responded to a player details request.\nvoid Steam::AddPlayerToList(const char *player_name, int score, float time_played){\n\temit_signal(\"player_details_player_added\", String(player_name), score, time_played);\n}\n\nvoid Steam::PlayersFailedToRespond(){\n\temit_signal(\"player_details_failed_to_respond\");\n}\n\nvoid Steam::PlayersRefreshComplete(){\n\temit_signal(\"player_details_refresh_complete\");\n}\n\nvoid Steam::RulesResponded(const char *rule, const char *value){\n\temit_signal(\"server_rules_responded\", String(rule), String(value));\n}\n\nvoid Steam::RulesFailedToRespond(){\n\temit_signal(\"server_rules_failed_to_respond\");\n}\n\nvoid Steam::RulesRefreshComplete(){\n\temit_signal(\"server_rules_refresh_complete\");\n}\n\n\n///// MUSIC\n\n// No notes about this in the Steam docs, but we can assume it just updates us about the plaback status\nvoid Steam::music_playback_status_has_changed(PlaybackStatusHasChanged_t* call_data) {\n\temit_signal(\"music_playback_status_has_changed\");\n}\n\n// No notes about this in the Steam docs, but we can assume it just updates us about the volume changes\nvoid Steam::music_volume_has_changed(VolumeHasChanged_t* call_data) {\n\tfloat new_volume = call_data->m_flNewVolume;\n\temit_signal(\"music_volume_has_changed\", new_volume);\n}\n\n\n///// MUSIC REMOTE\n\n// The majority of callback for Music Remote have no fields and no descriptions. They seem to be primarily fired as responses to\n// functions.\nvoid Steam::music_player_remote_to_front(MusicPlayerRemoteToFront_t *call_data) {\n\temit_signal(\"music_player_remote_to_front\");\n}\nvoid Steam::music_player_remote_will_activate(MusicPlayerRemoteWillActivate_t *call_data) {\n\temit_signal(\"music_player_remote_will_activate\");\n}\nvoid Steam::music_player_remote_will_deactivate(MusicPlayerRemoteWillDeactivate_t *call_data) {\n\temit_signal(\"music_player_remote_will_deactivate\");\n}\nvoid Steam::music_player_selects_playlist_entry(MusicPlayerSelectsPlaylistEntry_t *call_data) {\n\tint entry = call_data->nID;\n\temit_signal(\"music_player_selects_playlist_entry\", entry);\n}\nvoid Steam::music_player_selects_queue_entry(MusicPlayerSelectsQueueEntry_t *call_data) {\n\tint entry = call_data->nID;\n\temit_signal(\"music_player_selects_queue_entry\", entry);\n}\nvoid Steam::music_player_wants_looped(MusicPlayerWantsLooped_t *call_data) {\n\tbool looped = call_data->m_bLooped;\n\temit_signal(\"music_player_wants_looped\", looped);\n}\nvoid Steam::music_player_wants_pause(MusicPlayerWantsPause_t *call_data) {\n\temit_signal(\"music_player_wants_pause\");\n}\nvoid Steam::music_player_wants_playing_repeat_status(MusicPlayerWantsPlayingRepeatStatus_t *call_data) {\n\tint status = call_data->m_nPlayingRepeatStatus;\n\temit_signal(\"music_player_wants_playing_repeat_status\", status);\n}\nvoid Steam::music_player_wants_play_next(MusicPlayerWantsPlayNext_t *call_data) {\n\temit_signal(\"music_player_wants_play_next\");\n}\nvoid Steam::music_player_wants_play_previous(MusicPlayerWantsPlayPrevious_t *call_data) {\n\temit_signal(\"music_player_wants_play_previous\");\n}\nvoid Steam::music_player_wants_play(MusicPlayerWantsPlay_t *call_data) {\n\temit_signal(\"music_player_wants_play\");\n}\nvoid Steam::music_player_wants_shuffled(MusicPlayerWantsShuffled_t *call_data) {\n\tbool shuffled = call_data->m_bShuffled;\n\temit_signal(\"music_player_wants_shuffled\", shuffled);\n}\nvoid Steam::music_player_wants_volume(MusicPlayerWantsVolume_t *call_data) {\n\tfloat volume = call_data->m_flNewVolume;\n\temit_signal(\"music_player_wants_volume\", volume);\n}\nvoid Steam::music_player_will_quit(MusicPlayerWillQuit_t *call_data) {\n\temit_signal(\"music_player_will_quit\");\n}\n\n\n///// NETWORKING\n\n// Called when packets can't get through to the specified user. All queued packets unsent at this point will be dropped, further\n// attempts to send will retry making the connection (but will be dropped if we fail again).\nvoid Steam::p2p_session_connect_fail(P2PSessionConnectFail_t *call_data) {\n\tuint64_t remote_steam_id = call_data->m_steamIDRemote.ConvertToUint64();\n\tuint8_t session_error = call_data->m_eP2PSessionError;\n\temit_signal(\"p2p_session_connect_fail\", remote_steam_id, session_error);\n}\n\n// A user wants to communicate with us over the P2P channel via the sendP2PPacket. In response, a call to acceptP2PSessionWithUser\n// needs to be made, if you want to open the network channel with them.\nvoid Steam::p2p_session_request(P2PSessionRequest_t *call_data) {\n\tuint64_t remote_steam_id = call_data->m_steamIDRemote.ConvertToUint64();\n\temit_signal(\"p2p_session_request\", remote_steam_id);\n}\n\n\n///// NETWORKING MESSAGES\n\n// Posted when a remote host is sending us a message, and we do not already have a session with them.\nvoid Steam::network_messages_session_request(SteamNetworkingMessagesSessionRequest_t *call_data) {\n\temit_signal(\"network_messages_session_request\", getSteamIDFromIdentity(call_data->m_identityRemote));\n}\n\n// Posted when we fail to establish a connection, or we detect that communications have been disrupted it an unusual way.\nvoid Steam::network_messages_session_failed(SteamNetworkingMessagesSessionFailed_t *call_data) {\n\tSteamNetConnectionInfo_t info = call_data->m_info;\n\tint reason = info.m_eEndReason;\n\tuint64_t remote_steam_id = getSteamIDFromIdentity(info.m_identityRemote);\n\tint connection_state = (int)info.m_eState;\n\tString debug_message = (String)info.m_szEndDebug;\n\temit_signal(\"network_messages_session_failed\", reason, remote_steam_id, connection_state, debug_message);\n}\n\n\n///// NETWORKING SOCKETS\n\n// A struct used to describe a \"fake IP\" we have been assigned to use as an identifier.\n// This callback is posted when ISteamNetworkingSoockets::BeginAsyncRequestFakeIP completes.\nvoid Steam::fake_ip_result(SteamNetworkingFakeIPResult_t *call_data) {\n\tint result = call_data->m_eResult;\n\tuint32 fake_ip = call_data->m_unIP;\n\t// Get the ports as an array\n\tPackedInt32Array port_list;\n\tport_list.resize(SteamNetworkingFakeIPResult_t::k_nMaxReturnPorts);\n\tfor (uint16 i = 0; i < SteamNetworkingFakeIPResult_t::k_nMaxReturnPorts; i++) {\n\t\tport_list.write[i] = call_data->m_unPorts[i];\n\t}\n\temit_signal(\"fake_ip_result\", result, getSteamIDFromIdentity(call_data->m_identity), getStringFromIP(fake_ip), port_list);\n}\n\n// This callback is posted whenever the state of our readiness changes.\nvoid Steam::network_authentication_status(SteamNetAuthenticationStatus_t *call_data) {\n\tint available = call_data->m_eAvail;\n\t// Non-localized English language status. For diagnostic / debugging purposes only.\n\tchar debug_message[256 + 1]{};\n\tsnprintf(debug_message, 256, \"%s\", call_data->m_debugMsg);\n\t// Send the data back via signal\n\temit_signal(\"network_authentication_status\", available, debug_message);\n}\n\n// This callback is posted whenever a connection is created, destroyed, or changes state. The m_info field will contain a complete\n// description of the connection at the time the change occurred and the callback was posted. In particular, m_info.m_eState will have the new connection state.\nvoid Steam::network_connection_status_changed(SteamNetConnectionStatusChangedCallback_t *call_data) {\n\tuint32_t connection_handle = call_data->m_hConn;\n\tSteamNetConnectionInfo_t connection_info = call_data->m_info;\n\t\n\tDictionary connection;\n\tconnection[\"identity\"] = getSteamIDFromIdentity(connection_info.m_identityRemote);\n\tconnection[\"user_data\"] = (uint64_t)connection_info.m_nUserData;\n\tconnection[\"listen_socket\"] = connection_info.m_hListenSocket;\n\tconnection[\"remote_address\"] = getStringFromSteamIP(connection_info.m_addrRemote);\n\tconnection[\"remote_pop\"] = connection_info.m_idPOPRemote;\n\tconnection[\"pop_relay\"] = connection_info.m_idPOPRelay;\n\tconnection[\"connection_state\"] = connection_info.m_eState;\n\tconnection[\"end_reason\"] = connection_info.m_eEndReason;\n\tconnection[\"end_debug\"] = connection_info.m_szEndDebug;\n\tconnection[\"debug_description\"] = connection_info.m_szConnectionDescription;\n\t// Previous state (current state is in m_info.m_eState).\n\tint old_state = call_data->m_eOldState;\n\temit_signal(\"network_connection_status_changed\", connection_handle, connection, old_state);\n}\n\n\n///// NETWORKING UTILS\n\n// A struct used to describe our readiness to use the relay network.\nvoid Steam::relay_network_status(SteamRelayNetworkStatus_t *call_data) {\n\tint available = call_data->m_eAvail;\n\tint ping_measurement = call_data->m_bPingMeasurementInProgress;\n\tint available_config = call_data->m_eAvailNetworkConfig;\n\tint available_relay = call_data->m_eAvailAnyRelay;\n\tchar debug_message[256 + 1]{};\n\tsnprintf(debug_message, 256, \"%s\", call_data->m_debugMsg);\n\t//\tdebug_message = call_data->m_debugMsg;\n\temit_signal(\"relay_network_status\", available, ping_measurement, available_config, available_relay, debug_message);\n}\n\n\n///// PARENTAL SETTINGS\n\n// Purpose: Callback for querying UGC\nvoid Steam::parental_setting_changed(SteamParentalSettingsChanged_t *call_data) {\n\temit_signal(\"parental_setting_changed\");\n}\n\n\n///// PARTIES\n\n// After creating a beacon, when a user \"follows\" that beacon Steam will send you this callback to know that you should be\n// prepared for the user to join your game. When they do join, be sure to call ISteamParties::OnReservationCompleted to let Steam\n// know.\nvoid Steam::reservation_notification(ReservationNotificationCallback_t *call_data) {\n\tuint64_t beacon_id = call_data->m_ulBeaconID;\n\tuint64_t steam_id = call_data->m_steamIDJoiner.ConvertToUint64();\n\temit_signal(\"reservation_notifications\", beacon_id, steam_id);\n}\n\n// Notification that the list of available locations for posting a beacon has been updated.\nvoid Steam::available_beacon_locations_updated(AvailableBeaconLocationsUpdated_t *call_data) {\n\temit_signal(\"available_beacon_locations_updated\");\n}\n\n// Notification that the list of active beacons visible to the current user has changed.\nvoid Steam::active_beacons_updated(ActiveBeaconsUpdated_t *call_data) {\n\temit_signal(\"active_beacons_updated\");\n}\n\n\n///// REMOTE PLAY\n\n// The session ID of the session that just connected.\nvoid Steam::remote_play_session_connected(SteamRemotePlaySessionConnected_t *call_data) {\n\tuint32 session_id = call_data->m_unSessionID;\n\temit_signal(\"remote_play_session_connected\", session_id);\n}\n\n// The session ID of the session that just disconnected.\nvoid Steam::remote_play_session_disconnected(SteamRemotePlaySessionDisconnected_t *call_data) {\n\tuint32 session_id = call_data->m_unSessionID;\n\temit_signal(\"remote_play_session_disconnected\", session_id);\n}\n\n\n///// REMOTE STORAGE\n\n// Purpose: one or more files for this app have changed locally after syncing to remote session changes.\n// Note: only posted if this happens DURING the local app session.\nvoid Steam::local_file_changed(RemoteStorageLocalFileChange_t *call_data) {\n\temit_signal(\"local_file_changed\");\n}\n\n\n///// SCREENSHOT\n\n// A screenshot successfully written or otherwise added to the library and can now be tagged.\nvoid Steam::screenshot_ready(ScreenshotReady_t *call_data) {\n\tuint32_t handle = call_data->m_hLocal;\n\tuint32_t result = call_data->m_eResult;\n\temit_signal(\"screenshot_ready\", handle, result);\n}\n\n// A screenshot has been requested by the user from the Steam screenshot hotkey. This will only be called if hookScreenshots has\n// been enabled, in which case Steam will not take the screenshot itself.\nvoid Steam::screenshot_requested(ScreenshotRequested_t *call_data) {\n\temit_signal(\"screenshot_requested\");\n}\n\n\n///// UGC\n\n// Called when a workshop item has been downloaded.\nvoid Steam::item_downloaded(DownloadItemResult_t *call_data) {\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tAppId_t app_id = call_data->m_unAppID;\n\temit_signal(\"item_downloaded\", result, (uint64_t)file_id, (uint32_t)app_id);\n}\n\n// Called when a workshop item has been installed or updated.\nvoid Steam::item_installed(ItemInstalled_t *call_data) {\n\tAppId_t app_id = call_data->m_unAppID;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tUGCHandle_t legacy_content = call_data->m_hLegacyContent;\n\tuint64_t manifest_id = call_data->m_unManifestID;\n\temit_signal(\"item_installed\", app_id, (uint64_t)file_id, (uint64_t)legacy_content, manifest_id);\n}\n\n// Purpose: signal that the list of subscribed items changed.\nvoid Steam::user_subscribed_items_list_changed(UserSubscribedItemsListChanged_t *call_data) {\n\tuint32 app_id = call_data->m_nAppID;\n\temit_signal(\"user_subscribed_items_list_changed\", app_id);\n}\n\n\n///// USER\n\n// Sent by the Steam server to the client telling it to disconnect from the specified game server, which it may be in the process\n// of or already connected to. The game client should immediately disconnect upon receiving this message. This can usually occur\n// if the user doesn't have rights to play on the game server.\nvoid Steam::client_game_server_deny(ClientGameServerDeny_t *call_data) {\n\tuint32 app_id = call_data->m_uAppID;\n\tuint32 server_ip = call_data->m_unGameServerIP;\n\tuint16 server_port = call_data->m_usGameServerPort;\n\tuint16 secure = call_data->m_bSecure;\n\tuint32 reason = call_data->m_uReason;\n\temit_signal(\"client_game_server_deny\", app_id, getStringFromIP(server_ip), server_port, secure, reason);\n}\n\n// Sent to your game in response to a steam://gamewebcallback/ command from a user clicking a link in the Steam overlay browser.\n// You can use this to add support for external site signups where you want to pop back into the browser after some web page signup\n// sequence, and optionally get back some detail about that.\nvoid Steam::game_web_callback(GameWebCallback_t *call_data) {\n\tString url = call_data->m_szURL;\n\temit_signal(\"game_web_callback\", url);\n}\n\n// Result when creating an auth session ticket.\nvoid Steam::get_auth_session_ticket_response(GetAuthSessionTicketResponse_t *call_data) {\n\tuint32 auth_ticket = call_data->m_hAuthTicket;\n\tint result = call_data->m_eResult;\n\temit_signal(\"get_auth_session_ticket_response\", auth_ticket, result);\n}\n\n// Result when creating an webapi ticket from GetAuthTicketForWebApi.\nvoid Steam::get_ticket_for_web_api(GetTicketForWebApiResponse_t *call_data) {\n\tuint32 auth_ticket = call_data->m_hAuthTicket;\n\tint result = call_data->m_eResult;\n\tint ticket_size = call_data->m_cubTicket;\n\tPackedByteArray ticket_buffer;\n\tticket_buffer.resize(ticket_size);\n\tfor (auto i = 0; i < ticket_size; i++) {\n\t\tticket_buffer.set(i, call_data->m_rgubTicket[i]);\n\t}\n\temit_signal(\"get_ticket_for_web_api\", auth_ticket, result, ticket_size, ticket_buffer);\n}\n\n// Called when the callback system for this client is in an error state (and has flushed pending callbacks). When getting this\n// message the client should disconnect from Steam, reset any stored Steam state and reconnect. This usually occurs in the rare\n// event the Steam client has some kind of fatal error.\nvoid Steam::ipc_failure(IPCFailure_t *call_data) {\n\tuint8 type = call_data->m_eFailureType;\n\temit_signal(\"ipc_failure\", type);\n}\n\n// Called whenever the users licenses (owned packages) changes.\nvoid Steam::licenses_updated(LicensesUpdated_t *call_data) {\n\temit_signal(\"licenses_updated\");\n}\n\n// Called when a user has responded to a microtransaction authorization request.\nvoid Steam::microtransaction_auth_response(MicroTxnAuthorizationResponse_t *call_data) {\n\tuint32 app_id = call_data->m_unAppID;\n\tuint64_t order_id = call_data->m_ulOrderID;\n\tbool authorized;\n\tif (call_data->m_bAuthorized == 1) {\n\t\tauthorized = true;\n\t}\n\telse {\n\t\tauthorized = false;\n\t}\n\temit_signal(\"microtransaction_auth_response\", app_id, order_id, authorized);\n}\n\n// Called when a connections to the Steam back-end has been established. This means the Steam client now has a working connection\n// to the Steam servers. Usually this will have occurred before the game has launched, and should only be seen if the user has\n// dropped connection due to a networking issue or a Steam server update.\nvoid Steam::steam_server_connected(SteamServersConnected_t *connect_data) {\n\temit_signal(\"steam_server_connected\");\n}\n\n// Called if the client has lost connection to the Steam servers. Real-time services will be disabled until a matching\n// SteamServersConnected_t has been posted.\nvoid Steam::steam_server_disconnected(SteamServersDisconnected_t *connect_data) {\n\temit_signal(\"steam_server_disconnected\");\n}\n\n// Called when an auth ticket has been validated.\nvoid Steam::validate_auth_ticket_response(ValidateAuthTicketResponse_t *call_data) {\n\tuint64_t auth_id = call_data->m_SteamID.ConvertToUint64();\n\tuint32_t response = call_data->m_eAuthSessionResponse;\n\tuint64_t owner_id = call_data->m_OwnerSteamID.ConvertToUint64();\n\temit_signal(\"validate_auth_ticket_response\", auth_id, response, owner_id);\n}\n\n\n///// USER STATS\n\nvoid Steam::user_achievement_icon_fetched(UserAchievementIconFetched_t *call_data) {\n\tuint64_t app_id = call_data->m_nGameID.ToUint64();\n\tString achievement_name = call_data->m_rgchAchievementName;\n\tbool achieved = call_data->m_bAchieved;\n\tint icon_handle = call_data->m_nIconHandle;\n\temit_signal(\"user_achievement_icon_fetched\", app_id, achievement_name, achieved, icon_handle);\n}\n\n// Result of a request to store the achievements on the server, or an \"indicate progress\" call. If both m_nCurProgress and\n// m_nMaxProgress are zero, that means the achievement has been fully unlocked.\nvoid Steam::user_achievement_stored(UserAchievementStored_t *call_data) {\n\tCSteamID game_id = call_data->m_nGameID;\n\tuint64_t game = game_id.ConvertToUint64();\n\tbool group_achieve = call_data->m_bGroupAchievement;\n\tString name = call_data->m_rgchAchievementName;\n\tuint32_t current_progress = call_data->m_nCurProgress;\n\tuint32_t max_progress = call_data->m_nMaxProgress;\n\temit_signal(\"user_achievement_stored\", game, group_achieve, name, current_progress, max_progress);\n}\n\n// Result of a request to store the user stats.\nvoid Steam::user_stats_stored(UserStatsStored_t *call_data) {\n\tCSteamID game_id = call_data->m_nGameID;\n\tuint64_t game = game_id.ConvertToUint64();\n\tuint32_t result = call_data->m_eResult;\n\temit_signal(\"user_stats_stored\", game, result);\n}\n\n// Callback indicating that a user's stats have been unloaded. Call RequestUserStats again before accessing stats for this user.\nvoid Steam::user_stats_unloaded(UserStatsUnloaded_t *call_data) {\n\tCSteamID steam_id = call_data->m_steamIDUser;\n\tuint64_t user = steam_id.ConvertToUint64();\n\temit_signal(\"user_stats_unloaded\", user);\n}\n\n\n///// UTILITY\n\n// Called when the big picture gamepad text input has been closed.\nvoid Steam::gamepad_text_input_dismissed(GamepadTextInputDismissed_t *call_data) {\n\tbool was_submitted = call_data->m_bSubmitted;\n\tconst uint32 buffer_length = 1024;\n\tchar text[buffer_length + 1]{};\n\tuint32 length = 0;\n\tuint32_t app_id = call_data->m_unAppID;\n\tif (was_submitted) {\n\t\tSteamUtils()->GetEnteredGamepadTextInput(text, buffer_length);\n\t\tlength = SteamUtils()->GetEnteredGamepadTextLength();\n\t}\n\temit_signal(\"gamepad_text_input_dismissed\", was_submitted, String::utf8(text, (int)length), app_id);\n}\n\n// Called when the country of the user changed. The country should be updated with getIPCountry.\nvoid Steam::ip_country(IPCountry_t *call_data) {\n\temit_signal(\"ip_country\");\n}\n\n// Called when running on a laptop and less than 10 minutes of battery is left, and then fires then every minute afterwards.\nvoid Steam::low_power(LowBatteryPower_t *time_left) {\n\tuint8 power = time_left->m_nMinutesBatteryLeft;\n\temit_signal(\"low_power\", power);\n}\n\n// Called when a SteamAPICall_t has completed (or failed)\nvoid Steam::steam_api_call_completed(SteamAPICallCompleted_t *call_data) {\n\tuint64_t async_call = call_data->m_hAsyncCall;\n\tint callback = call_data->m_iCallback;\n\tuint32 parameter = call_data->m_cubParam;\n\temit_signal(\"steam_api_call_completed\", async_call, callback, parameter);\n}\n\n// Called when Steam wants to shutdown.\nvoid Steam::steam_shutdown(SteamShutdown_t *call_data) {\n\temit_signal(\"steam_shutdown\");\n}\n\n// Sent after the device returns from sleep/suspend mode.\nvoid Steam::app_resuming_from_suspend(AppResumingFromSuspend_t *call_data) {\n\temit_signal(\"app_resuming_from_suspend\");\n}\n\n// Sent after the device returns from sleep/suspend mode.\nvoid Steam::floating_gamepad_text_input_dismissed(FloatingGamepadTextInputDismissed_t *call_data) {\n\temit_signal(\"floating_gamepad_text_input_dismissed\");\n}\n\n// The text filtering dictionary has changed, obviously.\nvoid Steam::filter_text_dictionary_changed(FilterTextDictionaryChanged_t *call_data) {\n\tint language = call_data->m_eLanguage;\n\temit_signal(\"filter_text_dictionary_changed\", language);\n}\n\n\n///// VIDEO\n\n// Triggered when the OPF Details for 360 video playback are retrieved. After receiving this you can use GetOPFStringForApp to\n// access the OPF details.\nvoid Steam::get_opf_settings_result(GetOPFSettingsResult_t *call_data) {\n\tint result = call_data->m_eResult;\n\tuint32 app_id = call_data->m_unVideoAppID;\n\temit_signal(\"broadcast_upload_stop\", result, app_id);\n}\n\n// Provides the result of a call to GetVideoURL.\nvoid Steam::get_video_result(GetVideoURLResult_t *call_data) {\n\tint result = call_data->m_eResult;\n\tuint32 app_id = call_data->m_unVideoAppID;\n\tString url = call_data->m_rgchURL;\n\temit_signal(\"get_video_result\", result, app_id, url);\n}\n\n\n///// SIGNALS / CALL RESULTS\n\n///// FRIENDS\n\n// Marks the return of a request officer list call.\nvoid Steam::request_clan_officer_list(ClanOfficerListResponse_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] request_clan_officer_list signal failed internally\");\n\tArray officers_list;\n\tString message;\n\tif (!call_data->m_bSuccess) {\n\t\tmessage = \"Clan officer list response failed.\";\n\t}\n\telse {\n\t\tCSteamID owner_steam_id = SteamFriends()->GetClanOwner(call_data->m_steamIDClan);\n\t\tint officers = SteamFriends()->GetClanOfficerCount(call_data->m_steamIDClan);\n\t\tmessage = \"The owner of the clan is: \" + (String)String::utf8(SteamFriends()->GetFriendPersonaName(owner_steam_id)) + \" (\" + itos(owner_steam_id.ConvertToUint64()) + \") and there are \" + itos(call_data->m_cOfficers) + \" officers.\";\n\t\tfor (int i = 0; i < officers; i++) {\n\t\t\tDictionary officer;\n\t\t\tCSteamID officerSteamID = SteamFriends()->GetClanOfficerByIndex(call_data->m_steamIDClan, i);\n\t\t\tuint64_t id = officerSteamID.ConvertToUint64();\n\t\t\tofficer[\"id\"] = id;\n\t\t\tofficer[\"name\"] = String::utf8(SteamFriends()->GetFriendPersonaName(officerSteamID));\n\t\t\tofficers_list.append(officer);\n\t\t}\n\t}\n\temit_signal(\"request_clan_officer_list\", message, officers_list);\n}\n\n// Returns the result of enumerateFollowingList.\nvoid Steam::enumerate_following_list(FriendsEnumerateFollowingList_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] enumerate_following_list signal failed internally\");\n\tArray following;\n\tString message;\n\tif (call_data->m_eResult != k_EResultOK) {\n\t\tmessage = \"Failed to acquire list.\";\n\t}\n\telse {\n\t\tint followers_parsed = 0;\n\t\tmessage = \"Retrieved \" + itos(call_data->m_nResultsReturned) + \" of \" + itos(call_data->m_nTotalResultCount) + \" people followed.\";\n\t\tint32 count = call_data->m_nTotalResultCount;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tDictionary follow;\n\t\t\tint num = i;\n\t\t\tuint64_t id = call_data->m_rgSteamID[i].ConvertToUint64();\n\t\t\tfollow[\"num\"] = num;\n\t\t\tfollow[\"id\"] = id;\n\t\t\tfollowing.append(follow);\n\t\t}\n\t\tfollowers_parsed += call_data->m_nResultsReturned;\n\t\t// There are more followers so make another callback.\n\t\tif (followers_parsed < count) {\n\t\t\tSteamAPICall_t api_call = SteamFriends()->EnumerateFollowingList(call_data->m_nResultsReturned);\n\t\t\tcallResultEnumerateFollowingList.Set(api_call, this, &Steam::enumerate_following_list);\n\t\t}\n\t}\n\temit_signal(\"enumerate_following_list\", message, following);\n}\n\n// Call from RequestEquippedProfileItems... nice.\nvoid Steam::equipped_profile_items(EquippedProfileItems_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] equipped_profile_items signal failed internally\");\n\tint result = call_data->m_eResult;\n\tCSteamID this_steam_id = call_data->m_steamID;\n\tuint64_t steam_id = this_steam_id.ConvertToUint64();\n\tbool has_animated_avatar = call_data->m_bHasAnimatedAvatar;\n\tbool has_avatar_frame = call_data->m_bHasAvatarFrame;\n\tbool has_profile_modifier = call_data->m_bHasProfileModifier;\n\tbool has_profile_background = call_data->m_bHasProfileBackground;\n\tbool has_mini_profile_background = call_data->m_bHasMiniProfileBackground;\n\tbool from_cache = call_data->m_bFromCache;\n\t// Pass all profile data to a dictionary\n\tDictionary profile_data;\n\tprofile_data[\"avatar_animated\"] = has_animated_avatar;\n\tprofile_data[\"avatar_frame\"] = has_avatar_frame;\n\tprofile_data[\"profile_modifier\"] = has_profile_modifier;\n\tprofile_data[\"profile_background\"] = has_profile_background;\n\tprofile_data[\"profile_mini_background\"] = has_mini_profile_background;\n\tprofile_data[\"from_cache\"] = from_cache;\n\temit_signal(\"equipped_profile_items\", result, steam_id, profile_data);\n}\n\n// Returns the result of getFollowerCount.\nvoid Steam::get_follower_count(FriendsGetFollowerCount_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_follower_count signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tuint64_t steam_id = call_data->m_steamID.ConvertToUint64();\n\tint count = call_data->m_nCount;\n\temit_signal(\"follower_count\", result, steam_id, count);\n}\n\n// Returns the result of isFollowing.\nvoid Steam::is_following(FriendsIsFollowing_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] is_following signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tuint64_t steam_id = call_data->m_steamID.ConvertToUint64();\n\tbool following = call_data->m_bIsFollowing;\n\temit_signal(\"is_following\", result, steam_id, following);\n}\n\n\n///// HTML SURFACE\n\n// A new browser was created and is ready for use.\nvoid Steam::html_browser_ready(HTML_BrowserReady_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] html_browser_ready signal failed internally\");\n\tbrowser_handle = call_data->unBrowserHandle;\n\temit_signal(\"html_browser_ready\", browser_handle);\n}\n\n\n///// INVENTORY\n\n// Returned when you have requested the list of \"eligible\" promo items that can be manually granted to the given user. These are\n// promo items of type \"manual\" that won't be granted automatically.\nvoid Steam::inventory_eligible_promo_item(SteamInventoryEligiblePromoItemDefIDs_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] inventory_eligible_promo_item signal failed internally\");\n\tCSteamID steam_id = call_data->m_steamID;\n\tint result = call_data->m_result;\n\tint eligible = call_data->m_numEligiblePromoItemDefs;\n\tbool cached = call_data->m_bCachedData;\n\tArray definitions;\n\tSteamItemDef_t *id_array = new SteamItemDef_t[eligible];\n\tuint32 array_size = (int)eligible;\n\n\tif (SteamInventory()->GetEligiblePromoItemDefinitionIDs(steam_id, id_array, &array_size)) {\n\t\tfor (int i = 0; i < eligible; i++) {\n\t\t\tdefinitions.append(id_array[i]);\n\t\t}\n\t}\n\tdelete[] id_array;\n\temit_signal(\"inventory_eligible_promo_Item\", result, cached, definitions);\n}\n\n// Returned after StartPurchase is called.\nvoid Steam::inventory_start_purchase_result(SteamInventoryStartPurchaseResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] inventory_start_purchase_result signal failed internally\");\n\tif (call_data->m_result == k_EResultOK) {\n\t\tuint64_t order_id = call_data->m_ulOrderID;\n\t\tuint64_t transaction_id = call_data->m_ulTransID;\n\t\temit_signal(\"inventory_start_purchase_result\", \"success\", order_id, transaction_id);\n\t}\n\telse {\n\t\temit_signal(\"inventory_start_purchase_result\", \"failure\", 0, 0);\n\t}\n}\n\n// Returned after RequestPrices is called.\nvoid Steam::inventory_request_prices_result(SteamInventoryRequestPricesResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] inventory_request_prices_result signal failed internally\");\n\tint result = call_data->m_result;\n\tString currency = call_data->m_rgchCurrency;\n\temit_signal(\"inventory_request_prices_result\", result, currency);\n}\n\n\n///// MATCHMAKING\n\n// Signal the lobby has been created.\nvoid Steam::lobby_created(LobbyCreated_t *lobby_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] lobby_created signal failed internally\");\n\tint connect = lobby_data->m_eResult;\n\tCSteamID lobby_id = lobby_data->m_ulSteamIDLobby;\n\tuint64_t lobby = lobby_id.ConvertToUint64();\n\temit_signal(\"lobby_created\", connect, lobby);\n}\n\n// Result when requesting the lobby list. You should iterate over the returned lobbies with getLobbyByIndex, from 0 to\n// m_nLobbiesMatching-1.\nvoid Steam::lobby_match_list(LobbyMatchList_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] lobby_match_list signal failed internally\");\n\tint lobby_count = call_data->m_nLobbiesMatching;\n\tArray lobbies;\n\tfor (int i = 0; i < lobby_count; i++) {\n\t\tCSteamID lobby_id = SteamMatchmaking()->GetLobbyByIndex(i);\n\t\tuint64_t lobby = lobby_id.ConvertToUint64();\n\t\tlobbies.append(lobby);\n\t}\n\temit_signal(\"lobby_match_list\", lobbies);\n}\n\n\n///// PARTIES\n\n// This callback is used as a call response for ISteamParties::JoinParty. On success, you will have reserved a slot in the\n// beacon-owner's party, and should use m_rgchConnectString to connect to their game and complete the process.\nvoid Steam::join_party(JoinPartyCallback_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] join_party signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint64_t beacon_id = call_data->m_ulBeaconID;\n\tuint64_t steam_id = call_data->m_SteamIDBeaconOwner.ConvertToUint64();\n\tString connect_string = call_data->m_rgchConnectString;\n\temit_signal(\"join_party\", result, beacon_id, steam_id, connect_string);\n}\n\n// This callback is used as a call response for ISteamParties::CreateBeacon. If successful, your beacon has been posted in the\n// desired location and you may start receiving ISteamParties::ReservationNotificationCallback_t callbacks for users following\n// the beacon.\nvoid Steam::create_beacon(CreateBeaconCallback_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] create_beacon signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint64_t beacon_id = call_data->m_ulBeaconID;\n\temit_signal(\"create_beacon\", result, beacon_id);\n}\n\n// Call result for ISteamParties::ChangeNumOpenSlots.\nvoid Steam::change_num_open_slots(ChangeNumOpenSlotsCallback_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] change_num_open_slots signal failed internally\");\n\tint result = call_data->m_eResult;\n\temit_signal(\"change_num_open_slots\", result);\n}\n\n\n///// REMOTE STORAGE\n\n// Response when reading a file asyncrounously with FileReadAsync.\nvoid Steam::file_read_async_complete(RemoteStorageFileReadAsyncComplete_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] file_read_async_complete signal failed internally\");\n\tuint64_t handle = call_data->m_hFileReadAsync;\n\tint result = call_data->m_eResult;\n\tuint32 offset = call_data->m_nOffset;\n\tuint32 read = call_data->m_cubRead;\n\t// Was read complete?\n\tPackedByteArray buffer;\n\tbuffer.resize(read);\n\tbool complete = SteamRemoteStorage()->FileReadAsyncComplete(handle, buffer.ptrw(), read);\n\t// Create a dictionary and populate it with the results\n\tDictionary file_read;\n\tfile_read[\"result\"] = result;\n\tfile_read[\"handle\"] = handle;\n\tfile_read[\"buffer\"] = buffer;\n\tfile_read[\"offset\"] = offset;\n\tfile_read[\"read\"] = read;\n\tfile_read[\"complete\"] = complete;\n\temit_signal(\"file_read_async_complete\", file_read);\n}\n\n// Response to a file being shared.\nvoid Steam::file_share_result(RemoteStorageFileShareResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] file_share_result signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint64_t handle = call_data->m_hFile;\n\tconst char *name = call_data->m_rgchFilename;\n\temit_signal(\"file_share_result\", result, handle, name);\n}\n\n// Response when writing a file asyncrounously with FileWriteAsync.\nvoid Steam::file_write_async_complete(RemoteStorageFileWriteAsyncComplete_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] file_write_async_complete signal failed internally\");\n\tint result = call_data->m_eResult;\n\temit_signal(\"file_write_async_complete\", result);\n}\n\n// Response when downloading UGC\nvoid Steam::download_ugc_result(RemoteStorageDownloadUGCResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] download_ugc_result signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint64_t handle = call_data->m_hFile;\n\tuint32_t app_id = call_data->m_nAppID;\n\tint32 size = call_data->m_nSizeInBytes;\n\tconst char *filename = call_data->m_pchFileName;\n\tuint64_t owner_id = call_data->m_ulSteamIDOwner;\n\t// Pass some variable to download dictionary to bypass argument limit\n\tDictionary download_data;\n\tdownload_data[\"handle\"] = handle;\n\tdownload_data[\"app_id\"] = app_id;\n\tdownload_data[\"size\"] = size;\n\tdownload_data[\"filename\"] = filename;\n\tdownload_data[\"owner_id\"] = owner_id;\n\temit_signal(\"download_ugc_result\", result, download_data);\n}\n\n// Called when the user has unsubscribed from a piece of UGC. Result from ISteamUGC::UnsubscribeItem.\nvoid Steam::unsubscribe_item(RemoteStorageUnsubscribePublishedFileResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] unsubscribe_item signal failed internally\");\n\tint result = call_data->m_eResult;\n\tint file_id = call_data->m_nPublishedFileId;\n\temit_signal(\"unsubscribe_item\", result, file_id);\n}\n\n// Called when the user has subscribed to a piece of UGC. Result from ISteamUGC::SubscribeItem.\nvoid Steam::subscribe_item(RemoteStorageSubscribePublishedFileResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] subscribe_item signal failed internally\");\n\tint result = call_data->m_eResult;\n\tint file_id = call_data->m_nPublishedFileId;\n\temit_signal(\"subscribe_item\", result, file_id);\n}\n\n\n///// TIMELINE\n\n// Called when asking if recordings exist for a game phase ID.\nvoid Steam::timeline_event_recording_exists(SteamTimelineEventRecordingExists_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] timeline_event_recording_exists signal failed internally\");\n\tuint64_t event_id = call_data->m_ulEventID;\n\tbool recording_exists = call_data->m_bRecordingExists;\n\temit_signal(\"timeline_event_recording_exists\", event_id, recording_exists);\n}\n\n// Called when asking if recordings exist for an event handle.\nvoid Steam::timeline_game_phase_recording_exists(SteamTimelineGamePhaseRecordingExists_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] timeline_game_phase_recording_exists signal failed internally\");\n\tString phase_id = call_data->m_rgchPhaseID;\n\tuint64_t recording_ms = call_data->m_ulRecordingMS;\n\tuint64_t longest_clips_ms = call_data->m_ulLongestClipMS;\n\tuint32_t clip_count = call_data->m_unClipCount;\n\tuint32_t screenshot_count = call_data->m_unScreenshotCount;\n\temit_signal(\"timeline_game_phase_recording_exists\", phase_id, recording_ms, longest_clips_ms, clip_count, screenshot_count);\n}\n\n\n///// UGC\n\n// The result of a call to AddAppDependency.\nvoid Steam::add_app_dependency_result(AddAppDependencyResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] add_app_dependency_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tAppId_t app_id = call_data->m_nAppID;\n\temit_signal(\"add_app_dependency_result\", result, (uint64_t)file_id, (uint32_t)app_id);\n}\n\n// The result of a call to AddDependency.\nvoid Steam::add_ugc_dependency_result(AddUGCDependencyResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] add_ugc_dependency_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tPublishedFileId_t child_id = call_data->m_nChildPublishedFileId;\n\temit_signal(\"add_ugc_dependency_result\", result, (uint64_t)file_id, (uint64_t)child_id);\n}\n\n// Called when getting the app dependencies for an item.\nvoid Steam::get_app_dependencies_result(GetAppDependenciesResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_app_dependencies_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tuint32 app_dependencies = call_data->m_nNumAppDependencies;\n\tuint32 total_app_dependencies = call_data->m_nTotalNumAppDependencies;\n\tPackedInt32Array app_ids;\n\tfor (uint32 i = 0; i < app_dependencies; i++) {\n\t\tapp_ids.append(call_data->m_rgAppIDs[i]);\n\t}\n\temit_signal(\"get_app_dependencies_result\", result, (uint64_t)file_id, app_ids, app_dependencies, total_app_dependencies);\n}\n\n// Called when getting the users vote status on an item.\nvoid Steam::get_item_vote_result(GetUserItemVoteResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_item_vote_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tbool vote_up = call_data->m_bVotedUp;\n\tbool vote_down = call_data->m_bVotedDown;\n\tbool vote_skipped = call_data->m_bVoteSkipped;\n\temit_signal(\"get_item_vote_result\", result, (uint64_t)file_id, vote_up, vote_down, vote_skipped);\n}\n\n// Result of a workshop item being created.\nvoid Steam::item_created(CreateItemResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] item_created signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tbool accept_tos = call_data->m_bUserNeedsToAcceptWorkshopLegalAgreement;\n\temit_signal(\"item_created\", result, (uint64_t)file_id, accept_tos);\n}\n\n// Called when an attempt at deleting an item completes.\nvoid Steam::item_deleted(DeleteItemResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] add_ugc_dependency_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\temit_signal(\"item_deleted\", result, (uint64_t)file_id);\n}\n\n// Result of a workshop item being updated.\nvoid Steam::item_updated(SubmitItemUpdateResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_item_vote_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tbool need_to_accept_tos = call_data->m_bUserNeedsToAcceptWorkshopLegalAgreement;\n\temit_signal(\"item_updated\", result, need_to_accept_tos);\n}\n\n// Purpose: The result of a call to RemoveAppDependency.\nvoid Steam::remove_app_dependency_result(RemoveAppDependencyResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] remove_app_dependency_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tAppId_t app_id = call_data->m_nAppID;\n\temit_signal(\"remove_app_dependency_result\", result, (uint64_t)file_id, (uint32_t)app_id);\n}\n\n// Purpose: The result of a call to RemoveDependency.\nvoid Steam::remove_ugc_dependency_result(RemoveUGCDependencyResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] remove_ugc_dependency_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tPublishedFileId_t child_id = call_data->m_nChildPublishedFileId;\n\temit_signal(\"remove_ugc_dependency_result\", result, (uint64_t)file_id, (uint64_t)child_id);\n}\n\n// Called when the user has voted on an item.\nvoid Steam::set_user_item_vote(SetUserItemVoteResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] set_user_item_vote signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tbool vote_up = call_data->m_bVoteUp;\n\temit_signal(\"set_user_item_vote\", result, (uint64_t)file_id, vote_up);\n}\n\n// Called when workshop item playtime tracking has started.\nvoid Steam::start_playtime_tracking(StartPlaytimeTrackingResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] start_playtime_tracking signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\temit_signal(\"start_playtime_tracking\", result);\n}\n\n// Called when workshop item playtime tracking has stopped.\nvoid Steam::stop_playtime_tracking(StopPlaytimeTrackingResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_item_vote_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\temit_signal(\"stop_playtime_tracking\", result);\n}\n\n// Called when a UGC query request completes.\nvoid Steam::ugc_query_completed(SteamUGCQueryCompleted_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] ugc_query_completed signal failed internally\");\n\tUGCQueryHandle_t handle = call_data->m_handle;\n\tEResult result = call_data->m_eResult;\n\tuint32 results_returned = call_data->m_unNumResultsReturned;\n\tuint32 total_matching = call_data->m_unTotalMatchingResults;\n\tbool cached = call_data->m_bCachedData;\n\temit_signal(\"ugc_query_completed\", (uint64_t)handle, result, results_returned, total_matching, cached);\n}\n\n// Called when the user has added or removed an item to/from their favorites.\nvoid Steam::user_favorite_items_list_changed(UserFavoriteItemsListChanged_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_item_vote_result signal failed internally\");\n\tEResult result = call_data->m_eResult;\n\tPublishedFileId_t file_id = call_data->m_nPublishedFileId;\n\tbool was_add_request = call_data->m_bWasAddRequest;\n\temit_signal(\"user_favorite_items_list_changed\", result, (uint64_t)file_id, was_add_request);\n}\n\n// Purpose: Status of the user's acceptable/rejection of the app's specific Workshop EULA.\nvoid Steam::workshop_eula_status(WorkshopEULAStatus_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] get_item_vote_result signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint32 app_id = call_data->m_nAppID;\n\n\tDictionary eula_data;\n\teula_data[\"version\"] = call_data->m_unVersion; // int\n\teula_data[\"action\"] = call_data->m_rtAction; // int\n\teula_data[\"accepted\"] = call_data->m_bAccepted; // bool\n\teula_data[\"needs_action\"] = call_data->m_bNeedsAction; // bool\n\temit_signal(\"workshop_eula_status\", result, app_id, eula_data);\n}\n\n\n///// USER\n\n// Sent for games with enabled anti indulgence / duration control, for enabled users. Lets the game know whether persistent\n// rewards or XP should be granted at normal rate, half rate, or zero rate.\nvoid Steam::duration_control(DurationControl_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] subscribe_item signal failed internally\");\n\tint result = call_data->m_eResult;\n\tuint32 app_id = call_data->m_appid;\n\tbool applicable = call_data->m_bApplicable;\n\tint32 seconds_last = call_data->m_csecsLast5h;\n\tint progress = call_data->m_progress;\n\tint notification = call_data->m_notification;\n\tString verbal = \"\";\n\n\tif (notification == 1) {\n\t\tverbal = \"you've been playing for an hour\";\n\t}\n\telse if (notification == 2) {\n\t\tverbal = \"you've been playing for 3 hours; take a break\";\n\t}\n\telse if (notification == 3) {\n\t\tverbal = \"your xp / progress is half normal\";\n\t}\n\telse if (notification == 4) {\n\t\tverbal = \"your xp / progress is zero\";\n\t}\n\telse {\n\t\tverbal = \"no notification\";\n\t}\n\t// Create dictionary due to \"too many arguments\" issue\n\tDictionary duration;\n\tduration[\"app_id\"] = app_id;\n\tduration[\"applicable\"] = applicable;\n\tduration[\"seconds_last_5hrs\"] = seconds_last;\n\tduration[\"progress\"] = progress;\n\tduration[\"notification\"] = notification;\n\tduration[\"notification_verbal\"] = verbal;\n\temit_signal(\"duration_control\", result, duration);\n}\n\n// Called when an encrypted application ticket has been received.\nvoid Steam::encrypted_app_ticket_response(EncryptedAppTicketResponse_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] subscribe_item signal failed internally\");\n\tString result;\n\tif (call_data->m_eResult == k_EResultOK) {\n\t\tresult = \"ok\";\n\t}\n\telse if (call_data->m_eResult == k_EResultNoConnection) {\n\t\tresult = \"no connection\";\n\t}\n\telse if (call_data->m_eResult == k_EResultDuplicateRequest) {\n\t\tresult = \"duplicate request\";\n\t}\n\telse {\n\t\tresult = \"limit exceeded\";\n\t}\n\temit_signal(\"encrypted_app_ticket_response\", result);\n}\n\n// Called when a connection attempt has failed. This will occur periodically if the Steam client is not connected, and has failed\n// when retrying to establish a connection.\nvoid Steam::steam_server_connect_failed(SteamServerConnectFailure_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] steam_server_connect_failed signal failed internally\");\n\tint result = call_data->m_eResult;\n\tbool retrying = call_data->m_bStillRetrying;\n\temit_signal(\"steam_server_connected_failed\", result, retrying);\n}\n\n// Response when we have recieved the authentication URL after a call to requestStoreAuthURL.\nvoid Steam::store_auth_url_response(StoreAuthURLResponse_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] store_auth_url_response signal failed internally\");\n\tString url = call_data->m_szURL;\n\temit_signal(\"store_auth_url_response\", url);\n}\n\n\n///// USER STATS\n\n// Global achievements percentages are ready.\nvoid Steam::global_achievement_percentages_ready(GlobalAchievementPercentagesReady_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] global_achievement_percentages_ready signal failed internally\");\n\tCSteamID game_id = call_data->m_nGameID;\n\tuint64_t game = game_id.ConvertToUint64();\n\tuint32_t result = call_data->m_eResult;\n\temit_signal(\"global_achievement_percentages_ready\", game, result);\n}\n\n// Called when the global stats have been received from the server.\nvoid Steam::global_stats_received(GlobalStatsReceived_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] global_stats_received signal failed internally\");\n\tuint64_t game_id = call_data->m_nGameID;\n\tString result;\n\tif (call_data->m_eResult == k_EResultOK) {\n\t\tresult = \"ok\";\n\t}\n\telse if (call_data->m_eResult == k_EResultInvalidState) {\n\t\tresult = \"invalid\";\n\t}\n\telse {\n\t\tresult = \"fail\";\n\t}\n\temit_signal(\"global_stats_received\", game_id, result);\n}\n\n// Result when finding a leaderboard.\nvoid Steam::leaderboard_find_result(LeaderboardFindResult_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] leaderboard_find_result signal failed internally\");\n\tleaderboard_handle = call_data->m_hSteamLeaderboard;\n\tuint8_t found = call_data->m_bLeaderboardFound;\n\temit_signal(\"leaderboard_find_result\", (uint64_t)leaderboard_handle, found);\n}\n\n// Called when scores for a leaderboard have been downloaded and are ready to be retrieved. After calling you must use\n// GetDownloadedLeaderboardEntry to retrieve the info for each downloaded entry.\nvoid Steam::leaderboard_scores_downloaded(LeaderboardScoresDownloaded_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] leaderboard_scores_downloaded signal failed internally\");\n\tString message;\n\tuint64_t this_handle = call_data->m_hSteamLeaderboard;\n\tleaderboard_entries_array.clear();\n\tLeaderboardEntry_t *entry = memnew(LeaderboardEntry_t);\n\tPackedInt32Array details;\n\tint32 *details_pointer = NULL;\n\n\tif (leaderboard_details_max > 0) {\n\t\tdetails.resize(leaderboard_details_max);\n\t\tdetails_pointer = details.ptrw();\n\t\tfor (int i = 0; i < leaderboard_details_max; i++) {\n\t\t\tdetails_pointer[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < call_data->m_cEntryCount; i++) {\n\t\tif (SteamUserStats()->GetDownloadedLeaderboardEntry(call_data->m_hSteamLeaderboardEntries, i, entry, details_pointer, leaderboard_details_max)) {\n\t\t\tDictionary entry_dict;\n\t\t\tentry_dict[\"score\"] = entry->m_nScore;\n\t\t\tentry_dict[\"steam_id\"] = uint64_t(entry->m_steamIDUser.ConvertToUint64());\n\t\t\tentry_dict[\"global_rank\"] = entry->m_nGlobalRank;\n\t\t\tentry_dict[\"ugc_handle\"] = uint64_t(entry->m_hUGC);\n\t\t\tif (leaderboard_details_max > 0) {\n\t\t\t\tPackedInt32Array array;\n\t\t\t\tarray.resize(leaderboard_details_max);\n\t\t\t\tint32_t *ptr = array.ptrw();\n\t\t\t\tfor (int j = 0; j < leaderboard_details_max; j++) {\n\t\t\t\t\tptr[j] = details_pointer[j];\n\t\t\t\t}\n\t\t\t\tentry_dict[\"details\"] = array;\n\t\t\t}\n\t\t\tleaderboard_entries_array.append(entry_dict);\n\t\t}\n\t\tmessage = \"Leaderboard entries successfully retrieved\";\n\t}\n\tmemdelete(entry);\n\temit_signal(\"leaderboard_scores_downloaded\", message, this_handle, leaderboard_entries_array);\n}\n\n// Result indicating that a leaderboard score has been uploaded.\nvoid Steam::leaderboard_score_uploaded(LeaderboardScoreUploaded_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] leaderboard_score_uploaded signal failed internally\");\n\tuint64_t this_handle = call_data->m_hSteamLeaderboard;\n\tuint8 success = call_data->m_bSuccess;\n\t// Create dictionary since Godot will not allow more than six properties to be sent back\n\tDictionary this_score;\n\tint32 score = call_data->m_nScore;\n\tuint8 score_changed = call_data->m_bScoreChanged;\n\tint global_rank_new = call_data->m_nGlobalRankNew;\n\tint global_rank_prev = call_data->m_nGlobalRankPrevious;\n\t// Populate dictionary\n\tthis_score[\"score\"] = score;\n\tthis_score[\"score_changed\"] = score_changed;\n\tthis_score[\"global_rank_new\"] = global_rank_new;\n\tthis_score[\"global_rank_prev\"] = global_rank_prev;\n\temit_signal(\"leaderboard_score_uploaded\", success, this_handle, this_score);\n}\n\n// Result indicating that user generated content has been attached to one of the current user's leaderboard entries.\nvoid Steam::leaderboard_ugc_set(LeaderboardUGCSet_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] leaderboard_ugc_set signal failed internally\");\n\tleaderboard_handle = call_data->m_hSteamLeaderboard;\n\tString result;\n\tif (call_data->m_eResult == k_EResultOK) {\n\t\tresult = \"ok\";\n\t}\n\telse if (call_data->m_eResult == k_EResultTimeout) {\n\t\tresult = \"timeout\";\n\t}\n\telse {\n\t\tresult = \"invalid\";\n\t}\n\temit_signal(\"leaderboard_ugc_set\", (uint64_t)leaderboard_handle, result);\n}\n\n// Gets the current number of players for the current AppId.\nvoid Steam::number_of_current_players(NumberOfCurrentPlayers_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] number_of_current_players signal failed internally\");\n\tuint8 success = call_data->m_bSuccess;\n\tint32 players = call_data->m_cPlayers;\n\temit_signal(\"number_of_current_players\", success, players);\n}\n\n// Called when the latest stats and achievements for a specific user (including the local user) have been received from the server.\nvoid Steam::user_stats_received(UserStatsReceived_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] user_stats_received signal failed internally\");\n\tCSteamID game_id = call_data->m_nGameID;\n\tuint64_t game = game_id.ConvertToUint64();\n\tuint32_t result = call_data->m_eResult;\n\tCSteamID user_id = call_data->m_steamIDUser;\n\tuint64_t user = user_id.ConvertToUint64();\n\temit_signal(\"user_stats_received\", game, result, user);\n}\n\n\n///// UTILITY\n\n// CallResult for checkFileSignature.\nvoid Steam::check_file_signature(CheckFileSignature_t *call_data, bool io_failure) {\n\tERR_FAIL_COND_MSG(io_failure, \"[STEAM] check_file_signature signal failed internally\");\n\temit_signal(\"check_file_signature\", (CheckFileSignature)call_data->m_eCheckFileSignature);\n}\n\n\n///// BIND METHODS\n\nvoid Steam::_bind_methods() {\n\n\t// STEAM MAIN\n\tClassDB::bind_method(\"get_godotsteam_version\", &Steam::get_godotsteam_version);\n\tClassDB::bind_method(D_METHOD(\"getSteamID32\", \"steam_id\"), &Steam::getSteamID32);\n\tClassDB::bind_method(D_METHOD(\"isAnonAccount\", \"steam_id\"), &Steam::isAnonAccount);\n\tClassDB::bind_method(D_METHOD(\"isAnonUserAccount\", \"steam_id\"), &Steam::isAnonUserAccount);\n\tClassDB::bind_method(D_METHOD(\"isChatAccount\", \"steam_id\"), &Steam::isChatAccount);\n\tClassDB::bind_method(D_METHOD(\"isClanAccount\", \"steam_id\"), &Steam::isClanAccount);\n\tClassDB::bind_method(D_METHOD(\"isConsoleUserAccount\", \"steam_id\"), &Steam::isConsoleUserAccount);\n\tClassDB::bind_method(D_METHOD(\"isIndividualAccount\", \"steam_id\"), &Steam::isIndividualAccount);\n\tClassDB::bind_method(D_METHOD(\"isLobby\", \"steam_id\"), &Steam::isLobby);\n\tClassDB::bind_method(\"isSteamRunning\", &Steam::isSteamRunning);\n\tClassDB::bind_method(\"run_callbacks\", &Steam::run_callbacks);\n\tClassDB::bind_method(D_METHOD(\"restartAppIfNecessary\", \"app_id\"), &Steam::restartAppIfNecessary);\n\tClassDB::bind_method(D_METHOD(\"steamInit\", \"retrieve_stats\", \"app_id\", \"embed_callbacks\"), &Steam::steamInit, DEFVAL(false), DEFVAL(0), DEFVAL(false));\n\tClassDB::bind_method(D_METHOD(\"steamInitEx\", \"retrieve_stats\", \"app_id\", \"embed_callbacks\"), &Steam::steamInitEx, DEFVAL(false), DEFVAL(0), DEFVAL(false));\n\tClassDB::bind_method(\"steamShutdown\", &Steam::steamShutdown);\n\n\tClassDB::bind_method(\"get_browser_handle\", &Steam::get_browser_handle);\n\tClassDB::bind_method(\"get_current_app_id\", &Steam::get_current_app_id);\n\tClassDB::bind_method(\"get_current_clan_id\", &Steam::get_current_clan_id);\n\tClassDB::bind_method(\"get_current_steam_id\", &Steam::get_current_steam_id);\n\tClassDB::bind_method(\"get_inventory_handle\", &Steam::get_inventory_handle);\n\tClassDB::bind_method(\"get_inventory_update_handle\", &Steam::get_inventory_update_handle);\n\tClassDB::bind_method(\"get_leaderboard_handle\", &Steam::get_leaderboard_handle);\n\tClassDB::bind_method(\"get_leaderboard_details_max\", &Steam::get_leaderboard_details_max);\n\tClassDB::bind_method(\"get_leaderboard_entries\", &Steam::get_leaderboard_entries);\n\tClassDB::bind_method(\"get_server_list_request\", &Steam::get_server_list_request);\n\tClassDB::bind_method(D_METHOD(\"set_browser_handle\", \"new_browser_handle\"), &Steam::set_browser_handle);\n\tClassDB::bind_method(D_METHOD(\"set_current_app_id\", \"new_current_app_id\"), &Steam::set_current_app_id);\n\tClassDB::bind_method(D_METHOD(\"set_current_clan_id\", \"new_current_clan_id\"), &Steam::set_current_clan_id);\n\tClassDB::bind_method(D_METHOD(\"set_current_steam_id\", \"new_current_steam_id\"), &Steam::set_current_steam_id);\n\tClassDB::bind_method(D_METHOD(\"set_inventory_handle\", \"new_inventory_handle\"), &Steam::set_inventory_handle);\n\tClassDB::bind_method(D_METHOD(\"set_inventory_update_handle\", \"new_inventory_update_handle\"), &Steam::set_inventory_update_handle);\n\tClassDB::bind_method(D_METHOD(\"set_leaderboard_details_max\", \"new_leaderboard_details_max\"), &Steam::set_leaderboard_details_max);\n\tClassDB::bind_method(D_METHOD(\"set_leaderboard_entries\", \"new_leaderboard_entries\"), &Steam::set_leaderboard_entries);\n\tClassDB::bind_method(D_METHOD(\"set_leaderboard_handle\", \"new_leaderboard_handle\"), &Steam::set_leaderboard_handle);\n\tClassDB::bind_method(D_METHOD(\"set_server_list_request\", \"new_server_list_request\"), &Steam::set_server_list_request);\n\n\t// APPS\n\tClassDB::bind_method(\"getAppBuildId\", &Steam::getAppBuildId);\n\tClassDB::bind_method(D_METHOD(\"getAppInstallDir\", \"app_id\"), &Steam::getAppInstallDir);\n\tClassDB::bind_method(\"getAppOwner\", &Steam::getAppOwner);\n\tClassDB::bind_method(\"getAvailableGameLanguages\", &Steam::getAvailableGameLanguages);\n\tClassDB::bind_method(\"getBetaInfo\", &Steam::getBetaInfo);\n\tClassDB::bind_method(\"getCurrentBetaName\", &Steam::getCurrentBetaName);\n\tClassDB::bind_method(\"getCurrentGameLanguage\", &Steam::getCurrentGameLanguage);\n\tClassDB::bind_method(\"getDLCCount\", &Steam::getDLCCount);\n\tClassDB::bind_method(\"getDLCData\", &Steam::getDLCData);\n\tClassDB::bind_method(D_METHOD(\"getDLCDataByIndex\", \"this_dlc_index\"), &Steam::getDLCDataByIndex);\n\tClassDB::bind_method(D_METHOD(\"getDLCDownloadProgress\", \"dlc_id\"), &Steam::getDLCDownloadProgress);\n\tClassDB::bind_method(D_METHOD(\"getEarliestPurchaseUnixTime\", \"app_id\"), &Steam::getEarliestPurchaseUnixTime);\n\tClassDB::bind_method(D_METHOD(\"getFileDetails\", \"filename\"), &Steam::getFileDetails);\n\tClassDB::bind_method(D_METHOD(\"getInstalledDepots\", \"app_id\"), &Steam::getInstalledDepots);\n\tClassDB::bind_method(\"getLaunchCommandLine\", &Steam::getLaunchCommandLine);\n\tClassDB::bind_method(D_METHOD(\"getLaunchQueryParam\", \"key\"), &Steam::getLaunchQueryParam);\n\tClassDB::bind_method(\"getNumBetas\", &Steam::getNumBetas);\n\tClassDB::bind_method(D_METHOD(\"installDLC\", \"dlc_id\"), &Steam::installDLC);\n\tClassDB::bind_method(D_METHOD(\"isAppInstalled\", \"app_id\"), &Steam::isAppInstalled);\n\tClassDB::bind_method(\"isCybercafe\", &Steam::isCybercafe);\n\tClassDB::bind_method(D_METHOD(\"isDLCInstalled\", \"dlc_id\"), &Steam::isDLCInstalled);\n\tClassDB::bind_method(\"isLowViolence\", &Steam::isLowViolence);\n\tClassDB::bind_method(\"isSubscribed\", &Steam::isSubscribed);\n\tClassDB::bind_method(D_METHOD(\"isSubscribedApp\", \"app_id\"), &Steam::isSubscribedApp);\n\tClassDB::bind_method(\"isSubscribedFromFamilySharing\", &Steam::isSubscribedFromFamilySharing);\n\tClassDB::bind_method(\"isSubscribedFromFreeWeekend\", &Steam::isSubscribedFromFreeWeekend);\n\tClassDB::bind_method(\"isTimedTrial\", &Steam::isTimedTrial);\n\tClassDB::bind_method(\"isVACBanned\", &Steam::isVACBanned);\n\tClassDB::bind_method(D_METHOD(\"markContentCorrupt\", \"missing_files_only\"), &Steam::markContentCorrupt);\n\tClassDB::bind_method(D_METHOD(\"setActiveBeta\", \"beta_name\"), &Steam::setActiveBeta);\n\tClassDB::bind_method(D_METHOD(\"setDLCContext\", \"app_id\"), &Steam::setDLCContext);\n\tClassDB::bind_method(D_METHOD(\"uninstallDLC\", \"dlc_id\"), &Steam::uninstallDLC);\n\n\t// FRIENDS\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlay\", \"type\"), &Steam::activateGameOverlay, DEFVAL(\"\"));\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlayInviteDialog\", \"steam_id\"), &Steam::activateGameOverlayInviteDialog);\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlayInviteDialogConnectString\", \"connect_string\"), &Steam::activateGameOverlayInviteDialogConnectString);\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlayToStore\", \"app_id\"), &Steam::activateGameOverlayToStore, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlayToUser\", \"type\", \"steam_id\"), &Steam::activateGameOverlayToUser, DEFVAL(\"\"), DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"activateGameOverlayToWebPage\", \"url\"), &Steam::activateGameOverlayToWebPage);\n\tClassDB::bind_method(\"clearRichPresence\", &Steam::clearRichPresence);\n\tClassDB::bind_method(D_METHOD(\"closeClanChatWindowInSteam\", \"chat_id\"), &Steam::closeClanChatWindowInSteam);\n\tClassDB::bind_method(D_METHOD(\"downloadClanActivityCounts\", \"chat_id\", \"clans_to_request\"), &Steam::downloadClanActivityCounts);\n\tClassDB::bind_method(D_METHOD(\"enumerateFollowingList\", \"start_index\"), &Steam::enumerateFollowingList);\n\tClassDB::bind_method(D_METHOD(\"getChatMemberByIndex\", \"clan_id\", \"user\"), &Steam::getChatMemberByIndex);\n\tClassDB::bind_method(D_METHOD(\"getClanActivityCounts\", \"clan_id\"), &Steam::getClanActivityCounts);\n\tClassDB::bind_method(D_METHOD(\"getClanByIndex\", \"clan_index\"), &Steam::getClanByIndex);\n\tClassDB::bind_method(D_METHOD(\"getClanChatMemberCount\", \"clan_id\"), &Steam::getClanChatMemberCount);\n\tClassDB::bind_method(D_METHOD(\"getClanChatMessage\", \"chat_id\", \"message\"), &Steam::getClanChatMessage);\n\tClassDB::bind_method(\"getClanCount\", &Steam::getClanCount);\n\tClassDB::bind_method(D_METHOD(\"getClanName\", \"clan_id\"), &Steam::getClanName);\n\tClassDB::bind_method(D_METHOD(\"getClanOfficerByIndex\", \"clan_id\", \"officer\"), &Steam::getClanOfficerByIndex);\n\tClassDB::bind_method(D_METHOD(\"getClanOfficerCount\", \"clan_id\"), &Steam::getClanOfficerCount);\n\tClassDB::bind_method(D_METHOD(\"getClanOwner\", \"clan_id\"), &Steam::getClanOwner);\n\tClassDB::bind_method(D_METHOD(\"getClanTag\", \"clan_id\"), &Steam::getClanTag);\n\tClassDB::bind_method(D_METHOD(\"getCoplayFriend\", \"friend_number\"), &Steam::getCoplayFriend);\n\tClassDB::bind_method(\"getCoplayFriendCount\", &Steam::getCoplayFriendCount);\n\tClassDB::bind_method(D_METHOD(\"getFollowerCount\", \"steam_id\"), &Steam::getFollowerCount);\n\tClassDB::bind_method(D_METHOD(\"getFriendByIndex\", \"friend_number\", \"friend_flags\"), &Steam::getFriendByIndex);\n\tClassDB::bind_method(D_METHOD(\"getFriendCoplayGame\", \"friend_id\"), &Steam::getFriendCoplayGame);\n\tClassDB::bind_method(D_METHOD(\"getFriendCoplayTime\", \"friend_id\"), &Steam::getFriendCoplayTime);\n\tClassDB::bind_method(D_METHOD(\"getFriendCount\", \"friend_flags\"), &Steam::getFriendCount, DEFVAL(FRIEND_FLAG_ALL));\n\tClassDB::bind_method(D_METHOD(\"getFriendCountFromSource\", \"source_id\"), &Steam::getFriendCountFromSource);\n\tClassDB::bind_method(D_METHOD(\"getFriendFromSourceByIndex\", \"source_id\", \"friend_number\"), &Steam::getFriendFromSourceByIndex);\n\tClassDB::bind_method(D_METHOD(\"getFriendGamePlayed\", \"steam_id\"), &Steam::getFriendGamePlayed);\n\tClassDB::bind_method(D_METHOD(\"getFriendMessage\", \"friend_id\", \"message\"), &Steam::getFriendMessage);\n\tClassDB::bind_method(D_METHOD(\"getFriendPersonaName\", \"steam_id\"), &Steam::getFriendPersonaName);\n\tClassDB::bind_method(D_METHOD(\"getFriendPersonaNameHistory\", \"steam_id\", \"name_history\"), &Steam::getFriendPersonaNameHistory);\n\tClassDB::bind_method(D_METHOD(\"getFriendPersonaState\", \"steam_id\"), &Steam::getFriendPersonaState);\n\tClassDB::bind_method(D_METHOD(\"getFriendRelationship\", \"steam_id\"), &Steam::getFriendRelationship);\n\tClassDB::bind_method(D_METHOD(\"getFriendRichPresence\", \"friend_id\", \"key\"), &Steam::getFriendRichPresence);\n\tClassDB::bind_method(D_METHOD(\"getFriendRichPresenceKeyCount\", \"friend_id\"), &Steam::getFriendRichPresenceKeyCount);\n\tClassDB::bind_method(D_METHOD(\"getFriendRichPresenceKeyByIndex\", \"friend_id\", \"key\"), &Steam::getFriendRichPresenceKeyByIndex);\n\tClassDB::bind_method(\"getFriendsGroupCount\", &Steam::getFriendsGroupCount);\n\tClassDB::bind_method(D_METHOD(\"getFriendsGroupIDByIndex\", \"friend_group\"), &Steam::getFriendsGroupIDByIndex);\n\tClassDB::bind_method(D_METHOD(\"getFriendsGroupMembersCount\", \"friend_group\"), &Steam::getFriendsGroupMembersCount);\n\tClassDB::bind_method(D_METHOD(\"getFriendsGroupMembersList\", \"friend_group\", \"member_count\"), &Steam::getFriendsGroupMembersList);\n\tClassDB::bind_method(D_METHOD(\"getFriendsGroupName\", \"friend_group\"), &Steam::getFriendsGroupName);\n\tClassDB::bind_method(D_METHOD(\"getFriendSteamLevel\", \"steam_id\"), &Steam::getFriendSteamLevel);\n\tClassDB::bind_method(D_METHOD(\"getLargeFriendAvatar\", \"steam_id\"), &Steam::getLargeFriendAvatar);\n\tClassDB::bind_method(D_METHOD(\"getMediumFriendAvatar\", \"steam_id\"), &Steam::getMediumFriendAvatar);\n\tClassDB::bind_method(\"getPersonaName\", &Steam::getPersonaName);\n\tClassDB::bind_method(\"getPersonaState\", &Steam::getPersonaState);\n\tClassDB::bind_method(D_METHOD(\"getPlayerAvatar\", \"size\", \"steam_id\"), &Steam::getPlayerAvatar, DEFVAL(2), DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getPlayerNickname\", \"steam_id\"), &Steam::getPlayerNickname);\n\tClassDB::bind_method(D_METHOD(\"getProfileItemPropertyString\", \"steam_id\", \"item_type\", \"item_property\"), &Steam::getProfileItemPropertyString);\n\tClassDB::bind_method(D_METHOD(\"getProfileItemPropertyInt\", \"steam_id\", \"item_type\", \"item_property\"), &Steam::getProfileItemPropertyInt);\n\tClassDB::bind_method(\"getRecentPlayers\", &Steam::getRecentPlayers);\n\tClassDB::bind_method(D_METHOD(\"getSmallFriendAvatar\", \"steam_id\"), &Steam::getSmallFriendAvatar);\n\tClassDB::bind_method(\"getUserFriendsGroups\", &Steam::getUserFriendsGroups);\n\tClassDB::bind_method(\"getUserRestrictions\", &Steam::getUserRestrictions);\n\tClassDB::bind_method(\"getUserSteamFriends\", &Steam::getUserSteamFriends);\n\tClassDB::bind_method(\"getUserSteamGroups\", &Steam::getUserSteamGroups);\n\tClassDB::bind_method(D_METHOD(\"hasEquippedProfileItem\", \"steam_id\", \"friend_flags\"), &Steam::hasEquippedProfileItem);\n\tClassDB::bind_method(D_METHOD(\"hasFriend\", \"steam_id\", \"friend_flags\"), &Steam::hasFriend);\n\tClassDB::bind_method(D_METHOD(\"inviteUserToGame\", \"friend_id\", \"connect_string\"), &Steam::inviteUserToGame);\n\tClassDB::bind_method(D_METHOD(\"isClanChatAdmin\", \"chat_id\", \"steam_id\"), &Steam::isClanChatAdmin);\n\tClassDB::bind_method(D_METHOD(\"isClanPublic\", \"clan_id\"), &Steam::isClanPublic);\n\tClassDB::bind_method(D_METHOD(\"isClanOfficialGameGroup\", \"clan_id\"), &Steam::isClanOfficialGameGroup);\n\tClassDB::bind_method(D_METHOD(\"isClanChatWindowOpenInSteam\", \"chat_id\"), &Steam::isClanChatWindowOpenInSteam);\n\tClassDB::bind_method(D_METHOD(\"isFollowing\", \"steam_id\"), &Steam::isFollowing);\n\tClassDB::bind_method(D_METHOD(\"isUserInSource\", \"steam_id\", \"source_id\"), &Steam::isUserInSource);\n\tClassDB::bind_method(D_METHOD(\"joinClanChatRoom\", \"clan_id\"), &Steam::joinClanChatRoom);\n\tClassDB::bind_method(D_METHOD(\"leaveClanChatRoom\", \"clan_id\"), &Steam::leaveClanChatRoom);\n\tClassDB::bind_method(D_METHOD(\"openClanChatWindowInSteam\", \"chat_id\"), &Steam::openClanChatWindowInSteam);\n\tClassDB::bind_method(D_METHOD(\"registerProtocolInOverlayBrowser\", \"protocol\"), &Steam::registerProtocolInOverlayBrowser);\n\tClassDB::bind_method(D_METHOD(\"replyToFriendMessage\", \"steam_id\", \"message\"), &Steam::replyToFriendMessage);\n\tClassDB::bind_method(D_METHOD(\"requestClanOfficerList\", \"clan_id\"), &Steam::requestClanOfficerList);\n\tClassDB::bind_method(D_METHOD(\"requestEquippedProfileItems\", \"steam_id\"), &Steam::requestEquippedProfileItems);\n\tClassDB::bind_method(D_METHOD(\"requestFriendRichPresence\", \"friend_id\"), &Steam::requestFriendRichPresence);\n\tClassDB::bind_method(D_METHOD(\"requestUserInformation\", \"steam_id\", \"require_name_only\"), &Steam::requestUserInformation);\n\tClassDB::bind_method(D_METHOD(\"sendClanChatMessage\", \"chat_id\", \"text\"), &Steam::sendClanChatMessage);\n\tClassDB::bind_method(D_METHOD(\"setInGameVoiceSpeaking\", \"steam_id\", \"speaking\"), &Steam::setInGameVoiceSpeaking);\n\tClassDB::bind_method(D_METHOD(\"setListenForFriendsMessages\", \"intercept\"), &Steam::setListenForFriendsMessages);\n\tClassDB::bind_method(D_METHOD(\"setPersonaName\", \"name\"), &Steam::setPersonaName);\n\tClassDB::bind_method(D_METHOD(\"setPlayedWith\", \"steam_id\"), &Steam::setPlayedWith);\n\tClassDB::bind_method(D_METHOD(\"setRichPresence\", \"key\", \"value\"), &Steam::setRichPresence);\n\n\t// GAME SEARCH\n\tClassDB::bind_method(D_METHOD(\"addGameSearchParams\", \"key\", \"values\"), &Steam::addGameSearchParams);\n\tClassDB::bind_method(D_METHOD(\"searchForGameWithLobby\", \"lobby_id\", \"player_min\", \"player_max\"), &Steam::searchForGameWithLobby);\n\tClassDB::bind_method(D_METHOD(\"searchForGameSolo\", \"player_min\", \"player_max\"), &Steam::searchForGameSolo);\n\tClassDB::bind_method(\"acceptGame\", &Steam::acceptGame);\n\tClassDB::bind_method(\"declineGame\", &Steam::declineGame);\n\tClassDB::bind_method(D_METHOD(\"retrieveConnectionDetails\", \"host_id\"), &Steam::retrieveConnectionDetails);\n\tClassDB::bind_method(\"endGameSearch\", &Steam::endGameSearch);\n\tClassDB::bind_method(D_METHOD(\"setGameHostParams\", \"key\", \"value\"), &Steam::setGameHostParams);\n\tClassDB::bind_method(D_METHOD(\"setConnectionDetails\", \"details\", \"connection_details\"), &Steam::setConnectionDetails);\n\tClassDB::bind_method(D_METHOD(\"requestPlayersForGame\", \"player_min\", \"player_max\", \"max_team_size\"), &Steam::requestPlayersForGame);\n\tClassDB::bind_method(D_METHOD(\"hostConfirmGameStart\", \"game_id\"), &Steam::hostConfirmGameStart);\n\tClassDB::bind_method(\"cancelRequestPlayersForGame\", &Steam::cancelRequestPlayersForGame);\n\tClassDB::bind_method(D_METHOD(\"submitPlayerResult\", \"game_id\", \"player_id\", \"player_result\"), &Steam::submitPlayerResult);\n\tClassDB::bind_method(D_METHOD(\"endGame\", \"game_id\"), &Steam::endGame);\n\n\t// HTML SURFACE\n\tClassDB::bind_method(D_METHOD(\"addHeader\", \"key\", \"value\", \"this_handle\"), &Steam::addHeader, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"allowStartRequest\", \"allowed\", \"this_handle\"), &Steam::allowStartRequest, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"copyToClipboard\", \"this_handle\"), &Steam::copyToClipboard, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"createBrowser\", \"user_agent\", \"user_css\"), &Steam::createBrowser, DEFVAL(\"\"), DEFVAL(\"\"));\n\tClassDB::bind_method(D_METHOD(\"executeJavascript\", \"script\", \"this_handle\"), &Steam::executeJavascript, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"find\", \"search\", \"currently_in_find\", \"reverse\", \"this_handle\"), &Steam::find, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getLinkAtPosition\", \"x\", \"y\", \"this_handle\"), &Steam::getLinkAtPosition, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"goBack\", \"this_handle\"), &Steam::goBack, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"goForward\", \"this_handle\"), &Steam::goForward, DEFVAL(0));\n\tClassDB::bind_method(\"htmlInit\", &Steam::htmlInit);\n\tClassDB::bind_method(D_METHOD(\"jsDialogResponse\", \"result\", \"this_handle\"), &Steam::jsDialogResponse, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"keyChar\", \"unicode_char\", \"key_modifiers\", \"this_handle\"), &Steam::keyChar, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"keyDown\", \"native_key_code\", \"key_modifiers\", \"this_handle\"), &Steam::keyDown, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"keyUp\", \"native_key_code\", \"key_modifiers\", \"this_handle\"), &Steam::keyUp, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"loadURL\", \"url\", \"post_data\", \"this_handle\"), &Steam::loadURL, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"mouseDoubleClick\", \"mouse_button\", \"this_handle\"), &Steam::mouseDoubleClick, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"mouseDown\", \"mouse_button\", \"this_handle\"), &Steam::mouseDown, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"mouseMove\", \"x\", \"y\", \"this_handle\"), &Steam::mouseMove, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"mouseUp\", \"mouse_button\", \"this_handle\"), &Steam::mouseUp, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"mouseWheel\", \"delta\", \"this_handle\"), &Steam::mouseWheel, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"pasteFromClipboard\", \"this_handle\"), &Steam::pasteFromClipboard, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"reload\", \"this_handle\"), &Steam::reload, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"removeBrowser\", \"this_handle\"), &Steam::removeBrowser, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setBackgroundMode\", \"background_mode\", \"this_handle\"), &Steam::setBackgroundMode, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setCookie\", \"hostname\", \"key\", \"value\", \"path\", \"expires\", \"secure\", \"http_only\"), &Steam::setCookie);\n\tClassDB::bind_method(D_METHOD(\"setHorizontalScroll\", \"absolute_pixel_scroll\", \"this_handle\"), &Steam::setHorizontalScroll, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setKeyFocus\", \"has_key_focus\", \"this_handle\"), &Steam::setKeyFocus, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setPageScaleFactor\", \"zoom\", \"point_x\", \"point_y\", \"this_handle\"), &Steam::setPageScaleFactor, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setSize\", \"width\", \"height\", \"this_handle\"), &Steam::setSize, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setVerticalScroll\", \"absolute_pixel_scroll\", \"this_handle\"), &Steam::setVerticalScroll, DEFVAL(0));\n\tClassDB::bind_method(\"htmlShutdown\", &Steam::htmlShutdown);\n\tClassDB::bind_method(D_METHOD(\"stopFind\", \"this_handle\"), &Steam::stopFind, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"stopLoad\", \"this_handle\"), &Steam::stopLoad, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"viewSource\", \"this_handle\"), &Steam::viewSource, DEFVAL(0));\n\n\t// HTTP\n\tClassDB::bind_method(D_METHOD(\"createCookieContainer\", \"allow_response_to_modify\"), &Steam::createCookieContainer);\n\tClassDB::bind_method(D_METHOD(\"createHTTPRequest\", \"request_method\", \"absolute_url\"), &Steam::createHTTPRequest);\n\tClassDB::bind_method(D_METHOD(\"deferHTTPRequest\", \"request_handle\"), &Steam::deferHTTPRequest);\n\tClassDB::bind_method(D_METHOD(\"getHTTPDownloadProgressPct\", \"request_handle\"), &Steam::getHTTPDownloadProgressPct);\n\tClassDB::bind_method(D_METHOD(\"getHTTPRequestWasTimedOut\", \"request_handle\"), &Steam::getHTTPRequestWasTimedOut);\n\tClassDB::bind_method(D_METHOD(\"getHTTPResponseBodyData\", \"request_handle\", \"buffer_size\"), &Steam::getHTTPResponseBodyData);\n\tClassDB::bind_method(D_METHOD(\"getHTTPResponseBodySize\", \"request_handle\"), &Steam::getHTTPResponseBodySize);\n\tClassDB::bind_method(D_METHOD(\"getHTTPResponseHeaderSize\", \"request_handle\", \"header_name\"), &Steam::getHTTPResponseHeaderSize);\n\tClassDB::bind_method(D_METHOD(\"getHTTPResponseHeaderValue\", \"request_handle\", \"header_name\", \"buffer_size\"), &Steam::getHTTPResponseHeaderValue);\n\tClassDB::bind_method(D_METHOD(\"getHTTPStreamingResponseBodyData\", \"request_handle\", \"offset\", \"buffer_size\"), &Steam::getHTTPStreamingResponseBodyData);\n\tClassDB::bind_method(D_METHOD(\"prioritizeHTTPRequest\", \"request_handle\"), &Steam::prioritizeHTTPRequest);\n\tClassDB::bind_method(D_METHOD(\"releaseCookieContainer\", \"cookie_handle\"), &Steam::releaseCookieContainer);\n\tClassDB::bind_method(D_METHOD(\"releaseHTTPRequest\", \"request_handle\"), &Steam::releaseHTTPRequest);\n\tClassDB::bind_method(D_METHOD(\"sendHTTPRequest\", \"request_handle\"), &Steam::sendHTTPRequest);\n\tClassDB::bind_method(D_METHOD(\"sendHTTPRequestAndStreamResponse\", \"request_handle\"), &Steam::sendHTTPRequestAndStreamResponse);\n\tClassDB::bind_method(D_METHOD(\"setHTTPCookie\", \"cookie_handle\", \"host\", \"url\", \"cookie\"), &Steam::setHTTPCookie);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestAbsoluteTimeoutMS\", \"request_handle\", \"milliseconds\"), &Steam::setHTTPRequestAbsoluteTimeoutMS);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestContextValue\", \"request_handle\", \"context_value\"), &Steam::setHTTPRequestContextValue);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestCookieContainer\", \"request_handle\", \"cookie_handle\"), &Steam::setHTTPRequestCookieContainer);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestGetOrPostParameter\", \"request_handle\", \"name\", \"value\"), &Steam::setHTTPRequestGetOrPostParameter);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestHeaderValue\", \"request_handle\", \"header_name\", \"header_value\"), &Steam::setHTTPRequestHeaderValue);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestNetworkActivityTimeout\", \"request_handle\", \"timeout_seconds\"), &Steam::setHTTPRequestNetworkActivityTimeout);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestRawPostBody\", \"request_handle\", \"content_type\", \"body\"), &Steam::setHTTPRequestRawPostBody);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestRequiresVerifiedCertificate\", \"request_handle\", \"require_verified_certificate\"), &Steam::setHTTPRequestRequiresVerifiedCertificate);\n\tClassDB::bind_method(D_METHOD(\"setHTTPRequestUserAgentInfo\", \"request_handle\", \"user_agent_info\"), &Steam::setHTTPRequestUserAgentInfo);\n\n\t// INPUT\n\tClassDB::bind_method(D_METHOD(\"activateActionSet\", \"input_handle\", \"action_set_handle\"), &Steam::activateActionSet);\n\tClassDB::bind_method(D_METHOD(\"activateActionSetLayer\", \"input_handle\", \"action_set_layer_handle\"), &Steam::activateActionSetLayer);\n\tClassDB::bind_method(D_METHOD(\"deactivateActionSetLayer\", \"input_handle\", \"action_set_handle\"), &Steam::deactivateActionSetLayer);\n\tClassDB::bind_method(D_METHOD(\"deactivateAllActionSetLayers\", \"input_handle\"), &Steam::deactivateAllActionSetLayers);\n\tClassDB::bind_method(D_METHOD(\"getActionSetHandle\", \"action_set_name\"), &Steam::getActionSetHandle);\n\tClassDB::bind_method(D_METHOD(\"getActionOriginFromXboxOrigin\", \"input_handle\", \"origin\"), &Steam::getActionOriginFromXboxOrigin);\n\tClassDB::bind_method(D_METHOD(\"getActiveActionSetLayers\", \"input_handle\"), &Steam::getActiveActionSetLayers);\n\tClassDB::bind_method(D_METHOD(\"getAnalogActionData\", \"input_handle\", \"analog_action_handle\"), &Steam::getAnalogActionData);\n\tClassDB::bind_method(D_METHOD(\"getAnalogActionHandle\", \"action_name\"), &Steam::getAnalogActionHandle);\n\tClassDB::bind_method(D_METHOD(\"getAnalogActionOrigins\", \"input_handle\", \"action_set_handle\", \"analog_action_handle\"), &Steam::getAnalogActionOrigins);\n\tClassDB::bind_method(\"getConnectedControllers\", &Steam::getConnectedControllers);\n\tClassDB::bind_method(D_METHOD(\"getControllerForGamepadIndex\", \"index\"), &Steam::getControllerForGamepadIndex);\n\tClassDB::bind_method(D_METHOD(\"getCurrentActionSet\", \"input_handle\"), &Steam::getCurrentActionSet);\n\tClassDB::bind_method(D_METHOD(\"getDeviceBindingRevision\", \"input_handle\"), &Steam::getDeviceBindingRevision);\n\tClassDB::bind_method(D_METHOD(\"getDigitalActionData\", \"input_handle\", \"digital_action_handle\"), &Steam::getDigitalActionData);\n\tClassDB::bind_method(D_METHOD(\"getDigitalActionHandle\", \"action_name\"), &Steam::getDigitalActionHandle);\n\tClassDB::bind_method(D_METHOD(\"getDigitalActionOrigins\", \"input_handle\", \"action_set_handle\", \"digital_action_handle\"), &Steam::getDigitalActionOrigins);\n\tClassDB::bind_method(D_METHOD(\"getGamepadIndexForController\", \"input_handle\"), &Steam::getGamepadIndexForController);\n\tClassDB::bind_method(D_METHOD(\"getGlyphForActionOrigin\", \"origin\"), &Steam::getGlyphForActionOrigin);\n\tClassDB::bind_method(D_METHOD(\"getInputTypeForHandle\", \"input_handle\"), &Steam::getInputTypeForHandle);\n\tClassDB::bind_method(D_METHOD(\"getMotionData\", \"input_handle\"), &Steam::getMotionData);\n\tClassDB::bind_method(D_METHOD(\"getRemotePlaySessionID\", \"input_handle\"), &Steam::getRemotePlaySessionID);\n\tClassDB::bind_method(D_METHOD(\"getStringForActionOrigin\", \"origin\"), &Steam::getStringForActionOrigin);\n\tClassDB::bind_method(D_METHOD(\"inputInit\", \"explicitly_call_runframe\"), &Steam::inputInit, DEFVAL(false));\n\tClassDB::bind_method(\"inputShutdown\", &Steam::inputShutdown);\n\tClassDB::bind_method(D_METHOD(\"runFrame\", \"reserved_value\"), &Steam::runFrame, DEFVAL(true));\n\tClassDB::bind_method(D_METHOD(\"setLEDColor\", \"input_handle\", \"color_r\", \"color_g\", \"color_b\", \"flags\"), &Steam::setLEDColor);\n\tClassDB::bind_method(D_METHOD(\"showBindingPanel\", \"input_handle\"), &Steam::showBindingPanel);\n\tClassDB::bind_method(D_METHOD(\"stopAnalogActionMomentum\", \"input_handle\", \"action\"), &Steam::stopAnalogActionMomentum);\n\tClassDB::bind_method(D_METHOD(\"translateActionOrigin\", \"destination_input\", \"source_origin\"), &Steam::translateActionOrigin);\n\tClassDB::bind_method(D_METHOD(\"triggerHapticPulse\", \"input_handle\", \"target_pad\", \"duration\"), &Steam::triggerHapticPulse);\n\tClassDB::bind_method(D_METHOD(\"triggerRepeatedHapticPulse\", \"input_handle\", \"target_pad\", \"duration\", \"offset\", \"repeat\", \"flags\"), &Steam::triggerRepeatedHapticPulse);\n\tClassDB::bind_method(D_METHOD(\"triggerVibration\", \"input_handle\", \"left_speed\", \"right_speed\"), &Steam::triggerVibration);\n\tClassDB::bind_method(D_METHOD(\"setInputActionManifestFilePath\", \"manifest_path\"), &Steam::setInputActionManifestFilePath);\n\tClassDB::bind_method(D_METHOD(\"setDualSenseTriggerEffect\", \"input_handle\", \"parameters\", \"trigger_mask\", \"effect_mode\", \"position\", \"amplitude\", \"frequency\"), &Steam::setDualSenseTriggerEffect);\n\tClassDB::bind_method(D_METHOD(\"waitForData\", \"wait_forever\", \"timeout\"), &Steam::waitForData);\n\tClassDB::bind_method(\"newDataAvailable\", &Steam::newDataAvailable);\n\tClassDB::bind_method(\"enableDeviceCallbacks\", &Steam::enableDeviceCallbacks);\n\tClassDB::bind_method(\"enableActionEventCallbacks\", &Steam::enableActionEventCallbacks);\n\tClassDB::bind_method(D_METHOD(\"getGlyphPNGForActionOrigin\", \"origin\", \"size\", \"flags\"), &Steam::getGlyphPNGForActionOrigin);\n\tClassDB::bind_method(D_METHOD(\"getGlyphSVGForActionOrigin\", \"origin\", \"flags\"), &Steam::getGlyphSVGForActionOrigin);\n\tClassDB::bind_method(D_METHOD(\"triggerVibrationExtended\", \"input_handle\", \"left_speed\", \"right_speed\", \"left_trigger_speed\", \"right_trigger_speed\"), &Steam::triggerVibrationExtended);\n\tClassDB::bind_method(D_METHOD(\"triggerSimpleHapticEvent\", \"input_handle\", \"haptic_location\", \"intensity\", \"gain_db\", \"other_intensity\", \"other_gain_db\"), &Steam::triggerSimpleHapticEvent);\n\tClassDB::bind_method(D_METHOD(\"getStringForXboxOrigin\", \"origin\"), &Steam::getStringForXboxOrigin);\n\tClassDB::bind_method(D_METHOD(\"getGlyphForXboxOrigin\", \"origin\"), &Steam::getGlyphForXboxOrigin);\n\tClassDB::bind_method(\"getSessionInputConfigurationSettings\", &Steam::getSessionInputConfigurationSettings);\n\tClassDB::bind_method(D_METHOD(\"getStringForDigitalActionName\", \"action_handle\"), &Steam::getStringForDigitalActionName);\n\tClassDB::bind_method(D_METHOD(\"getStringForAnalogActionName\", \"action_handle\"), &Steam::getStringForAnalogActionName);\n\n\t// INVENTORY\n\tClassDB::bind_method(D_METHOD(\"addPromoItem\", \"item\"), &Steam::addPromoItem);\n\tClassDB::bind_method(D_METHOD(\"addPromoItems\", \"items\"), &Steam::addPromoItems);\n\tClassDB::bind_method(D_METHOD(\"checkResultSteamID\", \"steam_id_expected\", \"this_inventory_handle\"), &Steam::checkResultSteamID, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"consumeItem\", \"item_consume\", \"quantity\"), &Steam::consumeItem);\n\tClassDB::bind_method(D_METHOD(\"deserializeResult\", \"buffer\"), &Steam::deserializeResult);\n\tClassDB::bind_method(D_METHOD(\"destroyResult\", \"this_inventory_handle\"), &Steam::destroyResult, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"exchangeItems\", \"output_items\", \"output_quantity\", \"input_items\", \"input_quantity\"), &Steam::exchangeItems);\n\tClassDB::bind_method(D_METHOD(\"generateItems\", \"items\", \"quantity\"), &Steam::generateItems);\n\tClassDB::bind_method(\"getAllItems\", &Steam::getAllItems);\n\tClassDB::bind_method(D_METHOD(\"getItemDefinitionProperty\", \"definition\", \"name\"), &Steam::getItemDefinitionProperty);\n\tClassDB::bind_method(D_METHOD(\"getItemsByID\", \"id_array\"), &Steam::getItemsByID);\n\tClassDB::bind_method(D_METHOD(\"getItemPrice\", \"definition\"), &Steam::getItemPrice);\n\tClassDB::bind_method(D_METHOD(\"getItemsWithPrices\"), &Steam::getItemsWithPrices);\n\tClassDB::bind_method(D_METHOD(\"getResultItemProperty\", \"index\", \"name\", \"this_inventory_handle\"), &Steam::getResultItemProperty, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getResultItems\", \"this_inventory_handle\"), &Steam::getResultItems, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getResultStatus\", \"this_inventory_handle\"), &Steam::getResultStatus, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getResultTimestamp\", \"this_inventory_handle\"), &Steam::getResultTimestamp, DEFVAL(0));\n\tClassDB::bind_method(\"grantPromoItems\", &Steam::grantPromoItems);\n\tClassDB::bind_method(\"loadItemDefinitions\", &Steam::loadItemDefinitions);\n\tClassDB::bind_method(D_METHOD(\"requestEligiblePromoItemDefinitionsIDs\", \"steam_id\"), &Steam::requestEligiblePromoItemDefinitionsIDs);\n\tClassDB::bind_method(\"requestPrices\", &Steam::requestPrices);\n\tClassDB::bind_method(D_METHOD(\"serializeResult\", \"this_inventory_handle\"), &Steam::serializeResult, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"startPurchase\", \"items\", \"quantity\"), &Steam::startPurchase);\n\tClassDB::bind_method(D_METHOD(\"transferItemQuantity\", \"item_id\", \"quantity\", \"item_destination\", \"split\"), &Steam::transferItemQuantity);\n\tClassDB::bind_method(D_METHOD(\"triggerItemDrop\", \"definition\"), &Steam::triggerItemDrop);\n\tClassDB::bind_method(\"startUpdateProperties\", &Steam::startUpdateProperties);\n\tClassDB::bind_method(D_METHOD(\"submitUpdateProperties\", \"this_inventory_update_handle\"), &Steam::submitUpdateProperties, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"removeProperty\", \"item_id\", \"name\", \"this_inventory_update_handle\"), &Steam::removeProperty, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setPropertyString\", \"item_id\", \"name\", \"value\", \"this_inventory_update_handle\"), &Steam::setPropertyString, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setPropertyBool\", \"item_id\", \"name\", \"value\", \"this_inventory_update_handle\"), &Steam::setPropertyBool, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setPropertyInt\", \"item_id\", \"name\", \"value\", \"this_inventory_update_handle\"), &Steam::setPropertyInt, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"setPropertyFloat\", \"item_id\", \"name\", \"value\", \"this_inventory_update_handle\"), &Steam::setPropertyFloat, DEFVAL(0));\n\n\t// MATCHMAKING\n\tClassDB::bind_method(\"getFavoriteGames\", &Steam::getFavoriteGames);\n\tClassDB::bind_method(D_METHOD(\"addFavoriteGame\", \"ip\", \"port\", \"query_port\", \"flags\", \"last_played\"), &Steam::addFavoriteGame);\n\tClassDB::bind_method(D_METHOD(\"removeFavoriteGame\", \"app_id\", \"ip\", \"port\", \"query_port\", \"flags\"), &Steam::removeFavoriteGame);\n\tClassDB::bind_method(\"requestLobbyList\", &Steam::requestLobbyList);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListStringFilter\", \"key_to_match\", \"value_to_match\", \"comparison_type\"), &Steam::addRequestLobbyListStringFilter);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListNumericalFilter\", \"key_to_match\", \"value_to_match\", \"comparison_type\"), &Steam::addRequestLobbyListNumericalFilter);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListNearValueFilter\", \"key_to_match\", \"value_to_be_close_to\"), &Steam::addRequestLobbyListNearValueFilter);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListFilterSlotsAvailable\", \"slots_available\"), &Steam::addRequestLobbyListFilterSlotsAvailable);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListDistanceFilter\", \"distance_filter\"), &Steam::addRequestLobbyListDistanceFilter);\n\tClassDB::bind_method(D_METHOD(\"addRequestLobbyListResultCountFilter\", \"max_results\"), &Steam::addRequestLobbyListResultCountFilter);\n\tClassDB::bind_method(D_METHOD(\"createLobby\", \"lobby_type\", \"max_members\"), &Steam::createLobby, DEFVAL(2));\n\tClassDB::bind_method(D_METHOD(\"joinLobby\", \"steam_lobby_id\"), &Steam::joinLobby);\n\tClassDB::bind_method(D_METHOD(\"leaveLobby\", \"steam_lobby_id\"), &Steam::leaveLobby);\n\tClassDB::bind_method(D_METHOD(\"inviteUserToLobby\", \"steam_lobby_id\", \"steam_id_invitee\"), &Steam::inviteUserToLobby);\n\tClassDB::bind_method(D_METHOD(\"getNumLobbyMembers\", \"steam_lobby_id\"), &Steam::getNumLobbyMembers);\n\tClassDB::bind_method(D_METHOD(\"getLobbyMemberByIndex\", \"steam_lobby_id\", \"member\"), &Steam::getLobbyMemberByIndex);\n\tClassDB::bind_method(D_METHOD(\"getLobbyData\", \"steam_lobby_id\", \"key\"), &Steam::getLobbyData);\n\tClassDB::bind_method(D_METHOD(\"setLobbyData\", \"steam_lobby_id\", \"key\", \"value\"), &Steam::setLobbyData);\n\tClassDB::bind_method(D_METHOD(\"getAllLobbyData\", \"steam_lobby_id\"), &Steam::getAllLobbyData);\n\tClassDB::bind_method(D_METHOD(\"deleteLobbyData\", \"steam_lobby_id\", \"key\"), &Steam::deleteLobbyData);\n\tClassDB::bind_method(D_METHOD(\"getLobbyMemberData\", \"steam_lobby_id\", \"steam_id_user\", \"key\"), &Steam::getLobbyMemberData);\n\tClassDB::bind_method(D_METHOD(\"setLobbyMemberData\", \"steam_lobby_id\", \"key\", \"value\"), &Steam::setLobbyMemberData);\n\tClassDB::bind_method(D_METHOD(\"sendLobbyChatMsg\", \"steam_lobby_id\", \"message_body\"), &Steam::sendLobbyChatMsg);\n\tClassDB::bind_method(D_METHOD(\"requestLobbyData\", \"steam_lobby_id\"), &Steam::requestLobbyData);\n\tClassDB::bind_method(D_METHOD(\"setLobbyGameServer\", \"steam_lobby_id\", \"server_ip\", \"server_port\", \"steam_id_game_server\"), &Steam::setLobbyGameServer, DEFVAL(\"0\"), DEFVAL(0), DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"getLobbyGameServer\", \"steam_lobby_id\"), &Steam::getLobbyGameServer);\n\tClassDB::bind_method(D_METHOD(\"setLobbyMemberLimit\", \"steam_lobby_id\", \"max_members\"), &Steam::setLobbyMemberLimit);\n\tClassDB::bind_method(D_METHOD(\"getLobbyMemberLimit\", \"steam_lobby_id\"), &Steam::getLobbyMemberLimit);\n\tClassDB::bind_method(D_METHOD(\"setLobbyType\", \"steam_lobby_id\", \"lobby_type\"), &Steam::setLobbyType);\n\tClassDB::bind_method(D_METHOD(\"setLobbyJoinable\", \"steam_lobby_id\", \"joinable\"), &Steam::setLobbyJoinable);\n\tClassDB::bind_method(D_METHOD(\"getLobbyOwner\", \"steam_lobby_id\"), &Steam::getLobbyOwner);\n\tClassDB::bind_method(D_METHOD(\"setLobbyOwner\", \"steam_lobby_id\", \"steam_id_new_owner\"), &Steam::setLobbyOwner);\n\n\t// MATCHMAKING SERVERS\n\tClassDB::bind_method(D_METHOD(\"cancelQuery\", \"server_list_request\"), &Steam::cancelQuery);\n\tClassDB::bind_method(D_METHOD(\"cancelServerQuery\", \"server_query\"), &Steam::cancelServerQuery);\n\tClassDB::bind_method(D_METHOD(\"getServerCount\", \"server_list_request\"), &Steam::getServerCount);\n\tClassDB::bind_method(D_METHOD(\"getServerDetails\", \"server\", \"server_list_request\"), &Steam::getServerDetails);\n\tClassDB::bind_method(D_METHOD(\"isRefreshing\", \"server_list_request\"), &Steam::isRefreshing);\n\tClassDB::bind_method(D_METHOD(\"pingServer\", \"ip\", \"port\"), &Steam::pingServer);\n\tClassDB::bind_method(D_METHOD(\"playerDetails\", \"ip\", \"port\"), &Steam::playerDetails);\n\tClassDB::bind_method(D_METHOD(\"refreshQuery\", \"server_list_request\"), &Steam::refreshQuery);\n\tClassDB::bind_method(D_METHOD(\"refreshServer\", \"server\", \"server_list_request\"), &Steam::refreshServer);\n\tClassDB::bind_method(D_METHOD(\"releaseRequest\", \"server_list_request\"), &Steam::releaseRequest);\n\tClassDB::bind_method(D_METHOD(\"requestFavoritesServerList\", \"app_id\", \"filters\"), &Steam::requestFavoritesServerList);\n\tClassDB::bind_method(D_METHOD(\"requestFriendsServerList\", \"app_id\", \"filters\"), &Steam::requestFriendsServerList);\n\tClassDB::bind_method(D_METHOD(\"requestHistoryServerList\", \"app_id\", \"filters\"), &Steam::requestHistoryServerList);\n\tClassDB::bind_method(D_METHOD(\"requestInternetServerList\", \"app_id\", \"filters\"), &Steam::requestInternetServerList);\n\tClassDB::bind_method(D_METHOD(\"requestLANServerList\", \"app_id\"), &Steam::requestLANServerList);\n\tClassDB::bind_method(D_METHOD(\"requestSpectatorServerList\", \"app_id\", \"filters\"), &Steam::requestSpectatorServerList);\n\tClassDB::bind_method(D_METHOD(\"serverRules\", \"ip\", \"port\"), &Steam::serverRules);\n\n\t// MUSIC\n\tClassDB::bind_method(\"musicIsEnabled\", &Steam::musicIsEnabled);\n\tClassDB::bind_method(\"musicIsPlaying\", &Steam::musicIsPlaying);\n\tClassDB::bind_method(\"getPlaybackStatus\", &Steam::getPlaybackStatus);\n\tClassDB::bind_method(\"musicGetVolume\", &Steam::musicGetVolume);\n\tClassDB::bind_method(\"musicPause\", &Steam::musicPause);\n\tClassDB::bind_method(\"musicPlay\", &Steam::musicPlay);\n\tClassDB::bind_method(\"musicPlayNext\", &Steam::musicPlayNext);\n\tClassDB::bind_method(\"musicPlayPrev\", &Steam::musicPlayPrev);\n\tClassDB::bind_method(D_METHOD(\"musicSetVolume\", \"volume\"), &Steam::musicSetVolume);\n\n\t// MUSIC REMOTE\n\tClassDB::bind_method(D_METHOD(\"activationSuccess\", \"activate\"), &Steam::activationSuccess);\n\tClassDB::bind_method(\"isCurrentMusicRemote\", &Steam::isCurrentMusicRemote);\n\tClassDB::bind_method(\"currentEntryDidChange\", &Steam::currentEntryDidChange);\n\tClassDB::bind_method(D_METHOD(\"currentEntryIsAvailable\", \"available\"), &Steam::currentEntryIsAvailable);\n\tClassDB::bind_method(\"currentEntryWillChange\", &Steam::currentEntryWillChange);\n\tClassDB::bind_method(\"deregisterSteamMusicRemote\", &Steam::deregisterSteamMusicRemote);\n\tClassDB::bind_method(D_METHOD(\"enableLooped\", \"loop\"), &Steam::enableLooped);\n\tClassDB::bind_method(D_METHOD(\"enablePlaylists\", \"playlists\"), &Steam::enablePlaylists);\n\tClassDB::bind_method(D_METHOD(\"enablePlayNext\", \"next\"), &Steam::enablePlayNext);\n\tClassDB::bind_method(D_METHOD(\"enablePlayPrevious\", \"previous\"), &Steam::enablePlayPrevious);\n\tClassDB::bind_method(D_METHOD(\"enableQueue\", \"queue\"), &Steam::enableQueue);\n\tClassDB::bind_method(D_METHOD(\"enableShuffled\", \"shuffle\"), &Steam::enableShuffled);\n\tClassDB::bind_method(\"playlistDidChange\", &Steam::playlistDidChange);\n\tClassDB::bind_method(\"playlistWillChange\", &Steam::playlistWillChange);\n\tClassDB::bind_method(\"queueDidChange\", &Steam::queueDidChange);\n\tClassDB::bind_method(\"queueWillChange\", &Steam::queueWillChange);\n\tClassDB::bind_method(D_METHOD(\"registerSteamMusicRemote\", \"name\"), &Steam::registerSteamMusicRemote);\n\tClassDB::bind_method(\"resetPlaylistEntries\", &Steam::resetPlaylistEntries);\n\tClassDB::bind_method(\"resetQueueEntries\", &Steam::resetQueueEntries);\n\tClassDB::bind_method(D_METHOD(\"setCurrentPlaylistEntry\", \"id\"), &Steam::setCurrentPlaylistEntry);\n\tClassDB::bind_method(D_METHOD(\"setCurrentQueueEntry\", \"id\"), &Steam::setCurrentQueueEntry);\n\tClassDB::bind_method(D_METHOD(\"setDisplayName\", \"name\"), &Steam::setDisplayName);\n\tClassDB::bind_method(D_METHOD(\"setPlaylistEntry\", \"id\", \"position\", \"entry_text\"), &Steam::setPlaylistEntry);\n\tClassDB::bind_method(D_METHOD(\"setPNGIcon64x64\", \"icon\"), &Steam::setPNGIcon64x64);\n\tClassDB::bind_method(D_METHOD(\"setQueueEntry\", \"id\", \"position\", \"entry_text\"), &Steam::setQueueEntry);\n\tClassDB::bind_method(D_METHOD(\"updateCurrentEntryCoverArt\", \"art\"), &Steam::updateCurrentEntryCoverArt);\n\tClassDB::bind_method(D_METHOD(\"updateCurrentEntryElapsedSeconds\", \"seconds\"), &Steam::updateCurrentEntryElapsedSeconds);\n\tClassDB::bind_method(D_METHOD(\"updateCurrentEntryText\", \"text\"), &Steam::updateCurrentEntryText);\n\tClassDB::bind_method(D_METHOD(\"updateLooped\", \"looped\"), &Steam::updateLooped);\n\tClassDB::bind_method(D_METHOD(\"updatePlaybackStatus\", \"status\"), &Steam::updatePlaybackStatus);\n\tClassDB::bind_method(D_METHOD(\"updateShuffled\", \"shuffle\"), &Steam::updateShuffled);\n\tClassDB::bind_method(D_METHOD(\"updateVolume\", \"volume\"), &Steam::updateVolume);\n\n\t// NETWORKING\n\tClassDB::bind_method(D_METHOD(\"acceptP2PSessionWithUser\", \"remote_steam_id\"), &Steam::acceptP2PSessionWithUser);\n\tClassDB::bind_method(D_METHOD(\"allowP2PPacketRelay\", \"allow\"), &Steam::allowP2PPacketRelay);\n\tClassDB::bind_method(D_METHOD(\"closeP2PChannelWithUser\", \"remote_steam_id\", \"channel\"), &Steam::closeP2PChannelWithUser);\n\tClassDB::bind_method(D_METHOD(\"closeP2PSessionWithUser\", \"remote_steam_id\"), &Steam::closeP2PSessionWithUser);\n\tClassDB::bind_method(D_METHOD(\"getP2PSessionState\", \"remote_steam_id\"), &Steam::getP2PSessionState);\n\tClassDB::bind_method(D_METHOD(\"getAvailableP2PPacketSize\", \"channel\"), &Steam::getAvailableP2PPacketSize, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"readP2PPacket\", \"packet\", \"channel\"), &Steam::readP2PPacket, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"sendP2PPacket\", \"remote_steam_id\", \"data\", \"send_type\", \"channel\"), &Steam::sendP2PPacket, DEFVAL(0));\n\n\t// NETWORKING MESSAGES\n\tClassDB::bind_method(D_METHOD(\"acceptSessionWithUser\", \"remote_steam_id\"), &Steam::acceptSessionWithUser);\n\tClassDB::bind_method(D_METHOD(\"closeChannelWithUser\", \"remote_steam_id\", \"channel\"), &Steam::closeChannelWithUser);\n\tClassDB::bind_method(D_METHOD(\"closeSessionWithUser\", \"remote_steam_id\"), &Steam::closeSessionWithUser);\n\tClassDB::bind_method(D_METHOD(\"getSessionConnectionInfo\", \"remote_steam_id\", \"get_connection\", \"get_status\"), &Steam::getSessionConnectionInfo);\n\tClassDB::bind_method(D_METHOD(\"receiveMessagesOnChannel\", \"channel\", \"max_messages\"), &Steam::receiveMessagesOnChannel);\n\tClassDB::bind_method(D_METHOD(\"sendMessageToUser\", \"remote_steam_id\", \"data\", \"flags\", \"channel\"), &Steam::sendMessageToUser);\n\n\t// NETWORKING SOCKETS\n\tClassDB::bind_method(D_METHOD(\"acceptConnection\", \"connection_handle\"), &Steam::acceptConnection);\n\tClassDB::bind_method(D_METHOD(\"beginAsyncRequestFakeIP\", \"num_ports\"), &Steam::beginAsyncRequestFakeIP);\n\tClassDB::bind_method(D_METHOD(\"closeConnection\", \"peer\", \"reason\", \"debug_message\", \"linger\"), &Steam::closeConnection);\n\tClassDB::bind_method(D_METHOD(\"closeListenSocket\", \"socket\"), &Steam::closeListenSocket);\n\tClassDB::bind_method(D_METHOD(\"configureConnectionLanes\", \"connection\", \"lanes\", \"priorities\", \"weights\"), &Steam::configureConnectionLanes);\n\tClassDB::bind_method(D_METHOD(\"connectP2P\", \"remote_steam_id\", \"virtual_port\", \"options\"), &Steam::connectP2P);\n\tClassDB::bind_method(D_METHOD(\"connectByIPAddress\", \"ip_address_with_port\", \"options\"), &Steam::connectByIPAddress);\n\tClassDB::bind_method(D_METHOD(\"connectToHostedDedicatedServer\", \"remote_steam_id\", \"virtual_port\", \"options\"), &Steam::connectToHostedDedicatedServer);\n\tClassDB::bind_method(D_METHOD(\"createFakeUDPPort\", \"fake_server_port\"), &Steam::createFakeUDPPort);\n\tClassDB::bind_method(D_METHOD(\"createHostedDedicatedServerListenSocket\", \"virtual_port\", \"options\"), &Steam::createHostedDedicatedServerListenSocket);\n\tClassDB::bind_method(D_METHOD(\"createListenSocketIP\", \"ip_reference\", \"options\"), &Steam::createListenSocketIP);\n\tClassDB::bind_method(D_METHOD(\"createListenSocketP2P\", \"virtual_port\", \"options\"), &Steam::createListenSocketP2P);\n\tClassDB::bind_method(D_METHOD(\"createListenSocketP2PFakeIP\", \"fake_port\", \"options\"), &Steam::createListenSocketP2PFakeIP);\n\tClassDB::bind_method(\"createPollGroup\", &Steam::createPollGroup);\n\tClassDB::bind_method(D_METHOD(\"createSocketPair\", \"loopback\", \"remote_steam_id1\", \"remote_steam_id2\"), &Steam::createSocketPair);\n\tClassDB::bind_method(D_METHOD(\"destroyPollGroup\", \"poll_group\"), &Steam::destroyPollGroup);\n//\tClassDB::bind_method(D_METHOD(\"findRelayAuthTicketForServer\", \"port\"), &Steam::findRelayAuthTicketForServer);\t<------ Uses datagram relay structs which were removed from base SDK\n\tClassDB::bind_method(D_METHOD(\"flushMessagesOnConnection\", \"connection_handle\"), &Steam::flushMessagesOnConnection);\n\tClassDB::bind_method(\"getAuthenticationStatus\", &Steam::getAuthenticationStatus);\n\tClassDB::bind_method(\"getCertificateRequest\", &Steam::getCertificateRequest);\n\tClassDB::bind_method(D_METHOD(\"getConnectionInfo\", \"connection_handle\"), &Steam::getConnectionInfo);\n\tClassDB::bind_method(D_METHOD(\"getConnectionName\", \"peer\"), &Steam::getConnectionName);\n\tClassDB::bind_method(D_METHOD(\"getConnectionRealTimeStatus\", \"connection_handle\", \"lanes\", \"get_status\"), &Steam::getConnectionRealTimeStatus, DEFVAL(true));\n\tClassDB::bind_method(D_METHOD(\"getConnectionUserData\", \"peer\"), &Steam::getConnectionUserData);\n\tClassDB::bind_method(D_METHOD(\"getDetailedConnectionStatus\", \"connection_handle\"), &Steam::getDetailedConnectionStatus);\n\tClassDB::bind_method(D_METHOD(\"getFakeIP\", \"first_port\"), &Steam::getFakeIP, DEFVAL(0));\n//\tClassDB::bind_method(D_METHOD(\"getGameCoordinatorServerLogin\", \"app_data\"), &Steam::getGameCoordinatorServerLogin);\t<------ Uses datagram relay structs which were removed from base SDK\n//\tClassDB::bind_method(\"getHostedDedicatedServerAddress\", &Steam::getHostedDedicatedServerAddress);\t<------ Uses datagram relay structs which were removed from base SDK\n\tClassDB::bind_method(\"getHostedDedicatedServerPOPId\", &Steam::getHostedDedicatedServerPOPId);\n\tClassDB::bind_method(\"getHostedDedicatedServerPort\", &Steam::getHostedDedicatedServerPort);\n\tClassDB::bind_method(D_METHOD(\"getListenSocketAddress\", \"socket\", \"with_port\"), &Steam::getListenSocketAddress, DEFVAL(true));\n\tClassDB::bind_method(D_METHOD(\"getRemoteFakeIPForConnection\", \"connection\"), &Steam::getRemoteFakeIPForConnection);\n\tClassDB::bind_method(\"initAuthentication\", &Steam::initAuthentication);\n\tClassDB::bind_method(D_METHOD(\"receiveMessagesOnConnection\", \"connection\", \"max_messages\"), &Steam::receiveMessagesOnConnection);\n\tClassDB::bind_method(D_METHOD(\"receiveMessagesOnPollGroup\", \"poll_group\", \"max_messages\"), &Steam::receiveMessagesOnPollGroup);\n//\tClassDB::bind_method(\"receivedRelayAuthTicket\", &Steam::receivedRelayAuthTicket);\t<------ Uses datagram relay structs which were removed from base SDK\n\tClassDB::bind_method(D_METHOD(\"resetIdentity\", \"remote_steam_id\"), &Steam::resetIdentity);\n\tClassDB::bind_method(\"runNetworkingCallbacks\", &Steam::runNetworkingCallbacks);\n//\tClassDB::bind_method(D_METHOD(\"sendMessages\", \"data\", \"connection_handle\", \"flags\"), &Steam::sendMessages);\t\t<------ Currently does not compile on Windows but does on Linux\n\tClassDB::bind_method(D_METHOD(\"sendMessageToConnection\", \"connection_handle\", \"data\", \"flags\"), &Steam::sendMessageToConnection);\n\tClassDB::bind_method(D_METHOD(\"setCertificate\", \"certificate\"), &Steam::setCertificate);\n\tClassDB::bind_method(D_METHOD(\"setConnectionPollGroup\", \"connection_handle\", \"poll_group\"), &Steam::setConnectionPollGroup);\n\tClassDB::bind_method(D_METHOD(\"setConnectionName\", \"peer\", \"name\"), &Steam::setConnectionName);\n\n\t// NETWORKING UTILS\n\tClassDB::bind_method(D_METHOD(\"checkPingDataUpToDate\", \"max_age_in_seconds\"), &Steam::checkPingDataUpToDate);\n\tClassDB::bind_method(D_METHOD(\"convertPingLocationToString\", \"location\"), &Steam::convertPingLocationToString);\n\tClassDB::bind_method(D_METHOD(\"estimatePingTimeBetweenTwoLocations\", \"location1\", \"location2\"), &Steam::estimatePingTimeBetweenTwoLocations);\n\tClassDB::bind_method(D_METHOD(\"estimatePingTimeFromLocalHost\", \"location\"), &Steam::estimatePingTimeFromLocalHost);\n\tClassDB::bind_method(D_METHOD(\"getConfigValue\", \"config_value\", \"scope_type\", \"connection_handle\"), &Steam::getConfigValue);\n\tClassDB::bind_method(D_METHOD(\"getConfigValueInfo\", \"config_value\"), &Steam::getConfigValueInfo);\n\tClassDB::bind_method(D_METHOD(\"getDirectPingToPOP\", \"pop_id\"), &Steam::getDirectPingToPOP);\n\tClassDB::bind_method(\"getLocalPingLocation\", &Steam::getLocalPingLocation);\n\tClassDB::bind_method(\"getLocalTimestamp\", &Steam::getLocalTimestamp);\n\tClassDB::bind_method(D_METHOD(\"getPingToDataCenter\", \"pop_id\"), &Steam::getPingToDataCenter);\n\tClassDB::bind_method(\"getPOPCount\", &Steam::getPOPCount);\n\tClassDB::bind_method(\"getPOPList\", &Steam::getPOPList);\n\tClassDB::bind_method(\"getRelayNetworkStatus\", &Steam::getRelayNetworkStatus);\n\tClassDB::bind_method(\"initRelayNetworkAccess\", &Steam::initRelayNetworkAccess);\n\tClassDB::bind_method(D_METHOD(\"parsePingLocationString\", \"string\"), &Steam::parsePingLocationString);\n\tClassDB::bind_method(D_METHOD(\"setConnectionConfigValueFloat\", \"connection\", \"config\", \"value\"), &Steam::setConnectionConfigValueFloat);\n\tClassDB::bind_method(D_METHOD(\"setConnectionConfigValueInt32\", \"connection\", \"config\", \"value\"), &Steam::setConnectionConfigValueInt32);\n\tClassDB::bind_method(D_METHOD(\"setConnectionConfigValueString\", \"connection\", \"config\", \"value\"), &Steam::setConnectionConfigValueString);\n\t//\tClassDB::bind_method(D_METHOD(\"setConfigValue\", \"setting\", \"scope_type\", \"connection_handle\", \"data_type\", \"value\"), &Steam::setConfigValue);\n\tClassDB::bind_method(D_METHOD(\"setGlobalConfigValueFloat\", \"config\", \"value\"), &Steam::setGlobalConfigValueFloat);\n\tClassDB::bind_method(D_METHOD(\"setGlobalConfigValueInt32\", \"config\", \"value\"), &Steam::setGlobalConfigValueInt32);\n\tClassDB::bind_method(D_METHOD(\"setGlobalConfigValueString\", \"config\", \"value\"), &Steam::setGlobalConfigValueString);\n\n\t// PARENTAL SETTINGS\n\tClassDB::bind_method(\"isParentalLockEnabled\", &Steam::isParentalLockEnabled);\n\tClassDB::bind_method(\"isParentalLockLocked\", &Steam::isParentalLockLocked);\n\tClassDB::bind_method(D_METHOD(\"isAppBlocked\", \"app_id\"), &Steam::isAppBlocked);\n\tClassDB::bind_method(D_METHOD(\"isAppInBlockList\", \"app_id\"), &Steam::isAppInBlockList);\n\tClassDB::bind_method(D_METHOD(\"isFeatureBlocked\", \"feature\"), &Steam::isFeatureBlocked);\n\tClassDB::bind_method(D_METHOD(\"isFeatureInBlockList\", \"feature\"), &Steam::isFeatureInBlockList);\n\n\t// PARTIES\n\tClassDB::bind_method(D_METHOD(\"cancelReservation\", \"beacon_id\", \"steam_id\"), &Steam::cancelReservation);\n\tClassDB::bind_method(D_METHOD(\"changeNumOpenSlots\", \"beacon_id\", \"open_slots\"), &Steam::changeNumOpenSlots);\n\tClassDB::bind_method(D_METHOD(\"createBeacon\", \"open_slots\", \"location_id\", \"type\", \"connect_string\", \"beacon_metadata\"), &Steam::createBeacon);\n\tClassDB::bind_method(D_METHOD(\"destroyBeacon\", \"beacon_id\"), &Steam::destroyBeacon);\n\tClassDB::bind_method(D_METHOD(\"getAvailableBeaconLocations\", \"max\"), &Steam::getAvailableBeaconLocations);\n\tClassDB::bind_method(D_METHOD(\"getBeaconByIndex\", \"index\"), &Steam::getBeaconByIndex);\n\tClassDB::bind_method(D_METHOD(\"getBeaconDetails\", \"beacon_id\"), &Steam::getBeaconDetails);\n\tClassDB::bind_method(D_METHOD(\"getBeaconLocationData\", \"location_id\", \"location_type\", \"location_data\"), &Steam::getBeaconLocationData);\n\tClassDB::bind_method(\"getNumActiveBeacons\", &Steam::getNumActiveBeacons);\n\tClassDB::bind_method(D_METHOD(\"joinParty\", \"beacon_id\"), &Steam::joinParty);\n\tClassDB::bind_method(D_METHOD(\"onReservationCompleted\", \"beacon_id\", \"steam_id\"), &Steam::onReservationCompleted);\n\n\t// REMOTE PLAY\n\tClassDB::bind_method(\"getSessionCount\", &Steam::getSessionCount);\n\tClassDB::bind_method(D_METHOD(\"getSessionID\", \"index\"), &Steam::getSessionID);\n\tClassDB::bind_method(D_METHOD(\"getSessionSteamID\", \"session_id\"), &Steam::getSessionSteamID);\n\tClassDB::bind_method(D_METHOD(\"getSessionClientName\", \"session_id\"), &Steam::getSessionClientName);\n\tClassDB::bind_method(D_METHOD(\"getSessionClientFormFactor\", \"session_id\"), &Steam::getSessionClientFormFactor);\n\tClassDB::bind_method(D_METHOD(\"getSessionClientResolution\", \"session_id\"), &Steam::getSessionClientResolution);\n\tClassDB::bind_method(D_METHOD(\"sendRemotePlayTogetherInvite\", \"friend_id\"), &Steam::sendRemotePlayTogetherInvite);\n\tClassDB::bind_method(D_METHOD(\"startRemotePlayTogether\", \"show_overlay\"), &Steam::startRemotePlayTogether, DEFVAL(true));\n\n\t// REMOTE STORAGE\n\tClassDB::bind_method(\"beginFileWriteBatch\", &Steam::beginFileWriteBatch);\n\tClassDB::bind_method(\"endFileWriteBatch\", &Steam::endFileWriteBatch);\n\tClassDB::bind_method(D_METHOD(\"fileDelete\", \"file\"), &Steam::fileDelete);\n\tClassDB::bind_method(D_METHOD(\"fileExists\", \"file\"), &Steam::fileExists);\n\tClassDB::bind_method(D_METHOD(\"fileForget\", \"file\"), &Steam::fileForget);\n\tClassDB::bind_method(D_METHOD(\"filePersisted\", \"file\"), &Steam::filePersisted);\n\tClassDB::bind_method(D_METHOD(\"fileRead\", \"file\", \"data_to_read\"), &Steam::fileRead);\n\tClassDB::bind_method(D_METHOD(\"fileReadAsync\", \"file\", \"offset\", \"data_to_read\"), &Steam::fileReadAsync);\n\tClassDB::bind_method(D_METHOD(\"fileShare\", \"file\"), &Steam::fileShare);\n\tClassDB::bind_method(D_METHOD(\"fileWrite\", \"file\", \"data\", \"size\"), &Steam::fileWrite, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"fileWriteAsync\", \"file\", \"data\", \"size\"), &Steam::fileWriteAsync, DEFVAL(0));\n\tClassDB::bind_method(D_METHOD(\"fileWriteStreamCancel\", \"write_handle\"), &Steam::fileWriteStreamCancel);\n\tClassDB::bind_method(D_METHOD(\"fileWriteStreamClose\", \"write_handle\"), &Steam::fileWriteStreamClose);\n\tClassDB::bind_method(D_METHOD(\"fileWriteStreamOpen\", \"file\"), &Steam::fileWriteStreamOpen);\n\tClassDB::bind_method(D_METHOD(\"fileWriteStreamWriteChunk\", \"write_handle\", \"data\"), &Steam::fileWriteStreamWriteChunk);\n\tClassDB::bind_method(\"getCachedUGCCount\", &Steam::getCachedUGCCount);\n\tClassDB::bind_method(D_METHOD(\"getCachedUGCHandle\", \"content\"), &Steam::getCachedUGCHandle);\n\tClassDB::bind_method(\"getFileCount\", &Steam::getFileCount);\n\tClassDB::bind_method(D_METHOD(\"getFileNameAndSize\", \"file\"), &Steam::getFileNameAndSize);\n\tClassDB::bind_method(D_METHOD(\"getFileSize\", \"file\"), &Steam::getFileSize);\n\tClassDB::bind_method(D_METHOD(\"getFileTimestamp\", \"file\"), &Steam::getFileTimestamp);\n\tClassDB::bind_method(D_METHOD(\"getLocalFileChange\", \"file\"), &Steam::getLocalFileChange);\n\tClassDB::bind_method(\"getLocalFileChangeCount\", &Steam::getLocalFileChangeCount);\n\tClassDB::bind_method(\"getQuota\", &Steam::getQuota);\n\tClassDB::bind_method(D_METHOD(\"getSyncPlatforms\", \"file\"), &Steam::getSyncPlatforms);\n\tClassDB::bind_method(D_METHOD(\"getUGCDetails\", \"content\"), &Steam::getUGCDetails);\n\tClassDB::bind_method(D_METHOD(\"getUGCDownloadProgress\", \"content\"), &Steam::getUGCDownloadProgress);\n\tClassDB::bind_method(\"isCloudEnabledForAccount\", &Steam::isCloudEnabledForAccount);\n\tClassDB::bind_method(\"isCloudEnabledForApp\", &Steam::isCloudEnabledForApp);\n\tClassDB::bind_method(D_METHOD(\"setCloudEnabledForApp\", \"enabled\"), &Steam::setCloudEnabledForApp);\n\tClassDB::bind_method(D_METHOD(\"setSyncPlatforms\", \"file\", \"platform\"), &Steam::setSyncPlatforms);\n\tClassDB::bind_method(D_METHOD(\"ugcDownload\", \"content\", \"priority\"), &Steam::ugcDownload);\n\tClassDB::bind_method(D_METHOD(\"ugcDownloadToLocation\", \"content\", \"location\", \"priority\"), &Steam::ugcDownloadToLocation);\n\tClassDB::bind_method(D_METHOD(\"ugcRead\", \"content\", \"data_size\", \"offset\", \"action\"), &Steam::ugcRead);\n\n\t// SCREENSHOT\n\tClassDB::bind_method(D_METHOD(\"addScreenshotToLibrary\", \"filename\", \"thumbnail_filename\", \"width\", \"height\"), &Steam::addScreenshotToLibrary);\n\tClassDB::bind_method(D_METHOD(\"addVRScreenshotToLibrary\", \"type\", \"filename\", \"vr_filename\"), &Steam::addVRScreenshotToLibrary);\n\tClassDB::bind_method(D_METHOD(\"hookScreenshots\", \"hook\"), &Steam::hookScreenshots);\n\tClassDB::bind_method(\"isScreenshotsHooked\", &Steam::isScreenshotsHooked);\n\tClassDB::bind_method(D_METHOD(\"setLocation\", \"screenshot\", \"location\"), &Steam::setLocation);\n\tClassDB::bind_method(D_METHOD(\"tagPublishedFile\", \"screenshot\", \"file_id\"), &Steam::tagPublishedFile);\n\tClassDB::bind_method(D_METHOD(\"tagUser\", \"screenshot\", \"steam_id\"), &Steam::tagUser);\n\tClassDB::bind_method(\"triggerScreenshot\", &Steam::triggerScreenshot);\n\tClassDB::bind_method(D_METHOD(\"writeScreenshot\", \"rgb\", \"width\", \"height\"), &Steam::writeScreenshot);\n\n\t// TIMELINE\n\tClassDB::bind_method(D_METHOD(\"addGamePhaseTag\", \"tag_name\", \"tag_icon\", \"tag_group\", \"priority\"), &Steam::addGamePhaseTag);\n\tClassDB::bind_method(D_METHOD(\"addInstantaneousTimelineEvent\", \"title\", \"description\", \"icon\", \"icon_priority\", \"start_offset_seconds\", \"possible_clip\"), &Steam::addInstantaneousTimelineEvent, DEFVAL(TIMELINE_EVENT_CLIP_PRIORITY_NONE));\n\tClassDB::bind_method(D_METHOD(\"addRangeTimelineEvent\", \"title\", \"description\", \"icon\", \"icon_priority\", \"start_offset_seconds\", \"duration\", \"possible_clip\"), &Steam::addRangeTimelineEvent, DEFVAL(TIMELINE_EVENT_CLIP_PRIORITY_NONE));\n\tClassDB::bind_method(D_METHOD(\"clearTimelineTooltip\", \"time_delta\"), &Steam::clearTimelineTooltip);\n\tClassDB::bind_method(D_METHOD(\"doesEventRecordingExist\", \"this_event\"), &Steam::doesEventRecordingExist);\n\tClassDB::bind_method(D_METHOD(\"doesGamePhaseRecordingExist\", \"phase_id\"), &Steam::doesGamePhaseRecordingExist);\n\tClassDB::bind_method(D_METHOD(\"endGamePhase\"), &Steam::endGamePhase);\n\tClassDB::bind_method(D_METHOD(\"endRangeTimelineEvent\", \"this_event\", \"end_offset_seconds\"), &Steam::endRangeTimelineEvent);\n\tClassDB::bind_method(D_METHOD(\"openOverlayToGamePhase\", \"phase_id\"), &Steam::openOverlayToGamePhase);\n\tClassDB::bind_method(D_METHOD(\"openOverlayToTimelineEvent\", \"this_event\"), &Steam::openOverlayToTimelineEvent);\n\tClassDB::bind_method(D_METHOD(\"removeTimelineEvent\", \"this_event\"), &Steam::removeTimelineEvent);\n\tClassDB::bind_method(D_METHOD(\"se"
        },
        {
          "name": "godotsteam.h",
          "type": "blob",
          "size": 76.2705078125,
          "content": "#ifndef GODOTSTEAM_H\n#define GODOTSTEAM_H\n\n\n// Turn off MSVC-only warning about strcpy\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS 1\n#pragma warning(disable : 4996)\n#pragma warning(disable : 4828)\n#endif\n\n\n// Include INT types header\n#include <inttypes.h>\n\n// Include Steamworks API headers\n#include \"steam/steam_api_flat.h\"\n#include \"steam/steamnetworkingfakeip.h\"\n#include \"steam/isteamdualsense.h\"\n\n// Include Godot headers\n#include \"core/object/object.h\"\n#include \"core/object/ref_counted.h\"\n#include \"core/variant/dictionary.h\"\n#include \"scene/main/scene_tree.h\"\n#include \"scene/resources/texture.h\"\n\n// Include GodotSteam headers\n#include \"godotsteam_constants.h\"\n#include \"godotsteam_enums.h\"\n\n// Include some system headers\n#include \"map\"\n\n\nclass Steam : public Object,\n\tISteamMatchmakingServerListResponse,\n\tISteamMatchmakingPingResponse,\n\tISteamMatchmakingPlayersResponse,\n\tISteamMatchmakingRulesResponse {\n\n\tGDCLASS(Steam, Object);\n\n\npublic:\n\n\tstatic Steam *get_singleton();\n\tSteam();\n\t~Steam();\n\n\n\t// STEAMWORKS FUNCTIONS\n\t// Main\n\tString get_godotsteam_version() const { return godotsteam_version; }\n\tuint32_t getSteamID32(uint64_t steam_id);\n\tbool isAnonAccount(uint64_t steam_id);\n\tbool isAnonUserAccount(uint64_t steam_id);\n\tbool isChatAccount(uint64_t steam_id);\n\tbool isClanAccount(uint64_t steam_id);\n\tbool isConsoleUserAccount(uint64_t steam_id);\n\tbool isIndividualAccount(uint64_t steam_id);\n\tbool isLobby(uint64_t steam_id);\n\tbool isSteamRunning();\n\tbool restartAppIfNecessary(uint32 app_id);\n\tDictionary steamInit(bool retrieve_stats = false, uint32_t app_id = 0, bool embed_callbacks = false);\n\tDictionary steamInitEx(bool retrieve_stats = false, uint32_t app_id = 0, bool embed_callbacks = false);\n\tvoid steamShutdown();\n\n\tuint32 get_browser_handle() const { return browser_handle; }\n\tuint32_t get_current_app_id() const { return current_app_id; }\n\tuint64_t get_current_clan_id() const { return current_clan_id; }\n\tuint64_t get_current_steam_id() const { return current_steam_id; }\n\tint32 get_inventory_handle() const { return inventory_handle; }\n\tuint64_t get_inventory_update_handle() const { return inventory_update_handle; }\n\tuint64_t get_leaderboard_handle() const { return leaderboard_handle; }\n\tint get_leaderboard_details_max() const { return leaderboard_details_max; }\n\tArray get_leaderboard_entries() const { return leaderboard_entries_array; }\n\tuint64_t get_server_list_request() const { return (uint64)server_list_request; }\n\tvoid set_browser_handle(uint32 new_browser_handle){ browser_handle = new_browser_handle; }\n\tvoid set_current_app_id(uint32_t new_current_app_id){ current_app_id = new_current_app_id; }\n\tvoid set_current_clan_id(uint64_t new_current_clan_id){ current_clan_id = new_current_clan_id; }\n\tvoid set_current_steam_id(uint64_t new_current_steam_id){ current_steam_id = new_current_steam_id; }\n\tvoid set_inventory_handle(int32 new_inventory_handle){ inventory_handle = new_inventory_handle; }\n\tvoid set_inventory_update_handle(uint64_t new_inventory_update_handle){ inventory_update_handle = new_inventory_update_handle; }\n\tvoid set_leaderboard_details_max(int new_leaderboard_details_max) {\n\t\tif (new_leaderboard_details_max > k_cLeaderboardDetailsMax || new_leaderboard_details_max < 0) {\n\t\t\tnew_leaderboard_details_max = k_cLeaderboardDetailsMax;\n\t\t}\n\t\tleaderboard_details_max = new_leaderboard_details_max;\n\t}\n\tvoid set_leaderboard_entries(Array new_leaderboard_entries) { leaderboard_entries_array = new_leaderboard_entries; }\n\tvoid set_leaderboard_handle(uint64_t new_leaderboard_handle){ leaderboard_handle = new_leaderboard_handle; }\n\tvoid set_server_list_request(uint64_t new_server_list_request){ server_list_request = (HServerListRequest)new_server_list_request; }\n\n\t// Apps\n\tint getAppBuildId();\n\tDictionary getAppInstallDir(uint32_t app_id);\n\tuint64_t getAppOwner();\n\tString getAvailableGameLanguages();\n\tDictionary getBetaInfo();\n\tString getCurrentBetaName();\n\tString getCurrentGameLanguage();\n\tint32 getDLCCount();\n\tArray getDLCData();\n\tDictionary getDLCDataByIndex(uint32_t this_dlc_index);\n\tDictionary getDLCDownloadProgress(uint32_t dlc_id);\n\tuint32_t getEarliestPurchaseUnixTime(uint32_t app_id);\n\tvoid getFileDetails(const String &filename);\n\tArray getInstalledDepots(uint32_t app_id);\n\tString getLaunchCommandLine();\n\tString getLaunchQueryParam(const String &key);\n\tDictionary getNumBetas();\n\tvoid installDLC(uint32_t dlc_id);\n\tbool isAppInstalled(uint32_t app_id);\n\tbool isCybercafe();\n\tbool isDLCInstalled(uint32_t dlc_id);\n\tbool isLowViolence();\n\tbool isSubscribed();\n\tbool isSubscribedApp(uint32_t app_id);\n\tbool isSubscribedFromFamilySharing();\n\tbool isSubscribedFromFreeWeekend();\n\tDictionary isTimedTrial();\n\tbool isVACBanned();\n\tbool markContentCorrupt(bool missing_files_only);\n\tbool setActiveBeta(String beta_name);\n\tbool setDLCContext(uint32_t app_id);\n\tvoid uninstallDLC(uint32_t dlc_id);\n\n\t// Friends\n\tvoid activateGameOverlay(const String &type);\n\tvoid activateGameOverlayInviteDialog(uint64_t steam_id);\n\tvoid activateGameOverlayInviteDialogConnectString(const String &connect_string);\n\tvoid activateGameOverlayToStore(uint32_t app_id = 0);\n\tvoid activateGameOverlayToUser(const String &type, uint64_t steam_id);\n\tvoid activateGameOverlayToWebPage(const String &url);\n\tvoid clearRichPresence();\n\tbool closeClanChatWindowInSteam(uint64_t chat_id);\n\tvoid downloadClanActivityCounts(uint64_t clan_id, int clans_to_request);\n\tvoid enumerateFollowingList(uint32 start_index);\n\tuint64_t getChatMemberByIndex(uint64_t clan_id, int user);\n\tDictionary getClanActivityCounts(uint64_t clan_id);\n\tuint64_t getClanByIndex(int clan_index);\n\tint getClanChatMemberCount(uint64_t clan_id);\n\tDictionary getClanChatMessage(uint64_t chat_id, int message);\n\tint getClanCount();\n\tString getClanName(uint64_t clan_id);\n\tuint64_t getClanOfficerByIndex(uint64_t clan_id, int officer);\n\tint getClanOfficerCount(uint64_t clan_id);\n\tuint64_t getClanOwner(uint64_t clan_id);\n\tString getClanTag(uint64_t clan_id);\n\tuint64_t getCoplayFriend(int friend_number);\n\tint getCoplayFriendCount();\n\tvoid getFollowerCount(uint64_t steam_id);\n\tuint64_t getFriendByIndex(int friend_number, BitField<FriendFlags> friend_flags);\n\tuint32 getFriendCoplayGame(uint64_t friend_id);\n\tint getFriendCoplayTime(uint64_t friend_id);\n\tint getFriendCount(BitField<FriendFlags> friend_flags = FRIEND_FLAG_ALL);\n\tint getFriendCountFromSource(uint64_t source_id);\n\tuint64_t getFriendFromSourceByIndex(uint64_t source_id, int friend_number);\n\tDictionary getFriendGamePlayed(uint64_t steam_id);\n\tDictionary getFriendMessage(uint64_t friend_id, int message);\n\tString getFriendPersonaName(uint64_t steam_id);\n\tString getFriendPersonaNameHistory(uint64_t steam_id, int name_history);\n\tPersonaState getFriendPersonaState(uint64_t steam_id);\n\tFriendRelationship getFriendRelationship(uint64_t steam_id);\n\tString getFriendRichPresence(uint64_t friend_id, const String &key);\n\tint getFriendRichPresenceKeyCount(uint64_t friend_id);\n\tString getFriendRichPresenceKeyByIndex(uint64_t friend_id, int key);\n\tint getFriendsGroupCount();\n\tint16 getFriendsGroupIDByIndex(int16 friend_group);\n\tint getFriendsGroupMembersCount(int16 friend_group);\n\tArray getFriendsGroupMembersList(int16 friend_group, int member_count);\n\tString getFriendsGroupName(int16 friend_group);\n\tint getFriendSteamLevel(uint64_t steam_id);\n\tint getLargeFriendAvatar(uint64_t steam_id);\n\tint getMediumFriendAvatar(uint64_t steam_id);\n\tString getPersonaName();\n\tPersonaState getPersonaState();\n\tvoid getPlayerAvatar(int size = 2, uint64_t steam_id = 0);\n\tString getPlayerNickname(uint64_t steam_id);\n\tString getProfileItemPropertyString(uint64_t steam_id, CommunityProfileItemType item_type, CommunityProfileItemProperty item_property);\n\tuint32 getProfileItemPropertyInt(uint64_t steam_id, CommunityProfileItemType item_type, CommunityProfileItemProperty item_property);\n\tArray getRecentPlayers();\n\tint getSmallFriendAvatar(uint64_t steam_id);\n\tArray getUserFriendsGroups();\n\tuint32 getUserRestrictions();\n\tArray getUserSteamFriends();\n\tArray getUserSteamGroups();\n\tbool hasEquippedProfileItem(uint64_t steam_id, CommunityProfileItemType item_type);\n\tbool hasFriend(uint64_t steam_id, BitField<FriendFlags> friend_flags);\n\tbool inviteUserToGame(uint64_t friend_id, const String &connect_string);\n\tbool isClanChatAdmin(uint64_t chat_id, uint64_t steam_id);\n\tbool isClanPublic(uint64_t clan_id);\n\tbool isClanOfficialGameGroup(uint64_t clan_id);\n\tbool isClanChatWindowOpenInSteam(uint64_t chat_id);\n\tvoid isFollowing(uint64_t steam_id);\n\tbool isUserInSource(uint64_t steam_id, uint64_t source_id);\n\tvoid joinClanChatRoom(uint64_t clan_id);\n\tbool leaveClanChatRoom(uint64_t clan_id);\n\tbool openClanChatWindowInSteam(uint64_t chat_id);\n\tbool registerProtocolInOverlayBrowser(const String &protocol);\n\tbool replyToFriendMessage(uint64_t steam_id, const String &message);\n\tvoid requestClanOfficerList(uint64_t clan_id);\n\tvoid requestEquippedProfileItems(uint64_t steam_id);\n\tvoid requestFriendRichPresence(uint64_t friend_id);\n\tbool requestUserInformation(uint64_t steam_id, bool require_name_only);\n\tbool sendClanChatMessage(uint64_t chat_id, const String &text);\n\tvoid setInGameVoiceSpeaking(uint64_t steam_id, bool speaking);\n\tbool setListenForFriendsMessages(bool intercept);\n\tvoid setPersonaName(const String &name);\n\tvoid setPlayedWith(uint64_t steam_id);\n\tbool setRichPresence(const String &key, const String &value);\n\n\t// Game Search\n\tint addGameSearchParams(const String &key, const String &values);\n\tint searchForGameWithLobby(uint64_t lobby_id, int player_min, int player_max);\n\tint searchForGameSolo(int player_min, int player_max);\n\tint acceptGame();\n\tint declineGame();\n\tString retrieveConnectionDetails(uint64_t host_id);\n\tint endGameSearch();\n\tint setGameHostParams(const String &key, const String &value);\n\tint setConnectionDetails(const String &details, int connection_details);\n\tint requestPlayersForGame(int player_min, int player_max, int max_team_size);\n\tint hostConfirmGameStart(uint64_t game_id);\n\tint cancelRequestPlayersForGame();\n\tint submitPlayerResult(uint64_t game_id, uint64_t player_id, PlayerResult player_result);\n\tint endGame(uint64_t game_id);\n\n\t// HTML Surface\n\tvoid addHeader(const String &key, const String &value, uint32 this_handle = 0);\n\tvoid allowStartRequest(bool allowed, uint32 this_handle = 0);\n\tvoid copyToClipboard(uint32 this_handle = 0);\n\tvoid createBrowser(const String &user_agent = \"\", const String &user_css = \"\");\n\tvoid executeJavascript(const String &javascript, uint32 this_handle = 0);\n\tvoid find(const String &search, bool currently_in_find, bool reverse, uint32 this_handle = 0);\n\tvoid getLinkAtPosition(int x, int y, uint32 this_handle = 0);\n\tvoid goBack(uint32 this_handle = 0);\n\tvoid goForward(uint32 this_handle = 0);\n\tbool htmlInit();\n\tvoid jsDialogResponse(bool result, uint32 this_handle = 0);\n\tvoid keyChar(uint32 unicode_char, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle = 0);\n\tvoid keyDown(uint32 native_key_code, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle = 0);\n\tvoid keyUp(uint32 native_key_code, BitField<HTMLKeyModifiers> key_modifiers, uint32 this_handle = 0);\n\tvoid loadURL(const String &url, const String &post_data, uint32 this_handle = 0);\n\tvoid mouseDoubleClick(HTMLMouseButton mouse_button, uint32 this_handle = 0);\n\tvoid mouseDown(HTMLMouseButton mouse_button, uint32 this_handle = 0);\n\tvoid mouseMove(int x, int y, uint32 this_handle = 0);\n\tvoid mouseUp(HTMLMouseButton mouse_button, uint32 this_handle = 0);\n\tvoid mouseWheel(int32 delta, uint32 this_handle = 0);\n\tvoid pasteFromClipboard(uint32 this_handle = 0);\n\tvoid reload(uint32 this_handle = 0);\n\tvoid removeBrowser(uint32 this_handle = 0);\n\tvoid setBackgroundMode(bool background_mode, uint32 this_handle = 0);\n\tvoid setCookie(const String &hostname, const String &key, const String &value, const String &path, uint32 expires, bool secure, bool http_only);\n\tvoid setHorizontalScroll(uint32 absolute_pixel_scroll, uint32 this_handle = 0);\n\tvoid setKeyFocus(bool has_key_focus, uint32 this_handle = 0);\n\tvoid setPageScaleFactor(float zoom, int point_x, int point_y, uint32 this_handle = 0);\n\tvoid setSize(uint32 width, uint32 height, uint32 this_handle = 0);\n\tvoid setVerticalScroll(uint32 absolute_pixel_scroll, uint32 this_handle = 0);\n\tbool htmlShutdown();\n\tvoid stopFind(uint32 this_handle = 0);\n\tvoid stopLoad(uint32 this_handle = 0);\n\tvoid viewSource(uint32 this_handle = 0);\n\n\t// HTTP\n\tuint32_t createCookieContainer(bool allow_responses_to_modify);\n\tuint32_t createHTTPRequest(HTTPMethod request_method, const String &absolute_url);\n\tbool deferHTTPRequest(uint32 request_handle);\n\tfloat getHTTPDownloadProgressPct(uint32 request_handle);\n\tbool getHTTPRequestWasTimedOut(uint32 request_handle);\n\tPackedByteArray getHTTPResponseBodyData(uint32 request_handle, uint32 buffer_size);\n\tuint32 getHTTPResponseBodySize(uint32 request_handle);\n\tuint32 getHTTPResponseHeaderSize(uint32 request_handle, const String &header_name);\n\tPackedByteArray getHTTPResponseHeaderValue(uint32 request_handle, const String &header_name, uint32 buffer_size);\n\tPackedByteArray getHTTPStreamingResponseBodyData(uint32 request_handle, uint32 offset, uint32 buffer_size);\n\tbool prioritizeHTTPRequest(uint32 request_handle);\n\tbool releaseCookieContainer(uint32 cookie_handle);\n\tbool releaseHTTPRequest(uint32 request_handle);\n\tbool sendHTTPRequest(uint32 request_handle);\n\tbool sendHTTPRequestAndStreamResponse(uint32 request_handle);\n\tbool setHTTPCookie(uint32 cookie_handle, const String &host, const String &url, const String &cookie);\n\tbool setHTTPRequestAbsoluteTimeoutMS(uint32 request_handle, uint32 milliseconds);\n\tbool setHTTPRequestContextValue(uint32 request_handle, uint64_t context_value);\n\tbool setHTTPRequestCookieContainer(uint32 request_handle, uint32 cookie_handle);\n\tbool setHTTPRequestGetOrPostParameter(uint32 request_handle, const String &name, const String &value);\n\tbool setHTTPRequestHeaderValue(uint32 request_handle, const String &header_name, const String &header_value);\n\tbool setHTTPRequestNetworkActivityTimeout(uint32 request_handle, uint32 timeout_seconds);\n\tbool setHTTPRequestRawPostBody(uint32 request_handle, const String &content_type, const String &body);\n\tbool setHTTPRequestRequiresVerifiedCertificate(uint32 request_handle, bool require_verified_certificate);\n\tbool setHTTPRequestUserAgentInfo(uint32 request_handle, const String &user_agent_info);\n\n\t// Input\n\tvoid activateActionSet(uint64_t input_handle, uint64_t action_set_handle);\n\tvoid activateActionSetLayer(uint64_t input_handle, uint64_t action_set_layer_handle);\n\tvoid deactivateActionSetLayer(uint64_t input_handle, uint64_t action_set_handle);\n\tvoid deactivateAllActionSetLayers(uint64_t input_handle);\n\tvoid enableDeviceCallbacks();\n\tvoid enableActionEventCallbacks();\n\tuint64_t getActionSetHandle(const String &action_set_name);\n\tInputActionOrigin getActionOriginFromXboxOrigin(uint64_t input_handle, int origin);\n\tArray getActiveActionSetLayers(uint64_t input_handle);\n\tDictionary getAnalogActionData(uint64_t input_handle, uint64_t analog_action_handle);\n\tuint64_t getAnalogActionHandle(const String &action_name);\n\tArray getAnalogActionOrigins(uint64_t input_handle, uint64_t action_set_handle, uint64_t analog_action_handle);\n\tArray getConnectedControllers();\n\tuint64_t getControllerForGamepadIndex(int index);\n\tuint64_t getCurrentActionSet(uint64_t input_handle);\n\tArray getDeviceBindingRevision(uint64_t input_handle);\n\tDictionary getDigitalActionData(uint64_t input_handle, uint64_t digital_action_handle);\n\tuint64_t getDigitalActionHandle(const String &action_name);\n\tArray getDigitalActionOrigins(uint64_t input_handle, uint64_t action_set_handle, uint64_t digital_action_handle);\n\tint getGamepadIndexForController(uint64_t input_handle);\n\tString getGlyphForActionOrigin(InputActionOrigin origin);\n\tString getGlyphForXboxOrigin(int origin);\n\tString getGlyphPNGForActionOrigin(InputActionOrigin origin, InputGlyphSize size, uint32 flags);\n\tString getGlyphSVGForActionOrigin(InputActionOrigin origin, uint32 flags);\n\tInputType getInputTypeForHandle(uint64_t input_handle);\n\tDictionary getMotionData(uint64_t input_handle);\n\tint getRemotePlaySessionID(uint64_t input_handle);\n\tuint16 getSessionInputConfigurationSettings();\n\tString getStringForActionOrigin(InputActionOrigin origin);\n\tString getStringForAnalogActionName(uint64_t action_handle);\n\tString getStringForDigitalActionName(uint64_t action_handle);\n\tString getStringForXboxOrigin(int origin);\n\tvoid inputActionEventCallback(SteamInputActionEvent_t *call_data);\n\tbool inputInit(bool explicitly_call_runframe = false);\n\tbool inputShutdown();\n\tbool newDataAvailable();\n\tvoid runFrame(bool reserved_value = true);\n\tvoid setDualSenseTriggerEffect(uint64_t input_handle, int parameter_index, int trigger_mask, SCEPadTriggerEffectMode effect_mode, int position, int amplitude, int frequency);\n\tbool setInputActionManifestFilePath(const String &manifest_path);\n\tvoid setLEDColor(uint64_t input_handle, int color_r, int color_g, int color_b, int flags);\n\tbool showBindingPanel(uint64_t input_handle);\n\tvoid stopAnalogActionMomentum(uint64_t input_handle, uint64_t action);\n\tint translateActionOrigin(InputType destination_input, InputActionOrigin source_origin);\n\tvoid triggerHapticPulse(uint64_t input_handle, int target_pad, int duration);\n\tvoid triggerRepeatedHapticPulse(uint64_t input_handle, int target_pad, int duration, int offset, int repeat, int flags);\n\tvoid triggerSimpleHapticEvent(uint64_t input_handle, int haptic_location, uint8 intensity, const String &gain_db, uint8 other_intensity, const String &other_gain_db);\n\tvoid triggerVibration(uint64_t input_handle, uint16_t left_speed, uint16_t right_speed);\n\tvoid triggerVibrationExtended(uint64_t input_handle, uint16_t left_speed, uint16_t right_speed, uint16_t left_trigger_speed, uint16_t right_trigger_speed);\n\tbool waitForData(bool wait_forever, uint32 timeout);\n\n\t// Inventory\n\tint32 addPromoItem(uint32 item);\n\tint32 addPromoItems(PackedInt64Array items);\n\tbool checkResultSteamID(uint64_t steam_id_expected, int32 this_inventory_handle = 0);\n\tint32 consumeItem(uint64_t item_consume, uint32 quantity);\n\tint32 deserializeResult(PackedByteArray buffer);\n\tvoid destroyResult(int32 this_inventory_handle = 0);\n\tint32 exchangeItems(const PackedInt64Array output_items, const PackedInt32Array output_quantity, const PackedInt64Array input_items, const PackedInt32Array input_quantity);\n\tint32 generateItems(const PackedInt64Array items, const PackedInt32Array quantity);\n\tint32 getAllItems();\n\tString getItemDefinitionProperty(uint32 definition, const String &name);\n\tint32 getItemsByID(const PackedInt64Array id_array);\n\tDictionary getItemPrice(uint32 definition);\n\tArray getItemsWithPrices();\n\tString getResultItemProperty(uint32 index, const String &name, int32 this_inventory_handle = 0);\n\tArray getResultItems(int32 this_inventory_handle = 0);\n\tResult getResultStatus(int32 this_inventory_handle = 0);\n\tuint32 getResultTimestamp(int32 this_inventory_handle = 0);\n\tint32 grantPromoItems();\n\tbool loadItemDefinitions();\n\tvoid requestEligiblePromoItemDefinitionsIDs(uint64_t steam_id);\n\tvoid requestPrices();\n\tPackedByteArray serializeResult(int32 this_inventory_handle = 0);\n\tvoid startPurchase(const PackedInt64Array items, const PackedInt32Array quantity);\n\tint32 transferItemQuantity(uint64_t item_id, uint32 quantity, uint64_t item_destination, bool split);\n\tint32 triggerItemDrop(uint32 definition);\n\tvoid startUpdateProperties();\n\tint32 submitUpdateProperties(uint64_t this_inventory_update_handle = 0);\n\tbool removeProperty(uint64_t item_id, const String &name, uint64_t this_inventory_update_handle = 0);\n\tbool setPropertyString(uint64_t item_id, const String &name, const String &value, uint64_t this_inventory_update_handle = 0);\n\tbool setPropertyBool(uint64_t item_id, const String &name, bool value, uint64_t this_inventory_update_handle = 0);\n\tbool setPropertyInt(uint64_t item_id, const String &name, uint64_t value, uint64_t this_inventory_update_handle = 0);\n\tbool setPropertyFloat(uint64_t item_id, const String &name, float value, uint64_t this_inventory_update_handle = 0);\n\n\t// Matchmaking\n\tint addFavoriteGame(String ip, uint16 port, uint16 query_port, uint32 flags, uint32 last_played);\n\tvoid addRequestLobbyListDistanceFilter(LobbyDistanceFilter distance_filter);\n\tvoid addRequestLobbyListFilterSlotsAvailable(int slots_available);\n\tvoid addRequestLobbyListNearValueFilter(const String &key_to_match, int value_to_be_close_to);\n\tvoid addRequestLobbyListNumericalFilter(const String &key_to_match, int value_to_match, LobbyComparison comparison_type);\n\tvoid addRequestLobbyListResultCountFilter(int max_results);\n\tvoid addRequestLobbyListStringFilter(const String &key_to_match, const String &value_to_match, LobbyComparison comparison_type);\n\tvoid createLobby(LobbyType lobby_type, int max_members);\n\tbool deleteLobbyData(uint64_t steam_lobby_id, const String &key);\n\tDictionary getAllLobbyData(uint64_t steam_lobby_id);\n\tArray getFavoriteGames();\n\tString getLobbyData(uint64_t steam_lobby_id, const String &key);\n\tDictionary getLobbyGameServer(uint64_t steam_lobby_id);\n\tuint64_t getLobbyMemberByIndex(uint64_t steam_lobby_id, int member);\n\tString getLobbyMemberData(uint64_t steam_lobby_id, uint64_t steam_id_user, const String &key);\n\tint getLobbyMemberLimit(uint64_t steam_lobby_id);\n\tuint64_t getLobbyOwner(uint64_t steam_lobby_id);\n\tint getNumLobbyMembers(uint64_t steam_lobby_id);\n\tbool inviteUserToLobby(uint64_t steam_lobby_id, uint64_t steam_id_invitee);\n\tvoid joinLobby(uint64_t steam_lobby_id);\n\tvoid leaveLobby(uint64_t steam_lobby_id);\n\tbool removeFavoriteGame(uint32 app_id, String ip, uint16 port, uint16 query_port, uint32 flags);\n\tbool requestLobbyData(uint64_t steam_lobby_id);\n\tvoid requestLobbyList();\n\tbool sendLobbyChatMsg(uint64_t steam_lobby_id, const String &message_body);\n\tbool setLobbyData(uint64_t steam_lobby_id, const String &key, const String &value);\n\tvoid setLobbyGameServer(uint64_t steam_lobby_id, const String &server_ip = \"0\", uint16 server_port = 0, uint64_t steam_id_game_server = 0);\n\tbool setLobbyJoinable(uint64_t steam_lobby_id, bool joinable);\n\tvoid setLobbyMemberData(uint64_t steam_lobby_id, const String &key, const String &value);\n\tbool setLobbyMemberLimit(uint64_t steam_lobby_id, int max_members);\n\tbool setLobbyOwner(uint64_t steam_lobby_id, uint64_t steam_id_new_owner);\n\tbool setLobbyType(uint64_t steam_lobby_id, LobbyType lobby_type);\n\n\t// Matchmaking Servers\n\tvoid cancelQuery(uint64_t this_server_list_request = 0);\n\tvoid cancelServerQuery(int server_query);\n\tint getServerCount(uint64_t this_server_list_request = 0);\n\tDictionary getServerDetails(int server, uint64_t this_server_list_request = 0);\n\tbool isRefreshing(uint64_t this_server_list_request = 0);\n\tint pingServer(const String &ip, uint16 port);\n\tint playerDetails(const String &ip, uint16 port);\n\tvoid refreshQuery(uint64_t this_server_list_request = 0);\n\tvoid refreshServer(int server, uint64_t this_server_list_request = 0);\n\tvoid releaseRequest(uint64_t this_server_list_request = 0);\n\tuint64_t requestFavoritesServerList(uint32 app_id, Array filters);\n\tuint64_t requestFriendsServerList(uint32 app_id, Array filters);\n\tuint64_t requestHistoryServerList(uint32 app_id, Array filters);\n\tuint64_t requestInternetServerList(uint32 app_id, Array filters);\n\tuint64_t requestLANServerList(uint32 app_id);\n\tuint64_t requestSpectatorServerList(uint32 app_id, Array filters);\n\tint serverRules(const String &ip, uint16 port);\n\n\t// Music\n\tbool musicIsEnabled();\n\tbool musicIsPlaying();\n\tAudioPlaybackStatus getPlaybackStatus();\n\tfloat musicGetVolume();\n\tvoid musicPause();\n\tvoid musicPlay();\n\tvoid musicPlayNext();\n\tvoid musicPlayPrev();\n\tvoid musicSetVolume(float volume);\n\n\t// Music Remote\n\tbool activationSuccess(bool activate);\n\tbool isCurrentMusicRemote();\n\tbool currentEntryDidChange();\n\tbool currentEntryIsAvailable(bool available);\n\tbool currentEntryWillChange();\n\tbool deregisterSteamMusicRemote();\n\tbool enableLooped(bool loop);\n\tbool enablePlaylists(bool playlists);\n\tbool enablePlayNext(bool next);\n\tbool enablePlayPrevious(bool previous);\n\tbool enableQueue(bool queue);\n\tbool enableShuffled(bool shuffle);\n\tbool playlistDidChange();\n\tbool playlistWillChange();\n\tbool queueDidChange();\n\tbool queueWillChange();\n\tbool registerSteamMusicRemote(const String &name);\n\tbool resetPlaylistEntries();\n\tbool resetQueueEntries();\n\tbool setCurrentPlaylistEntry(int id);\n\tbool setCurrentQueueEntry(int id);\n\tbool setDisplayName(const String &name);\n\tbool setPlaylistEntry(int id, int position, const String &entry_text);\n\tbool setPNGIcon64x64(PackedByteArray icon);\n\tbool setQueueEntry(int id, int position, const String &entry_text);\n\tbool updateCurrentEntryCoverArt(PackedByteArray art);\n\tbool updateCurrentEntryElapsedSeconds(int seconds);\n\tbool updateCurrentEntryText(const String &text);\n\tbool updateLooped(bool looped);\n\tbool updatePlaybackStatus(AudioPlaybackStatus status);\n\tbool updateShuffled(bool shuffle);\n\tbool updateVolume(float volume);\n\n\t// Networking\n\tbool acceptP2PSessionWithUser(uint64_t remote_steam_id);\n\tbool allowP2PPacketRelay(bool allow);\n\tbool closeP2PChannelWithUser(uint64_t remote_steam_id, int channel);\n\tbool closeP2PSessionWithUser(uint64_t remote_steam_id);\n\tDictionary getP2PSessionState(uint64_t remote_steam_id);\n\tuint32_t getAvailableP2PPacketSize(int channel = 0);\n\tDictionary readP2PPacket(uint32_t packet, int channel = 0);\n\tbool sendP2PPacket(uint64_t remote_steam_id, const PackedByteArray data, P2PSend send_type, int channel = 0);\n\n\t// Networking Messages\n\tbool acceptSessionWithUser(uint64_t remote_steam_id);\n\tbool closeChannelWithUser(uint64_t remote_steam_id, int channel);\n\tbool closeSessionWithUser(uint64_t remote_steam_id);\n\tDictionary getSessionConnectionInfo(uint64_t remote_steam_id, bool get_connection, bool get_status);\n\tArray receiveMessagesOnChannel(int channel, int max_messages);\n\tint sendMessageToUser(uint64_t remote_steam_id, const PackedByteArray data, int flags, int channel);\n\n\t// Networking Sockets\n\tint acceptConnection(uint32 connection_handle);\n\tbool beginAsyncRequestFakeIP(int num_ports);\n\tbool closeConnection(uint32 peer, int reason, const String &debug_message, bool linger);\n\tbool closeListenSocket(uint32 socket);\n\tint configureConnectionLanes(uint32 connection, uint32 lanes, Array priorities, Array weights);\n\tuint32 connectP2P(uint64_t remote_steam_id, int virtual_port, Dictionary config_options);\n\tuint32 connectByIPAddress(String ip_address_with_port, Dictionary config_options);\n\tuint32 connectToHostedDedicatedServer(uint64_t remote_steam_id, int virtual_port, Dictionary config_options);\n\tvoid createFakeUDPPort(int fake_server_port);\n\tuint32 createHostedDedicatedServerListenSocket(int virtual_port, Dictionary config_options);\n\tuint32 createListenSocketIP(String ip_address, Dictionary config_options);\n\tuint32 createListenSocketP2P(int virtual_port, Dictionary config_options);\n\tuint32 createListenSocketP2PFakeIP(int fake_port, Dictionary config_options);\n\tuint32 createPollGroup();\n\tDictionary createSocketPair(bool loopback, uint64_t remote_steam_id1, uint64_t remote_steam_id2);\n\tbool destroyPollGroup(uint32 poll_group);\n//\tint findRelayAuthTicketForServer(int port);\t<------ Uses datagram relay structs which were removed from base SDK\n\tint flushMessagesOnConnection(uint32 connection_handle);\n\tNetworkingAvailability getAuthenticationStatus();\n\tDictionary getCertificateRequest();\n\tDictionary getConnectionInfo(uint32 connection_handle);\n\tString getConnectionName(uint32 peer);\n\tDictionary getConnectionRealTimeStatus(uint32 connection_handle, int lanes, bool get_status = true);\n\tuint64_t getConnectionUserData(uint32 peer);\n\tDictionary getDetailedConnectionStatus(uint32 connection_handle);\n\tDictionary getFakeIP(int first_port = 0);\n//\tint getGameCoordinatorServerLogin(const String& app_data);\t<------ Uses datagram relay structs which were removed from base SDK\n//\tint getHostedDedicatedServerAddress();\t<------ Uses datagram relay structs which were removed from base SDK\n\tuint32 getHostedDedicatedServerPOPId();\n\tuint16 getHostedDedicatedServerPort();\n\tString getListenSocketAddress(uint32 socket, bool with_port = true);\n\tDictionary getRemoteFakeIPForConnection(uint32 connection);\n\tNetworkingAvailability initAuthentication();\n\tArray receiveMessagesOnConnection(uint32 connection, int max_messages);\n\tArray receiveMessagesOnPollGroup(uint32 poll_group, int max_messages);\n//\tDictionary receivedRelayAuthTicket();\t<------ Uses datagram relay structs which were removed from base SDK\n\tvoid resetIdentity(uint64_t remote_steam_id);\n\tvoid runNetworkingCallbacks();\n//\tArray sendMessages(Array messages, uint32 connection_handle, int flags);\t<------ Currently does not compile on Windows but does on Linux\n\tDictionary sendMessageToConnection(uint32 connection_handle, const PackedByteArray data, int flags);\n\tDictionary setCertificate(const PackedByteArray &certificate);\n\tbool setConnectionPollGroup(uint32 connection_handle, uint32 poll_group);\n\tvoid setConnectionName(uint32 peer, const String &name);\n\n\t// Networking Utils\n\tbool checkPingDataUpToDate(float max_age_in_seconds);\n\tString convertPingLocationToString(PackedByteArray location);\n\tint estimatePingTimeBetweenTwoLocations(PackedByteArray location1, PackedByteArray location2);\n\tint estimatePingTimeFromLocalHost(PackedByteArray location);\n\tDictionary getConfigValue(NetworkingConfigValue config_value, NetworkingConfigScope scope_type, uint32_t connection_handle);\n\tDictionary getConfigValueInfo(NetworkingConfigValue config_value);\n\tint getDirectPingToPOP(uint32 pop_id);\n\tDictionary getLocalPingLocation();\n\tuint64_t getLocalTimestamp();\n\tDictionary getPingToDataCenter(uint32 pop_id);\n\tint getPOPCount();\n\tArray getPOPList();\n\tNetworkingAvailability getRelayNetworkStatus();\n\tvoid initRelayNetworkAccess();\n\tDictionary parsePingLocationString(const String &location_string);\n\tbool setConnectionConfigValueFloat(uint32 connection, NetworkingConfigValue config, float value);\n\tbool setConnectionConfigValueInt32(uint32 connection, NetworkingConfigValue config, int32 value);\n\tbool setConnectionConfigValueString(uint32 connection, NetworkingConfigValue config, const String &value);\n//\tbool setConfigValue(NetworkingConfigValue setting, NetworkingConfigScope scope_type, uint32_t connection_handle, NetworkingConfigDataType data_type, auto value);\n\tbool setGlobalConfigValueFloat(NetworkingConfigValue config, float value);\n\tbool setGlobalConfigValueInt32(NetworkingConfigValue config, int32 value);\n\tbool setGlobalConfigValueString(NetworkingConfigValue config, const String &value);\n\n\t// Parental Settings\n\tbool isAppBlocked(uint32 app_id);\n\tbool isAppInBlockList(uint32 app_id);\n\tbool isFeatureBlocked(ParentalFeature feature);\n\tbool isFeatureInBlockList(ParentalFeature feature);\n\tbool isParentalLockEnabled();\n\tbool isParentalLockLocked();\n\n\t// Parties\n\tvoid cancelReservation(uint64_t beacon_id, uint64_t steam_id);\n\tvoid changeNumOpenSlots(uint64_t beacon_id, uint32 open_slots);\n\tvoid createBeacon(uint32 open_slots, uint64_t location_id, PartyBeaconLocationType type, const String &connect_string, const String &beacon_metadata);\n\tbool destroyBeacon(uint64_t beacon_id);\n\tArray getAvailableBeaconLocations(uint32 max);\n\tuint64_t getBeaconByIndex(uint32 index);\n\tDictionary getBeaconDetails(uint64_t beacon_id);\n\tString getBeaconLocationData(uint64_t location_id, PartyBeaconLocationType location_type, PartyBeaconLocationData location_data);\n\tuint32 getNumActiveBeacons();\n\tvoid joinParty(uint64_t beacon_id);\n\tvoid onReservationCompleted(uint64_t beacon_id, uint64_t steam_id);\n\n\t// Remote Play\n\tuint32 getSessionCount();\n\tuint32 getSessionID(uint32 index);\n\tuint64_t getSessionSteamID(uint32 session_id);\n\tString getSessionClientName(uint32 session_id);\n\tint getSessionClientFormFactor(uint32 session_id);\n\tDictionary getSessionClientResolution(uint32 session_id);\n\tbool sendRemotePlayTogetherInvite(uint64_t friend_id);\n\tbool startRemotePlayTogether(bool show_overlay = true);\n\n\t// Remote Storage\n\tbool beginFileWriteBatch();\n\tbool endFileWriteBatch();\n\tbool fileDelete(const String &file);\n\tbool fileExists(const String &file);\n\tbool fileForget(const String &file);\n\tbool filePersisted(const String &file);\n\tDictionary fileRead(const String &file, int32_t data_to_read);\n\tvoid fileReadAsync(const String &file, uint32 offset, uint32_t data_to_read);\n\tvoid fileShare(const String &file);\n\tbool fileWrite(const String &file, PackedByteArray data, int32 size = 0);\n\tvoid fileWriteAsync(const String &file, PackedByteArray data, int32 size = 0);\n\tbool fileWriteStreamCancel(uint64_t write_handle);\n\tbool fileWriteStreamClose(uint64_t write_handle);\n\tuint64_t fileWriteStreamOpen(const String &file);\n\tbool fileWriteStreamWriteChunk(uint64_t write_handle, PackedByteArray data);\n\tint32 getCachedUGCCount();\n\tuint64_t getCachedUGCHandle(int32 content);\n\tint32_t getFileCount();\n\tDictionary getFileNameAndSize(int file);\n\tint32_t getFileSize(const String &file);\n\tint64_t getFileTimestamp(const String &file);\n\tDictionary getLocalFileChange(int file);\n\tuint32_t getLocalFileChangeCount();\n\tDictionary getQuota();\n\tDictionary getSyncPlatforms(const String &file);\n\tDictionary getUGCDetails(uint64_t content);\n\tDictionary getUGCDownloadProgress(uint64_t content);\n\tbool isCloudEnabledForAccount();\n\tbool isCloudEnabledForApp();\n\tvoid setCloudEnabledForApp(bool enabled);\n\tbool setSyncPlatforms(const String &file, int platform);\n\tvoid ugcDownload(uint64_t content, uint32 priority);\n\tvoid ugcDownloadToLocation(uint64_t content, const String &location, uint32 priority);\n\tPackedByteArray ugcRead(uint64_t content, int32 data_size, uint32 offset, UGCReadAction action);\n\n\t// Screenshots\n\tuint32_t addScreenshotToLibrary(const String &filename, const String &thumbnail_filename, int width, int height);\n\tuint32_t addVRScreenshotToLibrary(VRScreenshotType type, const String &filename, const String &vr_filename);\n\tvoid hookScreenshots(bool hook);\n\tbool isScreenshotsHooked();\n\tbool setLocation(uint32_t screenshot, const String &location);\n\tbool tagPublishedFile(uint32_t screenshot, uint64_t file_id);\n\tbool tagUser(uint32_t screenshot, uint64_t steam_id);\n\tvoid triggerScreenshot();\n\tuint32_t writeScreenshot(const PackedByteArray &rgb, int width, int height);\n\n\t// Timeline\n\tvoid addGamePhaseTag(const String &tag_name, const String &tag_icon, const String &tag_group, uint32 priority );\n\tuint64_t addInstantaneousTimelineEvent(const String &title, const String &description, const String &icon, uint32 icon_priority, float start_offset_seconds, TimelineEventClipPriority possible_clip = TIMELINE_EVENT_CLIP_PRIORITY_NONE);\n\tuint64_t addRangeTimelineEvent(const String &title, const String &description, const String &icon, uint32 icon_priority, float start_offset_seconds, float duration, TimelineEventClipPriority possible_clip = TIMELINE_EVENT_CLIP_PRIORITY_NONE);\n\tvoid clearTimelineTooltip(float time_delta);\n\tvoid doesEventRecordingExist(uint64_t this_event);\n\tvoid doesGamePhaseRecordingExist(const String &phase_id);\n\tvoid endGamePhase();\n\tvoid endRangeTimelineEvent(uint64_t this_event, float end_offset_seconds);\n\tvoid openOverlayToGamePhase(const String &phase_id);\n\tvoid openOverlayToTimelineEvent(const uint64_t this_event);\n\tvoid removeTimelineEvent(uint64_t this_event );\n\tvoid setGamePhaseAttribute(const String &attribute_group, const String &attribute_value, uint32 priority);\n\tvoid setGamePhaseID(const String &phase_id);\n\tvoid setTimelineGameMode(TimelineGameMode mode);\n\tvoid setTimelineTooltip(String description, float time_delta);\n\tvoid startGamePhase();\n\tuint64_t startRangeTimelineEvent(const String &title, const String &description, const String &icon, uint32 priority, float start_offset_seconds, TimelineEventClipPriority possible_clip = TIMELINE_EVENT_CLIP_PRIORITY_NONE);\n\tvoid updateRangeTimelineEvent(uint64_t this_event, const String &title, const String &description, const String &icon, uint32 priority, TimelineEventClipPriority possible_clip = TIMELINE_EVENT_CLIP_PRIORITY_NONE);\n\n\t// UGC\n\tvoid addAppDependency(uint64_t published_file_id, uint32_t app_id);\n\tbool addContentDescriptor(uint64_t update_handle, int descriptor_id);\n\tvoid addDependency(uint64_t published_file_id, uint64_t child_published_file_id);\n\tbool addExcludedTag(uint64_t query_handle, const String &tag_name);\n\tbool addItemKeyValueTag(uint64_t query_handle, const String &key, const String &value);\n\tbool addItemPreviewFile(uint64_t query_handle, const String &preview_file, ItemPreviewType type);\n\tbool addItemPreviewVideo(uint64_t query_handle, const String &video_id);\n\tvoid addItemToFavorites(uint32_t app_id, uint64_t published_file_id);\n\tbool addRequiredKeyValueTag(uint64_t query_handle, const String &key, const String &value);\n\tbool addRequiredTag(uint64_t query_handle, const String &tag_name);\n\tbool addRequiredTagGroup(uint64_t query_handle, Array tag_array);\n\tbool initWorkshopForGameServer(uint32_t workshop_depot_id, String folder);\n\tvoid createItem(uint32 app_id, WorkshopFileType file_type);\n\tuint64_t createQueryAllUGCRequest(UGCQuery query_type, UGCMatchingUGCType matching_type, uint32_t creator_id, uint32_t consumer_id, uint32 page);\n\tuint64_t createQueryUGCDetailsRequest(Array published_file_id);\n\tuint64_t createQueryUserUGCRequest(uint64_t steam_id, UserUGCList list_type, UGCMatchingUGCType matching_ugc_type, UserUGCListSortOrder sort_order, uint32_t creator_id, uint32_t consumer_id, uint32 page);\n\tvoid deleteItem(uint64_t published_file_id);\n\tbool downloadItem(uint64_t published_file_id, bool high_priority);\n\tDictionary getItemDownloadInfo(uint64_t published_file_id);\n\tDictionary getItemInstallInfo(uint64_t published_file_id);\n\tuint32 getItemState(uint64_t published_file_id);\n\tDictionary getItemUpdateProgress(uint64_t update_handle);\n\tuint32 getNumSubscribedItems();\n\tuint32 getNumSupportedGameVersions(uint64_t query_handle, uint32 index);\n\tDictionary getQueryUGCAdditionalPreview(uint64_t query_handle, uint32 index, uint32 preview_index);\n\tDictionary getQueryUGCChildren(uint64_t query_handle, uint32 index, uint32_t child_count);\n\tDictionary getQueryUGCContentDescriptors(uint64_t query_handle, uint32 index, uint32_t max_entries);\n\tDictionary getQueryUGCKeyValueTag(uint64_t query_handle, uint32 index, uint32 key_value_tag_index);\n\tString getQueryUGCMetadata(uint64_t query_handle, uint32 index);\n\tuint32 getQueryUGCNumAdditionalPreviews(uint64_t query_handle, uint32 index);\n\tuint32 getQueryUGCNumKeyValueTags(uint64_t query_handle, uint32 index);\n\tuint32 getQueryUGCNumTags(uint64_t query_handle, uint32 index);\n\tString getQueryUGCPreviewURL(uint64_t query_handle, uint32 index);\n\tDictionary getQueryUGCResult(uint64_t query_handle, uint32 index);\n\tDictionary getQueryUGCStatistic(uint64_t query_handle, uint32 index, ItemStatistic stat_type);\n\tString getQueryUGCTag(uint64_t query_handle, uint32 index, uint32 tag_index);\n\tString getQueryUGCTagDisplayName(uint64_t query_handle, uint32 index, uint32 tag_index);\n\tArray getSubscribedItems();\n\tDictionary getSupportedGameVersionData(uint64_t query_handle, uint32 index, uint32 version_index);\n\tArray getUserContentDescriptorPreferences(uint32 max_entries);\n\tvoid getUserItemVote(uint64_t published_file_id);\n\tbool releaseQueryUGCRequest(uint64_t query_handle);\n\tvoid removeAppDependency(uint64_t published_file_id, uint32_t app_id);\n\tbool removeContentDescriptor(uint64_t update_handle, int descriptor_id);\n\tvoid removeDependency(uint64_t published_file_id, uint64_t child_published_file_id);\n\tvoid removeItemFromFavorites(uint32_t app_id, uint64_t published_file_id);\n\tbool removeItemKeyValueTags(uint64_t update_handle, const String &key);\n\tbool removeItemPreview(uint64_t update_handle, uint32 index);\n\tvoid sendQueryUGCRequest(uint64_t update_handle);\n\tbool setAdminQuery(uint64_t update_handle, bool admin_query);\n\tbool setAllowCachedResponse(uint64_t update_handle, uint32 max_age_seconds);\n\tbool setCloudFileNameFilter(uint64_t update_handle, const String &match_cloud_filename);\n\tbool setItemContent(uint64_t update_handle, const String &content_folder);\n\tbool setItemDescription(uint64_t update_handle, const String &description);\n\tbool setItemMetadata(uint64_t update_handle, const String &ugc_metadata);\n\tbool setItemPreview(uint64_t update_handle, const String &preview_file);\n\tbool setItemTags(uint64_t update_handle, Array tag_array, bool allow_admin_tags = false);\n\tbool setItemTitle(uint64_t update_handle, const String &title);\n\tbool setItemUpdateLanguage(uint64_t update_handle, const String &language);\n\tbool setItemVisibility(uint64_t update_handle, RemoteStoragePublishedFileVisibility visibility);\n\tbool setLanguage(uint64_t query_handle, const String &language);\n\tbool setMatchAnyTag(uint64_t query_handle, bool match_any_tag);\n\tbool setRankedByTrendDays(uint64_t query_handle, uint32 days);\n\tbool setRequiredGameVersions(uint64_t query_handle, String game_branch_min, String game_branch_max);\n\tbool setReturnAdditionalPreviews(uint64_t query_handle, bool return_additional_previews);\n\tbool setReturnChildren(uint64_t query_handle, bool return_children);\n\tbool setReturnKeyValueTags(uint64_t query_handle, bool return_key_value_tags);\n\tbool setReturnLongDescription(uint64_t query_handle, bool return_long_description);\n\tbool setReturnMetadata(uint64_t query_handle, bool return_metadata);\n\tbool setReturnOnlyIDs(uint64_t query_handle, bool return_only_ids);\n\tbool setReturnPlaytimeStats(uint64_t query_handle, uint32 days);\n\tbool setReturnTotalOnly(uint64_t query_handle, bool return_total_only);\n\tbool setSearchText(uint64_t query_handle, const String &search_text);\n\tvoid setUserItemVote(uint64_t published_file_id, bool vote_up);\n\tuint64_t startItemUpdate(uint32_t app_id, uint64_t file_id);\n\tvoid startPlaytimeTracking(Array published_file_ids);\n\tvoid stopPlaytimeTracking(Array published_file_ids);\n\tvoid stopPlaytimeTrackingForAllItems();\n\tvoid getAppDependencies(uint64_t published_file_id);\n\tvoid submitItemUpdate(uint64_t update_handle, const String &change_note);\n\tvoid subscribeItem(uint64_t published_file_id);\n\tvoid suspendDownloads(bool suspend);\n\tvoid unsubscribeItem(uint64_t published_file_id);\n\tbool updateItemPreviewFile(uint64_t update_handle, uint32 index, const String &preview_file);\n\tbool updateItemPreviewVideo(uint64_t update_handle, uint32 index, const String &video_id);\n\tbool showWorkshopEULA();\n\tvoid getWorkshopEULAStatus();\n\tbool setTimeCreatedDateRange(uint64_t update_handle, uint32 start, uint32 end);\n\tbool setTimeUpdatedDateRange(uint64_t update_handle, uint32 start, uint32 end);\n\n\t// Users\n\tvoid advertiseGame(const String &server_ip, int port);\n\tBeginAuthSessionResult beginAuthSession(PackedByteArray ticket, int ticket_size, uint64_t steam_id);\n\tvoid cancelAuthTicket(uint32_t auth_ticket);\n\tDictionary decompressVoice(const PackedByteArray &voice, uint32 sample_rate, uint32 buffer_size_override = 20480);\n\tvoid endAuthSession(uint64_t steam_id);\n\tDictionary getAuthSessionTicket(uint64_t remote_steam_id = 0);\n\tuint32 getAuthTicketForWebApi(const String &service_identity = \"\");\n\tDictionary getAvailableVoice();\n//\tDictionary getDecompressedVoice(uint32 buffer_in_size_override = 0, uint32 buffer_out_size_override = 20480, uint32 sample_rate_override = 0);\n\tvoid getDurationControl();\n\tDictionary getEncryptedAppTicket();\n\tint getGameBadgeLevel(int series, bool foil);\n\tint getPlayerSteamLevel();\n\tuint64_t getSteamID();\n\tDictionary getVoice(uint32 buffer_size_override = 0);\n\tuint32 getVoiceOptimalSampleRate();\n\tDictionary initiateGameConnection(uint64_t server_id, String server_ip, uint16 server_port, bool secure);\n\tbool isBehindNAT();\n\tbool isPhoneIdentifying();\n\tbool isPhoneRequiringVerification();\n\tbool isPhoneVerified();\n\tbool isTwoFactorEnabled();\n\tbool loggedOn();\n\tvoid requestEncryptedAppTicket(const String &secret);\n\tvoid requestStoreAuthURL(const String &redirect);\n\tvoid startVoiceRecording();\n\tbool setDurationControlOnlineState(int new_state);\n\tvoid stopVoiceRecording();\n\tvoid terminateGameConnection(String server_ip, uint16 server_port);\n\tint userHasLicenseForApp(uint64_t steam_id, uint32_t app_id);\n\n\t// User Stats\n\tvoid attachLeaderboardUGC(uint64_t ugc_handle, uint64_t this_leaderboard = 0);\n\tbool clearAchievement(const String &achievement_name);\n\tvoid downloadLeaderboardEntries(int start, int end, LeaderboardDataRequest type = LeaderboardDataRequest(k_ELeaderboardDataRequestGlobal), uint64_t this_leaderboard = 0);\n\tvoid downloadLeaderboardEntriesForUsers(Array users_id, uint64_t this_leaderboard = 0);\n\tvoid findLeaderboard(const String &leaderboard_name);\n\tvoid findOrCreateLeaderboard(const String &leaderboard_name, LeaderboardSortMethod sort_method, LeaderboardDisplayType display_type);\n\tDictionary getAchievement(const String &achievement_name);\n\tDictionary getAchievementAchievedPercent(const String &achievement_name);\n\tDictionary getAchievementAndUnlockTime(const String &achievement_name);\n\tString getAchievementDisplayAttribute(const String &achievement_name, const String &key);\n\tint getAchievementIcon(const String &achievement_name);\n\tString getAchievementName(uint32_t achievement);\n\tDictionary getAchievementProgressLimitsInt(const String &achievement_name);\n\tDictionary getAchievementProgressLimitsFloat(const String &achievement_name);\n\tuint64_t getGlobalStatInt(const String &stat_name);\n\tdouble getGlobalStatFloat(const String &stat_name);\n\tPackedInt64Array getGlobalStatIntHistory(const String &stat_name);\n\tPackedFloat64Array getGlobalStatFloatHistory(const String &stat_name);\n\tDictionary getLeaderboardDisplayType(uint64_t this_leaderboard = 0);\n\tint getLeaderboardEntryCount(uint64_t this_leaderboard = 0);\n\tString getLeaderboardName(uint64_t this_leaderboard = 0);\n\tDictionary getLeaderboardSortMethod(uint64_t this_leaderboard = 0);\n\tDictionary getMostAchievedAchievementInfo();\n\tDictionary getNextMostAchievedAchievementInfo(int iterator);\n\tuint32_t getNumAchievements();\n\tvoid getNumberOfCurrentPlayers();\n\tfloat getStatFloat(const String &stat_name);\n\tint getStatInt(const String &stat_name);\n\tDictionary getUserAchievement(uint64_t steam_id, const String &name);\n\tDictionary getUserAchievementAndUnlockTime(uint64_t steam_id, const String &name);\n\tfloat getUserStatFloat(uint64_t steam_id, const String &name);\n\tint getUserStatInt(uint64_t steam_id, const String &name);\n\tbool indicateAchievementProgress(const String &name, int current_progress, int max_progress);\n\tvoid requestGlobalAchievementPercentages();\n\tvoid requestGlobalStats(int history_days);\n\tvoid requestUserStats(uint64_t steam_id);\n\tbool resetAllStats(bool achievements_too = true);\n\tbool setAchievement(const String &name);\n\tbool setStatFloat(const String &name, float value);\n\tbool setStatInt(const String &name, int value);\n\tbool storeStats();\n\tbool updateAvgRateStat(const String &name, float this_session, double session_length);\n\tvoid uploadLeaderboardScore(int score, bool keep_best = false, PackedInt32Array details = PackedInt32Array(), uint64_t this_leaderboard = 0);\n\n\t// Utils\n\tbool dismissFloatingGamepadTextInput();\n\tbool dismissGamepadTextInput();\n\tString filterText(TextFilteringContext context, uint64_t steam_id, const String &message);\n\tString getAPICallFailureReason();\n\tuint32_t getAppID();\n\tint getCurrentBatteryPower();\n\tDictionary getImageRGBA(int image);\n\tDictionary getImageSize(int image);\n\tuint32 getIPCCallCount();\n\tString getIPCountry();\n\tint getSecondsSinceAppActive();\n\tint getSecondsSinceComputerActive();\n\tint getServerRealTime();\n\tString getSteamUILanguage();\n\tbool initFilterText();\n\tDictionary isAPICallCompleted();\n\tbool isOverlayEnabled();\n\tbool isSteamChinaLauncher();\n\tbool isSteamInBigPictureMode();\n\tbool isSteamRunningInVR();\n\tbool isSteamRunningOnSteamDeck();\n\tbool isVRHeadsetStreamingEnabled();\n\tbool overlayNeedsPresent();\n\tvoid setGameLauncherMode(bool mode);\n\tvoid setOverlayNotificationInset(int horizontal, int vertical);\n\tvoid setOverlayNotificationPosition(int pos);\n\tvoid setVRHeadsetStreamingEnabled(bool enabled);\n\tbool showFloatingGamepadTextInput(FloatingGamepadTextInputMode input_mode, int text_field_x_position, int text_field_y_position, int text_field_width, int text_field_height);\n\tbool showGamepadTextInput(GamepadTextInputMode input_mode, GamepadTextInputLineMode line_input_mode, const String &description, uint32 max_text, const String &preset_text);\n\tvoid startVRDashboard();\n\n\t// Video\n\tvoid getOPFSettings(uint32_t app_id);\n\tString getOPFStringForApp(uint32_t app_id);\n\tvoid getVideoURL(uint32_t app_id);\n\tDictionary isBroadcasting();\n\n\n\t// PROPERTIES\n\t// Friends\n\tuint64_t current_clan_id = 0;\n\n\t// HTML Surface\n\tuint32 browser_handle = 0;\n\n\t// Inventory\n\tSteamInventoryResult_t inventory_handle = 0;\n\tSteamInventoryUpdateHandle_t inventory_update_handle = 0;\n\n\t// User\n\tuint64_t current_steam_id = 0;\n\n\t// User Stats\n\tint leaderboard_details_max = LEADERBOARD_DETAIL_MAX;\n\tArray leaderboard_entries_array;\n\tSteamLeaderboard_t leaderboard_handle = 0;\n\n\t// Utils\n\tuint32_t current_app_id = 0;\n\n\nprotected:\n\tstatic void _bind_methods();\n\tstatic Steam *singleton;\n\n\nprivate:\n\t// Main\n\tString godotsteam_version = \"4.12\";\n\tbool is_init_success;\n\tbool were_callbacks_embedded;\n\n\tconst SteamNetworkingConfigValue_t *convert_config_options(Dictionary config_options);\n\tCSteamID createSteamID(uint64_t steam_id, AccountType account_type = AccountType(-1));\n\tSteamNetworkingIdentity getIdentityFromSteamID(uint64_t steam_id);\n\tuint32 getIPFromSteamIP(SteamNetworkingIPAddr this_address);\n\tuint32 getIPFromString(String ip_string);\n\tuint64_t getSteamIDFromIdentity(SteamNetworkingIdentity this_identity);\n\tSteamNetworkingIPAddr getSteamIPFromInt(uint32 ip_integer);\n\tSteamNetworkingIPAddr getSteamIPFromString(String ip_string);\n\tString getStringFromIP(uint32 ip_address);\n\tString getStringFromSteamIP(SteamNetworkingIPAddr this_address);\n\n\t// Matchmaking Servers\n\tHServerListRequest server_list_request;\n\tISteamMatchmakingServerListResponse *server_list_response = this;\n\tISteamMatchmakingPingResponse *ping_response = this;\n\tISteamMatchmakingPlayersResponse *players_response = this;\n\tISteamMatchmakingRulesResponse *rules_response = this;\n\n\tDictionary gameServerItemToDictionary(gameserveritem_t *server_item);\n\n\t// Networking Sockets\n\tuint64_t networking_microseconds = 0;\n//\tSteamDatagramHostedAddress hosted_address;\n//\tPackedByteArray routing_blob;\n//\tSteamDatagramRelayAuthTicket relay_auth_ticket;\n\n\t// Utils\n\tuint64_t api_handle = 0;\n\n\t// Run the Steamworks API callbacks /////\n\tvoid run_callbacks() {\n\t\tSteamAPI_RunCallbacks();\n\t}\n\n\n\t// STEAM CALLBACKS\n\t// Apps\n\tSTEAM_CALLBACK(Steam, dlc_installed, DlcInstalled_t, callbackDLCInstalled);\n\tSTEAM_CALLBACK(Steam, file_details_result, FileDetailsResult_t, callbackFileDetailsResult);\n\tSTEAM_CALLBACK(Steam, new_launch_url_parameters, NewUrlLaunchParameters_t, callbackNewLaunchURLParameters);\n\tSTEAM_CALLBACK(Steam, timed_trial_status, TimedTrialStatus_t, callbackTimedTrialStatus);\n\n\t// Friends\n\tSTEAM_CALLBACK(Steam, avatar_loaded, AvatarImageLoaded_t, callbackAvatarLoaded);\n\tSTEAM_CALLBACK(Steam, avatar_image_loaded, AvatarImageLoaded_t, callbackAvatarImageLoaded);\n\tSTEAM_CALLBACK(Steam, clan_activity_downloaded, DownloadClanActivityCountsResult_t, callbackClanActivityDownloaded);\n\tSTEAM_CALLBACK(Steam, friend_rich_presence_update, FriendRichPresenceUpdate_t, callbackFriendRichPresenceUpdate);\n\tSTEAM_CALLBACK(Steam, connected_chat_join, GameConnectedChatJoin_t, callbackConnectedChatJoin);\n\tSTEAM_CALLBACK(Steam, connected_chat_leave, GameConnectedChatLeave_t, callbackConnectedChatLeave);\n\tSTEAM_CALLBACK(Steam, connected_clan_chat_message, GameConnectedClanChatMsg_t, callbackConnectedClanChatMessage);\n\tSTEAM_CALLBACK(Steam, connected_friend_chat_message, GameConnectedFriendChatMsg_t, callbackConnectedFriendChatMessage);\n\tSTEAM_CALLBACK(Steam, join_requested, GameLobbyJoinRequested_t, callbackJoinRequested);\n\tSTEAM_CALLBACK(Steam, overlay_toggled, GameOverlayActivated_t, callbackOverlayToggled);\n\tSTEAM_CALLBACK(Steam, join_game_requested, GameRichPresenceJoinRequested_t, callbackJoinGameRequested);\n\tSTEAM_CALLBACK(Steam, change_server_requested, GameServerChangeRequested_t, callbackChangeServerRequested);\n\tSTEAM_CALLBACK(Steam, join_clan_chat_complete, JoinClanChatRoomCompletionResult_t, callbackJoinClanChatComplete);\n\tSTEAM_CALLBACK(Steam, persona_state_change, PersonaStateChange_t, callbackPersonaStateChange);\n\tSTEAM_CALLBACK(Steam, name_changed, SetPersonaNameResponse_t, callbackNameChanged);\n\tSTEAM_CALLBACK(Steam, overlay_browser_protocol, OverlayBrowserProtocolNavigation_t, callbackOverlayBrowserProtocol);\n\tSTEAM_CALLBACK(Steam, unread_chat_messages_changed, UnreadChatMessagesChanged_t, callbackUnreadChatMessagesChanged);\n\tSTEAM_CALLBACK(Steam, equipped_profile_items_changed, EquippedProfileItemsChanged_t, callbackEquippedProfileItemsChanged);\n\n\t// Game Search\n\tSTEAM_CALLBACK(Steam, search_for_game_progress, SearchForGameProgressCallback_t, callbackSearchForGameProgress);\n\tSTEAM_CALLBACK(Steam, search_for_game_result, SearchForGameResultCallback_t, callbackSearchForGameResult);\n\tSTEAM_CALLBACK(Steam, request_players_for_game_progress, RequestPlayersForGameProgressCallback_t, callbackRequestPlayersForGameProgress);\n\tSTEAM_CALLBACK(Steam, request_players_for_game_result, RequestPlayersForGameResultCallback_t, callbackRequestPlayersForGameResult);\n\tSTEAM_CALLBACK(Steam, request_players_for_game_final_result, RequestPlayersForGameFinalResultCallback_t, callbackRequestPlayersForGameFinalResult);\n\tSTEAM_CALLBACK(Steam, submit_player_result, SubmitPlayerResultResultCallback_t, callbackSubmitPlayerResult);\n\tSTEAM_CALLBACK(Steam, end_game_result, EndGameResultCallback_t, callbackEndGameResult);\n\n\t// HTML Surface\n\tSTEAM_CALLBACK(Steam, html_can_go_backandforward, HTML_CanGoBackAndForward_t, callbackHTMLCanGoBackandforward);\n\tSTEAM_CALLBACK(Steam, html_changed_title, HTML_ChangedTitle_t, callbackHTMLChangedTitle);\n\tSTEAM_CALLBACK(Steam, html_close_browser, HTML_CloseBrowser_t, callbackHTMLCloseBrowser);\n\tSTEAM_CALLBACK(Steam, html_file_open_dialog, HTML_FileOpenDialog_t, callbackHTMLFileOpenDialog);\n\tSTEAM_CALLBACK(Steam, html_finished_request, HTML_FinishedRequest_t, callbackHTMLFinishedRequest);\n\tSTEAM_CALLBACK(Steam, html_hide_tooltip, HTML_HideToolTip_t, callbackHTMLHideTooltip);\n\tSTEAM_CALLBACK(Steam, html_horizontal_scroll, HTML_HorizontalScroll_t, callbackHTMLHorizontalScroll);\n\tSTEAM_CALLBACK(Steam, html_js_alert, HTML_JSAlert_t, callbackHTMLJSAlert);\n\tSTEAM_CALLBACK(Steam, html_js_confirm, HTML_JSConfirm_t, callbackHTMLJSConfirm);\n\tSTEAM_CALLBACK(Steam, html_link_at_position, HTML_LinkAtPosition_t, callbackHTMLLinkAtPosition);\n\tSTEAM_CALLBACK(Steam, html_needs_paint, HTML_NeedsPaint_t, callbackHTMLNeedsPaint);\n\tSTEAM_CALLBACK(Steam, html_new_window, HTML_NewWindow_t, callbackHTMLNewWindow);\n\tSTEAM_CALLBACK(Steam, html_open_link_in_new_tab, HTML_OpenLinkInNewTab_t, callbackHTMLOpenLinkInNewTab);\n\tSTEAM_CALLBACK(Steam, html_search_results, HTML_SearchResults_t, callbackHTMLSearchResults);\n\tSTEAM_CALLBACK(Steam, html_set_cursor, HTML_SetCursor_t, callbackHTMLSetCursor);\n\tSTEAM_CALLBACK(Steam, html_show_tooltip, HTML_ShowToolTip_t, callbackHTMLShowTooltip);\n\tSTEAM_CALLBACK(Steam, html_start_request, HTML_StartRequest_t, callbackHTMLStartRequest);\n\tSTEAM_CALLBACK(Steam, html_status_text, HTML_StatusText_t, callbackHTMLStatusText);\n\tSTEAM_CALLBACK(Steam, html_update_tooltip, HTML_UpdateToolTip_t, callbackHTMLUpdateTooltip);\n\tSTEAM_CALLBACK(Steam, html_url_changed, HTML_URLChanged_t, callbackHTMLURLChanged);\n\tSTEAM_CALLBACK(Steam, html_vertical_scroll, HTML_VerticalScroll_t, callbackHTMLVerticalScroll);\n\n\t// HTTP\n\tSTEAM_CALLBACK(Steam, http_request_completed, HTTPRequestCompleted_t, callbackHTTPRequestCompleted);\n\tSTEAM_CALLBACK(Steam, http_request_data_received, HTTPRequestDataReceived_t, callbackHTTPRequestDataReceived);\n\tSTEAM_CALLBACK(Steam, http_request_headers_received, HTTPRequestHeadersReceived_t, callbackHTTPRequestHeadersReceived);\n\n\t// Input\n\tSTEAM_CALLBACK(Steam, input_device_connected, SteamInputDeviceConnected_t, callbackInputDeviceConnected);\n\tSTEAM_CALLBACK(Steam, input_device_disconnected, SteamInputDeviceDisconnected_t, callbackInputDeviceDisconnected);\n\tSTEAM_CALLBACK(Steam, input_configuration_loaded, SteamInputConfigurationLoaded_t, callbackInputConfigurationLoaded);\n\tSTEAM_CALLBACK(Steam, input_gamepad_slot_change, SteamInputGamepadSlotChange_t, callbackInputGamePadSlotChange);\n\n\t// Inventory\n\tSTEAM_CALLBACK(Steam, inventory_definition_update, SteamInventoryDefinitionUpdate_t, callbackInventoryDefinitionUpdate);\n\tSTEAM_CALLBACK(Steam, inventory_full_update, SteamInventoryFullUpdate_t, callbackInventoryFullUpdate);\n\tSTEAM_CALLBACK(Steam, inventory_result_ready, SteamInventoryResultReady_t, callbackInventoryResultReady);\n\n\t// Matchmaking\n\tSTEAM_CALLBACK(Steam, favorites_list_accounts_updated, FavoritesListAccountsUpdated_t, callbackFavoritesListAccountsUpdated);\n\tSTEAM_CALLBACK(Steam, favorites_list_changed, FavoritesListChanged_t, callbackFavoritesListChanged);\n\tSTEAM_CALLBACK(Steam, lobby_message, LobbyChatMsg_t, callbackLobbyMessage);\n\tSTEAM_CALLBACK(Steam, lobby_chat_update, LobbyChatUpdate_t, callbackLobbyChatUpdate);\n\tSTEAM_CALLBACK(Steam, lobby_data_update, LobbyDataUpdate_t, callbackLobbyDataUpdate);\n\tSTEAM_CALLBACK(Steam, lobby_joined, LobbyEnter_t, callbackLobbyJoined);\n\tSTEAM_CALLBACK(Steam, lobby_game_created, LobbyGameCreated_t, callbackLobbyGameCreated);\n\tSTEAM_CALLBACK(Steam, lobby_invite, LobbyInvite_t, callbackLobbyInvite);\n\tSTEAM_CALLBACK(Steam, lobby_kicked, LobbyKicked_t, callbackLobbyKicked);\n\n\t// Matchmaking Server\n\t// ISteamMatchmakingServerListResponse\n\tvoid ServerResponded(HServerListRequest list_request_handle, int server);\n\tvoid ServerFailedToRespond(HServerListRequest list_request_handle, int server);\n\tvoid RefreshComplete (HServerListRequest list_request_handle, EMatchMakingServerResponse response);\n\t// ISteamMatchmakingPingResponse\n\tvoid ServerResponded(gameserveritem_t &server);\n\tvoid ServerFailedToRespond();\n\t// ISteamMatchmakingPlayersResponse\n\tvoid AddPlayerToList(const char *player_name, int score, float time_played);\n\tvoid PlayersFailedToRespond();\n\tvoid PlayersRefreshComplete();\n\t// ISteamMatchmakingRulesResponse\n\tvoid RulesResponded(const char *rule, const char *value);\n\tvoid RulesFailedToRespond();\n\tvoid RulesRefreshComplete();\n\n\t// Music\n\tSTEAM_CALLBACK(Steam, music_playback_status_has_changed, PlaybackStatusHasChanged_t, callbackMusicPlaybackStatusHasChanged);\n\tSTEAM_CALLBACK(Steam, music_volume_has_changed, VolumeHasChanged_t, callbackMusicVolumeHasChanged);\n\n\t// Music Remote\n\tSTEAM_CALLBACK(Steam, music_player_remote_to_front, MusicPlayerRemoteToFront_t, callbackMusicPlayerRemoteToFront);\n\tSTEAM_CALLBACK(Steam, music_player_remote_will_activate, MusicPlayerRemoteWillActivate_t, callbackMusicPlayerRemoteWillActivate);\n\tSTEAM_CALLBACK(Steam, music_player_remote_will_deactivate, MusicPlayerRemoteWillDeactivate_t, callbackMusicPlayerRemoteWillDeactivate);\n\tSTEAM_CALLBACK(Steam, music_player_selects_playlist_entry, MusicPlayerSelectsPlaylistEntry_t, callbackMusicPlayerSelectsPlaylistEntry);\n\tSTEAM_CALLBACK(Steam, music_player_selects_queue_entry, MusicPlayerSelectsQueueEntry_t, callbackMusicPlayerSelectsQueueEntry);\n\tSTEAM_CALLBACK(Steam, music_player_wants_looped, MusicPlayerWantsLooped_t, callbackMusicPlayerWantsLooped);\n\tSTEAM_CALLBACK(Steam, music_player_wants_pause, MusicPlayerWantsPause_t, callbackMusicPlayerWantsPause);\n\tSTEAM_CALLBACK(Steam, music_player_wants_playing_repeat_status, MusicPlayerWantsPlayingRepeatStatus_t, callbackMusicPlayerWantsPlayingRepeatStatus);\n\tSTEAM_CALLBACK(Steam, music_player_wants_play_next, MusicPlayerWantsPlayNext_t, callbackMusicPlayerWantsPlayNext);\n\tSTEAM_CALLBACK(Steam, music_player_wants_play_previous, MusicPlayerWantsPlayPrevious_t, callbackMusicPlayerWantsPlayPrevious);\n\tSTEAM_CALLBACK(Steam, music_player_wants_play, MusicPlayerWantsPlay_t, callbackMusicPlayerWantsPlay);\n\tSTEAM_CALLBACK(Steam, music_player_wants_shuffled, MusicPlayerWantsShuffled_t, callbackMusicPlayerWantsShuffled);\n\tSTEAM_CALLBACK(Steam, music_player_wants_volume, MusicPlayerWantsVolume_t, callbackMusicPlayerWantsVolume);\n\tSTEAM_CALLBACK(Steam, music_player_will_quit, MusicPlayerWillQuit_t, callbackMusicPlayerWillQuit);\n\n\t// Networking\n\tSTEAM_CALLBACK(Steam, p2p_session_connect_fail, P2PSessionConnectFail_t, callbackP2PSessionConnectFail);\n\tSTEAM_CALLBACK(Steam, p2p_session_request, P2PSessionRequest_t, callbackP2PSessionRequest);\n\n\t// Networking Messages\n\tSTEAM_CALLBACK(Steam, network_messages_session_request, SteamNetworkingMessagesSessionRequest_t, callbackNetworkMessagesSessionRequest);\n\tSTEAM_CALLBACK(Steam, network_messages_session_failed, SteamNetworkingMessagesSessionFailed_t, callbackNetworkMessagesSessionFailed);\n\n\t// Networking Sockets\n\tSTEAM_CALLBACK(Steam, network_connection_status_changed, SteamNetConnectionStatusChangedCallback_t, callbackNetworkConnectionStatusChanged);\n\tSTEAM_CALLBACK(Steam, network_authentication_status, SteamNetAuthenticationStatus_t, callbackNetworkAuthenticationStatus);\n\tSTEAM_CALLBACK(Steam, fake_ip_result, SteamNetworkingFakeIPResult_t, callbackNetworkingFakeIPResult);\n\n\t// Networking Utils\n\tSTEAM_CALLBACK(Steam, relay_network_status, SteamRelayNetworkStatus_t, callbackRelayNetworkStatus);\n\n\t// Parental Settings\n\tSTEAM_CALLBACK(Steam, parental_setting_changed, SteamParentalSettingsChanged_t, callbackParentlSettingChanged);\n\n\t// Parties\n\tSTEAM_CALLBACK(Steam, reservation_notification, ReservationNotificationCallback_t, callbackReserveNotification);\n\tSTEAM_CALLBACK(Steam, available_beacon_locations_updated, AvailableBeaconLocationsUpdated_t, callbackAvailableBeaconLocationsUpdated);\n\tSTEAM_CALLBACK(Steam, active_beacons_updated, ActiveBeaconsUpdated_t, callbackActiveBeaconsUpdated);\n\n\t// Remote Play\n\tSTEAM_CALLBACK(Steam, remote_play_session_connected, SteamRemotePlaySessionConnected_t, callbackRemotePlaySessionConnected);\n\tSTEAM_CALLBACK(Steam, remote_play_session_disconnected, SteamRemotePlaySessionDisconnected_t, callbackRemotePlaySessionDisconnected);\n\n\t// Remote Storage\n\tSTEAM_CALLBACK(Steam, local_file_changed, RemoteStorageLocalFileChange_t, callbackLocalFileChanged);\n\n\t// Screenshot\n\tSTEAM_CALLBACK(Steam, screenshot_ready, ScreenshotReady_t, callbackScreenshotReady);\n\tSTEAM_CALLBACK(Steam, screenshot_requested, ScreenshotRequested_t, callbackScreenshotRequested);\n\n\t// UGC\n\tSTEAM_CALLBACK(Steam, item_downloaded, DownloadItemResult_t, callbackItemDownloaded);\n\tSTEAM_CALLBACK(Steam, item_installed, ItemInstalled_t, callbackItemInstalled);\n\tSTEAM_CALLBACK(Steam, user_subscribed_items_list_changed, UserSubscribedItemsListChanged_t, callbackUserSubscribedItemsListChanged);\n\n\t// User\n\tSTEAM_CALLBACK(Steam, client_game_server_deny, ClientGameServerDeny_t, callbackClientGameServerDeny);\n\tSTEAM_CALLBACK(Steam, game_web_callback, GameWebCallback_t, callbackGameWebCallback);\n\tSTEAM_CALLBACK(Steam, get_auth_session_ticket_response, GetAuthSessionTicketResponse_t, callbackGetAuthSessionTicketResponse);\n\tSTEAM_CALLBACK(Steam, get_ticket_for_web_api, GetTicketForWebApiResponse_t, callbackGetTicketForWebApiResponse);\n\tSTEAM_CALLBACK(Steam, ipc_failure, IPCFailure_t, callbackIPCFailure);\n\tSTEAM_CALLBACK(Steam, licenses_updated, LicensesUpdated_t, callbackLicensesUpdated);\n\tSTEAM_CALLBACK(Steam, microtransaction_auth_response, MicroTxnAuthorizationResponse_t, callbackMicrotransactionAuthResponse);\n\tSTEAM_CALLBACK(Steam, steam_server_connected, SteamServersConnected_t, callbackSteamServerConnected);\n\tSTEAM_CALLBACK(Steam, steam_server_disconnected, SteamServersDisconnected_t, callbackSteamServerDisconnected);\n\tSTEAM_CALLBACK(Steam, validate_auth_ticket_response, ValidateAuthTicketResponse_t, callbackValidateAuthTicketResponse);\n\n\t// User Stats\n\tSTEAM_CALLBACK(Steam, user_achievement_icon_fetched, UserAchievementIconFetched_t, callbackUserAchievementIconFetched);\n\tSTEAM_CALLBACK(Steam, user_achievement_stored, UserAchievementStored_t, callbackUserAchievementStored);\n\tSTEAM_CALLBACK(Steam, user_stats_stored, UserStatsStored_t, callbackUserStatsStored);\n\tSTEAM_CALLBACK(Steam, user_stats_unloaded, UserStatsUnloaded_t, callbackUserStatsUnloaded);\n\n\t// Utility\n\tSTEAM_CALLBACK(Steam, gamepad_text_input_dismissed, GamepadTextInputDismissed_t, callbackGamepadTextInputDismissed);\n\tSTEAM_CALLBACK(Steam, ip_country, IPCountry_t, callbackIPCountry);\n\tSTEAM_CALLBACK(Steam, low_power, LowBatteryPower_t, callbackLowPower);\n\tSTEAM_CALLBACK(Steam, steam_api_call_completed, SteamAPICallCompleted_t, callbackSteamAPICallCompleted);\n\tSTEAM_CALLBACK(Steam, steam_shutdown, SteamShutdown_t, callbackSteamShutdown);\n\tSTEAM_CALLBACK(Steam, app_resuming_from_suspend, AppResumingFromSuspend_t, callbackAppResumingFromSuspend);\n\tSTEAM_CALLBACK(Steam, floating_gamepad_text_input_dismissed, FloatingGamepadTextInputDismissed_t, callbackFloatingGamepadTextInputDismissed);\n\tSTEAM_CALLBACK(Steam, filter_text_dictionary_changed, FilterTextDictionaryChanged_t, callbackFilterTextDictionaryChanged);\n\n\t// Video\n\tSTEAM_CALLBACK(Steam, get_opf_settings_result, GetOPFSettingsResult_t, callbackGetOPFSettingsResult);\n\tSTEAM_CALLBACK(Steam, get_video_result, GetVideoURLResult_t, callbackGetVideoResult);\n\n\n\t// STEAM CALL RESULTS\n\t// Friends\n\tCCallResult<Steam, ClanOfficerListResponse_t> callResultClanOfficerList;\n\tvoid request_clan_officer_list(ClanOfficerListResponse_t *call_data, bool io_failure);\n\tCCallResult<Steam, FriendsEnumerateFollowingList_t> callResultEnumerateFollowingList;\n\tvoid enumerate_following_list(FriendsEnumerateFollowingList_t *call_data, bool io_failure);\n\tCCallResult<Steam, EquippedProfileItems_t> callResultEquippedProfileItems;\n\tvoid equipped_profile_items(EquippedProfileItems_t *call_data, bool io_failure);\n\tCCallResult<Steam, FriendsGetFollowerCount_t> callResultFollowerCount;\n\tvoid get_follower_count(FriendsGetFollowerCount_t *call_data, bool io_failure);\n\tCCallResult<Steam, FriendsIsFollowing_t> callResultIsFollowing;\n\tvoid is_following(FriendsIsFollowing_t *call_data, bool io_failure);\n\n\t// HTML Surface\n\tCCallResult<Steam, HTML_BrowserReady_t> callResultHTMLBrowserReady;\n\tvoid html_browser_ready(HTML_BrowserReady_t *call_data, bool io_failure);\n\n\t// Inventory\n\tCCallResult<Steam, SteamInventoryEligiblePromoItemDefIDs_t> callResultEligiblePromoItemDefIDs;\n\tvoid inventory_eligible_promo_item(SteamInventoryEligiblePromoItemDefIDs_t *call_data, bool io_failure);\n\tCCallResult<Steam, SteamInventoryRequestPricesResult_t> callResultRequestPrices;\n\tvoid inventory_request_prices_result(SteamInventoryRequestPricesResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, SteamInventoryStartPurchaseResult_t> callResultStartPurchase;\n\tvoid inventory_start_purchase_result(SteamInventoryStartPurchaseResult_t *call_data, bool io_failure);\n\n\t// Matchmaking\n\tCCallResult<Steam, LobbyCreated_t> callResultCreateLobby;\n\tvoid lobby_created(LobbyCreated_t *call_data, bool io_failure);\n\tCCallResult<Steam, LobbyMatchList_t> callResultLobbyList;\n\tvoid lobby_match_list(LobbyMatchList_t *call_data, bool io_failure);\n\n\t// Parties\n\tCCallResult<Steam, JoinPartyCallback_t> callResultJoinParty;\n\tvoid join_party(JoinPartyCallback_t *call_data, bool io_failure);\n\tCCallResult<Steam, CreateBeaconCallback_t> callResultCreateBeacon;\n\tvoid create_beacon(CreateBeaconCallback_t *call_data, bool io_failure);\n\tCCallResult<Steam, ChangeNumOpenSlotsCallback_t> callResultChangeNumOpenSlots;\n\tvoid change_num_open_slots(ChangeNumOpenSlotsCallback_t *call_data, bool io_failure);\n\n\t// Remote Storage\n\tCCallResult<Steam, RemoteStorageFileReadAsyncComplete_t> callResultFileReadAsyncComplete;\n\tvoid file_read_async_complete(RemoteStorageFileReadAsyncComplete_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoteStorageFileShareResult_t> callResultFileShareResult;\n\tvoid file_share_result(RemoteStorageFileShareResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoteStorageFileWriteAsyncComplete_t> callResultFileWriteAsyncComplete;\n\tvoid file_write_async_complete(RemoteStorageFileWriteAsyncComplete_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoteStorageDownloadUGCResult_t> callResultDownloadUGCResult;\n\tvoid download_ugc_result(RemoteStorageDownloadUGCResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoteStorageUnsubscribePublishedFileResult_t> callResultUnsubscribeItem;\n\tvoid unsubscribe_item(RemoteStorageUnsubscribePublishedFileResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoteStorageSubscribePublishedFileResult_t> callResultSubscribeItem;\n\tvoid subscribe_item(RemoteStorageSubscribePublishedFileResult_t *call_data, bool io_failure);\n\n\t// Timeline\n\tCCallResult<Steam, SteamTimelineEventRecordingExists_t> callResultTimelineEvenRecordingExists;\n\tvoid timeline_event_recording_exists(SteamTimelineEventRecordingExists_t *call_data, bool io_failure);\n\tCCallResult<Steam, SteamTimelineGamePhaseRecordingExists_t> callResultTimelineGamePhaseRecordingExists;\n\tvoid timeline_game_phase_recording_exists(SteamTimelineGamePhaseRecordingExists_t *call_data, bool io_failure);\n\n\t// UGC\n\tCCallResult<Steam, AddAppDependencyResult_t> callResultAddAppDependency;\n\tvoid add_app_dependency_result(AddAppDependencyResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, AddUGCDependencyResult_t> callResultAddUGCDependency;\n\tvoid add_ugc_dependency_result(AddUGCDependencyResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, CreateItemResult_t> callResultItemCreate;\n\tvoid item_created(CreateItemResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, GetAppDependenciesResult_t> callResultGetAppDependencies;\n\tvoid get_app_dependencies_result(GetAppDependenciesResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, DeleteItemResult_t> callResultDeleteItem;\n\tvoid item_deleted(DeleteItemResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, GetUserItemVoteResult_t> callResultGetUserItemVote;\n\tvoid get_item_vote_result(GetUserItemVoteResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoveAppDependencyResult_t> callResultRemoveAppDependency;\n\tvoid remove_app_dependency_result(RemoveAppDependencyResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, RemoveUGCDependencyResult_t> callResultRemoveUGCDependency;\n\tvoid remove_ugc_dependency_result(RemoveUGCDependencyResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, SetUserItemVoteResult_t> callResultSetUserItemVote;\n\tvoid set_user_item_vote(SetUserItemVoteResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, StartPlaytimeTrackingResult_t> callResultStartPlaytimeTracking;\n\tvoid start_playtime_tracking(StartPlaytimeTrackingResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, SteamUGCQueryCompleted_t> callResultUGCQueryCompleted;\n\tvoid ugc_query_completed(SteamUGCQueryCompleted_t *call_data, bool io_failure);\n\tCCallResult<Steam, StopPlaytimeTrackingResult_t> callResultStopPlaytimeTracking;\n\tvoid stop_playtime_tracking(StopPlaytimeTrackingResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, SubmitItemUpdateResult_t> callResultItemUpdate;\n\tvoid item_updated(SubmitItemUpdateResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, UserFavoriteItemsListChanged_t> callResultFavoriteItemListChanged;\n\tvoid user_favorite_items_list_changed(UserFavoriteItemsListChanged_t *call_data, bool io_failure);\n\tCCallResult<Steam, WorkshopEULAStatus_t> callResultWorkshopEULAStatus;\n\tvoid workshop_eula_status(WorkshopEULAStatus_t *call_data, bool io_failure);\n\n\t// User\n\tCCallResult<Steam, DurationControl_t> callResultDurationControl;\n\tvoid duration_control(DurationControl_t *call_data, bool io_failure);\n\tCCallResult<Steam, EncryptedAppTicketResponse_t> callResultEncryptedAppTicketResponse;\n\tvoid encrypted_app_ticket_response(EncryptedAppTicketResponse_t *call_data, bool io_failure);\n\tCCallResult<Steam, SteamServerConnectFailure_t> callResultSteamServerConnectFailure;\n\tvoid steam_server_connect_failed(SteamServerConnectFailure_t *call_data, bool io_failure);\n\tCCallResult<Steam, StoreAuthURLResponse_t> callResultStoreAuthURLResponse;\n\tvoid store_auth_url_response(StoreAuthURLResponse_t *call_data, bool io_failure);\n\n\t// User Stats\n\tCCallResult<Steam, GlobalAchievementPercentagesReady_t> callResultGlobalAchievementPercentagesReady;\n\tvoid global_achievement_percentages_ready(GlobalAchievementPercentagesReady_t *call_data, bool io_failure);\n\tCCallResult<Steam, GlobalStatsReceived_t> callResultGlobalStatsReceived;\n\tvoid global_stats_received(GlobalStatsReceived_t *call_data, bool io_failure);\n\tCCallResult<Steam, LeaderboardFindResult_t> callResultFindLeaderboard;\n\tvoid leaderboard_find_result(LeaderboardFindResult_t *call_data, bool io_failure);\n\tCCallResult<Steam, LeaderboardScoresDownloaded_t> callResultEntries;\n\tvoid leaderboard_scores_downloaded(LeaderboardScoresDownloaded_t *call_data, bool io_failure);\n\tCCallResult<Steam, LeaderboardScoreUploaded_t> callResultUploadScore;\n\tvoid leaderboard_score_uploaded(LeaderboardScoreUploaded_t *call_data, bool io_failure);\n\tCCallResult<Steam, LeaderboardUGCSet_t> callResultLeaderboardUGCSet;\n\tvoid leaderboard_ugc_set(LeaderboardUGCSet_t *call_data, bool io_failure);\n\tCCallResult<Steam, NumberOfCurrentPlayers_t> callResultNumberOfCurrentPlayers;\n\tvoid number_of_current_players(NumberOfCurrentPlayers_t *call_data, bool io_failure);\n\tCCallResult<Steam, UserStatsReceived_t> callResultUserStatsReceived;\n\tvoid user_stats_received(UserStatsReceived_t *call_data, bool io_failure);\n\n\t// Utility\n\tCCallResult<Steam, CheckFileSignature_t> callResultCheckFileSignature;\n\tvoid check_file_signature(CheckFileSignature_t *call_data, bool io_failure);\n};\n\n\nVARIANT_ENUM_CAST(AccountType);\nVARIANT_ENUM_CAST(APICallFailure);\nVARIANT_ENUM_CAST(AudioPlaybackStatus);\nVARIANT_ENUM_CAST(AuthSessionResponse);\nVARIANT_ENUM_CAST(AvatarSizes);\n\nVARIANT_ENUM_CAST(BeginAuthSessionResult);\nVARIANT_BITFIELD_CAST(BetaBranchFlags);\nVARIANT_ENUM_CAST(BroadcastUploadResult);\n\nVARIANT_ENUM_CAST(ChatEntryType);\nVARIANT_BITFIELD_CAST(ChatMemberStateChange);\nVARIANT_ENUM_CAST(ChatRoomEnterResponse);\nVARIANT_BITFIELD_CAST(ChatSteamIDInstanceFlags);\nVARIANT_ENUM_CAST(CheckFileSignature);\nVARIANT_ENUM_CAST(CommunityProfileItemType);\nVARIANT_ENUM_CAST(CommunityProfileItemProperty);\nVARIANT_ENUM_CAST(ControllerHapticLocation);\nVARIANT_ENUM_CAST(ControllerHapticType);\nVARIANT_ENUM_CAST(ControllerPad);\n\nVARIANT_ENUM_CAST(DenyReason);\nVARIANT_ENUM_CAST(DeviceFormFactor);\nVARIANT_ENUM_CAST(DurationControlNotification);\nVARIANT_ENUM_CAST(DurationControlOnlineState);\nVARIANT_ENUM_CAST(DurationControlProgress);\n\nVARIANT_ENUM_CAST(FilePathType);\nVARIANT_ENUM_CAST(FloatingGamepadTextInputMode);\nVARIANT_BITFIELD_CAST(FriendFlags);\nVARIANT_ENUM_CAST(FriendRelationship);\n\nVARIANT_ENUM_CAST(GameIDType);\nVARIANT_ENUM_CAST(GamepadTextInputLineMode);\nVARIANT_ENUM_CAST(GamepadTextInputMode);\nVARIANT_ENUM_CAST(GameSearchErrorCode);\n\nVARIANT_BITFIELD_CAST(HTMLKeyModifiers);\nVARIANT_ENUM_CAST(HTMLMouseButton);\nVARIANT_ENUM_CAST(HTTPMethod);\nVARIANT_ENUM_CAST(HTTPStatusCode);\n\nVARIANT_ENUM_CAST(InputActionEventType);\nVARIANT_ENUM_CAST(InputActionOrigin);\nVARIANT_BITFIELD_CAST(InputConfigurationEnableType);\nVARIANT_ENUM_CAST(InputGlyphSize);\nVARIANT_BITFIELD_CAST(InputGlyphStyle);\nVARIANT_ENUM_CAST(InputLEDFlag);\nVARIANT_ENUM_CAST(InputSourceMode);\nVARIANT_ENUM_CAST(InputType);\nVARIANT_ENUM_CAST(IPType);\nVARIANT_ENUM_CAST(IPv6ConnectivityProtocol);\nVARIANT_ENUM_CAST(IPv6ConnectivityState);\nVARIANT_BITFIELD_CAST(ItemFlags);\nVARIANT_ENUM_CAST(ItemPreviewType);\nVARIANT_BITFIELD_CAST(ItemState);\nVARIANT_ENUM_CAST(ItemStatistic);\nVARIANT_ENUM_CAST(ItemUpdateStatus);\n\nVARIANT_ENUM_CAST(LeaderboardDataRequest);\nVARIANT_ENUM_CAST(LeaderboardDisplayType);\nVARIANT_ENUM_CAST(LeaderboardSortMethod);\nVARIANT_ENUM_CAST(LeaderboardUploadScoreMethod);\nVARIANT_ENUM_CAST(LobbyComparison);\nVARIANT_ENUM_CAST(LobbyDistanceFilter);\nVARIANT_ENUM_CAST(LobbyType);\nVARIANT_ENUM_CAST(LocalFileChange);\n\nVARIANT_ENUM_CAST(MarketNotAllowedReasonFlags);\nVARIANT_ENUM_CAST(MatchMakingServerResponse);\nVARIANT_ENUM_CAST(MouseCursor);\n\nVARIANT_ENUM_CAST(NetworkingAvailability);\nVARIANT_ENUM_CAST(NetworkingConfigDataType);\nVARIANT_ENUM_CAST(NetworkingConfigScope);\nVARIANT_ENUM_CAST(NetworkingConfigValue);\nVARIANT_ENUM_CAST(NetworkingConnectionEnd);\nVARIANT_ENUM_CAST(NetworkingConnectionState);\nVARIANT_ENUM_CAST(NetworkingFakeIPType);\nVARIANT_ENUM_CAST(NetworkingGetConfigValueResult);\nVARIANT_ENUM_CAST(NetworkingIdentityType);\nVARIANT_ENUM_CAST(NetworkingSocketsDebugOutputType);\nVARIANT_ENUM_CAST(NotificationPosition);\n\nVARIANT_ENUM_CAST(OverlayToStoreFlag);\nVARIANT_ENUM_CAST(OverlayToWebPageMode);\n\nVARIANT_ENUM_CAST(P2PSend);\nVARIANT_ENUM_CAST(P2PSessionError);\nVARIANT_ENUM_CAST(ParentalFeature);\nVARIANT_ENUM_CAST(PartyBeaconLocationData);\nVARIANT_ENUM_CAST(PartyBeaconLocationType);\nVARIANT_BITFIELD_CAST(PersonaChange);\nVARIANT_ENUM_CAST(PersonaState);\nVARIANT_ENUM_CAST(PlayerResult);\n\nVARIANT_BITFIELD_CAST(RemoteStoragePlatform);\nVARIANT_ENUM_CAST(RemoteStoragePublishedFileVisibility);\nVARIANT_ENUM_CAST(Result);\n\nVARIANT_ENUM_CAST(SCEPadTriggerEffectMode);\nVARIANT_ENUM_CAST(SocketConnectionType);\nVARIANT_ENUM_CAST(SocketState);\nVARIANT_ENUM_CAST(SteamAPIInitResult);\n\nVARIANT_ENUM_CAST(TextFilteringContext);\nVARIANT_ENUM_CAST(TimelineGameMode);\nVARIANT_ENUM_CAST(TimelineEventClipPriority);\n\nVARIANT_ENUM_CAST(Universe);\nVARIANT_ENUM_CAST(UGCContentDescriptorID);\nVARIANT_ENUM_CAST(UGCMatchingUGCType);\nVARIANT_ENUM_CAST(UGCQuery);\nVARIANT_ENUM_CAST(UGCReadAction);\nVARIANT_ENUM_CAST(UserHasLicenseForAppResult);\nVARIANT_BITFIELD_CAST(UserRestriction);\nVARIANT_ENUM_CAST(UserUGCList);\nVARIANT_ENUM_CAST(UserUGCListSortOrder);\n\nVARIANT_ENUM_CAST(VoiceResult);\nVARIANT_ENUM_CAST(VRScreenshotType);\n\nVARIANT_ENUM_CAST(WorkshopEnumerationType);\nVARIANT_ENUM_CAST(WorkshopFileAction);\nVARIANT_ENUM_CAST(WorkshopFileType);\nVARIANT_ENUM_CAST(WorkshopVideoProvider);\nVARIANT_ENUM_CAST(WorkshopVote);\n\nVARIANT_ENUM_CAST(XboxOrigin);\n\n\n#endif // GODOTSTEAM_H"
        },
        {
          "name": "godotsteam_constants.h",
          "type": "blob",
          "size": 8.0615234375,
          "content": "#ifndef GODOTSTEAM_CONSTANTS_H\n#define GODOTSTEAM_CONSTANTS_H\n\n\n// Constants with 'deprecated/': these were listed in the SDK docs but do not exist in the header files; safe to remove probably\n// Possibly deprecated or never existed?\n#define ACCOUNT_ID_INVALID k_uAccountIdInvalid\n#define API_CALL_INVALID k_uAPICallInvalid\n#define APP_ID_INVALID k_uAppIdInvalid\n#define AUTH_TICKET_INVALID k_HAuthTicketInvalid\n#define DEPOT_ID_INVALID k_uDepotIdInvalid\n#define GAME_EXTRA_INFO_MAX k_cchGameExtraInfoMax\n#define INVALID_BREAKPAD_HANDLE 0 //deprecated?\n#define QUERY_PORT_ERROR 0xFFFE //deprecated?\n#define QUERY_PORT_NOT_INITIALIZED 0xFFFF //deprecated?\n#define STEAM_ACCOUNT_ID_MASK k_unSteamAccountIDMask\n#define STEAM_ACCOUNT_INSTANCE_MASK k_unSteamAccountInstanceMask\n#define STEAM_BUFFER_SIZE 255 //deprecated?\n#define STEAM_LARGE_BUFFER_SIZE 8160 //deprecated?\n#define STEAM_MAX_ERROR_MESSAGE 1024\n#define STEAM_USER_CONSOLE_INSTANCE 2 //deprecated?\n#define STEAM_USER_DESKTOP_INSTANCE k_unSteamUserDefaultInstance\n#define STEAM_USER_WEB_INSTANCE 4 //deprecated?\n\n// Define Friends constants\n#define CHAT_METADATA_MAX k_cubChatMetadataMax\n#define ENUMERATED_FOLLOWERS_MAX k_cEnumerateFollowersMax\n#define FRIEND_GAME_INFO_QUERY_PORT_ERROR k_usFriendGameInfoQueryPort_Error\n#define FRIEND_GAME_INFO_QUERY_PORT_NOT_INITIALIZED k_usFriendGameInfoQueryPort_NotInitialized\n#define FRIENDS_GROUP_LIMIT k_cFriendsGroupLimit\n#define INVALID_FRIEND_GROUP_ID k_FriendsGroupID_Invalid\n#define MAX_FRIENDS_GROUP_NAME k_cchMaxFriendsGroupName\n#define MAX_RICH_PRESENCE_KEY_LENGTH k_cchMaxRichPresenceKeyLength\n#define MAX_RICH_PRESENCE_KEYS k_cchMaxRichPresenceKeys\n#define MAX_RICH_PRESENCE_VALUE_LENTH k_cchMaxRichPresenceValueLength\n#define PERSONA_NAME_MAX_UTF8 k_cchPersonaNameMax\n#define PERSONA_NAME_MAX_UTF16 k_cwchPersonaNameMax\n\n// Define HTML Surface constants\n#define INVALID_HTMLBROWSER 0\n\n// Define HTTP constants\n#define HTTPCOOKIE_INVALID_HANDLE INVALID_HTTPCOOKIE_HANDLE\n#define HTTPREQUEST_INVALID_HANDLE INVALID_HTTPREQUEST_HANDLE\n\n// Define Input constants\n#define INPUT_HANDLE_ALL_CONTROLLERS STEAM_INPUT_HANDLE_ALL_CONTROLLERS\n#define INPUT_MAX_ACTIVE_LAYERS STEAM_INPUT_MAX_ACTIVE_LAYERS\n#define INPUT_MAX_ANALOG_ACTIONS STEAM_INPUT_MAX_ANALOG_ACTIONS\n#define INPUT_MAX_ANALOG_ACTION_DATA STEAM_INPUT_MAX_ANALOG_ACTION_DATA\n#define INPUT_MAX_COUNT STEAM_INPUT_MAX_COUNT\n#define INPUT_MAX_DIGITAL_ACTIONS STEAM_INPUT_MAX_DIGITAL_ACTIONS\n#define INPUT_MAX_ORIGINS STEAM_INPUT_MAX_ORIGINS\n#define INPUT_MIN_ANALOG_ACTION_DATA STEAM_INPUT_MIN_ANALOG_ACTION_DATA\n\n// Define Inventory constants\n#define INVENTORY_RESULT_INVALID k_SteamInventoryResultInvalid\n#define ITEM_INSTANCE_ID_INVALID k_SteamItemInstanceIDInvalid\n\n// Define Matchmaking constants\n#define FAVORITE_FLAG_FAVORITE k_unFavoriteFlagFavorite\n#define FAVORITE_FLAG_HISTORY k_unFavoriteFlagHistory\n#define FAVORITE_FLAG_NONE k_unFavoriteFlagNone\n#define MAX_LOBBY_KEY_LENGTH k_nMaxLobbyKeyLength\n#define SERVER_QUERY_INVALID HSERVERQUERY_INVALID\n\n// Define Matchmaking Servers constants\n#define MAX_GAME_SERVER_GAME_DATA k_cbMaxGameServerGameData\n#define MAX_GAME_SERVER_GAME_DESCRIPTION k_cbMaxGameServerGameDescription\n#define MAX_GAME_SERVER_GAME_DIR k_cbMaxGameServerGameDir\n#define MAX_GAME_SERVER_MAP_NAME k_cbMaxGameServerMapName\n#define MAX_GAME_SERVER_NAME k_cbMaxGameServerName\n#define MAX_GAME_SERVER_TAGS k_cbMaxGameServerTags\n\n// Define Music Remote constants\n#define MUSIC_NAME_MAX_LENGTH k_SteamMusicNameMaxLength\n#define MUSIC_PNG_MAX_LENGTH k_SteamMusicPNGMaxLength\n\n// Define Networking Socket constants\n#define MAX_STEAM_PACKET_SIZE k_cbMaxSteamNetworkingSocketsMessageSizeSend\n\n// Define Networking Types constants | Found in steamnetworkingtypes.h\n#define LISTEN_SOCKET_INVALID k_HSteamListenSocket_Invalid\n#define MAX_NETWORKING_ERROR_MESSAGE k_cchMaxSteamNetworkingErrMsg\n#define MAX_NETWORKING_PING_LOCATION_STRING k_cchMaxSteamNetworkingPingLocationString\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DEFAULT k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DISABLE k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_RELAY k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PRIVATE k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PUBLIC k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public\n#define NETWORKING_CONFIG_P2P_TRANSPORT_ICE_ALL k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All\n#define NETWORKING_CONNECTION_INFO_FLAG_UNAUTHENTICATED k_nSteamNetworkConnectionInfoFlags_Unauthenticated\n#define NETWORKING_CONNECTION_INFO_FLAG_UNENCRYPTED k_nSteamNetworkConnectionInfoFlags_Unencrypted\n#define NETWORKING_CONNECTION_INFO_FLAG_LOOPBACK_BUFFERS k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers\n#define NETWORKING_CONNECTION_INFO_FLAG_FAST k_nSteamNetworkConnectionInfoFlags_Fast\n#define NETWORKING_CONNECTION_INFO_FLAG_RELAYED k_nSteamNetworkConnectionInfoFlags_Relayed\n#define NETWORKING_CONNECTION_INFO_FLAG_DUALWIFI k_nSteamNetworkConnectionInfoFlags_DualWifi\n#define NETWORKING_CONNECTION_INVALID k_HSteamNetConnection_Invalid\n#define NETWORKING_MAX_CONNECTION_APP_NAME k_cchSteamNetworkingMaxConnectionAppName\n#define NETWORKING_MAX_CONNECTION_CLOSE_REASON k_cchSteamNetworkingMaxConnectionCloseReason\n#define NETWORKING_MAX_CONNECTION_DESCRIPTION k_cchSteamNetworkingMaxConnectionDescription\n#define NETWORKING_PING_FAILED k_nSteamNetworkingPing_Failed\n#define NETWORKING_PING_UNKNOWN k_nSteamNetworkingPing_Unknown\n#define NETWORKING_SEND_UNRELIABLE k_nSteamNetworkingSend_Unreliable\n#define NETWORKING_SEND_NO_NAGLE k_nSteamNetworkingSend_NoNagle\n#define NETWORKING_SEND_URELIABLE_NO_NAGLE k_nSteamNetworkingSend_UnreliableNoNagle\n#define NETWORKING_SEND_NO_DELAY k_nSteamNetworkingSend_NoDelay\n#define NETWORKING_SEND_UNRELIABLE_NO_DELAY k_nSteamNetworkingSend_UnreliableNoDelay\n#define NETWORKING_SEND_RELIABLE k_nSteamNetworkingSend_Reliable\n#define NETWORKING_SEND_RELIABLE_NO_NAGLE k_nSteamNetworkingSend_ReliableNoNagle\n#define NETWORKING_SEND_USE_CURRENT_THREAD k_nSteamNetworkingSend_UseCurrentThread\n#define NETWORKING_SEND_AUTORESTART_BROKEN_SESSION k_nSteamNetworkingSend_AutoRestartBrokenSession\n\n// Define Remote Storage constants\n#define ENUMERATE_PUBLISHED_FILES_MAX_RESULTS k_unEnumeratePublishedFilesMaxResults\n#define FILE_NAME_MAX k_cchFilenameMax\n#define MAX_CLOUD_FILE_CHUNK_SIZE k_unMaxCloudFileChunkSize\n#define PUBLISHED_DOCUMENT_CHANGE_DESCRIPTION_MAX k_cchPublishedDocumentChangeDescriptionMax\n#define PUBLISHED_DOCUMENT_DESCRIPTION_MAX k_cchPublishedDocumentDescriptionMax\n#define PUBLISHED_DOCUMENT_TITLE_MAX k_cchPublishedDocumentTitleMax\n#define PUBLISHED_FILE_ID_INVALID k_PublishedFileIdInvalid\n#define PUBLISHED_FILE_UPDATE_HANDLE_INVALID k_PublishedFileUpdateHandleInvalid\n#define PUBLISHED_FILE_URL_MAX k_cchPublishedFileURLMax\n#define TAG_LIST_MAX k_cchTagListMax\n#define UGC_FILE_STREAM_HANDLE_INVALID k_UGCFileStreamHandleInvalid\n#define UGC_HANDLE_INVALID k_UGCHandleInvalid\n\n// Define Screenshot constants\n#define MAX_TAGGED_PUBLISHED_FILES k_nScreenshotMaxTaggedPublishedFiles\n#define MAX_TAGGED_USERS k_nScreenshotMaxTaggedUsers\n#define SCREENSHOT_INVALID_HANDLE INVALID_SCREENSHOT_HANDLE\n#define SCREENSHOT_THUMB_WIDTH k_ScreenshotThumbWidth\n#define UFS_TAG_TYPE_MAX k_cubUFSTagTypeMax\n#define UFS_TAG_VALUE_MAX k_cubUFSTagValueMax\n\n// Define Timeline constants\n#define MAX_PHASE_ID_LENGTH k_cchMaxPhaseIDLength\n#define MAX_TIMELINE_PRIORITY k_unMaxTimelinePriority\n#define MAX_TIMELINE_EVENT_DURATION k_flMaxTimelineEventDuration\n#define TIMELINE_PRIORITY_KEEP_CURRENT_VALUE k_unTimelinePriority_KeepCurrentValue\n\n// Define UGC constants\n#define DEVELOPER_METADATA_MAX k_cchDeveloperMetadataMax\n#define NUM_UGC_RESULTS_PER_PAGE kNumUGCResultsPerPage\n#define UGC_QUERY_HANDLE_INVALID k_UGCQueryHandleInvalid\n#define UGC_UPDATE_HANDLE_INVALID k_UGCUpdateHandleInvalid\n\n// Define User Stats constants\n#define LEADERBOARD_DETAIL_MAX k_cLeaderboardDetailsMax\n#define LEADERBOARD_NAME_MAX k_cchLeaderboardNameMax\n#define STAT_NAME_MAX k_cchStatNameMax\n\n\n#endif // GODOTSTEAM_CONSTANTS_H"
        },
        {
          "name": "godotsteam_enums.h",
          "type": "blob",
          "size": 109.1376953125,
          "content": "#ifndef GODOTSTEAM_ENUMS_H\n#define GODOTSTEAM_ENUMS_H\n\n\nenum AccountType {\n\t// Found in steamclientpublic.h\n\tACCOUNT_TYPE_INVALID = k_EAccountTypeInvalid,\n\tACCOUNT_TYPE_INDIVIDUAL = k_EAccountTypeIndividual,\n\tACCOUNT_TYPE_MULTISEAT = k_EAccountTypeMultiseat,\n\tACCOUNT_TYPE_GAME_SERVER = k_EAccountTypeGameServer,\n\tACCOUNT_TYPE_ANON_GAME_SERVER = k_EAccountTypeAnonGameServer,\n\tACCOUNT_TYPE_PENDING = k_EAccountTypePending,\n\tACCOUNT_TYPE_CONTENT_SERVER = k_EAccountTypeContentServer,\n\tACCOUNT_TYPE_CLAN = k_EAccountTypeClan,\n\tACCOUNT_TYPE_CHAT = k_EAccountTypeChat,\n\tACCOUNT_TYPE_CONSOLE_USER = k_EAccountTypeConsoleUser,\n\tACCOUNT_TYPE_ANON_USER = k_EAccountTypeAnonUser,\n\tACCOUNT_TYPE_MAX = k_EAccountTypeMax\n};\n\nenum AuthSessionResponse {\n\t// Found in steamclientpublic.h\n\tAUTH_SESSION_RESPONSE_OK = k_EAuthSessionResponseOK,\n\tAUTH_SESSION_RESPONSE_USER_NOT_CONNECTED_TO_STEAM = k_EAuthSessionResponseUserNotConnectedToSteam,\n\tAUTH_SESSION_RESPONSE_NO_LICENSE_OR_EXPIRED = k_EAuthSessionResponseNoLicenseOrExpired,\n\tAUTH_SESSION_RESPONSE_VAC_BANNED = k_EAuthSessionResponseVACBanned,\n\tAUTH_SESSION_RESPONSE_LOGGED_IN_ELSEWHERE = k_EAuthSessionResponseLoggedInElseWhere,\n\tAUTH_SESSION_RESPONSE_VAC_CHECK_TIMED_OUT = k_EAuthSessionResponseVACCheckTimedOut,\n\tAUTH_SESSION_RESPONSE_AUTH_TICKET_CANCELED = k_EAuthSessionResponseAuthTicketCanceled,\n\tAUTH_SESSION_RESPONSE_AUTH_TICKET_INVALID_ALREADY_USED = k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed,\n\tAUTH_SESSION_RESPONSE_AUTH_TICKET_INVALID = k_EAuthSessionResponseAuthTicketInvalid,\n\tAUTH_SESSION_RESPONSE_PUBLISHER_ISSUED_BAN = k_EAuthSessionResponsePublisherIssuedBan,\n\tAUTH_SESSION_RESPONSE_AUTH_TICKET_NETWORK_IDENTITY_FAILURE = k_EAuthSessionResponseAuthTicketNetworkIdentityFailure\n};\n\nenum BeginAuthSessionResult {\n\t// Found in steamclientpublic.h\n\tBEGIN_AUTH_SESSION_RESULT_OK = k_EBeginAuthSessionResultOK,\n\tBEGIN_AUTH_SESSION_RESULT_INVALID_TICKET = k_EBeginAuthSessionResultInvalidTicket,\n\tBEGIN_AUTH_SESSION_RESULT_DUPLICATE_REQUEST = k_EBeginAuthSessionResultDuplicateRequest,\n\tBEGIN_AUTH_SESSION_RESULT_INVALID_VERSION = k_EBeginAuthSessionResultInvalidVersion,\n\tBEGIN_AUTH_SESSION_RESULT_GAME_MISMATCH = k_EBeginAuthSessionResultGameMismatch,\n\tBEGIN_AUTH_SESSION_RESULT_EXPIRED_TICKET = k_EBeginAuthSessionResultExpiredTicket\n};\n\nenum BetaBranchFlags {\n\t// Found in steamclientpublic.h\n\tBETA_BRANCH_NONE = k_EBetaBranch_None,\n\tBETA_BRANCH_DEFAULT = k_EBetaBranch_Default,\n\tBETA_BRANCH_AVAILABLE = k_EBetaBranch_Available,\n\tBETA_BRANCH_PRIVATE = k_EBetaBranch_Private,\n\tBETA_BRANCH_SELECTED = k_EBetaBranch_Selected,\n\tBETA_BRANCH_INSTALLED = k_EBetaBranch_Installed\n};\n\nenum BroadcastUploadResult {\n\t// Found in steamclientpublic.h\n\tBROADCAST_UPLOAD_RESULT_NONE = k_EBroadcastUploadResultNone,\n\tBROADCAST_UPLOAD_RESULT_OK = k_EBroadcastUploadResultOK,\n\tBROADCAST_UPLOAD_RESULT_INIT_FAILED = k_EBroadcastUploadResultInitFailed,\n\tBROADCAST_UPLOAD_RESULT_FRAME_FAILED = k_EBroadcastUploadResultFrameFailed,\n\tBROADCAST_UPLOAD_RESULT_TIME_OUT = k_EBroadcastUploadResultTimeout,\n\tBROADCAST_UPLOAD_RESULT_BANDWIDTH_EXCEEDED = k_EBroadcastUploadResultBandwidthExceeded,\n\tBROADCAST_UPLOAD_RESULT_LOW_FPS = k_EBroadcastUploadResultLowFPS,\n\tBROADCAST_UPLOAD_RESULT_MISSING_KEYFRAMES = k_EBroadcastUploadResultMissingKeyFrames,\n\tBROADCAST_UPLOAD_RESULT_NO_CONNECTION = k_EBroadcastUploadResultNoConnection,\n\tBROADCAST_UPLOAD_RESULT_RELAY_FAILED = k_EBroadcastUploadResultRelayFailed,\n\tBROADCAST_UPLOAD_RESULT_SETTINGS_CHANGED = k_EBroadcastUploadResultSettingsChanged,\n\tBROADCAST_UPLOAD_RESULT_MISSING_AUDIO = k_EBroadcastUploadResultMissingAudio,\n\tBROADCAST_UPLOAD_RESULT_TOO_FAR_BEHIND = k_EBroadcastUploadResultTooFarBehind,\n\tBROADCAST_UPLOAD_RESULT_TRANSCODE_BEHIND = k_EBroadcastUploadResultTranscodeBehind,\n\tBROADCAST_UPLOAD_RESULT_NOT_ALLOWED_TO_PLAY = k_EBroadcastUploadResultNotAllowedToPlay,\n\tBROADCAST_UPLOAD_RESULT_BUSY = k_EBroadcastUploadResultBusy,\n\tBROADCAST_UPLOAD_RESULT_BANNED = k_EBroadcastUploadResultBanned,\n\tBROADCAST_UPLOAD_RESULT_ALREADY_ACTIVE = k_EBroadcastUploadResultAlreadyActive,\n\tBROADCAST_UPLOAD_RESULT_FORCED_OFF = k_EBroadcastUploadResultForcedOff,\n\tBROADCAST_UPLOAD_RESULT_AUDIO_BEHIND = k_EBroadcastUploadResultAudioBehind,\n\tBROADCAST_UPLOAD_RESULT_SHUTDOWN = k_EBroadcastUploadResultShutdown,\n\tBROADCAST_UPLOAD_RESULT_DISCONNECT = k_EBroadcastUploadResultDisconnect,\n\tBROADCAST_UPLOAD_RESULT_VIDEO_INIT_FAILED = k_EBroadcastUploadResultVideoInitFailed,\n\tBROADCAST_UPLOAD_RESULT_AUDIO_INIT_FAILED = k_EBroadcastUploadResultAudioInitFailed\n};\n\nenum ChatEntryType {\n\t// Found in steamclientpublic.h\n\tCHAT_ENTRY_TYPE_INVALID = k_EChatEntryTypeInvalid,\n\tCHAT_ENTRY_TYPE_CHAT_MSG = k_EChatEntryTypeChatMsg,\n\tCHAT_ENTRY_TYPE_TYPING = k_EChatEntryTypeTyping,\n\tCHAT_ENTRY_TYPE_INVITE_GAME = k_EChatEntryTypeInviteGame,\n\tCHAT_ENTRY_TYPE_EMOTE = k_EChatEntryTypeEmote,\n\t//\t\t\tCHAT_ENTRY_TYPE_LOBBY_GAME_START = k_EChatEntryTypeLobbyGameStart,\n\tCHAT_ENTRY_TYPE_LEFT_CONVERSATION = k_EChatEntryTypeLeftConversation,\n\tCHAT_ENTRY_TYPE_ENTERED = k_EChatEntryTypeEntered,\n\tCHAT_ENTRY_TYPE_WAS_KICKED = k_EChatEntryTypeWasKicked,\n\tCHAT_ENTRY_TYPE_WAS_BANNED = k_EChatEntryTypeWasBanned,\n\tCHAT_ENTRY_TYPE_DISCONNECTED = k_EChatEntryTypeDisconnected,\n\tCHAT_ENTRY_TYPE_HISTORICAL_CHAT = k_EChatEntryTypeHistoricalChat,\n\tCHAT_ENTRY_TYPE_LINK_BLOCKED = k_EChatEntryTypeLinkBlocked\n};\n\nenum ChatRoomEnterResponse {\n\t// Found in steamclientpublic.h\n\tCHAT_ROOM_ENTER_RESPONSE_SUCCESS = k_EChatRoomEnterResponseSuccess,\n\tCHAT_ROOM_ENTER_RESPONSE_DOESNT_EXIST = k_EChatRoomEnterResponseDoesntExist,\n\tCHAT_ROOM_ENTER_RESPONSE_NOT_ALLOWED = k_EChatRoomEnterResponseNotAllowed,\n\tCHAT_ROOM_ENTER_RESPONSE_FULL = k_EChatRoomEnterResponseFull,\n\tCHAT_ROOM_ENTER_RESPONSE_ERROR = k_EChatRoomEnterResponseError,\n\tCHAT_ROOM_ENTER_RESPONSE_BANNED = k_EChatRoomEnterResponseBanned,\n\tCHAT_ROOM_ENTER_RESPONSE_LIMITED = k_EChatRoomEnterResponseLimited,\n\tCHAT_ROOM_ENTER_RESPONSE_CLAN_DISABLED = k_EChatRoomEnterResponseClanDisabled,\n\tCHAT_ROOM_ENTER_RESPONSE_COMMUNITY_BAN = k_EChatRoomEnterResponseCommunityBan,\n\tCHAT_ROOM_ENTER_RESPONSE_MEMBER_BLOCKED_YOU = k_EChatRoomEnterResponseMemberBlockedYou,\n\tCHAT_ROOM_ENTER_RESPONSE_YOU_BLOCKED_MEMBER = k_EChatRoomEnterResponseYouBlockedMember,\n\tCHAT_ROOM_ENTER_RESPONSE_RATE_LIMIT_EXCEEDED = k_EChatRoomEnterResponseRatelimitExceeded\n};\n\nenum ChatSteamIDInstanceFlags {\n\t// Found in steamclientpublic.h\n\tCHAT_ACCOUNT_INSTANCE_MASK = k_EChatAccountInstanceMask,\n\tCHAT_INSTANCE_FLAG_CLAN = k_EChatInstanceFlagClan,\n\tCHAT_INSTANCE_FLAG_LOBBY = k_EChatInstanceFlagLobby,\n\tCHAT_INSTANCE_FLAG_MMS_LOBBY = k_EChatInstanceFlagMMSLobby\n};\n\nenum DenyReason {\n\t// Found in steamclientpublic.h\n\tDENY_INVALID = k_EDenyInvalid,\n\tDENY_INVALID_VERSION = k_EDenyInvalidVersion,\n\tDENY_GENERIC = k_EDenyGeneric,\n\tDENY_NOT_LOGGED_ON = k_EDenyNotLoggedOn,\n\tDENY_NO_LICENSE = k_EDenyNoLicense,\n\tDENY_CHEATER = k_EDenyCheater,\n\tDENY_LOGGED_IN_ELSEWHERE = k_EDenyLoggedInElseWhere,\n\tDENY_UNKNOWN_TEXT = k_EDenyUnknownText,\n\tDENY_INCOMPATIBLE_ANTI_CHEAT = k_EDenyIncompatibleAnticheat,\n\tDENY_MEMORY_CORRUPTION = k_EDenyMemoryCorruption,\n\tDENY_INCOMPATIBLE_SOFTWARE = k_EDenyIncompatibleSoftware,\n\tDENY_STEAM_CONNECTION_LOST = k_EDenySteamConnectionLost,\n\tDENY_STEAM_CONNECTION_ERROR = k_EDenySteamConnectionError,\n\tDENY_STEAM_RESPONSE_TIMED_OUT = k_EDenySteamResponseTimedOut,\n\tDENY_STEAM_VALIDATION_STALLED = k_EDenySteamValidationStalled,\n\tDENY_STEAM_OWNER_LEFT_GUEST_USER = k_EDenySteamOwnerLeftGuestUser\n};\n\nenum GameIDType {\n\tGAME_TYPE_APP = CGameID::k_EGameIDTypeApp,\n\tGAME_TYPE_GAME_MOD = CGameID::k_EGameIDTypeGameMod,\n\tGAME_TYPE_SHORTCUT = CGameID::k_EGameIDTypeShortcut,\n\tGAME_TYPE_P2P = CGameID::k_EGameIDTypeP2P\n};\n\nenum IPType {\n\tIP_TYPE_IPV4 = k_ESteamIPTypeIPv4,\n\tIP_TYPE_IPV6 = k_ESteamIPTypeIPv6\n};\n\nenum IPv6ConnectivityProtocol {\n\t// Found in steamclientpublic.h\n\tIPV6_CONNECTIVITY_PROTOCOL_INVALID = k_ESteamIPv6ConnectivityProtocol_Invalid,\n\tIPV6_CONNECTIVITY_PROTOCOL_HTTP = k_ESteamIPv6ConnectivityProtocol_HTTP,\n\tIPV6_CONNECTIVITY_PROTOCOL_UDP = k_ESteamIPv6ConnectivityProtocol_UDP\n};\n\nenum IPv6ConnectivityState {\n\t// Found in steamclientpublic.h\n\tIPV6_CONNECTIVITY_STATE_UNKNOWN = k_ESteamIPv6ConnectivityState_Unknown,\n\tIPV6_CONNECTIVITY_STATE_GOOD = k_ESteamIPv6ConnectivityState_Good,\n\tIPV6_CONNECTIVITY_STATE_BAD = k_ESteamIPv6ConnectivityState_Bad\n};\n\nenum MarketNotAllowedReasonFlags {\n\t// Found in steamclientpublic.h\n\tMARKET_NOT_ALLOWED_REASON_NONE = k_EMarketNotAllowedReason_None,\n\tMARKET_NOT_ALLOWED_REASON_TEMPORARY_FAILURE = k_EMarketNotAllowedReason_TemporaryFailure,\n\tMARKET_NOT_ALLOWED_REASON_ACCOUNT_DISABLED = k_EMarketNotAllowedReason_AccountDisabled,\n\tMARKET_NOT_ALLOWED_REASON_ACCOUNT_LOCKED_DOWN = k_EMarketNotAllowedReason_AccountLockedDown,\n\tMARKET_NOT_ALLOWED_REASON_ACCOUNT_LIMITED = k_EMarketNotAllowedReason_AccountLimited,\n\tMARKET_NOT_ALLOWED_REASON_TRADE_BANNED = k_EMarketNotAllowedReason_TradeBanned,\n\tMARKET_NOT_ALLOWED_REASON_ACCOUNT_NOT_TRUSTED = k_EMarketNotAllowedReason_AccountNotTrusted,\n\tMARKET_NOT_ALLOWED_REASON_STEAM_GUARD_NOT_ENABLED = k_EMarketNotAllowedReason_SteamGuardNotEnabled,\n\tMARKET_NOT_ALLOWED_REASON_STEAM_GAURD_ONLY_RECENTLY_ENABLED = k_EMarketNotAllowedReason_SteamGuardOnlyRecentlyEnabled,\n\tMARKET_NOT_ALLOWED_REASON_RECENT_PASSWORD_RESET = k_EMarketNotAllowedReason_RecentPasswordReset,\n\tMARKET_NOT_ALLOWED_REASON_NEW_PAYMENT_METHOD = k_EMarketNotAllowedReason_NewPaymentMethod,\n\tMARKET_NOT_ALLOWED_REASON_INVALID_COOKIE = k_EMarketNotAllowedReason_InvalidCookie,\n\tMARKET_NOT_ALLOWED_REASON_USING_NEW_DEVICE = k_EMarketNotAllowedReason_UsingNewDevice,\n\tMARKET_NOT_ALLOWED_REASON_RECENT_SELF_REFUND = k_EMarketNotAllowedReason_RecentSelfRefund,\n\tMARKET_NOT_ALLOWED_REASON_NEW_PAYMENT_METHOD_CANNOT_BE_VERIFIED = k_EMarketNotAllowedReason_NewPaymentMethodCannotBeVerified,\n\tMARKET_NOT_ALLOWED_REASON_NO_RECENT_PURCHASES = k_EMarketNotAllowedReason_NoRecentPurchases,\n\tMARKET_NOT_ALLOWED_REASON_ACCEPTED_WALLET_GIFT = k_EMarketNotAllowedReason_AcceptedWalletGift\n};\n\nenum NotificationPosition {\n\t// Found in steamclientpublic.h\n\tPOSITION_INVALID = k_EPositionInvalid,\n\tPOSITION_TOP_LEFT = k_EPositionTopLeft,\n\tPOSITION_TOP_RIGHT = k_EPositionTopRight,\n\tPOSITION_BOTTOM_LEFT = k_EPositionBottomLeft,\n\tPOSITION_BOTTOM_RIGHT = k_EPositionBottomRight\n};\n\nenum Result {\n\t// Found in steamclientpublic.h\n\tRESULT_NONE = k_EResultNone,\n\tRESULT_OK = k_EResultOK,\n\tRESULT_FAIL = k_EResultFail,\n\tRESULT_NO_CONNECTION = k_EResultNoConnection,\n\tRESULT_INVALID_PASSWORD = k_EResultInvalidPassword,\n\tRESULT_LOGGED_IN_ELSEWHERE = k_EResultLoggedInElsewhere,\n\tRESULT_INVALID_PROTOCOL_VER = k_EResultInvalidProtocolVer,\n\tRESULT_INVALID_PARAM = k_EResultInvalidParam,\n\tRESULT_FILE_NOT_FOUND = k_EResultFileNotFound,\n\tRESULT_BUSY = k_EResultBusy,\n\tRESULT_INVALID_STATE = k_EResultInvalidState,\n\tRESULT_INVALID_NAME = k_EResultInvalidName,\n\tRESULT_INVALID_EMAIL = k_EResultInvalidEmail,\n\tRESULT_DUPLICATE_NAME = k_EResultDuplicateName,\n\tRESULT_ACCESS_DENIED = k_EResultAccessDenied,\n\tRESULT_TIMEOUT = k_EResultTimeout,\n\tRESULT_BANNED = k_EResultBanned,\n\tRESULT_ACCOUNT_NOT_FOUND = k_EResultAccountNotFound,\n\tRESULT_INVALID_STEAMID = k_EResultInvalidSteamID,\n\tRESULT_SERVICE_UNAVAILABLE = k_EResultServiceUnavailable,\n\tRESULT_NOT_LOGGED_ON = k_EResultNotLoggedOn,\n\tRESULT_PENDING = k_EResultPending,\n\tRESULT_ENCRYPTION_FAILURE = k_EResultEncryptionFailure,\n\tRESULT_INSUFFICIENT_PRIVILEGE = k_EResultInsufficientPrivilege,\n\tRESULT_LIMIT_EXCEEDED = k_EResultLimitExceeded,\n\tRESULT_REVOKED = k_EResultRevoked,\n\tRESULT_EXPIRED = k_EResultExpired,\n\tRESULT_ALREADY_REDEEMED = k_EResultAlreadyRedeemed,\n\tRESULT_DUPLICATE_REQUEST = k_EResultDuplicateRequest,\n\tRESULT_ALREADY_OWNED = k_EResultAlreadyOwned,\n\tRESULT_IP_NOT_FOUND = k_EResultIPNotFound,\n\tRESULT_PERSIST_FAILED = k_EResultPersistFailed,\n\tRESULT_LOCKING_FAILED = k_EResultLockingFailed,\n\tRESULT_LOG_ON_SESSION_REPLACED = k_EResultLogonSessionReplaced,\n\tRESULT_CONNECT_FAILED = k_EResultConnectFailed,\n\tRESULT_HANDSHAKE_FAILED = k_EResultHandshakeFailed,\n\tRESULT_IO_FAILURE = k_EResultIOFailure,\n\tRESULT_REMOTE_DISCONNECT = k_EResultRemoteDisconnect,\n\tRESULT_SHOPPING_CART_NOT_FOUND = k_EResultShoppingCartNotFound,\n\tRESULT_BLOCKED = k_EResultBlocked,\n\tRESULT_IGNORED = k_EResultIgnored,\n\tRESULT_NO_MATCH = k_EResultNoMatch,\n\tRESULT_ACCOUNT_DISABLED = k_EResultAccountDisabled,\n\tRESULT_SERVICE_READ_ONLY = k_EResultServiceReadOnly,\n\tRESULT_ACCOUNT_NOT_FEATURED = k_EResultAccountNotFeatured,\n\tRESULT_ADMINISTRATOR_OK = k_EResultAdministratorOK,\n\tRESULT_CONTENT_VERSION = k_EResultContentVersion,\n\tRESULT_TRY_ANOTHER_CM = k_EResultTryAnotherCM,\n\tRESULT_PASSWORD_REQUIRED_TO_KICK_SESSION = k_EResultPasswordRequiredToKickSession,\n\tRESULT_ALREADY_LOGGED_IN_ELSEWHERE = k_EResultAlreadyLoggedInElsewhere,\n\tRESULT_SUSPENDED = k_EResultSuspended,\n\tRESULT_CANCELLED = k_EResultCancelled,\n\tRESULT_DATA_CORRUPTION = k_EResultDataCorruption,\n\tRESULT_DISK_FULL = k_EResultDiskFull,\n\tRESULT_REMOTE_CALL_FAILED = k_EResultRemoteCallFailed,\n\tRESULT_PASSWORD_UNSET = k_EResultPasswordUnset,\n\tRESULT_EXTERNAL_ACCOUNT_UNLINKED = k_EResultExternalAccountUnlinked,\n\tRESULT_PSN_TICKET_INVALID = k_EResultPSNTicketInvalid,\n\tRESULT_EXTERNAL_ACCOUNT_ALREADY_LINKED = k_EResultExternalAccountAlreadyLinked,\n\tRESULT_REMOTE_FILE_CONFLICT = k_EResultRemoteFileConflict,\n\tRESULT_ILLEGAL_PASSWORD = k_EResultIllegalPassword,\n\tRESULT_SAME_AS_PREVIOUS_VALUE = k_EResultSameAsPreviousValue,\n\tRESULT_ACCOUNT_LOG_ON_DENIED = k_EResultAccountLogonDenied,\n\tRESULT_CANNOT_USE_OLD_PASSWORD = k_EResultCannotUseOldPassword,\n\tRESULT_INVALID_LOG_IN_AUTH_CODE = k_EResultInvalidLoginAuthCode,\n\tRESULT_ACCOUNT_LOG_ON_DENIED_NO_MAIL = k_EResultAccountLogonDeniedNoMail,\n\tRESULT_HARDWARE_NOT_CAPABLE_OF_IPT = k_EResultHardwareNotCapableOfIPT,\n\tRESULT_IPT_INIT_ERROR = k_EResultIPTInitError,\n\tRESULT_PARENTAL_CONTROL_RESTRICTED = k_EResultParentalControlRestricted,\n\tRESULT_FACEBOOK_QUERY_ERROR = k_EResultFacebookQueryError,\n\tRESULT_EXPIRED_LOGIN_AUTH_CODE = k_EResultExpiredLoginAuthCode,\n\tRESULT_IP_LOGIN_RESTRICTION_FAILED = k_EResultIPLoginRestrictionFailed,\n\tRESULT_ACCOUNT_LOCKED_DOWN = k_EResultAccountLockedDown,\n\tRESULT_ACCOUNT_LOG_ON_DENIED_VERIFIED_EMAIL_REQUIRED = k_EResultAccountLogonDeniedVerifiedEmailRequired,\n\tRESULT_NO_MATCHING_URL = k_EResultNoMatchingURL,\n\tRESULT_BAD_RESPONSE = k_EResultBadResponse,\n\tRESULT_REQUIRE_PASSWORD_REENTRY = k_EResultRequirePasswordReEntry,\n\tRESULT_VALUE_OUT_OF_RANGE = k_EResultValueOutOfRange,\n\tRESULT_UNEXPECTED_ERROR = k_EResultUnexpectedError,\n\tRESULT_DISABLED = k_EResultDisabled,\n\tRESULT_INVALID_CEG_SUBMISSION = k_EResultInvalidCEGSubmission,\n\tRESULT_RESTRICTED_DEVICE = k_EResultRestrictedDevice,\n\tRESULT_REGION_LOCKED = k_EResultRegionLocked,\n\tRESULT_RATE_LIMIT_EXCEEDED = k_EResultRateLimitExceeded,\n\tRESULT_ACCOUNT_LOGIN_DENIED_NEED_TWO_FACTOR = k_EResultAccountLoginDeniedNeedTwoFactor,\n\tRESULT_ITEM_DELETED = k_EResultItemDeleted,\n\tRESULT_ACCOUNT_LOGIN_DENIED_THROTTLE = k_EResultAccountLoginDeniedThrottle,\n\tRESULT_TWO_FACTOR_CODE_MISMATCH = k_EResultTwoFactorCodeMismatch,\n\tRESULT_TWO_FACTOR_ACTIVATION_CODE_MISMATCH = k_EResultTwoFactorActivationCodeMismatch,\n\tRESULT_ACCOUNT_ASSOCIATED_TO_MULTIPLE_PARTNERS = k_EResultAccountAssociatedToMultiplePartners,\n\tRESULT_NOT_MODIFIED = k_EResultNotModified,\n\tRESULT_NO_MOBILE_DEVICE = k_EResultNoMobileDevice,\n\tRESULT_TIME_NOT_SYNCED = k_EResultTimeNotSynced,\n\tRESULT_SMS_CODE_FAILED = k_EResultSmsCodeFailed,\n\tRESULT_ACCOUNT_LIMIT_EXCEEDED = k_EResultAccountLimitExceeded,\n\tRESULT_ACCOUNT_ACTIVITY_LIMIT_EXCEEDED = k_EResultAccountActivityLimitExceeded,\n\tRESULT_PHONE_ACTIVITY_LIMIT_EXCEEDED = k_EResultPhoneActivityLimitExceeded,\n\tRESULT_REFUND_TO_WALLET = k_EResultRefundToWallet,\n\tRESULT_EMAIL_SEND_FAILURE = k_EResultEmailSendFailure,\n\tRESULT_NOT_SETTLED = k_EResultNotSettled,\n\tRESULT_NEED_CAPTCHA = k_EResultNeedCaptcha,\n\tRESULT_GSLT_DENIED = k_EResultGSLTDenied,\n\tRESULT_GS_OWNER_DENIED = k_EResultGSOwnerDenied,\n\tRESULT_INVALID_ITEM_TYPE = k_EResultInvalidItemType,\n\tRESULT_IP_BANNED = k_EResultIPBanned,\n\tRESULT_GSLT_EXPIRED = k_EResultGSLTExpired,\n\tRESULT_INSUFFICIENT_FUNDS = k_EResultInsufficientFunds,\n\tRESULT_TOO_MANY_PENDING = k_EResultTooManyPending,\n\tRESULT_NO_SITE_LICENSES_FOUND = k_EResultNoSiteLicensesFound,\n\tRESULT_WG_NETWORK_SEND_EXCEEDED = k_EResultWGNetworkSendExceeded,\n\tRESULT_ACCOUNT_NOT_FRIENDS = k_EResultAccountNotFriends,\n\tRESULT_LIMITED_USER_ACCOUNT = k_EResultLimitedUserAccount,\n\tRESULT_CANT_REMOVE_ITEM = k_EResultCantRemoveItem,\n\tRESULT_ACCOUNT_DELETED = k_EResultAccountDeleted,\n\tRESULT_EXISTING_USER_CANCELLED_LICENSE = k_EResultExistingUserCancelledLicense,\n\tRESULT_COMMUNITY_COOLDOWN = k_EResultCommunityCooldown,\n\tRESULT_NO_LAUNCHER_SPECIFIED = k_EResultNoLauncherSpecified,\n\tRESULT_MUST_AGREE_TO_SSA = k_EResultMustAgreeToSSA,\n\tRESULT_LAUNCHER_MIGRATED = k_EResultLauncherMigrated,\n\tRESULT_STEAM_REALM_MISMATCH = k_EResultSteamRealmMismatch,\n\tRESULT_INVALID_SIGNATURE = k_EResultInvalidSignature,\n\tRESULT_PARSE_FAILURE = k_EResultParseFailure,\n\tRESULT_NO_VERIFIED_PHONE = k_EResultNoVerifiedPhone,\n\tRESULT_INSUFFICIENT_BATTERY = k_EResultInsufficientBattery,\n\tRESULT_CHARGER_REQUIRED = k_EResultChargerRequired,\n\tRESULT_CACHED_CREDENTIAL_INVALID = k_EResultCachedCredentialInvalid,\n\tRESULT_PHONE_NUMBER_IS_VOIP = K_EResultPhoneNumberIsVOIP,\n\tRESULT_NOT_SUPPORTED = k_EResultNotSupported,\n\tRESULT_FAMILY_SIZE_LIMIT_EXCEEDED = k_EResultFamilySizeLimitExceeded,\n\tRESULT_OFFLINE_APP_CACHE_INVALID = k_EResultOfflineAppCacheInvalid\n\n};\n\nenum SteamAPIInitResult {\n\tSTEAM_API_INIT_RESULT_OK = k_ESteamAPIInitResult_OK,\n\tSTEAM_API_INIT_RESULT_FAILED_GENERIC = k_ESteamAPIInitResult_FailedGeneric,\n\tSTEAM_API_INIT_RESULT_NO_STEAM_CLIENT = k_ESteamAPIInitResult_NoSteamClient,\n\tSTEAM_API_INIT_RESULT_VERSION_MISMATCH = k_ESteamAPIInitResult_VersionMismatch\n};\n\nenum Universe {\n\t// Found in steamuniverse.h\n\tUNIVERSE_INVALID = k_EUniverseInvalid,\n\tUNIVERSE_PUBLIC = k_EUniversePublic,\n\tUNIVERSE_BETA = k_EUniverseBeta,\n\tUNIVERSE_INTERNAL = k_EUniverseInternal,\n\tUNIVERSE_DEV = k_EUniverseDev,\n\tUNIVERSE_MAX = k_EUniverseMax\n};\n\nenum UserHasLicenseForAppResult {\n\t// Found in steamclientpublic.h\n\tUSER_HAS_LICENSE_RESULT_HAS_LICENSE = k_EUserHasLicenseResultHasLicense,\n\tUSER_HAS_LICENSE_RESULT_DOES_NOT_HAVE_LICENSE = k_EUserHasLicenseResultDoesNotHaveLicense,\n\tUSER_HAS_LICENSE_RESULT_NO_AUTH = k_EUserHasLicenseResultNoAuth\n};\n\nenum VoiceResult {\n\t// Found in steamclientpublic.h\n\tVOICE_RESULT_OK = k_EVoiceResultOK,\n\tVOICE_RESULT_NOT_INITIALIZED = k_EVoiceResultNotInitialized,\n\tVOICE_RESULT_NOT_RECORDING = k_EVoiceResultNotRecording,\n\tVOICE_RESULT_NO_DATE = k_EVoiceResultNoData,\n\tVOICE_RESULT_BUFFER_TOO_SMALL = k_EVoiceResultBufferTooSmall,\n\tVOICE_RESULT_DATA_CORRUPTED = k_EVoiceResultDataCorrupted,\n\tVOICE_RESULT_RESTRICTED = k_EVoiceResultRestricted,\n\tVOICE_RESULT_UNSUPPORTED_CODEC = k_EVoiceResultUnsupportedCodec,\n\tVOICE_RESULT_RECEIVER_OUT_OF_DATE = k_EVoiceResultReceiverOutOfDate,\n\tVOICE_RESULT_RECEIVER_DID_NOT_ANSWER = k_EVoiceResultReceiverDidNotAnswer\n};\n\n// Friends enums\nenum AvatarSizes {\n\tAVATAR_SMALL = 1,\n\tAVATAR_MEDIUM = 2,\n\tAVATAR_LARGE = 3\n};\n\nenum CommunityProfileItemProperty {\n\tPROFILE_ITEM_PROPERTY_IMAGE_SMALL = k_ECommunityProfileItemProperty_ImageSmall,\n\tPROFILE_ITEM_PROPERTY_IMAGE_LARGE = k_ECommunityProfileItemProperty_ImageLarge,\n\tPROFILE_ITEM_PROPERTY_INTERNAL_NAME = k_ECommunityProfileItemProperty_InternalName,\n\tPROFILE_ITEM_PROPERTY_TITLE = k_ECommunityProfileItemProperty_Title,\n\tPROFILE_ITEM_PROPERTY_DESCRIPTION = k_ECommunityProfileItemProperty_Description,\n\tPROFILE_ITEM_PROPERTY_APP_ID = k_ECommunityProfileItemProperty_AppID,\n\tPROFILE_ITEM_PROPERTY_TYPE_ID = k_ECommunityProfileItemProperty_TypeID,\n\tPROFILE_ITEM_PROPERTY_CLASS = k_ECommunityProfileItemProperty_Class,\n\tPROFILE_ITEM_PROPERTY_MOVIE_WEBM = k_ECommunityProfileItemProperty_MovieWebM,\n\tPROFILE_ITEM_PROPERTY_MOVIE_MP4 = k_ECommunityProfileItemProperty_MovieMP4,\n\tPROFILE_ITEM_PROPERTY_MOVIE_WEBM_SMALL = k_ECommunityProfileItemProperty_MovieWebMSmall,\n\tPROFILE_ITEM_PROPERTY_MOVIE_MP4_SMALL = k_ECommunityProfileItemProperty_MovieMP4Small\n};\n\nenum CommunityProfileItemType {\n\tPROFILE_ITEM_TYPE_ANIMATED_AVATAR = k_ECommunityProfileItemType_AnimatedAvatar,\n\tPROFILE_ITEM_TYPE_AVATAR_FRAME = k_ECommunityProfileItemType_AvatarFrame,\n\tPROFILE_ITEM_TYPE_PROFILE_MODIFIER = k_ECommunityProfileItemType_ProfileModifier,\n\tPROFILE_ITEM_TYPE_PROFILE_BACKGROUND = k_ECommunityProfileItemType_ProfileBackground,\n\tPROFILE_ITEM_TYPE_MINI_PROFILE_BACKGROUND = k_ECommunityProfileItemType_MiniProfileBackground\n};\n\nenum FriendFlags {\n\tFRIEND_FLAG_NONE = k_EFriendFlagNone,\n\tFRIEND_FLAG_BLOCKED = k_EFriendFlagBlocked,\n\tFRIEND_FLAG_FRIENDSHIP_REQUESTED = k_EFriendFlagFriendshipRequested,\n\tFRIEND_FLAG_IMMEDIATE = k_EFriendFlagImmediate,\n\tFRIEND_FLAG_CLAN_MEMBER = k_EFriendFlagClanMember,\n\tFRIEND_FLAG_ON_GAME_SERVER = k_EFriendFlagOnGameServer,\n\t//\t\t\tFRIEND_FLAG_HAS_PLAYED_WITH = k_EFriendFlagHasPlayedWith,\n\t//\t\t\tFRIEND_FLAG_FRIEND_OF_FRIEND = k_EFriendFlagFriendOfFriend,\n\tFRIEND_FLAG_REQUESTING_FRIENDSHIP = k_EFriendFlagRequestingFriendship,\n\tFRIEND_FLAG_REQUESTING_INFO = k_EFriendFlagRequestingInfo,\n\tFRIEND_FLAG_IGNORED = k_EFriendFlagIgnored,\n\tFRIEND_FLAG_IGNORED_FRIEND = k_EFriendFlagIgnoredFriend,\n\t//\t\t\tFRIEND_FLAG_SUGGESTED = k_EFriendFlagSuggested,\n\tFRIEND_FLAG_CHAT_MEMBER = k_EFriendFlagChatMember,\n\tFRIEND_FLAG_ALL = k_EFriendFlagAll\n};\n\nenum FriendRelationship {\n\tFRIEND_RELATION_NONE = k_EFriendRelationshipNone,\n\tFRIEND_RELATION_BLOCKED = k_EFriendRelationshipBlocked,\n\tFRIEND_RELATION_REQUEST_RECIPIENT = k_EFriendRelationshipRequestRecipient,\n\tFRIEND_RELATION_FRIEND = k_EFriendRelationshipFriend,\n\tFRIEND_RELATION_REQUEST_INITIATOR = k_EFriendRelationshipRequestInitiator,\n\tFRIEND_RELATION_IGNORED = k_EFriendRelationshipIgnored,\n\tFRIEND_RELATION_IGNORED_FRIEND = k_EFriendRelationshipIgnoredFriend,\n\tFRIEND_RELATION_SUGGESTED = k_EFriendRelationshipSuggested_DEPRECATED,\n\tFRIEND_RELATION_MAX = k_EFriendRelationshipMax\n};\n\nenum OverlayToStoreFlag {\n\tOVERLAY_TO_STORE_FLAG_NONE = k_EOverlayToStoreFlag_None,\n\tOVERLAY_TO_STORE_FLAG_ADD_TO_CART = k_EOverlayToStoreFlag_AddToCart,\n\tOVERLAY_TO_STORE_FLAG_AND_TO_CART_AND_SHOW = k_EOverlayToStoreFlag_AddToCartAndShow\n};\n\nenum OverlayToWebPageMode {\n\tOVERLAY_TO_WEB_PAGE_MODE_DEFAULT = k_EActivateGameOverlayToWebPageMode_Default,\n\tOVERLAY_TO_WEB_PAGE_MODE_MODAL = k_EActivateGameOverlayToWebPageMode_Modal\n};\n\nenum PersonaChange {\n\tPERSONA_CHANGE_NAME = k_EPersonaChangeName,\n\tPERSONA_CHANGE_STATUS = k_EPersonaChangeStatus,\n\tPERSONA_CHANGE_COME_ONLINE = k_EPersonaChangeComeOnline,\n\tPERSONA_CHANGE_GONE_OFFLINE = k_EPersonaChangeGoneOffline,\n\tPERSONA_CHANGE_GAME_PLAYED = k_EPersonaChangeGamePlayed,\n\tPERSONA_CHANGE_GAME_SERVER = k_EPersonaChangeGameServer,\n\tPERSONA_CHANGE_AVATAR = k_EPersonaChangeAvatar,\n\tPERSONA_CHANGE_JOINED_SOURCE = k_EPersonaChangeJoinedSource,\n\tPERSONA_CHANGE_LEFT_SOURCE = k_EPersonaChangeLeftSource,\n\tPERSONA_CHANGE_RELATIONSHIP_CHANGED = k_EPersonaChangeRelationshipChanged,\n\tPERSONA_CHANGE_NAME_FIRST_SET = k_EPersonaChangeNameFirstSet,\n\tPERSONA_CHANGE_FACEBOOK_INFO = k_EPersonaChangeBroadcast,\n\tPERSONA_CHANGE_NICKNAME = k_EPersonaChangeNickname,\n\tPERSONA_CHANGE_STEAM_LEVEL = k_EPersonaChangeSteamLevel,\n\tPERSONA_CHANGE_RICH_PRESENCE = k_EPersonaChangeRichPresence\n};\n\nenum PersonaState {\n\tPERSONA_STATE_OFFLINE = k_EPersonaStateOffline,\n\tPERSONA_STATE_ONLINE = k_EPersonaStateOnline,\n\tPERSONA_STATE_BUSY = k_EPersonaStateBusy,\n\tPERSONA_STATE_AWAY = k_EPersonaStateAway,\n\tPERSONA_STATE_SNOOZE = k_EPersonaStateSnooze,\n\tPERSONA_STATE_LOOKING_TO_TRADE = k_EPersonaStateLookingToTrade,\n\tPERSONA_STATE_LOOKING_TO_PLAY = k_EPersonaStateLookingToPlay,\n\tPERSONA_STATE_INVISIBLE = k_EPersonaStateInvisible,\n\tPERSONA_STATE_MAX = k_EPersonaStateMax\n};\n\nenum UserRestriction {\n\tUSER_RESTRICTION_NONE = k_nUserRestrictionNone,\n\tUSER_RESTRICTION_UNKNOWN = k_nUserRestrictionUnknown,\n\tUSER_RESTRICTION_ANY_CHAT = k_nUserRestrictionAnyChat,\n\tUSER_RESTRICTION_VOICE_CHAT = k_nUserRestrictionVoiceChat,\n\tUSER_RESTRICTION_GROUP_CHAT = k_nUserRestrictionGroupChat,\n\tUSER_RESTRICTION_RATING = k_nUserRestrictionRating,\n\tUSER_RESTRICTION_GAME_INVITES = k_nUserRestrictionGameInvites,\n\tUSER_RESTRICTION_TRADING = k_nUserRestrictionTrading\n};\n\n\n// Game Search enums\nenum GameSearchErrorCode {\n\t// Found in steamclientpublic.h\n\tGAME_SEARCH_ERROR_CODE_OK = k_EGameSearchErrorCode_OK,\n\tGAME_SEARCH_ERROR_CODE_SEARCH_AREADY_IN_PROGRESS = k_EGameSearchErrorCode_Failed_Search_Already_In_Progress,\n\tGAME_SEARCH_ERROR_CODE_NO_SEARCH_IN_PROGRESS = k_EGameSearchErrorCode_Failed_No_Search_In_Progress,\n\tGAME_SEARCH_ERROR_CODE_NOT_LOBBY_LEADER = k_EGameSearchErrorCode_Failed_Not_Lobby_Leader,\n\tGAME_SEARCH_ERROR_CODE_NO_HOST_AVAILABLE = k_EGameSearchErrorCode_Failed_No_Host_Available,\n\tGAME_SEARCH_ERROR_CODE_SEARCH_PARAMS_INVALID = k_EGameSearchErrorCode_Failed_Search_Params_Invalid,\n\tGAME_SEARCH_ERROR_CODE_OFFLINE = k_EGameSearchErrorCode_Failed_Offline,\n\tGAME_SEARCH_ERROR_CODE_NOT_AUTHORIZED = k_EGameSearchErrorCode_Failed_NotAuthorized,\n\tGAME_SEARCH_ERROR_CODE_UNKNOWN_ERROR = k_EGameSearchErrorCode_Failed_Unknown_Error\n};\n\nenum PlayerResult {\n\t// Found in steamclientpublic.h\n\tPLAYER_RESULT_FAILED_TO_CONNECT = k_EPlayerResultFailedToConnect,\n\tPLAYER_RESULT_ABANDONED = k_EPlayerResultAbandoned,\n\tPLAYER_RESULT_KICKED = k_EPlayerResultKicked,\n\tPLAYER_RESULT_INCOMPLETE = k_EPlayerResultIncomplete,\n\tPLAYER_RESULT_COMPLETED = k_EPlayerResultCompleted\n};\n\n\n// HTMLSurface enums\nenum HTMLKeyModifiers {\n\tHTML_KEY_MODIFIER_NONE = ISteamHTMLSurface::k_eHTMLKeyModifier_None,\n\tHTML_KEY_MODIFIER_ALT_DOWN = ISteamHTMLSurface::k_eHTMLKeyModifier_AltDown,\n\tHTML_KEY_MODIFIER_CTRL_DOWN = ISteamHTMLSurface::k_eHTMLKeyModifier_CtrlDown,\n\tHTML_KEY_MODIFIER_SHIFT_DOWN = ISteamHTMLSurface::k_eHTMLKeyModifier_ShiftDown\n};\n\nenum HTMLMouseButton {\n\tHTML_MOUSE_BUTTON_LEFT = ISteamHTMLSurface::eHTMLMouseButton_Left,\n\tHTML_MOUSE_BUTTON_RIGHT = ISteamHTMLSurface::eHTMLMouseButton_Right,\n\tHTML_MOUSE_BUTTON_MIDDLE = ISteamHTMLSurface::eHTMLMouseButton_Middle\n};\n\nenum MouseCursor {\n\tDC_USER = ISteamHTMLSurface::dc_user,\n\tDC_NONE = ISteamHTMLSurface::dc_none,\n\tDC_ARROW = ISteamHTMLSurface::dc_arrow,\n\tDC_IBEAM = ISteamHTMLSurface::dc_ibeam,\n\tDC_HOUR_GLASS = ISteamHTMLSurface::dc_hourglass,\n\tDC_WAIT_ARROW = ISteamHTMLSurface::dc_waitarrow,\n\tDC_CROSSHAIR = ISteamHTMLSurface::dc_crosshair,\n\tDC_UP = ISteamHTMLSurface::dc_up,\n\tDC_SIZE_NW = ISteamHTMLSurface::dc_sizenw,\n\tDC_SIZE_SE = ISteamHTMLSurface::dc_sizese,\n\tDC_SIZE_NE = ISteamHTMLSurface::dc_sizene,\n\tDC_SIZE_SW = ISteamHTMLSurface::dc_sizesw,\n\tDC_SIZE_W = ISteamHTMLSurface::dc_sizew,\n\tDC_SIZE_E = ISteamHTMLSurface::dc_sizee,\n\tDC_SIZE_N = ISteamHTMLSurface::dc_sizen,\n\tDC_SIZE_S = ISteamHTMLSurface::dc_sizes,\n\tDC_SIZE_WE = ISteamHTMLSurface::dc_sizewe,\n\tDC_SIZE_NS = ISteamHTMLSurface::dc_sizens,\n\tDC_SIZE_ALL = ISteamHTMLSurface::dc_sizeall,\n\tDC_NO = ISteamHTMLSurface::dc_no,\n\tDC_HAND = ISteamHTMLSurface::dc_hand,\n\tDC_BLANK = ISteamHTMLSurface::dc_blank,\n\tDC_MIDDLE_PAN = ISteamHTMLSurface::dc_middle_pan,\n\tDC_NORTH_PAN = ISteamHTMLSurface::dc_north_pan,\n\tDC_NORTH_EAST_PAN = ISteamHTMLSurface::dc_north_east_pan,\n\tDC_EAST_PAN = ISteamHTMLSurface::dc_east_pan,\n\tDC_SOUTH_EAST_PAN = ISteamHTMLSurface::dc_south_east_pan,\n\tDC_SOUTH_PAN = ISteamHTMLSurface::dc_south_pan,\n\tDC_SOUTH_WEST_PAN = ISteamHTMLSurface::dc_south_west_pan,\n\tDC_WEST_PAN = ISteamHTMLSurface::dc_west_pan,\n\tDC_NORTH_WEST_PAN = ISteamHTMLSurface::dc_north_west_pan,\n\tDC_ALIAS = ISteamHTMLSurface::dc_alias,\n\tDC_CELL = ISteamHTMLSurface::dc_cell,\n\tDC_COL_RESIZE = ISteamHTMLSurface::dc_colresize,\n\tDC_COPY_CUR = ISteamHTMLSurface::dc_copycur,\n\tDC_VERTICAL_TEXT = ISteamHTMLSurface::dc_verticaltext,\n\tDC_ROW_RESIZE = ISteamHTMLSurface::dc_rowresize,\n\tDC_ZOOM_IN = ISteamHTMLSurface::dc_zoomin,\n\tDC_ZOOM_OUT = ISteamHTMLSurface::dc_zoomout,\n\tDC_HELP = ISteamHTMLSurface::dc_help,\n\tDC_CUSTOM = ISteamHTMLSurface::dc_custom,\n\tDC_LAST = ISteamHTMLSurface::dc_last\n};\n\n\n// HTTP enums\nenum HTTPMethod {\n\tHTTP_METHOD_INVALID = k_EHTTPMethodInvalid,\n\tHTTP_METHOD_GET = k_EHTTPMethodGET,\n\tHTTP_METHOD_HEAD = k_EHTTPMethodHEAD,\n\tHTTP_METHOD_POST = k_EHTTPMethodPOST,\n\tHTTP_METHOD_PUT = k_EHTTPMethodPUT,\n\tHTTP_METHOD_DELETE = k_EHTTPMethodDELETE,\n\tHTTP_METHOD_OPTIONS = k_EHTTPMethodOPTIONS,\n\tHTTP_METHOD_PATCH = k_EHTTPMethodPATCH\n};\n\nenum HTTPStatusCode {\n\tHTTP_STATUS_CODE_INVALID = k_EHTTPStatusCodeInvalid,\n\tHTTP_STATUS_CODE_100_CONTINUE = k_EHTTPStatusCode100Continue,\n\tHTTP_STATUS_CODE_101_SWITCHING_PROTOCOLS = k_EHTTPStatusCode101SwitchingProtocols,\n\tHTTP_STATUS_CODE_200_OK = k_EHTTPStatusCode200OK,\n\tHTTP_STATUS_CODE_201_CREATED = k_EHTTPStatusCode201Created,\n\tHTTP_STATUS_CODE_202_ACCEPTED = k_EHTTPStatusCode202Accepted,\n\tHTTP_STATUS_CODE_203_NON_AUTHORITATIVE = k_EHTTPStatusCode203NonAuthoritative,\n\tHTTP_STATUS_CODE_204_NO_CONTENT = k_EHTTPStatusCode204NoContent,\n\tHTTP_STATUS_CODE_205_RESET_CONTENT = k_EHTTPStatusCode205ResetContent,\n\tHTTP_STATUS_CODE_206_PARTIAL_CONTENT = k_EHTTPStatusCode206PartialContent,\n\tHTTP_STATUS_CODE_300_MULTIPLE_CHOICES = k_EHTTPStatusCode300MultipleChoices,\n\tHTTP_STATUS_CODE_301_MOVED_PERMANENTLY = k_EHTTPStatusCode301MovedPermanently,\n\tHTTP_STATUS_CODE_302_FOUND = k_EHTTPStatusCode302Found,\n\tHTTP_STATUS_CODE_303_SEE_OTHER = k_EHTTPStatusCode303SeeOther,\n\tHTTP_STATUS_CODE_304_NOT_MODIFIED = k_EHTTPStatusCode304NotModified,\n\tHTTP_STATUS_CODE_305_USE_PROXY = k_EHTTPStatusCode305UseProxy,\n\tHTTP_STATUS_CODE_307_TEMPORARY_REDIRECT = k_EHTTPStatusCode307TemporaryRedirect,\n\tHTTP_STATUS_CODE_308_PERMANENT_REDIRECT = k_EHTTPStatusCode308PermanentRedirect,\n\tHTTP_STATUS_CODE_400_BAD_REQUEST = k_EHTTPStatusCode400BadRequest,\n\tHTTP_STATUS_CODE_401_UNAUTHORIZED = k_EHTTPStatusCode401Unauthorized,\n\tHTTP_STATUS_CODE_402_PAYMENT_REQUIRED = k_EHTTPStatusCode402PaymentRequired,\n\tHTTP_STATUS_CODE_403_FORBIDDEN = k_EHTTPStatusCode403Forbidden,\n\tHTTP_STATUS_CODE_404_NOT_FOUND = k_EHTTPStatusCode404NotFound,\n\tHTTP_STATUS_CODE_405_METHOD_NOT_ALLOWED = k_EHTTPStatusCode405MethodNotAllowed,\n\tHTTP_STATUS_CODE_406_NOT_ACCEPTABLE = k_EHTTPStatusCode406NotAcceptable,\n\tHTTP_STATUS_CODE_407_PROXY_AUTH_REQUIRED = k_EHTTPStatusCode407ProxyAuthRequired,\n\tHTTP_STATUS_CODE_408_REQUEST_TIMEOUT = k_EHTTPStatusCode408RequestTimeout,\n\tHTTP_STATUS_CODE_409_CONFLICT = k_EHTTPStatusCode409Conflict,\n\tHTTP_STATUS_CODE_410_GONE = k_EHTTPStatusCode410Gone,\n\tHTTP_STATUS_CODE_411_LENGTH_REQUIRED = k_EHTTPStatusCode411LengthRequired,\n\tHTTP_STATUS_CODE_412_PRECONDITION_FAILED = k_EHTTPStatusCode412PreconditionFailed,\n\tHTTP_STATUS_CODE_413_REQUEST_ENTITY_TOO_LARGE = k_EHTTPStatusCode413RequestEntityTooLarge,\n\tHTTP_STATUS_CODE_414_REQUEST_URI_TOO_LONG = k_EHTTPStatusCode414RequestURITooLong,\n\tHTTP_STATUS_CODE_415_UNSUPPORTED_MEDIA_TYPE = k_EHTTPStatusCode415UnsupportedMediaType,\n\tHTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE = k_EHTTPStatusCode416RequestedRangeNotSatisfiable,\n\tHTTP_STATUS_CODE_417_EXPECTATION_FAILED = k_EHTTPStatusCode417ExpectationFailed,\n\tHTTP_STATUS_CODE_4XX_UNKNOWN = k_EHTTPStatusCode4xxUnknown,\n\tHTTP_STATUS_CODE_429_TOO_MANY_REQUESTS = k_EHTTPStatusCode429TooManyRequests,\n\tHTTP_STATUS_CODE_444_CONNECTION_CLOSED = k_EHTTPStatusCode444ConnectionClosed,\n\tHTTP_STATUS_CODE_500_INTERNAL_SERVER_ERROR = k_EHTTPStatusCode500InternalServerError,\n\tHTTP_STATUS_CODE_501_NOT_IMPLEMENTED = k_EHTTPStatusCode501NotImplemented,\n\tHTTP_STATUS_CODE_502_BAD_GATEWAY = k_EHTTPStatusCode502BadGateway,\n\tHTTP_STATUS_CODE_503_SERVICE_UNAVAILABLE = k_EHTTPStatusCode503ServiceUnavailable,\n\tHTTP_STATUS_CODE_504_GATEWAY_TIMEOUT = k_EHTTPStatusCode504GatewayTimeout,\n\tHTTP_STATUS_CODE_505_HTTP_VERSION_NOT_SUPPORTED = k_EHTTPStatusCode505HTTPVersionNotSupported,\n\tHTTP_STATUS_CODE_5XX_UNKNOWN = k_EHTTPStatusCode5xxUnknown\n};\n\n\n// Input enums\nenum ControllerHapticLocation {\n\tCONTROLLER_HAPTIC_LOCATION_LEFT = k_EControllerHapticLocation_Left,\n\tCONTROLLER_HAPTIC_LOCATION_RIGHT = k_EControllerHapticLocation_Right,\n\tCONTROLLER_HAPTIC_LOCATION_BOTH = k_EControllerHapticLocation_Both\n};\n\nenum ControllerHapticType {\n\tCONTROLLER_HAPTIC_TYPE_OFF = k_EControllerHapticType_Off,\n\tCONTROLLER_HAPTIC_TYPE_TICK = k_EControllerHapticType_Tick,\n\tCONTROLLER_HAPTIC_TYPE_CLICK = k_EControllerHapticType_Click\n};\n\nenum ControllerPad {\n\tSTEAM_CONTROLLER_PAD_LEFT = k_ESteamControllerPad_Left,\n\tSTEAM_CONTROLLER_PAD_RIGHT = k_ESteamControllerPad_Right\n};\n\nenum InputActionEventType {\n\tINPUT_ACTION_EVENT_TYPE_DIGITAL_ACTION = ESteamInputActionEventType_DigitalAction,\n\tINPUT_ACTION_EVENT_TYPE_ANALOG_ACTION = ESteamInputActionEventType_AnalogAction\n};\n\nenum InputActionOrigin {\n\tINPUT_ACTION_ORIGIN_NONE = k_EInputActionOrigin_None,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_A = k_EInputActionOrigin_SteamController_A,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_B = k_EInputActionOrigin_SteamController_B,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_X = k_EInputActionOrigin_SteamController_X,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_Y = k_EInputActionOrigin_SteamController_Y,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTBUMPER = k_EInputActionOrigin_SteamController_LeftBumper,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTBUMPER = k_EInputActionOrigin_SteamController_RightBumper,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTGRIP = k_EInputActionOrigin_SteamController_LeftGrip,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTGRIP = k_EInputActionOrigin_SteamController_RightGrip,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_START = k_EInputActionOrigin_SteamController_Start,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_BACK = k_EInputActionOrigin_SteamController_Back,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_TOUCH = k_EInputActionOrigin_SteamController_LeftPad_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_SWIPE = k_EInputActionOrigin_SteamController_LeftPad_Swipe,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_CLICK = k_EInputActionOrigin_SteamController_LeftPad_Click,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_DPADNORTH = k_EInputActionOrigin_SteamController_LeftPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_DPADSOUTH = k_EInputActionOrigin_SteamController_LeftPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_DPADWEST = k_EInputActionOrigin_SteamController_LeftPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTPAD_DPADEAST = k_EInputActionOrigin_SteamController_LeftPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_TOUCH = k_EInputActionOrigin_SteamController_RightPad_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_SWIPE = k_EInputActionOrigin_SteamController_RightPad_Swipe,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_CLICK = k_EInputActionOrigin_SteamController_RightPad_Click,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_DPADNORTH = k_EInputActionOrigin_SteamController_RightPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_DPADSOUTH = k_EInputActionOrigin_SteamController_RightPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_DPADWEST = k_EInputActionOrigin_SteamController_RightPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTPAD_DPADEAST = k_EInputActionOrigin_SteamController_RightPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTTRIGGER_PULL = k_EInputActionOrigin_SteamController_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTTRIGGER_CLICK = k_EInputActionOrigin_SteamController_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTTRIGGER_PULL = k_EInputActionOrigin_SteamController_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_SteamController_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_MOVE = k_EInputActionOrigin_SteamController_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_CLICK = k_EInputActionOrigin_SteamController_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_SteamController_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_SteamController_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_DPADWEST = k_EInputActionOrigin_SteamController_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_LEFTSTICK_DPADEAST = k_EInputActionOrigin_SteamController_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_GYRO_MOVE = k_EInputActionOrigin_SteamController_Gyro_Move,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_GYRO_PITCH = k_EInputActionOrigin_SteamController_Gyro_Pitch,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_GYRO_YAW = k_EInputActionOrigin_SteamController_Gyro_Yaw,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_GYRO_ROLL = k_EInputActionOrigin_SteamController_Gyro_Roll,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED0 = k_EInputActionOrigin_SteamController_Reserved0,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED1 = k_EInputActionOrigin_SteamController_Reserved1,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED2 = k_EInputActionOrigin_SteamController_Reserved2,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED3 = k_EInputActionOrigin_SteamController_Reserved3,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED4 = k_EInputActionOrigin_SteamController_Reserved4,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED5 = k_EInputActionOrigin_SteamController_Reserved5,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED6 = k_EInputActionOrigin_SteamController_Reserved6,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED7 = k_EInputActionOrigin_SteamController_Reserved7,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED8 = k_EInputActionOrigin_SteamController_Reserved8,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED9 = k_EInputActionOrigin_SteamController_Reserved9,\n\tINPUT_ACTION_ORIGIN_STEAMCONTROLLER_RESERVED10 = k_EInputActionOrigin_SteamController_Reserved10,\n\tINPUT_ACTION_ORIGIN_PS4_X = k_EInputActionOrigin_PS4_X,\n\tINPUT_ACTION_ORIGIN_PS4_CIRCLE = k_EInputActionOrigin_PS4_Circle,\n\tINPUT_ACTION_ORIGIN_PS4_TRIANGLE = k_EInputActionOrigin_PS4_Triangle,\n\tINPUT_ACTION_ORIGIN_PS4_SQUARE = k_EInputActionOrigin_PS4_Square,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTBUMPER = k_EInputActionOrigin_PS4_LeftBumper,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTBUMPER = k_EInputActionOrigin_PS4_RightBumper,\n\tINPUT_ACTION_ORIGIN_PS4_OPTIONS = k_EInputActionOrigin_PS4_Options,\n\tINPUT_ACTION_ORIGIN_PS4_SHARE = k_EInputActionOrigin_PS4_Share,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_TOUCH = k_EInputActionOrigin_PS4_LeftPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_SWIPE = k_EInputActionOrigin_PS4_LeftPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_CLICK = k_EInputActionOrigin_PS4_LeftPad_Click,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_DPADNORTH = k_EInputActionOrigin_PS4_LeftPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_DPADSOUTH = k_EInputActionOrigin_PS4_LeftPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_DPADWEST = k_EInputActionOrigin_PS4_LeftPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTPAD_DPADEAST = k_EInputActionOrigin_PS4_LeftPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_TOUCH = k_EInputActionOrigin_PS4_RightPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_SWIPE = k_EInputActionOrigin_PS4_RightPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_CLICK = k_EInputActionOrigin_PS4_RightPad_Click,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_DPADNORTH = k_EInputActionOrigin_PS4_RightPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_DPADSOUTH = k_EInputActionOrigin_PS4_RightPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_DPADWEST = k_EInputActionOrigin_PS4_RightPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTPAD_DPADEAST = k_EInputActionOrigin_PS4_RightPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_TOUCH = k_EInputActionOrigin_PS4_CenterPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_SWIPE = k_EInputActionOrigin_PS4_CenterPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_CLICK = k_EInputActionOrigin_PS4_CenterPad_Click,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_DPADNORTH = k_EInputActionOrigin_PS4_CenterPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_DPADSOUTH = k_EInputActionOrigin_PS4_CenterPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_DPADWEST = k_EInputActionOrigin_PS4_CenterPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS4_CENTERPAD_DPADEAST = k_EInputActionOrigin_PS4_CenterPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTTRIGGER_PULL = k_EInputActionOrigin_PS4_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTTRIGGER_CLICK = k_EInputActionOrigin_PS4_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTTRIGGER_PULL = k_EInputActionOrigin_PS4_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_PS4_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_MOVE = k_EInputActionOrigin_PS4_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_CLICK = k_EInputActionOrigin_PS4_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_PS4_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_PS4_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_DPADWEST = k_EInputActionOrigin_PS4_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS4_LEFTSTICK_DPADEAST = k_EInputActionOrigin_PS4_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_MOVE = k_EInputActionOrigin_PS4_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_CLICK = k_EInputActionOrigin_PS4_RightStick_Click,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_PS4_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_PS4_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_PS4_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS4_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_PS4_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS4_DPAD_NORTH = k_EInputActionOrigin_PS4_DPad_North,\n\tINPUT_ACTION_ORIGIN_PS4_DPAD_SOUTH = k_EInputActionOrigin_PS4_DPad_South,\n\tINPUT_ACTION_ORIGIN_PS4_DPAD_WEST = k_EInputActionOrigin_PS4_DPad_West,\n\tINPUT_ACTION_ORIGIN_PS4_DPAD_EAST = k_EInputActionOrigin_PS4_DPad_East,\n\tINPUT_ACTION_ORIGIN_PS4_GYRO_MOVE = k_EInputActionOrigin_PS4_Gyro_Move,\n\tINPUT_ACTION_ORIGIN_PS4_GYRO_PITCH = k_EInputActionOrigin_PS4_Gyro_Pitch,\n\tINPUT_ACTION_ORIGIN_PS4_GYRO_YAW = k_EInputActionOrigin_PS4_Gyro_Yaw,\n\tINPUT_ACTION_ORIGIN_PS4_GYRO_ROLL = k_EInputActionOrigin_PS4_Gyro_Roll,\n\tINPUT_ACTION_ORIGIN_PS4_DPAD_MOVE = k_EInputActionOrigin_PS4_DPad_Move,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED1 = k_EInputActionOrigin_PS4_Reserved1,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED2 = k_EInputActionOrigin_PS4_Reserved2,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED3 = k_EInputActionOrigin_PS4_Reserved3,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED4 = k_EInputActionOrigin_PS4_Reserved4,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED5 = k_EInputActionOrigin_PS4_Reserved5,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED6 = k_EInputActionOrigin_PS4_Reserved6,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED7 = k_EInputActionOrigin_PS4_Reserved7,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED8 = k_EInputActionOrigin_PS4_Reserved8,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED9 = k_EInputActionOrigin_PS4_Reserved9,\n\tINPUT_ACTION_ORIGIN_PS4_RESERVED10 = k_EInputActionOrigin_PS4_Reserved10,\n\tINPUT_ACTION_ORIGIN_XBOXONE_A = k_EInputActionOrigin_XBoxOne_A,\n\tINPUT_ACTION_ORIGIN_XBOXONE_B = k_EInputActionOrigin_XBoxOne_B,\n\tINPUT_ACTION_ORIGIN_XBOXONE_X = k_EInputActionOrigin_XBoxOne_X,\n\tINPUT_ACTION_ORIGIN_XBOXONE_Y = k_EInputActionOrigin_XBoxOne_Y,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTBUMPER = k_EInputActionOrigin_XBoxOne_LeftBumper,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTBUMPER = k_EInputActionOrigin_XBoxOne_RightBumper,\n\tINPUT_ACTION_ORIGIN_XBOXONE_MENU = k_EInputActionOrigin_XBoxOne_Menu,\n\tINPUT_ACTION_ORIGIN_XBOXONE_VIEW = k_EInputActionOrigin_XBoxOne_View,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTTRIGGER_PULL = k_EInputActionOrigin_XBoxOne_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTTRIGGER_CLICK = k_EInputActionOrigin_XBoxOne_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTTRIGGER_PULL = k_EInputActionOrigin_XBoxOne_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_XBoxOne_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_MOVE = k_EInputActionOrigin_XBoxOne_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_CLICK = k_EInputActionOrigin_XBoxOne_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_XBoxOne_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_XBoxOne_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_DPADWEST = k_EInputActionOrigin_XBoxOne_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTSTICK_DPADEAST = k_EInputActionOrigin_XBoxOne_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_MOVE = k_EInputActionOrigin_XBoxOne_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_CLICK = k_EInputActionOrigin_XBoxOne_RightStick_Click,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_XBoxOne_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_XBoxOne_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_XBoxOne_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_XBoxOne_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_XBOXONE_DPAD_NORTH = k_EInputActionOrigin_XBoxOne_DPad_North,\n\tINPUT_ACTION_ORIGIN_XBOXONE_DPAD_SOUTH = k_EInputActionOrigin_XBoxOne_DPad_South,\n\tINPUT_ACTION_ORIGIN_XBOXONE_DPAD_WEST = k_EInputActionOrigin_XBoxOne_DPad_West,\n\tINPUT_ACTION_ORIGIN_XBOXONE_DPAD_EAST = k_EInputActionOrigin_XBoxOne_DPad_East,\n\tINPUT_ACTION_ORIGIN_XBOXONE_DPAD_MOVE = k_EInputActionOrigin_XBoxOne_DPad_Move,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTGRIP_LOWER = k_EInputActionOrigin_XBoxOne_LeftGrip_Lower,\n\tINPUT_ACTION_ORIGIN_XBOXONE_LEFTGRIP_UPPER = k_EInputActionOrigin_XBoxOne_LeftGrip_Upper,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTGRIP_LOWER = k_EInputActionOrigin_XBoxOne_RightGrip_Lower,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RIGHTGRIP_UPPER = k_EInputActionOrigin_XBoxOne_RightGrip_Upper,\n\tINPUT_ACTION_ORIGIN_XBOXONE_SHARE = k_EInputActionOrigin_XBoxOne_Share,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RESERVED6 = k_EInputActionOrigin_XBoxOne_Reserved6,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RESERVED7 = k_EInputActionOrigin_XBoxOne_Reserved7,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RESERVED8 = k_EInputActionOrigin_XBoxOne_Reserved8,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RESERVED9 = k_EInputActionOrigin_XBoxOne_Reserved9,\n\tINPUT_ACTION_ORIGIN_XBOXONE_RESERVED10 = k_EInputActionOrigin_XBoxOne_Reserved10,\n\tINPUT_ACTION_ORIGIN_XBOX360_A = k_EInputActionOrigin_XBox360_A,\n\tINPUT_ACTION_ORIGIN_XBOX360_B = k_EInputActionOrigin_XBox360_B,\n\tINPUT_ACTION_ORIGIN_XBOX360_X = k_EInputActionOrigin_XBox360_X,\n\tINPUT_ACTION_ORIGIN_XBOX360_Y = k_EInputActionOrigin_XBox360_Y,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTBUMPER = k_EInputActionOrigin_XBox360_LeftBumper,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTBUMPER = k_EInputActionOrigin_XBox360_RightBumper,\n\tINPUT_ACTION_ORIGIN_XBOX360_START = k_EInputActionOrigin_XBox360_Start,\n\tINPUT_ACTION_ORIGIN_XBOX360_BACK = k_EInputActionOrigin_XBox360_Back,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTTRIGGER_PULL = k_EInputActionOrigin_XBox360_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTTRIGGER_CLICK = k_EInputActionOrigin_XBox360_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTTRIGGER_PULL = k_EInputActionOrigin_XBox360_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_XBox360_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_MOVE = k_EInputActionOrigin_XBox360_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_CLICK = k_EInputActionOrigin_XBox360_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_XBox360_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_XBox360_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_DPADWEST = k_EInputActionOrigin_XBox360_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_XBOX360_LEFTSTICK_DPADEAST = k_EInputActionOrigin_XBox360_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_MOVE = k_EInputActionOrigin_XBox360_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_CLICK = k_EInputActionOrigin_XBox360_RightStick_Click,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_XBox360_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_XBox360_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_XBox360_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_XBOX360_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_XBox360_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_XBOX360_DPAD_NORTH = k_EInputActionOrigin_XBox360_DPad_North,\n\tINPUT_ACTION_ORIGIN_XBOX360_DPAD_SOUTH = k_EInputActionOrigin_XBox360_DPad_South,\n\tINPUT_ACTION_ORIGIN_XBOX360_DPAD_WEST = k_EInputActionOrigin_XBox360_DPad_West,\n\tINPUT_ACTION_ORIGIN_XBOX360_DPAD_EAST = k_EInputActionOrigin_XBox360_DPad_East,\n\tINPUT_ACTION_ORIGIN_XBOX360_DPAD_MOVE = k_EInputActionOrigin_XBox360_DPad_Move,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED1 = k_EInputActionOrigin_XBox360_Reserved1,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED2 = k_EInputActionOrigin_XBox360_Reserved2,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED3 = k_EInputActionOrigin_XBox360_Reserved3,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED4 = k_EInputActionOrigin_XBox360_Reserved4,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED5 = k_EInputActionOrigin_XBox360_Reserved5,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED6 = k_EInputActionOrigin_XBox360_Reserved6,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED7 = k_EInputActionOrigin_XBox360_Reserved7,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED8 = k_EInputActionOrigin_XBox360_Reserved8,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED9 = k_EInputActionOrigin_XBox360_Reserved9,\n\tINPUT_ACTION_ORIGIN_XBOX360_RESERVED10 = k_EInputActionOrigin_XBox360_Reserved10,\n\tINPUT_ACTION_ORIGIN_SWITCH_A = k_EInputActionOrigin_Switch_A,\n\tINPUT_ACTION_ORIGIN_SWITCH_B = k_EInputActionOrigin_Switch_B,\n\tINPUT_ACTION_ORIGIN_SWITCH_X = k_EInputActionOrigin_Switch_X,\n\tINPUT_ACTION_ORIGIN_SWITCH_Y = k_EInputActionOrigin_Switch_Y,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTBUMPER = k_EInputActionOrigin_Switch_LeftBumper,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTBUMPER = k_EInputActionOrigin_Switch_RightBumper,\n\tINPUT_ACTION_ORIGIN_SWITCH_PLUS = k_EInputActionOrigin_Switch_Plus,\n\tINPUT_ACTION_ORIGIN_SWITCH_MINUS = k_EInputActionOrigin_Switch_Minus,\n\tINPUT_ACTION_ORIGIN_SWITCH_CAPTURE = k_EInputActionOrigin_Switch_Capture,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTTRIGGER_PULL = k_EInputActionOrigin_Switch_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTTRIGGER_CLICK = k_EInputActionOrigin_Switch_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTTRIGGER_PULL = k_EInputActionOrigin_Switch_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_Switch_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_MOVE = k_EInputActionOrigin_Switch_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_CLICK = k_EInputActionOrigin_Switch_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_Switch_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_Switch_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_DPADWEST = k_EInputActionOrigin_Switch_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTSTICK_DPADEAST = k_EInputActionOrigin_Switch_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_MOVE = k_EInputActionOrigin_Switch_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_CLICK = k_EInputActionOrigin_Switch_RightStick_Click,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_Switch_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_Switch_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_Switch_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_Switch_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_SWITCH_DPAD_NORTH = k_EInputActionOrigin_Switch_DPad_North,\n\tINPUT_ACTION_ORIGIN_SWITCH_DPAD_SOUTH = k_EInputActionOrigin_Switch_DPad_South,\n\tINPUT_ACTION_ORIGIN_SWITCH_DPAD_WEST = k_EInputActionOrigin_Switch_DPad_West,\n\tINPUT_ACTION_ORIGIN_SWITCH_DPAD_EAST = k_EInputActionOrigin_Switch_DPad_East,\n\tINPUT_ACTION_ORIGIN_SWITCH_PROGYRO_MOVE = k_EInputActionOrigin_Switch_ProGyro_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_PROGYRO_PITCH = k_EInputActionOrigin_Switch_ProGyro_Pitch,\n\tINPUT_ACTION_ORIGIN_SWITCH_PROGYRO_YAW = k_EInputActionOrigin_Switch_ProGyro_Yaw,\n\tINPUT_ACTION_ORIGIN_SWITCH_PROGYRO_ROLL = k_EInputActionOrigin_Switch_ProGyro_Roll,\n\tINPUT_ACTION_ORIGIN_SWITCH_DPAD_MOVE = k_EInputActionOrigin_Switch_DPad_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED1 = k_EInputActionOrigin_Switch_Reserved1,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED2 = k_EInputActionOrigin_Switch_Reserved2,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED3 = k_EInputActionOrigin_Switch_Reserved3,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED4 = k_EInputActionOrigin_Switch_Reserved4,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED5 = k_EInputActionOrigin_Switch_Reserved5,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED6 = k_EInputActionOrigin_Switch_Reserved6,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED7 = k_EInputActionOrigin_Switch_Reserved7,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED8 = k_EInputActionOrigin_Switch_Reserved8,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED9 = k_EInputActionOrigin_Switch_Reserved9,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED10 = k_EInputActionOrigin_Switch_Reserved10,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGYRO_MOVE = k_EInputActionOrigin_Switch_RightGyro_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGYRO_PITCH = k_EInputActionOrigin_Switch_RightGyro_Pitch,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGYRO_YAW = k_EInputActionOrigin_Switch_RightGyro_Yaw,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGYRO_ROLL = k_EInputActionOrigin_Switch_RightGyro_Roll,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGYRO_MOVE = k_EInputActionOrigin_Switch_LeftGyro_Move,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGYRO_PITCH = k_EInputActionOrigin_Switch_LeftGyro_Pitch,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGYRO_YAW = k_EInputActionOrigin_Switch_LeftGyro_Yaw,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGYRO_ROLL = k_EInputActionOrigin_Switch_LeftGyro_Roll,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGRIP_LOWER = k_EInputActionOrigin_Switch_LeftGrip_Lower,\n\tINPUT_ACTION_ORIGIN_SWITCH_LEFTGRIP_UPPER = k_EInputActionOrigin_Switch_LeftGrip_Upper,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGRIP_LOWER = k_EInputActionOrigin_Switch_RightGrip_Lower,\n\tINPUT_ACTION_ORIGIN_SWITCH_RIGHTGRIP_UPPER = k_EInputActionOrigin_Switch_RightGrip_Upper,\n\tINPUT_ACTION_ORIGIN_SWITCH_JOYCON_BUTTON_N = k_EInputActionOrigin_Switch_JoyConButton_N,\n\tINPUT_ACTION_ORIGIN_SWITCH_JOYCON_BUTTON_E = k_EInputActionOrigin_Switch_JoyConButton_E,\n\tINPUT_ACTION_ORIGIN_SWITCH_JOYCON_BUTTON_S = k_EInputActionOrigin_Switch_JoyConButton_S,\n\tINPUT_ACTION_ORIGIN_SWITCH_JOYCON_BUTTON_W = k_EInputActionOrigin_Switch_JoyConButton_W,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED15 = k_EInputActionOrigin_Switch_Reserved15,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED16 = k_EInputActionOrigin_Switch_Reserved16,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED17 = k_EInputActionOrigin_Switch_Reserved17,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED18 = k_EInputActionOrigin_Switch_Reserved18,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED19 = k_EInputActionOrigin_Switch_Reserved19,\n\tINPUT_ACTION_ORIGIN_SWITCH_RESERVED20 = k_EInputActionOrigin_Switch_Reserved20,\n\tINPUT_ACTION_ORIGIN_PS5_X = k_EInputActionOrigin_PS5_X,\n\tINPUT_ACTION_ORIGIN_PS5_CIRCLE = k_EInputActionOrigin_PS5_Circle,\n\tINPUT_ACTION_ORIGIN_PS5_TRIANGLE = k_EInputActionOrigin_PS5_Triangle,\n\tINPUT_ACTION_ORIGIN_PS5_SQUARE = k_EInputActionOrigin_PS5_Square,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTBUMPER = k_EInputActionOrigin_PS5_LeftBumper,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTBUMPER = k_EInputActionOrigin_PS5_RightBumper,\n\tINPUT_ACTION_ORIGIN_PS5_OPTION = k_EInputActionOrigin_PS5_Option,\n\tINPUT_ACTION_ORIGIN_PS5_CREATE = k_EInputActionOrigin_PS5_Create,\n\tINPUT_ACTION_ORIGIN_PS5_MUTE = k_EInputActionOrigin_PS5_Mute,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_TOUCH = k_EInputActionOrigin_PS5_LeftPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_SWIPE = k_EInputActionOrigin_PS5_LeftPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_CLICK = k_EInputActionOrigin_PS5_LeftPad_Click,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_DPADNORTH = k_EInputActionOrigin_PS5_LeftPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_DPADSOUTH = k_EInputActionOrigin_PS5_LeftPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_DPADWEST = k_EInputActionOrigin_PS5_LeftPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTPAD_DPADEAST = k_EInputActionOrigin_PS5_LeftPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_TOUCH = k_EInputActionOrigin_PS5_RightPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_SWIPE = k_EInputActionOrigin_PS5_RightPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_CLICK = k_EInputActionOrigin_PS5_RightPad_Click,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_DPADNORTH = k_EInputActionOrigin_PS5_RightPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_DPADSOUTH = k_EInputActionOrigin_PS5_RightPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_DPADWEST = k_EInputActionOrigin_PS5_RightPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTPAD_DPADEAST = k_EInputActionOrigin_PS5_RightPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_TOUCH = k_EInputActionOrigin_PS5_CenterPad_Touch,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_SWIPE = k_EInputActionOrigin_PS5_CenterPad_Swipe,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_CLICK = k_EInputActionOrigin_PS5_CenterPad_Click,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_DPADNORTH = k_EInputActionOrigin_PS5_CenterPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_DPADSOUTH = k_EInputActionOrigin_PS5_CenterPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_DPADWEST = k_EInputActionOrigin_PS5_CenterPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS5_CENTERPAD_DPADEAST = k_EInputActionOrigin_PS5_CenterPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTTRIGGER_PULL = k_EInputActionOrigin_PS5_LeftTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTTRIGGER_CLICK = k_EInputActionOrigin_PS5_LeftTrigger_Click,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTTRIGGER_PULL = k_EInputActionOrigin_PS5_RightTrigger_Pull,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTTRIGGER_CLICK = k_EInputActionOrigin_PS5_RightTrigger_Click,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_MOVE = k_EInputActionOrigin_PS5_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_CLICK = k_EInputActionOrigin_PS5_LeftStick_Click,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_PS5_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_PS5_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_DPADWEST = k_EInputActionOrigin_PS5_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTSTICK_DPADEAST = k_EInputActionOrigin_PS5_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_MOVE = k_EInputActionOrigin_PS5_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_CLICK = k_EInputActionOrigin_PS5_RightStick_Click,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_PS5_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_PS5_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_PS5_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_PS5_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_PS5_DPAD_NORTH = k_EInputActionOrigin_PS5_DPad_North,\n\tINPUT_ACTION_ORIGIN_PS5_DPAD_SOUTH = k_EInputActionOrigin_PS5_DPad_South,\n\tINPUT_ACTION_ORIGIN_PS5_DPAD_WEST = k_EInputActionOrigin_PS5_DPad_West,\n\tINPUT_ACTION_ORIGIN_PS5_DPAD_EAST = k_EInputActionOrigin_PS5_DPad_East,\n\tINPUT_ACTION_ORIGIN_PS5_GYRO_MOVE = k_EInputActionOrigin_PS5_Gyro_Move,\n\tINPUT_ACTION_ORIGIN_PS5_GYRO_PITCH = k_EInputActionOrigin_PS5_Gyro_Pitch,\n\tINPUT_ACTION_ORIGIN_PS5_GYRO_YAW = k_EInputActionOrigin_PS5_Gyro_Yaw,\n\tINPUT_ACTION_ORIGIN_PS5_GYRO_ROLL = k_EInputActionOrigin_PS5_Gyro_Roll,\n\tINPUT_ACTION_ORIGIN_PS5_DPAD_MOVE = k_EInputActionOrigin_PS5_DPad_Move,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTGRIP = k_EInputActionOrigin_PS5_LeftGrip,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTGRIP = k_EInputActionOrigin_PS5_RightGrip,\n\tINPUT_ACTION_ORIGIN_PS5_LEFTFN = k_EInputActionOrigin_PS5_LeftFn,\n\tINPUT_ACTION_ORIGIN_PS5_RIGHTFN = k_EInputActionOrigin_PS5_RightFn,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED5 = k_EInputActionOrigin_PS5_Reserved5,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED6 = k_EInputActionOrigin_PS5_Reserved6,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED7 = k_EInputActionOrigin_PS5_Reserved7,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED8 = k_EInputActionOrigin_PS5_Reserved8,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED9 = k_EInputActionOrigin_PS5_Reserved9,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED10 = k_EInputActionOrigin_PS5_Reserved10,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED11 = k_EInputActionOrigin_PS5_Reserved11,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED12 = k_EInputActionOrigin_PS5_Reserved12,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED13 = k_EInputActionOrigin_PS5_Reserved13,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED14 = k_EInputActionOrigin_PS5_Reserved14,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED15 = k_EInputActionOrigin_PS5_Reserved15,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED16 = k_EInputActionOrigin_PS5_Reserved16,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED17 = k_EInputActionOrigin_PS5_Reserved17,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED18 = k_EInputActionOrigin_PS5_Reserved18,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED19 = k_EInputActionOrigin_PS5_Reserved19,\n\tINPUT_ACTION_ORIGIN_PS5_RESERVED20 = k_EInputActionOrigin_PS5_Reserved20,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_A = k_EInputActionOrigin_SteamDeck_A,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_B = k_EInputActionOrigin_SteamDeck_B,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_X = k_EInputActionOrigin_SteamDeck_X,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_Y = k_EInputActionOrigin_SteamDeck_Y,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L1 = k_EInputActionOrigin_SteamDeck_L1,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R1 = k_EInputActionOrigin_SteamDeck_R1,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_MENU = k_EInputActionOrigin_SteamDeck_Menu,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_VIEW = k_EInputActionOrigin_SteamDeck_View,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_TOUCH = k_EInputActionOrigin_SteamDeck_LeftPad_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_SWIPE = k_EInputActionOrigin_SteamDeck_LeftPad_Swipe,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_CLICK = k_EInputActionOrigin_SteamDeck_LeftPad_Click,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_DPADNORTH = k_EInputActionOrigin_SteamDeck_LeftPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_DPADSOUTH = k_EInputActionOrigin_SteamDeck_LeftPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_DPADWEST = k_EInputActionOrigin_SteamDeck_LeftPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTPAD_DPADEAST = k_EInputActionOrigin_SteamDeck_LeftPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_TOUCH = k_EInputActionOrigin_SteamDeck_RightPad_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_SWIPE = k_EInputActionOrigin_SteamDeck_RightPad_Swipe,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_CLICK = k_EInputActionOrigin_SteamDeck_RightPad_Click,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_DPADNORTH = k_EInputActionOrigin_SteamDeck_RightPad_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_DPADSOUTH = k_EInputActionOrigin_SteamDeck_RightPad_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_DPADWEST = k_EInputActionOrigin_SteamDeck_RightPad_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTPAD_DPADEAST = k_EInputActionOrigin_SteamDeck_RightPad_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L2_SOFTPULL = k_EInputActionOrigin_SteamDeck_L2_SoftPull,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L2 = k_EInputActionOrigin_SteamDeck_L2,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R2_SOFTPULL = k_EInputActionOrigin_SteamDeck_R2_SoftPull,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R2 = k_EInputActionOrigin_SteamDeck_R2,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_MOVE = k_EInputActionOrigin_SteamDeck_LeftStick_Move,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L3 = k_EInputActionOrigin_SteamDeck_L3,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_DPADNORTH = k_EInputActionOrigin_SteamDeck_LeftStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_DPADSOUTH = k_EInputActionOrigin_SteamDeck_LeftStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_DPADWEST = k_EInputActionOrigin_SteamDeck_LeftStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_DPADEAST = k_EInputActionOrigin_SteamDeck_LeftStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_LEFTSTICK_TOUCH = k_EInputActionOrigin_SteamDeck_LeftStick_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_MOVE = k_EInputActionOrigin_SteamDeck_RightStick_Move,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R3 = k_EInputActionOrigin_SteamDeck_R3,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_DPADNORTH = k_EInputActionOrigin_SteamDeck_RightStick_DPadNorth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_DPADSOUTH = k_EInputActionOrigin_SteamDeck_RightStick_DPadSouth,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_DPADWEST = k_EInputActionOrigin_SteamDeck_RightStick_DPadWest,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_DPADEAST = k_EInputActionOrigin_SteamDeck_RightStick_DPadEast,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RIGHTSTICK_TOUCH = k_EInputActionOrigin_SteamDeck_RightStick_Touch,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L4 = k_EInputActionOrigin_SteamDeck_L4,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R4 = k_EInputActionOrigin_SteamDeck_R4,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_L5 = k_EInputActionOrigin_SteamDeck_L5,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_R5 = k_EInputActionOrigin_SteamDeck_R5,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_DPAD_MOVE = k_EInputActionOrigin_SteamDeck_DPad_Move,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_DPAD_NORTH = k_EInputActionOrigin_SteamDeck_DPad_North,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_DPAD_SOUTH = k_EInputActionOrigin_SteamDeck_DPad_South,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_DPAD_WEST = k_EInputActionOrigin_SteamDeck_DPad_West,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_DPAD_EAST = k_EInputActionOrigin_SteamDeck_DPad_East,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_GYRO_MOVE = k_EInputActionOrigin_SteamDeck_Gyro_Move,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_GYRO_PITCH = k_EInputActionOrigin_SteamDeck_Gyro_Pitch,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_GYRO_YAW = k_EInputActionOrigin_SteamDeck_Gyro_Yaw,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_GYRO_ROLL = k_EInputActionOrigin_SteamDeck_Gyro_Roll,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED1 = k_EInputActionOrigin_SteamDeck_Reserved1,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED2 = k_EInputActionOrigin_SteamDeck_Reserved2,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED3 = k_EInputActionOrigin_SteamDeck_Reserved3,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED4 = k_EInputActionOrigin_SteamDeck_Reserved4,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED5 = k_EInputActionOrigin_SteamDeck_Reserved5,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED6 = k_EInputActionOrigin_SteamDeck_Reserved6,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED7 = k_EInputActionOrigin_SteamDeck_Reserved7,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED8 = k_EInputActionOrigin_SteamDeck_Reserved8,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED9 = k_EInputActionOrigin_SteamDeck_Reserved9,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED10 = k_EInputActionOrigin_SteamDeck_Reserved10,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED11 = k_EInputActionOrigin_SteamDeck_Reserved11,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED12 = k_EInputActionOrigin_SteamDeck_Reserved12,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED13 = k_EInputActionOrigin_SteamDeck_Reserved13,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED14 = k_EInputActionOrigin_SteamDeck_Reserved14,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED15 = k_EInputActionOrigin_SteamDeck_Reserved15,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED16 = k_EInputActionOrigin_SteamDeck_Reserved16,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED17 = k_EInputActionOrigin_SteamDeck_Reserved17,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED18 = k_EInputActionOrigin_SteamDeck_Reserved18,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED19 = k_EInputActionOrigin_SteamDeck_Reserved19,\n\tINPUT_ACTION_ORIGIN_STEAMDECK_RESERVED20 = k_EInputActionOrigin_SteamDeck_Reserved20,\n\tINPUT_ACTION_ORIGIN_HORIPAD_M1 = k_EInputActionOrigin_Horipad_M1,\n\tINPUT_ACTION_ORIGIN_HORIPAD_M2 = k_EInputActionOrigin_Horipad_M2,\n\tINPUT_ACTION_ORIGIN_HORIPAD_L4 = k_EInputActionOrigin_Horipad_L4,\n\tINPUT_ACTION_ORIGIN_HORIPAD_R4 = k_EInputActionOrigin_Horipad_R4,\n\tINPUT_ACTION_ORIGIN_COUNT = k_EInputActionOrigin_Count,\n\tINPUT_ACTION_ORIGIN_MAXIMUM_POSSIBLE_VALUE = k_EInputActionOrigin_MaximumPossibleValue\n};\n\nenum InputConfigurationEnableType {\n\tINPUT_CONFIGURATION_ENABLE_TYPE_NONE = k_ESteamInputConfigurationEnableType_None,\n\tINPUT_CONFIGURATION_ENABLE_TYPE_PLAYSTATION = k_ESteamInputConfigurationEnableType_Playstation,\n\tINPUT_CONFIGURATION_ENABLE_TYPE_XBOX = k_ESteamInputConfigurationEnableType_Xbox,\n\tINPUT_CONFIGURATION_ENABLE_TYPE_GENERIC = k_ESteamInputConfigurationEnableType_Generic,\n\tINPUT_CONFIGURATION_ENABLE_TYPE_SWITCH = k_ESteamInputConfigurationEnableType_Switch\n};\n\nenum InputGlyphSize {\n\tINPUT_GLYPH_SIZE_SMALL = k_ESteamInputGlyphSize_Small,\n\tINPUT_GLYPH_SIZE_MEDIUM = k_ESteamInputGlyphSize_Medium,\n\tINPUT_GLYPH_SIZE_LARGE = k_ESteamInputGlyphSize_Large,\n\tINPUT_GLYPH_SIZE_COUNT = k_ESteamInputGlyphSize_Count\n};\n\nenum InputGlyphStyle {\n\tINPUT_GLYPH_STYLE_KNOCKOUT = ESteamInputGlyphStyle_Knockout,\n\tINPUT_GLYPH_STYLE_LIGHT = ESteamInputGlyphStyle_Light,\n\tINPUT_GLYPH_STYLE_DARK = ESteamInputGlyphStyle_Dark,\n\tINPUT_GLYPH_STYLE_NEUTRAL_COLOR_ABXY = ESteamInputGlyphStyle_NeutralColorABXY,\n\tINPUT_GLYPH_STYLE_SOLID_ABXY = ESteamInputGlyphStyle_SolidABXY\n};\n\nenum InputLEDFlag {\n\tINPUT_LED_FLAG_SET_COLOR = k_ESteamInputLEDFlag_SetColor,\n\tINPUT_LED_FLAG_RESTORE_USER_DEFAULT = k_ESteamInputLEDFlag_RestoreUserDefault\n};\n\nenum InputSourceMode {\n\tINPUT_SOURCE_MODE_NONE = k_EInputSourceMode_None,\n\tINPUT_SOURCE_MODE_DPAD = k_EInputSourceMode_Dpad,\n\tINPUT_SOURCE_MODE_BUTTONS = k_EInputSourceMode_Buttons,\n\tINPUT_SOURCE_MODE_FOUR_BUTTONS = k_EInputSourceMode_FourButtons,\n\tINPUT_SOURCE_MODE_ABSOLUTE_MOUSE = k_EInputSourceMode_AbsoluteMouse,\n\tINPUT_SOURCE_MODE_RELATIVE_MOUSE = k_EInputSourceMode_RelativeMouse,\n\tINPUT_SOURCE_MODE_JOYSTICK_MOVE = k_EInputSourceMode_JoystickMove,\n\tINPUT_SOURCE_MODE_JOYSTICK_MOUSE = k_EInputSourceMode_JoystickMouse,\n\tINPUT_SOURCE_MODE_JOYSTICK_CAMERA = k_EInputSourceMode_JoystickCamera,\n\tINPUT_SOURCE_MODE_SCROLL_WHEEL = k_EInputSourceMode_ScrollWheel,\n\tINPUT_SOURCE_MODE_TRIGGER = k_EInputSourceMode_Trigger,\n\tINPUT_SOURCE_MODE_TOUCH_MENU = k_EInputSourceMode_TouchMenu,\n\tINPUT_SOURCE_MODE_MOUSE_JOYSTICK = k_EInputSourceMode_MouseJoystick,\n\tINPUT_SOURCE_MODE_MOUSE_REGION = k_EInputSourceMode_MouseRegion,\n\tINPUT_SOURCE_MODE_RADIAL_MENU = k_EInputSourceMode_RadialMenu,\n\tINPUT_SOURCE_MODE_SINGLE_BUTTON = k_EInputSourceMode_SingleButton,\n\tINPUT_SOURCE_MODE_SWITCH = k_EInputSourceMode_Switches\n};\n\nenum InputType {\n\tINPUT_TYPE_UNKNOWN = k_ESteamInputType_Unknown,\n\tINPUT_TYPE_STEAM_CONTROLLER = k_ESteamInputType_SteamController,\n\tINPUT_TYPE_XBOX360_CONTROLLER = k_ESteamInputType_XBox360Controller,\n\tINPUT_TYPE_XBOXONE_CONTROLLER = k_ESteamInputType_XBoxOneController,\n\tINPUT_TYPE_GENERIC_XINPUT = k_ESteamInputType_GenericGamepad,\n\tINPUT_TYPE_PS4_CONTROLLER = k_ESteamInputType_PS4Controller,\n\tINPUT_TYPE_APPLE_MFI_CONTROLLER = k_ESteamInputType_AppleMFiController,\n\tINPUT_TYPE_ANDROID_CONTROLLER = k_ESteamInputType_AndroidController,\n\tINPUT_TYPE_SWITCH_JOYCON_PAIR = k_ESteamInputType_SwitchJoyConPair,\n\tINPUT_TYPE_SWITCH_JOYCON_SINGLE = k_ESteamInputType_SwitchJoyConSingle,\n\tINPUT_TYPE_SWITCH_PRO_CONTROLLER = k_ESteamInputType_SwitchProController,\n\tINPUT_TYPE_MOBILE_TOUCH = k_ESteamInputType_MobileTouch,\n\tINPUT_TYPE_PS3_CONTROLLER = k_ESteamInputType_PS3Controller,\n\tINPUT_TYPE_PS5_CONTROLLER = k_ESteamInputType_PS5Controller,\n\tINPUT_TYPE_STEAM_DECK_CONTROLLER = k_ESteamInputType_SteamDeckController,\n\tINPUT_TYPE_COUNT = k_ESteamInputType_Count,\n\tINPUT_TYPE_MAXIMUM_POSSIBLE_VALUE = k_ESteamInputType_MaximumPossibleValue\n};\n\nenum SCEPadTriggerEffectMode {\n\tPAD_TRIGGER_EFFECT_MODE_OFF = SCE_PAD_TRIGGER_EFFECT_MODE_OFF,\n\tPAD_TRIGGER_EFFECT_MODE_FEEDBACK = SCE_PAD_TRIGGER_EFFECT_MODE_FEEDBACK,\n\tPAD_TRIGGER_EFFECT_MODE_WEAPON = SCE_PAD_TRIGGER_EFFECT_MODE_WEAPON,\n\tPAD_TRIGGER_EFFECT_MODE_VIBRATION = SCE_PAD_TRIGGER_EFFECT_MODE_VIBRATION,\n\tPAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_FEEDBACK = SCE_PAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_FEEDBACK,\n\tPAD_TRIGGER_EFFECT_MODE_SLOPE_FEEDBACK = SCE_PAD_TRIGGER_EFFECT_MODE_SLOPE_FEEDBACK,\n\tPAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_VIBRATION = SCE_PAD_TRIGGER_EFFECT_MODE_MULTIPLE_POSITION_VIBRATION\n};\n\nenum XboxOrigin {\n\tXBOX_ORIGIN_A = k_EXboxOrigin_A,\n\tXBOX_ORIGIN_B = k_EXboxOrigin_B,\n\tXBOX_ORIGIN_X = k_EXboxOrigin_X,\n\tXBOX_ORIGIN_Y = k_EXboxOrigin_Y,\n\tXBOX_ORIGIN_LEFT_BUMPER = k_EXboxOrigin_LeftBumper,\n\tXBOX_ORIGIN_RIGHT_BUMPER = k_EXboxOrigin_RightBumper,\n\tXBOX_ORIGIN_MENU = k_EXboxOrigin_Menu,\n\tXBOX_ORIGIN_VIEW = k_EXboxOrigin_View,\n\tXBOX_ORIGIN_LEFT_TRIGGER_PULL = k_EXboxOrigin_LeftTrigger_Pull,\n\tXBOX_ORIGIN_LEFT_TRIGGER_CLICK = k_EXboxOrigin_LeftTrigger_Click,\n\tXBOX_ORIGIN_RIGHT_TRIGGER_PULL = k_EXboxOrigin_RightTrigger_Pull,\n\tXBOX_ORIGIN_RIGHT_TRIGGER_CLICK = k_EXboxOrigin_RightTrigger_Click,\n\tXBOX_ORIGIN_LEFT_STICK_MOVE = k_EXboxOrigin_LeftStick_Move,\n\tXBOX_ORIGIN_LEFT_STICK_CLICK = k_EXboxOrigin_LeftStick_Click,\n\tXBOX_ORIGIN_LEFT_STICK_DPAD_NORTH = k_EXboxOrigin_LeftStick_DPadNorth,\n\tXBOX_ORIGIN_LEFT_STICK_DPAD_SOUTH = k_EXboxOrigin_LeftStick_DPadSouth,\n\tXBOX_ORIGIN_LEFT_STICK_DPAD_WEST = k_EXboxOrigin_LeftStick_DPadWest,\n\tXBOX_ORIGIN_LEFT_STICK_DPAD_EAT = k_EXboxOrigin_LeftStick_DPadEast,\n\tXBOX_ORIGIN_RIGHT_STICK_MOVE = k_EXboxOrigin_RightStick_Move,\n\tXBOX_ORIGIN_RIGHT_STICK_CLICK = k_EXboxOrigin_RightStick_Click,\n\tXBOX_ORIGIN_RIGHT_STICK_DPAD_NORTH = k_EXboxOrigin_RightStick_DPadNorth,\n\tXBOX_ORIGIN_RIGHT_STICK_DPAD_SOUTH = k_EXboxOrigin_RightStick_DPadSouth,\n\tXBOX_ORIGIN_RIGHT_STICK_DPAD_WEST = k_EXboxOrigin_RightStick_DPadWest,\n\tXBOX_ORIGIN_RIGHT_STICK_DPAD_EAST = k_EXboxOrigin_RightStick_DPadEast,\n\tXBOX_ORIGIN_DPAD_NORTH = k_EXboxOrigin_DPad_North,\n\tXBOX_ORIGIN_DPAD_SOUTH = k_EXboxOrigin_DPad_South,\n\tXBOX_ORIGIN_DPAD_WEST = k_EXboxOrigin_DPad_West,\n\tXBOX_ORIGIN_DPAD_EAST = k_EXboxOrigin_DPad_East,\n\tXBOX_ORIGIN_COUNT = k_EXboxOrigin_Count\n};\n\n\n// Inventory enums\nenum ItemFlags {\n\tSTEAM_ITEM_NO_TRADE = k_ESteamItemNoTrade,\n\tSTEAM_ITEM_REMOVED = k_ESteamItemRemoved,\n\tSTEAM_ITEM_CONSUMED = k_ESteamItemConsumed\n};\n\n\n// Matchmaking enums\nenum ChatMemberStateChange {\n\tCHAT_MEMBER_STATE_CHANGE_ENTERED = k_EChatMemberStateChangeEntered,\n\tCHAT_MEMBER_STATE_CHANGE_LEFT = k_EChatMemberStateChangeLeft,\n\tCHAT_MEMBER_STATE_CHANGE_DISCONNECTED = k_EChatMemberStateChangeDisconnected,\n\tCHAT_MEMBER_STATE_CHANGE_KICKED = k_EChatMemberStateChangeKicked,\n\tCHAT_MEMBER_STATE_CHANGE_BANNED = k_EChatMemberStateChangeBanned\n};\n\nenum LobbyComparison {\n\tLOBBY_COMPARISON_EQUAL_TO_OR_LESS_THAN = k_ELobbyComparisonEqualToOrLessThan,\n\tLOBBY_COMPARISON_LESS_THAN = k_ELobbyComparisonLessThan,\n\tLOBBY_COMPARISON_EQUAL = k_ELobbyComparisonEqual,\n\tLOBBY_COMPARISON_GREATER_THAN = k_ELobbyComparisonGreaterThan,\n\tLOBBY_COMPARISON_EQUAL_TO_GREATER_THAN = k_ELobbyComparisonEqualToOrGreaterThan,\n\tLOBBY_COMPARISON_NOT_EQUAL = k_ELobbyComparisonNotEqual\n};\n\nenum LobbyDistanceFilter {\n\tLOBBY_DISTANCE_FILTER_CLOSE = k_ELobbyDistanceFilterClose,\n\tLOBBY_DISTANCE_FILTER_DEFAULT = k_ELobbyDistanceFilterDefault,\n\tLOBBY_DISTANCE_FILTER_FAR = k_ELobbyDistanceFilterFar,\n\tLOBBY_DISTANCE_FILTER_WORLDWIDE = k_ELobbyDistanceFilterWorldwide\n};\n\nenum LobbyType {\n\tLOBBY_TYPE_PRIVATE = k_ELobbyTypePrivate,\n\tLOBBY_TYPE_FRIENDS_ONLY = k_ELobbyTypeFriendsOnly,\n\tLOBBY_TYPE_PUBLIC = k_ELobbyTypePublic,\n\tLOBBY_TYPE_INVISIBLE = k_ELobbyTypeInvisible,\n\tLOBBY_TYPE_PRIVATE_UNIQUE = k_ELobbyTypePrivateUnique\n\n};\n\n\n// Matchmaking Servers enums\nenum MatchMakingServerResponse {\n\tSERVER_RESPONDED = eServerResponded,\n\tSERVER_FAILED_TO_RESPOND = eServerFailedToRespond,\n\tNO_SERVERS_LISTED_ON_MASTER_SERVER = eNoServersListedOnMasterServer\n};\n\n\n// Music enums\nenum AudioPlaybackStatus {\n\tAUDIO_PLAYBACK_UNDEFINED = AudioPlayback_Undefined,\n\tAUDIO_PLAYBACK_PLAYING = AudioPlayback_Playing,\n\tAUDIO_PLAYBACK_PAUSED = AudioPlayback_Paused,\n\tAUDIO_PLAYBACK_IDLE = AudioPlayback_Idle\n};\n\n\n// Networking enums\nenum P2PSend {\n\tP2P_SEND_UNRELIABLE = k_EP2PSendUnreliable,\n\tP2P_SEND_UNRELIABLE_NO_DELAY = k_EP2PSendUnreliableNoDelay,\n\tP2P_SEND_RELIABLE = k_EP2PSendReliable,\n\tP2P_SEND_RELIABLE_WITH_BUFFERING = k_EP2PSendReliableWithBuffering\n};\n\nenum P2PSessionError {\n\tP2P_SESSION_ERROR_NONE = k_EP2PSessionErrorNone,\n\tP2P_SESSION_ERROR_NOT_RUNNING_APP = k_EP2PSessionErrorNotRunningApp_DELETED,\n\tP2P_SESSION_ERROR_NO_RIGHTS_TO_APP = k_EP2PSessionErrorNoRightsToApp,\n\tP2P_SESSION_ERROR_DESTINATION_NOT_LOGGED_ON = k_EP2PSessionErrorDestinationNotLoggedIn_DELETED,\n\tP2P_SESSION_ERROR_TIMEOUT = k_EP2PSessionErrorTimeout,\n\tP2P_SESSION_ERROR_MAX = k_EP2PSessionErrorMax\n};\n\nenum SocketConnectionType {\n\tNET_SOCKET_CONNECTION_TYPE_NOT_CONNECTED = k_ESNetSocketConnectionTypeNotConnected,\n\tNET_SOCKET_CONNECTION_TYPE_UDP = k_ESNetSocketConnectionTypeUDP,\n\tNET_SOCKET_CONNECTION_TYPE_UDP_RELAY = k_ESNetSocketConnectionTypeUDPRelay\n};\n\nenum SocketState {\n\tNET_SOCKET_STATE_INVALID = k_ESNetSocketStateInvalid,\n\tNET_SOCKET_STATE_CONNECTED = k_ESNetSocketStateConnected,\n\tNET_SOCKET_STATE_INITIATED = k_ESNetSocketStateInitiated,\n\tNET_SOCKET_STATE_LOCAL_CANDIDATE_FOUND = k_ESNetSocketStateLocalCandidatesFound,\n\tNET_SOCKET_STATE_RECEIVED_REMOTE_CANDIDATES = k_ESNetSocketStateReceivedRemoteCandidates,\n\tNET_SOCKET_STATE_CHALLENGE_HANDSHAKE = k_ESNetSocketStateChallengeHandshake,\n\tNET_SOCKET_STATE_DISCONNECTING = k_ESNetSocketStateDisconnecting,\n\tNET_SOCKET_STATE_LOCAL_DISCONNECT = k_ESNetSocketStateLocalDisconnect,\n\tNET_SOCKET_STATE_TIMEOUT_DURING_CONNECT = k_ESNetSocketStateTimeoutDuringConnect,\n\tNET_SOCKET_STATE_REMOTE_END_DISCONNECTED = k_ESNetSocketStateRemoteEndDisconnected,\n\tNET_SOCKET_STATE_BROKEN = k_ESNetSocketStateConnectionBroken\n};\n\n\n// Networking Sockets enums\nenum NetworkingConfigValue {\n\tNETWORKING_CONFIG_INVALID = k_ESteamNetworkingConfig_Invalid,\n\tNETWORKING_CONFIG_FAKE_PACKET_LOSS_SEND = k_ESteamNetworkingConfig_FakePacketLoss_Send,\n\tNETWORKING_CONFIG_FAKE_PACKET_LOSS_RECV = k_ESteamNetworkingConfig_FakePacketLoss_Recv,\n\tNETWORKING_CONFIG_FAKE_PACKET_LAG_SEND = k_ESteamNetworkingConfig_FakePacketLag_Send,\n\tNETWORKING_CONFIG_FAKE_PACKET_LAG_RECV = k_ESteamNetworkingConfig_FakePacketLag_Recv,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_SEND_AVG = k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_SEND_MAX = k_ESteamNetworkingConfig_FakePacketJitter_Send_Max,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_SEND_PCT = k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_RECV_AVG = k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_RECV_MAX = k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max,\n\tNETWORKING_CONFIG_FAKE_PACKET_JITTER_RECV_PCT = k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct,\n\tNETWORKING_CONFIG_FAKE_PACKET_REORDER_SEND = k_ESteamNetworkingConfig_FakePacketReorder_Send,\n\tNETWORKING_CONFIG_FAKE_PACKET_REORDER_RECV = k_ESteamNetworkingConfig_FakePacketReorder_Recv,\n\tNETWORKING_CONFIG_FAKE_PACKET_REORDER_TIME = k_ESteamNetworkingConfig_FakePacketReorder_Time,\n\tNETWORKING_CONFIG_FAKE_PACKET_DUP_SEND = k_ESteamNetworkingConfig_FakePacketDup_Send,\n\tNETWORKING_CONFIG_FAKE_PACKET_DUP_REVC = k_ESteamNetworkingConfig_FakePacketDup_Recv,\n\tNETWORKING_CONFIG_FAKE_PACKET_DUP_TIME_MAX = k_ESteamNetworkingConfig_FakePacketDup_TimeMax,\n\tNETWORKING_CONFIG_PACKET_TRACE_MAX_BYTES = k_ESteamNetworkingConfig_PacketTraceMaxBytes,\n\tNETWORKING_CONFIG_FAKE_RATE_LIMIT_SEND_RATE = k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate,\n\tNETWORKING_CONFIG_FAKE_RATE_LIMIT_SEND_BURST = k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst,\n\tNETWORKING_CONFIG_FAKE_RATE_LIMIT_RECV_RATE = k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate,\n\tNETWORKING_CONFIG_FAKE_RATE_LIMIT_RECV_BURST = k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst,\n\tNETWORKING_CONFIG_OUT_OF_ORDER_CORRECTION_WINDOW_MICROSECONDS = k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds,\n\tNETWORKING_CONFIG_CONNECTION_USER_DATA = k_ESteamNetworkingConfig_ConnectionUserData,\n\tNETWORKING_CONFIG_TIMEOUT_INITIAL = k_ESteamNetworkingConfig_TimeoutInitial,\n\tNETWORKING_CONFIG_TIMEOUT_CONNECTED = k_ESteamNetworkingConfig_TimeoutConnected,\n\tNETWORKING_CONFIG_SEND_BUFFER_SIZE = k_ESteamNetworkingConfig_SendBufferSize,\n\tNETWORKING_CONFIG_RECV_BUFFER_SIZE = k_ESteamNetworkingConfig_RecvBufferSize,\n\tNETWORKING_CONFIG_RECV_BUFFER_MESSAGES = k_ESteamNetworkingConfig_RecvBufferMessages,\n\tNETWORKING_CONFIG_RECV_MAX_MESSAGE_SIZE = k_ESteamNetworkingConfig_RecvMaxMessageSize,\n\tNETWORKING_CONFIG_RECV_MAX_SEGMENTS_PER_PACKET = k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket,\n\tNETWORKING_CONFIG_SEND_RATE_MIN = k_ESteamNetworkingConfig_SendRateMin,\n\tNETWORKING_CONFIG_SEND_RATE_MAX = k_ESteamNetworkingConfig_SendRateMax,\n\tNETWORKING_CONFIG_NAGLE_TIME = k_ESteamNetworkingConfig_NagleTime,\n\tNETWORKING_CONFIG_IP_ALLOW_WITHOUT_AUTH = k_ESteamNetworkingConfig_IP_AllowWithoutAuth,\n\tNETWORKING_CONFIG_IP_LOCAL_HOST_ALLOW_WITHOUT_AUTH = k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth,\n\tNETWORKING_CONFIG_MTU_PACKET_SIZE = k_ESteamNetworkingConfig_MTU_PacketSize,\n\tNETWORKING_CONFIG_MTU_DATA_SIZE = k_ESteamNetworkingConfig_MTU_DataSize,\n\tNETWORKING_CONFIG_UNENCRYPTED = k_ESteamNetworkingConfig_Unencrypted,\n\tNETWORKING_CONFIG_SYMMETRIC_CONNECT = k_ESteamNetworkingConfig_SymmetricConnect,\n\tNETWORKING_CONFIG_LOCAL_VIRTUAL_PORT = k_ESteamNetworkingConfig_LocalVirtualPort,\n\tNETWORKING_CONFIG_DUAL_WIFI_ENABLE = k_ESteamNetworkingConfig_DualWifi_Enable,\n\tNETWORKING_CONFIG_ENABLE_DIAGNOSTICS_UI = k_ESteamNetworkingConfig_EnableDiagnosticsUI,\n\tNETWORKING_CONFIG_SEND_TIME_SINCE_PREVIOUS_PACKET = k_ESteamNetworkingConfig_SendTimeSincePreviousPacket,\n\tNETWORKING_CONFIG_SDR_CLIENT_CONSEC_PING_TIMEOUT_FAIL_INITIAL = k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial,\n\tNETWORKING_CONFIG_SDR_CLIENT_CONSEC_PING_TIMEOUT_FAIL = k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail,\n\tNETWORKING_CONFIG_SDR_CLIENT_MIN_PINGS_BEFORE_PING_ACCURATE = k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate,\n\tNETWORKING_CONFIG_SDR_CLIENT_SINGLE_SOCKET = k_ESteamNetworkingConfig_SDRClient_SingleSocket,\n\tNETWORKING_CONFIG_SDR_CLIENT_FORCE_RELAY_CLUSTER = k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster,\n\tNETWORKING_CONFIG_SDR_CLIENT_DEV_TICKET = k_ESteamNetworkingConfig_SDRClient_DevTicket,\n\tNETWORKING_CONFIG_SDR_CLIENT_FORCE_PROXY_ADDR = k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr,\n\tNETWORKING_CONFIG_SDR_CLIENT_FAKE_CLUSTER_PING = k_ESteamNetworkingConfig_SDRClient_FakeClusterPing,\n\tNETWORKING_CONFIG_SDR_CLIENT_LIMIT_PING_PROBES_TO_NEAREST_N = k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN,\n\tNETWORKING_CONFIG_LOG_LEVEL_ACK_RTT = k_ESteamNetworkingConfig_LogLevel_AckRTT,\n\tNETWORKING_CONFIG_LOG_LEVEL_PACKET_DECODE = k_ESteamNetworkingConfig_LogLevel_PacketDecode,\n\tNETWORKING_CONFIG_LOG_LEVEL_MESSAGE = k_ESteamNetworkingConfig_LogLevel_Message,\n\tNETWORKING_CONFIG_LOG_LEVEL_PACKET_GAPS = k_ESteamNetworkingConfig_LogLevel_PacketGaps,\n\tNETWORKING_CONFIG_LOG_LEVEL_P2P_RENDEZVOUS = k_ESteamNetworkingConfig_LogLevel_P2PRendezvous,\n\tNETWORKING_CONFIG_LOG_LEVEL_SRD_RELAY_PINGS = k_ESteamNetworkingConfig_LogLevel_SDRRelayPings,\n\tNETWORKING_CONFIG_CALLBACK_CONNECTION_STATUS_CHANGED = k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged,\n\tNETWORKING_CONFIG_CALLBACK_AUTH_STATUS_CHANGED = k_ESteamNetworkingConfig_Callback_AuthStatusChanged,\n\tNETWORKING_CONFIG_CALLBACK_RELAY_NETWORK_STATUS_CHANGED = k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged,\n\tNETWORKING_CONFIG_CALLBACK_MESSAGE_SESSION_REQUEST = k_ESteamNetworkingConfig_Callback_MessagesSessionRequest,\n\tNETWORKING_CONFIG_CALLBACK_MESSAGES_SESSION_FAILED = k_ESteamNetworkingConfig_Callback_MessagesSessionFailed,\n\tNETWORKING_CONFIG_CALLBACK_CREATE_CONNECTION_SIGNALING = k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling,\n\tNETWORKING_CONFIG_CALLBACK_FAKE_IP_RESULT = k_ESteamNetworkingConfig_Callback_FakeIPResult,\n\tNETWORKING_CONFIG_P2P_STUN_SERVER_LIST = k_ESteamNetworkingConfig_P2P_STUN_ServerList,\n\tNETWORKING_CONFIG_P2P_TRANSPORT_ICE_ENABLE = k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable,\n\tNETWORKING_CONFIG_P2P_TRANSPORT_ICE_PENALTY = k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty,\n\tNETWORKING_CONFIG_P2P_TRANSPORT_SDR_PENALTY = k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty,\n\tNETWORKING_CONFIG_P2P_TURN_SERVER_LIST = k_ESteamNetworkingConfig_P2P_TURN_ServerList,\n\tNETWORKING_CONFIG_P2P_TURN_uSER_LIST = k_ESteamNetworkingConfig_P2P_TURN_UserList,\n\tNETWORKING_CONFIG_P2P_TURN_PASS_LIST = k_ESteamNetworkingConfig_P2P_TURN_PassList,\n\t//\t\t\tNETWORKING_CONFIG_P2P_TRANSPORT_LAN_BEACON_PENALTY = k_ESteamNetworkingConfig_P2P_Transport_LANBeacon_Penalty,\n\tNETWORKING_CONFIG_P2P_TRANSPORT_ICE_IMPLEMENTATION = k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation,\n\tNETWORKING_CONFIG_ECN = k_ESteamNetworkingConfig_ECN,\n\tNETWORKING_CONFIG_VALUE_FORCE32BIT = k_ESteamNetworkingConfigValue__Force32Bit\n};\n\nenum NetworkingConnectionEnd {\n\tCONNECTION_END_INVALID = k_ESteamNetConnectionEnd_Invalid,\n\tCONNECTION_END_APP_MIN = k_ESteamNetConnectionEnd_App_Min,\n\tCONNECTION_END_APP_GENERIC = k_ESteamNetConnectionEnd_App_Generic,\n\tCONNECTION_END_APP_MAX = k_ESteamNetConnectionEnd_App_Max,\n\tCONNECTION_END_APP_EXCEPTION_MIN = k_ESteamNetConnectionEnd_AppException_Min,\n\tCONNECTION_END_APP_EXCEPTION_GENERIC = k_ESteamNetConnectionEnd_AppException_Generic,\n\tCONNECTION_END_APP_EXCEPTION_MAX = k_ESteamNetConnectionEnd_AppException_Max,\n\tCONNECTION_END_LOCAL_MIN = k_ESteamNetConnectionEnd_Local_Min,\n\tCONNECTION_END_LOCAL_OFFLINE_MODE = k_ESteamNetConnectionEnd_Local_OfflineMode,\n\tCONNECTION_END_LOCAL_MANY_RELAY_CONNECTIVITY = k_ESteamNetConnectionEnd_Local_ManyRelayConnectivity,\n\tCONNECTION_END_LOCAL_HOSTED_SERVER_PRIMARY_RELAY = k_ESteamNetConnectionEnd_Local_HostedServerPrimaryRelay,\n\tCONNECTION_END_LOCAL_NETWORK_CONFIG = k_ESteamNetConnectionEnd_Local_NetworkConfig,\n\tCONNECTION_END_LOCAL_RIGHTS = k_ESteamNetConnectionEnd_Local_Rights,\n\tCONNECTION_END_NO_PUBLIC_ADDRESS = k_ESteamNetConnectionEnd_Local_P2P_ICE_NoPublicAddresses,\n\tCONNECTION_END_LOCAL_MAX = k_ESteamNetConnectionEnd_Local_Max,\n\tCONNECTION_END_REMOVE_MIN = k_ESteamNetConnectionEnd_Remote_Min,\n\tCONNECTION_END_REMOTE_TIMEOUT = k_ESteamNetConnectionEnd_Remote_Timeout,\n\tCONNECTION_END_REMOTE_BAD_CRYPT = k_ESteamNetConnectionEnd_Remote_BadCrypt,\n\tCONNECTION_END_REMOTE_BAD_CERT = k_ESteamNetConnectionEnd_Remote_BadCert,\n\tCONNECTION_END_BAD_PROTOCOL_VERSION = k_ESteamNetConnectionEnd_Remote_BadProtocolVersion,\n\tCONNECTION_END_REMOTE_P2P_ICE_NO_PUBLIC_ADDRESSES = k_ESteamNetConnectionEnd_Remote_P2P_ICE_NoPublicAddresses,\n\tCONNECTION_END_REMOTE_MAX = k_ESteamNetConnectionEnd_Remote_Max,\n\tCONNECTION_END_MISC_MIN = k_ESteamNetConnectionEnd_Misc_Min,\n\tCONNECTION_END_MISC_GENERIC = k_ESteamNetConnectionEnd_Misc_Generic,\n\tCONNECTION_END_MISC_INTERNAL_ERROR = k_ESteamNetConnectionEnd_Misc_InternalError,\n\tCONNECTION_END_MISC_TIMEOUT = k_ESteamNetConnectionEnd_Misc_Timeout,\n\tCONNECTION_END_MISC_STEAM_CONNECTIVITY = k_ESteamNetConnectionEnd_Misc_SteamConnectivity,\n\tCONNECTION_END_MISC_NO_RELAY_SESSIONS_TO_CLIENT = k_ESteamNetConnectionEnd_Misc_NoRelaySessionsToClient,\n\tCONNECTION_END_MISC_P2P_RENDEZVOUS = k_ESteamNetConnectionEnd_Misc_P2P_Rendezvous,\n\tCONNECTION_END_MISC_P2P_NAT_FIREWALL = k_ESteamNetConnectionEnd_Misc_P2P_NAT_Firewall,\n\tCONNECTION_END_MISC_PEER_SENT_NO_CONNECTION = k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection,\n\tCONNECTION_END_MISC_MAX = k_ESteamNetConnectionEnd_Misc_Max,\n\tCONNECTION_END_FORCE32BIT = k_ESteamNetConnectionEnd__Force32Bit\n};\n\nenum NetworkingConnectionState {\n\tCONNECTION_STATE_NONE = k_ESteamNetworkingConnectionState_None,\n\tCONNECTION_STATE_CONNECTING = k_ESteamNetworkingConnectionState_Connecting,\n\tCONNECTION_STATE_FINDING_ROUTE = k_ESteamNetworkingConnectionState_FindingRoute,\n\tCONNECTION_STATE_CONNECTED = k_ESteamNetworkingConnectionState_Connected,\n\tCONNECTION_STATE_CLOSED_BY_PEER = k_ESteamNetworkingConnectionState_ClosedByPeer,\n\tCONNECTION_STATE_PROBLEM_DETECTED_LOCALLY = k_ESteamNetworkingConnectionState_ProblemDetectedLocally,\n\tCONNECTION_STATE_FIN_WAIT = k_ESteamNetworkingConnectionState_FinWait,\n\tCONNECTION_STATE_LINGER = k_ESteamNetworkingConnectionState_Linger,\n\tCONNECTION_STATE_DEAD = k_ESteamNetworkingConnectionState_Dead,\n\tCONNECTION_STATE_FORCE_32BIT = k_ESteamNetworkingConnectionState__Force32Bit\n};\n\nenum NetworkingFakeIPType {\n\tFAKE_IP_TYPE_INVALID = k_ESteamNetworkingFakeIPType_Invalid,\n\tFAKE_IP_TYPE_NOT_FAKE = k_ESteamNetworkingFakeIPType_NotFake,\n\tFAKE_IP_TYPE_GLOBAL_IPV4 = k_ESteamNetworkingFakeIPType_GlobalIPv4,\n\tFAKE_IP_TYPE_LOCAL_IPV4 = k_ESteamNetworkingFakeIPType_LocalIPv4,\n\tFAKE_IP_TYPE_FORCE32BIT = k_ESteamNetworkingFakeIPType__Force32Bit\n};\n\nenum NetworkingGetConfigValueResult {\n\tNETWORKING_GET_CONFIG_VALUE_BAD_VALUE = k_ESteamNetworkingGetConfigValue_BadValue,\n\tNETWORKING_GET_CONFIG_VALUE_BAD_SCOPE_OBJ = k_ESteamNetworkingGetConfigValue_BadScopeObj,\n\tNETWORKING_GET_CONFIG_VALUE_BUFFER_TOO_SMALL = k_ESteamNetworkingGetConfigValue_BufferTooSmall,\n\tNETWORKING_GET_CONFIG_VALUE_OK = k_ESteamNetworkingGetConfigValue_OK,\n\tNETWORKING_GET_CONFIG_VALUE_OK_INHERITED = k_ESteamNetworkingGetConfigValue_OKInherited,\n\tNETWORKING_GET_CONFIG_VALUE_FORCE_32BIT = k_ESteamNetworkingGetConfigValueResult__Force32Bit\n};\n\nenum NetworkingIdentityType {\n\tIDENTITY_TYPE_INVALID = k_ESteamNetworkingIdentityType_Invalid,\n\tIDENTITY_TYPE_STEAMID = k_ESteamNetworkingIdentityType_SteamID,\n\tIDENTITY_TYPE_IP_ADDRESS = k_ESteamNetworkingIdentityType_IPAddress,\n\tIDENTITY_TYPE_GENERIC_STRING = k_ESteamNetworkingIdentityType_GenericString,\n\tIDENTITY_TYPE_GENERIC_BYTES = k_ESteamNetworkingIdentityType_GenericBytes,\n\tIDENTITY_TYPE_UNKNOWN_TYPE = k_ESteamNetworkingIdentityType_UnknownType,\n\tIDENTITY_TYPE_XBOX_PAIRWISE = k_ESteamNetworkingIdentityType_XboxPairwiseID,\n\tIDENTITY_TYPE_SONY_PSN = k_ESteamNetworkingIdentityType_SonyPSN,\n\tIDENTITY_TYPE_FORCE_32BIT = k_ESteamNetworkingIdentityType__Force32bit\n};\n\nenum NetworkingSocketsDebugOutputType {\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_NONE = k_ESteamNetworkingSocketsDebugOutputType_None,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_BUG = k_ESteamNetworkingSocketsDebugOutputType_Bug,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_ERROR = k_ESteamNetworkingSocketsDebugOutputType_Error,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_IMPORTANT = k_ESteamNetworkingSocketsDebugOutputType_Important,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_WARNING = k_ESteamNetworkingSocketsDebugOutputType_Warning,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_MSG = k_ESteamNetworkingSocketsDebugOutputType_Msg,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_VERBOSE = k_ESteamNetworkingSocketsDebugOutputType_Verbose,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_DEBUG = k_ESteamNetworkingSocketsDebugOutputType_Debug,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_EVERYTHING = k_ESteamNetworkingSocketsDebugOutputType_Everything,\n\tNETWORKING_SOCKET_DEBUG_OUTPUT_TYPE_FORCE_32BIT = k_ESteamNetworkingSocketsDebugOutputType__Force32Bit\n};\n\n\n// Networking Utils enums {\nenum NetworkingAvailability {\n\tNETWORKING_AVAILABILITY_CANNOT_TRY = k_ESteamNetworkingAvailability_CannotTry,\n\tNETWORKING_AVAILABILITY_FAILED = k_ESteamNetworkingAvailability_Failed,\n\tNETWORKING_AVAILABILITY_PREVIOUSLY = k_ESteamNetworkingAvailability_Previously,\n\tNETWORKING_AVAILABILITY_RETRYING = k_ESteamNetworkingAvailability_Retrying,\n\tNETWORKING_AVAILABILITY_NEVER_TRIED = k_ESteamNetworkingAvailability_NeverTried,\n\tNETWORKING_AVAILABILITY_WAITING = k_ESteamNetworkingAvailability_Waiting,\n\tNETWORKING_AVAILABILITY_ATTEMPTING = k_ESteamNetworkingAvailability_Attempting,\n\tNETWORKING_AVAILABILITY_CURRENT = k_ESteamNetworkingAvailability_Current,\n\tNETWORKING_AVAILABILITY_UNKNOWN = k_ESteamNetworkingAvailability_Unknown,\n\tNETWORKING_AVAILABILITY_FORCE_32BIT = k_ESteamNetworkingAvailability__Force32bit\n};\n\nenum NetworkingConfigDataType {\n\tNETWORKING_CONFIG_TYPE_INT32 = k_ESteamNetworkingConfig_Int32,\n\tNETWORKING_CONFIG_TYPE_INT64 = k_ESteamNetworkingConfig_Int64,\n\tNETWORKING_CONFIG_TYPE_FLOAT = k_ESteamNetworkingConfig_Float,\n\tNETWORKING_CONFIG_TYPE_STRING = k_ESteamNetworkingConfig_String,\n\tNETWORKING_CONFIG_TYPE_FUNCTION_PTR = k_ESteamNetworkingConfig_Ptr,\n\tNETWORKING_CONFIG_TYPE_FORCE_32BIT = k_ESteamNetworkingConfigDataType__Force32Bit\n};\n\nenum NetworkingConfigScope {\n\tNETWORKING_CONFIG_SCOPE_GLOBAL = k_ESteamNetworkingConfig_Global,\n\tNETWORKING_CONFIG_SCOPE_SOCKETS_INTERFACE = k_ESteamNetworkingConfig_SocketsInterface,\n\tNETWORKING_CONFIG_SCOPE_LISTEN_SOCKET = k_ESteamNetworkingConfig_ListenSocket,\n\tNETWORKING_CONFIG_SCOPE_CONNECTION = k_ESteamNetworkingConfig_Connection,\n\tNETWORKING_CONFIG_SCOPE_FORCE_32BIT = k_ESteamNetworkingConfigScope__Force32Bit\n};\n\n\n// Parental Settings enums\nenum ParentalFeature {\n\tFEATURE_INVALID = k_EFeatureInvalid,\n\tFEATURE_STORE = k_EFeatureStore,\n\tFEATURE_COMMUNITY = k_EFeatureCommunity,\n\tFEATURE_PROFILE = k_EFeatureProfile,\n\tFEATURE_FRIENDS = k_EFeatureFriends,\n\tFEATURE_NEWS = k_EFeatureNews,\n\tFEATURE_TRADING = k_EFeatureTrading,\n\tFEATURE_SETTINGS = k_EFeatureSettings,\n\tFEATURE_CONSOLE = k_EFeatureConsole,\n\tFEATURE_BROWSER = k_EFeatureBrowser,\n\tFEATURE_PARENTAL_SETUP = k_EFeatureParentalSetup,\n\tFEATURE_LIBRARY = k_EFeatureLibrary,\n\tFEATURE_TEST = k_EFeatureTest,\n\tFEATURE_SITE_LICENSE = k_EFeatureSiteLicense,\n\tFEATURE_KIOSK_MODE = k_EFeatureKioskMode_Deprecated,\n\tFEATURE_BLOCK_ALWAYS = k_EFeatureBlockAlways,\n\tFEATURE_MAX = k_EFeatureMax\n};\n\n\n// Steam Parties enums\nenum PartyBeaconLocationData {\n\tSTEAM_PARTY_BEACON_LOCATION_DATA = k_ESteamPartyBeaconLocationDataInvalid,\n\tSTEAM_PARTY_BEACON_LOCATION_DATA_NAME = k_ESteamPartyBeaconLocationDataName,\n\tSTEAM_PARTY_BEACON_LOCATION_DATA_URL_SMALL = k_ESteamPartyBeaconLocationDataIconURLSmall,\n\tSTEAM_PARTY_BEACON_LOCATION_DATA_URL_MEDIUM = k_ESteamPartyBeaconLocationDataIconURLMedium,\n\tSTEAM_PARTY_BEACON_LOCATION_DATA_URL_LARGE = k_ESteamPartyBeaconLocationDataIconURLLarge\n};\nenum PartyBeaconLocationType {\n\tSTEAM_PARTY_BEACON_LOCATIONTYPE_INVALID = k_ESteamPartyBeaconLocationType_Invalid,\n\tSTEAM_PARTY_BEACON_LOCATIONTYPE_CHAT_GROUP = k_ESteamPartyBeaconLocationType_ChatGroup,\n\tSTEAM_PARTY_BEACON_LOCATION_TYPE_MAX = k_ESteamPartyBeaconLocationType_Max\n};\n\n\n// Remote Play enums\nenum DeviceFormFactor {\n\tFORM_FACTOR_UNKNOWN = k_ESteamDeviceFormFactorUnknown,\n\tFORM_FACTOR_PHONE = k_ESteamDeviceFormFactorPhone,\n\tFORM_FACTOR_TABLET = k_ESteamDeviceFormFactorTablet,\n\tFORM_FACTOR_COMPUTER = k_ESteamDeviceFormFactorComputer,\n\tFORM_FACTOR_TV = k_ESteamDeviceFormFactorTV,\n\tFORM_FACTOR_VR_HEADSET = k_ESteamDeviceFormFactorVRHeadset\n};\n\n\n// Remote Storage enums\nenum FilePathType {\n\tFILE_PATH_TYPE_INVALID = k_ERemoteStorageFilePathType_Invalid,\n\tFILE_PATH_TYPE_ABSOLUTE = k_ERemoteStorageFilePathType_Absolute,\n\tFILE_PATH_TYPE_API_FILENAME = k_ERemoteStorageFilePathType_APIFilename\n};\n\nenum LocalFileChange {\n\tLOCAL_FILE_CHANGE_INVALID = k_ERemoteStorageLocalFileChange_Invalid,\n\tLOCAL_FILE_CHANGE_FILE_UPDATED = k_ERemoteStorageLocalFileChange_FileUpdated,\n\tLOCAL_FILE_CHANGE_FILE_DELETED = k_ERemoteStorageLocalFileChange_FileDeleted\n};\n\nenum RemoteStoragePlatform : uint32_t {\n\tREMOTE_STORAGE_PLATFORM_NONE = k_ERemoteStoragePlatformNone,\n\tREMOTE_STORAGE_PLATFORM_WINDOWS = k_ERemoteStoragePlatformWindows,\n\tREMOTE_STORAGE_PLATFORM_OSX = k_ERemoteStoragePlatformOSX,\n\tREMOTE_STORAGE_PLATFORM_PS3 = k_ERemoteStoragePlatformPS3,\n\tREMOTE_STORAGE_PLATFORM_LINUX = k_ERemoteStoragePlatformLinux,\n\tREMOTE_STORAGE_PLATFORM_SWITCH = k_ERemoteStoragePlatformSwitch,\n\tREMOTE_STORAGE_PLATFORM_ANDROID = k_ERemoteStoragePlatformAndroid,\n\tREMOTE_STORAGE_PLATFORM_IOS = k_ERemoteStoragePlatformIOS,\n\tREMOTE_STORAGE_PLATFORM_ALL = k_ERemoteStoragePlatformAll\n};\n\nenum RemoteStoragePublishedFileVisibility {\n\tREMOTE_STORAGE_PUBLISHED_VISIBILITY_PUBLIC = k_ERemoteStoragePublishedFileVisibilityPublic,\n\tREMOTE_STORAGE_PUBLISHED_VISIBILITY_FRIENDS_ONLY = k_ERemoteStoragePublishedFileVisibilityFriendsOnly,\n\tREMOTE_STORAGE_PUBLISHED_VISIBILITY_PRIVATE = k_ERemoteStoragePublishedFileVisibilityPrivate,\n\tREMOTE_STORAGE_PUBLISHED_VISIBILITY_UNLISTED = k_ERemoteStoragePublishedFileVisibilityUnlisted\n};\n\nenum UGCReadAction {\n\tUGC_READ_CONTINUE_READING_UNTIL_FINISHED = k_EUGCRead_ContinueReadingUntilFinished,\n\tUGC_READ_CONTINUE_READING = k_EUGCRead_ContinueReading,\n\tUGC_READ_CLOSE = k_EUGCRead_Close\n};\n\nenum WorkshopEnumerationType {\n\tWORKSHOP_ENUMERATION_TYPE_RANKED_BY_VOTE = k_EWorkshopEnumerationTypeRankedByVote,\n\tWORKSHOP_ENUMERATION_TYPE_RECENT = k_EWorkshopEnumerationTypeRecent,\n\tWORKSHOP_ENUMERATION_TYPE_TRENDING = k_EWorkshopEnumerationTypeTrending,\n\tWORKSHOP_ENUMERATION_TYPE_FAVORITES_OF_FRIENDS = k_EWorkshopEnumerationTypeFavoritesOfFriends,\n\tWORKSHOP_ENUMERATION_TYPE_VOTED_BY_FRIENDS = k_EWorkshopEnumerationTypeVotedByFriends,\n\tWORKSHOP_ENUMERATION_TYPE_CONTENT_BY_FRIENDS = k_EWorkshopEnumerationTypeContentByFriends,\n\tWORKSHOP_ENUMERATION_TYPE_RECENT_FROM_FOLLOWED_USERS = k_EWorkshopEnumerationTypeRecentFromFollowedUsers\n};\n\nenum WorkshopFileAction {\n\tWORKSHOP_FILE_ACTION_PLAYED = k_EWorkshopFileActionPlayed,\n\tWORKSHOP_FILE_ACTION_COMPLETED = k_EWorkshopFileActionCompleted\n};\n\nenum WorkshopFileType {\n\tWORKSHOP_FILE_TYPE_FIRST = k_EWorkshopFileTypeFirst,\n\tWORKSHOP_FILE_TYPE_COMMUNITY = k_EWorkshopFileTypeCommunity,\n\tWORKSHOP_FILE_TYPE_MICROTRANSACTION = k_EWorkshopFileTypeMicrotransaction,\n\tWORKSHOP_FILE_TYPE_COLLECTION = k_EWorkshopFileTypeCollection,\n\tWORKSHOP_FILE_TYPE_ART = k_EWorkshopFileTypeArt,\n\tWORKSHOP_FILE_TYPE_VIDEO = k_EWorkshopFileTypeVideo,\n\tWORKSHOP_FILE_TYPE_SCREENSHOT = k_EWorkshopFileTypeScreenshot,\n\tWORKSHOP_FILE_TYPE_GAME = k_EWorkshopFileTypeGame,\n\tWORKSHOP_FILE_TYPE_SOFTWARE = k_EWorkshopFileTypeSoftware,\n\tWORKSHOP_FILE_TYPE_CONCEPT = k_EWorkshopFileTypeConcept,\n\tWORKSHOP_FILE_TYPE_WEB_GUIDE = k_EWorkshopFileTypeWebGuide,\n\tWORKSHOP_FILE_TYPE_INTEGRATED_GUIDE = k_EWorkshopFileTypeIntegratedGuide,\n\tWORKSHOP_FILE_TYPE_MERCH = k_EWorkshopFileTypeMerch,\n\tWORKSHOP_FILE_TYPE_CONTROLLER_BINDING = k_EWorkshopFileTypeControllerBinding,\n\tWORKSHOP_FILE_TYPE_STEAMWORKS_ACCESS_INVITE = k_EWorkshopFileTypeSteamworksAccessInvite,\n\tWORKSHOP_FILE_TYPE_STEAM_VIDEO = k_EWorkshopFileTypeSteamVideo,\n\tWORKSHOP_FILE_TYPE_GAME_MANAGED_ITEM = k_EWorkshopFileTypeGameManagedItem,\n\tWORKSHOP_FILE_TYPE_CLIP = k_EWorkshopFileTypeClip,\n\tWORKSHOP_FILE_TYPE_MAX = k_EWorkshopFileTypeMax\n};\n\nenum WorkshopVideoProvider {\n\tWORKSHOP_VIDEO_PROVIDER_NONE = k_EWorkshopVideoProviderNone,\n\tWORKSHOP_VIDEO_PROVIDER_YOUTUBE = k_EWorkshopVideoProviderYoutube\n};\n\nenum WorkshopVote {\n\tWORKSHOP_VOTE_UNVOTED = k_EWorkshopVoteUnvoted,\n\tWORKSHOP_VOTE_FOR = k_EWorkshopVoteFor,\n\tWORKSHOP_VOTE_AGAINST = k_EWorkshopVoteAgainst,\n\tWORKSHOP_VOTE_LATER = k_EWorkshopVoteLater\n};\n\n\n// Screenshot enums\nenum VRScreenshotType {\n\tVR_SCREENSHOT_TYPE_NONE = k_EVRScreenshotType_None,\n\tVR_SCREENSHOT_TYPE_MONO = k_EVRScreenshotType_Mono,\n\tVR_SCREENSHOT_TYPE_STEREO = k_EVRScreenshotType_Stereo,\n\tVR_SCREENSHOT_TYPE_MONO_CUBE_MAP = k_EVRScreenshotType_MonoCubemap,\n\tVR_SCREENSHOT_TYPE_MONO_PANORAMA = k_EVRScreenshotType_MonoPanorama,\n\tVR_SCREENSHOT_TYPE_STEREO_PANORAMA = k_EVRScreenshotType_StereoPanorama\n};\n\n\n// Timeline enums\nenum TimelineGameMode {\n\t// Found in isteamtimeline.h\n\tTIMELINE_GAME_MODE_INVALID = k_ETimelineGameMode_Invalid,\n\tTIMELINE_GAME_MODE_PLAYING = k_ETimelineGameMode_Playing,\n\tTIMELINE_GAME_MODE_STAGING = k_ETimelineGameMode_Staging,\n\tTIMELINE_GAME_MODE_MENUS = k_ETimelineGameMode_Menus,\n\tTIMELINE_GAME_MODE_LOADING_SCREEN = k_ETimelineGameMode_LoadingScreen,\n\tTIMELINE_GAME_MODE_MAX = k_ETimelineGameMode_Max\n};\n\nenum TimelineEventClipPriority {\n\t// Found in isteamtimeline.h\n\tTIMELINE_EVENT_CLIP_PRIORITY_INVALID = k_ETimelineEventClipPriority_Invalid,\n\tTIMELINE_EVENT_CLIP_PRIORITY_NONE = k_ETimelineEventClipPriority_None,\n\tTIMELINE_EVENT_CLIP_PRIORITY_STANDARD = k_ETimelineEventClipPriority_Standard,\n\tTIMELINE_EVENT_CLIP_PRIORITY_FEATURED = k_ETimelineEventClipPriority_Featured\n};\n\n\n// UGC enums\nenum ItemPreviewType {\n\tITEM_PREVIEW_TYPE_IMAGE = k_EItemPreviewType_Image,\n\tITEM_PREVIEW_TYPE_YOUTUBE_VIDEO = k_EItemPreviewType_YouTubeVideo,\n\tITEM_PREVIEW_TYPE_SKETCHFAB = k_EItemPreviewType_Sketchfab,\n\tITEM_PREVIEW_TYPE_ENVIRONMENTMAP_HORIZONTAL_CROSS = k_EItemPreviewType_EnvironmentMap_HorizontalCross,\n\tITEM_PREVIEW_TYPE_ENVIRONMENTMAP_LAT_LONG = k_EItemPreviewType_EnvironmentMap_LatLong,\n\tITEM_PREVIEW_TYPE_CLIP = k_EItemPreviewType_Clip,\n\tITEM_PREVIEW_TYPE_RESERVED_MAX = k_EItemPreviewType_ReservedMax\n};\n\nenum ItemState {\n\tITEM_STATE_NONE = k_EItemStateNone,\n\tITEM_STATE_SUBSCRIBED = k_EItemStateSubscribed,\n\tITEM_STATE_LEGACY_ITEM = k_EItemStateLegacyItem,\n\tITEM_STATE_INSTALLED = k_EItemStateInstalled,\n\tITEM_STATE_NEEDS_UPDATE = k_EItemStateNeedsUpdate,\n\tITEM_STATE_DOWNLOADING = k_EItemStateDownloading,\n\tITEM_STATE_DOWNLOAD_PENDING = k_EItemStateDownloadPending,\n\tITEM_STATE_DISABLED_LOCALLY = k_EItemStateDisabledLocally\n};\n\nenum ItemStatistic {\n\tITEM_STATISTIC_NUM_SUBSCRIPTIONS = k_EItemStatistic_NumSubscriptions,\n\tITEM_STATISTIC_NUM_FAVORITES = k_EItemStatistic_NumFavorites,\n\tITEM_STATISTIC_NUM_FOLLOWERS = k_EItemStatistic_NumFollowers,\n\tITEM_STATISTIC_NUM_UNIQUE_SUBSCRIPTIONS = k_EItemStatistic_NumUniqueSubscriptions,\n\tITEM_STATISTIC_NUM_UNIQUE_FAVORITES = k_EItemStatistic_NumUniqueFavorites,\n\tITEM_STATISTIC_NUM_UNIQUE_FOLLOWERS = k_EItemStatistic_NumUniqueFollowers,\n\tITEM_STATISTIC_NUM_UNIQUE_WEBSITE_VIEWS = k_EItemStatistic_NumUniqueWebsiteViews,\n\tITEM_STATISTIC_REPORT_SCORE = k_EItemStatistic_ReportScore,\n\tITEM_STATISTIC_NUM_SECONDS_PLAYED = k_EItemStatistic_NumSecondsPlayed,\n\tITEM_STATISTIC_NUM_PLAYTIME_SESSIONS = k_EItemStatistic_NumPlaytimeSessions,\n\tITEM_STATISTIC_NUM_COMMENTS = k_EItemStatistic_NumComments,\n\tITEM_STATISTIC_NUM_SECONDS_PLAYED_DURING_TIME_PERIOD = k_EItemStatistic_NumSecondsPlayedDuringTimePeriod,\n\tITEM_STATISTIC_NUM_PLAYTIME_SESSIONS_DURING_TIME_PERIOD = k_EItemStatistic_NumPlaytimeSessionsDuringTimePeriod\n};\n\nenum ItemUpdateStatus {\n\tITEM_UPDATE_STATUS_INVALID = k_EItemUpdateStatusInvalid,\n\tITEM_UPDATE_STATUS_PREPARING_CONFIG = k_EItemUpdateStatusPreparingConfig,\n\tITEM_UPDATE_STATUS_PREPARING_CONTENT = k_EItemUpdateStatusPreparingContent,\n\tITEM_UPDATE_STATUS_UPLOADING_CONTENT = k_EItemUpdateStatusUploadingContent,\n\tITEM_UPDATE_STATUS_UPLOADING_PREVIEW_FILE = k_EItemUpdateStatusUploadingPreviewFile,\n\tITEM_UPDATE_STATUS_COMMITTING_CHANGES = k_EItemUpdateStatusCommittingChanges\n};\n\nenum UGCContentDescriptorID {\n\tUGC_CONTENT_DESCRIPTOR_NUDITY_OR_SEXUAL_CONTENT = k_EUGCContentDescriptor_NudityOrSexualContent,\n\tUGC_CONTENT_DESCRIPTOR_FREQUENT_VIOLENCE_OR_GORE = k_EUGCContentDescriptor_FrequentViolenceOrGore,\n\tUGC_CONTENT_DESCRIPTOR_ADULT_ONLY_SEXUAL_CONTENT = k_EUGCContentDescriptor_AdultOnlySexualContent,\n\tUGC_CONTENT_DESCRIPTOR_GRATUITOUS_SEXUAL_CONTENT = k_EUGCContentDescriptor_GratuitousSexualContent,\n\tUGC_CONTENT_DESCRIPTOR_ANY_MATURE_CONTENT = k_EUGCContentDescriptor_AnyMatureContent\n};\n\nenum UGCMatchingUGCType {\n\tUGC_MATCHING_UGC_TYPE_ITEMS = k_EUGCMatchingUGCType_Items,\n\tUGC_MATCHING_UGC_TYPE_ITEMS_MTX = k_EUGCMatchingUGCType_Items_Mtx,\n\tUGC_MATCHING_UGC_TYPE_ITEMS_READY_TO_USE = k_EUGCMatchingUGCType_Items_ReadyToUse,\n\tUGC_MATCHING_UGC_TYPE_COLLECTIONS = k_EUGCMatchingUGCType_Collections,\n\tUGC_MATCHING_UGC_TYPE_ARTWORK = k_EUGCMatchingUGCType_Artwork,\n\tUGC_MATCHING_UGC_TYPE_VIDEOS = k_EUGCMatchingUGCType_Videos,\n\tUGC_MATCHING_UGC_TYPE_SCREENSHOTS = k_EUGCMatchingUGCType_Screenshots,\n\tUGC_MATCHING_UGC_TYPE_ALL_GUIDES = k_EUGCMatchingUGCType_AllGuides,\n\tUGC_MATCHING_UGC_TYPE_WEB_GUIDES = k_EUGCMatchingUGCType_WebGuides,\n\tUGC_MATCHING_UGC_TYPE_INTEGRATED_GUIDES = k_EUGCMatchingUGCType_IntegratedGuides,\n\tUGC_MATCHING_UGC_TYPE_USABLE_IN_GAME = k_EUGCMatchingUGCType_UsableInGame,\n\tUGC_MATCHING_UGC_TYPE_CONTROLLER_BINDINGS = k_EUGCMatchingUGCType_ControllerBindings,\n\tUGC_MATCHING_UGC_TYPE_GAME_MANAGED_ITEMS = k_EUGCMatchingUGCType_GameManagedItems,\n\tUGC_MATCHING_UGC_TYPE_ALL = k_EUGCMatchingUGCType_All\n};\n\nenum UGCQuery {\n\tUGC_QUERY_RANKED_BY_VOTE = k_EUGCQuery_RankedByVote,\n\tUGC_QUERY_RANKED_BY_PUBLICATION_DATE = k_EUGCQuery_RankedByPublicationDate,\n\tUGC_QUERY_ACCEPTED_FOR_GAME_RANKED_BY_ACCEPTANCE_DATE = k_EUGCQuery_AcceptedForGameRankedByAcceptanceDate,\n\tUGC_QUERY_RANKED_BY_TREND = k_EUGCQuery_RankedByTrend,\n\tUGC_QUERY_FAVORITED_BY_FRIENDS_RANKED_BY_PUBLICATION_DATE = k_EUGCQuery_FavoritedByFriendsRankedByPublicationDate,\n\tUGC_QUERY_CREATED_BY_FRIENDS_RANKED_BY_PUBLICATION_DATE = k_EUGCQuery_CreatedByFriendsRankedByPublicationDate,\n\tUGC_QUERY_RANKED_BY_NUM_TIMES_REPORTED = k_EUGCQuery_RankedByNumTimesReported,\n\tUGC_QUERY_CREATED_BY_FOLLOWED_USERS_RANKED_BY_PUBLICATION_DATE = k_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate,\n\tUGC_QUERY_NOT_YET_RATED = k_EUGCQuery_NotYetRated,\n\tUGC_QUERY_RANKED_BY_TOTAL_VOTES_ASC = k_EUGCQuery_RankedByTotalVotesAsc,\n\tUGC_QUERY_RANKED_BY_VOTES_UP = k_EUGCQuery_RankedByVotesUp,\n\tUGC_QUERY_RANKED_BY_TEXT_SEARCH = k_EUGCQuery_RankedByTextSearch,\n\tUGC_QUERY_RANKED_BY_TOTAL_UNIQUE_SUBSCRIPTIONS = k_EUGCQuery_RankedByTotalUniqueSubscriptions,\n\tUGC_QUERY_RANKED_BY_PLAYTIME_TREND = k_EUGCQuery_RankedByPlaytimeTrend,\n\tUGC_QUERY_RANKED_BY_TOTAL_PLAYTIME = k_EUGCQuery_RankedByTotalPlaytime,\n\tUGC_QUERY_RANKED_BY_AVERAGE_PLAYTIME_TREND = k_EUGCQuery_RankedByAveragePlaytimeTrend,\n\tUGC_QUERY_RANKED_BY_LIFETIME_AVERAGE_PLAYTIME = k_EUGCQuery_RankedByLifetimeAveragePlaytime,\n\tUGC_QUERY_RANKED_BY_PLAYTIME_SESSIONS_TREND = k_EUGCQuery_RankedByPlaytimeSessionsTrend,\n\tUGC_QUERY_RANKED_BY_LIFETIME_PLAYTIME_SESSIONS = k_EUGCQuery_RankedByLifetimePlaytimeSessions,\n\tUGC_QUERY_RANKED_BY_LAST_UPDATED_DATE = k_EUGCQuery_RankedByLastUpdatedDate\n};\n\nenum UserUGCList {\n\tUSER_UGC_LIST_PUBLISHED = k_EUserUGCList_Published,\n\tUSER_UGC_LIST_VOTED_ON = k_EUserUGCList_VotedOn,\n\tUSER_UGC_LIST_VOTED_UP = k_EUserUGCList_VotedUp,\n\tUSER_UGC_LIST_VOTED_DOWN = k_EUserUGCList_VotedDown,\n\tUSER_UGC_LIST_WILL_VOTE_LATER = k_EUserUGCList_WillVoteLater,\n\tUSER_UGC_LIST_FAVORITED = k_EUserUGCList_Favorited,\n\tUSER_UGC_LIST_SUBSCRIBED = k_EUserUGCList_Subscribed,\n\tUSER_UGC_LIST_USED_OR_PLAYED = k_EUserUGCList_UsedOrPlayed,\n\tUSER_UGC_LIST_FOLLOWED = k_EUserUGCList_Followed\n};\n\nenum UserUGCListSortOrder {\n\tUSER_UGC_LIST_SORT_ORDER_CREATION_ORDER_DESC = k_EUserUGCListSortOrder_CreationOrderDesc,\n\tUSER_UGC_LIST_SORT_ORDER_CREATION_ORDER_ASC = k_EUserUGCListSortOrder_CreationOrderAsc,\n\tUSER_UGC_LIST_SORT_ORDER_TITLE_ASC = k_EUserUGCListSortOrder_TitleAsc,\n\tUSER_UGC_LIST_SORT_ORDER_LAST_UPDATED_DESC = k_EUserUGCListSortOrder_LastUpdatedDesc,\n\tUSER_UGC_LIST_SORT_ORDER_SUBSCRIPTION_DATE_DESC = k_EUserUGCListSortOrder_SubscriptionDateDesc,\n\tUSER_UGC_LIST_SORT_ORDER_VOTE_SCORE_DESC = k_EUserUGCListSortOrder_VoteScoreDesc,\n\tUSER_UGC_LIST_SORT_ORDER_FOR_MODERATION = k_EUserUGCListSortOrder_ForModeration\n};\n\n\n// User enums\nenum DurationControlNotification {\n\t// Found in steamclientpublic.h\n\tDURATION_CONTROL_NOTIFICATION_NONE = k_EDurationControlNotification_None,\n\tDURATION_CONTROL_NOTIFICATION_1_HOUR = k_EDurationControlNotification_1Hour,\n\tDURATION_CONTROL_NOTIFICATION_3_HOURS = k_EDurationControlNotification_3Hours,\n\tDURATION_CONTROL_NOTIFICATION_HALF_PROGRESS = k_EDurationControlNotification_HalfProgress,\n\tDURATION_CONTROL_NOTIFICATION_NO_PROGRESS = k_EDurationControlNotification_NoProgress,\n\tDURATION_CONTROL_NOTIFICATION_EXIT_SOON_3H = k_EDurationControlNotification_ExitSoon_3h,\n\tDURATION_CONTROL_NOTIFICATION_EXIT_SOON_5H = k_EDurationControlNotification_ExitSoon_5h,\n\tDURATION_CONTROL_NOTIFICATION_EXIT_SOON_NIGHT = k_EDurationControlNotification_ExitSoon_Night\n};\n\nenum DurationControlOnlineState {\n\t// Found in steamclientpublic.h\n\tDURATION_CONTROL_ONLINE_STATE_INVALID = k_EDurationControlOnlineState_Invalid,\n\tDURATION_CONTROL_ONLINE_STATE_OFFLINE = k_EDurationControlOnlineState_Offline,\n\tDURATION_CONTROL_ONLINE_STATE_ONLINE = k_EDurationControlOnlineState_Online,\n\tDURATION_CONTROL_ONLINE_STATE_ONLINE_HIGH_PRIORITY = k_EDurationControlOnlineState_OnlineHighPri\n};\n\nenum DurationControlProgress {\n\t// Found in steamclientpublic.h\n\tDURATION_CONTROL_PROGRESS_FULL = k_EDurationControlProgress_Full,\n\tDURATION_CONTROL_PROGRESS_HALF = k_EDurationControlProgress_Half,\n\tDURATION_CONTROL_PROGRESS_NONE = k_EDurationControlProgress_None,\n\tDURATION_CONTROL_EXIT_SOON_3H = k_EDurationControl_ExitSoon_3h,\n\tDURATION_CONTROL_EXIT_SOON_5H = k_EDurationControl_ExitSoon_5h,\n\tDURATION_CONTROL_EXIT_SOON_NIGHT = k_EDurationControl_ExitSoon_Night\n};\n\n\n// User Stats enums\nenum LeaderboardDataRequest {\n\tLEADERBOARD_DATA_REQUEST_GLOBAL = k_ELeaderboardDataRequestGlobal,\n\tLEADERBOARD_DATA_REQUEST_GLOBAL_AROUND_USER = k_ELeaderboardDataRequestGlobalAroundUser,\n\tLEADERBOARD_DATA_REQUEST_FRIENDS = k_ELeaderboardDataRequestFriends,\n\tLEADERBOARD_DATA_REQUEST_USERS = k_ELeaderboardDataRequestUsers\n};\n\nenum LeaderboardDisplayType {\n\tLEADERBOARD_DISPLAY_TYPE_NONE = k_ELeaderboardDisplayTypeNone,\n\tLEADERBOARD_DISPLAY_TYPE_NUMERIC = k_ELeaderboardDisplayTypeNumeric,\n\tLEADERBOARD_DISPLAY_TYPE_TIME_SECONDS = k_ELeaderboardDisplayTypeTimeSeconds,\n\tLEADERBOARD_DISPLAY_TYPE_TIME_MILLISECONDS = k_ELeaderboardDisplayTypeTimeMilliSeconds\n};\n\nenum LeaderboardSortMethod {\n\tLEADERBOARD_SORT_METHOD_NONE = k_ELeaderboardSortMethodNone,\n\tLEADERBOARD_SORT_METHOD_ASCENDING = k_ELeaderboardSortMethodAscending,\n\tLEADERBOARD_SORT_METHOD_DESCENDING = k_ELeaderboardSortMethodDescending\n};\n\nenum LeaderboardUploadScoreMethod {\n\tLEADERBOARD_UPLOAD_SCORE_METHOD_NONE = k_ELeaderboardUploadScoreMethodNone,\n\tLEADERBOARD_UPLOAD_SCORE_METHOD_KEEP_BEST = k_ELeaderboardUploadScoreMethodKeepBest,\n\tLEADERBOARD_UPLOAD_SCORE_METHOD_FORCE_UPDATE = k_ELeaderboardUploadScoreMethodForceUpdate\n};\n\n\n// Utils enums\nenum CheckFileSignature {\n\tCHECK_FILE_SIGNATURE_INVALID_SIGNATURE = k_ECheckFileSignatureInvalidSignature,\n\tCHECK_FILE_SIGNATURE_VALID_SIGNATURE = k_ECheckFileSignatureValidSignature,\n\tCHECK_FILE_SIGNATURE_FILE_NOT_FOUND = k_ECheckFileSignatureFileNotFound,\n\tCHECK_FILE_SIGNATURE_NO_SIGNATURES_FOUND_FOR_THIS_APP = k_ECheckFileSignatureNoSignaturesFoundForThisApp,\n\tCHECK_FILE_SIGNATURE_NO_SIGNATURES_FOUND_FOR_THIS_FILE = k_ECheckFileSignatureNoSignaturesFoundForThisFile\n};\n\nenum GamepadTextInputLineMode {\n\tGAMEPAD_TEXT_INPUT_LINE_MODE_SINGLE_LINE = k_EGamepadTextInputLineModeSingleLine,\n\tGAMEPAD_TEXT_INPUT_LINE_MODE_MULTIPLE_LINES = k_EGamepadTextInputLineModeMultipleLines\n};\n\nenum GamepadTextInputMode {\n\tGAMEPAD_TEXT_INPUT_MODE_NORMAL = k_EGamepadTextInputModeNormal,\n\tGAMEPAD_TEXT_INPUT_MODE_PASSWORD = k_EGamepadTextInputModePassword\n};\n\nenum FloatingGamepadTextInputMode {\n\tFLOATING_GAMEPAD_TEXT_INPUT_MODE_SINGLE_LINE = k_EFloatingGamepadTextInputModeModeSingleLine,\n\tFLOATING_GAMEPAD_TEXT_INPUT_MODE_MULTIPLE_LINES = k_EFloatingGamepadTextInputModeModeMultipleLines,\n\tFLOATING_GAMEPAD_TEXT_INPUT_MODE_EMAIL = k_EFloatingGamepadTextInputModeModeEmail,\n\tFLOATING_GAMEPAD_TEXT_INPUT_MODE_NUMERIC = k_EFloatingGamepadTextInputModeModeNumeric\n};\n\nenum APICallFailure {\n\tSTEAM_API_CALL_FAILURE_NONE = k_ESteamAPICallFailureNone,\n\tSTEAM_API_CALL_FAILURE_STEAM_GONE = k_ESteamAPICallFailureSteamGone,\n\tSTEAM_API_CALL_FAILURE_NETWORK_FAILURE = k_ESteamAPICallFailureNetworkFailure,\n\tSTEAM_API_CALL_FAILURE_INVALID_HANDLE = k_ESteamAPICallFailureInvalidHandle,\n\tSTEAM_API_CALL_FAILURE_MISMATCHED_CALLBACK = k_ESteamAPICallFailureMismatchedCallback\n};\n\nenum TextFilteringContext {\n\tTEXT_FILTERING_CONTEXT_UNKNOWN = k_ETextFilteringContextUnknown,\n\tTEXT_FILTERING_CONTEXT_GAME_CONTENT = k_ETextFilteringContextGameContent,\n\tTEXT_FILTERING_CONTEXT_CHAT = k_ETextFilteringContextChat,\n\tTEXT_FILTERING_CONTEXT_NAME = k_ETextFilteringContextName\n};\n\n\n#endif // GODOTSTEAM_ENUMS_H"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.06640625,
          "content": "MIT License\n\nCopyright (c) 2015-Current | GP Garcia and Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "register_types.cpp",
          "type": "blob",
          "size": 0.6142578125,
          "content": "#include \"register_types.h\"\n#include \"core/object/class_db.h\"\n#include \"core/config/engine.h\"\n#include \"godotsteam.h\"\n\nstatic Steam* SteamPtr = NULL;\n\nvoid initialize_godotsteam_module(ModuleInitializationLevel level){\n\tif(level == MODULE_INITIALIZATION_LEVEL_SERVERS){\n\t\tGDREGISTER_CLASS(Steam);\n\t\tSteamPtr = memnew(Steam);\n\t\tEngine::get_singleton()->add_singleton(Engine::Singleton(\"Steam\", Steam::get_singleton()));\n\t}\n}\n\n\nvoid uninitialize_godotsteam_module(ModuleInitializationLevel level){\n\tif(level == MODULE_INITIALIZATION_LEVEL_SERVERS){\n\t\tEngine::get_singleton()->remove_singleton(\"Steam\");\n\t\tmemdelete(SteamPtr);\n\t}\n}\n"
        },
        {
          "name": "register_types.h",
          "type": "blob",
          "size": 0.255859375,
          "content": "#ifndef GODOTSTEAM_REGISTER_TYPES_H\n#define GODOTSTEAM_REGISTER_TYPES_H\n\n#include \"modules/register_module_types.h\"\n\nvoid initialize_godotsteam_module(ModuleInitializationLevel level);\nvoid uninitialize_godotsteam_module(ModuleInitializationLevel level);\n\n#endif"
        },
        {
          "name": "sdk",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}