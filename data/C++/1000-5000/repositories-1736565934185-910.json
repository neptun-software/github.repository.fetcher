{
  "metadata": {
    "timestamp": 1736565934185,
    "page": 910,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lucasb-eyer/pydensecrf",
      "stars": 1964,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6826171875,
          "content": "\nbuild\n*.so\n*.egg-info\n\npydensecrf/eigen.cpp\npydensecrf/densecrf.cpp\n\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\n\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Lucas Beyer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.158203125,
          "content": "include pydensecrf/eigen.pxd\ninclude pydensecrf/eigen.pyx\ninclude pydensecrf/densecrf.pxd\ninclude pydensecrf/densecrf.pyx\nrecursive-include pydensecrf/densecrf *\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0419921875,
          "content": "PyDenseCRF\n==========\n\nThis is a (Cython-based) Python wrapper for [Philipp Krähenbühl's Fully-Connected CRFs](http://web.archive.org/web/20161023180357/http://www.philkr.net/home/densecrf) (version 2, [new, incomplete page](http://www.philkr.net/2011/12/01/nips/)).\n\nIf you use this code for your reasearch, please cite:\n\n```\nEfficient Inference in Fully Connected CRFs with Gaussian Edge Potentials\nPhilipp Krähenbühl and Vladlen Koltun\nNIPS 2011\n```\n\nand provide a link to this repository as a footnote or a citation.\n\nInstallation\n============\n\nThe package is on PyPI, so simply run `pip install pydensecrf` to install it.\n\nIf you want the newest and freshest version, you can install it by executing:\n\n```\npip install git+https://github.com/lucasb-eyer/pydensecrf.git\n```\n\nand ignoring all the warnings coming from Eigen.\n\nNote that you need a relatively recent version of Cython (at least version 0.22) for this wrapper,\nthe one shipped with Ubuntu 14.04 is too old. (Thanks to Scott Wehrwein for pointing this out.)\nI suggest you use a [virtual environment](https://virtualenv.readthedocs.org/en/latest/) and install\nthe newest version of Cython there (`pip install cython`), but you may update the system version by\n\n```\nsudo apt-get remove cython\nsudo pip install -U cython\n```\n\n### Problems on Windows/VS\n\nSince this library needs to compile C++ code, installation can be a little more problematic than pure Python packages.\nMake sure to [have Cython installed](https://github.com/lucasb-eyer/pydensecrf/issues/62#issuecomment-400563257) or try [installing via conda instead](https://github.com/lucasb-eyer/pydensecrf/issues/69#issuecomment-400639881) if you are getting problems.\nPRs that improve Windows support are welcome.\n\n### Problems on Colab/Kaggle Kernel\n\n`pydensecrf` does not come pre-installed in Colab or Kaggle Kernel. Running `pip install pydensecrf` will result into\nbuild failures. Follow these steps instead for Colab/Kaggle Kernel:\n\n```\npip install -U cython\npip install git+https://github.com/lucasb-eyer/pydensecrf.git\n```\n\nUsage\n=====\n\nFor images, the easiest way to use this library is using the `DenseCRF2D` class:\n\n```python\nimport numpy as np\nimport pydensecrf.densecrf as dcrf\n\nd = dcrf.DenseCRF2D(640, 480, 5)  # width, height, nlabels\n```\n\nUnary potential\n---------------\n\nYou can then set a fixed unary potential in the following way:\n\n```python\nU = np.array(...)     # Get the unary in some way.\nprint(U.shape)        # -> (5, 480, 640)\nprint(U.dtype)        # -> dtype('float32')\nU = U.reshape((5,-1)) # Needs to be flat.\nd.setUnaryEnergy(U)\n\n# Or alternatively: d.setUnary(ConstUnary(U))\n```\n\nRemember that `U` should be negative log-probabilities, so if you're using\nprobabilities `py`, don't forget to `U = -np.log(py)` them.\n\nRequiring the `reshape` on the unary is an API wart that I'd like to fix, but\ndon't know how to without introducing an explicit dependency on numpy.\n\n**Note** that the `nlabels` dimension is the first here before the reshape;\nyou may need to move it there before reshaping if that's not already the case,\nlike so:\n\n```python\nprint(U.shape)  # -> (480, 640, 5)\nU = U.transpose(2, 0, 1).reshape((5,-1))\n```\n\n### Getting a Unary\n\nThere's two common ways of getting unary potentials:\n\n1. From a hard labeling generated by a human or some other processing.\n   This case is covered by `from pydensecrf.utils import unary_from_labels`.\n\n2. From a probability distribution computed by, e.g. the softmax output of a\n   deep network. For this, see `from pydensecrf.utils import unary_from_softmax`.\n\nFor usage of both of these, please refer to their docstrings or have a look at [the example](examples/inference.py).\n\nPairwise potentials\n-------------------\n\nThe two-dimensional case has two utility methods for adding the most-common pairwise potentials:\n\n```python\n# This adds the color-independent term, features are the locations only.\nd.addPairwiseGaussian(sxy=(3,3), compat=3, kernel=dcrf.DIAG_KERNEL, normalization=dcrf.NORMALIZE_SYMMETRIC)\n\n# This adds the color-dependent term, i.e. features are (x,y,r,g,b).\n# im is an image-array, e.g. im.dtype == np.uint8 and im.shape == (640,480,3)\nd.addPairwiseBilateral(sxy=(80,80), srgb=(13,13,13), rgbim=im, compat=10, kernel=dcrf.DIAG_KERNEL, normalization=dcrf.NORMALIZE_SYMMETRIC)\n```\n\nBoth of these methods have shortcuts and default-arguments such that the most\ncommon use-case can be simplified to:\n\n```python\nd.addPairwiseGaussian(sxy=3, compat=3)\nd.addPairwiseBilateral(sxy=80, srgb=13, rgbim=im, compat=10)\n```\n\nThe parameters map to those in the paper as follows: `sxy` in the `Gaussian` case is `$\\theta_{\\gamma}$`,\nand in the `Bilateral` case, `sxy` and `srgb` map to `$\\theta_{\\alpha}$` and `$\\theta_{\\beta}$`, respectively.\nThe names are shorthand for \"x/y standard-deviation\" and \"rgb standard-deviation\" and for reference, the formula is:\n\n![Equation 3 in the original paper](https://user-images.githubusercontent.com/10962198/36150757-01122bf2-10c5-11e8-97d2-2e833c1c9461.png)\n\n### Non-RGB bilateral\n\nAn important caveat is that `addPairwiseBilateral` only works for RGB images, i.e. three channels.\nIf your data is of different type than this simple but common case, you'll need to compute your\nown pairwise energy using `utils.create_pairwise_bilateral`; see the [generic non-2D case](https://github.com/lucasb-eyer/pydensecrf#generic-non-2d) for details.\n\nA good [example of working with Non-RGB data](https://github.com/lucasb-eyer/pydensecrf/blob/master/examples/Non%20RGB%20Example.ipynb) is provided as a notebook in the examples folder.\n\n### Compatibilities\n\nThe `compat` argument can be any of the following:\n\n- A number, then a `PottsCompatibility` is being used.\n- A 1D array, then a `DiagonalCompatibility` is being used.\n- A 2D array, then a `MatrixCompatibility` is being used.\n\nThese are label-compatibilites `µ(xi, xj)` whose parameters could possibly be [learned](https://github.com/lucasb-eyer/pydensecrf#learning).\nFor example, they could indicate that mistaking `bird` pixels for `sky` is not as bad as mistaking `cat` for `sky`.\nThe arrays should have `nlabels` or `(nlabels,nlabels)` as shape and a `float32` datatype.\n\n### Kernels\n\nPossible values for the `kernel` argument are:\n\n- `CONST_KERNEL`\n- `DIAG_KERNEL` (the default)\n- `FULL_KERNEL`\n\nThis specifies the kernel's precision-matrix `Λ(m)`, which could possibly be learned.\nThese indicate correlations between feature types, the default implying no correlation.\nAgain, this could possiblty be [learned](https://github.com/lucasb-eyer/pydensecrf#learning).\n\n### Normalizations\n\nPossible values for the `normalization` argument are:\n\n- `NO_NORMALIZATION`\n- `NORMALIZE_BEFORE`\n- `NORMALIZE_AFTER`\n- `NORMALIZE_SYMMETRIC` (the default)\n\n### Kernel weight\n\nI have so far not found a way to set the kernel weights `w(m)`.\nAccording to the paper, `w(2)` was set to 1 and `w(1)` was cross-validated, but never specified.\nLooking through Philip's code (included in [pydensecrf/densecrf](https://github.com/lucasb-eyer/pydensecrf/tree/master/pydensecrf/densecrf)),\nI couldn't find such explicit weights, and my guess is they are thus hard-coded to 1.\nIf anyone knows otherwise, please open an issue or, better yet, a pull-request.\nUpdate: user @waldol1 has an idea in [this issue](https://github.com/lucasb-eyer/pydensecrf/issues/37). Feel free to try it out!\n\nInference\n---------\n\nThe easiest way to do inference with 5 iterations is to simply call:\n\n```python\nQ = d.inference(5)\n```\n\nAnd the MAP prediction is then:\n\n```python\nmap = np.argmax(Q, axis=0).reshape((640,480))\n```\n\nIf you're interested in the class-probabilities `Q`, you'll notice `Q` is a\nwrapped Eigen matrix. The Eigen wrappers of this project implement the buffer\ninterface and can be simply cast to numpy arrays like so:\n\n```python\nproba = np.array(Q)\n```\n\nStep-by-step inference\n----------------------\n\nIf for some reason you want to run the inference loop manually, you can do so:\n\n```python\nQ, tmp1, tmp2 = d.startInference()\nfor i in range(5):\n    print(\"KL-divergence at {}: {}\".format(i, d.klDivergence(Q)))\n    d.stepInference(Q, tmp1, tmp2)\n```\n\nGeneric non-2D\n--------------\n\nThe `DenseCRF` class can be used for generic (non-2D) dense CRFs.\nIts usage is exactly the same as above, except that the 2D-specific pairwise\npotentials `addPairwiseGaussian` and `addPairwiseBilateral` are missing.\n\nInstead, you need to use the generic `addPairwiseEnergy` method like this:\n\n```python\nd = dcrf.DenseCRF(100, 5)  # npoints, nlabels\n\nfeats = np.array(...)  # Get the pairwise features from somewhere.\nprint(feats.shape)     # -> (7, 100) = (feature dimensionality, npoints)\nprint(feats.dtype)     # -> dtype('float32')\n\ndcrf.addPairwiseEnergy(feats)\n```\n\nIn addition, you can pass `compatibility`, `kernel` and `normalization`\narguments just like in the 2D gaussian and bilateral cases.\n\nThe potential will be computed as `w*exp(-0.5 * |f_i - f_j|^2)`.\n\n### Pairwise potentials for N-D\n\nUser @markusnagel has written a couple numpy-functions generalizing the two\nclassic 2-D image pairwise potentials (gaussian and bilateral) to an arbitrary\nnumber of dimensions: `create_pairwise_gaussian` and `create_pairwise_bilateral`.\nYou can access them as `from pydensecrf.utils import create_pairwise_gaussian`\nand then have a look at their docstring to see how to use them.\n\nLearning\n--------\n\nThe learning has not been fully wrapped. If you need it, get in touch or better\nyet, wrap it and submit a pull-request!\n\nHere's a pointer for starters: issue#24. We need to wrap the gradients and getting/setting parameters.\nBut then, we also need to do something with these, most likely call [minimizeLBFGS from optimization.cpp](https://github.com/lucasb-eyer/pydensecrf/blob/d824b89ee3867bca3e90b9f04c448f1b41821524/pydensecrf/densecrf/src/optimization.cpp).\nIt should be relatively straightforward to just follow the learning examples included in the [original code](http://graphics.stanford.edu/projects/drf/densecrf_v_2_2.zip).\n\nCommon Problems\n===============\n\n`undefined symbol` when importing\n---------------------------------\n\nIf while importing pydensecrf you get an error about some undefined symbols (for example `.../pydensecrf/densecrf.so: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E`), you most likely are inadvertently mixing different compilers or toolchains. Try to see what's going on using tools like `ldd`. If you're using Anaconda, [running `conda install libgcc` might be a solution](https://github.com/lucasb-eyer/pydensecrf/issues/28).\n\nValueError: Buffer dtype mismatch, expected 'float' but got 'double'\n--------------------------------------------------------------------\n\nThis is a pretty [co](https://github.com/lucasb-eyer/pydensecrf/issues/52)mm[on](https://github.com/lucasb-eyer/pydensecrf/issues/49) user error.\nIt means exactly what it says: you are passing a `double` but it wants a `float`.\nSolve it by, for example, calling `d.setUnaryEnergy(U.astype(np.float32))` instead of just `d.setUnaryEnergy(U)`, or using `float32` in your code in the first place.\n\nMy results are all pixelated like [MS Paint's airbrush tool](http://lmgtfy.com/?q=MS+Paint+Airbrush+tool)!\n----------------------------------------------------------\n\nYou screwed up reshaping somewhere and treated the class/label dimension as spatial dimension.\nThis is you misunderstanding NumPy's memory layout and nothing that PyDenseCRF can detect or help with.\n\nThis mistake often happens for the Unary, see the [**Note** in that section of the README](https://github.com/lucasb-eyer/pydensecrf#unary-potential).\n\n\nMaintaining\n===========\n\nThese are instructions for maintainers about how to release new versions. (Mainly instructions for myself.)\n\n```\n# Go increment the version in setup.py\n> python setup.py build_ext\n> python setup.py sdist\n> twine upload dist/pydensecrf-VERSION_NUM.tar.gz\n```\n\nAnd that's it. At some point, it would be cool to automate this on [TravisCI](https://docs.travis-ci.com/user/deployment/pypi/), but not worth it yet.\nAt that point, looking into [creating \"manylinux\" wheels](https://github.com/pypa/python-manylinux-demo) might be nice, too.\n\nTesting\n=======\n\nThanks to @MarvinTeichmann we now have proper tests, install the package and run `py.test`.\nMaybe there's a better way to run them, but both of us don't know :smile:\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "pydensecrf",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.0810546875,
          "content": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"Cython==0.29.36\"\n]\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.13671875,
          "content": "# coding: UTF-8\nfrom setuptools import setup\n\n# TODO:\n# - Wrap learning.\n# - Make LabelCompatibility, UnaryEnergy, PairwisePotential extensible? (Maybe overkill?)\n\n\n# If Cython is available, build using Cython.\n# Otherwise, use the pre-built (by someone who has Cython, i.e. me) wrapper `.cpp` files.\ntry:\n    from Cython.Build import cythonize\n    ext_modules = cythonize(['pydensecrf/eigen.pyx', 'pydensecrf/densecrf.pyx'])\nexcept ImportError:\n    from setuptools.extension import Extension\n    ext_modules = [\n        Extension(\"pydensecrf/eigen\", [\"pydensecrf/eigen.cpp\", \"pydensecrf/eigen_impl.cpp\"], language=\"c++\", include_dirs=[\"pydensecrf/densecrf/include\"]),\n        Extension(\"pydensecrf/densecrf\", [\"pydensecrf/densecrf.cpp\", \"pydensecrf/densecrf/src/densecrf.cpp\", \"pydensecrf/densecrf/src/unary.cpp\", \"pydensecrf/densecrf/src/pairwise.cpp\", \"pydensecrf/densecrf/src/permutohedral.cpp\", \"pydensecrf/densecrf/src/optimization.cpp\", \"pydensecrf/densecrf/src/objective.cpp\", \"pydensecrf/densecrf/src/labelcompatibility.cpp\", \"pydensecrf/densecrf/src/util.cpp\", \"pydensecrf/densecrf/external/liblbfgs/lib/lbfgs.c\"], language=\"c++\", include_dirs=[\"pydensecrf/densecrf/include\", \"pydensecrf/densecrf/external/liblbfgs/include\"]),\n    ]\n\nsetup(\n    name=\"pydensecrf\",\n    version=\"1.0\",\n    description=\"A python interface to Philipp Krähenbühl's fully-connected (dense) CRF code.\",\n    long_description=\"See the README.md at http://github.com/lucasb-eyer/pydensecrf\",\n    author=\"Lucas Beyer\",\n    author_email=\"lucasb.eyer.be@gmail.com\",\n    url=\"http://github.com/lucasb-eyer/pydensecrf\",\n    ext_modules=ext_modules,\n    packages=[\"pydensecrf\"],\n    setup_requires=['cython==0.29.36'],\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: Scientific/Engineering :: Image Recognition\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}