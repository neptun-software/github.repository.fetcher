{
  "metadata": {
    "timestamp": 1736565426353,
    "page": 271,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/lmctfy",
      "stars": 3410,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "bin/*\n*.pb.*\n!*.pb.go\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.3359375,
          "content": "# This is the official list of lmctfy authors for copyright purposes.\n# This file is distinct from the CONTRIBUTORS files.\n# See the latter for an explanation.\n\n# Names should be added to this file as\n#     Name or Organization <email address>\n# The email address is not required for organizations.\n\n# Please keep the list sorted.\n\nGoogle Inc.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.6171875,
          "content": "# This is the official list of people who have contributed to the project. The\n# copyright is held by those individuals or organizations in the AUTHORS file.\n#\n# Names should be added to this file like so:\n#     Name <email address>\n\n# Please keep the list sorted by first name.\n\nAditya Kali <adityakali@google.com>\nAmey Deshpande <ameyd@google.com>\nJonathan Wilson <jonathanw@google.com>\nKamil Yurtsever <kyurtsever@google.com>\nRohit Jnagal <jnagal@google.com>\nTim Hockin <thockin@google.com>\nVictor Marmol <vmarmol@google.com>\nVishnu Kannan <vishnuk@google.com>\nVrijenda Gokhale <vrigo@google.com>\nZohaib Maya <zohaib@google.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.5107421875,
          "content": "   Copyright 2013 The lmctfy Authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 9.302734375,
          "content": "# This Makefile is heavily based on LevelDB's:\n# https://code.google.com/p/leveldb/\n\n#-----------------------------------------------\n# Uncomment exactly one of the lines labelled (A), (B), and (C) below\n# to switch between compilation modes.\n\nOPT ?= -O2 -DNDEBUG       # (A) Production use (optimized mode)\n# OPT ?= -g2              # (B) Debug mode, w/ full line-level debugging symbols\n# OPT ?= -O2 -g2 -DNDEBUG # (C) Profiling mode: opt, but w/debugging symbols\n#-----------------------------------------------\n\n# Use default if no configuration specified.\nCXX ?= g++\nAR ?= ar\n\n# Version number of lmctfy.\nVERSION = \"\\\"0.5.0\\\"\"\n\n# TODO(vmarmol): Ensure our dependencies are installed\nPROTOC = protoc\n\n# Function for getting a set of source files.\nget_srcs = $(shell find $(1) -name \\*.cc -a ! -name \\*_test.cc | tr \"\\n\" \" \")\n\nINCLUDE_PROTOS = include/config include/virtual_host include/lmctfy \\\n                 include/namespaces\nUTIL_PROTOS = util/task/codes\nBASE_SOURCES = $(call get_srcs,base/)\nFILE_SOURCES = $(call get_srcs,file/)\nINCLUDE_SOURCES = $(call get_srcs,include/) \\\n\t\t  $(addsuffix .pb.cc,$(INCLUDE_PROTOS))\nUTIL_SOURCES = $(call get_srcs,util/) $(addsuffix .pb.cc,$(UTIL_PROTOS))\nSTRINGS_SOURCES = $(call get_srcs,strings/)\nTHREAD_SOURCES = $(call get_srcs,thread/)\nLIBLMCTFY_SOURCES =$(shell find lmctfy/ -name \\*.cc -a ! -name \\*_test.cc \\\n\t\t   -a ! -path \\*cli/\\* | tr \"\\n\" \" \")\nCLI_SOURCES = $(call get_srcs,lmctfy/cli/)\nNSINIT_SOURCES = nscon/init.cc nscon/init_impl.cc\nNSCLI_SOURCES = $(call get_srcs,nscon/cli/)\nNSCON_SOURCES = $(filter-out $(NSINIT_SOURCES),$(call get_srcs,nscon/))\nNSCON_SOURCES_NO_CLI = $(filter-out $(NSCLI_SOURCES),$(NSCON_SOURCES))\n\n# The objects for the system API (both release and test versions).\nSYSTEM_API_OBJS = global_utils/fs_utils.o \\\n\t\t  global_utils/mount_utils.o \\\n\t\t  global_utils/time_utils.o \\\n\t\t  system_api/kernel_api.o \\\n\t\t  system_api/kernel_api_singleton.o \\\n\t\t  system_api/libc_fs_api_impl.o \\\n\t\t  system_api/libc_fs_api_singleton.o \\\n\t\t  system_api/libc_net_api.o \\\n\t\t  system_api/libc_process_api.o \\\n\t\t  system_api/libc_time_api.o\nSYSTEM_API_TEST_OBJS = global_utils/fs_utils_test_util.o \\\n\t\t       global_utils/mount_utils_test_util.o \\\n\t\t       global_utils/time_utils_test_util.o \\\n\t\t       system_api/kernel_api.o \\\n\t\t       system_api/kernel_api_test_util.o \\\n\t\t       system_api/libc_fs_api_impl.o \\\n\t\t       system_api/libc_fs_api_test_util.o \\\n\t\t       system_api/libc_net_api_test_util.o \\\n\t\t       system_api/libc_process_api_test_util.o \\\n\t\t       system_api/libc_time_api_test_util.o\n\n# Gets all *_test.cc files in lmtcfy/.\nTESTS = $(basename $(shell find lmctfy/ nscon/ -name \\*_test.cc \\\n\t-a ! -name \\*_integration_test.cc))\n\n# Gets all *_integration_test.cc files in lmtcfy/.\nINTEGRATION_TESTS = $(basename $(shell find lmctfy/ nscon/ testing/ -name \\\n  \\*_integration_test.cc))\n\n# Where to place the binary outputs.\nOUT_DIR = bin\n\n# Location of gTest and gMock.\nGTEST_DIR = gmock/gtest\nGMOCK_DIR = gmock\n\nCXXFLAGS += $(OPT)\n\n# Determine GCC version.\nGCC_VERSION = $(shell $(CXX) -dumpversion | awk -F'.' \\\n\t      '{printf \"%d%02d%02d\", $$1, $$2, $$3}')\n\n# Helper comparison function.\nIF = $(if $(shell [ \"$(1)\" -$(2) \"$(3)\" ] && echo \"1\"),$(4),$(5))\n\n# Use c++11 for GCC >=4.7.0 and c++0x for earlier versions. Additionally,\n# set -fpermissive for 4.7.x to work around '<::'.\nCXXFLAGS += $(call IF,$(GCC_VERSION),ge,40700,\\\n\t    $(call IF,$(GCC_VERSION),lt,40800,\\\n\t    -std=c++11 -fpermissive,-std=c++11),\\\n\t    -std=c++0x)\n\n# Add defines.\nCXXFLAGS += -DHASH_NAMESPACE=std -DHAVE_LONG_LONG -DGTEST_HAS_STRING_PIECE_ \\\n\t    -DLMCTFY_VERSION=$(VERSION)\n\n# Add libraries to link in.\nCXXFLAGS += -pthread -lrt -lre2 -lgflags -lapparmor\n\n# Add include and library paths.\nCXXFLAGS += -I. -I./include -I./base -I./lmctfy -I$(GTEST_DIR)/include \\\n\t    -I$(GMOCK_DIR)/include -I/usr/local/include -L/usr/local/lib \\\n\t    -I/usr/include -L/usr/lib\n\n# Add proto flags.\nCXXFLAGS += `pkg-config --cflags --libs protobuf`\n\nCLI = lmctfy\nNSCON = lmctfy-nscon\nNSINIT = lmctfy-nsinit\nLIBRARY = liblmctfy.a\nCREAPER = lmctfy-creaper\n\n# Function for ensuring the output directory has been created.\ncreate_bin = mkdir -p $(dir $(OUT_DIR)/$@)\n\n# Function that archives all input's bin/ output into an archive.\narchive_all = $(AR) $(ARFLAGS) $(OUT_DIR)/$@ $(addprefix $(OUT_DIR)/,$^)\n\n# Function for turning source file names to their object file names (.cc -> .o).\nsource_to_object = $(addsuffix .o,$(basename $(1)))\n\ndefault: all\n\nall: $(LIBRARY) $(NSINIT) $(NSCON) $(CLI) $(CREAPER)\n\nINSTALL = /usr/bin/install\nINSTALL_PROGRAM = $(INSTALL) -m 755\nDESTDIR = /usr/local/bin\n\ninstall: all\n\t$(INSTALL_PROGRAM) $(OUT_DIR)/lmctfy/cli/$(CLI) $(DESTDIR)/$(CLI)\n\t$(INSTALL_PROGRAM) $(OUT_DIR)/nscon/cli/$(NSCON) $(DESTDIR)/$(NSCON)\n\t$(INSTALL_PROGRAM) $(OUT_DIR)/nscon/$(NSINIT) $(DESTDIR)/$(NSINIT)\n\t$(INSTALL_PROGRAM) $(OUT_DIR)/$(CREAPER) $(DESTDIR)/$(CREAPER)\n\nTEST_TMPDIR = \"/tmp/lmctfy_test.$$$$\"\ncheck: $(TESTS)\n\tfor t in $(addprefix $(OUT_DIR)/,$^); \\\n\t\tdo \\\n\t\t\techo \"***** Running $$t\"; \\\n\t\t\trm -rf $(TEST_TMPDIR); \\\n\t\t\tmkdir $(TEST_TMPDIR); \\\n\t\t\t./$$t --test_tmpdir=$(TEST_TMPDIR) || exit 1; \\\n\t\tdone; \\\n\trm -rf $(TEST_TMPDIR)\n\techo \"All tests pass!\"\n\ncheck_integration: $(INTEGRATION_TESTS)\n\tfor t in $(addprefix $(OUT_DIR)/,$^); \\\n\t\tdo \\\n\t\t\techo \"***** Running $$t\"; \\\n\t\t\trm -rf $(TEST_TMPDIR); \\\n\t\t\tmkdir $(TEST_TMPDIR); \\\n\t\t\t./$$t --test_tmpdir=$(TEST_TMPDIR) || exit 1; \\\n\t\tdone; \\\n\trm -rf $(TEST_TMPDIR)\n\techo \"All tests pass!\"\n\nclean:\n\t-rm -rf $(OUT_DIR)\n\t-rm -f `find . -type f -name '*.pb.*'`\n\nexamples/simple_existing: examples/simple_existing.o $(LIBRARY)\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/$@ $(addprefix $(OUT_DIR)/,$^) $(CXXFLAGS)\n\n# All common base sources (non-lmctfy and non-nscon).\nCOMMON_SOURCES = $(INCLUDE_SOURCES) $(BASE_SOURCES) $(STRINGS_SOURCES) \\\n\t\t $(FILE_SOURCES) $(THREAD_SOURCES) $(UTIL_SOURCES)\n\n# All sources needed by the library (minus the system API).\nLIBRARY_SOURCES = $(COMMON_SOURCES) $(LIBLMCTFY_SOURCES) $(NSCON_SOURCES_NO_CLI)\n\n\n# The lmctfy library without the system API. This is primarily an internal\n# target.\nlmctfy_no_system_api.a: $(call source_to_object,$(LIBRARY_SOURCES))\n\t$(create_bin)\n\t$(archive_all)\n\n# The lmctfy library with the real system API.\n$(LIBRARY): $(call source_to_object,$(LIBRARY_SOURCES)) $(SYSTEM_API_OBJS)\n\t$(create_bin)\n\t$(archive_all)\n\n# Objects of the lmctfy CLI.\nlmctfy_cli.a: $(call source_to_object,$(CLI_SOURCES))\n\t$(create_bin)\n\t$(archive_all)\n\n$(CLI): lmctfy_cli.a $(LIBRARY)\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/lmctfy/cli/$@ $(addprefix $(OUT_DIR)/,$^) $(CXXFLAGS)\n\n# Objects of the nscon CLI.\nnscon_cli.a: $(call source_to_object,$(NSCON_SOURCES) $(COMMON_SOURCES)) \\\n             $(SYSTEM_API_OBJS)\n\t$(create_bin)\n\t$(archive_all)\n\n$(NSCON): nscon_cli.a\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/nscon/cli/$@ $(addprefix $(OUT_DIR)/,$^) $(CXXFLAGS)\n\n# Objects of the nsinit CLI.\nnsinit_cli.a: $(call source_to_object,$(NSINIT_SOURCES) $(COMMON_SOURCES))\n\t$(create_bin)\n\t$(archive_all)\n\n$(NSINIT): nsinit_cli.a\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/nscon/$@ $(addprefix $(OUT_DIR)/,$^) $(CXXFLAGS)\n\n$(CREAPER): lmctfy-creaper.go\n\t$(create_bin)\n\tgo build -o $(OUT_DIR)/lmctfy-creaper lmctfy-creaper.go\n\n%_integration_test: gtest_main.a $(LIBRARY)\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/$@ $*_integration_test.cc $(addprefix $(OUT_DIR)/,$^) \\\n\t\t$(CXXFLAGS)\n\n%_real_test: gtest_main.a $(LIBRARY)\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/$@ $*.cc $*_real_test.cc $(addprefix $(OUT_DIR)/,$^) \\\n\t\t$(CXXFLAGS)\n\n%_test: gtest_main.a $(SYSTEM_API_TEST_OBJS) nscon_cli.a lmctfy_cli.a \\\n        lmctfy_no_system_api.a\n\t$(create_bin)\n\t$(CXX) -o $(OUT_DIR)/$@ $*.cc $*_test.cc $(addprefix $(OUT_DIR)/,$^) \\\n\t\t$(CXXFLAGS)\n\n%_proto: %.proto\n\t$(PROTOC) $^ --cpp_out=.\n\n%.pb.o: %_proto\n\t$(create_bin)\n\t$(CXX) -c $*.pb.cc -o $(OUT_DIR)/$@ $(CXXFLAGS)\n\ngen_protos: $(addsuffix _proto,$(INCLUDE_PROTOS) $(UTIL_PROTOS))\n\n%.o: gen_protos %.cc\n\t$(create_bin)\n\t$(CXX) -c $*.cc -o $(OUT_DIR)/$@ $(CXXFLAGS)\n\n# Rules for Building Google Test and Google Mock (based on gmock's example).\n\n# All Google Test headers.  Usually you shouldn't change this definition.\nGTEST_HEADERS = $(GTEST_DIR)/include/gtest/*.h \\\n\t\t$(GTEST_DIR)/include/gtest/internal/*.h\n\n# All Google Mock headers. Note that all Google Test headers are\n# included here too, as they are #included by Google Mock headers.\n# Usually you shouldn't change this definition.\nGMOCK_HEADERS = $(GMOCK_DIR)/include/gmock/*.h \\\n\t\t$(GMOCK_DIR)/include/gmock/internal/*.h \\\n\t\t$(GTEST_HEADERS)\n\nGTEST_SRCS_ = $(GTEST_DIR)/src/*.cc $(GTEST_DIR)/src/*.h $(GTEST_HEADERS)\nGMOCK_SRCS_ = $(GMOCK_DIR)/src/*.cc $(GMOCK_HEADERS)\n\n# For simplicity and to avoid depending on Google Test's\n# implementation details, the dependencies specified below are\n# conservative and not optimized.  This is fine as Google Test\n# compiles fast and for ordinary users its source rarely changes.\ngtest-all.o : $(GTEST_SRCS_)\n\t$(create_bin)\n\t$(CXX) -I$(GTEST_DIR) $(CXXFLAGS) -c \\\n\t\t$(GTEST_DIR)/src/gtest-all.cc -o $(OUT_DIR)/$@\n\ngmock-all.o : $(GMOCK_SRCS_)\n\t$(create_bin)\n\t$(CXX) -I$(GTEST_DIR) -I$(GMOCK_DIR) $(CXXFLAGS) \\\n\t\t-c $(GMOCK_DIR)/src/gmock-all.cc -o $(OUT_DIR)/$@\n\ngmock_main.o : $(GMOCK_SRCS_)\n\t$(create_bin)\n\t$(CXX) -I$(GTEST_DIR) -I$(GMOCK_DIR) $(CXXFLAGS) \\\n\t\t-c $(GMOCK_DIR)/src/gmock_main.cc -o $(OUT_DIR)/$@\n\ngtest.a : gmock-all.o gtest-all.o\n\t$(create_bin)\n\t$(archive_all)\n\ngtest_main.a : gmock-all.o gtest-all.o gmock_main.o\n\t$(create_bin)\n\t$(archive_all)\n"
        },
        {
          "name": "PRIMER.md",
          "type": "blob",
          "size": 3.53515625,
          "content": "# lmctfy Codebase Primer\n\nThe goal of this document is to provide a quick-start guide on the design of lmctfy in order to make contributing to the codebase easier.\n\n## Directory Structure\n\nThe repository has a slew of directories and a handful of files at the top level. Most of the top level files are documentation, licensing, and the build/test rules. The other directories are described below.\n\n### lmctfy Core\n\nThe core of lmctfy can be found in `/lmctfy` and the public API can be found in `/include`.\n\n* `/lmctfy`: The implementation of the public API and the core abstractions [(described below)](#abstractions).\n* `/lmctfy/cli`: The implementation of the lmctfy command line tool.\n* `/lmctfy/controllers`: [Controllers](#controllers) for all resources lmctfy supports.\n* `/lmctfy/resources`: [Resource handlers](#resource-handlers) for all resources lmctfy supports.\n\n### Utilities &amp; Dependencies\n\nThis comprises the majority of the top-level directories. These are base and generic C++ libraries and utilities.\n\n* `/base`: Base libraries.\n* `/file`: File-handling utilities.\n* `/gmock`: The gMock and gTest frameworks.\n* `/strings`: String-handling utilities.\n* `/thread`: Wrapper for thread operations.\n* `/util`: Generic utilities.\n\n### System\n\nThe lmctfy code abstracts system interactions with the system API found in `/system_api`. This abstraction lets us mock out the system for unit and integration testing.\n\n## Abstractions\n\nAt the core of lmctfy is the public C++ library API (the CLI is a thin wrapper around this). The public API has the `ContainerApi` which functions as a factory of `Container` objects (both of these are in [lmctfy.h](/include/lmctfy.h)). These make heavy use of different specifications found in [lmctfy.proto](/include/lmctfy.proto). All of these specifications are split into **resources** that lmctfy supports. The aim is for these to not change significantly over time and to be high level enough to adapt to underlying kernel changes. \n\nThe C++ library is implemented by some logic wrapping a set of **handlers**. The most prevalent of these are the **resource handlers** which each implements the support and policies of a single resource (their interface is in [resource_handler.h](/lmctfy/resource_handler.h)). One other top-level handler is the **tasks handler** which manages tracking of tasks (interface at [tasks_handler.h](/lmctfy/tasks_handler.h)).\n\n### Resource Handlers\n\nEach resource handler defines its own specification and implements the isolation that specification mentions. It does this through a series of [controllers](#controllers) which interact with the kernel. The `ResouceHandler` itself decides how it will use the controllers to implement the desired isolation (i.e.: the `CpuResourceHandler` creates a `/batch` top-level `cpu` cgroup (through the `CpuController`) to isolate all batch workload).\n\n#### Controllers\n\nThe controllers are what actually interacts with the kernel to implement the desired isolation. They provide a slightly higher API to the resource handlers in order to encapsulate changes in the kernel. The granularity of a controller is a cgroup or a namespace (e.g.: `CpuController` for the `cpu` hierarchy and `MemoryController` for the `memory` hierarchy).\n\n### Tasks Handler\n\nlmctfy requires a canonical tasks hierarchy it uses to keep track of groups of tasks. The `TasksHandler` contains this logic. The current implementation is the `CgroupTasksHandler` which uses the `freezer` cgroup hierarchy to track tasks.\n\n## Other\n\nFeel free to e-mail the project's mailing list with any questions: <lmctfy@googlegroups.com>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.943359375,
          "content": "# lmctfy - Let Me Contain That For You\n\n## Note\nWe have been collaborating with [Docker](http://docker.com) over libcontainer and are in process of porting the core lmctfy concepts and abstractions to [libcontainer](http://github.com/docker/libcontainer). We are not actively developing lmctfy further and have moved our efforts to libcontainer. In future, we hope to replace the core of lmctfy with libcontainer.\n\n## Introduction\nlmctfy (pronounced *l-m-c-t-fi*, IPA: /ɛlɛmsitifаɪ/) is the open source version of [Google](http://google.com)’s container stack, which provides Linux application containers. These containers allow for the isolation of resources used by multiple applications running on a single machine. This gives the applications the impression of running exclusively on a machine. The applications may be container-aware and thus be able to create and manage their own subcontainers.\n\nThe project aims to provide the container abstraction through a high-level API built around user intent. The containers created are themselves container-aware within the hierarchy and can be delegated to be managed by other user agents.\n\nlmctfy was designed and implemented with specific use-cases and configurations in mind and may not work out of the box for all use-cases and configurations. We do aim to support more use-cases and configurations so please feel free to [contribute](#contributing) patches or send e-mail to the [mailing list](#mailing-list) so that we may incorporate these into the [roadmap](#roadmap).\n\nlmctfy is released as both a C++ library and a CLI.\n\n## Current Status\nlmctfy is currently stalled as we migrate the core concepts to libcontainer and build a standard container management library that can be used by many projects.\n\nlmctfy is beta software and may change as it evolves. The latest release version is `0.5.0`. It currently provides isolation for CPU, memory, and devices. It also allows for the creation of Virtual Hosts which are more heavily isolated containers giving the impression of running as an independent host. \n\n## Getting Started\nThis section describes building the CLI, running all unit tests, and initializing the machine. The [CLI Commands](#cli-commands) section provides some examples of CLI operations and [C++ Library](#c-library) describes the use of the underlying library.\n### Dependencies\nlmctfy depends on the following libraries and expects them to be available on the system:\n* [Protocol Buffers](https://code.google.com/p/protobuf/)\n* [gflags](https://code.google.com/p/gflags/) (version >= 2.1.1)\n* [RE2](https://code.google.com/p/re2/)\n* [AppArmor](http://packages.ubuntu.com/precise/libapparmor-dev)\n* glibc (version >= 2.14)\n\nAddtionally to build lmctfy you also need:\n* make\n* go compiler\n* g++ or clang version with C++11 support (tested with g++-4.7 and clang-3.2)\n\nWe've tested the setup on **Ubuntu 12.04+**. We are happy to accept patches that add support for other setups.\n\n### Building the CLI\nTo build the `lmctfy` CLI:\n\n```bash\nmake -j <number of threads> lmctfy\n```\n\nThe CLI should now be available at: `bin/lmctfy/cli/lmctfy`\n### Building the C++ Library\nTo build the lmctfy library:\n\n```bash\nmake -j <number of threads> liblmctfy.a\n```\n\nThe library should now be available at: `bin/liblmctfy.a`.\n### Running Unit Tests\n\nTo build and run all unit tests:\n\n```bash\nmake -j <number of threads> check\n```\n\n### Initialization\nlmctfy has been tested on **Ubuntu 12.04+** and on the **Ubuntu 3.3** and **3.8** kernels. lmctfy runs best when it owns all containers in a machine so it is not recommended to run lmctfy alongside [LXC](http://lxc.sourceforge.net/) or another container system (although given some configuration, it can be made to work).\n\nIn order to run lmctfy we must first initialize the machine. This only needs to happen once and is typically done when the machine first boots. If the cgroup hierarchies are already mounted, then an empty config is enough and lmctfy will auto-detect the existing mounts:\n\n```bash\nlmctfy init \"\"\n```\n\nIf the cgroup hierarchies are not mounted, those must be specified so that lmctfy can mount them. The current version of lmctfy needs the following cgroup hierarchies: `cpu`, `cpuset`, `cpuacct`, `memory`, and `freezer`. `cpu` and `cpuacct` are the only hierarchies that can be co-mounted, all other must be mounted individually. For details on configuration specifications take a look at `InitSpec` in [lmctfy.proto](/include/lmctfy.proto). An example configuration mounting all of the hierarchies in `/sys/fs/cgroup`:\n\n```bash\nlmctfy init \"\n  cgroup_mount:{\n    mount_path:'/sys/fs/cgroup/cpu'\n    hierarchy:CGROUP_CPU hierarchy:CGROUP_CPUACCT\n  }\n  cgroup_mount:{\n    mount_path:'/sys/fs/cgroup/cpuset' hierarchy:CGROUP_CPUSET\n  }\n  cgroup_mount:{\n    mount_path:'/sys/fs/cgroup/freezer' hierarchy:CGROUP_FREEZER\n  }\n  cgroup_mount:{\n    mount_path:'/sys/fs/cgroup/memory' hierarchy:CGROUP_MEMORY\n  }\"\n```\n\nThe machine should now be ready to use `lmctfy` for container operations.\n\n## Container Names\nContainer names mimic filesystem paths closely since they express a hierarchy of containers (i.e.: containers can be inside other containers, these are called **subcontainers** or **child containers**).\n\nAllowable characters for container names are:\n* Alpha numeric (`[a-zA-Z0-9]+`)\n* Underscores (`_`)\n* Dashes (`-`)\n* Periods (`.`)\n\nAn absolute path is one that is defined from the root (`/`) container (i.e.: `/sys/subcont`). Container names can also be relative (i.e.: `subcont`). In general and unless otherwise specified, regular filesystem path rules apply.\n\n### Examples:\n```\n   /           : Root container\n   /sys        : the \"sys\" top level container\n   /sys/sub    : the \"sub\" container inside the \"sys\" top level container\n   .           : the current container\n   ./          : the current container\n   ..          : the parent of the current container\n   sub         : the \"sub\" subcontainer (child container) of the current container\n   ./sub       : the \"sub\" subcontainer (child container) of the current container\n   /sub        : the \"sub\" top level container\n   ../sibling  : the \"sibling\" child container of the parent container\n```\n\n\n## CLI Commands\n### Create\nTo create a container run:\n\n```bash\nlmctfy create <name> <specification>\n```\n\nPlease see [lmctfy.proto](/include/lmctfy.proto) for the full `ContainerSpec`.\n\nExample (create a memory-only container with `100MB` limit):\n\n```bash\nlmctfy create memory_only \"memory:{limit:100000000}\"\n```\n\n### Destroy\nTo destroy a container run:\n\n```bash\nlmctfy destroy <name>\n```\n\n### List\nTo list all containers in a machine, ask to recursively list from root:\n\n```bash\nlmctfy list containers -r /\n```\n\nYou can also list only the current subcontainers:\n\n```bash\nlmctfy list containers\n```\n\n### Run\nTo run a command inside a container run:\n\n```bash\nlmctfy run <name> <command>\n```\n\nExamples:\n\n```bash\nlmctfy run test \"echo hello world\"\nlmctfy run /test/sub bash\nlmctfy run -n /test \"echo hello from a daemon\"\n```\n\n### Other\nUse `lmctfy help` to see the full command listing and documentation.\n\n## C++ Library\nThe library is comprised of the `::containers::lmctfy::ContainerApi` factory which creates, gets, destroys, and detects `::containers::lmctfy::Container` objects that can be used to interact with individual containers. Full documentation for the lmctfy C++ library can be found in [lmctfy.h](/include/lmctfy.h). \n\n## Roadmap\n\nThe lmctfy project proposes a containers stack with two major layers we’ll call CL1 and CL2. CL1 encompases the driver and enforcement of the containers policy set by CL2. CL1 will create and maintain the container abstraction for higher layers. It should be the only layer that directly interacts with the kernel to manage containers. CL2 is what develops and sets container policy, it uses CL1 to enforce the policy and manage containers. For example: CL2 (a daemon) implements a policy that the amount of CPU and memory used by all of a machine’s containers must not exceed the amount of available CPU and memory (as opposed to overcommitting memory in the machine). To enforce that policy it uses CL1 (library/CLI) to create containers with memory limits that add up to the machine’s available memory. Alternate policies may involve overcommitting a machine’s resources by X% or creating levels of resources with different guarantees for quality of service.\n\nThe lmctfy project currently provides the CL1 component. The CL2 is not yet implemented.\n\n### CL1\nCurrently only provides robust CPU and memory isolation.  In our roadmap we have support for the following:\n* *Disk IO Isolation:* The specification is mostly complete, we’re missing the controller and resource handler.\n* *Network Isolation:* The specification and cgroup implementation is up in the air.\n* *Support for Root File Systems:* Specifying and building root file systems.\n* *Disk Images:* Being able to import/export a container’s root file system image.\n* *Checkpoint Restore:* Being able to checkpoint and restore containers on different machines.\n\n### CL2\nThe most basic CL2 would use a container policy that ensures the fair sharing of a machine’s resources without allowing overcommitment. We aim to eventually implement a CL2 that provides different levels of guaranteed quality of service. In this scheme some levels are given stronger quality of service than others. The following CL2 features are supported in our roadmap:\n* Monitoring and statistics support.\n* Admission control and feasibility checks.\n* Quality of Service guarantees and enforcement.\n\nWe have started work on CL2 under the [cAdvisor](https://github.com/google/cadvisor/) project\n\n## Kernel Support\n\nlmctfy was originally designed and implemented around a custom kernel with a set of patches on top of a vanilla Linux kernel. As such, some features work best in conjunction with those kernel patches. However, lmctfy should work without them. It should detect available kernel support and adapt accordingly. We’ve tested lmctfy in vanilla **Ubuntu 3.3*** and **3.8** kernels. Please report any issues you find with other kernel versions.\n\nSome of the relevant kernel patches:\n* *CPU latency:* This adds the `cpu.lat` cgroup file to the cpu hierarchy. It bounds the CPU wakeup latency a cgroup can expect.\n* *CPU histogram accounting:* This adds the `cpuacct.histogram` cgroup file to the cpuacct hierarchy. It provides various histograms of CPU scheduling behavior.\n* *OOM management:* Series of patches to enforce priorities during out of memory conditions.\n\n## Contributing\n\nInterested in contributing to the project? Feel free to send a patch or take a look at our [roadmap](#roadmap) for ideas on areas of contribution. Follow [Getting Started](#getting-started) above and it should get you up and running. If not, let us know so we can help and improve the instructions. There is some documentation on the structure of lmctfy in the [primer](/PRIMER.md).\n\n## Mailing List\n\nThe project mailing list is <lmctfy@googlegroups.com>. The list will be used for announcements, discussions, and general support. You can [subscribe via groups.google.com](https://groups.google.com/forum/#!forum/lmctfy).\n"
        },
        {
          "name": "base",
          "type": "tree",
          "content": null
        },
        {
          "name": "cadvisor",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "file",
          "type": "tree",
          "content": null
        },
        {
          "name": "global_utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "gmock",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "lmctfy-creaper.go",
          "type": "blob",
          "size": 8.359375,
          "content": "/*\nlmctfy-creaper is used to create a lmctfy container, optionally run a command\ninside it and then automatically destroy it once the init process in that\ncontainer exits. lmctfy-creaper should be started as a background process and\nit will exit as soon as the init process in a container that it created exits.\n*/\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n)\n\n// containerSpecInput wraps two possible ContainerSpec inputs to lmctfy which\n// is either via the command line as a string or through a config file.\ntype containerSpec struct {\n\tcommandLine string\n\tspecFile    string\n}\n\nconst (\n\t// prctl syscall option to set the current process as the parent for all\n\t// its grand children that gets abandoned.\n\tprSetChildSubreaper = 36\n)\n\nvar (\n\tspecFile = flag.String(\"specFile\", \"\", \"Path to a file that contains the Lmctfy ContainerSpec. \"+\n\t\t\"Use either -containerSpec flag or specify the ContainerSpec in the command line.\")\n\tdebug         = flag.Bool(\"debug\", false, \"When set to true, creaper will print debug information to the stdout.\")\n\tnetworkSetup  = flag.String(\"networkSetup\", \"\", \"Network setup script called from outside the namespace after namespace and veths are created.\")\n\tlmctfyBinPath = flag.String(\"lmctfyPath\", \"/usr/local/bin/lmctfy\", \"Path to lmctfy binary.\")\n)\n\n// destroyContainer uses lmctfy internally to unconditionally destroy the\n// container referred to by 'containerName'. Logs fatal if container deletion fails.\nfunc destroyContainer(containerName string) {\n\tcmd := exec.Command(*lmctfyBinPath, \"destroy\", containerName, \"-f\")\n\tif *debug {\n\t\tfmt.Println(strings.Join(cmd.Args, \" \"))\n\t}\n\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\tlog.Printf(\"failed to destroy container %s. lmctfy output: %s. error: %s\",\n\t\t\tcontainerName, string(out), err)\n\t}\n}\n\n// createContainer uses lmctfy to create a container with the given name and\n// lmctfy spec. Returns the output of lmctfy process.\nfunc createContainer(containerName string, spec containerSpec) (string, error) {\n\treadPipe, writePipe, err := os.Pipe()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer readPipe.Close()\n\t// output fd is 3 because writePipe is the first entry in exec.Cmd.ExtraFiles\n\targs := []string{*lmctfyBinPath, \"create\", containerName, \"--lmctfy_output_fd=3\"}\n\n\tif spec.specFile != \"\" {\n\t\targs = append(args, \"-c\", spec.specFile)\n\t} else {\n\t\targs = append(args, spec.commandLine)\n\t}\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.Stdin = os.Stdin\n\tcmd.ExtraFiles = []*os.File{writePipe}\n\tif *debug {\n\t\tfmt.Println(strings.Join(cmd.Args, \" \"))\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"container creation failed. error: %s\", err)\n\t}\n\twritePipe.Close()\n\tout, err := ioutil.ReadAll(readPipe)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(out), nil\n}\n\n// runCommandInContainer runs 'userCommand' in container with name 'containerName'.\n// Returns error on failure.\nfunc runCommandInContainer(containerName string, userCommand []string) error {\n\tcmd := exec.Command(*lmctfyBinPath, \"run\", containerName, strings.Join(userCommand, \" \"))\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.Stdin = os.Stdin\n\tif *debug {\n\t\tfmt.Println(strings.Join(cmd.Args, \" \"))\n\t}\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to run command %s in container %s. error: %s\",\n\t\t\tstrings.Join(userCommand, \" \"), containerName, err)\n\t}\n\treturn nil\n}\n\n// Extracts the value with key init_pid from lmctfyOutput. Returns the\n// value on success and returns an error on failure.\nfunc extractInitPID(lmctfyOutput string) (int, error) {\n\t// Lmctfy output is in the form of key value pairs (key=\"value\").\n\t// We are looking for key 'init_pid'\n\tfor _, keyValue := range strings.Split(lmctfyOutput, \" \") {\n\t\tfields := strings.Split(keyValue, \"=\")\n\t\tif len(fields) != 2 {\n\t\t\treturn 0, fmt.Errorf(\"invalid lmctfy output %s\", lmctfyOutput)\n\t\t}\n\t\tif strings.Contains(fields[0], \"init_pid\") {\n\t\t\tvalue := strings.TrimRight(strings.Replace(fields[1], \"\\\"\", \"\", -1), \"\\n\")\n\t\t\tinitPID, err := strconv.Atoi(value)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, fmt.Errorf(\"%s\\ninvalid Lmctfy output %s\", err, lmctfyOutput)\n\t\t\t}\n\t\t\treturn initPID, nil\n\t\t}\n\t}\n\treturn 0, fmt.Errorf(\"invalid lmctfy output %s\", lmctfyOutput)\n}\n\n// setChildSubreaper marks the current process to become the parent of any\n// grandchildren processes that might be abandoned by its parent\n// process. Returns error on failure, nil otherwise.\nfunc setChildSubreaper() error {\n\tif _, _, errno := syscall.Syscall6(syscall.SYS_PRCTL, uintptr(prSetChildSubreaper),\n\t\tuintptr(1), uintptr(0), uintptr(0), uintptr(0), uintptr(0)); errno != 0 {\n\t\treturn fmt.Errorf(\"failed to make current process parent of all \"+\n\t\t\t\"child processes that might be abandoned in the future. errno: %d\\n\", errno)\n\t}\n\treturn nil\n}\n\n// waitPID waits for 'wpid' to exit and prints the exit status of\n// 'wpid'. Returns error on failure, nil otherwise.\nfunc waitPid(wpid int) error {\n\tvar wstatus syscall.WaitStatus\n\tif *debug {\n\t\tlog.Printf(\"Waiting for pid %d to exit\", wpid)\n\t}\n\tif out, err := syscall.Wait4(wpid, &wstatus, 0, nil); out != wpid {\n\t\treturn fmt.Errorf(\"failed while waiting for process %d to exit. error: %s\", wpid, err)\n\t}\n\treturn nil\n}\n\nfunc runNetworkSetup() error {\n\tif len(*networkSetup) == 0 {\n\t\treturn nil\n\t}\n\tif *debug {\n\t\tfmt.Printf(\"Running network setup command: %s\\n\", *networkSetup)\n\t}\n\tif out, err := exec.Command(\"/bin/bash\", \"-c\", *networkSetup).CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"network setup command: %s, failed with output: %s and error: %s\", *networkSetup, out, err)\n\t}\n\treturn nil\n}\n\n// runCreaper does the following:\n// 1. creates the container with name 'containerName' and based on 'containerSpec'.\n// 2. waits for the init process in the container to exit.\n// 3. Runs User specified command 'userCommand' if specified.\n// 4. Destroys container once the init process in the container exits or if it\n// encounters any failure after creating the container.\n// Returns error if any of the steps fail.\nfunc runCreaper(containerName string, cSpec containerSpec, userCommand []string) error {\n\tif err := setChildSubreaper(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer destroyContainer(containerName)\n\t// TODO(vishnuk): Error out if the container already exists.\n\tlmctfyOutput, err := createContainer(containerName, cSpec)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitPID, err := extractInitPID(lmctfyOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := runNetworkSetup(); err != nil {\n\t\treturn err\n\t}\n\tmessage := make(chan error, 1)\n\tgo func() {\n\t\tmessage <- waitPid(initPID)\n\t}()\n\tif len(userCommand) > 0 {\n\t\tgo func() {\n\t\t\tmessage <- runCommandInContainer(containerName, userCommand)\n\t\t}()\n\t}\n\treturn <-message\n}\n\n// parseInput parses args and specFile and returns containerName, containerSpec and user command, if specified.\n// Returns error if input is invalid or any internal operation fails.\nfunc parseInput(args []string, specFile string) (string, containerSpec, []string, error) {\n\tif len(args) == 0 {\n\t\tflag.Usage()\n\t\treturn \"\", containerSpec{}, []string{}, fmt.Errorf(\"No args provided\")\n\t}\n\tcontainerName := args[0]\n\tvar userCommand []string\n\tvar cSpec containerSpec\n\tif len(specFile) > 0 {\n\t\tif _, err := os.Stat(specFile); err != nil {\n\t\t\treturn \"\", containerSpec{}, []string{},\n\t\t\t\tfmt.Errorf(\"cannot open config file %s. %s\", specFile, err)\n\t\t}\n\t\tcSpec.specFile = specFile\n\t\tif len(args) > 1 {\n\t\t\tuserCommand = args[1:]\n\t\t}\n\t} else {\n\t\tcSpec.commandLine = args[1]\n\t\tif len(args) > 2 {\n\t\t\tuserCommand = args[2:]\n\t\t}\n\t}\n\treturn containerName, cSpec, userCommand, nil\n}\n\n// main validates input, invokes runCreaper and exits with error code '1' if\n// runCreaper returns error.\nfunc main() {\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"Usage: lmctfy-creaper <containerName> {<containerSpec> | -specFile} [-networkSetup] [<command>]\\n\")\n\t\tflag.PrintDefaults()\n\t\tfmt.Fprintf(os.Stderr, \"  <containerName>: A Lmctfy container name.\\n\"+\n\t\t\t\"  <containerSpec>: Lmctfy Container spec.\\n\"+\n\t\t\t\"  <command>: An optional command to be run inside the container.\\n\"+\n\t\t\t\"  Note: The command will be killed as soon as the init process in the container virtual host exits.\\n\"+\n\t\t\t\"  Refer to include/lmctfy.proto for more information\\n\")\n\t}\n\tflag.Parse()\n\tcontainerName, cSpec, userCommand, err := parseInput(flag.Args(), *specFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := runCreaper(containerName, cSpec, userCommand); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "lmctfy",
          "type": "tree",
          "content": null
        },
        {
          "name": "nscon",
          "type": "tree",
          "content": null
        },
        {
          "name": "strings",
          "type": "tree",
          "content": null
        },
        {
          "name": "system_api",
          "type": "tree",
          "content": null
        },
        {
          "name": "thread",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}