{
  "metadata": {
    "timestamp": 1736565848063,
    "page": 792,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Nelarius/imnodes",
      "stars": 2137,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.998046875,
          "content": "---\nAccessModifierOffset: -4\nAlignAfterOpenBracket: 'AlwaysBreak'\nAlignConsecutiveDeclarations: 'true'\nAllowAllParametersOfDeclarationOnNextLine: 'false'\nAllowShortFunctionsOnASingleLine: 'true'\nAlwaysBreakBeforeMultilineStrings: 'true'\nAlwaysBreakTemplateDeclarations: 'true'\nBinPackArguments: 'false'\nBinPackParameters: 'false'\nBraceWrapping: {\n    AfterCaseLabel: 'true'\n    AfterClass: 'true'\n    AfterControlStatement: 'true'\n    AfterEnum: 'true'\n    AfterFunction: 'true'\n    AfterNamespace: 'true'\n    AfterStruct: 'true'\n    AfterUnion: 'true'\n    BeforeCatch: 'true'\n    BeforeElse: 'true'\n    IndentBraces: 'false'\n}\nBreakBeforeBraces: Custom\nColumnLimit: 100\nCpp11BracedListStyle: 'true'\nDerivePointerAlignment: 'false'\nIndentCaseLabels: 'false'\nIndentWidth: 4\nPenaltyExcessCharacter: 100000000\nPenaltyReturnTypeOnItsOwnLine: 100000000\nPointerAlignment: Left\nPointerBindsToType: 'true'\nSortIncludes: 'false'\nSpaceAfterTemplateKeyword: 'false'\nSpaceBeforeParens: ControlStatements\nTabWidth: 8\nUseTab: Never\n...\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 1.3671875,
          "content": "# Apply this style by doing\n#\n# clang-tidy -fix-errors -config= <source-files>\n#\n# Running the command without -fix-errors will generate warnings about each\n# style violation but won't change them.\n\nChecks: '-*,readability-identifier-naming'\nCheckOptions:\n  - key:             readability-identifier-naming.ClassCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.EnumCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.FunctionCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.MemberCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.MethodCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.NamespaceCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.ParameterCase\n    value:           lower_case\n  - key:             readability-identifier-naming.PrivateMemberCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.PrivateMemberPrefix\n    value:           '_'\n  - key:             readability-identifier-naming.StaticConstantCase\n    value:           UPPER_CASE\n  - key:             readability-identifier-naming.StructCase\n    value:           CamelCase\n  - key:             readability-identifier-naming.VariableCase\n    value:           lower_case\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 8.7900390625,
          "content": "### Local build ###\nbuild*/\n\n### ImGui ###\n**.ini\n\n# Created by https://www.toptal.com/developers/gitignore/api/sublimetext\n# Edit at https://www.toptal.com/developers/gitignore?templates=sublimetext\n\n### SublimeText ###\n# Cache files for Sublime Text\n*.tmlanguage.cache\n*.tmPreferences.cache\n*.stTheme.cache\n\n# Workspace files are user-specific\n*.sublime-workspace\n\n# Project files should be checked into the repository, unless a significant\n# proportion of contributors will probably not be using Sublime Text\n*.sublime-project\n\n# SFTP configuration file\nsftp-config.json\nsftp-config-alt*.json\n\n# Package control specific files\nPackage Control.last-run\nPackage Control.ca-list\nPackage Control.ca-bundle\nPackage Control.system-ca-bundle\nPackage Control.cache/\nPackage Control.ca-certs/\nPackage Control.merged-ca-bundle\nPackage Control.user-ca-bundle\noscrypto-ca-bundle.crt\nbh_unicode_properties.cache\n\n# Sublime-github package stores a github token in this file\n# https://packagecontrol.io/packages/sublime-github\nGitHub.sublime-settings\n\n# End of https://www.toptal.com/developers/gitignore/api/sublimetext\n\n# Created by https://www.gitignore.io/api/c,c++\n\n### C ###\n# Prerequisites\n*.d\n\n# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Linker output\n*.ilk\n*.map\n*.exp\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM/\n*.su\n*.idb\n*.pdb\n\n# Kernel Module Compile Results\n*.mod*\n*.cmd\n.tmp_versions/\nmodules.order\nModule.symvers\nMkfile.old\ndkms.conf\n\n### C++ ###\n# Prerequisites\n\n# Compiled Object files\n*.slo\n\n# Precompiled Headers\n\n# Compiled Dynamic libraries\n\n# Fortran module files\n*.mod\n*.smod\n\n# Compiled Static libraries\n*.lai\n\n# Executables\n\n\n# End of https://www.gitignore.io/api/c,c++\n\n# Created by https://www.gitignore.io/api/visualstudiocode\n\n### VisualStudioCode ###\n.vscode/*\n\n\n# End of https://www.gitignore.io/api/visualstudiocode\n\n# Created by https://www.gitignore.io/api/premake-gmake\n\n### premake-gmake ###\nMakefile\n*.make\nobj/\n\n\n# End of https://www.gitignore.io/api/premake-gmake\n\n\n# Created by https://www.gitignore.io/api/visualstudio\n# Edit at https://www.gitignore.io/?templates=visualstudio\n\n### VisualStudio ###\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# End of https://www.gitignore.io/api/visualstudio\n\n# Created by https://www.toptal.com/developers/gitignore/api/vcpkg\n# Edit at https://www.toptal.com/developers/gitignore?templates=vcpkg\n\n### vcpkg ###\n# Vcpkg\n\n## Manifest Mode\nvcpkg_installed/\n\n# End of https://www.toptal.com/developers/gitignore/api/vcpkg\n\n\n# Created by https://www.toptal.com/developers/gitignore/api/cmake\n# Edit at https://www.toptal.com/developers/gitignore?templates=cmake\n\n### CMake ###\nCMakeLists.txt.user\nCMakeCache.txt\nCMakeFiles\nCMakeScripts\nTesting\nMakefile\ncmake_install.cmake\ninstall_manifest.txt\ncompile_commands.json\nCTestTestfile.cmake\n_deps\n\n### CMake Patch ###\n# External projects\n*-prefix/\n\n# End of https://www.toptal.com/developers/gitignore/api/cmake\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.078125,
          "content": "[submodule \"vcpkg\"]\n\tpath = vcpkg\n\turl = https://github.com/microsoft/vcpkg.git\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.2724609375,
          "content": "cmake_minimum_required(VERSION 3.15)\n\nproject(imnodes)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\n\n# determine whether this is a standalone project or included by other projects\nif (NOT DEFINED IMNODES_STANDALONE_PROJECT)\n    if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n        set(IMNODES_STANDALONE_PROJECT ON)\n    else()\n        set(IMNODES_STANDALONE_PROJECT OFF)\n    endif ()\nendif()\n\n# cmake options\noption(IMNODES_EXAMPLES \"Build examples\" ${IMNODES_STANDALONE_PROJECT})\n\n# allow custom imgui target name since this can vary because imgui doesn't natively include a CMakeLists.txt\nif(NOT DEFINED IMNODES_IMGUI_TARGET_NAME)\n    find_package(imgui CONFIG REQUIRED)\n    set(IMNODES_IMGUI_TARGET_NAME imgui::imgui)\nendif()\n\n\nif(MSVC)\n    add_compile_definitions(SDL_MAIN_HANDLED)\n    add_compile_options(/WX)\n    # replace existing /W to avoid warning\n    if(CMAKE_CXX_FLAGS MATCHES \"/W[0-4]\")\n        string(REGEX REPLACE \"/W[0-4]\" \"/W4\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n    else()\n        add_compile_options(/W4)\n    endif()\nelse()\n    add_compile_options(-Wall -Wextra -Wpedantic -Werror)\nendif()\n\n# Imnodes\n\nadd_library(imnodes)\ntarget_sources(imnodes PRIVATE\n    imnodes.h\n    imnodes_internal.h\n    imnodes.cpp)\ntarget_include_directories(imnodes PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\ntarget_link_libraries(imnodes PUBLIC ${IMNODES_IMGUI_TARGET_NAME})\n\n# Example projects\nif(IMNODES_EXAMPLES)\n\n    find_package(SDL2 CONFIG REQUIRED)\n\n    add_executable(colornode\n        ${CMAKE_CURRENT_SOURCE_DIR}/imnodes.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/main.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/color_node_editor.cpp)\n    target_link_libraries(colornode imnodes SDL2::SDL2)\n    if (APPLE)\n        target_link_libraries(colornode \"-framework OpenGL\")\n    elseif(MSVC)\n        target_link_libraries(colornode \"opengl32\")\n    else()\n        target_link_libraries(colornode X11 Xext GL)\n    endif()\n\n    add_executable(multieditor\n        ${CMAKE_CURRENT_SOURCE_DIR}/imnodes.cpp \n        ${CMAKE_CURRENT_SOURCE_DIR}/example/main.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/multi_editor.cpp)\n    target_link_libraries(multieditor imnodes SDL2::SDL2)\n    if (APPLE)\n        target_link_libraries(multieditor \"-framework OpenGL\")\n    elseif(MSVC)\n        target_link_libraries(multieditor \"opengl32\")\n    else()\n        target_link_libraries(multieditor X11 Xext GL)\n    endif()\n\n    add_executable(saveload\n        ${CMAKE_CURRENT_SOURCE_DIR}/imnodes.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/main.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/save_load.cpp)\n    target_link_libraries(saveload imnodes SDL2::SDL2)\n    if (APPLE)\n        target_link_libraries(saveload \"-framework OpenGL\")\n    elseif(MSVC)\n        target_link_libraries(saveload \"opengl32\")\n    else()\n        target_link_libraries(saveload X11 Xext GL)\n    endif()\n\n    add_executable(hello\n        ${CMAKE_CURRENT_SOURCE_DIR}/imnodes.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/main.cpp\n        ${CMAKE_CURRENT_SOURCE_DIR}/example/hello.cpp)\n    target_link_libraries(hello imnodes SDL2::SDL2)\n    if (APPLE)\n        target_link_libraries(hello \"-framework OpenGL\")\n    elseif(MSVC)\n        target_link_libraries(hello \"opengl32\")\n    else()\n        target_link_libraries(hello X11 Xext GL)\n    endif()\nendif()\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2019 Johann Muszynski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.2412109375,
          "content": "<h1 align=\"center\">imnodes</h1>\n\n<p align=\"center\">A small, dependency-free node editor extension for <a href=\"https://github.com/ocornut/imgui\">dear imgui</a>.</p>\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/Nelarius/imnodes/master/img/imnodes.gif?token=ADH_jEpqbBrw0nH-BUmOip490dyO2CnRks5cVZllwA%3D%3D\">\n</p>\n\n[![Build Status](https://github.com/nelarius/imnodes/workflows/Build/badge.svg)](https://github.com/nelarius/imnodes/actions?workflow=Build)\n\nImnodes aims to provide a simple, immediate-mode interface for creating a node editor within an ImGui window. Imnodes provides simple, customizable building blocks that a user needs to build their node editor.\n\nFeatures:\n\n* Create nodes, links, and pins in an immediate-mode style. The user controls all the state.\n* Nest ImGui widgets inside nodes\n* Simple distribution, just copy-paste `imnodes.h`, `imnodes_internal.h`, and `imnodes.cpp` into your project along side ImGui.\n\n## Examples\n\nThis repository includes a few example files, under `example/`. They are intended as simple examples giving you an idea of what you can build with imnodes.\n\nIf you need to build the examples, you can use the provided CMake script to do so.\n\n```bash\n# Initialize the vcpkg submodule\n$ git submodule update --init\n# Run the generation step and build\n$ cmake -B build-release/ -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=vcpkg/scripts/buildsystems/vcpkg.cmake\n$ cmake --build build-release -- -j\n```\n\nNote that this has not been tested on Linux and is likely to fail on the platform.\n\n## A brief tour\n\nHere is a small overview of how the extension is used. For more information on example usage, scroll to the bottom of the README.\n\nBefore anything can be done, the library must be initialized. This can be done at the same time as `dear imgui` initialization.\n\n```cpp\nImGui::CreateContext();\nImNodes::CreateContext();\n\n// elsewhere in the code...\nImNodes::DestroyContext();\nImGui::DestroyContext();\n```\n\nThe node editor is a workspace which contains nodes. The node editor must be instantiated within a window, like any other UI element.\n\n```cpp\nImGui::Begin(\"node editor\");\n\nImNodes::BeginNodeEditor();\nImNodes::EndNodeEditor();\n\nImGui::End();\n```\n\nNow you should have a workspace with a grid visible in the window. An empty node can now be instantiated:\n\n```cpp\nconst int hardcoded_node_id = 1;\n\nImNodes::BeginNodeEditor();\n\nImNodes::BeginNode(hardcoded_node_id);\nImGui::Dummy(ImVec2(80.0f, 45.0f));\nImNodes::EndNode();\n\nImNodes::EndNodeEditor();\n```\n\nNodes, like windows in `dear imgui` must be uniquely identified. But we can't use the node titles for identification, because it should be possible to have many nodes of the same name in the workspace. Instead, you just use integers for identification.\n\nAttributes are the UI content of the node. An attribute will have a pin (the little circle) on either side of the node. There are two types of attributes: input, and output attributes. Input attribute pins are on the left side of the node, and output attribute pins are on the right. Like nodes, pins must be uniquely identified.\n\n```cpp\nImNodes::BeginNode(hardcoded_node_id);\n\nconst int output_attr_id = 2;\nImNodes::BeginOutputAttribute(output_attr_id);\n// in between Begin|EndAttribute calls, you can call ImGui\n// UI functions\nImGui::Text(\"output pin\");\nImNodes::EndOutputAttribute();\n\nImNodes::EndNode();\n```\n\nThe extension doesn't really care what is in the attribute. It just renders the pin for the attribute, and allows the user to create links between pins.\n\nA title bar can be added to the node using `BeginNodeTitleBar` and `EndNodeTitleBar`. Like attributes, you place your title bar's content between the function calls. Note that these functions have to be called before adding attributes or other `dear imgui` UI elements to the node, since the node's layout is built in order, top-to-bottom.\n\n```cpp\nImNodes::BeginNode(hardcoded_node_id);\n\nImNodes::BeginNodeTitleBar();\nImGui::TextUnformatted(\"output node\");\nImNodes::EndNodeTitleBar();\n\n// pins and other node UI content omitted...\n\nImNodes::EndNode();\n```\n\nThe user has to render their own links between nodes as well. A link is a curve which connects two attributes. A link is just a pair of attribute ids. And like nodes and attributes, links too have to be identified by unique integer values:\n\n```cpp\nstd::vector<std::pair<int, int>> links;\n// elsewhere in the code...\nfor (int i = 0; i < links.size(); ++i)\n{\n  const std::pair<int, int> p = links[i];\n  // in this case, we just use the array index of the link\n  // as the unique identifier\n  ImNodes::Link(i, p.first, p.second);\n}\n```\n\nAfter `EndNodeEditor` has been called, you can check if a link was created during the frame with the function call `IsLinkCreated`:\n\n```cpp\nint start_attr, end_attr;\nif (ImNodes::IsLinkCreated(&start_attr, &end_attr))\n{\n  links.push_back(std::make_pair(start_attr, end_attr));\n}\n```\n\nIn addition to checking for new links, you can also check whether UI elements are being hovered over by the mouse cursor:\n\n```cpp\nint node_id;\nif (ImNodes::IsNodeHovered(&node_id))\n{\n  node_hovered = node_id;\n}\n```\n\nYou can also check to see if any node has been selected. Nodes can be clicked on, or they can be selected by clicking and dragging the box selector over them.\n\n```cpp\n// Note that since many nodes can be selected at once, we first need to query the number of\n// selected nodes before getting them.\nconst int num_selected_nodes = ImNodes::NumSelectedNodes();\nif (num_selected_nodes > 0)\n{\n  std::vector<int> selected_nodes;\n  selected_nodes.resize(num_selected_nodes);\n  ImNodes::GetSelectedNodes(selected_nodes.data());\n}\n```\n\nSee `imnodes.h` for more UI event-related functions.\n\nLike `dear imgui`, the style of the UI can be changed. You can set the color style of individual nodes, pins, and links mid-frame by calling `ImNodes::PushColorStyle` and `ImNodes::PopColorStyle`.\n\n```cpp\n// set the titlebar color of an individual node\nImNodes::PushColorStyle(\n  ImNodesCol_TitleBar, IM_COL32(11, 109, 191, 255));\nImNodes::PushColorStyle(\n  ImNodesCol_TitleBarSelected, IM_COL32(81, 148, 204, 255));\n\nImNodes::BeginNode(hardcoded_node_id);\n// node internals here...\nImNodes::EndNode();\n\nImNodes::PopColorStyle();\nImNodes::PopColorStyle();\n```\n\nIf the style is not being set mid-frame, `ImNodes::GetStyle` can be called instead, and the values can be set into the style array directly.\n\n```cpp\n// set the titlebar color for all nodes\nImNodesStyle& style = ImNodes::GetStyle();\nstyle.colors[ImNodesCol_TitleBar] = IM_COL32(232, 27, 86, 255);\nstyle.colors[ImNodesCol_TitleBarSelected] = IM_COL32(241, 108, 146, 255);\n```\n\nTo handle quicker navigation of large graphs you can use an interactive mini-map overlay. The mini-map can be zoomed and scrolled. Editor nodes will track the panning of the mini-map accordingly.\n\n```cpp\nImGui::Begin(\"node editor\");\n\nImNodes::BeginNodeEditor();\n\n// add nodes...\n\n// must be called right before EndNodeEditor\nImNodes::MiniMap();\nImNodes::EndNodeEditor();\n\nImGui::End();\n```\n\nThe relative sizing and corner location of the mini-map in the editor space can be specified like so:\n\n```cpp\n// MiniMap is a square region with a side length that is 20% the largest editor canvas dimension\n// See ImNodesMiniMapLocation_ for other corner locations\nImNodes::MiniMap(0.2f, ImNodesMiniMapLocation_TopRight);\n```\n\nThe mini-map also supports limited node hovering customization through a user-defined callback.\n```cpp\n// User callback\nvoid mini_map_node_hovering_callback(int node_id, void* user_data)\n{\n  ImGui::SetTooltip(\"This is node %d\", node_id);\n}\n\n// Later on...\nImNodes::MiniMap(0.2f, ImNodesMiniMapLocation_TopRight, mini_map_node_hovering_callback, custom_user_data);\n\n// 'custom_user_data' can be used to supply extra information needed for drawing within the callback\n```\n\n## Customizing ImNodes\n\nImNodes can be customized by providing an `imnodes_config.h` header and specifying defining `IMNODES_USER_CONFIG=imnodes_config.h` when compiling.\n\nIt is currently possible to override the type of the minimap hovering callback function. This is useful when generating bindings for another language.\n\nHere's an example imnodes_config.h, which generates a pybind wrapper for the callback.\n```cpp\n#pragma once\n\n#include <pybind11/functional.h>\n\nnamespace pybind11 {\n\ninline bool PyWrapper_Check(PyObject *o) { return true; }\n\nclass wrapper : public object {\npublic:\n    PYBIND11_OBJECT_DEFAULT(wrapper, object, PyWrapper_Check)\n    wrapper(void* x) { m_ptr = (PyObject*)x; }\n    explicit operator bool() const { return m_ptr != nullptr && m_ptr != Py_None; }\n};\n\n} //namespace pybind11\n\nnamespace py = pybind11;\n\n#define ImNodesMiniMapNodeHoveringCallback py::wrapper\n\n#define ImNodesMiniMapNodeHoveringCallbackUserData py::wrapper\n```\n\n## Known issues\n\n* `ImGui::Separator()` spans the current window span. As a result, using a separator inside a node will result in the separator spilling out of the node into the node editor grid.\n\n## Further information\n\nSee the `examples/` directory to see library usage in greater detail.\n\n* simple.cpp is a simple hello-world style program which displays two nodes\n* save_load.cpp is enables you to add and remove nodes and links, and serializes/deserializes them, so that the program state is retained between restarting the program\n* color_node_editor.cpp is a more complete example, which shows how a simple node editor is implemented with a graph.\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "imnodes.cpp",
          "type": "blob",
          "size": 111.421875,
          "content": "// the structure of this file:\n//\n// [SECTION] bezier curve helpers\n// [SECTION] draw list helper\n// [SECTION] ui state logic\n// [SECTION] render helpers\n// [SECTION] API implementation\n\n#include \"imnodes_internal.h\"\n\n// Check minimum ImGui version\n#define MINIMUM_COMPATIBLE_IMGUI_VERSION 17400\n#if IMGUI_VERSION_NUM < MINIMUM_COMPATIBLE_IMGUI_VERSION\n#error \"Minimum ImGui version requirement not met -- please use a newer version!\"\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <new>\n#include <stdint.h>\n#include <stdio.h> // for fwrite, ssprintf, sscanf\n#include <stdlib.h>\n#include <string.h> // strlen, strncmp\n\n// Use secure CRT function variants to avoid MSVC compiler errors\n#ifdef _MSC_VER\n#define sscanf sscanf_s\n#endif\n\nImNodesContext* GImNodes = NULL;\n\nnamespace IMNODES_NAMESPACE\n{\nnamespace\n{\n// [SECTION] bezier curve helpers\n\nstruct CubicBezier\n{\n    ImVec2 P0, P1, P2, P3;\n    int    NumSegments;\n};\n\ninline ImVec2 EvalCubicBezier(\n    const float   t,\n    const ImVec2& P0,\n    const ImVec2& P1,\n    const ImVec2& P2,\n    const ImVec2& P3)\n{\n    // B(t) = (1-t)**3 p0 + 3(1 - t)**2 t P1 + 3(1-t)t**2 P2 + t**3 P3\n\n    const float u = 1.0f - t;\n    const float b0 = u * u * u;\n    const float b1 = 3 * u * u * t;\n    const float b2 = 3 * u * t * t;\n    const float b3 = t * t * t;\n    return ImVec2(\n        b0 * P0.x + b1 * P1.x + b2 * P2.x + b3 * P3.x,\n        b0 * P0.y + b1 * P1.y + b2 * P2.y + b3 * P3.y);\n}\n\n// Calculates the closest point along each bezier curve segment.\nImVec2 GetClosestPointOnCubicBezier(const int num_segments, const ImVec2& p, const CubicBezier& cb)\n{\n    IM_ASSERT(num_segments > 0);\n    ImVec2 p_last = cb.P0;\n    ImVec2 p_closest;\n    float  p_closest_dist = FLT_MAX;\n    float  t_step = 1.0f / (float)num_segments;\n    for (int i = 1; i <= num_segments; ++i)\n    {\n        ImVec2 p_current = EvalCubicBezier(t_step * i, cb.P0, cb.P1, cb.P2, cb.P3);\n        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);\n        float  dist = ImLengthSqr(p - p_line);\n        if (dist < p_closest_dist)\n        {\n            p_closest = p_line;\n            p_closest_dist = dist;\n        }\n        p_last = p_current;\n    }\n    return p_closest;\n}\n\ninline float GetDistanceToCubicBezier(\n    const ImVec2&      pos,\n    const CubicBezier& cubic_bezier,\n    const int          num_segments)\n{\n    const ImVec2 point_on_curve = GetClosestPointOnCubicBezier(num_segments, pos, cubic_bezier);\n\n    const ImVec2 to_curve = point_on_curve - pos;\n    return ImSqrt(ImLengthSqr(to_curve));\n}\n\ninline ImRect GetContainingRectForCubicBezier(const CubicBezier& cb)\n{\n    const ImVec2 min = ImVec2(ImMin(cb.P0.x, cb.P3.x), ImMin(cb.P0.y, cb.P3.y));\n    const ImVec2 max = ImVec2(ImMax(cb.P0.x, cb.P3.x), ImMax(cb.P0.y, cb.P3.y));\n\n    const float hover_distance = GImNodes->Style.LinkHoverDistance;\n\n    ImRect rect(min, max);\n    rect.Add(cb.P1);\n    rect.Add(cb.P2);\n    rect.Expand(ImVec2(hover_distance, hover_distance));\n\n    return rect;\n}\n\ninline CubicBezier GetCubicBezier(\n    ImVec2                     start,\n    ImVec2                     end,\n    const ImNodesAttributeType start_type,\n    const float                line_segments_per_length)\n{\n    IM_ASSERT(\n        (start_type == ImNodesAttributeType_Input) || (start_type == ImNodesAttributeType_Output));\n    if (start_type == ImNodesAttributeType_Input)\n    {\n        ImSwap(start, end);\n    }\n\n    const float  link_length = ImSqrt(ImLengthSqr(end - start));\n    const ImVec2 offset = ImVec2(0.25f * link_length, 0.f);\n    CubicBezier  cubic_bezier;\n    cubic_bezier.P0 = start;\n    cubic_bezier.P1 = start + offset;\n    cubic_bezier.P2 = end - offset;\n    cubic_bezier.P3 = end;\n    cubic_bezier.NumSegments = ImMax(static_cast<int>(link_length * line_segments_per_length), 1);\n    return cubic_bezier;\n}\n\ninline float EvalImplicitLineEq(const ImVec2& p1, const ImVec2& p2, const ImVec2& p)\n{\n    return (p2.y - p1.y) * p.x + (p1.x - p2.x) * p.y + (p2.x * p1.y - p1.x * p2.y);\n}\n\ninline int Sign(float val) { return int(val > 0.0f) - int(val < 0.0f); }\n\ninline bool RectangleOverlapsLineSegment(const ImRect& rect, const ImVec2& p1, const ImVec2& p2)\n{\n    // Trivial case: rectangle contains an endpoint\n    if (rect.Contains(p1) || rect.Contains(p2))\n    {\n        return true;\n    }\n\n    // Flip rectangle if necessary\n    ImRect flip_rect = rect;\n\n    if (flip_rect.Min.x > flip_rect.Max.x)\n    {\n        ImSwap(flip_rect.Min.x, flip_rect.Max.x);\n    }\n\n    if (flip_rect.Min.y > flip_rect.Max.y)\n    {\n        ImSwap(flip_rect.Min.y, flip_rect.Max.y);\n    }\n\n    // Trivial case: line segment lies to one particular side of rectangle\n    if ((p1.x < flip_rect.Min.x && p2.x < flip_rect.Min.x) ||\n        (p1.x > flip_rect.Max.x && p2.x > flip_rect.Max.x) ||\n        (p1.y < flip_rect.Min.y && p2.y < flip_rect.Min.y) ||\n        (p1.y > flip_rect.Max.y && p2.y > flip_rect.Max.y))\n    {\n        return false;\n    }\n\n    const int corner_signs[4] = {\n        Sign(EvalImplicitLineEq(p1, p2, flip_rect.Min)),\n        Sign(EvalImplicitLineEq(p1, p2, ImVec2(flip_rect.Max.x, flip_rect.Min.y))),\n        Sign(EvalImplicitLineEq(p1, p2, ImVec2(flip_rect.Min.x, flip_rect.Max.y))),\n        Sign(EvalImplicitLineEq(p1, p2, flip_rect.Max))};\n\n    int sum = 0;\n    int sum_abs = 0;\n\n    for (int i = 0; i < 4; ++i)\n    {\n        sum += corner_signs[i];\n        sum_abs += abs(corner_signs[i]);\n    }\n\n    // At least one corner of rectangle lies on a different side of line segment\n    return abs(sum) != sum_abs;\n}\n\ninline bool RectangleOverlapsBezier(const ImRect& rectangle, const CubicBezier& cubic_bezier)\n{\n    ImVec2 current =\n        EvalCubicBezier(0.f, cubic_bezier.P0, cubic_bezier.P1, cubic_bezier.P2, cubic_bezier.P3);\n    const float dt = 1.0f / cubic_bezier.NumSegments;\n    for (int s = 0; s < cubic_bezier.NumSegments; ++s)\n    {\n        ImVec2 next = EvalCubicBezier(\n            static_cast<float>((s + 1) * dt),\n            cubic_bezier.P0,\n            cubic_bezier.P1,\n            cubic_bezier.P2,\n            cubic_bezier.P3);\n        if (RectangleOverlapsLineSegment(rectangle, current, next))\n        {\n            return true;\n        }\n        current = next;\n    }\n    return false;\n}\n\ninline bool RectangleOverlapsLink(\n    const ImRect&              rectangle,\n    const ImVec2&              start,\n    const ImVec2&              end,\n    const ImNodesAttributeType start_type)\n{\n    // First level: simple rejection test via rectangle overlap:\n\n    ImRect lrect = ImRect(start, end);\n    if (lrect.Min.x > lrect.Max.x)\n    {\n        ImSwap(lrect.Min.x, lrect.Max.x);\n    }\n\n    if (lrect.Min.y > lrect.Max.y)\n    {\n        ImSwap(lrect.Min.y, lrect.Max.y);\n    }\n\n    if (rectangle.Overlaps(lrect))\n    {\n        // First, check if either one or both endpoinds are trivially contained\n        // in the rectangle\n\n        if (rectangle.Contains(start) || rectangle.Contains(end))\n        {\n            return true;\n        }\n\n        // Second level of refinement: do a more expensive test against the\n        // link\n\n        const CubicBezier cubic_bezier =\n            GetCubicBezier(start, end, start_type, GImNodes->Style.LinkLineSegmentsPerLength);\n        return RectangleOverlapsBezier(rectangle, cubic_bezier);\n    }\n\n    return false;\n}\n\n// [SECTION] coordinate space conversion helpers\n\ninline ImVec2 ScreenSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return v - GImNodes->CanvasOriginScreenSpace - editor.Panning;\n}\n\ninline ImRect ScreenSpaceToGridSpace(const ImNodesEditorContext& editor, const ImRect& r)\n{\n    return ImRect(ScreenSpaceToGridSpace(editor, r.Min), ScreenSpaceToGridSpace(editor, r.Max));\n}\n\ninline ImVec2 GridSpaceToScreenSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return v + GImNodes->CanvasOriginScreenSpace + editor.Panning;\n}\n\ninline ImVec2 GridSpaceToEditorSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return v + editor.Panning;\n}\n\ninline ImVec2 EditorSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return v - editor.Panning;\n}\n\ninline ImVec2 EditorSpaceToScreenSpace(const ImVec2& v)\n{\n    return GImNodes->CanvasOriginScreenSpace + v;\n}\n\ninline ImVec2 MiniMapSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return (v - editor.MiniMapContentScreenSpace.Min) / editor.MiniMapScaling +\n           editor.GridContentBounds.Min;\n}\n\ninline ImVec2 ScreenSpaceToMiniMapSpace(const ImNodesEditorContext& editor, const ImVec2& v)\n{\n    return (ScreenSpaceToGridSpace(editor, v) - editor.GridContentBounds.Min) *\n               editor.MiniMapScaling +\n           editor.MiniMapContentScreenSpace.Min;\n}\n\ninline ImRect ScreenSpaceToMiniMapSpace(const ImNodesEditorContext& editor, const ImRect& r)\n{\n    return ImRect(\n        ScreenSpaceToMiniMapSpace(editor, r.Min), ScreenSpaceToMiniMapSpace(editor, r.Max));\n}\n\n// [SECTION] draw list helper\n\nvoid ImDrawListGrowChannels(ImDrawList* draw_list, const int num_channels)\n{\n    ImDrawListSplitter& splitter = draw_list->_Splitter;\n\n    if (splitter._Count == 1)\n    {\n        splitter.Split(draw_list, num_channels + 1);\n        return;\n    }\n\n    // NOTE: this logic has been lifted from ImDrawListSplitter::Split with slight modifications\n    // to allow nested splits. The main modification is that we only create new ImDrawChannel\n    // instances after splitter._Count, instead of over the whole splitter._Channels array like\n    // the regular ImDrawListSplitter::Split method does.\n\n    const int old_channel_capacity = splitter._Channels.Size;\n    // NOTE: _Channels is not resized down, and therefore _Count <= _Channels.size()!\n    const int old_channel_count = splitter._Count;\n    const int requested_channel_count = old_channel_count + num_channels;\n    if (old_channel_capacity < old_channel_count + num_channels)\n    {\n        splitter._Channels.resize(requested_channel_count);\n    }\n\n    splitter._Count = requested_channel_count;\n\n    for (int i = old_channel_count; i < requested_channel_count; ++i)\n    {\n        ImDrawChannel& channel = splitter._Channels[i];\n\n        // If we're inside the old capacity region of the array, we need to reuse the existing\n        // memory of the command and index buffers.\n        if (i < old_channel_capacity)\n        {\n            channel._CmdBuffer.resize(0);\n            channel._IdxBuffer.resize(0);\n        }\n        // Else, we need to construct new draw channels.\n        else\n        {\n            IM_PLACEMENT_NEW(&channel) ImDrawChannel();\n        }\n\n        {\n            ImDrawCmd draw_cmd;\n            draw_cmd.ClipRect = draw_list->_ClipRectStack.back();\n            draw_cmd.TextureId = draw_list->_TextureIdStack.back();\n            channel._CmdBuffer.push_back(draw_cmd);\n        }\n    }\n}\n\nvoid ImDrawListSplitterSwapChannels(\n    ImDrawListSplitter& splitter,\n    const int           lhs_idx,\n    const int           rhs_idx)\n{\n    if (lhs_idx == rhs_idx)\n    {\n        return;\n    }\n\n    IM_ASSERT(lhs_idx >= 0 && lhs_idx < splitter._Count);\n    IM_ASSERT(rhs_idx >= 0 && rhs_idx < splitter._Count);\n\n    ImDrawChannel& lhs_channel = splitter._Channels[lhs_idx];\n    ImDrawChannel& rhs_channel = splitter._Channels[rhs_idx];\n    lhs_channel._CmdBuffer.swap(rhs_channel._CmdBuffer);\n    lhs_channel._IdxBuffer.swap(rhs_channel._IdxBuffer);\n\n    const int current_channel = splitter._Current;\n\n    if (current_channel == lhs_idx)\n    {\n        splitter._Current = rhs_idx;\n    }\n    else if (current_channel == rhs_idx)\n    {\n        splitter._Current = lhs_idx;\n    }\n}\n\nvoid DrawListSet(ImDrawList* window_draw_list)\n{\n    GImNodes->CanvasDrawList = window_draw_list;\n    GImNodes->NodeIdxToSubmissionIdx.Clear();\n    GImNodes->NodeIdxSubmissionOrder.clear();\n}\n\n// The draw list channels are structured as follows. First we have our base channel, the canvas grid\n// on which we render the grid lines in BeginNodeEditor(). The base channel is the reason\n// draw_list_submission_idx_to_background_channel_idx offsets the index by one. Each BeginNode()\n// call appends two new draw channels, for the node background and foreground. The node foreground\n// is the channel into which the node's ImGui content is rendered. Finally, in EndNodeEditor() we\n// append one last draw channel for rendering the selection box and the incomplete link on top of\n// everything else.\n//\n// +----------+----------+----------+----------+----------+----------+\n// |          |          |          |          |          |          |\n// |canvas    |node      |node      |...       |...       |click     |\n// |grid      |background|foreground|          |          |interaction\n// |          |          |          |          |          |          |\n// +----------+----------+----------+----------+----------+----------+\n//            |                     |\n//            |   submission idx    |\n//            |                     |\n//            -----------------------\n\nvoid DrawListAddNode(const int node_idx)\n{\n    GImNodes->NodeIdxToSubmissionIdx.SetInt(\n        static_cast<ImGuiID>(node_idx), GImNodes->NodeIdxSubmissionOrder.Size);\n    GImNodes->NodeIdxSubmissionOrder.push_back(node_idx);\n    ImDrawListGrowChannels(GImNodes->CanvasDrawList, 2);\n}\n\nvoid DrawListAppendClickInteractionChannel()\n{\n    // NOTE: don't use this function outside of EndNodeEditor. Using this before all nodes have been\n    // added will screw up the node draw order.\n    ImDrawListGrowChannels(GImNodes->CanvasDrawList, 1);\n}\n\nint DrawListSubmissionIdxToBackgroundChannelIdx(const int submission_idx)\n{\n    // NOTE: the first channel is the canvas background, i.e. the grid\n    return 1 + 2 * submission_idx;\n}\n\nint DrawListSubmissionIdxToForegroundChannelIdx(const int submission_idx)\n{\n    return DrawListSubmissionIdxToBackgroundChannelIdx(submission_idx) + 1;\n}\n\nvoid DrawListActivateClickInteractionChannel()\n{\n    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(\n        GImNodes->CanvasDrawList, GImNodes->CanvasDrawList->_Splitter._Count - 1);\n}\n\nvoid DrawListActivateCurrentNodeForeground()\n{\n    const int foreground_channel_idx =\n        DrawListSubmissionIdxToForegroundChannelIdx(GImNodes->NodeIdxSubmissionOrder.Size - 1);\n    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(\n        GImNodes->CanvasDrawList, foreground_channel_idx);\n}\n\nvoid DrawListActivateNodeBackground(const int node_idx)\n{\n    const int submission_idx =\n        GImNodes->NodeIdxToSubmissionIdx.GetInt(static_cast<ImGuiID>(node_idx), -1);\n    // There is a discrepancy in the submitted node count and the rendered node count! Did you call\n    // one of the following functions\n    // * EditorContextMoveToNode\n    // * SetNodeScreenSpacePos\n    // * SetNodeGridSpacePos\n    // * SetNodeDraggable\n    // after the BeginNode/EndNode function calls?\n    IM_ASSERT(submission_idx != -1);\n    const int background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(submission_idx);\n    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(\n        GImNodes->CanvasDrawList, background_channel_idx);\n}\n\nvoid DrawListSwapSubmissionIndices(const int lhs_idx, const int rhs_idx)\n{\n    IM_ASSERT(lhs_idx != rhs_idx);\n\n    const int lhs_foreground_channel_idx = DrawListSubmissionIdxToForegroundChannelIdx(lhs_idx);\n    const int lhs_background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(lhs_idx);\n    const int rhs_foreground_channel_idx = DrawListSubmissionIdxToForegroundChannelIdx(rhs_idx);\n    const int rhs_background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(rhs_idx);\n\n    ImDrawListSplitterSwapChannels(\n        GImNodes->CanvasDrawList->_Splitter,\n        lhs_background_channel_idx,\n        rhs_background_channel_idx);\n    ImDrawListSplitterSwapChannels(\n        GImNodes->CanvasDrawList->_Splitter,\n        lhs_foreground_channel_idx,\n        rhs_foreground_channel_idx);\n}\n\nvoid DrawListSortChannelsByDepth(const ImVector<int>& node_idx_depth_order)\n{\n    if (GImNodes->NodeIdxToSubmissionIdx.Data.Size < 2)\n    {\n        return;\n    }\n\n    IM_ASSERT(node_idx_depth_order.Size == GImNodes->NodeIdxSubmissionOrder.Size);\n\n    int start_idx = node_idx_depth_order.Size - 1;\n\n    while (node_idx_depth_order[start_idx] == GImNodes->NodeIdxSubmissionOrder[start_idx])\n    {\n        if (--start_idx == 0)\n        {\n            // early out if submission order and depth order are the same\n            return;\n        }\n    }\n\n    // TODO: this is an O(N^2) algorithm. It might be worthwhile revisiting this to see if the time\n    // complexity can be reduced.\n\n    for (int depth_idx = start_idx; depth_idx > 0; --depth_idx)\n    {\n        const int node_idx = node_idx_depth_order[depth_idx];\n\n        // Find the current index of the node_idx in the submission order array\n        int submission_idx = -1;\n        for (int i = 0; i < GImNodes->NodeIdxSubmissionOrder.Size; ++i)\n        {\n            if (GImNodes->NodeIdxSubmissionOrder[i] == node_idx)\n            {\n                submission_idx = i;\n                break;\n            }\n        }\n        IM_ASSERT(submission_idx >= 0);\n\n        if (submission_idx == depth_idx)\n        {\n            continue;\n        }\n\n        for (int j = submission_idx; j < depth_idx; ++j)\n        {\n            DrawListSwapSubmissionIndices(j, j + 1);\n            ImSwap(GImNodes->NodeIdxSubmissionOrder[j], GImNodes->NodeIdxSubmissionOrder[j + 1]);\n        }\n    }\n}\n\n// [SECTION] ui state logic\n\nImVec2 GetScreenSpacePinCoordinates(\n    const ImRect&              node_rect,\n    const ImRect&              attribute_rect,\n    const ImNodesAttributeType type)\n{\n    IM_ASSERT(type == ImNodesAttributeType_Input || type == ImNodesAttributeType_Output);\n    const float x = type == ImNodesAttributeType_Input\n                        ? (node_rect.Min.x - GImNodes->Style.PinOffset)\n                        : (node_rect.Max.x + GImNodes->Style.PinOffset);\n    return ImVec2(x, 0.5f * (attribute_rect.Min.y + attribute_rect.Max.y));\n}\n\nImVec2 GetScreenSpacePinCoordinates(const ImNodesEditorContext& editor, const ImPinData& pin)\n{\n    const ImRect& parent_node_rect = editor.Nodes.Pool[pin.ParentNodeIdx].Rect;\n    return GetScreenSpacePinCoordinates(parent_node_rect, pin.AttributeRect, pin.Type);\n}\n\nbool MouseInCanvas()\n{\n    // This flag should be true either when hovering or clicking something in the canvas.\n    const bool is_window_hovered_or_focused = ImGui::IsWindowHovered() || ImGui::IsWindowFocused();\n\n    return is_window_hovered_or_focused &&\n           GImNodes->CanvasRectScreenSpace.Contains(ImGui::GetMousePos());\n}\n\nvoid BeginNodeSelection(ImNodesEditorContext& editor, const int node_idx)\n{\n    // Don't start selecting a node if we are e.g. already creating and dragging\n    // a new link! New link creation can happen when the mouse is clicked over\n    // a node, but within the hover radius of a pin.\n    if (editor.ClickInteraction.Type != ImNodesClickInteractionType_None)\n    {\n        return;\n    }\n\n    editor.ClickInteraction.Type = ImNodesClickInteractionType_Node;\n    // If the node is not already contained in the selection, then we want only\n    // the interaction node to be selected, effective immediately.\n    //\n    // If the multiple selection modifier is active, we want to add this node\n    // to the current list of selected nodes.\n    //\n    // Otherwise, we want to allow for the possibility of multiple nodes to be\n    // moved at once.\n    if (!editor.SelectedNodeIndices.contains(node_idx))\n    {\n        editor.SelectedLinkIndices.clear();\n        if (!GImNodes->MultipleSelectModifier)\n        {\n            editor.SelectedNodeIndices.clear();\n        }\n        editor.SelectedNodeIndices.push_back(node_idx);\n\n        // Ensure that individually selected nodes get rendered on top\n        ImVector<int>&   depth_stack = editor.NodeDepthOrder;\n        const int* const elem = depth_stack.find(node_idx);\n        IM_ASSERT(elem != depth_stack.end());\n        depth_stack.erase(elem);\n        depth_stack.push_back(node_idx);\n    }\n    // Deselect a previously-selected node\n    else if (GImNodes->MultipleSelectModifier)\n    {\n        const int* const node_ptr = editor.SelectedNodeIndices.find(node_idx);\n        editor.SelectedNodeIndices.erase(node_ptr);\n\n        // Don't allow dragging after deselecting\n        editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n    }\n\n    // To support snapping of multiple nodes, we need to store the offset of\n    // each node in the selection to the origin of the dragged node.\n    const ImVec2 ref_origin = editor.Nodes.Pool[node_idx].Origin;\n    editor.PrimaryNodeOffset =\n        ref_origin + GImNodes->CanvasOriginScreenSpace + editor.Panning - GImNodes->MousePos;\n\n    editor.SelectedNodeOffsets.clear();\n    for (int idx = 0; idx < editor.SelectedNodeIndices.Size; idx++)\n    {\n        const int    node = editor.SelectedNodeIndices[idx];\n        const ImVec2 node_origin = editor.Nodes.Pool[node].Origin - ref_origin;\n        editor.SelectedNodeOffsets.push_back(node_origin);\n    }\n}\n\nvoid BeginLinkSelection(ImNodesEditorContext& editor, const int link_idx)\n{\n    editor.ClickInteraction.Type = ImNodesClickInteractionType_Link;\n    // When a link is selected, clear all other selections, and insert the link\n    // as the sole selection.\n    editor.SelectedNodeIndices.clear();\n    editor.SelectedLinkIndices.clear();\n    editor.SelectedLinkIndices.push_back(link_idx);\n}\n\nvoid BeginLinkDetach(ImNodesEditorContext& editor, const int link_idx, const int detach_pin_idx)\n{\n    const ImLinkData&        link = editor.Links.Pool[link_idx];\n    ImClickInteractionState& state = editor.ClickInteraction;\n    state.Type = ImNodesClickInteractionType_LinkCreation;\n    state.LinkCreation.EndPinIdx.Reset();\n    state.LinkCreation.StartPinIdx =\n        detach_pin_idx == link.StartPinIdx ? link.EndPinIdx : link.StartPinIdx;\n    GImNodes->DeletedLinkIdx = link_idx;\n}\n\nvoid BeginLinkCreation(ImNodesEditorContext& editor, const int hovered_pin_idx)\n{\n    editor.ClickInteraction.Type = ImNodesClickInteractionType_LinkCreation;\n    editor.ClickInteraction.LinkCreation.StartPinIdx = hovered_pin_idx;\n    editor.ClickInteraction.LinkCreation.EndPinIdx.Reset();\n    editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_Standard;\n    GImNodes->ImNodesUIState |= ImNodesUIState_LinkStarted;\n}\n\nvoid BeginLinkInteraction(\n    ImNodesEditorContext& editor,\n    const int             link_idx,\n    const ImOptionalIndex pin_idx = ImOptionalIndex())\n{\n    // Check if we are clicking the link with the modifier pressed.\n    // This will in a link detach via clicking.\n\n    const bool modifier_pressed = GImNodes->Io.LinkDetachWithModifierClick.Modifier == NULL\n                                      ? false\n                                      : *GImNodes->Io.LinkDetachWithModifierClick.Modifier;\n\n    if (modifier_pressed)\n    {\n        const ImLinkData& link = editor.Links.Pool[link_idx];\n        const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];\n        const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];\n        const ImVec2&     mouse_pos = GImNodes->MousePos;\n        const float       dist_to_start = ImLengthSqr(start_pin.Pos - mouse_pos);\n        const float       dist_to_end = ImLengthSqr(end_pin.Pos - mouse_pos);\n        const int closest_pin_idx = dist_to_start < dist_to_end ? link.StartPinIdx : link.EndPinIdx;\n\n        editor.ClickInteraction.Type = ImNodesClickInteractionType_LinkCreation;\n        BeginLinkDetach(editor, link_idx, closest_pin_idx);\n        editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_FromDetach;\n    }\n    else\n    {\n        if (pin_idx.HasValue())\n        {\n            const int hovered_pin_flags = editor.Pins.Pool[pin_idx.Value()].Flags;\n\n            // Check the 'click and drag to detach' case.\n            if (hovered_pin_flags & ImNodesAttributeFlags_EnableLinkDetachWithDragClick)\n            {\n                BeginLinkDetach(editor, link_idx, pin_idx.Value());\n                editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_FromDetach;\n            }\n            else\n            {\n                BeginLinkCreation(editor, pin_idx.Value());\n            }\n        }\n        else\n        {\n            BeginLinkSelection(editor, link_idx);\n        }\n    }\n}\n\nstatic inline bool IsMiniMapHovered();\n\nvoid BeginCanvasInteraction(ImNodesEditorContext& editor)\n{\n    const bool any_ui_element_hovered =\n        GImNodes->HoveredNodeIdx.HasValue() || GImNodes->HoveredLinkIdx.HasValue() ||\n        GImNodes->HoveredPinIdx.HasValue() || ImGui::IsAnyItemHovered();\n\n    const bool mouse_not_in_canvas = !MouseInCanvas();\n\n    if (editor.ClickInteraction.Type != ImNodesClickInteractionType_None ||\n        any_ui_element_hovered || mouse_not_in_canvas)\n    {\n        return;\n    }\n\n    const bool started_panning = GImNodes->AltMouseClicked;\n\n    if (started_panning)\n    {\n        editor.ClickInteraction.Type = ImNodesClickInteractionType_Panning;\n    }\n    else if (GImNodes->LeftMouseClicked)\n    {\n        editor.ClickInteraction.Type = ImNodesClickInteractionType_BoxSelection;\n        editor.ClickInteraction.BoxSelector.Rect.Min =\n            ScreenSpaceToGridSpace(editor, GImNodes->MousePos);\n    }\n}\n\nvoid BoxSelectorUpdateSelection(ImNodesEditorContext& editor, ImRect box_rect)\n{\n    // Invert box selector coordinates as needed\n\n    if (box_rect.Min.x > box_rect.Max.x)\n    {\n        ImSwap(box_rect.Min.x, box_rect.Max.x);\n    }\n\n    if (box_rect.Min.y > box_rect.Max.y)\n    {\n        ImSwap(box_rect.Min.y, box_rect.Max.y);\n    }\n\n    // Update node selection\n\n    editor.SelectedNodeIndices.clear();\n\n    // Test for overlap against node rectangles\n\n    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)\n    {\n        if (editor.Nodes.InUse[node_idx])\n        {\n            ImNodeData& node = editor.Nodes.Pool[node_idx];\n            if (box_rect.Overlaps(node.Rect))\n            {\n                editor.SelectedNodeIndices.push_back(node_idx);\n            }\n        }\n    }\n\n    // Update link selection\n\n    editor.SelectedLinkIndices.clear();\n\n    // Test for overlap against links\n\n    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)\n    {\n        if (editor.Links.InUse[link_idx])\n        {\n            const ImLinkData& link = editor.Links.Pool[link_idx];\n\n            const ImPinData& pin_start = editor.Pins.Pool[link.StartPinIdx];\n            const ImPinData& pin_end = editor.Pins.Pool[link.EndPinIdx];\n            const ImRect&    node_start_rect = editor.Nodes.Pool[pin_start.ParentNodeIdx].Rect;\n            const ImRect&    node_end_rect = editor.Nodes.Pool[pin_end.ParentNodeIdx].Rect;\n\n            const ImVec2 start = GetScreenSpacePinCoordinates(\n                node_start_rect, pin_start.AttributeRect, pin_start.Type);\n            const ImVec2 end =\n                GetScreenSpacePinCoordinates(node_end_rect, pin_end.AttributeRect, pin_end.Type);\n\n            // Test\n            if (RectangleOverlapsLink(box_rect, start, end, pin_start.Type))\n            {\n                editor.SelectedLinkIndices.push_back(link_idx);\n            }\n        }\n    }\n}\n\nImVec2 SnapOriginToGrid(ImVec2 origin)\n{\n    if (GImNodes->Style.Flags & ImNodesStyleFlags_GridSnapping)\n    {\n        const float spacing = GImNodes->Style.GridSpacing;\n        const float spacing2 = spacing * 0.5f;\n\n        // Snap the origin to the nearest grid point in any direction\n        float modx = fmodf(fabsf(origin.x) + spacing2, spacing) - spacing2;\n        float mody = fmodf(fabsf(origin.y) + spacing2, spacing) - spacing2;\n        origin.x += (origin.x < 0.f) ? modx : -modx;\n        origin.y += (origin.y < 0.f) ? mody : -mody;\n    }\n\n    return origin;\n}\n\nvoid TranslateSelectedNodes(ImNodesEditorContext& editor)\n{\n    if (GImNodes->LeftMouseDragging)\n    {\n        // If we have grid snap enabled, don't start moving nodes until we've moved the mouse\n        // slightly\n        const bool shouldTranslate = (GImNodes->Style.Flags & ImNodesStyleFlags_GridSnapping)\n                                         ? ImGui::GetIO().MouseDragMaxDistanceSqr[0] > 5.0\n                                         : true;\n\n        const ImVec2 origin = SnapOriginToGrid(\n            GImNodes->MousePos - GImNodes->CanvasOriginScreenSpace - editor.Panning +\n            editor.PrimaryNodeOffset);\n        for (int i = 0; i < editor.SelectedNodeIndices.size(); ++i)\n        {\n            const ImVec2 node_rel = editor.SelectedNodeOffsets[i];\n            const int    node_idx = editor.SelectedNodeIndices[i];\n            ImNodeData&  node = editor.Nodes.Pool[node_idx];\n            if (node.Draggable && shouldTranslate)\n            {\n                node.Origin = origin + node_rel + editor.AutoPanningDelta;\n            }\n        }\n    }\n}\n\nstruct LinkPredicate\n{\n    bool operator()(const ImLinkData& lhs, const ImLinkData& rhs) const\n    {\n        // Do a unique compare by sorting the pins' addresses.\n        // This catches duplicate links, whether they are in the\n        // same direction or not.\n        // Sorting by pin index should have the uniqueness guarantees as sorting\n        // by id -- each unique id will get one slot in the link pool array.\n\n        int lhs_start = lhs.StartPinIdx;\n        int lhs_end = lhs.EndPinIdx;\n        int rhs_start = rhs.StartPinIdx;\n        int rhs_end = rhs.EndPinIdx;\n\n        if (lhs_start > lhs_end)\n        {\n            ImSwap(lhs_start, lhs_end);\n        }\n\n        if (rhs_start > rhs_end)\n        {\n            ImSwap(rhs_start, rhs_end);\n        }\n\n        return lhs_start == rhs_start && lhs_end == rhs_end;\n    }\n};\n\nImOptionalIndex FindDuplicateLink(\n    const ImNodesEditorContext& editor,\n    const int                   start_pin_idx,\n    const int                   end_pin_idx)\n{\n    ImLinkData test_link(0);\n    test_link.StartPinIdx = start_pin_idx;\n    test_link.EndPinIdx = end_pin_idx;\n    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)\n    {\n        const ImLinkData& link = editor.Links.Pool[link_idx];\n        if (LinkPredicate()(test_link, link) && editor.Links.InUse[link_idx])\n        {\n            return ImOptionalIndex(link_idx);\n        }\n    }\n\n    return ImOptionalIndex();\n}\n\nbool ShouldLinkSnapToPin(\n    const ImNodesEditorContext& editor,\n    const ImPinData&            start_pin,\n    const int                   hovered_pin_idx,\n    const ImOptionalIndex       duplicate_link)\n{\n    const ImPinData& end_pin = editor.Pins.Pool[hovered_pin_idx];\n\n    // The end pin must be in a different node\n    if (start_pin.ParentNodeIdx == end_pin.ParentNodeIdx)\n    {\n        return false;\n    }\n\n    // The end pin must be of a different type\n    if (start_pin.Type == end_pin.Type)\n    {\n        return false;\n    }\n\n    // The link to be created must not be a duplicate, unless it is the link which was created on\n    // snap. In that case we want to snap, since we want it to appear visually as if the created\n    // link remains snapped to the pin.\n    if (duplicate_link.HasValue() && !(duplicate_link == GImNodes->SnapLinkIdx))\n    {\n        return false;\n    }\n\n    return true;\n}\n\nvoid ClickInteractionUpdate(ImNodesEditorContext& editor)\n{\n    switch (editor.ClickInteraction.Type)\n    {\n    case ImNodesClickInteractionType_BoxSelection:\n    {\n        editor.ClickInteraction.BoxSelector.Rect.Max =\n            ScreenSpaceToGridSpace(editor, GImNodes->MousePos);\n\n        ImRect box_rect = editor.ClickInteraction.BoxSelector.Rect;\n        box_rect.Min = GridSpaceToScreenSpace(editor, box_rect.Min);\n        box_rect.Max = GridSpaceToScreenSpace(editor, box_rect.Max);\n\n        BoxSelectorUpdateSelection(editor, box_rect);\n\n        const ImU32 box_selector_color = GImNodes->Style.Colors[ImNodesCol_BoxSelector];\n        const ImU32 box_selector_outline = GImNodes->Style.Colors[ImNodesCol_BoxSelectorOutline];\n        GImNodes->CanvasDrawList->AddRectFilled(box_rect.Min, box_rect.Max, box_selector_color);\n        GImNodes->CanvasDrawList->AddRect(box_rect.Min, box_rect.Max, box_selector_outline);\n\n        if (GImNodes->LeftMouseReleased)\n        {\n            ImVector<int>&       depth_stack = editor.NodeDepthOrder;\n            const ImVector<int>& selected_idxs = editor.SelectedNodeIndices;\n\n            // Bump the selected node indices, in order, to the top of the depth stack.\n            // NOTE: this algorithm has worst case time complexity of O(N^2), if the node selection\n            // is ~ N (due to selected_idxs.contains()).\n\n            if ((selected_idxs.Size > 0) && (selected_idxs.Size < depth_stack.Size))\n            {\n                int num_moved = 0; // The number of indices moved. Stop after selected_idxs.Size\n                for (int i = 0; i < depth_stack.Size - selected_idxs.Size; ++i)\n                {\n                    for (int node_idx = depth_stack[i]; selected_idxs.contains(node_idx);\n                         node_idx = depth_stack[i])\n                    {\n                        depth_stack.erase(depth_stack.begin() + static_cast<size_t>(i));\n                        depth_stack.push_back(node_idx);\n                        ++num_moved;\n                    }\n\n                    if (num_moved == selected_idxs.Size)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n        }\n    }\n    break;\n    case ImNodesClickInteractionType_Node:\n    {\n        TranslateSelectedNodes(editor);\n\n        if (GImNodes->LeftMouseReleased)\n        {\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n        }\n    }\n    break;\n    case ImNodesClickInteractionType_Link:\n    {\n        if (GImNodes->LeftMouseReleased)\n        {\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n        }\n    }\n    break;\n    case ImNodesClickInteractionType_LinkCreation:\n    {\n        const ImPinData& start_pin =\n            editor.Pins.Pool[editor.ClickInteraction.LinkCreation.StartPinIdx];\n\n        const ImOptionalIndex maybe_duplicate_link_idx =\n            GImNodes->HoveredPinIdx.HasValue()\n                ? FindDuplicateLink(\n                      editor,\n                      editor.ClickInteraction.LinkCreation.StartPinIdx,\n                      GImNodes->HoveredPinIdx.Value())\n                : ImOptionalIndex();\n\n        const bool should_snap =\n            GImNodes->HoveredPinIdx.HasValue() &&\n            ShouldLinkSnapToPin(\n                editor, start_pin, GImNodes->HoveredPinIdx.Value(), maybe_duplicate_link_idx);\n\n        // If we created on snap and the hovered pin is empty or changed, then we need signal that\n        // the link's state has changed.\n        const bool snapping_pin_changed =\n            editor.ClickInteraction.LinkCreation.EndPinIdx.HasValue() &&\n            !(GImNodes->HoveredPinIdx == editor.ClickInteraction.LinkCreation.EndPinIdx);\n\n        // Detach the link that was created by this link event if it's no longer in snap range\n        if (snapping_pin_changed && GImNodes->SnapLinkIdx.HasValue())\n        {\n            BeginLinkDetach(\n                editor,\n                GImNodes->SnapLinkIdx.Value(),\n                editor.ClickInteraction.LinkCreation.EndPinIdx.Value());\n        }\n\n        const ImVec2 start_pos = GetScreenSpacePinCoordinates(editor, start_pin);\n        // If we are within the hover radius of a receiving pin, snap the link\n        // endpoint to it\n        const ImVec2 end_pos = should_snap\n                                   ? GetScreenSpacePinCoordinates(\n                                         editor, editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()])\n                                   : GImNodes->MousePos;\n\n        const CubicBezier cubic_bezier = GetCubicBezier(\n            start_pos, end_pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);\n#if IMGUI_VERSION_NUM < 18000\n        GImNodes->CanvasDrawList->AddBezierCurve(\n#else\n        GImNodes->CanvasDrawList->AddBezierCubic(\n#endif\n            cubic_bezier.P0,\n            cubic_bezier.P1,\n            cubic_bezier.P2,\n            cubic_bezier.P3,\n            GImNodes->Style.Colors[ImNodesCol_Link],\n            GImNodes->Style.LinkThickness,\n            cubic_bezier.NumSegments);\n\n        const bool link_creation_on_snap =\n            GImNodes->HoveredPinIdx.HasValue() &&\n            (editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Flags &\n             ImNodesAttributeFlags_EnableLinkCreationOnSnap);\n\n        if (!should_snap)\n        {\n            editor.ClickInteraction.LinkCreation.EndPinIdx.Reset();\n        }\n\n        const bool create_link =\n            should_snap && (GImNodes->LeftMouseReleased || link_creation_on_snap);\n\n        if (create_link && !maybe_duplicate_link_idx.HasValue())\n        {\n            // Avoid send OnLinkCreated() events every frame if the snap link is not saved\n            // (only applies for EnableLinkCreationOnSnap)\n            if (!GImNodes->LeftMouseReleased &&\n                editor.ClickInteraction.LinkCreation.EndPinIdx == GImNodes->HoveredPinIdx)\n            {\n                break;\n            }\n\n            GImNodes->ImNodesUIState |= ImNodesUIState_LinkCreated;\n            editor.ClickInteraction.LinkCreation.EndPinIdx = GImNodes->HoveredPinIdx.Value();\n        }\n\n        if (GImNodes->LeftMouseReleased)\n        {\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n            if (!create_link)\n            {\n                GImNodes->ImNodesUIState |= ImNodesUIState_LinkDropped;\n            }\n        }\n    }\n    break;\n    case ImNodesClickInteractionType_Panning:\n    {\n        const bool dragging = GImNodes->AltMouseDragging;\n\n        if (dragging)\n        {\n            editor.Panning += ImGui::GetIO().MouseDelta;\n        }\n        else\n        {\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n        }\n    }\n    break;\n    case ImNodesClickInteractionType_ImGuiItem:\n    {\n        if (GImNodes->LeftMouseReleased)\n        {\n            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;\n        }\n    }\n    case ImNodesClickInteractionType_None:\n        break;\n    default:\n        IM_ASSERT(!\"Unreachable code!\");\n        break;\n    }\n}\n\nvoid ResolveOccludedPins(const ImNodesEditorContext& editor, ImVector<int>& occluded_pin_indices)\n{\n    const ImVector<int>& depth_stack = editor.NodeDepthOrder;\n\n    occluded_pin_indices.resize(0);\n\n    if (depth_stack.Size < 2)\n    {\n        return;\n    }\n\n    // For each node in the depth stack\n    for (int depth_idx = 0; depth_idx < (depth_stack.Size - 1); ++depth_idx)\n    {\n        const ImNodeData& node_below = editor.Nodes.Pool[depth_stack[depth_idx]];\n\n        // Iterate over the rest of the depth stack to find nodes overlapping the pins\n        for (int next_depth_idx = depth_idx + 1; next_depth_idx < depth_stack.Size;\n             ++next_depth_idx)\n        {\n            const ImRect& rect_above = editor.Nodes.Pool[depth_stack[next_depth_idx]].Rect;\n\n            // Iterate over each pin\n            for (int idx = 0; idx < node_below.PinIndices.Size; ++idx)\n            {\n                const int     pin_idx = node_below.PinIndices[idx];\n                const ImVec2& pin_pos = editor.Pins.Pool[pin_idx].Pos;\n\n                if (rect_above.Contains(pin_pos))\n                {\n                    occluded_pin_indices.push_back(pin_idx);\n                }\n            }\n        }\n    }\n}\n\nImOptionalIndex ResolveHoveredPin(\n    const ImObjectPool<ImPinData>& pins,\n    const ImVector<int>&           occluded_pin_indices)\n{\n    float           smallest_distance = FLT_MAX;\n    ImOptionalIndex pin_idx_with_smallest_distance;\n\n    const float hover_radius_sqr = GImNodes->Style.PinHoverRadius * GImNodes->Style.PinHoverRadius;\n\n    for (int idx = 0; idx < pins.Pool.Size; ++idx)\n    {\n        if (!pins.InUse[idx])\n        {\n            continue;\n        }\n\n        if (occluded_pin_indices.contains(idx))\n        {\n            continue;\n        }\n\n        const ImVec2& pin_pos = pins.Pool[idx].Pos;\n        const float   distance_sqr = ImLengthSqr(pin_pos - GImNodes->MousePos);\n\n        // TODO: GImNodes->Style.PinHoverRadius needs to be copied into pin data and the pin-local\n        // value used here. This is no longer called in BeginAttribute/EndAttribute scope and the\n        // detected pin might have a different hover radius than what the user had when calling\n        // BeginAttribute/EndAttribute.\n        if (distance_sqr < hover_radius_sqr && distance_sqr < smallest_distance)\n        {\n            smallest_distance = distance_sqr;\n            pin_idx_with_smallest_distance = idx;\n        }\n    }\n\n    return pin_idx_with_smallest_distance;\n}\n\nImOptionalIndex ResolveHoveredNode(const ImVector<int>& depth_stack)\n{\n    if (GImNodes->NodeIndicesOverlappingWithMouse.size() == 0)\n    {\n        return ImOptionalIndex();\n    }\n\n    if (GImNodes->NodeIndicesOverlappingWithMouse.size() == 1)\n    {\n        return ImOptionalIndex(GImNodes->NodeIndicesOverlappingWithMouse[0]);\n    }\n\n    int largest_depth_idx = -1;\n    int node_idx_on_top = -1;\n\n    for (int i = 0; i < GImNodes->NodeIndicesOverlappingWithMouse.size(); ++i)\n    {\n        const int node_idx = GImNodes->NodeIndicesOverlappingWithMouse[i];\n        for (int depth_idx = 0; depth_idx < depth_stack.size(); ++depth_idx)\n        {\n            if (depth_stack[depth_idx] == node_idx && (depth_idx > largest_depth_idx))\n            {\n                largest_depth_idx = depth_idx;\n                node_idx_on_top = node_idx;\n            }\n        }\n    }\n\n    IM_ASSERT(node_idx_on_top != -1);\n    return ImOptionalIndex(node_idx_on_top);\n}\n\nImOptionalIndex ResolveHoveredLink(\n    const ImObjectPool<ImLinkData>& links,\n    const ImObjectPool<ImPinData>&  pins)\n{\n    float           smallest_distance = FLT_MAX;\n    ImOptionalIndex link_idx_with_smallest_distance;\n\n    // There are two ways a link can be detected as \"hovered\".\n    // 1. The link is within hover distance to the mouse. The closest such link is selected as being\n    // hovered over.\n    // 2. If the link is connected to the currently hovered pin.\n    //\n    // The latter is a requirement for link detaching with drag click to work, as both a link and\n    // pin are required to be hovered over for the feature to work.\n\n    for (int idx = 0; idx < links.Pool.Size; ++idx)\n    {\n        if (!links.InUse[idx])\n        {\n            continue;\n        }\n\n        const ImLinkData& link = links.Pool[idx];\n        const ImPinData&  start_pin = pins.Pool[link.StartPinIdx];\n        const ImPinData&  end_pin = pins.Pool[link.EndPinIdx];\n\n        // If there is a hovered pin links can only be considered hovered if they use that pin\n        if (GImNodes->HoveredPinIdx.HasValue())\n        {\n            if (GImNodes->HoveredPinIdx == link.StartPinIdx ||\n                GImNodes->HoveredPinIdx == link.EndPinIdx)\n            {\n                return idx;\n            }\n            continue;\n        }\n\n        // TODO: the calculated CubicBeziers could be cached since we generate them again when\n        // rendering the links\n\n        const CubicBezier cubic_bezier = GetCubicBezier(\n            start_pin.Pos, end_pin.Pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);\n\n        // The distance test\n        {\n            const ImRect link_rect = GetContainingRectForCubicBezier(cubic_bezier);\n\n            // First, do a simple bounding box test against the box containing the link\n            // to see whether calculating the distance to the link is worth doing.\n            if (link_rect.Contains(GImNodes->MousePos))\n            {\n                const float distance = GetDistanceToCubicBezier(\n                    GImNodes->MousePos, cubic_bezier, cubic_bezier.NumSegments);\n\n                // TODO: GImNodes->Style.LinkHoverDistance could be also copied into ImLinkData,\n                // since we're not calling this function in the same scope as ImNodes::Link(). The\n                // rendered/detected link might have a different hover distance than what the user\n                // had specified when calling Link()\n                if (distance < GImNodes->Style.LinkHoverDistance && distance < smallest_distance)\n                {\n                    smallest_distance = distance;\n                    link_idx_with_smallest_distance = idx;\n                }\n            }\n        }\n    }\n\n    return link_idx_with_smallest_distance;\n}\n\n// [SECTION] render helpers\n\ninline ImRect GetItemRect() { return ImRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax()); }\n\ninline ImVec2 GetNodeTitleBarOrigin(const ImNodeData& node)\n{\n    return node.Origin + node.LayoutStyle.Padding;\n}\n\ninline ImVec2 GetNodeContentOrigin(const ImNodeData& node)\n{\n    const ImVec2 title_bar_height =\n        ImVec2(0.f, node.TitleBarContentRect.GetHeight() + 2.0f * node.LayoutStyle.Padding.y);\n    return node.Origin + title_bar_height + node.LayoutStyle.Padding;\n}\n\ninline ImRect GetNodeTitleRect(const ImNodeData& node)\n{\n    ImRect expanded_title_rect = node.TitleBarContentRect;\n    expanded_title_rect.Expand(node.LayoutStyle.Padding);\n\n    return ImRect(\n        expanded_title_rect.Min,\n        expanded_title_rect.Min + ImVec2(node.Rect.GetWidth(), 0.f) +\n            ImVec2(0.f, expanded_title_rect.GetHeight()));\n}\n\nvoid DrawGrid(ImNodesEditorContext& editor, const ImVec2& canvas_size)\n{\n    const ImVec2 offset = editor.Panning;\n    ImU32        line_color = GImNodes->Style.Colors[ImNodesCol_GridLine];\n    ImU32        line_color_prim = GImNodes->Style.Colors[ImNodesCol_GridLinePrimary];\n    bool         draw_primary = GImNodes->Style.Flags & ImNodesStyleFlags_GridLinesPrimary;\n\n    for (float x = fmodf(offset.x, GImNodes->Style.GridSpacing); x < canvas_size.x;\n         x += GImNodes->Style.GridSpacing)\n    {\n        GImNodes->CanvasDrawList->AddLine(\n            EditorSpaceToScreenSpace(ImVec2(x, 0.0f)),\n            EditorSpaceToScreenSpace(ImVec2(x, canvas_size.y)),\n            offset.x - x == 0.f && draw_primary ? line_color_prim : line_color);\n    }\n\n    for (float y = fmodf(offset.y, GImNodes->Style.GridSpacing); y < canvas_size.y;\n         y += GImNodes->Style.GridSpacing)\n    {\n        GImNodes->CanvasDrawList->AddLine(\n            EditorSpaceToScreenSpace(ImVec2(0.0f, y)),\n            EditorSpaceToScreenSpace(ImVec2(canvas_size.x, y)),\n            offset.y - y == 0.f && draw_primary ? line_color_prim : line_color);\n    }\n}\n\nstruct QuadOffsets\n{\n    ImVec2 TopLeft, BottomLeft, BottomRight, TopRight;\n};\n\nQuadOffsets CalculateQuadOffsets(const float side_length)\n{\n    const float half_side = 0.5f * side_length;\n\n    QuadOffsets offset;\n\n    offset.TopLeft = ImVec2(-half_side, half_side);\n    offset.BottomLeft = ImVec2(-half_side, -half_side);\n    offset.BottomRight = ImVec2(half_side, -half_side);\n    offset.TopRight = ImVec2(half_side, half_side);\n\n    return offset;\n}\n\nstruct TriangleOffsets\n{\n    ImVec2 TopLeft, BottomLeft, Right;\n};\n\nTriangleOffsets CalculateTriangleOffsets(const float side_length)\n{\n    // Calculates the Vec2 offsets from an equilateral triangle's midpoint to\n    // its vertices. Here is how the left_offset and right_offset are\n    // calculated.\n    //\n    // For an equilateral triangle of side length s, the\n    // triangle's height, h, is h = s * sqrt(3) / 2.\n    //\n    // The length from the base to the midpoint is (1 / 3) * h. The length from\n    // the midpoint to the triangle vertex is (2 / 3) * h.\n    const float sqrt_3 = sqrtf(3.0f);\n    const float left_offset = -0.1666666666667f * sqrt_3 * side_length;\n    const float right_offset = 0.333333333333f * sqrt_3 * side_length;\n    const float vertical_offset = 0.5f * side_length;\n\n    TriangleOffsets offset;\n    offset.TopLeft = ImVec2(left_offset, vertical_offset);\n    offset.BottomLeft = ImVec2(left_offset, -vertical_offset);\n    offset.Right = ImVec2(right_offset, 0.f);\n\n    return offset;\n}\n\nvoid DrawPinShape(const ImVec2& pin_pos, const ImPinData& pin, const ImU32 pin_color)\n{\n    static const int CIRCLE_NUM_SEGMENTS = 8;\n\n    switch (pin.Shape)\n    {\n    case ImNodesPinShape_Circle:\n    {\n        GImNodes->CanvasDrawList->AddCircle(\n            pin_pos,\n            GImNodes->Style.PinCircleRadius,\n            pin_color,\n            CIRCLE_NUM_SEGMENTS,\n            GImNodes->Style.PinLineThickness);\n    }\n    break;\n    case ImNodesPinShape_CircleFilled:\n    {\n        GImNodes->CanvasDrawList->AddCircleFilled(\n            pin_pos, GImNodes->Style.PinCircleRadius, pin_color, CIRCLE_NUM_SEGMENTS);\n    }\n    break;\n    case ImNodesPinShape_Quad:\n    {\n        const QuadOffsets offset = CalculateQuadOffsets(GImNodes->Style.PinQuadSideLength);\n        GImNodes->CanvasDrawList->AddQuad(\n            pin_pos + offset.TopLeft,\n            pin_pos + offset.BottomLeft,\n            pin_pos + offset.BottomRight,\n            pin_pos + offset.TopRight,\n            pin_color,\n            GImNodes->Style.PinLineThickness);\n    }\n    break;\n    case ImNodesPinShape_QuadFilled:\n    {\n        const QuadOffsets offset = CalculateQuadOffsets(GImNodes->Style.PinQuadSideLength);\n        GImNodes->CanvasDrawList->AddQuadFilled(\n            pin_pos + offset.TopLeft,\n            pin_pos + offset.BottomLeft,\n            pin_pos + offset.BottomRight,\n            pin_pos + offset.TopRight,\n            pin_color);\n    }\n    break;\n    case ImNodesPinShape_Triangle:\n    {\n        const TriangleOffsets offset =\n            CalculateTriangleOffsets(GImNodes->Style.PinTriangleSideLength);\n        GImNodes->CanvasDrawList->AddTriangle(\n            pin_pos + offset.TopLeft,\n            pin_pos + offset.BottomLeft,\n            pin_pos + offset.Right,\n            pin_color,\n            // NOTE: for some weird reason, the line drawn by AddTriangle is\n            // much thinner than the lines drawn by AddCircle or AddQuad.\n            // Multiplying the line thickness by two seemed to solve the\n            // problem at a few different thickness values.\n            2.f * GImNodes->Style.PinLineThickness);\n    }\n    break;\n    case ImNodesPinShape_TriangleFilled:\n    {\n        const TriangleOffsets offset =\n            CalculateTriangleOffsets(GImNodes->Style.PinTriangleSideLength);\n        GImNodes->CanvasDrawList->AddTriangleFilled(\n            pin_pos + offset.TopLeft,\n            pin_pos + offset.BottomLeft,\n            pin_pos + offset.Right,\n            pin_color);\n    }\n    break;\n    default:\n        IM_ASSERT(!\"Invalid PinShape value!\");\n        break;\n    }\n}\n\nvoid DrawPin(ImNodesEditorContext& editor, const int pin_idx)\n{\n    ImPinData&    pin = editor.Pins.Pool[pin_idx];\n    const ImRect& parent_node_rect = editor.Nodes.Pool[pin.ParentNodeIdx].Rect;\n\n    pin.Pos = GetScreenSpacePinCoordinates(parent_node_rect, pin.AttributeRect, pin.Type);\n\n    ImU32 pin_color = pin.ColorStyle.Background;\n\n    if (GImNodes->HoveredPinIdx == pin_idx)\n    {\n        pin_color = pin.ColorStyle.Hovered;\n    }\n\n    DrawPinShape(pin.Pos, pin, pin_color);\n}\n\nvoid DrawNode(ImNodesEditorContext& editor, const int node_idx)\n{\n    const ImNodeData& node = editor.Nodes.Pool[node_idx];\n    ImGui::SetCursorPos(node.Origin + editor.Panning);\n\n    const bool node_hovered =\n        GImNodes->HoveredNodeIdx == node_idx &&\n        editor.ClickInteraction.Type != ImNodesClickInteractionType_BoxSelection;\n\n    ImU32 node_background = node.ColorStyle.Background;\n    ImU32 titlebar_background = node.ColorStyle.Titlebar;\n\n    if (editor.SelectedNodeIndices.contains(node_idx))\n    {\n        node_background = node.ColorStyle.BackgroundSelected;\n        titlebar_background = node.ColorStyle.TitlebarSelected;\n    }\n    else if (node_hovered)\n    {\n        node_background = node.ColorStyle.BackgroundHovered;\n        titlebar_background = node.ColorStyle.TitlebarHovered;\n    }\n\n    {\n        // node base\n        GImNodes->CanvasDrawList->AddRectFilled(\n            node.Rect.Min, node.Rect.Max, node_background, node.LayoutStyle.CornerRounding);\n\n        // title bar:\n        if (node.TitleBarContentRect.GetHeight() > 0.f)\n        {\n            ImRect title_bar_rect = GetNodeTitleRect(node);\n\n#if IMGUI_VERSION_NUM < 18200\n            GImNodes->CanvasDrawList->AddRectFilled(\n                title_bar_rect.Min,\n                title_bar_rect.Max,\n                titlebar_background,\n                node.LayoutStyle.CornerRounding,\n                ImDrawCornerFlags_Top);\n#else\n            GImNodes->CanvasDrawList->AddRectFilled(\n                title_bar_rect.Min,\n                title_bar_rect.Max,\n                titlebar_background,\n                node.LayoutStyle.CornerRounding,\n                ImDrawFlags_RoundCornersTop);\n\n#endif\n        }\n\n        if ((GImNodes->Style.Flags & ImNodesStyleFlags_NodeOutline) != 0)\n        {\n#if IMGUI_VERSION_NUM < 18200\n            GImNodes->CanvasDrawList->AddRect(\n                node.Rect.Min,\n                node.Rect.Max,\n                node.ColorStyle.Outline,\n                node.LayoutStyle.CornerRounding,\n                ImDrawCornerFlags_All,\n                node.LayoutStyle.BorderThickness);\n#else\n            GImNodes->CanvasDrawList->AddRect(\n                node.Rect.Min,\n                node.Rect.Max,\n                node.ColorStyle.Outline,\n                node.LayoutStyle.CornerRounding,\n                ImDrawFlags_RoundCornersAll,\n                node.LayoutStyle.BorderThickness);\n#endif\n        }\n    }\n\n    for (int i = 0; i < node.PinIndices.size(); ++i)\n    {\n        DrawPin(editor, node.PinIndices[i]);\n    }\n\n    if (node_hovered)\n    {\n        GImNodes->HoveredNodeIdx = node_idx;\n    }\n}\n\nvoid DrawLink(ImNodesEditorContext& editor, const int link_idx)\n{\n    const ImLinkData& link = editor.Links.Pool[link_idx];\n    const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];\n    const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];\n\n    const CubicBezier cubic_bezier = GetCubicBezier(\n        start_pin.Pos, end_pin.Pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);\n\n    const bool link_hovered =\n        GImNodes->HoveredLinkIdx == link_idx &&\n        editor.ClickInteraction.Type != ImNodesClickInteractionType_BoxSelection;\n\n    if (link_hovered)\n    {\n        GImNodes->HoveredLinkIdx = link_idx;\n    }\n\n    // It's possible for a link to be deleted in begin_link_interaction. A user\n    // may detach a link, resulting in the link wire snapping to the mouse\n    // position.\n    //\n    // In other words, skip rendering the link if it was deleted.\n    if (GImNodes->DeletedLinkIdx == link_idx)\n    {\n        return;\n    }\n\n    ImU32 link_color = link.ColorStyle.Base;\n    if (editor.SelectedLinkIndices.contains(link_idx))\n    {\n        link_color = link.ColorStyle.Selected;\n    }\n    else if (link_hovered)\n    {\n        link_color = link.ColorStyle.Hovered;\n    }\n\n#if IMGUI_VERSION_NUM < 18000\n    GImNodes->CanvasDrawList->AddBezierCurve(\n#else\n    GImNodes->CanvasDrawList->AddBezierCubic(\n#endif\n        cubic_bezier.P0,\n        cubic_bezier.P1,\n        cubic_bezier.P2,\n        cubic_bezier.P3,\n        link_color,\n        GImNodes->Style.LinkThickness,\n        cubic_bezier.NumSegments);\n}\n\nvoid BeginPinAttribute(\n    const int                  id,\n    const ImNodesAttributeType type,\n    const ImNodesPinShape      shape,\n    const int                  node_idx)\n{\n    // Make sure to call BeginNode() before calling\n    // BeginAttribute()\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);\n    GImNodes->CurrentScope = ImNodesScope_Attribute;\n\n    ImGui::BeginGroup();\n    ImGui::PushID(id);\n\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    GImNodes->CurrentAttributeId = id;\n\n    const int pin_idx = ObjectPoolFindOrCreateIndex(editor.Pins, id);\n    GImNodes->CurrentPinIdx = pin_idx;\n    ImPinData& pin = editor.Pins.Pool[pin_idx];\n    pin.Id = id;\n    pin.ParentNodeIdx = node_idx;\n    pin.Type = type;\n    pin.Shape = shape;\n    pin.Flags = GImNodes->CurrentAttributeFlags;\n    pin.ColorStyle.Background = GImNodes->Style.Colors[ImNodesCol_Pin];\n    pin.ColorStyle.Hovered = GImNodes->Style.Colors[ImNodesCol_PinHovered];\n}\n\nvoid EndPinAttribute()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Attribute);\n    GImNodes->CurrentScope = ImNodesScope_Node;\n\n    ImGui::PopID();\n    ImGui::EndGroup();\n\n    if (ImGui::IsItemActive())\n    {\n        GImNodes->ActiveAttribute = true;\n        GImNodes->ActiveAttributeId = GImNodes->CurrentAttributeId;\n    }\n\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImPinData&            pin = editor.Pins.Pool[GImNodes->CurrentPinIdx];\n    ImNodeData&           node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];\n    pin.AttributeRect = GetItemRect();\n    node.PinIndices.push_back(GImNodes->CurrentPinIdx);\n}\n\nvoid Initialize(ImNodesContext* context)\n{\n    context->CanvasOriginScreenSpace = ImVec2(0.0f, 0.0f);\n    context->CanvasRectScreenSpace = ImRect(ImVec2(0.f, 0.f), ImVec2(0.f, 0.f));\n    context->CurrentScope = ImNodesScope_None;\n\n    context->CurrentPinIdx = INT_MAX;\n    context->CurrentNodeIdx = INT_MAX;\n\n    context->DefaultEditorCtx = EditorContextCreate();\n    context->EditorCtx = context->DefaultEditorCtx;\n\n    context->CurrentAttributeFlags = ImNodesAttributeFlags_None;\n    context->AttributeFlagStack.push_back(GImNodes->CurrentAttributeFlags);\n\n    StyleColorsDark(&context->Style);\n}\n\nvoid Shutdown(ImNodesContext* ctx) { EditorContextFree(ctx->DefaultEditorCtx); }\n\n// [SECTION] minimap\n\nstatic inline bool IsMiniMapActive()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    return editor.MiniMapEnabled && editor.MiniMapSizeFraction > 0.0f;\n}\n\nstatic inline bool IsMiniMapHovered()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    return IsMiniMapActive() &&\n           ImGui::IsMouseHoveringRect(\n               editor.MiniMapRectScreenSpace.Min, editor.MiniMapRectScreenSpace.Max);\n}\n\nstatic inline void CalcMiniMapLayout()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    const ImVec2          offset = GImNodes->Style.MiniMapOffset;\n    const ImVec2          border = GImNodes->Style.MiniMapPadding;\n    const ImRect          editor_rect = GImNodes->CanvasRectScreenSpace;\n\n    // Compute the size of the mini-map area\n    ImVec2 mini_map_size;\n    float  mini_map_scaling;\n    {\n        const ImVec2 max_size =\n            ImFloor(editor_rect.GetSize() * editor.MiniMapSizeFraction - border * 2.0f);\n        const float  max_size_aspect_ratio = max_size.x / max_size.y;\n        const ImVec2 grid_content_size = editor.GridContentBounds.IsInverted()\n                                             ? max_size\n                                             : ImFloor(editor.GridContentBounds.GetSize());\n        const float  grid_content_aspect_ratio = grid_content_size.x / grid_content_size.y;\n        mini_map_size = ImFloor(\n            grid_content_aspect_ratio > max_size_aspect_ratio\n                ? ImVec2(max_size.x, max_size.x / grid_content_aspect_ratio)\n                : ImVec2(max_size.y * grid_content_aspect_ratio, max_size.y));\n        mini_map_scaling = mini_map_size.x / grid_content_size.x;\n    }\n\n    // Compute location of the mini-map\n    ImVec2 mini_map_pos;\n    {\n        ImVec2 align;\n\n        switch (editor.MiniMapLocation)\n        {\n        case ImNodesMiniMapLocation_BottomRight:\n            align.x = 1.0f;\n            align.y = 1.0f;\n            break;\n        case ImNodesMiniMapLocation_BottomLeft:\n            align.x = 0.0f;\n            align.y = 1.0f;\n            break;\n        case ImNodesMiniMapLocation_TopRight:\n            align.x = 1.0f;\n            align.y = 0.0f;\n            break;\n        case ImNodesMiniMapLocation_TopLeft: // [[fallthrough]]\n        default:\n            align.x = 0.0f;\n            align.y = 0.0f;\n            break;\n        }\n\n        const ImVec2 top_left_pos = editor_rect.Min + offset + border;\n        const ImVec2 bottom_right_pos = editor_rect.Max - offset - border - mini_map_size;\n        mini_map_pos = ImFloor(ImLerp(top_left_pos, bottom_right_pos, align));\n    }\n\n    editor.MiniMapRectScreenSpace =\n        ImRect(mini_map_pos - border, mini_map_pos + mini_map_size + border);\n    editor.MiniMapContentScreenSpace = ImRect(mini_map_pos, mini_map_pos + mini_map_size);\n    editor.MiniMapScaling = mini_map_scaling;\n}\n\nstatic void MiniMapDrawNode(ImNodesEditorContext& editor, const int node_idx)\n{\n    const ImNodeData& node = editor.Nodes.Pool[node_idx];\n\n    const ImRect node_rect = ScreenSpaceToMiniMapSpace(editor, node.Rect);\n\n    // Round to near whole pixel value for corner-rounding to prevent visual glitches\n    const float mini_map_node_rounding =\n        floorf(node.LayoutStyle.CornerRounding * editor.MiniMapScaling);\n\n    ImU32 mini_map_node_background;\n\n    if (editor.ClickInteraction.Type == ImNodesClickInteractionType_None &&\n        ImGui::IsMouseHoveringRect(node_rect.Min, node_rect.Max))\n    {\n        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered];\n\n        // Run user callback when hovering a mini-map node\n        if (editor.MiniMapNodeHoveringCallback)\n        {\n            editor.MiniMapNodeHoveringCallback(node.Id, editor.MiniMapNodeHoveringCallbackUserData);\n        }\n    }\n    else if (editor.SelectedNodeIndices.contains(node_idx))\n    {\n        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundSelected];\n    }\n    else\n    {\n        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackground];\n    }\n\n    const ImU32 mini_map_node_outline = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeOutline];\n\n    GImNodes->CanvasDrawList->AddRectFilled(\n        node_rect.Min, node_rect.Max, mini_map_node_background, mini_map_node_rounding);\n\n    GImNodes->CanvasDrawList->AddRect(\n        node_rect.Min, node_rect.Max, mini_map_node_outline, mini_map_node_rounding);\n}\n\nstatic void MiniMapDrawLink(ImNodesEditorContext& editor, const int link_idx)\n{\n    const ImLinkData& link = editor.Links.Pool[link_idx];\n    const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];\n    const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];\n\n    const CubicBezier cubic_bezier = GetCubicBezier(\n        ScreenSpaceToMiniMapSpace(editor, start_pin.Pos),\n        ScreenSpaceToMiniMapSpace(editor, end_pin.Pos),\n        start_pin.Type,\n        GImNodes->Style.LinkLineSegmentsPerLength / editor.MiniMapScaling);\n\n    // It's possible for a link to be deleted in begin_link_interaction. A user\n    // may detach a link, resulting in the link wire snapping to the mouse\n    // position.\n    //\n    // In other words, skip rendering the link if it was deleted.\n    if (GImNodes->DeletedLinkIdx == link_idx)\n    {\n        return;\n    }\n\n    const ImU32 link_color =\n        GImNodes->Style.Colors\n            [editor.SelectedLinkIndices.contains(link_idx) ? ImNodesCol_MiniMapLinkSelected\n                                                           : ImNodesCol_MiniMapLink];\n\n#if IMGUI_VERSION_NUM < 18000\n    GImNodes->CanvasDrawList->AddBezierCurve(\n#else\n    GImNodes->CanvasDrawList->AddBezierCubic(\n#endif\n        cubic_bezier.P0,\n        cubic_bezier.P1,\n        cubic_bezier.P2,\n        cubic_bezier.P3,\n        link_color,\n        GImNodes->Style.LinkThickness * editor.MiniMapScaling,\n        cubic_bezier.NumSegments);\n}\n\nstatic void MiniMapUpdate()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    ImU32 mini_map_background;\n\n    if (IsMiniMapHovered())\n    {\n        mini_map_background = GImNodes->Style.Colors[ImNodesCol_MiniMapBackgroundHovered];\n    }\n    else\n    {\n        mini_map_background = GImNodes->Style.Colors[ImNodesCol_MiniMapBackground];\n    }\n\n    // Create a child window bellow mini-map, so it blocks all mouse interaction on canvas.\n    int flags = ImGuiWindowFlags_NoBackground;\n    ImGui::SetCursorScreenPos(editor.MiniMapRectScreenSpace.Min);\n    ImGui::BeginChild(\"minimap\", editor.MiniMapRectScreenSpace.GetSize(), false, flags);\n\n    const ImRect& mini_map_rect = editor.MiniMapRectScreenSpace;\n\n    // Draw minimap background and border\n    GImNodes->CanvasDrawList->AddRectFilled(\n        mini_map_rect.Min, mini_map_rect.Max, mini_map_background);\n\n    GImNodes->CanvasDrawList->AddRect(\n        mini_map_rect.Min, mini_map_rect.Max, GImNodes->Style.Colors[ImNodesCol_MiniMapOutline]);\n\n    // Clip draw list items to mini-map rect (after drawing background/outline)\n    GImNodes->CanvasDrawList->PushClipRect(\n        mini_map_rect.Min, mini_map_rect.Max, true /* intersect with editor clip-rect */);\n\n    // Draw links first so they appear under nodes, and we can use the same draw channel\n    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)\n    {\n        if (editor.Links.InUse[link_idx])\n        {\n            MiniMapDrawLink(editor, link_idx);\n        }\n    }\n\n    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)\n    {\n        if (editor.Nodes.InUse[node_idx])\n        {\n            MiniMapDrawNode(editor, node_idx);\n        }\n    }\n\n    // Draw editor canvas rect inside mini-map\n    {\n        const ImU32  canvas_color = GImNodes->Style.Colors[ImNodesCol_MiniMapCanvas];\n        const ImU32  outline_color = GImNodes->Style.Colors[ImNodesCol_MiniMapCanvasOutline];\n        const ImRect rect = ScreenSpaceToMiniMapSpace(editor, GImNodes->CanvasRectScreenSpace);\n\n        GImNodes->CanvasDrawList->AddRectFilled(rect.Min, rect.Max, canvas_color);\n        GImNodes->CanvasDrawList->AddRect(rect.Min, rect.Max, outline_color);\n    }\n\n    // Have to pop mini-map clip rect\n    GImNodes->CanvasDrawList->PopClipRect();\n\n    bool mini_map_is_hovered = ImGui::IsWindowHovered();\n\n    ImGui::EndChild();\n\n    bool center_on_click = mini_map_is_hovered && ImGui::IsMouseDown(ImGuiMouseButton_Left) &&\n                           editor.ClickInteraction.Type == ImNodesClickInteractionType_None &&\n                           !GImNodes->NodeIdxSubmissionOrder.empty();\n    if (center_on_click)\n    {\n        ImVec2 target = MiniMapSpaceToGridSpace(editor, ImGui::GetMousePos());\n        ImVec2 center = GImNodes->CanvasRectScreenSpace.GetSize() * 0.5f;\n        editor.Panning = ImFloor(center - target);\n    }\n\n    // Reset callback info after use\n    editor.MiniMapNodeHoveringCallback = NULL;\n    editor.MiniMapNodeHoveringCallbackUserData = NULL;\n}\n\n// [SECTION] selection helpers\n\ntemplate<typename T>\nvoid SelectObject(const ImObjectPool<T>& objects, ImVector<int>& selected_indices, const int id)\n{\n    const int idx = ObjectPoolFind(objects, id);\n    IM_ASSERT(idx >= 0);\n    IM_ASSERT(selected_indices.find(idx) == selected_indices.end());\n    selected_indices.push_back(idx);\n}\n\ntemplate<typename T>\nvoid ClearObjectSelection(\n    const ImObjectPool<T>& objects,\n    ImVector<int>&         selected_indices,\n    const int              id)\n{\n    const int idx = ObjectPoolFind(objects, id);\n    IM_ASSERT(idx >= 0);\n    IM_ASSERT(selected_indices.find(idx) != selected_indices.end());\n    selected_indices.find_erase_unsorted(idx);\n}\n\ntemplate<typename T>\nbool IsObjectSelected(const ImObjectPool<T>& objects, ImVector<int>& selected_indices, const int id)\n{\n    const int idx = ObjectPoolFind(objects, id);\n    return selected_indices.find(idx) != selected_indices.end();\n}\n\n} // namespace\n} // namespace IMNODES_NAMESPACE\n\n// [SECTION] API implementation\n\nImNodesIO::EmulateThreeButtonMouse::EmulateThreeButtonMouse() : Modifier(NULL) {}\n\nImNodesIO::LinkDetachWithModifierClick::LinkDetachWithModifierClick() : Modifier(NULL) {}\n\nImNodesIO::MultipleSelectModifier::MultipleSelectModifier() : Modifier(NULL) {}\n\nImNodesIO::ImNodesIO()\n    : EmulateThreeButtonMouse(), LinkDetachWithModifierClick(),\n      AltMouseButton(ImGuiMouseButton_Middle), AutoPanningSpeed(1000.0f)\n{\n}\n\nImNodesStyle::ImNodesStyle()\n    : GridSpacing(24.f), NodeCornerRounding(4.f), NodePadding(8.f, 8.f), NodeBorderThickness(1.f),\n      LinkThickness(3.f), LinkLineSegmentsPerLength(0.1f), LinkHoverDistance(10.f),\n      PinCircleRadius(4.f), PinQuadSideLength(7.f), PinTriangleSideLength(9.5),\n      PinLineThickness(1.f), PinHoverRadius(10.f), PinOffset(0.f), MiniMapPadding(8.0f, 8.0f),\n      MiniMapOffset(4.0f, 4.0f), Flags(ImNodesStyleFlags_NodeOutline | ImNodesStyleFlags_GridLines),\n      Colors()\n{\n}\n\nnamespace IMNODES_NAMESPACE\n{\nImNodesContext* CreateContext()\n{\n    ImNodesContext* ctx = IM_NEW(ImNodesContext)();\n    if (GImNodes == NULL)\n        SetCurrentContext(ctx);\n    Initialize(ctx);\n    return ctx;\n}\n\nvoid DestroyContext(ImNodesContext* ctx)\n{\n    if (ctx == NULL)\n        ctx = GImNodes;\n    Shutdown(ctx);\n    if (GImNodes == ctx)\n        SetCurrentContext(NULL);\n    IM_DELETE(ctx);\n}\n\nImNodesContext* GetCurrentContext() { return GImNodes; }\n\nvoid SetCurrentContext(ImNodesContext* ctx) { GImNodes = ctx; }\n\nImNodesEditorContext* EditorContextCreate()\n{\n    void* mem = ImGui::MemAlloc(sizeof(ImNodesEditorContext));\n    new (mem) ImNodesEditorContext();\n    return (ImNodesEditorContext*)mem;\n}\n\nvoid EditorContextFree(ImNodesEditorContext* ctx)\n{\n    ctx->~ImNodesEditorContext();\n    ImGui::MemFree(ctx);\n}\n\nvoid EditorContextSet(ImNodesEditorContext* ctx) { GImNodes->EditorCtx = ctx; }\n\nImVec2 EditorContextGetPanning()\n{\n    const ImNodesEditorContext& editor = EditorContextGet();\n    return editor.Panning;\n}\n\nvoid EditorContextResetPanning(const ImVec2& pos)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    editor.Panning = pos;\n}\n\nvoid EditorContextMoveToNode(const int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n\n    editor.Panning.x = -node.Origin.x;\n    editor.Panning.y = -node.Origin.y;\n}\n\nvoid SetImGuiContext(ImGuiContext* ctx) { ImGui::SetCurrentContext(ctx); }\n\nImNodesIO& GetIO() { return GImNodes->Io; }\n\nImNodesStyle& GetStyle() { return GImNodes->Style; }\n\nvoid StyleColorsDark(ImNodesStyle* dest)\n{\n    if (dest == nullptr)\n    {\n        dest = &GImNodes->Style;\n    }\n\n    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(50, 50, 50, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(75, 75, 75, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(75, 75, 75, 255);\n    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);\n    // title bar colors match ImGui's titlebg colors\n    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(41, 74, 122, 255);\n    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(66, 150, 250, 255);\n    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(66, 150, 250, 255);\n    // link colors match ImGui's slider grab colors\n    dest->Colors[ImNodesCol_Link] = IM_COL32(61, 133, 224, 200);\n    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(66, 150, 250, 255);\n    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(66, 150, 250, 255);\n    // pin colors match ImGui's button colors\n    dest->Colors[ImNodesCol_Pin] = IM_COL32(53, 150, 250, 180);\n    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(53, 150, 250, 255);\n\n    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(61, 133, 224, 30);\n    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(61, 133, 224, 150);\n\n    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(40, 40, 50, 200);\n    dest->Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 40);\n    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(240, 240, 240, 60);\n\n    // minimap colors\n    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 150);\n    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);\n    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);\n    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);\n    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered] = IM_COL32(200, 200, 200, 255);\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =\n        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];\n    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];\n    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];\n    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);\n    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);\n}\n\nvoid StyleColorsClassic(ImNodesStyle* dest)\n{\n    if (dest == nullptr)\n    {\n        dest = &GImNodes->Style;\n    }\n\n    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(50, 50, 50, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(75, 75, 75, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(75, 75, 75, 255);\n    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);\n    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(69, 69, 138, 255);\n    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(82, 82, 161, 255);\n    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(82, 82, 161, 255);\n    dest->Colors[ImNodesCol_Link] = IM_COL32(255, 255, 255, 100);\n    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(105, 99, 204, 153);\n    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(105, 99, 204, 153);\n    dest->Colors[ImNodesCol_Pin] = IM_COL32(89, 102, 156, 170);\n    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(102, 122, 179, 200);\n    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(82, 82, 161, 100);\n    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(82, 82, 161, 255);\n    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(40, 40, 50, 200);\n    dest->Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 40);\n    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(240, 240, 240, 60);\n\n    // minimap colors\n    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 100);\n    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);\n    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);\n    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);\n    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =\n        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = IM_COL32(200, 200, 240, 255);\n    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];\n    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];\n    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);\n    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);\n}\n\nvoid StyleColorsLight(ImNodesStyle* dest)\n{\n    if (dest == nullptr)\n    {\n        dest = &GImNodes->Style;\n    }\n\n    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(240, 240, 240, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(240, 240, 240, 255);\n    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(240, 240, 240, 255);\n    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);\n    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(248, 248, 248, 255);\n    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(209, 209, 209, 255);\n    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(209, 209, 209, 255);\n    // original imgui values: 66, 150, 250\n    dest->Colors[ImNodesCol_Link] = IM_COL32(66, 150, 250, 100);\n    // original imgui values: 117, 138, 204\n    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(66, 150, 250, 242);\n    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(66, 150, 250, 242);\n    // original imgui values: 66, 150, 250\n    dest->Colors[ImNodesCol_Pin] = IM_COL32(66, 150, 250, 160);\n    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(66, 150, 250, 255);\n    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(90, 170, 250, 30);\n    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(90, 170, 250, 150);\n    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(225, 225, 225, 255);\n    dest->Colors[ImNodesCol_GridLine] = IM_COL32(180, 180, 180, 100);\n    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(120, 120, 120, 100);\n\n    // minimap colors\n    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 100);\n    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);\n    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);\n    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);\n    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =\n        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];\n    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = IM_COL32(200, 200, 240, 255);\n    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);\n    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];\n    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];\n    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);\n    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);\n}\n\nvoid BeginNodeEditor()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    GImNodes->CurrentScope = ImNodesScope_Editor;\n\n    // Reset state from previous pass\n\n    ImNodesEditorContext& editor = EditorContextGet();\n    editor.AutoPanningDelta = ImVec2(0, 0);\n    editor.GridContentBounds = ImRect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);\n    editor.MiniMapEnabled = false;\n    ObjectPoolReset(editor.Nodes);\n    ObjectPoolReset(editor.Pins);\n    ObjectPoolReset(editor.Links);\n\n    GImNodes->HoveredNodeIdx.Reset();\n    GImNodes->HoveredLinkIdx.Reset();\n    GImNodes->HoveredPinIdx.Reset();\n    GImNodes->DeletedLinkIdx.Reset();\n    GImNodes->SnapLinkIdx.Reset();\n\n    GImNodes->NodeIndicesOverlappingWithMouse.clear();\n\n    GImNodes->ImNodesUIState = ImNodesUIState_None;\n\n    GImNodes->MousePos = ImGui::GetIO().MousePos;\n    GImNodes->LeftMouseClicked = ImGui::IsMouseClicked(0);\n    GImNodes->LeftMouseReleased = ImGui::IsMouseReleased(0);\n    GImNodes->LeftMouseDragging = ImGui::IsMouseDragging(0, 0.0f);\n    GImNodes->AltMouseClicked =\n        (GImNodes->Io.EmulateThreeButtonMouse.Modifier != NULL &&\n         *GImNodes->Io.EmulateThreeButtonMouse.Modifier && GImNodes->LeftMouseClicked) ||\n        ImGui::IsMouseClicked(GImNodes->Io.AltMouseButton);\n    GImNodes->AltMouseDragging =\n        (GImNodes->Io.EmulateThreeButtonMouse.Modifier != NULL && GImNodes->LeftMouseDragging &&\n         (*GImNodes->Io.EmulateThreeButtonMouse.Modifier)) ||\n        ImGui::IsMouseDragging(GImNodes->Io.AltMouseButton, 0.0f);\n    GImNodes->AltMouseScrollDelta = ImGui::GetIO().MouseWheel;\n    GImNodes->MultipleSelectModifier =\n        (GImNodes->Io.MultipleSelectModifier.Modifier != NULL\n             ? *GImNodes->Io.MultipleSelectModifier.Modifier\n             : ImGui::GetIO().KeyCtrl);\n\n    GImNodes->ActiveAttribute = false;\n\n    ImGui::BeginGroup();\n    {\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));\n        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));\n        ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);\n        ImGui::BeginChild(\n            \"scrolling_region\",\n            ImVec2(0.f, 0.f),\n            true,\n            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoMove |\n                ImGuiWindowFlags_NoScrollWithMouse);\n        GImNodes->CanvasOriginScreenSpace = ImGui::GetCursorScreenPos();\n\n        // NOTE: we have to fetch the canvas draw list *after* we call\n        // BeginChild(), otherwise the ImGui UI elements are going to be\n        // rendered into the parent window draw list.\n        DrawListSet(ImGui::GetWindowDrawList());\n\n        {\n            const ImVec2 canvas_size = ImGui::GetWindowSize();\n            GImNodes->CanvasRectScreenSpace = ImRect(\n                EditorSpaceToScreenSpace(ImVec2(0.f, 0.f)), EditorSpaceToScreenSpace(canvas_size));\n\n            if (GImNodes->Style.Flags & ImNodesStyleFlags_GridLines)\n            {\n                DrawGrid(editor, canvas_size);\n            }\n        }\n    }\n}\n\nvoid EndNodeEditor()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);\n    GImNodes->CurrentScope = ImNodesScope_None;\n\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    bool no_grid_content = editor.GridContentBounds.IsInverted();\n    if (no_grid_content)\n    {\n        editor.GridContentBounds = ScreenSpaceToGridSpace(editor, GImNodes->CanvasRectScreenSpace);\n    }\n\n    // Detect ImGui interaction first, because it blocks interaction with the rest of the UI\n\n    if (GImNodes->LeftMouseClicked && ImGui::IsAnyItemActive())\n    {\n        editor.ClickInteraction.Type = ImNodesClickInteractionType_ImGuiItem;\n    }\n\n    // Detect which UI element is being hovered over. Detection is done in a hierarchical fashion,\n    // because a UI element being hovered excludes any other as being hovered over.\n\n    // Don't do hovering detection for nodes/links/pins when interacting with the mini-map, since\n    // its an *overlay* with its own interaction behavior and must have precedence during mouse\n    // interaction.\n\n    if ((editor.ClickInteraction.Type == ImNodesClickInteractionType_None ||\n         editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation) &&\n        MouseInCanvas() && !IsMiniMapHovered())\n    {\n        // Pins needs some special care. We need to check the depth stack to see which pins are\n        // being occluded by other nodes.\n        ResolveOccludedPins(editor, GImNodes->OccludedPinIndices);\n\n        GImNodes->HoveredPinIdx = ResolveHoveredPin(editor.Pins, GImNodes->OccludedPinIndices);\n\n        if (!GImNodes->HoveredPinIdx.HasValue())\n        {\n            // Resolve which node is actually on top and being hovered using the depth stack.\n            GImNodes->HoveredNodeIdx = ResolveHoveredNode(editor.NodeDepthOrder);\n        }\n\n        // We don't check for hovered pins here, because if we want to detach a link by clicking and\n        // dragging, we need to have both a link and pin hovered.\n        if (!GImNodes->HoveredNodeIdx.HasValue())\n        {\n            GImNodes->HoveredLinkIdx = ResolveHoveredLink(editor.Links, editor.Pins);\n        }\n    }\n\n    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)\n    {\n        if (editor.Nodes.InUse[node_idx])\n        {\n            DrawListActivateNodeBackground(node_idx);\n            DrawNode(editor, node_idx);\n        }\n    }\n\n    // In order to render the links underneath the nodes, we want to first select the bottom draw\n    // channel.\n    GImNodes->CanvasDrawList->ChannelsSetCurrent(0);\n\n    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)\n    {\n        if (editor.Links.InUse[link_idx])\n        {\n            DrawLink(editor, link_idx);\n        }\n    }\n\n    // Render the click interaction UI elements (partial links, box selector) on top of everything\n    // else.\n\n    DrawListAppendClickInteractionChannel();\n    DrawListActivateClickInteractionChannel();\n\n    if (IsMiniMapActive())\n    {\n        CalcMiniMapLayout();\n        MiniMapUpdate();\n    }\n\n    // Handle node graph interaction\n\n    if (!IsMiniMapHovered())\n    {\n        if (GImNodes->LeftMouseClicked && GImNodes->HoveredLinkIdx.HasValue())\n        {\n            BeginLinkInteraction(editor, GImNodes->HoveredLinkIdx.Value(), GImNodes->HoveredPinIdx);\n        }\n\n        else if (GImNodes->LeftMouseClicked && GImNodes->HoveredPinIdx.HasValue())\n        {\n            BeginLinkCreation(editor, GImNodes->HoveredPinIdx.Value());\n        }\n\n        else if (GImNodes->LeftMouseClicked && GImNodes->HoveredNodeIdx.HasValue())\n        {\n            BeginNodeSelection(editor, GImNodes->HoveredNodeIdx.Value());\n        }\n\n        else if (\n            GImNodes->LeftMouseClicked || GImNodes->LeftMouseReleased ||\n            GImNodes->AltMouseClicked || GImNodes->AltMouseScrollDelta != 0.f)\n        {\n            BeginCanvasInteraction(editor);\n        }\n\n        bool should_auto_pan =\n            editor.ClickInteraction.Type == ImNodesClickInteractionType_BoxSelection ||\n            editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation ||\n            editor.ClickInteraction.Type == ImNodesClickInteractionType_Node;\n        if (should_auto_pan && !MouseInCanvas())\n        {\n            ImVec2 mouse = ImGui::GetMousePos();\n            ImVec2 center = GImNodes->CanvasRectScreenSpace.GetCenter();\n            ImVec2 direction = (center - mouse);\n            direction = direction * ImInvLength(direction, 0.0);\n\n            editor.AutoPanningDelta =\n                direction * ImGui::GetIO().DeltaTime * GImNodes->Io.AutoPanningSpeed;\n            editor.Panning += editor.AutoPanningDelta;\n        }\n    }\n    ClickInteractionUpdate(editor);\n\n    // At this point, draw commands have been issued for all nodes (and pins). Update the node pool\n    // to detect unused node slots and remove those indices from the depth stack before sorting the\n    // node draw commands by depth.\n    ObjectPoolUpdate(editor.Nodes);\n    ObjectPoolUpdate(editor.Pins);\n\n    DrawListSortChannelsByDepth(editor.NodeDepthOrder);\n\n    // After the links have been rendered, the link pool can be updated as well.\n    ObjectPoolUpdate(editor.Links);\n\n    // Finally, merge the draw channels\n    GImNodes->CanvasDrawList->ChannelsMerge();\n\n    // pop style\n    ImGui::EndChild();      // end scrolling region\n    ImGui::PopStyleColor(); // pop child window background color\n    ImGui::PopStyleVar();   // pop window padding\n    ImGui::PopStyleVar();   // pop frame padding\n    ImGui::EndGroup();\n}\n\nvoid MiniMap(\n    const float                                      minimap_size_fraction,\n    const ImNodesMiniMapLocation                     location,\n    const ImNodesMiniMapNodeHoveringCallback         node_hovering_callback,\n    const ImNodesMiniMapNodeHoveringCallbackUserData node_hovering_callback_data)\n{\n    // Check that editor size fraction is sane; must be in the range (0, 1]\n    IM_ASSERT(minimap_size_fraction > 0.f && minimap_size_fraction <= 1.f);\n\n    // Remember to call before EndNodeEditor\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);\n\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    editor.MiniMapEnabled = true;\n    editor.MiniMapSizeFraction = minimap_size_fraction;\n    editor.MiniMapLocation = location;\n\n    // Set node hovering callback information\n    editor.MiniMapNodeHoveringCallback = node_hovering_callback;\n    editor.MiniMapNodeHoveringCallbackUserData = node_hovering_callback_data;\n\n    // Actual drawing/updating of the MiniMap is done in EndNodeEditor so that\n    // mini map is draw over everything and all pin/link positions are updated\n    // correctly relative to their respective nodes. Hence, we must store some of\n    // of the state for the mini map in GImNodes for the actual drawing/updating\n}\n\nvoid BeginNode(const int node_id)\n{\n    // Remember to call BeginNodeEditor before calling BeginNode\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);\n    GImNodes->CurrentScope = ImNodesScope_Node;\n\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    const int node_idx = ObjectPoolFindOrCreateIndex(editor.Nodes, node_id);\n    GImNodes->CurrentNodeIdx = node_idx;\n\n    ImNodeData& node = editor.Nodes.Pool[node_idx];\n    node.ColorStyle.Background = GImNodes->Style.Colors[ImNodesCol_NodeBackground];\n    node.ColorStyle.BackgroundHovered = GImNodes->Style.Colors[ImNodesCol_NodeBackgroundHovered];\n    node.ColorStyle.BackgroundSelected = GImNodes->Style.Colors[ImNodesCol_NodeBackgroundSelected];\n    node.ColorStyle.Outline = GImNodes->Style.Colors[ImNodesCol_NodeOutline];\n    node.ColorStyle.Titlebar = GImNodes->Style.Colors[ImNodesCol_TitleBar];\n    node.ColorStyle.TitlebarHovered = GImNodes->Style.Colors[ImNodesCol_TitleBarHovered];\n    node.ColorStyle.TitlebarSelected = GImNodes->Style.Colors[ImNodesCol_TitleBarSelected];\n    node.LayoutStyle.CornerRounding = GImNodes->Style.NodeCornerRounding;\n    node.LayoutStyle.Padding = GImNodes->Style.NodePadding;\n    node.LayoutStyle.BorderThickness = GImNodes->Style.NodeBorderThickness;\n\n    // ImGui::SetCursorPos sets the cursor position, local to the current widget\n    // (in this case, the child object started in BeginNodeEditor). Use\n    // ImGui::SetCursorScreenPos to set the screen space coordinates directly.\n    ImGui::SetCursorPos(GridSpaceToEditorSpace(editor, GetNodeTitleBarOrigin(node)));\n\n    DrawListAddNode(node_idx);\n    DrawListActivateCurrentNodeForeground();\n\n    ImGui::PushID(node.Id);\n    ImGui::BeginGroup();\n}\n\nvoid EndNode()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);\n    GImNodes->CurrentScope = ImNodesScope_Editor;\n\n    ImNodesEditorContext& editor = EditorContextGet();\n\n    // The node's rectangle depends on the ImGui UI group size.\n    ImGui::EndGroup();\n    ImGui::PopID();\n\n    ImNodeData& node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];\n    node.Rect = GetItemRect();\n    node.Rect.Expand(node.LayoutStyle.Padding);\n\n    editor.GridContentBounds.Add(node.Origin);\n    editor.GridContentBounds.Add(node.Origin + node.Rect.GetSize());\n\n    if (node.Rect.Contains(GImNodes->MousePos))\n    {\n        GImNodes->NodeIndicesOverlappingWithMouse.push_back(GImNodes->CurrentNodeIdx);\n    }\n}\n\nImVec2 GetNodeDimensions(int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);\n    IM_ASSERT(node_idx != -1); // invalid node_id\n    const ImNodeData& node = editor.Nodes.Pool[node_idx];\n    return node.Rect.GetSize();\n}\n\nvoid BeginNodeTitleBar()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);\n    ImGui::BeginGroup();\n}\n\nvoid EndNodeTitleBar()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);\n    ImGui::EndGroup();\n\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];\n    node.TitleBarContentRect = GetItemRect();\n\n    ImGui::ItemAdd(GetNodeTitleRect(node), ImGui::GetID(\"title_bar\"));\n\n    ImGui::SetCursorPos(GridSpaceToEditorSpace(editor, GetNodeContentOrigin(node)));\n}\n\nvoid BeginInputAttribute(const int id, const ImNodesPinShape shape)\n{\n    BeginPinAttribute(id, ImNodesAttributeType_Input, shape, GImNodes->CurrentNodeIdx);\n}\n\nvoid EndInputAttribute() { EndPinAttribute(); }\n\nvoid BeginOutputAttribute(const int id, const ImNodesPinShape shape)\n{\n    BeginPinAttribute(id, ImNodesAttributeType_Output, shape, GImNodes->CurrentNodeIdx);\n}\n\nvoid EndOutputAttribute() { EndPinAttribute(); }\n\nvoid BeginStaticAttribute(const int id)\n{\n    // Make sure to call BeginNode() before calling BeginAttribute()\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);\n    GImNodes->CurrentScope = ImNodesScope_Attribute;\n\n    GImNodes->CurrentAttributeId = id;\n\n    ImGui::BeginGroup();\n    ImGui::PushID(id);\n}\n\nvoid EndStaticAttribute()\n{\n    // Make sure to call BeginNode() before calling BeginAttribute()\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Attribute);\n    GImNodes->CurrentScope = ImNodesScope_Node;\n\n    ImGui::PopID();\n    ImGui::EndGroup();\n\n    if (ImGui::IsItemActive())\n    {\n        GImNodes->ActiveAttribute = true;\n        GImNodes->ActiveAttributeId = GImNodes->CurrentAttributeId;\n    }\n}\n\nvoid PushAttributeFlag(const ImNodesAttributeFlags flag)\n{\n    GImNodes->CurrentAttributeFlags |= flag;\n    GImNodes->AttributeFlagStack.push_back(GImNodes->CurrentAttributeFlags);\n}\n\nvoid PopAttributeFlag()\n{\n    // PopAttributeFlag called without a matching PushAttributeFlag!\n    // The bottom value is always the default value, pushed in Initialize().\n    IM_ASSERT(GImNodes->AttributeFlagStack.size() > 1);\n\n    GImNodes->AttributeFlagStack.pop_back();\n    GImNodes->CurrentAttributeFlags = GImNodes->AttributeFlagStack.back();\n}\n\nvoid Link(const int id, const int start_attr_id, const int end_attr_id)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);\n\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImLinkData&           link = ObjectPoolFindOrCreateObject(editor.Links, id);\n    link.Id = id;\n    link.StartPinIdx = ObjectPoolFindOrCreateIndex(editor.Pins, start_attr_id);\n    link.EndPinIdx = ObjectPoolFindOrCreateIndex(editor.Pins, end_attr_id);\n    link.ColorStyle.Base = GImNodes->Style.Colors[ImNodesCol_Link];\n    link.ColorStyle.Hovered = GImNodes->Style.Colors[ImNodesCol_LinkHovered];\n    link.ColorStyle.Selected = GImNodes->Style.Colors[ImNodesCol_LinkSelected];\n\n    // Check if this link was created by the current link event\n    if ((editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation &&\n         editor.Pins.Pool[link.EndPinIdx].Flags & ImNodesAttributeFlags_EnableLinkCreationOnSnap &&\n         editor.ClickInteraction.LinkCreation.StartPinIdx == link.StartPinIdx &&\n         editor.ClickInteraction.LinkCreation.EndPinIdx == link.EndPinIdx) ||\n        (editor.ClickInteraction.LinkCreation.StartPinIdx == link.EndPinIdx &&\n         editor.ClickInteraction.LinkCreation.EndPinIdx == link.StartPinIdx))\n    {\n        GImNodes->SnapLinkIdx = ObjectPoolFindOrCreateIndex(editor.Links, id);\n    }\n}\n\nvoid PushColorStyle(const ImNodesCol item, unsigned int color)\n{\n    GImNodes->ColorModifierStack.push_back(ImNodesColElement(GImNodes->Style.Colors[item], item));\n    GImNodes->Style.Colors[item] = color;\n}\n\nvoid PopColorStyle()\n{\n    IM_ASSERT(GImNodes->ColorModifierStack.size() > 0);\n    const ImNodesColElement elem = GImNodes->ColorModifierStack.back();\n    GImNodes->Style.Colors[elem.Item] = elem.Color;\n    GImNodes->ColorModifierStack.pop_back();\n}\n\nstruct ImNodesStyleVarInfo\n{\n    ImGuiDataType Type;\n    ImU32         Count;\n    ImU32         Offset;\n    void* GetVarPtr(ImNodesStyle* style) const { return (void*)((unsigned char*)style + Offset); }\n};\n\nstatic const ImNodesStyleVarInfo GStyleVarInfo[] = {\n    // ImNodesStyleVar_GridSpacing\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, GridSpacing)},\n    // ImNodesStyleVar_NodeCornerRounding\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, NodeCornerRounding)},\n    // ImNodesStyleVar_NodePadding\n    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, NodePadding)},\n    // ImNodesStyleVar_NodeBorderThickness\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, NodeBorderThickness)},\n    // ImNodesStyleVar_LinkThickness\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkThickness)},\n    // ImNodesStyleVar_LinkLineSegmentsPerLength\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkLineSegmentsPerLength)},\n    // ImNodesStyleVar_LinkHoverDistance\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkHoverDistance)},\n    // ImNodesStyleVar_PinCircleRadius\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinCircleRadius)},\n    // ImNodesStyleVar_PinQuadSideLength\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinQuadSideLength)},\n    // ImNodesStyleVar_PinTriangleSideLength\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinTriangleSideLength)},\n    // ImNodesStyleVar_PinLineThickness\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinLineThickness)},\n    // ImNodesStyleVar_PinHoverRadius\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinHoverRadius)},\n    // ImNodesStyleVar_PinOffset\n    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinOffset)},\n    // ImNodesStyleVar_MiniMapPadding\n    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, MiniMapPadding)},\n    // ImNodesStyleVar_MiniMapOffset\n    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, MiniMapOffset)},\n};\n\nstatic const ImNodesStyleVarInfo* GetStyleVarInfo(ImNodesStyleVar idx)\n{\n    IM_ASSERT(idx >= 0 && idx < ImNodesStyleVar_COUNT);\n    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImNodesStyleVar_COUNT);\n    return &GStyleVarInfo[idx];\n}\n\nvoid PushStyleVar(const ImNodesStyleVar item, const float value)\n{\n    const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(item);\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)\n    {\n        float& style_var = *(float*)var_info->GetVarPtr(&GImNodes->Style);\n        GImNodes->StyleModifierStack.push_back(ImNodesStyleVarElement(item, style_var));\n        style_var = value;\n        return;\n    }\n    IM_ASSERT(0 && \"Called PushStyleVar() float variant but variable is not a float!\");\n}\n\nvoid PushStyleVar(const ImNodesStyleVar item, const ImVec2& value)\n{\n    const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(item);\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)\n    {\n        ImVec2& style_var = *(ImVec2*)var_info->GetVarPtr(&GImNodes->Style);\n        GImNodes->StyleModifierStack.push_back(ImNodesStyleVarElement(item, style_var));\n        style_var = value;\n        return;\n    }\n    IM_ASSERT(0 && \"Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!\");\n}\n\nvoid PopStyleVar(int count)\n{\n    while (count > 0)\n    {\n        IM_ASSERT(GImNodes->StyleModifierStack.size() > 0);\n        const ImNodesStyleVarElement style_backup = GImNodes->StyleModifierStack.back();\n        GImNodes->StyleModifierStack.pop_back();\n        const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(style_backup.Item);\n        void*                      style_var = var_info->GetVarPtr(&GImNodes->Style);\n        if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)\n        {\n            ((float*)style_var)[0] = style_backup.FloatValue[0];\n        }\n        else if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)\n        {\n            ((float*)style_var)[0] = style_backup.FloatValue[0];\n            ((float*)style_var)[1] = style_backup.FloatValue[1];\n        }\n        count--;\n    }\n}\n\nvoid SetNodeScreenSpacePos(const int node_id, const ImVec2& screen_space_pos)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n    node.Origin = ScreenSpaceToGridSpace(editor, screen_space_pos);\n}\n\nvoid SetNodeEditorSpacePos(const int node_id, const ImVec2& editor_space_pos)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n    node.Origin = EditorSpaceToGridSpace(editor, editor_space_pos);\n}\n\nvoid SetNodeGridSpacePos(const int node_id, const ImVec2& grid_pos)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n    node.Origin = grid_pos;\n}\n\nvoid SetNodeDraggable(const int node_id, const bool draggable)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n    node.Draggable = draggable;\n}\n\nImVec2 GetNodeScreenSpacePos(const int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);\n    IM_ASSERT(node_idx != -1);\n    ImNodeData& node = editor.Nodes.Pool[node_idx];\n    return GridSpaceToScreenSpace(editor, node.Origin);\n}\n\nImVec2 GetNodeEditorSpacePos(const int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);\n    IM_ASSERT(node_idx != -1);\n    ImNodeData& node = editor.Nodes.Pool[node_idx];\n    return GridSpaceToEditorSpace(editor, node.Origin);\n}\n\nImVec2 GetNodeGridSpacePos(const int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);\n    IM_ASSERT(node_idx != -1);\n    ImNodeData& node = editor.Nodes.Pool[node_idx];\n    return node.Origin;\n}\n\nvoid SnapNodeToGrid(int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);\n    node.Origin = SnapOriginToGrid(node.Origin);\n}\n\nbool IsEditorHovered() { return MouseInCanvas(); }\n\nbool IsNodeHovered(int* const node_id)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(node_id != NULL);\n\n    const bool is_hovered = GImNodes->HoveredNodeIdx.HasValue();\n    if (is_hovered)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        *node_id = editor.Nodes.Pool[GImNodes->HoveredNodeIdx.Value()].Id;\n    }\n    return is_hovered;\n}\n\nbool IsLinkHovered(int* const link_id)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(link_id != NULL);\n\n    const bool is_hovered = GImNodes->HoveredLinkIdx.HasValue();\n    if (is_hovered)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        *link_id = editor.Links.Pool[GImNodes->HoveredLinkIdx.Value()].Id;\n    }\n    return is_hovered;\n}\n\nbool IsPinHovered(int* const attr)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(attr != NULL);\n\n    const bool is_hovered = GImNodes->HoveredPinIdx.HasValue();\n    if (is_hovered)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        *attr = editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Id;\n    }\n    return is_hovered;\n}\n\nint NumSelectedNodes()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    const ImNodesEditorContext& editor = EditorContextGet();\n    return editor.SelectedNodeIndices.size();\n}\n\nint NumSelectedLinks()\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    const ImNodesEditorContext& editor = EditorContextGet();\n    return editor.SelectedLinkIndices.size();\n}\n\nvoid GetSelectedNodes(int* node_ids)\n{\n    IM_ASSERT(node_ids != NULL);\n\n    const ImNodesEditorContext& editor = EditorContextGet();\n    for (int i = 0; i < editor.SelectedNodeIndices.size(); ++i)\n    {\n        const int node_idx = editor.SelectedNodeIndices[i];\n        node_ids[i] = editor.Nodes.Pool[node_idx].Id;\n    }\n}\n\nvoid GetSelectedLinks(int* link_ids)\n{\n    IM_ASSERT(link_ids != NULL);\n\n    const ImNodesEditorContext& editor = EditorContextGet();\n    for (int i = 0; i < editor.SelectedLinkIndices.size(); ++i)\n    {\n        const int link_idx = editor.SelectedLinkIndices[i];\n        link_ids[i] = editor.Links.Pool[link_idx].Id;\n    }\n}\n\nvoid ClearNodeSelection()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    editor.SelectedNodeIndices.clear();\n}\n\nvoid ClearNodeSelection(int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ClearObjectSelection(editor.Nodes, editor.SelectedNodeIndices, node_id);\n}\n\nvoid ClearLinkSelection()\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    editor.SelectedLinkIndices.clear();\n}\n\nvoid ClearLinkSelection(int link_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    ClearObjectSelection(editor.Links, editor.SelectedLinkIndices, link_id);\n}\n\nvoid SelectNode(int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    SelectObject(editor.Nodes, editor.SelectedNodeIndices, node_id);\n}\n\nvoid SelectLink(int link_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    SelectObject(editor.Links, editor.SelectedLinkIndices, link_id);\n}\n\nbool IsNodeSelected(int node_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    return IsObjectSelected(editor.Nodes, editor.SelectedNodeIndices, node_id);\n}\n\nbool IsLinkSelected(int link_id)\n{\n    ImNodesEditorContext& editor = EditorContextGet();\n    return IsObjectSelected(editor.Links, editor.SelectedLinkIndices, link_id);\n}\n\nbool IsAttributeActive()\n{\n    IM_ASSERT((GImNodes->CurrentScope & ImNodesScope_Node) != 0);\n\n    if (!GImNodes->ActiveAttribute)\n    {\n        return false;\n    }\n\n    return GImNodes->ActiveAttributeId == GImNodes->CurrentAttributeId;\n}\n\nbool IsAnyAttributeActive(int* const attribute_id)\n{\n    IM_ASSERT((GImNodes->CurrentScope & (ImNodesScope_Node | ImNodesScope_Attribute)) == 0);\n\n    if (!GImNodes->ActiveAttribute)\n    {\n        return false;\n    }\n\n    if (attribute_id != NULL)\n    {\n        *attribute_id = GImNodes->ActiveAttributeId;\n    }\n\n    return true;\n}\n\nbool IsLinkStarted(int* const started_at_id)\n{\n    // Call this function after EndNodeEditor()!\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(started_at_id != NULL);\n\n    const bool is_started = (GImNodes->ImNodesUIState & ImNodesUIState_LinkStarted) != 0;\n    if (is_started)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        const int                   pin_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;\n        *started_at_id = editor.Pins.Pool[pin_idx].Id;\n    }\n\n    return is_started;\n}\n\nbool IsLinkDropped(int* const started_at_id, const bool including_detached_links)\n{\n    // Call this function after EndNodeEditor()!\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n\n    const ImNodesEditorContext& editor = EditorContextGet();\n\n    const bool link_dropped =\n        (GImNodes->ImNodesUIState & ImNodesUIState_LinkDropped) != 0 &&\n        (including_detached_links ||\n         editor.ClickInteraction.LinkCreation.Type != ImNodesLinkCreationType_FromDetach);\n\n    if (link_dropped && started_at_id)\n    {\n        const int pin_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;\n        *started_at_id = editor.Pins.Pool[pin_idx].Id;\n    }\n\n    return link_dropped;\n}\n\nbool IsLinkCreated(\n    int* const  started_at_pin_id,\n    int* const  ended_at_pin_id,\n    bool* const created_from_snap)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(started_at_pin_id != NULL);\n    IM_ASSERT(ended_at_pin_id != NULL);\n\n    const bool is_created = (GImNodes->ImNodesUIState & ImNodesUIState_LinkCreated) != 0;\n\n    if (is_created)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        const int                   start_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;\n        const int        end_idx = editor.ClickInteraction.LinkCreation.EndPinIdx.Value();\n        const ImPinData& start_pin = editor.Pins.Pool[start_idx];\n        const ImPinData& end_pin = editor.Pins.Pool[end_idx];\n\n        if (start_pin.Type == ImNodesAttributeType_Output)\n        {\n            *started_at_pin_id = start_pin.Id;\n            *ended_at_pin_id = end_pin.Id;\n        }\n        else\n        {\n            *started_at_pin_id = end_pin.Id;\n            *ended_at_pin_id = start_pin.Id;\n        }\n\n        if (created_from_snap)\n        {\n            *created_from_snap =\n                editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation;\n        }\n    }\n\n    return is_created;\n}\n\nbool IsLinkCreated(\n    int*  started_at_node_id,\n    int*  started_at_pin_id,\n    int*  ended_at_node_id,\n    int*  ended_at_pin_id,\n    bool* created_from_snap)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n    IM_ASSERT(started_at_node_id != NULL);\n    IM_ASSERT(started_at_pin_id != NULL);\n    IM_ASSERT(ended_at_node_id != NULL);\n    IM_ASSERT(ended_at_pin_id != NULL);\n\n    const bool is_created = (GImNodes->ImNodesUIState & ImNodesUIState_LinkCreated) != 0;\n\n    if (is_created)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        const int                   start_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;\n        const int         end_idx = editor.ClickInteraction.LinkCreation.EndPinIdx.Value();\n        const ImPinData&  start_pin = editor.Pins.Pool[start_idx];\n        const ImNodeData& start_node = editor.Nodes.Pool[start_pin.ParentNodeIdx];\n        const ImPinData&  end_pin = editor.Pins.Pool[end_idx];\n        const ImNodeData& end_node = editor.Nodes.Pool[end_pin.ParentNodeIdx];\n\n        if (start_pin.Type == ImNodesAttributeType_Output)\n        {\n            *started_at_pin_id = start_pin.Id;\n            *started_at_node_id = start_node.Id;\n            *ended_at_pin_id = end_pin.Id;\n            *ended_at_node_id = end_node.Id;\n        }\n        else\n        {\n            *started_at_pin_id = end_pin.Id;\n            *started_at_node_id = end_node.Id;\n            *ended_at_pin_id = start_pin.Id;\n            *ended_at_node_id = start_node.Id;\n        }\n\n        if (created_from_snap)\n        {\n            *created_from_snap =\n                editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation;\n        }\n    }\n\n    return is_created;\n}\n\nbool IsLinkDestroyed(int* const link_id)\n{\n    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);\n\n    const bool link_destroyed = GImNodes->DeletedLinkIdx.HasValue();\n    if (link_destroyed)\n    {\n        const ImNodesEditorContext& editor = EditorContextGet();\n        const int                   link_idx = GImNodes->DeletedLinkIdx.Value();\n        *link_id = editor.Links.Pool[link_idx].Id;\n    }\n\n    return link_destroyed;\n}\n\nnamespace\n{\nvoid NodeLineHandler(ImNodesEditorContext& editor, const char* const line)\n{\n    int id;\n    int x, y;\n    if (sscanf(line, \"[node.%i\", &id) == 1)\n    {\n        const int node_idx = ObjectPoolFindOrCreateIndex(editor.Nodes, id);\n        GImNodes->CurrentNodeIdx = node_idx;\n        ImNodeData& node = editor.Nodes.Pool[node_idx];\n        node.Id = id;\n    }\n    else if (sscanf(line, \"origin=%i,%i\", &x, &y) == 2)\n    {\n        ImNodeData& node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];\n        node.Origin = SnapOriginToGrid(ImVec2((float)x, (float)y));\n    }\n}\n\nvoid EditorLineHandler(ImNodesEditorContext& editor, const char* const line)\n{\n    (void)sscanf(line, \"panning=%f,%f\", &editor.Panning.x, &editor.Panning.y);\n}\n} // namespace\n\nconst char* SaveCurrentEditorStateToIniString(size_t* const data_size)\n{\n    return SaveEditorStateToIniString(&EditorContextGet(), data_size);\n}\n\nconst char* SaveEditorStateToIniString(\n    const ImNodesEditorContext* const editor_ptr,\n    size_t* const                     data_size)\n{\n    IM_ASSERT(editor_ptr != NULL);\n    const ImNodesEditorContext& editor = *editor_ptr;\n\n    GImNodes->TextBuffer.clear();\n    // TODO: check to make sure that the estimate is the upper bound of element\n    GImNodes->TextBuffer.reserve(64 * editor.Nodes.Pool.size());\n\n    GImNodes->TextBuffer.appendf(\n        \"[editor]\\npanning=%i,%i\\n\", (int)editor.Panning.x, (int)editor.Panning.y);\n\n    for (int i = 0; i < editor.Nodes.Pool.size(); i++)\n    {\n        if (editor.Nodes.InUse[i])\n        {\n            const ImNodeData& node = editor.Nodes.Pool[i];\n            GImNodes->TextBuffer.appendf(\"\\n[node.%d]\\n\", node.Id);\n            GImNodes->TextBuffer.appendf(\"origin=%i,%i\\n\", (int)node.Origin.x, (int)node.Origin.y);\n        }\n    }\n\n    if (data_size != NULL)\n    {\n        *data_size = GImNodes->TextBuffer.size();\n    }\n\n    return GImNodes->TextBuffer.c_str();\n}\n\nvoid LoadCurrentEditorStateFromIniString(const char* const data, const size_t data_size)\n{\n    LoadEditorStateFromIniString(&EditorContextGet(), data, data_size);\n}\n\nvoid LoadEditorStateFromIniString(\n    ImNodesEditorContext* const editor_ptr,\n    const char* const           data,\n    const size_t                data_size)\n{\n    if (data_size == 0u)\n    {\n        return;\n    }\n\n    ImNodesEditorContext& editor = editor_ptr == NULL ? EditorContextGet() : *editor_ptr;\n\n    char*       buf = (char*)ImGui::MemAlloc(data_size + 1);\n    const char* buf_end = buf + data_size;\n    memcpy(buf, data, data_size);\n    buf[data_size] = 0;\n\n    void (*line_handler)(ImNodesEditorContext&, const char*);\n    line_handler = NULL;\n    char* line_end = NULL;\n    for (char* line = buf; line < buf_end; line = line_end + 1)\n    {\n        while (*line == '\\n' || *line == '\\r')\n        {\n            line++;\n        }\n        line_end = line;\n        while (line_end < buf_end && *line_end != '\\n' && *line_end != '\\r')\n        {\n            line_end++;\n        }\n        line_end[0] = 0;\n\n        if (*line == ';' || *line == '\\0')\n        {\n            continue;\n        }\n\n        if (line[0] == '[' && line_end[-1] == ']')\n        {\n            line_end[-1] = 0;\n            if (strncmp(line + 1, \"node\", 4) == 0)\n            {\n                line_handler = NodeLineHandler;\n            }\n            else if (strcmp(line + 1, \"editor\") == 0)\n            {\n                line_handler = EditorLineHandler;\n            }\n        }\n\n        if (line_handler != NULL)\n        {\n            line_handler(editor, line);\n        }\n    }\n    ImGui::MemFree(buf);\n}\n\nvoid SaveCurrentEditorStateToIniFile(const char* const file_name)\n{\n    SaveEditorStateToIniFile(&EditorContextGet(), file_name);\n}\n\nvoid SaveEditorStateToIniFile(const ImNodesEditorContext* const editor, const char* const file_name)\n{\n    size_t      data_size = 0u;\n    const char* data = SaveEditorStateToIniString(editor, &data_size);\n    FILE*       file = ImFileOpen(file_name, \"wt\");\n    if (!file)\n    {\n        return;\n    }\n\n    fwrite(data, sizeof(char), data_size, file);\n    fclose(file);\n}\n\nvoid LoadCurrentEditorStateFromIniFile(const char* const file_name)\n{\n    LoadEditorStateFromIniFile(&EditorContextGet(), file_name);\n}\n\nvoid LoadEditorStateFromIniFile(ImNodesEditorContext* const editor, const char* const file_name)\n{\n    size_t data_size = 0u;\n    char*  file_data = (char*)ImFileLoadToMemory(file_name, \"rb\", &data_size);\n\n    if (!file_data)\n    {\n        return;\n    }\n\n    LoadEditorStateFromIniString(editor, file_data, data_size);\n    ImGui::MemFree(file_data);\n}\n} // namespace IMNODES_NAMESPACE\n"
        },
        {
          "name": "imnodes.h",
          "type": "blob",
          "size": 17.806640625,
          "content": "#pragma once\n\n#include <stddef.h>\n#include <imgui.h>\n\n#ifdef IMNODES_USER_CONFIG\n#include IMNODES_USER_CONFIG\n#endif\n\n#ifndef IMNODES_NAMESPACE\n#define IMNODES_NAMESPACE ImNodes\n#endif\n\ntypedef int ImNodesCol;             // -> enum ImNodesCol_\ntypedef int ImNodesStyleVar;        // -> enum ImNodesStyleVar_\ntypedef int ImNodesStyleFlags;      // -> enum ImNodesStyleFlags_\ntypedef int ImNodesPinShape;        // -> enum ImNodesPinShape_\ntypedef int ImNodesAttributeFlags;  // -> enum ImNodesAttributeFlags_\ntypedef int ImNodesMiniMapLocation; // -> enum ImNodesMiniMapLocation_\n\nenum ImNodesCol_\n{\n    ImNodesCol_NodeBackground = 0,\n    ImNodesCol_NodeBackgroundHovered,\n    ImNodesCol_NodeBackgroundSelected,\n    ImNodesCol_NodeOutline,\n    ImNodesCol_TitleBar,\n    ImNodesCol_TitleBarHovered,\n    ImNodesCol_TitleBarSelected,\n    ImNodesCol_Link,\n    ImNodesCol_LinkHovered,\n    ImNodesCol_LinkSelected,\n    ImNodesCol_Pin,\n    ImNodesCol_PinHovered,\n    ImNodesCol_BoxSelector,\n    ImNodesCol_BoxSelectorOutline,\n    ImNodesCol_GridBackground,\n    ImNodesCol_GridLine,\n    ImNodesCol_GridLinePrimary,\n    ImNodesCol_MiniMapBackground,\n    ImNodesCol_MiniMapBackgroundHovered,\n    ImNodesCol_MiniMapOutline,\n    ImNodesCol_MiniMapOutlineHovered,\n    ImNodesCol_MiniMapNodeBackground,\n    ImNodesCol_MiniMapNodeBackgroundHovered,\n    ImNodesCol_MiniMapNodeBackgroundSelected,\n    ImNodesCol_MiniMapNodeOutline,\n    ImNodesCol_MiniMapLink,\n    ImNodesCol_MiniMapLinkSelected,\n    ImNodesCol_MiniMapCanvas,\n    ImNodesCol_MiniMapCanvasOutline,\n    ImNodesCol_COUNT\n};\n\nenum ImNodesStyleVar_\n{\n    ImNodesStyleVar_GridSpacing = 0,\n    ImNodesStyleVar_NodeCornerRounding,\n    ImNodesStyleVar_NodePadding,\n    ImNodesStyleVar_NodeBorderThickness,\n    ImNodesStyleVar_LinkThickness,\n    ImNodesStyleVar_LinkLineSegmentsPerLength,\n    ImNodesStyleVar_LinkHoverDistance,\n    ImNodesStyleVar_PinCircleRadius,\n    ImNodesStyleVar_PinQuadSideLength,\n    ImNodesStyleVar_PinTriangleSideLength,\n    ImNodesStyleVar_PinLineThickness,\n    ImNodesStyleVar_PinHoverRadius,\n    ImNodesStyleVar_PinOffset,\n    ImNodesStyleVar_MiniMapPadding,\n    ImNodesStyleVar_MiniMapOffset,\n    ImNodesStyleVar_COUNT\n};\n\nenum ImNodesStyleFlags_\n{\n    ImNodesStyleFlags_None = 0,\n    ImNodesStyleFlags_NodeOutline = 1 << 0,\n    ImNodesStyleFlags_GridLines = 1 << 2,\n    ImNodesStyleFlags_GridLinesPrimary = 1 << 3,\n    ImNodesStyleFlags_GridSnapping = 1 << 4\n};\n\nenum ImNodesPinShape_\n{\n    ImNodesPinShape_Circle,\n    ImNodesPinShape_CircleFilled,\n    ImNodesPinShape_Triangle,\n    ImNodesPinShape_TriangleFilled,\n    ImNodesPinShape_Quad,\n    ImNodesPinShape_QuadFilled\n};\n\n// This enum controls the way the attribute pins behave.\nenum ImNodesAttributeFlags_\n{\n    ImNodesAttributeFlags_None = 0,\n    // Allow detaching a link by left-clicking and dragging the link at a pin it is connected to.\n    // NOTE: the user has to actually delete the link for this to work. A deleted link can be\n    // detected by calling IsLinkDestroyed() after EndNodeEditor().\n    ImNodesAttributeFlags_EnableLinkDetachWithDragClick = 1 << 0,\n    // Visual snapping of an in progress link will trigger IsLink Created/Destroyed events. Allows\n    // for previewing the creation of a link while dragging it across attributes. See here for demo:\n    // https://github.com/Nelarius/imnodes/issues/41#issuecomment-647132113 NOTE: the user has to\n    // actually delete the link for this to work. A deleted link can be detected by calling\n    // IsLinkDestroyed() after EndNodeEditor().\n    ImNodesAttributeFlags_EnableLinkCreationOnSnap = 1 << 1\n};\n\nstruct ImNodesIO\n{\n    struct EmulateThreeButtonMouse\n    {\n        EmulateThreeButtonMouse();\n\n        // The keyboard modifier to use in combination with mouse left click to pan the editor view.\n        // Set to NULL by default. To enable this feature, set the modifier to point to a boolean\n        // indicating the state of a modifier. For example,\n        //\n        // ImNodes::GetIO().EmulateThreeButtonMouse.Modifier = &ImGui::GetIO().KeyAlt;\n        const bool* Modifier;\n    } EmulateThreeButtonMouse;\n\n    struct LinkDetachWithModifierClick\n    {\n        LinkDetachWithModifierClick();\n\n        // Pointer to a boolean value indicating when the desired modifier is pressed. Set to NULL\n        // by default. To enable the feature, set the modifier to point to a boolean indicating the\n        // state of a modifier. For example,\n        //\n        // ImNodes::GetIO().LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyCtrl;\n        //\n        // Left-clicking a link with this modifier pressed will detach that link. NOTE: the user has\n        // to actually delete the link for this to work. A deleted link can be detected by calling\n        // IsLinkDestroyed() after EndNodeEditor().\n        const bool* Modifier;\n    } LinkDetachWithModifierClick;\n\n    struct MultipleSelectModifier\n    {\n        MultipleSelectModifier();\n\n        // Pointer to a boolean value indicating when the desired modifier is pressed. Set to NULL\n        // by default. To enable the feature, set the modifier to point to a boolean indicating the\n        // state of a modifier. For example,\n        //\n        // ImNodes::GetIO().MultipleSelectModifier.Modifier = &ImGui::GetIO().KeyCtrl;\n        //\n        // Left-clicking a node with this modifier pressed will add the node to the list of\n        // currently selected nodes. If this value is NULL, the Ctrl key will be used.\n        const bool* Modifier;\n    } MultipleSelectModifier;\n\n    // Holding alt mouse button pans the node area, by default middle mouse button will be used\n    // Set based on ImGuiMouseButton values\n    int AltMouseButton;\n\n    // Panning speed when dragging an element and mouse is outside the main editor view.\n    float AutoPanningSpeed;\n\n    ImNodesIO();\n};\n\nstruct ImNodesStyle\n{\n    float GridSpacing;\n\n    float  NodeCornerRounding;\n    ImVec2 NodePadding;\n    float  NodeBorderThickness;\n\n    float LinkThickness;\n    float LinkLineSegmentsPerLength;\n    float LinkHoverDistance;\n\n    // The following variables control the look and behavior of the pins. The default size of each\n    // pin shape is balanced to occupy approximately the same surface area on the screen.\n\n    // The circle radius used when the pin shape is either ImNodesPinShape_Circle or\n    // ImNodesPinShape_CircleFilled.\n    float PinCircleRadius;\n    // The quad side length used when the shape is either ImNodesPinShape_Quad or\n    // ImNodesPinShape_QuadFilled.\n    float PinQuadSideLength;\n    // The equilateral triangle side length used when the pin shape is either\n    // ImNodesPinShape_Triangle or ImNodesPinShape_TriangleFilled.\n    float PinTriangleSideLength;\n    // The thickness of the line used when the pin shape is not filled.\n    float PinLineThickness;\n    // The radius from the pin's center position inside of which it is detected as being hovered\n    // over.\n    float PinHoverRadius;\n    // Offsets the pins' positions from the edge of the node to the outside of the node.\n    float PinOffset;\n\n    // Mini-map padding size between mini-map edge and mini-map content.\n    ImVec2 MiniMapPadding;\n    // Mini-map offset from the screen side.\n    ImVec2 MiniMapOffset;\n\n    // By default, ImNodesStyleFlags_NodeOutline and ImNodesStyleFlags_Gridlines are enabled.\n    ImNodesStyleFlags Flags;\n    // Set these mid-frame using Push/PopColorStyle. You can index this color array with with a\n    // ImNodesCol value.\n    unsigned int Colors[ImNodesCol_COUNT];\n\n    ImNodesStyle();\n};\n\nenum ImNodesMiniMapLocation_\n{\n    ImNodesMiniMapLocation_BottomLeft,\n    ImNodesMiniMapLocation_BottomRight,\n    ImNodesMiniMapLocation_TopLeft,\n    ImNodesMiniMapLocation_TopRight,\n};\n\nstruct ImGuiContext;\nstruct ImVec2;\n\nstruct ImNodesContext;\n\n// An editor context corresponds to a set of nodes in a single workspace (created with a single\n// Begin/EndNodeEditor pair)\n//\n// By default, the library creates an editor context behind the scenes, so using any of the imnodes\n// functions doesn't require you to explicitly create a context.\nstruct ImNodesEditorContext;\n\n// Callback type used to specify special behavior when hovering a node in the minimap\n#ifndef ImNodesMiniMapNodeHoveringCallback\ntypedef void (*ImNodesMiniMapNodeHoveringCallback)(int, void*);\n#endif\n\n#ifndef ImNodesMiniMapNodeHoveringCallbackUserData\ntypedef void* ImNodesMiniMapNodeHoveringCallbackUserData;\n#endif\n\nnamespace IMNODES_NAMESPACE\n{\n// Call this function if you are compiling imnodes in to a dll, separate from ImGui. Calling this\n// function sets the GImGui global variable, which is not shared across dll boundaries.\nvoid SetImGuiContext(ImGuiContext* ctx);\n\nImNodesContext* CreateContext();\nvoid            DestroyContext(ImNodesContext* ctx = NULL); // NULL = destroy current context\nImNodesContext* GetCurrentContext();\nvoid            SetCurrentContext(ImNodesContext* ctx);\n\nImNodesEditorContext* EditorContextCreate();\nvoid                  EditorContextFree(ImNodesEditorContext*);\nvoid                  EditorContextSet(ImNodesEditorContext*);\nImVec2                EditorContextGetPanning();\nvoid                  EditorContextResetPanning(const ImVec2& pos);\nvoid                  EditorContextMoveToNode(const int node_id);\n\nImNodesIO& GetIO();\n\n// Returns the global style struct. See the struct declaration for default values.\nImNodesStyle& GetStyle();\n// Style presets matching the dear imgui styles of the same name. If dest is NULL, the active\n// context's ImNodesStyle instance will be used as the destination.\nvoid StyleColorsDark(ImNodesStyle* dest = NULL); // on by default\nvoid StyleColorsClassic(ImNodesStyle* dest = NULL);\nvoid StyleColorsLight(ImNodesStyle* dest = NULL);\n\n// The top-level function call. Call this before calling BeginNode/EndNode. Calling this function\n// will result the node editor grid workspace being rendered.\nvoid BeginNodeEditor();\nvoid EndNodeEditor();\n\n// Add a navigable minimap to the editor; call before EndNodeEditor after all\n// nodes and links have been specified\nvoid MiniMap(\n    const float                                      minimap_size_fraction = 0.2f,\n    const ImNodesMiniMapLocation                     location = ImNodesMiniMapLocation_TopLeft,\n    const ImNodesMiniMapNodeHoveringCallback         node_hovering_callback = NULL,\n    const ImNodesMiniMapNodeHoveringCallbackUserData node_hovering_callback_data = NULL);\n\n// Use PushColorStyle and PopColorStyle to modify ImNodesStyle::Colors mid-frame.\nvoid PushColorStyle(ImNodesCol item, unsigned int color);\nvoid PopColorStyle();\nvoid PushStyleVar(ImNodesStyleVar style_item, float value);\nvoid PushStyleVar(ImNodesStyleVar style_item, const ImVec2& value);\nvoid PopStyleVar(int count = 1);\n\n// id can be any positive or negative integer, but INT_MIN is currently reserved for internal use.\nvoid BeginNode(int id);\nvoid EndNode();\n\nImVec2 GetNodeDimensions(int id);\n\n// Place your node title bar content (such as the node title, using ImGui::Text) between the\n// following function calls. These functions have to be called before adding any attributes, or the\n// layout of the node will be incorrect.\nvoid BeginNodeTitleBar();\nvoid EndNodeTitleBar();\n\n// Attributes are ImGui UI elements embedded within the node. Attributes can have pin shapes\n// rendered next to them. Links are created between pins.\n//\n// The activity status of an attribute can be checked via the IsAttributeActive() and\n// IsAnyAttributeActive() function calls. This is one easy way of checking for any changes made to\n// an attribute's drag float UI, for instance.\n//\n// Each attribute id must be unique.\n\n// Create an input attribute block. The pin is rendered on left side.\nvoid BeginInputAttribute(int id, ImNodesPinShape shape = ImNodesPinShape_CircleFilled);\nvoid EndInputAttribute();\n// Create an output attribute block. The pin is rendered on the right side.\nvoid BeginOutputAttribute(int id, ImNodesPinShape shape = ImNodesPinShape_CircleFilled);\nvoid EndOutputAttribute();\n// Create a static attribute block. A static attribute has no pin, and therefore can't be linked to\n// anything. However, you can still use IsAttributeActive() and IsAnyAttributeActive() to check for\n// attribute activity.\nvoid BeginStaticAttribute(int id);\nvoid EndStaticAttribute();\n\n// Push a single AttributeFlags value. By default, only AttributeFlags_None is set.\nvoid PushAttributeFlag(ImNodesAttributeFlags flag);\nvoid PopAttributeFlag();\n\n// Render a link between attributes.\n// The attributes ids used here must match the ids used in Begin(Input|Output)Attribute function\n// calls. The order of start_attr and end_attr doesn't make a difference for rendering the link.\nvoid Link(int id, int start_attribute_id, int end_attribute_id);\n\n// Enable or disable the ability to click and drag a specific node.\nvoid SetNodeDraggable(int node_id, const bool draggable);\n\n// The node's position can be expressed in three coordinate systems:\n// * screen space coordinates, -- the origin is the upper left corner of the window.\n// * editor space coordinates -- the origin is the upper left corner of the node editor window\n// * grid space coordinates, -- the origin is the upper left corner of the node editor window,\n// translated by the current editor panning vector (see EditorContextGetPanning() and\n// EditorContextResetPanning())\n\n// Use the following functions to get and set the node's coordinates in these coordinate systems.\n\nvoid SetNodeScreenSpacePos(int node_id, const ImVec2& screen_space_pos);\nvoid SetNodeEditorSpacePos(int node_id, const ImVec2& editor_space_pos);\nvoid SetNodeGridSpacePos(int node_id, const ImVec2& grid_pos);\n\nImVec2 GetNodeScreenSpacePos(const int node_id);\nImVec2 GetNodeEditorSpacePos(const int node_id);\nImVec2 GetNodeGridSpacePos(const int node_id);\n\n// If ImNodesStyleFlags_GridSnapping is enabled, snap the specified node's origin to the grid.\nvoid SnapNodeToGrid(int node_id);\n\n// Returns true if the current node editor canvas is being hovered over by the mouse, and is not\n// blocked by any other windows.\nbool IsEditorHovered();\n// The following functions return true if a UI element is being hovered over by the mouse cursor.\n// Assigns the id of the UI element being hovered over to the function argument. Use these functions\n// after EndNodeEditor() has been called.\nbool IsNodeHovered(int* node_id);\nbool IsLinkHovered(int* link_id);\nbool IsPinHovered(int* attribute_id);\n\n// Use The following two functions to query the number of selected nodes or links in the current\n// editor. Use after calling EndNodeEditor().\nint NumSelectedNodes();\nint NumSelectedLinks();\n// Get the selected node/link ids. The pointer argument should point to an integer array with at\n// least as many elements as the respective NumSelectedNodes/NumSelectedLinks function call\n// returned.\nvoid GetSelectedNodes(int* node_ids);\nvoid GetSelectedLinks(int* link_ids);\n// Clears the list of selected nodes/links. Useful if you want to delete a selected node or link.\nvoid ClearNodeSelection();\nvoid ClearLinkSelection();\n// Use the following functions to add or remove individual nodes or links from the current editors\n// selection. Note that all functions require the id to be an existing valid id for this editor.\n// Select-functions has the precondition that the object is currently considered unselected.\n// Clear-functions has the precondition that the object is currently considered selected.\n// Preconditions listed above can be checked via IsNodeSelected/IsLinkSelected if not already\n// known.\nvoid SelectNode(int node_id);\nvoid ClearNodeSelection(int node_id);\nbool IsNodeSelected(int node_id);\nvoid SelectLink(int link_id);\nvoid ClearLinkSelection(int link_id);\nbool IsLinkSelected(int link_id);\n\n// Was the previous attribute active? This will continuously return true while the left mouse button\n// is being pressed over the UI content of the attribute.\nbool IsAttributeActive();\n// Was any attribute active? If so, sets the active attribute id to the output function argument.\nbool IsAnyAttributeActive(int* attribute_id = NULL);\n\n// Use the following functions to query a change of state for an existing link, or new link. Call\n// these after EndNodeEditor().\n\n// Did the user start dragging a new link from a pin?\nbool IsLinkStarted(int* started_at_attribute_id);\n// Did the user drop the dragged link before attaching it to a pin?\n// There are two different kinds of situations to consider when handling this event:\n// 1) a link which is created at a pin and then dropped\n// 2) an existing link which is detached from a pin and then dropped\n// Use the including_detached_links flag to control whether this function triggers when the user\n// detaches a link and drops it.\nbool IsLinkDropped(int* started_at_attribute_id = NULL, bool including_detached_links = true);\n// Did the user finish creating a new link?\nbool IsLinkCreated(\n    int*  started_at_attribute_id,\n    int*  ended_at_attribute_id,\n    bool* created_from_snap = NULL);\nbool IsLinkCreated(\n    int*  started_at_node_id,\n    int*  started_at_attribute_id,\n    int*  ended_at_node_id,\n    int*  ended_at_attribute_id,\n    bool* created_from_snap = NULL);\n\n// Was an existing link detached from a pin by the user? The detached link's id is assigned to the\n// output argument link_id.\nbool IsLinkDestroyed(int* link_id);\n\n// Use the following functions to write the editor context's state to a string, or directly to a\n// file. The editor context is serialized in the INI file format.\n\nconst char* SaveCurrentEditorStateToIniString(size_t* data_size = NULL);\nconst char* SaveEditorStateToIniString(\n    const ImNodesEditorContext* editor,\n    size_t*                     data_size = NULL);\n\nvoid LoadCurrentEditorStateFromIniString(const char* data, size_t data_size);\nvoid LoadEditorStateFromIniString(ImNodesEditorContext* editor, const char* data, size_t data_size);\n\nvoid SaveCurrentEditorStateToIniFile(const char* file_name);\nvoid SaveEditorStateToIniFile(const ImNodesEditorContext* editor, const char* file_name);\n\nvoid LoadCurrentEditorStateFromIniFile(const char* file_name);\nvoid LoadEditorStateFromIniFile(ImNodesEditorContext* editor, const char* file_name);\n} // namespace IMNODES_NAMESPACE\n"
        },
        {
          "name": "imnodes_internal.h",
          "type": "blob",
          "size": 12.5859375,
          "content": "#pragma once\n\n#define IMGUI_DEFINE_MATH_OPERATORS\n#include <imgui.h>\n#include <imgui_internal.h>\n\n#include \"imnodes.h\"\n\n#include <limits.h>\n\n// the structure of this file:\n//\n// [SECTION] internal enums\n// [SECTION] internal data structures\n// [SECTION] global and editor context structs\n// [SECTION] object pool implementation\n\nstruct ImNodesContext;\n\nextern ImNodesContext* GImNodes;\n\n// [SECTION] internal enums\n\ntypedef int ImNodesScope;\ntypedef int ImNodesAttributeType;\ntypedef int ImNodesUIState;\ntypedef int ImNodesClickInteractionType;\ntypedef int ImNodesLinkCreationType;\n\nenum ImNodesScope_\n{\n    ImNodesScope_None = 1,\n    ImNodesScope_Editor = 1 << 1,\n    ImNodesScope_Node = 1 << 2,\n    ImNodesScope_Attribute = 1 << 3\n};\n\nenum ImNodesAttributeType_\n{\n    ImNodesAttributeType_None,\n    ImNodesAttributeType_Input,\n    ImNodesAttributeType_Output\n};\n\nenum ImNodesUIState_\n{\n    ImNodesUIState_None = 0,\n    ImNodesUIState_LinkStarted = 1 << 0,\n    ImNodesUIState_LinkDropped = 1 << 1,\n    ImNodesUIState_LinkCreated = 1 << 2\n};\n\nenum ImNodesClickInteractionType_\n{\n    ImNodesClickInteractionType_Node,\n    ImNodesClickInteractionType_Link,\n    ImNodesClickInteractionType_LinkCreation,\n    ImNodesClickInteractionType_Panning,\n    ImNodesClickInteractionType_BoxSelection,\n    ImNodesClickInteractionType_ImGuiItem,\n    ImNodesClickInteractionType_None\n};\n\nenum ImNodesLinkCreationType_\n{\n    ImNodesLinkCreationType_Standard,\n    ImNodesLinkCreationType_FromDetach\n};\n\n// [SECTION] internal data structures\n\n// The object T must have the following interface:\n//\n// struct T\n// {\n//     T();\n//\n//     int id;\n// };\ntemplate<typename T>\nstruct ImObjectPool\n{\n    ImVector<T>    Pool;\n    ImVector<bool> InUse;\n    ImVector<int>  FreeList;\n    ImGuiStorage   IdMap;\n\n    ImObjectPool() : Pool(), InUse(), FreeList(), IdMap() {}\n};\n\n// Emulates std::optional<int> using the sentinel value `INVALID_INDEX`.\nstruct ImOptionalIndex\n{\n    ImOptionalIndex() : _Index(INVALID_INDEX) {}\n    ImOptionalIndex(const int value) : _Index(value) {}\n\n    // Observers\n\n    inline bool HasValue() const { return _Index != INVALID_INDEX; }\n\n    inline int Value() const\n    {\n        IM_ASSERT(HasValue());\n        return _Index;\n    }\n\n    // Modifiers\n\n    inline ImOptionalIndex& operator=(const int value)\n    {\n        _Index = value;\n        return *this;\n    }\n\n    inline void Reset() { _Index = INVALID_INDEX; }\n\n    inline bool operator==(const ImOptionalIndex& rhs) const { return _Index == rhs._Index; }\n\n    inline bool operator==(const int rhs) const { return _Index == rhs; }\n\n    inline bool operator!=(const ImOptionalIndex& rhs) const { return _Index != rhs._Index; }\n\n    inline bool operator!=(const int rhs) const { return _Index != rhs; }\n\n    static const int INVALID_INDEX = -1;\n\nprivate:\n    int _Index;\n};\n\nstruct ImNodeData\n{\n    int    Id;\n    ImVec2 Origin; // The node origin is in editor space\n    ImRect TitleBarContentRect;\n    ImRect Rect;\n\n    struct\n    {\n        ImU32 Background, BackgroundHovered, BackgroundSelected, Outline, Titlebar, TitlebarHovered,\n            TitlebarSelected;\n    } ColorStyle;\n\n    struct\n    {\n        float  CornerRounding;\n        ImVec2 Padding;\n        float  BorderThickness;\n    } LayoutStyle;\n\n    ImVector<int> PinIndices;\n    bool          Draggable;\n\n    ImNodeData(const int node_id)\n        : Id(node_id), Origin(0.0f, 0.0f), TitleBarContentRect(),\n          Rect(ImVec2(0.0f, 0.0f), ImVec2(0.0f, 0.0f)), ColorStyle(), LayoutStyle(), PinIndices(),\n          Draggable(true)\n    {\n    }\n\n    ~ImNodeData() { Id = INT_MIN; }\n};\n\nstruct ImPinData\n{\n    int                  Id;\n    int                  ParentNodeIdx;\n    ImRect               AttributeRect;\n    ImNodesAttributeType Type;\n    ImNodesPinShape      Shape;\n    ImVec2               Pos; // screen-space coordinates\n    int                  Flags;\n\n    struct\n    {\n        ImU32 Background, Hovered;\n    } ColorStyle;\n\n    ImPinData(const int pin_id)\n        : Id(pin_id), ParentNodeIdx(), AttributeRect(), Type(ImNodesAttributeType_None),\n          Shape(ImNodesPinShape_CircleFilled), Pos(), Flags(ImNodesAttributeFlags_None),\n          ColorStyle()\n    {\n    }\n};\n\nstruct ImLinkData\n{\n    int Id;\n    int StartPinIdx, EndPinIdx;\n\n    struct\n    {\n        ImU32 Base, Hovered, Selected;\n    } ColorStyle;\n\n    ImLinkData(const int link_id) : Id(link_id), StartPinIdx(), EndPinIdx(), ColorStyle() {}\n};\n\nstruct ImClickInteractionState\n{\n    ImNodesClickInteractionType Type;\n\n    struct\n    {\n        int                     StartPinIdx;\n        ImOptionalIndex         EndPinIdx;\n        ImNodesLinkCreationType Type;\n    } LinkCreation;\n\n    struct\n    {\n        ImRect Rect; // Coordinates in grid space\n    } BoxSelector;\n\n    ImClickInteractionState() : Type(ImNodesClickInteractionType_None) {}\n};\n\nstruct ImNodesColElement\n{\n    ImU32      Color;\n    ImNodesCol Item;\n\n    ImNodesColElement(const ImU32 c, const ImNodesCol s) : Color(c), Item(s) {}\n};\n\nstruct ImNodesStyleVarElement\n{\n    ImNodesStyleVar Item;\n    float           FloatValue[2];\n\n    ImNodesStyleVarElement(const ImNodesStyleVar variable, const float value) : Item(variable)\n    {\n        FloatValue[0] = value;\n    }\n\n    ImNodesStyleVarElement(const ImNodesStyleVar variable, const ImVec2 value) : Item(variable)\n    {\n        FloatValue[0] = value.x;\n        FloatValue[1] = value.y;\n    }\n};\n\n// [SECTION] global and editor context structs\n\nstruct ImNodesEditorContext\n{\n    ImObjectPool<ImNodeData> Nodes;\n    ImObjectPool<ImPinData>  Pins;\n    ImObjectPool<ImLinkData> Links;\n\n    ImVector<int> NodeDepthOrder;\n\n    // ui related fields\n    ImVec2 Panning;\n    ImVec2 AutoPanningDelta;\n    // Minimum and maximum extents of all content in grid space. Valid after final\n    // ImNodes::EndNode() call.\n    ImRect GridContentBounds;\n\n    ImVector<int> SelectedNodeIndices;\n    ImVector<int> SelectedLinkIndices;\n\n    // Relative origins of selected nodes for snapping of dragged nodes\n    ImVector<ImVec2> SelectedNodeOffsets;\n    // Offset of the primary node origin relative to the mouse cursor.\n    ImVec2 PrimaryNodeOffset;\n\n    ImClickInteractionState ClickInteraction;\n\n    // Mini-map state set by MiniMap()\n\n    bool                                       MiniMapEnabled;\n    ImNodesMiniMapLocation                     MiniMapLocation;\n    float                                      MiniMapSizeFraction;\n    ImNodesMiniMapNodeHoveringCallback         MiniMapNodeHoveringCallback;\n    ImNodesMiniMapNodeHoveringCallbackUserData MiniMapNodeHoveringCallbackUserData;\n\n    // Mini-map state set during EndNodeEditor() call\n\n    ImRect MiniMapRectScreenSpace;\n    ImRect MiniMapContentScreenSpace;\n    float  MiniMapScaling;\n\n    ImNodesEditorContext()\n        : Nodes(), Pins(), Links(), Panning(0.f, 0.f), SelectedNodeIndices(), SelectedLinkIndices(),\n          SelectedNodeOffsets(), PrimaryNodeOffset(0.f, 0.f), ClickInteraction(),\n          MiniMapEnabled(false), MiniMapSizeFraction(0.0f), MiniMapNodeHoveringCallback(NULL),\n          MiniMapNodeHoveringCallbackUserData(NULL), MiniMapScaling(0.0f)\n    {\n    }\n};\n\nstruct ImNodesContext\n{\n    ImNodesEditorContext* DefaultEditorCtx;\n    ImNodesEditorContext* EditorCtx;\n\n    // Canvas draw list and helper state\n    ImDrawList*   CanvasDrawList;\n    ImGuiStorage  NodeIdxToSubmissionIdx;\n    ImVector<int> NodeIdxSubmissionOrder;\n    ImVector<int> NodeIndicesOverlappingWithMouse;\n    ImVector<int> OccludedPinIndices;\n\n    // Canvas extents\n    ImVec2 CanvasOriginScreenSpace;\n    ImRect CanvasRectScreenSpace;\n\n    // Debug helpers\n    ImNodesScope CurrentScope;\n\n    // Configuration state\n    ImNodesIO                        Io;\n    ImNodesStyle                     Style;\n    ImVector<ImNodesColElement>      ColorModifierStack;\n    ImVector<ImNodesStyleVarElement> StyleModifierStack;\n    ImGuiTextBuffer                  TextBuffer;\n\n    int           CurrentAttributeFlags;\n    ImVector<int> AttributeFlagStack;\n\n    // UI element state\n    int CurrentNodeIdx;\n    int CurrentPinIdx;\n    int CurrentAttributeId;\n\n    ImOptionalIndex HoveredNodeIdx;\n    ImOptionalIndex HoveredLinkIdx;\n    ImOptionalIndex HoveredPinIdx;\n\n    ImOptionalIndex DeletedLinkIdx;\n    ImOptionalIndex SnapLinkIdx;\n\n    // Event helper state\n    // TODO: this should be a part of a state machine, and not a member of the global struct.\n    // Unclear what parts of the code this relates to.\n    int ImNodesUIState;\n\n    int  ActiveAttributeId;\n    bool ActiveAttribute;\n\n    // ImGui::IO cache\n\n    ImVec2 MousePos;\n\n    bool  LeftMouseClicked;\n    bool  LeftMouseReleased;\n    bool  AltMouseClicked;\n    bool  LeftMouseDragging;\n    bool  AltMouseDragging;\n    float AltMouseScrollDelta;\n    bool  MultipleSelectModifier;\n};\n\nnamespace IMNODES_NAMESPACE\n{\nstatic inline ImNodesEditorContext& EditorContextGet()\n{\n    // No editor context was set! Did you forget to call ImNodes::CreateContext()?\n    IM_ASSERT(GImNodes->EditorCtx != NULL);\n    return *GImNodes->EditorCtx;\n}\n\n// [SECTION] ObjectPool implementation\n\ntemplate<typename T>\nstatic inline int ObjectPoolFind(const ImObjectPool<T>& objects, const int id)\n{\n    const int index = objects.IdMap.GetInt(static_cast<ImGuiID>(id), -1);\n    return index;\n}\n\ntemplate<typename T>\nstatic inline void ObjectPoolUpdate(ImObjectPool<T>& objects)\n{\n    for (int i = 0; i < objects.InUse.size(); ++i)\n    {\n        const int id = objects.Pool[i].Id;\n\n        if (!objects.InUse[i] && objects.IdMap.GetInt(id, -1) == i)\n        {\n            objects.IdMap.SetInt(id, -1);\n            objects.FreeList.push_back(i);\n            (objects.Pool.Data + i)->~T();\n        }\n    }\n}\n\ntemplate<>\ninline void ObjectPoolUpdate(ImObjectPool<ImNodeData>& nodes)\n{\n    for (int i = 0; i < nodes.InUse.size(); ++i)\n    {\n        if (nodes.InUse[i])\n        {\n            nodes.Pool[i].PinIndices.clear();\n        }\n        else\n        {\n            const int id = nodes.Pool[i].Id;\n\n            if (nodes.IdMap.GetInt(id, -1) == i)\n            {\n                // Remove node idx form depth stack the first time we detect that this idx slot is\n                // unused\n                ImVector<int>&   depth_stack = EditorContextGet().NodeDepthOrder;\n                const int* const elem = depth_stack.find(i);\n                IM_ASSERT(elem != depth_stack.end());\n                depth_stack.erase(elem);\n\n                nodes.IdMap.SetInt(id, -1);\n                nodes.FreeList.push_back(i);\n                (nodes.Pool.Data + i)->~ImNodeData();\n            }\n        }\n    }\n}\n\ntemplate<typename T>\nstatic inline void ObjectPoolReset(ImObjectPool<T>& objects)\n{\n    if (!objects.InUse.empty())\n    {\n        memset(objects.InUse.Data, 0, objects.InUse.size_in_bytes());\n    }\n}\n\ntemplate<typename T>\nstatic inline int ObjectPoolFindOrCreateIndex(ImObjectPool<T>& objects, const int id)\n{\n    int index = objects.IdMap.GetInt(static_cast<ImGuiID>(id), -1);\n\n    // Construct new object\n    if (index == -1)\n    {\n        if (objects.FreeList.empty())\n        {\n            index = objects.Pool.size();\n            IM_ASSERT(objects.Pool.size() == objects.InUse.size());\n            const int new_size = objects.Pool.size() + 1;\n            objects.Pool.resize(new_size);\n            objects.InUse.resize(new_size);\n        }\n        else\n        {\n            index = objects.FreeList.back();\n            objects.FreeList.pop_back();\n        }\n        IM_PLACEMENT_NEW(objects.Pool.Data + index) T(id);\n        objects.IdMap.SetInt(static_cast<ImGuiID>(id), index);\n    }\n\n    // Flag it as used\n    objects.InUse[index] = true;\n\n    return index;\n}\n\ntemplate<>\ninline int ObjectPoolFindOrCreateIndex(ImObjectPool<ImNodeData>& nodes, const int node_id)\n{\n    int node_idx = nodes.IdMap.GetInt(static_cast<ImGuiID>(node_id), -1);\n\n    // Construct new node\n    if (node_idx == -1)\n    {\n        if (nodes.FreeList.empty())\n        {\n            node_idx = nodes.Pool.size();\n            IM_ASSERT(nodes.Pool.size() == nodes.InUse.size());\n            const int new_size = nodes.Pool.size() + 1;\n            nodes.Pool.resize(new_size);\n            nodes.InUse.resize(new_size);\n        }\n        else\n        {\n            node_idx = nodes.FreeList.back();\n            nodes.FreeList.pop_back();\n        }\n        IM_PLACEMENT_NEW(nodes.Pool.Data + node_idx) ImNodeData(node_id);\n        nodes.IdMap.SetInt(static_cast<ImGuiID>(node_id), node_idx);\n\n        ImNodesEditorContext& editor = EditorContextGet();\n        editor.NodeDepthOrder.push_back(node_idx);\n    }\n\n    // Flag node as used\n    nodes.InUse[node_idx] = true;\n\n    return node_idx;\n}\n\ntemplate<typename T>\nstatic inline T& ObjectPoolFindOrCreateObject(ImObjectPool<T>& objects, const int id)\n{\n    const int index = ObjectPoolFindOrCreateIndex(objects, id);\n    return objects.Pool[index];\n}\n} // namespace IMNODES_NAMESPACE\n"
        },
        {
          "name": "vcpkg",
          "type": "commit",
          "content": null
        },
        {
          "name": "vcpkg.json",
          "type": "blob",
          "size": 0.2080078125,
          "content": "{\n    \"name\": \"imnodes\",\n    \"version-string\": \"0.1.0-dev\",\n    \"dependencies\": [\n        \"sdl2\",\n        {\n          \"name\": \"imgui\",\n          \"features\": [ \"sdl2-binding\", \"opengl3-binding\" ]\n        }\n    ]\n}\n"
        }
      ]
    }
  ]
}