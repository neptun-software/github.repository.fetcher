{
  "metadata": {
    "timestamp": 1736565739558,
    "page": 656,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/proxy",
      "stars": 2368,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01171875,
          "content": "* text=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": "# Ignore build directories\nbuild/\nTesting/\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.146484375,
          "content": "cmake_minimum_required(VERSION 3.5)\n\nproject(msft_proxy VERSION 3.1.0 LANGUAGES CXX)\nadd_library(msft_proxy INTERFACE)\ntarget_compile_features(msft_proxy INTERFACE cxx_std_20)\ntarget_include_directories(msft_proxy INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n                                                $<INSTALL_INTERFACE:include>)\n\n# install and export the project. project name - proxy\ninclude(GNUInstallDirs)\ninstall(TARGETS msft_proxy\n        EXPORT proxyConfig)\ninstall(FILES proxy.h\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/proxy)\ninstall(EXPORT proxyConfig DESTINATION ${CMAKE_INSTALL_DATADIR}/proxy)\nexport(TARGETS msft_proxy FILE proxyConfig.cmake)\ninclude(CMakePackageConfigHelpers)\nwrite_basic_package_version_file(proxyConfigVersion.cmake\n                                 COMPATIBILITY SameMajorVersion\n                                 ARCH_INDEPENDENT)\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/proxyConfigVersion.cmake\n        DESTINATION ${CMAKE_INSTALL_DATADIR}/proxy)\n\n# build tests if BUILD_TESTING is ON\ninclude(CTest)\nif (BUILD_TESTING)\n  add_subdirectory(tests)\n  add_subdirectory(benchmarks)\n  add_subdirectory(samples)\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.43359375,
          "content": "# Microsoft Open Source Code of Conduct\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\n\nResources:\n\n- [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/)\n- [Microsoft Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)\n- Contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with questions or concerns\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1142578125,
          "content": "    MIT License\n\n    Copyright (c) Microsoft Corporation.\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.3388671875,
          "content": "# Proxy: Next Generation Polymorphism in C++\n\n[![Proxy-CI](https://github.com/microsoft/proxy/actions/workflows/pipeline-ci.yml/badge.svg)](https://github.com/microsoft/proxy/actions/workflows/pipeline-ci.yml)\n\nAre you looking to simplify the lifetime management and maintenance of polymorphic objects in C++?\n\nDo you want to write polymorphic code in C++ as easily as in [GC languages](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) like Java or C#, without sacrificing performance?\n\nHave you tried other polymorphic programming libraries in C++ but found them deficient?\n\nIf so, this library is for you.\n\n## Our Mission\n\n\"Proxy\" is a modern C++ library that helps you use polymorphism (a way to use different types of objects interchangeably) without needing inheritance.\n\n\"Proxy\" was created by Microsoft engineers and has been used in the Windows operating system since 2022. For many years, using inheritance was the main way to achieve polymorphism in C++. However, new programming languages like [Rust](https://doc.rust-lang.org/book/ch10-02-traits.html) offer better ways to do this. We have improved our understanding of object-oriented programming and decided to use *pointers* in C++ as the foundation for \"Proxy\". Specifically, the \"Proxy\" library is designed to be:\n\n- **Portable**: \"Proxy\" was implemented as a single-header library in standard C++20. It can be used on any platform while the compiler supports C++20. The majority of the library is [freestanding](https://en.cppreference.com/w/cpp/freestanding), making it feasible for embedded engineering or kernel design of an operating system.\n- **Non-intrusive**: An implementation type is no longer required to inherit from an abstract binding.\n- **Well-managed**: \"Proxy\" provides a GC-like capability that manages the lifetimes of different objects efficiently without the need for an actual garbage collector.\n- **Fast**: With typical compiler optimizations, \"Proxy\" produces high-quality code that is as good as or better than hand-written code. In many cases, \"Proxy\" performs better than traditional inheritance-based approaches, especially in managing the lifetimes of objects.\n- **Accessible**: Learned from user feedback, accessibility has been significantly improved in \"Proxy 3\" with intuitive syntax, good IDE compatibility, and accurate diagnostics.\n- **Flexible**: Not only member functions, the \"abstraction\" of \"Proxy\" allows *any* expression to be polymorphic, including free functions, operators, conversions, etc. Different abstractions can be freely composed on demand. Performance tuning is supported for experts to balance between extensibility and performance.\n\nPlease refer to the [Proxy's Frequently Asked Questions](https://microsoft.github.io/proxy/docs/faq.html) for more background, and refer to the [specifications](https://microsoft.github.io/proxy/docs/specifications.html) for more technical details.\n\n## Quick Start\n\n\"Proxy\" is a header-only C++20 library. To use the library, make sure your compiler meets the [minimum requirements](#compiler-req) and just include the header file [proxy.h](https://github.com/microsoft/proxy/blob/main/proxy.h) in your source code. Alternatively, you can install the library via [vcpkg](https://learn.microsoft.com/en-us/vcpkg/get_started/overview) or [conan](https://conan.io/), by searching for \"proxy\" (see [vcpkg.io](https://vcpkg.io/en/package/proxy) and [conan.io](https://conan.io/center/recipes/proxy)).\n\n### Hello World\n\nLet's get started with the following \"Hello World\" example:\n\n```cpp\n#include <iostream>\n#include <string>\n\n#include \"proxy.h\"\n\nstruct Streamable : pro::facade_builder\n    ::add_convention<pro::operator_dispatch<\"<<\", true>, std::ostream&(std::ostream& out) const>\n    ::build {};\n\nint main() {\n  std::string str = \"Hello World\";\n  pro::proxy<Streamable> p1 = &str;\n  std::cout << \"p1 = \" << *p1 << \"\\n\";  // Prints: \"p1 = Hello World\"\n\n  pro::proxy<Streamable> p2 = std::make_unique<int>(123);\n  std::cout << \"p2 = \" << *p2 << \"\\n\";  // Prints: \"p2 = 123\"\n\n  pro::proxy<Streamable> p3 = pro::make_proxy<Streamable>(3.14);\n  std::cout << \"p3 = \" << *p3 << \"\\n\";  // Prints: \"p3 = 3.14\"\n}\n```\n\nHere is a step-by-step explanation:\n\n- `#include <iostream>`: For [`std::cout`](https://en.cppreference.com/w/cpp/io/cout).\n- `#include <string>`: For [`std::string`](https://en.cppreference.com/w/cpp/string/basic_string).\n- `#include \"proxy.h\"`: For the \"Proxy\" library. Most of the facilities of the library are defined in namespace `pro`. If the library is consumed via [vcpkg](https://learn.microsoft.com/en-us/vcpkg/get_started/overview) or [conan](https://conan.io/), this line should be changed into `#include <proxy/proxy.h>`.\n- `struct Streamable : pro::facade_builder ... ::build {}`: Defines a facade type `Streamable`. The term \"facade\", formally defined as the [*ProFacade* requirements](https://microsoft.github.io/proxy/docs/ProFacade.html), is how the \"Proxy\" library models runtime abstraction. Specifically,\n  - [`pro::facade_builder`](https://microsoft.github.io/proxy/docs/basic_facade_builder.html): Provides capability to build a facade type at compile-time.\n  - [`add_convention`](https://microsoft.github.io/proxy/docs/basic_facade_builder/add_convention.html): Adds a generalized \"calling convention\", defined by a \"dispatch\" and several \"overloads\", to the build context.\n  - [`pro::operator_dispatch`](https://microsoft.github.io/proxy/docs/operator_dispatch.html)`<\"<<\", true>`: Specifies a dispatch for operator `<<` expressions where the primary operand (`proxy`) is on the right-hand side (specified by the second template parameter `true`). Note that polymorphism in the \"Proxy\" library is defined by expressions rather than member functions, which is different from C++ virtual functions or other OOP languages.\n  - `std::ostream&(std::ostream& out) const`: The signature of the calling convention, similar with [`std::move_only_function`](https://en.cppreference.com/w/cpp/utility/functional/move_only_function). `const` specifies that the primary operand is `const`.\n  - [`build`](https://microsoft.github.io/proxy/docs/basic_facade_builder/build.html): Builds the context into a facade type.\n- [`pro::proxy`](https://microsoft.github.io/proxy/docs/proxy.html)`<Streamable> p1 = &str`: Creates a `proxy` object from a raw pointer of `std::string`. `p1` behaves like a raw pointer, and does not have ownership of the underlying `std::string`. If the lifetime of `str` ends before `p1`, `p1` becomes dangling.\n- `std::cout << *p1`: This is how it works. It prints \"Hello World\" because the calling convention is defined in the facade `Streamable`, so it works as if by calling `std::cout << str`.\n- [`pro::proxy`](https://microsoft.github.io/proxy/docs/proxy.html)`<Streamable> p2 = `[`std::make_unique`](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)`<int>(123)`: Creates a [`std::unique_ptr`](https://en.cppreference.com/w/cpp/memory/unique_ptr)`<int>` and converts to a `proxy`. Different from `p1`, `p2` has ownership of the underlying `int` because it is instantiated from a value of `std::unique_ptr`, and will call the destructor of `std::unique_ptr` when `p2` is destroyed, while `p1` does not have ownership of the underlying `int` because it is instantiated from a raw pointer. `p1` and `p2` are of the same type `pro::proxy<Streamable>`, which means you can have a function that returns `pro::proxy<Streamable>` without exposing any information about the implementation details to its caller.\n- `std::cout << *p2`: Prints \"123\" with no surprise.\n- [`pro::proxy`](https://microsoft.github.io/proxy/docs/proxy.html)`<Streamable> p3 = `[`pro::make_proxy`](https://microsoft.github.io/proxy/docs/make_proxy.html)`<Streamable>(3.14)`: Creates a `proxy` from a `double` without specifying the underlying pointer type. Specifically,\n  - Similar with `p2`, `p3` also has ownership of the underlying `double` value, but can effectively avoid heap allocation.\n  - Since the size of the underlying type (`double`) is known to be small (on major 32- or 64-bit platforms), [`pro::make_proxy`](https://microsoft.github.io/proxy/docs/make_proxy.html) realizes the fact at compile-time, and falls back to [`pro::make_proxy_inplace`](https://microsoft.github.io/proxy/docs/make_proxy_inplace.html), which guarantees no heap allocation.\n  - The \"Proxy\" library explicitly defines when heap allocation occurs or not to avoid users falling into performance hell, which is different from [`std::function`](https://en.cppreference.com/w/cpp/utility/functional/function) and other existing polymorphic wrappers in the standard.\n\n- `std::cout << *p3`: Prints \"3.14\" with no surprise.\n- When `main` returns, `p2` and `p3` will destroy the underlying objects, while `p1` does nothing because it holds a raw pointer that does not have ownership of the underlying `std::string`.\n\n### More Expressions\n\nIn addition to the operator expressions demonstrated in the previous example, the library supports almost all forms of expressions in C++ and can make them polymorphic. Specifically,\n\n- [macro `PRO_DEF_MEM_DISPATCH`](https://microsoft.github.io/proxy/docs/PRO_DEF_MEM_DISPATCH.html): Defines a dispatch type for member function call expressions.\n- [macro `PRO_DEF_FREE_DISPATCH`](https://microsoft.github.io/proxy/docs/PRO_DEF_FREE_DISPATCH.html): Defines a dispatch type for free function call expressions.\n- [class template `pro::operator_dispatch`](https://microsoft.github.io/proxy/docs/operator_dispatch.html): Dispatch type for operator expressions.\n- [class template `pro::conversion_dispatch`](https://microsoft.github.io/proxy/docs/conversion_dispatch.html): Dispatch type for conversion expressions.\n\nNote that some facilities are provided as macro, because C++ templates today do not support generating a function with an arbitrary name. Here is another example that makes member function call expressions polymorphic:\n\n```cpp\n#include <iostream>\n#include <sstream>\n\n#include \"proxy.h\"\n\nPRO_DEF_MEM_DISPATCH(MemDraw, Draw);\nPRO_DEF_MEM_DISPATCH(MemArea, Area);\n\nstruct Drawable : pro::facade_builder\n    ::add_convention<MemDraw, void(std::ostream& output)>\n    ::add_convention<MemArea, double() noexcept>\n    ::support_copy<pro::constraint_level::nontrivial>\n    ::build {};\n\nclass Rectangle {\n public:\n  Rectangle(double width, double height) : width_(width), height_(height) {}\n  Rectangle(const Rectangle&) = default;\n\n  void Draw(std::ostream& out) const {\n    out << \"{Rectangle: width = \" << width_ << \", height = \" << height_ << \"}\";\n  }\n  double Area() const noexcept { return width_ * height_; }\n\n private:\n  double width_;\n  double height_;\n};\n\nstd::string PrintDrawableToString(pro::proxy<Drawable> p) {\n  std::stringstream result;\n  result << \"entity = \";\n  p->Draw(result);\n  result << \", area = \" << p->Area();\n  return std::move(result).str();\n}\n\nint main() {\n  pro::proxy<Drawable> p = pro::make_proxy<Drawable, Rectangle>(3, 5);\n  std::string str = PrintDrawableToString(p);\n  std::cout << str << \"\\n\";  // Prints: \"entity = {Rectangle: width = 3, height = 5}, area = 15\"\n}\n```\n\nHere is a step-by-step explanation:\n\n- `#include <iostream>`: For [`std::cout`](https://en.cppreference.com/w/cpp/io/cout).\n- `#include <sstream>`: For [`std::stringstream`](https://en.cppreference.com/w/cpp/io/basic_stringstream).\n- `#include \"proxy.h\"`: For the \"Proxy\" library.\n- [`PRO_DEF_MEM_DISPATCH`](https://microsoft.github.io/proxy/docs/PRO_DEF_MEM_DISPATCH.html)`(MemDraw, Draw)`: Defines a dispatch type `MemDraw` for expressions of calling member function `Draw`.\n- [`PRO_DEF_MEM_DISPATCH`](https://microsoft.github.io/proxy/docs/PRO_DEF_MEM_DISPATCH.html)`(MemArea, Area)`: Defines a dispatch type `MemArea` for expressions of calling member function `Area`.\n- `struct Drawable : pro::facade_builder ... ::build {}`: Defines a facade type `Drawable`. Specifically,\n  - [`add_convention`](https://microsoft.github.io/proxy/docs/basic_facade_builder/add_convention.html): Adds calling conventions to the build context.\n  - [`support_copy`](https://microsoft.github.io/proxy/docs/basic_facade_builder/support_copy.html)`<`[`pro::constraint_level`](https://microsoft.github.io/proxy/docs/constraint_level.html)`::nontrivial>`: Specifies the underlying pointer type shall be copyable, which also makes the resulting `proxy` type copyable.\n- `class Rectangle`: An implementation of `Drawable`.\n- Function `PrintDrawableToString`: Converts a `Drawable` into a `std::string`. Note that this is a function rather than a function template, which means it can generate [ABI](https://en.wikipedia.org/wiki/Application_binary_interface) in a larger build system.\n- `pro::proxy<Drawable> p = pro::make_proxy<Drawable, Rectangle>(3, 5)`: Creates a `proxy<Drawable>` object containing a `Rectangle`.\n- `std::string str = PrintDrawableToString(p)`: Converts `p` into a `std::string`, implicitly creates a copy of `p`.\n- `std::cout << str`: Prints the string.\n\n### Other Useful Features\n\nThe \"Proxy\" library is a self-contained solution for runtime polymorphism in C++. There are many other capabilities documented in the [specifications](https://microsoft.github.io/proxy/docs/specifications.html). In addition to the features mentioned above, here is a curated list of the most popular features based on user feedback:\n\n- **Overloading**: [`facade_builder::add_convention`](https://microsoft.github.io/proxy/docs/basic_facade_builder/add_convention.html) is more powerful than demonstrated above. It can take any number of overload types (formally, any type meeting the [*ProOverload* requirements](https://microsoft.github.io/proxy/docs/ProOverload.html)) and perform standard overload resolution when invoking a `proxy`.\n- **Facade composition**: [`facade_builder::add_facade`](https://microsoft.github.io/proxy/docs/basic_facade_builder/add_facade.html) allows flexible composition of different abstractions.\n- **Weak dispatch**: When an object does not implement a convention, and we do not want it to trigger a hard compile error, it is allowed to define a \"weak dispatch\" with [macro `PRO_DEF_WEAK_DISPATCH`](https://microsoft.github.io/proxy/docs/PRO_DEF_WEAK_DISPATCH.html) from an existing dispatch type and a default implementation.\n- **Allocator awareness**: [function template `allocate_proxy`](https://microsoft.github.io/proxy/docs/allocate_proxy.html) is able to create a `proxy` from a value with any custom allocator. In C++11, [`std::function`](https://en.cppreference.com/w/cpp/utility/functional/function) and [`std::packaged_task`](https://en.cppreference.com/w/cpp/thread/packaged_task) had constructors that accepted custom allocators for performance tuning, but these were [removed in C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html) because \"the semantics are unclear, and there are technical issues with storing an allocator in a type-erased context and then recovering that allocator later for any allocations needed during copy assignment\". These issues do not apply to `allocate_proxy`.\n- **Configurable constraints**: [`facade_builder`](https://microsoft.github.io/proxy/docs/basic_facade_builder.html) provides full support for constraints configuration, including memory layout (by [`restrict_layout`](https://microsoft.github.io/proxy/docs/basic_facade_builder/restrict_layout.html)), copyability (by [`support_copy`](https://microsoft.github.io/proxy/docs/basic_facade_builder/support_copy.html)), relocatability (by [`support_relocation`](https://microsoft.github.io/proxy/docs/basic_facade_builder/support_relocation.html)), and destructibility (by [`support_destruction`](https://microsoft.github.io/proxy/docs/basic_facade_builder/support_destruction.html)).\n- **Reflection**: `proxy` supports type-based compile-time reflection for runtime queries. Please refer to [`facade_builder::add_reflection`](https://microsoft.github.io/proxy/docs/basic_facade_builder/add_reflection.html) and [function template `proxy_reflect`](https://microsoft.github.io/proxy/docs/proxy_reflect.html) for more details.\n\n## <a name=\"compiler-req\">Minimum Requirements for Compilers</a>\n\n| Family     | Minimum version | Required flags |\n| ---------- | --------------- | -------------- |\n| GCC        | 13.1            | -std=c++20     |\n| Clang      | 16.0.0          | -std=c++20     |\n| MSVC       | 19.31           | /std:c++20     |\n| NVIDIA HPC | 24.1            | -std=c++20     |\n\n## Build and Run Tests with CMake\n\n```\ngit clone https://github.com/microsoft/proxy.git\ncd proxy\ncmake -B build\ncmake --build build -j\nctest --test-dir build -j\n```\n\n## Related Resources\n\n- November, 2024: [Analyzing the Performance of the “Proxy” Library](https://devblogs.microsoft.com/cppblog/analyzing-the-performance-of-the-proxy-library/)\n- September, 2024: [Announcing the Proxy 3 Library for Dynamic Polymorphism](https://devblogs.microsoft.com/cppblog/announcing-the-proxy-3-library-for-dynamic-polymorphism/)\n- April, 2024: [Published ISO C++ proposal P3086R2: Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3086r2.pdf)\n- August, 2022: [proxy: Runtime Polymorphism Made Easier Than Ever](https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/)\n\n## Contributing\n\nThis project welcomes contributions and suggestions.  Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.\n\nWhen you submit a pull request, a CLA bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\nFor more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or\ncontact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n\n## Trademarks\n\nThis project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft \ntrademarks or logos is subject to and must follow \n[Microsoft's Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general).\nUse of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.\nAny use of third-party trademarks or logos are subject to those third-party's policies.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.6923828125,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\n"
        },
        {
          "name": "SUPPORT.md",
          "type": "blob",
          "size": 1.21484375,
          "content": "# TODO: The maintainer of this repo has not yet edited this file\r\n\r\n**REPO OWNER**: Do you want Customer Service & Support (CSS) support for this product/project?\r\n\r\n- **No CSS support:** Fill out this template with information about how to file issues and get help.\r\n- **Yes CSS support:** Fill out an intake form at [aka.ms/onboardsupport](https://aka.ms/onboardsupport). CSS will work with/help you to determine next steps.\r\n- **Not sure?** Fill out an intake as though the answer were \"Yes\". CSS will help you decide.\r\n\r\n*Then remove this first heading from this SUPPORT.MD file before publishing your repo.*\r\n\r\n# Support\r\n\r\n## How to file issues and get help  \r\n\r\nThis project uses GitHub Issues to track bugs and feature requests. Please search the existing \r\nissues before filing new issues to avoid duplicates.  For new issues, file your bug or \r\nfeature request as a new Issue.\r\n\r\nFor help and questions about using this project, please **REPO MAINTAINER: INSERT INSTRUCTIONS HERE \r\nFOR HOW TO ENGAGE REPO OWNERS OR COMMUNITY FOR HELP. COULD BE A STACK OVERFLOW TAG OR OTHER\r\nCHANNEL. WHERE WILL YOU HELP PEOPLE?**.\r\n\r\n## Microsoft Support Policy  \r\n\r\nSupport for this **PROJECT or PRODUCT** is limited to the resources listed above.\r\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "proxy.h",
          "type": "blob",
          "size": 88.2890625,
          "content": "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n#ifndef _MSFT_PROXY_\n#define _MSFT_PROXY_\n\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <bit>\n#include <concepts>\n#include <exception>\n#include <initializer_list>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#if __STDC_HOSTED__\n#include <format>\n#endif  // __STDC_HOSTED__\n\n#ifdef __cpp_rtti\n#include <optional>\n#include <typeinfo>\n#endif  // __cpp_rtti\n\n#if __has_cpp_attribute(msvc::no_unique_address)\n#define ___PRO_NO_UNIQUE_ADDRESS_ATTRIBUTE msvc::no_unique_address\n#elif __has_cpp_attribute(no_unique_address)\n#define ___PRO_NO_UNIQUE_ADDRESS_ATTRIBUTE no_unique_address\n#else\n#error \"Proxy requires C++20 attribute no_unique_address\"\n#endif\n\n#ifdef __cpp_exceptions\n#define ___PRO_THROW(...) throw __VA_ARGS__\n#else\n#define ___PRO_THROW(...) std::abort()\n#endif  // __cpp_exceptions\n\n#ifdef _MSC_VER\n#define ___PRO_ENFORCE_EBO __declspec(empty_bases)\n#else\n#define ___PRO_ENFORCE_EBO\n#endif  // _MSC_VER\n\n#ifdef NDEBUG\n#define ___PRO_DEBUG(...)\n#else\n#define ___PRO_DEBUG(...) __VA_ARGS__\n#endif  // NDEBUG\n\n#define __msft_lib_proxy 202410L\n\nnamespace pro {\n\nenum class constraint_level { none, nontrivial, nothrow, trivial };\n\nstruct proxiable_ptr_constraints {\n  std::size_t max_size;\n  std::size_t max_align;\n  constraint_level copyability;\n  constraint_level relocatability;\n  constraint_level destructibility;\n};\n\ntemplate <class F> struct proxy_indirect_accessor;\ntemplate <class F> class proxy;\n\nnamespace details {\n\nstruct applicable_traits { static constexpr bool applicable = true; };\nstruct inapplicable_traits { static constexpr bool applicable = false; };\n\nenum class qualifier_type { lv, const_lv, rv, const_rv };\ntemplate <class T, qualifier_type Q> struct add_qualifier_traits;\ntemplate <class T>\nstruct add_qualifier_traits<T, qualifier_type::lv> : std::type_identity<T&> {};\ntemplate <class T>\nstruct add_qualifier_traits<T, qualifier_type::const_lv>\n    : std::type_identity<const T&> {};\ntemplate <class T>\nstruct add_qualifier_traits<T, qualifier_type::rv> : std::type_identity<T&&> {};\ntemplate <class T>\nstruct add_qualifier_traits<T, qualifier_type::const_rv>\n    : std::type_identity<const T&&> {};\ntemplate <class T, qualifier_type Q>\nusing add_qualifier_t = typename add_qualifier_traits<T, Q>::type;\ntemplate <class T, qualifier_type Q>\nusing add_qualifier_ptr_t = std::remove_reference_t<add_qualifier_t<T, Q>>*;\n\ntemplate <template <class, class> class R, class O, class... Is>\nstruct recursive_reduction : std::type_identity<O> {};\ntemplate <template <class, class> class R, class O, class I, class... Is>\nstruct recursive_reduction<R, O, I, Is...>\n    : recursive_reduction<R, R<O, I>, Is...> {};\ntemplate <template <class, class> class R, class O, class... Is>\nusing recursive_reduction_t = typename recursive_reduction<R, O, Is...>::type;\n\ntemplate <class Expr>\nconsteval bool is_consteval(Expr)\n    { return requires { typename std::bool_constant<(Expr{}(), false)>; }; }\n\ntemplate <class T, std::size_t I>\nconcept has_tuple_element = requires { typename std::tuple_element_t<I, T>; };\ntemplate <class T>\nconsteval bool is_tuple_like_well_formed() {\n  if constexpr (requires { { std::tuple_size<T>::value } ->\n      std::same_as<const std::size_t&>; }) {\n    if constexpr (is_consteval([] { return std::tuple_size<T>::value; })) {\n      return []<std::size_t... I>(std::index_sequence<I...>) {\n        return (has_tuple_element<T, I> && ...);\n      }(std::make_index_sequence<std::tuple_size_v<T>>{});\n    }\n  }\n  return false;\n}\n\ntemplate <template <class...> class T, class TL, class Is, class... Args>\nstruct instantiated_traits;\ntemplate <template <class...> class T, class TL, std::size_t... Is,\n    class... Args>\nstruct instantiated_traits<T, TL, std::index_sequence<Is...>, Args...>\n    : std::type_identity<T<Args..., std::tuple_element_t<Is, TL>...>> {};\ntemplate <template <class...> class T, class TL, class... Args>\nusing instantiated_t = typename instantiated_traits<\n    T, TL, std::make_index_sequence<std::tuple_size_v<TL>>, Args...>::type;\n\ntemplate <class T>\nconsteval bool has_copyability(constraint_level level) {\n  switch (level) {\n    case constraint_level::none: return true;\n    case constraint_level::nontrivial: return std::is_copy_constructible_v<T>;\n    case constraint_level::nothrow:\n      return std::is_nothrow_copy_constructible_v<T>;\n    case constraint_level::trivial:\n      return std::is_trivially_copy_constructible_v<T> &&\n          std::is_trivially_destructible_v<T>;\n    default: return false;\n  }\n}\ntemplate <class T>\nconsteval bool has_relocatability(constraint_level level) {\n  switch (level) {\n    case constraint_level::none: return true;\n    case constraint_level::nontrivial:\n      return std::is_move_constructible_v<T> && std::is_destructible_v<T>;\n    case constraint_level::nothrow:\n      return std::is_nothrow_move_constructible_v<T> &&\n          std::is_nothrow_destructible_v<T>;\n    case constraint_level::trivial:\n      return std::is_trivially_move_constructible_v<T> &&\n          std::is_trivially_destructible_v<T>;\n    default: return false;\n  }\n}\ntemplate <class T>\nconsteval bool has_destructibility(constraint_level level) {\n  switch (level) {\n    case constraint_level::none: return true;\n    case constraint_level::nontrivial: return std::is_destructible_v<T>;\n    case constraint_level::nothrow: return std::is_nothrow_destructible_v<T>;\n    case constraint_level::trivial: return std::is_trivially_destructible_v<T>;\n    default: return false;\n  }\n}\n\ntemplate <class T>\nclass destruction_guard {\n public:\n  explicit destruction_guard(T* p) noexcept : p_(p) {}\n  destruction_guard(const destruction_guard&) = delete;\n  ~destruction_guard() noexcept(std::is_nothrow_destructible_v<T>)\n      { std::destroy_at(p_); }\n\n private:\n  T* p_;\n};\n\ntemplate <class P, qualifier_type Q, bool NE>\nstruct ptr_traits : inapplicable_traits {};\ntemplate <class P, qualifier_type Q, bool NE>\n    requires(requires { *std::declval<add_qualifier_t<P, Q>>(); } &&\n        (!NE || noexcept(*std::declval<add_qualifier_t<P, Q>>())))\nstruct ptr_traits<P, Q, NE> : applicable_traits\n    { using target_type = decltype(*std::declval<add_qualifier_t<P, Q>>()); };\n\ntemplate <class D, bool NE, class R, class... Args>\nconcept invocable_dispatch = (NE && std::is_nothrow_invocable_r_v<\n    R, D, Args...>) || (!NE && std::is_invocable_r_v<R, D, Args...>);\ntemplate <class D, class P, qualifier_type Q, bool NE, class R, class... Args>\nconcept invocable_dispatch_ptr_indirect = ptr_traits<P, Q, NE>::applicable &&\n    invocable_dispatch<\n        D, NE, R, typename ptr_traits<P, Q, NE>::target_type, Args...>;\ntemplate <class D, class P, qualifier_type Q, bool NE, class R, class... Args>\nconcept invocable_dispatch_ptr_direct = invocable_dispatch<\n    D, NE, R, add_qualifier_t<P, Q>, Args...> && (Q != qualifier_type::rv ||\n        (NE && std::is_nothrow_destructible_v<P>) ||\n        (!NE && std::is_destructible_v<P>));\n\ntemplate <bool NE, class R, class... Args>\nusing func_ptr_t = std::conditional_t<\n    NE, R (*)(Args...) noexcept, R (*)(Args...)>;\n\ntemplate <class D, class R, class... Args>\nR invoke_dispatch(Args&&... args) {\n  if constexpr (std::is_void_v<R>) {\n    D{}(std::forward<Args>(args)...);\n  } else {\n    return D{}(std::forward<Args>(args)...);\n  }\n}\ntemplate <class D, class P, qualifier_type Q, class R, class... Args>\nR indirect_conv_dispatcher(add_qualifier_t<std::byte, Q> self, Args... args)\n    noexcept(invocable_dispatch_ptr_indirect<D, P, Q, true, R, Args...>) {\n  return invoke_dispatch<D, R>(*std::forward<add_qualifier_t<P, Q>>(\n      *std::launder(reinterpret_cast<add_qualifier_ptr_t<P, Q>>(&self))),\n      std::forward<Args>(args)...);\n}\ntemplate <class D, class P, qualifier_type Q, class R, class... Args>\nR direct_conv_dispatcher(add_qualifier_t<std::byte, Q> self, Args... args)\n    noexcept(invocable_dispatch_ptr_direct<D, P, Q, true, R, Args...>) {\n  auto& qp = *std::launder(\n      reinterpret_cast<add_qualifier_ptr_t<P, Q>>(&self));\n  if constexpr (Q == qualifier_type::rv) {\n    destruction_guard guard{&qp};\n    return invoke_dispatch<D, R>(\n        std::forward<add_qualifier_t<P, Q>>(qp), std::forward<Args>(args)...);\n  } else {\n    return invoke_dispatch<D, R>(\n        std::forward<add_qualifier_t<P, Q>>(qp), std::forward<Args>(args)...);\n  }\n}\ntemplate <class D, qualifier_type Q, class R, class... Args>\nR default_conv_dispatcher(add_qualifier_t<std::byte, Q>, Args... args)\n    noexcept(invocable_dispatch<D, true, R, std::nullptr_t, Args...>)\n    { return invoke_dispatch<D, R>(nullptr, std::forward<Args>(args)...); }\ntemplate <class P>\nvoid copying_dispatcher(std::byte& self, const std::byte& rhs)\n    noexcept(has_copyability<P>(constraint_level::nothrow)) {\n  std::construct_at(reinterpret_cast<P*>(&self),\n      *std::launder(reinterpret_cast<const P*>(&rhs)));\n}\ntemplate <std::size_t Len, std::size_t Align>\nvoid copying_default_dispatcher(std::byte& self, const std::byte& rhs)\n    noexcept {\n  std::uninitialized_copy_n(\n      std::assume_aligned<Align>(&rhs), Len, std::assume_aligned<Align>(&self));\n}\ntemplate <class P>\nvoid relocation_dispatcher(std::byte& self, const std::byte& rhs)\n    noexcept(has_relocatability<P>(constraint_level::nothrow)) {\n  P* other = std::launder(reinterpret_cast<P*>(const_cast<std::byte*>(&rhs)));\n  destruction_guard guard{other};\n  std::construct_at(reinterpret_cast<P*>(&self), std::move(*other));\n}\ntemplate <class P>\nvoid destruction_dispatcher(std::byte& self)\n    noexcept(has_destructibility<P>(constraint_level::nothrow))\n    { std::destroy_at(std::launder(reinterpret_cast<P*>(&self))); }\ninline void destruction_default_dispatcher(std::byte&) noexcept {}\n\ntemplate <class O> struct overload_traits : inapplicable_traits {};\ntemplate <qualifier_type Q, bool NE, class R, class... Args>\nstruct overload_traits_impl : applicable_traits {\n  template <bool IsDirect, class D>\n  struct meta_provider {\n    template <class P>\n    static constexpr auto get()\n        -> func_ptr_t<NE, R, add_qualifier_t<std::byte, Q>, Args...> {\n      if constexpr (!IsDirect &&\n          invocable_dispatch_ptr_indirect<D, P, Q, NE, R, Args...>) {\n        return &indirect_conv_dispatcher<D, P, Q, R, Args...>;\n      } else if constexpr (IsDirect &&\n          invocable_dispatch_ptr_direct<D, P, Q, NE, R, Args...>) {\n        return &direct_conv_dispatcher<D, P, Q, R, Args...>;\n      } else if constexpr (invocable_dispatch<\n          D, NE, R, std::nullptr_t, Args...>) {\n        return &default_conv_dispatcher<D, Q, R, Args...>;\n      } else {\n        return nullptr;\n      }\n    }\n  };\n  using return_type = R;\n  using view_type = R(Args...) const noexcept(NE);\n\n  template <bool IsDirect, class D, class P>\n  static constexpr bool applicable_ptr =\n      meta_provider<IsDirect, D>::template get<P>() != nullptr;\n  static constexpr qualifier_type qualifier = Q;\n};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...)>\n    : overload_traits_impl<qualifier_type::lv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) noexcept>\n    : overload_traits_impl<qualifier_type::lv, true, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) &>\n    : overload_traits_impl<qualifier_type::lv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) & noexcept>\n    : overload_traits_impl<qualifier_type::lv, true, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) &&>\n    : overload_traits_impl<qualifier_type::rv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) && noexcept>\n    : overload_traits_impl<qualifier_type::rv, true, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const>\n    : overload_traits_impl<qualifier_type::const_lv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const noexcept>\n    : overload_traits_impl<qualifier_type::const_lv, true, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const&>\n    : overload_traits_impl<qualifier_type::const_lv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const& noexcept>\n    : overload_traits_impl<qualifier_type::const_lv, true, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const&&>\n    : overload_traits_impl<qualifier_type::const_rv, false, R, Args...> {};\ntemplate <class R, class... Args>\nstruct overload_traits<R(Args...) const&& noexcept>\n    : overload_traits_impl<qualifier_type::const_rv, true, R, Args...> {};\n\ntemplate <class MP>\nstruct dispatcher_meta {\n  constexpr dispatcher_meta() noexcept : dispatcher(nullptr) {}\n  template <class P>\n  constexpr explicit dispatcher_meta(std::in_place_type_t<P>) noexcept\n      : dispatcher(MP::template get<P>()) {}\n\n  decltype(MP::template get<void>()) dispatcher;\n};\n\ntemplate <class... Ms>\nstruct composite_meta_impl : Ms... {\n  constexpr composite_meta_impl() noexcept = default;\n  template <class P>\n  constexpr explicit composite_meta_impl(std::in_place_type_t<P>) noexcept\n      : Ms(std::in_place_type<P>)... {}\n};\ntemplate <class O, class I> struct meta_reduction : std::type_identity<O> {};\ntemplate <class... Ms, class I> requires(!std::is_void_v<I>)\nstruct meta_reduction<composite_meta_impl<Ms...>, I>\n    : std::type_identity<composite_meta_impl<Ms..., I>> {};\ntemplate <class... Ms1, class... Ms2>\nstruct meta_reduction<composite_meta_impl<Ms1...>, composite_meta_impl<Ms2...>>\n    : std::type_identity<composite_meta_impl<Ms1..., Ms2...>> {};\ntemplate <class O, class I>\nusing meta_reduction_t = typename meta_reduction<O, I>::type;\ntemplate <class... Ms>\nusing composite_meta =\n    recursive_reduction_t<meta_reduction_t, composite_meta_impl<>, Ms...>;\n\ntemplate <class T>\nconsteval bool is_is_direct_well_formed() {\n  if constexpr (requires { { T::is_direct } -> std::same_as<const bool&>; }) {\n    if constexpr (is_consteval([] { return T::is_direct; })) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntemplate <class C, class... Os>\nstruct conv_traits_impl : inapplicable_traits {};\ntemplate <class C, class... Os>\n    requires(sizeof...(Os) > 0u && (overload_traits<Os>::applicable && ...))\nstruct conv_traits_impl<C, Os...> : applicable_traits {\n  using meta = composite_meta_impl<dispatcher_meta<typename overload_traits<Os>\n      ::template meta_provider<C::is_direct, typename C::dispatch_type>>...>;\n\n  template <class P>\n  static constexpr bool applicable_ptr =\n      (overload_traits<Os>::template applicable_ptr<\n          C::is_direct, typename C::dispatch_type, P> && ...);\n};\ntemplate <class C> struct conv_traits : inapplicable_traits {};\ntemplate <class C>\n    requires(\n        requires {\n          typename C::dispatch_type;\n          typename C::overload_types;\n        } &&\n        is_is_direct_well_formed<C>() &&\n        std::is_trivial_v<typename C::dispatch_type> &&\n        is_tuple_like_well_formed<typename C::overload_types>())\nstruct conv_traits<C>\n    : instantiated_t<conv_traits_impl, typename C::overload_types, C> {};\n\ntemplate <class P>\nusing ptr_element_t = typename std::pointer_traits<P>::element_type;\ntemplate <bool IsDirect, class R>\nstruct refl_meta {\n  template <class P> requires(IsDirect)\n  constexpr explicit refl_meta(std::in_place_type_t<P>)\n      : reflector(std::in_place_type<P>) {}\n  template <class P> requires(!IsDirect)\n  constexpr explicit refl_meta(std::in_place_type_t<P>)\n      : reflector(std::in_place_type<ptr_element_t<P>>) {}\n\n  R reflector;\n};\n\ntemplate <class R, class T, bool IsDirect>\nconsteval bool is_reflector_well_formed() {\n  if constexpr (IsDirect) {\n    if constexpr (std::is_constructible_v<R, std::in_place_type_t<T>>) {\n      if constexpr (is_consteval([] { return R{std::in_place_type<T>}; })) {\n        return true;\n      }\n    }\n  } else if constexpr (requires { typename ptr_element_t<T>; }) {\n    return is_reflector_well_formed<R, ptr_element_t<T>, true>();\n  }\n  return false;\n}\ntemplate <class R> struct refl_traits : inapplicable_traits {};\ntemplate <class R>\n    requires(requires { typename R::reflector_type; } &&\n        is_is_direct_well_formed<R>())\nstruct refl_traits<R> : applicable_traits {\n  using meta = refl_meta<R::is_direct, typename R::reflector_type>;\n\n  template <class P>\n  static constexpr bool applicable_ptr =\n      is_reflector_well_formed<typename R::reflector_type, P, R::is_direct>();\n};\n\ntemplate <bool NE>\nstruct copyability_meta_provider {\n  template <class P>\n  static constexpr func_ptr_t<NE, void, std::byte&, const std::byte&> get() {\n    if constexpr (has_copyability<P>(constraint_level::trivial)) {\n      return &copying_default_dispatcher<sizeof(P), alignof(P)>;\n    } else {\n      return &copying_dispatcher<P>;\n    }\n  }\n};\ntemplate <bool NE>\nstruct relocatability_meta_provider {\n  template <class P>\n  static constexpr func_ptr_t<NE, void, std::byte&, const std::byte&> get() {\n    if constexpr (has_relocatability<P>(constraint_level::trivial)) {\n      return &copying_default_dispatcher<sizeof(P), alignof(P)>;\n    } else {\n      return &relocation_dispatcher<P>;\n    }\n  }\n};\ntemplate <bool NE>\nstruct destructibility_meta_provider {\n  template <class P>\n  static constexpr func_ptr_t<NE, void, std::byte&> get() {\n    if constexpr (has_destructibility<P>(constraint_level::trivial)) {\n      return &destruction_default_dispatcher;\n    } else {\n      return &destruction_dispatcher<P>;\n    }\n  }\n};\ntemplate <template <bool> class MP, constraint_level C>\nstruct lifetime_meta_traits : std::type_identity<void> {};\ntemplate <template <bool> class MP>\nstruct lifetime_meta_traits<MP, constraint_level::nothrow>\n    : std::type_identity<dispatcher_meta<MP<true>>> {};\ntemplate <template <bool> class MP>\nstruct lifetime_meta_traits<MP, constraint_level::nontrivial>\n    : std::type_identity<dispatcher_meta<MP<false>>> {};\ntemplate <template <bool> class MP, constraint_level C>\nusing lifetime_meta_t = typename lifetime_meta_traits<MP, C>::type;\n\ntemplate <class... As>\nclass ___PRO_ENFORCE_EBO composite_accessor_impl : public As... {\n  template <class> friend class pro::proxy;\n  template <class F> friend struct pro::proxy_indirect_accessor;\n\n  composite_accessor_impl() noexcept = default;\n  composite_accessor_impl(const composite_accessor_impl&) noexcept = default;\n  composite_accessor_impl& operator=(const composite_accessor_impl&) noexcept\n      = default;\n};\n\ntemplate <class T>\nstruct accessor_traits_impl : std::type_identity<void> {};\ntemplate <class T>\n    requires(std::is_nothrow_default_constructible_v<T> &&\n        std::is_trivially_copyable_v<T> && !std::is_final_v<T>)\nstruct accessor_traits_impl<T> : std::type_identity<T> {};\ntemplate <class SFINAE, class T, class F>\nstruct accessor_traits : std::type_identity<void> {};\ntemplate <class T, class F>\nstruct accessor_traits<std::void_t<typename T::template accessor<F>>, T, F>\n    : accessor_traits_impl<typename T::template accessor<F>> {};\ntemplate <class T, class F>\nusing accessor_t = typename accessor_traits<void, T, F>::type;\n\ntemplate <bool IsDirect, class F, class O, class I>\nstruct composite_accessor_reduction : std::type_identity<O> {};\ntemplate <bool IsDirect, class F, class... As, class I>\n    requires(IsDirect == I::is_direct && !std::is_void_v<accessor_t<I, F>>)\nstruct composite_accessor_reduction<\n    IsDirect, F, composite_accessor_impl<As...>, I>\n    : std::type_identity<composite_accessor_impl<As..., accessor_t<I, F>>> {};\ntemplate <bool IsDirect, class F>\nstruct composite_accessor_helper {\n  template <class O, class I>\n  using reduction_t =\n      typename composite_accessor_reduction<IsDirect, F, O, I>::type;\n};\ntemplate <bool IsDirect, class F, class... Ts>\nusing composite_accessor = recursive_reduction_t<\n      composite_accessor_helper<IsDirect, F>::template reduction_t,\n      composite_accessor_impl<>, Ts...>;\n\ntemplate <class A1, class A2> struct composite_accessor_merge_traits;\ntemplate <class... A1, class... A2>\nstruct composite_accessor_merge_traits<\n    composite_accessor_impl<A1...>, composite_accessor_impl<A2...>>\n    : std::type_identity<composite_accessor_impl<A1..., A2...>> {};\ntemplate <class A1, class A2>\nusing merged_composite_accessor =\n    typename composite_accessor_merge_traits<A1, A2>::type;\n\ntemplate <class T> struct in_place_type_traits : inapplicable_traits {};\ntemplate <class T>\nstruct in_place_type_traits<std::in_place_type_t<T>> : applicable_traits {};\ntemplate <class T>\nconstexpr bool is_in_place_type = in_place_type_traits<T>::applicable;\n\ntemplate <class F>\nconsteval bool is_facade_constraints_well_formed() {\n  if constexpr (requires {\n      { F::constraints } -> std::same_as<const proxiable_ptr_constraints&>; }) {\n    if constexpr (is_consteval([] { return F::constraints; })) {\n      return std::has_single_bit(F::constraints.max_align) &&\n          F::constraints.max_size % F::constraints.max_align == 0u;\n    }\n  }\n  return false;\n}\ntemplate <class F, class... Cs>\nstruct facade_conv_traits_impl : inapplicable_traits {};\ntemplate <class F, class... Cs> requires(conv_traits<Cs>::applicable && ...)\nstruct facade_conv_traits_impl<F, Cs...> : applicable_traits {\n  using conv_meta = composite_meta<typename conv_traits<Cs>::meta...>;\n  using conv_indirect_accessor = composite_accessor<false, F, Cs...>;\n  using conv_direct_accessor = composite_accessor<true, F, Cs...>;\n\n  template <class P>\n  static constexpr bool conv_applicable_ptr =\n      (conv_traits<Cs>::template applicable_ptr<P> && ...);\n  template <bool IsDirect, class D, class O>\n  static constexpr bool is_invocable = std::is_base_of_v<dispatcher_meta<\n      typename overload_traits<O>::template meta_provider<IsDirect, D>>,\n      conv_meta>;\n};\ntemplate <class F, class... Rs>\nstruct facade_refl_traits_impl : inapplicable_traits {};\ntemplate <class F, class... Rs> requires(refl_traits<Rs>::applicable && ...)\nstruct facade_refl_traits_impl<F, Rs...> : applicable_traits {\n  using refl_meta = composite_meta<typename refl_traits<Rs>::meta...>;\n  using refl_indirect_accessor = composite_accessor<false, F, Rs...>;\n  using refl_direct_accessor = composite_accessor<true, F, Rs...>;\n\n  template <class P>\n  static constexpr bool refl_applicable_ptr =\n      (refl_traits<Rs>::template applicable_ptr<P> && ...);\n};\ntemplate <class F> struct facade_traits : inapplicable_traits {};\ntemplate <class F>\n    requires(\n        requires {\n          typename F::convention_types;\n          typename F::reflection_types;\n        } &&\n        is_facade_constraints_well_formed<F>() &&\n        is_tuple_like_well_formed<typename F::convention_types>() &&\n        instantiated_t<facade_conv_traits_impl, typename F::convention_types, F>\n            ::applicable &&\n        is_tuple_like_well_formed<typename F::reflection_types>() &&\n        instantiated_t<facade_refl_traits_impl, typename F::reflection_types, F>\n            ::applicable)\nstruct facade_traits<F>\n    : instantiated_t<facade_conv_traits_impl, typename F::convention_types, F>,\n      instantiated_t<facade_refl_traits_impl, typename F::reflection_types, F> {\n  using copyability_meta = lifetime_meta_t<\n      copyability_meta_provider, F::constraints.copyability>;\n  using relocatability_meta = lifetime_meta_t<\n      relocatability_meta_provider,\n      F::constraints.copyability == constraint_level::trivial ?\n          constraint_level::trivial : F::constraints.relocatability>;\n  using destructibility_meta = lifetime_meta_t<\n      destructibility_meta_provider, F::constraints.destructibility>;\n  using meta = composite_meta<copyability_meta, relocatability_meta,\n      destructibility_meta, typename facade_traits::conv_meta,\n      typename facade_traits::refl_meta>;\n  using indirect_accessor = merged_composite_accessor<\n      typename facade_traits::conv_indirect_accessor,\n      typename facade_traits::refl_indirect_accessor>;\n  using direct_accessor = merged_composite_accessor<\n      typename facade_traits::conv_direct_accessor,\n      typename facade_traits::refl_direct_accessor>;\n};\n\nusing ptr_prototype = void*[2];\n\ntemplate <class M>\nstruct meta_ptr_indirect_impl {\n  constexpr meta_ptr_indirect_impl() noexcept : ptr_(nullptr) {};\n  template <class P>\n  constexpr explicit meta_ptr_indirect_impl(std::in_place_type_t<P>) noexcept\n      : ptr_(&storage<P>) {}\n  bool has_value() const noexcept { return ptr_ != nullptr; }\n  void reset() noexcept { ptr_ = nullptr; }\n  const M* operator->() const noexcept { return ptr_; }\n\n private:\n  const M* ptr_;\n  template <class P> static constexpr M storage{std::in_place_type<P>};\n};\ntemplate <class M, class DM>\nstruct meta_ptr_direct_impl : private M {\n  using M::M;\n  bool has_value() const noexcept { return this->DM::dispatcher != nullptr; }\n  void reset() noexcept { this->DM::dispatcher = nullptr; }\n  const M* operator->() const noexcept { return this; }\n};\ntemplate <class M>\nstruct meta_ptr_traits_impl : std::type_identity<meta_ptr_indirect_impl<M>> {};\ntemplate <class MP, class... Ms>\nstruct meta_ptr_traits_impl<composite_meta_impl<dispatcher_meta<MP>, Ms...>>\n    : std::type_identity<meta_ptr_direct_impl<composite_meta_impl<\n          dispatcher_meta<MP>, Ms...>, dispatcher_meta<MP>>> {};\ntemplate <class M>\nstruct meta_ptr_traits : std::type_identity<meta_ptr_indirect_impl<M>> {};\ntemplate <class M>\n    requires(sizeof(M) <= sizeof(ptr_prototype) &&\n        alignof(M) <= alignof(ptr_prototype) &&\n        std::is_nothrow_default_constructible_v<M> &&\n        std::is_trivially_copyable_v<M>)\nstruct meta_ptr_traits<M> : meta_ptr_traits_impl<M> {};\ntemplate <class M>\nusing meta_ptr = typename meta_ptr_traits<M>::type;\n\ntemplate <class MP>\nstruct meta_ptr_reset_guard {\n public:\n  explicit meta_ptr_reset_guard(MP& meta) noexcept : meta_(meta) {}\n  meta_ptr_reset_guard(const meta_ptr_reset_guard&) = delete;\n  ~meta_ptr_reset_guard() { meta_.reset(); }\n\n private:\n  MP& meta_;\n};\n\ntemplate <class F>\nstruct proxy_helper {\n  static inline const auto& get_meta(const proxy<F>& p) noexcept {\n    assert(p.has_value());\n    return *p.meta_.operator->();\n  }\n  template <bool IsDirect, class D, class O, qualifier_type Q, class... Args>\n  static decltype(auto) invoke(add_qualifier_t<proxy<F>, Q> p, Args&&... args) {\n    auto dispatcher = get_meta(p)\n        .template dispatcher_meta<typename overload_traits<O>\n        ::template meta_provider<IsDirect, D>>::dispatcher;\n    if constexpr (\n        IsDirect && overload_traits<O>::qualifier == qualifier_type::rv) {\n      meta_ptr_reset_guard guard{p.meta_};\n      return dispatcher(std::forward<add_qualifier_t<std::byte, Q>>(*p.ptr_),\n          std::forward<Args>(args)...);\n    } else {\n      return dispatcher(std::forward<add_qualifier_t<std::byte, Q>>(*p.ptr_),\n          std::forward<Args>(args)...);\n    }\n  }\n  template <class A, qualifier_type Q>\n  static add_qualifier_t<proxy<F>, Q> access(add_qualifier_t<A, Q> a) {\n    if constexpr (std::is_base_of_v<A, proxy<F>>) {\n      return static_cast<add_qualifier_t<proxy<F>, Q>>(\n          std::forward<add_qualifier_t<A, Q>>(a));\n    } else {\n      // Note: The use of offsetof below is technically undefined until C++20\n      // because proxy may not be a standard layout type. However, all compilers\n      // currently provide well-defined behavior as an extension (which is\n      // demonstrated since constexpr evaluation must diagnose all undefined\n      // behavior). However, various compilers also warn about this use of\n      // offsetof, which must be suppressed.\n#if defined(__INTEL_COMPILER)\n#pragma warning push\n#pragma warning(disable : 1875)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif  // defined(__INTEL_COMPILER)\n#if defined(__NVCC__)\n#pragma nv_diagnostic push\n#pragma nv_diag_suppress 1427\n#endif  // defined(__NVCC__)\n#if defined(__NVCOMPILER)\n#pragma diagnostic push\n#pragma diag_suppress offset_in_non_POD_nonstandard\n#endif  // defined(__NVCOMPILER)\n      constexpr std::size_t offset = offsetof(proxy<F>, ia_);\n#if defined(__INTEL_COMPILER)\n#pragma warning pop\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif  // defined(__INTEL_COMPILER)\n#if defined(__NVCC__)\n#pragma nv_diagnostic pop\n#endif  // defined(__NVCC__)\n#if defined(__NVCOMPILER)\n#pragma diagnostic pop\n#endif  // defined(__NVCOMPILER)\n      return reinterpret_cast<add_qualifier_t<proxy<F>, Q>>(\n          *(reinterpret_cast<add_qualifier_ptr_t<std::byte, Q>>(\n              static_cast<add_qualifier_ptr_t<proxy_indirect_accessor<F>, Q>>(\n                  std::addressof(a))) - offset));\n    }\n  }\n};\n\n}  // namespace details\n\ntemplate <class F>\nconcept facade = details::facade_traits<F>::applicable;\n\ntemplate <class P, class F>\nconcept proxiable = facade<F> && sizeof(P) <= F::constraints.max_size &&\n    alignof(P) <= F::constraints.max_align &&\n    details::has_copyability<P>(F::constraints.copyability) &&\n    details::has_relocatability<P>(F::constraints.relocatability) &&\n    details::has_destructibility<P>(F::constraints.destructibility) &&\n    details::facade_traits<F>::template conv_applicable_ptr<P> &&\n    details::facade_traits<F>::template refl_applicable_ptr<P>;\n\ntemplate <class F> struct proxy_indirect_accessor {};\ntemplate <class F> requires(!std::is_same_v<typename details::facade_traits<F>\n    ::indirect_accessor, details::composite_accessor_impl<>>)\nstruct proxy_indirect_accessor<F>\n    : details::facade_traits<F>::indirect_accessor {};\n\ntemplate <class F>\nclass proxy : public details::facade_traits<F>::direct_accessor {\n  static_assert(facade<F>);\n  friend struct details::proxy_helper<F>;\n  using _Traits = details::facade_traits<F>;\n\n public:\n  proxy() noexcept {\n    ___PRO_DEBUG(\n      std::ignore = static_cast<proxy_indirect_accessor<F>*\n          (proxy::*)() noexcept>(&proxy::operator->);\n      std::ignore = static_cast<const proxy_indirect_accessor<F>*\n          (proxy::*)() const noexcept>(&proxy::operator->);\n      std::ignore = static_cast<proxy_indirect_accessor<F>&\n          (proxy::*)() & noexcept>(&proxy::operator*);\n      std::ignore = static_cast<const proxy_indirect_accessor<F>&\n          (proxy::*)() const& noexcept>(&proxy::operator*);\n      std::ignore = static_cast<proxy_indirect_accessor<F>&&\n          (proxy::*)() && noexcept>(&proxy::operator*);\n      std::ignore = static_cast<const proxy_indirect_accessor<F>&&\n          (proxy::*)() const&& noexcept>(&proxy::operator*);\n    )\n  }\n  proxy(std::nullptr_t) noexcept : proxy() {}\n  proxy(const proxy&) noexcept requires(F::constraints.copyability ==\n      constraint_level::trivial) = default;\n  proxy(const proxy& rhs)\n      noexcept(F::constraints.copyability == constraint_level::nothrow)\n      requires(F::constraints.copyability == constraint_level::nontrivial ||\n          F::constraints.copyability == constraint_level::nothrow) {\n    if (rhs.meta_.has_value()) {\n      rhs.meta_->_Traits::copyability_meta::dispatcher(*ptr_, *rhs.ptr_);\n      meta_ = rhs.meta_;\n    }\n  }\n  proxy(proxy&& rhs)\n      noexcept(F::constraints.relocatability == constraint_level::nothrow)\n      requires(F::constraints.relocatability >= constraint_level::nontrivial &&\n          F::constraints.copyability != constraint_level::trivial) {\n    if (rhs.meta_.has_value()) {\n      details::meta_ptr_reset_guard guard{rhs.meta_};\n      if constexpr (F::constraints.relocatability ==\n          constraint_level::trivial) {\n        std::ranges::uninitialized_copy(rhs.ptr_, ptr_);\n      } else {\n        rhs.meta_->_Traits::relocatability_meta::dispatcher(*ptr_, *rhs.ptr_);\n      }\n      meta_ = rhs.meta_;\n    }\n  }\n  template <class P>\n  proxy(P&& ptr) noexcept(std::is_nothrow_constructible_v<std::decay_t<P>, P>)\n      requires(!details::is_in_place_type<std::decay_t<P>> &&\n          proxiable<std::decay_t<P>, F> &&\n          std::is_constructible_v<std::decay_t<P>, P>)\n      : proxy() { initialize<std::decay_t<P>>(std::forward<P>(ptr)); }\n  template <proxiable<F> P, class... Args>\n  explicit proxy(std::in_place_type_t<P>, Args&&... args)\n      noexcept(std::is_nothrow_constructible_v<P, Args...>)\n      requires(std::is_constructible_v<P, Args...>)\n      : proxy() { initialize<P>(std::forward<Args>(args)...); }\n  template <proxiable<F> P, class U, class... Args>\n  explicit proxy(std::in_place_type_t<P>, std::initializer_list<U> il,\n          Args&&... args)\n      noexcept(std::is_nothrow_constructible_v<\n          P, std::initializer_list<U>&, Args...>)\n      requires(std::is_constructible_v<P, std::initializer_list<U>&, Args...>)\n      : proxy() { initialize<P>(il, std::forward<Args>(args)...); }\n  proxy& operator=(std::nullptr_t)\n      noexcept(F::constraints.destructibility >= constraint_level::nothrow)\n      requires(F::constraints.destructibility >= constraint_level::nontrivial)\n      { reset(); return *this; }\n  proxy& operator=(const proxy&) noexcept requires(F::constraints.copyability ==\n      constraint_level::trivial) = default;\n  proxy& operator=(const proxy& rhs)\n      noexcept(F::constraints.copyability >= constraint_level::nothrow &&\n          F::constraints.destructibility >= constraint_level::nothrow)\n      requires((F::constraints.copyability == constraint_level::nontrivial ||\n          F::constraints.copyability == constraint_level::nothrow) &&\n          F::constraints.destructibility >= constraint_level::nontrivial) {\n    if (this != &rhs) {\n      if constexpr (F::constraints.copyability == constraint_level::nothrow) {\n        std::destroy_at(this);\n        std::construct_at(this, rhs);\n      } else {\n        *this = proxy{rhs};\n      }\n    }\n    return *this;\n  }\n  proxy& operator=(proxy&& rhs)\n      noexcept(F::constraints.relocatability >= constraint_level::nothrow &&\n          F::constraints.destructibility >= constraint_level::nothrow)\n      requires(F::constraints.relocatability >= constraint_level::nontrivial &&\n          F::constraints.destructibility >= constraint_level::nontrivial &&\n          F::constraints.copyability != constraint_level::trivial) {\n    if (this != &rhs) {\n      reset();\n      std::construct_at(this, std::move(rhs));\n    }\n    return *this;\n  }\n  template <class P>\n  proxy& operator=(P&& ptr)\n      noexcept(std::is_nothrow_constructible_v<std::decay_t<P>, P> &&\n          F::constraints.destructibility >= constraint_level::nothrow)\n      requires(proxiable<std::decay_t<P>, F> &&\n          std::is_constructible_v<std::decay_t<P>, P> &&\n          F::constraints.destructibility >= constraint_level::nontrivial) {\n    if constexpr (std::is_nothrow_constructible_v<std::decay_t<P>, P>) {\n      std::destroy_at(this);\n      initialize<std::decay_t<P>>(std::forward<P>(ptr));\n    } else {\n      *this = proxy{std::forward<P>(ptr)};\n    }\n    return *this;\n  }\n  ~proxy() requires(F::constraints.destructibility == constraint_level::trivial)\n      = default;\n  ~proxy() noexcept(F::constraints.destructibility == constraint_level::nothrow)\n      requires(F::constraints.destructibility == constraint_level::nontrivial ||\n          F::constraints.destructibility == constraint_level::nothrow) {\n    if (meta_.has_value()) {\n      meta_->_Traits::destructibility_meta::dispatcher(*ptr_);\n    }\n  }\n\n  bool has_value() const noexcept { return meta_.has_value(); }\n  explicit operator bool() const noexcept { return meta_.has_value(); }\n  void reset()\n      noexcept(F::constraints.destructibility >= constraint_level::nothrow)\n      requires(F::constraints.destructibility >= constraint_level::nontrivial)\n      { std::destroy_at(this); meta_.reset(); }\n  void swap(proxy& rhs)\n      noexcept(F::constraints.relocatability >= constraint_level::nothrow ||\n          F::constraints.copyability == constraint_level::trivial)\n      requires(F::constraints.relocatability >= constraint_level::nontrivial ||\n          F::constraints.copyability == constraint_level::trivial) {\n    if constexpr (F::constraints.relocatability == constraint_level::trivial ||\n        F::constraints.copyability == constraint_level::trivial) {\n      std::swap(meta_, rhs.meta_);\n      std::swap(ptr_, rhs.ptr);\n    } else {\n      if (meta_.has_value()) {\n        if (rhs.meta_.has_value()) {\n          proxy temp = std::move(*this);\n          std::construct_at(this, std::move(rhs));\n          std::construct_at(&rhs, std::move(temp));\n        } else {\n          std::construct_at(&rhs, std::move(*this));\n        }\n      } else if (rhs.meta_.has_value()) {\n        std::construct_at(this, std::move(rhs));\n      }\n    }\n  }\n  template <proxiable<F> P, class... Args>\n  P& emplace(Args&&... args)\n      noexcept(std::is_nothrow_constructible_v<P, Args...> &&\n          F::constraints.destructibility >= constraint_level::nothrow)\n      requires(std::is_constructible_v<P, Args...> &&\n          F::constraints.destructibility >= constraint_level::nontrivial)\n      { reset(); return initialize<P>(std::forward<Args>(args)...); }\n  template <proxiable<F> P, class U, class... Args>\n  P& emplace(std::initializer_list<U> il, Args&&... args)\n      noexcept(std::is_nothrow_constructible_v<\n          P, std::initializer_list<U>&, Args...> &&\n          F::constraints.destructibility >= constraint_level::nothrow)\n      requires(std::is_constructible_v<P, std::initializer_list<U>&, Args...> &&\n          F::constraints.destructibility >= constraint_level::nontrivial)\n      { reset(); return initialize<P>(il, std::forward<Args>(args)...); }\n  proxy_indirect_accessor<F>* operator->() noexcept\n      { return std::addressof(ia_); }\n  const proxy_indirect_accessor<F>* operator->() const noexcept\n      { return std::addressof(ia_); }\n  proxy_indirect_accessor<F>& operator*() & noexcept { return ia_; }\n  const proxy_indirect_accessor<F>& operator*() const& noexcept { return ia_; }\n  proxy_indirect_accessor<F>&& operator*() && noexcept\n      { return std::move(ia_); }\n  const proxy_indirect_accessor<F>&& operator*() const&& noexcept\n      { return std::forward<const proxy_indirect_accessor<F>>(ia_); }\n\n  friend void swap(proxy& lhs, proxy& rhs) noexcept(noexcept(lhs.swap(rhs)))\n      { lhs.swap(rhs); }\n  friend bool operator==(const proxy& lhs, std::nullptr_t) noexcept\n      { return !lhs.has_value(); }\n\n private:\n  template <class P, class... Args>\n  P& initialize(Args&&... args) {\n    P& result = *std::construct_at(\n        reinterpret_cast<P*>(ptr_), std::forward<Args>(args)...);\n    if constexpr (requires { (bool)result; })\n        { assert((bool)result); }\n    meta_ = details::meta_ptr<typename _Traits::meta>{std::in_place_type<P>};\n    return result;\n  }\n\n  [[___PRO_NO_UNIQUE_ADDRESS_ATTRIBUTE]]\n  proxy_indirect_accessor<F> ia_;\n  details::meta_ptr<typename _Traits::meta> meta_;\n  alignas(F::constraints.max_align) std::byte ptr_[F::constraints.max_size];\n};\n\ntemplate <bool IsDirect, class D, class O, class F, class... Args>\nauto proxy_invoke(proxy<F>& p, Args&&... args)\n    -> typename details::overload_traits<O>::return_type {\n  return details::proxy_helper<F>::template invoke<IsDirect, D, O,\n      details::qualifier_type::lv>(p, std::forward<Args>(args)...);\n}\ntemplate <bool IsDirect, class D, class O, class F, class... Args>\nauto proxy_invoke(const proxy<F>& p, Args&&... args)\n    -> typename details::overload_traits<O>::return_type {\n  return details::proxy_helper<F>::template invoke<IsDirect, D, O,\n      details::qualifier_type::const_lv>(p, std::forward<Args>(args)...);\n}\ntemplate <bool IsDirect, class D, class O, class F, class... Args>\nauto proxy_invoke(proxy<F>&& p, Args&&... args)\n    -> typename details::overload_traits<O>::return_type {\n  return details::proxy_helper<F>::template invoke<\n      IsDirect, D, O, details::qualifier_type::rv>(\n      std::move(p), std::forward<Args>(args)...);\n}\ntemplate <bool IsDirect, class D, class O, class F, class... Args>\nauto proxy_invoke(const proxy<F>&& p, Args&&... args)\n    -> typename details::overload_traits<O>::return_type {\n  return details::proxy_helper<F>::template invoke<\n      IsDirect, D, O, details::qualifier_type::const_rv>(\n      std::move(p), std::forward<Args>(args)...);\n}\n\ntemplate <bool IsDirect, class R, class F>\nconst R& proxy_reflect(const proxy<F>& p) noexcept {\n  return static_cast<const details::refl_meta<IsDirect, R>&>(\n      details::proxy_helper<F>::get_meta(p)).reflector;\n}\n\ntemplate <class F, class A>\nproxy<F>& access_proxy(A& a) noexcept {\n  return details::proxy_helper<F>::template access<\n      A, details::qualifier_type::lv>(a);\n}\ntemplate <class F, class A>\nconst proxy<F>& access_proxy(const A& a) noexcept {\n  return details::proxy_helper<F>::template access<\n      A, details::qualifier_type::const_lv>(a);\n}\ntemplate <class F, class A>\nproxy<F>&& access_proxy(A&& a) noexcept {\n  return details::proxy_helper<F>::template access<\n      A, details::qualifier_type::rv>(std::forward<A>(a));\n}\ntemplate <class F, class A>\nconst proxy<F>&& access_proxy(const A&& a) noexcept {\n  return details::proxy_helper<F>::template access<\n      A, details::qualifier_type::const_rv>(std::forward<const A>(a));\n}\n\nnamespace details {\n\ntemplate <class T>\nclass inplace_ptr {\n public:\n  template <class... Args>\n  inplace_ptr(Args&&... args)\n      noexcept(std::is_nothrow_constructible_v<T, Args...>)\n      requires(std::is_constructible_v<T, Args...>)\n      : value_(std::forward<Args>(args)...) {}\n  inplace_ptr(const inplace_ptr&)\n      noexcept(std::is_nothrow_copy_constructible_v<T>) = default;\n  inplace_ptr(inplace_ptr&&)\n      noexcept(std::is_nothrow_move_constructible_v<T>) = default;\n\n  T* operator->() noexcept { return &value_; }\n  const T* operator->() const noexcept { return &value_; }\n  T& operator*() & noexcept { return value_; }\n  const T& operator*() const& noexcept { return value_; }\n  T&& operator*() && noexcept { return std::forward<T>(value_); }\n  const T&& operator*() const&& noexcept\n      { return std::forward<const T>(value_); }\n\n private:\n  T value_;\n};\n\n#if __STDC_HOSTED__\ntemplate <class T, class Alloc>\nstatic auto rebind_allocator(const Alloc& alloc) {\n  return typename std::allocator_traits<Alloc>::template rebind_alloc<T>(alloc);\n}\ntemplate <class T, class Alloc, class... Args>\nstatic T* allocate(const Alloc& alloc, Args&&... args) {\n  auto al = rebind_allocator<T>(alloc);\n  auto deleter = [&](T* ptr) { al.deallocate(ptr, 1); };\n  std::unique_ptr<T, decltype(deleter)> result{al.allocate(1), deleter};\n  std::construct_at(result.get(), std::forward<Args>(args)...);\n  return result.release();\n}\ntemplate <class Alloc, class T>\nstatic void deallocate(const Alloc& alloc, T* ptr) {\n  auto al = rebind_allocator<T>(alloc);\n  std::destroy_at(ptr);\n  al.deallocate(ptr, 1);\n}\n\ntemplate <class T, class Alloc>\nclass allocated_ptr {\n public:\n  template <class... Args>\n  allocated_ptr(const Alloc& alloc, Args&&... args)\n      requires(std::is_constructible_v<T, Args...>)\n      : alloc_(alloc), ptr_(allocate<T>(alloc, std::forward<Args>(args)...)) {}\n  allocated_ptr(const allocated_ptr& rhs)\n      requires(std::is_copy_constructible_v<T>)\n      : alloc_(rhs.alloc_), ptr_(rhs.ptr_ == nullptr ? nullptr :\n            allocate<T>(alloc_, std::as_const(*rhs.ptr_))) {}\n  allocated_ptr(allocated_ptr&& rhs)\n      noexcept(std::is_nothrow_move_constructible_v<Alloc>)\n      : alloc_(std::move(rhs.alloc_)), ptr_(std::exchange(rhs.ptr_, nullptr)) {}\n  ~allocated_ptr() { if (ptr_ != nullptr) { deallocate(alloc_, ptr_); } }\n\n  T* operator->() noexcept { return ptr_; }\n  const T* operator->() const noexcept { return ptr_; }\n  T& operator*() & noexcept { return *ptr_; }\n  const T& operator*() const& noexcept { return *ptr_; }\n  T&& operator*() && noexcept { return std::forward<T>(*ptr_); }\n  const T&& operator*() const&& noexcept\n      { return std::forward<const T>(*ptr_); }\n\n private:\n  [[___PRO_NO_UNIQUE_ADDRESS_ATTRIBUTE]]\n  Alloc alloc_;\n  T* ptr_;\n};\ntemplate <class T, class Alloc>\nclass compact_ptr {\n public:\n  template <class... Args>\n  compact_ptr(const Alloc& alloc, Args&&... args)\n      requires(std::is_constructible_v<T, Args...>)\n      : ptr_(allocate<storage>(alloc, alloc, std::forward<Args>(args)...)) {}\n  compact_ptr(const compact_ptr& rhs) requires(std::is_copy_constructible_v<T>)\n      : ptr_(rhs.ptr_ == nullptr ? nullptr : allocate<storage>(rhs.ptr_->alloc,\n            rhs.ptr_->alloc, std::as_const(rhs.ptr_->value))) {}\n  compact_ptr(compact_ptr&& rhs) noexcept\n      : ptr_(std::exchange(rhs.ptr_, nullptr)) {}\n  ~compact_ptr() { if (ptr_ != nullptr) { deallocate(ptr_->alloc, ptr_); } }\n\n  T* operator->() noexcept { return &ptr_->value; }\n  const T* operator->() const noexcept { return &ptr_->value; }\n  T& operator*() & noexcept { return ptr_->value; }\n  const T& operator*() const& noexcept { return ptr_->value; }\n  T&& operator*() && noexcept { return std::forward<T>(ptr_->value); }\n  const T&& operator*() const&& noexcept\n      { return std::forward<const T>(ptr_->value); }\n\n private:\n  struct storage {\n    template <class... Args>\n    explicit storage(const Alloc& alloc, Args&&... args)\n        : value(std::forward<Args>(args)...), alloc(alloc) {}\n\n    T value;\n    Alloc alloc;\n  };\n\n  storage* ptr_;\n};\ntemplate <class F, class T, class Alloc, class... Args>\nproxy<F> allocate_proxy_impl(const Alloc& alloc, Args&&... args) {\n  if constexpr (proxiable<allocated_ptr<T, Alloc>, F>) {\n    return proxy<F>{std::in_place_type<allocated_ptr<T, Alloc>>,\n        alloc, std::forward<Args>(args)...};\n  } else {\n    return proxy<F>{std::in_place_type<compact_ptr<T, Alloc>>,\n        alloc, std::forward<Args>(args)...};\n  }\n}\ntemplate <class F, class T, class... Args>\nproxy<F> make_proxy_impl(Args&&... args) {\n  if constexpr (proxiable<inplace_ptr<T>, F>) {\n    return proxy<F>{std::in_place_type<inplace_ptr<T>>,\n        std::forward<Args>(args)...};\n  } else {\n    return allocate_proxy_impl<F, T>(\n        std::allocator<T>{}, std::forward<Args>(args)...);\n  }\n}\n#endif  // __STDC_HOSTED__\n\n}  // namespace details\n\ntemplate <class T, class F>\nconcept inplace_proxiable_target = proxiable<details::inplace_ptr<T>, F>;\n\ntemplate <facade F, inplace_proxiable_target<F> T, class... Args>\nproxy<F> make_proxy_inplace(Args&&... args)\n    noexcept(std::is_nothrow_constructible_v<T, Args...>) {\n  return proxy<F>{std::in_place_type<details::inplace_ptr<T>>,\n      std::forward<Args>(args)...};\n}\ntemplate <facade F, inplace_proxiable_target<F> T, class U, class... Args>\nproxy<F> make_proxy_inplace(std::initializer_list<U> il, Args&&... args)\n    noexcept(std::is_nothrow_constructible_v<\n        T, std::initializer_list<U>&, Args...>) {\n  return proxy<F>{std::in_place_type<details::inplace_ptr<T>>,\n      il, std::forward<Args>(args)...};\n}\ntemplate <facade F, class T>\nproxy<F> make_proxy_inplace(T&& value)\n    noexcept(std::is_nothrow_constructible_v<std::decay_t<T>, T>)\n    requires(inplace_proxiable_target<std::decay_t<T>, F>) {\n  return proxy<F>{std::in_place_type<details::inplace_ptr<std::decay_t<T>>>,\n      std::forward<T>(value)};\n}\n\n#if __STDC_HOSTED__\ntemplate <facade F, class T, class Alloc, class... Args>\nproxy<F> allocate_proxy(const Alloc& alloc, Args&&... args) {\n  return details::allocate_proxy_impl<F, T>(alloc, std::forward<Args>(args)...);\n}\ntemplate <facade F, class T, class Alloc, class U,\n    class... Args>\nproxy<F> allocate_proxy(const Alloc& alloc, std::initializer_list<U> il,\n    Args&&... args) {\n  return details::allocate_proxy_impl<F, T>(\n      alloc, il, std::forward<Args>(args)...);\n}\ntemplate <facade F, class Alloc, class T>\nproxy<F> allocate_proxy(const Alloc& alloc, T&& value) {\n  return details::allocate_proxy_impl<F, std::decay_t<T>>(\n      alloc, std::forward<T>(value));\n}\ntemplate <facade F, class T, class... Args>\nproxy<F> make_proxy(Args&&... args)\n    { return details::make_proxy_impl<F, T>(std::forward<Args>(args)...); }\ntemplate <facade F, class T, class U, class... Args>\nproxy<F> make_proxy(std::initializer_list<U> il, Args&&... args)\n    { return details::make_proxy_impl<F, T>(il, std::forward<Args>(args)...); }\ntemplate <facade F, class T>\nproxy<F> make_proxy(T&& value) {\n  return details::make_proxy_impl<F, std::decay_t<T>>(std::forward<T>(value));\n}\n#endif  // __STDC_HOSTED__\n\ntemplate <class F>\nstruct observer_facade;\n\ntemplate <class F>\nusing proxy_view = proxy<observer_facade<F>>;\n\n#define ___PRO_DIRECT_FUNC_IMPL(...) \\\n    noexcept(noexcept(__VA_ARGS__)) requires(requires { __VA_ARGS__; }) \\\n    { return __VA_ARGS__; }\n\n#define ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(__MACRO, ...) \\\n    template <class __F, bool __IsDirect, class __D, class... __Os> \\\n    struct ___PRO_ENFORCE_EBO accessor { accessor() = delete; }; \\\n    template <class __F, bool __IsDirect, class __D, class... __Os> \\\n        requires(sizeof...(__Os) > 1u && (::std::is_constructible_v< \\\n            accessor<__F, __IsDirect, __D, __Os>> && ...)) \\\n    struct accessor<__F, __IsDirect, __D, __Os...> \\\n        : accessor<__F, __IsDirect, __D, __Os>... \\\n        { using accessor<__F, __IsDirect, __D, __Os>::__VA_ARGS__...; }; \\\n    __MACRO(, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(noexcept, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(&, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(& noexcept, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(&&, ::pro::access_proxy<__F>(::std::forward<accessor>(*this)), \\\n        __VA_ARGS__); \\\n    __MACRO(&& noexcept, ::pro::access_proxy<__F>( \\\n        ::std::forward<accessor>(*this)), __VA_ARGS__); \\\n    __MACRO(const, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(const noexcept, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(const&, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(const& noexcept, ::pro::access_proxy<__F>(*this), __VA_ARGS__); \\\n    __MACRO(const&&, ::pro::access_proxy<__F>( \\\n        ::std::forward<const accessor>(*this)), __VA_ARGS__); \\\n    __MACRO(const&& noexcept, ::pro::access_proxy<__F>( \\\n        ::std::forward<const accessor>(*this)), __VA_ARGS__);\n\n#define ___PRO_ADL_ARG ::pro::details::adl_accessor_arg_t<__F, __IsDirect>\n#define ___PRO_DEF_FREE_ACCESSOR_TEMPLATE(__MACRO, ...) \\\n    template <class __F, bool __IsDirect, class __D, class... __Os> \\\n    struct ___PRO_ENFORCE_EBO accessor { accessor() = delete; }; \\\n    template <class __F, bool __IsDirect, class __D, class... __Os> \\\n        requires(sizeof...(__Os) > 1u && (::std::is_constructible_v< \\\n            accessor<__F, __IsDirect, __D, __Os>> && ...)) \\\n    struct accessor<__F, __IsDirect, __D, __Os...> \\\n        : accessor<__F, __IsDirect, __D, __Os>... {}; \\\n    __MACRO(,, ___PRO_ADL_ARG& __self, ::pro::access_proxy<__F>(__self), \\\n        __VA_ARGS__); \\\n    __MACRO(noexcept, noexcept, ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(&,, ___PRO_ADL_ARG& __self, ::pro::access_proxy<__F>(__self), \\\n        __VA_ARGS__); \\\n    __MACRO(& noexcept, noexcept, ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(&&,, ___PRO_ADL_ARG&& __self, ::pro::access_proxy<__F>( \\\n        ::std::forward<decltype(__self)>(__self)), __VA_ARGS__); \\\n    __MACRO(&& noexcept, noexcept, ___PRO_ADL_ARG&& __self, \\\n        ::pro::access_proxy<__F>(::std::forward<decltype(__self)>(__self)), \\\n        __VA_ARGS__); \\\n    __MACRO(const,, const ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(const noexcept, noexcept, const ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(const&,, const ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(const& noexcept, noexcept, const ___PRO_ADL_ARG& __self, \\\n        ::pro::access_proxy<__F>(__self), __VA_ARGS__); \\\n    __MACRO(const&&,, const ___PRO_ADL_ARG&& __self, ::pro::access_proxy<__F>( \\\n        ::std::forward<decltype(__self)>(__self)), __VA_ARGS__); \\\n    __MACRO(const&& noexcept, noexcept, const ___PRO_ADL_ARG&& __self, \\\n        ::pro::access_proxy<__F>(::std::forward<decltype(__self)>(__self)), \\\n        __VA_ARGS__);\n\n#define ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(...) \\\n    ___PRO_DEBUG( \\\n        accessor() noexcept { ::std::ignore = &accessor::__VA_ARGS__; })\n\n#ifdef __cpp_rtti\nclass bad_proxy_cast : public std::bad_cast {\n public:\n  bad_proxy_cast() noexcept = default;\n  char const* what() const noexcept override { return \"pro::bad_proxy_cast\"; }\n};\n#endif  // __cpp_rtti\n\nnamespace details {\n\ntemplate <class F, bool IsDirect>\nusing adl_accessor_arg_t =\n    std::conditional_t<IsDirect, proxy<F>, proxy_indirect_accessor<F>>;\n\n#define ___PRO_DEF_CAST_ACCESSOR(Q, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class T> \\\n    struct accessor<__F, __IsDirect, __D, T() Q> { \\\n      ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(operator T) \\\n      explicit(Expl) operator T() Q { \\\n        if constexpr (Nullable) { \\\n          if (!SELF.has_value()) { return nullptr; } \\\n        } \\\n        return proxy_invoke<__IsDirect, __D, T() Q>(SELF); \\\n      } \\\n    }\ntemplate <bool Expl, bool Nullable>\nstruct cast_dispatch_base {\n  ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_CAST_ACCESSOR,\n      operator typename overload_traits<__Os>::return_type)\n};\n#undef ___PRO_DEF_CAST_ACCESSOR\n\nstruct upward_conversion_dispatch : cast_dispatch_base<false, true> {\n  template <class T>\n  T&& operator()(T&& self) noexcept { return std::forward<T>(self); }\n};\n\ntemplate <class T>\nstruct explicit_conversion_adapter {\n  explicit explicit_conversion_adapter(T&& value) noexcept\n      : value_(std::forward<T>(value)) {}\n  explicit_conversion_adapter(const explicit_conversion_adapter&) = delete;\n\n  template <class U>\n  operator U() noexcept(std::is_nothrow_constructible_v<U, T>)\n      requires(std::is_constructible_v<U, T>)\n      { return U{std::forward<T>(value_)}; }\n\n private:\n  T&& value_;\n};\n\nconstexpr std::size_t invalid_size = std::numeric_limits<std::size_t>::max();\nconstexpr constraint_level invalid_cl = static_cast<constraint_level>(\n    std::numeric_limits<std::underlying_type_t<constraint_level>>::min());\nconsteval auto normalize(proxiable_ptr_constraints value) {\n  if (value.max_size == invalid_size)\n      { value.max_size = sizeof(ptr_prototype); }\n  if (value.max_align == invalid_size)\n      { value.max_align = alignof(ptr_prototype); }\n  if (value.copyability == invalid_cl)\n      { value.copyability = constraint_level::none; }\n  if (value.relocatability == invalid_cl)\n      { value.relocatability = constraint_level::nothrow; }\n  if (value.destructibility == invalid_cl)\n      { value.destructibility = constraint_level::nothrow; }\n  return value;\n}\nconsteval auto make_restricted_layout(proxiable_ptr_constraints value,\n    std::size_t max_size, std::size_t max_align) {\n  if (value.max_size > max_size) { value.max_size = max_size; }\n  if (value.max_align > max_align) { value.max_align = max_align; }\n  return value;\n}\nconsteval auto make_copyable(proxiable_ptr_constraints value,\n    constraint_level cl) {\n  if (value.copyability < cl) { value.copyability = cl; }\n  return value;\n}\nconsteval auto make_relocatable(proxiable_ptr_constraints value,\n    constraint_level cl) {\n  if (value.relocatability < cl) { value.relocatability = cl; }\n  return value;\n}\nconsteval auto make_destructible(proxiable_ptr_constraints value,\n    constraint_level cl) {\n  if (value.destructibility < cl) { value.destructibility = cl; }\n  return value;\n}\nconsteval auto merge_constraints(proxiable_ptr_constraints a,\n    proxiable_ptr_constraints b) {\n  a = make_restricted_layout(a, b.max_size, b.max_align);\n  a = make_copyable(a, b.copyability);\n  a = make_relocatable(a, b.relocatability);\n  a = make_destructible(a, b.destructibility);\n  return a;\n}\nconsteval std::size_t max_align_of(std::size_t value) {\n  value &= ~value + 1u;\n  return value < alignof(std::max_align_t) ? value : alignof(std::max_align_t);\n}\n\ntemplate <class SFINAE, class T, class F, bool IsDirect, class... Args>\nstruct accessor_instantiation_traits : std::type_identity<void> {};\ntemplate <class T, class F, bool IsDirect, class... Args>\nstruct accessor_instantiation_traits<std::void_t<typename T::template accessor<\n    F, IsDirect, T, Args...>>, T, F, IsDirect, Args...>\n    : std::type_identity<typename T::template accessor<\n          F, IsDirect, T, Args...>> {};\ntemplate <class T, class F, bool IsDirect, class... Args>\nusing instantiated_accessor_t =\n    typename accessor_instantiation_traits<void, T, F, IsDirect, Args...>::type;\n\ntemplate <bool IsDirect, class D, class... Os>\nstruct conv_impl {\n  static constexpr bool is_direct = IsDirect;\n  using dispatch_type = D;\n  using overload_types = std::tuple<Os...>;\n  template <class F>\n  using accessor = instantiated_accessor_t<D, F, IsDirect, Os...>;\n};\ntemplate <bool IsDirect, class R>\nstruct refl_impl {\n  static constexpr bool is_direct = IsDirect;\n  using reflector_type = R;\n  template <class F>\n  using accessor = instantiated_accessor_t<R, F, IsDirect>;\n};\ntemplate <class Cs, class Rs, proxiable_ptr_constraints C>\nstruct facade_impl {\n  using convention_types = Cs;\n  using reflection_types = Rs;\n  static constexpr proxiable_ptr_constraints constraints = C;\n};\n\ntemplate <class O, class I>\nstruct add_tuple_reduction : std::type_identity<O> {};\ntemplate <class... Os, class I> requires(!std::is_same_v<I, Os> && ...)\nstruct add_tuple_reduction<std::tuple<Os...>, I>\n    : std::type_identity<std::tuple<Os..., I>> {};\ntemplate <class T, class U>\nusing add_tuple_t = typename add_tuple_reduction<T, U>::type;\ntemplate <class O, class... Is>\nusing merge_tuple_impl_t = recursive_reduction_t<add_tuple_t, O, Is...>;\ntemplate <class T, class U>\nusing merge_tuple_t = instantiated_t<merge_tuple_impl_t, U, T>;\n\ntemplate <bool IsDirect, class D>\nstruct merge_conv_traits\n    { template <class... Os> using type = conv_impl<IsDirect, D, Os...>; };\ntemplate <class C1, class C2>\nusing merge_conv_t = instantiated_t<\n    merge_conv_traits<C1::is_direct, typename C1::dispatch_type>::template type,\n    merge_tuple_t<typename C1::overload_types, typename C2::overload_types>>;\n\ntemplate <class Cs1, class C2, class C> struct add_conv_reduction;\ntemplate <class... Cs1, class C2, class... Cs3, class C>\nstruct add_conv_reduction<std::tuple<Cs1...>, std::tuple<C2, Cs3...>, C>\n    : add_conv_reduction<std::tuple<Cs1..., C2>, std::tuple<Cs3...>, C> {};\ntemplate <class... Cs1, class C2, class... Cs3, class C>\n    requires(C::is_direct == C2::is_direct && std::is_same_v<\n        typename C::dispatch_type, typename C2::dispatch_type>)\nstruct add_conv_reduction<std::tuple<Cs1...>, std::tuple<C2, Cs3...>, C>\n    : std::type_identity<std::tuple<Cs1..., merge_conv_t<C2, C>, Cs3...>> {};\ntemplate <class... Cs, class C>\nstruct add_conv_reduction<std::tuple<Cs...>, std::tuple<>, C>\n    : std::type_identity<std::tuple<Cs..., merge_conv_t<\n          conv_impl<C::is_direct, typename C::dispatch_type>, C>>> {};\ntemplate <class Cs, class C>\nusing add_conv_t = typename add_conv_reduction<std::tuple<>, Cs, C>::type;\n\ntemplate <class F, constraint_level CL>\nusing copy_conversion_overload =\n    proxy<F>() const& noexcept(CL >= constraint_level::nothrow);\ntemplate <class F, constraint_level CL>\nusing move_conversion_overload =\n    proxy<F>() && noexcept(CL >= constraint_level::nothrow);\ntemplate <class Cs, class F, constraint_level CCL, constraint_level RCL>\nstruct add_upward_conversion_conv\n    : std::type_identity<add_conv_t<Cs, conv_impl<true,\n          upward_conversion_dispatch, copy_conversion_overload<F, CCL>,\n          move_conversion_overload<F, RCL>>>> {};\ntemplate <class Cs, class F, constraint_level RCL>\nstruct add_upward_conversion_conv<Cs, F, constraint_level::none, RCL>\n    : std::type_identity<add_conv_t<Cs, conv_impl<true,\n          upward_conversion_dispatch, move_conversion_overload<F, RCL>>>> {};\ntemplate <class Cs, class F, constraint_level CCL>\nstruct add_upward_conversion_conv<Cs, F, CCL, constraint_level::none>\n    : std::type_identity<add_conv_t<Cs, conv_impl<true,\n          upward_conversion_dispatch, copy_conversion_overload<F, CCL>>>> {};\ntemplate <class Cs, class F>\nstruct add_upward_conversion_conv<\n    Cs, F, constraint_level::none, constraint_level::none>\n    : std::type_identity<Cs> {};\n\ntemplate <class Cs1, class... Cs2>\nusing merge_conv_tuple_t = recursive_reduction_t<add_conv_t, Cs1, Cs2...>;\ntemplate <class Cs, class F, bool WithUpwardConversion>\nusing merge_facade_conv_t = typename add_upward_conversion_conv<\n    instantiated_t<merge_conv_tuple_t, typename F::convention_types, Cs>, F,\n    WithUpwardConversion ? F::constraints.copyability : constraint_level::none,\n    (WithUpwardConversion &&\n        F::constraints.copyability != constraint_level::trivial) ?\n        F::constraints.relocatability : constraint_level::none>::type;\n\nstruct proxy_view_dispatch : cast_dispatch_base<false, true> {\n  template <class T>\n  auto* operator()(T&& value)\n      ___PRO_DIRECT_FUNC_IMPL(std::addressof(*std::forward<T>(value)))\n};\n\ntemplate <class P> struct facade_of_traits;\ntemplate <class F>\nstruct facade_of_traits<proxy<F>> : std::type_identity<F> {};\ntemplate <class P> using facade_of_t = typename facade_of_traits<P>::type;\n\ntemplate <class F, bool IsDirect, class D, class O>\nstruct observer_overload_mapping_traits_impl\n    : std::type_identity<typename overload_traits<O>::view_type> {};\ntemplate <class F, class D, class O>\n    requires(!std::is_same_v<D, proxy_view_dispatch> ||\n        std::is_same_v<typename overload_traits<O>::return_type, proxy_view<F>>)\nstruct observer_overload_mapping_traits_impl<F, true, D, O>\n    : std::type_identity<void> {};\ntemplate <class F, bool IsDirect, class D, class O>\nstruct observer_overload_mapping_traits : std::type_identity<void> {};\ntemplate <class F, bool IsDirect, class D, class O>\n    requires(overload_traits<O>::qualifier ==\n        (std::is_const_v<F> ? qualifier_type::const_lv : qualifier_type::lv))\nstruct observer_overload_mapping_traits<F, IsDirect, D, O>\n    : observer_overload_mapping_traits_impl<F, IsDirect, D, O> {};\ntemplate <class F, class O>\nstruct observer_overload_mapping_traits<F, true, upward_conversion_dispatch, O>\n    : std::type_identity<proxy_view<std::conditional_t<std::is_const_v<F>,\n          const facade_of_t<typename overload_traits<O>::return_type>,\n          facade_of_t<typename overload_traits<O>::return_type>>>()\n          const noexcept> {};\n\ntemplate <class D>\nstruct observer_dispatch_reduction : std::type_identity<D> {};\ntemplate <>\nstruct observer_dispatch_reduction<upward_conversion_dispatch>\n    : std::type_identity<proxy_view_dispatch> {};\n\ntemplate <class O, class I>\nstruct observer_overload_ignore_void_reduction : std::type_identity<O> {};\ntemplate <bool IsDirect, class D, class... Os, class O>\n    requires(!std::is_void_v<O>)\nstruct observer_overload_ignore_void_reduction<conv_impl<IsDirect, D, Os...>, O>\n    : std::type_identity<conv_impl<IsDirect, D, Os..., O>> {};\ntemplate <class O, class I>\nusing observer_overload_ignore_void_reduction_t =\n    typename observer_overload_ignore_void_reduction<O, I>::type;\n\ntemplate <class F, class C, class... Os>\nusing observer_conv_impl = recursive_reduction_t<\n    observer_overload_ignore_void_reduction_t,\n    conv_impl<C::is_direct, typename observer_dispatch_reduction<\n        typename C::dispatch_type>::type>,\n    typename observer_overload_mapping_traits<\n        F, C::is_direct, typename C::dispatch_type, Os>::type...>;\n\ntemplate <class O, class I>\nstruct observer_conv_reduction : std::type_identity<O> {};\ntemplate <class O, class I>\n    requires(std::tuple_size_v<typename I::overload_types> != 0u)\nstruct observer_conv_reduction<O, I> : std::type_identity<add_conv_t<O, I>> {};\ntemplate <class F>\nstruct observer_conv_reduction_traits {\n  template <class O, class I>\n  using type = typename observer_conv_reduction<O, instantiated_t<\n      observer_conv_impl, typename I::overload_types, F, I>>::type;\n};\n\ntemplate <class O, class I>\nstruct observer_refl_reduction : std::type_identity<O> {};\ntemplate <class... Rs, class R> requires(!R::is_direct)\nstruct observer_refl_reduction<std::tuple<Rs...>, R>\n    : std::type_identity<std::tuple<Rs..., R>> {};\ntemplate <class O, class I>\nusing observer_refl_reduction_t = typename observer_refl_reduction<O, I>::type;\n\ntemplate <class F, class... Cs>\nstruct observer_facade_conv_impl {\n  using convention_types = recursive_reduction_t<\n      observer_conv_reduction_traits<F>::template type, std::tuple<>, Cs...>;\n};\ntemplate <class... Rs>\nstruct observer_facade_refl_impl {\n  using reflection_types = recursive_reduction_t<\n      observer_refl_reduction_t, std::tuple<>, Rs...>;\n};\n\ntemplate <class F>\nstruct proxy_view_overload_traits\n    : std::type_identity<proxy_view<F>() noexcept> {};\ntemplate <class F>\nstruct proxy_view_overload_traits<const F>\n    : std::type_identity<proxy_view<const F>() const noexcept> {};\ntemplate <class F>\nusing proxy_view_overload = typename proxy_view_overload_traits<F>::type;\n\ntemplate <std::size_t N>\nstruct sign {\n  consteval sign(const char (&str)[N])\n      { for (std::size_t i = 0; i < N; ++i) { value[i] = str[i]; } }\n\n  char value[N];\n};\ntemplate <std::size_t N>\nsign(const char (&str)[N]) -> sign<N>;\n\n#if __STDC_HOSTED__\ntemplate <class CharT> struct format_overload_traits;\ntemplate <>\nstruct format_overload_traits<char>\n    : std::type_identity<std::format_context::iterator(\n          std::string_view spec, std::format_context& fc) const> {};\ntemplate <>\nstruct format_overload_traits<wchar_t>\n    : std::type_identity<std::wformat_context::iterator(\n          std::wstring_view spec, std::wformat_context& fc) const> {};\ntemplate <class CharT>\nusing format_overload_t = typename format_overload_traits<CharT>::type;\n\nstruct format_dispatch {\n  // Note: This function requires std::formatter<T, CharT> to be well-formed.\n  // However, the standard did not provide such facility before C++23. In the\n  // \"required\" clause of this function, std::formattable (C++23) is preferred\n  // when available. Otherwise, when building with C++20, we simply check\n  // whether std::formatter<T, CharT> is a disabled specialization of\n  // std::formatter by std::is_default_constructible_v as per\n  // [format.formatter.spec].\n  template <class T, class CharT, class OutIt>\n  OutIt operator()(const T& self, std::basic_string_view<CharT> spec,\n      std::basic_format_context<OutIt, CharT>& fc)\n      requires(\n#if defined(__cpp_lib_format_ranges) && __cpp_lib_format_ranges >= 202207L\n          std::formattable<T, CharT>\n#else\n          std::is_default_constructible_v<std::formatter<T, CharT>>\n#endif  // defined(__cpp_lib_format_ranges) && __cpp_lib_format_ranges >= 202207L\n      ) {\n    std::formatter<T, CharT> impl;\n    {\n      std::basic_format_parse_context<CharT> pc{spec};\n      impl.parse(pc);\n    }\n    return impl.format(self, fc);\n  }\n};\n#endif  // __STDC_HOSTED__\n\n#ifdef __cpp_rtti\nstruct proxy_cast_context {\n  const std::type_info* type_ptr;\n  bool is_ref;\n  bool is_const;\n  void* result_ptr;\n};\n\nstruct proxy_cast_dispatch;\ntemplate <class F, bool IsDirect, class D, class O>\nstruct proxy_cast_accessor_impl {\n  using _Self = add_qualifier_t<\n      adl_accessor_arg_t<F, IsDirect>, overload_traits<O>::qualifier>;\n  template <class T>\n  friend T proxy_cast(_Self self) {\n    static_assert(!std::is_rvalue_reference_v<T>);\n    if (!access_proxy<F>(self).has_value()) { ___PRO_THROW(bad_proxy_cast{}); }\n    if constexpr (std::is_lvalue_reference_v<T>) {\n      using U = std::remove_reference_t<T>;\n      void* result = nullptr;\n      proxy_cast_context ctx{.type_ptr = &typeid(T), .is_ref = true,\n          .is_const = std::is_const_v<U>, .result_ptr = &result};\n      proxy_invoke<IsDirect, D, O>(\n          access_proxy<F>(std::forward<_Self>(self)), ctx);\n      if (result == nullptr) { ___PRO_THROW(bad_proxy_cast{}); }\n      return *static_cast<U*>(result);\n    } else {\n      std::optional<std::remove_const_t<T>> result;\n      proxy_cast_context ctx{.type_ptr = &typeid(T), .is_ref = false,\n          .is_const = false, .result_ptr = &result};\n      proxy_invoke<IsDirect, D, O>(\n          access_proxy<F>(std::forward<_Self>(self)), ctx);\n      if (!result.has_value()) { ___PRO_THROW(bad_proxy_cast{}); }\n      return std::move(*result);\n    }\n  }\n  template <class T>\n  friend T* proxy_cast(std::remove_reference_t<_Self>* self) noexcept\n      requires(std::is_lvalue_reference_v<_Self>) {\n    if (!access_proxy<F>(*self).has_value()) { return nullptr; }\n    void* result = nullptr;\n    proxy_cast_context ctx{.type_ptr = &typeid(T), .is_ref = true,\n        .is_const = std::is_const_v<T>, .result_ptr = &result};\n    proxy_invoke<IsDirect, D, O>(access_proxy<F>(*self), ctx);\n    return static_cast<T*>(result);\n  }\n};\n\n#define ___PRO_DEF_PROXY_CAST_ACCESSOR(Q, ...) \\\n    template <class F, bool IsDirect, class D> \\\n    struct accessor<F, IsDirect, D, void(proxy_cast_context) Q> \\\n        : proxy_cast_accessor_impl<F, IsDirect, D, \\\n              void(proxy_cast_context) Q> {}\nstruct proxy_cast_dispatch {\n  template <class T>\n  void operator()(T&& self, proxy_cast_context ctx) {\n    if (typeid(T) == *ctx.type_ptr) {\n      if (ctx.is_ref) {\n        if constexpr (std::is_lvalue_reference_v<T>) {\n          if (ctx.is_const || !std::is_const_v<T>) {\n            *static_cast<void**>(ctx.result_ptr) = (void*)&self;\n          }\n        }\n      } else {\n        if constexpr (std::is_constructible_v<std::decay_t<T>, T>) {\n          static_cast<std::optional<std::decay_t<T>>*>(ctx.result_ptr)\n              ->emplace(std::forward<T>(self));\n        }\n      }\n    }\n  }\n  ___PRO_DEF_FREE_ACCESSOR_TEMPLATE(___PRO_DEF_PROXY_CAST_ACCESSOR)\n};\n#undef ___PRO_DEF_PROXY_CAST_ACCESSOR\n\nstruct proxy_typeid_reflector {\n  template <class T>\n  constexpr explicit proxy_typeid_reflector(std::in_place_type_t<T>)\n      : info(&typeid(T)) {}\n  constexpr proxy_typeid_reflector(const proxy_typeid_reflector&) = default;\n\n  template <class F, bool IsDirect, class R>\n  struct accessor {\n    friend const std::type_info& proxy_typeid(\n        const adl_accessor_arg_t<F, IsDirect>& self) noexcept {\n      const proxy<F>& p = access_proxy<F>(self);\n      if (!p.has_value()) { return typeid(void); }\n      const proxy_typeid_reflector& refl = proxy_reflect<IsDirect, R>(p);\n      return *refl.info;\n    }\n___PRO_DEBUG(\n    accessor() noexcept { std::ignore = &accessor::_symbol_guard; }\n\n   private:\n    static inline const std::type_info& _symbol_guard(\n        const adl_accessor_arg_t<F, IsDirect>& self) noexcept\n        { return proxy_typeid(self); }\n)\n  };\n\n  const std::type_info* info;\n};\n#endif  // __cpp_rtti\n\nstruct wildcard {\n  wildcard() = delete;\n\n  template <class T>\n  [[noreturn]] operator T() {\n#ifdef __cpp_lib_unreachable\n    std::unreachable();\n#else\n    std::abort();\n#endif  // __cpp_lib_unreachable\n  }\n};\n\n}  // namespace details\n\ntemplate <class Cs, class Rs, proxiable_ptr_constraints C>\nstruct basic_facade_builder {\n  template <class D, class... Os>\n      requires(sizeof...(Os) > 0u &&\n          (details::overload_traits<Os>::applicable && ...))\n  using add_indirect_convention = basic_facade_builder<details::add_conv_t<\n      Cs, details::conv_impl<false, D, Os...>>, Rs, C>;\n  template <class D, class... Os>\n      requires(sizeof...(Os) > 0u &&\n          (details::overload_traits<Os>::applicable && ...))\n  using add_direct_convention = basic_facade_builder<details::add_conv_t<\n      Cs, details::conv_impl<true, D, Os...>>, Rs, C>;\n  template <class D, class... Os>\n      requires(sizeof...(Os) > 0u &&\n          (details::overload_traits<Os>::applicable && ...))\n  using add_convention = add_indirect_convention<D, Os...>;\n  template <class R>\n  using add_indirect_reflection = basic_facade_builder<\n      Cs, details::add_tuple_t<Rs, details::refl_impl<false, R>>, C>;\n  template <class R>\n  using add_direct_reflection = basic_facade_builder<\n      Cs, details::add_tuple_t<Rs, details::refl_impl<true, R>>, C>;\n  template <class R>\n  using add_reflection = add_indirect_reflection<R>;\n  template <facade F, bool WithUpwardConversion = false>\n  using add_facade = basic_facade_builder<\n      details::merge_facade_conv_t<Cs, F, WithUpwardConversion>,\n      details::merge_tuple_t<Rs, typename F::reflection_types>,\n      details::merge_constraints(C, F::constraints)>;\n  template <std::size_t PtrSize,\n      std::size_t PtrAlign = details::max_align_of(PtrSize)>\n      requires(std::has_single_bit(PtrAlign) && PtrSize % PtrAlign == 0u)\n  using restrict_layout = basic_facade_builder<\n      Cs, Rs, details::make_restricted_layout(C, PtrSize, PtrAlign)>;\n  template <constraint_level CL>\n  using support_copy = basic_facade_builder<\n      Cs, Rs, details::make_copyable(C, CL)>;\n  template <constraint_level CL>\n  using support_relocation = basic_facade_builder<\n      Cs, Rs, details::make_relocatable(C, CL)>;\n  template <constraint_level CL>\n  using support_destruction = basic_facade_builder<\n      Cs, Rs, details::make_destructible(C, CL)>;\n#if __STDC_HOSTED__\n  using support_format = add_convention<\n      details::format_dispatch, details::format_overload_t<char>>;\n  using support_wformat = add_convention<\n      details::format_dispatch, details::format_overload_t<wchar_t>>;\n#endif  // __STDC_HOSTED__\n#ifdef __cpp_rtti\n  using support_indirect_rtti = basic_facade_builder<\n      details::add_conv_t<Cs, details::conv_impl<false,\n          details::proxy_cast_dispatch, void(details::proxy_cast_context) &,\n          void(details::proxy_cast_context) const&,\n          void(details::proxy_cast_context) &&>>,\n      details::add_tuple_t<Rs, details::refl_impl<false,\n          details::proxy_typeid_reflector>>, C>;\n  using support_direct_rtti = basic_facade_builder<\n      details::add_conv_t<Cs, details::conv_impl<true,\n          details::proxy_cast_dispatch, void(details::proxy_cast_context) &,\n          void(details::proxy_cast_context) const&,\n          void(details::proxy_cast_context) &&>>,\n      details::add_tuple_t<Rs, details::refl_impl<true,\n          details::proxy_typeid_reflector>>, C>;\n  using support_rtti = support_indirect_rtti;\n#endif  // __cpp_rtti\n  template <class F>\n  using add_view = add_direct_convention<\n      details::proxy_view_dispatch, details::proxy_view_overload<F>>;\n  using build = details::facade_impl<Cs, Rs, details::normalize(C)>;\n  basic_facade_builder() = delete;\n};\n\ntemplate <class F>\nstruct observer_facade\n    : details::instantiated_t<details::observer_facade_conv_impl,\n          typename F::convention_types, F>,\n      details::instantiated_t<details::observer_facade_refl_impl,\n          typename F::reflection_types> {\n  static constexpr proxiable_ptr_constraints constraints{\n      .max_size = sizeof(void*), .max_align = alignof(void*),\n      .copyability = constraint_level::trivial,\n      .relocatability = constraint_level::trivial,\n      .destructibility = constraint_level::trivial};\n};\n\nusing facade_builder = basic_facade_builder<std::tuple<>, std::tuple<>,\n    proxiable_ptr_constraints{\n        .max_size = details::invalid_size,\n        .max_align = details::invalid_size,\n        .copyability = details::invalid_cl,\n        .relocatability = details::invalid_cl,\n        .destructibility = details::invalid_cl}>;\n\ntemplate <details::sign Sign, bool Rhs = false>\nstruct operator_dispatch;\n\n#define ___PRO_DEF_LHS_LEFT_OP_ACCESSOR(Q, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class R> \\\n    struct accessor<__F, __IsDirect, __D, R() Q> { \\\n      ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(__VA_ARGS__) \\\n      R __VA_ARGS__() Q { return proxy_invoke<__IsDirect, __D, R() Q>(SELF); } \\\n    }\n#define ___PRO_DEF_LHS_ANY_OP_ACCESSOR(Q, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class R, class... Args> \\\n    struct accessor<__F, __IsDirect, __D, R(Args...) Q> { \\\n      ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(__VA_ARGS__) \\\n      R __VA_ARGS__(Args... args) Q { \\\n        return proxy_invoke<__IsDirect, __D, R(Args...) Q>( \\\n            SELF, std::forward<Args>(args)...); \\\n      } \\\n    }\n#define ___PRO_DEF_LHS_UNARY_OP_ACCESSOR ___PRO_DEF_LHS_ANY_OP_ACCESSOR\n#define ___PRO_DEF_LHS_BINARY_OP_ACCESSOR ___PRO_DEF_LHS_ANY_OP_ACCESSOR\n#define ___PRO_DEF_LHS_ALL_OP_ACCESSOR ___PRO_DEF_LHS_ANY_OP_ACCESSOR\n#define ___PRO_LHS_LEFT_OP_DISPATCH_BODY_IMPL(...) \\\n    template <class T> \\\n    decltype(auto) operator()(T&& self) \\\n        ___PRO_DIRECT_FUNC_IMPL(__VA_ARGS__ std::forward<T>(self))\n#define ___PRO_LHS_UNARY_OP_DISPATCH_BODY_IMPL(...) \\\n    template <class T> \\\n    decltype(auto) operator()(T&& self) \\\n        ___PRO_DIRECT_FUNC_IMPL(__VA_ARGS__ std::forward<T>(self)) \\\n    template <class T> \\\n    decltype(auto) operator()(T&& self, int) \\\n        ___PRO_DIRECT_FUNC_IMPL(std::forward<T>(self) __VA_ARGS__)\n#define ___PRO_LHS_BINARY_OP_DISPATCH_BODY_IMPL(...) \\\n    template <class T, class Arg> \\\n    decltype(auto) operator()(T&& self, Arg&& arg) \\\n        ___PRO_DIRECT_FUNC_IMPL( \\\n            std::forward<T>(self) __VA_ARGS__ std::forward<Arg>(arg))\n#define ___PRO_LHS_ALL_OP_DISPATCH_BODY_IMPL(...) \\\n    ___PRO_LHS_LEFT_OP_DISPATCH_BODY_IMPL(__VA_ARGS__) \\\n    ___PRO_LHS_BINARY_OP_DISPATCH_BODY_IMPL(__VA_ARGS__)\n#define ___PRO_LHS_OP_DISPATCH_IMPL(TYPE, ...) \\\n    template <> \\\n    struct operator_dispatch<#__VA_ARGS__, false> { \\\n      ___PRO_LHS_##TYPE##_OP_DISPATCH_BODY_IMPL(__VA_ARGS__) \\\n      ___PRO_DEF_MEM_ACCESSOR_TEMPLATE( \\\n          ___PRO_DEF_LHS_##TYPE##_OP_ACCESSOR, operator __VA_ARGS__) \\\n    };\n\n#define ___PRO_DEF_RHS_OP_ACCESSOR(Q, NE, SELF_ARG, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class R, class Arg> \\\n    struct accessor<__F, __IsDirect, __D, R(Arg) Q> { \\\n      friend R operator __VA_ARGS__(Arg arg, SELF_ARG) NE { \\\n        return proxy_invoke<__IsDirect, __D, R(Arg) Q>( \\\n            SELF, std::forward<Arg>(arg)); \\\n      } \\\n___PRO_DEBUG( \\\n      accessor() noexcept { std::ignore = &accessor::_symbol_guard; } \\\n    \\\n     private: \\\n      static inline R _symbol_guard(Arg arg, SELF_ARG) NE { \\\n        return std::forward<Arg>(arg) __VA_ARGS__ \\\n            std::forward<decltype(__self)>(__self); \\\n      } \\\n) \\\n    }\n#define ___PRO_RHS_OP_DISPATCH_IMPL(...) \\\n    template <> \\\n    struct operator_dispatch<#__VA_ARGS__, true> { \\\n      template <class T, class Arg> \\\n      decltype(auto) operator()(T&& self, Arg&& arg) \\\n          ___PRO_DIRECT_FUNC_IMPL( \\\n              std::forward<Arg>(arg) __VA_ARGS__ std::forward<T>(self)) \\\n      ___PRO_DEF_FREE_ACCESSOR_TEMPLATE( \\\n          ___PRO_DEF_RHS_OP_ACCESSOR, __VA_ARGS__) \\\n    };\n\n#define ___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL(...) \\\n    ___PRO_LHS_OP_DISPATCH_IMPL(ALL, __VA_ARGS__) \\\n    ___PRO_RHS_OP_DISPATCH_IMPL(__VA_ARGS__)\n\n#define ___PRO_BINARY_OP_DISPATCH_IMPL(...) \\\n    ___PRO_LHS_OP_DISPATCH_IMPL(BINARY, __VA_ARGS__) \\\n    ___PRO_RHS_OP_DISPATCH_IMPL(__VA_ARGS__)\n\n#define ___PRO_DEF_LHS_ASSIGNMENT_OP_ACCESSOR(Q, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class R, class Arg> \\\n    struct accessor<__F, __IsDirect, __D, R(Arg) Q> { \\\n      ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(__VA_ARGS__) \\\n      decltype(auto) __VA_ARGS__(Arg arg) Q { \\\n        proxy_invoke<__IsDirect, __D, R(Arg) Q>(SELF, std::forward<Arg>(arg)); \\\n        if constexpr (__IsDirect) { \\\n          return SELF; \\\n        } else { \\\n          return *SELF; \\\n        } \\\n      } \\\n    }\n#define ___PRO_DEF_RHS_ASSIGNMENT_OP_ACCESSOR(Q, NE, SELF_ARG, SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class R, class Arg> \\\n    struct accessor<__F, __IsDirect, __D, R(Arg&) Q> { \\\n      friend Arg& operator __VA_ARGS__(Arg& arg, SELF_ARG) NE { \\\n        proxy_invoke<__IsDirect, __D, R(Arg&) Q>(SELF, arg); \\\n        return arg; \\\n      } \\\n___PRO_DEBUG( \\\n      accessor() noexcept { std::ignore = &accessor::_symbol_guard; } \\\n    \\\n     private: \\\n      static inline Arg& _symbol_guard(Arg& arg, SELF_ARG) NE \\\n          { return arg __VA_ARGS__ std::forward<decltype(__self)>(__self); } \\\n) \\\n    }\n#define ___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(...) \\\n    template <> \\\n    struct operator_dispatch<#__VA_ARGS__, false> { \\\n      template <class T, class Arg> \\\n      decltype(auto) operator()(T&& self, Arg&& arg) \\\n          ___PRO_DIRECT_FUNC_IMPL(std::forward<T>(self) __VA_ARGS__ \\\n              std::forward<Arg>(arg)) \\\n      ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_LHS_ASSIGNMENT_OP_ACCESSOR, \\\n          operator __VA_ARGS__) \\\n    }; \\\n    template <> \\\n    struct operator_dispatch<#__VA_ARGS__, true> { \\\n      template <class T, class Arg> \\\n      decltype(auto) operator()(T&& self, Arg&& arg) \\\n          ___PRO_DIRECT_FUNC_IMPL( \\\n              std::forward<Arg>(arg) __VA_ARGS__ std::forward<T>(self)) \\\n      ___PRO_DEF_FREE_ACCESSOR_TEMPLATE(___PRO_DEF_RHS_ASSIGNMENT_OP_ACCESSOR, \\\n          __VA_ARGS__) \\\n    };\n\n___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL(+)\n___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL(-)\n___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL(*)\n___PRO_BINARY_OP_DISPATCH_IMPL(/)\n___PRO_BINARY_OP_DISPATCH_IMPL(%)\n___PRO_LHS_OP_DISPATCH_IMPL(UNARY, ++)\n___PRO_LHS_OP_DISPATCH_IMPL(UNARY, --)\n___PRO_BINARY_OP_DISPATCH_IMPL(==)\n___PRO_BINARY_OP_DISPATCH_IMPL(!=)\n___PRO_BINARY_OP_DISPATCH_IMPL(>)\n___PRO_BINARY_OP_DISPATCH_IMPL(<)\n___PRO_BINARY_OP_DISPATCH_IMPL(>=)\n___PRO_BINARY_OP_DISPATCH_IMPL(<=)\n___PRO_BINARY_OP_DISPATCH_IMPL(<=>)\n___PRO_LHS_OP_DISPATCH_IMPL(LEFT, !)\n___PRO_BINARY_OP_DISPATCH_IMPL(&&)\n___PRO_BINARY_OP_DISPATCH_IMPL(||)\n___PRO_LHS_OP_DISPATCH_IMPL(LEFT, ~)\n___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL(&)\n___PRO_BINARY_OP_DISPATCH_IMPL(|)\n___PRO_BINARY_OP_DISPATCH_IMPL(^)\n___PRO_BINARY_OP_DISPATCH_IMPL(<<)\n___PRO_BINARY_OP_DISPATCH_IMPL(>>)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(+=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(-=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(*=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(/=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(&=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(|=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(^=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(<<=)\n___PRO_ASSIGNMENT_OP_DISPATCH_IMPL(>>=)\n___PRO_BINARY_OP_DISPATCH_IMPL(,)\n___PRO_BINARY_OP_DISPATCH_IMPL(->*)\n\ntemplate <>\nstruct operator_dispatch<\"()\", false> {\n  template <class T, class... Args>\n  decltype(auto) operator()(T&& self, Args&&... args)\n      ___PRO_DIRECT_FUNC_IMPL(\n          std::forward<T>(self)(std::forward<Args>(args)...))\n  ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_LHS_ANY_OP_ACCESSOR, operator())\n};\ntemplate <>\nstruct operator_dispatch<\"[]\", false> {\n#if defined(__cpp_multidimensional_subscript) && __cpp_multidimensional_subscript >= 202110L\n  template <class T, class... Args>\n  decltype(auto) operator()(T&& self, Args&&... args)\n      ___PRO_DIRECT_FUNC_IMPL(\n          std::forward<T>(self)[std::forward<Args>(args)...])\n#else\n  template <class T, class Arg>\n  decltype(auto) operator()(T&& self, Arg&& arg)\n      ___PRO_DIRECT_FUNC_IMPL(std::forward<T>(self)[std::forward<Arg>(arg)])\n#endif  // defined(__cpp_multidimensional_subscript) && __cpp_multidimensional_subscript >= 202110L\n  ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_LHS_ANY_OP_ACCESSOR, operator[])\n};\n\n#undef ___PRO_ASSIGNMENT_OP_DISPATCH_IMPL\n#undef ___PRO_DEF_RHS_ASSIGNMENT_OP_ACCESSOR\n#undef ___PRO_DEF_LHS_ASSIGNMENT_OP_ACCESSOR\n#undef ___PRO_BINARY_OP_DISPATCH_IMPL\n#undef ___PRO_EXTENDED_BINARY_OP_DISPATCH_IMPL\n#undef ___PRO_RHS_OP_DISPATCH_IMPL\n#undef ___PRO_DEF_RHS_OP_ACCESSOR\n#undef ___PRO_LHS_OP_DISPATCH_IMPL\n#undef ___PRO_LHS_ALL_OP_DISPATCH_BODY_IMPL\n#undef ___PRO_LHS_BINARY_OP_DISPATCH_BODY_IMPL\n#undef ___PRO_LHS_UNARY_OP_DISPATCH_BODY_IMPL\n#undef ___PRO_LHS_LEFT_OP_DISPATCH_BODY_IMPL\n#undef ___PRO_DEF_LHS_ALL_OP_ACCESSOR\n#undef ___PRO_DEF_LHS_BINARY_OP_ACCESSOR\n#undef ___PRO_DEF_LHS_UNARY_OP_ACCESSOR\n#undef ___PRO_DEF_LHS_ANY_OP_ACCESSOR\n#undef ___PRO_DEF_LHS_LEFT_OP_ACCESSOR\n\nstruct implicit_conversion_dispatch\n    : details::cast_dispatch_base<false, false> {\n  template <class T>\n  T&& operator()(T&& self) noexcept { return std::forward<T>(self); }\n};\nstruct explicit_conversion_dispatch : details::cast_dispatch_base<true, false> {\n  template <class T>\n  auto operator()(T&& self) noexcept\n      { return details::explicit_conversion_adapter<T>{std::forward<T>(self)}; }\n};\nusing conversion_dispatch = explicit_conversion_dispatch;\n\nclass not_implemented : public std::exception {\n public:\n  not_implemented() noexcept = default;\n  char const* what() const noexcept override { return \"pro::not_implemented\"; }\n};\n\ntemplate <class D>\nstruct weak_dispatch : D {\n  using D::operator();\n  template <class... Args>\n  [[noreturn]] details::wildcard operator()(std::nullptr_t, Args&&...)\n      { ___PRO_THROW(not_implemented{}); }\n};\n\n#define ___PRO_EXPAND_IMPL(__X) __X\n#define ___PRO_EXPAND_MACRO_IMPL( \\\n    __MACRO, __1, __2, __3, __NAME, ...) \\\n    __MACRO##_##__NAME\n#define ___PRO_EXPAND_MACRO(__MACRO, ...) \\\n    ___PRO_EXPAND_IMPL(___PRO_EXPAND_MACRO_IMPL( \\\n        __MACRO, __VA_ARGS__, 3, 2)(__VA_ARGS__))\n\n#define ___PRO_DEF_MEM_ACCESSOR(__Q, __SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class __R, \\\n        class... __Args> \\\n    struct accessor<__F, __IsDirect, __D, __R(__Args...) __Q> { \\\n      ___PRO_GEN_DEBUG_SYMBOL_FOR_MEM_ACCESSOR(__VA_ARGS__) \\\n      __R __VA_ARGS__(__Args... __args) __Q { \\\n        return ::pro::proxy_invoke<__IsDirect, __D, __R(__Args...) __Q>( \\\n            __SELF, ::std::forward<__Args>(__args)...); \\\n      } \\\n    }\n#define ___PRO_DEF_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FNAME) \\\n    struct __NAME { \\\n      template <class __T, class... __Args> \\\n      decltype(auto) operator()(__T&& __self, __Args&&... __args) \\\n          ___PRO_DIRECT_FUNC_IMPL(::std::forward<__T>(__self) \\\n              .__FUNC(::std::forward<__Args>(__args)...)) \\\n      ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_MEM_ACCESSOR, __FNAME) \\\n    }\n#define ___PRO_DEF_MEM_DISPATCH_2(__NAME, __FUNC) \\\n    ___PRO_DEF_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FUNC)\n#define ___PRO_DEF_MEM_DISPATCH_3(__NAME, __FUNC, __FNAME) \\\n    ___PRO_DEF_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FNAME)\n#define PRO_DEF_MEM_DISPATCH(__NAME, ...) \\\n    ___PRO_EXPAND_MACRO(___PRO_DEF_MEM_DISPATCH, __NAME, __VA_ARGS__)\n\n#define ___PRO_DEF_FREE_ACCESSOR(__Q, __NE, __SELF_ARG, __SELF, ...) \\\n    template <class __F, bool __IsDirect, class __D, class __R, \\\n        class... __Args> \\\n    struct accessor<__F, __IsDirect, __D, __R(__Args...) __Q> { \\\n      friend __R __VA_ARGS__(__SELF_ARG, __Args... __args) __NE { \\\n        return ::pro::proxy_invoke<__IsDirect, __D, __R(__Args...) __Q>( \\\n            __SELF, ::std::forward<__Args>(__args)...); \\\n      } \\\n___PRO_DEBUG( \\\n      accessor() noexcept { ::std::ignore = &accessor::_symbol_guard; } \\\n    \\\n     private: \\\n      static inline __R _symbol_guard(__SELF_ARG, __Args... __args) __NE { \\\n        return __VA_ARGS__(::std::forward<decltype(__self)>(__self), \\\n            ::std::forward<__Args>(__args)...); \\\n      } \\\n) \\\n    }\n#define ___PRO_DEF_FREE_DISPATCH_IMPL(__NAME, __FUNC, __FNAME) \\\n    struct __NAME { \\\n      template <class __T, class... __Args> \\\n      decltype(auto) operator()(__T&& __self, __Args&&... __args) \\\n          ___PRO_DIRECT_FUNC_IMPL(__FUNC(::std::forward<__T>(__self), \\\n              ::std::forward<__Args>(__args)...)) \\\n      ___PRO_DEF_FREE_ACCESSOR_TEMPLATE(___PRO_DEF_FREE_ACCESSOR, __FNAME) \\\n    }\n#define ___PRO_DEF_FREE_DISPATCH_2(__NAME, __FUNC) \\\n    ___PRO_DEF_FREE_DISPATCH_IMPL(__NAME, __FUNC, __FUNC)\n#define ___PRO_DEF_FREE_DISPATCH_3(__NAME, __FUNC, __FNAME) \\\n    ___PRO_DEF_FREE_DISPATCH_IMPL(__NAME, __FUNC, __FNAME)\n#define PRO_DEF_FREE_DISPATCH(__NAME, ...) \\\n    ___PRO_EXPAND_MACRO(___PRO_DEF_FREE_DISPATCH, __NAME, __VA_ARGS__)\n\n#define ___PRO_DEF_FREE_AS_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FNAME) \\\n    struct __NAME { \\\n      template <class __T, class... __Args> \\\n      decltype(auto) operator()(__T&& __self, __Args&&... __args) \\\n          ___PRO_DIRECT_FUNC_IMPL(__FUNC(::std::forward<__T>(__self), \\\n              ::std::forward<__Args>(__args)...)) \\\n      ___PRO_DEF_MEM_ACCESSOR_TEMPLATE(___PRO_DEF_MEM_ACCESSOR, __FNAME) \\\n    }\n#define ___PRO_DEF_FREE_AS_MEM_DISPATCH_2(__NAME, __FUNC) \\\n    ___PRO_DEF_FREE_AS_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FUNC)\n#define ___PRO_DEF_FREE_AS_MEM_DISPATCH_3(__NAME, __FUNC, __FNAME) \\\n    ___PRO_DEF_FREE_AS_MEM_DISPATCH_IMPL(__NAME, __FUNC, __FNAME)\n#define PRO_DEF_FREE_AS_MEM_DISPATCH(__NAME, ...) \\\n    ___PRO_EXPAND_MACRO(___PRO_DEF_FREE_AS_MEM_DISPATCH, __NAME, __VA_ARGS__)\n\n#define PRO_DEF_WEAK_DISPATCH(__NAME, __D, __FUNC) \\\n    struct [[deprecated(\"'PRO_DEF_WEAK_DISPATCH' is deprecated. \" \\\n        \"Use pro::weak_dispatch<\" #__D \"> instead.\")]] __NAME : __D { \\\n      using __D::operator(); \\\n      template <class... __Args> \\\n      decltype(auto) operator()(::std::nullptr_t, __Args&&... __args) \\\n          ___PRO_DIRECT_FUNC_IMPL(__FUNC(::std::forward<__Args>(__args)...)) \\\n    }\n\n}  // namespace pro\n\n#if __STDC_HOSTED__\nnamespace std {\n\ntemplate <class F, class CharT>\n    requires(pro::details::facade_traits<F>::template is_invocable<false,\n        pro::details::format_dispatch, pro::details::format_overload_t<CharT>>)\nstruct formatter<pro::proxy_indirect_accessor<F>, CharT> {\n  constexpr auto parse(basic_format_parse_context<CharT>& pc) {\n    for (auto it = pc.begin(); it != pc.end(); ++it) {\n      if (*it == '}') {\n        spec_ = basic_string_view<CharT>{pc.begin(), it + 1};\n        return it;\n      }\n    }\n    return pc.end();\n  }\n\n  template <class OutIt>\n  OutIt format(const pro::proxy_indirect_accessor<F>& ia,\n      basic_format_context<OutIt, CharT>& fc) const {\n    auto& p = pro::access_proxy<F>(ia);\n    if (!p.has_value()) { ___PRO_THROW(format_error{\"null proxy\"}); }\n    return pro::proxy_invoke<false, pro::details::format_dispatch,\n        pro::details::format_overload_t<CharT>>(p, spec_, fc);\n  }\n\n private:\n  basic_string_view<CharT> spec_;\n};\n\n}  // namespace std\n#endif  // __STDC_HOSTED__\n\n#undef ___PRO_THROW\n#undef ___PRO_NO_UNIQUE_ADDRESS_ATTRIBUTE\n\n#endif  // _MSFT_PROXY_\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}