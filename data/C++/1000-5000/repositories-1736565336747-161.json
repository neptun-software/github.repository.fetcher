{
  "metadata": {
    "timestamp": 1736565336747,
    "page": 161,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bombela/backward-cpp",
      "stars": 3860,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0224609375,
          "content": "---\nBasedOnStyle: LLVM\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "build*/\n*.pyc\n*.sw?\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.7109375,
          "content": "language: cpp\ncompiler:\n  - gcc\n  - clang\n\naddons:\n  apt:\n    packages:\n      - valgrind\n\ninstall:\n  - DEPS_DIR=\"${TRAVIS_BUILD_DIR}/deps\"\n  - mkdir ${DEPS_DIR} && cd ${DEPS_DIR}\n  - CMAKE_URL=\"http://www.cmake.org/files/v3.3/cmake-3.3.2-Linux-x86_64.tar.gz\"\n  - mkdir cmake && travis_retry wget --no-check-certificate --quiet -O - ${CMAKE_URL} | tar --strip-components=1 -xz -C cmake\n  - export PATH=${DEPS_DIR}/cmake/bin:${PATH}\n  - pip install --user conan && export PATH=$PATH:$HOME/.local/bin\n  - cd ${TRAVIS_BUILD_DIR}\n  - mkdir build && cd build\n  - cmake .. -DBACKWARD_TESTS=ON\n  - cmake --build .\n\nscript:\n  - valgrind ctest .. --verbose\n  - cd ${TRAVIS_BUILD_DIR} && conan create . Manu343726/testing --build=outdated\n"
        },
        {
          "name": "BackwardConfig.cmake",
          "type": "blob",
          "size": 10.138671875,
          "content": "#\n# BackwardMacros.cmake\n# Copyright 2013 Google Inc. All Rights Reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n###############################################################################\n# OPTIONS\n###############################################################################\n\nset(STACK_WALKING_UNWIND TRUE CACHE BOOL\n\t\"Use compiler's unwind API\")\nset(STACK_WALKING_BACKTRACE FALSE CACHE BOOL\n\t\"Use backtrace from (e)glibc for stack walking\")\nset(STACK_WALKING_LIBUNWIND FALSE CACHE BOOL\n\t\"Use libunwind for stack walking\")\n\nset(STACK_DETAILS_AUTO_DETECT TRUE CACHE BOOL\n\t\"Auto detect backward's stack details dependencies\")\n\nset(STACK_DETAILS_BACKTRACE_SYMBOL FALSE CACHE BOOL\n\t\"Use backtrace from (e)glibc for symbols resolution\")\nset(STACK_DETAILS_DW FALSE CACHE BOOL\n\t\"Use libdw to read debug info\")\nset(STACK_DETAILS_BFD FALSE CACHE BOOL\n\t\"Use libbfd to read debug info\")\nset(STACK_DETAILS_DWARF FALSE CACHE BOOL\n\t\"Use libdwarf/libelf to read debug info\")\n\n###############################################################################\n# CONFIGS\n###############################################################################\ninclude(FindPackageHandleStandardArgs)\n\nif (STACK_WALKING_LIBUNWIND)\n\t# libunwind works on the macOS without having to add special include\n\t# paths or libraries\n\tif (NOT APPLE)\n\t\tfind_path(LIBUNWIND_INCLUDE_DIR NAMES \"libunwind.h\")\n\t\tfind_library(LIBUNWIND_LIBRARY unwind)\n\n\t\tif (LIBUNWIND_LIBRARY)\n\t\t\tinclude(CheckSymbolExists)\n\t\t\tcheck_symbol_exists(UNW_INIT_SIGNAL_FRAME libunwind.h HAVE_UNW_INIT_SIGNAL_FRAME)\n\t\t\tif (NOT HAVE_UNW_INIT_SIGNAL_FRAME)\n\t\t\t\tmessage(STATUS \"libunwind does not support unwinding from signal handler frames\")\n\t\t\tendif()\n\t\tendif()\n\n\t\tset(LIBUNWIND_INCLUDE_DIRS ${LIBUNWIND_INCLUDE_DIR})\n\t\tset(LIBDWARF_LIBRARIES ${LIBUNWIND_LIBRARY})\n\t\tfind_package_handle_standard_args(libunwind DEFAULT_MSG\n\t\t\tLIBUNWIND_LIBRARY LIBUNWIND_INCLUDE_DIR)\n\t\tmark_as_advanced(LIBUNWIND_INCLUDE_DIR LIBUNWIND_LIBRARY)\n\t\tlist(APPEND _BACKWARD_LIBRARIES ${LIBUNWIND_LIBRARY})\n\tendif()\n\n\t# Disable other unwinders if libunwind is found\n\tset(STACK_WALKING_UNWIND FALSE)\n\tset(STACK_WALKING_BACKTRACE FALSE)\nendif()\n\nif (${STACK_DETAILS_AUTO_DETECT})\n\tif(NOT CMAKE_VERSION VERSION_LESS 3.17)\n\t\tset(_name_mismatched_arg NAME_MISMATCHED)\n\tendif()\n\t# find libdw\n\tfind_path(LIBDW_INCLUDE_DIR NAMES \"elfutils/libdw.h\" \"elfutils/libdwfl.h\")\n\tfind_library(LIBDW_LIBRARY dw)\n\t# in case it's statically linked, look for all the possible dependencies\n\tfind_library(LIBELF_LIBRARY elf)\n\tfind_library(LIBPTHREAD_LIBRARY pthread)\n\tfind_library(LIBZ_LIBRARY z)\n\tfind_library(LIBBZ2_LIBRARY bz2)\n\tfind_library(LIBLZMA_LIBRARY lzma)\n\tfind_library(LIBZSTD_LIBRARY zstd)\n\tset(LIBDW_INCLUDE_DIRS ${LIBDW_INCLUDE_DIR} )\n\tset(LIBDW_LIBRARIES ${LIBDW_LIBRARY}\n\t\t$<$<BOOL:${LIBELF_LIBRARY}>:${LIBELF_LIBRARY}>\n\t\t$<$<BOOL:${LIBPTHREAD_LIBRARY}>:${LIBPTHREAD_LIBRARY}>\n\t\t$<$<BOOL:${LIBZ_LIBRARY}>:${LIBZ_LIBRARY}>\n\t\t$<$<BOOL:${LIBBZ2_LIBRARY}>:${LIBBZ2_LIBRARY}>\n\t\t$<$<BOOL:${LIBLZMA_LIBRARY}>:${LIBLZMA_LIBRARY}>\n\t\t$<$<BOOL:${LIBZSTD_LIBRARY}>:${LIBZSTD_LIBRARY}>)\n\tfind_package_handle_standard_args(libdw ${_name_mismatched_arg}\n\t\tREQUIRED_VARS LIBDW_LIBRARY LIBDW_INCLUDE_DIR)\n\tmark_as_advanced(LIBDW_INCLUDE_DIR LIBDW_LIBRARY)\n\n\t# find libbfd\n\tfind_path(LIBBFD_INCLUDE_DIR NAMES \"bfd.h\")\n\tfind_path(LIBDL_INCLUDE_DIR NAMES \"dlfcn.h\")\n\tfind_library(LIBBFD_LIBRARY bfd)\n\tfind_library(LIBDL_LIBRARY dl)\n\tset(LIBBFD_INCLUDE_DIRS ${LIBBFD_INCLUDE_DIR} ${LIBDL_INCLUDE_DIR})\n\tset(LIBBFD_LIBRARIES ${LIBBFD_LIBRARY} ${LIBDL_LIBRARY})\n\tfind_package_handle_standard_args(libbfd ${_name_mismatched_arg}\n\t\tREQUIRED_VARS LIBBFD_LIBRARY LIBBFD_INCLUDE_DIR\n\t\tLIBDL_LIBRARY LIBDL_INCLUDE_DIR)\n\tmark_as_advanced(LIBBFD_INCLUDE_DIR LIBBFD_LIBRARY\n\t\tLIBDL_INCLUDE_DIR LIBDL_LIBRARY)\n\n\t# find libdwarf\n\tfind_path(LIBDWARF_INCLUDE_DIR NAMES \"libdwarf.h\" PATH_SUFFIXES libdwarf)\n\tfind_path(LIBELF_INCLUDE_DIR NAMES \"libelf.h\")\n\tfind_path(LIBDL_INCLUDE_DIR NAMES \"dlfcn.h\")\n\tfind_library(LIBDWARF_LIBRARY dwarf)\n\tfind_library(LIBELF_LIBRARY elf)\n\tfind_library(LIBDL_LIBRARY dl)\n\tset(LIBDWARF_INCLUDE_DIRS ${LIBDWARF_INCLUDE_DIR} ${LIBELF_INCLUDE_DIR} ${LIBDL_INCLUDE_DIR})\n\tset(LIBDWARF_LIBRARIES ${LIBDWARF_LIBRARY} ${LIBELF_LIBRARY} ${LIBDL_LIBRARY})\n\tfind_package_handle_standard_args(libdwarf ${_name_mismatched_arg}\n\t\tREQUIRED_VARS LIBDWARF_LIBRARY LIBDWARF_INCLUDE_DIR\n\t\tLIBELF_LIBRARY LIBELF_INCLUDE_DIR\n\t\tLIBDL_LIBRARY LIBDL_INCLUDE_DIR)\n\tmark_as_advanced(LIBDWARF_INCLUDE_DIR LIBDWARF_LIBRARY\n\t\tLIBELF_INCLUDE_DIR LIBELF_LIBRARY\n\t\tLIBDL_INCLUDE_DIR LIBDL_LIBRARY)\n\n\tif (LIBDW_FOUND)\n\t\tLIST(APPEND _BACKWARD_INCLUDE_DIRS ${LIBDW_INCLUDE_DIRS})\n\t\tLIST(APPEND _BACKWARD_LIBRARIES ${LIBDW_LIBRARIES})\n\t\tset(STACK_DETAILS_DW TRUE)\n\t\tset(STACK_DETAILS_BFD FALSE)\n\t\tset(STACK_DETAILS_DWARF FALSE)\n\t\tset(STACK_DETAILS_BACKTRACE_SYMBOL FALSE)\n\telseif(LIBBFD_FOUND)\n\t\tLIST(APPEND _BACKWARD_INCLUDE_DIRS ${LIBBFD_INCLUDE_DIRS})\n\t\tLIST(APPEND _BACKWARD_LIBRARIES ${LIBBFD_LIBRARIES})\n\n\t\t# If we attempt to link against static bfd, make sure to link its dependencies, too\n\t\tget_filename_component(bfd_lib_ext \"${LIBBFD_LIBRARY}\" EXT)\n\t\tif (bfd_lib_ext STREQUAL \"${CMAKE_STATIC_LIBRARY_SUFFIX}\")\n\t\t\tfind_library(LIBSFRAME_LIBRARY NAMES sframe)\n\t\t\tif (LIBSFRAME_LIBRARY)\n\t\t\t\tlist(APPEND _BACKWARD_LIBRARIES ${LIBSFRAME_LIBRARY})\n\t\t\tendif()\n\n\t\t\tlist(APPEND _BACKWARD_LIBRARIES iberty z)\n\t\tendif()\n\n\t\tset(STACK_DETAILS_DW FALSE)\n\t\tset(STACK_DETAILS_BFD TRUE)\n\t\tset(STACK_DETAILS_DWARF FALSE)\n\t\tset(STACK_DETAILS_BACKTRACE_SYMBOL FALSE)\n\telseif(LIBDWARF_FOUND)\n\t\tLIST(APPEND _BACKWARD_INCLUDE_DIRS ${LIBDWARF_INCLUDE_DIRS})\n\t\tLIST(APPEND _BACKWARD_LIBRARIES ${LIBDWARF_LIBRARIES})\n\n\t\tset(STACK_DETAILS_DW FALSE)\n\t\tset(STACK_DETAILS_BFD FALSE)\n\t\tset(STACK_DETAILS_DWARF TRUE)\n\t\tset(STACK_DETAILS_BACKTRACE_SYMBOL FALSE)\n\telse()\n\t\tset(STACK_DETAILS_DW FALSE)\n\t\tset(STACK_DETAILS_BFD FALSE)\n\t\tset(STACK_DETAILS_DWARF FALSE)\n\t\tset(STACK_DETAILS_BACKTRACE_SYMBOL TRUE)\n\tendif()\nelse()\n\tif (STACK_DETAILS_DW)\n\t\tLIST(APPEND _BACKWARD_LIBRARIES dw)\n\tendif()\n\n\tif (STACK_DETAILS_BFD)\n\t\tLIST(APPEND _BACKWARD_LIBRARIES bfd dl)\n\tendif()\n\n\tif (STACK_DETAILS_DWARF)\n\t\tLIST(APPEND _BACKWARD_LIBRARIES dwarf elf)\n\tendif()\nendif()\n\nmacro(map_definitions var_prefix define_prefix)\n\tforeach(def ${ARGN})\n\t\tif (${${var_prefix}${def}})\n\t\t\tLIST(APPEND _BACKWARD_DEFINITIONS \"${define_prefix}${def}=1\")\n\t\telse()\n\t\t\tLIST(APPEND _BACKWARD_DEFINITIONS \"${define_prefix}${def}=0\")\n\t\tendif()\n\tendforeach()\nendmacro()\n\nif (NOT _BACKWARD_DEFINITIONS)\n\tmap_definitions(\"STACK_WALKING_\" \"BACKWARD_HAS_\" UNWIND LIBUNWIND BACKTRACE)\n\tmap_definitions(\"STACK_DETAILS_\" \"BACKWARD_HAS_\" BACKTRACE_SYMBOL DW BFD DWARF)\nendif()\n\nif(WIN32)\n\tlist(APPEND _BACKWARD_LIBRARIES dbghelp psapi)\n\tif(MINGW)\n\t\tinclude(CheckCXXCompilerFlag)\n\t\tcheck_cxx_compiler_flag(-gcodeview SUPPORT_WINDOWS_DEBUG_INFO)\t\n\t\tif(SUPPORT_WINDOWS_DEBUG_INFO)\n\t\t\tset(CMAKE_EXE_LINKER_FLAGS \"-Wl,--pdb= \")\n\t\t\tadd_compile_options(-gcodeview)\n\t\telse()\n\t\t\tset(MINGW_MSVCR_LIBRARY \"msvcr90$<$<CONFIG:DEBUG>:d>\" CACHE STRING \"Mingw MSVC runtime import library\")\n\t\t\tlist(APPEND _BACKWARD_LIBRARIES ${MINGW_MSVCR_LIBRARY})\n\t\tendif()\n\tendif()\t\nendif()\n\nset(BACKWARD_INCLUDE_DIR\n\t$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n\t$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n)\n\nset(BACKWARD_HAS_EXTERNAL_LIBRARIES FALSE)\nset(FIND_PACKAGE_REQUIRED_VARS BACKWARD_INCLUDE_DIR)\nif(DEFINED _BACKWARD_LIBRARIES)\n\tset(BACKWARD_HAS_EXTERNAL_LIBRARIES TRUE)\n\tlist(APPEND FIND_PACKAGE_REQUIRED_VARS _BACKWARD_LIBRARIES)\nendif()\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(Backward\n\tREQUIRED_VARS ${FIND_PACKAGE_REQUIRED_VARS}\n)\nlist(APPEND _BACKWARD_INCLUDE_DIRS ${BACKWARD_INCLUDE_DIR})\n\n# add_backward, optional bool argument; if passed and true, backward will be included as a system header\nmacro(add_backward target)\n\tmessage(DEPRECATION \"The add_backward() macro is deprecated, use target_link_libraries() to link to \"\n\t        \"one of the exported targets: Backward::Interface, Backward::Object, or Backward::Backward.\"\n\t)\n\tif (\"${ARGN}\")\n\t\ttarget_include_directories(${target} SYSTEM PRIVATE ${BACKWARD_INCLUDE_DIRS})\n\telse()\n\t\ttarget_include_directories(${target} PRIVATE ${BACKWARD_INCLUDE_DIRS})\n\tendif()\n\tset_property(TARGET ${target} APPEND PROPERTY COMPILE_DEFINITIONS ${BACKWARD_DEFINITIONS})\n\tset_property(TARGET ${target} APPEND PROPERTY LINK_LIBRARIES ${BACKWARD_LIBRARIES})\nendmacro()\n\nset(BACKWARD_INCLUDE_DIRS ${_BACKWARD_INCLUDE_DIRS} CACHE INTERNAL \"BACKWARD_INCLUDE_DIRS\")\nset(BACKWARD_DEFINITIONS ${_BACKWARD_DEFINITIONS} CACHE INTERNAL \"BACKWARD_DEFINITIONS\")\nset(BACKWARD_LIBRARIES ${_BACKWARD_LIBRARIES} CACHE INTERNAL \"BACKWARD_LIBRARIES\")\nmark_as_advanced(BACKWARD_INCLUDE_DIRS BACKWARD_DEFINITIONS BACKWARD_LIBRARIES)\n\n# Expand each definition in BACKWARD_DEFINITIONS to its own cmake var and export\n# to outer scope\nforeach(var ${BACKWARD_DEFINITIONS})\n\tstring(REPLACE \"=\" \";\" var_as_list ${var})\n\tlist(GET var_as_list 0 var_name)\n\tlist(GET var_as_list 1 var_value)\n\tset(${var_name} ${var_value})\n\tmark_as_advanced(${var_name})\nendforeach()\n\n# if this file is used from the install tree by find_package(), include the\n# file CMake-generated file where the targets are defined\nif(EXISTS ${CMAKE_CURRENT_LIST_DIR}/BackwardTargets.cmake)\n\tinclude(${CMAKE_CURRENT_LIST_DIR}/BackwardTargets.cmake)\nendif()\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 6.16015625,
          "content": "#\n# CMakeLists.txt\n# Copyright 2013 Google Inc. All Rights Reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\ncmake_minimum_required(VERSION 3.14)\nproject(backward CXX)\n\n# Introduce variables:\n# * CMAKE_INSTALL_LIBDIR\n# * CMAKE_INSTALL_BINDIR\n# * CMAKE_INSTALL_INCLUDEDIR\ninclude(GNUInstallDirs)\n\ninclude(BackwardConfig.cmake)\n\n###############################################################################\n# OPTIONS\n###############################################################################\n\noption(BACKWARD_SHARED \"Build backward as a shared library\" OFF)\nif(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR AND NOT DEFINED BACKWARD_TESTS)\n\t# If this is a top level CMake project, we most lixely want the tests\n\tset(BACKWARD_TESTS ON CACHE BOOL \"Enable tests\")\nelse()\n\tset(BACKWARD_TESTS OFF CACHE BOOL \"Enable tests\")\nendif()\n\n###############################################################################\n# COMPILER FLAGS\n###############################################################################\n\n# check if compiler is nvcc or nvcc_wrapper\nset(COMPILER_IS_NVCC false)\nget_filename_component(COMPILER_NAME ${CMAKE_CXX_COMPILER} NAME)\nif (COMPILER_NAME MATCHES \"^nvcc\")\n  set(COMPILER_IS_NVCC true)\nendif()\n\nif (DEFINED ENV{OMPI_CXX} OR DEFINED ENV{MPICH_CXX})\n   if ( ($ENV{OMPI_CXX} MATCHES \"nvcc\") OR ($ENV{MPICH_CXX} MATCHES \"nvcc\") )\n     set(COMPILER_IS_NVCC true)\n   endif()\nendif()\n\n# set CXX standard\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nset(CMAKE_CXX_STANDARD 11)\nif (${COMPILER_IS_NVCC})\n  # GNU CXX extensions are not supported by nvcc\n  set(CMAKE_CXX_EXTENSIONS OFF)\nendif()\n\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" OR CMAKE_COMPILER_IS_GNUCXX)\n\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wextra\")\n\tif (NOT ${COMPILER_IS_NVCC})\n\t  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pedantic-errors\")\n\tendif()\n\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g\")\nendif()\n\n###############################################################################\n# BACKWARD INTERFACE\n###############################################################################\n\nadd_library(backward_interface INTERFACE)\nset_target_properties(backward_interface PROPERTIES EXPORT_NAME Interface)\ntarget_compile_definitions(backward_interface INTERFACE ${BACKWARD_DEFINITIONS})\ntarget_include_directories(backward_interface INTERFACE ${BACKWARD_INCLUDE_DIRS})\nif(BACKWARD_HAS_EXTERNAL_LIBRARIES)\n    target_link_libraries(backward_interface INTERFACE ${BACKWARD_LIBRARIES})\nendif()\nadd_library(Backward::Interface ALIAS backward_interface)\n\n###############################################################################\n# BACKWARD OBJECT (Includes backward.cpp)\n# (Note that this target is not exported, since CMake currently does not allow\n# exporting an OBJECT library.)\n###############################################################################\n\nadd_library(backward_object OBJECT backward.cpp)\nset_target_properties(backward_object PROPERTIES EXPORT_NAME Object)\ntarget_link_libraries(backward_object PUBLIC Backward::Interface)\nadd_library(Backward::Object ALIAS backward_object)\n\n###############################################################################\n# BACKWARD LIBRARY (Includes backward.cpp)\n# (Note that the linker will not include unused objects from a static library,\n# unless the -Wl,--whole-archive option (or similar) is used.)\n###############################################################################\n\nset(libtype STATIC)\nif(BACKWARD_SHARED)\n    set(libtype SHARED)\nendif()\nadd_library(backward ${libtype} backward.cpp)\nset_target_properties(backward PROPERTIES EXPORT_NAME Backward)\ntarget_link_libraries(backward PUBLIC Backward::Interface)\nadd_library(Backward::Backward ALIAS backward)\n\n###############################################################################\n# TESTS\n###############################################################################\n\nif(BACKWARD_TESTS)\n\tenable_testing()\n\n\tadd_library(test_main OBJECT test/_test_main.cpp)\n\n\tmacro(backward_add_test src)\n\t\tget_filename_component(name ${src} NAME_WE)\n\t\tset(test_name \"test_${name}\")\n\n\t\tadd_executable(${test_name} ${src} ${ARGN} $<TARGET_OBJECTS:test_main>)\n\n\t\ttarget_link_libraries(${test_name} PRIVATE Backward::Interface)\n\n\t\tadd_test(NAME ${name} COMMAND ${test_name})\n\tendmacro()\n\n\t# Tests without backward.cpp\n\tset(TESTS\n\t\ttest\n\t\tstacktrace\n\t\trectrace\n\t\tselect_signals\n\t\t)\n\n\tforeach(test ${TESTS})\n\t\tbackward_add_test(test/${test}.cpp)\n\tendforeach()\n\n\t# Tests with backward.cpp\n\tset(TESTS\n\t\tsuicide\n\t\t)\n\n\tforeach(test ${TESTS})\n\t\tbackward_add_test(test/${test}.cpp backward.cpp)\n\tendforeach()\nendif()\n\ninstall(\n    FILES \"backward.hpp\"\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n)\ninstall(\n    FILES \"BackwardConfig.cmake\"\n    DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n)\n# check if Backward is being used as a top-level project or included as a subproject\nif(CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR)\n    # export the targets (note that exporting backward_object does not make sense)\n    install(TARGETS backward_interface backward EXPORT BackwardTargets)\n    # install a CMake file for the exported targets\n    install(EXPORT BackwardTargets\n            NAMESPACE Backward::\n            DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\")\nendif()\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0693359375,
          "content": "Copyright 2013 Google Inc. All Rights Reserved.\n\nThe MIT License (MIT)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.6962890625,
          "content": "Backward-cpp [![Conan Center](https://img.shields.io/conan/v/backward-cpp)](https://conan.io/center/recipes/backward-cpp)\n============\n\nBackward is a beautiful stack trace pretty printer for C++.\n\nIf you are bored to see this:\n\n![default trace](doc/rude.png)\n\nBackward will spice it up for you:\n\n![pretty stackstrace](doc/pretty.png)\n\nThere is not much to say. Of course it will be able to display the code\nsnippets only if the source files are accessible (else see trace #4 in the\nexample).\n\nAll \"Source\" lines and code snippet prefixed by a pipe \"|\" are frames inline\nthe next frame.\nYou can see that for the trace #1 in the example, the function\n`you_shall_not_pass()` was inlined in the function `...read2::do_test()` by the\ncompiler.\n\n## Installation\n\n#### Install backward.hpp\n\nBackward is a header only library. So installing Backward is easy, simply drop\na copy of `backward.hpp` along with your other source files in your C++ project.\nYou can also use a git submodule or really any other way that best fits your\nenvironment, as long as you can include `backward.hpp`.\n\n#### Install backward.cpp\n\nIf you want Backward to automatically print a stack trace on most common fatal\nerrors (segfault, abort, un-handled exception...), simply add a copy of\n`backward.cpp` to your project, and don't forget to tell your build system.\n\nThe code in `backward.cpp` is trivial anyway, you can simply copy what it's\ndoing at your convenience. \n\nNote for [folly](https://github.com/facebook/folly) library users: must define `backward::SignalHandling sh;` after `folly::init(&argc, &argv);`.\n\n## Configuration & Dependencies\n\n### Integration with CMake\n\nIf you are using CMake and want to use its configuration abilities to save you\nthe trouble, you can easily integrate Backward, depending on how you obtained\nthe library.\n\nNotice that all approaches are equivalent in the way Backward is added to a\nCMake target, the difference is in how CMake is pointed to the Backward\nsources. Backward defines three targets:\n\n- `Backward::Interface` is an interface target that brings compiler definition\n  flags, include directory, and external libraries. This is all you need to use\n  the `backward.hpp` header library.\n- `Backward::Object` brings `Backward::Interface` and `backward.cpp` as an\n  `OBJECT` CMake library. This target cannot be exported, so it is not\n  available when Backward is used via `find_package`.\n- `Backward::Backward` brings `Backward::Interface` and `backward.cpp` as\n  either `STATIC` or `SHARED` library (depending on the `BACKWARD_SHARED`\n  option). This target is exported and always available, however note that the\n  linker will not include unused objects from a static library, unless the\n  `-Wl,--whole-archive` option (or similar) is used.\n\n#### With `FetchContent()`:\n\nIf you are using a recent version of CMake, you can integrate `backward` via `FetchContent` like below:\n\n```cmake\ninclude(FetchContent)\n\n# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)\nFetchContent_Declare(backward\n    GIT_REPOSITORY https://github.com/bombela/backward-cpp\n    GIT_TAG master  # or a version tag, such as v1.6\n    SYSTEM          # optional, the Backward include directory will be treated as system directory\n)\nFetchContent_MakeAvailable(backward)\n\n# Add Backward to your target (either Backward::Interface, Backward::Object, or Backward::Backward)\ntarget_link_libraries(mytarget PUBLIC Backward::Interface)\n```\n\n#### As a subdirectory:\n\nIn this case you have a subdirectory containing the whole repository of Backward\n(e.g. using [git-submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)),\nin this case you can do:\n\n```cmake\nadd_subdirectory(/path/to/backward-cpp)\n\n# Add Backward to your target (either Backward::Interface, Backward::Object, or Backward::Backward)\ntarget_link_libraries(mytarget PUBLIC Backward::Interface)\n```\n\n#### Modifying `CMAKE_MODULE_PATH`:\n\nIn this case you can have Backward installed as a subdirectory:\n\n```\nlist(APPEND CMAKE_MODULE_PATH /path/to/backward-cpp)\nfind_package(Backward)\n\n# Add Backward to your target (either Backward::Interface or Backward::Backward)\ntarget_link_libraries(mytarget PUBLIC Backward::Interface)\n```\n\n#### Installation through a regular package manager\n\nIn this case you have obtained Backward through a package manager.\n\nPackages currently available:\n- [conda-forge](https://anaconda.org/conda-forge/backward-cpp)\n\n```\nfind_package(Backward)\n\n# Add Backward to your target (either Backward::Interface or Backward::Backward)\ntarget_link_libraries(mytarget PUBLIC Backward::Interface)\n```\n\n### Libraries to unwind the stack\n\nOn Linux and macOS, backtrace can back-trace or \"walk\" the stack using the\nfollowing libraries:\n\n#### unwind\n\nUnwind comes from libgcc, but there is an equivalent inside clang itself. With\nunwind, the stacktrace is as accurate as it can possibly be, since this is\nused by the C++ runtine in gcc/clang for stack unwinding on exception.\n\nNormally libgcc is already linked to your program by default.\n\n#### libunwind from the [libunwind project](https://github.com/libunwind/libunwind)\n\n\tapt-get install binutils-dev (or equivalent)\n\nLibunwind provides, in some cases, a more accurate stacktrace as it knows\nto decode signal handler frames and lets us edit the context registers when\nunwinding, allowing stack traces over bad function references.\n\nFor best results make sure you are using libunwind 1.3 or later, which added\n`unw_init_local2` and support for handling signal frames.\n\nCMake will warn you when configuring if your libunwind version doesn't support\nsignal frames.\n\nOn macOS clang provides a libunwind API compatible library as part of its\nenvironment, so no third party libraries are necessary.\n\n### Compile with debug info\n\nYou need to compile your project with generation of debug symbols enabled,\nusually `-g` with clang++ and g++.\n\nNote that you can use `-g` with any level of optimization, with modern debug\ninformation encoding like DWARF, it only takes space in the binary (it's not\nloaded in memory until your debugger or Backward makes use of it, don't worry),\nand it doesn't impact the code generation (at least on GNU/Linux x86\\_64 for\nwhat I know).\n\nIf you are missing debug information, the stack trace will lack details about\nyour sources.\n\n### Libraries to read the debug info\n\nBackward supports pretty printed stack traces on GNU/Linux, macOS and Windows,\nit will compile fine under other platforms but will not do anything. **Pull\nrequests are welcome :)**\n\nAlso, by default you will get a really basic stack trace, based on the\n`backtrace_symbols` API:\n\n![default trace](doc/nice.png)\n\nYou will need to install some dependencies to get the ultimate stack trace.\nThree libraries are currently supported, the only difference is which one is the\neasiest for you to install, so pick your poison:\n\n#### libbfd from the [GNU/binutils](http://www.gnu.org/software/binutils/)\n\n\tapt-get install binutils-dev (or equivalent)\n\nAnd do not forget to link with the lib: `g++/clang++ -lbfd -ldl ...`\n\nThis library requires dynamic loading. Which is provided by the library `dl`.\nHence why we also link with `-ldl`.\n\nThen define the following before every inclusion of `backward.hpp` (don't\nforget to update `backward.cpp` as well):\n\n\t#define BACKWARD_HAS_BFD 1\n\n#### libdw from the [elfutils](https://fedorahosted.org/elfutils/)\n\n\tapt-get install libdw-dev (or equivalent)\n\nAnd do not forget to link with the lib and inform Backward to use it:\n\n\t#define BACKWARD_HAS_DW 1\n\nOf course you can simply add the define (`-DBACKWARD_HAS_...=1`) and the\nlinkage details in your build system and even auto-detect which library is\ninstalled, it's up to you.\n\n#### [libdwarf](https://sourceforge.net/projects/libdwarf/) and [libelf](http://www.mr511.de/software/english.html)\n\n\tapt-get install libdwarf-dev (or equivalent)\n\nAnd do not forget to link with the lib and inform Backward to use it:\n\n\t#define BACKWARD_HAS_DWARF 1\n\nThere are several alternative implementations of libdwarf and libelf that\nare API compatible so it's possible, although it hasn't been tested, to\nreplace the ones used when developing backward (in bold, below):\n\n* **_libelf_** by [Michael \"Tired\" Riepe](http://www.mr511.de/software/english.html)\n* **_libdwarf_** by [David Anderson](https://www.prevanders.net/dwarf.html)\n* libelf from [elfutils](https://fedorahosted.org/elfutils/)\n* libelf and libdwarf from FreeBSD's [ELF Tool Chain](https://sourceforge.net/p/elftoolchain/wiki/Home/) project\n\n\nOf course you can simply add the define (`-DBACKWARD_HAS_...=1`) and the\nlinkage details in your build system and even auto-detect which library is\ninstalled, it's up to you.\n\nThat's it, you are all set, you should be getting nice stack traces like the\none at the beginning of this document.\n\n## API\n\nIf you don't want to limit yourself to the defaults offered by `backward.cpp`,\nand you want to take some random stack traces for whatever reason and pretty\nprint them the way you love or you decide to send them all to your buddies over\nthe Internet, you will appreciate the simplicity of Backward's API.\n\n### Stacktrace\n\nThe StackTrace class lets you take a \"snapshot\" of the current stack.\nYou can use it like this:\n\n```c++\nusing namespace backward;\nStackTrace st; st.load_here(32);\nPrinter p; p.print(st);\n```\n\nThe public methods are:\n\n```c++\nclass StackTrace { public:\n\t// Take a snapshot of the current stack, with at most \"trace_cnt_max\"\n\t// traces in it. The first trace is the most recent (ie the current\n\t// frame). You can also provide a trace address to load_from() assuming\n\t// the address is a valid stack frame (useful for signal handling traces).\n\t// Both function return size().\n\tsize_t load_here(size_t trace_cnt_max)\n\tsize_t load_from(void* address, size_t trace_cnt_max)\n\n\t// The number of traces loaded. This can be less than \"trace_cnt_max\".\n\tsize_t size() const\n\n\t// A unique id for the thread in which the trace was taken. The value\n\t// 0 means the stack trace comes from the main thread.\n\tsize_t thread_id() const\n\n\t// Retrieve a trace by index. 0 is the most recent trace, size()-1 is\n\t// the oldest one.\n\tTrace operator[](size_t trace_idx)\n};\n```\n\n### TraceResolver\n\nThe `TraceResolver` does the heavy lifting, and intends to transform a simple\n`Trace` from its address into a fully detailed `ResolvedTrace` with the\nfilename of the source, line numbers, inlined functions and so on.\n\nYou can use it like this:\n\n```c++\nusing namespace backward;\nStackTrace st; st.load_here(32);\n\nTraceResolver tr; tr.load_stacktrace(st);\nfor (size_t i = 0; i < st.size(); ++i) {\n\tResolvedTrace trace = tr.resolve(st[i]);\n\tstd::cout << \"#\" << i\n\t\t<< \" \" << trace.object_filename\n\t\t<< \" \" << trace.object_function\n\t\t<< \" [\" << trace.addr << \"]\"\n\t<< std::endl;\n}\n```\n\nThe public methods are:\n\n```c++\nclass TraceResolver { public:\n\t// Pre-load whatever is necessary from the stack trace.\n\ttemplate <class ST>\n\t\tvoid load_stacktrace(ST&)\n\n\t// Resolve a trace. It takes a ResolvedTrace, because a `Trace` is\n\t// implicitly convertible to it.\n\tResolvedTrace resolve(ResolvedTrace t)\n};\n```\n\n### SnippetFactory\n\nThe SnippetFactory is a simple helper class to automatically load and cache\nsource files in order to extract code snippets.\n\n```c++\nclass SnippetFactory { public:\n\t// A snippet is a list of line numbers and line contents.\n\ttypedef std::vector<std::pair<size_t, std::string> > lines_t;\n\n\t// Return a snippet starting at line_start with up to context_size lines.\n\tlines_t get_snippet(const std::string& filename,\n\t\t\tsize_t line_start, size_t context_size)\n\n\t// Return a combined snippet from two different locations and combine them.\n\t// context_size / 2 lines will be extracted from each location.\n\tlines_t get_combined_snippet(\n\t\t\tconst std::string& filename_a, size_t line_a,\n\t\t\tconst std::string& filename_b, size_t line_b,\n\t\t\tsize_t context_size)\n\n\t// Tries to return a unified snippet if the two locations from the same\n\t// file are close enough to fit inside one context_size, else returns\n\t// the equivalent of get_combined_snippet().\n\tlines_t get_coalesced_snippet(const std::string& filename,\n\t\t\tsize_t line_a, size_t line_b, size_t context_size)\n```\n\n### Printer\n\nA simpler way to pretty print a stack trace to the terminal. It will\nautomatically resolve the traces for you:\n\n```c++\nusing namespace backward;\nStackTrace st; st.load_here(32);\nPrinter p;\np.object = true;\np.color_mode = ColorMode::always;\np.address = true;\np.print(st, stderr);\n```\n\nYou can set a few options:\n\n```c++\nclass Printer { public:\n\t// Print a little snippet of code if possible.\n\tbool snippet = true;\n\n\t// Colorize the trace\n\t//  - ColorMode::automatic: Activate colors if possible. For example, when using a TTY on linux.\n\t//  - ColorMode::always: Always use colors.\n\t//  - ColorMode::never: Never use colors.\n\tbool color_mode = ColorMode::automatic;\n\n\t// Add the addresses of every source location to the trace.\n\tbool address = false;\n\n\t// Even if there is a source location, also prints the object\n\t// from where the trace came from.\n\tbool object = false;\n\n\t// Resolve and print a stack trace to the given C FILE* object.\n\t// On linux, if the FILE* object is attached to a TTY,\n\t// color will be used if color_mode is set to automatic.\n\ttemplate <typename StackTrace>\n\t\tFILE* print(StackTrace& st, FILE* fp = stderr);\n\n\t// Resolve and print a stack trace to the given std::ostream object.\n\t// Color will only be used if color_mode is set to always. \n\ttemplate <typename ST>\n\t\tstd::ostream& print(ST& st, std::ostream& os);\n```\n\n\n### SignalHandling\n\nA simple helper class that registers for you the most common signals and other\ncallbacks to segfault, hardware exception, un-handled exception etc.\n\n`backward.cpp` simply uses it like that:\n\n```c++\nbackward::SignalHandling sh;\n```\n\nCreating the object registers all the different signals and hooks. Destroying\nthis object doesn't do anything. It exposes only one method:\n\n```c++\nbool loaded() const // true if loaded with success\n```\n\n**Warning:** The registered signal handlers are not\n[signal safe](https://www.man7.org/linux/man-pages/man7/signal-safety.7.html),\nmostly because backward-cpp and the DWARF decoding libraries are using `malloc`.\nIn case a signal is raised while malloc is holding a lock, a deadlock will\noccur.\n\n### Trace object\n\nTo keep the memory footprint of a loaded `StackTrace` on the low-side, there a\nhierarchy of trace object, from a minimal `Trace `to a `ResolvedTrace`.\n\n#### Simple trace\n\n```c++\nstruct Trace {\n\tvoid*  addr; // address of the trace\n\tsize_t idx;  // its index (0 == most recent)\n};\n```\n\n#### Resolved trace\n\nA `ResolvedTrace` should contains a maximum of details about the location of\nthe trace in the source code. Note that not all fields might be set.\n\n```c++\nstruct ResolvedTrace: public Trace {\n\n\tstruct SourceLoc {\n\t\tstd::string function;\n\t\tstd::string filename;\n\t\tunsigned    line;\n\t\tunsigned    col;\n\t};\n\n\t// In which binary object this trace is located.\n\tstd::string                    object_filename;\n\n\t// The function in the object that contains the trace. This is not the same\n\t// as source.function which can be an function inlined in object_function.\n\tstd::string                    object_function;\n\n\t// The source location of this trace. It is possible for filename to be\n\t// empty and for line/col to be invalid (value 0) if this information\n\t// couldn't be deduced, for example if there is no debug information in the\n\t// binary object.\n\tSourceLoc                      source;\n\n\t// An optional list of \"inliners\". All of these sources locations where\n\t// inlined in the source location of the trace (the attribute right above).\n\t// This is especially useful when you compile with optimizations turned on.\n\ttypedef std::vector<SourceLoc> source_locs_t;\n\tsource_locs_t                  inliners;\n};\n```\n\n## Contact and copyright\n\nFrançois-Xavier Bourlet <bombela@gmail.com>\n\nCopyright 2013-2017 Google Inc. All Rights Reserved.\nMIT License.\n\n### Disclaimer\n\nAlthough this project is owned by Google Inc. this is not a Google supported or\naffiliated project.\n"
        },
        {
          "name": "backward.cpp",
          "type": "blob",
          "size": 1.0703125,
          "content": "// Pick your poison.\n//\n// On GNU/Linux, you have few choices to get the most out of your stack trace.\n//\n// By default you get:\n//\t- object filename\n//\t- function name\n//\n// In order to add:\n//\t- source filename\n//\t- line and column numbers\n//\t- source code snippet (assuming the file is accessible)\n\n// Install one of the following libraries then uncomment one of the macro (or\n// better, add the detection of the lib and the macro definition in your build\n// system)\n\n// - apt-get install libdw-dev ...\n// - g++/clang++ -ldw ...\n// #define BACKWARD_HAS_DW 1\n\n// - apt-get install binutils-dev ...\n// - g++/clang++ -lbfd ...\n// #define BACKWARD_HAS_BFD 1\n\n// - apt-get install libdwarf-dev ...\n// - g++/clang++ -ldwarf ...\n// #define BACKWARD_HAS_DWARF 1\n\n// Regardless of the library you choose to read the debug information,\n// for potentially more detailed stack traces you can use libunwind\n// - apt-get install libunwind-dev\n// - g++/clang++ -lunwind\n// #define BACKWARD_HAS_LIBUNWIND 1\n\n#include \"backward.hpp\"\n\nnamespace backward {\n\nbackward::SignalHandling sh;\n\n} // namespace backward\n"
        },
        {
          "name": "backward.hpp",
          "type": "blob",
          "size": 139.2578125,
          "content": "/*\n * backward.hpp\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifndef H_6B9572DA_A64B_49E6_B234_051480991C89\n#define H_6B9572DA_A64B_49E6_B234_051480991C89\n\n#ifndef __cplusplus\n#error \"It's not going to compile without a C++ compiler...\"\n#endif\n\n#if defined(BACKWARD_CXX11)\n#elif defined(BACKWARD_CXX98)\n#else\n#if __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1800)\n#define BACKWARD_CXX11\n#define BACKWARD_ATLEAST_CXX11\n#define BACKWARD_ATLEAST_CXX98\n#if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)\n#define BACKWARD_ATLEAST_CXX17\n#endif\n#else\n#define BACKWARD_CXX98\n#define BACKWARD_ATLEAST_CXX98\n#endif\n#endif\n\n// You can define one of the following (or leave it to the auto-detection):\n//\n// #define BACKWARD_SYSTEM_LINUX\n//\t- specialization for linux\n//\n// #define BACKWARD_SYSTEM_DARWIN\n//\t- specialization for Mac OS X 10.5 and later.\n//\n// #define BACKWARD_SYSTEM_WINDOWS\n//  - specialization for Windows (Clang 9 and MSVC2017)\n//\n// #define BACKWARD_SYSTEM_UNKNOWN\n//\t- placebo implementation, does nothing.\n//\n#if defined(BACKWARD_SYSTEM_LINUX)\n#elif defined(BACKWARD_SYSTEM_DARWIN)\n#elif defined(BACKWARD_SYSTEM_UNKNOWN)\n#elif defined(BACKWARD_SYSTEM_WINDOWS)\n#else\n#if defined(__linux) || defined(__linux__)\n#define BACKWARD_SYSTEM_LINUX\n#elif defined(__APPLE__)\n#define BACKWARD_SYSTEM_DARWIN\n#elif defined(_WIN32)\n#define BACKWARD_SYSTEM_WINDOWS\n#else\n#define BACKWARD_SYSTEM_UNKNOWN\n#endif\n#endif\n\n#define NOINLINE __attribute__((noinline))\n\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <new>\n#include <sstream>\n#include <streambuf>\n#include <string>\n#include <vector>\n#include <exception>\n#include <iterator>\n\n#if defined(BACKWARD_SYSTEM_LINUX)\n\n// On linux, backtrace can back-trace or \"walk\" the stack using the following\n// libraries:\n//\n// #define BACKWARD_HAS_UNWIND 1\n//  - unwind comes from libgcc, but I saw an equivalent inside clang itself.\n//  - with unwind, the stacktrace is as accurate as it can possibly be, since\n//  this is used by the C++ runtime in gcc/clang for stack unwinding on\n//  exception.\n//  - normally libgcc is already linked to your program by default.\n//\n// #define BACKWARD_HAS_LIBUNWIND 1\n//  - libunwind provides, in some cases, a more accurate stacktrace as it knows\n//  to decode signal handler frames and lets us edit the context registers when\n//  unwinding, allowing stack traces over bad function references.\n//\n// #define BACKWARD_HAS_BACKTRACE == 1\n//  - backtrace seems to be a little bit more portable than libunwind, but on\n//  linux, it uses unwind anyway, but abstract away a tiny information that is\n//  sadly really important in order to get perfectly accurate stack traces.\n//  - backtrace is part of the (e)glib library.\n//\n// The default is:\n// #define BACKWARD_HAS_UNWIND == 1\n//\n// Note that only one of the define should be set to 1 at a time.\n//\n#if BACKWARD_HAS_UNWIND == 1\n#elif BACKWARD_HAS_LIBUNWIND == 1\n#elif BACKWARD_HAS_BACKTRACE == 1\n#else\n#undef BACKWARD_HAS_UNWIND\n#define BACKWARD_HAS_UNWIND 1\n#undef BACKWARD_HAS_LIBUNWIND\n#define BACKWARD_HAS_LIBUNWIND 0\n#undef BACKWARD_HAS_BACKTRACE\n#define BACKWARD_HAS_BACKTRACE 0\n#endif\n\n// On linux, backward can extract detailed information about a stack trace\n// using one of the following libraries:\n//\n// #define BACKWARD_HAS_DW 1\n//  - libdw gives you the most juicy details out of your stack traces:\n//    - object filename\n//    - function name\n//    - source filename\n//    - line and column numbers\n//    - source code snippet (assuming the file is accessible)\n//    - variable names (if not optimized out)\n//    - variable values (not supported by backward-cpp)\n//  - You need to link with the lib \"dw\":\n//    - apt-get install libdw-dev\n//    - g++/clang++ -ldw ...\n//\n// #define BACKWARD_HAS_BFD 1\n//  - With libbfd, you get a fair amount of details:\n//    - object filename\n//    - function name\n//    - source filename\n//    - line numbers\n//    - source code snippet (assuming the file is accessible)\n//  - You need to link with the lib \"bfd\":\n//    - apt-get install binutils-dev\n//    - g++/clang++ -lbfd ...\n//\n// #define BACKWARD_HAS_DWARF 1\n//  - libdwarf gives you the most juicy details out of your stack traces:\n//    - object filename\n//    - function name\n//    - source filename\n//    - line and column numbers\n//    - source code snippet (assuming the file is accessible)\n//    - variable names (if not optimized out)\n//    - variable values (not supported by backward-cpp)\n//  - You need to link with the lib \"dwarf\":\n//    - apt-get install libdwarf-dev\n//    - g++/clang++ -ldwarf ...\n//\n// #define BACKWARD_HAS_BACKTRACE_SYMBOL 1\n//  - backtrace provides minimal details for a stack trace:\n//    - object filename\n//    - function name\n//  - backtrace is part of the (e)glib library.\n//\n// The default is:\n// #define BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n//\n// Note that only one of the define should be set to 1 at a time.\n//\n#if BACKWARD_HAS_DW == 1\n#elif BACKWARD_HAS_BFD == 1\n#elif BACKWARD_HAS_DWARF == 1\n#elif BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n#else\n#undef BACKWARD_HAS_DW\n#define BACKWARD_HAS_DW 0\n#undef BACKWARD_HAS_BFD\n#define BACKWARD_HAS_BFD 0\n#undef BACKWARD_HAS_DWARF\n#define BACKWARD_HAS_DWARF 0\n#undef BACKWARD_HAS_BACKTRACE_SYMBOL\n#define BACKWARD_HAS_BACKTRACE_SYMBOL 1\n#endif\n\n#include <cxxabi.h>\n#include <fcntl.h>\n#ifdef __ANDROID__\n//\t\tOld Android API levels define _Unwind_Ptr in both link.h and\n// unwind.h \t\tRename the one in link.h as we are not going to be using\n// it\n#define _Unwind_Ptr _Unwind_Ptr_Custom\n#include <link.h>\n#undef _Unwind_Ptr\n#else\n#include <link.h>\n#endif\n#if defined(__ppc__) || defined(__powerpc) || defined(__powerpc__) ||        \\\n    defined(__POWERPC__)\n// Linux kernel header required for the struct pt_regs definition\n// to access the NIP (Next Instruction Pointer) register value\n#include <asm/ptrace.h>\n#endif\n#include <signal.h>\n#include <sys/stat.h>\n#include <syscall.h>\n#include <unistd.h>\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#undef _GNU_SOURCE\n#else\n#include <dlfcn.h>\n#endif\n\n#if BACKWARD_HAS_BFD == 1\n//              NOTE: defining PACKAGE{,_VERSION} is required before including\n//                    bfd.h on some platforms, see also:\n//                    https://sourceware.org/bugzilla/show_bug.cgi?id=14243\n#ifndef PACKAGE\n#define PACKAGE\n#endif\n#ifndef PACKAGE_VERSION\n#define PACKAGE_VERSION\n#endif\n#include <bfd.h>\n#endif\n\n#if BACKWARD_HAS_DW == 1\n#include <dwarf.h>\n#include <elfutils/libdw.h>\n#include <elfutils/libdwfl.h>\n#endif\n\n#if BACKWARD_HAS_DWARF == 1\n#include <algorithm>\n#include <dwarf.h>\n#include <libdwarf.h>\n#include <libelf.h>\n#include <map>\n#endif\n\n#if (BACKWARD_HAS_BACKTRACE == 1) || (BACKWARD_HAS_BACKTRACE_SYMBOL == 1)\n// then we shall rely on backtrace\n#include <execinfo.h>\n#endif\n\n#endif // defined(BACKWARD_SYSTEM_LINUX)\n\n#if defined(BACKWARD_SYSTEM_DARWIN)\n// On Darwin, backtrace can back-trace or \"walk\" the stack using the following\n// libraries:\n//\n// #define BACKWARD_HAS_UNWIND 1\n//  - unwind comes from libgcc, but I saw an equivalent inside clang itself.\n//  - with unwind, the stacktrace is as accurate as it can possibly be, since\n//  this is used by the C++ runtime in gcc/clang for stack unwinding on\n//  exception.\n//  - normally libgcc is already linked to your program by default.\n//\n// #define BACKWARD_HAS_LIBUNWIND 1\n//  - libunwind comes from clang, which implements an API compatible version.\n//  - libunwind provides, in some cases, a more accurate stacktrace as it knows\n//  to decode signal handler frames and lets us edit the context registers when\n//  unwinding, allowing stack traces over bad function references.\n//\n// #define BACKWARD_HAS_BACKTRACE == 1\n//  - backtrace is available by default, though it does not produce as much\n//  information as another library might.\n//\n// The default is:\n// #define BACKWARD_HAS_UNWIND == 1\n//\n// Note that only one of the define should be set to 1 at a time.\n//\n#if BACKWARD_HAS_UNWIND == 1\n#elif BACKWARD_HAS_BACKTRACE == 1\n#elif BACKWARD_HAS_LIBUNWIND == 1\n#else\n#undef BACKWARD_HAS_UNWIND\n#define BACKWARD_HAS_UNWIND 1\n#undef BACKWARD_HAS_BACKTRACE\n#define BACKWARD_HAS_BACKTRACE 0\n#undef BACKWARD_HAS_LIBUNWIND\n#define BACKWARD_HAS_LIBUNWIND 0\n#endif\n\n// On Darwin, backward can extract detailed information about a stack trace\n// using one of the following libraries:\n//\n// #define BACKWARD_HAS_BACKTRACE_SYMBOL 1\n//  - backtrace provides minimal details for a stack trace:\n//    - object filename\n//    - function name\n//\n// The default is:\n// #define BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n//\n#if BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n#else\n#undef BACKWARD_HAS_BACKTRACE_SYMBOL\n#define BACKWARD_HAS_BACKTRACE_SYMBOL 1\n#endif\n\n#include <cxxabi.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#if (BACKWARD_HAS_BACKTRACE == 1) || (BACKWARD_HAS_BACKTRACE_SYMBOL == 1)\n#include <execinfo.h>\n#endif\n#endif // defined(BACKWARD_SYSTEM_DARWIN)\n\n#if defined(BACKWARD_SYSTEM_WINDOWS)\n\n#include <condition_variable>\n#include <mutex>\n#include <thread>\n\n#include <basetsd.h>\n\n#ifdef _WIN64\ntypedef SSIZE_T ssize_t;\n#else\ntypedef int ssize_t;\n#endif\n\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include <windows.h>\n#include <winnt.h>\n\n#include <psapi.h>\n#include <signal.h>\n\n#ifndef __clang__\n#undef NOINLINE\n#define NOINLINE __declspec(noinline)\n#endif\n\n#ifdef _MSC_VER\n#pragma comment(lib, \"psapi.lib\")\n#pragma comment(lib, \"dbghelp.lib\")\n#endif\n\n// Comment / packing is from stackoverflow:\n// https://stackoverflow.com/questions/6205981/windows-c-stack-trace-from-a-running-app/28276227#28276227\n// Some versions of imagehlp.dll lack the proper packing directives themselves\n// so we need to do it.\n#pragma pack(push, before_imagehlp, 8)\n#include <imagehlp.h>\n#pragma pack(pop, before_imagehlp)\n\n// TODO maybe these should be undefined somewhere else?\n#undef BACKWARD_HAS_UNWIND\n#undef BACKWARD_HAS_BACKTRACE\n#if BACKWARD_HAS_PDB_SYMBOL == 1\n#else\n#undef BACKWARD_HAS_PDB_SYMBOL\n#define BACKWARD_HAS_PDB_SYMBOL 1\n#endif\n\n#endif\n\n#if BACKWARD_HAS_UNWIND == 1\n\n#include <unwind.h>\n// while gcc's unwind.h defines something like that:\n//  extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);\n//  extern _Unwind_Ptr _Unwind_GetIPInfo (struct _Unwind_Context *, int *);\n//\n// clang's unwind.h defines something like this:\n//  uintptr_t _Unwind_GetIP(struct _Unwind_Context* __context);\n//\n// Even if the _Unwind_GetIPInfo can be linked to, it is not declared, worse we\n// cannot just redeclare it because clang's unwind.h doesn't define _Unwind_Ptr\n// anyway.\n//\n// Luckily we can play on the fact that the guard macros have a different name:\n#ifdef __CLANG_UNWIND_H\n// In fact, this function still comes from libgcc (on my different linux boxes,\n// clang links against libgcc).\n#include <inttypes.h>\nextern \"C\" uintptr_t _Unwind_GetIPInfo(_Unwind_Context *, int *);\n#endif\n\n#endif // BACKWARD_HAS_UNWIND == 1\n\n#if BACKWARD_HAS_LIBUNWIND == 1\n#define UNW_LOCAL_ONLY\n#include <libunwind.h>\n#endif // BACKWARD_HAS_LIBUNWIND == 1\n\n#ifdef BACKWARD_ATLEAST_CXX11\n#include <unordered_map>\n#include <utility> // for std::swap\nnamespace backward {\nnamespace details {\ntemplate <typename K, typename V> struct hashtable {\n  typedef std::unordered_map<K, V> type;\n};\nusing std::move;\n} // namespace details\n} // namespace backward\n#else // NOT BACKWARD_ATLEAST_CXX11\n#define nullptr NULL\n#define override\n#include <map>\nnamespace backward {\nnamespace details {\ntemplate <typename K, typename V> struct hashtable {\n  typedef std::map<K, V> type;\n};\ntemplate <typename T> const T &move(const T &v) { return v; }\ntemplate <typename T> T &move(T &v) { return v; }\n} // namespace details\n} // namespace backward\n#endif // BACKWARD_ATLEAST_CXX11\n\nnamespace backward {\nnamespace details {\n#if defined(BACKWARD_SYSTEM_WINDOWS)\nconst char kBackwardPathDelimiter[] = \";\";\n#else\nconst char kBackwardPathDelimiter[] = \":\";\n#endif\n} // namespace details\n} // namespace backward\n\nnamespace backward {\n\nnamespace system_tag {\nstruct linux_tag; // seems that I cannot call that \"linux\" because the name\n// is already defined... so I am adding _tag everywhere.\nstruct darwin_tag;\nstruct windows_tag;\nstruct unknown_tag;\n\n#if defined(BACKWARD_SYSTEM_LINUX)\ntypedef linux_tag current_tag;\n#elif defined(BACKWARD_SYSTEM_DARWIN)\ntypedef darwin_tag current_tag;\n#elif defined(BACKWARD_SYSTEM_WINDOWS)\ntypedef windows_tag current_tag;\n#elif defined(BACKWARD_SYSTEM_UNKNOWN)\ntypedef unknown_tag current_tag;\n#else\n#error \"May I please get my system defines?\"\n#endif\n} // namespace system_tag\n\nnamespace trace_resolver_tag {\n#if defined(BACKWARD_SYSTEM_LINUX)\nstruct libdw;\nstruct libbfd;\nstruct libdwarf;\nstruct backtrace_symbol;\n\n#if BACKWARD_HAS_DW == 1\ntypedef libdw current;\n#elif BACKWARD_HAS_BFD == 1\ntypedef libbfd current;\n#elif BACKWARD_HAS_DWARF == 1\ntypedef libdwarf current;\n#elif BACKWARD_HAS_BACKTRACE_SYMBOL == 1\ntypedef backtrace_symbol current;\n#else\n#error \"You shall not pass, until you know what you want.\"\n#endif\n#elif defined(BACKWARD_SYSTEM_DARWIN)\nstruct backtrace_symbol;\n\n#if BACKWARD_HAS_BACKTRACE_SYMBOL == 1\ntypedef backtrace_symbol current;\n#else\n#error \"You shall not pass, until you know what you want.\"\n#endif\n#elif defined(BACKWARD_SYSTEM_WINDOWS)\nstruct pdb_symbol;\n#if BACKWARD_HAS_PDB_SYMBOL == 1\ntypedef pdb_symbol current;\n#else\n#error \"You shall not pass, until you know what you want.\"\n#endif\n#endif\n} // namespace trace_resolver_tag\n\nnamespace details {\n\ntemplate <typename T> struct rm_ptr { typedef T type; };\n\ntemplate <typename T> struct rm_ptr<T *> { typedef T type; };\n\ntemplate <typename T> struct rm_ptr<const T *> { typedef const T type; };\n\ntemplate <typename R, typename T, R (*F)(T)> struct deleter {\n  template <typename U> void operator()(U &ptr) const { (*F)(ptr); }\n};\n\ntemplate <typename T> struct default_delete {\n  void operator()(T &ptr) const { delete ptr; }\n};\n\ntemplate <typename T, typename Deleter = deleter<void, void *, &::free> >\nclass handle {\n  struct dummy;\n  T _val;\n  bool _empty;\n\n#ifdef BACKWARD_ATLEAST_CXX11\n  handle(const handle &) = delete;\n  handle &operator=(const handle &) = delete;\n#endif\n\npublic:\n  ~handle() {\n    if (!_empty) {\n      Deleter()(_val);\n    }\n  }\n\n  explicit handle() : _val(), _empty(true) {}\n  explicit handle(T val) : _val(val), _empty(false) {\n    if (!_val)\n      _empty = true;\n  }\n\n#ifdef BACKWARD_ATLEAST_CXX11\n  handle(handle &&from) : _empty(true) { swap(from); }\n  handle &operator=(handle &&from) {\n    swap(from);\n    return *this;\n  }\n#else\n  explicit handle(const handle &from) : _empty(true) {\n    // some sort of poor man's move semantic.\n    swap(const_cast<handle &>(from));\n  }\n  handle &operator=(const handle &from) {\n    // some sort of poor man's move semantic.\n    swap(const_cast<handle &>(from));\n    return *this;\n  }\n#endif\n\n  void reset(T new_val) {\n    handle tmp(new_val);\n    swap(tmp);\n  }\n\n  void update(T new_val) {\n    _val = new_val;\n    _empty = !static_cast<bool>(new_val);\n  }\n\n  operator const dummy *() const {\n    if (_empty) {\n      return nullptr;\n    }\n    return reinterpret_cast<const dummy *>(_val);\n  }\n  T get() { return _val; }\n  T release() {\n    _empty = true;\n    return _val;\n  }\n  void swap(handle &b) {\n    using std::swap;\n    swap(b._val, _val);     // can throw, we are safe here.\n    swap(b._empty, _empty); // should not throw: if you cannot swap two\n    // bools without throwing... It's a lost cause anyway!\n  }\n\n  T &operator->() { return _val; }\n  const T &operator->() const { return _val; }\n\n  typedef typename rm_ptr<T>::type &ref_t;\n  typedef const typename rm_ptr<T>::type &const_ref_t;\n  ref_t operator*() { return *_val; }\n  const_ref_t operator*() const { return *_val; }\n  ref_t operator[](size_t idx) { return _val[idx]; }\n\n  // Watch out, we've got a badass over here\n  T *operator&() {\n    _empty = false;\n    return &_val;\n  }\n};\n\n// Default demangler implementation (do nothing).\ntemplate <typename TAG> struct demangler_impl {\n  static std::string demangle(const char *funcname) { return funcname; }\n};\n\n#if defined(BACKWARD_SYSTEM_LINUX) || defined(BACKWARD_SYSTEM_DARWIN)\n\ntemplate <> struct demangler_impl<system_tag::current_tag> {\n  demangler_impl() : _demangle_buffer_length(0) {}\n\n  std::string demangle(const char *funcname) {\n    using namespace details;\n    char *result = abi::__cxa_demangle(funcname, _demangle_buffer.get(),\n                                       &_demangle_buffer_length, nullptr);\n    if (result) {\n      _demangle_buffer.update(result);\n      return result;\n    }\n    return funcname;\n  }\n\nprivate:\n  details::handle<char *> _demangle_buffer;\n  size_t _demangle_buffer_length;\n};\n\n#endif // BACKWARD_SYSTEM_LINUX || BACKWARD_SYSTEM_DARWIN\n\nstruct demangler : public demangler_impl<system_tag::current_tag> {};\n\n// Split a string on the platform's PATH delimiter.  Example: if delimiter\n// is \":\" then:\n//   \"\"              --> []\n//   \":\"             --> [\"\",\"\"]\n//   \"::\"            --> [\"\",\"\",\"\"]\n//   \"/a/b/c\"        --> [\"/a/b/c\"]\n//   \"/a/b/c:/d/e/f\" --> [\"/a/b/c\",\"/d/e/f\"]\n//   etc.\ninline std::vector<std::string> split_source_prefixes(const std::string &s) {\n  std::vector<std::string> out;\n  size_t last = 0;\n  size_t next = 0;\n  size_t delimiter_size = sizeof(kBackwardPathDelimiter) - 1;\n  while ((next = s.find(kBackwardPathDelimiter, last)) != std::string::npos) {\n    out.push_back(s.substr(last, next - last));\n    last = next + delimiter_size;\n  }\n  if (last <= s.length()) {\n    out.push_back(s.substr(last));\n  }\n  return out;\n}\n\n} // namespace details\n\n/*************** A TRACE ***************/\n\nstruct Trace {\n  void *addr;\n  size_t idx;\n\n  Trace() : addr(nullptr), idx(0) {}\n\n  explicit Trace(void *_addr, size_t _idx) : addr(_addr), idx(_idx) {}\n};\n\nstruct ResolvedTrace : public Trace {\n\n  struct SourceLoc {\n    std::string function;\n    std::string filename;\n    unsigned line;\n    unsigned col;\n\n    SourceLoc() : line(0), col(0) {}\n\n    bool operator==(const SourceLoc &b) const {\n      return function == b.function && filename == b.filename &&\n             line == b.line && col == b.col;\n    }\n\n    bool operator!=(const SourceLoc &b) const { return !(*this == b); }\n  };\n\n  // In which binary object this trace is located.\n  std::string object_filename;\n\n  // The function in the object that contain the trace. This is not the same\n  // as source.function which can be an function inlined in object_function.\n  std::string object_function;\n\n  // The source location of this trace. It is possible for filename to be\n  // empty and for line/col to be invalid (value 0) if this information\n  // couldn't be deduced, for example if there is no debug information in the\n  // binary object.\n  SourceLoc source;\n\n  // An optionals list of \"inliners\". All the successive sources location\n  // from where the source location of the trace (the attribute right above)\n  // is inlined. It is especially useful when you compiled with optimization.\n  typedef std::vector<SourceLoc> source_locs_t;\n  source_locs_t inliners;\n\n  ResolvedTrace() : Trace() {}\n  ResolvedTrace(const Trace &mini_trace) : Trace(mini_trace) {}\n};\n\n/*************** STACK TRACE ***************/\n\n// default implemention.\ntemplate <typename TAG> class StackTraceImpl {\npublic:\n  size_t size() const { return 0; }\n  Trace operator[](size_t) const { return Trace(); }\n  size_t load_here(size_t = 0) { return 0; }\n  size_t load_from(void *, size_t = 0, void * = nullptr, void * = nullptr) {\n    return 0;\n  }\n  size_t thread_id() const { return 0; }\n  void skip_n_firsts(size_t) {}\n  void *const *begin() const { return nullptr; }\n};\n\nclass StackTraceImplBase {\npublic:\n  StackTraceImplBase()\n      : _thread_id(0), _skip(0), _context(nullptr), _error_addr(nullptr) {}\n\n  size_t thread_id() const { return _thread_id; }\n\n  void skip_n_firsts(size_t n) { _skip = n; }\n\nprotected:\n  void load_thread_info() {\n#ifdef BACKWARD_SYSTEM_LINUX\n#ifndef __ANDROID__\n    _thread_id = static_cast<size_t>(syscall(SYS_gettid));\n#else\n    _thread_id = static_cast<size_t>(gettid());\n#endif\n    if (_thread_id == static_cast<size_t>(getpid())) {\n      // If the thread is the main one, let's hide that.\n      // I like to keep little secret sometimes.\n      _thread_id = 0;\n    }\n#elif defined(BACKWARD_SYSTEM_DARWIN)\n    _thread_id = reinterpret_cast<size_t>(pthread_self());\n    if (pthread_main_np() == 1) {\n      // If the thread is the main one, let's hide that.\n      _thread_id = 0;\n    }\n#endif\n  }\n\n  void set_context(void *context) { _context = context; }\n  void *context() const { return _context; }\n\n  void set_error_addr(void *error_addr) { _error_addr = error_addr; }\n  void *error_addr() const { return _error_addr; }\n\n  size_t skip_n_firsts() const { return _skip; }\n\nprivate:\n  size_t _thread_id;\n  size_t _skip;\n  void *_context;\n  void *_error_addr;\n};\n\nclass StackTraceImplHolder : public StackTraceImplBase {\npublic:\n  size_t size() const {\n    return (_stacktrace.size() >= skip_n_firsts())\n               ? _stacktrace.size() - skip_n_firsts()\n               : 0;\n  }\n  Trace operator[](size_t idx) const {\n    if (idx >= size()) {\n      return Trace();\n    }\n    return Trace(_stacktrace[idx + skip_n_firsts()], idx);\n  }\n  void *const *begin() const {\n    if (size()) {\n      return &_stacktrace[skip_n_firsts()];\n    }\n    return nullptr;\n  }\n\nprotected:\n  std::vector<void *> _stacktrace;\n};\n\n#if BACKWARD_HAS_UNWIND == 1\n\nnamespace details {\n\ntemplate <typename F> class Unwinder {\npublic:\n  size_t operator()(F &f, size_t depth) {\n    _f = &f;\n    _index = -1;\n    _depth = depth;\n    _Unwind_Backtrace(&this->backtrace_trampoline, this);\n    if (_index == -1) {\n      // _Unwind_Backtrace has failed to obtain any backtraces\n      return 0;\n    } else {\n      return static_cast<size_t>(_index);\n    }\n  }\n\nprivate:\n  F *_f;\n  ssize_t _index;\n  size_t _depth;\n\n  static _Unwind_Reason_Code backtrace_trampoline(_Unwind_Context *ctx,\n                                                  void *self) {\n    return (static_cast<Unwinder *>(self))->backtrace(ctx);\n  }\n\n  _Unwind_Reason_Code backtrace(_Unwind_Context *ctx) {\n    if (_index >= 0 && static_cast<size_t>(_index) >= _depth)\n      return _URC_END_OF_STACK;\n\n    int ip_before_instruction = 0;\n    uintptr_t ip = _Unwind_GetIPInfo(ctx, &ip_before_instruction);\n\n    if (!ip_before_instruction) {\n      // calculating 0-1 for unsigned, looks like a possible bug to sanitizers,\n      // so let's do it explicitly:\n      if (ip == 0) {\n        ip = std::numeric_limits<uintptr_t>::max(); // set it to 0xffff... (as\n                                                    // from casting 0-1)\n      } else {\n        ip -= 1; // else just normally decrement it (no overflow/underflow will\n                 // happen)\n      }\n    }\n\n    if (_index >= 0) { // ignore first frame.\n      (*_f)(static_cast<size_t>(_index), reinterpret_cast<void *>(ip));\n    }\n    _index += 1;\n    return _URC_NO_REASON;\n  }\n};\n\ntemplate <typename F> size_t unwind(F f, size_t depth) {\n  Unwinder<F> unwinder;\n  return unwinder(f, depth);\n}\n\n} // namespace details\n\ntemplate <>\nclass StackTraceImpl<system_tag::current_tag> : public StackTraceImplHolder {\npublic:\n  NOINLINE\n  size_t load_here(size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    load_thread_info();\n    set_context(context);\n    set_error_addr(error_addr);\n    if (depth == 0) {\n      return 0;\n    }\n    _stacktrace.resize(depth);\n    size_t trace_cnt = details::unwind(callback(*this), depth);\n    _stacktrace.resize(trace_cnt);\n    skip_n_firsts(0);\n    return size();\n  }\n  size_t load_from(void *addr, size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    load_here(depth + 8, context, error_addr);\n\n    for (size_t i = 0; i < _stacktrace.size(); ++i) {\n      if (_stacktrace[i] == addr) {\n        skip_n_firsts(i);\n        break;\n      }\n    }\n\n    _stacktrace.resize(std::min(_stacktrace.size(), skip_n_firsts() + depth));\n    return size();\n  }\n\nprivate:\n  struct callback {\n    StackTraceImpl &self;\n    callback(StackTraceImpl &_self) : self(_self) {}\n\n    void operator()(size_t idx, void *addr) { self._stacktrace[idx] = addr; }\n  };\n};\n\n#elif BACKWARD_HAS_LIBUNWIND == 1\n\ntemplate <>\nclass StackTraceImpl<system_tag::current_tag> : public StackTraceImplHolder {\npublic:\n  __attribute__((noinline)) size_t load_here(size_t depth = 32,\n                                             void *_context = nullptr,\n                                             void *_error_addr = nullptr) {\n    set_context(_context);\n    set_error_addr(_error_addr);\n    load_thread_info();\n    if (depth == 0) {\n      return 0;\n    }\n    _stacktrace.resize(depth + 1);\n\n    int result = 0;\n\n    unw_context_t ctx;\n    size_t index = 0;\n\n    // Add the tail call. If the Instruction Pointer is the crash address it\n    // means we got a bad function pointer dereference, so we \"unwind\" the\n    // bad pointer manually by using the return address pointed to by the\n    // Stack Pointer as the Instruction Pointer and letting libunwind do\n    // the rest\n\n    if (context()) {\n      ucontext_t *uctx = reinterpret_cast<ucontext_t *>(context());\n#ifdef REG_RIP         // x86_64\n      if (uctx->uc_mcontext.gregs[REG_RIP] ==\n          reinterpret_cast<greg_t>(error_addr())) {\n        uctx->uc_mcontext.gregs[REG_RIP] =\n            *reinterpret_cast<size_t *>(uctx->uc_mcontext.gregs[REG_RSP]);\n      }\n      _stacktrace[index] =\n          reinterpret_cast<void *>(uctx->uc_mcontext.gregs[REG_RIP]);\n      ++index;\n      ctx = *reinterpret_cast<unw_context_t *>(uctx);\n#elif defined(REG_EIP) // x86_32\n      if (uctx->uc_mcontext.gregs[REG_EIP] ==\n          reinterpret_cast<greg_t>(error_addr())) {\n        uctx->uc_mcontext.gregs[REG_EIP] =\n            *reinterpret_cast<size_t *>(uctx->uc_mcontext.gregs[REG_ESP]);\n      }\n      _stacktrace[index] =\n          reinterpret_cast<void *>(uctx->uc_mcontext.gregs[REG_EIP]);\n      ++index;\n      ctx = *reinterpret_cast<unw_context_t *>(uctx);\n#elif defined(__arm__)\n      // libunwind uses its own context type for ARM unwinding.\n      // Copy the registers from the signal handler's context so we can\n      // unwind\n      unw_getcontext(&ctx);\n      ctx.regs[UNW_ARM_R0] = uctx->uc_mcontext.arm_r0;\n      ctx.regs[UNW_ARM_R1] = uctx->uc_mcontext.arm_r1;\n      ctx.regs[UNW_ARM_R2] = uctx->uc_mcontext.arm_r2;\n      ctx.regs[UNW_ARM_R3] = uctx->uc_mcontext.arm_r3;\n      ctx.regs[UNW_ARM_R4] = uctx->uc_mcontext.arm_r4;\n      ctx.regs[UNW_ARM_R5] = uctx->uc_mcontext.arm_r5;\n      ctx.regs[UNW_ARM_R6] = uctx->uc_mcontext.arm_r6;\n      ctx.regs[UNW_ARM_R7] = uctx->uc_mcontext.arm_r7;\n      ctx.regs[UNW_ARM_R8] = uctx->uc_mcontext.arm_r8;\n      ctx.regs[UNW_ARM_R9] = uctx->uc_mcontext.arm_r9;\n      ctx.regs[UNW_ARM_R10] = uctx->uc_mcontext.arm_r10;\n      ctx.regs[UNW_ARM_R11] = uctx->uc_mcontext.arm_fp;\n      ctx.regs[UNW_ARM_R12] = uctx->uc_mcontext.arm_ip;\n      ctx.regs[UNW_ARM_R13] = uctx->uc_mcontext.arm_sp;\n      ctx.regs[UNW_ARM_R14] = uctx->uc_mcontext.arm_lr;\n      ctx.regs[UNW_ARM_R15] = uctx->uc_mcontext.arm_pc;\n\n      // If we have crashed in the PC use the LR instead, as this was\n      // a bad function dereference\n      if (reinterpret_cast<unsigned long>(error_addr()) ==\n          uctx->uc_mcontext.arm_pc) {\n        ctx.regs[UNW_ARM_R15] =\n            uctx->uc_mcontext.arm_lr - sizeof(unsigned long);\n      }\n      _stacktrace[index] = reinterpret_cast<void *>(ctx.regs[UNW_ARM_R15]);\n      ++index;\n#elif defined(__APPLE__) && defined(__x86_64__)\n      unw_getcontext(&ctx);\n      // OS X's implementation of libunwind uses its own context object\n      // so we need to convert the passed context to libunwind's format\n      // (information about the data layout taken from unw_getcontext.s\n      // in Apple's libunwind source\n      ctx.data[0] = uctx->uc_mcontext->__ss.__rax;\n      ctx.data[1] = uctx->uc_mcontext->__ss.__rbx;\n      ctx.data[2] = uctx->uc_mcontext->__ss.__rcx;\n      ctx.data[3] = uctx->uc_mcontext->__ss.__rdx;\n      ctx.data[4] = uctx->uc_mcontext->__ss.__rdi;\n      ctx.data[5] = uctx->uc_mcontext->__ss.__rsi;\n      ctx.data[6] = uctx->uc_mcontext->__ss.__rbp;\n      ctx.data[7] = uctx->uc_mcontext->__ss.__rsp;\n      ctx.data[8] = uctx->uc_mcontext->__ss.__r8;\n      ctx.data[9] = uctx->uc_mcontext->__ss.__r9;\n      ctx.data[10] = uctx->uc_mcontext->__ss.__r10;\n      ctx.data[11] = uctx->uc_mcontext->__ss.__r11;\n      ctx.data[12] = uctx->uc_mcontext->__ss.__r12;\n      ctx.data[13] = uctx->uc_mcontext->__ss.__r13;\n      ctx.data[14] = uctx->uc_mcontext->__ss.__r14;\n      ctx.data[15] = uctx->uc_mcontext->__ss.__r15;\n      ctx.data[16] = uctx->uc_mcontext->__ss.__rip;\n\n      // If the IP is the same as the crash address we have a bad function\n      // dereference The caller's address is pointed to by %rsp, so we\n      // dereference that value and set it to be the next frame's IP.\n      if (uctx->uc_mcontext->__ss.__rip ==\n          reinterpret_cast<__uint64_t>(error_addr())) {\n        ctx.data[16] =\n            *reinterpret_cast<__uint64_t *>(uctx->uc_mcontext->__ss.__rsp);\n      }\n      _stacktrace[index] = reinterpret_cast<void *>(ctx.data[16]);\n      ++index;\n#elif defined(__APPLE__)\n      unw_getcontext(&ctx)\n          // TODO: Convert the ucontext_t to libunwind's unw_context_t like\n          // we do in 64 bits\n          if (ctx.uc_mcontext->__ss.__eip ==\n              reinterpret_cast<greg_t>(error_addr())) {\n        ctx.uc_mcontext->__ss.__eip = ctx.uc_mcontext->__ss.__esp;\n      }\n      _stacktrace[index] =\n          reinterpret_cast<void *>(ctx.uc_mcontext->__ss.__eip);\n      ++index;\n#endif\n    }\n\n    unw_cursor_t cursor;\n    if (context()) {\n#if defined(UNW_INIT_SIGNAL_FRAME)\n      result = unw_init_local2(&cursor, &ctx, UNW_INIT_SIGNAL_FRAME);\n#else\n      result = unw_init_local(&cursor, &ctx);\n#endif\n    } else {\n      unw_getcontext(&ctx);\n      ;\n      result = unw_init_local(&cursor, &ctx);\n    }\n\n    if (result != 0)\n      return 1;\n\n    unw_word_t ip = 0;\n\n    while (index <= depth && unw_step(&cursor) > 0) {\n      result = unw_get_reg(&cursor, UNW_REG_IP, &ip);\n      if (result == 0) {\n        _stacktrace[index] = reinterpret_cast<void *>(--ip);\n        ++index;\n      }\n    }\n    --index;\n\n    _stacktrace.resize(index + 1);\n    skip_n_firsts(0);\n    return size();\n  }\n\n  size_t load_from(void *addr, size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    load_here(depth + 8, context, error_addr);\n\n    for (size_t i = 0; i < _stacktrace.size(); ++i) {\n      if (_stacktrace[i] == addr) {\n        skip_n_firsts(i);\n        _stacktrace[i] = (void *)((uintptr_t)_stacktrace[i]);\n        break;\n      }\n    }\n\n    _stacktrace.resize(std::min(_stacktrace.size(), skip_n_firsts() + depth));\n    return size();\n  }\n};\n\n#elif defined(BACKWARD_HAS_BACKTRACE)\n\ntemplate <>\nclass StackTraceImpl<system_tag::current_tag> : public StackTraceImplHolder {\npublic:\n  NOINLINE\n  size_t load_here(size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    set_context(context);\n    set_error_addr(error_addr);\n    load_thread_info();\n    if (depth == 0) {\n      return 0;\n    }\n    _stacktrace.resize(depth + 1);\n    size_t trace_cnt = backtrace(&_stacktrace[0], _stacktrace.size());\n    _stacktrace.resize(trace_cnt);\n    skip_n_firsts(1);\n    return size();\n  }\n\n  size_t load_from(void *addr, size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    load_here(depth + 8, context, error_addr);\n\n    for (size_t i = 0; i < _stacktrace.size(); ++i) {\n      if (_stacktrace[i] == addr) {\n        skip_n_firsts(i);\n        _stacktrace[i] = (void *)((uintptr_t)_stacktrace[i] + 1);\n        break;\n      }\n    }\n\n    _stacktrace.resize(std::min(_stacktrace.size(), skip_n_firsts() + depth));\n    return size();\n  }\n};\n\n#elif defined(BACKWARD_SYSTEM_WINDOWS)\n\ntemplate <>\nclass StackTraceImpl<system_tag::current_tag> : public StackTraceImplHolder {\npublic:\n  // We have to load the machine type from the image info\n  // So we first initialize the resolver, and it tells us this info\n  void set_machine_type(DWORD machine_type) { machine_type_ = machine_type; }\n  void set_context(CONTEXT *ctx) { ctx_ = ctx; }\n  void set_thread_handle(HANDLE handle) { thd_ = handle; }\n\n  NOINLINE\n  size_t load_here(size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    set_context(static_cast<CONTEXT*>(context));\n    set_error_addr(error_addr);\n    CONTEXT localCtx; // used when no context is provided\n\n    if (depth == 0) {\n      return 0;\n    }\n\n    if (!ctx_) {\n      ctx_ = &localCtx;\n      RtlCaptureContext(ctx_);\n    }\n\n    if (!thd_) {\n      thd_ = GetCurrentThread();\n    }\n\n    HANDLE process = GetCurrentProcess();\n\n    STACKFRAME64 s;\n    memset(&s, 0, sizeof(STACKFRAME64));\n\n    // TODO: 32 bit context capture\n    s.AddrStack.Mode = AddrModeFlat;\n    s.AddrFrame.Mode = AddrModeFlat;\n    s.AddrPC.Mode = AddrModeFlat;\n#ifdef _M_X64\n    s.AddrPC.Offset = ctx_->Rip;\n    s.AddrStack.Offset = ctx_->Rsp;\n    s.AddrFrame.Offset = ctx_->Rbp;\n#else\n    s.AddrPC.Offset = ctx_->Eip;\n    s.AddrStack.Offset = ctx_->Esp;\n    s.AddrFrame.Offset = ctx_->Ebp;\n#endif\n\n    if (!machine_type_) {\n#ifdef _M_X64\n      machine_type_ = IMAGE_FILE_MACHINE_AMD64;\n#else\n      machine_type_ = IMAGE_FILE_MACHINE_I386;\n#endif\n    }\n\n    for (;;) {\n      // NOTE: this only works if PDBs are already loaded!\n      SetLastError(0);\n      if (!StackWalk64(machine_type_, process, thd_, &s, ctx_, NULL,\n                       SymFunctionTableAccess64, SymGetModuleBase64, NULL))\n        break;\n\n      if (s.AddrReturn.Offset == 0)\n        break;\n\n      _stacktrace.push_back(reinterpret_cast<void *>(s.AddrPC.Offset));\n\n      if (size() >= depth)\n        break;\n    }\n\n    return size();\n  }\n\n  size_t load_from(void *addr, size_t depth = 32, void *context = nullptr,\n                   void *error_addr = nullptr) {\n    load_here(depth + 8, context, error_addr);\n\n    for (size_t i = 0; i < _stacktrace.size(); ++i) {\n      if (_stacktrace[i] == addr) {\n        skip_n_firsts(i);\n        break;\n      }\n    }\n\n    _stacktrace.resize(std::min(_stacktrace.size(), skip_n_firsts() + depth));\n    return size();\n  }\n\nprivate:\n  DWORD machine_type_ = 0;\n  HANDLE thd_ = 0;\n  CONTEXT *ctx_ = nullptr;\n};\n\n#endif\n\nclass StackTrace : public StackTraceImpl<system_tag::current_tag> {};\n\n/*************** TRACE RESOLVER ***************/\n\nclass TraceResolverImplBase {\npublic:\n  virtual ~TraceResolverImplBase() {}\n\n  virtual void load_addresses(void *const*addresses, int address_count) {\n    (void)addresses;\n    (void)address_count;\n  }\n\n  template <class ST> void load_stacktrace(ST &st) {\n    load_addresses(st.begin(), static_cast<int>(st.size()));\n  }\n\n  virtual ResolvedTrace resolve(ResolvedTrace t) { return t; }\n\nprotected:\n  std::string demangle(const char *funcname) {\n    return _demangler.demangle(funcname);\n  }\n\nprivate:\n  details::demangler _demangler;\n};\n\ntemplate <typename TAG> class TraceResolverImpl;\n\n#ifdef BACKWARD_SYSTEM_UNKNOWN\n\ntemplate <> class TraceResolverImpl<system_tag::unknown_tag>\n    : public TraceResolverImplBase {};\n\n#endif\n\n#ifdef BACKWARD_SYSTEM_LINUX\n\nclass TraceResolverLinuxBase : public TraceResolverImplBase {\npublic:\n  TraceResolverLinuxBase()\n      : argv0_(get_argv0()), exec_path_(read_symlink(\"/proc/self/exe\")) {}\n  std::string resolve_exec_path(Dl_info &symbol_info) const {\n    // mutates symbol_info.dli_fname to be filename to open and returns filename\n    // to display\n    if (symbol_info.dli_fname == argv0_) {\n      // dladdr returns argv[0] in dli_fname for symbols contained in\n      // the main executable, which is not a valid path if the\n      // executable was found by a search of the PATH environment\n      // variable; In that case, we actually open /proc/self/exe, which\n      // is always the actual executable (even if it was deleted/replaced!)\n      // but display the path that /proc/self/exe links to.\n      // However, this right away reduces probability of successful symbol\n      // resolution, because libbfd may try to find *.debug files in the\n      // same dir, in case symbols are stripped. As a result, it may try\n      // to find a file /proc/self/<exe_name>.debug, which obviously does\n      // not exist. /proc/self/exe is a last resort. First load attempt\n      // should go for the original executable file path.\n      symbol_info.dli_fname = \"/proc/self/exe\";\n      return exec_path_;\n    } else {\n      return symbol_info.dli_fname;\n    }\n  }\n\nprivate:\n  std::string argv0_;\n  std::string exec_path_;\n\n  static std::string get_argv0() {\n    std::string argv0;\n    std::ifstream ifs(\"/proc/self/cmdline\");\n    std::getline(ifs, argv0, '\\0');\n    return argv0;\n  }\n\n  static std::string read_symlink(std::string const &symlink_path) {\n    std::string path;\n    path.resize(100);\n\n    while (true) {\n      ssize_t len =\n          ::readlink(symlink_path.c_str(), &*path.begin(), path.size());\n      if (len < 0) {\n        return \"\";\n      }\n      if (static_cast<size_t>(len) == path.size()) {\n        path.resize(path.size() * 2);\n      } else {\n        path.resize(static_cast<std::string::size_type>(len));\n        break;\n      }\n    }\n\n    return path;\n  }\n};\n\ntemplate <typename STACKTRACE_TAG> class TraceResolverLinuxImpl;\n\n#if BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n\ntemplate <>\nclass TraceResolverLinuxImpl<trace_resolver_tag::backtrace_symbol>\n    : public TraceResolverLinuxBase {\npublic:\n  void load_addresses(void *const*addresses, int address_count) override {\n    if (address_count == 0) {\n      return;\n    }\n    _symbols.reset(backtrace_symbols(addresses, address_count));\n  }\n\n  ResolvedTrace resolve(ResolvedTrace trace) override {\n    char *filename = _symbols[trace.idx];\n    char *funcname = filename;\n    while (*funcname && *funcname != '(') {\n      funcname += 1;\n    }\n    trace.object_filename.assign(filename,\n                                 funcname); // ok even if funcname is the ending\n                                            // \\0 (then we assign entire string)\n\n    if (*funcname) { // if it's not end of string (e.g. from last frame ip==0)\n      funcname += 1;\n      char *funcname_end = funcname;\n      while (*funcname_end && *funcname_end != ')' && *funcname_end != '+') {\n        funcname_end += 1;\n      }\n      *funcname_end = '\\0';\n      trace.object_function = this->demangle(funcname);\n      trace.source.function = trace.object_function; // we cannot do better.\n    }\n    return trace;\n  }\n\nprivate:\n  details::handle<char **> _symbols;\n};\n\n#endif // BACKWARD_HAS_BACKTRACE_SYMBOL == 1\n\n#if BACKWARD_HAS_BFD == 1\n\ntemplate <>\nclass TraceResolverLinuxImpl<trace_resolver_tag::libbfd>\n    : public TraceResolverLinuxBase {\npublic:\n  TraceResolverLinuxImpl() : _bfd_loaded(false) {}\n\n  ResolvedTrace resolve(ResolvedTrace trace) override {\n    Dl_info symbol_info;\n\n    // trace.addr is a virtual address in memory pointing to some code.\n    // Let's try to find from which loaded object it comes from.\n    // The loaded object can be yourself btw.\n    if (!dladdr(trace.addr, &symbol_info)) {\n      return trace; // dat broken trace...\n    }\n\n    // Now we get in symbol_info:\n    // .dli_fname:\n    //\t\tpathname of the shared object that contains the address.\n    // .dli_fbase:\n    //\t\twhere the object is loaded in memory.\n    // .dli_sname:\n    //\t\tthe name of the nearest symbol to trace.addr, we expect a\n    //\t\tfunction name.\n    // .dli_saddr:\n    //\t\tthe exact address corresponding to .dli_sname.\n\n    if (symbol_info.dli_sname) {\n      trace.object_function = demangle(symbol_info.dli_sname);\n    }\n\n    if (!symbol_info.dli_fname) {\n      return trace;\n    }\n\n    trace.object_filename = resolve_exec_path(symbol_info);\n    bfd_fileobject *fobj;\n    // Before rushing to resolution need to ensure the executable\n    // file still can be used. For that compare inode numbers of\n    // what is stored by the executable's file path, and in the\n    // dli_fname, which not necessarily equals to the executable.\n    // It can be a shared library, or /proc/self/exe, and in the\n    // latter case has drawbacks. See the exec path resolution for\n    // details. In short - the dli object should be used only as\n    // the last resort.\n    // If inode numbers are equal, it is known dli_fname and the\n    // executable file are the same. This is guaranteed by Linux,\n    // because if the executable file is changed/deleted, it will\n    // be done in a new inode. The old file will be preserved in\n    // /proc/self/exe, and may even have inode 0. The latter can\n    // happen if the inode was actually reused, and the file was\n    // kept only in the main memory.\n    //\n    struct stat obj_stat;\n    struct stat dli_stat;\n    if (stat(trace.object_filename.c_str(), &obj_stat) == 0 &&\n        stat(symbol_info.dli_fname, &dli_stat) == 0 &&\n        obj_stat.st_ino == dli_stat.st_ino) {\n      // The executable file, and the shared object containing the\n      // address are the same file. Safe to use the original path.\n      // this is preferable. Libbfd will search for stripped debug\n      // symbols in the same directory.\n      fobj = load_object_with_bfd(trace.object_filename);\n    } else{\n      // The original object file was *deleted*! The only hope is\n      // that the debug symbols are either inside the shared\n      // object file, or are in the same directory, and this is\n      // not /proc/self/exe.\n      fobj = nullptr;\n    }\n    if (fobj == nullptr || !fobj->handle) {\n      fobj = load_object_with_bfd(symbol_info.dli_fname);\n      if (!fobj->handle) {\n        return trace;\n      }\n    }\n\n    find_sym_result *details_selected; // to be filled.\n\n    // trace.addr is the next instruction to be executed after returning\n    // from the nested stack frame. In C++ this usually relate to the next\n    // statement right after the function call that leaded to a new stack\n    // frame. This is not usually what you want to see when printing out a\n    // stacktrace...\n    find_sym_result details_call_site =\n        find_symbol_details(fobj, trace.addr, symbol_info.dli_fbase);\n    details_selected = &details_call_site;\n\n#if BACKWARD_HAS_UNWIND == 0\n    // ...this is why we also try to resolve the symbol that is right\n    // before the return address. If we are lucky enough, we will get the\n    // line of the function that was called. But if the code is optimized,\n    // we might get something absolutely not related since the compiler\n    // can reschedule the return address with inline functions and\n    // tail-call optimization (among other things that I don't even know\n    // or cannot even dream about with my tiny limited brain).\n    find_sym_result details_adjusted_call_site = find_symbol_details(\n        fobj, (void *)(uintptr_t(trace.addr) - 1), symbol_info.dli_fbase);\n\n    // In debug mode, we should always get the right thing(TM).\n    if (details_call_site.found && details_adjusted_call_site.found) {\n      // Ok, we assume that details_adjusted_call_site is a better estimation.\n      details_selected = &details_adjusted_call_site;\n      trace.addr = (void *)(uintptr_t(trace.addr) - 1);\n    }\n\n    if (details_selected == &details_call_site && details_call_site.found) {\n      // we have to re-resolve the symbol in order to reset some\n      // internal state in BFD... so we can call backtrace_inliners\n      // thereafter...\n      details_call_site =\n          find_symbol_details(fobj, trace.addr, symbol_info.dli_fbase);\n    }\n#endif // BACKWARD_HAS_UNWIND\n\n    if (details_selected->found) {\n      if (details_selected->filename) {\n        trace.source.filename = details_selected->filename;\n      }\n      trace.source.line = details_selected->line;\n\n      if (details_selected->funcname) {\n        // this time we get the name of the function where the code is\n        // located, instead of the function were the address is\n        // located. In short, if the code was inlined, we get the\n        // function corresponding to the code. Else we already got in\n        // trace.function.\n        trace.source.function = demangle(details_selected->funcname);\n\n        if (!symbol_info.dli_sname) {\n          // for the case dladdr failed to find the symbol name of\n          // the function, we might as well try to put something\n          // here.\n          trace.object_function = trace.source.function;\n        }\n      }\n\n      // Maybe the source of the trace got inlined inside the function\n      // (trace.source.function). Let's see if we can get all the inlined\n      // calls along the way up to the initial call site.\n      trace.inliners = backtrace_inliners(fobj, *details_selected);\n\n#if 0\n\t\t\tif (trace.inliners.size() == 0) {\n\t\t\t\t// Maybe the trace was not inlined... or maybe it was and we\n\t\t\t\t// are lacking the debug information. Let's try to make the\n\t\t\t\t// world better and see if we can get the line number of the\n\t\t\t\t// function (trace.source.function) now.\n\t\t\t\t//\n\t\t\t\t// We will get the location of where the function start (to be\n\t\t\t\t// exact: the first instruction that really start the\n\t\t\t\t// function), not where the name of the function is defined.\n\t\t\t\t// This can be quite far away from the name of the function\n\t\t\t\t// btw.\n\t\t\t\t//\n\t\t\t\t// If the source of the function is the same as the source of\n\t\t\t\t// the trace, we cannot say if the trace was really inlined or\n\t\t\t\t// not.  However, if the filename of the source is different\n\t\t\t\t// between the function and the trace... we can declare it as\n\t\t\t\t// an inliner.  This is not 100% accurate, but better than\n\t\t\t\t// nothing.\n\n\t\t\t\tif (symbol_info.dli_saddr) {\n\t\t\t\t\tfind_sym_result details = find_symbol_details(fobj,\n\t\t\t\t\t\t\tsymbol_info.dli_saddr,\n\t\t\t\t\t\t\tsymbol_info.dli_fbase);\n\n\t\t\t\t\tif (details.found) {\n\t\t\t\t\t\tResolvedTrace::SourceLoc diy_inliner;\n\t\t\t\t\t\tdiy_inliner.line = details.line;\n\t\t\t\t\t\tif (details.filename) {\n\t\t\t\t\t\t\tdiy_inliner.filename = details.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (details.funcname) {\n\t\t\t\t\t\t\tdiy_inliner.function = demangle(details.funcname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiy_inliner.function = trace.source.function;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (diy_inliner != trace.source) {\n\t\t\t\t\t\t\ttrace.inliners.push_back(diy_inliner);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n    }\n\n    return trace;\n  }\n\nprivate:\n  bool _bfd_loaded;\n\n  typedef details::handle<bfd *,\n                          details::deleter<bfd_boolean, bfd *, &bfd_close> >\n      bfd_handle_t;\n\n  typedef details::handle<asymbol **> bfd_symtab_t;\n\n  struct bfd_fileobject {\n    bfd_handle_t handle;\n    bfd_vma base_addr;\n    bfd_symtab_t symtab;\n    bfd_symtab_t dynamic_symtab;\n  };\n\n  typedef details::hashtable<std::string, bfd_fileobject>::type fobj_bfd_map_t;\n  fobj_bfd_map_t _fobj_bfd_map;\n\n  bfd_fileobject *load_object_with_bfd(const std::string &filename_object) {\n    using namespace details;\n\n    if (!_bfd_loaded) {\n      using namespace details;\n      bfd_init();\n      _bfd_loaded = true;\n    }\n\n    fobj_bfd_map_t::iterator it = _fobj_bfd_map.find(filename_object);\n    if (it != _fobj_bfd_map.end()) {\n      return &it->second;\n    }\n\n    // this new object is empty for now.\n    bfd_fileobject *r = &_fobj_bfd_map[filename_object];\n\n    // we do the work temporary in this one;\n    bfd_handle_t bfd_handle;\n\n    int fd = open(filename_object.c_str(), O_RDONLY);\n    bfd_handle.reset(bfd_fdopenr(filename_object.c_str(), \"default\", fd));\n    if (!bfd_handle) {\n      close(fd);\n      return r;\n    }\n\n    if (!bfd_check_format(bfd_handle.get(), bfd_object)) {\n      return r; // not an object? You lose.\n    }\n\n    if ((bfd_get_file_flags(bfd_handle.get()) & HAS_SYMS) == 0) {\n      return r; // that's what happen when you forget to compile in debug.\n    }\n\n    ssize_t symtab_storage_size = bfd_get_symtab_upper_bound(bfd_handle.get());\n\n    ssize_t dyn_symtab_storage_size =\n        bfd_get_dynamic_symtab_upper_bound(bfd_handle.get());\n\n    if (symtab_storage_size <= 0 && dyn_symtab_storage_size <= 0) {\n      return r; // weird, is the file is corrupted?\n    }\n\n    bfd_symtab_t symtab, dynamic_symtab;\n    ssize_t symcount = 0, dyn_symcount = 0;\n\n    if (symtab_storage_size > 0) {\n      symtab.reset(static_cast<bfd_symbol **>(\n          malloc(static_cast<size_t>(symtab_storage_size))));\n      symcount = bfd_canonicalize_symtab(bfd_handle.get(), symtab.get());\n    }\n\n    if (dyn_symtab_storage_size > 0) {\n      dynamic_symtab.reset(static_cast<bfd_symbol **>(\n          malloc(static_cast<size_t>(dyn_symtab_storage_size))));\n      dyn_symcount = bfd_canonicalize_dynamic_symtab(bfd_handle.get(),\n                                                     dynamic_symtab.get());\n    }\n\n    if (symcount <= 0 && dyn_symcount <= 0) {\n      return r; // damned, that's a stripped file that you got there!\n    }\n\n    r->handle = move(bfd_handle);\n    r->symtab = move(symtab);\n    r->dynamic_symtab = move(dynamic_symtab);\n    return r;\n  }\n\n  struct find_sym_result {\n    bool found;\n    const char *filename;\n    const char *funcname;\n    unsigned int line;\n  };\n\n  struct find_sym_context {\n    TraceResolverLinuxImpl *self;\n    bfd_fileobject *fobj;\n    void *addr;\n    void *base_addr;\n    find_sym_result result;\n  };\n\n  find_sym_result find_symbol_details(bfd_fileobject *fobj, void *addr,\n                                      void *base_addr) {\n    find_sym_context context;\n    context.self = this;\n    context.fobj = fobj;\n    context.addr = addr;\n    context.base_addr = base_addr;\n    context.result.found = false;\n    bfd_map_over_sections(fobj->handle.get(), &find_in_section_trampoline,\n                          static_cast<void *>(&context));\n    return context.result;\n  }\n\n  static void find_in_section_trampoline(bfd *, asection *section, void *data) {\n    find_sym_context *context = static_cast<find_sym_context *>(data);\n    context->self->find_in_section(\n        reinterpret_cast<bfd_vma>(context->addr),\n        reinterpret_cast<bfd_vma>(context->base_addr), context->fobj, section,\n        context->result);\n  }\n\n  void find_in_section(bfd_vma addr, bfd_vma base_addr, bfd_fileobject *fobj,\n                       asection *section, find_sym_result &result) {\n    if (result.found)\n      return;\n\n#ifdef bfd_get_section_flags\n    if ((bfd_get_section_flags(fobj->handle.get(), section) & SEC_ALLOC) == 0)\n#else\n    if ((bfd_section_flags(section) & SEC_ALLOC) == 0)\n#endif\n      return; // a debug section is never loaded automatically.\n\n#ifdef bfd_get_section_vma\n    bfd_vma sec_addr = bfd_get_section_vma(fobj->handle.get(), section);\n#else\n    bfd_vma sec_addr = bfd_section_vma(section);\n#endif\n#ifdef bfd_get_section_size\n    bfd_size_type size = bfd_get_section_size(section);\n#else\n    bfd_size_type size = bfd_section_size(section);\n#endif\n\n    // are we in the boundaries of the section?\n    if (addr < sec_addr || addr >= sec_addr + size) {\n      addr -= base_addr; // oops, a relocated object, lets try again...\n      if (addr < sec_addr || addr >= sec_addr + size) {\n        return;\n      }\n    }\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    if (!result.found && fobj->symtab) {\n      result.found = bfd_find_nearest_line(\n          fobj->handle.get(), section, fobj->symtab.get(), addr - sec_addr,\n          &result.filename, &result.funcname, &result.line);\n    }\n\n    if (!result.found && fobj->dynamic_symtab) {\n      result.found = bfd_find_nearest_line(\n          fobj->handle.get(), section, fobj->dynamic_symtab.get(),\n          addr - sec_addr, &result.filename, &result.funcname, &result.line);\n    }\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n  }\n\n  ResolvedTrace::source_locs_t\n  backtrace_inliners(bfd_fileobject *fobj, find_sym_result previous_result) {\n    // This function can be called ONLY after a SUCCESSFUL call to\n    // find_symbol_details. The state is global to the bfd_handle.\n    ResolvedTrace::source_locs_t results;\n    while (previous_result.found) {\n      find_sym_result result;\n      result.found = bfd_find_inliner_info(fobj->handle.get(), &result.filename,\n                                           &result.funcname, &result.line);\n\n      if (result\n              .found) /* and not (\n                            cstrings_eq(previous_result.filename,\n                         result.filename) and\n                         cstrings_eq(previous_result.funcname, result.funcname)\n                            and result.line == previous_result.line\n                            )) */\n      {\n        ResolvedTrace::SourceLoc src_loc;\n        src_loc.line = result.line;\n        if (result.filename) {\n          src_loc.filename = result.filename;\n        }\n        if (result.funcname) {\n          src_loc.function = demangle(result.funcname);\n        }\n        results.push_back(src_loc);\n      }\n      previous_result = result;\n    }\n    return results;\n  }\n\n  bool cstrings_eq(const char *a, const char *b) {\n    if (!a || !b) {\n      return false;\n    }\n    return strcmp(a, b) == 0;\n  }\n};\n#endif // BACKWARD_HAS_BFD == 1\n\n#if BACKWARD_HAS_DW == 1\n\ntemplate <>\nclass TraceResolverLinuxImpl<trace_resolver_tag::libdw>\n    : public TraceResolverLinuxBase {\npublic:\n  TraceResolverLinuxImpl() : _dwfl_handle_initialized(false) {}\n\n  ResolvedTrace resolve(ResolvedTrace trace) override {\n    using namespace details;\n\n    Dwarf_Addr trace_addr = reinterpret_cast<Dwarf_Addr>(trace.addr);\n\n    if (!_dwfl_handle_initialized) {\n      // initialize dwfl...\n      _dwfl_cb.reset(new Dwfl_Callbacks);\n      _dwfl_cb->find_elf = &dwfl_linux_proc_find_elf;\n      _dwfl_cb->find_debuginfo = &dwfl_standard_find_debuginfo;\n      _dwfl_cb->debuginfo_path = 0;\n\n      _dwfl_handle.reset(dwfl_begin(_dwfl_cb.get()));\n      _dwfl_handle_initialized = true;\n\n      if (!_dwfl_handle) {\n        return trace;\n      }\n\n      // ...from the current process.\n      dwfl_report_begin(_dwfl_handle.get());\n      int r = dwfl_linux_proc_report(_dwfl_handle.get(), getpid());\n      dwfl_report_end(_dwfl_handle.get(), NULL, NULL);\n      if (r < 0) {\n        return trace;\n      }\n    }\n\n    if (!_dwfl_handle) {\n      return trace;\n    }\n\n    // find the module (binary object) that contains the trace's address.\n    // This is not using any debug information, but the addresses ranges of\n    // all the currently loaded binary object.\n    Dwfl_Module *mod = dwfl_addrmodule(_dwfl_handle.get(), trace_addr);\n    if (mod) {\n      // now that we found it, lets get the name of it, this will be the\n      // full path to the running binary or one of the loaded library.\n      const char *module_name = dwfl_module_info(mod, 0, 0, 0, 0, 0, 0, 0);\n      if (module_name) {\n        trace.object_filename = module_name;\n      }\n      // We also look after the name of the symbol, equal or before this\n      // address. This is found by walking the symtab. We should get the\n      // symbol corresponding to the function (mangled) containing the\n      // address. If the code corresponding to the address was inlined,\n      // this is the name of the out-most inliner function.\n      const char *sym_name = dwfl_module_addrname(mod, trace_addr);\n      if (sym_name) {\n        trace.object_function = demangle(sym_name);\n      }\n    }\n\n    // now let's get serious, and find out the source location (file and\n    // line number) of the address.\n\n    // This function will look in .debug_aranges for the address and map it\n    // to the location of the compilation unit DIE in .debug_info and\n    // return it.\n    Dwarf_Addr mod_bias = 0;\n    Dwarf_Die *cudie = dwfl_module_addrdie(mod, trace_addr, &mod_bias);\n\n#if 1\n    if (!cudie) {\n      // Sadly clang does not generate the section .debug_aranges, thus\n      // dwfl_module_addrdie will fail early. Clang doesn't either set\n      // the lowpc/highpc/range info for every compilation unit.\n      //\n      // So in order to save the world:\n      // for every compilation unit, we will iterate over every single\n      // DIEs. Normally functions should have a lowpc/highpc/range, which\n      // we will use to infer the compilation unit.\n\n      // note that this is probably badly inefficient.\n      while ((cudie = dwfl_module_nextcu(mod, cudie, &mod_bias))) {\n        Dwarf_Die die_mem;\n        Dwarf_Die *fundie =\n            find_fundie_by_pc(cudie, trace_addr - mod_bias, &die_mem);\n        if (fundie) {\n          break;\n        }\n      }\n    }\n#endif\n\n//#define BACKWARD_I_DO_NOT_RECOMMEND_TO_ENABLE_THIS_HORRIBLE_PIECE_OF_CODE\n#ifdef BACKWARD_I_DO_NOT_RECOMMEND_TO_ENABLE_THIS_HORRIBLE_PIECE_OF_CODE\n    if (!cudie) {\n      // If it's still not enough, lets dive deeper in the shit, and try\n      // to save the world again: for every compilation unit, we will\n      // load the corresponding .debug_line section, and see if we can\n      // find our address in it.\n\n      Dwarf_Addr cfi_bias;\n      Dwarf_CFI *cfi_cache = dwfl_module_eh_cfi(mod, &cfi_bias);\n\n      Dwarf_Addr bias;\n      while ((cudie = dwfl_module_nextcu(mod, cudie, &bias))) {\n        if (dwarf_getsrc_die(cudie, trace_addr - bias)) {\n\n          // ...but if we get a match, it might be a false positive\n          // because our (address - bias) might as well be valid in a\n          // different compilation unit. So we throw our last card on\n          // the table and lookup for the address into the .eh_frame\n          // section.\n\n          handle<Dwarf_Frame *> frame;\n          dwarf_cfi_addrframe(cfi_cache, trace_addr - cfi_bias, &frame);\n          if (frame) {\n            break;\n          }\n        }\n      }\n    }\n#endif\n\n    if (!cudie) {\n      return trace; // this time we lost the game :/\n    }\n\n    // Now that we have a compilation unit DIE, this function will be able\n    // to load the corresponding section in .debug_line (if not already\n    // loaded) and hopefully find the source location mapped to our\n    // address.\n    Dwarf_Line *srcloc = dwarf_getsrc_die(cudie, trace_addr - mod_bias);\n\n    if (srcloc) {\n      const char *srcfile = dwarf_linesrc(srcloc, 0, 0);\n      if (srcfile) {\n        trace.source.filename = srcfile;\n      }\n      int line = 0, col = 0;\n      dwarf_lineno(srcloc, &line);\n      dwarf_linecol(srcloc, &col);\n      trace.source.line = static_cast<unsigned>(line);\n      trace.source.col = static_cast<unsigned>(col);\n    }\n\n    deep_first_search_by_pc(cudie, trace_addr - mod_bias,\n                            inliners_search_cb(trace));\n    if (trace.source.function.size() == 0) {\n      // fallback.\n      trace.source.function = trace.object_function;\n    }\n\n    return trace;\n  }\n\nprivate:\n  typedef details::handle<Dwfl *, details::deleter<void, Dwfl *, &dwfl_end> >\n      dwfl_handle_t;\n  details::handle<Dwfl_Callbacks *, details::default_delete<Dwfl_Callbacks *> >\n      _dwfl_cb;\n  dwfl_handle_t _dwfl_handle;\n  bool _dwfl_handle_initialized;\n\n  // defined here because in C++98, template function cannot take locally\n  // defined types... grrr.\n  struct inliners_search_cb {\n    void operator()(Dwarf_Die *die) {\n      switch (dwarf_tag(die)) {\n        const char *name;\n      case DW_TAG_subprogram:\n        if ((name = dwarf_diename(die))) {\n          trace.source.function = name;\n        }\n        break;\n\n      case DW_TAG_inlined_subroutine:\n        ResolvedTrace::SourceLoc sloc;\n        Dwarf_Attribute attr_mem;\n\n        if ((name = dwarf_diename(die))) {\n          sloc.function = name;\n        }\n        if ((name = die_call_file(die))) {\n          sloc.filename = name;\n        }\n\n        Dwarf_Word line = 0, col = 0;\n        dwarf_formudata(dwarf_attr(die, DW_AT_call_line, &attr_mem), &line);\n        dwarf_formudata(dwarf_attr(die, DW_AT_call_column, &attr_mem), &col);\n        sloc.line = static_cast<unsigned>(line);\n        sloc.col = static_cast<unsigned>(col);\n\n        trace.inliners.push_back(sloc);\n        break;\n      };\n    }\n    ResolvedTrace &trace;\n    inliners_search_cb(ResolvedTrace &t) : trace(t) {}\n  };\n\n  static bool die_has_pc(Dwarf_Die *die, Dwarf_Addr pc) {\n    Dwarf_Addr low, high;\n\n    // continuous range\n    if (dwarf_hasattr(die, DW_AT_low_pc) && dwarf_hasattr(die, DW_AT_high_pc)) {\n      if (dwarf_lowpc(die, &low) != 0) {\n        return false;\n      }\n      if (dwarf_highpc(die, &high) != 0) {\n        Dwarf_Attribute attr_mem;\n        Dwarf_Attribute *attr = dwarf_attr(die, DW_AT_high_pc, &attr_mem);\n        Dwarf_Word value;\n        if (dwarf_formudata(attr, &value) != 0) {\n          return false;\n        }\n        high = low + value;\n      }\n      return pc >= low && pc < high;\n    }\n\n    // non-continuous range.\n    Dwarf_Addr base;\n    ptrdiff_t offset = 0;\n    while ((offset = dwarf_ranges(die, offset, &base, &low, &high)) > 0) {\n      if (pc >= low && pc < high) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Dwarf_Die *find_fundie_by_pc(Dwarf_Die *parent_die, Dwarf_Addr pc,\n                                      Dwarf_Die *result) {\n    if (dwarf_child(parent_die, result) != 0) {\n      return 0;\n    }\n\n    Dwarf_Die *die = result;\n    do {\n      switch (dwarf_tag(die)) {\n      case DW_TAG_subprogram:\n      case DW_TAG_inlined_subroutine:\n        if (die_has_pc(die, pc)) {\n          return result;\n        }\n      };\n      bool declaration = false;\n      Dwarf_Attribute attr_mem;\n      dwarf_formflag(dwarf_attr(die, DW_AT_declaration, &attr_mem),\n                     &declaration);\n      if (!declaration) {\n        // let's be curious and look deeper in the tree,\n        // function are not necessarily at the first level, but\n        // might be nested inside a namespace, structure etc.\n        Dwarf_Die die_mem;\n        Dwarf_Die *indie = find_fundie_by_pc(die, pc, &die_mem);\n        if (indie) {\n          *result = die_mem;\n          return result;\n        }\n      }\n    } while (dwarf_siblingof(die, result) == 0);\n    return 0;\n  }\n\n  template <typename CB>\n  static bool deep_first_search_by_pc(Dwarf_Die *parent_die, Dwarf_Addr pc,\n                                      CB cb) {\n    Dwarf_Die die_mem;\n    if (dwarf_child(parent_die, &die_mem) != 0) {\n      return false;\n    }\n\n    bool branch_has_pc = false;\n    Dwarf_Die *die = &die_mem;\n    do {\n      bool declaration = false;\n      Dwarf_Attribute attr_mem;\n      dwarf_formflag(dwarf_attr(die, DW_AT_declaration, &attr_mem),\n                     &declaration);\n      if (!declaration) {\n        // let's be curious and look deeper in the tree, function are\n        // not necessarily at the first level, but might be nested\n        // inside a namespace, structure, a function, an inlined\n        // function etc.\n        branch_has_pc = deep_first_search_by_pc(die, pc, cb);\n      }\n      if (!branch_has_pc) {\n        branch_has_pc = die_has_pc(die, pc);\n      }\n      if (branch_has_pc) {\n        cb(die);\n      }\n    } while (dwarf_siblingof(die, &die_mem) == 0);\n    return branch_has_pc;\n  }\n\n  static const char *die_call_file(Dwarf_Die *die) {\n    Dwarf_Attribute attr_mem;\n    Dwarf_Word file_idx = 0;\n\n    dwarf_formudata(dwarf_attr(die, DW_AT_call_file, &attr_mem), &file_idx);\n\n    if (file_idx == 0) {\n      return 0;\n    }\n\n    Dwarf_Die die_mem;\n    Dwarf_Die *cudie = dwarf_diecu(die, &die_mem, 0, 0);\n    if (!cudie) {\n      return 0;\n    }\n\n    Dwarf_Files *files = 0;\n    size_t nfiles;\n    dwarf_getsrcfiles(cudie, &files, &nfiles);\n    if (!files) {\n      return 0;\n    }\n\n    return dwarf_filesrc(files, file_idx, 0, 0);\n  }\n};\n#endif // BACKWARD_HAS_DW == 1\n\n#if BACKWARD_HAS_DWARF == 1\n\ntemplate <>\nclass TraceResolverLinuxImpl<trace_resolver_tag::libdwarf>\n    : public TraceResolverLinuxBase {\npublic:\n  TraceResolverLinuxImpl() : _dwarf_loaded(false) {}\n\n  ResolvedTrace resolve(ResolvedTrace trace) override {\n    // trace.addr is a virtual address in memory pointing to some code.\n    // Let's try to find from which loaded object it comes from.\n    // The loaded object can be yourself btw.\n\n    Dl_info symbol_info;\n    int dladdr_result = 0;\n#if defined(__GLIBC__)\n    link_map *link_map;\n    // We request the link map so we can get information about offsets\n    dladdr_result =\n        dladdr1(trace.addr, &symbol_info, reinterpret_cast<void **>(&link_map),\n                RTLD_DL_LINKMAP);\n#else\n    // Android doesn't have dladdr1. Don't use the linker map.\n    dladdr_result = dladdr(trace.addr, &symbol_info);\n#endif\n    if (!dladdr_result) {\n      return trace; // dat broken trace...\n    }\n\n    // Now we get in symbol_info:\n    // .dli_fname:\n    //      pathname of the shared object that contains the address.\n    // .dli_fbase:\n    //      where the object is loaded in memory.\n    // .dli_sname:\n    //      the name of the nearest symbol to trace.addr, we expect a\n    //      function name.\n    // .dli_saddr:\n    //      the exact address corresponding to .dli_sname.\n    //\n    // And in link_map:\n    // .l_addr:\n    //      difference between the address in the ELF file and the address\n    //      in memory\n    // l_name:\n    //      absolute pathname where the object was found\n\n    if (symbol_info.dli_sname) {\n      trace.object_function = demangle(symbol_info.dli_sname);\n    }\n\n    if (!symbol_info.dli_fname) {\n      return trace;\n    }\n\n    trace.object_filename = resolve_exec_path(symbol_info);\n    dwarf_fileobject &fobj = load_object_with_dwarf(symbol_info.dli_fname);\n    if (!fobj.dwarf_handle) {\n      return trace; // sad, we couldn't load the object :(\n    }\n\n#if defined(__GLIBC__)\n    // Convert the address to a module relative one by looking at\n    // the module's loading address in the link map\n    Dwarf_Addr address = reinterpret_cast<uintptr_t>(trace.addr) -\n                         reinterpret_cast<uintptr_t>(link_map->l_addr);\n#else\n    Dwarf_Addr address = reinterpret_cast<uintptr_t>(trace.addr);\n#endif\n\n    if (trace.object_function.empty()) {\n      symbol_cache_t::iterator it = fobj.symbol_cache.lower_bound(address);\n\n      if (it != fobj.symbol_cache.end()) {\n        if (it->first != address) {\n          if (it != fobj.symbol_cache.begin()) {\n            --it;\n          }\n        }\n        trace.object_function = demangle(it->second.c_str());\n      }\n    }\n\n    // Get the Compilation Unit DIE for the address\n    Dwarf_Die die = find_die(fobj, address);\n\n    if (!die) {\n      return trace; // this time we lost the game :/\n    }\n\n    // libdwarf doesn't give us direct access to its objects, it always\n    // allocates a copy for the caller. We keep that copy alive in a cache\n    // and we deallocate it later when it's no longer required.\n    die_cache_entry &die_object = get_die_cache(fobj, die);\n    if (die_object.isEmpty())\n      return trace; // We have no line section for this DIE\n\n    die_linemap_t::iterator it = die_object.line_section.lower_bound(address);\n\n    if (it != die_object.line_section.end()) {\n      if (it->first != address) {\n        if (it == die_object.line_section.begin()) {\n          // If we are on the first item of the line section\n          // but the address does not match it means that\n          // the address is below the range of the DIE. Give up.\n          return trace;\n        } else {\n          --it;\n        }\n      }\n    } else {\n      return trace; // We didn't find the address.\n    }\n\n    // Get the Dwarf_Line that the address points to and call libdwarf\n    // to get source file, line and column info.\n    Dwarf_Line line = die_object.line_buffer[it->second];\n    Dwarf_Error error = DW_DLE_NE;\n\n    char *filename;\n    if (dwarf_linesrc(line, &filename, &error) == DW_DLV_OK) {\n      trace.source.filename = std::string(filename);\n      dwarf_dealloc(fobj.dwarf_handle.get(), filename, DW_DLA_STRING);\n    }\n\n    Dwarf_Unsigned number = 0;\n    if (dwarf_lineno(line, &number, &error) == DW_DLV_OK) {\n      trace.source.line = number;\n    } else {\n      trace.source.line = 0;\n    }\n\n    if (dwarf_lineoff_b(line, &number, &error) == DW_DLV_OK) {\n      trace.source.col = number;\n    } else {\n      trace.source.col = 0;\n    }\n\n    std::vector<std::string> namespace_stack;\n    deep_first_search_by_pc(fobj, die, address, namespace_stack,\n                            inliners_search_cb(trace, fobj, die));\n\n    dwarf_dealloc(fobj.dwarf_handle.get(), die, DW_DLA_DIE);\n\n    return trace;\n  }\n\npublic:\n  static int close_dwarf(Dwarf_Debug dwarf) {\n    return dwarf_finish(dwarf, NULL);\n  }\n\nprivate:\n  bool _dwarf_loaded;\n\n  typedef details::handle<int, details::deleter<int, int, &::close> >\n      dwarf_file_t;\n\n  typedef details::handle<Elf *, details::deleter<int, Elf *, &elf_end> >\n      dwarf_elf_t;\n\n  typedef details::handle<Dwarf_Debug,\n                          details::deleter<int, Dwarf_Debug, &close_dwarf> >\n      dwarf_handle_t;\n\n  typedef std::map<Dwarf_Addr, int> die_linemap_t;\n\n  typedef std::map<Dwarf_Off, Dwarf_Off> die_specmap_t;\n\n  struct die_cache_entry {\n    die_specmap_t spec_section;\n    die_linemap_t line_section;\n    Dwarf_Line *line_buffer;\n    Dwarf_Signed line_count;\n    Dwarf_Line_Context line_context;\n\n    inline bool isEmpty() {\n      return line_buffer == NULL || line_count == 0 || line_context == NULL ||\n             line_section.empty();\n    }\n\n    die_cache_entry() : line_buffer(0), line_count(0), line_context(0) {}\n\n    ~die_cache_entry() {\n      if (line_context) {\n        dwarf_srclines_dealloc_b(line_context);\n      }\n    }\n  };\n\n  typedef std::map<Dwarf_Off, die_cache_entry> die_cache_t;\n\n  typedef std::map<uintptr_t, std::string> symbol_cache_t;\n\n  struct dwarf_fileobject {\n    dwarf_file_t file_handle;\n    dwarf_elf_t elf_handle;\n    dwarf_handle_t dwarf_handle;\n    symbol_cache_t symbol_cache;\n\n    // Die cache\n    die_cache_t die_cache;\n    die_cache_entry *current_cu;\n  };\n\n  typedef details::hashtable<std::string, dwarf_fileobject>::type\n      fobj_dwarf_map_t;\n  fobj_dwarf_map_t _fobj_dwarf_map;\n\n  static bool cstrings_eq(const char *a, const char *b) {\n    if (!a || !b) {\n      return false;\n    }\n    return strcmp(a, b) == 0;\n  }\n\n  dwarf_fileobject &load_object_with_dwarf(const std::string &filename_object) {\n\n    if (!_dwarf_loaded) {\n      // Set the ELF library operating version\n      // If that fails there's nothing we can do\n      _dwarf_loaded = elf_version(EV_CURRENT) != EV_NONE;\n    }\n\n    fobj_dwarf_map_t::iterator it = _fobj_dwarf_map.find(filename_object);\n    if (it != _fobj_dwarf_map.end()) {\n      return it->second;\n    }\n\n    // this new object is empty for now\n    dwarf_fileobject &r = _fobj_dwarf_map[filename_object];\n\n    dwarf_file_t file_handle;\n    file_handle.reset(open(filename_object.c_str(), O_RDONLY));\n    if (file_handle.get() < 0) {\n      return r;\n    }\n\n    // Try to get an ELF handle. We need to read the ELF sections\n    // because we want to see if there is a .gnu_debuglink section\n    // that points to a split debug file\n    dwarf_elf_t elf_handle;\n    elf_handle.reset(elf_begin(file_handle.get(), ELF_C_READ, NULL));\n    if (!elf_handle) {\n      return r;\n    }\n\n    const char *e_ident = elf_getident(elf_handle.get(), 0);\n    if (!e_ident) {\n      return r;\n    }\n\n    // Get the number of sections\n    // We use the new APIs as elf_getshnum is deprecated\n    size_t shdrnum = 0;\n    if (elf_getshdrnum(elf_handle.get(), &shdrnum) == -1) {\n      return r;\n    }\n\n    // Get the index to the string section\n    size_t shdrstrndx = 0;\n    if (elf_getshdrstrndx(elf_handle.get(), &shdrstrndx) == -1) {\n      return r;\n    }\n\n    std::string debuglink;\n    // Iterate through the ELF sections to try to get a gnu_debuglink\n    // note and also to cache the symbol table.\n    // We go the preprocessor way to avoid having to create templated\n    // classes or using gelf (which might throw a compiler error if 64 bit\n    // is not supported\n#define ELF_GET_DATA(ARCH)                                                     \\\n  Elf_Scn *elf_section = 0;                                                    \\\n  Elf_Data *elf_data = 0;                                                      \\\n  Elf##ARCH##_Shdr *section_header = 0;                                        \\\n  Elf_Scn *symbol_section = 0;                                                 \\\n  size_t symbol_count = 0;                                                     \\\n  size_t symbol_strings = 0;                                                   \\\n  Elf##ARCH##_Sym *symbol = 0;                                                 \\\n  const char *section_name = 0;                                                \\\n                                                                               \\\n  while ((elf_section = elf_nextscn(elf_handle.get(), elf_section)) != NULL) { \\\n    section_header = elf##ARCH##_getshdr(elf_section);                         \\\n    if (section_header == NULL) {                                              \\\n      return r;                                                                \\\n    }                                                                          \\\n                                                                               \\\n    if ((section_name = elf_strptr(elf_handle.get(), shdrstrndx,               \\\n                                   section_header->sh_name)) == NULL) {        \\\n      return r;                                                                \\\n    }                                                                          \\\n                                                                               \\\n    if (cstrings_eq(section_name, \".gnu_debuglink\")) {                         \\\n      elf_data = elf_getdata(elf_section, NULL);                               \\\n      if (elf_data && elf_data->d_size > 0) {                                  \\\n        debuglink =                                                            \\\n            std::string(reinterpret_cast<const char *>(elf_data->d_buf));      \\\n      }                                                                        \\\n    }                                                                          \\\n                                                                               \\\n    switch (section_header->sh_type) {                                         \\\n    case SHT_SYMTAB:                                                           \\\n      symbol_section = elf_section;                                            \\\n      symbol_count = section_header->sh_size / section_header->sh_entsize;     \\\n      symbol_strings = section_header->sh_link;                                \\\n      break;                                                                   \\\n                                                                               \\\n    /* We use .dynsyms as a last resort, we prefer .symtab */                  \\\n    case SHT_DYNSYM:                                                           \\\n      if (!symbol_section) {                                                   \\\n        symbol_section = elf_section;                                          \\\n        symbol_count = section_header->sh_size / section_header->sh_entsize;   \\\n        symbol_strings = section_header->sh_link;                              \\\n      }                                                                        \\\n      break;                                                                   \\\n    }                                                                          \\\n  }                                                                            \\\n                                                                               \\\n  if (symbol_section && symbol_count && symbol_strings) {                      \\\n    elf_data = elf_getdata(symbol_section, NULL);                              \\\n    symbol = reinterpret_cast<Elf##ARCH##_Sym *>(elf_data->d_buf);             \\\n    for (size_t i = 0; i < symbol_count; ++i) {                                \\\n      int type = ELF##ARCH##_ST_TYPE(symbol->st_info);                         \\\n      if (type == STT_FUNC && symbol->st_value > 0) {                          \\\n        r.symbol_cache[symbol->st_value] = std::string(                        \\\n            elf_strptr(elf_handle.get(), symbol_strings, symbol->st_name));    \\\n      }                                                                        \\\n      ++symbol;                                                                \\\n    }                                                                          \\\n  }\n\n    if (e_ident[EI_CLASS] == ELFCLASS32) {\n      ELF_GET_DATA(32)\n    } else if (e_ident[EI_CLASS] == ELFCLASS64) {\n      // libelf might have been built without 64 bit support\n#if __LIBELF64\n      ELF_GET_DATA(64)\n#endif\n    }\n\n    if (!debuglink.empty()) {\n      // We have a debuglink section! Open an elf instance on that\n      // file instead. If we can't open the file, then return\n      // the elf handle we had already opened.\n      dwarf_file_t debuglink_file;\n      debuglink_file.reset(open(debuglink.c_str(), O_RDONLY));\n      if (debuglink_file.get() > 0) {\n        dwarf_elf_t debuglink_elf;\n        debuglink_elf.reset(elf_begin(debuglink_file.get(), ELF_C_READ, NULL));\n\n        // If we have a valid elf handle, return the new elf handle\n        // and file handle and discard the original ones\n        if (debuglink_elf) {\n          elf_handle = move(debuglink_elf);\n          file_handle = move(debuglink_file);\n        }\n      }\n    }\n\n    // Ok, we have a valid ELF handle, let's try to get debug symbols\n    Dwarf_Debug dwarf_debug;\n    Dwarf_Error error = DW_DLE_NE;\n    dwarf_handle_t dwarf_handle;\n\n    int dwarf_result = dwarf_elf_init(elf_handle.get(), DW_DLC_READ, NULL, NULL,\n                                      &dwarf_debug, &error);\n\n    // We don't do any special handling for DW_DLV_NO_ENTRY specially.\n    // If we get an error, or the file doesn't have debug information\n    // we just return.\n    if (dwarf_result != DW_DLV_OK) {\n      return r;\n    }\n\n    dwarf_handle.reset(dwarf_debug);\n\n    r.file_handle = move(file_handle);\n    r.elf_handle = move(elf_handle);\n    r.dwarf_handle = move(dwarf_handle);\n\n    return r;\n  }\n\n  die_cache_entry &get_die_cache(dwarf_fileobject &fobj, Dwarf_Die die) {\n    Dwarf_Error error = DW_DLE_NE;\n\n    // Get the die offset, we use it as the cache key\n    Dwarf_Off die_offset;\n    if (dwarf_dieoffset(die, &die_offset, &error) != DW_DLV_OK) {\n      die_offset = 0;\n    }\n\n    die_cache_t::iterator it = fobj.die_cache.find(die_offset);\n\n    if (it != fobj.die_cache.end()) {\n      fobj.current_cu = &it->second;\n      return it->second;\n    }\n\n    die_cache_entry &de = fobj.die_cache[die_offset];\n    fobj.current_cu = &de;\n\n    Dwarf_Addr line_addr;\n    Dwarf_Small table_count;\n\n    // The addresses in the line section are not fully sorted (they might\n    // be sorted by block of code belonging to the same file), which makes\n    // it necessary to do so before searching is possible.\n    //\n    // As libdwarf allocates a copy of everything, let's get the contents\n    // of the line section and keep it around. We also create a map of\n    // program counter to line table indices so we can search by address\n    // and get the line buffer index.\n    //\n    // To make things more difficult, the same address can span more than\n    // one line, so we need to keep the index pointing to the first line\n    // by using insert instead of the map's [ operator.\n\n    // Get the line context for the DIE\n    if (dwarf_srclines_b(die, 0, &table_count, &de.line_context, &error) ==\n        DW_DLV_OK) {\n      // Get the source lines for this line context, to be deallocated\n      // later\n      if (dwarf_srclines_from_linecontext(de.line_context, &de.line_buffer,\n                                          &de.line_count,\n                                          &error) == DW_DLV_OK) {\n\n        // Add all the addresses to our map\n        for (int i = 0; i < de.line_count; i++) {\n          if (dwarf_lineaddr(de.line_buffer[i], &line_addr, &error) !=\n              DW_DLV_OK) {\n            line_addr = 0;\n          }\n          de.line_section.insert(std::pair<Dwarf_Addr, int>(line_addr, i));\n        }\n      }\n    }\n\n    // For each CU, cache the function DIEs that contain the\n    // DW_AT_specification attribute. When building with -g3 the function\n    // DIEs are separated in declaration and specification, with the\n    // declaration containing only the name and parameters and the\n    // specification the low/high pc and other compiler attributes.\n    //\n    // We cache those specifications so we don't skip over the declarations,\n    // because they have no pc, and we can do namespace resolution for\n    // DWARF function names.\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    Dwarf_Die current_die = 0;\n    if (dwarf_child(die, &current_die, &error) == DW_DLV_OK) {\n      for (;;) {\n        Dwarf_Die sibling_die = 0;\n\n        Dwarf_Half tag_value;\n        dwarf_tag(current_die, &tag_value, &error);\n\n        if (tag_value == DW_TAG_subprogram ||\n            tag_value == DW_TAG_inlined_subroutine) {\n\n          Dwarf_Bool has_attr = 0;\n          if (dwarf_hasattr(current_die, DW_AT_specification, &has_attr,\n                            &error) == DW_DLV_OK) {\n            if (has_attr) {\n              Dwarf_Attribute attr_mem;\n              if (dwarf_attr(current_die, DW_AT_specification, &attr_mem,\n                             &error) == DW_DLV_OK) {\n                Dwarf_Off spec_offset = 0;\n                if (dwarf_formref(attr_mem, &spec_offset, &error) ==\n                    DW_DLV_OK) {\n                  Dwarf_Off spec_die_offset;\n                  if (dwarf_dieoffset(current_die, &spec_die_offset, &error) ==\n                      DW_DLV_OK) {\n                    de.spec_section[spec_offset] = spec_die_offset;\n                  }\n                }\n              }\n              dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n            }\n          }\n        }\n\n        int result = dwarf_siblingof(dwarf, current_die, &sibling_die, &error);\n        if (result == DW_DLV_ERROR) {\n          break;\n        } else if (result == DW_DLV_NO_ENTRY) {\n          break;\n        }\n\n        if (current_die != die) {\n          dwarf_dealloc(dwarf, current_die, DW_DLA_DIE);\n          current_die = 0;\n        }\n\n        current_die = sibling_die;\n      }\n    }\n    return de;\n  }\n\n  static Dwarf_Die get_referenced_die(Dwarf_Debug dwarf, Dwarf_Die die,\n                                      Dwarf_Half attr, bool global) {\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Attribute attr_mem;\n\n    Dwarf_Die found_die = NULL;\n    if (dwarf_attr(die, attr, &attr_mem, &error) == DW_DLV_OK) {\n      Dwarf_Off offset;\n      int result = 0;\n      if (global) {\n        result = dwarf_global_formref(attr_mem, &offset, &error);\n      } else {\n        result = dwarf_formref(attr_mem, &offset, &error);\n      }\n\n      if (result == DW_DLV_OK) {\n        if (dwarf_offdie(dwarf, offset, &found_die, &error) != DW_DLV_OK) {\n          found_die = NULL;\n        }\n      }\n      dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n    }\n    return found_die;\n  }\n\n  static std::string get_referenced_die_name(Dwarf_Debug dwarf, Dwarf_Die die,\n                                             Dwarf_Half attr, bool global) {\n    Dwarf_Error error = DW_DLE_NE;\n    std::string value;\n\n    Dwarf_Die found_die = get_referenced_die(dwarf, die, attr, global);\n\n    if (found_die) {\n      char *name;\n      if (dwarf_diename(found_die, &name, &error) == DW_DLV_OK) {\n        if (name) {\n          value = std::string(name);\n        }\n        dwarf_dealloc(dwarf, name, DW_DLA_STRING);\n      }\n      dwarf_dealloc(dwarf, found_die, DW_DLA_DIE);\n    }\n\n    return value;\n  }\n\n  // Returns a spec DIE linked to the passed one. The caller should\n  // deallocate the DIE\n  static Dwarf_Die get_spec_die(dwarf_fileobject &fobj, Dwarf_Die die) {\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Off die_offset;\n    if (fobj.current_cu &&\n        dwarf_die_CU_offset(die, &die_offset, &error) == DW_DLV_OK) {\n      die_specmap_t::iterator it =\n          fobj.current_cu->spec_section.find(die_offset);\n\n      // If we have a DIE that completes the current one, check if\n      // that one has the pc we are looking for\n      if (it != fobj.current_cu->spec_section.end()) {\n        Dwarf_Die spec_die = 0;\n        if (dwarf_offdie(dwarf, it->second, &spec_die, &error) == DW_DLV_OK) {\n          return spec_die;\n        }\n      }\n    }\n\n    // Maybe we have an abstract origin DIE with the function information?\n    return get_referenced_die(fobj.dwarf_handle.get(), die,\n                              DW_AT_abstract_origin, true);\n  }\n\n  static bool die_has_pc(dwarf_fileobject &fobj, Dwarf_Die die, Dwarf_Addr pc) {\n    Dwarf_Addr low_pc = 0, high_pc = 0;\n    Dwarf_Half high_pc_form = 0;\n    Dwarf_Form_Class return_class;\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    bool has_lowpc = false;\n    bool has_highpc = false;\n    bool has_ranges = false;\n\n    if (dwarf_lowpc(die, &low_pc, &error) == DW_DLV_OK) {\n      // If we have a low_pc check if there is a high pc.\n      // If we don't have a high pc this might mean we have a base\n      // address for the ranges list or just an address.\n      has_lowpc = true;\n\n      if (dwarf_highpc_b(die, &high_pc, &high_pc_form, &return_class, &error) ==\n          DW_DLV_OK) {\n        // We do have a high pc. In DWARF 4+ this is an offset from the\n        // low pc, but in earlier versions it's an absolute address.\n\n        has_highpc = true;\n        // In DWARF 2/3 this would be a DW_FORM_CLASS_ADDRESS\n        if (return_class == DW_FORM_CLASS_CONSTANT) {\n          high_pc = low_pc + high_pc;\n        }\n\n        // We have low and high pc, check if our address\n        // is in that range\n        return pc >= low_pc && pc < high_pc;\n      }\n    } else {\n      // Reset the low_pc, in case dwarf_lowpc failing set it to some\n      // undefined value.\n      low_pc = 0;\n    }\n\n    // Check if DW_AT_ranges is present and search for the PC in the\n    // returned ranges list. We always add the low_pc, as it not set it will\n    // be 0, in case we had a DW_AT_low_pc and DW_AT_ranges pair\n    bool result = false;\n\n    Dwarf_Attribute attr;\n    if (dwarf_attr(die, DW_AT_ranges, &attr, &error) == DW_DLV_OK) {\n\n      Dwarf_Off offset;\n      if (dwarf_global_formref(attr, &offset, &error) == DW_DLV_OK) {\n        Dwarf_Ranges *ranges;\n        Dwarf_Signed ranges_count = 0;\n        Dwarf_Unsigned byte_count = 0;\n\n        if (dwarf_get_ranges_a(dwarf, offset, die, &ranges, &ranges_count,\n                               &byte_count, &error) == DW_DLV_OK) {\n          has_ranges = ranges_count != 0;\n          for (int i = 0; i < ranges_count; i++) {\n            if (ranges[i].dwr_addr1 != 0 &&\n                pc >= ranges[i].dwr_addr1 + low_pc &&\n                pc < ranges[i].dwr_addr2 + low_pc) {\n              result = true;\n              break;\n            }\n          }\n          dwarf_ranges_dealloc(dwarf, ranges, ranges_count);\n        }\n      }\n    }\n\n    // Last attempt. We might have a single address set as low_pc.\n    if (!result && low_pc != 0 && pc == low_pc) {\n      result = true;\n    }\n\n    // If we don't have lowpc, highpc and ranges maybe this DIE is a\n    // declaration that relies on a DW_AT_specification DIE that happens\n    // later. Use the specification cache we filled when we loaded this CU.\n    if (!result && (!has_lowpc && !has_highpc && !has_ranges)) {\n      Dwarf_Die spec_die = get_spec_die(fobj, die);\n      if (spec_die) {\n        result = die_has_pc(fobj, spec_die, pc);\n        dwarf_dealloc(dwarf, spec_die, DW_DLA_DIE);\n      }\n    }\n\n    return result;\n  }\n\n  static void get_type(Dwarf_Debug dwarf, Dwarf_Die die, std::string &type) {\n    Dwarf_Error error = DW_DLE_NE;\n\n    Dwarf_Die child = 0;\n    if (dwarf_child(die, &child, &error) == DW_DLV_OK) {\n      get_type(dwarf, child, type);\n    }\n\n    if (child) {\n      type.insert(0, \"::\");\n      dwarf_dealloc(dwarf, child, DW_DLA_DIE);\n    }\n\n    char *name;\n    if (dwarf_diename(die, &name, &error) == DW_DLV_OK) {\n      type.insert(0, std::string(name));\n      dwarf_dealloc(dwarf, name, DW_DLA_STRING);\n    } else {\n      type.insert(0, \"<unknown>\");\n    }\n  }\n\n  static std::string get_type_by_signature(Dwarf_Debug dwarf, Dwarf_Die die) {\n    Dwarf_Error error = DW_DLE_NE;\n\n    Dwarf_Sig8 signature;\n    Dwarf_Bool has_attr = 0;\n    if (dwarf_hasattr(die, DW_AT_signature, &has_attr, &error) == DW_DLV_OK) {\n      if (has_attr) {\n        Dwarf_Attribute attr_mem;\n        if (dwarf_attr(die, DW_AT_signature, &attr_mem, &error) == DW_DLV_OK) {\n          if (dwarf_formsig8(attr_mem, &signature, &error) != DW_DLV_OK) {\n            return std::string(\"<no type signature>\");\n          }\n        }\n        dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n      }\n    }\n\n    Dwarf_Unsigned next_cu_header;\n    Dwarf_Sig8 tu_signature;\n    std::string result;\n    bool found = false;\n\n    while (dwarf_next_cu_header_d(dwarf, 0, 0, 0, 0, 0, 0, 0, &tu_signature, 0,\n                                  &next_cu_header, 0, &error) == DW_DLV_OK) {\n\n      if (strncmp(signature.signature, tu_signature.signature, 8) == 0) {\n        Dwarf_Die type_cu_die = 0;\n        if (dwarf_siblingof_b(dwarf, 0, 0, &type_cu_die, &error) == DW_DLV_OK) {\n          Dwarf_Die child_die = 0;\n          if (dwarf_child(type_cu_die, &child_die, &error) == DW_DLV_OK) {\n            get_type(dwarf, child_die, result);\n            found = !result.empty();\n            dwarf_dealloc(dwarf, child_die, DW_DLA_DIE);\n          }\n          dwarf_dealloc(dwarf, type_cu_die, DW_DLA_DIE);\n        }\n      }\n    }\n\n    if (found) {\n      while (dwarf_next_cu_header_d(dwarf, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                                    &next_cu_header, 0, &error) == DW_DLV_OK) {\n        // Reset the cu header state. Unfortunately, libdwarf's\n        // next_cu_header API keeps its own iterator per Dwarf_Debug\n        // that can't be reset. We need to keep fetching elements until\n        // the end.\n      }\n    } else {\n      // If we couldn't resolve the type just print out the signature\n      std::ostringstream string_stream;\n      string_stream << \"<0x\" << std::hex << std::setfill('0');\n      for (int i = 0; i < 8; ++i) {\n        string_stream << std::setw(2) << std::hex\n                      << (int)(unsigned char)(signature.signature[i]);\n      }\n      string_stream << \">\";\n      result = string_stream.str();\n    }\n    return result;\n  }\n\n  struct type_context_t {\n    bool is_const;\n    bool is_typedef;\n    bool has_type;\n    bool has_name;\n    std::string text;\n\n    type_context_t()\n        : is_const(false), is_typedef(false), has_type(false), has_name(false) {\n    }\n  };\n\n  // Types are resolved from right to left: we get the variable name first\n  // and then all specifiers (like const or pointer) in a chain of DW_AT_type\n  // DIEs. Call this function recursively until we get a complete type\n  // string.\n  static void set_parameter_string(dwarf_fileobject &fobj, Dwarf_Die die,\n                                   type_context_t &context) {\n    char *name;\n    Dwarf_Error error = DW_DLE_NE;\n\n    // typedefs contain also the base type, so we skip it and only\n    // print the typedef name\n    if (!context.is_typedef) {\n      if (dwarf_diename(die, &name, &error) == DW_DLV_OK) {\n        if (!context.text.empty()) {\n          context.text.insert(0, \" \");\n        }\n        context.text.insert(0, std::string(name));\n        dwarf_dealloc(fobj.dwarf_handle.get(), name, DW_DLA_STRING);\n      }\n    } else {\n      context.is_typedef = false;\n      context.has_type = true;\n      if (context.is_const) {\n        context.text.insert(0, \"const \");\n        context.is_const = false;\n      }\n    }\n\n    bool next_type_is_const = false;\n    bool is_keyword = true;\n\n    Dwarf_Half tag = 0;\n    Dwarf_Bool has_attr = 0;\n    if (dwarf_tag(die, &tag, &error) == DW_DLV_OK) {\n      switch (tag) {\n      case DW_TAG_structure_type:\n      case DW_TAG_union_type:\n      case DW_TAG_class_type:\n      case DW_TAG_enumeration_type:\n        context.has_type = true;\n        if (dwarf_hasattr(die, DW_AT_signature, &has_attr, &error) ==\n            DW_DLV_OK) {\n          // If we have a signature it means the type is defined\n          // in .debug_types, so we need to load the DIE pointed\n          // at by the signature and resolve it\n          if (has_attr) {\n            std::string type =\n                get_type_by_signature(fobj.dwarf_handle.get(), die);\n            if (context.is_const)\n              type.insert(0, \"const \");\n\n            if (!context.text.empty())\n              context.text.insert(0, \" \");\n            context.text.insert(0, type);\n          }\n\n          // Treat enums like typedefs, and skip printing its\n          // base type\n          context.is_typedef = (tag == DW_TAG_enumeration_type);\n        }\n        break;\n      case DW_TAG_const_type:\n        next_type_is_const = true;\n        break;\n      case DW_TAG_pointer_type:\n        context.text.insert(0, \"*\");\n        break;\n      case DW_TAG_reference_type:\n        context.text.insert(0, \"&\");\n        break;\n      case DW_TAG_restrict_type:\n        context.text.insert(0, \"restrict \");\n        break;\n      case DW_TAG_rvalue_reference_type:\n        context.text.insert(0, \"&&\");\n        break;\n      case DW_TAG_volatile_type:\n        context.text.insert(0, \"volatile \");\n        break;\n      case DW_TAG_typedef:\n        // Propagate the const-ness to the next type\n        // as typedefs are linked to its base type\n        next_type_is_const = context.is_const;\n        context.is_typedef = true;\n        context.has_type = true;\n        break;\n      case DW_TAG_base_type:\n        context.has_type = true;\n        break;\n      case DW_TAG_formal_parameter:\n        context.has_name = true;\n        break;\n      default:\n        is_keyword = false;\n        break;\n      }\n    }\n\n    if (!is_keyword && context.is_const) {\n      context.text.insert(0, \"const \");\n    }\n\n    context.is_const = next_type_is_const;\n\n    Dwarf_Die ref =\n        get_referenced_die(fobj.dwarf_handle.get(), die, DW_AT_type, true);\n    if (ref) {\n      set_parameter_string(fobj, ref, context);\n      dwarf_dealloc(fobj.dwarf_handle.get(), ref, DW_DLA_DIE);\n    }\n\n    if (!context.has_type && context.has_name) {\n      context.text.insert(0, \"void \");\n      context.has_type = true;\n    }\n  }\n\n  // Resolve the function return type and parameters\n  static void set_function_parameters(std::string &function_name,\n                                      std::vector<std::string> &ns,\n                                      dwarf_fileobject &fobj, Dwarf_Die die) {\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Die current_die = 0;\n    std::string parameters;\n    bool has_spec = true;\n    // Check if we have a spec DIE. If we do we use it as it contains\n    // more information, like parameter names.\n    Dwarf_Die spec_die = get_spec_die(fobj, die);\n    if (!spec_die) {\n      has_spec = false;\n      spec_die = die;\n    }\n\n    std::vector<std::string>::const_iterator it = ns.begin();\n    std::string ns_name;\n    for (it = ns.begin(); it < ns.end(); ++it) {\n      ns_name.append(*it).append(\"::\");\n    }\n\n    if (!ns_name.empty()) {\n      function_name.insert(0, ns_name);\n    }\n\n    // See if we have a function return type. It can be either on the\n    // current die or in its spec one (usually true for inlined functions)\n    std::string return_type =\n        get_referenced_die_name(dwarf, die, DW_AT_type, true);\n    if (return_type.empty()) {\n      return_type = get_referenced_die_name(dwarf, spec_die, DW_AT_type, true);\n    }\n    if (!return_type.empty()) {\n      return_type.append(\" \");\n      function_name.insert(0, return_type);\n    }\n\n    if (dwarf_child(spec_die, &current_die, &error) == DW_DLV_OK) {\n      for (;;) {\n        Dwarf_Die sibling_die = 0;\n\n        Dwarf_Half tag_value;\n        dwarf_tag(current_die, &tag_value, &error);\n\n        if (tag_value == DW_TAG_formal_parameter) {\n          // Ignore artificial (ie, compiler generated) parameters\n          bool is_artificial = false;\n          Dwarf_Attribute attr_mem;\n          if (dwarf_attr(current_die, DW_AT_artificial, &attr_mem, &error) ==\n              DW_DLV_OK) {\n            Dwarf_Bool flag = 0;\n            if (dwarf_formflag(attr_mem, &flag, &error) == DW_DLV_OK) {\n              is_artificial = flag != 0;\n            }\n            dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n          }\n\n          if (!is_artificial) {\n            type_context_t context;\n            set_parameter_string(fobj, current_die, context);\n\n            if (parameters.empty()) {\n              parameters.append(\"(\");\n            } else {\n              parameters.append(\", \");\n            }\n            parameters.append(context.text);\n          }\n        }\n\n        int result = dwarf_siblingof(dwarf, current_die, &sibling_die, &error);\n        if (result == DW_DLV_ERROR) {\n          break;\n        } else if (result == DW_DLV_NO_ENTRY) {\n          break;\n        }\n\n        if (current_die != die) {\n          dwarf_dealloc(dwarf, current_die, DW_DLA_DIE);\n          current_die = 0;\n        }\n\n        current_die = sibling_die;\n      }\n    }\n    if (parameters.empty())\n      parameters = \"(\";\n    parameters.append(\")\");\n\n    // If we got a spec DIE we need to deallocate it\n    if (has_spec)\n      dwarf_dealloc(dwarf, spec_die, DW_DLA_DIE);\n\n    function_name.append(parameters);\n  }\n\n  // defined here because in C++98, template function cannot take locally\n  // defined types... grrr.\n  struct inliners_search_cb {\n    void operator()(Dwarf_Die die, std::vector<std::string> &ns) {\n      Dwarf_Error error = DW_DLE_NE;\n      Dwarf_Half tag_value;\n      Dwarf_Attribute attr_mem;\n      Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n\n      dwarf_tag(die, &tag_value, &error);\n\n      switch (tag_value) {\n        char *name;\n      case DW_TAG_subprogram:\n        if (!trace.source.function.empty())\n          break;\n        if (dwarf_diename(die, &name, &error) == DW_DLV_OK) {\n          trace.source.function = std::string(name);\n          dwarf_dealloc(dwarf, name, DW_DLA_STRING);\n        } else {\n          // We don't have a function name in this DIE.\n          // Check if there is a referenced non-defining\n          // declaration.\n          trace.source.function =\n              get_referenced_die_name(dwarf, die, DW_AT_abstract_origin, true);\n          if (trace.source.function.empty()) {\n            trace.source.function =\n                get_referenced_die_name(dwarf, die, DW_AT_specification, true);\n          }\n        }\n\n        // Append the function parameters, if available\n        set_function_parameters(trace.source.function, ns, fobj, die);\n\n        // If the object function name is empty, it's possible that\n        // there is no dynamic symbol table (maybe the executable\n        // was stripped or not built with -rdynamic). See if we have\n        // a DWARF linkage name to use instead. We try both\n        // linkage_name and MIPS_linkage_name because the MIPS tag\n        // was the unofficial one until it was adopted in DWARF4.\n        // Old gcc versions generate MIPS_linkage_name\n        if (trace.object_function.empty()) {\n          details::demangler demangler;\n\n          if (dwarf_attr(die, DW_AT_linkage_name, &attr_mem, &error) !=\n              DW_DLV_OK) {\n            if (dwarf_attr(die, DW_AT_MIPS_linkage_name, &attr_mem, &error) !=\n                DW_DLV_OK) {\n              break;\n            }\n          }\n\n          char *linkage;\n          if (dwarf_formstring(attr_mem, &linkage, &error) == DW_DLV_OK) {\n            trace.object_function = demangler.demangle(linkage);\n            dwarf_dealloc(dwarf, linkage, DW_DLA_STRING);\n          }\n          dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n        }\n        break;\n\n      case DW_TAG_inlined_subroutine:\n        ResolvedTrace::SourceLoc sloc;\n\n        if (dwarf_diename(die, &name, &error) == DW_DLV_OK) {\n          sloc.function = std::string(name);\n          dwarf_dealloc(dwarf, name, DW_DLA_STRING);\n        } else {\n          // We don't have a name for this inlined DIE, it could\n          // be that there is an abstract origin instead.\n          // Get the DW_AT_abstract_origin value, which is a\n          // reference to the source DIE and try to get its name\n          sloc.function =\n              get_referenced_die_name(dwarf, die, DW_AT_abstract_origin, true);\n        }\n\n        set_function_parameters(sloc.function, ns, fobj, die);\n\n        std::string file = die_call_file(dwarf, die, cu_die);\n        if (!file.empty())\n          sloc.filename = file;\n\n        Dwarf_Unsigned number = 0;\n        if (dwarf_attr(die, DW_AT_call_line, &attr_mem, &error) == DW_DLV_OK) {\n          if (dwarf_formudata(attr_mem, &number, &error) == DW_DLV_OK) {\n            sloc.line = number;\n          }\n          dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n        }\n\n        if (dwarf_attr(die, DW_AT_call_column, &attr_mem, &error) ==\n            DW_DLV_OK) {\n          if (dwarf_formudata(attr_mem, &number, &error) == DW_DLV_OK) {\n            sloc.col = number;\n          }\n          dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n        }\n\n        trace.inliners.push_back(sloc);\n        break;\n      };\n    }\n    ResolvedTrace &trace;\n    dwarf_fileobject &fobj;\n    Dwarf_Die cu_die;\n    inliners_search_cb(ResolvedTrace &t, dwarf_fileobject &f, Dwarf_Die c)\n        : trace(t), fobj(f), cu_die(c) {}\n  };\n\n  static Dwarf_Die find_fundie_by_pc(dwarf_fileobject &fobj,\n                                     Dwarf_Die parent_die, Dwarf_Addr pc,\n                                     Dwarf_Die result) {\n    Dwarf_Die current_die = 0;\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n\n    if (dwarf_child(parent_die, &current_die, &error) != DW_DLV_OK) {\n      return NULL;\n    }\n\n    for (;;) {\n      Dwarf_Die sibling_die = 0;\n      Dwarf_Half tag_value;\n      dwarf_tag(current_die, &tag_value, &error);\n\n      switch (tag_value) {\n      case DW_TAG_subprogram:\n      case DW_TAG_inlined_subroutine:\n        if (die_has_pc(fobj, current_die, pc)) {\n          return current_die;\n        }\n      };\n      bool declaration = false;\n      Dwarf_Attribute attr_mem;\n      if (dwarf_attr(current_die, DW_AT_declaration, &attr_mem, &error) ==\n          DW_DLV_OK) {\n        Dwarf_Bool flag = 0;\n        if (dwarf_formflag(attr_mem, &flag, &error) == DW_DLV_OK) {\n          declaration = flag != 0;\n        }\n        dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n      }\n\n      if (!declaration) {\n        // let's be curious and look deeper in the tree, functions are\n        // not necessarily at the first level, but might be nested\n        // inside a namespace, structure, a function, an inlined\n        // function etc.\n        Dwarf_Die die_mem = 0;\n        Dwarf_Die indie = find_fundie_by_pc(fobj, current_die, pc, die_mem);\n        if (indie) {\n          result = die_mem;\n          return result;\n        }\n      }\n\n      int res = dwarf_siblingof(dwarf, current_die, &sibling_die, &error);\n      if (res == DW_DLV_ERROR) {\n        return NULL;\n      } else if (res == DW_DLV_NO_ENTRY) {\n        break;\n      }\n\n      if (current_die != parent_die) {\n        dwarf_dealloc(dwarf, current_die, DW_DLA_DIE);\n        current_die = 0;\n      }\n\n      current_die = sibling_die;\n    }\n    return NULL;\n  }\n\n  template <typename CB>\n  static bool deep_first_search_by_pc(dwarf_fileobject &fobj,\n                                      Dwarf_Die parent_die, Dwarf_Addr pc,\n                                      std::vector<std::string> &ns, CB cb) {\n    Dwarf_Die current_die = 0;\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    Dwarf_Error error = DW_DLE_NE;\n\n    if (dwarf_child(parent_die, &current_die, &error) != DW_DLV_OK) {\n      return false;\n    }\n\n    bool branch_has_pc = false;\n    bool has_namespace = false;\n    for (;;) {\n      Dwarf_Die sibling_die = 0;\n\n      Dwarf_Half tag;\n      if (dwarf_tag(current_die, &tag, &error) == DW_DLV_OK) {\n        if (tag == DW_TAG_namespace || tag == DW_TAG_class_type) {\n          char *ns_name = NULL;\n          if (dwarf_diename(current_die, &ns_name, &error) == DW_DLV_OK) {\n            if (ns_name) {\n              ns.push_back(std::string(ns_name));\n            } else {\n              ns.push_back(\"<unknown>\");\n            }\n            dwarf_dealloc(dwarf, ns_name, DW_DLA_STRING);\n          } else {\n            ns.push_back(\"<unknown>\");\n          }\n          has_namespace = true;\n        }\n      }\n\n      bool declaration = false;\n      Dwarf_Attribute attr_mem;\n      if (tag != DW_TAG_class_type &&\n          dwarf_attr(current_die, DW_AT_declaration, &attr_mem, &error) ==\n              DW_DLV_OK) {\n        Dwarf_Bool flag = 0;\n        if (dwarf_formflag(attr_mem, &flag, &error) == DW_DLV_OK) {\n          declaration = flag != 0;\n        }\n        dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n      }\n\n      if (!declaration) {\n        // let's be curious and look deeper in the tree, function are\n        // not necessarily at the first level, but might be nested\n        // inside a namespace, structure, a function, an inlined\n        // function etc.\n        branch_has_pc = deep_first_search_by_pc(fobj, current_die, pc, ns, cb);\n      }\n\n      if (!branch_has_pc) {\n        branch_has_pc = die_has_pc(fobj, current_die, pc);\n      }\n\n      if (branch_has_pc) {\n        cb(current_die, ns);\n      }\n\n      int result = dwarf_siblingof(dwarf, current_die, &sibling_die, &error);\n      if (result == DW_DLV_ERROR) {\n        return false;\n      } else if (result == DW_DLV_NO_ENTRY) {\n        break;\n      }\n\n      if (current_die != parent_die) {\n        dwarf_dealloc(dwarf, current_die, DW_DLA_DIE);\n        current_die = 0;\n      }\n\n      if (has_namespace) {\n        has_namespace = false;\n        ns.pop_back();\n      }\n      current_die = sibling_die;\n    }\n\n    if (has_namespace) {\n      ns.pop_back();\n    }\n    return branch_has_pc;\n  }\n\n  static std::string die_call_file(Dwarf_Debug dwarf, Dwarf_Die die,\n                                   Dwarf_Die cu_die) {\n    Dwarf_Attribute attr_mem;\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Unsigned file_index;\n\n    std::string file;\n\n    if (dwarf_attr(die, DW_AT_call_file, &attr_mem, &error) == DW_DLV_OK) {\n      if (dwarf_formudata(attr_mem, &file_index, &error) != DW_DLV_OK) {\n        file_index = 0;\n      }\n      dwarf_dealloc(dwarf, attr_mem, DW_DLA_ATTR);\n\n      if (file_index == 0) {\n        return file;\n      }\n\n      char **srcfiles = 0;\n      Dwarf_Signed file_count = 0;\n      if (dwarf_srcfiles(cu_die, &srcfiles, &file_count, &error) == DW_DLV_OK) {\n        if (file_count > 0 && file_index <= static_cast<Dwarf_Unsigned>(file_count)) {\n          file = std::string(srcfiles[file_index - 1]);\n\t}\n\n        // Deallocate all strings!\n        for (int i = 0; i < file_count; ++i) {\n          dwarf_dealloc(dwarf, srcfiles[i], DW_DLA_STRING);\n        }\n        dwarf_dealloc(dwarf, srcfiles, DW_DLA_LIST);\n      }\n    }\n    return file;\n  }\n\n  Dwarf_Die find_die(dwarf_fileobject &fobj, Dwarf_Addr addr) {\n    // Let's get to work! First see if we have a debug_aranges section so\n    // we can speed up the search\n\n    Dwarf_Debug dwarf = fobj.dwarf_handle.get();\n    Dwarf_Error error = DW_DLE_NE;\n    Dwarf_Arange *aranges;\n    Dwarf_Signed arange_count;\n\n    Dwarf_Die returnDie;\n    bool found = false;\n    if (dwarf_get_aranges(dwarf, &aranges, &arange_count, &error) !=\n        DW_DLV_OK) {\n      aranges = NULL;\n    }\n\n    if (aranges) {\n      // We have aranges. Get the one where our address is.\n      Dwarf_Arange arange;\n      if (dwarf_get_arange(aranges, arange_count, addr, &arange, &error) ==\n          DW_DLV_OK) {\n\n        // We found our address. Get the compilation-unit DIE offset\n        // represented by the given address range.\n        Dwarf_Off cu_die_offset;\n        if (dwarf_get_cu_die_offset(arange, &cu_die_offset, &error) ==\n            DW_DLV_OK) {\n          // Get the DIE at the offset returned by the aranges search.\n          // We set is_info to 1 to specify that the offset is from\n          // the .debug_info section (and not .debug_types)\n          int dwarf_result =\n              dwarf_offdie_b(dwarf, cu_die_offset, 1, &returnDie, &error);\n\n          found = dwarf_result == DW_DLV_OK;\n        }\n        dwarf_dealloc(dwarf, arange, DW_DLA_ARANGE);\n      }\n    }\n\n    if (found)\n      return returnDie; // The caller is responsible for freeing the die\n\n    // The search for aranges failed. Try to find our address by scanning\n    // all compilation units.\n    Dwarf_Unsigned next_cu_header;\n    Dwarf_Half tag = 0;\n    returnDie = 0;\n\n    while (!found &&\n           dwarf_next_cu_header_d(dwarf, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                                  &next_cu_header, 0, &error) == DW_DLV_OK) {\n\n      if (returnDie)\n        dwarf_dealloc(dwarf, returnDie, DW_DLA_DIE);\n\n      if (dwarf_siblingof(dwarf, 0, &returnDie, &error) == DW_DLV_OK) {\n        if ((dwarf_tag(returnDie, &tag, &error) == DW_DLV_OK) &&\n            tag == DW_TAG_compile_unit) {\n          if (die_has_pc(fobj, returnDie, addr)) {\n            found = true;\n          }\n        }\n      }\n    }\n\n    if (found) {\n      while (dwarf_next_cu_header_d(dwarf, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                                    &next_cu_header, 0, &error) == DW_DLV_OK) {\n        // Reset the cu header state. Libdwarf's next_cu_header API\n        // keeps its own iterator per Dwarf_Debug that can't be reset.\n        // We need to keep fetching elements until the end.\n      }\n    }\n\n    if (found)\n      return returnDie;\n\n    // We couldn't find any compilation units with ranges or a high/low pc.\n    // Try again by looking at all DIEs in all compilation units.\n    Dwarf_Die cudie;\n    while (dwarf_next_cu_header_d(dwarf, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                                  &next_cu_header, 0, &error) == DW_DLV_OK) {\n      if (dwarf_siblingof(dwarf, 0, &cudie, &error) == DW_DLV_OK) {\n        Dwarf_Die die_mem = 0;\n        Dwarf_Die resultDie = find_fundie_by_pc(fobj, cudie, addr, die_mem);\n\n        if (resultDie) {\n          found = true;\n          break;\n        }\n      }\n    }\n\n    if (found) {\n      while (dwarf_next_cu_header_d(dwarf, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                                    &next_cu_header, 0, &error) == DW_DLV_OK) {\n        // Reset the cu header state. Libdwarf's next_cu_header API\n        // keeps its own iterator per Dwarf_Debug that can't be reset.\n        // We need to keep fetching elements until the end.\n      }\n    }\n\n    if (found)\n      return cudie;\n\n    // We failed.\n    return NULL;\n  }\n};\n#endif // BACKWARD_HAS_DWARF == 1\n\ntemplate <>\nclass TraceResolverImpl<system_tag::linux_tag>\n    : public TraceResolverLinuxImpl<trace_resolver_tag::current> {};\n\n#endif // BACKWARD_SYSTEM_LINUX\n\n#ifdef BACKWARD_SYSTEM_DARWIN\n\ntemplate <typename STACKTRACE_TAG> class TraceResolverDarwinImpl;\n\ntemplate <>\nclass TraceResolverDarwinImpl<trace_resolver_tag::backtrace_symbol>\n    : public TraceResolverImplBase {\npublic:\n  void load_addresses(void *const*addresses, int address_count) override {\n    if (address_count == 0) {\n      return;\n    }\n    _symbols.reset(backtrace_symbols(addresses, address_count));\n  }\n\n  ResolvedTrace resolve(ResolvedTrace trace) override {\n    // parse:\n    // <n>  <file>  <addr>  <mangled-name> + <offset>\n    char *filename = _symbols[trace.idx];\n\n    // skip \"<n>  \"\n    while (*filename && *filename != ' ')\n      filename++;\n    while (*filename == ' ')\n      filename++;\n\n    // find start of <mangled-name> from end (<file> may contain a space)\n    char *p = filename + strlen(filename) - 1;\n    // skip to start of \" + <offset>\"\n    while (p > filename && *p != ' ')\n      p--;\n    while (p > filename && *p == ' ')\n      p--;\n    while (p > filename && *p != ' ')\n      p--;\n    while (p > filename && *p == ' ')\n      p--;\n    char *funcname_end = p + 1;\n\n    // skip to start of \"<manged-name>\"\n    while (p > filename && *p != ' ')\n      p--;\n    char *funcname = p + 1;\n\n    // skip to start of \"  <addr>  \"\n    while (p > filename && *p == ' ')\n      p--;\n    while (p > filename && *p != ' ')\n      p--;\n    while (p > filename && *p == ' ')\n      p--;\n\n    // skip \"<file>\", handling the case where it contains a\n    char *filename_end = p + 1;\n    if (p == filename) {\n      // something went wrong, give up\n      filename_end = filename + strlen(filename);\n      funcname = filename_end;\n    }\n    trace.object_filename.assign(\n        filename, filename_end); // ok even if filename_end is the ending \\0\n                                 // (then we assign entire string)\n\n    if (*funcname) { // if it's not end of string\n      *funcname_end = '\\0';\n\n      trace.object_function = this->demangle(funcname);\n      trace.object_function += \" \";\n      trace.object_function += (funcname_end + 1);\n      trace.source.function = trace.object_function; // we cannot do better.\n    }\n    return trace;\n  }\n\nprivate:\n  details::handle<char **> _symbols;\n};\n\ntemplate <>\nclass TraceResolverImpl<system_tag::darwin_tag>\n    : public TraceResolverDarwinImpl<trace_resolver_tag::current> {};\n\n#endif // BACKWARD_SYSTEM_DARWIN\n\n#ifdef BACKWARD_SYSTEM_WINDOWS\n\n// Load all symbol info\n// Based on:\n// https://stackoverflow.com/questions/6205981/windows-c-stack-trace-from-a-running-app/28276227#28276227\n\nstruct module_data {\n  std::string image_name;\n  std::string module_name;\n  void *base_address;\n  DWORD load_size;\n};\n\nclass get_mod_info {\n  HANDLE process;\n  static const int buffer_length = 4096;\n\npublic:\n  get_mod_info(HANDLE h) : process(h) {}\n\n  module_data operator()(HMODULE module) {\n    module_data ret;\n    char temp[buffer_length];\n    MODULEINFO mi;\n\n    GetModuleInformation(process, module, &mi, sizeof(mi));\n    ret.base_address = mi.lpBaseOfDll;\n    ret.load_size = mi.SizeOfImage;\n\n    GetModuleFileNameExA(process, module, temp, sizeof(temp));\n    ret.image_name = temp;\n    GetModuleBaseNameA(process, module, temp, sizeof(temp));\n    ret.module_name = temp;\n    std::vector<char> img(ret.image_name.begin(), ret.image_name.end());\n    std::vector<char> mod(ret.module_name.begin(), ret.module_name.end());\n    SymLoadModule64(process, 0, &img[0], &mod[0], (DWORD64)ret.base_address,\n                    ret.load_size);\n    return ret;\n  }\n};\n\ntemplate <> class TraceResolverImpl<system_tag::windows_tag>\n    : public TraceResolverImplBase {\npublic:\n  TraceResolverImpl() {\n\n    HANDLE process = GetCurrentProcess();\n\n    std::vector<module_data> modules;\n    DWORD cbNeeded;\n    std::vector<HMODULE> module_handles(1);\n    SymInitialize(process, NULL, false);\n    DWORD symOptions = SymGetOptions();\n    symOptions |= SYMOPT_LOAD_LINES | SYMOPT_UNDNAME;\n    SymSetOptions(symOptions);\n    EnumProcessModules(process, &module_handles[0],\n                       static_cast<DWORD>(module_handles.size() * sizeof(HMODULE)),\n\t\t       &cbNeeded);\n    module_handles.resize(cbNeeded / sizeof(HMODULE));\n    EnumProcessModules(process, &module_handles[0],\n                       static_cast<DWORD>(module_handles.size() * sizeof(HMODULE)),\n\t\t       &cbNeeded);\n    std::transform(module_handles.begin(), module_handles.end(),\n                   std::back_inserter(modules), get_mod_info(process));\n    void *base = modules[0].base_address;\n    IMAGE_NT_HEADERS *h = ImageNtHeader(base);\n    image_type = h->FileHeader.Machine;\n  }\n\n  static const int max_sym_len = 255;\n  struct symbol_t {\n    SYMBOL_INFO sym;\n    char buffer[max_sym_len];\n  } sym;\n\n  DWORD64 displacement;\n\n  ResolvedTrace resolve(ResolvedTrace t) override {\n    HANDLE process = GetCurrentProcess();\n\n    char name[256];\n\n    memset(&sym, 0, sizeof(sym));\n    sym.sym.SizeOfStruct = sizeof(SYMBOL_INFO);\n    sym.sym.MaxNameLen = max_sym_len;\n\n    if (!SymFromAddr(process, (ULONG64)t.addr, &displacement, &sym.sym)) {\n      // TODO:  error handling everywhere\n      char* lpMsgBuf;\n      DWORD dw = GetLastError();\n\n      if (FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                             FORMAT_MESSAGE_FROM_SYSTEM |\n                             FORMAT_MESSAGE_IGNORE_INSERTS,\n                         NULL, dw, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                         (char*)&lpMsgBuf, 0, NULL)) {\n        std::fprintf(stderr, \"%s\\n\", lpMsgBuf);\n        LocalFree(lpMsgBuf);\n      }\n\n      // abort();\n    }\n    UnDecorateSymbolName(sym.sym.Name, (PSTR)name, 256, UNDNAME_COMPLETE);\n\n    DWORD offset = 0;\n    IMAGEHLP_LINE line;\n    if (SymGetLineFromAddr(process, (ULONG64)t.addr, &offset, &line)) {\n      t.object_filename = line.FileName;\n      t.source.filename = line.FileName;\n      t.source.line = line.LineNumber;\n      t.source.col = offset;\n    }\n\n    t.source.function = name;\n    t.object_filename = \"\";\n    t.object_function = name;\n\n    return t;\n  }\n\n  DWORD machine_type() const { return image_type; }\n\nprivate:\n  DWORD image_type;\n};\n\n#endif\n\nclass TraceResolver : public TraceResolverImpl<system_tag::current_tag> {};\n\n/*************** CODE SNIPPET ***************/\n\nclass SourceFile {\npublic:\n  typedef std::vector<std::pair<unsigned, std::string> > lines_t;\n\n  SourceFile() {}\n  SourceFile(const std::string &path) {\n    // 1. If BACKWARD_CXX_SOURCE_PREFIXES is set then assume it contains\n    //    a colon-separated list of path prefixes.  Try prepending each\n    //    to the given path until a valid file is found.\n    const std::vector<std::string> &prefixes = get_paths_from_env_variable();\n    for (size_t i = 0; i < prefixes.size(); ++i) {\n      // Double slashes (//) should not be a problem.\n      std::string new_path = prefixes[i] + '/' + path;\n      _file.reset(new std::ifstream(new_path.c_str()));\n      if (is_open())\n        break;\n    }\n    // 2. If no valid file found then fallback to opening the path as-is.\n    if (!_file || !is_open()) {\n      _file.reset(new std::ifstream(path.c_str()));\n    }\n  }\n  bool is_open() const { return _file->is_open(); }\n\n  lines_t &get_lines(unsigned line_start, unsigned line_count, lines_t &lines) {\n    using namespace std;\n    // This function make uses of the dumbest algo ever:\n    //\t1) seek(0)\n    //\t2) read lines one by one and discard until line_start\n    //\t3) read line one by one until line_start + line_count\n    //\n    // If you are getting snippets many time from the same file, it is\n    // somewhat a waste of CPU, feel free to benchmark and propose a\n    // better solution ;)\n\n    _file->clear();\n    _file->seekg(0);\n    string line;\n    unsigned line_idx;\n\n    for (line_idx = 1; line_idx < line_start; ++line_idx) {\n      std::getline(*_file, line);\n      if (!*_file) {\n        return lines;\n      }\n    }\n\n    // think of it like a lambda in C++98 ;)\n    // but look, I will reuse it two times!\n    // What a good boy am I.\n    struct isspace {\n      bool operator()(char c) { return std::isspace(c); }\n    };\n\n    bool started = false;\n    for (; line_idx < line_start + line_count; ++line_idx) {\n      getline(*_file, line);\n      if (!*_file) {\n        return lines;\n      }\n      if (!started) {\n        if (std::find_if(line.begin(), line.end(), not_isspace()) == line.end())\n          continue;\n        started = true;\n      }\n      lines.push_back(make_pair(line_idx, line));\n    }\n\n    lines.erase(\n        std::find_if(lines.rbegin(), lines.rend(), not_isempty()).base(),\n        lines.end());\n    return lines;\n  }\n\n  lines_t get_lines(unsigned line_start, unsigned line_count) {\n    lines_t lines;\n    return get_lines(line_start, line_count, lines);\n  }\n\n  // there is no find_if_not in C++98, lets do something crappy to\n  // workaround.\n  struct not_isspace {\n    bool operator()(char c) { return !std::isspace(c); }\n  };\n  // and define this one here because C++98 is not happy with local defined\n  // struct passed to template functions, fuuuu.\n  struct not_isempty {\n    bool operator()(const lines_t::value_type &p) {\n      return !(std::find_if(p.second.begin(), p.second.end(), not_isspace()) ==\n               p.second.end());\n    }\n  };\n\n  void swap(SourceFile &b) { _file.swap(b._file); }\n\n#ifdef BACKWARD_ATLEAST_CXX11\n  SourceFile(SourceFile &&from) : _file(nullptr) { swap(from); }\n  SourceFile &operator=(SourceFile &&from) {\n    swap(from);\n    return *this;\n  }\n#else\n  explicit SourceFile(const SourceFile &from) {\n    // some sort of poor man's move semantic.\n    swap(const_cast<SourceFile &>(from));\n  }\n  SourceFile &operator=(const SourceFile &from) {\n    // some sort of poor man's move semantic.\n    swap(const_cast<SourceFile &>(from));\n    return *this;\n  }\n#endif\n\n  // Allow adding to paths gotten from BACKWARD_CXX_SOURCE_PREFIXES after loading the\n  // library; this can be useful when the library is loaded when the locations are unknown\n  // Warning: Because this edits the static paths variable, it is *not* intrinsiclly thread safe\n  static void add_paths_to_env_variable_impl(const std::string & to_add) {\n    get_mutable_paths_from_env_variable().push_back(to_add);\n  }\n\nprivate:\n  details::handle<std::ifstream *, details::default_delete<std::ifstream *> >\n      _file;\n\n  static std::vector<std::string> get_paths_from_env_variable_impl() {\n    std::vector<std::string> paths;\n    const char *prefixes_str = std::getenv(\"BACKWARD_CXX_SOURCE_PREFIXES\");\n    if (prefixes_str && prefixes_str[0]) {\n      paths = details::split_source_prefixes(prefixes_str);\n    }\n    return paths;\n  }\n\n  static std::vector<std::string> &get_mutable_paths_from_env_variable() {\n    static volatile std::vector<std::string> paths = get_paths_from_env_variable_impl();\n    return const_cast<std::vector<std::string>&>(paths);\n  }\n\n  static const std::vector<std::string> &get_paths_from_env_variable() {\n    return get_mutable_paths_from_env_variable();\n  }\n\n#ifdef BACKWARD_ATLEAST_CXX11\n  SourceFile(const SourceFile &) = delete;\n  SourceFile &operator=(const SourceFile &) = delete;\n#endif\n};\n\nclass SnippetFactory {\npublic:\n  typedef SourceFile::lines_t lines_t;\n\n  lines_t get_snippet(const std::string &filename, unsigned line_start,\n                      unsigned context_size) {\n\n    SourceFile &src_file = get_src_file(filename);\n    unsigned start = line_start - context_size / 2;\n    return src_file.get_lines(start, context_size);\n  }\n\n  lines_t get_combined_snippet(const std::string &filename_a, unsigned line_a,\n                               const std::string &filename_b, unsigned line_b,\n                               unsigned context_size) {\n    SourceFile &src_file_a = get_src_file(filename_a);\n    SourceFile &src_file_b = get_src_file(filename_b);\n\n    lines_t lines =\n        src_file_a.get_lines(line_a - context_size / 4, context_size / 2);\n    src_file_b.get_lines(line_b - context_size / 4, context_size / 2, lines);\n    return lines;\n  }\n\n  lines_t get_coalesced_snippet(const std::string &filename, unsigned line_a,\n                                unsigned line_b, unsigned context_size) {\n    SourceFile &src_file = get_src_file(filename);\n\n    using std::max;\n    using std::min;\n    unsigned a = min(line_a, line_b);\n    unsigned b = max(line_a, line_b);\n\n    if ((b - a) < (context_size / 3)) {\n      return src_file.get_lines((a + b - context_size + 1) / 2, context_size);\n    }\n\n    lines_t lines = src_file.get_lines(a - context_size / 4, context_size / 2);\n    src_file.get_lines(b - context_size / 4, context_size / 2, lines);\n    return lines;\n  }\n\nprivate:\n  typedef details::hashtable<std::string, SourceFile>::type src_files_t;\n  src_files_t _src_files;\n\n  SourceFile &get_src_file(const std::string &filename) {\n    src_files_t::iterator it = _src_files.find(filename);\n    if (it != _src_files.end()) {\n      return it->second;\n    }\n    SourceFile &new_src_file = _src_files[filename];\n    new_src_file = SourceFile(filename);\n    return new_src_file;\n  }\n};\n\n/*************** PRINTER ***************/\n\nnamespace ColorMode {\nenum type { automatic, never, always };\n}\n\nclass cfile_streambuf : public std::streambuf {\npublic:\n  cfile_streambuf(FILE *_sink) : sink(_sink) {}\n  int_type underflow() override { return traits_type::eof(); }\n  int_type overflow(int_type ch) override {\n    if (traits_type::not_eof(ch) && fputc(ch, sink) != EOF) {\n      return ch;\n    }\n    return traits_type::eof();\n  }\n\n  std::streamsize xsputn(const char_type *s, std::streamsize count) override {\n    return static_cast<std::streamsize>(\n        fwrite(s, sizeof *s, static_cast<size_t>(count), sink));\n  }\n\n#ifdef BACKWARD_ATLEAST_CXX11\npublic:\n  cfile_streambuf(const cfile_streambuf &) = delete;\n  cfile_streambuf &operator=(const cfile_streambuf &) = delete;\n#else\nprivate:\n  cfile_streambuf(const cfile_streambuf &);\n  cfile_streambuf &operator=(const cfile_streambuf &);\n#endif\n\nprivate:\n  FILE *sink;\n  std::vector<char> buffer;\n};\n\n#ifdef BACKWARD_SYSTEM_LINUX\n\nnamespace Color {\nenum type { yellow = 33, purple = 35, reset = 39 };\n} // namespace Color\n\nclass Colorize {\npublic:\n  Colorize(std::ostream &os) : _os(os), _reset(false), _enabled(false) {}\n\n  void activate(ColorMode::type mode) { _enabled = mode == ColorMode::always; }\n\n  void activate(ColorMode::type mode, FILE *fp) { activate(mode, fileno(fp)); }\n\n  void set_color(Color::type ccode) {\n    if (!_enabled)\n      return;\n\n    // I assume that the terminal can handle basic colors. Seriously I\n    // don't want to deal with all the termcap shit.\n    _os << \"\\033[\" << static_cast<int>(ccode) << \"m\";\n    _reset = (ccode != Color::reset);\n  }\n\n  ~Colorize() {\n    if (_reset) {\n      set_color(Color::reset);\n    }\n  }\n\nprivate:\n  void activate(ColorMode::type mode, int fd) {\n    activate(mode == ColorMode::automatic && isatty(fd) ? ColorMode::always\n                                                        : mode);\n  }\n\n  std::ostream &_os;\n  bool _reset;\n  bool _enabled;\n};\n\n#else // ndef BACKWARD_SYSTEM_LINUX\n\nnamespace Color {\nenum type { yellow = 0, purple = 0, reset = 0 };\n} // namespace Color\n\nclass Colorize {\npublic:\n  Colorize(std::ostream &) {}\n  void activate(ColorMode::type) {}\n  void activate(ColorMode::type, FILE *) {}\n  void set_color(Color::type) {}\n};\n\n#endif // BACKWARD_SYSTEM_LINUX\n\nclass Printer {\npublic:\n  bool snippet;\n  ColorMode::type color_mode;\n  bool address;\n  bool object;\n  int inliner_context_size;\n  int trace_context_size;\n  bool reverse;\n\n  Printer()\n      : snippet(true), color_mode(ColorMode::automatic), address(false),\n        object(false), inliner_context_size(5), trace_context_size(7),\n        reverse(true) {}\n\n  template <typename ST> FILE *print(ST &st, FILE *fp = stderr) {\n    cfile_streambuf obuf(fp);\n    std::ostream os(&obuf);\n    Colorize colorize(os);\n    colorize.activate(color_mode, fp);\n    print_stacktrace(st, os, colorize);\n    return fp;\n  }\n\n  template <typename ST> std::ostream &print(ST &st, std::ostream &os) {\n    Colorize colorize(os);\n    colorize.activate(color_mode);\n    print_stacktrace(st, os, colorize);\n    return os;\n  }\n\n  template <typename IT>\n  FILE *print(IT begin, IT end, FILE *fp = stderr, size_t thread_id = 0) {\n    cfile_streambuf obuf(fp);\n    std::ostream os(&obuf);\n    Colorize colorize(os);\n    colorize.activate(color_mode, fp);\n    print_stacktrace(begin, end, os, thread_id, colorize);\n    return fp;\n  }\n\n  template <typename IT>\n  std::ostream &print(IT begin, IT end, std::ostream &os,\n                      size_t thread_id = 0) {\n    Colorize colorize(os);\n    colorize.activate(color_mode);\n    print_stacktrace(begin, end, os, thread_id, colorize);\n    return os;\n  }\n\n  TraceResolver const &resolver() const { return _resolver; }\n\nprivate:\n  TraceResolver _resolver;\n  SnippetFactory _snippets;\n\n  template <typename ST>\n  void print_stacktrace(ST &st, std::ostream &os, Colorize &colorize) {\n    print_header(os, st.thread_id());\n    _resolver.load_stacktrace(st);\n    if ( reverse ) {\n      for (size_t trace_idx = st.size(); trace_idx > 0; --trace_idx) {\n        print_trace(os, _resolver.resolve(st[trace_idx - 1]), colorize);\n      }\n    } else {\n      for (size_t trace_idx = 0; trace_idx < st.size(); ++trace_idx) {\n        print_trace(os, _resolver.resolve(st[trace_idx]), colorize);\n      }\n    }\n  }\n\n  template <typename IT>\n  void print_stacktrace(IT begin, IT end, std::ostream &os, size_t thread_id,\n                        Colorize &colorize) {\n    print_header(os, thread_id);\n    for (; begin != end; ++begin) {\n      print_trace(os, *begin, colorize);\n    }\n  }\n\n  void print_header(std::ostream &os, size_t thread_id) {\n    os << \"Stack trace (most recent call last)\";\n    if (thread_id) {\n      os << \" in thread \" << thread_id;\n    }\n    os << \":\\n\";\n  }\n\n  void print_trace(std::ostream &os, const ResolvedTrace &trace,\n                   Colorize &colorize) {\n    os << \"#\" << std::left << std::setw(2) << trace.idx << std::right;\n    bool already_indented = true;\n\n    if (!trace.source.filename.size() || object) {\n      os << \"   Object \\\"\" << trace.object_filename << \"\\\", at \" << trace.addr\n         << \", in \" << trace.object_function << \"\\n\";\n      already_indented = false;\n    }\n\n    for (size_t inliner_idx = trace.inliners.size(); inliner_idx > 0;\n         --inliner_idx) {\n      if (!already_indented) {\n        os << \"   \";\n      }\n      const ResolvedTrace::SourceLoc &inliner_loc =\n          trace.inliners[inliner_idx - 1];\n      print_source_loc(os, \" | \", inliner_loc);\n      if (snippet) {\n        print_snippet(os, \"    | \", inliner_loc, colorize, Color::purple,\n                      inliner_context_size);\n      }\n      already_indented = false;\n    }\n\n    if (trace.source.filename.size()) {\n      if (!already_indented) {\n        os << \"   \";\n      }\n      print_source_loc(os, \"   \", trace.source, trace.addr);\n      if (snippet) {\n        print_snippet(os, \"      \", trace.source, colorize, Color::yellow,\n                      trace_context_size);\n      }\n    }\n  }\n\n  void print_snippet(std::ostream &os, const char *indent,\n                     const ResolvedTrace::SourceLoc &source_loc,\n                     Colorize &colorize, Color::type color_code,\n                     int context_size) {\n    using namespace std;\n    typedef SnippetFactory::lines_t lines_t;\n\n    lines_t lines = _snippets.get_snippet(source_loc.filename, source_loc.line,\n                                          static_cast<unsigned>(context_size));\n\n    for (lines_t::const_iterator it = lines.begin(); it != lines.end(); ++it) {\n      if (it->first == source_loc.line) {\n        colorize.set_color(color_code);\n        os << indent << \">\";\n      } else {\n        os << indent << \" \";\n      }\n      os << std::setw(4) << it->first << \": \" << it->second << \"\\n\";\n      if (it->first == source_loc.line) {\n        colorize.set_color(Color::reset);\n      }\n    }\n  }\n\n  void print_source_loc(std::ostream &os, const char *indent,\n                        const ResolvedTrace::SourceLoc &source_loc,\n                        void *addr = nullptr) {\n    os << indent << \"Source \\\"\" << source_loc.filename << \"\\\", line \"\n       << source_loc.line << \", in \" << source_loc.function;\n\n    if (address && addr != nullptr) {\n      os << \" [\" << addr << \"]\";\n    }\n    os << \"\\n\";\n  }\n};\n\n/*************** SIGNALS HANDLING ***************/\n\n#if defined(BACKWARD_SYSTEM_LINUX) || defined(BACKWARD_SYSTEM_DARWIN)\n\nclass SignalHandling {\npublic:\n  static std::vector<int> make_default_signals() {\n    const int posix_signals[] = {\n      // Signals for which the default action is \"Core\".\n      SIGABRT, // Abort signal from abort(3)\n      SIGBUS,  // Bus error (bad memory access)\n      SIGFPE,  // Floating point exception\n      SIGILL,  // Illegal Instruction\n      SIGIOT,  // IOT trap. A synonym for SIGABRT\n      SIGQUIT, // Quit from keyboard\n      SIGSEGV, // Invalid memory reference\n      SIGSYS,  // Bad argument to routine (SVr4)\n      SIGTRAP, // Trace/breakpoint trap\n      SIGXCPU, // CPU time limit exceeded (4.2BSD)\n      SIGXFSZ, // File size limit exceeded (4.2BSD)\n#if defined(BACKWARD_SYSTEM_DARWIN)\n      SIGEMT, // emulation instruction executed\n#endif\n    };\n    return std::vector<int>(posix_signals,\n                            posix_signals +\n                                sizeof posix_signals / sizeof posix_signals[0]);\n  }\n\n  SignalHandling(const std::vector<int> &posix_signals = make_default_signals())\n      : _loaded(false) {\n    bool success = true;\n\n    const size_t stack_size = 1024 * 1024 * 8;\n    _stack_content.reset(static_cast<char *>(malloc(stack_size)));\n    if (_stack_content) {\n      stack_t ss;\n      ss.ss_sp = _stack_content.get();\n      ss.ss_size = stack_size;\n      ss.ss_flags = 0;\n      if (sigaltstack(&ss, nullptr) < 0) {\n        success = false;\n      }\n    } else {\n      success = false;\n    }\n\n    for (size_t i = 0; i < posix_signals.size(); ++i) {\n      struct sigaction action;\n      memset(&action, 0, sizeof action);\n      action.sa_flags =\n          static_cast<int>(SA_SIGINFO | SA_ONSTACK | SA_NODEFER | SA_RESETHAND);\n      sigfillset(&action.sa_mask);\n      sigdelset(&action.sa_mask, posix_signals[i]);\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#endif\n      action.sa_sigaction = &sig_handler;\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n      int r = sigaction(posix_signals[i], &action, nullptr);\n      if (r < 0)\n        success = false;\n    }\n\n    _loaded = success;\n  }\n\n  bool loaded() const { return _loaded; }\n\n  static void handleSignal(int, siginfo_t *info, void *_ctx) {\n    ucontext_t *uctx = static_cast<ucontext_t *>(_ctx);\n\n    StackTrace st;\n    void *error_addr = nullptr;\n#ifdef REG_RIP // x86_64\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.gregs[REG_RIP]);\n#elif defined(REG_EIP) // x86_32\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.gregs[REG_EIP]);\n#elif defined(__arm__)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.arm_pc);\n#elif defined(__aarch64__)\n    #if defined(__APPLE__)\n      error_addr = reinterpret_cast<void *>(uctx->uc_mcontext->__ss.__pc);\n    #else\n      error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.pc);\n    #endif\n#elif defined(__mips__)\n    error_addr = reinterpret_cast<void *>(\n        reinterpret_cast<struct sigcontext *>(&uctx->uc_mcontext)->sc_pc);\n#elif defined(__ppc__) || defined(__powerpc) || defined(__powerpc__) ||        \\\n    defined(__POWERPC__)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.regs->nip);\n#elif defined(__riscv)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.__gregs[REG_PC]);\n#elif defined(__s390x__)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext.psw.addr);\n#elif defined(__APPLE__) && defined(__x86_64__)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext->__ss.__rip);\n#elif defined(__APPLE__)\n    error_addr = reinterpret_cast<void *>(uctx->uc_mcontext->__ss.__eip);\n#else\n#warning \":/ sorry, ain't know no nothing none not of your architecture!\"\n#endif\n    if (error_addr) {\n      st.load_from(error_addr, 32, reinterpret_cast<void *>(uctx),\n                   info->si_addr);\n    } else {\n      st.load_here(32, reinterpret_cast<void *>(uctx), info->si_addr);\n    }\n\n    Printer printer;\n    printer.address = true;\n    printer.print(st, stderr);\n\n#if (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 700) || \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809L)\n    psiginfo(info, nullptr);\n#else\n    (void)info;\n#endif\n  }\n\nprivate:\n  details::handle<char *> _stack_content;\n  bool _loaded;\n\n#ifdef __GNUC__\n  __attribute__((noreturn))\n#endif\n  static void\n  sig_handler(int signo, siginfo_t *info, void *_ctx) {\n    handleSignal(signo, info, _ctx);\n\n    // try to forward the signal.\n    raise(info->si_signo);\n\n    // terminate the process immediately.\n    puts(\"watf? exit\");\n    _exit(EXIT_FAILURE);\n  }\n};\n\n#endif // BACKWARD_SYSTEM_LINUX || BACKWARD_SYSTEM_DARWIN\n\n#ifdef BACKWARD_SYSTEM_WINDOWS\n\nclass SignalHandling {\npublic:\n  SignalHandling(const std::vector<int> & = std::vector<int>())\n      : reporter_thread_([]() {\n          /* We handle crashes in a utility thread:\n            backward structures and some Windows functions called here\n            need stack space, which we do not have when we encounter a\n            stack overflow.\n            To support reporting stack traces during a stack overflow,\n            we create a utility thread at startup, which waits until a\n            crash happens or the program exits normally. */\n\n          {\n            std::unique_lock<std::mutex> lk(mtx());\n            cv().wait(lk, [] { return crashed() != crash_status::running; });\n          }\n          if (crashed() == crash_status::crashed) {\n            handle_stacktrace(skip_recs());\n          }\n          {\n            std::unique_lock<std::mutex> lk(mtx());\n            crashed() = crash_status::ending;\n          }\n          cv().notify_one();\n        }) {\n    SetUnhandledExceptionFilter(crash_handler);\n\n    signal(SIGABRT, signal_handler);\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n\n    std::set_terminate(&terminator);\n#ifndef BACKWARD_ATLEAST_CXX17\n    std::set_unexpected(&terminator);\n#endif\n    _set_purecall_handler(&terminator);\n    _set_invalid_parameter_handler(&invalid_parameter_handler);\n  }\n  bool loaded() const { return true; }\n\n  ~SignalHandling() {\n    {\n      std::unique_lock<std::mutex> lk(mtx());\n      crashed() = crash_status::normal_exit;\n    }\n\n    cv().notify_one();\n\n    reporter_thread_.join();\n  }\n\nprivate:\n  static CONTEXT *ctx() {\n    static CONTEXT data;\n    return &data;\n  }\n\n  enum class crash_status { running, crashed, normal_exit, ending };\n\n  static crash_status &crashed() {\n    static crash_status data;\n    return data;\n  }\n\n  static std::mutex &mtx() {\n    static std::mutex data;\n    return data;\n  }\n\n  static std::condition_variable &cv() {\n    static std::condition_variable data;\n    return data;\n  }\n\n  static HANDLE &thread_handle() {\n    static HANDLE handle;\n    return handle;\n  }\n\n  std::thread reporter_thread_;\n\n  // TODO: how not to hardcode these?\n  static const constexpr int signal_skip_recs =\n#ifdef __clang__\n      // With clang, RtlCaptureContext also captures the stack frame of the\n      // current function Below that, there are 3 internal Windows functions\n      4\n#else\n      // With MSVC cl, RtlCaptureContext misses the stack frame of the current\n      // function The first entries during StackWalk are the 3 internal Windows\n      // functions\n      3\n#endif\n      ;\n\n  static int &skip_recs() {\n    static int data;\n    return data;\n  }\n\n  static inline void terminator() {\n    crash_handler(signal_skip_recs);\n    abort();\n  }\n\n  static inline void signal_handler(int) {\n    crash_handler(signal_skip_recs);\n    abort();\n  }\n\n  static inline void __cdecl invalid_parameter_handler(const wchar_t *,\n                                                       const wchar_t *,\n                                                       const wchar_t *,\n                                                       unsigned int,\n                                                       uintptr_t) {\n    crash_handler(signal_skip_recs);\n    abort();\n  }\n\n  NOINLINE static LONG WINAPI crash_handler(EXCEPTION_POINTERS *info) {\n    // The exception info supplies a trace from exactly where the issue was,\n    // no need to skip records\n    crash_handler(0, info->ContextRecord);\n    return EXCEPTION_CONTINUE_SEARCH;\n  }\n\n  NOINLINE static void crash_handler(int skip, CONTEXT *ct = nullptr) {\n\n    if (ct == nullptr) {\n      RtlCaptureContext(ctx());\n    } else {\n      memcpy(ctx(), ct, sizeof(CONTEXT));\n    }\n    DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n                    GetCurrentProcess(), &thread_handle(), 0, FALSE,\n                    DUPLICATE_SAME_ACCESS);\n\n    skip_recs() = skip;\n\n    {\n      std::unique_lock<std::mutex> lk(mtx());\n      crashed() = crash_status::crashed;\n    }\n\n    cv().notify_one();\n\n    {\n      std::unique_lock<std::mutex> lk(mtx());\n      cv().wait(lk, [] { return crashed() != crash_status::crashed; });\n    }\n  }\n\n  static void handle_stacktrace(int skip_frames = 0) {\n    // printer creates the TraceResolver, which can supply us a machine type\n    // for stack walking. Without this, StackTrace can only guess using some\n    // macros.\n    // StackTrace also requires that the PDBs are already loaded, which is done\n    // in the constructor of TraceResolver\n    Printer printer;\n\n    StackTrace st;\n    st.set_machine_type(printer.resolver().machine_type());\n    st.set_thread_handle(thread_handle());\n    st.load_here(32 + skip_frames, ctx());\n    st.skip_n_firsts(skip_frames);\n\n    printer.address = true;\n    printer.print(st, std::cerr);\n  }\n};\n\n#endif // BACKWARD_SYSTEM_WINDOWS\n\n#ifdef BACKWARD_SYSTEM_UNKNOWN\n\nclass SignalHandling {\npublic:\n  SignalHandling(const std::vector<int> & = std::vector<int>()) {}\n  bool init() { return false; }\n  bool loaded() { return false; }\n};\n\n#endif // BACKWARD_SYSTEM_UNKNOWN\n\n} // namespace backward\n\n#endif /* H_GUARD */\n"
        },
        {
          "name": "builds.sh",
          "type": "blob",
          "size": 1.3271484375,
          "content": "#!/bin/bash\n\nCOMPILERS_CXX98=`cat<<EOF\ngcc-4.4\ngcc-4.6\ngcc-4.7\ngcc-4.8\nclang\nEOF`\n\nCOMPILERS_CXX11=`cat<<EOF\ngcc-4.7\ngcc-4.8\nclang\nEOF`\n\n\nfunction mkbuild() {\n\tlocal compiler=$1\n\tlocal lang=$2\n\tlocal buildtype=$3\n\tlocal builddir=\"$4\"\n\texport CC=$compiler\n\texport CXX=`echo $compiler | sed -e 's/clang/clang++/' -e 's/gcc/g++/'`\n\texport CXXFLAGS=\"-std=$lang\"\n\techo \"Creating $builddir\"\n\tmkdir $builddir 2>/dev/null\n\t(\n\t\tcd \"$builddir\"\n\t\tcmake -DCMAKE_BUILD_TYPE=$buildtype -DBACKWARD_TESTS=ON ..\n\t)\n}\n\nfunction build() {\n\tlocal builddir=$1\n\tshift\n\tmake -C \"$builddir\" $@\n}\n\nfunction dotest() {\n\tlocal builddir=$1\n\tshift\n\tmake -C \"$builddir\" test $@\n\treturn 0\n}\n\nfunction do_action() {\n\tlocal lang=$1\n\tlocal action=$2\n\tshift 2\n\n\tfor compiler in $COMPILERS; do\n\t\tlocal builddir=\"build_${lang}_${compiler}\"\n\n\t\tif [[ $action == \"cmake\" ]]; then\n\t\t\tbuildtype=$1\n\t\t\tmkbuild $compiler $lang \"$buildtype\" \"$builddir\"\n\t\t\t[[ $? != 0 ]] && exit\n\t\telif [[ $action == \"make\" ]]; then\n\t\t\tbuild \"$builddir\" $@\n\t\t\t[[ $? != 0 ]] && exit\n\t\telif [[ $action == \"test\" ]]; then\n\t\t\tdotest \"$builddir\" $@\n\t\t\t[[ $? != 0 ]] && exit\n\t\telif [[ $action == \"clean\" ]]; then\n\t\t\trm -r \"$builddir\"\n\t\telse\n\t\t\techo \"usage: $0 cmake [debug|release|relwithdbg]|make|test|clean\"\n\t\t\texit 255\n\t\tfi\n\tdone\n}\n\nCOMPILERS=$COMPILERS_CXX98\ndo_action c++98 $@\nCOMPILERS=$COMPILERS_CXX11\ndo_action c++11 $@\n"
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 1.4736328125,
          "content": "from conans import ConanFile, CMake\nimport os\n\nclass BackwardCpp(ConanFile):\n    settings = 'os', 'compiler', 'build_type', 'arch'\n    name = 'backward'\n    url = 'https://github.com/bombela/backward-cpp'\n    license = 'MIT'\n    version = '1.3.0'\n    options = {\n        'stack_walking_unwind': [True, False],\n        'stack_walking_backtrace': [True, False],\n        'stack_details_auto_detect': [True, False],\n        'stack_details_backtrace_symbol': [True, False],\n        'stack_details_dw': [True, False],\n        'stack_details_bfd': [True, False],\n        'shared': [True, False]\n    }\n    default_options = (\n        'stack_walking_unwind=True',\n        'stack_walking_backtrace=False',\n        'stack_details_auto_detect=True',\n        'stack_details_backtrace_symbol=False',\n        'stack_details_dw=False',\n        'stack_details_bfd=False',\n        'shared=False'\n    )\n    exports = 'backward.cpp', 'backward.hpp', 'test/*', 'CMakeLists.txt', 'BackwardConfig.cmake'\n    generators = 'cmake'\n\n    def build(self):\n        cmake = CMake(self)\n\n        cmake.configure(defs={'BACKWARD_' + name.upper(): value for name, value in self.options.values.as_list()})\n        cmake.build()\n\n    def package(self):\n        self.copy('backward.hpp', os.path.join('include', 'backward'))\n        self.copy('*.a', dst='lib')\n        self.copy('*.so', dst='lib')\n        self.copy('*.lib', dst='lib')\n        self.copy('*.dll', dst='lib')\n\n    def package_info(self):\n        self.cpp_info.libs = ['backward']\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_package",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}