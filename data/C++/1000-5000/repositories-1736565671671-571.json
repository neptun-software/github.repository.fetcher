{
  "metadata": {
    "timestamp": 1736565671671,
    "page": 571,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dropbox/json11",
      "stars": 2558,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1494140625,
          "content": "# generated files\ntest\nlibjson11.a\njson11.pc\n\n# Cmake\nCMakeCache.txt\nCTestTestfile.cmake\nCMakeFiles\nCMakeScripts\ncmake_install.cmake\ninstall_manifest.txt"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.7880859375,
          "content": "cmake_minimum_required(VERSION 2.8)\nif (CMAKE_VERSION VERSION_LESS \"3\")\n  project(json11 CXX)\nelse()\n  cmake_policy(SET CMP0048 NEW)\n  project(json11 VERSION 1.0.0 LANGUAGES CXX)\nendif()\n\nenable_testing()\n\noption(JSON11_BUILD_TESTS \"Build unit tests\" OFF)\noption(JSON11_ENABLE_DR1467_CANARY \"Enable canary test for DR 1467\" OFF)\n\nif(CMAKE_VERSION VERSION_LESS \"3\")\n  add_definitions(-std=c++11)\nelse()\n  set(CMAKE_CXX_STANDARD 11)\n  set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX /usr)\nendif()\n\nadd_library(json11 json11.cpp)\ntarget_include_directories(json11 PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\ntarget_compile_options(json11\n  PRIVATE -fPIC -fno-rtti -fno-exceptions -Wall)\n\n# Set warning flags, which may vary per platform\ninclude(CheckCXXCompilerFlag)\nset(_possible_warnings_flags /W4 /WX -Wextra -Werror)\nforeach(_warning_flag ${_possible_warnings_flags})\n  unset(_flag_supported)\n  CHECK_CXX_COMPILER_FLAG(${_warning_flag} _flag_supported)\n  if(${_flag_supported})\n    target_compile_options(json11 PRIVATE ${_warning_flag})\n  endif()\nendforeach()\n\nconfigure_file(\"json11.pc.in\" \"json11.pc\" @ONLY)\n\nif (JSON11_BUILD_TESTS)\n\n  # enable test for DR1467, described here: https://llvm.org/bugs/show_bug.cgi?id=23812\n  if(JSON11_ENABLE_DR1467_CANARY)\n    add_definitions(-D JSON11_ENABLE_DR1467_CANARY=1)\n  else()\n    add_definitions(-D JSON11_ENABLE_DR1467_CANARY=0)\n  endif()\n\n  add_executable(json11_test test.cpp)\n  target_link_libraries(json11_test json11)\nendif()\n\ninstall(TARGETS json11 DESTINATION lib/${CMAKE_LIBRARY_ARCHITECTURE})\ninstall(FILES \"${CMAKE_CURRENT_SOURCE_DIR}/json11.hpp\" DESTINATION include/${CMAKE_LIBRARY_ARCHITECTURE})\ninstall(FILES \"${CMAKE_CURRENT_BINARY_DIR}/json11.pc\" DESTINATION lib/${CMAKE_LIBRARY_ARCHITECTURE}/pkgconfig)\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (c) 2013 Dropbox, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.578125,
          "content": "# Environment variable to enable or disable code which demonstrates the behavior change\n# in Xcode 7 / Clang 3.7, introduced by DR1467 and described here:\n# https://llvm.org/bugs/show_bug.cgi?id=23812\n# Defaults to on in order to act as a warning to anyone who's unaware of the issue.\nifneq ($(JSON11_ENABLE_DR1467_CANARY),)\nCANARY_ARGS = -DJSON11_ENABLE_DR1467_CANARY=$(JSON11_ENABLE_DR1467_CANARY)\nendif\n\ntest: json11.cpp json11.hpp test.cpp\n\t$(CXX) $(CANARY_ARGS) -O -std=c++11 json11.cpp test.cpp -o test -fno-rtti -fno-exceptions\n\nclean:\n\tif [ -e test ]; then rm test; fi\n\n.PHONY: clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.41796875,
          "content": "json11\n------\n\njson11 is a tiny JSON library for C++11, providing JSON parsing and serialization.\n\nThe core object provided by the library is json11::Json. A Json object represents any JSON\nvalue: null, bool, number (int or double), string (std::string), array (std::vector), or\nobject (std::map).\n\nJson objects act like values. They can be assigned, copied, moved, compared for equality or\norder, and so on. There are also helper methods Json::dump, to serialize a Json to a string, and\nJson::parse (static) to parse a std::string as a Json object.\n\nIt's easy to make a JSON object with C++11's new initializer syntax:\n\n    Json my_json = Json::object {\n        { \"key1\", \"value1\" },\n        { \"key2\", false },\n        { \"key3\", Json::array { 1, 2, 3 } },\n    };\n    std::string json_str = my_json.dump();\n\nThere are also implicit constructors that allow standard and user-defined types to be\nautomatically converted to JSON. For example:\n\n    class Point {\n    public:\n        int x;\n        int y;\n        Point (int x, int y) : x(x), y(y) {}\n        Json to_json() const { return Json::array { x, y }; }\n    };\n\n    std::vector<Point> points = { { 1, 2 }, { 10, 20 }, { 100, 200 } };\n    std::string points_json = Json(points).dump();\n\nJSON values can have their values queried and inspected:\n\n    Json json = Json::array { Json::object { { \"k\", \"v\" } } };\n    std::string str = json[0][\"k\"].string_value();\n\nFor more documentation see json11.hpp.\n"
        },
        {
          "name": "json11.cpp",
          "type": "blob",
          "size": 24.462890625,
          "content": "/* Copyright (c) 2013 Dropbox, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"json11.hpp\"\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <limits>\n\nnamespace json11 {\n\nstatic const int max_depth = 200;\n\nusing std::string;\nusing std::vector;\nusing std::map;\nusing std::make_shared;\nusing std::initializer_list;\nusing std::move;\n\n/* Helper for representing null - just a do-nothing struct, plus comparison\n * operators so the helpers in JsonValue work. We can't use nullptr_t because\n * it may not be orderable.\n */\nstruct NullStruct {\n    bool operator==(NullStruct) const { return true; }\n    bool operator<(NullStruct) const { return false; }\n};\n\n/* * * * * * * * * * * * * * * * * * * *\n * Serialization\n */\n\nstatic void dump(NullStruct, string &out) {\n    out += \"null\";\n}\n\nstatic void dump(double value, string &out) {\n    if (std::isfinite(value)) {\n        char buf[32];\n        snprintf(buf, sizeof buf, \"%.17g\", value);\n        out += buf;\n    } else {\n        out += \"null\";\n    }\n}\n\nstatic void dump(int value, string &out) {\n    char buf[32];\n    snprintf(buf, sizeof buf, \"%d\", value);\n    out += buf;\n}\n\nstatic void dump(bool value, string &out) {\n    out += value ? \"true\" : \"false\";\n}\n\nstatic void dump(const string &value, string &out) {\n    out += '\"';\n    for (size_t i = 0; i < value.length(); i++) {\n        const char ch = value[i];\n        if (ch == '\\\\') {\n            out += \"\\\\\\\\\";\n        } else if (ch == '\"') {\n            out += \"\\\\\\\"\";\n        } else if (ch == '\\b') {\n            out += \"\\\\b\";\n        } else if (ch == '\\f') {\n            out += \"\\\\f\";\n        } else if (ch == '\\n') {\n            out += \"\\\\n\";\n        } else if (ch == '\\r') {\n            out += \"\\\\r\";\n        } else if (ch == '\\t') {\n            out += \"\\\\t\";\n        } else if (static_cast<uint8_t>(ch) <= 0x1f) {\n            char buf[8];\n            snprintf(buf, sizeof buf, \"\\\\u%04x\", ch);\n            out += buf;\n        } else if (static_cast<uint8_t>(ch) == 0xe2 && static_cast<uint8_t>(value[i+1]) == 0x80\n                   && static_cast<uint8_t>(value[i+2]) == 0xa8) {\n            out += \"\\\\u2028\";\n            i += 2;\n        } else if (static_cast<uint8_t>(ch) == 0xe2 && static_cast<uint8_t>(value[i+1]) == 0x80\n                   && static_cast<uint8_t>(value[i+2]) == 0xa9) {\n            out += \"\\\\u2029\";\n            i += 2;\n        } else {\n            out += ch;\n        }\n    }\n    out += '\"';\n}\n\nstatic void dump(const Json::array &values, string &out) {\n    bool first = true;\n    out += \"[\";\n    for (const auto &value : values) {\n        if (!first)\n            out += \", \";\n        value.dump(out);\n        first = false;\n    }\n    out += \"]\";\n}\n\nstatic void dump(const Json::object &values, string &out) {\n    bool first = true;\n    out += \"{\";\n    for (const auto &kv : values) {\n        if (!first)\n            out += \", \";\n        dump(kv.first, out);\n        out += \": \";\n        kv.second.dump(out);\n        first = false;\n    }\n    out += \"}\";\n}\n\nvoid Json::dump(string &out) const {\n    m_ptr->dump(out);\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Value wrappers\n */\n\ntemplate <Json::Type tag, typename T>\nclass Value : public JsonValue {\nprotected:\n\n    // Constructors\n    explicit Value(const T &value) : m_value(value) {}\n    explicit Value(T &&value)      : m_value(move(value)) {}\n\n    // Get type tag\n    Json::Type type() const override {\n        return tag;\n    }\n\n    // Comparisons\n    bool equals(const JsonValue * other) const override {\n        return m_value == static_cast<const Value<tag, T> *>(other)->m_value;\n    }\n    bool less(const JsonValue * other) const override {\n        return m_value < static_cast<const Value<tag, T> *>(other)->m_value;\n    }\n\n    const T m_value;\n    void dump(string &out) const override { json11::dump(m_value, out); }\n};\n\nclass JsonDouble final : public Value<Json::NUMBER, double> {\n    double number_value() const override { return m_value; }\n    int int_value() const override { return static_cast<int>(m_value); }\n    bool equals(const JsonValue * other) const override { return m_value == other->number_value(); }\n    bool less(const JsonValue * other)   const override { return m_value <  other->number_value(); }\npublic:\n    explicit JsonDouble(double value) : Value(value) {}\n};\n\nclass JsonInt final : public Value<Json::NUMBER, int> {\n    double number_value() const override { return m_value; }\n    int int_value() const override { return m_value; }\n    bool equals(const JsonValue * other) const override { return m_value == other->number_value(); }\n    bool less(const JsonValue * other)   const override { return m_value <  other->number_value(); }\npublic:\n    explicit JsonInt(int value) : Value(value) {}\n};\n\nclass JsonBoolean final : public Value<Json::BOOL, bool> {\n    bool bool_value() const override { return m_value; }\npublic:\n    explicit JsonBoolean(bool value) : Value(value) {}\n};\n\nclass JsonString final : public Value<Json::STRING, string> {\n    const string &string_value() const override { return m_value; }\npublic:\n    explicit JsonString(const string &value) : Value(value) {}\n    explicit JsonString(string &&value)      : Value(move(value)) {}\n};\n\nclass JsonArray final : public Value<Json::ARRAY, Json::array> {\n    const Json::array &array_items() const override { return m_value; }\n    const Json & operator[](size_t i) const override;\npublic:\n    explicit JsonArray(const Json::array &value) : Value(value) {}\n    explicit JsonArray(Json::array &&value)      : Value(move(value)) {}\n};\n\nclass JsonObject final : public Value<Json::OBJECT, Json::object> {\n    const Json::object &object_items() const override { return m_value; }\n    const Json & operator[](const string &key) const override;\npublic:\n    explicit JsonObject(const Json::object &value) : Value(value) {}\n    explicit JsonObject(Json::object &&value)      : Value(move(value)) {}\n};\n\nclass JsonNull final : public Value<Json::NUL, NullStruct> {\npublic:\n    JsonNull() : Value({}) {}\n};\n\n/* * * * * * * * * * * * * * * * * * * *\n * Static globals - static-init-safe\n */\nstruct Statics {\n    const std::shared_ptr<JsonValue> null = make_shared<JsonNull>();\n    const std::shared_ptr<JsonValue> t = make_shared<JsonBoolean>(true);\n    const std::shared_ptr<JsonValue> f = make_shared<JsonBoolean>(false);\n    const string empty_string;\n    const vector<Json> empty_vector;\n    const map<string, Json> empty_map;\n    Statics() {}\n};\n\nstatic const Statics & statics() {\n    static const Statics s {};\n    return s;\n}\n\nstatic const Json & static_null() {\n    // This has to be separate, not in Statics, because Json() accesses statics().null.\n    static const Json json_null;\n    return json_null;\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Constructors\n */\n\nJson::Json() noexcept                  : m_ptr(statics().null) {}\nJson::Json(std::nullptr_t) noexcept    : m_ptr(statics().null) {}\nJson::Json(double value)               : m_ptr(make_shared<JsonDouble>(value)) {}\nJson::Json(int value)                  : m_ptr(make_shared<JsonInt>(value)) {}\nJson::Json(bool value)                 : m_ptr(value ? statics().t : statics().f) {}\nJson::Json(const string &value)        : m_ptr(make_shared<JsonString>(value)) {}\nJson::Json(string &&value)             : m_ptr(make_shared<JsonString>(move(value))) {}\nJson::Json(const char * value)         : m_ptr(make_shared<JsonString>(value)) {}\nJson::Json(const Json::array &values)  : m_ptr(make_shared<JsonArray>(values)) {}\nJson::Json(Json::array &&values)       : m_ptr(make_shared<JsonArray>(move(values))) {}\nJson::Json(const Json::object &values) : m_ptr(make_shared<JsonObject>(values)) {}\nJson::Json(Json::object &&values)      : m_ptr(make_shared<JsonObject>(move(values))) {}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Accessors\n */\n\nJson::Type Json::type()                           const { return m_ptr->type();         }\ndouble Json::number_value()                       const { return m_ptr->number_value(); }\nint Json::int_value()                             const { return m_ptr->int_value();    }\nbool Json::bool_value()                           const { return m_ptr->bool_value();   }\nconst string & Json::string_value()               const { return m_ptr->string_value(); }\nconst vector<Json> & Json::array_items()          const { return m_ptr->array_items();  }\nconst map<string, Json> & Json::object_items()    const { return m_ptr->object_items(); }\nconst Json & Json::operator[] (size_t i)          const { return (*m_ptr)[i];           }\nconst Json & Json::operator[] (const string &key) const { return (*m_ptr)[key];         }\n\ndouble                    JsonValue::number_value()              const { return 0; }\nint                       JsonValue::int_value()                 const { return 0; }\nbool                      JsonValue::bool_value()                const { return false; }\nconst string &            JsonValue::string_value()              const { return statics().empty_string; }\nconst vector<Json> &      JsonValue::array_items()               const { return statics().empty_vector; }\nconst map<string, Json> & JsonValue::object_items()              const { return statics().empty_map; }\nconst Json &              JsonValue::operator[] (size_t)         const { return static_null(); }\nconst Json &              JsonValue::operator[] (const string &) const { return static_null(); }\n\nconst Json & JsonObject::operator[] (const string &key) const {\n    auto iter = m_value.find(key);\n    return (iter == m_value.end()) ? static_null() : iter->second;\n}\nconst Json & JsonArray::operator[] (size_t i) const {\n    if (i >= m_value.size()) return static_null();\n    else return m_value[i];\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Comparison\n */\n\nbool Json::operator== (const Json &other) const {\n    if (m_ptr == other.m_ptr)\n        return true;\n    if (m_ptr->type() != other.m_ptr->type())\n        return false;\n\n    return m_ptr->equals(other.m_ptr.get());\n}\n\nbool Json::operator< (const Json &other) const {\n    if (m_ptr == other.m_ptr)\n        return false;\n    if (m_ptr->type() != other.m_ptr->type())\n        return m_ptr->type() < other.m_ptr->type();\n\n    return m_ptr->less(other.m_ptr.get());\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Parsing\n */\n\n/* esc(c)\n *\n * Format char c suitable for printing in an error message.\n */\nstatic inline string esc(char c) {\n    char buf[12];\n    if (static_cast<uint8_t>(c) >= 0x20 && static_cast<uint8_t>(c) <= 0x7f) {\n        snprintf(buf, sizeof buf, \"'%c' (%d)\", c, c);\n    } else {\n        snprintf(buf, sizeof buf, \"(%d)\", c);\n    }\n    return string(buf);\n}\n\nstatic inline bool in_range(long x, long lower, long upper) {\n    return (x >= lower && x <= upper);\n}\n\nnamespace {\n/* JsonParser\n *\n * Object that tracks all state of an in-progress parse.\n */\nstruct JsonParser final {\n\n    /* State\n     */\n    const string &str;\n    size_t i;\n    string &err;\n    bool failed;\n    const JsonParse strategy;\n\n    /* fail(msg, err_ret = Json())\n     *\n     * Mark this parse as failed.\n     */\n    Json fail(string &&msg) {\n        return fail(move(msg), Json());\n    }\n\n    template <typename T>\n    T fail(string &&msg, const T err_ret) {\n        if (!failed)\n            err = std::move(msg);\n        failed = true;\n        return err_ret;\n    }\n\n    /* consume_whitespace()\n     *\n     * Advance until the current character is non-whitespace.\n     */\n    void consume_whitespace() {\n        while (str[i] == ' ' || str[i] == '\\r' || str[i] == '\\n' || str[i] == '\\t')\n            i++;\n    }\n\n    /* consume_comment()\n     *\n     * Advance comments (c-style inline and multiline).\n     */\n    bool consume_comment() {\n      bool comment_found = false;\n      if (str[i] == '/') {\n        i++;\n        if (i == str.size())\n          return fail(\"unexpected end of input after start of comment\", false);\n        if (str[i] == '/') { // inline comment\n          i++;\n          // advance until next line, or end of input\n          while (i < str.size() && str[i] != '\\n') {\n            i++;\n          }\n          comment_found = true;\n        }\n        else if (str[i] == '*') { // multiline comment\n          i++;\n          if (i > str.size()-2)\n            return fail(\"unexpected end of input inside multi-line comment\", false);\n          // advance until closing tokens\n          while (!(str[i] == '*' && str[i+1] == '/')) {\n            i++;\n            if (i > str.size()-2)\n              return fail(\n                \"unexpected end of input inside multi-line comment\", false);\n          }\n          i += 2;\n          comment_found = true;\n        }\n        else\n          return fail(\"malformed comment\", false);\n      }\n      return comment_found;\n    }\n\n    /* consume_garbage()\n     *\n     * Advance until the current character is non-whitespace and non-comment.\n     */\n    void consume_garbage() {\n      consume_whitespace();\n      if(strategy == JsonParse::COMMENTS) {\n        bool comment_found = false;\n        do {\n          comment_found = consume_comment();\n          if (failed) return;\n          consume_whitespace();\n        }\n        while(comment_found);\n      }\n    }\n\n    /* get_next_token()\n     *\n     * Return the next non-whitespace character. If the end of the input is reached,\n     * flag an error and return 0.\n     */\n    char get_next_token() {\n        consume_garbage();\n        if (failed) return static_cast<char>(0);\n        if (i == str.size())\n            return fail(\"unexpected end of input\", static_cast<char>(0));\n\n        return str[i++];\n    }\n\n    /* encode_utf8(pt, out)\n     *\n     * Encode pt as UTF-8 and add it to out.\n     */\n    void encode_utf8(long pt, string & out) {\n        if (pt < 0)\n            return;\n\n        if (pt < 0x80) {\n            out += static_cast<char>(pt);\n        } else if (pt < 0x800) {\n            out += static_cast<char>((pt >> 6) | 0xC0);\n            out += static_cast<char>((pt & 0x3F) | 0x80);\n        } else if (pt < 0x10000) {\n            out += static_cast<char>((pt >> 12) | 0xE0);\n            out += static_cast<char>(((pt >> 6) & 0x3F) | 0x80);\n            out += static_cast<char>((pt & 0x3F) | 0x80);\n        } else {\n            out += static_cast<char>((pt >> 18) | 0xF0);\n            out += static_cast<char>(((pt >> 12) & 0x3F) | 0x80);\n            out += static_cast<char>(((pt >> 6) & 0x3F) | 0x80);\n            out += static_cast<char>((pt & 0x3F) | 0x80);\n        }\n    }\n\n    /* parse_string()\n     *\n     * Parse a string, starting at the current position.\n     */\n    string parse_string() {\n        string out;\n        long last_escaped_codepoint = -1;\n        while (true) {\n            if (i == str.size())\n                return fail(\"unexpected end of input in string\", \"\");\n\n            char ch = str[i++];\n\n            if (ch == '\"') {\n                encode_utf8(last_escaped_codepoint, out);\n                return out;\n            }\n\n            if (in_range(ch, 0, 0x1f))\n                return fail(\"unescaped \" + esc(ch) + \" in string\", \"\");\n\n            // The usual case: non-escaped characters\n            if (ch != '\\\\') {\n                encode_utf8(last_escaped_codepoint, out);\n                last_escaped_codepoint = -1;\n                out += ch;\n                continue;\n            }\n\n            // Handle escapes\n            if (i == str.size())\n                return fail(\"unexpected end of input in string\", \"\");\n\n            ch = str[i++];\n\n            if (ch == 'u') {\n                // Extract 4-byte escape sequence\n                string esc = str.substr(i, 4);\n                // Explicitly check length of the substring. The following loop\n                // relies on std::string returning the terminating NUL when\n                // accessing str[length]. Checking here reduces brittleness.\n                if (esc.length() < 4) {\n                    return fail(\"bad \\\\u escape: \" + esc, \"\");\n                }\n                for (size_t j = 0; j < 4; j++) {\n                    if (!in_range(esc[j], 'a', 'f') && !in_range(esc[j], 'A', 'F')\n                            && !in_range(esc[j], '0', '9'))\n                        return fail(\"bad \\\\u escape: \" + esc, \"\");\n                }\n\n                long codepoint = strtol(esc.data(), nullptr, 16);\n\n                // JSON specifies that characters outside the BMP shall be encoded as a pair\n                // of 4-hex-digit \\u escapes encoding their surrogate pair components. Check\n                // whether we're in the middle of such a beast: the previous codepoint was an\n                // escaped lead (high) surrogate, and this is a trail (low) surrogate.\n                if (in_range(last_escaped_codepoint, 0xD800, 0xDBFF)\n                        && in_range(codepoint, 0xDC00, 0xDFFF)) {\n                    // Reassemble the two surrogate pairs into one astral-plane character, per\n                    // the UTF-16 algorithm.\n                    encode_utf8((((last_escaped_codepoint - 0xD800) << 10)\n                                 | (codepoint - 0xDC00)) + 0x10000, out);\n                    last_escaped_codepoint = -1;\n                } else {\n                    encode_utf8(last_escaped_codepoint, out);\n                    last_escaped_codepoint = codepoint;\n                }\n\n                i += 4;\n                continue;\n            }\n\n            encode_utf8(last_escaped_codepoint, out);\n            last_escaped_codepoint = -1;\n\n            if (ch == 'b') {\n                out += '\\b';\n            } else if (ch == 'f') {\n                out += '\\f';\n            } else if (ch == 'n') {\n                out += '\\n';\n            } else if (ch == 'r') {\n                out += '\\r';\n            } else if (ch == 't') {\n                out += '\\t';\n            } else if (ch == '\"' || ch == '\\\\' || ch == '/') {\n                out += ch;\n            } else {\n                return fail(\"invalid escape character \" + esc(ch), \"\");\n            }\n        }\n    }\n\n    /* parse_number()\n     *\n     * Parse a double.\n     */\n    Json parse_number() {\n        size_t start_pos = i;\n\n        if (str[i] == '-')\n            i++;\n\n        // Integer part\n        if (str[i] == '0') {\n            i++;\n            if (in_range(str[i], '0', '9'))\n                return fail(\"leading 0s not permitted in numbers\");\n        } else if (in_range(str[i], '1', '9')) {\n            i++;\n            while (in_range(str[i], '0', '9'))\n                i++;\n        } else {\n            return fail(\"invalid \" + esc(str[i]) + \" in number\");\n        }\n\n        if (str[i] != '.' && str[i] != 'e' && str[i] != 'E'\n                && (i - start_pos) <= static_cast<size_t>(std::numeric_limits<int>::digits10)) {\n            return std::atoi(str.c_str() + start_pos);\n        }\n\n        // Decimal part\n        if (str[i] == '.') {\n            i++;\n            if (!in_range(str[i], '0', '9'))\n                return fail(\"at least one digit required in fractional part\");\n\n            while (in_range(str[i], '0', '9'))\n                i++;\n        }\n\n        // Exponent part\n        if (str[i] == 'e' || str[i] == 'E') {\n            i++;\n\n            if (str[i] == '+' || str[i] == '-')\n                i++;\n\n            if (!in_range(str[i], '0', '9'))\n                return fail(\"at least one digit required in exponent\");\n\n            while (in_range(str[i], '0', '9'))\n                i++;\n        }\n\n        return std::strtod(str.c_str() + start_pos, nullptr);\n    }\n\n    /* expect(str, res)\n     *\n     * Expect that 'str' starts at the character that was just read. If it does, advance\n     * the input and return res. If not, flag an error.\n     */\n    Json expect(const string &expected, Json res) {\n        assert(i != 0);\n        i--;\n        if (str.compare(i, expected.length(), expected) == 0) {\n            i += expected.length();\n            return res;\n        } else {\n            return fail(\"parse error: expected \" + expected + \", got \" + str.substr(i, expected.length()));\n        }\n    }\n\n    /* parse_json()\n     *\n     * Parse a JSON object.\n     */\n    Json parse_json(int depth) {\n        if (depth > max_depth) {\n            return fail(\"exceeded maximum nesting depth\");\n        }\n\n        char ch = get_next_token();\n        if (failed)\n            return Json();\n\n        if (ch == '-' || (ch >= '0' && ch <= '9')) {\n            i--;\n            return parse_number();\n        }\n\n        if (ch == 't')\n            return expect(\"true\", true);\n\n        if (ch == 'f')\n            return expect(\"false\", false);\n\n        if (ch == 'n')\n            return expect(\"null\", Json());\n\n        if (ch == '\"')\n            return parse_string();\n\n        if (ch == '{') {\n            map<string, Json> data;\n            ch = get_next_token();\n            if (ch == '}')\n                return data;\n\n            while (1) {\n                if (ch != '\"')\n                    return fail(\"expected '\\\"' in object, got \" + esc(ch));\n\n                string key = parse_string();\n                if (failed)\n                    return Json();\n\n                ch = get_next_token();\n                if (ch != ':')\n                    return fail(\"expected ':' in object, got \" + esc(ch));\n\n                data[std::move(key)] = parse_json(depth + 1);\n                if (failed)\n                    return Json();\n\n                ch = get_next_token();\n                if (ch == '}')\n                    break;\n                if (ch != ',')\n                    return fail(\"expected ',' in object, got \" + esc(ch));\n\n                ch = get_next_token();\n            }\n            return data;\n        }\n\n        if (ch == '[') {\n            vector<Json> data;\n            ch = get_next_token();\n            if (ch == ']')\n                return data;\n\n            while (1) {\n                i--;\n                data.push_back(parse_json(depth + 1));\n                if (failed)\n                    return Json();\n\n                ch = get_next_token();\n                if (ch == ']')\n                    break;\n                if (ch != ',')\n                    return fail(\"expected ',' in list, got \" + esc(ch));\n\n                ch = get_next_token();\n                (void)ch;\n            }\n            return data;\n        }\n\n        return fail(\"expected value, got \" + esc(ch));\n    }\n};\n}//namespace {\n\nJson Json::parse(const string &in, string &err, JsonParse strategy) {\n    JsonParser parser { in, 0, err, false, strategy };\n    Json result = parser.parse_json(0);\n\n    // Check for any trailing garbage\n    parser.consume_garbage();\n    if (parser.failed)\n        return Json();\n    if (parser.i != in.size())\n        return parser.fail(\"unexpected trailing \" + esc(in[parser.i]));\n\n    return result;\n}\n\n// Documented in json11.hpp\nvector<Json> Json::parse_multi(const string &in,\n                               std::string::size_type &parser_stop_pos,\n                               string &err,\n                               JsonParse strategy) {\n    JsonParser parser { in, 0, err, false, strategy };\n    parser_stop_pos = 0;\n    vector<Json> json_vec;\n    while (parser.i != in.size() && !parser.failed) {\n        json_vec.push_back(parser.parse_json(0));\n        if (parser.failed)\n            break;\n\n        // Check for another object\n        parser.consume_garbage();\n        if (parser.failed)\n            break;\n        parser_stop_pos = parser.i;\n    }\n    return json_vec;\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Shape-checking\n */\n\nbool Json::has_shape(const shape & types, string & err) const {\n    if (!is_object()) {\n        err = \"expected JSON object, got \" + dump();\n        return false;\n    }\n\n    const auto& obj_items = object_items();\n    for (auto & item : types) {\n        const auto it = obj_items.find(item.first);\n        if (it == obj_items.cend() || it->second.type() != item.second) {\n            err = \"bad type for \" + item.first + \" in \" + dump();\n            return false;\n        }\n    }\n\n    return true;\n}\n\n} // namespace json11\n"
        },
        {
          "name": "json11.hpp",
          "type": "blob",
          "size": 9.05078125,
          "content": "/* json11\n *\n * json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.\n *\n * The core object provided by the library is json11::Json. A Json object represents any JSON\n * value: null, bool, number (int or double), string (std::string), array (std::vector), or\n * object (std::map).\n *\n * Json objects act like values: they can be assigned, copied, moved, compared for equality or\n * order, etc. There are also helper methods Json::dump, to serialize a Json to a string, and\n * Json::parse (static) to parse a std::string as a Json object.\n *\n * Internally, the various types of Json object are represented by the JsonValue class\n * hierarchy.\n *\n * A note on numbers - JSON specifies the syntax of number formatting but not its semantics,\n * so some JSON implementations distinguish between integers and floating-point numbers, while\n * some don't. In json11, we choose the latter. Because some JSON implementations (namely\n * Javascript itself) treat all numbers as the same type, distinguishing the two leads\n * to JSON that will be *silently* changed by a round-trip through those implementations.\n * Dangerous! To avoid that risk, json11 stores all numbers as double internally, but also\n * provides integer helpers.\n *\n * Fortunately, double-precision IEEE754 ('double') can precisely store any integer in the\n * range +/-2^53, which includes every 'int' on most systems. (Timestamps often use int64\n * or long long to avoid the Y2038K problem; a double storing microseconds since some epoch\n * will be exact for +/- 275 years.)\n */\n\n/* Copyright (c) 2013 Dropbox, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#pragma once\n\n#include <string>\n#include <vector>\n#include <map>\n#include <memory>\n#include <initializer_list>\n\n#ifdef _MSC_VER\n    #if _MSC_VER <= 1800 // VS 2013\n        #ifndef noexcept\n            #define noexcept throw()\n        #endif\n\n        #ifndef snprintf\n            #define snprintf _snprintf_s\n        #endif\n    #endif\n#endif\n\nnamespace json11 {\n\nenum JsonParse {\n    STANDARD, COMMENTS\n};\n\nclass JsonValue;\n\nclass Json final {\npublic:\n    // Types\n    enum Type {\n        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT\n    };\n\n    // Array and object typedefs\n    typedef std::vector<Json> array;\n    typedef std::map<std::string, Json> object;\n\n    // Constructors for the various types of JSON value.\n    Json() noexcept;                // NUL\n    Json(std::nullptr_t) noexcept;  // NUL\n    Json(double value);             // NUMBER\n    Json(int value);                // NUMBER\n    Json(bool value);               // BOOL\n    Json(const std::string &value); // STRING\n    Json(std::string &&value);      // STRING\n    Json(const char * value);       // STRING\n    Json(const array &values);      // ARRAY\n    Json(array &&values);           // ARRAY\n    Json(const object &values);     // OBJECT\n    Json(object &&values);          // OBJECT\n\n    // Implicit constructor: anything with a to_json() function.\n    template <class T, class = decltype(&T::to_json)>\n    Json(const T & t) : Json(t.to_json()) {}\n\n    // Implicit constructor: map-like objects (std::map, std::unordered_map, etc)\n    template <class M, typename std::enable_if<\n        std::is_constructible<std::string, decltype(std::declval<M>().begin()->first)>::value\n        && std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,\n            int>::type = 0>\n    Json(const M & m) : Json(object(m.begin(), m.end())) {}\n\n    // Implicit constructor: vector-like objects (std::list, std::vector, std::set, etc)\n    template <class V, typename std::enable_if<\n        std::is_constructible<Json, decltype(*std::declval<V>().begin())>::value,\n            int>::type = 0>\n    Json(const V & v) : Json(array(v.begin(), v.end())) {}\n\n    // This prevents Json(some_pointer) from accidentally producing a bool. Use\n    // Json(bool(some_pointer)) if that behavior is desired.\n    Json(void *) = delete;\n\n    // Accessors\n    Type type() const;\n\n    bool is_null()   const { return type() == NUL; }\n    bool is_number() const { return type() == NUMBER; }\n    bool is_bool()   const { return type() == BOOL; }\n    bool is_string() const { return type() == STRING; }\n    bool is_array()  const { return type() == ARRAY; }\n    bool is_object() const { return type() == OBJECT; }\n\n    // Return the enclosed value if this is a number, 0 otherwise. Note that json11 does not\n    // distinguish between integer and non-integer numbers - number_value() and int_value()\n    // can both be applied to a NUMBER-typed object.\n    double number_value() const;\n    int int_value() const;\n\n    // Return the enclosed value if this is a boolean, false otherwise.\n    bool bool_value() const;\n    // Return the enclosed string if this is a string, \"\" otherwise.\n    const std::string &string_value() const;\n    // Return the enclosed std::vector if this is an array, or an empty vector otherwise.\n    const array &array_items() const;\n    // Return the enclosed std::map if this is an object, or an empty map otherwise.\n    const object &object_items() const;\n\n    // Return a reference to arr[i] if this is an array, Json() otherwise.\n    const Json & operator[](size_t i) const;\n    // Return a reference to obj[key] if this is an object, Json() otherwise.\n    const Json & operator[](const std::string &key) const;\n\n    // Serialize.\n    void dump(std::string &out) const;\n    std::string dump() const {\n        std::string out;\n        dump(out);\n        return out;\n    }\n\n    // Parse. If parse fails, return Json() and assign an error message to err.\n    static Json parse(const std::string & in,\n                      std::string & err,\n                      JsonParse strategy = JsonParse::STANDARD);\n    static Json parse(const char * in,\n                      std::string & err,\n                      JsonParse strategy = JsonParse::STANDARD) {\n        if (in) {\n            return parse(std::string(in), err, strategy);\n        } else {\n            err = \"null input\";\n            return nullptr;\n        }\n    }\n    // Parse multiple objects, concatenated or separated by whitespace\n    static std::vector<Json> parse_multi(\n        const std::string & in,\n        std::string::size_type & parser_stop_pos,\n        std::string & err,\n        JsonParse strategy = JsonParse::STANDARD);\n\n    static inline std::vector<Json> parse_multi(\n        const std::string & in,\n        std::string & err,\n        JsonParse strategy = JsonParse::STANDARD) {\n        std::string::size_type parser_stop_pos;\n        return parse_multi(in, parser_stop_pos, err, strategy);\n    }\n\n    bool operator== (const Json &rhs) const;\n    bool operator<  (const Json &rhs) const;\n    bool operator!= (const Json &rhs) const { return !(*this == rhs); }\n    bool operator<= (const Json &rhs) const { return !(rhs < *this); }\n    bool operator>  (const Json &rhs) const { return  (rhs < *this); }\n    bool operator>= (const Json &rhs) const { return !(*this < rhs); }\n\n    /* has_shape(types, err)\n     *\n     * Return true if this is a JSON object and, for each item in types, has a field of\n     * the given type. If not, return false and set err to a descriptive message.\n     */\n    typedef std::initializer_list<std::pair<std::string, Type>> shape;\n    bool has_shape(const shape & types, std::string & err) const;\n\nprivate:\n    std::shared_ptr<JsonValue> m_ptr;\n};\n\n// Internal class hierarchy - JsonValue objects are not exposed to users of this API.\nclass JsonValue {\nprotected:\n    friend class Json;\n    friend class JsonInt;\n    friend class JsonDouble;\n    virtual Json::Type type() const = 0;\n    virtual bool equals(const JsonValue * other) const = 0;\n    virtual bool less(const JsonValue * other) const = 0;\n    virtual void dump(std::string &out) const = 0;\n    virtual double number_value() const;\n    virtual int int_value() const;\n    virtual bool bool_value() const;\n    virtual const std::string &string_value() const;\n    virtual const Json::array &array_items() const;\n    virtual const Json &operator[](size_t i) const;\n    virtual const Json::object &object_items() const;\n    virtual const Json &operator[](const std::string &key) const;\n    virtual ~JsonValue() {}\n};\n\n} // namespace json11\n"
        },
        {
          "name": "json11.pc.in",
          "type": "blob",
          "size": 0.326171875,
          "content": "prefix=@CMAKE_INSTALL_PREFIX@\nlibdir=${prefix}/lib/@CMAKE_LIBRARY_ARCHITECTURE@\nincludedir=${prefix}/include/@CMAKE_LIBRARY_ARCHITECTURE@\n\nName: @PROJECT_NAME@\nDescription: json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.\nVersion: @PROJECT_VERSION@\nLibs: -L${libdir} -ljson11\nCflags: -I${includedir}\n"
        },
        {
          "name": "test.cpp",
          "type": "blob",
          "size": 10.400390625,
          "content": "/*\n * Define JSON11_TEST_CUSTOM_CONFIG to 1 if you want to build this tester into\n * your own unit-test framework rather than a stand-alone program.  By setting\n * The values of the variables included below, you can insert your own custom\n * code into this file as it builds, in order to make it into a test case for\n * your favorite framework.\n */\n#if !JSON11_TEST_CUSTOM_CONFIG\n#define JSON11_TEST_CPP_PREFIX_CODE\n#define JSON11_TEST_CPP_SUFFIX_CODE\n#define JSON11_TEST_STANDALONE_MAIN 1\n#define JSON11_TEST_CASE(name) static void name()\n#define JSON11_TEST_ASSERT(b) assert(b)\n#ifdef NDEBUG\n#undef NDEBUG//at now assert will work even in Release build\n#endif\n#endif // JSON11_TEST_CUSTOM_CONFIG\n\n/*\n * Enable or disable code which demonstrates the behavior change in Xcode 7 / Clang 3.7,\n * introduced by DR1467 and described here: https://github.com/dropbox/json11/issues/86\n * Defaults to off since it doesn't appear the standards committee is likely to act\n * on this, so it needs to be considered normal behavior.\n */\n#ifndef JSON11_ENABLE_DR1467_CANARY\n#define JSON11_ENABLE_DR1467_CANARY 0\n#endif\n\n/*\n * Beginning of standard source file, which makes use of the customizations above.\n */\n#include <cassert>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include \"json11.hpp\"\n#include <list>\n#include <set>\n#include <unordered_map>\n#include <algorithm>\n#include <type_traits>\n\n// Insert user-defined prefix code (includes, function declarations, etc)\n// to set up a custom test suite\nJSON11_TEST_CPP_PREFIX_CODE\n\nusing namespace json11;\nusing std::string;\n\n// Check that Json has the properties we want.\n#define CHECK_TRAIT(x) static_assert(std::x::value, #x)\nCHECK_TRAIT(is_nothrow_constructible<Json>);\nCHECK_TRAIT(is_nothrow_default_constructible<Json>);\nCHECK_TRAIT(is_copy_constructible<Json>);\nCHECK_TRAIT(is_nothrow_move_constructible<Json>);\nCHECK_TRAIT(is_copy_assignable<Json>);\nCHECK_TRAIT(is_nothrow_move_assignable<Json>);\nCHECK_TRAIT(is_nothrow_destructible<Json>);\n\nJSON11_TEST_CASE(json11_test) {\n    const string simple_test =\n        R\"({\"k1\":\"v1\", \"k2\":42, \"k3\":[\"a\",123,true,false,null]})\";\n\n    string err;\n    const auto json = Json::parse(simple_test, err);\n\n    std::cout << \"k1: \" << json[\"k1\"].string_value() << \"\\n\";\n    std::cout << \"k3: \" << json[\"k3\"].dump() << \"\\n\";\n\n    for (auto &k : json[\"k3\"].array_items()) {\n        std::cout << \"    - \" << k.dump() << \"\\n\";\n    }\n\n    string comment_test = R\"({\n      // comment /* with nested comment */\n      \"a\": 1,\n      // comment\n      // continued\n      \"b\": \"text\",\n      /* multi\n         line\n         comment\n        // line-comment-inside-multiline-comment\n      */\n      // and single-line comment\n      // and single-line comment /* multiline inside single line */\n      \"c\": [1, 2, 3]\n      // and single-line comment at end of object\n    })\";\n\n    string err_comment;\n    auto json_comment = Json::parse(\n      comment_test, err_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(!json_comment.is_null());\n    JSON11_TEST_ASSERT(err_comment.empty());\n\n    comment_test = \"{\\\"a\\\": 1}//trailing line comment\";\n    json_comment = Json::parse(\n      comment_test, err_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(!json_comment.is_null());\n    JSON11_TEST_ASSERT(err_comment.empty());\n\n    comment_test = \"{\\\"a\\\": 1}/*trailing multi-line comment*/\";\n    json_comment = Json::parse(\n      comment_test, err_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(!json_comment.is_null());\n    JSON11_TEST_ASSERT(err_comment.empty());\n\n    string failing_comment_test = \"{\\n/* unterminated comment\\n\\\"a\\\": 1,\\n}\";\n    string err_failing_comment;\n    auto json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    failing_comment_test = \"{\\n/* unterminated trailing comment }\";\n    json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    failing_comment_test = \"{\\n/ / bad comment }\";\n    json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    failing_comment_test = \"{// bad comment }\";\n    json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    failing_comment_test = \"{\\n\\\"a\\\": 1\\n}/\";\n    json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    failing_comment_test = \"{/* bad\\ncomment *}\";\n    json_failing_comment = Json::parse(\n      failing_comment_test, err_failing_comment, JsonParse::COMMENTS);\n    JSON11_TEST_ASSERT(json_failing_comment.is_null());\n    JSON11_TEST_ASSERT(!err_failing_comment.empty());\n\n    std::list<int> l1 { 1, 2, 3 };\n    std::vector<int> l2 { 1, 2, 3 };\n    std::set<int> l3 { 1, 2, 3 };\n    JSON11_TEST_ASSERT(Json(l1) == Json(l2));\n    JSON11_TEST_ASSERT(Json(l2) == Json(l3));\n\n    std::map<string, string> m1 { { \"k1\", \"v1\" }, { \"k2\", \"v2\" } };\n    std::unordered_map<string, string> m2 { { \"k1\", \"v1\" }, { \"k2\", \"v2\" } };\n    JSON11_TEST_ASSERT(Json(m1) == Json(m2));\n\n    // Json literals\n    const Json obj = Json::object({\n        { \"k1\", \"v1\" },\n        { \"k2\", 42.0 },\n        { \"k3\", Json::array({ \"a\", 123.0, true, false, nullptr }) },\n    });\n\n    std::cout << \"obj: \" << obj.dump() << \"\\n\";\n    JSON11_TEST_ASSERT(obj.dump() == \"{\\\"k1\\\": \\\"v1\\\", \\\"k2\\\": 42, \\\"k3\\\": [\\\"a\\\", 123, true, false, null]}\");\n\n    JSON11_TEST_ASSERT(Json(\"a\").number_value() == 0);\n    JSON11_TEST_ASSERT(Json(\"a\").string_value() == \"a\");\n    JSON11_TEST_ASSERT(Json().number_value() == 0);\n\n    JSON11_TEST_ASSERT(obj == json);\n    JSON11_TEST_ASSERT(Json(42) == Json(42.0));\n    JSON11_TEST_ASSERT(Json(42) != Json(42.1));\n\n    const string unicode_escape_test =\n        R\"([ \"blah\\ud83d\\udca9blah\\ud83dblah\\udca9blah\\u0000blah\\u1234\" ])\";\n\n    const char utf8[] = \"blah\" \"\\xf0\\x9f\\x92\\xa9\" \"blah\" \"\\xed\\xa0\\xbd\" \"blah\"\n                        \"\\xed\\xb2\\xa9\" \"blah\" \"\\0\" \"blah\" \"\\xe1\\x88\\xb4\";\n\n    Json uni = Json::parse(unicode_escape_test, err);\n    JSON11_TEST_ASSERT(uni[0].string_value().size() == (sizeof utf8) - 1);\n    JSON11_TEST_ASSERT(std::memcmp(uni[0].string_value().data(), utf8, sizeof utf8) == 0);\n\n    // Demonstrates the behavior change in Xcode 7 / Clang 3.7, introduced by DR1467\n    // and described here: https://llvm.org/bugs/show_bug.cgi?id=23812\n    if (JSON11_ENABLE_DR1467_CANARY) {\n        Json nested_array = Json::array { Json::array { 1, 2, 3 } };\n        JSON11_TEST_ASSERT(nested_array.is_array());\n        JSON11_TEST_ASSERT(nested_array.array_items().size() == 1);\n        JSON11_TEST_ASSERT(nested_array.array_items()[0].is_array());\n        JSON11_TEST_ASSERT(nested_array.array_items()[0].array_items().size() == 3);\n    }\n\n    {\n        const std::string good_json = R\"( {\"k1\" : \"v1\"})\";\n        const std::string bad_json1 = good_json + \" {\";\n        const std::string bad_json2 = good_json + R\"({\"k2\":\"v2\", \"k3\":[)\";\n        struct TestMultiParse {\n            std::string input;\n            std::string::size_type expect_parser_stop_pos;\n            size_t expect_not_empty_elms_count;\n            Json expect_parse_res;\n        } tests[] = {\n            {\" {\", 0, 0, {}},\n            {good_json, good_json.size(), 1, Json(std::map<string, string>{ { \"k1\", \"v1\" } })},\n            {bad_json1, good_json.size() + 1, 1, Json(std::map<string, string>{ { \"k1\", \"v1\" } })},\n            {bad_json2, good_json.size(), 1, Json(std::map<string, string>{ { \"k1\", \"v1\" } })},\n            {\"{}\", 2, 1, Json::object{}},\n        };\n        for (const auto &tst : tests) {\n            std::string::size_type parser_stop_pos;\n            std::string err;\n            auto res = Json::parse_multi(tst.input, parser_stop_pos, err);\n            JSON11_TEST_ASSERT(parser_stop_pos == tst.expect_parser_stop_pos);\n            JSON11_TEST_ASSERT(\n                (size_t)std::count_if(res.begin(), res.end(),\n                                      [](const Json& j) { return !j.is_null(); })\n                == tst.expect_not_empty_elms_count);\n            if (!res.empty()) {\n                JSON11_TEST_ASSERT(tst.expect_parse_res == res[0]);\n            }\n        }\n    }\n\n    Json my_json = Json::object {\n        { \"key1\", \"value1\" },\n        { \"key2\", false },\n        { \"key3\", Json::array { 1, 2, 3 } },\n    };\n    std::string json_obj_str = my_json.dump();\n    std::cout << \"json_obj_str: \" << json_obj_str << \"\\n\";\n    JSON11_TEST_ASSERT(json_obj_str == \"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": false, \\\"key3\\\": [1, 2, 3]}\");\n\n    class Point {\n    public:\n        int x;\n        int y;\n        Point (int x, int y) : x(x), y(y) {}\n        Json to_json() const { return Json::array { x, y }; }\n    };\n\n    std::vector<Point> points = { { 1, 2 }, { 10, 20 }, { 100, 200 } };\n    std::string points_json = Json(points).dump();\n    std::cout << \"points_json: \" << points_json << \"\\n\";\n    JSON11_TEST_ASSERT(points_json == \"[[1, 2], [10, 20], [100, 200]]\");\n\n    JSON11_TEST_ASSERT(((Json)(Json::object { { \"foo\", nullptr } })).has_shape({ { \"foo\", Json::NUL } }, err) == true);\n    JSON11_TEST_ASSERT(((Json)(Json::object { { \"foo\", 1234567 } })).has_shape({ { \"foo\", Json::NUL } }, err) == false);\n    JSON11_TEST_ASSERT(((Json)(Json::object { { \"bar\", 1234567 } })).has_shape({ { \"foo\", Json::NUL } }, err) == false);\n\n}\n\n#if JSON11_TEST_STANDALONE_MAIN\n\nstatic void parse_from_stdin() {\n    string buf;\n    string line;\n    while (std::getline(std::cin, line)) {\n        buf += line + \"\\n\";\n    }\n\n    string err;\n    auto json = Json::parse(buf, err);\n    if (!err.empty()) {\n        printf(\"Failed: %s\\n\", err.c_str());\n    } else {\n        printf(\"Result: %s\\n\", json.dump().c_str());\n    }\n}\n\nint main(int argc, char **argv) {\n    if (argc == 2 && argv[1] == string(\"--stdin\")) {\n        parse_from_stdin();\n        return 0;\n    }\n\n    json11_test();\n}\n\n#endif // JSON11_TEST_STANDALONE_MAIN\n\n// Insert user-defined suffix code (function definitions, etc)\n// to set up a custom test suite\nJSON11_TEST_CPP_SUFFIX_CODE\n"
        }
      ]
    }
  ]
}