{
  "metadata": {
    "timestamp": 1736565587504,
    "page": 466,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "openjdk/jfx",
      "stars": 2788,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0078125,
          "content": "* -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.26953125,
          "content": "# Ignore the following directories and files\n.gradle/\n.hg/\nDebug/\nRelease/\nbin/\nbuild/\ndist/\ngradle.properties\ntestbin/\n**/Ensemble8/lib/\n**/Ensemble8/src/generated/resources/ensemble/search/index/write.lock\n**/nbproject/private/\nhs_err_pid*\n\n# Ignore webrevs\n/webrev/\n/webrev.zip\n\n# IntelliJ Idea Begin\n# https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore\n# Ignore IntelliJ files\n.idea/inspectionProfiles/**\n.idea/copyright/profiles_settings.xml\n\n# Code styles should be shared\n#.idea/codeStyles/**\n#.idea/checkstyle-idea.xml\n\n# User-specific stuff\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/usage.statistics.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n# Generated files\n.idea/**/contentModel.xml\n\n# Gradle\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# Auto-import\n.idea/artifacts\n.idea/compiler.xml\n.idea/jarRepositories.xml\n.idea/modules.xml\n.idea/*.iml\n.idea/modules\n*.iml\n*.ipr\n\n# File-based project format\n*.iws\n\n# SonarLint plugin\n.idea/sonarlint/\n#IntelliJ Idea End\n\n# Ignore the following file suffixes\n*.vcxproj.user\n*.orig\n*.bak\n*.rej\n*.swp\n*~\n\n# Ignore macOS system files\n.DS_Store\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n\n# Ignore Windows system files\nDesktop.ini\nThumbs.db\n"
        },
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": ".jcheck",
          "type": "tree",
          "content": null
        },
        {
          "name": ".project",
          "type": "blob",
          "size": 0.1484375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>jfx</name>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t</buildSpec>\n</projectDescription>\n"
        },
        {
          "name": ".settings",
          "type": "tree",
          "content": null
        },
        {
          "name": "ADDITIONAL_LICENSE_INFO",
          "type": "blob",
          "size": 2.064453125,
          "content": "                      ADDITIONAL INFORMATION ABOUT LICENSING\n\nCertain files distributed by Oracle America, Inc. and/or its affiliates are \nsubject to the following clarification and special exception to the GPLv2, \nbased on the GNU Project exception for its Classpath libraries, known as the \nGNU Classpath Exception.\n\nNote that Oracle includes multiple, independent programs in this software \npackage.  Some of those programs are provided under licenses deemed \nincompatible with the GPLv2 by the Free Software Foundation and others. \nFor example, the package includes programs licensed under the Apache \nLicense, Version 2.0 and may include FreeType. Such programs are licensed \nto you under their original licenses. \n\nOracle facilitates your further distribution of this package by adding the \nClasspath Exception to the necessary parts of its GPLv2 code, which permits \nyou to use that code in combination with other independent modules not \nlicensed under the GPLv2. However, note that this would not permit you to \ncommingle code under an incompatible license with Oracle's GPLv2 licensed \ncode by, for example, cutting and pasting such code into a file also \ncontaining Oracle's GPLv2 licensed code and then distributing the result. \n\nAdditionally, if you were to remove the Classpath Exception from any of the \nfiles to which it applies and distribute the result, you would likely be \nrequired to license some or all of the other code in that distribution under \nthe GPLv2 as well, and since the GPLv2 is incompatible with the license terms \nof some items included in the distribution by Oracle, removing the Classpath \nException could therefore effectively compromise your ability to further \ndistribute the package. \n\nFailing to distribute notices associated with some files may also create \nunexpected legal consequences.\n \nProceed with caution and we recommend that you obtain the advice of a lawyer \nskilled in open source matters before removing the Classpath Exception or \nmaking modifications to this package which may subsequently be redistributed \nand/or involve the use of third party software.\n"
        },
        {
          "name": "ASSEMBLY_EXCEPTION",
          "type": "blob",
          "size": 1.486328125,
          "content": "\nOPENJDK ASSEMBLY EXCEPTION\n\nThe OpenJDK source code made available by Oracle America, Inc. (Oracle) at\nopenjdk.java.net (\"OpenJDK Code\") is distributed under the terms of the GNU\nGeneral Public License <http://www.gnu.org/copyleft/gpl.html> version 2\nonly (\"GPL2\"), with the following clarification and special exception.\n\n    Linking this OpenJDK Code statically or dynamically with other code\n    is making a combined work based on this library.  Thus, the terms\n    and conditions of GPL2 cover the whole combination.\n\n    As a special exception, Oracle gives you permission to link this\n    OpenJDK Code with certain code licensed by Oracle as indicated at\n    http://openjdk.java.net/legal/exception-modules-2007-05-08.html\n    (\"Designated Exception Modules\") to produce an executable,\n    regardless of the license terms of the Designated Exception Modules,\n    and to copy and distribute the resulting executable under GPL2,\n    provided that the Designated Exception Modules continue to be\n    governed by the licenses under which they were offered by Oracle.\n\nAs such, it allows licensees and sublicensees of Oracle's GPL2 OpenJDK Code\nto build an executable that includes those portions of necessary code that\nOracle could not provide under GPL2 (or that Oracle has provided under GPL2\nwith the Classpath exception).  If you modify or add to the OpenJDK code,\nthat new GPL2 code may still be combined with Designated Exception Modules\nif the new code is made subject to this exception by its copyright holder.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 16.6279296875,
          "content": "Contributing to OpenJFX\n=======================\n\nOpenJFX is an open source project and we love to receive contributions from our community &mdash; you! There are many ways to contribute, from improving the documentation, submitting bug reports and feature requests, or writing code which can be incorporated into OpenJFX itself.\n\nBug reports\n-----------\n\nIf you think you have found a bug in OpenJFX, first make sure that you are testing against the latest version - your issue may already have been fixed. If not, search our [issues list](https://bugs.openjdk.org/issues/?filter=39543) in the Java Bug System (JBS) in case a similar issue has already been opened. More information on where and how to report a bug can be found at [bugreport.java.com](https://bugreport.java.com/).\n\nIt is very helpful if you can prepare a reproduction of the bug. In other words, provide a small test case which we can run to confirm your bug. It makes it easier to find the problem and to fix it.\n\nProvide as much information as you can. The easier it is for us to recreate your problem, the faster it is likely to be fixed.\n\nFeature requests\n----------------\n\nIf you find yourself wishing for a feature that doesn't exist in OpenJFX, you are probably not alone. There are bound to be others out there with similar needs. Many of the features that OpenJFX has today have been added because our users saw the need. Please be aware that\nall new feature requests, including any API changes, need prior discussion on the [openjfx-dev](https://mail.openjdk.org/mailman/listinfo/openjfx-dev) mailing list, even if there is already an open\n[JBS issue](https://bugs.openjdk.org). See the [New features / API additions](#new-features--api-additions) section below for more information.\n\nContributing code and documentation changes\n-------------------------------------------\n\nIf you have a bug fix or new feature that you would like to contribute to OpenJFX, please talk about what you would like to do on the [openjfx-dev](https://mail.openjdk.org/mailman/listinfo/openjfx-dev) mailing list. It may be that somebody is already working on it, or that there are particular issues that you should know about before implementing the change.\n\nWe enjoy working with contributors to get their code accepted. There are many approaches to fixing a problem and it is important to find the best approach before writing too much code.\n\nNote that it is unlikely the project will merge refactors for the sake of refactoring. These\ntypes of pull requests have a high cost to maintainers in reviewing and testing with little\nto no tangible benefit. This especially includes changes generated by tools. For example,\nconverting all generic interface instances to use the diamond operator.\n\n### Fork and clone the repository\n\nOnce you have created a bug report or confirmed its existence on JBS, you will need to fork the [repository](https://github.com/openjdk/jfx) and clone it to your local machine. See\nthe [GitHub help page](https://help.github.com/articles/fork-a-repo) for help.\n\n### Before submitting a pull request\n\nIf you are a first time contributor to OpenJFX, welcome! Please do the following before you submit your first pull request:\n\n* Sign the Contributor Agreement\n\n    In order for us to evaluate your contribution, you need to sign the [Oracle Contributor Agreement](https://oca.opensource.oracle.com/) (OCA). We are not asking you to give up your copyright, but to give us the right to distribute your code without restriction. By doing this you assert that the code you contribute is *yours* to contribute, and not third-party code that you do not own. We ask this of all contributors in order to assure our users of the origin and continuing existence of the code. You only need to sign the OCA once.\n\n* Read the code review policies\n\n    Please read the entire section below on how to submit a pull request, as well as the [Code Review Policies](README-code-reviews.md) page. If this is a feature request, please note the additional requirements and expectations in the [New features / API additions](#new-features--api-additions) section at the end of this guide.\n\n* File a bug in JBS for every pull request\n\n    A unique [JBS](https://bugs.openjdk.org) bug ID is needed for every\n    pull request. If there isn't already a bug filed in JBS, then please\n    file one at [bugreport.java.com](https://bugreport.java.com/).\n    A developer with an active OpenJDK ID can file a bug directly in JBS.\n\nTIP: A GitHub pull request (PR) should not be the first time we hear about your proposed change to OpenJFX. Unless clearly identified as a `Draft` or work-in-progress (WIP), as described in the following section, we will usually close a pull request that isn't associated with an existing bug report. Reading the policies below will help you in getting your change approved.\n\n### Submitting your changes via a pull request\n\nOnce your changes and tests are ready to submit for review:\n\n1. Test your changes\n\n    Run the test suite to make sure that nothing is broken. For most code changes, you need to provide new tests covering those changes. At least one of the new tests should fail before your proposed fix and pass after your proposed fix.\n\n2. Rebase your changes\n\n    Update your local repository with the most recent code from the main [repository]((https://github.com/openjdk/jfx)), and rebase your branch on top of the latest `master` branch. We prefer your initial changes to be squashed into a single commit. See the [GitHub help page](https://help.github.com/articles/about-git-rebase/) for help. Later, if we ask you to make changes, add them as separate commits. This makes them easier to review.\n\n3. Submit a pull request\n\n    Push your local changes to your forked copy of the repository and\n    [submit a pull request](https://help.github.com/articles/using-pull-requests).\n    The title of the pull request must start with the 7-digit JBS bug id,\n    followed by a colon (`:`), then a space,\n    and finally the bug title as taken from JBS. This title must _exactly_ match\n    the JBS bug, else the Skara bot will warn about the mismatch and block integration.\n    You should include\n    additional details about your change in the Description of the pull\n    request. For example, the following is a valid pull request title:\n\n    ```\n    8231326: Update README and CONTRIBUTING docs for Skara\n    ```\n\n    The Skara bot will then run `jcheck` on the server to verify the format\n    of the PR title and check for whitespace errors. Once that passes,\n    it will automatically send a Request For Review (RFR) email to the\n    [openjfx-dev](https://mail.openjdk.org/mailman/listinfo/openjfx-dev) mailing list.\n    The Skara bot will also cross-link the JBS Issue and the pull request.\n    See the\n    [Skara project page](https://github.com/openjdk/skara#openjdk-project-skara)\n    for information on `jcheck` and other Skara tools.\n\n    TIP: Create a `Draft` pull request or prefix the pull request title with `WIP:` if you aren't yet\n    ready for it to be reviewed. The Skara bot will not send an RFR\n    email unless the PR is out of the `Draft` state and the title starts with a 7-digit bug ID.\n\n    Please adhere to the general guideline that you should never force push\n    to a publicly shared branch. Once you have opened your pull request, you\n    should consider your branch publicly shared. Instead of force pushing\n    you can just add incremental commits; this is generally easier on your\n    reviewers. If you need to pick up changes from `master`, you can merge\n    `master` into your branch. A reviewer might ask you to rebase a\n    long-running pull request in which case force pushing is okay for that\n    request. Note that squashing at the end of the review process should\n    also not be done. The Skara bot will squash your commits into a\n    single commit, and rebase it onto the target branch when the pull\n    request is integrated.\n    See the [GitHub Help Documentation](https://docs.github.com/en/github)\n    for additional help on using Git and GitHub.\n\n4. Code review\n\n    All pull requests _must_ be reviewed according to the\n    [Code Review Policies](README-code-reviews.md) page.\n    It is the responsibility of the Reviewer(s) and the Committer who\n    will integrate or sponsor the change to ensure that the code review policies\n    are followed, and that all concerns have been addressed.\n\n    Discussion and review of the pull request can happen either by adding\n    a comment to the PR itself, or by replying to the mailing list \"RFR\"\n    thread. The Skara bot will cross-forward between them.\n    To approve a pull request, a reviewer must do that in the PR itself.\n    See the following\n    [GitHub help page](https://help.github.com/en/articles/reviewing-proposed-changes-in-a-pull-request)\n    for help on reviewing a pull request.\n\n    If any changes\n    are needed, you would push additional commits to the branch\n    from which you made the pull request.\n\n    The code review continues until there are no unaddressed concerns, and\n    at least the minimum number of reviewers have approved the PR -- which\n    is one for low-impact bug fixes and two for enhancements or high-impact\n    bug fixes.\n\n    NOTE: A Reviewer in the project can set the minimum number of reviewers\n    for a PR using the Skara `/reviewers` command. For example,\n    `/reviewers 2` is used for high-impact fixes and enhancements to indicate\n    that two reviewers are needed, at least one of whom needs to have the\n    Reviewer role in the project.\n\n    NOTE: A reviewer can indicate that a PR needs a\n    [CSR](https://wiki.openjdk.org/display/csr/Main) by\n    entering the `/csr` command. The Skara bot will then require an approved\n    CSR before the PR can be integrated.\n\n5. Integrate the pull request\n\n    Once the review has completed as described above, you can integrate\n    the PR.\n\n    A. Verify the following: all substantive feedback has been addressed; all Reviewers\n    who have requested the chance to review have done so; the PR has been \"rfr\"\n    for at least 1 business day (excluding weekends and holidays);\n    the commit message is correct.\n    See the [Code Review Gudelines](README-code-reviews.md#before-you-integrate-or-sponsor-a-pr)\n    for more details.\n\n    B. Issue the `/integrate` command. If you have the \"Committer\" role\n    (or higher) in the Project, then the Skara bot will merge the change\n    with no further action on your part. If you are not a Committer,\n    then you must get a Committer to sponsor your change. This is often\n    one of the reviewers who reviewed your PR, but it need not be. The\n    sponsor will issue the `/sponsor` command after you issue `/integrate`\n    once they are satisfied that the review criteria have been met.\n    The Skara bot will automatically resolve the JBS issue as \"Fixed\"\n    so there is no need to manually resolve it.\n\n\nNew features / API additions\n----------------------------\n\nAdding a new feature to OpenJFX requires us to consider what it means to support that API forever; we take compatibility seriously.\nThe main idea is to think in terms of \"stewardship\" when evolving the JavaFX API. This will require significant effort on your part.\nIt begins before you submit a pull request for review, and continues after the new feature is integrated.\nWith that in mind, here are the needed steps to get a new feature into JavaFX.\n\n1. Discuss the proposed feature on the [openjfx-dev](https://mail.openjdk.org/mailman/listinfo/openjfx-dev) mailing list.\nYou should start with _why_ you think\nadding the API to the core of JavaFX is a good and useful addition for multiple applications (not just your own)\nand for the evolution of the JavaFX UI Toolkit. Part of this is to see whether the Project Leads and Reviewers\nare generally supportive of the idea, as well as to see whether other developers have any ideas as to whether\nand how it would be useful in their applications. We want to make sure that the new feature fits in with the\nexisting API and will move the API forward in a direction we want to go. We need to ensure that the value\nproposition of the new feature justifies the investment, which goes well beyond the initial cost of developing it.\nPresuming that the feature meets the cost / benefit assessment (including opportunity cost), then discussion can\nproceed to the API.\n\n2. Discuss the API needed to provide the feature. While this can't always be completely separated from its\nimplementation, it is the public API itself that is important to nail down and get right. While we don't currently\nuse the formal JEP process as is done for larger JDK features, the [JEP template](https://openjdk.org/jeps/2)\nprovides some ideas to consider when proposing an API, such as a summary of the changes, goals, motivation, testing,\ndependencies, etc. A Draft (or WIP) pull request can be useful for illustrative purposes as long as the focus is on the public API.\nIf there are trade-offs to be made in the implementation, or different implementation approaches that you might take,\nthis is a good time to discuss it. Once this step is far enough along that there is general agreement as to the API,\nthen it's time to focus on the implementation.\n\n3. Submit a review of your proposed implementation. As noted in the\n[New features / API additions](README-code-reviews.md#c-new-features--api-additions)\nsection of the Code Review Policies page, we also need a [CSR](https://wiki.openjdk.org/display/csr/Main), which documents the API change and its approval.\nThe CSR can be reviewed in parallel. Changes in the API that arise during the review need to be reflected in the CSR, meaning\nthat the final review / approval of the CSR usually happens late in the review cycle.\nYou can avoid extra work by waiting to submit the CSR until the API is agreed upon and the code review for the documentation is reasonably far along.\n\nTIP: a pull request is _not_ the starting point, since that skips the first two important steps and jumps right into\n\"given this new feature, and an API definition that specifies it, please review my proposed implementation\".\n\nCoding style and testing guidelines\n------------------------------------------\n\nThe following formatting rules are enforced for source code files by\n`git jcheck`, which is run by the Skara bot:\n\n* Use Unix-style (LF) line endings, not DOS-style (CRLF)\n* Do not use TAB characters (exception: Makefiles can have TABS)\n* No trailing spaces\n* No files with execute permission\n\nPlease also follow these formatting guidelines:\n\n* Java indent is 4 spaces\n* Line width is no more than 120 characters\n* The rest is left to Java coding standards\n* Avoid making changes that are unrelated to the bug you are fixing. This includes fixing minor errors such as warnings, spacing / indentation, spelling errors, etc, in code that you aren't otherwise modifying as part of your fix.\n* Disable &ldquo;auto-format on save&rdquo; to prevent your IDE from making unnecessary formatting changes. This makes reviews much harder as it generates unnecessary diffs. If your IDE supports formatting only modified chunks, that is fine to do.\n* Wildcard imports &ndash; for example, `import java.util.*;` &ndash; are forbidden and may cause the build to fail. Please attempt to configure your IDE so it doesn't generate wildcard imports. An exception to this rule is that wildcard static imports in test classes are allowed, for example, `import static org.junit.Assert.*;`.\n* Don't worry too much about import order. Try not to change it but don't worry about fighting your IDE to stop it from doing so.\n\nNew code should be formatted consistently in accordance with the above guidelines. However, please do not reformat existing code as part of a bug fix. This makes more changes for code reviewers to track and review, and can lead to merge conflicts.\n\n### Building and testing\n\nJDK 22 (at a minimum) is required to build OpenJFX. You must have the JDK\ninstalled on your system\nwith the environment variable `JAVA_HOME` referencing the path to Java home for\nyour JDK installation. By default, tests use the same runtime as `JAVA_HOME`.\n\nIt is possible to develop in any major Java IDE (Eclipse, IntelliJ, NetBeans). IDEs can automatically configure projects based on Gradle setup.\n\nOpenJFX uses Gradle for its build. Before submitting your changes, run the test suite to make sure that nothing is broken, with:\n\n```sh\nbash ./gradlew all test\n```\n\nIf you are changing anything that might possibly affect rendering, you should run a full test with robot enabled:\n\n```sh\nbash ./gradlew -PFULL_TEST=true -PUSE_ROBOT=true all test\n```\n\nIf you don't build WebKit (using the `-PCOMPILE_WEBKIT=true` option), you are likely to get test failures when running the web tests. See the [Web Testing](WEBKIT-MEDIA-STUBS.md) page for information on how to address this.\n\nEven more documentation on OpenJFX projects and its build system can be found on the\n[OpenJFX Wiki](https://wiki.openjdk.org/display/OpenJFX/).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 18.822265625,
          "content": "The GNU General Public License (GPL)\n\nVersion 2, June 1991\n\nCopyright (C) 1989, 1991 Free Software Foundation, Inc.\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this license\ndocument, but changing it is not allowed.\n\nPreamble\n\nThe licenses for most software are designed to take away your freedom to share\nand change it.  By contrast, the GNU General Public License is intended to\nguarantee your freedom to share and change free software--to make sure the\nsoftware is free for all its users.  This General Public License applies to\nmost of the Free Software Foundation's software and to any other program whose\nauthors commit to using it.  (Some other Free Software Foundation software is\ncovered by the GNU Library General Public License instead.) You can apply it to\nyour programs, too.\n\nWhen we speak of free software, we are referring to freedom, not price.  Our\nGeneral Public Licenses are designed to make sure that you have the freedom to\ndistribute copies of free software (and charge for this service if you wish),\nthat you receive source code or can get it if you want it, that you can change\nthe software or use pieces of it in new free programs; and that you know you\ncan do these things.\n\nTo protect your rights, we need to make restrictions that forbid anyone to deny\nyou these rights or to ask you to surrender the rights.  These restrictions\ntranslate to certain responsibilities for you if you distribute copies of the\nsoftware, or if you modify it.\n\nFor example, if you distribute copies of such a program, whether gratis or for\na fee, you must give the recipients all the rights that you have.  You must\nmake sure that they, too, receive or can get the source code.  And you must\nshow them these terms so they know their rights.\n\nWe protect your rights with two steps: (1) copyright the software, and (2)\noffer you this license which gives you legal permission to copy, distribute\nand/or modify the software.\n\nAlso, for each author's protection and ours, we want to make certain that\neveryone understands that there is no warranty for this free software.  If the\nsoftware is modified by someone else and passed on, we want its recipients to\nknow that what they have is not the original, so that any problems introduced\nby others will not reflect on the original authors' reputations.\n\nFinally, any free program is threatened constantly by software patents.  We\nwish to avoid the danger that redistributors of a free program will\nindividually obtain patent licenses, in effect making the program proprietary.\nTo prevent this, we have made it clear that any patent must be licensed for\neveryone's free use or not licensed at all.\n\nThe precise terms and conditions for copying, distribution and modification\nfollow.\n\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n0. This License applies to any program or other work which contains a notice\nplaced by the copyright holder saying it may be distributed under the terms of\nthis General Public License.  The \"Program\", below, refers to any such program\nor work, and a \"work based on the Program\" means either the Program or any\nderivative work under copyright law: that is to say, a work containing the\nProgram or a portion of it, either verbatim or with modifications and/or\ntranslated into another language.  (Hereinafter, translation is included\nwithout limitation in the term \"modification\".) Each licensee is addressed as\n\"you\".\n\nActivities other than copying, distribution and modification are not covered by\nthis License; they are outside its scope.  The act of running the Program is\nnot restricted, and the output from the Program is covered only if its contents\nconstitute a work based on the Program (independent of having been made by\nrunning the Program).  Whether that is true depends on what the Program does.\n\n1. You may copy and distribute verbatim copies of the Program's source code as\nyou receive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice and\ndisclaimer of warranty; keep intact all the notices that refer to this License\nand to the absence of any warranty; and give any other recipients of the\nProgram a copy of this License along with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and you may\nat your option offer warranty protection in exchange for a fee.\n\n2. You may modify your copy or copies of the Program or any portion of it, thus\nforming a work based on the Program, and copy and distribute such modifications\nor work under the terms of Section 1 above, provided that you also meet all of\nthese conditions:\n\n    a) You must cause the modified files to carry prominent notices stating\n    that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in whole or\n    in part contains or is derived from the Program or any part thereof, to be\n    licensed as a whole at no charge to all third parties under the terms of\n    this License.\n\n    c) If the modified program normally reads commands interactively when run,\n    you must cause it, when started running for such interactive use in the\n    most ordinary way, to print or display an announcement including an\n    appropriate copyright notice and a notice that there is no warranty (or\n    else, saying that you provide a warranty) and that users may redistribute\n    the program under these conditions, and telling the user how to view a copy\n    of this License.  (Exception: if the Program itself is interactive but does\n    not normally print such an announcement, your work based on the Program is\n    not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If identifiable\nsections of that work are not derived from the Program, and can be reasonably\nconsidered independent and separate works in themselves, then this License, and\nits terms, do not apply to those sections when you distribute them as separate\nworks.  But when you distribute the same sections as part of a whole which is a\nwork based on the Program, the distribution of the whole must be on the terms\nof this License, whose permissions for other licensees extend to the entire\nwhole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest your\nrights to work written entirely by you; rather, the intent is to exercise the\nright to control the distribution of derivative or collective works based on\nthe Program.\n\nIn addition, mere aggregation of another work not based on the Program with the\nProgram (or with a work based on the Program) on a volume of a storage or\ndistribution medium does not bring the other work under the scope of this\nLicense.\n\n3. You may copy and distribute the Program (or a work based on it, under\nSection 2) in object code or executable form under the terms of Sections 1 and\n2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable source\n    code, which must be distributed under the terms of Sections 1 and 2 above\n    on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three years, to\n    give any third party, for a charge no more than your cost of physically\n    performing source distribution, a complete machine-readable copy of the\n    corresponding source code, to be distributed under the terms of Sections 1\n    and 2 above on a medium customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer to\n    distribute corresponding source code.  (This alternative is allowed only\n    for noncommercial distribution and only if you received the program in\n    object code or executable form with such an offer, in accord with\n    Subsection b above.)\n\nThe source code for a work means the preferred form of the work for making\nmodifications to it.  For an executable work, complete source code means all\nthe source code for all modules it contains, plus any associated interface\ndefinition files, plus the scripts used to control compilation and installation\nof the executable.  However, as a special exception, the source code\ndistributed need not include anything that is normally distributed (in either\nsource or binary form) with the major components (compiler, kernel, and so on)\nof the operating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the source\ncode from the same place counts as distribution of the source code, even though\nthird parties are not compelled to copy the source along with the object code.\n\n4. You may not copy, modify, sublicense, or distribute the Program except as\nexpressly provided under this License.  Any attempt otherwise to copy, modify,\nsublicense or distribute the Program is void, and will automatically terminate\nyour rights under this License.  However, parties who have received copies, or\nrights, from you under this License will not have their licenses terminated so\nlong as such parties remain in full compliance.\n\n5. You are not required to accept this License, since you have not signed it.\nHowever, nothing else grants you permission to modify or distribute the Program\nor its derivative works.  These actions are prohibited by law if you do not\naccept this License.  Therefore, by modifying or distributing the Program (or\nany work based on the Program), you indicate your acceptance of this License to\ndo so, and all its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n6. Each time you redistribute the Program (or any work based on the Program),\nthe recipient automatically receives a license from the original licensor to\ncopy, distribute or modify the Program subject to these terms and conditions.\nYou may not impose any further restrictions on the recipients' exercise of the\nrights granted herein.  You are not responsible for enforcing compliance by\nthird parties to this License.\n\n7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues), conditions\nare imposed on you (whether by court order, agreement or otherwise) that\ncontradict the conditions of this License, they do not excuse you from the\nconditions of this License.  If you cannot distribute so as to satisfy\nsimultaneously your obligations under this License and any other pertinent\nobligations, then as a consequence you may not distribute the Program at all.\nFor example, if a patent license would not permit royalty-free redistribution\nof the Program by all those who receive copies directly or indirectly through\nyou, then the only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply and\nthe section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any patents or\nother property right claims or to contest validity of any such claims; this\nsection has the sole purpose of protecting the integrity of the free software\ndistribution system, which is implemented by public license practices.  Many\npeople have made generous contributions to the wide range of software\ndistributed through that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing to\ndistribute software through any other system and a licensee cannot impose that\nchoice.\n\nThis section is intended to make thoroughly clear what is believed to be a\nconsequence of the rest of this License.\n\n8. If the distribution and/or use of the Program is restricted in certain\ncountries either by patents or by copyrighted interfaces, the original\ncopyright holder who places the Program under this License may add an explicit\ngeographical distribution limitation excluding those countries, so that\ndistribution is permitted only in or among countries not thus excluded.  In\nsuch case, this License incorporates the limitation as if written in the body\nof this License.\n\n9. The Free Software Foundation may publish revised and/or new versions of the\nGeneral Public License from time to time.  Such new versions will be similar in\nspirit to the present version, but may differ in detail to address new problems\nor concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any later\nversion\", you have the option of following the terms and conditions either of\nthat version or of any later version published by the Free Software Foundation.\nIf the Program does not specify a version number of this License, you may\nchoose any version ever published by the Free Software Foundation.\n\n10. If you wish to incorporate parts of the Program into other free programs\nwhose distribution conditions are different, write to the author to ask for\npermission.  For software which is copyrighted by the Free Software Foundation,\nwrite to the Free Software Foundation; we sometimes make exceptions for this.\nOur decision will be guided by the two goals of preserving the free status of\nall derivatives of our free software and of promoting the sharing and reuse of\nsoftware generally.\n\nNO WARRANTY\n\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR\nTHE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE\nSTATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE\nPROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND\nPERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE,\nYOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL\nANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE\nPROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR\nINABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\nBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER\nOR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\nEND OF TERMS AND CONDITIONS\n\nHow to Apply These Terms to Your New Programs\n\nIf you develop a new program, and you want it to be of the greatest possible\nuse to the public, the best way to achieve this is to make it free software\nwhich everyone can redistribute and change under these terms.\n\nTo do so, attach the following notices to the program.  It is safest to attach\nthem to the start of each source file to most effectively convey the exclusion\nof warranty; and each file should have at least the \"copyright\" line and a\npointer to where the full notice is found.\n\n    One line to give the program's name and a brief idea of what it does.\n\n    Copyright (C) <year> <name of author>\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by the Free\n    Software Foundation; either version 2 of the License, or (at your option)\n    any later version.\n\n    This program is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this when it\nstarts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author Gnomovision comes\n    with ABSOLUTELY NO WARRANTY; for details type 'show w'.  This is free\n    software, and you are welcome to redistribute it under certain conditions;\n    type 'show c' for details.\n\nThe hypothetical commands 'show w' and 'show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may be\ncalled something other than 'show w' and 'show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.  Here\nis a sample; alter the names:\n\n    Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n    'Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n    signature of Ty Coon, 1 April 1989\n\n    Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Library General Public\nLicense instead of this License.\n\n\n\"CLASSPATH\" EXCEPTION TO THE GPL\n\nCertain source files distributed by Oracle America and/or its affiliates are\nsubject to the following clarification and special exception to the GPL, but\nonly where Oracle has expressly included in the particular source file's header\nthe words \"Oracle designates this particular file as subject to the \"Classpath\"\nexception as provided by Oracle in the LICENSE file that accompanied this code.\"\n\n    Linking this library statically or dynamically with other modules is making\n    a combined work based on this library.  Thus, the terms and conditions of\n    the GNU General Public License cover the whole combination.\n\n    As a special exception, the copyright holders of this library give you\n    permission to link this library with independent modules to produce an\n    executable, regardless of the license terms of these independent modules,\n    and to copy and distribute the resulting executable under terms of your\n    choice, provided that you also meet, for each linked independent module,\n    the terms and conditions of the license of that module.  An independent\n    module is a module which is not derived from or based on this library.  If\n    you modify this library, you may extend this exception to your version of\n    the library, but you are not obligated to do so.  If you do not wish to do\n    so, delete this exception statement from your version.\n"
        },
        {
          "name": "README-code-reviews.md",
          "type": "blob",
          "size": 10.927734375,
          "content": "Code Review Policies\n====================\n\nProject Stewardship\n-------------------\n\nThe OpenJFX Project is guided by the Project Leads and Reviewers.\n\n__Project Co-Lead__: Kevin Rushforth (OpenJDK ID: `kcr`; GitHub ID: `kevinrushforth`) <br>\n__Project Co-Lead__: Johan Vos (OpenJDK ID: `jvos`; GitHub ID: `johanvos`)\n\n### Reviewers\n\nThe [List of Reviewers](https://openjdk.org/census#openjfx) is on the OpenJDK Census.\n\nOverview\n--------\n\nAll code must be reviewed before being pushed to the repository. The short version of the OpenJFX code review policy is:\n\n* We define a formal \"Reviewer\" role, similar to the JDK project, and outline the responsibilities of Reviewers\n* Reviewers, PR authors, and sponsoring Committers verify the following before integration:\n    * All feedback from reviewers is addressed\n    * All Reviewers who have asked for the chance to review have done so (or indicated that they no longer need to)\n    * Sufficient time (at least 1 business day) has passed to allow others to comment\n* The code review policies recognize the following different types of changes, with different minimum thresholds for review:\n    * Simple, low-impact fixes: 1 reviewer\n    * Higher-impact fixes: 2 reviewers\n    * Features / API changes: CSR for approving the change, including approval by a \"lead\"; implementation then needs 2 reviewers for the code (as with other \"higher-impact\" fixes above)\n\nDetails\n-------\n\nCode reviews are important to maintain high-quality contributions, but we recognize that not every type of change needs the same level of review. Without lowering our standards of quality, we want to make it easier to get low-impact changes (simple bug fixes) accepted.\n\nIn support of this, the following review policies are in effect. Many of these will involve judgment calls, especially when it comes to deciding whether a fix is low impact vs. high-impact, and that's OK. It doesn't have to be perfect.\n\n### 1. The Reviewer role for the OpenJFX Project\n\nWe define a formal \"Reviewer\" role, similar to the JDK project. A [Reviewer](https://openjdk.org/census#openjfx) is responsible for reviewing code changes and helping to determine whether a change is suitable for including into OpenJFX. We expect Reviewers to feel responsible not just for their piece, but for the quality of the JavaFX library as a whole. In other words, the role of Reviewer is one of stewardship. See the following section for what constitutes a good review.\n\nAn experienced Committer can eventually become a Reviewer by providing good quality fixes and participating in code reviews over time, demonstrating the high-level of skill and understanding needed to be a competent reviewer. The JDK uses a threshold of 32 significant contributions. Without wanting to relax this standard too much, one thing we may consider is that a Committer with, say, 24 commits, who regularly participates in reviews, offering good feedback, might be just as good a reviewer (or maybe even better) as someone with 32 commits who rarely, if ever, provides feedback on proposed bug fixes. This is meant to be a somewhat loose guideline. It is up to the Reviewers and the Project Leads to decide whether and when a new Committer is ready to become a Reviewer.\n\n### 2. Code review policies\n\nAll code reviews must be done via a pull request submitted against this GitHub repo, [openjdk/jfx](https://github.com/openjdk/jfx). A JBS bug ID must exist before the pull request will be reviewed. See [CONTRIBUTING.md](CONTRIBUTING.md) for information on how to submit a pull request.\n\nAll fixes must be reviewed by at least one reviewer with the \"Reviewer\" role (aka a \"R\"eviewer). We have a different code review threshold for different types of changes. If there is disagreement as to whether a fix is low-impact or high-impact, then it is considered high-impact. In other words we will always err on the side of quality by \"rounding up\" to the next higher category. The contributor can say whether they think something is low-impact or high-impact, but it is up to a Reviewer to confirm this. A Reviewer either adds a comment indicating that they think a single review is sufficient, or else issues the Skara `/reviewers 2` command requesting a second reviewer (a Reviewer can request more than 2 reviewers in some cases where a fix might be especially risky or cut across multiple functional areas).\n\nReview comments can either be added directly to the GitHub pull request, or by replying to the auto-generated \"RFR\" (Request For Review) email thread. The Skara bot will cross-forward between them. To approve a pull request, a reviewer must do that in the PR itself. See the following [GitHub help page](https://help.github.com/en/articles/reviewing-proposed-changes-in-a-pull-request) for help on reviewing a pull request.\n\n#### Guidelines for reviewing a PR:\n\nBy default, a PR is marked as ready once any \"R\"eviewer reviews and approves it. Because of this, those who have the Reviewer role should do the following when reviewing a PR _before_ approving it:\n\n* Determine whether this needs 2 reviewers and whether it needs a CSR; issue the `/reviewers 2` or `/csr` command as needed (note that `/reviewers 2` requires approval from 2 total reviewers, at least one of which has the Reviewer role; if you really feel that a review from a second \"R\"eviewer is needed, use the command `/reviewers 2 reviewers`)\n    * If you want to indicate your approval, but still feel additional reviewers are needed, you may increase the number of reviewers (e.g., from 2 to 3)\n    * If you want an area expert to review a PR, indicate this in a comment of the form: `Reviewers: @PERSON1 @PERSON2`; the requested reviewers can indicate whether or not they plan to review it\n    * If you want to ensure that you have the opportunity to review this PR yourself, add a comment of the form: `@PRAUTHOR Wait for me to review this PR`, optionally add any concerns you might have\n* Check that the PR target branch is correct\n    * An ordinary (non-backport) PR must target the `master` branch in almost all cases\n    * A backport PR (which will have the `backport` label) must target the current stabilization branch; a Reviewer should check that the bug being fixed meets the criteria for the current phase of stabilization\n\nHere is a list of things to keep in mind when reviewing a PR. This applies to anyone doing a review, but especially a \"R\"eviewer:\n\n* Make sure you understand why there was an issue to begin with, and why/how the proposed PR solves the issue\n* Carefully consider the risk of regression\n* Carefully consider any compatibility concerns\n* Check whether it adds, removes, or modifies any public or protected API, even implicitly (such as a public method that overrides a protected method, or a class that is moved from a non-exported to an exported package); if it does, indicate that it needs a CSR\n* Focus first on substantive comments rather than stylistic comments\n* Check whether there is an automated test; if not, ask for one, if it is feasible\n* Make sure that the PR has executed the GitHub Actions (GHA) tests; if they aren't being run, ask the PR author to enable GHA workflows; if the test fails on some platforms, check whether it is a real bug (sometimes a job fails because of GHA infrastructure changes or we see a spurious GHA failure)\n* Test the code locally if you have any concerns as to whether and how it works; as a helpful tip, merge the latest upstream master into your locally fetch PR review branch before testing\n* If the PR source branch hasn't synced up from master in a long time, or if there is an upstream commit not in the source branch that might interfere with the PR, consider asking the PR author to merge the latest upstream master, so we will get an up-to-date GHA run\n\n#### Before you integrate or sponsor a PR:\n\nSkara will mark a PR as \"ready\" once the minimum number of reviewers have reviewed it. Before you integrate or sponsor the PR, ensure that the following have been done:\n\n* All substantive feedback has been addressed, especially any objections from one with a Reviewer role\n    * If you have pushed any changes in response to a Reviewer's substantive comments, wait for them to re-review the latest version of your PR with those changes (to ensure they are satisfied with the way you addressed them)\n* All Reviewers who have requested the chance to review have done so (or indicated that they are OK with it going in without their review). In rare cases a Project Lead may override this\n* The PR has been \"rfr\" (as indicated by Skara) for at least 1 business day (at least 24 hours, not including weekends or major holidays). This is to allow sufficient time for those reviewers who might be in other time zones the chance to review if they have concerns. This is measured from the time that Skara has most recently added the \"rfr\" label (for example, for a PR that was previously in Draft mode, wait for at least 1 business day after the PR has been taken out of Draft and marked \"rfr\"). In rare cases (e.g., a build breakage) a Reviewer might give the OK to integrate without waiting for 1 business day.\n\n#### A. Low-impact bug fixes.\n\nThese are typically isolated bug fixes with little or no impact beyond fixing the bug in question; included in this category are test fixes (including most new tests), doc fixes, and fixes to sample applications (including most new samples).\n\nOne (1) \"R\"eviewer is usually sufficient to accept such changes.\n\n#### B. Higher impact bug fixes or RFEs.\n\nThese include changes to the implementation that potentially have a performance or behavioral impact, or are otherwise broad in scope. Some larger bug fixes will fall into this category, as will any fixes in high-risk areas (e.g., CSS).\n\nAt least two (2) reviewers must approve to accept such changes, at least one of whom must be a \"R\"eviewer.\n\n#### C. New features / API additions.\n\nThis includes behavioral changes, additions to the FXML or CSS spec, etc.\n\nFeature requests come with a responsibility beyond just saying \"here is the code for this cool new feature, please take it\". There are many factors to consider for even small features. Larger features will need a significant contribution in terms of API design, coding, testing, maintainability, etc.\n\nA feature should be discussed up-front on the openjfx-dev mailing list to get early feedback on the concept (is it a feature we are likely to accept) and the direction the API and/or implementation should take.\n\nTo ensure that new features are consistent with the rest of the API and the desired direction of the Project, a CSR is required for a new Feature, API addition, or behavioral change. The CSR must be reviewed and approved by a \"lead\" of the Project. Currently this is either Kevin Rushforth or Johan Vos as indicated above.\n\nThe review of the implementation follows the same \"two reviewer\" standard for higher-impact changes as described in category B. The two code reviewers for the implementation may or may not include the Lead who reviewed the CSR. The review / approval of the CSR is an independent step from the review / approval of the code change, although they can proceed in parallel.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.0361328125,
          "content": "# OpenJFX\n\nOpenJFX is an open source, next generation client application platform for desktop, mobile and embedded systems based on JavaSE. It is a collaborative effort by many individuals and companies with the goal of producing a modern, efficient, and fully featured toolkit for developing rich client applications. This is the open source project where we develop JavaFX.\n\nOpenJFX is free software, licensed under [GPL v2 with the Classpath exception](LICENSE), just like the JDK. Anybody is welcome to contribute to this project, port it to other platforms or devices, or do anything else that a free software license allows you to do!\n\nOpenJFX is a project under the charter of the OpenJDK. The [OpenJDK Bylaws](https://openjdk.org/bylaws) and [License](LICENSE) govern our work. The OpenJFX project membership can be found on the [OpenJDK Census](https://openjdk.org/census#openjfx). We welcome patches and involvement from individual contributors or companies. If this is your first time contributing to an OpenJDK project, you will need to review the rules on [becoming a Contributor](https://openjdk.org/bylaws#contributor), and sign the [Oracle Contributor Agreement](https://oca.opensource.oracle.com/) (OCA).\n\n## Issue tracking\n\nIf you think you have found a bug in OpenJFX, first make sure that you are testing against the latest version - your issue may already have been fixed. If not, search our [issues list](https://bugs.openjdk.org/issues/?filter=39543) in the Java Bug System (JBS) in case a similar issue has already been opened. More information on where and how to report a bug can be found at [bugreport.java.com](https://bugreport.java.com/).\n\n## Getting Started\n\nFor instructions on building JavaFX, see the [Building OpenJFX](https://wiki.openjdk.org/display/OpenJFX/Building+OpenJFX) Wiki page.\n\nFor information about downloading and using JavaFX, see the [JavaFX community site](https://openjfx.io/).\n\n\n## Contributing\n\nPlease read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1826171875,
          "content": "# JavaFX Vulnerabilities\n\nPlease follow the process outlined in the [OpenJDK Vulnerability Policy](https://openjdk.org/groups/vulnerability/report) to disclose vulnerabilities in JavaFX.\n"
        },
        {
          "name": "UPDATING-VERSION.md",
          "type": "blob",
          "size": 1.33984375,
          "content": "# Updating the JavaFX Release Version\n\nHere are the instructions for updating the JavaFX release version number\nfor a feature release or security (dot-dot) release.\nSee [JDK-8226365](https://bugs.openjdk.org/browse/JDK-8226365)\nfor a recent example.\n\n## Incrementing the feature version\n\nHere are the steps to increment the JavaFX release version number to a new\nfeature version (for example, from 13 to 14).\n\n* In `.jcheck/conf`, modify the `version` property in the `[general]`\nsection to increment the JBS version number from `jfx$N` to `jfx$N+1`.\n\n* In `build.properties`, modify the following properties to increment the\nfeature version number from `N` to `N+1`:\n\n```\n    jfx.release.major.version\n```\n\n* In\n`modules/javafx.base/src/test/java/test/com/sun/javafx/runtime/VersionInfoTest.java`,\nmodify the `FEATURE` variable to increment the feature version number\nfrom `N` to `N+1`.\n\n## Incrementing the security version\n\nHere are the steps to increment the JavaFX release version number to a new\nsecurity version (for example, from 13 to 13.0.1).\n\n* In `.jcheck/conf`, modify the `version` property in the `[general]`\nsection to increment the JBS version number from `jfx$N` to `jfx$N.0.1`\nor from `jfx$N.0.M` to `jfx$N.0.$M+1`.\n\n* In `build.properties`, modify the `jfx.release.security.version` property\nto increment the security version number from `M` to `M+1`.\n"
        },
        {
          "name": "WEBKIT-MEDIA-STUBS.md",
          "type": "blob",
          "size": 1.5126953125,
          "content": "# Web Testing\n\nThe web project needs WebKit and Media shared libraries to run tests.\n\nThese can be supplied in a number of ways. See sections below.\n\n## Compiled from source\n\nSpecify these Gradle properties to enable building of WebKit and Media libraries from source:\n\n    -PCOMPILE_WEBKIT=true -PCOMPILE_MEDIA=true\n\nNote that these require additional build tooling and take some time to build.\n\nIf you are not actively working on these sources, you may want to cache the output by copying it to one of the folders mentioned below.\n\n\n## Cached libraries\n\nYou can manually place WebKit and Media shared libraries in these folders:\n\n* Unix libraries (*.so or *.dylib files)\n````\n    $projectDir/../caches/sdk/lib\n````\n\n* Windows libraries (*.dll files)\n````\n    $projectDir/../caches/sdk/bin\n````\n\n## Officially released libraries\n\nGradle has a task to automate downloading officially released libraries from MavenCentral.\n\nYou can enable the task by specifying this Gradle property:\n\n    -PSTUB_RUNTIME_OPENJFX=\"15-ea+4\"\n\nNote that these libraries may not be compatible with the source tree you are working with. Always use the [latest version](https://search.maven.org/search?q=g:org.openjfx%20AND%20a:javafx); this may improve your chances of compatibility.\n\n\n## Skip Web tests\n\nYou can also skip the web module tests.\n\nSpecify these options to Gradle\n\n    -x :web:test\n\nNote that this is fine for local work. But a full test *is* required before submitting a PR, see [CONTRIBUTING.md](https://github.com/openjdk/jfx/blob/master/CONTRIBUTING.md).\n"
        },
        {
          "name": "apps",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.gradle",
          "type": "blob",
          "size": 251.986328125,
          "content": "/*\n * Copyright (c) 2013, 2024, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/**\n * The main build script for JavaFX.\n *\n * MUST FIX tasks to complete:\n *  - build check -- making sure the final artifact has the right bits\n *      - some things worth automatically sanity checking:\n *          - are there images in the javadocs?\n *          - are all of the expected dylibs etc there?\n *  - Perform sanity checking to make sure a JDK exists with javac, etc\n *  - Support building with no known JDK location, as long as javac, etc are on the path\n *  - Check all of the native flags. We're adding weight to some libs that don't need it, and so forth.\n *\n * Additional projects to work on as we go:\n *  - Add \"developer debug\". This is where the natives do not have debug symbols, but the Java code does\n *  - The genVSproperties.bat doesn't find the directory where RC.exe lives. So it is hard coded. Might be a problem.\n *  - special tasks for common needs, such as:\n *      - updating copyright headers\n *      - stripping trailing whitespace (?)\n *  - checkstyle\n *  - findbugs\n *  - re needs?\n *  - sqe testing\n *  - API change check\n *  - Pushing results to a repo?\n *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.\n *  - Integrate Parfait reports for C code\n *  - FXML Project tests are not running\n *\n * Adding a new project or task:\n *  - Fix for JDK-8297071, introduces a restriction on assigning name for a project or task.\n *    - If the name of project or task contains word test/Test then it is considered as test task.\n *    - If the name of a task contains word shim/Shim then it is considered as shims task.\n *    - See TEST_ONLY flag, isTestTask() method, the tasks: shims and sdk for more clarity.\n */\ndefaultTasks = [\"sdk\"]\n\nimport java.nio.file.Files\nimport java.nio.file.StandardCopyOption\nimport java.time.Instant\nimport java.time.LocalDateTime\nimport java.time.ZoneOffset\nimport java.time.format.DateTimeFormatter\nimport java.time.temporal.ChronoUnit\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\nimport java.util.concurrent.Future\nimport java.util.zip.ZipEntry\nimport java.util.zip.ZipFile\nimport java.util.zip.ZipOutputStream\nimport java.lang.Runtime.Version\n\n/******************************************************************************\n *                              Utility methods                               *\n *****************************************************************************/\n\n/**\n * If the given named property is not defined, then this method will define\n * it with the given defaultValue. Any properties defined by this method can\n * be substituted on the command line by using -P, or by specifying a\n * gradle.properties file in the user home dir\n *\n * @param name The name of the property to define\n * @param defaultValue The default value to assign the property\n */\nvoid defineProperty(String name, String defaultValue) {\n    if (!project.hasProperty(name)) {\n        project.ext.set(name, defaultValue);\n    }\n}\n\n/**\n * If the given named property is not defined, then this method will attempt to\n * look up the property in the props map, and use the defaultValue if it cannot be found.\n *\n * @param name The name of the property to look up and/or define\n * @param props The properties to look for the named property in, if it has not already been defined\n * @param defaultValue The default value if the property has not been defined and the\n *                     props map does not contain the named property\n */\nvoid defineProperty(String name, Properties props, String defaultValue) {\n    if (!project.hasProperty(name)) {\n        project.ext.set(name, props.getProperty(name, defaultValue));\n    }\n}\n\n/**\n * Converts cygwin style paths to windows style paths, but with a forward slash.\n * This method is safe to call from any platform, and will only do work if\n * called on Windows (in all other cases it simply returns the supplied path.\n *\n * @param path the path to convert\n * @return the path converted to windows style, if on windows, otherwise it\n *         is the supplied path.\n */\nString cygpath(String path) {\n    if (!IS_WINDOWS) return path;\n    if (path == null || \"\".equals(path)) return path;\n    String ret = path.replaceAll('\\\\\\\\', '/')\n    logger.info(\"Converting path '$path' via cygpath to \"+ret)\n    return ret\n}\n\n/**\n * Converts cygwin file paths for java executables to windows style\n * executable paths by changing forward slashes to back slashes and\n * adding the '.exe' extension.\n * This method is safe to call from any platform, and will only do work if\n * called on Windows (in all other cases it simply returns the supplied path).\n *\n * @param path the path to convert\n * @return the path converted to windows style, if on windows, otherwise it\n *         is the supplied path.\n */\nString cygpathExe(String path) {\n    if (!IS_WINDOWS) return path;\n    if (path == null || \"\".equals(path)) return path;\n    String ret = path.replaceAll('/', '\\\\\\\\')\n    logger.info(\"Converting path '$path' via cygpath to \"+ret)\n    return ret + \".exe\"\n}\n\nvoid loadProperties(String sourceFileName) {\n    def config = new Properties()\n    def propFile = new File(sourceFileName)\n    if (propFile.canRead()) {\n        config.load(new FileInputStream(propFile))\n        for (java.util.Map.Entry property in config) {\n            def keySplit = property.key.split(\"\\\\.\");\n            def key = keySplit[0];\n            for (int i = 1; i < keySplit.length; i++) {\n                key = key + keySplit[i].capitalize();\n            }\n            ext[key] = property.value;\n        }\n    }\n}\n\n/**\n * Struct used to contain some information passed to the closure\n * passed to compileTargets.\n */\nclass CompileTarget {\n    String name;\n    String upper;\n    String capital;\n}\n\n/**\n * Iterates over each of the compile targets, passing the given closure\n * a CompileTarget instance.\n *\n * @param c The closure to call\n */\nvoid compileTargets(Closure c) {\n    if (COMPILE_TARGETS == \"\") {\n        return\n    }\n    COMPILE_TARGETS.split(\",\").each { target ->\n        CompileTarget ct = new CompileTarget();\n        ct.name = target;\n        ct.upper = target.trim().toUpperCase(Locale.ROOT)\n        ct.capital = target.trim().capitalize()\n        c(ct)\n    }\n}\n\n/**\n * Manages the execution of some closure which is responsible for producing\n * content for a properties file built at build time and stored in the\n * root project's $buildDir, and then loading that properties file and\n * passing it to the processor closure.\n *\n * This is used on windows to produce a properties file containing all the\n * windows visual studio paths and environment variables, and on Linux\n * for storing the results of pkg-config calls.\n *\n * @param name the name of the file to produce\n * @param loader a closure which is invoked, given the properties file. This\n *        closure is invoked only if the properties file needs to be created\n *        and is responsible for populating the properties file.\n * @param processor a closure which is invoked every time this method is\n *        called and which will be given a Properties object, fully populated.\n *        The processor is then responsible for doing whatever it is that it\n *        must do with those properties (such as setting up environment\n *        variables used in subsequent native builds, or whatnot).\n */\nvoid setupTools(String name, Closure loader, Closure processor) {\n    // Check to see whether $buildDir/$name.properties file exists. If not,\n    // then generate it. Once generated, we need to read the properties file to\n    // help us define the defaults for this block of properties\n    File propFile = file(\"$buildDir/${name}.properties\");\n    if (!propFile.exists() || propFile.length() == 0) {\n        // Create the properties file\n        propFile.getParentFile().mkdirs();\n        propFile.createNewFile();\n        loader(propFile);\n    }\n\n    // Try reading the properties in order to define the properties. If the property file cannot\n    // be located, then we will throw an exception because we cannot guess these values\n    InputStream propStream = null;\n    try {\n        Properties properties = new Properties();\n        propStream = new FileInputStream(propFile);\n        properties.load(propStream);\n        processor(properties);\n    } finally {\n        try { propStream.close() } catch (Exception e) { }\n    }\n}\n\n/**\n * Fails the build with the specified error message\n *\n * @param msg the reason for the failure\n */\nvoid fail(String msg) {\n    throw new GradleException(\"FAIL: \" + msg);\n}\n\n/**\n * Rewrites the ZIP or JAR archive, setting the timestamp of each entry to\n * the local date and time in UTC of the instant provided.\n *\n * Note that using the method 'eachFile(Closure)' of the Zip Task for this\n * purpose fails to modify the JAR entries for META-INF and MANIFEST.MF\n * because the manifest file is generated by Gradle instead of copied.\n *\n * Also note that the ZIP format has no notion of time zone. The UTC date\n * and time can be set in optional extra fields, but only in addition to\n * the local \"MS-DOS date and time.\" To avoid depending on the time zone\n * of the build machine, this method provides the local date and time in\n * UTC by calling 'setTimeLocal(LocalDateTime)'.\n *\n * An alternative solution is to set the default time zone of the\n * JVM temporarily to UTC while providing the UTC date and time with\n * 'setLastModifiedTime(FileTime)'. This solution stores the precise instant\n * on the time-line, but it also increases the size of the archive by adding\n * an extra Extended Timestamp field for each entry.\n *\n * @param archive the ZIP or JAR archive file to rewrite\n * @param instant the instant for the timestamp of each entry\n */\nvoid setFileTimestamps(Provider<RegularFile> archive, Instant instant) {\n    def dosTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC)\n    def oldFile = archive.get().getAsFile()\n    def zipFile = new ZipFile(oldFile)\n    def newName = oldFile.getName() + \".new\"\n    def newFile = new File(oldFile.getParentFile(), newName)\n    def output = new ZipOutputStream(new FileOutputStream(newFile))\n    zipFile.entries().each { ZipEntry entry ->\n        def clone = new ZipEntry(entry)\n        def input = zipFile.getInputStream(entry)\n        clone.setTimeLocal(dosTime)\n        output.putNextEntry(clone)\n        input.transferTo(output)\n        output.closeEntry()\n        input.close()\n    }\n    output.close()\n    zipFile.close()\n    Files.move(newFile.toPath(), oldFile.toPath(), StandardCopyOption.REPLACE_EXISTING)\n}\n\n/******************************************************************************\n *                                                                            *\n *                   Definition of project properties                         *\n *                                                                            *\n *  All properties defined using ext. are immediately available throughout    *\n *  the script as variables that can be used. These variables are attached    *\n *  to the root project (whereas if they were defined as def variables then   *\n *  they would only be available within the root project scope).              *\n *                                                                            *\n *  All properties defined using the \"defineProperty\" method can be replaced  *\n *  on the command line by using the -P flag. For example, to override the    *\n *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *\n *                                                                            *\n *****************************************************************************/\n\nloadProperties(\"$projectDir/build.properties\")\n\n// If the ../rt-closed directory exists, then we are doing a closed build.\n// In this case, build and property files will be read from\n// ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle\n// respectively\n\ndef closedDir = file(\"../rt-closed\")\ndef buildClosed = closedDir.isDirectory()\next.BUILD_CLOSED = buildClosed\n\next.RUNARGSFILE = \"run.args\"\next.COMPILEARGSFILE = \"compile.args\"\n\next.TESTCOMPILEARGSFILE = \"testcompile.args\"\next.TESTRUNARGSFILE = \"testrun.args\"\n\n// the file containing \"extra\" --add-exports\next.EXTRAADDEXPORTS = 'buildSrc/addExports'\n\next.MODULESOURCEPATH = \"modulesourcepath.args\"\n\n// These variables indicate what platform is running the build. Is\n// this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?\next.OS_NAME = System.getProperty(\"os.name\").toLowerCase()\next.OS_ARCH = System.getProperty(\"os.arch\")\next.ARCH_NAME = \"x64\"\next.IS_64 = OS_ARCH.toLowerCase().contains(\"64\")\next.IS_AARCH64 = OS_ARCH.toLowerCase().contains(\"aarch64\")\next.IS_LOONGARCH64 = OS_ARCH.toLowerCase().contains(\"loongarch64\")\next.IS_RISCV64 = OS_ARCH.toLowerCase().contains(\"riscv64\")\next.IS_MAC = OS_NAME.contains(\"mac\") || OS_NAME.contains(\"darwin\")\next.IS_WINDOWS = OS_NAME.contains(\"windows\")\next.IS_LINUX = OS_NAME.contains(\"linux\")\n\next.MAVEN_GROUP_ID = \"org.openjfx\"\n\n// Enable native access from modules with native code\next.enableNativeGraphics='--enable-native-access=javafx.graphics'\next.enableNativeAll='--enable-native-access=javafx.graphics,javafx.media,javafx.web'\n\n// FIXME: Remove this when JDK-8334137 is fixed\next.allowSunMiscUnsafe = '--sun-misc-unsafe-memory-access=allow'\n\n// Verify that the architecture & OS are supported configurations. Note that\n// at present building on PI is not supported, but we would only need to make\n// some changes on assumptions on what should be built (like SWT / Swing) and\n// such and we could probably make it work.\nif (!IS_MAC && !IS_WINDOWS && !IS_LINUX) fail(\"Unsupported build OS ${OS_NAME}\")\nif (IS_WINDOWS && OS_ARCH != \"x86\" && OS_ARCH != \"amd64\" && !IS_AARCH64) {\n    logger.warn(\"Unknown and unsupported build architecture: $OS_ARCH\")\n} else if (IS_MAC && OS_ARCH != \"x86_64\" && OS_ARCH != \"aarch64\") {\n    logger.warn(\"Unknown and unsupported build architecture: $OS_ARCH\")\n} else if (IS_LINUX && OS_ARCH != \"i386\" && OS_ARCH != \"amd64\" && !IS_AARCH64 && !IS_LOONGARCH64 && !IS_RISCV64) {\n    logger.warn(\"Unknown and unsupported build architecture: $OS_ARCH\")\n}\n\nif (IS_64) {\n    if (IS_AARCH64) {\n        ARCH_NAME = \"aarch64\"\n    } else if (IS_LOONGARCH64) {\n        ARCH_NAME = \"loongarch64\"\n    } else if (IS_RISCV64) {\n        ARCH_NAME = \"riscv64\"\n    } else {\n        ARCH_NAME = \"x64\"\n    }\n} else {\n    ARCH_NAME = \"x32\"\n}\n\n// Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,\n// use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified\n// independently (or we'll try to get the right one based on other supplied info). Sometimes the\n// JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:\n//    c:\\Program Files (x86)\\Java\\jdk1.8.0\\jre\n//    c:\\Program Files (x86)\\Java\\jre8\\\n// Because of this, you may sometimes get the jdk's JRE (in which case the logic we used to have here\n// was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).\ndef envJavaHome = cygpath(System.getenv(\"JDK_HOME\"))\nif (envJavaHome == null || envJavaHome.equals(\"\")) envJavaHome = cygpath(System.getenv(\"JAVA_HOME\"))\ndef javaHome = envJavaHome == null || envJavaHome.equals(\"\") ? System.getProperty(\"java.home\") : envJavaHome\ndef javaHomeFile = file(javaHome)\ndefineProperty(\"JDK_HOME\",\n        javaHomeFile.name == \"jre\" ?\n        javaHomeFile.getParent().toString() :\n        javaHomeFile.name.startsWith(\"jre\") ?\n        new File(javaHomeFile.getParent(), \"jdk1.${javaHomeFile.name.substring(3)}.0\").toString() :\n        javaHome) // we have to bail and set it to something and this is as good as any!\next.JAVA_HOME = JDK_HOME\n\ndefineProperty(\"JAVA\", cygpathExe(\"$JDK_HOME/bin/java\"))\ndefineProperty(\"JAVAC\", cygpathExe(\"$JDK_HOME/bin/javac\"))\ndefineProperty(\"JAVADOC\", cygpathExe(\"$JDK_HOME/bin/javadoc\"))\ndefineProperty(\"JMOD\", cygpathExe(\"$JDK_HOME/bin/jmod\"))\ndefineProperty(\"JDK_DOCS\", \"https://docs.oracle.com/en/java/javase/${jdkDocsVersion}/docs/api/\")\ndefineProperty(\"JDK_JMODS\", cygpath(System.getenv(\"JDK_JMODS\")) ?: cygpath(System.getenv(\"JDK_HOME\") + \"/jmods\"))\n\ndefineProperty(\"libAVRepositoryURL\", \"https://github.com/libav/libav/archive\")\ndefineProperty(\"FFmpegRepositoryURL\", \"https://www.ffmpeg.org/releases/\")\ndefineProperty(\"icuRepositoryURL\", \"https://github.com/unicode-org/icu/releases/\")\n\ndef supplementalPreBuildFile = file(\"$closedDir/closed-pre-build.gradle\");\ndef supplementalBuildFile = file(\"$closedDir/closed-build.gradle\");\n\nif (BUILD_CLOSED) {\n    apply from: supplementalPreBuildFile\n}\n\n// GRADLE_VERSION_CHECK specifies whether to fail the build if the\n// gradle version check fails\ndefineProperty(\"GRADLE_VERSION_CHECK\", \"true\")\next.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)\n\n// JAVA_TARGET_VERSION specifies the minimum compile and runtime Java version that we will target when building the JavaFX classes\next.JAVA_TARGET_VERSION = Integer.parseInt(jfxJdkTargetVersion)\n\n// JFX_DEPS_URL specifies the optional location of an alternate local repository\ndefineProperty(\"JFX_DEPS_URL\", \"\")\n\n// JDK_DOCS_LINK specifies the optional URL for offline javadoc linking\ndefineProperty(\"JDK_DOCS_LINK\", \"\")\n\n// COMPILE_WEBKIT specifies whether to build all of webkit.\ndefineProperty(\"COMPILE_WEBKIT\", \"false\")\next.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)\n\n// COMPILE_MEDIA specifies whether to build all of media.\ndefineProperty(\"COMPILE_MEDIA\", \"false\")\next.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)\n\n// BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries\ndefineProperty(\"BUILD_LIBAV_STUBS\", \"false\")\next.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false\n\n// BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with\n// decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.\ndefineProperty(\"BUILD_WORKING_LIBAV\", \"false\")\next.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false\n\n// COMPILE_PANGO specifies whether to build javafx_font_pango.\ndefineProperty(\"COMPILE_PANGO\", \"${IS_LINUX}\")\next.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)\n\n// COMPILE_HARFBUZZ specifies whether to use Harfbuzz.\ndefineProperty(\"COMPILE_HARFBUZZ\", \"false\")\next.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)\n\n// COMPILE_PARFAIT specifies whether to build parfait\ndefineProperty(\"COMPILE_PARFAIT\", \"false\")\next.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)\n\ndefineProperty(\"STATIC_BUILD\", \"false\")\next.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)\n\nif (IS_STATIC_BUILD && IS_COMPILE_MEDIA) {\n    throw new GradleException(\"Can not have COMPILE_MEDIA when STATIC_BUILD is enabled\");\n}\n\n// By default, target architecture = host architecture, but we allow different ones.\n// On Apple Silicon, default architecture must be \"arm64\", because clang does not accept\n// aarch64 as -arch parameter.\ndefineProperty(\"TARGET_ARCH\", (IS_MAC && IS_AARCH64) ? \"arm64\" : OS_ARCH)\n\n// BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads\n// required build tools.\ndefineProperty(\"BUILD_TOOLS_DOWNLOAD_SCRIPT\", \"\")\n\n// Define the SWT.jar that we are going to have to download during the build process based\n// on what platform we are compiling from (not based on our target).\next.SWT_FILE_NAME =\n    IS_MAC && IS_AARCH64 ? \"org.eclipse.swt.cocoa.macosx.aarch64_${swtVersion}\" :\n    IS_MAC && !IS_AARCH64 ? \"org.eclipse.swt.cocoa.macosx.x86_64_${swtVersion}\" :\n    IS_WINDOWS ? \"org.eclipse.swt.win32.win32.x86_64_${swtVersion}\" :\n    IS_LINUX && IS_AARCH64 ? \"org.eclipse.swt.gtk.linux.aarch64_${swtVersion}\" :\n    IS_LINUX && !IS_AARCH64 ? \"org.eclipse.swt.gtk.linux.x86_64_${swtVersion}\" : \"\"\n\n// Specifies whether to run full tests (true) or smoke tests (false)\ndefineProperty(\"FULL_TEST\", \"false\")\next.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);\n\ndefineProperty(\"FORCE_TESTS\", \"false\")\next.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);\n\n// Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)\ndefineProperty(\"USE_ROBOT\", \"false\")\next.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);\n\n// Specified whether to run tests in headless mode\ndefineProperty(\"HEADLESS_TEST\", \"false\")\next.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);\n\n// Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)\ndefineProperty(\"AWT_TEST\", \"true\")\next.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);\n\n// Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)\ndefineProperty(\"SWT_TEST\", \"true\")\next.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);\n\n// Specifies whether to run unstable tests (true) - tests that don't run well with Hudson builds\n// These tests should be protected with :\n//    assumeTrue(Boolean.getBoolean(\"unstable.test\"));\ndefineProperty(\"UNSTABLE_TEST\", \"false\")\next.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);\n\n// Default timeout values to use in JUnit for tests and lifecycle methods\n// that don't specify one\ndefineProperty(\"JUNIT_TEST_TIMEOUT\", \"120s\")\ndefineProperty(\"JUNIT_LIFECYCLE_TIMEOUT\", \"20s\")\n\n// Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.\ndefineProperty(\"WORKER_DEBUG\", \"false\")\next.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);\n\n// Specify the build configuration (Release, Debug, or DebugNative)\ndefineProperty(\"CONF\", \"Debug\")\next.IS_DEBUG_JAVA = CONF == \"Debug\" || CONF == \"DebugNative\"\next.IS_DEBUG_NATIVE = CONF == \"DebugNative\"\next.IS_RELEASE = !ext.IS_DEBUG_JAVA\n\n// Specifies whether to enable the Maven publishing tasks\ndefineProperty(\"MAVEN_PUBLISH\", \"false\")\next.IS_MAVEN_PUBLISH = Boolean.parseBoolean(MAVEN_PUBLISH)\n\n// Define the compiler lint warnings to enable.\n//\n// We define a separate set of options for normal classes, test classes\n// (including shims), and tool classes (including JSLC).\n// A project (module) can add project-specific lint options for each\n// category if desired.\n// extraLintOptions\n// extraToolLintOptions\n// extraTestLintOptions\n//\n// The lint options can be overriden on the command line. If set to the\n// empty string, then no lint warnings are enabled; even project-specific\n// lint options are disabled. If not empty, then it is parsed as a space\n// or comma separated list of names. See the javac documentation for a list\n// of valid lint options.\n\ndef defaultLintOptions =\n        \"removal\" + \",\" +\n        \"missing-explicit-ctor\"\ndefineProperty(\"LINT\", defaultLintOptions)\next.IS_LINT = LINT != \"\"\n\ndef defaultToolLintOptions = \"\"\ndefineProperty(\"TOOL_LINT\", defaultToolLintOptions)\next.IS_TOOL_LINT = TOOL_LINT != \"\"\n\ndef defaultTestLintOptions =\n        \"-options\" + \",\" +\n        \"removal\"\ndefineProperty(\"TEST_LINT\", defaultTestLintOptions)\next.IS_TEST_LINT = TEST_LINT != \"\"\n\ndefineProperty(\"JAVAC_WERROR\", \"true\")\next.IS_JAVAC_WERROR = Boolean.parseBoolean(JAVAC_WERROR)\n\ndefineProperty(\"TOOL_JAVAC_WERROR\", \"false\")\next.IS_TOOL_JAVAC_WERROR = Boolean.parseBoolean(TOOL_JAVAC_WERROR)\n\ndefineProperty(\"TEST_JAVAC_WERROR\", \"true\")\next.IS_TEST_JAVAC_WERROR = Boolean.parseBoolean(TEST_JAVAC_WERROR)\n\n// Doclint options (all enabled by default)\ndefineProperty(\"DOC_LINT\", \"all\")\next.IS_DOC_LINT = DOC_LINT != \"\"\n\ndefineProperty(\"DOC_WERROR\", \"true\")\next.IS_DOC_WERROR = Boolean.parseBoolean(DOC_WERROR)\n\n// Specifies whether to use the \"useDepend\" option when compiling Java sources\ndefineProperty(\"USE_DEPEND\", \"true\")\next.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)\n\n// Specifies whether to use the \"incremental\" option when compiling Java sources\ndefineProperty(\"INCREMENTAL\", \"false\")\next.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)\n\n// Specifies whether to include the Null3D pipeline (for perf debugging)\ndefineProperty(\"INCLUDE_NULL3D\", \"false\")\next.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)\n\n// Specifies whether to include the ES2 pipeline if available\ndefineProperty(\"INCLUDE_ES2\", IS_WINDOWS ? \"false\" : \"true\")\next.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)\n\n// Specifies whether to generate code coverage statistics when running tests\ndefineProperty(\"JCOV\", \"false\")\next.DO_JCOV = Boolean.parseBoolean(JCOV)\n\n// Specifies whether to use Cygwin when building OpenJFX. This should only ever\n// be set to false for development builds (that skip building media and webkit).\ndefineProperty(\"USE_CYGWIN\", \"true\")\next.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)\n\n// Define the number of threads to use when compiling (specifically for native compilation, including webkit)\ndefineProperty(\"NUM_COMPILE_THREADS\", \"${Runtime.runtime.availableProcessors()}\")\n\n//\n// The next three sections of properties are used to generate the\n// VersionInfo class, and the Windows DLL manifest.\n//\n\n// The following properties should be left alone by developers and set only from Hudson.\ndefineProperty(\"HUDSON_JOB_NAME\", \"not_hudson\")\ndefineProperty(\"HUDSON_BUILD_NUMBER\",\"0000\")\ndefineProperty(\"PROMOTED_BUILD_NUMBER\", \"0\")\ndefineProperty(\"MILESTONE_FCS\", \"false\")\next.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)\n\n// The following properties define the product name for Oracle JDK and OpenJDK\n// for VersionInfo and the DLL manifest.\nif (BUILD_CLOSED) {\n    defineProperty(\"PRODUCT_NAME\", \"Java(TM)\")\n    defineProperty(\"COMPANY_NAME\", \"Oracle Corporation\")\n    defineProperty(\"PLATFORM_NAME\", \"Platform SE\")\n} else {\n    defineProperty(\"PRODUCT_NAME\", \"OpenJFX\")\n    defineProperty(\"COMPANY_NAME\", \"N/A\")\n    defineProperty(\"PLATFORM_NAME\", \"Platform\")\n}\n\n// The following properties are set based on properties defined in\n// build.properties. The release version and suffix should be updated\n// in that file.\ndef relVer = 0\nif (jfxReleasePatchVersion == \"0\") {\n    if (jfxReleaseSecurityVersion == \"0\") {\n        if (jfxReleaseMinorVersion == \"0\") {\n            relVer = \"${jfxReleaseMajorVersion}\"\n        } else {\n            relVer = \"${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}\"\n        }\n    } else {\n        relVer = \"${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}\"\n    }\n} else {\n    relVer = \"${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}\"\n}\ndefineProperty(\"RELEASE_VERSION\", relVer)\ndefineProperty(\"RELEASE_VERSION_PADDED\", \"${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}\")\n\ndef buildInstant = Instant.now().truncatedTo(ChronoUnit.SECONDS)\ndef sourceDateEpoch = System.getenv(\"SOURCE_DATE_EPOCH\")\nif (sourceDateEpoch != null) {\n    def epochSeconds = Long.parseLong(sourceDateEpoch)\n    buildInstant = Instant.ofEpochSecond(epochSeconds)\n}\n// Creates the timestamp in UTC using the ISO 8601 extended format.\ndef extendedTimestamp = buildInstant.toString()\n// Creates the timestamp in UTC using the historical ad hoc format, which is\n// valid for the OPT field of the version string. An alternative to the ad hoc\n// format is the ISO 8601 basic format with the pattern \"yyyyMMdd'T'HHmmssX\".\ndef zonedTime = ZonedDateTime.ofInstant(buildInstant, ZoneOffset.UTC)\ndef formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd-HHmmss\")\ndef buildTimestamp = zonedTime.format(formatter)\ndefineProperty(\"BUILD_TIMESTAMP\", buildTimestamp)\ndef relSuffix = \"\"\ndef relOpt = \"\"\nif (HUDSON_JOB_NAME == \"not_hudson\") {\n    relSuffix = \"-internal\"\n    relOpt = \"-${buildTimestamp}\"\n} else {\n    if (IS_MILESTONE_FCS) {\n        if (jfxExperimentalFeatureName != \"\") {\n            fail(\"An experimental feature branch should not be used for FCS build\")\n        }\n        relSuffix = \"\"\n    } else {\n        if (jfxExperimentalFeatureName != \"\") {\n            relSuffix = \"-${jfxExperimentalFeatureName}\"\n            relOpt = \"-${buildTimestamp}\"\n        } else {\n            relSuffix = jfxReleaseSuffix\n        }\n    }\n}\ndefineProperty(\"RELEASE_SUFFIX\", relSuffix)\ndefineProperty(\"RELEASE_VERSION_SHORT\", \"${RELEASE_VERSION}${RELEASE_SUFFIX}\")\ndefineProperty(\"RELEASE_VERSION_LONG\", \"${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}\")\ndefineProperty(\"MAVEN_VERSION\", IS_MAVEN_PUBLISH ? (IS_MILESTONE_FCS ? \"${RELEASE_VERSION_SHORT}\" : \"${RELEASE_VERSION_LONG}\") : \"\")\n\n// Check whether the COMPILE_TARGETS property has been specified (if so, it was done by\n// the user and not by this script). If it has not been defined then default\n// to building the normal desktop build for this machine\nproject.ext.set(\"defaultHostTarget\", IS_MAC ? \"mac\" : IS_WINDOWS ? \"win\" : IS_LINUX ? \"linux\" : \"\");\ndefineProperty(\"COMPILE_TARGETS\", \"$defaultHostTarget\")\n\n// Flag indicating whether to import cross compile tools\ndef importCrossTools = false\nif (hasProperty(\"IMPORT_CROSS_TOOLS\")) {\n    importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);\n}\next.IS_IMPORT_CROSS_TOOLS = importCrossTools\n\n// Location of the cross compile tools\ndef crossToolsDir = \"../crosslibs\"\nif (hasProperty(\"CROSS_TOOLS_DIR\")) {\n    crossToolsDir = CROSS_TOOLS_DIR\n}\next.CROSS_TOOLS_DIR = file(crossToolsDir)\n\n// For backward compatibility, -PBUILD_SDK_FOR_TEST=false will set TEST_ONLY to true\ndefineProperty(\"BUILD_SDK_FOR_TEST\", \"true\")\ndef buildSdkForTest = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)\n\n// Specifies whether to run only test tasks using the already built javafx.* modules\n// and shim classes, instead of rebuilding them.\n// If true, then all non test tasks, except verifyJava are disabled. see task sdk and isTestTask method.\ndefineProperty(\"TEST_ONLY\", \"false\")\next.IS_TEST_ONLY = Boolean.parseBoolean(TEST_ONLY) || !buildSdkForTest\n\next.IS_TEST_SDK = false\nif (hasProperty(\"TEST_SDK_PATH\")) {\n    if (!IS_TEST_ONLY) {\n        fail(\"TEST_ONLY must be set to true when using an external TEST_SDK_PATH for running tests: include -PTEST_ONLY=true\")\n    }\n    def sdkShimsPath = file(\"${TEST_SDK_PATH}\")\n    def sdkPath = file(\"${TEST_SDK_PATH}/sdk\")\n    def shimsPath = file(\"${TEST_SDK_PATH}/shims\")\n    if (!sdkShimsPath.exists() || !sdkShimsPath.isDirectory() ||\n             !sdkPath.exists() || !sdkPath.isDirectory() ||\n           !shimsPath.exists() || !shimsPath.isDirectory()) {\n        fail(\"The provided TEST_SDK_PATH=${TEST_SDK_PATH} is invalid\")\n    }\n    ext.IS_TEST_SDK = true\n} else {\n    defineProperty(\"TEST_SDK_PATH\", \"${rootProject.buildDir}\")\n}\n\n// Make sure JDK_HOME/bin/java exists\nif (!file(JAVA).exists()) throw new Exception(\"Missing or incorrect path to 'java': '$JAVA'. Perhaps bad JDK_HOME? $JDK_HOME\")\nif (!file(JAVAC).exists()) throw new Exception(\"Missing or incorrect path to 'javac': '$JAVAC'. Perhaps bad JDK_HOME? $JDK_HOME\")\nif (!file(JAVADOC).exists()) throw new Exception(\"Missing or incorrect path to 'javadoc': '$JAVADOC'. Perhaps bad JDK_HOME? $JDK_HOME\")\n\n// Determine the verion of Java in JDK_HOME. It looks like this:\n//\n// $ java -version\n// java version \"1.7.0_45\"\n// Java(TM) SE Runtime Environment (build 1.7.0_45-b18)\n// Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)\n//\n// We need to parse the second line\nVersion jdkVersionInfo;\ntry (BufferedReader inStream = new java.io.BufferedReader(new java.io.InputStreamReader(\n        new java.lang.ProcessBuilder(JAVA, \"-fullversion\").start().getErrorStream()))) {\n    String v = inStream.readLine().trim();\n    if (v != null) {\n        int ib = v.indexOf(\"full version \\\"\");\n        if (ib != -1) {\n            String str = v.substring(ib);\n            String ver = str.substring(str.indexOf(\"\\\"\") + 1, str.size() - 1);\n            jdkVersionInfo = Version.parse(ver);\n\n            // Define global properties based on the version of Java\n            // For example, we could define a \"jdk18OrLater\" property as\n            // follows that could then be used to implement conditional build\n            // logic based on whether we were running on JDK 18 or later,\n            // should the need arise.\n//            ext.jdk18OrLater = jdkVersionInfo.feature() >= 18\n\n            ext.jdk24OrLater = jdkVersionInfo.feature() >= 24\n        }\n    }\n}\nif (jdkVersionInfo == null) throw new Exception(\"Unable to determine the version of Java in JDK_HOME at $JDK_HOME\");\n\n// Use --upgrade-module-path instead of --module-path when compiling and\n// running tests if we are using a JDK that includes an upgradable\n// jdk.jsobject module.  Currently, this is JDK 24 or later. Once\n// jdk.jsobject is removed from the JDK, we can stop doing it. For example,\n// if jdk.jsobject is removed from the JDK in JDK 26, the logic will then be\n// changed to: \"jdk24OrLater && !jdk26OrLater\"\next.USE_UPGRADE_MODULE_PATH = jdk24OrLater\n\n// Determine whether the javafx.* modules are present in the JDK. To do this,\n// we will execute \"java --list-modules\" and search for javafx.base.\next.HAS_JAVAFX_MODULES = false;\ndef inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, \"--list-modules\").start().getInputStream()));\ntry {\n    String v;\n    while ((v = inStream2.readLine()) != null) {\n        v = v.trim();\n        if (v.startsWith(\"javafx.base\")) ext.HAS_JAVAFX_MODULES = true;\n    }\n} finally {\n    inStream2.close();\n}\n\n// The HAS_JAVAFX_MODULES flag will be used to determine the mode for building\n// and running the applications and tests.\n// If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules\n// for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will\n// build / test a standalone sdk for running with a JDK that does not include\n// the javafx modules.\n\n\n/**\n * Fetch/Check that external tools are present for the build. This method\n * will conditionally download the packages from project defined ivy repositories\n * and unpack them into the specified destdir\n *\n * @param configName A unique name to distinguish the configuration (ie \"ARMSFV6\")\n * @param packages A list of required packages (with extensions .tgz, .zip)\n * @param destdir where the packages should be unpacked\n * @param doFetch if true, the named packages will be download\n */\nvoid fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {\n    if (doFetch) {\n        // create a unique configuration for this fetch\n        def String fetchToolsConfig = \"fetchTools$configName\"\n        rootProject.configurations.create(fetchToolsConfig)\n\n        def List<String> fetchedPackages = []\n        def int fetchCount = 0\n\n        packages.each { pkgname->\n            def int dotdex = pkgname.lastIndexOf('.')\n            def int dashdex = pkgname.lastIndexOf('-')\n            def String basename = pkgname.substring(0,dashdex)\n            def String ver = pkgname.substring(dashdex+1,dotdex)\n            def String ext = pkgname.substring(dotdex+1)\n            def File pkgdir = file(\"$destdir/$basename-$ver\")\n\n            if (!pkgdir.isDirectory()) {\n                rootProject.dependencies.add(fetchToolsConfig, \"javafx:$basename:$ver\", {\n                    artifact {\n                        name = basename\n                        type = ext\n                    }\n                })\n                println \"adding $pkgname as a downloadable item did not find $pkgdir\"\n                fetchedPackages.add(pkgname)\n                fetchCount++\n            }\n        }\n\n        //fetch all the missing packages\n        if (fetchedPackages.size() > 0) {\n            destdir.mkdirs()\n\n            logger.quiet \"fetching missing packages $fetchedPackages\"\n            copy {\n                from rootProject.configurations[fetchToolsConfig]\n                into destdir\n            }\n\n            // unpack the fetched packages\n            fetchedPackages.each { pkgname->\n                logger.quiet \"expanding the package $pkgname\"\n                def srcball = file(\"${destdir}/${pkgname}\")\n\n                if (!srcball.exists()) {\n                    throw new GradleException(\"Failed to fetch $pkgname\");\n                }\n\n                def String basename = pkgname.substring(0,pkgname.lastIndexOf(\".\"))\n                def File pkgdir = file(\"$destdir/$basename\")\n\n                if (pkgname.endsWith(\".tgz\") || pkgname.endsWith(\"tar.gz\")) {\n                    if (IS_LINUX || IS_MAC) {\n                        // use native tar to support symlinks\n                        pkgdir.mkdirs()\n                        exec {\n                            workingDir pkgdir\n                            commandLine \"tar\", \"zxf\", \"${srcball}\"\n                         }\n                    } else {\n                        copy {\n                            from tarTree(resources.gzip(\"${srcball}\"))\n                            into pkgdir\n                        }\n                    }\n                } else if (pkgname.endsWith(\".zip\")) {\n                     copy {\n                         from zipTree(\"${srcball}\")\n                         into pkgdir\n                     }\n                } else {\n                    throw new GradleException(\"Unhandled package type for compile package ${pkgname}\")\n                }\n                srcball.delete();\n            }\n        } else {\n            logger.quiet \"all tool packages are present $packages\"\n        }\n    } else { // !doFetch - so just check they are present\n        // check that all the dirs are really there\n        def List<String> errors = []\n        packages.each { pkgname->\n            def String basename = pkgname.substring(0,pkgname.lastIndexOf(\".\"))\n            def File pkgdir = file(\"$destdir/$basename\")\n\n            if (!pkgdir.isDirectory()) {\n                errors.add(pkgname)\n            }\n        }\n        if (errors.size() > 0) {\n            throw new GradleException(\"Error: missing tool packages: $errors\")\n        } else {\n            logger.quiet \"all tool packages are present $packages\"\n        }\n    }\n}\n\n// Make a forked ANT call.\n// This needs to be forked so that ant can be used with the right JDK and updated modules\n// for testing obscure things like packaging of apps\nvoid ant(String conf,   // platform configuration\n         String dir,    // directory to run from\n         String target, // ant target\n         List<String>  params // parameters (usually -Dxxx=yyy)\n         ) {\n    // Try to use ANT_HOME\n    String antHomeEnv = System.getenv(\"ANT_HOME\")\n    String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;\n    String ant = (antHome != null && !antHome.equals(\"\")) ? \"$antHome/bin/ant\" : \"ant\";\n\n    List<String> cmdArgs = new ArrayList<String>()\n    if (IS_WINDOWS) {\n        cmdArgs += !ant.matches(\"\\\\s+\") ? '\"' + ant + '\"' : ant\n    }\n\n    cmdArgs += \"-Dbuild.compiler=javac1.7\"\n\n    if ((conf != null) && !rootProject.defaultHostTarget.equals(conf)) {\n        def targetProperties = rootProject.ext[conf.trim().toUpperCase()]\n        cmdArgs += \"-Dcross.platform=$conf\"\n        if (targetProperties.containsKey('arch')) {\n            cmdArgs += \"-Dcross.platform.arch=${targetProperties.arch}\"\n        }\n    }\n\n    if (params != null) {\n        params.each() { s->\n            cmdArgs += IS_WINDOWS && !s.matches(\"\\\\s+\") ? '\"' + s + '\"' : s\n        }\n    }\n\n    if (IS_MILESTONE_FCS) {\n        cmdArgs += '-Djfx.release.suffix=\"\"'\n    }\n\n    cmdArgs += target\n\n    exec {\n        workingDir = dir\n        environment(\"JDK_HOME\", JDK_HOME)\n        environment(\"JAVA_HOME\", JDK_HOME)\n        if (IS_WINDOWS) {\n            environment([\n                    \"VCINSTALLDIR\"         : WINDOWS_VS_VCINSTALLDIR,\n                    \"VSINSTALLDIR\"         : WINDOWS_VS_VSINSTALLDIR,\n                    \"DEVENVDIR\"            : WINDOWS_VS_DEVENVDIR,\n                    \"MSVCDIR\"              : WINDOWS_VS_MSVCDIR,\n                    \"INCLUDE\"              : WINDOWS_VS_INCLUDE,\n                    \"LIB\"                  : WINDOWS_VS_LIB,\n                    \"LIBPATH\"              : WINDOWS_VS_LIBPATH,\n                    \"PATH\"                 : WINDOWS_VS_PATH\n            ]);\n            commandLine \"cmd\", \"/s\", \"/c\", '\"' + String.join(\" \", cmdArgs) + '\"'\n        } else {\n            commandLine ant\n            args(cmdArgs)\n        }\n    }\n}\n\nList<String> computeLibraryPath(boolean working) {\n    List<String> lp = []\n\n    if (HAS_JAVAFX_MODULES) {\n        List<String> modsWithNative = [ 'javafx.graphics', 'javafx.media', 'javafx.web' ]\n\n        // the build/modular-sdk area\n        def platformPrefix = \"\"\n        def bundledSdkDirName = \"${platformPrefix}modular-sdk\"\n        def bundledSdkDir = \"${rootProject.buildDir}/${bundledSdkDirName}\"\n        def modulesLibsDir = \"${bundledSdkDir}/modules_libs\"\n\n        modsWithNative.each() { m ->\n            lp << cygpath(\"${modulesLibsDir}/${m}\")\n        }\n    } else {\n        def platformPrefix = \"\"\n        def standaloneSdkDirName = \"${platformPrefix}sdk\"\n        def standaloneSdkDir = \"${TEST_SDK_PATH}/${standaloneSdkDirName}\"\n        def modulesLibName = IS_WINDOWS ? \"bin\" : \"lib\"\n        def modulesLibsDir = \"${standaloneSdkDir}/${modulesLibName}\"\n        lp << cygpath(\"${modulesLibsDir}\")\n    }\n\n    return lp\n}\n\n// Return list with the arguments needed for --patch-module, --module-path,\n// or --upgrade-module-path for the provided projects.\n// Used with Java executables ie. tests\nList<String> computePatchModuleArgs(List<String> deps, boolean test, boolean includeJLP) {\n    List<String> pma = []\n\n    if (HAS_JAVAFX_MODULES) {\n        deps.each { String projname ->\n            def proj = project(projname)\n            if (proj.hasProperty(\"moduleName\")) {\n                File dir;\n                if (test && proj.sourceSets.hasProperty('shims')) {\n                    dir = file(\"${rootProject.buildDir}/shims\")\n                } else {\n                    dir = file(\"${rootProject.buildDir}/modular-sdk/modules\")\n                }\n                String moduleName = proj.ext.moduleName\n                String dirpath = cygpath(\"${dir}/${moduleName}\")\n                pma += \"--patch-module=${moduleName}=${dirpath}\"\n            }\n        }\n    } else {\n        String mp = null\n        deps.each { String projname ->\n            def proj = project(projname)\n            if (proj.hasProperty(\"moduleName\")) {\n                String moduleName = proj.ext.moduleName\n                File dir;\n                if (test && proj.sourceSets.hasProperty('shims')) {\n                    dir = file(\"${TEST_SDK_PATH}/shims/${moduleName}\")\n                } else {\n                    dir = file(\"${TEST_SDK_PATH}/sdk/lib/${moduleName}.jar\")\n                }\n                if (mp == null) {\n                    mp = dir.path\n                } else {\n                    mp = mp + File.pathSeparator + dir.path\n                }\n            }\n        }\n\n        // in some cases like base we could end up with an empty\n        // path... make sure we don't pass one back\n        if (mp == null) {\n            return null\n        }\n\n        pma += (test && USE_UPGRADE_MODULE_PATH) ? '--upgrade-module-path' : '--module-path'\n        pma += mp\n\n        String addm = null\n        deps.each {String projname ->\n            def proj = project(projname)\n            if (proj.hasProperty(\"moduleName\") && proj.buildModule) {\n                if (addm == null) {\n                    addm = proj.moduleName\n                } else {\n                    addm = addm + \",\" + proj.moduleName\n                }\n            }\n        }\n        if (addm != null) {\n            pma += \"--add-modules=${addm}\"\n        }\n    }\n\n    if (includeJLP) {\n        pma += \"-Djava.library.path=\" + computeLibraryPath(true).join(File.pathSeparator)\n    }\n\n    return pma\n}\n\n// Return a list containing the --upgrade-module-path or --module-path\n// used with Javac\nList<String> computeModulePathArgs(String  pname, List<String> deps, boolean test) {\n    List<String> mpa = (HAS_JAVAFX_MODULES || (test && USE_UPGRADE_MODULE_PATH)) ? [ '--upgrade-module-path' ] : [ '--module-path' ]\n    String mp = null\n    deps.each { String projname ->\n        def proj = project(projname)\n        // for a non test set of args, we don't want the current module in the list\n        // for a test test, we do need it to update what we built\n\n        if (proj.hasProperty(\"moduleName\") &&\n                proj.buildModule &&\n                !(!test && proj.name.equals(pname))) {\n\n            File dir;\n            if (test && proj.sourceSets.hasProperty('shims')) {\n                dir = new File(proj.sourceSets.shims.java.getDestinationDirectory().get().getAsFile(), proj.ext.moduleName);\n            } else {\n                dir = new File(proj.sourceSets.main.java.getDestinationDirectory().get().getAsFile(), proj.ext.moduleName);\n            }\n            if (mp == null) {\n                mp = dir.path\n            } else {\n                mp = mp + File.pathSeparator + dir.path\n            }\n        }\n    }\n\n    // in some cases like base we could end up with an empty\n    // path... make sure we don't pass one back\n    if (mp == null) {\n        return null\n    }\n\n    mpa += mp\n\n    if (!HAS_JAVAFX_MODULES) {\n        String addm = null\n        deps.each {String projname ->\n            def proj = project(projname)\n            // for a non test set of args, we don't want the current module in the list\n            // for a test test, we do need it to update what we built\n\n            if (proj.hasProperty(\"moduleName\") &&\n                    proj.buildModule &&\n                    !(!test && proj.name.equals(pname))) {\n\n                if (addm == null) {\n                    addm = proj.moduleName\n                } else {\n                    addm = addm + \",\" + proj.moduleName\n                }\n            }\n        }\n        if (addm != null) {\n            mpa += \"--add-modules=${addm}\"\n        }\n    }\n\n    return mpa\n}\n\n\nvoid writeArgsFile(boolean isCompile, File dest, List<String> libpath, List<String> modpath, List<String> modules) {\n\n    dest.delete()\n\n    logger.info(\"Creating file ${dest.path}\")\n\n    if (libpath != null) {\n        dest <<  \"-Djava.library.path=\\\"\\\\\\n\"\n        libpath.each() { e->\n            dest << \"  \"\n            dest << e\n            dest << File.pathSeparator\n            dest << \"\\\\\\n\"\n        }\n        dest <<  \"  \\\"\\n\"\n    }\n\n    if (HAS_JAVAFX_MODULES) {\n        modpath.each { e ->\n            dest <<  \"--patch-module=\\\"\"\n            dest << e\n            dest << \"\\\"\\n\"\n        }\n    } else {\n        def modulePathArgName = USE_UPGRADE_MODULE_PATH ? '--upgrade-module-path' : '--module-path'\n\n        if (modpath.size() == 1) {\n            dest <<  \"${modulePathArgName}=\\\"\"\n            dest << modpath[0]\n            dest << \"\\\"\\n\"\n        } else {\n            dest <<  \"${modulePathArgName}=\\\"\\\\\\n\"\n            modpath.each() { e->\n                dest << \"  \"\n                dest << e\n                dest << File.pathSeparator\n                dest << \"\\\\\\n\"\n            }\n            dest <<  \"  \\\"\\n\"\n        }\n    }\n\n    if (modules != null) {\n        dest <<  \"--add-modules=\"\n        dest << modules.join(\",\")\n        dest << \"\\n\"\n        if (!isCompile) {\n            dest << enableNativeAll\n            dest << \"\\n\"\n            // FIXME: Remove this when JDK-8334137 is fixed\n            if (jdk24OrLater) {\n                dest << allowSunMiscUnsafe\n                dest << \"\\n\"\n            }\n        }\n    }\n}\n\nvoid writeCompileArgsFile(File dest, List<String> libpath, List<String> modpath, List<String> modules) {\n    writeArgsFile(true, dest, libpath, modpath, modules)\n}\n\nvoid writeRunArgsFile(File dest, List<String> libpath, List<String> modpath, List<String> modules) {\n    writeArgsFile(false, dest, libpath, modpath, modules)\n}\n\n// perform common project manipulation for modules\nvoid commonModuleSetup(Project p, List<String> moduleChain) {\n\n    p.ext.moduleChain = moduleChain\n\n    if (p.hasProperty(\"moduleName\")) {\n        p.ext.moduleDir = new File (p.sourceSets.main.java.getDestinationDirectory().get().getAsFile(), \"${p.moduleName}\")\n        if (p.sourceSets.hasProperty('shims')) {\n            p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.getDestinationDirectory().get().getAsFile(), \"${p.moduleName}\")\n        }\n    }\n\n    def mpa = computeModulePathArgs(p.name, moduleChain, false)\n    if (mpa != null) {\n        p.ext.modulePathArgs = mpa\n    }\n\n    p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)\n    p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)\n    p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)\n\n    moduleChain.each() {e ->\n        if (!e.equals(p.name)) {\n            p.compileJava.dependsOn(project(e).classes)\n            p.compileTestJava.dependsOn(project(e).testClasses)\n        }\n    }\n\n    // read in any addExports file\n    File addExportsFile = new File(p.projectDir,\"src/test/addExports\")\n    if (addExportsFile.exists()) {\n        List<String> ae = []\n        addExportsFile.eachLine { line ->\n            line = line.trim()\n            if (!(line.startsWith(\"#\") || line.equals(\"\"))) {\n                ae += line.split(' ')\n            }\n        }\n        p.ext.testAddExports  = ae.flatten()\n    }\n\n    // read in the temporary addExports file EXTRAADDEXPORTS)\n    //\n    // These extra --add-exports will be used in two places and so we\n    // create/modify two items:\n    // p.testAddExports - add the extra items so they are included in test builds\n    //\n    // p.extraAddExports - for use in any other place where we don't automatically update\n    //    for example any non modular, non 'test' compile, any compile that does not\n    //    use a module-source-path that includes the dependent modules\n    //\n    // Note that we don't modify the modular build (main, shims) because they use\n    // module-info directly, and we don't want to cover up any missing items there.\n    //\n    if (!rootProject.hasProperty(\"EXTRA_ADDEXPORTS_ARGS\")) {\n        List<String> extraAddExportsList = []\n        String fullae = \"\"\n        File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)\n        if (tmpaddExportsFile.exists()) {\n            String nl = System.getProperty(\"line.separator\")\n            tmpaddExportsFile.eachLine { line ->\n                line = line.trim()\n                fullae += line + nl\n                if (!(line.startsWith(\"#\") || line.equals(\"\"))) {\n                    extraAddExportsList += line.split(' ')\n                }\n            }\n        }\n        // This string is used in the creation of the build/*.args files\n        // so we preserve comments\n        if (!extraAddExportsList.isEmpty()) {\n            rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae\n        }\n        rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList\n    }\n\n    if (HAS_JAVAFX_MODULES) {\n        // use this variable, because it shows we have a non empty addition\n        if (rootProject.hasProperty(\"EXTRA_ADDEXPORTS_STRING\")) {\n            p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()\n            if (p.hasProperty(\"testAddExports\")) {\n                p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()\n            }\n        }\n    }\n}\n\nif (BUILD_TOOLS_DOWNLOAD_SCRIPT != \"\") {\n    println \"Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}\"\n    apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT\n}\n\n// Now we need to define the native compilation tasks. The set of parameters to\n// native compilation depends on the target platform (and also to some extent what platform\n// you are compiling on). These settings are contained in various gradle files\n// such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer\n// can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file\n// that will contain the appropriate flags.\ndefineProperty(\"COMPILE_FLAGS_FILES\", COMPILE_TARGETS.split(\",\").collect {\"buildSrc/${it.trim()}.gradle\"}.join(\",\"))\nif (COMPILE_TARGETS == \"all\") {\n    def tmp = []\n    File buildSrcDir = file(\"buildSrc\")\n    buildSrcDir.listFiles().each { File f ->\n        if (f.isFile() && f.name.endsWith(\".gradle\") && !f.name.equals(\"build.gradle\")) {\n            def target = f.name.substring(0, f.name.lastIndexOf('.gradle')).toUpperCase(Locale.ROOT)\n            apply from: f\n            if (project.ext[\"${target}\"].canBuild) {\n                tmp.add(target)\n            }\n        }\n    }\n    COMPILE_FLAGS_FILES = tmp.collect { \"buildSrc/${it}.gradle\"}.join(\",\")\n    COMPILE_TARGETS = tmp.collect { \"${it.toLowerCase()}\"}.join(\",\")\n} else {\n    COMPILE_FLAGS_FILES.split(\",\").each {\n        logger.info(\"Applying COMPILE_FLAGS_FILE '$it'\")\n        apply from: it\n    }\n}\n\nif (COMPILE_TARGETS != \"\") {\n    def tmp = []\n    COMPILE_TARGETS.split(\",\").each {target ->\n        if (project.ext[\"${target.toUpperCase(Locale.ROOT)}\"].canBuild) {\n            tmp.add(target)\n        }\n    }\n    COMPILE_TARGETS = tmp.collect { \"${it.toLowerCase()}\"}.join(\",\")\n}\n\n// Sanity check the expected properties all exist\ncompileTargets { t ->\n    // Every platform must define these variables\n    if (!project.hasProperty(t.upper)) throw new Exception(\"ERROR: Incorrectly configured compile flags file, missing ${t.name} property\")\n    def props = project.ext[t.upper];\n    // TODO: we could remove libDest in favor of modLibDest\n    [\"compileSwing\", \"compileSWT\", \"libDest\"].each { prop ->\n        if (!props.containsKey(prop)) throw new Exception(\"ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}\")\n    }\n}\n\n// Various build flags may be set by the different target files, such as\n// whether to build Swing, SWT, etc. We iterate over all\n// compile targets and look for these settings in our properties. Note that\n// these properties cannot be set from the command line, but are set by\n// the target build files such as armv6hf.gradle or mac.gradle.\next.COMPILE_SWING = false;\next.COMPILE_SWT = false;\ncompileTargets { t ->\n    def targetProperties = project.rootProject.ext[t.upper]\n\n    if (targetProperties.compileSwing) COMPILE_SWING = true\n    if (targetProperties.compileSWT) COMPILE_SWT = true\n\n    if (!targetProperties.containsKey('compileWebnodeNative')) {\n        // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT\n        targetProperties.compileWebnodeNative = true\n    }\n\n    if (!targetProperties.containsKey('compileMediaNative')) {\n        // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA\n        targetProperties.compileMediaNative = true\n    }\n\n    if (!targetProperties.containsKey('includeSWT')) targetProperties.includeSWT = true\n    if (!targetProperties.containsKey('includeSwing')) targetProperties.includeSwing = true\n    if (!targetProperties.containsKey('includeNull3d')) targetProperties.includeNull3d = true\n    if (!targetProperties.containsKey('includeMonocle')) targetProperties.includeMonocle = false\n    if (!targetProperties.containsKey('includeEGL')) targetProperties.includeEGL = false\n\n    if (!targetProperties.containsKey('includeGTK')) targetProperties.includeGTK = IS_LINUX\n\n    if (!targetProperties.containsKey('modLibDest')) targetProperties.modLibDest = targetProperties.libDest\n\n    // This value is used as a prefix for various directories under ./build,\n    // such as sdk, to allow for a common name for the hosted build\n    // (for use when building apps) and a unique name for cross builds.\n    if (rootProject.defaultHostTarget.equals(t.name)) {\n        // use a simple common default for the \"host\" build\n        targetProperties.platformPrefix=\"\"\n    } else {\n        // and a more complex one for cross builds\n        targetProperties.platformPrefix=\"${t.name}-\"\n    }\n}\n\n/******************************************************************************\n *                                                                            *\n *                         Build Setup Sanity Checks                          *\n *                                                                            *\n *  Here we do a variety of checks so that if the version of Java you are     *\n *  building with is misconfigured, or you are using the wrong version of     *\n *  gradle, etc you will get some kind of helpful error / warning message     *\n *                                                                            *\n *****************************************************************************/\n\n// Sanity check that we actually have a list of compile targets to execute\nif (COMPILE_TARGETS == null || COMPILE_TARGETS == \"\") {\n    throw new Exception(\"Unable to determine compilation platform, must specify valid COMPILE_TARGETS!\")\n}\n\n// Verify that CONF is something useful\nif (CONF != \"Release\" && CONF != \"Debug\" && CONF != \"DebugNative\") {\n    logger.warn(\"Unknown configuration CONF='$CONF'. Treating as 'Release'\")\n}\n\n// If the number of compile threads is less than 1 then we have a problem!\nif (Integer.parseInt(NUM_COMPILE_THREADS.toString()) < 1) {\n    logger.warn(\"NUM_COMPILE_THREADS was specified as '$NUM_COMPILE_THREADS' which is less than the minimum value of 1. \" +\n            \"Building with a value of 1 instead.\")\n    NUM_COMPILE_THREADS = 1\n}\n\n// Check gradle version\nif (gradle.gradleVersion != jfxGradleVersion) {\n    def ver = gradle.gradleVersion.split(\"[\\\\.]\");\n    def verMin = jfxGradleVersionMin.split(\"[\\\\.]\");\n    def gradleMajor = Integer.parseInt(ver[0]);\n    def gradleMinor = Integer.parseInt(ver[1].split(\"[^0-9]\")[0]);\n    def gradleMajorMin = Integer.parseInt(verMin[0]);\n    def gradleMinorMin = Integer.parseInt(verMin[1].split(\"[^0-9]\")[0]);\n    def err = \"\";\n    if (gradleMajor < gradleMajorMin || (gradleMajor == gradleMajorMin && gradleMinor < gradleMinorMin)) {\n        err = \"Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}\"\n    }\n\n    if (IS_GRADLE_VERSION_CHECK && err != \"\") {\n        fail(err);\n    }\n\n    logger.warn(\"*****************************************************************\");\n    logger.warn(\"Unsupported gradle version $gradle.gradleVersion in use.\");\n    logger.warn(\"Only version $jfxGradleVersion is supported. Use this version at your own risk\");\n    if ( err != \"\") logger.warn(err);\n    logger.warn(\"*****************************************************************\");\n}\n\n// Look for stub runtime in bundled sdk, standalone sdk, or boot JDK\n\n// Allows automatic provisioning of webkit+media shared libraries\n// from official OpenJFX releases, downloaded from MavenCentral\ndefineProperty(\"STUB_RUNTIME_OPENJFX\", \"\")\next.IS_STUB_RUNTIME_OPENJFX = !STUB_RUNTIME_OPENJFX.isBlank()\n\ndef String cachedBundledRuntime = cygpath(\"$projectDir\") + \"/../caches/modular-sdk\"\ndef String cachedStandaloneRuntime = cygpath(\"$projectDir\") + \"/../caches/sdk\"\ndef String jdkStubRuntime = cygpath(\"$JDK_HOME\")\ndef String openjfxStubRuntime = cygpath(\"$projectDir\") + \"/buildSrc/build/openjfxStub\"\n\ndef defaultStubRuntime = \"\"\nif (file(cachedBundledRuntime).exists()) {\n    defaultStubRuntime = cachedBundledRuntime\n} else if (file(cachedStandaloneRuntime).exists()) {\n    defaultStubRuntime = cachedStandaloneRuntime\n} else if (BUILD_CLOSED) {\n    defaultStubRuntime = cachedBundledRuntime\n} else if (IS_STUB_RUNTIME_OPENJFX) {\n    defaultStubRuntime = openjfxStubRuntime\n} else {\n    defaultStubRuntime = jdkStubRuntime\n}\n\ndefineProperty(\"STUB_RUNTIME\", defaultStubRuntime)\n\nif (STUB_RUNTIME.endsWith(\"/modular-sdk\")) {\n    def stubModulesLib = \"$STUB_RUNTIME/modules_libs\"\n    defineProperty(\"MEDIA_STUB\", \"$stubModulesLib/javafx.media\")\n    defineProperty(\"WEB_STUB\", \"$stubModulesLib/javafx.web\")\n} else {\n    def libraryStub = IS_WINDOWS ? \"$STUB_RUNTIME/bin\" : \"$STUB_RUNTIME/lib\"\n\n    defineProperty(\"MEDIA_STUB\", libraryStub)\n    defineProperty(\"WEB_STUB\", libraryStub)\n}\n\next.UPDATE_STUB_CACHE = (BUILD_CLOSED && STUB_RUNTIME != \"\" && !file(STUB_RUNTIME).isDirectory())\n\n\n/******************************************************************************\n *                                                                            *\n *                      Logging of Properties and Settings                    *\n *                                                                            *\n *  Log some of the settings we've determined. We could log more here, it     *\n *  doesn't really hurt.                                                      *\n *                                                                            *\n *****************************************************************************/\n\nlogger.quiet(\"gradle.gradleVersion: $gradle.gradleVersion\")\nlogger.quiet(\"OS_NAME: $OS_NAME\")\nlogger.quiet(\"OS_ARCH: $OS_ARCH\")\nlogger.quiet(\"JAVA_HOME: $JAVA_HOME\")\nlogger.quiet(\"JDK_HOME: $JDK_HOME\")\n\nVersion javaVersionInfo = Runtime.version()\nlogger.quiet(\"java.runtime.version: \" + javaVersionInfo)\nlogger.quiet(\"java version: \" + javaVersionInfo.feature())\nlogger.quiet(\"java build number: \" + javaVersionInfo.build().orElse(0))\n\nlogger.quiet(\"jdk.runtime.version: \" + jdkVersionInfo)\nlogger.quiet(\"jdk version: \" + jdkVersionInfo.feature())\nlogger.quiet(\"jdk build: \" + javaVersionInfo.build().orElse(0))\nlogger.quiet(\"minimum jdk version: ${jfxBuildJdkVersionMin}\")\nlogger.quiet(\"minimum jdk build number: ${jfxBuildJdkBuildnumMin}\")\nlogger.quiet(\"Java target version: ${JAVA_TARGET_VERSION}\")\n\nif (IS_LINUX) {\n    logger.quiet(\"GCC version: ${jfxBuildLinuxGccVersion}\")\n} else if (IS_WINDOWS) {\n    logger.quiet(\"MSVC version: ${jfxBuildWindowsMsvcVersion}\")\n} else if (IS_MAC) {\n    logger.quiet(\"XCODE version: ${jfxBuildMacosxXcodeVersion}\")\n}\nlogger.quiet(\"cmake version: ${jfxBuildCmakeVersion}\")\nlogger.quiet(\"ninja version: ${jfxBuildNinjaVersion}\")\nlogger.quiet(\"ant version: ${jfxBuildAntVersion}\")\n\nlogger.quiet(\"HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES\")\nlogger.quiet(\"STUB_RUNTIME: $STUB_RUNTIME\")\nlogger.quiet(\"CONF: $CONF\")\nlogger.quiet(\"NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS\")\nlogger.quiet(\"COMPILE_TARGETS: $COMPILE_TARGETS\")\nlogger.quiet(\"COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES\")\nlogger.quiet(\"HUDSON_JOB_NAME: $HUDSON_JOB_NAME\")\nlogger.quiet(\"HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER\")\nlogger.quiet(\"PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER\")\nlogger.quiet(\"PRODUCT_NAME: $PRODUCT_NAME\")\nlogger.quiet(\"BUILD_TIMESTAMP: $BUILD_TIMESTAMP\")\nlogger.quiet(\"RELEASE_VERSION: $RELEASE_VERSION\")\nlogger.quiet(\"RELEASE_SUFFIX: $RELEASE_SUFFIX\")\nlogger.quiet(\"RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT\")\nlogger.quiet(\"RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG\")\nlogger.quiet(\"RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED\")\nlogger.quiet(\"MAVEN_PUBLISH: $MAVEN_PUBLISH\")\nlogger.quiet(\"MAVEN_VERSION: $MAVEN_VERSION\")\nlogger.quiet(\"UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE\")\n\n/******************************************************************************\n *                                                                            *\n *                Definition of Native Code Compilation Tasks                 *\n *                                                                            *\n *    - CCTask compiles native code. Specifically it will compile .m, .c,     *\n *      .cpp, or .cc files. It uses the headers provided by running           *\n *      'javac -h' plus additional platform specific headers. It will         *\n *      compile into .obj files.                                              *\n *    - LinkTask will perform native linking and create the .dll / .so /      *\n *      .dylib as necessary.                                                  *\n *                                                                            *\n *****************************************************************************/\n\n// Save a reference to the buildSrc.jar file because we need it for actually\n// compiling things, not just for the sake of this build script\n// (such as generating the JSL files, etc)\next.BUILD_SRC = rootProject.files(\"buildSrc/build/libs/buildSrc.jar\")\n\n/**\n * Convenience method for creating cc, link, and \"native\" tasks in the given project. These\n * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc\n * named tasks.\n *\n * @param project The project to add tasks to\n * @param name The name of the project, such as \"prism-common\". This name is used\n *        in the name of the generated task, such as ccPrismCommon, and also\n *        in the name of the final library, such as libprism-common.dylib.\n */\nvoid addNative(Project project, String name) {\n    // TODO if we want to handle 32/64 bit windows in the same build,\n    // Then we will need to modify the win compile target to be win32 or win64\n    def capitalName = name.split(\"-\").collect{it.capitalize()}.join()\n    def nativeTask = project.task(\"native$capitalName\", group: \"Build\") {\n        description = \"Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets\"\n    }\n    def cleanTask = project.task(\"cleanNative$capitalName\", type: Delete, group: \"Build\") {\n        description = \"Clean native objects for $name\"\n    }\n    if (project.hasProperty(\"nativeAllTask\")) project.nativeAllTask.dependsOn nativeTask\n    project.assemble.dependsOn(nativeTask)\n    if (project.hasProperty(\"cleanNativeAllTask\")) project.cleanNativeAllTask.dependsOn cleanTask\n\n    // Each of the different compile targets will be placed in a sub directory\n    // of these root dirs, with the name of the dir being the name of the target\n    def nativeRootDir = project.file(\"$project.buildDir/native/$name\")\n    def libRootDir = project.file(\"$project.buildDir/libs/$name\")\n    // For each compile target, create a cc / link pair\n    compileTargets { t ->\n        def targetProperties = project.rootProject.ext[t.upper]\n        def library = targetProperties.library\n        def properties = targetProperties.get(name)\n        def nativeDir = file(\"$nativeRootDir/${t.name}\")\n        def headerDir = file(\"${project.buildDir}/gensrc/headers/${project.moduleName}\")\n\n        // If there is not a library clause in the properties, assume it is not wanted\n        if (!targetProperties.containsKey(name)) {\n            println(\"Ignoring native library ${name}. Not defined in ${t.name} project properties\");\n            return\n        }\n\n        // check for the property disable${name} = true\n        def String disableKey = \"disable${name}\"\n        def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false\n        if (disabled) {\n            println(\"Native library ${name} disabled in ${t.name} project properties\");\n            return\n        }\n\n        def variants = properties.containsKey(\"variants\") ? properties.variants : [\"\"];\n        variants.each { variant ->\n            def variantProperties = variant == \"\" ? properties : properties.get(variant)\n            def capitalVariant = variant.capitalize()\n            def ccOutput = variant == \"\" ? nativeDir : file(\"$nativeDir/$variant\")\n            def ccTask = project.task(\"cc${t.capital}$capitalName$capitalVariant\", type: CCTask, group: \"Build\") {\n                description = \"Compiles native sources for ${name} for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}\"\n                matches = \".*\\\\.c|.*\\\\.cpp|.*\\\\.m|.*\\\\.cc\"\n                headers = headerDir\n                output(ccOutput)\n                params.addAll(variantProperties.ccFlags)\n                compiler = variantProperties.compiler\n                source(variantProperties.nativeSource)\n                cleanTask.delete ccOutput\n            }\n            def linkTask = project.task(\"link${t.capital}$capitalName$capitalVariant\", type: LinkTask, dependsOn: ccTask, group: \"Build\") {\n                description = \"Creates native dynamic library for $name for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}\"\n                objectDir = ccOutput\n                linkParams.addAll(variantProperties.linkFlags)\n                lib = file(\"$libRootDir/${t.name}/${variant == '' ? library(properties.lib) : library(variantProperties.lib)}\")\n                linker = variantProperties.linker\n                cleanTask.delete \"$libRootDir/${t.name}\"\n            }\n            nativeTask.dependsOn(linkTask)\n            if (IS_WINDOWS && t.name == \"win\" && (!IS_STATIC_BUILD || name == \"glass\")) {\n                def rcTask = project.task(\"rc$capitalName$capitalVariant\", type: CompileResourceTask, group: \"Build\") {\n                    description = \"Compiles native sources for $name\"\n                    matches = \".*\\\\.rc\"\n                    compiler = variantProperties.rcCompiler\n                    source(variantProperties.rcSource)\n                    if (variantProperties.rcFlags) {\n                        rcParams.addAll(variantProperties.rcFlags)\n                    }\n                    output(ccOutput)\n                }\n                linkTask.dependsOn rcTask;\n            }\n        }\n\n        def useLipo = targetProperties.containsKey('useLipo') ? targetProperties.useLipo : false\n        if (useLipo) {\n            def lipoTask = project.task(\"lipo${t.capital}$capitalName\", type: LipoTask, group: \"Build\") {\n                description = \"Creates native fat library for $name for ${t.name}\"\n                libDir = file(\"$libRootDir/${t.name}\")\n                lib = file(\"$libRootDir/${t.name}/${library(properties.lib)}\")\n            }\n            nativeTask.dependsOn(lipoTask)\n        }\n    }\n}\n\nvoid addJSL(Project project, String name, String pkg, List<String> addExports, Closure compile) {\n    def lowerName = name.toLowerCase()\n\n    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n    def compileCompilers = project.task(\"compile${name}Compilers\",\n            type: JavaCompile,\n            dependsOn: project.compileJava) {\n        description = \"Compile the $name JSL Compilers\"\n\n        classpath =\n               project.files(project.sourceSets.jslc.java.getDestinationDirectory().get().getAsFile()) +\n               project.configurations.antlr\n        source = [project.file(\"src/main/jsl-$lowerName\")]\n        destinationDirectory = project.file(\"$project.buildDir/classes/jsl-compilers/$lowerName\")\n\n        options.compilerArgs.addAll([\n            \"-implicit:none\",\n            \"--module-path\", modulePath,\n            \"--add-modules=javafx.graphics\"\n            ])\n        if (addExports != null) {\n            options.compilerArgs.addAll(addExports)\n        }\n    }\n\n    def generateShaders = project.task(\"generate${name}Shaders\",\n            dependsOn: compileCompilers) {\n        description = \"Generate $name shaders from JSL\"\n        def sourceDir = project.file(\"src/main/jsl-$lowerName\")\n        def destinationDir = project.file(\"$project.buildDir/gensrc/jsl-$lowerName\")\n        inputs.dir sourceDir\n        outputs.dir destinationDir\n        doLast {\n            compile(sourceDir, destinationDir)\n        }\n    }\n\n    def compileHLSLShaders = project.task(\"compile${name}HLSLShaders\",\n            dependsOn: generateShaders,\n            type: CompileHLSLTask) {\n        enabled = IS_WINDOWS\n        description = \"Compile $name HLSL files into .obj files\"\n        matches = \".*\\\\.hlsl\"\n        output project.file(\"$project.buildDir/hlsl/$name/$pkg\")\n        source project.file(\"$project.buildDir/gensrc/jsl-$lowerName/$pkg\")\n    }\n\n    def processShaders = project.task(\"process${name}Shaders\",\n            dependsOn: [generateShaders, compileHLSLShaders],\n            type: Copy,\n            description: \"Copy hlsl / frag shaders to build/resources/jsl-$lowerName\") {\n        from(\"$project.buildDir/hlsl/$name\") {\n            include \"**/*.obj\"\n        }\n        from(\"$project.buildDir/gensrc/jsl-$lowerName\") {\n            include(\"**/*.frag\")\n        }\n        into project.moduleDir\n    }\n\n    project.processShaders.dependsOn(processShaders)\n    project.sourceSets.shaders.output.dir(\"$project.buildDir/gensrc/jsl-$lowerName\", builtBy: processShaders )\n\n    def processShimsShaders = project.task(\"process${name}ShimsShaders\",\n            dependsOn: [generateShaders, compileHLSLShaders],\n            type: Copy,\n            description: \"Copy hlsl / frag shaders to shims\") {\n        from(\"$project.buildDir/hlsl/$name\") {\n            include \"**/*.obj\"\n        }\n        from(\"$project.buildDir/gensrc/jsl-$lowerName\") {\n            include(\"**/*.frag\")\n        }\n        into project.moduleShimsDir\n    }\n\n    project.processShimsShaders.dependsOn(processShimsShaders)\n\n}\n\nvoid addMavenPublication(Project project, List<String> projectDependencies) {\n    if (!IS_MAVEN_PUBLISH) {\n        return\n    }\n\n    if (!project.hasProperty(\"moduleName\")) {\n        fail(\"Project ${project} has no module name\")\n    }\n    projectDependencies.each { projName ->\n        def dep = project.project(\":$projName\")\n        if (!dep.hasProperty(\"moduleName\")) {\n            fail(\"${project} dependency ${dep} has no module name\")\n        }\n    }\n\n    project.apply plugin: 'maven-publish'\n\n    project.group = MAVEN_GROUP_ID\n    project.version = MAVEN_VERSION\n\n    if (project.name == 'base') {\n        project.publishing {\n            publications {\n                javafx(MavenPublication) {\n                    artifactId = 'javafx'\n                    artifacts = []\n                }\n            }\n        }\n    }\n\n    gradle.taskGraph.whenReady { g ->\n        project.tasks.findAll { it.name == 'generatePomFileForJavafxPublication'}.each { it ->\n            it.doLast {\n                copy {\n                    into project.file(\"${project.buildDir}/publications/javafx\")\n                    from file(\"${rootProject.projectDir}/javafx.pom\")\n                    rename \"javafx.pom\", \"pom-default.xml\"\n                    filter { line ->\n                        line.replaceAll(\"@VERSION@\", MAVEN_VERSION)\n                    }\n                }\n            }\n        }\n    }\n\n    project.publishing {\n        repositories {\n            maven {\n                def repositoryUrl = project.hasProperty('repositoryUrl') ? project.getProperty('repositoryUrl') : \"\"\n                def repositoryUsername = project.hasProperty('repositoryUsername') ? project.getProperty('repositoryUsername') : \"\"\n                def repositoryPassword = project.hasProperty('repositoryPassword') ? project.getProperty('repositoryPassword') : \"\"\n                url repositoryUrl\n                credentials {\n                   username repositoryUsername\n                   password repositoryPassword\n                }\n            }\n        }\n    }\n\n    compileTargets { t ->\n        project.publishing {\n            publications {\n                maven(MavenPublication) {\n                    def artifactName = project.moduleName.replace('.', '-')\n                    artifactId = artifactName\n\n                    afterEvaluate {\n                        artifact project.tasks.\"moduleEmptyPublicationJar$t.capital\"\n                        artifact project.tasks.\"modularPublicationJar$t.capital\" {\n                            archiveClassifier.set(\"$t.name\")\n                        }\n                    }\n\n                    pom.withXml {\n                        Node parent = asNode().appendNode(\"parent\")\n                        parent.appendNode(\"groupId\", MAVEN_GROUP_ID)\n                        parent.appendNode(\"artifactId\", \"javafx\")\n                        parent.appendNode(\"version\", MAVEN_VERSION)\n\n                        Node dependencies = asNode().appendNode(\"dependencies\")\n\n                        Node projectDependencyPlatform = dependencies.appendNode(\"dependency\")\n                        projectDependencyPlatform.appendNode(\"groupId\", MAVEN_GROUP_ID)\n                        projectDependencyPlatform.appendNode(\"artifactId\", artifactName)\n                        projectDependencyPlatform.appendNode(\"version\", MAVEN_VERSION)\n                        projectDependencyPlatform.appendNode(\"classifier\", \"\\${javafx.platform}\")\n\n                        if (!projectDependencies.empty) {\n                            projectDependencies.each { projName ->\n                                def dep = project.project(\":$projName\")\n                                def depName = dep.moduleName.replace('.', '-')\n                                Node projectDependency = dependencies.appendNode(\"dependency\")\n                                projectDependency.appendNode(\"groupId\", MAVEN_GROUP_ID)\n                                projectDependency.appendNode(\"artifactId\", depName)\n                                projectDependency.appendNode(\"version\", MAVEN_VERSION)\n                           }\n                        }\n                    }\n                }\n            }\n\n        }\n    }\n}\n\n/**\n * Verifies that all of the *.java files in a source tree have the\n * correct package name. If not, fail the build.\n *\n * @param sourceRoot the root of the source tree to check\n * @param hasModuleName true if the sources under sourceRoot are being\n * compiled as modules, with the immediate child directories being the\n * root(s) of the named modules being compiled. In this case the package\n * root is one directory below the sourceRoot.\n */\nvoid validatePackages(File sourceRoot, boolean hasModuleName) {\n    if (!sourceRoot.isDirectory()) {\n        return;\n    }\n    def err = false;\n    String sourceString = sourceRoot.toString().replace(\"\\\\\", \"/\")\n    def startPos = sourceString.length() + 1\n    logger.info(\"validating packages for ${sourceRoot}\")\n    def inputFiles = fileTree(dir: sourceRoot, include: \"**/*.java\")\n    inputFiles.each { file ->\n        def packageRoot = file.toString().replace(\"\\\\\", \"/\").substring(startPos)\n        if (hasModuleName) {\n            packageRoot = packageRoot.substring(packageRoot.indexOf(\"/\") + 1)\n        }\n        def endPos = packageRoot.lastIndexOf(\"/\")\n        def pkgEx = endPos > -1 ?  packageRoot.substring(0, endPos).replace(\"/\", \".\") : \"\"\n        def pkg = \"\"\n        file.withReader { reader ->\n            def line\n            while ((line = reader.readLine()) != null) {\n                def words = line.trim().split(\"[ ;]+\")\n                if (words.length > 1 && words[0] == \"package\") {\n                    pkg = words[1]\n                    break;\n                }\n            }\n        }\n        if (pkg != pkgEx) {\n            err = true\n            println \"*** ERROR: File location <${file}> does not match package name <${pkg}>\"\n        }\n    }\n    if (err) {\n        fail(\"Package validation failed\")\n    }\n}\n\n/**\n * Add a task to the given project to validate that the package names\n * of all java files in the given source sets have the correct package\n * name. If not, fail the build.\n */\nvoid addValidateSourceSets(Project project,\n                           Collection<SourceSet> sourceSets,\n                           Collection<SourceSet> modSourceSets) {\n    def validateSourceSetsTask = project.task(\"validateSourceSets\") {\n        doLast {\n            // Accumulate the root directories from all sourceSets.\n            // We use a Set to elide duplicates (the shims sourceset\n            // will include the dirs from the main sourceset)\n            Set<File> sourceRoots = []\n            sourceSets.each { srcSet ->\n                srcSet.java.srcDirs.each { rootDir ->\n                    sourceRoots += rootDir\n                }\n            }\n            sourceRoots.each { rootDir ->\n                validatePackages(rootDir, false)\n            }\n\n            Set<File> modSourceRoots = []\n            modSourceSets.each { srcSet ->\n                srcSet.java.srcDirs.each { rootDir ->\n                    modSourceRoots += rootDir\n                }\n            }\n            modSourceRoots.each { rootDir ->\n                validatePackages(rootDir, true)\n            }\n        }\n    }\n\n    // Run this for all projects when compiling the test sources\n    // (i.e., when running \"gradle test\")\n    project.compileTestJava.dependsOn(validateSourceSetsTask)\n}\n\nvoid addValidateSourceSets(Project project, Collection<SourceSet> sourceSets) {\n    addValidateSourceSets(project, sourceSets, []);\n}\n\n/**\n * Returns true if the name of task or name of task's project contains word test/Test.\n */\nboolean isTestTask(Task task) {\n    return (task.project.name.contains(\"test\") || task.project.name.contains(\"Test\")\n                 || task.name.contains(\"test\") || task.name.contains(\"Test\"))\n}\n\n// Task to verify the minimum level of Java needed to build JavaFX\ntask verifyJava() {\n    doLast {\n        Version minVersionInfo = Version.parse(\"${jfxBuildJdkVersionMin}+${jfxBuildJdkBuildnumMin}\") // from build.properties\n        if (jdkVersionInfo.compareTo(minVersionInfo) < 0) {\n            fail(\"java version mismatch: JDK version (${jdkVersionInfo}) < minimum version (${minVersionInfo})\")\n        }\n    }\n}\n\ntask updateCacheIfNeeded() {\n    // an empty task we can add to as needed for UPDATE_STUB_CACHE\n}\n\ntask createTestArgfiles {\n    // an empty task we can add to as needed\n}\n\ntask createRunArgFiles {\n    // an empty task we can add to as needed\n}\n\n/*****************************************************************************\n*        Project definitions (dependencies, etc)                             *\n*****************************************************************************/\n\nvoid addJCov(p, test) {\n    test.doFirst {\n        def jcovJVMArgument =\n                \"include=javafx,\" +\n                \"include=com.sun.javafx,\" +\n                \"include=com.sun.glass,\" +\n                \"include=com.sun.openpisces,\" +\n                \"include=com.sun.pisces,\" +\n                \"include=com.sun.prism,\" +\n                \"include=com.sun.scenario,\" +\n                \"include=com.sun.webkit,\" +\n                \"exclude=com,\" +\n                \"exclude=java,\" +\n                \"exclude=javax,\" +\n                \"exclude=\\\"**.test\\\",\" +\n                \"exclude=\\\"**.*Test\\\",\" +\n                \"file=build/reports/jcov/report.xml,\" +\n                \"merge=merge\";\n        test.jvmArgs(\"-javaagent:${p.configurations.testClasspath.files.find { it.name.startsWith('jcov') }}=$jcovJVMArgument\");\n        p.mkdir p.file(\"build/reports/jcov\")\n    }\n    test.doLast {\n        def reportFile = p.file(\"build/reports/jcov/report.xml\")\n        if (reportFile.exists()) {\n            p.javaexec {\n                workingDir = p.file(\"build/reports/jcov\")\n                classpath = p.files(p.configurations.testClasspath.files.find { it.name.startsWith('jcov') })\n                mainClass = \"com.sun.tdk.jcov.Helper\"\n                args = [\n                        \"RepGen\",\n                        \"-exclude\", \"\\\"**.test\\\"\",\n                        \"-exclude\", \"\\\"**.*Test\\\"\",\n                        \"-output\", \".\",\n                        \"-source\", p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(\":\"),\n                        \"report.xml\"\n                ]\n            }\n        }\n    }\n}\n\nallprojects {\n\n    // Setup the repositories that we'll download libraries from.\n    // By default we use Maven Central for most things. The custom \"ivy\"\n    // repo is for downloading SWT. The way it works is to setup the\n    // download URL such that it will resolve to the actual jar file to\n    // download. See SWT_FILE_NAME for the name of the jar that will be\n    // used as the \"artifact\" in the pattern below.\n    // If JFX_DEPS_URL is set, then that overrides the default\n    // repositories. This allows the dependencies to be cached locally.\n\n    if (JFX_DEPS_URL != \"\") {\n        repositories {\n            ivy {\n                url JFX_DEPS_URL\n                metadataSources {\n                    artifact()\n                }\n                patternLayout {\n                    artifact \"[artifact]-[revision](-[classifier]).[ext]\"\n                    artifact \"[artifact].[ext]\"\n                }\n            }\n        }\n    }\n\n    if (JFX_DEPS_URL == \"\") {\n        repositories {\n            mavenCentral()\n            ivy {\n                url \"https://download.eclipse.org/eclipse/updates/${eclipseUpdatesiteVersion}/plugins/\"\n                metadataSources {\n                    artifact()\n                }\n                patternLayout {\n                    artifact \"[artifact].[ext]\"\n                }\n            }\n        }\n    }\n\n    if (JFX_DEPS_URL == \"\" && IS_BUILD_LIBAV_STUBS) {\n        repositories {\n            ivy {\n                url libAVRepositoryURL\n                metadataSources {\n                    artifact()\n                }\n                patternLayout {\n                    artifact \"[artifact].[ext]\"\n                }\n            }\n            ivy {\n                url FFmpegRepositoryURL\n                metadataSources {\n                    artifact()\n                }\n                patternLayout {\n                    artifact \"[artifact].[ext]\"\n                }\n            }\n        }\n    }\n\n    if (JFX_DEPS_URL == \"\" && IS_COMPILE_WEBKIT) {\n        def icuReleaseVersion = \"${icuVersion}\".replaceAll('\\\\.', '-')\n        repositories {\n            ivy {\n                url icuRepositoryURL\n                metadataSources {\n                    artifact()\n                }\n                patternLayout {\n                    artifact \"download/release-$icuReleaseVersion/[artifact].[ext]\"\n                }\n            }\n        }\n    }\n\n    // We want to configure all projects as java projects and use the same compile settings\n    // etc, except for the root project which we just want to ignore (and for now media)\n    if (project == rootProject) {\n       return\n    }\n    if (project.path.startsWith(\":apps\")) {\n        // Lets handle the apps tree differently, as it is a collection of ant builds,\n        // and the ant importer collides with the 'apply plugin:java'\n        return\n    }\n\n    // All of our projects are java projects\n\n    apply plugin: \"java\"\n\n    // Set sourceCompatibility to the target release of Java. Most modules\n    // set compiler.options.release (to the same target version), which will\n    // override this setting, but it is needed for those modules that can't.\n    java {\n        sourceCompatibility = JAVA_TARGET_VERSION\n    }\n\n    // By default all of our projects require junit for testing so we can just\n    // setup this dependency here.\n    dependencies {\n        testImplementation group: \"junit\", name: \"junit\", version: \"${junitVersion}\"\n        testImplementation group: \"org.hamcrest\", name: \"hamcrest-core\", version: \"${hamcrestVersion}\"\n        testImplementation group: \"org.junit.jupiter\", name: \"junit-jupiter\", version: \"${junitJupiterVersion}\"\n        testImplementation group: \"org.junit.jupiter\", name: \"junit-jupiter-api\", version: \"${junitJupiterVersion}\"\n        testImplementation group: \"org.junit.jupiter\", name: \"junit-jupiter-params\", version: \"${junitJupiterVersion}\"\n        testImplementation group: \"org.opentest4j\", name: \"opentest4j\", version: \"${opentest4jVersion}\"\n        testImplementation group: \"org.apiguardian\", name: \"apiguardian-api\", version: \"${apiguardianVersion}\"\n        testRuntimeOnly group: \"org.junit.jupiter\", name: \"junit-jupiter-engine\", version: \"${junitJupiterVersion}\"\n        testRuntimeOnly group: \"org.junit.platform\", name: \"junit-platform-commons\", version: \"${junitPlatformVersion}\"\n        testRuntimeOnly group: \"org.junit.platform\", name: \"junit-platform-engine\", version: \"${junitPlatformVersion}\"\n        testRuntimeOnly group: \"org.junit.platform\", name: \"junit-platform-launcher\", version: \"${junitPlatformVersion}\"\n        testRuntimeOnly group: \"org.junit.vintage\", name: \"junit-vintage-engine\", version: \"${junitJupiterVersion}\"\n\n        if (BUILD_CLOSED && DO_JCOV)  {\n            testImplementation name: \"jcov\"\n        }\n    }\n\n    compileJava.dependsOn verifyJava\n\n    // At the moment the ASM library shipped with Gradle that is used to\n    // discover the different test classes fails on Java 8, so in order\n    // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off\n    // and manually specify the includes / excludes. At the moment we use\n    // Java 7 but when we switch to 8 this will be needed, and probably again when\n    // we start building with Java 9.\n    test {\n        useJUnitPlatform();\n\n        // Always run tests\n        outputs.upToDateWhen { false }\n\n        executable = JAVA;\n        enableAssertions = true;\n        testLogging.exceptionFormat = \"full\";\n        scanForTestClasses = true;\n        include(\"**/*.*\");\n        if (BUILD_CLOSED && DO_JCOV) {\n            addJCov(project, test)\n        }\n\n        if (IS_HEADLESS_TEST) {\n            systemProperty 'glass.platform', 'Monocle'\n            systemProperty 'monocle.platform', 'Headless'\n            systemProperty 'prism.order', 'sw'\n            systemProperty 'com.sun.javafx.gestures.zoom', 'true'\n            systemProperty 'com.sun.javafx.gestures.rotate', 'true'\n            systemProperty 'com.sun.javafx.gestures.scroll', 'true'\n        }\n\n        systemProperty 'unstable.test', IS_UNSTABLE_TEST\n        systemProperty 'junit.jupiter.execution.timeout.test.method.default', JUNIT_TEST_TIMEOUT\n        systemProperty 'junit.jupiter.execution.timeout.lifecycle.method.default', JUNIT_LIFECYCLE_TIMEOUT\n    }\n\n    compileTestJava {\n    }\n}\n\n// These strings define the module-source-path to be used in compilation.\n// They need to contain the full paths to the sources and the * will be\n// used to infer the module name that is used.\nproject.ext.defaultModuleSourcePath =\n    cygpath(rootProject.projectDir.path + '/modules/*/src/main/java') +\n        File.pathSeparator  +\n    cygpath(rootProject.projectDir.path + '/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}')\n\n// graphics pass one\nproject.ext.defaultModuleSourcePath_GraphicsOne =\n    cygpath(rootProject.projectDir.path + '/modules/*/src/main/java') +\n        File.pathSeparator  +\n    cygpath(rootProject.projectDir.path + '/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}')\n\n// web pass one\nproject.ext.defaultModuleSourcePath_WebOne =\n    cygpath(rootProject.projectDir.path + '/modules/*/src/main/java')\n\n// Compiling the test shim files too.\nproject.ext.defaultModuleSourcePathShim =\n    cygpath(rootProject.projectDir.path + '/modules/*/src/{main,shims}/java') +\n        File.pathSeparator  +\n    cygpath(rootProject.projectDir.path + '/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}')\n\n// The \"base\" project is our first module and the most basic one required for\n// all other modules. It is useful even for non-GUI applications.\nproject(\":base\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.base\"\n\n// TODO: the following is an example of enabling module-specific lint opts\n//    project.ext.extraLintOptions =\n//        \"deprecation\" + \",\" +\n//        \"divzero\"\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    dependencies {\n        testImplementation sourceSets.main.output\n        testImplementation sourceSets.shims.output\n    }\n\n    commonModuleSetup(project, [ 'base' ])\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    // We need to take the VersionInfo.java file and replace the various\n    // properties within it\n    def replacements = [\n        \"BUILD_TIMESTAMP\": BUILD_TIMESTAMP,\n        \"HUDSON_JOB_NAME\": HUDSON_JOB_NAME,\n        \"HUDSON_BUILD_NUMBER\": HUDSON_BUILD_NUMBER,\n        \"RELEASE_SUFFIX\": RELEASE_SUFFIX,\n        \"RELEASE_VERSION_SHORT\": RELEASE_VERSION_SHORT,\n        \"RELEASE_VERSION_LONG\": RELEASE_VERSION_LONG];\n    task processVersionInfo(type: Copy, description: \"Replace params in VersionInfo and copy file to destination\") {\n        doFirst { mkdir \"$buildDir/gensrc/java\" }\n        from \"src/main/version-info\"\n        into \"$buildDir/gensrc/java/com/sun/javafx/runtime\"\n        filter {line->\n            replacements.each() {k, v ->\n                line = line.replace(\"@$k@\", v.toString());\n            }\n            line\n        }\n    }\n\n    // Make sure to include $buildDir/gensrc/java that we previously created.\n    // We DO NOT want to include src/main/version-info\n\n    sourceSets.main.java.srcDirs += \"$buildDir/gensrc/java\"\n\n    compileJava.dependsOn processVersionInfo\n    addMavenPublication(project, [])\n\n    addValidateSourceSets(project, sourceSets)\n\n    test {\n        if (IS_TEST_SDK) {\n            logger.info \"Skipping VersionInfoTest when TEST_SDK_PATH is set.\"\n            exclude(\"test/com/sun/javafx/runtime/VersionInfoTest*\");\n        }\n    }\n}\n\n// The graphics module is needed for any graphical JavaFX application. It requires\n// the base module and includes the scene graph, layout, css, prism, windowing, etc.\n// This is a fairly complicated module. There are many different types of native components\n// that all need to be compiled.\nproject(\":graphics\") {\n\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.graphics\"\n\n    // FIXME: Remove this setting when JDK-8334137 is fixed\n    // Disable javac -Werror until we stop using sun.misc.Unsafe\n    project.ext.disableJavacWerror = true\n\n    getConfigurations().create(\"antlr\");\n\n    sourceSets {\n        jslc   // JSLC gramar subset\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        shaders // generated shaders (prism & decora)\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n        stub\n    }\n\n    dependencies {\n        antlr group: \"org.antlr\", name: \"antlr4\", version: \"${antlr4Version}\", classifier: \"complete\"\n        testImplementation project(\":base\").sourceSets.test.output\n        implementation project(':base')\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics' ])\n\n    List<String> decoraAddExports = [\n            '--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED',\n            '--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED',\n            '--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED'\n            ]\n    /*\n    Graphics compilation is \"complicated\" by the generated shaders.\n\n    We have two shader groups - Decora and Prism.\n\n    The shader groups each will generate a custom compiler that\n    then genarates the shader code. These compilers rely on the JSLC\n    gramar parser which is antlr generated and compile separately.\n\n    The decora compiler relies on compileJava - which is sourceSet.main.java\n    It also accesses module private packages, so will need add-exports\n\n    Once the shader java code is generated, we can compileFullJava\n\n    After that, we can generate the required native header and then build the native code\n    */\n\n    project.task(\"processShaders\") {\n        // an empty task to hang the prism and decora shaders on\n    }\n\n    project.task(\"processShimsShaders\") {\n        // an empty task to hang the prism and decora shaders on\n    }\n\n    compileShimsJava.dependsOn(\"processShimsShaders\")\n\n    // Generate the JSLC support grammar\n    project.task(\"generateGrammarSource\", type: JavaExec) {\n        // use antlr to generate our grammar.\n        // note: the antlr plugin creates some issues with the other compiles\n        // so we will do this by hand\n\n        File wd = file(project.projectDir.path + \"/src/jslc/antlr\")\n        File outDir = file(\"$buildDir/gensrc/antlr\")\n        def inJSL = \"com/sun/scenario/effect/compiler/JSL.g4\"\n        if (IS_WINDOWS) {\n            // antlr needs backslashes on Windows\n            inJSL = inJSL.replace(\"/\", \"\\\\\")\n        }\n\n        executable = JAVA\n        classpath = project.configurations.antlr\n        workingDir = wd\n        mainClass = \"org.antlr.v4.Tool\"\n\n        args = [\n            \"-o\",\n            outDir.toString(),\n            \"-package\",\n            \"com.sun.scenario.effect.compiler\",\n            \"-visitor\",\n            inJSL ]\n\n        inputs.dir wd\n        outputs.dir outDir\n    }\n    sourceSets.jslc.java.srcDirs += \"$buildDir/gensrc/antlr\"\n\n    // and compile the JSLC support classes\n    compileJslcJava.dependsOn(generateGrammarSource)\n    compileJslcJava.classpath = project.configurations.antlr\n\n    compileJava.dependsOn(compileJslcJava)\n\n    // this task is the \"second pass\" compile of all of the module classes\n    project.task(\"compileFullJava\", type: JavaCompile, dependsOn: processShaders) {\n        description = \"Compile all of the graphics java classes - main and shaders\"\n\n        classpath = configurations.compileClasspath\n\n        source = project.sourceSets.main.java.srcDirs\n        source += \"$buildDir/gensrc/java\"\n        source += project.sourceSets.shaders.output\n\n        destinationDirectory = project.sourceSets.main.java.destinationDirectory\n        options.compilerArgs.addAll([\n            '-h', \"$buildDir/gensrc/headers/\",  // Note: this creates the native headers\n            '-implicit:none',\n            '--module-version', \"$RELEASE_VERSION_SHORT\",\n            '--module-source-path', defaultModuleSourcePath\n            ] )\n    }\n    classes.dependsOn(compileFullJava)\n\n    project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output\n    project.sourceSets.shims.java.srcDirs += \"$buildDir/gensrc/jsl-prism\"\n    project.sourceSets.shims.java.srcDirs += \"$buildDir/gensrc/jsl-decora\"\n\n    compileShimsJava.dependsOn(compileFullJava)\n\n    // Create a single \"native\" task which will depend on all the individual native tasks for graphics\n    project.ext.nativeAllTask = task(\"native\", group: \"Build\", description: \"Compiles and Builds all native libraries for Graphics\");\n    project.ext.cleanNativeAllTask = task(\"cleanNative\", group: \"Build\", description: \"Clean all native libraries and objects for Graphics\");\n\n    // Add tasks for native compilation\n    addNative(project, \"glass\");\n    addNative(project, \"prism\")\n    addNative(project, \"prismSW\")\n    addNative(project, \"font\")\n    addNative(project, \"iio\")\n    if (IS_INCLUDE_ES2) {\n        addNative(project, \"prismES2\")\n    }\n\n    if (IS_COMPILE_PANGO) {\n        addNative(project, \"fontFreetype\")\n        addNative(project, \"fontPango\")\n    }\n\n    if (IS_WINDOWS) {\n        addNative(project, \"prismD3D\")\n        // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed\n        task generateD3DHeaders(group: \"Build\") {\n            enabled = IS_WINDOWS\n            inputs.file \"src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl\"\n            inputs.file \"src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl\"\n            inputs.file \"src/main/native-prism-d3d/PassThroughVS.hlsl\"\n            outputs.dir \"$buildDir/headers/PrismD3D/\"\n            outputs.dir \"$buildDir/headers/PrismD3D/hlsl/\"\n            description = \"Generate headers by compiling hlsl files\"\n            doLast {\n                mkdir file(\"$buildDir/headers/PrismD3D/hlsl\")\n                def PS_3D_SRC = file(\"src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl\")\n                def VS_3D_SRC = file(\"src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl\")\n                def PASSTHROUGH_VS_SRC = file(\"src/main/native-prism-d3d/PassThroughVS.hlsl\")\n                def jobs = [\n                        [\"$FXC\", \"/nologo\", \"/T\", \"vs_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/PassThroughVS.h\", \"/E\", \"passThrough\", \"$PASSTHROUGH_VS_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h\", \"/DSpec=0\", \"/DSType=0\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h\", \"/DSpec=0\", \"/DSType=0\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h\", \"/DSpec=1\", \"/DSType=0\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h\", \"/DSpec=2\", \"/DSType=0\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h\", \"/DSpec=3\", \"/DSType=0\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h\", \"/DSpec=1\", \"/DSType=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h\", \"/DSpec=2\", \"/DSType=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h\", \"/DSpec=3\", \"/DSType=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h\", \"/DSpec=1\", \"/DSType=2\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h\", \"/DSpec=2\", \"/DSType=2\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h\", \"/DSpec=3\", \"/DSType=2\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h\", \"/DSpec=1\", \"/DSType=3\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h\", \"/DSpec=2\", \"/DSType=3\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h\", \"/DSpec=3\", \"/DSType=3\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h\", \"/DSpec=1\", \"/DSType=0\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h\", \"/DSpec=2\", \"/DSType=0\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h\", \"/DSpec=3\", \"/DSType=0\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h\", \"/DSpec=1\", \"/DSType=1\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h\", \"/DSpec=2\", \"/DSType=1\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h\", \"/DSpec=3\", \"/DSType=1\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h\", \"/DSpec=1\", \"/DSType=2\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h\", \"/DSpec=2\", \"/DSType=2\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h\", \"/DSpec=3\", \"/DSType=2\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h\", \"/DSpec=1\", \"/DSType=3\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h\", \"/DSpec=2\", \"/DSType=3\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h\", \"/DSpec=3\", \"/DSType=3\", \"/DBump=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h\", \"/DSpec=1\", \"/DSType=0\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h\", \"/DSpec=2\", \"/DSType=0\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h\", \"/DSpec=3\", \"/DSType=0\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h\", \"/DSpec=1\", \"/DSType=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h\", \"/DSpec=2\", \"/DSType=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h\", \"/DSpec=3\", \"/DSType=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h\", \"/DSpec=1\", \"/DSType=2\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h\", \"/DSpec=2\", \"/DSType=2\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h\", \"/DSpec=3\", \"/DSType=2\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h\", \"/DSpec=1\", \"/DSType=3\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h\", \"/DSpec=2\", \"/DSType=3\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h\", \"/DSpec=3\", \"/DSType=3\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h\", \"/DSpec=1\", \"/DSType=0\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h\", \"/DSpec=2\", \"/DSType=0\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h\", \"/DSpec=3\", \"/DSType=0\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h\", \"/DSpec=1\", \"/DSType=1\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h\", \"/DSpec=2\", \"/DSType=1\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h\", \"/DSpec=3\", \"/DSType=1\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h\", \"/DSpec=1\", \"/DSType=2\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h\", \"/DSpec=2\", \"/DSType=2\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h\", \"/DSpec=3\", \"/DSType=2\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h\", \"/DSpec=1\", \"/DSType=3\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h\", \"/DSpec=2\", \"/DSType=3\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"ps_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h\", \"/DSpec=3\", \"/DSType=3\", \"/DBump=1\", \"/DIllumMap=1\", \"$PS_3D_SRC\"],\n                        [\"$FXC\", \"/nologo\", \"/T\", \"vs_3_0\", \"/Fh\", \"$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h\", \"/DVertexType=VsInput\", \"$VS_3D_SRC\"]\n                ]\n                final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));\n                final CountDownLatch latch = new CountDownLatch(jobs.size());\n                List futures = new ArrayList<Future>();\n                jobs.each { cmd ->\n                    futures.add(executor.submit(new Runnable() {\n                        @Override public void run() {\n                            try {\n                                exec {\n                                    commandLine cmd\n                                }\n                            } finally {\n                                latch.countDown();\n                            }\n                        }\n                    }));\n                }\n                latch.await();\n                // Looking for whether an exception occurred while executing any of the futures.\n                // By calling \"get()\" on each future an exception will be thrown if one had occurred\n                // on the background thread.\n                futures.each {it.get();}\n            }\n        }\n\n        ccWinPrismD3D.dependsOn generateD3DHeaders\n    }\n\n    // The Decora and Prism JSL files have to be generated in a very specific set of steps.\n    //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be\n    //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).\n    //      2) Generate source files from the JSL files contained in src/main/jsl-*. These\n    //         will be output to $buildDir/gensrc/jsl-*\n    //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output\n    //         into classes/jsl-*\n    //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj\n    //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib\n    //      5) Modify the jar step to include classes/jsl-*\n    // The native library must be copied over during SDK creation time in the \"sdk\" task. In\n    // addition to these steps, the clean task is created. Note that I didn't bother to create\n    // a new task for each of the decora files, preferring instead just to create a rule?? Also\n    // need \"clean\" tasks for each compile task.\n\n    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n    addJSL(project, \"Decora\", \"com/sun/scenario/effect/impl/hw/d3d/hlsl\", decoraAddExports) { sourceDir, destinationDir ->\n        [[fileName: \"ColorAdjust\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"Brightpass\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"SepiaTone\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"PerspectiveTransform\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"DisplacementMap\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"InvertMask\", generator: \"CompileJSL\", outputs: \"-all\"],\n         [fileName: \"Blend\", generator: \"CompileBlend\", outputs: \"-all\"],\n         [fileName: \"PhongLighting\", generator: \"CompilePhong\", outputs: \"-all\"],\n         [fileName: \"LinearConvolve\", generator: \"CompileLinearConvolve\", outputs: \"-hw\"],\n         [fileName: \"LinearConvolveShadow\", generator: \"CompileLinearConvolve\", outputs: \"-hw\"]].each { settings ->\n            javaexec {\n                executable = JAVA\n                workingDir = project.projectDir\n                mainClass = settings.generator\n                classpath = configurations.compileClasspath + configurations.antlr\n                classpath += files(project.sourceSets.jslc.java.getDestinationDirectory().get().getAsFile())\n\n                classpath += files(\"${project.projectDir}/src/jslc/resources\")\n\n                classpath += files(\"$buildDir/classes/jsl-compilers/decora\")\n                jvmArgs += \"--module-path=$modulePath\"\n                jvmArgs += \"--add-modules=javafx.graphics\"\n                jvmArgs += decoraAddExports\n                args += [\"-i\", sourceDir, \"-o\", destinationDir, \"-t\", \"-pkg\", \"com/sun/scenario/effect\", \"$settings.outputs\", \"$settings.fileName\"]\n            }\n        }\n    }\n\n\n    task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: \"Build\") {\n        description = \"Generates JNI headers, compiles, and builds native dynamic library for Decora\"\n    }\n    task cleanNativeDecora(type: Delete, group: \"Build\") {\n        description = \"Clean native objects for Decora\"\n    }\n\n    def headerDir = file(\"$buildDir/gensrc/headers/javafx.graphics\")\n    def nativeRootDir = project.file(\"$project.buildDir/native/jsl-decora\")\n    def libRootDir = project.file(\"$project.buildDir/libs/jsl-decora\")\n    // For each compile target, create cc and link tasks\n    compileTargets { t ->\n        def target = t.name\n        def upperTarget = t.upper\n        def capitalTarget = t.capital\n        def targetProperties = rootProject.ext[upperTarget];\n        def library = targetProperties.library\n        def properties = targetProperties.get('decora')\n        def nativeDir = file(\"$nativeRootDir/$target\");\n\n        def variants = properties.containsKey(\"variants\") ? properties.variants : [\"\"];\n        variants.each { variant ->\n            def variantProperties = variant == \"\" ? properties : properties.get(variant)\n            def capitalVariant = variant.capitalize()\n            def ccOutput = variant == \"\" ? nativeDir : file(\"$nativeDir/$variant\")\n\n            def ccTask = task(\"compileDecoraNativeShaders$capitalTarget$capitalVariant\", type: CCTask, dependsOn: generateDecoraShaders) {\n                description = \"Compiles Decora SSE natives for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}\"\n                matches = \".*\\\\.cc\"\n                source file(\"$buildDir/gensrc/jsl-decora\")\n                source file(project.projectDir.path + \"/src/main/native-decora\")\n                headers = headerDir\n                params.addAll(variantProperties.ccFlags)\n                output(ccOutput)\n                compiler = variantProperties.compiler\n                cleanNativeDecora.delete ccOutput\n            }\n\n            def linkTask = task(\"linkDecoraNativeShaders$capitalTarget$capitalVariant\", type: LinkTask, dependsOn: ccTask) {\n                description = \"Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}\"\n                objectDir = ccOutput\n                linkParams.addAll(variantProperties.linkFlags)\n                lib = file(\"$libRootDir/$t.name/${library(variantProperties.lib)}\")\n                linker = variantProperties.linker\n                cleanNativeDecora.delete \"$libRootDir/$t.name/\"\n            }\n\n            if (IS_WINDOWS && target == \"win\") {\n                def rcTask = project.task(\"rcDecoraNativeShaders$capitalTarget$capitalVariant\", type: CompileResourceTask) {\n                    description = \"Compiles native sources for Decora SSE\"\n                    matches = \".*\\\\.rc\"\n                    compiler = variantProperties.rcCompiler\n                    source(variantProperties.rcSource)\n                    if (variantProperties.rcFlags) {\n                        rcParams.addAll(variantProperties.rcFlags)\n                    }\n                    output(ccOutput)\n                }\n                linkTask.dependsOn rcTask;\n            }\n\n            nativeDecora.dependsOn(linkTask)\n        }\n    }\n\n    // Prism JSL\n    addJSL(project, \"Prism\", \"com/sun/prism/d3d/hlsl\", null) { sourceDir, destinationDir ->\n        def inputFiles = fileTree(dir: sourceDir)\n        inputFiles.include \"**/*.jsl\"\n        inputFiles.each { file ->\n            javaexec {\n                executable = JAVA\n                workingDir = project.projectDir\n                mainClass = \"CompileJSL\"\n                classpath = configurations.compileClasspath + configurations.antlr\n                classpath += files(project.sourceSets.jslc.java.getDestinationDirectory().get().getAsFile())\n                classpath += files(project.sourceSets.jslc.resources)\n                classpath += files(\"$buildDir/classes/jsl-compilers/prism\",\n                    project.projectDir.path + \"/src/main/jsl-prism\") // for the .stg\n                args = [\"-i\", sourceDir, \"-o\", destinationDir, \"-t\", \"-pkg\", \"com/sun/prism\", \"-d3d\", \"-es2\", \"-name\", \"$file\"]\n            }\n        }\n    }\n\n    task initShaderDirs() {\n        doLast {\n            // Create empty hlsl dirs on all platforms for IDE support\n            file(\"$project.buildDir/hlsl/Decora\").mkdirs()\n            file(\"$project.buildDir/hlsl/Prism\").mkdirs()\n            file(\"$project.buildDir/gensrc/jsl-prism\").mkdirs()\n            file(\"$project.buildDir/gensrc/jsl-decora\").mkdirs()\n        }\n    }\n    project.processShaders.dependsOn(initShaderDirs)\n\n    nativePrism.dependsOn compilePrismHLSLShaders;\n\n    project.nativeAllTask.dependsOn nativeDecora\n    project.cleanNativeAllTask.dependsOn cleanNativeDecora\n    assemble.dependsOn nativeDecora\n    processResources.dependsOn processDecoraShaders, processPrismShaders\n\n    test {\n        def cssDir = file(\"${TEST_SDK_PATH}/shims/${moduleName}/javafx\")\n        jvmArgs enableNativeGraphics\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\",\n            \"-DCSS_META_DATA_TEST_DIR=$cssDir\"\n        enableAssertions = true\n        testLogging.exceptionFormat = \"full\"\n        scanForTestClasses = true\n        include \"**/*.*\"\n        if (BUILD_CLOSED && DO_JCOV) {\n            addJCov(project, test)\n        }\n    }\n\n    // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries\n    // available in some known location. Maybe in the future the Gradle plugins to each\n    // of the IDEs will be good enough that we won't need this hack anymore.\n    classes {\n        doLast {\n            // Copy all of the download libraries to the libs directory for the sake of the IDEs\n            File libsDir = rootProject.file(\"build/libs\");\n\n            // In some IDEs (Eclipse for example), touching these libraries\n            // cauese a full build within the IDE. When gradle is used\n            // outside of the IDE, for example to build the native code,\n            // a full rebuild is caused within the IDE. The fix is to check\n            // for the presence of the target files in the lib directory\n            // and not copy the files if all are present.\n\n            libsDir.mkdirs();\n\n            def allLibsPresent = true\n            def libNames = [ \"antlr4-${antlr4Version}-complete.jar\" ]\n            libNames.each { name ->\n                File f = new File(libsDir, name)\n                if (!f.exists()) allLibsPresent = false\n            }\n            if (allLibsPresent) return;\n\n            for (File f : [configurations.compileClasspath.files, configurations.antlr.files].flatten()) {\n                copy {\n                    into libsDir\n                    from f.getParentFile()\n                    include \"**/antlr4-${antlr4Version}-complete.jar\"\n                    includeEmptyDirs = false\n                }\n            }\n        }\n    }\n\n    addMavenPublication(project, [ 'base' ])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":controls\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.controls\"\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics', 'controls' ])\n\n    dependencies {\n        testImplementation project(\":graphics\").sourceSets.test.output\n        testImplementation project(\":base\").sourceSets.test.output\n        implementation project(':base')\n        implementation project(':graphics')\n    }\n\n    test {\n        def cssDir = file(\"${TEST_SDK_PATH}/shims/${moduleName}/javafx\")\n        jvmArgs enableNativeGraphics\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\",\n            \"-DCSS_META_DATA_TEST_DIR=$cssDir\"\n    }\n\n    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n    processResources {\n      doLast {\n        def cssFiles = fileTree(dir: \"$moduleDir/com/sun/javafx/scene/control/skin\")\n        cssFiles.include \"**/*.css\"\n        cssFiles.each { css ->\n            logger.info(\"converting CSS to BSS ${css}\");\n\n            javaexec {\n                executable = JAVA\n                workingDir = project.projectDir\n                jvmArgs += patchModuleArgs\n                jvmArgs += \"--module-path=$modulePath\"\n                jvmArgs += \"--add-modules=javafx.graphics\"\n                mainClass = \"com.sun.javafx.css.parser.Css2Bin\"\n                args css\n            }\n        }\n      }\n    }\n\n    def copyShimBssTask = project.task(\"copyShimBss\", type: Copy,\n                            dependsOn: [project.tasks.getByName(\"compileJava\"),\n                                        project.tasks.getByName(\"processResources\")]) {\n        from project.moduleDir\n        into project.moduleShimsDir\n        include \"**/*.bss\"\n    }\n    processShimsResources.dependsOn(copyShimBssTask)\n\n    addMavenPublication(project, [ 'graphics' ])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\n// Add a project declaration for each incubator module here, leaving the\n// incubator placeholder lines as an example.\n// See CSR JDK-8344644 for more information.\n// BEGIN: incubator placeholder\n//project(\":incubator.mymod\") {\n//    project.ext.buildModule = true\n//    project.ext.includeSources = true\n//    project.ext.moduleRuntime = true\n//    project.ext.moduleName = \"jfx.incubator.mymod\"\n//    project.ext.incubating = true\n//    ...\n//}\n// END: incubator placeholder\n\nproject(\":incubator.input\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"jfx.incubator.input\"\n    project.ext.incubating = true\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [\n        'base',\n        'graphics',\n        'controls',\n        'incubator.input'\n    ])\n\n    dependencies {\n        testImplementation project(\":base\").sourceSets.test.output\n        testImplementation project(\":graphics\").sourceSets.test.output\n        testImplementation project(\":controls\").sourceSets.test.output\n        implementation project(':base')\n        implementation project(':graphics')\n        implementation project(':controls')\n    }\n\n    test {\n        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\"\n    }\n\n    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.controls/build/classes/java/main\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n\n    addMavenPublication(project, [ 'graphics' , 'controls'])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":incubator.richtext\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"jfx.incubator.richtext\"\n    project.ext.incubating = true\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [\n        'base',\n        'graphics',\n        'controls',\n        'incubator.input',\n        'incubator.richtext'\n    ])\n\n    dependencies {\n        testImplementation project(\":base\").sourceSets.test.output\n        testImplementation project(\":graphics\").sourceSets.test.output\n        testImplementation project(\":controls\").sourceSets.test.output\n        testImplementation project(\":incubator.input\").sourceSets.test.output\n        implementation project(':base')\n        implementation project(':graphics')\n        implementation project(':controls')\n        implementation project(':incubator.input')\n    }\n\n    test {\n        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\"\n    }\n\n    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.controls/build/classes/java/main\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main\"\n    modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n\n    addMavenPublication(project, [ 'graphics' , 'controls'])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":swing\") {\n\n    // We need to skip setting compiler.options.release for this module,\n    // since javafx.swing requires jdk.unsupported.desktop, which is\n    // excluded by \"--release NN\". This will fall back to using\n    // \"-source NN -target NN\" for this module.\n    project.ext.skipJavaCompilerOptionRelease = true\n\n    // We also need to disable the implicitly-enabled lint warning that\n    // results from the above\n    project.ext.extraLintOptions =\n        \"-options\"\n\n    tasks.all {\n        if (!COMPILE_SWING) it.enabled = false\n    }\n\n    project.ext.buildModule = COMPILE_SWING\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.swing\"\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics', 'swing' ])\n\n    dependencies {\n        implementation project(\":base\")\n        implementation project(\":graphics\")\n    }\n\n    test {\n        enabled = IS_FULL_TEST && IS_AWT_TEST\n\n        jvmArgs enableNativeGraphics\n\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n    }\n\n    if (COMPILE_SWING) {\n        addMavenPublication(project, [ 'graphics' ])\n    }\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":swt\") {\n    tasks.all {\n        if (!COMPILE_SWT) it.enabled = false\n    }\n\n    // javafx.swt is an automatic module\n    project.ext.buildModule = false\n\n    commonModuleSetup(project, [ 'base', 'graphics' ])\n\n    dependencies {\n        implementation name: SWT_FILE_NAME\n    }\n\n    classes {\n        doLast {\n            // Copy all of the download libraries to libs directory for the sake of the IDEs\n            File libsDir = rootProject.file(\"build/libs\");\n            File swtLib = new File(libsDir, \"swt-debug.jar\")\n            libsDir.mkdirs();\n\n            // Skip copy if file is present.\n            if (swtLib.exists()) return;\n\n            for (File f : configurations.compileClasspath.files) {\n                // Have to rename the swt jar because it is some platform specific name but\n                // for the sake of the IDEs we need to have a single stable name that works\n                // on every platform\n                copy {\n                    into libsDir\n                    from f.getParentFile()\n                    include \"**/*swt*.jar\"\n                    includeEmptyDirs = false\n                    rename \".*swt.*jar\", \"swt-debug\\\\.jar\"\n                }\n            }\n        }\n    }\n\n    compileJava.options.compilerArgs.addAll([\n            \"--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED\",\n            \"--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED\",\n            \"--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED\",\n            \"--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED\",\n            \"--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED\",\n            ])\n\n    compileTestJava {\n        if (IS_TEST_SDK) enabled = false\n    }\n\n    test {\n        //enabled = IS_FULL_TEST && IS_SWT_TEST\n        enabled = false // FIXME: JIGSAW -- support this with modules\n        logger.info(\"JIGSAW Testing disabled for swt\")\n\n        jvmArgs enableNativeGraphics\n\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n\n        if (IS_MAC) {\n            enabled = false\n            logger.info(\"SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).\")\n        }\n    }\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":fxml\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.fxml\"\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics', 'controls', 'fxml' ])\n\n\n    dependencies {\n        testImplementation project(\":graphics\").sourceSets.test.output\n        testImplementation project(\":base\").sourceSets.test.output\n        implementation project(\":base\")\n        implementation project(\":graphics\")\n    }\n\n    test {\n        // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance\n        // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,\n        // we have to use the stub toolkit for now.\n        jvmArgs enableNativeGraphics\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\"\n        // FIXME: change this to also allow JDK 9 boot jdk\n        classpath += files(\"$JDK_HOME/jre/lib/ext/nashorn.jar\")\n    }\n\n    addMavenPublication(project, [ 'controls' ])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":media\") {\n    configurations {\n        media\n    }\n\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.media\"\n\n    sourceSets {\n        main\n        //shims // no test shims needed\n        test\n        tools {\n            java.srcDir \"src/tools/java\"\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics', 'media' ])\n\n    dependencies {\n        if (IS_BUILD_LIBAV_STUBS) {\n            media name: \"v9.14\", ext: \"tar.gz\"\n            media name: \"v11.4\", ext: \"tar.gz\"\n            media name: \"v12.1\", ext: \"tar.gz\"\n            media name: \"ffmpeg-3.3.3\", ext: \"tar.gz\"\n            media name: \"ffmpeg-4.0.2\", ext: \"tar.gz\"\n            media name: \"ffmpeg-5.1.2\", ext: \"tar.gz\"\n            media name: \"ffmpeg-6.0\", ext: \"tar.gz\"\n            media name: \"ffmpeg-7.0.2\", ext: \"tar.gz\"\n        }\n        implementation project(\":base\")\n        implementation project(\":graphics\")\n    }\n\n    compileJava.dependsOn updateCacheIfNeeded\n\n    compileJava {\n        // generate the native headers during compile\n        options.compilerArgs.addAll([\n            '-h', \"${project.buildDir}/gensrc/headers\"\n            ])\n    }\n\n    compileToolsJava {\n        enabled = IS_COMPILE_MEDIA\n        def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n        options.compilerArgs.addAll([\n            \"--module-path=$modulePath\",\n            \"--add-modules=javafx.media\",\n            '--add-exports', 'javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED',\n            ])\n    }\n\n    project.ext.makeJobsFlag = IS_WINDOWS && IS_DEBUG_NATIVE ? \"-j1\" : \"-j5\";\n    project.ext.buildType = IS_DEBUG_NATIVE ? \"Debug\" : \"Release\";\n\n    def nativeSrcDir = file(\"${projectDir}/src/main/native\")\n    def generatedHeadersDir = file(\"${buildDir}/gensrc/headers/${project.moduleName}\")\n\n    task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {\n        enabled = IS_COMPILE_MEDIA\n        def headerpath = file(\"$generatedHeadersDir/jfxmedia_errors.h\");\n        doLast {\n            def classpath = files(sourceSets.tools.output);\n            def sourcepath = sourceSets.main.java.srcDirs;\n            def srcRoot = (sourcepath.toArray())[0];\n\n            mkdir generatedHeadersDir;\n\n            def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n            modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main\"\n            modulePath += File.pathSeparator + \"${rootProject.projectDir}/modules/javafx.base/build/classes/java/main\"\n\n            exec {\n                commandLine(\"$JAVA\");\n                args += patchModuleArgs\n                args += [ \"--module-path=$modulePath\" ]\n                args += [ \"--add-modules=javafx.media\" ]\n                args +=  [ '--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED' ]\n                args +=  [ '-classpath', \"${classpath.asPath}\" ]\n                args += [ \"headergen.HeaderGen\", \"$headerpath\", \"$srcRoot\" ]\n            }\n        }\n        outputs.file(project.file(\"$headerpath\"))\n    }\n\n    task buildNativeTargets {\n        enabled = IS_COMPILE_MEDIA\n    }\n\n    compileTargets { t->\n        def targetProperties = project.rootProject.ext[t.upper]\n        def nativeOutputDir = file(\"${buildDir}/native/${t.name}\")\n        def projectDir = t.name.startsWith(\"arm\") ? \"linux\" : t.name\n        def mediaProperties = targetProperties.media\n        // Makefile for OSX needs to know if we're building for parfait\n        def compileParfait = IS_COMPILE_PARFAIT ? \"true\" : \"false\"\n\n        def buildNative = task(\"build${t.capital}Native\", dependsOn: [generateMediaErrorHeader]) {\n            enabled = targetProperties.compileMediaNative\n            if (!targetProperties.compileMediaNative) {\n                println(\"Not compiling native Media for ${t.name} per configuration request\");\n            }\n\n            doLast {\n                exec {\n                    commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/jfxmedia/projects/${projectDir}\")\n                    args(\"JAVA_HOME=${JDK_HOME}\", \"GENERATED_HEADERS_DIR=${generatedHeadersDir}\",\n                         \"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=jfxmedia\",\n                         \"COMPILE_PARFAIT=${compileParfait}\",\n                         \"ARCH=${ARCH_NAME}\",\n                        \"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\")\n\n                    if (t.name == \"win\") {\n                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                        args( \"RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}\")\n                    } else {\n                        if (t.name.startsWith(\"arm\")) {\n                            args(\"EXTRA_CFLAGS=${mediaProperties.extra_cflags}\", \"EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}\")\n                        } else {\n                            args(\"HOST_COMPILE=1\")\n                        }\n                    }\n                }\n            }\n        }\n\n        // check for the property disable${name} = true\n        def boolean disabled = targetProperties.containsKey('disableMedia') ? targetProperties.get('disableMedia') : false\n        if (!disabled) {\n            // Building GStreamer\n            def buildGStreamer = task(\"build${t.capital}GStreamer\") {\n                enabled = IS_COMPILE_MEDIA\n                doLast {\n                    exec {\n                        commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite\")\n                        args(\"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=gstreamer-lite\",\n                             \"ARCH=${ARCH_NAME}\", \"CC=${mediaProperties.compiler}\",\n                             \"AR=${mediaProperties.ar}\", \"LINKER=${mediaProperties.linker}\")\n\n                        if (t.name == \"win\") {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            args(\"RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}\")\n                        }\n                    }\n                }\n            }\n\n            def buildPlugins = task(\"build${t.capital}Plugins\", dependsOn: buildGStreamer) {\n                enabled = IS_COMPILE_MEDIA\n\n                doLast {\n                    exec {\n                        commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins\")\n                        args(\"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=fxplugins\",\n                             \"ARCH=${ARCH_NAME}\",\n                             \"CC=${mediaProperties.compiler}\", \"AR=${mediaProperties.ar}\", \"LINKER=${mediaProperties.linker}\")\n\n                        if (t.name == \"win\") {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            args(\"RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}\")\n                        }\n                    }\n                }\n            }\n\n            buildNative.dependsOn buildPlugins\n\n            if (t.name == \"linux\") {\n                // Pre-defined command line arguments\n                def cfgCMDArgs = [\"sh\", \"configure\"]\n                def commonCfgArgs = [\"--enable-shared\", \"--disable-debug\", \"--disable-static\", \"--disable-asm\", \"--disable-doc\", \"--disable-programs\", \"--disable-everything\"]\n                def codecsCfgArgs = [\"--enable-decoder=aac,mp3,mp3float,h264,hevc\", \"--enable-parser=aac,h264,hevc\", \"--enable-demuxer=aac,h264,hevc,mpegts,mpegtsraw\"]\n\n                def copyLibAVStubs = {String fromDir, String toDir ->\n                    FileCollection config = files(\"config.h\")\n                    FileCollection libavcodec = files(\"avcodec.h\", \"avfft.h\", \"dxva2.h\", \"vaapi.h\", \"vda.h\",\n                                                      \"vdpau.h\", \"version.h\", \"xvmc.h\", \"old_codec_ids.h\",\n                                                      \"codec.h\", \"codec_desc.h\", \"codec_par.h\", \"codec_id.h\",\n                                                      \"defs.h\", \"packet.h\", \"version_major.h\")\n                    FileCollection libavdevice = files(\"avdevice.h\", \"version.h\")\n                    FileCollection libavfilter = files(\"avfiltergraph.h\", \"avfilter.h\", \"buffersink.h\", \"buffersrc.h\", \"version.h\");\n                    FileCollection libavformat = files(\"avformat.h\", \"avio.h\", \"version.h\", \"version_major.h\")\n                    FileCollection libavresample = files(\"avresample.h\", \"version.h\")\n                    FileCollection libavutil = files(\"adler32.h\", \"blowfish.h\", \"error.h\", \"log.h\", \"pixfmt.h\",\n                                                     \"aes.h\", \"bswap.h\", \"eval.h\", \"lzo.h\", \"random_seed.h\",\n                                                     \"attributes.h\", \"buffer.h\", \"fifo.h\", \"macros.h\", \"rational.h\",\n                                                     \"audio_fifo.h\", \"channel_layout.h\", \"file.h\", \"mathematics.h\", \"samplefmt.h\",\n                                                     \"avassert.h\", \"common.h\", \"frame.h\", \"md5.h\", \"sha.h\",\n                                                     \"avconfig.h\", \"imgutils.h\", \"mem.h\", \"time.h\", \"avstring.h\",\n                                                     \"cpu_internal.h\", \"intfloat.h\", \"opt.h\", \"version.h\", \"avutil.h\",\n                                                     \"crc.h\", \"intreadwrite.h\", \"parseutils.h\", \"xtea.h\", \"base64.h\",\n                                                     \"dict.h\", \"lfg.h\", \"pixdesc.h\", \"intfloat_readwrite.h\", \"old_pix_fmts.h\", \"audioconvert.h\",\n                                                     \"cpu.h\", \"hwcontext.h\")\n                    FileCollection libavutil_x86 = files(\"cpu.h\") // Use cpu.h from x86 instead of libavutil root if exist\n                    FileCollection libswscale = files(\"swscale.h\", \"version.h\", \"version_major.h\")\n\n                    def copyLibAVFiles = {FileCollection files, String fDir, String tDir ->\n                        File dir = file(tDir)\n                        dir.mkdirs()\n\n                        files.each { File file ->\n                            copy {\n                                from fDir\n                                into tDir\n                                include file.name\n                            }\n                        }\n                    }\n\n                    copyLibAVFiles(config, fromDir, \"${toDir}/include\")\n                    copyLibAVFiles(libavcodec, \"${fromDir}/libavcodec\", \"${toDir}/include/libavcodec\")\n                    copyLibAVFiles(libavdevice, \"${fromDir}/libavdevice\", \"${toDir}/include/libavdevice\")\n                    copyLibAVFiles(libavfilter, \"${fromDir}/libavfilter\", \"${toDir}/include/libavfilter\")\n                    copyLibAVFiles(libavformat, \"${fromDir}/libavformat\", \"${toDir}/include/libavformat\")\n                    copyLibAVFiles(libavresample, \"${fromDir}/libavresample\", \"${toDir}/include/libavresample\")\n                    copyLibAVFiles(libavutil, \"${fromDir}/libavutil\", \"${toDir}/include/libavutil\")\n                    copyLibAVFiles(libavutil_x86, \"${fromDir}/libavutil/x86\", \"${toDir}/include/libavutil\")\n                    copyLibAVFiles(libswscale, \"${fromDir}/libswscale\", \"${toDir}/include/libswscale\")\n\n                    // Copy libs\n                    FileTree libs = fileTree(dir: \"${fromDir}\", include: \"**/*.so*\")\n                    libs.each {File file ->\n                        copy {\n                            from file\n                            into \"${toDir}/lib\"\n                        }\n                    }\n                }\n\n                def buildLibAVStubs = task(\"buildLibAVStubs\", dependsOn: []) {\n                    enabled = IS_BUILD_LIBAV_STUBS\n\n                    doLast {\n                        project.ext.libav = [:]\n                        project.ext.libav.basedir = \"${buildDir}/native/linux/libav\"\n                        project.ext.libav.versions = [ \"9.14\", \"11.4\", \"12.1\" ]\n                        project.ext.libav.versionmap = [ \"9.14\" : \"54\", \"11.4\" : \"56\", \"12.1\" : \"57\" ]\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/libav-${version}\"\n                            for (File f : configurations.media.files) {\n                                if (f.name.startsWith(\"v${version}\")) {\n                                    File dir = file(libavDir)\n                                    dir.mkdirs()\n                                    def libavTar = \"${libav.basedir}/libav-${version}.tar\"\n                                    ant.gunzip(src: f, dest: libavTar)\n                                    ant.untar(src: libavTar, dest: libav.basedir)\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/libav-${version}\"\n                            File dir = file(libavDir)\n                            if (dir.exists()) {\n                                def configFile = \"${libav.basedir}/libav-${version}/config.h\"\n                                File cfgFile = file(configFile)\n                                if (!cfgFile.exists()) {\n                                    // Add execute permissions to version.sh, otherwise build fails\n                                    exec {\n                                        workingDir(\"$libavDir\")\n                                        commandLine(\"chmod\", \"+x\", \"version.sh\")\n                                    }\n                                    exec {\n                                        workingDir(\"$libavDir\")\n                                        if (IS_BUILD_WORKING_LIBAV) {\n                                            commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)\n                                        } else {\n                                            commandLine(cfgCMDArgs + commonCfgArgs)\n                                        }\n                                    }\n                                }\n                                exec {\n                                    workingDir(\"$libavDir\")\n                                    commandLine(\"make\")\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def fromDir = \"${libav.basedir}/libav-${version}\"\n                            def majorVersion = libav.versionmap[version]\n                            def toDir = \"${libav.basedir}/libav-${majorVersion}\"\n                            copyLibAVStubs(fromDir, toDir)\n                        }\n                    }\n                }\n\n                def buildLibAVFFmpegStubs = task(\"buildLibAVFFmpegStubs\", dependsOn: []) {\n                    enabled = IS_BUILD_LIBAV_STUBS\n\n                    def extraCfgArgs = [\"--build-suffix=-ffmpeg\"]\n\n                    doLast {\n                        project.ext.libav = [:]\n                        project.ext.libav.basedir = \"${buildDir}/native/linux/libavffmpeg\"\n                        project.ext.libav.versions = [ \"11.4\" ]\n                        project.ext.libav.versionmap = [ \"11.4\" : \"56\" ]\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/libav-${version}\"\n                            for (File f : configurations.media.files) {\n                                if (f.name.startsWith(\"v${version}\")) {\n                                    File dir = file(libavDir)\n                                    dir.mkdirs()\n                                    def libavTar = \"${libav.basedir}/libav-${version}.tar\"\n                                    ant.gunzip(src: f, dest: libavTar)\n                                    ant.untar(src: libavTar, dest: libav.basedir)\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/libav-${version}\"\n                            File dir = file(libavDir)\n                            if (dir.exists()) {\n                                def configFile = \"${libav.basedir}/libav-${version}/config.h\"\n                                File cfgFile = file(configFile)\n                                if (!cfgFile.exists()) {\n                                    // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded\n                                    FileTree vfiles = fileTree(dir: \"${libavDir}\", include: \"**/*.v\")\n                                    vfiles.each {File file ->\n                                        String data = file.getText(\"UTF-8\")\n                                        data = data.replace(\"_\\$MAJOR\", \"_FFMPEG_\\$MAJOR\")\n                                        file.write(data, \"UTF-8\")\n                                    }\n                                    // Add execute permissions to version.sh, otherwise build fails\n                                    exec {\n                                        workingDir(\"$libavDir\")\n                                        commandLine(\"chmod\", \"+x\", \"version.sh\")\n                                    }\n                                    exec {\n                                        workingDir(\"$libavDir\")\n                                        if (IS_BUILD_WORKING_LIBAV) {\n                                            commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)\n                                        } else {\n                                            commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)\n                                        }\n                                    }\n                                }\n                                exec {\n                                    workingDir(\"$libavDir\")\n                                    commandLine(\"make\")\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def fromDir = \"${libav.basedir}/libav-${version}\"\n                            def majorVersion = libav.versionmap[version]\n                            def toDir = \"${libav.basedir}/libav-${majorVersion}\"\n                            copyLibAVStubs(fromDir, toDir)\n\n                            // Special case to copy *-ffmpeg.so to *.so\n                            FileTree libs = fileTree(dir: \"${fromDir}\", include: \"**/*-ffmpeg.so\")\n                            libs.each {File file ->\n                                copy {\n                                    from file\n                                    into \"${toDir}/lib\"\n                                    rename { String fileName ->\n                                        fileName.replace(\"-ffmpeg\", \"\")\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                def buildFFmpegStubs = task(\"buildFFmpegStubs\", dependsOn: []) {\n                    enabled = IS_BUILD_LIBAV_STUBS\n\n                    doLast {\n                        project.ext.libav = [:]\n                        project.ext.libav.basedir = \"${buildDir}/native/linux/ffmpeg\"\n                        project.ext.libav.versions = [ \"3.3.3\", \"4.0.2\", \"5.1.2\", \"6.0\", \"7.0.2\" ]\n                        project.ext.libav.versionmap = [ \"3.3.3\" : \"57\", \"4.0.2\" : \"58\", \"5.1.2\" : \"59\", \"6.0\" : \"60\", \"7.0.2\" : \"61\" ]\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/ffmpeg-${version}\"\n                            for (File f : configurations.media.files) {\n                                if (f.name.startsWith(\"ffmpeg-${version}\")) {\n                                    File dir = file(libavDir)\n                                    dir.mkdirs()\n                                    def libavTar = \"${libav.basedir}/ffmpeg-${version}.tar\"\n                                    ant.gunzip(src: f, dest: libavTar)\n                                    ant.untar(src: libavTar, dest: libav.basedir)\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def libavDir = \"${libav.basedir}/ffmpeg-${version}\"\n                            File dir = file(libavDir)\n                            if (dir.exists()) {\n                                def configFile = \"${libavDir}/config.h\"\n                                File cfgFile = file(configFile)\n                                if (!cfgFile.exists()) {\n                                    // Add execute permissions to version.sh, otherwise build fails\n                                    def versionFile = \"${libavDir}/version.sh\"\n                                    File verFile = file(versionFile)\n                                    if (verFile.exists()) {\n                                        exec {\n                                            workingDir(\"$libavDir\")\n                                            commandLine(\"chmod\", \"+x\", \"version.sh\")\n                                        }\n                                    } else {\n                                        versionFile = \"${libavDir}/ffbuild/version.sh\"\n                                        verFile = file(versionFile)\n                                        if (verFile.exists()) {\n                                            exec {\n                                                workingDir(\"${libavDir}/ffbuild\")\n                                                commandLine(\"chmod\")\n                                                args += \"+x\"\n                                                args += [\"version.sh\", \"libversion.sh\", \"pkgconfig_generate.sh\"]\n                                            }\n                                        }\n                                    }\n                                    exec {\n                                        workingDir(\"$libavDir\")\n                                        if (IS_BUILD_WORKING_LIBAV) {\n                                            commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)\n                                        } else {\n                                            commandLine(cfgCMDArgs + commonCfgArgs)\n                                        }\n                                    }\n                                }\n                                exec {\n                                    workingDir(\"$libavDir\")\n                                    commandLine(\"make\")\n                                }\n                            }\n                        }\n\n                        libav.versions.each { version ->\n                            def fromDir = \"${libav.basedir}/ffmpeg-${version}\"\n                            def majorVersion = libav.versionmap[version]\n                            def toDir = \"${libav.basedir}/ffmpeg-${majorVersion}\"\n                            copyLibAVStubs(fromDir, toDir)\n                        }\n                    }\n                }\n\n                def buildAVPlugin = task( \"buildAVPlugin\", dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {\n                    enabled = IS_COMPILE_MEDIA\n\n                    doLast {\n                        if (IS_BUILD_LIBAV_STUBS) {\n                            project.ext.libav = [:]\n                            project.ext.libav.basedir = \"${buildDir}/native/linux/libav/libav\"\n                            project.ext.libav.versions = [ \"53\", \"54\", \"55\", \"56\", \"57\" ]\n                            project.ext.libav.libavffmpeg = [:]\n                            project.ext.libav.libavffmpeg.basedir = \"${buildDir}/native/linux/libavffmpeg/libav\"\n                            project.ext.libav.libavffmpeg.versions = [ \"56\" ]\n                            project.ext.libav.ffmpeg = [:]\n                            project.ext.libav.ffmpeg.basedir = \"${buildDir}/native/linux/ffmpeg/ffmpeg\"\n                            project.ext.libav.ffmpeg.versions = [ \"57\", \"58\", \"59\", \"60\", \"61\" ]\n\n                            project.ext.libav.versions.each { version ->\n                                def libavDir = \"${project.ext.libav.basedir}-${version}\"\n                                File dir = file(libavDir)\n                                if (dir.exists()) {\n                                    exec {\n                                        commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/linux/avplugin\")\n                                        args(\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\",\n                                             \"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\",\n                                             \"BASE_NAME=avplugin\", \"VERSION=${version}\", \"LIBAV_DIR=${libavDir}\",\n                                             \"SUFFIX=\", \"ARCH=${ARCH_NAME}\",\n                                             \"STATIC=${IS_STATIC_BUILD}\")\n                                    }\n                                }\n                            }\n\n                            project.ext.libav.libavffmpeg.versions.each { version ->\n                                def libavDir = \"${project.ext.libav.libavffmpeg.basedir}-${version}\"\n                                File dir = file(libavDir)\n                                if (dir.exists()) {\n                                    exec {\n                                        commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/linux/avplugin\")\n                                        args(\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\",\n                                             \"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\",\n                                             \"BASE_NAME=avplugin\", \"VERSION=${version}\", \"LIBAV_DIR=${libavDir}\",\n                                             \"SUFFIX=-ffmpeg\",\n                                             \"ARCH=${ARCH_NAME}\")\n                                    }\n                                }\n                            }\n\n                            project.ext.libav.ffmpeg.versions.each { version ->\n                                def libavDir = \"${project.ext.libav.ffmpeg.basedir}-${version}\"\n                                File dir = file(libavDir)\n                                if (dir.exists()) {\n                                    exec {\n                                        commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/linux/avplugin\")\n                                        args(\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\",\n                                             \"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\",\n                                             \"BASE_NAME=avplugin\", \"VERSION=${version}\", \"LIBAV_DIR=${libavDir}\",\n                                             \"SUFFIX=-ffmpeg\",\n                                             \"ARCH=${ARCH_NAME}\")\n                                    }\n                                }\n                            }\n                        } else {\n                            // Building fxavcodec plugin (libav plugin)\n                            exec {\n                                commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/linux/avplugin\")\n                                args(\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\",\n                                     \"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\",\n                                     \"BASE_NAME=avplugin\", \"ARCH=${ARCH_NAME}\")\n                            }\n                        }\n                    }\n                }\n                buildNative.dependsOn buildAVPlugin\n            }\n\n            if (t.name == \"win\") {\n                def buildResources = task(\"buildResources\") {\n                    doLast {\n                        def rcOutputDir = \"${nativeOutputDir}/${buildType}\"\n                        mkdir rcOutputDir\n                        exec {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            commandLine (WIN.media.rcCompiler)\n                            args(WIN.media.glibRcFlags)\n                            args(\"/Fo${rcOutputDir}/${WIN.media.glibRcFile}\", WIN.media.rcSource)\n                        }\n\n                        exec {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            commandLine (WIN.media.rcCompiler)\n                            args(WIN.media.gstreamerRcFlags)\n                            args(\"/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}\", WIN.media.rcSource)\n                        }\n\n                        exec {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            commandLine (WIN.media.rcCompiler)\n                            args(WIN.media.fxpluginsRcFlags)\n                            args(\"/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}\", WIN.media.rcSource)\n                        }\n\n                        exec {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            commandLine (WIN.media.rcCompiler)\n                            args(WIN.media.jfxmediaRcFlags)\n                            args(\"/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}\", WIN.media.rcSource)\n                        }\n                    }\n                }\n\n                def buildGlib = task(\"build${t.capital}Glib\", dependsOn: [buildResources]) {\n                    enabled = IS_COMPILE_MEDIA\n                    doLast {\n                        exec {\n                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                            commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite\")\n                            args(\"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=glib-lite\",\n                                 IS_64 ? \"ARCH=x64\" : \"ARCH=x32\", \"RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}\",\n                                 \"CC=${mediaProperties.compiler}\", \"AR=${mediaProperties.ar}\", \"LINKER=${mediaProperties.linker}\")\n                        }\n                    }\n                }\n                buildGStreamer.dependsOn buildGlib\n\n            } else if (t.name == \"mac\") {\n                def buildGlib = task(\"build${t.capital}Glib\") {\n                    enabled = IS_COMPILE_MEDIA\n                    doLast {\n                        exec {\n                            commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi\")\n                            args(\"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=ffi\", \"ARCH=$TARGET_ARCH\")\n                            args (\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\", \"AR=${mediaProperties.ar}\")\n                        }\n\n                        exec {\n                            commandLine (\"make\", \"${makeJobsFlag}\", \"-C\", \"${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite\")\n                            args(\"OUTPUT_DIR=${nativeOutputDir}\", \"BUILD_TYPE=${buildType}\", \"BASE_NAME=glib-lite\", \"ARCH=$TARGET_ARCH\")\n                            args (\"CC=${mediaProperties.compiler}\", \"LINKER=${mediaProperties.linker}\")\n                        }\n                    }\n                }\n                buildGStreamer.dependsOn buildGlib\n            }\n        }\n\n        buildNativeTargets.dependsOn buildNative\n    }\n\n    jar {\n        exclude(\"headergen/**\")\n\n        dependsOn compileJava\n        if (IS_COMPILE_MEDIA) {\n            dependsOn buildNativeTargets\n        }\n    }\n\n    addMavenPublication(project, [ 'graphics' ])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":jsobject\") {\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"jdk.jsobject\"\n\n    sourceSets {\n        main\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'jsobject' ])\n\n\n    dependencies {\n    }\n\n    addMavenPublication(project, [])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\nproject(\":web\") {\n    configurations {\n        webkit\n    }\n    project.ext.buildModule = true\n    project.ext.includeSources = true\n    project.ext.moduleRuntime = true\n    project.ext.moduleName = \"javafx.web\"\n\n    getConfigurations().create(\"icu\");\n\n    sourceSets {\n        main\n        shims {\n            java {\n                compileClasspath += sourceSets.main.output\n                runtimeClasspath += sourceSets.main.output\n            }\n        }\n        test {\n            java {\n                compileClasspath += sourceSets.shims.output\n                runtimeClasspath += sourceSets.shims.output\n            }\n        }\n    }\n\n    project.ext.moduleSourcePath = defaultModuleSourcePath\n    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n\n    commonModuleSetup(project, [ 'base', 'graphics', 'controls', 'media', 'jsobject', 'web' ])\n\n    dependencies {\n        if (IS_COMPILE_WEBKIT) {\n            def icuFileVersion = \"${icuVersion}\".replaceAll('\\\\.', '_')\n            icu name: \"icu4c-${icuFileVersion}-data-bin-l\", ext: \"zip\"\n        }\n        implementation project(\":base\")\n        implementation project(\":graphics\")\n        implementation project(\":controls\")\n        implementation project(\":media\")\n        testImplementation project(\":base\").sourceSets.test.output\n    }\n\n    compileJava.dependsOn updateCacheIfNeeded\n\n    task testWebArchiveJar(type: Jar) {\n        from (project.file(\"$projectDir/src/test/resources/test/html\")) {\n            include \"**/archive-*.*\"\n        }\n        archiveFileName = \"webArchiveJar.jar\"\n        destinationDirectory = file(\"$buildDir/testing/resources\")\n    }\n\n    def gensrcDir = \"${buildDir}/gensrc/java\"\n\n    // add in the wrappers to the compile\n    sourceSets.main.java.srcDirs += \"${gensrcDir}\"\n\n    if (IS_COMPILE_WEBKIT) {\n        compileJava {\n            // generate the native headers during compile\n            // only needed if we are doing the native compile\n            options.compilerArgs.addAll([\n                '-h', \"${project.buildDir}/gensrc/headers\"\n                ])\n        }\n    }\n\n    // Copy these to a common location in the moduleSourcePath\n    def copyWrappers = project.task(\"copyPreGeneratedWrappers\", type: Copy) {\n        from \"src/main/native/Source/WebCore/bindings/java/dom3/java\"\n        into \"${gensrcDir}\"\n    }\n\n    compileJava.dependsOn(copyWrappers);\n\n    test {\n        doFirst {\n            if (IS_STUB_RUNTIME_OPENJFX) {\n                println \"********************************************************\"\n                println \"WARNING: running web tests with officially built webkit.\"\n                println \"The webkit native library may not be compatible with the\"\n                println \"source tree you are using.\"\n                println \"If tests fail, try compiling webkit instead.\"\n                println \"See WEBKIT-MEDIA-STUBS.md\"\n                println \"********************************************************\"\n            } else if (!IS_COMPILE_WEBKIT) {\n                println \"******************************************************\"\n                println \"WARNING: running web tests without building webkit.\"\n                println \"The webkit native library will be copied from the JDK,\"\n                println \"which might lead to failures in some web tests.\"\n                println \"See WEBKIT-MEDIA-STUBS.md\"\n                println \"******************************************************\"\n            }\n        }\n\n        // enable native access for all modules with native code\n        jvmArgs enableNativeAll\n\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n\n        // Run web tests in headless mode\n        systemProperty 'glass.platform', 'Monocle'\n        systemProperty 'monocle.platform', 'Headless'\n        systemProperty 'prism.order', 'sw'\n        dependsOn testWebArchiveJar\n        def testResourceDir = file(\"$buildDir/testing/resources\")\n        jvmArgs \"-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir\"\n    }\n\n    task compileJavaDOMBinding()\n\n    compileTargets { t ->\n        def targetProperties = project.rootProject.ext[t.upper]\n        def webkitProperties = targetProperties.webkit\n\n        def webkitOutputDir = cygpath(\"$buildDir/${t.name}\")\n        def webkitConfig = IS_DEBUG_NATIVE ? \"Debug\" : \"Release\"\n\n        File nativeBuildDir = new File(\"${webkitOutputDir}\")\n        nativeBuildDir.mkdirs()\n\n        def getICUFile = task(\"copyICUFile\", type: Copy) {\n            enabled = IS_COMPILE_WEBKIT\n\n            from configurations.icu.files\n            into \"$webkitOutputDir/icu/data\"\n        }\n\n        def compileNativeTask = task(\"compileNative${t.capital}\", dependsOn: [compileJava, getICUFile]) {\n            println \"Building Webkit configuration /$webkitConfig/ into $webkitOutputDir\"\n            enabled =  (IS_COMPILE_WEBKIT)\n\n            doLast {\n                exec {\n                    workingDir(\"$webkitOutputDir\")\n                    commandLine(\"perl\", \"$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration\", \"--$webkitConfig\")\n                    environment([\"WEBKIT_OUTPUTDIR\" : webkitOutputDir])\n                }\n\n                exec {\n                    workingDir(\"$webkitOutputDir\")\n                    def cmakeArgs = \"-DENABLE_TOOLS=1\"\n                    def makeArgs = \"-j $NUM_COMPILE_THREADS\"\n                    if (IS_STATIC_BUILD) {\n                        cmakeArgs = \" $cmakeArgs -DSTATIC_BUILD=1 -DUSE_THIN_ARCHIVES=OFF\";\n                    }\n                    cmakeArgs = \" $cmakeArgs -DCMAKE_C_COMPILER='${webkitProperties.compiler}'\"\n                    if (t.name == \"win\") {\n                        // To enable ninja build on Windows\n                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)\n                        // Adds compiler and linker flags if present\n                        def cFlags = webkitProperties.ccFlags?.join(' ') ?: ''\n                        def lFlags = webkitProperties.linkFlags?.join(' ') ?: ''\n                        cmakeArgs = \"$cmakeArgs -DCMAKE_C_FLAGS='${cFlags}' -DCMAKE_CXX_FLAGS='${cFlags}'\"\n                        cmakeArgs = \"$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS='${lFlags}'\"\n                    } else if (t.name == \"mac\") {\n                        cmakeArgs = \" $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH\"\n                    } else if (t.name == \"linux\") {\n                        cmakeArgs = \" $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux\"\n                        if (IS_64) {\n                            if (IS_AARCH64) {\n                                cmakeArgs = \"$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=aarch64\"\n                            } else if (IS_LOONGARCH64) {\n                                cmakeArgs = \"$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=loongarch64\"\n                            } else if (IS_RISCV64) {\n                                cmakeArgs = \"$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=riscv64\"\n                            } else {\n                                cmakeArgs = \"$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64\"\n                            }\n                        } else {\n                            cmakeArgs = \"$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586\"\n                        }\n                        // TODO: Use cflags and ldflags from all platforms\n                        def cFlags = webkitProperties.ccFlags?.join(' ') ?: ''\n                        def lFlags = webkitProperties.linkFlags?.join(' ') ?: ''\n                        if (IS_STATIC_BUILD) {\n                            cFlags = \" $cFlags -DSTATIC_BUILD=1\";\n                        }\n                        // -shared flag should be omitted while creating executable.\n                        def exeFlags = webkitProperties.linkFlags?.join(' ')?.replace('-shared', '') ?: ''\n                        cmakeArgs = \"$cmakeArgs -DCMAKE_C_FLAGS='${cFlags}' -DCMAKE_CXX_FLAGS='${cFlags}'\"\n                        cmakeArgs = \"$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS='${lFlags}' -DCMAKE_EXE_LINKER_FLAGS='${exeFlags}'\"\n                    } else if (t.name.startsWith(\"arm\")) {\n                        fail(\"ARM target is not supported as of now.\")\n                    }\n\n                    if (IS_COMPILE_PARFAIT) {\n                        environment([\n                            \"COMPILE_PARFAIT\" : \"true\"\n                        ])\n                        environment \"PATH\", System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH\n                        cmakeArgs = \"-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++\"\n                    }\n\n                    if (project.hasProperty('toolsPath')) {\n                        environment \"PATH\", toolsPath + File.pathSeparator + environment.PATH\n                    }\n\n                    environment([\n                        \"JAVA_HOME\"       : JDK_HOME,\n                        \"WEBKIT_OUTPUTDIR\" : webkitOutputDir,\n                        \"PYTHONDONTWRITEBYTECODE\" : \"1\",\n                    ])\n\n                    def targetCpuBitDepthSwitch = \"\"\n                    if (IS_64) {\n                        targetCpuBitDepthSwitch = \"--64-bit\"\n                    } else {\n                        targetCpuBitDepthSwitch = \"--32-bit\"\n                    }\n                    cmakeArgs += \" -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}\"\n                    commandLine(\"perl\", \"$projectDir/src/main/native/Tools/Scripts/build-webkit\",\n                        \"--java\", \"--icu-unicode\", targetCpuBitDepthSwitch,\n                        \"--makeArgs=${makeArgs}\",\n                        \"--no-experimental-features\", \"--cmakeargs=${cmakeArgs}\")\n                }\n            }\n        }\n\n        // Cmake places Windows DLL in bin directory\n        def dllDir = IS_WINDOWS ? \"bin\" : \"lib\"\n        def copyDumpTreeNativeTask = task(\"copyDumpTreeNative${t.capital}\", type: Copy,\n                dependsOn: [ compileNativeTask]) {\n            def library = rootProject.ext[t.upper].library\n            from \"$webkitOutputDir/$dllDir/${library('DumpRenderTreeJava')}\"\n            into \"$buildDir/test/${t.name}\"\n        }\n\n        def copyNativeTask = task(\"copyNative${t.capital}\", type: Copy,\n                dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {\n            enabled =  (IS_COMPILE_WEBKIT)\n            def library = rootProject.ext[t.upper].library\n            from \"$webkitOutputDir/$dllDir/${library('jfxwebkit')}\"\n            into \"$buildDir/libs/${t.name}\"\n        }\n\n        if (IS_WINDOWS && t.name == \"win\") {\n            def rcTask = project.task(\"rc${t.capital}\", type: CompileResourceTask) {\n                compiler = webkitProperties.rcCompiler\n                source(webkitProperties.rcSource)\n                if (webkitProperties.rcFlags) {\n                    rcParams.addAll(webkitProperties.rcFlags)\n                }\n                output(file(\"$webkitOutputDir/WebCore/obj\"))\n            }\n            compileNativeTask.dependsOn rcTask\n        }\n\n        def compileJavaDOMBindingTask = task(\"compileJavaDOMBinding${t.capital}\", type: JavaCompile,\n                dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {\n            destinationDirectory = file(\"$buildDir/classes/java/main\")\n            classpath = configurations.compileClasspath\n            source = project.sourceSets.main.java.srcDirs\n            options.compilerArgs.addAll([\n                '-implicit:none',\n                '--module-version', \"$RELEASE_VERSION_SHORT\",\n                '--module-source-path', defaultModuleSourcePath\n                ])\n        }\n\n        compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask\n\n        if (!targetProperties.compileWebnodeNative) {\n            println(\"Not compiling native Webkit for ${t.name} per configuration request\");\n            compileNativeTask.enabled = false\n        }\n    }\n\n    def drtClasses = \"**/com/sun/javafx/webkit/drt/**\"\n    task drtJar(type: Jar, dependsOn: compileJava) {\n        archiveFileName = \"drt.jar\"\n        destinationDirectory = file(\"$buildDir/test\")\n        from \"$buildDir/classes/java/main/javafx.web/\"\n        include drtClasses\n        includeEmptyDirs = false\n    }\n\n    if (IS_COMPILE_WEBKIT) {\n        drtJar.dependsOn compileJavaDOMBinding, processResources\n        compileShimsJava.dependsOn compileJavaDOMBinding\n        assemble.dependsOn compileJavaDOMBinding, drtJar\n    }\n\n    addMavenPublication(project, [ 'controls', 'media', 'jsobject' ])\n\n    addValidateSourceSets(project, sourceSets)\n}\n\n// This project is for system tests that need to run with a full SDK.\n// Most of them display a stage or do other things that preclude running\n// them in a shared JVM or as part of the \"smoke test\" run (which must\n// not pop up any windows or use audio). As such, they are only enabled\n// when FULL_TEST is specified, and each test runs in its own JVM\nproject(\":systemTests\") {\n\n    sourceSets {\n        test\n\n        // Source sets for standalone test apps (used for launcher tests)\n        testapp1\n\n        // Modular applications\n        testapp2\n        testapp3\n        testapp4\n        testapp5\n        testapp6\n        testapp7\n        testscriptapp1\n        testscriptapp2\n    }\n\n    def nonModSrcSets = [\n        sourceSets.test,\n        sourceSets.testapp1\n    ]\n\n    def modSrcSets = [\n        sourceSets.testapp2,\n        sourceSets.testapp3,\n        sourceSets.testapp4,\n        sourceSets.testapp5,\n        sourceSets.testapp6,\n        sourceSets.testapp7,\n        sourceSets.testscriptapp1,\n        sourceSets.testscriptapp2\n    ]\n\n    // We need to skip setting compiler.options.release for system tests,\n    // since the tests export an internal package from java.desktop, which\n    // is disallowed by \"--release NN\". This will fall back to using\n    // \"-source NN -target NN\" for the system tests.\n    project.ext.skipJavaCompilerOptionRelease = true\n\n    project.ext.buildModule = false\n    project.ext.moduleRuntime = false\n    project.ext.moduleName = \"systemTests\"\n\n    dependencies {\n        testImplementation project(\":graphics\").sourceSets.test.output\n        testImplementation project(\":base\").sourceSets.test.output\n        testImplementation project(\":controls\").sourceSets.test.output\n        testImplementation project(\":swing\").sourceSets.test.output\n    }\n\n    def dependentProjects = [\n        'base',\n        'graphics',\n        'controls',\n        // Add an entry for each incubator module here, leaving the incubator\n        // placeholder lines as an example.\n        // BEGIN: incubator placeholder\n        //'incubator.mymod',\n        // END: incubator placeholder\n        'incubator.input',\n        'incubator.richtext',\n        'media',\n        'jsobject',\n        'web',\n        'swing',\n        'fxml'\n    ]\n    commonModuleSetup(project, dependentProjects)\n\n    File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);\n\n    File stRunArgsFile = new File(project.buildDir,\"st.run.args\");\n\n    def sts = task(\"systemTestSetup\") {\n        outputs.file(stRunArgsFile)\n\n        doLast() {\n            stRunArgsFile.delete()\n\n            logger.info(\"Creating patchmodule.args file ${stRunArgsFile}\")\n\n            // Create an argfile with the information needed to launch\n            // the stand alone system unit tests.\n\n            //First add in all of the patch-module args we use for the\n            //normal unit tests, copied from test.run.args\n            testRunArgsFile.eachLine { str ->\n                stRunArgsFile <<  \"${str}\\n\"\n            }\n\n            // Now add in the working classpath elements (junit, test classes...)\n            stRunArgsFile <<  \"-cp \\\"\\\\\\n\"\n            test.classpath.each() { elem ->\n                def e = cygpath(\"${elem}\")\n                stRunArgsFile <<  \"  ${e}${File.pathSeparator}\\\\\\n\"\n            }\n            stRunArgsFile <<  \"\\\"\\n\"\n        }\n    }\n\n    test.dependsOn(sts)\n    test.dependsOn(createTestArgfiles);\n\n    // Tasks to create standalone test applications for the launcher tests\n\n    if (project.hasProperty('testModulePathArgs')) {\n        compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)\n    }\n    dependentProjects.each { e ->\n        compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)\n    }\n\n    def testapp1JarName = \"testapp1.jar\"\n    task createTestapp1Jar1(type: Jar) {\n        dependsOn compileTestapp1Java\n        enabled = IS_FULL_TEST\n\n        destinationDirectory = file(\"$buildDir/testapp1\")\n        archiveFileName = testapp1JarName\n        includeEmptyDirs = false\n        from project.sourceSets.testapp1.java.getDestinationDirectory().get().getAsFile()\n        include(\"testapp/**\")\n        include(\"com/javafx/main/**\")\n\n        manifest {\n            attributes(\n                \"Main-Class\" : \"com.javafx.main.Main\",\n                \"JavaFX-Version\" : \"2.2\",\n                \"JavaFX-Application-Class\" : \"testapp.HelloWorld\",\n                \"JavaFX-Class-Path\" : \"jar2.jar\"\n            )\n        }\n    }\n\n    task createTestapp1Jar2(type: Jar) {\n        dependsOn compileTestapp1Java\n        enabled = IS_FULL_TEST\n\n        destinationDirectory = file(\"$buildDir/testapp1\")\n        archiveFileName = \"jar2.jar\";\n        includeEmptyDirs = false\n        from project.sourceSets.testapp1.java.getDestinationDirectory().get().getAsFile()\n        include(\"pkg2/**\")\n    }\n\n    task createTestApps() {\n        dependsOn(createTestapp1Jar1)\n        dependsOn(createTestapp1Jar2)\n    }\n    test.dependsOn(createTestApps);\n\n    def modtestapps = [ \"testapp2\", \"testapp3\", \"testapp4\", \"testapp5\", \"testapp6\", \"testapp7\", \"testscriptapp1\", \"testscriptapp2\" ]\n    modtestapps.each { testapp ->\n        def testappCapital = testapp.capitalize()\n        def copyTestAppTask = task(\"copy${testappCapital}\", type: Copy) {\n            from project.sourceSets.\"${testapp}\".java.getDestinationDirectory().get().getAsFile()\n            from project.sourceSets.\"${testapp}\".output.resourcesDir\n            into \"${project.buildDir}/modules/${testapp}\"\n        }\n\n        def List<String> testAppSourceDirs = []\n        project.sourceSets.\"${testapp}\".java.srcDirs.each { dir ->\n            testAppSourceDirs += dir\n        }\n        def testappCompileTasks = project.getTasksByName(\"compile${testappCapital}Java\", true);\n        def testappResourceTasks = project.getTasksByName(\"process${testappCapital}Resources\", true);\n        testappCompileTasks.each { appCompileTask ->\n            appCompileTask.options.compilerArgs.addAll([\n                '-implicit:none',\n                '--module-source-path', testAppSourceDirs.join(File.pathSeparator),\n                ] )\n            if (project.hasProperty('testModulePathArgs')) {\n                appCompileTask.options.compilerArgs.addAll(testModulePathArgs)\n            }\n\n            dependentProjects.each { e ->\n                appCompileTask.dependsOn(rootProject.project(e).testClasses)\n            }\n\n            copyTestAppTask.dependsOn(appCompileTask)\n        }\n        testappResourceTasks.each { appResourceTask ->\n            copyTestAppTask.dependsOn(appResourceTask)\n        }\n\n        createTestApps.dependsOn(copyTestAppTask)\n    }\n\n    test {\n        enabled = IS_FULL_TEST\n\n        // enable native access for all modules with native code\n        jvmArgs enableNativeAll\n\n        // FIXME: Remove this when JDK-8334137 is fixed\n        if (jdk24OrLater) {\n            jvmArgs allowSunMiscUnsafe\n        }\n\n        // Parse testPatchModuleArgs looking for \"*module-path\".\n        // Save path if found so we can pass it to the module launcher tests\n        def pendingModulePath = false\n        testPatchModuleArgs.each { str ->\n            if (pendingModulePath) {\n                project.ext.launcherModulePath = str;\n                pendingModulePath = false\n            } else if (str.endsWith(\"module-path\")) {\n                pendingModulePath = true\n            }\n        }\n\n        // Properties passed to launcher tests\n        systemProperty \"launchertest.testapp1.jar\", \"build/testapp1/$testapp1JarName\"\n        modtestapps.each { testapp ->\n            systemProperty \"launchertest.${testapp}.module.path\",\n                    \"${project.buildDir}/modules/${testapp}\"\n        }\n\n        // Properties passed to test.util.Util\n        systemProperties 'worker.debug': IS_WORKER_DEBUG\n        systemProperties 'worker.patchmodule.file': cygpath(stRunArgsFile.path)\n        if (project.hasProperty(\"launcherModulePath\")) {\n            systemProperties 'worker.module.path': launcherModulePath\n        }\n        systemProperties 'worker.java.cmd': JAVA\n\n        if (rootProject.hasProperty(\"ClipShapeTest.numTests\")) {\n            systemProperty \"ClipShapeTest.numTests\", rootProject.getProperty(\"ClipShapeTest.numTests\")\n        }\n\n        if (!IS_USE_ROBOT) {\n            // Disable all robot-based visual tests\n            exclude(\"test/robot/**\");\n        }\n        if (!IS_UNSTABLE_TEST) {\n            // JDK-8196607 Don't run monocle test cases\n            exclude(\"test/robot/com/sun/glass/ui/monocle/**\");\n        }\n        if (!IS_AWT_TEST) {\n            // Disable all AWT-based tests\n            exclude(\"**/javafx/embed/swing/*.*\");\n            exclude(\"**/com/sun/javafx/application/Swing*.*\");\n        }\n\n        forkEvery = 1\n    }\n\n    addValidateSourceSets(project, nonModSrcSets, modSrcSets)\n}\n\nvoid setupLintOptions(Task compile, String lintOpts, String extraLintOpts) {\n    lintOpts.split(\"[, ]\").each { s ->\n        compile.options.compilerArgs += \"-Xlint:$s\"\n    }\n\n    if (extraLintOpts != \"\") {\n        extraLintOpts.split(\"[, ]\").each { s ->\n            compile.options.compilerArgs += \"-Xlint:$s\"\n        }\n    }\n\n    compile.options.compilerArgs += [ \"-Xmaxwarns\", \"1000\" ]\n}\n\nallprojects {\n    // The following block is a workaround for the fact that presently Gradle\n    // can't set the -XDignore.symbol.file flag, because it appears that the\n    // javac API is lacking support for it. So what we'll do is find any Compile\n    // task and manually provide the options necessary to fire up the\n    // compiler with the right settings.\n    tasks.withType(JavaCompile) { compile ->\n        if (compile.options.hasProperty(\"useAnt\")) {\n            compile.options.useAnt = true\n            compile.options.useDepend = IS_USE_DEPEND\n        } else if (compile.options.hasProperty(\"incremental\")) {\n            compile.options.incremental = IS_INCREMENTAL\n        }\n\n        def isCompileTestTask = compile.name.startsWith(\"compileTest\")\n        if (!isCompileTestTask) {\n            if (project.hasProperty('skipJavaCompilerOptionRelease') &&\n                    project.ext.skipJavaCompilerOptionRelease) {\n\n                logger.info \"Using 'javac -source/-target' for ${compile}\"\n            } else {\n                compile.options.release = JAVA_TARGET_VERSION\n            }\n        }\n\n        compile.options.debug = true // we always generate debugging info in the class files\n        compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? \"source,lines,vars\" : \"source,lines\"\n        compile.options.fork = true\n\n        compile.options.forkOptions.executable = JAVAC\n\n        compile.options.compilerArgs += [\"-XDignore.symbol.file\", \"-encoding\", \"UTF-8\"]\n        compile.options.compilerArgs += [ \"-Xmaxerrs\", \"1000\" ]\n\n        // we use a custom javadoc command\n        project.javadoc.enabled = false\n\n        def disableJavacWerror =\n                project.hasProperty('disableJavacWerror') &&\n                project.ext.disableJavacWerror\n\n        if (compile.name == \"compileJava\" ||\n            compile.name == \"compileFullJava\" ||\n            compile.name.startsWith(\"compileJavaDOMBinding\")) {\n\n            // Add in the -Xlint options\n            compile.options.warnings = IS_LINT\n            if (IS_LINT) {\n                def extraLintOpts = project.hasProperty(\"extraLintOptions\") ?\n                                    project.ext.extraLintOptions : \"\"\n                setupLintOptions(compile, LINT, extraLintOpts);\n\n                if (IS_JAVAC_WERROR && !disableJavacWerror) {\n                    compile.options.compilerArgs += \"-Werror\"\n                }\n            }\n        } else if (compile.name == \"compileJslcJava\" ||\n            compile.name == \"compileDecoraCompilers\" ||\n            compile.name == \"compilePrismCompilers\" ||\n            compile.name == \"compileToolsJava\") {\n\n            // Add in the -Xlint options\n            compile.options.warnings = IS_TOOL_LINT\n            if (IS_TOOL_LINT) {\n                def extraLintOpts = project.hasProperty(\"extraToolLintOptions\") ?\n                                    project.ext.extraToolLintOptions : \"\"\n                setupLintOptions(compile, TOOL_LINT, extraLintOpts);\n\n                if (IS_TOOL_JAVAC_WERROR && !disableJavacWerror) {\n                    compile.options.compilerArgs += \"-Werror\"\n                }\n            }\n        } else if (compile.name == \"compileShimsJava\" ||\n            compile.name.startsWith(\"compileTest\")) {\n\n            // Add in the -Xlint options\n            compile.options.warnings = IS_TEST_LINT\n            if (IS_TEST_LINT) {\n                def extraLintOpts = project.hasProperty(\"extraTestLintOptions\") ?\n                                    project.ext.extraTestLintOptions : \"\"\n                setupLintOptions(compile, TEST_LINT, extraLintOpts);\n\n                if (IS_TEST_JAVAC_WERROR && !disableJavacWerror) {\n                    compile.options.compilerArgs += \"-Werror\"\n                }\n            }\n        } else {\n            logger.info(\"Unknown compilation task: ${project}:${compile.name}\")\n            compile.options.warnings = false\n        }\n    } // tasks with javaCompile\n\n    // Normalizes the ZIP and JAR archives\n    tasks.withType(Zip) {\n        if (sourceDateEpoch != null) {\n            preserveFileTimestamps = false\n            reproducibleFileOrder = true\n            doLast {\n                setFileTimestamps(archiveFile, buildInstant)\n            }\n        }\n    }\n\n    // If I am a module....\n    if (project.hasProperty('moduleSourcePath') &&\n            (project.hasProperty('buildModule') && project.buildModule)) {\n        project.compileJava {\n            options.compilerArgs.addAll([\n                '-implicit:none',\n                '--module-version', \"$RELEASE_VERSION_SHORT\",\n                '--module-source-path', project.moduleSourcePath\n                ])\n        }\n        // no jars needed for modules\n        project.jar.enabled = false\n\n        // and redirect the resources into the module\n        project.sourceSets.main.output.resourcesDir = project.moduleDir\n        project.processResources.destinationDir = project.moduleDir\n    }\n\n    if (project.hasProperty('moduleSourcePathShim') &&\n            project.sourceSets.hasProperty('shims')) {\n\n        // sync up the obvious source directories with the shims\n        // others (like the shaders in graphics) should be added in there\n        project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs\n        project.sourceSets.shims.java.srcDirs += \"$buildDir/gensrc/java\"\n\n        project.compileShimsJava {\n            options.compilerArgs.addAll([\n                '-implicit:none',\n                '--module-version', \"$RELEASE_VERSION_SHORT\",\n                '--module-source-path', project.moduleSourcePathShim\n                ])\n        }\n        project.compileShimsJava.dependsOn(project.compileJava)\n\n        def copyGeneratedShimsTask = task(\"copyGeneratedShims\", type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {\n            from project.sourceSets.shims.java.getDestinationDirectory().get().getAsFile()\n            into \"${rootProject.buildDir}/shims\"\n            if (HAS_JAVAFX_MODULES) {\n                exclude(\"*/module-info.class\")\n            }\n        }\n\n        project.processShimsResources.dependsOn(project.processResources)\n\n        // shims resources should have the main resouces as a base\n        project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs\n\n        // and redirect the resources into the module\n        project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir\n        project.processShimsResources.destinationDir = project.moduleShimsDir\n\n       compileTestJava.dependsOn(copyGeneratedShimsTask)\n    }\n\n    if (project.hasProperty('modulePathArgs')) {\n        project.compileJava.options.compilerArgs.addAll(modulePathArgs)\n    }\n\n    if (project.hasProperty('testModulePathArgs')) {\n        project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)\n    }\n\n    if (project.hasProperty('testPatchModuleArgs')) {\n        project.test.jvmArgs += testPatchModuleArgs\n    }\n\n    /* Note: we should not have to add extraAddExports to the normal\n     * modular compile, as it contains all of the module-info files.\n     * In fact doing so might cover up a module-info issue.\n     * so we don't do it, and I will leave this commented out\n     * block as a reminder of this fact.\n    if (project.hasProperty('extraAddExports')) {\n        project.compileJava.options.compilerArgs.addAll(extraAddExports);\n    }\n    */\n\n    if (project.hasProperty('testAddExports')) {\n        project.compileTestJava.options.compilerArgs.addAll(testAddExports);\n        project.test.jvmArgs += testAddExports\n    }\n\n    if (rootProject.hasProperty(\"EXTRA_TEST_ARGS\") && project.hasProperty('test')) {\n        EXTRA_TEST_ARGS.split(' ').each() { e ->\n            project.test.jvmArgs += e\n        }\n    }\n\n    if (rootProject.hasProperty(\"EXTRA_COMPILE_ARGS\") && project.hasProperty('compileJava')) {\n        project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(' '))\n    }\n\n    if (rootProject.hasProperty(\"EXTRA_COMPILE_ARGS\") && project.hasProperty('compileTestJava')) {\n        project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(' '))\n    }\n}\n\n/******************************************************************************\n *                                                                            *\n *                             Top Level Tasks                                *\n *                                                                            *\n *  These are the tasks which are defined only for the top level project and  *\n *  not for any sub projects. These are generally the entry point that is     *\n *  used by Hudson and by the continuous build system.                        *\n *                                                                            *\n *****************************************************************************/\n\ntask clean() {\n    group = \"Basic\"\n    description = \"Deletes the build directory and the build directory of all sub projects\"\n    getSubprojects().each { subProject ->\n        dependsOn(subProject.getTasksByName(\"clean\", true));\n    }\n    doLast {\n        delete(buildDir);\n    }\n}\n\ntask cleanAll() {\n    group = \"Basic\"\n    description = \"Scrubs the repo of build artifacts\"\n    dependsOn(clean)\n    doLast {\n        //delete(\".gradle\"); This causes problems on windows.\n        delete(\"buildSrc/build\");\n    }\n}\n\ntask createMSPfile() {\n    group = \"Build\"\n    File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)\n    outputs.file(mspFile)\n\n    doLast {\n        mspFile.delete()\n        mspFile << \"--module-source-path\\n\"\n        mspFile << defaultModuleSourcePath\n        mspFile << \"\\n\"\n    }\n}\n\ntask javadoc(type: Javadoc, dependsOn: createMSPfile) {\n    group = \"Basic\"\n    description = \"Generates the JavaDoc for all the public API\"\n    executable = JAVADOC\n    def projectsToDocument = [\n        project(\":base\"),\n        project(\":graphics\"),\n        project(\":controls\"),\n        // Add an entry for each incubator module here, leaving the incubator\n        // placeholder lines as an example.\n        // BEGIN: incubator placeholder\n        //project(\":incubator.mymod\"),\n        // END: incubator placeholder\n        project(\":incubator.input\"),\n        project(\":incubator.richtext\"),\n        project(\":media\"),\n        project(\":swing\"),\n        /*project(\":swt\"),*/\n        project(\":fxml\"),\n        project(\":jsobject\"),\n        project(\":web\")\n    ]\n    source(projectsToDocument.collect({\n        [it.sourceSets.main.java]\n    }));\n    setDestinationDir(new File(buildDir, 'javadoc'));\n\n    exclude(\"com/**/*\", \"Compile*\", \"javafx/builder/**/*\", \"javafx/scene/accessibility/**/*\");\n\n    options.tags(\"apiNote:a:API Note:\")\n    options.tags(\"implSpec:a:Implementation Requirements:\")\n    options.tags(\"implNote:a:Implementation Note:\")\n    options.tags(\"interpolationType:a:Interpolation Type:\")\n    options.tags(\"param\")\n    options.tags(\"return\")\n    options.tags(\"throws\")\n    options.tags(\"moduleGraph:X\")\n    options.tags(\"since\")\n    options.tags(\"version\")\n    options.tags(\"serialData\")\n    options.tags(\"factory\")\n    options.tags(\"see\")\n\n    options.addStringOption(\"-since\").setValue((9..jfxReleaseMajorVersion.toInteger()).join(\",\"))\n    options.addStringOption(\"-since-label\").setValue(\"New API since JavaFX 9\")\n    options.addStringOption(\"Xmaxwarns\").setValue(\"1000\")\n    options.addStringOption(\"Xmaxerrs\").setValue(\"1000\")\n\n    String draftMsg = IS_MILESTONE_FCS ? \"\" : \"<br><b>DRAFT ${RELEASE_VERSION_LONG}</b>\"\n    String javadocTitleImpl = javadocTitle\n            .replaceAll(\"@JAVADOC_VERSION@\", jfxReleaseMajorVersion)\n    String javadocHeaderImpl = javadocHeader\n            .replaceAll(\"@JAVADOC_VERSION@\", jfxReleaseMajorVersion)\n            .replaceAll(\"@DRAFT_UNLESS_FCS@\", draftMsg)\n    String javadocBottomImpl = javadocBottom\n            .replaceAll(\"@DRAFT_UNLESS_FCS@\", draftMsg)\n            .replaceAll(\"@FULL_VERSION@\", RELEASE_VERSION_LONG)\n    options.windowTitle(javadocTitleImpl)\n    options.header(javadocHeaderImpl)\n    options.bottom(javadocBottomImpl)\n    if (!IS_MILESTONE_FCS) {\n        options.addStringOption(\"top\").setValue(javadocTop)\n    }\n\n    options.locale(\"en\");\n    if (JDK_DOCS_LINK != \"\") {\n        options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);\n    } else {\n        options.links(JDK_DOCS);\n    }\n    options.addBooleanOption(\"XDignore.symbol.file\").setValue(true);\n    options.addBooleanOption(\"Xdoclint:${DOC_LINT}\").setValue(IS_DOC_LINT);\n    options.addBooleanOption(\"Werror\").setValue(IS_DOC_WERROR);\n    options.addBooleanOption(\"html5\").setValue(true);\n    options.addBooleanOption(\"javafx\").setValue(true);\n    options.addBooleanOption(\"use\").setValue(true);\n\n    // Suppress generating overridden methods with no additional documentation\n    // The leading '-' is necessary, since this option starts with '--' and gradle adds '-' when passing an option to javadoc\n    options.addBooleanOption(\"-override-methods=summary\").setValue(true);\n\n    options.setOptionFiles([\n        new File(rootProject.buildDir,MODULESOURCEPATH)\n        ]);\n\n    doLast {\n        projectsToDocument.each { p ->\n            def destDir = \"$buildDir/javadoc/${p.ext.moduleName}\"\n            copy {\n                from(\"$p.projectDir/src/main/docs\") {\n                    include \"**/*.html\"\n                    filter { line->\n                        line = line.replace(\"@FXVERSION@\", RELEASE_VERSION)\n                    }\n                }\n                from(\"$p.projectDir/src/main/docs\") {\n                    exclude \"**/*.html\"\n                }\n\n                into destDir\n            }\n        }\n    }\n\n    dependsOn(projectsToDocument.collect { project -> project.getTasksByName(\"classes\", true)});\n}\n\ntask shims() {\n    gradle.allprojects { project ->\n        if (project.hasProperty(\"sourceSets\") && project.sourceSets.hasProperty('shims')) {\n            project.tasks.each { task ->\n                if (task.name.contains(\"shim\") || task.name.contains(\"Shim\")) {\n                    dependsOn(task)\n                }\n            }\n        }\n    }\n}\n\ntask sdk() {\n    if (!IS_TEST_ONLY) {\n        rootProject.getTasksByName(\"test\", true).each { t ->\n            if (t.enabled) t.dependsOn(shims)\n        }\n    } else {\n        gradle.taskGraph.whenReady { taskGraph ->\n            taskGraph.allTasks.each { task ->\n                if (!isTestTask(task) && !task.name.equals(\"verifyJava\") &&\n                    !task.name.equals(\"validateSourceSets\") && !task.name.contains(\"buildRunArgs\")) {\n                    task.enabled = false\n                }\n            }\n        }\n    }\n}\n\nshims.dependsOn(sdk)\n\ntask jmods() {\n    dependsOn(sdk)\n    // real work items added later.\n}\n\ntask appsjar() {\n    dependsOn(sdk)\n    // Note: the jar dependencies get added elsewhere see project(\":apps\")\n}\n\n// these are empty tasks, allowing us to depend on the task, which may have other\n// real work items added later.\ntask copyAppsArtifacts() {\n    dependsOn(appsjar)\n}\n\ntask apps() {\n    dependsOn(sdk)\n    dependsOn(appsjar)\n    dependsOn(copyAppsArtifacts)\n}\n\ntask findbugs() {\n    dependsOn(sdk)\n\n    doLast {\n        if (!BUILD_CLOSED) {\n            println \"findbugs task is only run for a closed build\"\n        }\n    }\n}\n\n// create the zip file of modules for a JDK build\ntask jdkZip {\n    dependsOn(sdk)\n}\n\n// The following tasks are for the closed build only. They are a no-op for the open build\n\ntask checkCache() {\n    dependsOn(updateCacheIfNeeded)\n}\n\ntask publicExports() {\n    dependsOn(sdk, jmods, apps, javadoc, jdkZip)\n    // note the real work is below in the compileTargets\n}\n\ntask perf() {\n    dependsOn(sdk, apps)\n    doLast {\n        if (!BUILD_CLOSED) {\n            println \"perf task is only run for a closed build\"\n        }\n    }\n}\n\ntask zips() {\n    dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)\n    // note the real work is below in the compileTargets\n}\n\ntask all() {\n    dependsOn(sdk, shims, publicExports, apps, perf, zips)\n}\n\n\n// Construct list of subprojects that are modules\next.moduleProjList = []\nsubprojects {\n    if (project.hasProperty(\"buildModule\") && project.ext.buildModule) {\n        rootProject.ext.moduleProjList += project\n        println \"module: $project (buildModule=YES)\"\n    } else {\n        println \"module: $project (buildModule=NO)\"\n    }\n}\n\n\n// Define the sdk task, which also produces the javafx.swt modular jar\n\ncompileTargets { t ->\n\n    def javafxSwtTask = task(\"javafxSwt$t.capital\", type: Jar) {\n        enabled = COMPILE_SWT\n        group = \"Basic\"\n        description = \"Creates the javafx-swt.jar for the $t.name target\"\n        destinationDirectory = file(\"${project(\":swt\").buildDir}/libs\")\n        archiveFileName = \"javafx-swt.jar\"\n        includeEmptyDirs = false\n        from(\"${project(\":swt\").buildDir}/classes/java/main\");\n        include(\"**/javafx/embed/swt/**\")\n\n        dependsOn(\n            project(\":swt\").compileJava,\n            project(\":swt\").processResources,\n            // note: assemble and classes are not enough for DidWork\n            project(\":swt\").classes,\n            // classes is needed for a jar copy\n            )\n    }\n\n    def sdkTask = task(\"sdk$t.capital\") {\n        group = \"Basic\"\n        dependsOn(javafxSwtTask)\n    }\n\n    sdk.dependsOn(sdkTask)\n}\n\nproject(\":apps\") {\n    // The apps build is Ant based, we will exec ant from gradle.\n\n    // Download the Lucene libraries needed for the Ensemble8 app\n    getConfigurations().create(\"lucene\");\n    dependencies {\n        lucene group: \"org.apache.lucene\", name: \"lucene-core\", version: \"${luceneVersion}\"\n        lucene group: \"org.apache.lucene\", name: \"lucene-grouping\", version: \"${luceneVersion}\"\n        lucene group: \"org.apache.lucene\", name: \"lucene-queryparser\", version: \"${luceneVersion}\"\n    }\n\n    // Copy Lucene libraries into the Ensemble8/lib directory\n    File ensembleLibDir = rootProject.file(\"apps/samples/Ensemble8/lib\");\n    def libNames = [ \"lucene-core-${luceneVersion}.jar\",\n                     \"lucene-grouping-${luceneVersion}.jar\",\n                     \"lucene-queryparser-${luceneVersion}.jar\" ]\n\n\n    task getLucene(type: Copy) {\n        doFirst {\n            ensembleLibDir.mkdirs();\n        }\n        into ensembleLibDir\n        includeEmptyDirs = false\n        configurations.lucene.files.each { f ->\n            libNames.each { name ->\n                if (name == f.getName()) {\n                    from f.getPath()\n                }\n            }\n        }\n    }\n\n    compileTargets { t ->\n        List<String> params = []\n\n        params << \"-DtargetBld=$t.name\"\n\n        if (!rootProject.ext[t.upper].compileSwing) {\n            params << \"-DJFX_CORE_ONLY=true\"\n        }\n        params << \"-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}\"\n        params << \"-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}\"\n        params << \"-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}\"\n\n        def appsJar = project.task(\"appsJar${t.capital}\") {\n            dependsOn(sdk, getLucene)\n            doLast() {\n                ant(t.name,\n                      projectDir.path,\n                      \"appsJar\",\n                      params);\n            }\n        }\n        rootProject.appsjar.dependsOn(appsJar)\n\n        def appsClean = project.task(\"clean${t.capital}\") {\n            doLast() {\n                ant(t.name,\n                      project.projectDir.path,\n                      \"clean\",\n                      params);\n                delete(ensembleLibDir);\n            }\n        }\n        rootProject.clean.dependsOn(appsClean)\n    }\n}\n\n// Tasks to create the disk layout for the sdk, jmods, and docs\n// in the artifacts directory (publicExports), and zip them up in\n// artifacts/bundles (zips)\n// These tasks are only used for the standalone SDK.\ncompileTargets { t ->\n    if (!HAS_JAVAFX_MODULES) {\n        def targetProperties = rootProject.ext[t.upper]\n        def platformPrefix = targetProperties.platformPrefix\n\n        def artifactsDir = \"${rootProject.buildDir}/artifacts\"\n        def bundlesDir = \"${artifactsDir}/bundles\"\n\n        def sdkDirName = \"${platformPrefix}sdk\"\n        def sdkDir = \"${rootProject.buildDir}/${sdkDirName}\"\n        def sdkBundleName = \"javafx-sdk-${RELEASE_VERSION}\"\n        def sdkArtifactsDir = \"${artifactsDir}/${sdkBundleName}\"\n\n        def docsDirName = \"javadoc\"\n        def docsDir = \"${rootProject.buildDir}/${docsDirName}\"\n        def docsBundleName = \"javafx-docs-${RELEASE_VERSION}\"\n        def docsArtifactsDir = \"${artifactsDir}/${docsBundleName}\"\n\n        def jmodsDirName = \"jmods\"\n        def jmodsDir = \"${rootProject.buildDir}/${jmodsDirName}\"\n        def jmodsBundleName = \"javafx-jmods-${RELEASE_VERSION}\"\n        def jmodsArtifactsDir = \"${artifactsDir}/${jmodsBundleName}\"\n\n        def publicExportsTask = task (\"publicExportsStandalone${t.capital}\") {\n            group = \"Basic\"\n            description = \"Creates the disk layout for sdk, jmods, and docs\"\n        }\n        publicExports.dependsOn(publicExportsTask)\n\n        def copyArtifactsSdkTask = task(\"copyArtifactsSdk$t.capital\", type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {\n            from sdkDir\n            into sdkArtifactsDir\n        }\n        publicExportsTask.dependsOn(copyArtifactsSdkTask)\n\n        // Need to modify file permissions Windows to make sure that the\n        // execute bit is set, and that the files are world readable\n        def chmodArtifactsSdkTask = task(\"chmodArtifactsSdk$t.capital\", dependsOn: copyArtifactsSdkTask) {\n            if (IS_WINDOWS && IS_USE_CYGWIN) {\n                doLast {\n                    exec {\n                        workingDir(sdkArtifactsDir)\n                        commandLine(\"chmod\", \"-R\", \"755\", \".\")\n                    }\n                }\n            }\n        }\n        publicExportsTask.dependsOn(chmodArtifactsSdkTask)\n\n        def copyArtifactsDocsTask = task(\"copyArtifactsDocs$t.capital\", type: Copy, dependsOn: chmodArtifactsSdkTask) {\n            from docsDir\n            into \"${docsArtifactsDir}/api\"\n        }\n        publicExportsTask.dependsOn(copyArtifactsDocsTask)\n\n        def copyArtifactsJmodsTask = task(\"copyArtifactsJmods$t.capital\", type: Copy, dependsOn: copyArtifactsDocsTask) {\n            from jmodsDir\n            into \"${jmodsArtifactsDir}\"\n        }\n        publicExportsTask.dependsOn(copyArtifactsJmodsTask)\n\n        def zipsTask = task (\"zipsStandalone${t.capital}\") {\n            group = \"Basic\"\n            description = \"Creates the public zip bundles\"\n        }\n        zips.dependsOn(zipsTask)\n\n        def zipSdkTask = task(\"zipSdk$t.capital\", type: Zip, dependsOn: publicExportsTask) {\n            destinationDirectory = file(\"${bundlesDir}\")\n            archiveFileName = \"${sdkBundleName}.zip\"\n            includeEmptyDirs = false\n            // Sets directory and file permissions in archive for Windows\n            if (IS_WINDOWS && IS_USE_CYGWIN) {\n                dirPermissions { unix(0755) }\n                filePermissions { unix(0755) }\n            }\n            from sdkArtifactsDir\n            into \"${sdkBundleName}\"\n        }\n        zipsTask.dependsOn(zipSdkTask)\n\n        def zipDocsTask = task(\"zipDocs$t.capital\", type: Zip, dependsOn: zipSdkTask) {\n            destinationDirectory = file(\"${bundlesDir}\")\n            archiveFileName = \"${docsBundleName}.zip\"\n            includeEmptyDirs = false\n            from docsArtifactsDir\n            into \"${docsBundleName}\"\n        }\n        zipsTask.dependsOn(zipDocsTask)\n\n        def zipJmodsTask = task(\"zipJmods$t.capital\", type: Zip, dependsOn: zipDocsTask) {\n            destinationDirectory = file(\"${bundlesDir}\")\n            archiveFileName = \"${jmodsBundleName}.zip\"\n            includeEmptyDirs = false\n            from jmodsArtifactsDir\n            into \"${jmodsBundleName}\"\n        }\n        zipsTask.dependsOn(zipJmodsTask)\n    }\n}\n\n\n/******************************************************************************\n *                                                                            *\n *                             OpenJFX Stubs                                  *\n *                                                                            *\n *****************************************************************************/\n\nconfigurations {\n    openjfxStubs\n}\n\nif (IS_STUB_RUNTIME_OPENJFX) {\n    def String platform = IS_MAC ? \"mac\" : IS_WINDOWS ? \"win\" : IS_LINUX ? \"linux\" : \"\"\n    dependencies {\n        openjfxStubs \"org.openjfx:javafx-media:$STUB_RUNTIME_OPENJFX:$platform@jar\"\n        openjfxStubs \"org.openjfx:javafx-web:$STUB_RUNTIME_OPENJFX:$platform@jar\"\n    }\n}\n\n// Extract binary libraries from OpenJFX artifacts for use as stubs\ntask prepOpenJfxStubs(type: Copy) {\n    enabled = IS_STUB_RUNTIME_OPENJFX\n\n    from configurations.openjfxStubs.files.collect { zipTree(it) }\n    include(\"*.dll\")\n    include(\"*.dylib\")\n    include(\"*.so\")\n    into IS_WINDOWS ? file(\"$openjfxStubRuntime/bin\") : file(\"$openjfxStubRuntime/lib\")\n}\n\n\n/******************************************************************************\n *                                                                            *\n *                               Modules                                      *\n *                                                                            *\n *****************************************************************************/\n\next.moduleDependencies = [file(\"dependencies\")]\n\ntask buildModules {\n}\n\n// Combine the classes, lib, and bin for each module\ncompileTargets { t ->\n    def targetProperties = project.ext[t.upper]\n\n    def platformPrefix = targetProperties.platformPrefix\n    def bundledSdkDirName = \"${platformPrefix}modular-sdk\"\n    def bundledSdkDir = \"${rootProject.buildDir}/${bundledSdkDirName}\"\n    def modulesDir = \"${bundledSdkDir}/modules\"\n    def modulesCmdsDir = \"${bundledSdkDir}/modules_cmds\"\n    def modulesLibsDir = \"${bundledSdkDir}/modules_libs\"\n    def modulesSrcDir = \"${bundledSdkDir}/modules_src\"\n    def modulesConfDir = \"${bundledSdkDir}/modules_conf\"\n    def modulesLegalDir = \"${bundledSdkDir}/modules_legal\"\n    def modulesMakeDir = \"${bundledSdkDir}/make\"\n\n    final File runArgsFile = file(\"${rootProject.buildDir}/${RUNARGSFILE}\")\n    final File compileArgsFile = file(\"${rootProject.buildDir}/${COMPILEARGSFILE}\")\n\n    project.files(runArgsFile);\n\n    def buildModulesTask = task(\"buildModules$t.capital\", group: \"Build\") {\n        // BUNDLED SDK\n\n        // Copy dependencies/*/module-info.java.extra\n        // merging as needed, removing duplicates\n        // only lines with 'exports' will be copied\n        def dependencyRoots = moduleDependencies\n        if (rootProject.hasProperty(\"closedModuleDepedencies\")) {\n            dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()\n        }\n\n        // Create the inputs/outputs list first to support UP-TO-DATE\n        ArrayList outputNames = new ArrayList()\n        dependencyRoots.each { root ->\n            FileTree ft = fileTree(root).include('**/*.extra')\n            ft.each() { e->\n                inputs.file(e)\n\n                String usename = e.path\n                String filePath = e.getAbsolutePath()\n                String folderPath = root.getAbsolutePath()\n                if (filePath.startsWith(folderPath)) {\n                    usename = filePath.substring(folderPath.length() + 1);\n                }\n                if (! outputNames.contains(usename) ) {\n                    outputNames.add(usename)\n                }\n            }\n        }\n\n        outputNames.each() { e->\n                File f = new File(modulesSrcDir, e)\n                outputs.file(f)\n        }\n\n        doLast {\n            Map extras = [:]\n\n            dependencyRoots.each { root ->\n                FileTree ft = fileTree(root).include('**/*.extra')\n                ft.each() { e->\n                    String usename = e.path\n                    String filePath = e.getAbsolutePath()\n                    String folderPath = root.getAbsolutePath()\n                    if (filePath.startsWith(folderPath)) {\n                        usename = filePath.substring(folderPath.length() + 1);\n                    }\n                    if (extras.containsKey(usename)) {\n                        List<String> lines = extras.get(usename)\n                        e.eachLine { line ->\n                            line = line.trim()\n                            if (line.length() > 1 && Character.isLetter(line.charAt(0))) {\n                                lines << line\n                            }\n                        }\n\n                    } else {\n                        List<String> lines = []\n                        e.eachLine { line ->\n                            line = line.trim()\n                            if (line.length() > 1 && Character.isLetter(line.charAt(0))) {\n                                lines << line\n                            }\n                        }\n                        extras.put(usename,lines)\n                    }\n                }\n            }\n            extras.keySet().each() { e->\n                File f = new File(modulesSrcDir, e)\n                f.getParentFile().mkdirs()\n                f.delete()\n\n                extras.get(e).unique().each() { l->\n                    f << l\n                    f << \"\\n\"\n                }\n            }\n        }\n    }\n    buildModules.dependsOn(buildModulesTask)\n\n    // BUNDLED SDK\n    moduleProjList.each { project ->\n        // Copy classes, bin, and lib directories\n\n        def moduleName = project.ext.moduleName\n        def buildDir = project.buildDir\n\n        def srcClassesDir = \"${buildDir}/${platformPrefix}module-classes\"\n        def dstClassesDir = \"${modulesDir}/${moduleName}\"\n        def copyClassFilesTask = project.task(\"copyClassFiles$t.capital\", type: Copy, dependsOn: project.assemble) {\n            from srcClassesDir\n            into dstClassesDir\n            exclude(\"module-info.class\")\n        }\n\n        def srcCmdsDir = \"${buildDir}/${platformPrefix}module-bin\"\n        def dstCmdsDir = \"${modulesCmdsDir}/${moduleName}\"\n        def copyBinFilesTask = project.task(\"copyBinFiles$t.capital\", type: Copy, dependsOn: copyClassFilesTask) {\n            from srcCmdsDir\n            into dstCmdsDir\n        }\n\n        def srcLibsDir = \"${buildDir}/${platformPrefix}module-lib\"\n        def dstLibsDir = \"${modulesLibsDir}/${moduleName}\"\n        def copyLibFilesTask = project.task(\"copyLibFiles$t.capital\", type: Copy, dependsOn: copyBinFilesTask) {\n            from srcLibsDir\n            into dstLibsDir\n        }\n\n        // Copy module sources\n        // FIXME: javafx.swt sources?\n        def copySources = project.hasProperty(\"includeSources\") && project.includeSources\n        def copySourceFilesTask = project.task(\"copySourceFiles$t.capital\", type: Copy, dependsOn: copyLibFilesTask) {\n            if (copySources) {\n                from \"${project.projectDir}/src/main/java\"\n                if (project.name.equals(\"base\")) {\n                    from \"${project.projectDir}/build/gensrc/java\"\n                }\n                if (project.name.equals(\"web\")) {\n                    from \"${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java\"\n                }\n            } else {\n                from \"${project.projectDir}/src/main/java/module-info.java\"\n            }\n            into \"${modulesSrcDir}/${moduleName}\"\n            include \"**/*.java\"\n\n            if (project.hasProperty(\"sourceFilter\")) {\n                filter(project.sourceFilter)\n            }\n        }\n\n        // Copy .html and other files needed for doc bundles\n        def copyDocFiles = project.task(\"copyDocFiles$t.capital\", type: Copy, dependsOn: copySourceFilesTask) {\n            if (copySources) {\n                from(\"${project.projectDir}/src/main/docs\") {\n                    include \"**/*.html\"\n                    filter { line->\n                        line = line.replace(\"@FXVERSION@\", RELEASE_VERSION)\n                    }\n                }\n                from(\"${project.projectDir}/src/main/docs\") {\n                    exclude \"**/*.html\"\n                }\n                from(\"${project.projectDir}/src/main/java\") {\n                    exclude \"**/*.java\"\n                }\n\n                into \"${modulesSrcDir}/${moduleName}\"\n            }\n        }\n\n        // Copy make/build.properties\n        def srcMakeDir = \"${project.projectDir}/make\"\n        def dstMakeDir = \"${modulesMakeDir}/${moduleName}\"\n        def copyBuildPropertiesTask = project.task(\"copyBuildProperties$t.capital\", type: Copy, dependsOn: copyDocFiles) {\n            from srcMakeDir\n            into dstMakeDir\n        }\n\n        // Copy legal files\n        def srcLegalDir = \"${project.projectDir}/src/main/legal\"\n        def dstLegalDir = \"${modulesLegalDir}/${moduleName}\"\n        def copyLegalTask = project.task(\"copyLegal$t.capital\", type: Copy, dependsOn: copyBuildPropertiesTask) {\n            from srcLegalDir\n            into dstLegalDir\n\n            // Exclude ANGLE since we (currently) do not use it\n            exclude(\"angle.md\")\n        }\n\n        buildModulesTask.dependsOn(\n            copyClassFilesTask,\n            copyLibFilesTask,\n            copySourceFilesTask,\n            copyDocFiles,\n            copyBuildPropertiesTask,\n            copyLegalTask)\n    }\n\n    // ============================================================\n\n    def standaloneSdkDirName = \"${platformPrefix}sdk\"\n    def standaloneSdkDir = \"${TEST_SDK_PATH}/${standaloneSdkDirName}\"\n    def standaloneLibDir = \"${standaloneSdkDir}/lib\"\n    def libDest=targetProperties.libDest\n    def standaloneNativeDir = \"${standaloneSdkDir}/${libDest}\"\n    def standaloneLegalDir = \"${standaloneSdkDir}/legal\"\n    def standaloneSrcZipName = \"src.zip\"\n\n    // STANDALONE SDK\n    moduleProjList.each { project ->\n        // Copy classes, bin, and lib directories\n\n        def moduleName = project.ext.moduleName\n        def buildDir = project.buildDir\n\n        // Create modular jars\n        def srcClassesDir = \"${buildDir}/${platformPrefix}module-classes\"\n        def srcLibsDir = \"${buildDir}/${platformPrefix}module-lib\"\n        def dstModularJarDir = \"${standaloneLibDir}\"\n        def modularJarName = \"${moduleName}.jar\"\n        def modularJarTask = project.task(\"modularJarStandalone$t.capital\", type: Jar, dependsOn: project.assemble) {\n            destinationDirectory = file(\"${dstModularJarDir}\")\n            archiveFileName = modularJarName\n            includeEmptyDirs = false\n            from srcClassesDir\n        }\n\n        // Copy native libraries\n        def srcNativeDir = \"${buildDir}/${platformPrefix}module-lib\"\n        def dstNativeDir = \"${standaloneNativeDir}\"\n        def copyNativeFilesTask = project.task(\"copyNativeFilesStandalone$t.capital\", type: Copy, dependsOn: modularJarTask) {\n            from srcNativeDir\n            into dstNativeDir\n            include(\"*.dll\")\n        }\n\n        // Copy other lib files\n        def dstLibsDir = \"${standaloneLibDir}\"\n        def copyLibFilesTask = project.task(\"copyLibFilesStandalone$t.capital\", type: Copy, dependsOn: copyNativeFilesTask) {\n            from srcLibsDir\n            into dstLibsDir\n            exclude(\"*.dll\")\n        }\n\n        // Copy legal files\n        def licenseFiles = [ \"ADDITIONAL_LICENSE_INFO\", \"ASSEMBLY_EXCEPTION\", \"LICENSE\" ]\n        def srcLegalDir = \"${project.projectDir}/src/main/legal\"\n        def dstLegalDir = \"${standaloneLegalDir}/${moduleName}\"\n        def copyLegalTask = project.task(\"copyLegalStandalone$t.capital\", type: Copy, dependsOn: copyLibFilesTask) {\n\n            def rtDir = rootProject.file('.')\n            licenseFiles.each { lFile ->\n                from \"${rtDir}/${lFile}\"\n            }\n\n            from srcLegalDir\n\n            into dstLegalDir\n\n            // Exclude ANGLE since we (currently) do not use it\n            exclude(\"angle.md\")\n        }\n\n        buildModulesTask.dependsOn(\n            modularJarTask,\n            copyNativeFilesTask,\n            copyLibFilesTask,\n            copyLegalTask)\n    }\n\n    // Zip module sources for standalone SDK\n    //\n    // NOTE: the input is taken from the modular-sdk/modules_src dir\n    // so that we don't have to duplicate the logic and create another\n    // temporary directory. This is somewhat inelegant, since the bundled sdk\n    // and the standalone sdk should be independent of one another, but seems\n    // better than the alternatives.\n    def zipSourceFilesTask = project.task(\"zipSourceFilesStandalone$t.capital\", type: Zip, dependsOn: buildModulesTask) {\n        destinationDirectory = file(\"${standaloneSdkDir}\")\n        archiveFileName = standaloneSrcZipName\n        includeEmptyDirs = false\n        from modulesSrcDir\n        include \"**/*.java\"\n    }\n    buildModules.dependsOn(zipSourceFilesTask)\n\n    // ============================================================\n\n    // Maven Publications\n    def publicationDirName = \"${platformPrefix}publications\"\n    def publicationDir = \"${rootProject.buildDir}/${publicationDirName}\"\n\n    moduleProjList.each { project ->\n        // Create publications to be uploaded\n\n        def moduleName = project.ext.moduleName\n        def buildDir = project.buildDir\n\n        def dstModularJarDir=\"${publicationDir}\"\n        def srcClassesDir = \"${buildDir}/${platformPrefix}module-classes\"\n        def srcLibsDir = \"${buildDir}/${platformPrefix}module-lib\"\n\n        def modularEmptyPublicationJarName = \"${moduleName}.jar\"\n        def modularEmptyPublicationJarTask = project.task(\"moduleEmptyPublicationJar${t.capital}\", type: Jar) {\n            destinationDirectory = file(\"${dstModularJarDir}\")\n            archiveFileName = modularEmptyPublicationJarName\n            manifest {\n                attributes(\n                        'Automatic-Module-Name':\"${moduleName}Empty\"\n                )\n            }\n        }\n\n        def modularPublicationJarName = \"${moduleName}-${t.name}.jar\"\n        def modularPublicationJarTask = project.task(\"modularPublicationJar${t.capital}\", type: Jar, dependsOn: modularEmptyPublicationJarTask) {\n            destinationDirectory = file(\"${dstModularJarDir}\")\n            archiveFileName = modularPublicationJarName\n            from srcLibsDir\n            from srcClassesDir\n        }\n\n        buildModulesTask.dependsOn(modularPublicationJarTask)\n\n    }\n    // ============================================================\n\n    def buildRunArgsTask = task(\"buildRunArgs$t.capital\",\n            group: \"Build\", dependsOn: buildModulesTask) {\n        outputs.file(runArgsFile);\n        inputs.file(EXTRAADDEXPORTS);\n        doLast() {\n            List<String>modpath = []\n            List<String>modnames = []\n\n            moduleProjList.each { project ->\n                def moduleName = project.ext.moduleName\n                def dstModuleDir = cygpath(\"${modulesDir}/${moduleName}\")\n                if (HAS_JAVAFX_MODULES) {\n                    modpath <<  \"${moduleName}=${dstModuleDir}\"\n                } else {\n                    modnames << moduleName\n                }\n            }\n\n            if (HAS_JAVAFX_MODULES) {\n                writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)\n                writeCompileArgsFile(compileArgsFile, null, modpath, null)\n\n                if (rootProject.hasProperty(\"EXTRA_ADDEXPORTS_STRING\")) {\n                    runArgsFile << EXTRA_ADDEXPORTS_STRING\n                    compileArgsFile << EXTRA_ADDEXPORTS_STRING\n                }\n            } else {\n                modpath = [ cygpath(\"${standaloneLibDir}\") ]\n                writeRunArgsFile(runArgsFile, null, modpath, modnames)\n                writeCompileArgsFile(compileArgsFile, null, modpath, modnames)\n            }\n        }\n    }\n    createRunArgFiles.dependsOn(buildRunArgsTask)\n    buildModules.dependsOn(buildRunArgsTask)\n\n    def isWindows = IS_WINDOWS && t.name == \"win\";\n    def isMac = IS_MAC && t.name == \"mac\";\n\n    // Create layout for modular classes\n    moduleProjList.each { project ->\n        def buildModuleClassesTask = project.task(\"buildModule$t.capital\", group: \"Build\", type: Copy) {\n            dependsOn(project.assemble)\n            def buildDir = project.buildDir\n            def sourceBuildDirs = [\n                \"${buildDir}/classes/java/main/${project.moduleName}\",\n            ]\n\n            def moduleClassesDir = \"$buildDir/${platformPrefix}module-classes\"\n                includeEmptyDirs = false\n                sourceBuildDirs.each { d ->\n                    from d\n                }\n                into moduleClassesDir\n\n                // Exclude obsolete, experimental, or non-shipping code\n                exclude(\"version.rc\")\n                exclude(\"com/sun/glass/ui/swt\")\n                exclude(\"com/sun/javafx/tools/ant\")\n                exclude(\"com/javafx/main\")\n                exclude(\"com/sun/javafx/webkit/drt\")\n                if (!IS_INCLUDE_NULL3D) {\n                    exclude (\"com/sun/prism/null3d\")\n                }\n                if (!IS_INCLUDE_ES2) {\n                       exclude(\"com/sun/prism/es2\",\n                               \"com/sun/scenario/effect/impl/es2\")\n                }\n\n                // Exclude platform-specific classes for other platforms\n\n                if (!isMac) {\n                    exclude (\"com/sun/media/jfxmediaimpl/platform/osx\",\n                             \"com/sun/prism/es2/MacGL*\",\n                             \"com/sun/glass/events/mac\",\n                             \"com/sun/glass/ui/mac\",\n                             )\n                }\n\n                if (!isWindows) {\n                    exclude (\"**/*.hlsl\",\n                             \"com/sun/glass/ui/win\",\n                             \"com/sun/prism/d3d\",\n                             \"com/sun/prism/es2/WinGL*\",\n                             \"com/sun/scenario/effect/impl/hw/d3d\"\n                             )\n                }\n\n                if (!targetProperties.includeGTK) { //usually IS_LINUX\n                    exclude (\n                             \"com/sun/glass/ui/gtk\",\n                             \"com/sun/prism/es2/EGL*\",\n                             \"com/sun/prism/es2/X11GL*\"\n                             )\n                }\n\n                if (!targetProperties.includeEGL) {\n                    exclude (\"com/sun/prism/es2/EGL*\")\n                }\n\n                if (!targetProperties.includeMonocle) {\n                    exclude (\"com/sun/glass/ui/monocle\")\n                    exclude(\"com/sun/prism/es2/Monocle*\")\n                }\n\n                if (t.name != 'ios') {\n                    exclude (\"com/sun/media/jfxmediaimpl/platform/ios\",\n                             \"com/sun/glass/ui/ios\",\n                             \"com/sun/prism/es2/IOS*\"\n                             )\n                }\n\n                if (t.name != 'android' && t.name != 'dalvik') {\n                    exclude (\"com/sun/glass/ui/android\")\n                }\n\n                // Filter out other platform-specific classes\n                if (targetProperties.containsKey('jfxrtJarExcludes')) {\n                    exclude(targetProperties.jfxrtJarExcludes)\n                }\n\n                /* FIXME: JIGSAW -- handle this in the module itself\n                String webbld = project(\":web\").buildDir.path\n                String ctrlbld = project(\":controls\").buildDir.path\n                if (t.name == 'android') {\n                    from (\"${webbld}/classes/android\",\n                          \"${webbld}/resources/android\",\n                          \"${ctrlbld}/classes/android\",\n                          \"${ctrlbld}/resources/android\")\n                } else if (t.name == 'ios') {\n                    from (\"${webbld}/classes/ios\",\n                          \"${webbld}/resources/ios\")\n                } else {\n                    from (\"${webbld}/classes/java/main\")\n                }\n                */\n        }\n        buildModulesTask.dependsOn(buildModuleClassesTask)\n\n        if (project.tasks.getByName(\"modularJarStandalone$t.capital\") != null) {\n            project.tasks.getByName(\"modularJarStandalone$t.capital\").dependsOn(buildModuleClassesTask)\n        }\n        if (project.tasks.getByName(\"copyClassFiles$t.capital\") != null) {\n            project.tasks.getByName(\"copyClassFiles$t.capital\").dependsOn(buildModuleClassesTask)\n        }\n        if (project.tasks.getByName(\"modularPublicationJar$t.capital\") != null) {\n            project.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleClassesTask)\n        }\n    }\n\n    def buildModuleLibsTask = task(\"buildModuleLibs$t.capital\") {\n        group = \"Basic\"\n\n        def baseProject = project(\":base\");\n\n        def graphicsProject = project(\":graphics\");\n\n        def mediaProject = project(\":media\");\n\n        def webProject = project(\":web\");\n        dependsOn(webProject.assemble)\n\n        def swtProject = project(\":swt\");\n\n        def library = targetProperties.library\n\n        def doStrip = targetProperties.containsKey('strip') && IS_RELEASE\n        def strip = doStrip ? targetProperties.strip : null\n        def stripArgs = doStrip ? targetProperties.stripArgs : null\n        def doSign = rootProject.hasProperty('codeSignCmd') && IS_RELEASE\n        def signCmd = doSign ? rootProject.ext.codeSignCmd : null\n        def signArgs = doSign ? rootProject.ext.codeSignArgs : null\n        def useLipo = targetProperties.containsKey('useLipo') ? targetProperties.useLipo : false\n        def modLibDest = targetProperties.modLibDest\n        def moduleNativeDirName = \"${platformPrefix}module-$modLibDest\"\n\n        def buildModuleBaseTask = task(\"buildModuleBase$t.capital\", dependsOn: baseProject.assemble) {\n            group = \"Basic\"\n            description = \"creates javafx.base property files\"\n\n            def moduleLibDir = \"${baseProject.buildDir}/${platformPrefix}module-lib\"\n            final File javafxProperties = file(\"${moduleLibDir}/javafx.properties\")\n            outputs.file(javafxProperties)\n\n            if (targetProperties.containsKey(\"javafxPlatformProperties\")) {\n                final File javafxPlatformProperties = file(\"${moduleLibDir}/javafx.platform.properties\")\n                outputs.file(javafxPlatformProperties)\n            }\n\n            doLast {\n                mkdir moduleLibDir\n\n                javafxProperties.delete()\n                javafxProperties << \"javafx.version=$RELEASE_VERSION_SHORT\";\n                javafxProperties << \"\\n\"\n                javafxProperties << \"javafx.runtime.version=$RELEASE_VERSION_LONG\";\n                javafxProperties << \"\\n\"\n                javafxProperties << \"javafx.runtime.build=$PROMOTED_BUILD_NUMBER\";\n                javafxProperties << \"\\n\"\n                // Include any properties that have been defined (most likely in\n                // one of the various platform gradle files)\n                if (targetProperties.containsKey(\"javafxProperties\")) {\n                    javafxProperties << targetProperties.javafxProperties\n                    javafxProperties << \"\\n\"\n                }\n\n                // Embedded builds define this file as well\n                if (targetProperties.containsKey(\"javafxPlatformProperties\")) {\n                    final File javafxPlatformProperties = file(\"${moduleLibDir}/javafx.platform.properties\")\n                    javafxPlatformProperties.delete()\n                    javafxPlatformProperties << targetProperties.javafxPlatformProperties\n                    javafxPlatformProperties << \"\\n\"\n                }\n            }\n        }\n        baseProject.tasks.getByName(\"copyLibFilesStandalone$t.capital\").dependsOn(buildModuleBaseTask)\n        baseProject.tasks.getByName(\"copyLibFiles$t.capital\").dependsOn(buildModuleBaseTask)\n        baseProject.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleBaseTask)\n\n        def buildModuleGraphicsTask = task(\"buildModuleGraphics$t.capital\", type: Copy, dependsOn: graphicsProject.assemble) {\n            group = \"Basic\"\n            description = \"copies javafx.graphics native libraries\"\n\n            def destDirName = \"${graphicsProject.buildDir}/${moduleNativeDirName}\"\n            into destDirName\n\n            from(\"${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}\")\n            def libs = ['font', 'prism', 'prismSW', 'glass', 'iio']\n            if (IS_INCLUDE_ES2) {\n                libs += ['prismES2'];\n            }\n            if (IS_COMPILE_PANGO) {\n                libs += ['fontFreetype', 'fontPango'];\n            }\n            libs.each { lib ->\n                def variants = targetProperties[lib].containsKey('variants') && !useLipo ? targetProperties[lib].variants : [null]\n                variants.each { variant ->\n                    def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]\n                    from (\"${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}\")\n                }\n            }\n            if (IS_WINDOWS) {\n                from (\"${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}\");\n                targetProperties.VSDLLs.each { vslib ->\n                    from (\"$vslib\");\n                }\n                targetProperties.WinSDKDLLs.each { winsdklib ->\n                    from (\"$winsdklib\");\n                }\n            }\n\n            if (doStrip) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n                    // FIXME: if we ever need to strip on Windows platforms, we must\n                    // exclude the Microsoft DLLs (VSDLLNames and WinSDKDLLNames)\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ strip, stripArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n            if (doSign) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n                    // FIXME: if we ever need to sign on Windows platforms, we must\n                    // exclude the Microsoft DLLs (VSDLLNames and WinSDKDLLNames)\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ signCmd, signArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n        }\n        graphicsProject.tasks.getByName(\"copyNativeFilesStandalone$t.capital\").dependsOn(buildModuleGraphicsTask)\n        graphicsProject.tasks.getByName(\"copyLibFilesStandalone$t.capital\").dependsOn(buildModuleGraphicsTask)\n        graphicsProject.tasks.getByName(\"copyLibFiles$t.capital\").dependsOn(buildModuleGraphicsTask)\n        graphicsProject.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleGraphicsTask)\n\n        def buildModuleMediaTask = task(\"buildModuleMedia$t.capital\", type: Copy, dependsOn: [mediaProject.assemble, prepOpenJfxStubs]) {\n            group = \"Basic\"\n            description = \"copies javafx.media native libraries\"\n\n            def destDirName = \"${mediaProject.buildDir}/${moduleNativeDirName}\"\n            into destDirName\n\n            def mediaBuildType = project(\":media\").ext.buildType\n            if (IS_COMPILE_MEDIA) {\n                [ \"fxplugins\", \"gstreamer-lite\", \"jfxmedia\" ].each { name ->\n                    from (\"${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}\") }\n\n                if (t.name == \"mac\") {\n                    // OSX media natives\n                    [ \"jfxmedia_qtkit\", \"jfxmedia_avf\", \"glib-lite\" ].each { name ->\n                        from (\"${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}\") }\n                } else if (t.name == \"linux\") {\n                    from(\"${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}\") { include \"libavplugin*.so\" }\n                } else from (\"${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(\"glib-lite\")}\")\n            } else {\n                if (t.name != \"android\"  && t.name != \"dalvik\" ) {\n                    [ \"fxplugins\", \"gstreamer-lite\", \"jfxmedia\" ].each { name ->\n                        from (\"$MEDIA_STUB/${library(name)}\") }\n                }\n\n                if (t.name == \"mac\") {\n                    // copy libjfxmedia_{avf,qtkit}.dylib if they exist\n                    [ \"jfxmedia_qtkit\", \"jfxmedia_avf\", \"glib-lite\" ].each { name ->\n                        from (\"$MEDIA_STUB/${library(name)}\") }\n                } else if (t.name == \"linux\") {\n                    from(MEDIA_STUB) { include \"libavplugin*.so\" }\n                }\n                else if (t.name != \"android\"  && t.name != \"dalvik\" ) {\n                    from (\"$MEDIA_STUB/${library(\"glib-lite\")}\")\n                }\n            }\n\n            if (doStrip && IS_COMPILE_MEDIA) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ strip, stripArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n            if (doSign && IS_COMPILE_MEDIA) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n                    // FIXME: if we ever need to sign on Windows platforms, we must\n                    // exclude the Microsoft DLLs (VSDLLNames and WinSDKDLLNames)\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ signCmd, signArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n        }\n        mediaProject.tasks.getByName(\"copyNativeFilesStandalone$t.capital\").dependsOn(buildModuleMediaTask)\n        mediaProject.tasks.getByName(\"copyLibFilesStandalone$t.capital\").dependsOn(buildModuleMediaTask)\n        mediaProject.tasks.getByName(\"copyLibFiles$t.capital\").dependsOn(buildModuleMediaTask)\n        mediaProject.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleMediaTask)\n\n        def buildModuleWeb = task(\"buildModuleWeb$t.capital\", type: Copy, dependsOn: [webProject.assemble, prepOpenJfxStubs]) {\n            group = \"Basic\"\n            description = \"copies javafx.web native libraries\"\n\n            def destDirName = \"${webProject.buildDir}/${moduleNativeDirName}\"\n            into destDirName\n\n            if (IS_COMPILE_WEBKIT) {\n                from (\"${webProject.buildDir}/libs/${t.name}/${library('jfxwebkit')}\")\n            } else {\n                if (t.name != \"android\" && t.name != \"ios\" && t.name != \"dalvik\") {\n                    from (\"$WEB_STUB/${library('jfxwebkit')}\")\n                }\n            }\n\n            if (doStrip && IS_COMPILE_WEBKIT) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ strip, stripArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n            if (doSign && IS_COMPILE_WEBKIT) {\n                doLast {\n                    def inputFiles = fileTree(dir: destDirName)\n                    inputFiles.include(\"*.dll\")\n                    inputFiles.include(\"*.dylib\")\n                    inputFiles.include(\"*.so\")\n                    // FIXME: if we ever need to sign on Windows platforms, we must\n                    // exclude the Microsoft DLLs (VSDLLNames and WinSDKDLLNames)\n\n                    inputFiles.each { file ->\n                        exec {\n                            def cmd = [ signCmd, signArgs, file ].flatten()\n                            commandLine(cmd)\n                        }\n                    }\n                }\n            }\n        }\n        webProject.tasks.getByName(\"copyNativeFilesStandalone$t.capital\").dependsOn(buildModuleWeb)\n        webProject.tasks.getByName(\"copyLibFilesStandalone$t.capital\").dependsOn(buildModuleWeb)\n        webProject.tasks.getByName(\"copyLibFiles$t.capital\").dependsOn(buildModuleWeb)\n        webProject.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleWeb)\n\n        def buildModuleSWT = task(\"buildModuleSWT$t.capital\", type: Copy) {\n            group = \"Basic\"\n            description = \"copies SWT JAR\"\n\n            // FIXME: the following is a hack to workaround the fact that there\n            // is no way to deliver javafx-swt.jar other than in one of the\n            // existing runtime modules.\n\n            dependsOn(buildModuleGraphicsTask) // we copy to the graphics module\n\n            if (COMPILE_SWT) {\n                def javafxSwtTask = tasks.getByName(\"javafxSwt$t.capital\");\n                dependsOn(javafxSwtTask)\n                //enabled = COMPILE_SWT\n            }\n\n            // Copy javafx-swt.jar to the javafx-graphics module lib dir\n            from \"${swtProject.buildDir}/libs/javafx-swt.jar\"\n            into \"${graphicsProject.buildDir}/${platformPrefix}module-lib\"\n        }\n        graphicsProject.tasks.getByName(\"copyNativeFilesStandalone$t.capital\").dependsOn(buildModuleSWT)\n        graphicsProject.tasks.getByName(\"copyLibFilesStandalone$t.capital\").dependsOn(buildModuleSWT)\n        graphicsProject.tasks.getByName(\"copyLibFiles$t.capital\").dependsOn(buildModuleSWT)\n        graphicsProject.tasks.getByName(\"modularPublicationJar$t.capital\").dependsOn(buildModuleSWT)\n\n        dependsOn(\n            buildModuleBaseTask,\n            buildModuleGraphicsTask,\n            buildModuleMediaTask,\n            buildModuleWeb,\n            buildModuleSWT,\n            )\n    }\n    buildModulesTask.dependsOn(buildModuleLibsTask)\n\n    def zipTask = project.task(\"buildModuleZip$t.capital\", type: Zip, group: \"Build\",\n            dependsOn: buildModulesTask ) {\n\n        // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name\n        def jfxBundle = \"${platformPrefix}javafx-exports.zip\"\n\n        doFirst() {\n            file(\"${rootProject.buildDir}/${jfxBundle}\").delete()\n        }\n\n        archiveFileName = jfxBundle\n        destinationDirectory = file(\"${rootProject.buildDir}\")\n        includeEmptyDirs = false\n        from \"${bundledSdkDir}\"\n    }\n    jdkZip.dependsOn(zipTask)\n\n    def buildSdkDir = \"${rootProject.buildDir}/sdk\"\n    def buildShimsDir = \"${rootProject.buildDir}/shims\"\n    def sdkShimZipTask = project.task(\"sdkShimsZip$t.capital\", type: Zip, group: \"Build\",\n            dependsOn: [shims] ) {\n\n        def sdkShimsBundle = \"${platformPrefix}javafx-sdk-shims.zip\"\n\n        doFirst() {\n            file(\"${rootProject.buildDir}/${sdkShimsBundle}\").delete()\n        }\n\n        if (IS_WINDOWS && IS_USE_CYGWIN) {\n            dirPermissions { unix(0755) }\n            filePermissions { unix(0755) }\n        }\n\n        archiveFileName = sdkShimsBundle\n        destinationDirectory = file(\"${rootProject.buildDir}\")\n        includeEmptyDirs = false\n        from (\"${buildSdkDir}\") {\n            into \"sdk\"\n        }\n        from (\"${buildShimsDir}\") {\n            into \"shims\"\n        }\n    }\n    jdkZip.dependsOn(sdkShimZipTask)\n\n    Task testArgFiles = task(\"createTestArgfiles${t.capital}\") {\n\n        File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)\n        //test (shimed) version\n        File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)\n\n        outputs.file(testRunArgsFile)\n        outputs.file(testCompileArgsFile)\n        inputs.file(EXTRAADDEXPORTS);\n\n        doLast() {\n            rootProject.buildDir.mkdir()\n\n            List<String> projNames = []\n            moduleProjList.each { project ->\n                projNames << project.name\n            }\n\n            // And the test (shimed) variation...\n\n            testRunArgsFile.delete()\n            testCompileArgsFile.delete()\n\n            List<String> modpath = []\n\n            if (HAS_JAVAFX_MODULES) {\n                moduleProjList.each { project ->\n                    if (project.hasProperty(\"moduleName\") && project.buildModule) {\n                        File dir;\n                        if (project.sourceSets.hasProperty('shims')) {\n                           dir = new File(rootProject.buildDir, \"shims/${project.ext.moduleName}\")\n                        } else {\n                           dir = new File(rootProject.buildDir, \"modular-sdk/modules/${project.ext.moduleName}\")\n                        }\n\n                        def dstModuleDir = cygpath(dir.path)\n                        modpath << \"${project.ext.moduleName}=${dstModuleDir}\"\n\n                    }\n                }\n\n                writeCompileArgsFile(testCompileArgsFile, null, modpath, null)\n                writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)\n\n                if (rootProject.hasProperty(\"EXTRA_ADDEXPORTS_STRING\")) {\n                    testCompileArgsFile << EXTRA_ADDEXPORTS_STRING\n                    testRunArgsFile << EXTRA_ADDEXPORTS_STRING\n                }\n            } else  {\n                def modnames = []\n                moduleProjList.each { project ->\n                    if (project.hasProperty(\"moduleName\") && project.buildModule) {\n                        modnames << project.ext.moduleName\n                        File dir;\n                        if (project.sourceSets.hasProperty('shims')) {\n                           dir = new File(TEST_SDK_PATH, \"shims/${project.ext.moduleName}\")\n                        } else {\n                           dir = new File(TEST_SDK_PATH, \"sdk/lib/${project.ext.moduleName}.jar\")\n                        }\n\n                        def dstModuleDir = cygpath(dir.path)\n                        modpath << \"${dstModuleDir}\"\n                    }\n                }\n\n                writeCompileArgsFile(testCompileArgsFile, null, modpath, modnames)\n                writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)\n\n            }\n        }\n    }\n    sdk.dependsOn(testArgFiles)\n    createTestArgfiles.dependsOn(testArgFiles)\n\n    def sdkTask = tasks.getByName(\"sdk${t.capital}\");\n    sdkTask.dependsOn(buildModulesTask)\n}\nsdk.dependsOn(buildModules)\n\n// Build the jmod for each module for the standalone SDK only.\ncompileTargets { t ->\n    if (!HAS_JAVAFX_MODULES) {\n        def targetProperties = project.ext[t.upper]\n\n        def platformPrefix = targetProperties.platformPrefix\n        def jmodsDirName = \"${platformPrefix}jmods\"\n        def jmodsDir = \"${rootProject.buildDir}/${jmodsDirName}\"\n        def standaloneSdkDirName = \"${platformPrefix}sdk\"\n        def standaloneSdkDir = \"${rootProject.buildDir}/${standaloneSdkDirName}\"\n        def standaloneLegalDir = \"${standaloneSdkDir}/legal\"\n\n        moduleProjList.each { project ->\n            def moduleName = project.ext.moduleName\n            def buildDir = project.buildDir\n\n            def srcClassesDir = \"${buildDir}/${platformPrefix}module-classes\"\n            def srcLibDir = \"${buildDir}/${platformPrefix}module-lib\"\n            def srcLegalDir = \"${standaloneLegalDir}/${moduleName}\"\n\n            def jmodLibDir = srcLibDir\n            if (IS_WINDOWS) {\n                jmodLibDir = \"${srcLibDir}-jmod\"\n            }\n\n            def jmodName = \"${moduleName}.jmod\"\n            def jmodFile = \"${jmodsDir}/${jmodName}\"\n\n            def incubating = project.hasProperty(\"incubating\") && project.ext.incubating\n\n            // On Windows, copy the native libraries in the jmod image\n            // to a \"javafx\" subdir to avoid conflicting with the Microsoft\n            // DLLs that are shipped with the JDK\n            def jmodCopyLibTask = project.task(\"jmodCopyLib$t.capital\", type: Copy, dependsOn: sdk) {\n                enabled = IS_WINDOWS\n\n                group = \"Basic\"\n                description = \"copied Windows DLLs into javafx subdir for jmods\"\n\n                into jmodLibDir\n\n                from (srcLibDir) {\n                    exclude(\"*.dll\")\n                }\n\n                from (srcLibDir) {\n                    include(\"*.dll\")\n                    into(\"javafx\")\n                }\n            }\n\n            def jmodTask = project.task(\"jmod$t.capital\", group: \"Build\", dependsOn: [sdk, jmodCopyLibTask]) {\n                doLast {\n                    mkdir jmodsDir\n                    delete(jmodFile);\n                    exec {\n                        commandLine(JMOD)\n                        args(\"create\")\n                        args(\"--class-path\")\n                        args(srcClassesDir)\n                        args(\"--module-version\", \"$RELEASE_VERSION_SHORT\")\n                        // Not all modules have a \"lib\" dir\n                        if (file(jmodLibDir).isDirectory()) {\n                            args(\"--libs\")\n                            args(jmodLibDir)\n                        }\n                        args(\"--legal-notices\")\n                        args(srcLegalDir)\n                        if (sourceDateEpoch != null) {\n                            args(\"--date\", extendedTimestamp)\n                        }\n                        if (incubating) {\n                            args(\"--do-not-resolve-by-default\")\n                            args(\"--warn-if-resolved=incubating\")\n                        }\n                        args(jmodFile)\n                    }\n                }\n            }\n\n            jmods.dependsOn(jmodTask)\n        }\n    }\n}\n\n/******************************************************************************\n *                                                                            *\n *                              BUILD_CLOSED                                  *\n *                                                                            *\n * This next section should remain at the end of the build script. It allows  *\n * for a \"supplemental\" gradle file to be used to extend the normal build     *\n * structure. For example, this is used for passing a supplemental gradle     *\n * file for producing official JavaFX builds.                                 *\n *                                                                            *\n *****************************************************************************/\n\nif (BUILD_CLOSED) {\n    apply from: supplementalBuildFile\n}\n\ntask showFlags {\n}\n\ncompileTargets { t ->\n    // Every platform must define these variables\n    def props = project.ext[t.upper];\n    showFlags.dependsOn(\n        project.task(\"showFlags$t.upper\") {\n            doLast() {\n                println \"Properties set for $t.upper\"\n                props.each { println it }\n            }\n        }\n    )\n\n}\n"
        },
        {
          "name": "build.properties",
          "type": "blob",
          "size": 5.0947265625,
          "content": "#\n# Copyright (c) 2013, 2024, Oracle and/or its affiliates. All rights reserved.\n# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n#\n# This code is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 2 only, as\n# published by the Free Software Foundation.  Oracle designates this\n# particular file as subject to the \"Classpath\" exception as provided\n# by Oracle in the LICENSE file that accompanied this code.\n#\n# This code is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n# version 2 for more details (a copy is included in the LICENSE file that\n# accompanied this code).\n#\n# You should have received a copy of the GNU General Public License version\n# 2 along with this work; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n# or visit www.oracle.com if you need additional information or have any\n# questions.\n#\n\n##############################################################################\n#\n# Build properties for defining the JavaFX version number\n#\n##############################################################################\n\n# NOTE: It is no longer necessary to modify this file to switch the\n# milestone to fcs.\n#\n# By default the milestone is set to early access (ea) for all builds. It\n# is overridden by the RE build script, which passes \"-PMILESTONE_FCS=true\"\n# to gradle when the BUILD_MILESTONE env variable is set to \"fcs\". This\n# will cause the suffix to become blank.\njfx.release.suffix=-ea\n\n# Set this property to the name of the experimental feature for your branch in sandbox.\n# Do not include a dash in the name. For example, if you have a sandbox branch\n# named myfeature you might set jfx.experimental.feature.name=myfeature\njfx.experimental.feature.name=\n\n# UPDATE THE FOLLOWING VALUES FOR A NEW RELEASE\njfx.release.major.version=24\njfx.release.minor.version=0\njfx.release.security.version=0\njfx.release.patch.version=0\n\n# Note: The release version is now calculated in build.gradle as the\n# dot-separated concatenation of the previous four fields with trailing zero\n# fields removed\n\n##############################################################################\n#\n# Build properties for generating javadoc\n#\n##############################################################################\n\njavadoc.bottom=<small><a href=\"http://bugreport.java.com/bugreport/\">Report a bug or suggest an enhancement</a><br> Copyright &copy; 2008, 2025, Oracle and/or its affiliates. All rights reserved.@DRAFT_UNLESS_FCS@<!-- Version @FULL_VERSION@ --></small>\n\njavadoc.title=JavaFX @JAVADOC_VERSION@\njavadoc.header=<div><strong>JavaFX @JAVADOC_VERSION@@DRAFT_UNLESS_FCS@</strong></div>\njavadoc.top=<div style=\"padding: 6px; text-align: center; font-size: 80%;\">This specification is not final and is subject to change. Use is subject to license terms.</div>\n\n##############################################################################\n#\n# Build properties for defining the version of JDK used to build FX\n#\n# jfx.build.jdk.buildnum should be set to the JDK build number used to\n# compile FX. This variable is read by the Hudson build scripts to\n# select the JDK.\n#\n# jdk.docs.version should be set to the JDK feature version used for\n# javadoc links to JDK classes from JavaFX classes. It is typically the\n# feature version corresponding to the JDK used to compile JavaFX.\n#\n# jfx.build.jdk.buildnum.min should be set to the lowest version that\n# supports building FX (which must be <= jfx.build.jdk.buildnum)\n#\n# jfx.jdk.target.version is set to the minimum runtime version that\n# JavaFX will run on. This is passed to javac as the value of \"--release\",\n# so it also defines the language features that can be used.\n#\n##############################################################################\n\n# JDK\njdk.docs.version=23\njfx.build.jdk.version=23\njfx.build.jdk.buildnum=37\njfx.build.jdk.version.min=22\njfx.build.jdk.buildnum.min=36\njfx.jdk.target.version=22\n\n# The jfx.gradle.version property defines the version of gradle that is\n# used in the build. It must match the version number in\n# gradle/wrapper/gradle-wrapper.properties and should also be recorded in\n# The jfx.gradle.version.min property defines the minimum version of gradle\n# that is supported. It must be <= jfx.gradle.version.\njfx.gradle.version=8.10.2\njfx.gradle.version.min=8.5\n\n# Toolchains\njfx.build.linux.gcc.version=gcc13.2.0-OL6.4+1.0\njfx.build.windows.msvc.version=VS2022-17.6.5+1.0\njfx.build.macosx.xcode.version=Xcode14.3.1+1.0\n\n# Build tools\njfx.build.cmake.version=3.22.3\njfx.build.ninja.version=1.8.2\njfx.build.ant.version=1.10.5\n\n# Dependencies\neclipse.updatesite.version=4.30/R-4.30-202312010110\nswt.version=3.124.200.v20231113-1355\n\njunit.version=4.13.2\njunit.jupiter.version=5.11.3\njunit.platform.version=1.11.3\nhamcrest.version=1.3\nopentest4j.version=1.3.0\napiguardian.version=1.1.2\n\nicu.version=74.2\nantlr4.version=4.7.2\nlucene.version=7.7.3\n"
        },
        {
          "name": "buildSrc",
          "type": "tree",
          "content": null
        },
        {
          "name": "checkstyle.xml",
          "type": "blob",
          "size": 7.93359375,
          "content": "<?xml version=\"1.0\"?>\n<!DOCTYPE module PUBLIC\n          \"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\"\n          \"https://checkstyle.org/dtds/configuration_1_3.dtd\">\n\n<!--\n\n  Checkstyle configuration that checks the sun coding conventions from:\n\n    - the Java Language Specification at\n      https://docs.oracle.com/javase/specs/jls/se11/html/index.html\n\n    - the Sun Code Conventions at https://www.oracle.com/java/technologies/javase/codeconventions-contents.html\n\n    - the Javadoc guidelines at\n      https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html\n\n    - the JDK Api documentation https://docs.oracle.com/en/java/javase/11/\n\n    - some best practices\n\n  Checkstyle is very configurable. Be sure to read the documentation at\n  https://checkstyle.org (or in your downloaded distribution).\n\n  Most Checks are configurable, be sure to consult the documentation.\n\n  To completely disable a check, just comment it out or delete it from the file.\n  To suppress certain violations please review suppression filters.\n\n  Finally, it is worth reading the documentation.\n\n-->\n\n<module name=\"Checker\">\n  <!--\n      If you set the basedir property below, then all reported file\n      names will be relative to the specified directory. See\n      https://checkstyle.org/config.html#Checker\n\n      <property name=\"basedir\" value=\"${basedir}\"/>\n  -->\n  <property name=\"severity\" value=\"error\"/>\n\n  <property name=\"fileExtensions\" value=\"java, properties, xml\"/>\n\n  <!-- Excludes all 'module-info.java' files              -->\n  <!-- See https://checkstyle.org/config_filefilters.html -->\n  <module name=\"BeforeExecutionExclusionFileFilter\">\n    <property name=\"fileNamePattern\" value=\"module\\-info\\.java$\"/>\n  </module>\n\n  <!-- https://checkstyle.org/config_filters.html#SuppressionFilter -->\n  <module name=\"SuppressionFilter\">\n    <property name=\"file\" value=\"${org.checkstyle.sun.suppressionfilter.config}\"\n              default=\"checkstyle-suppressions.xml\" />\n    <property name=\"optional\" value=\"true\"/>\n  </module>\n\n  <!-- Checks that a package-info.java file exists for each package.     -->\n  <!-- See https://checkstyle.org/config_javadoc.html#JavadocPackage -->\n  <module name=\"JavadocPackage\"/>\n\n  <!-- Checks whether files end with a new line.                        -->\n  <!-- See https://checkstyle.org/config_misc.html#NewlineAtEndOfFile -->\n  <module name=\"NewlineAtEndOfFile\"/>\n\n  <!-- Checks that property files contain the same keys.         -->\n  <!-- See https://checkstyle.org/config_misc.html#Translation -->\n  <module name=\"Translation\"/>\n\n  <!-- Checks for Size Violations.                    -->\n  <!-- See https://checkstyle.org/config_sizes.html -->\n  <module name=\"FileLength\"/>\n  <module name=\"LineLength\">\n    <property name=\"max\" value=\"120\"/>\n    <property name=\"fileExtensions\" value=\"java\"/>\n  </module>\n\n  <!-- Checks for whitespace                               -->\n  <!-- See https://checkstyle.org/config_whitespace.html -->\n  <module name=\"FileTabCharacter\"/>\n\n  <!-- Miscellaneous other checks.                   -->\n  <!-- See https://checkstyle.org/config_misc.html -->\n  <module name=\"RegexpSingleline\">\n    <property name=\"format\" value=\"\\s+$\"/>\n    <property name=\"minimum\" value=\"0\"/>\n    <property name=\"maximum\" value=\"0\"/>\n    <property name=\"message\" value=\"Line has trailing spaces.\"/>\n  </module>\n\n  <!-- Checks for Headers                                -->\n  <!-- See https://checkstyle.org/config_header.html   -->\n  <!-- <module name=\"Header\"> -->\n  <!--   <property name=\"headerFile\" value=\"${checkstyle.header.file}\"/> -->\n  <!--   <property name=\"fileExtensions\" value=\"java\"/> -->\n  <!-- </module> -->\n\n  <module name=\"TreeWalker\">\n\n    <!-- Checks for Javadoc comments.                     -->\n    <!-- See https://checkstyle.org/config_javadoc.html -->\n    <module name=\"InvalidJavadocPosition\"/>\n    <module name=\"JavadocMethod\">\n      <property name=\"accessModifiers\" value=\"public\"/>\n      <property name=\"allowMissingParamTags\" value=\"true\"/>\n    </module>\n    <module name=\"JavadocType\"/>\n    <module name=\"JavadocVariable\">\n      <property name=\"scope\" value=\"public\"/>\n    </module>\n    <module name=\"JavadocStyle\"/>\n<!--    <module name=\"MissingJavadocMethod\">-->\n<!--      <property name=\"scope\" value=\"public\"/>-->\n<!--      <property name=\"ignoreMethodNamesRegex\" value=\"^test.*$\"/>-->\n<!--    </module>-->\n\n    <!-- Checks for Naming Conventions.                  -->\n    <!-- See https://checkstyle.org/config_naming.html -->\n    <module name=\"ConstantName\"/>\n    <module name=\"LocalFinalVariableName\"/>\n    <module name=\"LocalVariableName\"/>\n    <module name=\"MemberName\"/>\n    <module name=\"MethodName\">\n      <property name=\"format\" value=\"^[a-z_][a-zA-Z0-9]*$\"/>\n    </module>\n    <module name=\"PackageName\"/>\n    <module name=\"ParameterName\"/>\n    <module name=\"StaticVariableName\"/>\n    <module name=\"TypeName\"/>\n\n    <!-- Checks for imports                              -->\n    <!-- See https://checkstyle.org/config_imports.html -->\n    <module name=\"AvoidStarImport\"/>\n<!--    <module name=\"IllegalImport\"/> &lt;!&ndash; defaults to sun.* packages &ndash;&gt;-->\n    <module name=\"RedundantImport\"/>\n    <module name=\"UnusedImports\">\n      <property name=\"processJavadoc\" value=\"false\"/>\n    </module>\n\n    <!-- Checks for Size Violations.                    -->\n    <!-- See https://checkstyle.org/config_sizes.html -->\n    <module name=\"MethodLength\"/>\n    <module name=\"ParameterNumber\">\n      <property name=\"max\" value=\"20\"/>\n    </module>\n\n    <!-- Checks for whitespace                               -->\n    <!-- See https://checkstyle.org/config_whitespace.html -->\n    <module name=\"EmptyForIteratorPad\"/>\n    <module name=\"GenericWhitespace\"/>\n    <module name=\"MethodParamPad\"/>\n    <module name=\"NoWhitespaceAfter\"/>\n    <module name=\"NoWhitespaceBefore\"/>\n    <module name=\"OperatorWrap\"/>\n    <module name=\"ParenPad\"/>\n    <module name=\"TypecastParenPad\"/>\n    <module name=\"WhitespaceAfter\"/>\n    <module name=\"WhitespaceAround\"/>\n\n    <!-- Modifier Checks                                    -->\n    <!-- See https://checkstyle.org/config_modifier.html -->\n    <module name=\"ModifierOrder\"/>\n    <module name=\"RedundantModifier\"/>\n\n    <!-- Checks for blocks. You know, those {}'s         -->\n    <!-- See https://checkstyle.org/config_blocks.html -->\n    <module name=\"AvoidNestedBlocks\"/>\n    <module name=\"EmptyBlock\"/>\n    <module name=\"LeftCurly\"/>\n    <module name=\"NeedBraces\"/>\n    <module name=\"RightCurly\"/>\n\n    <!-- Checks for common coding problems               -->\n    <!-- See https://checkstyle.org/config_coding.html -->\n    <module name=\"EmptyStatement\"/>\n    <module name=\"EqualsHashCode\"/>\n    <module name=\"HiddenField\">\n      <property name=\"tokens\" value=\"VARIABLE_DEF, PATTERN_VARIABLE_DEF, LAMBDA, RECORD_COMPONENT_DEF\"/>\n    </module>\n    <module name=\"IllegalInstantiation\"/>\n    <module name=\"InnerAssignment\"/>\n<!--    <module name=\"MagicNumber\"/>-->\n    <module name=\"MissingSwitchDefault\"/>\n    <module name=\"MultipleVariableDeclarations\"/>\n    <module name=\"SimplifyBooleanExpression\"/>\n    <module name=\"SimplifyBooleanReturn\"/>\n\n    <!-- Checks for class design                         -->\n    <!-- See https://checkstyle.org/config_design.html -->\n    <module name=\"DesignForExtension\"/>\n    <module name=\"FinalClass\"/>\n    <module name=\"HideUtilityClassConstructor\"/>\n    <module name=\"InterfaceIsType\"/>\n    <module name=\"VisibilityModifier\"/>\n\n    <!-- Miscellaneous other checks.                   -->\n    <!-- See https://checkstyle.org/config_misc.html -->\n    <module name=\"ArrayTypeStyle\"/>\n<!--    <module name=\"FinalParameters\"/>-->\n    <module name=\"TodoComment\"/>\n    <module name=\"UpperEll\"/>\n\n    <!-- https://checkstyle.org/config_filters.html#SuppressionXpathFilter -->\n    <module name=\"SuppressionXpathFilter\">\n      <property name=\"file\" value=\"${org.checkstyle.sun.suppressionxpathfilter.config}\"\n                default=\"checkstyle-xpath-suppressions.xml\" />\n      <property name=\"optional\" value=\"true\"/>\n    </module>\n\n  </module>\n\n</module>\n"
        },
        {
          "name": "doc-files",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradle.properties.template",
          "type": "blob",
          "size": 13.1826171875,
          "content": "#\n# Copyright (c) 2013, 2023, Oracle and/or its affiliates. All rights reserved.\n# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n#\n# This code is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 2 only, as\n# published by the Free Software Foundation.  Oracle designates this\n# particular file as subject to the \"Classpath\" exception as provided\n# by Oracle in the LICENSE file that accompanied this code.\n#\n# This code is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n# version 2 for more details (a copy is included in the LICENSE file that\n# accompanied this code).\n#\n# You should have received a copy of the GNU General Public License version\n# 2 along with this work; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n# or visit www.oracle.com if you need additional information or have any\n# questions.\n#\n\n#####################################################################################\n#                                                                                   #\n# This properties file allows for a developer to override various properties used   #\n# when building JavaFX. Any settings you configure in the gradle.properties file    #\n# will have precedence over any values specified in the build script itself.        #\n#                                                                                   #\n#####################################################################################\n\n# By default, the build will 'fail fast' if the version of gradle is incompatible.\n# Set this flag to false to have it print a warning and try to build anyway.\n\n#GRADLE_VERSION_CHECK = false\n\n# These properties give developers the chance to skip building WebKit and/or\n# GStreamer. WebKit takes a fair amount of time to build (more than 50% of the\n# overall full build time is taken by WebKit), so allowing a developer to\n# selectively enable building of WebKit is important. To build WebKit or\n# GStreamer, uncomment the appropriate lines below.\n\n#COMPILE_WEBKIT = true\n#COMPILE_MEDIA = true\n\n# These properties can be used to support building the libav stubs in support of\n# running on multiple Linux systems. BUILD_LIBAV_STUBS is intended to build a\n# distribution that will run on multiple versions of Linux. BUILD_WORKING_LIBAV\n# is only intended for developers to test their code locally without needing an\n# installed libav; most developers will not ever need to use this option.\n# BUILD_LIBAV_STUBS is valid with COMPILE_MEDIA = true and BUILD_WORKING_LIBAV\n# is valid with COMPILE_MEDIA = true and BUILD_LIBAV_STUBS = true on Linux\n# platforms only.\n\n# BUILD_LIBAV_STUBS = true\n# BUILD_WORKING_LIBAV = true\n\n# Specifies whether to include the Null3D pipeline, which can be used for\n# performance debugging.\n# Uncomment this flag in order to include the Null3D pipeline in the build.\n\n#INCLUDE_NULL3D = true\n\n# Specifies whether to include the ES2 graphics pipeline.\n# By default, this pipeline is not included on the Windows platform.\n# Uncomment this flag in order to include the ES2 pipeline in the build.\n\n#INCLUDE_ES2 = true\n\n# Specifies whether to build SDK for running the provided test task.\n# By default, it is set to false and the tests are running of the\n# fresh-built SDK. If set to true, this flag disables all non test tasks,\n# and it is expected that sdk and shims tasks have been previously built.\n\n#TEST_ONLY = true\n\n# Specifies whether to do a full test run or a \"smoke test\" run. By default we\n# do a smoke test run which excludes all tests that show a window or play media.\n# Certain long running tests might also be excluded when this is not set.\n\n#FULL_TEST = true\n\n# Specifies whether to enable robot-based visual tests when running a full test.\n# This flag is ignored if FULL_TEST is false.\n\n#USE_ROBOT = true\n\n# Specifies whether to run unstable tests, that are not suitable for automated builds\n\n#UNSTABLE_TEST = false\n\n# Specifies whether to run system tests that depend on AWT.\n# This flag is ignored if FULL_TEST is false.\n\n#AWT_TEST = false\n\n# Specifies whether to run system tests that depend on SWT.\n# This flag is ignored if FULL_TEST is false.\n\n#SWT_TEST = false\n\n# Specify the COMPILE_TARGETS when performing cross compiles. A Cross-Compile is\n# when you build for a platform other than the one you are building on. For example,\n# to build for Apple iOS, you would specify ios as one of the COMPILE_TARGETS.\n# The case is not significant. Valid cross build targets for each OS include:\n#\n#   OS             Target\n#  ------------------------------\n#   Mac             mac\n#   Mac             ios\n#   Mac             swt\n#   Mac             android\n#   Linux           linux\n#   Linux           armv6hf\n#   Linux           armv6sf\n#   Linux           swt\n#   Linux           android\n#   Windows         win\n#   Windows         swt\n#   Window          android\n#\n# The compile targets are listed as a comma separated list. Alternatively,\n# you can set COMPILE_TARGETS to \"all\" and every appropriate compile target\n# for your current machine configuration will be used. We will look up and\n# determine whether, for example, you have the Android tools installed and\n# only build Android if those tools are installed.\n#\n# If you manually specify a compile target which cannot be built, then the\n# build will fail. If you specify \"all\" then only those targets which can\n# be built will be attempted. For example, if your system is missing the\n# required toolchains for embedded builds, then armv6 builds would not\n# even be attempted when \"all\" is set.\n\n#COMPILE_TARGETS = all\n\n# The JDK_HOME must either be specified or will be inferred based on the JDK / JRE used to\n# execute Gradle. From the JDK_HOME are derived the JAVA, JAVAC, JAVADOC, and STUB_RUNTIME\n# properties, although each of these may be specified individually. In addition, the LIBRARY_STUB\n# property is derived from STUB_RUNTIME. Normally the gradle build\n# will work based on whatever \"java\" is being used to run gradle. It does this by looking for\n# a JDK relative to the bin/java location. However if you want to build with a different JDK than\n# what is used to execute Gradle, or to fix a failed attempt by the build script to locate the\n# JDK_HOME, you may want to specify it manually here.\n\n#JDK_HOME = /path/to/the/jdk\n#JAVA = /path/to/the/jdk/bin/java\n#JAVAC = /path/to/the/jdk/bin/javac\n#JAVADOC = /path/to/the/jdk/bin/javadoc\n#STUB_RUNTIME = /path/to/the/jdk/jre\n#LIBRARY_STUB = /path/to/the/jdk/jre/xxx (different location depending on platform)\n\n# The generated JavaDocs contain many references to core JDK classes such as java.lang.String\n# and java.util.concurrent.Executor. These references are resolved via the JDK_DOCS property,\n# which should point to the JDK API documentation. You can override which JDK to point to here.\n# This follows the rules specified in the JavaDoc tool documentation. Examples are below.\n\n#JDK_DOCS = https://docs.oracle.com/javase/8/docs/api\n#JDK_DOCS = file:///Library/Java/JavaVirtualMachines/jdk1.8.0/Content/Home/docs/api\n#JDK_DOCS = relative/path/to/docs/api\n\n# If you want to link against a docs URL that is not accessible to you at build\n# time (e.g., in case you are behind a firewall), you can set the\n# JDK_DOCS_LINK property to the URL of a local javadocs bundle that will\n# be used to resolve the symbols.\n\n#JDK_DOCS_LINK = file:///opt/javadocs/jdk10/docs/api\n\n# If you want to use a local repository for downloading dependencies\n# rather than maven central, you can set the JFX_DEPS_URL property\n# to point to your local server.\n\n#JFX_DEPS_URL=http:/local.server.my.compay.com/dependencies\n\n# Specify the build configuration: Release, Debug, or DebugNative. The default setting is Debug.\n\n#CONF = Release\n\n# Gradle 1.x incremental compilation\n#\n# Enables the use of the \"use depend\" feature. This speeds up incremental builds, but at the\n# cost of accuracy. Under normal circumstances, if you modify a single source file in the\n# \"base\" project, a near-complete recompile of the entire project is required for correctness\n# since that change *may* have caused other files to no longer compile / link correctly.\n# However, in many cases this is just additional compilation overhead because you may have\n# only added comments or performed some other work that didn't change the public API in any\n# way. By setting \"use depend\" to true, the build system will do more extensive analysis to\n# only recompile those classes directly impacted by your change. In some cases this will miss\n# compiling some classes that really do require recompilation and your build will be faulty.\n# This flag is enabled by default for command line builds. Uncomment to turn it off \"use depend\"\n\n#USE_DEPEND = false\n\n# Gradle 2.x incremental compilation\n#\n# Enables the use of the (still incubating) incremental Java compilation feature. This\n# should speed up incremental builds of the Java classes, but is not yet working correctly.\n#\n# This flag is disabled by default. Uncomment this to turn it on.\n\n#INCREMENTAL = true\n\n# Specify an option to -Xdoclint, such as \"none\" or \"all\" (default),\n# used by the javadoc task.\n\n#DOC_LINT = none\n\n# Specify compiler LINT arguments. These values are defined by the javac compiler. You can\n# study the list of available options here https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/javac.html\n# If LINT is empty, then no warning are generated. Otherwise, LINT should be a space or comma separated\n# list of names. If the name is prefixed with a '-' then that warning is removed (not used). For example:\n#\n# LINT = static try -varags\n#\n# This command would turn on the \"static\" and \"try\" warnings, but turn off the \"varargs\" warnings. The\n# special values \"all\" and \"none\" are used to turn on all recommended warnings, or turn them all off, respectively.\n# The default (for now) is \"none\" but as we clean up our warnings, we will likely change this to \"all\".\n\n#LINT = all\n\n# The following flag specifies whether to generate code coverage\n# statistics when running tests\n\n#JCOV = true\n\n# Define the number of threads to use when compiling native code. This value must be\n# > 0, or the build system will default to 1. If not specified, the number of compile\n# threads is determined based on the number of CPU cores on the machine. If this value\n# is too high, the amount of time servicing the threads will start slowing down your\n# build. Likely the optimal value is somewhat larger than the number of cores on the\n# machine, and playing with this value may improve build time performance.\n\n#NUM_COMPILE_THREADS = 12\n\n# When you are working from behind a proxy and attempting to access public libraries, you need\n# to set the proxy host and port.\n\n#systemProp.http.proxyHost=proxy.my.com\n#systemProp.http.proxyPort=80\n\n# In order to enable Android builds, you must specify the paths to the Android SDK and NDK.\n# Uncomment the two lines below and configure them to point to the right location on your system\n\n#ANDROID_SDK = /path/to/android/sdk\n#ANDROID_NDK = /path/to/android/ndk\n\n# The COMPILE_FLAGS_FILES defines the native compilation flags to use. Each native project\n# defines a pair of flags, XXX_CC_FLAGS and XXX_LINK_FLAGS as defined below:\n#\n#   Project         Flags\n#  -----------------------------------\n#   Glass           GLASS_CC_FLAGS, GLASS_LINK_FLAGS\n#   Decora          DECORA_CC_FLAGS, DECORA_LINK_FLAGS\n#   Prism           PRISM_CC_FLAGS, PRISM_LINK_FLAGS\n#   Prism SW        PRISM_SW_CC_FLAGS, PRISM_SW_LINK_FLAGS\n#\n# Other projects may use CC_FLAGS and LINK_FLAGS, or may not be fully abstracted out yet.\n# As such, the set of flags a COMPILE_FLAGS_FILES must support will change as time goes on.\n# Setting a custom COMPILE_FLAGS_FILE should be something rarely done, usually by\n# somebody who is setting up builds for a new compile target.\n#\n# The COMPILE_FLAGS_FILES is a gradle file and is applied directly by build.gradle.\n# This means that the file can implement logic (if / loop / etc) and has access to all of\n# the properties defined for the build.\n#\n# If not specified, the appropriate COMPILE_FLAGS_FILES for the designated COMPILE_TARGETS\n# will be chosen automatically. For example, win.gradle will be used when compiling on\n# windows, and armhf.gradle will be picked up when compiling for armhf (such as for\n# the Raspberry PI).\n#\n# Paths for those properties that take a path should be absolute or relative paths, or they\n# should be full URLs. For example:\n#\n#       COMPILE_FLAGS_FILES = foo.gradle\n#       COMPILE_FLAGS_FILES = ../foo.gradle\n#       COMPILE_FLAGS_FILES = bar/foo.gradle\n#       COMPILE_FLAGS_FILES = file:///path/to/foo.gradle\n#\n\n#COMPILE_FLAGS_FILES = path/to/flags/file.gradle, path/to/flags/file2.gradle\n\n# Define settings used when creating the VersionInfo. These settings are generally left alone\n# by developers and set only from Hudson.\n\n#HUDSON_JOB_NAME = not_hudson\n#HUDSON_BUILD_NUMBER = 0000\n#PROMOTED_BUILD_NUMBER = 00\n#PRODUCT_NAME = OpenJFX\n\n# Define the default SDK path on Mac. This should need to be rarely, if ever set.\n\n# MACOSX_SDK_PATH = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.7.sdk\n"
        },
        {
          "name": "gradle",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradlew",
          "type": "blob",
          "size": 8.556640625,
          "content": "#!/bin/sh\n\n#\n# Copyright  2015-2021 the original authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# SPDX-License-Identifier: Apache-2.0\n#\n\n##############################################################################\n#\n#   Gradle start up script for POSIX generated by Gradle.\n#\n#   Important for running:\n#\n#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is\n#       noncompliant, but you have some other compliant shell such as ksh or\n#       bash, then to run this script, type that shell name before the whole\n#       command line, like:\n#\n#           ksh Gradle\n#\n#       Busybox and similar reduced shells will NOT work, because this script\n#       requires all of these POSIX shell features:\n#         * functions;\n#         * expansions $var, ${var}, ${var:-default}, ${var+SET},\n#           ${var#prefix}, ${var%suffix}, and $( cmd );\n#         * compound commands having a testable exit status, especially case;\n#         * various built-in commands including command, set, and ulimit.\n#\n#   Important for patching:\n#\n#   (2) This script targets any POSIX shell, so it avoids extensions provided\n#       by Bash, Ksh, etc; in particular arrays are avoided.\n#\n#       The \"traditional\" practice of packing multiple parameters into a\n#       space-separated string is a well documented source of bugs and security\n#       problems, so this is (mostly) avoided, by progressively accumulating\n#       options in \"$@\", and eventually passing that to Java.\n#\n#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,\n#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;\n#       see the in-line comments for details.\n#\n#       There are tweaks for specific operating systems such as AIX, CygWin,\n#       Darwin, MinGW, and NonStop.\n#\n#   (3) This script is generated from the Groovy template\n#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\n#       within the Gradle project.\n#\n#       You can find Gradle at https://github.com/gradle/gradle/.\n#\n##############################################################################\n\n# Attempt to set APP_HOME\n\n# Resolve links: $0 may be a link\napp_path=$0\n\n# Need this for daisy-chained symlinks.\nwhile\n    APP_HOME=${app_path%\"${app_path##*/}\"}  # leaves a trailing /; empty if no leading path\n    [ -h \"$app_path\" ]\ndo\n    ls=$( ls -ld \"$app_path\" )\n    link=${ls#*' -> '}\n    case $link in             #(\n      /*)   app_path=$link ;; #(\n      *)    app_path=$APP_HOME$link ;;\n    esac\ndone\n\n# This is normally unused\n# shellcheck disable=SC2034\nAPP_BASE_NAME=${0##*/}\n# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)\nAPP_HOME=$( cd -P \"${APP_HOME:-./}\" > /dev/null && printf '%s\n' \"$PWD\" ) || exit\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD=maximum\n\nwarn () {\n    echo \"$*\"\n} >&2\n\ndie () {\n    echo\n    echo \"$*\"\n    echo\n    exit 1\n} >&2\n\n# OS specific support (must be 'true' or 'false').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase \"$( uname )\" in                #(\n  CYGWIN* )         cygwin=true  ;; #(\n  Darwin* )         darwin=true  ;; #(\n  MSYS* | MINGW* )  msys=true    ;; #(\n  NONSTOP* )        nonstop=true ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n\n# Determine the Java command to use to start the JVM.\nif [ -n \"$JAVA_HOME\" ] ; then\n    if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n        # IBM's JDK on AIX uses strange locations for the executables\n        JAVACMD=$JAVA_HOME/jre/sh/java\n    else\n        JAVACMD=$JAVA_HOME/bin/java\n    fi\n    if [ ! -x \"$JAVACMD\" ] ; then\n        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nelse\n    JAVACMD=java\n    if ! command -v java >/dev/null 2>&1\n    then\n        die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation.\"\n    fi\nfi\n\n# Increase the maximum file descriptors if we can.\nif ! \"$cygwin\" && ! \"$darwin\" && ! \"$nonstop\" ; then\n    case $MAX_FD in #(\n      max*)\n        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.\n        # shellcheck disable=SC2039,SC3045\n        MAX_FD=$( ulimit -H -n ) ||\n            warn \"Could not query maximum file descriptor limit\"\n    esac\n    case $MAX_FD in  #(\n      '' | soft) :;; #(\n      *)\n        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.\n        # shellcheck disable=SC2039,SC3045\n        ulimit -n \"$MAX_FD\" ||\n            warn \"Could not set maximum file descriptor limit to $MAX_FD\"\n    esac\nfi\n\n# Collect all arguments for the java command, stacking in reverse order:\n#   * args from the command line\n#   * the main class name\n#   * -classpath\n#   * -D...appname settings\n#   * --module-path (only if needed)\n#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.\n\n# For Cygwin or MSYS, switch paths to Windows format before running java\nif \"$cygwin\" || \"$msys\" ; then\n    APP_HOME=$( cygpath --path --mixed \"$APP_HOME\" )\n    CLASSPATH=$( cygpath --path --mixed \"$CLASSPATH\" )\n\n    JAVACMD=$( cygpath --unix \"$JAVACMD\" )\n\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    for arg do\n        if\n            case $arg in                                #(\n              -*)   false ;;                            # don't mess with options #(\n              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath\n                    [ -e \"$t\" ] ;;                      #(\n              *)    false ;;\n            esac\n        then\n            arg=$( cygpath --path --ignore --mixed \"$arg\" )\n        fi\n        # Roll the args list around exactly as many times as the number of\n        # args, so each arg winds up back in the position where it started, but\n        # possibly modified.\n        #\n        # NB: a `for` loop captures its iteration list before it begins, so\n        # changing the positional parameters here affects neither the number of\n        # iterations, nor the values presented in `arg`.\n        shift                   # remove old arg\n        set -- \"$@\" \"$arg\"      # push replacement arg\n    done\nfi\n\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS='\"-Xmx64m\" \"-Xms64m\"'\n\n# Collect all arguments for the java command:\n#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,\n#     and any embedded shellness will be escaped.\n#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be\n#     treated as '${Hostname}' itself on the command line.\n\nset -- \\\n        \"-Dorg.gradle.appname=$APP_BASE_NAME\" \\\n        -classpath \"$CLASSPATH\" \\\n        org.gradle.wrapper.GradleWrapperMain \\\n        \"$@\"\n\n# Stop when \"xargs\" is not available.\nif ! command -v xargs >/dev/null 2>&1\nthen\n    die \"xargs is not available\"\nfi\n\n# Use \"xargs\" to parse quoted args.\n#\n# With -n1 it outputs one arg per line, with the quotes and backslashes removed.\n#\n# In Bash we could simply go:\n#\n#   readarray ARGS < <( xargs -n1 <<<\"$var\" ) &&\n#   set -- \"${ARGS[@]}\" \"$@\"\n#\n# but POSIX shell has neither arrays nor command substitution, so instead we\n# post-process each arg (as a line of input to sed) to backslash-escape any\n# character that might be a shell metacharacter, then use eval to reverse\n# that process (while maintaining the separation between arguments), and wrap\n# the whole thing up as a single \"set\" statement.\n#\n# This will of course break if any of these variables contains a newline or\n# an unmatched quote.\n#\n\neval \"set -- $(\n        printf '%s\\n' \"$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\" |\n        xargs -n1 |\n        sed ' s~[^-[:alnum:]+,./:=@_]~\\\\&~g; ' |\n        tr '\\n' ' '\n    )\" '\"$@\"'\n\nexec \"$JAVACMD\" \"$@\"\n"
        },
        {
          "name": "gradlew.bat",
          "type": "blob",
          "size": 2.8046875,
          "content": "@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the \"License\");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an \"AS IS\" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n@rem SPDX-License-Identifier: Apache-2.0\n@rem\n\n@if \"%DEBUG%\"==\"\" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \"%OS%\"==\"Windows_NT\" setlocal\n\nset DIRNAME=%~dp0\nif \"%DIRNAME%\"==\"\" set DIRNAME=.\n@rem This is normally unused\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Resolve any \".\" and \"..\" in APP_HOME to make it shorter.\nfor %%i in (\"%APP_HOME%\") do set APP_HOME=%%~fi\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS=\"-Xmx64m\" \"-Xms64m\"\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif %ERRORLEVEL% equ 0 goto execute\n\necho. 1>&2\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\necho. 1>&2\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\necho location of your Java installation. 1>&2\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:\"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist \"%JAVA_EXE%\" goto execute\n\necho. 1>&2\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\necho. 1>&2\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\necho location of your Java installation. 1>&2\n\ngoto fail\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n\n@rem Execute Gradle\n\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %*\n\n:end\n@rem End local scope for the variables with windows NT shell\nif %ERRORLEVEL% equ 0 goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nset EXIT_CODE=%ERRORLEVEL%\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\nif not \"\"==\"%GRADLE_EXIT_CONSOLE%\" exit %EXIT_CODE%\nexit /b %EXIT_CODE%\n\n:mainEnd\nif \"%OS%\"==\"Windows_NT\" endlocal\n\n:omega\n"
        },
        {
          "name": "javafx.pom",
          "type": "blob",
          "size": 1.9140625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>org.openjfx</groupId>\n    <artifactId>javafx</artifactId>\n    <version>@VERSION@</version>\n    <packaging>pom</packaging>\n    <name>openjfx</name>\n    <description>OpenJFX JavaFX</description>\n    <properties>\n        <javafx.version>@VERSION@</javafx.version>\n    </properties>\n    <dependencyManagement>\n    </dependencyManagement>\n    <profiles>\n        <profile>\n            <id>linux</id>\n            <activation>\n                <os>\n                    <name>linux</name>\n                </os>\n            </activation>\n            <properties>\n                <javafx.platform>linux</javafx.platform>\n            </properties>\n        </profile>\n        <profile>\n            <id>macosx</id>\n            <activation>\n                <os>\n                    <name>mac os x</name>\n                </os>\n            </activation>\n            <properties>\n                <javafx.platform>mac</javafx.platform>\n            </properties>\n        </profile>\n        <profile>\n            <id>windows</id>\n            <activation>\n                <os>\n                    <family>windows</family>\n                </os>\n            </activation>\n            <properties>\n                <javafx.platform>win</javafx.platform>\n            </properties>\n        </profile>\n        <profile>\n            <id>javafx.platform.custom</id>\n            <activation>\n                <property>\n                    <name>javafx.platform</name>\n                </property>\n            </activation>\n            <properties>\n                <javafx.platform>${javafx.platform}</javafx.platform>\n            </properties>\n        </profile>\n    </profiles>\n</project>\n"
        },
        {
          "name": "modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.gradle",
          "type": "blob",
          "size": 2.86328125,
          "content": "/*\n * Copyright (c) 2013, 2024, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\ninclude \"base\",\n        \"graphics\",\n        \"controls\",\n        // Add an entry for each incubator module here, leaving the incubator\n        // placeholder lines as an example.\n        // BEGIN: incubator placeholder\n        //\"incubator.mymod\",\n        // END: incubator placeholder\n        \"incubator.input\",\n        \"incubator.richtext\",\n        \"swing\",\n        \"swt\",\n        \"fxml\",\n        \"jsobject\",\n        \"web\",\n        \"media\",\n        \"systemTests\"\n\nproject(\":base\").projectDir = file(\"modules/javafx.base\")\nproject(\":graphics\").projectDir = file(\"modules/javafx.graphics\")\nproject(\":controls\").projectDir = file(\"modules/javafx.controls\")\n// Add an entry for each incubator module here, leaving the incubator\n// placeholder lines as an example.\n// BEGIN: incubator placeholder\n//project(\":incubator.mymod\").projectDir = file(\"modules/jfx.incubator.mymod\")\n// END: incubator placeholder\nproject(\":incubator.input\").projectDir = file(\"modules/jfx.incubator.input\")\nproject(\":incubator.richtext\").projectDir = file(\"modules/jfx.incubator.richtext\")\nproject(\":swing\").projectDir = file(\"modules/javafx.swing\")\nproject(\":swt\").projectDir = file(\"modules/javafx.swt\")\nproject(\":fxml\").projectDir = file(\"modules/javafx.fxml\")\nproject(\":jsobject\").projectDir = file(\"modules/jdk.jsobject\")\nproject(\":web\").projectDir = file(\"modules/javafx.web\")\nproject(\":media\").projectDir = file(\"modules/javafx.media\")\nproject(\":systemTests\").projectDir = file(\"tests/system\")\n\ndef closedDir = file(\"../rt-closed\")\ndef buildClosed = closedDir.isDirectory()\n\nif (buildClosed) {\n    File supplementalSettingsFile = new File(\"../rt-closed/closed-settings.gradle\");\n    apply from: supplementalSettingsFile\n}\n\ninclude 'apps'\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}