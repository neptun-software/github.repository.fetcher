{
  "metadata": {
    "timestamp": 1736565572781,
    "page": 444,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "p-ranav/argparse",
      "stars": 2851,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bazelrc",
          "type": "blob",
          "size": 0.2080078125,
          "content": "build --enable_platform_specific_config\n\nbuild:linux --cxxopt=-std=c++17\n\nbuild:windows --copt=/utf-8\nbuild:windows --copt=/Zc:preprocessor\nbuild:windows --cxxopt=/std:c++17\nbuild:windows --cxxopt=/Zc:__cplusplus\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.197265625,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  LLVM\nAccessModifierOffset: -2\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: All\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:     80\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nForEachMacros:\n  - foreach\n  - Q_FOREACH\n  - BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories:\n  - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n    Priority:        2\n  - Regex:           '^(<|\"(gtest|gmock|isl|json)/)'\n    Priority:        3\n  - Regex:           '.*'\n    Priority:        1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentPPDirectives: None\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60\nPointerAlignment: Right\nRawStringFormats:\n  - Language: TextProto\n    Delimiters:\n      - 'pb'\n      - 'proto'\n    BasedOnStyle: google\nReflowComments:  true\nSortIncludes:    true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        c++17\nTabWidth:        8\nUseTab:          Never\n...\n\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 1.021484375,
          "content": "Checks:\n  -*,\n  clang-analyzer-*,\n  cppcoreguidelines-avoid-c-arrays,\n  cppcoreguidelines-special-member-functions,\n  readability-*,\n\nCheckOptions:\n  - { key: readability-identifier-naming.ClassCase, value: CamelCase }\n  - { key: readability-identifier-naming.ConstexprVariableCase, value: lower_case }\n  - { key: readability-identifier-naming.ConstexprVariableIgnoredRegexp, value: \"^Is.+\" }\n  - { key: readability-identifier-naming.FunctionCase, value: lower_case }\n  - { key: readability-identifier-naming.NamespaceCase, value: lower_case }\n  - { key: readability-identifier-naming.ParameterCase, value: lower_case }\n  - { key: readability-identifier-naming.PrivateMemberCase, value: lower_case }\n  - { key: readability-identifier-naming.PrivateMemberPrefix, value: m_ }\n  - { key: readability-identifier-naming.StructCase, value: CamelCase }\n  - { key: readability-identifier-naming.StructIgnoredRegexp, value: \"parse_number\" }\n  - { key: readability-identifier-naming.VariableCase, value: lower_case }\n\nHeaderFilterRegex: 'argparse/.+\\.hpp'\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.4833984375,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n.vscode/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# DNX\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n#*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignoreable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\nnode_modules/\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# CMake build directory\nbuild\n\n# Cppcheck build directory\nanalysis-cppcheck-build-dir\n\n# Ideas directory\nideas\n\ndesktop.iniimages/\n\n# Ignore all bazel-* symlinks. There is no full list since this can change\n# based on the name of the directory bazel is cloned into.\n/bazel-*\n"
        },
        {
          "name": ".stylua.toml",
          "type": "blob",
          "size": 0.0224609375,
          "content": "indent_type = \"Spaces\"\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.82421875,
          "content": "matrix:\n  include:\n    - os: linux\n      dist: bionic\n      language: cpp\n      compiler: gcc\n      addons:\n        apt:\n          sources:\n            - ubuntu-toolchain-r-test\n          packages:\n            - g++-8\n      env: CXX=g++-8 CC=gcc-8\n    - os: osx\n      osx_image: xcode10.2\n      language: cpp\n      compiler: clang\n    - os: windows\n      language: bash\n      env: CXX=cl.exe\ninstall:\n  - |\n    if [[ $TRAVIS_OS_NAME == 'windows' ]]; then\n      choco install ninja cmake\n    elif [[ $TRAVIS_OS_NAME == 'osx' ]]; then\n      export PATH=~/Library/Python/3.7/bin:$PATH\n      pip3 install --user ninja cmake\n    else\n      pipenv global 3.6\n      pip install --user ninja cmake\n    fi\nscript:\n  - |\n    if [[ $TRAVIS_OS_NAME == 'windows' ]]; then\n      tools/build.bat\n    else\n      sh tools/build.sh\n    fi\n  - ./build/test/tests\n"
        },
        {
          "name": "BUILD.bazel",
          "type": "blob",
          "size": 0.1494140625,
          "content": "cc_library(\n    name = \"argparse\",\n    hdrs = [\"include/argparse/argparse.hpp\"],\n    includes = [\"include\"],\n    visibility = [\"//visibility:public\"],\n)\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.4462890625,
          "content": "cmake_minimum_required(VERSION 3.12.4)\n\nif(NOT DEFINED PROJECT_NAME)\n  set(ARGPARSE_IS_TOP_LEVEL ON)\nelse()\n  set(ARGPARSE_IS_TOP_LEVEL OFF)\nendif()\n\nproject(argparse\n        VERSION 3.1.0 \n        DESCRIPTION \"A single header argument parser for C++17\"\n        HOMEPAGE_URL \"https://github.com/p-ranav/argparse\"\n        LANGUAGES CXX\n)\n\noption(ARGPARSE_INSTALL \"Include an install target\" ${ARGPARSE_IS_TOP_LEVEL})\noption(ARGPARSE_BUILD_TESTS \"Build tests\" ${ARGPARSE_IS_TOP_LEVEL})\noption(ARGPARSE_BUILD_SAMPLES \"Build samples\" OFF)\n\ninclude(GNUInstallDirs)\ninclude(CMakePackageConfigHelpers)\n\nadd_library(argparse INTERFACE)\nadd_library(argparse::argparse ALIAS argparse)\n\ntarget_compile_features(argparse INTERFACE cxx_std_17)\ntarget_include_directories(argparse INTERFACE\n  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>)\n\nif(ARGPARSE_BUILD_SAMPLES)\n  add_subdirectory(samples)\nendif()\n  \nif(ARGPARSE_BUILD_TESTS)\n  add_subdirectory(test)\nendif()\n  \nif(ARGPARSE_INSTALL)\n  install(TARGETS argparse EXPORT argparseConfig)\n  install(EXPORT argparseConfig\n          NAMESPACE argparse::\n          DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME})\n  install(FILES ${CMAKE_CURRENT_LIST_DIR}/include/argparse/argparse.hpp\n          DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/argparse)\n\n\n  set(CONFIG_FILE_NAME_WITHOUT_EXT \"${PROJECT_NAME}Config\")\n  set(CMAKE_CONFIG_FILE_BASENAME \"${CMAKE_CURRENT_BINARY_DIR}/${CONFIG_FILE_NAME_WITHOUT_EXT}\")\n  set(CMAKE_CONFIG_VERSION_FILE_NAME \"${CMAKE_CONFIG_FILE_BASENAME}-version.cmake\")\n  set(CMAKE_CONFIG_FILE_NAME \"${CMAKE_CONFIG_FILE_BASENAME}.cmake\")\n\n  if(${CMAKE_VERSION} VERSION_GREATER \"3.14\")\n  \tset(OPTIONAL_ARCH_INDEPENDENT \"ARCH_INDEPENDENT\")\n  endif()\n\n  write_basic_package_version_file(\"${CMAKE_CONFIG_VERSION_FILE_NAME}\"\n      COMPATIBILITY SameMajorVersion\n      ${OPTIONAL_ARCH_INDEPENDENT}\n  )\n\n  export(EXPORT argparseConfig\n         NAMESPACE argparse::)\n\n  install(FILES \"${CMAKE_CONFIG_VERSION_FILE_NAME}\"\n         DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\")\n\n  set(PackagingTemplatesDir \"${CMAKE_CURRENT_SOURCE_DIR}/packaging\")\n\n  set(CPACK_PACKAGE_NAME \"${PROJECT_NAME}\")\n  set(CPACK_PACKAGE_VENDOR \"argparse (C++) developers\")\n  set(CPACK_PACKAGE_DESCRIPTION \"${PROJECT_DESCRIPTION}\")\n  set(CPACK_DEBIAN_PACKAGE_NAME \"${CPACK_PACKAGE_NAME}\")\n  set(CPACK_RPM_PACKAGE_NAME \"${CPACK_PACKAGE_NAME}\")\n  set(CPACK_PACKAGE_HOMEPAGE_URL \"${PROJECT_HOMEPAGE_URL}\")\n  set(CPACK_PACKAGE_MAINTAINER \"Pranav Srinivas Kumar\")\n  set(CPACK_DEBIAN_PACKAGE_MAINTAINER \"${CPACK_PACKAGE_MAINTAINER}\")\n  set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE\")\n  set(CPACK_RESOURCE_FILE_README \"${CMAKE_CURRENT_SOURCE_DIR}/README.md\")\n\n  set(CPACK_DEBIAN_PACKAGE_NAME \"lib${PROJECT_NAME}-dev\")\n  set(CPACK_DEBIAN_PACKAGE_DEPENDS \"libc6-dev\")\n  set(CPACK_DEBIAN_PACKAGE_SUGGESTS \"cmake, pkg-config, pkg-conf\")\n\n  set(CPACK_RPM_PACKAGE_NAME \"lib${PROJECT_NAME}-devel\")\n  set(CPACK_RPM_PACKAGE_SUGGESTS \"${CPACK_DEBIAN_PACKAGE_SUGGESTS}\")\n\n  set(CPACK_DEB_COMPONENT_INSTALL ON)\n  set(CPACK_RPM_COMPONENT_INSTALL ON)\n  set(CPACK_NSIS_COMPONENT_INSTALL ON)\n  set(CPACK_DEBIAN_COMPRESSION_TYPE \"xz\")\n\n  set(PKG_CONFIG_FILE_NAME \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc\")\n  configure_file(\"${PackagingTemplatesDir}/pkgconfig.pc.in\" \"${PKG_CONFIG_FILE_NAME}\" @ONLY)\n  install(FILES \"${PKG_CONFIG_FILE_NAME}\"\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\"\n  )\nendif()\n\ninclude(CPack)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.5966796875,
          "content": "# Contributing\nContributions are welcomed. Open a pull-request or an issue.\n\n## Code of conduct\nThis project adheres to the [Open Code of Conduct][code-of-conduct]. By participating, you are expected to honor this code.\n\n[code-of-conduct]: https://github.com/spotify/code-of-conduct/blob/master/code-of-conduct.md\n\n## Code Style\n\nThis project prefers, but does not strictly enforce, a specific source code style. The style is described in `.clang-format` and `.clang-tidy`.\n\nTo generate a clang-tidy report:\n\n```bash\nclang-tidy --extra-arg=-std=c++17 --config-file=.clang-tidy include/argparse/argparse.hpp\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.072265625,
          "content": "Copyright (c) 2018 Pranav Srinivas Kumar <pranav.srinivas.kumar@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 45.4423828125,
          "content": "<p align=\"center\">\r\n  <img height=\"100\" src=\"https://i.imgur.com/oDXeMUQ.png\" alt=\"argparse\"/>\r\n</p>\r\n\r\n<p align=\"center\">\r\n  <a href=\"https://github.com/p-ranav/argparse/blob/master/LICENSE\">\r\n    <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"license\"/>\r\n  </a>\r\n  <img src=\"https://img.shields.io/badge/version-3.1-blue.svg?cacheSeconds=2592000\" alt=\"version\"/>\r\n</p>\r\n\r\n## Highlights\r\n\r\n* Single header file\r\n* Requires C++17\r\n* MIT License\r\n\r\n## Table of Contents\r\n\r\n*    [Quick Start](#quick-start)\r\n     *    [Positional Arguments](#positional-arguments)\r\n     *    [Optional Arguments](#optional-arguments)\r\n          *    [Requiring optional arguments](#requiring-optional-arguments)\r\n          *    [Accessing optional arguments without default values](#accessing-optional-arguments-without-default-values)\r\n          *    [Deciding if the value was given by the user](#deciding-if-the-value-was-given-by-the-user)\r\n          *    [Joining values of repeated optional arguments](#joining-values-of-repeated-optional-arguments)\r\n          *    [Repeating an argument to increase a value](#repeating-an-argument-to-increase-a-value)\r\n          *    [Mutually Exclusive Group](#mutually-exclusive-group)\r\n     *    [Storing values into variables](#store-into)\r\n     *    [Negative Numbers](#negative-numbers)\r\n     *    [Combining Positional and Optional Arguments](#combining-positional-and-optional-arguments)\r\n     *    [Printing Help](#printing-help)\r\n     *    [Adding a description and an epilog to help](#adding-a-description-and-an-epilog-to-help)\r\n     *    [List of Arguments](#list-of-arguments)\r\n     *    [Compound Arguments](#compound-arguments)\r\n     *    [Converting to Numeric Types](#converting-to-numeric-types)\r\n     *    [Default Arguments](#default-arguments)\r\n     *    [Gathering Remaining Arguments](#gathering-remaining-arguments)\r\n     *    [Parent Parsers](#parent-parsers)\r\n     *    [Subcommands](#subcommands)\r\n     *    [Getting Argument and Subparser Instances](#getting-argument-and-subparser-instances)\r\n     *    [Parse Known Args](#parse-known-args)\r\n     *    [Hidden argument and alias](#hidden-argument-alias)\r\n     *    [ArgumentParser in bool Context](#argumentparser-in-bool-context)\r\n     *    [Custom Prefix Characters](#custom-prefix-characters)\r\n     *    [Custom Assignment Characters](#custom-assignment-characters)\r\n*    [Further Examples](#further-examples)\r\n     *    [Construct a JSON object from a filename argument](#construct-a-json-object-from-a-filename-argument)\r\n     *    [Positional Arguments with Compound Toggle Arguments](#positional-arguments-with-compound-toggle-arguments)\r\n     *    [Restricting the set of values for an argument](#restricting-the-set-of-values-for-an-argument)\r\n     *    [Using `option=value` syntax](#using-optionvalue-syntax)\r\n     *    [Advanced usage formatting](#advanced-usage-formatting)\r\n*    [Developer Notes](#developer-notes)\r\n     *    [Copying and Moving](#copying-and-moving)\r\n*    [CMake Integration](#cmake-integration)\r\n*    [Building, Installing, and Testing](#building-installing-and-testing)\r\n*    [Supported Toolchains](#supported-toolchains)\r\n*    [Contributing](#contributing)\r\n*    [License](#license)\r\n\r\n## Quick Start\r\n\r\nSimply include argparse.hpp and you're good to go.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n```\r\n\r\nTo start parsing command-line arguments, create an ```ArgumentParser```.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"program_name\");\r\n```\r\n\r\n**NOTE:** There is an optional second argument to the `ArgumentParser` which is the program version. Example: `argparse::ArgumentParser program(\"libfoo\", \"1.9.0\");`\r\n\r\n**NOTE:** There are optional third and fourth arguments to the `ArgumentParser` which control default arguments. Example: `argparse::ArgumentParser program(\"libfoo\", \"1.9.0\", default_arguments::help, false);` See [Default Arguments](#default-arguments), below.\r\n\r\nTo add a new argument, simply call ```.add_argument(...)```. You can provide a variadic list of argument names that you want to group together, e.g., ```-v``` and ```--verbose```\r\n\r\n```cpp\r\nprogram.add_argument(\"foo\");\r\nprogram.add_argument(\"-v\", \"--verbose\"); // parameter packing\r\n```\r\n\r\nArgparse supports a variety of argument types including positional, optional, and compound arguments. Below you can see how to configure each of these types:\r\n\r\n### Positional Arguments\r\n\r\nHere's an example of a ***positional argument***:\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"program_name\");\r\n\r\n  program.add_argument(\"square\")\r\n    .help(\"display the square of a given integer\")\r\n    .scan<'i', int>();\r\n\r\n  try {\r\n    program.parse_args(argc, argv);\r\n  }\r\n  catch (const std::exception& err) {\r\n    std::cerr << err.what() << std::endl;\r\n    std::cerr << program;\r\n    return 1;\r\n  }\r\n\r\n  auto input = program.get<int>(\"square\");\r\n  std::cout << (input * input) << std::endl;\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\nAnd running the code:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main 15\r\n225\r\n```\r\n\r\nHere's what's happening:\r\n\r\n* The ```add_argument()``` method is used to specify which command-line options the program is willing to accept. In this case, I’ve named it square so that it’s in line with its function.\r\n* Command-line arguments are strings. To square the argument and print the result, we need to convert this argument to a number. In order to do this, we use the ```.scan``` method to convert user input into an integer.\r\n* We can get the value stored by the parser for a given argument using ```parser.get<T>(key)``` method.\r\n\r\n### Optional Arguments\r\n\r\nNow, let's look at ***optional arguments***. Optional arguments start with ```-``` or ```--```, e.g., ```--verbose``` or ```-a```. Optional arguments can be placed anywhere in the input sequence.\r\n\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"--verbose\")\r\n  .help(\"increase output verbosity\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nif (program[\"--verbose\"] == true) {\r\n  std::cout << \"Verbosity enabled\" << std::endl;\r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main --verbose\r\nVerbosity enabled\r\n```\r\n\r\nHere's what's happening:\r\n* The program is written so as to display something when --verbose is specified and display nothing when not.\r\n* Since the argument is actually optional, no error is thrown when running the program without ```--verbose```. Note that by using ```.default_value(false)```, if the optional argument isn’t used, it's value is automatically set to false.\r\n* By using ```.implicit_value(true)```, the user specifies that this option is more of a flag than something that requires a value. When the user provides the --verbose option, it's value is set to true.\r\n\r\n#### Flag\r\n\r\nWhen defining flag arguments, you can use the shorthand `flag()` which is the same as `default_value(false).implicit_value(true)`. \r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"--verbose\")\r\n  .help(\"increase output verbosity\")\r\n  .flag();\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nif (program[\"--verbose\"] == true) {\r\n  std::cout << \"Verbosity enabled\" << std::endl;\r\n}\r\n```\r\n\r\n#### Requiring optional arguments\r\n\r\nThere are scenarios where you would like to make an optional argument ***required***. As discussed above, optional arguments either begin with `-` or `--`. You can make these types of arguments required like so:\r\n\r\n```cpp\r\nprogram.add_argument(\"-o\", \"--output\")\r\n  .required()\r\n  .help(\"specify the output file.\");\r\n```\r\n\r\nIf the user does not provide a value for this parameter, an exception is thrown.\r\n\r\nAlternatively, you could provide a default value like so:\r\n\r\n```cpp\r\nprogram.add_argument(\"-o\", \"--output\")\r\n  .default_value(std::string(\"-\"))\r\n  .required()\r\n  .help(\"specify the output file.\");\r\n```\r\n\r\n#### Accessing optional arguments without default values\r\n\r\nIf you require an optional argument to be present but have no good default value for it, you can combine testing and accessing the argument as following:\r\n\r\n```cpp\r\nif (auto fn = program.present(\"-o\")) {\r\n    do_something_with(*fn);\r\n}\r\n```\r\n\r\nSimilar to `get`, the `present` method also accepts a template argument.  But rather than returning `T`, `parser.present<T>(key)` returns `std::optional<T>`, so that when the user does not provide a value to this parameter, the return value compares equal to `std::nullopt`.\r\n\r\n#### Deciding if the value was given by the user\r\n\r\nIf you want to know whether the user supplied a value for an argument that has a ```.default_value```, check whether the argument ```.is_used()```.\r\n\r\n```cpp\r\nprogram.add_argument(\"--color\")\r\n  .default_value(std::string{\"orange\"})   // might otherwise be type const char* leading to an error when trying program.get<std::string>\r\n  .help(\"specify the cat's fur color\");\r\n\r\ntry {\r\n  program.parse_args(argc, argv);    // Example: ./main --color orange\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto color = program.get<std::string>(\"--color\");  // \"orange\"\r\nauto explicit_color = program.is_used(\"--color\");  // true, user provided orange\r\n```\r\n\r\n#### Joining values of repeated optional arguments\r\n\r\nYou may want to allow an optional argument to be repeated and gather all values in one place.\r\n\r\n```cpp\r\nprogram.add_argument(\"--color\")\r\n  .default_value<std::vector<std::string>>({ \"orange\" })\r\n  .append()\r\n  .help(\"specify the cat's fur color\");\r\n\r\ntry {\r\n  program.parse_args(argc, argv);    // Example: ./main --color red --color green --color blue\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto colors = program.get<std::vector<std::string>>(\"--color\");  // {\"red\", \"green\", \"blue\"}\r\n```\r\n\r\nNotice that ```.default_value``` is given an explicit template parameter to match the type you want to ```.get```.\r\n\r\n#### Repeating an argument to increase a value\r\n\r\nA common pattern is to repeat an argument to indicate a greater value.\r\n\r\n```cpp\r\nint verbosity = 0;\r\nprogram.add_argument(\"-V\", \"--verbose\")\r\n  .action([&](const auto &) { ++verbosity; })\r\n  .append()\r\n  .default_value(false)\r\n  .implicit_value(true)\r\n  .nargs(0);\r\n\r\nprogram.parse_args(argc, argv);    // Example: ./main -VVVV\r\n\r\nstd::cout << \"verbose level: \" << verbosity << std::endl;    // verbose level: 4\r\n```\r\n\r\n#### Mutually Exclusive Group\r\n\r\nCreate a mutually exclusive group using `program.add_mutually_exclusive_group(required = false)`. `argparse`` will make sure that only one of the arguments in the mutually exclusive group was present on the command line:\r\n\r\n```cpp\r\nauto &group = program.add_mutually_exclusive_group();\r\ngroup.add_argument(\"--first\");\r\ngroup.add_argument(\"--second\");\r\n```\r\n\r\nwith the following usage will yield an error:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main --first 1 --second 2\r\nArgument '--second VAR' not allowed with '--first VAR'\r\n```\r\n\r\nThe `add_mutually_exclusive_group()` function also accepts a `required` argument, to indicate that at least one of the mutually exclusive arguments is required:\r\n\r\n```cpp\r\nauto &group = program.add_mutually_exclusive_group(true);\r\ngroup.add_argument(\"--first\");\r\ngroup.add_argument(\"--second\");\r\n```\r\n\r\nwith the following usage will yield an error:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main\r\nOne of the arguments '--first VAR' or '--second VAR' is required\r\n```\r\n\r\n### Storing values into variables\r\n\r\nIt is possible to bind arguments to a variable storing their value, as an\r\nalternative to explicitly calling ``program.get<T>(arg_name)`` or ``program[arg_name]``\r\n\r\nThis is currently implementeted for variables of type ``bool`` (this also\r\nimplicitly calls ``flag()``), ``int``, ``double``, ``std::string``,\r\n``std::vector<std::string>`` and ``std::vector<int>``.\r\nIf the argument is not specified in the command\r\nline, the default value (if set) is set into the variable.\r\n\r\n```cpp\r\nbool flagvar = false;\r\nprogram.add_argument(\"--flagvar\").store_into(flagvar);\r\n\r\nint intvar = 0;\r\nprogram.add_argument(\"--intvar\").store_into(intvar);\r\n\r\ndouble doublevar = 0;\r\nprogram.add_argument(\"--doublevar\").store_into(doublevar);\r\n\r\nstd::string strvar;\r\nprogram.add_argument(\"--strvar\").store_into(strvar);\r\n\r\nstd::vector<std::string> strvar_repeated;\r\nprogram.add_argument(\"--strvar-repeated\").append().store_into(strvar_repeated);\r\n\r\nstd::vector<std::string> strvar_multi_valued;\r\nprogram.add_argument(\"--strvar-multi-valued\").nargs(2).store_into(strvar_multi_valued);\r\n\r\nstd::vector<int> intvar_repeated;\r\nprogram.add_argument(\"--intvar-repeated\").append().store_into(intvar_repeated);\r\n\r\nstd::vector<int> intvar_multi_valued;\r\nprogram.add_argument(\"--intvar-multi-valued\").nargs(2).store_into(intvar_multi_valued);\r\n```\r\n\r\n### Negative Numbers\r\n\r\nOptional arguments start with ```-```. Can ```argparse``` handle negative numbers? The answer is yes!\r\n\r\n```cpp\r\nargparse::ArgumentParser program;\r\n\r\nprogram.add_argument(\"integer\")\r\n  .help(\"Input number\")\r\n  .scan<'i', int>();\r\n\r\nprogram.add_argument(\"floats\")\r\n  .help(\"Vector of floats\")\r\n  .nargs(4)\r\n  .scan<'g', float>();\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\n// Some code to print arguments\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main -5 -1.1 -3.1415 -3.1e2 -4.51329E3\r\ninteger : -5\r\nfloats  : -1.1 -3.1415 -310 -4513.29\r\n```\r\n\r\nAs you can see here, ```argparse``` supports negative integers, negative floats and scientific notation.\r\n\r\n### Combining Positional and Optional Arguments\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"main\");\r\n\r\nprogram.add_argument(\"square\")\r\n  .help(\"display the square of a given number\")\r\n  .scan<'i', int>();\r\n\r\nprogram.add_argument(\"--verbose\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nint input = program.get<int>(\"square\");\r\n\r\nif (program[\"--verbose\"] == true) {\r\n  std::cout << \"The square of \" << input << \" is \" << (input * input) << std::endl;\r\n}\r\nelse {\r\n  std::cout << (input * input) << std::endl;\r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main 4\r\n16\r\n\r\nfoo@bar:/home/dev/$ ./main 4 --verbose\r\nThe square of 4 is 16\r\n\r\nfoo@bar:/home/dev/$ ./main --verbose 4\r\nThe square of 4 is 16\r\n```\r\n\r\n### Printing Help\r\n\r\n`std::cout << program` prints a help message, including the program usage and information about the arguments registered with the `ArgumentParser`. For the previous example, here's the default help message:\r\n\r\n```\r\nfoo@bar:/home/dev/$ ./main --help\r\nUsage: main [-h] [--verbose] square\r\n\r\nPositional arguments:\r\n  square       \tdisplay the square of a given number\r\n\r\nOptional arguments:\r\n  -h, --help   \tshows help message and exits\r\n  -v, --version\tprints version information and exits\r\n  --verbose\r\n```\r\n\r\nYou may also get the help message in string via `program.help().str()`.\r\n\r\n#### Adding a description and an epilog to help\r\n\r\n`ArgumentParser::add_description` will add text before the detailed argument\r\ninformation. `ArgumentParser::add_epilog` will add text after all other help output.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"main\");\r\n  program.add_argument(\"thing\").help(\"Thing to use.\").metavar(\"THING\");\r\n  program.add_argument(\"--member\").help(\"The alias for the member to pass to.\").metavar(\"ALIAS\");\r\n  program.add_argument(\"--verbose\").default_value(false).implicit_value(true);\r\n\r\n  program.add_description(\"Forward a thing to the next member.\");\r\n  program.add_epilog(\"Possible things include betingalw, chiz, and res.\");\r\n\r\n  program.parse_args(argc, argv);\r\n\r\n  std::cout << program << std::endl;\r\n}\r\n```\r\n\r\n```console\r\nUsage: main [-h] [--member ALIAS] [--verbose] THING\r\n\r\nForward a thing to the next member.\r\n\r\nPositional arguments:\r\n  THING         \tThing to use.\r\n\r\nOptional arguments:\r\n  -h, --help    \tshows help message and exits\r\n  -v, --version \tprints version information and exits\r\n  --member ALIAS\tThe alias for the member to pass to.\r\n  --verbose\r\n\r\nPossible things include betingalw, chiz, and res.\r\n```\r\n\r\n### List of Arguments\r\n\r\nArgumentParser objects usually associate a single command-line argument with a single action to be taken. The ```.nargs``` associates a different number of command-line arguments with a single action. When using ```nargs(N)```, N arguments from the command line will be gathered together into a list.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"main\");\r\n\r\nprogram.add_argument(\"--input_files\")\r\n  .help(\"The list of input files\")\r\n  .nargs(2);\r\n\r\ntry {\r\n  program.parse_args(argc, argv);   // Example: ./main --input_files config.yml System.xml\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto files = program.get<std::vector<std::string>>(\"--input_files\");  // {\"config.yml\", \"System.xml\"}\r\n```\r\n\r\n```ArgumentParser.get<T>()``` has specializations for ```std::vector``` and ```std::list```. So, the following variant, ```.get<std::list>```, will also work.\r\n\r\n```cpp\r\nauto files = program.get<std::list<std::string>>(\"--input_files\");  // {\"config.yml\", \"System.xml\"}\r\n```\r\n\r\nUsing ```.scan```, one can quickly build a list of desired value types from command line arguments. Here's an example:\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"main\");\r\n\r\nprogram.add_argument(\"--query_point\")\r\n  .help(\"3D query point\")\r\n  .nargs(3)\r\n  .default_value(std::vector<double>{0.0, 0.0, 0.0})\r\n  .scan<'g', double>();\r\n\r\ntry {\r\n  program.parse_args(argc, argv); // Example: ./main --query_point 3.5 4.7 9.2\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto query_point = program.get<std::vector<double>>(\"--query_point\");  // {3.5, 4.7, 9.2}\r\n```\r\n\r\nYou can also make a variable length list of arguments with the ```.nargs```.\r\nBelow are some examples.\r\n\r\n```cpp\r\nprogram.add_argument(\"--input_files\")\r\n  .nargs(1, 3);  // This accepts 1 to 3 arguments.\r\n```\r\n\r\nSome useful patterns are defined like \"?\", \"*\", \"+\" of argparse in Python.\r\n\r\n```cpp\r\nprogram.add_argument(\"--input_files\")\r\n  .nargs(argparse::nargs_pattern::any);  // \"*\" in Python. This accepts any number of arguments including 0.\r\n```\r\n```cpp\r\nprogram.add_argument(\"--input_files\")\r\n  .nargs(argparse::nargs_pattern::at_least_one);  // \"+\" in Python. This accepts one or more number of arguments.\r\n```\r\n```cpp\r\nprogram.add_argument(\"--input_files\")\r\n  .nargs(argparse::nargs_pattern::optional);  // \"?\" in Python. This accepts an argument optionally.\r\n```\r\n\r\n### Compound Arguments\r\n\r\nCompound arguments are optional arguments that are combined and provided as a single argument. Example: ```ps -aux```\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"-a\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\nprogram.add_argument(\"-b\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\nprogram.add_argument(\"-c\")\r\n  .nargs(2)\r\n  .default_value(std::vector<float>{0.0f, 0.0f})\r\n  .scan<'g', float>();\r\n\r\ntry {\r\n  program.parse_args(argc, argv);                  // Example: ./main -abc 1.95 2.47\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto a = program.get<bool>(\"-a\");                  // true\r\nauto b = program.get<bool>(\"-b\");                  // true\r\nauto c = program.get<std::vector<float>>(\"-c\");    // {1.95, 2.47}\r\n\r\n/// Some code that prints parsed arguments\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main -ac 3.14 2.718\r\na = true\r\nb = false\r\nc = {3.14, 2.718}\r\n\r\nfoo@bar:/home/dev/$ ./main -cb\r\na = false\r\nb = true\r\nc = {0.0, 0.0}\r\n```\r\n\r\nHere's what's happening:\r\n* We have three optional arguments ```-a```, ```-b``` and ```-c```.\r\n* ```-a``` and ```-b``` are toggle arguments.\r\n* ```-c``` requires 2 floating point numbers from the command-line.\r\n* argparse can handle compound arguments, e.g., ```-abc``` or ```-bac``` or ```-cab```. This only works with short single-character argument names.\r\n  - ```-a``` and ```-b``` become true.\r\n  - argv is further parsed to identify the inputs mapped to ```-c```.\r\n  - If argparse cannot find any arguments to map to c, then c defaults to {0.0, 0.0} as defined by ```.default_value```\r\n\r\n### Converting to Numeric Types\r\n\r\nFor inputs, users can express a primitive type for the value.\r\n\r\nThe ```.scan<Shape, T>``` method attempts to convert the incoming `std::string` to `T` following the `Shape` conversion specifier. An `std::invalid_argument` or `std::range_error` exception is thrown for errors.\r\n\r\n```cpp\r\nprogram.add_argument(\"-x\")\r\n       .scan<'d', int>();\r\n\r\nprogram.add_argument(\"scale\")\r\n       .scan<'g', double>();\r\n```\r\n\r\n`Shape` specifies what the input \"looks like\", and the type template argument specifies the return value of the predefined action. Acceptable types are floating point (i.e float, double, long double) and integral (i.e. signed char, short, int, long, long long).\r\n\r\nThe grammar follows `std::from_chars`, but does not exactly duplicate it. For example, hexadecimal numbers may begin with `0x` or `0X` and numbers with a leading zero may be handled as octal values.\r\n\r\n| Shape      | interpretation                            |\r\n| :--------: | ----------------------------------------- |\r\n| 'a' or 'A' | hexadecimal floating point                |\r\n| 'e' or 'E' | scientific notation (floating point)      |\r\n| 'f' or 'F' | fixed notation (floating point)           |\r\n| 'g' or 'G' | general form (either fixed or scientific) |\r\n|            |                                           |\r\n| 'd'        | decimal                                   |\r\n| 'i'        | `std::from_chars` grammar with base == 10 |\r\n| 'o'        | octal (unsigned)                          |\r\n| 'u'        | decimal (unsigned)                        |\r\n| 'x' or 'X' | hexadecimal (unsigned)                    |\r\n\r\n### Default Arguments\r\n\r\n`argparse` provides predefined arguments and actions for `-h`/`--help` and `-v`/`--version`. By default, these actions will **exit** the program after displaying a help or version message, respectively. This exit does not call destructors, skipping clean-up of taken resources.\r\n\r\nThese default arguments can be disabled during `ArgumentParser` creation so that you can handle these arguments in your own way. (Note that a program name and version must be included when choosing default arguments.)\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\", \"1.0\", default_arguments::none);\r\n\r\nprogram.add_argument(\"-h\", \"--help\")\r\n  .action([=](const std::string& s) {\r\n    std::cout << help().str();\r\n  })\r\n  .default_value(false)\r\n  .help(\"shows help message\")\r\n  .implicit_value(true)\r\n  .nargs(0);\r\n```\r\n\r\nThe above code snippet outputs a help message and continues to run. It does not support a `--version` argument.\r\n\r\nThe default is `default_arguments::all` for included arguments. No default arguments will be added with `default_arguments::none`. `default_arguments::help` and `default_arguments::version` will individually add `--help` and `--version`.\r\n\r\nThe default arguments can be used while disabling the default exit with these arguments. This forth argument to `ArgumentParser` (`exit_on_default_arguments`) is a bool flag with a default **true** value. The following call will retain `--help` and `--version`, but will not exit when those arguments are used.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\", \"1.0\", default_arguments::all, false)\r\n```\r\n\r\n### Gathering Remaining Arguments\r\n\r\n`argparse` supports gathering \"remaining\" arguments at the end of the command, e.g., for use in a compiler:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ compiler file1 file2 file3\r\n```\r\n\r\nTo enable this, simply create an argument and mark it as `remaining`. All remaining arguments passed to argparse are gathered here.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"compiler\");\r\n\r\nprogram.add_argument(\"files\")\r\n  .remaining();\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\ntry {\r\n  auto files = program.get<std::vector<std::string>>(\"files\");\r\n  std::cout << files.size() << \" files provided\" << std::endl;\r\n  for (auto& file : files)\r\n    std::cout << file << std::endl;\r\n} catch (std::logic_error& e) {\r\n  std::cout << \"No files provided\" << std::endl;\r\n}\r\n```\r\n\r\nWhen no arguments are provided:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./compiler\r\nNo files provided\r\n```\r\n\r\nand when multiple arguments are provided:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./compiler foo.txt bar.txt baz.txt\r\n3 files provided\r\nfoo.txt\r\nbar.txt\r\nbaz.txt\r\n```\r\n\r\nThe process of gathering remaining arguments plays nicely with optional arguments too:\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"compiler\");\r\n\r\nprogram.add_arguments(\"-o\")\r\n  .default_value(std::string(\"a.out\"));\r\n\r\nprogram.add_argument(\"files\")\r\n  .remaining();\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto output_filename = program.get<std::string>(\"-o\");\r\nstd::cout << \"Output filename: \" << output_filename << std::endl;\r\n\r\ntry {\r\n  auto files = program.get<std::vector<std::string>>(\"files\");\r\n  std::cout << files.size() << \" files provided\" << std::endl;\r\n  for (auto& file : files)\r\n    std::cout << file << std::endl;\r\n} catch (std::logic_error& e) {\r\n  std::cout << \"No files provided\" << std::endl;\r\n}\r\n\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./compiler -o main foo.cpp bar.cpp baz.cpp\r\nOutput filename: main\r\n3 files provided\r\nfoo.cpp\r\nbar.cpp\r\nbaz.cpp\r\n```\r\n\r\n***NOTE***: Remember to place all optional arguments BEFORE the remaining argument. If the optional argument is placed after the remaining arguments, it too will be deemed remaining:\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./compiler foo.cpp bar.cpp baz.cpp -o main\r\n5 arguments provided\r\nfoo.cpp\r\nbar.cpp\r\nbaz.cpp\r\n-o\r\nmain\r\n```\r\n\r\n### Parent Parsers\r\n\r\nA parser may use arguments that could be used by other parsers.\r\n\r\nThese shared arguments can be added to a parser which is then used as a \"parent\" for parsers which also need those arguments. One or more parent parsers may be added to a parser with `.add_parents`. The positional and optional arguments in each parent is added to the child parser.\r\n\r\n```cpp\r\nargparse::ArgumentParser surface_parser(\"surface\", \"1.0\", argparse::default_arguments::none);\r\nsurface_parser.add_argument(\"--area\")\r\n  .default_value(0)\r\n  .scan<'i', int>();\r\n\r\nargparse::ArgumentParser floor_parser(\"floor\");\r\nfloor_parser.add_argument(\"tile_size\").scan<'i', int>();\r\nfloor_parser.add_parents(surface_parser);\r\nfloor_parser.parse_args({ \"./main\", \"--area\", \"200\", \"12\" });  // --area = 200, tile_size = 12\r\n\r\nargparse::ArgumentParser ceiling_parser(\"ceiling\");\r\nceiling_parser.add_argument(\"--color\");\r\nceiling_parser.add_parents(surface_parser);\r\nceiling_parser.parse_args({ \"./main\", \"--color\", \"gray\" });  // --area = 0, --color = \"gray\"\r\n```\r\n\r\nChanges made to parents after they are added to a parser are not reflected in any child parsers. Completely initialize parent parsers before adding them to a parser.\r\n\r\nEach parser will have the standard set of default arguments. Disable the default arguments in parent parsers to avoid duplicate help output.\r\n\r\n### Subcommands\r\n\r\nMany programs split up their functionality into a number of sub-commands, for example, the `git` program can invoke sub-commands like `git checkout`, `git add`, and `git commit`. Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. `ArgumentParser` supports the creation of such sub-commands with the `add_subparser()` member function.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"git\");\r\n\r\n  // git add subparser\r\n  argparse::ArgumentParser add_command(\"add\");\r\n  add_command.add_description(\"Add file contents to the index\");\r\n  add_command.add_argument(\"files\")\r\n    .help(\"Files to add content from. Fileglobs (e.g.  *.c) can be given to add all matching files.\")\r\n    .remaining();\r\n\r\n  // git commit subparser\r\n  argparse::ArgumentParser commit_command(\"commit\");\r\n  commit_command.add_description(\"Record changes to the repository\");\r\n  commit_command.add_argument(\"-a\", \"--all\")\r\n    .help(\"Tell the command to automatically stage files that have been modified and deleted.\")\r\n    .default_value(false)\r\n    .implicit_value(true);\r\n\r\n  commit_command.add_argument(\"-m\", \"--message\")\r\n    .help(\"Use the given <msg> as the commit message.\");\r\n\r\n  // git cat-file subparser\r\n  argparse::ArgumentParser catfile_command(\"cat-file\");\r\n  catfile_command.add_description(\"Provide content or type and size information for repository objects\");\r\n  catfile_command.add_argument(\"-t\")\r\n    .help(\"Instead of the content, show the object type identified by <object>.\");\r\n\r\n  catfile_command.add_argument(\"-p\")\r\n    .help(\"Pretty-print the contents of <object> based on its type.\");\r\n\r\n  // git submodule subparser\r\n  argparse::ArgumentParser submodule_command(\"submodule\");\r\n  submodule_command.add_description(\"Initialize, update or inspect submodules\");\r\n  argparse::ArgumentParser submodule_update_command(\"update\");\r\n  submodule_update_command.add_description(\"Update the registered submodules to match what the superproject expects\");\r\n  submodule_update_command.add_argument(\"--init\")\r\n    .default_value(false)\r\n    .implicit_value(true);\r\n  submodule_update_command.add_argument(\"--recursive\")\r\n    .default_value(false)\r\n    .implicit_value(true);\r\n  submodule_command.add_subparser(submodule_update_command);\r\n\r\n  program.add_subparser(add_command);\r\n  program.add_subparser(commit_command);\r\n  program.add_subparser(catfile_command);\r\n  program.add_subparser(submodule_command);\r\n\r\n  try {\r\n    program.parse_args(argc, argv);\r\n  }\r\n  catch (const std::exception& err) {\r\n    std::cerr << err.what() << std::endl;\r\n    std::cerr << program;\r\n    return 1;\r\n  }\r\n\r\n  // Use arguments\r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./git --help\r\nUsage: git [-h] {add,cat-file,commit,submodule}\r\n\r\nOptional arguments:\r\n  -h, --help   \tshows help message and exits\r\n  -v, --version\tprints version information and exits\r\n\r\nSubcommands:\r\n  add           Add file contents to the index\r\n  cat-file      Provide content or type and size information for repository objects\r\n  commit        Record changes to the repository\r\n  submodule     Initialize, update or inspect submodules\r\n\r\nfoo@bar:/home/dev/$ ./git add --help\r\nUsage: add [-h] files\r\n\r\nAdd file contents to the index\r\n\r\nPositional arguments:\r\n  files        \tFiles to add content from. Fileglobs (e.g.  *.c) can be given to add all matching files.\r\n\r\nOptional arguments:\r\n  -h, --help   \tshows help message and exits\r\n  -v, --version\tprints version information and exits\r\n\r\nfoo@bar:/home/dev/$ ./git commit --help\r\nUsage: commit [-h] [--all] [--message VAR]\r\n\r\nRecord changes to the repository\r\n\r\nOptional arguments:\r\n  -h, --help   \tshows help message and exits\r\n  -v, --version\tprints version information and exits\r\n  -a, --all    \tTell the command to automatically stage files that have been modified and deleted.\r\n  -m, --message\tUse the given <msg> as the commit message.\r\n\r\nfoo@bar:/home/dev/$ ./git submodule --help\r\nUsage: submodule [-h] {update}\r\n\r\nInitialize, update or inspect submodules\r\n\r\nOptional arguments:\r\n  -h, --help   \tshows help message and exits\r\n  -v, --version\tprints version information and exits\r\n\r\nSubcommands:\r\n  update        Update the registered submodules to match what the superproject expects\r\n```\r\n\r\nWhen a help message is requested from a subparser, only the help for that particular parser will be printed. The help message will not include parent parser or sibling parser messages.\r\n\r\nAdditionally, every parser has the `.is_subcommand_used(\"<command_name>\")` and `.is_subcommand_used(subparser)` member functions to check if a subcommand was used. \r\n\r\nSometimes there may be a need to hide part of the subcommands from the user\r\nby suppressing information about them in an help message. To do this,\r\n```ArgumentParser``` contains the method ```.set_suppress(bool suppress)```:\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nargparse::ArgumentParser hidden_cmd(\"hidden\");\r\nhidden_cmd.add_argument(\"files\").remaining();\r\nhidden_cmd.set_suppress(true);\r\n\r\nprogram.add_subparser(hidden_cmd);\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main -h\r\nUsage: test [--help] [--version] {}\r\n\r\nOptional arguments:\r\n  -h, --help    shows help message and exits\r\n  -v, --version prints version information and exits\r\n\r\nfoo@bar:/home/dev/$ ./main hidden -h\r\nUsage: hidden [--help] [--version] files\r\n\r\nPositional arguments:\r\n  files         [nargs: 0 or more]\r\n\r\nOptional arguments:\r\n  -h, --help    shows help message and exits\r\n  -v, --version prints version information and exits\r\n```\r\n\r\n### Getting Argument and Subparser Instances\r\n\r\n```Argument``` and ```ArgumentParser``` instances added to an ```ArgumentParser``` can be retrieved with ```.at<T>()```. The default return type is ```Argument```.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"--dir\");\r\nprogram.at(\"--dir\").default_value(std::string(\"/home/user\"));\r\n\r\nprogram.add_subparser(argparse::ArgumentParser{\"walk\"});\r\nprogram.at<argparse::ArgumentParser>(\"walk\").add_argument(\"depth\");\r\n```\r\n\r\n### Parse Known Args\r\n\r\nSometimes a program may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the `parse_known_args()` function can be useful. It works much like `parse_args()` except that it does not produce an error when extra arguments are present. Instead, it returns a list of remaining argument strings.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n#include <cassert>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"test\");\r\n  program.add_argument(\"--foo\").implicit_value(true).default_value(false);\r\n  program.add_argument(\"bar\");\r\n\r\n  auto unknown_args =\r\n    program.parse_known_args({\"test\", \"--foo\", \"--badger\", \"BAR\", \"spam\"});\r\n\r\n  assert(program.get<bool>(\"--foo\") == true);\r\n  assert(program.get<std::string>(\"bar\") == std::string{\"BAR\"});\r\n  assert((unknown_args == std::vector<std::string>{\"--badger\", \"spam\"}));\r\n}\r\n```\r\n\r\n### Hidden argument and alias\r\n\r\nIt is sometimes desirable to offer an alias for an argument, but without it\r\nappearing it in the usage. For example, to phase out a deprecated wording of\r\nan argument while not breaking backwards compatible. This can be done with\r\nthe ``ArgumentParser::add_hidden_alias_for()` method.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nauto &arg = program.add_argument(\"--suppress\").flag();\r\nprogram.add_hidden_alias_for(arg, \"--supress\"); // old misspelled alias\r\n```\r\n\r\nThe ``Argument::hidden()`` method can also be used to prevent a (generally\r\noptional) argument from appearing in the usage or help.\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"--non-documented\").flag().hidden();\r\n```\r\n\r\nThis can also be used on positional arguments, but in that later case it only\r\nmakes sense in practice for the last ones.\r\n\r\n### ArgumentParser in bool Context\r\n\r\nAn `ArgumentParser` is `false` until it (or one of its subparsers) have extracted\r\nknown value(s) with `.parse_args` or `.parse_known_args`. When using `.parse_known_args`,\r\nunknown arguments will not make a parser `true`.\r\n\r\n### Custom Prefix Characters\r\n\r\nMost command-line options will use `-` as the prefix, e.g. `-f/--foo`. Parsers that need to support different or additional prefix characters, e.g. for options like `+f` or `/foo`, may specify them using the `set_prefix_chars()`.\r\n\r\nThe default prefix character is `-`.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n#include <cassert>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"test\");\r\n  program.set_prefix_chars(\"-+/\");\r\n\r\n  program.add_argument(\"+f\");\r\n  program.add_argument(\"--bar\");\r\n  program.add_argument(\"/foo\");\r\n\r\n  try {\r\n    program.parse_args(argc, argv);\r\n  }\r\n  catch (const std::exception& err) {\r\n    std::cerr << err.what() << std::endl;\r\n    std::cerr << program;\r\n    return 1;\r\n  }\r\n\r\n  if (program.is_used(\"+f\")) {\r\n    std::cout << \"+f    : \" << program.get(\"+f\") << \"\\n\";\r\n  }\r\n\r\n  if (program.is_used(\"--bar\")) {\r\n    std::cout << \"--bar : \" << program.get(\"--bar\") << \"\\n\";\r\n  }\r\n\r\n  if (program.is_used(\"/foo\")) {\r\n    std::cout << \"/foo  : \" << program.get(\"/foo\") << \"\\n\";\r\n  }  \r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main +f 5 --bar 3.14f /foo \"Hello\"\r\n+f    : 5\r\n--bar : 3.14f\r\n/foo  : Hello\r\n```\r\n\r\n### Custom Assignment Characters \r\n\r\nIn addition to prefix characters, custom 'assign' characters can be set. This setting is used to allow invocations like `./test --foo=Foo /B:Bar`.\r\n\r\nThe default assign character is `=`.\r\n\r\n```cpp\r\n#include <argparse/argparse.hpp>\r\n#include <cassert>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"test\");\r\n  program.set_prefix_chars(\"-+/\");\r\n  program.set_assign_chars(\"=:\");\r\n\r\n  program.add_argument(\"--foo\");\r\n  program.add_argument(\"/B\");\r\n\r\n  try {\r\n    program.parse_args(argc, argv);\r\n  }\r\n  catch (const std::exception& err) {\r\n    std::cerr << err.what() << std::endl;\r\n    std::cerr << program;\r\n    return 1;\r\n  }\r\n\r\n  if (program.is_used(\"--foo\")) {\r\n    std::cout << \"--foo : \" << program.get(\"--foo\") << \"\\n\";\r\n  }\r\n\r\n  if (program.is_used(\"/B\")) {\r\n    std::cout << \"/B    : \" << program.get(\"/B\") << \"\\n\";\r\n  }\r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main --foo=Foo /B:Bar\r\n--foo : Foo\r\n/B    : Bar\r\n```\r\n\r\n## Further Examples\r\n\r\n### Construct a JSON object from a filename argument\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"json_test\");\r\n\r\nprogram.add_argument(\"config\")\r\n  .action([](const std::string& value) {\r\n    // read a JSON file\r\n    std::ifstream stream(value);\r\n    nlohmann::json config_json;\r\n    stream >> config_json;\r\n    return config_json;\r\n  });\r\n\r\ntry {\r\n  program.parse_args({\"./test\", \"config.json\"});\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nnlohmann::json config = program.get<nlohmann::json>(\"config\");\r\n```\r\n\r\n### Positional Arguments with Compound Toggle Arguments\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"numbers\")\r\n  .nargs(3)\r\n  .scan<'i', int>();\r\n\r\nprogram.add_argument(\"-a\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\nprogram.add_argument(\"-b\")\r\n  .default_value(false)\r\n  .implicit_value(true);\r\n\r\nprogram.add_argument(\"-c\")\r\n  .nargs(2)\r\n  .scan<'g', float>();\r\n\r\nprogram.add_argument(\"--files\")\r\n  .nargs(3);\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto numbers = program.get<std::vector<int>>(\"numbers\");        // {1, 2, 3}\r\nauto a = program.get<bool>(\"-a\");                               // true\r\nauto b = program.get<bool>(\"-b\");                               // true\r\nauto c = program.get<std::vector<float>>(\"-c\");                 // {3.14f, 2.718f}\r\nauto files = program.get<std::vector<std::string>>(\"--files\");  // {\"a.txt\", \"b.txt\", \"c.txt\"}\r\n\r\n/// Some code that prints parsed arguments\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main 1 2 3 -abc 3.14 2.718 --files a.txt b.txt c.txt\r\nnumbers = {1, 2, 3}\r\na = true\r\nb = true\r\nc = {3.14, 2.718}\r\nfiles = {\"a.txt\", \"b.txt\", \"c.txt\"}\r\n```\r\n\r\n### Restricting the set of values for an argument\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"input\")\r\n  .default_value(std::string{\"baz\"})\r\n  .choices(\"foo\", \"bar\", \"baz\");\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto input = program.get(\"input\");\r\nstd::cout << input << std::endl;\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main fex\r\nInvalid argument \"fex\" - allowed options: {foo, bar, baz}\r\n```\r\n\r\nUsing choices also works with integer types, e.g.,\r\n\r\n```cpp\r\nargparse::ArgumentParser program(\"test\");\r\n\r\nprogram.add_argument(\"input\")\r\n  .default_value(0)\r\n  .choices(0, 1, 2, 3, 4, 5);\r\n\r\ntry {\r\n  program.parse_args(argc, argv);\r\n}\r\ncatch (const std::exception& err) {\r\n  std::cerr << err.what() << std::endl;\r\n  std::cerr << program;\r\n  std::exit(1);\r\n}\r\n\r\nauto input = program.get(\"input\");\r\nstd::cout << input << std::endl;\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./main 6\r\nInvalid argument \"6\" - allowed options: {0, 1, 2, 3, 4, 5}\r\n```\r\n\r\n### Using `option=value` syntax\r\n\r\n```cpp\r\n#include \"argparse.hpp\"\r\n#include <cassert>\r\n\r\nint main(int argc, char *argv[]) {\r\n  argparse::ArgumentParser program(\"test\");\r\n  program.add_argument(\"--foo\").implicit_value(true).default_value(false);\r\n  program.add_argument(\"--bar\");\r\n\r\n  try {\r\n    program.parse_args(argc, argv);\r\n  }\r\n  catch (const std::exception& err) {\r\n    std::cerr << err.what() << std::endl;\r\n    std::cerr << program;\r\n    return 1;\r\n  }\r\n\r\n  if (program.is_used(\"--foo\")) {\r\n    std::cout << \"--foo: \" << std::boolalpha << program.get<bool>(\"--foo\") << \"\\n\";\r\n  }\r\n\r\n  if (program.is_used(\"--bar\")) {\r\n    std::cout << \"--bar: \" << program.get(\"--bar\") << \"\\n\";\r\n  }  \r\n}\r\n```\r\n\r\n```console\r\nfoo@bar:/home/dev/$ ./test --bar=BAR --foo\r\n--foo: true\r\n--bar: BAR\r\n```\r\n\r\n### Advanced usage formatting\r\n\r\nBy default usage is reported on a single line.\r\n\r\nThe ``ArgumentParser::set_usage_max_line_width(width)`` method can be used\r\nto display the usage() on multiple lines, by defining the maximum line width.\r\n\r\nIt can be combined with a call to ``ArgumentParser::set_usage_break_on_mutex()``\r\nto ask grouped mutually exclusive arguments to be displayed on a separate line.\r\n\r\n``ArgumentParser::add_usage_newline()`` can also be used to force the next\r\nargument to be displayed on a new line in the usage output.\r\n\r\nThe following snippet\r\n\r\n```cpp\r\n    argparse::ArgumentParser program(\"program\");\r\n    program.set_usage_max_line_width(80);\r\n    program.set_usage_break_on_mutex();\r\n    program.add_argument(\"--quite-long-option-name\").flag();\r\n    auto &group = program.add_mutually_exclusive_group();\r\n    group.add_argument(\"-a\").flag();\r\n    group.add_argument(\"-b\").flag();\r\n    program.add_argument(\"-c\").flag();\r\n    program.add_argument(\"--another-one\").flag();\r\n    program.add_argument(\"-d\").flag();\r\n    program.add_argument(\"--yet-another-long-one\").flag();\r\n    program.add_argument(\"--will-go-on-new-line\").flag();\r\n    program.add_usage_newline();\r\n    program.add_argument(\"--new-line\").flag();\r\n    std::cout << program.usage() << std::endl;\r\n```\r\n\r\nwill display:\r\n```console\r\nUsage: program [--help] [--version] [--quite-long-option-name]\r\n               [[-a]|[-b]]\r\n               [-c] [--another-one] [-d] [--yet-another-long-one]\r\n               [--will-go-on-new-line]\r\n               [--new-line]\r\n```\r\n\r\nFurthermore arguments can be separated into several groups by calling\r\n``ArgumentParser::add_group(group_name)``. Only optional arguments should\r\nbe specified after the first call to add_group().\r\n\r\n```cpp\r\n    argparse::ArgumentParser program(\"program\");\r\n    program.set_usage_max_line_width(80);\r\n    program.add_argument(\"-a\").flag().help(\"help_a\");\r\n    program.add_group(\"Advanced options\");\r\n    program.add_argument(\"-b\").flag().help(\"help_b\");\r\n```\r\n\r\nwill display:\r\n```console\r\nUsage: program [--help] [--version] [-a]\r\n\r\nAdvanced options:\r\n               [-b]\r\n```\r\n\r\n## Developer Notes\r\n\r\n### Copying and Moving\r\n\r\n`argparse::ArgumentParser` is intended to be used in a single function - setup everything and parse arguments in one place. Attempting to move or copy invalidates internal references (issue #260). Thus, starting with v3.0, `argparse::ArgumentParser` copy and move constructors are marked as `delete`.\r\n\r\n## CMake Integration \r\n\r\nUse the latest argparse in your CMake project without copying any content.  \r\n\r\n```cmake\r\ncmake_minimum_required(VERSION 3.14)\r\n\r\nPROJECT(myproject)\r\n\r\n# fetch latest argparse\r\ninclude(FetchContent)\r\nFetchContent_Declare(\r\n    argparse\r\n    GIT_REPOSITORY https://github.com/p-ranav/argparse.git\r\n)\r\nFetchContent_MakeAvailable(argparse)\r\n\r\nadd_executable(myproject main.cpp)\r\ntarget_link_libraries(myproject argparse)\r\n```\r\n\r\n## Bazel Integration\r\n\r\nAdd an `http_archive` in WORKSPACE.bazel, for example\r\n\r\n```starlark\r\nhttp_archive(\r\n    name = \"argparse\",\r\n    sha256 = \"674e724c2702f0bfef1619161815257a407e1babce30d908327729fba6ce4124\",\r\n    strip_prefix = \"argparse-3.1\",\r\n    url = \"https://github.com/p-ranav/argparse/archive/refs/tags/v3.1.zip\",\r\n)\r\n```\r\n\r\n## Building, Installing, and Testing\r\n\r\n```bash\r\n# Clone the repository\r\ngit clone https://github.com/p-ranav/argparse\r\ncd argparse\r\n\r\n# Build the tests\r\nmkdir build\r\ncd build\r\ncmake -DARGPARSE_BUILD_SAMPLES=on -DARGPARSE_BUILD_TESTS=on ..\r\nmake\r\n\r\n# Run tests\r\n./test/tests\r\n\r\n# Install the library\r\nsudo make install\r\n```\r\n\r\n## Supported Toolchains\r\n\r\n| Compiler             | Standard Library | Test Environment   |\r\n| :------------------- | :--------------- | :----------------- |\r\n| GCC >= 8.3.0         | libstdc++        | Ubuntu 18.04       |\r\n| Clang >= 7.0.0       | libc++           | Xcode 10.2         |\r\n| MSVC >= 16.8         | Microsoft STL    | Visual Studio 2019 |\r\n\r\n## Contributing\r\nContributions are welcome, have a look at the [CONTRIBUTING.md](CONTRIBUTING.md) document for more information.\r\n\r\n## License\r\nThe project is available under the [MIT](https://opensource.org/licenses/MIT) license.\r\n"
        },
        {
          "name": "WORKSPACE.bazel",
          "type": "blob",
          "size": 0.025390625,
          "content": "workspace(name=\"argparse\")"
        },
        {
          "name": "clang_format.bash",
          "type": "blob",
          "size": 0.0625,
          "content": "clang-format -i include/argparse/*.hpp test/*.cpp samples/*.cpp\n"
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 0.2275390625,
          "content": "from conans import ConanFile\n\nclass ArgparseConan(ConanFile):\n    name = \"argparse\"\n    version = \"3.1\"\n    exports_sources = \"include/argparse.hpp\"\n    no_copy_source = True\n\n    def package(self):\n        self.copy(\"argparse.hpp\")\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "module",
          "type": "tree",
          "content": null
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "xmake.lua",
          "type": "blob",
          "size": 2.2431640625,
          "content": "set_xmakever(\"2.8.2\")\nset_project(\"argparse\")\n\nset_version(\"3.1.0\", { build = \"%Y%m%d%H%M\" })\n\noption(\"enable_module\")\noption(\"enable_std_import\", { defines = \"ARGPARSE_MODULE_USE_STD_MODULE\" })\noption(\"enable_tests\")\noption(\"enable_samples\")\n\nadd_cxxflags(\n    \"-Wall\",\n    \"-Wno-long-long\",\n    \"-pedantic\",\n    \"-Wsign-conversion\",\n    \"-Wshadow\",\n    \"-Wconversion\",\n    { toolsets = { \"clang\", \"gcc\" } }\n)\nadd_cxxflags(\"cl::/W4\")\n\nif is_plat(\"windows\") then\n    add_defines(\"_CRT_SECURE_NO_WARNINGS\")\nend\n\ntarget(\"argparse\", function()\n    set_languages(\"c++17\")\n    set_kind(\"headeronly\")\n    if get_config(\"enable_module\") then\n        set_languages(\"c++20\")\n        set_kind(\"static\") -- static atm because of a XMake bug, headeronly doesn't generate package module metadata\n    end\n\n    add_options(\"enable_std_import\")\n\n    add_includedirs(\"include\", { public = true })\n    add_headerfiles(\"include/argparse/argparse.hpp\")\n    if get_config(\"enable_module\") then\n        add_files(\"module/argparse.cppm\", { install = true })\n    end\nend)\n\nif get_config(\"enable_tests\") then\n    target(\"argparse_tests\", function()\n        set_kind(\"binary\")\n        set_languages(\"c++17\")\n        set_basename(\"tests\")\n\n        add_includedirs(\"test\")\n\n        add_files(\"test/main.cpp\", { defines = { \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\" } })\n        add_files(\"test/**.cpp\")\n\n        add_deps(\"argparse\")\n    end)\n\n    if get_config(\"enable_module\") then\n        target(\"argparse_module_tests\", function()\n            set_kind(\"binary\")\n            set_languages(\"c++20\")\n            set_basename(\"module_tests\")\n\n            add_defines(\"WITH_MODULE\")\n\n            add_includedirs(\"test\")\n\n            add_files(\"test/main.cpp\", { defines = { \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\" } })\n            add_files(\"test/**.cpp\")\n            add_files(\"test/argparse_details.cppm\")\n\n            add_deps(\"argparse\")\n        end)\n    end\nend\n\nif get_config(\"enable_samples\") then\n    for _, sample_file in ipairs(os.files(\"samples/*.cpp\")) do\n        target(path.basename(sample_file), function()\n            set_kind(\"binary\")\n            set_languages(\"c++17\")\n\n            add_files(sample_file)\n\n            set_policy(\"build.c++.modules\", false)\n\n            add_deps(\"argparse\")\n        end)\n    end\nend\n"
        }
      ]
    }
  ]
}