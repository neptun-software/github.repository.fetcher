{
  "metadata": {
    "timestamp": 1736565981770,
    "page": 961,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DmitryUlyanov/Multicore-TSNE",
      "stars": 1893,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 1.36328125,
          "content": "shallow_clone: true\nclone_depth: 2\nskip_tags: false\n\nnotifications:\n  - provider: Email\n    on_build_success: false\n    on_build_failure: false\n    on_build_status_changed: false\n\nenvironment:\n  fast_finish: true\n  matrix:\n    - PYTHON: C:\\Python36\n      WHEEL_PLATFORM: win32\n    - PYTHON: C:\\Python36-x64\n      EXTRA_CMAKE_ARGS: -DCMAKE_GENERATOR_PLATFORM=x64\n      WHEEL_PLATFORM: win_amd64\n\n  TWINE_USERNAME: placeholder\n  TWINE_PASSWORD: secret\n\ninstall:\n  # Install dependencies\n  - set \"PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%\"\n  - python -m pip install -U pip setuptools wheel\n  - python -m pip install --only-binary=all --pre scipy scikit-learn\n\n  # Build and install from wheel so we see this works\n  - python setup.py -v build_ext --cmake-args=%EXTRA_CMAKE_ARGS% bdist_wheel\n  # Rename the wheel to contain PEP-425 platform tags\n  - ps: mv dist\\*.whl dist\\MulticoreTSNE-$(python -c 'from setup import VERSION; print(VERSION)')-py2.py3-none-$env:WHEEL_PLATFORM.whl\n  - FOR /F %%a IN ('dir /b dist\\\\*.whl') DO (SET \"wheel=dist\\\\%%a\")\n\n  - python -m pip install %wheel%\n  - python -m pip install -U --no-deps %wheel%\n\nbuild: off\n\ntest_script:\n  - pushd .. & python -m unittest discover -v MulticoreTSNE & popd\n\nartifacts:\n  - path: 'dist\\*.whl'\n    name: wheel\n\non_success:\n  - python -m pip install twine\n  - if \"%APPVEYOR_REPO_TAG%\"==\"true\" python -m twine upload --skip-existing %wheel%\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "*.gz\n\n# cmake directories\nmulticore_tsne/*/*\nbuild"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.5087890625,
          "content": "language: python\ndist: trusty\nsudo: false\n\ncache:\n  apt: true\n  pip: true\n  ccache: true\n\naddons:\n  apt:\n    packages:\n      - cppcheck\n\nmatrix:\n  include:\n    - os: osx\n      language: generic\n      compiler: clang\n    - python: 2.7\n    - python: 3.6\n\nbefore_install:\n  - set -e\n  - if command -v cppcheck >/dev/null; then\n      cppcheck --enable=all --error-exitcode=1 multicore_tsne/*.{h,c,cpp};\n    fi\n\n  # Travis OS X image lacks Python3; download it from homebrew\n  - if [ \"$TRAVIS_OS_NAME\" = osx ]; then\n      brew update &&\n      brew install python3 &&\n      virtualenv env -p python3 &&\n      source env/bin/activate;\n    fi\n\n  - python setup.py -v bdist_wheel\n  - python setup.py -v sdist --formats=zip\n\ninstall:\n  # Tag the built wheels according to PEP-425\n  - if [ \"$TRAVIS_OS_NAME\" = osx ]; then\n      pip install delocate &&\n      delocate-wheel -v --require-archs=x86_64 dist/*.whl;\n    else\n      mv dist/*.whl `python -c 'import sys; parts = sys.argv[1].split(\"-\"); parts[4] = \"manylinux1_x86_64.whl\"; print(\"-\".join(parts))' dist/*.whl`;\n    fi &&\n    mv dist/*.whl `python -c 'import sys; parts = sys.argv[1].split(\"-\"); parts[2] = \"py2.py3\"; parts[3] = \"none\"; print(\"-\".join(parts))' dist/*.whl`\n\n  - pip install .[test]\n  - pip install -U dist/*.whl\n\nscript:\n  - cd ..; python -m unittest discover -v MulticoreTSNE.tests; cd -\n\nafter_success:\n  # TWINE_USERNAME/TWINE_PASSWORD env vars defined in Travis settings\n  - if [ \"$TRAVIS_TAG\" ]; then\n      pip install twine &&\n      twine upload --skip-existing dist/*;\n    fi\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.783203125,
          "content": "  Copyright (c) 2014, Laurens van der Maaten (Delft University of Technology)\n  Copyright (c) 2016, Dmitry Ulyanov\n  All rights reserved.\n \n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in the\n     documentation and/or other materials provided with the distribution.\n  3. All advertising materials mentioning features or use of this software\n     must display the following acknowledgement:\n     This product includes software developed by the Delft University of Technology.\n  4. Neither the name of the Delft University of Technology nor the names of \n     its contributors may be used to endorse or promote products derived from \n     this software without specific prior written permission.\n \n  THIS SOFTWARE IS PROVIDED BY LAURENS VAN DER MAATEN ''AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES \n  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO \n  EVENT SHALL LAURENS VAN DER MAATEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR \n  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING \n  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY \n  OF SUCH DAMAGE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.201171875,
          "content": "recursive-include   .                 CMakeLists.txt\nrecursive-include   multicore_tsne    *.cpp *.h\nrecursive-include   torch             *.lua *.rockspec\n\ninclude   *.txt *.md\ninclude   tsne-embedding.py\n"
        },
        {
          "name": "MulticoreTSNE",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.89453125,
          "content": "# Multicore t-SNE [![Build Status](https://travis-ci.org/DmitryUlyanov/Multicore-TSNE.svg?branch=master)](https://travis-ci.org/DmitryUlyanov/Multicore-TSNE)\n\nThis is a multicore modification of [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) by L. Van der Maaten with Python CFFI-based wrappers. This code also works **faster than sklearn.TSNE** on 1 core (as of version 0.18).\n\n<center><img src=\"mnist-tsne.png\" width=\"512\"></center>\n\n# What to expect\n\nBarnes-Hut t-SNE is done in two steps.\n\n- First step: an efficient data structure for nearest neighbours search is built and used to compute probabilities. This can be done in parallel for each point in the dataset, this is why we can expect a good speed-up by using more cores.\n\n- Second step: the embedding is optimized using gradient descent. This part is essentially consecutive so we can only optimize within iteration. In fact some parts can be parallelized effectively, but not all of them a parallelized for now. That is why the second step speed-up will not be as significant as first step sepeed-up but there is still room for improvement.\n\nSo when can you benefit from parallelization? It is almost true, that the second step computation time is constant of `D` and depends mostly on `N`. The first part's time depends on `D` a lot, so for small `D` `time(Step 1) << time(Step 2)`, for large `D` `time(Step 1) >> time(Step 2)`. As we are only good at parallelizing step 1 we will benefit most when `D` is large enough (MNIST's `D = 784` is large, `D = 10` even for `N=1000000` is not so much). I wrote multicore modification originally for [Springleaf competition](https://www.kaggle.com/c/springleaf-marketing-response), where my data table was about `300000 x 3000` and only several days left till the end of the competition so any speed-up was handy.\n\n# Benchmark\n\n### 1 core\n\nInterestingly, this code beats other implementations. We compare to `sklearn` (Barnes-Hut of course), L. Van der Maaten's [bhtsne](https://github.com/lvdmaaten/bhtsne), [py_bh_tsne repo](https://github.com/danielfrg/tsne) (cython wrapper for bhtsne with QuadTree). `perplexity = 30, theta=0.5` for every run. In fact [py_bh_tsne repo](https://github.com/danielfrg/tsne) works at the same speed as this code when using more optimization flags for the compiler.\n\nThis is a benchmark for `70000x784` MNIST data:\n\n| Method                       | Step 1 (sec)   | Step 2 (sec)  |\n| ---------------------------- |:---------------:| --------------:|\n| MulticoreTSNE(n_jobs=1)      | **912**         | **350**        |\n| bhtsne                       | 4257            | 1233           |\n| py_bh_tsne                   | 1232            | 367            |\n| sklearn(0.18)                | ~5400           | ~20920         |\n\nI did my best to find what is wrong with sklearn numbers, but it is the best benchmark I could do (you can find the test script in `MulticoreTSNE/examples` folder).\n\n### Multicore\n\nThis table shows a relative to 1 core speed-up when using `n` cores.\n\n| n_jobs        | Step 1    | Step 2   |\n| ------------- |:---------:| --------:|\n| 1             | 1x        | 1x       |\n| 2             | 1.54x     | 1.05x    |\n| 4             | 2.6x      | 1.2x     |\n| 8             | 5.6x      | 1.65x    |\n\n# How to use\n\n### Install\n\n#### Directly from pypi\n`pip install MulticoreTSNE`\n\n#### From source\n\nMake sure `cmake` is installed on your system, and you will also need a sensible C++ compiler, such as `gcc` or `llvm-clang`. On macOS, you can get both via [homebrew](https://brew.sh/).\n\nTo install the package, please do:\n```bash\ngit clone https://github.com/DmitryUlyanov/Multicore-TSNE.git\ncd Multicore-TSNE/\npip install .\n```\n\nTested with python >= 3.6 (conda).\n\n### Run\n\nYou can use it as a near drop-in replacement for [sklearn.manifold.TSNE](http://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html).\n\n```python\nfrom MulticoreTSNE import MulticoreTSNE as TSNE\n\ntsne = TSNE(n_jobs=4)\nY = tsne.fit_transform(X)\n```\n\nPlease refer to [sklearn TSNE manual](http://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html) for parameters explanation.\n\nThis implementation `n_components=2`, which is the most common case (use [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) or sklearn otherwise). Also note that some parameters are there just for the sake of compatibility with sklearn and are otherwise ignored. See `MulticoreTSNE` class docstring for more info.\n\n#### MNIST example\n```python\nfrom sklearn.datasets import fetch_openml\nfrom MulticoreTSNE import MulticoreTSNE as TSNE\nfrom matplotlib import pyplot as plt\n\nX, _ = fetch_openml(\n  \"mnist_784\", version=1, return_X_y=True, as_frame=False, parser=\"pandas\"\n)\nembeddings = TSNE(n_jobs=4).fit_transform(X)\nvis_x = embeddings[:, 0]\nvis_y = embeddings[:, 1]\nplt.scatter(vis_x, vis_y, c=digits.target, cmap=plt.cm.get_cmap(\"jet\", 10), marker='.')\nplt.colorbar(ticks=range(10))\nplt.clim(-0.5, 9.5)\nplt.show()\n```\n\n### Test\n\nYou can test it on MNIST dataset with the following command:\n\n```bash\npython MulticoreTSNE/examples/test.py --n_jobs <n_jobs>\n```\n\n#### Note on jupyter use\nTo make the computation log visible in jupyter please install `wurlitzer` (`pip install wurlitzer`) and execute this line in any cell beforehand:\n```\n%load_ext wurlitzer\n```\nMemory leakages are possible if you interrupt the process. Should be OK if you let it run until the end.\n\n# License\n\nInherited from [original repo's license](https://github.com/lvdmaaten/bhtsne).\n\n# Future work\n\n- Allow other types than double\n- Improve step 2 performance (possible)\n\n# Citation\n\nPlease cite this repository if it was useful for your research:\n\n```\n@misc{Ulyanov2016,\n  author = {Ulyanov, Dmitry},\n  title = {Multicore-TSNE},\n  year = {2016},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/DmitryUlyanov/Multicore-TSNE}},\n}\n```\n\nOf course, do not forget to cite [L. Van der Maaten's paper](http://lvdmaaten.github.io/publications/papers/JMLR_2014.pdf)\n"
        },
        {
          "name": "mnist-tsne.png",
          "type": "blob",
          "size": 293.1630859375,
          "content": null
        },
        {
          "name": "multicore_tsne",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0341796875,
          "content": "numpy\ncffi\ncmake>=3.17.0\npackaging\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 3.8447265625,
          "content": "import sys\nimport shutil\nimport os\nimport subprocess\nfrom os import path\nfrom subprocess import call as execute\n\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools import setup, find_packages, Extension\n\n\nPACKAGE_NAME = \"MulticoreTSNE\"\n\nVERSION = '0.1'\nLICENSE=\"BSD-3-clause\"\n\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=''):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\n\nclass CMakeBuild(build_ext):\n    user_options = build_ext.user_options\n    user_options.extend([\n        ('cmake-args=', None, 'extra CMake arguments passed on the cmake command line'),\n    ])\n\n    def initialize_options(self):\n        self.cmake_args = None\n        build_ext.initialize_options(self)\n\n    def get_cmake_version(self):\n        output = subprocess.check_output(['cmake', '--version']).decode('utf-8')\n        line = output.splitlines()[0]\n        version = line.split()[2]\n        return(version)\n        \n    def run(self):\n        if 0 != os.system('cmake --version'):\n            sys.exit('\\nError: Cannot find cmake. Install cmake, e.g. `pip install cmake`.')\n\n        for ext in self.extensions:\n            self.build_extension(ext)\n\n    def build_extension(self, ext):\n        from packaging import version\n        SOURCE_DIR = ext.sourcedir\n        EXT_DIR = path.abspath(path.dirname(self.get_ext_fullpath(ext.name)))\n        BUILD_TEMP = self.build_temp\n\n        shutil.rmtree(BUILD_TEMP, ignore_errors=True)\n        os.makedirs(BUILD_TEMP)\n\n        if version.parse(self.get_cmake_version()) < version.parse(\"3.22.0\"):\n            cmake_passthru_flag = \"--\"\n        else:\n            cmake_passthru_flag = \"-S\"\n\n        # Run cmake\n        build_type = 'Debug' if self.debug else 'Release'\n        if 0 != execute(['cmake',\n                         '-DCMAKE_BUILD_TYPE={}'.format(build_type),\n                         '-DCMAKE_VERBOSE_MAKEFILE={}'.format(int(self.verbose)),\n                         \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY='{}'\".format(EXT_DIR),\n                         # set Debug and Release paths to the output directory on Windows\n                         \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG='{}'\".format(EXT_DIR),\n                         \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE='{}'\".format(EXT_DIR),\n                         self.cmake_args or cmake_passthru_flag,\n                         SOURCE_DIR], cwd=BUILD_TEMP):\n            sys.exit('\\nERROR: Cannot generate Makefile. See above errors.')\n\n        # Run make\n        cmd = 'cmake --build .'\n        # For MSVC specify build type at build time\n        # https://stackoverflow.com/q/24460486/1925996\n        if sys.platform.startswith('win'):\n            cmd += ' --config ' + build_type\n        if 0 != execute(cmd, shell=True, cwd=BUILD_TEMP):\n            sys.exit('\\nERROR: Cannot find make? See above errors.')\n\n\nif __name__ == '__main__':\n    EXT_MODULES = []\n    if 'test' not in sys.argv:\n        EXT_MODULES = [CMakeExtension('MulticoreTSNE.MulticoreTSNE',\n                                      sourcedir='multicore_tsne')]\n    setup(\n        name=PACKAGE_NAME,\n        version=VERSION,\n        license=LICENSE,\n        description='Multicore version of t-SNE algorithm.',\n        author=\"Dmitry Ulyanov (based on L. Van der Maaten's code)\",\n        author_email='dmitry.ulyanov.msu@gmail.com',\n        url='https://github.com/DmitryUlyanov/Multicore-TSNE',\n        install_requires=[\n            'numpy',\n            'cffi'\n        ],\n        setup_requires=[\"packaging\"],\n        packages=find_packages(),\n        include_package_data=True,\n\n        ext_modules=EXT_MODULES,\n        cmdclass={'build_ext': CMakeBuild},\n\n        extras_require={\n            'test': [\n                'scikit-learn',\n                'scipy',\n            ],\n        },\n        test_suite='MulticoreTSNE.tests',\n        tests_require=['MulticoreTSNE[test]']\n    )\n"
        },
        {
          "name": "tsne-embedding.py",
          "type": "blob",
          "size": 2.2236328125,
          "content": "from MulticoreTSNE import MulticoreTSNE as TSNE\nimport skimage.io\nimport argparse\nimport glob\nfrom scipy.spatial import KDTree\nimport numpy as np\n\n\ndef imscatter(images, positions):\n    '''\n        Creates a scatter plot, where each plot is shown by corresponding image\n    '''\n    positions = np.array(positions)\n\n    bottoms = positions[:, 1] - np.array([im.shape[1] / 2.0 for im in images])\n    tops = bottoms + np.array([im.shape[1] for im in images])\n\n    lefts = positions[:, 0] - np.array([im.shape[0] / 2.0 for im in images])\n    rigths = lefts + np.array([im.shape[0] for im in images])\n\n    most_bottom = int(np.floor(bottoms.min()))\n    most_top = int(np.ceil(tops.max()))\n\n    most_left = int(np.floor(lefts.min()))\n    most_right = int(np.ceil(rigths.max()))\n\n    scatter_image = np.zeros(\n        [most_right - most_left, most_top - most_bottom, 3], dtype=imgs[0].dtype)\n\n    # shift, now all from zero\n    positions -= [most_left, most_bottom]\n\n    for im, pos in zip(images, positions):\n\n        xl = int(pos[0] - im.shape[0] / 2)\n        xr = xl + im.shape[0]\n\n        yb = int(pos[1] - im.shape[1] / 2)\n        yt = yb + im.shape[1]\n\n        scatter_image[xl:xr, yb:yt, :] = im\n    return scatter_image\n\n\nif __name__ == '__main__':\n    '''\n    Takes a set of images and returns their T-SNE embedding\n    '''\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--in_glob\")\n    parser.add_argument(\"--out_path\", default='embedding.png')\n    args = parser.parse_args()\n\n    files = glob.glob(args.in_glob)\n\n    print('Reading images')\n    feats, imgs = [], []\n    for f in files:\n        im = skimage.io.imread(f)\n\n        feats.append(im.ravel())\n\n        if im.ndim == 2:\n            im = im[:, :, None]\n        imgs.append(im)\n\n    feats = np.vstack(feats).astype(np.float64)\n\n    print('Running T-SNE')\n    tsne = TSNE(n_jobs=1)\n    embedding = tsne.fit_transform(feats)\n\n    # Find an appropriate scaling, so that the images not overlap much\n    kdt = KDTree(embedding)\n    dists = kdt.query(embedding, k=2)[0][:, 1]\n    c = (imgs[0].shape[0] + imgs[0].shape[1]) / 2 / np.percentile(dists, 30)\n\n    print('Creating an image scatter')\n    img = imscatter(imgs, embedding * c)\n\n    print('Saving result')\n    skimage.io.imsave(args.out_path, img)\n"
        }
      ]
    }
  ]
}