{
  "metadata": {
    "timestamp": 1736565477931,
    "page": 335,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "homenc/HElib",
      "stars": 3166,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.1015625,
          "content": "---\nLanguage:        Cpp\nBasedOnStyle:  LLVM\nAlwaysBreakTemplateDeclarations: Yes # Changed from Multiline\nBinPackArguments: false # Changed from true\nBinPackParameters: false # Changed from true\nBreakInheritanceList: AfterColon # Changed from BeforeColon\nBreakConstructorInitializers: AfterColon # Changed from BeforeColon\nConstructorInitializerAllOnOneLineOrOnePerLine: true # Changed from false\nSortIncludes: false # Changed from true - TRY to make it true, might not work\nSortUsingDeclarations: false # Changed from true - TRY to make it true, might not work\nPointerAlignment: Left # Changed from Right\nBreakBeforeBraces: Mozilla # Changed to break after class/struct/function/..., but not after statement (if/while/for)\nPenaltyReturnTypeOnItsOwnLine: 1000 # Changed from 60 to avoid break after return type\nAllowAllArgumentsOnNextLine: false # Changed to avoid all call arguments on next line\nAllowAllParametersOfDeclarationOnNextLine: false # Changed to avoid all function parameters on next line\n#Standard: c++14 # This should validate the input to c++14 standard, but it is not supported in clang-9. For future use.\n...\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.2109375,
          "content": "# A local cmake cache will affect the docker image build\nCMakeCache.txt\n# Typical build directory name - if copied in from the host, the image will \n# be very bloated and could interfere with the build process\nbuild\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.42578125,
          "content": "gh-pages/\nbuild/\n\n__pycache__/\n\n**.log\n**.sk\n**.pk\n**.out\n**.ptxt\n**.ctxt\n**/CMakeCache.txt\n\nsrc/fhe.a\nsrc/*.o\nsrc/*_x\nsrc/*_x.exe\n\nMakefile-*\nsrc/makedep.d\nsrc/*_x.dSYM\nsrc/*.sh\nsrc/*.bin\nsrc/*.txt\n\n**.bak\n**.swp\n**.DS_Store\n\n# Exception for CMakeLists file\n!**/CMakeLists.txt\n\n# Exception for sample files\n!src/misc/iotest_asciiBE.txt\n!src/misc/iotest_asciiLE.txt\n!src/misc/iotest_binBE.bin\n!src/misc/iotest_binLE.bin\n\n/html/\n/latex/\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 15.37109375,
          "content": "Release Changes\n===============\n\nHElib 2.3.0, July 2023\n======================\n(tagged as v2.3.0)\n\n* Added support for processing queries with the NOT operator homomorphically.\n* Introduced the NOT Expr, and a corresponding inline NOT QueryExpr Within the weights, or CNF, framework:\n  * Extensions to the ExpandOr() function to queries with NOT operators, via a new function negate()\n  * New function Tidy() which eliminates duplicate columns in inner clauses, or columns and their negation in inner clauses that can be created by squashing ORs. It also eliminates empty clauses,\n  * Put the code from build() which constructed the corresponding weights into a new function buildWeights(), and extended this to the case there are negations of columns\n  * New framework which evaluates queries homomorphically directly from the string:\n  * New function removeOr() within the QueryBuilder class which generates a new query string which is logically equivalent, but only has Ands and Nots\n  * Overloaded contains() function that takes a string instead of a QueryType, and evaluates the RPN directly using a stack of ciphertexts\n\n* Updated CI\n  * Deprecated build&test on Ubuntu 20.04\n  * Updated build&test on Ubuntu 22.04\n  * Added build&test on macOS 12 and MacOS13\n\n* Bug Fixes\n\n\nHElib 2.2.1, October 2021\n=========================\n(tagged as v2.2.1)\n\n* Improved NTT bechmark code\n* CI update\n* Improvements to partial match logic\n* Bug fixes\n\nHElib 2.2.0, September 2021\n=========================\n(tagged as v2.2.0)\n\n* Intel HEXL integration (experimental)\n  * HEXL NTT acceleration for m as a power of 2\n  * HEXL acceleration to fundamental ciphertext operations\n  * Documentation update\n* Update NTL dependency to version 11.5.1\n* Update GMP dependency to version 6.2.1\n* Update to benchmarks\n* Bug fixes\n\nHElib 2.1.0, March 2021\n=========================\n(tagged as v2.1.0)\n\n* Deprecated APIs\n  * Documentation update: deprecated list\n  * Marked functions as deprecated\n  * Updated examples\n* Documentation update: PtxtArray JSON IO\n* Bug fixes\n\nHElib 2.0.0, January 2021\n=========================\n(tagged as v2.0.0)\n\n* Contains API changes that are not backwards compatible with v1.x.x\n  * Changes to Context API\n  * Must use ContextBuilder to build context\n  * New serialization APIs: binary and JSON\n* CKKS coding tutorials\n* Bug fixes\n\nHElib 1.3.1, December 2020\n=========================\n(tagged as v1.3.1)\n\n* Refactoring of CKKS Mitigation\n* Re-instated `Ctxt` isCorrect\n* Ctxt Conjugation fix\n* Added GMP and NTL alternative download locations\n\nHElib 1.3.0, December 2020\n=========================\n(tagged as v1.3.0)\n\nNovember-December 2020\n---------------------\n* Mitigation for the CKKS vulnerability recently [observed](https://eprint.iacr.org/2020/1533.pdf) by Li and Micciancio\n* Context Builder using builder pattern\n* HElib now requires C++17\n\nHElib 1.2.0, November 2020\n=========================\n(tagged as v1.2.0)\n\nOctober-November 2020\n---------------------\n* Mitigation for potential CKKS vulnerability.\n* Additional API changes for parameters to the CKKS encoding functions.\n* New infrastructure for benchmarks\n* Updated ClonedPtr\n* Additional Ctxt tests\n* Bug Fixes\n\nHElib 1.1.0, October 2020\n=========================\n(tagged as v1.1.0)\n\nAugst-October 2020\n------------------\n* Updated & enhanced security level estimation\n* Experimental Tool for computing sample parameters for CKKS\n* Improved testing procedures and documentation\n* Multi platform and multi configuration Travis-CI pipeline\n* Added version.{h,cpp)\n* Bug Fixes:\n  * CKKS divide by zero\n  * version.h\n  * compatibility with cmake 3.10.x\n\nHElib 1.1.0 Beta 0, August 2020\n===============================\n(tagged as v1.1.0-beta.0)\n\nJune-August 2020\n------------------\n* Utils\n  * create-context\n  * encrypt/decrypt\n  * encode/decode examples\n* Improvements to noise management\n* Move to CMake >= 3.10.2\n* Doxygen improved look and feel\n* Improved docs\n* New examples and mini-tutorial on private preserving db query\n* Configurable PSI/PIR beta\n* Some tools in `misc/` for code formatting and algebra generation\n* `Warning` messages are now logged (default `helib.log`)\n* Bug fixes\n\nHElib 1.0.2, June 2020\n===============================\n(tagged as v1.0.2)\n\nApril-June 2020\n------------------\n* Source code contribution policy\n* HElib now builds with compiler pedantic flags\n* Consistent C++ format style adopted\n* Improved sampling functions\n* Bug fixes\n\nHElib 1.0.1, April 2020\n===============================\n(tagged as v1.0.1)\n\nJanuary-April 2020\n------------------\n* Additional BGV examples BGV_(packed and binary)_arithmetic and simple BGV_database_lookup\n* Improved powerful basis\n* Enhancements and extensions to Binary operations\n* Enhancements to Ptxt functions\n* Enhancements to Ctxt Functions\n* Enhancements and fixes to `ArgMap` functionality\n* Compilation warning messages clean-up\n* Updates to Docker build\n* Using stable Google Test framework to HElib testing suite.\n* Additional tests ported to using Google Test framework\n* Bug fixes\n\nHElib 1.0.0, January 2020\n===============================\n(tagged as v1.0.0)\n\nDecember 2019\n-------------\n* C++14 Standard (minimum level)\n* New `Ptxt` Plaintext class that implements the same functionality of the `Ctxt` ciphertext class.  \n* Improved version of the `ArgMap` API for command line arguments.  \n* Restructuring of the project directory tree.  \n* Removed AES example - improved version on its way.  \n* Doxygen documentation.  \n* Bug fixes.\n\nHElib 1.0.0 beta 2, November 2019\n===============================\n(tagged as 1.0.0-beta2-Nov2019)\n\nSeptember-November 2019\n-----------------------\n* Significant refactoring and cleanup of codebase.  \n* New `helib` namespace.  \n* New `examples` and `benchmarks` directory trees.  \n* Improvements to bootstrapping.  \n* Better tests for bootstrapping and binary arithmetic in BGV.   \n* Docs and example code for binary arithmetic.  \n* Overall code and performance improvements in `NumbTh.cpp`.   \n* HElib now avoids *very bad* generators.   \n* Bug fixes.\n\nHElib 1.0.0 beta 1, August 2019\n===============================\n(tagged as 1.0.0-beta1-Aug2019)\n\nAugust 2019\n-----------\n* Improved noise management in HElib.  \n* Better and more robust bootstrapping algorithm.\n\nJuly 2019\n---------\n* Added new bootstrapping and PGFFT tests.\n\nJune 2019\n---------\n* Added implementation of PGFFT to replace Armadillo for FFTs in\nthe CKKS scheme. See comments in `PGFFT.h` for more information.\n\nMay 2019\n--------\n* CKKS bug fixes and fixed compiler warnings.\n\nApril 2019\n----------\n* Moved the HElib repository on github from shaih/HElib to HomEnc/HElib.  \n* Introduced HElib-specific exceptions, replaced C `assert`, NTL\n* Error and `std::exception` to use HElib-specific assertions that throw the new exceptions.  \n* See comments in `assertions.h` and `exceptions.h` for usage information.\n\nMarch 2019\n----------\n* Introduced new test framework (google test), documented in [TESTS.md](TESTS.md).  \n* Previous framework will be deprecated. Added a cmake build script for building HElib and dependencies, documented in [INSTALL.md](INSTALL.md).  \n* Added an example program, see `example program`.\n\n\nHElib 1.0.0 beta 0, January 2019\n===============================\n(tagged as 1.0.0-beta0-Jan2019)\n \nThis commit includes multiple changes to the library. We hope to add documentation over the next few weeks, then make it into an official version 1.0.0 release. Below is a summary of the main changes since March of 2018.\n\n\n## 1. Decoupling modulus-switching resolution from size of primes in the chain\n\nWith this version, we greatly refined the supported resolution for modulus switching. In previous versions all the modulus in the chain were of the same size, except perhaps one that was exactly half the size of the others. As a result, modulus switching was always confined to a rather coarse resolution. For example when the moduli size was 50 bits and the half-size modulus was 25 bits long, modulus switching had to drop multiples of 25 bits every time.\n\nIn the current version the application can specify the target resolution, using the optional 'resolution' argument of the method `FHEcontext::buildModChain` (with `resolution=3` as the default). HElib now keeps moduli of different sizes, and attempts to find a subset of them with sizes adding up to what's needed.\n\nAn important implication of this change is that HElib no longer has a notion of a discrete number of \"levels\" that are available for computation. Instead it has a notion of \"capacity\" of a ciphertext, which is just the logarithm of the modulus/noise ratio. One can get the current capacity of a ciphertext by calling `ct.capacity()` for the natural logarithm or `ct.bitCapacity()` for the logarithm base 2.\n\nWhen calling `FHEcontext::buildModChain`, the number-of-levels argument is replaced by a number-of-bits arguments. The task of determining the required number of bits for any given computation is left to the calling application. (We may provide some functions to help make that decisions, but they are not available yet.)\n\nSome convenience methods that we do provide are `ct.naturalSize()` that returns the size (natural logarithm) that this ciphertext should be mod-switched to if we square it, and `ct.naturalPrimeSet()` that returns the corresponding prime-set.\n\n\n## 2. Preliminary support for the CKKS cryptosystem\n\nIncluded in this version is a draft implementation of the CKKS approximate-number homomorphic encryption. To access this implementation, one needs to create an `FHEcontext` with \"plaintext space modulus\" `p=-1`, and using the parameter `r` to specify the requested precision. For example setting\n```c++\n  FHEcontext context(/*m=*/4096, /*p=*/-1, /*r=*/8);\n```\nwill set up an instance of CKKS over the 2^12 cyclotomic ring, requesting to keep precision of 1/256 (i.e., 8 bits to the right of the binary point). The implementation includes a `EncryptedArrayCx` class that handles the encoding and decoding of these instances, see EncryptedArray.h.\n\nWe use the same chassis for CKKS as for BGV, and in particular we support arbitrary cyclotomics (not just powers of two). But not everything is implemented for this case yet. (For instance `EncryptedArray::shift1D` is not implemented for CKKS ciphertexts.)\n\nThis implementation is quite preliminary, and for now it only \"does the right thing\" as long as all the complex data elements throughout the computation are close to one in absolute value. For smaller data values the requested precision will typically not be enough, while for larger values the implementation will spend too much resources trying to keep the precision way too high.\n\n\n## 3. More rigorous dynamic noise estimates\n\nHElib includes logic to estimate the level of noise in the ciphertext, and many of the library's housekeeping operations depend on this estimate. Crucially, big discrepancies between the actual noise and the estimated one may lead to decryption errors.\n\nEarlier version roughly kept an estimate of the L2-squared noise of the coefficient representation of the ring elements, using various hand-wavy methods (which often times were not even heuristically sound). The current version instead keeps high-probability bound on the L-infinity norm in the canonical embedding, and tries to provide at least a heuristic guarantee of no decryption errors. The result is sometimes more conservative modulus-switching choices.\n\nWe added to the `FHEcontext` class a data member `scale` that represents the \"number of standard deviations\" used in our high-probability heuristic bounds. It defaults to `scale=10`, corresponding to probability roughly 2^{-76} for a normal random variable being more than 10 standard deviations away from its mean. The application can set `context.scale` to other values, it controls the estimated size of the noise terms in freshly sampled elements and other operations (such as modulus switching and key switching). See more documentation in FHEContext.h.\n\nAlso with this version we no longer use the \"ring constant\" data member `cM` in the PAlgebra class for noise estimate. That data member is only used in recryption, to tweak the size computation for the \"powerful basis\" of elements. See more documentation in recryption.h under the `setAE()` function.\n\n\n## 4. Other notable changes\n\n### 4a. Keeping an integer factor in BGV\nIn previous versions we used the decryption invariant\n\n    [<sk,ct>]_q = q*m (mod p),\n\nwhich is convenient for the modulus switching operation. One of the consequences of this invariant, however, is that whenever we multiply two ciphertexts we have to multiply the result by q^{-1} mod p, which increases the noise (especially for large plaintext spaces p).\n\nIn this version we added a `long intFactor` data member to ciphertexts, and we now use the modified invariant\n\n    [<sk,ct>]_q = intFactor*q*m (mod p),\n\nThis is just as convenient as before for modulus switching, but it allows us to just modify the `intFactor` (without changing the noise) after multiplication. When we add two ciphertexts we still need to make sure that they both have the same `intFactor`, but it is easy to see that this can be done while increasing the noise of the result by at most a sqrt(p) factor.\n\n### 4b. Wider noise sampling for non-power-of-two ring-LWE\nFixed a security bug, related to the ring-LWE assumption in non-power-of-two cyclotomic rings. Before we always sampled the noise with a constant width in the coefficient representation (sigma=3.2 by default). This is an acceptable choice for power-of-two cyclotomics, but not otherwise. In the new version, for the m'th cyclotomic (with m not a power of two), we sample a *degree-m polynomial* in coefficient representation using Gaussian width sigma*sqrt(m), and then reduce the result modulo Phi_m(X). This yields somewhat larger noise terms.\n\nOn the other hand, when sampling noise terms during key-generation, we check the canonical-embedding norm of the result and re-sample if it is too large. (Specifically we set the parameters so that the probability of re-sampling is below 1/2.) This very often yields smaller noise terms for the keys.\n\n### 4c. Implemented the Chen-Han \"thin\" bootstrapping procedure\nImplemented the faster procedure for bootstrapping lightly packed ciphertexts (where the slots contain only integers), from [[Chen-Han, Eurocrypt 2018]](https://ia.cr/2018/067). Integrated this procedure with the improved linear algebra methods of HElib.\n\n### 4d. Bootstrapping parameters handled more rigorously\nCorrected some mistakes and tightened the analysis in [[Halevi-Shoup, Eurocrypt 2015]](https://ia.cr/2014/873), specifically Lemmas 5.1 and 5.2 and appendix A. This makes very little difference for bootstrapping with a prime plaintext space p, but a dramatic difference for plaintext space p^r for r>1. For example bootstrapping with plaintext space p^r=2^8 is now almost as efficient as for plaintext space p=2.\n\n## 5. Minor changes\n* Modified `Makefile` to look for local settings in the file `local-defs`;\n* Introduced binary serialization/deserialization (vs. the previous ascii-based method);\n* Removed all 'using' from header files;\n* Added innerProduct function on wrapped vectors (see `CtPtrs.h`);\n* `DoubleCRT` constructors no longer have default prime-set;\n* Added a \"destructive\" multiply method, calling `ct1.multLowLvl(ct, true)` may mod-switch both `c1` and `c2`;\n* Made `FHEPubKey::Encrypt` virtual, overridden by `FHESecKey::Encrypt`;\n* Small changes in how the digits are set-up in `FHEcontext` to make their size more uniform;\n* Eliminated some code duplication between \"thin\" and \"think\" bootstrapping in recryption.cpp;\n* Added some more functions/options in the debugging module.\n"
        },
        {
          "name": "CKKS-security.md",
          "type": "blob",
          "size": 10.650390625,
          "content": "# Security of Approximate-Numbers Homomorphic Encryption\n\nSecurity of standard (not homomorphic) encryption scheme is fairly well understood nowadays, and it usually comes in two flavors: An encryption scheme may only resists passive attackers (that can view encrypted data but not manipulate it), or it can also resist active attackers that can manipulate the encrypted data and then observe how it is decrypted.\nThe crypto lingo for the weaker (passive) notion is [CPA-security](https://en.wikipedia.org/wiki/Chosen-plaintext_attack), while the stronger is called [CCA-security](https://en.wikipedia.org/wiki/Chosen-ciphertext_attack). (These acronyms stand for chosen-plaintext-attacks and chosen-ciphertext-attacks, respectively.)\nIt is well understood that to protect data at rest or in transit, one must use CCA-secure encryption. CPA-security may suffice when the encryption is used as one component in a larger system, and protection against active attackers is provided by other components in that system.\n\nFor homomorphic encryption (HE) schemes, it is well known that they inherently cannot be CCA secure. One consequence of their non-CCA-security is that the system must ensure that decryption is never applied to invalid ciphertexts.<sup>[1](#validCtxt)</sup> Indeed, with contemporary HE schemes, allowing the attacker to submit invalid ciphertexts to be decrypted would typically result in exposure of the secret key. It is thus a commonly accepted practice for HE schemes to make do with CPA security, and rely on the system around the HE to provide the extra protection that may be needed.\n\nRecently, Li and Micciancio [observed](https://eprint.iacr.org/2020/1533) that for *approximate-number* HE schemes, the common notion of CPA security may not be enough even against passive attackers. The crucial difference is that since the scheme itself adds some error, the attacker could learn something from the decryption result *even if it knows what the decrypted result was supposed to be*. Specifically, it learns the error, which may leak information about the secret key. Li and Micciancio described simple attacks on the CKKS approximate-numbers scheme that expose the secret key after seeing a small number of decryption results (sometimes as few as a single decryption).\n\n## Mitigating the Li-Micciancio attacks\n\nIn response to this observation, HElib now includes countermeasures to mitigate this risk. In particular, the HElib decryption routine for CKKS was modified to add some key-independent noise, masking the key-dependent noise and making the Li-Micciancio attacks harder to mount. This extra noise, however, reduces the accuracy of the decrypted result. By default, the magnitude of this key-independent noise is chosen equal to the noise-bound that HElib keeps for the ciphertext to be decrypted, but that bound may be over-conservative and hence the added noise could sometimes cause a significant decrease in accuracy. HElib therefore provides the application the means to specify the required accuracy on decryption, and will then add the largest amount of noise subject to this accuracy constraint.\n\nApplications that use CKKS need to walk a fine line, balancing security, accuracy, and performance. Below we describe a framework for developing CCKS-based applications while taking these aspect into account. Roughly, we recommend that the application try to get a tight estimate for the error, and then use that estimate instead of the noise bound that HElib computes.\n\n1. Start by identifying the (class of) processes that the application needs to apply to the data;\n2. Identify the *required precision* from the processed results;\n3. Run these processes in HElib on test data to determine the parameters to be used, roughly as follows:\n   1. Find some parameter setting where `context.securityLevel()` returns high enough security and the library does not report decryption errors;\n   2. Experimentally find a fairly tight bound on the noise magnitude of the decrypted results, when called with the accuracy parameter from Step 2. This can be done by running HElib processing many times and comparing the decrypted results to what you get when applying the same processing to plaintext data;\n   3. Compare the noise bounds that you get from Step 3.2 above with the estimated error that HElib computes just prior to decryption, which can be accessed via `ctxt.errorBound()`. If the experimental noise is significantly smaller than what `ctxt.errorBound()` returns then use `ctxt.bumpNoiseBound()` prior to decryption to force HElib to use the tighter error estimate.\n   4. Repeat Steps 3.1-3.3, increasing the parameters until decryption no longer emits a warning about the added noise being too small.\n\nWe now elaborate more on each of these steps.\n\n### Steps 1-2, Processes and Required Precision\n\nAs with any application of HE, the starting point is ensuring adequate functionality. The developers must therefore determine the operations to be computed and the required *output precision*. Some applications only need to compute a single function while others need to handle a wider class of functions, but at the very least the developers should determine the maximum depth of supported circuits and the maximum precision required.\n\nIn HElib, the application gets to specify the *input precision* for encrypting plaintext data, and each level in the circuit reduces the precision by one (or upto 1.5) bits, namely the error roughly doubles for each level. For example using the helper class `PtxtArray` one could call `ptxt.encrypt(ctxt, ptxtMagnitude, precision)`,<sup>[2](#optPrecision)</sup> which would result in encryption of the given input plaintext with error bounded by 2<sup>-precision</sup>.\nAfter evaluating a depth-three circuit (say), the error will grow to a little more than 2<sup>3-precision</sup>. An application requiring *p* bits of output precision after the evaluation of a depth-*d* circuit should then encrypt with input precision somewhere between *p+d* and *p+3d/2*.\n\n### Step 3, Finding Matching Parameters\n\nAfter determining the required depth *d* and output precision *p*, the application developers need to find some parameters that yield this output precision while ensuring security. This typically involves an iterative trial-and-error procedure, as follows:\n\n1. Begin with some rough estimate of the parameters: The total bitlength of the modulus needed for a depth-*d* circuit is typically something like *22(d+1)*, and the ring dimension needed to get 128-bit security with this modulus is around *750(d+1)* (rounded up to a power of two, since the current CKKS support in HElib was only tested with power-of-two rings).\n\n   Denote by *m* the next power of two larger than *750(d+1)*, then these initial parameters can be set in HElib by using the `ContextBuilder` class, setting\n   ```\n     Context context =\n         ContextBuilder<CKKS>().m(m).bits(16*(d+1)).precision(p+d).c(3).build();\n   ```\n   Note that the number of bits specified above is only *16(d+1)* rather than *22(d+1)*, and there is a mysterious additional parameter *c=3* satisfying *(c+1)/c ~ 22/16*. The quantity *bits=16(d+1)* is an estimate for what's needed for a depth-*d* circuit, and the total modulus bitsize in HElib is obtained roughly as *bits&middot;(c+1)/c*. (See discussion of *ciphertext vs. special primes* in the [HElib document](https://eprint.iacr.org/2020/1481), section 5.1.) One can get slightly smaller total bitsize for the same functionality by increasing the *c* parameter from its default value of *c=3*, but the keysize and running time grow almost linearly with *c*.\n\n   After setting these parameters, run HElib processing and check if the library complains about possible decryption errors, and use these experiments to increase or decrease the *bits* and *m* parameters. You should also use the interface `context.securityLevel()` to check that this combination of parameters *m,bits,precision* and *c* yields an acceptable level of security.\n\n2. Check that these parameters indeed yield the required output precision. Namely run several experiments of HElib processing, decrypting the result with the optional precision argument (e.g., using the interface `ptxt.rawDecrypt(ctxt, secretKey)` of the `ptxtArray` class), and comparing the outcome with the result of plaintext processing. (At this point you should ignore any warning from HEib about the added noise being too small.) Revisit the parameters from Step 1 above until both security and output precision are acceptable.\n\n3. Next, check the error bound that HElib reports via `ctxt.errorBound()` just prior to decryption, to the actual error that was observed in the previous step (which presumably is no more than *2<sup>-p</sup>*). If the HElib estimate is significantly larger than the actual noise, then use `ctxt.bumpNoiseBound()` prior to decryption to force HElib to use the \"right estimate\".\n\n4. At this point, you need to switch to using `ptxt.decrypt(ctxt, secretKey, p)` and check that HElib no longer emits a warning message on decryption about the added noise being too small. If you still see that warning, then you need to revisit the parameter setting, increasing the *bits* parameter (and other parameters as needed to maintain security and precision), until this warning is no longer displayed.\n\nAs a final comment, we remark that this procedure is only adequate for cases where the threat model include the adversary only getting access to a handful of decryption results. If the total amount of information available to the adversary about decryption queries is much larger, then the application needs to increase the *bits* parameter from above. In particular, to withstand an attack that has access to the results from decryption of *D* ciphertexts, the *bits* parameter should be increased roughly by a factor of *<math><msqrt><mi>D</mi></msqrt></math>*, and the input-precision parameter should similarly be increased to *<math><msqrt><mi>D</mi></msqrt>(p+d)</math>*.\n\n---------------------------------------\n<a name=\"validCtxt\"><sup>1</sup></a>\nIn HElib, a ciphertext is *valid* if it was produced using the library's encryption and evaluation routines and does not contain too much noise. In particular, decryption using should not emit a warning about \"decrypting with too much noise\".\n\n<a name=\"optPrecision\"><sup>2</sup></a>\nThe `ptxtMagnitude`, and `precision` arguments are optional, with defaults that depend on the context and the actual plaintext to be encrypted. Importantly, the precision (if specified) indicates an absolute number, *not* a fraction of the plaintext magnitude. For example calling with `precision=3` yields an error of magnitude 1/8, whether it is called with `ptxtMagnitude=16`, and `ptxtMagnitude=1`. Finally note that the `precision` arguments can also be negative, indicating error magnitude larger than one.\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 15.95703125,
          "content": "# Copyright (C) 2019-2020 IBM Corp.\n#\n# This program is Licensed under the Apache License, Version 2.0\n# (the \"License\"); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#   http://www.apache.org/licenses/LICENSE-2.0\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License. See accompanying LICENSE file.\n\n# Enforce CMake v3.20 on MacOS else set minimum to v3.16\nif (APPLE)\n  cmake_minimum_required(VERSION 3.20 FATAL_ERROR)\nelse ()\n  cmake_minimum_required(VERSION 3.16 FATAL_ERROR)\nendif ()\n\nproject(helib_superbuild LANGUAGES C CXX)\n\n# STRINGS avoids having the 2 newline characters at the end of the string.\n# Alternatively it's possible to use file(READ ...) and then\n# string(REGEX REPLACE \"\\n$\" \"\" HELIB_VERSION \"${HELIB_VERSION}\")\nfile(STRINGS \"${PROJECT_SOURCE_DIR}/VERSION\" HELIB_VERSION)\n\n# Fail if the target architecture is not 64-bit.\nif (NOT (CMAKE_SIZEOF_VOID_P EQUAL 8))\n  message(FATAL_ERROR \"HElib requires a 64-bit architecture.\")\nendif ()\n\n# Use -std=c++17 as default.\nset(CMAKE_CXX_STANDARD 17)\n# Disable C++ extensions\nset(CMAKE_CXX_EXTENSIONS OFF)\n# Require full C++ standard\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n################################################################################\n#                                                                              #\n#                             FOLDER DEFINITIONS                               #\n#                                                                              #\n################################################################################\n\n# Define standard installation directories (GNU)\ninclude(GNUInstallDirs)\n\n# Setting compiler output directories\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n    ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n    ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n    ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n\n# Location of the root folder of HElib (the one where this file is)\nset(HELIB_PROJECT_ROOT_DIR \"${PROJECT_SOURCE_DIR}\")\n# Location of the cmake extra files\nset(HELIB_CMAKE_EXTRA_DIR \"${PROJECT_SOURCE_DIR}/cmake\")\n# Prefix of the header files (directory to be added to the include list)\nset(HELIB_INCLUDE_DIR \"${PROJECT_SOURCE_DIR}/include\")\n# Location of helib header files\nset(HELIB_HEADER_DIR \"${HELIB_INCLUDE_DIR}/helib\")\n# Location of the source files\nset(HELIB_SOURCE_DIR \"${PROJECT_SOURCE_DIR}/src\")\n# Location of the google tests\nset(HELIB_TESTS_DIR \"${PROJECT_SOURCE_DIR}/tests\")\n# Location of the dependencies\nset(HELIB_DEPENDENCIES_DIR \"${PROJECT_SOURCE_DIR}/dependencies\")\n# Location of the directory containing the test binary (runTests). If\n# PACKAGE_BUILD=ON, this location will be changed to reflect the tests location.\nset(HELIB_TEST_BIN_DIR \"${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}\")\n\n# GMP minimal version to be used if not PACKAGE_BUILD\nset(GMP_MINIMAL_VERSION \"6.2.0\")\n# NTL minimal version to be used if NOT PACKAGE_BUILD\nset(NTL_MINIMAL_VERSION \"11.4.3\")\n\n# The -isysroot flag needs set.\nif ((APPLE OR (CMAKE_CXX_PLATFORM_ID STREQUAL \"Darwin\")) AND\n    # This addresses the problem when CMAKE_OSX_SYSROOT is \"\" (e.g. when /usr/include/sys/types.h exists)\n    NOT CMAKE_OSX_SYSROOT STREQUAL \"\")\n  set(macos_isysroot_flag \"-isysroot ${CMAKE_OSX_SYSROOT}\")\nelse()\n  set(macos_isysroot_flag \"\")\nendif()\n\n# Setting up RelWithDebInfo as default CMAKE_BUILD_TYPE\nif (NOT CMAKE_BUILD_TYPE)\n  # Setting RelWithDebInfo as it will compile with -O2 -g\n  set(CMAKE_BUILD_TYPE RelWithDebInfo\n      CACHE\n      STRING \"Choose the type of build, options are: Debug RelWithDebInfo Release MinSizeRel\"\n      FORCE)\n\nendif (NOT CMAKE_BUILD_TYPE)\n\n# Adding possible gui values to CMAKE_BUILD_TYPE variable\nset_property(CACHE\n             CMAKE_BUILD_TYPE\n             PROPERTY\n             STRINGS \"Debug\" \"RelWithDebInfo\" \"Release\" \"MinSizeRel\")\n\n# Creating and documenting TARGET_ARCHITECTURE cmake property\nset(TARGET_ARCHITECTURE \"${TARGET_ARCHITECTURE}\"\n    CACHE\n    STRING \"Target architecture used for -march (default is native)\")\n# If TARGET_ARCHITECTURE is not set use default\nif (NOT TARGET_ARCHITECTURE)\n  set(TARGET_ARCHITECTURE \"native\"\n      CACHE\n      STRING \"Target architecture used for -march (default is native)\"\n      FORCE)\nendif (NOT TARGET_ARCHITECTURE)\n\nset(HELIB_SP_NBITS \"0\" \n    CACHE \n    STRING \"Override the bitsize for the ciphertext primes used\")\nif (NOT HELIB_SP_NBITS EQUAL 0)\n  # Now check within bounds. NB. zero is special value to not override\n  if (HELIB_SP_NBITS LESS 1 OR HELIB_SP_NBITS GREATER 64)\n    message(FATAL_ERROR \"HELIB_SP_NBITS must be in range [1, 64].\")\n  endif()\n  add_compile_definitions(HELIB_SP_NBITS=${HELIB_SP_NBITS})\nendif()\n\n# Path containing FindGMP.cmake and FindNTL.cmake\nlist(APPEND CMAKE_MODULE_PATH \"${HELIB_CMAKE_EXTRA_DIR}\")\n\noption(BUILD_SHARED \"Build as shared library\" OFF)\n\noption(PACKAGE_BUILD\n       \"Download dependencies and build as a self-contained package\"\n       OFF)\n\noption(ENABLE_THREADS\n       \"Enable threads support.  Requires NTL built with NTL_THREADS=on\"\n       ON)\n\noption(HELIB_DEBUG\n       \"Build with HELIB_DEBUG (enables extra debugging info, but needs to be initialized)\"\n       OFF)\noption(ENABLE_TEST \"Enable tests\" OFF)\noption(USE_INTEL_HEXL \"Use Intel HEXL library\" OFF)\noption(PEDANTIC_BUILD \"Use -Wall -Wpedantic -Wextra -Werror during build\" ON)\n\n# Add properties dependent to PACKAGE_BUILD\nif (PACKAGE_BUILD)\n  # Properties to be enabled when using PACKAGE_BUILD\n  set(PACKAGE_DIR\n      \"\"\n      CACHE\n      STRING \"Folder with the compilation output directory (DEFAULT: helib_pack)\")\n\n  option(FETCH_GMP \"Fetch and compile the GMP library (DEFAULT: ON)\" ON)\nelse (PACKAGE_BUILD)\n  # Properties to be enabled when not using PACKAGE_BUILD\nendif (PACKAGE_BUILD)\n\n# Allow GMP_DIR and search in it if not using PACKAGE_BUILD or using\n# PACKAGE_BUILD and !FETCH_GMP\nif ((NOT PACKAGE_BUILD) OR NOT FETCH_GMP)\n  set(GMP_DIR\n      \"\"\n      CACHE\n      STRING \"Prefix of the GMP library (ignored when PACKAGE_BUILD is ON)\")\nendif ((NOT PACKAGE_BUILD) OR NOT FETCH_GMP)\n\n# Allow NTL_DIR only if not PACKAGE_BUILD\nif (NOT PACKAGE_BUILD)\n  set(NTL_DIR\n      \"\"\n      CACHE\n      STRING \"Prefix of the NTL library (ignored when PACKAGE_BUILD is ON)\")\nendif (NOT PACKAGE_BUILD)\n\n# Setting flag lists to avoid polluting CMAKE_CXX_FLAGS.\n# PUBLIC_HELIB_CXX_FLAGS will be exported to the installed target.\nset(PRIVATE_HELIB_CXX_FLAGS \"-march=${TARGET_ARCHITECTURE}\")\nset(PUBLIC_HELIB_CXX_FLAGS \"\")\n# Add extra checks during build\nif (PEDANTIC_BUILD)\n  list(APPEND PRIVATE_HELIB_CXX_FLAGS \"-Wall\" \"-Wpedantic\" \"-Wextra\" \"-Werror\")\nendif (PEDANTIC_BUILD)\n\nif (ENABLE_TEST)\n  enable_testing()\nendif (ENABLE_TEST)\n\n# Look for pthread using default FindThreads.cmake script\nfind_package(Threads)\nif (ENABLE_THREADS AND Threads_NOTFOUND)\n  message(FATAL_ERROR \"Cannot find pthreads (ENABLE_THREADS is ON).\")\nendif ()\n\n# Build optional Intel HEXL library\nif(USE_INTEL_HEXL)\n  # HEXL currently only supported using Library Build\n  if(PACKAGE_BUILD)\n    message(FATAL_ERROR \"Intel HEXL currently not supported with Package \"\n      \"Build. Please use the Library Build when enabling Intel HEXL.\")\n  endif(PACKAGE_BUILD)\n\n  if(HEXL_DIR)\n    set(HEXL_DIR\n        \"\"\n        CACHE\n        STRING \"Set location of HEXL cmake data for linking.\"\n        )\n    set(INIT_HEXL_DIR ${HEXL_DIR})\n  endif()\n\n  # Set minimum version of HEXL\n  set(HEXL_MIN_VERSION 1.2.1)\n\n  find_package(HEXL HINTS ${HEXL_DIR} REQUIRED)\n\n  # Check the version found is greater than the minimum\n  if(HEXL_MIN_VERSION VERSION_GREATER HEXL_VERSION)\n    message(FATAL_ERROR \"Minimum Intel HEXL version required is ${HEXL_MIN_VERSION}, found ${HEXL_VERSION}\")\n  else()\n    message(STATUS \"Intel HEXL Version: ${HEXL_VERSION} found (minimum required is ${HEXL_MIN_VERSION})\")\n  endif()\n\n  if(INIT_HEXL_DIR AND NOT INIT_HEXL_DIR STREQUAL HEXL_DIR)\n    message(WARNING \"HEXL location provided '${INIT_HEXL_DIR}' \\\n            does not equal chosen '${HEXL_DIR}'.\")\n  endif()\n  include_directories(${HEXL_INCLUDE_DIRS})\n  add_compile_definitions(USE_INTEL_HEXL)\nendif(USE_INTEL_HEXL)\n\n# NOTE: Consider reconfiguring everything when PACKAGE_BUILD changes value.\n# Options from the previous value will remain otherwise.\n# Set up extra properties depending on the value of PACKAGE_BUILD\nif (PACKAGE_BUILD)\n  # Setting up dependencies versions\n  # GMP version to be used (and eventually downloaded) if PACKAGE_BUILD\n  set(FETCHED_GMP_VERSION \"6.2.1\")\n  # NTL version to be used (and eventually downloaded) if PACKAGE_BUILD\n  set(FETCHED_NTL_VERSION \"11.5.1\")\n  # Setting up default compilation output directory\n  if (NOT PACKAGE_DIR)\n    set(PACKAGE_DIR \"helib_pack\")\n  endif (NOT PACKAGE_DIR)\n  if (NOT IS_ABSOLUTE ${PACKAGE_DIR})\n    # Make CMAKE_PACKAGE_DIR absolute\n    set(PACKAGE_DIR\n        \"${CMAKE_BINARY_DIR}/${PACKAGE_DIR}\"\n        CACHE\n        STRING \"Folder with the compilation output directory (DEFAULT: helib_pack)\"\n        FORCE)\n  endif ()\n\n  # Setting up download/build path of external dependencies\n  set(DEPENDENCIES_FOLDER \"${CMAKE_BINARY_DIR}/dependencies\")\n  set_property(DIRECTORY PROPERTY EP_BASE \"${DEPENDENCIES_FOLDER}\")\n\n  # Raising warning when PACKAGE_BUILD is ON\n  # warn if installing globally\n  # NOTE: this is a somewhat fragile check that can be enhanced\n  string(FIND \"${CMAKE_INSTALL_PREFIX}\" \"/usr\" install_in_usr)\n  if (\"${install_in_usr}\" EQUAL 0)\n    message(WARNING\n            \"CAUTION: Package build should not be installed globally as it will potentially override dependencies.\")\n  endif ()\n  unset(install_in_usr)\n\n  # Warn existing dependencies are ignored and rebuilt\n  if (GMP_DIR)\n    if (FETCH_GMP)\n      message(WARNING \"GMP_DIR is ignored when PACKAGE_BUILD is ON.\")\n    else (FETCH_GMP)\n      message(STATUS\n              \"GMP_DIR is not the system one.  This may prevent relocatability of the package.\")\n    endif (FETCH_GMP)\n  endif (GMP_DIR)\n\n  if (NTL_DIR)\n    message(WARNING \"NTL_DIR is ignored when PACKAGE_BUILD is ON.\")\n  endif (NTL_DIR)\n\n  # Add an imported target to propagate the library locations\n  add_library(gmp_external SHARED IMPORTED)\n  add_library(ntl_external SHARED IMPORTED)\n\n  # RPATH will be empty since ntl, gmp, and helib are all in PACKAGE_DIR/lib\n  set(PACKAGE_RPATH \"\")\n\n  if (NOT FETCH_GMP)\n    # find GMP library\n    # Try to find the GMP package (using cmake/FindGMP.cmake script)\n    # REQUIRED arg make cmake to fail if GMP is not found\n    # Checks that at least version GMP_MINIMAL_VERSION is available\n    find_package(GMP \"${GMP_MINIMAL_VERSION}\" REQUIRED)\n    set_target_properties(gmp_external\n                          PROPERTIES\n                          INTERFACE_INCLUDE_DIRECTORIES \"${GMP_INCLUDE_PATHS}\"\n                          IMPORTED_LOCATION \"${GMP_LIBRARIES}\")\n  endif (NOT FETCH_GMP)\n\n  # Add the external dependencies (done in dependencies/CMakeLists.txt)\n  add_subdirectory(dependencies)\n\n  # get gmp and ntl include/link directories\n  get_target_property(GMP_INCLUDE_PATHS\n                      gmp_external\n                      INTERFACE_INCLUDE_DIRECTORIES)\n  get_target_property(GMP_LIBRARIES gmp_external IMPORTED_LOCATION)\n  get_target_property(NTL_INCLUDE_PATHS\n                      ntl_external\n                      INTERFACE_INCLUDE_DIRECTORIES)\n  get_target_property(NTL_LIBRARIES ntl_external IMPORTED_LOCATION)\n\n  # Track if helib requires pthreads as dependency\n  set(HELIB_REQUIRES_PTHREADS ${ENABLE_THREADS})\nelse (PACKAGE_BUILD)\n  # find GMP library\n  # Try to find the GMP package (using cmake/FindGMP.cmake script)\n  # REQUIRED arg make cmake to fail if GMP is not found\n  # Checks that at least version GMP_MINIMAL_VERSION is available\n  find_package(GMP \"${GMP_MINIMAL_VERSION}\" REQUIRED)\n\n  # find NTL library\n  # Try to find the NTL package (using cmake/FindNTL.cmake script)\n  # REQUIRED arg make cmake to fail if NTL is not found\n  # Checks that at least version NTL_MINIMAL_VERSION is available\n  find_package(NTL \"${NTL_MINIMAL_VERSION}\" REQUIRED)\n\n  # Thread enabling checks\n  # Checking if NTL is built with NTL_THREADS=on\n  set(ntl_config_file \"${NTL_INCLUDE_PATHS}/NTL/config.h\")\n  if (EXISTS \"${ntl_config_file}\")\n    include(CheckCXXSymbolExists)\n    check_cxx_symbol_exists(\"NTL_THREADS\" \"${ntl_config_file}\" ntl_has_threads)\n  else ()\n    message(\n      FATAL_ERROR \"Cannot locate NTL configuration file (${ntl_config_file}).\")\n  endif ()\n\n  # Raising errors when threads are misconfigured\n  if (ENABLE_THREADS AND NOT ntl_has_threads)\n    message(FATAL_ERROR\n            \"Cannot enable threads since NTL was built without.  Consider re-building NTL with NTL_THREADS=on.\")\n  endif (ENABLE_THREADS AND NOT ntl_has_threads)\n\n  # This should not really happen\n  if (ntl_has_threads AND Threads_NOTFOUND)\n    message(FATAL_ERROR \"NTL requires pthreads that has not been found.\")\n  endif (ntl_has_threads AND Threads_NOTFOUND)\n\n  # Track if helib requires pthreads as dependency\n  set(HELIB_REQUIRES_PTHREADS ${ntl_has_threads})\n\n  unset(ntl_config_file)\n  unset(ntl_has_threads)\nendif (PACKAGE_BUILD)\n\n# Building HELIB here\nif (PACKAGE_BUILD)\n  # Adding HELIB as an external project\n  include(ExternalProject)\n\n  # Before building helib_external wait compilation of gmp and ntl.\n  list(APPEND helib_external_deps \"gmp_external\" \"ntl_external\")\n\n  ExternalProject_Add(\n    helib_external\n    DEPENDS # await compilation of gmp and ntl\n            gmp_external ntl_external\n    SOURCE_DIR ${CMAKE_SOURCE_DIR}/src\n    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${PACKAGE_DIR}\n               -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n               -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS}\n               -DCMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD}\n               -DCMAKE_CXX_STANDARD_REQUIRED=${CMAKE_CXX_STANDARD_REQUIRED}\n               -DCMAKE_CXX_EXTENSIONS=${CMAKE_CXX_EXTENSIONS}\n               -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}\n               -DPRIVATE_HELIB_CXX_FLAGS=${PRIVATE_HELIB_CXX_FLAGS}\n               -DPUBLIC_HELIB_CXX_FLAGS=${PUBLIC_HELIB_CXX_FLAGS}\n               -DGMP_LIBRARIES=${GMP_LIBRARIES}\n               -DNTL_INCLUDE_PATHS=${NTL_INCLUDE_PATHS}\n               -DNTL_LIBRARIES=${NTL_LIBRARIES}\n               -DENABLE_THREADS=${ENABLE_THREADS}\n               -DHELIB_REQUIRES_PTHREADS=${HELIB_REQUIRES_PTHREADS}\n               -DBUILD_SHARED=${BUILD_SHARED}\n               -DPACKAGE_BUILD=${PACKAGE_BUILD}\n               -DFETCH_GMP=${FETCH_GMP}\n               -DENABLE_TEST=${ENABLE_TEST}\n               -DHELIB_DEBUG=${HELIB_DEBUG}\n               -DUSE_INTEL_HEXL=${USE_INTEL_HEXL}\n               -DHELIB_PROJECT_ROOT_DIR=${HELIB_PROJECT_ROOT_DIR}\n               -DHELIB_CMAKE_EXTRA_DIR=${HELIB_CMAKE_EXTRA_DIR}\n               -DHELIB_INCLUDE_DIR=${HELIB_INCLUDE_DIR}\n               -DHELIB_HEADER_DIR=${HELIB_HEADER_DIR}\n               -DHELIB_SOURCE_DIR=${HELIB_SOURCE_DIR}\n               -DHELIB_TESTS_DIR=${HELIB_TESTS_DIR}\n               -DHELIB_DEPENDENCIES_DIR=${HELIB_DEPENDENCIES_DIR}\n               -DHELIB_VERSION=${HELIB_VERSION}\n    BUILD_ALWAYS ON)\n\n    if (ENABLE_TEST)\n      # Tests for PACKAGE_BUILD are located in\n      # ${DEPENDENCIES_FOLDER}/Build/helib_external/${CMAKE_INSTALL_BINDIR}.\n      # Update its location and add the tests to cmake to avoid re-creating\n      # their targets (as they are already built by ExternalProject_Add)\n      set(HELIB_TEST_BIN_DIR\n          \"${DEPENDENCIES_FOLDER}/Build/helib_external/${CMAKE_INSTALL_BINDIR}\")\n      set(ONLY_ADD_TEST ON)\n      add_subdirectory(\"${HELIB_TESTS_DIR}\" tests)\n      unset(ONLY_ADD_TEST)\n    endif (ENABLE_TEST)\n\n  # To install copy the whole PACKAGE_DIR directory to the defined prefix\n  install(\n    DIRECTORY ${PACKAGE_DIR}\n    DESTINATION\n      # this is interpreted relative to the value of CMAKE_INSTALL_PREFIX\n      .\n    USE_SOURCE_PERMISSIONS)\nelse (PACKAGE_BUILD)\n  # If not compiling as PACKAGE_BUILD then add helib as subfolder and not as an\n  # external project\n  add_subdirectory(src)\nendif (PACKAGE_BUILD)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.296875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at flavio@uk.ibm.com and/or shaih@alum.mit.edu. \nAll complaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.6982421875,
          "content": "# Contributing to the Homomorphic Encryption Library HElib\n\nAdding new features, improving documentation, fixing bugs, writing new \ntests, designing and coding new examples or writing tutorials are all examples \nof helpful contributions. \n\nA contribution to HElib can be initiated through GitHub pull request (PR).\nHElib is written in C++17 and uses `clang-format` for the formatting of the code.\nRequirements and installation instructions can be found in [INSTALL.md](INSTALL.md).\nWhen making code contributions to HElib, we ask that you follow the `C++17` \ncoding standard and format your code using the [clang format](.clang-format) \nstyle file included in this distribution. Please provide unit/regression \ntests that are relevant to your code contribution. \n\nThis project uses Developer Certificate of Origin [DCO](https://developercertificate.org/). \nBe sure to sign off your commits using the `-s` flag or adding `Signed-off-By: Name<Email>` in the commit message.\n\n### Example commit message\n```bash\ngit commit -s -m 'Informative commit message'\n```\n\n### Unit/Regression tests\n\nWhether you are contributing a new feature, updating or bug fixing the code elsewhere, you need to ensure that your HElib build passes the regression test suite. \n\nHElib test suite uses the [Google Test Framework](https://github.com/google/googletest). Additional information on HElib's test suite can be found in [TESTS.md](TESTS.md). Please remember to provide unit/regression tests that are relevant to your code contribution.\n\nOnce all the tests have passed, and you are satisfied with your contribution, open a pull request into the `master` branch from **your fork of the repository** to request adding your contributions into the main code base.\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 11.333984375,
          "content": "# Building and installing HElib\n\nThe current HElib build, install, and regression tests suite have been built\nand tested on Ubuntu 22.04, macOS Montrey >=12.6.7, and macOS Ventura >=13.4.1.\nPrevious HElib versions included build, install, and regression tests on \nUbuntu 18.04, ubuntu 20.04, Fedora 33, CentOS 8.2, macOS Mojave >=10.14.6, \nmacOS Catalina >=10.15.7, and macOS Big Sur >=11.7.8\n\nThere are two different ways to build and install HElib. The first one will\nautomatically download and build the GMP and NTL dependencies and pack the\nlibraries in a relocatable folder. The second way, instead, requires the\ndependencies to be installed by you and available in the system.\n\nThis release of HElib has experimental support for the Intel® [HEXL](https://github.com/intel/hexl) \nacceleration library for homomorphic encryption that exploits Intel® Advanced Vector Extensions 512. \nInstructions to enable and link to HEXL are given \n[below](#enabling-and-linking-to-intel-hexl).\n\n```diff\n- Please read these instructions in full to better choose the type of build that is best for you.\n```\n\n## General prerequisites\n\n- pthreads\n- git >= 2.36 (required to build and run the HElib test suite)\n\n**Default Linux environment:**\n\n- Ubuntu 22.04 LTS\n- GNU make >= 4.3\n- g++ >= 11.3.0\n- cmake >= 3.22\n\n**macOS environment:**\n\n- Apple clang >= 14.0.0 (available with the latest Xcode for the tested versions of macOS)\n- Xcode Command Line Tools (can be installed with the command `xcode-select\n  --install` in a terminal)\n- cmake >= 3.22 (available from [CMake](https://cmake.org/) or [MacPorts\n  Project](https://www.macports.org/) and [Homebrew](https://brew.sh/) as\n  packages)\n- GNU make >= 4.3\n\n**For HElib development:**\n\n- clang-format >= 14.0.0 (available with your linux distribution and for macOS\n  from [MacPorts Project](https://www.macports.org/) and\n  [Homebrew](https://brew.sh/) as packages)\n\n## Option 1: package build (recommended for most users)\n\nThis option bundles HElib and its dependencies (NTL and GMP) in one directory\nwhich can then be moved around freely on the system.  NTL and GMP will be\nautomatically fetched and compiled.  It can be installed globally (i.e. under\n`/usr/local`), which is the default option if no `CMAKE_INSTALL_PREFIX` is\nspecified, but this should only be done with caution as existing versions of\nNTL, GMP, or HElib will be overwritten.  These additional two prerequisites are\nrequired in this case:\n\n- m4 >= 1.4.18\n- patchelf >= 0.14.3 (if building on Linux)\n\nPlease note that if changing from library build to package build, it is safer to\nuse a clean build directory.\n\n### Instructions\n\n1. Create a build directory, typically as a sibling of `src`:\n\n```bash\ncd HElib\nmkdir build\ncd build\n```\n\n2. Run the cmake configuration step, specifying that you want a package build\n   (via -DPACKAGE_BUILD=ON) and saying where you would like the installation to\n   be. To install in `/home/alice/helib_install`, for example:\n\n```bash\ncmake -DPACKAGE_BUILD=ON -DCMAKE_INSTALL_PREFIX=/home/alice/helib_install ..\n```\n\nExtra options can be specified here, such as enabling HElib tests with\n`-DENABLE_TEST=ON`.  See later section entitled \"HElib build options\" for\ndetails.\n\n3. Compile, with an optional number of threads specified (16 in this example).\n   The output of this will be in the relocatable folder `helib_pack`:\n\n```bash\nmake -j16\n```\n\n4. (optional) If step 2 was performed with `-DENABLE_TEST=ON`, HElib tests can\n   be run as follows:\n\n```bash\nctest\n```\n\nDetailed HElib-specific test logs can be found in\n`Testing/Temporary/LastTest.log`.\n\n5. (optional) Run the install step, to copy the folder `helib_pack` to\n   `${CMAKE_INSTALL_PREFIX}` (in this example `/home/alice/helib_install`):\n\n```bash\nmake install\n```\n\nof course, if the `CMAKE_INSTALL_PREFIX` was kept as the default `/usr/local` or\nsome other system-wide path, step 5 may require `sudo` privileges.\n\n## Option 2: library build (advanced)\n\nThis option involves building HElib on its own, linking against pre-existing\ndependencies (NTL and GMP) on the system.  In this way, the HElib library can be\nmoved around, but its dependencies (NTL and GMP) cannot, as they are absolute\npaths.  For this option, you must build GMP >=6.2.1 and NTL >=11.5.1 yourself.\nFor details on how to do this, please see the section on building dependencies\nlater.  It is assumed throughout this installation option that the environment\nvariables `$GMPDIR` and `$NTLDIR` are set to point to the installation\ndirectories of GMP and NTL respectively.\n\nPlease note that if changing from package build to library build, it is safer to\nuse a clean build directory.\n\n1. Create a build directory, typically as a sibling of `src`:\n\n```bash\ncd HElib\nmkdir build\ncd build\n```\n\n2. Run the cmake configuration step, specifying where to find NTL and GMP.  If\n   not specified, system-wide locations such as `/usr/local/lib` will be\n   searched. To install in `/home/alice/helib_install`, for example:\n\n```bash\ncmake -DGMP_DIR=\"${GMPDIR}\" -DNTL_DIR=\"${NTLDIR}\" -DCMAKE_INSTALL_PREFIX=/home/alice/helib_install ..\n```\n\nExtra options can be specified here, such as enabling HElib tests with\n`-DENABLE_TEST=ON`.  See later section entitled \"HElib build options\" for\ndetails.\n\n3. Compile, with an optional number of threads specified (16 in this example):\n\n```bash\nmake -j16\n```\n\n4. (optional) If step 2 was performed with `-DENABLE_TEST=ON`, tests can be run\n   as follows:\n\n```bash\nctest\n```\n\nDetailed HElib test logs can be found in `Testing/Temporary/LastTest.log`.\n\n5. Run the install step, to copy the files to `${CMAKE_INSTALL_PREFIX}` (in this\n   example `/home/alice/helib_install`):\n\n```bash\nmake install\n```\n\nof course, if the `CMAKE_INSTALL_PREFIX` was kept as the default `/usr/local` or\nsome other system-wide path, step 5 may require `sudo` privileges.\n\n## Building dependencies (for option 2)\n\n### GMP\n\nMany distributions come with GMP pre-installed. If not, you can install GMP as\nfollows.\n\n1. Download GMP from [http://www.gmplib.org](http://www.gmplib.org) -- make sure\n   that you get GMP >=6.2.0 (current version is 6.2.1).\n2. Decompress and cd into the gmp directory (e.g., `gmp-6.2.1`).\n3. GMP is compiled in the standard unix way:\n\n```bash\n      ./configure\n      make\n      sudo make install\n```\n\nThis will install GMP into `/usr/local` by default.\n\n**NOTE:** For further options when building GMP, run `./configure --help` in\nstep 3.\n\n### NTL\n\nYou can install NTL as follows:\n\n1. Download NTL >=11.5.1 from\n   [https://libntl.org/download.html](https://libntl.org/download.html)\n2. Decompress and cd into the directory, e.g., `ntl-11.5.1/src`\n3. NTL is configured, built and installed in the standard Unix way (but remember\n   to specify the following flags to `configure`):\n\n```bash\n      ./configure NTL_GMP_LIP=on SHARED=on  NTL_THREADS=on NTL_THREAD_BOOST=on\n      make\n      sudo make install\n```\n\nThis should install NTL into `/usr/local`.\n\n**NOTE:** For further options when building NTL, run `./configure --help` in\nstep 3.\n\n**NOTE**: if linking against a non-system GMP, pass `GMP_PREFIX=<path/to/gmp>`\nto the `./configure` step.\n\n## Enabling and linking to Intel® HEXL\n**NOTE:** HElib with HEXL acceleration is only supported on the processors with AVX512DQ and \nAVX512-IFMA such as the 3rd generation Intel® Xeon® or the 11th generation Intel® Core®\n\n**NOTE:** It is currently only possible to use HEXL with HElib when using the\nlibrary build and when building HElib as a static library. i.e.\n`-DPACKAGE_BUILD=OFF` and `-DBUILD_SHARED=OFF`.\n\nFirst you must download and build HEXL from source.  Currently, HElib only\nworks with HEXL version >= 1.2.1 Using git this would be\n\n```bash\ngit clone https://github.com/intel/hexl --branch 1.2.1\n```\nFollow the instructions for HEXL installation in the README.md for all\navailable options.  Note previous versions of HEXL requires the deprecated\n`-DENABLE_EXPORT=ON` otherwise the cmake metadata for linking a cmake project\nis not created. Modern versions do not have this flag and the metadata is\ncreated by default.  For a quick start most people will want,\n\n```bash\ncd hexl\ncmake -S . -B build/ [-DCMAKE_INSTALL_PREFIX=<install-location-for-HEXL>/lib/cmake/hexl-1.2.1] \ncmake --build build -j [<parallel-jobs>]\ncmake --install build\n```\nIf you do not provide an optional install location for HEXL the default is\n`/usr/local`.\n\nTo enable and link HEXL in HElib, you must configure cmake for HElib with\n`-DUSE_INTEL_HEXL=ON`. If HEXL is not in the default system location or you\nwish to use another installation tell HElib where to find it using\n`-DHEXL_DIR=<install-location-for-hexl>`.\nThere is no requirement to provide any HElib subprojects with the location of\nHEXL.\n\n## HElib build options\n\n### Generic options\n\n- `BUILD_SHARED=ON/OFF` (default is `OFF`): Build as a shared library. Note that\n  building HElib (regardless of `BUILD_SHARED`) will fail if NTL is not built as\n  a shared library. The default for NTL is static library, to build NTL as a\n  shared library use `./configure SHARED=on` in step 1. \n- `CMAKE_BUILD_TYPE`: (default is `RelWithDebInfo`): Choose the type of build,\n  options are: `Debug`, `RelWithDebInfo`, `Release`, `MinSizeRel`.\n- `CMAKE_INSTALL_PREFIX`: Desired installation directory for HElib.\n- `ENABLE_TEST=ON/OFF` (default is `OFF`): Enable building of tests. This will\n  include an automatic download step for the google test framework stable\n  release (googletest v1.10.0)\n- `ENABLE_THREADS=ON/OFF` (default is `ON`): Enable threading support. This must\n  be on if and only if NTL was built with `NTL_THREADS=ON`.\n- `PEDANTIC_BUILD=ON/OFF` (default is `ON`): Use `-Wall -Wpedantic -Wextra\n  -Werror` during build.\n- `HELIB_DEBUG=ON/OFF` (default is `OFF`): Activate the debug module when\n  building HElib (by defining the `HELIB_DEBUG` macro). When the debug module is\n  active, this generates extra information used for debugging purposes.\n  `HELIB_DEBUG` will propagate to programs using HElib, when using cmake. When\n  this is enabled, programs using HElib will generate a warning during\n  configuration.  This is to remind the user that use of the debug module can\n  cause issues, such as `sigsegv`, if initialized incorrectly.\n\n### Parameters specific to option 1 (package build)\n\n- `PACKAGE_DIR`: Location that a package build will be installed to.  Defaults\n  to `${CMAKE_INSTALL_PREFIX}/helib_pack`.\n- `FETCH_GMP`: Whether or not to fetch and build GMP.  Defaults to `ON`.  If set\n  to `OFF`, there should either exist a system-installed GMP library, or\n  `GMP_DIR` should point to a valid GMP prefix.\n- `GMP_DIR`: Prefix of the GMP library.  Ignored if `FETCH_GMP=ON`.\n\n### Parameters specific to option 2 (library build)\n\n- `GMP_DIR`: Prefix of the GMP library.\n- `NTL_DIR`: Prefix of the NTL library.\n- `USE_INTEL_HEXL`: Enable the Intel HEXL library.\n- `HEXL_DIR`: Prefix of the Intel HEXL library.\n\n# Using HElib in a project\n\n## Standard method\n\nAfter `make install` has been run in either option 1 or option 2, one can find\nthe required shared library files to link against in `lib` and the header files\nin `include`.  These can be used in the preferred way with your build system of\nchoice.\n\n## Package build with cmake\n\nAnother, easier way is possible if you are using HElib in a cmake project.\n\n1. Include the following line in your `CMakeLists.txt`:\n\n```cmake\nfind_package(helib)\n```\n\n2. Run your `cmake` step with \n  `-Dhelib_DIR=<helib install prefix>/share/cmake/helib`.\n\n## Example\n\nFull working examples of cmake-based projects which uses HElib can be found in\nthe `examples` directory.\n"
        },
        {
          "name": "ISSUES.md",
          "type": "blob",
          "size": 0.40625,
          "content": "# Known Issues\n\nThese issues listed below are known to be current and are expected to be\naddressed. \n\nThe function in BinaryArith `fifteenOrLess4Four` is known to not be currently\nthread safe. Therefore set NTL's thread pool to 1 to avoid this issue.  The\nfunction `NTL::SetNumThreads` can be used to set the number of threads in the\npool and `NTL::AvailableThreads` gives the current available threads in the\npool.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 11.111328125,
          "content": "# LICENSE\n\n```\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n```\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.0400390625,
          "content": "HElib\nCopyright (C) 2012-2020 IBM Corp.\n\n"
        },
        {
          "name": "OLD_INSTALL.txt",
          "type": "blob",
          "size": 7.9326171875,
          "content": "===> CAUTION: This guide refers to an old style Makefile installation.  <===\n===>          Refer to INSTALL.md for newer cmake-based installation.   <===\n===>          We no longer recommend this method to install HElib.      <=== \n\nAdditional Notes, September 2020\n--------------------------------\nversion.in.h header and some source code (version.in.cpp and\nTestVersion.in.cpp) has been added so that HElib can introspect on its version.\nThese are template files that cmake fills in the version numbers for us during\na build. The old Makefile does not compile these. So, if you wish to use them\nwe recommend moving to the cmake build.\n\n\nHElib Installation Notes, August 2020\n---------------------------------------\nMuch has changed since the note in 2015 and there are many updates. So this \nis a refreshed note.\n\nTo build HElib, you will need to have GMP and NTL libraries installed.\n\nMany distributions come with GMP pre-installed. If not, install GMP as follows:\n\n1. Download GMP from http://www.gmplib.org\n2. Uncompress and cd into the directory gmp-XXX\n3. On the command line:\n      ./configure\n      make\n      sudo make install\n4. This should install GMP into /usr/local\n\nOnce GMP is installed, you can install NTL as follows:\n(NOTE: you will needs NTL v11.4.3 or higher)\n\n1. Download NTL from http://www.shoup.net/ntl/download.html\n2. Uncompress and cd into the directory ntl-XXX/src\n3. On the command line:\n      ./configure NTL_GMP_LIP=on\n      make\n      sudo make install\n4. This should install NTL into /usr/local\n\nNow that you have these libraries in place, cd to the HElib src directory to\nbuild HElib.\n\nThis \"build system\" for HElib is very rudimentary: no configure script and just\na Makefile (with no \"make install\").  The Makefile will build the static\nlibrary fhe.a in the HElib src directory, and then one can build application\nprograms based on fhe.a, also in the HElib src directory (or set the include\nand library parameters to include the right things). Hopefully, this build\nsystem will be improved in the future.\n\nBefore building HElib, you may want to look at the Makefile, and consider\nadjusting some of the defaults for CC and CFLAGS. The defaults should be OK on\nmost systems, but you can see the suggested options, which are documented in\nthe Makefile.\n\nOn the command line in the HElib src directory:\n\n   make\n\nwill compile and build the library fhe.a. Once built, run\n\n   make check\n\nwhich will compile and runs a series of test programs.\n\nIf you want to build your own program based on HElib, the easiest way\nto do it is to write the program in a file called myprog.cpp and then\nrun\n\n   make myprog_x\n\nwhich will compile myprog.cpp and link in fhe.a and all required\nsupport libraries, and create the executable myprog_x.\n\nTake a look at the programs Test_*.cpp for examples of using HElib.\nThese programs can be found in the misc/legacy_tests directory.\n\nSome comments:\n\n* HElib uses C++14, for gcc you may need to specify the flags '-std=c++14'\nto be able to compile (depending on the gcc version that you use).\n\n* There are compilation flags that control some aspects of the\nlibrary, currently these are:\n\n  -DHELIB_THREADS  tells HElib to enable generic multithreading capabilities;\n                    must be used with a thread-enabled NTL and the -pthread\n                    flag should be passed to gcc\n\n  -DHELIB_BOOT_THREADS  tells HElib to use a multithreading strategy for\n                         bootstrapping; requires -DHELIB_THREADS (see above)\n\n  -DHELIB_DEBUG\n    Add some debugging printouts\n\n\nHElib Installation Notes, October 2015\n---------------------------------------\nTo build HElib, you will need to have GMP and NTL libraries installed.\n\nMany distributions come with GMP pre-installed.\nIf not, you can install GMP as follows.\n\n1. Download GMP from http://www.gmplib.org\n2. uncompress and cd into the directory gmp-XXX\n3. On the command line:\n      ./configure\n      make\n      sudo make install\n4. This should install GMP into /usr/local\n\nOnce GMP is installed, you can install NTL as follows:\n(NOTE: you will needs NTL v9.4.0 or higher)\n\n1. Download NTL from http://www.shoup.net/ntl/download.html\n2. uncompress and cd into the directory ntl-XXX/src\n3. On the command line:\n      ./configure NTL_GMP_LIP=on\n      make\n      sudo make install\n4. This should install NTL into /usr/local\n\n\nNow that you have these libraries in place, you can cd to the HElib\nsrc directory to build HElib.\n\nRight now, the \"build system\" for HElib is very rudimentary: no\nconfigure script and just a Makefile (with no \"make install\").\nThe Makefile will build the static library fhe.a in the HElib src\ndirectory, and then one can build applications programs based on\nfhe.a, also in the HElib src directory (or set the include and library\nparameters to include the right things). Hopefully, this build system\nwill be improved in the future.\n\nBefore building HElib, you may want to look at the Makefile, and\nconsider adjusting some of the defaults for CC and CFLAGS. The\ndefaults should be OK on most systems, but you can see the suggested\noptions, which are documented in the Makefile.\n\nOn the command line in the HElib src directory:\n\n   make\n\nwill compile and build the library fhe.a. Once built, run\n\n   make check\n\nwhich will compile and runs a series of test programs.\n\nIf you want to build your own program based on HElib, the easiest way\nto do it is to write the program in a file called myprog.cpp and then\nrun\n\n   make myprog_x\n\nwhich will compile myprog.cpp and link in fhe.a and all required\nsupport libraries, and create the executable myprog_x.\n\nTake a look at the programs Test_*.cpp for examples of using HElib.\n\nSome comments:\n\n* HElib uses C++11, for gcc you may need to specify the flags '-std=c++11'\nto be able to compile (depending on the gcc version that you use).\n\n* There are compilation flags that control some aspects of the\nlibrary, currently these are:\n\n  -DUSE_ALT_CRT\n    Tells HElib to use an alternative to the default DoubleCRT\n    representation of polynomials. The DoubleCRT class is described in\n    the (rather outdated) design document (Section 2.8). Specifying the\n    flag USE_ALT_CRT invokes a different implementation of the same\n    interfaces. This is an experimental feature, the alternative\n    implementation can be either faster or slower,  depending on the\n    operation mixture in use by the application.\n\n\n  -DNO_HALF_SIZE_PRIME\n    Tells HElib to not use the half size prime in the prime chain. By\n    default, the modulus-chain in HElib consists of many \"full-size primes\"\n    (of size n bits, typically n=50 or n=60 for 64-bit machines) and\n    one \"half-size prime\" of n/2 bits. A level corresponds to n/2 bits\n    in the size of the modulus, and dropping to a lower level is done\n    either by dropping the half-size prime (if it is part of the current\n    modulus) or by dropping a full-size prime and adding back the\n    half-size prime (if it is not part of the current modulus).\n\n    Specifying the flag NO_HALF_SIZE_PRIME makes all the primes the\n    same size, with each prime corresponding to a level (so dropping to\n    a lower level means dropping one of the primes).\n\n\n  -DEVALMAP_CACHED=0\n  -DEVALMAP_CACHED=1\n    This flag only affect bootstrapping, it tells HElib to cache some\n    constants that are used during recryption (rather than having to\n    encode then anew with every recryption operation).\n\n    EVALMAP_CACHED=0 caches these constants as ZZX'es, this takes\n    less space but it means that they still need to be converted to\n    DoubleCRT's with every recryption operation. \n\n    EVALMAP_CACHED=1 caches these constants directly as DoubleCRT's,\n    this may take a significant amount of memory.\n\n\n  -DHELIB_THREADS  tells HElib to enable generic multithreading capabilities;\n                   must be used with a thread-enabled NTL and the -pthread\n                   flag should be passed to gcc\n\n  -DHELIB_BOOT_THREADS  tells HElib to use a multithreading strategy for\n                        bootstrapping; requires -DHELIB_THREADS (see above)\n\n  -DDEBUG_PRINTOUT\n    Add some debugging printouts\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.7744140625,
          "content": "HElib\n=====\n\n[![Build and Test](https://github.com/homenc/HElib/actions/workflows/github-ci.yml/badge.svg)](https://github.com/homenc/HElib/actions/workflows/github-ci.yml)\n\nHElib is an open-source ([Apache License v2.0][5]) software library that\nimplements [homomorphic encryption][6] (HE). Currently available schemes are the\nimplementations of the [Brakerski-Gentry-Vaikuntanathan][1] (BGV) scheme with\n[bootstrapping][8] and the Approximate Number scheme of [Cheon-Kim-Kim-Song][9]\n(CKKS), along with many optimizations to make homomorphic evaluation run faster,\nfocusing mostly on effective use of the [Smart-Vercauteren][2] ciphertext\npacking techniques and the [Gentry-Halevi-Smart][3] optimizations. See [this\nreport][7] for a description of a few of the algorithms using in this library.\n\nPlease refer to [CKKS-security.md](CKKS-security.md) for the latest discussion\non the security of the CKKS scheme implementation in HElib.\n\nSince mid-2018 HElib has been under extensive refactoring for *Reliability*,\n*Robustness & Serviceability*, *Performance*, and most importantly *Usability*\nfor researchers and developers working on HE and its uses.\n\nHElib supports an *\"assembly language for HE\"*, providing low-level routines\n(set, add, multiply, shift, etc.), sophisticated automatic noise management,\nimproved BGV bootstrapping, multi-threading, and also support for Ptxt\n(plaintext) objects which mimics the functionality of Ctxt (ciphertext) objects.\nThe report [Design and implementation of HElib][11] contains additional details.\nAlso, see [CHANGES.md](CHANGES.md) for more information on the HElib releases.\n\nFull installation instructions and a list of the required dependencies can be\nfound in [INSTALL.md](INSTALL.md).\n\nFor guidance in getting started programming with HElib, take a look at the\nexample programs and our CKKS tutorials located in the `examples` directory. See\n[examples/README.md](examples/README.md).\n\nIf you are interested in contributing to HElib, please read our\n[Contributing Guidelines](CONTRIBUTING.md).\n\nHElib is written in C++17 and uses the [NTL mathematical library][4].  \nHElib is distributed under the terms of the [Apache License v2.0][5].  \n\n  [1]: http://eprint.iacr.org/2011/277       \"BGV12\"\n  [2]: http://eprint.iacr.org/2011/133       \"SV11\"\n  [3]: http://eprint.iacr.org/2012/099       \"GHS12\"\n  [4]: http://www.shoup.net/ntl/             \"NTL\"\n  [5]: http://www.apache.org/licenses/LICENSE-2.0  \"Apache-v2.0\"\n  [6]: http://en.wikipedia.org/wiki/Homomorphic_encryption \"Homomorphic encryption\"\n  [7]: http://eprint.iacr.org/2014/106       \"algorithms\"\n  [8]: http://eprint.iacr.org/2014/873       \"bootstrapping\"\n  [9]: http://eprint.iacr.org/2016/421       \"CKKS16\"\n  [10]: https://github.com/homenc/HElib      \"GitHubPages\"\n  [11]: https://eprint.iacr.org/2020/1481    \"HElib Design\"\n  \n"
        },
        {
          "name": "TESTS.md",
          "type": "blob",
          "size": 5.5126953125,
          "content": "# Building and running the new tests\n\n1. To build and run the new tests, one must pass `-DENABLE_TEST=on` to cmake\n   (see [INSTALL.md](INSTALL.md)).  The google test library will then be\n   downloaded and the correct targets will be defined for cmake.\n2. To compile them, `make` as normal from a build directory.\n3. The entire set of tests can be run with:\n    - `./bin/runTests` or `./dependencies/Build/helib_external/bin/runTests` if\n      `PACKAGE_BUILD=ON`.  The parameters `noPrint`, `dry` and `verbose` can be\n      specified as before, but they will apply to all tests which are run.\n    - `ctest`.  In this case the output will be significantly less verbose and\n      therefore less helpful in the case of a failure.  The parameter\n      `--output-on-failure` can be added to display the output of each test that\n      happened to fail.  It is also possible to run tests in parallel by using\n      `-j<number of concurrent tests>`.  Detailed output of the tests (as if run\n      directly with `runTests`) can be found in\n      `Testing/Temporary/LastTest.log`.\n    - `make test`, which will run the tests through `ctest`.  In this case no\n      arguments can be passed.  Detailed output of the tests (as if run directly\n      with `runTests`) can be found in `Testing/Temporary/LastTest.log`.\n\n## Running a subset of the tests\n\nOne may often want to run a specific test or set of tests.  This is achieved\nusing google test's built-in 'filtering' system.  To run only the `PolyEval`\ntests, for example, one simply runs\n```\n./bin/runTests --gtest_filter='*PolyEval*'\n```\nTo list all the tests, use `./bin/runTests --gtest_list_tests`.  More details\non this filtering can be found in Google's documentation [here][1].\n\nIt is also possible to run a specific test using `ctest` by adding the argument\n`-R \"<name of the test>\"`.  For example to run only the `PolyEval` test one\nsimply runs\n```\nctest -R \"PolyEval\"\n```\nTo list all the tests, use `ctest -N`.  More details on this filtering can be\nfound in the `ctest` documentation `ctest --help`.\n\n## Changing parameters\n\nThe majority of the tests currently residing in `tests` are ported from the old\ntests which took several parameters.  This maps reasonably well onto google\ntest's 'Parameterised tests', more of which can be read about [here][2].\n\nCurrently, the parameters to run tests with are written in the tests themselves,\nand require modification in the code to run with different parameters.  Some\nruntime overriding of these parameters would be possible by placing a function\ncall in the `INSTANTIATE_TEST_CASE_P` macro, but this has not been done yet.\n\n# Writing new tests\n\n## Why google test?\n\nThe google test framework gives us a few of main benefits:\n\n- The presence of 'fixtures', which are classes to contain common set-up and\n  teardown code.  These are created by inheriting from `::testing::Test` or\n  `::testing::TestWithParam<T>`, and typically have a name such as\n  `GTest_extractDigits`.\n- A rich set of expectation/assertion macros, such as `EXPECT_EQ`, `EXPECT_GT`,\n  and many more which can be read about [here][3].  A test will typically\n  contain at least one of these, the result of which determines the success or\n  failure of the test.\n- A convenient runner which provides utilities such as filtering, repeating,\n  shuffling, and convenient, consistent printouts.  This adds significant\n  convenience when only some tests are failing, since a summary as printed at\n  the end specifying which tests failed, with which parameters they failed,\n  etc.\n\n## Summary of how to write a google test\n\n1. Create a new file for the tests, let's say called `GTest_foo.cpp`.\n2. Add `GTest_foo.cpp` and `GTest_foo` to the appropriate lists in\n   `tests/CMakeLists.txt`.\n3. In `GTest_foo.cpp`, be sure to include both `\"gtest/gtest.h\"` and\n   `\"test_common.h`.  The latter will give access to the parameters\n   `helib_test::dry`, `helib_test::noPrint`, `helib_test::special_bits`,\n   `helib_test::verbose`, and `helib_test::seed`.\n4. Create an anonymous namespace in which to put everything, so that the global\n   namespace for the test runner is not polluted.\n5. Create a class called `GTest_foo`, inheriting from `::testing::Test` or\n   `::testing::TestWithParam<some_type>` for non-parameterized or parameterized\n   tests (respectively). Common setup and teardown code/data should be placed in\n   this class.\n6. Create actual test code inside a `TEST_F` or `TEST_P` for non-parameterized\n   or parameterized tests (respectively).\n7. If using parameterized tests, create some parameters to run the tests with\n   using the `INSTANTIATE_TEST_CASE_P` macro.\n\n## Further reading\n\nMore details on how to use these google test utilities can be found by the\nhelpful google test documentation:\n\n- Basic overview: https://github.com/google/googletest/\n- Introduction to using google test:\n  https://github.com/google/googletest/blob/master/googletest/docs/primer.md\n- More detailed documentation:\n  https://github.com/google/googletest/blob/master/googletest/README.md\n- Advanced features:\n  https://github.com/google/googletest/blob/master/googletest/docs/advanced.md\n\nIt may also be helpful to look at the existing examples of the above style of\ntesting, which can be found in the `src/tests` folder.\n\n[1]: https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#running-a-subset-of-the-tests \"Google documentation\"\n[2]: https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests \"Parameterised tests\"\n[3]: https://github.com/google/googletest/blob/master/googletest/docs/primer.md \"expectation/assertion macros\"\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "2.2.0\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "dependencies",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}