{
  "metadata": {
    "timestamp": 1736565983687,
    "page": 963,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "skypjack/uvw",
      "stars": 1892,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.0634765625,
          "content": "BasedOnStyle: llvm\n---\nAccessModifierOffset: -4\nAlignEscapedNewlines: DontAlign\nAllowShortBlocksOnASingleLine: Empty\nAllowShortEnumsOnASingleLine: true\nAllowShortFunctionsOnASingleLine: Empty\nAllowShortIfStatementsOnASingleLine: WithoutElse\nAllowShortLoopsOnASingleLine: true\nAlwaysBreakTemplateDeclarations: Yes\nBreakBeforeBinaryOperators: NonAssignment\nBreakBeforeTernaryOperators: true\nColumnLimit: 0\nDerivePointerAlignment: false\nIncludeCategories:\n  - Regex: '<[[:alnum:]_]+>'\n    Priority: 1\n  - Regex: '<(gtest|gmock)/'\n    Priority: 2\n  - Regex: '<[[:alnum:]_./]+>'\n    Priority: 3\n  - Regex: '<entt/'\n    Priority: 4\n  - Regex: '.*'\n    Priority: 5\nIndentPPDirectives: AfterHash\nIndentWidth: 4\nKeepEmptyLinesAtTheStartOfBlocks: false\nLanguage: Cpp\nPointerAlignment: Right\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: false\nSpaceAroundPointerQualifiers: After\nSpaceBeforeCaseColon: false\nSpaceBeforeCtorInitializerColon: false\nSpaceBeforeInheritanceColon: false\nSpaceBeforeParens: Never\nSpaceBeforeRangeBasedForLoopColon: false\nStandard: Latest\nTabWidth: 4\nUseTab: Never\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.3076171875,
          "content": "Checks: >\n    bugprone-*,\n    -bugprone-easily-swappable-parameters,\n    concurrency-*,\n    modernize-*,\n    -modernize-avoid-c-arrays,\n    -modernize-use-trailing-return-type,\n    performance-*,\n    portability-*,\nCheckOptions:\n    - key: bugprone-suspicious-include.HeaderFileExtensions\n      value: \";h;hpp;ipp\"\n"
        },
        {
          "name": ".conan",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1025390625,
          "content": "*.user\nCMakeSettings.json\n.conan/test_package/build\ncmake-build-debug/\n.idea/\n.vs/\n.vscode/\n.cache/\nout/\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.232421875,
          "content": "# Author\n\nskypjack\n\n# Collaborators\n\nmorbo84\nstefanofiorentino\n\n# Contributors\n\nlessness\nlordlukas\nlpmi-13\nZikoel\nfradefe\ntusharpm\nfcelda\nraoul\nfilonik\nyisonPylkita\nMiigon\nslyshykO\nbmagistro\nrichardbmx\nwnsgml972\nffontaine\nelindsey\nerez-o\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.365234375,
          "content": "#\n# uvw\n#\n\ncmake_minimum_required(VERSION 3.13)\n\n#\n# Building in-tree is not allowed (we take care of your craziness).\n#\n\nif(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)\n    message(FATAL_ERROR \"Prevented in-tree built. Please create a build directory outside of the source code and call cmake from there. Thank you.\")\nendif()\n\n#\n# Project configuration\n#\nset(UVW_VERSION_MAJOR 3)\nset(UVW_VERSION_MINOR 5)\nset(UVW_VERSION_PATCH 0)\n\nproject(\n    uvw\n    VERSION ${UVW_VERSION_MAJOR}.${UVW_VERSION_MINOR}.${UVW_VERSION_PATCH}\n    DESCRIPTION \"Header-only, event based, tiny and easy to use libuv wrapper in modern C++ - now available also as static library!\"\n    HOMEPAGE_URL \"https://github.com/skypjack/uvw\"\n    LANGUAGES C CXX\n)\n\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE Debug)\nendif()\n\noption(UVW_USE_LIBCPP \"Use libc++ by adding -stdlib=libc++ flag if available.\" ON)\noption(UVW_USE_ASAN \"Use address sanitizer by adding -fsanitize=address -fno-omit-frame-pointer flags\" OFF)\noption(UVW_USE_UBSAN \"Use address sanitizer by adding -fsanitize=undefined -fno-sanitize-recover=all -fno-omit-frame-pointer flags\" OFF)\noption(UVW_USE_CLANG_TIDY \"Enable static analysis with clang-tidy\" OFF)\noption(UVW_BUILD_LIBS \"Prepare targets for static library rather than for a header-only library.\" OFF)\noption(UVW_BUILD_SHARED_LIB \"Prepare targets for shared library rather than for a header-only library.\" OFF)\noption(UVW_FIND_LIBUV \"Try finding libuv library development files in the system\" OFF)\n\nif(UVW_BUILD_SHARED_LIB)\n    set(UVW_BUILD_LIBS BOOL:ON)\nendif()\n\n#\n# Compiler stuff\n#\n\nif(NOT WIN32 AND UVW_USE_LIBCPP)\n    include(CheckCXXSourceCompiles)\n    include(CMakePushCheckState)\n\n    cmake_push_check_state()\n\n    set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -stdlib=libc++\")\n\n    check_cxx_source_compiles(\"\n        #include<type_traits>\n        int main() { return std::is_same_v<int, char>; }\n    \" UVW_HAS_LIBCPP)\n\n    if(NOT UVW_HAS_LIBCPP)\n        message(WARNING \"The option UVW_USE_LIBCPP is set (by default) but libc++ is not available. The flag will not be added to the target.\")\n    endif()\n\n    cmake_pop_check_state()\nendif()\n\nif(UVW_USE_CLANG_TIDY)\n    find_program(UVW_CLANG_TIDY_EXECUTABLE \"clang-tidy\")\n\n    if(NOT UVW_CLANG_TIDY_EXECUTABLE)\n        message(VERBOSE \"The option UVW_USE_CLANG_TIDY is set but clang-tidy executable is not available.\")\n    endif()\nendif()\n\n# Required minimal libuv version\nset(UVW_LIBUV_VERSION 1.49.0)\n\nfunction(fetch_libuv)\n    if (UVW_FETCH_LIBUV)\n        include(FetchContent)\n\n        FetchContent_Declare(\n            libuv\n            GIT_REPOSITORY https://github.com/libuv/libuv.git\n            GIT_TAG \"v${UVW_LIBUV_VERSION}\"\n            GIT_SHALLOW 1\n        )\n\n        FetchContent_GetProperties(libuv)\n\n        if(NOT libuv_POPULATED)\n            FetchContent_Populate(libuv)\n            add_subdirectory(${libuv_SOURCE_DIR} ${libuv_BINARY_DIR} EXCLUDE_FROM_ALL)\n        endif()\n\n        if(UVW_BUILD_SHARED_LIB)\n            add_library(uv::uv-shared ALIAS uv)\n            set_target_properties(uv PROPERTIES POSITION_INDEPENDENT_CODE 1)\n        else()\n            add_library(uv::uv-static ALIAS uv_a)\n            set_target_properties(uv_a PROPERTIES POSITION_INDEPENDENT_CODE 1)\n        endif()\n    endif(UVW_FETCH_LIBUV)\nendfunction()\n\nfunction(use_libuv)\n    set(UVW_FETCH_LIBUV_DEFAULT ON)\n\n    if (UVW_FIND_LIBUV)\n        find_package(libuv ${LIBUV_VERSION} QUIET)\n        if (libuv_FOUND)\n            add_library(uv::uv-shared ALIAS uv)\n            set(UVW_FETCH_LIBUV_DEFAULT OFF)\n            message(STATUS \"libuv ${libuv_VERSION} found via cmake\")\n        else(libuv_FOUND)\n            find_package(PkgConfig QUIET)\n            if (PkgConfig_FOUND)\n                pkg_check_modules(libuv IMPORTED_TARGET libuv>=${LIBUV_VERSION})\n                if (libuv_FOUND)\n                    add_library(uv::uv-shared ALIAS PkgConfig::libuv)\n                    set(UVW_FETCH_LIBUV_DEFAULT OFF)\n                    message(STATUS \"libuv ${libuv_VERSION} found via pkg-config\")\n                endif(libuv_FOUND)\n            endif(PkgConfig_FOUND)\n        endif(libuv_FOUND)\n    endif(UVW_FIND_LIBUV)\n\n    option(UVW_FETCH_LIBUV \"Fetch the libuv repo using CMake FetchContent facility\" ${UVW_FETCH_LIBUV_DEFAULT})\n\n    fetch_libuv()\nendfunction()\n\n#\n# Add uvw target\n#\n\ninclude(GNUInstallDirs)\n\nif(UVW_BUILD_LIBS)\n    use_libuv()\n\n    add_subdirectory(src)\n    file(GLOB HEADERS src/uvw/*.h src/uvw/*.hpp)\nelse()\n    add_library(uvw INTERFACE)\n    add_library(uvw::uvw ALIAS uvw)\n\n    target_compile_features(uvw INTERFACE cxx_std_17)\n\n    target_include_directories(\n        uvw\n        INTERFACE\n            $<BUILD_INTERFACE:${uvw_SOURCE_DIR}/src>\n            $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n    )\n\n    if(UVW_USE_ASAN)\n        target_compile_options(uvw INTERFACE $<$<CONFIG:Debug>:-fsanitize=address -fno-omit-frame-pointer>)\n        target_link_libraries(uvw INTERFACE $<$<CONFIG:Debug>:-fsanitize=address>)\n    endif()\n\n    if(UVW_USE_UBSAN)\n        target_compile_options(uvw INTERFACE $<$<CONFIG:Debug>:-fsanitize=undefined -fno-sanitize-recover=all -fno-omit-frame-pointer>)\n        target_link_libraries(uvw INTERFACE $<$<CONFIG:Debug>:-fsanitize=undefined>)\n    endif()\n\n    if(UVW_CLANG_TIDY_EXECUTABLE)\n        set(CMAKE_CXX_CLANG_TIDY \"${UVW_CLANG_TIDY_EXECUTABLE};--config-file=${uvw_SOURCE_DIR}/.clang-tidy;--header-filter=${uvw_SOURCE_DIR}/src/uvw/.*\")\n    endif()\n\n    if(UVW_HAS_LIBCPP)\n        target_compile_options(uvw BEFORE INTERFACE -stdlib=libc++)\n    endif()\n\n    file(GLOB HEADERS src/uvw/*.h src/uvw/*.hpp)\nendif()\n\n#\n# Install targets\n#\n\ninstall(\n    FILES ${HEADERS}\n    COMPONENT ${PROJECT_NAME}\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/uvw\n    PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ\n)\n\ninstall(\n    FILES src/uvw.hpp\n    COMPONENT ${PROJECT_NAME}\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n    PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ\n)\n\n#\n# Install targets\n#\n\nif (UVW_BUILD_LIBS)\n    set_target_properties(\n        uvw PROPERTIES\n        VERSION ${UVW_VERSION_MAJOR}.${UVW_VERSION_MINOR}.${UVW_VERSION_PATCH}\n        SOVERSION ${UVW_VERSION_MAJOR}\n    )\nendif()\n\ninstall(\n    EXPORT uvwConfig \n    NAMESPACE uvw:: \n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/uvw\n)\n\ninstall(\n    TARGETS uvw \n    EXPORT uvwConfig\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n)\n\nif(UVW_FETCH_LIBUV AND UVW_BUILD_LIBS)\n    # libuv is only fetched when both above conditions are true\n    install(DIRECTORY ${libuv_SOURCE_DIR}/include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/uvw/uv/include)\n    if (UVW_BUILD_SHARED_LIB)\n        install(TARGETS uv EXPORT uvwConfig LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/uvw)\n    else()\n        install(TARGETS uv_a EXPORT uvwConfig ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/uvw)\n    endif()\nendif(UVW_FETCH_LIBUV AND UVW_BUILD_LIBS)\n\nexport(EXPORT uvwConfig)\n\n### Testing\n\noption(UVW_BUILD_TESTING \"Enable testing with ctest.\" OFF)\n\nif(UVW_BUILD_TESTING)\n    option(UVW_FIND_GTEST_PACKAGE \"Enable finding gtest package.\" OFF)\n\n    if (NOT UVW_BUILD_LIBS)\n        use_libuv()\n    endif()\n\n    enable_testing()\n    add_subdirectory(test)\nendif()\n\n#\n# Documentation\n#\n\noption(UVW_BUILD_DOCS \"Enable building with documentation.\" OFF)\n\nif(UVW_BUILD_DOCS)\n    find_package(Doxygen 1.10)\n\n    if(DOXYGEN_FOUND)\n        add_subdirectory(docs)\n    endif()\nendif()\n"
        },
        {
          "name": "CMakePresets.json",
          "type": "blob",
          "size": 1.572265625,
          "content": "{\n  \"version\": 2,\n  \"cmakeMinimumRequired\": {\n    \"major\": 3,\n    \"minor\": 13,\n    \"patch\": 0\n  },\n  \"configurePresets\": [\n    {\n      \"name\": \"cmake-pedantic\",\n      \"description\": \"Enables all CMake warnings.`\",\n      \"hidden\": true,\n      \"warnings\": {\n        \"dev\": true,\n        \"deprecated\": true,\n        \"uninitialized\": true,\n        \"unusedCli\": true,\n        \"systemVars\": false\n      }\n    },\n    {\n      \"name\": \"dev-mode\",\n      \"hidden\": true,\n      \"description\": \"Common (non-OS specific) mode for development\",\n      \"inherits\": \"cmake-pedantic\",\n      \"cacheVariables\": {\n        \"UVW_BUILD_TESTING\": true,\n        \"libuv_buildtests\": false\n      }\n    },\n    {\n      \"name\": \"flags-linux\",\n      \"hidden\": true,\n      \"description\": \"Compiler flags for GNU and Clang compilers. When compiling in DEBUG mode, all warnings will be converted into errors.\",\n      \"cacheVariables\": {\n        \"CMAKE_CXX_FLAGS\": \"-Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion -Wcast-qual -Wformat=2 -Wundef -Wshadow -Wcast-align -Wunused -Wnull-dereference -Wimplicit-fallthrough -Woverloaded-virtual -Wnon-virtual-dtor -Wold-style-cast\",\n        \"CMAKE_CXX_FLAGS_DEBUG\": \"-Werror\"\n      }\n    },\n    {\n      \"name\": \"ci-linux\",\n      \"generator\": \"Unix Makefiles\",\n      \"hidden\": true,\n      \"inherits\": [\"flags-linux\"],\n      \"cacheVariables\": {\n        \"CMAKE_BUILD_TYPE\": \"Debug\"\n      }\n    },\n    {\n      \"name\": \"ci-build\",\n      \"binaryDir\": \"${sourceDir}/build\",\n      \"hidden\": true\n    },\n    {\n      \"name\": \"ci-ubuntu\",\n      \"inherits\": [\"ci-build\", \"ci-linux\", \"dev-mode\"]\n    }\n  ]\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016-2024 Michele Caini\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopy of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopy or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.521484375,
          "content": "![uvw - libuv wrapper in modern C++](https://user-images.githubusercontent.com/1812216/46069406-c977a600-c17b-11e8-9a47-9bba6f412c57.png)\n\n[![Build Status](https://github.com/skypjack/uvw/workflows/build/badge.svg)](https://github.com/skypjack/uvw/actions)\n[![Coverage](https://codecov.io/gh/skypjack/uvw/branch/master/graph/badge.svg)](https://codecov.io/gh/skypjack/uvw)\n[![Documentation](https://img.shields.io/badge/docs-doxygen-blue)](https://skypjack.github.io/uvw/)\n[![Vcpkg port](https://img.shields.io/vcpkg/v/uvw)](https://vcpkg.link/ports/uvw)\n[![Gitter chat](https://badges.gitter.im/skypjack/uvw.png)](https://gitter.im/skypjack/uvw)\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.me/skypjack)\n\nDo you have a **question** that doesn't require you to open an issue? Join the\n[gitter channel](https://gitter.im/skypjack/uvw).<br/>\nIf you use `uvw` and you want to say thanks or support the project, please\n**consider becoming a\n[sponsor](https://github.com/users/skypjack/sponsorship)**.<br/>\nYou can help me make the difference.\n[Many thanks](https://skypjack.github.io/sponsorship/) to those who supported me\nand still support me today.\n\n# Introduction\n\n`uvw` started as a header-only, event based, tiny and easy to use wrapper for\n[`libuv`](https://github.com/libuv/libuv) written in modern C++.<br/>\nNow it's finally available also as a compilable static library.\n\nThe basic idea is to wrap the *C-ish* interface of `libuv` behind a graceful C++\nAPI.<br/>\nNote that `uvw` stays true to the API of `libuv` and it doesn't add anything to\nits interface. For the same reasons, users of the library must follow the same\nrules which are used with `libuv`.<br/>\nAs an example, a *handle* should be initialized before any other operation and\nclosed once it is no longer in use.\n\n## Code Example\n\n```cpp\n#include <uvw.hpp>\n#include <memory>\n\nvoid listen(uvw::loop &loop) {\n    std::shared_ptr<uvw::tcp_handle> tcp = loop.resource<uvw::tcp_handle>();\n\n    tcp->on<uvw::listen_event>([](const uvw::listen_event &, uvw::tcp_handle &srv) {\n        std::shared_ptr<uvw::tcp_handle> client = srv.parent().resource<uvw::tcp_handle>();\n\n        client->on<uvw::close_event>([ptr = srv.shared_from_this()](const uvw::close_event &, uvw::tcp_handle &) { ptr->close(); });\n        client->on<uvw::end_event>([](const uvw::end_event &, uvw::tcp_handle &client) { client.close(); });\n\n        srv.accept(*client);\n        client->read();\n    });\n\n    tcp->bind(\"127.0.0.1\", 4242);\n    tcp->listen();\n}\n\nvoid conn(uvw::loop &loop) {\n    auto tcp = loop.resource<uvw::tcp_handle>();\n\n    tcp->on<uvw::error_event>([](const uvw::error_event &, uvw::tcp_handle &) { /* handle errors */ });\n\n    tcp->on<uvw::connect_event>([](const uvw::connect_event &, uvw::tcp_handle &tcp) {\n        auto dataWrite = std::unique_ptr<char[]>(new char[2]{ 'b', 'c' });\n        tcp.write(std::move(dataWrite), 2);\n        tcp.close();\n    });\n\n    tcp->connect(std::string{\"127.0.0.1\"}, 4242);\n}\n\nint main() {\n    auto loop = uvw::loop::get_default();\n    listen(*loop);\n    conn(*loop);\n    loop->run();\n}\n```\n\n## Motivation\n\nThe main reason for which `uvw` has been written is the fact that there does not\nexist a valid `libuv` wrapper in C++. That's all.\n\n# Build Instructions\n\n## Requirements\n\nTo be able to use `uvw`, users must provide the following system-wide tools:\n\n* A full-featured compiler that supports at least C++17.\n* `libuv` (which version depends on the tag of `uvw` in use)\n  *  If you use `meson`, libuv will be downloaded for you\n\nThe requirements below are mandatory to compile the tests and to extract the\ndocumentation:\n\n* CMake version 3.13 or later.\n* Doxygen version 1.8 or later.\n\nNote that `libuv` is part of the dependencies of the project and may be cloned\nby `CMake` in some cases (see below for further details).<br/>\nBecause of that, users don't have to install it to run the tests or when `uvw`\nlibraries are compiled through `CMake`.\n\n## Meson\n\nYou can use `uvw` with [meson](https://mesonbuild.com/) by simply adding it to\nyour `subprojects` directory in your project.\n\nTo compile `uvw` from source without using it as a subproject, in the `uvw`\nsource directory, run:\n\n* `$ meson setup build`\n  * If you want a static library, add `--default-library=static`\n* `$ cd build`\n* `$ meson compile`\n\n## Library\n\n`uvw` is a dual-mode library. It can be used in its header-only form or as a\ncompiled static library.<br/>\nThe following sections describe what to do in both cases to get `uvw` up and\nrunningin your own project.\n\n### Header-only\n\nTo use `uvw` as a header-only library, all is needed is to include the `uvw.hpp`\nheader or one of the other `uvw/*.hpp` files.<br/>\nIt's a matter of adding the following line at the top of a file:\n\n```cpp\n#include <uvw.hpp>\n```\n\nThen pass the proper `-I` argument to the compiler to add the `src` directory to\nthe include paths.<br/>\nNote that users are required to correctly setup the include directories and\nlibraries search paths for `libuv` in this case.\n\nWhen used through `CMake`, the `uvw::uvw` target is exported for convenience.\n\n### Static\n\nTo use `uvw` as a compiled library, set the `UVW_BUILD_LIBS` options in cmake\nbefore including the project.<br/>\nThis option triggers the generation of a targets named\n`uvw::uvw-static`. The matching version of `libuv` is also\ncompiled and exported as `uv::uv-static` for convenience.\n\nIn case you don't use or don't want to use `CMake`, you can still compile all\n`.cpp` files and include all `.h` files to get the job done. In this case, users\nare required to correctly setup the include directories and libraries search\npaths for `libuv`.\n\n## Versioning\n\nStarting with tag _v1.12.0_ of `libuv`, `uvw` follows the\n[semantic versioning](http://semver.org/) scheme.<br/>\nThe problem is that any version of `uvw` also requires to track explicitly the\nversion of `libuv` to which it is bound.<br/>\nBecause of that, the latter wil be appended to the version of `uvw`. As an\nexample:\n\n    vU.V.W_libuv-vX.Y\n\nIn particular, the following applies:\n\n* _U.V.W_ are major, minor and patch versions of `uvw`.\n* _X.Y_ is the version of `libuv` to which to refer (where any patch version is\n  valid).\n\nIn other terms, tags will look like this from now on:\n\n    v1.0.0_libuv-v1.12\n\nBranch `master` of `uvw` will be a work in progress branch that follows branch\n_v1.x_ of `libuv` (at least as long as it remains their _master_ branch).<br/>\n\n## Documentation\n\nThe documentation is based on\n[`doxygen`](https://www.doxygen.nl/). To build it:\n\n* `$ cd build`\n* `$ cmake ..`\n* `$ make docs`\n\nThe API reference will be created in HTML format within the directory\n`build/docs/html`.<br/>\nTo navigate it with your favorite browser:\n\n* `$ cd build`\n* `$ your_favorite_browser docs/html/index.html`\n\nThe same version is also available [online](https://skypjack.github.io/uvw/)\nfor the latest release, that is the last stable tag.\n\n### Note\n\nThe documentation is mostly inspired by the official\n[libuv API documentation](http://docs.libuv.org/en/v1.x/) for obvious\nreasons.\n\n## Tests\n\nTo compile and run the tests, `uvw` requires `libuv` and `googletest`.<br/>\n`CMake` will download and compile both the libraries before compiling anything\nelse.\n\nTo build the tests:\n\n* `$ cd build`\n* `$ cmake .. -DUVW_BUILD_TESTING=ON`\n* `$ make`\n* `$ ctest -j4 -R uvw`\n\nOmit `-R uvw` if you also want to test `libuv` and other dependencies.\n\n# Crash Course\n\n## Vademecum\n\nThere is only one rule when using `uvw`: always initialize the resources and\nterminate them.\n\nResources belong mainly to two families: _handles_ and _requests_.<br/>\nHandles represent long-lived objects capable of performing certain operations\nwhile active.<br/>\nRequests represent (typically) short-lived operations performed either over a\nhandle or standalone.\n\nThe following sections will explain in short what it means to initialize and\nterminate these kinds of resources.<br/>\nFor more details, please refer to the\n[online documentation](https://skypjack.github.io/uvw/).\n\n## Handles\n\nInitialization is usually performed under the hood and can be even passed over,\nas far as handles are created using the `loop::resource` member function.<br/>\nOn the other side, handles keep themselves alive until one explicitly closes\nthem. Because of that, memory usage will grow if users simply forget about a\nhandle.<br/>\nTherefore the rule quickly becomes *always close your handles*. It's as simple\nas calling the `close` member function on them.\n\n## Requests\n\nUsually initializing a request object is not required. Anyway, the recommended\nway to create a request is still through the `loop::resource` member\nfunction.<br/>\nRequests will keep themselves alive as long as they are bound to unfinished\nunderlying activities. This means that users don't have to discard a\nrequest explicitly .<br/>\nTherefore the rule quickly becomes *feel free to make a request and forget about\nit*. It's as simple as calling a member function on them.\n\n## The Loop and the Resource\n\nThe first thing to do to use `uvw` is to create a loop. In case the default one\nis enough, it's easy as doing this:\n\n```cpp\nauto loop = uvw::loop::get_default();\n```\n\nNote that loop objects don't require being closed explicitly, even if they offer\nthe `close` member function in case a user wants to do that.<br/>\nLoops can be started using the `run` member function. The two calls below are\nequivalent:\n\n```cpp\nloop->run();\nloop->run(uvw::loop::run_mode::DEFAULT);\n```\n\nAvailable modes are: `DEFAULT`, `ONCE`, `NOWAIT`. Please refer to the\ndocumentation of `libuv` for further details.\n\nIn order to create a resource and to bind it to the given loop, just do the\nfollowing:\n\n```cpp\nauto tcp = loop->resource<uvw::tcp_handle>();\n```\n\nThe line above creates and initializes a tcp handle, then a shared pointer to\nthat resource is returned.<br/>\nUsers should check if pointers have been correctly initialized: in case of\nerrors, they won't be.<br/>\nIt also is possible to create uninitialized resources to init later on as:\n\n```cpp\nauto tcp = loop->uninitialized_resource<uvw::tcp_handle>();\ntcp->init();\n```\n\nAll resources also accept arbitrary user-data that won't be touched in any\ncase.<br/>\nUsers can set and get them through the `data` member function as it follows:\n\n```cpp\nresource->data(std::make_shared<int>(42));\nstd::shared_ptr<void> data = resource->data();\n```\n\nResources expect a `std::shared_pointer<void>` and return it, therefore any kind\nof data is welcome.<br/>\nUsers can explicitly specify a type other than `void` when calling the `data`\nmember function:\n\n```cpp\nstd::shared_ptr<int> data = resource->data<int>();\n```\n\nRemember from the previous section that a handle will keep itself alive until\none invokes the `close` member function on it.<br/>\nTo know what are the handles that are still alive and bound to a given loop,\nthere exists the `walk` member function. It returns handles with their types.\nTherefore, the use of `overloaded` is recommended to be able to intercept all\ntypes of interest:\n\n```cpp\nhandle.parent().walk(uvw::overloaded{\n    [](uvw::timer_handle &h){ /* application code for timers here */ },\n    [](auto &&){ /* ignore all other types */ }\n});\n```\n\nThis function can also be used for a completely generic approach. For example,\nall the pending handles can be closed easily as it follows:\n\n```cpp\nloop->walk([](auto &&h){ h.close(); });\n```\n\nNo need to keep track of them.\n\n## The event-based approach\n\n`uvw` offers an event-based approach where resources are small event emitters to\nwhich listeners are attached.<br/>\nAttaching listeners to resources is the recommended way to receive notifications\nabout their operations.<br/>\nListeners are callable objects of type `void(event_type &, resource_type &)`,\nwhere:\n\n* `event_type` is the type of the event for which they have been designed.\n* `resource_type` is the type of the resource that has originated the event.\n\nIt means that the following function types are all valid:\n\n* `void(event_type &, resource_type &)`\n* `void(const event_type &, resource_type &)`\n* `void(event_type &, const resource_type &)`\n* `void(const event_type &, const resource_type &)`\n\nPlease note that there is no need to keep around references to the resources,\nsince they pass themselves as an argument whenever an event is published.<br/>\nThe `on` member function is the way to go to register long-running listeners:\n\n```cpp\nresource.on<event_type>(listener)\n```\n\nTo know if a listener exists for a given type, the class offers a `has` function\ntemplate. Similarly, the `reset` function template is be used to reset and thus\ndisconnect listeners, if any. A non-template version of `reset` also exists to\nclear an emitter as a whole.\n\nAlmost all the resources emit `error_event` in case of errors.<br/>\nAll the other events are specific for the given resource and documented in the\nAPI reference.\n\nThe code below shows how to create a simple tcp server using `uvw`:\n\n```cpp\nauto loop = uvw::loop::get_default();\nauto tcp = loop->resource<uvw::tcp_handle>();\n\ntcp->on<uvw::error_event>([](const uvw::error_event &, uvw::tcp_handle &) { /* something went wrong */ });\n\ntcp->on<uvw::listen_event>([](const uvw::listen_event &, uvw::tcp_handle &srv) {\n    std::shared_ptr<uvw::tcp_handle> client = srv.parent().resource<uvw::tcp_handle>();\n    client->on<uvw::end_event>([](const uvw::end_event &, uvw::tcp_handle &client) { client.close(); });\n    client->on<uvw::data_event>([](const uvw::data_event &, uvw::tcp_handle &) { /* data received */ });\n    srv.accept(*client);\n    client->read();\n});\n\ntcp->bind(\"127.0.0.1\", 4242);\ntcp->listen();\n```\n\nNote also that `uvw::tcp_handle` already supports _IPv6_ out-of-the-box.<br/>\nThe API reference is the recommended documentation for further details about\nresources and their methods.\n\n## Going raw\n\nIn case users need to use functionalities not wrapped yet by `uvw` or if they\nwant to get the underlying data structures as defined by `libuv` for some other\nreasons, almost all the classes in `uvw` give direct access to them.<br/>\nPlease, note that this functions should not be used directly unless users know\nexactly what they are doing and what are the risks. Going raw is dangerous,\nmainly because the lifetime management of a loop, a handle or a request is\ncompletely controlled by the library and working around it could quickly break\nthings.\n\nThat being said, _going raw_ is a matter of using the `raw` member functions:\n\n```cpp\nauto loop = uvw::loop::get_default();\nauto tcp = loop->resource<uvw::tcp_handle>();\n\nuv_loop_t *raw = loop->raw();\nuv_tcp_t *handle = tcp->raw();\n```\n\nGo the raw way at your own risk, but do not expect any support in case of bugs.\n\n\n# Related projects\n\nInterested in additional tools and libraries that build upon `uvw`? You might\nfind the following useful then:\n\n- [`uvw_net`](https://github.com/mincequi/uvw_net): a networking library with a\n  collection of clients (HTTP/Modbus/SunSpec) that also includes discovery\n  impementations like dns-sd/mdns.\n\nFeel free to add your tool to the list if you like.\n\n# Contributors\n\nIf you want to contribute, please send patches as pull requests against the\nbranch master.<br/>\nCheck the\n[contributors list](https://github.com/skypjack/uvw/blob/master/AUTHORS) to see\nwho has partecipated so far.\n\n# License\n\nCode and documentation Copyright (c) 2016-2024 Michele Caini.<br/>\nLogo Copyright (c) 2018-2021 Richard Caseres.\n\nCode and documentation released under\n[the MIT license](https://github.com/skypjack/uvw/blob/master/LICENSE).<br/>\nLogo released under\n[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/).\n\n# Support\n\nIf you want to support this project, you can\n[offer me](https://github.com/users/skypjack/sponsorship) an espresso.<br/>\nIf you find that it's not enough, feel free to\n[help me](https://www.paypal.me/skypjack) the way you prefer.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.20703125,
          "content": "* do not send error events when the return value is enough (still wip)\n* also cleanup error event mentions in the doc\n* Make all tests pass on all platforms\n* add iwyu and clean up everything\n* Allocator support\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 0.7451171875,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom conans import ConanFile\n\nclass UVWConan(ConanFile):\n    name = \"uvw\"\n    description = \"Header-only, event based, tiny and easy to use libuv wrapper in modern C++\"\n    homepage = \"https://github.com/skypjack/uvw\"\n    url = homepage\n    license = \"MIT\"\n    topics = (\"conan\", \"uvw\", \"libuv\", \"header-only\", \"wrapper\", \"event-loop\")\n    author = \"Michele Caini <michele.caini@gmail.com>\"\n    exports = \"LICENSE\"\n    exports_sources = \"src/*\"\n    no_copy_source = True\n    requires = \"libuv/1.49.0@bincrafters/stable\"\n\n    def package(self):\n        self.copy(pattern=\"LICENSE\", dst=\"licenses\")\n        self.copy(pattern=\"*.hpp\", dst=\"include\", src=\"src\")\n\n    def package_id(self):\n        self.info.header_only()\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 1.05078125,
          "content": "project(\n  'uvw',\n  'cpp',\n  version: '3.3.0',\n  license: 'MIT',\n  default_options: ['cpp_std=c++17'],\n)\n\nlibuv_dep = dependency('libuv', version: '1.48.0', required: true)\n\nsources = [\n  'src/uvw/async.cpp',\n  'src/uvw/check.cpp',\n  'src/uvw/dns.cpp',\n  'src/uvw/emitter.cpp',\n  'src/uvw/fs.cpp',\n  'src/uvw/fs_event.cpp',\n  'src/uvw/fs_poll.cpp',\n  'src/uvw/idle.cpp',\n  'src/uvw/lib.cpp',\n  'src/uvw/loop.cpp',\n  'src/uvw/pipe.cpp',\n  'src/uvw/poll.cpp',\n  'src/uvw/prepare.cpp',\n  'src/uvw/process.cpp',\n  'src/uvw/signal.cpp',\n  'src/uvw/stream.cpp',\n  'src/uvw/tcp.cpp',\n  'src/uvw/thread.cpp',\n  'src/uvw/timer.cpp',\n  'src/uvw/tty.cpp',\n  'src/uvw/udp.cpp',\n  'src/uvw/util.cpp',\n  'src/uvw/work.cpp',\n]\n\nuvw_lib = library(\n  'uvw',\n  sources,\n  include_directories: 'src',\n  dependencies: [libuv_dep],\n  cpp_args: ['-DUVW_AS_LIB'],\n  install: true,\n)\n\nuvw_dep = declare_dependency(\n  include_directories: ['src'],\n  dependencies: [libuv_dep],\n  link_with: [uvw_lib],\n)\n\nif meson.version().version_compare('>=0.54.0')\n  meson.override_dependency('uvw', uvw_dep)\nendif\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "subprojects",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "uvw.imp",
          "type": "blob",
          "size": 0.181640625,
          "content": "[\n  # gtest only\n  { \"include\": [ \"@<gtest/internal/.*>\", \"private\", \"<gtest/gtest.h>\", \"public\" ] },\n  { \"include\": [ \"@<gtest/gtest-.*>\", \"private\", \"<gtest/gtest.h>\", \"public\" ] },\n]\n"
        }
      ]
    }
  ]
}