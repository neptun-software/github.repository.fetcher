{
  "metadata": {
    "timestamp": 1736565652276,
    "page": 543,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eidheim/Simple-Web-Server",
      "stars": 2621,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.216796875,
          "content": "IndentWidth: 2\nAccessModifierOffset: -2\nUseTab: Never\nColumnLimit: 0\nMaxEmptyLinesToKeep: 2\nSpaceBeforeParens: Never\nBreakBeforeBraces: Custom\nBraceWrapping: {BeforeElse: true, BeforeCatch: true}\nNamespaceIndentation: All\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4345703125,
          "content": "# https://github.com/github/gitignore/blob/master/CMake.gitignore\nCMakeCache.txt\nCMakeFiles\nCMakeScripts\nMakefile\ncmake_install.cmake\ninstall_manifest.txt\n*.cmake\n#Additions to https://github.com/github/gitignore/blob/master/CMake.gitignore\nTesting\ncompile_commands.json\n.usages_clang\n\n*.crt\n*.key\n\n# executables\nhttp_examples\nhttps_examples\nio_test\nparse_test\ncrypto_test\nstatus_code_test\n\n# Visual Studio 2015/2017 cache/options directory\n.vs\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.626953125,
          "content": "sudo: required\n\nservices:\n  - docker\n\nscript:\n  - sudo docker run -it -v \"$PWD:/repository\" eidheim/testing sh -c \"\n      cd /repository && mkdir build && cd build &&\n      scan-build cmake -DCMAKE_CXX_FLAGS=-Werror .. &&\n      scan-build --status-bugs make &&\n      rm -r * &&\n      CXX=clang++ cmake -DCMAKE_CXX_FLAGS=-Werror .. &&\n      make &&\n      rm -r * &&\n      CXX=g++ cmake -DCMAKE_CXX_FLAGS=-Werror .. &&\n      make &&\n      CTEST_OUTPUT_ON_FAILURE=1 make test &&\n      rm -r * &&\n      CXX=g++ cmake -DUSE_STANDALONE_ASIO=ON -DCMAKE_CXX_FLAGS=\\\"-Werror -O3\\\" .. &&\n      make &&\n      CTEST_OUTPUT_ON_FAILURE=1 make test\n      \"\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.041015625,
          "content": "cmake_minimum_required (VERSION 3.0)\n\nproject (Simple-Web-Server)\n\noption(USE_STANDALONE_ASIO \"set ON to use standalone Asio instead of Boost.Asio\" OFF)\noption(BUILD_TESTING \"set ON to build library tests\" OFF)\n\nif(NOT MSVC)\n    add_compile_options(-std=c++11 -Wall -Wextra -Wsign-conversion)\nelse()\n    add_compile_options(/W1)\nendif()\n\nadd_library(simple-web-server INTERFACE)\n\ntarget_include_directories(simple-web-server INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})\n\nfind_package(Threads REQUIRED)\ntarget_link_libraries(simple-web-server INTERFACE ${CMAKE_THREAD_LIBS_INIT})\n\n# TODO 2020 when Debian Jessie LTS ends:\n# Remove Boost system, thread, regex components; use Boost::<component> aliases; remove Boost target_include_directories\nif(USE_STANDALONE_ASIO)\n    target_compile_definitions(simple-web-server INTERFACE USE_STANDALONE_ASIO)\n    include(CheckIncludeFileCXX)\n    CHECK_INCLUDE_FILE_CXX(asio.hpp HAVE_ASIO)\n    if(NOT HAVE_ASIO)\n        message(FATAL_ERROR \"Standalone Asio not found\")\n    endif()\nelse()\n    find_package(Boost 1.53.0 COMPONENTS system thread REQUIRED)\n    target_link_libraries(simple-web-server INTERFACE ${Boost_LIBRARIES})\n    target_include_directories(simple-web-server INTERFACE ${Boost_INCLUDE_DIR})\n    if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.9)\n        target_compile_definitions(simple-web-server INTERFACE USE_BOOST_REGEX)\n        find_package(Boost 1.53.0 COMPONENTS regex REQUIRED)\n        target_link_libraries(simple-web-server INTERFACE ${Boost_LIBRARIES})\n        target_include_directories(simple-web-server INTERFACE ${Boost_INCLUDE_DIR})\n    endif()\nendif()\nif(WIN32)\n    target_link_libraries(simple-web-server INTERFACE ws2_32 wsock32)\nendif()\n\nif(APPLE)\n    set(OPENSSL_ROOT_DIR \"/usr/local/opt/openssl\")\nendif()\nfind_package(OpenSSL)\nif(OPENSSL_FOUND)\n    target_compile_definitions(simple-web-server INTERFACE HAVE_OPENSSL)\n    target_link_libraries(simple-web-server INTERFACE ${OPENSSL_LIBRARIES})\n    target_include_directories(simple-web-server INTERFACE ${OPENSSL_INCLUDE_DIR})\nendif()\n\n# If Simple-Web-Server is not a sub-project:\nif(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n    add_executable(http_examples http_examples.cpp)\n    target_link_libraries(http_examples simple-web-server)\n    find_package(Boost 1.53.0 COMPONENTS system thread filesystem REQUIRED)\n    target_link_libraries(http_examples ${Boost_LIBRARIES})\n    target_include_directories(http_examples PRIVATE ${Boost_INCLUDE_DIR})\n    if(OPENSSL_FOUND)\n        add_executable(https_examples https_examples.cpp)\n        target_link_libraries(https_examples simple-web-server)\n        target_link_libraries(https_examples ${Boost_LIBRARIES})\n        target_include_directories(https_examples PRIVATE ${Boost_INCLUDE_DIR})\n    endif()\n    \n    set(BUILD_TESTING ON)\n    \n    install(FILES server_http.hpp client_http.hpp server_https.hpp client_https.hpp crypto.hpp utility.hpp status_code.hpp DESTINATION include/simple-web-server)\nendif()\n\nif(BUILD_TESTING)\n    enable_testing()\n    add_subdirectory(tests)\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2018 Ole Christian Eidheim\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.9853515625,
          "content": "**_This project has moved to https://gitlab.com/eidheim/Simple-Web-Server._**\n\nSimple-Web-Server\n=================\n\nA very simple, fast, multithreaded, platform independent HTTP and HTTPS server and client library implemented using C++11 and Asio (both Boost.Asio and standalone Asio can be used). Created to be an easy way to make REST resources available from C++ applications. \n\nSee https://gitlab.com/eidheim/Simple-WebSocket-Server for an easy way to make WebSocket/WebSocket Secure endpoints in C++. Also, feel free to check out the new C++ IDE supporting C++11/14/17: https://gitlab.com/cppit/jucipp. \n\n### Features\n\n* Asynchronous request handling\n* Thread pool if needed\n* Platform independent\n* HTTPS support\n* HTTP persistent connection (for HTTP/1.1)\n* Client supports chunked transfer encoding\n* Timeouts, if any of Server::timeout_request and Server::timeout_content are >0 (default: Server::timeout_request=5 seconds, and Server::timeout_content=300 seconds)\n* Simple way to add REST resources using regex for path, and anonymous functions\n\n### Usage\n\nSee http_examples.cpp or https_examples.cpp for example usage. \n\nSee particularly the JSON-POST (using Boost.PropertyTree) and the GET /match/[number] examples, which are most relevant.\n\n### Dependencies\n\n* Boost.Asio or standalone Asio\n* Boost is required to compile the examples\n* For HTTPS: OpenSSL libraries \n\n### Compile and run\n\nCompile with a C++11 compliant compiler:\n```sh\nmkdir build\ncd build\ncmake ..\nmake\ncd ..\n```\n\n#### HTTP\n\nRun the server and client examples: `./build/http_examples`\n\nDirect your favorite browser to for instance http://localhost:8080/\n\n#### HTTPS\n\nBefore running the server, an RSA private key (server.key) and an SSL certificate (server.crt) must be created. Follow, for instance, the instructions given here (for a self-signed certificate): http://www.akadia.com/services/ssh_test_certificate.html\n\nRun the server and client examples: `./build/https_examples`\n\nDirect your favorite browser to for instance https://localhost:8080/\n\n"
        },
        {
          "name": "client_http.hpp",
          "type": "blob",
          "size": 28.236328125,
          "content": "#ifndef CLIENT_HTTP_HPP\n#define CLIENT_HTTP_HPP\n\n#include \"utility.hpp\"\n#include <limits>\n#include <mutex>\n#include <random>\n#include <unordered_set>\n#include <vector>\n\n#ifdef USE_STANDALONE_ASIO\n#include <asio.hpp>\n#include <asio/steady_timer.hpp>\nnamespace SimpleWeb {\n  using error_code = std::error_code;\n  using errc = std::errc;\n  using system_error = std::system_error;\n  namespace make_error_code = std;\n} // namespace SimpleWeb\n#else\n#include <boost/asio.hpp>\n#include <boost/asio/steady_timer.hpp>\nnamespace SimpleWeb {\n  namespace asio = boost::asio;\n  using error_code = boost::system::error_code;\n  namespace errc = boost::system::errc;\n  using system_error = boost::system::system_error;\n  namespace make_error_code = boost::system::errc;\n} // namespace SimpleWeb\n#endif\n\n#if __cplusplus > 201402L || (defined(_MSC_VER) && _MSC_VER >= 1910)\n#include <string_view>\nnamespace SimpleWeb {\n  using string_view = std::string_view;\n}\n#elif !defined(USE_STANDALONE_ASIO)\n#include <boost/utility/string_ref.hpp>\nnamespace SimpleWeb {\n  using string_view = boost::string_ref;\n}\n#else\nnamespace SimpleWeb {\n  using string_view = const std::string &;\n}\n#endif\n\nnamespace SimpleWeb {\n  template <class socket_type>\n  class Client;\n\n  template <class socket_type>\n  class ClientBase {\n  public:\n    class Content : public std::istream {\n      friend class ClientBase<socket_type>;\n\n    public:\n      std::size_t size() noexcept {\n        return streambuf.size();\n      }\n      /// Convenience function to return std::string. The stream buffer is consumed.\n      std::string string() noexcept {\n        try {\n          std::string str;\n          auto size = streambuf.size();\n          str.resize(size);\n          read(&str[0], static_cast<std::streamsize>(size));\n          return str;\n        }\n        catch(...) {\n          return std::string();\n        }\n      }\n\n    private:\n      asio::streambuf &streambuf;\n      Content(asio::streambuf &streambuf) noexcept : std::istream(&streambuf), streambuf(streambuf) {}\n    };\n\n    class Response {\n      friend class ClientBase<socket_type>;\n      friend class Client<socket_type>;\n\n      asio::streambuf streambuf;\n\n      Response(std::size_t max_response_streambuf_size) noexcept : streambuf(max_response_streambuf_size), content(streambuf) {}\n\n    public:\n      std::string http_version, status_code;\n\n      Content content;\n\n      CaseInsensitiveMultimap header;\n    };\n\n    class Config {\n      friend class ClientBase<socket_type>;\n\n    private:\n      Config() noexcept {}\n\n    public:\n      /// Set timeout on requests in seconds. Default value: 0 (no timeout).\n      long timeout = 0;\n      /// Set connect timeout in seconds. Default value: 0 (Config::timeout is then used instead).\n      long timeout_connect = 0;\n      /// Maximum size of response stream buffer. Defaults to architecture maximum.\n      /// Reaching this limit will result in a message_size error code.\n      std::size_t max_response_streambuf_size = std::numeric_limits<std::size_t>::max();\n      /// Set proxy server (server:port)\n      std::string proxy_server;\n    };\n\n  protected:\n    class Connection : public std::enable_shared_from_this<Connection> {\n    public:\n      template <typename... Args>\n      Connection(std::shared_ptr<ScopeRunner> handler_runner, long timeout, Args &&... args) noexcept\n          : handler_runner(std::move(handler_runner)), timeout(timeout), socket(new socket_type(std::forward<Args>(args)...)) {}\n\n      std::shared_ptr<ScopeRunner> handler_runner;\n      long timeout;\n\n      std::unique_ptr<socket_type> socket; // Socket must be unique_ptr since asio::ssl::stream<asio::ip::tcp::socket> is not movable\n      bool in_use = false;\n      bool attempt_reconnect = true;\n\n      std::unique_ptr<asio::steady_timer> timer;\n\n      void set_timeout(long seconds = 0) noexcept {\n        if(seconds == 0)\n          seconds = timeout;\n        if(seconds == 0) {\n          timer = nullptr;\n          return;\n        }\n        timer = std::unique_ptr<asio::steady_timer>(new asio::steady_timer(socket->get_io_service()));\n        timer->expires_from_now(std::chrono::seconds(seconds));\n        auto self = this->shared_from_this();\n        timer->async_wait([self](const error_code &ec) {\n          if(!ec) {\n            error_code ec;\n            self->socket->lowest_layer().cancel(ec);\n          }\n        });\n      }\n\n      void cancel_timeout() noexcept {\n        if(timer) {\n          error_code ec;\n          timer->cancel(ec);\n        }\n      }\n    };\n\n    class Session {\n    public:\n      Session(std::size_t max_response_streambuf_size, std::shared_ptr<Connection> connection, std::unique_ptr<asio::streambuf> request_streambuf) noexcept\n          : connection(std::move(connection)), request_streambuf(std::move(request_streambuf)), response(new Response(max_response_streambuf_size)) {}\n\n      std::shared_ptr<Connection> connection;\n      std::unique_ptr<asio::streambuf> request_streambuf;\n      std::shared_ptr<Response> response;\n      std::function<void(const std::shared_ptr<Connection> &, const error_code &)> callback;\n    };\n\n  public:\n    /// Set before calling request\n    Config config;\n\n    /// If you have your own asio::io_service, store its pointer here before calling request().\n    /// When using asynchronous requests, running the io_service is up to the programmer.\n    std::shared_ptr<asio::io_service> io_service;\n\n    /// Convenience function to perform synchronous request. The io_service is run within this function.\n    /// If reusing the io_service for other tasks, use the asynchronous request functions instead.\n    /// Do not use concurrently with the asynchronous request functions.\n    std::shared_ptr<Response> request(const std::string &method, const std::string &path = std::string(\"/\"),\n                                      string_view content = \"\", const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n      std::shared_ptr<Response> response;\n      error_code ec;\n      request(method, path, content, header, [&response, &ec](std::shared_ptr<Response> response_, const error_code &ec_) {\n        response = response_;\n        ec = ec_;\n      });\n\n      {\n        std::unique_lock<std::mutex> lock(concurrent_synchronous_requests_mutex);\n        ++concurrent_synchronous_requests;\n      }\n      io_service->run();\n      {\n        std::unique_lock<std::mutex> lock(concurrent_synchronous_requests_mutex);\n        --concurrent_synchronous_requests;\n        if(!concurrent_synchronous_requests)\n          io_service->reset();\n      }\n\n      if(ec)\n        throw system_error(ec);\n\n      return response;\n    }\n\n    /// Convenience function to perform synchronous request. The io_service is run within this function.\n    /// If reusing the io_service for other tasks, use the asynchronous request functions instead.\n    /// Do not use concurrently with the asynchronous request functions.\n    std::shared_ptr<Response> request(const std::string &method, const std::string &path, std::istream &content,\n                                      const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n      std::shared_ptr<Response> response;\n      error_code ec;\n      request(method, path, content, header, [&response, &ec](std::shared_ptr<Response> response_, const error_code &ec_) {\n        response = response_;\n        ec = ec_;\n      });\n\n      {\n        std::unique_lock<std::mutex> lock(concurrent_synchronous_requests_mutex);\n        ++concurrent_synchronous_requests;\n      }\n      io_service->run();\n      {\n        std::unique_lock<std::mutex> lock(concurrent_synchronous_requests_mutex);\n        --concurrent_synchronous_requests;\n        if(!concurrent_synchronous_requests)\n          io_service->reset();\n      }\n\n      if(ec)\n        throw system_error(ec);\n\n      return response;\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    /// Do not use concurrently with the synchronous request functions.\n    void request(const std::string &method, const std::string &path, string_view content, const CaseInsensitiveMultimap &header,\n                 std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback_) {\n      auto session = std::make_shared<Session>(config.max_response_streambuf_size, get_connection(), create_request_header(method, path, header));\n      auto response = session->response;\n      auto request_callback = std::make_shared<std::function<void(std::shared_ptr<Response>, const error_code &)>>(std::move(request_callback_));\n      session->callback = [this, response, request_callback](const std::shared_ptr<Connection> &connection, const error_code &ec) {\n        {\n          std::unique_lock<std::mutex> lock(this->connections_mutex);\n          connection->in_use = false;\n\n          // Remove unused connections, but keep one open for HTTP persistent connection:\n          std::size_t unused_connections = 0;\n          for(auto it = this->connections.begin(); it != this->connections.end();) {\n            if(ec && connection == *it)\n              it = this->connections.erase(it);\n            else if((*it)->in_use)\n              ++it;\n            else {\n              ++unused_connections;\n              if(unused_connections > 1)\n                it = this->connections.erase(it);\n              else\n                ++it;\n            }\n          }\n        }\n\n        if(*request_callback)\n          (*request_callback)(response, ec);\n      };\n\n      std::ostream write_stream(session->request_streambuf.get());\n      if(content.size() > 0) {\n        auto header_it = header.find(\"Content-Length\");\n        if(header_it == header.end()) {\n          header_it = header.find(\"Transfer-Encoding\");\n          if(header_it == header.end() || header_it->second != \"chunked\")\n            write_stream << \"Content-Length: \" << content.size() << \"\\r\\n\";\n        }\n      }\n      write_stream << \"\\r\\n\"\n                   << content;\n\n      connect(session);\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    /// Do not use concurrently with the synchronous request functions.\n    void request(const std::string &method, const std::string &path, string_view content,\n                 std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback) {\n      request(method, path, content, CaseInsensitiveMultimap(), std::move(request_callback));\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    void request(const std::string &method, const std::string &path,\n                 std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback) {\n      request(method, path, std::string(), CaseInsensitiveMultimap(), std::move(request_callback));\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    void request(const std::string &method, std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback) {\n      request(method, std::string(\"/\"), std::string(), CaseInsensitiveMultimap(), std::move(request_callback));\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    void request(const std::string &method, const std::string &path, std::istream &content, const CaseInsensitiveMultimap &header,\n                 std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback_) {\n      auto session = std::make_shared<Session>(config.max_response_streambuf_size, get_connection(), create_request_header(method, path, header));\n      auto response = session->response;\n      auto request_callback = std::make_shared<std::function<void(std::shared_ptr<Response>, const error_code &)>>(std::move(request_callback_));\n      session->callback = [this, response, request_callback](const std::shared_ptr<Connection> &connection, const error_code &ec) {\n        {\n          std::unique_lock<std::mutex> lock(this->connections_mutex);\n          connection->in_use = false;\n\n          // Remove unused connections, but keep one open for HTTP persistent connection:\n          std::size_t unused_connections = 0;\n          for(auto it = this->connections.begin(); it != this->connections.end();) {\n            if(ec && connection == *it)\n              it = this->connections.erase(it);\n            else if((*it)->in_use)\n              ++it;\n            else {\n              ++unused_connections;\n              if(unused_connections > 1)\n                it = this->connections.erase(it);\n              else\n                ++it;\n            }\n          }\n        }\n\n        if(*request_callback)\n          (*request_callback)(response, ec);\n      };\n\n      content.seekg(0, std::ios::end);\n      auto content_length = content.tellg();\n      content.seekg(0, std::ios::beg);\n      std::ostream write_stream(session->request_streambuf.get());\n      if(content_length > 0) {\n        auto header_it = header.find(\"Content-Length\");\n        if(header_it == header.end()) {\n          header_it = header.find(\"Transfer-Encoding\");\n          if(header_it == header.end() || header_it->second != \"chunked\")\n            write_stream << \"Content-Length: \" << content_length << \"\\r\\n\";\n        }\n      }\n      write_stream << \"\\r\\n\";\n      if(content_length > 0)\n        write_stream << content.rdbuf();\n\n      connect(session);\n    }\n\n    /// Asynchronous request where setting and/or running Client's io_service is required.\n    void request(const std::string &method, const std::string &path, std::istream &content,\n                 std::function<void(std::shared_ptr<Response>, const error_code &)> &&request_callback) {\n      request(method, path, content, CaseInsensitiveMultimap(), std::move(request_callback));\n    }\n\n    /// Close connections\n    void stop() noexcept {\n      std::unique_lock<std::mutex> lock(connections_mutex);\n      for(auto it = connections.begin(); it != connections.end();) {\n        error_code ec;\n        (*it)->socket->lowest_layer().cancel(ec);\n        it = connections.erase(it);\n      }\n    }\n\n    virtual ~ClientBase() noexcept {\n      handler_runner->stop();\n      stop();\n    }\n\n  protected:\n    bool internal_io_service = false;\n\n    std::string host;\n    unsigned short port;\n    unsigned short default_port;\n\n    std::unique_ptr<asio::ip::tcp::resolver::query> query;\n\n    std::unordered_set<std::shared_ptr<Connection>> connections;\n    std::mutex connections_mutex;\n\n    std::shared_ptr<ScopeRunner> handler_runner;\n\n    std::size_t concurrent_synchronous_requests = 0;\n    std::mutex concurrent_synchronous_requests_mutex;\n\n    ClientBase(const std::string &host_port, unsigned short default_port) noexcept : default_port(default_port), handler_runner(new ScopeRunner()) {\n      auto parsed_host_port = parse_host_port(host_port, default_port);\n      host = parsed_host_port.first;\n      port = parsed_host_port.second;\n    }\n\n    std::shared_ptr<Connection> get_connection() noexcept {\n      std::shared_ptr<Connection> connection;\n      std::unique_lock<std::mutex> lock(connections_mutex);\n\n      if(!io_service) {\n        io_service = std::make_shared<asio::io_service>();\n        internal_io_service = true;\n      }\n\n      for(auto it = connections.begin(); it != connections.end(); ++it) {\n        if(!(*it)->in_use && !connection) {\n          connection = *it;\n          break;\n        }\n      }\n      if(!connection) {\n        connection = create_connection();\n        connections.emplace(connection);\n      }\n      connection->attempt_reconnect = true;\n      connection->in_use = true;\n\n      if(!query) {\n        if(config.proxy_server.empty())\n          query = std::unique_ptr<asio::ip::tcp::resolver::query>(new asio::ip::tcp::resolver::query(host, std::to_string(port)));\n        else {\n          auto proxy_host_port = parse_host_port(config.proxy_server, 8080);\n          query = std::unique_ptr<asio::ip::tcp::resolver::query>(new asio::ip::tcp::resolver::query(proxy_host_port.first, std::to_string(proxy_host_port.second)));\n        }\n      }\n\n      return connection;\n    }\n\n    virtual std::shared_ptr<Connection> create_connection() noexcept = 0;\n    virtual void connect(const std::shared_ptr<Session> &) = 0;\n\n    std::unique_ptr<asio::streambuf> create_request_header(const std::string &method, const std::string &path, const CaseInsensitiveMultimap &header) const {\n      auto corrected_path = path;\n      if(corrected_path == \"\")\n        corrected_path = \"/\";\n      if(!config.proxy_server.empty() && std::is_same<socket_type, asio::ip::tcp::socket>::value)\n        corrected_path = \"http://\" + host + ':' + std::to_string(port) + corrected_path;\n\n      std::unique_ptr<asio::streambuf> streambuf(new asio::streambuf());\n      std::ostream write_stream(streambuf.get());\n      write_stream << method << \" \" << corrected_path << \" HTTP/1.1\\r\\n\";\n      write_stream << \"Host: \" << host;\n      if(port != default_port)\n        write_stream << ':' << std::to_string(port);\n      write_stream << \"\\r\\n\";\n      for(auto &h : header)\n        write_stream << h.first << \": \" << h.second << \"\\r\\n\";\n      return streambuf;\n    }\n\n    std::pair<std::string, unsigned short> parse_host_port(const std::string &host_port, unsigned short default_port) const noexcept {\n      std::pair<std::string, unsigned short> parsed_host_port;\n      std::size_t host_end = host_port.find(':');\n      if(host_end == std::string::npos) {\n        parsed_host_port.first = host_port;\n        parsed_host_port.second = default_port;\n      }\n      else {\n        parsed_host_port.first = host_port.substr(0, host_end);\n        parsed_host_port.second = static_cast<unsigned short>(stoul(host_port.substr(host_end + 1)));\n      }\n      return parsed_host_port;\n    }\n\n    void write(const std::shared_ptr<Session> &session) {\n      session->connection->set_timeout();\n      asio::async_write(*session->connection->socket, session->request_streambuf->data(), [this, session](const error_code &ec, std::size_t /*bytes_transferred*/) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        if(!ec)\n          this->read(session);\n        else\n          session->callback(session->connection, ec);\n      });\n    }\n\n    void read(const std::shared_ptr<Session> &session) {\n      session->connection->set_timeout();\n      asio::async_read_until(*session->connection->socket, session->response->streambuf, \"\\r\\n\\r\\n\", [this, session](const error_code &ec, std::size_t bytes_transferred) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        if((!ec || ec == asio::error::not_found) && session->response->streambuf.size() == session->response->streambuf.max_size()) {\n          session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n        if(!ec) {\n          session->connection->attempt_reconnect = true;\n          std::size_t num_additional_bytes = session->response->streambuf.size() - bytes_transferred;\n\n          if(!ResponseMessage::parse(session->response->content, session->response->http_version, session->response->status_code, session->response->header)) {\n            session->callback(session->connection, make_error_code::make_error_code(errc::protocol_error));\n            return;\n          }\n\n          auto header_it = session->response->header.find(\"Content-Length\");\n          if(header_it != session->response->header.end()) {\n            auto content_length = stoull(header_it->second);\n            if(content_length > num_additional_bytes) {\n              session->connection->set_timeout();\n              asio::async_read(*session->connection->socket, session->response->streambuf, asio::transfer_exactly(content_length - num_additional_bytes), [session](const error_code &ec, std::size_t /*bytes_transferred*/) {\n                session->connection->cancel_timeout();\n                auto lock = session->connection->handler_runner->continue_lock();\n                if(!lock)\n                  return;\n                if(!ec) {\n                  if(session->response->streambuf.size() == session->response->streambuf.max_size()) {\n                    session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n                    return;\n                  }\n                  session->callback(session->connection, ec);\n                }\n                else\n                  session->callback(session->connection, ec);\n              });\n            }\n            else\n              session->callback(session->connection, ec);\n          }\n          else if((header_it = session->response->header.find(\"Transfer-Encoding\")) != session->response->header.end() && header_it->second == \"chunked\") {\n            auto chunks_streambuf = std::make_shared<asio::streambuf>(this->config.max_response_streambuf_size);\n            this->read_chunked_transfer_encoded(session, chunks_streambuf);\n          }\n          else if(session->response->http_version < \"1.1\" || ((header_it = session->response->header.find(\"Session\")) != session->response->header.end() && header_it->second == \"close\")) {\n            session->connection->set_timeout();\n            asio::async_read(*session->connection->socket, session->response->streambuf, [session](const error_code &ec, std::size_t /*bytes_transferred*/) {\n              session->connection->cancel_timeout();\n              auto lock = session->connection->handler_runner->continue_lock();\n              if(!lock)\n                return;\n              if(!ec) {\n                if(session->response->streambuf.size() == session->response->streambuf.max_size()) {\n                  session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n                  return;\n                }\n                session->callback(session->connection, ec);\n              }\n              else\n                session->callback(session->connection, ec == asio::error::eof ? error_code() : ec);\n            });\n          }\n          else\n            session->callback(session->connection, ec);\n        }\n        else {\n          if(session->connection->attempt_reconnect && ec != asio::error::operation_aborted) {\n            std::unique_lock<std::mutex> lock(connections_mutex);\n            auto it = connections.find(session->connection);\n            if(it != connections.end()) {\n              connections.erase(it);\n              session->connection = create_connection();\n              session->connection->attempt_reconnect = false;\n              session->connection->in_use = true;\n              connections.emplace(session->connection);\n              lock.unlock();\n              this->connect(session);\n            }\n            else {\n              lock.unlock();\n              session->callback(session->connection, ec);\n            }\n          }\n          else\n            session->callback(session->connection, ec);\n        }\n      });\n    }\n\n    void read_chunked_transfer_encoded(const std::shared_ptr<Session> &session, const std::shared_ptr<asio::streambuf> &chunks_streambuf) {\n      session->connection->set_timeout();\n      asio::async_read_until(*session->connection->socket, session->response->streambuf, \"\\r\\n\", [this, session, chunks_streambuf](const error_code &ec, size_t bytes_transferred) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        if((!ec || ec == asio::error::not_found) && session->response->streambuf.size() == session->response->streambuf.max_size()) {\n          session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n        if(!ec) {\n          std::string line;\n          getline(session->response->content, line);\n          bytes_transferred -= line.size() + 1;\n          line.pop_back();\n          unsigned long length = 0;\n          try {\n            length = stoul(line, 0, 16);\n          }\n          catch(...) {\n            session->callback(session->connection, make_error_code::make_error_code(errc::protocol_error));\n            return;\n          }\n\n          auto num_additional_bytes = session->response->streambuf.size() - bytes_transferred;\n\n          if((2 + length) > num_additional_bytes) {\n            session->connection->set_timeout();\n            asio::async_read(*session->connection->socket, session->response->streambuf, asio::transfer_exactly(2 + length - num_additional_bytes), [this, session, chunks_streambuf, length](const error_code &ec, size_t /*bytes_transferred*/) {\n              session->connection->cancel_timeout();\n              auto lock = session->connection->handler_runner->continue_lock();\n              if(!lock)\n                return;\n              if(!ec) {\n                if(session->response->streambuf.size() == session->response->streambuf.max_size()) {\n                  session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n                  return;\n                }\n                this->read_chunked_transfer_encoded_chunk(session, chunks_streambuf, length);\n              }\n              else\n                session->callback(session->connection, ec);\n            });\n          }\n          else\n            this->read_chunked_transfer_encoded_chunk(session, chunks_streambuf, length);\n        }\n        else\n          session->callback(session->connection, ec);\n      });\n    }\n\n    void read_chunked_transfer_encoded_chunk(const std::shared_ptr<Session> &session, const std::shared_ptr<asio::streambuf> &chunks_streambuf, unsigned long length) {\n      std::ostream tmp_stream(chunks_streambuf.get());\n      if(length > 0) {\n        std::unique_ptr<char[]> buffer(new char[length]);\n        session->response->content.read(buffer.get(), static_cast<std::streamsize>(length));\n        tmp_stream.write(buffer.get(), static_cast<std::streamsize>(length));\n        if(chunks_streambuf->size() == chunks_streambuf->max_size()) {\n          session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n      }\n\n      // Remove \"\\r\\n\"\n      session->response->content.get();\n      session->response->content.get();\n\n      if(length > 0)\n        read_chunked_transfer_encoded(session, chunks_streambuf);\n      else {\n        if(chunks_streambuf->size() > 0) {\n          std::ostream ostream(&session->response->streambuf);\n          ostream << chunks_streambuf.get();\n        }\n        error_code ec;\n        session->callback(session->connection, ec);\n      }\n    }\n  };\n\n  template <class socket_type>\n  class Client : public ClientBase<socket_type> {};\n\n  using HTTP = asio::ip::tcp::socket;\n\n  template <>\n  class Client<HTTP> : public ClientBase<HTTP> {\n  public:\n    Client(const std::string &server_port_path) noexcept : ClientBase<HTTP>::ClientBase(server_port_path, 80) {}\n\n  protected:\n    std::shared_ptr<Connection> create_connection() noexcept override {\n      return std::make_shared<Connection>(handler_runner, config.timeout, *io_service);\n    }\n\n    void connect(const std::shared_ptr<Session> &session) override {\n      if(!session->connection->socket->lowest_layer().is_open()) {\n        auto resolver = std::make_shared<asio::ip::tcp::resolver>(*io_service);\n        session->connection->set_timeout(config.timeout_connect);\n        resolver->async_resolve(*query, [this, session, resolver](const error_code &ec, asio::ip::tcp::resolver::iterator it) {\n          session->connection->cancel_timeout();\n          auto lock = session->connection->handler_runner->continue_lock();\n          if(!lock)\n            return;\n          if(!ec) {\n            session->connection->set_timeout(config.timeout_connect);\n            asio::async_connect(*session->connection->socket, it, [this, session, resolver](const error_code &ec, asio::ip::tcp::resolver::iterator /*it*/) {\n              session->connection->cancel_timeout();\n              auto lock = session->connection->handler_runner->continue_lock();\n              if(!lock)\n                return;\n              if(!ec) {\n                asio::ip::tcp::no_delay option(true);\n                error_code ec;\n                session->connection->socket->set_option(option, ec);\n                this->write(session);\n              }\n              else\n                session->callback(session->connection, ec);\n            });\n          }\n          else\n            session->callback(session->connection, ec);\n        });\n      }\n      else\n        write(session);\n    }\n  };\n} // namespace SimpleWeb\n\n#endif /* CLIENT_HTTP_HPP */\n"
        },
        {
          "name": "client_https.hpp",
          "type": "blob",
          "size": 6.361328125,
          "content": "#ifndef CLIENT_HTTPS_HPP\n#define CLIENT_HTTPS_HPP\n\n#include \"client_http.hpp\"\n\n#ifdef USE_STANDALONE_ASIO\n#include <asio/ssl.hpp>\n#else\n#include <boost/asio/ssl.hpp>\n#endif\n\nnamespace SimpleWeb {\n  using HTTPS = asio::ssl::stream<asio::ip::tcp::socket>;\n\n  template <>\n  class Client<HTTPS> : public ClientBase<HTTPS> {\n  public:\n    Client(const std::string &server_port_path, bool verify_certificate = true, const std::string &cert_file = std::string(),\n           const std::string &private_key_file = std::string(), const std::string &verify_file = std::string())\n        : ClientBase<HTTPS>::ClientBase(server_port_path, 443), context(asio::ssl::context::tlsv12) {\n      if(cert_file.size() > 0 && private_key_file.size() > 0) {\n        context.use_certificate_chain_file(cert_file);\n        context.use_private_key_file(private_key_file, asio::ssl::context::pem);\n      }\n\n      if(verify_certificate)\n        context.set_verify_callback(asio::ssl::rfc2818_verification(host));\n\n      if(verify_file.size() > 0)\n        context.load_verify_file(verify_file);\n      else\n        context.set_default_verify_paths();\n\n      if(verify_file.size() > 0 || verify_certificate)\n        context.set_verify_mode(asio::ssl::verify_peer);\n      else\n        context.set_verify_mode(asio::ssl::verify_none);\n    }\n\n  protected:\n    asio::ssl::context context;\n\n    std::shared_ptr<Connection> create_connection() noexcept override {\n      return std::make_shared<Connection>(handler_runner, config.timeout, *io_service, context);\n    }\n\n    void connect(const std::shared_ptr<Session> &session) override {\n      if(!session->connection->socket->lowest_layer().is_open()) {\n        auto resolver = std::make_shared<asio::ip::tcp::resolver>(*io_service);\n        resolver->async_resolve(*query, [this, session, resolver](const error_code &ec, asio::ip::tcp::resolver::iterator it) {\n          auto lock = session->connection->handler_runner->continue_lock();\n          if(!lock)\n            return;\n          if(!ec) {\n            session->connection->set_timeout(this->config.timeout_connect);\n            asio::async_connect(session->connection->socket->lowest_layer(), it, [this, session, resolver](const error_code &ec, asio::ip::tcp::resolver::iterator /*it*/) {\n              session->connection->cancel_timeout();\n              auto lock = session->connection->handler_runner->continue_lock();\n              if(!lock)\n                return;\n              if(!ec) {\n                asio::ip::tcp::no_delay option(true);\n                error_code ec;\n                session->connection->socket->lowest_layer().set_option(option, ec);\n\n                if(!this->config.proxy_server.empty()) {\n                  auto write_buffer = std::make_shared<asio::streambuf>();\n                  std::ostream write_stream(write_buffer.get());\n                  auto host_port = this->host + ':' + std::to_string(this->port);\n                  write_stream << \"CONNECT \" + host_port + \" HTTP/1.1\\r\\n\"\n                               << \"Host: \" << host_port << \"\\r\\n\\r\\n\";\n                  session->connection->set_timeout(this->config.timeout_connect);\n                  asio::async_write(session->connection->socket->next_layer(), *write_buffer, [this, session, write_buffer](const error_code &ec, std::size_t /*bytes_transferred*/) {\n                    session->connection->cancel_timeout();\n                    auto lock = session->connection->handler_runner->continue_lock();\n                    if(!lock)\n                      return;\n                    if(!ec) {\n                      std::shared_ptr<Response> response(new Response(this->config.max_response_streambuf_size));\n                      session->connection->set_timeout(this->config.timeout_connect);\n                      asio::async_read_until(session->connection->socket->next_layer(), response->streambuf, \"\\r\\n\\r\\n\", [this, session, response](const error_code &ec, std::size_t /*bytes_transferred*/) {\n                        session->connection->cancel_timeout();\n                        auto lock = session->connection->handler_runner->continue_lock();\n                        if(!lock)\n                          return;\n                        if((!ec || ec == asio::error::not_found) && response->streambuf.size() == response->streambuf.max_size()) {\n                          session->callback(session->connection, make_error_code::make_error_code(errc::message_size));\n                          return;\n                        }\n                        if(!ec) {\n                          if(!ResponseMessage::parse(response->content, response->http_version, response->status_code, response->header))\n                            session->callback(session->connection, make_error_code::make_error_code(errc::protocol_error));\n                          else {\n                            if(response->status_code.empty() || response->status_code.compare(0, 3, \"200\") != 0)\n                              session->callback(session->connection, make_error_code::make_error_code(errc::permission_denied));\n                            else\n                              this->handshake(session);\n                          }\n                        }\n                        else\n                          session->callback(session->connection, ec);\n                      });\n                    }\n                    else\n                      session->callback(session->connection, ec);\n                  });\n                }\n                else\n                  this->handshake(session);\n              }\n              else\n                session->callback(session->connection, ec);\n            });\n          }\n          else\n            session->callback(session->connection, ec);\n        });\n      }\n      else\n        write(session);\n    }\n\n    void handshake(const std::shared_ptr<Session> &session) {\n      SSL_set_tlsext_host_name(session->connection->socket->native_handle(), this->host.c_str());\n\n      session->connection->set_timeout(this->config.timeout_connect);\n      session->connection->socket->async_handshake(asio::ssl::stream_base::client, [this, session](const error_code &ec) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        if(!ec)\n          this->write(session);\n        else\n          session->callback(session->connection, ec);\n      });\n    }\n  };\n} // namespace SimpleWeb\n\n#endif /* CLIENT_HTTPS_HPP */\n"
        },
        {
          "name": "crypto.hpp",
          "type": "blob",
          "size": 8.091796875,
          "content": "#ifndef SIMPLE_WEB_CRYPTO_HPP\n#define SIMPLE_WEB_CRYPTO_HPP\n\n#include <cmath>\n#include <iomanip>\n#include <istream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include <openssl/buffer.h>\n#include <openssl/evp.h>\n#include <openssl/md5.h>\n#include <openssl/sha.h>\n\nnamespace SimpleWeb {\n// TODO 2017: remove workaround for MSVS 2012\n#if _MSC_VER == 1700                       // MSVS 2012 has no definition for round()\n  inline double round(double x) noexcept { // Custom definition of round() for positive numbers\n    return floor(x + 0.5);\n  }\n#endif\n\n  class Crypto {\n    const static std::size_t buffer_size = 131072;\n\n  public:\n    class Base64 {\n    public:\n      static std::string encode(const std::string &ascii) noexcept {\n        std::string base64;\n\n        BIO *bio, *b64;\n        BUF_MEM *bptr = BUF_MEM_new();\n\n        b64 = BIO_new(BIO_f_base64());\n        BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n        bio = BIO_new(BIO_s_mem());\n        BIO_push(b64, bio);\n        BIO_set_mem_buf(b64, bptr, BIO_CLOSE);\n\n        // Write directly to base64-buffer to avoid copy\n        auto base64_length = static_cast<std::size_t>(round(4 * ceil(static_cast<double>(ascii.size()) / 3.0)));\n        base64.resize(base64_length);\n        bptr->length = 0;\n        bptr->max = base64_length + 1;\n        bptr->data = &base64[0];\n\n        if(BIO_write(b64, &ascii[0], static_cast<int>(ascii.size())) <= 0 || BIO_flush(b64) <= 0)\n          base64.clear();\n\n        // To keep &base64[0] through BIO_free_all(b64)\n        bptr->length = 0;\n        bptr->max = 0;\n        bptr->data = nullptr;\n\n        BIO_free_all(b64);\n\n        return base64;\n      }\n\n      static std::string decode(const std::string &base64) noexcept {\n        std::string ascii;\n\n        // Resize ascii, however, the size is a up to two bytes too large.\n        ascii.resize((6 * base64.size()) / 8);\n        BIO *b64, *bio;\n\n        b64 = BIO_new(BIO_f_base64());\n        BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n// TODO: Remove in 2020\n#if OPENSSL_VERSION_NUMBER <= 0x1000115fL\n        bio = BIO_new_mem_buf((char *)&base64[0], static_cast<int>(base64.size()));\n#else\n        bio = BIO_new_mem_buf(&base64[0], static_cast<int>(base64.size()));\n#endif\n        bio = BIO_push(b64, bio);\n\n        auto decoded_length = BIO_read(bio, &ascii[0], static_cast<int>(ascii.size()));\n        if(decoded_length > 0)\n          ascii.resize(static_cast<std::size_t>(decoded_length));\n        else\n          ascii.clear();\n\n        BIO_free_all(b64);\n\n        return ascii;\n      }\n    };\n\n    /// Return hex string from bytes in input string.\n    static std::string to_hex_string(const std::string &input) noexcept {\n      std::stringstream hex_stream;\n      hex_stream << std::hex << std::internal << std::setfill('0');\n      for(auto &byte : input)\n        hex_stream << std::setw(2) << static_cast<int>(static_cast<unsigned char>(byte));\n      return hex_stream.str();\n    }\n\n    static std::string md5(const std::string &input, std::size_t iterations = 1) noexcept {\n      std::string hash;\n\n      hash.resize(128 / 8);\n      MD5(reinterpret_cast<const unsigned char *>(&input[0]), input.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        MD5(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string md5(std::istream &stream, std::size_t iterations = 1) noexcept {\n      MD5_CTX context;\n      MD5_Init(&context);\n      std::streamsize read_length;\n      std::vector<char> buffer(buffer_size);\n      while((read_length = stream.read(&buffer[0], buffer_size).gcount()) > 0)\n        MD5_Update(&context, buffer.data(), static_cast<std::size_t>(read_length));\n      std::string hash;\n      hash.resize(128 / 8);\n      MD5_Final(reinterpret_cast<unsigned char *>(&hash[0]), &context);\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        MD5(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha1(const std::string &input, std::size_t iterations = 1) noexcept {\n      std::string hash;\n\n      hash.resize(160 / 8);\n      SHA1(reinterpret_cast<const unsigned char *>(&input[0]), input.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA1(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha1(std::istream &stream, std::size_t iterations = 1) noexcept {\n      SHA_CTX context;\n      SHA1_Init(&context);\n      std::streamsize read_length;\n      std::vector<char> buffer(buffer_size);\n      while((read_length = stream.read(&buffer[0], buffer_size).gcount()) > 0)\n        SHA1_Update(&context, buffer.data(), static_cast<std::size_t>(read_length));\n      std::string hash;\n      hash.resize(160 / 8);\n      SHA1_Final(reinterpret_cast<unsigned char *>(&hash[0]), &context);\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA1(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha256(const std::string &input, std::size_t iterations = 1) noexcept {\n      std::string hash;\n\n      hash.resize(256 / 8);\n      SHA256(reinterpret_cast<const unsigned char *>(&input[0]), input.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA256(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha256(std::istream &stream, std::size_t iterations = 1) noexcept {\n      SHA256_CTX context;\n      SHA256_Init(&context);\n      std::streamsize read_length;\n      std::vector<char> buffer(buffer_size);\n      while((read_length = stream.read(&buffer[0], buffer_size).gcount()) > 0)\n        SHA256_Update(&context, buffer.data(), static_cast<std::size_t>(read_length));\n      std::string hash;\n      hash.resize(256 / 8);\n      SHA256_Final(reinterpret_cast<unsigned char *>(&hash[0]), &context);\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA256(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha512(const std::string &input, std::size_t iterations = 1) noexcept {\n      std::string hash;\n\n      hash.resize(512 / 8);\n      SHA512(reinterpret_cast<const unsigned char *>(&input[0]), input.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA512(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    static std::string sha512(std::istream &stream, std::size_t iterations = 1) noexcept {\n      SHA512_CTX context;\n      SHA512_Init(&context);\n      std::streamsize read_length;\n      std::vector<char> buffer(buffer_size);\n      while((read_length = stream.read(&buffer[0], buffer_size).gcount()) > 0)\n        SHA512_Update(&context, buffer.data(), static_cast<std::size_t>(read_length));\n      std::string hash;\n      hash.resize(512 / 8);\n      SHA512_Final(reinterpret_cast<unsigned char *>(&hash[0]), &context);\n\n      for(std::size_t c = 1; c < iterations; ++c)\n        SHA512(reinterpret_cast<const unsigned char *>(&hash[0]), hash.size(), reinterpret_cast<unsigned char *>(&hash[0]));\n\n      return hash;\n    }\n\n    /// key_size is number of bytes of the returned key.\n    static std::string pbkdf2(const std::string &password, const std::string &salt, int iterations, int key_size) noexcept {\n      std::string key;\n      key.resize(static_cast<std::size_t>(key_size));\n      PKCS5_PBKDF2_HMAC_SHA1(password.c_str(), password.size(),\n                             reinterpret_cast<const unsigned char *>(salt.c_str()), salt.size(), iterations,\n                             key_size, reinterpret_cast<unsigned char *>(&key[0]));\n      return key;\n    }\n  };\n}\n#endif /* SIMPLE_WEB_CRYPTO_HPP */\n"
        },
        {
          "name": "http_examples.cpp",
          "type": "blob",
          "size": 8.8828125,
          "content": "#include \"client_http.hpp\"\n#include \"server_http.hpp\"\n\n// Added for the json-example\n#define BOOST_SPIRIT_THREADSAFE\n#include <boost/property_tree/json_parser.hpp>\n#include <boost/property_tree/ptree.hpp>\n\n// Added for the default_resource example\n#include <algorithm>\n#include <boost/filesystem.hpp>\n#include <fstream>\n#include <vector>\n#ifdef HAVE_OPENSSL\n#include \"crypto.hpp\"\n#endif\n\nusing namespace std;\n// Added for the json-example:\nusing namespace boost::property_tree;\n\nusing HttpServer = SimpleWeb::Server<SimpleWeb::HTTP>;\nusing HttpClient = SimpleWeb::Client<SimpleWeb::HTTP>;\n\nint main() {\n  // HTTP-server at port 8080 using 1 thread\n  // Unless you do more heavy non-threaded processing in the resources,\n  // 1 thread is usually faster than several threads\n  HttpServer server;\n  server.config.port = 8080;\n\n  // Add resources using path-regex and method-string, and an anonymous function\n  // POST-example for the path /string, responds the posted string\n  server.resource[\"^/string$\"][\"POST\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> request) {\n    // Retrieve string:\n    auto content = request->content.string();\n    // request->content.string() is a convenience function for:\n    // stringstream ss;\n    // ss << request->content.rdbuf();\n    // auto content=ss.str();\n\n    *response << \"HTTP/1.1 200 OK\\r\\nContent-Length: \" << content.length() << \"\\r\\n\\r\\n\"\n              << content;\n\n\n    // Alternatively, use one of the convenience functions, for instance:\n    // response->write(content);\n  };\n\n  // POST-example for the path /json, responds firstName+\" \"+lastName from the posted json\n  // Responds with an appropriate error message if the posted json is not valid, or if firstName or lastName is missing\n  // Example posted json:\n  // {\n  //   \"firstName\": \"John\",\n  //   \"lastName\": \"Smith\",\n  //   \"age\": 25\n  // }\n  server.resource[\"^/json$\"][\"POST\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> request) {\n    try {\n      ptree pt;\n      read_json(request->content, pt);\n\n      auto name = pt.get<string>(\"firstName\") + \" \" + pt.get<string>(\"lastName\");\n\n      *response << \"HTTP/1.1 200 OK\\r\\n\"\n                << \"Content-Length: \" << name.length() << \"\\r\\n\\r\\n\"\n                << name;\n    }\n    catch(const exception &e) {\n      *response << \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: \" << strlen(e.what()) << \"\\r\\n\\r\\n\"\n                << e.what();\n    }\n\n\n    // Alternatively, using a convenience function:\n    // try {\n    //     ptree pt;\n    //     read_json(request->content, pt);\n\n    //     auto name=pt.get<string>(\"firstName\")+\" \"+pt.get<string>(\"lastName\");\n    //     response->write(name);\n    // }\n    // catch(const exception &e) {\n    //     response->write(SimpleWeb::StatusCode::client_error_bad_request, e.what());\n    // }\n  };\n\n  // GET-example for the path /info\n  // Responds with request-information\n  server.resource[\"^/info$\"][\"GET\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> request) {\n    stringstream stream;\n    stream << \"<h1>Request from \" << request->remote_endpoint_address() << \":\" << request->remote_endpoint_port() << \"</h1>\";\n\n    stream << request->method << \" \" << request->path << \" HTTP/\" << request->http_version;\n\n    stream << \"<h2>Query Fields</h2>\";\n    auto query_fields = request->parse_query_string();\n    for(auto &field : query_fields)\n      stream << field.first << \": \" << field.second << \"<br>\";\n\n    stream << \"<h2>Header Fields</h2>\";\n    for(auto &field : request->header)\n      stream << field.first << \": \" << field.second << \"<br>\";\n\n    response->write(stream);\n  };\n\n  // GET-example for the path /match/[number], responds with the matched string in path (number)\n  // For instance a request GET /match/123 will receive: 123\n  server.resource[\"^/match/([0-9]+)$\"][\"GET\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> request) {\n    response->write(request->path_match[1]);\n  };\n\n  // GET-example simulating heavy work in a separate thread\n  server.resource[\"^/work$\"][\"GET\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> /*request*/) {\n    thread work_thread([response] {\n      this_thread::sleep_for(chrono::seconds(5));\n      response->write(\"Work done\");\n    });\n    work_thread.detach();\n  };\n\n  // Default GET-example. If no other matches, this anonymous function will be called.\n  // Will respond with content in the web/-directory, and its subdirectories.\n  // Default file: index.html\n  // Can for instance be used to retrieve an HTML 5 client that uses REST-resources on this server\n  server.default_resource[\"GET\"] = [](shared_ptr<HttpServer::Response> response, shared_ptr<HttpServer::Request> request) {\n    try {\n      auto web_root_path = boost::filesystem::canonical(\"web\");\n      auto path = boost::filesystem::canonical(web_root_path / request->path);\n      // Check if path is within web_root_path\n      if(distance(web_root_path.begin(), web_root_path.end()) > distance(path.begin(), path.end()) ||\n         !equal(web_root_path.begin(), web_root_path.end(), path.begin()))\n        throw invalid_argument(\"path must be within root path\");\n      if(boost::filesystem::is_directory(path))\n        path /= \"index.html\";\n\n      SimpleWeb::CaseInsensitiveMultimap header;\n\n      // Uncomment the following line to enable Cache-Control\n      // header.emplace(\"Cache-Control\", \"max-age=86400\");\n\n#ifdef HAVE_OPENSSL\n//    Uncomment the following lines to enable ETag\n//    {\n//      ifstream ifs(path.string(), ifstream::in | ios::binary);\n//      if(ifs) {\n//        auto hash = SimpleWeb::Crypto::to_hex_string(SimpleWeb::Crypto::md5(ifs));\n//        header.emplace(\"ETag\", \"\\\"\" + hash + \"\\\"\");\n//        auto it = request->header.find(\"If-None-Match\");\n//        if(it != request->header.end()) {\n//          if(!it->second.empty() && it->second.compare(1, hash.size(), hash) == 0) {\n//            response->write(SimpleWeb::StatusCode::redirection_not_modified, header);\n//            return;\n//          }\n//        }\n//      }\n//      else\n//        throw invalid_argument(\"could not read file\");\n//    }\n#endif\n\n      auto ifs = make_shared<ifstream>();\n      ifs->open(path.string(), ifstream::in | ios::binary | ios::ate);\n\n      if(*ifs) {\n        auto length = ifs->tellg();\n        ifs->seekg(0, ios::beg);\n\n        header.emplace(\"Content-Length\", to_string(length));\n        response->write(header);\n\n        // Trick to define a recursive function within this scope (for example purposes)\n        class FileServer {\n        public:\n          static void read_and_send(const shared_ptr<HttpServer::Response> &response, const shared_ptr<ifstream> &ifs) {\n            // Read and send 128 KB at a time\n            static vector<char> buffer(131072); // Safe when server is running on one thread\n            streamsize read_length;\n            if((read_length = ifs->read(&buffer[0], static_cast<streamsize>(buffer.size())).gcount()) > 0) {\n              response->write(&buffer[0], read_length);\n              if(read_length == static_cast<streamsize>(buffer.size())) {\n                response->send([response, ifs](const SimpleWeb::error_code &ec) {\n                  if(!ec)\n                    read_and_send(response, ifs);\n                  else\n                    cerr << \"Connection interrupted\" << endl;\n                });\n              }\n            }\n          }\n        };\n        FileServer::read_and_send(response, ifs);\n      }\n      else\n        throw invalid_argument(\"could not read file\");\n    }\n    catch(const exception &e) {\n      response->write(SimpleWeb::StatusCode::client_error_bad_request, \"Could not open path \" + request->path + \": \" + e.what());\n    }\n  };\n\n  server.on_error = [](shared_ptr<HttpServer::Request> /*request*/, const SimpleWeb::error_code & /*ec*/) {\n    // Handle errors here\n    // Note that connection timeouts will also call this handle with ec set to SimpleWeb::errc::operation_canceled\n  };\n\n  thread server_thread([&server]() {\n    // Start server\n    server.start();\n  });\n\n  // Wait for server to start so that the client can connect\n  this_thread::sleep_for(chrono::seconds(1));\n\n  // Client examples\n  HttpClient client(\"localhost:8080\");\n\n  string json_string = \"{\\\"firstName\\\": \\\"John\\\",\\\"lastName\\\": \\\"Smith\\\",\\\"age\\\": 25}\";\n\n  // Synchronous request examples\n  try {\n    auto r1 = client.request(\"GET\", \"/match/123\");\n    cout << r1->content.rdbuf() << endl; // Alternatively, use the convenience function r1->content.string()\n\n    auto r2 = client.request(\"POST\", \"/string\", json_string);\n    cout << r2->content.rdbuf() << endl;\n  }\n  catch(const SimpleWeb::system_error &e) {\n    cerr << \"Client request error: \" << e.what() << endl;\n  }\n\n  // Asynchronous request example\n  client.request(\"POST\", \"/json\", json_string, [](shared_ptr<HttpClient::Response> response, const SimpleWeb::error_code &ec) {\n    if(!ec)\n      cout << response->content.rdbuf() << endl;\n  });\n  client.io_service->run();\n\n  server_thread.join();\n}\n"
        },
        {
          "name": "https_examples.cpp",
          "type": "blob",
          "size": 8.9853515625,
          "content": "#include \"client_https.hpp\"\n#include \"server_https.hpp\"\n\n// Added for the json-example\n#define BOOST_SPIRIT_THREADSAFE\n#include <boost/property_tree/json_parser.hpp>\n#include <boost/property_tree/ptree.hpp>\n\n// Added for the default_resource example\n#include \"crypto.hpp\"\n#include <algorithm>\n#include <boost/filesystem.hpp>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n// Added for the json-example:\nusing namespace boost::property_tree;\n\nusing HttpsServer = SimpleWeb::Server<SimpleWeb::HTTPS>;\nusing HttpsClient = SimpleWeb::Client<SimpleWeb::HTTPS>;\n\nint main() {\n  // HTTPS-server at port 8080 using 1 thread\n  // Unless you do more heavy non-threaded processing in the resources,\n  // 1 thread is usually faster than several threads\n  HttpsServer server(\"server.crt\", \"server.key\");\n  server.config.port = 8080;\n\n  // Add resources using path-regex and method-string, and an anonymous function\n  // POST-example for the path /string, responds the posted string\n  server.resource[\"^/string$\"][\"POST\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> request) {\n    // Retrieve string:\n    auto content = request->content.string();\n    // request->content.string() is a convenience function for:\n    // stringstream ss;\n    // ss << request->content.rdbuf();\n    // auto content=ss.str();\n\n    *response << \"HTTP/1.1 200 OK\\r\\nContent-Length: \" << content.length() << \"\\r\\n\\r\\n\"\n              << content;\n\n\n    // Alternatively, use one of the convenience functions, for instance:\n    // response->write(content);\n  };\n\n  // POST-example for the path /json, responds firstName+\" \"+lastName from the posted json\n  // Responds with an appropriate error message if the posted json is not valid, or if firstName or lastName is missing\n  // Example posted json:\n  // {\n  //   \"firstName\": \"John\",\n  //   \"lastName\": \"Smith\",\n  //   \"age\": 25\n  // }\n  server.resource[\"^/json$\"][\"POST\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> request) {\n    try {\n      ptree pt;\n      read_json(request->content, pt);\n\n      auto name = pt.get<string>(\"firstName\") + \" \" + pt.get<string>(\"lastName\");\n\n      *response << \"HTTP/1.1 200 OK\\r\\n\"\n                << \"Content-Length: \" << name.length() << \"\\r\\n\\r\\n\"\n                << name;\n    }\n    catch(const exception &e) {\n      *response << \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: \" << strlen(e.what()) << \"\\r\\n\\r\\n\"\n                << e.what();\n    }\n\n\n    // Alternatively, using a convenience function:\n    // try {\n    //     ptree pt;\n    //     read_json(request->content, pt);\n\n    //     auto name=pt.get<string>(\"firstName\")+\" \"+pt.get<string>(\"lastName\");\n    //     response->write(name);\n    // }\n    // catch(const exception &e) {\n    //     response->write(SimpleWeb::StatusCode::client_error_bad_request, e.what());\n    // }\n  };\n\n  // GET-example for the path /info\n  // Responds with request-information\n  server.resource[\"^/info$\"][\"GET\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> request) {\n    stringstream stream;\n    stream << \"<h1>Request from \" << request->remote_endpoint_address() << \":\" << request->remote_endpoint_port() << \"</h1>\";\n\n    stream << request->method << \" \" << request->path << \" HTTP/\" << request->http_version;\n\n    stream << \"<h2>Query Fields</h2>\";\n    auto query_fields = request->parse_query_string();\n    for(auto &field : query_fields)\n      stream << field.first << \": \" << field.second << \"<br>\";\n\n    stream << \"<h2>Header Fields</h2>\";\n    for(auto &field : request->header)\n      stream << field.first << \": \" << field.second << \"<br>\";\n\n    response->write(stream);\n  };\n\n  // GET-example for the path /match/[number], responds with the matched string in path (number)\n  // For instance a request GET /match/123 will receive: 123\n  server.resource[\"^/match/([0-9]+)$\"][\"GET\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> request) {\n    response->write(request->path_match[1]);\n  };\n\n  // GET-example simulating heavy work in a separate thread\n  server.resource[\"^/work$\"][\"GET\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> /*request*/) {\n    thread work_thread([response] {\n      this_thread::sleep_for(chrono::seconds(5));\n      response->write(\"Work done\");\n    });\n    work_thread.detach();\n  };\n\n  // Default GET-example. If no other matches, this anonymous function will be called.\n  // Will respond with content in the web/-directory, and its subdirectories.\n  // Default file: index.html\n  // Can for instance be used to retrieve an HTML 5 client that uses REST-resources on this server\n  server.default_resource[\"GET\"] = [](shared_ptr<HttpsServer::Response> response, shared_ptr<HttpsServer::Request> request) {\n    try {\n      auto web_root_path = boost::filesystem::canonical(\"web\");\n      auto path = boost::filesystem::canonical(web_root_path / request->path);\n      // Check if path is within web_root_path\n      if(distance(web_root_path.begin(), web_root_path.end()) > distance(path.begin(), path.end()) ||\n         !equal(web_root_path.begin(), web_root_path.end(), path.begin()))\n        throw invalid_argument(\"path must be within root path\");\n      if(boost::filesystem::is_directory(path))\n        path /= \"index.html\";\n\n      SimpleWeb::CaseInsensitiveMultimap header;\n\n      // Uncomment the following line to enable Cache-Control\n      // header.emplace(\"Cache-Control\", \"max-age=86400\");\n\n#ifdef HAVE_OPENSSL\n//    Uncomment the following lines to enable ETag\n//    {\n//      ifstream ifs(path.string(), ifstream::in | ios::binary);\n//      if(ifs) {\n//        auto hash = SimpleWeb::Crypto::to_hex_string(SimpleWeb::Crypto::md5(ifs));\n//        header.emplace(\"ETag\", \"\\\"\" + hash + \"\\\"\");\n//        auto it = request->header.find(\"If-None-Match\");\n//        if(it != request->header.end()) {\n//          if(!it->second.empty() && it->second.compare(1, hash.size(), hash) == 0) {\n//            response->write(SimpleWeb::StatusCode::redirection_not_modified, header);\n//            return;\n//          }\n//        }\n//      }\n//      else\n//        throw invalid_argument(\"could not read file\");\n//    }\n#endif\n\n      auto ifs = make_shared<ifstream>();\n      ifs->open(path.string(), ifstream::in | ios::binary | ios::ate);\n\n      if(*ifs) {\n        auto length = ifs->tellg();\n        ifs->seekg(0, ios::beg);\n\n        header.emplace(\"Content-Length\", to_string(length));\n        response->write(header);\n\n        // Trick to define a recursive function within this scope (for example purposes)\n        class FileServer {\n        public:\n          static void read_and_send(const shared_ptr<HttpsServer::Response> &response, const shared_ptr<ifstream> &ifs) {\n            // Read and send 128 KB at a time\n            static vector<char> buffer(131072); // Safe when server is running on one thread\n            streamsize read_length;\n            if((read_length = ifs->read(&buffer[0], static_cast<streamsize>(buffer.size())).gcount()) > 0) {\n              response->write(&buffer[0], read_length);\n              if(read_length == static_cast<streamsize>(buffer.size())) {\n                response->send([response, ifs](const SimpleWeb::error_code &ec) {\n                  if(!ec)\n                    read_and_send(response, ifs);\n                  else\n                    cerr << \"Connection interrupted\" << endl;\n                });\n              }\n            }\n          }\n        };\n        FileServer::read_and_send(response, ifs);\n      }\n      else\n        throw invalid_argument(\"could not read file\");\n    }\n    catch(const exception &e) {\n      response->write(SimpleWeb::StatusCode::client_error_bad_request, \"Could not open path \" + request->path + \": \" + e.what());\n    }\n  };\n\n  server.on_error = [](shared_ptr<HttpsServer::Request> /*request*/, const SimpleWeb::error_code & /*ec*/) {\n    // Handle errors here\n    // Note that connection timeouts will also call this handle with ec set to SimpleWeb::errc::operation_canceled\n  };\n\n  thread server_thread([&server]() {\n    // Start server\n    server.start();\n  });\n\n  // Wait for server to start so that the client can connect\n  this_thread::sleep_for(chrono::seconds(1));\n\n  // Client examples\n  // Second create() parameter set to false: no certificate verification\n  HttpsClient client(\"localhost:8080\", false);\n\n  string json_string = \"{\\\"firstName\\\": \\\"John\\\",\\\"lastName\\\": \\\"Smith\\\",\\\"age\\\": 25}\";\n\n  // Synchronous request examples\n  try {\n    auto r1 = client.request(\"GET\", \"/match/123\");\n    cout << r1->content.rdbuf() << endl; // Alternatively, use the convenience function r1->content.string()\n\n    auto r2 = client.request(\"POST\", \"/string\", json_string);\n    cout << r2->content.rdbuf() << endl;\n  }\n  catch(const SimpleWeb::system_error &e) {\n    cerr << \"Client request error: \" << e.what() << endl;\n  }\n\n  // Asynchronous request example\n  client.request(\"POST\", \"/json\", json_string, [](shared_ptr<HttpsClient::Response> response, const SimpleWeb::error_code &ec) {\n    if(!ec)\n      cout << response->content.rdbuf() << endl;\n  });\n  client.io_service->run();\n\n  server_thread.join();\n}\n"
        },
        {
          "name": "server_http.hpp",
          "type": "blob",
          "size": 29.0068359375,
          "content": "#ifndef SERVER_HTTP_HPP\n#define SERVER_HTTP_HPP\n\n#include \"utility.hpp\"\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <mutex>\n#include <sstream>\n#include <thread>\n#include <unordered_set>\n\n#ifdef USE_STANDALONE_ASIO\n#include <asio.hpp>\n#include <asio/steady_timer.hpp>\nnamespace SimpleWeb {\n  using error_code = std::error_code;\n  using errc = std::errc;\n  namespace make_error_code = std;\n} // namespace SimpleWeb\n#else\n#include <boost/asio.hpp>\n#include <boost/asio/steady_timer.hpp>\nnamespace SimpleWeb {\n  namespace asio = boost::asio;\n  using error_code = boost::system::error_code;\n  namespace errc = boost::system::errc;\n  namespace make_error_code = boost::system::errc;\n} // namespace SimpleWeb\n#endif\n\n// Late 2017 TODO: remove the following checks and always use std::regex\n#ifdef USE_BOOST_REGEX\n#include <boost/regex.hpp>\nnamespace SimpleWeb {\n  namespace regex = boost;\n}\n#else\n#include <regex>\nnamespace SimpleWeb {\n  namespace regex = std;\n}\n#endif\n\nnamespace SimpleWeb {\n  template <class socket_type>\n  class Server;\n\n  template <class socket_type>\n  class ServerBase {\n  protected:\n    class Session;\n\n  public:\n    class Response : public std::enable_shared_from_this<Response>, public std::ostream {\n      friend class ServerBase<socket_type>;\n      friend class Server<socket_type>;\n\n      asio::streambuf streambuf;\n\n      std::shared_ptr<Session> session;\n      long timeout_content;\n\n      Response(std::shared_ptr<Session> session, long timeout_content) noexcept : std::ostream(&streambuf), session(std::move(session)), timeout_content(timeout_content) {}\n\n      template <typename size_type>\n      void write_header(const CaseInsensitiveMultimap &header, size_type size) {\n        bool content_length_written = false;\n        bool chunked_transfer_encoding = false;\n        for(auto &field : header) {\n          if(!content_length_written && case_insensitive_equal(field.first, \"content-length\"))\n            content_length_written = true;\n          else if(!chunked_transfer_encoding && case_insensitive_equal(field.first, \"transfer-encoding\") && case_insensitive_equal(field.second, \"chunked\"))\n            chunked_transfer_encoding = true;\n\n          *this << field.first << \": \" << field.second << \"\\r\\n\";\n        }\n        if(!content_length_written && !chunked_transfer_encoding && !close_connection_after_response)\n          *this << \"Content-Length: \" << size << \"\\r\\n\\r\\n\";\n        else\n          *this << \"\\r\\n\";\n      }\n\n    public:\n      std::size_t size() noexcept {\n        return streambuf.size();\n      }\n\n      /// Use this function if you need to recursively send parts of a longer message\n      void send(const std::function<void(const error_code &)> &callback = nullptr) noexcept {\n        session->connection->set_timeout(timeout_content);\n        auto self = this->shared_from_this(); // Keep Response instance alive through the following async_write\n        asio::async_write(*session->connection->socket, streambuf, [self, callback](const error_code &ec, std::size_t /*bytes_transferred*/) {\n          self->session->connection->cancel_timeout();\n          auto lock = self->session->connection->handler_runner->continue_lock();\n          if(!lock)\n            return;\n          if(callback)\n            callback(ec);\n        });\n      }\n\n      /// Write directly to stream buffer using std::ostream::write\n      void write(const char_type *ptr, std::streamsize n) {\n        std::ostream::write(ptr, n);\n      }\n\n      /// Convenience function for writing status line, potential header fields, and empty content\n      void write(StatusCode status_code = StatusCode::success_ok, const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n        *this << \"HTTP/1.1 \" << SimpleWeb::status_code(status_code) << \"\\r\\n\";\n        write_header(header, 0);\n      }\n\n      /// Convenience function for writing status line, header fields, and content\n      void write(StatusCode status_code, const std::string &content, const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n        *this << \"HTTP/1.1 \" << SimpleWeb::status_code(status_code) << \"\\r\\n\";\n        write_header(header, content.size());\n        if(!content.empty())\n          *this << content;\n      }\n\n      /// Convenience function for writing status line, header fields, and content\n      void write(StatusCode status_code, std::istream &content, const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n        *this << \"HTTP/1.1 \" << SimpleWeb::status_code(status_code) << \"\\r\\n\";\n        content.seekg(0, std::ios::end);\n        auto size = content.tellg();\n        content.seekg(0, std::ios::beg);\n        write_header(header, size);\n        if(size)\n          *this << content.rdbuf();\n      }\n\n      /// Convenience function for writing success status line, header fields, and content\n      void write(const std::string &content, const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n        write(StatusCode::success_ok, content, header);\n      }\n\n      /// Convenience function for writing success status line, header fields, and content\n      void write(std::istream &content, const CaseInsensitiveMultimap &header = CaseInsensitiveMultimap()) {\n        write(StatusCode::success_ok, content, header);\n      }\n\n      /// Convenience function for writing success status line, and header fields\n      void write(const CaseInsensitiveMultimap &header) {\n        write(StatusCode::success_ok, std::string(), header);\n      }\n\n      /// If true, force server to close the connection after the response have been sent.\n      ///\n      /// This is useful when implementing a HTTP/1.0-server sending content\n      /// without specifying the content length.\n      bool close_connection_after_response = false;\n    };\n\n    class Content : public std::istream {\n      friend class ServerBase<socket_type>;\n\n    public:\n      std::size_t size() noexcept {\n        return streambuf.size();\n      }\n      /// Convenience function to return std::string. The stream buffer is consumed.\n      std::string string() noexcept {\n        try {\n          std::string str;\n          auto size = streambuf.size();\n          str.resize(size);\n          read(&str[0], static_cast<std::streamsize>(size));\n          return str;\n        }\n        catch(...) {\n          return std::string();\n        }\n      }\n\n    private:\n      asio::streambuf &streambuf;\n      Content(asio::streambuf &streambuf) noexcept : std::istream(&streambuf), streambuf(streambuf) {}\n    };\n\n    class Request {\n      friend class ServerBase<socket_type>;\n      friend class Server<socket_type>;\n      friend class Session;\n\n      asio::streambuf streambuf;\n\n      Request(std::size_t max_request_streambuf_size, std::shared_ptr<asio::ip::tcp::endpoint> remote_endpoint) noexcept\n          : streambuf(max_request_streambuf_size), content(streambuf), remote_endpoint(std::move(remote_endpoint)) {}\n\n    public:\n      std::string method, path, query_string, http_version;\n\n      Content content;\n\n      CaseInsensitiveMultimap header;\n\n      regex::smatch path_match;\n\n      std::shared_ptr<asio::ip::tcp::endpoint> remote_endpoint;\n\n      /// The time point when the request header was fully read.\n      std::chrono::system_clock::time_point header_read_time;\n\n      std::string remote_endpoint_address() noexcept {\n        try {\n          return remote_endpoint->address().to_string();\n        }\n        catch(...) {\n          return std::string();\n        }\n      }\n\n      unsigned short remote_endpoint_port() noexcept {\n        return remote_endpoint->port();\n      }\n\n      /// Returns query keys with percent-decoded values.\n      CaseInsensitiveMultimap parse_query_string() noexcept {\n        return SimpleWeb::QueryString::parse(query_string);\n      }\n    };\n\n  protected:\n    class Connection : public std::enable_shared_from_this<Connection> {\n    public:\n      template <typename... Args>\n      Connection(std::shared_ptr<ScopeRunner> handler_runner, Args &&... args) noexcept : handler_runner(std::move(handler_runner)), socket(new socket_type(std::forward<Args>(args)...)) {}\n\n      std::shared_ptr<ScopeRunner> handler_runner;\n\n      std::unique_ptr<socket_type> socket; // Socket must be unique_ptr since asio::ssl::stream<asio::ip::tcp::socket> is not movable\n      std::mutex socket_close_mutex;\n\n      std::unique_ptr<asio::steady_timer> timer;\n\n      std::shared_ptr<asio::ip::tcp::endpoint> remote_endpoint;\n\n      void close() noexcept {\n        error_code ec;\n        std::unique_lock<std::mutex> lock(socket_close_mutex); // The following operations seems to be needed to run sequentially\n        socket->lowest_layer().shutdown(asio::ip::tcp::socket::shutdown_both, ec);\n        socket->lowest_layer().close(ec);\n      }\n\n      void set_timeout(long seconds) noexcept {\n        if(seconds == 0) {\n          timer = nullptr;\n          return;\n        }\n\n        timer = std::unique_ptr<asio::steady_timer>(new asio::steady_timer(socket->get_io_service()));\n        timer->expires_from_now(std::chrono::seconds(seconds));\n        auto self = this->shared_from_this();\n        timer->async_wait([self](const error_code &ec) {\n          if(!ec)\n            self->close();\n        });\n      }\n\n      void cancel_timeout() noexcept {\n        if(timer) {\n          error_code ec;\n          timer->cancel(ec);\n        }\n      }\n    };\n\n    class Session {\n    public:\n      Session(std::size_t max_request_streambuf_size, std::shared_ptr<Connection> connection) noexcept : connection(std::move(connection)) {\n        if(!this->connection->remote_endpoint) {\n          error_code ec;\n          this->connection->remote_endpoint = std::make_shared<asio::ip::tcp::endpoint>(this->connection->socket->lowest_layer().remote_endpoint(ec));\n        }\n        request = std::shared_ptr<Request>(new Request(max_request_streambuf_size, this->connection->remote_endpoint));\n      }\n\n      std::shared_ptr<Connection> connection;\n      std::shared_ptr<Request> request;\n    };\n\n  public:\n    class Config {\n      friend class ServerBase<socket_type>;\n\n      Config(unsigned short port) noexcept : port(port) {}\n\n    public:\n      /// Port number to use. Defaults to 80 for HTTP and 443 for HTTPS. Set to 0 get an assigned port.\n      unsigned short port;\n      /// If io_service is not set, number of threads that the server will use when start() is called.\n      /// Defaults to 1 thread.\n      std::size_t thread_pool_size = 1;\n      /// Timeout on request handling. Defaults to 5 seconds.\n      long timeout_request = 5;\n      /// Timeout on content handling. Defaults to 300 seconds.\n      long timeout_content = 300;\n      /// Maximum size of request stream buffer. Defaults to architecture maximum.\n      /// Reaching this limit will result in a message_size error code.\n      std::size_t max_request_streambuf_size = std::numeric_limits<std::size_t>::max();\n      /// IPv4 address in dotted decimal form or IPv6 address in hexadecimal notation.\n      /// If empty, the address will be any address.\n      std::string address;\n      /// Set to false to avoid binding the socket to an address that is already in use. Defaults to true.\n      bool reuse_address = true;\n    };\n    /// Set before calling start().\n    Config config;\n\n  private:\n    class regex_orderable : public regex::regex {\n      std::string str;\n\n    public:\n      regex_orderable(const char *regex_cstr) : regex::regex(regex_cstr), str(regex_cstr) {}\n      regex_orderable(std::string regex_str) : regex::regex(regex_str), str(std::move(regex_str)) {}\n      bool operator<(const regex_orderable &rhs) const noexcept {\n        return str < rhs.str;\n      }\n    };\n\n  public:\n    /// Warning: do not add or remove resources after start() is called\n    std::map<regex_orderable, std::map<std::string, std::function<void(std::shared_ptr<typename ServerBase<socket_type>::Response>, std::shared_ptr<typename ServerBase<socket_type>::Request>)>>> resource;\n\n    std::map<std::string, std::function<void(std::shared_ptr<typename ServerBase<socket_type>::Response>, std::shared_ptr<typename ServerBase<socket_type>::Request>)>> default_resource;\n\n    std::function<void(std::shared_ptr<typename ServerBase<socket_type>::Request>, const error_code &)> on_error;\n\n    std::function<void(std::unique_ptr<socket_type> &, std::shared_ptr<typename ServerBase<socket_type>::Request>)> on_upgrade;\n\n    /// If you have your own asio::io_service, store its pointer here before running start().\n    std::shared_ptr<asio::io_service> io_service;\n\n    /// If you know the server port in advance, use start() instead.\n    /// Returns assigned port. If io_service is not set, an internal io_service is created instead.\n    /// Call before accept_and_run().\n    unsigned short bind() {\n      asio::ip::tcp::endpoint endpoint;\n      if(config.address.size() > 0)\n        endpoint = asio::ip::tcp::endpoint(asio::ip::address::from_string(config.address), config.port);\n      else\n        endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), config.port);\n\n      if(!io_service) {\n        io_service = std::make_shared<asio::io_service>();\n        internal_io_service = true;\n      }\n\n      if(!acceptor)\n        acceptor = std::unique_ptr<asio::ip::tcp::acceptor>(new asio::ip::tcp::acceptor(*io_service));\n      acceptor->open(endpoint.protocol());\n      acceptor->set_option(asio::socket_base::reuse_address(config.reuse_address));\n      acceptor->bind(endpoint);\n\n      after_bind();\n\n      return acceptor->local_endpoint().port();\n    }\n\n    /// If you know the server port in advance, use start() instead.\n    /// Accept requests, and if io_service was not set before calling bind(), run the internal io_service instead.\n    /// Call after bind().\n    void accept_and_run() {\n      acceptor->listen();\n      accept();\n\n      if(internal_io_service) {\n        if(io_service->stopped())\n          io_service->reset();\n\n        // If thread_pool_size>1, start m_io_service.run() in (thread_pool_size-1) threads for thread-pooling\n        threads.clear();\n        for(std::size_t c = 1; c < config.thread_pool_size; c++) {\n          threads.emplace_back([this]() {\n            this->io_service->run();\n          });\n        }\n\n        // Main thread\n        if(config.thread_pool_size > 0)\n          io_service->run();\n\n        // Wait for the rest of the threads, if any, to finish as well\n        for(auto &t : threads)\n          t.join();\n      }\n    }\n\n    /// Start the server by calling bind() and accept_and_run()\n    void start() {\n      bind();\n      accept_and_run();\n    }\n\n    /// Stop accepting new requests, and close current connections.\n    void stop() noexcept {\n      if(acceptor) {\n        error_code ec;\n        acceptor->close(ec);\n\n        {\n          std::unique_lock<std::mutex> lock(*connections_mutex);\n          for(auto &connection : *connections)\n            connection->close();\n          connections->clear();\n        }\n\n        if(internal_io_service)\n          io_service->stop();\n      }\n    }\n\n    virtual ~ServerBase() noexcept {\n      handler_runner->stop();\n      stop();\n    }\n\n  protected:\n    bool internal_io_service = false;\n\n    std::unique_ptr<asio::ip::tcp::acceptor> acceptor;\n    std::vector<std::thread> threads;\n\n    std::shared_ptr<std::unordered_set<Connection *>> connections;\n    std::shared_ptr<std::mutex> connections_mutex;\n\n    std::shared_ptr<ScopeRunner> handler_runner;\n\n    ServerBase(unsigned short port) noexcept : config(port), connections(new std::unordered_set<Connection *>()), connections_mutex(new std::mutex()), handler_runner(new ScopeRunner()) {}\n\n    virtual void after_bind() {}\n    virtual void accept() = 0;\n\n    template <typename... Args>\n    std::shared_ptr<Connection> create_connection(Args &&... args) noexcept {\n      auto connections = this->connections;\n      auto connections_mutex = this->connections_mutex;\n      auto connection = std::shared_ptr<Connection>(new Connection(handler_runner, std::forward<Args>(args)...), [connections, connections_mutex](Connection *connection) {\n        {\n          std::unique_lock<std::mutex> lock(*connections_mutex);\n          auto it = connections->find(connection);\n          if(it != connections->end())\n            connections->erase(it);\n        }\n        delete connection;\n      });\n      {\n        std::unique_lock<std::mutex> lock(*connections_mutex);\n        connections->emplace(connection.get());\n      }\n      return connection;\n    }\n\n    void read(const std::shared_ptr<Session> &session) {\n      session->connection->set_timeout(config.timeout_request);\n      asio::async_read_until(*session->connection->socket, session->request->streambuf, \"\\r\\n\\r\\n\", [this, session](const error_code &ec, std::size_t bytes_transferred) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        session->request->header_read_time = std::chrono::system_clock::now();\n        if((!ec || ec == asio::error::not_found) && session->request->streambuf.size() == session->request->streambuf.max_size()) {\n          auto response = std::shared_ptr<Response>(new Response(session, this->config.timeout_content));\n          response->write(StatusCode::client_error_payload_too_large);\n          response->send();\n          if(this->on_error)\n            this->on_error(session->request, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n        if(!ec) {\n          // request->streambuf.size() is not necessarily the same as bytes_transferred, from Boost-docs:\n          // \"After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter\"\n          // The chosen solution is to extract lines from the stream directly when parsing the header. What is left of the\n          // streambuf (maybe some bytes of the content) is appended to in the async_read-function below (for retrieving content).\n          std::size_t num_additional_bytes = session->request->streambuf.size() - bytes_transferred;\n\n          if(!RequestMessage::parse(session->request->content, session->request->method, session->request->path,\n                                    session->request->query_string, session->request->http_version, session->request->header)) {\n            if(this->on_error)\n              this->on_error(session->request, make_error_code::make_error_code(errc::protocol_error));\n            return;\n          }\n\n          // If content, read that as well\n          auto header_it = session->request->header.find(\"Content-Length\");\n          if(header_it != session->request->header.end()) {\n            unsigned long long content_length = 0;\n            try {\n              content_length = stoull(header_it->second);\n            }\n            catch(const std::exception &) {\n              if(this->on_error)\n                this->on_error(session->request, make_error_code::make_error_code(errc::protocol_error));\n              return;\n            }\n            if(content_length > num_additional_bytes) {\n              session->connection->set_timeout(config.timeout_content);\n              asio::async_read(*session->connection->socket, session->request->streambuf, asio::transfer_exactly(content_length - num_additional_bytes), [this, session](const error_code &ec, std::size_t /*bytes_transferred*/) {\n                session->connection->cancel_timeout();\n                auto lock = session->connection->handler_runner->continue_lock();\n                if(!lock)\n                  return;\n                if(!ec) {\n                  if(session->request->streambuf.size() == session->request->streambuf.max_size()) {\n                    auto response = std::shared_ptr<Response>(new Response(session, this->config.timeout_content));\n                    response->write(StatusCode::client_error_payload_too_large);\n                    response->send();\n                    if(this->on_error)\n                      this->on_error(session->request, make_error_code::make_error_code(errc::message_size));\n                    return;\n                  }\n                  this->find_resource(session);\n                }\n                else if(this->on_error)\n                  this->on_error(session->request, ec);\n              });\n            }\n            else\n              this->find_resource(session);\n          }\n          else if((header_it = session->request->header.find(\"Transfer-Encoding\")) != session->request->header.end() && header_it->second == \"chunked\") {\n            auto chunks_streambuf = std::make_shared<asio::streambuf>(this->config.max_request_streambuf_size);\n            this->read_chunked_transfer_encoded(session, chunks_streambuf);\n          }\n          else\n            this->find_resource(session);\n        }\n        else if(this->on_error)\n          this->on_error(session->request, ec);\n      });\n    }\n\n    void read_chunked_transfer_encoded(const std::shared_ptr<Session> &session, const std::shared_ptr<asio::streambuf> &chunks_streambuf) {\n      session->connection->set_timeout(config.timeout_content);\n      asio::async_read_until(*session->connection->socket, session->request->streambuf, \"\\r\\n\", [this, session, chunks_streambuf](const error_code &ec, size_t bytes_transferred) {\n        session->connection->cancel_timeout();\n        auto lock = session->connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n        if((!ec || ec == asio::error::not_found) && session->request->streambuf.size() == session->request->streambuf.max_size()) {\n          auto response = std::shared_ptr<Response>(new Response(session, this->config.timeout_content));\n          response->write(StatusCode::client_error_payload_too_large);\n          response->send();\n          if(this->on_error)\n            this->on_error(session->request, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n        if(!ec) {\n          std::string line;\n          getline(session->request->content, line);\n          bytes_transferred -= line.size() + 1;\n          line.pop_back();\n          unsigned long length = 0;\n          try {\n            length = stoul(line, 0, 16);\n          }\n          catch(...) {\n            if(this->on_error)\n              this->on_error(session->request, make_error_code::make_error_code(errc::protocol_error));\n            return;\n          }\n\n          auto num_additional_bytes = session->request->streambuf.size() - bytes_transferred;\n\n          if((2 + length) > num_additional_bytes) {\n            session->connection->set_timeout(config.timeout_content);\n            asio::async_read(*session->connection->socket, session->request->streambuf, asio::transfer_exactly(2 + length - num_additional_bytes), [this, session, chunks_streambuf, length](const error_code &ec, size_t /*bytes_transferred*/) {\n              session->connection->cancel_timeout();\n              auto lock = session->connection->handler_runner->continue_lock();\n              if(!lock)\n                return;\n              if(!ec) {\n                if(session->request->streambuf.size() == session->request->streambuf.max_size()) {\n                  auto response = std::shared_ptr<Response>(new Response(session, this->config.timeout_content));\n                  response->write(StatusCode::client_error_payload_too_large);\n                  response->send();\n                  if(this->on_error)\n                    this->on_error(session->request, make_error_code::make_error_code(errc::message_size));\n                  return;\n                }\n                this->read_chunked_transfer_encoded_chunk(session, chunks_streambuf, length);\n              }\n              else if(this->on_error)\n                this->on_error(session->request, ec);\n            });\n          }\n          else\n            this->read_chunked_transfer_encoded_chunk(session, chunks_streambuf, length);\n        }\n        else if(this->on_error)\n          this->on_error(session->request, ec);\n      });\n    }\n\n    void read_chunked_transfer_encoded_chunk(const std::shared_ptr<Session> &session, const std::shared_ptr<asio::streambuf> &chunks_streambuf, unsigned long length) {\n      std::ostream tmp_stream(chunks_streambuf.get());\n      if(length > 0) {\n        std::unique_ptr<char[]> buffer(new char[length]);\n        session->request->content.read(buffer.get(), static_cast<std::streamsize>(length));\n        tmp_stream.write(buffer.get(), static_cast<std::streamsize>(length));\n        if(chunks_streambuf->size() == chunks_streambuf->max_size()) {\n          auto response = std::shared_ptr<Response>(new Response(session, this->config.timeout_content));\n          response->write(StatusCode::client_error_payload_too_large);\n          response->send();\n          if(this->on_error)\n            this->on_error(session->request, make_error_code::make_error_code(errc::message_size));\n          return;\n        }\n      }\n\n      // Remove \"\\r\\n\"\n      session->request->content.get();\n      session->request->content.get();\n\n      if(length > 0)\n        read_chunked_transfer_encoded(session, chunks_streambuf);\n      else {\n        if(chunks_streambuf->size() > 0) {\n          std::ostream ostream(&session->request->streambuf);\n          ostream << chunks_streambuf.get();\n        }\n        this->find_resource(session);\n      }\n    }\n\n    void find_resource(const std::shared_ptr<Session> &session) {\n      // Upgrade connection\n      if(on_upgrade) {\n        auto it = session->request->header.find(\"Upgrade\");\n        if(it != session->request->header.end()) {\n          // remove connection from connections\n          {\n            std::unique_lock<std::mutex> lock(*connections_mutex);\n            auto it = connections->find(session->connection.get());\n            if(it != connections->end())\n              connections->erase(it);\n          }\n\n          on_upgrade(session->connection->socket, session->request);\n          return;\n        }\n      }\n      // Find path- and method-match, and call write\n      for(auto &regex_method : resource) {\n        auto it = regex_method.second.find(session->request->method);\n        if(it != regex_method.second.end()) {\n          regex::smatch sm_res;\n          if(regex::regex_match(session->request->path, sm_res, regex_method.first)) {\n            session->request->path_match = std::move(sm_res);\n            write(session, it->second);\n            return;\n          }\n        }\n      }\n      auto it = default_resource.find(session->request->method);\n      if(it != default_resource.end())\n        write(session, it->second);\n    }\n\n    void write(const std::shared_ptr<Session> &session,\n               std::function<void(std::shared_ptr<typename ServerBase<socket_type>::Response>, std::shared_ptr<typename ServerBase<socket_type>::Request>)> &resource_function) {\n      session->connection->set_timeout(config.timeout_content);\n      auto response = std::shared_ptr<Response>(new Response(session, config.timeout_content), [this](Response *response_ptr) {\n        auto response = std::shared_ptr<Response>(response_ptr);\n        response->send([this, response](const error_code &ec) {\n          if(!ec) {\n            if(response->close_connection_after_response)\n              return;\n\n            auto range = response->session->request->header.equal_range(\"Connection\");\n            for(auto it = range.first; it != range.second; it++) {\n              if(case_insensitive_equal(it->second, \"close\"))\n                return;\n              else if(case_insensitive_equal(it->second, \"keep-alive\")) {\n                auto new_session = std::make_shared<Session>(this->config.max_request_streambuf_size, response->session->connection);\n                this->read(new_session);\n                return;\n              }\n            }\n            if(response->session->request->http_version >= \"1.1\") {\n              auto new_session = std::make_shared<Session>(this->config.max_request_streambuf_size, response->session->connection);\n              this->read(new_session);\n              return;\n            }\n          }\n          else if(this->on_error)\n            this->on_error(response->session->request, ec);\n        });\n      });\n\n      try {\n        resource_function(response, session->request);\n      }\n      catch(const std::exception &) {\n        if(on_error)\n          on_error(session->request, make_error_code::make_error_code(errc::operation_canceled));\n        return;\n      }\n    }\n  };\n\n  template <class socket_type>\n  class Server : public ServerBase<socket_type> {};\n\n  using HTTP = asio::ip::tcp::socket;\n\n  template <>\n  class Server<HTTP> : public ServerBase<HTTP> {\n  public:\n    Server() noexcept : ServerBase<HTTP>::ServerBase(80) {}\n\n  protected:\n    void accept() override {\n      auto connection = create_connection(*io_service);\n\n      acceptor->async_accept(*connection->socket, [this, connection](const error_code &ec) {\n        auto lock = connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n\n        // Immediately start accepting a new connection (unless io_service has been stopped)\n        if(ec != asio::error::operation_aborted)\n          this->accept();\n\n        auto session = std::make_shared<Session>(config.max_request_streambuf_size, connection);\n\n        if(!ec) {\n          asio::ip::tcp::no_delay option(true);\n          error_code ec;\n          session->connection->socket->set_option(option, ec);\n\n          this->read(session);\n        }\n        else if(this->on_error)\n          this->on_error(session->request, ec);\n      });\n    }\n  };\n} // namespace SimpleWeb\n\n#endif /* SERVER_HTTP_HPP */\n"
        },
        {
          "name": "server_https.hpp",
          "type": "blob",
          "size": 2.966796875,
          "content": "#ifndef SERVER_HTTPS_HPP\n#define SERVER_HTTPS_HPP\n\n#include \"server_http.hpp\"\n\n#ifdef USE_STANDALONE_ASIO\n#include <asio/ssl.hpp>\n#else\n#include <boost/asio/ssl.hpp>\n#endif\n\n#include <algorithm>\n#include <openssl/ssl.h>\n\nnamespace SimpleWeb {\n  using HTTPS = asio::ssl::stream<asio::ip::tcp::socket>;\n\n  template <>\n  class Server<HTTPS> : public ServerBase<HTTPS> {\n    bool set_session_id_context = false;\n\n  public:\n    Server(const std::string &cert_file, const std::string &private_key_file, const std::string &verify_file = std::string())\n        : ServerBase<HTTPS>::ServerBase(443), context(asio::ssl::context::tlsv12) {\n      context.use_certificate_chain_file(cert_file);\n      context.use_private_key_file(private_key_file, asio::ssl::context::pem);\n\n      if(verify_file.size() > 0) {\n        context.load_verify_file(verify_file);\n        context.set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert | asio::ssl::verify_client_once);\n        set_session_id_context = true;\n      }\n    }\n\n  protected:\n    asio::ssl::context context;\n\n    void after_bind() override {\n      if(set_session_id_context) {\n        // Creating session_id_context from address:port but reversed due to small SSL_MAX_SSL_SESSION_ID_LENGTH\n        auto session_id_context = std::to_string(acceptor->local_endpoint().port()) + ':';\n        session_id_context.append(config.address.rbegin(), config.address.rend());\n        SSL_CTX_set_session_id_context(context.native_handle(), reinterpret_cast<const unsigned char *>(session_id_context.data()),\n                                       std::min<std::size_t>(session_id_context.size(), SSL_MAX_SSL_SESSION_ID_LENGTH));\n      }\n    }\n\n    void accept() override {\n      auto connection = create_connection(*io_service, context);\n\n      acceptor->async_accept(connection->socket->lowest_layer(), [this, connection](const error_code &ec) {\n        auto lock = connection->handler_runner->continue_lock();\n        if(!lock)\n          return;\n\n        if(ec != asio::error::operation_aborted)\n          this->accept();\n\n        auto session = std::make_shared<Session>(config.max_request_streambuf_size, connection);\n\n        if(!ec) {\n          asio::ip::tcp::no_delay option(true);\n          error_code ec;\n          session->connection->socket->lowest_layer().set_option(option, ec);\n\n          session->connection->set_timeout(config.timeout_request);\n          session->connection->socket->async_handshake(asio::ssl::stream_base::server, [this, session](const error_code &ec) {\n            session->connection->cancel_timeout();\n            auto lock = session->connection->handler_runner->continue_lock();\n            if(!lock)\n              return;\n            if(!ec)\n              this->read(session);\n            else if(this->on_error)\n              this->on_error(session->request, ec);\n          });\n        }\n        else if(this->on_error)\n          this->on_error(session->request, ec);\n      });\n    }\n  };\n} // namespace SimpleWeb\n\n#endif /* SERVER_HTTPS_HPP */\n"
        },
        {
          "name": "status_code.hpp",
          "type": "blob",
          "size": 7.828125,
          "content": "#ifndef SIMPLE_WEB_STATUS_CODE_HPP\n#define SIMPLE_WEB_STATUS_CODE_HPP\n\n#include <map>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace SimpleWeb {\n  enum class StatusCode {\n    unknown = 0,\n    information_continue = 100,\n    information_switching_protocols,\n    information_processing,\n    success_ok = 200,\n    success_created,\n    success_accepted,\n    success_non_authoritative_information,\n    success_no_content,\n    success_reset_content,\n    success_partial_content,\n    success_multi_status,\n    success_already_reported,\n    success_im_used = 226,\n    redirection_multiple_choices = 300,\n    redirection_moved_permanently,\n    redirection_found,\n    redirection_see_other,\n    redirection_not_modified,\n    redirection_use_proxy,\n    redirection_switch_proxy,\n    redirection_temporary_redirect,\n    redirection_permanent_redirect,\n    client_error_bad_request = 400,\n    client_error_unauthorized,\n    client_error_payment_required,\n    client_error_forbidden,\n    client_error_not_found,\n    client_error_method_not_allowed,\n    client_error_not_acceptable,\n    client_error_proxy_authentication_required,\n    client_error_request_timeout,\n    client_error_conflict,\n    client_error_gone,\n    client_error_length_required,\n    client_error_precondition_failed,\n    client_error_payload_too_large,\n    client_error_uri_too_long,\n    client_error_unsupported_media_type,\n    client_error_range_not_satisfiable,\n    client_error_expectation_failed,\n    client_error_im_a_teapot,\n    client_error_misdirection_required = 421,\n    client_error_unprocessable_entity,\n    client_error_locked,\n    client_error_failed_dependency,\n    client_error_upgrade_required = 426,\n    client_error_precondition_required = 428,\n    client_error_too_many_requests,\n    client_error_request_header_fields_too_large = 431,\n    client_error_unavailable_for_legal_reasons = 451,\n    server_error_internal_server_error = 500,\n    server_error_not_implemented,\n    server_error_bad_gateway,\n    server_error_service_unavailable,\n    server_error_gateway_timeout,\n    server_error_http_version_not_supported,\n    server_error_variant_also_negotiates,\n    server_error_insufficient_storage,\n    server_error_loop_detected,\n    server_error_not_extended = 510,\n    server_error_network_authentication_required\n  };\n\n  inline const std::map<StatusCode, std::string> &status_code_strings() {\n    static const std::map<StatusCode, std::string> status_code_strings = {\n        {StatusCode::unknown, \"\"},\n        {StatusCode::information_continue, \"100 Continue\"},\n        {StatusCode::information_switching_protocols, \"101 Switching Protocols\"},\n        {StatusCode::information_processing, \"102 Processing\"},\n        {StatusCode::success_ok, \"200 OK\"},\n        {StatusCode::success_created, \"201 Created\"},\n        {StatusCode::success_accepted, \"202 Accepted\"},\n        {StatusCode::success_non_authoritative_information, \"203 Non-Authoritative Information\"},\n        {StatusCode::success_no_content, \"204 No Content\"},\n        {StatusCode::success_reset_content, \"205 Reset Content\"},\n        {StatusCode::success_partial_content, \"206 Partial Content\"},\n        {StatusCode::success_multi_status, \"207 Multi-Status\"},\n        {StatusCode::success_already_reported, \"208 Already Reported\"},\n        {StatusCode::success_im_used, \"226 IM Used\"},\n        {StatusCode::redirection_multiple_choices, \"300 Multiple Choices\"},\n        {StatusCode::redirection_moved_permanently, \"301 Moved Permanently\"},\n        {StatusCode::redirection_found, \"302 Found\"},\n        {StatusCode::redirection_see_other, \"303 See Other\"},\n        {StatusCode::redirection_not_modified, \"304 Not Modified\"},\n        {StatusCode::redirection_use_proxy, \"305 Use Proxy\"},\n        {StatusCode::redirection_switch_proxy, \"306 Switch Proxy\"},\n        {StatusCode::redirection_temporary_redirect, \"307 Temporary Redirect\"},\n        {StatusCode::redirection_permanent_redirect, \"308 Permanent Redirect\"},\n        {StatusCode::client_error_bad_request, \"400 Bad Request\"},\n        {StatusCode::client_error_unauthorized, \"401 Unauthorized\"},\n        {StatusCode::client_error_payment_required, \"402 Payment Required\"},\n        {StatusCode::client_error_forbidden, \"403 Forbidden\"},\n        {StatusCode::client_error_not_found, \"404 Not Found\"},\n        {StatusCode::client_error_method_not_allowed, \"405 Method Not Allowed\"},\n        {StatusCode::client_error_not_acceptable, \"406 Not Acceptable\"},\n        {StatusCode::client_error_proxy_authentication_required, \"407 Proxy Authentication Required\"},\n        {StatusCode::client_error_request_timeout, \"408 Request Timeout\"},\n        {StatusCode::client_error_conflict, \"409 Conflict\"},\n        {StatusCode::client_error_gone, \"410 Gone\"},\n        {StatusCode::client_error_length_required, \"411 Length Required\"},\n        {StatusCode::client_error_precondition_failed, \"412 Precondition Failed\"},\n        {StatusCode::client_error_payload_too_large, \"413 Payload Too Large\"},\n        {StatusCode::client_error_uri_too_long, \"414 URI Too Long\"},\n        {StatusCode::client_error_unsupported_media_type, \"415 Unsupported Media Type\"},\n        {StatusCode::client_error_range_not_satisfiable, \"416 Range Not Satisfiable\"},\n        {StatusCode::client_error_expectation_failed, \"417 Expectation Failed\"},\n        {StatusCode::client_error_im_a_teapot, \"418 I'm a teapot\"},\n        {StatusCode::client_error_misdirection_required, \"421 Misdirected Request\"},\n        {StatusCode::client_error_unprocessable_entity, \"422 Unprocessable Entity\"},\n        {StatusCode::client_error_locked, \"423 Locked\"},\n        {StatusCode::client_error_failed_dependency, \"424 Failed Dependency\"},\n        {StatusCode::client_error_upgrade_required, \"426 Upgrade Required\"},\n        {StatusCode::client_error_precondition_required, \"428 Precondition Required\"},\n        {StatusCode::client_error_too_many_requests, \"429 Too Many Requests\"},\n        {StatusCode::client_error_request_header_fields_too_large, \"431 Request Header Fields Too Large\"},\n        {StatusCode::client_error_unavailable_for_legal_reasons, \"451 Unavailable For Legal Reasons\"},\n        {StatusCode::server_error_internal_server_error, \"500 Internal Server Error\"},\n        {StatusCode::server_error_not_implemented, \"501 Not Implemented\"},\n        {StatusCode::server_error_bad_gateway, \"502 Bad Gateway\"},\n        {StatusCode::server_error_service_unavailable, \"503 Service Unavailable\"},\n        {StatusCode::server_error_gateway_timeout, \"504 Gateway Timeout\"},\n        {StatusCode::server_error_http_version_not_supported, \"505 HTTP Version Not Supported\"},\n        {StatusCode::server_error_variant_also_negotiates, \"506 Variant Also Negotiates\"},\n        {StatusCode::server_error_insufficient_storage, \"507 Insufficient Storage\"},\n        {StatusCode::server_error_loop_detected, \"508 Loop Detected\"},\n        {StatusCode::server_error_not_extended, \"510 Not Extended\"},\n        {StatusCode::server_error_network_authentication_required, \"511 Network Authentication Required\"}};\n    return status_code_strings;\n  }\n\n  inline StatusCode status_code(const std::string &status_code_string) noexcept {\n    class StringToStatusCode : public std::unordered_map<std::string, SimpleWeb::StatusCode> {\n    public:\n      StringToStatusCode() {\n        for(auto &status_code : status_code_strings())\n          emplace(status_code.second, status_code.first);\n      }\n    };\n    static StringToStatusCode string_to_status_code;\n    auto pos = string_to_status_code.find(status_code_string);\n    if(pos == string_to_status_code.end())\n      return StatusCode::unknown;\n    return pos->second;\n  }\n\n  inline const std::string &status_code(StatusCode status_code_enum) noexcept {\n    auto pos = status_code_strings().find(status_code_enum);\n    if(pos == status_code_strings().end()) {\n      static std::string empty_string;\n      return empty_string;\n    }\n    return pos->second;\n  }\n} // namespace SimpleWeb\n\n#endif // SIMPLE_WEB_STATUS_CODE_HPP\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "utility.hpp",
          "type": "blob",
          "size": 11.9326171875,
          "content": "#ifndef SIMPLE_WEB_UTILITY_HPP\n#define SIMPLE_WEB_UTILITY_HPP\n\n#include \"status_code.hpp\"\n#include <atomic>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\nnamespace SimpleWeb {\n  inline bool case_insensitive_equal(const std::string &str1, const std::string &str2) noexcept {\n    return str1.size() == str2.size() &&\n           std::equal(str1.begin(), str1.end(), str2.begin(), [](char a, char b) {\n             return tolower(a) == tolower(b);\n           });\n  }\n  class CaseInsensitiveEqual {\n  public:\n    bool operator()(const std::string &str1, const std::string &str2) const noexcept {\n      return case_insensitive_equal(str1, str2);\n    }\n  };\n  // Based on https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x/2595226#2595226\n  class CaseInsensitiveHash {\n  public:\n    std::size_t operator()(const std::string &str) const noexcept {\n      std::size_t h = 0;\n      std::hash<int> hash;\n      for(auto c : str)\n        h ^= hash(tolower(c)) + 0x9e3779b9 + (h << 6) + (h >> 2);\n      return h;\n    }\n  };\n\n  using CaseInsensitiveMultimap = std::unordered_multimap<std::string, std::string, CaseInsensitiveHash, CaseInsensitiveEqual>;\n\n  /// Percent encoding and decoding\n  class Percent {\n  public:\n    /// Returns percent-encoded string\n    static std::string encode(const std::string &value) noexcept {\n      static auto hex_chars = \"0123456789ABCDEF\";\n\n      std::string result;\n      result.reserve(value.size()); // Minimum size of result\n\n      for(auto &chr : value) {\n        if(!((chr >= '0' && chr <= '9') || (chr >= 'A' && chr <= 'Z') || (chr >= 'a' && chr <= 'z') || chr == '-' || chr == '.' || chr == '_' || chr == '~'))\n          result += std::string(\"%\") + hex_chars[static_cast<unsigned char>(chr) >> 4] + hex_chars[static_cast<unsigned char>(chr) & 15];\n        else\n          result += chr;\n      }\n\n      return result;\n    }\n\n    /// Returns percent-decoded string\n    static std::string decode(const std::string &value) noexcept {\n      std::string result;\n      result.reserve(value.size() / 3 + (value.size() % 3)); // Minimum size of result\n\n      for(std::size_t i = 0; i < value.size(); ++i) {\n        auto &chr = value[i];\n        if(chr == '%' && i + 2 < value.size()) {\n          auto hex = value.substr(i + 1, 2);\n          auto decoded_chr = static_cast<char>(std::strtol(hex.c_str(), nullptr, 16));\n          result += decoded_chr;\n          i += 2;\n        }\n        else if(chr == '+')\n          result += ' ';\n        else\n          result += chr;\n      }\n\n      return result;\n    }\n  };\n\n  /// Query string creation and parsing\n  class QueryString {\n  public:\n    /// Returns query string created from given field names and values\n    static std::string create(const CaseInsensitiveMultimap &fields) noexcept {\n      std::string result;\n\n      bool first = true;\n      for(auto &field : fields) {\n        result += (!first ? \"&\" : \"\") + field.first + '=' + Percent::encode(field.second);\n        first = false;\n      }\n\n      return result;\n    }\n\n    /// Returns query keys with percent-decoded values.\n    static CaseInsensitiveMultimap parse(const std::string &query_string) noexcept {\n      CaseInsensitiveMultimap result;\n\n      if(query_string.empty())\n        return result;\n\n      std::size_t name_pos = 0;\n      auto name_end_pos = std::string::npos;\n      auto value_pos = std::string::npos;\n      for(std::size_t c = 0; c < query_string.size(); ++c) {\n        if(query_string[c] == '&') {\n          auto name = query_string.substr(name_pos, (name_end_pos == std::string::npos ? c : name_end_pos) - name_pos);\n          if(!name.empty()) {\n            auto value = value_pos == std::string::npos ? std::string() : query_string.substr(value_pos, c - value_pos);\n            result.emplace(std::move(name), Percent::decode(value));\n          }\n          name_pos = c + 1;\n          name_end_pos = std::string::npos;\n          value_pos = std::string::npos;\n        }\n        else if(query_string[c] == '=') {\n          name_end_pos = c;\n          value_pos = c + 1;\n        }\n      }\n      if(name_pos < query_string.size()) {\n        auto name = query_string.substr(name_pos, name_end_pos - name_pos);\n        if(!name.empty()) {\n          auto value = value_pos >= query_string.size() ? std::string() : query_string.substr(value_pos);\n          result.emplace(std::move(name), Percent::decode(value));\n        }\n      }\n\n      return result;\n    }\n  };\n\n  class HttpHeader {\n  public:\n    /// Parse header fields\n    static CaseInsensitiveMultimap parse(std::istream &stream) noexcept {\n      CaseInsensitiveMultimap result;\n      std::string line;\n      getline(stream, line);\n      std::size_t param_end;\n      while((param_end = line.find(':')) != std::string::npos) {\n        std::size_t value_start = param_end + 1;\n        while(value_start + 1 < line.size() && line[value_start] == ' ')\n          ++value_start;\n        if(value_start < line.size())\n          result.emplace(line.substr(0, param_end), line.substr(value_start, line.size() - value_start - 1));\n\n        getline(stream, line);\n      }\n      return result;\n    }\n\n    class FieldValue {\n    public:\n      class SemicolonSeparatedAttributes {\n      public:\n        /// Parse Set-Cookie or Content-Disposition header field value. Attribute values are percent-decoded.\n        static CaseInsensitiveMultimap parse(const std::string &str) {\n          CaseInsensitiveMultimap result;\n\n          std::size_t name_start_pos = std::string::npos;\n          std::size_t name_end_pos = std::string::npos;\n          std::size_t value_start_pos = std::string::npos;\n          for(std::size_t c = 0; c < str.size(); ++c) {\n            if(name_start_pos == std::string::npos) {\n              if(str[c] != ' ' && str[c] != ';')\n                name_start_pos = c;\n            }\n            else {\n              if(name_end_pos == std::string::npos) {\n                if(str[c] == ';') {\n                  result.emplace(str.substr(name_start_pos, c - name_start_pos), std::string());\n                  name_start_pos = std::string::npos;\n                }\n                else if(str[c] == '=')\n                  name_end_pos = c;\n              }\n              else {\n                if(value_start_pos == std::string::npos) {\n                  if(str[c] == '\"' && c + 1 < str.size())\n                    value_start_pos = c + 1;\n                  else\n                    value_start_pos = c;\n                }\n                else if(str[c] == '\"' || str[c] == ';') {\n                  result.emplace(str.substr(name_start_pos, name_end_pos - name_start_pos), Percent::decode(str.substr(value_start_pos, c - value_start_pos)));\n                  name_start_pos = std::string::npos;\n                  name_end_pos = std::string::npos;\n                  value_start_pos = std::string::npos;\n                }\n              }\n            }\n          }\n          if(name_start_pos != std::string::npos) {\n            if(name_end_pos == std::string::npos)\n              result.emplace(str.substr(name_start_pos), std::string());\n            else if(value_start_pos != std::string::npos) {\n              if(str.back() == '\"')\n                result.emplace(str.substr(name_start_pos, name_end_pos - name_start_pos), Percent::decode(str.substr(value_start_pos, str.size() - 1)));\n              else\n                result.emplace(str.substr(name_start_pos, name_end_pos - name_start_pos), Percent::decode(str.substr(value_start_pos)));\n            }\n          }\n\n          return result;\n        }\n      };\n    };\n  }; // namespace SimpleWeb\n\n  class RequestMessage {\n  public:\n    /// Parse request line and header fields\n    static bool parse(std::istream &stream, std::string &method, std::string &path, std::string &query_string, std::string &version, CaseInsensitiveMultimap &header) noexcept {\n      header.clear();\n      std::string line;\n      getline(stream, line);\n      std::size_t method_end;\n      if((method_end = line.find(' ')) != std::string::npos) {\n        method = line.substr(0, method_end);\n\n        std::size_t query_start = std::string::npos;\n        std::size_t path_and_query_string_end = std::string::npos;\n        for(std::size_t i = method_end + 1; i < line.size(); ++i) {\n          if(line[i] == '?' && (i + 1) < line.size())\n            query_start = i + 1;\n          else if(line[i] == ' ') {\n            path_and_query_string_end = i;\n            break;\n          }\n        }\n        if(path_and_query_string_end != std::string::npos) {\n          if(query_start != std::string::npos) {\n            path = line.substr(method_end + 1, query_start - method_end - 2);\n            query_string = line.substr(query_start, path_and_query_string_end - query_start);\n          }\n          else\n            path = line.substr(method_end + 1, path_and_query_string_end - method_end - 1);\n\n          std::size_t protocol_end;\n          if((protocol_end = line.find('/', path_and_query_string_end + 1)) != std::string::npos) {\n            if(line.compare(path_and_query_string_end + 1, protocol_end - path_and_query_string_end - 1, \"HTTP\") != 0)\n              return false;\n            version = line.substr(protocol_end + 1, line.size() - protocol_end - 2);\n          }\n          else\n            return false;\n\n          header = HttpHeader::parse(stream);\n        }\n        else\n          return false;\n      }\n      else\n        return false;\n      return true;\n    }\n  };\n\n  class ResponseMessage {\n  public:\n    /// Parse status line and header fields\n    static bool parse(std::istream &stream, std::string &version, std::string &status_code, CaseInsensitiveMultimap &header) noexcept {\n      header.clear();\n      std::string line;\n      getline(stream, line);\n      std::size_t version_end = line.find(' ');\n      if(version_end != std::string::npos) {\n        if(5 < line.size())\n          version = line.substr(5, version_end - 5);\n        else\n          return false;\n        if((version_end + 1) < line.size())\n          status_code = line.substr(version_end + 1, line.size() - (version_end + 1) - 1);\n        else\n          return false;\n\n        header = HttpHeader::parse(stream);\n      }\n      else\n        return false;\n      return true;\n    }\n  };\n} // namespace SimpleWeb\n\n#ifdef __SSE2__\n#include <emmintrin.h>\nnamespace SimpleWeb {\n  inline void spin_loop_pause() noexcept { _mm_pause(); }\n} // namespace SimpleWeb\n// TODO: need verification that the following checks are correct:\n#elif defined(_MSC_VER) && _MSC_VER >= 1800 && (defined(_M_X64) || defined(_M_IX86))\n#include <intrin.h>\nnamespace SimpleWeb {\n  inline void spin_loop_pause() noexcept { _mm_pause(); }\n} // namespace SimpleWeb\n#else\nnamespace SimpleWeb {\n  inline void spin_loop_pause() noexcept {}\n} // namespace SimpleWeb\n#endif\n\nnamespace SimpleWeb {\n  /// Makes it possible to for instance cancel Asio handlers without stopping asio::io_service\n  class ScopeRunner {\n    /// Scope count that is set to -1 if scopes are to be canceled\n    std::atomic<long> count;\n\n  public:\n    class SharedLock {\n      friend class ScopeRunner;\n      std::atomic<long> &count;\n      SharedLock(std::atomic<long> &count) noexcept : count(count) {}\n      SharedLock &operator=(const SharedLock &) = delete;\n      SharedLock(const SharedLock &) = delete;\n\n    public:\n      ~SharedLock() noexcept {\n        count.fetch_sub(1);\n      }\n    };\n\n    ScopeRunner() noexcept : count(0) {}\n\n    /// Returns nullptr if scope should be exited, or a shared lock otherwise\n    std::unique_ptr<SharedLock> continue_lock() noexcept {\n      long expected = count;\n      while(expected >= 0 && !count.compare_exchange_weak(expected, expected + 1))\n        spin_loop_pause();\n\n      if(expected < 0)\n        return nullptr;\n      else\n        return std::unique_ptr<SharedLock>(new SharedLock(count));\n    }\n\n    /// Blocks until all shared locks are released, then prevents future shared locks\n    void stop() noexcept {\n      long expected = 0;\n      while(!count.compare_exchange_weak(expected, -1)) {\n        if(expected < 0)\n          return;\n        expected = 0;\n        spin_loop_pause();\n      }\n    }\n  };\n} // namespace SimpleWeb\n\n#endif // SIMPLE_WEB_UTILITY_HPP\n"
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}