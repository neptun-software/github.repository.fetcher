{
  "metadata": {
    "timestamp": 1736565922666,
    "page": 892,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "br3ttb/Arduino-PID-Library",
      "stars": 1987,
      "defaultBranch": "master",
      "files": [
        {
          "name": "PID_v1.cpp",
          "type": "blob",
          "size": 7.8720703125,
          "content": "/**********************************************************************************************\n * Arduino PID Library - Version 1.2.1\n * by Brett Beauregard <br3ttb@gmail.com> brettbeauregard.com\n *\n * This Library is licensed under the MIT License\n **********************************************************************************************/\n\n#if ARDUINO >= 100\n  #include \"Arduino.h\"\n#else\n  #include \"WProgram.h\"\n#endif\n\n#include <PID_v1.h>\n\n/*Constructor (...)*********************************************************\n *    The parameters specified here are those for for which we can't set up\n *    reliable defaults, so we need to have the user set them.\n ***************************************************************************/\nPID::PID(double* Input, double* Output, double* Setpoint,\n        double Kp, double Ki, double Kd, int POn, int ControllerDirection)\n{\n    myOutput = Output;\n    myInput = Input;\n    mySetpoint = Setpoint;\n    inAuto = false;\n\n    PID::SetOutputLimits(0, 255);\t\t\t\t//default output limit corresponds to\n\t\t\t\t\t\t\t\t\t\t\t\t//the arduino pwm limits\n\n    SampleTime = 100;\t\t\t\t\t\t\t//default Controller Sample Time is 0.1 seconds\n\n    PID::SetControllerDirection(ControllerDirection);\n    PID::SetTunings(Kp, Ki, Kd, POn);\n\n    lastTime = millis()-SampleTime;\n}\n\n/*Constructor (...)*********************************************************\n *    To allow backwards compatability for v1.1, or for people that just want\n *    to use Proportional on Error without explicitly saying so\n ***************************************************************************/\n\nPID::PID(double* Input, double* Output, double* Setpoint,\n        double Kp, double Ki, double Kd, int ControllerDirection)\n    :PID::PID(Input, Output, Setpoint, Kp, Ki, Kd, P_ON_E, ControllerDirection)\n{\n\n}\n\n\n/* Compute() **********************************************************************\n *     This, as they say, is where the magic happens.  this function should be called\n *   every time \"void loop()\" executes.  the function will decide for itself whether a new\n *   pid Output needs to be computed.  returns true when the output is computed,\n *   false when nothing has been done.\n **********************************************************************************/\nbool PID::Compute()\n{\n   if(!inAuto) return false;\n   unsigned long now = millis();\n   unsigned long timeChange = (now - lastTime);\n   if(timeChange>=SampleTime)\n   {\n      /*Compute all the working error variables*/\n      double input = *myInput;\n      double error = *mySetpoint - input;\n      double dInput = (input - lastInput);\n      outputSum+= (ki * error);\n\n      /*Add Proportional on Measurement, if P_ON_M is specified*/\n      if(!pOnE) outputSum-= kp * dInput;\n\n      if(outputSum > outMax) outputSum= outMax;\n      else if(outputSum < outMin) outputSum= outMin;\n\n      /*Add Proportional on Error, if P_ON_E is specified*/\n\t   double output;\n      if(pOnE) output = kp * error;\n      else output = 0;\n\n      /*Compute Rest of PID Output*/\n      output += outputSum - kd * dInput;\n\n\t    if(output > outMax) output = outMax;\n      else if(output < outMin) output = outMin;\n\t    *myOutput = output;\n\n      /*Remember some variables for next time*/\n      lastInput = input;\n      lastTime = now;\n\t    return true;\n   }\n   else return false;\n}\n\n/* SetTunings(...)*************************************************************\n * This function allows the controller's dynamic performance to be adjusted.\n * it's called automatically from the constructor, but tunings can also\n * be adjusted on the fly during normal operation\n ******************************************************************************/\nvoid PID::SetTunings(double Kp, double Ki, double Kd, int POn)\n{\n   if (Kp<0 || Ki<0 || Kd<0) return;\n\n   pOn = POn;\n   pOnE = POn == P_ON_E;\n\n   dispKp = Kp; dispKi = Ki; dispKd = Kd;\n\n   double SampleTimeInSec = ((double)SampleTime)/1000;\n   kp = Kp;\n   ki = Ki * SampleTimeInSec;\n   kd = Kd / SampleTimeInSec;\n\n  if(controllerDirection ==REVERSE)\n   {\n      kp = (0 - kp);\n      ki = (0 - ki);\n      kd = (0 - kd);\n   }\n}\n\n/* SetTunings(...)*************************************************************\n * Set Tunings using the last-rembered POn setting\n ******************************************************************************/\nvoid PID::SetTunings(double Kp, double Ki, double Kd){\n    SetTunings(Kp, Ki, Kd, pOn); \n}\n\n/* SetSampleTime(...) *********************************************************\n * sets the period, in Milliseconds, at which the calculation is performed\n ******************************************************************************/\nvoid PID::SetSampleTime(int NewSampleTime)\n{\n   if (NewSampleTime > 0)\n   {\n      double ratio  = (double)NewSampleTime\n                      / (double)SampleTime;\n      ki *= ratio;\n      kd /= ratio;\n      SampleTime = (unsigned long)NewSampleTime;\n   }\n}\n\n/* SetOutputLimits(...)****************************************************\n *     This function will be used far more often than SetInputLimits.  while\n *  the input to the controller will generally be in the 0-1023 range (which is\n *  the default already,)  the output will be a little different.  maybe they'll\n *  be doing a time window and will need 0-8000 or something.  or maybe they'll\n *  want to clamp it from 0-125.  who knows.  at any rate, that can all be done\n *  here.\n **************************************************************************/\nvoid PID::SetOutputLimits(double Min, double Max)\n{\n   if(Min >= Max) return;\n   outMin = Min;\n   outMax = Max;\n\n   if(inAuto)\n   {\n\t   if(*myOutput > outMax) *myOutput = outMax;\n\t   else if(*myOutput < outMin) *myOutput = outMin;\n\n\t   if(outputSum > outMax) outputSum= outMax;\n\t   else if(outputSum < outMin) outputSum= outMin;\n   }\n}\n\n/* SetMode(...)****************************************************************\n * Allows the controller Mode to be set to manual (0) or Automatic (non-zero)\n * when the transition from manual to auto occurs, the controller is\n * automatically initialized\n ******************************************************************************/\nvoid PID::SetMode(int Mode)\n{\n    bool newAuto = (Mode == AUTOMATIC);\n    if(newAuto && !inAuto)\n    {  /*we just went from manual to auto*/\n        PID::Initialize();\n    }\n    inAuto = newAuto;\n}\n\n/* Initialize()****************************************************************\n *\tdoes all the things that need to happen to ensure a bumpless transfer\n *  from manual to automatic mode.\n ******************************************************************************/\nvoid PID::Initialize()\n{\n   outputSum = *myOutput;\n   lastInput = *myInput;\n   if(outputSum > outMax) outputSum = outMax;\n   else if(outputSum < outMin) outputSum = outMin;\n}\n\n/* SetControllerDirection(...)*************************************************\n * The PID will either be connected to a DIRECT acting process (+Output leads\n * to +Input) or a REVERSE acting process(+Output leads to -Input.)  we need to\n * know which one, because otherwise we may increase the output when we should\n * be decreasing.  This is called from the constructor.\n ******************************************************************************/\nvoid PID::SetControllerDirection(int Direction)\n{\n   if(inAuto && Direction !=controllerDirection)\n   {\n\t    kp = (0 - kp);\n      ki = (0 - ki);\n      kd = (0 - kd);\n   }\n   controllerDirection = Direction;\n}\n\n/* Status Funcions*************************************************************\n * Just because you set the Kp=-1 doesn't mean it actually happened.  these\n * functions query the internal state of the PID.  they're here for display\n * purposes.  this are the functions the PID Front-end uses for example\n ******************************************************************************/\ndouble PID::GetKp(){ return  dispKp; }\ndouble PID::GetKi(){ return  dispKi;}\ndouble PID::GetKd(){ return  dispKd;}\nint PID::GetMode(){ return  inAuto ? AUTOMATIC : MANUAL;}\nint PID::GetDirection(){ return controllerDirection;}\n\n"
        },
        {
          "name": "PID_v1.h",
          "type": "blob",
          "size": 3.90234375,
          "content": "#ifndef PID_v1_h\n#define PID_v1_h\n#define LIBRARY_VERSION\t1.2.1\n\nclass PID\n{\n\n\n  public:\n\n  //Constants used in some of the functions below\n  #define AUTOMATIC\t1\n  #define MANUAL\t0\n  #define DIRECT  0\n  #define REVERSE  1\n  #define P_ON_M 0\n  #define P_ON_E 1\n\n  //commonly used functions **************************************************************************\n    PID(double*, double*, double*,        // * constructor.  links the PID to the Input, Output, and \n        double, double, double, int, int);//   Setpoint.  Initial tuning parameters are also set here.\n                                          //   (overload for specifying proportional mode)\n\n    PID(double*, double*, double*,        // * constructor.  links the PID to the Input, Output, and \n        double, double, double, int);     //   Setpoint.  Initial tuning parameters are also set here\n\t\n    void SetMode(int Mode);               // * sets PID to either Manual (0) or Auto (non-0)\n\n    bool Compute();                       // * performs the PID calculation.  it should be\n                                          //   called every time loop() cycles. ON/OFF and\n                                          //   calculation frequency can be set using SetMode\n                                          //   SetSampleTime respectively\n\n    void SetOutputLimits(double, double); // * clamps the output to a specific range. 0-255 by default, but\n\t\t\t\t\t\t\t\t\t\t                      //   it's likely the user will want to change this depending on\n\t\t\t\t\t\t\t\t\t\t                      //   the application\n\t\n\n\n  //available but not commonly used functions ********************************************************\n    void SetTunings(double, double,       // * While most users will set the tunings once in the \n                    double);         \t    //   constructor, this function gives the user the option\n                                          //   of changing tunings during runtime for Adaptive control\n    void SetTunings(double, double,       // * overload for specifying proportional mode\n                    double, int);         \t  \n\n\tvoid SetControllerDirection(int);\t  // * Sets the Direction, or \"Action\" of the controller. DIRECT\n\t\t\t\t\t\t\t\t\t\t  //   means the output will increase when error is positive. REVERSE\n\t\t\t\t\t\t\t\t\t\t  //   means the opposite.  it's very unlikely that this will be needed\n\t\t\t\t\t\t\t\t\t\t  //   once it is set in the constructor.\n    void SetSampleTime(int);              // * sets the frequency, in Milliseconds, with which \n                                          //   the PID calculation is performed.  default is 100\n\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t  \n  //Display functions ****************************************************************\n\tdouble GetKp();\t\t\t\t\t\t  // These functions query the pid for interal values.\n\tdouble GetKi();\t\t\t\t\t\t  //  they were created mainly for the pid front-end,\n\tdouble GetKd();\t\t\t\t\t\t  // where it's important to know what is actually \n\tint GetMode();\t\t\t\t\t\t  //  inside the PID.\n\tint GetDirection();\t\t\t\t\t  //\n\n  private:\n\tvoid Initialize();\n\t\n\tdouble dispKp;\t\t\t\t// * we'll hold on to the tuning parameters in user-entered \n\tdouble dispKi;\t\t\t\t//   format for display purposes\n\tdouble dispKd;\t\t\t\t//\n    \n\tdouble kp;                  // * (P)roportional Tuning Parameter\n    double ki;                  // * (I)ntegral Tuning Parameter\n    double kd;                  // * (D)erivative Tuning Parameter\n\n\tint controllerDirection;\n\tint pOn;\n\n    double *myInput;              // * Pointers to the Input, Output, and Setpoint variables\n    double *myOutput;             //   This creates a hard link between the variables and the \n    double *mySetpoint;           //   PID, freeing the user from having to constantly tell us\n                                  //   what these values are.  with pointers we'll just know.\n\t\t\t  \n\tunsigned long lastTime;\n\tdouble outputSum, lastInput;\n\n\tunsigned long SampleTime;\n\tdouble outMin, outMax;\n\tbool inAuto, pOnE;\n};\n#endif\n\n"
        },
        {
          "name": "README.txt",
          "type": "blob",
          "size": 0.646484375,
          "content": "***************************************************************\n* Arduino PID Library - Version 1.2.1\n* by Brett Beauregard <br3ttb@gmail.com> brettbeauregard.com\n*\n* This Library is licensed under the MIT License\n***************************************************************\n\n - For an ultra-detailed explanation of why the code is the way it is, please visit: \n   http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/\n\n - For function documentation see:  http://playground.arduino.cc/Code/PIDLibrary (Click \"Libraries\" on the left panel. The link to the documentation is listed as \"PIDLibrary - Provides basic feedback control\".)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 0.7578125,
          "content": "#######################################\n# Syntax Coloring Map For PID Library\n#######################################\n\n#######################################\n# Datatypes (KEYWORD1)\n#######################################\n\nPID\tKEYWORD1\n\n#######################################\n# Methods and Functions (KEYWORD2)\n#######################################\n\nSetMode\tKEYWORD2\nCompute\tKEYWORD2\nSetOutputLimits\tKEYWORD2\nSetTunings\tKEYWORD2\nSetControllerDirection\tKEYWORD2\nSetSampleTime\tKEYWORD2\nGetKp\tKEYWORD2\nGetKi\tKEYWORD2\nGetKd\tKEYWORD2\nGetMode\tKEYWORD2\nGetDirection\tKEYWORD2\n\n#######################################\n# Constants (LITERAL1)\n#######################################\n\nAUTOMATIC\tLITERAL1\nMANUAL\tLITERAL1\nDIRECT\tLITERAL1\nREVERSE\tLITERAL1\nP_ON_E\tLITERAL1\nP_ON_M\tLITERAL1\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.5361328125,
          "content": "{\n  \"name\": \"PID\",\n  \"keywords\": \"PID, controller, signal\",\n  \"description\": \"A PID controller seeks to keep some input variable close to a desired setpoint by adjusting an output. The way in which it does this can be 'tuned' by adjusting three parameters (P,I,D).\",\n  \"url\": \"http://playground.arduino.cc/Code/PIDLibrary\",\n  \"include\": \"PID_v1\",\n  \"authors\":\n  [\n    {\n      \"name\": \"Brett Beauregard\"\n    }\n  ],\n  \"repository\":\n  {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/br3ttb/Arduino-PID-Library.git\"\n  },\n  \"frameworks\": \"arduino\"\n}\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.3828125,
          "content": "name=PID\nversion=1.2.1\nauthor=Brett Beauregard \nmaintainer=Brett Beauregard\nsentence=PID controller\nparagraph=A PID controller seeks to keep some input variable close to a desired setpoint by adjusting an output. The way in which it does this can be 'tuned' by adjusting three parameters (P,I,D).\ncategory=Signal Input/Output\nurl=http://playground.arduino.cc/Code/PIDLibrary\narchitectures=* \n"
        }
      ]
    }
  ]
}