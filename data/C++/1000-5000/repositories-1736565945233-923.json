{
  "metadata": {
    "timestamp": 1736565945233,
    "page": 923,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "haiku/haiku",
      "stars": 1949,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.0478515625,
          "content": "[*.{h,cpp,c}]\nindent_style = tab\nindent_size = 4\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6689453125,
          "content": "# Files generated by our buildsystem or reserved for local changes by the user\ngenerated*\nbuild/jam/UserBuildConfig\nbuild/user_config_headers\n\n# KDE backup files ending with a ~ (created by KDE and Qt text editors)\n*~\n# Vim temporary/lock files\n.*.sw?\n# Configuration directories for Visual Studio Code\n.vscode\n# Configuration directories for IntelliJ IDEA code editors\n.idea\n\n# compiled/optimized Python (created by Python optimizer when running scripts)\n*.pyc\n*.pyo\n\n# Mac OS X directory attributes (created by Mac OS X when opening files or\n# directories)\n.DS_Store\n\n# Project settings of the Genio IDE\n.genio\n\n# clangd related tooling for IDE code completion\ncompile_commands.json\n"
        },
        {
          "name": ".gitreview",
          "type": "blob",
          "size": 0.076171875,
          "content": "[gerrit]\nhost=git.haiku-os.org\nport=22\nproject=haiku.git\ndefaultbranch=master\n"
        },
        {
          "name": "3rdparty",
          "type": "tree",
          "content": null
        },
        {
          "name": "Jamfile",
          "type": "blob",
          "size": 4.1513671875,
          "content": "SubDir HAIKU_TOP ;\n\n# Prepare the optional build features before parsing the Jamfile tree.\nlocal architectureObject ;\nfor architectureObject in [ MultiArchSubDirSetup ] {\n\ton $(architectureObject) {\n\t\tinclude [ FDirName $(HAIKU_BUILD_RULES_DIR) BuildFeatures ] ;\n\n\t\t# Let the target platform depend on the external header directories such\n\t\t# that those will be unpacked before anything is built for the target\n\t\t# platform.\n\t\tDepends $(TARGET_PLATFORM) : [\n\t\t\tBuildFeatureAttribute gcc_syslibs_devel : c++-headers\n\t\t] [\n\t\t\tBuildFeatureAttribute gcc_syslibs_devel : gcc-headers\n\t\t] ;\n\t}\n}\n\n# Include required packages:\n# primary architecture\nAddHaikuImageSystemPackages [ FFilterByBuildFeatures\n\tbash bc freetype zlib\n\n\t!gcc2 @{ coreutils icu74 wget }@\n\tgcc2 @{ coreutils_x86 wget_x86 icu icu74_x86@secondary_x86 }@\n\tregular_image @{\n\t\tbzip2 expat ffmpeg6 glu gutenprint9 gzip\n\t\tlame less libedit libicns\n\t\tmesa mesa_devel mesa_swpipe@!gcc2 mesa_swrast@gcc2\n\t\tnetcat\n\t\tsed sharutils\n\t\tunzip which zip\n\n\t\t!gcc2 @{ diffutils findutils gawk grep tar tcpdump zstd }@\n\t\tgcc2 @{\n\t\t\tdiffutils_x86@secondary_x86 findutils_x86@secondary_x86\n\t\t\tmawk grep_x86@secondary_x86 tar_x86@secondary_x86\n\t\t\ttcpdump_x86@secondary_x86\n\t\t}@\n\t}@\n] ;\nAddHaikuImageSourcePackages [ FFilterByBuildFeatures\n\tbash bc\n\n\t!gcc2 @{ coreutils }@\n\tgcc2 @{ coreutils_x86 }@\n\n\tregular_image @{\n\t\texpat ffmpeg6 findutils grep gutenprint9 gzip\n\t\tlame less libicns\n\t\tsed sharutils\n\t\ttar wget which\n\t\t!gcc2 @{ gawk }@\n\t\tgcc2 @{ mawk }@\n\t}@\n] ;\nif $(HAIKU_PACKAGING_ARCHS[1]) != x86_gcc2 {\n\tAddHaikuImageSystemPackages [ FFilterByBuildFeatures gcc_syslibs ] ;\n}\n\nif $(HAIKU_PACKAGING_ARCHS[2]) {\n\t# secondary architectures\n\tlocal architectureObject ;\n\tfor architectureObject\n\t\t\tin [ MultiArchSubDirSetup $(HAIKU_PACKAGING_ARCHS[2-]) ] {\n\t\ton $(architectureObject) {\n\t\t\tAddHaikuImageSystemPackages [ FFilterByBuildFeatures\n\t\t\t\tfreetype icu zlib\n\n\t\t\t\tregular_image @{\n\t\t\t\t\tffmpeg6 glu jasper jpeg libavif libicns libpng16 libwebp mesa\n\t\t\t\t}@\n\t\t\t] ;\n\t\t\tif $(TARGET_PACKAGING_ARCH) != x86_gcc2 {\n\t\t\t\tAddHaikuImageSystemPackages [ FFilterByBuildFeatures gcc_syslibs\n\t\t\t\t\tmesa_swpipe ] ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n# If enabled, make sure that OpenSSL is added to the image.\nif [ FIsBuildFeatureEnabled openssl ] {\n\tAddHaikuImageSystemPackages openssl3 ;\n}\n\n# add additionally requested packages\nAddHaikuImageSystemPackages $(HAIKU_IMAGE_ADDITIONAL_PACKAGES) ;\n\n# Optionally we allow not to include the \"src\" subdirectory.\nif $(HAIKU_DONT_INCLUDE_SRC) {\n\t# Don't include \"src\", but at least include the stuff needed for the\n\t# build.\n\tSubInclude HAIKU_TOP src build ;\n\tSubInclude HAIKU_TOP src tools ;\n} else {\n\tSubInclude HAIKU_TOP src ;\n}\nif $(HAIKU_INCLUDE_3RDPARTY) {\n\tSubInclude HAIKU_TOP 3rdparty ;\n}\n\n# Perform deferred SubIncludes.\nExecuteDeferredSubIncludes ;\n\n# reset subdir\nSubDir HAIKU_TOP ;\n\n# Execute post-build-target user config rules.\nUserBuildConfigRulePostBuildTargets\t;\n\n# specify the Haiku repository contents\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) repositories Haiku ] ;\n\n# specify the actual Haiku image contents\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images HaikuImage ] ;\n\n# specify the additional image contents one for each boot type\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images NetBootArchive ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images FloppyBootImage ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images CDBootImage ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images HaikuCD ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images AnybootImage ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) images MMCImage ] ;\n\n# Check whether all requested optional packages do actually exist.\nlocal package ;\nlocal packageError ;\nfor package in $(HAIKU_ADDED_OPTIONAL_PACKAGES) {\n\tif ! [ on $(package) return $(HAIKU_OPTIONAL_PACKAGE_EXISTS) ] {\n\t\tEcho \"ERROR: Requested optional package \\\"$(package)\\\" does not\"\n\t\t\t\"exist.\" ;\n\t\tpackageError = 1 ;\n\t}\n}\nif $(packageError) {\n\tExit ;\n}\n\n# Pseudo-target to build all targets that are localized.\nNotFile LocalizedTargets ;\nDepends LocalizedTargets : $(HAIKU_LOCALIZED_TARGETS) ;\n\nNotFile catalogs ;\nDepends catalogs : $(HAIKU_LOCALE_CATALOGS) ;\n\nNotFile catkeys ;\nDepends catkeys : $(HAIKU_LOCALE_OUTPUT_CATKEYS) ;\n"
        },
        {
          "name": "Jamrules",
          "type": "blob",
          "size": 5.4482421875,
          "content": "# Haiku Jamrules\n\n# Make sure we are on a sane version of Jam.\nif ! [ Match \"(.*)-haiku-(.*)\" : $(JAMVERSION) ] {\n\tExit \"You can only build Haiku with Haiku's Jam, not Perforce Jam or\"\n\t\t\"some other variant (you are using $(JAMVERSION)).\" ;\n}\n\n# Make sure we are on a recent Jambase.\nif $(JAMBASEDATE) < 2018 {\n\tExit \"Your Jambase is too old ($(JAMBASEDATE)); please update it (likely\"\n\t\t\"by updating Jam itself.)\" ;\n}\n\n# Make sure HAIKU_TOP is a relative path (and prefer it to be the current or\n# parent directory.)\n#\n# This is done so that invocations to the compiler and other tools, which\n# under some circumstances inject the source's path into the generated file,\n# are passed relative paths, making builds more reproducible.\nif $(HAIKU_TOP) != \".\" && $(HAIKU_TOP) != \"..\"\n\t\t&& ! [ Match \"\\\\.\\\\./(.*)\" : $(HAIKU_TOP) ] {\n\tExit \"The present path to the project root is '$(HAIKU_TOP)', but you\"\n\t\t\"must be in the project root or a \\\"generated\\\" directory in order to\"\n\t\t\"build Haiku.\"\n\n\t\t\"(If you are, and are still seeing this message, run \"\n\t\t\"\\\"../configure --update\\\" to solve the issue.)\" ;\n}\n\n# Main directories used by the build.\nHAIKU_OUTPUT_DIR\t\t\t\t\t?= [ FDirName $(HAIKU_TOP) generated ] ;\nHAIKU_BUILD_OUTPUT_DIR\t\t\t\t?= [ FDirName $(HAIKU_OUTPUT_DIR) build ] ;\nHAIKU_BUILD_DIR\t\t\t\t\t\t?= [ FDirName $(HAIKU_TOP) build ] ;\nHAIKU_BUILD_RULES_DIR\t\t\t\t?= [ FDirName $(HAIKU_BUILD_DIR) jam ] ;\nHAIKU_OBJECT_DIR\t\t\t\t\t?= [ FDirName $(HAIKU_OUTPUT_DIR)\n\t\t\t\t\t\t\t\t\t\t\tobjects ] ;\nHAIKU_CATALOGS_OBJECT_DIR\t\t\t?= [ FDirName $(HAIKU_OBJECT_DIR)\n\t\t\t\t\t\t\t\t\t\t\tcatalogs ] ;\nHAIKU_COMMON_PLATFORM_OBJECT_DIR\t?= [ FDirName $(HAIKU_OBJECT_DIR) common ] ;\nHAIKU_DOWNLOAD_DIR\t\t\t\t\t?= [ FDirName $(HAIKU_OUTPUT_DIR)\n\t\t\t\t\t\t\t\t\t\t\tdownload ] ;\nHAIKU_OPTIONAL_BUILD_PACKAGES_DIR\t?= [ FDirName $(HAIKU_OUTPUT_DIR)\n\t\t\t\t\t\t\t\t\t\t\tbuild_packages ] ;\n\n# Absolutely rooted versions of some of the main directories\nHAIKU_ABSOLUTE_TOP\t\t\t\t\t?= [ FDirName $(PWD) $(HAIKU_TOP) ] ;\nHAIKU_ABSOLUTE_OUTPUT_DIR\t\t\t?= [ FDirName $(PWD) $(HAIKU_OUTPUT_DIR) ] ;\n\n# Cache files for header scanning and jamfile caching\nHCACHEFILE = header_cache ;\nJCACHEFILE = jamfile_cache ;\nLOCATE on $(HCACHEFILE) $(JCACHEFILE) = $(HAIKU_BUILD_OUTPUT_DIR) ;\n\n# include BuildConfig\nlocal buildConfig = [ GLOB $(HAIKU_BUILD_OUTPUT_DIR) : BuildConfig ] ;\nif ! $(buildConfig) {\n\tECHO \"No `BuildConfig' found in $(HAIKU_BUILD_OUTPUT_DIR)!\" ;\n\tEXIT \"Run ./configure in the source tree's root directory first!\" ;\n}\nLOCATE on BuildConfig = $(HAIKU_BUILD_OUTPUT_DIR) ;\ninclude BuildConfig ;\n\n# set HAIKU_PACKAGING_ARCH, the primary packaging architecture\nHAIKU_PACKAGING_ARCH = $(HAIKU_PACKAGING_ARCHS[1]) ;\n\n# The build setup and rules are neatly organized in several files. Include\n# them now. Start with the side-effect-less rules, since they are the most\n# likely to be used in the top level context (i.e. not only in rules).\n# At the end include BuildSetup that sets up global variables etc. The\n# optional user-defined UserBuildConfig is included thereafter.\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) HelperRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) MathRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) ArchitectureRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) BeOSRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) BuildFeatureRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) LocaleRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) CommandLineArguments ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) ConfigRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) FileRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) HeadersRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) KernelRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) BootRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) ImageRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) CDRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) MainBuildRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) MiscRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) OverriddenJamRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) PackageRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) RepositoryRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) SystemLibraryRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) TestsRules ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) BuildSetup ] ;\ninclude [ FDirName $(HAIKU_BUILD_RULES_DIR) DefaultBuildProfiles ] ;\n\n# Include the repositories for this architecture.\nlocal repositoriesDirectory\n\t= [ FDirName $(HAIKU_BUILD_RULES_DIR) repositories ] ;\nlocal repositories = HaikuPorts ;\nif $(HAIKU_BUILD_TYPE) = bootstrap {\n\trepositories = HaikuPortsCross ;\n}\n\nlocal repository ;\nfor repository in $(repositories) {\n\tlocal repositoryDirectory\n\t\t= [ FDirName $(repositoriesDirectory) $(repository) ] ;\n\tlocal file = [ Glob $(repositoryDirectory) : $(HAIKU_PACKAGING_ARCH) ] ;\n\tif $(file) {\n\t\tHAIKU_REPOSITORY_JAMFILE = $(file) ;\n\t\tinclude $(file) ;\n\t}\n}\n\n# Declare no-op user-overridable build rules.\nrule UserBuildConfigRulePostBuildTargets\t{ }\nrule UserBuildConfigRulePreImage\t\t\t{ }\nrule UserBuildConfigRulePostImage\t\t\t{ }\n\n# Include UserBuildConfig.\nif ! $(HAIKU_IGNORE_USER_BUILD_CONFIG) {\n\tlocal userBuildConfig\n\t\t= [ GLOB $(HAIKU_BUILD_RULES_DIR) : UserBuildConfig ] ;\n\tif $(userBuildConfig) {\n\t\tinclude $(userBuildConfig) ;\n\t}\n\n\t# allow for a separate UserBuildConfig per output directory\n\tlocal userBuildConfig\n\t\t= [ GLOB $(HAIKU_OUTPUT_DIR) : UserBuildConfig ] ;\n\tif $(userBuildConfig) {\n\t\tinclude $(userBuildConfig) ;\n\t}\n}\n\nDefineDefaultBuildProfiles ;\n\nPrepareConfigVariables ;\n"
        },
        {
          "name": "License.md",
          "type": "blob",
          "size": 1.603515625,
          "content": "The vast majority of code in this repository was written by the Haiku Project,\nand is licensed under the MIT license, which appears below. There are some\nnotable exceptions to this, such as the GNU C library (which is under the GPL)\nas well as many other files in this repository which are under other licenses.\nEvery piece of source code should have its license specified at the top, but\nthere is also a (probably) comprehensive set of known licenses in the\n`data/system/data/licenses` directory.\n\n\nThe MIT License\n-----------------------------------------------------------\n\nCopyright (c) <year> <copyright holders>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "ReadMe.Compiling.md",
          "type": "blob",
          "size": 9.3974609375,
          "content": "Building Haiku\n==========================\nThis is a overview into the process of building HAIKU from source.\nAn online version is available at <https://www.haiku-os.org/guides/building/>.\n\nOfficial releases of Haiku are at <https://www.haiku-os.org/get-haiku>.\nThe (unstable) nightly builds are available at <https://download.haiku-os.org/>.\n\nWe currently support the following platforms:\n * Haiku\n * Linux\n * FreeBSD\n * macOS\n\nRequired Software\n----------------------------\nTools provided within Haiku's repositories:\n * `jam` (Jam 2.5-haiku-20111222)\n * Haiku's cross-compiler\n\nThe tools to compile Haiku will vary, depending on the platform that you are\nusing to build Haiku. When building from Haiku, all of the necessary\ndevelopment tools are included in official releases (e.g. R1/beta1) and in the\nnightly builds.\n\n * `git`\n * `gcc`/`g++` and binutils (`as`, `ld`, etc., required by GCC)\n * (GNU) `make`\n * `bison` (2.4 or better)\n * `flex` and `lex` (usually a mini shell script invoking `flex`)\n * `makeinfo` (part of `texinfo`, only needed for building GCC 4)\n * `autoheader` (part of `autoconf`, needed for building GCC)\n * `automake` (needed for building GCC)\n * `awk` (GNU awk is most tested, but other implementations should work)\n * `nasm`\n * `wget`\n * `[un]zip`\n * `xorriso`\n * `mtools` (<https://gnu.org/software/mtools/intro.html>)\n * `python3`\n * case-sensitive file system\n\nWhether they are installed can be tested by running them in a shell with\nthe `--version` parameter.\n\nThe following libraries (and their respective headers) are required:\n * `zlib`\n * `zstd`\n\n### Haiku for ARM\nIf you want to compile Haiku for ARM, you will also need:\n\n * `mkimage` (<http://www.denx.de/wiki/U-Boot/WebHome>)\n\n### On macOS\n\nDisk Utility can create a case-sensitive disk image of at least 3 GiB in size.\nThe following ports need to be installed:\n * `expat`\n * `gawk`\n * `gettext`\n * `libiconv`\n * `gsed`\n * `cdrtools`\n * `nasm`\n * `wget`\n * `less`\n * `mpfr`\n * `gmp`\n * `libmpc`\n * `bison` (updated to the latest version)\n\nMore information about individual distributions of Linux and BSD can be found\nat <https://haiku-os.org/guides/building/pre-reqs>.\n\nDownloading Haiku's sources\n--------------------------------------------------\nThere are two parts to Haiku's sources &mdash; the code for Haiku itself and a set\nof build tools for compiling Haiku on an operating system other than Haiku.\nThe buildtools are needed only for non-Haiku platforms.\n\nAnonymous checkout:\n```\ngit clone https://review.haiku-os.org/haiku.git\ngit clone https://review.haiku-os.org/buildtools.git\n```\n\nIf you have commit access:\n```\ngit clone ssh://git.haiku-os.org/haiku\ngit clone ssh://git.haiku-os.org/buildtools\n```\n\nBuilding Jam\n-------------------------------------------\n(*This step applies only to non-Haiku platforms. Haiku already ships with the correct version of Jam*)\n\nChange to the `buildtools` folder and run the following commands to\ngenerate and install `jam`:\n```\ncd buildtools/jam\nmake\nsudo ./jam0 install\n```\nOr,  if you don't want to install `jam` systemwide:\n```\n./jam0 -sBINDIR=$HOME/bin install\n```\n\nConfiguring the build\n-------------------------------------\nThe `configure` script generates a file named `BuildConfig` in the\n`generated/build` directory. As long as `configure` is not modified (!) and the\ncross-compilation tools have not been updated, there is no need to call it again.\nFor rebuilding, you only need to invoke `jam` (see below). If you don't\nupdate the source tree very frequently, you may want to execute `configure`\nafter each update just to be on the safe side.\n\nDepending on your goal, there are several different ways to configure Haiku.\nThe first way is to call configure from within your Haiku checkout's root. That\nwill prepare a folder named 'generated', which will contain the compiled objects.\nAnother option is to manually created one or more `generated.*` folders and run\nconfigure from within them. For example, imagine the following directory setup:\n```\nbuildtools/\nhaiku/\nhaiku/generated.x86gcc2\n```\n\n### Configure an x86_64 (GCC 8) build\n```bash\ncd haiku/generated.x86_64\n../configure --cross-tools-source ../../buildtools --build-cross-tools x86_64\n```\n\n### Configure a 32-bit GCC 2.95/GCC 8 Hybrid, from a non-Haiku platform\n```bash\ncd haiku/generated.x86gcc2\n../configure \\\n\t--cross-tools-source ../../buildtools/ \\\n\t--build-cross-tools x86_gcc2 \\\n\t--build-cross-tools x86\n```\n\n### Configure a 32-bit GCC 2.95/GCC 8 Hybrid, from Haiku\n```bash\ncd haiku/generated.x86gcc2\n../configure --target-arch x86_gcc2 --target-arch x86\n```\n\nAdditional information about GCC Hybrids can be found on the website,\n<https://www.haiku-os.org/guides/building/gcc-hybrid>.\n\n### Configure options\nThe various runtime options for configure are documented in its onscreen help\n```bash\n./configure --help\n```\n\nBuilding via Jam\n----------------------------\n\nHaiku can be built in either of two ways, as disk image file (e.g. for use\nwith emulators, to be written directly to a usb stick, burned as a compact\ndisc) or as installation in a directory.\n\n### Running Jam\n\nThere are various ways in which you can run `jam`:\n\n * If you have a single generated folder, you can run 'jam' from the top level of Haiku's trunk.\n * If you have one or more generated folders, (e.g. generated.x86gcc2),\n   you can `cd` into that directory and run `jam`.\n * In either case, you can `cd` into a certain folder in the source tree (e.g.\n   src/apps/debugger) and run jam -sHAIKU_OUTPUT_DIR=<path to generated folder>\n\nBe sure to read `build/jam/UserBuildConfig.ReadMe` and `UserBuildConfig.sample`,\nas they contain information on customizing your build of Haiku.\n\n### Building a Haiku anyboot image (Nightly)\n```\njam -q @nightly-anyboot\n```\n\nThis generates an image file named `haiku-nightly-anyboot.iso` in your output\ndirectory under `generated/`.\n\n### Building a Haiku raw image (Nightly)\n```\njam -q @nightly-raw\n```\n\nThis generates an image file named `haiku.image` in your output directory under\n`generated/`.\n\n### Building a VMware image file\n```\njam -q @nightly-vmware\n```\n\nThis generates an image file named `haiku.vmdk` in your output\ndirectory under `generated/`.\n\n### Directory Installation\n```\nHAIKU_INSTALL_DIR=/Haiku jam -q @install\n```\n\nInstalls all Haiku components into the volume mounted at \"/Haiku\" and\nautomatically marks it as bootable. To create a partition in the first place\nuse DriveSetup and initialize it to BFS.\n\nNote that installing Haiku in a directory only works as expected under Haiku,\nbut it is not yet supported under Linux and other non-Haiku platforms.\n\n### Building individual components\nIf you don't want to build the complete Haiku, but only a certain\napp/driver/etc. you can specify it as argument to jam, e.g.:\n```\njam -q Debugger\n```\nAlternatively, you can `cd` to the directory of the component you want to\nbuild and run `jam` from there. **NOTE:** if your generated directory is named\nsomething other than `generated/`, you will need to tell `jam` where it is:\n```\njam -q -sHAIKU_OUTPUT_DIR=<path to generated folder>\n```\nYou can also force the rebuild of a component by using the `-a` parameter:\n```\njam -qa Debugger\n```\n\nBootstrap Build\n----------------\nNew architectures (and occasionally existing ones) will require a bootstrap\nbuild to compile *build packages*. (Catch-22 software packages which are needed\nto compile Haiku, but need to be initially compiled under Haiku)\n\n### Pre-requirements\n  * All of the standard tools in the Required Software section above.\n  * The following repositories on disk in the same general location\n    * haiku (https://git.haiku-os.org/haiku)\n    * buildtools (https://git.haiku-os.org/buildtools)\n    * haikuporter (https://github.com/haikuports/haikuporter.git)\n    * haikuports.cross (https://github.com/haikuports/haikuports.cross.git)\n    * haikuports (https://github.com/haikuports/haikuports.git)\n\n### Setting Up a Bootstrap build\nCreate a clean build directory under the haiku repo.\n```\nmkdir generated.myarch && cd generated.myarch\n```\n\nConfigure Haiku's build system for a bootstrap build specifying the location\nof all of the repositories above.\n```\n../configure -j4 \\\n  --build-cross-tools myarch --cross-tools-source ../../buildtools \\\n  --bootstrap ../../haikuporter/haikuporter ../../haikuports.cross ../../haikuports\n```\n\nOnce the build system is configured for bootstrap, we now can begin building\nthe bootstrap image.\n\n```\njam -q @bootstrap-raw\n```\n\nIf you are bootstrapping for an architecture Haiku already boots on, the generated\ndisk image can be used to compile *build packages* needed for the standard\nHaiku build.\n\nIf you are bootstrapping for a new architecture which doesn't build yet, you will\nneed to leverage the ```unbootstrap.sh``` script to hack the generated bootstrap\npackages into non-bootstrap packages which can be temporarily used as\n*build packages*.\n\nRunning\n----------------\nGenerally there are two ways of running Haiku: on real hardware using a\npartition, and on emulated hardware using an emulator (like VirtualBox, or QEMU).\n\n### On Real Hardware\nIf you have installed Haiku to its own partition you can include this\npartition in your bootmanager and try to boot Haiku like any other OS you\nhave installed. To include a new partition in the Haiku bootmanager, start\nthe BootManager configurator by running:\n```\nBootManager\n```\n\n### On Emulated Hardware\nFor emulated hardware you should build a disk image (see above). How to set up\nthis image depends on your emulator. If you use QEMU, you can usually just\nprovide the path to the image as command line argument to the `qemu`\nexecutable.\n"
        },
        {
          "name": "ReadMe.md",
          "type": "blob",
          "size": 2.3955078125,
          "content": "Haiku\n=======================\n**[Homepage](https://www.haiku-os.org/)\n| [Mailing Lists](https://www.haiku-os.org/community/ml)\n| [IRC Channels](https://www.haiku-os.org/community/irc)\n| [Issue Tracker](https://dev.haiku-os.org/)\n| [API docs](https://api.haiku-os.org)**\n\nHaiku is an open-source operating system that specifically targets personal\ncomputing. Inspired by the BeOS, Haiku is fast, simple to use, easy to learn\nand yet very powerful.\n\nGoals\n------------\n * Sensible defaults with minimal configuration required.\n * Clean, clear, concise code.\n * Unified desktop environment.\n\nTrying Haiku\n---------------\nHaiku provides pre-built [nightly images](http://download.haiku-os.org/) and\n[release images](https://www.haiku-os.org/get-haiku). Haiku is compatible\nwith a large variety of hardware, but in case you don't want to \"take the\nplunge\" and install Haiku on bare metal, you can install it on a virtual\nmachine (VM) instead. If you've never used a VM before, you can follow one of\nthe [\"Emulating Haiku\"](https://www.haiku-os.org/guides/virtualizing/) guides.\n\nCompiling Haiku\n---------------\nSee `ReadMe.Compiling`.\n\nContributing\n-------------------\nHaiku is a meritocratic open source project with a large variety of tasks. Even\nif you can't write code, *you can still help*! Haiku needs designers,\n(technical) writers, translators, testers... [Get involved](https://www.haiku-os.org/community/getting-involved/)\nand help out!\n\n### Contributing code\nIf you're submitting a patch to us, please make sure you're following the\n[patch submitting guidelines](https://dev.haiku-os.org/wiki/CodingGuidelines/SubmittingPatches).\n\nIf you're having trouble finding something in the source tree, you can use\none of our web-based source code browsers:\n\n * https://xref.landonf.org/ (OpenGrok, provided by Landon Fuller)\n * https://git.haiku-os.org/ (git, provided by Haiku, Inc.)\n\n### Contributing documentation\nThe main piece of documentation that still needs work are the API docs (found\nin the tree at `docs/user`). Just find an undocumented class, write\ndocumentation for it, and [submit a patch](https://dev.haiku-os.org/wiki/CodingGuidelines/SubmittingPatches).\n\n### Contributing translations\nSee [wiki:i18n](https://dev.haiku-os.org/wiki/i18n).\n\n### Contributing software ports\nSee [HaikuPorts](https://github.com/haikuports/haikuports/).\n\n### Contributing to our infrastructure\nSee [Infrastructure](https://github.com/haiku/infrastructure/).\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 37.8798828125,
          "content": "#!/bin/sh\n#\n# configure [ <options> ]\n\n# usage\n#\n# Prints usage.\n#\nusage()\n{\n\tcat << EOF\n\nUsage: $0 <options>\noptions:\n  --help                      Prints out this help.\n  --update                    Re-runs last configure invocation [must be given\n                              as first option!]\n  --bootstrap <haikuporter> <HaikuPorts cross repo> <HaikuPorts repo>\n                              Prepare for a bootstrap build. No pre-built\n                              packages will be used, instead they will be built\n                              from the sources (in several phases).\n                              <haikuporter> is the path to the haikuporter tool\n                              suitable for the host platform.\n                              <HaikuPorts cross repo> is the path to a checked\n                              out HaikuPorts cross-compilation repository.\n                              <HaikuPorts repo> is the path to a checked out\n                              HaikuPorts repository.\n  --build-cross-tools <arch>\n                              Assume cross compilation.\n                              Toolchain will be compiled and placed in the\n                              output directory under \"cross-tools\". The\n                              HAIKU_* tools variables will be set accordingly.\n                              <arch> specifies the target architecture, either\n                              \"x86_gcc2\", \"x86\", \"x86_64\", \"ppc\", \"m68k\",\n                              \"arm\", \"arm64\", \"riscv64\", \"sparc\"\n                              This option and --cross-tools-prefix can be\n                              specified multiple times. The first cross tools\n                              specify the primary tools, the subsequent ones the\n                              secondary tools (for \"hybrid\" images).\n  --cross-tools-prefix <prefix>\n                              Assume cross compilation. <prefix> should be a\n                              path to the directory where the cross\n                              compilation tools are located, plus the platform\n                              prefix, e.g. \"/path/to/tools/i586-pc-haiku-\".\n                              This overrides the HAIKU_* tool variables.\n  --cross-tools-source <buildtools dir>\n                              Toolchain sources for cross compilation.\n                              <buildtools dir> defines the location of the\n                              buildtools sources.\n  --distro-compatibility <level>\n                              The distribution's level of compatibility with\n                              the official Haiku distribution. The generated\n                              files will contain the respective trademarks\n                              accordingly.\n                              official -- the official Haiku distribution.\n                              compatible -- a Haiku Compatible (tm) distro.\n                              default -- any other distro (default value).\n  --host-only                 Configure for building tools for the build host\n                              only. Haiku cannot be built when configured like\n                              this.\n  --include-sources           Includes the source code of projects that require\n                              either an offer of source code or a copy of the\n                              patched sources. This is preferable when\n                              distributing on physical mediums.\n  --include-3rdparty          Include 3rdparty/ in the build system.\n  -j<n>                       Only relevant for --build-cross-tools. Is passed\n                              on to the make building the build tools.\n  --no-downloads              Do not download anything. Useful when trying to\n                              bootstrap and build Haiku from source only.\n  --sysroot                   The location of the cross-compiler sysroot,\n                              primarily for CI environments or cross-compilers\n                              used outside of the Haiku build system.\n  --target-arch <arch>        Haiku only: Specify the target architecture to\n                              build for. Must be one of the architectures of the\n                              host system. The installed build tools for that\n                              architecture will be used.\n                              This option can be specified multiple times. The\n                              first occurrence specifies the primary\n                              architecture of the Haiku to build, subsequent\n                              ones the secondary architectures.\n  --use-clang <arch>          Build with host Clang instead of GCC cross\n                              compiler, targeting <arch>\n  --use-gcc-pipe              Build with GCC option -pipe. Speeds up the build\n                              process, but uses more memory.\n  --use-gcc-graphite          Build with GCC Graphite engine for loop\n                              optimizations. (Only for GCC 4+.)\n  --use-32bit                 Use -m32 flag on 64bit host gcc compiler.\n  --no-full-xattr             Do not use Linux/*BSD/Darwin's native extended file\n                              attributes as Haiku attributes. If they are still\n                              available, they will be used to store hashes for\n                              the attribute emulation layer.\n  --no-xattr                  Do not use Linux/*BSD/Darwin's native extended file\n                              attributes for Haiku extended attributes at all,\n                              even if they are available.\n  --with-gdb <gdb sources dir>\n                              specify the path to a GDB source dir, to build\n                              GDB for each arch we build the cross-tools for.\n  --use-stack-protector       Build with stack protection enabled\n  --efi-signing-key           Private keyfile to sign any EFI bootloaders\n\nenvironment variables:\n  CC                          The host compiler. Defaults to \"gcc\".\n  HAIKU_AR_<arch>             The static library archiver for <arch>.\n                              Defaults to \"ar\".\n  HAIKU_CC_<arch>             The compiler for <arch>. Defaults to \"gcc\".\n  HAIKU_LD_<arch>             The <arch> linker. Defaults to \"ld\".\n  HAIKU_OBJCOPY_<arch>        The <arch> objcopy to be used. Defaults to\n                              \"objcopy\".\n  HAIKU_RANLIB_<arch>         The static library indexer for <arch>. Defaults\n                              to \"ranlib\".\n  HAIKU_STRIP_<arch>          The <arch> strip command. Defaults to \"strip\".\n  HAIKU_NASM                  The nasm assembler (x86 and x86_64 only).\n  HAIKU_CPPFLAGS_<arch>       The preprocessor flags for target architecture\n                              <arch>. Defaults to \"\".\n  HAIKU_CCFLAGS_<arch>        The C flags for target architecture <arch>.\n                              Defaults to \"\".\n  HAIKU_CXXFLAGS_<arch>       The C++ flags for target architecture <arch>.\n                              Defaults to \"\".\n  HAIKU_LINKFLAGS_<arch>      The flags passed to the compiler when linking for\n                              target architecture <arch>. Defaults to \"\".\n  HAIKU_LDFLAGS_<arch>        The linker flags for target architecture <arch>.\n                              Defaults to \"\".\n  HAIKU_ARFLAGS_<arch>        The flags passed to HAIKU_AR for target\n                              architecture <arch> for archiving. Defaults to\n                              \"cru\".\n  HAIKU_UNARFLAGS_<arch>      The flags passed to HAIKU_AR for target\n                              architecture <arch> for unarchiving. Defaults to\n                              \"x\".\n\nNon-default output directories:\n  By default all objects, build configuration, and other related files are\n  stored in /path/to/haiku_source/generated.  To store objects in a non-default\n  location, run \"../../relative/path/to/haiku_source/configure <options>\" from\n  within your non-default location.  \"jam [ options ] targets\" can then be run\n  directly inside your non-default location.  Another option is to invoke \"jam\n  [ options ] targets\" from within haiku_source.  This can be accomplished by\n  either \"export HAIKU_OUTPUT_DIR=your non-default location\" before invoking\n  jam or by creating a symlink of haiku_source/generated pointing to your\n  non-default location and running jam.\n\n\nEOF\n}\n\n# assertparam\n#\n# Checks whether at least one parameter is left.\n#\nassertparam()\n{\n\tif [ $2 -lt 2 ]; then\n\t\techo $0: \\`$1\\': Parameter expected.\n\t\texit 1\n\tfi\n}\n\n# assertparams\n#\n# Checks whether at least a certain number of parameters is left.\n#\nassertparams()\n{\n\tif [ $3 -le $2 ]; then\n\t\techo $0: \\`$1\\': Not enough parameters.\n\t\texit 1\n\tfi\n}\n\n# absolute_path\n#\n# returns the absolute path of a given path.\n#\nabsolute_path()\n{\n\tif [ \"x$1\" != \"x${1#/}\" ]; then\n\t\techo \"$1\"\n\telse\n\t\techo \"`pwd`/$1\"\n\tfi\n}\n\n# check_dir_exists\n#\n# check if a directory exists or not\n#\ncheck_dir_exists()\n{\n\tif [ -d \"$1\" ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\n# check_file_exists\n#\n# check if a file exists or not\n#\ncheck_file_exists()\n{\n\tif [ -f \"$1\" ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\n# real_path\n#\n# returns the realpath of a symbolic link.\n#\nreal_path()\n{\n\tperl -MCwd=realpath -e'print realpath($ARGV[0]), \"\\n\"' \"$1\"\n}\n\n# relative_to\n#\n# returns $1 relative to $2\n#\nrelative_to()\n{\n\tperl -e 'use File::Spec; print File::Spec->abs2rel(@ARGV) . \"\\n\"' \\\n\t\t\"$1\" \"$2\"\n}\n\n# valid_toolchain\n#\n# check if a toolchain is valid\n#\nvalid_toolchain()\n{\n\tTRIPLET=\"$1\"\n\tBASE=\"$2\"\n\tSOURCE=\"$3\"\n\tif [ ! -d \"$BASE\" ]; then\n\t\treturn 1\n\tfi\n\tif [ -f \"$BASE/bin/$TRIPLET-gcc\" ]; then\n\t\t[ \"$BASE/bin/$TRIPLET-gcc\" -nt \"$SOURCE/legacy/gcc/configure\" ] && \\\n\t\t\t[ \"$BASE/bin/$TRIPLET-gcc\" -nt \"$SOURCE/gcc/gcc/configure\" ]\n\t\treturn $?\n\tfi\n\treturn 1\n}\n\n# is_legacy_gcc\n#\n# Determines if the specified GCC version is a \"legacy\" (i.e. GCC < 4) one.\n#\nis_legacy_gcc()\n{\n\tif [ `echo $1 | cut -d'.' -f1` -lt 4 ]; then\n\t\techo 1\n\telse\n\t\techo 0\n\tfi\n}\n\n# standard_gcc_settings\n#\n# Sets the variables for a GCC platform.\n#\nstandard_gcc_settings()\n{\n\tlocal gcc=\"$1\"\n\n\tif which greadlink > /dev/null 2>&1; then\n\t\treadlink=\"greadlink -e\"\n\telif which realpath > /dev/null 2>&1; then\n\t\treadlink=realpath\n\telif readlink -e / > /dev/null 2>&1; then\n\t\treadlink=\"readlink -e\"\n\telse\n\t\treadlink=real_path\n\tfi\n\n\t# PLATFORM_LINKLIBS\n\tlocal gcclib=`$gcc -print-libgcc-file-name`\n\tlocal gccdir=`dirname ${gcclib}`\n\n\tlocal gccRawVersion=`$gcc -dumpversion`\n\tlocal gccMachine=`$gcc -dumpmachine`\n\n\t# determine architecture from machine triple\n\tcase $gccMachine in\n\t\tarm-*)\t\ttargetCpu=arm;;\n\t\taarch64-*)\ttargetCpu=arm64;;\n\t\ti?86-*)\t\ttargetCpu=x86;;\n\t\tm68k-*)\t\ttargetCpu=m68k;;\n\t\tpowerpc-*)\ttargetCpu=ppc;;\n\t\triscv64-*)\ttargetCpu=riscv64;;\n\t\tsparc64-*)\ttargetCpu=sparc;;\n\t\tx86_64-*)\ttargetCpu=x86_64;;\n\t\t*)\n\t\t\techo \"Unsupported gcc target machine: $gccMachine\" >&2\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\n\tlocal targetArch=$targetCpu\n\n\tcase $gccRawVersion in\n\t\t2.9*)\n\t\t\t# check for correct (most up-to-date) legacy compiler and complain\n\t\t\t# if an older one is installed\n\t\t\tif [ $gccRawVersion != $haikuRequiredLegacyGCCVersion ]; then\n\t\t\t\techo \"GCC version $haikuRequiredLegacyGCCVersion is required!\";\n\t\t\t\techo \"Please download it from www.haiku-os.org...\";\n\t\t\t\texit 1;\n\t\t\tfi\n\n\t\t\ttargetArch=x86_gcc2\n\t\t\t;;\n\tesac\n\n\tlocal bootLibgcc\n\tlocal bootLibSupCxx\n\tlocal bootCxxHeaders\n\tlocal boot32Libgcc\n\tlocal boot32LibSupCxx\n\tlocal boot32CxxHeaders\n\tcase $gccMachine in\n\t\tx86_64-*)\n\t\t\t# Boot loader is 32-bit, need the 32-bit libs and c++ config\n\t\t\tboot32Libgcc=`$gcc -m32 -print-file-name=libgcc.a`\n\t\t\tboot32LibSupCxx=`$gcc -m32 -print-file-name=libsupc++.a`\n\t\t\tbootLibgcc=`$gcc -print-file-name=libgcc.a`\n\t\t\tbootLibSupCxx=`$gcc -print-file-name=libsupc++.a`\n\n\t\t\tlocal headersBase=$gccdir/../../../..\n\t\t\tlocal headers=$headersBase/$gccMachine/include/c++/$gccRawVersion\n\t\t\tif [ ! -d $headers ]; then\n\t\t\t\theaders=$headersBase/include/c++/$gccRawVersion\n\t\t\tfi\n\t\t\tboot32CxxHeaders=\"$headers/$gccMachine/32\"\n\t\t\tbootCxxHeaders=\"$headers/$gccMachine\"\n\t\t\t;;\n\tesac\n\n\t# determine whether graphite loop optimization should/can be used\n\tlocal useGraphite=`get_variable HAIKU_USE_GCC_GRAPHITE_$targetCpu`\n\tif [ -z \"$useGraphite\" ]; then\n\t\tuseGraphite=$useGccGraphiteDefault\n\tfi\n\n\tif [ \"$useGraphite\" != 0 ]; then\n\t\tUNUSED=`echo \"int main() {}\" | $gcc -xc -c -floop-block - 2>&1`\n\t\tif [ $? != 0 ]; then\n\t\t\techo \"GCC Graphite loop optimizations cannot be used on $targetArch\"\n\t\t\tuseGraphite=0\n\t\tfi\n\tfi\n\n\tset_variable HAIKU_CPU_$targetArch $targetCpu\n\n\tget_build_tool_path CC_$targetArch \"$gcc\"\n\tset_variable HAIKU_CC_IS_LEGACY_GCC_$targetArch \\\n\t\t`is_legacy_gcc $gccRawVersion`\n\tset_variable HAIKU_CC_IS_CLANG_$targetArch $useClang\n\tset_variable HAIKU_GCC_MACHINE_$targetArch $gccMachine\n\tset_variable HAIKU_GCC_LIB_DIR_$targetArch $gccdir\n\tset_variable HAIKU_BOOT_CXX_HEADERS_DIR_$targetArch \"$bootCxxHeaders\"\n\tset_variable HAIKU_BOOT_LIBSUPCXX_$targetArch \"$bootLibSupCxx\"\n\tset_variable HAIKU_BOOT_LIBGCC_$targetArch $bootLibgcc\n\tset_variable HAIKU_BOOT_32_CXX_HEADERS_DIR_$targetArch \"$boot32CxxHeaders\"\n\tset_variable HAIKU_BOOT_32_LIBSUPCXX_$targetArch \"$boot32LibSupCxx\"\n\tset_variable HAIKU_BOOT_32_LIBGCC_$targetArch $boot32Libgcc\n\tset_variable HAIKU_USE_GCC_GRAPHITE_$targetArch $useGraphite\n\n\tstandard_gcc_settings_targetArch=$targetArch\n}\n\n# set_variable\n#\n# Set the value of a variable.\n#\nset_variable()\n{\n\teval \"$1=\\\"$2\\\"\"\n}\n\n# get_variable\n#\n# Echo the value of a variable.\n#\nget_variable()\n{\n\teval \"echo \\${$1}\"\n}\n\n# set_default_value\n#\n# Set the value for a variable, if no value is set yet.\n#\nset_default_value()\n{\n\teval \"$1=\\${$1-$2}\"\n}\n\n# get_build_tool_path\n#\n# Gets a usable absolute path of a build tool.\n#\nget_build_tool_path()\n{\n\tlocal var=\"HAIKU_$1\"\n\tlocal varval=\"`get_variable $var`\"\n\tlocal cmd=\"$2\"\n\n\tif [ ! -z \"$varval\" ]; then\n\t\t# this variable is already set (probably by user) so grab its contents\n\t\tcmd=$varval\n\tfi\n\n\tlocal path=${cmd%% *}\n\n\tif [ -f \"$path\" ]; then\n\t\t# get absolute path from relative path\n\t\tlocal oldPwd=\"`pwd`\"\n\t\tcd \"`dirname \"$path\"`\"\n\t\tpath=\"`pwd`/`basename \"$path\"`\"\n\t\tcd $oldPwd\n\telse\n\t\twhich \"$path\" > /dev/null 2>&1 || {\n\t\t\techo \"Build tool \\\"$path\\\" not found (maybe specify it in $var?)\" >&2\n\t\t\texit 1\n\t\t}\n\tfi\n\n\tif test \"${cmd#* }\" != \"$cmd\"; then\n\t\t# $cmd contains arguments, so preserve them (and only them)\n\t\tcmd=${cmd#* }\n\telse\n\t\t# $cmd does not contain arguments, so unset it\n\t\tcmd=\n\tfi\n\teval \"$var=\\\"$path $cmd\\\"\"\n}\n\n# check_native_xattrs\n#\n# Checks the host platform's support for extended attributes.\n# 0: no support, 1: only enough for xattr-ref, 2: full support\n#\ncheck_native_xattrs()\n{\n\tlocal xattr_set=\n\tlocal xattr_set_args=\n\tlocal xattr_get=\n\tlocal xattr_get_args=\n\tcase $HOST_PLATFORM in\n\t\thaiku_host)\n\t\t\txattr_set=\"addattr\"; xattr_set_args=\"\\$NAME \\\"\\$VALUE\\\"\"\n\t\t\txattr_get=\"catattr\"; xattr_get_args=\"\\$NAME\"\n\t\t\t;;\n\t\tdarwin)\n\t\t\txattr_set=\"xattr\"; xattr_set_args=\"-w \\$NAME \\\"\\$VALUE\\\"\"\n\t\t\txattr_get=\"xattr\"; xattr_get_args=\"-p \\$NAME\"\n\t\t\t;;\n\t\tfreebsd)\n\t\t\txattr_set=\"setextattr\"; xattr_set_args=\"user \\$NAME \\\"\\$VALUE\\\"\"\n\t\t\txattr_get=\"getextattr\"; xattr_get_args=\"user \\$NAME\"\n\t\t\t;;\n\t\tlinux)\n\t\t\txattr_set=\"setfattr\"; xattr_set_args=\"-n user.\\$NAME -v \\\"\\$VALUE\\\"\"\n\t\t\txattr_get=\"getfattr\"; xattr_get_args=\"-n user.\\$NAME\"\n\t\t\t;;\n\t\t*)\n\t\t\treturn 0\n\t\t\t;;\n\tesac\n\tif ! type $xattr_set >/dev/null 2>&1; then\n\t\techo \"$0: could not find $xattr_set, assuming host has no extended attributes\"\n\t\treturn 0\n\telif ! type $xattr_get >/dev/null 2>&1; then\n\t\techo \"$0: could not find $xattr_get, assuming host has no extended attributes\"\n\t\treturn 0\n\tfi\n\n\tmkdir -p \"$outputDir\"\n\techo \"xattr test file\" >\"$outputDir/xattrtest\"\n\tlocal i=0\n\t# on round 0, we test if we can set 3 attrs of 1K each (enough for xattr-ref)\n\t# on round 1, we test if we can set 3 attrs of 45K each (enough for full xattr)\n\twhile [ $i -lt 2 ]; do\n\t\tlocal j=0\n\t\twhile [ $j -lt 3 ]; do\n\t\t\tNAME=attr$j\n\t\t\tVALUE=`printf '%*s' $((1024 + $i * 45056)) \"\" | tr ' ' x`\n\t\t\tif [ `echo -n $VALUE | wc -c` -lt $((1024 + $i * 45056)) ]; then\n\t\t\t\techo \"$0: warning: could not generate test data for extended attributes\"\n\t\t\t\trm \"$outputDir/xattrtest\"\n\t\t\t\treturn $i\n\t\t\telif ! $xattr_set `eval echo \\\"$xattr_set_args\\\"` \\\n\t\t\t\t\t\"$outputDir/xattrtest\" >/dev/null 2>&1 ; then\n\t\t\t\trm \"$outputDir/xattrtest\"\n\t\t\t\treturn $i\n\t\t\tfi\n\t\t\tj=$((j+1))\n\t\tdone\n\t\ti=$((i+1))\n\tdone\n\trm \"$outputDir/xattrtest\"\n\treturn 2\n}\n\nis_in_list()\n{\n\tlocal element\n\tfor element in $2; do\n\t\tif [ \"$1\" = \"$element\" ]; then\n\t\t\treturn 0\n\t\tfi\n\tdone\n\treturn 1\n}\n\n# check for --help or -h and show usage immediately\nif [ \"$1\" = \"--help\" ] || [ \"$1\" = \"-h\" ]; then\n\tusage; exit 0;\nfi\n\n# get cwd and the source directory\ncurrentDir=`pwd`\ncd `dirname \"$0\"`\nsourceDir=`pwd`\ncd \"$currentDir\"\n\n# determine output directory\nif [ \"$currentDir\" = \"$sourceDir\" ]; then\n\toutputDir=$currentDir/generated\nelse\n\toutputDir=$currentDir\nfi\nbuildOutputDir=\"$outputDir/build\"\nHAIKU_BUILD_ATTRIBUTES_DIR=\"$outputDir/attributes\"\nbuildConfigFile=\"$buildOutputDir/BuildConfig\"\n\n# check for update request\nif [ \"$1\" = \"--update\" ]; then\n\tif ! [ -e \"$buildConfigFile\" ]; then\n\t\techo $0 --update: \\'$buildConfigFile\\' not found - updating not possible.\n\t\texit 1\n\tfi\n\t# get last configure invocation and flags from BuildConfig and call ourselves with it\n\tlastPwd=`grep \"#d \" \"$buildConfigFile\" | cut -c 4-`\n\tlastConfig=`grep \"#c \" \"$buildConfigFile\" | cut -c 4-`\n\tlastEnv=`grep \"#e \" \"$buildConfigFile\" | cut -c 4-`\n\tlastArgs=`grep \"#a \" \"$buildConfigFile\" | cut -c 4-`\n\tif [ -z \"$lastConfig\" ]; then\n\t\techo \"$0 --update: The previous configure invocation was not properly\" \\\n\t\t\t\"encoded into '$buildConfigFile' - updating not possible.\"\n\t\texit 1\n\tfi\n\tcd \"$lastPwd\"\n\tif [ -n \"$lastEnv\" ]; then\n\t\texport $lastEnv\n\tfi\n\t$lastConfig $lastArgs\n\texit $?\nfi\n\n# backup the passed arguments\nconfigureArgs=\"$@\"\nconfigurePath=$0\nconfigureDir=`dirname $configurePath`\n\n# backup relevant environs\nconfigureEnvirons=\nfor var in `env`; do\n\tcase \"$var\" in\n\t\tCC\\=*|HAIKU*\\=*|JAMSHELL\\=*|HOST_PYTHON\\=*)\n\t\t\tconfigureEnvirons=\"$configureEnvirons $var\"\n\t\t\t;;\n\tesac\ndone\n\n# ensure umask is not too restrictive\nif [ `umask` -gt 22 ]; then\n\techo Your umask is too restrictive \"(should be <= 0022;\" is actually `umask`\")\"\n\techo\n\techo Additionally, if the source tree was cloned with a too-restrictive umask,\n\techo you will need to run \\\"git checkout\\\" again to fix this.\n\texit 1\nfi\n\n# internal default parameter values\n#\nplatform=`uname`\nplatformMachine=`uname  -m`\ntargetArchs=\nbuildCrossTools=\nbuildCrossToolsScript=\"$sourceDir/build/scripts/build_cross_tools\"\nbuildCrossToolsJobs=\nuseClang=0\nuseGccGraphiteDefault=0\nunknownArchIndex=1\nhaikuTargetArchs=\ngdbSources=\n\nif [ -z \"$CC\" ]; then\n\tCC=gcc\nfi\nif [ $(is_legacy_gcc $($CC -dumpversion)) -ne 0 ]; then\n\tif [ $platform == \"Haiku\" ] && [ $platformMachine == \"BePC\" ]; then\n\t\tCC=gcc-x86\n\telse\n\t\techo The host tools cannot be built with a legacy version of GCC.\n\t\techo Please specify a more modern compiler in the \"CC\" environ.\n\t\texit 1\n\tfi\nfi\n\n# detect the build platform\ncase \"${platform}\" in\n\tDarwin)  HOST_PLATFORM=darwin ;;\n\tFreeBSD) HOST_PLATFORM=freebsd\n\t         if [ \"$HAIKU_HOST_USE_32BIT\" = 1 ] ; then\n\t         \techo Unsupported platform: FreeBSD ${platformMachine}\n\t         \texit 1\n\t         fi ;;\n\tHaiku)   HOST_PLATFORM=haiku_host ;;\n\tLinux)   HOST_PLATFORM=linux ;;\n\tOpenBSD) HOST_PLATFORM=openbsd ;;\n\t*)       echo Unsupported platform: ${platform}\n\t         exit 1 ;;\nesac\n\ncase $HOST_PLATFORM in\n\tdarwin|freebsd|openbsd) statCmd='stat -f' ;;\n\t*)                      statCmd='stat -c' ;;\nesac\n\n# ensure git checkout was not done with a restrictive umask\nif [ `$statCmd '%a' \"$sourceDir/data/system/boot/SetupEnvironment\"` -lt 644 ]; then\n\techo \"The source tree was cloned with a umask > 0022. It seems you\"\n\techo have already corrected your umask, but not re-checked-out the\n\techo source tree. Try running:\n\techo \"\tgit checkout --force\"\n\techo to fix this problem.\n\texit 1\nfi\n\n# exported (BuildSetup) default parameter values\n#\nGIT_DIR=`git -C \"$configureDir\" rev-parse --git-dir | sed 's/^gitdir: //'`\nHOST_GCC_MACHINE=`$CC -dumpmachine`\nHAIKU_INCLUDE_SOURCES=0\nHAIKU_INCLUDE_3RDPARTY=0\nHAIKU_DISTRO_COMPATIBILITY=default\nTARGET_PLATFORM=haiku\nHAIKU_USE_GCC_PIPE=0\nHAIKU_HOST_USE_32BIT=0\nHAIKU_HOST_USE_XATTR=\nHAIKU_HOST_USE_XATTR_REF=\nHAIKU_HOST_BUILD_ONLY=0\nHOST_EXTENDED_REGEX_SED=\"sed -r\"\nHOST_GCC_LD=`$CC -print-prog-name=ld`\nHOST_GCC_OBJCOPY=`$CC -print-prog-name=objcopy`\nHOST_SHA256=\nHOST_HAIKU_PORTER=\nHAIKU_PORTS=\nHAIKU_PORTS_CROSS=\nHAIKU_IS_BOOTSTRAP=0\nHAIKU_NO_DOWNLOADS=0\n\nHAIKU_PACKAGING_ARCHS=\n\nset_default_value HAIKU_NASM\t\tnasm\n\nif sha256sum < /dev/null > /dev/null 2>&1; then\n\tHOST_SHA256=sha256sum\nelif sha256 < /dev/null > /dev/null 2>&1; then\n\tHOST_SHA256=\"sha256 -q\"\nelif shasum < /dev/null > /dev/null 2>&1; then\n\tHOST_SHA256=\"shasum -a 256\"\nelse\n\techo \"Error: Neither sha256sum nor sha256 seem to be available!\" >&2\n\texit 1\nfi\n\nhaikuRequiredLegacyGCCVersion=\"2.95.3-haiku-2017_07_20\"\nexport haikuRequiredLegacyGCCVersion\n\t# version of legacy gcc required to build haiku\nsupportedTargetArchs=\"\n\tarm\n\tarm64\n\tm68k\n\tppc\n\triscv64\n\tsparc\n\tx86\n\tx86_64\n\tx86_gcc2\n\t\"\n\n# parse parameters\n#\nwhile [ $# -gt 0 ] ; do\n\tcase \"$1\" in\n\t\t--sysroot)\n\t\t\tassertparam \"$1\" $#\n\t\t\tcrossToolsSysroot=$2\n\t\t\tshift 2\n\t\t\t;;\n\t\t--bootstrap)\n\t\t\tassertparams \"$1\" 3 $#\n\t\t\tHOST_HAIKU_PORTER=\"`absolute_path $2`\"\n\t\t\tHAIKU_PORTS_CROSS=\"`absolute_path $3`\"\n\t\t\tHAIKU_PORTS=\"`absolute_path $4`\"\n\t\t\tHAIKU_IS_BOOTSTRAP=1\n\t\t\tHAIKU_NO_DOWNLOADS=1\n\t\t\tif ! check_file_exists \"$HOST_HAIKU_PORTER\"; then\n\t\t\t\techo \"Invalid path to haikuporter: $HOST_HAIKU_PORTER\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tif ! check_dir_exists \"$HAIKU_PORTS\"; then\n\t\t\t\techo \"Non-existent directory $HAIKU_PORTS\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tif ! check_dir_exists \"$HAIKU_PORTS_CROSS\"; then\n\t\t\t\techo \"Non-existent directory $HAIKU_PORTS_CROSS\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tshift 4\n\t\t\t;;\n\t\t--cross-tools-source)\n\t\t\tassertparam \"$1\" $#\n\t\t\tbuildCrossTools=$2\n\t\t\tshift 2\n\t\t\t;;\n\t\t--build-cross-tools)\n\t\t\tassertparam \"$1\" $#\n\t\t\ttargetArch=$2\n\t\t\tshift 2\n\t\t\tcase \"$targetArch\" in\n\t\t\t\tx86_gcc2)\ttargetMachine=i586-pc-haiku;;\n\t\t\t\tx86)\t\ttargetMachine=i586-pc-haiku;;\n\t\t\t\tx86_64)\t\ttargetMachine=x86_64-unknown-haiku;;\n\t\t\t\tppc)\t\ttargetMachine=powerpc-apple-haiku;;\n\t\t\t\tm68k)\t\ttargetMachine=m68k-unknown-haiku;;\n\t\t\t\tarm)\t\ttargetMachine=arm-unknown-haiku;;\n\t\t\t\tarm64)\t\ttargetMachine=aarch64-unknown-haiku;;\n\t\t\t\triscv64)\ttargetMachine=riscv64-unknown-haiku;;\n\t\t\t\tsparc)\t\ttargetMachine=sparc64-unknown-haiku;;\n\t\t\t\t*)\n\t\t\t\t\techo \"Unsupported target architecture: $targetArch\" >&2\n\t\t\t\t\texit 1\n\t\t\t\t\t;;\n\t\t\tesac\n\t\t\tset_variable buildCrossToolsMachine_$targetArch $targetMachine\n\t\t\ttargetArchs=\"$targetArchs $targetArch\"\n\t\t\t;;\n\t\t--cross-tools-prefix)\n\t\t\tassertparam \"$1\" $#\n\t\t\ttargetArch=unknown${unknownArchIndex}\n\t\t\tset_variable crossToolsPrefix_$targetArch \"$2\"\n\t\t\ttargetArchs=\"$targetArchs $targetArch\"\n\t\t\tunknownArchIndex=$(($unknownArchIndex + 1))\n\t\t\tshift 2\n\t\t\t;;\n\t\t--distro-compatibility)\n\t\t\tassertparam \"$1\" $#\n\t\t\tHAIKU_DISTRO_COMPATIBILITY=$2\n\t\t\tcase \"$HAIKU_DISTRO_COMPATIBILITY\" in\n\t\t\t\tofficial)\t;;\n\t\t\t\tcompatible)\t;;\n\t\t\t\tdefault)\t;;\n\t\t\t\t*)\t\t\techo \"Invalid distro compatibility\" \\\n\t\t\t\t\t\t\t\t\"level: $HAIKU_DISTRO_COMPATIBILITY\"\n\t\t\t\t\t\t\texit 1;;\n\t\t\tesac\n\t\t\tshift 2\n\t\t\t;;\n\t\t--host-only)\tHAIKU_HOST_BUILD_ONLY=1; shift 1;;\n\t\t--include-sources)\tHAIKU_INCLUDE_SOURCES=1; shift 1;;\n\t\t--include-3rdparty)\tHAIKU_INCLUDE_3RDPARTY=1; shift 1;;\n        -j*)\t\t\t\tbuildCrossToolsJobs=\"$1\"; shift 1;;\n\t\t--no-downloads)\tHAIKU_NO_DOWNLOADS=1; shift 1;;\n\t\t--target-arch)\n\t\t\tassertparam \"$1\" $#\n\t\t\ttargetArch=$2\n\t\t\tshift 2\n\t\t\tif [ ! \"$platform\" = Haiku ]; then\n\t\t\t\techo \"--target-arch can only be specified on Haiku.\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tis_in_list \"$targetArch\" \"$supportedTargetArchs\" || (\n\t\t\t\techo \"Unsupported target architecture: \\\"$targetArch\\\"\" >&2\n\t\t\t\texit 1\n\t\t\t)\n\t\t\thaikuTargetArchs=\"$haikuTargetArchs $targetArch\"\n\t\t\t;;\n\t\t--use-clang)\n\t\t\tassertparam \"$1\" $#\n\t\t\ttargetArch=$2\n\t\t\tuseClang=1\n\t\t\tcase \"$targetArch\" in\n\t\t\t\tx86)\t\ttargetMachine=i586-pc-haiku;;\n\t\t\t\tx86_64)\t\ttargetMachine=x86_64-unknown-haiku;;\n\t\t\t\tppc)\t\ttargetMachine=powerpc-apple-haiku;;\n\t\t\t\tarm)\t\ttargetMachine=arm-unknown-haiku;;\n\t\t\t\tarm64)\t\ttargetMachine=aarch64-unknown-haiku;;\n\t\t\t\triscv64)\ttargetMachine=riscv64-unknown-haiku;;\n\t\t\t\tsparc)\t\ttargetMachine=sparc64-unknown-haiku;;\n\t\t\t\t*)\n\t\t\t\t\techo \"Unsupported target architecture: $2\" >&2\n\t\t\t\t\texit 1\n\t\t\t\t\t;;\n\t\t\tesac\n\t\t\tget_build_tool_path clang clang\n\t\t\tif [ -z `get_variable \"crossToolsPrefix_$targetArch\"` ] \\\n\t\t\t\t\t&& [ -z `get_variable buildCrossToolsMachine_$targetArch` ]; then\n\t\t\t\tset_variable crossToolsPrefix_$targetArch llvm-\n\t\t\tfi\n\t\t\tclangVersion=`$HAIKU_clang -v 2>&1 | head -1 | cut -d \" \" -f3`\n\t\t\tif [ `echo $clangVersion | cut -d'.' -f1` -lt 7 ]; then\n\t\t\t\techo \"Haiku requires Clang 7 or better to build, but you have $clangVersion.\"\n\t\t\t\techo \"Please install a newer version.\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\ttargetArchs=\"$targetArchs $targetArch\"\n\t\t\tshift 2\n\t\t\t;;\n\t\t--use-gcc-pipe)\tHAIKU_USE_GCC_PIPE=1; shift 1;;\n\t\t--use-gcc-graphite)\tuseGccGraphiteDefault=1; shift 1;;\n\t\t--use-32bit)\tHAIKU_HOST_USE_32BIT=1; shift 1;;\n\t\t--no-full-xattr)HAIKU_HOST_USE_XATTR=0; shift 1;;\n\t\t--no-xattr)\t\tHAIKU_HOST_USE_XATTR_REF=0; shift 1;;\n\t\t--with-gdb)\tgdbSources=$2; shift 2;;\n\t\t--use-stack-protector)\tHAIKU_USE_STACK_PROTECTOR=1; shift 1;;\n\t\t--efi-signing-key)\n\t\t\tassertparam \"$1\" $#\n\t\t\tHAIKU_EFI_SIGNING_KEY=\"$2\"\n\t\t\tshift 2\n\t\t\t;;\n\t\t*)\t\t\t\techo Invalid argument: \\`$1\\'; exit 1;;\n\tesac\ndone\n\n# check for case-sensitive filesystem\nmkdir haikuCaseTest 2>/dev/null\nmkdir haikucasetest 2>/dev/null\ncaseInsensitive=$?\nrmdir haikuCaseTest haikucasetest 2>/dev/null\nif [ $caseInsensitive != 0 ]; then\n\techo \"You need a case-sensitive file-system to build Haiku.\"\n\tif [ $HOST_PLATFORM = \"darwin\" ]; then\n\t\techo \"You can create a case-sensitive disk image using Disk Utility.\"\n\tfi\n\texit 1\nfi\n\n# check xattr support\nif [ -z $HAIKU_HOST_USE_XATTR_REF ]; then\n\tcheck_native_xattrs\n\tattrSupport=$?\n\tif [ $attrSupport = 2 ] && [ -z $HAIKU_HOST_USE_XATTR ]; then\n\t\tHAIKU_HOST_USE_XATTR=1\n\telif [ $attrSupport = 1 ]; then\n\t\tHAIKU_HOST_USE_XATTR_REF=1\n\tfi\nfi\nif [ -z $HAIKU_HOST_USE_XATTR ]; then HAIKU_HOST_USE_XATTR=0; fi\nif [ -z $HAIKU_HOST_USE_XATTR_REF ]; then HAIKU_HOST_USE_XATTR_REF=0; fi\n\n# determine how to invoke sed with extended regexp support for non-GNU sed\nif [ $HOST_PLATFORM = \"darwin\" ]; then\n\tHOST_EXTENDED_REGEX_SED=\"sed -E\"\nfi\n\n# pick a JAMSHELL\nif [ \"$JAMSHELL\" = \"\" ]; then\n\tif check_file_exists /bin/dash; then\n\t\tJAMSHELL=/bin/dash\n\telse\n\t\tJAMSHELL=/bin/sh\n\tfi\nfi\nif ! $JAMSHELL -c true; then\n\techo \"$JAMSHELL does not work! Please specify a working JAMSHELL.\"\n\texit 1\nfi\n\n# locate python\nif [ -z \"$HOST_PYTHON\" ]; then\n\tif python3 --version < /dev/null > /dev/null 2>&1; then\n\t\tHOST_PYTHON=\"python3\"\n\telif python --version < /dev/null > /dev/null 2>&1; then\n\t\tHOST_PYTHON=\"python\"\n\telse\n\t\techo \"a python interpreter is required\"\n\t\texit 1\n\tfi\nfi\n\n# check is python is new enough\n# usage of python by HDS requires at least 3.9\nPYTHON_VERSION=$(\"$HOST_PYTHON\" --version 2>&1 | sed -e 's/Python //')\n\ncase $PYTHON_VERSION in\n\t2.* | 3.[1-8].*)\n\t\techo \"Python $PYTHON_VERSION is too old; need at least Python 3.9.\"\n\t\techo \"(maybe specify a Python interpreter to use in HOST_PYTHON?)\"\n\t\texit 1\n\t\t;;\n\t*)\n\t\t;;\nesac\n\n# check if wget supports --retry-on-host-error\nif wget --retry-on-host-error --version > /dev/null 2>&1; then\n\tHOST_WGET_RETRY_ON_HOST_ERROR=1\nfi\n\n# check if nasm can actually output ELF files\n# (the stock version in OSX can't)\n# XXX: should probably only test for x86* arch\nif [ \"$(\"$HAIKU_NASM\" -hf | grep -c elf'[36][24] ')\" -ne \"2\" ]; then\n\techo \"$HAIKU_NASM cannot generate ELF files. Please install a working version.\"\n\tif [ $HOST_PLATFORM = \"darwin\" ]; then\n\t\techo \"You can install it from Mac Ports.\"\n\t\techo \"Mac Ports is available at: http://www.macports.org/\"\n\tfi\n\texit 1\nfi\n\n# create output directory\nmkdir -p \"$buildOutputDir\" || exit 1\n\nif [ \"$HAIKU_HOST_BUILD_ONLY\" = 1 ]; then\n\tinvalidCommand=$sourceDir/build/scripts/host_build_only\n\tHAIKU_AR=$invalidCommand\n\tHAIKU_CC=$invalidCommand\n\tHAIKU_LD=$invalidCommand\n\tHAIKU_OBJCOPY=$invalidCommand\n\tHAIKU_RANLIB=$invalidCommand\n\tHAIKU_ELFEDIT=$invalidCommand\n\tHAIKU_NASM=$invalidCommand\n\tHAIKU_STRIP=$invalidCommand\nelse\n\t# On Haiku determine target architectures and tools automatically.\n\tif [ -z \"$targetArchs\" ]; then\n\t\tif [ $HOST_PLATFORM != haiku_host ]; then\n\t\t\techo \"Please specify the build tools to use or build (via\" \\\n\t\t\t\t\"--cross-tools-prefix or --build-cross-tools) or specify a\" \\\n\t\t\t\t\"host-only build (--host-only).\" >&2\n\t\t\techo \"For more info, invoke $0 --help\"\n\t\t\texit 1\n\t\tfi\n\n\t\t# determine primary architecture\n\t\ttargetArch=`package list -i /system/packages/haiku-*.hpkg \\\n\t\t\t| sed '/^\\s*architecture:/!d; s,^\\s*architecture:\\s*,,'`\n\t\tis_in_list \"$targetArch\" \"$supportedTargetArchs\" || (\n\t\t\techo \"Unsupported target architecture: \\\"$targetArch\\\"\" >&2\n\t\t\texit 1\n\t\t)\n\t\ttargetArchs=$targetArch\n\n\t\tset_default_value HAIKU_AR_$targetArch\t\t\tar\n\t\tset_default_value HAIKU_CC_$targetArch\t\t\tgcc\n\t\tset_default_value HAIKU_LD_$targetArch\t\t\tld\n\t\tset_default_value HAIKU_OBJCOPY_$targetArch\t\tobjcopy\n\t\tset_default_value HAIKU_RANLIB_$targetArch\t\tranlib\n\t\tset_default_value HAIKU_ELFEDIT_$targetArch\t\telfedit\n\t\tset_default_value HAIKU_STRIP_$targetArch\t\tstrip\n\n\t\t# determine secondary architectures\n\t\tfor targetArch in $supportedTargetArchs; do\n\t\t\tif [ -e /system/packages/haiku_$targetArch-*.hpkg ]; then\n\t\t\t\ttargetArchs=\"$targetArchs $targetArch\"\n\t\t\t\tset_default_value HAIKU_AR_$targetArch\t\tar-$targetArch\n\t\t\t\tset_default_value HAIKU_CC_$targetArch\t\tgcc-$targetArch\n\t\t\t\tset_default_value HAIKU_LD_$targetArch\t\tld-$targetArch\n\t\t\t\tset_default_value HAIKU_OBJCOPY_$targetArch\tobjcopy-$targetArch\n\t\t\t\tset_default_value HAIKU_RANLIB_$targetArch\tranlib-$targetArch\n\t\t\t\tset_default_value HAIKU_ELFEDIT_$targetArch\telfedit-$targetArch\n\t\t\t\tset_default_value HAIKU_STRIP_$targetArch\tstrip-$targetArch\n\t\t\tfi\n\t\tdone\n\n\t\t# The target architectures might have been specified explicitly.\n\t\tif [ -n \"$haikuTargetArchs\" ]; then\n\t\t\tfor targetArch in $haikuTargetArchs; do\n\t\t\t\tis_in_list \"$targetArch\" \"$targetArchs\" || (\n\t\t\t\t\techo \"Unsupported target architecture: \\\"$targetArch\\\".\" \\\n\t\t\t\t\t\t\"Only native architectures of the host platform can\" \\\n\t\t\t\t\t\t\"be specified.\" >&2\n\t\t\t\t\texit 1\n\t\t\t\t)\n\t\t\tdone\n\t\t\ttargetArchs=\"$haikuTargetArchs\"\n\t\tfi\n\tfi\n\n\tif [ \"$targetArchs\" = \" x86_gcc2\" ]; then\n\t\techo \"Building a GCC2-only Haiku is no longer supported.\"\n\t\techo \"Please configure the secondary architecture.\"\n\t\texit 1\n\tfi\n\n\tisPrimaryArch=1\n\tfor targetArch in $targetArchs; do\n\t\t# Note: targetArch is \"unknown<n>\" at this point if a cross-tools\n\t\t# prefix was specified. The standard_gcc_settings call below will get\n\t\t# the actual architecture.\n\n\t\tfor existingArch in $HAIKU_PACKAGING_ARCHS; do\n\t\t\tif [ $existingArch = $targetArch ]; then\n\t\t\t\t# somehow we wound up with a duplicate arch; skip this one\n\t\t\t\ttargetArch=\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ -z \"$targetArch\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\tcrossToolsPrefix=`get_variable crossToolsPrefix_$targetArch`\n\n\t\t# build cross tools from sources\n\t\tif [ -n \"$buildCrossTools\" -a -z \"$crossToolsPrefix\" ]; then\n\t\t\tcrossToolsDir=\"$outputDir/cross-tools-$targetArch\"\n\t\t\ttargetMachine=`get_variable buildCrossToolsMachine_$targetArch`\n\t\t\tscript=\"$buildCrossToolsScript\"\n\t\t\tscriptArgs=\n\t\t\tif [ $targetArch != x86_gcc2 ]; then\n\t\t\t\tscript=\"${script}_gcc4\"\n\t\t\t\tscriptArgs=\"$targetMachine\"\n\t\t\t\tset_default_value HAIKU_USE_GCC_GRAPHITE_$targetArch\t\\\n\t\t\t\t\t$useGccGraphiteDefault\n\t\t\tfi\n\t\t\tsecondaryArch=\n\t\t\tif [ -z \"$isPrimaryArch\" ]; then\n\t\t\t\tsecondaryArch=$targetArch\n\t\t\tfi\n\n\t\t\tcase $HOST_PLATFORM in\n\t\t\t\tfreebsd|openbsd)\tMAKE=gmake;;\n\t\t\t\t*)\t\t\t\t\tMAKE=make;;\n\t\t\tesac\n\n\t\t\tif ! valid_toolchain \"${targetMachine}\" \"${crossToolsDir}\" \"${buildCrossTools}\"; then\n\t\t\t\tMAKE=$MAKE \\\n\t\t\t\tSECONDARY_ARCH=$secondaryArch \\\n\t\t\t\tHAIKU_USE_GCC_GRAPHITE=`get_variable \\\n\t\t\t\t\tHAIKU_USE_GCC_GRAPHITE_$targetArch` \\\n\t\t\t\tHAIKU_USE_GCC_PIPE=$HAIKU_USE_GCC_PIPE \\\n\t\t\t\tHAIKU_USE_GDB=\"$gdbSources\" \\\n\t\t\t\tHAIKU_USE_SYSROOT=\"$crossToolsSysroot\" \\\n\t\t\t\t\"$script\" $scriptArgs \"$sourceDir\" \"$buildCrossTools\" \\\n\t\t\t\t\t\"$crossToolsDir\" $buildCrossToolsJobs || exit 1\n\t\t\telse\n\t\t\t\techo \"$targetArch crosstools already exist in $crossToolsDir; skipping build\"\n\t\t\tfi\n\t\t\tcrossToolsPrefix=\"$crossToolsDir/bin/${targetMachine}-\"\n\t\tfi\n\n\t\t# prepare gcc settings and get the actual target architecture\n\t\tif [ $useClang = 1 ]; then\n\t\t\tgcc=\"$HAIKU_clang -target ${targetMachine}\"\n\t\t\tif [ ! -z \"${crossToolsPrefix}\" ]; then\n\t\t\t\tgcc=\"$gcc -B ${crossToolsPrefix}\"\n\t\t\tfi\n\n\t\t\t# Clang's compiler intrinsics are not compatible with GCC's or even\n\t\t\t# across versions of Clang, so we must collect them for use in the build.\n\t\t\tmkdir -p \"$outputDir/clang_headers\" || exit 1\n\t\t\tclangHeadersDir=`$gcc -print-resource-dir`/include/\n\t\t\tcase $targetArch in\n\t\t\t\tx86*) cp $clangHeadersDir/*intrin* $clangHeadersDir/mm3* \"$outputDir/clang_headers\" || exit 1 ;;\n\t\t\t\tppc*) cp $clangHeadersDir/*altivec* \"$outputDir/clang_headers\" || exit 1 ;;\n\t\t\t\tarm*) cp $clangHeadersDir/*arm* \"$outputDir/clang_headers\" || exit 1 ;;\n\t\t\tesac\n\t\telif [ -z \"${crossToolsPrefix}\" ]; then\n\t\t\tgcc=`get_variable HAIKU_CC_$targetArch`\n\t\telse\n\t\t\tgcc=\"${crossToolsPrefix}gcc\"\n\t\tfi\n\n\t\tif [ -z \"$gcc\" ]; then\n\t\t\techo \"Please specify the build tools to use or build (via\" \\\n\t\t\t\t\"--cross-tools-prefix or --build-cross-tools).\" >&2\n\t\t\techo \"For more info, invoke $0 --help\"\n\t\t\texit 1\n\t\tfi\n\t\tstandard_gcc_settings \"$gcc\"\n\t\ttargetArch=$standard_gcc_settings_targetArch\n\n\t\t# set default values for flags\n\t\tset_default_value HAIKU_CPPFLAGS_$targetArch\t\"\"\n\t\tset_default_value HAIKU_CCFLAGS_$targetArch\t\t\"\"\n\t\tset_default_value HAIKU_CXXFLAGS_$targetArch\t\"\"\n\t\tset_default_value HAIKU_LINKFLAGS_$targetArch\t\"\"\n\t\tset_default_value HAIKU_LDFLAGS_$targetArch\t\t\"\"\n\t\tset_default_value HAIKU_ARFLAGS_$targetArch\t\tcru\n\t\tset_default_value HAIKU_UNARFLAGS_$targetArch\tx\n\n\t\t# Override the cross tools variables, if the tools were built or a\n\t\t# prefix was specified.\n\t\tif [ -n \"$crossToolsPrefix\" ]; then\n\t\t\tget_build_tool_path AR_$targetArch ${crossToolsPrefix}ar\n\t\t\tget_build_tool_path OBJCOPY_$targetArch ${crossToolsPrefix}objcopy\n\t\t\tget_build_tool_path RANLIB_$targetArch ${crossToolsPrefix}ranlib\n\t\t\tget_build_tool_path STRIP_$targetArch ${crossToolsPrefix}strip\n\n\t\t\tget_build_tool_path LD_$targetArch ${crossToolsPrefix}ld\n\t\t\tif [ `get_variable HAIKU_CC_IS_LEGACY_GCC_$targetArch` -eq 0 ]; then\n\t\t\t\tget_build_tool_path ELFEDIT_$targetArch ${crossToolsPrefix}elfedit\n\t\t\tfi\n\t\tfi\n\n\t\t# check whether the Haiku compiler really targets Haiku\n\t\ttargetMachine=`get_variable HAIKU_GCC_MACHINE_$targetArch`\n\t\tcase \"$targetMachine\" in\n\t\t\t*-*-haiku)\t;;\n\t\t\t*)\n\t\t\t\techo The compiler specified as Haiku target compiler is not a \\\n\t\t\t\tvalid Haiku cross-compiler. Please see ReadMe.cross-compile. >&2\n\t\t\t\techo compiler: $HAIKU_CC\n\t\t\t\techo compiler is configured for target: $targetMachine\n\t\t\t\texit 1 ;;\n\t\tesac\n\n\t\tHAIKU_PACKAGING_ARCHS=\"$HAIKU_PACKAGING_ARCHS $targetArch\"\n\t\tisPrimaryArch=\n\tdone\nfi\n\n# Generate BuildConfig\ncat << EOF > \"$buildConfigFile\"\n# -- WARNING --\n# This file was AUTOMATICALLY GENERATED by configure, and will be completely\n# overwritten the next time configure is run.\n#\n#d ${currentDir}\n#c ${configurePath}\n#e ${configureEnvirons}\n#a ${configureArgs}\n\nGIT_DIR\t\t\t\t\t\t?= \"${GIT_DIR}\" ;\n\nHOST_PLATFORM\t\t\t\t?= \"${HOST_PLATFORM}\" ;\nTARGET_PLATFORM \t\t\t?= \"${TARGET_PLATFORM}\" ;\nHAIKU_PACKAGING_ARCHS\t\t?= ${HAIKU_PACKAGING_ARCHS} ;\n\nHAIKU_NO_DOWNLOADS\t\t\t?= \"${HAIKU_NO_DOWNLOADS}\" ;\nHAIKU_INCLUDE_SOURCES\t\t?= \"${HAIKU_INCLUDE_SOURCES}\" ;\nHAIKU_INCLUDE_3RDPARTY\t\t?= \"${HAIKU_INCLUDE_3RDPARTY}\" ;\nHAIKU_DISTRO_COMPATIBILITY\t?= \"${HAIKU_DISTRO_COMPATIBILITY}\" ;\n\nHAIKU_USE_GCC_PIPE\t\t\t?= \"${HAIKU_USE_GCC_PIPE}\" ;\nHAIKU_HOST_USE_32BIT\t\t?= \"${HAIKU_HOST_USE_32BIT}\" ;\nHAIKU_HOST_USE_XATTR\t\t?= \"${HAIKU_HOST_USE_XATTR}\" ;\nHAIKU_HOST_USE_XATTR_REF\t?= \"${HAIKU_HOST_USE_XATTR_REF}\" ;\nHAIKU_HOST_BUILD_ONLY\t\t?= \"${HAIKU_HOST_BUILD_ONLY}\" ;\n\nJAMSHELL\t\t\t\t\t?= ${JAMSHELL} -e -c ;\n\nHOST_CC\t\t\t\t\t\t?= ${CC} ;\nHOST_GCC_MACHINE\t\t\t?= ${HOST_GCC_MACHINE} ;\nHOST_LD\t\t\t\t\t\t?= ${HOST_GCC_LD} ;\nHOST_OBJCOPY\t\t\t\t?= ${HOST_GCC_OBJCOPY} ;\nHOST_EXTENDED_REGEX_SED\t\t?= ${HOST_EXTENDED_REGEX_SED} ;\nHOST_SHA256\t\t\t\t\t?= ${HOST_SHA256} ;\nHOST_PYTHON\t\t\t\t\t?= ${HOST_PYTHON} ;\nHOST_WGET_RETRY_ON_HOST_ERROR\t\t\t?= ${HOST_WGET_RETRY_ON_HOST_ERROR} ;\nHAIKU_NASM\t\t\t\t\t?= ${HAIKU_NASM} ;\n\nHAIKU_BUILD_ATTRIBUTES_DIR\t?= \"${HAIKU_BUILD_ATTRIBUTES_DIR}\" ;\n\nHOST_HAIKU_PORTER\t\t\t?= ${HOST_HAIKU_PORTER} ;\nHAIKU_PORTS\t\t\t\t\t?= ${HAIKU_PORTS} ;\nHAIKU_PORTS_CROSS\t\t\t?= ${HAIKU_PORTS_CROSS} ;\nHAIKU_IS_BOOTSTRAP\t\t\t?= ${HAIKU_IS_BOOTSTRAP} ;\n\nHAIKU_BOOT_EFI_PRIVATE_KEYFILE\t?= ${HAIKU_EFI_SIGNING_KEY} ;\nEOF\n\nfor targetArch in $HAIKU_PACKAGING_ARCHS; do\n\tvariables=\"\n\t\tHAIKU_CC\t\t\t\t\tHAIKU_CC\n\t\tHAIKU_CC_IS_LEGACY_GCC\t\tHAIKU_CC_IS_LEGACY_GCC\n\t\tHAIKU_CC_IS_CLANG\t\t\tHAIKU_CC_IS_CLANG\n\t\tHAIKU_USE_GCC_GRAPHITE\t\tHAIKU_USE_GCC_GRAPHITE\n\t\tHAIKU_CPU\t\t\t\t\tHAIKU_CPU\n\t\tHAIKU_GCC_MACHINE\t\t\tHAIKU_GCC_MACHINE\n\t\tHAIKU_GCC_LIB_DIR\t\t\tHAIKU_GCC_LIB_DIR\n\t\tHAIKU_BOOT_LIBGCC\t\t\tHAIKU_BOOT_LIBGCC\n\t\tHAIKU_BOOT_LIBSUPC++\t\tHAIKU_BOOT_LIBSUPCXX\n\t\tHAIKU_BOOT_32_LIBGCC\t\tHAIKU_BOOT_32_LIBGCC\n\t\tHAIKU_BOOT_32_LIBSUPC++\t\tHAIKU_BOOT_32_LIBSUPCXX\n\t\tHAIKU_AR\t\t\t\t\tHAIKU_AR\n\t\tHAIKU_LD\t\t\t\t\tHAIKU_LD\n\t\tHAIKU_OBJCOPY\t\t\t\tHAIKU_OBJCOPY\n\t\tHAIKU_RANLIB\t\t\t\tHAIKU_RANLIB\n\t\tHAIKU_ELFEDIT\t\t\t\tHAIKU_ELFEDIT\n\t\tHAIKU_STRIP\t\t\t\t\tHAIKU_STRIP\n\t\tHAIKU_CPPFLAGS\t\t\t\tHAIKU_CPPFLAGS\n\t\tHAIKU_CCFLAGS\t\t\t\tHAIKU_CCFLAGS\n\t\tHAIKU_C++FLAGS\t\t\t\tHAIKU_CXXFLAGS\n\t\tHAIKU_LINKFLAGS\t\t\t\tHAIKU_LINKFLAGS\n\t\tHAIKU_LDFLAGS\t\t\t\tHAIKU_LDFLAGS\n\t\tHAIKU_ARFLAGS\t\t\t\tHAIKU_ARFLAGS\n\t\tHAIKU_UNARFLAGS\t\t\t\tHAIKU_UNARFLAGS\n\t\t\"\n\tset -- $variables\n\twhile [ $# -ge 2 ]; do\n\t\tvalue=`get_variable ${2}_$targetArch`\n\t\techo \"${1}_${targetArch} ?= $value ;\" >> \"$buildConfigFile\"\n\t\tshift 2\n\tdone\n\n\t# For variables that may have long values, distribute them over multiple\n\t# lines so that jam doesn't hit the maximum line length.\n\tvariables=\"\n\t\tHAIKU_BOOT_C++_HEADERS_DIR\tHAIKU_BOOT_CXX_HEADERS_DIR\n\t\tHAIKU_BOOT_32_C++_HEADERS_DIR\tHAIKU_BOOT_32_CXX_HEADERS_DIR\n\t\t\"\n\tset -- $variables\n\twhile [ $# -ge 2 ]; do\n\t\techo \"${1}_${targetArch} ?= \" >> \"$buildConfigFile\"\n\t\tget_variable ${2}_$targetArch | xargs -n 1 echo \"   \" \\\n\t\t\t>> \"$buildConfigFile\"\n\t\techo \"    ;\" >> \"$buildConfigFile\"\n\t\tshift 2\n\tdone\ndone\n\n\n# Generate a Jamfile in the output directory.\n\ncat << EOF > $outputDir/Jamfile\n# -- WARNING --\n# This file was AUTOMATICALLY GENERATED by configure, and will be completely\n# overwritten the next time configure is run.\n\nHAIKU_TOP\t\t\t= $(relative_to \"${sourceDir}\" \"${outputDir}\") ;\nHAIKU_OUTPUT_DIR\t= . ;\n\ninclude [ FDirName \\$(HAIKU_TOP) Jamfile ] ;\n\nEOF\n\necho \"Configured successfully!\"\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "headers",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}