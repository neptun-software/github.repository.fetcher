{
  "metadata": {
    "timestamp": 1736565519758,
    "page": 391,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jwise/HoRNDIS",
      "stars": 3014,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7548828125,
          "content": "InfoPlist.h\n\n# Created by https://www.gitignore.io\n\n### Xcode ###\nbuild/\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata\n*.xccheckout\n*.moved-aside\nDerivedData\n*.xcuserstate\n\n\n### OSX ###\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end  with two \\r\nIcon\n\n\n# Resource Forks\n._*\n\n# Files that might appear on external disk\n.Spotlight-V100\n.Trashes\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n\n### C++ ###\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n"
        },
        {
          "name": "COPYING.rtf",
          "type": "blob",
          "size": 37.19140625,
          "content": "{\\rtf1\\ansi\\ansicpg1252\\cocoartf1187\\cocoasubrtf340\n{\\fonttbl\\f0\\fnil\\fcharset0 LucidaGrande;\\f1\\fnil\\fcharset0 Menlo-Regular;}\n{\\colortbl;\\red255\\green255\\blue255;}\n{\\*\\listtable{\\list\\listtemplateid1\\listhybrid{\\listlevel\\levelnfc4\\levelnfcn4\\leveljc0\\leveljcn0\\levelfollow0\\levelstartat1\\levelspace360\\levelindent0{\\*\\levelmarker \\{lower-alpha\\})}{\\leveltext\\leveltemplateid1\\'02\\'00);}{\\levelnumbers\\'01;}\\fi-360\\li720\\lin720 }{\\listname ;}\\listid1}\n{\\list\\listtemplateid2\\listhybrid{\\listlevel\\levelnfc4\\levelnfcn4\\leveljc0\\leveljcn0\\levelfollow0\\levelstartat1\\levelspace360\\levelindent0{\\*\\levelmarker \\{lower-alpha\\})}{\\leveltext\\leveltemplateid101\\'02\\'00);}{\\levelnumbers\\'01;}\\fi-360\\li720\\lin720 }{\\listname ;}\\listid2}\n{\\list\\listtemplateid3\\listhybrid{\\listlevel\\levelnfc4\\levelnfcn4\\leveljc0\\leveljcn0\\levelfollow0\\levelstartat1\\levelspace360\\levelindent0{\\*\\levelmarker \\{lower-alpha\\})}{\\leveltext\\leveltemplateid201\\'02\\'00);}{\\levelnumbers\\'01;}\\fi-360\\li720\\lin720 }{\\listname ;}\\listid3}}\n{\\*\\listoverridetable{\\listoverride\\listid1\\listoverridecount0\\ls1}{\\listoverride\\listid2\\listoverridecount0\\ls2}{\\listoverride\\listid3\\listoverridecount0\\ls3}}\n\\margl1440\\margr1440\\vieww10800\\viewh8400\\viewkind0\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\n\n\\f0\\fs24 \\cf0 \\\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\\qc\n\n\\b\\fs36 \\cf0 GNU GENERAL PUBLIC LICENSE\\\n\n\\b0\\fs24 \\\nVersion 3, 29 June 2007\\\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\n\\cf0 \\\nCopyright \\'a9 2007 Free Software Foundation, Inc.\\\n<{\\field{\\*\\fldinst{HYPERLINK \"http://fsf.org/\"}}{\\fldrslt http://fsf.org/}}>\\\n\\\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\\\n\\\n\n\\b\\fs36 Preamble\\\n\n\\b0\\fs24 \\\nThe GNU General Public License is a free, copyleft license for software and other kinds of works.\\\n\\\nThe licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.\\\n\\\nWhen we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.\\\n\\\nTo protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.\\\n\\\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\\\n\\\nDevelopers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.\\\n\\\nFor the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.\\\n\\\nSome devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.\\\n\\\nFinally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.\\\n\\\nThe precise terms and conditions for copying, distribution and modification follow.\\\n\\\n\n\\b\\fs36 TERMS AND CONDITIONS\\\n\\\n\n\\fs28 0. Definitions.\\\n\n\\b0\\fs24 \\\n\\'93This License\\'94 refers to version 3 of the GNU General Public License.\\\n\\\n\\'93Copyright\\'94 also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.\\\n\\\n\\'93The Program\\'94 refers to any copyrightable work licensed under this License. Each licensee is addressed as \\'93you\\'94. \\'93Licensees\\'94 and \\'93recipients\\'94 may be individuals or organizations.\\\n\\\nTo \\'93modify\\'94 a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \\'93modified version\\'94 of the earlier work or a work \\'93based on\\'94 the earlier work.\\\n\\\nA \\'93covered work\\'94 means either the unmodified Program or a work based on the Program.\\\n\\\nTo \\'93propagate\\'94 a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.\\\n\\\nTo \\'93convey\\'94 a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.\\\n\\\nAn interactive user interface displays \\'93Appropriate Legal Notices\\'94 to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.\\\n\\\n\n\\b\\fs28 1. Source Code.\\\n\n\\b0\\fs24 \\\nThe \\'93source code\\'94 for a work means the preferred form of the work for making modifications to it. \\'93Object code\\'94 means any non-source form of a work.\\\n\\\nA \\'93Standard Interface\\'94 means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.\\\n\\\nThe \\'93System Libraries\\'94 of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \\'93Major Component\\'94, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.\\\n\\\nThe \\'93Corresponding Source\\'94 for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.\\\n\\\nThe Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.\\\n\\\nThe Corresponding Source for a work in source code form is that same work.\\\n\\\n\n\\b\\fs28 2. Basic Permissions.\\\n\n\\b0\\fs24 \\\nAll rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.\\\n\\\nYou may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.\\\n\\\nConveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.\\\n\\\n\n\\b\\fs28 3. Protecting Users' Legal Rights From Anti-Circumvention Law.\\\n\n\\b0\\fs24 \\\nNo covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.\\\n\\\nWhen you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.\\\n\\\n\n\\b\\fs28 4. Conveying Verbatim Copies.\\\n\n\\b0\\fs24 \\\nYou may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.\\\n\\\nYou may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.\\\n\\\n\n\\b\\fs28 5. Conveying Modified Source Versions.\\\n\n\\b0\\fs24 \\\nYou may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:\\\n\\\n\\pard\\tx220\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\li720\\fi-720\\pardirnatural\n\\ls1\\ilvl0\\cf0 {\\listtext\ta)\t}The work must carry prominent notices stating that you modified it, and giving a relevant date.\\\n{\\listtext\tb)\t}The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \\'93keep intact all notices\\'94.\\\n{\\listtext\tc)\t}You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.\\\n{\\listtext\td)\t}If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.\\\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\n\\cf0 \\\nA compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \\'93aggregate\\'94 if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.\\\n\\\n\n\\b\\fs28 6. Conveying Non-Source Forms.\\\n\n\\b0\\fs24 \\\nYou may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:\\\n\\\n\\pard\\tx220\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\li720\\fi-720\\pardirnatural\n\\ls2\\ilvl0\\cf0 {\\listtext\ta)\t}Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.\\\n{\\listtext\tb)\t}Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.\\\n{\\listtext\tc)\t}Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.\\\n{\\listtext\td)\t}Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.\\\n{\\listtext\te)\t}Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.\\\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\n\\cf0 \\\nA separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.\\\n\\\nA \\'93User Product\\'94 is either (1) a \\'93consumer product\\'94, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \\'93normally used\\'94 refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.\\\n\\\n\\'93Installation Information\\'94 for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.\\\n\\\nIf you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).\\\n\\\nThe requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.\\\n\\\nCorresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.\\\n\\\n\n\\b\\fs28 7. Additional Terms.\\\n\n\\b0\\fs24 \\\n\\'93Additional permissions\\'94 are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.\\\n\\\nWhen you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.\\\n\\\nNotwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:\\\n\\\n\\pard\\tx220\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\li720\\fi-720\\pardirnatural\n\\ls3\\ilvl0\\cf0 {\\listtext\ta)\t}Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or\\\n{\\listtext\tb)\t}Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or\\\n{\\listtext\tc)\t}Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or\\\n{\\listtext\td)\t}Limiting the use for publicity purposes of names of licensors or authors of the material; or\\\n{\\listtext\te)\t}Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or\\\n{\\listtext\tf)\t}Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.\\\n\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\pardirnatural\n\\cf0 \\\nAll other non-permissive additional terms are considered \\'93further restrictions\\'94 within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.\\\n\\\nIf you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.\\\n\\\nAdditional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.\\\n\\\n\n\\b\\fs28 8. Termination.\\\n\n\\b0\\fs24 \\\nYou may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).\\\n\\\nHowever, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.\\\n\\\nMoreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.\\\n\\\nTermination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.\\\n\\\n\n\\b\\fs28 9. Acceptance Not Required for Having Copies.\\\n\n\\b0\\fs24 \\\nYou are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.\\\n\\\n\n\\b\\fs28 10. Automatic Licensing of Downstream Recipients.\\\n\n\\b0\\fs24 \\\nEach time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.\\\n\\\nAn \\'93entity transaction\\'94 is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.\\\n\\\nYou may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.\\\n\\\n\n\\b\\fs28 11. Patents.\\\n\n\\b0\\fs24 \\\nA \\'93contributor\\'94 is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \\'93contributor version\\'94.\\\n\\\nA contributor's \\'93essential patent claims\\'94 are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \\'93control\\'94 includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.\\\n\\\nEach contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.\\\n\\\nIn the following three paragraphs, a \\'93patent license\\'94 is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \\'93grant\\'94 such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.\\\n\\\nIf you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \\'93Knowingly relying\\'94 means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.\\\n\\\nIf, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.\\\n\\\nA patent license is \\'93discriminatory\\'94 if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.\\\n\\\nNothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.\\\n\\\n\n\\b\\fs28 12. No Surrender of Others' Freedom.\\\n\n\\b0\\fs24 \\\nIf conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.\\\n\\\n\n\\b\\fs28 13. Use with the GNU Affero General Public License.\\\n\n\\b0\\fs24 \\\nNotwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.\\\n\\\n\n\\b\\fs28 14. Revised Versions of this License.\\\n\n\\b0\\fs24 \\\nThe Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\\\n\\\nEach version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \\'93or any later version\\'94 applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.\\\n\\\nIf the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.\\\n\\\nLater license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.\\\n\\\n\n\\b\\fs28 15. Disclaimer of Warranty.\\\n\n\\b0\\fs24 \\\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \\'93AS IS\\'94 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\\\n\\\n\n\\b\\fs28 16. Limitation of Liability.\\\n\n\\b0\\fs24 \\\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\\\n\\\n\n\\b\\fs28 17. Interpretation of Sections 15 and 16.\\\n\n\\b0\\fs24 \\\nIf the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.\\\n\\\nEND OF TERMS AND CONDITIONS\\\n\\\n\n\\b\\fs36 How to Apply These Terms to Your New Programs\\\n\n\\b0\\fs24 \\\nIf you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\\\n\\\nTo do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \\'93copyright\\'94 line and a pointer to where the full notice is found.\\\n\\\n\n\\f1     <one line to give the program's name and a brief idea of what it does.>\\\n    Copyright (C) <year>  <name of author>\\\n\\\n    This program is free software: you can redistribute it and/or modify\\\n    it under the terms of the GNU General Public License as published by\\\n    the Free Software Foundation, either version 3 of the License, or\\\n    (at your option) any later version.\\\n\\\n    This program is distributed in the hope that it will be useful,\\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\\n    GNU General Public License for more details.\\\n\\\n    You should have received a copy of the GNU General Public License\\\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\\\n\n\\f0 \\\nAlso add information on how to contact you by electronic and paper mail.\\\n\\\nIf the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:\\\n\\\n\n\\f1     <program>  Copyright (C) <year>  <name of author>\\\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\\n    This is free software, and you are welcome to redistribute it\\\n    under certain conditions; type `show c' for details.\\\n\n\\f0 \\\nThe hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \\'93about box\\'94.\\\n\\\nYou should also get your employer (if you work as a programmer) or school, if any, to sign a \\'93copyright disclaimer\\'94 for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <{\\field{\\*\\fldinst{HYPERLINK \"http://www.gnu.org/licenses/\"}}{\\fldrslt http://www.gnu.org/licenses/}}>.\\\n\\\nThe GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <{\\field{\\*\\fldinst{HYPERLINK \"http://www.gnu.org/philosophy/why-not-lgpl.html\"}}{\\fldrslt http://www.gnu.org/philosophy/why-not-lgpl.html}}>.\\\n}"
        },
        {
          "name": "HoRNDIS-Info.plist",
          "type": "blob",
          "size": 2.978515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CFBundleDevelopmentRegion</key>\n\t<string>English</string>\n\t<key>CFBundleExecutable</key>\n\t<string>${EXECUTABLE_NAME}</string>\n\t<key>CFBundleGetInfoString</key>\n\t<string>Android/RNDIS tethering driver</string>\n\t<key>CFBundleIconFile</key>\n\t<string></string>\n\t<key>CFBundleIdentifier</key>\n\t<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n\t<key>CFBundleInfoDictionaryVersion</key>\n\t<string>6.0</string>\n\t<key>CFBundleName</key>\n\t<string>${PRODUCT_NAME}</string>\n\t<key>CFBundlePackageType</key>\n\t<string>KEXT</string>\n\t<key>CFBundleSignature</key>\n\t<string>????</string>\n\t<key>CFBundleVersion</key>\n\t<string>$(MODULE_VERSION)</string>\n\t<key>IOKitPersonalities</key>\n\t<dict>\n\t\t<key>RNDISControlStockAndroid</key>\n\t\t<dict>\n\t\t\t<key>CFBundleIdentifier</key>\n\t\t\t<string>com.joshuawise.kexts.HoRNDIS</string>\n\t\t\t<key>IOClass</key>\n\t\t\t<string>HoRNDIS</string>\n\t\t\t<key>IOProviderClass</key>\n\t\t\t<string>IOUSBHostInterface</string>\n\t\t\t<key>bInterfaceClass</key>\n\t\t\t<integer>224</integer>\n\t\t\t<key>bInterfaceSubClass</key>\n\t\t\t<integer>1</integer>\n\t\t\t<key>bInterfaceProtocol</key>\n\t\t\t<integer>3</integer>\n\t\t</dict>\n\t\t<key>RNDISControlMiscDeviceRoE</key>\n\t\t<dict>\n\t\t\t<key>CFBundleIdentifier</key>\n\t\t\t<string>com.joshuawise.kexts.HoRNDIS</string>\n\t\t\t<key>IOClass</key>\n\t\t\t<string>HoRNDIS</string>\n\t\t\t<key>IOProviderClass</key>\n\t\t\t<string>IOUSBHostInterface</string>\n\t\t\t<key>bInterfaceClass</key>\n\t\t\t<integer>239</integer>\n\t\t\t<key>bInterfaceSubClass</key>\n\t\t\t<integer>4</integer>\n\t\t\t<key>bInterfaceProtocol</key>\n\t\t\t<integer>1</integer>\n\t\t</dict>\n\t\t<key>RNDISControlLinuxGadget</key>\n\t\t<dict>\n\t\t\t<key>CFBundleIdentifier</key>\n\t\t\t<string>com.joshuawise.kexts.HoRNDIS</string>\n\t\t\t<key>IOClass</key>\n\t\t\t<string>HoRNDIS</string>\n\t\t\t<key>IOProviderClass</key>\n\t\t\t<string>IOUSBHostInterface</string>\n\t\t\t<key>bInterfaceClass</key>\n\t\t\t<integer>2</integer>\n\t\t\t<key>bInterfaceSubClass</key>\n\t\t\t<integer>2</integer>\n\t\t\t<key>bInterfaceProtocol</key>\n\t\t\t<integer>255</integer>\n\t\t</dict>\n\t\t<key>WirelessControllerDevice</key>\n\t\t<dict>\n\t\t\t<key>CFBundleIdentifier</key>\n\t\t\t<string>com.joshuawise.kexts.HoRNDIS</string>\n\t\t\t<key>IOClass</key>\n\t\t\t<string>HoRNDIS</string>\n\t\t\t<key>IOProviderClass</key>\n\t\t\t<string>IOUSBHostDevice</string>\n\t\t\t<key>bDeviceClass</key>\n\t\t\t<integer>224</integer>\n\t\t\t<key>bDeviceSubClass</key>\n\t\t\t<integer>0</integer>\n\t\t\t<key>bDeviceProtocol</key>\n\t\t\t<integer>0</integer>\n\t\t</dict>\n\t</dict>\n\t<key>OSBundleLibraries</key>\n\t<dict>\n\t\t<key>com.apple.iokit.IONetworkingFamily</key>\n\t\t<string>3.2</string>\n\t\t<key>com.apple.iokit.IOUSBHostFamily</key>\n\t\t<string>1.0.1</string>\n\t\t<key>com.apple.kpi.bsd</key>\n\t\t<string>15.0</string>\n\t\t<key>com.apple.kpi.iokit</key>\n\t\t<string>15.0</string>\n\t\t<key>com.apple.kpi.libkern</key>\n\t\t<string>15.0</string>\n\t\t<key>com.apple.kpi.mach</key>\n\t\t<string>15.0</string>\n\t\t<key>com.apple.kpi.unsupported</key>\n\t\t<string>15.0</string>\n\t</dict>\n</dict>\n</plist>\n"
        },
        {
          "name": "HoRNDIS-Prefix.pch",
          "type": "blob",
          "size": 0.091796875,
          "content": "//\n// Prefix header for all source files of the 'HoRNDIS' target in the 'HoRNDIS' project\n//\n\n"
        },
        {
          "name": "HoRNDIS.cpp",
          "type": "blob",
          "size": 50.447265625,
          "content": "/* HoRNDIS.cpp\n * Implementation of IOKit-derived classes\n * HoRNDIS, a RNDIS driver for Mac OS X\n *\n *   Copyright (c) 2012 Joshua Wise.\n *   Copyright (c) 2018 Mikhail Iakhiaev\n *\n * IOKit examples from Apple's USBCDCEthernet.cpp; not much of that code remains.\n *\n * RNDIS logic is from linux/drivers/net/usb/rndis_host.c, which is:\n *\n *   Copyright (c) 2005 David Brownell.\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"HoRNDIS.h\"\n\n#include <mach/kmod.h>\n#include <libkern/version.h>\n#include <IOKit/IOKitKeys.h>\n\n#include <IOKit/usb/IOUSBHostDevice.h>\n#include <IOKit/usb/IOUSBHostInterface.h>\n#include <IOKit/network/IOGatedOutputQueue.h>\n// May be useful for supporting suspend/resume:\n// #include <IOKit/pwr_mgt/RootDomain.h>\n\n\n#define V_PTR 0\n#define V_PACKET 1\n#define V_DEBUG 2\n#define V_NOTE 3\n#define V_ERROR 4\n\n// The XCode \"Debug\" build is now more verbose:\n#if DEBUG == 1\n\t#define DEBUGLEVEL V_DEBUG\n#else\n\t#define DEBUGLEVEL V_NOTE\n#endif\n#define LOG(verbosity, s, ...) do { if (verbosity >= DEBUGLEVEL) IOLog(\"HoRNDIS: %s: \" s \"\\n\", __func__, ##__VA_ARGS__); } while(0)\n\n#define super IOEthernetController\n\nOSDefineMetaClassAndStructors(HoRNDIS, IOEthernetController);\nOSDefineMetaClassAndStructors(HoRNDISInterface, IOEthernetInterface);\n\n/* \n================================================================\nDESCRIPTION OF DEVICE DRIVER MATCHING (+ Info.plist description)\n================================================================\nThe HoRNDIS driver classes are only instantiated when the MacOS matches \n\"IOKitPersonalities\" dictionary entries to the existing devices. The matching \ncan be done 2 based on two different provider classes:\n \n - IOUSBHostInterface - matches an interface under a USB device. Here, we match\n   based on the interface class/subclass/protocol. In order for the matching to\n   work, some other driver has to open the USB device and call \n   \"setConfiguration\" method with matchInterfaces=true.\n   The interface matching works out-of-the-box for interfaces under USB\n   Composite Devices (class/subclass/protocol are 0/0/0), since there is an OS \n   driver that opens such devices for matching.\n \n - IOUSBHostDevice - match is performed on the whole device. Here, we match \n   based on class/subclass/protocol. The start method needs to call \n   'setConfiguration' in order for any IOUSBHostInterface instances under the \n   device to become available. If it specifies 'matchInterfaces', matching is \n   then performed on newly-created IOUSBHostInterfaces.\n\nOUR APPROACH:\nWe'll match based on either device or interface, and let the probe and start \nmethods handle the difference. Not calling setConfiguration with matchInterfaces\nfor now: if it's not a USB composite device, consider that we own it.\n \nSubsequent logic:\nAfter MacOS finds a match based on Info.plist, it instantiates the driver class,\nand calls the 'probe' method that looks at descriptors and decides if this is \nreally the device we care about (e.g. fine-grained filtering), and sets the \n\"probeXxx\" variables. Then, 'start' method calls 'openUSBInterfaces' that \nblindly follows the \"probeXxx\" variables to get the needed IOUSBHostInterface \nvalues from the opened device.\n\n==========================\n||  DEVICE VARIATIONS\n==========================\nThis section must document ALL different variations of the devices that we\nmay be dealing with, so we have the whole picture when updating the \"probe\"\ncode or \"Info.plist\". Notation:\n * Device: 224 / 0 / 0\n   - bDeviceClass / bDeviceSubClass / bDeviceProtocol\n * Interface Associaton[2]: 224 / 1 / 3\n   - [bInterfaceCount]:  bFunctionClass / bFunctionSubClass / bFunctionProtocol\n * Interface: 224 / 3 / 1\n   -  bInterfaceClass / bInterfaceSubClass / bInterfaceProtocol\n\n[*] \"Stock\" Android. I believe most Android phone tethering should behave\n    this way\n    * USBCompositeDevice: 0 / 0 / 0\n      - InterfaceAssociation[2] 224 / 1 / 3\n        - ControlInterface: 224 / 1 / 3\n        - DataInterface:     10 / 0 / 0\n    * Info.plist entry: RNDISControlStockAndroid(interface)\n\n[*] Linux USB Gadget drivers. Location:\n    <LINUX_KERNEL>/drivers/usb/gadget/function/f_rndis.c\n    These show up in various embedded Linux boards, such as Beagle Board,\n    Analog Devices PlutoSDR, etc.\n    * USBCompositeDevice: 0 / 0 / 0\n      - InterfaceAssociation[2]: Configurable (e.g. 2/6/0, 239/4/1).\n        - ControlInterface:  2 / 2 / 255\n        - DataInterface:    10 / 0 / 0\n    * Info.plist entry: RNDISControlLinuxGadget(interface)\n\n[*] Wireless Controller Device (class 224). Some Samsung phones (e.g. S7 Edge) \n    specify device class 224 for tethering, instead of just being a USB\n    composite device. The rest is the same as in \"stock\" Android.\n    Note, the other Samsung phones (e.g. S8) behave like other Android devices.\n\t* Device: 224 / 0 / 0\n\t  - (same as \"Stock\" Android)\n\n[*] Composite Device, using 0xEF/4/1 for RNDIS control: Nokia 7 Plus (issue #88)\n    Also may apply to Sony Xperia XZ.\n    This matches \"RNDIS over Ethernet\" specification given here:\n\thttp://www.usb.org/developers/defined_class/#BaseClassEFh\n    * USBCompositeDevice: 0 / 0 / 0\n\t  - InterfaceAssociation[2]: 239 / 4 / 1\n        - ControlInterface: 239 / 4 / 1\n        - DataInterface:     10 / 0 / 0\n\t* Info.plist entry: RNDISControlMiscDeviceRoE(interface)\n*/\n\n// Detects the 224/1/3 - stock Android RNDIS control interface.\nstatic inline bool isRNDISControlStockAndroid(const InterfaceDescriptor *idesc) {\n\treturn idesc->bInterfaceClass == 224  // Wireless Controller\n\t\t&& idesc->bInterfaceSubClass == 1  // Radio Frequency\n\t\t&& idesc->bInterfaceProtocol == 3;  // RNDIS protocol\n}\n\n// Miscellaneous Device (0xEF), RNDIS over Ethernet: some phones, see above.\nstatic inline bool isRNDISControlMiscDeviceRoE(const InterfaceDescriptor *idesc) {\n\treturn idesc->bInterfaceClass == 239  // Miscellaneous Device\n\t\t&& idesc->bInterfaceSubClass == 4  // RNDIS?\n\t\t&& idesc->bInterfaceProtocol == 1;  // RNDIS over Ethernet\n}\n\n// Detects RNDIS control on BeagleBoard and possibly other embedded Linux devices.\nstatic inline bool isRNDISControlLinuxGadget(const InterfaceDescriptor *idesc) {\n\treturn idesc->bInterfaceClass == 2  // Communications / CDC Control\n\t\t&& idesc->bInterfaceSubClass == 2  // Abstract (modem)\n\t\t&& idesc->bInterfaceProtocol == 255;  // Vendor Specific (RNDIS).\n}\n\n// Any of the above RNDIS control interface.\nstatic inline bool isRNDISControlInterface(const InterfaceDescriptor *idesc) {\n\treturn isRNDISControlStockAndroid(idesc)\n\t\t|| isRNDISControlLinuxGadget(idesc)\n\t\t|| isRNDISControlMiscDeviceRoE(idesc);\n}\n\n// Detects the class 10 - CDC data interface.\nstatic inline bool isCDCDataInterface(const InterfaceDescriptor *idesc) {\n\t// Check for CDC class. Sub-class and Protocol are undefined:\n\treturn idesc->bInterfaceClass == 10;\n}\n\nbool HoRNDIS::init(OSDictionary *properties) {\n\textern kmod_info_t kmod_info;  // Getting the version from generated file.\n\tLOG(V_NOTE, \"HoRNDIS tethering driver for Mac OS X, %s\", kmod_info.version);\n\t\n\tif (super::init(properties) == false) {\n\t\tLOG(V_ERROR, \"initialize superclass failed\");\n\t\treturn false;\n\t}\n\n\tLOG(V_PTR, \"PTR: I am: %p\", this);\n\t\n\tfNetworkInterface = NULL;\n\tfpNetStats = NULL;\n\n\tfReadyToTransfer = false;\n\tfNetifEnabled = false;\n\tfEnableDisableInProgress = false;\n\tfDataDead = false;\n\n\tfProbeConfigVal = 0;\n\tfProbeCommIfNum = 0;\n\n\tfCallbackCount = 0;\n\n\tfCommInterface = NULL;\n\tfDataInterface = NULL;\n\t\n\tfInPipe = NULL;\n\tfOutPipe = NULL;\n\n\tnumFreeOutBufs = 0;\n\tfor (int i = 0; i < N_OUT_BUFS; i++) {\n\t\toutbufs[i].mdp = NULL;\n\t\toutbufStack[i] = i;  // Value does not matter here.\n\t}\n\tfor (int i = 0 ; i < N_IN_BUFS; i++) {\n\t\tinbufs[i].mdp = NULL;\n\t}\n\n\trndisXid = 1;\n\tmaxOutTransferSize = 0;\n\t\n\treturn true;\n}\n\nvoid HoRNDIS::free() {\n\t// Here, we shall free everything allocated by the 'init'.\n\n\tLOG(V_NOTE, \"driver instance terminated\");  // For the default level\n\tsuper::free();\n}\n\n/*\n==================================================\nINTERFACE PROLIFERATION AND PROVIDER CLASS NAME\n==================================================\nPROBLEM:\n Every time you connect the same Android device (or somewhat more rarely),\n MacOS creates a new entry under \"Network\" configurations tab. These entries\n keep on coming on and on, polluting the configuration.\n \nROOT CAUSE:\n Android devices randomly-generate Ethernet MAC address for\n RNDIS interface, so the system may think there is a new device\n every time you connect an Android phone, and may create a new\n network interface every such time.\n Luckily, it does extra check when Network Provider is a USB device:\n in that case, it would match based on USB data, creating an entry like:\n\t\t<key>SCNetworkInterfaceInfo</key>\n\t\t<dict>\n\t\t\t<key>USB Product Name</key>\n\t\t\t<string>Pixel 2</string>\n\t\t\t<key>UserDefinedName</key>\n\t\t\t<string>Pixel 2</string>\n\t\t\t<key>idProduct</key>\n\t\t\t<integer>20195</integer>\n\t\t\t...\n In: /Library/Preferences/SystemConfiguration/NetworkInterfaces.plist\n When that works, interfaces do not proliferate (at least in most cases).\n\nPROBLEM CAUSE:\n The MacOS network daemon (or whatever it is) looks at interface's \n \"IOProviderClass\" to see if it's USB Device. Unfortunately, it may not pick\n up all the names, e.g. it may trigger off the old \"IOUSBDevice\", but not\n the new \"IOUSBHostDevice\". This problem is present in El Capitan for both\n device and the interface, and seems to be present in later systems for \n IOUSBDevice.\n \nFIX/HACK:\n The IOUSBHostDevice and IOUSBHostInterface providers actually specify\n the \"IOClassNameOverride\" that gives the old name. We just take this value\n and update our \"IOProviderClass\" to that.\n*/\n\nbool HoRNDIS::start(IOService *provider) {\n\tLOG(V_DEBUG, \">\");\n\n\t// Per comment in \"IONetworkController.h\", 'super::start' should be the\n\t// first method called in the overridden implementation. It allocates the\n\t// network queue for the interface. The rest of the networking\n\t// initialization will be done by 'createNetworkInterface', once USB\n\t// USB is ready.\n\tif(!super::start(provider)) {\n\t\treturn false;\n\t}\n\n\t{  // Fixing the Provider class name.\n\t\t// See \"INTERFACE PROLIFERATION AND PROVIDER CLASS NAME\" description.\n\t\tOSObject *providerClass = provider->getProperty(\"IOClassNameOverride\");\n\t\tif (providerClass) {\n\t\t\tsetProperty(kIOProviderClassKey, providerClass);\n\t\t}\n\t}\n\n\tif (!openUSBInterfaces(provider)) {\n\t\tgoto bailout;\n\t}\n\n\tif (!rndisInit()) {\n\t\tgoto bailout;\n\t}\n\n\t// NOTE: The RNDIS spec mandates the usage of Keep Alive timer; however,\n\t// the Android does not seem to be missing its absense, so there is\n\t// probably no use in implementing it.\n\n\tLOG(V_DEBUG, \"done with RNDIS initialization: can start network interface\");\n\n\t// Let's create the medium tables here, to avoid doing extra\n\t// steps in 'enable'. Also, comments recommend creating medium tables\n\t// in the 'setup' stage.\n\tconst IONetworkMedium *primaryMedium;\n\tif (!createMediumTables(&primaryMedium) ||\n\t\t!setCurrentMedium(primaryMedium)) {\n\t\tgoto bailout;\n\t}\n\t\n\t// Looks like everything's good... publish the interface!\n\tif (!createNetworkInterface()) {\n\t\tgoto bailout;\n\t}\n\n\t// This call is based on traces of Thunderbolt Ethernet driver.\n\t// That driver calls 'setLinkStatus(0x1)' before interface publish \n\t// callback (which happens after 'start').\n\tsetLinkStatus(kIONetworkLinkValid);\n\t\n\tLOG(V_DEBUG, \"successful\");\n\treturn true;\n\nbailout:\n\tstop(provider);\n\treturn false;\n}\n\nbool HoRNDIS::willTerminate(IOService *provider, IOOptionBits options) {\n\tLOG(V_DEBUG, \">\");\n\t// The 'willTerminate' is called when USB device disappears - the user\n\t// either disconnected the USB, or switched-off tethering. It's likely\n\t// that the pending read has already invoked a callback with unreachable\n\t// device or aborted status, and already terminated. If not, closing of\n\t// the USB Data interface would force it to abort.\n\t//\n\t// Note, per comments in 'IOUSBHostInterface.h' (for some later version\n\t// of MacOS SDK), this is the recommended place to close USB interfaces.\n\t//\n\t// This happens before ::stop, but after some of the read jobs fail\n\t// with kIOReturnNotResponding (and some of the writers might fail,\n\t// too).  ::disable happens sometime after we get done here, too --\n\t// potentially invoked by super::willTerminate.\n\t\n\tdisableNetworkQueue();\n\tcloseUSBInterfaces();\n\n\treturn super::willTerminate(provider, options);\n}\n\nvoid HoRNDIS::stop(IOService *provider) {\n\tLOG(V_DEBUG, \">\");\n\t\n\tOSSafeReleaseNULL(fNetworkInterface);\n\t\n\tcloseUSBInterfaces();  // Just in case - supposed to be closed by now.\n\n\tsuper::stop(provider);\n}\n\n\n// Convenience function: to retain and assign in one step:\ntemplate <class T> static inline T *retainT(T *ptr) {\n\tptr->retain();\n\treturn ptr;\n}\n\nbool HoRNDIS::openUSBInterfaces(IOService *provider) {\n\tif (fProbeConfigVal == 0) {\n\t\t// Must have been set by 'probe' before 'start' function call:\n\t\tLOG(V_ERROR, \"'fProbeConfigVal' has not been set, bailing out\");\n\t\treturn false;\n\t}\n\n\tIOUSBHostDevice *device = OSDynamicCast(IOUSBHostDevice, provider);\n\tif (device) {\n\t\t// Set the device configuration, so we can start looking at the interfaces:\n\t\tif (device->setConfiguration(fProbeConfigVal, false) != kIOReturnSuccess) {\n\t\t\tLOG(V_ERROR, \"Cannot set the USB Device configuration\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tIOUSBHostInterface *iface = OSDynamicCast(IOUSBHostInterface, provider);\n\t\tif (iface == NULL) {\n\t\t\tLOG(V_ERROR, \"start: BUG unexpected provider class\");\n\t\t\treturn false;\n\t\t}\n\t\tdevice = iface->getDevice();\n\t\t// Make sure it's the one we care about:\n\t\tbool match = iface->getConfigurationDescriptor()->bConfigurationValue == fProbeConfigVal\n\t\t\t&& iface->getInterfaceDescriptor()->bInterfaceNumber == fProbeCommIfNum;\n\t\tif (!match) {\n\t\t\tLOG(V_ERROR, \"BUG! Did we see a different provider in probe?\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t{  // Now, find the interfaces:\n\t\tOSIterator *iterator = device->getChildIterator(gIOServicePlane);\n\t\tOSObject *obj = NULL;\n\t\twhile(iterator != NULL && (obj = iterator->getNextObject()) != NULL) {\n\t\t\tIOUSBHostInterface *iface = OSDynamicCast(IOUSBHostInterface, obj);\n\t\t\tif (iface == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (iface->getConfigurationDescriptor()->bConfigurationValue !=\n\t\t\t\t\tfProbeConfigVal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst InterfaceDescriptor *desc = iface->getInterfaceDescriptor();\n\t\t\tuint8_t ifaceNum = desc->bInterfaceNumber;\n\t\t\tif (!fCommInterface && ifaceNum == fProbeCommIfNum) {\n\t\t\t\tLOG(V_DEBUG, \"Found control interface: %d/%d/%d, opening\",\n\t\t\t\t\tdesc->bInterfaceClass, desc->bInterfaceSubClass,\n\t\t\t\t\tdesc->bInterfaceProtocol);\n\t\t\t\tif (!iface->open(this)) {\n\t\t\t\t\tLOG(V_ERROR, \"Could not open RNDIS control interface\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Note, we retain AFTER opening the interface, because once\n\t\t\t\t// 'fCommInterface' is set, the 'closeUSBInterfaces' would\n\t\t\t\t// always try to close it before releasing:\n\t\t\t\tfCommInterface = retainT(iface);\n\t\t\t} else if (ifaceNum == fProbeCommIfNum + 1) {\n\t\t\t\tLOG(V_DEBUG, \"Found data interface: %d/%d/%d, opening\",\n\t\t\t\t\tdesc->bInterfaceClass, desc->bInterfaceSubClass,\n\t\t\t\t\tdesc->bInterfaceProtocol);\n\t\t\t\tif (!iface->open(this)) {\n\t\t\t\t\tLOG(V_ERROR, \"Could not open RNDIS data interface\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// open before retain, see above:\n\t\t\t\tfDataInterface = retainT(iface);\n\t\t\t\tbreak;  // We should be done by now.\n\t\t\t}\n\t\t}\n\t\tOSSafeReleaseNULL(iterator);\n\t}\n\n\t// WARNING, it is a WRONG idea to attach 'fDataInterface' as a second\n\t// provider, because both providers would be calling 'willTerminate', and\n\t// 'stop' methods, resulting in chaos.\n\n\tif (!fCommInterface || !fDataInterface) {\n\t\tLOG(V_ERROR, \"could not find the required interfaces, despite seeing \"\n\t\t\t\"their descriptors during 'probe' method call\");\n\t\treturn false;\n\t}\n\t\n\t{  // Get the pipes for the data interface:\n\t\tconst EndpointDescriptor *candidate = NULL;\n\t\tconst InterfaceDescriptor *intDesc = fDataInterface->getInterfaceDescriptor();\n\t\tconst ConfigurationDescriptor *confDesc = fDataInterface->getConfigurationDescriptor();\n\t\tif (intDesc->bNumEndpoints != 2) {\n\t\t\tLOG(V_ERROR, \"Expected 2 endpoints for Data Interface, got: %d\", intDesc->bNumEndpoints);\n\t\t\treturn false;\n\t\t}\n\t\twhile((candidate = StandardUSB::getNextEndpointDescriptor(\n\t\t\t\t\tconfDesc, intDesc, candidate)) != NULL) {\n\t\t\tconst bool isEPIn =\n\t\t\t\t(candidate->bEndpointAddress & kEndpointDescriptorDirection) != 0;\n\t\t\tIOUSBHostPipe *&pipe = isEPIn ? fInPipe : fOutPipe;\n\t\t\tif (pipe == NULL) {\n\t\t\t\t// Note, 'copyPipe' already performs 'retain': must not call it again.\n\t\t\t\tpipe = fDataInterface->copyPipe(candidate->bEndpointAddress);\n\t\t\t}\n\t\t}\n\t\tif (fInPipe == NULL || fOutPipe == NULL) {\n\t\t\tLOG(V_ERROR, \"Could not init IN/OUT pipes in the Data Interface\");\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nvoid HoRNDIS::closeUSBInterfaces() {\n\tfReadyToTransfer = false;  // Interfaces are about to be closed.\n\t// Close the interfaces - this would abort the transfers (if present):\n\tif (fDataInterface) {\n\t\tfDataInterface->close(this);\n\t}\n\tif (fCommInterface) {\n\t\tfCommInterface->close(this);\n\t}\n\n\tOSSafeReleaseNULL(fInPipe);\n\tOSSafeReleaseNULL(fOutPipe);\n\tOSSafeReleaseNULL(fDataInterface);\n\tOSSafeReleaseNULL(fCommInterface);  // First one to open, last one to die.\n}\n\nIOService *HoRNDIS::probe(IOService *provider, SInt32 *score) {\n\tLOG(V_DEBUG, \"came in with a score of %d\", *score);\n\t{  // Check if this is a device-based matching:\n\t\tIOUSBHostDevice *device = OSDynamicCast(IOUSBHostDevice, provider);\n\t\tif (device) {\n\t\t\treturn probeDevice(device, score);\n\t\t}\n\t}\n\t\n\tIOUSBHostInterface *controlIf = OSDynamicCast(IOUSBHostInterface, provider);\n \tif (controlIf == NULL) {\n\t\tLOG(V_ERROR, \"unexpected provider class (wrong Info.plist)\");\n\t\treturn NULL;\n\t}\n\n\tconst InterfaceDescriptor *desc = controlIf->getInterfaceDescriptor();\n\tLOG(V_DEBUG, \"Interface-based matching, probing for device '%s', \"\n\t\t\"interface %d/%d/%d\", controlIf->getDevice()->getName(),\n\t\tdesc->bInterfaceClass, desc->bInterfaceSubClass,\n\t\tdesc->bInterfaceProtocol);\n\tif (!isRNDISControlInterface(controlIf->getInterfaceDescriptor())) {\n\t\tLOG(V_ERROR, \"not RNDIS control interface (wrong Info.plist)\");\n\t\treturn NULL;\n\t}\n\n\tconst ConfigurationDescriptor *configDesc =\n\t\tcontrolIf->getConfigurationDescriptor();\n\tconst InterfaceDescriptor *dataDesc =\n\t\tStandardUSB::getNextInterfaceDescriptor(configDesc, desc);\n\tbool match = isCDCDataInterface(dataDesc) &&\n\t\t(dataDesc->bInterfaceNumber == desc->bInterfaceNumber + 1);\n\tif (!match) {\n\t\tLOG(V_DEBUG, \"Could not find CDC data interface right after control\");\n\t\treturn NULL;\n\t}\n\tfProbeConfigVal = configDesc->bConfigurationValue;\n\tfProbeCommIfNum = desc->bInterfaceNumber;\n\t*score += 100000;\n\treturn this;\n}\n\nIOService *HoRNDIS::probeDevice(IOUSBHostDevice *device, SInt32 *score) {\n\tconst DeviceDescriptor *desc = device->getDeviceDescriptor();\n\tLOG(V_DEBUG, \"Device-based matching, probing: '%s', %d/%d/%d\",\n\t\tdevice->getName(), desc->bDeviceClass, desc->bDeviceSubClass,\n\t\tdesc->bDeviceProtocol);\n\t// Look through all configurations and find the one we want:\n\tfor (int i = 0; i < desc->bNumConfigurations; i++) {\n\t\tconst ConfigurationDescriptor *configDesc =\n\t\t\tdevice->getConfigurationDescriptor(i);\n\t\tif (configDesc == NULL) {\n\t\t\tLOG(V_ERROR, \"Cannot get device's configuration descriptor\");\n\t\t\treturn NULL;\n\t\t}\n\t\tint controlIfNum = INT16_MAX;  // Definitely invalid interface number.\n\t\tbool foundData = false;\n\t\tconst InterfaceDescriptor *intDesc = NULL;\n\t\twhile((intDesc = StandardUSB::getNextInterfaceDescriptor(configDesc, intDesc)) != NULL) {\n\t\t\t// If this is a device-level match, check for the control interface:\n\t\t\tif (isRNDISControlInterface(intDesc)) {  // Just check them all.\n\t\t\t\tcontrolIfNum = intDesc->bInterfaceNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\n\t\t\t// We check for data interface AND make sure it follows directly the\n\t\t\t// control interface. Note the condition below would only trigger\n\t\t\t// if we previously found an appropriate 'controlIfNum':\n\t\t\tif (isCDCDataInterface(intDesc) &&\n\t\t\t\tintDesc->bInterfaceNumber == controlIfNum + 1) {\n\t\t\t\tfoundData = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (foundData) {\n\t\t\t// We've found it! Save the information and return:\n\t\t\tfProbeConfigVal = configDesc->bConfigurationValue;\n\t\t\tfProbeCommIfNum = controlIfNum;\n\t\t\t*score += 10000;\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t// Did not find any interfaces we can use:\n\tLOG(V_DEBUG, \"The device '%s' does not contain the required interfaces: \"\n\t\t\t\"it is not for us\", device->getName());\n\treturn NULL;\n}\n\n/***** Ethernet interface bits *****/\n\n/* We need our own createInterface (overriding the one in IOEthernetController) \n * because we need our own subclass of IOEthernetInterface.  Why's that, you say?\n * Well, we need that because that's the only way to set a different default MTU,\n * because it seems like MacOS code just assumes that any EthernetController\n * driver must be able to handle al leaset 1500-byte Ethernet payload.\n * Sigh...\n * The MTU-limiting code may never come into play though, because the devices\n * I've seen have \"max_transfer_size\" large enough to accomodate a max-length \n * Ethernet frames. */\n\nbool HoRNDISInterface::init(IONetworkController *controller, int mtu) {\n\tmaxmtu = mtu;\n\tif (IOEthernetInterface::init(controller) == false) {\n\t\treturn false;\n\t}\n\tLOG(V_NOTE, \"(network interface) starting up with MTU %d\", mtu);\n\tsetMaxTransferUnit(mtu);\n\treturn true;\n}\n\nbool HoRNDISInterface::setMaxTransferUnit(UInt32 mtu) {\n\tif (mtu > maxmtu) {\n\t\tLOG(V_NOTE, \"Excuse me, but I said you could have an MTU of %u, and you just tried to set an MTU of %d.  Good try, buddy.\", maxmtu, mtu);\n\t\treturn false;\n\t}\n\tIOEthernetInterface::setMaxTransferUnit(mtu);\n\treturn true;\n}\n\n/* Overrides IOEthernetController::createInterface */\nIONetworkInterface *HoRNDIS::createInterface() {\n\tLOG(V_DEBUG, \">\");\n\tHoRNDISInterface *netif = new HoRNDISInterface;\n\t\n\tif (!netif) {\n\t\treturn NULL;\n\t}\n\n\tint mtuLimit = maxOutTransferSize\n\t\t- (int)sizeof(rndis_data_hdr)\n\t\t- 14;  // Size of ethernet header (no QLANs). Checksum is not included.\n\n\tif (!netif->init(this, min(ETHERNET_MTU, mtuLimit))) {\n\t\tnetif->release();\n\t\treturn NULL;\n\t}\n\t\n\treturn netif;\n}\n\nbool HoRNDIS::createNetworkInterface() {\n\tLOG(V_DEBUG, \"attaching and registering interface\");\n\t\n\t// MTU is initialized before we get here, so this is a safe time to do this.\n\tif (!attachInterface((IONetworkInterface **)&fNetworkInterface, true)) {\n\t\tLOG(V_ERROR, \"attachInterface failed?\");\t  \n\t\treturn false;\n\t}\n\tLOG(V_PTR, \"fNetworkInterface: %p\", fNetworkInterface);\n\n\t// The 'registerService' should be called by 'attachInterface' (with second\n\t// parameter set to true). No need to do it here.\n\t\n\treturn true;\t\n}\n\n/***** Interface enable and disable logic *****/\nHoRNDIS::ReentryLocker::ReentryLocker(IOCommandGate *inGate, bool &inGuard)\n\t\t: gate(inGate), entryGuard(inGuard), result(kIOReturnSuccess) {\n\t// Note, please see header comment for the motivation behind\n\t// 'ReentryLocker' and its high-level functionality.\n\t// Wait until we exit the previously-entered enable or disable method:\n\twhile (entryGuard) {\n\t\tLOG(V_DEBUG, \"Delaying the re-entered call\");\n\t\tresult = gate->commandSleep(&entryGuard);\n\t\t// If \"commandSleep\" has failed, stop immediately, and don't\n\t\t// touch the 'entryGuard':\n\t\tif (isInterrupted()) {\n\t\t\treturn;\n\t\t}\n\t}\n\tentryGuard = true;  // Mark the entry into one of the protected methods.\n}\n\nHoRNDIS::ReentryLocker::~ReentryLocker() {\n\tif (!isInterrupted()) {\n\t\tentryGuard = false;\n\t\tgate->commandWakeup(&entryGuard);\n\t}\n}\n\nstatic IOReturn loopClearPipeStall(IOUSBHostPipe *pipe) {\n\tIOReturn rc = kUSBHostReturnPipeStalled;\n\tint count = 0;\n\t// For some reason, 'clearStall' may keep on returning\n\t// kUSBHostReturnPipeStalled many times, before finally returning success\n\t// (Android keeps on sending packtes, each generating a stall?).\n\tconst int NUM_RETRIES = 1000;\n\tfor (; count < NUM_RETRIES && rc == kUSBHostReturnPipeStalled; count++) {\n\t\trc = pipe->clearStall(true);\n\t}\n\tLOG(V_DEBUG, \"Called 'clearStall' %d times\", count);\n\treturn rc;\n}\n\n/*!\n * Calls 'pipe->io', and if there is a stall, tries to clear that \n * stall and calls it again.\n */\nstatic inline IOReturn robustIO(IOUSBHostPipe *pipe, pipebuf_t *buf,\n\tuint32_t len) {\n\tIOReturn rc = pipe->io(buf->mdp, len, &buf->comp);\n\tif (rc == kUSBHostReturnPipeStalled) {\n\t\tLOG(V_DEBUG, \"USB Pipe is stalled. Trying to clear ...\");\n\t\trc = loopClearPipeStall(pipe);\n\t\t// If clearing the stall succeeded, try the IO operation again:\n\t\tif (rc == kIOReturnSuccess) {\n\t\t\tLOG(V_DEBUG, \"Cleared USB Stall, Retrying the operation\");\n\t\t\trc = pipe->io(buf->mdp, len, &buf->comp);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/* Contains buffer alloc and dealloc, notably.  Why do that here?  \n   Not just because that's what Apple did. We don't want to consume these \n   resources when the interface is sitting disabled and unused. */\nIOReturn HoRNDIS::enable(IONetworkInterface *netif) {\n\tIOReturn rtn = kIOReturnSuccess;\n\n\tLOG(V_DEBUG, \"begin for thread_id=%lld\", thread_tid(current_thread()));\n\tReentryLocker locker(this, fEnableDisableInProgress);\n\tif (locker.isInterrupted()) {\n\t\tLOG(V_ERROR, \"Waiting interrupted\");\n\t\treturn locker.getResult();\n\t}\n\n\tif (fNetifEnabled) {\n\t\tLOG(V_DEBUG, \"Repeated call (thread_id=%lld), returning success\",\n\t\t\tthread_tid(current_thread()));\n\t\treturn kIOReturnSuccess;\n\t}\n\n\tif (fCallbackCount != 0) {\n\t\tLOG(V_ERROR, \"Invalid state: fCallbackCount(=%d) != 0\", fCallbackCount);\n\t\treturn kIOReturnError;\n\t}\n\n\tif (!allocateResources()) {\n\t\treturn kIOReturnNoMemory;\n\t}\n\n\t// Tell the other end to start transmitting.\n\tif (!rndisSetPacketFilter(RNDIS_DEFAULT_FILTER)) {\n\t\tgoto bailout;\n\t}\n\n\t// The pipe stall clearning is not needed for the first \"enable\" call after\n\t// pugging in the device, but it becomes necessary when \"disable\" is called\n\t// after that, followed by another \"enable\". This happens when user runs\n\t// \"sudo ifconfig <netif> down\", followed by \"sudo ifconfig <netif> up\"\n\tLOG(V_DEBUG, \"Clearing potential Pipe stalls on Input and Output pipes\");\n\tloopClearPipeStall(fInPipe);\n\tloopClearPipeStall(fOutPipe);\n\n\t// We can now perform reads and writes between Network stack and USB device:\n\tfReadyToTransfer = true;\n\t\n\t// Kick off the read requests:\n\tfor (int i = 0; i < N_IN_BUFS; i++) {\n\t\tpipebuf_t &inbuf = inbufs[i];\n\t\tinbuf.comp.owner = this;\n\t\tinbuf.comp.action = dataReadComplete;\n\t\tinbuf.comp.parameter = &inbuf;\n\n\t\trtn = robustIO(fInPipe, &inbuf, (uint32_t)inbuf.mdp->getLength());\n\t\tif (rtn != kIOReturnSuccess) {\n\t\t\tLOG(V_ERROR, \"Failed to start the first read: %08x\\n\", rtn);\n\t\t\tgoto bailout;\n\t\t}\n\t\tfCallbackCount++;\n\t}\n\n\t// Tell the world that the link is up...\n\tif (!setLinkStatus(kIONetworkLinkActive | kIONetworkLinkValid,\n\t\t\tgetCurrentMedium())) {\n\t\tLOG(V_ERROR, \"Cannot set link status\");\n\t\trtn = kIOReturnError;\n\t\tgoto bailout;\n\t}\n\n\t// ... and then listen for packets!\n\tgetOutputQueue()->setCapacity(TRANSMIT_QUEUE_SIZE);\n\tgetOutputQueue()->start();\n\tLOG(V_DEBUG, \"txqueue started\");\n\n\t// Now we can say we're alive.\n\tfNetifEnabled = true;\n\tLOG(V_NOTE, \"completed (thread_id=%lld): RNDIS network interface '%s' \"\n\t\t\"should be live now\", thread_tid(current_thread()), netif->getName());\n\t\n\treturn kIOReturnSuccess;\n\t\nbailout:\n\tdisableImpl();\n\treturn rtn;\n}\n\nvoid HoRNDIS::disableNetworkQueue() {\n\t// Disable the queue (no more outputPacket),\n\t// and then flush everything in the queue.\n\tgetOutputQueue()->stop();\n\tgetOutputQueue()->flush();\n\tgetOutputQueue()->setCapacity(0);\n}\n\nIOReturn HoRNDIS::disable(IONetworkInterface *netif) {\n\tLOG(V_DEBUG, \"begin for thread_id=%lld\", thread_tid(current_thread()));\n\t// This function can be called as a consequence of:\n\t//  1. USB Disconnect\n\t//  2. Some action, while the device is up and running\n\t//     (e.g. \"ifconfig en6 down\").\n\t// In the second case, we'll need to do more cleanup:\n\t// ask the RNDIS device to stop transmitting, and abort the callbacks.\n\t//\n\n\tReentryLocker locker(this, fEnableDisableInProgress);\n\tif (locker.isInterrupted()) {\n\t\tLOG(V_ERROR, \"Waiting interrupted\");\n\t\treturn locker.getResult();\n\t}\n\n\tif (!fNetifEnabled) {\n\t\tLOG(V_DEBUG, \"Repeated call (thread_id=%lld)\", thread_tid(current_thread()));\n\t\treturn kIOReturnSuccess;\n\t}\n\n\tdisableImpl();\n\n\tLOG(V_DEBUG, \"completed (thread_id=%lld)\", thread_tid(current_thread()));\n\treturn kIOReturnSuccess;\n}\n\nvoid HoRNDIS::disableImpl() {\n\tdisableNetworkQueue();\n\n\t// Stop the the new transfers. The code below would cancel the pending ones:\n\tfReadyToTransfer = false;\n\n\t// If the device has not been disconnected, ask it to stop xmitting:\n\tif (fCommInterface) {\n\t\trndisSetPacketFilter(0);\n\t}\n\n\t// Again, based on Thunderbolt Ethernet controller traces.\n\t// It sets the link status to 0x1 in the disable call:\n\tsetLinkStatus(kIONetworkLinkValid, 0);\n\n\t// If USB interfaces are still up, abort the reader and writer:\n\tif (fInPipe) {\n\t\tfInPipe->abort(IOUSBHostIOSource::kAbortSynchronous,\n\t\t\tkIOReturnAborted, NULL);\n\t}\n\tif (fOutPipe) {\n\t\tfOutPipe->abort(IOUSBHostIOSource::kAbortSynchronous,\n\t\t\tkIOReturnAborted, NULL);\n\t}\n\t// Make sure all the callbacks have exited:\n\tLOG(V_DEBUG, \"Callback count: %d. If not zero, delaying ...\",\n\t\tfCallbackCount);\n\twhile (fCallbackCount > 0) {\n\t\t// No timeout: in our callbacks we trust!\n\t\tgetCommandGate()->commandSleep(&fCallbackCount);\n\t}\n\tLOG(V_DEBUG, \"All callbacks exited\");\n\n\t// Release all resources\n\treleaseResources();\n\n\tfNetifEnabled = false;\n}\n\nbool HoRNDIS::createMediumTables(const IONetworkMedium **primary) {\n\tIONetworkMedium\t*medium;\n\t\n\tOSDictionary *mediumDict = OSDictionary::withCapacity(1);\n\tif (mediumDict == NULL) {\n\t\tLOG(V_ERROR, \"Cannot allocate OSDictionary\");\n\t\treturn false;\n\t}\n\t\n\tmedium = IONetworkMedium::medium(kIOMediumEthernetAuto, 480 * 1000000);\n\tIONetworkMedium::addMedium(mediumDict, medium);\n\tmedium->release();  // 'mediumDict' holds a ref now.\n\tif (primary) {\n\t\t*primary = medium;\n\t}\n\t\n\tbool result = publishMediumDictionary(mediumDict);\n\tif (!result) {\n\t\tLOG(V_ERROR, \"Cannot publish medium dictionary!\");\n\t}\n\n\t// Per comment for 'publishMediumDictionary' in NetworkController.h, the\n\t// medium dictionary is copied and may be safely relseased after the call.\n\tmediumDict->release();\n\t\n\treturn result;\n}\n\nbool HoRNDIS::allocateResources() {\n\tLOG(V_DEBUG, \"Allocating %d input buffers (size=%d) and %d output \"\n\t\t\"buffers (size=%d)\", N_IN_BUFS, IN_BUF_SIZE, N_OUT_BUFS, OUT_BUF_SIZE);\n\t\n\t// Grab a memory descriptor pointer for data-in.\n\tfor (int i = 0; i < N_IN_BUFS; i++) {\n\t\tinbufs[i].mdp = IOBufferMemoryDescriptor::withCapacity(IN_BUF_SIZE, kIODirectionIn);\n\t\tif (!inbufs[i].mdp) {\n\t\t\treturn false;\n\t\t}\n\t\tinbufs[i].mdp->setLength(IN_BUF_SIZE);\n\t\tLOG(V_PTR, \"PTR: inbuf[%d].mdp: %p\", i, inbufs[i].mdp);\n\t}\n\n\t// And a handful for data-out...\n\tfor (int i = 0; i < N_OUT_BUFS; i++) {\n\t\toutbufs[i].mdp = IOBufferMemoryDescriptor::withCapacity(\n\t\t\tOUT_BUF_SIZE, kIODirectionOut);\n\t\tif (!outbufs[i].mdp) {\n\t\t\tLOG(V_ERROR, \"allocate output descriptor failed\");\n\t\t\treturn false;\n\t\t}\n\t\tLOG(V_PTR, \"PTR: outbufs[%d].mdp: %p\", i, outbufs[i].mdp);\n\t\toutbufs[i].mdp->setLength(OUT_BUF_SIZE);\n\t\toutbufStack[i] = i;\n\t}\n\tnumFreeOutBufs = N_OUT_BUFS;\n\t\n\treturn true;\n}\n\nvoid HoRNDIS::releaseResources() {\n\tLOG(V_DEBUG, \"releaseResources\");\n\n\tfReadyToTransfer = false;  // No transfers without buffers.\n\tfor (int i = 0; i < N_OUT_BUFS; i++) {\n\t\tOSSafeReleaseNULL(outbufs[i].mdp);\n\t\toutbufStack[i] = i;\n\t}\n\tnumFreeOutBufs = 0;\n\n\tfor (int i = 0; i < N_IN_BUFS; i++) {\n\t\tOSSafeReleaseNULL(inbufs[i].mdp);\n\t}\n}\n\nIOOutputQueue *HoRNDIS::createOutputQueue() {\n\tLOG(V_DEBUG, \">\");\n\t// The gated Output Queue keeps things simple: everything is\n\t// serialized, no need to worry about locks or concurrency.\n\t// The device is not very fast, so the serial execution should be more\n\t// than capable of keeping up.\n\t// Note, if we ever switch to non-gated queue, we shall update the\n\t// 'outputPacket' to access the shared state using locks + update all the\n\t// other users of that state + may want to use locks for USB calls as well.\n\treturn IOGatedOutputQueue::withTarget(this,\n\t\tgetWorkLoop(), TRANSMIT_QUEUE_SIZE);\n}\n\nbool HoRNDIS::configureInterface(IONetworkInterface *netif) {\n\tLOG(V_DEBUG, \">\");\n\tIONetworkData *nd;\n\t\n\tif (super::configureInterface(netif) == false) {\n\t\tLOG(V_ERROR, \"super failed\");\n\t\treturn false;\n\t}\n\t\n\tnd = netif->getNetworkData(kIONetworkStatsKey);\n\tif (!nd || !(fpNetStats = (IONetworkStats *)nd->getBuffer())) {\n\t\tLOG(V_ERROR, \"network statistics buffer unavailable?\");\n\t\treturn false;\n\t}\n\t\n\tLOG(V_PTR, \"fpNetStats: %p\", fpNetStats);\n\t\n\treturn true;\n}\n\n\n/***** All-purpose IOKit network routines *****/\n\nIOReturn HoRNDIS::getPacketFilters(const OSSymbol *group, UInt32 *filters) const {\n\tIOReturn\trtn = kIOReturnSuccess;\n\t\n\tif (group == gIOEthernetWakeOnLANFilterGroup) {\n\t\t*filters = 0;\n\t} else if (group == gIONetworkFilterGroup) {\n\t\t*filters = kIOPacketFilterUnicast | kIOPacketFilterBroadcast\n\t\t\t| kIOPacketFilterPromiscuous | kIOPacketFilterMulticast\n\t\t\t| kIOPacketFilterMulticastAll;\n\t} else {\n\t\trtn = super::getPacketFilters(group, filters);\n\t}\n\n\treturn rtn;\n}\n\nIOReturn HoRNDIS::getMaxPacketSize(UInt32 *maxSize) const {\n\tIOReturn rc = super::getMaxPacketSize(maxSize);\n\tif (rc != kIOReturnSuccess) {\n\t\treturn rc;\n\t}\n\t// The max packet size is limited by RNDIS max transfer size:\n\t*maxSize = min(*maxSize, maxOutTransferSize - sizeof(rndis_data_hdr));\n\tLOG(V_DEBUG, \"returning %d\", *maxSize);\n\treturn kIOReturnSuccess;\n}\n\nIOReturn HoRNDIS::selectMedium(const IONetworkMedium *medium) {\n\tLOG(V_DEBUG, \">\");\n\tsetSelectedMedium(medium);\n\t\n\treturn kIOReturnSuccess;\n}\n\nIOReturn HoRNDIS::getHardwareAddress(IOEthernetAddress *ea) {\n\tLOG(V_DEBUG, \">\");\n\tUInt32\t  i;\n\tvoid *buf;\n\tunsigned char *bp;\n\tint rlen = -1;\n\tint rv;\n\t\n\tbuf = IOMallocAligned(RNDIS_CMD_BUF_SZ, sizeof(void *));\n\tif (!buf) {\n\t\treturn kIOReturnNoMemory;\n\t}\n\n\t// WARNING: Android devices may randomly-generate RNDIS MAC address.\n\t// The function may return different results for the same device.\n\n\trv = rndisQuery(buf, OID_802_3_PERMANENT_ADDRESS, 48, (void **) &bp, &rlen);\n\tif (rv < 0) {\n\t\tLOG(V_ERROR, \"getHardwareAddress OID failed?\");\n\t\tIOFreeAligned(buf, RNDIS_CMD_BUF_SZ);\n\t\treturn kIOReturnIOError;\n\t}\n\tLOG(V_DEBUG, \"MAC Address %02x:%02x:%02x:%02x:%02x:%02x -- rlen %d\",\n\t      bp[0], bp[1], bp[2], bp[3], bp[4], bp[5],\n\t      rlen);\n\t\n\tfor (i=0; i<6; i++) {\n\t\tea->bytes[i] = bp[i];\n\t}\n\t\n\tIOFreeAligned(buf, RNDIS_CMD_BUF_SZ);\n\treturn kIOReturnSuccess;\n}\n\nIOReturn HoRNDIS::setMulticastMode(bool active) {\n\t// For 'real' RNDIS devices, this should toggle\n\t// RNDIS_PACKET_TYPE_ALL_MULTICAST or RNDIS_PACKET_TYPE_MULTICAST\n\t// via 'rndisSetPacketFilter', but Android/Linux kernel\n\t// doesn't care, so why should we?\n\treturn kIOReturnSuccess;\n}\n\nIOReturn HoRNDIS::setMulticastList(IOEthernetAddress *addrs,\n\t                            UInt32             count) {\n\t// \"Honey Badger don't care\". We're using MULTICAST_ALL flag: everything\n\t// gets passed through.\n\treturn kIOReturnSuccess;\n}\n\nIOReturn HoRNDIS::setPromiscuousMode(bool active) {\n\t// Similar to 'setMulticastMode'.\n\t// XXX This actually needs to get passed down to support 'real'\n\t//  RNDIS devices, but it will work okay for Android devices.\n\treturn kIOReturnSuccess;\n}\n\n/***** Packet transmit logic *****/\n\nstatic inline bool isTransferStopStatus(IOReturn rc) {\n\t// IOReturn indicating that we need to stop transfers:\n\treturn rc == kIOReturnAborted || rc == kIOReturnNotResponding;\n}\n\nUInt32 HoRNDIS::outputPacket(mbuf_t packet, void *param) {\n\tIOReturn ior = kIOReturnSuccess;\n\tint poolIndx = N_OUT_BUFS;\n\n\t// Note, this function MAY or MAY NOT be protected by the IOCommandGate,\n\t// depending on the kind of OutputQueue used.\n\t// Here, we assume that IOCommandGate is used: no need to lock.\n\n\tif (!fReadyToTransfer) {\n\t\t// Technically, we must never be here, because we always disable the\n\t\t// queue before clearing 'fReadyToTransfer', but double-checking here\n\t\t// just in-case: better safe than sorry.\n\t\tLOG(V_DEBUG, \"fReadyToTransfer=false: dropping packet \"\n\t\t\t\"(we shouldn't even be here)\");\n\t\tfreePacket(packet);\n\t\treturn kIOReturnOutputDropped;\n\t}\n\t\n\t// Count the total size of this packet\n\tsize_t pktlen = 0;\n\tfor (mbuf_t m = packet; m; m = mbuf_next(m)) {\n\t\tpktlen += mbuf_len(m);\n\t}\n\t\n\tLOG(V_PACKET, \"%ld bytes\", pktlen);\n\n\tconst uint32_t transmitLength = (uint32_t)(pktlen + sizeof(rndis_data_hdr));\n\t\n\tif (transmitLength > maxOutTransferSize) {\n\t\tLOG(V_ERROR, \"packet too large (%ld bytes, maximum can transmit %ld)\",\n\t\t\tpktlen, maxOutTransferSize - sizeof(rndis_data_hdr));\n\t\tfpNetStats->outputErrors++;\n\t\tfreePacket(packet);\n\t\treturn kIOReturnOutputDropped;\n\t}\n\n\tif (numFreeOutBufs <= 0) {\n\t\tLOG(V_ERROR, \"BUG: Ran out of buffers - stall did not work!\");\n\t\t// Stall the queue and re-try the same packet later: don't release:\n\t\treturn kIOOutputStatusRetry | kIOOutputCommandStall;\n\t}\n\n\t// Note, we don't decrement 'numFreeOutBufs' (commit to using that buffer)\n\t// until everything is successful.\n\tpoolIndx = outbufStack[numFreeOutBufs - 1];\n\tif (poolIndx < 0 || poolIndx >= N_OUT_BUFS) {\n\t\tLOG(V_ERROR, \"BUG: poolIndex out-of-bounds\");\n\t\tfreePacket(packet);\n\t\treturn kIOReturnOutputDropped;\n\t}\n\n\t// Start filling in the send buffer\n\tstruct rndis_data_hdr *hdr;\n\thdr = (struct rndis_data_hdr *)outbufs[poolIndx].mdp->getBytesNoCopy();\n\n\toutbufs[poolIndx].mdp->setLength(transmitLength);\n\t\n\tmemset(hdr, 0, sizeof *hdr);\n\thdr->msg_type = RNDIS_MSG_PACKET;\n\thdr->msg_len = cpu_to_le32(pktlen + sizeof *hdr);\n\thdr->data_offset = cpu_to_le32(sizeof(*hdr) - 8);\n\thdr->data_len = cpu_to_le32(pktlen);\n\tmbuf_copydata(packet, 0, pktlen, hdr + 1);\n\t\n\tfreePacket(packet);\n\tpacket = NULL;\n\t\n\t// Now, fire it off!\n\tIOUSBHostCompletion *const comp = &outbufs[poolIndx].comp;\n\tcomp->owner     = this;\n\tcomp->parameter = (void *)(uintptr_t)poolIndx;\n\tcomp->action    = dataWriteComplete;\n\t\n\tior = robustIO(fOutPipe, &outbufs[poolIndx], transmitLength);\n\tif (ior != kIOReturnSuccess) {\n\t\tif (isTransferStopStatus(ior)) {\n\t\t\tLOG(V_DEBUG, \"WRITER: The device was possibly disconnected: ignoring the error\");\n\t\t} else {\n\t\t\tLOG(V_ERROR, \"write failed: %08x\", ior);\n\t\t\tfpNetStats->outputErrors++;\n\t\t}\n\t\t// Packet was already freed: just quit:\n\t\treturn kIOReturnOutputDropped;\n\t}\n\t// Only here - when 'fOutPipe->io' has fired - we mark the buffer in-use:\n\tnumFreeOutBufs--;\n\tfCallbackCount++;\n\tfpNetStats->outputPackets++;\n\t// If we ran out of free buffers, issue a stall command to the queue.\n\t// Note, this would be \"we accept this packet, but don't give us more yet\",\n\t// which is NOT the same as 'kIOReturnOutputStall'.\n\tconst bool stallQueue = (numFreeOutBufs == 0);\n\tif (stallQueue) {\n\t\tLOG(V_PACKET, \"Issuing stall command to the output queue\");\n\t}\n\treturn kIOOutputStatusAccepted |\n\t\t(stallQueue ? kIOOutputCommandStall : kIOOutputCommandNone);\n}\n\nvoid HoRNDIS::callbackExit() {\n\tfCallbackCount--;\n\t// Notify the 'disable' that may be waiting for callback count to reach 0:\n\tif (fCallbackCount <= 0) {\n\t\tLOG(V_DEBUG, \"Notifying last callback exited\");\n\t\tgetCommandGate()->commandWakeup(&fCallbackCount);\n\t}\n}\n\nvoid HoRNDIS::dataWriteComplete(void *obj, void *param, IOReturn rc, UInt32 transferred) {\n\tHoRNDIS\t*me = (HoRNDIS *)obj;\n\tunsigned long poolIndx = (unsigned long)param;\n\t\n\tpoolIndx = (unsigned long)param;\n\n\tLOG(V_PACKET, \"(rc %08x, poolIndx %ld)\", rc, poolIndx);\n\t// Callback completed. We don't know when/if we launch another one:\n\tme->callbackExit();\n\n\t// Note, if 'fReadyToTransfer' is false, we shall not go further:\n\t// it's a good idea NOT to touch the 'outbufs'.\n\tif (isTransferStopStatus(rc) || !me->fReadyToTransfer) {\n\t\tLOG(V_DEBUG, \"Data Write Aborted, or ready-to-transfer is cleared.\");\n\t\treturn;\n\t}\n\n\tif (rc != kIOReturnSuccess) {\n\t\t// Write error. In case of pipe stall,\n\t\t// we shall clear it on the next transmit.\n\t\tLOG(V_ERROR, \"I/O error: %08x\", rc);\n\t}\n\n\t// Free the buffer: put the index back onto the stack:\n\tif (me->numFreeOutBufs >= N_OUT_BUFS) {\n\t\tLOG(V_ERROR, \"BUG: more free buffers than was allocated\");\n\t\treturn;\n\t}\n\n\tme->outbufStack[me->numFreeOutBufs] = poolIndx;\n\tme->numFreeOutBufs++;\n\t// Unstall the queue whenever the number of free buffers goes 0->1.\n\t// I.e. we unstall it the moment we're able to write something into it:\n\tif (me->numFreeOutBufs == 1) {\n\t\tme->getOutputQueue()->service();\n\t}\n}\n\n\n/***** Packet receive logic *****/\nvoid HoRNDIS::dataReadComplete(void *obj, void *param, IOReturn rc, UInt32 transferred) {\n\tHoRNDIS\t*me = (HoRNDIS *)obj;\n\tpipebuf_t *inbuf = (pipebuf_t *)param;\n\tIOReturn ior;\n\n\t// Stop conditions. Not separating them out, since reacting to individual\n\t// ones would be very timing-sansitive.\n\tif (isTransferStopStatus(rc) || !me->fReadyToTransfer) {\n\t\tLOG(V_DEBUG, \"READER STOPPED: USB device aborted or not responding, \"\n\t\t\t\"or 'fReadyToTransfer' flag is cleared.\");\n\t\tme->callbackExit();\n\t\treturn;\n\t}\n\t\n\tif (rc == kIOReturnSuccess) {\n\t\t// Got one?  Hand it to the back end.\n\t\tLOG(V_PACKET, \"Reader(%ld), tid=%lld: %d bytes\", inbuf - me->inbufs,\n\t\t\tthread_tid(current_thread()), transferred);\n\t\tme->receivePacket(inbuf->mdp->getBytesNoCopy(), transferred);\n\t} else {\n\t\tLOG(V_ERROR, \"dataReadComplete: I/O error: %08x\", rc);\n\t}\n\t\n\t// Queue the next one up.\n\tior = robustIO(me->fInPipe, inbuf, (uint32_t)inbuf->mdp->getLength());\n\tif (ior == kIOReturnSuccess) {\n\t\treturn;  // Callback is in-progress.\n\t}\n\n\tLOG(V_ERROR, \"READER STOPPED: USB failure trying to read: %08x\", ior);\n\tme->callbackExit();\n\tme->fDataDead = true;\n}\n\n/*!\n * Transfer the packet we've received to the MAC OS Network stack.\n */\nvoid HoRNDIS::receivePacket(void *packet, UInt32 size) {\n\tmbuf_t m;\n\tUInt32 submit;\n\tIOReturn rv;\n\t\n\tLOG(V_PACKET, \"packet sz %d\", (int)size);\n\t\n\twhile (size) {\n\t\tstruct rndis_data_hdr *hdr = (struct rndis_data_hdr *)packet;\n\t\tuint32_t msg_len, data_ofs, data_len;\n\t\t\n\t\tif (size <= sizeof(struct rndis_data_hdr)) {\n\t\t\tLOG(V_ERROR, \"receivePacket() on too small packet? (size %d)\", size);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmsg_len = le32_to_cpu(hdr->msg_len);\n\t\tdata_ofs = le32_to_cpu(hdr->data_offset);\n\t\tdata_len = le32_to_cpu(hdr->data_len);\n\t\t\n\t\tif (hdr->msg_type != RNDIS_MSG_PACKET) { // both are LE, so that's okay\n\t\t\tLOG(V_ERROR, \"non-PACKET over data channel? (msg_type %08x)\", hdr->msg_type);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (msg_len > size) {\n\t\t\tLOG(V_ERROR, \"msg_len too big?\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ((data_ofs + data_len + 8) > msg_len) {\n\t\t\tLOG(V_ERROR, \"data bigger than msg?\");\n\t\t\treturn;\n\t\t}\n\t\n\t\tm = allocatePacket(data_len);\n\t\tif (!m) {\n\t\t\tLOG(V_ERROR, \"allocatePacket for data_len %d failed\", data_len);\n\t\t\tfpNetStats->inputErrors++;\n\t\t\treturn;\n\t\t}\n\t\tLOG(V_PTR, \"PTR: mbuf: %p\", m);\n\t\t\n\t\trv = mbuf_copyback(m, 0, data_len, (char *)packet + data_ofs + 8, MBUF_WAITOK);\n\t\tif (rv) {\n\t\t\tLOG(V_ERROR, \"mbuf_copyback failed, rv %08x\", rv);\n\t\t\tfpNetStats->inputErrors++;\n\t\t\tfreePacket(m);\n\t\t\treturn;\n\t\t}\n\n\t\tsubmit = fNetworkInterface->inputPacket(m, data_len);\n\t\tLOG(V_PACKET, \"submitted pkt sz %d\", data_len);\n\t\tfpNetStats->inputPackets++;\n\t\t\n\t\tsize -= msg_len;\n\t\tpacket = (char *)packet + msg_len;\n\t}\n}\n\n\n/***** RNDIS command logic *****/\n\nIOReturn HoRNDIS::rndisCommand(struct rndis_msg_hdr *buf, int buflen) {\n\tint rc = kIOReturnSuccess;\n\tif (!fCommInterface) {  // Safety: make sure 'fCommInterface' is valid.\n\t\tLOG(V_ERROR, \"fCommInterface is NULL, bailing out\");\n\t\treturn kIOReturnError;\n\t}\n\tconst uint8_t ifNum = fCommInterface->getInterfaceDescriptor()->bInterfaceNumber;\n\n\tif (buf->msg_type != RNDIS_MSG_HALT && buf->msg_type != RNDIS_MSG_RESET) {\n\t\t// No need to lock here: multi-threading does not even come close\n\t\t// (IOWorkLoop + IOGate are at our service):\n\t\tbuf->request_id = cpu_to_le32(rndisXid++);\n\t\tif (!buf->request_id) {\n\t\t\tbuf->request_id = cpu_to_le32(rndisXid++);\n\t\t}\n\t\t\n\t\tLOG(V_DEBUG, \"Generated xid: %d\", le32_to_cpu(buf->request_id));\n\t}\n\tconst uint32_t old_msg_type = buf->msg_type;\n\tconst uint32_t old_request_id = buf->request_id;\n\t\n\t{\n\t\tDeviceRequest rq;\n\t\trq.bmRequestType = kDeviceRequestDirectionOut |\n\t\t\tkDeviceRequestTypeClass | kDeviceRequestRecipientInterface;\n\t\trq.bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\t\trq.wValue = 0;\n\t\trq.wIndex = ifNum;\n\t\trq.wLength = le32_to_cpu(buf->msg_len);\n\t\n\t\tuint32_t bytes_transferred;\n\t\tif ((rc = fCommInterface->deviceRequest(rq, buf, bytes_transferred)) != kIOReturnSuccess) {\n\t\t\tLOG(V_DEBUG, \"Device request send error\");\n\t\t\treturn rc;\n\t\t}\n\t\tif (bytes_transferred != rq.wLength) {\n\t\t\tLOG(V_DEBUG, \"Incomplete device transfer\");\n\t\t\treturn kIOReturnError;\n\t\t}\n\t}\n\n\t// The RNDIS control messages are done via 'deviceRequest' - issue control\n\t// transfers on the device's default endpoint. Per [MSDN-RNDISUSB], if\n\t// a device is not ready (for some reason) to reply with the actual data,\n\t// it shall send a one-byte reply indicating an error, rather than stall\n\t// the control pipe. The retry loop below is a hackish way of waiting\n\t// for the reply.\n\t//\n\t// Per [MSDN-RNDISUSB], once the driver sends a OUT device transfer, it\n\t// should wait for a notification on the interrupt endpoint from\n\t// fCommInterface, and only then perform a device request to retrieve\n\t// the result. Whether Android does that correctly is something I need to\n\t// investigate.\n\t//\n\t// Also, RNDIS specifies that the device may be sending\n\t// REMOTE_NDIS_INDICATE_STATUS_MSG on its own. How much this applies to\n\t// Android or embedded Linux devices needs to be investigated.\n\t//\n\t// Reference:\n\t// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/control-channel-characteristics\n\n\t// Now we wait around a while for the device to get back to us.\n\tint count;\n\tfor (count = 0; count < 10; count++) {\n\t\tDeviceRequest rq;\n\t\trq.bmRequestType = kDeviceRequestDirectionIn |\n\t\t\tkDeviceRequestTypeClass | kDeviceRequestRecipientInterface;\n\t\trq.bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\n\t\trq.wValue = 0;\n\t\trq.wIndex = ifNum;\n\t\trq.wLength = RNDIS_CMD_BUF_SZ;\n\n\t\t// Make sure 'fCommInterface' was not taken away from us while\n\t\t// we were doing synchronous IO:\n\t\tif (!fCommInterface) {\n\t\t\tLOG(V_ERROR, \"fCommInterface was closed, bailing out\");\n\t\t\treturn kIOReturnError;\n\t\t}\n\t\tuint32_t bytes_transferred;\n\t\tif ((rc = fCommInterface->deviceRequest(rq, buf, bytes_transferred)) != kIOReturnSuccess) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (bytes_transferred < 12) {\n\t\t\tLOG(V_ERROR, \"short read on control request?\");\n\t\t\tIOSleep(20);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (buf->msg_type == (old_msg_type | RNDIS_MSG_COMPLETION)) {\n\t\t\tif (buf->request_id == old_request_id) {\n\t\t\t\tif (buf->msg_type == RNDIS_MSG_RESET_C) {\n\t\t\t\t\t// This is probably incorrect: the RESET_C does not have\n\t\t\t\t\t// 'request_id', but we don't issue resets => don't care.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (buf->status != RNDIS_STATUS_SUCCESS) {\n\t\t\t\t\tLOG(V_ERROR, \"RNDIS command returned status %08x\",\n\t\t\t\t\t\tle32_to_cpu(buf->status));\n\t\t\t\t\trc = kIOReturnError;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (le32_to_cpu(buf->msg_len) != bytes_transferred) {\n\t\t\t\t\tLOG(V_ERROR, \"Message Length mismatch: expected: %d, actual: %d\",\n\t\t\t\t\t\tle32_to_cpu(buf->msg_len), bytes_transferred);\n\t\t\t\t\trc = kIOReturnError;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tLOG(V_DEBUG, \"RNDIS command completed\");\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tLOG(V_ERROR, \"RNDIS return had incorrect xid?\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (buf->msg_type == RNDIS_MSG_INDICATE) {\n\t\t\t\tLOG(V_ERROR, \"unsupported: RNDIS_MSG_INDICATE\");\t\n\t\t\t} else if (buf->msg_type == RNDIS_MSG_INDICATE) {\n\t\t\t\tLOG(V_ERROR, \"unsupported: RNDIS_MSG_KEEPALIVE\");\n\t\t\t} else {\n\t\t\t\tLOG(V_ERROR, \"unexpected msg type %08x, msg_len %08x\",\n\t\t\t\t\tle32_to_cpu(buf->msg_type), le32_to_cpu(buf->msg_len));\n\t\t\t}\n\t\t}\n\t\t\n\t\tIOSleep(20);\n\t}\n\tif (count == 10) {\n\t\tLOG(V_ERROR, \"command timed out?\");\n\t\treturn kIOReturnTimeout;\n\t}\n\n\treturn rc;\n}\n\nint HoRNDIS::rndisQuery(void *buf, uint32_t oid, uint32_t in_len, void **reply, int *reply_len) {\n\tint rc;\n\t\n\tunion {\n\t\tvoid *buf;\n\t\tstruct rndis_msg_hdr *hdr;\n\t\tstruct rndis_query *get;\n\t\tstruct rndis_query_c *get_c;\n\t} u;\n\tuint32_t off, len;\n\t\n\tu.buf = buf;\n\t\n\tmemset(u.get, 0, sizeof(*u.get) + in_len);\n\tu.get->msg_type = RNDIS_MSG_QUERY;\n\tu.get->msg_len = cpu_to_le32(sizeof(*u.get) + in_len);\n\tu.get->oid = oid;\n\tu.get->len = cpu_to_le32(in_len);\n\tu.get->offset = cpu_to_le32(20);\n\t\n\trc = rndisCommand(u.hdr, RNDIS_CMD_BUF_SZ);\n\tif (rc != kIOReturnSuccess) {\n\t\tLOG(V_ERROR, \"RNDIS_MSG_QUERY failure? %08x\", rc);\n\t\treturn rc;\n\t}\n\t\n\toff = le32_to_cpu(u.get_c->offset);\n\tlen = le32_to_cpu(u.get_c->len);\n\tLOG(V_DEBUG, \"RNDIS query completed\");\n\t\n\tif ((8 + off + len) > RNDIS_CMD_BUF_SZ) {\n\t\tgoto fmterr;\n\t}\n\tif (*reply_len != -1 && len != *reply_len) {\n\t\tgoto fmterr;\n\t}\n\t\n\t*reply = ((unsigned char *) &u.get_c->request_id) + off;\n\t*reply_len = len;\n\t\n\treturn 0;\n\nfmterr:\n\tLOG(V_ERROR, \"protocol error?\");\n\treturn -1;\n}\n\nbool HoRNDIS::rndisInit() {\n\tint rc;\n\tunion {\n\t\tstruct rndis_msg_hdr *hdr;\n\t\tstruct rndis_init *init;\n\t\tstruct rndis_init_c *init_c;\n\t} u;\n\t\n\tu.hdr = (rndis_msg_hdr *)IOMallocAligned(RNDIS_CMD_BUF_SZ, sizeof(void *));\n\tif (!u.hdr) {\n\t\tLOG(V_ERROR, \"out of memory?\");\n\t\treturn false;\n\t}\n\t\n\tu.init->msg_type = RNDIS_MSG_INIT;\n\tu.init->msg_len = cpu_to_le32(sizeof *u.init);\n\tu.init->major_version = cpu_to_le32(1);\n\tu.init->minor_version = cpu_to_le32(0);\n\t// This is the maximum USB transfer the device is allowed to make to host:\n\tu.init->max_transfer_size = IN_BUF_SIZE;\n\trc = rndisCommand(u.hdr, RNDIS_CMD_BUF_SZ);\n\tif (rc != kIOReturnSuccess) {\n\t\tLOG(V_ERROR, \"INIT not successful?\");\n\t\tIOFreeAligned(u.hdr, RNDIS_CMD_BUF_SZ);\n\t\treturn false;\n\t}\n\n\tif (fCommInterface) {  // Safety: don't accesss 'fCommInterface if NULL.\n\t\tLOG(V_NOTE, \"'%s': ver=%d.%d, max_packets_per_transfer=%d, \"\n\t\t\t\"max_transfer_size=%d, packet_alignment=2^%d\",\n\t\t\tfCommInterface->getDevice()->getName(),\n\t\t\tle32_to_cpu(u.init_c->major_version),\n\t\t\tle32_to_cpu(u.init_c->minor_version),\n\t\t\tle32_to_cpu(u.init_c->max_packets_per_transfer),\n\t\t\tle32_to_cpu(u.init_c->max_transfer_size),\n\t\t\tle32_to_cpu(u.init_c->packet_alignment));\n\t}\n\n\tmaxOutTransferSize = le32_to_cpu(u.init_c->max_transfer_size);\n\t// For now, let's limit the maxOutTransferSize by the Output Buffer size.\n\t// If we implement transmitting multiple PDUs in a single USB transfer,\n\t// we may want to size the output buffers based on\n\t// \"u.init_c->max_transfer_size\".\n\tmaxOutTransferSize = min(maxOutTransferSize, OUT_BUF_SIZE);\n\t\n\tIOFreeAligned(u.hdr, RNDIS_CMD_BUF_SZ);\n\t\n\treturn true;\n}\n\nbool HoRNDIS::rndisSetPacketFilter(uint32_t filter) {\n\tunion {\n\t\tstruct rndis_msg_hdr *hdr;\n\t\tstruct rndis_set *set;\n\t\tstruct rndis_set_c *set_c;\n\t} u;\n\tint rc;\n\t\n\tu.hdr = (rndis_msg_hdr *)IOMallocAligned(RNDIS_CMD_BUF_SZ, sizeof(void *));\n\tif (!u.hdr) {\n\t\tLOG(V_ERROR, \"out of memory?\");\n\t\treturn false;;\n\t}\n\t\n\tmemset(u.set, 0, sizeof *u.set);\n\tu.set->msg_type = RNDIS_MSG_SET;\n\tu.set->msg_len = cpu_to_le32(4 + sizeof *u.set);\n\tu.set->oid = OID_GEN_CURRENT_PACKET_FILTER;\n\tu.set->len = cpu_to_le32(4);\n\tu.set->offset = cpu_to_le32((sizeof *u.set) - 8);\n\t*(uint32_t *)(u.set + 1) = filter;\n\t\n\trc = rndisCommand(u.hdr, RNDIS_CMD_BUF_SZ);\n\tif (rc != kIOReturnSuccess) {\n\t\tLOG(V_ERROR, \"SET not successful?\");\n\t\tIOFreeAligned(u.hdr, RNDIS_CMD_BUF_SZ);\n\t\treturn false;\n\t}\n\t\n\tIOFreeAligned(u.hdr, RNDIS_CMD_BUF_SZ);\n\t\n\treturn true;\n}\n"
        },
        {
          "name": "HoRNDIS.h",
          "type": "blob",
          "size": 13.8271484375,
          "content": "/* HoRNDIS.h\n * Declaration of IOKit-derived classes\n * HoRNDIS, a RNDIS driver for Mac OS X\n *\n *   Copyright (c) 2012 Joshua Wise.\n *   Copyright (c) 2018 Mikhail Iakhiaev\n *\n * IOKit examples from Apple's USBCDCEthernet.cpp; not much of that code remains.\n *\n * RNDIS logic is from linux/drivers/net/usb/rndis_host.c, which is:\n *\n *   Copyright (c) 2005 David Brownell.\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <machine/limits.h>\t\t\t/* UINT_MAX */\n#include <libkern/OSByteOrder.h>\n#include <libkern/OSTypes.h>\n\n#include <IOKit/network/IOEthernetController.h>\n#include <IOKit/network/IOEthernetInterface.h>\n\n#include <IOKit/IOTimerEventSource.h>\n#include <IOKit/assert.h>\n#include <IOKit/IOLib.h>\n#include <IOKit/IOService.h>\n#include <IOKit/IOBufferMemoryDescriptor.h>\n#include <IOKit/IOMessage.h>\n\n#include <IOKit/usb/IOUSBHostFamily.h>\n#include <IOKit/usb/IOUSBHostPipe.h>\n\nextern \"C\"\n{\n\t#include <sys/param.h>\n\t#include <sys/mbuf.h>\n}\n\n#define cpu_to_le32(x) OSSwapHostToLittleInt32(x)\n#define le32_to_cpu(x) OSSwapLittleToHostInt32(x)\n// Helps to avoid including private classes and methods into the symbol table.\n#define NOEXPORT\t__attribute__((visibility(\"hidden\")))\n\n// REFERENCES:\n// [MS-RNDIS]: Remote Network Driver Interface Specification (RNDIS) Protocol\n//   https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/WinArchive/[MS-RNDIS].pdf\n// [MSDN-RNDISUSB]: Remote NDIS To USB Mapping\n//   https://docs.microsoft.com/en-us/windows-hardware/drivers/network/remote-ndis-to-usb-mapping\n\n#define TRANSMIT_QUEUE_SIZE     256\n#define OUT_BUF_SIZE            4096\n\n// Per [MS-RNDIS], description of REMOTE_NDIS_INITIALIZE_MSG:\n//    \"MaxTransferSize (4 bytes): ... It SHOULD be set to 0x00004000\"\n// I.e. specs recommends we should be able to input 16K in a single transfer.\n// Also, some Android versions (e.g. 8.1.0 on Pixel 2) seem to ignore\n// \"max_transfer_size\" in \"REMOTE_NDIS_INITIALIZE_MSG\" and use packets up to\n// 16K regardless.\n#define IN_BUF_SIZE             16384\n\n#define N_OUT_BUFS              4\n// The N_IN_BUFS value should either be 1 or 2.\n// 2 - double-buffering enabled, 1 - double-buffering disabled: single reader.\n// NOTE: surprisingly, single-buffer overall performs better, probably due to\n// less contention on the USB2 bus, which is half-duplex.\n#define N_IN_BUFS               1\n\n// Maximum payload size in a standard (non-jumbo) Ethernet frame.\n#define ETHERNET_MTU            1500\n\n/***** RNDIS definitions -- from linux/include/linux/usb/rndis_host.h ****/\n\n// Per [MSDN-RNDISUSB], \"Control Channel Characteristics\", it's the minumim\n// buffer size the host should support (and it's way bigger than we need).\n#define RNDIS_CMD_BUF_SZ\t\t0x400\n\nstruct rndis_msg_hdr {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t status;\n} __attribute__((packed));\n\nstruct rndis_data_hdr {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t data_offset;\n\tuint32_t data_len;\n\t\n\tuint32_t oob_data_offset;\n\tuint32_t oob_data_len;\n\tuint32_t num_oob;\n\tuint32_t packet_data_offset;\n\t\n\tuint32_t packet_data_len;\n\tuint32_t vc_handle;\n\tuint32_t reserved;\n} __attribute__((packed));\n\nstruct rndis_query {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t oid;\n\tuint32_t len;\n\tuint32_t offset;\n\tuint32_t handle;\n} __attribute__((packed));\n\nstruct rndis_query_c {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t status;\n\tuint32_t len;\n\tuint32_t offset;\n} __attribute__((packed));\n\nstruct rndis_init {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t major_version;\n\tuint32_t minor_version;\n\tuint32_t max_transfer_size;\n} __attribute__((packed));\n\nstruct rndis_init_c {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t status;\n\tuint32_t major_version;\n\tuint32_t minor_version;\n\tuint32_t device_flags;\n\tuint32_t medium;\n\tuint32_t max_packets_per_transfer;\n\tuint32_t max_transfer_size;\n\tuint32_t packet_alignment;\n\tuint32_t af_list_offset;\n\tuint32_t af_list_size;\n} __attribute__((packed));\n\nstruct rndis_set {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t oid;\n\tuint32_t len;\n\tuint32_t offset;\n\tuint32_t handle;\n} __attribute__((packed));\n\nstruct rndis_set_c {\n\tuint32_t msg_type;\n\tuint32_t msg_len;\n\tuint32_t request_id;\n\tuint32_t status;\n} __attribute__((packed));\n\n#define RNDIS_MSG_COMPLETION                    cpu_to_le32(0x80000000)\n#define RNDIS_MSG_PACKET                        cpu_to_le32(0x00000001) /* 1-N packets */\n#define RNDIS_MSG_INIT                          cpu_to_le32(0x00000002)\n#define RNDIS_MSG_INIT_C                        (RNDIS_MSG_INIT|RNDIS_MSG_COMPLETION)\n#define RNDIS_MSG_HALT                          cpu_to_le32(0x00000003)\n#define RNDIS_MSG_QUERY                         cpu_to_le32(0x00000004)\n#define RNDIS_MSG_QUERY_C                       (RNDIS_MSG_QUERY|RNDIS_MSG_COMPLETION)\n#define RNDIS_MSG_SET                           cpu_to_le32(0x00000005)\n#define RNDIS_MSG_SET_C                         (RNDIS_MSG_SET|RNDIS_MSG_COMPLETION)\n#define RNDIS_MSG_RESET                         cpu_to_le32(0x00000006)\n#define RNDIS_MSG_RESET_C                       (RNDIS_MSG_RESET|RNDIS_MSG_COMPLETION)\n#define RNDIS_MSG_INDICATE                      cpu_to_le32(0x00000007)\n#define RNDIS_MSG_KEEPALIVE                     cpu_to_le32(0x00000008)\n#define RNDIS_MSG_KEEPALIVE_C                   (RNDIS_MSG_KEEPALIVE|RNDIS_MSG_COMPLETION)\n\n#define RNDIS_STATUS_SUCCESS                    cpu_to_le32(0x00000000)\n#define RNDIS_STATUS_FAILURE                    cpu_to_le32(0xc0000001)\n#define RNDIS_STATUS_INVALID_DATA               cpu_to_le32(0xc0010015)\n#define RNDIS_STATUS_NOT_SUPPORTED              cpu_to_le32(0xc00000bb)\n#define RNDIS_STATUS_MEDIA_CONNECT              cpu_to_le32(0x4001000b)\n#define RNDIS_STATUS_MEDIA_DISCONNECT           cpu_to_le32(0x4001000c)\n#define RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION  cpu_to_le32(0x40010012)\n\n#define RNDIS_PHYSICAL_MEDIUM_UNSPECIFIED       cpu_to_le32(0x00000000)\n#define RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN      cpu_to_le32(0x00000001)\n#define RNDIS_PHYSICAL_MEDIUM_CABLE_MODEM       cpu_to_le32(0x00000002)\n#define RNDIS_PHYSICAL_MEDIUM_PHONE_LINE        cpu_to_le32(0x00000003)\n#define RNDIS_PHYSICAL_MEDIUM_POWER_LINE        cpu_to_le32(0x00000004)\n#define RNDIS_PHYSICAL_MEDIUM_DSL               cpu_to_le32(0x00000005)\n#define RNDIS_PHYSICAL_MEDIUM_FIBRE_CHANNEL     cpu_to_le32(0x00000006)\n#define RNDIS_PHYSICAL_MEDIUM_1394              cpu_to_le32(0x00000007)\n#define RNDIS_PHYSICAL_MEDIUM_WIRELESS_WAN      cpu_to_le32(0x00000008)\n#define RNDIS_PHYSICAL_MEDIUM_MAX               cpu_to_le32(0x00000009)\n\n#define OID_802_3_PERMANENT_ADDRESS             cpu_to_le32(0x01010101)\n#define OID_GEN_MAXIMUM_FRAME_SIZE              cpu_to_le32(0x00010106)\n#define OID_GEN_CURRENT_PACKET_FILTER           cpu_to_le32(0x0001010e)\n#define OID_GEN_PHYSICAL_MEDIUM                 cpu_to_le32(0x00010202)\n\n/* packet filter bits used by OID_GEN_CURRENT_PACKET_FILTER */\n#define RNDIS_PACKET_TYPE_DIRECTED              cpu_to_le32(0x00000001)\n#define RNDIS_PACKET_TYPE_MULTICAST             cpu_to_le32(0x00000002)\n#define RNDIS_PACKET_TYPE_ALL_MULTICAST         cpu_to_le32(0x00000004)\n#define RNDIS_PACKET_TYPE_BROADCAST             cpu_to_le32(0x00000008)\n#define RNDIS_PACKET_TYPE_SOURCE_ROUTING        cpu_to_le32(0x00000010)\n#define RNDIS_PACKET_TYPE_PROMISCUOUS           cpu_to_le32(0x00000020)\n#define RNDIS_PACKET_TYPE_SMT                   cpu_to_le32(0x00000040)\n#define RNDIS_PACKET_TYPE_ALL_LOCAL             cpu_to_le32(0x00000080)\n#define RNDIS_PACKET_TYPE_GROUP                 cpu_to_le32(0x00001000)\n#define RNDIS_PACKET_TYPE_ALL_FUNCTIONAL        cpu_to_le32(0x00002000)\n#define RNDIS_PACKET_TYPE_FUNCTIONAL            cpu_to_le32(0x00004000)\n#define RNDIS_PACKET_TYPE_MAC_FRAME             cpu_to_le32(0x00008000)\n\n/* default filter used with RNDIS devices */\n#define RNDIS_DEFAULT_FILTER ( \\\n        RNDIS_PACKET_TYPE_DIRECTED | \\\n        RNDIS_PACKET_TYPE_BROADCAST | \\\n        RNDIS_PACKET_TYPE_ALL_MULTICAST | \\\n        RNDIS_PACKET_TYPE_PROMISCUOUS)\n\n#define USB_CDC_SEND_ENCAPSULATED_COMMAND       0x00\n#define USB_CDC_GET_ENCAPSULATED_RESPONSE       0x01\n\n/***** Actual class definitions *****/\n\ntypedef struct {\n\tIOBufferMemoryDescriptor *mdp;\n\tIOUSBHostCompletion comp;\n} pipebuf_t;\n\nclass HoRNDIS : public IOEthernetController {\n\tOSDeclareDefaultStructors(HoRNDIS);\t// Constructor & Destructor stuff\n\nprivate:\n\t/*!\n\t * This class protects method calls against re-entry, when the IOCommand\n\t * gate is being released due to synchronous IO, or some other reason.\n\t * Use case:\n\t * Unlike start/stop calls, that are triggered by a single IO provider,\n\t * the enable/disable calls can be triggered by multiple interface clients,\n\t * as well as user's actions, e.g. \"ifconfig en6 up\" - potentially multiple\n\t * \"ifconfig\" processes running in parallel.\n\t * Even though the calls to this class are protected by the IOCommandGate,\n\t * synchronous USB transfers release the gate (by using \n\t * IOCommandGate::commandSleep), allowing another enable/disable call\n\t * to \"sneak in\". We use the \"ReentryLocker\" to delay additional\n\t * enable/disable calls until the first one completes.\n\t */\n\tclass NOEXPORT ReentryLocker {\n\tpublic:\n\t\t// 'inGuard' is instance-level variable that would be set by\n\t\t// \"ReentryLocker\" whenever someone is executing the protected section.\n\t\tReentryLocker(IOCommandGate *inGate, bool &inGuard);\n\t\tReentryLocker(IONetworkController *controller, bool &inGuard):\n\t\t\tReentryLocker(controller->getCommandGate(), inGuard) {}\n\t\t~ReentryLocker();\n\t\tIOReturn getResult() const { return result; }\n\t\tbool isInterrupted() const { return result != kIOReturnSuccess; }\n\tprivate:\n\t\tIOCommandGate *const gate;\n\t\tbool &entryGuard;\n\t\tIOReturn result;\n\t};\n\t\t\n\tIOEthernetInterface *fNetworkInterface;\n\tIONetworkStats *fpNetStats;\n\n\tbool fReadyToTransfer;  // Ready to transmit: Android <-> MAC.\n\t// Set to true when 'enable' succeeds, and\n\t// set to false when 'disable' succeeds:\n\tbool fNetifEnabled;\n\tbool fEnableDisableInProgress;  // Guards against re-entry\n\tbool fDataDead;\n\n\t// These pass information from 'probe' to 'openUSBInterfaces':\n\tuint8_t fProbeConfigVal;\n\tuint8_t fProbeCommIfNum;  // The data interface number is +1.\n\n\t// fCallbackCount is the number of callbacks concurrently running\n\t// (possibly offset by a certain value).\n\t//  - Every successful async API call shall \"fCallbackCount++\".\n\t//  - Every time we exit the completion without making another call:\n\t//    'callbackExit()'.\n\tint fCallbackCount;\n\t\n\t// USB Communication:\n\tIOUSBHostInterface *fCommInterface;\n\tIOUSBHostInterface *fDataInterface;\n\t\n\tIOUSBHostPipe *fInPipe;\n\tIOUSBHostPipe *fOutPipe;\n\t\n\tuint32_t rndisXid;  // RNDIS request_id count.\n\tint32_t maxOutTransferSize;  // Set by 'rdisInit' from device reply.\n\n\tpipebuf_t outbufs[N_OUT_BUFS];\n\t// Allow double-buffering to enable the best hardware utilization:\n\tpipebuf_t inbufs[N_IN_BUFS];\n\tuint16_t outbufStack[N_OUT_BUFS];\n\tint numFreeOutBufs;\n\n\tvoid callbackExit();\n\tstatic void dataWriteComplete(void *obj, void *param, IOReturn ior, UInt32 transferred);\n\tstatic void dataReadComplete(void *obj, void *param, IOReturn ior, UInt32 transferred);\n\n\tbool rndisInit();\n\tIOReturn rndisCommand(struct rndis_msg_hdr *buf, int buflen);\n\tint rndisQuery(void *buf, uint32_t oid, uint32_t in_len, void **reply, int *reply_len);\n\tbool rndisSetPacketFilter(uint32_t filter);\n\n\tIOService *probeDevice(IOUSBHostDevice *device, SInt32 *score);\n\n\tbool openUSBInterfaces(IOService *provider);\n\tvoid closeUSBInterfaces();\n\tvoid disableNetworkQueue();\n\tvoid disableImpl();\n\n\tbool createMediumTables(const IONetworkMedium **primary);\n\tbool allocateResources(void);\n\tvoid releaseResources(void);\n\tbool createNetworkInterface(void);\n\n\tvoid receivePacket(void *packet, UInt32 size);\n\npublic:\n\t// IOKit overrides\n\tvirtual bool init(OSDictionary *properties = 0) override;\n\tvirtual void free() override;\n\tvirtual IOService *probe(IOService *provider, SInt32 *score) override;\n\tvirtual bool start(IOService *provider) override;\n\tvirtual bool willTerminate(IOService *provider, IOOptionBits options) override;\n\tvirtual void stop(IOService *provider) override;\n\n\t// IOEthernetController overrides\n\tvirtual IOOutputQueue *createOutputQueue(void) override;\n\tvirtual IOReturn getHardwareAddress(IOEthernetAddress *addr) override;\n\tvirtual IOReturn getMaxPacketSize(UInt32 *maxSize) const override;\n\tvirtual IOReturn getPacketFilters(const OSSymbol *group,\n\t\t\t\t\t\t\t\t\t  UInt32 *filters ) const  override;\n\tvirtual IONetworkInterface *createInterface() override;\n\tvirtual bool configureInterface(IONetworkInterface *netif) override;\n\t\n\tvirtual IOReturn enable(IONetworkInterface *netif) override;\n\tvirtual IOReturn disable(IONetworkInterface *netif) override;\n\tvirtual IOReturn selectMedium(const IONetworkMedium *medium) override;\n\tvirtual IOReturn setMulticastMode(bool active) override;\n\tvirtual IOReturn setMulticastList(IOEthernetAddress *addrs,\n\t                                  UInt32             count) override;\n\tvirtual IOReturn setPromiscuousMode(bool active) override;\n\tvirtual UInt32 outputPacket(mbuf_t pkt, void *param) override;\n};\n\nclass HoRNDISInterface : public IOEthernetInterface {\n\tOSDeclareDefaultStructors(HoRNDISInterface);\n\tint maxmtu;\npublic:\n\tvirtual bool init(IONetworkController *controller, int mtu);\n\tvirtual bool setMaxTransferUnit(UInt32 mtu) override;\n};\n"
        },
        {
          "name": "HoRNDIS.xcodeproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "KNOWN_BUGS",
          "type": "blob",
          "size": 1.6064453125,
          "content": "The following bugs have been sighted, but not root-caused:\n\nCertain sequences of loading and unloading the driver (and connecting and\ndisconnecting the phone) can cause the driver to leak a refcount to itself. \nFor instance, the sequence --\n  plug in phone\n  set phone to tethering\n  load driver\n  do some operations...\n  unload driver\n  load driver\n    (checkbox on phone will have unticked itself; phone will be confused)\n  driver wedges during ::enable, since rndis driver on phone has died\n  unplug phone\n  attempt to unload driver\nresults in the message --\n  (kernel) Can't unload kext com.joshuawise.kexts.HoRNDIS; classes have instances:\n  (kernel) Kext com.joshuawise.kexts.HoRNDIS class HoRNDIS has 1 instance.\nand the interesting commentary from the kernel --\n  bruges kernel[0]: HoRNDIS: outputPacket: waiting for buffer...\n  --- last message repeated 9 times ---\n  bruges kernel[0]: HoRNDIS: outputPacket: timed out waiting for buffer\n  bruges kernel[0]: HoRNDIS: dataWriteComplete: I/O error: e00002ed\n  bruges kernel[0]: HoRNDIS: clearPipeStall: pipe not stalled?\n  bruges kernel[0]: HoRNDIS: dataReadComplete: I/O aborted: device unplugged?\n  bruges.joshuawise.com configd[17]: DHCP en3: INIT transmit failed\n  bruges.joshuawise.com configd[17]: arp_client_open_fd: bpf_setif(en3) failed: Device not configured (6)\n  bruges kernel[0]: HoRNDIS: message: kIOMessageServiceWasClosed\n  bruges kernel[0]: HoRNDIS: rndisSetPacketFilter: SET not successful?\n  bruges kernel[0]: HoRNDIS: message: kIOMessageServiceIsTerminated\n  bruges kernel[0]: HoRNDIS: dataWriteComplete: I/O error: e00002eb\n  --- last message repeated 14 times ---\n\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.353515625,
          "content": "# For the building the driver for MacOS 10.11+, the preferred\n# XCode version is 7.3.1.\n#\n# You can do this by downloading Xcode 7.3.1 as a dmg from Apple, then\n# copying the contents into /Applications as Xcode-7.3.1.\n# If you also want to build from \"release_pre_10_11\", you may want to\n# also download \"Xcode-4.3.3\", and copy \"MacOSX10.6.sdk\" from it to\n# SDK directory under:\n# /Applications/Xcode-7.3.1.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/\n\n-include localconfig.mk\n\n# Can be set from the environment:\nHORNDIS_XCODE ?= /Applications/Xcode*$(XCODE_VER).app\n\nXCODE_VER ?= 7.3.1\nXCODEBUILD ?= $(wildcard $(HORNDIS_XCODE)/Contents/Developer/usr/bin/xcodebuild)\n\nifeq (,$(XCODEBUILD))\n    $(error Cannot find xcodebuild under $(HORNDIS_XCODE). Please either \\\n    \tdownload Xcode $(XCODE_VER) from: \"https://developer.apple.com/download\" \\\n    \tand install as /Applications/Xcode-$(XCODE_VER)/ or point HORNDIS_XCODE \\\n    \tto your preferred Xcode app path)\nendif\n\n# The package signing certificate must either be set or explicitly disabled:\nifeq (,$(CODESIGN_INST))\n    $(error Please set CODESIGN_INST variable to your Mac Installer \\\n      certificate or 'none' if you don't have any. \\\n      E.g. \"export CODESIGN_INST=G3H8VBSL7A\")\nelse ifeq (none,$(CODESIGN_INST))\n    # Clear the 'none' vaulue: easier to test in 'if' condition.\n    CODESIGN_INST :=\nendif\n\nall: build/Release/HoRNDIS.kext build/pkg/_complete\n\nclean:\n\trm -rf build\n\n# We now sign as part of the xcodebuild process.\nbuild/Release/HoRNDIS.kext: $(wildcard *.cpp *.h *.plist HoRNDIS.xcodeproj/* *.lproj/*)\n\t$(XCODEBUILD) -project HoRNDIS.xcodeproj\n\nbuild/pkg/root: build/Release/HoRNDIS.kext\n\trm -rf build/pkg/\n\tmkdir -p build/pkg/root/Library/Extensions\n\tcp -R build/Release/HoRNDIS.kext build/pkg/root/Library/Extensions/\n\nbuild/pkg/HoRNDIS-kext.pkg: build/pkg/root\n\tpkgbuild --identifier com.joshuawise.kexts.HoRNDIS --scripts package/scripts --root $< $@\n\n# The variable is to be resolved first time it's used:\nVERSION = $(shell defaults read $(PWD)/build/Release/HoRNDIS.kext/Contents/Info.plist CFBundleVersion)\n\nbuild/pkg/_complete: build/pkg/HoRNDIS-kext.pkg $(wildcard package/*)\n\tproductbuild --distribution package/Distribution.xml --package-path build/pkg --resources package --version $(VERSION) $(if $(CODESIGN_INST),--sign $(CODESIGN_INST)) build/HoRNDIS-$(VERSION).pkg && touch build/pkg/_complete\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6884765625,
          "content": "# HoRNDIS(the USB tethering driver for Mac OS X)\n\n**HoRNDIS** (pronounce: *\"horrendous\"*) is a driver for Mac OS X that allows you to use your Android phone's native [USB tethering](http://en.wikipedia.org/wiki/Tethering) mode to get Internet access.\n\nFor more information, [visit the home page for HoRNDIS on my site](http://www.joshuawise.com/horndis).\n\n## Installation\n\n### From Source/Binary\n\n* Get the installation package ([Download](http://www.joshuawise.com/horndis) or [Build](#building-the-source) the installation package from source yourself)\n* Run the installation package\n\n### From Homebrew\n\n```sh\nbrew cask install horndis\nsudo kextload /Library/Extensions/HoRNDIS.kext\n```\n\n## Configuration\n\n* Assuming that the installation proceeds without errors, after it completes, connect your phone to your Mac by USB.\n* Enter the settings menu on your phone.\n* In the connections section, below Wi-Fi and Bluetooth:\n  * Select \"More...\"\n  * Select \"Tethering & portable hotspot\"\n* Check the \"USB tethering\" box. It should flash once, and then become solidly checked.\n\n## Uninstallation\n\n* Delete the `HoRNDIS.kext` under `/System/Library/Extensions` and `/Library/Extensions` folder\n* Restart your computer\n\n## Building the source\n\n* `git clone` the repository\n* Simply running xcodebuild in the checkout directory should be sufficient to build the kext.\n* If you wish to package it up, you can run `make` to assemble the package in the build/ directory\n\n## Debugging and Development Notes\n\nThis sections contains tips and tricks for developing and debugging the driver.\n\n### USB Device Information\n\n*Mac OS System Menu* -> *About This Mac* -> *System Report* --> *Hardware*/*USB* <br>\nLists all USB devices that OS recognizes. Unfortunately, it does not give USB descriptors.\n\n`lsusb -v`<br>\nIt prints USB configuration, such as interface and endpoint descriptors. You can print it for all devices or limit the output to specific ones. In order to run this command, you need to install *usbutils*.\n* Homebrew users: `brew install mikhailai/misc/usbutils`<br>\n  Please *do not* install *lsusb* package from Homebrew Core, it's a different utility with the same name.\n* Macports users: `sudo port install usbutils`\n\n### IO Registry\n\n`ioreg -l -r -c IOUSBHostDevice`<br>\nThis command lists all the Mac OS IO Registry information under all USB devices. Unlike *lsusb*, ioreg tells how Mac OS recognized USB devices and interfaces, and how it matched drivers to these interfaces. The `-r -c IOUSBHostDevice` limits the output to USB devices; to get complete OS registry, please run `ioreg -l`.\n\n### OS Logging\n\nThe `LOG(....)` statements, sprinkled throughout the HoRNDIS code, call the `IOLog` functions. On Mac OS *El Capitan* (10.11) and earlier, the log messages go into `/var/log/system.log`. Starting from *Sierra* (10.12), these messages are no longer written to `system.log` and instead can be viewed via:\n* *GUI*, using *Console* application, located in *Utilities* folder. You need to enter `process:kernel` in the search box in order to filter the relevant messages.\n* *Command Line*, using the `log` command. For example:<br>\n  `log show --predicate process==\\\"kernel\\\" --start \"2018-12-11 22:54:00\"`<br>\n  The start value needs to be several minutes in the past, so it would not flood the console. Here is a convenient command that prints the messages from the past 3 mintes:<br>\n  `log show --predicate process==\\\"kernel\\\" --start \"$(date -v-3M +'%F %T')\"`\n\nI've observed that Mac OS logging is unreliable (especially in *Sierra*). In some cases, the messages may come out garbled (looking like bad multi-threaded code). In other cases, either GUI or Command Line may be missing messages that were emitted. Sometimes, reloading the driver may fix the problem.\n"
        },
        {
          "name": "en.lproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "package",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_kext.command",
          "type": "blob",
          "size": 1.3779296875,
          "content": "#!/bin/bash\n\n# Variables\nSOURCE=\"${BASH_SOURCE[0]}\"\nwhile [ -h \"$SOURCE\" ]; do DIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\";SOURCE=\"$(readlink \"$SOURCE\")\";[[ $SOURCE != /* ]] && SOURCE=\"$DIR/$SOURCE\"; done\nCURDIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\"\n\nDESTDIR=\"/tmp/HoRNDIS\";\n\n\n# Get sudo\nif [ -z $(sudo echo \"gotsudo\") ]; then echo \"Could not get super-user permissions\"; exit -1; fi\n\n\n# Copy KEXT to tmp\necho \"Copying...\";\n\nif [ -d $DESTDIR ]; then sudo rm -r $DESTDIR; fi\nsudo mkdir $DESTDIR;\nsudo cp -r $CURDIR/HoRNDIS* $DESTDIR/; #Copies all files beginning with HoRNDIS…\nsudo chmod -R 0700 $DESTDIR;\nsudo chown -R root:wheel $DESTDIR;\n\n# Load KEXT\n\nKEXTFILES=();\nwhile read -r -d $'\\0'; do KEXTFILES+=(\"$REPLY\"); done < <(sudo find $DESTDIR -iname \"*.kext\" -maxdepth 1 -print0);\nif [ ${#KEXTFILES[@]} -gt 1 ]; then\n\t# Ask user which kext to take\n\tNUM_KEXTS=${#KEXTFILES[@]};\n\t\n\tfor (( i=0; i < $NUM_KEXTS; i++ )); do\n\t\techo \"$i: ${KEXTFILES[$i]}\";\n\tdone\n\n\tKEXTNUM=-1;\n\twhile [ $KEXTNUM -lt 0 ] || [ $KEXTNUM -ge $NUM_KEXTS ]; do read -p \"Which file?: \" KEXTNUM; done\n\t\n\t# Got file\n\tKEXTFILE=${KEXTFILES[$KEXTNUM]};\nelse\n\tKEXTFILE=${KEXTFILES[0]};\nfi\n\nif [ -n \"$KEXTFILE\" ]; then\n\t# Load KEXT if found\n\techo \"Loading \\\"$KEXTFILE\\\"...\";\n\tsudo kextload -t \"$KEXTFILE\";\n\t\n\techo \"Loaded:\";\n\techo $(kextstat | grep HoRNDIS);\n\t\n\texit 0;\nelse\n\t# No KEXT found\n\techo 'No KEXTFILE found.';\n\texit 1;\nfi\n"
        }
      ]
    }
  ]
}