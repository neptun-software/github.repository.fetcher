{
  "metadata": {
    "timestamp": 1736565662526,
    "page": 558,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sciter-sdk/go-sciter",
      "stars": 2586,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 1.9287109375,
          "content": "version: 0.4.0.{build}\n\nbranches:\n  only:\n    - master\n    - travis\n\nimage:\n  - Visual Studio 2015\n\nenvironment:\n  matrix:\n  - TARGET: Go 1.12.0\n    ARCH: 64\n    ARCHGO:\n    VERGO: 112\n    MGWVER: x86_64-7.2.0-posix-seh-rt_v5-rev1\n\n  - TARGET: Go 1.12.0\n    ARCH: 32\n    ARCHGO: -x86\n    VERGO: 112\n    MGWVER: i686-6.3.0-posix-dwarf-rt_v5-rev1\n\n  - TARGET: Go 1.13.0\n    ARCH: 64\n    ARCHGO:\n    VERGO: 113\n    MGWVER: x86_64-7.2.0-posix-seh-rt_v5-rev1\n\n  - TARGET: Go 1.13.0\n    ARCH: 32\n    ARCHGO: -x86\n    VERGO: 113\n    MGWVER: i686-6.3.0-posix-dwarf-rt_v5-rev1\n\n  - TARGET: Go 1.14.0\n    ARCH: 64\n    ARCHGO:\n    VERGO: 113\n    MGWVER: x86_64-7.2.0-posix-seh-rt_v5-rev1\n\n  - TARGET: Go 1.14.0\n    ARCH: 32\n    ARCHGO: -x86\n    VERGO: 113\n    MGWVER: i686-6.3.0-posix-dwarf-rt_v5-rev1\n\n  - TARGET: Go 1.15.0\n    ARCH: 64\n    ARCHGO:\n    VERGO: 113\n    MGWVER: x86_64-7.2.0-posix-seh-rt_v5-rev1\n\n  - TARGET: Go 1.15.0\n    ARCH: 32\n    ARCHGO: -x86\n    VERGO: 113\n    MGWVER: i686-6.3.0-posix-dwarf-rt_v5-rev1\n\ninstall:\n  - cmd: echo Testing sciter%ARCH% with %TARGET%.\n  - cmd: echo Current directory is %APPVEYOR_BUILD_FOLDER%\n  - cmd: set PATH=C:\\projects\\deps;C:\\go%VERGO%%ARCHGO%\\bin;C:\\mingw-w64\\%MGWVER%\\mingw%ARCH%\\bin;%PATH%\n\n  - gcc --version\n  - go version\n\n  - mkdir C:\\projects\\deps\n  - curl -so \"C:\\projects\\deps\\sciter.dll\" \"https://raw.githubusercontent.com/c-smile/sciter-sdk/master/bin.win/x%ARCH%/sciter.dll\"\n\nbefore_build:\n  - cmd: set GOROOT=C:\\go%VERGO%%ARCHGO%\n  - cmd: set GOPATH=C:\\projects\\gopath\n  - cmd: set PATH=%GOPATH%\\bin;%PATH%\n  - cmd: mkdir %GOPATH%\n  - go env\n  - go get -u github.com/lxn/win\n  - go get -u github.com/GeertJohan/go.rice\n  - go get -u github.com/GeertJohan/go.rice/rice\n  - go get -u github.com/kardianos/osext\n\n\nbuild_script:\n  - cmd: echo Building library\n  - cmd: cd\n  - go build -x\n\n  - go get github.com/sciter-sdk/go-sciter\n\n  - cmd: echo Building examples\n  - cmd: cd examples\n  - cmd: go build ./...\n\ntest: off\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.287109375,
          "content": "# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n\n# sciter sdk\nsciter-sdk*/\n\n# editor config\n.vscode/"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.7919921875,
          "content": "# Based on the \"trust\" template v0.1.2\n# https://github.com/japaric/trust/tree/v0.1.2\n\ndist: trusty\nsudo: false\nlanguage: go\n\nnotifications:\n  email: change\n\nos:\n  - linux\n  - osx\n\n# \"1.9\" go-sciter is incompatible with 1.9\n# The latest 1.9 version was 9646a0a383.\n\ngo:\n  - \"1.12\"\n  - \"1.13\"\n  - \"1.14\"\n  - \"1.15\"\n\n\nbranches:\n  only:\n    - master\n    - travis\n\naddons:\n  apt:\n    sources:\n    - ubuntu-toolchain-r-test\n\n    packages:\n    - libgtk-3-dev\n    - libgtk-3-0\n    - libstdc++-6-pic\n\ncache:\n  directories:\n    - $GOPATH/src\n    - $GOPATH/pkg\n\nbefore_cache:\n  - rm -rf $GOPATH/src/github.com/sciter-sdk/go-sciter/*\n  - rm -rf $GOPATH/pkg/**/github.com/sciter-sdk/go-sciter\n\ninstall:\n  - export SDK_PATH=https://raw.githubusercontent.com/c-smile/sciter-sdk/master\n  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then curl -so \"$TRAVIS_BUILD_DIR/libsciter-gtk.so\" $SDK_PATH/bin.lnx/x64/libsciter-gtk.so; fi\n  - if [ \"$TRAVIS_OS_NAME\" = \"osx\"   ]; then curl -so \"$TRAVIS_BUILD_DIR/libsciter.dylib\" $SDK_PATH/bin.osx/libsciter.dylib; fi\n\n# - go get golang.org/x/lint/golint\n\n  - go get -u github.com/GeertJohan/go.rice\n  - go get -u github.com/GeertJohan/go.rice/rice\n\nbefore_script:\n  - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then export DYLD_LIBRARY_PATH=\"$DYLD_LIBRARY_PATH:$TRAVIS_BUILD_DIR\"; fi\n  - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then cp \"$TRAVIS_BUILD_DIR/libsciter.dylib\" \"$TRAVIS_BUILD_DIR/liblibsciter.dylib\"; fi\n\n  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$TRAVIS_BUILD_DIR\"; fi\n\n  - export PATH=\"$PATH:$TRAVIS_BUILD_DIR\"\n  - export LIBRARY_PATH=\"$LIBRARY_PATH:$TRAVIS_BUILD_DIR\"\n\n  - gcc --version\n  - go version\n  - go env\n  - echo $PWD\n\n\nscript:\n  - go build\n\n  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then cd examples; fi\n  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then go build ./...; fi\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.7119140625,
          "content": "# Go bindings for Sciter\n\n[![AppVeyor status](https://ci.appveyor.com/api/projects/status/rphv883klffw9em9/branch/master?svg=true)](https://ci.appveyor.com/project/pravic/go-sciter)\n[![Travis Status](https://travis-ci.com/sciter-sdk/go-sciter.svg?branch=master)](https://travis-ci.com/sciter-sdk/go-sciter)\n[![License](https://img.shields.io/github/license/sciter-sdk/go-sciter.svg)](https://github.com/sciter-sdk/go-sciter)\n[![Join the forums at https://sciter.com/forums](https://img.shields.io/badge/forum-sciter.com-orange.svg)](https://sciter.com/forums)\n\nCheck [this page](http://sciter.com/developers/sciter-sdk-bindings/) for other language bindings (Delphi / D / Go / .NET / Python / Rust).\n\n----\n\n\n# Attention\n\nThe ownership of project is transferred to this new organization.\nThus the `import path` for golang should now be `github.com/sciter-sdk/go-sciter`, but the package name is still `sciter`.\n\n# Introduction\n\nThis package provides a Golang bindings of [Sciter][] using cgo.\nUsing go sciter you must have the platform specified `sciter dynamic library`\ndownloaded from [sciter-sdk][], the library itself is rather small\n (under 5MB, less than 2MB when upxed) .\n\nMost [Sciter][] API are supported, including:\n\n * Html string/file loading\n * DOM manipulation/callback/event handling\n * DOM state/attribute handling\n * Custom resource loading\n * Sciter Behavior\n * Sciter Options\n * Sciter Value support\n * NativeFunctor (used in sciter scripting)\n\nAnd the API are organized in more or less a gopher friendly way.\n\nThings that are not supported:\n\n * Sciter Node API\n * TIScript Engine API\n\n# Getting Started\n\n###  At the moment only **Go 1.10** or higher is supported (issue #136).\n\n 1. Download the [sciter-sdk][]\n 2. Extract the sciter runtime library from [sciter-sdk][] to system PATH\n\n    The runtime libraries lives in `bin` `bin.lnx` `bin.osx` with suffix like `dll` `so` or `dylib`\n\n    * Windows: simply copying `bin\\64\\sciter.dll` to `c:\\windows\\system32` is just enough\n    * Linux:\n      - `cd sciter-sdk/bin.lnx/x64`\n      - `export LIBRARY_PATH=$PWD`\n      - `echo $PWD >> libsciter.conf`\n      - `sudo cp libsciter.conf /etc/ld.so.conf.d/`\n      - `sudo ldconfig`\n      - `ldconfig -p | grep sciter` should print libsciter-gtk.so location\n    * OSX:\n      - `cd sciter-sdk/bin.osx/`\n      - `export DYLD_LIBRARY_PATH=$PWD`\n\n 3. Set up GCC envrionmnet for CGO\n\n    [mingw64-gcc][] (5.2.0 and 7.2.0 are tested) is recommended for Windows users.\n\n    Under Linux gcc(4.8 or above) and gtk+-3.0 are needed.\n\n 4. `go get -x github.com/sciter-sdk/go-sciter`\n\n 5. Run the example and enjoy :)\n\n# Sciter Desktop UI Examples\n\n![](http://sciter.com/screenshots/slide-wt5.png)\n\n![](http://sciter.com/screenshots/slide-norton360.png)\n\n![](http://sciter.com/screenshots/slide-norton-nis.png)\n\n![](http://sciter.com/screenshots/slide-cardio.png)\n\n![](http://sciter.com/screenshots/slide-surveillance.png)\n\n![](http://sciter.com/screenshots/slide-technology.png)\n\n![](http://sciter.com/screenshots/slide-sciter-ide.png)\n\n![](http://sciter.com/screenshots/slide-sciter-osx.png)\n\n![](http://sciter.com/screenshots/slide-sciter-gtk.png)\n\n\n# Sciter Version Support\nCurrently supports [Sciter][] version `4.0.0.0` and higher.\n\n[Sciter]: http://sciter.com/\n[sciter-sdk]: http://sciter.com/download/\n\n# About Sciter\n\n[Sciter][] is an `Embeddable HTML/CSS/script engine for modern UI development, Web designers, and developers, can reuse their experience and expertise in creating modern looking desktop applications.`\n\nIn my opinion, [Sciter][] , though not open sourced, is an great\ndesktop UI development envrionment using the full stack of web technologies,\nwhich is rather small (under 5MB) especially compared to [CEF][],[Node Webkit][nw] and [Atom Electron][electron]. :)\n\nFinally, according to [Andrew Fedoniouk][author] the author and the Sciter\n`END USER LICENSE AGREEMENT` , the binary form of the [Sciter][]\ndynamic libraries are totally free to use for commercial or\nnon-commercial applications.\n\n# The Tailored Sciter C Headers\nThis binding ueses a tailored version of the sciter C Headers, which lives in directory: `include`. The included c headers are a modified version of the\n[sciter-sdk][] standard headers.\n\nIt seems [Sciter][] is developed using C++, and the included headers in the\n[Sciter SDK][sciter-sdk] are a mixture of C and C++, which is not\nquite suitable for an easy golang binding.\n\nI'm not much fond of C++ since I started to use Golang, so I made this\nmodification and hope [Andrew Fedoniouk][author] the author would provide\npure C header files for Sciter. :)\n\n[CEF]:https://bitbucket.org/chromiumembedded/cef\n[nw]: https://github.com/nwjs/nw.js\n[electron]:https://github.com/atom/electron\n\n[author]: http://sciter.com/about/\n[mingw64-gcc]: http://sourceforge.net/projects/mingw-w64/\n"
        },
        {
          "name": "callbacks.c",
          "type": "blob",
          "size": 2.357421875,
          "content": "#include \"sciter-x.h\"\r\n#include \"_cgo_export.h\"\r\n\r\n// typedef SBOOL SC_CALLBACK SciterElementCallback(HELEMENT he, LPVOID param);\r\n\r\nSBOOL SC_CALLBACK SciterElementCallback_cgo(HELEMENT he, LPVOID param)\r\n{\r\n    return goSciterElementCallback(he, param);\r\n}\r\n\r\n// typedef VOID SC_CALLBACK LPCBYTE_RECEIVER(LPCBYTE bytes, UINT num_bytes, LPVOID param);\r\nVOID SC_CALLBACK LPCBYTE_RECEIVER_cgo(LPCBYTE bytes, UINT num_bytes, LPVOID param)\r\n{\r\n    goLPCBYTE_RECEIVER((BYTE*)bytes, num_bytes, param);\r\n}\r\n\r\n// typedef VOID SC_CALLBACK LPCWSTR_RECEIVER(LPCWSTR str, UINT str_length, LPVOID param);\r\nVOID SC_CALLBACK LPCWSTR_RECEIVER_cgo(LPCWSTR str, UINT str_length, LPVOID param)\r\n{\r\n    goLPCWSTR_RECEIVER((WCHAR*)str, str_length, param);\r\n}\r\n\r\n// typedef VOID SC_CALLBACK LPCSTR_RECEIVER(LPCSTR str, UINT str_length, LPVOID param);\r\nVOID SC_CALLBACK LPCSTR_RECEIVER_cgo(LPCSTR str, UINT str_length, LPVOID param)\r\n{\r\n    goLPCSTR_RECEIVER(str, str_length, param);\r\n}\r\n\r\n// typedef SBOOL SC_CALLBACK ElementEventProc(LPVOID tag, HELEMENT he, UINT evtg, LPVOID prms);\r\nSBOOL SC_CALLBACK ElementEventProc_cgo(LPVOID tag, HELEMENT he, UINT evtg, LPVOID prms)\r\n{\r\n    return goElementEventProc(tag, he, evtg, prms);\r\n}\r\n\r\n// typedef UINT SC_CALLBACK SciterHostCallback(LPSCITER_CALLBACK_NOTIFICATION pns, LPVOID callbackParam);\r\nUINT SC_CALLBACK SciterHostCallback_cgo(LPSCITER_CALLBACK_NOTIFICATION pns, LPVOID callbackParam)\r\n{\r\n    return goSciterHostCallback(pns, callbackParam);\r\n}\r\n\r\n// typedef VOID NATIVE_FUNCTOR_INVOKE(VOID* tag, UINT argc, const VALUE* argv, VALUE* retval); // retval may contain error definition\r\nVOID NATIVE_FUNCTOR_INVOKE_cgo(VOID* tag, UINT argc, const VALUE* argv, VALUE* retval)\r\n{\r\n    goNATIVE_FUNCTOR_INVOKE(tag, argc, (VALUE*)argv, retval);\r\n}\r\n\r\n// typedef VOID NATIVE_FUNCTOR_RELEASE(VOID* tag);\r\nVOID NATIVE_FUNCTOR_RELEASE_cgo(VOID* tag)\r\n{\r\n    goNATIVE_FUNCTOR_RELEASE(tag);\r\n}\r\n\r\n// typedef INT SC_CALLBACK ELEMENT_COMPARATOR(HELEMENT he1, HELEMENT he2, LPVOID param);\r\n\r\nINT SC_CALLBACK ELEMENT_COMPARATOR_cgo(HELEMENT he1, HELEMENT he2, LPVOID param)\r\n{\r\n    return goELEMENT_COMPARATOR(he1, he2, param);\r\n}\r\n\r\n// typedef SBOOL SC_CALLBACK KeyValueCallback(LPVOID param, const VALUE* pkey, const VALUE* pval);\r\n\r\nSBOOL SC_CALLBACK KeyValueCallback_cgo(LPVOID param, const VALUE* pkey, const VALUE* pval)\r\n{\r\n    return goKeyValueCallback(param, (VALUE*)pkey, (VALUE*)pval);\r\n}"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "generate.go",
          "type": "blob",
          "size": 0.2646484375,
          "content": "package sciter\r\n\r\n//go:generate stringer -type=BehaviorEvent,MouseEvent,CursorType,KeyEvent,FocusEvent,ScrollEvent,GestureCmd,GestureState,GestureTypeFlag,DrawEvent,EventReason,EditChangedReason,BehaviorMethodIdentifier,SCDOM_RESULT,VALUE_RESULT -output types_string.go\r\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "request.c",
          "type": "blob",
          "size": 4.16796875,
          "content": " #include <sciter-x.h>\n\nextern LPSciterRequestAPI rapi();\n\nREQUEST_RESULT SCAPI RequestUse( HREQUEST rq ) { return rapi()->RequestUse(rq); }\nREQUEST_RESULT SCAPI RequestUnUse( HREQUEST rq ) { return rapi()->RequestUnUse(rq); }\nREQUEST_RESULT SCAPI RequestUrl( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestUrl(rq,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestContentUrl( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestContentUrl(rq,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetRequestType( HREQUEST rq, REQUEST_RQ_TYPE* pType ) { return rapi()->RequestGetRequestType(rq,pType); }\nREQUEST_RESULT SCAPI RequestGetRequestedDataType( HREQUEST rq, SciterResourceType* pData ) { return rapi()->RequestGetRequestedDataType(rq,pData); }\nREQUEST_RESULT SCAPI RequestGetReceivedDataType( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetReceivedDataType(rq,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetNumberOfParameters( HREQUEST rq, UINT* pNumber ) { return rapi()->RequestGetNumberOfParameters(rq,pNumber); }\nREQUEST_RESULT SCAPI RequestGetNthParameterName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param  ) { return rapi()->RequestGetNthParameterName(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetNthParameterValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param  ) { return rapi()->RequestGetNthParameterValue(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetTimes( HREQUEST rq, UINT* pStarted, UINT* pEnded ) { return rapi()->RequestGetTimes(rq,pStarted,pEnded); }\nREQUEST_RESULT SCAPI RequestGetNumberOfRqHeaders( HREQUEST rq, UINT* pNumber ) { return rapi()->RequestGetNumberOfRqHeaders(rq,pNumber); }\nREQUEST_RESULT SCAPI RequestGetNthRqHeaderName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetNthRqHeaderName(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetNthRqHeaderValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetNthRqHeaderValue(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetNumberOfRspHeaders( HREQUEST rq, UINT* pNumber ) { return rapi()->RequestGetNumberOfRspHeaders(rq,pNumber); }\nREQUEST_RESULT SCAPI RequestGetNthRspHeaderName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetNthRspHeaderName(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetNthRspHeaderValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetNthRspHeaderValue(rq,n,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetCompletionStatus( HREQUEST rq, REQUEST_STATE* pState, UINT* pCompletionStatus ) { return rapi()->RequestGetCompletionStatus(rq,pState,pCompletionStatus); }\nREQUEST_RESULT SCAPI RequestGetProxyHost( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetProxyHost(rq,rcv,rcv_param); }\nREQUEST_RESULT SCAPI RequestGetProxyPort( HREQUEST rq, UINT* pPort ) { return rapi()->RequestGetProxyPort(rq,pPort); }\nREQUEST_RESULT SCAPI RequestSetSucceeded( HREQUEST rq, UINT status, LPCBYTE dataOrNull, UINT dataLength) { return rapi()->RequestSetSucceeded(rq,status,dataOrNull,dataLength); }\nREQUEST_RESULT SCAPI RequestSetFailed( HREQUEST rq, UINT status, LPCBYTE dataOrNull, UINT dataLength ) { return rapi()->RequestSetFailed(rq,status,dataOrNull,dataLength); }\nREQUEST_RESULT SCAPI RequestAppendDataChunk( HREQUEST rq, LPCBYTE data, UINT dataLength ) { return rapi()->RequestAppendDataChunk(rq,data,dataLength); }\nREQUEST_RESULT SCAPI RequestSetRqHeader( HREQUEST rq, LPCWSTR name, LPCWSTR value ) { return rapi()->RequestSetRqHeader(rq,name,value); }\nREQUEST_RESULT SCAPI RequestSetRspHeader( HREQUEST rq, LPCWSTR name, LPCWSTR value ) { return rapi()->RequestSetRspHeader(rq,name,value); }\nREQUEST_RESULT SCAPI RequestSetReceivedDataType( HREQUEST rq, LPCSTR type ) { return rapi()->RequestSetReceivedDataType(rq,type); }\nREQUEST_RESULT SCAPI RequestSetReceivedDataEncoding( HREQUEST rq, LPCSTR encoding ) { return rapi()->RequestSetReceivedDataEncoding(rq,encoding); }\nREQUEST_RESULT SCAPI RequestGetData( HREQUEST rq, LPCBYTE_RECEIVER* rcv, LPVOID rcv_param ) { return rapi()->RequestGetData(rq,rcv,rcv_param); }\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 12.5673828125,
          "content": "package sciter\n\n/*\n#include <sciter-x.h>\n\nextern REQUEST_RESULT SCAPI RequestUse( HREQUEST rq );\nextern REQUEST_RESULT SCAPI RequestUnUse( HREQUEST rq );\nextern REQUEST_RESULT SCAPI RequestUrl( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestContentUrl( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetRequestType( HREQUEST rq, REQUEST_RQ_TYPE* pType );\nextern REQUEST_RESULT SCAPI RequestGetRequestedDataType( HREQUEST rq, SciterResourceType* pData );\nextern REQUEST_RESULT SCAPI RequestGetReceivedDataType( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetNumberOfParameters( HREQUEST rq, UINT* pNumber );\nextern REQUEST_RESULT SCAPI RequestGetNthParameterName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param  );\nextern REQUEST_RESULT SCAPI RequestGetNthParameterValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param  );\nextern REQUEST_RESULT SCAPI RequestGetTimes( HREQUEST rq, UINT* pStarted, UINT* pEnded );\nextern REQUEST_RESULT SCAPI RequestGetNumberOfRqHeaders( HREQUEST rq, UINT* pNumber );\nextern REQUEST_RESULT SCAPI RequestGetNthRqHeaderName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetNthRqHeaderValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetNumberOfRspHeaders( HREQUEST rq, UINT* pNumber );\nextern REQUEST_RESULT SCAPI RequestGetNthRspHeaderName( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetNthRspHeaderValue( HREQUEST rq, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetCompletionStatus( HREQUEST rq, REQUEST_STATE* pState, UINT* pCompletionStatus );\nextern REQUEST_RESULT SCAPI RequestGetProxyHost( HREQUEST rq, LPCSTR_RECEIVER* rcv, LPVOID rcv_param );\nextern REQUEST_RESULT SCAPI RequestGetProxyPort( HREQUEST rq, UINT* pPort );\nextern REQUEST_RESULT SCAPI RequestSetSucceeded( HREQUEST rq, UINT status, LPCBYTE dataOrNull, UINT dataLength);\nextern REQUEST_RESULT SCAPI RequestSetFailed( HREQUEST rq, UINT status, LPCBYTE dataOrNull, UINT dataLength );\nextern REQUEST_RESULT SCAPI RequestAppendDataChunk( HREQUEST rq, LPCBYTE data, UINT dataLength );\nextern REQUEST_RESULT SCAPI RequestSetRqHeader( HREQUEST rq, LPCWSTR name, LPCWSTR value );\nextern REQUEST_RESULT SCAPI RequestSetRspHeader( HREQUEST rq, LPCWSTR name, LPCWSTR value );\nextern REQUEST_RESULT SCAPI RequestSetReceivedDataType( HREQUEST rq, LPCSTR type );\nextern REQUEST_RESULT SCAPI RequestSetReceivedDataEncoding( HREQUEST rq, LPCSTR encoding );\nextern REQUEST_RESULT SCAPI RequestGetData( HREQUEST rq, LPCBYTE_RECEIVER* rcv, LPVOID rcv_param );\n*/\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"time\"\n\t\"unsafe\"\n)\n\n/** Resource data type.\n *  Used by SciterDataReadyAsync() function.\n **/\ntype SciterResourceType uint32\n\n// typedef enum SciterResourceType\nconst (\n\tRT_DATA_HTML SciterResourceType = iota\n\tRT_DATA_IMAGE\n\tRT_DATA_STYLE\n\tRT_DATA_CURSOR\n\tRT_DATA_SCRIPT\n\tRT_DATA_RAW\n\tRT_DATA_FONT\n\tRT_DATA_SOUND // wav bytes\n\n\tRT_DATA_FORCE_DWORD = 0xffffffff\n)\n\ntype REQUEST_RESULT int32\n\n// enum REQUEST_RESULT\nconst (\n\tREQUEST_PANIC = iota - 1 // e.g. not enough memory\n\tREQUEST_OK\n\tREQUEST_BAD_PARAM    // bad parameter\n\tREQUEST_FAILURE      // operation failed, e.g. index out of bounds\n\tREQUEST_NOTSUPPORTED // the platform does not support requested feature\n)\n\n// enum REQUEST_RQ_TYPE\nconst (\n\tRRT_GET = 1 + iota\n\tRRT_POST\n\tRRT_PUT\n\tRRT_DELETE\n\n\tRRT_FORCE_DWORD = 0xFFFFFFFF\n)\n\n// enum REQUEST_STATE\nconst (\n\tRS_PENDING = iota\n\tRS_SUCCESS // completed successfully\n\tRS_FAILURE // completed with failure\n\n\tRS_FORCE_DWORD = 0xFFFFFFFF\n)\n\ntype requestError struct {\n\tResult  REQUEST_RESULT\n\tMessage string\n}\n\nfunc (e *requestError) Error() string {\n\treturn fmt.Sprintf(\"%s: %s\", e.Result.String(), e.Message)\n}\n\nfunc newRequestError(ret REQUEST_RESULT, msg string) *requestError {\n\treturn &requestError{\n\t\tResult:  ret,\n\t\tMessage: msg,\n\t}\n}\n\nfunc wrapRequestResult(r C.REQUEST_RESULT, msg string) error {\n\tif r == C.REQUEST_RESULT(REQUEST_OK) {\n\t\treturn nil\n\t}\n\treturn newRequestError(REQUEST_RESULT(r), msg)\n}\n\nvar (\n\tBAD_HREQUEST = C.HREQUEST(unsafe.Pointer(uintptr(0)))\n)\n\n// Request represents a request issued by sciter\n// e.g. el.request(...) or view.request(...)\ntype Request struct {\n\thandle C.HREQUEST\n}\n\n// WrapRequest wraps C.HREQUEST to a go side *Request, doing RequestUse/RequestUnUse automatically\nfunc WrapRequest(requestId C.HREQUEST) *Request {\n\tr := &Request{\n\t\thandle: requestId,\n\t}\n\tr.use()\n\truntime.SetFinalizer(r, (*Request).finalize)\n\treturn r\n}\n\nfunc (r *Request) use() error {\n\tret := C.RequestUse(r.handle)\n\treturn wrapRequestResult(ret, \"RequestUse\")\n}\n\nfunc (r *Request) unUse() error {\n\tret := C.RequestUnUse(r.handle)\n\treturn wrapRequestResult(ret, \"RequestUnUse\")\n}\n\nfunc (r *Request) finalize() {\n\tr.unUse()\n\tr.handle = BAD_HREQUEST\n}\n\nfunc (r *Request) Url() (string, error) {\n\tvar url string\n\t// args\n\tcurl := C.LPVOID(unsafe.Pointer(&url))\n\t// cgo call\n\tret := C.RequestUrl(r.handle, lpcstr_receiver, curl)\n\treturn url, wrapRequestResult(ret, \"RequestUrl\")\n}\n\nfunc (r *Request) ContentUrl() (string, error) {\n\tvar url string\n\t// args\n\tcurl := C.LPVOID(unsafe.Pointer(&url))\n\t// cgo call\n\tret := C.RequestContentUrl(r.handle, lpcstr_receiver, curl)\n\treturn url, wrapRequestResult(ret, \"RequestContentUrl\")\n}\n\nfunc (r *Request) RequestType() (uint, error) {\n\tvar requestType uint\n\t// args\n\tcrequestType := (*C.REQUEST_RQ_TYPE)(unsafe.Pointer(&requestType))\n\t// cgo call\n\tret := C.RequestGetRequestType(r.handle, crequestType)\n\treturn requestType, wrapRequestResult(ret, \"RequestGetRequestType\")\n}\n\nfunc (r *Request) RequestedDataType() (SciterResourceType, error) {\n\tvar resourceType SciterResourceType\n\t// args\n\tcresourceType := (*C.SciterResourceType)(unsafe.Pointer(&resourceType))\n\t// cgo call\n\tret := C.RequestGetRequestedDataType(r.handle, cresourceType)\n\treturn resourceType, wrapRequestResult(ret, \"RequestGetRequestedDataType\")\n}\n\nfunc (r *Request) ReceivedDataType() (string, error) {\n\tvar dataType string\n\t// args\n\tcdataType := C.LPVOID(unsafe.Pointer(&dataType))\n\t// cgo call\n\tret := C.RequestGetReceivedDataType(r.handle, lpcstr_receiver, cdataType)\n\treturn dataType, wrapRequestResult(ret, \"RequestGetReceivedDataType\")\n}\n\nfunc (r *Request) NumberOfParameters() (uint, error) {\n\tvar numParams uint\n\t// args\n\tcnumParams := (*C.UINT)(unsafe.Pointer(&numParams))\n\t// cgo call\n\tret := C.RequestGetNumberOfParameters(r.handle, cnumParams)\n\treturn numParams, wrapRequestResult(ret, \"RequestGetNumberOfParameters\")\n}\n\nfunc (r *Request) NthParameterName(idx uint) (string, error) {\n\tvar name string\n\t// args\n\tcname := C.LPVOID(unsafe.Pointer(&name))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthParameterName(r.handle, cidx, lpcwstr_receiver, cname)\n\treturn name, wrapRequestResult(ret, \"RequestGetNthParameterName\")\n}\n\nfunc (r *Request) NthParameterValue(idx uint) (string, error) {\n\tvar value string\n\t// args\n\tcvalue := C.LPVOID(unsafe.Pointer(&value))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthParameterValue(r.handle, cidx, lpcwstr_receiver, cvalue)\n\treturn value, wrapRequestResult(ret, \"RequestGetNthParameterValue\")\n}\n\nfunc (r *Request) Times() (time.Time, time.Time, error) {\n\tvar started, ended uint\n\tvar tStarted, tEnded time.Time\n\t// args\n\tcstarted := (*C.UINT)(unsafe.Pointer(&started))\n\tcended := (*C.UINT)(unsafe.Pointer(&ended))\n\t// cgo call\n\tret := C.RequestGetTimes(r.handle, cstarted, cended)\n\ttStarted = time.Unix(int64(started), 0)\n\ttEnded = time.Unix(int64(ended), 0)\n\treturn tStarted, tEnded, wrapRequestResult(ret, \"RequestGetTimes\")\n}\n\nfunc (r *Request) NumberOfRqHeaders() (uint, error) {\n\tvar num uint\n\t// args\n\tcnum := (*C.UINT)(unsafe.Pointer(&num))\n\t// cgo call\n\tret := C.RequestGetNumberOfRqHeaders(r.handle, cnum)\n\treturn num, wrapRequestResult(ret, \"RequestGetNumberOfRqHeaders\")\n}\n\nfunc (r *Request) NthRqHeaderName(idx uint) (string, error) {\n\tvar name string\n\t// args\n\tcname := C.LPVOID(unsafe.Pointer(&name))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthRqHeaderName(r.handle, cidx, lpcwstr_receiver, cname)\n\treturn name, wrapRequestResult(ret, \"RequestGetNthRqHeaderName\")\n}\n\nfunc (r *Request) NthRqHeaderValue(idx uint) (string, error) {\n\tvar val string\n\t// args\n\tcvalue := C.LPVOID(unsafe.Pointer(&val))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthRqHeaderValue(r.handle, cidx, lpcwstr_receiver, cvalue)\n\treturn val, wrapRequestResult(ret, \"RequestGetNthRqHeaderValue\")\n}\n\nfunc (r *Request) NumberOfRspHeaders() (uint, error) {\n\tvar num uint\n\t// args\n\tcnum := (*C.UINT)(unsafe.Pointer(&num))\n\t// cgo call\n\tret := C.RequestGetNumberOfRspHeaders(r.handle, cnum)\n\treturn num, wrapRequestResult(ret, \"RequestGetNumberOfRspHeaders\")\n}\n\nfunc (r *Request) NthRspHeaderName(idx uint) (string, error) {\n\tvar name string\n\t// args\n\tcname := C.LPVOID(unsafe.Pointer(&name))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthRspHeaderName(r.handle, cidx, lpcwstr_receiver, cname)\n\treturn name, wrapRequestResult(ret, \"RequestGetNthRspHeaderName\")\n}\n\nfunc (r *Request) NthRspHeaderValue(idx uint) (string, error) {\n\tvar val string\n\t// args\n\tcvalue := C.LPVOID(unsafe.Pointer(&val))\n\tcidx := C.UINT(idx)\n\t// cgo call\n\tret := C.RequestGetNthRspHeaderValue(r.handle, cidx, lpcwstr_receiver, cvalue)\n\treturn val, wrapRequestResult(ret, \"RequestGetNthRspHeaderValue\")\n}\n\nfunc (r *Request) CompletionStatus() (uint, uint, error) {\n\tvar state, status uint\n\t// args\n\tcstate := (*C.REQUEST_STATE)(unsafe.Pointer(&state))\n\tcstatus := (*C.UINT)(unsafe.Pointer(&status))\n\t// cgo call\n\tret := C.RequestGetCompletionStatus(r.handle, cstate, cstatus)\n\treturn state, status, wrapRequestResult(ret, \"RequestGetCompletionStatus\")\n}\n\nfunc (r *Request) ProxyHost() (string, error) {\n\tvar host string\n\t// args\n\tchost := C.LPVOID(unsafe.Pointer(&host))\n\t// cgo call\n\tret := C.RequestGetProxyHost(r.handle, lpcstr_receiver, chost)\n\treturn host, wrapRequestResult(ret, \"RequestGetProxyHost\")\n}\n\nfunc (r *Request) ProxyPort() (uint, error) {\n\tvar portno uint\n\t// args\n\tcportno := (*C.UINT)(unsafe.Pointer(&portno))\n\t// cgo call\n\tret := C.RequestGetProxyPort(r.handle, cportno)\n\treturn portno, wrapRequestResult(ret, \"RequestGetProxyPort\")\n}\n\nfunc (r *Request) SetSucceeded(status uint, data []byte) error {\n\t// args\n\tcstatus := C.UINT(status)\n\tvar pData C.LPCBYTE\n\tif len(data) > 0 {\n\t\tpData = C.LPCBYTE(unsafe.Pointer(&data[0]))\n\t}\n\tcdataLength := C.UINT(len(data))\n\n\t//cgo call\n\tret := C.RequestSetSucceeded(r.handle, cstatus, pData, cdataLength)\n\treturn wrapRequestResult(ret, \"RequestSetSucceeded\")\n}\n\nfunc (r *Request) SetFailed(status uint, data []byte) error {\n\t// args\n\tcstatus := C.UINT(status)\n\tvar pData C.LPCBYTE\n\tif len(data) > 0 {\n\t\tpData = C.LPCBYTE(unsafe.Pointer(&data[0]))\n\t}\n\tcdataLength := C.UINT(len(data))\n\n\t//cgo call\n\tret := C.RequestSetFailed(r.handle, cstatus, pData, cdataLength)\n\treturn wrapRequestResult(ret, \"RequestSetFailed\")\n}\n\nfunc (r *Request) AppendDataChunk(data []byte) error {\n\t// args\n\tvar pData C.LPCBYTE\n\tif len(data) > 0 {\n\t\tpData = C.LPCBYTE(unsafe.Pointer(&data[0]))\n\t}\n\tcdataLength := C.UINT(len(data))\n\n\t//cgo call\n\tret := C.RequestAppendDataChunk(r.handle, pData, cdataLength)\n\treturn wrapRequestResult(ret, \"RequestAppendDataChunk\")\n}\n\nfunc (r *Request) SetRqHeader(name, value string) error {\n\t// args\n\tcname := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(name)))\n\tcvalue := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(value)))\n\t// cgo call\n\tret := C.RequestSetRqHeader(r.handle, cname, cvalue)\n\treturn wrapRequestResult(ret, \"RequestSetRqHeader\")\n}\n\nfunc (r *Request) SetRspHeader(name, value string) error {\n\t// args\n\tcname := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(name)))\n\tcvalue := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(value)))\n\t// cgo call\n\tret := C.RequestSetRspHeader(r.handle, cname, cvalue)\n\treturn wrapRequestResult(ret, \"RequestSetRspHeader\")\n}\n\nfunc (r *Request) SetReceivedDataType(dataType string) error {\n\t// args\n\tcdataType := C.LPCSTR(unsafe.Pointer(StringToBytePtr(dataType)))\n\t// cgo call\n\tret := C.RequestSetReceivedDataType(r.handle, cdataType)\n\treturn wrapRequestResult(ret, \"RequestSetReceivedDataType\")\n}\n\nfunc (r *Request) RequestSetReceivedDataEncoding(encoding string) error {\n\t// args\n\tcencoding := C.LPCSTR(unsafe.Pointer(StringToBytePtr(encoding)))\n\t// cgo call\n\tret := C.RequestSetReceivedDataEncoding(r.handle, cencoding)\n\treturn wrapRequestResult(ret, \"RequestSetReceivedDataEncoding\")\n}\n\nfunc (r *Request) Data() ([]byte, error) {\n\tvar buf []byte\n\t// args\n\tcbuf := C.LPVOID(unsafe.Pointer(&buf))\n\t// cgo call\n\tret := C.RequestGetData(r.handle, lpcbyte_receiver, cbuf)\n\treturn buf, wrapRequestResult(ret, \"RequestGetData\")\n}\n"
        },
        {
          "name": "rice",
          "type": "tree",
          "content": null
        },
        {
          "name": "sciter-x-api.c",
          "type": "blob",
          "size": 30.2470703125,
          "content": "#include <sciter-x.h>\n#include <string.h>\n\ntypedef ISciterAPI* (SCAPI *SciterAPI_ptr)();\n\nconst char * SCITER_DLL_PATH = SCITER_DLL_NAME;\n\n// getting ISciterAPI reference:\n\n#if defined(STATIC_LIB) || defined(SCITER_BUILD)\n\n    EXTERN_C ISciterAPI* SCAPI SciterAPI();\n\n    ISciterAPI* _SAPI(ISciterAPI* ext) {\n       static ISciterAPI* _api = NULL;\n       if( ext ) _api = ext;\n       if( !_api )\n       {\n          _api = SciterAPI();\n#if defined(__cplusplus) && !defined(PLAIN_API_ONLY)\n//          tiscript::ni(_api->TIScriptAPI());\n#endif\n       }\n       assert(_api);\n       return _api;\n    }\n\n#elif defined(WINDOWS)\n\n    ISciterAPI* _SAPI( ISciterAPI* ext ) {\n       static ISciterAPI* _api = NULL;\n       if( ext ) _api = ext;\n       if( !_api )\n       {\n          HMODULE hm = LoadLibrary( TEXT(SCITER_DLL_NAME) );\n          if(hm) {\n            SciterAPI_ptr sciterAPI = (SciterAPI_ptr) GetProcAddress(hm, \"SciterAPI\");\n            if( sciterAPI ) {\n              _api = sciterAPI();\n//#if defined(__cplusplus) && !defined(PLAIN_API_ONLY)\n//              tiscript::ni( _api->TIScriptAPI() );\n//#endif\n            } else {\n              FreeLibrary(hm);\n            }\n\n          }\n       }\n       assert(_api);\n       if( !_api ) {\n         //::MessageBox(NULL, TEXT(\"Sciter engine not found, quiting\"),TEXT(\"Error\"),MB_OK);\n         exit(-1);\n       }\n       return _api;\n    }\n\n#elif defined(OSX)\n\n    //typedef ISciterAPI* SCAPI (*SciterAPI_ptr)();\n\n    ISciterAPI* _SAPI( ISciterAPI* ext )\n    {\n        static ISciterAPI* _api = NULL;\n        if( ext ) _api = ext;\n        if( !_api ) {\n            pid_t pid;\n            char pathbuf[PROC_PIDPATHINFO_MAXSIZE];\n            char folderpath[PROC_PIDPATHINFO_MAXSIZE];\n            pid = getpid();\n            proc_pidpath (pid, pathbuf, sizeof(pathbuf));\n            realpath(pathbuf, folderpath);\n            *strrchr(folderpath, '/') = '\\0';\n\n            void* lib_sciter_handle = dlopen(SCITER_DLL_NAME, RTLD_LOCAL|RTLD_LAZY);\n            if( !lib_sciter_handle ) {\n                const char* lookup_paths[] =\n                {\n                    \"/\" SCITER_DLL_NAME,\n                    \"/../Frameworks/\" SCITER_DLL_NAME, // - (bundle folder)/Contents/Frameworks/\n                    \"/../../../\" SCITER_DLL_NAME // aside of bundle folder (SDK samples)\n                };\n                for( int n = 0; !lib_sciter_handle && n < 3; ++n ) {\n                    char tpath[PROC_PIDPATHINFO_MAXSIZE];\n                    strcpy(tpath,folderpath);\n                    strcat(tpath, lookup_paths[n]);\n                    lib_sciter_handle = dlopen(tpath, RTLD_LOCAL|RTLD_LAZY);\n                }\n            }\n            if (!lib_sciter_handle) {\n                fprintf(stderr, \"[%s] Unable to load library: %s\\n\", __FILE__, dlerror());\n                exit(EXIT_FAILURE);\n            }\n\n            SciterAPI_ptr sapi = (SciterAPI_ptr) dlsym(lib_sciter_handle, \"SciterAPI\");\n            if (!sapi) {\n                fprintf(stderr,\"[%s] Unable to get symbol: %s\\n\", __FILE__, dlerror());\n                exit(EXIT_FAILURE);\n            }\n            _api = sapi();\n            //tiscript::ni( _api->TIScriptAPI() );\n        }\n        assert(_api);\n        return _api;\n    }\n\n#elif defined(ANDROID)\n\n#if 1\n    EXTERN_C ISciterAPI *SciterAPI();\n\n    ISciterAPI* _SAPI( ISciterAPI* ext )\n    {\n        static ISciterAPI* _api = NULL;\n        if( ext )\n          _api = ext;\n        else\n          _api = SciterAPI();\n        assert(_api);\n        //if (!sapi) {\n        //  fprintf(stderr, \"[%s] Unable to get symbol: %s\\n\", __FILE__, dlerror());\n        //  exit(EXIT_FAILURE);\n        //}\n        return _api;\n    }\n\n#else\n    ISciterAPI *_SAPI(ISciterAPI *ext) {\n      static ISciterAPI *_api = NULL;\n      if (ext) _api = ext;\n      if (!_api) {\n        void *lib_sciter_handle = NULL;\n        // 1. try to load from the same folder as this executable\n        lib_sciter_handle = dlopen(SCITER_DLL_NAME, RTLD_LOCAL | RTLD_LAZY);\n        if (!lib_sciter_handle) {\n          fprintf(stderr, \"[%s] Unable to load library: %s\\n\", dlerror(), SCITER_DLL_NAME);\n        }\n\n        SciterAPI_ptr sapi = (SciterAPI_ptr)dlsym(lib_sciter_handle, \"SciterAPI\");\n        if (!sapi) {\n          fprintf(stderr, \"[%s] Unable to get symbol: %s\\n\", __FILE__, dlerror());\n          exit(EXIT_FAILURE);\n        }\n        _api = sapi();\n      }\n      assert(_api);\n      return _api;\n}\n\n#endif\n\n#elif defined(LINUX)\n\n#include <libgen.h>\n#include <dlfcn.h>\n\n// typedef ISciterAPI* SCAPI (*SciterAPI_ptr)();\n\nISciterAPI *_SAPI(ISciterAPI *ext) {\n  static ISciterAPI *_api = NULL;\n  if (ext) _api = ext;\n  if (!_api) {\n\n    char folderpath[2048] = {0};\n\n    if (readlink(\"/proc/self/exe\", folderpath, sizeof(folderpath)) != -1) {\n      dirname(folderpath);\n      // strcat  (pathbuf, \"/\");\n    }\n\n    void *lib_sciter_handle = NULL;\n\n    {\n      // 1. try to load from the same folder as this executable\n      const char *lookup_paths[] = {\"/\" SCITER_DLL_NAME, NULL};\n      for (int n = 0; !lib_sciter_handle; ++n) {\n        if (!lookup_paths[n]) break;\n        char tpath[2048] = {0};\n        strcpy(tpath, folderpath);\n        strcat(tpath, lookup_paths[n]);\n        // fprintf(stdout, \"[%s]\\n\",tpath);\n        lib_sciter_handle = dlopen(tpath, RTLD_LOCAL | RTLD_LAZY);\n        if (!lib_sciter_handle) {\n          fprintf(stderr, \"[%s] Unable to load library: %s\\n\", dlerror(),\n                  tpath);\n        }\n      }\n    }\n\n    if (!lib_sciter_handle) // 2. no luck, try to load from system paths\n      lib_sciter_handle = dlopen(SCITER_DLL_NAME, RTLD_LOCAL | RTLD_LAZY);\n\n    if (!lib_sciter_handle) {\n      fprintf(stderr, \"[%s] Unable to load library: %s\\n\", __FILE__, dlerror());\n      exit(EXIT_FAILURE);\n    }\n\n    SciterAPI_ptr sapi = (SciterAPI_ptr)dlsym(lib_sciter_handle, \"SciterAPI\");\n    if (!sapi) {\n      fprintf(stderr, \"[%s] Unable to get symbol: %s\\n\", __FILE__, dlerror());\n      exit(EXIT_FAILURE);\n    }\n    _api = sapi();\n  }\n  assert(_api);\n  return _api;\n}\n\n#endif\n\n\n  ISciterAPI* SAPI() {\n    return _SAPI(NULL);\n  }\n\n  LPSciterGraphicsAPI gapi()\n  {\n    return SAPI()->GetSciterGraphicsAPI();\n  }\n\n  LPSciterRequestAPI rapi()\n  {\n    return SAPI()->GetSciterRequestAPI();\n  }\n\n\n  // defining \"official\" API functions:\n\n    LPCWSTR SCAPI SciterClassName (void) { return SAPI()->SciterClassName(); }\n    UINT    SCAPI SciterVersion (SBOOL major) { return SAPI()->SciterVersion (major); }\n    SBOOL    SCAPI SciterDataReady (HWINDOW hwnd,LPCWSTR uri,LPCBYTE data, UINT dataLength) { return SAPI()->SciterDataReady (hwnd,uri,data,dataLength); }\n    SBOOL    SCAPI SciterDataReadyAsync (HWINDOW hwnd,LPCWSTR uri, LPCBYTE data, UINT dataLength, LPVOID requestId) { return SAPI()->SciterDataReadyAsync (hwnd,uri, data, dataLength, requestId); }\n#if defined(WINDOWS) && !defined(WINDOWLESS)\n    LRESULT SCAPI SciterProc (HWINDOW hwnd, UINT msg, WPARAM wParam, LPARAM lParam) { return SAPI()->SciterProc (hwnd,msg,wParam,lParam); }\n    LRESULT SCAPI SciterProcND (HWINDOW hwnd, UINT msg, WPARAM wParam, LPARAM lParam, SBOOL* pbHandled) { return SAPI()->SciterProcND (hwnd,msg,wParam,lParam,pbHandled); }\n#endif\n    SBOOL    SCAPI SciterLoadFile (HWINDOW hWndSciter, LPCWSTR filename) { return SAPI()->SciterLoadFile (hWndSciter,filename); }\n    SBOOL    SCAPI SciterLoadHtml (HWINDOW hWndSciter, LPCBYTE html, UINT htmlSize, LPCWSTR baseUrl) { return SAPI()->SciterLoadHtml (hWndSciter,html,htmlSize,baseUrl); }\n    VOID    SCAPI SciterSetCallback (HWINDOW hWndSciter, LPSciterHostCallback cb, LPVOID cbParam) { SAPI()->SciterSetCallback (hWndSciter,cb,cbParam); }\n    SBOOL    SCAPI SciterSetMasterCSS (LPCBYTE utf8, UINT numBytes) { return SAPI()->SciterSetMasterCSS (utf8,numBytes); }\n    SBOOL    SCAPI SciterAppendMasterCSS (LPCBYTE utf8, UINT numBytes) { return SAPI()->SciterAppendMasterCSS (utf8,numBytes); }\n    SBOOL    SCAPI SciterSetCSS (HWINDOW hWndSciter, LPCBYTE utf8, UINT numBytes, LPCWSTR baseUrl, LPCWSTR mediaType) { return SAPI()->SciterSetCSS (hWndSciter,utf8,numBytes,baseUrl,mediaType); }\n    SBOOL    SCAPI SciterSetMediaType (HWINDOW hWndSciter, LPCWSTR mediaType) { return SAPI()->SciterSetMediaType (hWndSciter,mediaType); }\n    SBOOL    SCAPI SciterSetMediaVars (HWINDOW hWndSciter, const SCITER_VALUE *mediaVars) { return SAPI()->SciterSetMediaVars (hWndSciter,mediaVars); }\n    UINT    SCAPI SciterGetMinWidth (HWINDOW hWndSciter) { return SAPI()->SciterGetMinWidth (hWndSciter); }\n    UINT    SCAPI SciterGetMinHeight (HWINDOW hWndSciter, UINT width) { return SAPI()->SciterGetMinHeight (hWndSciter,width); }\n    SBOOL    SCAPI SciterCall (HWINDOW hWnd, LPCSTR functionName, UINT argc, const SCITER_VALUE* argv, SCITER_VALUE* retval) { return SAPI()->SciterCall (hWnd,functionName, argc,argv,retval); }\n    SBOOL    SCAPI SciterEval ( HWINDOW hwnd, LPCWSTR script, UINT scriptLength, SCITER_VALUE* pretval) { return SAPI()->SciterEval ( hwnd, script, scriptLength, pretval); }\n    VOID    SCAPI SciterUpdateWindow(HWINDOW hwnd) { SAPI()->SciterUpdateWindow(hwnd); }\n#if defined(WINDOWS) && !defined(WINDOWLESS)\n    SBOOL    SCAPI SciterTranslateMessage (MSG* lpMsg) { return SAPI()->SciterTranslateMessage (lpMsg); }\n#endif\n   SBOOL    SCAPI SciterSetOption (HWINDOW hWnd, UINT option, UINT_PTR value ) { return SAPI()->SciterSetOption (hWnd,option,value ); }\n   VOID    SCAPI SciterGetPPI (HWINDOW hWndSciter, UINT* px, UINT* py) { SAPI()->SciterGetPPI (hWndSciter,px,py); }\n   SBOOL    SCAPI SciterGetViewExpando ( HWINDOW hwnd, VALUE* pval ) { return SAPI()->SciterGetViewExpando ( hwnd, pval ); }\n#if defined(WINDOWS) && !defined(WINDOWLESS)\n   SBOOL    SCAPI SciterRenderD2D (HWINDOW hWndSciter, IUnknown* /*ID2D1RenderTarget**/ prt) { return SAPI()->SciterRenderD2D (hWndSciter,prt); }\n   SBOOL    SCAPI SciterD2DFactory (IUnknown** /*ID2D1Factory ***/ ppf) { return SAPI()->SciterD2DFactory (ppf); }\n   SBOOL    SCAPI SciterDWFactory (IUnknown** /*IDWriteFactory ***/ ppf) { return SAPI()->SciterDWFactory (ppf); }\n#endif\n   SBOOL    SCAPI SciterGraphicsCaps (LPUINT pcaps) { return SAPI()->SciterGraphicsCaps (pcaps); }\n   SBOOL    SCAPI SciterSetHomeURL (HWINDOW hWndSciter, LPCWSTR baseUrl) { return SAPI()->SciterSetHomeURL (hWndSciter,baseUrl); }\n#if defined(OSX) && !defined(WINDOWLESS)\n   HWINDOW SCAPI SciterCreateNSView ( LPRECT frame ) { return SAPI()->SciterCreateNSView ( frame ); }\n#endif\n#if !defined(WINDOWLESS)\n   HWINDOW SCAPI SciterCreateWindow ( UINT creationFlags,LPRECT frame, SciterWindowDelegate* delegate, LPVOID delegateParam, HWINDOW parent) { return SAPI()->SciterCreateWindow (creationFlags,frame,delegate,delegateParam,parent); }\n#endif\n\n  SCDOM_RESULT SCAPI Sciter_UseElement(HELEMENT he) { return SAPI()->Sciter_UseElement(he); }\n  SCDOM_RESULT SCAPI Sciter_UnuseElement(HELEMENT he) { return SAPI()->Sciter_UnuseElement(he); }\n  SCDOM_RESULT SCAPI SciterGetRootElement(HWINDOW hwnd, HELEMENT *phe) { return SAPI()->SciterGetRootElement(hwnd, phe); }\n  SCDOM_RESULT SCAPI SciterGetFocusElement(HWINDOW hwnd, HELEMENT *phe) { return SAPI()->SciterGetFocusElement(hwnd, phe); }\n  SCDOM_RESULT SCAPI SciterFindElement(HWINDOW hwnd, POINT pt, HELEMENT* phe) { return SAPI()->SciterFindElement(hwnd,pt,phe); }\n  SCDOM_RESULT SCAPI SciterGetChildrenCount(HELEMENT he, UINT* count) { return SAPI()->SciterGetChildrenCount(he, count); }\n  SCDOM_RESULT SCAPI SciterGetNthChild(HELEMENT he, UINT n, HELEMENT* phe) { return SAPI()->SciterGetNthChild(he,n,phe); }\n  SCDOM_RESULT SCAPI SciterGetParentElement(HELEMENT he, HELEMENT* p_parent_he) { return SAPI()->SciterGetParentElement(he,p_parent_he); }\n  SCDOM_RESULT SCAPI SciterGetElementHtmlCB(HELEMENT he, SBOOL outer, LPCBYTE_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetElementHtmlCB( he, outer, rcv, rcv_param); }\n  SCDOM_RESULT SCAPI SciterGetElementTextCB(HELEMENT he, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetElementTextCB(he, rcv, rcv_param); }\n  SCDOM_RESULT SCAPI SciterSetElementText(HELEMENT he, LPCWSTR utf16, UINT length) { return SAPI()->SciterSetElementText(he, utf16, length); }\n  SCDOM_RESULT SCAPI SciterGetAttributeCount(HELEMENT he, LPUINT p_count) { return SAPI()->SciterGetAttributeCount(he, p_count); }\n  SCDOM_RESULT SCAPI SciterGetNthAttributeNameCB(HELEMENT he, UINT n, LPCSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetNthAttributeNameCB(he,n,rcv,rcv_param); }\n  SCDOM_RESULT SCAPI SciterGetNthAttributeValueCB(HELEMENT he, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetNthAttributeValueCB(he, n, rcv, rcv_param); }\n  SCDOM_RESULT SCAPI SciterGetAttributeByNameCB(HELEMENT he, LPCSTR name, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetAttributeByNameCB(he,name,rcv,rcv_param); }\n  SCDOM_RESULT SCAPI SciterSetAttributeByName(HELEMENT he, LPCSTR name, LPCWSTR value) { return SAPI()->SciterSetAttributeByName(he,name,value); }\n  SCDOM_RESULT SCAPI SciterClearAttributes(HELEMENT he) { return SAPI()->SciterClearAttributes(he); }\n  SCDOM_RESULT SCAPI SciterGetElementIndex(HELEMENT he, LPUINT p_index) { return SAPI()->SciterGetElementIndex(he,p_index); }\n  SCDOM_RESULT SCAPI SciterGetElementType(HELEMENT he, LPCSTR* p_type) { return SAPI()->SciterGetElementType(he,p_type); }\n  SCDOM_RESULT SCAPI SciterGetElementTypeCB(HELEMENT he, LPCSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetElementTypeCB(he,rcv,rcv_param); }\n  SCDOM_RESULT SCAPI SciterGetStyleAttributeCB(HELEMENT he, LPCSTR name, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterGetStyleAttributeCB(he,name,rcv,rcv_param); }\n  SCDOM_RESULT SCAPI SciterSetStyleAttribute(HELEMENT he, LPCSTR name, LPCWSTR value) { return SAPI()->SciterSetStyleAttribute(he,name,value); }\n  SCDOM_RESULT SCAPI SciterGetElementLocation(HELEMENT he, LPRECT p_location, UINT areas /*ELEMENT_AREAS*/) { return SAPI()->SciterGetElementLocation(he,p_location,areas); }\n  SCDOM_RESULT SCAPI SciterScrollToView(HELEMENT he, UINT SciterScrollFlags) { return SAPI()->SciterScrollToView(he,SciterScrollFlags); }\n  SCDOM_RESULT SCAPI SciterUpdateElement(HELEMENT he, SBOOL andForceRender) { return SAPI()->SciterUpdateElement(he,andForceRender); }\n  SCDOM_RESULT SCAPI SciterRefreshElementArea(HELEMENT he, RECT rc) { return SAPI()->SciterRefreshElementArea(he,rc); }\n  SCDOM_RESULT SCAPI SciterSetCapture(HELEMENT he) { return SAPI()->SciterSetCapture(he); }\n  SCDOM_RESULT SCAPI SciterReleaseCapture(HELEMENT he) { return SAPI()->SciterReleaseCapture(he); }\n  SCDOM_RESULT SCAPI SciterGetElementHwnd(HELEMENT he, HWINDOW* p_hwnd, SBOOL rootWindow) { return SAPI()->SciterGetElementHwnd(he,p_hwnd,rootWindow); }\n  SCDOM_RESULT SCAPI SciterCombineURL(HELEMENT he, LPWSTR szUrlBuffer, UINT UrlBufferSize) { return SAPI()->SciterCombineURL(he,szUrlBuffer,UrlBufferSize); }\n  SCDOM_RESULT SCAPI SciterSelectElements(HELEMENT  he, LPCSTR    CSS_selectors, SciterElementCallback* callback, LPVOID param) { return SAPI()->SciterSelectElements(he,CSS_selectors,callback,param); }\n  SCDOM_RESULT SCAPI SciterSelectElementsW(HELEMENT  he, LPCWSTR   CSS_selectors, SciterElementCallback* callback, LPVOID param) { return SAPI()->SciterSelectElementsW(he,CSS_selectors,callback,param); }\n  SCDOM_RESULT SCAPI SciterSelectParent(HELEMENT  he, LPCSTR    selector, UINT      depth, HELEMENT* heFound) { return SAPI()->SciterSelectParent(he,selector,depth,heFound); }\n  SCDOM_RESULT SCAPI SciterSelectParentW(HELEMENT  he, LPCWSTR   selector, UINT      depth, HELEMENT* heFound) { return SAPI()->SciterSelectParentW(he,selector,depth,heFound); }\n  SCDOM_RESULT SCAPI SciterSetElementHtml(HELEMENT he, const BYTE* html, UINT htmlLength, UINT where) { return SAPI()->SciterSetElementHtml(he,html,htmlLength,where); }\n  SCDOM_RESULT SCAPI SciterGetElementUID(HELEMENT he, UINT* puid) { return SAPI()->SciterGetElementUID(he,puid); }\n  SCDOM_RESULT SCAPI SciterGetElementByUID(HWINDOW hwnd, UINT uid, HELEMENT* phe) { return SAPI()->SciterGetElementByUID(hwnd,uid,phe); }\n  SCDOM_RESULT SCAPI SciterShowPopup(HELEMENT hePopup, HELEMENT heAnchor, UINT placement) { return SAPI()->SciterShowPopup(hePopup,heAnchor,placement); }\n  SCDOM_RESULT SCAPI SciterShowPopupAt(HELEMENT hePopup, POINT pos, UINT placement) { return SAPI()->SciterShowPopupAt(hePopup,pos,placement); }\n  SCDOM_RESULT SCAPI SciterHidePopup(HELEMENT he) { return SAPI()->SciterHidePopup(he); }\n  SCDOM_RESULT SCAPI SciterGetElementState( HELEMENT he, UINT* pstateBits) { return SAPI()->SciterGetElementState(he,pstateBits); }\n  SCDOM_RESULT SCAPI SciterSetElementState( HELEMENT he, UINT stateBitsToSet, UINT stateBitsToClear, SBOOL updateView) { return SAPI()->SciterSetElementState(he,stateBitsToSet,stateBitsToClear,updateView); }\n  SCDOM_RESULT SCAPI SciterCreateElement( LPCSTR tagname, LPCWSTR textOrNull, /*out*/ HELEMENT *phe ) { return SAPI()->SciterCreateElement(tagname,textOrNull,phe ); }\n  SCDOM_RESULT SCAPI SciterCloneElement( HELEMENT he, /*out*/ HELEMENT *phe ) { return SAPI()->SciterCloneElement(he,phe ); }\n  SCDOM_RESULT SCAPI SciterInsertElement( HELEMENT he, HELEMENT hparent, UINT index ) { return SAPI()->SciterInsertElement(he,hparent,index ); }\n  SCDOM_RESULT SCAPI SciterDetachElement( HELEMENT he ) { return SAPI()->SciterDetachElement( he ); }\n  SCDOM_RESULT SCAPI SciterDeleteElement(HELEMENT he) { return SAPI()->SciterDeleteElement(he); }\n  SCDOM_RESULT SCAPI SciterSetTimer( HELEMENT he, UINT milliseconds, UINT_PTR timer_id ) { return SAPI()->SciterSetTimer(he,milliseconds,timer_id ); }\n  SCDOM_RESULT SCAPI SciterDetachEventHandler( HELEMENT he, LPELEMENT_EVENT_PROC pep, LPVOID tag ) { return SAPI()->SciterDetachEventHandler(he,pep,tag ); }\n  SCDOM_RESULT SCAPI SciterAttachEventHandler( HELEMENT he, LPELEMENT_EVENT_PROC pep, LPVOID tag ) { return SAPI()->SciterAttachEventHandler( he,pep,tag ); }\n  SCDOM_RESULT SCAPI SciterWindowAttachEventHandler( HWINDOW hwndLayout, LPELEMENT_EVENT_PROC pep, LPVOID tag, UINT subscription ) { return SAPI()->SciterWindowAttachEventHandler(hwndLayout,pep,tag,subscription ); }\n  SCDOM_RESULT SCAPI SciterWindowDetachEventHandler( HWINDOW hwndLayout, LPELEMENT_EVENT_PROC pep, LPVOID tag ) { return SAPI()->SciterWindowDetachEventHandler(hwndLayout,pep,tag ); }\n  SCDOM_RESULT SCAPI SciterSendEvent( HELEMENT he, UINT appEventCode, HELEMENT heSource, UINT_PTR reason, /*out*/ SBOOL* handled) { return SAPI()->SciterSendEvent( he,appEventCode,heSource,reason,handled); }\n  SCDOM_RESULT SCAPI SciterPostEvent( HELEMENT he, UINT appEventCode, HELEMENT heSource, UINT_PTR reason) { return SAPI()->SciterPostEvent(he,appEventCode,heSource,reason); }\n  SCDOM_RESULT SCAPI SciterFireEvent( const BEHAVIOR_EVENT_PARAMS* evt, SBOOL post, SBOOL *handled) { return SAPI()->SciterFireEvent( evt, post, handled ); }\n  SCDOM_RESULT SCAPI SciterCallBehaviorMethod(HELEMENT he, struct METHOD_PARAMS* params) { return SAPI()->SciterCallBehaviorMethod(he,params); }\n  SCDOM_RESULT SCAPI SciterRequestElementData( HELEMENT he, LPCWSTR url, UINT dataType, HELEMENT initiator ) { return SAPI()->SciterRequestElementData(he,url,dataType,initiator ); }\n  SCDOM_RESULT SCAPI SciterHttpRequest( HELEMENT he, LPCWSTR url, UINT dataType, UINT requestType, struct REQUEST_PARAM* requestParams, UINT nParams) { return SAPI()->SciterHttpRequest(he,url,dataType,requestType,requestParams,nParams); }\n  SCDOM_RESULT SCAPI SciterGetScrollInfo( HELEMENT he, LPPOINT scrollPos, LPRECT viewRect, LPSIZE contentSize ) { return SAPI()->SciterGetScrollInfo( he,scrollPos,viewRect,contentSize ); }\n  SCDOM_RESULT SCAPI SciterSetScrollPos( HELEMENT he, POINT scrollPos, SBOOL smooth ) { return SAPI()->SciterSetScrollPos( he,scrollPos,smooth ); }\n  SCDOM_RESULT SCAPI SciterGetElementIntrinsicWidths( HELEMENT he, INT* pMinWidth, INT* pMaxWidth ) { return SAPI()->SciterGetElementIntrinsicWidths(he,pMinWidth,pMaxWidth ); }\n  SCDOM_RESULT SCAPI SciterGetElementIntrinsicHeight( HELEMENT he, INT forWidth, INT* pHeight ) { return SAPI()->SciterGetElementIntrinsicHeight( he,forWidth,pHeight ); }\n  SCDOM_RESULT SCAPI SciterIsElementVisible( HELEMENT he, SBOOL* pVisible) { return SAPI()->SciterIsElementVisible( he,pVisible); }\n  SCDOM_RESULT SCAPI SciterIsElementEnabled( HELEMENT he, SBOOL* pEnabled ) { return SAPI()->SciterIsElementEnabled( he, pEnabled ); }\n  SCDOM_RESULT SCAPI SciterSortElements( HELEMENT he, UINT firstIndex, UINT lastIndex, ELEMENT_COMPARATOR* cmpFunc, LPVOID cmpFuncParam ) { return SAPI()->SciterSortElements( he, firstIndex, lastIndex, cmpFunc, cmpFuncParam ); }\n  SCDOM_RESULT SCAPI SciterSwapElements( HELEMENT he1, HELEMENT he2 ) { return SAPI()->SciterSwapElements( he1,he2 ); }\n  SCDOM_RESULT SCAPI SciterTraverseUIEvent( UINT evt, LPVOID eventCtlStruct, SBOOL* bOutProcessed ) { return SAPI()->SciterTraverseUIEvent( evt,eventCtlStruct,bOutProcessed ); }\n  SCDOM_RESULT SCAPI SciterCallScriptingMethod( HELEMENT he, LPCSTR name, const VALUE* argv, UINT argc, VALUE* retval ) { return SAPI()->SciterCallScriptingMethod( he,name,argv,argc,retval ); }\n  SCDOM_RESULT SCAPI SciterCallScriptingFunction( HELEMENT he, LPCSTR name, const VALUE* argv, UINT argc, VALUE* retval ) { return SAPI()->SciterCallScriptingFunction( he,name,argv,argc,retval ); }\n  SCDOM_RESULT SCAPI SciterEvalElementScript( HELEMENT he, LPCWSTR script, UINT scriptLength, VALUE* retval ) { return SAPI()->SciterEvalElementScript( he, script, scriptLength, retval ); }\n  SCDOM_RESULT SCAPI SciterAttachHwndToElement(HELEMENT he, HWINDOW hwnd) { return SAPI()->SciterAttachHwndToElement(he,hwnd); }\n  SCDOM_RESULT SCAPI SciterControlGetType( HELEMENT he, /*CTL_TYPE*/ UINT *pType ) { return SAPI()->SciterControlGetType( he, pType ); }\n  SCDOM_RESULT SCAPI SciterGetValue( HELEMENT he, VALUE* pval ) { return SAPI()->SciterGetValue( he,pval ); }\n  SCDOM_RESULT SCAPI SciterSetValue( HELEMENT he, const VALUE* pval ) { return SAPI()->SciterSetValue( he, pval ); }\n  SCDOM_RESULT SCAPI SciterGetExpando( HELEMENT he, VALUE* pval, SBOOL forceCreation ) { return SAPI()->SciterGetExpando( he, pval, forceCreation ); }\n  //SCDOM_RESULT SCAPI SciterGetObject( HELEMENT he, void* pval, SBOOL forceCreation ) { return SAPI()->SciterGetObject( he, pval, forceCreation ); }\n  //SCDOM_RESULT SCAPI SciterGetElementNamespace(  HELEMENT he, void* pval) { return SAPI()->SciterGetElementNamespace( he,pval); }\n  SCDOM_RESULT SCAPI SciterGetHighlightedElement(HWINDOW hwnd, HELEMENT* phe) { return SAPI()->SciterGetHighlightedElement(hwnd, phe); }\n  SCDOM_RESULT SCAPI SciterSetHighlightedElement(HWINDOW hwnd, HELEMENT he) { return SAPI()->SciterSetHighlightedElement(hwnd,he); }\n  SCDOM_RESULT SCAPI SciterNodeAddRef(HNODE hn) { return SAPI()->SciterNodeAddRef(hn); }\n  SCDOM_RESULT SCAPI SciterNodeRelease(HNODE hn) { return SAPI()->SciterNodeRelease(hn); }\n  SCDOM_RESULT SCAPI SciterNodeCastFromElement(HELEMENT he, HNODE* phn) { return SAPI()->SciterNodeCastFromElement(he,phn); }\n  SCDOM_RESULT SCAPI SciterNodeCastToElement(HNODE hn, HELEMENT* he) { return SAPI()->SciterNodeCastToElement(hn,he); }\n  SCDOM_RESULT SCAPI SciterNodeFirstChild(HNODE hn, HNODE* phn) { return SAPI()->SciterNodeFirstChild(hn,phn); }\n  SCDOM_RESULT SCAPI SciterNodeLastChild(HNODE hn, HNODE* phn) { return SAPI()->SciterNodeLastChild(hn, phn); }\n  SCDOM_RESULT SCAPI SciterNodeNextSibling(HNODE hn, HNODE* phn) { return SAPI()->SciterNodeNextSibling(hn, phn); }\n  SCDOM_RESULT SCAPI SciterNodePrevSibling(HNODE hn, HNODE* phn) { return SAPI()->SciterNodePrevSibling(hn,phn); }\n  SCDOM_RESULT SCAPI SciterNodeParent(HNODE hnode, HELEMENT* pheParent) { return SAPI()->SciterNodeParent(hnode,pheParent) ; }\n  SCDOM_RESULT SCAPI SciterNodeNthChild(HNODE hnode, UINT n, HNODE* phn) { return SAPI()->SciterNodeNthChild(hnode,n,phn); }\n  SCDOM_RESULT SCAPI SciterNodeChildrenCount(HNODE hnode, UINT* pn) { return SAPI()->SciterNodeChildrenCount(hnode, pn); }\n  SCDOM_RESULT SCAPI SciterNodeType(HNODE hnode, UINT* pNodeType /*NODE_TYPE*/) { return SAPI()->SciterNodeType(hnode,pNodeType); }\n  SCDOM_RESULT SCAPI SciterNodeGetText(HNODE hnode, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterNodeGetText(hnode,rcv,rcv_param); }\n  SCDOM_RESULT SCAPI SciterNodeSetText(HNODE hnode, LPCWSTR text, UINT textLength) { return SAPI()->SciterNodeSetText(hnode,text,textLength); }\n  SCDOM_RESULT SCAPI SciterNodeInsert(HNODE hnode, UINT where /*NODE_INS_TARGET*/, HNODE what) { return SAPI()->SciterNodeInsert(hnode,where,what); }\n  SCDOM_RESULT SCAPI SciterNodeRemove(HNODE hnode, SBOOL finalize) { return SAPI()->SciterNodeRemove(hnode,finalize); }\n  SCDOM_RESULT SCAPI SciterCreateTextNode(LPCWSTR text, UINT textLength, HNODE* phnode) { return SAPI()->SciterCreateTextNode(text,textLength,phnode); }\n  SCDOM_RESULT SCAPI SciterCreateCommentNode(LPCWSTR text, UINT textLength, HNODE* phnode) { return SAPI()->SciterCreateCommentNode(text,textLength,phnode); }\n\n  //HVM   SCAPI SciterGetVM( HWINDOW hwnd )  { return SAPI()->SciterGetVM(hwnd); }\n\n  UINT SCAPI ValueInit ( VALUE* pval ) { return SAPI()->ValueInit(pval); }\n  UINT SCAPI ValueClear ( VALUE* pval ) { return SAPI()->ValueClear(pval); }\n  UINT SCAPI ValueCompare ( const VALUE* pval1, const VALUE* pval2 ) { return SAPI()->ValueCompare(pval1,pval2); }\n  UINT SCAPI ValueCopy ( VALUE* pdst, const VALUE* psrc ) { return SAPI()->ValueCopy(pdst, psrc); }\n  UINT SCAPI ValueIsolate ( VALUE* pdst ) { return SAPI()->ValueIsolate(pdst); }\n  UINT SCAPI ValueType ( const VALUE* pval, UINT* pType, UINT* pUnits ) { return SAPI()->ValueType(pval,pType,pUnits); }\n  UINT SCAPI ValueStringData ( const VALUE* pval, LPCWSTR* pChars, UINT* pNumChars ) { return SAPI()->ValueStringData(pval,pChars,pNumChars); }\n  UINT SCAPI ValueStringDataSet ( VALUE* pval, LPCWSTR chars, UINT numChars, UINT units ) { return SAPI()->ValueStringDataSet(pval, chars, numChars, units); }\n  UINT SCAPI ValueIntData ( const VALUE* pval, INT* pData ) { return SAPI()->ValueIntData ( pval, pData ); }\n  UINT SCAPI ValueIntDataSet ( VALUE* pval, INT data, UINT type, UINT units ) { return SAPI()->ValueIntDataSet ( pval, data,type,units ); }\n  UINT SCAPI ValueInt64Data ( const VALUE* pval, INT64* pData ) { return SAPI()->ValueInt64Data ( pval,pData ); }\n  UINT SCAPI ValueInt64DataSet ( VALUE* pval, INT64 data, UINT type, UINT units ) { return SAPI()->ValueInt64DataSet ( pval,data,type,units ); }\n  UINT SCAPI ValueFloatData ( const VALUE* pval, FLOAT_VALUE* pData ) { return SAPI()->ValueFloatData ( pval,pData ); }\n  UINT SCAPI ValueFloatDataSet ( VALUE* pval, FLOAT_VALUE data, UINT type, UINT units ) { return SAPI()->ValueFloatDataSet ( pval,data,type,units ); }\n  UINT SCAPI ValueBinaryData ( const VALUE* pval, LPCBYTE* pBytes, UINT* pnBytes ) { return SAPI()->ValueBinaryData ( pval,pBytes,pnBytes ); }\n  UINT SCAPI ValueBinaryDataSet ( VALUE* pval, LPCBYTE pBytes, UINT nBytes, UINT type, UINT units ) { return SAPI()->ValueBinaryDataSet ( pval,pBytes,nBytes,type,units ); }\n  UINT SCAPI ValueElementsCount ( const VALUE* pval, INT* pn) { return SAPI()->ValueElementsCount ( pval,pn); }\n  UINT SCAPI ValueNthElementValue ( const VALUE* pval, INT n, VALUE* pretval) { return SAPI()->ValueNthElementValue ( pval, n, pretval); }\n  UINT SCAPI ValueNthElementValueSet ( VALUE* pval, INT n, const VALUE* pval_to_set) { return SAPI()->ValueNthElementValueSet ( pval,n,pval_to_set); }\n  UINT SCAPI ValueNthElementKey ( const VALUE* pval, INT n, VALUE* pretval) { return SAPI()->ValueNthElementKey ( pval,n,pretval); }\n  UINT SCAPI ValueEnumElements ( const VALUE* pval, KeyValueCallback* penum, LPVOID param) { return SAPI()->ValueEnumElements (pval,penum,param); }\n  UINT SCAPI ValueSetValueToKey ( VALUE* pval, const VALUE* pkey, const VALUE* pval_to_set) { return SAPI()->ValueSetValueToKey ( pval, pkey, pval_to_set); }\n  UINT SCAPI ValueGetValueOfKey ( const VALUE* pval, const VALUE* pkey, VALUE* pretval) { return SAPI()->ValueGetValueOfKey ( pval, pkey,pretval); }\n  UINT SCAPI ValueToString ( VALUE* pval, UINT how ) { return SAPI()->ValueToString ( pval,how ); }\n  UINT SCAPI ValueFromString ( VALUE* pval, LPCWSTR str, UINT strLength, UINT how ) { return SAPI()->ValueFromString ( pval, str,strLength,how ); }\n  UINT SCAPI ValueInvoke ( const VALUE* pval, VALUE* pthis, UINT argc, const VALUE* argv, VALUE* pretval, LPCWSTR url) { return SAPI()->ValueInvoke ( pval, pthis, argc, argv, pretval, url); }\n  UINT SCAPI ValueNativeFunctorSet (VALUE* pval, NATIVE_FUNCTOR_INVOKE*  pinvoke, NATIVE_FUNCTOR_RELEASE* prelease, VOID* tag ) { return SAPI()->ValueNativeFunctorSet ( pval, pinvoke,prelease,tag); }\n  SBOOL SCAPI ValueIsNativeFunctor ( const VALUE* pval) { return SAPI()->ValueIsNativeFunctor (pval); }\n\n HSARCHIVE SCAPI SciterOpenArchive (LPCBYTE archiveData, UINT archiveDataLength) { return SAPI()->SciterOpenArchive (archiveData,archiveDataLength); }\n SBOOL SCAPI SciterGetArchiveItem (HSARCHIVE harc, LPCWSTR path, LPCBYTE* pdata, UINT* pdataLength){ return SAPI()->SciterGetArchiveItem (harc,path,pdata,pdataLength); }\n SBOOL SCAPI SciterCloseArchive (HSARCHIVE harc) { return SAPI()->SciterCloseArchive(harc); }\n\n#if defined(WINDOWS) && !defined(WINDOWLESS)\n  SBOOL SCAPI SciterCreateOnDirectXWindow(HWINDOW hwnd, IUnknown* pSwapChain) { return SAPI()->SciterCreateOnDirectXWindow(hwnd,pSwapChain); }\n  SBOOL SCAPI SciterRenderOnDirectXWindow(HWINDOW hwnd, HELEMENT elementToRenderOrNull, SBOOL frontLayer) { return SAPI()->SciterRenderOnDirectXWindow(hwnd,elementToRenderOrNull,frontLayer); }\n  SBOOL SCAPI SciterRenderOnDirectXTexture(HWINDOW hwnd, HELEMENT elementToRenderOrNull, IUnknown* surface) { return SAPI()->SciterRenderOnDirectXTexture(hwnd,elementToRenderOrNull,surface); }\n#endif\n\n    SBOOL SCAPI SciterProcX(HWINDOW hwnd, SCITER_X_MSG* pMsg) { return SAPI()->SciterProcX(hwnd, pMsg); }\n#ifdef __cplusplus\n  template<class MSG>\n    SBOOL SCAPI SciterProcX(HWINDOW hwnd, const MSG &msg) {\n     static_assert(offsetof(MSG, header) == 0, \"must contain SCITER_X_MSG as first memeber\");\n     static_assert(std::is_same<decltype(MSG::header), SCITER_X_MSG>::value, \"must contain SCITER_X_MSG\");\n     return SAPI()->SciterProcX(hwnd, (SCITER_X_MSG*)(&msg));\n  }\n#endif\n\n  UINT64 SCAPI SciterAtomValue(const char* name) { return SAPI()->SciterAtomValue(name); }\n  UINT64 SCAPI SciterAtomNameCB(UINT64 atomv, LPCSTR_RECEIVER* rcv, LPVOID rcv_param) { return SAPI()->SciterAtomNameCB(atomv, rcv, rcv_param); }\n  SBOOL   SCAPI SciterSetGlobalAsset(som_asset_t* pass) { return SAPI()->SciterSetGlobalAsset(pass); }\n\n  UINT   SCAPI SciterElementUnwrap(const VALUE* pval, HELEMENT* ppElement) { return SAPI()->SciterElementUnwrap(pval, ppElement); }\n  UINT   SCAPI SciterElementWrap(VALUE* pval, HELEMENT pElement) { return SAPI()->SciterElementWrap(pval, pElement); }\n\n  UINT   SCAPI SciterNodeUnwrap(const VALUE* pval, HNODE* ppNode) { return SAPI()->SciterNodeUnwrap(pval, ppNode); }\n  UINT   SCAPI SciterNodeWrap(VALUE* pval, HNODE pNode) { return SAPI()->SciterNodeWrap(pval, pNode); }\n"
        },
        {
          "name": "sciter.go",
          "type": "blob",
          "size": 89.4951171875,
          "content": "// This package provides a Golang bindings of Sciter using cgo.\r\n// Using go sciter you must have the platform specified sciter dynamic library\r\n// downloaded from sciter-sdk,\r\n// the library itself is rather small (under 5MB, less than 2MB when upxed) .\r\npackage sciter\r\n\r\n/*\r\n#cgo CFLAGS: -g -std=c11 -Iinclude -DPLAIN_API_ONLY -D_BSD_SOURCE -D_DEFAULT_SOURCE\r\n#cgo linux LDFLAGS: -ldl\r\n#cgo linux pkg-config: gtk+-3.0\r\n\r\n#include \"sciter-x.h\"\r\n\r\nextern SBOOL SC_CALLBACK SciterElementCallback_cgo(HELEMENT he, LPVOID param);\r\nextern VOID SC_CALLBACK LPCSTR_RECEIVER_cgo( LPCSTR str, UINT str_length, LPVOID param );\r\nextern VOID SC_CALLBACK LPCWSTR_RECEIVER_cgo( LPCWSTR str, UINT str_length, LPVOID param );\r\nextern VOID SC_CALLBACK LPCBYTE_RECEIVER_cgo( LPCBYTE bytes, UINT num_bytes, LPVOID param );\r\nextern SBOOL SC_CALLBACK ElementEventProc_cgo(LPVOID tag, HELEMENT he, UINT evtg, LPVOID prms );\r\nextern UINT SC_CALLBACK SciterHostCallback_cgo( LPSCITER_CALLBACK_NOTIFICATION pns, LPVOID callbackParam );\r\n// native functor\r\nextern VOID NATIVE_FUNCTOR_INVOKE_cgo( VOID* tag, UINT argc, const VALUE* argv, VALUE* retval);\r\nextern VOID NATIVE_FUNCTOR_RELEASE_cgo( VOID* tag );\r\n// cmp\r\nextern INT SC_CALLBACK ELEMENT_COMPARATOR_cgo( HELEMENT he1, HELEMENT he2, LPVOID param );\r\n// ValueEnumElements\r\nextern SBOOL SC_CALLBACK KeyValueCallback_cgo(LPVOID param, const VALUE* pkey, const VALUE* pval );\r\n\r\nextern const char * SCITER_DLL_PATH;\r\n\r\nextern HSARCHIVE SCAPI SciterOpenArchive (LPCBYTE archiveData, UINT archiveDataLength);\r\n\r\nextern SBOOL SCAPI SciterGetArchiveItem (HSARCHIVE harc, LPCWSTR path, LPCBYTE* pdata, UINT* pdataLength);\r\n\r\nextern SBOOL SCAPI SciterCloseArchive (HSARCHIVE harc);\r\n\r\n*/\r\nimport \"C\"\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"runtime\"\r\n\t\"strings\"\r\n\t\"unsafe\"\r\n)\r\n\r\ntype Sciter struct {\r\n\thwnd C.HWINDOW\r\n\t// because it live with the PROGRAM\r\n\tcallbacks map[*CallbackHandler]struct{}\r\n\t// map scripting function name to NativeFunctor\r\n\t*eventMapper\r\n\t// sciter archive\r\n\thar C.HSARCHIVE\r\n}\r\n\r\nvar (\r\n\tBAD_HWINDOW C.HWINDOW = nil\r\n)\r\n\r\nfunc Wrap(hwnd C.HWINDOW) *Sciter {\r\n\ts := &Sciter{\r\n\t\thwnd:      hwnd,\r\n\t\tcallbacks: make(map[*CallbackHandler]struct{}),\r\n\t}\r\n\treturn s\r\n}\r\n\r\nfunc ClassName() string {\r\n\tcname := (*uint16)(unsafe.Pointer(C.SciterClassName()))\r\n\treturn Utf16ToString(cname)\r\n}\r\n\r\nfunc Version(major bool) uint {\r\n\tvar v C.UINT\r\n\tif major {\r\n\t\tv = C.SciterVersion(C.SBOOL(1))\r\n\t} else {\r\n\t\tv = C.SciterVersion(C.SBOOL(0))\r\n\t}\r\n\treturn uint(v)\r\n}\r\n\r\nfunc VersionAsString() string {\r\n\tmajor := Version(true)\r\n\tminor := Version(false)\r\n\treturn fmt.Sprintf(\"0x%x %x\", major, minor)\r\n}\r\n\r\nfunc (s *Sciter) GetHwnd() C.HWINDOW {\r\n\treturn s.hwnd\r\n}\r\n\r\nfunc SetDLL(dir string) {\r\n\tC.SCITER_DLL_PATH = C.CString(dir)\r\n}\r\n\r\n//This function is used in response to SCN_LOAD_DATA request.\r\n//\r\n//  \\param[in] hwnd \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] uri \\b LPCWSTR, URI of the data requested by Sciter.\r\n//  \\param[in] data \\b LPBYTE, pointer to data buffer.\r\n//  \\param[in] dataLength \\b UINT, length of the data in bytes.\r\n//  \\return \\b BOOL, TRUE if Sciter accepts the data or \\c FALSE if error occured\r\n//  (for example this function was called outside of #SCN_LOAD_DATA request).\r\n//\r\n//  \\warning If used, call of this function MUST be done ONLY while handling\r\n//  SCN_LOAD_DATA request and in the same thread. For asynchronous resource loading\r\n//  use SciterDataReadyAsync\r\nfunc (s *Sciter) DataReady(uri string, data []byte) bool {\r\n\tvar pData C.LPCBYTE\r\n\tif len(data) > 0 {\r\n\t\tpData = (C.LPCBYTE)(unsafe.Pointer(&data[0]))\r\n\t}\r\n\tret := C.SciterDataReady(s.hwnd, StringToWcharPtr(uri), pData, C.UINT(len(data)))\r\n\tif ret == 0 {\r\n\t\treturn false\r\n\t}\r\n\t// mark the data to prevent gc\r\n\tloadedUri[uri] = data\r\n\treturn true\r\n}\r\n\r\nvar (\r\n\tloadedUri = map[string][]byte{}\r\n)\r\n\r\n//SciterDataReadyAsync (HWINDOW hwnd,LPCWSTR uri, LPCBYTE data, UINT dataLength, LPVOID requestId) ;//{ return SAPI()->SciterDataReadyAsync (hwnd,uri, data, dataLength, requestId); }\r\n\r\n//Use this function outside of SCN_LOAD_DATA request. This function is needed when you\r\n//  you have your own http client implemented in your application.\r\n//\r\n//  \\param[in] hwnd \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] uri \\b LPCWSTR, URI of the data requested by Sciter.\r\n//  \\param[in] data \\b LPBYTE, pointer to data buffer.\r\n//  \\param[in] requestId \\b LPVOID, SCN_LOAD_DATA requestId.\r\n//  \\return \\b BOOL, TRUE if Sciter accepts the data or \\c FALSE if error occured\r\nfunc (s *Sciter) DataReadyAsync(uri string, data []byte, requestId C.HREQUEST) bool {\r\n\t// args\r\n\tvar pData C.LPCBYTE\r\n\tif len(data) > 0 {\r\n\t\tpData = (C.LPCBYTE)(unsafe.Pointer(&data[0]))\r\n\t}\r\n\tcuri := StringToWcharPtr(uri)\r\n\tcdataLength := C.UINT(len(data))\r\n\tcrequestId := C.LPVOID(requestId)\r\n\r\n\t// cgo call\r\n\tret := C.SciterDataReadyAsync(s.hwnd, curi, pData, cdataLength, crequestId)\r\n\tif ret == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL SciterLoadFile (HWINDOW hWndSciter, LPCWSTR filename) ;//{ return SAPI()->SciterLoadFile (hWndSciter,filename); }\r\n\r\nfunc (s *Sciter) LoadFile(filename string) error {\r\n\tret := C.SciterLoadFile(s.hwnd, StringToWcharPtr(filename))\r\n\tif ret == 0 {\r\n\t\treturn fmt.Errorf(\"LoadFile with: %s failed\", filename)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// BOOL SciterLoadHtml (HWINDOW hWndSciter, LPCBYTE html, UINT htmlSize, LPCWSTR baseUrl) ;//{ return SAPI()->SciterLoadHtml (hWndSciter,html,htmlSize,baseUrl); }\r\n\r\n//Load HTML from in memory buffer with base.\r\n//\r\n//  \\param[in] hWndSciter \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] html \\b LPCBYTE, Address of HTML to load.\r\n//  \\param[in] htmlSize \\b UINT, Length of the array pointed by html parameter.\r\n//  \\param[in] baseUrl \\b LPCWSTR, base URL. All relative links will be resolved against\r\n//                                 this URL.\r\n//  \\return \\b BOOL, \\c TRUE if the text was parsed and loaded successfully, FALSE otherwise.\r\nfunc (s *Sciter) LoadHtml(html, baseUrl string) error {\r\n\t// args\r\n\tchtml := (C.LPCBYTE)(unsafe.Pointer(StringToBytePtr(html)))\r\n\tcsize := C.UINT(len(html))\r\n\tcbaseUrl := StringToWcharPtr(baseUrl)\r\n\t// cgo call\r\n\tret := C.SciterLoadHtml(s.hwnd, chtml, csize, cbaseUrl)\r\n\tif ret == 0 {\r\n\t\treturn fmt.Errorf(\"LoadHtml with: %s failed\", string(html))\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// typedef UINT SC_CALLBACK SciterHostCallback( LPSCITER_CALLBACK_NOTIFICATION pns, LPVOID callbackParam );\r\n\r\n//export goSciterHostCallback\r\nfunc goSciterHostCallback(ph unsafe.Pointer, callbackParam unsafe.Pointer) int {\r\n\tphdr := (*SciterCallbackNotification)(ph)\r\n\thandler := globalCallbackHandlers[int(uintptr(callbackParam))]\r\n\tswitch phdr.Code {\r\n\tcase SC_LOAD_DATA:\r\n\t\tif handler.OnLoadData != nil {\r\n\t\t\treturn handler.OnLoadData((*ScnLoadData)(unsafe.Pointer(phdr)))\r\n\t\t}\r\n\tcase SC_DATA_LOADED:\r\n\t\tif handler.OnDataLoaded != nil {\r\n\t\t\treturn handler.OnDataLoaded((*ScnDataLoaded)(unsafe.Pointer(phdr)))\r\n\t\t}\r\n\tcase SC_ATTACH_BEHAVIOR:\r\n\t\tparams := (*ScnAttachBehavior)(unsafe.Pointer(phdr))\r\n\t\tkey := params.BehaviorName()\r\n\t\tif behavior, exists := handler.Behaviors[key]; exists {\r\n\t\t\t// Increment the reference count for this behavior\r\n\t\t\tif refCount, exists := behaviors[behavior]; exists {\r\n\t\t\t\tbehaviors[behavior] = refCount + 1\r\n\t\t\t} else {\r\n\t\t\t\tbehaviors[behavior] = 1\r\n\t\t\t}\r\n\t\t\tel := WrapElement(params.Element())\r\n\t\t\tel.attachBehavior(behavior)\r\n\t\t} else {\r\n\t\t\tlog.Printf(\"No such behavior <%s> found\", key)\r\n\t\t}\r\n\tcase SC_ENGINE_DESTROYED:\r\n\t\tif handler.OnEngineDestroyed != nil {\r\n\t\t\treturn handler.OnEngineDestroyed()\r\n\t\t}\r\n\tcase SC_POSTED_NOTIFICATION:\r\n\t\tif handler.OnPostedNotification != nil {\r\n\t\t\treturn handler.OnPostedNotification((*ScnPostedNotification)(unsafe.Pointer(phdr)))\r\n\t\t}\r\n\tcase SC_GRAPHICS_CRITICAL_FAILURE:\r\n\t\tif handler.OnGraphicsCriticalFailure != nil {\r\n\t\t\treturn handler.OnGraphicsCriticalFailure()\r\n\t\t}\r\n\tcase SC_KEYBOARD_REQUEST:\r\n\t\tif handler.OnKeyboardRequest != nil {\r\n\t\t\treturn handler.OnKeyboardRequest((*ScnKeyboardRequest)(unsafe.Pointer(phdr)))\r\n\t\t}\r\n\tcase SC_INVALIDATE_RECT:\r\n\t\tif handler.OnInvalidateRect != nil {\r\n\t\t\treturn handler.OnInvalidateRect((*ScnInvalidateRect)(unsafe.Pointer(phdr)))\r\n\t\t}\r\n\t}\r\n\treturn 0\r\n}\r\n\r\nvar (\r\n\tsciterhostcallback     = C.LPSciterHostCallback(unsafe.Pointer(C.SciterHostCallback_cgo))\r\n\tglobalCallbackHandlers = make([]*CallbackHandler, 0)\r\n)\r\n\r\n// VOID SciterSetCallback (HWINDOW hWndSciter, LPSciterHostCallback cb, LPVOID cbParam)\r\n\r\n//Set \\link #SCITER_NOTIFY() notification callback function \\endlink.\r\n//\r\n//  \\param[in] hWndSciter \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] cb \\b SCITER_NOTIFY*, \\link #SCITER_NOTIFY() callback function \\endlink.\r\n//  \\param[in] cbParam \\b LPVOID, parameter that will be passed to \\link #SCITER_NOTIFY() callback function \\endlink as vParam paramter.\r\nfunc (s *Sciter) SetCallback(handler *CallbackHandler) {\r\n\tif _, ok := s.callbacks[handler]; ok {\r\n\t\treturn\r\n\t}\r\n\ts.callbacks[handler] = struct{}{}\r\n\t// args\r\n\tglobalCallbackHandlers = append(globalCallbackHandlers, handler)\r\n\tidx := len(globalCallbackHandlers) - 1\r\n\tcparam := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\t// cgo call\r\n\tC.SciterSetCallback(s.hwnd, sciterhostcallback, cparam)\r\n}\r\n\r\n// BOOL SciterSetMasterCSS (LPCBYTE utf8, UINT numBytes)\r\n\r\n//Set Master style sheet.\r\n//\r\n//  \\param[in] utf8 \\b LPCBYTE, start of CSS buffer.\r\n//  \\param[in] numBytes \\b UINT, number of bytes in utf8.\r\nfunc SetMasterCSS(data string) (ok bool) {\r\n\t// args\r\n\tcutf8 := C.LPCBYTE(unsafe.Pointer(StringToBytePtr(data)))\r\n\tclen := C.UINT(len(data))\r\n\t// cgo call\r\n\tr := C.SciterSetMasterCSS(cutf8, clen)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL SciterAppendMasterCSS (LPCBYTE utf8, UINT numBytes)\r\n\r\n//Append Master style sheet.\r\n//\r\n//  \\param[in] utf8 \\b LPCBYTE, start of CSS buffer.\r\n//  \\param[in] numBytes \\b UINT, number of bytes in utf8.\r\nfunc AppendMasterCSS(data string) (ok bool) {\r\n\t// args\r\n\tcutf8 := C.LPCBYTE(unsafe.Pointer(StringToBytePtr(data)))\r\n\tclen := C.UINT(len(data))\r\n\t// cgo call\r\n\tr := C.SciterAppendMasterCSS(cutf8, clen)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL SciterSetCSS (HWINDOW hWndSciter, LPCBYTE utf8, UINT numBytes, LPCWSTR baseUrl, LPCWSTR mediaType)\r\n\r\n//Set (reset) style sheet of current document.\r\n//Will reset styles for all elements according to given CSS (utf8)\r\n//\r\n//  \\param[in] hWndSciter \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] utf8 \\b LPCBYTE, start of CSS buffer.\r\n//  \\param[in] numBytes \\b UINT, number of bytes in utf8.\r\nfunc (s *Sciter) SetCSS(css, baseUrl, mediaType string) (ok bool) {\r\n\t// args\r\n\tccss := C.LPCBYTE(unsafe.Pointer(StringToBytePtr(css)))\r\n\tclen := C.UINT(len(css))\r\n\tcbaseUrl := StringToWcharPtr(baseUrl)\r\n\tcmediaType := StringToWcharPtr(mediaType)\r\n\t// cgo call\r\n\tr := C.SciterSetCSS(s.hwnd, ccss, clen, cbaseUrl, cmediaType)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL SciterSetMediaType (HWINDOW hWndSciter, LPCWSTR mediaType)\r\n\r\n//Set media type of this sciter instance.\r\n//\r\n//  \\param[in] hWndSciter \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] mediaType \\b LPCWSTR, media type name.\r\n//\r\n//  For example media type can be \"handheld\", \"projection\", \"screen\", \"screen-hires\", etc.\r\n//  By default sciter window has \"screen\" media type.\r\n//\r\n//  Media type name is used while loading and parsing style sheets in the engine so\r\n//  you should call this function *before* loading document in it.\r\nfunc (s *Sciter) SetMediaType(mediaType string) (ok bool) {\r\n\t// args\r\n\tcmediaType := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(mediaType)))\r\n\t// cgo call\r\n\tr := C.SciterSetMediaType(s.hwnd, cmediaType)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL SciterSetMediaVars (HWINDOW hWndSciter, const SCITER_VALUE *mediaVars)\r\n\r\n// UINT SciterGetMinWidth (HWINDOW hWndSciter)\r\nfunc (s *Sciter) MinWidth() int {\r\n\tr := C.SciterGetMinWidth(s.hwnd)\r\n\treturn int(r)\r\n}\r\n\r\n// UINT SciterGetMinHeight (HWINDOW hWndSciter, UINT width)\r\nfunc (s *Sciter) MinHeight(width int) int {\r\n\t// args\r\n\tcwidth := C.UINT(width)\r\n\t// cgo call\r\n\tr := C.SciterGetMinHeight(s.hwnd, cwidth)\r\n\treturn int(r)\r\n}\r\n\r\n// BOOL SciterCall (HWINDOW hWnd, LPCSTR functionName, UINT argc, const SCITER_VALUE* argv, SCITER_VALUE* retval)\r\n\r\n// To call global function defined in script using its full name (may include name of namespaces where it resides)\r\nfunc (s *Sciter) Call(functionName string, args ...*Value) (retval *Value, err error) {\r\n\tretval = NewValue()\r\n\targc := len(args)\r\n\targv := make([]Value, argc)\r\n\tfor i := 0; i < argc; i++ {\r\n\t\targv[i].Copy(args[i]) // Make copy that is not garbage collected\r\n\t\tdefer argv[i].finalize()\r\n\t}\r\n\t// args\r\n\tfuncName := C.CString(functionName)\r\n\tdefer C.free(unsafe.Pointer(funcName))\r\n\tcfn := C.LPCSTR(unsafe.Pointer(funcName))\r\n\tcargc := C.UINT(argc)\r\n\tvar cargv *C.SCITER_VALUE\r\n\tif len(argv) > 0 {\r\n\t\tcargv = (*C.SCITER_VALUE)(unsafe.Pointer(&argv[0]))\r\n\t}\r\n\tcretval := (*C.SCITER_VALUE)(unsafe.Pointer(retval))\r\n\t// cgo call\r\n\tr := C.SciterCall(s.hwnd, cfn, cargc, cargv, cretval)\r\n\tif r == 0 {\r\n\t\terr = fmt.Errorf(\"SciterCall failed with function: %s\", functionName)\r\n\t}\r\n\treturn\r\n}\r\n\r\n// BOOL SciterEval ( HWINDOW hwnd, LPCWSTR script, UINT scriptLength, SCITER_VALUE* pretval)\r\n\r\n// To evaluate arbitrary script in context of current document loaded into the window\r\nfunc (s *Sciter) Eval(script string) (retval *Value, ok bool) {\r\n\tretval = NewValue()\r\n\t// args\r\n\tu16, err := Utf16FromString(script)\r\n\tif err != nil {\r\n\t\treturn nil, false\r\n\t}\r\n\tcscriptLength := C.UINT(len(u16) - 1)\r\n\tcscript := C.LPCWSTR(unsafe.Pointer(&u16[0]))\r\n\tcretval := (*C.SCITER_VALUE)(unsafe.Pointer(retval))\r\n\t// cgo call\r\n\tr := C.SciterEval(s.hwnd, cscript, cscriptLength, cretval)\r\n\tif r == 0 {\r\n\t\tok = false\r\n\t} else {\r\n\t\tok = true\r\n\t}\r\n\treturn\r\n}\r\n\r\n// VOID SciterUpdateWindow(HWINDOW hwnd)\r\nfunc (s *Sciter) UpdateWindow() {\r\n\tC.SciterUpdateWindow(s.hwnd)\r\n}\r\n\r\n// #ifdef WINDOWS\r\n// BOOL     SciterTranslateMessage (MSG* lpMsg) ;//{ return SAPI()->SciterTranslateMessage (lpMsg); }\r\n// #endif\r\n\r\n// BOOL     SciterSetOption (HWINDOW hWnd, UINT option, UINT_PTR value )\r\nfunc (s *Sciter) SetOption(option Sciter_RT_OPTIONS, value uint) (ok bool) {\r\n\t// args\r\n\tcoption := C.UINT(option)\r\n\tcvalue := C.UINT_PTR(value)\r\n\t// cgo call\r\n\tr := C.SciterSetOption(s.hwnd, coption, cvalue)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// BOOL     SciterSetOption (NULL, UINT option, UINT_PTR value )\r\nfunc SetOption(option Sciter_RT_OPTIONS, value uint) (ok bool) {\r\n\tcoption := C.UINT(option)\r\n\tcvalue := C.UINT_PTR(value)\r\n\thwnd := BAD_HWINDOW\r\n\tr := C.SciterSetOption(hwnd, coption, cvalue)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// VOID     SciterGetPPI (HWINDOW hWndSciter, UINT* px, UINT* py) ;// { SAPI()->SciterGetPPI (hWndSciter,px,py); }\r\n// BOOL     SciterGetViewExpando ( HWINDOW hwnd, VALUE* pval ) ;//{ return SAPI()->SciterGetViewExpando ( hwnd, pval ); }\r\n// #ifdef WINDOWS\r\n// BOOL     SciterRenderD2D (HWINDOW hWndSciter, ID2D1RenderTarget* prt) ;//{ return SAPI()->SciterRenderD2D (hWndSciter,prt); }\r\n// BOOL     SciterD2DFactory (ID2D1Factory ** ppf) ;//{ return SAPI()->SciterD2DFactory (ppf); }\r\n// BOOL     SciterDWFactory (IDWriteFactory ** ppf) ;//{ return SAPI()->SciterDWFactory (ppf); }\r\n// #endif\r\n// BOOL     SciterGraphicsCaps (LPUINT pcaps) ;//{ return SAPI()->SciterGraphicsCaps (pcaps); }\r\n\r\n// BOOL     SciterSetHomeURL (HWINDOW hWndSciter, LPCWSTR baseUrl)\r\n\r\n// Set sciter home url.\r\n//   home url is used for resolving sciter: urls\r\n//   If you will set it like SciterSetHomeURL(hwnd,\"http://sciter.com/modules/\")\r\n//   then <script src=\"sciter:lib/root-extender.tis\"> will load\r\n//   root-extender.tis from http://sciter.com/modules/lib/root-extender.tis\r\n//\r\n//  \\param[in] hWndSciter \\b HWINDOW, Sciter window handle.\r\n//  \\param[in] baseUrl \\b LPCWSTR, URL of sciter home.\r\nfunc (s *Sciter) SetHomeURL(baseUrl string) (ok bool) {\r\n\t// args\r\n\tcbaseUrl := C.LPCWSTR(unsafe.Pointer(StringToWcharPtr(baseUrl)))\r\n\t// cgo call\r\n\tr := C.SciterSetHomeURL(s.hwnd, cbaseUrl)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// Open data blob of the provided compressed Sciter archive.\r\nfunc (s *Sciter) OpenArchive(data []byte) {\r\n\ts.har = C.SciterOpenArchive((*C.BYTE)(&data[0]), C.UINT(len(data)))\r\n}\r\n\r\n// Get an archive item referenced by \\c uri.\r\n//\r\n// Usually it is passed to \\c Sciter.DataReady().\r\nfunc (s *Sciter) GetArchiveItem(uri string) []byte {\r\n\tvar data C.LPCBYTE\r\n\tvar length C.UINT\r\n\tcdata := (*C.LPCBYTE)(&data)\r\n\tr := C.SciterGetArchiveItem(s.har, StringToWcharPtr(uri), cdata, &length)\r\n\tif r == 0 {\r\n\t\treturn nil\r\n\t}\r\n\tret := ByteCPtrToBytes(data, length)\r\n\treturn ret\r\n}\r\n\r\n// Close the archive.\r\nfunc (s *Sciter) CloseArchive() {\r\n\tC.SciterCloseArchive(s.har)\r\n\ts.har = C.HSARCHIVE(nil)\r\n}\r\n\r\n// Register `this://app/` URLs to be loaded from the given Sciter archive.\r\n//\r\n// Pack resources using `packfolder` tool:\r\n//\r\n//   `$ packfolder res_folder res_packed.go -v resource_name -go`\r\n//\r\n// Usage:\r\n//\r\n//```\r\n//   win.SetResourceArchive(resource_name)\r\n//   win.LoadFile(\"this://app//index.htm\")\r\n//```\r\nfunc (s *Sciter) SetResourceArchive(data []byte) {\r\n\r\n\t// register `this://app/` schema\r\n\tcallback := &CallbackHandler{\r\n\t\tOnLoadData: func(params *ScnLoadData) int {\r\n\t\t\tif strings.HasPrefix(params.Uri(), \"this://app/\") {\r\n\t\t\t\t// load resource starting with our schema\r\n\t\t\t\turl := params.Uri()[11:]\r\n\t\t\t\tfileData := s.GetArchiveItem(url)\r\n\t\t\t\tif fileData != nil {\r\n\t\t\t\t\t// use loaded resource\r\n\t\t\t\t\ts.DataReady(url, fileData)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// failed to load\r\n\t\t\t\t\tlog.Println(\"error: failed to load \" + params.Uri())\r\n\t\t\t\t\t//  but fallback to Sciter anyway\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn LOAD_OK\r\n\t\t},\r\n\t}\r\n\r\n\ts.OpenArchive(data)\r\n\ts.SetCallback(callback)\r\n}\r\n\r\n// #if defined(OSX)\r\n// HWINDOW  SciterCreateNSView ( LPRECT frame ) ;//{ return SAPI()->SciterCreateNSView ( frame ); }\r\n// #endif\r\n// HWINDOW  SciterCreateWindow ( UINT creationFlags,LPRECT frame, SciterWindowDelegate* delegate, LPVOID delegateParam, HWINDOW parent);\r\n\r\n// #if defined(OSX)\r\n//    HWINDOW SCAPI  SciterCreateNSView( LPRECT frame ); // returns NSView*\r\n//   typedef LPVOID SciterWindowDelegate; // Obj-C id, NSWindowDelegate and NSResponder\r\n// #elif defined(WINDOWS)\r\n//   typedef LRESULT SC_CALLBACK SciterWindowDelegate(HWINDOW hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LPVOID pParam, BOOL* handled);\r\n// #elif defined(LINUX)\r\n//   typedef LPVOID SciterWindowDelegate;\r\n// #endif\r\n\r\n// type HELEMENT C.HELEMENT\r\n\r\nvar (\r\n\tBAD_HELEMENT = C.HELEMENT(unsafe.Pointer(uintptr(0)))\r\n)\r\n\r\nvar (\r\n\telementHandlerMap = map[*Element]map[*EventHandler]struct{}{}\r\n)\r\n\r\n// Represents a single DOM element, owns and manages a Handle\r\ntype Element struct {\r\n\thandle C.HELEMENT\r\n\terr    error\r\n\t// defaultHandler *EventHandler\r\n\t*eventMapper\r\n}\r\n\r\n// Wrap C.HELEMENT to a go side *Element, doing Sciter_UseElement/Sciter_UnuseElement automatically\r\nfunc WrapElement(he C.HELEMENT) *Element {\r\n\te := &Element{\r\n\t\thandle: he,\r\n\t}\r\n\te.use()\r\n\truntime.SetFinalizer(e, (*Element).finalize)\r\n\treturn e\r\n}\r\n\r\n// SCDOM_RESULT  Sciter_UseElement(HELEMENT he) ;//{ return SAPI()->Sciter_UseElement(he); }\r\nfunc (e *Element) use() error {\r\n\tr := C.Sciter_UseElement(e.handle)\r\n\treturn wrapDomResult(r, \"Sciter_UseElement\")\r\n}\r\n\r\n// SCDOM_RESULT  Sciter_UnuseElement(HELEMENT he) ;//{ return SAPI()->Sciter_UnuseElement(he); }\r\n\r\n//Marks DOM object as unused (a.k.a. Release).\r\n//\r\n// UnUse would be called automatically when released by Go Runtime\r\n// for *Element created by WrapElement(...)\r\n//\r\n//  Get handle of every element's child element.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//  Application should call this function when it does not need element's\r\n//  handle anymore.\r\n//  \\sa #Sciter_UseElement()\r\nfunc (e *Element) unUse() error {\r\n\tr := C.Sciter_UnuseElement(e.handle)\r\n\treturn wrapDomResult(r, \"Sciter_UnuseElement\")\r\n}\r\n\r\n// finalize() only happens when *Element is no longer used\r\n// but the existence of elementHandlerMap makes that\r\n// elements with EventHandler attached would not be gc collected\r\nfunc (e *Element) finalize() {\r\n\t// Detach handlers\r\n\t// log.Printf(\"finalizing el 0x%x\", e)\r\n\t// only detach when element does have handlers\r\n\tif handlersmap, ok := elementHandlerMap[e]; ok {\r\n\t\tfor handler, _ := range handlersmap {\r\n\t\t\te.DetachEventHandler(handler)\r\n\t\t}\r\n\t}\r\n\t// Release the underlying sciter handle\r\n\te.unUse()\r\n\te.handle = BAD_HELEMENT\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetRootElement(HWINDOW hwnd, HELEMENT *phe) ;//{ return SAPI()->SciterGetRootElement(hwnd, phe); }\r\n\r\n//Get root DOM element of HTML document.\r\n//   \\param[in] hwnd \\b HWINDOW, Sciter window for which you need to get root\r\n//   element\r\n//   \\param[out ] phe \\b #HELEMENT*, variable to receive root element\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   Root DOM object is always a 'HTML' element of the document.\r\nfunc (s *Sciter) GetRootElement() (*Element, error) {\r\n\tvar he C.HELEMENT\r\n\tr := C.SciterGetRootElement(s.hwnd, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterGetRootElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetFocusElement(HWINDOW hwnd, HELEMENT *phe) ;//{ return SAPI()->SciterGetFocusElement(hwnd, phe); }\r\n\r\n//Get focused DOM element of HTML document.\r\n//   \\param[in] hwnd \\b HWINDOW, Sciter window for which you need to get focus\r\n//   element\r\n//   \\param[out ] phe \\b #HELEMENT*, variable to receive focus element\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   phe can have null value (0).\r\n//\r\n//   COMMENT: To set focus on element use SciterSetElementState(STATE_FOCUS,0)\r\nfunc (s *Sciter) GetFocusElement() (*Element, error) {\r\n\tvar he C.HELEMENT\r\n\tr := C.SciterGetFocusElement(s.hwnd, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterGetFocusElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterFindElement(HWINDOW hwnd, POINT pt, HELEMENT* phe) ;//{ return SAPI()->SciterFindElement(hwnd,pt,phe); }\r\n\r\n// Find DOM element by coordinate.\r\n//   \\param[in] hwnd \\b HWINDOW, Sciter window for which you need to find\r\n//   elementz\r\n//   \\param[in] pt \\b POINT, coordinates, window client area relative.\r\n//   \\param[out ] phe \\b #HELEMENT*, variable to receive found element handle.\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   If element was not found then *phe will be set to zero.\r\nfunc (s *Sciter) FindElement(pt Point) (*Element, error) {\r\n\tvar he C.HELEMENT\r\n\tcpt := *(*C.POINT)(unsafe.Pointer(&pt))\r\n\tr := C.SciterFindElement(s.hwnd, cpt, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterFindElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetChildrenCount(HELEMENT he, UINT* count) ;//{ return SAPI()->SciterGetChildrenCount(he, count); }\r\n\r\n// Get number of child elements.\r\n//   \\param[in] he \\b #HELEMENT, element which child elements you need to count\r\n//   \\param[out] count \\b UINT*, variable to receive number of child elements\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   \\par Example:\r\n//   for paragraph defined as\r\n//   \\verbatim <p>Hello <b>wonderfull</b> world!</p> \\endverbatim\r\n//   count will be set to 1 as the paragraph has only one sub element:\r\n//   \\verbatim <b>wonderfull</b> \\endverbatim\r\nfunc (e *Element) ChildrenCount() (int, error) {\r\n\tvar count C.UINT\r\n\tr := C.SciterGetChildrenCount(e.handle, &count)\r\n\treturn int(count), wrapDomResult(r, \"SciterGetChildrenCount\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetNthChild(HELEMENT he, UINT n, HELEMENT* phe) ;//{ return SAPI()->SciterGetNthChild(he,n,phe); }\r\n\r\n// Get handle of every element's child element.\r\n//   \\param[in] he \\b #HELEMENT\r\n//   \\param[in] n \\b UINT, number of the child element\r\n//   \\param[out] phe \\b #HELEMENT*, variable to receive handle of the child\r\n//   element\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   \\par Example:\r\n//   for paragraph defined as\r\n//   \\verbatim <p>Hello <b>wonderfull</b> world!</p> \\endverbatim\r\n//   *phe will be equal to handle of &lt;b&gt; element:\r\n//   \\verbatim <b>wonderfull</b> \\endverbatim\r\nfunc (e *Element) NthChild(n int) (*Element, error) {\r\n\tvar he C.HELEMENT\r\n\tr := C.SciterGetNthChild(e.handle, C.UINT(n), &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterGetNthChild\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetParentElement(HELEMENT he, HELEMENT* p_parent_he) ;//{ return SAPI()->SciterGetParentElement(he,p_parent_he); }\r\n\r\n// Get parent element.\r\nfunc (e *Element) ParentElement() (*Element, error) {\r\n\tvar he C.HELEMENT\r\n\tr := C.SciterGetParentElement(e.handle, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterGetParentElement\")\r\n}\r\n\r\n// inline VOID SC_CALLBACK _LPCBYTE2ASTRING( LPCBYTE bytes, UINT num_bytes, LPVOID param )\r\n// {\r\n//     sciter::astring* s = (sciter::astring*)param;\r\n//     *s = sciter::astring((const char*)bytes,num_bytes);\r\n// }\r\n// var _LPCSTR_RECEIVER = syscall.NewCallback(func(bs *byte, n uint, param uintptr) int {\r\n//     s := (*string)(unsafe.Pointer(param))\r\n//     *s = bytePtrToString(bs)\r\n//     return 0\r\n// })\r\n\r\n// inline VOID SC_CALLBACK _LPCWSTR2STRING( LPCWSTR str, UINT str_length, LPVOID param )\r\n// {\r\n//     sciter::string* s = (sciter::string*)param;\r\n//     *s = sciter::string(str,str_length);\r\n// }\r\n// var _LPCWSTR_RECEIVER = syscall.NewCallback(func(bs *uint16, n uint, param uintptr) int {\r\n//     s := (*string)(unsafe.Pointer(param))\r\n//     *s = utf16ToString(bs)\r\n//     return 0\r\n// })\r\n\r\n// typedef VOID SC_CALLBACK LPCBYTE_RECEIVER( LPCBYTE bytes, UINT num_bytes, LPVOID param );\r\n\r\n//export goLPCBYTE_RECEIVER\r\nfunc goLPCBYTE_RECEIVER(bs *byte, n uint, param unsafe.Pointer) int {\r\n\tr := BytePtrToBytes(bs, n)\r\n\t*(*[]byte)(param) = r\r\n\treturn 0\r\n}\r\n\r\n// typedef VOID SC_CALLBACK LPCWSTR_RECEIVER( LPCWSTR str, UINT str_length, LPVOID param );\r\n\r\n//export goLPCWSTR_RECEIVER\r\nfunc goLPCWSTR_RECEIVER(bs *uint16, n uint, param unsafe.Pointer) int {\r\n\ts := (*string)(param)\r\n\t*s = Utf16ToString(bs)\r\n\treturn 0\r\n}\r\n\r\n// typedef VOID SC_CALLBACK LPCSTR_RECEIVER( LPCSTR str, UINT str_length, LPVOID param );\r\n\r\n//export goLPCSTR_RECEIVER\r\nfunc goLPCSTR_RECEIVER(bs C.LPCSTR, n uint, param unsafe.Pointer) int {\r\n\ts := (*string)(param)\r\n\t*s = C.GoString(bs)\r\n\treturn 0\r\n}\r\n\r\nvar (\r\n\tlpcbyte_receiver = (*C.LPCBYTE_RECEIVER)(unsafe.Pointer(C.LPCBYTE_RECEIVER_cgo))\r\n\tlpcwstr_receiver = (*C.LPCWSTR_RECEIVER)(unsafe.Pointer(C.LPCWSTR_RECEIVER_cgo))\r\n\tlpcstr_receiver  = (*C.LPCSTR_RECEIVER)(unsafe.Pointer(C.LPCSTR_RECEIVER_cgo))\r\n)\r\n\r\n// SCDOM_RESULT  SciterGetElementHtmlCB(HELEMENT he, BOOL outer, LPCBYTE_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterGetElementHtmlCB( he, outer, rcv, rcv_param); }\r\n\r\n//Get html representation of the element.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] outer \\b BOOL, if TRUE will retunr outer HTML otherwise inner.\r\n//  \\param[in] rcv \\b pointer to function receiving UTF8 encoded HTML.\r\n//  \\param[in] rcv_param \\b parameter that passed to rcv as it is.\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) Html(outer bool) (string, error) {\r\n\tvar bs []byte\r\n\t// args\r\n\tcouter := C.SBOOL(C.FALSE)\r\n\tif outer {\r\n\t\tcouter = C.SBOOL(C.TRUE)\r\n\t}\r\n\tcparam := C.LPVOID(unsafe.Pointer(&bs))\r\n\t// cgo call\r\n\tr := C.SciterGetElementHtmlCB(e.handle, couter, lpcbyte_receiver, cparam)\r\n\tstr := string(bs)\r\n\treturn str, wrapDomResult(r, \"SciterGetElementHtmlCB\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementTextCB(HELEMENT he, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param)\r\n\r\n// Get inner text of the element as LPCWSTR (utf16 words).\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] rcv \\b pointer to the function receiving UTF16 encoded plain text\r\n//  \\param[in] rcv_param \\b param passed that passed to LPCWSTR_RECEIVER \"as is\"\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) Text() (string, error) {\r\n\tvar str string\r\n\t// args\r\n\tcparam := C.LPVOID(unsafe.Pointer(&str))\r\n\t// cgo call\r\n\tr := C.SciterGetElementTextCB(e.handle, lpcwstr_receiver, cparam)\r\n\treturn str, wrapDomResult(r, \"SciterGetElementTextCB\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetElementText(HELEMENT he, LPCWSTR utf16, UINT length)\r\n\r\n//Set inner text of the element from LPCWSTR buffer (utf16 words).\r\n//   \\param[in] he \\b #HELEMENT\r\n//   \\param[in] utf16words \\b pointer, UTF16 encoded plain text\r\n//   \\param[in] length \\b UINT, number of words in utf16words sequence\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) SetText(text string) error {\r\n\t// args\r\n\tu16, err := Utf16FromString(text)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tclength := C.UINT(len(u16) - 1)\r\n\tctext := C.LPCWSTR(unsafe.Pointer(&u16[0]))\r\n\t// cgo call\r\n\tr := C.SciterSetElementText(e.handle, ctext, clength)\r\n\treturn wrapDomResult(r, \"SciterSetElementText\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetAttributeCount(HELEMENT he, LPUINT p_count) ;//{ return SAPI()->SciterGetAttributeCount(he, p_count); }\r\n\r\n//Get number of element's attributes.\r\n//   \\param[in] he \\b #HELEMENT\r\n//   \\param[out] p_count \\b LPUINT, variable to receive number of element\r\n//   attributes.\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) AttrCount() (int, error) {\r\n\tvar count C.UINT\r\n\t// cgo call\r\n\tr := C.SciterGetAttributeCount(e.handle, &count)\r\n\treturn int(count), wrapDomResult(r, \"SciterGetAttributeCount\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetNthAttributeNameCB(HELEMENT he, UINT n, LPCSTR_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterGetNthAttributeNameCB(he,n,rcv,rcv_param); }\r\n\r\nfunc (e *Element) NthAttrName(n int) (name string, err error) {\r\n\t// args\r\n\tcn := C.UINT(n)\r\n\tcparam := C.LPVOID(unsafe.Pointer(&name))\r\n\t// cgo call\r\n\tr := C.SciterGetNthAttributeNameCB(e.handle, cn, lpcstr_receiver, cparam)\r\n\terr = wrapDomResult(r, \"SciterGetNthAttributeNameCB\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetNthAttributeValueCB(HELEMENT he, UINT n, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterGetNthAttributeValueCB(he, n, rcv, rcv_param); }\r\n\r\n//Get value of any element's attribute by attribute's number.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] n \\b UINT, number of desired attribute\r\n//  \\param[out] p_name \\b LPCSTR*, will be set to address of the string\r\n//  containing attribute name\r\n//  \\param[out] p_value \\b LPCWSTR*, will be set to address of the string\r\n//  containing attribute value\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) NthAttr(n int) (value string, err error) {\r\n\t// args\r\n\tcn := C.UINT(n)\r\n\tcparam := C.LPVOID(unsafe.Pointer(&value))\r\n\t// cgo call\r\n\tr := C.SciterGetNthAttributeValueCB(e.handle, cn, lpcwstr_receiver, cparam)\r\n\terr = wrapDomResult(r, \"SciterGetNthAttributeValueCB\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetAttributeByNameCB(HELEMENT he, LPCSTR name, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterGetAttributeByNameCB(he,name,rcv,rcv_param); }\r\n\r\n//Get value of any element's attribute by name.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] name \\b LPCSTR, attribute name\r\n//  \\param[out] p_value \\b LPCWSTR*, will be set to address of the string\r\n//  containing attribute value\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) Attr(name string) (string, error) {\r\n\tvar str string\r\n\t// args\r\n\tcname := C.CString(name)\r\n\tcrcv := (*C.LPCWSTR_RECEIVER)(unsafe.Pointer(C.LPCWSTR_RECEIVER_cgo))\r\n\tcparam := C.LPVOID(unsafe.Pointer(&str))\r\n\t// cgo call\r\n\tr := C.SciterGetAttributeByNameCB(e.handle, cname, crcv, cparam)\r\n\tC.free(unsafe.Pointer(cname))\r\n\treturn str, wrapDomResult(r, \"SciterGetAttributeByNameCB\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetAttributeByName(HELEMENT he, LPCSTR name, LPCWSTR value) ;//{ return SAPI()->SciterSetAttributeByName(he,name,value); }\r\n\r\n//Set attribute's value.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] name \\b LPCSTR, attribute name\r\n//  \\param[in] value \\b LPCWSTR, new attribute value or 0 if you want to remove attribute.\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) SetAttr(name, val string) error {\r\n\t// args\r\n\tcname := C.CString(name)\r\n\tcval := C.LPCWSTR(StringToWcharPtr(val))\r\n\t// cgo call\r\n\tr := C.SciterSetAttributeByName(e.handle, cname, cval)\r\n\tC.free(unsafe.Pointer(cname))\r\n\treturn wrapDomResult(r, \"SciterSetAttributeByName\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterClearAttributes(HELEMENT he)\r\n\r\n//Remove all attributes from the element.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) ClearAttr() error {\r\n\treturn wrapDomResult(C.SciterClearAttributes(e.handle), \"SciterClearAttributes\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementIndex(HELEMENT he, LPUINT p_index)\r\n\r\n//Get element index.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[out] p_index \\b LPUINT, variable to receive number of the element\r\n//  among parent element's subelements.\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) Index() (idx int, err error) {\r\n\t// args\r\n\tvar cidx C.UINT\r\n\t// cgo call\r\n\tr := C.SciterGetElementIndex(e.handle, &cidx)\r\n\tidx = int(cidx)\r\n\terr = wrapDomResult(r, \"SciterGetElementIndex\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementType(HELEMENT he, LPCSTR* p_type)\r\n// SCDOM_RESULT  SciterGetElementTypeCB(HELEMENT he, LPCSTR_RECEIVER* rcv, LPVOID rcv_param)\r\n\r\n// Get element's type.\r\nfunc (e *Element) Type() (string, error) {\r\n\tvar str string\r\n\t// args\r\n\tcparam := C.LPVOID(unsafe.Pointer(&str))\r\n\t// cgo call\r\n\tr := C.SciterGetElementTypeCB(e.handle, lpcstr_receiver, cparam)\r\n\treturn str, wrapDomResult(r, \"SciterGetElementTypeCB\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetStyleAttributeCB(HELEMENT he, LPCSTR name, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterGetStyleAttributeCB(he,name,rcv,rcv_param); }\r\n\r\n//Get element's style attribute.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\param[in] name \\b LPCSTR, name of the style attribute\r\n//  \\param[in] rcv \\b pointer to the function receiving UTF16 encoded plain text\r\n//  \\param[in] rcv_param \\b param passed that passed to LPCWSTR_RECEIVER \"as is\"\r\n//\r\n//  Style attributes are those that are set using css. E.g. \"font-face: arial\" or \"display: block\".\r\n//\r\n//  \\sa #SciterSetStyleAttribute()\r\nfunc (e *Element) Style(name string) (string, error) {\r\n\tvar str string\r\n\t// args\r\n\tcname := C.CString(name)\r\n\tcrcv := (*C.LPCWSTR_RECEIVER)(unsafe.Pointer(C.LPCWSTR_RECEIVER_cgo))\r\n\tcparam := C.LPVOID(unsafe.Pointer(&str))\r\n\t// cgo call\r\n\tr := C.SciterGetStyleAttributeCB(e.handle, cname, crcv, cparam)\r\n\tC.free(unsafe.Pointer(cname))\r\n\treturn str, wrapDomResult(r, \"SciterGetStyleAttributeCB\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetStyleAttribute(HELEMENT he, LPCSTR name, LPCWSTR value) ;//{ return SAPI()->SciterSetStyleAttribute(he,name,value); }\r\n\r\nfunc (e *Element) SetStyle(name, val string) error {\r\n\t// args\r\n\tcname := C.CString(name)\r\n\tcval := C.LPCWSTR(StringToWcharPtr(val))\r\n\t// cgo call\r\n\tr := C.SciterSetStyleAttribute(e.handle, cname, cval)\r\n\tC.free(unsafe.Pointer(cname))\r\n\treturn wrapDomResult(r, \"SciterSetStyleAttribute\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementLocation(HELEMENT he, LPRECT p_location, UINT areas /*ELEMENT_AREAS*/) ;//{ return SAPI()->SciterGetElementLocation(he,p_location,areas); }\r\n\r\n// SCDOM_RESULT  SciterScrollToView(HELEMENT he, UINT SciterScrollFlags) ;//{ return SAPI()->SciterScrollToView(he,SciterScrollFlags); }\r\n\r\n// Scroll to view.\r\nfunc (e *Element) ScrollToView(flag SCITER_SCROLL_FLAGS) error {\r\n\t// args\r\n\tcflag := C.UINT(flag)\r\n\t// cgo call\r\n\tr := C.SciterScrollToView(e.handle, cflag)\r\n\treturn wrapDomResult(r, \"SciterScrollToView\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterUpdateElement(HELEMENT he, BOOL andForceRender)\r\n\r\n// Apply changes and refresh element area in its window.\r\n//   \\param[in] he \\b #HELEMENT\r\n//   \\param[in] andForceRender \\b BOOL, TRUE to force UpdateWindow() call.\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) Update(forceRender bool) error {\r\n\t// args\r\n\tvar cforceRender C.SBOOL = C.FALSE\r\n\tif forceRender {\r\n\t\tcforceRender = C.TRUE\r\n\t}\r\n\t// cgo call\r\n\treturn wrapDomResult(C.SciterUpdateElement(e.handle, cforceRender), \"SciterUpdateElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterRefreshElementArea(HELEMENT he, RECT rc)\r\n\r\n// SCDOM_RESULT  SciterSetCapture(HELEMENT he)\r\n\r\n//Set the mouse capture to the specified element.\r\n//  \\param[in] he \\b #HELEMENT\r\n//  \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//  After call to this function all mouse events will be targeted to the element.\r\n//  To remove mouse capture call ReleaseCapture() function.\r\nfunc (e *Element) Capture() error {\r\n\treturn wrapDomResult(C.SciterSetCapture(e.handle), \"SciterSetCapture\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterReleaseCapture(HELEMENT he)\r\nfunc (e *Element) ReleaseCapture() error {\r\n\treturn wrapDomResult(C.SciterReleaseCapture(e.handle), \"SciterReleaseCapture\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementHwnd(HELEMENT he, HWINDOW* p_hwnd, BOOL rootWindow)\r\n\r\n// Get HWINDOW of containing window.\r\nfunc (e *Element) GetHwnd(rootWindow bool) (hwnd C.HWINDOW, err error) {\r\n\t// args\r\n\tvar crootWindow C.SBOOL = C.FALSE\r\n\tif rootWindow {\r\n\t\tcrootWindow = C.TRUE\r\n\t}\r\n\t// cgo call\r\n\tr := C.SciterGetElementHwnd(e.handle, (C.HWINDOW_PTR)(unsafe.Pointer(&hwnd)), crootWindow)\r\n\terr = wrapDomResult(r, \"SciterGetElementHwnd\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterCombineURL(HELEMENT he, LPWSTR szUrlBuffer, UINT UrlBufferSize)\r\n\r\n// Combine given URL with URL of the document element belongs to.\r\n//   \\param[in] he \\b #HELEMENT\r\n//   \\param[in, out] szUrlBuffer \\b LPWSTR, at input this buffer contains\r\n//   zero-terminated URL to be combined, after function call it contains\r\n//   zero-terminated combined URL\r\n//   \\param[in] UrlBufferSize \\b UINT, size of the buffer pointed by\r\n//   \\c szUrlBuffer\r\n//   \\return \\b #SCDOM_RESULT SCAPI\r\n//\r\n//   This function is used for resolving relative references.\r\nfunc (e *Element) CombineURL(url string) (combinedUrl string, err error) {\r\n\tvar buf []uint16\r\n\tbuf, err = Utf16FromString(url)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tbuf = append(buf, make([]uint16, 1024)...)\r\n\t// args\r\n\tcBuffer := C.LPWSTR(unsafe.Pointer(&buf[0]))\r\n\tcBufferSize := C.UINT(len(buf))\r\n\t// cgo call\r\n\tr := C.SciterCombineURL(e.handle, cBuffer, cBufferSize)\r\n\tif SCDOM_RESULT(r) != SCDOM_OK {\r\n\t\treturn \"\", wrapDomResult(r, \"SciterCombineURL\")\r\n\t}\r\n\t// get combinedUrl\r\n\tcombinedUrl = Utf16ToString(&buf[0])\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterSelectElements(HELEMENT  he, LPCSTR    CSS_selectors, SciterElementCallback* callback, LPVOID param)\r\n\r\n// typedef BOOL SC_CALLBACK SciterElementCallback( HELEMENT he, LPVOID param );\r\n\r\n//export goSciterElementCallback\r\nfunc goSciterElementCallback(he C.HELEMENT, param unsafe.Pointer) int {\r\n\tidx := int(uintptr(param))\r\n\te := WrapElement(he)\r\n\tglobalElementCallbackResults[idx] = append(globalElementCallbackResults[idx], e)\r\n\treturn 0\r\n}\r\n\r\nvar (\r\n\tsciterElementCallback        = (*C.SciterElementCallback)(unsafe.Pointer(C.SciterElementCallback_cgo))\r\n\tglobalElementCallbackResults = make([][]*Element, 0)\r\n)\r\n\r\n// SCDOM_RESULT  SciterSelectElementsW(HELEMENT  he, LPCWSTR   CSS_selectors, SciterElementCallback* callback, LPVOID param)\r\nfunc (e *Element) Select(css_selectors string) ([]*Element, error) {\r\n\tresults := make([]*Element, 0, 32)\r\n\tglobalElementCallbackResults = append(globalElementCallbackResults, results)\r\n\tidx := len(globalElementCallbackResults) - 1\r\n\t// args\r\n\tcselectors := C.LPCWSTR(StringToWcharPtr(css_selectors))\r\n\tcparam := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\t// cgo call\r\n\tr := C.SciterSelectElementsW(e.handle, cselectors, sciterElementCallback, cparam)\r\n\terr := wrapDomResult(r, \"SciterSelectElementsW\")\r\n\tresults = globalElementCallbackResults[idx]\r\n\tglobalElementCallbackResults[idx] = nil\r\n\treturn results, err\r\n}\r\n\r\n// Returns the only child element that matches the selector.\r\nfunc (e *Element) SelectFirst(css_selectors string) (*Element, error) {\r\n\tels, err := e.Select(css_selectors)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"%s:%s\", \"SelectFirst\", \"no proper element found\")\r\n\t}\r\n\tif len(els) == 0 {\r\n\t\treturn nil, nil\r\n\t}\r\n\treturn els[0], nil\r\n}\r\n\r\n// Returns the only child element that matches the selector.\r\n// If no elements match or more than one element matches, the function returns error.\r\nfunc (e *Element) SelectUnique(selector string) (*Element, error) {\r\n\tels, err := e.Select(selector)\r\n\tif err != nil || len(els) != 1 {\r\n\t\treturn nil, fmt.Errorf(\"%s:%s\", \"SelectUnique\", \"no unique element found\")\r\n\t}\r\n\treturn els[0], nil\r\n}\r\n\r\n// Returns the only child element that matches the selector.\r\n// If no elements match or more than one element matches, the function panics.\r\nfunc (e *Element) MustSelectUnique(selector string) *Element {\r\n\tr, err := e.SelectUnique(selector)\r\n\tif err != nil {\r\n\t\tlog.Panic(err)\r\n\t}\r\n\treturn r\r\n}\r\n\r\n// A wrapper of SelectUnique that auto-prepends a hash to the provided id.\r\n// Useful when selecting elements base on a programmatically retrieved id (which does\r\n// not already have the hash on it)\r\nfunc (e *Element) SelectById(id string) (*Element, error) {\r\n\treturn e.SelectUnique(fmt.Sprintf(\"#%s\", id))\r\n}\r\n\r\nfunc (e *Element) MustSelectById(id string) *Element {\r\n\treturn e.MustSelectUnique(fmt.Sprintf(\"#%s\", id))\r\n}\r\n\r\n// SCDOM_RESULT  SciterSelectParent(HELEMENT  he, LPCSTR    selector, UINT      depth, HELEMENT* heFound)\r\n\r\n// SCDOM_RESULT  SciterSelectParentW(HELEMENT  he, LPCWSTR   selector, UINT      depth, HELEMENT* heFound)\r\nfunc (e *Element) SelectParent(css_selector string, depth int) (*Element, error) {\r\n\tvar heFound C.HELEMENT\r\n\t// args\r\n\tcselector := C.LPCWSTR(StringToWcharPtr(css_selector))\r\n\tcdepth := C.UINT(depth)\r\n\t// cgo call\r\n\tr := C.SciterSelectParentW(e.handle, cselector, cdepth, &heFound)\r\n\treturn WrapElement(heFound), wrapDomResult(r, \"SciterSelectParentW\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetElementHtml(HELEMENT he, const BYTE* html, UINT htmlLength, UINT where)\r\nfunc (e *Element) SetHtml(html string, where SET_ELEMENT_HTML) error {\r\n\tif len(html) == 0 {\r\n\t\treturn e.Clear()\r\n\t}\r\n\r\n\t// args\r\n\tchtml := (*C.BYTE)(StringToBytePtr(html))\r\n\tclen := C.UINT(len(html))\r\n\tcwhere := C.UINT(where)\r\n\t// cgo call\r\n\tr := C.SciterSetElementHtml(e.handle, chtml, clen, cwhere)\r\n\treturn wrapDomResult(r, \"SciterSetElementHtml\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementUID(HELEMENT he, UINT* puid)\r\nfunc (e *Element) UID() (uint, error) {\r\n\t// args\r\n\tvar uid C.UINT\r\n\t// cgo call\r\n\tr := C.SciterGetElementUID(e.handle, &uid)\r\n\treturn uint(uid), wrapDomResult(r, \"SciterGetElementUID\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementByUID(HWINDOW hwnd, UINT uid, HELEMENT* phe)\r\nfunc (s *Sciter) GetElementByUID(uid uint) (*Element, error) {\r\n\t// args\r\n\tcuid := C.UINT(uid)\r\n\tvar he C.HELEMENT\r\n\t// cgo call\r\n\tr := C.SciterGetElementByUID(s.hwnd, cuid, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterGetElementByUID\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterShowPopup(HELEMENT hePopup, HELEMENT heAnchor, UINT placement)\r\n\r\n//Shows block element (DIV) in popup window.\r\n// \\param[in] hePopup \\b HELEMENT, element to show as popup\r\n// \\param[in] heAnchor \\b HELEMENT, anchor element - hePopup will be shown near this element\r\n// \\param[in] placement \\b UINT, values:\r\n//     2 - popup element below of anchor\r\n//     8 - popup element above of anchor\r\n//     4 - popup element on left side of anchor\r\n//     6 - popup element on right side of anchor\r\n//     ( see numpad on keyboard to get an idea of the numbers)\r\n// \\return \\b #SCDOM_RESULT SCAPI\r\nfunc (e *Element) ShowPopup(eAnchor *Element, placement PopupPlacement) error {\r\n\t// args\r\n\tcplacement := C.UINT(placement)\r\n\t// cgo call\r\n\tr := C.SciterShowPopup(e.handle, eAnchor.handle, cplacement)\r\n\treturn wrapDomResult(r, \"SciterShowPopup\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterShowPopupAt(HELEMENT hePopup, POINT pos, BOOL animate)\r\n\r\n// Shows block element (DIV) in popup window at given position.\r\n//  \\param[in] hePopup \\b HELEMENT, element to show as popup\r\n//  \\param[in] pos \\b POINT, popup element position, relative to origin of Sciter window.\r\n//  \\param[in] placement \\b UINT, values:\r\n//      2 - popup element below of anchor\r\n//      8 - popup element above of anchor\r\n//      4 - popup element on left side of anchor\r\n//      6 - popup element on right side of anchor\r\n//      ( see numpad on keyboard to get an idea of the numbers)\r\nfunc (e *Element) ShowPopupAt(pos Point, placement uint) error {\r\n\t// args\r\n\tvar cpos C.POINT = *(*C.POINT)(unsafe.Pointer(&pos))\r\n\tcplacement := C.UINT(placement)\r\n\t// cgo call\r\n\tr := C.SciterShowPopupAt(e.handle, cpos, cplacement)\r\n\treturn wrapDomResult(r, \"SciterShowPopupAt\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterHidePopup(HELEMENT he)\r\nfunc (e *Element) HidePopup() error {\r\n\t// cgo call\r\n\tr := C.SciterHidePopup(e.handle)\r\n\treturn wrapDomResult(r, \"SciterHidePopup\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetElementState( HELEMENT he, UINT* pstateBits)\r\n\r\n// Get/set state bits, stateBits*** accept or'ed values above\r\nfunc (e *Element) State() (ElementState, error) {\r\n\t// args\r\n\tvar state C.UINT\r\n\t// cgo call\r\n\tr := C.SciterGetElementState(e.handle, &state)\r\n\treturn ElementState(state), wrapDomResult(r, \"SciterGetElementState\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetElementState( HELEMENT he, UINT stateBitsToSet, UINT stateBitsToClear, BOOL updateView)\r\nfunc (e *Element) SetState(bitsToSet, bitsToClear ElementState, updateView bool) error {\r\n\t// args\r\n\tcbitsToSet := C.UINT(bitsToSet)\r\n\tcbitsToClear := C.UINT(bitsToClear)\r\n\tvar cupdateView C.SBOOL = C.FALSE\r\n\tif updateView {\r\n\t\tcupdateView = C.TRUE\r\n\t}\r\n\t// cgo call\r\n\tr := C.SciterSetElementState(e.handle, cbitsToSet, cbitsToClear, cupdateView)\r\n\treturn wrapDomResult(r, \"SciterSetElementState\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterCreateElement( LPCSTR tagname, LPCWSTR textOrNull, /*out*/ HELEMENT *phe )\r\n\r\n// Create new element, the element is disconnected initially from the DOM.\r\n//     Element created with ref_count = 1 thus you \\b must call Sciter_UnuseElement on returned handler.\r\n//  \\param[in] tagname \\b LPCSTR, html tag of the element e.g. \"div\", \"option\", etc.\r\n//  \\param[in] textOrNull \\b LPCWSTR, initial text of the element or NULL. text here is a plain text - method does no parsing.\r\n//  \\param[out ] phe \\b #HELEMENT*, variable to receive handle of the element\r\nfunc CreateElement(tagname, textOrNull string) (*Element, error) {\r\n\t// args\r\n\tvar he C.HELEMENT\r\n\tctagname := C.LPCSTR(unsafe.Pointer(StringToBytePtr(tagname)))\r\n\tctextOrNull := C.LPCWSTR(StringToWcharPtr(textOrNull))\r\n\t// cgo call\r\n\tr := C.SciterCreateElement(ctagname, ctextOrNull, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterCreateElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterCloneElement( HELEMENT he, /*out*/ HELEMENT *phe )\r\n\r\n// Create new element as copy of existing element, new element is a full (deep) copy of the element and\r\n//     is disconnected initially from the DOM.\r\n//     Element created with ref_count = 1 thus you \\b must call Sciter_UnuseElement on returned handler.\r\n//  \\param[in] he \\b #HELEMENT, source element.\r\n//  \\param[out ] phe \\b #HELEMENT*, variable to receive handle of the new element.\r\nfunc (e *Element) Clone() (*Element, error) {\r\n\t// args\r\n\tvar he C.HELEMENT\r\n\t// cgo call\r\n\tr := C.SciterCloneElement(e.handle, &he)\r\n\treturn WrapElement(he), wrapDomResult(r, \"SciterCloneElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterInsertElement( HELEMENT he, HELEMENT hparent, UINT index )\r\n//\r\n// Insert element at the index position of parent.\r\n//     It is not an error to insert element which already has parent - it will be disconnected first, but\r\n//     you need to update elements parent in this case.\r\nfunc (e *Element) Insert(el *Element, index int) error {\r\n\t// args\r\n\tcindex := C.UINT(index)\r\n\t// cgo call\r\n\tr := C.SciterInsertElement(el.handle, e.handle, cindex)\r\n\treturn wrapDomResult(r, \"SciterInsertElement\")\r\n}\r\n\r\n// Append element e as last child of this element.\r\nfunc (e *Element) Append(el *Element) error {\r\n\t// args\r\n\tcindex := C.UINT(0x7FFFFFFF)\r\n\t// cgo call\r\n\tr := C.SciterInsertElement(el.handle, e.handle, cindex)\r\n\treturn wrapDomResult(r, \"Element.Append\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterDetachElement( HELEMENT he )\r\n\r\n// Take element out of its container (and DOM tree).\r\n//    Element will be destroyed when its reference counter will become zero\r\nfunc (e *Element) Detach() error {\r\n\t// cgo call\r\n\tr := C.SciterDetachElement(e.handle)\r\n\treturn wrapDomResult(r, \"SciterDetachElement\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterDeleteElement(HELEMENT he)\r\n\r\n// Take element out of its container (and DOM tree).\r\n//   Element will be destroyed when its reference counter will become zero\r\nfunc (e *Element) Delete() error {\r\n\t// cgo cal\r\n\tr := C.SciterDeleteElement(e.handle)\r\n\treturn wrapDomResult(r, \"SciterDeleteElement\")\r\n}\r\n\r\n// Clear contents and all children of the element.\r\nfunc (e *Element) Clear() error {\r\n\t// cgo cal\r\n\tr := C.SciterSetElementText(e.handle, C.LPCWSTR(nil), C.UINT(0))\r\n\treturn wrapDomResult(r, \"Element.Clear\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetTimer( HELEMENT he, UINT milliseconds, UINT_PTR timer_id )\r\n\r\n// Start Timer for the element.\r\n//   Element will receive on_timer event\r\n//   To stop timer call SciterSetTimer( he, 0 );\r\nfunc (e *Element) SetTimer(milliseconds int) error {\r\n\t// args\r\n\tcmilliseconds := C.UINT(milliseconds)\r\n\tctimeer_id := (C.UINT_PTR)(0)\r\n\t// cgo call\r\n\tr := C.SciterSetTimer(e.handle, cmilliseconds, ctimeer_id)\r\n\treturn wrapDomResult(r, \"SciterSetTimer\")\r\n}\r\n\r\n// typedef BOOL SC_CALLBACK ElementEventProc(LPVOID tag, HELEMENT he, UINT evtg, LPVOID prms );\r\n// typedef ElementEventProc* LPELEMENT_EVENT_PROC;\r\n\r\n// Main event handler that dispatches to the right element handler\r\n\r\nvar (\r\n\t// Hold a reference to handlers that are in-use so that they don't\r\n\t// get garbage collected.\r\n\tglobalEventHandlers = make([]*EventHandler, 0)\r\n\tbehaviors           = make(map[*EventHandler]int, 32)\r\n)\r\n\r\nconst (\r\n\thandlerNotFound = -1\r\n)\r\n\r\n// -1 indacates not found\r\nfunc findEventHandlerIdx(eh *EventHandler) int {\r\n\tfor i, v := range globalEventHandlers {\r\n\t\tif v == eh {\r\n\t\t\treturn i\r\n\t\t}\r\n\t}\r\n\treturn handlerNotFound\r\n}\r\n\r\n//export goElementEventProc\r\nfunc goElementEventProc(tag unsafe.Pointer, he C.HELEMENT, evtg uint, params unsafe.Pointer) int {\r\n\thandler := globalEventHandlers[int(uintptr(tag))]\r\n\thandled := false\r\n\t// el := WrapElement(he)\r\n\tel := WrapElement(he)\r\n\r\n\tswitch evtg {\r\n\tcase SUBSCRIPTIONS_REQUEST:\r\n\t\tp := (*uint32)(params)\r\n\t\t*p = HANDLE_ALL\r\n\t\thandled = true\r\n\tcase HANDLE_INITIALIZATION:\r\n\t\tif p := (*InitializationParams)(params); p.Cmd == BEHAVIOR_ATTACH {\r\n\t\t\t//log.Print(\"Attach event handler to \", NewElementFromHandle(HELEMENT(he)).Describe())\r\n\t\t\tif handler.OnAttached != nil {\r\n\t\t\t\thandler.OnAttached(el)\r\n\t\t\t}\r\n\t\t} else if p.Cmd == BEHAVIOR_DETACH {\r\n\t\t\t//log.Print(\"Detach event handler from \", NewElementFromHandle(el).Describe())\r\n\t\t\tif handler.OnDetached != nil {\r\n\t\t\t\thandler.OnDetached(el)\r\n\t\t\t}\r\n\r\n\t\t\t// If this was a behavior detaching, decrement the reference count and stop tracking\r\n\t\t\t// the pointer if the ref count has been exhausted\r\n\t\t\tif behaviorRefCount, exists := behaviors[handler]; exists {\r\n\t\t\t\tbehaviorRefCount--\r\n\t\t\t\tif behaviorRefCount == 0 {\r\n\t\t\t\t\tdelete(behaviors, handler)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbehaviors[handler] = behaviorRefCount\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\thandled = true\r\n\tcase HANDLE_MOUSE:\r\n\t\tif handler.OnMouse != nil {\r\n\t\t\tp := (*MouseParams)(params)\r\n\t\t\thandled = handler.OnMouse(el, p)\r\n\t\t}\r\n\tcase HANDLE_KEY:\r\n\t\tif handler.OnKey != nil {\r\n\t\t\tp := (*KeyParams)(params)\r\n\t\t\thandled = handler.OnKey(el, p)\r\n\t\t}\r\n\tcase HANDLE_FOCUS:\r\n\t\tif handler.OnFocus != nil {\r\n\t\t\tp := (*FocusParams)(params)\r\n\t\t\thandled = handler.OnFocus(el, p)\r\n\t\t}\r\n\tcase HANDLE_DRAW:\r\n\t\tif handler.OnDraw != nil {\r\n\t\t\tp := (*DrawParams)(params)\r\n\t\t\thandled = handler.OnDraw(el, p)\r\n\t\t}\r\n\tcase HANDLE_TIMER:\r\n\t\tif handler.OnTimer != nil {\r\n\t\t\tp := (*TimerParams)(params)\r\n\t\t\thandled = handler.OnTimer(el, p)\r\n\t\t}\r\n\tcase HANDLE_BEHAVIOR_EVENT:\r\n\t\tif handler.OnBehaviorEvent != nil {\r\n\t\t\tp := (*BehaviorEventParams)(params)\r\n\t\t\thandled = handler.OnBehaviorEvent(el, p)\r\n\t\t}\r\n\tcase HANDLE_METHOD_CALL:\r\n\t\tif handler.OnMethodCall != nil {\r\n\t\t\tp := (*MethodParams)(params)\r\n\t\t\thandled = handler.OnMethodCall(el, p)\r\n\t\t}\r\n\tcase HANDLE_SCRIPTING_METHOD_CALL:\r\n\t\tif handler.OnScriptingMethodCall != nil {\r\n\t\t\tp := (*ScriptingMethodParams)(params)\r\n\t\t\thandled = handler.OnScriptingMethodCall(el, p)\r\n\t\t}\r\n\tcase HANDLE_TISCRIPT_METHOD_CALL:\r\n\t\tif handler.OnTiscriptMethodCall != nil {\r\n\t\t\tp := (*TiscriptMethodParams)(params)\r\n\t\t\thandled = handler.OnTiscriptMethodCall(el, p)\r\n\t\t}\r\n\r\n\tcase HANDLE_DATA_ARRIVED:\r\n\t\tif handler.OnDataArrived != nil {\r\n\t\t\tp := (*DataArrivedParams)(params)\r\n\t\t\thandled = handler.OnDataArrived(el, p)\r\n\t\t}\r\n\tcase HANDLE_SIZE:\r\n\t\tif handler.OnSize != nil {\r\n\t\t\thandler.OnSize(el)\r\n\t\t}\r\n\tcase HANDLE_SCROLL:\r\n\t\tif handler.OnScroll != nil {\r\n\t\t\tp := (*ScrollParams)(params)\r\n\t\t\thandled = handler.OnScroll(el, p)\r\n\t\t}\r\n\tcase HANDLE_EXCHANGE:\r\n\t\tif handler.OnExchange != nil {\r\n\t\t\tp := (*ExchangeParams)(params)\r\n\t\t\thandled = handler.OnExchange(el, p)\r\n\t\t}\r\n\tcase HANDLE_GESTURE:\r\n\t\tif handler.OnGesture != nil {\r\n\t\t\tp := (*GestureParams)(params)\r\n\t\t\thandled = handler.OnGesture(el, p)\r\n\t\t}\r\n\tcase HANDLE_SOM:\r\n\t\tif handler.OnSom != nil {\r\n\t\t\tp := (*SomParams)(params)\r\n\t\t\thandled = handler.OnSom(el, p)\r\n\t\t}\r\n\tdefault:\r\n\t\tlog.Panicf(\"Unhandled sciter event case: 0x%04X.\\nCheck `EVENT_GROUPS` in sciter-x-behavior.h in the latest Sciter SDK\", evtg)\r\n\t}\r\n\tif handled {\r\n\t\treturn 1\r\n\t}\r\n\treturn 0\r\n}\r\n\r\nvar (\r\n\telement_event_proc = (C.LPELEMENT_EVENT_PROC)(unsafe.Pointer(C.ElementEventProc_cgo))\r\n)\r\n\r\n// SCDOM_RESULT  SciterDetachEventHandler( HELEMENT he, LPELEMENT_EVENT_PROC pep, LPVOID tag )\r\nfunc (e *Element) DetachEventHandler(handler *EventHandler) error {\r\n\t// test\r\n\thm, ok := elementHandlerMap[e]\r\n\tif !ok {\r\n\t\thm = make(map[*EventHandler]struct{}, 0)\r\n\t\telementHandlerMap[e] = hm\r\n\t}\r\n\tif _, exists := hm[handler]; !exists {\r\n\t\treturn nil\r\n\t}\r\n\t// args\r\n\tidx := findEventHandlerIdx(handler)\r\n\ttag := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\t// cgo call\r\n\tif ret := C.SciterDetachEventHandler(e.handle, element_event_proc, tag); SCDOM_RESULT(ret) != SCDOM_OK {\r\n\t\treturn wrapDomResult(ret, \"SciterDetachEventHandler\")\r\n\t} else {\r\n\t\tglobalEventHandlers[idx] = nil\r\n\t\tdelete(hm, handler)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (e *Element) isValid() bool {\r\n\treturn e.handle != BAD_HELEMENT\r\n}\r\n\r\n// SCDOM_RESULT  SciterAttachEventHandler( HELEMENT he, LPELEMENT_EVENT_PROC pep, LPVOID tag ) ;//{ return SAPI()->SciterAttachEventHandler( he,pep,tag ); }\r\n//\r\n// Any Element that calls this function would not be gc collected any more\r\n// thus prevent the handler missing in sciter callbacks\r\nfunc (e *Element) AttachEventHandler(handler *EventHandler) error {\r\n\thm, ok := elementHandlerMap[e]\r\n\tif !ok {\r\n\t\thm = make(map[*EventHandler]struct{}, 0)\r\n\t\telementHandlerMap[e] = hm\r\n\t}\r\n\t// allready attached\r\n\tif _, exists := hm[handler]; exists {\r\n\t\treturn nil\r\n\t}\r\n\t// args\r\n\tglobalEventHandlers = append(globalEventHandlers, handler)\r\n\tidx := len(globalEventHandlers) - 1\r\n\ttag := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\t// do attach\r\n\thm[handler] = struct{}{}\r\n\t// Don't let the caller disable ATTACH/DETACH events, otherwise we\r\n\t// won't know when to throw out our event handler object\r\n\tif ret := C.SciterAttachEventHandler(e.handle, element_event_proc, tag); SCDOM_RESULT(ret) != SCDOM_OK {\r\n\t\treturn wrapDomResult(ret, \"SciterAttachEventHandler\")\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// This is the same as AttachHandler, except that behaviors are singleton instances stored\r\n// in a master map.  They may be shared among many elements since they have no state.\r\n// The only reason we keep a separate set of the behaviors is so that the event handler\r\n// dispatch method can tell if an event handler is a behavior or a regular handler.\r\nfunc (e *Element) attachBehavior(handler *EventHandler) {\r\n\tif !e.isValid() {\r\n\t\treturn\r\n\t}\r\n\te.AttachEventHandler(handler)\r\n}\r\n\r\n// SCDOM_RESULT  SciterWindowAttachEventHandler( HWINDOW hwndLayout, LPELEMENT_EVENT_PROC pep, LPVOID tag, UINT subscription )\r\nfunc (s *Sciter) AttachWindowEventHandler(handler *EventHandler) error {\r\n\t// prevent duplicated attachement\r\n\tfor _, v := range globalEventHandlers {\r\n\t\tif v == handler {\r\n\t\t\treturn nil\r\n\t\t}\r\n\t}\r\n\t// new attach\r\n\t// args\r\n\tglobalEventHandlers = append(globalEventHandlers, handler)\r\n\tidx := len(globalEventHandlers) - 1\r\n\ttag := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\t// // detach first\r\n\t// s.DetachWindowEventHandler()\r\n\r\n\t// // Overwrite if it exists\r\n\t// s.WindowEventHandler = handler\r\n\r\n\t// Don't let the caller disable ATTACH/DETACH events, otherwise we\r\n\t// won't know when to throw out our event handler object\r\n\t// subscription := handler.Subscription()\r\n\t// subscription &= ^uint(DISABLE_INITIALIZATION & 0xffffffff)\r\n\r\n\tr := C.SciterWindowAttachEventHandler(s.hwnd, element_event_proc, tag, HANDLE_ALL)\r\n\treturn wrapDomResult(r, \"SciterWindowAttachEventHandler\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterWindowDetachEventHandler( HWINDOW hwndLayout, LPELEMENT_EVENT_PROC pep, LPVOID tag )\r\nfunc (s *Sciter) DetachWindowEventHandler(handler *EventHandler) error {\r\n\t// if s.WindowEventHandler != nil {\r\n\tidx := findEventHandlerIdx(handler)\r\n\tif idx == handlerNotFound {\r\n\t\treturn nil\r\n\t}\r\n\ttag := C.LPVOID(unsafe.Pointer(uintptr(idx)))\r\n\tret := C.SciterWindowDetachEventHandler(s.hwnd, element_event_proc, tag)\r\n\tglobalEventHandlers[idx] = nil\r\n\treturn wrapDomResult(ret, \"SciterWindowDetachEventHandler\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSendEvent( HELEMENT he, UINT appEventCode, HELEMENT heSource, UINT reason, /*out*/ BOOL* handled) ;//{ return SAPI()->SciterSendEvent( he,appEventCode,heSource,reason,handled); }\r\n/** SendEvent - sends sinking/bubbling event to the child/parent chain of he element.\r\n   First event will be send in SINKING mode (with SINKING flag) - from root to he element itself.\r\n   Then from he element to its root on parents chain without SINKING flag (bubbling phase).\r\n\r\n* \\param[in] he \\b HELEMENT, element to send this event to.\r\n* \\param[in] appEventCode \\b UINT, event ID, see: #BEHAVIOR_EVENTS\r\n* \\param[in] heSource \\b HELEMENT, optional handle of the source element, e.g. some list item\r\n* \\param[in] reason \\b UINT, notification specific event reason code\r\n* \\param[out] handled \\b BOOL*, variable to receive TRUE if any handler handled it, FALSE otherwise.\r\n\r\n**/\r\n\r\n// SCDOM_RESULT  SciterPostEvent( HELEMENT he, UINT appEventCode, HELEMENT heSource, UINT reason) ;//{ return SAPI()->SciterPostEvent(he,appEventCode,heSource,reason); }\r\n/** PostEvent - post sinking/bubbling event to the child/parent chain of he element.\r\n *  Function will return immediately posting event into input queue of the application.\r\n *\r\n * \\param[in] he \\b HELEMENT, element to send this event to.\r\n * \\param[in] appEventCode \\b UINT, event ID, see: #BEHAVIOR_EVENTS\r\n * \\param[in] heSource \\b HELEMENT, optional handle of the source element, e.g. some list item\r\n * \\param[in] reason \\b UINT, notification specific event reason code\r\n\r\n **/\r\n\r\n// SCDOM_RESULT  SciterFireEvent( const BEHAVIOR_EVENT_PARAMS* evt, BOOL post, BOOL *handled) ;//{ return SAPI()->SciterFireEvent( evt, post, handled ); }\r\n// SCDOM_RESULT  SciterCallBehaviorMethod(HELEMENT he, struct METHOD_PARAMS* params) ;//{ return SAPI()->SciterCallBehaviorMethod(he,params); }\r\n/** SciterCallMethod - calls behavior specific method.\r\n * \\param[in] he \\b HELEMENT, element - source of the event.\r\n * \\param[in] params \\b METHOD_PARAMS, pointer to method param block\r\n **/\r\n\r\n// SCDOM_RESULT  SciterRequestElementData( HELEMENT he, LPCWSTR url, UINT dataType, HELEMENT initiator ) ;//{ return SAPI()->SciterRequestElementData(he,url,dataType,initiator ); }\r\n\r\n// SciterRequestElementData  - request data download for the element. as jQuery.load :)\r\n//  \\param[in] he \\b HELEMENT, element to deleiver data to.\r\n//  \\param[in] url \\b LPCWSTR, url to download data from.\r\n//  \\param[in] dataType \\b UINT, data type, see SciterResourceType.\r\n//  \\param[in] hInitiator \\b HELEMENT, element - initiator, can be NULL.\r\n//\r\n//  event handler on the he element (if any) will be notified\r\n//  when data will be ready by receiving HANDLE_DATA_DELIVERY event.\r\nfunc (e *Element) Load(url string, dataType SciterResourceType) error {\r\n\t// args\r\n\tcurl := C.LPCWSTR(StringToWcharPtr(url))\r\n\tcdataType := C.UINT(dataType)\r\n\thInitiator := BAD_HELEMENT\r\n\t// cgo call\r\n\tr := C.SciterRequestElementData(e.handle, curl, cdataType, hInitiator)\r\n\treturn wrapDomResult(r, \"SciterRequestElementData\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterHttpRequest( HELEMENT he, LPCWSTR url, UINT dataType, UINT requestType, struct REQUEST_PARAM* requestParams, UINT nParams)\r\n\r\n// SciterSendRequest - send GET or POST request for the element\r\n//\r\n//  event handler on the 'he' element (if any) will be notified\r\n//  when data will be ready by receiving HANDLE_DATA_DELIVERY event.\r\nfunc (e *Element) HttpRequest(url string, dataType SciterResourceType, requestType RequestType, params ...RequestParam) error {\r\n\t// args\r\n\tcurl := C.LPCWSTR(StringToWcharPtr(url))\r\n\tcdataType := C.UINT(dataType)\r\n\tcrequestType := C.UINT(requestType)\r\n\tnParams := len(params)\r\n\tcnParams := C.UINT(nParams)\r\n\trParams := make([]C.REQUEST_PARAM, nParams)\r\n\tfor i := 0; i < nParams; i++ {\r\n\t\trParams[i].name = C.LPCWSTR(StringToWcharPtr(params[i].Name))\r\n\t\trParams[i].value = C.LPCWSTR(StringToWcharPtr(params[i].Value))\r\n\t}\r\n\tvar crParams *C.REQUEST_PARAM\r\n\tif nParams > 0 {\r\n\t\tcrParams = (*C.REQUEST_PARAM)(unsafe.Pointer(&rParams[0]))\r\n\t}\r\n\t// cgo call\r\n\tr := C.SciterHttpRequest(e.handle, curl, cdataType, crequestType, crParams, cnParams)\r\n\treturn wrapDomResult(r, \"SciterHttpRequest\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetScrollInfo( HELEMENT he, LPPOINT scrollPos, LPRECT viewRect, LPSIZE contentSize ) ;//{ return SAPI()->SciterGetScrollInfo( he,scrollPos,viewRect,contentSize ); }\r\n// SCDOM_RESULT  SciterSetScrollPos( HELEMENT he, POINT scrollPos, BOOL smooth ) ;//{ return SAPI()->SciterSetScrollPos( he,scrollPos,smooth ); }\r\n// SCDOM_RESULT  SciterGetElementIntrinsicWidths( HELEMENT he, INT* pMinWidth, INT* pMaxWidth ) ;//{ return SAPI()->SciterGetElementIntrinsicWidths(he,pMinWidth,pMaxWidth ); }\r\n// SCDOM_RESULT  SciterGetElementIntrinsicHeight( HELEMENT he, INT forWidth, INT* pHeight ) ;//{ return SAPI()->SciterGetElementIntrinsicHeight( he,forWidth,pHeight ); }\r\n\r\n// SCDOM_RESULT  SciterIsElementVisible( HELEMENT he, BOOL* pVisible)\r\n\r\n// SciterIsElementVisible - deep visibility, determines if element visible - has no visiblity:hidden and no display:none defined\r\n//     for itself or for any its parents.\r\n//  \\param[in] he \\b HELEMENT, element.\r\n//  \\param[out] pVisible \\b LPBOOL, visibility state.\r\nfunc (e *Element) IsVisible() bool {\r\n\t// args\r\n\tvar v C.SBOOL\r\n\t// cgo call\r\n\tC.SciterIsElementVisible(e.handle, &v)\r\n\tif v == C.TRUE {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\n// SCDOM_RESULT  SciterIsElementEnabled( HELEMENT he, BOOL* pEnabled )\r\n\r\n// SciterIsElementEnabled - deep enable state, determines if element enabled - is not disabled by itself or no one\r\n//    of its parents is disabled.\r\n// \\param[in] he \\b HELEMENT, element.\r\n// \\param[out] pEnabled \\b LPBOOL, enabled state.\r\nfunc (e *Element) IsEnabled() bool {\r\n\t// args\r\n\tvar v C.SBOOL\r\n\t// cgo call\r\n\tC.SciterIsElementEnabled(e.handle, &v)\r\n\tif v == C.TRUE {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\n//export goELEMENT_COMPARATOR\r\nfunc goELEMENT_COMPARATOR(he1 unsafe.Pointer, he2 unsafe.Pointer, arg unsafe.Pointer) int {\r\n\tcmp := *(*func(*Element, *Element) int)(arg)\r\n\treturn cmp(WrapElement(C.HELEMENT(he1)), WrapElement(C.HELEMENT(he2)))\r\n}\r\n\r\n// SCDOM_RESULT  SciterSortElements( HELEMENT he, UINT firstIndex, UINT lastIndex, ELEMENT_COMPARATOR* cmpFunc, LPVOID cmpFuncParam ) ;//{ return SAPI()->SciterSortElements( he, firstIndex, lastIndex, cmpFunc, cmpFuncParam ); }\r\n\r\n/** SciterSortElements - sort children of the element.\r\n * \\param[in] he \\b HELEMENT, element which children to be sorted.\r\n * \\param[in] firstIndex \\b UINT, first child index to start sorting from.\r\n * \\param[in] lastIndex \\b UINT, last index of the sorting range, element with this index will not be included in the sorting.\r\n * \\param[in] cmpFunc \\b ELEMENT_COMPARATOR, comparator function.\r\n * \\param[in] cmpFuncParam \\b LPVOID, parameter to be passed in comparator function.\r\n **/\r\nfunc (e *Element) Sort(start, count int, comparator func(*Element, *Element) int) error {\r\n\t// args\r\n\tcstart := C.UINT(start)\r\n\tcend := C.UINT(start + count)\r\n\tcmpFunc := (*C.ELEMENT_COMPARATOR)(unsafe.Pointer(C.ELEMENT_COMPARATOR_cgo))\r\n\tcmpFuncParam := C.LPVOID(unsafe.Pointer(&comparator))\r\n\t// cgo call\r\n\tr := C.SciterSortElements(e.handle, cstart, cend, cmpFunc, cmpFuncParam)\r\n\treturn wrapDomResult(r, \"SciterSortElements\")\r\n}\r\n\r\nfunc (e *Element) SortChildren(comparator func(*Element, *Element) int) error {\r\n\tcount, err := e.ChildrenCount()\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\treturn e.Sort(0, count, comparator)\r\n}\r\n\r\n// SCDOM_RESULT  SciterSwapElements( HELEMENT he1, HELEMENT he2 ) ;//{ return SAPI()->SciterSwapElements( he1,he2 ); }\r\n\r\n// SciterSwapElements - swap element positions.\r\n//  Function changes \"insertion points\" of two elements. So it swops indexes and parents of two elements.\r\n//  \\param[in] he1 \\b HELEMENT, first element.\r\n//  \\param[in] he2 \\b HELEMENT, second element.\r\nfunc (e *Element) Swap(t *Element) error {\r\n\treturn wrapDomResult(C.SciterSwapElements(e.handle, t.handle), \"SciterSwapElements\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterTraverseUIEvent( UINT evt, LPVOID eventCtlStruct, BOOL* bOutProcessed ) ;//{ return SAPI()->SciterTraverseUIEvent( evt,eventCtlStruct,bOutProcessed ); }\r\n\r\n// SCDOM_RESULT  SciterCallScriptingFunction( HELEMENT he, LPCSTR name, const VALUE* argv, UINT argc, VALUE* retval ) ;//{ return SAPI()->SciterCallScriptingFunction( he,name,argv,argc,retval ); }\r\n\r\n// call scripting function defined on global level\r\n// Example, script:\r\n//   function foo() {...}\r\n// Native code:\r\n//   dom::element root = ... get root element of main document or some frame inside it\r\n//   root.call_function(\"foo\"); // call the function\r\nfunc (e *Element) CallFunction(functionName string, args ...*Value) (retval *Value, err error) {\r\n\tretval = NewValue()\r\n\targc := len(args)\r\n\targv := make([]Value, argc)\r\n\tfor i := 0; i < argc; i++ {\r\n\t\targv[i].Copy(args[i]) // Make copy that is not garbage collected\r\n\t\tdefer argv[i].finalize()\r\n\t}\r\n\t// args\r\n\tcfn := C.LPCSTR(unsafe.Pointer(StringToBytePtr(functionName)))\r\n\tcargc := C.UINT(argc)\r\n\tvar cargv *C.SCITER_VALUE\r\n\tif len(argv) > 0 {\r\n\t\tcargv = (*C.SCITER_VALUE)(unsafe.Pointer(&argv[0]))\r\n\t}\r\n\tcretval := (*C.SCITER_VALUE)(unsafe.Pointer(retval))\r\n\t// cgo call\r\n\tr := C.SciterCallScriptingFunction(e.handle, cfn, cargv, cargc, cretval)\r\n\terr = wrapDomResult(r, \"SciterCallScriptingFunction\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterCallScriptingMethod( HELEMENT he, LPCSTR name, const VALUE* argv, UINT argc, VALUE* retval ) ;//{ return SAPI()->SciterCallScriptingMethod( he,name,argv,argc,retval ); }\r\n\r\n// call scripting method attached to the element (directly or through of scripting behavior)\r\n// Example, script:\r\n//   var elem = ...\r\n//   elem.foo = function() {...}\r\n// Native code:\r\n//   dom::element elem = ...\r\n//   elem.call_method(\"foo\");\r\nfunc (e *Element) CallMethod(methodName string, args ...*Value) (retval *Value, err error) {\r\n\tretval = NewValue()\r\n\targc := len(args)\r\n\targv := make([]Value, argc)\r\n\tfor i := 0; i < argc; i++ {\r\n\t\targv[i].Copy(args[i]) // Make copy that is not garbage collected\r\n\t\tdefer argv[i].finalize()\r\n\t}\r\n\t// args\r\n\tcfn := C.LPCSTR(unsafe.Pointer(StringToBytePtr(methodName)))\r\n\tcargc := C.UINT(argc)\r\n\tvar cargv *C.SCITER_VALUE\r\n\tif len(argv) > 0 {\r\n\t\tcargv = (*C.SCITER_VALUE)(unsafe.Pointer(&argv[0]))\r\n\t}\r\n\r\n\tcretval := (*C.SCITER_VALUE)(unsafe.Pointer(retval))\r\n\t// cgo call\r\n\tr := C.SciterCallScriptingMethod(e.handle, cfn, cargv, cargc, cretval)\r\n\terr = wrapDomResult(r, \"SciterCallScriptingMethod\")\r\n\treturn\r\n}\r\n\r\n// SCDOM_RESULT  SciterEvalElementScript( HELEMENT he, LPCWSTR script, UINT scriptLength, VALUE* retval ) ;//{ return SAPI()->SciterEvalElementScript( he, script, scriptLength, retval ); }\r\n// SCDOM_RESULT  SciterAttachHwndToElement(HELEMENT he, HWINDOW hwnd) ;//{ return SAPI()->SciterAttachHwndToElement(he,hwnd); }\r\n// SCDOM_RESULT  SciterControlGetType( HELEMENT he, /*CTL_TYPE*/ UINT *pType ) ;//{ return SAPI()->SciterControlGetType( he, pType ); }\r\n\r\n// SCDOM_RESULT  SciterGetValue( HELEMENT he, VALUE* pval ) ;//{ return SAPI()->SciterGetValue( he,pval ); }\r\n\r\n// SciterGetValue - get value of the element. 'value' is value of correspondent behavior attached to the element or its text.\r\n//  \\param[in] he \\b HELEMENT, element which value will be retrieved.\r\n//  \\param[out] pval \\b VALUE*, pointer to VALUE that will get elements value.\r\n//   ATTN: if you are not using json::value wrapper then you shall call ValueClear aginst the returned value\r\n//         otherwise memory will leak.\r\nfunc (e *Element) GetValue() (*Value, error) {\r\n\t// args\r\n\tv := NewValue()\r\n\tcv := (*C.VALUE)(unsafe.Pointer(v))\r\n\t// cgo call\r\n\tr := C.SciterGetValue(e.handle, cv)\r\n\treturn v, wrapDomResult(r, \"SciterGetValue\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterSetValue( HELEMENT he, const VALUE* pval ) ;//{ return SAPI()->SciterSetValue( he, pval ); }\r\n\r\n// SciterSetValue - set value of the element.\r\n//  \\param[in] he \\b HELEMENT, element which value will be changed.\r\n//  \\param[in] pval \\b VALUE*, pointer to the VALUE to set.\r\nfunc (e *Element) SetValue(v *Value) error {\r\n\t// args\r\n\tcv := (*C.VALUE)(unsafe.Pointer(v))\r\n\t// cgo call\r\n\tr := C.SciterSetValue(e.handle, cv)\r\n\treturn wrapDomResult(r, \"SciterSetValue\")\r\n}\r\n\r\n// SCDOM_RESULT  SciterGetExpando( HELEMENT he, VALUE* pval, BOOL forceCreation ) ;//{ return SAPI()->SciterGetExpando( he, pval, forceCreation ); }\r\n// DLLEXPORT SCDOM_RESULT  SciterGetObject( HELEMENT he, tiscript_value* pval, BOOL forceCreation ) ;//{ return SAPI()->SciterGetObject( he, pval, forceCreation ); }\r\n// DLLEXPORT SCDOM_RESULT  SciterGetElementNamespace(  HELEMENT he, tiscript_value* pval) ;//{ return SAPI()->SciterGetElementNamespace( he,pval); }\r\n// SCDOM_RESULT  SciterGetHighlightedElement(HWINDOW hwnd, HELEMENT* phe) ;//{ return SAPI()->SciterGetHighlightedElement(hwnd, phe); }\r\n// SCDOM_RESULT  SciterSetHighlightedElement(HWINDOW hwnd, HELEMENT he) ;//{ return SAPI()->SciterSetHighlightedElement(hwnd,he); }\r\n// SCDOM_RESULT  SciterNodeAddRef(HNODE hn) ;//{ return SAPI()->SciterNodeAddRef(hn); }\r\n// SCDOM_RESULT  SciterNodeRelease(HNODE hn) ;//{ return SAPI()->SciterNodeRelease(hn); }\r\n// SCDOM_RESULT  SciterNodeCastFromElement(HELEMENT he, HNODE* phn) ;//{ return SAPI()->SciterNodeCastFromElement(he,phn); }\r\n// SCDOM_RESULT  SciterNodeCastToElement(HNODE hn, HELEMENT* he) ;//{ return SAPI()->SciterNodeCastToElement(hn,he); }\r\n// SCDOM_RESULT  SciterNodeFirstChild(HNODE hn, HNODE* phn) ;//{ return SAPI()->SciterNodeFirstChild(hn,phn); }\r\n// SCDOM_RESULT  SciterNodeLastChild(HNODE hn, HNODE* phn) ;//{ return SAPI()->SciterNodeLastChild(hn, phn); }\r\n// SCDOM_RESULT  SciterNodeNextSibling(HNODE hn, HNODE* phn) ;//{ return SAPI()->SciterNodeNextSibling(hn, phn); }\r\n// SCDOM_RESULT  SciterNodePrevSibling(HNODE hn, HNODE* phn) ;//{ return SAPI()->SciterNodePrevSibling(hn,phn); }\r\n// SCDOM_RESULT  SciterNodeParent(HNODE hnode, HELEMENT* pheParent) ;//{ return SAPI()->SciterNodeParent(hnode,pheParent) ; }\r\n// SCDOM_RESULT  SciterNodeNthChild(HNODE hnode, UINT n, HNODE* phn) ;//{ return SAPI()->SciterNodeNthChild(hnode,n,phn); }\r\n// SCDOM_RESULT  SciterNodeChildrenCount(HNODE hnode, UINT* pn) ;//{ return SAPI()->SciterNodeChildrenCount(hnode, pn); }\r\n// SCDOM_RESULT  SciterNodeType(HNODE hnode, UINT* pNodeType /*NODE_TYPE*/) ;//{ return SAPI()->SciterNodeType(hnode,pNodeType); }\r\n// SCDOM_RESULT  SciterNodeGetText(HNODE hnode, LPCWSTR_RECEIVER* rcv, LPVOID rcv_param) ;//{ return SAPI()->SciterNodeGetText(hnode,rcv,rcv_param); }\r\n// SCDOM_RESULT  SciterNodeSetText(HNODE hnode, LPCWSTR text, UINT textLength) ;//{ return SAPI()->SciterNodeSetText(hnode,text,textLength); }\r\n// SCDOM_RESULT  SciterNodeInsert(HNODE hnode, UINT where /*NODE_INS_TARGET*/, HNODE what) ;//{ return SAPI()->SciterNodeInsert(hnode,where,what); }\r\n// SCDOM_RESULT  SciterNodeRemove(HNODE hnode, BOOL finalize) ;//{ return SAPI()->SciterNodeRemove(hnode,finalize); }\r\n// SCDOM_RESULT  SciterCreateTextNode(LPCWSTR text, UINT textLength, HNODE* phnode) ;//{ return SAPI()->SciterCreateTextNode(text,textLength,phnode); }\r\n// SCDOM_RESULT  SciterCreateCommentNode(LPCWSTR text, UINT textLength, HNODE* phnode) ;//{ return SAPI()->SciterCreateCommentNode(text,textLength,phnode); }\r\n\r\n// DLLEXPORT HVM    SciterGetVM( HWINDOW hwnd )  ;//{ return SAPI()->SciterGetVM(hwnd); }\r\n\r\n// typedef struct\r\n// {\r\n//   UINT   t;\r\n//   UINT   u;\r\n//   UINT64 d;\r\n// } VALUE;\r\ntype Value C.VALUE\r\n\r\n// type Value struct {\r\n// \tt, u uint\r\n// \td    uint64\r\n// }\r\n\r\n// UINT  ValueInit ( VALUE* pval ) ;//{ return SAPI()->ValueInit(pval); }\r\n\r\n// ValueInit - initialize VALUE storage\r\n//\r\n// This call has to be made before passing VALUE* to any other functions\r\nfunc (pdst *Value) init() error {\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueInit((*C.VALUE)(unsafe.Pointer(pdst)))), \"ValueInit\")\r\n}\r\n\r\n// UINT  ValueClear ( VALUE* pval ) ;//{ return SAPI()->ValueClear(pval); }\r\n\r\n// ValueClear - clears the VALUE and deallocates all assosiated structures that are not used anywhere else.\r\nfunc (pdst *Value) clear() error {\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueClear((*C.VALUE)(unsafe.Pointer(pdst)))), \"ValueClear\")\r\n}\r\n\r\n// UINT  ValueCompare ( const VALUE* pval1, const VALUE* pval2 ) ;//{ return SAPI()->ValueCompare(pval1,pval2); }\r\n\r\n//  ValueCompare - compares two values, returns HV_OK_TRUE if val1 == val2.\r\nfunc (pdst *Value) Compare(val *Value) error {\r\n\tpv := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tv := (*C.VALUE)(unsafe.Pointer(val))\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueCompare(pv, v)), \"ValueCompare\")\r\n}\r\n\r\n// UINT  ValueCopy ( VALUE* pdst, const VALUE* psrc ) ;//{ return SAPI()->ValueCopy(pdst, psrc); }\r\n\r\n// ValueCopy - copies src VALUE to dst VALUE. dst VALUE must be in ValueInit state.\r\nfunc (pdst *Value) Copy(psrc *Value) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcpsrc := (*C.VALUE)(unsafe.Pointer(psrc))\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueCopy(cpdst, cpsrc)), \"ValueCopy\")\r\n}\r\n\r\n// UINT  ValueIsolate ( VALUE* pdst ) ;//{ return SAPI()->ValueIsolate(pdst); }\r\n\r\n// ValueIsolate - converts T_OBJECT value types to T_MAP or T_ARRAY.\r\n// use this method if you need to pass values between different threads.\r\n// The fanction is applicable for the Sciter\r\nfunc (pdst *Value) Isolate() error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueIsolate(cpdst)), \"ValueIsolate\")\r\n}\r\n\r\n// UINT  ValueType ( const VALUE* pval, UINT* pType, UINT* pUnits ) ;//{ return SAPI()->ValueType(pval,pType,pUnits); }\r\n\r\n// ValueType - returns VALUE_TYPE and VALUE_UNIT_TYPE flags of the VALUE\r\nfunc (pdst *Value) Type(pType, pUints *uint) uint {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\tcpType := (*C.UINT)(unsafe.Pointer(pType))\r\n\tcpUnits := (*C.UINT)(unsafe.Pointer(pUints))\r\n\t// cgo call\r\n\treturn uint(C.ValueType(cpdst, cpType, cpUnits))\r\n}\r\n\r\n// UINT  ValueStringData ( const VALUE* pval, LPCWSTR* pChars, UINT* pNumChars ) ;//{ return SAPI()->ValueStringData(pval,pChars,pNumChars); }\r\n\r\n// ValueStringData - returns string data for T_STRING type\r\n// For T_FUNCTION returns name of the fuction.\r\nfunc (pdst *Value) stringData() string {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tvar pChars *uint16\r\n\tpNumChars := uint(0)\r\n\tcpChars := (*C.LPCWSTR)(unsafe.Pointer(&pChars))\r\n\tcpNumChars := (*C.UINT)(unsafe.Pointer(&pNumChars))\r\n\t// cgo call\r\n\tret := VALUE_RESULT(C.ValueStringData(cpdst, cpChars, cpNumChars))\r\n\tif ret == HV_OK {\r\n\t\treturn Utf16ToString(pChars)\r\n\t}\r\n\treturn \"\"\r\n}\r\n\r\nfunc (v *Value) Clone() *Value {\r\n\treturn NewValue(v)\r\n}\r\n\r\nfunc (v *Value) String() string {\r\n\tif v.IsString() {\r\n\t\treturn v.stringData()\r\n\t}\r\n\tif v.IsNativeFunctor() || v.IsFunction() {\r\n\t\treturn \"<functor>\"\r\n\t}\r\n\tt := v.Clone()\r\n\tt.ConvertToString(CVT_SIMPLE)\r\n\treturn t.stringData()\r\n}\r\n\r\n// UINT  ValueStringDataSet ( VALUE* pval, LPCWSTR chars, UINT numChars, UINT units ) ;//{ return SAPI()->ValueStringDataSet(pval, chars, numChars, units); }\r\n\r\n// ValueStringDataSet - sets VALUE to T_STRING type and copies chars/numChars to\r\n// internal refcounted buffer assosiated with the value.\r\nfunc (pdst *Value) SetString(str string, uintType ...int) error {\r\n\tsType := C.UINT(C.UT_STRING_STRING)\r\n\tif len(uintType) > 0 {\r\n\t\tsType = C.UINT(uintType[0])\r\n\t}\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\tpStr, length := StringToUTF16PtrWithLen(str)\r\n\tchars := (C.LPCWSTR)(unsafe.Pointer(pStr))\r\n\tnumChars := (C.UINT)(length)\r\n\t// cgo call\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueStringDataSet(cpdst, chars, numChars, sType)), \"ValueStringDataSet\")\r\n}\r\n\r\nfunc NewSymbol(sym string) *Value {\r\n\tv := new(Value)\r\n\tv.init()\r\n\truntime.SetFinalizer(v, (*Value).finalize)\r\n\tif err := v.SetString(sym, int(C.UT_STRING_SYMBOL)); err != nil {\r\n\t\tlog.Panic(err)\r\n\t}\r\n\treturn v\r\n}\r\n\r\n// UINT  ValueIntData ( const VALUE* pval, INT* pData ) ;//{ return SAPI()->ValueIntData ( pval, pData ); }\r\nfunc (pdst *Value) Int() int {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tvar data int = 0\r\n\tpData := (*C.INT)(unsafe.Pointer(&data))\r\n\tret := VALUE_RESULT(C.ValueIntData(cpdst, pData))\r\n\tif ret == HV_OK {\r\n\t\treturn data\r\n\t}\r\n\treturn 0\r\n}\r\n\r\n// UINT  ValueIntDataSet ( VALUE* pval, INT data, UINT type, UINT units ) ;//{ return SAPI()->ValueIntDataSet ( pval, data,type,units ); }\r\nfunc (pdst *Value) SetInt(data int) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueIntDataSet(cpdst, C.INT(data), T_INT, 0)), \"ValueIntDataSet\")\r\n}\r\n\r\nfunc (v *Value) Bool() bool {\r\n\tif v.Int() == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\nfunc (pdst *Value) SetBool(b bool) error {\r\n\tdata := 0\r\n\tif b {\r\n\t\tdata = 1\r\n\t}\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueIntDataSet(cpdst, C.INT(data), T_BOOL, 0)), \"ValueIntDataSet\")\r\n}\r\n\r\n// UINT  ValueInt64Data ( const VALUE* pval, INT64* pData ) ;//{ return SAPI()->ValueInt64Data ( pval,pData ); }\r\nfunc (pdst *Value) Int64() int64 {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tvar data int64 = 0\r\n\tpData := (*C.INT64)(unsafe.Pointer(&data))\r\n\tret := VALUE_RESULT(C.ValueInt64Data(cpdst, pData))\r\n\tif ret == HV_OK {\r\n\t\treturn data\r\n\t}\r\n\treturn 0\r\n}\r\n\r\n// UINT  ValueInt64DataSet ( VALUE* pval, INT64 data, UINT type, UINT units ) ;//{ return SAPI()->ValueInt64DataSet ( pval,data,type,units ); }\r\nfunc (pdst *Value) SetInt64(data int64, typ uint) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueInt64DataSet(cpdst, C.INT64(data), C.UINT(typ), 0)), \"ValueInt64DataSet\")\r\n}\r\n\r\n// UINT  ValueFloatData ( const VALUE* pval, FLOAT_VALUE* pData ) ;//{ return SAPI()->ValueFloatData ( pval,pData ); }\r\nfunc (pdst *Value) Float() float64 {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tvar data float64 = 0\r\n\tpData := (*C.FLOAT_VALUE)(unsafe.Pointer(&data))\r\n\tr := C.ValueFloatData(cpdst, pData)\r\n\tif r != C.UINT(HV_OK) {\r\n\t\treturn 0\r\n\t}\r\n\treturn data\r\n}\r\n\r\n// UINT  ValueFloatDataSet ( VALUE* pval, FLOAT_VALUE data, UINT type, UINT units ) ;//{ return SAPI()->ValueFloatDataSet ( pval,data,type,units ); }\r\nfunc (pdst *Value) SetFloat(data float64) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueFloatDataSet(cpdst, C.FLOAT_VALUE(data), C.UINT(T_FLOAT), 0)), \"ValueFloatDataSet\")\r\n}\r\n\r\n// UINT  ValueBinaryData ( const VALUE* pval, LPCBYTE* pBytes, UINT* pnBytes ) ;//{ return SAPI()->ValueBinaryData ( pval,pBytes,pnBytes ); }\r\n\r\n// ValueBinaryData - retreive integer data of T_BYTES type\r\nfunc (pdst *Value) Bytes() []byte {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\tvar pv C.LPCBYTE\r\n\tvar length C.UINT\r\n\tpBytes := (*C.LPCBYTE)(unsafe.Pointer(&pv))\r\n\t// cgo call\r\n\tr := C.ValueBinaryData(cpdst, pBytes, &length)\r\n\tif r != C.UINT(HV_OK) {\r\n\t\treturn nil\r\n\t}\r\n\tret := ByteCPtrToBytes(pv, length)\r\n\treturn ret\r\n}\r\n\r\n// UINT  ValueBinaryDataSet ( VALUE* pval, LPCBYTE pBytes, UINT nBytes, UINT type, UINT units )\r\nfunc (pdst *Value) SetBytes(data []byte) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\tvar pBytes C.LPCBYTE\r\n\tif len(data) > 0 {\r\n\t\tpBytes = (C.LPCBYTE)(unsafe.Pointer(&data[0]))\r\n\t}\r\n\tnBytes := (C.UINT)(len(data))\r\n\t// cgo call\r\n\tr := C.ValueBinaryDataSet(cpdst, pBytes, nBytes, T_BYTES, 0)\r\n\treturn wrapValueResult(VALUE_RESULT(r), \"ValueBinaryDataSet\")\r\n}\r\n\r\n// UINT  ValueElementsCount ( const VALUE* pval, INT* pn) ;//{ return SAPI()->ValueElementsCount ( pval,pn); }\r\n\r\n// ValueElementsCount - retreive number of sub-elements for:\r\n// - T_ARRAY - number of elements in the array;\r\n// - T_MAP - number of key/value pairs in the map;\r\n// - T_FUNCTION - number of arguments in the function;\r\nfunc (pdst *Value) Length() int {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t//args\r\n\tvar n C.INT\r\n\tr := C.ValueElementsCount(cpdst, &n)\r\n\tif r != C.UINT(HV_OK) {\r\n\t\t// in case of not being array/map etc.\r\n\t\treturn 0\r\n\t}\r\n\treturn int(n)\r\n}\r\n\r\n// UINT  ValueNthElementValue ( const VALUE* pval, INT n, VALUE* pretval) ;//{ return SAPI()->ValueNthElementValue ( pval, n, pretval); }\r\n\r\n// ValueNthElementValue - retreive value of sub-element at index n for:\r\n// - T_ARRAY - nth element of the array;\r\n// - T_MAP - value of nth key/value pair in the map;\r\n// - T_FUNCTION - value of nth argument of the function;\r\nfunc (pdst *Value) Index(n int) *Value {\r\n\tret := NewValue()\r\n\t//args\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcn := C.INT(n)\r\n\tcret := (*C.VALUE)(unsafe.Pointer(ret))\r\n\t// cgo call\r\n\tr := C.ValueNthElementValue(cpdst, cn, cret)\r\n\tif r != C.UINT(HV_OK) {\r\n\t\treturn nil\r\n\t}\r\n\treturn ret\r\n}\r\n\r\n// UINT  ValueNthElementValueSet ( VALUE* pval, INT n, const VALUE* pval_to_set) ;//{ return SAPI()->ValueNthElementValueSet ( pval,n,pval_to_set); }\r\n\r\n// ValueNthElementValueSet - sets value of sub-element at index n for:\r\n//  - T_ARRAY - nth element of the array;\r\n//  - T_MAP - value of nth key/value pair in the map;\r\n//  - T_FUNCTION - value of nth argument of the function;\r\n// If the VALUE is not of one of types above then it makes it of type T_ARRAY with\r\n// single element - 'val_to_set'.\r\nfunc (pdst *Value) SetIndex(idx int, val interface{}) error {\r\n\t// args\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcval := (*C.VALUE)(unsafe.Pointer(NewValue(val)))\r\n\t// cgo call\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueNthElementValueSet(cpdst, C.INT(idx), cval)), \"ValueNthElementValueSet\")\r\n}\r\n\r\nfunc (pdst *Value) Append(val interface{}) error {\r\n\tn := pdst.Length()\r\n\treturn pdst.SetIndex(n, val)\r\n}\r\n\r\n// UINT  ValueNthElementKey ( const VALUE* pval, INT n, VALUE* pretval) ;//{ return SAPI()->ValueNthElementKey ( pval,n,pretval); }\r\nfunc (pdst *Value) NthElementKey(idx int) (val *Value) {\r\n\tval = NewValue()\r\n\t// args\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcval := (*C.VALUE)(unsafe.Pointer(val))\r\n\t// cgo call\r\n\tr := C.ValueNthElementKey(cpdst, C.INT(idx), cval)\r\n\t// ret\r\n\tif r != C.UINT(HV_OK) {\r\n\t\treturn nil\r\n\t}\r\n\treturn val\r\n}\r\n\r\n/**Callback function used with #ValueEnumElements().\r\n * return TRUE to continue enumeration\r\n */\r\n// typedef BOOL SC_CALLBACK KeyValueCallback( LPVOID param, const VALUE* pkey, const VALUE* pval );\r\n\r\ntype KeyValueCallback func(key, value *Value) bool\r\n\r\n//export goKeyValueCallback\r\nfunc goKeyValueCallback(param unsafe.Pointer, key, value *Value) bool {\r\n\tfn := *(*KeyValueCallback)(param)\r\n\treturn fn(key, value)\r\n}\r\n\r\n/**\r\n * ValueEnumElements - enumeartes key/value pairs of T_MAP, T_FUNCTION and T_OBJECT values\r\n * - T_MAP - key of nth key/value pair in the map;\r\n * - T_FUNCTION - name of nth argument of the function (if any);\r\n */\r\n// UINT  ValueEnumElements ( VALUE* pval, KeyValueCallback* penum, LPVOID param) ;//{ return SAPI()->ValueEnumElements (pval,penum,param); }\r\nfunc (pdst *Value) EnumerateKeyValue(fn KeyValueCallback) error {\r\n\t// args\r\n\tcpval := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcpenum := (*C.KeyValueCallback)(unsafe.Pointer(C.KeyValueCallback_cgo))\r\n\tcparam := C.LPVOID(unsafe.Pointer(&fn))\r\n\t// cgo call\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueEnumElements(cpval, cpenum, cparam)), \"ValueEnumElements\")\r\n}\r\n\r\n// UINT  ValueSetValueToKey ( VALUE* pval, const VALUE* pkey, const VALUE* pval_to_set) ;//{ return SAPI()->ValueSetValueToKey ( pval, pkey, pval_to_set); }\r\n\r\n//  ValueSetValueToKey - sets value of sub-element by key:\r\n//\r\n//    - T_MAP - value of key/value pair with the key;\r\n//    - T_FUNCTION - value of argument with the name key;\r\n//    - T_OBJECT (tiscript) - value of property of the object\r\n//  If the VALUE is not of one of types above then it makes it of type T_MAP with\r\n//  single pair - 'key'/'val_to_set'.\r\n//\r\n//  key usually is a value of type T_STRING\r\nfunc (pdst *Value) Set(key string, val interface{}) error {\r\n\t// args\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcval := (*C.VALUE)(unsafe.Pointer(NewValue(val)))\r\n\tvkey := NewValue(key)\r\n\tckey := (*C.VALUE)(unsafe.Pointer(vkey))\r\n\t// cgo call\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueSetValueToKey(cpdst, ckey, cval)), \"ValueSetValueToKey\")\r\n}\r\n\r\n// UINT  ValueGetValueOfKey ( const VALUE* pval, const VALUE* pkey, VALUE* pretval) ;//{ return SAPI()->ValueGetValueOfKey ( pval, pkey,pretval); }\r\n\r\n// ValueGetValueOfKey - retrieves value of sub-element by key:\r\n//   - T_MAP - value of key/value pair with the key;\r\n//   - T_FUNCTION - value of argument with the name key;\r\n//   - T_OBJECT (tiscript) - value of property of the object\r\n// Otherwise *pretval will have T_UNDEFINED value.\r\nfunc (pdst *Value) Get(key string) (val *Value) {\r\n\tval = NewValue()\r\n\t// args\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tcval := (*C.VALUE)(unsafe.Pointer(val))\r\n\tvkey := NewValue(key)\r\n\tckey := (*C.VALUE)(unsafe.Pointer(vkey))\r\n\t// cgo call\r\n\tr := C.ValueGetValueOfKey(cpdst, ckey, cval)\r\n\t// ret\r\n\tif r != C.UINT(HV_OK) {\r\n\t\treturn nil\r\n\t}\r\n\treturn val\r\n}\r\n\r\n// UINT  ValueToString ( VALUE* pval, UINT how ) ;//{ return SAPI()->ValueToString ( pval,how ); }\r\n\r\n// ValueToString - converts value to T_STRING inplace:\r\n//   - CVT_SIMPLE - parse/emit terminal values (T_INT, T_FLOAT, T_LENGTH, T_STRING)\r\n//   - CVT_JSON_LITERAL - parse/emit value using JSON literal rules: {}, [], \"string\", true, false, null\r\n//   - CVT_JSON_MAP - parse/emit MAP value without enclosing '{' and '}' brackets.\r\nfunc (pdst *Value) ConvertToString(how ValueStringConvertType) error {\r\n\tcpdst := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t//args\r\n\tchow := C.UINT(how)\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueToString(cpdst, chow)), \"ValueToString\")\r\n}\r\n\r\n// UINT  ValueFromString ( VALUE* pval, LPCWSTR str, UINT strLength, UINT how ) ;//{ return SAPI()->ValueFromString ( pval, str,strLength,how ); }\r\n\r\n// ValueFromString - parses string into value:\r\n//  - CVT_SIMPLE - parse/emit terminal values (T_INT, T_FLOAT, T_LENGTH, T_STRING), \"guess\" non-strict parsing\r\n//  - CVT_JSON_LITERAL - parse/emit value using JSON literal rules: {}, [], \"string\", true, false, null\r\n//  - CVT_JSON_MAP - parse/emit MAP value without enclosing '{' and '}' brackets.\r\n// Returns:\r\n//   Number of non-parsed characters in case of errors. Thus if string was parsed in full it returns 0 (success)\r\nfunc (pdst *Value) ConvertFromString(str string, how ValueStringConvertType) error {\r\n\tcval := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// args\r\n\tu16, err := Utf16FromString(str)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tclen := C.UINT(len(u16) - 1)\r\n\tcstr := C.LPCWSTR(unsafe.Pointer(&u16[0]))\r\n\tchow := C.UINT(how)\r\n\t// cgo call\r\n\treturn wrapValueResult(VALUE_RESULT(C.ValueFromString(cval, cstr, clen, chow)), \"ValueFromString\")\r\n}\r\n\r\n// UINT  ValueInvoke ( VALUE* pval, VALUE* pthis, UINT argc, const VALUE* argv, VALUE* pretval, LPCWSTR url) ;//{ return SAPI()->ValueInvoke ( pval, pthis, argc, argv, pretval, url); }\r\n\r\n//ValueInvoke - function invocation (Sciter/TIScript). Usually as callbacks for asynchronous tasks\r\n//  - VALUE* pval is a value of type T_OBJECT/UT_OBJECT_FUNCTION\r\n//  - VALUE* self - object that will be known as 'this' inside that function.\r\n//                   'self' here is what will be known as 'this' inside the function,\r\n//                   can be undefined for invocations of global functions\r\n//  - UINT argc, const VALUE* argv - vector of arguments to pass to the function.\r\n//  - VALUE* pretval - parse/emit MAP value without enclosing '{' and '}' brackets.\r\n//  - LPCWSTR url - url or name of the script - used for error reporting in the script.\r\n//Returns:\r\n//  HV_OK, HV_BAD_PARAMETER or HV_INCOMPATIBLE_TYPE\r\nfunc (v *Value) Invoke(self *Value, nameOrUrl string, args ...*Value) (retval *Value, err error) {\r\n\tretval = NewValue()\r\n\targc := len(args)\r\n\targv := make([]Value, argc)\r\n\tfor i := 0; i < argc; i++ {\r\n\t\targv[i].Copy(args[i]) // Make copy that is not garbage collected\r\n\t\tdefer argv[i].finalize()\r\n\t}\r\n\t// args\r\n\tcv := (*C.SCITER_VALUE)(unsafe.Pointer(v))\r\n\tcself := (*C.SCITER_VALUE)(unsafe.Pointer(self))\r\n\tcargc := C.UINT(argc)\r\n\tvar cargv *C.SCITER_VALUE\r\n\tif len(argv) > 0 {\r\n\t\tcargv = (*C.SCITER_VALUE)(unsafe.Pointer(&argv[0]))\r\n\t}\r\n\tcretval := (*C.SCITER_VALUE)(unsafe.Pointer(retval))\r\n\tcnameOrUrl := C.LPCWSTR(StringToWcharPtr(nameOrUrl))\r\n\t// cgo call\r\n\tr := C.ValueInvoke(cv, cself, cargc, cargv, cretval, cnameOrUrl)\r\n\terr = wrapValueResult(VALUE_RESULT(r), \"ValueInvoke\")\r\n\treturn\r\n}\r\n\r\nvar (\r\n\tfunctorMap = make(map[unsafe.Pointer]NativeFunctor, 20)\r\n)\r\n\r\n// Native functor\r\n// typedef VOID NATIVE_FUNCTOR_INVOKE( VOID* tag, UINT argc, const VALUE* argv, VALUE* retval); // retval may contain error definition\r\n\r\n//export goNATIVE_FUNCTOR_INVOKE\r\nfunc goNATIVE_FUNCTOR_INVOKE(tag unsafe.Pointer, argc uint, argv unsafe.Pointer, retval unsafe.Pointer) uint {\r\n\tnf := functorMap[tag]\r\n\targs := make([]*Value, int(argc))\r\n\tstep := unsafe.Sizeof(Value{})\r\n\trval := (*Value)(retval)\r\n\tp := uintptr(argv)\r\n\tfor i := 0; i < int(argc); i++ {\r\n\t\targs[i] = (*Value)(unsafe.Pointer(p + uintptr(i)*step))\r\n\t}\r\n\tval := nf(args...)\r\n\trval.init()\r\n\trval.Copy(val)\r\n\treturn 1\r\n}\r\n\r\n//export goNATIVE_FUNCTOR_RELEASE\r\nfunc goNATIVE_FUNCTOR_RELEASE(tag unsafe.Pointer) int {\r\n\tdelete(functorMap, tag)\r\n\treturn 1\r\n}\r\n\r\nvar (\r\n\tpinvoke  = (*C.NATIVE_FUNCTOR_INVOKE)(unsafe.Pointer(C.NATIVE_FUNCTOR_INVOKE_cgo))\r\n\tprelease = (*C.NATIVE_FUNCTOR_RELEASE)(unsafe.Pointer(C.NATIVE_FUNCTOR_RELEASE_cgo))\r\n)\r\n\r\n// typedef VOID NATIVE_FUNCTOR_RELEASE( VOID* tag );\r\n\r\n// UINT  ValueNativeFunctorSet (VALUE* pval, NATIVE_FUNCTOR_INVOKE*  pinvoke, NATIVE_FUNCTOR_RELEASE* prelease, VOID* tag )\r\n\r\n//ValueNativeFunctorSet - set reference to native function\r\n//  - VALUE* pval - value to be initialized\r\n//  - NATIVE_FUNCTOR_INVOKE* pinvoke - reference to native functor implementation.\r\n//  - NATIVE_FUNCTOR_RELEASE* prelease - reference to native functor dtor implementation.\r\n//  - VOID* tag - optional tag, passed as it is to pinvoke and prelease\r\n//Returns:\r\n//  HV_OK, HV_BAD_PARAMETER\r\nfunc (pdst *Value) SetNativeFunctor(nf NativeFunctor) error {\r\n\ttag := unsafe.Pointer(&nf)\r\n\tfunctorMap[tag] = nf\r\n\t// args\r\n\tcval := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\t// cgo call\r\n\tr := C.ValueNativeFunctorSet(cval, pinvoke, prelease, tag)\r\n\treturn wrapValueResult(VALUE_RESULT(r), \"ValueNativeFunctorSet\")\r\n}\r\n\r\n// BOOL  ValueIsNativeFunctor ( const VALUE* pval) ;//{ return SAPI()->ValueIsNativeFunctor (pval); }\r\nfunc (pdst *Value) IsNativeFunctor() bool {\r\n\tcval := (*C.VALUE)(unsafe.Pointer(pdst))\r\n\tr := C.ValueIsNativeFunctor(cval)\r\n\tif r == 0 {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n"
        },
        {
          "name": "sciter_darwin.go",
          "type": "blob",
          "size": 0.703125,
          "content": "package sciter\n\n/*\n#cgo CFLAGS: -Iinclude\n#include \"sciter-x.h\"\n*/\nimport \"C\"\nimport (\n\t\"unsafe\"\n)\n\n// HWINDOW  SciterCreateWindow ( UINT creationFlags,LPRECT frame, SciterWindowDelegate* delegate, LPVOID delegateParam, HWINDOW parent);\n\n// rect is the display area\nfunc CreateWindow(createFlags WindowCreationFlag, rect *Rect, delegate uintptr, delegateParam uintptr, parent C.HWINDOW) C.HWINDOW {\n\t// set default size\n\tif rect == nil {\n\t\trect = DefaultRect\n\t}\n\t// create window\n\thwnd := C.SciterCreateWindow(\n\t\tC.UINT(createFlags),\n\t\t(*C.RECT)(unsafe.Pointer(rect)),\n\t\tnil,\n\t\t(C.LPVOID)(delegateParam),\n\t\tparent)\n\t// in case of NULL\n\tif int(uintptr(unsafe.Pointer(hwnd))) == 0 {\n\t\treturn BAD_HWINDOW\n\t}\n\treturn hwnd\n}\n"
        },
        {
          "name": "sciter_linux.go",
          "type": "blob",
          "size": 0.734375,
          "content": "package sciter\r\n\r\n/*\r\n#cgo CFLAGS: -Iinclude\r\n#include \"sciter-x.h\"\r\n*/\r\nimport \"C\"\r\nimport (\r\n\t\"unsafe\"\r\n)\r\n\r\n// HWINDOW  SciterCreateWindow ( UINT creationFlags,LPRECT frame, SciterWindowDelegate* delegate, LPVOID delegateParam, HWINDOW parent);\r\n\r\n// rect is the display area\r\nfunc CreateWindow(createFlags WindowCreationFlag, rect *Rect, delegate uintptr, delegateParam uintptr, parent C.HWINDOW) C.HWINDOW {\r\n\t// set default size\r\n\tif rect == nil {\r\n\t\trect = DefaultRect\r\n\t}\r\n\t// create window\r\n\thwnd := C.SciterCreateWindow(\r\n\t\tC.UINT(createFlags),\r\n\t\t(*C.RECT)(unsafe.Pointer(rect)),\r\n\t\tnil,\r\n\t\t(C.LPVOID)(delegateParam),\r\n\t\tparent)\r\n\t// in case of NULL\r\n\tif int(uintptr(unsafe.Pointer(hwnd))) == 0 {\r\n\t\treturn BAD_HWINDOW\r\n\t}\r\n\treturn hwnd\r\n}\r\n"
        },
        {
          "name": "sciter_windows.go",
          "type": "blob",
          "size": 2.091796875,
          "content": "package sciter\r\n\r\n/*\r\n#cgo CFLAGS: -Iinclude\r\n#include \"sciter-x.h\"\r\n*/\r\nimport \"C\"\r\nimport (\r\n\t\"github.com/lxn/win\"\r\n\t\"unsafe\"\r\n)\r\n\r\n// LRESULT  SciterProc (HWINDOW hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;//{ return SAPI()->SciterProc (hwnd,msg,wParam,lParam); }\r\n// LRESULT  SciterProcND (HWINDOW hwnd, UINT msg, WPARAM wParam, LPARAM lParam, BOOL* pbHandled) ;//{ return SAPI()->SciterProcND (hwnd,msg,wParam,lParam,pbHandled); }\r\n\r\nfunc ProcND(hwnd win.HWND, msg uint, wParam uintptr, lParam uintptr) (ret int, handled bool) {\r\n\tvar bHandled C.BOOL\r\n\t// ret = uintptr(syssciterProcND(HWND(hwnd), msg, wParam, lParam, &bHandled))\r\n\tret = int(C.SciterProcND(C.HWINDOW(unsafe.Pointer(hwnd)), C.UINT(msg), C.WPARAM(wParam), C.LPARAM(lParam), &bHandled))\r\n\tif bHandled == 0 {\r\n\t\thandled = false\r\n\t} else {\r\n\t\thandled = true\r\n\t}\r\n\treturn\r\n}\r\n\r\n// HWINDOW  SciterCreateWindow ( UINT creationFlags,LPRECT frame, SciterWindowDelegate* delegate, LPVOID delegateParam, HWINDOW parent);\r\n\r\n// Create sciter window.\r\n//   On Windows returns HWND of either top-level or child window created.\r\n//   On OS X returns NSView* of either top-level window or child view .\r\n//\r\n//  \\param[in] creationFlags \\b SCITER_CREATE_WINDOW_FLAGS, creation flags.\r\n//  \\param[in] frame \\b LPRECT, window frame position and size.\r\n//  \\param[in] delegate \\b SciterWindowDelegate, either partial WinProc implementation or thing implementing NSWindowDelegate protocol.\r\n//  \\param[in] delegateParam \\b LPVOID, optional param passed to SciterWindowDelegate.\r\n//  \\param[in] parent \\b HWINDOW, optional parent window.\r\n// rect is the display area\r\nfunc CreateWindow(createFlags WindowCreationFlag, rect *Rect, delegate uintptr, delegateParam uintptr, parent C.HWINDOW) C.HWINDOW {\r\n\t// set default size\r\n\tif rect == nil {\r\n\t\trect = DefaultRect\r\n\t}\r\n\t// create window\r\n\thwnd := C.SciterCreateWindow(\r\n\t\tC.UINT(createFlags),\r\n\t\t(*C.RECT)(unsafe.Pointer(rect)),\r\n\t\t(*C.SciterWindowDelegate)(unsafe.Pointer(delegate)),\r\n\t\t(C.LPVOID)(delegateParam),\r\n\t\tparent)\r\n\t// in case of NULL\r\n\tif int(uintptr(unsafe.Pointer(hwnd))) == 0 {\r\n\t\treturn BAD_HWINDOW\r\n\t}\r\n\treturn hwnd\r\n}\r\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 50.8642578125,
          "content": "package sciter\r\n\r\n/*\r\n#include \"sciter-x.h\"\r\n*/\r\nimport \"C\"\r\nimport (\r\n\t\"fmt\"\r\n\t\"unsafe\"\r\n)\r\n\r\n// enum SCITER_CREATE_WINDOW_FLAGS {\r\n//    SW_CHILD      = (1 << 0), // child window only, if this flag is set all other flags ignored\r\n//    SW_TITLEBAR   = (1 << 1), // toplevel window, has titlebar\r\n//    SW_RESIZEABLE = (1 << 2), // has resizeable frame\r\n//    SW_TOOL       = (1 << 3), // is tool window\r\n//    SW_CONTROLS   = (1 << 4), // has minimize / maximize buttons\r\n//    SW_GLASSY     = (1 << 5), // glassy window ( DwmExtendFrameIntoClientArea on windows )\r\n//    SW_ALPHA      = (1 << 6), // transparent window ( e.g. WS_EX_LAYERED on Windows )\r\n//    SW_MAIN       = (1 << 7), // main window of the app, will terminate the app on close\r\n//    SW_POPUP      = (1 << 8), // the window is created as topmost window.\r\n//    SW_ENABLE_DEBUG = (1 << 9), // make this window inspector ready\r\n//    SW_OWNS_VM      = (1 << 10), // it has its own script VM\r\n// };\r\ntype WindowCreationFlag uint32\r\n\r\nconst (\r\n\tSW_CHILD        WindowCreationFlag = (1 << iota) // child window only, if this flag is set all other flags ignored\r\n\tSW_TITLEBAR                                      // toplevel window, has titlebar\r\n\tSW_RESIZEABLE                                    // has resizeable frame\r\n\tSW_TOOL                                          // is tool window\r\n\tSW_CONTROLS                                      // has minimize / maximize buttons\r\n\tSW_GLASSY                                        // glassy window ( DwmExtendFrameIntoClientArea on windows )\r\n\tSW_ALPHA                                         // transparent window ( e.g. WS_EX_LAYERED on Windows )\r\n\tSW_MAIN                                          // main window of the app, will terminate the app on close\r\n\tSW_POPUP                                         // the window is created as topmost window.\r\n\tSW_ENABLE_DEBUG                                  // make this window inspector ready\r\n\tSW_OWNS_VM                                       // it has its own script VM\r\n)\r\n\r\nvar (\r\n\t// create an resizable main window with minimize/maximize controls\r\n\t// linux must use this combination to create the main window correctly\r\n\tDefaultWindowCreateFlag = SW_TITLEBAR | SW_RESIZEABLE | SW_CONTROLS | SW_MAIN | SW_ENABLE_DEBUG\r\n)\r\n\r\n// enum OUTPUT_SUBSYTEMS\r\nconst (\r\n\tOT_DOM  = iota // html parser & runtime\r\n\tOT_CSSS        // csss! parser & runtime\r\n\tOT_CSS         // css parser\r\n\tOT_TIS         // TIS parser & runtime\r\n)\r\n\r\n// enum OUTPUT_SEVERITY\r\nconst (\r\n\tOS_INFO = iota\r\n\tOS_WARNING\r\n\tOS_ERROR\r\n)\r\n\r\n// enum EVENT_GROUPS\r\nconst (\r\n\tHANDLE_INITIALIZATION = 0x0000 /** attached/detached */\r\n\tHANDLE_MOUSE          = 0x0001 /** mouse events */\r\n\tHANDLE_KEY            = 0x0002 /** key events */\r\n\tHANDLE_FOCUS          = 0x0004 /** focus events if this flag is set it also means that element it attached to is focusable */\r\n\tHANDLE_SCROLL         = 0x0008 /** scroll events */\r\n\tHANDLE_TIMER          = 0x0010 /** timer event */\r\n\tHANDLE_SIZE           = 0x0020 /** size changed event */\r\n\tHANDLE_DRAW           = 0x0040 /** drawing request (event) */\r\n\tHANDLE_DATA_ARRIVED   = 0x080  /** requested data () has been delivered */\r\n\tHANDLE_BEHAVIOR_EVENT = 0x0100 /** logical synthetic events:\r\n\tBUTTON_CLICK HYPERLINK_CLICK etc.\r\n\ta.k.a. notifications from intrinsic behaviors */\r\n\tHANDLE_METHOD_CALL           = 0x0200 /** behavior specific methods */\r\n\tHANDLE_SCRIPTING_METHOD_CALL = 0x0400 /** behavior specific methods */\r\n\tHANDLE_TISCRIPT_METHOD_CALL  = 0x0800 /** behavior specific methods using direct tiscript::value's */\r\n\r\n\tHANDLE_EXCHANGE = 0x1000 /** system drag-n-drop */\r\n\tHANDLE_GESTURE  = 0x2000 /** touch input events */\r\n\tHANDLE_SOM      = 0x8000 /** som_asset_t request */\r\n\r\n\tHANDLE_ALL = 0xFFFF /* all of them */\r\n\r\n\tSUBSCRIPTIONS_REQUEST = 0xFFFFFFFF /** special value for getting subscription flags */\r\n)\r\n\r\ntype PhaseMask uint32\r\n\r\n// enum PHASE_MASK\r\nconst (\r\n\tBUBBLING        = 0       // bubbling (emersion) phase\r\n\tSINKING         = 0x8000  // capture (immersion) phase, this flag is or'ed with EVENTS codes below\r\n\tHANDLED         = 0x10000 // a bubbling event consumed by some element\r\n\tSINKING_HANDLED = 0x18000 // a sinking event consumed by some child element\r\n\t// see: http://www.w3.org/TR/xml-events/Overview.html#s_intro\r\n)\r\n\r\ntype MouseButton uint32\r\n\r\n// enum MOUSE_BUTTONS\r\nconst (\r\n\tMAIN_MOUSE_BUTTON   MouseButton = 1 //aka left button\r\n\tPROP_MOUSE_BUTTON   MouseButton = 2 //aka right button\r\n\tMIDDLE_MOUSE_BUTTON MouseButton = 4\r\n)\r\n\r\ntype KeyboardState uint32\r\n\r\n// enum KEYBOARD_STATES\r\nconst (\r\n\tCONTROL_KEY_PRESSED KeyboardState = 0x1\r\n\tSHIFT_KEY_PRESSED   KeyboardState = 0x2\r\n\tALT_KEY_PRESSED     KeyboardState = 0x4\r\n)\r\n\r\n// parameters of evtg == HANDLE_INITIALIZATION\r\n// enum INITIALIZATION_EVENTS\r\nconst (\r\n\tBEHAVIOR_DETACH = 0\r\n\tBEHAVIOR_ATTACH = 1\r\n)\r\n\r\ntype DraggingType uint32\r\n\r\n// enum DRAGGING_TYPE\r\nconst (\r\n\tNO_DRAGGING = iota\r\n\tDRAGGING_MOVE\r\n\tDRAGGING_COPY\r\n)\r\n\r\ntype MouseEvent uint32\r\n\r\n// parameters of evtg == HANDLE_MOUSE\r\n// enum MOUSE_EVENTS\r\nconst (\r\n\tMOUSE_ENTER MouseEvent = iota\r\n\tMOUSE_LEAVE\r\n\tMOUSE_MOVE\r\n\tMOUSE_UP\r\n\tMOUSE_DOWN\r\n\tMOUSE_DCLICK\r\n\tMOUSE_WHEEL\r\n\tMOUSE_TICK // mouse pressed ticks\r\n\tMOUSE_IDLE // mouse stay idle for some time\r\n\r\n\tDROP         // item dropped target is that dropped item\r\n\tDRAG_ENTER   // drag arrived to the target element that is one of current drop targets.\r\n\tDRAG_LEAVE   // drag left one of current drop targets. target is the drop target element.\r\n\tDRAG_REQUEST // drag src notification before drag start. To cancel - return true from handler.\r\n\r\n\tMOUSE_CLICK MouseEvent = 0xFF // mouse click event\r\n\r\n\tDRAGGING MouseEvent = 0x100 // This flag is 'ORed' with MOUSE_ENTER..MOUSE_DOWN codes if dragging operation is in effect.\r\n\t// E.g. event DRAGGING | MOUSE_MOVE is sent to underlying DOM elements while dragging.\r\n)\r\n\r\ntype CursorType uint32\r\n\r\n// enum CURSOR_TYPE\r\nconst (\r\n\tCURSOR_ARROW       CursorType = iota //0\r\n\tCURSOR_IBEAM                         //1\r\n\tCURSOR_WAIT                          //2\r\n\tCURSOR_CROSS                         //3\r\n\tCURSOR_UPARROW                       //4\r\n\tCURSOR_SIZENWSE                      //5\r\n\tCURSOR_SIZENESW                      //6\r\n\tCURSOR_SIZEWE                        //7\r\n\tCURSOR_SIZENS                        //8\r\n\tCURSOR_SIZEALL                       //9\r\n\tCURSOR_NO                            //10\r\n\tCURSOR_APPSTARTING                   //11\r\n\tCURSOR_HELP                          //12\r\n\tCURSOR_HAND                          //13\r\n\tCURSOR_DRAG_MOVE                     //14\r\n\tCURSOR_DRAG_COPY                     //15\r\n)\r\n\r\ntype KeyEvent uint32\r\n\r\n// enum KEY_EVENTS\r\nconst (\r\n\tKEY_DOWN KeyEvent = iota\r\n\tKEY_UP\r\n\tKEY_CHAR\r\n)\r\n\r\ntype FocusEvent uint32\r\n\r\n// enum FOCUS_EVENTS\r\nconst (\r\n\tFOCUS_LOST FocusEvent = iota\r\n\tFOCUS_GOT\r\n)\r\n\r\ntype ScrollEvent uint32\r\n\r\n// enum SCROLL_EVENTS\r\nconst (\r\n\tSCROLL_HOME ScrollEvent = iota\r\n\tSCROLL_END\r\n\tSCROLL_STEP_PLUS\r\n\tSCROLL_STEP_MINUS\r\n\tSCROLL_PAGE_PLUS\r\n\tSCROLL_PAGE_MINUS\r\n\tSCROLL_POS\r\n\tSCROLL_SLIDER_RELEASED\r\n\tSCROLL_CORNER_PRESSED\r\n\tSCROLL_CORNER_RELEASED\r\n)\r\n\r\ntype GestureCmd uint32\r\n\r\n// enum GESTURE_CMD\r\nconst (\r\n\tGESTURE_REQUEST GestureCmd = iota // return true and fill flags if it will handle gestures.\r\n\tGESTURE_ZOOM                      // The zoom gesture.\r\n\tGESTURE_PAN                       // The pan gesture.\r\n\tGESTURE_ROTATE                    // The rotation gesture.\r\n\tGESTURE_TAP1                      // The tap gesture.\r\n\tGESTURE_TAP2                      // The two-finger tap gesture.\r\n)\r\n\r\ntype GestureState uint32\r\n\r\n// enum GESTURE_STATE\r\nconst (\r\n\tGESTURE_STATE_BEGIN   GestureState = 1 // starts\r\n\tGESTURE_STATE_INERTIA GestureState = 2 // events generated by inertia processor\r\n\tGESTURE_STATE_END     GestureState = 4 // end last event of the gesture sequence\r\n)\r\n\r\ntype GestureTypeFlag uint32\r\n\r\n// enum GESTURE_TYPE_FLAGS // requested\r\nconst (\r\n\tGESTURE_FLAG_ZOOM                          GestureTypeFlag = 0x0001\r\n\tGESTURE_FLAG_ROTATE                        GestureTypeFlag = 0x0002\r\n\tGESTURE_FLAG_PAN_VERTICAL                  GestureTypeFlag = 0x0004\r\n\tGESTURE_FLAG_PAN_HORIZONTALGestureTypeFlag                 = 0x0008\r\n\tGESTURE_FLAG_TAP1                          GestureTypeFlag = 0x0010 // press & tap\r\n\tGESTURE_FLAG_TAP2                          GestureTypeFlag = 0x0020 // two fingers tap\r\n\r\n\tGESTURE_FLAG_PAN_WITH_GUTTER  GestureTypeFlag = 0x4000 // PAN_VERTICAL and PAN_HORIZONTAL modifiers\r\n\tGESTURE_FLAG_PAN_WITH_INERTIA GestureTypeFlag = 0x8000 //\r\n\tGESTURE_FLAGS_ALL             GestureTypeFlag = 0xFFFF //\r\n)\r\n\r\ntype DrawEvent uint32\r\n\r\n// enum DRAW_EVENTS\r\nconst (\r\n\tDRAW_CONTENT    DrawEvent = 1\r\n\tDRAW_FOREGROUND DrawEvent = 2\r\n)\r\n\r\n// enum CONTENT_CHANGE_BITS {  // for CONTENT_CHANGED reason\r\nconst (\r\n\tCONTENT_ADDED   = 0x01\r\n\tCONTENT_REMOVED = 0x02\r\n)\r\n\r\ntype BehaviorEvent uint32\r\n\r\n// enum BEHAVIOR_EVENTS\r\nconst (\r\n\tBUTTON_CLICK             BehaviorEvent = 0 // click on button\r\n\tBUTTON_PRESS             BehaviorEvent = 1 // mouse down or key down in button\r\n\tBUTTON_STATE_CHANGED     BehaviorEvent = 2 // checkbox/radio/slider changed its state/value\r\n\tEDIT_VALUE_CHANGING      BehaviorEvent = 3 // before text change\r\n\tEDIT_VALUE_CHANGED       BehaviorEvent = 4 // after text change\r\n\tSELECT_SELECTION_CHANGED BehaviorEvent = 5 // selection in <select> changed\r\n\tSELECT_STATE_CHANGED     BehaviorEvent = 6 // node in select expanded/collapsed heTarget is the node\r\n\r\n\tPOPUP_REQUEST BehaviorEvent = 7 // request to show popup just received\r\n\t//     here DOM of popup element can be modifed.\r\n\tPOPUP_READY BehaviorEvent = 8 // popup element has been measured and ready to be shown on screen\r\n\t//     here you can use functions like ScrollToView.\r\n\tPOPUP_DISMISSED BehaviorEvent = 9 // popup element is closed\r\n\t//     here DOM of popup element can be modifed again - e.g. some items can be removed\r\n\t//     to free memory.\r\n\r\n\tMENU_ITEM_ACTIVE BehaviorEvent = 0xA // menu item activated by mouse hover or by keyboard\r\n\tMENU_ITEM_CLICK  BehaviorEvent = 0xB // menu item click\r\n\t//   BEHAVIOR_EVENT_PARAMS structure layout\r\n\t//   BEHAVIOR_EVENT_PARAMS.cmd - MENU_ITEM_CLICK/MENU_ITEM_ACTIVE\r\n\t//   BEHAVIOR_EVENT_PARAMS.heTarget - owner(anchor) of the menu\r\n\t//   BEHAVIOR_EVENT_PARAMS.he - the menu item presumably <li> element\r\n\t//   BEHAVIOR_EVENT_PARAMS.reason - BY_MOUSE_CLICK | BY_KEY_CLICK\r\n\r\n\tCONTEXT_MENU_REQUEST BehaviorEvent = 0x10 // \"right-click\" BEHAVIOR_EVENT_PARAMS::he is current popup menu HELEMENT being processed or NULL.\r\n\t// application can provide its own HELEMENT here (if it is NULL) or modify current menu element.\r\n\r\n\tVISIUAL_STATUS_CHANGED  BehaviorEvent = 0x11 // broadcast notification sent to all elements of some container being shown or hidden\r\n\tDISABLED_STATUS_CHANGED BehaviorEvent = 0x12 // broadcast notification sent to all elements of some container that got new value of :disabled state\r\n\r\n\tPOPUP_DISMISSING BehaviorEvent = 0x13 // popup is about to be closed\r\n\r\n\tCONTENT_CHANGED BehaviorEvent = 0x15 // content has been changed is posted to the element that gets content changed  reason is combination of CONTENT_CHANGE_BITS.\r\n\t// target == NULL means the window got new document and this event is dispatched only to the window.\r\n\r\n\t// \"grey\" event codes  - notfications from behaviors from this SDK\r\n\tHYPERLINK_CLICK BehaviorEvent = 0x80 // hyperlink click\r\n\r\n\t//TABLE_HEADER_CLICK            // click on some cell in table header\r\n\t//                               //     target = the cell\r\n\t//                               //     reason = index of the cell (column number 0..n)\r\n\t//TABLE_ROW_CLICK               // click on data row in the table target is the row\r\n\t//                               //     target = the row\r\n\t//                               //     reason = index of the row (fixed_rows..n)\r\n\t//TABLE_ROW_DBL_CLICK           // mouse dbl click on data row in the table target is the row\r\n\t//                               //     target = the row\r\n\t//                               //     reason = index of the row (fixed_rows..n)\r\n)\r\n\r\nconst (\r\n\tELEMENT_COLLAPSED BehaviorEvent = iota + 0x90 // element was collapsed so far only behavior:tabs is sending these two to the panels\r\n\tELEMENT_EXPANDED                              // element was expanded\r\n\r\n\tACTIVATE_CHILD // activate (select) child\r\n\t// used for example by accesskeys behaviors to send activation request e.g. tab on behavior:tabs.\r\n\r\n\t//DO_SWITCH_TAB = ACTIVATE_CHILD// command to switch tab programmatically handled by behavior:tabs\r\n\t//                               // use it as HTMLayoutPostEvent(tabsElementOrItsChild DO_SWITCH_TAB tabElementToShow 0);\r\n\r\n\tINIT_DATA_VIEW // request to virtual grid to initialize its view\r\n\r\n\tROWS_DATA_REQUEST // request from virtual grid to data source behavior to fill data in the table\r\n\t// parameters passed throug DATA_ROWS_PARAMS structure.\r\n\r\n\tUI_STATE_CHANGED // ui state changed observers shall update their visual states.\r\n\t// is sent for example by behavior:richtext when caret position/selection has changed.\r\n\r\n\tFORM_SUBMIT // behavior:form detected submission event. BEHAVIOR_EVENT_PARAMS::data field contains data to be posted.\r\n\t// BEHAVIOR_EVENT_PARAMS::data is of type T_MAP in this case key/value pairs of data that is about\r\n\t// to be submitted. You can modify the data or discard submission by returning true from the handler.\r\n\tFORM_RESET // behavior:form detected reset event (from button type=reset). BEHAVIOR_EVENT_PARAMS::data field contains data to be reset.\r\n\t// BEHAVIOR_EVENT_PARAMS::data is of type T_MAP in this case key/value pairs of data that is about\r\n\t// to be rest. You can modify the data or discard reset by returning true from the handler.\r\n\r\n\tDOCUMENT_COMPLETE // document in behavior:frame or root document is complete.\r\n\r\n\tHISTORY_PUSH // requests to behavior:history (commands)\r\n\tHISTORY_DROP\r\n\tHISTORY_PRIOR\r\n\tHISTORY_NEXT\r\n\tHISTORY_STATE_CHANGED // behavior:history notification - history stack has changed\r\n\r\n\tCLOSE_POPUP     // close popup request\r\n\tREQUEST_TOOLTIP // request tooltip evt.source <- is the tooltip element.\r\n\r\n\tANIMATION BehaviorEvent = 0xA0 // animation started (reason=1) or ended(reason=0) on the element.\r\n\r\n\tDOCUMENT_CREATED       BehaviorEvent = 0xC0 // document created script namespace initialized. target -> the document\r\n\tDOCUMENT_CLOSE_REQUEST BehaviorEvent = 0xC1 // document is about to be closed to cancel closing do: evt.data = sciter::value(\"cancel\");\r\n\tDOCUMENT_CLOSE         BehaviorEvent = 0xC2 // last notification before document removal from the DOM\r\n\tDOCUMENT_READY         BehaviorEvent = 0xC3 // document has got DOM structure styles and behaviors of DOM elements. Script loading run is complete at this moment.\r\n\r\n\tVIDEO_INITIALIZED BehaviorEvent = 0xD1 // <video> \"ready\" notification\r\n\tVIDEO_STARTED     BehaviorEvent = 0xD2 // <video> playback started notification\r\n\tVIDEO_STOPPED     BehaviorEvent = 0xD3 // <video> playback stoped/paused notification\r\n\tVIDEO_BIND_RQ     BehaviorEvent = 0xD4 // <video> request for frame source binding\r\n\t//   If you want to provide your own video frames source for the given target <video> element do the following:\r\n\t//   1. Handle and consume this VIDEO_BIND_RQ request\r\n\t//   2. You will receive second VIDEO_BIND_RQ request/event for the same <video> element\r\n\t//      but this time with the 'reason' field set to an instance of sciter::video_destination interface.\r\n\t//   3. add_ref() it and store it for example in worker thread producing video frames.\r\n\t//   4. call sciter::video_destination::start_streaming(...) providing needed parameters\r\n\t//      call sciter::video_destination::render_frame(...) as soon as they are available\r\n\t//      call sciter::video_destination::stop_streaming() to stop the rendering (a.k.a. end of movie reached)\r\n\r\n\tFIRST_APPLICATION_EVENT_CODE = 0x100\r\n\t// all custom event codes shall be greater\r\n\t// than this number. All codes below this will be used\r\n\t// solely by application - HTMLayout will not intrepret it\r\n\t// and will do just dispatching.\r\n\t// To send event notifications with  these codes use\r\n\t// HTMLayoutSend/PostEvent API.\r\n)\r\n\r\ntype EventReason uint\r\n\r\n// enum EVENT_REASON\r\nconst (\r\n\tBY_MOUSE_CLICK EventReason = iota\r\n\tBY_KEY_CLICK\r\n\tSYNTHESIZED // synthesized programmatically generated.\r\n\tBY_MOUSE_ON_ICON\r\n)\r\n\r\ntype EditChangedReason uint\r\n\r\n// enum EDIT_CHANGED_REASON\r\nconst (\r\n\tBY_INS_CHAR  EditChangedReason = iota // single char insertion\r\n\tBY_INS_CHARS                          // character range insertion clipboard\r\n\tBY_DEL_CHAR                           // single char deletion\r\n\tBY_DEL_CHARS                          // character range deletion (selection)\r\n\tBY_UNDO_REDO                          // undo/redo\r\n)\r\n\r\ntype BehaviorMethodIdentifier uint32\r\n\r\n// enum BEHAVIOR_METHOD_IDENTIFIERS\r\nconst (\r\n\tDO_CLICK BehaviorMethodIdentifier = iota\r\n\tGET_TEXT_VALUE\r\n\tSET_TEXT_VALUE\r\n\t// p - TEXT_VALUE_PARAMS\r\n\r\n\tTEXT_EDIT_GET_SELECTION\r\n\t// p - TEXT_EDIT_SELECTION_PARAMS\r\n\r\n\tTEXT_EDIT_SET_SELECTION\r\n\t// p - TEXT_EDIT_SELECTION_PARAMS\r\n\r\n\t// Replace selection content or insert text at current caret position.\r\n\t// Replaced text will be selected.\r\n\tTEXT_EDIT_REPLACE_SELECTION\r\n\t// p - TEXT_EDIT_REPLACE_SELECTION_PARAMS\r\n\r\n\t// Set value of type=\"vscrollbar\"/\"hscrollbar\"\r\n\tSCROLL_BAR_GET_VALUE\r\n\tSCROLL_BAR_SET_VALUE\r\n\r\n\tTEXT_EDIT_GET_CARET_POSITION\r\n\tTEXT_EDIT_GET_SELECTION_TEXT // p - TEXT_SELECTION_PARAMS\r\n\tTEXT_EDIT_GET_SELECTION_HTML // p - TEXT_SELECTION_PARAMS\r\n\tTEXT_EDIT_CHAR_POS_AT_XY     // p - TEXT_EDIT_CHAR_POS_AT_XY_PARAMS\r\n\r\n\tIS_EMPTY  BehaviorMethodIdentifier = 0xFC // p - IS_EMPTY_PARAMS // set VALUE_PARAMS::is_empty (false/true) reflects :empty state of the element.\r\n\tGET_VALUE BehaviorMethodIdentifier = 0xFD // p - VALUE_PARAMS\r\n\tSET_VALUE BehaviorMethodIdentifier = 0xFE // p - VALUE_PARAMS\r\n\r\n\tFIRST_APPLICATION_METHOD_ID BehaviorMethodIdentifier = 0x100\r\n)\r\n\r\n// enum VALUE_TYPE\r\nconst (\r\n\tT_UNDEFINED = iota\r\n\tT_NULL\r\n\tT_BOOL\r\n\tT_INT\r\n\tT_FLOAT\r\n\tT_STRING\r\n\tT_DATE     // INT64 - contains a 64-bit value representing the number of 100-nanosecond intervals since January 1 1601 (UTC) a.k.a. FILETIME on Windows\r\n\tT_CURRENCY // INT64 - 14.4 fixed number. E.g. dollars = int64 / 10000;\r\n\tT_LENGTH   // length units value is int or float units are VALUE_UNIT_TYPE\r\n\tT_ARRAY\r\n\tT_MAP\r\n\tT_FUNCTION\r\n\tT_BYTES      // sequence of bytes - e.g. image data\r\n\tT_OBJECT     // scripting object proxy (TISCRIPT/SCITER)\r\n\tT_DOM_OBJECT // DOM object (CSSS!) use get_object_data to get HELEMENT\r\n\tT_RESOURCE   // 15 - other thing derived from tool::resource\r\n\tT_RANGE      // 16 - N..M, integer range.\r\n\tT_DURATION   // double, seconds\r\n\tT_ANGLE      // double, radians\r\n\tT_COLOR      // [unsigned] INT, ABGR\r\n\tT_ENUM\r\n\tT_ASSET // sciter::om::iasset* add_ref'ed pointer\r\n)\r\n\r\n// enum VALUE_UNIT_TYPE\r\nconst (\r\n\tUT_EM     = 1 //height of the element's font.\r\n\tUT_EX     = 2 //height of letter 'x'\r\n\tUT_PR     = 3 //%\r\n\tUT_SP     = 4 //%% \"springs\" a.k.a. flex units\r\n\treserved1 = 5\r\n\treserved2 = 6\r\n\tUT_PX     = 7  //pixels\r\n\tUT_IN     = 8  //inches (1 inch = 2.54 centimeters).\r\n\tUT_CM     = 9  //centimeters.\r\n\tUT_MM     = 10 //millimeters.\r\n\tUT_PT     = 11 //points (1 point = 1/72 inches).\r\n\tUT_PC     = 12 //picas (1 pica = 12 points).\r\n\tUT_DIP    = 13\r\n\treserved3 = 14\r\n\tUT_COLOR  = 15     // color in int\r\n\tUT_URL    = 16     // url in string\r\n\tUT_SYMBOL = 0xFFFF // for T_STRINGs designates symbol string ( so called NAME_TOKEN - CSS or JS identifier )\r\n)\r\n\r\n// enum VALUE_UNIT_TYPE_DATE\r\nconst (\r\n\tDT_HAS_DATE    = 0x01 // date contains date portion\r\n\tDT_HAS_TIME    = 0x02 // date contains time portion HH:MM\r\n\tDT_HAS_SECONDS = 0x04 // date contains time and seconds HH:MM:SS\r\n\tDT_UTC         = 0x10 // T_DATE is known to be UTC. Otherwise it is local date/time\r\n)\r\n\r\n// Sciter or TIScript specific\r\n// enum VALUE_UNIT_TYPE_OBJECT\r\nconst (\r\n\tUT_OBJECT_ARRAY    = 0 // type T_OBJECT of type Array\r\n\tUT_OBJECT_OBJECT   = 1 // type T_OBJECT of type Object\r\n\tUT_OBJECT_CLASS    = 2 // type T_OBJECT of type Type (class or namespace)\r\n\tUT_OBJECT_NATIVE   = 3 // type T_OBJECT of native Type with data slot (LPVOID)\r\n\tUT_OBJECT_FUNCTION = 4 // type T_OBJECT of type Function\r\n\tUT_OBJECT_ERROR    = 5 // type T_OBJECT of type Error\r\n)\r\n\r\n// enum VALUE_UNIT_UNDEFINED\r\nconst (\r\n\tUT_NOTHING = 1\r\n)\r\n\r\ntype ValueStringConvertType uint32\r\n\r\n// enum VALUE_STRING_CVT_TYPE\r\nconst (\r\n\tCVT_SIMPLE        ValueStringConvertType = iota ///< simple conversion of terminal values\r\n\tCVT_JSON_LITERAL                                ///< json literal parsing/emission\r\n\tCVT_JSON_MAP                                    ///< json parsing/emission it parses as if token '{' already recognized\r\n\tCVT_XJSON_LITERAL                               ///< x-json parsing/emission, date is emitted as ISO8601 date literal, currency is emitted in the form DDDD$CCC\r\n)\r\n\r\ntype SET_ELEMENT_HTML int32\r\n\r\n// enum SET_ELEMENT_HTML\r\nconst (\r\n\tSIH_REPLACE_CONTENT   SET_ELEMENT_HTML = 0\r\n\tSIH_INSERT_AT_START   SET_ELEMENT_HTML = 1\r\n\tSIH_APPEND_AFTER_LAST SET_ELEMENT_HTML = 2\r\n\tSOH_REPLACE           SET_ELEMENT_HTML = 3\r\n\tSOH_INSERT_BEFORE     SET_ELEMENT_HTML = 4\r\n\tSOH_INSERT_AFTER      SET_ELEMENT_HTML = 5\r\n)\r\n\r\ntype InitializationParams struct {\r\n\tCmd uint32\r\n}\r\n\r\ntype MouseParams struct {\r\n\tCmd         MouseEvent // MouseEvents\r\n\tTarget      C.HELEMENT\r\n\tPos         Point\r\n\tDocumentPos Point\r\n\tButtonState MouseButton\r\n\tAltState    KeyboardState\r\n\tCursorType  CursorType\r\n\tIsOnIcon    int32\r\n\r\n\tDragging     C.HELEMENT\r\n\tDraggingMode DraggingType\r\n}\r\n\r\ntype KeyParams struct {\r\n\tCmd      KeyEvent // KeyEvents\r\n\tTarget   C.HELEMENT\r\n\tKeyCode  uint32\r\n\tAltState KeyboardState\r\n}\r\n\r\ntype FocusParams struct {\r\n\tCmd          FocusEvent // FocusEvents\r\n\tTarget       C.HELEMENT\r\n\tByMouseClick int32 // boolean // true if focus is being set by mouse click\r\n\tCancel       int32 // boolean // in FOCUS_LOST phase setting this field to true will cancel transfer focus from old element to the new one.\r\n}\r\n\r\ntype DrawParams struct {\r\n\tCmd      DrawEvent // DrawEvents\r\n\tHdc      uintptr\r\n\tArea     Rect\r\n\treserved uint32\r\n}\r\n\r\ntype TimerParams struct {\r\n\tTimerId uintptr\r\n}\r\n\r\n// typedef struct BEHAVIOR_EVENT_PARAMS\r\n// {\r\n//   UINT     cmd;        // BEHAVIOR_EVENTS\r\n//   HELEMENT heTarget;   // target element handler, in MENU_ITEM_CLICK this is owner element that caused this menu - e.g. context menu owner\r\n//                        // In scripting this field named as Event.owner\r\n//   HELEMENT he;         // source element e.g. in SELECTION_CHANGED it is new selected <option>, in MENU_ITEM_CLICK it is menu item (LI) element\r\n//   UINT_PTR reason;     // EVENT_REASON or EDIT_CHANGED_REASON - UI action causing change.\r\n//                        // In case of custom event notifications this may be any\r\n//                        // application specific value.\r\n//   SCITER_VALUE\r\n//            data;       // auxiliary data accompanied with the event. E.g. FORM_SUBMIT event is using this field to pass collection of values.\r\n// } BEHAVIOR_EVENT_PARAMS;\r\ntype BehaviorEventParams C.BEHAVIOR_EVENT_PARAMS\r\n\r\nfunc (b *BehaviorEventParams) Cmd() BehaviorEvent {\r\n\treturn BehaviorEvent(b.cmd & 0xFFF)\r\n}\r\n\r\nfunc (b *BehaviorEventParams) Phase() PhaseMask {\r\n\treturn PhaseMask(b.cmd & 0xFFFFF000)\r\n}\r\n\r\ntype MethodParams struct {\r\n\tMethodId BehaviorMethodIdentifier\r\n\t// Text     *uint16\r\n\t// Length   uint32\r\n}\r\n\r\n// typedef struct SCRIPTING_METHOD_PARAMS\r\n// {\r\n//     LPCSTR        name;   //< method name\r\n//     SCITER_VALUE* argv;   //< vector of arguments\r\n//     UINT          argc;   //< argument count\r\n//     SCITER_VALUE  result; //< return value\r\n// } SCRIPTING_METHOD_PARAMS;\r\n\r\ntype ScriptingMethodParams C.SCRIPTING_METHOD_PARAMS\r\n\r\nfunc (s *ScriptingMethodParams) Name() string {\r\n\treturn C.GoString(s.name)\r\n}\r\n\r\nfunc (s *ScriptingMethodParams) Argc() int {\r\n\treturn int(s.argc)\r\n}\r\n\r\nfunc (r *ScriptingMethodParams) Args() []*Value {\r\n\targs := make([]*Value, 0)\r\n\tstep := unsafe.Sizeof(r.result)\r\n\tfor i := 0; i < int(r.Argc()); i++ {\r\n\t\tp := uintptr(unsafe.Pointer(r.argv)) + uintptr(i)*step\r\n\t\targs = append(args, (*Value)(unsafe.Pointer(p)))\r\n\t}\r\n\treturn args\r\n}\r\n\r\nfunc (r *ScriptingMethodParams) Arg(i int) *Value {\r\n\tif i >= int(r.Argc()) {\r\n\t\tpanic(\"ScriptingMethodParams arg index out of range\")\r\n\t}\r\n\tp := uintptr(unsafe.Pointer(r.argv)) + uintptr(i)*unsafe.Sizeof(r.result)\r\n\treturn (*Value)(unsafe.Pointer(p))\r\n}\r\n\r\n// set the return val for the scripting func\r\n// if not set return undefined\r\nfunc (s *ScriptingMethodParams) Return(val interface{}) {\r\n\tv := (*Value)(unsafe.Pointer(&(s.result)))\r\n\tv.init()\r\n\tv.Assign(val)\r\n}\r\n\r\ntype PTiscriptVM uintptr\r\ntype HVM PTiscriptVM\r\n\r\n// // tiscript_value\r\n// typedef UINT64 tiscript_value;\r\ntype TiscriptValue uint64\r\n\r\n// // pinned tiscript_value, val here will survive GC.\r\n// typedef struct tiscript_pvalue\r\n// {\r\n//    tiscript_value val;\r\n//    struct tiscript_VM* vm;\r\n//    void *d1,*d2;\r\n// } tiscript_pvalue;\r\ntype TiscriptPvalue struct {\r\n\tVal    TiscriptValue\r\n\tVM     HVM\r\n\td1, d2 uintptr\r\n}\r\n\r\n// typedef struct TISCRIPT_METHOD_PARAMS\r\n// {\r\n//     tiscript_VM*   vm;\r\n//     tiscript_value tag;    //< method id (symbol)\r\n//     tiscript_value result; //< return value\r\n//     // parameters are accessible through tiscript::args.\r\n// } TISCRIPT_METHOD_PARAMS;\r\ntype TiscriptMethodParams struct {\r\n\t// tiscript_VM    *vm\r\n\tVM HVM\r\n\t// tiscript_value tag    //< method id (symbol)\r\n\tTag TiscriptValue\r\n\t// tiscript_value result //< return value\r\n\tResult TiscriptValue\r\n}\r\n\r\n// typedef struct DATA_ARRIVED_PARAMS\r\n// {\r\n//     HELEMENT  initiator;    // element intiator of HTMLayoutRequestElementData request,\r\n//     LPCBYTE   data;         // data buffer\r\n//     UINT      dataSize;     // size of data\r\n//     UINT      dataType;     // data type passed \"as is\" from HTMLayoutRequestElementData\r\n//     UINT      status;       // status = 0 (dataSize == 0) - unknown error.\r\n//                             // status = 100..505 - http response status, Note: 200 - OK!\r\n//                             // status > 12000 - wininet error code, see ERROR_INTERNET_*** in wininet.h\r\n//     LPCWSTR   uri;          // requested url\r\n// } DATA_ARRIVED_PARAMS;\r\ntype DataArrivedParams C.DATA_ARRIVED_PARAMS\r\n\r\n// type DataArrivedParams struct {\r\n// \tInitiator C.HELEMENT\r\n// \tdata      *byte\r\n// \tDataSize  uint32\r\n// \tDataType  uint32\r\n// \tStatus    uint32\r\n// \turi       *uint16 // Wide character string\r\n// }\r\n\r\nfunc (d *DataArrivedParams) Uri() string {\r\n\treturn Utf16ToString((*uint16)(unsafe.Pointer(d.uri)))\r\n}\r\n\r\nfunc (d *DataArrivedParams) Data() []byte {\r\n\treturn BytePtrToBytes((*byte)(unsafe.Pointer(d.data)), uint(d.dataSize))\r\n}\r\n\r\n// struct SCROLL_PARAMS\r\n// {\r\n//   UINT      cmd;          // SCROLL_EVENTS\r\n//   HELEMENT  target;       // target element\r\n//   INT       pos;          // scroll position if SCROLL_POS\r\n//   BOOL      vertical;     // true if from vertical scrollbar\r\n// };\r\ntype ScrollParams struct {\r\n\tCmd      ScrollEvent\r\n\tTarget   C.HELEMENT\r\n\tPos      int32\r\n\tVertical int32 // bool\r\n}\r\n\r\n// enum EXCHANGE_CMD {\r\n// \tX_DRAG_ENTER = 0,       // drag enters the element\r\n// \tX_DRAG_LEAVE = 1,       // drag leaves the element\r\n// \tX_DRAG = 2,             // drag over the element\r\n// \tX_DROP = 3,             // data dropped on the element\r\n// \tX_PASTE = 4,            // N/A\r\n// \tX_DRAG_REQUEST = 5,     // N/A\r\n// \tX_DRAG_CANCEL = 6,      // drag cancelled (e.g. by pressing VK_ESCAPE)\r\n// \tX_WILL_ACCEPT_DROP = 7, // drop target element shall consume this event in order to receive X_DROP\r\n// };\r\ntype ExchangeCmd uint32\r\n\r\nconst (\r\n\tX_DRAG_ENTER ExchangeCmd = iota\r\n\tX_DRAG_LEAVE\r\n\tX_DRAG\r\n\tX_DROP\r\n\tX_PASTE\r\n\tX_DRAG_REQUEST\r\n\tX_DRAG_CANCEL\r\n\tX_WILL_ACCEPT_DROP\r\n)\r\n\r\n// enum DD_MODES {\r\n// \tDD_MODE_NONE = 0, // DROPEFFECT_NONE\t( 0 )\r\n// \tDD_MODE_COPY = 1, // DROPEFFECT_COPY\t( 1 )\r\n// \tDD_MODE_MOVE = 2, // DROPEFFECT_MOVE\t( 2 )\r\n// \tDD_MODE_COPY_OR_MOVE = 3, // DROPEFFECT_COPY\t( 1 ) | DROPEFFECT_MOVE\t( 2 )\r\n// \tDD_MODE_LINK = 4, // DROPEFFECT_LINK\t( 4 )\r\n// };\r\ntype DDMode uint32\r\n\r\nconst (\r\n\tDD_MODE_NONE DDMode = 0\r\n\tDD_MODE_COPY\r\n\tDD_MODE_MOVE\r\n\tDD_MODE_COPY_OR_MOVE\r\n\tDD_MODE_LINK\r\n)\r\n\r\n// struct EXCHANGE_PARAMS\r\n// {\r\n//   UINT         cmd;          // EXCHANGE_EVENTS\r\n//   HELEMENT     target;       // target element\r\n//   HELEMENT     source;       // source element (can be null if D&D from external window)\r\n//   POINT        pos;          // position of cursor, element relative\r\n//   POINT        pos_view;     // position of cursor, view relative\r\n//   UINT         mode;         // DD_MODE\r\n//   SCITER_VALUE data;         // packaged drag data\r\n// };\r\ntype ExchangeParams struct {\r\n\tCmd     ExchangeCmd\r\n\tTarget  C.HELEMENT\r\n\tSource  C.HELEMENT\r\n\tPos     Point\r\n\tPosView Point\r\n\tMode    DDMode\r\n\tData    Value\r\n}\r\n\r\n// struct GESTURE_PARAMS\r\n// {\r\n// UINT      cmd;          // GESTURE_EVENTS\r\n// HELEMENT  target;       // target element\r\n// POINT     pos;          // position of cursor, element relative\r\n// POINT     pos_view;     // position of cursor, view relative\r\n// UINT      flags;        // for GESTURE_REQUEST combination of GESTURE_FLAGs.\r\n//                         // for others it is a combination of GESTURE_STATe's\r\n// UINT      delta_time;   // period of time from previous event.\r\n// SIZE      delta_xy;     // for GESTURE_PAN it is a direction vector\r\n// double    delta_v;      // for GESTURE_ROTATE - delta angle (radians)\r\n//                         // for GESTURE_ZOOM - zoom value, is less or greater than 1.0\r\n// };\r\ntype GestureParams struct {\r\n\tCmd       GestureCmd\r\n\tTarget    C.HELEMENT\r\n\tPos       Point\r\n\tPosView   Point\r\n\tFlags     uint32\r\n\tDeltaTime uint32\r\n\tDeltaXY   Size\r\n\tDeltaV    float64\r\n}\r\n\r\ntype SomEvents uint32\r\n\r\nconst (\r\n\tSOM_GET_PASSPORT = 0\r\n\tSOM_GET_ASSET    = 1\r\n)\r\n\r\ntype SomParams C.SOM_PARAMS\r\n\r\nconst (\r\n\tLOAD_OK      = 0 // do default loading if data not set\r\n\tLOAD_DISCARD = 1 // discard request completely\r\n\tLOAD_DELAYED = 2 // data will be delivered later by the host application.\r\n)\r\n\r\nconst (\r\n\t/**Notifies that Sciter is about to download a referred resource.\r\n\t *\r\n\t * \\param lParam #LPSCN_LOAD_DATA.\r\n\t * \\return #LOAD_OK or #LOAD_DISCARD\r\n\t *\r\n\t * This notification gives application a chance to override built-in loader and\r\n\t * implement loading of resources in its own way (for example images can be loaded from\r\n\t * database or other resource). To do this set #SCN_LOAD_DATA::outData and\r\n\t * #SCN_LOAD_DATA::outDataSize members of SCN_LOAD_DATA. Sciter does not\r\n\t * store pointer to this data. You can call #SciterDataReady() function instead\r\n\t * of filling these fields. This allows you to free your outData buffer\r\n\t * immediately.\r\n\t**/\r\n\tSC_LOAD_DATA = 0x01\r\n\r\n\t/**This notification indicates that external data (for example image) download process\r\n\t * completed.\r\n\t *\r\n\t * \\param lParam #LPSCN_DATA_LOADED\r\n\t *\r\n\t * This notifiaction is sent for each external resource used by document when\r\n\t * this resource has been completely downloaded. Sciter will send this\r\n\t * notification asynchronously.\r\n\t **/\r\n\tSC_DATA_LOADED = 0x02\r\n\r\n\t/**This notification is sent when all external data (for example image) has been downloaded.\r\n\t *\r\n\t * This notification is sent when all external resources required by document\r\n\t * have been completely downloaded. Sciter will send this notification\r\n\t * asynchronously.\r\n\t **/\r\n\t/* obsolete #define SC_DOCUMENT_COMPLETE 0x03\r\n\tuse DOCUMENT_COMPLETE DOM event.\r\n\t*/\r\n\r\n\t/**This notification is sent on parsing the document and while processing\r\n\t * elements having non empty style.behavior attribute value.\r\n\t *\r\n\t * \\param lParam #LPSCN_ATTACH_BEHAVIOR\r\n\t *\r\n\t * Application has to provide implementation of #sciter::behavior interface.\r\n\t * Set #SCN_ATTACH_BEHAVIOR::impl to address of this implementation.\r\n\t **/\r\n\tSC_ATTACH_BEHAVIOR = 0x04\r\n\r\n\t/**This notification is sent when instance of the engine is destroyed.\r\n\t * It is always final notification.\r\n\t *\r\n\t * \\param lParam #LPSCN_ENGINE_DESTROYED\r\n\t *\r\n\t **/\r\n\tSC_ENGINE_DESTROYED = 0x05\r\n\r\n\t/**Posted notification.\r\n\r\n\t * \\param lParam #LPSCN_POSTED_NOTIFICATION\r\n\t *\r\n\t **/\r\n\tSC_POSTED_NOTIFICATION = 0x06\r\n\r\n\t/**This notification is sent when the engine encounters critical rendering error: e.g. DirectX gfx driver error.\r\n\t  Most probably bad gfx drivers.\r\n\r\n\t* \\param lParam #LPSCN_GRAPHICS_CRITICAL_FAILURE\r\n\t*\r\n\t**/\r\n\tSC_GRAPHICS_CRITICAL_FAILURE = 0x07\r\n\r\n\t/**This notification is sent when the engine needs keyboard to be present on screen\r\n\t  E.g. when <input|text> gets focus\r\n\r\n\t* \\param lParam #LPSCN_KEYBOARD_REQUEST\r\n\t*\r\n\t**/\r\n\tSC_KEYBOARD_REQUEST = 0x08\r\n\r\n\t/**This notification is sent when the engine needs some area to be redrawn\r\n\r\n\t * \\param lParam #LPSCN_INVLIDATE_RECT\r\n\t *\r\n\t **/\r\n\tSC_INVALIDATE_RECT = 0x09\r\n)\r\n\r\n// Notify structures\r\n/**Notification callback structure.\r\n **/\r\n// typedef struct SCITER_CALLBACK_NOTIFICATION\r\n// {\r\n//   UINT code; /**< [in] one of the codes above.*/\r\n//   HWINDOW hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n// } SCITER_CALLBACK_NOTIFICATION;\r\ntype SciterCallbackNotification struct {\r\n\tCode uint32\r\n\tHwnd C.HWINDOW\r\n}\r\n\r\n/**This structure is used by #SC_ENGINE_DESTROYED notification.\r\n *\\copydoc SCN_ENGINE_DESTROYED **/\r\n// typedef struct SCN_ENGINE_DESTROYED\r\n// {\r\n//     UINT code; /**< [in] one of the codes above.*/\r\n//     HWINDOW hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n// } SCN_ENGINE_DESTROYED;\r\ntype ScnEngineDestroyed SciterCallbackNotification\r\n\r\n/**This structure is used by #SC_ENGINE_DESTROYED notification.\r\n *\\copydoc SCN_ENGINE_DESTROYED **/\r\n//typedef struct SCN_POSTED_NOTIFICATION\r\n//{\r\n//    UINT      code; /**< [in] one of the codes above.*/\r\n//    HWINDOW   hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n//    UINT_PTR  wparam;\r\n//    UINT_PTR  lparam;\r\n//    UINT_PTR  lreturn;\r\n//} SCN_POSTED_NOTIFICATION;\r\ntype ScnPostedNotification struct {\r\n\tSciterCallbackNotification\r\n\tWparam  *uint\r\n\tLparam  *uint\r\n\tLreturn *uint\r\n}\r\n\r\n/**This structure is used by #SC_GRAPHICS_CRITICAL_FAILURE notification.\r\n *\\copydoc SC_GRAPHICS_CRITICAL_FAILURE **/\r\ntype ScnGraphicsCriticalFailure SciterCallbackNotification\r\n\r\n/**This structure is used by #SC_KEYBOARD_REQUEST notification.\r\n *\\copydoc SC_KEYBOARD_REQUEST **/\r\ntype ScnKeyboardRequest struct {\r\n\tSciterCallbackNotification\r\n\t// 0 - hide keyboard, 1 ... - type of keyboard\r\n\tkeyboardMode uint\r\n}\r\n\r\n/**This structure is used by #SC_INVALIDATE_RECT notification.\r\n *\\copydoc SC_INVALIDATE_RECT **/\r\ntype ScnInvalidateRect struct {\r\n\tSciterCallbackNotification\r\n\t// cumulative invalid rect\r\n\tinvalidRect Rect\r\n}\r\n\r\n/**This structure is used by #SCN_LOAD_DATA notification.\r\n *\\copydoc SCN_LOAD_DATA\r\n **/\r\n\r\n//typedef struct SCN_LOAD_DATA\r\n//{\r\n//    UINT code; /**< [in] one of the codes above.*/\r\n//    HWINDOW hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n//\r\n//    LPCWSTR  uri;              /**< [in] Zero terminated string, fully qualified uri, for example \"http://server/folder/file.ext\".*/\r\n//\r\n//    LPCBYTE  outData;          /**< [in,out] pointer to loaded data to return. if data exists in the cache then this field contain pointer to it*/\r\n//    UINT     outDataSize;      /**< [in,out] loaded data size to return.*/\r\n//    UINT     dataType;         /**< [in] SciterResourceType */\r\n//\r\n//    LPVOID   requestId;        /**< [in] request id that needs to be passed as is to the SciterDataReadyAsync call */\r\n//\r\n//    HELEMENT principal;\r\n//    HELEMENT initiator;\r\n//} SCN_LOAD_DATA;\r\n\r\ntype ScnLoadData C.SCN_LOAD_DATA\r\n\r\n// type ScnLoadData struct {\r\n// \tSciterCallbackNotification\r\n// \turi         *uint16\r\n// \toutData     *byte\r\n// \toutDataSize uint\r\n// \tDataType    uint\r\n// \tRequestId   uintptr\r\n// \tPrincipal   C.HELEMENT\r\n// \tInitiator   C.HELEMENT\r\n// }\r\n\r\nfunc (s *ScnLoadData) Uri() string {\r\n\treturn Utf16ToString((*uint16)(unsafe.Pointer(s.uri)))\r\n}\r\n\r\nfunc (s *ScnLoadData) RequestId() C.HREQUEST {\r\n\treturn s.requestId\r\n}\r\n\r\nfunc (s *ScnLoadData) Data() []byte {\r\n\tret := ByteCPtrToBytes(s.outData, s.outDataSize)\r\n\treturn ret\r\n}\r\n\r\nfunc (s *ScnLoadData) SetData(data []byte) {\r\n\ts.outData = (C.LPCBYTE)(unsafe.Pointer((&data[0])))\r\n\ts.outDataSize = C.UINT(len(data))\r\n}\r\n\r\n/**This structure is used by #SCN_DATA_LOADED notification.\r\n *\\copydoc SCN_DATA_LOADED\r\n **/\r\n//typedef struct SCN_DATA_LOADED\r\n//{\r\n//    UINT code; /**< [in] one of the codes above.*/\r\n//    HWINDOW hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n//\r\n//    LPCWSTR  uri;              /**< [in] zero terminated string, fully qualified uri, for example \"http://server/folder/file.ext\".*/\r\n//    LPCBYTE  data;             /**< [in] pointer to loaded data.*/\r\n//    UINT    dataSize;         /**< [in] loaded data size (in bytes).*/\r\n//    UINT     dataType;         /**< [in] SciterResourceType */\r\n//    UINT     status;           /**< [in]\r\n//                                         status = 0 (dataSize == 0) - unknown error.\r\n//                                         status = 100..505 - http response status, Note: 200 - OK!\r\n//                                         status > 12000 - wininet error code, see ERROR_INTERNET_*** in wininet.h\r\n//                                 */\r\n//} SCN_DATA_LOADED;\r\ntype ScnDataLoaded struct {\r\n\tSciterCallbackNotification\r\n\turi      *uint16\r\n\tdata     *byte\r\n\tDataSize uint32\r\n\tDataType SciterResourceType\r\n\tStatus   uint32\r\n}\r\n\r\nfunc (s *ScnDataLoaded) Uri() string {\r\n\treturn Utf16ToString(s.uri)\r\n}\r\n\r\nfunc (s *ScnDataLoaded) Data() []byte {\r\n\treturn BytePtrToBytes(s.data, uint(s.DataSize))\r\n}\r\n\r\n//typedef struct SCN_ATTACH_BEHAVIOR\r\n//{\r\n//    UINT code; /**< [in] one of the codes above.*/\r\n//    HWINDOW hwnd; /**< [in] HWINDOW of the window this callback was attached to.*/\r\n//\r\n//    HELEMENT element;          /**< [in] target DOM element handle*/\r\n//    LPCSTR   behaviorName;     /**< [in] zero terminated string, string appears as value of CSS behavior:\"???\" attribute.*/\r\n//\r\n//    ElementEventProc* elementProc;    /**< [out] pointer to ElementEventProc function.*/\r\n//    LPVOID            elementTag;     /**< [out] tag value, passed as is into pointer ElementEventProc function.*/\r\n//\r\n//} SCN_ATTACH_BEHAVIOR;\r\ntype ScnAttachBehavior C.SCN_ATTACH_BEHAVIOR\r\n\r\n// type ScnAttachBehavior struct {\r\n// \tSciterCallbackNotification\r\n// \tElement      C.HELEMENT\r\n// \tbehaviorName *byte\r\n// \tElementProc  uintptr\r\n// \tElementTag   uintptr\r\n// }\r\n\r\nfunc (s *ScnAttachBehavior) BehaviorName() string {\r\n\treturn C.GoString(s.behaviorName)\r\n}\r\n\r\nfunc (s *ScnAttachBehavior) Element() C.HELEMENT {\r\n\treturn s.element\r\n}\r\n\r\n// typedef int SCDOM_RESULT;\r\ntype SCDOM_RESULT int32\r\ntype VALUE_RESULT int32 //C.VALUE_RESULT\r\n\r\n// enum VALUE_RESULT\r\nconst (\r\n\tHV_OK_TRUE VALUE_RESULT = iota - 1\r\n\tHV_OK\r\n\tHV_BAD_PARAMETER\r\n\tHV_INCOMPATIBLE_TYPE\r\n)\r\n\r\nconst (\r\n\tSCDOM_OK SCDOM_RESULT = iota\r\n\tSCDOM_INVALID_HWND\r\n\tSCDOM_INVALID_HANDLE\r\n\tSCDOM_PASSIVE_HANDLE\r\n\tSCDOM_INVALID_PARAMETER\r\n\tSCDOM_OPERATION_FAILED\r\n\tSCDOM_OK_NOT_HANDLED SCDOM_RESULT = (-1)\r\n)\r\n\r\ntype domError struct {\r\n\tResult  SCDOM_RESULT\r\n\tMessage string\r\n}\r\n\r\nfunc (e *domError) Error() string {\r\n\treturn fmt.Sprintf(\"%s: %s\", e.Result.String(), e.Message)\r\n}\r\n\r\nfunc newDomError(ret SCDOM_RESULT, msg string) *domError {\r\n\treturn &domError{\r\n\t\tResult:  ret,\r\n\t\tMessage: msg,\r\n\t}\r\n}\r\n\r\n// return nil when r == SCDOM_OK\r\nfunc wrapDomResult(r C.INT, msg string) error {\r\n\tif r == C.INT(SCDOM_OK) {\r\n\t\treturn nil\r\n\t}\r\n\treturn newDomError(SCDOM_RESULT(r), msg)\r\n}\r\n\r\n// enum ELEMENT_AREAS\r\nconst (\r\n\tROOT_RELATIVE = 0x01 // - or this flag if you want to get HTMLayout window relative coordinates\r\n\t//   otherwise it will use nearest windowed container e.g. popup window.\r\n\tSELF_RELATIVE = 0x02 // - \"or\" this flag if you want to get coordinates relative to the origin\r\n\t//   of element iself.\r\n\tCONTAINER_RELATIVE = 0x03 // - position inside immediate container.\r\n\tVIEW_RELATIVE      = 0x04 // - position relative to view - HTMLayout window\r\n\r\n\tCONTENT_BOX = 0x00 // content (inner)  box\r\n\tPADDING_BOX = 0x10 // content + paddings\r\n\tBORDER_BOX  = 0x20 // content + paddings + border\r\n\tMARGIN_BOX  = 0x30 // content + paddings + border + margins\r\n\r\n\tBACK_IMAGE_AREA = 0x40 // relative to content origin - location of background image (if it set no-repeat)\r\n\tFORE_IMAGE_AREA = 0x50 // relative to content origin - location of foreground image (if it set no-repeat)\r\n\r\n\tSCROLLABLE_AREA = 0x60 // scroll_area - scrollable area in content box\r\n)\r\n\r\ntype SCITER_SCROLL_FLAGS uint32\r\n\r\n// enum SCITER_SCROLL_FLAGS\r\nconst (\r\n\tSCROLL_TO_TOP SCITER_SCROLL_FLAGS = 0x01\r\n\tSCROLL_SMOOTH SCITER_SCROLL_FLAGS = 0x10\r\n)\r\n\r\ntype Point struct {\r\n\tX int32\r\n\tY int32\r\n}\r\n\r\ntype Size struct {\r\n\tCx int32\r\n\tCy int32\r\n}\r\n\r\ntype Rect struct {\r\n\tLeft   int32\r\n\tTop    int32\r\n\tRight  int32\r\n\tBottom int32\r\n}\r\n\r\nfunc NewRect(top, left, width, height int) *Rect {\r\n\treturn &Rect{\r\n\t\tTop:    int32(top),\r\n\t\tLeft:   int32(left),\r\n\t\tBottom: int32(top + height),\r\n\t\tRight:  int32(left + width),\r\n\t}\r\n}\r\n\r\nvar (\r\n\tDefaultRect = &Rect{0, 0, 300, 400}\r\n)\r\n\r\ntype EventHandler struct {\r\n\tOnAttached func(he *Element)\r\n\tOnDetached func(he *Element)\r\n\tOnMouse    func(he *Element, params *MouseParams) bool\r\n\tOnKey      func(he *Element, params *KeyParams) bool\r\n\tOnFocus    func(he *Element, params *FocusParams) bool\r\n\tOnDraw     func(he *Element, params *DrawParams) bool\r\n\tOnTimer    func(he *Element, params *TimerParams) bool\r\n\t// notification events from builtin behaviors - synthesized events: BUTTON_CLICK, VALUE_CHANGED\r\n\t// see enum BEHAVIOR_EVENTS\r\n\tOnBehaviorEvent func(he *Element, params *BehaviorEventParams) bool\r\n\tOnMethodCall    func(he *Element, params *MethodParams) bool\r\n\t// calls from CSSS! script and TIScript (if it was not handled by method below).\r\n\r\n\t// If needed your application may expose some [native] functions to be called by script code.\r\n\t// Usually this is made by implementing your own event_handler and overriding\r\n\t// its on_script_call(helement, name, argc, argv, retval) method.\r\n\t// If you will do this then you can invoke this callback from script as:\r\n\t//     \"global\" native functions: var r = view.funcName( p0, p1, ... );\r\n\t//              - calling  on_script_call of event_handler instance attached to the window.\r\n\t//     As element's methods: var r = el.funcName( p0, p1, ... );\r\n\t//              - calling  on_script_call of event_handler instance (native behavior) attached to the element.\r\n\t// This way you can establish interaction between scipt and native code inside your application.\r\n\tOnScriptingMethodCall func(he *Element, params *ScriptingMethodParams) bool\r\n\t// Calls from TIScript. Override this if you want your own methods accessible directly from tiscript engine.\r\n\t// Use tiscript::args to access parameters.\r\n\tOnTiscriptMethodCall func(he *Element, params *TiscriptMethodParams) bool\r\n\t// call when resource is loaded but not used\r\n\t// return true would cancel the resource usage\r\n\t// return false would follow the normal procedure\r\n\tOnDataArrived func(he *Element, params *DataArrivedParams) bool\r\n\tOnSize        func(he *Element)\r\n\tOnScroll      func(he *Element, params *ScrollParams) bool\r\n\tOnExchange    func(he *Element, params *ExchangeParams) bool\r\n\tOnGesture     func(he *Element, params *GestureParams) bool\r\n\tOnSom         func(he *Element, params *SomParams) bool\r\n}\r\n\r\n// case SC_LOAD_DATA:          return static_cast<BASE*>(this)->on_load_data((LPSCN_LOAD_DATA) pnm);\r\n// case SC_DATA_LOADED:        return static_cast<BASE*>(this)->on_data_loaded((LPSCN_DATA_LOADED)pnm);\r\n// //case SC_DOCUMENT_COMPLETE: return on_document_complete();\r\n// case SC_ATTACH_BEHAVIOR:    return static_cast<BASE*>(this)->on_attach_behavior((LPSCN_ATTACH_BEHAVIOR)pnm );\r\n// case SC_ENGINE_DESTROYED:   return static_cast<BASE*>(this)->on_engine_destroyed();\r\n// case SC_POSTED_NOTIFICATION: return static_cast<BASE*>(this)->on_posted_notification((LPSCN_POSTED_NOTIFICATION)pnm);\r\n\r\ntype CallbackHandler struct {\r\n\tBehaviors map[string]*EventHandler\r\n\t// Notifies that Sciter is about to download a referred resource.\r\n\tOnLoadData func(params *ScnLoadData) int\r\n\t// This notification indicates that external data (for example image) download process\r\n\tOnDataLoaded func(params *ScnDataLoaded) int\r\n\t/**This notification is sent on parsing the document and while processing\r\n\t * elements having non empty style.behavior attribute value.\r\n\t *\r\n\t * \\param lParam #LPSCN_ATTACH_BEHAVIOR\r\n\t *\r\n\t * Application has to provide implementation of #sciter::behavior interface.\r\n\t * Set #SCN_ATTACH_BEHAVIOR::impl to address of this implementation.\r\n\t **/\r\n\tOnAttachBehavior func(params *ScnAttachBehavior) int\r\n\t/**This notification is sent when instance of the engine is destroyed.\r\n\t * It is always final notification.\r\n\t *\r\n\t * \\param lParam #LPSCN_ENGINE_DESTROYED\r\n\t *\r\n\t **/\r\n\tOnEngineDestroyed func() int\r\n\t/**Posted notification.\r\n\r\n\t * \\param lParam #LPSCN_POSTED_NOTIFICATION\r\n\t *\r\n\t **/\r\n\tOnPostedNotification func(params *ScnPostedNotification) int\r\n\r\n\t/**This notification is sent when the engine encounters critical rendering error: e.g. DirectX gfx driver error.\r\n\t  Most probably bad gfx drivers.\r\n\r\n\t* \\param lParam #LPSCN_GRAPHICS_CRITICAL_FAILURE\r\n\t*\r\n\t**/\r\n\tOnGraphicsCriticalFailure func() int\r\n\r\n\t/**This notification is sent when the engine needs keyboard to be present on screen\r\n\t  E.g. when <input|text> gets focus\r\n\r\n\t* \\param lParam #LPSCN_KEYBOARD_REQUEST\r\n\t*\r\n\t**/\r\n\tOnKeyboardRequest func(params *ScnKeyboardRequest) int\r\n\r\n\t/**This notification is sent when the engine needs some area to be redrawn\r\n\r\n\t * \\param lParam #LPSCN_INVLIDATE_RECT\r\n\t *\r\n\t **/\r\n\tOnInvalidateRect func(params *ScnInvalidateRect) int\r\n}\r\n\r\n// enum SCRIPT_RUNTIME_FEATURES\r\n// {\r\nconst (\r\n\tALLOW_FILE_IO   = 0x00000001\r\n\tALLOW_SOCKET_IO = 0x00000002\r\n\tALLOW_EVAL      = 0x00000004\r\n\tALLOW_SYSINFO   = 0x00000008\r\n)\r\n\r\n// };\r\n\r\n// enum GFX_LAYER\r\n// {\r\nconst (\r\n\tGFX_LAYER_GDI         = 1\r\n\tGFX_LAYER_CG          = 1\r\n\tGFX_LAYER_CAIRO       = 1\r\n\tGFX_LAYER_WARP        = 2\r\n\tGFX_LAYER_D2D         = 3\r\n\tGFX_LAYER_SKIA        = 4\r\n\tGFX_LAYER_SKIA_OPENGL = 5\r\n\tGFX_LAYER_AUTO        = 0xFFFF\r\n)\r\n\r\n// };\r\n\r\ntype Sciter_RT_OPTIONS uint32\r\n\r\nconst (\r\n\tSCITER_SMOOTH_SCROLL      Sciter_RT_OPTIONS = 1 // value:TRUE - enable, value:FALSE - disable, enabled by default\r\n\tSCITER_CONNECTION_TIMEOUT                   = 2 // value: milliseconds, connection timeout of http client\r\n\tSCITER_HTTPS_ERROR                          = 3 // value: 0 - drop connection, 1 - use builtin dialog, 2 - accept connection silently\r\n\tSCITER_FONT_SMOOTHING                       = 4 // value: 0 - system default, 1 - no smoothing, 2 - std smoothing, 3 - clear type\r\n\t_\r\n\tSCITER_TRANSPARENT_WINDOW = 6 // Windows Aero support, value:\r\n\t// 0 - normal drawing,\r\n\t// 1 - window has transparent background after calls DwmExtendFrameIntoClientArea() or DwmEnableBlurBehindWindow().\r\n\tSCITER_SET_GPU_BLACKLIST = 7 // hWnd = NULL,\r\n\t// value = LPCBYTE, json - GPU black list, see: gpu-blacklist.json resource.\r\n\tSCITER_SET_SCRIPT_RUNTIME_FEATURES = 8  // value - combination of SCRIPT_RUNTIME_FEATURES flags.\r\n\tSCITER_SET_GFX_LAYER               = 9  // hWnd = NULL, value - GFX_LAYER\r\n\tSCITER_SET_DEBUG_MODE              = 10 // hWnd, value - TRUE/FALSE\r\n\tSCITER_SET_UX_THEMING              = 11 // hWnd = NULL, value - BOOL, TRUE - the engine will use \"unisex\" theme that is common for all platforms.\r\n\t// That UX theme is not using OS primitives for rendering input elements. Use it if you want exactly\r\n\t// the same (modulo fonts) look-n-feel on all platforms.\r\n\r\n\tSCITER_ALPHA_WINDOW = 12 //  hWnd, value - TRUE/FALSE - window uses per pixel alpha (e.g. WS_EX_LAYERED/UpdateLayeredWindow() window)\r\n\r\n\tSCITER_SET_INIT_SCRIPT = 13 // hWnd - N/A , value LPCSTR - UTF-8 encoded script source to be loaded into each view before any other script execution.\r\n\t//                             The engine copies this string inside the call.\r\n\r\n\tSCITER_SET_MAIN_WINDOW = 14 //  hWnd, value - TRUE/FALSE - window is main, will destroy all other dependent windows on close\r\n\r\n\tSCITER_SET_MAX_HTTP_DATA_LENGTH = 15 // hWnd - N/A , value - max request length in megabytes (1024*1024 bytes)\r\n)\r\n\r\n// * \\param[in] placement \\b UINT, values:\r\n// *     2 - popup element below of anchor\r\n// *     8 - popup element above of anchor\r\n// *     4 - popup element on left side of anchor\r\n// *     6 - popup element on right side of anchor\r\n// *     ( see numpad on keyboard to get an idea of the numbers)\r\ntype PopupPlacement uint32\r\n\r\nconst (\r\n\tBelowAnchor   PopupPlacement = 2\r\n\taboveAnchor   PopupPlacement = 8\r\n\tLeftOfAnchor  PopupPlacement = 4\r\n\tRightOfAnchor PopupPlacement = 6\r\n)\r\n\r\ntype ElementState uint32\r\n\r\n// enum ELEMENT_STATE_BITS\r\nconst (\r\n\tSTATE_LINK       ElementState = 0x00000001\r\n\tSTATE_HOVER      ElementState = 0x00000002\r\n\tSTATE_ACTIVE     ElementState = 0x00000004\r\n\tSTATE_FOCUS      ElementState = 0x00000008\r\n\tSTATE_VISITED    ElementState = 0x00000010\r\n\tSTATE_CURRENT    ElementState = 0x00000020 // current (hot) item\r\n\tSTATE_CHECKED    ElementState = 0x00000040 // element is checked (or selected)\r\n\tSTATE_DISABLED   ElementState = 0x00000080 // element is disabled\r\n\tSTATE_READONLY   ElementState = 0x00000100 // readonly input element\r\n\tSTATE_EXPANDED   ElementState = 0x00000200 // expanded state - nodes in tree view\r\n\tSTATE_COLLAPSED  ElementState = 0x00000400 // collapsed state - nodes in tree view - mutually exclusive with\r\n\tSTATE_INCOMPLETE ElementState = 0x00000800 // one of fore/back images requested but not delivered\r\n\tSTATE_ANIMATING  ElementState = 0x00001000 // is animating currently\r\n\tSTATE_FOCUSABLE  ElementState = 0x00002000 // will accept focus\r\n\tSTATE_ANCHOR     ElementState = 0x00004000 // anchor in selection (used with current in selects)\r\n\tSTATE_SYNTHETIC  ElementState = 0x00008000 // this is a synthetic element - don't emit it's head/tail\r\n\tSTATE_OWNS_POPUP ElementState = 0x00010000 // this is a synthetic element - don't emit it's head/tail\r\n\tSTATE_TABFOCUS   ElementState = 0x00020000 // focus gained by tab traversal\r\n\tSTATE_EMPTY      ElementState = 0x00040000 // empty - element is empty (text.size() == 0 && subs.size() == 0)\r\n\t//  if element has behavior attached then the behavior is responsible for the value of this flag.\r\n\tSTATE_BUSY ElementState = 0x00080000 // busy; loading\r\n\r\n\tSTATE_DRAG_OVER   ElementState = 0x00100000 // drag over the block that can accept it (so is current drop target). Flag is set for the drop target block\r\n\tSTATE_DROP_TARGET ElementState = 0x00200000 // active drop target.\r\n\tSTATE_MOVING      ElementState = 0x00400000 // dragging/moving - the flag is set for the moving block.\r\n\tSTATE_COPYING     ElementState = 0x00800000 // dragging/copying - the flag is set for the copying block.\r\n\tSTATE_DRAG_SOURCE ElementState = 0x01000000 // element that is a drag source.\r\n\tSTATE_DROP_MARKER ElementState = 0x02000000 // element is drop marker\r\n\r\n\tSTATE_PRESSED ElementState = 0x04000000 // pressed - close to active but has wider life span - e.g. in MOUSE_UP it\r\n\t//   is still on; so behavior can check it in MOUSE_UP to discover CLICK condition.\r\n\tSTATE_POPUP ElementState = 0x08000000 // this element is out of flow - popup\r\n\r\n\tSTATE_IS_LTR ElementState = 0x10000000 // the element or one of its containers has dir=ltr declared\r\n\tSTATE_IS_RTL ElementState = 0x20000000 // the element or one of its containers has dir=rtl declared\r\n)\r\n\r\ntype RequestType uint32\r\n\r\n// enum REQUEST_TYPE\r\nconst (\r\n\tGET_ASYNC  RequestType = iota // async GET\r\n\tPOST_ASYNC                    // async POST\r\n\tGET_SYNC                      // synchronous GET\r\n\tPOST_SYNC                     // synchronous POST\r\n)\r\n\r\n// struct REQUEST_PARAM {\r\n//   LPCWSTR name;\r\n//   LPCWSTR value;\r\n// };\r\n\r\ntype RequestParam struct {\r\n\tName  string\r\n\tValue string\r\n}\r\n"
        },
        {
          "name": "types_string.go",
          "type": "blob",
          "size": 10.1591796875,
          "content": "// generated by stringer -type=BehaviorEvent,MouseEvent,CursorType,KeyEvent,FocusEvent,ScrollEvent,GestureCmd,GestureState,GestureTypeFlag,DrawEvent,EventReason,EditChangedReason,BehaviorMethodIdentifier,SCDOM_RESULT,VALUE_RESULT -output types_string.go; DO NOT EDIT\n\npackage sciter\n\nimport \"fmt\"\n\nconst (\n\t_BehaviorEvent_name_0 = \"BUTTON_CLICKBUTTON_PRESSBUTTON_STATE_CHANGEDEDIT_VALUE_CHANGINGEDIT_VALUE_CHANGEDSELECT_SELECTION_CHANGEDSELECT_STATE_CHANGEDPOPUP_REQUESTPOPUP_READYPOPUP_DISMISSEDMENU_ITEM_ACTIVEMENU_ITEM_CLICK\"\n\t_BehaviorEvent_name_1 = \"CONTEXT_MENU_REQUESTVISIUAL_STATUS_CHANGEDDISABLED_STATUS_CHANGEDPOPUP_DISMISSING\"\n\t_BehaviorEvent_name_2 = \"CONTENT_CHANGED\"\n\t_BehaviorEvent_name_3 = \"HYPERLINK_CLICK\"\n\t_BehaviorEvent_name_4 = \"ELEMENT_COLLAPSEDELEMENT_EXPANDEDACTIVATE_CHILDINIT_DATA_VIEWROWS_DATA_REQUESTUI_STATE_CHANGEDFORM_SUBMITFORM_RESETDOCUMENT_COMPLETEHISTORY_PUSHHISTORY_DROPHISTORY_PRIORHISTORY_NEXTHISTORY_STATE_CHANGEDCLOSE_POPUPREQUEST_TOOLTIPANIMATION\"\n\t_BehaviorEvent_name_5 = \"DOCUMENT_CREATEDDOCUMENT_CLOSE_REQUESTDOCUMENT_CLOSEDOCUMENT_READY\"\n\t_BehaviorEvent_name_6 = \"VIDEO_INITIALIZEDVIDEO_STARTEDVIDEO_STOPPEDVIDEO_BIND_RQ\"\n)\n\nvar (\n\t_BehaviorEvent_index_0 = [...]uint8{0, 12, 24, 44, 63, 81, 105, 125, 138, 149, 164, 180, 195}\n\t_BehaviorEvent_index_1 = [...]uint8{0, 20, 42, 65, 81}\n\t_BehaviorEvent_index_2 = [...]uint8{0, 15}\n\t_BehaviorEvent_index_3 = [...]uint8{0, 15}\n\t_BehaviorEvent_index_4 = [...]uint8{0, 17, 33, 47, 61, 78, 94, 105, 115, 132, 144, 156, 169, 181, 202, 213, 228, 237}\n\t_BehaviorEvent_index_5 = [...]uint8{0, 16, 38, 52, 66}\n\t_BehaviorEvent_index_6 = [...]uint8{0, 17, 30, 43, 56}\n)\n\nfunc (i BehaviorEvent) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 11:\n\t\treturn _BehaviorEvent_name_0[_BehaviorEvent_index_0[i]:_BehaviorEvent_index_0[i+1]]\n\tcase 16 <= i && i <= 19:\n\t\ti -= 16\n\t\treturn _BehaviorEvent_name_1[_BehaviorEvent_index_1[i]:_BehaviorEvent_index_1[i+1]]\n\tcase i == 21:\n\t\treturn _BehaviorEvent_name_2\n\tcase i == 128:\n\t\treturn _BehaviorEvent_name_3\n\tcase 144 <= i && i <= 160:\n\t\ti -= 144\n\t\treturn _BehaviorEvent_name_4[_BehaviorEvent_index_4[i]:_BehaviorEvent_index_4[i+1]]\n\tcase 192 <= i && i <= 195:\n\t\ti -= 192\n\t\treturn _BehaviorEvent_name_5[_BehaviorEvent_index_5[i]:_BehaviorEvent_index_5[i+1]]\n\tcase 209 <= i && i <= 212:\n\t\ti -= 209\n\t\treturn _BehaviorEvent_name_6[_BehaviorEvent_index_6[i]:_BehaviorEvent_index_6[i+1]]\n\tdefault:\n\t\treturn fmt.Sprintf(\"BehaviorEvent(%d)\", i)\n\t}\n}\n\nconst (\n\t_MouseEvent_name_0 = \"MOUSE_ENTERMOUSE_LEAVEMOUSE_MOVEMOUSE_UPMOUSE_DOWNMOUSE_DCLICKMOUSE_WHEELMOUSE_TICKMOUSE_IDLEDROPDRAG_ENTERDRAG_LEAVEDRAG_REQUEST\"\n\t_MouseEvent_name_1 = \"MOUSE_CLICKDRAGGING\"\n)\n\nvar (\n\t_MouseEvent_index_0 = [...]uint8{0, 11, 22, 32, 40, 50, 62, 73, 83, 93, 97, 107, 117, 129}\n\t_MouseEvent_index_1 = [...]uint8{0, 11, 19}\n)\n\nfunc (i MouseEvent) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 12:\n\t\treturn _MouseEvent_name_0[_MouseEvent_index_0[i]:_MouseEvent_index_0[i+1]]\n\tcase 255 <= i && i <= 256:\n\t\ti -= 255\n\t\treturn _MouseEvent_name_1[_MouseEvent_index_1[i]:_MouseEvent_index_1[i+1]]\n\tdefault:\n\t\treturn fmt.Sprintf(\"MouseEvent(%d)\", i)\n\t}\n}\n\nconst _CursorType_name = \"CURSOR_ARROWCURSOR_IBEAMCURSOR_WAITCURSOR_CROSSCURSOR_UPARROWCURSOR_SIZENWSECURSOR_SIZENESWCURSOR_SIZEWECURSOR_SIZENSCURSOR_SIZEALLCURSOR_NOCURSOR_APPSTARTINGCURSOR_HELPCURSOR_HANDCURSOR_DRAG_MOVECURSOR_DRAG_COPY\"\n\nvar _CursorType_index = [...]uint8{0, 12, 24, 35, 47, 61, 76, 91, 104, 117, 131, 140, 158, 169, 180, 196, 212}\n\nfunc (i CursorType) String() string {\n\tif i+1 >= CursorType(len(_CursorType_index)) {\n\t\treturn fmt.Sprintf(\"CursorType(%d)\", i)\n\t}\n\treturn _CursorType_name[_CursorType_index[i]:_CursorType_index[i+1]]\n}\n\nconst _KeyEvent_name = \"KEY_DOWNKEY_UPKEY_CHAR\"\n\nvar _KeyEvent_index = [...]uint8{0, 8, 14, 22}\n\nfunc (i KeyEvent) String() string {\n\tif i+1 >= KeyEvent(len(_KeyEvent_index)) {\n\t\treturn fmt.Sprintf(\"KeyEvent(%d)\", i)\n\t}\n\treturn _KeyEvent_name[_KeyEvent_index[i]:_KeyEvent_index[i+1]]\n}\n\nconst _FocusEvent_name = \"FOCUS_LOSTFOCUS_GOT\"\n\nvar _FocusEvent_index = [...]uint8{0, 10, 19}\n\nfunc (i FocusEvent) String() string {\n\tif i+1 >= FocusEvent(len(_FocusEvent_index)) {\n\t\treturn fmt.Sprintf(\"FocusEvent(%d)\", i)\n\t}\n\treturn _FocusEvent_name[_FocusEvent_index[i]:_FocusEvent_index[i+1]]\n}\n\nconst _ScrollEvent_name = \"SCROLL_HOMESCROLL_ENDSCROLL_STEP_PLUSSCROLL_STEP_MINUSSCROLL_PAGE_PLUSSCROLL_PAGE_MINUSSCROLL_POSSCROLL_SLIDER_RELEASEDSCROLL_CORNER_PRESSEDSCROLL_CORNER_RELEASED\"\n\nvar _ScrollEvent_index = [...]uint8{0, 11, 21, 37, 54, 70, 87, 97, 119, 140, 162}\n\nfunc (i ScrollEvent) String() string {\n\tif i+1 >= ScrollEvent(len(_ScrollEvent_index)) {\n\t\treturn fmt.Sprintf(\"ScrollEvent(%d)\", i)\n\t}\n\treturn _ScrollEvent_name[_ScrollEvent_index[i]:_ScrollEvent_index[i+1]]\n}\n\nconst _GestureCmd_name = \"GESTURE_REQUESTGESTURE_ZOOMGESTURE_PANGESTURE_ROTATEGESTURE_TAP1GESTURE_TAP2\"\n\nvar _GestureCmd_index = [...]uint8{0, 15, 27, 38, 52, 64, 76}\n\nfunc (i GestureCmd) String() string {\n\tif i+1 >= GestureCmd(len(_GestureCmd_index)) {\n\t\treturn fmt.Sprintf(\"GestureCmd(%d)\", i)\n\t}\n\treturn _GestureCmd_name[_GestureCmd_index[i]:_GestureCmd_index[i+1]]\n}\n\nconst (\n\t_GestureState_name_0 = \"GESTURE_STATE_BEGINGESTURE_STATE_INERTIA\"\n\t_GestureState_name_1 = \"GESTURE_STATE_END\"\n)\n\nvar (\n\t_GestureState_index_0 = [...]uint8{0, 19, 40}\n\t_GestureState_index_1 = [...]uint8{0, 17}\n)\n\nfunc (i GestureState) String() string {\n\tswitch {\n\tcase 1 <= i && i <= 2:\n\t\ti -= 1\n\t\treturn _GestureState_name_0[_GestureState_index_0[i]:_GestureState_index_0[i+1]]\n\tcase i == 4:\n\t\treturn _GestureState_name_1\n\tdefault:\n\t\treturn fmt.Sprintf(\"GestureState(%d)\", i)\n\t}\n}\n\nconst (\n\t_GestureTypeFlag_name_0 = \"GESTURE_FLAG_ZOOMGESTURE_FLAG_ROTATE\"\n\t_GestureTypeFlag_name_1 = \"GESTURE_FLAG_PAN_VERTICAL\"\n\t_GestureTypeFlag_name_2 = \"GESTURE_FLAG_TAP1\"\n\t_GestureTypeFlag_name_3 = \"GESTURE_FLAG_TAP2\"\n\t_GestureTypeFlag_name_4 = \"GESTURE_FLAG_PAN_WITH_GUTTER\"\n\t_GestureTypeFlag_name_5 = \"GESTURE_FLAG_PAN_WITH_INERTIA\"\n\t_GestureTypeFlag_name_6 = \"GESTURE_FLAGS_ALL\"\n)\n\nvar (\n\t_GestureTypeFlag_index_0 = [...]uint8{0, 17, 36}\n\t_GestureTypeFlag_index_1 = [...]uint8{0, 25}\n\t_GestureTypeFlag_index_2 = [...]uint8{0, 17}\n\t_GestureTypeFlag_index_3 = [...]uint8{0, 17}\n\t_GestureTypeFlag_index_4 = [...]uint8{0, 28}\n\t_GestureTypeFlag_index_5 = [...]uint8{0, 29}\n\t_GestureTypeFlag_index_6 = [...]uint8{0, 17}\n)\n\nfunc (i GestureTypeFlag) String() string {\n\tswitch {\n\tcase 1 <= i && i <= 2:\n\t\ti -= 1\n\t\treturn _GestureTypeFlag_name_0[_GestureTypeFlag_index_0[i]:_GestureTypeFlag_index_0[i+1]]\n\tcase i == 4:\n\t\treturn _GestureTypeFlag_name_1\n\tcase i == 16:\n\t\treturn _GestureTypeFlag_name_2\n\tcase i == 32:\n\t\treturn _GestureTypeFlag_name_3\n\tcase i == 16384:\n\t\treturn _GestureTypeFlag_name_4\n\tcase i == 32768:\n\t\treturn _GestureTypeFlag_name_5\n\tcase i == 65535:\n\t\treturn _GestureTypeFlag_name_6\n\tdefault:\n\t\treturn fmt.Sprintf(\"GestureTypeFlag(%d)\", i)\n\t}\n}\n\nconst _DrawEvent_name = \"DRAW_CONTENTDRAW_FOREGROUND\"\n\nvar _DrawEvent_index = [...]uint8{0, 12, 27}\n\nfunc (i DrawEvent) String() string {\n\ti -= 1\n\tif i+1 >= DrawEvent(len(_DrawEvent_index)) {\n\t\treturn fmt.Sprintf(\"DrawEvent(%d)\", i+1)\n\t}\n\treturn _DrawEvent_name[_DrawEvent_index[i]:_DrawEvent_index[i+1]]\n}\n\nconst _EventReason_name = \"BY_MOUSE_CLICKBY_KEY_CLICKSYNTHESIZEDBY_MOUSE_ON_ICON\"\n\nvar _EventReason_index = [...]uint8{0, 14, 26, 37, 53}\n\nfunc (i EventReason) String() string {\n\tif i+1 >= EventReason(len(_EventReason_index)) {\n\t\treturn fmt.Sprintf(\"EventReason(%d)\", i)\n\t}\n\treturn _EventReason_name[_EventReason_index[i]:_EventReason_index[i+1]]\n}\n\nconst _EditChangedReason_name = \"BY_INS_CHARBY_INS_CHARSBY_DEL_CHARBY_DEL_CHARSBY_UNDO_REDO\"\n\nvar _EditChangedReason_index = [...]uint8{0, 11, 23, 34, 46, 58}\n\nfunc (i EditChangedReason) String() string {\n\tif i+1 >= EditChangedReason(len(_EditChangedReason_index)) {\n\t\treturn fmt.Sprintf(\"EditChangedReason(%d)\", i)\n\t}\n\treturn _EditChangedReason_name[_EditChangedReason_index[i]:_EditChangedReason_index[i+1]]\n}\n\nconst (\n\t_BehaviorMethodIdentifier_name_0 = \"DO_CLICKGET_TEXT_VALUESET_TEXT_VALUETEXT_EDIT_GET_SELECTIONTEXT_EDIT_SET_SELECTIONTEXT_EDIT_REPLACE_SELECTIONSCROLL_BAR_GET_VALUESCROLL_BAR_SET_VALUETEXT_EDIT_GET_CARET_POSITIONTEXT_EDIT_GET_SELECTION_TEXTTEXT_EDIT_GET_SELECTION_HTMLTEXT_EDIT_CHAR_POS_AT_XY\"\n\t_BehaviorMethodIdentifier_name_1 = \"IS_EMPTYGET_VALUESET_VALUE\"\n\t_BehaviorMethodIdentifier_name_2 = \"FIRST_APPLICATION_METHOD_ID\"\n)\n\nvar (\n\t_BehaviorMethodIdentifier_index_0 = [...]uint16{0, 8, 22, 36, 59, 82, 109, 129, 149, 177, 205, 233, 257}\n\t_BehaviorMethodIdentifier_index_1 = [...]uint8{0, 8, 17, 26}\n\t_BehaviorMethodIdentifier_index_2 = [...]uint8{0, 27}\n)\n\nfunc (i BehaviorMethodIdentifier) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 11:\n\t\treturn _BehaviorMethodIdentifier_name_0[_BehaviorMethodIdentifier_index_0[i]:_BehaviorMethodIdentifier_index_0[i+1]]\n\tcase 252 <= i && i <= 254:\n\t\ti -= 252\n\t\treturn _BehaviorMethodIdentifier_name_1[_BehaviorMethodIdentifier_index_1[i]:_BehaviorMethodIdentifier_index_1[i+1]]\n\tcase i == 256:\n\t\treturn _BehaviorMethodIdentifier_name_2\n\tdefault:\n\t\treturn fmt.Sprintf(\"BehaviorMethodIdentifier(%d)\", i)\n\t}\n}\n\nconst _SCDOM_RESULT_name = \"SCDOM_OK_NOT_HANDLEDSCDOM_OKSCDOM_INVALID_HWNDSCDOM_INVALID_HANDLESCDOM_PASSIVE_HANDLESCDOM_INVALID_PARAMETERSCDOM_OPERATION_FAILED\"\n\nvar _SCDOM_RESULT_index = [...]uint8{0, 20, 28, 46, 66, 86, 109, 131}\n\nfunc (i SCDOM_RESULT) String() string {\n\ti -= -1\n\tif i < 0 || i+1 >= SCDOM_RESULT(len(_SCDOM_RESULT_index)) {\n\t\treturn fmt.Sprintf(\"SCDOM_RESULT(%d)\", i+-1)\n\t}\n\treturn _SCDOM_RESULT_name[_SCDOM_RESULT_index[i]:_SCDOM_RESULT_index[i+1]]\n}\n\nconst _VALUE_RESULT_name = \"HV_OK_TRUEHV_OKHV_BAD_PARAMETERHV_INCOMPATIBLE_TYPE\"\n\nvar _VALUE_RESULT_index = [...]uint8{0, 10, 15, 31, 51}\n\nfunc (i VALUE_RESULT) String() string {\n\ti -= -1\n\tif i < 0 || i+1 >= VALUE_RESULT(len(_VALUE_RESULT_index)) {\n\t\treturn fmt.Sprintf(\"VALUE_RESULT(%d)\", i+-1)\n\t}\n\treturn _VALUE_RESULT_name[_VALUE_RESULT_index[i]:_VALUE_RESULT_index[i+1]]\n}\n\nconst _REQUEST_RESULT_name = \"REQUEST_PANICREQUEST_OKREQUEST_BAD_PARAMREQUEST_FAILUREREQUEST_NOTSUPPORTED\"\n\nvar _REQUEST_RESULT_index = [...]uint8{0, 13, 23, 40, 55, 75}\n\nfunc (i REQUEST_RESULT) String() string {\n\ti -= -1\n\tif i < 0 || i+1 >= REQUEST_RESULT(len(_REQUEST_RESULT_index)) {\n\t\treturn fmt.Sprintf(\"REQUEST_RESULT(%d)\", i+-1)\n\t}\n\treturn _REQUEST_RESULT_name[_REQUEST_RESULT_index[i]:_REQUEST_RESULT_index[i+1]]\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 1.72265625,
          "content": "package sciter\r\n\r\n/*\r\n#cgo CFLAGS: -Iinclude\r\n#include \"sciter-x.h\"\r\n*/\r\nimport \"C\"\r\nimport (\r\n\t\"syscall\"\r\n\t\"unicode/utf16\"\r\n\t\"unsafe\"\r\n)\r\n\r\n// Returns the utf-8 encoding of the utf-16 sequence s,\r\n// with a terminating NUL removed.\r\nfunc Utf16ToString(s *uint16) string {\r\n\tif s == nil {\r\n\t\tpanic(\"null cstring\")\r\n\t}\r\n\tus := make([]uint16, 0, 256)\r\n\tfor p := uintptr(unsafe.Pointer(s)); ; p += 2 {\r\n\t\tu := *(*uint16)(unsafe.Pointer(p))\r\n\t\tif u == 0 {\r\n\t\t\treturn string(utf16.Decode(us))\r\n\t\t}\r\n\t\tus = append(us, u)\r\n\t}\r\n\treturn \"\"\r\n}\r\n\r\nfunc Utf16ToStringLength(s *uint16, length int) string {\r\n\tif s == nil {\r\n\t\tpanic(\"null cstring\")\r\n\t}\r\n\tus := make([]uint16, 0, 256)\r\n\tfor p, i := uintptr(unsafe.Pointer(s)), 0; i < length; p, i = p+2, i+1 {\r\n\t\tu := *(*uint16)(unsafe.Pointer(p))\r\n\t\tus = append(us, u)\r\n\t}\r\n\treturn string(utf16.Decode(us))\r\n}\r\n\r\nfunc StringToBytePtr(s string) *byte {\r\n\tbs := ([]byte)(s)\r\n\treturn &bs[0]\r\n}\r\n\r\n// returns a UTF-16 string, including the trailing zero\r\nfunc Utf16FromString(s string) ([]uint16, error) {\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == 0 {\r\n\t\t\treturn nil, syscall.EINVAL\r\n\t\t}\r\n\t}\r\n\treturn utf16.Encode([]rune(s + \"\\x00\")), nil\r\n}\r\n\r\nfunc StringToWcharPtr(s string) *C.WCHAR {\r\n\treturn (*C.WCHAR)(unsafe.Pointer(StringToUTF16Ptr(s)))\r\n}\r\n\r\nfunc StringToUTF16Ptr(s string) *uint16 {\r\n\tus, _ := Utf16FromString(s)\r\n\treturn &us[0]\r\n}\r\n\r\nfunc StringToUTF16PtrWithLen(s string) (*uint16, int) {\r\n\tus, _ := Utf16FromString(s)\r\n\tlength := len(us) - 1\r\n\treturn &us[0], length\r\n}\r\n\r\nfunc ByteCPtrToBytes(bp C.LPCBYTE, size C.UINT) []byte {\r\n\tbs := C.GoBytes(unsafe.Pointer(bp), C.INT(size))\r\n\treturn bs\r\n}\r\n\r\nfunc BytePtrToBytes(bp *byte, size uint) []byte {\r\n\tbs := C.GoBytes(unsafe.Pointer(bp), C.INT(size))\r\n\treturn bs\r\n}\r\n"
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 6.4599609375,
          "content": "package sciter\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"runtime\"\r\n)\r\n\r\ntype NativeFunctor func(args ...*Value) *Value\r\n\r\n// typedef VALUE SCITER_VALUE;\r\n// type Scitervalue Value\r\n\r\ntype valueError struct {\r\n\tResult  VALUE_RESULT\r\n\tMessage string\r\n}\r\n\r\nfunc (e *valueError) Error() string {\r\n\treturn fmt.Sprintf(\"%s: %s\", e.Result.String(), e.Message)\r\n}\r\n\r\nfunc newValueError(ret VALUE_RESULT, msg string) *valueError {\r\n\treturn &valueError{\r\n\t\tResult:  ret,\r\n\t\tMessage: msg,\r\n\t}\r\n}\r\n\r\nfunc wrapValueResult(r VALUE_RESULT, msg string) error {\r\n\tif r == VALUE_RESULT(HV_OK) {\r\n\t\treturn nil\r\n\t}\r\n\treturn newValueError(VALUE_RESULT(r), msg)\r\n}\r\n\r\nfunc valuePanic(result uint, message ...interface{}) {\r\n\tpanic(&valueError{VALUE_RESULT(result), fmt.Sprint(message...)})\r\n}\r\n\r\n// Only supported basic types: int/bool/string/float/NativeFunctor/Value\r\n//\t for creating array: a := NewValue(); a.SetIndex(0, 123)|a.Append(123)\r\n//\t for creating map/object: obj := NewValue(); obj.Set(\"key\", \"value\")\r\n// The creating process would call ValueInit/VlaueClear automatically\r\nfunc NewValue(val ...interface{}) *Value {\r\n\tv := new(Value)\r\n\tv.init()\r\n\truntime.SetFinalizer(v, (*Value).finalize)\r\n\tif len(val) == 0 {\r\n\t\treturn v\r\n\t}\r\n\tv.Assign(val[0])\r\n\treturn v\r\n}\r\n\r\nfunc (v *Value) finalize() {\r\n\t// log.Println(\"finalizing value:\", v)\r\n\tv.clear()\r\n}\r\n\r\n// release the object from sciter and go world\r\nfunc (v *Value) Release() {\r\n\truntime.SetFinalizer(v, nil)\r\n\tv.finalize()\r\n}\r\n\r\n// Assign go value to Sciter Value\r\n// currently supported go types: bool integer float string and NativeFunctor\r\nfunc (v *Value) Assign(val interface{}) {\r\n\tswitch val.(type) {\r\n\tcase string:\r\n\t\ts := val.(string)\r\n\t\tv.SetString(s)\r\n\tcase int:\r\n\t\ti := val.(int)\r\n\t\tv.SetInt(i)\r\n\tcase float64:\r\n\t\tf := val.(float64)\r\n\t\t// valueInit(this); valueFloatDataSet(this, v, T_FLOAT, 0)\r\n\t\tv.SetFloat(f)\r\n\tcase bool:\r\n\t\t// value( bool v )           { valueInit(this); valueIntDataSet(this, v?1:0, T_BOOL, 0); }\r\n\t\tv.SetBool(val.(bool))\r\n\tcase float32:\r\n\t\tv.Assign(float64(val.(float32)))\r\n\tcase uint:\r\n\t\tv.Assign(int(val.(uint)))\r\n\tcase uint32:\r\n\t\tv.Assign(int(val.(uint32)))\r\n\tcase uint64:\r\n\t\tv.Assign(int(val.(uint64)))\r\n\tcase int32:\r\n\t\tv.Assign(int(val.(int32)))\r\n\tcase int64:\r\n\t\tv.Assign(int(val.(int64)))\r\n\tcase Value:\r\n\t\tvf := val.(Value)\r\n\t\tv.Copy(&vf)\r\n\tcase *Value:\r\n\t\tv.Copy(val.(*Value))\r\n\tcase NativeFunctor:\r\n\t\tv.SetNativeFunctor(val.(NativeFunctor))\r\n\tcase func(args ...*Value) *Value:\r\n\t\tv.SetNativeFunctor((NativeFunctor)(val.(func(args ...*Value) *Value)))\r\n\tdefault:\r\n\t\tnf, ok := val.(NativeFunctor)\r\n\t\tif ok {\r\n\t\t\tv.SetNativeFunctor(nf)\r\n\t\t} else {\r\n\t\t\tpanic(\"unsupported value type\")\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// bool is_undefined() const { return t == T_UNDEFINED; }\r\nfunc (v *Value) IsUndefined() bool {\r\n\treturn v.t == T_UNDEFINED\r\n}\r\n\r\n// bool is_bool() const { return t == T_BOOL; }\r\nfunc (v *Value) IsBool() bool {\r\n\treturn v.t == T_BOOL\r\n}\r\n\r\n// bool is_int() const { return t == T_INT; }\r\nfunc (v *Value) IsInt() bool {\r\n\treturn v.t == T_INT\r\n}\r\n\r\n// bool is_float() const { return t == T_FLOAT; }\r\nfunc (v *Value) IsFloat() bool {\r\n\treturn v.t == T_FLOAT\r\n}\r\n\r\n// bool is_string() const { return t == T_STRING; }\r\nfunc (v *Value) IsString() bool {\r\n\treturn v.t == T_STRING\r\n}\r\n\r\n// bool is_symbol() const { return t == T_STRING && u == UT_SYMBOL; }\r\nfunc (v *Value) IsSymbol() bool {\r\n\treturn v.t == T_STRING && v.t == UT_SYMBOL\r\n}\r\n\r\n// bool is_date() const { return t == T_DATE; }\r\nfunc (v *Value) IsDate() bool {\r\n\treturn v.t == T_DATE\r\n}\r\n\r\n// bool is_currency() const { return t == T_CURRENCY; }\r\nfunc (v *Value) IsCurrency() bool {\r\n\treturn v.t == T_CURRENCY\r\n}\r\n\r\n// bool is_map() const { return t == T_MAP; }\r\nfunc (v *Value) IsMap() bool {\r\n\treturn v.t == T_MAP\r\n}\r\n\r\n// bool is_array() const { return t == T_ARRAY; }\r\nfunc (v *Value) IsArray() bool {\r\n\treturn v.t == T_ARRAY\r\n}\r\n\r\n// bool is_function() const { return t == T_FUNCTION; }\r\nfunc (v *Value) IsFunction() bool {\r\n\treturn v.t == T_FUNCTION\r\n}\r\n\r\n// bool is_color() const { return t == T_COLOR; }\r\nfunc (v *Value) IsColor() bool {\r\n\treturn v.t == T_COLOR\r\n}\r\n\r\n// bool is_duration() const { return t == T_DURATION; }\r\nfunc (v *Value) IsDuration() bool {\r\n\treturn v.t == T_DURATION\r\n}\r\n// bool is_angle() const { return t == T_ANGLE; }\r\nfunc (v *Value) IsAngle() bool {\r\n\treturn v.t == T_ANGLE\r\n}\r\n\r\n// bool is_asset() const { return t == T_ASSET; }\r\nfunc (v *Value) IsAsset() bool {\r\n\treturn v.t == T_ASSET\r\n}\r\n\r\n// bool is_bytes() const { return t == T_BYTES; }\r\nfunc (v *Value) IsByte() bool {\r\n\treturn v.t == T_BYTES\r\n}\r\n\r\n// bool is_object() const { return t == T_OBJECT; }\r\nfunc (v *Value) IsObject() bool {\r\n\treturn v.t == T_OBJECT\r\n}\r\n\r\n// bool is_object_native() const   {  return t == T_OBJECT && u == UT_OBJECT_NATIVE; }\r\nfunc (v *Value) IsObjectNative() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_NATIVE\r\n}\r\n\r\n// bool is_object_array() const    {  return t == T_OBJECT && u == UT_OBJECT_ARRAY; }\r\nfunc (v *Value) IsObjectArray() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_ARRAY\r\n}\r\n\r\n// bool is_object_function() const {  return t == T_OBJECT && u == UT_OBJECT_FUNCTION; }\r\nfunc (v *Value) IsObjectFunction() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_FUNCTION\r\n}\r\n\r\n// bool is_object_object() const   {  return t == T_OBJECT && u == UT_OBJECT_OBJECT; } // that is plain TS object\r\nfunc (v *Value) IsObjectObject() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_OBJECT\r\n}\r\n\r\n// bool is_object_class() const    {  return t == T_OBJECT && u == UT_OBJECT_CLASS; }  // that is TS class\r\nfunc (v *Value) IsObjectClass() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_CLASS\r\n}\r\n\r\n// bool is_object_error() const    {  return t == T_OBJECT && u == UT_OBJECT_ERROR; }  // that is TS error\r\nfunc (v *Value) IsObjectE() bool {\r\n\treturn v.t == T_OBJECT && v.u == UT_OBJECT_ERROR\r\n}\r\n\r\n// bool is_dom_element() const { return t == T_DOM_OBJECT; }\r\nfunc (v *Value) IsDomElement() bool {\r\n\treturn v.t == T_DOM_OBJECT\r\n}\r\n\r\n// bool is_null() const { return t == T_NULL; }\r\nfunc (v *Value) IsNull() bool {\r\n\treturn v.t == T_NULL\r\n}\r\n\r\n// // static value null() { value n; n.t = T_NULL; return n; }\r\nfunc NullValue() *Value {\r\n\tv := new(Value)\r\n\tv.init()\r\n\tv.t = T_NULL\r\n\treturn v\r\n}\r\n\r\n// bool is_nothing() const { return t == T_UNDEFINED && u == UT_NOTHING; }\r\nfunc (v *Value) IsNothing() bool {\r\n\treturn v.t == T_UNDEFINED && v.u == UT_NOTHING\r\n}\r\n\r\n// static value nothing() { value n; n.t = T_UNDEFINED; n.u = UT_NOTHING; return n; }\r\nfunc NothingValue() *Value {\r\n\tv := new(Value)\r\n\tv.init()\r\n\tv.t = T_UNDEFINED\r\n\tv.u = UT_NOTHING\r\n\treturn v\r\n}\r\n"
        },
        {
          "name": "window",
          "type": "tree",
          "content": null
        },
        {
          "name": "wrapper.go",
          "type": "blob",
          "size": 5.01953125,
          "content": "package sciter\r\n\r\ntype eventMapper struct {\r\n\tmouseHandlerList         []func(he *Element, params *MouseParams) bool\r\n\tkeyHandlerList           []func(he *Element, params *KeyParams) bool\r\n\tfocusHandlerList         []func(he *Element, params *FocusParams) bool\r\n\ttimerHandlerList         []func(he *Element, params *TimerParams) bool\r\n\tbehaviorEventHandlerList []func(he *Element, params *BehaviorEventParams) bool\r\n\tmethodCallHandlerList    []func(he *Element, params *MethodParams) bool\r\n\tscriptingMethodMap       map[string]func(args ...*Value) *Value\r\n\tdataArrivedHandlerList   []func(he *Element, params *DataArrivedParams) bool\r\n\tsizeHandlerList          []func(he *Element)\r\n\tscrollHandlerList        []func(he *Element, params *ScrollParams) bool\r\n\tgestureHandlerList       []func(he *Element, params *GestureParams) bool\r\n\t// the handler instance\r\n\teventhandler *EventHandler\r\n}\r\n\r\nfunc newEventMapper() *eventMapper {\r\n\tem := &eventMapper{\r\n\t\tmouseHandlerList:         make([]func(he *Element, params *MouseParams) bool, 0),\r\n\t\tkeyHandlerList:           make([]func(he *Element, params *KeyParams) bool, 0),\r\n\t\tfocusHandlerList:         make([]func(he *Element, params *FocusParams) bool, 0),\r\n\t\ttimerHandlerList:         make([]func(he *Element, params *TimerParams) bool, 0),\r\n\t\tbehaviorEventHandlerList: make([]func(he *Element, params *BehaviorEventParams) bool, 0),\r\n\t\tmethodCallHandlerList:    make([]func(he *Element, params *MethodParams) bool, 0),\r\n\t\tscriptingMethodMap:       make(map[string]func(args ...*Value) *Value),\r\n\t\tdataArrivedHandlerList:   make([]func(he *Element, params *DataArrivedParams) bool, 0),\r\n\t\tsizeHandlerList:          make([]func(he *Element), 0),\r\n\t\tscrollHandlerList:        make([]func(he *Element, params *ScrollParams) bool, 0),\r\n\t\tgestureHandlerList:       make([]func(he *Element, params *GestureParams) bool, 0),\r\n\t}\r\n\tem.eventhandler = em.toEventHandler()\r\n\treturn em\r\n}\r\n\r\nfunc (s *Sciter) checkMapper() {\r\n\tif s.eventMapper == nil {\r\n\t\ts.eventMapper = newEventMapper()\r\n\t\ts.AttachWindowEventHandler(s.eventMapper.eventhandler)\r\n\t}\r\n}\r\n\r\nfunc (el *Element) checkMapper() {\r\n\tif el.eventMapper == nil {\r\n\t\tel.eventMapper = newEventMapper()\r\n\t\tel.AttachEventHandler(el.eventMapper.eventhandler)\r\n\t}\r\n}\r\n\r\nfunc (e *eventMapper) addMethod(name string, nf func(args ...*Value) *Value) {\r\n\te.scriptingMethodMap[name] = nf\r\n}\r\n\r\nfunc (e *eventMapper) onClick(fn func()) {\r\n\te.behaviorEventHandlerList = append(e.behaviorEventHandlerList, func(he *Element, params *BehaviorEventParams) bool {\r\n\t\tif params.Cmd() == BUTTON_CLICK && params.Phase() == SINKING {\r\n\t\t\tfn()\r\n\t\t}\r\n\t\treturn false\r\n\t})\r\n}\r\n\r\n// DefineFunction defines global scripting function which works for tiscript and csss! script.\r\n//   The global function must be access via the `view` namespace\r\nfunc (s *Sciter) DefineFunction(name string, nf func(args ...*Value) *Value) {\r\n\ts.checkMapper()\r\n\ts.eventMapper.scriptingMethodMap[name] = nf\r\n}\r\n\r\n// DefineMethod defines Element locally scripting function in tiscript\r\n//   The local method must be access as the element attribute.\r\nfunc (e *Element) DefineMethod(name string, nf func(args ...*Value) *Value) {\r\n\te.checkMapper()\r\n\te.eventMapper.scriptingMethodMap[name] = nf\r\n}\r\n\r\nfunc (e *Element) OnClick(fn func()) {\r\n\te.checkMapper()\r\n\te.eventMapper.onClick(fn)\r\n}\r\n\r\nfunc (e *eventMapper) toEventHandler() *EventHandler {\r\n\treturn &EventHandler{\r\n\t\tOnMouse: func(he *Element, params *MouseParams) bool {\r\n\t\t\tfor _, h := range e.mouseHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnKey: func(he *Element, params *KeyParams) bool {\r\n\t\t\tfor _, h := range e.keyHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnFocus: func(he *Element, params *FocusParams) bool {\r\n\t\t\tfor _, h := range e.focusHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnTimer: func(he *Element, params *TimerParams) bool {\r\n\t\t\tfor _, h := range e.timerHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnBehaviorEvent: func(he *Element, params *BehaviorEventParams) bool {\r\n\t\t\tfor _, h := range e.behaviorEventHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnMethodCall: func(he *Element, params *MethodParams) bool {\r\n\t\t\tfor _, h := range e.methodCallHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnScriptingMethodCall: func(he *Element, params *ScriptingMethodParams) bool {\r\n\t\t\tif nf, ok := e.scriptingMethodMap[params.Name()]; ok {\r\n\t\t\t\tparams.Return(nf(params.Args()...))\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnDataArrived: func(he *Element, params *DataArrivedParams) bool {\r\n\t\t\tfor _, h := range e.dataArrivedHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnSize: func(he *Element) {\r\n\t\t\tfor _, h := range e.sizeHandlerList {\r\n\t\t\t\th(he)\r\n\t\t\t}\r\n\t\t},\r\n\t\tOnScroll: func(he *Element, params *ScrollParams) bool {\r\n\t\t\tfor _, h := range e.scrollHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t\tOnGesture: func(he *Element, params *GestureParams) bool {\r\n\t\t\tfor _, h := range e.gestureHandlerList {\r\n\t\t\t\th(he, params)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t}\r\n}\r\n"
        }
      ]
    }
  ]
}