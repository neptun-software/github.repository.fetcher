{
  "metadata": {
    "timestamp": 1736565939685,
    "page": 917,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sui77/rc-switch",
      "stars": 1955,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.146484375,
          "content": "# Mac stuff\n.DS_Store\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.787109375,
          "content": "language: c\npython:\n  - \"2.7\"\n\n# Cache PlatformIO packages using Travis CI container-based infrastructure \ncache:\n  pip: true\n  directories:\n      - \"~/.platformio\"\n\nenv:\n  - > \n    PLATFORMIO_CI_SRC=$PWD/examples/Webserver \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/Webserver.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01\"\n  - > \n    PLATFORMIO_CI_SRC=$PWD/examples/ReceiveDemo_Simple \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/ReceiveDemo_Simple.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01\"\n  - > \n    PLATFORMIO_CI_SRC=$PWD/examples/TypeC_Intertechno \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/TypeC_Intertechno.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01 --board=attiny25 --board=attiny24\"\n  - > \n    PLATFORMIO_CI_SRC=$PWD/examples/TypeD_REV \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/TypeD_REV.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01 --board=attiny25 --board=attiny24\"\n  - >\n    PLATFORMIO_CI_SRC=$PWD/examples/TypeA_WithDIPSwitches \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/TypeA_WithDIPSwitches.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01 --board=attiny25 --board=attiny24\"\n  - > \n    PLATFORMIO_CI_SRC=$PWD/examples/TypeA_WithDIPSwitches_Lightweight \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/TypeA_WithDIPSwitches_Lightweight.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01 --board=attiny25 --board=attiny24\"\n  - >\n    PLATFORMIO_CI_SRC=$PWD/examples/TypeB_WithRotaryOrSlidingSwitches \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/TypeB_WithRotaryOrSlidingSwitches.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01 --board=attiny25 --board=attiny24\"\n  - >\n    PLATFORMIO_CI_SRC=$PWD/examples/SendDemo \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/SendDemo.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01\"\n  - >\n    PLATFORMIO_CI_SRC=$PWD/examples/ReceiveDemo_Advanced \n    ARDUINOIDE_CI_SRC=$PLATFORMIO_CI_SRC/ReceiveDemo_Advanced.ino\n    BOARDS=\"--board=diecimilaatmega328 --board=uno --board=esp01\"\n \nbefore_install:\n  # Arduino IDE\n  - \"/sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_1.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :1 -ac -screen 0 1280x1024x16\"\n  - sleep 3\n  - export DISPLAY=:1.0\n  - wget http://downloads.arduino.cc/arduino-1.8.10-linux64.tar.xz\n  - tar xf arduino-1.8.10-linux64.tar.xz\n  - sudo mv arduino-1.8.10 /usr/local/share/arduino\n  - sudo ln -s /usr/local/share/arduino/arduino /usr/local/bin/arduino\n  \ninstall:\n  # Arduino IDE\n  - ln -s $PWD /usr/local/share/arduino/libraries/rc-switch\n  # PlatformIO\n  # - pip install -U platformio\n  # - platformio update\n\nscript:\n  # Arduino IDE\n  - arduino --verify --board arduino:avr:uno ${ARDUINOIDE_CI_SRC}\n  # PlatformIO\n  # - platformio run --lib=\".\" ${BOARDS}\n"
        },
        {
          "name": "RCSwitch.cpp",
          "type": "blob",
          "size": 22.5361328125,
          "content": "/*\n  RCSwitch - Arduino libary for remote control outlet switches\n  Copyright (c) 2011 Suat Özgür.  All right reserved.\n  \n  Contributors:\n  - Andre Koehler / info(at)tomate-online(dot)de\n  - Gordeev Andrey Vladimirovich / gordeev(at)openpyro(dot)com\n  - Skineffect / http://forum.ardumote.com/viewtopic.php?f=2&t=46\n  - Dominik Fischer / dom_fischer(at)web(dot)de\n  - Frank Oltmanns / <first name>.<last name>(at)gmail(dot)com\n  - Andreas Steinel / A.<lastname>(at)gmail(dot)com\n  - Max Horn / max(at)quendi(dot)de\n  - Robert ter Vehn / <first name>.<last name>(at)gmail(dot)com\n  - Johann Richard / <first name>.<last name>(at)gmail(dot)com\n  - Vlad Gheorghe / <first name>.<last name>(at)gmail(dot)com https://github.com/vgheo\n  - Matias Cuenca-Acuna \n  \n  Project home: https://github.com/sui77/rc-switch/\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"RCSwitch.h\"\n\n#ifdef RaspberryPi\n    // PROGMEM and _P functions are for AVR based microprocessors,\n    // so we must normalize these for the ARM processor:\n    #define PROGMEM\n    #define memcpy_P(dest, src, num) memcpy((dest), (src), (num))\n#endif\n\n#if defined(ESP8266)\n    // interrupt handler and related code must be in RAM on ESP8266,\n    // according to issue #46.\n    #define RECEIVE_ATTR ICACHE_RAM_ATTR\n    #define VAR_ISR_ATTR\n#elif defined(ESP32)\n    #define RECEIVE_ATTR IRAM_ATTR\n    #define VAR_ISR_ATTR DRAM_ATTR\n#else\n    #define RECEIVE_ATTR\n    #define VAR_ISR_ATTR\n#endif\n\n\n/* Format for protocol definitions:\n * {pulselength, Sync bit, \"0\" bit, \"1\" bit, invertedSignal}\n * \n * pulselength: pulse length in microseconds, e.g. 350\n * Sync bit: {1, 31} means 1 high pulse and 31 low pulses\n *     (perceived as a 31*pulselength long pulse, total length of sync bit is\n *     32*pulselength microseconds), i.e:\n *      _\n *     | |_______________________________ (don't count the vertical bars)\n * \"0\" bit: waveform for a data bit of value \"0\", {1, 3} means 1 high pulse\n *     and 3 low pulses, total length (1+3)*pulselength, i.e:\n *      _\n *     | |___\n * \"1\" bit: waveform for a data bit of value \"1\", e.g. {3,1}:\n *      ___\n *     |   |_\n *\n * These are combined to form Tri-State bits when sending or receiving codes.\n */\n#if defined(ESP8266) || defined(ESP32)\nstatic const VAR_ISR_ATTR RCSwitch::Protocol proto[] = {\n#else\nstatic const RCSwitch::Protocol PROGMEM proto[] = {\n#endif\n  { 350, {  1, 31 }, {  1,  3 }, {  3,  1 }, false },    // protocol 1\n  { 650, {  1, 10 }, {  1,  2 }, {  2,  1 }, false },    // protocol 2\n  { 100, { 30, 71 }, {  4, 11 }, {  9,  6 }, false },    // protocol 3\n  { 380, {  1,  6 }, {  1,  3 }, {  3,  1 }, false },    // protocol 4\n  { 500, {  6, 14 }, {  1,  2 }, {  2,  1 }, false },    // protocol 5\n  { 450, { 23,  1 }, {  1,  2 }, {  2,  1 }, true },     // protocol 6 (HT6P20B)\n  { 150, {  2, 62 }, {  1,  6 }, {  6,  1 }, false },    // protocol 7 (HS2303-PT, i. e. used in AUKEY Remote)\n  { 200, {  3, 130}, {  7, 16 }, {  3,  16}, false},     // protocol 8 Conrad RS-200 RX\n  { 200, { 130, 7 }, {  16, 7 }, { 16,  3 }, true},      // protocol 9 Conrad RS-200 TX\n  { 365, { 18,  1 }, {  3,  1 }, {  1,  3 }, true },     // protocol 10 (1ByOne Doorbell)\n  { 270, { 36,  1 }, {  1,  2 }, {  2,  1 }, true },     // protocol 11 (HT12E)\n  { 320, { 36,  1 }, {  1,  2 }, {  2,  1 }, true }      // protocol 12 (SM5212)\n};\n\nenum {\n   numProto = sizeof(proto) / sizeof(proto[0])\n};\n\n#if not defined( RCSwitchDisableReceiving )\nvolatile unsigned long RCSwitch::nReceivedValue = 0;\nvolatile unsigned int RCSwitch::nReceivedBitlength = 0;\nvolatile unsigned int RCSwitch::nReceivedDelay = 0;\nvolatile unsigned int RCSwitch::nReceivedProtocol = 0;\nint RCSwitch::nReceiveTolerance = 60;\nconst unsigned int VAR_ISR_ATTR RCSwitch::nSeparationLimit = 4300;\n// separationLimit: minimum microseconds between received codes, closer codes are ignored.\n// according to discussion on issue #14 it might be more suitable to set the separation\n// limit to the same time as the 'low' part of the sync signal for the current protocol.\nunsigned int RCSwitch::timings[RCSWITCH_MAX_CHANGES];\n#endif\n\nRCSwitch::RCSwitch() {\n  this->nTransmitterPin = -1;\n  this->setRepeatTransmit(10);\n  this->setProtocol(1);\n  #if not defined( RCSwitchDisableReceiving )\n  this->nReceiverInterrupt = -1;\n  this->setReceiveTolerance(60);\n  RCSwitch::nReceivedValue = 0;\n  #endif\n}\n\n/**\n  * Sets the protocol to send.\n  */\nvoid RCSwitch::setProtocol(Protocol protocol) {\n  this->protocol = protocol;\n}\n\n/**\n  * Sets the protocol to send, from a list of predefined protocols\n  */\nvoid RCSwitch::setProtocol(int nProtocol) {\n  if (nProtocol < 1 || nProtocol > numProto) {\n    nProtocol = 1;  // TODO: trigger an error, e.g. \"bad protocol\" ???\n  }\n#if defined(ESP8266) || defined(ESP32)\n  this->protocol = proto[nProtocol-1];\n#else\n  memcpy_P(&this->protocol, &proto[nProtocol-1], sizeof(Protocol));\n#endif\n}\n\n/**\n  * Sets the protocol to send with pulse length in microseconds.\n  */\nvoid RCSwitch::setProtocol(int nProtocol, int nPulseLength) {\n  setProtocol(nProtocol);\n  this->setPulseLength(nPulseLength);\n}\n\n\n/**\n  * Sets pulse length in microseconds\n  */\nvoid RCSwitch::setPulseLength(int nPulseLength) {\n  this->protocol.pulseLength = nPulseLength;\n}\n\n/**\n * Sets Repeat Transmits\n */\nvoid RCSwitch::setRepeatTransmit(int nRepeatTransmit) {\n  this->nRepeatTransmit = nRepeatTransmit;\n}\n\n/**\n * Set Receiving Tolerance\n */\n#if not defined( RCSwitchDisableReceiving )\nvoid RCSwitch::setReceiveTolerance(int nPercent) {\n  RCSwitch::nReceiveTolerance = nPercent;\n}\n#endif\n  \n\n/**\n * Enable transmissions\n *\n * @param nTransmitterPin    Arduino Pin to which the sender is connected to\n */\nvoid RCSwitch::enableTransmit(int nTransmitterPin) {\n  this->nTransmitterPin = nTransmitterPin;\n  pinMode(this->nTransmitterPin, OUTPUT);\n}\n\n/**\n  * Disable transmissions\n  */\nvoid RCSwitch::disableTransmit() {\n  this->nTransmitterPin = -1;\n}\n\n/**\n * Switch a remote switch on (Type D REV)\n *\n * @param sGroup        Code of the switch group (A,B,C,D)\n * @param nDevice       Number of the switch itself (1..3)\n */\nvoid RCSwitch::switchOn(char sGroup, int nDevice) {\n  this->sendTriState( this->getCodeWordD(sGroup, nDevice, true) );\n}\n\n/**\n * Switch a remote switch off (Type D REV)\n *\n * @param sGroup        Code of the switch group (A,B,C,D)\n * @param nDevice       Number of the switch itself (1..3)\n */\nvoid RCSwitch::switchOff(char sGroup, int nDevice) {\n  this->sendTriState( this->getCodeWordD(sGroup, nDevice, false) );\n}\n\n/**\n * Switch a remote switch on (Type C Intertechno)\n *\n * @param sFamily  Familycode (a..f)\n * @param nGroup   Number of group (1..4)\n * @param nDevice  Number of device (1..4)\n  */\nvoid RCSwitch::switchOn(char sFamily, int nGroup, int nDevice) {\n  this->sendTriState( this->getCodeWordC(sFamily, nGroup, nDevice, true) );\n}\n\n/**\n * Switch a remote switch off (Type C Intertechno)\n *\n * @param sFamily  Familycode (a..f)\n * @param nGroup   Number of group (1..4)\n * @param nDevice  Number of device (1..4)\n */\nvoid RCSwitch::switchOff(char sFamily, int nGroup, int nDevice) {\n  this->sendTriState( this->getCodeWordC(sFamily, nGroup, nDevice, false) );\n}\n\n/**\n * Switch a remote switch on (Type B with two rotary/sliding switches)\n *\n * @param nAddressCode  Number of the switch group (1..4)\n * @param nChannelCode  Number of the switch itself (1..4)\n */\nvoid RCSwitch::switchOn(int nAddressCode, int nChannelCode) {\n  this->sendTriState( this->getCodeWordB(nAddressCode, nChannelCode, true) );\n}\n\n/**\n * Switch a remote switch off (Type B with two rotary/sliding switches)\n *\n * @param nAddressCode  Number of the switch group (1..4)\n * @param nChannelCode  Number of the switch itself (1..4)\n */\nvoid RCSwitch::switchOff(int nAddressCode, int nChannelCode) {\n  this->sendTriState( this->getCodeWordB(nAddressCode, nChannelCode, false) );\n}\n\n/**\n * Deprecated, use switchOn(const char* sGroup, const char* sDevice) instead!\n * Switch a remote switch on (Type A with 10 pole DIP switches)\n *\n * @param sGroup        Code of the switch group (refers to DIP switches 1..5 where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n * @param nChannelCode  Number of the switch itself (1..5)\n */\nvoid RCSwitch::switchOn(const char* sGroup, int nChannel) {\n  const char* code[6] = { \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"00001\" };\n  this->switchOn(sGroup, code[nChannel]);\n}\n\n/**\n * Deprecated, use switchOff(const char* sGroup, const char* sDevice) instead!\n * Switch a remote switch off (Type A with 10 pole DIP switches)\n *\n * @param sGroup        Code of the switch group (refers to DIP switches 1..5 where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n * @param nChannelCode  Number of the switch itself (1..5)\n */\nvoid RCSwitch::switchOff(const char* sGroup, int nChannel) {\n  const char* code[6] = { \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"00001\" };\n  this->switchOff(sGroup, code[nChannel]);\n}\n\n/**\n * Switch a remote switch on (Type A with 10 pole DIP switches)\n *\n * @param sGroup        Code of the switch group (refers to DIP switches 1..5 where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n * @param sDevice       Code of the switch device (refers to DIP switches 6..10 (A..E) where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n */\nvoid RCSwitch::switchOn(const char* sGroup, const char* sDevice) {\n  this->sendTriState( this->getCodeWordA(sGroup, sDevice, true) );\n}\n\n/**\n * Switch a remote switch off (Type A with 10 pole DIP switches)\n *\n * @param sGroup        Code of the switch group (refers to DIP switches 1..5 where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n * @param sDevice       Code of the switch device (refers to DIP switches 6..10 (A..E) where \"1\" = on and \"0\" = off, if all DIP switches are on it's \"11111\")\n */\nvoid RCSwitch::switchOff(const char* sGroup, const char* sDevice) {\n  this->sendTriState( this->getCodeWordA(sGroup, sDevice, false) );\n}\n\n\n/**\n * Returns a char[13], representing the code word to be send.\n *\n */\nchar* RCSwitch::getCodeWordA(const char* sGroup, const char* sDevice, bool bStatus) {\n  static char sReturn[13];\n  int nReturnPos = 0;\n\n  for (int i = 0; i < 5; i++) {\n    sReturn[nReturnPos++] = (sGroup[i] == '0') ? 'F' : '0';\n  }\n\n  for (int i = 0; i < 5; i++) {\n    sReturn[nReturnPos++] = (sDevice[i] == '0') ? 'F' : '0';\n  }\n\n  sReturn[nReturnPos++] = bStatus ? '0' : 'F';\n  sReturn[nReturnPos++] = bStatus ? 'F' : '0';\n\n  sReturn[nReturnPos] = '\\0';\n  return sReturn;\n}\n\n/**\n * Encoding for type B switches with two rotary/sliding switches.\n *\n * The code word is a tristate word and with following bit pattern:\n *\n * +-----------------------------+-----------------------------+----------+------------+\n * | 4 bits address              | 4 bits address              | 3 bits   | 1 bit      |\n * | switch group                | switch number               | not used | on / off   |\n * | 1=0FFF 2=F0FF 3=FF0F 4=FFF0 | 1=0FFF 2=F0FF 3=FF0F 4=FFF0 | FFF      | on=F off=0 |\n * +-----------------------------+-----------------------------+----------+------------+\n *\n * @param nAddressCode  Number of the switch group (1..4)\n * @param nChannelCode  Number of the switch itself (1..4)\n * @param bStatus       Whether to switch on (true) or off (false)\n *\n * @return char[13], representing a tristate code word of length 12\n */\nchar* RCSwitch::getCodeWordB(int nAddressCode, int nChannelCode, bool bStatus) {\n  static char sReturn[13];\n  int nReturnPos = 0;\n\n  if (nAddressCode < 1 || nAddressCode > 4 || nChannelCode < 1 || nChannelCode > 4) {\n    return 0;\n  }\n\n  for (int i = 1; i <= 4; i++) {\n    sReturn[nReturnPos++] = (nAddressCode == i) ? '0' : 'F';\n  }\n\n  for (int i = 1; i <= 4; i++) {\n    sReturn[nReturnPos++] = (nChannelCode == i) ? '0' : 'F';\n  }\n\n  sReturn[nReturnPos++] = 'F';\n  sReturn[nReturnPos++] = 'F';\n  sReturn[nReturnPos++] = 'F';\n\n  sReturn[nReturnPos++] = bStatus ? 'F' : '0';\n\n  sReturn[nReturnPos] = '\\0';\n  return sReturn;\n}\n\n/**\n * Like getCodeWord (Type C = Intertechno)\n */\nchar* RCSwitch::getCodeWordC(char sFamily, int nGroup, int nDevice, bool bStatus) {\n  static char sReturn[13];\n  int nReturnPos = 0;\n\n  int nFamily = (int)sFamily - 'a';\n  if ( nFamily < 0 || nFamily > 15 || nGroup < 1 || nGroup > 4 || nDevice < 1 || nDevice > 4) {\n    return 0;\n  }\n  \n  // encode the family into four bits\n  sReturn[nReturnPos++] = (nFamily & 1) ? 'F' : '0';\n  sReturn[nReturnPos++] = (nFamily & 2) ? 'F' : '0';\n  sReturn[nReturnPos++] = (nFamily & 4) ? 'F' : '0';\n  sReturn[nReturnPos++] = (nFamily & 8) ? 'F' : '0';\n\n  // encode the device and group\n  sReturn[nReturnPos++] = ((nDevice-1) & 1) ? 'F' : '0';\n  sReturn[nReturnPos++] = ((nDevice-1) & 2) ? 'F' : '0';\n  sReturn[nReturnPos++] = ((nGroup-1) & 1) ? 'F' : '0';\n  sReturn[nReturnPos++] = ((nGroup-1) & 2) ? 'F' : '0';\n\n  // encode the status code\n  sReturn[nReturnPos++] = '0';\n  sReturn[nReturnPos++] = 'F';\n  sReturn[nReturnPos++] = 'F';\n  sReturn[nReturnPos++] = bStatus ? 'F' : '0';\n\n  sReturn[nReturnPos] = '\\0';\n  return sReturn;\n}\n\n/**\n * Encoding for the REV Switch Type\n *\n * The code word is a tristate word and with following bit pattern:\n *\n * +-----------------------------+-------------------+----------+--------------+\n * | 4 bits address              | 3 bits address    | 3 bits   | 2 bits       |\n * | switch group                | device number     | not used | on / off     |\n * | A=1FFF B=F1FF C=FF1F D=FFF1 | 1=0FF 2=F0F 3=FF0 | 000      | on=10 off=01 |\n * +-----------------------------+-------------------+----------+--------------+\n *\n * Source: http://www.the-intruder.net/funksteckdosen-von-rev-uber-arduino-ansteuern/\n *\n * @param sGroup        Name of the switch group (A..D, resp. a..d) \n * @param nDevice       Number of the switch itself (1..3)\n * @param bStatus       Whether to switch on (true) or off (false)\n *\n * @return char[13], representing a tristate code word of length 12\n */\nchar* RCSwitch::getCodeWordD(char sGroup, int nDevice, bool bStatus) {\n  static char sReturn[13];\n  int nReturnPos = 0;\n\n  // sGroup must be one of the letters in \"abcdABCD\"\n  int nGroup = (sGroup >= 'a') ? (int)sGroup - 'a' : (int)sGroup - 'A';\n  if ( nGroup < 0 || nGroup > 3 || nDevice < 1 || nDevice > 3) {\n    return 0;\n  }\n\n  for (int i = 0; i < 4; i++) {\n    sReturn[nReturnPos++] = (nGroup == i) ? '1' : 'F';\n  }\n\n  for (int i = 1; i <= 3; i++) {\n    sReturn[nReturnPos++] = (nDevice == i) ? '1' : 'F';\n  }\n\n  sReturn[nReturnPos++] = '0';\n  sReturn[nReturnPos++] = '0';\n  sReturn[nReturnPos++] = '0';\n\n  sReturn[nReturnPos++] = bStatus ? '1' : '0';\n  sReturn[nReturnPos++] = bStatus ? '0' : '1';\n\n  sReturn[nReturnPos] = '\\0';\n  return sReturn;\n}\n\n/**\n * @param sCodeWord   a tristate code word consisting of the letter 0, 1, F\n */\nvoid RCSwitch::sendTriState(const char* sCodeWord) {\n  // turn the tristate code word into the corresponding bit pattern, then send it\n  unsigned long code = 0;\n  unsigned int length = 0;\n  for (const char* p = sCodeWord; *p; p++) {\n    code <<= 2L;\n    switch (*p) {\n      case '0':\n        // bit pattern 00\n        break;\n      case 'F':\n        // bit pattern 01\n        code |= 1L;\n        break;\n      case '1':\n        // bit pattern 11\n        code |= 3L;\n        break;\n    }\n    length += 2;\n  }\n  this->send(code, length);\n}\n\n/**\n * @param sCodeWord   a binary code word consisting of the letter 0, 1\n */\nvoid RCSwitch::send(const char* sCodeWord) {\n  // turn the tristate code word into the corresponding bit pattern, then send it\n  unsigned long code = 0;\n  unsigned int length = 0;\n  for (const char* p = sCodeWord; *p; p++) {\n    code <<= 1L;\n    if (*p != '0')\n      code |= 1L;\n    length++;\n  }\n  this->send(code, length);\n}\n\n/**\n * Transmit the first 'length' bits of the integer 'code'. The\n * bits are sent from MSB to LSB, i.e., first the bit at position length-1,\n * then the bit at position length-2, and so on, till finally the bit at position 0.\n */\nvoid RCSwitch::send(unsigned long code, unsigned int length) {\n  if (this->nTransmitterPin == -1)\n    return;\n\n#if not defined( RCSwitchDisableReceiving )\n  // make sure the receiver is disabled while we transmit\n  int nReceiverInterrupt_backup = nReceiverInterrupt;\n  if (nReceiverInterrupt_backup != -1) {\n    this->disableReceive();\n  }\n#endif\n\n  for (int nRepeat = 0; nRepeat < nRepeatTransmit; nRepeat++) {\n    for (int i = length-1; i >= 0; i--) {\n      if (code & (1L << i))\n        this->transmit(protocol.one);\n      else\n        this->transmit(protocol.zero);\n    }\n    this->transmit(protocol.syncFactor);\n  }\n\n  // Disable transmit after sending (i.e., for inverted protocols)\n  digitalWrite(this->nTransmitterPin, LOW);\n\n#if not defined( RCSwitchDisableReceiving )\n  // enable receiver again if we just disabled it\n  if (nReceiverInterrupt_backup != -1) {\n    this->enableReceive(nReceiverInterrupt_backup);\n  }\n#endif\n}\n\n/**\n * Transmit a single high-low pulse.\n */\nvoid RCSwitch::transmit(HighLow pulses) {\n  uint8_t firstLogicLevel = (this->protocol.invertedSignal) ? LOW : HIGH;\n  uint8_t secondLogicLevel = (this->protocol.invertedSignal) ? HIGH : LOW;\n  \n  digitalWrite(this->nTransmitterPin, firstLogicLevel);\n  delayMicroseconds( this->protocol.pulseLength * pulses.high);\n  digitalWrite(this->nTransmitterPin, secondLogicLevel);\n  delayMicroseconds( this->protocol.pulseLength * pulses.low);\n}\n\n\n#if not defined( RCSwitchDisableReceiving )\n/**\n * Enable receiving data\n */\nvoid RCSwitch::enableReceive(int interrupt) {\n  this->nReceiverInterrupt = interrupt;\n  this->enableReceive();\n}\n\nvoid RCSwitch::enableReceive() {\n  if (this->nReceiverInterrupt != -1) {\n    RCSwitch::nReceivedValue = 0;\n    RCSwitch::nReceivedBitlength = 0;\n#if defined(RaspberryPi) // Raspberry Pi\n    wiringPiISR(this->nReceiverInterrupt, INT_EDGE_BOTH, &handleInterrupt);\n#else // Arduino\n    attachInterrupt(this->nReceiverInterrupt, handleInterrupt, CHANGE);\n#endif\n  }\n}\n\n/**\n * Disable receiving data\n */\nvoid RCSwitch::disableReceive() {\n#if not defined(RaspberryPi) // Arduino\n  detachInterrupt(this->nReceiverInterrupt);\n#endif // For Raspberry Pi (wiringPi) you can't unregister the ISR\n  this->nReceiverInterrupt = -1;\n}\n\nbool RCSwitch::available() {\n  return RCSwitch::nReceivedValue != 0;\n}\n\nvoid RCSwitch::resetAvailable() {\n  RCSwitch::nReceivedValue = 0;\n}\n\nunsigned long RCSwitch::getReceivedValue() {\n  return RCSwitch::nReceivedValue;\n}\n\nunsigned int RCSwitch::getReceivedBitlength() {\n  return RCSwitch::nReceivedBitlength;\n}\n\nunsigned int RCSwitch::getReceivedDelay() {\n  return RCSwitch::nReceivedDelay;\n}\n\nunsigned int RCSwitch::getReceivedProtocol() {\n  return RCSwitch::nReceivedProtocol;\n}\n\nunsigned int* RCSwitch::getReceivedRawdata() {\n  return RCSwitch::timings;\n}\n\n/* helper function for the receiveProtocol method */\nstatic inline unsigned int diff(int A, int B) {\n  return abs(A - B);\n}\n\n/**\n *\n */\nbool RECEIVE_ATTR RCSwitch::receiveProtocol(const int p, unsigned int changeCount) {\n#if defined(ESP8266) || defined(ESP32)\n    const Protocol &pro = proto[p-1];\n#else\n    Protocol pro;\n    memcpy_P(&pro, &proto[p-1], sizeof(Protocol));\n#endif\n\n    unsigned long code = 0;\n    //Assuming the longer pulse length is the pulse captured in timings[0]\n    const unsigned int syncLengthInPulses =  ((pro.syncFactor.low) > (pro.syncFactor.high)) ? (pro.syncFactor.low) : (pro.syncFactor.high);\n    const unsigned int delay = RCSwitch::timings[0] / syncLengthInPulses;\n    const unsigned int delayTolerance = delay * RCSwitch::nReceiveTolerance / 100;\n    \n    /* For protocols that start low, the sync period looks like\n     *               _________\n     * _____________|         |XXXXXXXXXXXX|\n     *\n     * |--1st dur--|-2nd dur-|-Start data-|\n     *\n     * The 3rd saved duration starts the data.\n     *\n     * For protocols that start high, the sync period looks like\n     *\n     *  ______________\n     * |              |____________|XXXXXXXXXXXXX|\n     *\n     * |-filtered out-|--1st dur--|--Start data--|\n     *\n     * The 2nd saved duration starts the data\n     */\n    const unsigned int firstDataTiming = (pro.invertedSignal) ? (2) : (1);\n\n    for (unsigned int i = firstDataTiming; i < changeCount - 1; i += 2) {\n        code <<= 1;\n        if (diff(RCSwitch::timings[i], delay * pro.zero.high) < delayTolerance &&\n            diff(RCSwitch::timings[i + 1], delay * pro.zero.low) < delayTolerance) {\n            // zero\n        } else if (diff(RCSwitch::timings[i], delay * pro.one.high) < delayTolerance &&\n                   diff(RCSwitch::timings[i + 1], delay * pro.one.low) < delayTolerance) {\n            // one\n            code |= 1;\n        } else {\n            // Failed\n            return false;\n        }\n    }\n\n    if (changeCount > 7) {    // ignore very short transmissions: no device sends them, so this must be noise\n        RCSwitch::nReceivedValue = code;\n        RCSwitch::nReceivedBitlength = (changeCount - 1) / 2;\n        RCSwitch::nReceivedDelay = delay;\n        RCSwitch::nReceivedProtocol = p;\n        return true;\n    }\n\n    return false;\n}\n\nvoid RECEIVE_ATTR RCSwitch::handleInterrupt() {\n\n  static unsigned int changeCount = 0;\n  static unsigned long lastTime = 0;\n  static unsigned int repeatCount = 0;\n\n  const long time = micros();\n  const unsigned int duration = time - lastTime;\n\n  if (duration > RCSwitch::nSeparationLimit) {\n    // A long stretch without signal level change occurred. This could\n    // be the gap between two transmission.\n    if ((repeatCount==0) || (diff(duration, RCSwitch::timings[0]) < 200)) {\n      // This long signal is close in length to the long signal which\n      // started the previously recorded timings; this suggests that\n      // it may indeed by a a gap between two transmissions (we assume\n      // here that a sender will send the signal multiple times,\n      // with roughly the same gap between them).\n      repeatCount++;\n      if (repeatCount == 2) {\n        for(unsigned int i = 1; i <= numProto; i++) {\n          if (receiveProtocol(i, changeCount)) {\n            // receive succeeded for protocol i\n            break;\n          }\n        }\n        repeatCount = 0;\n      }\n    }\n    changeCount = 0;\n  }\n \n  // detect overflow\n  if (changeCount >= RCSWITCH_MAX_CHANGES) {\n    changeCount = 0;\n    repeatCount = 0;\n  }\n\n  RCSwitch::timings[changeCount++] = duration;\n  lastTime = time;  \n}\n#endif\n"
        },
        {
          "name": "RCSwitch.h",
          "type": "blob",
          "size": 6.34375,
          "content": "/*\n  RCSwitch - Arduino libary for remote control outlet switches\n  Copyright (c) 2011 Suat Özgür.  All right reserved.\n\n  Contributors:\n  - Andre Koehler / info(at)tomate-online(dot)de\n  - Gordeev Andrey Vladimirovich / gordeev(at)openpyro(dot)com\n  - Skineffect / http://forum.ardumote.com/viewtopic.php?f=2&t=46\n  - Dominik Fischer / dom_fischer(at)web(dot)de\n  - Frank Oltmanns / <first name>.<last name>(at)gmail(dot)com\n  - Max Horn / max(at)quendi(dot)de\n  - Robert ter Vehn / <first name>.<last name>(at)gmail(dot)com\n  \n  Project home: https://github.com/sui77/rc-switch/\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#ifndef _RCSwitch_h\n#define _RCSwitch_h\n\n#if defined(ARDUINO) && ARDUINO >= 100\n    #include \"Arduino.h\"\n#elif defined(ENERGIA) // LaunchPad, FraunchPad and StellarPad specific\n    #include \"Energia.h\"\n#elif defined(RPI) // Raspberry Pi\n    #define RaspberryPi\n\n    // Include libraries for RPi:\n    #include <string.h> /* memcpy */\n    #include <stdlib.h> /* abs */\n    #include <wiringPi.h>\n#elif defined(SPARK)\n    #include \"application.h\"\n#else\n    #include \"WProgram.h\"\n#endif\n\n#include <stdint.h>\n\n\n// At least for the ATTiny X4/X5, receiving has to be disabled due to\n// missing libm depencies (udivmodhi4)\n#if defined( __AVR_ATtinyX5__ ) or defined ( __AVR_ATtinyX4__ )\n#define RCSwitchDisableReceiving\n#endif\n\n// Number of maximum high/Low changes per packet.\n// We can handle up to (unsigned long) => 32 bit * 2 H/L changes per bit + 2 for sync\n#define RCSWITCH_MAX_CHANGES 67\n\nclass RCSwitch {\n\n  public:\n    RCSwitch();\n    \n    void switchOn(int nGroupNumber, int nSwitchNumber);\n    void switchOff(int nGroupNumber, int nSwitchNumber);\n    void switchOn(const char* sGroup, int nSwitchNumber);\n    void switchOff(const char* sGroup, int nSwitchNumber);\n    void switchOn(char sFamily, int nGroup, int nDevice);\n    void switchOff(char sFamily, int nGroup, int nDevice);\n    void switchOn(const char* sGroup, const char* sDevice);\n    void switchOff(const char* sGroup, const char* sDevice);\n    void switchOn(char sGroup, int nDevice);\n    void switchOff(char sGroup, int nDevice);\n\n    void sendTriState(const char* sCodeWord);\n    void send(unsigned long code, unsigned int length);\n    void send(const char* sCodeWord);\n    \n    #if not defined( RCSwitchDisableReceiving )\n    void enableReceive(int interrupt);\n    void enableReceive();\n    void disableReceive();\n    bool available();\n    void resetAvailable();\n\n    unsigned long getReceivedValue();\n    unsigned int getReceivedBitlength();\n    unsigned int getReceivedDelay();\n    unsigned int getReceivedProtocol();\n    unsigned int* getReceivedRawdata();\n    #endif\n  \n    void enableTransmit(int nTransmitterPin);\n    void disableTransmit();\n    void setPulseLength(int nPulseLength);\n    void setRepeatTransmit(int nRepeatTransmit);\n    #if not defined( RCSwitchDisableReceiving )\n    void setReceiveTolerance(int nPercent);\n    #endif\n\n    /**\n     * Description of a single pule, which consists of a high signal\n     * whose duration is \"high\" times the base pulse length, followed\n     * by a low signal lasting \"low\" times the base pulse length.\n     * Thus, the pulse overall lasts (high+low)*pulseLength\n     */\n    struct HighLow {\n        uint8_t high;\n        uint8_t low;\n    };\n\n    /**\n     * A \"protocol\" describes how zero and one bits are encoded into high/low\n     * pulses.\n     */\n    struct Protocol {\n        /** base pulse length in microseconds, e.g. 350 */\n        uint16_t pulseLength;\n\n        HighLow syncFactor;\n        HighLow zero;\n        HighLow one;\n\n        /**\n         * If true, interchange high and low logic levels in all transmissions.\n         *\n         * By default, RCSwitch assumes that any signals it sends or receives\n         * can be broken down into pulses which start with a high signal level,\n         * followed by a a low signal level. This is e.g. the case for the\n         * popular PT 2260 encoder chip, and thus many switches out there.\n         *\n         * But some devices do it the other way around, and start with a low\n         * signal level, followed by a high signal level, e.g. the HT6P20B. To\n         * accommodate this, one can set invertedSignal to true, which causes\n         * RCSwitch to change how it interprets any HighLow struct FOO: It will\n         * then assume transmissions start with a low signal lasting\n         * FOO.high*pulseLength microseconds, followed by a high signal lasting\n         * FOO.low*pulseLength microseconds.\n         */\n        bool invertedSignal;\n    };\n\n    void setProtocol(Protocol protocol);\n    void setProtocol(int nProtocol);\n    void setProtocol(int nProtocol, int nPulseLength);\n\n  private:\n    char* getCodeWordA(const char* sGroup, const char* sDevice, bool bStatus);\n    char* getCodeWordB(int nGroupNumber, int nSwitchNumber, bool bStatus);\n    char* getCodeWordC(char sFamily, int nGroup, int nDevice, bool bStatus);\n    char* getCodeWordD(char group, int nDevice, bool bStatus);\n    void transmit(HighLow pulses);\n\n    #if not defined( RCSwitchDisableReceiving )\n    static void handleInterrupt();\n    static bool receiveProtocol(const int p, unsigned int changeCount);\n    int nReceiverInterrupt;\n    #endif\n    int nTransmitterPin;\n    int nRepeatTransmit;\n    \n    Protocol protocol;\n\n    #if not defined( RCSwitchDisableReceiving )\n    static int nReceiveTolerance;\n    volatile static unsigned long nReceivedValue;\n    volatile static unsigned int nReceivedBitlength;\n    volatile static unsigned int nReceivedDelay;\n    volatile static unsigned int nReceivedProtocol;\n    const static unsigned int nSeparationLimit;\n    /* \n     * timings[0] contains sync timing, followed by a number of bits\n     */\n    static unsigned int timings[RCSWITCH_MAX_CHANGES];\n    #endif\n\n    \n};\n\n#endif\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.416015625,
          "content": "# rc-switch\n[![arduino-library-badge](https://www.ardu-badge.com/badge/rc-switch.svg?)](https://www.ardu-badge.com/rc-switch)\n[![Build Status](https://travis-ci.org/sui77/rc-switch.svg?branch=master)](https://travis-ci.org/sui77/rc-switch)\n\nUse your Arduino or [Raspberry Pi](https://github.com/r10r/rcswitch-pi) to operate remote radio controlled devices\n\n## Download\nhttps://github.com/sui77/rc-switch/releases/latest\n\nrc-switch is also listed in the arduino library manager.\n\n## Wiki\nhttps://github.com/sui77/rc-switch/wiki\n\n## Info\n### Send RC codes\n\nUse your Arduino or Raspberry Pi to operate remote radio controlled devices.\nThis will most likely work with all popular low cost power outlet sockets. If\nyours doesn't work, you might need to adjust the pulse length.\n\nAll you need is a Arduino or Raspberry Pi, a 315/433MHz AM transmitter and one\nor more devices with one of the supported chipsets:\n\n - SC5262 / SC5272\n - HX2262 / HX2272\n - PT2262 / PT2272\n - EV1527 / RT1527 / FP1527 / HS1527 \n - Intertechno outlets\n - HT6P20X\n\n### Receive and decode RC codes\n\nFind out what codes your remote is sending. Use your remote to control your\nArduino.\n\nAll you need is an Arduino, a 315/433MHz AM receiver (altough there is no\ninstruction yet, yes it is possible to hack an existing device) and a remote\nhand set.\n\nFor the Raspberry Pi, clone the https://github.com/ninjablocks/433Utils project to\ncompile a sniffer tool and transmission commands.\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 1.1103515625,
          "content": "#######################################\n# Syntax Coloring Map For RCSwitch\n#######################################\n\n#######################################\n# Datatypes (KEYWORD1)\n#######################################\n\nRCSwitch\tKEYWORD1\n\n#######################################\n# Methods and Functions (KEYWORD2)\n#######################################\n\n##########\n#SENDS Begin\n##########\nswitchOn\t\tKEYWORD2\nswitchOff\t\tKEYWORD2\nsendTriState\t\tKEYWORD2\nsend\t\t\tKEYWORD2\n##########\n#SENDS End\n##########\n\n##########\n#RECEIVE Begin\n##########\nenableReceive\t\tKEYWORD2\ndisableReceive\t\tKEYWORD2\navailable\t\tKEYWORD2\t\nresetAvailable\t\tKEYWORD2\nsetReceiveTolerance\tKEYWORD2\ngetReceivedValue\tKEYWORD2\ngetReceivedBitlength\tKEYWORD2\ngetReceivedDelay\tKEYWORD2\ngetReceivedProtocol\tKEYWORD2\ngetReceivedRawdata\tKEYWORD2\n##########\n#RECEIVE End\n##########\n\n##########\n#OTHERS Begin\n##########\nenableTransmit\t\tKEYWORD2\ndisableTransmit\t\tKEYWORD2\nsetPulseLength\t\tKEYWORD2\nsetProtocol\t\tKEYWORD2\nsetRepeatTransmit\tKEYWORD2\n##########\n#OTHERS End\n##########\n\n#######################################\n# Constants (LITERAL1)\n#######################################\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.4140625,
          "content": "{\n  \"name\": \"rc-switch\",\n  \"description\": \"Use your Arduino or Raspberry Pi to operate remote radio controlled devices\",\n  \"keywords\": \"rf, radio, wireless\",\n  \"authors\":\n  {\n    \"name\": \"Suat Ozgur\"\n  },\n  \"repository\":\n  {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sui77/rc-switch.git\"\n  },\n  \"version\": \"2.6.4\",\n  \"frameworks\": [\n        \"arduino\",\n        \"energia\",\n        \"wiringpi\"\n  ],\n  \"platforms\": \"*\"\n}\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.419921875,
          "content": "name=rc-switch\nversion=2.6.4\nauthor=sui77\nmaintainer=sui77,fingolfin <noreply@sui.li>\nsentence=Operate 433/315Mhz devices.\nparagraph=Use your Arduino, ESP8266/ESP32 or Raspberry Pi to operate remote radio controlled devices. This will most likely work with all popular low cost power outlet sockets. \ncategory=Device Control\nurl=https://github.com/sui77/rc-switch\narchitectures=avr,esp8266,esp32,stm32,megaavr\nincludes=RCSwitch.h\n"
        }
      ]
    }
  ]
}