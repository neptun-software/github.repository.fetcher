{
  "metadata": {
    "timestamp": 1736565576652,
    "page": 450,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "SerenityOS/jakt",
      "stars": 2835,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.3427734375,
          "content": "---\nLanguage: Cpp\nBasedOnStyle: WebKit\nSpaceAfterTemplateKeyword: false\nAlignEscapedNewlines: Left\nAlignTrailingComments: true\nBreakBeforeInheritanceComma: true\nBreakConstructorInitializers: BeforeComma\nIndentPPDirectives: AfterHash\nBreakBeforeBraces: Custom\nBraceWrapping:\n    AfterFunction: true\nNamespaceIndentation: None\nQualifierAlignment: Right\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "build/\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.009765625,
          "content": "* eof=lf\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.162109375,
          "content": "target\na.out\noutput.cpp\nbuild\nresult\n\n.vscode/\n.idea/\njakttest/.ninja_log\n.ninja_log\ncmake_install.cmake\nCMakeFiles/\n\n# Populated by CMake, don't commit.\nruntime/AK\n\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.23046875,
          "content": "repos:\n  - repo: local\n    hooks:\n      - id: meta-lint-commit\n        name: Lint commit message to ensure it will pass the commit linting on CI\n        entry: meta/lint-commit.sh\n        stages: [ commit-msg ]\n        language: system\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 11.4189453125,
          "content": "cmake_minimum_required(VERSION 3.16..3.21)\ncmake_policy(SET CMP0091 NEW)\n\nproject(Jakt\n        VERSION 0.0.1\n        LANGUAGES CXX C\n        HOMEPAGE_URL https://github.com/SerenityOS/jakt\n        DESCRIPTION \"Jakt programming language compiler\")\n\n# FIXME: Serenity's CMake toolchain files don't seem to include these,\n#        and not having them makes CMake find host packages for a serenity build...\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n\nfind_program(CCACHE_PROGRAM ccache)\nif(CCACHE_PROGRAM)\n    set(CMAKE_C_COMPILER_LAUNCHER \"${CCACHE_PROGRAM}\" CACHE FILEPATH \"Path to a compiler launcher program, e.g. ccache\")\n    set(CMAKE_CXX_COMPILER_LAUNCHER \"${CCACHE_PROGRAM}\" CACHE FILEPATH \"Path to a compiler launcher program, e.g. ccache\")\nendif()\n\nfind_package(Threads REQUIRED)\n\nSET(CMAKE_FIND_PACKAGE_SORT_ORDER NATURAL)\nSET(CMAKE_FIND_PACKAGE_SORT_DIRECTION DEC)\nfind_package(Clang CONFIG\n  PATHS /opt/homebrew/opt/llvm\n)\n\nset(JAKT_CPP_AUTO_IMPORT_PROCESSOR_DEFAULT none)\nif (Clang_FOUND)\n  set(JAKT_CPP_AUTO_IMPORT_PROCESSOR_DEFAULT clang)\n  find_program(CLANG_PATH clang REQUIRED\n    PATHS \"${CLANG_INSTALL_PREFIX}/bin\"\n    NO_DEFAULT_PATH\n  )\n  execute_process(\n    COMMAND\n      ${CLANG_PATH} -print-resource-dir\n    OUTPUT_VARIABLE\n      JAKT_CLANG_RESOURCE_DIR\n    OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\nendif()\n\ninclude(GNUInstallDirs)\ninclude(\"cmake/symlink.cmake\")\n\nset(FINAL_STAGE \"1\" CACHE STRING \"Compiler stage to stop at, either 1 (default) or 2)\")\noption(SERENITY_SOURCE_DIR PATH \"Path of an existing SerenityOS checkout to pull AK files from\")\nset(CPP_AUTO_IMPORT_PROCESSOR \"${JAKT_CPP_AUTO_IMPORT_PROCESSOR_DEFAULT}\" CACHE STRING \"'import extern' processor to use (default=none/clang/libcpp/none)\")\n\nset(JAKT_USING_CLANG OFF)\nset(JAKT_CPP_AUTO_IMPORT_PROCESSOR \"${CPP_AUTO_IMPORT_PROCESSOR}\")\nset(JAKT_CPP_AUTO_IMPORT_EXTRA_SOURCES\n  selfhost/cpp_import/none.jakt\n)\n\nif (CPP_AUTO_IMPORT_PROCESSOR STREQUAL \"clang\")\n  set(JAKT_USING_CLANG ON)\n  set(JAKT_CPP_AUTO_IMPORT_EXTRA_SOURCES\n    selfhost/cpp_import/clang.jakt\n    selfhost/cpp_import/clang_c.jakt\n  )\nelseif(CPP_AUTO_IMPORT_PROCESSOR STREQUAL \"libcpp\")\n  set(JAKT_CPP_AUTO_IMPORT_EXTRA_SOURCES\n    selfhost/cpp_import/libcpp.jakt\n    selfhost/cpp_import/hashmap.jakt\n    selfhost/cpp_import/vector.jakt\n  )\nendif()\n\nmessage(STATUS \"Using ${JAKT_CPP_AUTO_IMPORT_PROCESSOR} as the cpp import processor (using Clang=${JAKT_USING_CLANG}, resource dir=${JAKT_CLANG_RESOURCE_DIR})\")\n\nset(in_build_prefix \"\")\nget_cmake_property(is_multi_config GENERATOR_IS_MULTI_CONFIG)\nif (is_multi_config)\n  set(in_build_prefix \"$<CONFIG>/\")\nendif()\n\nfunction(apply_output_rules target)\n  cmake_parse_arguments(PARSE_ARGV 1 OUTPUT_RULES \"\" \"TARGET_DIR\" \"\")\n  set(output_prefix \"${PROJECT_BINARY_DIR}/${in_build_prefix}\")\n  set_property(TARGET ${target} PROPERTY \"ARCHIVE_OUTPUT_DIRECTORY\" \"${output_prefix}lib/${OUTPUT_RULES_TARGET_DIR}\")\n  set_property(TARGET ${target} PROPERTY \"LIBRARY_OUTPUT_DIRECTORY\" \"${output_prefix}lib/${OUTPUT_RULES_TARGET_DIR}\")\n  set_property(TARGET ${target} PROPERTY \"RUNTIME_OUTPUT_DIRECTORY\" \"${output_prefix}bin/${OUTPUT_RULES_TARGET_DIR}\")\nendfunction()\n\ninclude(cmake/jakt-executable.cmake)\n\nadd_subdirectory(runtime)\n\nif (NOT ${JAKT_TARGET_TRIPLE} STREQUAL ${JAKT_DEFAULT_TARGET_TRIPLE})\n  jakt_make_runtime_available(TARGET ${JAKT_TARGET_TRIPLE})\nendif()\n\nset(JAKT_BOOTSTRAP_COMPILER \"\" CACHE FILEPATH \"Path to an existing bootstrap jakt compiler\")\nset(JAKT_BUILDING_STAGE0 NO)\nif (CMAKE_CROSSCOMPILING OR NOT (JAKT_BOOTSTRAP_COMPILER STREQUAL \"\"))\n  if (JAKT_BOOTSTRAP_COMPILER STREQUAL \"\")\n    find_program(HOST_JAKT jakt REQUIRED HINTS jakt-install/bin)\n  else()\n    set(HOST_JAKT \"${JAKT_BOOTSTRAP_COMPILER}\")\n  endif()\n  add_executable(Jakt::jakt IMPORTED)\n  set_target_properties(Jakt::jakt PROPERTIES IMPORTED_LOCATION \"${HOST_JAKT}\")\n  set(BOOSTRAP_COMPILER ${HOST_JAKT})\n  message(STATUS \"Using host jakt at ${HOST_JAKT} to bootstrap\")\nelse()\n  set(JAKT_BUILDING_STAGE0 YES)\n  file(GLOB JAKT_STAGE0_SOURCES CONFIGURE_DEPENDS \"bootstrap/stage0/*.cpp\")\n  file(GLOB JAKT_STAGE0_RUNTIME_SOURCES CONFIGURE_DEPENDS \"bootstrap/stage0/runtime/*.cpp\")\n  file(GLOB JAKT_STAGE0_RUNTIME_LIB_SOURCES CONFIGURE_DEPENDS \"bootstrap/stage0/runtime/*/*.cpp\")\n  list(APPEND JAKT_STAGE0_ALL_SOURCES\n      ${JAKT_STAGE0_SOURCES}\n      ${JAKT_STAGE0_RUNTIME_SOURCES}\n      ${JAKT_STAGE0_RUNTIME_LIB_SOURCES}\n  )\n\n  # Note: This currently does not build under windows, but it is not needed by the runtime.\n  list(FILTER JAKT_STAGE0_ALL_SOURCES EXCLUDE REGEX \".*AK/Time\\.cpp$\")\n  list(FILTER JAKT_STAGE0_ALL_SOURCES EXCLUDE REGEX \".*AK/DOSPackedTime\\.cpp$\")\n\n  add_executable(jakt_stage0 \"${JAKT_STAGE0_ALL_SOURCES}\")\n  add_executable(Jakt::jakt_stage0 ALIAS jakt_stage0)\n  add_jakt_compiler_flags(jakt_stage0)\n  message(STATUS \"If this is windows, '${LIBCLANG_RT_PATH_${JAKT_TARGET_TRIPLE}}' should be nonempty\")\n  target_link_libraries(jakt_stage0 PRIVATE Threads::Threads ${LIBCLANG_RT_PATH_${JAKT_TARGET_TRIPLE}})\n  target_include_directories(jakt_stage0\n    PRIVATE\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/bootstrap/stage0/runtime>\n    INTERFACE\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/bootstrap/stage0/runtime>\n    PUBLIC\n      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/runtime>\n  )\n  apply_output_rules(jakt_stage0)\n  if (WIN32)\n      target_link_options(jakt_stage0 PRIVATE LINKER:/STACK:0x800000)\n  endif()\n  set(BOOSTRAP_COMPILER jakt_stage0)\nendif()\n\nmessage(STATUS \"Building for target ${JAKT_TARGET_TRIPLE}\")\n\n# As the bootstrap compiler can't make directories, create the \"exports\" dir here, if it doesn't exist\nfile(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/exports\")\n\nset(SELFHOST_SOURCES\n  selfhost/build.jakt\n  selfhost/codegen.jakt\n  selfhost/compiler.jakt\n  selfhost/error.jakt\n  selfhost/formatter.jakt\n  selfhost/git.jakt\n  selfhost/ide.jakt\n  selfhost/ids.jakt\n  selfhost/interpreter.jakt\n  selfhost/lexer.jakt\n  selfhost/parser.jakt\n  selfhost/project.jakt\n  selfhost/repl.jakt\n  selfhost/repl_backend/common.jakt\n  selfhost/repl_backend/default.jakt\n  selfhost/typechecker.jakt\n  selfhost/types.jakt\n  selfhost/utility.jakt\n  selfhost/platform.jakt\n  selfhost/cpp_import/common.jakt\n  ${JAKT_CPP_AUTO_IMPORT_EXTRA_SOURCES}\n)\n\n# FIXME: STDLIB target needed\nset(SELFHOST_STDLIB_SOURCES\n  jakt__libc__io.cpp\n  jakt__arguments.cpp\n  jakt__file_iterator.cpp\n  jakt__platform.cpp\n  jakt__platform__utility.cpp\n  jakt__path.cpp\n)\n\nif(CMAKE_HOST_WIN32)\n  list(APPEND SELFHOST_STDLIB_SOURCES\n    jakt__platform__windows_fs.cpp\n    jakt__platform__windows_errno.cpp\n    jakt__platform__windows_process.cpp\n  )\n  list(APPEND SELFHOST_STDLIB_SOURCES platform__windows_compiler.cpp)\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  list(APPEND SELFHOST_STDLIB_SOURCES\n    jakt__platform__posix_fs.cpp\n    jakt__platform__darwin_errno.cpp\n    jakt__platform__posix_process.cpp\n  )\n  list(APPEND SELFHOST_STDLIB_SOURCES platform__posix_compiler.cpp)\nelseif(CMAKE_HOST_UNIX)\n  list(APPEND SELFHOST_STDLIB_SOURCES\n    jakt__platform__posix_fs.cpp\n    jakt__platform__posix_errno.cpp\n    jakt__platform__posix_process.cpp\n  )\n  list(APPEND SELFHOST_STDLIB_SOURCES platform__posix_compiler.cpp)\nelse()\n  list(APPEND SELFHOST_STDLIB_SOURCES\n    jakt__platform__unknown_fs.cpp\n    jakt__platform__unknown_process.cpp\n  )\n  list(APPEND SELFHOST_STDLIB_SOURCES platform__unknown_compiler.cpp)\nendif()\n\nset(SELFHOST_CONFIGS\n  \"jakt.cpp_import.processor=${JAKT_CPP_AUTO_IMPORT_PROCESSOR}\"\n)\n\nif(NOT JAKT_CLANG_RESOURCE_DIR STREQUAL \"\")\n  list(APPEND SELFHOST_CONFIGS \"jakt.cpp_import.processor.clang.resource_dir=${JAKT_CLANG_RESOURCE_DIR}\")\nendif()\n\n\nadd_jakt_executable(jakt_stage1\n  COMPILER \"${BOOSTRAP_COMPILER}\"\n  MAIN_SOURCE selfhost/main.jakt\n  MODULE_SOURCES ${SELFHOST_SOURCES}\n  STDLIB_SOURCES ${SELFHOST_STDLIB_SOURCES}\n  RUNTIME_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/runtime\"\n  CONFIGS ${SELFHOST_CONFIGS}\n)\n\nif (JAKT_USING_CLANG)\n  target_link_libraries(jakt_stage1 PRIVATE libclang)\n  target_include_directories(jakt_stage1\n    PRIVATE\n      ${CLANG_INCLUDE_DIRS}\n      ${LLVM_INCLUDE_DIRS} # CLANG_INCLUDE_DIRS is more often than not incorrect on distros that ship clang as clangN, but LLVM_INCLUDE_DIRS seems to be correct everywhere.\n  )\nendif()\n\ntarget_include_directories(jakt_stage1\n  INTERFACE\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/runtime>\n  PUBLIC\n    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/runtime>\n)\nadd_executable(Jakt::jakt_stage1 ALIAS jakt_stage1)\napply_output_rules(jakt_stage1)\nif (MSVC)\n    target_link_options(jakt_stage1 PRIVATE LINKER:/STACK:0x800000)\nendif()\n\nif (FINAL_STAGE GREATER_EQUAL 2)\n  add_jakt_executable(jakt_stage2\n    COMPILER jakt_stage1\n    MAIN_SOURCE selfhost/main.jakt\n    MODULE_SOURCES ${SELFHOST_SOURCES}\n    STDLIB_SOURCES ${SELFHOST_STDLIB_SOURCES}\n    RUNTIME_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/runtime\"\n    CONFIGS ${SELFHOST_CONFIGS}\n  )\n  target_include_directories(jakt_stage2\n    INTERFACE\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/runtime>\n    PUBLIC\n      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/runtime>\n  )\n  if (JAKT_USING_CLANG)\n    target_link_libraries(jakt_stage2 PRIVATE libclang)\n    target_include_directories(jakt_stage2\n      PRIVATE\n        ${CLANG_INCLUDE_DIRS}\n        ${LLVM_INCLUDE_DIRS} # CLANG_INCLUDE_DIRS is more often than not incorrect on distros that ship clang as clangN, but LLVM_INCLUDE_DIRS seems to be correct everywhere.\n    )\n  endif()\n  add_executable(Jakt::jakt_stage2 ALIAS jakt_stage2)\n  apply_output_rules(jakt_stage2)\n  if (MSVC)\n    target_link_options(jakt_stage2 PRIVATE LINKER:/STACK:0x800000)\n  endif()\nendif()\n\n# Link runtime into build directory(ies) for relative pathing usage\n#    Note: \"If a sequential execution of multiple commands is required, use multiple execute_process() calls with a single COMMAND argument.\"\nif (CMAKE_CONFIGURATION_TYPES)\n  foreach (build_type IN LISTS CMAKE_CONFIGURATION_TYPES)\n    execute_process(COMMAND \"${CMAKE_COMMAND}\" -E make_directory \"${CMAKE_CURRENT_BINARY_DIR}/${build_type}/include\")\n    create_symlink(\"${CMAKE_CURRENT_SOURCE_DIR}/runtime\" \"${CMAKE_CURRENT_BINARY_DIR}/${build_type}/include/runtime\" DIRECTORY)\n  endforeach()\nelse()\n  execute_process(COMMAND \"${CMAKE_COMMAND}\" -E make_directory \"${CMAKE_CURRENT_BINARY_DIR}/include\")\n  create_symlink(\"${CMAKE_CURRENT_SOURCE_DIR}/runtime\" \"${CMAKE_CURRENT_BINARY_DIR}/include/runtime\" DIRECTORY)\nendif()\n\nadd_symlink_command(\n  \"$<SHELL_PATH:$<TARGET_FILE:jakt_stage${FINAL_STAGE}>>\"\n  \"$<SHELL_PATH:$<PATH:REPLACE_FILENAME,$<TARGET_FILE:jakt_stage${FINAL_STAGE}>,jakt${CMAKE_EXECUTABLE_SUFFIX}>>\"\n  TARGET \"jakt_stage${FINAL_STAGE}\"\n  POST_BUILD\n  VERBATIM\n)\nadd_executable(Jakt::jakt ALIAS jakt_stage${FINAL_STAGE})\n\nif (NOT CMAKE_SKIP_INSTALL_RULES)\n  include(cmake/install-rules.cmake)\n  jakt_install_runtime(${JAKT_TARGET_TRIPLE})\nendif()\n\n# FIXME: Remove if we decide to use CTest\noption(JAKT_BUILD_TESTING \"Whether to build tests or not, default on\" ON)\n\nif (JAKT_BUILD_TESTING AND NOT CMAKE_CROSSCOMPILING)\n  add_jakt_executable(jakttest\n    MAIN_SOURCE\n      jakttest/jakttest.jakt\n    MODULE_SOURCES\n      jakttest/error.jakt\n      jakttest/parser.jakt\n      jakttest/utility.jakt\n    INCLUDES\n      \"${CMAKE_CURRENT_SOURCE_DIR}/jakttest\"\n    RUNTIME_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/runtime\"\n  )\n  add_jakt_compiler_flags(jakttest)\n  target_sources(jakttest PRIVATE\n     jakttest/fs.cpp\n     jakttest/os.cpp\n     jakttest/process.cpp\n  )\n  apply_output_rules(jakttest)\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 2.1591796875,
          "content": "The purpose of this repo is to facilitate productive development of the Jakt programming language, a part of the SerenityOS project. Any behavior that runs counter to that goal will not be tolerated.\n\n## Some basic rules:\n\n1. Do the best you can, both in code and in communication. Expect others to do the same.\n2. Politics, religion and sex are not appropriate topics here. Discuss them elsewhere.\n3. Any discussion unrelated to the Jakt/SerenityOS project belongs elsewhere.\n4. Try your best to keep a positive attitude, and try to not drag others down if/when you're having a bad day.\n5. Don't complain about things you are not actively engaged in improving. This includes low-effort whining like \"$THING is trash\". Don't shit on other projects, companies, or communities. \n6. If you need help building Jakt, use the discord #jakt channel.\n8. Talk is cheap. Don't waste other people's time by talking about your great ideas if you don't also spend time implementing your ideas. We have no need for \"idea guys\"\n9. Don't ask other people to look things up for you. If a question can be answered by consulting the code, the git history, the issue tracker, or a search engine, look it up yourself.\n10. Avoid when-posting. \"When will Jakt get this feature?\", \"When will you do X?\", etc. If you want to see something happen, you make it happen.\n11. Refrain from excitement-posting on issues/pull requests. We are all excited about Jakt, but please don't add unnecessary noise. Users who repeatedly misuse this will be restricted.\n12. If a bug is discussed, please make sure there's a separate GitHub issue for it.\n13. No soliciting of any kind.\n14. Be judicious when using the @user (\"ping\") feature. The purpose of pinging somebody is to request their attention. Please don't use @user when simply referring to a user in conversation.\n15. Don't send general technical questions as direct messages to strangers and don't send friend requests to people you don't have a prior relationship with. If you have questions, asking in public makes it far more likely that someone can answer it. Furthermore, if multiple people have the same question, it's more efficient to answer it once where everyone can learn from it."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.8828125,
          "content": "# Contributing to Jakt\n\nWhen contributing to Jakt, make sure that the changes you wish to make are in line with the project direction. If you are not sure about this, open an issue first, so we can discuss it.\n\nEveryone is welcome to work on the project, and while we have lots of fun, it's a serious kind of fun. :^)\n\n## Communication\n\nJoin the SerenityOS Discord server: [SerenityOS Discord](https://discord.gg/serenityos). The \"Jakt\" category of channels is specifically about Jakt and its development.\n\n## Issue policy\n\nUnlike many other software projects, Jakt is not concerned with gaining the largest possible userbase. Its target audience is its own developers. As such, we have limited interest in feature requests from non-contributors.\n\nThat said, please do file any bugs you find, keeping the following in mind:\n\n* One issue per bug. Putting multiple things in the same issue makes both discussion and completion unnecessarily complicated.\n* No build issues (or other support requests). If the GitHub Actions CI build succeeds, the build problem is most likely on your side. Work it out locally, or ask on Discord.\n* Don't comment on issues just to add a joke or irrelevant commentary. Hundreds of people get notified about comments so let's keep them relevant.\n\n## Human language policy\n\nIn SerenityOS, we treat human language as seriously as we do programming language.\n\nThe following applies to all user-facing strings, code, comments, and commit messages:\n\n* The official project language is American English with ISO 8601 dates and metric units.\n* Use proper spelling, grammar, and punctuation.\n* Write in an authoritative and technical tone.\n\nEveryone is encouraged to make use of tooling (spell checkers, etc) to make this easier.\n\n## Code submission policy\n\nNobody is perfect, and sometimes we mess things up. That said, here are some good dos & dont's to try and stick to:\n\n**Do:**\n\n* Conform to the project coding style found in [coding-style.md](https://github.com/SerenityOS/jakt/blob/main/documentation/coding-style.md). Use automatic formatters (`rustfmt`, `clang-format`, etc.) to format code according to project style.\n* Choose expressive variable, function and class names. Make it as obvious as possible what the code is doing.\n* Split your changes into separate, atomic commits (i.e. A commit per feature or fix, where the build, tests and the system are all functioning).\n* Make sure your commits are rebased on the master branch.\n* Wrap your commit messages at 72 characters.\n* The first line of the commit message is the subject line, and must have the format \"Category: Brief description of what's being changed\".\n* Write the commit message subject line in the imperative mood (\"Foo: Change the way dates work\", not \"Foo: Changed the way dates work\").\n* Write your commit messages in proper English, with care and punctuation.\n* Squash your commits when making revisions after a patch review.\n* Add your personal copyright line to files when making substantive changes. (Optional but encouraged!)\n* Check the spelling of your code, comments and commit messages.\n* If you have images that go along with your code, run `optipng -strip all` on them to optimize and strip away useless metadata - this can reduce file size from multiple kilobytes to a couple hundred bytes.\n* If you have sample Jakt files (or outputs) that go along with your changes, please use underscores rather than dashes in the filename (e.g. `my_code_sample.jakt`, not `my-code-sample.jakt`).\n\n**Don't:**\n\n* Submit code that's incompatible with the project licence (2-clause BSD.)\n* Touch anything outside the stated scope of the PR.\n* Iterate excessively on your design across multiple commits.\n* Use weasel-words like \"refactor\" or \"fix\" to avoid explaining what's being changed.\n* End commit message subject lines with a period.\n* Include commented-out code.\n* Attempt large architectural changes until you are familiar with the system and have worked on it for a while.\n* Engage in excessive \"feng shui programming\" by moving code around without quantifiable benefit.\n\n## Pull Request Q&A\n\n### I've submitted a PR and it passes CI. When can I expect to get some review feedback?\n\nWhile unadvertised PRs may get randomly merged by curious maintainers, you will have a much smoother time if you engage with the community on Discord.\n\n### If my PR isn't getting attention, how long should I wait before pinging one of the project maintainers?\n\nPing them right away if it's something urgent! If it's less urgent, advertise your PR on Discord and ask if someone could review it.\n\n### Who are the project maintainers?\n\nThe project maintainers at this time are [@awesomekling](https://github.com/awesomekling), [@jntrnr](https://github.com/jntrnr), [@alimpfard](https://github.com/alimpfard), [@trflynn89](https://github.com/trflynn89), [@AtkinsSJ](https://github.com/AtkinsSJ), and [@ADKaster](https://github.com/ADKaster).\n\nMaintainership is by invitation only and does not correlate with any particular metric.\n\n### Are there specific people to reach out to for different subsystems (e.g. parser, typechecker, runtime, etc)?\n\nIn theory, the best person to speak with is whoever wrote most code adjacent to what you're working on. In practice, asking in one of the development channels on Discord is usually easier/better, since that allows many people to join the discussion.\n\n### Is Discord the place to ask for review help, or is Github preferred?\n\nIt's definitely better to ask on Discord. Due to the volume of GitHub notifications, many of us turn them off and rely on Discord for learning about review requests.\n\n## Commit Hooks\n\nThe repository contains a file called `.pre-commit-config.yaml` that defines several 'commit hooks' that can be run automatically just before and after creating a new commit. These hooks lint your commit message, and the changes it contains to ensure they will pass the automated CI for pull requests.\nTo enable these hooks firstly follow the installation instructions available at https://pre-commit.com/#install and then enable one or both of the following hooks:\n - pre-commit hook - Runs Meta/lint-ci.sh and Meta/lint-ports.py to ensure changes to the code will pass linting:\n   ```console\n   pre-commit install\n   ```\n - post-commit hook - Lints the commit message to ensure it will pass the commit linting:\n   ```console\n   pre-commit install --hook-type commit-msg\n   ```\n\n## On abandoned pull requests\n\nSometimes good PRs get abandoned by the author for one reason or another. If the PR is fundamentally good, but the author is not responding to requests, the PR may be manually integrated with minor changes to code and commit messages.\n\nTo make this easier, we do appreciate it if folks enable the \"Allow edits from maintainers\" flag on their pull requests.\n\n## On ideologically motivated changes\n\nThis is a purely technical project. As such, it is not an appropriate arena to advertise your personal politics or religious beliefs. Any changes that appear ideologically motivated will be rejected.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.7548828125,
          "content": "# To build: docker build --no-cache -t jakt:latest -f Dockerfile .\n# To run: docker run -it jakt:latest\nFROM ubuntu:22.04\n\nENV DEBIAN_FRONTEND=noninteractive\n\nRUN apt-get update -y \\\n    && apt-get install -y \\\n        build-essential \\\n        cmake \\\n        git \\\n        ninja-build \\\n        clang-15 \\\n        libclang-15-dev \\\n    && rm -rf /var/lib/apt/lists/\n\nCOPY . /project/jakt/\nWORKDIR /project/jakt/\n\nRUN ln -s /usr/bin/clang++-15 /usr/bin/clang++; \\\n    ln -s /usr/bin/clang-15 /usr/bin/clang; \\\n    ln -s /usr/bin/clang-cpp-15 /usr/bin/clang-cpp\n\nRUN cmake -B build -GNinja -DCMAKE_CXX_COMPILER=clang++-15 -DCMAKE_INSTALL_PREFIX=jakt-install\nRUN ninja -C build install\n\nRUN ln -s /project/jakt/jakt-install/bin/jakt /usr/bin/jakt\n\nENTRYPOINT [\"/bin/bash\"]\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2958984375,
          "content": "BSD 2-Clause License\n\nCopyright (c) 2022, JT, Andreas Kling\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.212890625,
          "content": "# The Jakt programming language\n\n**Jakt** is a memory-safe systems programming language.\n\nIt currently transpiles to C++.\n\n**NOTE:** The language is under heavy development.\n\n**NOTE** If you're cloning to a Windows PC (not WSL), make sure that your Git client keeps the line endings as `\\n`. You can set this as a global config via `git config --global core.autocrlf false`.\n\n## Usage\nThe transpilation to C++ requires `clang`. Make sure you have that installed.\n```\njakt file.jakt\n./build/file\n```\n\n## Building\nSee [here](documentation/cmake-bootstrap.md).\n\n## Goals\n\n1. Memory safety\n2. Code readability\n3. Developer productivity\n4. Executable performance\n5. Fun!\n\n## Memory safety\n\nThe following strategies are employed to achieve memory safety:\n- Automatic reference counting\n- Strong typing\n- Bounds checking\n- No raw pointers in safe mode\n\nIn **Jakt**, there are three pointer types:\n\n- [x] **T** (Strong pointer to reference-counted class `T`.)\n- [x] **weak T** (Weak pointer to reference-counted class `T`. Becomes empty on pointee destruction.)\n- [x] **raw T** (Raw pointer to arbitrary type `T`. Only usable in `unsafe` blocks.)\n\nNull pointers are not possible in safe mode, but pointers can be wrapped in `Optional`, i.e `Optional<T>` or `T?` for short.\n\n## Math safety\n\n- [x] Integer overflow (both signed and unsigned) is a runtime error.\n- [x] Numeric values are not automatically coerced to `int`. All casts must be explicit.\n\nFor cases where silent integer overflow is desired, there are explicit functions that provide this functionality.\n\n## Code readability\n\nFar more time is spent reading code than writing it. For that reason, **Jakt** puts a high emphasis on readability.\n\nSome of the features that encourage more readable programs:\n\n- [x] Immutable by default.\n- [x] Argument labels in call expressions (`object.function(width: 10, height: 5)`)\n- [ ] Inferred `enum` scope. (You can say `Foo` instead of `MyEnum::Foo`).\n- [x] Pattern matching with `match`.\n- [x] Optional chaining (`foo?.bar?.baz` (fallible) and `foo!.bar!.baz` (infallible))\n- [x] None coalescing for optionals (`foo ?? bar` yields `foo` if `foo` has a value, otherwise `bar`)\n- [x] `defer` statements.\n- [x] Pointers are always dereferenced with `.` (never `->`)\n- [x] Trailing closure parameters can be passed outside the call parentheses.\n- [ ] Error propagation with `ErrorOr<T>` return type and dedicated `try` / `must` keywords.\n\n## Code reuse\n\nJakt is flexible in how a project can be structured with a built-in module system.\n\n```jakt\nimport a                                // (1)\nimport a { use_cool_things }            // (2)\nimport fn()                             // (3)\nimport relative foo::bar                // (4)\nimport relative parent::foo::baz        // (5)\nimport relative parent(3)::foo::baz     // (6)\n```\n\n1. Import a module from the same directory as the file.\n1. Import only `use_cool_things()` from module `a`.\n1. Imports can be calculated at compile time. See [Comptime Imports](#comptime-imports)\n1. Import a module using the relative keyword when the module is a sub path of the directory containing the file.\n1. Import a module in a parent path one directory up from the directory containing the file.\n1. Syntactic sugar for importing a module three parent paths up from the directory containing the file.\n\n### The Jakt Standard Library\n\nJakt has a Standard Library that is accessed using the `jakt::` namespace:\n\n```jakt\nimport jakt::arguments\nimport jakt::libc::io { system }\n```\n\nThe Jakt Standard Library is in its infancy, so please consider making a contribution!\n\n## Function calls\n\nWhen calling a function, you must specify the name of each argument as you're passing it:\n\n```jakt\nrect.set_size(width: 640, height: 480)\n```\n\nThere are two exceptions to this:\n\n- [x] If the parameter in the function declaration is declared as `anon`, omitting the argument label is allowed.\n- [x] When passing a variable with the same name as the parameter.\n\n## Structures and classes\n\nThere are two main ways to declare a structure in **Jakt**: `struct` and `class`.\n\n### `struct`\n\nBasic syntax:\n\n```jakt\nstruct Point {\n    x: i64\n    y: i64\n}\n```\n\nStructs in **Jakt** have *value semantics*:\n- Variables that contain a struct always have a unique instance of the struct.\n- Copying a `struct` instance always makes a deep copy.\n\n```jakt\nlet a = Point(x: 10, y: 5)\nlet b = a\n// \"b\" is a deep copy of \"a\", they do not refer to the same Point\n```\n\n**Jakt** generates a default constructor for structs. It takes all fields by name. For the `Point` struct above, it looks like this:\n\n```jakt\nPoint(x: i64, y: i64)\n```\n\nStruct members are *public* by default.\n\n### `class`\n\n- [x] basic class support\n- [x] private-by-default members\n- [x] inheritance\n- [ ] class-based polymorphism (assign child instance to things requiring the parent type)\n- [ ] `Super` type\n- [ ] `Self` type\n\nSame basic syntax as `struct`:\n```\nclass Size {\n    width: i64\n    height: i64\n\n    public fn area(this) => .width * .height\n}\n```\n\nClasses in **Jakt** have *reference semantics*:\n- Copying a `class` instance (aka an \"object\") copies a reference to the object.\n- All objects are reference-counted by default. This ensures that objects don't get accessed after being deleted.\n\nClass members are *private* by default.\n\n### Member functions\n\nBoth structs and classes can have member functions.\n\nThere are three kinds of member functions:\n\n**Static member functions** don't require an object to call. They have no `this` parameter.\n\n```jakt\nclass Foo {\n    fn func() => println(\"Hello!\")\n}\n\n// Foo::func() can be called without an object.\nFoo::func()\n```\n\n**Non-mutating member functions** require an object to be called, but cannot mutate the object. The first parameter is `this`.\n\n```jakt\nclass Foo {\n    fn func(this) => println(\"Hello!\")\n}\n\n// Foo::func() can only be called on an instance of Foo.\nlet x = Foo()\nx.func()\n```\n\n**Mutating member functions** require an object to be called, and may modify the object. The first parameter is `mut this`.\n```jakt\nclass Foo {\n    x: i64\n\n    fn set(mut this, anon x: i64) {\n        this.x = x\n    }\n}\n\n// Foo::set() can only be called on a mut Foo:\nmut foo = Foo(x: 3)\nfoo.set(9)\n```\n\n### Shorthand for accessing member variables\n\nTo reduce repetitive `this.` spam in methods, the shorthand `.foo` expands to `this.foo`.\n\n## Strings\n\nStrings are provided in the language mainly as the type `String`, which is a reference-counted (and heap-allocated) string type.\nString literals are written with double quotes, like `\"Hello, world!\"`.\n\n### Overloaded string literals\n\nString literals are of type `String` by default; however, they can be used to implicitly construct any type that implements the `FromStringLiteral` (or `ThrowingFromStringLiteral`) trait. In the language prelude, currently only `StringView` implements this trait, which can be used only to refer to strings with a static lifetime:\n```jakt\nlet foo: StringView = \"foo\" // This string is not allocated on the heap, and foo is only a fat pointer to the static string.\n```\n\nOverloaded string literals can be used by providing a type hint, whether by explicit type annotations, or by passing the literal to a function that expects a specific type:\n```jakt\nstruct NotString implements(FromStringLiteral) {\n    fn from_string_literal(anon string: StringView) -> NotString => NotString()\n}\n\nfn test(x: NotString) {}\n\nfn main() {\n    let foo: NotString = \"foo\"\n    test(x: \"Some string literal\")\n}\n```\n\n## Arrays\n\nDynamic arrays are provided via a built-in `Array<T>` type. They can grow and shrink at runtime.\n\n`Array` is memory safe:\n- Out-of-bounds will panic the program with a runtime error.\n- Slices of an `Array` keep the underlying data alive via automatic reference counting.\n\n### Declaring arrays\n\n```jakt\n// Function that takes an Array<i64> and returns an Array<String>\nfn foo(numbers: [i64]) -> [String] {\n    ...\n}\n```\n\n### Shorthand for creating arrays\n\n```jakt\n// Array<i64> with 256 elements, all initialized to 0.\nlet values = [0; 256]\n\n// Array<String> with 3 elements: \"foo\", \"bar\" and \"baz\".\nlet values = [\"foo\", \"bar\", \"baz\"]\n```\n\n## Dictionaries\n\n- [x] Creating dictionaries\n- [x] Indexing dictionaries\n- [x] Assigning into indexes (aka lvalue)\n\n```jakt\nfn main() {\n    let dict = [\"a\": 1, \"b\": 2]\n\n    println(\"{}\", dict[\"a\"])\n}\n```\n\n### Declaring dictionaries\n\n```jakt\n// Function that takes a Dictionary<i64, String> and returns an Dictionary<String, bool>\nfn foo(numbers: [i64:String]) -> [String:bool] {\n    ...\n}\n```\n\n### Shorthand for creating dictionaries\n\n```jakt\n// Dictionary<String, i64> with 3 entries.\nlet values = [\"foo\": 500, \"bar\": 600, \"baz\": 700]\n```\n\n## Sets\n\n- [x] Creating sets\n- [x] Reference semantics\n\n```jakt\nfn main() {\n    let set = {1, 2, 3}\n\n    println(\"{}\", set.contains(1))\n    println(\"{}\", set.contains(5))\n}\n```\n\n## Tuples\n\n- [x] Creating tuples\n- [x] Index tuples\n- [x] Tuple types\n\n```\nfn main() {\n    let x = (\"a\", 2, true)\n\n    println(\"{}\", x.1)\n}\n```\n\n## Enums and Pattern Matching\n\n- [x] Enums as sum-types\n- [x] Generic enums\n- [x] Enums as names for values of an underlying type\n- [x] `match` expressions\n- [x] Enum scope inference in `match` arms\n- [x] Yielding values from match blocks\n- [ ] Nested `match` patterns\n- [ ] Traits as `match` patterns\n- [ ] Support for interop with the `?`, `??` and `!` operators\n\n```jakt\nenum MyOptional<T> {\n    Some(T)\n    None\n}\n\nfn value_or_default<T>(anon x: MyOptional<T>, default: T) -> T {\n    return match x {\n        Some(value) => {\n            let stuff = maybe_do_stuff_with(value)\n            let more_stuff = stuff.do_some_more_processing()\n            yield more_stuff\n        }\n        None => default\n    }\n}\n\nenum Foo {\n    StructLikeThingy (\n        field_a: i32\n        field_b: i32\n    )\n}\n\nfn look_at_foo(anon x: Foo) -> i32 {\n    match x {\n        StructLikeThingy(field_a: a, field_b) => {\n            return a + field_b\n        }\n    }\n}\n\nenum AlertDescription: i8 {\n    CloseNotify = 0\n    UnexpectedMessage = 10\n    BadRecordMAC = 20\n    // etc\n}\n\n// Use in match:\nfn do_nothing_in_particular() => match AlertDescription::CloseNotify {\n    CloseNotify => { ... }\n    UnexpectedMessage => { ... }\n    BadRecordMAC => { ... }\n}\n```\n\n## Generics\n\n- [x] Generic types\n- [x] Constant generics (minimal support)\n- [ ] Constant generics (full support)\n- [x] Generic type inference\n- [x] Traits\n\n**Jakt** supports both generic structures and generic functions.\n\n```jakt\nfn id<T>(anon x: T) -> T {\n    return x\n}\n\nfn main() {\n    let y = id(3)\n\n    println(\"{}\", y + 1000)\n}\n```\n\n```jakt\nstruct Foo<T> {\n    x: T\n}\n\nfn main() {\n    let f = Foo(x: 100)\n\n    println(\"{}\", f.x)\n}\n```\n\n```jakt\nstruct MyArray<T, comptime U> {\n    // NOTE: There is currently no way to access the value 'U', referring to 'U' is only valid as the type at the moment.\n    data: [T]\n}\n```\n\n## Namespaces\n\n- [x] Namespace support for functions and struct/class/enum\n- [ ] Deep namespace support\n\n```\nnamespace Greeters {\n    fn greet() {\n        println(\"Well, hello friends\")\n    }\n}\n\nfn main() {\n    Greeters::greet()\n}\n```\n\n## Type casts\n\nThere are two built-in casting operators in **Jakt**.\n\n- `as? T`: Returns an `Optional<T>`, empty if the source value isn't convertible to `T`.\n- `as! T`: Returns a `T`, aborts the program if the source value isn't convertible to `T`.\n\nThe `as` cast can do these things (note that the implementation may not agree yet):\n- Casts to the same type are infallible and pointless, so might be forbidden in the future.\n- If the source type is _unknown_, the cast is valid as a type assertion.\n- If both types are primitive, a safe conversion is done.\n    - Integer casts will fail if the value is out of range. This means that promotion casts like i32 -> i64 are infallible.\n    - Float -> Integer casts truncate the decimal point (?)\n    - Integer -> Float casts resolve to the closest value to the integer representable by the floating-point type (?). If the integer value is too large, they resolve to infinity (?)\n    - Any primitive -> bool will create `true` for any value except 0, which is `false`.\n    - bool -> any primitive will do `false -> 0` and `true -> 1`, even for floats.\n- If the types are two different pointer types (see above), the cast is essentially a no-op. A cast to `T` will increment the reference count as expected; that's the preferred way of creating a strong reference from a weak reference. A cast from and to `raw T` is unsafe.\n- If the types are part of the same type hierarchy (i.e. one is a child type of another):\n    - A child can be cast to its parent infallibly.\n    - A parent can be cast to a child, but this will check the type at runtime and fail if the object was not of the child type or one of its subtypes.\n- If the types are incompatible, a user-defined cast is attempted to be used. The details here are not decided yet.\n- If nothing works, the cast will not even compile.\n\nAdditional casts are available in the standard library. Two important ones are `as_saturated` and `as_truncated`, which cast integral values while saturating to the boundaries or truncating bits, respectively.\n\n## Traits\n\nTo make generics a bit more powerful and expressive, you can add additional information to them:\n\n```jakt\ntrait Hashable<Output> {\n    fn hash(self) -> Output\n}\n\nclass Foo implements(Hashable<i64>) {\n    fn hash(self) => 42\n}\n```\n\nTraits can be used to add constraints to generic types, but also provide default implementations based on a minimal set of requirements - for instance:\n\n```jakt\ntrait Fancy {\n    fn do_something(this) -> void\n    fn do_something_twice(this) -> void {\n        .do_something()\n        .do_something()\n    }\n}\n\nstruct Boring implements(Fancy) {\n    fn do_something(this) -> void {\n        println(\"I'm so boring\")\n    }\n\n    // Note that we don't have to implement `do_something_twice` here, because it has a default implementation.\n}\n\nstruct Better implements(Fancy) {\n    fn do_something(this) -> void {\n        println(\"I'm not boring\")\n    }\n\n    // However, a custom implementation is still valid.\n    fn do_something_twice(this) -> void {\n        println(\"I'm not boring, but I'm doing it twice\")\n    }\n}\n```\n\nTraits can have methods that reference other traits as types, which can be used to describe a hierarchy of traits:\n\n```jakt\ntrait ConstIterable<T> {\n    fn next(this) -> T?\n}\n\ntrait IntoIterator<T> {\n    // Note how the return type is a reference to the ConstIterable trait (and not a concrete type)\n    fn iterator(this) -> ConstIterable<T>\n}\n```\n\n### Operator Overloading and Traits\n\nOperators are implemented as traits, and can be overloaded by implementing them on a given type:\n\n```jakt\nstruct Foo implements(Add<Foo, Foo>) {\n    x: i32\n\n    fn add(this, anon rhs: Foo) -> Foo {\n        return Foo(x: .x + other.x)\n    }\n}\n```\n\nThe relationship between operators and traits is as follows (Note that `@` is used as a placeholder for any binary operator's name or sigil):\n\n| Operator | Trait | Method Name | Derived From Method |\n|----------|-------|-------------|---------------------|\n| `+` | `Add` | `add` | - |\n| `-` | `Subtract` | `subtract` | - |\n| `*` | `Multiply` | `multiply` | - |\n| `/` | `Divide` | `divide` | - |\n| `%` | `Modulo` | `modulo` | - |\n| `<` | `Compare` | `less_than` | `compare` |\n| `>` | `Compare` | `greater_than` | `compare` |\n| `<=` | `Compare` | `less_than_or_equal` | `compare` |\n| `>=` | `Compare` | `greater_than_or_equal` | `compare` |\n| `==` | `Equal` | `equals` | - |\n| `!=` | `Equal` | `not_equals` | `equals` |\n| `@=` | `@Assignment` | `@_assign` | - |\n\nOther operators have not yet been converted to traits, decided on, or implemented:\n\n| Operator | Description | Status |\n|----------|-------------|--------|\n| `&` | Bitwise And | Not Decided |\n| `\\|` | Bitwise Or | Not Decided |\n| `^` | Bitwise Xor | Not Decided |\n| `~` | Bitwise Not | Not Decided |\n| `<<` | Bitwise Shift Left | Not Decided |\n| `>>` | Bitwise Shift Right | Not Decided |\n| `and` | Logical And | Not Decided |\n| `or` | Logical Or | Not Decided |\n| `not` | Logical Not | Not Decided |\n| `=` | Assignment | Not Decided |\n\n## Safety analysis\n\n**(Not yet implemented)**\n\nTo keep things safe, there are a few kinds of analysis we'd like to do (non-exhaustive):\n\n* Preventing overlapping of method calls that would collide with each other. For example, creating an iterator over a container, and while that's live, resizing the container\n* Using and manipulating raw pointers\n* Calling out to C code that may have side effects\n\n## Error handling\n\nFunctions that can fail with an error instead of returning normally are marked with the `throws` keyword:\n\n```jakt\nfn task_that_might_fail() throws -> usize {\n    if problem {\n        throw Error::from_errno(EPROBLEM)\n    }\n    ...\n    return result\n}\n\nfn task_that_cannot_fail() -> usize {\n    ...\n    return result\n}\n```\n\nUnlike languages like C++ and Java, errors don't unwind the call stack automatically. Instead, they bubble up to the nearest caller.\n\nIf nothing else is specified, calling a function that `throws` from within a function that `throws` will implicitly bubble errors.\n\n### Syntax for catching errors\n\nIf you want to catch errors locally instead of letting them bubble up to the caller, use a `try`/`catch` construct like this:\n\n```jakt\ntry {\n    task_that_might_fail()\n} catch error {\n    println(\"Caught error: {}\", error)\n}\n```\n\nThere's also a shorter form:\n\n```jakt\ntry task_that_might_fail() catch error {\n    println(\"Caught error: {}\", error)\n}\n```\n\n### Rethrowing errors\n\n**(Not yet implemented)**\n\n## Inline C++\n\nFor better interoperability with existing C++ code, as well as situations where the capabilities of **Jakt** within `unsafe` blocks are not powerful enough, the possibility of embedding inline C++ code into the program exists in the form of `cpp` blocks:\n\n```jakt\nmut x = 0\nunsafe {\n    cpp {\n        \"x = (i64)&x;\"\n    }\n}\nprintln(\"{}\", x)\n```\n\n## References\n\nValues and objects can be passed by reference in some situations where it's provably safe to do so.\n\nA reference is either immutable (default) or mutable.\n\n### Reference type syntax\n\n- `&T` is an immutable reference to a value of type `T`.\n- `&mut T` is a mutable reference to a value of type `T`.\n\n### Reference expression syntax\n\n- `&foo` creates an immutable reference to the variable `foo`.\n- `&mut foo` creates a mutable reference to the variable `foo`.\n\n### Dereferencing a reference\n\nTo \"get the value out\" of a reference, it must be dereferenced using the `*` operator, however the compiler will automatically dereference references if the dereferencing is the single unambiguous correct use of the reference (in practice, manual dereferencing is only required where the reference is being stored or passed to functions).\n\n```jakt\nfn sum(a: &i64, b: &i64) -> i64 {\n    return a + b\n    // Or with manual dereferencing:\n    return *a + *b\n}\n\nfn test() {\n    let a = 1\n    let b = 2\n    let c = sum(&a, &b)\n}\n```\n\nFor mutable references to structs, you'll need to wrap the dereference in parentheses in order to do a field access:\n\n```jakt\nstruct Foo {\n    x: i64\n}\nfn zero_out(foo: &mut Foo) {\n    foo.x = 0\n    // Or with manual dereferencing:\n    (*foo).x = 0\n}\n```\n\n### References (first version) feature list:\n\n- [x] Reference types\n- [x] Reference function parameters\n- [x] Local reference variables with basic lifetime analysis\n- [x] No references in structs\n- [x] No references in return types\n- [x] No mutable references to immutable values\n- [x] Allow `&foo` and `&mut foo` without argument label for parameters named `foo`\n- [x] Auto-dereference references where applicable\n\n### References TODO:\n\n- [ ] (`unsafe`) references and raw pointers bidirectionally convertible\n- [ ] No capture-by-reference in persistent closures\n\n### Closures (first version) feature list:\n\n- [x] Function as parameter to function\n- [x] Functions as variables\n- [x] No returning functions from functions\n- [x] Lambdas can throw\n- [x] Explicit captures\n\n### Closures TODO:\n\n- [ ] Return function from function\n\n## Compiletime Execution\n\nCompiletime Function Execution (or CTFE) in Jakt allows the execution of any jakt function at compiletime, provided that the result value\nmay be synthesized using its fields - currently this only disallows a few prelude objects that cannot be constructed by their fields (like Iterator objects and StringBuilders).\n\nAny regular Jakt function can be turned into a compiletime function by replacing the `function` keyword in its declaration with the `comptime` keyword, which will force all calls to that specific function to be evaluated at compile time.\n\n### Invocation Restrictions\n\nComptime functions may only be invoked by constant expressions; this restriction includes the `this` object of methods.\n\n### Throwing in a comptime context\n\nThrowing behaves the same way as normal error control flow does, if the error leaves the comptime context (by reaching the original callsite), it will be promoted to a compilation error.\n\n### Side effects\n\nCurrently all prelude functions with side effects behave the same as they would in runtime. This allows e.g. pulling in files into the binary; some functions may be changed later to perform more useful actions.\n\n## Comptime imports\n\nIt is possible to design custom import handling based on data available at compile time. An excellent example of this in the Jakt compiler is the [Platform Module](https://github.com/SerenityOS/jakt/blob/main/selfhost/os.jakt#L41).\n\nSee a smaller example in the [comptime imports sample](https://github.com/SerenityOS/jakt/blob/main/samples/modules/comptime_imports.jakt).\n\n### Comptime TODO\n\n- [ ] Implement execution of all Jakt expressions\n"
        },
        {
          "name": "bootstrap",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "editors",
          "type": "tree",
          "content": null
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 1.4443359375,
          "content": "{\n  \"nodes\": {\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1708984720,\n        \"narHash\": \"sha256-gJctErLbXx4QZBBbGp78PxtOOzsDaQ+yw1ylNQBuSUY=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"13aff9b34cc32e59d35c62ac9356e4a41198a538\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs\",\n        \"utils\": \"utils\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"utils\": {\n      \"inputs\": {\n        \"systems\": \"systems\"\n      },\n      \"locked\": {\n        \"lastModified\": 1710146030,\n        \"narHash\": \"sha256-SZ5L6eA7HJ/nmkzGG7/ISclqe6oZdOZTNoesiInkXPQ=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"b1d9ab70662946ef0850d488da1c9019f3a9752a\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 1.080078125,
          "content": "{\n  description = \"The Jakt Programming Language\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    utils.url = \"github:numtide/flake-utils\";\n  };\n\n  outputs = { self, nixpkgs, utils }: utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs { inherit system; };\n\n    jakt = pkgs.callPackage ({ callPackage, symlinkJoin, makeWrapper, clang_16 }: let\n      jakt-unwrapped = callPackage ./jakt.nix {};\n    in symlinkJoin {\n      name = \"jakt\";\n\n      paths = [ jakt-unwrapped ];\n      nativeBuildInputs = [ makeWrapper ];\n\n      postBuild = ''\n        wrapProgram $out/bin/jakt_stage0 \\\n          --prefix PATH : ${clang_16}/bin\n\n        wrapProgram $out/bin/jakt_stage1 \\\n          --prefix PATH : ${clang_16}/bin\n      '';\n\n      passthru.unwrapped = jakt-unwrapped;\n    }) {};\n  in {\n    packages.jakt-unwrapped = jakt.unwrapped;\n    packages.jakt = jakt;\n    packages.default = jakt;\n\n    devShells.default = pkgs.mkShell {\n      packages = let\n        inherit (jakt.unwrapped) buildInputs nativeBuildInputs;\n      in buildInputs ++ nativeBuildInputs;\n    };\n  });\n}\n"
        },
        {
          "name": "jakt.nix",
          "type": "blob",
          "size": 0.6328125,
          "content": "{\n  stdenv,\n  fetchFromGitHub,\n\n  clang_16,\n  cmake,\n  ninja,\n  pkg-config,\n  python3,\n}:\n\nlet\n  serenity = fetchFromGitHub {\n    owner = \"serenityos\";\n    repo = \"serenity\";\n    rev = \"05e78dabdbceea46bae7dca52b63dc0a115e7b52\"; # latest at the time\n    hash = \"sha256-ymXQ68Uib1xP4eGPuxm3vRgAIhrVK4rmHdGLfuvsOJU=\";\n  };\nin stdenv.mkDerivation {\n  name = \"jakt-unwrapped\";\n  src = ./.;\n\n  nativeBuildInputs = [\n    pkg-config\n    cmake\n    ninja\n ];\n\n  buildInputs = [\n    clang_16\n    python3\n  ];\n\n  cmakeFlags = [\n    \"-DCMAKE_CXX_COMPILER=${clang_16}/bin/clang++\"\n    \"-DSERENITY_SOURCE_DIR=${serenity}\"\n    \"-DCMAKE_INSTALL_BINDIR=bin\"\n  ];\n}\n"
        },
        {
          "name": "jakttest",
          "type": "tree",
          "content": null
        },
        {
          "name": "meta",
          "type": "tree",
          "content": null
        },
        {
          "name": "runtime",
          "type": "tree",
          "content": null
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "selfhost",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}