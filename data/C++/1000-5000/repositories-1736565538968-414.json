{
  "metadata": {
    "timestamp": 1736565538968,
    "page": 414,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "CalcProgrammer1/OpenRGB",
      "stars": 2948,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.353515625,
          "content": "# EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs\n# editorconfig.org\n\nroot = true\n\n[*]\nindent_style = space\nindent_size = 4\n\n# We recommend you to keep these unchanged\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.md]\ntrim_trailing_whitespace = false\nindent_size = 4"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.3818359375,
          "content": "# This file is used to ignore files that should not be pushed to the repo.\n# ----------------------------------------------------------------------------\n\n# OpenRGB Specific\nOpenRGB\nopenrgb\nOpenRGB-x86_64.AppImage\n60-openrgb.rules\ndebian/changelog\nfedora/OpenRGB.spec\n\n# Directories\n.build/\n.cache/\n.moc/\n.obj/\n.pch/\n.rcc/\n.uic/\n.clangd/\n*_debug/\n*_release/\ndebug/\nrelease/\nbuild/\nBuild/\n.qmake.cache\n.qmake.stash\n.vscode\n.vs\n\n# Generic Files\n.DS_Store\nThumbs.db\n\n# Binaries\n*.exe\n!dependencies/**/*.exe\n*.bat\n!dependencies/**/*.bat\n\n# C++ objects and libs\n*.a\n*.dll\n*.dylib\n*.ii\n*.la\n*.lai\n*.lo\n*.o\n*.s\n*.slo\n*.so\n*.so.*\n!dependencies/**/*.dll\n\n# Qt-es\nobject_script.*.Release\nobject_script.*.Debug\n*_plugin_import.cpp\n*.pro.user\n*.pro.user.*\n*.qbs.user\n*.qbs.user.*\n*.moc\nmoc_*.cpp\nmoc_*.h\nqrc_*.cpp\nui_*.h\n*.qmlc\n*.jsc\nMakefile*\n*build-*\n*.qm\n*.prl\n\n# Qt unit tests\ntarget_wrapper.*\n\n# QtCreator\n*.autosave\n\n# QtCreator Qml\n*.qmlproject.user\n*.qmlproject.user.*\n\n# QtCreator CMake\nCMakeLists.txt.user*\n\n# QtCreator 4.8< compilation database\ncompile_commands.json\n\n# QtCreator local machine specific files for imported projects\n*creator.user*\n*.qrc\n\n# Visual Studio generated files\n*.ib_pdb_index\n*.idb\n*.ilk\n*.ncb\n*.opensdf\n*.pdb\n*.sdf\n*.sln\n*.suo\n*.vcproj\n*.vcxproj\n*vcproj.*.*.user\n*vcxproj.*\n\n# MinGW generated files\n*.Debug\n*.Release\n\n# Clang tooling files\ncompile_commands.json\n\n# Generated i18n files\n*.qm\n"
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 20.5498046875,
          "content": "# swy: some useful references; the MSVC part of the CI script is based on the one from bind9, by Michał Kępień:\n# https://gitlab.com/gitlab-org/ci-cd/shared-runners/images/gcp/windows-containers/blob/master/cookbooks/preinstalled-software/README.md\n# https://gitlab.isc.org/isc-projects/bind9/commit/facc6a051fcac70fbbc61cb92a37be8c3e4db5ec#587d266bb27a4dc3022bbed44dfa19849df3044c_718_731\n# https://www.kittell.net/code/powershell-unix-sed-equivalent-change-text-file/\n# https://powershell.org/forums/topic/how-to-use-ansi-vt100-formatting-in-powershell-ooh-pretty-colors/\n\n#-----------------------------------------------------------------------#\n# OpenRGB GitLab CI Configuration                                       #\n#-----------------------------------------------------------------------#\n.fork_local_runner_rules:\n  rules:\n  - if: $CI_PROJECT_PATH == \"CalcProgrammer1/OpenRGB\" || $CI_PIPELINE_SOURCE == \"push\"\n    when: on_success\n\n.fork_gitlab_runner_rules:\n  rules:\n  - if: $CI_PROJECT_PATH != \"CalcProgrammer1/OpenRGB\" && $CI_PIPELINE_SOURCE == \"push\"\n    when: manual\n    allow_failure: true\n\n.upstream_rules:\n  rules:\n  - if: '$CI_PROJECT_PATH == \"CalcProgrammer1/OpenRGB\"'\n    when: on_success\n  - !reference [.fork_gitlab_runner_rules, rules]\n\n.shared_windows_runners:\n  tags:\n  - shared-windows\n  - windows\n  - windows-1809\n\nstages:\n  - build\n  - test\n\nbefore_script:\n - echo \"started by ${GITLAB_USER_NAME}\"\n\n#reusable templates\n.ccache_init: &ccache_init\n  before_script:\n    - export QT_SELECT=qt5\n    - export APPIMAGE_EXTRACT_AND_RUN=1\n\n#-----------------------------------------------------------------------#\n# Supported Devices Build Target                                        #\n#-----------------------------------------------------------------------#\n\"Supported Devices\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-amd64\n  tags:\n  - linux\n  - amd64\n  stage: build\n  script:\n  - qmake\n  - make -j$(nproc)\n  - ./scripts/build-supported-devices-md.sh $CI_PROJECT_DIR $CI_COMMIT_SHORT_SHA\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Supported_Devices_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - Supported Devices.csv\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (AppImage) i386 Build Target                                    #\n#-----------------------------------------------------------------------#\n\"Linux i386 AppImage\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-i386\n  tags:\n  - linux\n  - i386\n  stage: build\n  script:\n  - export $(dpkg-architecture)\n  - ./scripts/build-appimage.sh\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_i386_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB-i386.AppImage\n    - 60-openrgb.rules\n    - README.md\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (AppImage) amd64 Build Target                                   #\n#-----------------------------------------------------------------------#\n\"Linux amd64 AppImage Base\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-amd64\n  stage: build\n  script:\n  - export $(dpkg-architecture)\n  - ./scripts/build-appimage.sh\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_amd64_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB-x86_64.AppImage\n    - 60-openrgb.rules\n    - README.md\n    expire_in: 30 days\n\n  rules:\n  - if: $CI_PIPELINE_SOURCE == \"merge_request_event\" || $CI_PIPELINE_SOURCE == \"push\"\n    when: never\n\n\"Linux amd64 AppImage\":\n  extends: \"Linux amd64 AppImage Base\"\n  rules:\n  - !reference [.fork_local_runner_rules, rules]\n  tags:\n  - linux\n  - amd64\n\n\"Linux amd64 AppImage (gitlab.com runner)\":\n  extends: \"Linux amd64 AppImage Base\"\n  rules:\n  - !reference [.fork_gitlab_runner_rules, rules]\n  tags:\n  - \"saas-linux-small-amd64\"\n\n#-----------------------------------------------------------------------#\n# Linux (AppImage) armhf Build Target                                   #\n#-----------------------------------------------------------------------#\n\"Linux armhf AppImage\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-armhf\n  tags:\n  - linux\n  - armhf\n  stage: build\n  script:\n  - export $(dpkg-architecture)\n  - ./scripts/build-appimage.sh\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_armhf_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB-armhf.AppImage\n    - 60-openrgb.rules\n    - README.md\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (AppImage) arm64 Build Target                                   #\n#-----------------------------------------------------------------------#\n\"Linux arm64 AppImage\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-arm64\n  tags:\n  - linux\n  - arm64\n  stage: build\n  script:\n  - export $(dpkg-architecture)\n  - ./scripts/build-appimage.sh\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_arm64_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB-arm64.AppImage\n    - 60-openrgb.rules\n    - README.md\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (.deb) Debian Bookworm i386 Build Target                        #\n#-----------------------------------------------------------------------#\n\"Linux i386 .deb (Debian Bookworm)\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-i386\n  tags:\n  - linux\n  - i386\n  stage: build\n  script:\n  - ./scripts/build-package-files.sh debian/changelog\n  - dpkg-architecture -l\n  - dpkg-buildpackage -us -B\n  - rm -v ../openrgb-dbgsym*.deb\n  - mv -v ../openrgb*.deb ./\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_i386_deb_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - openrgb*.deb\n    exclude:\n    - openrgb-dbgsym*.deb\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (.deb) Debian Bookworm amd64 Build Target                       #\n#-----------------------------------------------------------------------#\n\"Linux amd64 .deb (Debian Bookworm)\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-amd64\n  tags:\n  - linux\n  - amd64\n  stage: build\n  script:\n  - ./scripts/build-package-files.sh debian/changelog\n  - dpkg-architecture -l\n  - dpkg-buildpackage -us -B\n  - rm -v ../openrgb-dbgsym*.deb\n  - mv -v ../openrgb*.deb ./\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_amd64_deb_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - openrgb*.deb\n    exclude:\n    - openrgb-dbgsym*.deb\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (.deb) Debian Bookworm armhf Build Target                       #\n#-----------------------------------------------------------------------#\n\"Linux armhf .deb (Debian Bookworm)\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-armhf\n  tags:\n  - linux\n  - armhf\n  stage: build\n  script:\n  - ./scripts/build-package-files.sh debian/changelog\n  - dpkg-architecture -l\n  - dpkg-buildpackage -us -B\n  - rm -v ../openrgb-dbgsym*.deb\n  - mv -v ../openrgb*.deb ./\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_armhf_deb_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - openrgb*.deb\n    exclude:\n    - openrgb-dbgsym*.deb\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (.deb) Debian Bookworm arm64 Build Target                       #\n#-----------------------------------------------------------------------#\n\"Linux arm64 .deb (Debian Bookworm)\":\n  <<: *ccache_init\n  image: registry.gitlab.com/openrgbdevelopers/openrgb-linux-ci-deb-builder:bookworm-arm64\n  tags:\n  - linux\n  - arm64\n  stage: build\n  script:\n  - ./scripts/build-package-files.sh debian/changelog\n  - dpkg-architecture -l\n  - dpkg-buildpackage -us -B\n  - rm -v ../openrgb-dbgsym*.deb\n  - mv -v ../openrgb*.deb ./\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_arm64_deb_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - openrgb*.deb\n    exclude:\n    - openrgb-dbgsym*.deb\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Linux (.rpm, F40) 64-bit Build Target                                 #\n#-----------------------------------------------------------------------#\n\"Linux 64 F40 rpm\":\n  image: fedora:40\n  stage: build\n  script:\n  - dnf install rpmdevtools dnf-plugins-core libcurl-devel qt5-qtbase-devel -y\n  - rpmdev-setuptree\n  - ./scripts/build-package-files.sh fedora/OpenRGB.spec\n  - ls /root/\n  - cp fedora/OpenRGB.spec /root/rpmbuild/SPECS\n  - cp ../OpenRGB /root/rpmbuild/SOURCES/ -r\n  - cd /root/rpmbuild/SOURCES\n  - tar -cf OpenRGB.tar.gz OpenRGB/\n  - cd ..\n  - dnf builddep SPECS/OpenRGB.spec -y\n  - rpmbuild -ba SPECS/OpenRGB.spec\n  - cd RPMS/x86_64/\n  - mv openrgb*.rpm ${CI_PROJECT_DIR}/\n  - cd ${CI_PROJECT_DIR}\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Linux_64_rpm_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - openrgb*.rpm\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Debian i386 Bookworm test                                             #\n#-----------------------------------------------------------------------#\n\"Debian i386 Bookworm\":\n  image: i386/debian:bookworm\n  stage: test\n  script:\n  - apt update\n  - DEBIAN_FRONTEND=noninteractive apt install -yq --no-install-recommends ./openrgb*i386.deb\n  - openrgb --version\n  - apt remove -y openrgb\n  dependencies:\n  - \"Linux i386 .deb (Debian Bookworm)\"\n  needs:\n  - \"Linux i386 .deb (Debian Bookworm)\"\n\n#-----------------------------------------------------------------------#\n# Debian amd64 Bookworm test                                            #\n#-----------------------------------------------------------------------#\n\"Debian amd64 Bookworm\":\n  image: amd64/debian:bookworm\n  stage: test\n  script:\n  - apt update\n  - DEBIAN_FRONTEND=noninteractive apt install -yq --no-install-recommends ./openrgb*amd64.deb\n  - openrgb --version\n  - apt remove -y openrgb\n  dependencies:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n  needs:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n\n#-----------------------------------------------------------------------#\n# Ubuntu amd64 22.04 test                                               #\n#-----------------------------------------------------------------------#\n\"Ubuntu amd64 22.04LTS\":\n  image: ubuntu:jammy\n  stage: test\n  script:\n  - apt update\n  - DEBIAN_FRONTEND=noninteractive apt install -yq --no-install-recommends ./openrgb*amd64.deb\n  - openrgb --version\n  - apt remove -y openrgb\n  dependencies:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n  needs:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n\n#-----------------------------------------------------------------------#\n# Ubuntu amd64 24.04 test                                               #\n#-----------------------------------------------------------------------#\n\"Ubuntu amd64 24.04LTS\":\n  image: ubuntu:noble\n  stage: test\n  script:\n  - apt update\n  - DEBIAN_FRONTEND=noninteractive apt install -yq --no-install-recommends ./openrgb*amd64.deb\n  - openrgb --version\n  - apt remove -y openrgb\n  dependencies:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n  needs:\n  - \"Linux amd64 .deb (Debian Bookworm)\"\n\n#-----------------------------------------------------------------------#\n# Fedora 64 v40 test                                                    #\n#-----------------------------------------------------------------------#\n\"Fedora 64 v40\":\n  image: fedora:40\n  stage: test\n  script:\n  - yum -y localinstall ./openrgb*64.rpm\n  - openrgb --version\n  - yum -y remove openrgb\n  dependencies:\n  - \"Linux 64 F40 rpm\"\n  needs:\n  - \"Linux 64 F40 rpm\"\n\n#-----------------------------------------------------------------------#\n# Windows (32-bit) Build Target                                         #\n#-----------------------------------------------------------------------#\n\"Windows 32\":\n  extends:\n  - .shared_windows_runners\n  stage: build\n  script:\n  - $esc = \"$([char]27)\"\n  - $count = 0\n  - function _unix_tmsec_ { [int64](([datetime]::UtcNow)-(get-date \"1/1/1970\")).TotalSeconds }\n  - function _fold_start_ { param( [string]$TEXT_TAG ) $t=_unix_tmsec_; $global:count += 1; Write-Host -NoNewLine \"`r`n`r`nsection_start:${t}:sect_${count}`r${esc}[0K${esc}[33m${TEXT_TAG}${esc}[39m`r`n\"; }\n  - function _fold_final_ {                            $t=_unix_tmsec_;                     Write-Host -NoNewLine   \"`r`n`r`nsection_end:${t}:sect_${count}`r${esc}[0K`r`n\"           ; }\n\n\n  - _fold_start_ 'configuring the msvc environment variables'\n  - Push-Location \"C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Auxiliary/Build\"\n  - '& cmd.exe /C \"vcvarsall.bat x86 & set\" | Foreach-Object { if ($_ -match \"(.*?)=(.*)\") { Set-Item -force -path \"Env:\\$($matches[1])\" -value \"$($matches[2])\" } }'\n  - Pop-Location\n  - _fold_final_\n\n  - _fold_start_ 'downloading precompiled versions of qtbase, qttools (for windeployqt) and jom (for a more parallel nmake)'\n  - mkdir _qt\n  - mkdir _qt_download\n  - Push-Location _qt_download\n  - curl.exe -LJ -o qt-base.7z  'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610076/download'\n  - curl.exe -LJ -o qt-tools.7z 'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610097/download'\n  - curl.exe -LJ -o qt-jom.zip  'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610138/download'\n  - _fold_final_\n\n  - _fold_start_ 'extracting the downloaded qt binaries'\n  - 7z x qt-base.7z  '-o../_qt' -y\n  - 7z x qt-tools.7z '-o../_qt' -y\n  - 7z x qt-jom.zip  '-o../_qt' -y\n  - _fold_final_\n\n  - _fold_start_ 'turn the qt install from enterprise to foss; remove the licensing checks'\n  - ${qconfig-pri-folder} = '..\\_qt\\5.15.0\\msvc2019\\mkspecs\\qconfig.pri'\n  - (Get-Content ${qconfig-pri-folder}).replace('QT_EDITION = Enterprise', 'QT_EDITION = OpenSource') | Set-Content ${qconfig-pri-folder}\n  - (Get-Content ${qconfig-pri-folder}).replace('QT_LICHECK = licheck.exe', '')                       | Set-Content ${qconfig-pri-folder}\n  - Pop-Location\n  - _fold_final_\n\n  - _fold_start_ 'run qmake and generate the msvc nmake makefile'\n  - mkdir _build; cd _build\n  - ..\\_qt\\5.15.0\\msvc2019\\bin\\qmake ..\\OpenRGB.pro\n  - _fold_final_\n\n  - _fold_start_ 'start the actual build with jom instead of nmake; for speed'\n  - ..\\_qt\\jom\n  - _fold_final_\n\n  - _fold_start_ 'run windeployqt to automatically copy the needed dll files'\n  - ..\\_qt\\5.15.0\\msvc2019\\bin\\windeployqt --no-angle --no-translations --no-opengl-sw --no-system-d3d-compiler --no-compiler-runtime --no-webkit2 .\\release\\\n  - _fold_final_\n\n  - _fold_start_ 'Moving results for upload'\n  - mv release ../'OpenRGB Windows 32-bit'\n  - _fold_final_\n#  cache:\n#    key: same-key\n#    paths:\n#    - C:\\vcpkg\\installed\\\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Windows_32_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - 'OpenRGB Windows 32-bit'\n    exclude:\n    - 'OpenRGB Windows 32-bit\\*.qm'\n    expire_in: 30 days\n\n  rules:\n    - !reference [.upstream_rules, rules]\n\n#-----------------------------------------------------------------------#\n# Windows (64-bit) Build Target                                         #\n#-----------------------------------------------------------------------#\n\"Windows 64 Base\":\n  extends:\n  - .shared_windows_runners\n  stage: build\n  script:\n  - $esc = \"$([char]27)\"\n  - $count = 0\n  - function _unix_tmsec_ { [int64](([datetime]::UtcNow)-(get-date \"1/1/1970\")).TotalSeconds }\n  - function _fold_start_ { param( [string]$TEXT_TAG ) $t=_unix_tmsec_; $global:count += 1; Write-Host -NoNewLine \"`r`n`r`nsection_start:${t}:sect_${count}`r${esc}[0K${esc}[33m${TEXT_TAG}${esc}[39m`r`n\"; }\n  - function _fold_final_ {                            $t=_unix_tmsec_;                     Write-Host -NoNewLine   \"`r`n`r`nsection_end:${t}:sect_${count}`r${esc}[0K`r`n\"           ; }\n\n\n  - _fold_start_ 'configuring the msvc environment variables'\n  - Push-Location \"C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Auxiliary/Build\"\n  - '& cmd.exe /C \"vcvarsall.bat x64 & set\" | Foreach-Object { if ($_ -match \"(.*?)=(.*)\") { Set-Item -force -path \"Env:\\$($matches[1])\" -value \"$($matches[2])\" } }'\n  - Pop-Location\n  - _fold_final_\n\n  - _fold_start_ 'downloading precompiled versions of qtbase, qttools (for windeployqt) and jom (for a more parallel nmake)'\n  - mkdir _qt\n  - mkdir _qt_download\n  - Push-Location _qt_download\n  - curl.exe -LJ -o qt-base.7z  'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610116/download'\n  - curl.exe -LJ -o qt-tools.7z 'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610131/download'\n  - curl.exe -LJ -o qt-jom.zip  'https://gitlab.com/OpenRGBDevelopers/openrgb-linux-ci-deb-builder/-/package_files/55610138/download'\n  - _fold_final_\n\n  - _fold_start_ 'extracting the downloaded qt binaries'\n  - 7z x qt-base.7z  '-o../_qt' -y\n  - 7z x qt-tools.7z '-o../_qt' -y\n  - 7z x qt-jom.zip  '-o../_qt' -y\n  - _fold_final_\n\n  - _fold_start_ 'turn the qt install from enterprise to foss; remove the licensing checks'\n  - ${qconfig-pri-folder} = '..\\_qt\\5.15.0\\msvc2019_64\\mkspecs\\qconfig.pri'\n  - (Get-Content ${qconfig-pri-folder}).replace('QT_EDITION = Enterprise', 'QT_EDITION = OpenSource') | Set-Content ${qconfig-pri-folder}\n  - (Get-Content ${qconfig-pri-folder}).replace('QT_LICHECK = licheck.exe', '')                       | Set-Content ${qconfig-pri-folder}\n  - Pop-Location\n  - _fold_final_\n\n  - _fold_start_ 'run qmake and generate the msvc nmake makefile'\n  - mkdir _build; cd _build\n  - ..\\_qt\\5.15.0\\msvc2019_64\\bin\\qmake ..\\OpenRGB.pro\n  - _fold_final_\n\n  - _fold_start_ 'start the actual build with jom instead of nmake; for speed'\n  - ..\\_qt\\jom\n  - _fold_final_\n\n  - _fold_start_ 'run windeployqt to automatically copy the needed dll files'\n  - ..\\_qt\\5.15.0\\msvc2019_64\\bin\\windeployqt --no-angle --no-translations --no-opengl-sw --no-system-d3d-compiler --no-compiler-runtime --no-webkit2 .\\release\\\n  - _fold_final_\n\n  - _fold_start_ 'Moving results for upload'\n  - mv release ../'OpenRGB Windows 64-bit'\n  - _fold_final_\n#  cache:\n#    key: same-key\n#    paths:\n#    - C:\\vcpkg\\installed\\\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_Windows_64_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - 'OpenRGB Windows 64-bit'\n    exclude:\n    - 'OpenRGB Windows 64-bit\\*.qm'\n    expire_in: 30 days\n\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\" || $CI_PIPELINE_SOURCE == \"push\"\n      when: never\n\n\n\"Windows 64\":\n  extends: \"Windows 64 Base\"\n  rules:\n  - !reference [.fork_local_runner_rules, rules]\n\n\"Windows 64 (gitlab.com runner)\":\n  extends: \"Windows 64 Base\"\n  before_script:\n    choco install visualstudio2019-workload-vctools -y # gitlab provides vs2022, so add vs2019\n  rules:\n  - !reference [.fork_gitlab_runner_rules, rules]\n  tags:\n  - \"saas-windows-medium-amd64\"\n\n#-----------------------------------------------------------------------#\n# MacOS Build Target                                                    #\n#-----------------------------------------------------------------------#\n\"MacOS ARM64\":\n  tags:\n  - macos\n  stage: build\n  script:\n  - eval $(/opt/homebrew/bin/brew shellenv)\n  - qmake OpenRGB.pro\n  - make -j16\n  - macdeployqt OpenRGB.app -codesign=OpenRGB\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_MacOS_ARM64_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB.app\n    expire_in: 30 days\n\n  rules:\n  - if: '$CI_PROJECT_PATH == \"CalcProgrammer1/OpenRGB\"'\n    when: on_success\n  - if: '$BUILD_MACOS =~ /.+/'\n    when: on_success\n  - if: $CI_PIPELINE_SOURCE == \"push\"\n    when: manual\n    allow_failure: true\n\n\"MacOS Intel\":\n  tags:\n  - macos\n  stage: build\n  script:\n  - eval $(/usr/local/bin/brew shellenv)\n  - arch -x86_64 /usr/local/bin/qmake OpenRGB.pro\n  - arch -x86_64 make -j16\n  - arch -x86_64 macdeployqt OpenRGB.app -codesign=OpenRGB\n\n  artifacts:\n    name: \"${CI_PROJECT_NAME}_MacOS_Intel_${CI_COMMIT_SHORT_SHA}\"\n    paths:\n    - OpenRGB.app\n    expire_in: 30 days\n\n  rules:\n  - if: '$CI_PROJECT_PATH == \"CalcProgrammer1/OpenRGB\"'\n    when: on_success\n  - if: '$BUILD_MACOS =~ /.+/'\n    when: on_success\n  - if: $CI_PIPELINE_SOURCE == \"push\"\n    when: manual\n    allow_failure: true\n"
        },
        {
          "name": ".gitlab",
          "type": "tree",
          "content": null
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "AutoStart",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.716796875,
          "content": "# Contributing to OpenRGB\n\nThe OpenRGB project welcomes contributions from the community.  The project would not support the number of devices it does today without the amazing contributions from community developers.  If you want to add a new device, fix a bug, or add a feature, feel free to open a merge request on the OpenRGB GitLab (https://gitlab.com/CalcProgrammer1/OpenRGB).\n\n## Creating a Merge Request\n\nTo create a merge request, log into GitLab and fork the OpenRGB project.  Push your changes to your fork and then use the Create Merge Request option.  Before opening a merge request, please review the following best practices to help your merge request get merged without excessive delay.\n\n* Please keep the scope of each merge request limited to one functional area.  If you wish to add a new device controller, for instance, don't also do code cleanup in another controller as part of the same merge request.\n* Explain what your merge request is changing, why you feel the change is necessary, and add any additional information you feel is needed to best understand your change in the merge request description.\n* Mark your merge request as a draft (start title with \"Draft:\") until it has been tested and verified working.\n* Follow the Style Guidelines below when making your code changes.\n* Avoid using `git merge` when updating your fork.  The OpenRGB project uses a linear git history, meaning all changes are rebased onto the tip of master.  By using `git rebase` to update your fork, you will make it easier to accept merge requests.\n* Do not submit a merge request using your fork's `master` branch as the source.  The `master` branch is protected by default when creating a fork and I cannot manually rebase a protected branch before merging.  If you submit a merge request with a protected `master` branch as the source, it may not get merged until you unprotect it.\n\n### Pipelines, Shared Runners and Quotas\n\nSince mid 2022 Gitlab has limited the usage of shared runners to all projects and whilst quite geneorous quotas are allowed\n for open source projects it is possible to exhaust them. With that in mind not all jobs within the pipeline build are\n triggered to automatically run with every push to your branch with the exception of the Windows 64bit and Linux Appimage 64bit\n jobs. If you need to test or share another build you can still start it manually from your pipeline queue.\n Once a merge request is created all architectures and platforms will be compiled to ensure that they are ready to merge.\n\nPlease refer to the following link for [further information relating to minutes and quotas](https://docs.gitlab.com/ee/ci/pipelines/cicd_minutes.html).\n\n## Style Guidelines\n\nOpenRGB is written in C++, uses the Qt framework for UI, and uses the QMake build system.  While OpenRGB does use C++, I am primarily a C programmer and prefer doing things \"C Style\" vs. C++ style.  C++'s object oriented programming features fit the needs of a program such as OpenRGB where there are many implementations of a single interface so I chose to write it in C++ over C.  Still, however, I prefer using C-style code where possible.  When making changes to existing code files, try to follow the existing style.  Merge requests that go out of their way to restyle code will not be accepted and will be sent back for rework.\n\n### Functional Style\n\n* Limit use of C++ std library data types\n    * For fixed-length containers, use C arrays\n    * For list constants, use const C arrays\n    * For fixed-length strings, use C char buffers (\"C strings\"), though using std::string is acceptable if the value will be placed in a std::string\n    * For basic types, prefer using the non-typedef'd basic types (char, short, int, etc) over typedef'd (uint8_t, uint16_t, uint32_t, etc)\n        * Unless defined in an OpenRGB API or the file is implementing an existing API using these types (such as i2c_smbus)\n    * For hard-coded values, use `#define`s over const variables unless you need a pointer to the value\n    * For variable-length containers, use std::vector\n    * For variable-length strings, use std::string\n    * `struct` should not include any functions, only variables\n    * `class` should only be used for objects containing functions\n    * Other std types may be used sparingly if necessary\n* Only use Qt libraries, types, and functionality in user interface files\n    * Anything under the qt/ folder basically\n    * Do not use QDebug, use our LogManager instead.  If you use QDebug during development, please remove it before submitting your merge request\n* Use C-style indexed for loops when iterating through an array or vector\n* Use C-style casts unless necessary\n* Avoid the `auto` type.  It makes code more difficult to read\n* Do not use `printf` or `cout` for debug messages, use LogManager instead\n* Don't define namespaces unless necessary\n\n### Non-functional Style\n\n* Set your editor's tab settings to insert spaces, using 4 spaces per tab stop\n* Always put opening and closing braces `{`, `}` on their own lines\n* Indent code inside the braces, do not indent the braces themselves\n* Capitalize hexadecimal literals (`0xFF` not `0xff`) except in the udev rules file (which must be lowercase to work)\n* No space between keyword and open parenthesis (`if(TRUE)` not `if (TRUE)`).  There are some instances of this that haven't been cleaned up in the code.\n* Generally, `snake_case` is used for variable names and `CamelCase` is used for function and class names\n* Add a header comment to new files with the filename, description, original author, and date (this is missing on most Detect files)\n* Line up `=` when doing a lot of assignments together\n* Use this comment box style when adding comments:\n\n```\n/*--------------------------------*\\\n| This is a comment                |\n\\*_-------------------------------*/\n```\n"
        },
        {
          "name": "Colors.h",
          "type": "blob",
          "size": 5.3056640625,
          "content": "/*---------------------------------------------------------*\\\n| Colors.h                                                  |\n|                                                           |\n|   List of named color constants                           |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#ifndef COLORS_H\n#define COLORS_H\n\n#define COLOR_BLACK 0x000000\n#define COLOR_NAVY 0x000080\n#define COLOR_DARKBLUE 0x00008b\n#define COLOR_MEDIUMBLUE 0x0000cd\n#define COLOR_BLUE 0x0000ff\n#define COLOR_DARKGREEN 0x006400\n#define COLOR_GREEN 0x008000\n#define COLOR_TEAL 0x008080\n#define COLOR_DARKCYAN 0x008b8b\n#define COLOR_DEEPSKYBLUE 0x00bfff\n#define COLOR_DARKTURQUOISE 0x00ced1\n#define COLOR_MEDIUMSPRINGGREEN 0x00fa9a\n#define COLOR_LIME 0x00ff00\n#define COLOR_SPRINGGREEN 0x00ff7f\n#define COLOR_AQUA 0x00ffff\n#define COLOR_CYAN 0x00ffff\n#define COLOR_MIDNIGHTBLUE 0x191970\n#define COLOR_DODGERBLUE 0x1e90ff\n#define COLOR_LIGHTSEAGREEN 0x20b2aa\n#define COLOR_FORESTGREEN 0x228b22\n#define COLOR_SEAGREEN 0x2e8b57\n#define COLOR_DARKSLATEGRAY 0x2f4f4f\n#define COLOR_DARKSLATEGREY 0x2f4f4f\n#define COLOR_LIMEGREEN 0x32cd32\n#define COLOR_MEDIUMSEAGREEN 0x3cb371\n#define COLOR_TURQUOISE 0x40e0d0\n#define COLOR_ROYALBLUE 0x4169e1\n#define COLOR_STEELBLUE 0x4682b4\n#define COLOR_DARKSLATEBLUE 0x483d8b\n#define COLOR_MEDIUMTURQUOISE 0x48d1cc\n#define COLOR_INDIGO 0x4b0082\n#define COLOR_DARKOLIVEGREEN 0x556b2f\n#define COLOR_CADETBLUE 0x5f9ea0\n#define COLOR_CORNFLOWERBLUE 0x6495ed\n#define COLOR_MEDIUMAQUAMARINE 0x66cdaa\n#define COLOR_DIMGRAY 0x696969\n#define COLOR_DIMGREY 0x696969\n#define COLOR_SLATEBLUE 0x6a5acd\n#define COLOR_OLIVEDRAB 0x6b8e23\n#define COLOR_SLATEGRAY 0x708090\n#define COLOR_SLATEGREY 0x708090\n#define COLOR_LIGHTSLATEGRAY 0x778899\n#define COLOR_LIGHTSLATEGREY 0x778899\n#define COLOR_MEDIUMSLATEBLUE 0x7b68ee\n#define COLOR_LAWNGREEN 0x7cfc00\n#define COLOR_CHARTREUSE 0x7fff00\n#define COLOR_AQUAMARINE 0x7fffd4\n#define COLOR_MAROON 0x800000\n#define COLOR_PURPLE 0x800080\n#define COLOR_ELECTRIC_ULTRAMARINE 0x4000FF\n#define COLOR_OLIVE 0x808000\n#define COLOR_GRAY 0x808080\n#define COLOR_GREY 0x808080\n#define COLOR_SKYBLUE 0x87ceeb\n#define COLOR_LIGHTSKYBLUE 0x87cefa\n#define COLOR_BLUEVIOLET 0x8a2be2\n#define COLOR_DARKRED 0x8b0000\n#define COLOR_DARKMAGENTA 0x8b008b\n#define COLOR_SADDLEBROWN 0x8b4513\n#define COLOR_DARKSEAGREEN 0x8fbc8f\n#define COLOR_LIGHTGREEN 0x90ee90\n#define COLOR_MEDIUMPURPLE 0x9370db\n#define COLOR_DARKVIOLET 0x9400d3\n#define COLOR_PALEGREEN 0x98fb98\n#define COLOR_DARKORCHID 0x9932cc\n#define COLOR_YELLOWGREEN 0x9acd32\n#define COLOR_SIENNA 0xa0522d\n#define COLOR_BROWN 0xa52a2a\n#define COLOR_DARKGRAY 0xa9a9a9\n#define COLOR_DARKGREY 0xa9a9a9\n#define COLOR_LIGHTBLUE 0xadd8e6\n#define COLOR_GREENYELLOW 0xadff2f\n#define COLOR_PALETURQUOISE 0xafeeee\n#define COLOR_LIGHTSTEELBLUE 0xb0c4de\n#define COLOR_POWDERBLUE 0xb0e0e6\n#define COLOR_FIREBRICK 0xb22222\n#define COLOR_DARKGOLDENROD 0xb8860b\n#define COLOR_MEDIUMORCHID 0xba55d3\n#define COLOR_ROSYBROWN 0xbc8f8f\n#define COLOR_DARKKHAKI 0xbdb76b\n#define COLOR_SILVER 0xc0c0c0\n#define COLOR_MEDIUMVIOLETRED 0xc71585\n#define COLOR_INDIANRED 0xcd5c5c\n#define COLOR_PERU 0xcd853f\n#define COLOR_CHOCOLATE 0xd2691e\n#define COLOR_TAN 0xd2b48c\n#define COLOR_LIGHTGRAY 0xd3d3d3\n#define COLOR_LIGHTGREY 0xd3d3d3\n#define COLOR_THISTLE 0xd8bfd8\n#define COLOR_ORCHID 0xda70d6\n#define COLOR_GOLDENROD 0xdaa520\n#define COLOR_PALEVIOLETRED 0xdb7093\n#define COLOR_CRIMSON 0xdc143c\n#define COLOR_GAINSBORO 0xdcdcdc\n#define COLOR_PLUM 0xdda0dd\n#define COLOR_BURLYWOOD 0xdeb887\n#define COLOR_LIGHTCYAN 0xe0ffff\n#define COLOR_LAVENDER 0xe6e6fa\n#define COLOR_DARKSALMON 0xe9967a\n#define COLOR_VIOLET 0xee82ee\n#define COLOR_PALEGOLDENROD 0xeee8aa\n#define COLOR_LIGHTCORAL 0xf08080\n#define COLOR_KHAKI 0xf0e68c\n#define COLOR_ALICEBLUE 0xf0f8ff\n#define COLOR_HONEYDEW 0xf0fff0\n#define COLOR_AZURE 0xf0ffff\n#define COLOR_SANDYBROWN 0xf4a460\n#define COLOR_WHEAT 0xf5deb3\n#define COLOR_BEIGE 0xf5f5dc\n#define COLOR_WHITESMOKE 0xf5f5f5\n#define COLOR_MINTCREAM 0xf5fffa\n#define COLOR_GHOSTWHITE 0xf8f8ff\n#define COLOR_SALMON 0xfa8072\n#define COLOR_ANTIQUEWHITE 0xfaebd7\n#define COLOR_LINEN 0xfaf0e6\n#define COLOR_LIGHTGOLDENRODYELLOW 0xfafad2\n#define COLOR_OLDLACE 0xfdf5e6\n#define COLOR_RED 0xff0000\n#define COLOR_FUCHSIA 0xff00ff\n#define COLOR_MAGENTA 0xff00ff\n#define COLOR_DEEPPINK 0xff1493\n#define COLOR_ORANGERED 0xff4500\n#define COLOR_TOMATO 0xff6347\n#define COLOR_HOTPINK 0xff69b4\n#define COLOR_CORAL 0xff7f50\n#define COLOR_DARKORANGE 0xff8c00\n#define COLOR_LIGHTSALMON 0xffa07a\n#define COLOR_ORANGE 0xffa500\n#define COLOR_LIGHTPINK 0xffb6c1\n#define COLOR_PINK 0xffc0cb\n#define COLOR_GOLD 0xffd700\n#define COLOR_PEACHPUFF 0xffdab9\n#define COLOR_NAVAJOWHITE 0xffdead\n#define COLOR_MOCCASIN 0xffe4b5\n#define COLOR_BISQUE 0xffe4c4\n#define COLOR_MISTYROSE 0xffe4e1\n#define COLOR_BLANCHEDALMOND 0xffebcd\n#define COLOR_PAPAYAWHIP 0xffefd5\n#define COLOR_LAVENDERBLUSH 0xfff0f5\n#define COLOR_SEASHELL 0xfff5ee\n#define COLOR_CORNSILK 0xfff8dc\n#define COLOR_LEMONCHIFFON 0xfffacd\n#define COLOR_FLORALWHITE 0xfffaf0\n#define COLOR_SNOW 0xfffafa\n#define COLOR_YELLOW 0xffff00\n#define COLOR_LIGHTYELLOW 0xffffe0\n#define COLOR_IVORY 0xfffff0\n#define COLOR_WHITE 0xffffff\n\n#endif // COLORS_H\n"
        },
        {
          "name": "Controllers",
          "type": "tree",
          "content": null
        },
        {
          "name": "Detector.h",
          "type": "blob",
          "size": 5.9462890625,
          "content": "/*---------------------------------------------------------*\\\n| Detector.h                                                |\n|                                                           |\n|   Macros for registering detectors                        |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include \"DeviceDetector.h\"\n\n#define REGISTER_DETECTOR(name, func)                                                   static DeviceDetector           device_detector_obj_##func(name, func)\n#define REGISTER_I2C_DETECTOR(name, func)                                               static I2CDeviceDetector        device_detector_obj_##func(name, func)\n#define REGISTER_I2C_DIMM_DETECTOR(name, func, jedec_id, dimm_type)                     static I2CDIMMDeviceDetector    device_detector_obj_##func(name, func, jedec_id, dimm_type)\n#define REGISTER_I2C_PCI_DETECTOR(name, func, ven, dev, subven, subdev, addr)           static I2CPCIDeviceDetector     device_detector_obj_##ven##dev##subven##subdev##addr##func(name, func, ven, dev, subven, subdev, addr)\n#define REGISTER_I2C_BUS_DETECTOR(func)                                                 static I2CBusDetector           device_detector_obj_##func(func)\n#define REGISTER_HID_DETECTOR(name, func, vid, pid)                                     static HIDDeviceDetector        device_detector_obj_##vid##pid(name, func, vid, pid, HID_INTERFACE_ANY, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_HID_DETECTOR_I(name, func, vid, pid, interface)                        static HIDDeviceDetector        device_detector_obj_##vid##pid##_##interface(name, func, vid, pid, interface, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_HID_DETECTOR_IP(name, func, vid, pid, interface, page)                 static HIDDeviceDetector        device_detector_obj_##vid##pid##_##interface##_##page(name, func, vid, pid, interface, page, HID_USAGE_ANY)\n#define REGISTER_HID_DETECTOR_IPU(name, func, vid, pid, interface, page, usage)         static HIDDeviceDetector        device_detector_obj_##vid##pid##_##interface##_##page##_##usage(name, func, vid, pid, interface, page, usage)\n#define REGISTER_HID_DETECTOR_P(name, func, vid, pid, page)                             static HIDDeviceDetector        device_detector_obj_##vid##pid##__##page(name, func, vid, pid, HID_INTERFACE_ANY, page, HID_USAGE_ANY)\n#define REGISTER_HID_DETECTOR_PU(name, func, vid, pid, page, usage)                     static HIDDeviceDetector        device_detector_obj_##vid##pid##__##page##_##usage(name, func, vid, pid, HID_INTERFACE_ANY, page, usage)\n#define REGISTER_HID_WRAPPED_DETECTOR(name, func, vid, pid)                             static HIDWrappedDeviceDetector device_detector_obj_##vid##pid(name, func, vid, pid, HID_INTERFACE_ANY, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_HID_WRAPPED_DETECTOR_I(name, func, vid, pid, interface)                static HIDWrappedDeviceDetector device_detector_obj_##vid##pid##_##interface(name, func, vid, pid, interface, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_HID_WRAPPED_DETECTOR_IPU(name, func, vid, pid, interface, page, usage) static HIDWrappedDeviceDetector device_detector_obj_##vid##pid##_##interface##_##page##_##usage(name, func, vid, pid, interface, page, usage)\n#define REGISTER_HID_WRAPPED_DETECTOR_PU(name, func, vid, pid, page, usage)             static HIDWrappedDeviceDetector device_detector_obj_##vid##pid##__##page##_##usage(name, func, vid, pid, HID_INTERFACE_ANY, page, usage)\n#define REGISTER_DYNAMIC_DETECTOR(name, func)                                           static DynamicDetector          device_detector_obj_##func(name, func)\n#define REGISTER_PRE_DETECTION_HOOK(func)                                               static PreDetectionHook         device_detector_obj_##func(func)\n\n#define REGISTER_DYNAMIC_I2C_DETECTOR(name, func)                                       I2CDeviceDetector               device_detector_obj_##func(name, func)\n#define REGISTER_DYNAMIC_I2C_DIMM_DETECTOR(name, func, jedec_id, dimm_type)             I2CDIMMDeviceDetector           device_detector_obj_##func(name, func, jedec_id, dimm_type)\n#define REGISTER_DYNAMIC_I2C_PCI_DETECTOR(name, func, ven, dev, subven, subdev, addr)   I2CPCIDeviceDetector            device_detector_obj_##ven##dev##subven##subdev##addr##func(name, func, ven, dev, subven, subdev, addr)\n#define REGISTER_DYNAMIC_I2C_BUS_DETECTOR(func)                                         I2CBusDetector                  device_detector_obj_##func(func)\n#define REGISTER_DYNAMIC_HID_DETECTOR(name, func, vid, pid)                             HIDDeviceDetector               device_detector_obj_##vid##pid(name, func, vid, pid, HID_INTERFACE_ANY, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_DYNAMIC_HID_DETECTOR_I(name, func, vid, pid, interface)                HIDDeviceDetector               device_detector_obj_##vid##pid##_##interface(name, func, vid, pid, interface, HID_USAGE_PAGE_ANY, HID_USAGE_ANY)\n#define REGISTER_DYNAMIC_HID_DETECTOR_IP(name, func, vid, pid, interface, page)         HIDDeviceDetector               device_detector_obj_##vid##pid##_##interface##_##page(name, func, vid, pid, interface, page, HID_USAGE_ANY)\n#define REGISTER_DYNAMIC_HID_DETECTOR_IPU(name, func, vid, pid, interface, page, usage) HIDDeviceDetector               device_detector_obj_##vid##pid##_##interface##_##page##_##usage(name, func, vid, pid, interface, page, usage)\n#define REGISTER_DYNAMIC_HID_DETECTOR_P(name, func, vid, pid, page)                     HIDDeviceDetector               device_detector_obj_##vid##pid##__##page(name, func, vid, pid, HID_INTERFACE_ANY, page, HID_USAGE_ANY)\n#define REGISTER_DYNAMIC_HID_DETECTOR_PU(name, func, vid, pid, page, usage)             HIDDeviceDetector               device_detector_obj_##vid##pid##__##page##_##usage(name, func, vid, pid, HID_INTERFACE_ANY, page, usage)\n"
        },
        {
          "name": "DeviceDetector.h",
          "type": "blob",
          "size": 2.7080078125,
          "content": "/*---------------------------------------------------------*\\\n| DeviceDetector.h                                          |\n|                                                           |\n|   Device detector functionality                           |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"ResourceManager.h\"\n\nclass DeviceDetector\n{\npublic:\n    DeviceDetector(std::string name, DeviceDetectorFunction detector)\n\t{\n        ResourceManager::get()->RegisterDeviceDetector(name, detector);\n\t}\n};\n\nclass I2CDeviceDetector\n{\npublic:\n    I2CDeviceDetector(std::string name, I2CDeviceDetectorFunction detector)\n\t{\n        ResourceManager::get()->RegisterI2CDeviceDetector(name, detector);\n\t}\n};\n\nclass I2CDIMMDeviceDetector\n{\npublic:\n    I2CDIMMDeviceDetector(std::string name, I2CDIMMDeviceDetectorFunction detector, uint16_t jedec_id, uint8_t dimm_type)\n\t{\n        ResourceManager::get()->RegisterI2CDIMMDeviceDetector(name, detector, jedec_id, dimm_type);\n\t}\n};\n\nclass I2CPCIDeviceDetector\n{\npublic:\n    I2CPCIDeviceDetector(std::string name, I2CPCIDeviceDetectorFunction detector, uint16_t ven_id, uint16_t dev_id, uint16_t subven_id, uint16_t subdev_id, uint8_t i2c_addr)\n    {\n        ResourceManager::get()->RegisterI2CPCIDeviceDetector(name, detector, ven_id, dev_id, subven_id, subdev_id, i2c_addr);\n    }\n};\n\nclass I2CBusDetector\n{\npublic:\n    I2CBusDetector(I2CBusDetectorFunction detector)\n    {\n        ResourceManager::get()->RegisterI2CBusDetector(detector);\n    }\n};\n\nclass HIDDeviceDetector\n{\npublic:\n    HIDDeviceDetector(std::string name, HIDDeviceDetectorFunction detector, uint16_t vid, uint16_t pid, int interface, int usage_page, int usage)\n    {\n        ResourceManager::get()->RegisterHIDDeviceDetector(name, detector, vid, pid, interface, usage_page, usage);\n    }\n};\n\nclass HIDWrappedDeviceDetector\n{\npublic:\n    HIDWrappedDeviceDetector(std::string name, HIDWrappedDeviceDetectorFunction detector, uint16_t vid, uint16_t pid, int interface, int usage_page, int usage)\n    {\n        ResourceManager::get()->RegisterHIDWrappedDeviceDetector(name, detector, vid, pid, interface, usage_page, usage);\n    }\n};\n\nclass DynamicDetector\n{\npublic:\n    DynamicDetector(std::string name, DynamicDetectorFunction detector)\n    {\n        ResourceManager::get()->RegisterDynamicDetector(name, detector);\n    }\n};\n\nclass PreDetectionHook\n{\npublic:\n    PreDetectionHook(PreDetectionHookFunction hook)\n    {\n        ResourceManager::get()->RegisterPreDetectionHook(hook);\n    }\n};\n"
        },
        {
          "name": "Documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "KeyboardLayoutManager",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.619140625,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    OpenAuraSDK\n    Copyright (C) 2019  Adam Honse\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  {signature of Ty Coon}, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "LogManager.cpp",
          "type": "blob",
          "size": 12.4482421875,
          "content": "/*---------------------------------------------------------*\\\n| LogManager.cpp                                            |\n|                                                           |\n|   Manages log file and output to the console              |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include \"LogManager.h\"\n\n#include <stdarg.h>\n#include <iostream>\n#include <iomanip>\n#include <chrono>\n\n#include \"filesystem.h\"\n\nconst char* LogManager::log_codes[] = {\"FATAL:\", \"ERROR:\", \"Warning:\", \"Info:\", \"Verbose:\", \"Debug:\", \"Trace:\", \"Dialog:\"};\n\nLogManager::LogManager()\n{\n    base_clock = std::chrono::steady_clock::now();\n    log_console_enabled = false;\n    log_file_enabled = true;\n}\n\nLogManager* LogManager::get()\n{\n    static LogManager* _instance = nullptr;\n    static std::mutex instance_mutex;\n    std::lock_guard<std::mutex> grd(instance_mutex);\n\n    /*-------------------------------------------------*\\\n    | Create a new instance if one does not exist       |\n    \\*-------------------------------------------------*/\n    if(!_instance)\n    {\n        _instance = new LogManager();\n    }\n    \n    return _instance;\n}\n\nunsigned int LogManager::getLoglevel()\n{\n    if(log_console_enabled)\n    {\n        return(LL_TRACE);\n    }\n    else\n    {\n        return(loglevel);\n    }\n}\n\nvoid LogManager::configure(json config, const filesystem::path& defaultDir)\n{\n    std::lock_guard<std::mutex> grd(entry_mutex);\n\n    /*-------------------------------------------------*\\\n    | If the log is not open, create a new log file     |\n    \\*-------------------------------------------------*/\n    if(!log_stream.is_open())\n    {\n        if(config.contains(\"log_file\"))\n        {\n            log_file_enabled = config[\"log_file\"];\n        }\n\n        if(log_file_enabled)\n        {\n            std::string logname = \"OpenRGB_#.log\";\n\n            /*-------------------------------------------------*\\\n            | If the logfile is defined in the configuration,   |\n            | use the configured name                           |\n            \\*-------------------------------------------------*/\n            if(config.contains(\"logfile\"))\n            {\n                const json& logfile_obj = config[\"logfile\"];\n                if(logfile_obj.is_string())\n                {\n                    std::string tmpname = config[\"logfile\"];\n                    if(!tmpname.empty())\n                    {\n                        logname = tmpname;\n                    }\n                }\n            }\n\n            /*-------------------------------------------------*\\\n            | If the # symbol is found in the log file name,    |\n            | replace it with a timestamp                       |\n            \\*-------------------------------------------------*/\n            time_t t = time(0);\n            struct tm* tmp = localtime(&t);\n            char time_string[64];\n            snprintf(time_string, 64, \"%04d%02d%02d_%02d%02d%02d\", 1900 + tmp->tm_year, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n            size_t oct = logname.find(\"#\");\n            if(oct != logname.npos)\n            {\n                logname.replace(oct, 1, time_string);\n            }\n\n            /*-------------------------------------------------*\\\n            | If the path is relative, use logs dir             |\n            \\*-------------------------------------------------*/\n            filesystem::path p = filesystem::u8path(logname);\n            if(p.is_relative())\n            {\n                p = defaultDir / \"logs\" / logname;\n            }\n            filesystem::create_directories(p.parent_path());\n\n            /*-------------------------------------------------*\\\n            | Open the logfile                                  |\n            \\*-------------------------------------------------*/\n            log_stream.open(p);\n\n            /*-------------------------------------------------*\\\n            | Print Git Commit info, version, etc.              |\n            \\*-------------------------------------------------*/\n            log_stream << \"    OpenRGB v\" << VERSION_STRING << std::endl;\n            log_stream << \"    Commit: \" << GIT_COMMIT_ID << \" from \" << GIT_COMMIT_DATE << std::endl;\n            log_stream << \"    Launched: \" << time_string << std::endl;\n            log_stream << \"====================================================================================================\" << std::endl;\n            log_stream << std::endl;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Check loglevel configuration                      |\n    \\*-------------------------------------------------*/\n    if(config.contains(\"loglevel\"))\n    {\n        const json& loglevel_obj = config[\"loglevel\"];\n\n        /*-------------------------------------------------*\\\n        | Set the log level if configured                   |\n        \\*-------------------------------------------------*/\n        if(loglevel_obj.is_number_integer())\n        {\n            loglevel = loglevel_obj;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Check log console configuration                   |\n    \\*-------------------------------------------------*/\n    if(config.contains(\"log_console\"))\n    {\n        log_console_enabled = config[\"log_console\"];\n    }\n\n    /*-------------------------------------------------*\\\n    | Flush the log                                     |\n    \\*-------------------------------------------------*/\n    _flush();\n}\n\nvoid LogManager::_flush()\n{\n    /*-------------------------------------------------*\\\n    | If the log is open, write out buffered messages   |\n    \\*-------------------------------------------------*/\n    if(log_stream.is_open())\n    {\n        for(size_t msg = 0; msg < temp_messages.size(); ++msg)\n        {\n            if(temp_messages[msg]->level <= loglevel || temp_messages[msg]->level == LL_DIALOG)\n            {\n                // Put the timestamp here\n                std::chrono::milliseconds counter = std::chrono::duration_cast<std::chrono::milliseconds>(temp_messages[msg]->counted_second);\n                log_stream << std::left << std::setw(6) << counter.count()  << \"|\";\n                log_stream << std::left << std::setw(9) << log_codes[temp_messages[msg]->level];\n                log_stream << temp_messages[msg]->buffer;\n         \n                if(print_source)\n                {\n                    log_stream << \" [\" << temp_messages[msg]->filename << \":\" << temp_messages[msg]->line << \"]\";\n                }\n                \n                log_stream << std::endl;\n            }\n        }\n\n        /*-------------------------------------------------*\\\n        | Clear temp message buffers after writing them out |\n        \\*-------------------------------------------------*/\n        temp_messages.clear();\n\n        /*-------------------------------------------------*\\\n        | Flush the stream                                  |\n        \\*-------------------------------------------------*/\n        log_stream.flush();\n    }\n}\n\nvoid LogManager::flush()\n{\n    std::lock_guard<std::mutex> grd(entry_mutex);\n    _flush();\n}\n\nvoid LogManager::_append(const char* filename, int line, unsigned int level, const char* fmt, va_list va)\n{\n    /*-------------------------------------------------*\\\n    | If a critical message occurs, enable source       |\n    | printing and set loglevel and verbosity to highest|\n    \\*-------------------------------------------------*/\n    if(level == LL_FATAL)\n    {\n        print_source = true;\n        loglevel = LL_DEBUG;\n        verbosity = LL_DEBUG;\n    }\n\n    /*-------------------------------------------------*\\\n    | Create a new message                              |\n    \\*-------------------------------------------------*/\n    PLogMessage mes = std::make_shared<LogMessage>();\n\n    /*-------------------------------------------------*\\\n    | Resize the buffer, then fill in the message text  |\n    \\*-------------------------------------------------*/\n    va_list va2;\n    va_copy(va2, va);\n    int len = vsnprintf(nullptr, 0, fmt, va);\n    mes->buffer.resize(len);\n    vsnprintf(&(mes->buffer[0]), len + 1, fmt, va2);\n    va_end(va2);\n\n    /*-------------------------------------------------*\\\n    | Fill in message information                       |\n    \\*-------------------------------------------------*/\n    mes->level          = level;\n    mes->filename       = filename;\n    mes->line           = line;\n    mes->counted_second = std::chrono::steady_clock::now() - base_clock;\n\n    /*-------------------------------------------------*\\\n    | If this is a dialog message, call the dialog show |\n    | callback                                          |\n    \\*-------------------------------------------------*/\n    if(level == LL_DIALOG)\n    {\n        for(size_t idx = 0; idx < dialog_show_callbacks.size(); idx++)\n        {\n            dialog_show_callbacks[idx](dialog_show_callback_args[idx], mes);\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | If the message is within the current verbosity,   |\n    | print it on the screen                            |\n    | TODO: Put the timestamp here                      |\n    \\*-------------------------------------------------*/\n    if(level <= verbosity || level == LL_DIALOG)\n    {\n        std::cout << mes->buffer;\n        if(print_source)\n        {\n            std::cout << \" [\" << mes->filename << \":\" << mes->line << \"]\";\n        }\n        std::cout << std::endl;\n    }\n\n    /*-------------------------------------------------*\\\n    | Add the message to the logfile queue              |\n    \\*-------------------------------------------------*/\n    temp_messages.push_back(mes);\n\n    if(log_console_enabled)\n    {\n        all_messages.push_back(mes);\n    }\n\n    /*-------------------------------------------------*\\\n    | Flush the queues                                  |\n    \\*-------------------------------------------------*/\n    _flush();\n}\n\nstd::vector<PLogMessage> LogManager::messages()\n{\n    return all_messages;\n}\n\nvoid LogManager::clearMessages()\n{\n    all_messages.clear();\n}\n\nvoid LogManager::append(const char* filename, int line, unsigned int level, const char* fmt, ...)\n{\n    va_list va;\n    va_start(va, fmt);\n\n    std::lock_guard<std::mutex> grd(entry_mutex);\n    _append(filename, line, level, fmt, va);\n\n    va_end(va);\n}\n\nvoid LogManager::setLoglevel(unsigned int level)\n{\n    /*-------------------------------------------------*\\\n    | Check that the new log level is valid, otherwise  |\n    | set it within the valid range                     |\n    \\*-------------------------------------------------*/\n    if(level > LL_TRACE)\n    {\n        level = LL_TRACE;\n    }\n\n    LOG_DEBUG(\"[LogManager] Loglevel set to %d\", level);\n\n    /*-------------------------------------------------*\\\n    | Set the new log level                             |\n    \\*-------------------------------------------------*/\n    loglevel = level;\n}\n\nvoid LogManager::setVerbosity(unsigned int level)\n{\n    /*-------------------------------------------------*\\\n    | Check that the new verbosity is valid, otherwise  |\n    | set it within the valid range                     |\n    \\*-------------------------------------------------*/\n\n    if(level > LL_TRACE)\n    {\n        level = LL_TRACE;\n    }\n\n    LOG_DEBUG(\"[LogManager] Verbosity set to %d\", level);\n\n    /*-------------------------------------------------*\\\n    | Set the new verbosity                             |\n    \\*-------------------------------------------------*/\n    verbosity = level;\n}\n\nvoid LogManager::setPrintSource(bool v)\n{\n    LOG_DEBUG(\"[LogManager] Source code location printouts were %s\", v ? \"enabled\" : \"disabled\");\n    print_source = v;\n}\n\nvoid LogManager::RegisterDialogShowCallback(LogDialogShowCallback callback, void* receiver)\n{\n    LOG_DEBUG(\"[LogManager] dialog show callback registered\");\n    dialog_show_callbacks.push_back(callback);\n    dialog_show_callback_args.push_back(receiver);\n}\n\nvoid LogManager::UnregisterDialogShowCallback(LogDialogShowCallback callback, void* receiver)\n{\n    for(size_t idx = 0; idx < dialog_show_callbacks.size(); idx++)\n    {\n        if(dialog_show_callbacks[idx] == callback && dialog_show_callback_args[idx] == receiver)\n        {\n            dialog_show_callbacks.erase(dialog_show_callbacks.begin() + idx);\n            dialog_show_callback_args.erase(dialog_show_callback_args.begin() + idx);\n        }\n    }\n}\n"
        },
        {
          "name": "LogManager.h",
          "type": "blob",
          "size": 4.90625,
          "content": "/*---------------------------------------------------------*\\\n| LogManager.h                                              |\n|                                                           |\n|   Manages log file and output to the console              |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#ifndef LOGMANAGER_H\n#define LOGMANAGER_H\n\n#include <fstream>\n#include <mutex>\n#include <vector>\n#include <queue>\n#include <memory>\n#include \"json.hpp\"\n#include \"filesystem.h\"\n\n/*-------------------------------------------------*\\\n| Common LOG strings                                |\n|   This may need to be in it's own .h file         |\n\\*-------------------------------------------------*/\n#define SMBUS_CHECK_DEVICE_MESSAGE_EN   \"[%s] Bus %02d is a motherboard and the subvendor matches the one for %s, looking for a device at 0x%02X\"\n#define SMBUS_CHECK_DEVICE_FAILURE_EN   \"[%s] Bus %02d is not a motherboard or the subvendor does not match the one for %s, skipping detection\"\n\n#define GPU_DETECT_MESSAGE              \"[%s] Found a device match at Bus %02d for Device 0x%04X and SubDevice 0x%04X: %s\"\n\nusing json = nlohmann::json;\n\nenum\n{\n    LL_FATAL,       // Critical unrecoverable errors that cause a generalized crash of a module or of the entire app\n    LL_ERROR,       // Local errors that abort an operation\n    LL_WARNING,     // Local errors that may cause an operation to have an undefined behavior or may have dangerous/unforeseen consequences\n    LL_INFO,        // Initialization messages, significant actions and follow-up information\n    LL_VERBOSE,     // Tracing of commands and performed actions, usually for debug purposes, comments on the higher priority messages\n    LL_DEBUG,       // Deep tracing, \"printf-style debugging\" alternative, for debug purposes. Such messages should be put all over the code instead of comments\n    LL_TRACE,\n    LL_DIALOG       // Log messages to be shown in a GUI dialog box\n};\n\nstruct LogMessage\n{\n    std::string buffer;\n    unsigned int level;\n    const char* filename;\n    int line;\n    std::chrono::duration<double> counted_second;\n    // int timestamp or float time_offset? TBD\n};\ntypedef std::shared_ptr<LogMessage> PLogMessage;\ntypedef void(*LogDialogShowCallback)(void*, PLogMessage);\n\nclass LogManager\n{\nprivate:\n    LogManager();\n    LogManager(const LogManager&) = delete;\n    LogManager(LogManager&&) = delete;\n    ~LogManager();\n    std::mutex entry_mutex;\n    std::mutex section_mutex;\n    std::ofstream log_stream;\n\n    std::vector<LogDialogShowCallback>  dialog_show_callbacks;\n    std::vector<void*>                  dialog_show_callback_args;\n\n    // A temporary log message storage to hold them until the stream opens\n    std::vector<PLogMessage> temp_messages;\n\n    // A log message storage that will be displayed in the app\n    std::vector<PLogMessage> all_messages;\n\n    // A flag that marks if the message source file name and line number should be printed on screen\n    bool print_source = false;\n\n    // Logfile max level\n    unsigned int loglevel = LL_INFO;\n    \n    // Verbosity (stdout) max level\n    unsigned int verbosity = LL_WARNING;\n\n    //Clock from LogManager creation\n    std::chrono::time_point<std::chrono::steady_clock> base_clock;\n\n    // A non-guarded append()\n    void _append(const char* filename, int line, unsigned int level, const char* fmt, va_list va);\n\n    // A non-guarded flush()\n    void _flush();\n\npublic:\n    static LogManager* get();\n    void configure(json config, const filesystem::path & defaultDir);\n    void flush();\n    void append(const char* filename, int line, unsigned int level, const char* fmt, ...);\n    void setLoglevel(unsigned int);\n    void setVerbosity(unsigned int);\n    void setPrintSource(bool);\n    void RegisterDialogShowCallback(LogDialogShowCallback callback, void* receiver);\n    void UnregisterDialogShowCallback(LogDialogShowCallback callback, void* receiver);\n    unsigned int getLoglevel();\n    unsigned int getVerbosity() {return verbosity;}\n    void clearMessages();\n    std::vector<PLogMessage> messages();\n\n    bool log_console_enabled;\n    bool log_file_enabled;\n    static const char* log_codes[];\n};\n\n#define LogAppend(level, ...)   LogManager::get()->append(__FILE__, __LINE__, level, __VA_ARGS__)\n#define LOG_FATAL(...)          LogAppend(LL_FATAL,     __VA_ARGS__)\n#define LOG_ERROR(...)          LogAppend(LL_ERROR,     __VA_ARGS__)\n#define LOG_WARNING(...)        LogAppend(LL_WARNING,   __VA_ARGS__)\n#define LOG_INFO(...)           LogAppend(LL_INFO,      __VA_ARGS__)\n#define LOG_VERBOSE(...)        LogAppend(LL_VERBOSE,   __VA_ARGS__)\n#define LOG_DEBUG(...)          LogAppend(LL_DEBUG,     __VA_ARGS__)\n#define LOG_TRACE(...)          LogAppend(LL_TRACE,     __VA_ARGS__)\n#define LOG_DIALOG(...)         LogAppend(LL_DIALOG,    __VA_ARGS__)\n\n#endif // LOGMANAGER_H\n"
        },
        {
          "name": "NetworkClient.cpp",
          "type": "blob",
          "size": 31.4794921875,
          "content": "/*---------------------------------------------------------*\\\n| NetworkClient.cpp                                         |\n|                                                           |\n|   OpenRGB SDK network client                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <cstring>\n#include \"NetworkClient.h\"\n#include \"RGBController_Network.h\"\n\n#ifdef _WIN32\n#include <Windows.h>\n#define MSG_NOSIGNAL 0\n#endif\n\n#ifdef __APPLE__\n#include <unistd.h>\n#endif\n\n#ifdef __linux__\n#include <unistd.h>\n#include <sys/select.h>\n#endif\n\nusing namespace std::chrono_literals;\n\nNetworkClient::NetworkClient(std::vector<RGBController *>& control) : controllers(control)\n{\n    port_ip                 = \"127.0.0.1\";\n    port_num                = OPENRGB_SDK_PORT;\n    client_sock             = -1;\n    server_connected        = false;\n    server_controller_count = 0;\n    change_in_progress      = false;\n\n    ListenThread            = NULL;\n    ConnectionThread        = NULL;\n}\n\nNetworkClient::~NetworkClient()\n{\n    StopClient();\n}\n\nvoid NetworkClient::ClearCallbacks()\n{\n    ClientInfoChangeCallbacks.clear();\n    ClientInfoChangeCallbackArgs.clear();\n}\n\nvoid NetworkClient::ClientInfoChanged()\n{\n    ClientInfoChangeMutex.lock();\n    ControllerListMutex.lock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    for(unsigned int callback_idx = 0; callback_idx < ClientInfoChangeCallbacks.size(); callback_idx++)\n    {\n        ClientInfoChangeCallbacks[callback_idx](ClientInfoChangeCallbackArgs[callback_idx]);\n    }\n\n    ControllerListMutex.unlock();\n    ClientInfoChangeMutex.unlock();\n}\n\nstd::string NetworkClient::GetIP()\n{\n    return port_ip;\n}\n\nunsigned short NetworkClient::GetPort()\n{\n    return port_num;\n}\n\nunsigned int NetworkClient::GetProtocolVersion()\n{\n    unsigned int protocol_version = 0;\n\n    if(server_protocol_version > OPENRGB_SDK_PROTOCOL_VERSION)\n    {\n        protocol_version = OPENRGB_SDK_PROTOCOL_VERSION;\n    }\n    else\n    {\n        protocol_version = server_protocol_version;\n    }\n\n    return(protocol_version);\n}\n\nbool NetworkClient::GetConnected()\n{\n    return(server_connected);\n}\n\nbool NetworkClient::GetOnline()\n{\n    return(server_connected && server_initialized);\n}\n\nvoid NetworkClient::RegisterClientInfoChangeCallback(NetClientCallback new_callback, void * new_callback_arg)\n{\n    ClientInfoChangeCallbacks.push_back(new_callback);\n    ClientInfoChangeCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid NetworkClient::SetIP(std::string new_ip)\n{\n    if(server_connected == false)\n    {\n        port_ip = new_ip;\n    }\n}\n\nvoid NetworkClient::SetName(std::string new_name)\n{\n    client_name = new_name;\n\n    if(server_connected == true)\n    {\n        SendData_ClientString();\n    }\n}\n\nvoid NetworkClient::SetPort(unsigned short new_port)\n{\n    if(server_connected == false)\n    {\n        port_num = new_port;\n    }\n}\n\nvoid NetworkClient::StartClient()\n{\n    /*---------------------------------------------------------*\\\n    | Start a TCP server and launch threads                     |\n    \\*---------------------------------------------------------*/\n    char port_str[6];\n    snprintf(port_str, 6, \"%d\", port_num);\n\n    port.tcp_client(port_ip.c_str(), port_str);\n\n    client_active = true;\n\n    /*---------------------------------------------------------*\\\n    | Start the connection thread                               |\n    \\*---------------------------------------------------------*/\n    ConnectionThread = new std::thread(&NetworkClient::ConnectionThreadFunction, this);\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkClient::StopClient()\n{\n    /*---------------------------------------------------------*\\\n    | Disconnect the server and set it as inactive              |\n    \\*---------------------------------------------------------*/\n    server_connected = false;\n    client_active    = false;\n\n    /*---------------------------------------------------------*\\\n    | Shut down and close the client socket                     |\n    \\*---------------------------------------------------------*/\n    if(server_connected)\n    {\n        shutdown(client_sock, SD_RECEIVE);\n        closesocket(client_sock);\n    }\n\n    client_active    = false;\n    server_connected = false;\n\n    /*---------------------------------------------------------*\\\n    | Close the listen thread                                   |\n    \\*---------------------------------------------------------*/\n    if(ListenThread)\n    {\n        ListenThread->join();\n        delete ListenThread;\n        ListenThread = nullptr;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Close the connection thread                               |\n    \\*---------------------------------------------------------*/\n    if(ConnectionThread)\n    {\n        connection_cv.notify_all();\n        ConnectionThread->join();\n        delete ConnectionThread;\n        ConnectionThread = nullptr;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkClient::ConnectionThreadFunction()\n{\n    unsigned int requested_controllers;\n\n    std::unique_lock<std::mutex> lock(connection_mutex);\n\n    /*---------------------------------------------------------*\\\n    | This thread manages the connection to the server          |\n    \\*---------------------------------------------------------*/\n    while(client_active == true)\n    {\n        if(server_connected == false)\n        {\n            /*---------------------------------------------------------*\\\n            | Connect to server and reconnect if the connection is lost |\n            \\*---------------------------------------------------------*/\n            server_initialized = false;\n\n            /*---------------------------------------------------------*\\\n            | Try to connect to server                                  |\n            \\*---------------------------------------------------------*/\n            if(port.tcp_client_connect() == true)\n            {\n                client_sock = port.sock;\n                printf( \"Connected to server\\n\" );\n\n                /*---------------------------------------------------------*\\\n                | Server is now connected                                   |\n                \\*---------------------------------------------------------*/\n                server_connected = true;\n\n                /*---------------------------------------------------------*\\\n                | Start the listener thread                                 |\n                \\*---------------------------------------------------------*/\n                ListenThread = new std::thread(&NetworkClient::ListenThreadFunction, this);\n\n                /*---------------------------------------------------------*\\\n                | Server is not initialized                                 |\n                \\*---------------------------------------------------------*/\n                server_initialized = false;\n\n                /*---------------------------------------------------------*\\\n                | Client info has changed, call the callbacks               |\n                \\*---------------------------------------------------------*/\n                ClientInfoChanged();\n            }\n            else\n            {\n                printf( \"Connection attempt failed\\n\" );\n            }\n        }\n\n        /*-------------------------------------------------------------*\\\n        | Double-check client_active as it could have changed           |\n        \\*-------------------------------------------------------------*/\n        if(client_active && server_initialized == false && server_connected == true)\n        {\n            unsigned int timeout_counter     = 0;\n            requested_controllers            = 0;\n            server_controller_count          = 0;\n            server_controller_count_received = false;\n            server_protocol_version_received = false;\n\n            /*---------------------------------------------------------*\\\n            | Wait for server to connect                                |\n            \\*---------------------------------------------------------*/\n            connection_cv.wait_for(lock, 100ms);\n            if(!client_active)\n            {\n                break;\n            }\n\n            /*---------------------------------------------------------*\\\n            | Request protocol version                                  |\n            \\*---------------------------------------------------------*/\n            SendRequest_ProtocolVersion();\n\n            /*---------------------------------------------------------*\\\n            | Wait up to 1s for protocol version reply                  |\n            \\*---------------------------------------------------------*/\n            while(!server_protocol_version_received)\n            {\n                connection_cv.wait_for(lock, 5ms);\n                if(!client_active)\n                {\n                    break;\n                }\n\n                timeout_counter++;\n\n                /*---------------------------------------------------------*\\\n                | If no protocol version received within 1s, assume the     |\n                | server doesn't support protocol versioning and use        |\n                | protocol version 0                                        |\n                \\*---------------------------------------------------------*/\n                if(timeout_counter > 200)\n                {\n                    server_protocol_version          = 0;\n                    server_protocol_version_received = true;\n                }\n            }\n\n            /*---------------------------------------------------------*\\\n            | Once server is connected, send client string              |\n            \\*---------------------------------------------------------*/\n            SendData_ClientString();\n\n            /*---------------------------------------------------------*\\\n            | Request number of controllers                             |\n            \\*---------------------------------------------------------*/\n            SendRequest_ControllerCount();\n\n            /*---------------------------------------------------------*\\\n            | Wait for server controller count                          |\n            \\*---------------------------------------------------------*/\n            while(!server_controller_count_received)\n            {\n                connection_cv.wait_for(lock, 5ms);\n                if(!client_active)\n                {\n                    break;\n                }\n            }\n\n            printf(\"Client: Received controller count from server: %d\\r\\n\", server_controller_count);\n\n            /*---------------------------------------------------------*\\\n            | Once count is received, request controllers               |\n            \\*---------------------------------------------------------*/\n            while(requested_controllers < server_controller_count)\n            {\n                printf(\"Client: Requesting controller %d\\r\\n\", requested_controllers);\n\n                controller_data_received = false;\n                SendRequest_ControllerData(requested_controllers);\n\n                /*---------------------------------------------------------*\\\n                | Wait until controller is received                         |\n                \\*---------------------------------------------------------*/\n                while(controller_data_received == false)\n                {\n                    connection_cv.wait_for(lock, 5ms);\n                    if(!client_active)\n                    {\n                        break;\n                    }\n                }\n\n                requested_controllers++;\n            }\n\n            ControllerListMutex.lock();\n\n            /*---------------------------------------------------------*\\\n            | All controllers received, add them to master list         |\n            \\*---------------------------------------------------------*/\n            printf(\"Client: All controllers received, adding them to master list\\r\\n\");\n            for(std::size_t controller_idx = 0; controller_idx < server_controllers.size(); controller_idx++)\n            {\n                controllers.push_back(server_controllers[controller_idx]);\n            }\n\n            ControllerListMutex.unlock();\n\n            server_initialized = true;\n\n            /*---------------------------------------------------------*\\\n            | Client info has changed, call the callbacks               |\n            \\*---------------------------------------------------------*/\n            ClientInfoChanged();\n        }\n\n        /*---------------------------------------------------------*\\\n        | Wait 1 sec or until the thread is requested to stop       |\n        \\*---------------------------------------------------------*/\n        connection_cv.wait_for(lock, 1s);\n    }\n}\n\nint NetworkClient::recv_select(SOCKET s, char *buf, int len, int flags)\n{\n    fd_set              set;\n    struct timeval      timeout;\n\n    while(1)\n    {\n        timeout.tv_sec      = 5;\n        timeout.tv_usec     = 0;\n\n        FD_ZERO(&set);\n        FD_SET(s, &set);\n\n        int rv = select((int)s + 1, &set, NULL, NULL, &timeout);\n\n        if(rv == SOCKET_ERROR || server_connected == false)\n        {\n            return 0;\n        }\n        else if(rv == 0)\n        {\n            continue;\n        }\n        else\n        {\n            return(recv(s, buf, len, flags));\n        }\n\n    }\n}\n\nvoid NetworkClient::ListenThreadFunction()\n{\n    printf(\"Network client listener started\\n\");\n\n    /*---------------------------------------------------------*\\\n    | This thread handles messages received from the server     |\n    \\*---------------------------------------------------------*/\n    while(server_connected == true)\n    {\n        NetPacketHeader header;\n        int             bytes_read  = 0;\n        char *          data        = NULL;\n\n        for(unsigned int i = 0; i < 4; i++)\n        {\n            /*---------------------------------------------------------*\\\n            | Read byte of magic                                        |\n            \\*---------------------------------------------------------*/\n            bytes_read = recv_select(client_sock, &header.pkt_magic[i], 1, 0);\n\n            if(bytes_read <= 0)\n            {\n                goto listen_done;\n            }\n\n            /*---------------------------------------------------------*\\\n            | Test characters of magic \"ORGB\"                           |\n            \\*---------------------------------------------------------*/\n            if(header.pkt_magic[i] != openrgb_sdk_magic[i])\n            {\n                continue;\n            }\n        }\n\n        /*---------------------------------------------------------*\\\n        | If we get to this point, the magic is correct.  Read the  |\n        | rest of the header                                        |\n        \\*---------------------------------------------------------*/\n        bytes_read = 0;\n        do\n        {\n            int tmp_bytes_read = 0;\n\n            tmp_bytes_read = recv_select(client_sock, (char *)&header.pkt_dev_idx + bytes_read, sizeof(header) - sizeof(header.pkt_magic) - bytes_read, 0);\n\n            bytes_read += tmp_bytes_read;\n\n            if(tmp_bytes_read <= 0)\n            {\n                goto listen_done;\n            }\n\n        } while(bytes_read != sizeof(header) - sizeof(header.pkt_magic));\n\n        /*---------------------------------------------------------*\\\n        | Header received, now receive the data                     |\n        \\*---------------------------------------------------------*/\n        if(header.pkt_size > 0)\n        {\n            bytes_read = 0;\n\n            data = new char[header.pkt_size];\n\n            do\n            {\n                int tmp_bytes_read = 0;\n\n                tmp_bytes_read = recv_select(client_sock, &data[(unsigned int)bytes_read], header.pkt_size - bytes_read, 0);\n\n                if(tmp_bytes_read <= 0)\n                {\n                    goto listen_done;\n                }\n                bytes_read += tmp_bytes_read;\n\n            } while ((unsigned int)bytes_read < header.pkt_size);\n        }\n\n        /*---------------------------------------------------------*\\\n        | Entire request received, select functionality based on    |\n        | request ID                                                |\n        \\*---------------------------------------------------------*/\n        switch(header.pkt_id)\n        {\n            case NET_PACKET_ID_REQUEST_CONTROLLER_COUNT:\n                ProcessReply_ControllerCount(header.pkt_size, data);\n                break;\n\n            case NET_PACKET_ID_REQUEST_CONTROLLER_DATA:\n                ProcessReply_ControllerData(header.pkt_size, data, header.pkt_dev_idx);\n                break;\n\n            case NET_PACKET_ID_REQUEST_PROTOCOL_VERSION:\n                ProcessReply_ProtocolVersion(header.pkt_size, data);\n                break;\n\n            case NET_PACKET_ID_DEVICE_LIST_UPDATED:\n                ProcessRequest_DeviceListChanged();\n                break;\n        }\n\n        delete[] data;\n    }\n\nlisten_done:\n    printf( \"Client socket has been closed\");\n    server_initialized = false;\n    server_connected = false;\n\n    ControllerListMutex.lock();\n\n    for(size_t server_controller_idx = 0; server_controller_idx < server_controllers.size(); server_controller_idx++)\n    {\n        for(size_t controller_idx = 0; controller_idx < controllers.size(); controller_idx++)\n        {\n            if(controllers[controller_idx] == server_controllers[server_controller_idx])\n            {\n                controllers.erase(controllers.begin() + controller_idx);\n                break;\n            }\n        }\n    }\n\n    std::vector<RGBController *> server_controllers_copy = server_controllers;\n\n    server_controllers.clear();\n\n    for(size_t server_controller_idx = 0; server_controller_idx < server_controllers_copy.size(); server_controller_idx++)\n    {\n        delete server_controllers_copy[server_controller_idx];\n    }\n\n    ControllerListMutex.unlock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkClient::WaitOnControllerData()\n{\n    for(int i = 0; i < 1000; i++)\n    {\n        if(controller_data_received)\n        {\n            break;\n        }\n        std::this_thread::sleep_for(1ms);\n    }\n\n    return;\n}\n\nvoid NetworkClient::ProcessReply_ControllerCount(unsigned int data_size, char * data)\n{\n    if(data_size == sizeof(unsigned int))\n    {\n        memcpy(&server_controller_count, data, sizeof(unsigned int));\n        server_controller_count_received = true;\n    }\n}\n\nvoid NetworkClient::ProcessReply_ControllerData(unsigned int data_size, char * data, unsigned int dev_idx)\n{\n    /*---------------------------------------------------------*\\\n    | Verify the controller description size (first 4 bytes of  |\n    | data) matches the packet size in the header               |\n    \\*---------------------------------------------------------*/\n    if(data_size == *((unsigned int*)data))\n    {\n        RGBController_Network * new_controller   = new RGBController_Network(this, dev_idx);\n\n        new_controller->ReadDeviceDescription((unsigned char *)data, GetProtocolVersion());\n\n        ControllerListMutex.lock();\n\n        if(dev_idx >= server_controllers.size())\n        {\n            server_controllers.push_back(new_controller);\n        }\n        else\n        {\n            server_controllers[dev_idx]->active_mode = new_controller->active_mode;\n            server_controllers[dev_idx]->leds.clear();\n            server_controllers[dev_idx]->leds        = new_controller->leds;\n            server_controllers[dev_idx]->colors.clear();\n            server_controllers[dev_idx]->colors      = new_controller->colors;\n            for(unsigned int i = 0; i < server_controllers[dev_idx]->zones.size(); i++)\n            {\n                server_controllers[dev_idx]->zones[i].leds_count = new_controller->zones[i].leds_count;\n            }\n            server_controllers[dev_idx]->SetupColors();\n\n            delete new_controller;\n        }\n\n        ControllerListMutex.unlock();\n\n        controller_data_received = true;\n    }\n}\n\nvoid NetworkClient::ProcessReply_ProtocolVersion(unsigned int data_size, char * data)\n{\n    if(data_size == sizeof(unsigned int))\n    {\n        memcpy(&server_protocol_version, data, sizeof(unsigned int));\n        server_protocol_version_received = true;\n    }\n}\n\nvoid NetworkClient::ProcessRequest_DeviceListChanged()\n{\n    change_in_progress = true;\n\n    ControllerListMutex.lock();\n\n    for(size_t server_controller_idx = 0; server_controller_idx < server_controllers.size(); server_controller_idx++)\n    {\n        for(size_t controller_idx = 0; controller_idx < controllers.size(); controller_idx++)\n        {\n            if(controllers[controller_idx] == server_controllers[server_controller_idx])\n            {\n                controllers.erase(controllers.begin() + controller_idx);\n                break;\n            }\n        }\n    }\n\n    std::vector<RGBController *> server_controllers_copy = server_controllers;\n\n    server_controllers.clear();\n\n    for(size_t server_controller_idx = 0; server_controller_idx < server_controllers_copy.size(); server_controller_idx++)\n    {\n        delete server_controllers_copy[server_controller_idx];\n    }\n\n    ControllerListMutex.unlock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n\n    /*---------------------------------------------------------*\\\n    | Mark server as uninitialized and delete the list          |\n    \\*---------------------------------------------------------*/\n    server_initialized = false;\n\n    change_in_progress = false;\n}\n\nvoid NetworkClient::SendData_ClientString()\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_SET_CLIENT_NAME, (unsigned int)strlen(client_name.c_str()) + 1);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&reply_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)client_name.c_str(), reply_hdr.pkt_size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_ControllerCount()\n{\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, 0, NET_PACKET_ID_REQUEST_CONTROLLER_COUNT, 0);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_ControllerData(unsigned int dev_idx)\n{\n    NetPacketHeader request_hdr;\n    unsigned int    protocol_version;\n\n    controller_data_received = false;\n\n    memcpy(request_hdr.pkt_magic, openrgb_sdk_magic, sizeof(openrgb_sdk_magic));\n\n    request_hdr.pkt_dev_idx  = dev_idx;\n    request_hdr.pkt_id       = NET_PACKET_ID_REQUEST_CONTROLLER_DATA;\n\n    if(server_protocol_version == 0)\n    {\n        request_hdr.pkt_size     = 0;\n\n        send_in_progress.lock();\n        send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n        send_in_progress.unlock();\n    }\n    else\n    {\n        request_hdr.pkt_size     = sizeof(unsigned int);\n\n        /*-------------------------------------------------------------*\\\n        | Limit the protocol version to the highest supported by both   |\n        | the client and the server.                                    |\n        \\*-------------------------------------------------------------*/\n        if(server_protocol_version > OPENRGB_SDK_PROTOCOL_VERSION)\n        {\n            protocol_version = OPENRGB_SDK_PROTOCOL_VERSION;\n        }\n        else\n        {\n            protocol_version = server_protocol_version;\n        }\n\n        send_in_progress.lock();\n        send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n        send(client_sock, (char *)&protocol_version, sizeof(unsigned int), MSG_NOSIGNAL);\n        send_in_progress.unlock();\n    }\n}\n\nvoid NetworkClient::SendRequest_ProtocolVersion()\n{\n    NetPacketHeader request_hdr;\n    unsigned int    request_data;\n\n    InitNetPacketHeader(&request_hdr, 0, NET_PACKET_ID_REQUEST_PROTOCOL_VERSION, sizeof(unsigned int));\n\n    request_data             = OPENRGB_SDK_PROTOCOL_VERSION;\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)&request_data, sizeof(unsigned int), MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_ResizeZone(unsigned int dev_idx, int zone, int new_size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n    int             request_data[2];\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_RESIZEZONE, sizeof(request_data));\n\n    request_data[0]          = zone;\n    request_data[1]          = new_size;\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)&request_data, sizeof(request_data), MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_UpdateLEDs(unsigned int dev_idx, unsigned char * data, unsigned int size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_UPDATELEDS, size);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)data, size, 0);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_UpdateZoneLEDs(unsigned int dev_idx, unsigned char * data, unsigned int size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_UPDATEZONELEDS, size);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)data, size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_UpdateSingleLED(unsigned int dev_idx, unsigned char * data, unsigned int size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_UPDATESINGLELED, size);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)data, size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_SetCustomMode(unsigned int dev_idx)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_SETCUSTOMMODE, 0);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_UpdateMode(unsigned int dev_idx, unsigned char * data, unsigned int size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_UPDATEMODE, size);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)data, size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_RGBController_SaveMode(unsigned int dev_idx, unsigned char * data, unsigned int size)\n{\n    if(change_in_progress)\n    {\n        return;\n    }\n\n    NetPacketHeader request_hdr;\n\n    InitNetPacketHeader(&request_hdr, dev_idx, NET_PACKET_ID_RGBCONTROLLER_SAVEMODE, size);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&request_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)data, size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_LoadProfile(std::string profile_name)\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_LOAD_PROFILE, (unsigned int)strlen(profile_name.c_str()) + 1);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&reply_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)profile_name.c_str(), reply_hdr.pkt_size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_SaveProfile(std::string profile_name)\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_SAVE_PROFILE, (unsigned int)strlen(profile_name.c_str()) + 1);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&reply_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)profile_name.c_str(), reply_hdr.pkt_size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_DeleteProfile(std::string profile_name)\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_DELETE_PROFILE, (unsigned int)strlen(profile_name.c_str()) + 1);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&reply_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send(client_sock, (char *)profile_name.c_str(), reply_hdr.pkt_size, MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nvoid NetworkClient::SendRequest_GetProfileList()\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_PROFILE_LIST, 0);\n\n    send_in_progress.lock();\n    send(client_sock, (char *)&reply_hdr, sizeof(NetPacketHeader), MSG_NOSIGNAL);\n    send_in_progress.unlock();\n}\n\nstd::vector<std::string> * NetworkClient::ProcessReply_ProfileList(unsigned int data_size, char * data)\n{\n    std::vector<std::string> * profile_list;\n\n    if(data_size > 0)\n    {\n        profile_list = new std::vector<std::string>(data_size);\n\n        /*---------------------------------------------------------*\\\n        | Skip 4 first bytes (data length, unused)                  |\n        \\*---------------------------------------------------------*/\n        unsigned short data_ptr = sizeof(unsigned short);\n        unsigned short num_profile;\n\n        memcpy(&num_profile, data, sizeof(unsigned short));\n        data_ptr += sizeof(unsigned short);\n\n        for(int i = 0; i < num_profile; i++)\n        {\n            unsigned short name_len;\n\n            memcpy(&name_len, data, sizeof(unsigned short));\n            data_ptr += sizeof(unsigned short);\n\n            std::string profile_name(data, name_len);\n            profile_list->push_back(profile_name);\n\n            data_ptr += name_len;\n        }\n\n        server_controller_count_received = true;\n    }\n    else\n    {\n        profile_list = new std::vector<std::string>(0);\n    }\n\n    return profile_list;\n}\n"
        },
        {
          "name": "NetworkClient.h",
          "type": "blob",
          "size": 4.4013671875,
          "content": "/*---------------------------------------------------------*\\\n| NetworkClient.h                                           |\n|                                                           |\n|   OpenRGB SDK network client                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <mutex>\n#include <thread>\n#include <condition_variable>\n#include \"RGBController.h\"\n#include \"NetworkProtocol.h\"\n#include \"net_port.h\"\n\ntypedef void (*NetClientCallback)(void *);\n\nclass NetworkClient\n{\npublic:\n    NetworkClient(std::vector<RGBController *>& control);\n    ~NetworkClient();\n\n    void            ClientInfoChanged();\n\n    bool            GetConnected();\n    std::string     GetIP();\n    unsigned short  GetPort();\n    unsigned int    GetProtocolVersion();\n    bool            GetOnline();\n\n    void            ClearCallbacks();\n    void            RegisterClientInfoChangeCallback(NetClientCallback new_callback, void * new_callback_arg);\n\n    void            SetIP(std::string new_ip);\n    void            SetName(std::string new_name);\n    void            SetPort(unsigned short new_port);\n\n    void            StartClient();\n    void            StopClient();\n\n    void            ConnectionThreadFunction();\n    void            ListenThreadFunction();\n\n    void            WaitOnControllerData();\n    \n    void        ProcessReply_ControllerCount(unsigned int data_size, char * data);\n    void        ProcessReply_ControllerData(unsigned int data_size, char * data, unsigned int dev_idx);\n    void        ProcessReply_ProtocolVersion(unsigned int data_size, char * data);\n\n    void        ProcessRequest_DeviceListChanged();\n\n    void        SendData_ClientString();\n\n    void        SendRequest_ControllerCount();\n    void        SendRequest_ControllerData(unsigned int dev_idx);\n    void        SendRequest_ProtocolVersion();\n\n    void        SendRequest_RGBController_ResizeZone(unsigned int dev_idx, int zone, int new_size);\n\n    void        SendRequest_RGBController_UpdateLEDs(unsigned int dev_idx, unsigned char * data, unsigned int size);\n    void        SendRequest_RGBController_UpdateZoneLEDs(unsigned int dev_idx, unsigned char * data, unsigned int size);\n    void        SendRequest_RGBController_UpdateSingleLED(unsigned int dev_idx, unsigned char * data, unsigned int size);\n\n    void        SendRequest_RGBController_SetCustomMode(unsigned int dev_idx);\n\n    void        SendRequest_RGBController_UpdateMode(unsigned int dev_idx, unsigned char * data, unsigned int size);\n    void        SendRequest_RGBController_SaveMode(unsigned int dev_idx, unsigned char * data, unsigned int size);\n\n\n    std::vector<std::string> * ProcessReply_ProfileList(unsigned int data_size, char * data);\n\n    void        SendRequest_GetProfileList();\n    void        SendRequest_LoadProfile(std::string profile_name);\n    void        SendRequest_SaveProfile(std::string profile_name);\n    void        SendRequest_DeleteProfile(std::string profile_name);\n\n    std::vector<RGBController *>  server_controllers;\n\n    std::mutex                          ControllerListMutex;\n\nprotected:\n    std::vector<RGBController *>& controllers;\n\n\nprivate:\n    SOCKET          client_sock;\n    std::string     client_name;\n    net_port        port;\n    std::string     port_ip;\n    unsigned short  port_num;\n    std::atomic<bool> client_active;\n    bool            controller_data_received;\n    bool            server_connected;\n    bool            server_initialized;\n    unsigned int    server_controller_count;\n    bool            server_controller_count_received;\n    unsigned int    server_protocol_version;\n    bool            server_protocol_version_received;\n    bool            change_in_progress;\n    std::mutex      send_in_progress;\n\n    std::mutex      connection_mutex;\n    std::condition_variable connection_cv;\n\n    std::thread *   ConnectionThread;\n    std::thread *   ListenThread;\n\n    std::mutex                          ClientInfoChangeMutex;\n    std::vector<NetClientCallback>      ClientInfoChangeCallbacks;\n    std::vector<void *>                 ClientInfoChangeCallbackArgs;\n\n    int recv_select(SOCKET s, char *buf, int len, int flags);\n};\n"
        },
        {
          "name": "NetworkProtocol.cpp",
          "type": "blob",
          "size": 1.263671875,
          "content": "/*---------------------------------------------------------*\\\n| NetworkProtocol.cpp                                       |\n|                                                           |\n|   OpenRGB SDK network protocol                            |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <cstring>\n#include \"NetworkProtocol.h\"\n\n/*-----------------------------------------------------*\\\n| OpenRGB SDK Magic Value \"ORGB\"                        |\n\\*-----------------------------------------------------*/\nconst char openrgb_sdk_magic[OPENRGB_SDK_MAGIC_SIZE] = { 'O', 'R', 'G', 'B' };\n\nvoid InitNetPacketHeader\n    (\n    NetPacketHeader *   pkt_hdr,\n    unsigned int        pkt_dev_idx,\n    unsigned int        pkt_id,\n    unsigned int        pkt_size\n    )\n{\n    memcpy(pkt_hdr->pkt_magic, openrgb_sdk_magic, sizeof(openrgb_sdk_magic));\n\n    pkt_hdr->pkt_dev_idx  = pkt_dev_idx;\n    pkt_hdr->pkt_id       = pkt_id;\n    pkt_hdr->pkt_size     = pkt_size;\n}\n"
        },
        {
          "name": "NetworkProtocol.h",
          "type": "blob",
          "size": 5.4052734375,
          "content": "/*---------------------------------------------------------*\\\n| NetworkProtocol.h                                         |\n|                                                           |\n|   OpenRGB SDK network protocol                            |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n/*---------------------------------------------------------------------*\\\n| OpenRGB SDK protocol version                                          |\n|                                                                       |\n|   0:      Initial (unversioned) protocol                              |\n|   1:      Add versioning, vendor string (Release 0.5)                 |\n|   2:      Add profile controls (Release 0.6)                          |\n|   3:      Add brightness field to modes (Release 0.7)                 |\n|   4:      Add segments field to zones, network plugins (Release 0.9)  |\n\\*---------------------------------------------------------------------*/\n#define OPENRGB_SDK_PROTOCOL_VERSION    4\n\n/*-----------------------------------------------------*\\\n| Default Interface to bind to.                         |\n\\*-----------------------------------------------------*/\n#define OPENRGB_SDK_HOST \"0.0.0.0\"\n\n/*-----------------------------------------------------*\\\n| Default OpenRGB SDK port is 6742                      |\n| This is \"ORGB\" on a phone keypad                      |\n\\*-----------------------------------------------------*/\n#define OPENRGB_SDK_PORT 6742\n\n/*-----------------------------------------------------*\\\n| OpenRGB SDK Magic Value \"ORGB\"                        |\n\\*-----------------------------------------------------*/\n#define OPENRGB_SDK_MAGIC_SIZE 4\nextern const char openrgb_sdk_magic[OPENRGB_SDK_MAGIC_SIZE];\n\ntypedef struct NetPacketHeader\n{\n    char                pkt_magic[4];               /* Magic value \"ORGB\" identifies beginning of packet    */\n    unsigned int        pkt_dev_idx;                /* Device index                                         */\n    unsigned int        pkt_id;                     /* Packet ID                                            */\n    unsigned int        pkt_size;                   /* Packet size                                          */\n} NetPacketHeader;\n\nenum\n{\n    /*----------------------------------------------------------------------------------------------------------*\\\n    | Network requests                                                                                           |\n    \\*----------------------------------------------------------------------------------------------------------*/\n    NET_PACKET_ID_REQUEST_CONTROLLER_COUNT      = 0,    /* Request RGBController device count from server       */\n    NET_PACKET_ID_REQUEST_CONTROLLER_DATA       = 1,    /* Request RGBController data block                     */\n\n    NET_PACKET_ID_REQUEST_PROTOCOL_VERSION      = 40,   /* Request OpenRGB SDK protocol version from server     */\n\n    NET_PACKET_ID_SET_CLIENT_NAME               = 50,   /* Send client name string to server                    */\n\n    NET_PACKET_ID_DEVICE_LIST_UPDATED           = 100,  /* Indicate to clients that device list has updated     */\n\n    NET_PACKET_ID_REQUEST_PROFILE_LIST          = 150,  /* Request profile list                                 */\n    NET_PACKET_ID_REQUEST_SAVE_PROFILE          = 151,  /* Save current configuration in a new profile          */\n    NET_PACKET_ID_REQUEST_LOAD_PROFILE          = 152,  /* Load a given profile                                 */\n    NET_PACKET_ID_REQUEST_DELETE_PROFILE        = 153,  /* Delete a given profile                               */\n\n    NET_PACKET_ID_REQUEST_PLUGIN_LIST           = 200,  /* Request list of plugins                              */\n    NET_PACKET_ID_PLUGIN_SPECIFIC               = 201,  /* Interact with a plugin                               */\n\n    /*----------------------------------------------------------------------------------------------------------*\\\n    | RGBController class functions                                                                              |\n    \\*----------------------------------------------------------------------------------------------------------*/\n    NET_PACKET_ID_RGBCONTROLLER_RESIZEZONE      = 1000, /* RGBController::ResizeZone()                          */\n\n    NET_PACKET_ID_RGBCONTROLLER_UPDATELEDS      = 1050, /* RGBController::UpdateLEDs()                          */\n    NET_PACKET_ID_RGBCONTROLLER_UPDATEZONELEDS  = 1051, /* RGBController::UpdateZoneLEDs()                      */\n    NET_PACKET_ID_RGBCONTROLLER_UPDATESINGLELED = 1052, /* RGBController::UpdateSingleLED()                     */\n\n    NET_PACKET_ID_RGBCONTROLLER_SETCUSTOMMODE   = 1100, /* RGBController::SetCustomMode()                       */\n    NET_PACKET_ID_RGBCONTROLLER_UPDATEMODE      = 1101, /* RGBController::UpdateMode()                          */\n    NET_PACKET_ID_RGBCONTROLLER_SAVEMODE        = 1102, /* RGBController::SaveMode()                            */\n};\n\nvoid InitNetPacketHeader\n    (\n    NetPacketHeader *   pkt_hdr,\n    unsigned int        pkt_dev_idx,\n    unsigned int        pkt_id,\n    unsigned int        pkt_size\n    );\n"
        },
        {
          "name": "NetworkServer.cpp",
          "type": "blob",
          "size": 41.78515625,
          "content": "/*---------------------------------------------------------*\\\n| NetworkServer.cpp                                         |\n|                                                           |\n|   OpenRGB SDK network server                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <cstring>\n#include \"NetworkServer.h\"\n#include \"LogManager.h\"\n\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n\nconst char yes = 1;\n\n#ifdef WIN32\n#include <Windows.h>\n#else\n#include <unistd.h>\n#endif\n\nusing namespace std::chrono_literals;\n\nNetworkClientInfo::NetworkClientInfo()\n{\n    client_string           = \"Client\";\n    client_ip               = OPENRGB_SDK_HOST;\n    client_sock             = INVALID_SOCKET;\n    client_listen_thread    = nullptr;\n    client_protocol_version = 0;\n}\n\nNetworkClientInfo::~NetworkClientInfo()\n{\n    if(client_sock != INVALID_SOCKET)\n    {\n        LOG_INFO(\"[NetworkServer] Closing server connection: %s\", client_ip.c_str());\n        delete client_listen_thread;\n        shutdown(client_sock, SD_RECEIVE);\n        closesocket(client_sock);\n    }\n}\n\nNetworkServer::NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n{\n    host                        = OPENRGB_SDK_HOST;\n    port_num                    = OPENRGB_SDK_PORT;\n    server_online               = false;\n    server_listening            = false;\n    legacy_workaround_enabled   = false;\n\n    for(int i = 0; i < MAXSOCK; i++)\n    {\n        ConnectionThread[i] = nullptr;\n    }\n\n    profile_manager  = nullptr;\n}\n\nNetworkServer::~NetworkServer()\n{\n    StopServer();\n}\n\nvoid NetworkServer::ClientInfoChanged()\n{\n    ClientInfoChangeMutex.lock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    for(unsigned int callback_idx = 0; callback_idx < ClientInfoChangeCallbacks.size(); callback_idx++)\n    {\n        ClientInfoChangeCallbacks[callback_idx](ClientInfoChangeCallbackArgs[callback_idx]);\n    }\n\n    ClientInfoChangeMutex.unlock();\n}\n\nvoid NetworkServer::DeviceListChanged()\n{\n    /*---------------------------------------------------------*\\\n    | Indicate to the clients that the controller list has      |\n    | changed                                                   |\n    \\*---------------------------------------------------------*/\n    for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n    {\n        SendRequest_DeviceListChanged(ServerClients[client_idx]->client_sock);\n    }\n}\n\nvoid NetworkServer::ServerListeningChanged()\n{\n    ServerListeningChangeMutex.lock();\n\n    /*---------------------------------------------------------*\\\n    | Server state has changed, call the callbacks              |\n    \\*---------------------------------------------------------*/\n    for(unsigned int callback_idx = 0; callback_idx < ServerListeningChangeCallbacks.size(); callback_idx++)\n    {\n        ServerListeningChangeCallbacks[callback_idx](ServerListeningChangeCallbackArgs[callback_idx]);\n    }\n\n    ServerListeningChangeMutex.unlock();\n}\n\nstd::string NetworkServer::GetHost()\n{\n    return host;\n}\n\nunsigned short NetworkServer::GetPort()\n{\n    return port_num;\n}\n\nbool NetworkServer::GetOnline()\n{\n    return server_online;\n}\n\nbool NetworkServer::GetListening()\n{\n    return server_listening;\n}\n\nunsigned int NetworkServer::GetNumClients()\n{\n    return (unsigned int)ServerClients.size();\n}\n\nconst char * NetworkServer::GetClientString(unsigned int client_num)\n{\n    const char * result;\n\n    ServerClientsMutex.lock();\n\n    if(client_num < ServerClients.size())\n    {\n        result = ServerClients[client_num]->client_string.c_str();\n    }\n    else\n    {\n        result = \"\";\n    }\n\n    ServerClientsMutex.unlock();\n\n    return result;\n}\n\nconst char * NetworkServer::GetClientIP(unsigned int client_num)\n{\n    const char * result;\n\n    ServerClientsMutex.lock();\n\n    if(client_num < ServerClients.size())\n    {\n        result = ServerClients[client_num]->client_ip.c_str();\n    }\n    else\n    {\n        result = \"\";\n    }\n\n    ServerClientsMutex.unlock();\n\n    return result;\n}\n\nunsigned int NetworkServer::GetClientProtocolVersion(unsigned int client_num)\n{\n    unsigned int result;\n\n    ServerClientsMutex.lock();\n\n    if(client_num < ServerClients.size())\n    {\n        result = ServerClients[client_num]->client_protocol_version;\n    }\n    else\n    {\n        result = 0;\n    }\n\n    ServerClientsMutex.unlock();\n\n    return result;\n}\n\nvoid NetworkServer::RegisterClientInfoChangeCallback(NetServerCallback new_callback, void * new_callback_arg)\n{\n    ClientInfoChangeCallbacks.push_back(new_callback);\n    ClientInfoChangeCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid NetworkServer::RegisterServerListeningChangeCallback(NetServerCallback new_callback, void * new_callback_arg)\n{\n    ServerListeningChangeCallbacks.push_back(new_callback);\n    ServerListeningChangeCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid NetworkServer::SetHost(std::string new_host)\n{\n    if(server_online == false)\n    {\n        host = new_host;\n    }\n}\n\nvoid NetworkServer::SetLegacyWorkaroundEnable(bool enable)\n{\n    legacy_workaround_enabled = enable;\n}\n\nvoid NetworkServer::SetPort(unsigned short new_port)\n{\n    if(server_online == false)\n    {\n        port_num = new_port;\n    }\n}\n\nvoid NetworkServer::StartServer()\n{\n    int err;\n    struct addrinfo hints, *res, *result;\n\n    /*---------------------------------------------------------*\\\n    | Start a TCP server and launch threads                     |\n    \\*---------------------------------------------------------*/\n    char port_str[6];\n    snprintf(port_str, 6, \"%d\", port_num);\n\n    socket_count = 0;\n\n    /*---------------------------------------------------------*\\\n    | Windows requires WSAStartup before using sockets          |\n    \\*---------------------------------------------------------*/\n#ifdef WIN32\n    if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n    {\n        WSACleanup();\n        return;\n    }\n#endif\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n    err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n    if(err)\n    {\n        LOG_ERROR(\"[NetworkServer] Unable to get address.\");\n        WSACleanup();\n        return;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Create a server socket for each address returned.         |\n    \\*---------------------------------------------------------*/\n    for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n    {\n        server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n        if(server_sock[socket_count] == INVALID_SOCKET)\n        {\n            LOG_ERROR(\"[NetworkServer] Network socket could not be created.\");\n            WSACleanup();\n            return;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Bind the server socket                                    |\n        \\*---------------------------------------------------------*/\n        if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n        {\n            if(errno == EADDRINUSE)\n            {\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. Is port %hu already being used?\", GetPort());\n            }\n            else if(errno == EACCES)\n            {\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. Access to socket was denied.\");\n            }\n            else if(errno == EBADF)\n            {\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. sockfd is not a valid file descriptor.\");\n            }\n            else if(errno == EINVAL)\n            {\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n            }\n            else if(errno == ENOTSOCK)\n            {\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n            }\n            else\n            {\n                /*---------------------------------------------------------*\\\n                | errno could be a Linux specific error, see:               |\n                | https://man7.org/linux/man-pages/man2/bind.2.html         |\n                \\*---------------------------------------------------------*/\n                LOG_ERROR(\"[NetworkServer] Could not bind network socket. Error code: %d.\", errno);\n            }\n\n            WSACleanup();\n            return;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Set socket options - no delay                             |\n        \\*---------------------------------------------------------*/\n        setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n        socket_count += 1;\n    }\n\n    freeaddrinfo(result);\n    server_online = true;\n\n    /*---------------------------------------------------------*\\\n    | Start the connection thread                               |\n    \\*---------------------------------------------------------*/\n    for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n    {\n        ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n        ConnectionThread[curr_socket]->detach();\n    }\n}\n\nvoid NetworkServer::StopServer()\n{\n    int curr_socket;\n    server_online = false;\n\n    ServerClientsMutex.lock();\n\n    for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n    {\n        delete ServerClients[client_idx];\n    }\n\n    ServerClients.clear();\n\n    for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n    {\n        shutdown(server_sock[curr_socket], SD_RECEIVE);\n        closesocket(server_sock[curr_socket]);\n    }\n\n    ServerClientsMutex.unlock();\n\n    for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n    {\n        if(ConnectionThread[curr_socket])\n        {\n            delete ConnectionThread[curr_socket];\n            ConnectionThread[curr_socket] = nullptr;\n        }\n    }\n\n    socket_count = 0;\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkServer::ConnectionThreadFunction(int socket_idx)\n{\n    /*---------------------------------------------------------*\\\n    | This thread handles client connections                    |\n    \\*---------------------------------------------------------*/\n    LOG_INFO(\"[NetworkServer] Network connection thread started on port %hu\", GetPort());\n\n    while(server_online == true)\n    {\n        /*---------------------------------------------------------*\\\n        | Create new socket for client connection                   |\n        \\*---------------------------------------------------------*/\n        NetworkClientInfo * client_info = new NetworkClientInfo();\n\n        /*---------------------------------------------------------*\\\n        | Listen for incoming client connection on the server       |\n        | socket.  This call blocks until a connection is           |\n        | established                                               |\n        \\*---------------------------------------------------------*/\n        if(listen(server_sock[socket_idx], 10) < 0)\n        {\n            LOG_INFO(\"[NetworkServer] Connection thread closed\");\n            server_online = false;\n\n            return;\n        }\n\n        server_listening = true;\n        ServerListeningChanged();\n\n        /*---------------------------------------------------------*\\\n        | Accept the client connection                              |\n        \\*---------------------------------------------------------*/\n        client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n        if(client_info->client_sock < 0)\n        {\n            LOG_INFO(\"[NetworkServer] Connection thread closed\");\n            server_online = false;\n\n            server_listening = false;\n            ServerListeningChanged();\n\n            return;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Get the new client socket and store it in the clients     |\n        | vector                                                    |\n        \\*---------------------------------------------------------*/\n        u_long arg = 0;\n        ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n        setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n        /*---------------------------------------------------------*\\\n        | Discover the remote hosts IP                              |\n        \\*---------------------------------------------------------*/\n        struct sockaddr_storage tmp_addr;\n        char ipstr[INET6_ADDRSTRLEN];\n        socklen_t len;\n        len = sizeof(tmp_addr);\n        getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n        if(tmp_addr.ss_family == AF_INET)\n        {\n            struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n            inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n            client_info->client_ip = ipstr;\n        }\n        else\n        {\n            struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n            inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n            client_info->client_ip = ipstr;\n        }\n\n        /*---------------------------------------------------------*\\\n        | We need to lock before the thread could possibly finish   |\n        \\*---------------------------------------------------------*/\n        ServerClientsMutex.lock();\n\n        /*---------------------------------------------------------*\\\n        | Start a listener thread for the new client socket         |\n        \\*---------------------------------------------------------*/\n        client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        client_info->client_listen_thread->detach();\n\n        ServerClients.push_back(client_info);\n        ServerClientsMutex.unlock();\n\n        /*---------------------------------------------------------*\\\n        | Client info has changed, call the callbacks               |\n        \\*---------------------------------------------------------*/\n        ClientInfoChanged();\n    }\n\n    LOG_INFO(\"[NetworkServer] Connection thread closed\");\n    server_online = false;\n    server_listening = false;\n    ServerListeningChanged();\n}\n\nint NetworkServer::accept_select(int sockfd)\n{\n    fd_set              set;\n    struct timeval      timeout;\n\n    while(1)\n    {\n        timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n        timeout.tv_usec         = 0;\n\n        FD_ZERO(&set);\n        FD_SET(sockfd, &set);\n\n        int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n        if(rv == SOCKET_ERROR || server_online == false)\n        {\n            return -1;\n        }\n        else if(rv == 0)\n        {\n            continue;\n        }\n        else\n        {\n            return(accept((int)sockfd, NULL, NULL));\n        }\n    }\n}\n\nint NetworkServer::recv_select(SOCKET s, char *buf, int len, int flags)\n{\n    fd_set              set;\n    struct timeval      timeout;\n\n    while(1)\n    {\n        timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n        timeout.tv_usec         = 0;\n\n        FD_ZERO(&set);\n        FD_SET(s, &set);\n\n        int rv = select((int)s + 1, &set, NULL, NULL, &timeout);\n\n        if(rv == SOCKET_ERROR || server_online == false)\n        {\n            return 0;\n        }\n        else if(rv == 0)\n        {\n            continue;\n        }\n        else\n        {\n            return(recv(s, buf, len, flags));\n        }\n    }\n}\n\nvoid NetworkServer::ListenThreadFunction(NetworkClientInfo * client_info)\n{\n    SOCKET client_sock = client_info->client_sock;\n\n    LOG_INFO(\"[NetworkServer] Network server started\");\n\n    /*---------------------------------------------------------*\\\n    | This thread handles messages received from clients        |\n    \\*---------------------------------------------------------*/\n    while(server_online == true)\n    {\n        NetPacketHeader header;\n        int             bytes_read  = 0;\n        char *          data        = NULL;\n\n        for(unsigned int i = 0; i < 4; i++)\n        {\n            /*---------------------------------------------------------*\\\n            | Read byte of magic                                        |\n            \\*---------------------------------------------------------*/\n            bytes_read = recv_select(client_sock, &header.pkt_magic[i], 1, 0);\n\n            if(bytes_read <= 0)\n            {\n                LOG_ERROR(\"[NetworkServer] recv_select failed receiving magic, closing listener\");\n                goto listen_done;\n            }\n\n            /*---------------------------------------------------------*\\\n            | Test characters of magic \"ORGB\"                           |\n            \\*---------------------------------------------------------*/\n            if(header.pkt_magic[i] != openrgb_sdk_magic[i])\n            {\n                LOG_ERROR(\"[NetworkServer] Invalid magic received\");\n                continue;\n            }\n        }\n\n        /*---------------------------------------------------------*\\\n        | If we get to this point, the magic is correct.  Read the  |\n        | rest of the header                                        |\n        \\*---------------------------------------------------------*/\n        bytes_read = 0;\n        do\n        {\n            int tmp_bytes_read = 0;\n\n            tmp_bytes_read = recv_select(client_sock, (char *)&header.pkt_dev_idx + bytes_read, sizeof(header) - sizeof(header.pkt_magic) - bytes_read, 0);\n\n            bytes_read += tmp_bytes_read;\n\n            if(tmp_bytes_read <= 0)\n            {\n                LOG_ERROR(\"[NetworkServer] recv_select failed receiving header, closing listener\");\n                goto listen_done;\n            }\n\n        } while(bytes_read != sizeof(header) - sizeof(header.pkt_magic));\n\n        /*---------------------------------------------------------*\\\n        | Header received, now receive the data                     |\n        \\*---------------------------------------------------------*/\n        bytes_read = 0;\n        if(header.pkt_size > 0)\n        {\n            data = new char[header.pkt_size];\n\n            do\n            {\n                int tmp_bytes_read = 0;\n\n                tmp_bytes_read = recv_select(client_sock, &data[(unsigned int)bytes_read], header.pkt_size - bytes_read, 0);\n\n                if(tmp_bytes_read <= 0)\n                {\n                    LOG_ERROR(\"[NetworkServer] recv_select failed receiving data, closing listener\");\n                    goto listen_done;\n                }\n                bytes_read += tmp_bytes_read;\n\n            } while ((unsigned int)bytes_read < header.pkt_size);\n        }\n\n        /*---------------------------------------------------------*\\\n        | Entire request received, select functionality based on    |\n        | request ID                                                |\n        \\*---------------------------------------------------------*/\n        switch(header.pkt_id)\n        {\n            case NET_PACKET_ID_REQUEST_CONTROLLER_COUNT:\n                SendReply_ControllerCount(client_sock);\n                break;\n\n            case NET_PACKET_ID_REQUEST_CONTROLLER_DATA:\n                {\n                    unsigned int protocol_version = 0;\n\n                    if(header.pkt_size == sizeof(unsigned int))\n                    {\n                        memcpy(&protocol_version, data, sizeof(unsigned int));\n                    }\n\n                    SendReply_ControllerData(client_sock, header.pkt_dev_idx, protocol_version);\n                }\n                break;\n\n            case NET_PACKET_ID_REQUEST_PROTOCOL_VERSION:\n                SendReply_ProtocolVersion(client_sock);\n                ProcessRequest_ClientProtocolVersion(client_sock, header.pkt_size, data);\n                break;\n\n            case NET_PACKET_ID_SET_CLIENT_NAME:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                ProcessRequest_ClientString(client_sock, header.pkt_size, data);\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_RESIZEZONE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                if((header.pkt_dev_idx < controllers.size()) && (header.pkt_size == (2 * sizeof(int))))\n                {\n                    int zone;\n                    int new_size;\n\n                    memcpy(&zone, data, sizeof(int));\n                    memcpy(&new_size, data + sizeof(int), sizeof(int));\n\n                    controllers[header.pkt_dev_idx]->ResizeZone(zone, new_size);\n                    profile_manager->SaveProfile(\"sizes\", true);\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_UPDATELEDS:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Verify the color description size (first 4 bytes of data) |\n                | matches the packet size in the header                     |\n                |                                                           |\n                | If protocol version is 4 or below and the legacy SDK      |\n                | compatibility workaround is enabled, ignore this check.   |\n                | This allows backwards compatibility with old versions of  |\n                | SDK applications that didn't properly implement the size  |\n                | field.                                                    |\n                \\*---------------------------------------------------------*/\n                if((header.pkt_size == *((unsigned int*)data))\n                || ((client_info->client_protocol_version <= 4)\n                 && (legacy_workaround_enabled)))\n                {\n                    if(header.pkt_dev_idx < controllers.size())\n                    {\n                        controllers[header.pkt_dev_idx]->SetColorDescription((unsigned char *)data);\n                        controllers[header.pkt_dev_idx]->UpdateLEDs();\n                    }\n                }\n                else\n                {\n                    LOG_ERROR(\"[NetworkServer] UpdateLEDs packet has invalid size. Packet size: %d, Data size: %d\", header.pkt_size, *((unsigned int*)data));\n                    goto listen_done;\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_UPDATEZONELEDS:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Verify the color description size (first 4 bytes of data) |\n                | matches the packet size in the header                     |\n                |                                                           |\n                | If protocol version is 4 or below and the legacy SDK      |\n                | compatibility workaround is enabled, ignore this check.   |\n                | This allows backwards compatibility with old versions of  |\n                | SDK applications that didn't properly implement the size  |\n                | field.                                                    |\n                \\*---------------------------------------------------------*/\n                if((header.pkt_size == *((unsigned int*)data))\n                || ((client_info->client_protocol_version <= 4)\n                 && (legacy_workaround_enabled)))\n                {\n                    if(header.pkt_dev_idx < controllers.size())\n                    {\n                        int zone;\n\n                        memcpy(&zone, &data[sizeof(unsigned int)], sizeof(int));\n\n                        controllers[header.pkt_dev_idx]->SetZoneColorDescription((unsigned char *)data);\n                        controllers[header.pkt_dev_idx]->UpdateZoneLEDs(zone);\n                    }\n                }\n                else\n                {\n                    LOG_ERROR(\"[NetworkServer] UpdateZoneLEDs packet has invalid size. Packet size: %d, Data size: %d\", header.pkt_size, *((unsigned int*)data));\n                    goto listen_done;\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_UPDATESINGLELED:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Verify the single LED color description size (8 bytes)    |\n                | matches the packet size in the header                     |\n                \\*---------------------------------------------------------*/\n                if(header.pkt_size == (sizeof(int) + sizeof(RGBColor)))\n                {\n                    if(header.pkt_dev_idx < controllers.size())\n                    {\n                        int led;\n\n                        memcpy(&led, data, sizeof(int));\n\n                        controllers[header.pkt_dev_idx]->SetSingleLEDColorDescription((unsigned char *)data);\n                        controllers[header.pkt_dev_idx]->UpdateSingleLED(led);\n                    }\n                }\n                else\n                {\n                    LOG_ERROR(\"[NetworkServer] UpdateSingleLED packet has invalid size. Packet size: %d, Data size: %d\", header.pkt_size, (sizeof(int) + sizeof(RGBColor)));\n                    goto listen_done;\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_SETCUSTOMMODE:\n                if(header.pkt_dev_idx < controllers.size())\n                {\n                    controllers[header.pkt_dev_idx]->SetCustomMode();\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_UPDATEMODE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Verify the mode description size (first 4 bytes of data)  |\n                | matches the packet size in the header                     |\n                |                                                           |\n                | If protocol version is 4 or below and the legacy SDK      |\n                | compatibility workaround is enabled, ignore this check.   |\n                | This allows backwards compatibility with old versions of  |\n                | SDK applications that didn't properly implement the size  |\n                | field.                                                    |\n                \\*---------------------------------------------------------*/\n                if((header.pkt_size == *((unsigned int*)data))\n                || ((client_info->client_protocol_version <= 4)\n                 && (legacy_workaround_enabled)))\n                {\n                    if(header.pkt_dev_idx < controllers.size())\n                    {\n                        controllers[header.pkt_dev_idx]->SetModeDescription((unsigned char *)data, client_info->client_protocol_version);\n                        controllers[header.pkt_dev_idx]->UpdateMode();\n                    }\n                }\n                else\n                {\n                    LOG_ERROR(\"[NetworkServer] UpdateMode packet has invalid size. Packet size: %d, Data size: %d\", header.pkt_size, *((unsigned int*)data));\n                    goto listen_done;\n                }\n                break;\n\n            case NET_PACKET_ID_RGBCONTROLLER_SAVEMODE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Verify the mode description size (first 4 bytes of data)  |\n                | matches the packet size in the header                     |\n                |                                                           |\n                | If protocol version is 4 or below and the legacy SDK      |\n                | compatibility workaround is enabled, ignore this check.   |\n                | This allows backwards compatibility with old versions of  |\n                | SDK applications that didn't properly implement the size  |\n                | field.                                                    |\n                \\*---------------------------------------------------------*/\n                if((header.pkt_size == *((unsigned int*)data))\n                || ((client_info->client_protocol_version <= 4)\n                 && (legacy_workaround_enabled)))\n                {\n                    if(header.pkt_dev_idx < controllers.size())\n                    {\n                        controllers[header.pkt_dev_idx]->SetModeDescription((unsigned char *)data, client_info->client_protocol_version);\n                        controllers[header.pkt_dev_idx]->SaveMode();\n                    }\n                }\n                break;\n\n            case NET_PACKET_ID_REQUEST_PROFILE_LIST:\n                SendReply_ProfileList(client_sock);\n                break;\n\n            case NET_PACKET_ID_REQUEST_SAVE_PROFILE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                if(profile_manager)\n                {\n                    std::string profile_name;\n                    profile_name.assign(data, header.pkt_size);\n\n                    profile_manager->SaveProfile(profile_name);\n                }\n\n                break;\n\n            case NET_PACKET_ID_REQUEST_LOAD_PROFILE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                if(profile_manager)\n                {\n                    std::string profile_name;\n                    profile_name.assign(data, header.pkt_size);\n\n                    profile_manager->LoadProfile(profile_name);\n                }\n\n                for(RGBController* controller : controllers)\n                {\n                    controller->UpdateLEDs();\n                }\n\n                break;\n\n            case NET_PACKET_ID_REQUEST_DELETE_PROFILE:\n                if(data == NULL)\n                {\n                    break;\n                }\n\n                if(profile_manager)\n                {\n                    std::string profile_name;\n                    profile_name.assign(data, header.pkt_size);\n\n                    profile_manager->DeleteProfile(profile_name);\n                }\n\n                break;\n\n            case NET_PACKET_ID_REQUEST_PLUGIN_LIST:\n                SendReply_PluginList(client_sock);\n                break;\n\n            case NET_PACKET_ID_PLUGIN_SPECIFIC:\n                {\n                    unsigned int plugin_pkt_type = *((unsigned int*)(data));\n                    unsigned int plugin_pkt_size = header.pkt_size - (sizeof(unsigned int));\n                    unsigned char* plugin_data = (unsigned char*)(data + sizeof(unsigned int));\n\n                    if(header.pkt_dev_idx < plugins.size())\n                    {\n                        NetworkPlugin plugin = plugins[header.pkt_dev_idx];\n                        unsigned char* output = plugin.callback(plugin.callback_arg, plugin_pkt_type, plugin_data, &plugin_pkt_size);\n                        if(output != nullptr)\n                        {\n                            SendReply_PluginSpecific(client_sock, plugin_pkt_type, output, plugin_pkt_size);\n                        }\n                    }\n                    break;\n                }\n        }\n\n        delete[] data;\n    }\n\nlisten_done:\n\n    ServerClientsMutex.lock();\n\n    for(unsigned int this_idx = 0; this_idx < ServerClients.size(); this_idx++)\n    {\n        if(ServerClients[this_idx] == client_info)\n        {\n            delete client_info;\n            ServerClients.erase(ServerClients.begin() + this_idx);\n            break;\n        }\n    }\n\n    client_info = nullptr;\n\n    ServerClientsMutex.unlock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkServer::ProcessRequest_ClientProtocolVersion(SOCKET client_sock, unsigned int data_size, char * data)\n{\n    unsigned int protocol_version = 0;\n\n    if(data_size == sizeof(unsigned int) && (data != NULL))\n    {\n        memcpy(&protocol_version, data, sizeof(unsigned int));\n    }\n\n    if(protocol_version > OPENRGB_SDK_PROTOCOL_VERSION)\n    {\n        protocol_version = OPENRGB_SDK_PROTOCOL_VERSION;\n    }\n\n    ServerClientsMutex.lock();\n    for(unsigned int this_idx = 0; this_idx < ServerClients.size(); this_idx++)\n    {\n        if(ServerClients[this_idx]->client_sock == client_sock)\n        {\n            ServerClients[this_idx]->client_protocol_version = protocol_version;\n            break;\n        }\n    }\n    ServerClientsMutex.unlock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkServer::ProcessRequest_ClientString(SOCKET client_sock, unsigned int data_size, char * data)\n{\n    ServerClientsMutex.lock();\n    for(unsigned int this_idx = 0; this_idx < ServerClients.size(); this_idx++)\n    {\n        if(ServerClients[this_idx]->client_sock == client_sock)\n        {\n            ServerClients[this_idx]->client_string.assign(data, data_size);\n            break;\n        }\n    }\n    ServerClientsMutex.unlock();\n\n    /*---------------------------------------------------------*\\\n    | Client info has changed, call the callbacks               |\n    \\*---------------------------------------------------------*/\n    ClientInfoChanged();\n}\n\nvoid NetworkServer::SendReply_ControllerCount(SOCKET client_sock)\n{\n    NetPacketHeader reply_hdr;\n    unsigned int    reply_data;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_CONTROLLER_COUNT, sizeof(unsigned int));\n\n    reply_data = (unsigned int)controllers.size();\n\n    send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n    send(client_sock, (const char *)&reply_data, sizeof(unsigned int), 0);\n}\n\nvoid NetworkServer::SendReply_ControllerData(SOCKET client_sock, unsigned int dev_idx, unsigned int protocol_version)\n{\n    if(dev_idx < controllers.size())\n    {\n        NetPacketHeader reply_hdr;\n        unsigned char *reply_data = controllers[dev_idx]->GetDeviceDescription(protocol_version);\n        unsigned int   reply_size;\n\n        memcpy(&reply_size, reply_data, sizeof(reply_size));\n\n        InitNetPacketHeader(&reply_hdr, dev_idx, NET_PACKET_ID_REQUEST_CONTROLLER_DATA, reply_size);\n\n        send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n        send(client_sock, (const char *)reply_data, reply_size, 0);\n\n        delete[] reply_data;\n    }\n}\n\nvoid NetworkServer::SendReply_ProtocolVersion(SOCKET client_sock)\n{\n    NetPacketHeader reply_hdr;\n    unsigned int    reply_data;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_PROTOCOL_VERSION, sizeof(unsigned int));\n\n    reply_data = OPENRGB_SDK_PROTOCOL_VERSION;\n\n    send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n    send(client_sock, (const char *)&reply_data, sizeof(unsigned int), 0);\n}\n\nvoid NetworkServer::SendRequest_DeviceListChanged(SOCKET client_sock)\n{\n    NetPacketHeader pkt_hdr;\n\n    InitNetPacketHeader(&pkt_hdr, 0, NET_PACKET_ID_DEVICE_LIST_UPDATED, 0);\n\n    send(client_sock, (char *)&pkt_hdr, sizeof(NetPacketHeader), 0);\n}\n\nvoid NetworkServer::SendReply_ProfileList(SOCKET client_sock)\n{\n    if(!profile_manager)\n    {\n        return;\n    }\n\n    NetPacketHeader reply_hdr;\n    unsigned char *reply_data = profile_manager->GetProfileListDescription();\n    unsigned int reply_size;\n\n    memcpy(&reply_size, reply_data, sizeof(reply_size));\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_PROFILE_LIST, reply_size);\n\n    send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n    send(client_sock, (const char *)reply_data, reply_size, 0);\n}\n\nvoid NetworkServer::SendReply_PluginList(SOCKET client_sock)\n{\n    unsigned int data_size = 0;\n    unsigned int data_ptr = 0;\n\n    /*---------------------------------------------------------*\\\n    | Calculate data size                                       |\n    \\*---------------------------------------------------------*/\n    unsigned short num_plugins = (unsigned short)plugins.size();\n\n    data_size += sizeof(data_size);\n    data_size += sizeof(num_plugins);\n\n    for(unsigned int i = 0; i < num_plugins; i++)\n    {\n        data_size += sizeof(unsigned short) * 3;\n        data_size += (unsigned int)strlen(plugins[i].name.c_str()) + 1;\n        data_size += (unsigned int)strlen(plugins[i].description.c_str()) + 1;\n        data_size += (unsigned int)strlen(plugins[i].version.c_str()) + 1;\n        data_size += sizeof(unsigned int) * 2;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Create data buffer                                        |\n    \\*---------------------------------------------------------*/\n    unsigned char *data_buf = new unsigned char[data_size];\n\n    /*---------------------------------------------------------*\\\n    | Copy in data size                                         |\n    \\*---------------------------------------------------------*/\n    memcpy(&data_buf[data_ptr], &data_size, sizeof(data_size));\n    data_ptr += sizeof(data_size);\n\n    /*---------------------------------------------------------*\\\n    | Copy in num_plugins                                       |\n    \\*---------------------------------------------------------*/\n    memcpy(&data_buf[data_ptr], &num_plugins, sizeof(num_plugins));\n    data_ptr += sizeof(num_plugins);\n\n    for(unsigned int i = 0; i < num_plugins; i++)\n    {\n        /*---------------------------------------------------------*\\\n        | Copy in plugin name (size+data)                           |\n        \\*---------------------------------------------------------*/\n        unsigned short str_len = (unsigned short)strlen(plugins[i].name.c_str()) + 1;\n\n        memcpy(&data_buf[data_ptr], &str_len, sizeof(unsigned short));\n        data_ptr += sizeof(unsigned short);\n\n        strcpy((char *)&data_buf[data_ptr], plugins[i].name.c_str());\n        data_ptr += str_len;\n\n        /*---------------------------------------------------------*\\\n        | Copy in plugin description (size+data)                    |\n        \\*---------------------------------------------------------*/\n        str_len = (unsigned short)strlen(plugins[i].description.c_str()) + 1;\n\n        memcpy(&data_buf[data_ptr], &str_len, sizeof(unsigned short));\n        data_ptr += sizeof(unsigned short);\n\n        strcpy((char *)&data_buf[data_ptr], plugins[i].description.c_str());\n        data_ptr += str_len;\n\n        /*---------------------------------------------------------*\\\n        | Copy in plugin version (size+data)                        |\n        \\*---------------------------------------------------------*/\n        str_len = (unsigned short)strlen(plugins[i].version.c_str()) + 1;\n\n        memcpy(&data_buf[data_ptr], &str_len, sizeof(unsigned short));\n        data_ptr += sizeof(unsigned short);\n\n        strcpy((char *)&data_buf[data_ptr], plugins[i].version.c_str());\n        data_ptr += str_len;\n\n        /*---------------------------------------------------------*\\\n        | Copy in plugin index (data)                               |\n        \\*---------------------------------------------------------*/\n        memcpy(&data_buf[data_ptr], &i, sizeof(unsigned int));\n        data_ptr += sizeof(unsigned int);\n\n        /*---------------------------------------------------------*\\\n        | Copy in plugin sdk version (data)                         |\n        \\*---------------------------------------------------------*/\n        memcpy(&data_buf[data_ptr], &plugins[i].protocol_version, sizeof(unsigned int));\n        data_ptr += sizeof(unsigned int);\n    }\n\n    NetPacketHeader reply_hdr;\n    unsigned int reply_size;\n\n    memcpy(&reply_size, data_buf, sizeof(reply_size));\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_REQUEST_PLUGIN_LIST, reply_size);\n\n    send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n    send(client_sock, (const char *)data_buf, reply_size, 0);\n\n    delete [] data_buf;\n}\n\nvoid NetworkServer::SendReply_PluginSpecific(SOCKET client_sock, unsigned int pkt_type, unsigned char* data, unsigned int data_size)\n{\n    NetPacketHeader reply_hdr;\n\n    InitNetPacketHeader(&reply_hdr, 0, NET_PACKET_ID_PLUGIN_SPECIFIC, data_size + sizeof(pkt_type));\n\n    send(client_sock, (const char *)&reply_hdr, sizeof(NetPacketHeader), 0);\n    send(client_sock, (const char *)&pkt_type, sizeof(pkt_type), 0);\n    send(client_sock, (const char *)data, data_size, 0);\n    delete [] data;\n}\n\nvoid NetworkServer::SetProfileManager(ProfileManagerInterface* profile_manager_pointer)\n{\n    profile_manager = profile_manager_pointer;\n}\n\nvoid NetworkServer::RegisterPlugin(NetworkPlugin plugin)\n{\n    plugins.push_back(plugin);\n}\n\nvoid NetworkServer::UnregisterPlugin(std::string plugin_name)\n{\n    for(std::vector<NetworkPlugin>::iterator it = plugins.begin(); it != plugins.end(); it++)\n    {\n        if(it->name == plugin_name)\n        {\n            plugins.erase(it);\n            break;\n        }\n    }\n}\n"
        },
        {
          "name": "NetworkServer.h",
          "type": "blob",
          "size": 5.439453125,
          "content": "/*---------------------------------------------------------*\\\n| NetworkServer.h                                           |\n|                                                           |\n|   OpenRGB SDK network server                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                09 May 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <mutex>\n#include <thread>\n#include <chrono>\n#include \"RGBController.h\"\n#include \"NetworkProtocol.h\"\n#include \"net_port.h\"\n#include \"ProfileManager.h\"\n\n#define MAXSOCK 32\n#define TCP_TIMEOUT_SECONDS 5\n\ntypedef void (*NetServerCallback)(void *);\ntypedef unsigned char* (*NetPluginCallback)(void *, unsigned int, unsigned char*, unsigned int*);\n\nstruct NetworkPlugin\n{\n    std::string name;\n    std::string description;\n    std::string version;\n    NetPluginCallback callback;\n    void* callback_arg;\n    unsigned int protocol_version;\n};\n\nclass NetworkClientInfo\n{\npublic:\n    NetworkClientInfo();\n    ~NetworkClientInfo();\n\n    SOCKET          client_sock;\n    std::thread *   client_listen_thread;\n    std::string     client_string;\n    unsigned int    client_protocol_version;\n    std::string     client_ip;\n};\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control);\n    ~NetworkServer();\n\n    std::string                         GetHost();\n    unsigned short                      GetPort();\n    bool                                GetOnline();\n    bool                                GetListening();\n    unsigned int                        GetNumClients();\n    const char *                        GetClientString(unsigned int client_num);\n    const char *                        GetClientIP(unsigned int client_num);\n    unsigned int                        GetClientProtocolVersion(unsigned int client_num);\n\n    void                                ClientInfoChanged();\n    void                                DeviceListChanged();\n    void                                RegisterClientInfoChangeCallback(NetServerCallback, void * new_callback_arg);\n\n    void                                ServerListeningChanged();\n    void                                RegisterServerListeningChangeCallback(NetServerCallback, void * new_callback_arg);\n\n    void                                SetHost(std::string host);\n    void                                SetLegacyWorkaroundEnable(bool enable);\n    void                                SetPort(unsigned short new_port);\n\n    void                                StartServer();\n    void                                StopServer();\n\n    void                                ConnectionThreadFunction(int socket_idx);\n    void                                ListenThreadFunction(NetworkClientInfo * client_sock);\n\n    void                                ProcessRequest_ClientProtocolVersion(SOCKET client_sock, unsigned int data_size, char * data);\n    void                                ProcessRequest_ClientString(SOCKET client_sock, unsigned int data_size, char * data);\n\n    void                                SendReply_ControllerCount(SOCKET client_sock);\n    void                                SendReply_ControllerData(SOCKET client_sock, unsigned int dev_idx, unsigned int protocol_version);\n    void                                SendReply_ProtocolVersion(SOCKET client_sock);\n\n    void                                SendRequest_DeviceListChanged(SOCKET client_sock);\n    void                                SendReply_ProfileList(SOCKET client_sock);\n    void                                SendReply_PluginList(SOCKET client_sock);\n    void                                SendReply_PluginSpecific(SOCKET client_sock, unsigned int pkt_type, unsigned char* data, unsigned int data_size);\n\n    void                                SetProfileManager(ProfileManagerInterface* profile_manager_pointer);\n\n    void                                RegisterPlugin(NetworkPlugin plugin);\n    void                                UnregisterPlugin(std::string plugin_name);\n\nprotected:\n    std::string                         host;\n    unsigned short                      port_num;\n    std::atomic<bool>                   server_online;\n    std::atomic<bool>                   server_listening;\n\n    std::vector<RGBController *>&       controllers;\n\n    std::mutex                          ServerClientsMutex;\n    std::vector<NetworkClientInfo *>    ServerClients;\n    std::thread *                       ConnectionThread[MAXSOCK];\n\n    std::mutex                          ClientInfoChangeMutex;\n    std::vector<NetServerCallback>      ClientInfoChangeCallbacks;\n    std::vector<void *>                 ClientInfoChangeCallbackArgs;\n\n    std::mutex                          ServerListeningChangeMutex;\n    std::vector<NetServerCallback>      ServerListeningChangeCallbacks;\n    std::vector<void *>                 ServerListeningChangeCallbackArgs;\n\n    ProfileManagerInterface*            profile_manager;\n\n    std::vector<NetworkPlugin>          plugins;\n\nprivate:\n#ifdef WIN32\n    WSADATA     wsa;\n#endif\n\n    bool            legacy_workaround_enabled;\n    int             socket_count;\n    SOCKET          server_sock[MAXSOCK];\n\n    int             accept_select(int sockfd);\n    int             recv_select(SOCKET s, char *buf, int len, int flags);\n};\n"
        },
        {
          "name": "OpenRGB.pro",
          "type": "blob",
          "size": 57.73828125,
          "content": "#-----------------------------------------------------------------------------------------------#\n# OpenRGB 0.x QMake Project                                                                     #\n#                                                                                               #\n#   Adam Honse (CalcProgrammer1)                        5/25/2020                               #\n#-----------------------------------------------------------------------------------------------#\n\n#-----------------------------------------------------------------------------------------------#\n# Qt Configuration                                                                              #\n#-----------------------------------------------------------------------------------------------#\nQT +=                                                                                           \\\n    core                                                                                        \\\n    gui                                                                                         \\\n\n#-----------------------------------------------------------------------------------------------#\n# Set compiler to use C++17 to make std::filesystem available                                   #\n#-----------------------------------------------------------------------------------------------#\nCONFIG +=   c++17                                                                               \\\n            lrelease                                                                            \\\n            embed_translations                                                                  \\\n            silent                                                                              \\\n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n\n#-----------------------------------------------------------------------------------------------#\n# Application Configuration                                                                     #\n#-----------------------------------------------------------------------------------------------#\nMAJOR       = 0\nMINOR       = 9\nREVISION    = 1\nVERSION     = $$MAJOR\".\"$$MINOR$$REVISION\nTARGET      = OpenRGB\nTEMPLATE    = app\n\n#-----------------------------------------------------------------------------------------------#\n# Automatically generated build information                                                     #\n#-----------------------------------------------------------------------------------------------#\nwin32:BUILDDATE         = $$system(date /t)\nlinux:BUILDDATE         = $$system(date -R -d \"@${SOURCE_DATE_EPOCH:-$(date +%s)}\")\nfreebsd:BUILDDATE       = $$system(date -j -R -r \"${SOURCE_DATE_EPOCH:-$(date +%s)}\")\nmacx:BUILDDATE          = $$system(date -j -R -r \"${SOURCE_DATE_EPOCH:-$(date +%s)}\")\nGIT_COMMIT_ID           = $$system(git log -n 1 --pretty=format:\"%H\")\nGIT_COMMIT_DATE         = $$system(git log -n 1 --pretty=format:\"%ci\")\nGIT_BRANCH              = $$system(git branch --show-current)\n\nDEFINES +=                                                                                      \\\n    VERSION_STRING=\\\\\"\\\"\\\"$$VERSION\\\\\"\\\"\\\"                                                      \\\n    BUILDDATE_STRING=\\\\\"\\\"\\\"$$BUILDDATE\\\\\"\\\"\\\"                                                  \\\n    GIT_COMMIT_ID=\\\\\"\\\"\\\"$$GIT_COMMIT_ID\\\\\"\\\"\\\"                                                 \\\n    GIT_COMMIT_DATE=\\\\\"\\\"\\\"$$GIT_COMMIT_DATE\\\\\"\\\"\\\"                                             \\\n    GIT_BRANCH=\\\\\"\\\"\\\"$$GIT_BRANCH\\\\\"\\\"\\\"\n\n#-----------------------------------------------------------------------------------------------#\n# OpenRGB dynamically added sources                                                             #\n#-----------------------------------------------------------------------------------------------#\nFORMS += $$files(\"qt/*.ui\", true)\n\nfor(iter, FORMS) {\n    GUI_INCLUDES += $$dirname(iter)\n}\nGUI_INCLUDES        = $$unique(GUI_INCLUDES)\n\nGUI_H               = $$files(\"qt/*.h\", true)\nGUI_CPP             = $$files(\"qt/*.cpp\", true)\n\nCONTROLLER_H        = $$files(\"Controllers/*.h\", true)\nCONTROLLER_CPP      = $$files(\"Controllers/*.cpp\", true)\n\nfor(iter, $$list($$CONTROLLER_H)) {\n    CONTROLLER_INCLUDES += $$dirname(iter)\n}\nCONTROLLER_INCLUDES = $$unique(CONTROLLER_INCLUDES)\n\n#-----------------------------------------------------------------------------------------------#\n# Remove OS-specific files from the overall controller headers and sources lists                #\n# The suffixes _Windows, _Linux, _FreeBSD, and _MacOS are usable to denote that a file only     #\n# applies to one or more OSes.  The suffixes may be combined such as <file>_Windows_Linux.cpp.  #\n#-----------------------------------------------------------------------------------------------#\nCONTROLLER_H_WINDOWS    = $$files(\"Controllers/*_Windows*.h\",   true)\nCONTROLLER_CPP_WINDOWS  = $$files(\"Controllers/*_Windows*.cpp\", true)\nCONTROLLER_H_LINUX      = $$files(\"Controllers/*_Linux*.h\",     true)\nCONTROLLER_CPP_LINUX    = $$files(\"Controllers/*_Linux*.cpp\",   true)\nCONTROLLER_H_FREEBSD    = $$files(\"Controllers/*_FreeBSD*.h\",   true)\nCONTROLLER_CPP_FREEBSD  = $$files(\"Controllers/*_FreeBSD*.cpp\", true)\nCONTROLLER_H_MACOS      = $$files(\"Controllers/*_MacOS*.h\",     true)\nCONTROLLER_CPP_MACOS    = $$files(\"Controllers/*_MacOS*.cpp\",   true)\n\nCONTROLLER_H           -= $$CONTROLLER_H_WINDOWS\nCONTROLLER_H           -= $$CONTROLLER_H_LINUX\nCONTROLLER_H           -= $$CONTROLLER_H_FREEBSD\nCONTROLLER_H           -= $$CONTROLLER_H_MACOS\n\nCONTROLLER_CPP         -= $$CONTROLLER_CPP_WINDOWS\nCONTROLLER_CPP         -= $$CONTROLLER_CPP_LINUX\nCONTROLLER_CPP         -= $$CONTROLLER_CPP_FREEBSD\nCONTROLLER_CPP         -= $$CONTROLLER_CPP_MACOS\n\n#-----------------------------------------------------------------------------------------------#\n# OpenRGB Common                                                                                #\n#-----------------------------------------------------------------------------------------------#\nINCLUDEPATH +=                                                                                  \\\n    $$CONTROLLER_INCLUDES                                                                       \\\n    $$GUI_INCLUDES                                                                              \\\n    dependencies/ColorWheel                                                                     \\\n    dependencies/CRCpp/                                                                         \\\n    dependencies/hueplusplus-1.1.0/include                                                      \\\n    dependencies/hueplusplus-1.1.0/include/hueplusplus                                          \\\n    dependencies/httplib                                                                        \\\n    dependencies/json/                                                                          \\\n    dependencies/mdns                                                                           \\\n    dmiinfo/                                                                                    \\\n    hidapi_wrapper/                                                                             \\\n    i2c_smbus/                                                                                  \\\n    i2c_tools/                                                                                  \\\n    interop/                                                                                    \\\n    net_port/                                                                                   \\\n    pci_ids/                                                                                    \\\n    scsiapi/                                                                                    \\\n    serial_port/                                                                                \\\n    super_io/                                                                                   \\\n    AutoStart/                                                                                  \\\n    KeyboardLayoutManager/                                                                      \\\n    RGBController/                                                                              \\\n    qt/                                                                                         \\\n    SPDAccessor/                                                                                \\\n    SuspendResume/\n\nHEADERS +=                                                                                      \\\n    $$GUI_H                                                                                     \\\n    $$CONTROLLER_H                                                                              \\\n    Colors.h                                                                                    \\\n    dependencies/ColorWheel/ColorWheel.h                                                        \\\n    dependencies/json/json.hpp                                                                  \\\n    LogManager.h                                                                                \\\n    NetworkClient.h                                                                             \\\n    NetworkProtocol.h                                                                           \\\n    NetworkServer.h                                                                             \\\n    OpenRGBPluginInterface.h                                                                    \\\n    PluginManager.h                                                                             \\\n    ProfileManager.h                                                                            \\\n    ResourceManager.h                                                                           \\\n    SettingsManager.h                                                                           \\\n    Detector.h                                                                                  \\\n    DeviceDetector.h                                                                            \\\n    dmiinfo/dmiinfo.h                                                                           \\\n    filesystem.h                                                                                \\\n    hidapi_wrapper/hidapi_wrapper.h                                                             \\\n    i2c_smbus/i2c_smbus.h                                                                       \\\n    i2c_tools/i2c_tools.h                                                                       \\\n    interop/DeviceGuard.h                                                                       \\\n    interop/DeviceGuardLock.h                                                                   \\\n    interop/DeviceGuardManager.h                                                                \\\n    net_port/net_port.h                                                                         \\\n    pci_ids/pci_ids.h                                                                           \\\n    scsiapi/scsiapi.h                                                                           \\\n    serial_port/find_usb_serial_port.h                                                          \\\n    serial_port/serial_port.h                                                                   \\\n    StringUtils.h                                                                               \\\n    super_io/super_io.h                                                                         \\\n    SuspendResume/SuspendResume.h                                                               \\\n    AutoStart/AutoStart.h                                                                       \\\n    KeyboardLayoutManager/KeyboardLayoutManager.h                                               \\\n    RGBController/RGBController.h                                                               \\\n    RGBController/RGBController_Dummy.h                                                         \\\n    RGBController/RGBControllerKeyNames.h                                                       \\\n    RGBController/RGBController_Network.h                                                       \\\n\nSOURCES +=                                                                                      \\\n    $$GUI_CPP                                                                                   \\\n    $$CONTROLLER_CPP                                                                            \\\n    dependencies/ColorWheel/ColorWheel.cpp                                                      \\\n    dependencies/hueplusplus-1.1.0/src/Action.cpp                                               \\\n    dependencies/hueplusplus-1.1.0/src/APICache.cpp                                             \\\n    dependencies/hueplusplus-1.1.0/src/BaseDevice.cpp                                           \\\n    dependencies/hueplusplus-1.1.0/src/BaseHttpHandler.cpp                                      \\\n    dependencies/hueplusplus-1.1.0/src/Bridge.cpp                                               \\\n    dependencies/hueplusplus-1.1.0/src/BridgeConfig.cpp                                         \\\n    dependencies/hueplusplus-1.1.0/src/CLIPSensors.cpp                                          \\\n    dependencies/hueplusplus-1.1.0/src/ColorUnits.cpp                                           \\\n    dependencies/hueplusplus-1.1.0/src/EntertainmentMode.cpp                                    \\\n    dependencies/hueplusplus-1.1.0/src/ExtendedColorHueStrategy.cpp                             \\\n    dependencies/hueplusplus-1.1.0/src/ExtendedColorTemperatureStrategy.cpp                     \\\n    dependencies/hueplusplus-1.1.0/src/Group.cpp                                                \\\n    dependencies/hueplusplus-1.1.0/src/HueCommandAPI.cpp                                        \\\n    dependencies/hueplusplus-1.1.0/src/HueDeviceTypes.cpp                                       \\\n    dependencies/hueplusplus-1.1.0/src/HueException.cpp                                         \\\n    dependencies/hueplusplus-1.1.0/src/Light.cpp                                                \\\n    dependencies/hueplusplus-1.1.0/src/ModelPictures.cpp                                        \\\n    dependencies/hueplusplus-1.1.0/src/NewDeviceList.cpp                                        \\\n    dependencies/hueplusplus-1.1.0/src/Scene.cpp                                                \\\n    dependencies/hueplusplus-1.1.0/src/Schedule.cpp                                             \\\n    dependencies/hueplusplus-1.1.0/src/Sensor.cpp                                               \\\n    dependencies/hueplusplus-1.1.0/src/SimpleBrightnessStrategy.cpp                             \\\n    dependencies/hueplusplus-1.1.0/src/SimpleColorHueStrategy.cpp                               \\\n    dependencies/hueplusplus-1.1.0/src/SimpleColorTemperatureStrategy.cpp                       \\\n    dependencies/hueplusplus-1.1.0/src/StateTransaction.cpp                                     \\\n    dependencies/hueplusplus-1.1.0/src/TimePattern.cpp                                          \\\n    dependencies/hueplusplus-1.1.0/src/UPnP.cpp                                                 \\\n    dependencies/hueplusplus-1.1.0/src/Utils.cpp                                                \\\n    dependencies/hueplusplus-1.1.0/src/ZLLSensors.cpp                                           \\\n    main.cpp                                                                                    \\\n    cli.cpp                                                                                     \\\n    dmiinfo/dmiinfo.cpp                                                                         \\\n    LogManager.cpp                                                                              \\\n    NetworkClient.cpp                                                                           \\\n    NetworkProtocol.cpp                                                                         \\\n    NetworkServer.cpp                                                                           \\\n    PluginManager.cpp                                                                           \\\n    ProfileManager.cpp                                                                          \\\n    ResourceManager.cpp                                                                         \\\n    SPDAccessor/DDR4DirectAccessor.cpp                                                          \\\n    SPDAccessor/DDR5DirectAccessor.cpp                                                          \\\n    SPDAccessor/SPDAccessor.cpp                                                                 \\\n    SPDAccessor/SPDDetector.cpp                                                                 \\\n    SPDAccessor/SPDWrapper.cpp                                                                  \\\n    SettingsManager.cpp                                                                         \\\n    i2c_smbus/i2c_smbus.cpp                                                                     \\\n    i2c_tools/i2c_tools.cpp                                                                     \\\n    interop/DeviceGuard.cpp                                                                     \\\n    interop/DeviceGuardLock.cpp                                                                 \\\n    interop/DeviceGuardManager.cpp                                                              \\\n    net_port/net_port.cpp                                                                       \\\n    serial_port/serial_port.cpp                                                                 \\\n    StringUtils.cpp                                                                             \\\n    super_io/super_io.cpp                                                                       \\\n    AutoStart/AutoStart.cpp                                                                     \\\n    KeyboardLayoutManager/KeyboardLayoutManager.cpp                                             \\\n    RGBController/RGBController.cpp                                                             \\\n    RGBController/RGBController_Dummy.cpp                                                       \\\n    RGBController/RGBControllerKeyNames.cpp                                                     \\\n    RGBController/RGBController_Network.cpp                                                     \\\n\nRESOURCES +=                                                                                    \\\n    qt/resources.qrc                                                                            \\\n\n#-----------------------------------------------------------------------------------------------#\n# General configuration to decide if in-tree dependencies are used or not\n#-----------------------------------------------------------------------------------------------#\n\n!system_libe131:SOURCES += dependencies/libe131/src/e131.c\n!system_libe131:INCLUDEPATH += dependencies/libe131/src/\n\n#-----------------------------------------------------------------------------------------------#\n# General configuration out-of-tree dependencies if in-tree are not used for systems\n# who use pkg-config i.e. Unix-like. Also includes macOS as Homebrew uses pkg-config too.\n#-----------------------------------------------------------------------------------------------#\n\nunix {\n    system_libe131 {\n        CONFIG += link_pkgconfig\n        PKGCONFIG += libe131\n    }\n}\n\n#-----------------------------------------------------------------------------------------------#\n# Translations                                                                                  #\n#   NB: Translation files should not be added dynamically due to the process                    #\n#       to add new translations relies on entries here in OpenRGB.pro                           #\n#-----------------------------------------------------------------------------------------------#\nTRANSLATIONS +=                                                                                 \\\n    qt/i18n/OpenRGB_de_DE.ts                                                                    \\\n    qt/i18n/OpenRGB_en_US.ts                                                                    \\\n    qt/i18n/OpenRGB_en_AU.ts                                                                    \\\n    qt/i18n/OpenRGB_en_GB.ts                                                                    \\\n    qt/i18n/OpenRGB_es_ES.ts                                                                    \\\n    qt/i18n/OpenRGB_fr_FR.ts                                                                    \\\n    qt/i18n/OpenRGB_hr_HR.ts                                                                    \\\n    qt/i18n/OpenRGB_it_IT.ts                                                                    \\\n    qt/i18n/OpenRGB_ko_KR.ts                                                                    \\\n    qt/i18n/OpenRGB_ms_MY.ts                                                                    \\\n    qt/i18n/OpenRGB_pl_PL.ts                                                                    \\\n    qt/i18n/OpenRGB_pt_BR.ts                                                                    \\\n    qt/i18n/OpenRGB_ru_RU.ts                                                                    \\\n    qt/i18n/OpenRGB_zh_CN.ts                                                                    \\\n    qt/i18n/OpenRGB_zh_TW.ts                                                                    \\\n\n#-----------------------------------------------------------------------------------------------#\n# Windows-specific Configuration                                                                #\n#-----------------------------------------------------------------------------------------------#\nwin32:QMAKE_CXXFLAGS += /utf-8\nwin32:INCLUDEPATH +=                                                                            \\\n    dependencies/display-library/include                                                        \\\n    dependencies/hidapi-win/include                                                             \\\n    dependencies/winring0/include                                                               \\\n    dependencies/libusb-1.0.27/include                                                          \\\n    dependencies/mbedtls-2.28.8/include                                                         \\\n    dependencies/NVFC                                                                           \\\n    wmi/                                                                                        \\\n\nwin32:SOURCES += $$CONTROLLER_CPP_WINDOWS\n\nwin32:SOURCES +=                                                                                \\\n    dependencies/hueplusplus-1.1.0/src/WinHttpHandler.cpp                                       \\\n    dependencies/mbedtls-2.28.8/library/aes.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/aesni.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/arc4.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/aria.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/asn1parse.c                                             \\\n    dependencies/mbedtls-2.28.8/library/asn1write.c                                             \\\n    dependencies/mbedtls-2.28.8/library/base64.c                                                \\\n    dependencies/mbedtls-2.28.8/library/bignum.c                                                \\\n    dependencies/mbedtls-2.28.8/library/blowfish.c                                              \\\n    dependencies/mbedtls-2.28.8/library/camellia.c                                              \\\n    dependencies/mbedtls-2.28.8/library/ccm.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/certs.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/chacha20.c                                              \\\n    dependencies/mbedtls-2.28.8/library/chachapoly.c                                            \\\n    dependencies/mbedtls-2.28.8/library/cipher.c                                                \\\n    dependencies/mbedtls-2.28.8/library/cipher_wrap.c                                           \\\n    dependencies/mbedtls-2.28.8/library/cmac.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/constant_time.c                                         \\\n    dependencies/mbedtls-2.28.8/library/ctr_drbg.c                                              \\\n    dependencies/mbedtls-2.28.8/library/debug.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/des.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/dhm.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/ecdh.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/ecdsa.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/ecjpake.c                                               \\\n    dependencies/mbedtls-2.28.8/library/ecp.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/ecp_curves.c                                            \\\n    dependencies/mbedtls-2.28.8/library/entropy.c                                               \\\n    dependencies/mbedtls-2.28.8/library/entropy_poll.c                                          \\\n    dependencies/mbedtls-2.28.8/library/error.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/gcm.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/havege.c                                                \\\n    dependencies/mbedtls-2.28.8/library/hkdf.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/hmac_drbg.c                                             \\\n    dependencies/mbedtls-2.28.8/library/md2.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/md4.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/md5.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/md.c                                                    \\\n    dependencies/mbedtls-2.28.8/library/memory_buffer_alloc.c                                   \\\n    dependencies/mbedtls-2.28.8/library/mps_reader.c                                            \\\n    dependencies/mbedtls-2.28.8/library/mps_trace.c                                             \\\n    dependencies/mbedtls-2.28.8/library/net_sockets.c                                           \\\n    dependencies/mbedtls-2.28.8/library/nist_kw.c                                               \\\n    dependencies/mbedtls-2.28.8/library/oid.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/padlock.c                                               \\\n    dependencies/mbedtls-2.28.8/library/pem.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/pk.c                                                    \\\n    dependencies/mbedtls-2.28.8/library/pkcs11.c                                                \\\n    dependencies/mbedtls-2.28.8/library/pkcs12.c                                                \\\n    dependencies/mbedtls-2.28.8/library/pkcs5.c                                                 \\\n    dependencies/mbedtls-2.28.8/library/pkparse.c                                               \\\n    dependencies/mbedtls-2.28.8/library/pk_wrap.c                                               \\\n    dependencies/mbedtls-2.28.8/library/pkwrite.c                                               \\\n    dependencies/mbedtls-2.28.8/library/platform.c                                              \\\n    dependencies/mbedtls-2.28.8/library/platform_util.c                                         \\\n    dependencies/mbedtls-2.28.8/library/poly1305.c                                              \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_aead.c                                       \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto.c                                            \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_cipher.c                                     \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_client.c                                     \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_driver_wrappers.c                            \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_ecp.c                                        \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_hash.c                                       \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_mac.c                                        \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_rsa.c                                        \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_se.c                                         \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_slot_management.c                            \\\n    dependencies/mbedtls-2.28.8/library/psa_crypto_storage.c                                    \\\n    dependencies/mbedtls-2.28.8/library/psa_its_file.c                                          \\\n    dependencies/mbedtls-2.28.8/library/ripemd160.c                                             \\\n    dependencies/mbedtls-2.28.8/library/rsa.c                                                   \\\n    dependencies/mbedtls-2.28.8/library/rsa_internal.c                                          \\\n    dependencies/mbedtls-2.28.8/library/sha1.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/sha256.c                                                \\\n    dependencies/mbedtls-2.28.8/library/sha512.c                                                \\\n    dependencies/mbedtls-2.28.8/library/ssl_cache.c                                             \\\n    dependencies/mbedtls-2.28.8/library/ssl_ciphersuites.c                                      \\\n    dependencies/mbedtls-2.28.8/library/ssl_cli.c                                               \\\n    dependencies/mbedtls-2.28.8/library/ssl_cookie.c                                            \\\n    dependencies/mbedtls-2.28.8/library/ssl_msg.c                                               \\\n    dependencies/mbedtls-2.28.8/library/ssl_srv.c                                               \\\n    dependencies/mbedtls-2.28.8/library/ssl_ticket.c                                            \\\n    dependencies/mbedtls-2.28.8/library/ssl_tls13_keys.c                                        \\\n    dependencies/mbedtls-2.28.8/library/ssl_tls.c                                               \\\n    dependencies/mbedtls-2.28.8/library/threading.c                                             \\\n    dependencies/mbedtls-2.28.8/library/timing.c                                                \\\n    dependencies/mbedtls-2.28.8/library/version.c                                               \\\n    dependencies/mbedtls-2.28.8/library/version_features.c                                      \\\n    dependencies/mbedtls-2.28.8/library/x509.c                                                  \\\n    dependencies/mbedtls-2.28.8/library/x509_create.c                                           \\\n    dependencies/mbedtls-2.28.8/library/x509_crl.c                                              \\\n    dependencies/mbedtls-2.28.8/library/x509_crt.c                                              \\\n    dependencies/mbedtls-2.28.8/library/x509_csr.c                                              \\\n    dependencies/mbedtls-2.28.8/library/x509write_crt.c                                         \\\n    dependencies/mbedtls-2.28.8/library/x509write_csr.c                                         \\\n    dependencies/mbedtls-2.28.8/library/xtea.c                                                  \\\n    dependencies/NVFC/nvapi.cpp                                                                 \\\n    i2c_smbus/i2c_smbus_amdadl.cpp                                                              \\\n    i2c_smbus/i2c_smbus_i801.cpp                                                                \\\n    i2c_smbus/i2c_smbus_nct6775.cpp                                                             \\\n    i2c_smbus/i2c_smbus_nvapi.cpp                                                               \\\n    i2c_smbus/i2c_smbus_piix4.cpp                                                               \\\n    scsiapi/scsiapi_windows.c                                                                   \\\n    serial_port/find_usb_serial_port_win.cpp                                                    \\\n    SuspendResume/SuspendResume_Windows.cpp                                                     \\\n    wmi/wmi.cpp                                                                                 \\\n    AutoStart/AutoStart-Windows.cpp                                                             \\\n\nwin32:HEADERS += $$CONTROLLER_H_WINDOWS\n\nwin32:HEADERS +=                                                                                \\\n    dependencies/display-library/include/adl_defines.h                                          \\\n    dependencies/display-library/include/adl_sdk.h                                              \\\n    dependencies/display-library/include/adl_structures.h                                       \\\n    dependencies/winring0/include/OlsApi.h                                                      \\\n    dependencies/NVFC/nvapi.h                                                                   \\\n    i2c_smbus/i2c_smbus_i801.h                                                                  \\\n    i2c_smbus/i2c_smbus_nct6775.h                                                               \\\n    i2c_smbus/i2c_smbus_nvapi.h                                                                 \\\n    i2c_smbus/i2c_smbus_piix4.h                                                                 \\\n    wmi/wmi.h                                                                                   \\\n    AutoStart/AutoStart-Windows.h                                                               \\\n    SuspendResume/SuspendResume_Windows.h                                                       \\\n\nwin32:contains(QMAKE_TARGET.arch, x86_64) {\n    LIBS +=                                                                                     \\\n        -lws2_32                                                                                \\\n        -liphlpapi                                                                              \\\n        -L\"$$PWD/dependencies/winring0/x64/\" -lWinRing0x64                                      \\\n        -L\"$$PWD/dependencies/libusb-1.0.27/VS2019/MS64/dll\" -llibusb-1.0                       \\\n        -L\"$$PWD/dependencies/hidapi-win/x64/\" -lhidapi                                         \\\n}\n\nwin32:contains(QMAKE_TARGET.arch, x86) {\n    LIBS +=                                                                                     \\\n        -lws2_32                                                                                \\\n        -liphlpapi                                                                              \\\n        -L\"$$PWD/dependencies/winring0/Win32/\" -lWinRing0                                       \\\n        -L\"$$PWD/dependencies/libusb-1.0.27/VS2019/MS32/dll\" -llibusb-1.0                       \\\n        -L\"$$PWD/dependencies/hidapi-win/x86/\" -lhidapi                                         \\\n}\n\nwin32:DEFINES -=                                                                                \\\n    UNICODE\n\nwin32:DEFINES +=                                                                                \\\n    USE_HID_USAGE                                                                               \\\n    _MBCS                                                                                       \\\n    WIN32                                                                                       \\\n    _CRT_SECURE_NO_WARNINGS                                                                     \\\n    _WINSOCK_DEPRECATED_NO_WARNINGS                                                             \\\n    WIN32_LEAN_AND_MEAN                                                                         \\\n\nwin32:RC_ICONS +=                                                                               \\\n    qt/OpenRGB.ico\n\n#-----------------------------------------------------------------------------------------------#\n# Windows GitLab CI Configuration                                                               #\n#-----------------------------------------------------------------------------------------------#\nwin32:CONFIG(debug, debug|release) {\n    win32:DESTDIR = debug\n}\n\nwin32:CONFIG(release, debug|release) {\n    win32:DESTDIR = release\n}\n\nwin32:OBJECTS_DIR = _intermediate_$$DESTDIR/.obj\nwin32:MOC_DIR     = _intermediate_$$DESTDIR/.moc\nwin32:RCC_DIR     = _intermediate_$$DESTDIR/.qrc\nwin32:UI_DIR      = _intermediate_$$DESTDIR/.ui\n\n#-----------------------------------------------------------------------------------------------#\n# Copy dependencies to output directory                                                         #\n#-----------------------------------------------------------------------------------------------#\n\nwin32:contains(QMAKE_TARGET.arch, x86_64) {\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.dll                )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.sys                )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/libusb-1.0.27/VS2019/MS64/dll/libusb-1.0.dll)\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/hidapi-win/x64/hidapi.dll                   )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    first.depends = $(first) copydata\n    export(first.depends)\n    export(copydata.commands)\n    QMAKE_EXTRA_TARGETS += first copydata\n}\n\nwin32:contains(QMAKE_TARGET.arch, x86) {\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/winring0/Win32/WinRing0.dll                 )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/winring0/Win32/WinRing0.sys                 )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.sys                )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/libusb-1.0.27/VS2019/MS32/dll/libusb-1.0.dll)\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n    copydata.commands += $(COPY_FILE) \\\"$$shell_path($$PWD/dependencies/hidapi-win/x86/hidapi.dll                   )\\\" \\\"$$shell_path($$DESTDIR)\\\" $$escape_expand(\\n\\t)\n\n    first.depends = $(first) copydata\n    export(first.depends)\n    export(copydata.commands)\n    QMAKE_EXTRA_TARGETS += first copydata\n}\n\n#-----------------------------------------------------------------------------------------------#\n# Linux-specific Configuration                                                                  #\n#-----------------------------------------------------------------------------------------------#\ncontains(QMAKE_PLATFORM, linux) {\n    CONFIG += link_pkgconfig\n\n    PKGCONFIG +=                                                                                \\\n    libusb-1.0\n\n    TARGET = $$lower($$TARGET)\n\n    HEADERS += $$CONTROLLER_H_LINUX\n\n    HEADERS +=                                                                                  \\\n    dependencies/NVFC/nvapi.h                                                                   \\\n    i2c_smbus/i2c_smbus_linux.h                                                                 \\\n    AutoStart/AutoStart-Linux.h                                                                 \\\n    SPDAccessor/EE1004Accessor_Linux.h                                                          \\\n    SPDAccessor/SPD5118Accessor_Linux.h                                                         \\\n    SuspendResume/SuspendResume_Linux_FreeBSD.h                                                 \\\n\n    INCLUDEPATH +=                                                                              \\\n    dependencies/NVFC                                                                           \\\n    /usr/include/mbedtls2/                                                                      \\\n\n    LIBS +=                                                                                     \\\n    -L/usr/lib/mbedtls2/                                                                        \\\n    -lmbedx509                                                                                  \\\n    -lmbedtls                                                                                   \\\n    -lmbedcrypto                                                                                \\\n    -ldl                                                                                        \\\n\n    COMPILER_VERSION = $$system($$QMAKE_CXX \" -dumpversion\")\n    if (!versionAtLeast(COMPILER_VERSION, \"9\")) {\n         LIBS += -lstdc++fs\n    }\n\n    QT += dbus\n\n    QMAKE_CXXFLAGS += -Wno-implicit-fallthrough -Wno-psabi\n\n    #-------------------------------------------------------------------------------------------#\n    # Determine which hidapi to use based on availability                                       #\n    #   Prefer hidraw backend, then libusb                                                      #\n    #-------------------------------------------------------------------------------------------#\n    packagesExist(hidapi-hidraw) {\n        PKGCONFIG += hidapi-hidraw\n\n        #---------------------------------------------------------------------------------------#\n        # hidapi-hidraw >= 0.10.1 supports USAGE/USAGE_PAGE                                     #\n        # Define USE_HID_USAGE if hidapi-hidraw supports it                                     #\n        #---------------------------------------------------------------------------------------#\n        HIDAPI_HIDRAW_VERSION = $$system($$PKG_CONFIG --modversion hidapi-hidraw)\n        if(versionAtLeast(HIDAPI_HIDRAW_VERSION, \"0.10.1\")) {\n            DEFINES += USE_HID_USAGE\n        }\n    } else {\n        packagesExist(hidapi-libusb) {\n            PKGCONFIG += hidapi-libusb\n        } else {\n            PKGCONFIG += hidapi\n        }\n    }\n\n    SOURCES += $$CONTROLLER_CPP_LINUX\n\n    SOURCES +=                                                                                  \\\n    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \\\n    dependencies/NVFC/nvapi.cpp                                                                 \\\n    i2c_smbus/i2c_smbus_linux.cpp                                                               \\\n    scsiapi/scsiapi_linux.c                                                                     \\\n    serial_port/find_usb_serial_port_linux.cpp                                                  \\\n    AutoStart/AutoStart-Linux.cpp                                                               \\\n    SPDAccessor/EE1004Accessor_Linux.cpp                                                        \\\n    SPDAccessor/SPD5118Accessor_Linux.cpp                                                       \\\n    SuspendResume/SuspendResume_Linux_FreeBSD.cpp                                               \\\n\n    #-------------------------------------------------------------------------------------------#\n    # Set up install paths                                                                      #\n    # These install paths are used for AppImage and .deb packaging                              #\n    #-------------------------------------------------------------------------------------------#\n    isEmpty(PREFIX) {\n        PREFIX = /usr\n    }\n\n    !defined(OPENRGB_SYSTEM_PLUGIN_DIRECTORY, var):OPENRGB_SYSTEM_PLUGIN_DIRECTORY =            \\\n        \"$$PREFIX/lib/openrgb/plugins\"                                                          \\\n\n    DEFINES +=                                                                                  \\\n        OPENRGB_SYSTEM_PLUGIN_DIRECTORY=\\\\\"\\\"\\\"$$OPENRGB_SYSTEM_PLUGIN_DIRECTORY\\\\\"\\\"\\\"         \\\n\n    #-------------------------------------------------------------------------------------------#\n    # Custom target for dynamically created udev_rules                                          #\n    #   Ordinarily you would add the 'udev_rules' target to both QMAKE_EXTRA_TARGETS to add a   #\n    #   rule in the Makefile and PRE_TARGETDEPS to ensure it is a dependency of the TARGET      #\n    #                                                                                           #\n    #   ie. QMAKE_EXTRA_TARGETS += udev_rules                                                   #\n    #       PRE_TARGETDEPS      += udev_rules                                                   #\n    #-------------------------------------------------------------------------------------------#\n    CONFIG(release, debug|release) {\n        udev_rules.CONFIG       = no_check_exist\n        udev_rules.target       = 60-openrgb.rules\n        udev_rules.path         = $$PREFIX/lib/udev/rules.d/\n\n        exists($$udev_rules.target) {\n            message($$udev_rules.target \" - UDEV rules file exists. Removing from build\")\n            udev_rules.files    = $$udev_rules.target\n        } else {\n            message($$udev_rules.target \" - UDEV rules file missing. Adding script to build\")\n            #-----------------------------------------------------------------------------------#\n            # This is a compiler config flag to save the preproccessed .ii & .s                 #\n            #   files so as to automatically process the UDEV rules and the Supported Devices   #\n            #-----------------------------------------------------------------------------------#\n            QMAKE_CXXFLAGS+=-save-temps\n            QMAKE_CXXFLAGS-=-pipe\n            udev_rules.extra    = $$PWD/scripts/build-udev-rules.sh $$PWD $$GIT_COMMIT_ID\n            udev_rules.files    = $$OUT_PWD/60-openrgb.rules\n        }\n    }\n\n    #-------------------------------------------------------------------------------------------#\n    # Add static files to installation                                                          #\n    #-------------------------------------------------------------------------------------------#\n    target.path=$$PREFIX/bin/\n    desktop.path=$$PREFIX/share/applications/\n    desktop.files+=qt/org.openrgb.OpenRGB.desktop\n    icon.path=$$PREFIX/share/icons/hicolor/128x128/apps/\n    icon.files+=qt/org.openrgb.OpenRGB.png\n    metainfo.path=$$PREFIX/share/metainfo/\n    metainfo.files+=qt/org.openrgb.OpenRGB.metainfo.xml\n    INSTALLS += target desktop icon metainfo udev_rules\n}\n\n#-----------------------------------------------------------------------------------------------#\n# FreeBSD-specific Configuration                                                                #\n#-----------------------------------------------------------------------------------------------#\ncontains(QMAKE_PLATFORM, freebsd) {\n    CONFIG += link_pkgconfig\n\n    PKGCONFIG +=                                                                                \\\n    libusb-1.0\n\n    TARGET = $$lower($$TARGET)\n\n    HEADERS += $$CONTROLLER_H_FREEBSD\n\n    HEADERS +=                                                                                  \\\n    AutoStart/AutoStart-FreeBSD.h                                                               \\\n    SuspendResume/SuspendResume_Linux_FreeBSD.h                                                 \\\n\n    HEADERS -=                                                                                  \\\n    Controllers/SeagateController/RGBController_Seagate.h                                       \\\n    Controllers/SeagateController/SeagateController.h                                           \\\n    Controllers/ENESMBusController/ENESMBusInterface/ENESMBusInterface_ROGArion.h               \\\n    $$CONTROLLER_H_WINDOWS                                                                      \\\n\n    LIBS +=                                                                                     \\\n    -lmbedx509                                                                                  \\\n    -lmbedtls                                                                                   \\\n    -lmbedcrypto                                                                                \\\n\n    COMPILER_VERSION = $$system($$QMAKE_CXX \" -dumpversion\")\n    if (!versionAtLeast(COMPILER_VERSION, \"9\")) {\n         LIBS += -lstdc++fs\n    }\n\n    QT += dbus\n\n    #-------------------------------------------------------------------------------------------#\n    # Determine which hidapi to use based on availability                                       #\n    #   Prefer hidraw backend, then libusb                                                      #\n    #-------------------------------------------------------------------------------------------#\n    packagesExist(hidapi-hidraw) {\n        PKGCONFIG += hidapi-hidraw\n\n        #---------------------------------------------------------------------------------------#\n        # hidapi-hidraw >= 0.10.1 supports USAGE/USAGE_PAGE                                     #\n        # Define USE_HID_USAGE if hidapi-hidraw supports it                                     #\n        #---------------------------------------------------------------------------------------#\n        packagesExist(hidapi-hidraw>=0.10.1) {\n            DEFINES += USE_HID_USAGE\n        }\n    } else {\n        packagesExist(hidapi-libusb) {\n            PKGCONFIG += hidapi-libusb\n        } else {\n            PKGCONFIG += hidapi\n        }\n    }\n\n    SOURCES += $$CONTROLLER_CPP_FREEBSD\n\n    SOURCES +=                                                                                  \\\n    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \\\n    serial_port/find_usb_serial_port_linux.cpp                                                  \\\n    AutoStart/AutoStart-FreeBSD.cpp                                                             \\\n    SuspendResume/SuspendResume_Linux_FreeBSD.cpp                                               \\\n\n    SOURCES -=                                                                                  \\\n    Controllers/SeagateController/RGBController_Seagate.cpp                                     \\\n    Controllers/SeagateController/SeagateController.cpp                                         \\\n    Controllers/SeagateController/SeagateControllerDetect.cpp                                   \\\n    Controllers/ENESMBusController/ROGArionDetect.cpp                                           \\\n    Controllers/ENESMBusController/ENESMBusInterface/ENESMBusInterface_ROGArion.cpp             \\\n\n    #-------------------------------------------------------------------------------------------#\n    # Set up install paths                                                                      #\n    # These install paths are used for AppImage and .deb packaging                              #\n    #-------------------------------------------------------------------------------------------#\n    isEmpty(PREFIX) {\n        PREFIX = /usr\n    }\n\n    target.path=$$PREFIX/bin/\n    desktop.path=$$PREFIX/share/applications/\n    desktop.files+=qt/org.openrgb.OpenRGB.desktop\n    icon.path=$$PREFIX/share/icons/hicolor/128x128/apps/\n    icon.files+=qt/org.openrgb.OpenRGB.png\n    metainfo.path=$$PREFIX/share/metainfo/\n    metainfo.files+=qt/org.openrgb.OpenRGB.metainfo.xml\n    rules.path=$$PREFIX/lib/udev/rules.d/\n    rules.files+=60-openrgb.rules\n    INSTALLS += target desktop icon metainfo rules\n}\n\nunix:!macx:CONFIG(asan) {\n    message(\"ASan Mode\")\n    QMAKE_CFLAGS=-fsanitize=address\n    QMAKE_CXXFLAGS=-fsanitize=address\n    QMAKE_LFLAGS=-fsanitize=address\n}\n\n#-----------------------------------------------------------------------------------------------#\n# MacOS-specific Configuration                                                                  #\n#-----------------------------------------------------------------------------------------------#\nQMAKE_MACOSX_DEPLOYMENT_TARGET = 10.15\n\n#-----------------------------------------------------------------------------------------------#\n# Common MacOS definitions                                                                      #\n#-----------------------------------------------------------------------------------------------#\nmacx {\n    CONFIG += link_pkgconfig\n\n    PKGCONFIG +=                                                                                \\\n    libusb-1.0                                                                                  \\\n    hidapi\n\n    DEFINES +=                                                                                  \\\n    USE_HID_USAGE                                                                               \\\n\n    QMAKE_CXXFLAGS +=                                                                           \\\n    -Wno-narrowing                                                                              \\\n\n    HEADERS +=                                                                                  \\\n    AutoStart/AutoStart-MacOS.h                                                                 \\\n    qt/macutils.h                                                                               \\\n    SuspendResume/SuspendResume_MacOS.h                                                         \\\n\n    HEADERS += $$CONTROLLER_H_MACOS\n\n    SOURCES +=                                                                                  \\\n    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \\\n    serial_port/find_usb_serial_port_macos.cpp                                                  \\\n    AutoStart/AutoStart-MacOS.cpp                                                               \\\n    qt/macutils.mm                                                                              \\\n    SuspendResume/SuspendResume_MacOS.cpp                                                       \\\n\n    SOURCES += $$CONTROLLER_CPP_MACOS\n\n    # Use mbedtls v2 instead of latest\n    MBEDTLS_PREFIX = $$system(brew --prefix mbedtls@2)\n\n    INCLUDEPATH +=                                                                              \\\n    $$MBEDTLS_PREFIX/include                                                                    \\\n\n    LIBS +=                                                                                     \\\n    -lmbedx509                                                                                  \\\n    -lmbedcrypto                                                                                \\\n    -lmbedtls                                                                                   \\\n    -L$$MBEDTLS_PREFIX/lib\n\n    ICON = qt/OpenRGB.icns\n\n    info_plist.input = mac/Info.plist.in\n    info_plist.output = $$OUT_PWD/Info.plist\n    QMAKE_SUBSTITUTES += info_plist\n    QMAKE_INFO_PLIST = $$OUT_PWD/Info.plist\n}\n\n#-----------------------------------------------------------------------------------------------#\n# Apple Silicon (arm64) Homebrew installs at /opt/homebrew                                      #\n#-----------------------------------------------------------------------------------------------#\nmacx:contains(QMAKE_HOST.arch, arm64) {\n    INCLUDEPATH +=                                                                              \\\n    /opt/homebrew/include                                                                       \\\n\n    SOURCES +=                                                                                  \\\n    scsiapi/scsiapi_macos.c                                                                     \\\n\n    LIBS +=                                                                                     \\\n    -L/opt/homebrew/lib                                                                         \\\n}\n\n#-----------------------------------------------------------------------------------------------#\n# Intel (x86_64) Homebrew installs at /usr/local/lib                                            #\n#-----------------------------------------------------------------------------------------------#\nmacx:contains(QMAKE_HOST.arch, x86_64) {\n    INCLUDEPATH +=                                                                              \\\n    dependencies/macUSPCIO                                                                      \\\n    /usr/local/include                                                                          \\\n    /usr/local/homebrew/include                                                                 \\\n\n    SOURCES +=                                                                                  \\\n    i2c_smbus/i2c_smbus_i801.cpp                                                                \\\n    scsiapi/scsiapi_macos.c                                                                     \\\n\n    HEADERS +=                                                                                  \\\n    dependencies/macUSPCIO/macUSPCIOAccess.h                                                    \\\n    i2c_smbus/i2c_smbus_i801.h                                                                  \\\n\n    LIBS +=                                                                                     \\\n    -L/usr/local/lib                                                                            \\\n    -L/usr/local/homebrew/lib                                                                   \\\n\n    DEFINES +=                                                                                  \\\n    _MACOSX_X86_X64                                                                             \\\n}\n\nDISTFILES += \\\n    debian/openrgb-udev.postinst \\\n    debian/openrgb.postinst\n"
        },
        {
          "name": "OpenRGBPluginInterface.h",
          "type": "blob",
          "size": 5.6298828125,
          "content": "/*---------------------------------------------------------*\\\n| OpenRGBPluginInterface.h                                  |\n|                                                           |\n|   OpenRGB SDK network protocol                            |\n|                                                           |\n|   herosilas12 (CoffeeIsLife)                  11 Dec 2020 |\n|   Adam Honse (CalcProgrammer1)                05 Jan 2021 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <QtPlugin>\n#include <QLabel>\n#include <QMenu>\n#include \"ResourceManager.h\"\n\n#define OpenRGBPluginInterface_IID  \"com.OpenRGBPluginInterface\"\n\n/*-----------------------------------------------------------------------------------------------------*\\\n| OpenRGB Plugin API Versions                                                                           |\n| 0:    OpenRGB 0.6     Unversioned, early plugin API.                                                  |\n| 1:    OpenRGB 0.61    First versioned API, introduced with plugin settings changes                    |\n| 2:    OpenRGB 0.7     First released versioned API, callback unregister functions in ResourceManager  |\n| 3:    OpenRGB 0.9     Use filesystem::path for paths, Added segments                                  |\n\\*-----------------------------------------------------------------------------------------------------*/\n#define OPENRGB_PLUGIN_API_VERSION  3\n\n/*-----------------------------------------------------------------------------------------------------*\\\n| Plugin Tab Location Values                                                                            |\n\\*-----------------------------------------------------------------------------------------------------*/\nenum\n{\n    OPENRGB_PLUGIN_LOCATION_TOP         = 0,    /* Top-level tab (no icon)                             */\n    OPENRGB_PLUGIN_LOCATION_DEVICES     = 1,    /* Devices tab                                         */\n    OPENRGB_PLUGIN_LOCATION_INFORMATION = 2,    /* Information tab                                     */\n    OPENRGB_PLUGIN_LOCATION_SETTINGS    = 3,    /* Settings tab                                        */\n};\n\nstruct OpenRGBPluginInfo\n{\n    /*-------------------------------------------------------------------------------------------------*\\\n    | Plugin Details                                                                                    |\n    \\*-------------------------------------------------------------------------------------------------*/\n    std::string                 Name;           /* Plugin name string                                  */\n    std::string                 Description;    /* Plugin description string                           */\n    std::string                 Version;        /* Plugin version string                               */\n    std::string                 Commit;         /* Plugin commit (git or otherwise) string             */\n    std::string                 URL;            /* Plugin project URL string                           */\n    QImage                      Icon;           /* Icon image (displayed 64x64)                        */\n\n    /*-------------------------------------------------------------------------------------------------*\\\n    | Plugin Tab Configuration                                                                          |\n    \\*-------------------------------------------------------------------------------------------------*/\n    unsigned int                Location;       /* Plugin tab location from Plugin Tab Location enum   */\n                                                /* This field is mandatory, an invalid value will      */\n                                                /* prevent plugin tab from being displayed             */\n    std::string                 Label;          /* Plugin tab label string                             */\n    std::string                 TabIconString;  /* Plugin tab icon string, leave empty to use custom   */\n    QImage                      TabIcon;        /* Custom tab icon image (displayed 16x16)             */\n};\n\nclass OpenRGBPluginInterface\n{\npublic:\n    virtual                    ~OpenRGBPluginInterface() {}\n\n    /*-------------------------------------------------------------------------------------------------*\\\n    | Plugin Information                                                                                |\n    \\*-------------------------------------------------------------------------------------------------*/\n    virtual OpenRGBPluginInfo   GetPluginInfo()                                                     = 0;\n    virtual unsigned int        GetPluginAPIVersion()                                               = 0;\n\n    /*-------------------------------------------------------------------------------------------------*\\\n    | Plugin Functionality                                                                              |\n    \\*-------------------------------------------------------------------------------------------------*/\n    virtual void                Load(bool dark_theme, ResourceManager* resource_manager_ptr)        = 0;\n    virtual QWidget*            GetWidget()                                                         = 0;\n    virtual QMenu*              GetTrayMenu()                                                       = 0;\n    virtual void                Unload()                                                            = 0;\n};\n\nQ_DECLARE_INTERFACE(OpenRGBPluginInterface, OpenRGBPluginInterface_IID)\n"
        },
        {
          "name": "PluginManager.cpp",
          "type": "blob",
          "size": 19.2724609375,
          "content": "/*---------------------------------------------------------*\\\n| PluginManager.cpp                                         |\n|                                                           |\n|   OpenRGB plugin manager                                  |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include \"LogManager.h\"\n#include \"filesystem.h\"\n#include \"PluginManager.h\"\n#include \"OpenRGBThemeManager.h\"\n#include \"SettingsManager.h\"\n\nPluginManager::PluginManager()\n{\n    /*---------------------------------------------------------*\\\n    | Initialize plugin manager class variables                 |\n    \\*---------------------------------------------------------*/\n    AddPluginCallbackVal    = nullptr;\n    AddPluginCallbackArg    = nullptr;\n    RemovePluginCallbackVal = nullptr;\n    RemovePluginCallbackArg = nullptr;\n\n    /*-------------------------------------------------------------------------*\\\n    | Create OpenRGB plugins directory                                          |\n    \\*-------------------------------------------------------------------------*/\n    filesystem::path plugins_dir = ResourceManager::get()->GetConfigurationDirectory() / plugins_path;\n\n    filesystem::create_directories(plugins_dir);\n}\n\nvoid PluginManager::RegisterAddPluginCallback(AddPluginCallback new_callback, void * new_callback_arg)\n{\n    AddPluginCallbackVal    = new_callback;\n    AddPluginCallbackArg    = new_callback_arg;\n}\n\nvoid PluginManager::RegisterRemovePluginCallback(RemovePluginCallback new_callback, void * new_callback_arg)\n{\n    RemovePluginCallbackVal = new_callback;\n    RemovePluginCallbackArg = new_callback_arg;\n}\n\nvoid PluginManager::ScanAndLoadPlugins()\n{\n    /*---------------------------------------------------------*\\\n    | Get the user plugins directory                            |\n    |                                                           |\n    | The user plugins directory is a directory named \"plugins\" |\n    | in the configuration directory                            |\n    \\*---------------------------------------------------------*/\n    filesystem::path plugins_dir = ResourceManager::get()->GetConfigurationDirectory() / plugins_path;\n    ScanAndLoadPluginsFrom(plugins_dir, false);\n\n#ifdef OPENRGB_SYSTEM_PLUGIN_DIRECTORY\n    /*---------------------------------------------------------*\\\n    | Get the system plugins directory                          |\n    |                                                           |\n    | The system plugin directory can be set during build time, |\n    | e.g. by the package maintainer to load plugins installed  |\n    | via package manager                                       |\n    \\*---------------------------------------------------------*/\n    ScanAndLoadPluginsFrom(OPENRGB_SYSTEM_PLUGIN_DIRECTORY, true);\n#endif\n}\n\nvoid PluginManager::ScanAndLoadPluginsFrom(const filesystem::path & plugins_dir, bool is_system)\n{\n    if(is_system)\n    {\n        LOG_TRACE(\"[PluginManager] Scanning system plugin directory: %s\", plugins_dir.generic_u8string().c_str());\n    }\n    else\n    {\n        LOG_TRACE(\"[PluginManager] Scanning user plugin directory: %s\", plugins_dir.generic_u8string().c_str());\n    }\n\n    if(!filesystem::is_directory(plugins_dir))\n    {\n        return;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Get a list of all files in the plugins directory          |\n    \\*---------------------------------------------------------*/\n\n    for(const filesystem::directory_entry& entry: filesystem::directory_iterator(plugins_dir))\n    {\n        if(filesystem::is_directory(entry.path()))\n        {\n            continue;\n        }\n\n        filesystem::path plugin_path = entry.path();\n        LOG_TRACE(\"[PluginManager] Found plugin file %s\", plugin_path.filename().generic_u8string().c_str());\n        AddPlugin(plugin_path, is_system);\n    }\n}\n\nvoid PluginManager::AddPlugin(const filesystem::path& path, bool is_system)\n{\n    OpenRGBPluginInterface* plugin = nullptr;\n\n    unsigned int plugin_idx;\n\n    /*---------------------------------------------------------------------*\\\n    | Search active plugins to see if this path already exists              |\n    \\*---------------------------------------------------------------------*/\n    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)\n    {\n        if(path == ActivePlugins[plugin_idx].path)\n        {\n            break;\n        }\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the path does not match an existing entry, create a new entry      |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_idx == ActivePlugins.size())\n    {\n        /*-----------------------------------------------------------------*\\\n        | Create a QPluginLoader and load the plugin                        |\n        \\*-----------------------------------------------------------------*/\n        std::string     path_string = path.generic_u8string();\n        QPluginLoader*  loader      = new QPluginLoader(QString::fromStdString(path_string));\n        QObject*        instance    = loader->instance();\n\n        if(!loader->isLoaded())\n        {\n            LOG_WARNING(\"[PluginManager] Plugin %s cannot be loaded: %s\", path.c_str(), loader->errorString().toStdString().c_str());\n        }\n\n        /*-----------------------------------------------------------------*\\\n        | Check that the plugin is valid, then check the API version        |\n        \\*-----------------------------------------------------------------*/\n        if(instance)\n        {\n            plugin = qobject_cast<OpenRGBPluginInterface*>(instance);\n\n            if(plugin)\n            {\n                if(plugin->GetPluginAPIVersion() == OPENRGB_PLUGIN_API_VERSION)\n                {\n                    LOG_TRACE(\"[PluginManager] Plugin %s has a compatible API version\", path.c_str());\n\n                    /*-----------------------------------------------------*\\\n                    | Get the plugin information                            |\n                    \\*-----------------------------------------------------*/\n                    OpenRGBPluginInfo info = plugin->GetPluginInfo();\n\n                    /*-----------------------------------------------------*\\\n                    | Search the settings to see if it is enabled           |\n                    \\*-----------------------------------------------------*/\n                    std::string     name        = \"\";\n                    std::string     description = \"\";\n                    bool            enabled     = true;\n                    bool            found       = false;\n                    unsigned int    plugin_ct   = 0;\n\n                    /*-----------------------------------------------------*\\\n                    | Open plugin list and check if plugin is in the list   |\n                    \\*-----------------------------------------------------*/\n                    json plugin_settings = ResourceManager::get()->GetSettingsManager()->GetSettings(\"Plugins\");\n\n                    if(plugin_settings.contains(\"plugins\"))\n                    {\n                        plugin_ct = (unsigned int)plugin_settings[\"plugins\"].size();\n\n                        for(unsigned int plugin_settings_idx = 0; plugin_settings_idx < plugin_settings[\"plugins\"].size(); plugin_settings_idx++)\n                        {\n                            if(plugin_settings[\"plugins\"][plugin_settings_idx].contains(\"name\"))\n                            {\n                                name        = plugin_settings[\"plugins\"][plugin_settings_idx][\"name\"];\n                            }\n\n                            if(plugin_settings[\"plugins\"][plugin_settings_idx].contains(\"description\"))\n                            {\n                                description = plugin_settings[\"plugins\"][plugin_settings_idx][\"description\"];\n                            }\n\n                            if(plugin_settings[\"plugins\"][plugin_settings_idx].contains(\"enabled\"))\n                            {\n                                enabled     = plugin_settings[\"plugins\"][plugin_settings_idx][\"enabled\"];\n                            }\n\n                            if((info.Name == name)\n                             &&(info.Description == description))\n                            {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    /*-----------------------------------------------------*\\\n                    | If the plugin was not in the list, add it to the list |\n                    | and default it to enabled, then save the settings     |\n                    \\*-----------------------------------------------------*/\n                    if(!found)\n                    {\n                        plugin_settings[\"plugins\"][plugin_ct][\"name\"]           = info.Name;\n                        plugin_settings[\"plugins\"][plugin_ct][\"description\"]    = info.Description;\n                        plugin_settings[\"plugins\"][plugin_ct][\"enabled\"]        = enabled;\n\n                        ResourceManager::get()->GetSettingsManager()->SetSettings(\"Plugins\", plugin_settings);\n                        ResourceManager::get()->GetSettingsManager()->SaveSettings();\n                    }\n\n                    LOG_VERBOSE(\"[PluginManager] Loaded plugin %s\", info.Name.c_str());\n\n                    /*-----------------------------------------------------*\\\n                    | Add the plugin to the PluginManager active plugins    |\n                    \\*-----------------------------------------------------*/\n                    OpenRGBPluginEntry entry;\n\n                    entry.info          = info;\n                    entry.plugin        = plugin;\n                    entry.loader        = loader;\n                    entry.path          = path_string;\n                    entry.enabled       = enabled;\n                    entry.widget        = nullptr;\n                    entry.incompatible  = false;\n                    entry.api_version   = plugin->GetPluginAPIVersion();\n                    entry.is_system     = is_system;\n\n                    loader->unload();\n\n                    ActivePlugins.push_back(entry);\n\n                    if(entry.enabled)\n                    {\n                        LoadPlugin(&ActivePlugins.back());\n                    }\n                }\n                else\n                {\n                    /*-----------------------------------------------------*\\\n                    | Fill in a plugin information object with text showing |\n                    | the plugin is incompatible                            |\n                    \\*-----------------------------------------------------*/\n                    OpenRGBPluginInfo info;\n\n                    info.Name           = \"Incompatible Plugin\";\n                    info.Description    = \"This plugin is not compatible with this version of OpenRGB.\";\n\n                    /*-----------------------------------------------------*\\\n                    | Add the plugin to the PluginManager active plugins    |\n                    | but mark it as incompatible                           |\n                    \\*-----------------------------------------------------*/\n                    OpenRGBPluginEntry entry;\n\n                    entry.info          = info;\n                    entry.plugin        = plugin;\n                    entry.loader        = loader;\n                    entry.path          = path_string;\n                    entry.enabled       = false;\n                    entry.widget        = nullptr;\n                    entry.incompatible  = true;\n                    entry.api_version   = plugin->GetPluginAPIVersion();\n\n                    loader->unload();\n\n                    PluginManager::ActivePlugins.push_back(entry);\n\n                    bool unloaded = loader->unload();\n\n                    LOG_WARNING(\"[PluginManager] Plugin %s has an incompatible API version\", path.c_str());\n\n                    if(!unloaded)\n                    {\n                        LOG_WARNING(\"[PluginManager] Plugin %s cannot be unloaded\", path.c_str());\n                    }\n                }\n            }\n            else\n            {\n                LOG_WARNING(\"[PluginManager] Plugin %s cannot be casted to OpenRGBPluginInterface\", path.c_str());\n            }\n        }\n        else\n        {\n            LOG_WARNING(\"[PluginManager] Plugin %s cannot be instantiated.\", path.c_str());\n        }\n    }\n}\n\nvoid PluginManager::RemovePlugin(const filesystem::path& path)\n{\n    unsigned int plugin_idx;\n\n    LOG_TRACE(\"[PluginManager] Attempting to remove plugin %s\", path.c_str());\n\n    /*---------------------------------------------------------------------*\\\n    | Search active plugins to see if this path already exists              |\n    \\*---------------------------------------------------------------------*/\n    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)\n    {\n        if(path == ActivePlugins[plugin_idx].path)\n        {\n            break;\n        }\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the plugin path does not exist in the active plugins list, return  |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_idx == ActivePlugins.size())\n    {\n        LOG_TRACE(\"[PluginManager] Plugin %s not active\", path.c_str());\n        return;\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the selected plugin is in the list and loaded, unload it           |\n    \\*---------------------------------------------------------------------*/\n    if(ActivePlugins[plugin_idx].loader->isLoaded())\n    {\n        LOG_TRACE(\"[PluginManager] Plugin %s is active, unloading\", path.c_str());\n        UnloadPlugin(&ActivePlugins[plugin_idx]);\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | Remove the plugin from the active plugins list                        |\n    \\*---------------------------------------------------------------------*/\n    ActivePlugins.erase(ActivePlugins.begin() + plugin_idx);\n}\n\nvoid PluginManager::EnablePlugin(const filesystem::path& path)\n{\n    unsigned int plugin_idx;\n\n    /*---------------------------------------------------------------------*\\\n    | Search active plugins to see if this path already exists              |\n    \\*---------------------------------------------------------------------*/\n    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)\n    {\n        if(path == ActivePlugins[plugin_idx].path)\n        {\n            break;\n        }\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the plugin path does not exist in the active plugins list, return  |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_idx == ActivePlugins.size())\n    {\n        return;\n    }\n\n    ActivePlugins[plugin_idx].enabled = true;\n    LoadPlugin(&ActivePlugins[plugin_idx]);\n}\n\nvoid PluginManager::LoadPlugin(OpenRGBPluginEntry* plugin_entry)\n{\n    /*---------------------------------------------------------------------*\\\n    | If the plugin is in the list but is incompatible, return              |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_entry->incompatible)\n    {\n        return;\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the selected plugin is in the list but not loaded, load it         |\n    \\*---------------------------------------------------------------------*/\n    if(!plugin_entry->loader->isLoaded())\n    {\n        plugin_entry->loader->load();\n\n        QObject* instance                = plugin_entry->loader->instance();\n\n        bool dark_theme = OpenRGBThemeManager::IsDarkTheme();\n\n        if(instance)\n        {\n            OpenRGBPluginInterface* plugin = qobject_cast<OpenRGBPluginInterface*>(instance);\n\n            if(plugin)\n            {\n                if(plugin->GetPluginAPIVersion() == OPENRGB_PLUGIN_API_VERSION)\n                {\n                    plugin_entry->plugin = plugin;\n\n                    plugin->Load(dark_theme, ResourceManager::get());\n\n                    /*-------------------------------------------------*\\\n                    | Call the Add Plugin callback                      |\n                    \\*-------------------------------------------------*/\n                    if(AddPluginCallbackArg != nullptr)\n                    {\n                        AddPluginCallbackVal(AddPluginCallbackArg, plugin_entry);\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid PluginManager::DisablePlugin(const filesystem::path& path)\n{\n    unsigned int plugin_idx;\n\n    /*---------------------------------------------------------------------*\\\n    | Search active plugins to see if this path already exists              |\n    \\*---------------------------------------------------------------------*/\n    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)\n    {\n        if(path == ActivePlugins[plugin_idx].path)\n        {\n            break;\n        }\n    }\n\n    /*---------------------------------------------------------------------*\\\n    | If the plugin path does not exist in the active plugins list, return  |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_idx == ActivePlugins.size())\n    {\n        return;\n    }\n\n    ActivePlugins[plugin_idx].enabled = false;\n    UnloadPlugin(&ActivePlugins[plugin_idx]);\n}\n\nvoid PluginManager::UnloadPlugin(OpenRGBPluginEntry* plugin_entry)\n{\n    /*---------------------------------------------------------------------*\\\n    | If the selected plugin is in the list and loaded, unload it           |\n    \\*---------------------------------------------------------------------*/\n    if(plugin_entry->loader->isLoaded())\n    {\n        /*-------------------------------------------------*\\\n        | Call plugin's Unload function before GUI removal  |\n        \\*-------------------------------------------------*/\n        plugin_entry->plugin->Unload();\n\n        /*-------------------------------------------------*\\\n        | Call the Remove Plugin callback                   |\n        \\*-------------------------------------------------*/\n        if(RemovePluginCallbackVal != nullptr)\n        {\n            RemovePluginCallbackVal(RemovePluginCallbackArg, plugin_entry);\n        }\n\n        bool unloaded = plugin_entry->loader->unload();\n\n        if(!unloaded)\n        {\n            LOG_WARNING(\"[PluginManager] Plugin %s cannot be unloaded\", plugin_entry->path.c_str());\n        }\n        else\n        {\n            LOG_TRACE(\"[PluginManager] Plugin %s successfully unloaded\", plugin_entry->path.c_str());\n        }\n    }\n    else\n    {\n        LOG_TRACE(\"[PluginManager] Plugin %s was already unloaded\", plugin_entry->path.c_str());\n    }\n}\n\nvoid PluginManager::LoadPlugins()\n{\n    for(OpenRGBPluginEntry& plugin_entry: ActivePlugins)\n    {\n        if(plugin_entry.enabled)\n        {\n            LoadPlugin(&plugin_entry);\n        }\n    }\n}\n\nvoid PluginManager::UnloadPlugins()\n{\n    for(OpenRGBPluginEntry& plugin_entry: ActivePlugins)\n    {\n        UnloadPlugin(&plugin_entry);\n    }\n}\n"
        },
        {
          "name": "PluginManager.h",
          "type": "blob",
          "size": 2.29296875,
          "content": "/*---------------------------------------------------------*\\\n| PluginManager.h                                           |\n|                                                           |\n|   OpenRGB plugin manager                                  |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <string>\n#include <iostream>\n#include <QPluginLoader>\n#include <QLabel>\n#include <QtPlugin>\n#include <QDir>\n#include \"OpenRGBPluginInterface.h\"\n\ntypedef struct\n{\n    OpenRGBPluginInfo           info;\n    OpenRGBPluginInterface*     plugin;\n    QPluginLoader*              loader;\n    QWidget*                    widget;\n    QMenu*                      traymenu;\n    std::string                 path;\n    bool                        enabled;\n    bool                        incompatible;\n    bool                        is_system;\n    int                         api_version;\n} OpenRGBPluginEntry;\n\ntypedef void (*AddPluginCallback)(void *, OpenRGBPluginEntry* plugin);\ntypedef void (*RemovePluginCallback)(void *, OpenRGBPluginEntry* plugin);\n\nclass PluginManager\n{\npublic:\n    PluginManager();\n\n    void RegisterAddPluginCallback(AddPluginCallback new_callback, void * new_callback_arg);\n    void RegisterRemovePluginCallback(RemovePluginCallback new_callback, void * new_callback_arg);\n\n    void ScanAndLoadPlugins();\n\n    void AddPlugin(const filesystem::path& path, bool is_system);\n    void RemovePlugin(const filesystem::path& path);\n\n    void EnablePlugin(const filesystem::path& path);\n    void DisablePlugin(const filesystem::path& path);\n\n    void LoadPlugins();\n    void UnloadPlugins();\n\n    std::vector<OpenRGBPluginEntry> ActivePlugins;\n\nprivate:\n    void LoadPlugin(OpenRGBPluginEntry* plugin_entry);\n    void UnloadPlugin(OpenRGBPluginEntry* plugin_entry);\n\n    void ScanAndLoadPluginsFrom(const filesystem::path & plugins_dir, bool is_system);\n\n    AddPluginCallback       AddPluginCallbackVal;\n    void *                  AddPluginCallbackArg;\n\n    RemovePluginCallback    RemovePluginCallbackVal;\n    void *                  RemovePluginCallbackArg;\n\n    const char *            plugins_path = \"plugins/\";\n};\n"
        },
        {
          "name": "ProfileManager.cpp",
          "type": "blob",
          "size": 23.4951171875,
          "content": "/*---------------------------------------------------------*\\\n| ProfileManager.cpp                                        |\n|                                                           |\n|   OpenRGB profile manager                                 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <fstream>\n#include <iostream>\n#include <cstring>\n#include \"ProfileManager.h\"\n#include \"ResourceManager.h\"\n#include \"RGBController_Dummy.h\"\n#include \"LogManager.h\"\n#include \"NetworkProtocol.h\"\n#include \"filesystem.h\"\n#include \"StringUtils.h\"\n\n#define OPENRGB_PROFILE_HEADER  \"OPENRGB_PROFILE\"\n#define OPENRGB_PROFILE_VERSION OPENRGB_SDK_PROTOCOL_VERSION\n\nProfileManager::ProfileManager(const filesystem::path& config_dir)\n{\n    configuration_directory = config_dir;\n    UpdateProfileList();\n}\n\nProfileManager::~ProfileManager()\n{\n\n}\n\nbool ProfileManager::SaveProfile(std::string profile_name, bool sizes)\n{\n    profile_name = StringUtils::remove_null_terminating_chars(profile_name);\n\n    /*---------------------------------------------------------*\\\n    | Get the list of controllers from the resource manager     |\n    \\*---------------------------------------------------------*/\n    std::vector<RGBController *> controllers = ResourceManager::get()->GetRGBControllers();\n\n    /*---------------------------------------------------------*\\\n    | If a name was entered, save the profile file              |\n    \\*---------------------------------------------------------*/\n    if(profile_name != \"\")\n    {\n        /*---------------------------------------------------------*\\\n        | Extension .orp - OpenRgb Profile                          |\n        \\*---------------------------------------------------------*/\n        std::string filename = profile_name;\n\n        /*---------------------------------------------------------*\\\n        | Determine file extension                                  |\n        \\*---------------------------------------------------------*/\n        if(sizes)\n        {\n            filename += \".ors\";\n        }\n        else\n        {\n            filename += \".orp\";\n        }\n\n        /*---------------------------------------------------------*\\\n        | Open an output file in binary mode                        |\n        \\*---------------------------------------------------------*/\n        filesystem::path profile_path = configuration_directory / filesystem::u8path(filename);\n        std::ofstream controller_file(profile_path, std::ios::out | std::ios::binary | std::ios::trunc);\n\n        /*---------------------------------------------------------*\\\n        | Write header                                              |\n        | 16 bytes - \"OPENRGB_PROFILE\"                              |\n        | 4 bytes - Version, unsigned int                           |\n        \\*---------------------------------------------------------*/\n        unsigned int profile_version = OPENRGB_PROFILE_VERSION;\n        controller_file.write(OPENRGB_PROFILE_HEADER, 16);\n        controller_file.write((char *)&profile_version, sizeof(unsigned int));\n\n        /*---------------------------------------------------------*\\\n        | Write controller data for each controller                 |\n        \\*---------------------------------------------------------*/\n        for(std::size_t controller_index = 0; controller_index < controllers.size(); controller_index++)\n        {\n            unsigned char *controller_data = controllers[controller_index]->GetDeviceDescription(profile_version);\n            unsigned int controller_size;\n\n            memcpy(&controller_size, controller_data, sizeof(controller_size));\n\n            controller_file.write((const char *)controller_data, controller_size);\n\n            delete[] controller_data;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Close the file when done                                  |\n        \\*---------------------------------------------------------*/\n        controller_file.close();\n\n        /*---------------------------------------------------------*\\\n        | Update the profile list                                   |\n        \\*---------------------------------------------------------*/\n        UpdateProfileList();\n\n        return(true);\n    }\n    else\n    {\n        return(false);\n    }\n}\n\nvoid ProfileManager::SetConfigurationDirectory(const filesystem::path& directory)\n{\n    configuration_directory = directory;\n    UpdateProfileList();\n}\n\nbool ProfileManager::LoadProfile(std::string profile_name)\n{\n    profile_name = StringUtils::remove_null_terminating_chars(profile_name);\n    return(LoadProfileWithOptions(profile_name, false, true));\n}\n\nbool ProfileManager::LoadSizeFromProfile(std::string profile_name)\n{\n    profile_name = StringUtils::remove_null_terminating_chars(profile_name);\n    return(LoadProfileWithOptions(profile_name, true, false));\n}\n\nstd::vector<RGBController*> ProfileManager::LoadProfileToList\n    (\n    std::string     profile_name,\n    bool            sizes\n    )\n{\n    std::vector<RGBController*> temp_controllers;\n    unsigned int                controller_size;\n    unsigned int                controller_offset = 0;\n\n    filesystem::path filename = configuration_directory / filesystem::u8path(profile_name);\n\n    /*---------------------------------------------------------*\\\n    | Determine file extension                                  |\n    \\*---------------------------------------------------------*/\n    if(sizes)\n    {\n        filename.concat(\".ors\");\n    }\n    else\n    {\n        if(filename.extension() != \".orp\")\n        {\n            filename.concat(\".orp\");\n        }\n    }\n\n    /*---------------------------------------------------------*\\\n    | Open input file in binary mode                            |\n    \\*---------------------------------------------------------*/\n    std::ifstream controller_file(filename, std::ios::in | std::ios::binary);\n\n    /*---------------------------------------------------------*\\\n    | Read and verify file header                               |\n    \\*---------------------------------------------------------*/\n    char            profile_string[16]  = \"\";\n    unsigned int    profile_version     = 0;\n\n    controller_file.read(profile_string, 16);\n    controller_file.read((char *)&profile_version, sizeof(unsigned int));\n\n    /*---------------------------------------------------------*\\\n    | Profile version started at 1 and protocol version started |\n    | at 0.  Version 1 profiles should use protocol 0, but 2 or |\n    | greater should be synchronized                            |\n    \\*---------------------------------------------------------*/\n    if(profile_version == 1)\n    {\n        profile_version = 0;\n    }\n\n    controller_offset += 16 + sizeof(unsigned int);\n    controller_file.seekg(controller_offset);\n\n    if(strcmp(profile_string, OPENRGB_PROFILE_HEADER) == 0)\n    {\n        if(profile_version <= OPENRGB_PROFILE_VERSION)\n        {\n            /*---------------------------------------------------------*\\\n            | Read controller data from file until EOF                  |\n            \\*---------------------------------------------------------*/\n            while(!(controller_file.peek() == EOF))\n            {\n                controller_file.read((char *)&controller_size, sizeof(controller_size));\n\n                unsigned char *controller_data = new unsigned char[controller_size];\n\n                controller_file.seekg(controller_offset);\n\n                controller_file.read((char *)controller_data, controller_size);\n\n                RGBController_Dummy *temp_controller = new RGBController_Dummy();\n\n                temp_controller->ReadDeviceDescription(controller_data, profile_version);\n\n                temp_controllers.push_back(temp_controller);\n\n                delete[] controller_data;\n\n                controller_offset += controller_size;\n                controller_file.seekg(controller_offset);\n            }\n        }\n    }\n\n    return(temp_controllers);\n}\n\nbool ProfileManager::LoadDeviceFromListWithOptions\n    (\n    std::vector<RGBController*>&    temp_controllers,\n    std::vector<bool>&              temp_controller_used,\n    RGBController*                  load_controller,\n    bool                            load_size,\n    bool                            load_settings\n    )\n{\n    for(std::size_t temp_index = 0; temp_index < temp_controllers.size(); temp_index++)\n    {\n        RGBController *temp_controller = temp_controllers[temp_index];\n\n        /*---------------------------------------------------------*\\\n        | Do not compare location string for HID devices, as the    |\n        | location string may change between runs as devices are    |\n        | connected and disconnected. Also do not compare the I2C   |\n        | bus number, since it is not persistent across reboots     |\n        | on Linux - strip the I2C number and compare only address. |\n        \\*---------------------------------------------------------*/\n        bool location_check;\n\n        if(load_controller->location.find(\"HID: \") == 0)\n        {\n            location_check = true;\n        }\n        else if(load_controller->location.find(\"I2C: \") == 0)\n        {\n            std::size_t loc = load_controller->location.rfind(\", \");\n            if(loc == std::string::npos)\n            {\n                location_check = false;\n            }\n            else\n            {\n                std::string i2c_address = load_controller->location.substr(loc + 2);\n                location_check = temp_controller->location.find(i2c_address) != std::string::npos;\n            }\n        }\n        else\n        {\n            location_check = temp_controller->location == load_controller->location;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Test if saved controller data matches this controller     |\n        \\*---------------------------------------------------------*/\n        if((temp_controller_used[temp_index]    == false                       )\n         &&(temp_controller->type               == load_controller->type       )\n         &&(temp_controller->name               == load_controller->name       )\n         &&(temp_controller->description        == load_controller->description)\n         &&(temp_controller->version            == load_controller->version    )\n         &&(temp_controller->serial             == load_controller->serial     )\n         &&(location_check                      == true                        ))\n        {\n            /*---------------------------------------------------------*\\\n            | Set used flag for this temp device                        |\n            \\*---------------------------------------------------------*/\n            temp_controller_used[temp_index] = true;\n\n            /*---------------------------------------------------------*\\\n            | Update zone sizes if requested                            |\n            \\*---------------------------------------------------------*/\n            if(load_size)\n            {\n                if(temp_controller->zones.size() == load_controller->zones.size())\n                {\n                    for(std::size_t zone_idx = 0; zone_idx < temp_controller->zones.size(); zone_idx++)\n                    {\n                        if((temp_controller->zones[zone_idx].name       == load_controller->zones[zone_idx].name      )\n                         &&(temp_controller->zones[zone_idx].type       == load_controller->zones[zone_idx].type      )\n                         &&(temp_controller->zones[zone_idx].leds_min   == load_controller->zones[zone_idx].leds_min  )\n                         &&(temp_controller->zones[zone_idx].leds_max   == load_controller->zones[zone_idx].leds_max  ))\n                        {\n                            if (temp_controller->zones[zone_idx].leds_count != load_controller->zones[zone_idx].leds_count)\n                            {\n                                load_controller->ResizeZone((int)zone_idx, temp_controller->zones[zone_idx].leds_count);\n                            }\n\n                            for(std::size_t segment_idx = 0; segment_idx < temp_controller->zones[zone_idx].segments.size(); segment_idx++)\n                            {\n                                load_controller->zones[zone_idx].segments.push_back(temp_controller->zones[zone_idx].segments[segment_idx]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            /*---------------------------------------------------------*\\\n            | Update settings if requested                              |\n            \\*---------------------------------------------------------*/\n            if(load_settings)\n            {\n                /*---------------------------------------------------------*\\\n                | Update all modes                                          |\n                \\*---------------------------------------------------------*/\n                if(temp_controller->modes.size() == load_controller->modes.size())\n                {\n                    for(std::size_t mode_index = 0; mode_index < temp_controller->modes.size(); mode_index++)\n                    {\n                        if((temp_controller->modes[mode_index].name             == load_controller->modes[mode_index].name          )\n                         &&(temp_controller->modes[mode_index].value            == load_controller->modes[mode_index].value         )\n                         &&(temp_controller->modes[mode_index].flags            == load_controller->modes[mode_index].flags         )\n                         &&(temp_controller->modes[mode_index].speed_min        == load_controller->modes[mode_index].speed_min     )\n                         &&(temp_controller->modes[mode_index].speed_max        == load_controller->modes[mode_index].speed_max     )\n                       //&&(temp_controller->modes[mode_index].brightness_min   == load_controller->modes[mode_index].brightness_min)\n                       //&&(temp_controller->modes[mode_index].brightness_max   == load_controller->modes[mode_index].brightness_max)\n                         &&(temp_controller->modes[mode_index].colors_min       == load_controller->modes[mode_index].colors_min    )\n                         &&(temp_controller->modes[mode_index].colors_max       == load_controller->modes[mode_index].colors_max   ))\n                        {\n                            load_controller->modes[mode_index].speed            = temp_controller->modes[mode_index].speed;\n                            load_controller->modes[mode_index].brightness       = temp_controller->modes[mode_index].brightness;\n                            load_controller->modes[mode_index].direction        = temp_controller->modes[mode_index].direction;\n                            load_controller->modes[mode_index].color_mode       = temp_controller->modes[mode_index].color_mode;\n\n                            load_controller->modes[mode_index].colors.resize(temp_controller->modes[mode_index].colors.size());\n\n                            for(std::size_t mode_color_index = 0; mode_color_index < temp_controller->modes[mode_index].colors.size(); mode_color_index++)\n                            {\n                                load_controller->modes[mode_index].colors[mode_color_index] = temp_controller->modes[mode_index].colors[mode_color_index];\n                            }\n                        }\n\n                    }\n\n                    load_controller->active_mode = temp_controller->active_mode;\n                }\n\n                /*---------------------------------------------------------*\\\n                | Update all colors                                         |\n                \\*---------------------------------------------------------*/\n                if(temp_controller->colors.size() == load_controller->colors.size())\n                {\n                    for(std::size_t color_index = 0; color_index < temp_controller->colors.size(); color_index++)\n                    {\n                        load_controller->colors[color_index] = temp_controller->colors[color_index];\n                    }\n                }\n            }\n\n            return(true);\n        }\n    }\n\n    return(false);\n}\n\nbool ProfileManager::LoadProfileWithOptions\n    (\n    std::string     profile_name,\n    bool            load_size,\n    bool            load_settings\n    )\n{\n    std::vector<RGBController*> temp_controllers;\n    std::vector<bool>           temp_controller_used;\n    bool                        ret_val = false;\n\n    /*---------------------------------------------------------*\\\n    | Get the list of controllers from the resource manager     |\n    \\*---------------------------------------------------------*/\n    std::vector<RGBController *> controllers = ResourceManager::get()->GetRGBControllers();\n\n    /*---------------------------------------------------------*\\\n    | Open input file in binary mode                            |\n    \\*---------------------------------------------------------*/\n    temp_controllers = LoadProfileToList(profile_name);\n\n    /*---------------------------------------------------------*\\\n    | Set up used flag vector                                   |\n    \\*---------------------------------------------------------*/\n    temp_controller_used.resize(temp_controllers.size());\n\n    for(unsigned int controller_idx = 0; controller_idx < temp_controller_used.size(); controller_idx++)\n    {\n        temp_controller_used[controller_idx] = false;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Loop through all controllers.  For each controller, search|\n    | all saved controllers until a match is found              |\n    \\*---------------------------------------------------------*/\n    for(std::size_t controller_index = 0; controller_index < controllers.size(); controller_index++)\n    {\n        bool temp_ret_val = LoadDeviceFromListWithOptions(temp_controllers, temp_controller_used, controllers[controller_index], load_size, load_settings);\n        std::string current_name = controllers[controller_index]->name + \" @ \" + controllers[controller_index]->location;\n        LOG_INFO(\"[ProfileManager] Profile loading: %s for %s\", ( temp_ret_val ? \"Succeeded\" : \"FAILED!\" ), current_name.c_str());\n        ret_val |= temp_ret_val;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Delete all temporary controllers                          |\n    \\*---------------------------------------------------------*/\n    for(unsigned int controller_idx = 0; controller_idx < temp_controllers.size(); controller_idx++)\n    {\n        delete temp_controllers[controller_idx];\n    }\n\n    return(ret_val);\n}\n\nvoid ProfileManager::DeleteProfile(std::string profile_name)\n{\n    profile_name = StringUtils::remove_null_terminating_chars(profile_name);\n\n    filesystem::path filename = configuration_directory / profile_name;\n    filename.concat(\".orp\");\n\n    filesystem::remove(filename);\n\n    UpdateProfileList();\n}\n\nvoid ProfileManager::UpdateProfileList()\n{\n    profile_list.clear();\n\n    /*---------------------------------------------------------*\\\n    | Load profiles by looking for .orp files in current dir    |\n    \\*---------------------------------------------------------*/\n    for(const auto & entry : filesystem::directory_iterator(configuration_directory))\n    {\n        std::string filename = entry.path().filename().string();\n\n        if(filename.find(\".orp\") != std::string::npos)\n        {\n            LOG_INFO(\"[ProfileManager] Found file: %s attempting to validate header\", filename.c_str());\n\n            /*---------------------------------------------------------*\\\n            | Open input file in binary mode                            |\n            \\*---------------------------------------------------------*/\n            filesystem::path file_path = configuration_directory;\n            file_path.append(filename);\n            std::ifstream profile_file(file_path, std::ios::in | std::ios::binary);\n\n            /*---------------------------------------------------------*\\\n            | Read and verify file header                               |\n            \\*---------------------------------------------------------*/\n            char            profile_string[16];\n            unsigned int    profile_version;\n\n            profile_file.read(profile_string, 16);\n            profile_file.read((char *)&profile_version, sizeof(unsigned int));\n\n            if(strcmp(profile_string, OPENRGB_PROFILE_HEADER) == 0)\n            {\n                if(profile_version <= OPENRGB_PROFILE_VERSION)\n                {\n                    /*---------------------------------------------------------*\\\n                    | Add this profile to the list                              |\n                    \\*---------------------------------------------------------*/\n                    filename.erase(filename.length() - 4);\n                    profile_list.push_back(filename);\n\n                    LOG_INFO(\"[ProfileManager] Valid v%i profile found for %s\", profile_version, filename.c_str());\n                }\n                else\n                {\n                    LOG_WARNING(\"[ProfileManager] Profile %s isn't valid for current version (v%i, expected v%i at most)\", filename.c_str(), profile_version, OPENRGB_PROFILE_VERSION);\n                }\n            }\n            else\n            {\n                LOG_WARNING(\"[ProfileManager] Profile %s isn't valid: header is missing\", filename.c_str());\n            }\n\n            profile_file.close();\n        }\n    }\n}\n\nunsigned char * ProfileManager::GetProfileListDescription()\n{\n    unsigned int data_ptr = 0;\n    unsigned int data_size = 0;\n\n    /*---------------------------------------------------------*\\\n    | Calculate data size                                       |\n    \\*---------------------------------------------------------*/\n     unsigned short num_profiles = (unsigned short)profile_list.size();\n\n     data_size += sizeof(data_size);\n     data_size += sizeof(num_profiles);\n\n    for(unsigned int i = 0; i < num_profiles; i++)\n    {\n        data_size += sizeof (unsigned short);\n        data_size += (unsigned int)strlen(profile_list[i].c_str()) + 1;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Create data buffer                                        |\n    \\*---------------------------------------------------------*/\n    unsigned char *data_buf = new unsigned char[data_size];\n\n    /*---------------------------------------------------------*\\\n    | Copy in data size                                         |\n    \\*---------------------------------------------------------*/\n    memcpy(&data_buf[data_ptr], &data_size, sizeof(data_size));\n    data_ptr += sizeof(data_size);\n\n    /*---------------------------------------------------------*\\\n    | Copy in num_profiles                                      |\n    \\*---------------------------------------------------------*/\n    memcpy(&data_buf[data_ptr], &num_profiles, sizeof(num_profiles));\n    data_ptr += sizeof(num_profiles);\n\n    /*---------------------------------------------------------*\\\n    | Copy in profile names (size+data)                         |\n    \\*---------------------------------------------------------*/\n    for(unsigned int i = 0; i < num_profiles; i++)\n    {\n        unsigned short name_len = (unsigned short)strlen(profile_list[i].c_str()) + 1;\n\n        memcpy(&data_buf[data_ptr], &name_len, sizeof(name_len));\n        data_ptr += sizeof(name_len);\n\n        strcpy((char *)&data_buf[data_ptr], profile_list[i].c_str());\n        data_ptr += name_len;\n    }\n\n    return(data_buf);\n}\n"
        },
        {
          "name": "ProfileManager.h",
          "type": "blob",
          "size": 3.2626953125,
          "content": "/*---------------------------------------------------------*\\\n| ProfileManager.h                                          |\n|                                                           |\n|   OpenRGB profile manager                                 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include \"RGBController.h\"\n#include \"filesystem.h\"\n\nclass ProfileManagerInterface\n{\npublic:\n    virtual bool SaveProfile\n        (\n        std::string profile_name,\n        bool sizes = false\n        )                                                                            = 0;\n    virtual bool LoadProfile(std::string profile_name)                               = 0;\n    virtual bool LoadSizeFromProfile(std::string profile_name)                       = 0;\n    virtual void DeleteProfile(std::string profile_name)                             = 0;\n    virtual unsigned char * GetProfileListDescription()                              = 0;\n\n    std::vector<std::string> profile_list;\n\n    virtual bool LoadDeviceFromListWithOptions\n        (\n        std::vector<RGBController*>&    temp_controllers,\n        std::vector<bool>&              temp_controller_used,\n        RGBController*                  load_controller,\n        bool                            load_size,\n        bool                            load_settings\n        )                                                                            = 0;\n\n    virtual std::vector<RGBController*> LoadProfileToList\n        (\n        std::string profile_name,\n        bool sizes = false\n        )                                                                            = 0;\n\n    virtual void SetConfigurationDirectory(const filesystem::path& directory)        = 0;\nprotected:\n    virtual ~ProfileManagerInterface() {};\n};\n\nclass ProfileManager: public ProfileManagerInterface\n{\npublic:\n    ProfileManager(const filesystem::path& config_dir);\n    ~ProfileManager();\n\n    bool SaveProfile\n        (\n        std::string     profile_name,\n        bool            sizes = false\n        );\n    bool LoadProfile(std::string profile_name);\n    bool LoadSizeFromProfile(std::string profile_name);\n    void DeleteProfile(std::string profile_name);\n    unsigned char * GetProfileListDescription();\n\n    std::vector<std::string> profile_list;\n\n    bool LoadDeviceFromListWithOptions\n        (\n        std::vector<RGBController*>&    temp_controllers,\n        std::vector<bool>&              temp_controller_used,\n        RGBController*                  load_controller,\n        bool                            load_size,\n        bool                            load_settings\n        );\n\n    std::vector<RGBController*> LoadProfileToList\n        (\n        std::string     profile_name,\n        bool            sizes = false\n        );\n\n    void SetConfigurationDirectory(const filesystem::path& directory);\n\nprivate:\n    filesystem::path configuration_directory;\n\n    void UpdateProfileList();\n    bool LoadProfileWithOptions\n            (\n            std::string     profile_name,\n            bool            load_size,\n            bool            load_settings\n            );\n};\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.9326171875,
          "content": "## ![OpenRGB](Documentation/Images/OpenRGB.png \"OpenRGB Logo\")\n\n![Pipeline Status](https://gitlab.com/CalcProgrammer1/OpenRGB/badges/master/pipeline.svg)\n\nOne of the biggest complaints about RGB is the software ecosystem surrounding it.  Every manufacturer has their own app, their own brand, their own style.  If you want to mix and match devices, you end up with a ton of conflicting, functionally identical apps competing for your background resources.  On top of that, these apps are proprietary and Windows-only.  Some even require online accounts.  What if there was a way to control all of your RGB devices from a single app, on Windows, Linux, and MacOS, without any nonsense?  That is what OpenRGB sets out to achieve.  One app to rule them all.\n\n## Features\n\n* Set colors and select effect modes for a wide variety of RGB hardware\n* Save and load profiles\n* Control lighting from third party software using the OpenRGB SDK\n* Command line interface\n* Connect multiple instances of OpenRGB to synchronize lighting across multiple PCs\n* Can operate standalone or in a client/headless server configuration\n* View device information\n* No official/manufacturer software required\n* Graphical view of device LEDs makes creating custom patterns easy\n\n![OpenRGB_Device_View](Documentation/Images/OpenRGB_Screenshot.png \"OpenRGB Device View Screenshot\")\n\n## Website\n\n* Check out our website at [openrgb.org](https://openrgb.org)\n\n## Supported Devices\n\n* See the [Supported Devices](https://openrgb.org/devices.html) page for the current list of supported devices.\n\n## WARNING!\n\nThis project interacts directly with hardware using reverse engineered protocols.  While we do our best to make sure we're sending the right data, there is always some risk in sending data to hardware when we don't understand exactly how that hardware works.  There have been issues in the past with certain hardware getting damaged/bricked and we have either disabled or fixed the offending code.  That said, with OpenRGB always changing and the landscape of RGB devices being of widely varying quality, we can't guarantee it won't happen again.  By installing and using OpenRGB you accept this risk.\n\n## Download OpenRGB\n\n  * Pre-built binaries are available for the following platforms:\n    * Windows\n    * Linux (AppImage, .deb, and .rpm)\n    * MacOS\n  * Released versions are available to download on [OpenRGB.org](https://openrgb.org/releases.html) or under [Releases](https://gitlab.com/CalcProgrammer1/OpenRGB/-/releases/permalink/latest).\n  * Experimental (aka Pipeline) versions are available to download on [OpenRGB.org](https://openrgb.org/index.html#pl).\n  * On Windows, you will need the **Microsoft Visual 2019 C++ runtime** installed.  You can get it [here](https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads).\n  * An unofficial Flatpak release is [available on Flathub](https://flathub.org/apps/details/org.openrgb.OpenRGB)\n    * Note: If using the AppImage or Flatpak versions, ensure you [install the latest udev rules](Documentation/UdevRules.md).\n  * Released versions are officially packaged for various distributions including Alpine, Fedora, and Arch.\n  * Arch users can also install from the AUR for both the [release](https://aur.archlinux.org/packages/openrgb/) and [pipeline](https://aur.archlinux.org/packages/openrgb-git/) versions.\n\n## Compile OpenRGB\n\n  * Instructions for compiling from source are [available here](Documentation/Compiling.md).\n\n## Setup Device Access\n\n  * After installing OpenRGB, please see the [SMBus Access](Documentation/SMBusAccess.md) and [USB Access](Documentation/USBAccess.md) pages for instructions on setting up access to your RGB devices.\n\n## Join Our Discord\n\n* https://discord.gg/AQwjJPY\n\n## Visit Our Lemmy Community\n\n* https://lemmy.ml/c/OpenRGB\n\n## How-Tos and FAQs\n\n* [Windows Setup and Usage](https://gitlab.com/OpenRGBDevelopers/OpenRGB-Wiki/-/blob/stable/User-Documentation/OpenRGB-Windows-Setup-and-Usage.md)\n* [Frequently Asked Questions](https://gitlab.com/OpenRGBDevelopers/OpenRGB-Wiki/-/blob/stable/User-Documentation/Frequently-Asked-Questions.md)\n\n## Support OpenRGB\n\n* OpenRGB is a project I created to solve a problem I had with the RGB ecosystem.  My goal isn't to make money off of this project.  That said, people have requested to donate, and donations allow me to buy more RGB stuff to reverse engineer.\n* [Donate via PayPal](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=4VPTFMD3G4QVG&item_name=OpenRGB+Development&currency_code=USD&source=url)\n* [Become a Patron](https://www.patreon.com/CalcProgrammer1) (I'm not doing any Patreon-exclusive content, it's purely for donation)\n* Donate via Bitcoin: 1N83YPu7btXYadPS1neB9zX7X1QTdpyZQ\n\n## History of OpenRGB\n\n* OpenRGB is a continuation of OpenAuraSDK, which itself was created out of reverse engineering work done on the Keyboard Visualizer project.  For a complete history of the RGB projects that led to OpenRGB's creation, see the [History page](https://gitlab.com/OpenRGBDevelopers/OpenRGB-Wiki/-/blob/stable/History-of-OpenRGB.md).\n\n## Contributing\n\n* Want to contribute support for a new device?  Check out the [RGBController API](Documentation/RGBControllerAPI.md) page for documentation of how OpenRGB implements device control.\n* Want to create a new OpenRGB SDK client implementation?  Check out the [OpenRGB SDK Documentation](Documentation/OpenRGBSDK.md) page for documentation of how the OpenRGB SDK network protocol functions.\n* Please read the [Contributing Guidelines](CONTRIBUTING.md) before starting work on your new changes.\n\n## OpenRGB SDK\n\n* OpenRGB provides a network interface for controlling supported RGB devices from other software.  These projects implement the OpenRGB SDK and provide additional ways for you to control your lighting setup.\n\n  * [OpenRGB Python Client](https://github.com/jath03/openrgb-python) (by jath03)\n  * [OpenRGB Python Client (deprecated)](https://github.com/bahorn/OpenRGB-PyClient) (by bahorn)  \n  * [OpenRGB Node.js Client](https://github.com/vlakreeh/openrgb) (by vlakreeh)\n  * [D-Bus Connector for OpenRGB](https://github.com/Vinno97/OpenRGB-DBus-Connector) (by Vinno97)\n  * [OpenRGB.NET - C# OpenRGB Client](https://github.com/diogotr7/OpenRGB.NET) (by diogotr7)\n  * [OpenRGB-Client - Java Client](https://gitlab.com/mguimard/openrgb-client) (by morg)\n  * [OpenRGB-SDK - NodeJS client](https://www.npmjs.com/package/openrgb-sdk) (by Mola19)\n  * [OpenRGB-cppSDK - C++ client](https://github.com/Youda008/OpenRGB-cppSDK) (by Youda008)\n  * [openrgb-rs - Rust client](https://github.com/nicoulaj/openrgb-rs) (by nicoulaj)\n\n## Applications Supporting OpenRGB SDK\n\n* While OpenRGB itself only provides control over the lighting effects built into hardware, several open source applications can use the OpenRGB SDK to provide synchronized lighting effects for your devices.\n\n  * [Keyboard Visualizer](https://gitlab.com/CalcProgrammer1/KeyboardVisualizer) (by CalcProgrammer1)\n  * [OpenRGB E1.31 Receiver](https://gitlab.com/CalcProgrammer1/OpenRGBE131Receiver) (by me)\n  * [Aurora](https://github.com/Aurora-RGB/Aurora) (OpenRGB support added by diogotr7)\n  * [Artemis](https://github.com/Artemis-RGB/Artemis) (OpenRGB support added by diogotr7)\n  * [RemoteLight](https://github.com/Drumber/RemoteLight) (by Drumber, requires OpenRGB plugin)\n  * [OpenRGB-python-FX](https://github.com/herosilas12/OpenRGB-python-FX) (by herosilas12)\n  * [AllMyLights](https://github.com/sparten11740/allmylights) (by sparten11740)\n  * [OpenRGBRemote](https://gitlab.com/mguimard/openrgbremote) (by morg)\n  * [PiLED](https://github.com/PolisanTheEasyNick/PiLED) (by PolisanTheEasyNick)\n\n## OpenRGB Plugins\n\n* OpenRGB provides a plugin interface for adding features to the OpenRGB application.  The following projects provide additional functionality in the form of plugins.\n\n  * [OpenRGB Effects Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin) (by herosilas12, morg)\n  * [OpenRGB Visual Map Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBVisualMapPlugin) (by morg)\n  * [OpenRGB E1.31 Receiver Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBE131ReceiverPlugin) (by CalcProgrammer1)\n  * [OpenRGB Scheduler Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBSchedulerPlugin) (by morg)\n  * [OpenRGB Skin Plugin](https://gitlab.com/OpenRGBDevelopers/openrgbskinplugin) (by morg)\n  * [OpenRGB Hardware Sync Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBHardwareSyncPlugin) (by morg)\n  * [OpenRGB Http Hook Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBHttpHookPlugin) (by morg)\n  * [OpenRGB Razer Extras Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBRazerExtrasPlugin) (by morg)\n  * [OpenRGB Fan Hardware Sync Plugin](https://gitlab.com/OpenRGBDevelopers/OpenRGBFanSyncPlugin) (by Shady)\n  * [OpenRGB Ambient Plugin](https://github.com/krojew/OpenRGB-Ambient) (by krojew)\n\n## Projects Used\n\n* OpenRGB directly relies upon these projects.\n\n  * WinRing0: https://openlibsys.org/\n  * libusb: https://github.com/libusb/libusb\n  * hidapi: https://github.com/libusb/hidapi\n  * libe131: https://github.com/hhromic/libe131\n  * NVFC: https://github.com/graphitemaster/NVFC\n  * Qt-Plus (ColorWheel): https://github.com/liuyanghejerry/Qt-Plus\n  * AMD ADL Libraries: https://github.com/GPUOpen-LibrariesAndSDKs/display-library\n  * hueplusplus: https://github.com/enwi/hueplusplus\n  * httplib: https://github.com/yhirose/cpp-httplib\n  * mdns: https://github.com/mjansson/mdns\n  * macUSPCIO: https://github.com/ShadyNawara/macUSPCIO\n\n## Projects Researched\n\n* While no code from these projects directly made its way into OpenRGB, these projects have been invaluable resources for protocol information.\n\n  * OpenRazer: https://github.com/openrazer/openrazer\n  * OpenRazer-Win32: https://github.com/CalcProgrammer1/openrazer-win32\n  * ckb-next: https://github.com/ckb-next/ckb-next\n  * linux_thermaltake_riing: https://github.com/chestm007/linux_thermaltake_riing\n  * Aura Addressable Header Controller: https://gitlab.com/cneil02/aura-addressable-header-controller\n  * OpenPyAURA: https://gitlab.com/thelastguardian/openpyaura\n  * AsrLed: https://github.com/EUA/AsrLed\n  * asrock-leds: https://github.com/RattyDAVE/asrock-leds\n  * hue-plus: https://github.com/kusti8/hue-plus\n  * rogauracore: https://github.com/wroberts/rogauracore\n  * msi-rgb: https://github.com/nagisa/msi-rgb\n  * OpenCorsairLink: https://github.com/audiohacked/OpenCorsairLink\n  * msi-keyboard: https://github.com/bparker06/msi-keyboard\n  * rivalcfg: https://github.com/flozz/rivalcfg\n  * VRMTool: https://github.com/rbrune/VRMtool\n  * g810-led: https://github.com/MatMoul/g810-led\n  * liquidctl: https://github.com/jonasmalacofilho/liquidctl\n  * Annemone: https://github.com/manualmanul/Annemone\n  * libcmmk: https://github.com/chmod222/libcmmk\n  * Signal RGB Plugins: https://gitlab.com/signalrgb/signal-plugins/-/tree/master/Plugins\n  * k550-macos: https://github.com/vookimedlo/ck550-macos/tree/master\n  * luxafor-python: https://github.com/vmitchell85/luxafor-python\n  * dreamcheekyusb: https://github.com/gbrayut/dreamcheekyusb\n  * omen-light: https://github.com/chiahsing/omen-light\n  \n"
        },
        {
          "name": "RGBController",
          "type": "tree",
          "content": null
        },
        {
          "name": "ResourceManager.cpp",
          "type": "blob",
          "size": 77.220703125,
          "content": "/*---------------------------------------------------------*\\\n| ResourceManager.cpp                                       |\n|                                                           |\n|   OpenRGB Resource Manager controls access to application |\n|   components including RGBControllers, I2C interfaces,    |\n|   and network SDK components                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                27 Sep 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#ifdef _WIN32\n#include <codecvt>\n#include <locale>\n#endif\n\n#include <stdlib.h>\n#include <string>\n#include <hidapi.h>\n#include \"cli.h\"\n#include \"pci_ids/pci_ids.h\"\n#include \"ResourceManager.h\"\n#include \"ProfileManager.h\"\n#include \"LogManager.h\"\n#include \"SettingsManager.h\"\n#include \"NetworkClient.h\"\n#include \"NetworkServer.h\"\n#include \"filesystem.h\"\n#include \"StringUtils.h\"\n\nconst hidapi_wrapper default_wrapper =\n{\n    NULL,\n    (hidapi_wrapper_send_feature_report)        hid_send_feature_report,\n    (hidapi_wrapper_get_feature_report)         hid_get_feature_report,\n    (hidapi_wrapper_get_serial_number_string)   hid_get_serial_number_string,\n    (hidapi_wrapper_open_path)                  hid_open_path,\n    (hidapi_wrapper_enumerate)                  hid_enumerate,\n    (hidapi_wrapper_free_enumeration)           hid_free_enumeration,\n    (hidapi_wrapper_close)                      hid_close,\n    (hidapi_wrapper_error)                      hid_error\n};\n\nbool BasicHIDBlock::compare(hid_device_info* info)\n{\n    return ( (vid == info->vendor_id)\n        && (pid == info->product_id)\n#ifdef USE_HID_USAGE\n        && ( (usage_page == HID_USAGE_PAGE_ANY)\n            || (usage_page == info->usage_page) )\n        && ( (usage      == HID_USAGE_ANY)\n            || (usage      == info->usage) )\n        && ( (interface  == HID_INTERFACE_ANY)\n            || (interface  == info->interface_number ) )\n#else\n        && ( (interface  == HID_INTERFACE_ANY)\n            || (interface  == info->interface_number ) )\n#endif\n            );\n}\n\nResourceManager* ResourceManager::instance;\n\nusing namespace std::chrono_literals;\n\nResourceManager *ResourceManager::get()\n{\n    if(!instance)\n    {\n        instance = new ResourceManager();\n    }\n\n    return instance;\n}\n\nResourceManager::ResourceManager()\n{\n    /*-------------------------------------------------------------------------*\\\n    | Initialize Detection Variables                                            |\n    \\*-------------------------------------------------------------------------*/\n    detection_enabled           = true;\n    detection_percent           = 100;\n    detection_string            = \"\";\n    detection_is_required       = false;\n    dynamic_detectors_processed = false;\n    init_finished               = false;\n    background_thread_running    = true;\n\n    /*-------------------------------------------------------------------------*\\\n    | Start the background detection thread in advance; it will be suspended    |\n    | until necessary                                                           |\n    \\*-------------------------------------------------------------------------*/\n    DetectDevicesThread         = new std::thread(&ResourceManager::BackgroundThreadFunction, this);\n\n    SetupConfigurationDirectory();\n\n    /*-------------------------------------------------------------------------*\\\n    | Load settings from file                                                   |\n    \\*-------------------------------------------------------------------------*/\n    settings_manager        = new SettingsManager();\n\n    settings_manager->LoadSettings(GetConfigurationDirectory() / \"OpenRGB.json\");\n\n    /*-------------------------------------------------------------------------*\\\n    | Configure the log manager                                                 |\n    \\*-------------------------------------------------------------------------*/\n    LogManager::get()->configure(settings_manager->GetSettings(\"LogManager\"), GetConfigurationDirectory());\n\n    /*-------------------------------------------------------------------------*\\\n    | Initialize Server Instance                                                |\n    |   If configured, pass through full controller list including clients      |\n    |   Otherwise, pass only local hardware controllers                         |\n    \\*-------------------------------------------------------------------------*/\n    json server_settings    = settings_manager->GetSettings(\"Server\");\n    bool all_controllers    = false;\n    bool legacy_workaround  = false;\n\n    if(server_settings.contains(\"all_controllers\"))\n    {\n        all_controllers     = server_settings[\"all_controllers\"];\n    }\n\n    if(all_controllers)\n    {\n        server              = new NetworkServer(rgb_controllers);\n    }\n    else\n    {\n        server              = new NetworkServer(rgb_controllers_hw);\n    }\n\n    /*-------------------------------------------------------------------------*\\\n    | Enable legacy SDK workaround in server if configured                      |\n    \\*-------------------------------------------------------------------------*/\n    if(server_settings.contains(\"legacy_workaround\"))\n    {\n        legacy_workaround   = server_settings[\"legacy_workaround\"];\n    }\n\n    if(legacy_workaround)\n    {\n        server->SetLegacyWorkaroundEnable(true);\n    }\n\n    /*-------------------------------------------------------------------------*\\\n    | Initialize Saved Client Connections                                       |\n    \\*-------------------------------------------------------------------------*/\n    json client_settings    = settings_manager->GetSettings(\"Client\");\n\n    if(client_settings.contains(\"clients\"))\n    {\n        for(unsigned int client_idx = 0; client_idx < client_settings[\"clients\"].size(); client_idx++)\n        {\n            NetworkClient * client = new NetworkClient(rgb_controllers);\n\n            std::string titleString = \"OpenRGB \";\n            titleString.append(VERSION_STRING);\n\n            std::string     client_ip   = client_settings[\"clients\"][client_idx][\"ip\"];\n            unsigned short  client_port = client_settings[\"clients\"][client_idx][\"port\"];\n\n            client->SetIP(client_ip.c_str());\n            client->SetName(titleString.c_str());\n            client->SetPort(client_port);\n\n            client->StartClient();\n\n            for(int timeout = 0; timeout < 100; timeout++)\n            {\n                if(client->GetConnected())\n                {\n                    break;\n                }\n                std::this_thread::sleep_for(10ms);\n            }\n\n            clients.push_back(client);\n        }\n    }\n\n    /*-------------------------------------------------------------------------*\\\n    | Load sizes list from file                                                 |\n    \\*-------------------------------------------------------------------------*/\n    profile_manager         = new ProfileManager(GetConfigurationDirectory());\n    server->SetProfileManager(profile_manager);\n    rgb_controllers_sizes   = profile_manager->LoadProfileToList(\"sizes\", true);\n}\n\nResourceManager::~ResourceManager()\n{\n    Cleanup();\n\n    // Mark the background detection thread as not running\n    // And then wake it up so it knows that it has to stop\n    background_thread_running = false;\n    BackgroundFunctionStartTrigger.notify_one();\n\n    // Stop the background thread\n    if(DetectDevicesThread)\n    {\n        DetectDevicesThread->join();\n        delete DetectDevicesThread;\n        DetectDevicesThread = nullptr;\n    }\n}\n\nvoid ResourceManager::RegisterI2CBus(i2c_smbus_interface *bus)\n{\n    LOG_INFO(\"[ResourceManager] Registering I2C interface: %s Device %04X:%04X Subsystem: %04X:%04X\", bus->device_name, bus->pci_vendor, bus->pci_device,bus->pci_subsystem_vendor,bus->pci_subsystem_device);\n    busses.push_back(bus);\n}\n\nstd::vector<i2c_smbus_interface*> & ResourceManager::GetI2CBusses()\n{\n    return busses;\n}\n\nvoid ResourceManager::RegisterRGBController(RGBController *rgb_controller)\n{\n    LOG_INFO(\"[%s] Registering RGB controller\", rgb_controller->name.c_str());\n    rgb_controllers_hw.push_back(rgb_controller);\n\n    /*-------------------------------------------------*\\\n    | If the device list size has changed, call the     |\n    | device list changed callbacks                     |\n    |                                                   |\n    | TODO: If all detection is reworked to use         |\n    | RegisterRGBController, tracking of previous list  |\n    | size can be removed and profile can be loaded per |\n    | controller before adding to list                  |\n    \\*-------------------------------------------------*/\n    if(rgb_controllers_hw.size() != detection_prev_size)\n    {\n        /*-------------------------------------------------*\\\n        | First, load sizes for the new controllers         |\n        \\*-------------------------------------------------*/\n        for(unsigned int controller_size_idx = detection_prev_size; controller_size_idx < rgb_controllers_hw.size(); controller_size_idx++)\n        {\n            profile_manager->LoadDeviceFromListWithOptions(rgb_controllers_sizes, detection_size_entry_used, rgb_controllers_hw[controller_size_idx], true, false);\n        }\n\n        UpdateDeviceList();\n    }\n\n    detection_prev_size = (unsigned int)rgb_controllers_hw.size();\n\n    UpdateDeviceList();\n}\n\nvoid ResourceManager::UnregisterRGBController(RGBController* rgb_controller)\n{\n    LOG_INFO(\"[%s] Unregistering RGB controller\", rgb_controller->name.c_str());\n\n    /*-------------------------------------------------------------------------*\\\n    | Clear callbacks from the controller before removal                        |\n    \\*-------------------------------------------------------------------------*/\n    rgb_controller->ClearCallbacks();\n\n    /*-------------------------------------------------------------------------*\\\n    | Find the controller to remove and remove it from the hardware list        |\n    \\*-------------------------------------------------------------------------*/\n    std::vector<RGBController*>::iterator hw_it = std::find(rgb_controllers_hw.begin(), rgb_controllers_hw.end(), rgb_controller);\n\n    if (hw_it != rgb_controllers_hw.end())\n    {\n        rgb_controllers_hw.erase(hw_it);\n    }\n\n    /*-------------------------------------------------------------------------*\\\n    | Find the controller to remove and remove it from the master list          |\n    \\*-------------------------------------------------------------------------*/\n    std::vector<RGBController*>::iterator rgb_it = std::find(rgb_controllers.begin(), rgb_controllers.end(), rgb_controller);\n\n    if (rgb_it != rgb_controllers.end())\n    {\n        rgb_controllers.erase(rgb_it);\n    }\n\n    UpdateDeviceList();\n}\n\nstd::vector<RGBController*> & ResourceManager::GetRGBControllers()\n{\n    return rgb_controllers;\n}\n\nvoid ResourceManager::RegisterI2CBusDetector(I2CBusDetectorFunction detector)\n{\n    i2c_bus_detectors.push_back(detector);\n}\n\nvoid ResourceManager::RegisterI2CDeviceDetector(std::string name, I2CDeviceDetectorFunction detector)\n{\n    i2c_device_detector_strings.push_back(name);\n    i2c_device_detectors.push_back(detector);\n}\n\nvoid ResourceManager::RegisterI2CDIMMDeviceDetector(std::string name, I2CDIMMDeviceDetectorFunction detector, uint16_t jedec_id, uint8_t dimm_type)\n{\n    I2CDIMMDeviceDetectorBlock block;\n\n    block.name          = name;\n    block.function      = detector;\n    block.jedec_id      = jedec_id;\n    block.dimm_type     = dimm_type;\n\n    i2c_dimm_device_detectors.push_back(block);\n}\n\nvoid ResourceManager::RegisterI2CPCIDeviceDetector(std::string name, I2CPCIDeviceDetectorFunction detector, uint16_t ven_id, uint16_t dev_id, uint16_t subven_id, uint16_t subdev_id, uint8_t i2c_addr)\n{\n    I2CPCIDeviceDetectorBlock block;\n\n    block.name          = name;\n    block.function      = detector;\n    block.ven_id        = ven_id;\n    block.dev_id        = dev_id;\n    block.subven_id     = subven_id;\n    block.subdev_id     = subdev_id;\n    block.i2c_addr      = i2c_addr;\n\n    i2c_pci_device_detectors.push_back(block);\n}\n\nvoid ResourceManager::RegisterDeviceDetector(std::string name, DeviceDetectorFunction detector)\n{\n    device_detector_strings.push_back(name);\n    device_detectors.push_back(detector);\n}\n\nvoid ResourceManager::RegisterHIDDeviceDetector(std::string name,\n                               HIDDeviceDetectorFunction  detector,\n                               uint16_t vid,\n                               uint16_t pid,\n                               int interface,\n                               int usage_page,\n                               int usage)\n{\n    HIDDeviceDetectorBlock block;\n\n    block.name          = name;\n    block.vid           = vid;\n    block.pid           = pid;\n    block.function      = detector;\n    block.interface     = interface;\n    block.usage_page    = usage_page;\n    block.usage         = usage;\n\n    hid_device_detectors.push_back(block);\n}\n\nvoid ResourceManager::RegisterHIDWrappedDeviceDetector(std::string name,\n                                                       HIDWrappedDeviceDetectorFunction  detector,\n                                                       uint16_t vid,\n                                                       uint16_t pid,\n                                                       int interface,\n                                                       int usage_page,\n                                                       int usage)\n{\n    HIDWrappedDeviceDetectorBlock block;\n\n    block.name          = name;\n    block.vid           = vid;\n    block.pid           = pid;\n    block.function      = detector;\n    block.interface     = interface;\n    block.usage_page    = usage_page;\n    block.usage         = usage;\n\n    hid_wrapped_device_detectors.push_back(block);\n}\n\nvoid ResourceManager::RegisterDynamicDetector(std::string name, DynamicDetectorFunction detector)\n{\n    dynamic_detector_strings.push_back(name);\n    dynamic_detectors.push_back(detector);\n}\n\nvoid ResourceManager::RegisterPreDetectionHook(PreDetectionHookFunction hook)\n{\n    pre_detection_hooks.push_back(hook);\n}\n\nvoid ResourceManager::RegisterDeviceListChangeCallback(DeviceListChangeCallback new_callback, void * new_callback_arg)\n{\n    DeviceListChangeCallbacks.push_back(new_callback);\n    DeviceListChangeCallbackArgs.push_back(new_callback_arg);\n\n    LOG_TRACE(\"[ResourceManager] Registered device list change callback.  Total callbacks registered: %d\", DeviceListChangeCallbacks.size());\n}\n\nvoid ResourceManager::UnregisterDeviceListChangeCallback(DeviceListChangeCallback callback, void * callback_arg)\n{\n    for(size_t idx = 0; idx < DeviceListChangeCallbacks.size(); idx++)\n    {\n        if(DeviceListChangeCallbacks[idx] == callback && DeviceListChangeCallbackArgs[idx] == callback_arg)\n        {\n            DeviceListChangeCallbacks.erase(DeviceListChangeCallbacks.begin() + idx);\n            DeviceListChangeCallbackArgs.erase(DeviceListChangeCallbackArgs.begin() + idx);\n        }\n    }\n\n    LOG_TRACE(\"[ResourceManager] Unregistered device list change callback.  Total callbacks registered: %d\", DeviceListChangeCallbacks.size());\n}\n\nvoid ResourceManager::RegisterI2CBusListChangeCallback(I2CBusListChangeCallback new_callback, void * new_callback_arg)\n{\n    I2CBusListChangeCallbacks.push_back(new_callback);\n    I2CBusListChangeCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid ResourceManager::UnregisterI2CBusListChangeCallback(I2CBusListChangeCallback callback, void * callback_arg)\n{\n    for(size_t idx = 0; idx < I2CBusListChangeCallbacks.size(); idx++)\n    {\n        if(I2CBusListChangeCallbacks[idx] == callback && I2CBusListChangeCallbackArgs[idx] == callback_arg)\n        {\n            I2CBusListChangeCallbacks.erase(I2CBusListChangeCallbacks.begin() + idx);\n            I2CBusListChangeCallbackArgs.erase(I2CBusListChangeCallbackArgs.begin() + idx);\n        }\n    }\n}\n\nvoid ResourceManager::RegisterDetectionProgressCallback(DetectionProgressCallback new_callback, void *new_callback_arg)\n{\n    DetectionProgressCallbacks.push_back(new_callback);\n    DetectionProgressCallbackArgs.push_back(new_callback_arg);\n\n    LOG_TRACE(\"[ResourceManager] Registered detection progress callback.  Total callbacks registered: %d\", DetectionProgressCallbacks.size());\n}\n\nvoid ResourceManager::UnregisterDetectionProgressCallback(DetectionProgressCallback callback, void *callback_arg)\n{\n    for(size_t idx = 0; idx < DetectionProgressCallbacks.size(); idx++)\n    {\n        if(DetectionProgressCallbacks[idx] == callback && DetectionProgressCallbackArgs[idx] == callback_arg)\n        {\n            DetectionProgressCallbacks.erase(DetectionProgressCallbacks.begin() + idx);\n            DetectionProgressCallbackArgs.erase(DetectionProgressCallbackArgs.begin() + idx);\n        }\n    }\n\n    LOG_TRACE(\"[ResourceManager] Unregistered detection progress callback.  Total callbacks registered: %d\", DetectionProgressCallbacks.size());\n}\n\nvoid ResourceManager::RegisterDetectionStartCallback(DetectionStartCallback new_callback, void *new_callback_arg)\n{\n    DetectionStartCallbacks.push_back(new_callback);\n    DetectionStartCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid ResourceManager::UnregisterDetectionStartCallback(DetectionStartCallback callback, void *callback_arg)\n{\n    for(size_t idx = 0; idx < DetectionStartCallbacks.size(); idx++)\n    {\n        if(DetectionStartCallbacks[idx] == callback && DetectionStartCallbackArgs[idx] == callback_arg)\n        {\n            DetectionStartCallbacks.erase(DetectionStartCallbacks.begin() + idx);\n            DetectionStartCallbackArgs.erase(DetectionStartCallbackArgs.begin() + idx);\n        }\n    }\n}\n\nvoid ResourceManager::RegisterDetectionEndCallback(DetectionEndCallback new_callback, void *new_callback_arg)\n{\n    DetectionEndCallbacks.push_back(new_callback);\n    DetectionEndCallbackArgs.push_back(new_callback_arg);\n}\n\nvoid ResourceManager::UnregisterDetectionEndCallback(DetectionEndCallback callback, void *callback_arg)\n{\n    for(size_t idx = 0; idx < DetectionEndCallbacks.size(); idx++)\n    {\n        if(DetectionEndCallbacks[idx] == callback && DetectionEndCallbackArgs[idx] == callback_arg)\n        {\n            DetectionEndCallbacks.erase(DetectionEndCallbacks.begin() + idx);\n            DetectionEndCallbackArgs.erase(DetectionEndCallbackArgs.begin() + idx);\n        }\n    }\n}\n\nvoid ResourceManager::UpdateDeviceList()\n{\n    DeviceListChangeMutex.lock();\n\n    /*-------------------------------------------------*\\\n    | Insert hardware controllers into controller list  |\n    \\*-------------------------------------------------*/\n    for(unsigned int hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++)\n    {\n        /*-------------------------------------------------*\\\n        | Check if the controller is already in the list    |\n        | at the correct index                              |\n        \\*-------------------------------------------------*/\n        if(hw_controller_idx < rgb_controllers.size())\n        {\n            if(rgb_controllers[hw_controller_idx] == rgb_controllers_hw[hw_controller_idx])\n            {\n                continue;\n            }\n        }\n\n        /*-------------------------------------------------*\\\n        | If not, check if the controller is already in the |\n        | list at a different index                         |\n        \\*-------------------------------------------------*/\n        for(unsigned int controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)\n        {\n            if(rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx])\n            {\n                rgb_controllers.erase(rgb_controllers.begin() + controller_idx);\n                rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);\n                break;\n            }\n        }\n\n        /*-------------------------------------------------*\\\n        | If it still hasn't been found, add it to the list |\n        \\*-------------------------------------------------*/\n        rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);\n    }\n\n    /*-------------------------------------------------*\\\n    | Device list has changed, call the callbacks       |\n    \\*-------------------------------------------------*/\n    DeviceListChanged();\n\n    /*-------------------------------------------------*\\\n    | Device list has changed, inform all clients       |\n    | connected to this server                          |\n    \\*-------------------------------------------------*/\n    server->DeviceListChanged();\n\n    DeviceListChangeMutex.unlock();\n}\n\nvoid ResourceManager::DeviceListChanged()\n{\n    /*-------------------------------------------------*\\\n    | Device list has changed, call the callbacks       |\n    \\*-------------------------------------------------*/\n    LOG_TRACE(\"[ResourceManager] Calling device list change callbacks.\");\n\n    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)DeviceListChangeCallbacks.size(); callback_idx++)\n    {\n        ResourceManager::DeviceListChangeCallbacks[callback_idx](DeviceListChangeCallbackArgs[callback_idx]);\n    }\n}\n\nvoid ResourceManager::DetectionProgressChanged()\n{\n    DetectionProgressMutex.lock();\n\n    /*-------------------------------------------------*\\\n    | Detection progress has changed, call the callbacks|\n    \\*-------------------------------------------------*/\n    LOG_TRACE(\"[ResourceManager] Calling detection progress callbacks.\");\n\n    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)DetectionProgressCallbacks.size(); callback_idx++)\n    {\n        DetectionProgressCallbacks[callback_idx](DetectionProgressCallbackArgs[callback_idx]);\n    }\n\n    DetectionProgressMutex.unlock();\n}\n\nvoid ResourceManager::I2CBusListChanged()\n{\n    I2CBusListChangeMutex.lock();\n\n    /*-------------------------------------------------*\\\n    | Detection progress has changed, call the callbacks|\n    \\*-------------------------------------------------*/\n    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)I2CBusListChangeCallbacks.size(); callback_idx++)\n    {\n        I2CBusListChangeCallbacks[callback_idx](I2CBusListChangeCallbackArgs[callback_idx]);\n    }\n\n    I2CBusListChangeMutex.unlock();\n}\n\nvoid ResourceManager::SetupConfigurationDirectory()\n{\n    config_dir.clear();\n#ifdef _WIN32\n    const wchar_t* appdata = _wgetenv(L\"APPDATA\");\n    if(appdata != NULL)\n    {\n        config_dir = appdata;\n    }\n#else\n    const char* xdg_config_home = getenv(\"XDG_CONFIG_HOME\");\n    const char* home            = getenv(\"HOME\");\n    /*-----------------------------------------------------*\\\n    | Check both XDG_CONFIG_HOME and APPDATA environment    |\n    | variables.  If neither exist, use current directory   |\n    \\*-----------------------------------------------------*/\n    if(xdg_config_home != NULL)\n    {\n        config_dir = xdg_config_home;\n    }\n    else if(home != NULL)\n    {\n        config_dir = home;\n        config_dir /= \".config\";\n    }\n#endif\n\n\n    /*-----------------------------------------------------*\\\n    | If a configuration directory was found, append OpenRGB|\n    \\*-----------------------------------------------------*/\n    if(config_dir != \"\")\n    {\n        config_dir.append(\"OpenRGB\");\n\n        /*-------------------------------------------------------------------------*\\\n        | Create OpenRGB configuration directory if it doesn't exist                |\n        \\*-------------------------------------------------------------------------*/\n        filesystem::create_directories(config_dir);\n    }\n    else\n    {\n        config_dir = \"./\";\n    }\n}\n\nfilesystem::path ResourceManager::GetConfigurationDirectory()\n{\n    return(config_dir);\n}\n\nvoid ResourceManager::SetConfigurationDirectory(const filesystem::path &directory)\n{\n    config_dir = directory;\n    settings_manager->LoadSettings(directory / \"OpenRGB.json\");\n    profile_manager->SetConfigurationDirectory(directory);\n\n    rgb_controllers_sizes.clear();\n    rgb_controllers_sizes   = profile_manager->LoadProfileToList(\"sizes\", true);\n}\n\nNetworkServer* ResourceManager::GetServer()\n{\n    return(server);\n}\n\nstatic void NetworkClientInfoChangeCallback(void* this_ptr)\n{\n    ResourceManager* this_obj = (ResourceManager*)this_ptr;\n\n    this_obj->DeviceListChanged();\n}\n\nvoid ResourceManager::RegisterNetworkClient(NetworkClient* new_client)\n{\n    new_client->RegisterClientInfoChangeCallback(NetworkClientInfoChangeCallback, this);\n\n    clients.push_back(new_client);\n}\n\nvoid ResourceManager::UnregisterNetworkClient(NetworkClient* network_client)\n{\n    /*-------------------------------------------------------------------------*\\\n    | Stop the disconnecting client                                             |\n    \\*-------------------------------------------------------------------------*/\n    network_client->StopClient();\n\n    /*-------------------------------------------------------------------------*\\\n    | Clear callbacks from the client before removal                            |\n    \\*-------------------------------------------------------------------------*/\n    network_client->ClearCallbacks();\n\n    /*-------------------------------------------------------------------------*\\\n    | Find the client to remove and remove it from the clients list             |\n    \\*-------------------------------------------------------------------------*/\n    std::vector<NetworkClient*>::iterator client_it = std::find(clients.begin(), clients.end(), network_client);\n\n    if(client_it != clients.end())\n    {\n        clients.erase(client_it);\n    }\n\n    /*-------------------------------------------------------------------------*\\\n    | Delete the client                                                         |\n    \\*-------------------------------------------------------------------------*/\n    delete network_client;\n\n    UpdateDeviceList();\n}\n\n\n/******************************************************************************************\\\n*                                                                                          *\n*   AttemptLocalConnection                                                                 *\n*                                                                                          *\n*       Attempts an SDK connection to the local server.  Returns true if success           *\n*                                                                                          *\n\\******************************************************************************************/\n\nbool ResourceManager::AttemptLocalConnection()\n{\n    detection_percent = 0;\n    detection_string  = \"Attempting local server connection...\";\n    DetectionProgressChanged();\n\n    LOG_DEBUG(\"[ResourceManager] Attempting server connection...\");\n\n    bool success = false;\n\n    NetworkClient * client = new NetworkClient(ResourceManager::get()->GetRGBControllers());\n\n    std::string titleString = \"OpenRGB \";\n    titleString.append(VERSION_STRING);\n\n    client->SetName(titleString.c_str());\n    client->StartClient();\n\n    for(int timeout = 0; timeout < 10; timeout++)\n    {\n        if(client->GetConnected())\n        {\n            break;\n        }\n        std::this_thread::sleep_for(5ms);\n    }\n\n    if(!client->GetConnected())\n    {\n        LOG_TRACE(\"[ResourceManager] Client failed to connect\");\n        client->StopClient();\n        LOG_TRACE(\"[ResourceManager] Client stopped\");\n\n        delete client;\n\n        client = NULL;\n    }\n    else\n    {\n        ResourceManager::get()->RegisterNetworkClient(client);\n        LOG_TRACE(\"[ResourceManager] Registered network client\");\n\n        success = true;\n\n        /*-----------------------------------------------------*\\\n        | Wait up to 5 seconds for the client connection to     |\n        | retrieve all controllers                              |\n        \\*-----------------------------------------------------*/\n        for(int timeout = 0; timeout < 1000; timeout++)\n        {\n            if(client->GetOnline())\n            {\n                break;\n            }\n            std::this_thread::sleep_for(5ms);\n        }\n    }\n\n    return success;\n}\n\nstd::vector<NetworkClient*>& ResourceManager::GetClients()\n{\n    return(clients);\n}\n\nProfileManager* ResourceManager::GetProfileManager()\n{\n    return(profile_manager);\n}\n\nSettingsManager* ResourceManager::GetSettingsManager()\n{\n    return(settings_manager);\n}\n\nbool ResourceManager::GetDetectionEnabled()\n{\n    return(detection_enabled);\n}\n\nunsigned int ResourceManager::GetDetectionPercent()\n{\n    return (detection_percent.load());\n}\n\nconst char *ResourceManager::GetDetectionString()\n{\n    return (detection_string);\n}\n\nvoid ResourceManager::Cleanup()\n{\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    std::vector<RGBController *> rgb_controllers_hw_copy = rgb_controllers_hw;\n\n    for(std::size_t hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++)\n    {\n        for(std::size_t controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)\n        {\n            if(rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx])\n            {\n                rgb_controllers.erase(rgb_controllers.begin() + controller_idx);\n                break;\n            }\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Clear the hardware controllers list and set the   |\n    | previous hardware controllers list size to zero   |\n    \\*-------------------------------------------------*/\n    rgb_controllers_hw.clear();\n    detection_prev_size = 0;\n\n    for(RGBController* rgb_controller : rgb_controllers_hw_copy)\n    {\n        delete rgb_controller;\n    }\n\n    std::vector<i2c_smbus_interface *> busses_copy = busses;\n\n    busses.clear();\n\n    for(i2c_smbus_interface* bus : busses_copy)\n    {\n        delete bus;\n    }\n\n    RunInBackgroundThread(std::bind(&ResourceManager::HidExitCoroutine, this));\n}\n\nvoid ResourceManager::ProcessPreDetectionHooks()\n{\n    for(std::size_t hook_idx = 0; hook_idx < pre_detection_hooks.size(); hook_idx++)\n    {\n        pre_detection_hooks[hook_idx]();\n    }\n}\n\nvoid ResourceManager::ProcessDynamicDetectors()\n{\n    for(std::size_t detector_idx = 0; detector_idx < dynamic_detectors.size(); detector_idx++)\n    {\n        dynamic_detectors[detector_idx]();\n    }\n\n    dynamic_detectors_processed = true;\n}\n\n/*-----------------------------------------------------*\\\n| Handle ALL pre-detection routines                     |\n| The system should be ready to start a detection thread|\n| (returns false if detection can not proceed)          |\n\\*-----------------------------------------------------*/\nbool ResourceManager::ProcessPreDetection()\n{\n    /*-----------------------------------------------------*\\\n    | Process pre-detection hooks                           |\n    \\*-----------------------------------------------------*/\n    ProcessPreDetectionHooks();\n\n    /*-----------------------------------------------------*\\\n    | Process Dynamic Detectors                             |\n    \\*-----------------------------------------------------*/\n    if(!dynamic_detectors_processed)\n    {\n        ProcessDynamicDetectors();\n    }\n\n    /*-----------------------------------------------------*\\\n    | Call detection start callbacks                        |\n    \\*-----------------------------------------------------*/\n    LOG_TRACE(\"[ResourceManager] Calling detection start callbacks.\");\n\n    for(std::size_t callback_idx = 0; callback_idx < DetectionStartCallbacks.size(); callback_idx++)\n    {\n        DetectionStartCallbacks[callback_idx](DetectionStartCallbackArgs[callback_idx]);\n    }\n\n    /*-----------------------------------------------------*\\\n    | Update the detector settings                          |\n    \\*-----------------------------------------------------*/\n    UpdateDetectorSettings();\n    if(detection_enabled)\n    {\n        /*-------------------------------------------------*\\\n        | Do nothing is it is already detecting devices     |\n        \\*-------------------------------------------------*/\n        if(detection_is_required.load())\n        {\n            return false;\n        }\n\n        /*-------------------------------------------------*\\\n        | If there's anything left from the last time,      |\n        | we shall remove it first                          |\n        \\*-------------------------------------------------*/\n        detection_percent = 0;\n        detection_string  = \"\";\n\n        DetectionProgressChanged();\n\n        Cleanup();\n\n        UpdateDeviceList();\n\n        /*-------------------------------------------------*\\\n        | Initialize HID interface for detection            |\n        \\*-------------------------------------------------*/\n        int hid_status = hid_init();\n\n        LOG_INFO(\"[ResourceManager] Initializing HID interfaces: %s\", ((hid_status == 0) ? \"Success\" : \"Failed\"));\n\n        /*-------------------------------------------------*\\\n        | Mark the detection as ongoing                     |\n        | So the detection thread may proceed               |\n        \\*-------------------------------------------------*/\n        detection_is_required = true;\n\n        return true;\n    }\n    return false;\n}\n\nvoid ResourceManager::DetectDevices()\n{\n    if(ProcessPreDetection())\n    {\n        // Run the detection coroutine\n        RunInBackgroundThread(std::bind(&ResourceManager::DetectDevicesCoroutine, this));\n    }\n\n    if(!detection_enabled)\n    {\n        ProcessPostDetection();\n    }\n}\n\nvoid ResourceManager::ProcessPostDetection()\n{\n    /*-------------------------------------------------*\\\n    | Signal that detection is complete                 |\n    \\*-------------------------------------------------*/\n    detection_percent     = 100;\n    DetectionProgressChanged();\n\n    LOG_INFO(\"[ResourceManager] Calling Post-detection callbacks\");\n    /*-----------------------------------------------------*\\\n    | Call detection end callbacks                          |\n    \\*-----------------------------------------------------*/\n    for(std::size_t callback_idx = 0; callback_idx < DetectionEndCallbacks.size(); callback_idx++)\n    {\n        DetectionEndCallbacks[callback_idx](DetectionEndCallbackArgs[callback_idx]);\n    }\n\n    detection_is_required = false;\n\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|                Detection completed                 |\");\n    LOG_INFO(\"------------------------------------------------------\");\n}\n\nvoid ResourceManager::DisableDetection()\n{\n    detection_enabled = false;\n}\n\nvoid ResourceManager::DetectDevicesCoroutine()\n{\n    DetectDeviceMutex.lock();\n\n    hid_device_info*    current_hid_device;\n    float               percent             = 0.0f;\n    float               percent_denominator = 0.0f;\n    json                detector_settings;\n    unsigned int        hid_device_count    = 0;\n    hid_device_info*    hid_devices         = NULL;\n    bool                hid_safe_mode       = false;\n\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|               Start device detection               |\");\n    LOG_INFO(\"------------------------------------------------------\");\n\n    /*-------------------------------------------------*\\\n    | Reset the size entry used flags vector            |\n    \\*-------------------------------------------------*/\n    detection_size_entry_used.resize(rgb_controllers_sizes.size());\n\n    for(std::size_t size_idx = 0; size_idx < (unsigned int)detection_size_entry_used.size(); size_idx++)\n    {\n        detection_size_entry_used[size_idx] = false;\n    }\n\n    /*-------------------------------------------------*\\\n    | Open device disable list and read in disabled     |\n    | device strings                                    |\n    \\*-------------------------------------------------*/\n    detector_settings = settings_manager->GetSettings(\"Detectors\");\n\n    /*-------------------------------------------------*\\\n    | Check HID safe mode setting                       |\n    \\*-------------------------------------------------*/\n    if(detector_settings.contains(\"hid_safe_mode\"))\n    {\n        hid_safe_mode = detector_settings[\"hid_safe_mode\"];\n    }\n\n    /*-------------------------------------------------*\\\n    | Calculate the percentage denominator by adding    |\n    | the number of I2C and miscellaneous detectors and |\n    | the number of enumerated HID devices              |\n    |                                                   |\n    | Start by iterating through all HID devices in     |\n    | list to get a total count                         |\n    \\*-------------------------------------------------*/\n    if(!hid_safe_mode)\n    {\n        hid_devices = hid_enumerate(0, 0);\n    }\n\n    current_hid_device = hid_devices;\n\n    while(current_hid_device)\n    {\n        hid_device_count++;\n\n        current_hid_device = current_hid_device->next;\n    }\n\n    percent_denominator = (float)(i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_pci_device_detectors.size() + device_detectors.size()) + (float)hid_device_count;\n\n    /*-------------------------------------------------*\\\n    | Start at 0% detection progress                    |\n    \\*-------------------------------------------------*/\n    detection_percent = 0;\n\n#ifdef __linux__\n    /*-------------------------------------------------*\\\n    | Check if the udev rules exist                     |\n    \\*-------------------------------------------------*/\n    bool udev_not_exist     = false;\n    bool udev_multiple      = false;\n\n    if(access(\"/etc/udev/rules.d/60-openrgb.rules\", F_OK) != 0)\n    {\n        if(access(\"/usr/lib/udev/rules.d/60-openrgb.rules\", F_OK) != 0)\n        {\n            udev_not_exist  = true;\n        }\n    }\n    else\n    {\n        if(access(\"/usr/lib/udev/rules.d/60-openrgb.rules\", F_OK) == 0)\n        {\n            udev_multiple   = true;\n        }\n    }\n#endif\n\n    /*-------------------------------------------------*\\\n    | Detect i2c interfaces                             |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|             Detecting I2C interfaces               |\");\n    LOG_INFO(\"------------------------------------------------------\");\n\n    bool i2c_interface_fail = false;\n\n    for(unsigned int i2c_bus_detector_idx = 0; i2c_bus_detector_idx < (unsigned int)i2c_bus_detectors.size() && detection_is_required.load(); i2c_bus_detector_idx++)\n    {\n        if(i2c_bus_detectors[i2c_bus_detector_idx]() == false)\n        {\n            i2c_interface_fail = true;\n        }\n\n        I2CBusListChanged();\n    }\n\n    /*-------------------------------------------------*\\\n    | Detect i2c devices                                |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|               Detecting I2C devices                |\");\n    LOG_INFO(\"------------------------------------------------------\");\n    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)\n    {\n        unsigned int controller_size = rgb_controllers_hw.size();\n        detection_string = i2c_device_detector_strings[i2c_detector_idx].c_str();\n\n        /*-------------------------------------------------*\\\n        | Check if this detector is enabled                 |\n        \\*-------------------------------------------------*/\n        bool this_device_enabled = true;\n        if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n        {\n            this_device_enabled = detector_settings[\"detectors\"][detection_string];\n        }\n\n        LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n        if(this_device_enabled)\n        {\n            DetectionProgressChanged();\n\n            i2c_device_detectors[i2c_detector_idx](busses);\n        }\n\n        /*-------------------------------------------------*\\\n        | If the device list size has changed, call the     |\n        | device list changed callbacks                     |\n        \\*-------------------------------------------------*/\n        if(rgb_controllers_hw.size() == controller_size)\n        {\n            LOG_DEBUG(\"[%s] no devices found\", detection_string);\n        }\n\n        LOG_TRACE(\"[%s] detection end\", detection_string);\n\n        /*-------------------------------------------------*\\\n        | Update detection percent                          |\n        \\*-------------------------------------------------*/\n        percent = ((float)i2c_detector_idx + 1.0f) / percent_denominator;\n\n        detection_percent = (unsigned int)(percent * 100.0f);\n    }\n\n    /*-------------------------------------------------*\\\n    | Detect i2c DIMM modules                           |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|            Detecting I2C DIMM modules              |\");\n    LOG_INFO(\"------------------------------------------------------\");\n    for(unsigned int bus = 0; bus < busses.size() && IsAnyDimmDetectorEnabled(detector_settings); bus++)\n    {\n        IF_DRAM_SMBUS(busses[bus]->pci_vendor, busses[bus]->pci_device)\n        {\n            std::vector<SPDWrapper> slots;\n            SPDMemoryType dimm_type = SPD_RESERVED;\n\n            for(uint8_t spd_addr = 0x50; spd_addr < 0x58; spd_addr++)\n            {\n                SPDDetector spd(busses[bus], spd_addr, dimm_type);\n                if(spd.is_valid())\n                {\n                    SPDWrapper accessor(spd);\n                    dimm_type = spd.memory_type();\n                    LOG_INFO(\"[ResourceManager] Detected occupied slot %d, bus %d, type %s\", spd_addr - 0x50 + 1, bus, spd_memory_type_name[dimm_type]);\n                    LOG_DEBUG(\"[ResourceManager] Jedec ID: 0x%04x\", accessor.jedec_id());\n                    slots.push_back(accessor);\n                }\n            }\n\n            for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < i2c_dimm_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)\n            {\n                if(i2c_dimm_device_detectors[i2c_detector_idx].dimm_type == dimm_type &&\n                   is_jedec_in_slots(slots, i2c_dimm_device_detectors[i2c_detector_idx].jedec_id))\n                {\n                    detection_string = i2c_dimm_device_detectors[i2c_detector_idx].name.c_str();\n\n                    /*-------------------------------------------------*\\\n                    | Check if this detector is enabled                 |\n                    \\*-------------------------------------------------*/\n                    bool this_device_enabled = true;\n                    if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n                    {\n                        this_device_enabled = detector_settings[\"detectors\"][detection_string];\n                    }\n\n                    LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n                    if(this_device_enabled)\n                    {\n                        DetectionProgressChanged();\n\n                        std::vector<SPDWrapper*> matching_slots = slots_with_jedec(slots, i2c_dimm_device_detectors[i2c_detector_idx].jedec_id);\n                        i2c_dimm_device_detectors[i2c_detector_idx].function(busses[bus], matching_slots);\n                    }\n\n                    LOG_TRACE(\"[%s] detection end\", detection_string);\n                }\n\n                /*-------------------------------------------------*\\\n                | Update detection percent                          |\n                \\*-------------------------------------------------*/\n                percent = (i2c_device_detectors.size() + i2c_detector_idx + 1.0f) / percent_denominator;\n\n                detection_percent = (unsigned int)(percent * 100.0f);\n            }\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Detect i2c PCI devices                            |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|               Detecting I2C PCI devices            |\");\n    LOG_INFO(\"------------------------------------------------------\");\n    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_pci_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)\n    {\n        detection_string = i2c_pci_device_detectors[i2c_detector_idx].name.c_str();\n\n        /*-------------------------------------------------*\\\n        | Check if this detector is enabled                 |\n        \\*-------------------------------------------------*/\n        bool this_device_enabled = true;\n        if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n        {\n            this_device_enabled = detector_settings[\"detectors\"][detection_string];\n        }\n\n        LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n        if(this_device_enabled)\n        {\n            DetectionProgressChanged();\n\n            for(unsigned int bus = 0; bus < busses.size(); bus++)\n            {\n                if(busses[bus]->pci_vendor           == i2c_pci_device_detectors[i2c_detector_idx].ven_id    &&\n                   busses[bus]->pci_device           == i2c_pci_device_detectors[i2c_detector_idx].dev_id    &&\n                   busses[bus]->pci_subsystem_vendor == i2c_pci_device_detectors[i2c_detector_idx].subven_id &&\n                   busses[bus]->pci_subsystem_device == i2c_pci_device_detectors[i2c_detector_idx].subdev_id)\n                {\n                    i2c_pci_device_detectors[i2c_detector_idx].function(busses[bus], i2c_pci_device_detectors[i2c_detector_idx].i2c_addr, i2c_pci_device_detectors[i2c_detector_idx].name);\n                }\n            }\n        }\n\n        LOG_TRACE(\"[%s] detection end\", detection_string);\n\n        /*-------------------------------------------------*\\\n        | Update detection percent                          |\n        \\*-------------------------------------------------*/\n        percent = (i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_detector_idx + 1.0f) / percent_denominator;\n\n        detection_percent = (unsigned int)(percent * 100.0f);\n    }\n\n    /*-------------------------------------------------*\\\n    | Detect HID devices                                |\n    |                                                   |\n    | Reset current device pointer to first device      |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|               Detecting HID devices                |\");\n    if (hid_safe_mode)\n    LOG_INFO(\"|                  with safe mode                    |\");\n    LOG_INFO(\"------------------------------------------------------\");\n    current_hid_device = hid_devices;\n\n    if(hid_safe_mode)\n    {\n        /*-----------------------------------------------------------------------------*\\\n        | Loop through all available detectors.  If all required information matches,   |\n        | run the detector                                                              |\n        \\*-----------------------------------------------------------------------------*/\n        for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)\n        {\n            HIDDeviceDetectorBlock & detector = hid_device_detectors[hid_detector_idx];\n            hid_devices = hid_enumerate(detector.vid, detector.pid);\n\n            LOG_VERBOSE(\"[ResourceManager] Trying to run detector for [%s] (for %04x:%04x)\", detector.name.c_str(), detector.vid, detector.pid);\n\n            current_hid_device = hid_devices;\n\n            while(current_hid_device)\n            {\n\n                if(detector.compare(current_hid_device))\n                {\n                    detection_string = detector.name.c_str();\n\n                    /*-------------------------------------------------*\\\n                    | Check if this detector is enabled or needs to be  |\n                    | added to the settings list                        |\n                    \\*-------------------------------------------------*/\n                    bool this_device_enabled = true;\n                    if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n                    {\n                        this_device_enabled = detector_settings[\"detectors\"][detection_string];\n                    }\n\n                    LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n\n                    if(this_device_enabled)\n                    {\n                        DetectionProgressChanged();\n\n                        detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);\n\n                        LOG_TRACE(\"[%s] detection end\", detection_string);\n                    }\n                }\n\n                current_hid_device = current_hid_device->next;\n            }\n\n            hid_free_enumeration(hid_devices);\n        }\n    }\n    else\n    {\n        /*-------------------------------------------------*\\\n        | Iterate through all devices in list and run       |\n        | detectors                                         |\n        \\*-------------------------------------------------*/\n        hid_device_count = 0;\n\n        while(current_hid_device)\n        {\n            if(LogManager::get()->getLoglevel() >= LL_DEBUG)\n            {\n                const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);\n                const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);\n                LOG_DEBUG(\"[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s\", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);\n            }\n            detection_string = \"\";\n            DetectionProgressChanged();\n\n            /*-----------------------------------------------------------------------------*\\\n            | Loop through all available detectors.  If all required information matches,   |\n            | run the detector                                                              |\n            \\*-----------------------------------------------------------------------------*/\n            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)\n            {\n                HIDDeviceDetectorBlock & detector = hid_device_detectors[hid_detector_idx];\n                if(detector.compare(current_hid_device))\n                {\n                    detection_string = detector.name.c_str();\n\n                    /*-------------------------------------------------*\\\n                    | Check if this detector is enabled or needs to be  |\n                    | added to the settings list                        |\n                    \\*-------------------------------------------------*/\n                    bool this_device_enabled = true;\n                    if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n                    {\n                        this_device_enabled = detector_settings[\"detectors\"][detection_string];\n                    }\n\n                    LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n\n                    if(this_device_enabled)\n                    {\n                        DetectionProgressChanged();\n\n                        detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);\n                    }\n                }\n            }\n\n            /*-----------------------------------------------------------------------------*\\\n            | Loop through all available wrapped HID detectors.  If all required            |\n            | information matches, run the detector                                         |\n            \\*-----------------------------------------------------------------------------*/\n            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)\n            {\n                HIDWrappedDeviceDetectorBlock & detector = hid_wrapped_device_detectors[hid_detector_idx];\n                if(detector.compare(current_hid_device))\n                {\n                    detection_string = detector.name.c_str();\n\n                    /*-------------------------------------------------*\\\n                    | Check if this detector is enabled or needs to be  |\n                    | added to the settings list                        |\n                    \\*-------------------------------------------------*/\n                    bool this_device_enabled = true;\n                    if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n                    {\n                        this_device_enabled = detector_settings[\"detectors\"][detection_string];\n                    }\n\n                    LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n\n                    if(this_device_enabled)\n                    {\n                        DetectionProgressChanged();\n\n                        detector.function(default_wrapper, current_hid_device, hid_wrapped_device_detectors[hid_detector_idx].name);\n                    }\n                }\n            }\n\n            /*-------------------------------------------------*\\\n            | Update detection percent                          |\n            \\*-------------------------------------------------*/\n            hid_device_count++;\n\n            percent = (i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;\n\n            detection_percent = (unsigned int)(percent * 100.0f);\n\n            /*-------------------------------------------------*\\\n            | Move on to the next HID device                    |\n            \\*-------------------------------------------------*/\n            current_hid_device = current_hid_device->next;\n        }\n\n        /*-------------------------------------------------*\\\n        | Done using the device list, free it               |\n        \\*-------------------------------------------------*/\n        hid_free_enumeration(hid_devices);\n    }\n\n    /*-------------------------------------------------*\\\n    | Detect HID devices                                |\n    |                                                   |\n    | Reset current device pointer to first device      |\n    \\*-------------------------------------------------*/\n#ifdef __linux__\n#ifdef __GLIBC__\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|            Detecting libusb HID devices            |\");\n    LOG_INFO(\"------------------------------------------------------\");\n\n    void *         dyn_handle = NULL;\n    hidapi_wrapper wrapper;\n\n    /*-------------------------------------------------*\\\n    | Load the libhidapi-libusb library                 |\n    \\*-------------------------------------------------*/\n#ifdef __GLIBC__\n    if((dyn_handle = dlopen(\"libhidapi-libusb.so\", RTLD_NOW | RTLD_NODELETE | RTLD_DEEPBIND)))\n#else\n    if(dyn_handle = dlopen(\"libhidapi-libusb.so\", RTLD_NOW | RTLD_NODELETE ))\n#endif\n    {\n        /*-------------------------------------------------*\\\n        | Create a wrapper with the libusb functions        |\n        \\*-------------------------------------------------*/\n        wrapper =\n        {\n            .dyn_handle                     = dyn_handle,\n            .hid_send_feature_report        = (hidapi_wrapper_send_feature_report)          dlsym(dyn_handle,\"hid_send_feature_report\"),\n            .hid_get_feature_report         = (hidapi_wrapper_get_feature_report)           dlsym(dyn_handle,\"hid_get_feature_report\"),\n            .hid_get_serial_number_string   = (hidapi_wrapper_get_serial_number_string)     dlsym(dyn_handle,\"hid_get_serial_number_string\"),\n            .hid_open_path                  = (hidapi_wrapper_open_path)                    dlsym(dyn_handle,\"hid_open_path\"),\n            .hid_enumerate                  = (hidapi_wrapper_enumerate)                    dlsym(dyn_handle,\"hid_enumerate\"),\n            .hid_free_enumeration           = (hidapi_wrapper_free_enumeration)             dlsym(dyn_handle,\"hid_free_enumeration\"),\n            .hid_close                      = (hidapi_wrapper_close)                        dlsym(dyn_handle,\"hid_close\"),\n            .hid_error                      = (hidapi_wrapper_error)                        dlsym(dyn_handle,\"hid_free_enumeration\")\n        };\n\n        hid_devices = wrapper.hid_enumerate(0, 0);\n\n        current_hid_device = hid_devices;\n\n        /*-------------------------------------------------*\\\n        | Iterate through all devices in list and run       |\n        | detectors                                         |\n        \\*-------------------------------------------------*/\n        hid_device_count = 0;\n\n        while(current_hid_device)\n        {\n            if(LogManager::get()->getLoglevel() >= LL_DEBUG)\n            {\n                const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);\n                const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);\n                LOG_DEBUG(\"[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s\", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);\n            }\n            detection_string = \"\";\n            DetectionProgressChanged();\n\n            /*-----------------------------------------------------------------------------*\\\n            | Loop through all available wrapped HID detectors.  If all required            |\n            | information matches, run the detector                                         |\n            \\*-----------------------------------------------------------------------------*/\n            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)\n            {\n                HIDWrappedDeviceDetectorBlock & detector = hid_wrapped_device_detectors[hid_detector_idx];\n                if(detector.compare(current_hid_device))\n                {\n                    detection_string = detector.name.c_str();\n\n                    /*-------------------------------------------------*\\\n                    | Check if this detector is enabled or needs to be  |\n                    | added to the settings list                        |\n                    \\*-------------------------------------------------*/\n                    bool this_device_enabled = true;\n                    if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n                    {\n                        this_device_enabled = detector_settings[\"detectors\"][detection_string];\n                    }\n\n                    LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n\n                    if(this_device_enabled)\n                    {\n                        DetectionProgressChanged();\n\n                        detector.function(wrapper, current_hid_device, detector.name);\n                    }\n                }\n            }\n\n            /*-------------------------------------------------*\\\n            | Update detection percent                          |\n            \\*-------------------------------------------------*/\n            hid_device_count++;\n\n            percent = (i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;\n\n            detection_percent = percent * 100.0f;\n\n            /*-------------------------------------------------*\\\n            | Move on to the next HID device                    |\n            \\*-------------------------------------------------*/\n            current_hid_device = current_hid_device->next;\n        }\n\n        /*-------------------------------------------------*\\\n        | Done using the device list, free it               |\n        \\*-------------------------------------------------*/\n        wrapper.hid_free_enumeration(hid_devices);\n    }\n#endif\n#endif\n\n    /*-------------------------------------------------*\\\n    | Detect other devices                              |\n    \\*-------------------------------------------------*/\n    LOG_INFO(\"------------------------------------------------------\");\n    LOG_INFO(\"|              Detecting other devices               |\");\n    LOG_INFO(\"------------------------------------------------------\");\n\n    for(unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size() && detection_is_required.load(); detector_idx++)\n    {\n        detection_string = device_detector_strings[detector_idx].c_str();\n\n        /*-------------------------------------------------*\\\n        | Check if this detector is enabled                 |\n        \\*-------------------------------------------------*/\n        bool this_device_enabled = true;\n        if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string))\n        {\n            this_device_enabled = detector_settings[\"detectors\"][detection_string];\n        }\n\n        LOG_DEBUG(\"[%s] is %s\", detection_string, ((this_device_enabled == true) ? \"enabled\" : \"disabled\"));\n\n        if(this_device_enabled)\n        {\n            DetectionProgressChanged();\n\n            device_detectors[detector_idx]();\n        }\n\n        LOG_TRACE(\"[%s] detection end\", detection_string);\n\n        /*-------------------------------------------------*\\\n        | Update detection percent                          |\n        \\*-------------------------------------------------*/\n        percent = (i2c_device_detectors.size() + hid_device_count + detector_idx + 1.0f) / percent_denominator;\n\n        detection_percent = (unsigned int)(percent * 100.0f);\n    }\n\n    /*-------------------------------------------------*\\\n    | Make sure that when the detection is done,        |\n    | progress bar is set to 100%                       |\n    \\*-------------------------------------------------*/\n    ProcessPostDetection();\n\n    DetectDeviceMutex.unlock();\n\n#ifdef __linux__\n    /*-------------------------------------------------*\\\n    | If the udev rules file is not installed, show a   |\n    | dialog                                            |\n    \\*-------------------------------------------------*/\n    if(udev_not_exist)\n    {\n        const char* message =  \"<h2>WARNING:</h2>\"\n                                \"<p>The OpenRGB udev rules are not installed.</p>\"\n                                \"<p>Most devices will not be available unless running OpenRGB as root.</p>\"\n                                \"<p>If using AppImage, Flatpak, or self-compiled versions of OpenRGB you must install the udev rules manually</p>\"\n                                \"<p>See <a href='https://openrgb.org/udev'>https://openrgb.org/udev</a> to install the udev rules manually</p>\";\n\n        LOG_DIALOG(\"%s\", message);\n\n        udev_multiple       = false;\n        i2c_interface_fail  = false;\n    }\n\n    /*-------------------------------------------------*\\\n    | If multiple udev rules files are installed, show  |\n    | a dialog                                          |\n    \\*-------------------------------------------------*/\n    if(udev_multiple)\n    {\n        const char* message =  \"<h2>WARNING:</h2>\"\n                                \"<p>Multiple OpenRGB udev rules are installed.</p>\"\n                                \"<p>The udev rules file 60-openrgb.rules is installed in both /etc/udev/rules.d and /usr/lib/udev/rules.d.</p>\"\n                                \"<p>Multiple udev rules files can conflict, it is recommended to remove one of them.</p>\";\n\n        LOG_DIALOG(\"%s\", message);\n\n        i2c_interface_fail  = false;\n    }\n\n#endif\n\n    /*-------------------------------------------------*\\\n    | If any i2c interfaces failed to detect due to an  |\n    | error condition, show a dialog                    |\n    \\*-------------------------------------------------*/\n    if(i2c_interface_fail)\n    {\n        const char* message =   \"<h2>Some internal devices may not be detected:</h2>\"\n                                \"<p>One or more I2C or SMBus interfaces failed to initialize.</p>\"\n                                \"<p><b>RGB DRAM modules, some motherboards' onboard RGB lighting, and RGB Graphics Cards, will not be available in OpenRGB</b> without I2C or SMBus.</p>\"\n\n                                \"<h4>How to fix this:</h4>\"\n#ifdef _WIN32\n                                \"<p>On Windows, this is usually caused by a failure to load the WinRing0 driver.</p>\"\n                                \"<p>You must run OpenRGB as administrator at least once to allow WinRing0 to set up.</p>\"\n#endif\n#ifdef __linux__\n                                \"<p>On Linux, this is usually because the i2c-dev module is not loaded.</p>\"\n                                \"<p>You must load the i2c-dev module along with the correct i2c driver for your motherboard. \"\n                                \"This is usually i2c-piix4 for AMD systems and i2c-i801 for Intel systems.</p>\"\n#endif\n                                \"<p>See <a href='https://help.openrgb.org/'>help.openrgb.org</a> for additional troubleshooting steps if you keep seeing this message.<br></p>\"\n                                \"<h3>If you are not using internal RGB on a desktop this message is not important to you.</h3>\";\n\n        LOG_DIALOG(\"%s\", message);\n    }\n}\n\nvoid ResourceManager::StopDeviceDetection()\n{\n    LOG_INFO(\"[ResourceManager] Detection abort requested\");\n    detection_is_required = false;\n    detection_percent = 100;\n    detection_string = \"Stopping\";\n}\n\nvoid ResourceManager::Initialize(bool tryConnect, bool detectDevices, bool startServer, bool applyPostOptions)\n{\n    // Cache the parameters\n    // TODO: Possibly cache them in the CLI file somewhere\n    tryAutoConnect     = tryConnect;\n    detection_enabled  = detectDevices;\n    start_server       = startServer;\n    apply_post_options = applyPostOptions;\n\n    RunInBackgroundThread(std::bind(&ResourceManager::InitCoroutine, this));\n}\n\nvoid ResourceManager::InitCoroutine()\n{\n    if(tryAutoConnect)\n    {\n        detection_percent = 0;\n        detection_string  = \"Attempting server connection...\";\n        DetectionProgressChanged();\n\n        // Disable detection if a local server was found\n        if(AttemptLocalConnection())\n        {\n            DisableDetection();\n        }\n        else\n        {\n            LOG_DEBUG(\"[ResourceManager] Local OpenRGB server connected, running in client mode\");\n        }\n        tryAutoConnect = false;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Perform actual detection                                  |\n    | Done in the same thread (InitThread), as we need to wait  |\n    | for completion anyway                                     |\n    \\*---------------------------------------------------------*/\n    if(detection_enabled)\n    {\n        LOG_DEBUG(\"[ResourceManager] Running standalone\");\n        if(ProcessPreDetection())\n        {\n            // We are currently in a coroutine, so run detection directly with no scheduling\n            DetectDevicesCoroutine();\n        }\n    }\n    else\n    {\n        ProcessPostDetection();\n    }\n\n    if(start_server)\n    {\n        detection_percent = 100;\n        detection_string = \"Starting server\";\n        DetectionProgressChanged();\n\n        GetServer()->StartServer();\n        if(!GetServer()->GetOnline())\n        {\n            LOG_DEBUG(\"[ResourceManager] Server failed to start\");\n        }\n    }\n\n    /*---------------------------------------------------------*\\\n    | Process command line arguments after detection only if the|\n    | pre-detection parsing indicated it should be run          |\n    \\*---------------------------------------------------------*/\n    if(apply_post_options)\n    {\n        cli_post_detection();\n    }\n\n    init_finished = true;\n}\n\nvoid ResourceManager::HidExitCoroutine()\n{\n    /*-------------------------------------------------*\\\n    | Cleanup HID interface                             |\n    | WARNING: may not be ran from any other thread!!!  |\n    \\*-------------------------------------------------*/\n    int hid_status = hid_exit();\n\n    LOG_DEBUG(\"[ResourceManager] Closing HID interfaces: %s\", ((hid_status == 0) ? \"Success\" : \"Failed\"));\n}\n\nvoid ResourceManager::RunInBackgroundThread(std::function<void()> coroutine)\n{\n    if(std::this_thread::get_id() == DetectDevicesThread->get_id())\n    {\n        // We are already in the background thread - don't schedule the call, run it immediately\n        coroutine();\n    }\n    else\n    {\n        BackgroundThreadStateMutex.lock();\n        if(ScheduledBackgroundFunction != nullptr)\n        {\n            LOG_WARNING(\"[ResourceManager] Detection coroutine: assigned a new coroutine when one was already scheduled - probably two rescan events sent at once\");\n        }\n        ScheduledBackgroundFunction = coroutine;\n        BackgroundThreadStateMutex.unlock();\n        BackgroundFunctionStartTrigger.notify_one();\n    }\n}\n\nvoid ResourceManager::BackgroundThreadFunction()\n{\n    // The background thread that runs scheduled coroutines when applicable\n    // Stays asleep if nothing is scheduled\n    // NOTE: this thread owns the HIDAPI library internal objects on MacOS\n    // hid_init and hid_exit may not be called outside of this thread\n    // calling hid_exit outside of this thread WILL cause an immediate CRASH on MacOS\n    // BackgroundThreadStateMutex will be UNLOCKED as long as the thread is suspended\n    // It locks automatically when any coroutine is running\n    // However, it seems to be necessary to be separate from the DeviceDetectionMutex, even though their states are nearly identical\n\n    std::unique_lock lock(BackgroundThreadStateMutex);\n    while(background_thread_running)\n    {\n        if(ScheduledBackgroundFunction)\n        {\n            std::function<void()> coroutine = nullptr;\n            std::swap(ScheduledBackgroundFunction, coroutine);\n            try\n            {\n                coroutine();\n            }\n            catch(std::exception& e)\n            {\n                LOG_ERROR(\"[ResourceManager] Unhandled exception in coroutine; e.what(): %s\", e.what());\n            }\n            catch(...)\n            {\n                LOG_ERROR(\"[ResourceManager] Unhandled exception in coroutine\");\n            }\n        }\n        // This line will cause the thread to suspend until the condition variable is triggered\n        // NOTE: it may be subject to \"spurious wakeups\"\n        BackgroundFunctionStartTrigger.wait(lock);\n    }\n}\n\nvoid ResourceManager::UpdateDetectorSettings()\n{\n    json                detector_settings;\n    bool                save_settings       = false;\n\n    /*-------------------------------------------------*\\\n    | Open device disable list and read in disabled     |\n    | device strings                                    |\n    \\*-------------------------------------------------*/\n    detector_settings = settings_manager->GetSettings(\"Detectors\");\n\n    /*-------------------------------------------------*\\\n    | Loop through all I2C detectors and see if any     |\n    | need to be saved to the settings                  |\n    \\*-------------------------------------------------*/\n    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size(); i2c_detector_idx++)\n    {\n        detection_string = i2c_device_detector_strings[i2c_detector_idx].c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Loop through all I2C DIMM detectors and see       |\n    | if any need to be saved to the settings           |\n    \\*-------------------------------------------------*/\n    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_dimm_device_detectors.size(); i2c_detector_idx++)\n    {\n        detection_string = i2c_dimm_device_detectors[i2c_detector_idx].name.c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Loop through all I2C PCI detectors and see if any |\n    | need to be saved to the settings                  |\n    \\*-------------------------------------------------*/\n    for(unsigned int i2c_pci_detector_idx = 0; i2c_pci_detector_idx < (unsigned int)i2c_pci_device_detectors.size(); i2c_pci_detector_idx++)\n    {\n        detection_string = i2c_pci_device_detectors[i2c_pci_detector_idx].name.c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Loop through all HID detectors and see if any     |\n    | need to be saved to the settings                  |\n    \\*-------------------------------------------------*/\n    for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size(); hid_detector_idx++)\n    {\n        detection_string = hid_device_detectors[hid_detector_idx].name.c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Loop through all HID wrapped detectors and see if |\n    | any need to be saved to the settings              |\n    \\*-------------------------------------------------*/\n    for(unsigned int hid_wrapped_detector_idx = 0; hid_wrapped_detector_idx < (unsigned int)hid_wrapped_device_detectors.size(); hid_wrapped_detector_idx++)\n    {\n        detection_string = hid_wrapped_device_detectors[hid_wrapped_detector_idx].name.c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | Loop through remaining detectors and see if any   |\n    | need to be saved to the settings                  |\n    \\*-------------------------------------------------*/\n    for(unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size(); detector_idx++)\n    {\n        detection_string = device_detector_strings[detector_idx].c_str();\n\n        if(!(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string)))\n        {\n            detector_settings[\"detectors\"][detection_string] = true;\n            save_settings = true;\n        }\n    }\n\n    /*-------------------------------------------------*\\\n    | If there were any setting changes that need to be |\n    | saved, set the settings in the settings manager   |\n    | and save them.                                    |\n    \\*-------------------------------------------------*/\n    if(save_settings)\n    {\n        LOG_INFO(\"[ResourceManager] Saving detector settings\");\n\n        settings_manager->SetSettings(\"Detectors\", detector_settings);\n\n        settings_manager->SaveSettings();\n    }\n}\n\nvoid ResourceManager::WaitForInitialization()\n{\n    /*-------------------------------------------------*\\\n    | A reliable sychronization of this kind is         |\n    | impossible without the use of a `barrier`         |\n    | implementation, which is only introduced in C++20 |\n    \\*-------------------------------------------------*/\n    while (!init_finished)\n    {\n        std::this_thread::sleep_for(1ms);\n    };\n}\n\nvoid ResourceManager::WaitForDeviceDetection()\n{\n    DetectDeviceMutex.lock();\n    DetectDeviceMutex.unlock();\n}\n\nbool ResourceManager::IsAnyDimmDetectorEnabled(json &detector_settings)\n{\n    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < i2c_dimm_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)\n    {\n        detection_string = i2c_dimm_device_detectors[i2c_detector_idx].name.c_str();\n        /*-------------------------------------------------*\\\n        | Check if this detector is enabled                 |\n        \\*-------------------------------------------------*/\n        if(detector_settings.contains(\"detectors\") && detector_settings[\"detectors\"].contains(detection_string) &&\n           detector_settings[\"detectors\"][detection_string] == false)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n"
        },
        {
          "name": "ResourceManager.h",
          "type": "blob",
          "size": 20.3330078125,
          "content": "/*---------------------------------------------------------*\\\n| ResourceManager.h                                         |\n|                                                           |\n|   OpenRGB Resource Manager controls access to application |\n|   components including RGBControllers, I2C interfaces,    |\n|   and network SDK components                              |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                27 Sep 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <memory>\n#include <vector>\n#include <functional>\n#include <thread>\n#include <string>\n#include <vector>\n#include \"SPDWrapper.h\"\n#include \"hidapi_wrapper.h\"\n#include \"i2c_smbus.h\"\n#include \"filesystem.h\"\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\n#define HID_INTERFACE_ANY   -1\n#define HID_USAGE_ANY       -1\n#define HID_USAGE_PAGE_ANY  -1L\n\n#define CONTROLLER_LIST_HID 0\n\nstruct hid_device_info;\nclass NetworkClient;\nclass NetworkServer;\nclass ProfileManager;\nclass RGBController;\nclass SettingsManager;\n\ntypedef std::function<bool()>                                                               I2CBusDetectorFunction;\ntypedef std::function<void()>                                                               DeviceDetectorFunction;\ntypedef std::function<void(std::vector<i2c_smbus_interface*>&)>                             I2CDeviceDetectorFunction;\ntypedef std::function<void(i2c_smbus_interface*, std::vector<SPDWrapper*>&)>                I2CDIMMDeviceDetectorFunction;\ntypedef std::function<void(i2c_smbus_interface*, uint8_t, const std::string&)>              I2CPCIDeviceDetectorFunction;\ntypedef std::function<void(hid_device_info*, const std::string&)>                           HIDDeviceDetectorFunction;\ntypedef std::function<void(hidapi_wrapper wrapper, hid_device_info*, const std::string&)>   HIDWrappedDeviceDetectorFunction;\ntypedef std::function<void()>                                                               DynamicDetectorFunction;\ntypedef std::function<void()>                                                               PreDetectionHookFunction;\n\nclass BasicHIDBlock\n{\npublic:\n    std::string  name;\n    uint16_t     vid;\n    uint16_t     pid;\n    int          interface;\n    int          usage_page;\n    int          usage;\n\n    bool compare(hid_device_info* info);\n};\n\nclass HIDDeviceDetectorBlock : public BasicHIDBlock\n{\npublic:\n    HIDDeviceDetectorFunction   function;\n};\n\nclass HIDWrappedDeviceDetectorBlock : public BasicHIDBlock\n{\npublic:\n    HIDWrappedDeviceDetectorFunction    function;\n};\n\ntypedef struct\n{\n    std::string                     name;\n    I2CPCIDeviceDetectorFunction    function;\n    uint16_t                        ven_id;\n    uint16_t                        dev_id;\n    uint16_t                        subven_id;\n    uint16_t                        subdev_id;\n    uint8_t                         i2c_addr;\n} I2CPCIDeviceDetectorBlock;\n\ntypedef struct\n{\n    std::string                     name;\n    I2CDIMMDeviceDetectorFunction   function;\n    uint16_t                        jedec_id;\n    uint8_t                         dimm_type;\n} I2CDIMMDeviceDetectorBlock;\n\ntypedef void (*DeviceListChangeCallback)(void *);\ntypedef void (*DetectionProgressCallback)(void *);\ntypedef void (*DetectionStartCallback)(void *);\ntypedef void (*DetectionEndCallback)(void *);\ntypedef void (*I2CBusListChangeCallback)(void *);\n\nclass ResourceManagerInterface\n{\npublic:\n    virtual std::vector<i2c_smbus_interface*> & GetI2CBusses()                                                                                      = 0;\n\n    virtual void                                RegisterRGBController(RGBController *rgb_controller)                                                = 0;\n    virtual void                                UnregisterRGBController(RGBController *rgb_controller)                                              = 0;\n\n    virtual void                                RegisterDeviceListChangeCallback(DeviceListChangeCallback new_callback, void * new_callback_arg)    = 0;\n    virtual void                                RegisterDetectionProgressCallback(DetectionProgressCallback new_callback, void * new_callback_arg)  = 0;\n    virtual void                                RegisterDetectionStartCallback(DetectionStartCallback new_callback, void * new_callback_arg)        = 0;\n    virtual void                                RegisterDetectionEndCallback(DetectionEndCallback new_callback, void * new_callback_arg)            = 0;\n    virtual void                                RegisterI2CBusListChangeCallback(I2CBusListChangeCallback new_callback, void * new_callback_arg)    = 0;\n\n    virtual void                                UnregisterDeviceListChangeCallback(DeviceListChangeCallback callback, void * callback_arg)          = 0;\n    virtual void                                UnregisterDetectionProgressCallback(DetectionProgressCallback callback, void *callback_arg)         = 0;\n    virtual void                                UnregisterDetectionStartCallback(DetectionStartCallback callback, void *callback_arg)               = 0;\n    virtual void                                UnregisterDetectionEndCallback(DetectionEndCallback callback, void *callback_arg)                   = 0;\n    virtual void                                UnregisterI2CBusListChangeCallback(I2CBusListChangeCallback callback, void * callback_arg)          = 0;\n\n    virtual std::vector<RGBController*> &       GetRGBControllers()                                                                                 = 0;\n\n    virtual unsigned int                        GetDetectionPercent()                                                                               = 0;\n\n    virtual filesystem::path                    GetConfigurationDirectory()                                                                         = 0;\n\n    virtual std::vector<NetworkClient*>&        GetClients()                                                                                        = 0;\n    virtual NetworkServer*                      GetServer()                                                                                         = 0;\n\n    virtual ProfileManager*                     GetProfileManager()                                                                                 = 0;\n    virtual SettingsManager*                    GetSettingsManager()                                                                                = 0;\n\n    virtual void                                UpdateDeviceList()                                                                                  = 0;\n    virtual void                                WaitForDeviceDetection()                                                                            = 0;\n\nprotected:\n    virtual                                    ~ResourceManagerInterface() {};\n};\n\nclass ResourceManager: public ResourceManagerInterface\n{\npublic:\n    static ResourceManager *get();\n\n    ResourceManager();\n    ~ResourceManager();\n\n    void RegisterI2CBus(i2c_smbus_interface *);\n    std::vector<i2c_smbus_interface*> & GetI2CBusses();\n\n    void RegisterRGBController(RGBController *rgb_controller);\n    void UnregisterRGBController(RGBController *rgb_controller);\n\n    std::vector<RGBController*> & GetRGBControllers();\n\n    void RegisterI2CBusDetector         (I2CBusDetectorFunction     detector);\n    void RegisterDeviceDetector         (std::string name, DeviceDetectorFunction     detector);\n    void RegisterI2CDeviceDetector      (std::string name, I2CDeviceDetectorFunction  detector);\n    void RegisterI2CDIMMDeviceDetector  (std::string name, I2CDIMMDeviceDetectorFunction detector, uint16_t jedec_id, uint8_t dimm_type);\n    void RegisterI2CPCIDeviceDetector   (std::string name, I2CPCIDeviceDetectorFunction detector, uint16_t ven_id, uint16_t dev_id, uint16_t subven_id, uint16_t subdev_id, uint8_t i2c_addr);\n    void RegisterHIDDeviceDetector      (std::string name,\n                                         HIDDeviceDetectorFunction  detector,\n                                         uint16_t vid,\n                                         uint16_t pid,\n                                         int interface  = HID_INTERFACE_ANY,\n                                         int usage_page = HID_USAGE_PAGE_ANY,\n                                         int usage      = HID_USAGE_ANY);\n    void RegisterHIDWrappedDeviceDetector   (std::string name,\n                                            HIDWrappedDeviceDetectorFunction  detector,\n                                            uint16_t vid,\n                                            uint16_t pid,\n                                            int interface  = HID_INTERFACE_ANY,\n                                            int usage_page = HID_USAGE_PAGE_ANY,\n                                            int usage      = HID_USAGE_ANY);\n    void RegisterDynamicDetector        (std::string name, DynamicDetectorFunction detector);\n    void RegisterPreDetectionHook       (PreDetectionHookFunction hook);\n\n    void RegisterDeviceListChangeCallback(DeviceListChangeCallback new_callback, void * new_callback_arg);\n    void RegisterDetectionProgressCallback(DetectionProgressCallback new_callback, void * new_callback_arg);\n    void RegisterDetectionStartCallback(DetectionStartCallback new_callback, void * new_callback_arg);\n    void RegisterDetectionEndCallback(DetectionEndCallback new_callback, void * new_callback_arg);\n    void RegisterI2CBusListChangeCallback(I2CBusListChangeCallback new_callback, void * new_callback_arg);\n\n    void UnregisterDeviceListChangeCallback(DeviceListChangeCallback callback, void * callback_arg);\n    void UnregisterDetectionProgressCallback(DetectionProgressCallback callback, void *callback_arg);\n    void UnregisterDetectionStartCallback(DetectionStartCallback callback, void *callback_arg);\n    void UnregisterDetectionEndCallback(DetectionEndCallback callback, void *callback_arg);\n    void UnregisterI2CBusListChangeCallback(I2CBusListChangeCallback callback, void * callback_arg);\n\n    bool         GetDetectionEnabled();\n    unsigned int GetDetectionPercent();\n    const char*  GetDetectionString();\n\n    filesystem::path                GetConfigurationDirectory();\n\n    void RegisterNetworkClient(NetworkClient* new_client);\n    void UnregisterNetworkClient(NetworkClient* network_client);\n\n    std::vector<NetworkClient*>&    GetClients();\n    NetworkServer*                  GetServer();\n\n    ProfileManager*                 GetProfileManager();\n    SettingsManager*                GetSettingsManager();\n\n    void                            SetConfigurationDirectory(const filesystem::path &directory);\n\n    void ProcessPreDetectionHooks(); // Consider making private\n    void ProcessDynamicDetectors();  // Consider making private\n    void UpdateDeviceList();\n    void DeviceListChanged();\n    void DetectionProgressChanged();\n    void I2CBusListChanged();\n\n    void Initialize(bool tryConnect, bool detectDevices, bool startServer, bool applyPostOptions);\n\n    void Cleanup();\n\n    void DetectDevices();\n\n    void DisableDetection();\n\n    void StopDeviceDetection();\n\n    void WaitForInitialization();\n    void WaitForDeviceDetection();\n\nprivate:\n    void UpdateDetectorSettings();\n    void SetupConfigurationDirectory();\n    bool AttemptLocalConnection();\n    bool ProcessPreDetection();\n    void ProcessPostDetection();\n    bool IsAnyDimmDetectorEnabled(json &detector_settings);\n    void RunInBackgroundThread(std::function<void()>);\n    void BackgroundThreadFunction();\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Functions that must be run in the background thread                                   |\n    | These are not related to STL coroutines, yet this name is the most convenient         |\n    \\*-------------------------------------------------------------------------------------*/\n    void InitCoroutine();\n    void DetectDevicesCoroutine();\n    void HidExitCoroutine();\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Static pointer to shared instance of ResourceManager                                  |\n    \\*-------------------------------------------------------------------------------------*/\n    static ResourceManager*                     instance;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Auto connection permitting flag                                                       |\n    \\*-------------------------------------------------------------------------------------*/\n    bool                                        tryAutoConnect;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Detection enabled flag                                                                |\n    \\*-------------------------------------------------------------------------------------*/\n    bool                                        detection_enabled;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Auto connection permitting flag                                                       |\n    \\*-------------------------------------------------------------------------------------*/\n    bool                                        start_server;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Auto connection permitting flag                                                       |\n    \\*-------------------------------------------------------------------------------------*/\n    bool                                        apply_post_options;\n    /*-------------------------------------------------------------------------------------*\\\n    | Initialization completion flag                                                        |\n    \\*-------------------------------------------------------------------------------------*/\n    std::atomic<bool>                           init_finished;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Profile Manager                                                                       |\n    \\*-------------------------------------------------------------------------------------*/\n    ProfileManager*                             profile_manager;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Settings Manager                                                                      |\n    \\*-------------------------------------------------------------------------------------*/\n    SettingsManager*                            settings_manager;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | I2C/SMBus Interfaces                                                                  |\n    \\*-------------------------------------------------------------------------------------*/\n    std::vector<i2c_smbus_interface*>           busses;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | RGBControllers                                                                        |\n    \\*-------------------------------------------------------------------------------------*/\n    std::vector<RGBController*>                 rgb_controllers_sizes;\n    std::vector<RGBController*>                 rgb_controllers_hw;\n    std::vector<RGBController*>                 rgb_controllers;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Network Server                                                                        |\n    \\*-------------------------------------------------------------------------------------*/\n    NetworkServer*                              server;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Network Clients                                                                       |\n    \\*-------------------------------------------------------------------------------------*/\n    std::vector<NetworkClient*>                 clients;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Detectors                                                                             |\n    \\*-------------------------------------------------------------------------------------*/\n    std::vector<DeviceDetectorFunction>         device_detectors;\n    std::vector<std::string>                    device_detector_strings;\n    std::vector<I2CBusDetectorFunction>         i2c_bus_detectors;\n    std::vector<I2CDeviceDetectorFunction>      i2c_device_detectors;\n    std::vector<std::string>                    i2c_device_detector_strings;\n    std::vector<I2CDIMMDeviceDetectorBlock>     i2c_dimm_device_detectors;\n    std::vector<I2CPCIDeviceDetectorBlock>      i2c_pci_device_detectors;\n    std::vector<HIDDeviceDetectorBlock>         hid_device_detectors;\n    std::vector<HIDWrappedDeviceDetectorBlock>  hid_wrapped_device_detectors;\n    std::vector<DynamicDetectorFunction>        dynamic_detectors;\n    std::vector<std::string>                    dynamic_detector_strings;\n    std::vector<PreDetectionHookFunction>       pre_detection_hooks;\n\n    bool                                        dynamic_detectors_processed;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Detection Thread and Detection State                                                  |\n    \\*-------------------------------------------------------------------------------------*/\n    std::thread *                               DetectDevicesThread;\n    std::mutex                                  DetectDeviceMutex;\n    std::function<void()>                       ScheduledBackgroundFunction;\n    std::mutex                                  BackgroundThreadStateMutex;\n    std::condition_variable                     BackgroundFunctionStartTrigger; // NOTE: wakes up the background detection thread\n\n    std::atomic<bool>                           background_thread_running;\n    std::atomic<bool>                           detection_is_required;\n    std::atomic<unsigned int>                   detection_percent;\n    std::atomic<unsigned int>                   detection_prev_size;\n    std::vector<bool>                           detection_size_entry_used;\n    const char*                                 detection_string;\n\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Device List Changed Callback                                                          |\n    \\*-------------------------------------------------------------------------------------*/\n    std::mutex                                  DeviceListChangeMutex;\n    std::vector<DeviceListChangeCallback>       DeviceListChangeCallbacks;\n    std::vector<void *>                         DeviceListChangeCallbackArgs;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | Detection Progress, Start, and End Callbacks                                          |\n    \\*-------------------------------------------------------------------------------------*/\n    std::mutex                                  DetectionProgressMutex;\n    std::vector<DetectionProgressCallback>      DetectionProgressCallbacks;\n    std::vector<void *>                         DetectionProgressCallbackArgs;\n\n    std::vector<DetectionStartCallback>         DetectionStartCallbacks;\n    std::vector<void *>                         DetectionStartCallbackArgs;\n\n    std::vector<DetectionEndCallback>           DetectionEndCallbacks;\n    std::vector<void *>                         DetectionEndCallbackArgs;\n\n    /*-------------------------------------------------------------------------------------*\\\n    | I2C/SMBus Adapter List Changed Callback                                               |\n    \\*-------------------------------------------------------------------------------------*/\n    std::mutex                                  I2CBusListChangeMutex;\n    std::vector<I2CBusListChangeCallback>       I2CBusListChangeCallbacks;\n    std::vector<void *>                         I2CBusListChangeCallbackArgs;\n\n    filesystem::path config_dir;\n};\n"
        },
        {
          "name": "SPDAccessor",
          "type": "tree",
          "content": null
        },
        {
          "name": "SettingsManager.cpp",
          "type": "blob",
          "size": 4.0498046875,
          "content": "/*---------------------------------------------------------*\\\n| SettingsManager.cpp                                       |\n|                                                           |\n|   OpenRGB Settings Manager maintains a list of application|\n|   settings in JSON format.  Other components may register |\n|   settings with this class and store/load values.         |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                04 Nov 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <fstream>\n#include <iostream>\n#include \"SettingsManager.h\"\n#include \"LogManager.h\"\n\nSettingsManager::SettingsManager()\n{\n    config_found = false;\n}\n\nSettingsManager::~SettingsManager()\n{\n\n}\n\njson SettingsManager::GetSettings(std::string settings_key)\n{\n    /*---------------------------------------------------------*\\\n    | Check to see if the key exists in the settings store and  |\n    | return the settings associated with the key if it exists  |\n    | We lock the mutex to protect the value from changing      |\n    | while data is being read and copy before unlocking        |\n    \\*---------------------------------------------------------*/\n    json result;\n\n    mutex.lock();\n    if(settings_data.contains(settings_key))\n    {\n        result = settings_data[settings_key];\n    }\n\n    mutex.unlock();\n\n    return result;\n}\n\nvoid SettingsManager::SetSettings(std::string settings_key, json new_settings)\n{\n    mutex.lock();\n    settings_data[settings_key] = new_settings;\n    mutex.unlock();\n}\n\nvoid SettingsManager::LoadSettings(const filesystem::path& filename)\n{\n    /*---------------------------------------------------------*\\\n    | Clear any stored settings before loading                  |\n    \\*---------------------------------------------------------*/\n    mutex.lock();\n\n    settings_data.clear();\n\n    /*---------------------------------------------------------*\\\n    | Store settings filename, so we can save to it later       |\n    \\*---------------------------------------------------------*/\n    settings_filename = filename;\n\n    /*---------------------------------------------------------*\\\n    | Open input file in binary mode                            |\n    \\*---------------------------------------------------------*/\n    config_found = filesystem::exists(filename);\n    if(config_found)\n    {\n        std::ifstream settings_file(settings_filename, std::ios::in | std::ios::binary);\n\n        /*---------------------------------------------------------*\\\n        | Read settings into JSON store                             |\n        \\*---------------------------------------------------------*/\n        if(settings_file)\n        {\n            try\n            {\n                settings_file >> settings_data;\n            }\n            catch(const std::exception& e)\n            {\n                /*-------------------------------------------------*\\\n                | If an exception was caught, that means the JSON   |\n                | parsing failed.  Clear out any data in the store  |\n                | as it is corrupt.                                 |\n                | We could attempt a reload for backup location     |\n                \\*-------------------------------------------------*/\n                LOG_ERROR(\"[SettingsManager] JSON parsing failed: %s\", e.what());\n\n                settings_data.clear();\n            }\n        }\n\n        settings_file.close();\n    }\n\n    mutex.unlock();\n}\n\nvoid SettingsManager::SaveSettings()\n{\n    mutex.lock();\n    std::ofstream settings_file(settings_filename, std::ios::out | std::ios::binary);\n\n    if(settings_file)\n    {\n        try\n        {\n            settings_file << settings_data.dump(4);\n        }\n        catch(const std::exception& e)\n        {\n            LOG_ERROR(\"[SettingsManager] Cannot write to file: %s\", e.what());\n        }\n\n        settings_file.close();\n    }\n    mutex.unlock();\n}\n"
        },
        {
          "name": "SettingsManager.h",
          "type": "blob",
          "size": 1.7783203125,
          "content": "/*---------------------------------------------------------*\\\n| SettingsManager.h                                         |\n|                                                           |\n|   OpenRGB Settings Manager maintains a list of application|\n|   settings in JSON format.  Other components may register |\n|   settings with this class and store/load values.         |\n|                                                           |\n|   Adam Honse (CalcProgrammer1)                04 Nov 2020 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include \"json.hpp\"\n#include <mutex>\n#include \"filesystem.h\"\n\nusing json = nlohmann::json;\n\nclass SettingsManagerInterface\n{\npublic:\n    virtual json GetSettings(std::string settings_key)                       = 0;\n    virtual void SetSettings(std::string settings_key, json new_settings)    = 0;\n\n    virtual void LoadSettings(const filesystem::path& filename)              = 0;\n    virtual void SaveSettings()                                              = 0;\n\nprotected:\n    virtual ~SettingsManagerInterface() {};\n};\n\nclass SettingsManager: public SettingsManagerInterface\n{\npublic:\n    SettingsManager();\n    ~SettingsManager();\n\n    json GetSettings(std::string settings_key) override;\n    void SetSettings(std::string settings_key, json new_settings) override;\n\n    void LoadSettings(const filesystem::path& filename) override;\n    void SaveSettings() override;\n\nprivate:\n    json             settings_data;\n    json             settings_prototype;\n    filesystem::path settings_filename;\n    std::mutex       mutex;\n    bool             config_found;\n};\n"
        },
        {
          "name": "StringUtils.cpp",
          "type": "blob",
          "size": 1.9951171875,
          "content": "/*---------------------------------------------------------*\\\n| StringUtils.cpp                                           |\n|                                                           |\n|   String utility functions                                |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <codecvt>\n#include <locale>\n#include <string>\n#include \"StringUtils.h\"\n\nconst char* StringUtils::wchar_to_char(const wchar_t* pwchar)\n{\n    if (pwchar == nullptr)\n    {\n        return \"\";\n    }\n    // get the number of characters in the string.\n    int currentCharIndex = 0;\n    char currentChar = (char)pwchar[currentCharIndex];\n\n    while (currentChar != '\\0')\n    {\n        currentCharIndex++;\n        currentChar = (char)pwchar[currentCharIndex];\n    }\n\n    const int charCount = currentCharIndex + 1;\n\n    // allocate a new block of memory size char (1 byte) instead of wide char (2 bytes)\n    char* filePathC = (char*)malloc(sizeof(char) * charCount);\n\n    for (int i = 0; i < charCount; i++)\n    {\n        // convert to char (1 byte)\n        char character = (char)pwchar[i];\n\n        *filePathC = character;\n\n        filePathC += sizeof(char);\n\n    }\n    filePathC += '\\0';\n\n    filePathC -= (sizeof(char) * charCount);\n\n    return filePathC;\n}\n\nstd::string StringUtils::wstring_to_string(const std::wstring wstring)\n{\n    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n\n    return(converter.to_bytes(wstring));\n}\n\nstd::string StringUtils::u16string_to_string(const std::u16string wstring)\n{\n    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>,char16_t> converter;\n\n    return(converter.to_bytes(wstring));\n}\n\nconst std::string StringUtils::remove_null_terminating_chars(std::string input)\n{\n    while (!input.empty() && input.back() == 0)\n    {\n        input.pop_back();\n    }\n\n    return input;\n}\n\n"
        },
        {
          "name": "StringUtils.h",
          "type": "blob",
          "size": 0.8251953125,
          "content": "/*---------------------------------------------------------*\\\n| StringUtils.h                                             |\n|                                                           |\n|   String utility functions                                |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#pragma once\n\n#include <string>\n\nclass StringUtils\n{\npublic:\n    static const char* wchar_to_char(const wchar_t* pwchar);\n    static std::string wstring_to_string(const std::wstring wstring);\n    static std::string u16string_to_string(const std::u16string wstring);\n    static const std::string remove_null_terminating_chars(std::string input);\n};\n"
        },
        {
          "name": "SuspendResume",
          "type": "tree",
          "content": null
        },
        {
          "name": "cli.cpp",
          "type": "blob",
          "size": 66.2607421875,
          "content": "/*---------------------------------------------------------*\\\n| cli.cpp                                                   |\n|                                                           |\n|   OpenRGB command line interface                          |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <vector>\n#include <cstring>\n#include <string>\n#include <tuple>\n#include <iostream>\n#include \"AutoStart.h\"\n#include \"filesystem.h\"\n#include \"ProfileManager.h\"\n#include \"ResourceManager.h\"\n#include \"RGBController.h\"\n#include \"i2c_smbus.h\"\n#include \"NetworkClient.h\"\n#include \"NetworkServer.h\"\n#include \"LogManager.h\"\n#include \"Colors.h\"\n\n/*-------------------------------------------------------------*\\\n| Quirk for MSVC; which doesn't support this case-insensitive   |\n| function                                                      |\n\\*-------------------------------------------------------------*/\n#ifdef _WIN32\n#include <shellapi.h>\n    #define strcasecmp strcmpi\n#endif\n\nusing namespace std::chrono_literals;\n\nstatic std::string                 profile_save_filename = \"\";\nconst unsigned int                 brightness_percentage = 100;\nconst unsigned int                 speed_percentage      = 100;\n\nstatic int preserve_argc = 0;\nstatic char** preserve_argv = nullptr;\n\nenum\n{\n    RET_FLAG_PRINT_HELP         = 1,\n    RET_FLAG_START_GUI          = 2,\n    RET_FLAG_I2C_TOOLS          = 4,\n    RET_FLAG_START_MINIMIZED    = 8,\n    RET_FLAG_NO_DETECT          = 16,\n    RET_FLAG_CLI_POST_DETECTION = 32,\n    RET_FLAG_START_SERVER       = 64,\n    RET_FLAG_NO_AUTO_CONNECT    = 128,\n};\n\nstruct DeviceOptions\n{\n    int             device;\n    int             zone            = -1;\n    std::vector<std::tuple<unsigned char, unsigned char, unsigned char>> colors;\n    std::string     mode;\n    unsigned int    speed           = 100;\n    unsigned int    brightness      = 100;\n    unsigned int    size;\n    bool            random_colors   = false;\n    bool            hasSize         = false;\n    bool            hasOption       = false;\n};\n\nstruct ServerOptions\n{\n    bool start = false;\n    unsigned short  port = OPENRGB_SDK_PORT;\n};\n\nstruct Options\n{\n    std::vector<DeviceOptions>  devices;\n\n    /*---------------------------------------------------------*\\\n    | If hasDevice is false, devices above is empty and         |\n    | allDeviceOptions shall be applied to all available devices|\n    | except in the case that a profile was loaded.             |\n    \\*---------------------------------------------------------*/\n    bool                        hasDevice        = false;\n    bool                        profile_loaded  = false;\n    DeviceOptions               allDeviceOptions;\n    ServerOptions               servOpts;\n};\n\n/*---------------------------------------------------------------------------------------------------------*\\\n| Support a common subset of human colors; for easier typing: https://www.w3.org/TR/css-color-3/#svg-color  |\n\\*---------------------------------------------------------------------------------------------------------*/\nstruct HumanColors { uint32_t rgb; const char* keyword; } static const human_colors[] =\n{\n    { COLOR_BLACK, \"black\" },\n    { COLOR_NAVY, \"navy\" },\n    { COLOR_DARKBLUE, \"darkblue\" },\n    { COLOR_MEDIUMBLUE, \"mediumblue\" },\n    { COLOR_BLUE, \"blue\" },\n    { COLOR_DARKGREEN, \"darkgreen\" },\n    { COLOR_GREEN, \"green\" },\n    { COLOR_TEAL, \"teal\" },\n    { COLOR_DARKCYAN, \"darkcyan\" },\n    { COLOR_DEEPSKYBLUE, \"deepskyblue\" },\n    { COLOR_DARKTURQUOISE, \"darkturquoise\" },\n    { COLOR_MEDIUMSPRINGGREEN, \"mediumspringgreen\" },\n    { COLOR_LIME, \"lime\" },\n    { COLOR_SPRINGGREEN, \"springgreen\" },\n    { COLOR_AQUA, \"aqua\" },\n    { COLOR_CYAN, \"cyan\" },\n    { COLOR_MIDNIGHTBLUE, \"midnightblue\" },\n    { COLOR_DODGERBLUE, \"dodgerblue\" },\n    { COLOR_LIGHTSEAGREEN, \"lightseagreen\" },\n    { COLOR_FORESTGREEN, \"forestgreen\" },\n    { COLOR_SEAGREEN, \"seagreen\" },\n    { COLOR_DARKSLATEGRAY, \"darkslategray\" },\n    { COLOR_DARKSLATEGREY, \"darkslategrey\" },\n    { COLOR_LIMEGREEN, \"limegreen\" },\n    { COLOR_MEDIUMSEAGREEN, \"mediumseagreen\" },\n    { COLOR_TURQUOISE, \"turquoise\" },\n    { COLOR_ROYALBLUE, \"royalblue\" },\n    { COLOR_STEELBLUE, \"steelblue\" },\n    { COLOR_DARKSLATEBLUE, \"darkslateblue\" },\n    { COLOR_MEDIUMTURQUOISE, \"mediumturquoise\" },\n    { COLOR_INDIGO, \"indigo\" },\n    { COLOR_DARKOLIVEGREEN, \"darkolivegreen\" },\n    { COLOR_CADETBLUE, \"cadetblue\" },\n    { COLOR_CORNFLOWERBLUE, \"cornflowerblue\" },\n    { COLOR_MEDIUMAQUAMARINE, \"mediumaquamarine\" },\n    { COLOR_DIMGRAY, \"dimgray\" },\n    { COLOR_DIMGREY, \"dimgrey\" },\n    { COLOR_SLATEBLUE, \"slateblue\" },\n    { COLOR_OLIVEDRAB, \"olivedrab\" },\n    { COLOR_SLATEGRAY, \"slategray\" },\n    { COLOR_SLATEGREY, \"slategrey\" },\n    { COLOR_LIGHTSLATEGRAY, \"lightslategray\" },\n    { COLOR_LIGHTSLATEGREY, \"lightslategrey\" },\n    { COLOR_MEDIUMSLATEBLUE, \"mediumslateblue\" },\n    { COLOR_LAWNGREEN, \"lawngreen\" },\n    { COLOR_CHARTREUSE, \"chartreuse\" },\n    { COLOR_AQUAMARINE, \"aquamarine\" },\n    { COLOR_MAROON, \"maroon\" },\n    { COLOR_PURPLE, \"purple\" },\n    { COLOR_ELECTRIC_ULTRAMARINE, \"electricultramarine\" },\n    { COLOR_OLIVE, \"olive\" },\n    { COLOR_GRAY, \"gray\" },\n    { COLOR_GREY, \"grey\" },\n    { COLOR_SKYBLUE, \"skyblue\" },\n    { COLOR_LIGHTSKYBLUE, \"lightskyblue\" },\n    { COLOR_BLUEVIOLET, \"blueviolet\" },\n    { COLOR_DARKRED, \"darkred\" },\n    { COLOR_DARKMAGENTA, \"darkmagenta\" },\n    { COLOR_SADDLEBROWN, \"saddlebrown\" },\n    { COLOR_DARKSEAGREEN, \"darkseagreen\" },\n    { COLOR_LIGHTGREEN, \"lightgreen\" },\n    { COLOR_MEDIUMPURPLE, \"mediumpurple\" },\n    { COLOR_DARKVIOLET, \"darkviolet\" },\n    { COLOR_PALEGREEN, \"palegreen\" },\n    { COLOR_DARKORCHID, \"darkorchid\" },\n    { COLOR_YELLOWGREEN, \"yellowgreen\" },\n    { COLOR_SIENNA, \"sienna\" },\n    { COLOR_BROWN, \"brown\" },\n    { COLOR_DARKGRAY, \"darkgray\" },\n    { COLOR_DARKGREY, \"darkgrey\" },\n    { COLOR_LIGHTBLUE, \"lightblue\" },\n    { COLOR_GREENYELLOW, \"greenyellow\" },\n    { COLOR_PALETURQUOISE, \"paleturquoise\" },\n    { COLOR_LIGHTSTEELBLUE, \"lightsteelblue\" },\n    { COLOR_POWDERBLUE, \"powderblue\" },\n    { COLOR_FIREBRICK, \"firebrick\" },\n    { COLOR_DARKGOLDENROD, \"darkgoldenrod\" },\n    { COLOR_MEDIUMORCHID, \"mediumorchid\" },\n    { COLOR_ROSYBROWN, \"rosybrown\" },\n    { COLOR_DARKKHAKI, \"darkkhaki\" },\n    { COLOR_SILVER, \"silver\" },\n    { COLOR_MEDIUMVIOLETRED, \"mediumvioletred\" },\n    { COLOR_INDIANRED, \"indianred\" },\n    { COLOR_PERU, \"peru\" },\n    { COLOR_CHOCOLATE, \"chocolate\" },\n    { COLOR_TAN, \"tan\" },\n    { COLOR_LIGHTGRAY, \"lightgray\" },\n    { COLOR_LIGHTGREY, \"lightgrey\" },\n    { COLOR_THISTLE, \"thistle\" },\n    { COLOR_ORCHID, \"orchid\" },\n    { COLOR_GOLDENROD, \"goldenrod\" },\n    { COLOR_PALEVIOLETRED, \"palevioletred\" },\n    { COLOR_CRIMSON, \"crimson\" },\n    { COLOR_GAINSBORO, \"gainsboro\" },\n    { COLOR_PLUM, \"plum\" },\n    { COLOR_BURLYWOOD, \"burlywood\" },\n    { COLOR_LIGHTCYAN, \"lightcyan\" },\n    { COLOR_LAVENDER, \"lavender\" },\n    { COLOR_DARKSALMON, \"darksalmon\" },\n    { COLOR_VIOLET, \"violet\" },\n    { COLOR_PALEGOLDENROD, \"palegoldenrod\" },\n    { COLOR_LIGHTCORAL, \"lightcoral\" },\n    { COLOR_KHAKI, \"khaki\" },\n    { COLOR_ALICEBLUE, \"aliceblue\" },\n    { COLOR_HONEYDEW, \"honeydew\" },\n    { COLOR_AZURE, \"azure\" },\n    { COLOR_SANDYBROWN, \"sandybrown\" },\n    { COLOR_WHEAT, \"wheat\" },\n    { COLOR_BEIGE, \"beige\" },\n    { COLOR_WHITESMOKE, \"whitesmoke\" },\n    { COLOR_MINTCREAM, \"mintcream\" },\n    { COLOR_GHOSTWHITE, \"ghostwhite\" },\n    { COLOR_SALMON, \"salmon\" },\n    { COLOR_ANTIQUEWHITE, \"antiquewhite\" },\n    { COLOR_LINEN, \"linen\" },\n    { COLOR_LIGHTGOLDENRODYELLOW, \"lightgoldenrodyellow\" },\n    { COLOR_OLDLACE, \"oldlace\" },\n    { COLOR_RED, \"red\" },\n    { COLOR_FUCHSIA, \"fuchsia\" },\n    { COLOR_MAGENTA, \"magenta\" },\n    { COLOR_DEEPPINK, \"deeppink\" },\n    { COLOR_ORANGERED, \"orangered\" },\n    { COLOR_TOMATO, \"tomato\" },\n    { COLOR_HOTPINK, \"hotpink\" },\n    { COLOR_CORAL, \"coral\" },\n    { COLOR_DARKORANGE, \"darkorange\" },\n    { COLOR_LIGHTSALMON, \"lightsalmon\" },\n    { COLOR_ORANGE, \"orange\" },\n    { COLOR_LIGHTPINK, \"lightpink\" },\n    { COLOR_PINK, \"pink\" },\n    { COLOR_GOLD, \"gold\" },\n    { COLOR_PEACHPUFF, \"peachpuff\" },\n    { COLOR_NAVAJOWHITE, \"navajowhite\" },\n    { COLOR_MOCCASIN, \"moccasin\" },\n    { COLOR_BISQUE, \"bisque\" },\n    { COLOR_MISTYROSE, \"mistyrose\" },\n    { COLOR_BLANCHEDALMOND, \"blanchedalmond\" },\n    { COLOR_PAPAYAWHIP, \"papayawhip\" },\n    { COLOR_LAVENDERBLUSH, \"lavenderblush\" },\n    { COLOR_SEASHELL, \"seashell\" },\n    { COLOR_CORNSILK, \"cornsilk\" },\n    { COLOR_LEMONCHIFFON, \"lemonchiffon\" },\n    { COLOR_FLORALWHITE, \"floralwhite\" },\n    { COLOR_SNOW, \"snow\" },\n    { COLOR_YELLOW, \"yellow\" },\n    { COLOR_LIGHTYELLOW, \"lightyellow\" },\n    { COLOR_IVORY, \"ivory\" },\n    { COLOR_WHITE, \"white\" },\n    { 0, NULL }\n};\n\nbool ParseColors(std::string colors_string, DeviceOptions *options)\n{\n    while (colors_string.length() > 0)\n    {\n        size_t    rgb_end = colors_string.find_first_of(',');\n        std::string color = colors_string.substr(0, rgb_end);\n        int32_t rgb = 0;\n\n        bool parsed = false;\n\n        if (color.length() <= 0)\n            break;\n\n        /*-----------------------------------------------------------------*\\\n        | This will set correct colour mode for modes with a                |\n        |   MODE_COLORS_RANDOM else generate a random colour from the       |\n        |   human_colors list above                                         |\n        \\*-----------------------------------------------------------------*/\n        if (color == \"random\")\n        {\n            options->random_colors = true;\n            srand((unsigned int)time(NULL));\n            int index = rand() % (sizeof(human_colors) / sizeof(human_colors[0])) + 1; //Anything other than black\n            rgb = human_colors[index].rgb;\n            parsed = true;\n        }\n        else\n        {\n            /* swy: (A) try interpreting it as text; as human keywords, otherwise strtoul() will pick up 'darkgreen' as 0xDA */\n            for (const struct HumanColors *hc = human_colors; hc->keyword != NULL; hc++)\n            {\n                if (strcasecmp(hc->keyword, color.c_str()) != 0)\n                    continue;\n\n                rgb = hc->rgb; parsed = true;\n\n                break;\n            }\n        }\n\n        /* swy: (B) no luck, try interpreting it as an hexadecimal number instead */\n        if (!parsed)\n        {\n            if (color.length() == 6)\n            {\n                const char *colorptr = color.c_str(); char *endptr = NULL;\n\n                rgb = strtoul(colorptr, &endptr, 16);\n\n                /* swy: check that strtoul() has advanced the read pointer until the end (NULL terminator);\n                        that means it has read the whole thing */\n                if (colorptr != endptr && endptr && *endptr == '\\0')\n                    parsed = true;\n            }\n        }\n\n        /* swy: we got it, save the 32-bit integer as a tuple of three RGB bytes */\n        if (parsed)\n        {\n            options->colors.push_back(std::make_tuple(\n                (rgb >> (8 * 2)) & 0xFF, /* RR.... */\n                (rgb >> (8 * 1)) & 0xFF, /* ..GG.. */\n                (rgb >> (8 * 0)) & 0xFF  /* ....BB */\n            ));\n        }\n        else\n        {\n            std::cout << \"Error: Unknown color: '\" + color + \"', skipping.\" << std::endl;\n        }\n\n        // If there are no more colors\n        if (rgb_end == std::string::npos)\n            break;\n\n        // Remove the current color and the next color's leading comma\n        colors_string = colors_string.substr(color.length() + 1);\n    }\n\n    return options->colors.size() > 0;\n}\n\nunsigned int ParseMode(DeviceOptions& options, std::vector<RGBController *> &rgb_controllers)\n{\n    // no need to check if --mode wasn't passed\n    if (options.mode.size() == 0)\n    {\n        return rgb_controllers[options.device]->active_mode;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Search through all of the device modes and see if there is|\n    | a match.  If no match is found, print an error message.   |\n    \\*---------------------------------------------------------*/\n    for(unsigned int mode_idx = 0; mode_idx < rgb_controllers[options.device]->modes.size(); mode_idx++)\n    {\n        if (strcasecmp(rgb_controllers[options.device]->modes[mode_idx].name.c_str(), options.mode.c_str()) == 0)\n        {\n            return mode_idx;\n        }\n    }\n\n    std::cout << \"Error: Mode '\" + options.mode + \"' not available for device '\" + rgb_controllers[options.device]->name + \"'\" << std::endl;\n    return false;\n}\n\nDeviceOptions* GetDeviceOptionsForDevID(Options *opts, int device)\n{\n    if (device == -1)\n    {\n        return &opts->allDeviceOptions;\n    }\n\n    for (unsigned int i = 0; i < opts->devices.size(); i++)\n    {\n        if (opts->devices[i].device == device)\n        {\n            return &opts->devices[i];\n        }\n    }\n\n    // should never happen\n    std::cout << \"Internal error: Tried setting an option on a device that wasn't specified\" << std::endl;\n    abort();\n}\n\nstd::string QuoteIfNecessary(std::string str)\n{\n    if (str.find(' ') == std::string::npos)\n    {\n        return str;\n    }\n    else\n    {\n        return \"'\" + str + \"'\";\n    }\n}\n\n/*---------------------------------------------------------------------------------------------------------*\\\n| Option processing functions                                                                               |\n\\*---------------------------------------------------------------------------------------------------------*/\n\nvoid OptionHelp()\n{\n    std::string help_text;\n    help_text += \"OpenRGB \";\n    help_text += VERSION_STRING;\n    help_text += \", for controlling RGB lighting.\\n\";\n    help_text += \"Usage: OpenRGB (--device [--mode] [--color])...\\n\";\n    help_text += \"\\n\";\n    help_text += \"Options:\\n\";\n    help_text += \"--gui                                    Shows the GUI. GUI also appears when not passing any parameters\\n\";\n    help_text += \"--startminimized                         Starts the GUI minimized to tray. Implies --gui, even if not specified\\n\";\n    help_text += \"--client [IP]:[Port]                     Starts an SDK client on the given IP:Port (assumes port 6742 if not specified)\\n\";\n    help_text += \"--server                                 Starts the SDK's server\\n\";\n    help_text += \"--server-host                            Sets the SDK's server host. Default: 0.0.0.0 (all network interfaces)\\n\";\n    help_text += \"--server-port                            Sets the SDK's server port. Default: 6742 (1024-65535)\\n\";\n    help_text += \"-l,  --list-devices                      Lists every compatible device with their number\\n\";\n    help_text += \"-d,  --device [0-9 | \\\"name\\\"]             Selects device to apply colors and/or effect to, or applies to all devices if omitted\\n\";\n    help_text += \"                                           Basic string search is implemented 3 characters or more\\n\";\n    help_text += \"                                           Can be specified multiple times with different modes and colors\\n\";\n    help_text += \"-z,  --zone [0-9]                        Selects zone to apply colors and/or sizes to, or applies to all zones in device if omitted\\n\";\n    help_text += \"                                           Must be specified after specifying a device\\n\";\n    help_text += \"-c,  --color [random | FFFFF,00AAFF ...] Sets colors on each device directly if no effect is specified, and sets the effect color if an effect is specified\\n\";\n    help_text += \"                                           If there are more LEDs than colors given, the last color will be applied to the remaining LEDs\\n\";\n    help_text += \"-m,  --mode [breathing | static | ...]   Sets the mode to be applied, check --list-devices to see which modes are supported on your device\\n\";\n    help_text += \"-b,  --brightness [0-100]                Sets the brightness as a percentage if the mode supports brightness\\n\";\n    help_text += \"-s, --speed [0-100]                      Sets the speed as a percentage if the mode supports speed\\n\";\n    help_text += \"-sz,  --size [0-N]                       Sets the new size of the specified device zone.\\n\";\n    help_text += \"                                           Must be specified after specifying a zone.\\n\";\n    help_text += \"                                           If the specified size is out of range, or the zone does not offer resizing capability, the size will not be changed\\n\";\n    help_text += \"-V,  --version                           Display version and software build information\\n\";\n    help_text += \"-p,  --profile filename[.orp]            Load the profile from filename/filename.orp\\n\";\n    help_text += \"-sp, --save-profile filename.orp         Save the given settings to profile filename.orp\\n\";\n    help_text += \"--i2c-tools                              Shows the I2C/SMBus Tools page in the GUI. Implies --gui, even if not specified.\\n\";\n    help_text += \"                                           USE I2C TOOLS AT YOUR OWN RISK! Don't use this option if you don't know what you're doing!\\n\";\n    help_text += \"                                           There is a risk of bricking your motherboard, RGB controller, and RAM if you send invalid SMBus/I2C transactions.\\n\";\n    help_text += \"--localconfig                            Use the current working directory instead of the global configuration directory.\\n\";\n    help_text += \"--config path                            Use a custom path instead of the global configuration directory.\\n\";\n    help_text += \"--nodetect                               Do not try to detect hardware at startup.\\n\";\n    help_text += \"--noautoconnect                          Do not try to autoconnect to a local server at startup.\\n\";\n    help_text += \"--loglevel [0-6 | error | warning ...]   Set the log level (0: fatal to 6: trace).\\n\";\n    help_text += \"--print-source                           Print the source code file and line number for each log entry.\\n\";\n    help_text += \"-v,  --verbose                           Print log messages to stdout.\\n\";\n    help_text += \"-vv, --very-verbose                      Print debug messages and log messages to stdout.\\n\";\n    help_text += \"--autostart-check                        Check if OpenRGB starting at login is enabled.\\n\";\n    help_text += \"--autostart-disable                      Disable OpenRGB starting at login.\\n\";\n    help_text += \"--autostart-enable arguments             Enable OpenRGB to start at login. Requires arguments to give to OpenRGB at login.\\n\";\n\n    std::cout << help_text << std::endl;\n}\n\nvoid OptionVersion()\n{\n    std::string version_text;\n    version_text += \"OpenRGB \";\n    version_text += VERSION_STRING;\n    version_text += \", for controlling RGB lighting.\\n\";\n    version_text += \"  Version:\\t\\t \";\n    version_text += VERSION_STRING;\n    version_text += \"\\n  Build Date\\t\\t \";\n    version_text += BUILDDATE_STRING;\n    version_text += \"\\n  Git Commit ID\\t\\t \";\n    version_text += GIT_COMMIT_ID;\n    version_text += \"\\n  Git Commit Date\\t \";\n    version_text += GIT_COMMIT_DATE;\n    version_text += \"\\n  Git Branch\\t\\t \";\n    version_text += GIT_BRANCH;\n    version_text += \"\\n\";\n\n    std::cout << version_text << std::endl;\n}\n\nvoid OptionListDevices(std::vector<RGBController *>& rgb_controllers)\n{\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    for(std::size_t controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)\n    {\n        RGBController *controller = rgb_controllers[controller_idx];\n\n        /*---------------------------------------------------------*\\\n        | Print device name                                         |\n        \\*---------------------------------------------------------*/\n        std::cout << controller_idx << \": \" << controller->name << std::endl;\n\n        /*---------------------------------------------------------*\\\n        | Print device type                                         |\n        \\*---------------------------------------------------------*/\n            std::cout << \"  Type:           \" << device_type_to_str(controller->type) << std::endl;\n\n        /*---------------------------------------------------------*\\\n        | Print device description                                  |\n        \\*---------------------------------------------------------*/\n        if(!controller->description.empty())\n        {\n            std::cout << \"  Description:    \" << controller->description << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device version                                      |\n        \\*---------------------------------------------------------*/\n        if(!controller->version.empty())\n        {\n            std::cout << \"  Version:        \" << controller->version << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device location                                     |\n        \\*---------------------------------------------------------*/\n        if(!controller->location.empty())\n        {\n            std::cout << \"  Location:       \" << controller->location << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device serial                                       |\n        \\*---------------------------------------------------------*/\n        if(!controller->serial.empty())\n        {\n            std::cout << \"  Serial:         \" << controller->serial << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device modes                                        |\n        \\*---------------------------------------------------------*/\n        if(!controller->modes.empty())\n        {\n            std::cout << \"  Modes:\";\n\n            int current_mode = controller->GetMode();\n            for(std::size_t mode_idx = 0; mode_idx < controller->modes.size(); mode_idx++)\n            {\n                std::string modeStr = QuoteIfNecessary(controller->modes[mode_idx].name);\n\n                if(current_mode == (int)mode_idx)\n                {\n                    modeStr = \"[\" + modeStr + \"]\";\n                }\n                std::cout << \" \" << modeStr;\n            }\n            std::cout << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device zones                                        |\n        \\*---------------------------------------------------------*/\n        if(!controller->zones.empty())\n        {\n            std::cout << \"  Zones:\";\n\n            for(std::size_t zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)\n            {\n                std::cout << \" \" << QuoteIfNecessary(controller->zones[zone_idx].name);\n            }\n            std::cout << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Print device LEDs                                         |\n        \\*---------------------------------------------------------*/\n        if(!controller->leds.empty())\n        {\n            std::cout << \"  LEDs:\";\n\n            for(std::size_t led_idx = 0; led_idx < controller->leds.size(); led_idx++)\n            {\n                std::cout << \" \" << QuoteIfNecessary(controller->leds[led_idx].name);\n            }\n            std::cout << std::endl;\n        }\n\n        std::cout << std::endl;\n    }\n}\n\nbool OptionDevice(std::vector<DeviceOptions>* current_devices, std::string argument, Options* options, std::vector<RGBController *>& rgb_controllers)\n{\n    bool found = false;\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    try\n    {\n        int current_device = std::stoi(argument);\n\n        if((current_device >= static_cast<int>(rgb_controllers.size())) || (current_device < 0))\n        {\n            throw nullptr;\n        }\n\n        DeviceOptions newDev;\n        newDev.device = current_device;\n\n        if(!options->hasDevice)\n        {\n            options->hasDevice = true;\n        }\n\n        current_devices->push_back(newDev);\n\n        found = true;\n    }\n    catch(...)\n    {\n        if(argument.length() > 1)\n        {\n            for(unsigned int i = 0; i < rgb_controllers.size(); i++)\n            {\n                /*---------------------------------------------------------*\\\n                | If the argument is not a number then check all the        |\n                |   controllers names for a match                           |\n                \\*---------------------------------------------------------*/\n                std::string name            = rgb_controllers[i]->name;\n                std::transform(name.begin(), name.end(), name.begin(), ::tolower);\n                std::transform(argument.begin(), argument.end(), argument.begin(), ::tolower);\n\n                if(name.find(argument) != std::string::npos)\n                {\n                    found                   = true;\n\n                    DeviceOptions newDev;\n                    newDev.device           = i;\n\n                    if(!options->hasDevice)\n                    {\n                        options->hasDevice  = true;\n                    }\n\n                    current_devices->push_back(newDev);\n                }\n            }\n        }\n        else\n        {\n            std::cout << \"Error: Invalid device ID: \" + argument << std::endl;\n            return false;\n        }\n    }\n\n    return found;\n}\n\nbool OptionZone(std::vector<DeviceOptions>* current_devices, std::string argument, Options* /*options*/, std::vector<RGBController *>& rgb_controllers)\n{\n    bool found = false;\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    try\n    {\n        int current_zone = std::stoi(argument);\n\n        for(size_t i = 0; i < current_devices->size(); i++)\n        {\n            int current_device = current_devices->at(i).device;\n\n            if(current_zone >= static_cast<int>(rgb_controllers[current_device]->zones.size()) || (current_zone < 0))\n            {\n                throw nullptr;\n            }\n\n            current_devices->at(i).zone = current_zone;\n            found = true;\n        }\n    }\n    catch(...)\n    {\n        std::cout << \"Error: Invalid zone ID: \" + argument << std::endl;\n        return false;\n    }\n\n    return found;\n}\n\nbool CheckColor(std::string argument, DeviceOptions* currentDevOpts)\n{\n    if(ParseColors(argument, currentDevOpts))\n    {\n        currentDevOpts->hasOption = true;\n        return true;\n    }\n    else\n    {\n        std::cout << \"Error: Invalid color value: \" + argument << std::endl;\n        return false;\n    }\n}\n\nbool OptionColor(std::vector<DeviceOptions>* current_devices, std::string argument, Options* options)\n{\n    /*---------------------------------------------------------*\\\n    | If a device is not selected  i.e. size() == 0             |\n    |   then add color to allDeviceOptions                      |\n    \\*---------------------------------------------------------*/\n    bool found                      = false;\n    DeviceOptions* currentDevOpts   = &options->allDeviceOptions;\n\n    if(current_devices->size() == 0)\n    {\n        found = CheckColor(argument, currentDevOpts);\n    }\n    else\n    {\n        for(size_t i = 0; i < current_devices->size(); i++)\n        {\n            currentDevOpts = &current_devices->at(i);\n\n            found = CheckColor(argument, currentDevOpts);\n        }\n    }\n\n    return found;\n}\n\nbool OptionMode(std::vector<DeviceOptions>* current_devices, std::string argument, Options* options)\n{\n    if(argument.size() == 0)\n    {\n        std::cout << \"Error: --mode passed with no argument\" << std::endl;\n        return false;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If a device is not selected  i.e. size() == 0             |\n    |   then add mode to allDeviceOptions                       |\n    \\*---------------------------------------------------------*/\n    bool found                      = false;\n    DeviceOptions* currentDevOpts   = &options->allDeviceOptions;\n\n    if(current_devices->size() == 0)\n    {\n        currentDevOpts->mode = argument;\n        currentDevOpts->hasOption = true;\n        found = true;\n    }\n    else\n    {\n        for(size_t i = 0; i < current_devices->size(); i++)\n        {\n            currentDevOpts = &current_devices->at(i);\n\n            currentDevOpts->mode = argument;\n            currentDevOpts->hasOption = true;\n            found = true;\n        }\n    }\n\n    return found;\n}\n\nbool OptionSpeed(std::vector<DeviceOptions>* current_devices, std::string argument, Options* options)\n{\n    if(argument.size() == 0)\n    {\n        std::cout << \"Error: --speed passed with no argument\" << std::endl;\n        return false;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If a device is not selected  i.e. size() == 0             |\n    |   then add speed to allDeviceOptions                 |\n    \\*---------------------------------------------------------*/\n    bool found                      = false;\n    DeviceOptions* currentDevOpts   = &options->allDeviceOptions;\n\n    if(current_devices->size() == 0)\n    {\n        currentDevOpts->speed  = std::min(std::max(std::stoi(argument), 0),(int)speed_percentage);\n        currentDevOpts->hasOption   = true;\n        found = true;\n    }\n    else\n    {\n        for(size_t i = 0; i < current_devices->size(); i++)\n        {\n            DeviceOptions* currentDevOpts   = &current_devices->at(i);\n\n            currentDevOpts->speed      = std::min(std::max(std::stoi(argument), 0),(int)speed_percentage);\n            currentDevOpts->hasOption       = true;\n            found = true;\n        }\n    }\n\n    return found;\n}\n\nbool OptionBrightness(std::vector<DeviceOptions>* current_devices, std::string argument, Options* options)\n{\n    if(argument.size() == 0)\n    {\n        std::cout << \"Error: --brightness passed with no argument\" << std::endl;\n        return false;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If a device is not selected  i.e. size() == 0             |\n    |   then add brightness to allDeviceOptions                 |\n    \\*---------------------------------------------------------*/\n    bool found                      = false;\n    DeviceOptions* currentDevOpts   = &options->allDeviceOptions;\n\n    if(current_devices->size() == 0)\n    {\n        currentDevOpts->brightness  = std::min(std::max(std::stoi(argument), 0),(int)brightness_percentage);\n        currentDevOpts->hasOption   = true;\n        found = true;\n    }\n    else\n    {\n        for(size_t i = 0; i < current_devices->size(); i++)\n        {\n            DeviceOptions* currentDevOpts   = &current_devices->at(i);\n\n            currentDevOpts->brightness      = std::min(std::max(std::stoi(argument), 0),(int)brightness_percentage);\n            currentDevOpts->hasOption       = true;\n            found = true;\n        }\n    }\n\n    return found;\n}\n\nbool OptionSize(std::vector<DeviceOptions>* current_devices, std::string argument, Options* /*options*/, std::vector<RGBController *>& rgb_controllers)\n{\n    const unsigned int new_size = std::stoi(argument);\n\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    for(size_t i = 0; i < current_devices->size(); i++)\n    {\n        int current_device      = current_devices->at(i).device;\n        int current_zone        = current_devices->at(i).zone;\n\n        /*---------------------------------------------------------*\\\n        | Fail out if device, zone, or size are out of range        |\n        \\*---------------------------------------------------------*/\n        if((current_device >= static_cast<int>(rgb_controllers.size())) || (current_device < 0))\n        {\n            std::cout << \"Error: Device is out of range\" << std::endl;\n            return false;\n        }\n        else if((current_zone >= static_cast<int>(rgb_controllers[current_device]->zones.size())) || (current_zone < 0))\n        {\n            std::cout << \"Error: Zone is out of range\" << std::endl;\n            return false;\n        }\n        else if((new_size < rgb_controllers[current_device]->zones[current_zone].leds_min) || (new_size > rgb_controllers[current_device]->zones[current_zone].leds_max))\n        {\n            std::cout << \"Error: New size is out of range\" << std::endl;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Resize the zone                                           |\n        \\*---------------------------------------------------------*/\n        rgb_controllers[current_device]->ResizeZone(current_zone, new_size);\n\n        /*---------------------------------------------------------*\\\n        | Save the profile                                          |\n        \\*---------------------------------------------------------*/\n        ResourceManager::get()->GetProfileManager()->SaveProfile(\"sizes\", true);\n    }\n\n    return true;\n}\n\nbool OptionProfile(std::string argument, std::vector<RGBController *>& rgb_controllers)\n{\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    /*---------------------------------------------------------*\\\n    | Attempt to load profile                                   |\n    \\*---------------------------------------------------------*/\n    if(ResourceManager::get()->GetProfileManager()->LoadProfile(argument))\n    {\n        /*-----------------------------------------------------*\\\n        | Change device mode if profile loading was successful  |\n        \\*-----------------------------------------------------*/\n        for(std::size_t controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)\n        {\n            RGBController* device = rgb_controllers[controller_idx];\n\n            device->DeviceUpdateMode();\n            LOG_DEBUG(\"[CLI] Updating mode for %s to %i\", device->name.c_str(), device->active_mode);\n\n            if(device->modes[device->active_mode].color_mode == MODE_COLORS_PER_LED)\n            {\n                device->DeviceUpdateLEDs();\n                LOG_DEBUG(\"[CLI] Mode uses per-LED color, also updating LEDs\");\n            }\n        }\n\n        std::cout << \"Profile loaded successfully\" << std::endl;\n        return true;\n    }\n    else\n    {\n        std::cout << \"Profile failed to load\" << std::endl;\n        return false;\n    }\n}\n\nbool OptionSaveProfile(std::string argument)\n{\n    /*---------------------------------------------------------*\\\n    | Set save profile filename                                 |\n    \\*---------------------------------------------------------*/\n    profile_save_filename = argument;\n    return(true);\n}\n\nint ProcessOptions(Options* options, std::vector<RGBController *>& rgb_controllers)\n{\n    unsigned int ret_flags  = 0;\n    int arg_index           = 1;\n    std::vector<DeviceOptions> current_devices;\n\n    options->hasDevice = false;\n    options->profile_loaded = false;\n\n#ifdef _WIN32\n    int fake_argc;\n    wchar_t** argvw = CommandLineToArgvW(GetCommandLineW(), &fake_argc);\n#endif\n\n    while(arg_index < preserve_argc)\n    {\n        std::string option   = preserve_argv[arg_index];\n        std::string argument = \"\";\n        filesystem::path arg_path;\n\n        /*---------------------------------------------------------*\\\n        | Handle options that take an argument                      |\n        \\*---------------------------------------------------------*/\n        if(arg_index + 1 < preserve_argc)\n        {\n            argument = preserve_argv[arg_index + 1];\n#ifdef _WIN32\n            arg_path = argvw[arg_index + 1];\n#else\n            arg_path = argument;\n#endif\n        }\n\n        /*---------------------------------------------------------*\\\n        | -l / --list-devices (no arguments)                        |\n        \\*---------------------------------------------------------*/\n        if(option == \"--list-devices\" || option == \"-l\")\n        {\n            OptionListDevices(rgb_controllers);\n            exit(0);\n        }\n\n        /*---------------------------------------------------------*\\\n        | -d / --device                                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--device\" || option == \"-d\")\n        {\n            while(!current_devices.empty())\n            {\n                options->devices.push_back(current_devices.back());\n                current_devices.pop_back();\n            }\n\n            if(!OptionDevice(&current_devices, argument, options, rgb_controllers))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -z / --zone                                               |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--zone\" || option == \"-z\")\n        {\n            if(!OptionZone(&current_devices, argument, options, rgb_controllers))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -c / --color                                              |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--color\" || option == \"-c\")\n        {\n            if(!OptionColor(&current_devices, argument, options))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -m / --mode                                               |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--mode\" || option == \"-m\")\n        {\n            if(!OptionMode(&current_devices, argument, options))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -b / --brightness                                         |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--brightness\" || option == \"-b\")\n        {\n            if(!OptionBrightness(&current_devices, argument, options))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -s / --speed                                         |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--speed\" || option == \"-s\")\n        {\n            if(!OptionSpeed(&current_devices, argument, options))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -sz / --size                                               |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--size\" || option == \"-sz\")\n        {\n            if(!OptionSize(&current_devices, argument, options, rgb_controllers))\n            {\n                return RET_FLAG_PRINT_HELP;\n            }\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -p / --profile                                            |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--profile\" || option == \"-p\")\n        {\n            options->profile_loaded = OptionProfile(arg_path.generic_u8string(), rgb_controllers);\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -sp / --save-profile                                      |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--save-profile\" || option == \"-sp\")\n        {\n            OptionSaveProfile(arg_path.generic_u8string());\n\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Invalid option                                            |\n        \\*---------------------------------------------------------*/\n        else\n        {\n            if((option == \"--localconfig\")\n             ||(option == \"--nodetect\")\n             ||(option == \"--noautoconnect\")\n             ||(option == \"--server\")\n             ||(option == \"--gui\")\n             ||(option == \"--i2c-tools\" || option == \"--yolo\")\n             ||(option == \"--startminimized\")\n             ||(option == \"--print-source\")\n             ||(option == \"--verbose\" || option == \"-v\")\n             ||(option == \"--very-verbose\" || option == \"-vv\")\n             ||(option == \"--help\" || option == \"-h\")\n             ||(option == \"--version\" || option == \"-V\")\n             ||(option == \"--autostart-check\")\n             ||(option == \"--autostart-disable\"))\n            {\n                /*-------------------------------------------------*\\\n                | Do nothing, these are pre-detection arguments     |\n                | and this parser should ignore them                |\n                \\*-------------------------------------------------*/\n            }\n            else if((option == \"--server-port\")\n                  ||(option == \"--server-host\")\n                  ||(option == \"--loglevel\")\n                  ||(option == \"--config\")\n                  ||(option == \"--client\")\n                  ||(option == \"--autostart-enable\"))\n            {\n                /*-------------------------------------------------*\\\n                | Increment index for pre-detection arguments with  |\n                | parameter                                         |\n                \\*-------------------------------------------------*/\n                arg_index++;\n            }\n            else\n            {\n                /*-------------------------------------------------*\\\n                | If the argument is not a pre-detection argument,  |\n                | throw an error and print help                     |\n                \\*-------------------------------------------------*/\n                std::cout << \"Error: Invalid option: \" + option << std::endl;\n                return RET_FLAG_PRINT_HELP;\n            }\n        }\n\n        arg_index++;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If a device was specified, check to verify that a         |\n    | corresponding option was also specified                   |\n    \\*---------------------------------------------------------*/\n    while(!current_devices.empty())\n    {\n        options->devices.push_back(current_devices.back());\n        current_devices.pop_back();\n    }\n\n    if(options->hasDevice)\n    {\n        for(std::size_t option_idx = 0; option_idx < options->devices.size(); option_idx++)\n        {\n            if(!options->devices[option_idx].hasOption)\n            {\n                std::cout << \"Error: Device \" + std::to_string(option_idx) + \" specified, but neither mode nor color given\" << std::endl;\n                return RET_FLAG_PRINT_HELP;\n            }\n        }\n        return 0;\n    }\n    else\n    {\n        return ret_flags;\n    }\n}\n\nvoid ApplyOptions(DeviceOptions& options, std::vector<RGBController *>& rgb_controllers)\n{\n    RGBController* device = rgb_controllers[options.device];\n\n    /*---------------------------------------------------------*\\\n    | Set mode first, in case it's 'direct' (which affects      |\n    | SetLED below)                                             |\n    \\*---------------------------------------------------------*/\n    unsigned int mode = ParseMode(options, rgb_controllers);\n\n    /*---------------------------------------------------------*\\\n    | If the user has specified random colours and the device   |\n    |   supports that colour mode then swich to it before       |\n    |   evaluating if a colour needs to be set                  |\n    \\*---------------------------------------------------------*/\n    if(options.random_colors && (device->modes[mode].flags & MODE_FLAG_HAS_RANDOM_COLOR))\n    {\n        device->modes[mode].color_mode = MODE_COLORS_RANDOM;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If the user has specified random colours and the device   |\n    |   supports that colour mode then swich to it before       |\n    |   evaluating if a colour needs to be set                  |\n    \\*---------------------------------------------------------*/\n    if((device->modes[mode].flags & MODE_FLAG_HAS_BRIGHTNESS))\n    {\n        unsigned int new_brightness     = device->modes[mode].brightness_max - device->modes[mode].brightness_min;\n        new_brightness                 *= options.brightness;\n        new_brightness                 /= brightness_percentage;\n\n        device->modes[mode].brightness  = device->modes[mode].brightness_min + new_brightness;\n    }\n\n    if((device->modes[mode].flags & MODE_FLAG_HAS_SPEED))\n    {\n        unsigned int new_speed     = device->modes[mode].speed_max - device->modes[mode].speed_min;\n        new_speed                 *= options.speed;\n        new_speed                 /= speed_percentage;\n\n        device->modes[mode].speed  = device->modes[mode].speed_min + new_speed;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Determine which color mode this mode uses and update      |\n    | colors accordingly                                        |\n    \\*---------------------------------------------------------*/\n    switch(device->modes[mode].color_mode)\n    {\n        case MODE_COLORS_NONE:\n            break;\n\n        case MODE_COLORS_RANDOM:\n            break;\n\n        case MODE_COLORS_PER_LED:\n            if(options.colors.size() != 0)\n            {\n                std::size_t last_set_color = 0;\n\n                RGBColor* start_from;\n                unsigned int led_count;\n                if(options.zone < 0)\n                {\n                    start_from  = &device->colors[0];\n                    led_count   = (unsigned int)device->leds.size();\n                }\n                else\n                {\n                    start_from  = device->zones[options.zone].colors;\n                    led_count   = device->zones[options.zone].leds_count;\n                }\n\n                for(std::size_t led_idx = 0; led_idx < led_count; led_idx++)\n                {\n                    if(led_idx < options.colors.size())\n                    {\n                        last_set_color      = led_idx;\n                    }\n\n                    start_from[led_idx]     = ToRGBColor(std::get<0>(options.colors[last_set_color]),\n                                                         std::get<1>(options.colors[last_set_color]),\n                                                         std::get<2>(options.colors[last_set_color]));\n                }\n            }\n            break;\n\n        case MODE_COLORS_MODE_SPECIFIC:\n            if(options.colors.size() >= device->modes[mode].colors_min && options.colors.size() <= device->modes[mode].colors_max)\n            {\n                device->modes[mode].colors.resize(options.colors.size());\n\n                for(std::size_t color_idx = 0; color_idx < options.colors.size(); color_idx++)\n                {\n                    device->modes[mode].colors[color_idx] = ToRGBColor(std::get<0>(options.colors[color_idx]),\n                                                                       std::get<1>(options.colors[color_idx]),\n                                                                       std::get<2>(options.colors[color_idx]));\n                }\n            }\n            else\n            {\n                std::cout << \"Wrong number of colors specified for mode \" + device->modes[mode].name << std::endl;\n                std::cout << \"Please provide between \" + std::to_string(device->modes[mode].colors_min) + \" and \" + std::to_string(device->modes[mode].colors_min) + \" colors\" << std::endl;\n                exit(0);\n            }\n            break;\n    }\n\n    /*---------------------------------------------------------*\\\n    | Set device mode                                           |\n    \\*---------------------------------------------------------*/\n    device->active_mode = mode;\n    device->DeviceUpdateMode();\n\n    /*---------------------------------------------------------*\\\n    | Set device per-LED colors if necessary                    |\n    \\*---------------------------------------------------------*/\n    if(device->modes[mode].color_mode == MODE_COLORS_PER_LED)\n    {\n        device->DeviceUpdateLEDs();\n    }\n}\n\n\nunsigned int cli_pre_detection(int argc, char* argv[])\n{\n    /*---------------------------------------------------------*\\\n    | Process only the arguments that should be performed prior |\n    | to detecting devices and/or starting clients              |\n    \\*---------------------------------------------------------*/\n    int             arg_index    = 1;\n    unsigned int    cfg_args     = 0;\n    unsigned int    ret_flags    = 0;\n    std::string     server_host  = OPENRGB_SDK_HOST;\n    unsigned short  server_port  = OPENRGB_SDK_PORT;\n    bool            server_start = false;\n    bool            print_help   = false;\n\n    preserve_argc = argc;\n    preserve_argv = argv;\n\n#ifdef _WIN32\n    int fake_argc;\n    wchar_t** argvw = CommandLineToArgvW(GetCommandLineW(), &fake_argc);\n#endif\n\n    while(arg_index < argc)\n    {\n        std::string option   = argv[arg_index];\n        std::string argument = \"\";\n\n        LOG_DEBUG(\"[CLI] Parsing CLI option: %s\", option.c_str());\n\n        /*---------------------------------------------------------*\\\n        | Handle options that take an argument                      |\n        \\*---------------------------------------------------------*/\n        if(arg_index + 1 < argc)\n        {\n            argument = argv[arg_index + 1];\n        }\n\n        /*---------------------------------------------------------*\\\n        | --localconfig                                             |\n        \\*---------------------------------------------------------*/\n        if(option == \"--localconfig\")\n        {\n            ResourceManager::get()->SetConfigurationDirectory(\"./\");\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --config                                                  |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--config\")\n        {\n            cfg_args+= 2;\n            arg_index++;\n#ifdef _WIN32\n            filesystem::path config_path(argvw[arg_index]);\n#else\n            filesystem::path config_path(argument);\n#endif\n\n            if(filesystem::is_directory(config_path))\n            {\n                ResourceManager::get()->SetConfigurationDirectory(config_path);\n                LOG_INFO(\"[CLI] Setting config directory to %s\",argument.c_str()); // TODO: Use config_path in logs somehow\n            }\n            else\n            {\n                LOG_ERROR(\"[CLI] '%s' is not a valid directory\",argument.c_str()); // TODO: Use config_path in logs somehow\n                print_help = true;\n                break;\n            }\n        }\n\n        /*---------------------------------------------------------*\\\n        | --nodetect                                                |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--nodetect\")\n        {\n            ret_flags |= RET_FLAG_NO_DETECT;\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --noautoconnect                                           |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--noautoconnect\")\n        {\n            ret_flags |= RET_FLAG_NO_AUTO_CONNECT;\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --client                                                  |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--client\")\n        {\n            NetworkClient * client = new NetworkClient(ResourceManager::get()->GetRGBControllers());\n\n            std::size_t pos = argument.find(\":\");\n            std::string ip = argument.substr(0, pos);\n            unsigned short port_val;\n\n            if(pos == argument.npos)\n            {\n                port_val = OPENRGB_SDK_PORT;\n            }\n            else\n            {\n                std::string port = argument.substr(argument.find(\":\") + 1);\n                port_val = std::stoi(port);\n            }\n\n            std::string titleString = \"OpenRGB \";\n            titleString.append(VERSION_STRING);\n\n            client->SetIP(ip.c_str());\n            client->SetName(titleString.c_str());\n            client->SetPort(port_val);\n\n            client->StartClient();\n\n            for(int timeout = 0; timeout < 100; timeout++)\n            {\n                if(client->GetConnected())\n                {\n                    break;\n                }\n                std::this_thread::sleep_for(10ms);\n            }\n\n            ResourceManager::get()->GetClients().push_back(client);\n\n            cfg_args++;\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --server (no arguments)                                   |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--server\")\n        {\n            server_start = true;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --server-port                                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--server-port\")\n        {\n            if (argument != \"\")\n            {\n                try\n                {\n                    int port = std::stoi(argument);\n                    if (port >= 1024 && port <= 65535)\n                    {\n                        server_port  = port;\n                        server_start = true;\n                    }\n                    else\n                    {\n                        std::cout << \"Error: Port out of range: \" << port << \" (1024-65535)\" << std::endl;\n                        print_help = true;\n                        break;\n                    }\n                }\n                catch(std::invalid_argument& /*e*/)\n                {\n                    std::cout << \"Error: Invalid data in --server-port argument (expected a number in range 1024-65535)\" << std::endl;\n                    print_help = true;\n                    break;\n                }\n            }\n            else\n            {\n                std::cout << \"Error: Missing argument for --server-port\" << std::endl;\n                print_help = true;\n                break;\n            }\n            cfg_args++;\n            arg_index++;\n        }\n        /*---------------------------------------------------------*\\\n        | --server-host                                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--server-host\")\n        {\n            if (argument != \"\")\n            {\n                std::string host = argument;\n\n                server_host  = host;\n                server_start = true;\n            }\n            else\n            {\n                std::cout << \"Error: Missing argument for --server-host\" << std::endl;\n                print_help = true;\n                break;\n            }\n            cfg_args++;\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --loglevel                                                |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--loglevel\")\n        {\n            if (argument != \"\")\n            {\n                try\n                {\n                    int level = std::stoi(argument);\n                    if (level >= 0 && level <= LL_TRACE)\n                    {\n                        LogManager::get()->setLoglevel(level);\n                    }\n                    else\n                    {\n                        LOG_ERROR(\"[CLI] Loglevel out of range: %d (0-6)\", level);\n                        print_help = true;\n                        break;\n                    }\n                }\n                catch(std::invalid_argument& /*e*/)\n                {\n                    if(!strcasecmp(argument.c_str(), \"fatal\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_FATAL);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"error\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_ERROR);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"warning\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_WARNING);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"info\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_INFO);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"verbose\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_VERBOSE);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"debug\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_DEBUG);\n                    }\n                    else if(!strcasecmp(argument.c_str(), \"trace\"))\n                    {\n                        LogManager::get()->setLoglevel(LL_TRACE);\n                    }\n                    else\n                    {\n                        LOG_ERROR(\"[CLI] Invalid loglevel\");\n                        print_help = true;\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_ERROR(\"[CLI] Missing argument for --loglevel\");\n                print_help = true;\n                break;\n            }\n            cfg_args+= 2;\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --autostart-check (no arguments)                          |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--autostart-check\")\n        {\n            AutoStart auto_start(\"OpenRGB\");\n\n            if(auto_start.IsAutoStartEnabled())\n            {\n                std::cout << \"Autostart is enabled.\" << std::endl;\n            }\n            else\n            {\n                std::cout << \"Autostart is disabled.\" << std::endl;\n            }\n        }\n\n        /*---------------------------------------------------------*\\\n        | --autostart-disable (no arguments)                        |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--autostart-disable\")\n        {\n            AutoStart auto_start(\"OpenRGB\");\n\n            if(auto_start.DisableAutoStart())\n            {\n                std::cout << \"Autostart disabled.\" << std::endl;\n            }\n            else\n            {\n                std::cout << \"Autostart failed to disable.\" << std::endl;\n            }\n        }\n\n        /*---------------------------------------------------------*\\\n        | --autostart-enable                                        |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--autostart-enable\")\n        {\n            if (argument != \"\")\n            {\n                std::string desc = \"OpenRGB \";\n                desc += VERSION_STRING;\n                desc += \", for controlling RGB lighting.\";\n\n                AutoStart       auto_start(\"OpenRGB\");\n                AutoStartInfo   auto_start_interface;\n\n                auto_start_interface.args        = argument;\n                auto_start_interface.category    = \"Utility;\";\n                auto_start_interface.desc        = desc;\n                auto_start_interface.icon        = \"OpenRGB\";\n                auto_start_interface.path        = auto_start.GetExePath();\n\n                if(auto_start.EnableAutoStart(auto_start_interface))\n                {\n                    std::cout << \"Autostart enabled.\" << std::endl;\n                }\n                else\n                {\n                    std::cout << \"Autostart failed to enable.\" << std::endl;\n                }\n            }\n            else\n            {\n                std::cout << \"Error: Missing argument for --autostart-enable\" << std::endl;\n                print_help = true;\n                break;\n            }\n\n            cfg_args++;\n            arg_index++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --gui (no arguments)                                      |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--gui\")\n        {\n            ret_flags |= RET_FLAG_START_GUI;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --i2c-tools / --yolo (no arguments)                       |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--i2c-tools\" || option == \"--yolo\")\n        {\n            ret_flags |= RET_FLAG_START_GUI | RET_FLAG_I2C_TOOLS;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --startminimized (no arguments)                           |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--startminimized\")\n        {\n            ret_flags |= RET_FLAG_START_GUI | RET_FLAG_START_MINIMIZED;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -h / --help (no arguments)                                |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--help\" || option == \"-h\")\n        {\n            print_help = true;\n            break;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -V / --version (no arguments)                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--version\" || option == \"-V\")\n        {\n            OptionVersion();\n            exit(0);\n        }\n\n        /*---------------------------------------------------------*\\\n        | -v / --verbose (no arguments)                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--verbose\" || option == \"-v\")\n        {\n            LogManager::get()->setVerbosity(LL_VERBOSE);\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | -vv / --very-verbose (no arguments)                       |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--very-verbose\" || option == \"-vv\")\n        {\n            LogManager::get()->setVerbosity(LL_TRACE);\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | --print-source (no arguments)                             |\n        \\*---------------------------------------------------------*/\n        else if(option == \"--print-source\")\n        {\n            LogManager::get()->setPrintSource(true);\n            cfg_args++;\n        }\n\n        /*---------------------------------------------------------*\\\n        | Any unrecognized arguments trigger the post-detection CLI |\n        \\*---------------------------------------------------------*/\n        else\n        {\n            ret_flags |= RET_FLAG_CLI_POST_DETECTION;\n        }\n\n        arg_index++;\n    }\n\n    if(print_help)\n    {\n        OptionHelp();\n        exit(0);\n    }\n\n    if(server_start)\n    {\n        NetworkServer * server = ResourceManager::get()->GetServer();\n        server->SetHost(server_host);\n        server->SetPort(server_port);\n        ret_flags |= RET_FLAG_START_SERVER;\n    }\n\n    if((argc - cfg_args) <= 1)\n    {\n        ret_flags |= RET_FLAG_START_GUI;\n    }\n\n    return(ret_flags);\n}\n\nunsigned int cli_post_detection()\n{\n    /*---------------------------------------------------------*\\\n    | Wait for device detection                                 |\n    \\*---------------------------------------------------------*/\n    ResourceManager::get()->WaitForDeviceDetection();\n\n    /*---------------------------------------------------------*\\\n    | Get controller list from resource manager                 |\n    \\*---------------------------------------------------------*/\n    std::vector<RGBController *> rgb_controllers = ResourceManager::get()->GetRGBControllers();\n\n    /*---------------------------------------------------------*\\\n    | Process the argument options                              |\n    \\*---------------------------------------------------------*/\n    Options options;\n    unsigned int ret_flags = ProcessOptions(&options, rgb_controllers);\n\n    /*---------------------------------------------------------*\\\n    | If the return flags are set, exit CLI mode without        |\n    | processing device updates from CLI input.                 |\n    \\*---------------------------------------------------------*/\n    switch(ret_flags)\n    {\n        case 0:\n            break;\n\n        case RET_FLAG_PRINT_HELP:\n            OptionHelp();\n            exit(-1);\n            break;\n\n        default:\n            return ret_flags;\n            break;\n    }\n\n    /*---------------------------------------------------------*\\\n    | If the options has one or more specific devices, loop     |\n    | through all of the specific devices and apply settings.   |\n    | Otherwise, apply settings to all devices.                 |\n    \\*---------------------------------------------------------*/\n    if (options.hasDevice)\n    {\n        for(unsigned int device_idx = 0; device_idx < options.devices.size(); device_idx++)\n        {\n            ApplyOptions(options.devices[device_idx], rgb_controllers);\n        }\n    }\n    else if (!options.profile_loaded)\n    {\n        for (unsigned int device_idx = 0; device_idx < rgb_controllers.size(); device_idx++)\n        {\n            options.allDeviceOptions.device = device_idx;\n            ApplyOptions(options.allDeviceOptions, rgb_controllers);\n        }\n    }\n\n    /*---------------------------------------------------------*\\\n    | If there is a save filename set, save the profile         |\n    \\*---------------------------------------------------------*/\n    if (profile_save_filename != \"\")\n    {\n        if(ResourceManager::get()->GetProfileManager()->SaveProfile(profile_save_filename))\n        {\n            LOG_INFO(\"[CLI] Profile saved successfully\");\n        }\n        else\n        {\n            LOG_ERROR(\"[CLI] Profile saving failed\");\n        }\n    }\n\n    std::this_thread::sleep_for(1s);\n\n    return 0;\n}\n"
        },
        {
          "name": "cli.h",
          "type": "blob",
          "size": 0.4296875,
          "content": "#ifndef CLI_H\n#define CLI_H\n\nunsigned int cli_pre_detection(int argc, char* argv[]);\nunsigned int cli_post_detection();\n\nenum\n{\n    RET_FLAG_PRINT_HELP         = 1,\n    RET_FLAG_START_GUI          = 2,\n    RET_FLAG_I2C_TOOLS          = 4,\n    RET_FLAG_START_MINIMIZED    = 8,\n    RET_FLAG_NO_DETECT          = 16,\n    RET_FLAG_CLI_POST_DETECTION = 32,\n    RET_FLAG_START_SERVER       = 64,\n    RET_FLAG_NO_AUTO_CONNECT    = 128,\n};\n\n#endif\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "dependencies",
          "type": "tree",
          "content": null
        },
        {
          "name": "dmiinfo",
          "type": "tree",
          "content": null
        },
        {
          "name": "fedora",
          "type": "tree",
          "content": null
        },
        {
          "name": "filesystem.h",
          "type": "blob",
          "size": 1.4013671875,
          "content": "/*---------------------------------------------------------*\\\n| filesystem.h                                              |\n|                                                           |\n|   Selects between std and experimental filesystem library |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#ifndef FILESYSTEM_H\n#define FILESYSTEM_H\n\n#if defined(__has_include) && __has_include(<filesystem>)\n\n#include <filesystem>\n\n// Debian 10 provides the header, but does not enable the feature, so we additionally check for the feature test macro\n// MSVC below 2017 does not provide feature test macros, so we leave an exception for them\n#if defined(__cpp_lib_filesystem) || defined (_MSC_VER)\nnamespace filesystem = std::filesystem;\n#define STD_FILESYSTEM_FOUND\n#endif\n\n#endif\n\n#ifndef STD_FILESYSTEM_FOUND\n\n#if defined(__has_include) && !__has_include(<experimental/filesystem>)\n#error Neither <filesystem> nor <experimental/filesystem> could be found on the system! Please report an issue to OpenRGB developers providing your system info.\n#endif\n\n#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING\n#include <experimental/filesystem>\nnamespace filesystem = std::experimental::filesystem;\n\n#endif // C++17\n\n#endif // FILESYSTEM_H\n"
        },
        {
          "name": "hidapi_wrapper",
          "type": "tree",
          "content": null
        },
        {
          "name": "i2c_smbus",
          "type": "tree",
          "content": null
        },
        {
          "name": "i2c_tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "interop",
          "type": "tree",
          "content": null
        },
        {
          "name": "mac",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 11.1796875,
          "content": "/*---------------------------------------------------------*\\\n| main.cpp                                                  |\n|                                                           |\n|   Entry point for the OpenRGB application                 |\n|                                                           |\n|   This file is part of the OpenRGB project                |\n|   SPDX-License-Identifier: GPL-2.0-only                   |\n\\*---------------------------------------------------------*/\n\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\n#include <thread>\n#include \"cli.h\"\n#include \"ResourceManager.h\"\n#include \"NetworkClient.h\"\n#include \"NetworkServer.h\"\n#include \"ProfileManager.h\"\n#include \"RGBController.h\"\n#include \"i2c_smbus.h\"\n#include \"LogManager.h\"\n\n#ifdef _MACOSX_X86_X64\n#include \"macUSPCIOAccess.h\"\nio_connect_t macUSPCIO_driver_connection;\n#endif\n\n#include \"OpenRGBDialog.h\"\n\n#ifdef __APPLE__\n#include \"macutils.h\"\n#endif\n\nusing namespace std::chrono_literals;\n\n/******************************************************************************************\\\n*                                                                                          *\n*   InitializeTimerResolution (Win32)                                                      *\n*                                                                                          *\n*       On Windows, the default timer resolution is 15.6ms.  For higher accuracy delays,   *\n*       the timer resolution should be set to a shorter interval.  The shortest interval   *\n*       that can be set is 0.5ms.                                                          *\n*                                                                                          *\n\\******************************************************************************************/\n#ifdef _WIN32\ntypedef unsigned int NTSTATUS;\ntypedef NTSTATUS (*NTSETTIMERRESOLUTION)(ULONG DesiredResolution, BOOLEAN SetResolution, PULONG CurrentResolution);\n\nvoid InitializeTimerResolution()\n{\n    NTSETTIMERRESOLUTION NtSetTimerResolution;\n    HMODULE              NtDllHandle;\n    ULONG                CurrentResolution;\n\n    NtDllHandle = LoadLibrary(\"ntdll.dll\");\n\n    NtSetTimerResolution = (NTSETTIMERRESOLUTION)GetProcAddress(NtDllHandle, \"NtSetTimerResolution\");\n\n    NtSetTimerResolution(5000, TRUE, &CurrentResolution);\n}\n\nvoid InitializeTimerResolutionThreadFunction()\n{\n    while(1)\n    {\n        InitializeTimerResolution();\n\n        std::this_thread::sleep_for(500ms);\n    }\n}\n#endif\n\nvoid WaitWhileServerOnline(NetworkServer* srv)\n{\n    while (srv->GetOnline())\n    {\n        std::this_thread::sleep_for(1s);\n    };\n}\n\n/******************************************************************************************\\\n*                                                                                          *\n*   Install SMBus Driver WinRing0, If not already installed (Win32)                        *\n*                                                                                          *\n\\******************************************************************************************/\n#ifdef _WIN32\nvoid InstallWinRing0()\n{\n    TCHAR winring0_install_location[MAX_PATH]; // driver final location usually C:\\windows\\system32\\drivers\\WinRing0x64.sys\n    uint system_path_length = GetSystemDirectory(winring0_install_location, MAX_PATH);\n    std::string winring0_filename = \"WinRing0.sys\";\n    BOOL bIsWow64 = false;\n#if _WIN64\n    winring0_filename = \"WinRing0x64.sys\";\n#else\n    BOOL (*fnIsWow64Process)(HANDLE, PBOOL) = (BOOL (__cdecl *)(HANDLE, PBOOL))GetProcAddress(GetModuleHandle(TEXT(\"kernel32\")),\"IsWow64Process\");\n    if (fnIsWow64Process)\n    {\n        fnIsWow64Process(GetCurrentProcess(),&bIsWow64);\n    }\n    if(bIsWow64)\n    {\n        winring0_filename = \"WinRing0x64.sys\";\n    }\n#endif\n    std::strncat(winring0_install_location, \"\\\\drivers\\\\\", MAX_PATH - system_path_length - 1);\n    std::strncat(winring0_install_location, winring0_filename.c_str(), MAX_PATH - system_path_length - 10);\n\n    std::string driver_name = winring0_filename.substr(0, winring0_filename.size() - 4); // driver name: WinRing0 or WinRing0x64\n    SC_HANDLE manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n    if (manager)\n    {\n        PVOID wow64_fsredirection_OldValue = NULL;\n        if(bIsWow64)\n        {\n            Wow64DisableWow64FsRedirection(&wow64_fsredirection_OldValue);\n        }\n        if(INVALID_FILE_ATTRIBUTES == GetFileAttributes(winring0_install_location) && GetLastError()==ERROR_FILE_NOT_FOUND)\n        {\n            char module_path_buffer[MAX_PATH];\n            GetModuleFileNameA(NULL, module_path_buffer, MAX_PATH);\n            std::string::size_type exe_loc = std::string(module_path_buffer).find_last_of(\"\\\\/\");\n            std::string driver_source_path = std::string(module_path_buffer).substr(0, exe_loc + 1) + winring0_filename;\n            CopyFile(driver_source_path.c_str(), winring0_install_location, true);\n        }\n        if(bIsWow64)\n        {\n            Wow64RevertWow64FsRedirection(wow64_fsredirection_OldValue);\n        }\n\n        SC_HANDLE service = OpenService(manager, driver_name.c_str(), SERVICE_ALL_ACCESS);\n        if(!service)\n        {\n            std::string service_sys_path = \"System32\\\\Drivers\\\\\" + winring0_filename;\n            service = CreateService(manager,\n               driver_name.c_str(),\n               driver_name.c_str(),\n               SERVICE_ALL_ACCESS,\n               SERVICE_KERNEL_DRIVER,\n               SERVICE_AUTO_START,\n               SERVICE_ERROR_NORMAL,\n               service_sys_path.c_str(),\n               NULL,\n               NULL,\n               NULL,\n               NULL,\n               NULL);\n        }\n        CloseServiceHandle(service);\n        CloseServiceHandle(manager);\n    }\n}\n#endif\n\n/******************************************************************************************\\\n*                                                                                          *\n*   main                                                                                   *\n*                                                                                          *\n*       Main function.  Detects busses and Aura controllers, then opens the main window    *\n*                                                                                          *\n\\******************************************************************************************/\n\nint main(int argc, char* argv[])\n{\n#ifdef _WIN32\n    /*---------------------------------------------------------*\\\n    | Windows only - Attach console output                      |\n    \\*---------------------------------------------------------*/\n    if (AttachConsole(ATTACH_PARENT_PROCESS))\n    {\n        /*---------------------------------------------------------*\\\n        | We are running under some terminal context; otherwise     |\n        | leave the GUI and CRT alone                               |\n        \\*---------------------------------------------------------*/\n        freopen(\"CONIN$\",  \"r\", stdin);\n        freopen(\"CONOUT$\", \"w\", stdout);\n        freopen(\"CONOUT$\", \"w\", stderr);\n    }\n\n    /*---------------------------------------------------------*\\\n    | Windows only - Start timer resolution correction thread   |\n    \\*---------------------------------------------------------*/\n    std::thread * InitializeTimerResolutionThread;\n    InitializeTimerResolutionThread = new std::thread(InitializeTimerResolutionThreadFunction);\n    InitializeTimerResolutionThread->detach();\n\n    /*---------------------------------------------------------*\\\n    | Windows only - Install SMBus Driver WinRing0              |\n    \\*---------------------------------------------------------*/\n    InstallWinRing0();\n#endif\n\n    /*---------------------------------------------------------*\\\n    | Mac x86/x64 only - Install SMBus Driver macUSPCIO         |\n    \\*---------------------------------------------------------*/\n#ifdef _MACOSX_X86_X64\n    InitMacUSPCIODriver();\n#endif\n\n    /*---------------------------------------------------------*\\\n    | Process command line arguments before detection           |\n    \\*---------------------------------------------------------*/\n    unsigned int ret_flags = cli_pre_detection(argc, argv);\n\n    ResourceManager::get()->Initialize(\n        !(ret_flags & RET_FLAG_NO_AUTO_CONNECT),\n        !(ret_flags & RET_FLAG_NO_DETECT),\n        ret_flags & RET_FLAG_START_SERVER,\n        ret_flags & RET_FLAG_CLI_POST_DETECTION);\n\n    /*---------------------------------------------------------*\\\n    | If the command line parser indicates that the GUI should  |\n    | run, or if there were no command line arguments, start the|\n    | GUI.                                                      |\n    \\*---------------------------------------------------------*/\n    if(ret_flags & RET_FLAG_START_GUI)\n    {\n        LOG_TRACE(\"[main] initializing GUI\");\n        QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);\n        QApplication a(argc, argv);\n        QGuiApplication::setDesktopFileName(\"org.openrgb.OpenRGB\");\n        LOG_TRACE(\"[main] QApplication created\");\n\n        /*---------------------------------------------------------*\\\n        | Main UI widget                                            |\n        \\*---------------------------------------------------------*/\n        Ui::OpenRGBDialog dlg;\n        LOG_TRACE(\"[main] Dialog created\");\n\n        if(ret_flags & RET_FLAG_I2C_TOOLS)\n        {\n            dlg.AddI2CToolsPage();\n        }\n\n        dlg.AddClientTab();\n\n        if(ret_flags & RET_FLAG_START_MINIMIZED)\n        {\n#ifdef _WIN32\n            /*---------------------------------------------------------*\\\n            | Show the window always, even if it will immediately be    |\n            | hidden.  On Windows, events are not delivered to          |\n            | nativeEventFilter (for SuspendResume) until the window    |\n            | has been shown once.                                      |\n            \\*---------------------------------------------------------*/\n            dlg.showMinimized();\n#endif\n#ifdef __APPLE__\n            MacUtils::ToggleApplicationDocklessState(false);\n#endif\n            dlg.hide();\n        }\n        else\n        {\n            dlg.show();\n        }\n\n        LOG_TRACE(\"[main] Ready to exec() the dialog\");\n        return a.exec();\n    }\n    else\n    {\n        /*---------------------------------------------------------*\\\n        | If no GUI is needed, we let the background threads run    |\n        | as long as they need, but we need to AT LEAST wait for    |\n        | initialization to finish                                  |\n        \\*---------------------------------------------------------*/\n        ResourceManager::get()->WaitForInitialization();\n\n        if(ret_flags & RET_FLAG_START_SERVER)\n        {\n            NetworkServer* server = ResourceManager::get()->GetServer();\n\n            if(!server->GetOnline())\n            {\n#ifdef _MACOSX_X86_X64\n                CloseMacUSPCIODriver();\n#endif\n                return 1;\n            }\n            else\n            {\n                WaitWhileServerOnline(server);\n#ifdef _MACOSX_X86_X64\n                CloseMacUSPCIODriver();\n#endif\n            }\n        }\n        else\n        {\n#ifdef _MACOSX_X86_X64\n            CloseMacUSPCIODriver();\n#endif\n            return 0;\n        }\n    }\n}\n"
        },
        {
          "name": "net_port",
          "type": "tree",
          "content": null
        },
        {
          "name": "pci_ids",
          "type": "tree",
          "content": null
        },
        {
          "name": "qt",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "scsiapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "serial_port",
          "type": "tree",
          "content": null
        },
        {
          "name": "super_io",
          "type": "tree",
          "content": null
        },
        {
          "name": "wmi",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}