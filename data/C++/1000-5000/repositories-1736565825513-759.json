{
  "metadata": {
    "timestamp": 1736565825513,
    "page": 759,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nodejs/node-addon-api",
      "stars": 2203,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.1123046875,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  Google\nAccessModifierOffset: -1\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: Inline\nAllowShortIfStatementsOnASingleLine: true\nAllowShortLoopsOnASingleLine: true\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: false\nBinPackParameters: false\nBraceWrapping:\n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:      80\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nForEachMacros:\n  - foreach\n  - Q_FOREACH\n  - BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories:\n  - Regex:           '^<ext/.*\\.h>'\n    Priority:        2\n  - Regex:           '^<.*\\.h>'\n    Priority:        1\n  - Regex:           '^<.*'\n    Priority:        2\n  - Regex:           '.*'\n    Priority:        3\nIncludeIsMainRegex: '([-_](test|unittest))?$'\nIndentCaseLabels: true\nIndentPPDirectives: None\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: false\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 1\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 200\nPointerAlignment: Left\nReflowComments:  true\nSortIncludes:    true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 2\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Auto\nTabWidth:        8\nUseTab:          Never\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.126953125,
          "content": "root = true\n\n[*]\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3583984375,
          "content": "/node_modules\n/build\n/benchmark/build\n/benchmark/src\n/test/addon_build/addons\n/test/require_basic_finalizers/addons\n/.vscode\n\n# ignore node-gyp generated files outside its build directory\n/test/*.Makefile\n/test/*.mk\n\n# ignore node-gyp generated Visual Studio files\n*.vcxproj\n*.vcxproj.filters\n*.vcxproj.user\n*.vsidx\n*.sln\n*.suo\n/test/.vs/\n/test/Release/\n/test/Debug/\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": ".release-please-manifest.json",
          "type": "blob",
          "size": 0.0185546875,
          "content": "{\n  \".\": \"8.3.0\"\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 112.4365234375,
          "content": "# node-addon-api Changelog\n\n## [8.3.0](https://github.com/nodejs/node-addon-api/compare/v8.2.2...v8.3.0) (2024-11-29)\n\n\n### Features\n\n* allow catching all exceptions ([#1593](https://github.com/nodejs/node-addon-api/issues/1593)) ([c679f6f](https://github.com/nodejs/node-addon-api/commit/c679f6f4c9dc6bf9fc0d99cbe5982bd24a5e2c7b))\n\n## [8.2.2](https://github.com/nodejs/node-addon-api/compare/v8.2.1...v8.2.2) (2024-11-07)\n\n\n### Bug Fixes\n\n* mark external memory and version APIs as basic ([#1597](https://github.com/nodejs/node-addon-api/issues/1597)) ([78da4fa](https://github.com/nodejs/node-addon-api/commit/78da4fa2251af1e4de16efac94d92388f117ae6e))\n* missing napi_delete_reference on ObjectWrap ref ([#1607](https://github.com/nodejs/node-addon-api/issues/1607)) ([98aae33](https://github.com/nodejs/node-addon-api/commit/98aae3343c3af36b4befd6b67c4cb19ba49b8d20))\n\n## [8.2.1](https://github.com/nodejs/node-addon-api/compare/v8.2.0...v8.2.1) (2024-10-09)\n\n\n### Bug Fixes\n\n* failed type cast checks in Symbol::WellKnown ([#1581](https://github.com/nodejs/node-addon-api/issues/1581)) ([d8523a7](https://github.com/nodejs/node-addon-api/commit/d8523a708030a0a3abb9d7832051c70e2dafac3d))\n* missing node_api_nogc_env definition ([#1585](https://github.com/nodejs/node-addon-api/issues/1585)) ([6ba3891](https://github.com/nodejs/node-addon-api/commit/6ba3891954d8b56215d133e54a86cb621e476b9e))\n\n## [8.2.0](https://github.com/nodejs/node-addon-api/compare/v8.1.0...v8.2.0) (2024-09-19)\n\n\n### Features\n\n* add support for nogc types via `BasicEnv`  ([#1514](https://github.com/nodejs/node-addon-api/issues/1514)) ([b4aeecb](https://github.com/nodejs/node-addon-api/commit/b4aeecb046480eeaaf1c578a140f71ac0e77094f))\n* add support for requiring basic finalizers ([#1568](https://github.com/nodejs/node-addon-api/issues/1568)) ([7bcb826](https://github.com/nodejs/node-addon-api/commit/7bcb826aa4323f450b3c58f9c7fb34243ff13f77))\n\n\n### Bug Fixes\n\n* call base basic finalizer if none defined ([#1574](https://github.com/nodejs/node-addon-api/issues/1574)) ([294a43f](https://github.com/nodejs/node-addon-api/commit/294a43f8c6a4c79b3295a8f1b83d4782d44cfe74))\n\n## [8.1.0](https://github.com/nodejs/node-addon-api/compare/node-addon-api-v8.0.0...node-addon-api-v8.1.0) (2024-07-05)\n\n\n### Features\n\n* Expose version property in public API ([#1479](https://github.com/nodejs/node-addon-api/issues/1479)) ([23bb42b](https://github.com/nodejs/node-addon-api/commit/23bb42b5e47630c9082dddbabea555626571926e))\n* improve messages on CheckCast ([#1507](https://github.com/nodejs/node-addon-api/issues/1507)) ([bf49519](https://github.com/nodejs/node-addon-api/commit/bf49519a4ce08ee5320327c9a0199cd89d5b87b3))\n\n\n### Bug Fixes\n\n* fix compilation for Visual Studio 2022 ([#1492](https://github.com/nodejs/node-addon-api/issues/1492)) ([e011720](https://github.com/nodejs/node-addon-api/commit/e011720010af26ed66638ceac822e5f1c5e43cde))\n* restore ability to run under NAPI_EXPERIMENTAL ([#1409](https://github.com/nodejs/node-addon-api/issues/1409)) ([40bcb09](https://github.com/nodejs/node-addon-api/commit/40bcb09e6b82e7a1164cb3de56cb503d9b5a3d37))\n\n## 2024-03-01 Version 8.0.0, @legendecas\n\n### Notable changes\n\n- Support for Node.js v16.x is no longer maintained.\n\n### Commits\n\n* \\[[`df2147a2b6`](https://github.com/nodejs/node-addon-api/commit/df2147a2b6)] - build(deps): bump github/codeql-action from 3.24.3 to 3.24.5 (dependabot\\[bot]) [#1455](https://github.com/nodejs/node-addon-api/pull/1455)\n* \\[[`eb4fa9b55a`](https://github.com/nodejs/node-addon-api/commit/eb4fa9b55a)] - build(deps): bump actions/dependency-review-action from 4.1.0 to 4.1.3 (dependabot\\[bot]) [#1452](https://github.com/nodejs/node-addon-api/pull/1452)\n* \\[[`f85e8146bb`](https://github.com/nodejs/node-addon-api/commit/f85e8146bb)] - build(deps): bump github/codeql-action from 3.23.2 to 3.24.3 (dependabot\\[bot]) [#1448](https://github.com/nodejs/node-addon-api/pull/1448)\n* \\[[`b84deb0d2f`](https://github.com/nodejs/node-addon-api/commit/b84deb0d2f)] - build(deps): bump actions/dependency-review-action from 4.0.0 to 4.1.0 (dependabot\\[bot]) [#1447](https://github.com/nodejs/node-addon-api/pull/1447)\n* \\[[`7dcee380cd`](https://github.com/nodejs/node-addon-api/commit/7dcee380cd)] - build(deps): bump actions/setup-node from 4.0.1 to 4.0.2 (dependabot\\[bot]) [#1444](https://github.com/nodejs/node-addon-api/pull/1444)\n* \\[[`a727b629fe`](https://github.com/nodejs/node-addon-api/commit/a727b629fe)] - build(deps): bump actions/upload-artifact from 4.3.0 to 4.3.1 (dependabot\\[bot]) [#1443](https://github.com/nodejs/node-addon-api/pull/1443)\n* \\[[`ea712094e3`](https://github.com/nodejs/node-addon-api/commit/ea712094e3)] - build(deps): bump step-security/harden-runner from 2.6.1 to 2.7.0 (dependabot\\[bot]) [#1440](https://github.com/nodejs/node-addon-api/pull/1440)\n* \\[[`898e5006a5`](https://github.com/nodejs/node-addon-api/commit/898e5006a5)] - build(deps): bump github/codeql-action from 3.23.1 to 3.23.2 (dependabot\\[bot]) [#1439](https://github.com/nodejs/node-addon-api/pull/1439)\n* \\[[`66e6e0e4b6`](https://github.com/nodejs/node-addon-api/commit/66e6e0e4b6)] - build(deps): bump actions/upload-artifact from 4.0.0 to 4.3.0 (dependabot\\[bot]) [#1438](https://github.com/nodejs/node-addon-api/pull/1438)\n* \\[[`f1ca4ccd7f`](https://github.com/nodejs/node-addon-api/commit/f1ca4ccd7f)] - build(deps): bump actions/dependency-review-action from 3.1.5 to 4.0.0 (dependabot\\[bot]) [#1433](https://github.com/nodejs/node-addon-api/pull/1433)\n* \\[[`c58112d52e`](https://github.com/nodejs/node-addon-api/commit/c58112d52e)] - build(deps): bump github/codeql-action from 3.23.0 to 3.23.1 (dependabot\\[bot]) [#1430](https://github.com/nodejs/node-addon-api/pull/1430)\n* \\[[`f1b9c0bc24`](https://github.com/nodejs/node-addon-api/commit/f1b9c0bc24)] - **chore**: remove v16.x regular CI runs (Chengzhong Wu) [#1437](https://github.com/nodejs/node-addon-api/pull/1437)\n* \\[[`c6561d90d6`](https://github.com/nodejs/node-addon-api/commit/c6561d90d6)] - **chore**: reduce dependabot noise (Chengzhong Wu) [#1436](https://github.com/nodejs/node-addon-api/pull/1436)\n* \\[[`42931eeba6`](https://github.com/nodejs/node-addon-api/commit/42931eeba6)] - **doc**: reorganize readme (Chengzhong Wu) [#1441](https://github.com/nodejs/node-addon-api/pull/1441)\n* \\[[`3b9f3db14e`](https://github.com/nodejs/node-addon-api/commit/3b9f3db14e)] - **doc**: update changelog maker commands (Chengzhong Wu) [#1431](https://github.com/nodejs/node-addon-api/pull/1431)\n* \\[[`034c039298`](https://github.com/nodejs/node-addon-api/commit/034c039298)] - **test**: heed npm\\_config\\_debug (Gabriel Schulhof) [#1445](https://github.com/nodejs/node-addon-api/pull/1445)\n\n## 2024-01-18 Version 7.1.0, @legendecas\n\n### Notable changes\n\n#### API\n\n- Add Env::GetModuleFileName\n- Add SyntaxError\n- Allow NAPI\\_VERSION env var and templatize AttachData callback\n- Add common gyp dependency targets.\n\n### Commits\n\n* \\[[`864fed488c`](https://github.com/nodejs/node-addon-api/commit/864fed488c)] - build(deps): bump github/codeql-action from 3.22.12 to 3.23.0 (dependabot\\[bot]) [#1428](https://github.com/nodejs/node-addon-api/pull/1428)\n* \\[[`81a8d43130`](https://github.com/nodejs/node-addon-api/commit/81a8d43130)] - build(deps): bump actions/dependency-review-action from 3.1.4 to 3.1.5 (dependabot\\[bot]) [#1427](https://github.com/nodejs/node-addon-api/pull/1427)\n* \\[[`e20088941b`](https://github.com/nodejs/node-addon-api/commit/e20088941b)] - build(deps): bump github/codeql-action from 3.22.11 to 3.22.12 (dependabot\\[bot]) [#1426](https://github.com/nodejs/node-addon-api/pull/1426)\n* \\[[`76c7b12e4e`](https://github.com/nodejs/node-addon-api/commit/76c7b12e4e)] - build(deps): bump actions/setup-node from 4.0.0 to 4.0.1 (dependabot\\[bot]) [#1425](https://github.com/nodejs/node-addon-api/pull/1425)\n* \\[[`cd58edde1d`](https://github.com/nodejs/node-addon-api/commit/cd58edde1d)] - build(deps): bump actions/upload-artifact from 3.1.3 to 4.0.0 (dependabot\\[bot]) [#1424](https://github.com/nodejs/node-addon-api/pull/1424)\n* \\[[`0fd1b9e0e1`](https://github.com/nodejs/node-addon-api/commit/0fd1b9e0e1)] - build(deps): bump github/codeql-action from 2.22.8 to 3.22.11 (dependabot\\[bot]) [#1423](https://github.com/nodejs/node-addon-api/pull/1423)\n* \\[[`c181b19d68`](https://github.com/nodejs/node-addon-api/commit/c181b19d68)] - build(deps): bump actions/stale from 8.0.0 to 9.0.0 (dependabot\\[bot]) [#1418](https://github.com/nodejs/node-addon-api/pull/1418)\n* \\[[`6fa67791a1`](https://github.com/nodejs/node-addon-api/commit/6fa67791a1)] - build(deps): bump actions/setup-python from 4.7.1 to 5.0.0 (dependabot\\[bot]) [#1417](https://github.com/nodejs/node-addon-api/pull/1417)\n* \\[[`1fff346fa6`](https://github.com/nodejs/node-addon-api/commit/1fff346fa6)] - build(deps): bump actions/dependency-review-action from 3.1.3 to 3.1.4 (dependabot\\[bot]) [#1415](https://github.com/nodejs/node-addon-api/pull/1415)\n* \\[[`ecb9690fe5`](https://github.com/nodejs/node-addon-api/commit/ecb9690fe5)] - build(deps): bump github/codeql-action from 2.22.7 to 2.22.8 (dependabot\\[bot]) [#1414](https://github.com/nodejs/node-addon-api/pull/1414)\n* \\[[`969547b871`](https://github.com/nodejs/node-addon-api/commit/969547b871)] - build(deps): bump github/codeql-action from 2.22.5 to 2.22.7 (dependabot\\[bot]) [#1413](https://github.com/nodejs/node-addon-api/pull/1413)\n* \\[[`183d1522a9`](https://github.com/nodejs/node-addon-api/commit/183d1522a9)] - build(deps): bump step-security/harden-runner from 2.6.0 to 2.6.1 (dependabot\\[bot]) [#1412](https://github.com/nodejs/node-addon-api/pull/1412)\n* \\[[`25f977724a`](https://github.com/nodejs/node-addon-api/commit/25f977724a)] - build(deps): bump actions/dependency-review-action from 3.1.0 to 3.1.3 (dependabot\\[bot]) [#1410](https://github.com/nodejs/node-addon-api/pull/1410)\n* \\[[`f6d125a407`](https://github.com/nodejs/node-addon-api/commit/f6d125a407)] - build(deps): bump actions/setup-python from 4.7.0 to 4.7.1 (dependabot\\[bot]) [#1406](https://github.com/nodejs/node-addon-api/pull/1406)\n* \\[[`ce78a39ec7`](https://github.com/nodejs/node-addon-api/commit/ce78a39ec7)] - build(deps): bump github/codeql-action from 2.22.4 to 2.22.5 (dependabot\\[bot]) [#1400](https://github.com/nodejs/node-addon-api/pull/1400)\n* \\[[`dc211ebb48`](https://github.com/nodejs/node-addon-api/commit/dc211ebb48)] - build(deps): bump actions/setup-node from 3.8.1 to 4.0.0 (dependabot\\[bot]) [#1398](https://github.com/nodejs/node-addon-api/pull/1398)\n* \\[[`cab559e3bd`](https://github.com/nodejs/node-addon-api/commit/cab559e3bd)] - build(deps): bump ossf/scorecard-action from 2.3.0 to 2.3.1 (dependabot\\[bot]) [#1397](https://github.com/nodejs/node-addon-api/pull/1397)\n* \\[[`f71ff5582d`](https://github.com/nodejs/node-addon-api/commit/f71ff5582d)] - build(deps): bump github/codeql-action from 2.22.3 to 2.22.4 (dependabot\\[bot]) [#1396](https://github.com/nodejs/node-addon-api/pull/1396)\n* \\[[`21c1d08680`](https://github.com/nodejs/node-addon-api/commit/21c1d08680)] - build(deps): bump actions/checkout from 4.1.0 to 4.1.1 (dependabot\\[bot]) [#1394](https://github.com/nodejs/node-addon-api/pull/1394)\n* \\[[`e4eec0939c`](https://github.com/nodejs/node-addon-api/commit/e4eec0939c)] - build(deps): bump github/codeql-action from 2.21.9 to 2.22.3 (dependabot\\[bot]) [#1393](https://github.com/nodejs/node-addon-api/pull/1393)\n* \\[[`94f3459474`](https://github.com/nodejs/node-addon-api/commit/94f3459474)] - build(deps): bump ossf/scorecard-action from 2.2.0 to 2.3.0 (dependabot\\[bot]) [#1388](https://github.com/nodejs/node-addon-api/pull/1388)\n* \\[[`90a741ef10`](https://github.com/nodejs/node-addon-api/commit/90a741ef10)] - build(deps): bump step-security/harden-runner from 2.5.1 to 2.6.0 (dependabot\\[bot]) [#1386](https://github.com/nodejs/node-addon-api/pull/1386)\n* \\[[`7e1aa06132`](https://github.com/nodejs/node-addon-api/commit/7e1aa06132)] - Update LICENSE.md (Michael Dawson) [#1385](https://github.com/nodejs/node-addon-api/pull/1385)\n* \\[[`0a0612362e`](https://github.com/nodejs/node-addon-api/commit/0a0612362e)] - build(deps): bump github/codeql-action from 2.21.7 to 2.21.9 (dependabot\\[bot]) [#1384](https://github.com/nodejs/node-addon-api/pull/1384)\n* \\[[`47bd430da2`](https://github.com/nodejs/node-addon-api/commit/47bd430da2)] - build(deps): bump actions/checkout from 4.0.0 to 4.1.0 (dependabot\\[bot]) [#1383](https://github.com/nodejs/node-addon-api/pull/1383)\n* \\[[`b3f7f73cb9`](https://github.com/nodejs/node-addon-api/commit/b3f7f73cb9)] - build(deps): bump actions/dependency-review-action from 3.0.8 to 3.1.0 (dependabot\\[bot]) [#1377](https://github.com/nodejs/node-addon-api/pull/1377)\n* \\[[`12c1655387`](https://github.com/nodejs/node-addon-api/commit/12c1655387)] - build(deps): bump github/codeql-action from 2.21.6 to 2.21.7 (dependabot\\[bot]) [#1380](https://github.com/nodejs/node-addon-api/pull/1380)\n* \\[[`6abed318e4`](https://github.com/nodejs/node-addon-api/commit/6abed318e4)] - build(deps): bump github/codeql-action from 2.21.5 to 2.21.6 (dependabot\\[bot]) [#1378](https://github.com/nodejs/node-addon-api/pull/1378)\n* \\[[`89eda59930`](https://github.com/nodejs/node-addon-api/commit/89eda59930)] - build(deps): bump actions/upload-artifact from 3.1.2 to 3.1.3 (dependabot\\[bot]) [#1376](https://github.com/nodejs/node-addon-api/pull/1376)\n* \\[[`90870dbffa`](https://github.com/nodejs/node-addon-api/commit/90870dbffa)] - build(deps): bump actions/checkout from 3.6.0 to 4.0.0 (dependabot\\[bot]) [#1375](https://github.com/nodejs/node-addon-api/pull/1375)\n* \\[[`b860793eff`](https://github.com/nodejs/node-addon-api/commit/b860793eff)] - build(deps): bump github/codeql-action from 2.21.2 to 2.21.5 (dependabot\\[bot]) [#1372](https://github.com/nodejs/node-addon-api/pull/1372)\n* \\[[`f9b9974b4a`](https://github.com/nodejs/node-addon-api/commit/f9b9974b4a)] - build(deps): bump actions/checkout from 3.5.3 to 3.6.0 (dependabot\\[bot]) [#1371](https://github.com/nodejs/node-addon-api/pull/1371)\n* \\[[`9596e3de2d`](https://github.com/nodejs/node-addon-api/commit/9596e3de2d)] - build(deps): bump actions/setup-node from 3.7.0 to 3.8.1 (dependabot\\[bot]) [#1370](https://github.com/nodejs/node-addon-api/pull/1370)\n* \\[[`e969210747`](https://github.com/nodejs/node-addon-api/commit/e969210747)] - build(deps): bump actions/dependency-review-action from 3.0.6 to 3.0.8 (dependabot\\[bot]) [#1368](https://github.com/nodejs/node-addon-api/pull/1368)\n* \\[[`13ef96a5a9`](https://github.com/nodejs/node-addon-api/commit/13ef96a5a9)] - build(deps): bump step-security/harden-runner from 2.5.0 to 2.5.1 (dependabot\\[bot]) [#1364](https://github.com/nodejs/node-addon-api/pull/1364)\n* \\[[`9776d148b3`](https://github.com/nodejs/node-addon-api/commit/9776d148b3)] - build(deps): bump github/codeql-action from 2.21.1 to 2.21.2 (dependabot\\[bot]) [#1358](https://github.com/nodejs/node-addon-api/pull/1358)\n* \\[[`59dc6be097`](https://github.com/nodejs/node-addon-api/commit/59dc6be097)] - build(deps): bump github/codeql-action from 2.21.0 to 2.21.1 (dependabot\\[bot]) [#1357](https://github.com/nodejs/node-addon-api/pull/1357)\n* \\[[`5e72796cd5`](https://github.com/nodejs/node-addon-api/commit/5e72796cd5)] - build(deps): bump step-security/harden-runner from 2.4.1 to 2.5.0 (dependabot\\[bot]) [#1356](https://github.com/nodejs/node-addon-api/pull/1356)\n* \\[[`4e62db45e4`](https://github.com/nodejs/node-addon-api/commit/4e62db45e4)] - build(deps): bump github/codeql-action from 2.20.3 to 2.21.0 (dependabot\\[bot]) [#1353](https://github.com/nodejs/node-addon-api/pull/1353)\n* \\[[`0c093a33e8`](https://github.com/nodejs/node-addon-api/commit/0c093a33e8)] - build(deps): bump github/codeql-action from 2.20.1 to 2.20.3 (dependabot\\[bot]) [#1349](https://github.com/nodejs/node-addon-api/pull/1349)\n* \\[[`5523b2d3fa`](https://github.com/nodejs/node-addon-api/commit/5523b2d3fa)] - build(deps): bump actions/setup-node from 3.6.0 to 3.7.0 (dependabot\\[bot]) [#1348](https://github.com/nodejs/node-addon-api/pull/1348)\n* \\[[`afa494ef7f`](https://github.com/nodejs/node-addon-api/commit/afa494ef7f)] - Add Node.js version restrictions (Ingo Fischer) [#1340](https://github.com/nodejs/node-addon-api/pull/1340)\n* \\[[`ac4c87f660`](https://github.com/nodejs/node-addon-api/commit/ac4c87f660)] - build(deps): bump ossf/scorecard-action from 2.0.6 to 2.2.0 (dependabot\\[bot]) [#1344](https://github.com/nodejs/node-addon-api/pull/1344)\n* \\[[`47aeb6689d`](https://github.com/nodejs/node-addon-api/commit/47aeb6689d)] - build(deps): bump github/codeql-action from 2.2.12 to 2.20.1 (dependabot\\[bot]) [#1343](https://github.com/nodejs/node-addon-api/pull/1343)\n* \\[[`bd45a8fffc`](https://github.com/nodejs/node-addon-api/commit/bd45a8fffc)] - build(deps): bump step-security/harden-runner from 2.3.0 to 2.4.1 (dependabot\\[bot]) [#1342](https://github.com/nodejs/node-addon-api/pull/1342)\n* \\[[`343a1e1708`](https://github.com/nodejs/node-addon-api/commit/343a1e1708)] - build(deps-dev): bump fs-extra from 9.1.0 to 11.1.1 (dependabot\\[bot]) [#1335](https://github.com/nodejs/node-addon-api/pull/1335)\n* \\[[`4168c10182`](https://github.com/nodejs/node-addon-api/commit/4168c10182)] - build(deps): bump actions/stale from 5.2.1 to 8.0.0 (dependabot\\[bot]) [#1333](https://github.com/nodejs/node-addon-api/pull/1333)\n* \\[[`1c182abd1f`](https://github.com/nodejs/node-addon-api/commit/1c182abd1f)] - build(deps): bump actions/dependency-review-action from 2.5.1 to 3.0.6 (dependabot\\[bot]) [#1331](https://github.com/nodejs/node-addon-api/pull/1331)\n* \\[[`717a61931d`](https://github.com/nodejs/node-addon-api/commit/717a61931d)] - build(deps): bump actions/checkout from 3.5.2 to 3.5.3 (dependabot\\[bot]) [#1329](https://github.com/nodejs/node-addon-api/pull/1329)\n* \\[[`d605d62c89`](https://github.com/nodejs/node-addon-api/commit/d605d62c89)] - **chore**: lock python version in actions (Chengzhong Wu) [#1403](https://github.com/nodejs/node-addon-api/pull/1403)\n* \\[[`734e3f2509`](https://github.com/nodejs/node-addon-api/commit/734e3f2509)] - **doc**: fix rendering of code blocks in list (Tobias Nießen) [#1401](https://github.com/nodejs/node-addon-api/pull/1401)\n* \\[[`dfdf6eb6e6`](https://github.com/nodejs/node-addon-api/commit/dfdf6eb6e6)] - **doc**: add missing title IsBigInt (Marx) [#1352](https://github.com/nodejs/node-addon-api/pull/1352)\n* \\[[`8850997f38`](https://github.com/nodejs/node-addon-api/commit/8850997f38)] - **doc**: fix typo AsyncProgressWorker::ExecutionProgress (JerryZhongJ) [#1350](https://github.com/nodejs/node-addon-api/pull/1350)\n* \\[[`8192a471a1`](https://github.com/nodejs/node-addon-api/commit/8192a471a1)] - **docs**: fixed Broken Links (Ömer AKGÜL) [#1405](https://github.com/nodejs/node-addon-api/pull/1405)\n* \\[[`16a18c047a`](https://github.com/nodejs/node-addon-api/commit/16a18c047a)] - **fix**: handle c++ exception in TSFN callback (Chengzhong Wu) [#1345](https://github.com/nodejs/node-addon-api/pull/1345)\n* \\[[`ab14347080`](https://github.com/nodejs/node-addon-api/commit/ab14347080)] - **gyp**: add common targets (Chengzhong Wu) [#1389](https://github.com/nodejs/node-addon-api/pull/1389)\n* \\[[`fa3518bc08`](https://github.com/nodejs/node-addon-api/commit/fa3518bc08)] - **src**: remove duplicate buffer info calls (Chengzhong Wu) [#1354](https://github.com/nodejs/node-addon-api/pull/1354)\n* \\[[`b83e453e6e`](https://github.com/nodejs/node-addon-api/commit/b83e453e6e)] - **src**: add Env::GetModuleFileName (Kevin Eady) [#1327](https://github.com/nodejs/node-addon-api/pull/1327)\n* \\[[`d9828c6264`](https://github.com/nodejs/node-addon-api/commit/d9828c6264)] - **src**: add SyntaxError (Kevin Eady) [#1326](https://github.com/nodejs/node-addon-api/pull/1326)\n* \\[[`c52e764bb2`](https://github.com/nodejs/node-addon-api/commit/c52e764bb2)] - **src,test,build**: allow NAPI\\_VERSION env var and templatize AttachData callback (Gabriel Schulhof) [#1399](https://github.com/nodejs/node-addon-api/pull/1399)\n* \\[[`8f028d630a`](https://github.com/nodejs/node-addon-api/commit/8f028d630a)] - **test**: remove experimental flag from bigint (Gabriel Schulhof) [#1395](https://github.com/nodejs/node-addon-api/pull/1395)\n* \\[[`414be9e000`](https://github.com/nodejs/node-addon-api/commit/414be9e000)] - **test**: run interfering tests in their own process (Gabriel Schulhof) [#1325](https://github.com/nodejs/node-addon-api/pull/1325)\n\n## 2023-06-13 Version 7.0.0, @KevinEady\n\n### Notable changes\n\n#### API\n\n- Drop support for Node.js v14.x and v19.x.\n- Ensure native receiver exists when calling instance methods and properties.\n- Fix issue when creating `Napi::Error` instances that wrap primitives values.\n\n#### TEST\n\n- Added tests for `Napi::AsyncProgressQueueWorker<T>` class.\n- Added tests for `Napi::AsyncProgressWorker<T>` class.\n\n### Documentation\n\n- Added documentation for `Napi::Value::IsBigInt()`.\n\n### Commits\n\n* \\[[`de5c899400`](https://github.com/nodejs/node-addon-api/commit/de5c899400)] - **doc,chore**: drop support for Node.js v14, v19 (Kevin Eady) [#1324](https://github.com/nodejs/node-addon-api/pull/1324)\n* \\[[`3083b7f148`](https://github.com/nodejs/node-addon-api/commit/3083b7f148)] - \\[StepSecurity] Apply security best practices (StepSecurity Bot) [#1308](https://github.com/nodejs/node-addon-api/pull/1308)\n* \\[[`a198e24a15`](https://github.com/nodejs/node-addon-api/commit/a198e24a15)] - \\[Test] Add tests for async progress queue worker (Jack) [#1316](https://github.com/nodejs/node-addon-api/pull/1316)\n* \\[[`665f4aa845`](https://github.com/nodejs/node-addon-api/commit/665f4aa845)] - **doc**: add missing Value::IsBigInt (Kevin Eady) [#1319](https://github.com/nodejs/node-addon-api/pull/1319)\n* \\[[`358b2d3b4f`](https://github.com/nodejs/node-addon-api/commit/358b2d3b4f)] - **doc**: complete code curly braces  in async\\_worker.md (wanlu) [#1317](https://github.com/nodejs/node-addon-api/pull/1317)\n* \\[[`858942ce31`](https://github.com/nodejs/node-addon-api/commit/858942ce31)] - **src**: avoid calling into C++ with a null this (Caleb Hearon) [#1313](https://github.com/nodejs/node-addon-api/pull/1313)\n* \\[[`64f6515331`](https://github.com/nodejs/node-addon-api/commit/64f6515331)] - **src**: handle failure during error wrap of primitive (Gabriel Schulhof) [#1310](https://github.com/nodejs/node-addon-api/pull/1310)\n* \\[[`dfad6b45fe`](https://github.com/nodejs/node-addon-api/commit/dfad6b45fe)] - \\[test] Add test coverage for AsyncProgressWorker (Jack) [#1307](https://github.com/nodejs/node-addon-api/pull/1307)\n* \\[[`0e34f22839`](https://github.com/nodejs/node-addon-api/commit/0e34f22839)] - **release**: v6.1.0. (Nicola Del Gobbo)\n\n## 2023-04-20 Version 6.1.0, @NickNaso\n\n### Notable changes\n\n#### API\n\n- Enforce type checks on `Napi::Value::As()`.\n- Added `Napi::TypeTaggable` class.\n- Defined `NAPI_HAS_THREADS` to make TSFN available on Emscripten.\n- Defined `NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED` and\n`Napi::Buffer::NewOrCopy()` to handle the support for external buffers.\n\n#### TEST\n\n- Added tests for `Napi::Reference<T>` class.\n- Added tests for copy/move semantics.\n- Added tests for `Napi::RangeError` and `Napi::TypeError` class.\n- Fixed inconsistent failure executing test suite.\n- Added tests for `Napi::ObjectReference<T>` class.\n- Added tests for `Napi::ObjectWrap<T>` class.\n\n### Documentation\n\n- Added documentation for `Napi::TypeTaggable`.\n- Some minor fixes all over the documentation.\n\n### Commits\n\n- \\[[`5adb896782`](https://github.com/nodejs/node-addon-api/commit/5adb896782)] - **src**: enforce type checks on Napi::Value::As() (#1281) (Chengzhong Wu)\n- \\[[`d9faac7ec2`](https://github.com/nodejs/node-addon-api/commit/d9faac7ec2)] - Fix exits/exists typo in docs for Env::AddCleanupHook() (#1306) (Mathias Stearn)\n- \\[[`164459ca03`](https://github.com/nodejs/node-addon-api/commit/164459ca03)] - **doc**: update class hierarchy for TypeTaggable (Gabriel Schulhof) [#1303](https://github.com/nodejs/node-addon-api/pull/1303)\n- \\[[`d01304437c`](https://github.com/nodejs/node-addon-api/commit/d01304437c)] - **src**: interject class TypeTaggable (Gabriel Schulhof) [#1298](https://github.com/nodejs/node-addon-api/pull/1298)\n- \\[[`d4942ccd4f`](https://github.com/nodejs/node-addon-api/commit/d4942ccd4f)] - **test**: Complete test coverage for Reference\\<T> class (#1277) (Jack)\n- \\[[`a8ad7e7a7b`](https://github.com/nodejs/node-addon-api/commit/a8ad7e7a7b)] - **test**: Add tests for copy/move semantics (JckXia) [#1295](https://github.com/nodejs/node-addon-api/pull/1295)\n- \\[[`e484327344`](https://github.com/nodejs/node-addon-api/commit/e484327344)] - Add test coverage for typed and range err (#1280) (Jack)\n- \\[[`ebc7858593`](https://github.com/nodejs/node-addon-api/commit/ebc7858593)] - **test**: Update wait with a condition (#1297) (Jack)\n- \\[[`0b53d885f5`](https://github.com/nodejs/node-addon-api/commit/0b53d885f5)] - **src**: define `NAPI_HAS_THREADS` (toyobayashi) [#1283](https://github.com/nodejs/node-addon-api/pull/1283)\n- \\[[`464610babf`](https://github.com/nodejs/node-addon-api/commit/464610babf)] - **test**: complete objectRefs tests (JckXia) [#1274](https://github.com/nodejs/node-addon-api/pull/1274)\n- \\[[`b16c762a19`](https://github.com/nodejs/node-addon-api/commit/b16c762a19)] - **src**: handle no support for external buffers (legendecas) [#1273](https://github.com/nodejs/node-addon-api/pull/1273)\n- \\[[`61b8e28720`](https://github.com/nodejs/node-addon-api/commit/61b8e28720)] - **test**: Add test covg for obj wrap (#1269) (Jack)\n\n## 2023-02-03 Version 6.0.0, @NickNaso\n\n### Notable changes\n\n#### API\n\n- Added `Napi::Object::TypeTag()` and `Napi::Object::CheckTypeTag()` methods.\n- Made operator `napi_callback_info` explicit.\n\n#### TEST\n\n- Some minor fixes all over the test suite.\n- Added tests related to `Napi::Object::TypeTag()` and `Napi::Object::CheckTypeTag()` methods.\n- Added tests related to `Napi::CallbackScope`.\n- Added tests related to `Napi::EscapableHandleScope`.\n- Added tests related to `Napi::Maybe<T>`.\n- Added tests related to `Napi::ThreadSafeFuntion`.\n- Changed some tests related to `Napi::AsyncWorker`.\n\n### Documentation\n\n- Added documentation for `Napi::Object::TypeTag()` and `Napi::Object::CheckTypeTag()` methods.\n- Added documentation about how to run a specific unit test.\n\n### TOOL\n\n- Added `x86` architecture to the CI matrix.\n\n### Commits\n\n* \\[[`e2726193f1`](https://github.com/nodejs/node-addon-api/commit/e2726193f1)] - **src**: remove AsyncWorker move and complete tests (JckXia) [#1266](https://github.com/nodejs/node-addon-api/pull/1266)\n* \\[[`ff969485ea`](https://github.com/nodejs/node-addon-api/commit/ff969485ea)] - **chore**: build node-addon-api against X86 (JckXia) [#1276](https://github.com/nodejs/node-addon-api/pull/1276)\n* \\[[`a70564cdfd`](https://github.com/nodejs/node-addon-api/commit/a70564cdfd)] - **test**: add cov for ThreadSafeFunction new overloads (JckXia) [#1251](https://github.com/nodejs/node-addon-api/pull/1251)\n* \\[[`53f7cf1d48`](https://github.com/nodejs/node-addon-api/commit/53f7cf1d48)] - **src**: make operator napi\\_callback\\_info explicit (Kevin Eady) [#1275](https://github.com/nodejs/node-addon-api/pull/1275)\n* \\[[`78b5a15533`](https://github.com/nodejs/node-addon-api/commit/78b5a15533)] - **test**: Add tests for ThreadSafeFunction's NonBlock function overloads (#1249) (Jack)\n* \\[[`fdc6263034`](https://github.com/nodejs/node-addon-api/commit/fdc6263034)] - **test**: Add test covg for Maybe\\<T> (#1270) (Jack)\n* \\[[`35d9d669b3`](https://github.com/nodejs/node-addon-api/commit/35d9d669b3)] - **test**: add test covg for handle and escapehandle scopes (JckXia) [#1263](https://github.com/nodejs/node-addon-api/pull/1263)\n* \\[[`021313409e`](https://github.com/nodejs/node-addon-api/commit/021313409e)] - **test**: add unit test covg for callbackscopes (JckXia) [#1262](https://github.com/nodejs/node-addon-api/pull/1262)\n* \\[[`b11e4de2cf`](https://github.com/nodejs/node-addon-api/commit/b11e4de2cf)] - **src**: add Object::TypeTag, Object::CheckTypeTag (Kevin Eady) [#1261](https://github.com/nodejs/node-addon-api/pull/1261)\n\n## 2023-01-13 Version 5.1.0, @NickNaso\n\n### Notable changes\n\n#### API\n\n- Fixed memory leak in `Napi::AsyncProgressWorkerBase`.\n- Added api to get `callback_info` from `Napi::CallBackInfo`.\n- Fixed erros and warning in VS 2017.\n- Made `Npi::Env::CleanupHook` public.\n- Removed `Napi::TypedArray::unknown_array_type`.\n\n#### TEST\n\n- Some minor fixes all over the test suite.\n- Added tests related to `Napi::Env`.\n- Added tests related to `Napi::TypedArray`.\n- Added tests related to `Napi::AsyncWorker`.\n- Added tests related to `Napi::TypedThreadSafeFunction`.\n- Added tests related to `Napi::Value`.\n- Added test related to `Napi::Promise`.\n\n### Documentation\n\n- Some minor fixes all over the documentation.\n- Added `Napi::HandleScope` example.\n- Added documentation about how to run a specific unit test.\n\n### TOOL\n\n- Added Windows with VS 2022 and Node.JS 19.x to the CI matrix.\n- Fixed stale workflow.\n- Updated Node.js versions on CI component.\n- Added condition for Window to find eslint.\n\n### Commits\n\n* \\[[`79a446fb9c`](https://github.com/nodejs/node-addon-api/commit/79a446fb9c)] - Update contributors (#1265) (Kevin Eady)\n* \\[[`01c61690c6`](https://github.com/nodejs/node-addon-api/commit/01c61690c6)] - **src**: napi-inl: Fix a memory leak bug in `AsyncProgressWorkerBase` (Ammar Faizi) [#1264](https://github.com/nodejs/node-addon-api/pull/1264)\n* \\[[`55bd08ee26`](https://github.com/nodejs/node-addon-api/commit/55bd08ee26)] - **src**: api to get callback\\_info from CallBackInfo (JckXia) [#1253](https://github.com/nodejs/node-addon-api/pull/1253)\n* \\[[`ad76256714`](https://github.com/nodejs/node-addon-api/commit/ad76256714)] - **test**: add tests related to env (JckXia) [#1254](https://github.com/nodejs/node-addon-api/pull/1254)\n* \\[[`5c3937365d`](https://github.com/nodejs/node-addon-api/commit/5c3937365d)] - **chore**: add Windows with VS 2022 and Node.JS 19.x to the CI matrix (#1252) (Vladimir Morozov)\n* \\[[`97736c93f4`](https://github.com/nodejs/node-addon-api/commit/97736c93f4)] - **src**: fix errors and warnings in VS 2017 (Vladimir Morozov) [#1245](https://github.com/nodejs/node-addon-api/pull/1245)\n* \\[[`ad7ff92c16`](https://github.com/nodejs/node-addon-api/commit/ad7ff92c16)] - **src**: refactor call js wrapper (#1242) (Jack)\n* \\[[`39267baf1b`](https://github.com/nodejs/node-addon-api/commit/39267baf1b)] - **src**: make CleanupHook public (Julian Mesa) [#1240](https://github.com/nodejs/node-addon-api/pull/1240)\n* \\[[`edf630cc79`](https://github.com/nodejs/node-addon-api/commit/edf630cc79)] - **src**: fix implementation of Signal (Kevin Eady) [#1216](https://github.com/nodejs/node-addon-api/pull/1216)\n* \\[[`de5a502f3c`](https://github.com/nodejs/node-addon-api/commit/de5a502f3c)] - **doc**: Napi::Error is caught (Nicola Del Gobbo) [#1241](https://github.com/nodejs/node-addon-api/pull/1241)\n* \\[[`10ad762807`](https://github.com/nodejs/node-addon-api/commit/10ad762807)] - **test**: removed the usage of default\\_configuration. (Nicola Del Gobbo) [#1226](https://github.com/nodejs/node-addon-api/pull/1226)\n* \\[[`e9db2adef2`](https://github.com/nodejs/node-addon-api/commit/e9db2adef2)] - **test**: Add test coverage to TSFN::New() overloads (#1201) (Jack)\n* \\[[`c849ad3f6a`](https://github.com/nodejs/node-addon-api/commit/c849ad3f6a)] - **chore**: fix stale workflow (#1228) (Richard Lau)\n* \\[[`e408804ad8`](https://github.com/nodejs/node-addon-api/commit/e408804ad8)] - **test**: adding ref for threadsafefunctions (JckXia) [#1222](https://github.com/nodejs/node-addon-api/pull/1222)\n* \\[[`a8afb2d73c`](https://github.com/nodejs/node-addon-api/commit/a8afb2d73c)] - **src**: remove TypedArray::unknown\\_array\\_type (Kevin Eady) [#1209](https://github.com/nodejs/node-addon-api/pull/1209)\n* \\[[`257a52f823`](https://github.com/nodejs/node-addon-api/commit/257a52f823)] - **test**: Add test cased for failed task cancellations (#1214) (Jack)\n* \\[[`793268c59f`](https://github.com/nodejs/node-addon-api/commit/793268c59f)] - **test**: Add test case for canceling async worker tasks (#1202) (Jack)\n* \\[[`1331856ef1`](https://github.com/nodejs/node-addon-api/commit/1331856ef1)] - **doc**: add HandleScope example (#1210) (Kevin Eady)\n* \\[[`d5fc875e5d`](https://github.com/nodejs/node-addon-api/commit/d5fc875e5d)] - **test**: remove update to process.config (#1208) (Michael Dawson)\n* \\[[`30cd4a37f0`](https://github.com/nodejs/node-addon-api/commit/30cd4a37f0)] - **test**: add tests for .Data method (JckXia) [#1203](https://github.com/nodejs/node-addon-api/pull/1203)\n* \\[[`225ca35963`](https://github.com/nodejs/node-addon-api/commit/225ca35963)] - **test**: Add test coverage for \"TSFN::Ref()\" (#1196) (Jack)\n* \\[[`5a5a213985`](https://github.com/nodejs/node-addon-api/commit/5a5a213985)] - Update CI component versions (#1200) (Vladimir Morozov)\n* \\[[`fb27e72b0c`](https://github.com/nodejs/node-addon-api/commit/fb27e72b0c)] - **doc**: Update CONTRIBUTING.md (Saint Gabriel) [#1185](https://github.com/nodejs/node-addon-api/pull/1185)\n* \\[[`e9def3ed72`](https://github.com/nodejs/node-addon-api/commit/e9def3ed72)] - **doc**: Update Readme for filter conditions in unit tests (Deepak Rajamohan) [#1199](https://github.com/nodejs/node-addon-api/pull/1199)\n* \\[[`efd67876e1`](https://github.com/nodejs/node-addon-api/commit/efd67876e1)] - **doc**: updated npm script for focused tests (Peter Šándor)\n* \\[[`134961d853`](https://github.com/nodejs/node-addon-api/commit/134961d853)] - **test**: CallbackInfo NewTarget() basic coverage (#1048) (Peter Šándor)\n* \\[[`1dfd03bdd5`](https://github.com/nodejs/node-addon-api/commit/1dfd03bdd5)] - Update README.md (#1187) (Saint Gabriel)\n* \\[[`576128fd19`](https://github.com/nodejs/node-addon-api/commit/576128fd19)] - **doc**: fix typo in async\\_operations.md (#1189) (Tobias Nießen)\n* \\[[`63d3c30ec1`](https://github.com/nodejs/node-addon-api/commit/63d3c30ec1)] - **test**: add tests for TypedArray (Dante Calderon) [#1179](https://github.com/nodejs/node-addon-api/pull/1179)\n* \\[[`358ac2f080`](https://github.com/nodejs/node-addon-api/commit/358ac2f080)] - Fix link to CMake.js documentation (#1180) (Kyle Kovacs)\n* \\[[`dc4f2bbe4a`](https://github.com/nodejs/node-addon-api/commit/dc4f2bbe4a)] - **test**: Add promise unit test (#1173) (Jenny)\n* \\[[`f3124ae0ed`](https://github.com/nodejs/node-addon-api/commit/f3124ae0ed)] - **doc**: fix broken `Napi::ThreadSafeFunction` link (#1172) (Feng Yu)\n* \\[[`10b440fe27`](https://github.com/nodejs/node-addon-api/commit/10b440fe27)] - **src**: reformat all code (Kevin Eady) [#1160](https://github.com/nodejs/node-addon-api/pull/1160)\n* \\[[`33e402971e`](https://github.com/nodejs/node-addon-api/commit/33e402971e)] - **test**: Add condition for window to find eslint (#1176) (Jack)\n* \\[[`d53843b83b`](https://github.com/nodejs/node-addon-api/commit/d53843b83b)] - **test**: add missing value tests (JckXia) [#1170](https://github.com/nodejs/node-addon-api/pull/1170)\n\n## 2022-05-02 Version 5.0.0, @NickNaso\n\n### Notable changes:\n\n#### API\n- Marked methods of wrapper classes `const`.\n- Enabled wrapping `Napi` namespace with custom namespace.\n- Added an override to `Napi::Function::Call` to call it with a c-style array\nof `Napi::Value`'s.\n- Some other minor fixes.\n\n#### TEST\n\n- Improved the test framework. Added the possibility to run subsets of tests\nmore easily.\n- Added test for `Napi::AsyncContext` class.\n- Fixed ramdom failure on test for `Napi::ThreadSafeFunction` e\n`Napi::TypedThreadSafeFunction` class.\n- Fixed compilation problem on debian 8 system.\n- Added test for `Napi::Object::Set()` method.\n\n### Documentation\n- Added some clarifications for `Napi::ClassPropertyDescriptor`.\n- Added clarification about weak reference for `Napi::ObjectWrap`.\n- Some minor fixes all over the documentation.\n\n### TOOL\n\n- Fixed `eslint` configuration.\n- Fixed CI configuration for Windows.\n- Enabled pre-commit `ClangFormat` on Windows.\n\n### Commits\n\n* \\[[`f32db917f3`](https://github.com/nodejs/node-addon-api/commit/f32db917f3)] - Add test coverage for async contexts (#1164) (Jack)\n* \\[[`24455f88af`](https://github.com/nodejs/node-addon-api/commit/24455f88af)] - **src**: check for tsfn in conditional\\_variable wait (Kevin Eady) [#1168](https://github.com/nodejs/node-addon-api/pull/1168)\n* \\[[`40ed7ce409`](https://github.com/nodejs/node-addon-api/commit/40ed7ce409)] - **src**: fix regression introduced by #874 (Michael Dawson)\n* \\[[`9bea434326`](https://github.com/nodejs/node-addon-api/commit/9bea434326)] - **doc**: added some comments to ClassPropertyDescriptor. (#1149) (Nicola Del Gobbo)\n* \\[[`57c212e15f`](https://github.com/nodejs/node-addon-api/commit/57c212e15f)] - **buld**: Enable running pre-commit ClangFormat on Win (Vladimir Morozov)\n* \\[[`8c46a9501a`](https://github.com/nodejs/node-addon-api/commit/8c46a9501a)] - **doc**: clarify ObjectWrap weak ref behavior (#1155) (Alba Mendez)\n* \\[[`01274966d5`](https://github.com/nodejs/node-addon-api/commit/01274966d5)] - **build**: run Windows CI only on nondeprecated build configurations (#1152) (Darshan Sen)\n* \\[[`b8449e17e0`](https://github.com/nodejs/node-addon-api/commit/b8449e17e0)] - **src**: mark methods of wrapper classes const (Nikolai Vavilov) [#874](https://github.com/nodejs/node-addon-api/pull/874)\n* \\[[`5e2c1f24f8`](https://github.com/nodejs/node-addon-api/commit/5e2c1f24f8)] - **lint**: set sourceType to 'script' (#1141) (Anna Henningsen)\n* \\[[`da8af20152`](https://github.com/nodejs/node-addon-api/commit/da8af20152)] - **doc**: mention Napi::Env arg for Finalization callback (#1139) (extremeheat)\n* \\[[`5b51864a39`](https://github.com/nodejs/node-addon-api/commit/5b51864a39)] - **src**: enable wrapping Napi namespace with custom namespace (#1135) (Anna Henningsen)\n* \\[[`c54aeef5fd`](https://github.com/nodejs/node-addon-api/commit/c54aeef5fd)] - Add Function::Call Napi::Value override (#1026) (rgerd)\n* \\[[`e906b5a7ce`](https://github.com/nodejs/node-addon-api/commit/e906b5a7ce)] - **test**: fix compilation problem on debian 8 (NickNaso) [#1138](https://github.com/nodejs/node-addon-api/pull/1138)\n* \\[[`5790c55784`](https://github.com/nodejs/node-addon-api/commit/5790c55784)] - **src**: do not use non-static class member for constant value (#1134) (Anna Henningsen)\n* \\[[`b7659db945`](https://github.com/nodejs/node-addon-api/commit/b7659db945)] - Merge pull request #1130 from meixg/main (Jack)\n* \\[[`a840d51d21`](https://github.com/nodejs/node-addon-api/commit/a840d51d21)] - Add test case for Object Set using uint32 as key (meixg)\n* \\[[`2c88a7ec4c`](https://github.com/nodejs/node-addon-api/commit/2c88a7ec4c)] - Merge pull request #1132 from JckXia/test-wfl-run (Jack)\n* \\[[`d3a5ed3869`](https://github.com/nodejs/node-addon-api/commit/d3a5ed3869)] - _**Revert**_ \"window CI to running on 2019\" (JckXia)\n* \\[[`cee899ade5`](https://github.com/nodejs/node-addon-api/commit/cee899ade5)] - **src**: allow customization of ObjectWrap behavior (Aaron Meriwether) [#1125](https://github.com/nodejs/node-addon-api/pull/1125)\n* \\[[`91879b4082`](https://github.com/nodejs/node-addon-api/commit/91879b4082)] - remove window-latest to debug (JckXia)\n* \\[[`1593ef46ee`](https://github.com/nodejs/node-addon-api/commit/1593ef46ee)] - Testing CI run (JckXia)\n* \\[[`744c8d2410`](https://github.com/nodejs/node-addon-api/commit/744c8d2410)] - **test**: enhance the test framework (Deepak Rajamohan)\n\n## 2022-01-21 Version 4.3.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Added iterator for `Napi::Object`.\n- Fixed usage of `napi_extended_error_info` in `Napi::Error::New()`.\n- Added unwrapping logic to handle graceful error handling for primitives.\n\n#### TEST\n\n- Removed travis config.\n- Updated compiler used for testing.\n- Added BigInt value test.\n- Minor fixes all overtest suite.\n\n### Documentation\n\n- Documentation of iterator for `Napi::Object`.\n- Minor fixes all over documentation.\n\n### Commits\n\n* [[`7046834305`](https://github.com/nodejs/node-addon-api/commit/7046834305)] - Update to use recent version of stale action (Michael Dawson)\n* [[`293c7327ad`](https://github.com/nodejs/node-addon-api/commit/293c7327ad)] - Merge pull request #1075 from JckXia/handle-error-thrown (Jack)\n* [[`706b19986d`](https://github.com/nodejs/node-addon-api/commit/706b19986d)] - **test**: create tools/eslint-format (Doni Rubiagatra) [#1080](https://github.com/nodejs/node-addon-api/pull/1080)\n* [[`e0567d098a`](https://github.com/nodejs/node-addon-api/commit/e0567d098a)] - Update documents (JckXia)\n* [[`691813842e`](https://github.com/nodejs/node-addon-api/commit/691813842e)] - Refactor code. Using hard coded string instead of using symbol (JckXia)\n* [[`7423cc5025`](https://github.com/nodejs/node-addon-api/commit/7423cc5025)] - Update object\\_wrap.md (#1094) (Alexander Floh)\n* [[`5aab27e6e1`](https://github.com/nodejs/node-addon-api/commit/5aab27e6e1)] - **doc**: add blurb about SetInstanceData (Gabriel Schulhof)\n* [[`e439222fe6`](https://github.com/nodejs/node-addon-api/commit/e439222fe6)] - **test**: add bigint value test (WenheLI) [#1096](https://github.com/nodejs/node-addon-api/pull/1096)\n* [[`0dfa89f4ef`](https://github.com/nodejs/node-addon-api/commit/0dfa89f4ef)] - **doc**: document object iterators (#1090) (Darshan Sen)\n* [[`04b26a9d9b`](https://github.com/nodejs/node-addon-api/commit/04b26a9d9b)] - **test**: add first set of func Ref tests (JckXia) [#1035](https://github.com/nodejs/node-addon-api/pull/1035)\n* [[`a0b3fe9197`](https://github.com/nodejs/node-addon-api/commit/a0b3fe9197)] - Replace magic value with symbol (JckXia)\n* [[`173c5bc9d9`](https://github.com/nodejs/node-addon-api/commit/173c5bc9d9)] - Update PR based on review comments (JckXia)\n* [[`02bcfbccfd`](https://github.com/nodejs/node-addon-api/commit/02bcfbccfd)] - Update doc and appending GUID to object property (JckXia)\n* [[`c89f0bfb0b`](https://github.com/nodejs/node-addon-api/commit/c89f0bfb0b)] - Remove un-necessary comment/iostream and updated docs to reflect on limitations with this impl (JckXia)\n* [[`ed4d1c51c4`](https://github.com/nodejs/node-addon-api/commit/ed4d1c51c4)] - Added unwrapping logic to handle graceful error handling for primitives (JckXia)\n* [[`4663453eae`](https://github.com/nodejs/node-addon-api/commit/4663453eae)] - **src**: fix usage of `napi_extended_error_info` in `Error::New()` (Darshan Sen) [#1092](https://github.com/nodejs/node-addon-api/pull/1092)\n* [[`cb228418e6`](https://github.com/nodejs/node-addon-api/commit/cb228418e6)] - **doc**: fix typo in TypedThreadSafeFunction example (#1083) (Tobias Nießen)\n* [[`b70acdda1f`](https://github.com/nodejs/node-addon-api/commit/b70acdda1f)] - **test**: remove travis config (#1082) (Michael Dawson)\n* [[`1404b7cbea`](https://github.com/nodejs/node-addon-api/commit/1404b7cbea)] - **test**: update compiler used for testing (#1079) (Michael Dawson)\n* [[`4351bffd53`](https://github.com/nodejs/node-addon-api/commit/4351bffd53)] - **doc**: fixup to meet lint rules (Michael Dawson) [#1077](https://github.com/nodejs/node-addon-api/pull/1077)\n* [[`bd8f6e6d1a`](https://github.com/nodejs/node-addon-api/commit/bd8f6e6d1a)] - **src**: add iterator for Object (Darshan Sen)\n* [[`d8fc7b869a`](https://github.com/nodejs/node-addon-api/commit/d8fc7b869a)] - **lint**: add eslint based on config-semistandard (#1067) (Doni Rubiagatra)\n\n## 2021-09-17 Version 4.2.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Allow creating Function with move-only functor.\n- Fixed casts to not be undefined behavior.\n\n#### TEST\n\n- Fixed the way to enable C++ exceptions.\n- Run tests with options to prefix build root path.\n\n### Documentation\n\n- Fixed documentation about how to enable C++ exception.\n- Minor fixes all over documentation.\n\n### Commits\n\n* [[`2dc1f5b66c`](https://github.com/nodejs/node-addon-api/commit/2dc1f5b66c)] - Merge pull request #1065 from strager/move-only-functor (Nicola Del Gobbo)\n* [[`2b57a4aa4c`](https://github.com/nodejs/node-addon-api/commit/2b57a4aa4c)] - **src**: fix casts to not be undefined behavior (Anna Henningsen) [#1070](https://github.com/nodejs/node-addon-api/pull/1070)\n* [[`76de4d8222`](https://github.com/nodejs/node-addon-api/commit/76de4d8222)] - **docs**: fix typos (#1068) (todoroff)\n* [[`22a2f3c926`](https://github.com/nodejs/node-addon-api/commit/22a2f3c926)] - **docs**: fix typo and formatting (#1062) (strager)\n* [[`62b666c34c`](https://github.com/nodejs/node-addon-api/commit/62b666c34c)] - **test**: run tests with opts to prefix bld root path (Deepak Rajamohan) [#1055](https://github.com/nodejs/node-addon-api/pull/1055)\n* [[`cbac3aac5d`](https://github.com/nodejs/node-addon-api/commit/cbac3aac5d)] - **test**: standardize unit test file names (Deepak Rajamohan) [#1056](https://github.com/nodejs/node-addon-api/pull/1056)\n* [[`3e5897a78b`](https://github.com/nodejs/node-addon-api/commit/3e5897a78b)] - **src,test**: allow creating Function with move-only functor (Matthew \"strager\" Glazar)\n* [[`da2e754a02`](https://github.com/nodejs/node-addon-api/commit/da2e754a02)] - **test**: fix errors reported by newer compiler (Michael Dawson)\n* [[`9aaf3b1324`](https://github.com/nodejs/node-addon-api/commit/9aaf3b1324)] - **doc**: fix documentation about how to enable C++ exception (#1059) (Nicola Del Gobbo) [#1059](https://github.com/nodejs/node-addon-api/pull/1059)\n* [[`b2f861987f`](https://github.com/nodejs/node-addon-api/commit/b2f861987f)] - **test**: fixed the way to enable C++ exceptions. (#1061) (Nicola Del Gobbo) [#1061](https://github.com/nodejs/node-addon-api/pull/1061)\n\n## 2021-08-25 Version 4.1.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- `Napi::Reference` updated the default value to reflect the most possible\nvalues when there are any errors occurred on `napi_reference_unref`.\n- Added the check for nullpointer on `Napi::String` initialization.\n- Added the wraps for `napi_add_env_cleanup_hook` and\n`napi_remove_env_cleanup_hook`.\n- Added `Napi::Maybe<T>` class to handle pending exception when cpp exception\ndisabled.\n\n#### TEST\n\n- Added first set of tests for `Napi::Symbol`.\n- Updated test suite to avoid parallel running.\n\n### Documentation\n\n- Updated example for context sensitivity.\n\n### Commits\n\n* [[`3615041423`](https://github.com/nodejs/node-addon-api/commit/3615041423)] - **src**: return Maybe on pending exception when cpp exception disabled (legendecas) [#927](https://github.com/nodejs/node-addon-api/pull/927)\n* [[`10564a43c6`](https://github.com/nodejs/node-addon-api/commit/10564a43c6)] - **src**: add AddCleanupHook (Kevin Eady) [#1014](https://github.com/nodejs/node-addon-api/pull/1014)\n* [[`a459f5cc8f`](https://github.com/nodejs/node-addon-api/commit/a459f5cc8f)] - **doc**: update tests to avoid running in parallel (Michael Dawson) [#1024](https://github.com/nodejs/node-addon-api/pull/1024)\n* [[`6697c51d1d`](https://github.com/nodejs/node-addon-api/commit/6697c51d1d)] - **src,test**: fix up null char \\* exception thrown (Gabriel Schulhof) [#1019](https://github.com/nodejs/node-addon-api/pull/1019)\n* [[`e02e8a4ce3`](https://github.com/nodejs/node-addon-api/commit/e02e8a4ce3)] - **test**: add  first set of symbol tests (JckXia) [#972](https://github.com/nodejs/node-addon-api/pull/972)\n* [[`da50b51398`](https://github.com/nodejs/node-addon-api/commit/da50b51398)] - **test**: dd check for nullptr inside String init (JckXia) [#1015](https://github.com/nodejs/node-addon-api/pull/1015)\n* [[`627dbf3c37`](https://github.com/nodejs/node-addon-api/commit/627dbf3c37)] - **doc**: update examples for context sensitivity (Kevin Eady) [#1013](https://github.com/nodejs/node-addon-api/pull/1013)\n* [[`37a9b8e753`](https://github.com/nodejs/node-addon-api/commit/37a9b8e753)] - **src**: set default return value of Reference Ref/Unref to 0 (legendecas) [#1004](https://github.com/nodejs/node-addon-api/pull/1004)\n\n## 2021-06-15 Version 4.0.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Fixed a crashing issue in `Napi::Error::ThrowAsJavaScriptException`\nintroducing the preprocessor directive `NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS`.\n- Fixed compilation problem for GCC 11 and C++20.\n\n#### TEST\n\n- Added test for function reference call and contructor.\n\n### Documentation\n\n- Updated the oldest Node.js version supported from `10.x` to `12.x`.\n\n### Commits\n\n* [[`028107f686`](https://github.com/nodejs/node-addon-api/commit/028107f686)] - **src**: fix Error::ThrowAsJavaScriptException crash (rudolftam) [#975](https://github.com/nodejs/node-addon-api/pull/975)\n* [[`fed13534c5`](https://github.com/nodejs/node-addon-api/commit/fed13534c5)] - **src**: fix gcc-11 c++20 compilation (Kevin Eady) [#1009](https://github.com/nodejs/node-addon-api/pull/1009)\n* [[`b75afc4d29`](https://github.com/nodejs/node-addon-api/commit/b75afc4d29)] - **test**: function reference call & construct (legendecas) [#1005](https://github.com/nodejs/node-addon-api/pull/1005)\n\n## 2021-05-28 Version 3.2.1, @NickNaso\n\n### Notable changes:\n\n#### Documentation\n\n- Fixed documentation about the oldest Node.js version supported.\n\n### Commits\n\n* [[`6d41ee5a3a`](https://github.com/nodejs/node-addon-api/commit/6d41ee5a3a)] - Fixed readme for new release. (NickNaso)\n\n## 2021-05-17 Version 3.2.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Remove unnecessary symbol exposure.\n- Fixed leak in `Napi::ObjectWrap` instance for getter and setter method.\n- Added `Napi::Object::Freeze` and `Napi::object::Seal` methods.\n- `Napi::Reference` is now copyable.\n\n#### Documentation\n\n- Added docuemtnation for `Napi::Object::PropertyLValue`.\n- Changed all N-API references to Node-API.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Added tests relating to fetch property from Global Object.\n- Added addtiona tests for `Napi::Object`.\n- Added test for `Napi::Function` contructors.\n- Fixed intermittent failure for `Napi::ThreadSafeFunction` test.\n- Some minor corrections all over the test suite.\n\n### TOOL\n\n- Added Node.js v16.x to CI.\n- Added CI configuration for Windows.\n- Some fixex on linter command.\n\n### Commits\n\n* [[`52721312f6`](https://github.com/nodejs/node-addon-api/commit/52721312f6)] - **docs**: add napi-rs iin Other Bindings section (#999) (LongYinan)\n* [[`78a6570a42`](https://github.com/nodejs/node-addon-api/commit/78a6570a42)] - **doc**: fix typo in code example (#997) (Tobias Nießen)\n* [[`da3bd5778f`](https://github.com/nodejs/node-addon-api/commit/da3bd5778f)] - **test**: fix undoc assumptions about the timing of tsfn calls (legendecas) [#995](https://github.com/nodejs/node-addon-api/pull/995)\n* [[`410cf6a81e`](https://github.com/nodejs/node-addon-api/commit/410cf6a81e)] - **src**: return bool on object freeze and seal (#991) (legendecas)\n* [[`93f1898312`](https://github.com/nodejs/node-addon-api/commit/93f1898312)] - **src**: return bool on object set and define property (#977) (legendecas)\n* [[`331c2ee274`](https://github.com/nodejs/node-addon-api/commit/331c2ee274)] - **build**: add Node.js v16.x to CI (#983) (legendecas)\n* [[`b6f5eb15e6`](https://github.com/nodejs/node-addon-api/commit/b6f5eb15e6)] - **test**: run test suites with helpers (legendecas) [#976](https://github.com/nodejs/node-addon-api/pull/976)\n* [[`fbcdf00ea0`](https://github.com/nodejs/node-addon-api/commit/fbcdf00ea0)] - **test**: rename misspelled parameters (Tobias Nießen) [#973](https://github.com/nodejs/node-addon-api/pull/973)\n* [[`63a6c32e80`](https://github.com/nodejs/node-addon-api/commit/63a6c32e80)] - **test**: fix intermittent TSFN crashes (Kevin Eady) [#974](https://github.com/nodejs/node-addon-api/pull/974)\n* [[`8f120b033f`](https://github.com/nodejs/node-addon-api/commit/8f120b033f)] - **fix**: key for wapping drawing's system condition (#970) (Kévin VOYER)\n* [[`1c9d528d66`](https://github.com/nodejs/node-addon-api/commit/1c9d528d66)] - **doc**: correct struct definition (#969) (Darshan Sen)\n* [[`5e64d1fa61`](https://github.com/nodejs/node-addon-api/commit/5e64d1fa61)] - Added badges for Node-API v7 and v8. (#954) (Nicola Del Gobbo)\n* [[`6ce629b3fa`](https://github.com/nodejs/node-addon-api/commit/6ce629b3fa)] - **src**: add pull request template (#967) (Michael Dawson)\n* [[`98126661af`](https://github.com/nodejs/node-addon-api/commit/98126661af)] - Update CONTRIBUTING.md (#966) (Michael Dawson)\n* [[`77350eee98`](https://github.com/nodejs/node-addon-api/commit/77350eee98)] - **src**: added Freeze and Seal method to Object class. (NickNaso) [#955](https://github.com/nodejs/node-addon-api/pull/955)\n* [[`bc5147cc4a`](https://github.com/nodejs/node-addon-api/commit/bc5147cc4a)] - Finished tests relating to fetch property from Global Object (JckXia)\n* [[`0127813111`](https://github.com/nodejs/node-addon-api/commit/0127813111)] - **doc**: unambiguously mark deprecated signatures (Tobias Nießen) [#942](https://github.com/nodejs/node-addon-api/pull/942)\n* [[`787e216105`](https://github.com/nodejs/node-addon-api/commit/787e216105)] - **doc**: rename N-API with Node-API (Darshan Sen) [#951](https://github.com/nodejs/node-addon-api/pull/951)\n* [[`628023689a`](https://github.com/nodejs/node-addon-api/commit/628023689a)] - **src**: rename N-API with Node-API on comments (NickNaso) [#953](https://github.com/nodejs/node-addon-api/pull/953)\n* [[`5c6391578f`](https://github.com/nodejs/node-addon-api/commit/5c6391578f)] - **build**: add CI configuration for Windows (NickNaso) [#948](https://github.com/nodejs/node-addon-api/pull/948)\n* [[`8ef07251ec`](https://github.com/nodejs/node-addon-api/commit/8ef07251ec)] - **doc**: added some warnings for buffer and array buffer factory method. (#929) (Nicola Del Gobbo)\n* [[`6490b1f730`](https://github.com/nodejs/node-addon-api/commit/6490b1f730)] - **doc**: sync Object::Set value arg with Value::From (#933) (Tobias Nießen)\n* [[`7319a0d7a2`](https://github.com/nodejs/node-addon-api/commit/7319a0d7a2)] - Fix tab indent (#938) (Tobias Nießen)\n* [[`1916cb937e`](https://github.com/nodejs/node-addon-api/commit/1916cb937e)] - **chore**: fixup linter commands (#940) (legendecas)\n* [[`fc4585fa23`](https://github.com/nodejs/node-addon-api/commit/fc4585fa23)] - **test**: dd tests for Function constructors (JoseExposito) [#937](https://github.com/nodejs/node-addon-api/pull/937)\n* [[`87b7aae469`](https://github.com/nodejs/node-addon-api/commit/87b7aae469)] - **doc**: warn about SuppressDestruct() (#926) (Anna Henningsen)\n* [[`71494a49a3`](https://github.com/nodejs/node-addon-api/commit/71494a49a3)] - **src,doc**: refactor to replace typedefs with usings (Darshan Sen) [#910](https://github.com/nodejs/node-addon-api/pull/910)\n* [[`298ff8d9d2`](https://github.com/nodejs/node-addon-api/commit/298ff8d9d2)] - **test**: add additional tests for Object (JoseExposito) [#923](https://github.com/nodejs/node-addon-api/pull/923)\n* [[`8a1147b430`](https://github.com/nodejs/node-addon-api/commit/8a1147b430)] - **revert**: src: add additional tests for Function (Michael Dawson)\n* [[`bb56ffaa6f`](https://github.com/nodejs/node-addon-api/commit/bb56ffaa6f)] - **doc**: fix documentation for object api (Nicola Del Gobbo) [#931](https://github.com/nodejs/node-addon-api/pull/931)\n* [[`3b8bddab49`](https://github.com/nodejs/node-addon-api/commit/3b8bddab49)] - **src**: add additional tests for Function (José Expósito) [#928](https://github.com/nodejs/node-addon-api/pull/928)\n* [[`74ab50c775`](https://github.com/nodejs/node-addon-api/commit/74ab50c775)] - **src**: allow references to be copyable in APIs (legendecas) [#915](https://github.com/nodejs/node-addon-api/pull/915)\n* [[`929709d0fe`](https://github.com/nodejs/node-addon-api/commit/929709d0fe)] - **doc**: add propertylvalue.md (#925) (Gabriel Schulhof)\n* [[`69d0d98be4`](https://github.com/nodejs/node-addon-api/commit/69d0d98be4)] - fixup (Anna Henningsen)\n* [[`46e41d961b`](https://github.com/nodejs/node-addon-api/commit/46e41d961b)] - fixup (Anna Henningsen)\n* [[`1af1642fb7`](https://github.com/nodejs/node-addon-api/commit/1af1642fb7)] - **doc**: warn about SuppressDestruct() (Anna Henningsen)\n* [[`12c548b2ff`](https://github.com/nodejs/node-addon-api/commit/12c548b2ff)] - **tools**: fix error detection (#914) (Darshan Sen)\n* [[`458d895d5b`](https://github.com/nodejs/node-addon-api/commit/458d895d5b)] - **packaging**: list files to be published to npm (Lovell Fuller) [#889](https://github.com/nodejs/node-addon-api/pull/889)\n* [[`f7ed2490d4`](https://github.com/nodejs/node-addon-api/commit/f7ed2490d4)] - **test**: remove outdated V8 flag (Darshan Sen) [#895](https://github.com/nodejs/node-addon-api/pull/895)\n* [[`a575a6ec60`](https://github.com/nodejs/node-addon-api/commit/a575a6ec60)] - **src**: fix leak in ObjectWrap instance set/getters (Kevin Eady) [#899](https://github.com/nodejs/node-addon-api/pull/899)\n* [[`b6e844e0b0`](https://github.com/nodejs/node-addon-api/commit/b6e844e0b0)] - **doc**: fix spelling of \"targeted\" and \"targeting\" (#904) (Tobias Nießen)\n* [[`4d856f6e91`](https://github.com/nodejs/node-addon-api/commit/4d856f6e91)] - **src**: remove unnecessary symbol exposure (Gabriel Schulhof) [#896](https://github.com/nodejs/node-addon-api/pull/896)\n* [[`f35bb7d0d7`](https://github.com/nodejs/node-addon-api/commit/f35bb7d0d7)] - **doc**: Update GitHub URL references from 'master' to 'HEAD' (#898) (Jim Schlight)\n* [[`286ae215d1`](https://github.com/nodejs/node-addon-api/commit/286ae215d1)] - Add warning about branch rename (Michael Dawson)\n* [[`a4a7b28288`](https://github.com/nodejs/node-addon-api/commit/a4a7b28288)] - Update branch references from master to main (#886) (Jim Schlight)\n* [[`a2ad0a107a`](https://github.com/nodejs/node-addon-api/commit/a2ad0a107a)] - **docs**: add NAN to N-API resource link (#880) (kidneysolo)\n* [[`1c040eeb63`](https://github.com/nodejs/node-addon-api/commit/1c040eeb63)] - **test**: load testModules automatically (raisinten) [#876](https://github.com/nodejs/node-addon-api/pull/876)\n* [[`bf478e4496`](https://github.com/nodejs/node-addon-api/commit/bf478e4496)] - **src**: use NAPI\\_NOEXCEPT macro instead of noexcept (NickNaso) [#864](https://github.com/nodejs/node-addon-api/pull/864)\n* [[`744705f2eb`](https://github.com/nodejs/node-addon-api/commit/744705f2eb)] - **test**: refactor remove repeated execution index.js (raisinten) [#839](https://github.com/nodejs/node-addon-api/pull/839)\n* [[`db62e3c811`](https://github.com/nodejs/node-addon-api/commit/db62e3c811)] - Update team members (Michael Dawson)\n\n## 2020-12-17 Version 3.1.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Added `Napi::TypedThreadSafeFunction` class that is a new implementation for\nthread-safe functions.\n- Fixed leak on `Napi::AsyncProgressWorkerBase`.\n- Fixed empty data on `Napi::AsyncProgressWorker::OnProgress` caused by race\nconditions of `Napi::AsyncProgressWorker`.\n- Added `Napi::ArrayBuffer::Detach()` and `Napi::ArrayBuffer::IsDetached()`.\n- Fixed problem on `Napi::FinalizeCallback` it needs to create a\n`Napi::HandleScope` when it calls `Napi::ObjectWrap::~ObjectWrap()`.\n\n#### Documentation\n\n- Added documentation for `Napi::TypedThreadSafeFunction`.\n- Removed unsued Doxygen file.\n- Clarified when to use N-API.\n- Added support information.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Added test for `Napi::TypedThreadSafeFunction`.\n- Fixed testing for specific N-API version.\n- Some minor corrections all over the test suite.\n\n### TOOL\n\n- Setup github actions for tests.\n- Added stale action.\n- Removed `sudo` tag from Travis CI.\n- Added clang-format.\n- Added pre-commit package for linting.\n\n### Commits\n\n* [[`ff642c5b85`](https://github.com/nodejs/node-addon-api/commit/ff642c5b85)] - **doc**: fix tsfn docs to reflect true implementation (#860) (Kevin Eady)\n* [[`86feeebf54`](https://github.com/nodejs/node-addon-api/commit/86feeebf54)] - **src**: empty data OnProgress in AsyncProgressWorker (legendecas) [#853](https://github.com/nodejs/node-addon-api/pull/853)\n* [[`a7fb5fb31c`](https://github.com/nodejs/node-addon-api/commit/a7fb5fb31c)] - **action**: add stale action (#856) (Michael Dawson)\n* [[`fd44609885`](https://github.com/nodejs/node-addon-api/commit/fd44609885)] - **chore**: setup github actions for tests (#854) (legendecas) [#854](https://github.com/nodejs/node-addon-api/pull/854)\n* [[`c52ace4813`](https://github.com/nodejs/node-addon-api/commit/c52ace4813)] - **script**: fix complains that js files are not supported on npm run lint:fix (#852) (legendecas)\n* [[`b4a3364ad5`](https://github.com/nodejs/node-addon-api/commit/b4a3364ad5)] - **doc**: remove unused Doxygen file (#851) (Michael Dawson)\n* [[`b810466ae2`](https://github.com/nodejs/node-addon-api/commit/b810466ae2)] - **doc**: clarify when to use N-API (#849) (Michael Dawson)\n* [[`528b9f6832`](https://github.com/nodejs/node-addon-api/commit/528b9f6832)] - **test**: remove sudo from travis (#850) (Michael Dawson)\n* [[`4bb680de4e`](https://github.com/nodejs/node-addon-api/commit/4bb680de4e)] - Remove misleading sentence (#847) (Nikolai Vavilov) [#847](https://github.com/nodejs/node-addon-api/pull/847)\n* [[`48e6b584a3`](https://github.com/nodejs/node-addon-api/commit/48e6b584a3)] - Merge pull request #742 from KevinEady/contexted-tsfn-api-gcc-4 (Gabriel Schulhof)\n* [[`d5e37210cc`](https://github.com/nodejs/node-addon-api/commit/d5e37210cc)] - **tools**: print more instructions on clang-format check failed (#846) (legendecas) [#846](https://github.com/nodejs/node-addon-api/pull/846)\n* [[`d9e11ff2c9`](https://github.com/nodejs/node-addon-api/commit/d9e11ff2c9)] - **doc**: add support info (#843) (Michael Dawson) [#843](https://github.com/nodejs/node-addon-api/pull/843)\n* [[`356e93d69a`](https://github.com/nodejs/node-addon-api/commit/356e93d69a)] - **test**: fixup testing for specific N-API version (#840) (Michael Dawson) [#840](https://github.com/nodejs/node-addon-api/pull/840)\n* [[`5e5b9ce1b7`](https://github.com/nodejs/node-addon-api/commit/5e5b9ce1b7)] - Apply formatting changes (Kevin Eady)\n* [[`559ad8c0c0`](https://github.com/nodejs/node-addon-api/commit/559ad8c0c0)] - Merge remote-tracking branch 'upstream/master' into contexted-tsfn-api-gcc-4 (Kevin Eady)\n* [[`c24c455ced`](https://github.com/nodejs/node-addon-api/commit/c24c455ced)] - Rename to TypedThreadSafeFunction (Kevin Eady)\n* [[`63b43f4125`](https://github.com/nodejs/node-addon-api/commit/63b43f4125)] - **test**: fix buildType bug objectwrap\\_worker\\_thread (raisinten) [#837](https://github.com/nodejs/node-addon-api/pull/837)\n* [[`6321f2ba1a`](https://github.com/nodejs/node-addon-api/commit/6321f2ba1a)] - **test**: fix typos in addon\\_build/index.js (raisinten) [#838](https://github.com/nodejs/node-addon-api/pull/838)\n* [[`59c6a6aeb0`](https://github.com/nodejs/node-addon-api/commit/59c6a6aeb0)] - **fix**: git-clang-format doesn't recognize no changes requested on given files (#835) (legendecas)\n* [[`1427b3ef78`](https://github.com/nodejs/node-addon-api/commit/1427b3ef78)] - **src**: create a HandleScope in FinalizeCallback (blagoev) [#832](https://github.com/nodejs/node-addon-api/pull/832)\n* [[`8fb5820557`](https://github.com/nodejs/node-addon-api/commit/8fb5820557)] - **build**: add incremental clang-format checks (legendecas) [#819](https://github.com/nodejs/node-addon-api/pull/819)\n* [[`2c02d317e5`](https://github.com/nodejs/node-addon-api/commit/2c02d317e5)] - **build**: add pre-commit package for linting (#823) (Kevin Eady)\n* [[`1b52c28eb8`](https://github.com/nodejs/node-addon-api/commit/1b52c28eb8)] - Clean up AsyncProgressWorker documentation (#831) (mastergberry)\n* [[`4abe7cfe30`](https://github.com/nodejs/node-addon-api/commit/4abe7cfe30)] - **test**: rename tsfnex test files (Kevin Eady)\n* [[`c9563caa25`](https://github.com/nodejs/node-addon-api/commit/c9563caa25)] - **src**: add ArrayBuffer::Detach() and ::IsDetached() (Tobias Nießen) [#659](https://github.com/nodejs/node-addon-api/pull/659)\n* [[`c79cabaed2`](https://github.com/nodejs/node-addon-api/commit/c79cabaed2)] - **doc**: avoid directing users to HTTP (#828) (Tobias Nießen)\n* [[`7a13f861ab`](https://github.com/nodejs/node-addon-api/commit/7a13f861ab)] - **doc**: fix additional typo (Kevin Eady)\n* [[`7ec9741dd2`](https://github.com/nodejs/node-addon-api/commit/7ec9741dd2)] - Merge remote-tracking branch 'upstream/master' into contexted-tsfn-api-gcc-4 (Kevin Eady)\n* [[`f5fad239fa`](https://github.com/nodejs/node-addon-api/commit/f5fad239fa)] - Update object\\_reference.md (#827) (kidneysolo)\n* [[`35b65712c2`](https://github.com/nodejs/node-addon-api/commit/35b65712c2)] - **Fix**: some typos in documentation (#826) (Helio Frota)\n* [[`8983383000`](https://github.com/nodejs/node-addon-api/commit/8983383000)] - **Fix**: some typos in the document (#825) (Ziqiu Zhao)\n* [[`826e466ef6`](https://github.com/nodejs/node-addon-api/commit/826e466ef6)] - Fixed example in addon.md. (#820) (nempoBu4) [#820](https://github.com/nodejs/node-addon-api/pull/820)\n* [[`b54f5eb788`](https://github.com/nodejs/node-addon-api/commit/b54f5eb788)] - Additional changes from review (Kevin Eady)\n* [[`59f27dac9a`](https://github.com/nodejs/node-addon-api/commit/59f27dac9a)] - Fix common.gypi (Kevin Eady)\n* [[`151a914c99`](https://github.com/nodejs/node-addon-api/commit/151a914c99)] - Apply documentation suggestions from code review (Kevin Eady)\n* [[`ceb27d4949`](https://github.com/nodejs/node-addon-api/commit/ceb27d4949)] - **src**: fix leak in AsyncProgressWorkerBase\\<DataType\\> (Ferdinand Holzer) [#795](https://github.com/nodejs/node-addon-api/pull/795)\n\n## 2020-09-18 Version 3.0.2, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Introduced `include_dir` for use with **gyp** in a scalar context.\n- Added `Napi::Addon` to help handle the loading of a native add-on into\nmultiple threads and or multiple times in the same thread.\n- Concentrate callbacks provided to core N-API.\n- Make sure wrapcallback is used.\n\n#### Documentation\n\n- Added documentation for `Napi::Addon`.\n- Added documentation that reports the full class hierarchy.\n- Added link to N-API tutorial website.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Added tests to check the build process.\n- Refactored test for threasfafe function using async/await.\n- Converted tests that gc into async functions that await 10 ticks after\neach gc.\n- Some minor corrections all over the test suite.\n\n### Commits\n\n* [[`51e25f7c39`](https://github.com/nodejs/node-addon-api/commit/51e25f7c39)] - **doc**: remove a file (#815) (Gabriel Schulhof)\n* [[`8c9f1809a2`](https://github.com/nodejs/node-addon-api/commit/8c9f1809a2)] - **doc**: add inheritance links and other changes (Gabriel Schulhof) [#798](https://github.com/nodejs/node-addon-api/pull/798)\n* [[`6562e6b0ab`](https://github.com/nodejs/node-addon-api/commit/6562e6b0ab)] - **test**: added tests to check the build process (NickNaso) [#808](https://github.com/nodejs/node-addon-api/pull/808)\n* [[`a13b36c96e`](https://github.com/nodejs/node-addon-api/commit/a13b36c96e)] - **test**: fix the threasfafe function test (NickNaso) [#807](https://github.com/nodejs/node-addon-api/pull/807)\n* [[`f27623ff61`](https://github.com/nodejs/node-addon-api/commit/f27623ff61)] - **build**: introduce include\\_dir (Lovell Fuller) [#766](https://github.com/nodejs/node-addon-api/pull/766)\n* [[`9aceea71fc`](https://github.com/nodejs/node-addon-api/commit/9aceea71fc)] - **src**: concentrate callbacks provided to core N-API (Gabriel Schulhof) [#786](https://github.com/nodejs/node-addon-api/pull/786)\n* [[`2bc45bbffd`](https://github.com/nodejs/node-addon-api/commit/2bc45bbffd)] - **test**: refactor test to use async/await (Velmisov) [#787](https://github.com/nodejs/node-addon-api/pull/787)\n* [[`518cfdcdc1`](https://github.com/nodejs/node-addon-api/commit/518cfdcdc1)] - **test**: test ObjectWrap destructor - no HandleScope (David Halls) [#729](https://github.com/nodejs/node-addon-api/pull/729)\n* [[`c2cbbd9191`](https://github.com/nodejs/node-addon-api/commit/c2cbbd9191)] - **doc**: add link to n-api tutorial website (#794) (Jim Schlight) [#794](https://github.com/nodejs/node-addon-api/pull/794)\n* [[`1c2a8d59b5`](https://github.com/nodejs/node-addon-api/commit/1c2a8d59b5)] - **doc**: Added required return to example (#793) (pacop) [#793](https://github.com/nodejs/node-addon-api/pull/793)\n* [[`cec2c76941`](https://github.com/nodejs/node-addon-api/commit/cec2c76941)] - **src**: wrap finalizer callback (Gabriel Schulhof) [#762](https://github.com/nodejs/node-addon-api/pull/762)\n* [[`4ce40d22a6`](https://github.com/nodejs/node-addon-api/commit/4ce40d22a6)] - **test**: use assert.strictEqual() (Koki Nishihara) [#777](https://github.com/nodejs/node-addon-api/pull/777)\n* [[`461e3640c6`](https://github.com/nodejs/node-addon-api/commit/461e3640c6)] - **test**: string tests together (Gabriel Schulhof) [#773](https://github.com/nodejs/node-addon-api/pull/773)\n* [[`5af645f649`](https://github.com/nodejs/node-addon-api/commit/5af645f649)] - **src**: add Addon\\<T\\> class (Gabriel Schulhof) [#749](https://github.com/nodejs/node-addon-api/pull/749)\n* [[`6148fb4bcc`](https://github.com/nodejs/node-addon-api/commit/6148fb4bcc)] - Synchronise Node.js versions in Appveyor Windows CI with Travis (#768) (Lovell Fuller)\n\n## 2020-07-13 Version 3.0.1, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Fixed the usage of `Napi::Reference` with `Napi::TypedArray`.\n- Fixed `Napi::ObjectWrap` inheritance.\n\n#### Documentation\n\n- Updated the example for `Napi::ObjectWrap`.\n- Added documentation for instance data APIs.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Fixed test for `Napi::ArrayBuffer` and `Napi::Buffer`.\n- Some minor corrections all over the test suite.\n\n### Commits\n\n* [[`40c7926342`](https://github.com/nodejs/node-addon-api/commit/40c7926342)] - **build**: ensure paths with spaces can be used (Lovell Fuller) [#757](https://github.com/nodejs/node-addon-api/pull/757)\n* [[`ef16dfb4a2`](https://github.com/nodejs/node-addon-api/commit/ef16dfb4a2)] - **doc**: update ObjectWrap example (Gabriel Schulhof) [#754](https://github.com/nodejs/node-addon-api/pull/754)\n* [[`48f6762bf6`](https://github.com/nodejs/node-addon-api/commit/48f6762bf6)] - **src**: add \\_\\_wasm32\\_\\_ guards (Gus Caplan)\n* [[`bd2c5ec502`](https://github.com/nodejs/node-addon-api/commit/bd2c5ec502)] - Fixes issue 745. (#748) (Nicola Del Gobbo)\n* [[`4c01af2d87`](https://github.com/nodejs/node-addon-api/commit/4c01af2d87)] - Fix typo in CHANGELOG (#715) (Kasumi Hanazuki)\n* [[`36e1af96d5`](https://github.com/nodejs/node-addon-api/commit/36e1af96d5)] - **src**: fix use of Reference with typed arrays (Michael Dawson) [#726](https://github.com/nodejs/node-addon-api/pull/726)\n* [[`d463f02bc7`](https://github.com/nodejs/node-addon-api/commit/d463f02bc7)] - **src**: fix testEnumerables on ObjectWrap (Ferdinand Holzer) [#736](https://github.com/nodejs/node-addon-api/pull/736)\n* [[`ba7ad37d44`](https://github.com/nodejs/node-addon-api/commit/ba7ad37d44)] - **src**: fix ObjectWrap inheritance (David Halls) [#732](https://github.com/nodejs/node-addon-api/pull/732)\n* [[`31504c862b`](https://github.com/nodejs/node-addon-api/commit/31504c862b)] - **doc**: fix minor typo in object\\_wrap.md (#741) (Daniel Bevenius) [#741](https://github.com/nodejs/node-addon-api/pull/741)\n* [[`beccf2145d`](https://github.com/nodejs/node-addon-api/commit/beccf2145d)] - **test**: fix up delays for array buffer test (Michael Dawson) [#737](https://github.com/nodejs/node-addon-api/pull/737)\n* [[`45cb1d9748`](https://github.com/nodejs/node-addon-api/commit/45cb1d9748)] - Correct AsyncProgressWorker link in README (#716) (Jeroen Janssen)\n* [[`381c0da60c`](https://github.com/nodejs/node-addon-api/commit/381c0da60c)] - **doc**: add instance data APIs (Gabriel Schulhof) [#708](https://github.com/nodejs/node-addon-api/pull/708)\n\n## 2020-04-30 Version 3.0.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- `Napi::Object` added templated property descriptors.\n- `Napi::ObjectWrap` added templated methods.\n- `Napi::ObjectWrap` the wrap is removed only on failure.\n- `Napi::ObjectWrap` the constructor's exceptions are gracefully handled.\n- `Napi::Function` added templated factory functions.\n- Added `Env::RunScript` method to run JavaScript code contained in a string.\n- Added templated version of `Napi::Function`.\n- Added benchmarking framework.\n- Added support for native addon instance data.\n- Added `Napi::AsyncProgressQueueWorker` api.\n- Changed the guards to `NAPI_VERSION > 5`.\n- Removed N-API implementation (v6.x and v8.x support).\n- `Napi::AsyncWorker::OnWorkComplete` and `Napi::AsyncWorker::OnExecute` methods\nare override-able.\n- Removed erroneous finalizer cleanup in `Napi::ThreadSafeFunction`.\n- Disabled caching in `Napi::ArrayBuffer`.\n- Explicitly disallow assign and copy operator.\n- Some minor corrections and improvements.\n\n#### Documentation\n\n- Updated documentation for `Napi::Object`.\n- Updated documentation for `Napi::Function`.\n- Updated documentation for `Napi::ObjectWrap`.\n- Added documentation on how to add benchmark.\n- Added documentation for `Napi::AsyncProgressQueueWorker`.\n- Added suggestion about tags to use on NPM.\n- Added reference to N-API badges.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Updated test cases for `Napi::Object`.\n- Updated test cases for `Napi::Function`.\n- Updated test cases for `Napi::ObjectWrap`.\n- Updated test cases for `Napi::Env`.\n- Added test cases for `Napi::AsyncProgressQueueWorker`.\n- Some minor corrections all over the test suite.\n\n### Commits\n\n* [[`187318e37f`](https://github.com/nodejs/node-addon-api/commit/187318e37f)] - **doc**: Removed references to Node.js lower than 10.x. (#709) (Nicola Del Gobbo)\n* [[`9c9accfbbe`](https://github.com/nodejs/node-addon-api/commit/9c9accfbbe)] - **src**: add support for addon instance data (Gabriel Schulhof) [#663](https://github.com/nodejs/node-addon-api/pull/663)\n* [[`82a96502a4`](https://github.com/nodejs/node-addon-api/commit/82a96502a4)] - **src**: change guards to NAPI\\_VERSION \\> 5 (Gabriel Schulhof) [#697](https://github.com/nodejs/node-addon-api/pull/697)\n* [[`a64e8a5641`](https://github.com/nodejs/node-addon-api/commit/a64e8a5641)] - **ci**: move travis from 13 to 14 (#707) (Gabriel Schulhof)\n* [[`4de23c9d6b`](https://github.com/nodejs/node-addon-api/commit/4de23c9d6b)] - **doc**: fix support bigint64/biguint64 guards (Yulong Wang) [#705](https://github.com/nodejs/node-addon-api/pull/705)\n* [[`fedc8195e3`](https://github.com/nodejs/node-addon-api/commit/fedc8195e3)] - **doc**: fix semicolon missing in async\\_worker.md (Azlan Mukhtar) [#701](https://github.com/nodejs/node-addon-api/pull/701)\n* [[`cdb662506c`](https://github.com/nodejs/node-addon-api/commit/cdb662506c)] - **doc**: fix typo in bigint.md (#700) (Kelvin)\n* [[`e1a827ae29`](https://github.com/nodejs/node-addon-api/commit/e1a827ae29)] - **src**: fix AsyncProgressQueueWorker compilation (#696) (Gabriel Schulhof) [#696](https://github.com/nodejs/node-addon-api/pull/696)\n* [[`2c3d5df463`](https://github.com/nodejs/node-addon-api/commit/2c3d5df463)] - Merge pull request #692 from kelvinhammond/patch-1 (Nicola Del Gobbo)\n* [[`623e876949`](https://github.com/nodejs/node-addon-api/commit/623e876949)] - Merge pull request #688 from NickNaso/badges (Nicola Del Gobbo)\n* [[`6c97913d1f`](https://github.com/nodejs/node-addon-api/commit/6c97913d1f)] - Fix minor typo in object\\_lifetime\\_management.md (Kelvin)\n* [[`6b8dd47c55`](https://github.com/nodejs/node-addon-api/commit/6b8dd47c55)] - Added badge section to documentation. (NickNaso)\n* [[`89e62a9154`](https://github.com/nodejs/node-addon-api/commit/89e62a9154)] - **doc**: recommend tags of addon helpers (legendecas) [#683](https://github.com/nodejs/node-addon-api/pull/683)\n* [[`ab018444ae`](https://github.com/nodejs/node-addon-api/commit/ab018444ae)] - **src**: implement AsyncProgressQueueWorker (legendecas) [#585](https://github.com/nodejs/node-addon-api/pull/585)\n* [[`d43da6ac2b`](https://github.com/nodejs/node-addon-api/commit/d43da6ac2b)] - **doc**: add @legendecas to active member list (legendecas)\n* [[`cb498bbe7f`](https://github.com/nodejs/node-addon-api/commit/cb498bbe7f)] - **doc**: Add Napi::BigInt::New() overload for uint64\\_t (ikokostya)\n* [[`baaaa8452c`](https://github.com/nodejs/node-addon-api/commit/baaaa8452c)] - **doc**: link threadsafe function from JS function (legendecas)\n* [[`7f56a78ff7`](https://github.com/nodejs/node-addon-api/commit/7f56a78ff7)] - **objectwrap**: remove wrap only on failure (Gabriel Schulhof)\n* [[`4d816183da`](https://github.com/nodejs/node-addon-api/commit/4d816183da)] - **doc**: fix example code (András Timár, Dr) [#657](https://github.com/nodejs/node-addon-api/pull/657)\n* [[`7ac6e21801`](https://github.com/nodejs/node-addon-api/commit/7ac6e21801)] - **gyp**: fix gypfile name in index.js (Anna Henningsen) [#658](https://github.com/nodejs/node-addon-api/pull/658)\n* [[`46484202ca`](https://github.com/nodejs/node-addon-api/commit/46484202ca)] - **test**: user data in function property descriptor (Kevin Eady) [#652](https://github.com/nodejs/node-addon-api/pull/652)\n* [[`0f8d730483`](https://github.com/nodejs/node-addon-api/commit/0f8d730483)] - **doc**: fix syntax error in example (András Timár, Dr) [#650](https://github.com/nodejs/node-addon-api/pull/650)\n* [[`4e885069f1`](https://github.com/nodejs/node-addon-api/commit/4e885069f1)] - **src**: call `napi\\_remove\\_wrap()` in `ObjectWrap` dtor (Anna Henningsen) [#475](https://github.com/nodejs/node-addon-api/pull/475)\n* [[`2fde5c3ca3`](https://github.com/nodejs/node-addon-api/commit/2fde5c3ca3)] - **test**: update BigInt test for recent change in core (Michael Dawson) [#649](https://github.com/nodejs/node-addon-api/pull/649)\n* [[`e8935bd8d9`](https://github.com/nodejs/node-addon-api/commit/e8935bd8d9)] - **test**: add test for own properties on ObjectWrap (Guenter Sandner) [#645](https://github.com/nodejs/node-addon-api/pull/645)\n* [[`23ff7f0b24`](https://github.com/nodejs/node-addon-api/commit/23ff7f0b24)] - **src**: make OnWorkComplete and OnExecute override-able (legendecas) [#589](https://github.com/nodejs/node-addon-api/pull/589)\n* [[`86384f94d3`](https://github.com/nodejs/node-addon-api/commit/86384f94d3)] - **objectwrap**: gracefully handle constructor exceptions (Gabriel Schulhof)\n* [[`9af69da01f`](https://github.com/nodejs/node-addon-api/commit/9af69da01f)] - remove N-API implementation, v6.x and v8.x support (Gabriel Schulhof) [#643](https://github.com/nodejs/node-addon-api/pull/643)\n* [[`920d544779`](https://github.com/nodejs/node-addon-api/commit/920d544779)] - **benchmark**: add templated version of Function (Gabriel Schulhof) [#637](https://github.com/nodejs/node-addon-api/pull/637)\n* [[`03759f7759`](https://github.com/nodejs/node-addon-api/commit/03759f7759)] - ignore benchmark built archives (legendecas) [#631](https://github.com/nodejs/node-addon-api/pull/631)\n* [[`5eeabb0214`](https://github.com/nodejs/node-addon-api/commit/5eeabb0214)] - **tsfn**: Remove erroneous finalizer cleanup (Kevin Eady) [#636](https://github.com/nodejs/node-addon-api/pull/636)\n* [[`9e0e0f31e4`](https://github.com/nodejs/node-addon-api/commit/9e0e0f31e4)] - **src**: remove unnecessary forward declarations (Gabriel Schulhof) [#633](https://github.com/nodejs/node-addon-api/pull/633)\n* [[`79deefb6f3`](https://github.com/nodejs/node-addon-api/commit/79deefb6f3)] - **src**: explicitly disallow assign and copy (legendecas) [#590](https://github.com/nodejs/node-addon-api/pull/590)\n* [[`af50ac281b`](https://github.com/nodejs/node-addon-api/commit/af50ac281b)] - **error**: do not replace pending exception (Gabriel Schulhof) [#629](https://github.com/nodejs/node-addon-api/pull/629)\n* [[`b72f1d6978`](https://github.com/nodejs/node-addon-api/commit/b72f1d6978)] - Disable caching in ArrayBuffer (Tobias Nießen) [#611](https://github.com/nodejs/node-addon-api/pull/611)\n* [[`0e7483eb7b`](https://github.com/nodejs/node-addon-api/commit/0e7483eb7b)] - Fix code format in tests (Tobias Nießen) [#617](https://github.com/nodejs/node-addon-api/pull/617)\n* [[`6a0646356d`](https://github.com/nodejs/node-addon-api/commit/6a0646356d)] - add benchmarking framework (Gabriel Schulhof) [#623](https://github.com/nodejs/node-addon-api/pull/623)\n* [[`ffc71edd54`](https://github.com/nodejs/node-addon-api/commit/ffc71edd54)] - Add Env::RunScript (Tobias Nießen) [#616](https://github.com/nodejs/node-addon-api/pull/616)\n* [[`a1b106066e`](https://github.com/nodejs/node-addon-api/commit/a1b106066e)] - **src**: add templated function factories (Gabriel Schulhof) [#608](https://github.com/nodejs/node-addon-api/pull/608)\n* [[`c584343217`](https://github.com/nodejs/node-addon-api/commit/c584343217)] - Add GetPropertyNames, HasOwnProperty, Delete (#615) (Tobias Nießen) [#615](https://github.com/nodejs/node-addon-api/pull/615)\n* [[`3acc4b32f5`](https://github.com/nodejs/node-addon-api/commit/3acc4b32f5)] - Fix std::string encoding (#619) (Tobias Nießen) [#619](https://github.com/nodejs/node-addon-api/pull/619)\n* [[`e71d0eadcc`](https://github.com/nodejs/node-addon-api/commit/e71d0eadcc)] - \\[doc\\] Fixed links to array documentation (#613) (Nicola Del Gobbo)\n* [[`3dfb1f0591`](https://github.com/nodejs/node-addon-api/commit/3dfb1f0591)] - Change \"WG\" to \"team\" (Tobias Nießen)\n* [[`ce91e14860`](https://github.com/nodejs/node-addon-api/commit/ce91e14860)] - **objectwrap**: add template methods (Dmitry Ashkadov) [#604](https://github.com/nodejs/node-addon-api/pull/604)\n* [[`cfa71b60f7`](https://github.com/nodejs/node-addon-api/commit/cfa71b60f7)] - **object**: add templated property descriptors (Gabriel Schulhof) [#610](https://github.com/nodejs/node-addon-api/pull/610)\n* [[`734725e971`](https://github.com/nodejs/node-addon-api/commit/734725e971)] - Correctly define copy assignment operators. (Rolf Timmermans)\n\n## 2019-11-21 Version 2.0.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Added `Napi::AsyncProgressWorker` api.\n- Added error checking on `Napi::ThreadSafeFunction::GetContext`.\n- Added copy constructor to `Napi::ThreadSafeFunction`.\n- Added `Napi::ThreadSafeFunction::Ref` and `Napi::ThreadSafeFunction::Unref` to `Napi::ThreadSafeFunction`.\n- Added `Napi::Object::AddFinalizer` method.\n- Use `napi_add_finalizer()` to attach data when building against N-API 5.\n- Added `Napi::Date` api.\n- Added `Napi::ObjectWrap::Finalize` method.\n\n#### Documentation\n\n- Added documentation for `Napi::AsyncProgressWorker`.\n- Improve `Napi::AsyncWorker` documentation.\n- Added documentation for `Napi::Object::AddFinalizer` method.\n- Improved documentation for `Napi::ThreadSafeFunction`.\n- Improved documentation about the usage of CMake as build tool.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Added test cases for `Napi::AsyncProgressWorker` api.\n- Added test cases for `Napi::Date` api.\n- Added test cases for new features added to `Napi::ThreadSafeFunction`.\n\n### Commits\n\n* [[`c881168d49`](https://github.com/nodejs/node-addon-api/commit/c881168d49)] - **tsfn**: add error checking on GetContext (#583) (Kevin Eady) [#583](https://github.com/nodejs/node-addon-api/pull/583)\n* [[`24d75dd82f`](https://github.com/nodejs/node-addon-api/commit/24d75dd82f)] - Merge pull request #588 from NickNaso/add-asyncprogress-worker-readme (Nicola Del Gobbo)\n* [[`aa79e37b62`](https://github.com/nodejs/node-addon-api/commit/aa79e37b62)] - Merge pull request #587 from timrach/patch-1 (Nicola Del Gobbo)\n* [[`df75e08c2b`](https://github.com/nodejs/node-addon-api/commit/df75e08c2b)] - **tsfn**: support direct calls to underlying napi\\_tsfn (Kevin Eady) [#58](https://github.com/nodejs/node-addon-api/pull/58)\n* [[`2298dfae58`](https://github.com/nodejs/node-addon-api/commit/2298dfae58)] - **doc**: Added AsyncProgressWorker to readme (NickNaso)\n* [[`b3609d33b6`](https://github.com/nodejs/node-addon-api/commit/b3609d33b6)] - Fix return type and declaration of setter callback (Tim Rach)\n* [[`295e560f55`](https://github.com/nodejs/node-addon-api/commit/295e560f55)] - **test**: improve guards for experimental features (legendecas)\n* [[`2e71842f63`](https://github.com/nodejs/node-addon-api/commit/2e71842f63)] - **tsfn**: Implement copy constructor (Kevin Eady) [#546](https://github.com/nodejs/node-addon-api/pull/546)\n* [[`650562cab9`](https://github.com/nodejs/node-addon-api/commit/650562cab9)] - **src**: implement AsyncProgressWorker (legendecas) [#529](https://github.com/nodejs/node-addon-api/pull/529)\n* [[`bdfd14101f`](https://github.com/nodejs/node-addon-api/commit/bdfd14101f)] - **src**: attach data with napi\\_add\\_finalizer (Gabriel Schulhof) [#577](https://github.com/nodejs/node-addon-api/pull/577)\n* [[`9e955a802b`](https://github.com/nodejs/node-addon-api/commit/9e955a802b)] - **doc**: change node.js to Node.js per guideline (#579) (Tobias Nießen) [#579](https://github.com/nodejs/node-addon-api/pull/579)\n* [[`b42e21e3a9`](https://github.com/nodejs/node-addon-api/commit/b42e21e3a9)] - **build**: move node/6 to travis allowed failures and add node/13 (#573) (Gabriel Schulhof)\n* [[`8d6132f609`](https://github.com/nodejs/node-addon-api/commit/8d6132f609)] - **doc**: improve AsyncWorker docs (#571) (legendecas) [#571](https://github.com/nodejs/node-addon-api/pull/571)\n* [[`bc8fc23627`](https://github.com/nodejs/node-addon-api/commit/bc8fc23627)] - **test**: do not run TSFN tests on NAPI\\_VERSION \\< 4 (legendecas) [#576](https://github.com/nodejs/node-addon-api/pull/576)\n* [[`bcc1d58fc4`](https://github.com/nodejs/node-addon-api/commit/bcc1d58fc4)] - implement Object::AddFinalizer (Gabriel Schulhof)\n* [[`e9a4bcd52a`](https://github.com/nodejs/node-addon-api/commit/e9a4bcd52a)] - **doc**: updates Make.js doc to current best practices (Jim Schlight) [#558](https://github.com/nodejs/node-addon-api/pull/558)\n* [[`b513d1aa7a`](https://github.com/nodejs/node-addon-api/commit/b513d1aa7a)] - **doc**: fix return type of ArrayBuffer::Data (Tobias Nießen) [#552](https://github.com/nodejs/node-addon-api/pull/552)\n* [[`34c11cf0a4`](https://github.com/nodejs/node-addon-api/commit/34c11cf0a4)] - **src**: disallow copying, double close of scopes (legendecas) [#566](https://github.com/nodejs/node-addon-api/pull/566)\n* [[`ce139a05e8`](https://github.com/nodejs/node-addon-api/commit/ce139a05e8)] - **src**: make failure of closing scopes fatal (legendecas) [#566](https://github.com/nodejs/node-addon-api/pull/566)\n* [[`740c79823e`](https://github.com/nodejs/node-addon-api/commit/740c79823e)] - **src**: add Env() to AsyncContext (Rolf Timmermans) [#568](https://github.com/nodejs/node-addon-api/pull/568)\n* [[`ea9ce1c801`](https://github.com/nodejs/node-addon-api/commit/ea9ce1c801)] - **tsfn**: add wrappers for Ref and Unref (Kevin Eady) [#561](https://github.com/nodejs/node-addon-api/pull/561)\n* [[`2e1769e1a3`](https://github.com/nodejs/node-addon-api/commit/2e1769e1a3)] - **error**: remove unnecessary if condition (legendecas) [#562](https://github.com/nodejs/node-addon-api/pull/562)\n* [[`828f223a87`](https://github.com/nodejs/node-addon-api/commit/828f223a87)] - **doc**: fix spelling in ObjectWrap doc (#563) (Tobias Nießen) [#563](https://github.com/nodejs/node-addon-api/pull/563)\n* [[`dd9fa8a4a8`](https://github.com/nodejs/node-addon-api/commit/dd9fa8a4a8)] - **doc**: move Arunesh and Taylor to Emeritus (#540) (Michael Dawson) [#540](https://github.com/nodejs/node-addon-api/pull/540)\n* [[`cf8b8415df`](https://github.com/nodejs/node-addon-api/commit/cf8b8415df)] - **doc**: add Kevin to the list of collaborators (#539) (Michael Dawson) [#539](https://github.com/nodejs/node-addon-api/pull/539)\n* [[`5d6aeae7b5`](https://github.com/nodejs/node-addon-api/commit/5d6aeae7b5)] - **build**: enable travis for fast PR check (legendecas)\n* [[`6192e705cd`](https://github.com/nodejs/node-addon-api/commit/6192e705cd)] - **src**: add napi\\_date (Mathias Küsel) [#497](https://github.com/nodejs/node-addon-api/pull/497)\n* [[`7b1ee96d52`](https://github.com/nodejs/node-addon-api/commit/7b1ee96d52)] - **doc**: update prebuild\\_tools.md (Nurbol Alpysbayev) [#527](https://github.com/nodejs/node-addon-api/pull/527)\n* [[`0b4f3a5b8c`](https://github.com/nodejs/node-addon-api/commit/0b4f3a5b8c)] - **tsfn**: fix crash on releasing tsfn (legendecas) [#532](https://github.com/nodejs/node-addon-api/pull/532)\n* [[`c3c8814d2f`](https://github.com/nodejs/node-addon-api/commit/c3c8814d2f)] - implement virutal ObjectWrap::Finalize (Michael Price) [#515](https://github.com/nodejs/node-addon-api/pull/515)\n\n## 2019-07-23 Version 1.7.1, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Fixed compilation problems that happen on Node.js with N-API version less than 4.\n\n### Commits\n\n* [[`c20bcbd069`](https://github.com/nodejs/node-addon-api/commit/c20bcbd069)] - Merge pull request #518 from NickNaso/master (Nicola Del Gobbo)\n* [[`6720d57253`](https://github.com/nodejs/node-addon-api/commit/6720d57253)] - Create the native threadsafe\\_function for test only for N-API greater than 3. (NickNaso)\n* [[`37b6c185ad`](https://github.com/nodejs/node-addon-api/commit/37b6c185ad)] - Fix compilation breakage on 1.7.0 (NickNaso)\n\n## 2019-07-23 Version 1.7.0, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Added `Napi::ThreadSafeFunction` api.\n- Added `Napi::AsyncWorker::GetResult()` method to `Napi::AsyncWorker`.\n- Added `Napi::AsyncWorker::Destroy()()` method to `Napi::AsyncWorker`.\n- Use full namespace on macros that create the errors.\n\n#### Documentation\n\n- Added documentation about contribution philosophy.\n- Added documentation for `Napi::ThreadSafeFunction`.\n- Some minor corrections all over the documentation.\n\n#### TEST\n\n- Added test case for bool operator.\n- Fixed test case for `Napi::ObjectWrap`.\n\n### Commits\n\n* [[`717c9ab163`](https://github.com/nodejs/node-addon-api/commit/717c9ab163)] - **AsyncWorker**: add GetResult() method (Kevin Eady) [#512](https://github.com/nodejs/node-addon-api/pull/512)\n* [[`d9d991bbc9`](https://github.com/nodejs/node-addon-api/commit/d9d991bbc9)] - **doc**: add ThreadSafeFunction to main README (#513) (Kevin Eady) [#513](https://github.com/nodejs/node-addon-api/pull/513)\n* [[`ac6000d0fd`](https://github.com/nodejs/node-addon-api/commit/ac6000d0fd)] - **doc**: fix minor typo (Yohei Kishimoto) [#510](https://github.com/nodejs/node-addon-api/pull/510)\n* [[`e9fa1eaa86`](https://github.com/nodejs/node-addon-api/commit/e9fa1eaa86)] - **doc**: document ThreadSafeFunction (#494) (Kevin Eady) [#494](https://github.com/nodejs/node-addon-api/pull/494)\n* [[`cab3b1e2a2`](https://github.com/nodejs/node-addon-api/commit/cab3b1e2a2)] - **doc**: ClassPropertyDescriptor example (Ross Weir) [#507](https://github.com/nodejs/node-addon-api/pull/507)\n* [[`c32d7dbdcf`](https://github.com/nodejs/node-addon-api/commit/c32d7dbdcf)] - **macros**: create errors fully namespaced (Gabriel Schulhof) [#506](https://github.com/nodejs/node-addon-api/pull/506)\n* [[`0a90df2fcb`](https://github.com/nodejs/node-addon-api/commit/0a90df2fcb)] - Implement ThreadSafeFunction class (Jinho Bang)\n* [[`1fb540eeb5`](https://github.com/nodejs/node-addon-api/commit/1fb540eeb5)] - Use curly brackets to include node\\_api.h (NickNaso) [#493](https://github.com/nodejs/node-addon-api/pull/493)\n* [[`b2b08122ea`](https://github.com/nodejs/node-addon-api/commit/b2b08122ea)] - **AsyncWorker**: make callback optional (Kevin Eady) [#489](https://github.com/nodejs/node-addon-api/pull/489)\n* [[`a0cac77c82`](https://github.com/nodejs/node-addon-api/commit/a0cac77c82)] - Added test for bool operator (NickNaso) [#490](https://github.com/nodejs/node-addon-api/pull/490)\n* [[`ab7d8fcc48`](https://github.com/nodejs/node-addon-api/commit/ab7d8fcc48)] - **src**: fix objectwrap test case (Michael Dawson) [#495](https://github.com/nodejs/node-addon-api/pull/495)\n* [[`3b6b9eb88a`](https://github.com/nodejs/node-addon-api/commit/3b6b9eb88a)] - **AsyncWorker**: introduce Destroy() method (Gabriel Schulhof) [#488](https://github.com/nodejs/node-addon-api/pull/488)\n* [[`f633fbd95d`](https://github.com/nodejs/node-addon-api/commit/f633fbd95d)] - string.md: Document existing New(env, value, length) APIs (Tux3) [#486](https://github.com/nodejs/node-addon-api/pull/486)\n* [[`aaea55eda9`](https://github.com/nodejs/node-addon-api/commit/aaea55eda9)] - Little fix on code example (Nicola Del Gobbo) [#470](https://github.com/nodejs/node-addon-api/pull/470)\n* [[`e1cf9a35a1`](https://github.com/nodejs/node-addon-api/commit/e1cf9a35a1)] - Use `Value::IsEmpty` to check for empty value (NickNaso) [#478](https://github.com/nodejs/node-addon-api/pull/478)\n* [[`3ad5dfc7d9`](https://github.com/nodejs/node-addon-api/commit/3ad5dfc7d9)] - Fix link (Alba Mendez) [#481](https://github.com/nodejs/node-addon-api/pull/481)\n* [[`a3b4d99c45`](https://github.com/nodejs/node-addon-api/commit/a3b4d99c45)] - **doc**: Add contribution philosophy doc (Hitesh Kanwathirtha)\n* [[`36863f087b`](https://github.com/nodejs/node-addon-api/commit/36863f087b)] - **doc**: refer to TypedArray and ArrayBuffer from Array (Gabriel \"_|Nix|_\" Schulhof) [#465](https://github.com/nodejs/node-addon-api/pull/465)\n\n## 2019-04-03 Version 1.6.3, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Added `SuppressDestruct` method to `Napi::AsyncWorker`.\n- Added new build targets for debug.\n- Exposed macros that throw errors.\n- Fixed memory leaks caused by callback data when a napi error occurs.\n- Fixed missing `void *data` usage in `Napi::PropertyDescriptors`.\n\n#### Documentation\n\n- Some minor corrections all over the documentation.\n\n### Commits\n\n* [[`83b41c2fe4`](https://github.com/nodejs/node-addon-api/commit/83b41c2fe4)] - Document adding -fvisibility=hidden flag for macOS users (Nicola Del Gobbo) [#460](https://github.com/nodejs/node-addon-api/pull/460)\n* [[`1ed7ad8769`](https://github.com/nodejs/node-addon-api/commit/1ed7ad8769)] - **doc**: correct return type of Int32Value to int32\\_t (Bill Gallafent) [#459](https://github.com/nodejs/node-addon-api/pull/459)\n* [[`b0f6b601aa`](https://github.com/nodejs/node-addon-api/commit/b0f6b601aa)] - **src**: add AsyncWorker destruction suppression (Gabriel Schulhof) [#407](https://github.com/nodejs/node-addon-api/pull/407)\n* [[`72b1975cff`](https://github.com/nodejs/node-addon-api/commit/72b1975cff)] - **doc**: fix links to the Property Descriptor docs (Ryuichi Okumura) [#458](https://github.com/nodejs/node-addon-api/pull/458)\n* [[`fcfc612728`](https://github.com/nodejs/node-addon-api/commit/fcfc612728)] - **build**: new build targets for debug purposes (Jinho Bang) [#186](https://github.com/nodejs/node-addon-api/pull/186)\n* [[`c629553cd7`](https://github.com/nodejs/node-addon-api/commit/c629553cd7)] - **doc**: minor doc corrections and clarifications (Bruce A. MacNaughton) [#426](https://github.com/nodejs/node-addon-api/pull/426)\n* [[`7b87e0b999`](https://github.com/nodejs/node-addon-api/commit/7b87e0b999)] - **doc**: update number.md (Bernardo Heynemann) [#436](https://github.com/nodejs/node-addon-api/pull/436)\n* [[`fcf173d2a1`](https://github.com/nodejs/node-addon-api/commit/fcf173d2a1)] - **src**: expose macros that throw errors (Gabriel Schulhof) [#448](https://github.com/nodejs/node-addon-api/pull/448)\n* [[`b409a2f987`](https://github.com/nodejs/node-addon-api/commit/b409a2f987)] - **package**: add npm search keywords (Sam Roberts) [#452](https://github.com/nodejs/node-addon-api/pull/452)\n* [[`0bc7987806`](https://github.com/nodejs/node-addon-api/commit/0bc7987806)] - **doc**: fix references to Weak and Persistent (Jake Barnes) [#428](https://github.com/nodejs/node-addon-api/pull/428)\n* [[`ad6f569f85`](https://github.com/nodejs/node-addon-api/commit/ad6f569f85)] - **doc**: dix typo (Abhishek Kumar Singh) [#435](https://github.com/nodejs/node-addon-api/pull/435)\n* [[`28df833a49`](https://github.com/nodejs/node-addon-api/commit/28df833a49)] - Merge pull request #441 from jschlight/master (Jim Schlight)\n* [[`4921e74d83`](https://github.com/nodejs/node-addon-api/commit/4921e74d83)] - Rearranges names to be alphabetical (Jim Schlight)\n* [[`48220335b0`](https://github.com/nodejs/node-addon-api/commit/48220335b0)] - Membership review update (Jim Schlight)\n* [[`44f0695533`](https://github.com/nodejs/node-addon-api/commit/44f0695533)] - Merge pull request #394 from NickNaso/create\\_release (Nicola DelGobbo)\n* [[`fa49d68416`](https://github.com/nodejs/node-addon-api/commit/fa49d68416)] - **doc**: fix some `Finalizer` signatures (Philipp Renoth) [#414](https://github.com/nodejs/node-addon-api/pull/414)\n* [[`020ac4a628`](https://github.com/nodejs/node-addon-api/commit/020ac4a628)] - **src**: make `Object::GetPropertyNames()` const (Philipp Renoth)[#415](https://github.com/nodejs/node-addon-api/pull/415)\n* [[`91eaa6f4cb`](https://github.com/nodejs/node-addon-api/commit/91eaa6f4cb)] - **src**: fix callbackData leaks on error napi status (Philipp Renoth) [#417](https://github.com/nodejs/node-addon-api/pull/417)\n* [[`0b40275752`](https://github.com/nodejs/node-addon-api/commit/0b40275752)] - **src**: fix noexcept control flow issues (Philipp Renoth) [#420](https://github.com/nodejs/node-addon-api/pull/420)\n* [[`c1ff2936f9`](https://github.com/nodejs/node-addon-api/commit/c1ff2936f9)] - **src**: fix missing void\\*data usage in PropertyDescriptors (Luciano Martorella) [#374](https://github.com/nodejs/node-addon-api/pull/374)\n\n## 2018-11-29 Version 1.6.2, @NickNaso\n\n### Notable changes:\n\n#### API\n\n- Fixed selection logic for version 6.x.\n\n### Commmits\n\n* [[`07a0fc4e95`](https://github.com/nodejs/node-addon-api/commit/07a0fc4e95)] - **src**: fix selection logic for 6.x (Michael Dawson) [#402](https://github.com/nodejs/node-addon-api/pull/402)\n\n## 2018-11-14 Version 1.6.1, @NickNaso\n\n### Notable changes:\n\n#### Documentation\n\n- Updated links for examples to point to node-addon-examples repo.\n- Fixed typos on some parts of documentation.\n\n#### API\n\n- Removed unused member on `Napi::CallbackScope`.\n- Enabled `Napi::CallbackScope` only with N-API v3.\n\n### Commits\n\n* [[`e7cd292a74`](https://github.com/nodejs/node-addon-api/commit/e7cd292a74)] - **src**: remove unused CallbackScope member (Gabriel Schulhof) [#391](https://github.com/nodejs/node-addon-api/pull/391)\n* [[`d47399fe25`](https://github.com/nodejs/node-addon-api/commit/d47399fe25)] - **src**: guard CallbackScope with N-API v3 (Michael Dawson) [#395](https://github.com/nodejs/node-addon-api/pull/395)\n* [[`29a0262ab9`](https://github.com/nodejs/node-addon-api/commit/29a0262ab9)] - **doc**: fix typo (Dongjin Na) [#385](https://github.com/nodejs/node-addon-api/pull/385)\n* [[`b6dc15b88d`](https://github.com/nodejs/node-addon-api/commit/b6dc15b88d)] - **doc**: make links point to node-addon-examples repo (Nicola Del Gobbo) [#389](https://github.com/nodejs/node-addon-api/pull/389)\n\n## 2018-11-02 Version 1.6.0, @NickNaso\n\n### Notable changes:\n\n#### Documentation\n\n- Improved documentation about ABI stability.\n\n#### API\n\n- Add `Napi::CallbackScope` class that help to have the equivalent of the scope\nassociated with a callback in place when making certain N-API calls\n\n#### TEST\n\n- Added tests for `Napi::Array` class.\n- Added tests for `Napi::ArrayBuffer` class.\n\n### Commits\n\n* [[`8ce605c657`](https://github.com/nodejs/node-addon-api/commit/8ce605c657)] - **build**: avoid using package-lock.json (Jaeseok Yoon) [#359](https://github.com/nodejs/node-addon-api/pull/359)\n* [[`fa3a6150b3`](https://github.com/nodejs/node-addon-api/commit/fa3a6150b3)] - **src**: use MakeCallback() -\\> Call() in AsyncWorker (Jinho Bang) [#361](https://github.com/nodejs/node-addon-api/pull/361)\n* [[`2342415463`](https://github.com/nodejs/node-addon-api/commit/2342415463)] - **test**: create test objects in the stack instead of the heap (Dongjin Na) [#371](https://github.com/nodejs/node-addon-api/pull/371)\n* [[`67b7db0a6f`](https://github.com/nodejs/node-addon-api/commit/67b7db0a6f)] - **test**: write tests for Array class (Jaeseok Yoon) [#363](https://github.com/nodejs/node-addon-api/pull/363)\n* [[`729f6dc4ee`](https://github.com/nodejs/node-addon-api/commit/729f6dc4ee)] - **test**: add arraybuffer tests (Dongjin Na) [#369](https://github.com/nodejs/node-addon-api/pull/369)\n* [[`405f3e5b5b`](https://github.com/nodejs/node-addon-api/commit/405f3e5b5b)] - **src**: implement CallbackScope class (Jinho Bang) [#362](https://github.com/nodejs/node-addon-api/pull/362)\n* [[`015d95312f`](https://github.com/nodejs/node-addon-api/commit/015d95312f)] - **doc**: fix Napi::Reference link (Gentilhomme) [#365](https://github.com/nodejs/node-addon-api/pull/365)\n* [[`fd65078e3c`](https://github.com/nodejs/node-addon-api/commit/fd65078e3c)] - README.md: link to new ABI stability guide (Gabriel Schulhof) [#367](https://github.com/nodejs/node-addon-api/pull/367)\n* [[`ffebf9ba9a`](https://github.com/nodejs/node-addon-api/commit/ffebf9ba9a)] - Updates for release 1.5.0 (NickNaso)\n\n## 2018-10-03 Version 1.5.0, @NickNaso\n\n### Notable changes:\n\n#### Documentation\n\n- Completed the documentation to cover all the API surface.\n- Numerous fixes to make documentation more consistent in all of its parts.\n\n#### API\n\n- Add `Napi::AsyncContext` class to handle asynchronous operation.\n- Add `Napi::BigInt` class to work with BigInt type.\n- Add `Napi::VersionManagement` class to retrieve the versions of Node.js and N-API.\n- Fix potential memory leaks.\n- DataView feature is enabled by default\n- Add descriptor for Symbols\n- Add new methods on `Napi::FunctionReference`.\n- Add the possibility to retrieve the environment on `Napi::Promise::Deferred`\n\n#### TOOL\n\n- Add tool to check if a native add-on is built using N-API\n\n#### TEST\n\n- Start to increase the test coverage\n- Fix in the test suite to better handle the experimental features that are not\nyet backported in the previous Node.js version.\n\n### Commits\n\n* [[`2009c019af`](https://github.com/nodejs/node-addon-api/commit/2009c019af)] - Merge pull request #292 from devsnek/feature/bigint (Gus Caplan)\n* [[`e44aca985e`](https://github.com/nodejs/node-addon-api/commit/e44aca985e)] - add bigint class (Gus Caplan)\n* [[`a3951ab973`](https://github.com/nodejs/node-addon-api/commit/a3951ab973)] - Add documentation for Env(). (Rolf Timmermans) [#318](https://github.com/nodejs/node-addon-api/pull/318)\n* [[`a6f7a6ad51`](https://github.com/nodejs/node-addon-api/commit/a6f7a6ad51)] - Add Env() to Promise::Deferred. (Rolf Timmermans)\n* [[`0097e96b92`](https://github.com/nodejs/node-addon-api/commit/0097e96b92)] - Fixed broken links for Symbol and String (NickNaso)\n* [[`b0ecd38d76`](https://github.com/nodejs/node-addon-api/commit/b0ecd38d76)] - Fix Code of conduct link properly (#323) (Jake Yoon) [#323](https://github.com/nodejs/node-addon-api/pull/323)\n* [[`223474900f`](https://github.com/nodejs/node-addon-api/commit/223474900f)] - **doc**: update Version management (Dongjin Na) [#360](https://github.com/nodejs/node-addon-api/pull/360)\n* [[`4f76262a10`](https://github.com/nodejs/node-addon-api/commit/4f76262a10)] - **doc**: some fix on `Napi::Boolean` documentation (NickNaso) [#354](https://github.com/nodejs/node-addon-api/pull/354)\n* [[`78374f72d2`](https://github.com/nodejs/node-addon-api/commit/78374f72d2)] - **doc**: number documentation (NickNaso) [#356](https://github.com/nodejs/node-addon-api/pull/356)\n* [[`51ffe453f8`](https://github.com/nodejs/node-addon-api/commit/51ffe453f8)] - **doc**: doc cleanup (NickNaso) [#353](https://github.com/nodejs/node-addon-api/pull/353)\n* [[`fc11c944b2`](https://github.com/nodejs/node-addon-api/commit/fc11c944b2)] - **doc**: major doc cleanup (NickNaso) [#335](https://github.com/nodejs/node-addon-api/pull/335)\n* [[`100d0a7cb2`](https://github.com/nodejs/node-addon-api/commit/100d0a7cb2)] - **doc**: first pass on objectwrap documentation (NickNaso) [#321](https://github.com/nodejs/node-addon-api/pull/321)\n* [[`c7d54180ff`](https://github.com/nodejs/node-addon-api/commit/c7d54180ff)] - **doc**: the Napi::ObjectWrap example does not compile (Arnaud Botella) [#339](https://github.com/nodejs/node-addon-api/pull/339)\n* [[`7cdd78726a`](https://github.com/nodejs/node-addon-api/commit/7cdd78726a)] - **doc**: added cpp highlight for string.md (Jaeseok Yoon) [#329](https://github.com/nodejs/node-addon-api/pull/329)\n* [[`8ed29f547c`](https://github.com/nodejs/node-addon-api/commit/8ed29f547c)] - **doc**: add blurb about ABI stability (Gabriel Schulhof) [#326](https://github.com/nodejs/node-addon-api/pull/326)\n* [[`757eb1f5a3`](https://github.com/nodejs/node-addon-api/commit/757eb1f5a3)] - **doc**: add function and function reference doc (NickNaso) [#299](https://github.com/nodejs/node-addon-api/pull/299)\n* [[`2885c18591`](https://github.com/nodejs/node-addon-api/commit/2885c18591)] - **doc**: Create changelog for release 1.4.0 (Nicola Del Gobbo)\n* [[`917bd60baa`](https://github.com/nodejs/node-addon-api/commit/917bd60baa)] - **src**: remove TODOs by fixing memory leaks (Gabriel Schulhof) [#343](https://github.com/nodejs/node-addon-api/pull/343)\n* [[`dfcb93945f`](https://github.com/nodejs/node-addon-api/commit/dfcb93945f)] - **src**: implement AsyncContext class (Jinho Bang) [#252](https://github.com/nodejs/node-addon-api/pull/252)\n* [[`211ed38d0d`](https://github.com/nodejs/node-addon-api/commit/211ed38d0d)] - **src**: make 'nothing' target a static library (Gabriel Schulhof) [#348](https://github.com/nodejs/node-addon-api/pull/348)\n* [[`97c4ab5cf2`](https://github.com/nodejs/node-addon-api/commit/97c4ab5cf2)] - **src**: add Call and MakeCallback that accept cargs (NickNaso) [#344](https://github.com/nodejs/node-addon-api/pull/344)\n* [[`b6e2d92c09`](https://github.com/nodejs/node-addon-api/commit/b6e2d92c09)] - **src**: enable DataView feature by default (Jinho) [#331](https://github.com/nodejs/node-addon-api/pull/331)\n* [[`0a00e7c97b`](https://github.com/nodejs/node-addon-api/commit/0a00e7c97b)] - **src**: implement missing descriptor defs for symbols (Philipp Renoth) [#280](https://github.com/nodejs/node-addon-api/pull/280)\n* [[`38e01b7e3b`](https://github.com/nodejs/node-addon-api/commit/38e01b7e3b)] - **src**: first pass on adding version management apis (NickNaso) [#325](https://github.com/nodejs/node-addon-api/pull/325)\n* [[`79ee8381d2`](https://github.com/nodejs/node-addon-api/commit/79ee8381d2)] - **src**: fix compile failure in test (Michael Dawson) [#345](https://github.com/nodejs/node-addon-api/pull/345)\n* [[`4d92a6066f`](https://github.com/nodejs/node-addon-api/commit/4d92a6066f)] - **src**: Add ObjectReference test case (Anisha Rohra) [#212](https://github.com/nodejs/node-addon-api/pull/212)\n* [[`779560f397`](https://github.com/nodejs/node-addon-api/commit/779560f397)] - **test**: add operator overloading tests in Number (Your Name) [#355](https://github.com/nodejs/node-addon-api/pull/355)\n* [[`73fed84ceb`](https://github.com/nodejs/node-addon-api/commit/73fed84ceb)] - **test**: add ability to control experimental tests (Michael Dawson) [#350](https://github.com/nodejs/node-addon-api/pull/350)\n* [[`14c69abd46`](https://github.com/nodejs/node-addon-api/commit/14c69abd46)] - **test**: write tests for Boolean class (Jaeseok Yoon) [#328](https://github.com/nodejs/node-addon-api/pull/328)\n* [[`2ad47a83b1`](https://github.com/nodejs/node-addon-api/commit/2ad47a83b1)] - **test**: explicitly cast to uint32\\_t in test (Gabriel Schulhof) [#341](https://github.com/nodejs/node-addon-api/pull/341)\n* [[`622ffaea76`](https://github.com/nodejs/node-addon-api/commit/622ffaea76)] - **test**: Tighten up compiler warnings (Mikhail Cheshkov) [#315](https://github.com/nodejs/node-addon-api/pull/315)\n* [[`fd3c37b0f2`](https://github.com/nodejs/node-addon-api/commit/fd3c37b0f2)] - **tools**: add tool to check for N-API modules (Gabriel Schulhof) [#346](https://github.com/nodejs/node-addon-api/pull/346)\n\n## 2018-07-19 Version 1.4.0, @NickNaso\n\n### Notable changes:\n\n#### Documentation\n\n- Numerous additions to the documentation, filling out coverage\n  of API surface\n\n#### API\n\n- Add resource parameters to AsyncWorker constructor\n- Add memory management feature\n\n### Commits\n\n* [[`7dc5ac8bc3`](https://github.com/nodejs/node-addon-api/commit/7dc5ac8bc3)] - **doc**: update metadata for release (Nicola Del Gobbo)\n* [[`d68e86adb4`](https://github.com/nodejs/node-addon-api/commit/d68e86adb4)] - **doc**: Added documentation for PropertyDescriptor (Anisha Rohra) [#309](https://github.com/nodejs/node-addon-api/pull/309)\n* [[`968a5f2000`](https://github.com/nodejs/node-addon-api/commit/968a5f2000)] - **doc**: Add documentation for ObjectReference.md (Anisha Rohra) [#307](https://github.com/nodejs/node-addon-api/pull/307)\n* [[`908cdc314c`](https://github.com/nodejs/node-addon-api/commit/908cdc314c)] - **doc**: add `TypedArray` and `TypedArrayOf` (Kyle Farnung) [#305](https://github.com/nodejs/node-addon-api/pull/305)\n* [[`2ff776ffe3`](https://github.com/nodejs/node-addon-api/commit/2ff776ffe3)] - backport node::Persistent (Gabriel Schulhof) [#300](https://github.com/nodejs/node-addon-api/pull/300)\n* [[`98161970c9`](https://github.com/nodejs/node-addon-api/commit/98161970c9)] - Backport perf, crash and exception handling fixes (Gabriel Schulhof) [#295](https://github.com/nodejs/node-addon-api/pull/295)\n* [[`dd1191e086`](https://github.com/nodejs/node-addon-api/commit/dd1191e086)] - **test**: fix asyncworker test so it runs on 6.x (Michael Dawson) [#298](https://github.com/nodejs/node-addon-api/pull/298)\n* [[`11697fcecd`](https://github.com/nodejs/node-addon-api/commit/11697fcecd)] - **doc**: ArrayBuffer and Buffer documentation (Kyle Farnung) [#256](https://github.com/nodejs/node-addon-api/pull/256)\n* [[`605aa2babf`](https://github.com/nodejs/node-addon-api/commit/605aa2babf)] - Add memory management feature (NickNaso) [#286](https://github.com/nodejs/node-addon-api/pull/286)\n* [[`86be13a611`](https://github.com/nodejs/node-addon-api/commit/86be13a611)] - **doc**: Fix HandleScope docs (Ben Berman) [#287](https://github.com/nodejs/node-addon-api/pull/287)\n* [[`90f92c4dc0`](https://github.com/nodejs/node-addon-api/commit/90f92c4dc0)] - **doc**: Update broken links in README.md (Hitesh Kanwathirtha) [#290](https://github.com/nodejs/node-addon-api/pull/290)\n* [[`c2a620dc11`](https://github.com/nodejs/node-addon-api/commit/c2a620dc11)] - **doc**: Clarify positioning versus N-API (Michael Dawson) [#288](https://github.com/nodejs/node-addon-api/pull/288)\n* [[`6cff890ee5`](https://github.com/nodejs/node-addon-api/commit/6cff890ee5)] - **doc**: Fix typo in docs (Ben Berman) [#284](https://github.com/nodejs/node-addon-api/pull/284)\n* [[`7394bfd154`](https://github.com/nodejs/node-addon-api/commit/7394bfd154)] - **doc**: Fix typo in docs (Ben Berman) [#285](https://github.com/nodejs/node-addon-api/pull/285)\n* [[`12b2cdeed3`](https://github.com/nodejs/node-addon-api/commit/12b2cdeed3)] - fix test files (Kyle Farnung) [#257](https://github.com/nodejs/node-addon-api/pull/257)\n* [[`9ab6607242`](https://github.com/nodejs/node-addon-api/commit/9ab6607242)] - **doc**: Update Doc Version Number (joshgarde) [#277](https://github.com/nodejs/node-addon-api/pull/277)\n* [[`e029a076c6`](https://github.com/nodejs/node-addon-api/commit/e029a076c6)] - **doc**: First pass at basic Node Addon API docs (Hitesh Kanwathirtha) [#268](https://github.com/nodejs/node-addon-api/pull/268)\n* [[`74ff79717e`](https://github.com/nodejs/node-addon-api/commit/74ff79717e)] - **doc**: fix link to async\\_worker.md (Michael Dawson)\n* [[`5a63f45eda`](https://github.com/nodejs/node-addon-api/commit/5a63f45eda)] - **doc**: First step of error and async doc (NickNaso) [#272](https://github.com/nodejs/node-addon-api/pull/272)\n* [[`9d38f61afb`](https://github.com/nodejs/node-addon-api/commit/9d38f61afb)] - **doc**: New Promise and Reference docs (Jim Schlight) [#243](https://github.com/nodejs/node-addon-api/pull/243)\n* [[`43ff9fa836`](https://github.com/nodejs/node-addon-api/commit/43ff9fa836)] - **doc**: Updated Object documentation (Anisha Rohra) [#254](https://github.com/nodejs/node-addon-api/pull/254)\n* [[`b197f7cc8b`](https://github.com/nodejs/node-addon-api/commit/b197f7cc8b)] - **doc**: minor typos (Nick Soggin) [#248](https://github.com/nodejs/node-addon-api/pull/248)\n* [[`4b8918b352`](https://github.com/nodejs/node-addon-api/commit/4b8918b352)] - Add resource parameters to AsyncWorker constructor (Jinho Bang) [#253](https://github.com/nodejs/node-addon-api/pull/253)\n* [[`1ecf7c19b6`](https://github.com/nodejs/node-addon-api/commit/1ecf7c19b6)] - **doc**: fix wrong link in readme (miloas) [#255](https://github.com/nodejs/node-addon-api/pull/255)\n* [[`a750ed1932`](https://github.com/nodejs/node-addon-api/commit/a750ed1932)] - **release**: updates to metadata for next release (Michael Dawson)\n\n## 2018-05-08 Version 1.3.0, @mhdawson\n\n### Notable changes:\n\n#### Documentation\n- Added documentation for Scopes\n- Added documentation for migration from NAN\n- Update documentation to better explain the use of NODE_ADDON_API\n\n#### API\n- Implement data manipulation methods for dataview\n- Use built-in N-API on Node.js >= 6.14.2\n- Value\n  - Added IsExternal()\n  - IsObject() allow functions\n- String\n  - Fixed initialization of std::string to nullptr\n\n#### Tests\n- Fix test failures on linuxOne and AIX\n- Added basic tests for Scopes\n- Fix MSVC warning C4244 in tests\n\n### Commits\n\n* [386c2aeb74] - test: remove dep on later C++ feature (Michael Dawson) https://github.com/nodejs/node-addon-api/pull/267\n* [10697734da] - Use built-in N-API on Node.js >= 6.14.2 (Gabriel Schulhof)\n* [75086da273] - test: add basic tests and doc for scopes (Michael Dawson) https://github.com/nodejs/node-addon-api/pull/250\n* [341dbd25d5] - doc: update blurb explaining NODE_ADDON_API (Gabriel Schulhof) https://github.com/nodejs/node-addon-api/pull/251\n* [cf6c93e4ee] - don't try to escape null (Michael Dawson) https://github.com/nodejs/node-addon-api/pull/245\n* [15e4b35fc2] - test: fix MSVC warning C4244 in tests (Kyle Farnung) https://github.com/nodejs/node-addon-api/pull/236\n* [7f3ca03b8e] - Create a doc for migration (Sampson Gao) https://github.com/nodejs/node-addon-api/pull/118\n* [0a2177debe] - Fix test failures on linuxOne and AIX (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/232\n* [d567f4b6b5] - Added Napi::Value::IsExternal() (Eric Bickle) https://github.com/nodejs/node-addon-api/pull/227\n* [1b0f0e004a] - Update node-gyp.md (Michele Campus) https://github.com/nodejs/node-addon-api/pull/226\n* [faf19c4f7a] - Fixed initialization of std::string to nullptr (Eric Bickle) https://github.com/nodejs/node-addon-api/pull/228\n* [9c4d321b57] - Implement data manipulation methods for dataview (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/218\n* [5a39fdca6f] - n-api: throw RangeError napi_create_typedarray() (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/216\n* [1376377202] - Make IsObject() allow functions (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/217\n* [673b59d319] - src: Initial implementation of DataView class (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/205\n* [0a899bf1c5] - doc: update indication of latest version (Michael Dawson) https://github.com/nodejs/node-addon-api/pull/211\n* [17c74e5a5e] - n-api: RangeError in napi_create_dataview() (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/214\n* [4058a29989] - n-api: fix memory leak in napi_async_destroy() (Jinho Bang) https://github.com/nodejs/node-addon-api/pull/213\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.1533203125,
          "content": "# Code of Conduct\n\nThe Node.js Code of Conduct, which applies to this project, can be found at\nhttps://github.com/nodejs/admin/blob/HEAD/CODE_OF_CONDUCT.md.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 7.1552734375,
          "content": "# Contributing to **node-addon-api**\n\n* [Code of Conduct](#code-of-conduct)\n* [Developer's Certificate of Origin 1.1](#developers-certificate-of-origin)\n* [Tests](#tests)\n* [Debug](#debug)\n* [Benchmarks](#benchmarks)\n* [node-addon-api Contribution Philosophy](#node-addon-api-contribution-philosophy)\n\n## Code of Conduct\n\nThe Node.js project has a\n[Code of Conduct](https://github.com/nodejs/admin/blob/HEAD/CODE_OF_CONDUCT.md)\nto which all contributors must adhere.\n\nSee [details on our policy on Code of Conduct](https://github.com/nodejs/node/blob/main/doc/contributing/code-of-conduct.md).\n\n<a id=\"developers-certificate-of-origin\"></a>\n\n## Developer's Certificate of Origin 1.1\n\n<pre>\nBy making a contribution to this project, I certify that:\n\n (a) The contribution was created in whole or in part by me and I\n     have the right to submit it under the open source license\n     indicated in the file; or\n\n (b) The contribution is based upon previous work that, to the best\n     of my knowledge, is covered under an appropriate open source\n     license and I have the right under that license to submit that\n     work with modifications, whether created in whole or in part\n     by me, under the same open source license (unless I am\n     permitted to submit under a different license), as indicated\n     in the file; or\n\n (c) The contribution was provided directly to me by some other\n     person who certified (a), (b) or (c) and I have not modified\n     it.\n\n (d) I understand and agree that this project and the contribution\n     are public and that a record of the contribution (including all\n     personal information I submit with it, including my sign-off) is\n     maintained indefinitely and may be redistributed consistent with\n     this project or the open source license(s) involved.\n</pre>\n\n\n## Tests\n\nTo run the **node-addon-api** tests do:\n\n```\nnpm install\nnpm test\n```\n\nTo avoid testing the deprecated portions of the API run\n```\nnpm install\nnpm test --disable-deprecated\n```\n\nTo run the tests targeting a specific version of Node-API run\n```\nnpm install\nexport NAPI_VERSION=X\nnpm test --NAPI_VERSION=X\n```\n\nwhere X is the version of Node-API you want to target.\n\nTo run a specific unit test, filter conditions are available\n\n**Example:**\n  compile and run only tests on objectwrap.cc and objectwrap.js\n  ```\n    npm run unit --filter=objectwrap\n  ```\n\nMultiple unit tests cane be selected with wildcards\n\n**Example:**\ncompile and run all test files ending with \"reference\" -> function_reference.cc, object_reference.cc, reference.cc\n ```\n    npm run unit --filter=*reference\n ```\n\nMultiple filter conditions can be joined to broaden the test selection\n\n**Example:**\n compile and run all tests under folders threadsafe_function and typed_threadsafe_function and also the objectwrap.cc file\n    npm run unit --filter='*function objectwrap'\n\n## Debug\n\nTo run the **node-addon-api** tests with `--debug` option:\n\n```\nnpm run-script dev\n```\n\nIf you want a faster build, you might use the following option:\n\n```\nnpm run-script dev:incremental\n```\n\nTake a look and get inspired by our **[test suite](https://github.com/nodejs/node-addon-api/tree/HEAD/test)**\n\n## Benchmarks\n\nYou can run the available benchmarks using the following command:\n\n```\nnpm run-script benchmark\n```\n\nSee [benchmark/README.md](benchmark/README.md) for more details about running and adding benchmarks.\n\n## **node-addon-api** Contribution Philosophy\n\nThe **node-addon-api** team loves contributions. There are many ways in which you can\ncontribute to **node-addon-api**:\n- [New APIs](#new-apis)\n- [Source code fixes](#source-changes)\n- Additional tests\n- Documentation improvements\n- Joining the Node-API working group and participating in meetings\n\n### New APIs\n\nAs new APIs are added to Node-API, node-addon-api must be updated to provide\nwrappers for those new APIs. For this reason, node-addon-api provides\nmethods that allow callers to obtain the underlying Node-API handles so\ndirect calls to Node-API and the use of the objects/methods provided by\nnode-addon-api can be used together. For example, in order to be able\nto use an API for which the node-addon-api does not yet provide a wrapper.\n\nAPIs exposed by node-addon-api are generally used to create and\nmanipulate JavaScript values. Concepts and operations generally map\nto ideas specified in the **ECMA262 Language Specification**.\n\n### Source changes\n\n**node-addon-api** is meant to be a thin convenience wrapper around Node-API. With this\nin mind, contributions of any new APIs that wrap around a core Node-API API will\nbe considered for merging. However, changes that wrap existing **node-addon-api**\nAPIs are encouraged to instead be provided as an ecosystem module. The\n**node-addon-api** team is happy to link to a curated set of modules that build on\ntop of **node-addon-api** if they have broad usefulness to the community and promote\na recommended idiom or pattern.\n\n### Rationale\n\nThe Node-API team considered a couple of different approaches with regard to changes\nextending **node-addon-api**\n- Larger core module - Incorporate these helpers and patterns into **node-addon-api**\n- Extras package - Create a new package (strawman name '**node-addon-api**-extras')\nthat contain utility classes and methods that help promote good patterns and\nidioms while writing native addons with **node-addon-api**.\n- Ecosystem - Encourage the creation of a module ecosystem around **node-addon-api**\nwhere folks can build on top of it.\n\n#### Larger Core\n\nThis is probably our simplest option in terms of immediate action needed. It\nwould involve landing any open PRs against **node-addon-api**, and continuing to\nencourage folks to make PRs for utility helpers against the same repository.\n\nThe downside of the approach is the following:\n- Less coherency for our API set\n- More maintenance burden on the Node-API WG core team.\n\n#### Extras Package\n\nThis involves us spinning up a new package that contains the utility classes\nand methods. This has the benefit of having a separate module where helpers\nmake it easier to implement certain patterns and idioms for native addons\neasier.\n\nThe downside of this approach is the following:\n- Potential for confusion - we'll need to provide clear documentation to help the\ncommunity understand where a particular contribution should be directed to (what\nbelongs in **node-addon-api** vs **node-addon-api-extras**)\n- Need to define the level of support/API guarantees\n- Unclear if the maintenance burden on the Node-API WG is reduced or not\n\n#### Ecosystem\n\nThis doesn't require a ton of up-front work from the Node-API WG. Instead of\naccepting utility PRs into **node-addon-api** or creating and maintaining a new\nmodule, the WG will encourage the creation of an ecosystem of modules that\nbuild on top of **node-addon-api**, and provide some level of advertising for these\nmodules (listing them out on the repository/wiki, using them in workshops/tutorials\netc).\n\nThe downside of this approach is the following:\n- Potential for lack of visibility. Evangelism and education are hard, and module\nauthors might not find the right patterns and instead implement things themselves\n- There might be greater friction for the Node-API WG in evolving APIs since the\necosystem would have taken dependencies on the API shape of **node-addon-api**\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.123046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 [Node.js API collaborators](https://github.com/nodejs/node-addon-api#collaborators)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.8798828125,
          "content": "# **node-addon-api module**\n\n[![codecov](https://codecov.io/gh/nodejs/node-addon-api/branch/main/graph/badge.svg)](https://app.codecov.io/gh/nodejs/node-addon-api/tree/main)\n\n[![NPM](https://nodei.co/npm/node-addon-api.png?downloads=true&downloadRank=true)](https://nodei.co/npm/node-addon-api/) [![NPM](https://nodei.co/npm-dl/node-addon-api.png?months=6&height=1)](https://nodei.co/npm/node-addon-api/)\n\nThis module contains  **header-only C++ wrapper classes** which simplify\nthe use of the C based [Node-API](https://nodejs.org/dist/latest/docs/api/n-api.html)\nprovided by Node.js when using C++. It provides a C++ object model\nand exception handling semantics with low overhead.\n\n- [API References](doc/README.md)\n- [Badges](#badges)\n- [Contributing](#contributing)\n- [License](#license)\n\n## API References\n\nAPI references are available in the [doc](doc/README.md) directory.\n\n<!-- x-release-please-start-version -->\n## Current version: 8.3.0\n<!-- x-release-please-end -->\n\n(See [CHANGELOG.md](CHANGELOG.md) for complete Changelog)\n\nnode-addon-api is based on [Node-API](https://nodejs.org/api/n-api.html) and supports using different Node-API versions.\nThis allows addons built with it to run with Node.js versions which support the targeted Node-API version.\n**However** the node-addon-api support model is to support only the active LTS Node.js versions. This means that\nevery year there will be a new major which drops support for the Node.js LTS version which has gone out of service.\n\nThe oldest Node.js version supported by the current version of node-addon-api is Node.js 18.x.\n\n## Badges\n\nThe use of badges is recommended to indicate the minimum version of Node-API\nrequired for the module. This helps to determine which Node.js major versions are\nsupported. Addon maintainers can consult the [Node-API support matrix][] to determine\nwhich Node.js versions provide a given Node-API version. The following badges are\navailable:\n\n![Node-API v1 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v1%20Badge.svg)\n![Node-API v2 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v2%20Badge.svg)\n![Node-API v3 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v3%20Badge.svg)\n![Node-API v4 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v4%20Badge.svg)\n![Node-API v5 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v5%20Badge.svg)\n![Node-API v6 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v6%20Badge.svg)\n![Node-API v7 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v7%20Badge.svg)\n![Node-API v8 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v8%20Badge.svg)\n![Node-API v9 Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20v9%20Badge.svg)\n![Node-API Experimental Version Badge](https://github.com/nodejs/abi-stable-node/blob/doc/assets/Node-API%20Experimental%20Version%20Badge.svg)\n\n## Contributing\n\nWe love contributions from the community to **node-addon-api**!\nSee [CONTRIBUTING.md](CONTRIBUTING.md) for more details on our philosophy around extending this module.\n\n## Team members\n\n### Active\n\n| Name                | GitHub Link                                           |\n| ------------------- | ----------------------------------------------------- |\n| Anna Henningsen     | [addaleax](https://github.com/addaleax)               |\n| Chengzhong Wu       | [legendecas](https://github.com/legendecas)           |\n| Jack Xia            | [JckXia](https://github.com/JckXia)                   |\n| Kevin Eady          | [KevinEady](https://github.com/KevinEady)             |\n| Michael Dawson      | [mhdawson](https://github.com/mhdawson)               |\n| Nicola Del Gobbo    | [NickNaso](https://github.com/NickNaso)               |\n| Vladimir Morozov    | [vmoroz](https://github.com/vmoroz)                   |\n\n<details>\n\n<summary>Emeritus</summary>\n\n### Emeritus\n\n| Name                | GitHub Link                                           |\n| ------------------- | ----------------------------------------------------- |\n| Arunesh Chandra     | [aruneshchandra](https://github.com/aruneshchandra)   |\n| Benjamin Byholm     | [kkoopa](https://github.com/kkoopa)                   |\n| Gabriel Schulhof    | [gabrielschulhof](https://github.com/gabrielschulhof) |\n| Hitesh Kanwathirtha | [digitalinfinity](https://github.com/digitalinfinity) |\n| Jason Ginchereau    | [jasongin](https://github.com/jasongin)               |\n| Jim Schlight        | [jschlight](https://github.com/jschlight)             |\n| Sampson Gao         | [sampsongao](https://github.com/sampsongao)           |\n| Taylor Woll         | [boingoing](https://github.com/boingoing)             |\n\n</details>\n\n## License\n\nLicensed under [MIT](./LICENSE.md)\n\n[Node-API support matrix]: https://nodejs.org/dist/latest/docs/api/n-api.html#n_api_n_api_version_matrix\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.689453125,
          "content": "environment:\n  # https://github.com/jasongin/nvs/blob/HEAD/doc/CI.md\n  NVS_VERSION: 1.4.2\n  matrix:\n    - NODEJS_VERSION: node/10\n    - NODEJS_VERSION: node/12\n    - NODEJS_VERSION: node/14\n    - NODEJS_VERSION: nightly\n\nos: Visual Studio 2017\nplatform:\n  - x86\n  - x64\n\ninstall:\n  # nvs\n  - git clone --branch v%NVS_VERSION% --depth 1 https://github.com/jasongin/nvs %LOCALAPPDATA%\\nvs\n  - set PATH=%LOCALAPPDATA%\\nvs;%PATH%\n  - nvs --version\n  # node.js\n  - nvs add %NODEJS_VERSION%/%PLATFORM%\n  - nvs use %NODEJS_VERSION%/%PLATFORM%\n  - node --version\n  - node -p process.arch\n  - npm --version\n  # app\n  - npm install\n\ntest_script:\n  - npm test\n\nbuild: off\n\nversion: \"{build}\"\n\ncache:\n  - node_modules\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "common.gypi",
          "type": "blob",
          "size": 0.7783203125,
          "content": "{\n  'variables': {\n    'NAPI_VERSION%': \"<!(node -p \\\"process.env.NAPI_VERSION || process.versions.napi\\\")\",\n    'disable_deprecated': \"<!(node -p \\\"process.env['npm_config_disable_deprecated']\\\")\"\n  },\n  'conditions': [\n    ['NAPI_VERSION!=\"\"', { 'defines': ['NAPI_VERSION=<@(NAPI_VERSION)'] } ],\n    ['NAPI_VERSION==2147483647', { 'defines': ['NAPI_EXPERIMENTAL'] } ],\n    ['disable_deprecated==\"true\"', {\n      'defines': ['NODE_ADDON_API_DISABLE_DEPRECATED']\n    }],\n    ['OS==\"mac\"', {\n      'cflags+': ['-fvisibility=hidden'],\n      'xcode_settings': {\n        'OTHER_CFLAGS': ['-fvisibility=hidden']\n      }\n    }]\n  ],\n  'cflags': [ '-Werror', '-Wall', '-Wextra', '-Wpedantic', '-Wunused-parameter' ],\n  'cflags_cc': [ '-Werror', '-Wall', '-Wextra', '-Wpedantic', '-Wunused-parameter' ]\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "eslint.config.js",
          "type": "blob",
          "size": 0.0732421875,
          "content": "'use strict';\n\nmodule.exports = require('neostandard')({\n  semi: true,\n});\n"
        },
        {
          "name": "except.gypi",
          "type": "blob",
          "size": 0.546875,
          "content": "{\n  'defines': [ 'NAPI_CPP_EXCEPTIONS' ],\n  'cflags!': [ '-fno-exceptions' ],\n  'cflags_cc!': [ '-fno-exceptions' ],\n  'conditions': [\n    [\"OS=='win'\", {\n      \"defines\": [\n        \"_HAS_EXCEPTIONS=1\"\n      ],\n      \"msvs_settings\": {\n        \"VCCLCompilerTool\": {\n          \"ExceptionHandling\": 1,\n          'EnablePREfast': 'true',\n        },\n      },\n    }],\n    [\"OS=='mac'\", {\n      'xcode_settings': {\n        'GCC_ENABLE_CPP_EXCEPTIONS': 'YES',\n        'CLANG_CXX_LIBRARY': 'libc++',\n        'MACOSX_DEPLOYMENT_TARGET': '10.7',\n      },\n    }],\n  ],\n}\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 0.4248046875,
          "content": "const path = require('path');\nconst { version } = require('./package.json');\n\nconst includeDir = path.relative('.', __dirname);\n\nmodule.exports = {\n  include: `\"${__dirname}\"`, // deprecated, can be removed as part of 4.0.0\n  include_dir: includeDir,\n  gyp: path.join(includeDir, 'node_api.gyp:nothing'), // deprecated.\n  targets: path.join(includeDir, 'node_addon_api.gyp'),\n  version,\n  isNodeApiBuiltin: true,\n  needsFlag: false\n};\n"
        },
        {
          "name": "napi-inl.deprecated.h",
          "type": "blob",
          "size": 6.1748046875,
          "content": "#ifndef SRC_NAPI_INL_DEPRECATED_H_\n#define SRC_NAPI_INL_DEPRECATED_H_\n\n////////////////////////////////////////////////////////////////////////////////\n// PropertyDescriptor class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    const char* utf8name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using CbData = details::CallbackData<Getter, Napi::Value>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({getter, nullptr});\n\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    const std::string& utf8name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor(utf8name.c_str(), getter, attributes, data);\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    napi_value name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using CbData = details::CallbackData<Getter, Napi::Value>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({getter, nullptr});\n\n  return PropertyDescriptor({nullptr,\n                             name,\n                             nullptr,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Name name, Getter getter, napi_property_attributes attributes, void* data) {\n  napi_value nameValue = name;\n  return PropertyDescriptor::Accessor(nameValue, getter, attributes, data);\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    const char* utf8name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using CbData = details::AccessorCallbackData<Getter, Setter>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({getter, setter, nullptr});\n\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             CbData::GetterWrapper,\n                             CbData::SetterWrapper,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    const std::string& utf8name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor(utf8name.c_str(), getter, setter, attributes, data);\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    napi_value name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using CbData = details::AccessorCallbackData<Getter, Setter>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({getter, setter, nullptr});\n\n  return PropertyDescriptor({nullptr,\n                             name,\n                             nullptr,\n                             CbData::GetterWrapper,\n                             CbData::SetterWrapper,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Name name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* data) {\n  napi_value nameValue = name;\n  return PropertyDescriptor::Accessor(\n      nameValue, getter, setter, attributes, data);\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    const char* utf8name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using ReturnType = decltype(cb(CallbackInfo(nullptr, nullptr)));\n  using CbData = details::CallbackData<Callable, ReturnType>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({cb, nullptr});\n\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    const std::string& utf8name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* data) {\n  return Function(utf8name.c_str(), cb, attributes, data);\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    napi_value name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* /*data*/) {\n  using ReturnType = decltype(cb(CallbackInfo(nullptr, nullptr)));\n  using CbData = details::CallbackData<Callable, ReturnType>;\n  // TODO: Delete when the function is destroyed\n  auto callbackData = new CbData({cb, nullptr});\n\n  return PropertyDescriptor({nullptr,\n                             name,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    Name name, Callable cb, napi_property_attributes attributes, void* data) {\n  napi_value nameValue = name;\n  return PropertyDescriptor::Function(nameValue, cb, attributes, data);\n}\n\n#endif  // !SRC_NAPI_INL_DEPRECATED_H_\n"
        },
        {
          "name": "napi-inl.h",
          "type": "blob",
          "size": 227.5419921875,
          "content": "#ifndef SRC_NAPI_INL_H_\n#define SRC_NAPI_INL_H_\n\n////////////////////////////////////////////////////////////////////////////////\n// Node-API C++ Wrapper Classes\n//\n// Inline header-only implementations for \"Node-API\" ABI-stable C APIs for\n// Node.js.\n////////////////////////////////////////////////////////////////////////////////\n\n// Note: Do not include this file directly! Include \"napi.h\" instead.\n// This should be a no-op and is intended for better IDE integration.\n#include \"napi.h\"\n\n#include <algorithm>\n#include <cstdarg>\n#include <cstring>\n#if NAPI_HAS_THREADS\n#include <mutex>\n#endif  // NAPI_HAS_THREADS\n#include <type_traits>\n#include <utility>\n\nnamespace Napi {\n\n#ifdef NAPI_CPP_CUSTOM_NAMESPACE\nnamespace NAPI_CPP_CUSTOM_NAMESPACE {\n#endif\n\n// Helpers to handle functions exposed from C++ and internal constants.\nnamespace details {\n\n// New napi_status constants not yet available in all supported versions of\n// Node.js releases. Only necessary when they are used in napi.h and napi-inl.h.\nconstexpr int napi_no_external_buffers_allowed = 22;\n\ntemplate <typename FreeType>\ninline void default_basic_finalizer(node_addon_api_basic_env /*env*/,\n                                    void* data,\n                                    void* /*hint*/) {\n  delete static_cast<FreeType*>(data);\n}\n\n// Attach a data item to an object and delete it when the object gets\n// garbage-collected.\n// TODO: Replace this code with `napi_add_finalizer()` whenever it becomes\n// available on all supported versions of Node.js.\ntemplate <\n    typename FreeType,\n    node_addon_api_basic_finalize finalizer = default_basic_finalizer<FreeType>>\ninline napi_status AttachData(napi_env env,\n                              napi_value obj,\n                              FreeType* data,\n                              void* hint = nullptr) {\n  napi_status status;\n#if (NAPI_VERSION < 5)\n  napi_value symbol, external;\n  status = napi_create_symbol(env, nullptr, &symbol);\n  if (status == napi_ok) {\n    status = napi_create_external(env, data, finalizer, hint, &external);\n    if (status == napi_ok) {\n      napi_property_descriptor desc = {nullptr,\n                                       symbol,\n                                       nullptr,\n                                       nullptr,\n                                       nullptr,\n                                       external,\n                                       napi_default,\n                                       nullptr};\n      status = napi_define_properties(env, obj, 1, &desc);\n    }\n  }\n#else  // NAPI_VERSION >= 5\n  status = napi_add_finalizer(env, obj, data, finalizer, hint, nullptr);\n#endif\n  return status;\n}\n\n// For use in JS to C++ callback wrappers to catch any Napi::Error exceptions\n// and rethrow them as JavaScript exceptions before returning from the callback.\ntemplate <typename Callable>\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS_ALL\ninline napi_value WrapCallback(napi_env env, Callable callback) {\n#else\ninline napi_value WrapCallback(napi_env, Callable callback) {\n#endif\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  try {\n    return callback();\n  } catch (const Error& e) {\n    e.ThrowAsJavaScriptException();\n    return nullptr;\n  }\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS_ALL\n  catch (const std::exception& e) {\n    Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();\n    return nullptr;\n  } catch (...) {\n    Napi::Error::New(env, \"A native exception was thrown\")\n        .ThrowAsJavaScriptException();\n    return nullptr;\n  }\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS_ALL\n#else   // NODE_ADDON_API_CPP_EXCEPTIONS\n  // When C++ exceptions are disabled, errors are immediately thrown as JS\n  // exceptions, so there is no need to catch and rethrow them here.\n  return callback();\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n}\n\n// For use in JS to C++ void callback wrappers to catch any Napi::Error\n// exceptions and rethrow them as JavaScript exceptions before returning from\n// the callback.\ntemplate <typename Callable>\ninline void WrapVoidCallback(Callable callback) {\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  try {\n    callback();\n  } catch (const Error& e) {\n    e.ThrowAsJavaScriptException();\n  }\n#else   // NAPI_CPP_EXCEPTIONS\n  // When C++ exceptions are disabled, errors are immediately thrown as JS\n  // exceptions, so there is no need to catch and rethrow them here.\n  callback();\n#endif  // NAPI_CPP_EXCEPTIONS\n}\n\n// For use in JS to C++ void callback wrappers to catch _any_ thrown exception\n// and rethrow them as JavaScript exceptions before returning from the callback,\n// wrapping in an Napi::Error as needed.\ntemplate <typename Callable>\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS_ALL\ninline void WrapVoidCallback(napi_env env, Callable callback) {\n#else\ninline void WrapVoidCallback(napi_env, Callable callback) {\n#endif\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  try {\n    callback();\n  } catch (const Error& e) {\n    e.ThrowAsJavaScriptException();\n  }\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS_ALL\n  catch (const std::exception& e) {\n    Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();\n  } catch (...) {\n    Napi::Error::New(env, \"A native exception was thrown\")\n        .ThrowAsJavaScriptException();\n  }\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS_ALL\n#else\n  // When C++ exceptions are disabled, there is no need to catch and rethrow C++\n  // exceptions. JS errors should be thrown with\n  // `Error::ThrowAsJavaScriptException`.\n  callback();\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n}\n\ntemplate <typename Callable, typename Return>\nstruct CallbackData {\n  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {\n    return details::WrapCallback(env, [&] {\n      CallbackInfo callbackInfo(env, info);\n      CallbackData* callbackData =\n          static_cast<CallbackData*>(callbackInfo.Data());\n      callbackInfo.SetData(callbackData->data);\n      return callbackData->callback(callbackInfo);\n    });\n  }\n\n  Callable callback;\n  void* data;\n};\n\ntemplate <typename Callable>\nstruct CallbackData<Callable, void> {\n  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {\n    return details::WrapCallback(env, [&] {\n      CallbackInfo callbackInfo(env, info);\n      CallbackData* callbackData =\n          static_cast<CallbackData*>(callbackInfo.Data());\n      callbackInfo.SetData(callbackData->data);\n      callbackData->callback(callbackInfo);\n      return nullptr;\n    });\n  }\n\n  Callable callback;\n  void* data;\n};\n\ntemplate <void (*Callback)(const CallbackInfo& info)>\nnapi_value TemplatedVoidCallback(napi_env env,\n                                 napi_callback_info info) NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo cbInfo(env, info);\n    Callback(cbInfo);\n    return nullptr;\n  });\n}\n\ntemplate <Napi::Value (*Callback)(const CallbackInfo& info)>\nnapi_value TemplatedCallback(napi_env env,\n                             napi_callback_info info) NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo cbInfo(env, info);\n    // MSVC requires to copy 'Callback' function pointer to a local variable\n    // before invoking it.\n    auto callback = Callback;\n    return callback(cbInfo);\n  });\n}\n\ntemplate <typename T,\n          Napi::Value (T::*UnwrapCallback)(const CallbackInfo& info)>\nnapi_value TemplatedInstanceCallback(napi_env env,\n                                     napi_callback_info info) NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo cbInfo(env, info);\n    T* instance = T::Unwrap(cbInfo.This().As<Object>());\n    return instance ? (instance->*UnwrapCallback)(cbInfo) : Napi::Value();\n  });\n}\n\ntemplate <typename T, void (T::*UnwrapCallback)(const CallbackInfo& info)>\nnapi_value TemplatedInstanceVoidCallback(napi_env env, napi_callback_info info)\n    NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo cbInfo(env, info);\n    T* instance = T::Unwrap(cbInfo.This().As<Object>());\n    if (instance) (instance->*UnwrapCallback)(cbInfo);\n    return nullptr;\n  });\n}\n\ntemplate <typename T, typename Finalizer, typename Hint = void>\nstruct FinalizeData {\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n  template <typename F = Finalizer,\n            typename = std::enable_if_t<\n                std::is_invocable_v<F, node_addon_api_basic_env, T*>>>\n#endif\n  static inline void Wrapper(node_addon_api_basic_env env,\n                             void* data,\n                             void* finalizeHint) NAPI_NOEXCEPT {\n    WrapVoidCallback([&] {\n      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);\n      finalizeData->callback(env, static_cast<T*>(data));\n      delete finalizeData;\n    });\n  }\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n  template <typename F = Finalizer,\n            typename = std::enable_if_t<\n                !std::is_invocable_v<F, node_addon_api_basic_env, T*>>,\n            typename = void>\n  static inline void Wrapper(node_addon_api_basic_env env,\n                             void* data,\n                             void* finalizeHint) NAPI_NOEXCEPT {\n#ifdef NODE_ADDON_API_REQUIRE_BASIC_FINALIZERS\n    static_assert(false,\n                  \"NODE_ADDON_API_REQUIRE_BASIC_FINALIZERS defined: Finalizer \"\n                  \"must be basic.\");\n#endif\n    napi_status status =\n        node_api_post_finalizer(env, WrapperGC, data, finalizeHint);\n    NAPI_FATAL_IF_FAILED(\n        status, \"FinalizeData::Wrapper\", \"node_api_post_finalizer failed\");\n  }\n#endif\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n  template <typename F = Finalizer,\n            typename = std::enable_if_t<\n                std::is_invocable_v<F, node_addon_api_basic_env, T*, Hint*>>>\n#endif\n  static inline void WrapperWithHint(node_addon_api_basic_env env,\n                                     void* data,\n                                     void* finalizeHint) NAPI_NOEXCEPT {\n    WrapVoidCallback([&] {\n      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);\n      finalizeData->callback(env, static_cast<T*>(data), finalizeData->hint);\n      delete finalizeData;\n    });\n  }\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n  template <typename F = Finalizer,\n            typename = std::enable_if_t<\n                !std::is_invocable_v<F, node_addon_api_basic_env, T*, Hint*>>,\n            typename = void>\n  static inline void WrapperWithHint(node_addon_api_basic_env env,\n                                     void* data,\n                                     void* finalizeHint) NAPI_NOEXCEPT {\n#ifdef NODE_ADDON_API_REQUIRE_BASIC_FINALIZERS\n    static_assert(false,\n                  \"NODE_ADDON_API_REQUIRE_BASIC_FINALIZERS defined: Finalizer \"\n                  \"must be basic.\");\n#endif\n    napi_status status =\n        node_api_post_finalizer(env, WrapperGCWithHint, data, finalizeHint);\n    NAPI_FATAL_IF_FAILED(\n        status, \"FinalizeData::Wrapper\", \"node_api_post_finalizer failed\");\n  }\n#endif\n\n  static inline void WrapperGCWithoutData(napi_env env,\n                                          void* /*data*/,\n                                          void* finalizeHint) NAPI_NOEXCEPT {\n    WrapVoidCallback(env, [&] {\n      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);\n      finalizeData->callback(env);\n      delete finalizeData;\n    });\n  }\n\n  static inline void WrapperGC(napi_env env,\n                               void* data,\n                               void* finalizeHint) NAPI_NOEXCEPT {\n    WrapVoidCallback(env, [&] {\n      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);\n      finalizeData->callback(env, static_cast<T*>(data));\n      delete finalizeData;\n    });\n  }\n\n  static inline void WrapperGCWithHint(napi_env env,\n                                       void* data,\n                                       void* finalizeHint) NAPI_NOEXCEPT {\n    WrapVoidCallback(env, [&] {\n      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);\n      finalizeData->callback(env, static_cast<T*>(data), finalizeData->hint);\n      delete finalizeData;\n    });\n  }\n\n  Finalizer callback;\n  Hint* hint;\n};\n\n#if (NAPI_VERSION > 3 && NAPI_HAS_THREADS)\ntemplate <typename ContextType = void,\n          typename Finalizer = std::function<void(Env, void*, ContextType*)>,\n          typename FinalizerDataType = void>\nstruct ThreadSafeFinalize {\n  static inline void Wrapper(napi_env env,\n                             void* rawFinalizeData,\n                             void* /* rawContext */) {\n    if (rawFinalizeData == nullptr) return;\n\n    ThreadSafeFinalize* finalizeData =\n        static_cast<ThreadSafeFinalize*>(rawFinalizeData);\n    finalizeData->callback(Env(env));\n    delete finalizeData;\n  }\n\n  static inline void FinalizeWrapperWithData(napi_env env,\n                                             void* rawFinalizeData,\n                                             void* /* rawContext */) {\n    if (rawFinalizeData == nullptr) return;\n\n    ThreadSafeFinalize* finalizeData =\n        static_cast<ThreadSafeFinalize*>(rawFinalizeData);\n    finalizeData->callback(Env(env), finalizeData->data);\n    delete finalizeData;\n  }\n\n  static inline void FinalizeWrapperWithContext(napi_env env,\n                                                void* rawFinalizeData,\n                                                void* rawContext) {\n    if (rawFinalizeData == nullptr) return;\n\n    ThreadSafeFinalize* finalizeData =\n        static_cast<ThreadSafeFinalize*>(rawFinalizeData);\n    finalizeData->callback(Env(env), static_cast<ContextType*>(rawContext));\n    delete finalizeData;\n  }\n\n  static inline void FinalizeFinalizeWrapperWithDataAndContext(\n      napi_env env, void* rawFinalizeData, void* rawContext) {\n    if (rawFinalizeData == nullptr) return;\n\n    ThreadSafeFinalize* finalizeData =\n        static_cast<ThreadSafeFinalize*>(rawFinalizeData);\n    finalizeData->callback(\n        Env(env), finalizeData->data, static_cast<ContextType*>(rawContext));\n    delete finalizeData;\n  }\n\n  FinalizerDataType* data;\n  Finalizer callback;\n};\n\ntemplate <typename ContextType, typename DataType, typename CallJs, CallJs call>\ninline typename std::enable_if<call != static_cast<CallJs>(nullptr)>::type\nCallJsWrapper(napi_env env, napi_value jsCallback, void* context, void* data) {\n  details::WrapVoidCallback(env, [&]() {\n    call(env,\n         Function(env, jsCallback),\n         static_cast<ContextType*>(context),\n         static_cast<DataType*>(data));\n  });\n}\n\ntemplate <typename ContextType, typename DataType, typename CallJs, CallJs call>\ninline typename std::enable_if<call == static_cast<CallJs>(nullptr)>::type\nCallJsWrapper(napi_env env,\n              napi_value jsCallback,\n              void* /*context*/,\n              void* /*data*/) {\n  details::WrapVoidCallback(env, [&]() {\n    if (jsCallback != nullptr) {\n      Function(env, jsCallback).Call(0, nullptr);\n    }\n  });\n}\n\n#if NAPI_VERSION > 4\n\ntemplate <typename CallbackType, typename TSFN>\nnapi_value DefaultCallbackWrapper(napi_env /*env*/, std::nullptr_t /*cb*/) {\n  return nullptr;\n}\n\ntemplate <typename CallbackType, typename TSFN>\nnapi_value DefaultCallbackWrapper(napi_env /*env*/, Napi::Function cb) {\n  return cb;\n}\n\n#else\ntemplate <typename CallbackType, typename TSFN>\nnapi_value DefaultCallbackWrapper(napi_env env, Napi::Function cb) {\n  if (cb.IsEmpty()) {\n    return TSFN::EmptyFunctionFactory(env);\n  }\n  return cb;\n}\n#endif  // NAPI_VERSION > 4\n#endif  // NAPI_VERSION > 3 && NAPI_HAS_THREADS\n\ntemplate <typename Getter, typename Setter>\nstruct AccessorCallbackData {\n  static inline napi_value GetterWrapper(napi_env env,\n                                         napi_callback_info info) {\n    return details::WrapCallback(env, [&] {\n      CallbackInfo callbackInfo(env, info);\n      AccessorCallbackData* callbackData =\n          static_cast<AccessorCallbackData*>(callbackInfo.Data());\n      callbackInfo.SetData(callbackData->data);\n      return callbackData->getterCallback(callbackInfo);\n    });\n  }\n\n  static inline napi_value SetterWrapper(napi_env env,\n                                         napi_callback_info info) {\n    return details::WrapCallback(env, [&] {\n      CallbackInfo callbackInfo(env, info);\n      AccessorCallbackData* callbackData =\n          static_cast<AccessorCallbackData*>(callbackInfo.Data());\n      callbackInfo.SetData(callbackData->data);\n      callbackData->setterCallback(callbackInfo);\n      return nullptr;\n    });\n  }\n\n  Getter getterCallback;\n  Setter setterCallback;\n  void* data;\n};\n\n// Debugging-purpose C++-style variant of sprintf().\ninline std::string StringFormat(const char* format, ...) {\n  std::string result;\n  va_list args;\n  va_start(args, format);\n  int len = vsnprintf(nullptr, 0, format, args);\n  result.resize(len);\n  vsnprintf(&result[0], len + 1, format, args);\n  va_end(args);\n  return result;\n}\n\ntemplate <typename T>\nclass HasExtendedFinalizer {\n private:\n  template <typename U, void (U::*)(Napi::Env)>\n  struct SFINAE {};\n  template <typename U>\n  static char test(SFINAE<U, &U::Finalize>*);\n  template <typename U>\n  static int test(...);\n\n public:\n  static constexpr bool value = sizeof(test<T>(0)) == sizeof(char);\n};\n\ntemplate <typename T>\nclass HasBasicFinalizer {\n private:\n  template <typename U, void (U::*)(Napi::BasicEnv)>\n  struct SFINAE {};\n  template <typename U>\n  static char test(SFINAE<U, &U::Finalize>*);\n  template <typename U>\n  static int test(...);\n\n public:\n  static constexpr bool value = sizeof(test<T>(0)) == sizeof(char);\n};\n\n}  // namespace details\n\n#ifndef NODE_ADDON_API_DISABLE_DEPRECATED\n#include \"napi-inl.deprecated.h\"\n#endif  // !NODE_ADDON_API_DISABLE_DEPRECATED\n\n////////////////////////////////////////////////////////////////////////////////\n// Module registration\n////////////////////////////////////////////////////////////////////////////////\n\n// Register an add-on based on an initializer function.\n#define NODE_API_MODULE(modname, regfunc)                                      \\\n  static napi_value __napi_##regfunc(napi_env env, napi_value exports) {       \\\n    return Napi::RegisterModule(env, exports, regfunc);                        \\\n  }                                                                            \\\n  NAPI_MODULE(modname, __napi_##regfunc)\n\n// Register an add-on based on a subclass of `Addon<T>` with a custom Node.js\n// module name.\n#define NODE_API_NAMED_ADDON(modname, classname)                               \\\n  static napi_value __napi_##classname(napi_env env, napi_value exports) {     \\\n    return Napi::RegisterModule(env, exports, &classname::Init);               \\\n  }                                                                            \\\n  NAPI_MODULE(modname, __napi_##classname)\n\n// Register an add-on based on a subclass of `Addon<T>` with the Node.js module\n// name given by node-gyp from the `target_name` in binding.gyp.\n#define NODE_API_ADDON(classname)                                              \\\n  NODE_API_NAMED_ADDON(NODE_GYP_MODULE_NAME, classname)\n\n// Adapt the NAPI_MODULE registration function:\n//  - Wrap the arguments in NAPI wrappers.\n//  - Catch any NAPI errors and rethrow as JS exceptions.\ninline napi_value RegisterModule(napi_env env,\n                                 napi_value exports,\n                                 ModuleRegisterCallback registerCallback) {\n  return details::WrapCallback(env, [&] {\n    return napi_value(\n        registerCallback(Napi::Env(env), Napi::Object(env, exports)));\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Maybe class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <class T>\nbool Maybe<T>::IsNothing() const {\n  return !_has_value;\n}\n\ntemplate <class T>\nbool Maybe<T>::IsJust() const {\n  return _has_value;\n}\n\ntemplate <class T>\nvoid Maybe<T>::Check() const {\n  NAPI_CHECK(IsJust(), \"Napi::Maybe::Check\", \"Maybe value is Nothing.\");\n}\n\ntemplate <class T>\nT Maybe<T>::Unwrap() const {\n  NAPI_CHECK(IsJust(), \"Napi::Maybe::Unwrap\", \"Maybe value is Nothing.\");\n  return _value;\n}\n\ntemplate <class T>\nT Maybe<T>::UnwrapOr(const T& default_value) const {\n  return _has_value ? _value : default_value;\n}\n\ntemplate <class T>\nbool Maybe<T>::UnwrapTo(T* out) const {\n  if (IsJust()) {\n    *out = _value;\n    return true;\n  };\n  return false;\n}\n\ntemplate <class T>\nbool Maybe<T>::operator==(const Maybe& other) const {\n  return (IsJust() == other.IsJust()) &&\n         (!IsJust() || Unwrap() == other.Unwrap());\n}\n\ntemplate <class T>\nbool Maybe<T>::operator!=(const Maybe& other) const {\n  return !operator==(other);\n}\n\ntemplate <class T>\nMaybe<T>::Maybe() : _has_value(false) {}\n\ntemplate <class T>\nMaybe<T>::Maybe(const T& t) : _has_value(true), _value(t) {}\n\ntemplate <class T>\ninline Maybe<T> Nothing() {\n  return Maybe<T>();\n}\n\ntemplate <class T>\ninline Maybe<T> Just(const T& t) {\n  return Maybe<T>(t);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// BasicEnv / Env class\n////////////////////////////////////////////////////////////////////////////////\n\ninline BasicEnv::BasicEnv(node_addon_api_basic_env env) : _env(env) {}\n\ninline BasicEnv::operator node_addon_api_basic_env() const {\n  return _env;\n}\n\ninline Env::Env(napi_env env) : BasicEnv(env) {}\n\ninline Env::operator napi_env() const {\n  return const_cast<napi_env>(_env);\n}\n\ninline Object Env::Global() const {\n  napi_value value;\n  napi_status status = napi_get_global(*this, &value);\n  NAPI_THROW_IF_FAILED(*this, status, Object());\n  return Object(*this, value);\n}\n\ninline Value Env::Undefined() const {\n  napi_value value;\n  napi_status status = napi_get_undefined(*this, &value);\n  NAPI_THROW_IF_FAILED(*this, status, Value());\n  return Value(*this, value);\n}\n\ninline Value Env::Null() const {\n  napi_value value;\n  napi_status status = napi_get_null(*this, &value);\n  NAPI_THROW_IF_FAILED(*this, status, Value());\n  return Value(*this, value);\n}\n\ninline bool Env::IsExceptionPending() const {\n  bool result;\n  napi_status status = napi_is_exception_pending(*this, &result);\n  if (status != napi_ok)\n    result = false;  // Checking for a pending exception shouldn't throw.\n  return result;\n}\n\ninline Error Env::GetAndClearPendingException() const {\n  napi_value value;\n  napi_status status = napi_get_and_clear_last_exception(*this, &value);\n  if (status != napi_ok) {\n    // Don't throw another exception when failing to get the exception!\n    return Error();\n  }\n  return Error(*this, value);\n}\n\ninline MaybeOrValue<Value> Env::RunScript(const char* utf8script) const {\n  String script = String::New(*this, utf8script);\n  return RunScript(script);\n}\n\ninline MaybeOrValue<Value> Env::RunScript(const std::string& utf8script) const {\n  return RunScript(utf8script.c_str());\n}\n\ninline MaybeOrValue<Value> Env::RunScript(String script) const {\n  napi_value result;\n  napi_status status = napi_run_script(*this, script, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      *this, status, Napi::Value(*this, result), Napi::Value);\n}\n\n#if NAPI_VERSION > 2\ntemplate <typename Hook, typename Arg>\nvoid BasicEnv::CleanupHook<Hook, Arg>::Wrapper(void* data) NAPI_NOEXCEPT {\n  auto* cleanupData = static_cast<\n      typename Napi::BasicEnv::CleanupHook<Hook, Arg>::CleanupData*>(data);\n  cleanupData->hook();\n  delete cleanupData;\n}\n\ntemplate <typename Hook, typename Arg>\nvoid BasicEnv::CleanupHook<Hook, Arg>::WrapperWithArg(void* data)\n    NAPI_NOEXCEPT {\n  auto* cleanupData = static_cast<\n      typename Napi::BasicEnv::CleanupHook<Hook, Arg>::CleanupData*>(data);\n  cleanupData->hook(static_cast<Arg*>(cleanupData->arg));\n  delete cleanupData;\n}\n#endif  // NAPI_VERSION > 2\n\n#if NAPI_VERSION > 5\ntemplate <typename T, BasicEnv::Finalizer<T> fini>\ninline void BasicEnv::SetInstanceData(T* data) const {\n  napi_status status = napi_set_instance_data(\n      _env,\n      data,\n      [](napi_env env, void* data, void*) { fini(env, static_cast<T*>(data)); },\n      nullptr);\n  NAPI_FATAL_IF_FAILED(\n      status, \"BasicEnv::SetInstanceData\", \"invalid arguments\");\n}\n\ntemplate <typename DataType,\n          typename HintType,\n          Napi::BasicEnv::FinalizerWithHint<DataType, HintType> fini>\ninline void BasicEnv::SetInstanceData(DataType* data, HintType* hint) const {\n  napi_status status = napi_set_instance_data(\n      _env,\n      data,\n      [](napi_env env, void* data, void* hint) {\n        fini(env, static_cast<DataType*>(data), static_cast<HintType*>(hint));\n      },\n      hint);\n  NAPI_FATAL_IF_FAILED(\n      status, \"BasicEnv::SetInstanceData\", \"invalid arguments\");\n}\n\ntemplate <typename T>\ninline T* BasicEnv::GetInstanceData() const {\n  void* data = nullptr;\n\n  napi_status status = napi_get_instance_data(_env, &data);\n  NAPI_FATAL_IF_FAILED(\n      status, \"BasicEnv::GetInstanceData\", \"invalid arguments\");\n\n  return static_cast<T*>(data);\n}\n\ntemplate <typename T>\nvoid BasicEnv::DefaultFini(Env, T* data) {\n  delete data;\n}\n\ntemplate <typename DataType, typename HintType>\nvoid BasicEnv::DefaultFiniWithHint(Env, DataType* data, HintType*) {\n  delete data;\n}\n#endif  // NAPI_VERSION > 5\n\n#if NAPI_VERSION > 8\ninline const char* BasicEnv::GetModuleFileName() const {\n  const char* result;\n  napi_status status = node_api_get_module_file_name(_env, &result);\n  NAPI_FATAL_IF_FAILED(\n      status, \"BasicEnv::GetModuleFileName\", \"invalid arguments\");\n  return result;\n}\n#endif  // NAPI_VERSION > 8\n////////////////////////////////////////////////////////////////////////////////\n// Value class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Value::Value() : _env(nullptr), _value(nullptr) {}\n\ninline Value::Value(napi_env env, napi_value value)\n    : _env(env), _value(value) {}\n\ninline Value::operator napi_value() const {\n  return _value;\n}\n\ninline bool Value::operator==(const Value& other) const {\n  return StrictEquals(other);\n}\n\ninline bool Value::operator!=(const Value& other) const {\n  return !this->operator==(other);\n}\n\ninline bool Value::StrictEquals(const Value& other) const {\n  bool result;\n  napi_status status = napi_strict_equals(_env, *this, other, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline Napi::Env Value::Env() const {\n  return Napi::Env(_env);\n}\n\ninline bool Value::IsEmpty() const {\n  return _value == nullptr;\n}\n\ninline napi_valuetype Value::Type() const {\n  if (IsEmpty()) {\n    return napi_undefined;\n  }\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(_env, _value, &type);\n  NAPI_THROW_IF_FAILED(_env, status, napi_undefined);\n  return type;\n}\n\ninline bool Value::IsUndefined() const {\n  return Type() == napi_undefined;\n}\n\ninline bool Value::IsNull() const {\n  return Type() == napi_null;\n}\n\ninline bool Value::IsBoolean() const {\n  return Type() == napi_boolean;\n}\n\ninline bool Value::IsNumber() const {\n  return Type() == napi_number;\n}\n\n#if NAPI_VERSION > 5\ninline bool Value::IsBigInt() const {\n  return Type() == napi_bigint;\n}\n#endif  // NAPI_VERSION > 5\n\n#if (NAPI_VERSION > 4)\ninline bool Value::IsDate() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_date(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n#endif\n\ninline bool Value::IsString() const {\n  return Type() == napi_string;\n}\n\ninline bool Value::IsSymbol() const {\n  return Type() == napi_symbol;\n}\n\ninline bool Value::IsArray() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_array(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsArrayBuffer() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_arraybuffer(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsTypedArray() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_typedarray(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsObject() const {\n  return Type() == napi_object || IsFunction();\n}\n\ninline bool Value::IsFunction() const {\n  return Type() == napi_function;\n}\n\ninline bool Value::IsPromise() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_promise(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsDataView() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_dataview(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsBuffer() const {\n  if (IsEmpty()) {\n    return false;\n  }\n\n  bool result;\n  napi_status status = napi_is_buffer(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\ninline bool Value::IsExternal() const {\n  return Type() == napi_external;\n}\n\ntemplate <typename T>\ninline T Value::As() const {\n#ifdef NODE_ADDON_API_ENABLE_TYPE_CHECK_ON_AS\n  T::CheckCast(_env, _value);\n#endif\n  return T(_env, _value);\n}\n\ntemplate <typename T>\ninline T Value::UnsafeAs() const {\n  return T(_env, _value);\n}\n\n// static\ninline void Value::CheckCast(napi_env /* env */, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Value::CheckCast\", \"empty value\");\n}\n\ninline MaybeOrValue<Boolean> Value::ToBoolean() const {\n  napi_value result;\n  napi_status status = napi_coerce_to_bool(_env, _value, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Boolean(_env, result), Napi::Boolean);\n}\n\ninline MaybeOrValue<Number> Value::ToNumber() const {\n  napi_value result;\n  napi_status status = napi_coerce_to_number(_env, _value, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Number(_env, result), Napi::Number);\n}\n\ninline MaybeOrValue<String> Value::ToString() const {\n  napi_value result;\n  napi_status status = napi_coerce_to_string(_env, _value, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::String(_env, result), Napi::String);\n}\n\ninline MaybeOrValue<Object> Value::ToObject() const {\n  napi_value result;\n  napi_status status = napi_coerce_to_object(_env, _value, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Object(_env, result), Napi::Object);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Boolean class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Boolean Boolean::New(napi_env env, bool val) {\n  napi_value value;\n  napi_status status = napi_get_boolean(env, val, &value);\n  NAPI_THROW_IF_FAILED(env, status, Boolean());\n  return Boolean(env, value);\n}\n\ninline void Boolean::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Boolean::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Boolean::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_boolean, \"%d\", \"Boolean::CheckCast\");\n}\n\ninline Boolean::Boolean() : Napi::Value() {}\n\ninline Boolean::Boolean(napi_env env, napi_value value)\n    : Napi::Value(env, value) {}\n\ninline Boolean::operator bool() const {\n  return Value();\n}\n\ninline bool Boolean::Value() const {\n  bool result;\n  napi_status status = napi_get_value_bool(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Number class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Number Number::New(napi_env env, double val) {\n  napi_value value;\n  napi_status status = napi_create_double(env, val, &value);\n  NAPI_THROW_IF_FAILED(env, status, Number());\n  return Number(env, value);\n}\n\ninline void Number::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Number::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Number::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_number, \"%d\", \"Number::CheckCast\");\n}\n\ninline Number::Number() : Value() {}\n\ninline Number::Number(napi_env env, napi_value value) : Value(env, value) {}\n\ninline Number::operator int32_t() const {\n  return Int32Value();\n}\n\ninline Number::operator uint32_t() const {\n  return Uint32Value();\n}\n\ninline Number::operator int64_t() const {\n  return Int64Value();\n}\n\ninline Number::operator float() const {\n  return FloatValue();\n}\n\ninline Number::operator double() const {\n  return DoubleValue();\n}\n\ninline int32_t Number::Int32Value() const {\n  int32_t result;\n  napi_status status = napi_get_value_int32(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ninline uint32_t Number::Uint32Value() const {\n  uint32_t result;\n  napi_status status = napi_get_value_uint32(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ninline int64_t Number::Int64Value() const {\n  int64_t result;\n  napi_status status = napi_get_value_int64(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ninline float Number::FloatValue() const {\n  return static_cast<float>(DoubleValue());\n}\n\ninline double Number::DoubleValue() const {\n  double result;\n  napi_status status = napi_get_value_double(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\n#if NAPI_VERSION > 5\n////////////////////////////////////////////////////////////////////////////////\n// BigInt Class\n////////////////////////////////////////////////////////////////////////////////\n\ninline BigInt BigInt::New(napi_env env, int64_t val) {\n  napi_value value;\n  napi_status status = napi_create_bigint_int64(env, val, &value);\n  NAPI_THROW_IF_FAILED(env, status, BigInt());\n  return BigInt(env, value);\n}\n\ninline BigInt BigInt::New(napi_env env, uint64_t val) {\n  napi_value value;\n  napi_status status = napi_create_bigint_uint64(env, val, &value);\n  NAPI_THROW_IF_FAILED(env, status, BigInt());\n  return BigInt(env, value);\n}\n\ninline BigInt BigInt::New(napi_env env,\n                          int sign_bit,\n                          size_t word_count,\n                          const uint64_t* words) {\n  napi_value value;\n  napi_status status =\n      napi_create_bigint_words(env, sign_bit, word_count, words, &value);\n  NAPI_THROW_IF_FAILED(env, status, BigInt());\n  return BigInt(env, value);\n}\n\ninline void BigInt::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"BigInt::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"BigInt::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_bigint, \"%d\", \"BigInt::CheckCast\");\n}\n\ninline BigInt::BigInt() : Value() {}\n\ninline BigInt::BigInt(napi_env env, napi_value value) : Value(env, value) {}\n\ninline int64_t BigInt::Int64Value(bool* lossless) const {\n  int64_t result;\n  napi_status status =\n      napi_get_value_bigint_int64(_env, _value, &result, lossless);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ninline uint64_t BigInt::Uint64Value(bool* lossless) const {\n  uint64_t result;\n  napi_status status =\n      napi_get_value_bigint_uint64(_env, _value, &result, lossless);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ninline size_t BigInt::WordCount() const {\n  size_t word_count;\n  napi_status status =\n      napi_get_value_bigint_words(_env, _value, nullptr, &word_count, nullptr);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return word_count;\n}\n\ninline void BigInt::ToWords(int* sign_bit,\n                            size_t* word_count,\n                            uint64_t* words) {\n  napi_status status =\n      napi_get_value_bigint_words(_env, _value, sign_bit, word_count, words);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n#endif  // NAPI_VERSION > 5\n\n#if (NAPI_VERSION > 4)\n////////////////////////////////////////////////////////////////////////////////\n// Date Class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Date Date::New(napi_env env, double val) {\n  napi_value value;\n  napi_status status = napi_create_date(env, val, &value);\n  NAPI_THROW_IF_FAILED(env, status, Date());\n  return Date(env, value);\n}\n\ninline void Date::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Date::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_date(env, value, &result);\n  NAPI_CHECK(status == napi_ok, \"Date::CheckCast\", \"napi_is_date failed\");\n  NAPI_CHECK(result, \"Date::CheckCast\", \"value is not date\");\n}\n\ninline Date::Date() : Value() {}\n\ninline Date::Date(napi_env env, napi_value value) : Value(env, value) {}\n\ninline Date::operator double() const {\n  return ValueOf();\n}\n\ninline double Date::ValueOf() const {\n  double result;\n  napi_status status = napi_get_date_value(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n// Name class\n////////////////////////////////////////////////////////////////////////////////\ninline void Name::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Name::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Name::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK(type == napi_string || type == napi_symbol,\n                      \"Name::CheckCast\",\n                      \"value is not napi_string or napi_symbol, got %d.\",\n                      type);\n}\n\ninline Name::Name() : Value() {}\n\ninline Name::Name(napi_env env, napi_value value) : Value(env, value) {}\n\n////////////////////////////////////////////////////////////////////////////////\n// String class\n////////////////////////////////////////////////////////////////////////////////\n\ninline String String::New(napi_env env, const std::string& val) {\n  return String::New(env, val.c_str(), val.size());\n}\n\ninline String String::New(napi_env env, const std::u16string& val) {\n  return String::New(env, val.c_str(), val.size());\n}\n\ninline String String::New(napi_env env, const char* val) {\n  // TODO(@gabrielschulhof) Remove if-statement when core's error handling is\n  // available in all supported versions.\n  if (val == nullptr) {\n    // Throw an error that looks like it came from core.\n    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, String());\n  }\n  napi_value value;\n  napi_status status =\n      napi_create_string_utf8(env, val, std::strlen(val), &value);\n  NAPI_THROW_IF_FAILED(env, status, String());\n  return String(env, value);\n}\n\ninline String String::New(napi_env env, const char16_t* val) {\n  napi_value value;\n  // TODO(@gabrielschulhof) Remove if-statement when core's error handling is\n  // available in all supported versions.\n  if (val == nullptr) {\n    // Throw an error that looks like it came from core.\n    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, String());\n  }\n  napi_status status =\n      napi_create_string_utf16(env, val, std::u16string(val).size(), &value);\n  NAPI_THROW_IF_FAILED(env, status, String());\n  return String(env, value);\n}\n\ninline String String::New(napi_env env, const char* val, size_t length) {\n  napi_value value;\n  napi_status status = napi_create_string_utf8(env, val, length, &value);\n  NAPI_THROW_IF_FAILED(env, status, String());\n  return String(env, value);\n}\n\ninline String String::New(napi_env env, const char16_t* val, size_t length) {\n  napi_value value;\n  napi_status status = napi_create_string_utf16(env, val, length, &value);\n  NAPI_THROW_IF_FAILED(env, status, String());\n  return String(env, value);\n}\n\ninline void String::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"String::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"String::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_string, \"%d\", \"String::CheckCast\");\n}\n\ninline String::String() : Name() {}\n\ninline String::String(napi_env env, napi_value value) : Name(env, value) {}\n\ninline String::operator std::string() const {\n  return Utf8Value();\n}\n\ninline String::operator std::u16string() const {\n  return Utf16Value();\n}\n\ninline std::string String::Utf8Value() const {\n  size_t length;\n  napi_status status =\n      napi_get_value_string_utf8(_env, _value, nullptr, 0, &length);\n  NAPI_THROW_IF_FAILED(_env, status, \"\");\n\n  std::string value;\n  value.reserve(length + 1);\n  value.resize(length);\n  status = napi_get_value_string_utf8(\n      _env, _value, &value[0], value.capacity(), nullptr);\n  NAPI_THROW_IF_FAILED(_env, status, \"\");\n  return value;\n}\n\ninline std::u16string String::Utf16Value() const {\n  size_t length;\n  napi_status status =\n      napi_get_value_string_utf16(_env, _value, nullptr, 0, &length);\n  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(\"\"));\n\n  std::u16string value;\n  value.reserve(length + 1);\n  value.resize(length);\n  status = napi_get_value_string_utf16(\n      _env, _value, &value[0], value.capacity(), nullptr);\n  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(\"\"));\n  return value;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Symbol class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Symbol Symbol::New(napi_env env, const char* description) {\n  napi_value descriptionValue = description != nullptr\n                                    ? String::New(env, description)\n                                    : static_cast<napi_value>(nullptr);\n  return Symbol::New(env, descriptionValue);\n}\n\ninline Symbol Symbol::New(napi_env env, const std::string& description) {\n  napi_value descriptionValue = String::New(env, description);\n  return Symbol::New(env, descriptionValue);\n}\n\ninline Symbol Symbol::New(napi_env env, String description) {\n  napi_value descriptionValue = description;\n  return Symbol::New(env, descriptionValue);\n}\n\ninline Symbol Symbol::New(napi_env env, napi_value description) {\n  napi_value value;\n  napi_status status = napi_create_symbol(env, description, &value);\n  NAPI_THROW_IF_FAILED(env, status, Symbol());\n  return Symbol(env, value);\n}\n\ninline MaybeOrValue<Symbol> Symbol::WellKnown(napi_env env,\n                                              const std::string& name) {\n  // No need to check if the return value is a symbol or undefined.\n  // Well known symbols are definite and it is an develop time error\n  // if the symbol does not exist.\n#if defined(NODE_ADDON_API_ENABLE_MAYBE)\n  Value symbol_obj;\n  Value symbol_value;\n  if (Napi::Env(env).Global().Get(\"Symbol\").UnwrapTo(&symbol_obj) &&\n      symbol_obj.As<Object>().Get(name).UnwrapTo(&symbol_value)) {\n    return Just<Symbol>(symbol_value.UnsafeAs<Symbol>());\n  }\n  return Nothing<Symbol>();\n#else\n  return Napi::Env(env)\n      .Global()\n      .Get(\"Symbol\")\n      .As<Object>()\n      .Get(name)\n      .UnsafeAs<Symbol>();\n#endif\n}\n\ninline MaybeOrValue<Symbol> Symbol::For(napi_env env,\n                                        const std::string& description) {\n  napi_value descriptionValue = String::New(env, description);\n  return Symbol::For(env, descriptionValue);\n}\n\ninline MaybeOrValue<Symbol> Symbol::For(napi_env env, const char* description) {\n  napi_value descriptionValue = String::New(env, description);\n  return Symbol::For(env, descriptionValue);\n}\n\ninline MaybeOrValue<Symbol> Symbol::For(napi_env env, String description) {\n  return Symbol::For(env, static_cast<napi_value>(description));\n}\n\ninline MaybeOrValue<Symbol> Symbol::For(napi_env env, napi_value description) {\n#if defined(NODE_ADDON_API_ENABLE_MAYBE)\n  Value symbol_obj;\n  Value symbol_for_value;\n  Value symbol_value;\n  if (Napi::Env(env).Global().Get(\"Symbol\").UnwrapTo(&symbol_obj) &&\n      symbol_obj.As<Object>().Get(\"for\").UnwrapTo(&symbol_for_value) &&\n      symbol_for_value.As<Function>()\n          .Call(symbol_obj, {description})\n          .UnwrapTo(&symbol_value)) {\n    return Just<Symbol>(symbol_value.As<Symbol>());\n  }\n  return Nothing<Symbol>();\n#else\n  Object symbol_obj = Napi::Env(env).Global().Get(\"Symbol\").As<Object>();\n  return symbol_obj.Get(\"for\")\n      .As<Function>()\n      .Call(symbol_obj, {description})\n      .As<Symbol>();\n#endif\n}\n\ninline void Symbol::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Symbol::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Symbol::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_symbol, \"%d\", \"Symbol::CheckCast\");\n}\n\ninline Symbol::Symbol() : Name() {}\n\ninline Symbol::Symbol(napi_env env, napi_value value) : Name(env, value) {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Automagic value creation\n////////////////////////////////////////////////////////////////////////////////\n\nnamespace details {\ntemplate <typename T>\nstruct vf_number {\n  static Number From(napi_env env, T value) {\n    return Number::New(env, static_cast<double>(value));\n  }\n};\n\ntemplate <>\nstruct vf_number<bool> {\n  static Boolean From(napi_env env, bool value) {\n    return Boolean::New(env, value);\n  }\n};\n\nstruct vf_utf8_charp {\n  static String From(napi_env env, const char* value) {\n    return String::New(env, value);\n  }\n};\n\nstruct vf_utf16_charp {\n  static String From(napi_env env, const char16_t* value) {\n    return String::New(env, value);\n  }\n};\nstruct vf_utf8_string {\n  static String From(napi_env env, const std::string& value) {\n    return String::New(env, value);\n  }\n};\n\nstruct vf_utf16_string {\n  static String From(napi_env env, const std::u16string& value) {\n    return String::New(env, value);\n  }\n};\n\ntemplate <typename T>\nstruct vf_fallback {\n  static Value From(napi_env env, const T& value) { return Value(env, value); }\n};\n\ntemplate <typename...>\nstruct disjunction : std::false_type {};\ntemplate <typename B>\nstruct disjunction<B> : B {};\ntemplate <typename B, typename... Bs>\nstruct disjunction<B, Bs...>\n    : std::conditional<bool(B::value), B, disjunction<Bs...>>::type {};\n\ntemplate <typename T>\nstruct can_make_string\n    : disjunction<typename std::is_convertible<T, const char*>::type,\n                  typename std::is_convertible<T, const char16_t*>::type,\n                  typename std::is_convertible<T, std::string>::type,\n                  typename std::is_convertible<T, std::u16string>::type> {};\n}  // namespace details\n\ntemplate <typename T>\nValue Value::From(napi_env env, const T& value) {\n  using Helper = typename std::conditional<\n      std::is_integral<T>::value || std::is_floating_point<T>::value,\n      details::vf_number<T>,\n      typename std::conditional<details::can_make_string<T>::value,\n                                String,\n                                details::vf_fallback<T>>::type>::type;\n  return Helper::From(env, value);\n}\n\ntemplate <typename T>\nString String::From(napi_env env, const T& value) {\n  struct Dummy {};\n  using Helper = typename std::conditional<\n      std::is_convertible<T, const char*>::value,\n      details::vf_utf8_charp,\n      typename std::conditional<\n          std::is_convertible<T, const char16_t*>::value,\n          details::vf_utf16_charp,\n          typename std::conditional<\n              std::is_convertible<T, std::string>::value,\n              details::vf_utf8_string,\n              typename std::conditional<\n                  std::is_convertible<T, std::u16string>::value,\n                  details::vf_utf16_string,\n                  Dummy>::type>::type>::type>::type;\n  return Helper::From(env, value);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// TypeTaggable class\n////////////////////////////////////////////////////////////////////////////////\n\ninline TypeTaggable::TypeTaggable() : Value() {}\n\ninline TypeTaggable::TypeTaggable(napi_env _env, napi_value _value)\n    : Value(_env, _value) {}\n\n#if NAPI_VERSION >= 8\n\ninline void TypeTaggable::TypeTag(const napi_type_tag* type_tag) const {\n  napi_status status = napi_type_tag_object(_env, _value, type_tag);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline bool TypeTaggable::CheckTypeTag(const napi_type_tag* type_tag) const {\n  bool result;\n  napi_status status =\n      napi_check_object_type_tag(_env, _value, type_tag, &result);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return result;\n}\n\n#endif  // NAPI_VERSION >= 8\n\n////////////////////////////////////////////////////////////////////////////////\n// Object class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename Key>\ninline Object::PropertyLValue<Key>::operator Value() const {\n  MaybeOrValue<Value> val = Object(_env, _object).Get(_key);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  return val.Unwrap();\n#else\n  return val;\n#endif\n}\n\ntemplate <typename Key>\ntemplate <typename ValueType>\ninline Object::PropertyLValue<Key>& Object::PropertyLValue<Key>::operator=(\n    ValueType value) {\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  MaybeOrValue<bool> result =\n#endif\n      Object(_env, _object).Set(_key, value);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  result.Unwrap();\n#endif\n  return *this;\n}\n\ntemplate <typename Key>\ninline Object::PropertyLValue<Key>::PropertyLValue(Object object, Key key)\n    : _env(object.Env()), _object(object), _key(key) {}\n\ninline Object Object::New(napi_env env) {\n  napi_value value;\n  napi_status status = napi_create_object(env, &value);\n  NAPI_THROW_IF_FAILED(env, status, Object());\n  return Object(env, value);\n}\n\ninline void Object::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Object::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Object::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK(type == napi_object || type == napi_function,\n                      \"Object::CheckCast\",\n                      \"Expect napi_object or napi_function, but got %d.\",\n                      type);\n}\n\ninline Object::Object() : TypeTaggable() {}\n\ninline Object::Object(napi_env env, napi_value value)\n    : TypeTaggable(env, value) {}\n\ninline Object::PropertyLValue<std::string> Object::operator[](\n    const char* utf8name) {\n  return PropertyLValue<std::string>(*this, utf8name);\n}\n\ninline Object::PropertyLValue<std::string> Object::operator[](\n    const std::string& utf8name) {\n  return PropertyLValue<std::string>(*this, utf8name);\n}\n\ninline Object::PropertyLValue<uint32_t> Object::operator[](uint32_t index) {\n  return PropertyLValue<uint32_t>(*this, index);\n}\n\ninline Object::PropertyLValue<Value> Object::operator[](Value index) const {\n  return PropertyLValue<Value>(*this, index);\n}\n\ninline MaybeOrValue<Value> Object::operator[](const char* utf8name) const {\n  return Get(utf8name);\n}\n\ninline MaybeOrValue<Value> Object::operator[](\n    const std::string& utf8name) const {\n  return Get(utf8name);\n}\n\ninline MaybeOrValue<Value> Object::operator[](uint32_t index) const {\n  return Get(index);\n}\n\ninline MaybeOrValue<bool> Object::Has(napi_value key) const {\n  bool result;\n  napi_status status = napi_has_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::Has(Value key) const {\n  bool result;\n  napi_status status = napi_has_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::Has(const char* utf8name) const {\n  bool result;\n  napi_status status = napi_has_named_property(_env, _value, utf8name, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::Has(const std::string& utf8name) const {\n  return Has(utf8name.c_str());\n}\n\ninline MaybeOrValue<bool> Object::HasOwnProperty(napi_value key) const {\n  bool result;\n  napi_status status = napi_has_own_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::HasOwnProperty(Value key) const {\n  bool result;\n  napi_status status = napi_has_own_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::HasOwnProperty(const char* utf8name) const {\n  napi_value key;\n  napi_status status =\n      napi_create_string_utf8(_env, utf8name, std::strlen(utf8name), &key);\n  NAPI_MAYBE_THROW_IF_FAILED(_env, status, bool);\n  return HasOwnProperty(key);\n}\n\ninline MaybeOrValue<bool> Object::HasOwnProperty(\n    const std::string& utf8name) const {\n  return HasOwnProperty(utf8name.c_str());\n}\n\ninline MaybeOrValue<Value> Object::Get(napi_value key) const {\n  napi_value result;\n  napi_status status = napi_get_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);\n}\n\ninline MaybeOrValue<Value> Object::Get(Value key) const {\n  napi_value result;\n  napi_status status = napi_get_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);\n}\n\ninline MaybeOrValue<Value> Object::Get(const char* utf8name) const {\n  napi_value result;\n  napi_status status = napi_get_named_property(_env, _value, utf8name, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);\n}\n\ninline MaybeOrValue<Value> Object::Get(const std::string& utf8name) const {\n  return Get(utf8name.c_str());\n}\n\ntemplate <typename ValueType>\ninline MaybeOrValue<bool> Object::Set(napi_value key,\n                                      const ValueType& value) const {\n  napi_status status =\n      napi_set_property(_env, _value, key, Value::From(_env, value));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ntemplate <typename ValueType>\ninline MaybeOrValue<bool> Object::Set(Value key, const ValueType& value) const {\n  napi_status status =\n      napi_set_property(_env, _value, key, Value::From(_env, value));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ntemplate <typename ValueType>\ninline MaybeOrValue<bool> Object::Set(const char* utf8name,\n                                      const ValueType& value) const {\n  napi_status status =\n      napi_set_named_property(_env, _value, utf8name, Value::From(_env, value));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ntemplate <typename ValueType>\ninline MaybeOrValue<bool> Object::Set(const std::string& utf8name,\n                                      const ValueType& value) const {\n  return Set(utf8name.c_str(), value);\n}\n\ninline MaybeOrValue<bool> Object::Delete(napi_value key) const {\n  bool result;\n  napi_status status = napi_delete_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::Delete(Value key) const {\n  bool result;\n  napi_status status = napi_delete_property(_env, _value, key, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<bool> Object::Delete(const char* utf8name) const {\n  return Delete(String::New(_env, utf8name));\n}\n\ninline MaybeOrValue<bool> Object::Delete(const std::string& utf8name) const {\n  return Delete(String::New(_env, utf8name));\n}\n\ninline MaybeOrValue<bool> Object::Has(uint32_t index) const {\n  bool result;\n  napi_status status = napi_has_element(_env, _value, index, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<Value> Object::Get(uint32_t index) const {\n  napi_value value;\n  napi_status status = napi_get_element(_env, _value, index, &value);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, value), Value);\n}\n\ntemplate <typename ValueType>\ninline MaybeOrValue<bool> Object::Set(uint32_t index,\n                                      const ValueType& value) const {\n  napi_status status =\n      napi_set_element(_env, _value, index, Value::From(_env, value));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ninline MaybeOrValue<bool> Object::Delete(uint32_t index) const {\n  bool result;\n  napi_status status = napi_delete_element(_env, _value, index, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ninline MaybeOrValue<Array> Object::GetPropertyNames() const {\n  napi_value result;\n  napi_status status = napi_get_property_names(_env, _value, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Array(_env, result), Array);\n}\n\ninline MaybeOrValue<bool> Object::DefineProperty(\n    const PropertyDescriptor& property) const {\n  napi_status status = napi_define_properties(\n      _env,\n      _value,\n      1,\n      reinterpret_cast<const napi_property_descriptor*>(&property));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ninline MaybeOrValue<bool> Object::DefineProperties(\n    const std::initializer_list<PropertyDescriptor>& properties) const {\n  napi_status status = napi_define_properties(\n      _env,\n      _value,\n      properties.size(),\n      reinterpret_cast<const napi_property_descriptor*>(properties.begin()));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ninline MaybeOrValue<bool> Object::DefineProperties(\n    const std::vector<PropertyDescriptor>& properties) const {\n  napi_status status = napi_define_properties(\n      _env,\n      _value,\n      properties.size(),\n      reinterpret_cast<const napi_property_descriptor*>(properties.data()));\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ninline MaybeOrValue<bool> Object::InstanceOf(\n    const Function& constructor) const {\n  bool result;\n  napi_status status = napi_instanceof(_env, _value, constructor, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, bool);\n}\n\ntemplate <typename Finalizer, typename T>\ninline void Object::AddFinalizer(Finalizer finalizeCallback, T* data) const {\n  details::FinalizeData<T, Finalizer>* finalizeData =\n      new details::FinalizeData<T, Finalizer>(\n          {std::move(finalizeCallback), nullptr});\n  napi_status status =\n      details::AttachData<T, details::FinalizeData<T, Finalizer>::Wrapper>(\n          _env, *this, data, finalizeData);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n  }\n}\n\ntemplate <typename Finalizer, typename T, typename Hint>\ninline void Object::AddFinalizer(Finalizer finalizeCallback,\n                                 T* data,\n                                 Hint* finalizeHint) const {\n  details::FinalizeData<T, Finalizer, Hint>* finalizeData =\n      new details::FinalizeData<T, Finalizer, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n  napi_status status = details::\n      AttachData<T, details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint>(\n          _env, *this, data, finalizeData);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n  }\n}\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\ninline Object::const_iterator::const_iterator(const Object* object,\n                                              const Type type) {\n  _object = object;\n  _keys = object->GetPropertyNames();\n  _index = type == Type::BEGIN ? 0 : _keys.Length();\n}\n\ninline Object::const_iterator Napi::Object::begin() const {\n  const_iterator it(this, Object::const_iterator::Type::BEGIN);\n  return it;\n}\n\ninline Object::const_iterator Napi::Object::end() const {\n  const_iterator it(this, Object::const_iterator::Type::END);\n  return it;\n}\n\ninline Object::const_iterator& Object::const_iterator::operator++() {\n  ++_index;\n  return *this;\n}\n\ninline bool Object::const_iterator::operator==(\n    const const_iterator& other) const {\n  return _index == other._index;\n}\n\ninline bool Object::const_iterator::operator!=(\n    const const_iterator& other) const {\n  return _index != other._index;\n}\n\ninline const std::pair<Value, Object::PropertyLValue<Value>>\nObject::const_iterator::operator*() const {\n  const Value key = _keys[_index];\n  const PropertyLValue<Value> value = (*_object)[key];\n  return {key, value};\n}\n\ninline Object::iterator::iterator(Object* object, const Type type) {\n  _object = object;\n  _keys = object->GetPropertyNames();\n  _index = type == Type::BEGIN ? 0 : _keys.Length();\n}\n\ninline Object::iterator Napi::Object::begin() {\n  iterator it(this, Object::iterator::Type::BEGIN);\n  return it;\n}\n\ninline Object::iterator Napi::Object::end() {\n  iterator it(this, Object::iterator::Type::END);\n  return it;\n}\n\ninline Object::iterator& Object::iterator::operator++() {\n  ++_index;\n  return *this;\n}\n\ninline bool Object::iterator::operator==(const iterator& other) const {\n  return _index == other._index;\n}\n\ninline bool Object::iterator::operator!=(const iterator& other) const {\n  return _index != other._index;\n}\n\ninline std::pair<Value, Object::PropertyLValue<Value>>\nObject::iterator::operator*() {\n  Value key = _keys[_index];\n  PropertyLValue<Value> value = (*_object)[key];\n  return {key, value};\n}\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n#if NAPI_VERSION >= 8\ninline MaybeOrValue<bool> Object::Freeze() const {\n  napi_status status = napi_object_freeze(_env, _value);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n\ninline MaybeOrValue<bool> Object::Seal() const {\n  napi_status status = napi_object_seal(_env, _value);\n  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, bool);\n}\n#endif  // NAPI_VERSION >= 8\n\n////////////////////////////////////////////////////////////////////////////////\n// External class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline External<T> External<T>::New(napi_env env, T* data) {\n  napi_value value;\n  napi_status status =\n      napi_create_external(env, data, nullptr, nullptr, &value);\n  NAPI_THROW_IF_FAILED(env, status, External());\n  return External(env, value);\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer>\ninline External<T> External<T>::New(napi_env env,\n                                    T* data,\n                                    Finalizer finalizeCallback) {\n  napi_value value;\n  details::FinalizeData<T, Finalizer>* finalizeData =\n      new details::FinalizeData<T, Finalizer>(\n          {std::move(finalizeCallback), nullptr});\n  napi_status status =\n      napi_create_external(env,\n                           data,\n                           details::FinalizeData<T, Finalizer>::Wrapper,\n                           finalizeData,\n                           &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, External());\n  }\n  return External(env, value);\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer, typename Hint>\ninline External<T> External<T>::New(napi_env env,\n                                    T* data,\n                                    Finalizer finalizeCallback,\n                                    Hint* finalizeHint) {\n  napi_value value;\n  details::FinalizeData<T, Finalizer, Hint>* finalizeData =\n      new details::FinalizeData<T, Finalizer, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n  napi_status status = napi_create_external(\n      env,\n      data,\n      details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint,\n      finalizeData,\n      &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, External());\n  }\n  return External(env, value);\n}\n\ntemplate <typename T>\ninline void External<T>::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"External::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"External::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_external, \"%d\", \"External::CheckCast\");\n}\n\ntemplate <typename T>\ninline External<T>::External() : TypeTaggable() {}\n\ntemplate <typename T>\ninline External<T>::External(napi_env env, napi_value value)\n    : TypeTaggable(env, value) {}\n\ntemplate <typename T>\ninline T* External<T>::Data() const {\n  void* data;\n  napi_status status = napi_get_value_external(_env, _value, &data);\n  NAPI_THROW_IF_FAILED(_env, status, nullptr);\n  return reinterpret_cast<T*>(data);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Array class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Array Array::New(napi_env env) {\n  napi_value value;\n  napi_status status = napi_create_array(env, &value);\n  NAPI_THROW_IF_FAILED(env, status, Array());\n  return Array(env, value);\n}\n\ninline Array Array::New(napi_env env, size_t length) {\n  napi_value value;\n  napi_status status = napi_create_array_with_length(env, length, &value);\n  NAPI_THROW_IF_FAILED(env, status, Array());\n  return Array(env, value);\n}\n\ninline void Array::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Array::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_array(env, value, &result);\n  NAPI_CHECK(status == napi_ok, \"Array::CheckCast\", \"napi_is_array failed\");\n  NAPI_CHECK(result, \"Array::CheckCast\", \"value is not array\");\n}\n\ninline Array::Array() : Object() {}\n\ninline Array::Array(napi_env env, napi_value value) : Object(env, value) {}\n\ninline uint32_t Array::Length() const {\n  uint32_t result;\n  napi_status status = napi_get_array_length(_env, _value, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ArrayBuffer class\n////////////////////////////////////////////////////////////////////////////////\n\ninline ArrayBuffer ArrayBuffer::New(napi_env env, size_t byteLength) {\n  napi_value value;\n  void* data;\n  napi_status status = napi_create_arraybuffer(env, byteLength, &data, &value);\n  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());\n\n  return ArrayBuffer(env, value);\n}\n\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\ninline ArrayBuffer ArrayBuffer::New(napi_env env,\n                                    void* externalData,\n                                    size_t byteLength) {\n  napi_value value;\n  napi_status status = napi_create_external_arraybuffer(\n      env, externalData, byteLength, nullptr, nullptr, &value);\n  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());\n\n  return ArrayBuffer(env, value);\n}\n\ntemplate <typename Finalizer>\ninline ArrayBuffer ArrayBuffer::New(napi_env env,\n                                    void* externalData,\n                                    size_t byteLength,\n                                    Finalizer finalizeCallback) {\n  napi_value value;\n  details::FinalizeData<void, Finalizer>* finalizeData =\n      new details::FinalizeData<void, Finalizer>(\n          {std::move(finalizeCallback), nullptr});\n  napi_status status = napi_create_external_arraybuffer(\n      env,\n      externalData,\n      byteLength,\n      details::FinalizeData<void, Finalizer>::Wrapper,\n      finalizeData,\n      &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());\n  }\n\n  return ArrayBuffer(env, value);\n}\n\ntemplate <typename Finalizer, typename Hint>\ninline ArrayBuffer ArrayBuffer::New(napi_env env,\n                                    void* externalData,\n                                    size_t byteLength,\n                                    Finalizer finalizeCallback,\n                                    Hint* finalizeHint) {\n  napi_value value;\n  details::FinalizeData<void, Finalizer, Hint>* finalizeData =\n      new details::FinalizeData<void, Finalizer, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n  napi_status status = napi_create_external_arraybuffer(\n      env,\n      externalData,\n      byteLength,\n      details::FinalizeData<void, Finalizer, Hint>::WrapperWithHint,\n      finalizeData,\n      &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());\n  }\n\n  return ArrayBuffer(env, value);\n}\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n\ninline void ArrayBuffer::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"ArrayBuffer::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_arraybuffer(env, value, &result);\n  NAPI_CHECK(status == napi_ok,\n             \"ArrayBuffer::CheckCast\",\n             \"napi_is_arraybuffer failed\");\n  NAPI_CHECK(result, \"ArrayBuffer::CheckCast\", \"value is not arraybuffer\");\n}\n\ninline ArrayBuffer::ArrayBuffer() : Object() {}\n\ninline ArrayBuffer::ArrayBuffer(napi_env env, napi_value value)\n    : Object(env, value) {}\n\ninline void* ArrayBuffer::Data() {\n  void* data;\n  napi_status status = napi_get_arraybuffer_info(_env, _value, &data, nullptr);\n  NAPI_THROW_IF_FAILED(_env, status, nullptr);\n  return data;\n}\n\ninline size_t ArrayBuffer::ByteLength() {\n  size_t length;\n  napi_status status =\n      napi_get_arraybuffer_info(_env, _value, nullptr, &length);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return length;\n}\n\n#if NAPI_VERSION >= 7\ninline bool ArrayBuffer::IsDetached() const {\n  bool detached;\n  napi_status status = napi_is_detached_arraybuffer(_env, _value, &detached);\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return detached;\n}\n\ninline void ArrayBuffer::Detach() {\n  napi_status status = napi_detach_arraybuffer(_env, _value);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n#endif  // NAPI_VERSION >= 7\n\n////////////////////////////////////////////////////////////////////////////////\n// DataView class\n////////////////////////////////////////////////////////////////////////////////\ninline DataView DataView::New(napi_env env, Napi::ArrayBuffer arrayBuffer) {\n  return New(env, arrayBuffer, 0, arrayBuffer.ByteLength());\n}\n\ninline DataView DataView::New(napi_env env,\n                              Napi::ArrayBuffer arrayBuffer,\n                              size_t byteOffset) {\n  if (byteOffset > arrayBuffer.ByteLength()) {\n    NAPI_THROW(RangeError::New(\n                   env, \"Start offset is outside the bounds of the buffer\"),\n               DataView());\n  }\n  return New(\n      env, arrayBuffer, byteOffset, arrayBuffer.ByteLength() - byteOffset);\n}\n\ninline DataView DataView::New(napi_env env,\n                              Napi::ArrayBuffer arrayBuffer,\n                              size_t byteOffset,\n                              size_t byteLength) {\n  if (byteOffset + byteLength > arrayBuffer.ByteLength()) {\n    NAPI_THROW(RangeError::New(env, \"Invalid DataView length\"), DataView());\n  }\n  napi_value value;\n  napi_status status =\n      napi_create_dataview(env, byteLength, arrayBuffer, byteOffset, &value);\n  NAPI_THROW_IF_FAILED(env, status, DataView());\n  return DataView(env, value);\n}\n\ninline void DataView::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"DataView::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_dataview(env, value, &result);\n  NAPI_CHECK(\n      status == napi_ok, \"DataView::CheckCast\", \"napi_is_dataview failed\");\n  NAPI_CHECK(result, \"DataView::CheckCast\", \"value is not dataview\");\n}\n\ninline DataView::DataView() : Object() {}\n\ninline DataView::DataView(napi_env env, napi_value value) : Object(env, value) {\n  napi_status status = napi_get_dataview_info(_env,\n                                              _value /* dataView */,\n                                              &_length /* byteLength */,\n                                              &_data /* data */,\n                                              nullptr /* arrayBuffer */,\n                                              nullptr /* byteOffset */);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline Napi::ArrayBuffer DataView::ArrayBuffer() const {\n  napi_value arrayBuffer;\n  napi_status status = napi_get_dataview_info(_env,\n                                              _value /* dataView */,\n                                              nullptr /* byteLength */,\n                                              nullptr /* data */,\n                                              &arrayBuffer /* arrayBuffer */,\n                                              nullptr /* byteOffset */);\n  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());\n  return Napi::ArrayBuffer(_env, arrayBuffer);\n}\n\ninline size_t DataView::ByteOffset() const {\n  size_t byteOffset;\n  napi_status status = napi_get_dataview_info(_env,\n                                              _value /* dataView */,\n                                              nullptr /* byteLength */,\n                                              nullptr /* data */,\n                                              nullptr /* arrayBuffer */,\n                                              &byteOffset /* byteOffset */);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return byteOffset;\n}\n\ninline size_t DataView::ByteLength() const {\n  return _length;\n}\n\ninline void* DataView::Data() const {\n  return _data;\n}\n\ninline float DataView::GetFloat32(size_t byteOffset) const {\n  return ReadData<float>(byteOffset);\n}\n\ninline double DataView::GetFloat64(size_t byteOffset) const {\n  return ReadData<double>(byteOffset);\n}\n\ninline int8_t DataView::GetInt8(size_t byteOffset) const {\n  return ReadData<int8_t>(byteOffset);\n}\n\ninline int16_t DataView::GetInt16(size_t byteOffset) const {\n  return ReadData<int16_t>(byteOffset);\n}\n\ninline int32_t DataView::GetInt32(size_t byteOffset) const {\n  return ReadData<int32_t>(byteOffset);\n}\n\ninline uint8_t DataView::GetUint8(size_t byteOffset) const {\n  return ReadData<uint8_t>(byteOffset);\n}\n\ninline uint16_t DataView::GetUint16(size_t byteOffset) const {\n  return ReadData<uint16_t>(byteOffset);\n}\n\ninline uint32_t DataView::GetUint32(size_t byteOffset) const {\n  return ReadData<uint32_t>(byteOffset);\n}\n\ninline void DataView::SetFloat32(size_t byteOffset, float value) const {\n  WriteData<float>(byteOffset, value);\n}\n\ninline void DataView::SetFloat64(size_t byteOffset, double value) const {\n  WriteData<double>(byteOffset, value);\n}\n\ninline void DataView::SetInt8(size_t byteOffset, int8_t value) const {\n  WriteData<int8_t>(byteOffset, value);\n}\n\ninline void DataView::SetInt16(size_t byteOffset, int16_t value) const {\n  WriteData<int16_t>(byteOffset, value);\n}\n\ninline void DataView::SetInt32(size_t byteOffset, int32_t value) const {\n  WriteData<int32_t>(byteOffset, value);\n}\n\ninline void DataView::SetUint8(size_t byteOffset, uint8_t value) const {\n  WriteData<uint8_t>(byteOffset, value);\n}\n\ninline void DataView::SetUint16(size_t byteOffset, uint16_t value) const {\n  WriteData<uint16_t>(byteOffset, value);\n}\n\ninline void DataView::SetUint32(size_t byteOffset, uint32_t value) const {\n  WriteData<uint32_t>(byteOffset, value);\n}\n\ntemplate <typename T>\ninline T DataView::ReadData(size_t byteOffset) const {\n  if (byteOffset + sizeof(T) > _length ||\n      byteOffset + sizeof(T) < byteOffset) {  // overflow\n    NAPI_THROW(\n        RangeError::New(_env, \"Offset is outside the bounds of the DataView\"),\n        0);\n  }\n\n  return *reinterpret_cast<T*>(static_cast<uint8_t*>(_data) + byteOffset);\n}\n\ntemplate <typename T>\ninline void DataView::WriteData(size_t byteOffset, T value) const {\n  if (byteOffset + sizeof(T) > _length ||\n      byteOffset + sizeof(T) < byteOffset) {  // overflow\n    NAPI_THROW_VOID(\n        RangeError::New(_env, \"Offset is outside the bounds of the DataView\"));\n  }\n\n  *reinterpret_cast<T*>(static_cast<uint8_t*>(_data) + byteOffset) = value;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// TypedArray class\n////////////////////////////////////////////////////////////////////////////////\ninline void TypedArray::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"TypedArray::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_typedarray(env, value, &result);\n  NAPI_CHECK(\n      status == napi_ok, \"TypedArray::CheckCast\", \"napi_is_typedarray failed\");\n  NAPI_CHECK(result, \"TypedArray::CheckCast\", \"value is not typedarray\");\n}\n\ninline TypedArray::TypedArray()\n    : Object(), _type(napi_typedarray_type::napi_int8_array), _length(0) {}\n\ninline TypedArray::TypedArray(napi_env env, napi_value value)\n    : Object(env, value),\n      _type(napi_typedarray_type::napi_int8_array),\n      _length(0) {\n  if (value != nullptr) {\n    napi_status status =\n        napi_get_typedarray_info(_env,\n                                 _value,\n                                 &const_cast<TypedArray*>(this)->_type,\n                                 &const_cast<TypedArray*>(this)->_length,\n                                 nullptr,\n                                 nullptr,\n                                 nullptr);\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n  }\n}\n\ninline TypedArray::TypedArray(napi_env env,\n                              napi_value value,\n                              napi_typedarray_type type,\n                              size_t length)\n    : Object(env, value), _type(type), _length(length) {}\n\ninline napi_typedarray_type TypedArray::TypedArrayType() const {\n  return _type;\n}\n\ninline uint8_t TypedArray::ElementSize() const {\n  switch (_type) {\n    case napi_int8_array:\n    case napi_uint8_array:\n    case napi_uint8_clamped_array:\n      return 1;\n    case napi_int16_array:\n    case napi_uint16_array:\n      return 2;\n    case napi_int32_array:\n    case napi_uint32_array:\n    case napi_float32_array:\n      return 4;\n    case napi_float64_array:\n#if (NAPI_VERSION > 5)\n    case napi_bigint64_array:\n    case napi_biguint64_array:\n#endif  // (NAPI_VERSION > 5)\n      return 8;\n    default:\n      return 0;\n  }\n}\n\ninline size_t TypedArray::ElementLength() const {\n  return _length;\n}\n\ninline size_t TypedArray::ByteOffset() const {\n  size_t byteOffset;\n  napi_status status = napi_get_typedarray_info(\n      _env, _value, nullptr, nullptr, nullptr, nullptr, &byteOffset);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return byteOffset;\n}\n\ninline size_t TypedArray::ByteLength() const {\n  return ElementSize() * ElementLength();\n}\n\ninline Napi::ArrayBuffer TypedArray::ArrayBuffer() const {\n  napi_value arrayBuffer;\n  napi_status status = napi_get_typedarray_info(\n      _env, _value, nullptr, nullptr, nullptr, &arrayBuffer, nullptr);\n  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());\n  return Napi::ArrayBuffer(_env, arrayBuffer);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// TypedArrayOf<T> class\n////////////////////////////////////////////////////////////////////////////////\ntemplate <typename T>\ninline void TypedArrayOf<T>::CheckCast(napi_env env, napi_value value) {\n  TypedArray::CheckCast(env, value);\n  napi_typedarray_type type;\n  napi_status status = napi_get_typedarray_info(\n      env, value, &type, nullptr, nullptr, nullptr, nullptr);\n  NAPI_CHECK(status == napi_ok,\n             \"TypedArrayOf::CheckCast\",\n             \"napi_is_typedarray failed\");\n\n  NAPI_INTERNAL_CHECK(\n      (type == TypedArrayTypeForPrimitiveType<T>() ||\n       (type == napi_uint8_clamped_array && std::is_same<T, uint8_t>::value)),\n      \"TypedArrayOf::CheckCast\",\n      \"Array type must match the template parameter, (Uint8 arrays may \"\n      \"optionally have the \\\"clamped\\\" array type.), got %d.\",\n      type);\n}\n\ntemplate <typename T>\ninline TypedArrayOf<T> TypedArrayOf<T>::New(napi_env env,\n                                            size_t elementLength,\n                                            napi_typedarray_type type) {\n  Napi::ArrayBuffer arrayBuffer =\n      Napi::ArrayBuffer::New(env, elementLength * sizeof(T));\n  return New(env, elementLength, arrayBuffer, 0, type);\n}\n\ntemplate <typename T>\ninline TypedArrayOf<T> TypedArrayOf<T>::New(napi_env env,\n                                            size_t elementLength,\n                                            Napi::ArrayBuffer arrayBuffer,\n                                            size_t bufferOffset,\n                                            napi_typedarray_type type) {\n  napi_value value;\n  napi_status status = napi_create_typedarray(\n      env, type, elementLength, arrayBuffer, bufferOffset, &value);\n  NAPI_THROW_IF_FAILED(env, status, TypedArrayOf<T>());\n\n  return TypedArrayOf<T>(\n      env,\n      value,\n      type,\n      elementLength,\n      reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(arrayBuffer.Data()) +\n                           bufferOffset));\n}\n\ntemplate <typename T>\ninline TypedArrayOf<T>::TypedArrayOf() : TypedArray(), _data(nullptr) {}\n\ntemplate <typename T>\ninline TypedArrayOf<T>::TypedArrayOf(napi_env env, napi_value value)\n    : TypedArray(env, value), _data(nullptr) {\n  napi_status status = napi_ok;\n  if (value != nullptr) {\n    void* data = nullptr;\n    status = napi_get_typedarray_info(\n        _env, _value, &_type, &_length, &data, nullptr, nullptr);\n    _data = static_cast<T*>(data);\n  } else {\n    _type = TypedArrayTypeForPrimitiveType<T>();\n    _length = 0;\n  }\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ntemplate <typename T>\ninline TypedArrayOf<T>::TypedArrayOf(napi_env env,\n                                     napi_value value,\n                                     napi_typedarray_type type,\n                                     size_t length,\n                                     T* data)\n    : TypedArray(env, value, type, length), _data(data) {\n  if (!(type == TypedArrayTypeForPrimitiveType<T>() ||\n        (type == napi_uint8_clamped_array &&\n         std::is_same<T, uint8_t>::value))) {\n    NAPI_THROW_VOID(TypeError::New(\n        env,\n        \"Array type must match the template parameter. \"\n        \"(Uint8 arrays may optionally have the \\\"clamped\\\" array type.)\"));\n  }\n}\n\ntemplate <typename T>\ninline T& TypedArrayOf<T>::operator[](size_t index) {\n  return _data[index];\n}\n\ntemplate <typename T>\ninline const T& TypedArrayOf<T>::operator[](size_t index) const {\n  return _data[index];\n}\n\ntemplate <typename T>\ninline T* TypedArrayOf<T>::Data() {\n  return _data;\n}\n\ntemplate <typename T>\ninline const T* TypedArrayOf<T>::Data() const {\n  return _data;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Function class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename CbData>\ninline napi_status CreateFunction(napi_env env,\n                                  const char* utf8name,\n                                  napi_callback cb,\n                                  CbData* data,\n                                  napi_value* result) {\n  napi_status status =\n      napi_create_function(env, utf8name, NAPI_AUTO_LENGTH, cb, data, result);\n  if (status == napi_ok) {\n    status = Napi::details::AttachData(env, *result, data);\n  }\n\n  return status;\n}\n\ntemplate <Function::VoidCallback cb>\ninline Function Function::New(napi_env env, const char* utf8name, void* data) {\n  napi_value result = nullptr;\n  napi_status status = napi_create_function(env,\n                                            utf8name,\n                                            NAPI_AUTO_LENGTH,\n                                            details::TemplatedVoidCallback<cb>,\n                                            data,\n                                            &result);\n  NAPI_THROW_IF_FAILED(env, status, Function());\n  return Function(env, result);\n}\n\ntemplate <Function::Callback cb>\ninline Function Function::New(napi_env env, const char* utf8name, void* data) {\n  napi_value result = nullptr;\n  napi_status status = napi_create_function(env,\n                                            utf8name,\n                                            NAPI_AUTO_LENGTH,\n                                            details::TemplatedCallback<cb>,\n                                            data,\n                                            &result);\n  NAPI_THROW_IF_FAILED(env, status, Function());\n  return Function(env, result);\n}\n\ntemplate <Function::VoidCallback cb>\ninline Function Function::New(napi_env env,\n                              const std::string& utf8name,\n                              void* data) {\n  return Function::New<cb>(env, utf8name.c_str(), data);\n}\n\ntemplate <Function::Callback cb>\ninline Function Function::New(napi_env env,\n                              const std::string& utf8name,\n                              void* data) {\n  return Function::New<cb>(env, utf8name.c_str(), data);\n}\n\ntemplate <typename Callable>\ninline Function Function::New(napi_env env,\n                              Callable cb,\n                              const char* utf8name,\n                              void* data) {\n  using ReturnType = decltype(cb(CallbackInfo(nullptr, nullptr)));\n  using CbData = details::CallbackData<Callable, ReturnType>;\n  auto callbackData = new CbData{std::move(cb), data};\n\n  napi_value value;\n  napi_status status =\n      CreateFunction(env, utf8name, CbData::Wrapper, callbackData, &value);\n  if (status != napi_ok) {\n    delete callbackData;\n    NAPI_THROW_IF_FAILED(env, status, Function());\n  }\n\n  return Function(env, value);\n}\n\ntemplate <typename Callable>\ninline Function Function::New(napi_env env,\n                              Callable cb,\n                              const std::string& utf8name,\n                              void* data) {\n  return New(env, cb, utf8name.c_str(), data);\n}\n\ninline void Function::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Function::CheckCast\", \"empty value\");\n\n  napi_valuetype type;\n  napi_status status = napi_typeof(env, value, &type);\n  NAPI_CHECK(status == napi_ok, \"Function::CheckCast\", \"napi_typeof failed\");\n  NAPI_INTERNAL_CHECK_EQ(type, napi_function, \"%d\", \"Function::CheckCast\");\n}\n\ninline Function::Function() : Object() {}\n\ninline Function::Function(napi_env env, napi_value value)\n    : Object(env, value) {}\n\ninline MaybeOrValue<Value> Function::operator()(\n    const std::initializer_list<napi_value>& args) const {\n  return Call(Env().Undefined(), args);\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    const std::initializer_list<napi_value>& args) const {\n  return Call(Env().Undefined(), args);\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    const std::vector<napi_value>& args) const {\n  return Call(Env().Undefined(), args);\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    const std::vector<Value>& args) const {\n  return Call(Env().Undefined(), args);\n}\n\ninline MaybeOrValue<Value> Function::Call(size_t argc,\n                                          const napi_value* args) const {\n  return Call(Env().Undefined(), argc, args);\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    napi_value recv, const std::initializer_list<napi_value>& args) const {\n  return Call(recv, args.size(), args.begin());\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    napi_value recv, const std::vector<napi_value>& args) const {\n  return Call(recv, args.size(), args.data());\n}\n\ninline MaybeOrValue<Value> Function::Call(\n    napi_value recv, const std::vector<Value>& args) const {\n  const size_t argc = args.size();\n  const size_t stackArgsCount = 6;\n  napi_value stackArgs[stackArgsCount];\n  std::vector<napi_value> heapArgs;\n  napi_value* argv;\n  if (argc <= stackArgsCount) {\n    argv = stackArgs;\n  } else {\n    heapArgs.resize(argc);\n    argv = heapArgs.data();\n  }\n\n  for (size_t index = 0; index < argc; index++) {\n    argv[index] = static_cast<napi_value>(args[index]);\n  }\n\n  return Call(recv, argc, argv);\n}\n\ninline MaybeOrValue<Value> Function::Call(napi_value recv,\n                                          size_t argc,\n                                          const napi_value* args) const {\n  napi_value result;\n  napi_status status =\n      napi_call_function(_env, recv, _value, argc, args, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Value(_env, result), Napi::Value);\n}\n\ninline MaybeOrValue<Value> Function::MakeCallback(\n    napi_value recv,\n    const std::initializer_list<napi_value>& args,\n    napi_async_context context) const {\n  return MakeCallback(recv, args.size(), args.begin(), context);\n}\n\ninline MaybeOrValue<Value> Function::MakeCallback(\n    napi_value recv,\n    const std::vector<napi_value>& args,\n    napi_async_context context) const {\n  return MakeCallback(recv, args.size(), args.data(), context);\n}\n\ninline MaybeOrValue<Value> Function::MakeCallback(\n    napi_value recv,\n    size_t argc,\n    const napi_value* args,\n    napi_async_context context) const {\n  napi_value result;\n  napi_status status =\n      napi_make_callback(_env, context, recv, _value, argc, args, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Value(_env, result), Napi::Value);\n}\n\ninline MaybeOrValue<Object> Function::New(\n    const std::initializer_list<napi_value>& args) const {\n  return New(args.size(), args.begin());\n}\n\ninline MaybeOrValue<Object> Function::New(\n    const std::vector<napi_value>& args) const {\n  return New(args.size(), args.data());\n}\n\ninline MaybeOrValue<Object> Function::New(size_t argc,\n                                          const napi_value* args) const {\n  napi_value result;\n  napi_status status = napi_new_instance(_env, _value, argc, args, &result);\n  NAPI_RETURN_OR_THROW_IF_FAILED(\n      _env, status, Napi::Object(_env, result), Napi::Object);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Promise class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Promise::Deferred Promise::Deferred::New(napi_env env) {\n  return Promise::Deferred(env);\n}\n\ninline Promise::Deferred::Deferred(napi_env env) : _env(env) {\n  napi_status status = napi_create_promise(_env, &_deferred, &_promise);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline Promise Promise::Deferred::Promise() const {\n  return Napi::Promise(_env, _promise);\n}\n\ninline Napi::Env Promise::Deferred::Env() const {\n  return Napi::Env(_env);\n}\n\ninline void Promise::Deferred::Resolve(napi_value value) const {\n  napi_status status = napi_resolve_deferred(_env, _deferred, value);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline void Promise::Deferred::Reject(napi_value value) const {\n  napi_status status = napi_reject_deferred(_env, _deferred, value);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline void Promise::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Promise::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_promise(env, value, &result);\n  NAPI_CHECK(status == napi_ok, \"Promise::CheckCast\", \"napi_is_promise failed\");\n  NAPI_CHECK(result, \"Promise::CheckCast\", \"value is not promise\");\n}\n\ninline Promise::Promise(napi_env env, napi_value value) : Object(env, value) {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Buffer<T> class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline Buffer<T> Buffer<T>::New(napi_env env, size_t length) {\n  napi_value value;\n  void* data;\n  napi_status status =\n      napi_create_buffer(env, length * sizeof(T), &data, &value);\n  NAPI_THROW_IF_FAILED(env, status, Buffer<T>());\n  return Buffer(env, value);\n}\n\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\ntemplate <typename T>\ninline Buffer<T> Buffer<T>::New(napi_env env, T* data, size_t length) {\n  napi_value value;\n  napi_status status = napi_create_external_buffer(\n      env, length * sizeof(T), data, nullptr, nullptr, &value);\n  NAPI_THROW_IF_FAILED(env, status, Buffer<T>());\n  return Buffer(env, value);\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer>\ninline Buffer<T> Buffer<T>::New(napi_env env,\n                                T* data,\n                                size_t length,\n                                Finalizer finalizeCallback) {\n  napi_value value;\n  details::FinalizeData<T, Finalizer>* finalizeData =\n      new details::FinalizeData<T, Finalizer>(\n          {std::move(finalizeCallback), nullptr});\n  napi_status status =\n      napi_create_external_buffer(env,\n                                  length * sizeof(T),\n                                  data,\n                                  details::FinalizeData<T, Finalizer>::Wrapper,\n                                  finalizeData,\n                                  &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, Buffer());\n  }\n  return Buffer(env, value);\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer, typename Hint>\ninline Buffer<T> Buffer<T>::New(napi_env env,\n                                T* data,\n                                size_t length,\n                                Finalizer finalizeCallback,\n                                Hint* finalizeHint) {\n  napi_value value;\n  details::FinalizeData<T, Finalizer, Hint>* finalizeData =\n      new details::FinalizeData<T, Finalizer, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n  napi_status status = napi_create_external_buffer(\n      env,\n      length * sizeof(T),\n      data,\n      details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint,\n      finalizeData,\n      &value);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, Buffer());\n  }\n  return Buffer(env, value);\n}\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n\ntemplate <typename T>\ninline Buffer<T> Buffer<T>::NewOrCopy(napi_env env, T* data, size_t length) {\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  napi_value value;\n  napi_status status = napi_create_external_buffer(\n      env, length * sizeof(T), data, nullptr, nullptr, &value);\n  if (status == details::napi_no_external_buffers_allowed) {\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n    // If we can't create an external buffer, we'll just copy the data.\n    return Buffer<T>::Copy(env, data, length);\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  }\n  NAPI_THROW_IF_FAILED(env, status, Buffer<T>());\n  return Buffer(env, value);\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer>\ninline Buffer<T> Buffer<T>::NewOrCopy(napi_env env,\n                                      T* data,\n                                      size_t length,\n                                      Finalizer finalizeCallback) {\n  details::FinalizeData<T, Finalizer>* finalizeData =\n      new details::FinalizeData<T, Finalizer>(\n          {std::move(finalizeCallback), nullptr});\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  napi_value value;\n  napi_status status =\n      napi_create_external_buffer(env,\n                                  length * sizeof(T),\n                                  data,\n                                  details::FinalizeData<T, Finalizer>::Wrapper,\n                                  finalizeData,\n                                  &value);\n  if (status == details::napi_no_external_buffers_allowed) {\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n    // If we can't create an external buffer, we'll just copy the data.\n    Buffer<T> ret = Buffer<T>::Copy(env, data, length);\n    details::FinalizeData<T, Finalizer>::WrapperGC(env, data, finalizeData);\n    return ret;\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  }\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, Buffer());\n  }\n  return Buffer(env, value);\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n}\n\ntemplate <typename T>\ntemplate <typename Finalizer, typename Hint>\ninline Buffer<T> Buffer<T>::NewOrCopy(napi_env env,\n                                      T* data,\n                                      size_t length,\n                                      Finalizer finalizeCallback,\n                                      Hint* finalizeHint) {\n  details::FinalizeData<T, Finalizer, Hint>* finalizeData =\n      new details::FinalizeData<T, Finalizer, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  napi_value value;\n  napi_status status = napi_create_external_buffer(\n      env,\n      length * sizeof(T),\n      data,\n      details::FinalizeData<T, Finalizer, Hint>::WrapperWithHint,\n      finalizeData,\n      &value);\n  if (status == details::napi_no_external_buffers_allowed) {\n#endif\n    // If we can't create an external buffer, we'll just copy the data.\n    Buffer<T> ret = Buffer<T>::Copy(env, data, length);\n    details::FinalizeData<T, Finalizer, Hint>::WrapperGCWithHint(\n        env, data, finalizeData);\n    return ret;\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  }\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, Buffer());\n  }\n  return Buffer(env, value);\n#endif\n}\n\ntemplate <typename T>\ninline Buffer<T> Buffer<T>::Copy(napi_env env, const T* data, size_t length) {\n  napi_value value;\n  napi_status status =\n      napi_create_buffer_copy(env, length * sizeof(T), data, nullptr, &value);\n  NAPI_THROW_IF_FAILED(env, status, Buffer<T>());\n  return Buffer<T>(env, value);\n}\n\ntemplate <typename T>\ninline void Buffer<T>::CheckCast(napi_env env, napi_value value) {\n  NAPI_CHECK(value != nullptr, \"Buffer::CheckCast\", \"empty value\");\n\n  bool result;\n  napi_status status = napi_is_buffer(env, value, &result);\n  NAPI_CHECK(status == napi_ok, \"Buffer::CheckCast\", \"napi_is_buffer failed\");\n  NAPI_CHECK(result, \"Buffer::CheckCast\", \"value is not buffer\");\n}\n\ntemplate <typename T>\ninline Buffer<T>::Buffer() : Uint8Array() {}\n\ntemplate <typename T>\ninline Buffer<T>::Buffer(napi_env env, napi_value value)\n    : Uint8Array(env, value) {}\n\ntemplate <typename T>\ninline size_t Buffer<T>::Length() const {\n  return ByteLength() / sizeof(T);\n}\n\ntemplate <typename T>\ninline T* Buffer<T>::Data() const {\n  return reinterpret_cast<T*>(const_cast<uint8_t*>(Uint8Array::Data()));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Error class\n////////////////////////////////////////////////////////////////////////////////\n\ninline Error Error::New(napi_env env) {\n  napi_status status;\n  napi_value error = nullptr;\n  bool is_exception_pending;\n  napi_extended_error_info last_error_info_copy;\n\n  {\n    // We must retrieve the last error info before doing anything else because\n    // doing anything else will replace the last error info.\n    const napi_extended_error_info* last_error_info;\n    status = napi_get_last_error_info(env, &last_error_info);\n    NAPI_FATAL_IF_FAILED(status, \"Error::New\", \"napi_get_last_error_info\");\n\n    // All fields of the `napi_extended_error_info` structure gets reset in\n    // subsequent Node-API function calls on the same `env`. This includes a\n    // call to `napi_is_exception_pending()`. So here it is necessary to make a\n    // copy of the information as the `error_code` field is used later on.\n    memcpy(&last_error_info_copy,\n           last_error_info,\n           sizeof(napi_extended_error_info));\n  }\n\n  status = napi_is_exception_pending(env, &is_exception_pending);\n  NAPI_FATAL_IF_FAILED(status, \"Error::New\", \"napi_is_exception_pending\");\n\n  // A pending exception takes precedence over any internal error status.\n  if (is_exception_pending) {\n    status = napi_get_and_clear_last_exception(env, &error);\n    NAPI_FATAL_IF_FAILED(\n        status, \"Error::New\", \"napi_get_and_clear_last_exception\");\n  } else {\n    const char* error_message = last_error_info_copy.error_message != nullptr\n                                    ? last_error_info_copy.error_message\n                                    : \"Error in native callback\";\n\n    napi_value message;\n    status = napi_create_string_utf8(\n        env, error_message, std::strlen(error_message), &message);\n    NAPI_FATAL_IF_FAILED(status, \"Error::New\", \"napi_create_string_utf8\");\n\n    switch (last_error_info_copy.error_code) {\n      case napi_object_expected:\n      case napi_string_expected:\n      case napi_boolean_expected:\n      case napi_number_expected:\n        status = napi_create_type_error(env, nullptr, message, &error);\n        break;\n      default:\n        status = napi_create_error(env, nullptr, message, &error);\n        break;\n    }\n    NAPI_FATAL_IF_FAILED(status, \"Error::New\", \"napi_create_error\");\n  }\n\n  return Error(env, error);\n}\n\ninline Error Error::New(napi_env env, const char* message) {\n  return Error::New<Error>(\n      env, message, std::strlen(message), napi_create_error);\n}\n\ninline Error Error::New(napi_env env, const std::string& message) {\n  return Error::New<Error>(\n      env, message.c_str(), message.size(), napi_create_error);\n}\n\ninline NAPI_NO_RETURN void Error::Fatal(const char* location,\n                                        const char* message) {\n  napi_fatal_error(location, NAPI_AUTO_LENGTH, message, NAPI_AUTO_LENGTH);\n}\n\ninline Error::Error() : ObjectReference() {}\n\ninline Error::Error(napi_env env, napi_value value)\n    : ObjectReference(env, nullptr) {\n  if (value != nullptr) {\n    // Attempting to create a reference on the error object.\n    // If it's not a Object/Function/Symbol, this call will return an error\n    // status.\n    napi_status status = napi_create_reference(env, value, 1, &_ref);\n\n    if (status != napi_ok) {\n      napi_value wrappedErrorObj;\n\n      // Create an error object\n      status = napi_create_object(env, &wrappedErrorObj);\n      NAPI_FATAL_IF_FAILED(status, \"Error::Error\", \"napi_create_object\");\n\n      // property flag that we attach to show the error object is wrapped\n      napi_property_descriptor wrapObjFlag = {\n          ERROR_WRAP_VALUE(),  // Unique GUID identifier since Symbol isn't a\n                               // viable option\n          nullptr,\n          nullptr,\n          nullptr,\n          nullptr,\n          Value::From(env, value),\n          napi_enumerable,\n          nullptr};\n\n      status = napi_define_properties(env, wrappedErrorObj, 1, &wrapObjFlag);\n#ifdef NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS\n      if (status == napi_pending_exception) {\n        // Test if the pending exception was reported because the environment is\n        // shutting down. We assume that a status of napi_pending_exception\n        // coupled with the absence of an actual pending exception means that\n        // the environment is shutting down. If so, we replace the\n        // napi_pending_exception status with napi_ok.\n        bool is_exception_pending = false;\n        status = napi_is_exception_pending(env, &is_exception_pending);\n        if (status == napi_ok && !is_exception_pending) {\n          status = napi_ok;\n        } else {\n          status = napi_pending_exception;\n        }\n      }\n#endif  // NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS\n      NAPI_FATAL_IF_FAILED(status, \"Error::Error\", \"napi_define_properties\");\n\n      // Create a reference on the newly wrapped object\n      status = napi_create_reference(env, wrappedErrorObj, 1, &_ref);\n    }\n\n    // Avoid infinite recursion in the failure case.\n    NAPI_FATAL_IF_FAILED(status, \"Error::Error\", \"napi_create_reference\");\n  }\n}\n\ninline Object Error::Value() const {\n  if (_ref == nullptr) {\n    return Object(_env, nullptr);\n  }\n\n  napi_value refValue;\n  napi_status status = napi_get_reference_value(_env, _ref, &refValue);\n  NAPI_THROW_IF_FAILED(_env, status, Object());\n\n  napi_valuetype type;\n  status = napi_typeof(_env, refValue, &type);\n  NAPI_THROW_IF_FAILED(_env, status, Object());\n\n  // If refValue isn't a symbol, then we proceed to whether the refValue has the\n  // wrapped error flag\n  if (type != napi_symbol) {\n    // We are checking if the object is wrapped\n    bool isWrappedObject = false;\n\n    status = napi_has_property(_env,\n                               refValue,\n                               String::From(_env, ERROR_WRAP_VALUE()),\n                               &isWrappedObject);\n\n    // Don't care about status\n    if (isWrappedObject) {\n      napi_value unwrappedValue;\n      status = napi_get_property(_env,\n                                 refValue,\n                                 String::From(_env, ERROR_WRAP_VALUE()),\n                                 &unwrappedValue);\n      NAPI_THROW_IF_FAILED(_env, status, Object());\n\n      return Object(_env, unwrappedValue);\n    }\n  }\n\n  return Object(_env, refValue);\n}\n\ninline Error::Error(Error&& other) : ObjectReference(std::move(other)) {}\n\ninline Error& Error::operator=(Error&& other) {\n  static_cast<Reference<Object>*>(this)->operator=(std::move(other));\n  return *this;\n}\n\ninline Error::Error(const Error& other) : ObjectReference(other) {}\n\ninline Error& Error::operator=(const Error& other) {\n  Reset();\n\n  _env = other.Env();\n  HandleScope scope(_env);\n\n  napi_value value = other.Value();\n  if (value != nullptr) {\n    napi_status status = napi_create_reference(_env, value, 1, &_ref);\n    NAPI_THROW_IF_FAILED(_env, status, *this);\n  }\n\n  return *this;\n}\n\ninline const std::string& Error::Message() const NAPI_NOEXCEPT {\n  if (_message.size() == 0 && _env != nullptr) {\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n    try {\n      _message = Get(\"message\").As<String>();\n    } catch (...) {\n      // Catch all errors here, to include e.g. a std::bad_alloc from\n      // the std::string::operator=, because this method may not throw.\n    }\n#else  // NODE_ADDON_API_CPP_EXCEPTIONS\n#if defined(NODE_ADDON_API_ENABLE_MAYBE)\n    Napi::Value message_val;\n    if (Get(\"message\").UnwrapTo(&message_val)) {\n      _message = message_val.As<String>();\n    }\n#else\n    _message = Get(\"message\").As<String>();\n#endif\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n  }\n  return _message;\n}\n\n// we created an object on the &_ref\ninline void Error::ThrowAsJavaScriptException() const {\n  HandleScope scope(_env);\n  if (!IsEmpty()) {\n#ifdef NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS\n    bool pendingException = false;\n\n    // check if there is already a pending exception. If so don't try to throw a\n    // new one as that is not allowed/possible\n    napi_status status = napi_is_exception_pending(_env, &pendingException);\n\n    if ((status != napi_ok) ||\n        ((status == napi_ok) && (pendingException == false))) {\n      // We intentionally don't use `NAPI_THROW_*` macros here to ensure\n      // that there is no possible recursion as `ThrowAsJavaScriptException`\n      // is part of `NAPI_THROW_*` macro definition for noexcept.\n\n      status = napi_throw(_env, Value());\n\n#ifdef NAPI_EXPERIMENTAL\n      napi_status expected_failure_mode = napi_cannot_run_js;\n#else\n      napi_status expected_failure_mode = napi_pending_exception;\n#endif\n      if (status == expected_failure_mode) {\n        // The environment must be terminating as we checked earlier and there\n        // was no pending exception. In this case continuing will result\n        // in a fatal error and there is nothing the author has done incorrectly\n        // in their code that is worth flagging through a fatal error\n        return;\n      }\n    } else {\n      status = napi_pending_exception;\n    }\n#else\n    // We intentionally don't use `NAPI_THROW_*` macros here to ensure\n    // that there is no possible recursion as `ThrowAsJavaScriptException`\n    // is part of `NAPI_THROW_*` macro definition for noexcept.\n\n    napi_status status = napi_throw(_env, Value());\n#endif\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n    if (status != napi_ok) {\n      throw Error::New(_env);\n    }\n#else   // NODE_ADDON_API_CPP_EXCEPTIONS\n    NAPI_FATAL_IF_FAILED(\n        status, \"Error::ThrowAsJavaScriptException\", \"napi_throw\");\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n  }\n}\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n\ninline const char* Error::what() const NAPI_NOEXCEPT {\n  return Message().c_str();\n}\n\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\ninline const char* Error::ERROR_WRAP_VALUE() NAPI_NOEXCEPT {\n  return \"4bda9e7e-4913-4dbc-95de-891cbf66598e-errorVal\";\n}\n\ntemplate <typename TError>\ninline TError Error::New(napi_env env,\n                         const char* message,\n                         size_t length,\n                         create_error_fn create_error) {\n  napi_value str;\n  napi_status status = napi_create_string_utf8(env, message, length, &str);\n  NAPI_THROW_IF_FAILED(env, status, TError());\n\n  napi_value error;\n  status = create_error(env, nullptr, str, &error);\n  NAPI_THROW_IF_FAILED(env, status, TError());\n\n  return TError(env, error);\n}\n\ninline TypeError TypeError::New(napi_env env, const char* message) {\n  return Error::New<TypeError>(\n      env, message, std::strlen(message), napi_create_type_error);\n}\n\ninline TypeError TypeError::New(napi_env env, const std::string& message) {\n  return Error::New<TypeError>(\n      env, message.c_str(), message.size(), napi_create_type_error);\n}\n\ninline TypeError::TypeError() : Error() {}\n\ninline TypeError::TypeError(napi_env env, napi_value value)\n    : Error(env, value) {}\n\ninline RangeError RangeError::New(napi_env env, const char* message) {\n  return Error::New<RangeError>(\n      env, message, std::strlen(message), napi_create_range_error);\n}\n\ninline RangeError RangeError::New(napi_env env, const std::string& message) {\n  return Error::New<RangeError>(\n      env, message.c_str(), message.size(), napi_create_range_error);\n}\n\ninline RangeError::RangeError() : Error() {}\n\ninline RangeError::RangeError(napi_env env, napi_value value)\n    : Error(env, value) {}\n\n#if NAPI_VERSION > 8\ninline SyntaxError SyntaxError::New(napi_env env, const char* message) {\n  return Error::New<SyntaxError>(\n      env, message, std::strlen(message), node_api_create_syntax_error);\n}\n\ninline SyntaxError SyntaxError::New(napi_env env, const std::string& message) {\n  return Error::New<SyntaxError>(\n      env, message.c_str(), message.size(), node_api_create_syntax_error);\n}\n\ninline SyntaxError::SyntaxError() : Error() {}\n\ninline SyntaxError::SyntaxError(napi_env env, napi_value value)\n    : Error(env, value) {}\n#endif  // NAPI_VERSION > 8\n\n////////////////////////////////////////////////////////////////////////////////\n// Reference<T> class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline Reference<T> Reference<T>::New(const T& value,\n                                      uint32_t initialRefcount) {\n  napi_env env = value.Env();\n  napi_value val = value;\n\n  if (val == nullptr) {\n    return Reference<T>(env, nullptr);\n  }\n\n  napi_ref ref;\n  napi_status status = napi_create_reference(env, value, initialRefcount, &ref);\n  NAPI_THROW_IF_FAILED(env, status, Reference<T>());\n\n  return Reference<T>(env, ref);\n}\n\ntemplate <typename T>\ninline Reference<T>::Reference()\n    : _env(nullptr), _ref(nullptr), _suppressDestruct(false) {}\n\ntemplate <typename T>\ninline Reference<T>::Reference(napi_env env, napi_ref ref)\n    : _env(env), _ref(ref), _suppressDestruct(false) {}\n\ntemplate <typename T>\ninline Reference<T>::~Reference() {\n  if (_ref != nullptr) {\n    if (!_suppressDestruct) {\n      // TODO(legendecas): napi_delete_reference should be invoked immediately.\n      // Fix this when https://github.com/nodejs/node/pull/55620 lands.\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n      Env().PostFinalizer(\n          [](Napi::Env env, napi_ref ref) { napi_delete_reference(env, ref); },\n          _ref);\n#else\n      napi_delete_reference(_env, _ref);\n#endif\n    }\n\n    _ref = nullptr;\n  }\n}\n\ntemplate <typename T>\ninline Reference<T>::Reference(Reference<T>&& other)\n    : _env(other._env),\n      _ref(other._ref),\n      _suppressDestruct(other._suppressDestruct) {\n  other._env = nullptr;\n  other._ref = nullptr;\n  other._suppressDestruct = false;\n}\n\ntemplate <typename T>\ninline Reference<T>& Reference<T>::operator=(Reference<T>&& other) {\n  Reset();\n  _env = other._env;\n  _ref = other._ref;\n  _suppressDestruct = other._suppressDestruct;\n  other._env = nullptr;\n  other._ref = nullptr;\n  other._suppressDestruct = false;\n  return *this;\n}\n\ntemplate <typename T>\ninline Reference<T>::Reference(const Reference<T>& other)\n    : _env(other._env), _ref(nullptr), _suppressDestruct(false) {\n  HandleScope scope(_env);\n\n  napi_value value = other.Value();\n  if (value != nullptr) {\n    // Copying is a limited scenario (currently only used for Error object) and\n    // always creates a strong reference to the given value even if the incoming\n    // reference is weak.\n    napi_status status = napi_create_reference(_env, value, 1, &_ref);\n    NAPI_FATAL_IF_FAILED(\n        status, \"Reference<T>::Reference\", \"napi_create_reference\");\n  }\n}\n\ntemplate <typename T>\ninline Reference<T>::operator napi_ref() const {\n  return _ref;\n}\n\ntemplate <typename T>\ninline bool Reference<T>::operator==(const Reference<T>& other) const {\n  HandleScope scope(_env);\n  return this->Value().StrictEquals(other.Value());\n}\n\ntemplate <typename T>\ninline bool Reference<T>::operator!=(const Reference<T>& other) const {\n  return !this->operator==(other);\n}\n\ntemplate <typename T>\ninline Napi::Env Reference<T>::Env() const {\n  return Napi::Env(_env);\n}\n\ntemplate <typename T>\ninline bool Reference<T>::IsEmpty() const {\n  return _ref == nullptr;\n}\n\ntemplate <typename T>\ninline T Reference<T>::Value() const {\n  if (_ref == nullptr) {\n    return T(_env, nullptr);\n  }\n\n  napi_value value;\n  napi_status status = napi_get_reference_value(_env, _ref, &value);\n  NAPI_THROW_IF_FAILED(_env, status, T());\n  return T(_env, value);\n}\n\ntemplate <typename T>\ninline uint32_t Reference<T>::Ref() const {\n  uint32_t result;\n  napi_status status = napi_reference_ref(_env, _ref, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ntemplate <typename T>\ninline uint32_t Reference<T>::Unref() const {\n  uint32_t result;\n  napi_status status = napi_reference_unref(_env, _ref, &result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n\ntemplate <typename T>\ninline void Reference<T>::Reset() {\n  if (_ref != nullptr) {\n    napi_status status = napi_delete_reference(_env, _ref);\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n    _ref = nullptr;\n  }\n}\n\ntemplate <typename T>\ninline void Reference<T>::Reset(const T& value, uint32_t refcount) {\n  Reset();\n  _env = value.Env();\n\n  napi_value val = value;\n  if (val != nullptr) {\n    napi_status status = napi_create_reference(_env, value, refcount, &_ref);\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n  }\n}\n\ntemplate <typename T>\ninline void Reference<T>::SuppressDestruct() {\n  _suppressDestruct = true;\n}\n\ntemplate <typename T>\ninline Reference<T> Weak(T value) {\n  return Reference<T>::New(value, 0);\n}\n\ninline ObjectReference Weak(Object value) {\n  return Reference<Object>::New(value, 0);\n}\n\ninline FunctionReference Weak(Function value) {\n  return Reference<Function>::New(value, 0);\n}\n\ntemplate <typename T>\ninline Reference<T> Persistent(T value) {\n  return Reference<T>::New(value, 1);\n}\n\ninline ObjectReference Persistent(Object value) {\n  return Reference<Object>::New(value, 1);\n}\n\ninline FunctionReference Persistent(Function value) {\n  return Reference<Function>::New(value, 1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ObjectReference class\n////////////////////////////////////////////////////////////////////////////////\n\ninline ObjectReference::ObjectReference() : Reference<Object>() {}\n\ninline ObjectReference::ObjectReference(napi_env env, napi_ref ref)\n    : Reference<Object>(env, ref) {}\n\ninline ObjectReference::ObjectReference(Reference<Object>&& other)\n    : Reference<Object>(std::move(other)) {}\n\ninline ObjectReference& ObjectReference::operator=(Reference<Object>&& other) {\n  static_cast<Reference<Object>*>(this)->operator=(std::move(other));\n  return *this;\n}\n\ninline ObjectReference::ObjectReference(ObjectReference&& other)\n    : Reference<Object>(std::move(other)) {}\n\ninline ObjectReference& ObjectReference::operator=(ObjectReference&& other) {\n  static_cast<Reference<Object>*>(this)->operator=(std::move(other));\n  return *this;\n}\n\ninline ObjectReference::ObjectReference(const ObjectReference& other)\n    : Reference<Object>(other) {}\n\ninline MaybeOrValue<Napi::Value> ObjectReference::Get(\n    const char* utf8name) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Get(utf8name);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> ObjectReference::Get(\n    const std::string& utf8name) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Get(utf8name);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const char* utf8name,\n                                               napi_value value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const char* utf8name,\n                                               Napi::Value value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const char* utf8name,\n                                               const char* utf8value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, utf8value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const char* utf8name,\n                                               bool boolValue) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, boolValue);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const char* utf8name,\n                                               double numberValue) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, numberValue);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const std::string& utf8name,\n                                               napi_value value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const std::string& utf8name,\n                                               Napi::Value value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const std::string& utf8name,\n                                               std::string& utf8value) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, utf8value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const std::string& utf8name,\n                                               bool boolValue) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, boolValue);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(const std::string& utf8name,\n                                               double numberValue) const {\n  HandleScope scope(_env);\n  return Value().Set(utf8name, numberValue);\n}\n\ninline MaybeOrValue<Napi::Value> ObjectReference::Get(uint32_t index) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Get(index);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(uint32_t index,\n                                               napi_value value) const {\n  HandleScope scope(_env);\n  return Value().Set(index, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(uint32_t index,\n                                               Napi::Value value) const {\n  HandleScope scope(_env);\n  return Value().Set(index, value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(uint32_t index,\n                                               const char* utf8value) const {\n  HandleScope scope(_env);\n  return Value().Set(index, utf8value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(\n    uint32_t index, const std::string& utf8value) const {\n  HandleScope scope(_env);\n  return Value().Set(index, utf8value);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(uint32_t index,\n                                               bool boolValue) const {\n  HandleScope scope(_env);\n  return Value().Set(index, boolValue);\n}\n\ninline MaybeOrValue<bool> ObjectReference::Set(uint32_t index,\n                                               double numberValue) const {\n  HandleScope scope(_env);\n  return Value().Set(index, numberValue);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// FunctionReference class\n////////////////////////////////////////////////////////////////////////////////\n\ninline FunctionReference::FunctionReference() : Reference<Function>() {}\n\ninline FunctionReference::FunctionReference(napi_env env, napi_ref ref)\n    : Reference<Function>(env, ref) {}\n\ninline FunctionReference::FunctionReference(Reference<Function>&& other)\n    : Reference<Function>(std::move(other)) {}\n\ninline FunctionReference& FunctionReference::operator=(\n    Reference<Function>&& other) {\n  static_cast<Reference<Function>*>(this)->operator=(std::move(other));\n  return *this;\n}\n\ninline FunctionReference::FunctionReference(FunctionReference&& other)\n    : Reference<Function>(std::move(other)) {}\n\ninline FunctionReference& FunctionReference::operator=(\n    FunctionReference&& other) {\n  static_cast<Reference<Function>*>(this)->operator=(std::move(other));\n  return *this;\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::operator()(\n    const std::initializer_list<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value()(args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::Call(\n    const std::initializer_list<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Call(args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::Call(\n    const std::vector<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Call(args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::Call(\n    napi_value recv, const std::initializer_list<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Call(recv, args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::Call(\n    napi_value recv, const std::vector<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Call(recv, args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::Call(\n    napi_value recv, size_t argc, const napi_value* args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().Call(recv, argc, args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(\n    napi_value recv,\n    const std::initializer_list<napi_value>& args,\n    napi_async_context context) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().MakeCallback(recv, args, context);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(\n    napi_value recv,\n    const std::vector<napi_value>& args,\n    napi_async_context context) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result = Value().MakeCallback(recv, args, context);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Napi::Value> FunctionReference::MakeCallback(\n    napi_value recv,\n    size_t argc,\n    const napi_value* args,\n    napi_async_context context) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Napi::Value> result =\n      Value().MakeCallback(recv, argc, args, context);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()));\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Value();\n  }\n  return scope.Escape(result);\n#endif\n}\n\ninline MaybeOrValue<Object> FunctionReference::New(\n    const std::initializer_list<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Object> result = Value().New(args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()).As<Object>());\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Object();\n  }\n  return scope.Escape(result).As<Object>();\n#endif\n}\n\ninline MaybeOrValue<Object> FunctionReference::New(\n    const std::vector<napi_value>& args) const {\n  EscapableHandleScope scope(_env);\n  MaybeOrValue<Object> result = Value().New(args);\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n  if (result.IsJust()) {\n    return Just(scope.Escape(result.Unwrap()).As<Object>());\n  }\n  return result;\n#else\n  if (scope.Env().IsExceptionPending()) {\n    return Object();\n  }\n  return scope.Escape(result).As<Object>();\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// CallbackInfo class\n////////////////////////////////////////////////////////////////////////////////\n\ninline CallbackInfo::CallbackInfo(napi_env env, napi_callback_info info)\n    : _env(env),\n      _info(info),\n      _this(nullptr),\n      _dynamicArgs(nullptr),\n      _data(nullptr) {\n  _argc = _staticArgCount;\n  _argv = _staticArgs;\n  napi_status status =\n      napi_get_cb_info(env, info, &_argc, _argv, &_this, &_data);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n\n  if (_argc > _staticArgCount) {\n    // Use either a fixed-size array (on the stack) or a dynamically-allocated\n    // array (on the heap) depending on the number of args.\n    _dynamicArgs = new napi_value[_argc];\n    _argv = _dynamicArgs;\n\n    status = napi_get_cb_info(env, info, &_argc, _argv, nullptr, nullptr);\n    NAPI_THROW_IF_FAILED_VOID(_env, status);\n  }\n}\n\ninline CallbackInfo::~CallbackInfo() {\n  if (_dynamicArgs != nullptr) {\n    delete[] _dynamicArgs;\n  }\n}\n\ninline CallbackInfo::operator napi_callback_info() const {\n  return _info;\n}\n\ninline Value CallbackInfo::NewTarget() const {\n  napi_value newTarget;\n  napi_status status = napi_get_new_target(_env, _info, &newTarget);\n  NAPI_THROW_IF_FAILED(_env, status, Value());\n  return Value(_env, newTarget);\n}\n\ninline bool CallbackInfo::IsConstructCall() const {\n  return !NewTarget().IsEmpty();\n}\n\ninline Napi::Env CallbackInfo::Env() const {\n  return Napi::Env(_env);\n}\n\ninline size_t CallbackInfo::Length() const {\n  return _argc;\n}\n\ninline const Value CallbackInfo::operator[](size_t index) const {\n  return index < _argc ? Value(_env, _argv[index]) : Env().Undefined();\n}\n\ninline Value CallbackInfo::This() const {\n  if (_this == nullptr) {\n    return Env().Undefined();\n  }\n  return Object(_env, _this);\n}\n\ninline void* CallbackInfo::Data() const {\n  return _data;\n}\n\ninline void CallbackInfo::SetData(void* data) {\n  _data = data;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// PropertyDescriptor class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n\n  desc.utf8name = utf8name;\n  desc.getter = details::TemplatedCallback<Getter>;\n  desc.attributes = attributes;\n  desc.data = data;\n\n  return desc;\n}\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    const std::string& utf8name,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor<Getter>(utf8name.c_str(), attributes, data);\n}\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    Name name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n\n  desc.name = name;\n  desc.getter = details::TemplatedCallback<Getter>;\n  desc.attributes = attributes;\n  desc.data = data;\n\n  return desc;\n}\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter,\n          typename PropertyDescriptor::SetterCallback Setter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n\n  desc.utf8name = utf8name;\n  desc.getter = details::TemplatedCallback<Getter>;\n  desc.setter = details::TemplatedVoidCallback<Setter>;\n  desc.attributes = attributes;\n  desc.data = data;\n\n  return desc;\n}\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter,\n          typename PropertyDescriptor::SetterCallback Setter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    const std::string& utf8name,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor<Getter, Setter>(utf8name.c_str(), attributes, data);\n}\n\ntemplate <typename PropertyDescriptor::GetterCallback Getter,\n          typename PropertyDescriptor::SetterCallback Setter>\nPropertyDescriptor PropertyDescriptor::Accessor(\n    Name name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n\n  desc.name = name;\n  desc.getter = details::TemplatedCallback<Getter>;\n  desc.setter = details::TemplatedVoidCallback<Setter>;\n  desc.attributes = attributes;\n  desc.data = data;\n\n  return desc;\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    const char* utf8name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* data) {\n  using CbData = details::CallbackData<Getter, Napi::Value>;\n  auto callbackData = new CbData({getter, data});\n\n  napi_status status = AttachData(env, object, callbackData);\n  if (status != napi_ok) {\n    delete callbackData;\n    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());\n  }\n\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    const std::string& utf8name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor(env, object, utf8name.c_str(), getter, attributes, data);\n}\n\ntemplate <typename Getter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    Name name,\n    Getter getter,\n    napi_property_attributes attributes,\n    void* data) {\n  using CbData = details::CallbackData<Getter, Napi::Value>;\n  auto callbackData = new CbData({getter, data});\n\n  napi_status status = AttachData(env, object, callbackData);\n  if (status != napi_ok) {\n    delete callbackData;\n    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());\n  }\n\n  return PropertyDescriptor({nullptr,\n                             name,\n                             nullptr,\n                             CbData::Wrapper,\n                             nullptr,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    const char* utf8name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* data) {\n  using CbData = details::AccessorCallbackData<Getter, Setter>;\n  auto callbackData = new CbData({getter, setter, data});\n\n  napi_status status = AttachData(env, object, callbackData);\n  if (status != napi_ok) {\n    delete callbackData;\n    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());\n  }\n\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             CbData::GetterWrapper,\n                             CbData::SetterWrapper,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    const std::string& utf8name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* data) {\n  return Accessor(\n      env, object, utf8name.c_str(), getter, setter, attributes, data);\n}\n\ntemplate <typename Getter, typename Setter>\ninline PropertyDescriptor PropertyDescriptor::Accessor(\n    Napi::Env env,\n    Napi::Object object,\n    Name name,\n    Getter getter,\n    Setter setter,\n    napi_property_attributes attributes,\n    void* data) {\n  using CbData = details::AccessorCallbackData<Getter, Setter>;\n  auto callbackData = new CbData({getter, setter, data});\n\n  napi_status status = AttachData(env, object, callbackData);\n  if (status != napi_ok) {\n    delete callbackData;\n    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());\n  }\n\n  return PropertyDescriptor({nullptr,\n                             name,\n                             nullptr,\n                             CbData::GetterWrapper,\n                             CbData::SetterWrapper,\n                             nullptr,\n                             attributes,\n                             callbackData});\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    Napi::Env env,\n    Napi::Object /*object*/,\n    const char* utf8name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* data) {\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             Napi::Function::New(env, cb, utf8name, data),\n                             attributes,\n                             nullptr});\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    Napi::Env env,\n    Napi::Object object,\n    const std::string& utf8name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* data) {\n  return Function(env, object, utf8name.c_str(), cb, attributes, data);\n}\n\ntemplate <typename Callable>\ninline PropertyDescriptor PropertyDescriptor::Function(\n    Napi::Env env,\n    Napi::Object /*object*/,\n    Name name,\n    Callable cb,\n    napi_property_attributes attributes,\n    void* data) {\n  return PropertyDescriptor({nullptr,\n                             name,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             Napi::Function::New(env, cb, nullptr, data),\n                             attributes,\n                             nullptr});\n}\n\ninline PropertyDescriptor PropertyDescriptor::Value(\n    const char* utf8name,\n    napi_value value,\n    napi_property_attributes attributes) {\n  return PropertyDescriptor({utf8name,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             nullptr,\n                             value,\n                             attributes,\n                             nullptr});\n}\n\ninline PropertyDescriptor PropertyDescriptor::Value(\n    const std::string& utf8name,\n    napi_value value,\n    napi_property_attributes attributes) {\n  return Value(utf8name.c_str(), value, attributes);\n}\n\ninline PropertyDescriptor PropertyDescriptor::Value(\n    napi_value name, napi_value value, napi_property_attributes attributes) {\n  return PropertyDescriptor(\n      {nullptr, name, nullptr, nullptr, nullptr, value, attributes, nullptr});\n}\n\ninline PropertyDescriptor PropertyDescriptor::Value(\n    Name name, Napi::Value value, napi_property_attributes attributes) {\n  napi_value nameValue = name;\n  napi_value valueValue = value;\n  return PropertyDescriptor::Value(nameValue, valueValue, attributes);\n}\n\ninline PropertyDescriptor::PropertyDescriptor(napi_property_descriptor desc)\n    : _desc(desc) {}\n\ninline PropertyDescriptor::operator napi_property_descriptor&() {\n  return _desc;\n}\n\ninline PropertyDescriptor::operator const napi_property_descriptor&() const {\n  return _desc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// InstanceWrap<T> class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline void InstanceWrap<T>::AttachPropData(\n    napi_env env, napi_value value, const napi_property_descriptor* prop) {\n  napi_status status;\n  if (!(prop->attributes & napi_static)) {\n    if (prop->method == T::InstanceVoidMethodCallbackWrapper) {\n      status = Napi::details::AttachData(\n          env, value, static_cast<InstanceVoidMethodCallbackData*>(prop->data));\n      NAPI_THROW_IF_FAILED_VOID(env, status);\n    } else if (prop->method == T::InstanceMethodCallbackWrapper) {\n      status = Napi::details::AttachData(\n          env, value, static_cast<InstanceMethodCallbackData*>(prop->data));\n      NAPI_THROW_IF_FAILED_VOID(env, status);\n    } else if (prop->getter == T::InstanceGetterCallbackWrapper ||\n               prop->setter == T::InstanceSetterCallbackWrapper) {\n      status = Napi::details::AttachData(\n          env, value, static_cast<InstanceAccessorCallbackData*>(prop->data));\n      NAPI_THROW_IF_FAILED_VOID(env, status);\n    }\n  }\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    const char* utf8name,\n    InstanceVoidMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceVoidMethodCallbackData* callbackData =\n      new InstanceVoidMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = T::InstanceVoidMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    const char* utf8name,\n    InstanceMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceMethodCallbackData* callbackData =\n      new InstanceMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = T::InstanceMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    Symbol name,\n    InstanceVoidMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceVoidMethodCallbackData* callbackData =\n      new InstanceVoidMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = T::InstanceVoidMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    Symbol name,\n    InstanceMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceMethodCallbackData* callbackData =\n      new InstanceMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = T::InstanceMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceVoidMethodCallback method>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = details::TemplatedInstanceVoidCallback<T, method>;\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceMethodCallback method>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = details::TemplatedInstanceCallback<T, method>;\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceVoidMethodCallback method>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = details::TemplatedInstanceVoidCallback<T, method>;\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceMethodCallback method>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceMethod(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = details::TemplatedInstanceCallback<T, method>;\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceAccessor(\n    const char* utf8name,\n    InstanceGetterCallback getter,\n    InstanceSetterCallback setter,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceAccessorCallbackData* callbackData =\n      new InstanceAccessorCallbackData({getter, setter, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.getter = getter != nullptr ? T::InstanceGetterCallbackWrapper : nullptr;\n  desc.setter = setter != nullptr ? T::InstanceSetterCallbackWrapper : nullptr;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceAccessor(\n    Symbol name,\n    InstanceGetterCallback getter,\n    InstanceSetterCallback setter,\n    napi_property_attributes attributes,\n    void* data) {\n  InstanceAccessorCallbackData* callbackData =\n      new InstanceAccessorCallbackData({getter, setter, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.getter = getter != nullptr ? T::InstanceGetterCallbackWrapper : nullptr;\n  desc.setter = setter != nullptr ? T::InstanceSetterCallbackWrapper : nullptr;\n  desc.data = callbackData;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceGetterCallback getter,\n          typename InstanceWrap<T>::InstanceSetterCallback setter>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceAccessor(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.getter = details::TemplatedInstanceCallback<T, getter>;\n  desc.setter = This::WrapSetter(This::SetterTag<setter>());\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceGetterCallback getter,\n          typename InstanceWrap<T>::InstanceSetterCallback setter>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceAccessor(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.getter = details::TemplatedInstanceCallback<T, getter>;\n  desc.setter = This::WrapSetter(This::SetterTag<setter>());\n  desc.data = data;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceValue(\n    const char* utf8name,\n    Napi::Value value,\n    napi_property_attributes attributes) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.value = value;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> InstanceWrap<T>::InstanceValue(\n    Symbol name, Napi::Value value, napi_property_attributes attributes) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.value = value;\n  desc.attributes = attributes;\n  return desc;\n}\n\ntemplate <typename T>\ninline napi_value InstanceWrap<T>::InstanceVoidMethodCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    InstanceVoidMethodCallbackData* callbackData =\n        reinterpret_cast<InstanceVoidMethodCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    T* instance = T::Unwrap(callbackInfo.This().As<Object>());\n    auto cb = callbackData->callback;\n    if (instance) (instance->*cb)(callbackInfo);\n    return nullptr;\n  });\n}\n\ntemplate <typename T>\ninline napi_value InstanceWrap<T>::InstanceMethodCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    InstanceMethodCallbackData* callbackData =\n        reinterpret_cast<InstanceMethodCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    T* instance = T::Unwrap(callbackInfo.This().As<Object>());\n    auto cb = callbackData->callback;\n    return instance ? (instance->*cb)(callbackInfo) : Napi::Value();\n  });\n}\n\ntemplate <typename T>\ninline napi_value InstanceWrap<T>::InstanceGetterCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    InstanceAccessorCallbackData* callbackData =\n        reinterpret_cast<InstanceAccessorCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    T* instance = T::Unwrap(callbackInfo.This().As<Object>());\n    auto cb = callbackData->getterCallback;\n    return instance ? (instance->*cb)(callbackInfo) : Napi::Value();\n  });\n}\n\ntemplate <typename T>\ninline napi_value InstanceWrap<T>::InstanceSetterCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    InstanceAccessorCallbackData* callbackData =\n        reinterpret_cast<InstanceAccessorCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    T* instance = T::Unwrap(callbackInfo.This().As<Object>());\n    auto cb = callbackData->setterCallback;\n    if (instance) (instance->*cb)(callbackInfo, callbackInfo[0]);\n    return nullptr;\n  });\n}\n\ntemplate <typename T>\ntemplate <typename InstanceWrap<T>::InstanceSetterCallback method>\ninline napi_value InstanceWrap<T>::WrappedMethod(\n    napi_env env, napi_callback_info info) NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    const CallbackInfo cbInfo(env, info);\n    T* instance = T::Unwrap(cbInfo.This().As<Object>());\n    if (instance) (instance->*method)(cbInfo, cbInfo[0]);\n    return nullptr;\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ObjectWrap<T> class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline ObjectWrap<T>::ObjectWrap(const Napi::CallbackInfo& callbackInfo) {\n  napi_env env = callbackInfo.Env();\n  napi_value wrapper = callbackInfo.This();\n  napi_status status;\n  napi_ref ref;\n  T* instance = static_cast<T*>(this);\n  status = napi_wrap(env, wrapper, instance, FinalizeCallback, nullptr, &ref);\n  NAPI_THROW_IF_FAILED_VOID(env, status);\n\n  Reference<Object>* instanceRef = instance;\n  *instanceRef = Reference<Object>(env, ref);\n}\n\ntemplate <typename T>\ninline ObjectWrap<T>::~ObjectWrap() {\n  // If the JS object still exists at this point, remove the finalizer added\n  // through `napi_wrap()`.\n  if (!IsEmpty() && !_finalized) {\n    Object object = Value();\n    // It is not valid to call `napi_remove_wrap()` with an empty `object`.\n    // This happens e.g. during garbage collection.\n    if (!object.IsEmpty() && _construction_failed) {\n      napi_remove_wrap(Env(), object, nullptr);\n    }\n  }\n}\n\ntemplate <typename T>\ninline T* ObjectWrap<T>::Unwrap(Object wrapper) {\n  void* unwrapped;\n  napi_status status = napi_unwrap(wrapper.Env(), wrapper, &unwrapped);\n  NAPI_THROW_IF_FAILED(wrapper.Env(), status, nullptr);\n  return static_cast<T*>(unwrapped);\n}\n\ntemplate <typename T>\ninline Function ObjectWrap<T>::DefineClass(\n    Napi::Env env,\n    const char* utf8name,\n    const size_t props_count,\n    const napi_property_descriptor* descriptors,\n    void* data) {\n  napi_status status;\n  std::vector<napi_property_descriptor> props(props_count);\n\n  // We copy the descriptors to a local array because before defining the class\n  // we must replace static method property descriptors with value property\n  // descriptors such that the value is a function-valued `napi_value` created\n  // with `CreateFunction()`.\n  //\n  // This replacement could be made for instance methods as well, but V8 aborts\n  // if we do that, because it expects methods defined on the prototype template\n  // to have `FunctionTemplate`s.\n  for (size_t index = 0; index < props_count; index++) {\n    props[index] = descriptors[index];\n    napi_property_descriptor* prop = &props[index];\n    if (prop->method == T::StaticMethodCallbackWrapper) {\n      status =\n          CreateFunction(env,\n                         utf8name,\n                         prop->method,\n                         static_cast<StaticMethodCallbackData*>(prop->data),\n                         &(prop->value));\n      NAPI_THROW_IF_FAILED(env, status, Function());\n      prop->method = nullptr;\n      prop->data = nullptr;\n    } else if (prop->method == T::StaticVoidMethodCallbackWrapper) {\n      status =\n          CreateFunction(env,\n                         utf8name,\n                         prop->method,\n                         static_cast<StaticVoidMethodCallbackData*>(prop->data),\n                         &(prop->value));\n      NAPI_THROW_IF_FAILED(env, status, Function());\n      prop->method = nullptr;\n      prop->data = nullptr;\n    }\n  }\n\n  napi_value value;\n  status = napi_define_class(env,\n                             utf8name,\n                             NAPI_AUTO_LENGTH,\n                             T::ConstructorCallbackWrapper,\n                             data,\n                             props_count,\n                             props.data(),\n                             &value);\n  NAPI_THROW_IF_FAILED(env, status, Function());\n\n  // After defining the class we iterate once more over the property descriptors\n  // and attach the data associated with accessors and instance methods to the\n  // newly created JavaScript class.\n  for (size_t idx = 0; idx < props_count; idx++) {\n    const napi_property_descriptor* prop = &props[idx];\n\n    if (prop->getter == T::StaticGetterCallbackWrapper ||\n        prop->setter == T::StaticSetterCallbackWrapper) {\n      status = Napi::details::AttachData(\n          env, value, static_cast<StaticAccessorCallbackData*>(prop->data));\n      NAPI_THROW_IF_FAILED(env, status, Function());\n    } else {\n      // InstanceWrap<T>::AttachPropData is responsible for attaching the data\n      // of instance methods and accessors.\n      T::AttachPropData(env, value, prop);\n    }\n  }\n\n  return Function(env, value);\n}\n\ntemplate <typename T>\ninline Function ObjectWrap<T>::DefineClass(\n    Napi::Env env,\n    const char* utf8name,\n    const std::initializer_list<ClassPropertyDescriptor<T>>& properties,\n    void* data) {\n  return DefineClass(\n      env,\n      utf8name,\n      properties.size(),\n      reinterpret_cast<const napi_property_descriptor*>(properties.begin()),\n      data);\n}\n\ntemplate <typename T>\ninline Function ObjectWrap<T>::DefineClass(\n    Napi::Env env,\n    const char* utf8name,\n    const std::vector<ClassPropertyDescriptor<T>>& properties,\n    void* data) {\n  return DefineClass(\n      env,\n      utf8name,\n      properties.size(),\n      reinterpret_cast<const napi_property_descriptor*>(properties.data()),\n      data);\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    const char* utf8name,\n    StaticVoidMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticVoidMethodCallbackData* callbackData =\n      new StaticVoidMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = T::StaticVoidMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    const char* utf8name,\n    StaticMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticMethodCallbackData* callbackData =\n      new StaticMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = T::StaticMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    Symbol name,\n    StaticVoidMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticVoidMethodCallbackData* callbackData =\n      new StaticVoidMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = T::StaticVoidMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    Symbol name,\n    StaticMethodCallback method,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticMethodCallbackData* callbackData =\n      new StaticMethodCallbackData({method, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = T::StaticMethodCallbackWrapper;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticVoidMethodCallback method>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = details::TemplatedVoidCallback<method>;\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticVoidMethodCallback method>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = details::TemplatedVoidCallback<method>;\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticMethodCallback method>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.method = details::TemplatedCallback<method>;\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticMethodCallback method>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticMethod(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.method = details::TemplatedCallback<method>;\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticAccessor(\n    const char* utf8name,\n    StaticGetterCallback getter,\n    StaticSetterCallback setter,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticAccessorCallbackData* callbackData =\n      new StaticAccessorCallbackData({getter, setter, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.getter = getter != nullptr ? T::StaticGetterCallbackWrapper : nullptr;\n  desc.setter = setter != nullptr ? T::StaticSetterCallbackWrapper : nullptr;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticAccessor(\n    Symbol name,\n    StaticGetterCallback getter,\n    StaticSetterCallback setter,\n    napi_property_attributes attributes,\n    void* data) {\n  StaticAccessorCallbackData* callbackData =\n      new StaticAccessorCallbackData({getter, setter, data});\n\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.getter = getter != nullptr ? T::StaticGetterCallbackWrapper : nullptr;\n  desc.setter = setter != nullptr ? T::StaticSetterCallbackWrapper : nullptr;\n  desc.data = callbackData;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticGetterCallback getter,\n          typename ObjectWrap<T>::StaticSetterCallback setter>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticAccessor(\n    const char* utf8name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.getter = details::TemplatedCallback<getter>;\n  desc.setter = This::WrapStaticSetter(This::StaticSetterTag<setter>());\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticGetterCallback getter,\n          typename ObjectWrap<T>::StaticSetterCallback setter>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticAccessor(\n    Symbol name, napi_property_attributes attributes, void* data) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.getter = details::TemplatedCallback<getter>;\n  desc.setter = This::WrapStaticSetter(This::StaticSetterTag<setter>());\n  desc.data = data;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticValue(\n    const char* utf8name,\n    Napi::Value value,\n    napi_property_attributes attributes) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.utf8name = utf8name;\n  desc.value = value;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline ClassPropertyDescriptor<T> ObjectWrap<T>::StaticValue(\n    Symbol name, Napi::Value value, napi_property_attributes attributes) {\n  napi_property_descriptor desc = napi_property_descriptor();\n  desc.name = name;\n  desc.value = value;\n  desc.attributes =\n      static_cast<napi_property_attributes>(attributes | napi_static);\n  return desc;\n}\n\ntemplate <typename T>\ninline Value ObjectWrap<T>::OnCalledAsFunction(\n    const Napi::CallbackInfo& callbackInfo) {\n  NAPI_THROW(\n      TypeError::New(callbackInfo.Env(),\n                     \"Class constructors cannot be invoked without 'new'\"),\n      Napi::Value());\n}\n\ntemplate <typename T>\ninline void ObjectWrap<T>::Finalize(Napi::Env /*env*/) {}\n\ntemplate <typename T>\ninline void ObjectWrap<T>::Finalize(BasicEnv /*env*/) {}\n\ntemplate <typename T>\ninline napi_value ObjectWrap<T>::ConstructorCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  napi_value new_target;\n  napi_status status = napi_get_new_target(env, info, &new_target);\n  if (status != napi_ok) return nullptr;\n\n  bool isConstructCall = (new_target != nullptr);\n  if (!isConstructCall) {\n    return details::WrapCallback(\n        env, [&] { return T::OnCalledAsFunction(CallbackInfo(env, info)); });\n  }\n\n  napi_value wrapper = details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    T* instance = new T(callbackInfo);\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n    instance->_construction_failed = false;\n#else\n    if (callbackInfo.Env().IsExceptionPending()) {\n      // We need to clear the exception so that removing the wrap might work.\n      Error e = callbackInfo.Env().GetAndClearPendingException();\n      delete instance;\n      e.ThrowAsJavaScriptException();\n    } else {\n      instance->_construction_failed = false;\n    }\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n    return callbackInfo.This();\n  });\n\n  return wrapper;\n}\n\ntemplate <typename T>\ninline napi_value ObjectWrap<T>::StaticVoidMethodCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    StaticVoidMethodCallbackData* callbackData =\n        reinterpret_cast<StaticVoidMethodCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    callbackData->callback(callbackInfo);\n    return nullptr;\n  });\n}\n\ntemplate <typename T>\ninline napi_value ObjectWrap<T>::StaticMethodCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    StaticMethodCallbackData* callbackData =\n        reinterpret_cast<StaticMethodCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    return callbackData->callback(callbackInfo);\n  });\n}\n\ntemplate <typename T>\ninline napi_value ObjectWrap<T>::StaticGetterCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    StaticAccessorCallbackData* callbackData =\n        reinterpret_cast<StaticAccessorCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    return callbackData->getterCallback(callbackInfo);\n  });\n}\n\ntemplate <typename T>\ninline napi_value ObjectWrap<T>::StaticSetterCallbackWrapper(\n    napi_env env, napi_callback_info info) {\n  return details::WrapCallback(env, [&] {\n    CallbackInfo callbackInfo(env, info);\n    StaticAccessorCallbackData* callbackData =\n        reinterpret_cast<StaticAccessorCallbackData*>(callbackInfo.Data());\n    callbackInfo.SetData(callbackData->data);\n    callbackData->setterCallback(callbackInfo, callbackInfo[0]);\n    return nullptr;\n  });\n}\n\ntemplate <typename T>\ninline void ObjectWrap<T>::FinalizeCallback(node_addon_api_basic_env env,\n                                            void* data,\n                                            void* /*hint*/) {\n  // If the child class does not override _any_ Finalize() method, `env` will be\n  // unused because of the constexpr guards. Explicitly reference it here to\n  // bypass compiler warnings.\n  (void)env;\n  T* instance = static_cast<T*>(data);\n\n  // Prevent ~ObjectWrap from calling napi_remove_wrap.\n  // The instance->_ref should be deleted with napi_delete_reference in\n  // ~Reference.\n  instance->_finalized = true;\n\n  // If class overrides the basic finalizer, execute it.\n  if constexpr (details::HasBasicFinalizer<T>::value) {\n#ifndef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n    HandleScope scope(env);\n#endif\n\n    instance->Finalize(Napi::BasicEnv(env));\n  }\n\n  // If class overrides the (extended) finalizer, either schedule it or\n  // execute it immediately (depending on experimental features enabled).\n  if constexpr (details::HasExtendedFinalizer<T>::value) {\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n    // In experimental, attach via node_api_post_finalizer.\n    // `PostFinalizeCallback` is responsible for deleting the `T* instance`,\n    // after calling the user-provided finalizer.\n    napi_status status =\n        node_api_post_finalizer(env, PostFinalizeCallback, data, nullptr);\n    NAPI_FATAL_IF_FAILED(status,\n                         \"ObjectWrap<T>::FinalizeCallback\",\n                         \"node_api_post_finalizer failed\");\n#else\n    // In non-experimental, this `FinalizeCallback` already executes from a\n    // non-basic environment. Execute the override directly.\n    // `PostFinalizeCallback` is responsible for deleting the `T* instance`,\n    // after calling the user-provided finalizer.\n    HandleScope scope(env);\n    PostFinalizeCallback(env, data, static_cast<void*>(nullptr));\n#endif\n  }\n  // If the instance does _not_ override the (extended) finalizer, delete the\n  // `T* instance` immediately.\n  else {\n    delete instance;\n  }\n}\n\ntemplate <typename T>\ninline void ObjectWrap<T>::PostFinalizeCallback(napi_env env,\n                                                void* data,\n                                                void* /*hint*/) {\n  T* instance = static_cast<T*>(data);\n  instance->Finalize(Napi::Env(env));\n  delete instance;\n}\n\ntemplate <typename T>\ntemplate <typename ObjectWrap<T>::StaticSetterCallback method>\ninline napi_value ObjectWrap<T>::WrappedMethod(\n    napi_env env, napi_callback_info info) NAPI_NOEXCEPT {\n  return details::WrapCallback(env, [&] {\n    const CallbackInfo cbInfo(env, info);\n    // MSVC requires to copy 'method' function pointer to a local variable\n    // before invoking it.\n    auto m = method;\n    m(cbInfo, cbInfo[0]);\n    return nullptr;\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HandleScope class\n////////////////////////////////////////////////////////////////////////////////\n\ninline HandleScope::HandleScope(napi_env env, napi_handle_scope scope)\n    : _env(env), _scope(scope) {}\n\ninline HandleScope::HandleScope(Napi::Env env) : _env(env) {\n  napi_status status = napi_open_handle_scope(_env, &_scope);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline HandleScope::~HandleScope() {\n  napi_status status = napi_close_handle_scope(_env, _scope);\n  NAPI_FATAL_IF_FAILED(\n      status, \"HandleScope::~HandleScope\", \"napi_close_handle_scope\");\n}\n\ninline HandleScope::operator napi_handle_scope() const {\n  return _scope;\n}\n\ninline Napi::Env HandleScope::Env() const {\n  return Napi::Env(_env);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// EscapableHandleScope class\n////////////////////////////////////////////////////////////////////////////////\n\ninline EscapableHandleScope::EscapableHandleScope(\n    napi_env env, napi_escapable_handle_scope scope)\n    : _env(env), _scope(scope) {}\n\ninline EscapableHandleScope::EscapableHandleScope(Napi::Env env) : _env(env) {\n  napi_status status = napi_open_escapable_handle_scope(_env, &_scope);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline EscapableHandleScope::~EscapableHandleScope() {\n  napi_status status = napi_close_escapable_handle_scope(_env, _scope);\n  NAPI_FATAL_IF_FAILED(status,\n                       \"EscapableHandleScope::~EscapableHandleScope\",\n                       \"napi_close_escapable_handle_scope\");\n}\n\ninline EscapableHandleScope::operator napi_escapable_handle_scope() const {\n  return _scope;\n}\n\ninline Napi::Env EscapableHandleScope::Env() const {\n  return Napi::Env(_env);\n}\n\ninline Value EscapableHandleScope::Escape(napi_value escapee) {\n  napi_value result;\n  napi_status status = napi_escape_handle(_env, _scope, escapee, &result);\n  NAPI_THROW_IF_FAILED(_env, status, Value());\n  return Value(_env, result);\n}\n\n#if (NAPI_VERSION > 2)\n////////////////////////////////////////////////////////////////////////////////\n// CallbackScope class\n////////////////////////////////////////////////////////////////////////////////\n\ninline CallbackScope::CallbackScope(napi_env env, napi_callback_scope scope)\n    : _env(env), _scope(scope) {}\n\ninline CallbackScope::CallbackScope(napi_env env, napi_async_context context)\n    : _env(env) {\n  napi_status status =\n      napi_open_callback_scope(_env, Object::New(env), context, &_scope);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline CallbackScope::~CallbackScope() {\n  napi_status status = napi_close_callback_scope(_env, _scope);\n  NAPI_FATAL_IF_FAILED(\n      status, \"CallbackScope::~CallbackScope\", \"napi_close_callback_scope\");\n}\n\ninline CallbackScope::operator napi_callback_scope() const {\n  return _scope;\n}\n\ninline Napi::Env CallbackScope::Env() const {\n  return Napi::Env(_env);\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n// AsyncContext class\n////////////////////////////////////////////////////////////////////////////////\n\ninline AsyncContext::AsyncContext(napi_env env, const char* resource_name)\n    : AsyncContext(env, resource_name, Object::New(env)) {}\n\ninline AsyncContext::AsyncContext(napi_env env,\n                                  const char* resource_name,\n                                  const Object& resource)\n    : _env(env), _context(nullptr) {\n  napi_value resource_id;\n  napi_status status = napi_create_string_utf8(\n      _env, resource_name, NAPI_AUTO_LENGTH, &resource_id);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n\n  status = napi_async_init(_env, resource, resource_id, &_context);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline AsyncContext::~AsyncContext() {\n  if (_context != nullptr) {\n    napi_async_destroy(_env, _context);\n    _context = nullptr;\n  }\n}\n\ninline AsyncContext::AsyncContext(AsyncContext&& other) {\n  _env = other._env;\n  other._env = nullptr;\n  _context = other._context;\n  other._context = nullptr;\n}\n\ninline AsyncContext& AsyncContext::operator=(AsyncContext&& other) {\n  _env = other._env;\n  other._env = nullptr;\n  _context = other._context;\n  other._context = nullptr;\n  return *this;\n}\n\ninline AsyncContext::operator napi_async_context() const {\n  return _context;\n}\n\ninline Napi::Env AsyncContext::Env() const {\n  return Napi::Env(_env);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// AsyncWorker class\n////////////////////////////////////////////////////////////////////////////////\n\n#if NAPI_HAS_THREADS\n\ninline AsyncWorker::AsyncWorker(const Function& callback)\n    : AsyncWorker(callback, \"generic\") {}\n\ninline AsyncWorker::AsyncWorker(const Function& callback,\n                                const char* resource_name)\n    : AsyncWorker(callback, resource_name, Object::New(callback.Env())) {}\n\ninline AsyncWorker::AsyncWorker(const Function& callback,\n                                const char* resource_name,\n                                const Object& resource)\n    : AsyncWorker(\n          Object::New(callback.Env()), callback, resource_name, resource) {}\n\ninline AsyncWorker::AsyncWorker(const Object& receiver,\n                                const Function& callback)\n    : AsyncWorker(receiver, callback, \"generic\") {}\n\ninline AsyncWorker::AsyncWorker(const Object& receiver,\n                                const Function& callback,\n                                const char* resource_name)\n    : AsyncWorker(\n          receiver, callback, resource_name, Object::New(callback.Env())) {}\n\ninline AsyncWorker::AsyncWorker(const Object& receiver,\n                                const Function& callback,\n                                const char* resource_name,\n                                const Object& resource)\n    : _env(callback.Env()),\n      _receiver(Napi::Persistent(receiver)),\n      _callback(Napi::Persistent(callback)),\n      _suppress_destruct(false) {\n  napi_value resource_id;\n  napi_status status = napi_create_string_latin1(\n      _env, resource_name, NAPI_AUTO_LENGTH, &resource_id);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n\n  status = napi_create_async_work(_env,\n                                  resource,\n                                  resource_id,\n                                  OnAsyncWorkExecute,\n                                  OnAsyncWorkComplete,\n                                  this,\n                                  &_work);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline AsyncWorker::AsyncWorker(Napi::Env env) : AsyncWorker(env, \"generic\") {}\n\ninline AsyncWorker::AsyncWorker(Napi::Env env, const char* resource_name)\n    : AsyncWorker(env, resource_name, Object::New(env)) {}\n\ninline AsyncWorker::AsyncWorker(Napi::Env env,\n                                const char* resource_name,\n                                const Object& resource)\n    : _env(env), _receiver(), _callback(), _suppress_destruct(false) {\n  napi_value resource_id;\n  napi_status status = napi_create_string_latin1(\n      _env, resource_name, NAPI_AUTO_LENGTH, &resource_id);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n\n  status = napi_create_async_work(_env,\n                                  resource,\n                                  resource_id,\n                                  OnAsyncWorkExecute,\n                                  OnAsyncWorkComplete,\n                                  this,\n                                  &_work);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline AsyncWorker::~AsyncWorker() {\n  if (_work != nullptr) {\n    napi_delete_async_work(_env, _work);\n    _work = nullptr;\n  }\n}\n\ninline void AsyncWorker::Destroy() {\n  delete this;\n}\n\ninline AsyncWorker::operator napi_async_work() const {\n  return _work;\n}\n\ninline Napi::Env AsyncWorker::Env() const {\n  return Napi::Env(_env);\n}\n\ninline void AsyncWorker::Queue() {\n  napi_status status = napi_queue_async_work(_env, _work);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline void AsyncWorker::Cancel() {\n  napi_status status = napi_cancel_async_work(_env, _work);\n  NAPI_THROW_IF_FAILED_VOID(_env, status);\n}\n\ninline ObjectReference& AsyncWorker::Receiver() {\n  return _receiver;\n}\n\ninline FunctionReference& AsyncWorker::Callback() {\n  return _callback;\n}\n\ninline void AsyncWorker::SuppressDestruct() {\n  _suppress_destruct = true;\n}\n\ninline void AsyncWorker::OnOK() {\n  if (!_callback.IsEmpty()) {\n    _callback.Call(_receiver.Value(), GetResult(_callback.Env()));\n  }\n}\n\ninline void AsyncWorker::OnError(const Error& e) {\n  if (!_callback.IsEmpty()) {\n    _callback.Call(_receiver.Value(),\n                   std::initializer_list<napi_value>{e.Value()});\n  }\n}\n\ninline void AsyncWorker::SetError(const std::string& error) {\n  _error = error;\n}\n\ninline std::vector<napi_value> AsyncWorker::GetResult(Napi::Env /*env*/) {\n  return {};\n}\n// The OnAsyncWorkExecute method receives an napi_env argument. However, do NOT\n// use it within this method, as it does not run on the JavaScript thread and\n// must not run any method that would cause JavaScript to run. In practice,\n// this means that almost any use of napi_env will be incorrect.\ninline void AsyncWorker::OnAsyncWorkExecute(napi_env env, void* asyncworker) {\n  AsyncWorker* self = static_cast<AsyncWorker*>(asyncworker);\n  self->OnExecute(env);\n}\n// The OnExecute method receives an napi_env argument. However, do NOT\n// use it within this method, as it does not run on the JavaScript thread and\n// must not run any method that would cause JavaScript to run. In practice,\n// this means that almost any use of napi_env will be incorrect.\ninline void AsyncWorker::OnExecute(Napi::Env /*DO_NOT_USE*/) {\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  try {\n    Execute();\n  } catch (const std::exception& e) {\n    SetError(e.what());\n  }\n#else   // NODE_ADDON_API_CPP_EXCEPTIONS\n  Execute();\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n}\n\ninline void AsyncWorker::OnAsyncWorkComplete(napi_env env,\n                                             napi_status status,\n                                             void* asyncworker) {\n  AsyncWorker* self = static_cast<AsyncWorker*>(asyncworker);\n  self->OnWorkComplete(env, status);\n}\ninline void AsyncWorker::OnWorkComplete(Napi::Env env, napi_status status) {\n  if (status != napi_cancelled) {\n    HandleScope scope(_env);\n    details::WrapCallback(env, [&] {\n      if (_error.size() == 0) {\n        OnOK();\n      } else {\n        OnError(Error::New(_env, _error));\n      }\n      return nullptr;\n    });\n  }\n  if (!_suppress_destruct) {\n    Destroy();\n  }\n}\n\n#endif  // NAPI_HAS_THREADS\n\n#if (NAPI_VERSION > 3 && NAPI_HAS_THREADS)\n////////////////////////////////////////////////////////////////////////////////\n// TypedThreadSafeFunction<ContextType,DataType,CallJs> class\n////////////////////////////////////////////////////////////////////////////////\n\n// Starting with NAPI 5, the JavaScript function `func` parameter of\n// `napi_create_threadsafe_function` is optional.\n#if NAPI_VERSION > 4\n// static, with Callback [missing] Resource [missing] Finalizer [missing]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      nullptr,\n                                      nullptr,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      nullptr,\n                                      nullptr,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with Callback [missing] Resource [passed] Finalizer [missing]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    const Object& resource,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      nullptr,\n                                      resource,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      nullptr,\n                                      nullptr,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with Callback [missing] Resource [missing] Finalizer [passed]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context,\n    Finalizer finalizeCallback,\n    FinalizerDataType* data) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  auto* finalizeData = new details::\n      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(\n          {data, finalizeCallback});\n  auto fini =\n      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::\n          FinalizeFinalizeWrapperWithDataAndContext;\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      nullptr,\n                                      nullptr,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      finalizeData,\n                                      fini,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with Callback [missing] Resource [passed] Finalizer [passed]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    const Object& resource,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context,\n    Finalizer finalizeCallback,\n    FinalizerDataType* data) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  auto* finalizeData = new details::\n      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(\n          {data, finalizeCallback});\n  auto fini =\n      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::\n          FinalizeFinalizeWrapperWithDataAndContext;\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      nullptr,\n                                      resource,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      finalizeData,\n                                      fini,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n#endif\n\n// static, with Callback [passed] Resource [missing] Finalizer [missing]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    const Function& callback,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      callback,\n                                      nullptr,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      nullptr,\n                                      nullptr,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with Callback [passed] Resource [passed] Finalizer [missing]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    const Function& callback,\n    const Object& resource,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      callback,\n                                      resource,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      nullptr,\n                                      nullptr,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with Callback [passed] Resource [missing] Finalizer [passed]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    const Function& callback,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context,\n    Finalizer finalizeCallback,\n    FinalizerDataType* data) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  auto* finalizeData = new details::\n      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(\n          {data, finalizeCallback});\n  auto fini =\n      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::\n          FinalizeFinalizeWrapperWithDataAndContext;\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      callback,\n                                      nullptr,\n                                      String::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      finalizeData,\n                                      fini,\n                                      context,\n                                      CallJsInternal,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\n// static, with: Callback [passed] Resource [passed] Finalizer [passed]\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ntemplate <typename CallbackType,\n          typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::New(\n    napi_env env,\n    CallbackType callback,\n    const Object& resource,\n    ResourceString resourceName,\n    size_t maxQueueSize,\n    size_t initialThreadCount,\n    ContextType* context,\n    Finalizer finalizeCallback,\n    FinalizerDataType* data) {\n  TypedThreadSafeFunction<ContextType, DataType, CallJs> tsfn;\n\n  auto* finalizeData = new details::\n      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(\n          {data, finalizeCallback});\n  auto fini =\n      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::\n          FinalizeFinalizeWrapperWithDataAndContext;\n  napi_status status = napi_create_threadsafe_function(\n      env,\n      details::DefaultCallbackWrapper<\n          CallbackType,\n          TypedThreadSafeFunction<ContextType, DataType, CallJs>>(env,\n                                                                  callback),\n      resource,\n      String::From(env, resourceName),\n      maxQueueSize,\n      initialThreadCount,\n      finalizeData,\n      fini,\n      context,\n      CallJsInternal,\n      &tsfn._tsfn);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(\n        env, status, TypedThreadSafeFunction<ContextType, DataType, CallJs>());\n  }\n\n  return tsfn;\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>::\n    TypedThreadSafeFunction()\n    : _tsfn() {}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>::\n    TypedThreadSafeFunction(napi_threadsafe_function tsfn)\n    : _tsfn(tsfn) {}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline TypedThreadSafeFunction<ContextType, DataType, CallJs>::\noperator napi_threadsafe_function() const {\n  return _tsfn;\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline napi_status\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::BlockingCall(\n    DataType* data) const {\n  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_blocking);\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline napi_status\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::NonBlockingCall(\n    DataType* data) const {\n  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_nonblocking);\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline void TypedThreadSafeFunction<ContextType, DataType, CallJs>::Ref(\n    napi_env env) const {\n  if (_tsfn != nullptr) {\n    napi_status status = napi_ref_threadsafe_function(env, _tsfn);\n    NAPI_THROW_IF_FAILED_VOID(env, status);\n  }\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline void TypedThreadSafeFunction<ContextType, DataType, CallJs>::Unref(\n    napi_env env) const {\n  if (_tsfn != nullptr) {\n    napi_status status = napi_unref_threadsafe_function(env, _tsfn);\n    NAPI_THROW_IF_FAILED_VOID(env, status);\n  }\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline napi_status\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::Acquire() const {\n  return napi_acquire_threadsafe_function(_tsfn);\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline napi_status\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::Release() const {\n  return napi_release_threadsafe_function(_tsfn, napi_tsfn_release);\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline napi_status\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::Abort() const {\n  return napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);\n}\n\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\ninline ContextType*\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::GetContext() const {\n  void* context;\n  napi_status status = napi_get_threadsafe_function_context(_tsfn, &context);\n  NAPI_FATAL_IF_FAILED(status,\n                       \"TypedThreadSafeFunction::GetContext\",\n                       \"napi_get_threadsafe_function_context\");\n  return static_cast<ContextType*>(context);\n}\n\n// static\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\nvoid TypedThreadSafeFunction<ContextType, DataType, CallJs>::CallJsInternal(\n    napi_env env, napi_value jsCallback, void* context, void* data) {\n  details::CallJsWrapper<ContextType, DataType, decltype(CallJs), CallJs>(\n      env, jsCallback, context, data);\n}\n\n#if NAPI_VERSION == 4\n// static\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\nNapi::Function\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::EmptyFunctionFactory(\n    Napi::Env env) {\n  return Napi::Function::New(env, [](const CallbackInfo& cb) {});\n}\n\n// static\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\nNapi::Function\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::FunctionOrEmpty(\n    Napi::Env env, Napi::Function& callback) {\n  if (callback.IsEmpty()) {\n    return EmptyFunctionFactory(env);\n  }\n  return callback;\n}\n\n#else\n// static\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\nstd::nullptr_t\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::EmptyFunctionFactory(\n    Napi::Env /*env*/) {\n  return nullptr;\n}\n\n// static\ntemplate <typename ContextType,\n          typename DataType,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)>\nNapi::Function\nTypedThreadSafeFunction<ContextType, DataType, CallJs>::FunctionOrEmpty(\n    Napi::Env /*env*/, Napi::Function& callback) {\n  return callback;\n}\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n// ThreadSafeFunction class\n////////////////////////////////////////////////////////////////////////////////\n\n// static\ntemplate <typename ResourceString>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount) {\n  return New(\n      env, callback, Object(), resourceName, maxQueueSize, initialThreadCount);\n}\n\n// static\ntemplate <typename ResourceString, typename ContextType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context) {\n  return New(env,\n             callback,\n             Object(),\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             context);\n}\n\n// static\ntemplate <typename ResourceString, typename Finalizer>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  Finalizer finalizeCallback) {\n  return New(env,\n             callback,\n             Object(),\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             finalizeCallback);\n}\n\n// static\ntemplate <typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  Finalizer finalizeCallback,\n                                                  FinalizerDataType* data) {\n  return New(env,\n             callback,\n             Object(),\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             finalizeCallback,\n             data);\n}\n\n// static\ntemplate <typename ResourceString, typename ContextType, typename Finalizer>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context,\n                                                  Finalizer finalizeCallback) {\n  return New(env,\n             callback,\n             Object(),\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             context,\n             finalizeCallback);\n}\n\n// static\ntemplate <typename ResourceString,\n          typename ContextType,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context,\n                                                  Finalizer finalizeCallback,\n                                                  FinalizerDataType* data) {\n  return New(env,\n             callback,\n             Object(),\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             context,\n             finalizeCallback,\n             data);\n}\n\n// static\ntemplate <typename ResourceString>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount) {\n  return New(env,\n             callback,\n             resource,\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             static_cast<void*>(nullptr) /* context */);\n}\n\n// static\ntemplate <typename ResourceString, typename ContextType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context) {\n  return New(env,\n             callback,\n             resource,\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             context,\n             [](Env, ContextType*) {} /* empty finalizer */);\n}\n\n// static\ntemplate <typename ResourceString, typename Finalizer>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  Finalizer finalizeCallback) {\n  return New(env,\n             callback,\n             resource,\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             static_cast<void*>(nullptr) /* context */,\n             finalizeCallback,\n             static_cast<void*>(nullptr) /* data */,\n             details::ThreadSafeFinalize<void, Finalizer>::Wrapper);\n}\n\n// static\ntemplate <typename ResourceString,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  Finalizer finalizeCallback,\n                                                  FinalizerDataType* data) {\n  return New(env,\n             callback,\n             resource,\n             resourceName,\n             maxQueueSize,\n             initialThreadCount,\n             static_cast<void*>(nullptr) /* context */,\n             finalizeCallback,\n             data,\n             details::ThreadSafeFinalize<void, Finalizer, FinalizerDataType>::\n                 FinalizeWrapperWithData);\n}\n\n// static\ntemplate <typename ResourceString, typename ContextType, typename Finalizer>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context,\n                                                  Finalizer finalizeCallback) {\n  return New(\n      env,\n      callback,\n      resource,\n      resourceName,\n      maxQueueSize,\n      initialThreadCount,\n      context,\n      finalizeCallback,\n      static_cast<void*>(nullptr) /* data */,\n      details::ThreadSafeFinalize<ContextType,\n                                  Finalizer>::FinalizeWrapperWithContext);\n}\n\n// static\ntemplate <typename ResourceString,\n          typename ContextType,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context,\n                                                  Finalizer finalizeCallback,\n                                                  FinalizerDataType* data) {\n  return New(\n      env,\n      callback,\n      resource,\n      resourceName,\n      maxQueueSize,\n      initialThreadCount,\n      context,\n      finalizeCallback,\n      data,\n      details::ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>::\n          FinalizeFinalizeWrapperWithDataAndContext);\n}\n\ninline ThreadSafeFunction::ThreadSafeFunction() : _tsfn() {}\n\ninline ThreadSafeFunction::ThreadSafeFunction(napi_threadsafe_function tsfn)\n    : _tsfn(tsfn) {}\n\ninline ThreadSafeFunction::operator napi_threadsafe_function() const {\n  return _tsfn;\n}\n\ninline napi_status ThreadSafeFunction::BlockingCall() const {\n  return CallInternal(nullptr, napi_tsfn_blocking);\n}\n\ntemplate <>\ninline napi_status ThreadSafeFunction::BlockingCall(void* data) const {\n  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_blocking);\n}\n\ntemplate <typename Callback>\ninline napi_status ThreadSafeFunction::BlockingCall(Callback callback) const {\n  return CallInternal(new CallbackWrapper(callback), napi_tsfn_blocking);\n}\n\ntemplate <typename DataType, typename Callback>\ninline napi_status ThreadSafeFunction::BlockingCall(DataType* data,\n                                                    Callback callback) const {\n  auto wrapper = [data, callback](Env env, Function jsCallback) {\n    callback(env, jsCallback, data);\n  };\n  return CallInternal(new CallbackWrapper(wrapper), napi_tsfn_blocking);\n}\n\ninline napi_status ThreadSafeFunction::NonBlockingCall() const {\n  return CallInternal(nullptr, napi_tsfn_nonblocking);\n}\n\ntemplate <>\ninline napi_status ThreadSafeFunction::NonBlockingCall(void* data) const {\n  return napi_call_threadsafe_function(_tsfn, data, napi_tsfn_nonblocking);\n}\n\ntemplate <typename Callback>\ninline napi_status ThreadSafeFunction::NonBlockingCall(\n    Callback callback) const {\n  return CallInternal(new CallbackWrapper(callback), napi_tsfn_nonblocking);\n}\n\ntemplate <typename DataType, typename Callback>\ninline napi_status ThreadSafeFunction::NonBlockingCall(\n    DataType* data, Callback callback) const {\n  auto wrapper = [data, callback](Env env, Function jsCallback) {\n    callback(env, jsCallback, data);\n  };\n  return CallInternal(new CallbackWrapper(wrapper), napi_tsfn_nonblocking);\n}\n\ninline void ThreadSafeFunction::Ref(napi_env env) const {\n  if (_tsfn != nullptr) {\n    napi_status status = napi_ref_threadsafe_function(env, _tsfn);\n    NAPI_THROW_IF_FAILED_VOID(env, status);\n  }\n}\n\ninline void ThreadSafeFunction::Unref(napi_env env) const {\n  if (_tsfn != nullptr) {\n    napi_status status = napi_unref_threadsafe_function(env, _tsfn);\n    NAPI_THROW_IF_FAILED_VOID(env, status);\n  }\n}\n\ninline napi_status ThreadSafeFunction::Acquire() const {\n  return napi_acquire_threadsafe_function(_tsfn);\n}\n\ninline napi_status ThreadSafeFunction::Release() const {\n  return napi_release_threadsafe_function(_tsfn, napi_tsfn_release);\n}\n\ninline napi_status ThreadSafeFunction::Abort() const {\n  return napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);\n}\n\ninline ThreadSafeFunction::ConvertibleContext ThreadSafeFunction::GetContext()\n    const {\n  void* context;\n  napi_status status = napi_get_threadsafe_function_context(_tsfn, &context);\n  NAPI_FATAL_IF_FAILED(status,\n                       \"ThreadSafeFunction::GetContext\",\n                       \"napi_get_threadsafe_function_context\");\n  return ConvertibleContext({context});\n}\n\n// static\ntemplate <typename ResourceString,\n          typename ContextType,\n          typename Finalizer,\n          typename FinalizerDataType>\ninline ThreadSafeFunction ThreadSafeFunction::New(napi_env env,\n                                                  const Function& callback,\n                                                  const Object& resource,\n                                                  ResourceString resourceName,\n                                                  size_t maxQueueSize,\n                                                  size_t initialThreadCount,\n                                                  ContextType* context,\n                                                  Finalizer finalizeCallback,\n                                                  FinalizerDataType* data,\n                                                  napi_finalize wrapper) {\n  static_assert(details::can_make_string<ResourceString>::value ||\n                    std::is_convertible<ResourceString, napi_value>::value,\n                \"Resource name should be convertible to the string type\");\n\n  ThreadSafeFunction tsfn;\n  auto* finalizeData = new details::\n      ThreadSafeFinalize<ContextType, Finalizer, FinalizerDataType>(\n          {data, finalizeCallback});\n  napi_status status =\n      napi_create_threadsafe_function(env,\n                                      callback,\n                                      resource,\n                                      Value::From(env, resourceName),\n                                      maxQueueSize,\n                                      initialThreadCount,\n                                      finalizeData,\n                                      wrapper,\n                                      context,\n                                      CallJS,\n                                      &tsfn._tsfn);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_THROW_IF_FAILED(env, status, ThreadSafeFunction());\n  }\n\n  return tsfn;\n}\n\ninline napi_status ThreadSafeFunction::CallInternal(\n    CallbackWrapper* callbackWrapper,\n    napi_threadsafe_function_call_mode mode) const {\n  napi_status status =\n      napi_call_threadsafe_function(_tsfn, callbackWrapper, mode);\n  if (status != napi_ok && callbackWrapper != nullptr) {\n    delete callbackWrapper;\n  }\n\n  return status;\n}\n\n// static\ninline void ThreadSafeFunction::CallJS(napi_env env,\n                                       napi_value jsCallback,\n                                       void* /* context */,\n                                       void* data) {\n  if (env == nullptr && jsCallback == nullptr) {\n    return;\n  }\n\n  details::WrapVoidCallback(env, [&]() {\n    if (data != nullptr) {\n      auto* callbackWrapper = static_cast<CallbackWrapper*>(data);\n      (*callbackWrapper)(env, Function(env, jsCallback));\n      delete callbackWrapper;\n    } else if (jsCallback != nullptr) {\n      Function(env, jsCallback).Call({});\n    }\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Async Progress Worker Base class\n////////////////////////////////////////////////////////////////////////////////\ntemplate <typename DataType>\ninline AsyncProgressWorkerBase<DataType>::AsyncProgressWorkerBase(\n    const Object& receiver,\n    const Function& callback,\n    const char* resource_name,\n    const Object& resource,\n    size_t queue_size)\n    : AsyncWorker(receiver, callback, resource_name, resource) {\n  // Fill all possible arguments to work around ambiguous\n  // ThreadSafeFunction::New signatures.\n  _tsfn = ThreadSafeFunction::New(callback.Env(),\n                                  callback,\n                                  resource,\n                                  resource_name,\n                                  queue_size,\n                                  /** initialThreadCount */ 1,\n                                  /** context */ this,\n                                  OnThreadSafeFunctionFinalize,\n                                  /** finalizeData */ this);\n}\n\n#if NAPI_VERSION > 4\ntemplate <typename DataType>\ninline AsyncProgressWorkerBase<DataType>::AsyncProgressWorkerBase(\n    Napi::Env env,\n    const char* resource_name,\n    const Object& resource,\n    size_t queue_size)\n    : AsyncWorker(env, resource_name, resource) {\n  // TODO: Once the changes to make the callback optional for threadsafe\n  // functions are available on all versions we can remove the dummy Function\n  // here.\n  Function callback;\n  // Fill all possible arguments to work around ambiguous\n  // ThreadSafeFunction::New signatures.\n  _tsfn = ThreadSafeFunction::New(env,\n                                  callback,\n                                  resource,\n                                  resource_name,\n                                  queue_size,\n                                  /** initialThreadCount */ 1,\n                                  /** context */ this,\n                                  OnThreadSafeFunctionFinalize,\n                                  /** finalizeData */ this);\n}\n#endif\n\ntemplate <typename DataType>\ninline AsyncProgressWorkerBase<DataType>::~AsyncProgressWorkerBase() {\n  // Abort pending tsfn call.\n  // Don't send progress events after we've already completed.\n  // It's ok to call ThreadSafeFunction::Abort and ThreadSafeFunction::Release\n  // duplicated.\n  _tsfn.Abort();\n}\n\ntemplate <typename DataType>\ninline void AsyncProgressWorkerBase<DataType>::OnAsyncWorkProgress(\n    Napi::Env /* env */, Napi::Function /* jsCallback */, void* data) {\n  ThreadSafeData* tsd = static_cast<ThreadSafeData*>(data);\n  tsd->asyncprogressworker()->OnWorkProgress(tsd->data());\n  delete tsd;\n}\n\ntemplate <typename DataType>\ninline napi_status AsyncProgressWorkerBase<DataType>::NonBlockingCall(\n    DataType* data) {\n  auto tsd = new AsyncProgressWorkerBase::ThreadSafeData(this, data);\n  auto ret = _tsfn.NonBlockingCall(tsd, OnAsyncWorkProgress);\n  if (ret != napi_ok) {\n    delete tsd;\n  }\n  return ret;\n}\n\ntemplate <typename DataType>\ninline void AsyncProgressWorkerBase<DataType>::OnWorkComplete(\n    Napi::Env /* env */, napi_status status) {\n  _work_completed = true;\n  _complete_status = status;\n  _tsfn.Release();\n}\n\ntemplate <typename DataType>\ninline void AsyncProgressWorkerBase<DataType>::OnThreadSafeFunctionFinalize(\n    Napi::Env env, void* /* data */, AsyncProgressWorkerBase* context) {\n  if (context->_work_completed) {\n    context->AsyncWorker::OnWorkComplete(env, context->_complete_status);\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Async Progress Worker class\n////////////////////////////////////////////////////////////////////////////////\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback)\n    : AsyncProgressWorker(callback, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback,\n                                                   const char* resource_name)\n    : AsyncProgressWorker(\n          callback, resource_name, Object::New(callback.Env())) {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Function& callback,\n                                                   const char* resource_name,\n                                                   const Object& resource)\n    : AsyncProgressWorker(\n          Object::New(callback.Env()), callback, resource_name, resource) {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,\n                                                   const Function& callback)\n    : AsyncProgressWorker(receiver, callback, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,\n                                                   const Function& callback,\n                                                   const char* resource_name)\n    : AsyncProgressWorker(\n          receiver, callback, resource_name, Object::New(callback.Env())) {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(const Object& receiver,\n                                                   const Function& callback,\n                                                   const char* resource_name,\n                                                   const Object& resource)\n    : AsyncProgressWorkerBase(receiver, callback, resource_name, resource),\n      _asyncdata(nullptr),\n      _asyncsize(0),\n      _signaled(false) {}\n\n#if NAPI_VERSION > 4\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(Napi::Env env)\n    : AsyncProgressWorker(env, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(Napi::Env env,\n                                                   const char* resource_name)\n    : AsyncProgressWorker(env, resource_name, Object::New(env)) {}\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::AsyncProgressWorker(Napi::Env env,\n                                                   const char* resource_name,\n                                                   const Object& resource)\n    : AsyncProgressWorkerBase(env, resource_name, resource),\n      _asyncdata(nullptr),\n      _asyncsize(0) {}\n#endif\n\ntemplate <class T>\ninline AsyncProgressWorker<T>::~AsyncProgressWorker() {\n  {\n    std::lock_guard<std::mutex> lock(this->_mutex);\n    _asyncdata = nullptr;\n    _asyncsize = 0;\n  }\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::Execute() {\n  ExecutionProgress progress(this);\n  Execute(progress);\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::OnWorkProgress(void*) {\n  T* data;\n  size_t size;\n  bool signaled;\n  {\n    std::lock_guard<std::mutex> lock(this->_mutex);\n    data = this->_asyncdata;\n    size = this->_asyncsize;\n    signaled = this->_signaled;\n    this->_asyncdata = nullptr;\n    this->_asyncsize = 0;\n    this->_signaled = false;\n  }\n\n  /**\n   * The callback of ThreadSafeFunction is not been invoked immediately on the\n   * callback of uv_async_t (uv io poll), rather the callback of TSFN is\n   * invoked on the right next uv idle callback. There are chances that during\n   * the deferring the signal of uv_async_t is been sent again, i.e. potential\n   * not coalesced two calls of the TSFN callback.\n   */\n  if (data == nullptr && !signaled) {\n    return;\n  }\n\n  this->OnProgress(data, size);\n  delete[] data;\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::SendProgress_(const T* data, size_t count) {\n  T* new_data = new T[count];\n  std::copy(data, data + count, new_data);\n\n  T* old_data;\n  {\n    std::lock_guard<std::mutex> lock(this->_mutex);\n    old_data = _asyncdata;\n    _asyncdata = new_data;\n    _asyncsize = count;\n    _signaled = false;\n  }\n  this->NonBlockingCall(nullptr);\n\n  delete[] old_data;\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::Signal() {\n  {\n    std::lock_guard<std::mutex> lock(this->_mutex);\n    _signaled = true;\n  }\n  this->NonBlockingCall(static_cast<T*>(nullptr));\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::ExecutionProgress::Signal() const {\n  this->_worker->Signal();\n}\n\ntemplate <class T>\ninline void AsyncProgressWorker<T>::ExecutionProgress::Send(\n    const T* data, size_t count) const {\n  _worker->SendProgress_(data, count);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Async Progress Queue Worker class\n////////////////////////////////////////////////////////////////////////////////\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Function& callback)\n    : AsyncProgressQueueWorker(callback, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Function& callback, const char* resource_name)\n    : AsyncProgressQueueWorker(\n          callback, resource_name, Object::New(callback.Env())) {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Function& callback, const char* resource_name, const Object& resource)\n    : AsyncProgressQueueWorker(\n          Object::New(callback.Env()), callback, resource_name, resource) {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Object& receiver, const Function& callback)\n    : AsyncProgressQueueWorker(receiver, callback, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Object& receiver, const Function& callback, const char* resource_name)\n    : AsyncProgressQueueWorker(\n          receiver, callback, resource_name, Object::New(callback.Env())) {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    const Object& receiver,\n    const Function& callback,\n    const char* resource_name,\n    const Object& resource)\n    : AsyncProgressWorkerBase<std::pair<T*, size_t>>(\n          receiver,\n          callback,\n          resource_name,\n          resource,\n          /** unlimited queue size */ 0) {}\n\n#if NAPI_VERSION > 4\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(Napi::Env env)\n    : AsyncProgressQueueWorker(env, \"generic\") {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    Napi::Env env, const char* resource_name)\n    : AsyncProgressQueueWorker(env, resource_name, Object::New(env)) {}\n\ntemplate <class T>\ninline AsyncProgressQueueWorker<T>::AsyncProgressQueueWorker(\n    Napi::Env env, const char* resource_name, const Object& resource)\n    : AsyncProgressWorkerBase<std::pair<T*, size_t>>(\n          env, resource_name, resource, /** unlimited queue size */ 0) {}\n#endif\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::Execute() {\n  ExecutionProgress progress(this);\n  Execute(progress);\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::OnWorkProgress(\n    std::pair<T*, size_t>* datapair) {\n  if (datapair == nullptr) {\n    return;\n  }\n\n  T* data = datapair->first;\n  size_t size = datapair->second;\n\n  this->OnProgress(data, size);\n  delete datapair;\n  delete[] data;\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::SendProgress_(const T* data,\n                                                       size_t count) {\n  T* new_data = new T[count];\n  std::copy(data, data + count, new_data);\n\n  auto pair = new std::pair<T*, size_t>(new_data, count);\n  this->NonBlockingCall(pair);\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::Signal() const {\n  this->SendProgress_(static_cast<T*>(nullptr), 0);\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::OnWorkComplete(Napi::Env env,\n                                                        napi_status status) {\n  // Draining queued items in TSFN.\n  AsyncProgressWorkerBase<std::pair<T*, size_t>>::OnWorkComplete(env, status);\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::ExecutionProgress::Signal() const {\n  _worker->SendProgress_(static_cast<T*>(nullptr), 0);\n}\n\ntemplate <class T>\ninline void AsyncProgressQueueWorker<T>::ExecutionProgress::Send(\n    const T* data, size_t count) const {\n  _worker->SendProgress_(data, count);\n}\n#endif  // NAPI_VERSION > 3 && NAPI_HAS_THREADS\n\n////////////////////////////////////////////////////////////////////////////////\n// Memory Management class\n////////////////////////////////////////////////////////////////////////////////\n\ninline int64_t MemoryManagement::AdjustExternalMemory(BasicEnv env,\n                                                      int64_t change_in_bytes) {\n  int64_t result;\n  napi_status status =\n      napi_adjust_external_memory(env, change_in_bytes, &result);\n  NAPI_FATAL_IF_FAILED(status,\n                       \"MemoryManagement::AdjustExternalMemory\",\n                       \"napi_adjust_external_memory\");\n  return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Version Management class\n////////////////////////////////////////////////////////////////////////////////\n\ninline uint32_t VersionManagement::GetNapiVersion(BasicEnv env) {\n  uint32_t result;\n  napi_status status = napi_get_version(env, &result);\n  NAPI_FATAL_IF_FAILED(\n      status, \"VersionManagement::GetNapiVersion\", \"napi_get_version\");\n  return result;\n}\n\ninline const napi_node_version* VersionManagement::GetNodeVersion(\n    BasicEnv env) {\n  const napi_node_version* result;\n  napi_status status = napi_get_node_version(env, &result);\n  NAPI_FATAL_IF_FAILED(\n      status, \"VersionManagement::GetNodeVersion\", \"napi_get_node_version\");\n  return result;\n}\n\n#if NAPI_VERSION > 5\n////////////////////////////////////////////////////////////////////////////////\n// Addon<T> class\n////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\ninline Object Addon<T>::Init(Env env, Object exports) {\n  T* addon = new T(env, exports);\n  env.SetInstanceData(addon);\n  return addon->entry_point_;\n}\n\ntemplate <typename T>\ninline T* Addon<T>::Unwrap(Object wrapper) {\n  return wrapper.Env().GetInstanceData<T>();\n}\n\ntemplate <typename T>\ninline void Addon<T>::DefineAddon(\n    Object exports, const std::initializer_list<AddonProp>& props) {\n  DefineProperties(exports, props);\n  entry_point_ = exports;\n}\n\ntemplate <typename T>\ninline Napi::Object Addon<T>::DefineProperties(\n    Object object, const std::initializer_list<AddonProp>& props) {\n  const napi_property_descriptor* properties =\n      reinterpret_cast<const napi_property_descriptor*>(props.begin());\n  size_t size = props.size();\n  napi_status status =\n      napi_define_properties(object.Env(), object, size, properties);\n  NAPI_THROW_IF_FAILED(object.Env(), status, object);\n  for (size_t idx = 0; idx < size; idx++)\n    T::AttachPropData(object.Env(), object, &properties[idx]);\n  return object;\n}\n#endif  // NAPI_VERSION > 5\n\n#if NAPI_VERSION > 2\ntemplate <typename Hook, typename Arg>\nEnv::CleanupHook<Hook, Arg> BasicEnv::AddCleanupHook(Hook hook, Arg* arg) {\n  return CleanupHook<Hook, Arg>(*this, hook, arg);\n}\n\ntemplate <typename Hook>\nEnv::CleanupHook<Hook> BasicEnv::AddCleanupHook(Hook hook) {\n  return CleanupHook<Hook>(*this, hook);\n}\n\ntemplate <typename Hook, typename Arg>\nEnv::CleanupHook<Hook, Arg>::CleanupHook() {\n  data = nullptr;\n}\n\ntemplate <typename Hook, typename Arg>\nEnv::CleanupHook<Hook, Arg>::CleanupHook(Napi::BasicEnv env, Hook hook)\n    : wrapper(Env::CleanupHook<Hook, Arg>::Wrapper) {\n  data = new CleanupData{std::move(hook), nullptr};\n  napi_status status = napi_add_env_cleanup_hook(env, wrapper, data);\n  if (status != napi_ok) {\n    delete data;\n    data = nullptr;\n  }\n}\n\ntemplate <typename Hook, typename Arg>\nEnv::CleanupHook<Hook, Arg>::CleanupHook(Napi::BasicEnv env,\n                                         Hook hook,\n                                         Arg* arg)\n    : wrapper(Env::CleanupHook<Hook, Arg>::WrapperWithArg) {\n  data = new CleanupData{std::move(hook), arg};\n  napi_status status = napi_add_env_cleanup_hook(env, wrapper, data);\n  if (status != napi_ok) {\n    delete data;\n    data = nullptr;\n  }\n}\n\ntemplate <class Hook, class Arg>\nbool Env::CleanupHook<Hook, Arg>::Remove(BasicEnv env) {\n  napi_status status = napi_remove_env_cleanup_hook(env, wrapper, data);\n  delete data;\n  data = nullptr;\n  return status == napi_ok;\n}\n\ntemplate <class Hook, class Arg>\nbool Env::CleanupHook<Hook, Arg>::IsEmpty() const {\n  return data == nullptr;\n}\n#endif  // NAPI_VERSION > 2\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\ntemplate <typename FinalizerType>\ninline void BasicEnv::PostFinalizer(FinalizerType finalizeCallback) const {\n  using T = void*;\n  details::FinalizeData<T, FinalizerType>* finalizeData =\n      new details::FinalizeData<T, FinalizerType>(\n          {std::move(finalizeCallback), nullptr});\n\n  napi_status status = node_api_post_finalizer(\n      _env,\n      details::FinalizeData<T, FinalizerType>::WrapperGCWithoutData,\n      static_cast<void*>(nullptr),\n      finalizeData);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_FATAL_IF_FAILED(\n        status, \"BasicEnv::PostFinalizer\", \"invalid arguments\");\n  }\n}\n\ntemplate <typename FinalizerType, typename T>\ninline void BasicEnv::PostFinalizer(FinalizerType finalizeCallback,\n                                    T* data) const {\n  details::FinalizeData<T, FinalizerType>* finalizeData =\n      new details::FinalizeData<T, FinalizerType>(\n          {std::move(finalizeCallback), nullptr});\n\n  napi_status status = node_api_post_finalizer(\n      _env,\n      details::FinalizeData<T, FinalizerType>::WrapperGC,\n      data,\n      finalizeData);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_FATAL_IF_FAILED(\n        status, \"BasicEnv::PostFinalizer\", \"invalid arguments\");\n  }\n}\n\ntemplate <typename FinalizerType, typename T, typename Hint>\ninline void BasicEnv::PostFinalizer(FinalizerType finalizeCallback,\n                                    T* data,\n                                    Hint* finalizeHint) const {\n  details::FinalizeData<T, FinalizerType, Hint>* finalizeData =\n      new details::FinalizeData<T, FinalizerType, Hint>(\n          {std::move(finalizeCallback), finalizeHint});\n  napi_status status = node_api_post_finalizer(\n      _env,\n      details::FinalizeData<T, FinalizerType, Hint>::WrapperGCWithHint,\n      data,\n      finalizeData);\n  if (status != napi_ok) {\n    delete finalizeData;\n    NAPI_FATAL_IF_FAILED(\n        status, \"BasicEnv::PostFinalizer\", \"invalid arguments\");\n  }\n}\n#endif  // NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n\n#ifdef NAPI_CPP_CUSTOM_NAMESPACE\n}  // namespace NAPI_CPP_CUSTOM_NAMESPACE\n#endif\n\n}  // namespace Napi\n\n#endif  // SRC_NAPI_INL_H_\n"
        },
        {
          "name": "napi.h",
          "type": "blob",
          "size": 116.4912109375,
          "content": "#ifndef SRC_NAPI_H_\n#define SRC_NAPI_H_\n\n#ifndef NAPI_HAS_THREADS\n#if !defined(__wasm__) || (defined(__EMSCRIPTEN_PTHREADS__) ||                 \\\n                           (defined(__wasi__) && defined(_REENTRANT)))\n#define NAPI_HAS_THREADS 1\n#else\n#define NAPI_HAS_THREADS 0\n#endif\n#endif\n\n#include <node_api.h>\n#include <functional>\n#include <initializer_list>\n#include <memory>\n#if NAPI_HAS_THREADS\n#include <mutex>\n#endif  // NAPI_HAS_THREADS\n#include <string>\n#include <vector>\n\n// VS2015 RTM has bugs with constexpr, so require min of VS2015 Update 3 (known\n// good version)\n#if !defined(_MSC_VER) || _MSC_FULL_VER >= 190024210\n#define NAPI_HAS_CONSTEXPR 1\n#endif\n\n// VS2013 does not support char16_t literal strings, so we'll work around it\n// using wchar_t strings and casting them. This is safe as long as the character\n// sizes are the same.\n#if defined(_MSC_VER) && _MSC_VER <= 1800\nstatic_assert(sizeof(char16_t) == sizeof(wchar_t),\n              \"Size mismatch between char16_t and wchar_t\");\n#define NAPI_WIDE_TEXT(x) reinterpret_cast<char16_t*>(L##x)\n#else\n#define NAPI_WIDE_TEXT(x) u##x\n#endif\n\n// Backwards-compatibility to handle the rename of this macro definition, in\n// case they are used within userland code.\n#ifdef NAPI_CPP_EXCEPTIONS\n#define NODE_ADDON_API_CPP_EXCEPTIONS\n#endif\n#if defined(NODE_ADDON_API_CPP_EXCEPTIONS) && !defined(NAPI_CPP_EXCEPTIONS)\n#define NAPI_CPP_EXCEPTIONS\n#endif\n#ifdef NAPI_DISABLE_CPP_EXCEPTIONS\n#define NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS\n#endif\n#if defined(NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS) &&                          \\\n    !defined(NAPI_DISABLE_CPP_EXCEPTIONS)\n#define NAPI_DISABLE_CPP_EXCEPTIONS\n#endif\n\n// If C++ exceptions are not explicitly enabled or disabled, enable them\n// if exceptions were enabled in the compiler settings.\n#if !defined(NODE_ADDON_API_CPP_EXCEPTIONS) &&                                 \\\n    !defined(NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS)\n#if defined(_CPPUNWIND) || defined(__EXCEPTIONS)\n#define NODE_ADDON_API_CPP_EXCEPTIONS\n#else\n#error Exception support not detected. \\\n      Define either NODE_ADDON_API_CPP_EXCEPTIONS or NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS.\n#endif\n#endif\n\n// If C++ NODE_ADDON_API_CPP_EXCEPTIONS are enabled, NODE_ADDON_API_ENABLE_MAYBE\n// should not be set\n#if defined(NODE_ADDON_API_CPP_EXCEPTIONS) &&                                  \\\n    defined(NODE_ADDON_API_ENABLE_MAYBE)\n#error NODE_ADDON_API_ENABLE_MAYBE should not be set when \\\n    NODE_ADDON_API_CPP_EXCEPTIONS is defined.\n#endif\n\n#ifdef _NOEXCEPT\n#define NAPI_NOEXCEPT _NOEXCEPT\n#else\n#define NAPI_NOEXCEPT noexcept\n#endif\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n\n// When C++ exceptions are enabled, Errors are thrown directly. There is no need\n// to return anything after the throw statements. The variadic parameter is an\n// optional return value that is ignored.\n// We need _VOID versions of the macros to avoid warnings resulting from\n// leaving the NAPI_THROW_* `...` argument empty.\n\n#define NAPI_THROW(e, ...) throw e\n#define NAPI_THROW_VOID(e) throw e\n\n#define NAPI_THROW_IF_FAILED(env, status, ...)                                 \\\n  if ((status) != napi_ok) throw Napi::Error::New(env);\n\n#define NAPI_THROW_IF_FAILED_VOID(env, status)                                 \\\n  if ((status) != napi_ok) throw Napi::Error::New(env);\n\n#else  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n// When C++ exceptions are disabled, Errors are thrown as JavaScript exceptions,\n// which are pending until the callback returns to JS.  The variadic parameter\n// is an optional return value; usually it is an empty result.\n// We need _VOID versions of the macros to avoid warnings resulting from\n// leaving the NAPI_THROW_* `...` argument empty.\n\n#define NAPI_THROW(e, ...)                                                     \\\n  do {                                                                         \\\n    (e).ThrowAsJavaScriptException();                                          \\\n    return __VA_ARGS__;                                                        \\\n  } while (0)\n\n#define NAPI_THROW_VOID(e)                                                     \\\n  do {                                                                         \\\n    (e).ThrowAsJavaScriptException();                                          \\\n    return;                                                                    \\\n  } while (0)\n\n#define NAPI_THROW_IF_FAILED(env, status, ...)                                 \\\n  if ((status) != napi_ok) {                                                   \\\n    Napi::Error::New(env).ThrowAsJavaScriptException();                        \\\n    return __VA_ARGS__;                                                        \\\n  }\n\n#define NAPI_THROW_IF_FAILED_VOID(env, status)                                 \\\n  if ((status) != napi_ok) {                                                   \\\n    Napi::Error::New(env).ThrowAsJavaScriptException();                        \\\n    return;                                                                    \\\n  }\n\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n#ifdef NODE_ADDON_API_ENABLE_MAYBE\n#define NAPI_MAYBE_THROW_IF_FAILED(env, status, type)                          \\\n  NAPI_THROW_IF_FAILED(env, status, Napi::Nothing<type>())\n\n#define NAPI_RETURN_OR_THROW_IF_FAILED(env, status, result, type)              \\\n  NAPI_MAYBE_THROW_IF_FAILED(env, status, type);                               \\\n  return Napi::Just<type>(result);\n#else\n#define NAPI_MAYBE_THROW_IF_FAILED(env, status, type)                          \\\n  NAPI_THROW_IF_FAILED(env, status, type())\n\n#define NAPI_RETURN_OR_THROW_IF_FAILED(env, status, result, type)              \\\n  NAPI_MAYBE_THROW_IF_FAILED(env, status, type);                               \\\n  return result;\n#endif\n\n#define NAPI_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&) = delete;\n#define NAPI_DISALLOW_COPY(CLASS) CLASS(const CLASS&) = delete;\n\n#define NAPI_DISALLOW_ASSIGN_COPY(CLASS)                                       \\\n  NAPI_DISALLOW_ASSIGN(CLASS)                                                  \\\n  NAPI_DISALLOW_COPY(CLASS)\n\n#define NAPI_CHECK(condition, location, message)                               \\\n  do {                                                                         \\\n    if (!(condition)) {                                                        \\\n      Napi::Error::Fatal((location), (message));                               \\\n    }                                                                          \\\n  } while (0)\n\n// Internal check helper. Be careful that the formatted message length should be\n// max 255 size and null terminated.\n#define NAPI_INTERNAL_CHECK(expr, location, ...)                               \\\n  do {                                                                         \\\n    if (!(expr)) {                                                             \\\n      std::string msg = Napi::details::StringFormat(__VA_ARGS__);              \\\n      Napi::Error::Fatal(location, msg.c_str());                               \\\n    }                                                                          \\\n  } while (0)\n\n#define NAPI_INTERNAL_CHECK_EQ(actual, expected, value_format, location)       \\\n  do {                                                                         \\\n    auto actual_value = (actual);                                              \\\n    NAPI_INTERNAL_CHECK(actual_value == (expected),                            \\\n                        location,                                              \\\n                        \"Expected \" #actual \" to be equal to \" #expected       \\\n                        \", but got \" value_format \".\",                         \\\n                        actual_value);                                         \\\n  } while (0)\n\n#define NAPI_FATAL_IF_FAILED(status, location, message)                        \\\n  NAPI_CHECK((status) == napi_ok, location, message)\n\n////////////////////////////////////////////////////////////////////////////////\n/// Node-API C++ Wrapper Classes\n///\n/// These classes wrap the \"Node-API\" ABI-stable C APIs for Node.js, providing a\n/// C++ object model and C++ exception-handling semantics with low overhead.\n/// The wrappers are all header-only so that they do not affect the ABI.\n////////////////////////////////////////////////////////////////////////////////\nnamespace Napi {\n\n#ifdef NAPI_CPP_CUSTOM_NAMESPACE\n// NAPI_CPP_CUSTOM_NAMESPACE can be #define'd per-addon to avoid symbol\n// conflicts between different instances of node-addon-api\n\n// First dummy definition of the namespace to make sure that Napi::(name) still\n// refers to the right things inside this file.\nnamespace NAPI_CPP_CUSTOM_NAMESPACE {}\nusing namespace NAPI_CPP_CUSTOM_NAMESPACE;\n\nnamespace NAPI_CPP_CUSTOM_NAMESPACE {\n#endif\n\n// Forward declarations\nclass Env;\nclass Value;\nclass Boolean;\nclass Number;\n#if NAPI_VERSION > 5\nclass BigInt;\n#endif  // NAPI_VERSION > 5\n#if (NAPI_VERSION > 4)\nclass Date;\n#endif\nclass String;\nclass Object;\nclass Array;\nclass ArrayBuffer;\nclass Function;\nclass Error;\nclass PropertyDescriptor;\nclass CallbackInfo;\nclass TypedArray;\ntemplate <typename T>\nclass TypedArrayOf;\n\nusing Int8Array =\n    TypedArrayOf<int8_t>;  ///< Typed-array of signed 8-bit integers\nusing Uint8Array =\n    TypedArrayOf<uint8_t>;  ///< Typed-array of unsigned 8-bit integers\nusing Int16Array =\n    TypedArrayOf<int16_t>;  ///< Typed-array of signed 16-bit integers\nusing Uint16Array =\n    TypedArrayOf<uint16_t>;  ///< Typed-array of unsigned 16-bit integers\nusing Int32Array =\n    TypedArrayOf<int32_t>;  ///< Typed-array of signed 32-bit integers\nusing Uint32Array =\n    TypedArrayOf<uint32_t>;  ///< Typed-array of unsigned 32-bit integers\nusing Float32Array =\n    TypedArrayOf<float>;  ///< Typed-array of 32-bit floating-point values\nusing Float64Array =\n    TypedArrayOf<double>;  ///< Typed-array of 64-bit floating-point values\n#if NAPI_VERSION > 5\nusing BigInt64Array =\n    TypedArrayOf<int64_t>;  ///< Typed array of signed 64-bit integers\nusing BigUint64Array =\n    TypedArrayOf<uint64_t>;  ///< Typed array of unsigned 64-bit integers\n#endif                       // NAPI_VERSION > 5\n\n/// Defines the signature of a Node-API C++ module's registration callback\n/// (init) function.\nusing ModuleRegisterCallback = Object (*)(Env env, Object exports);\n\nclass MemoryManagement;\n\n/// A simple Maybe type, representing an object which may or may not have a\n/// value.\n///\n/// If an API method returns a Maybe<>, the API method can potentially fail\n/// either because an exception is thrown, or because an exception is pending,\n/// e.g. because a previous API call threw an exception that hasn't been\n/// caught yet. In that case, a \"Nothing\" value is returned.\ntemplate <class T>\nclass Maybe {\n public:\n  bool IsNothing() const;\n  bool IsJust() const;\n\n  /// Short-hand for Unwrap(), which doesn't return a value. Could be used\n  /// where the actual value of the Maybe is not needed like Object::Set.\n  /// If this Maybe is nothing (empty), node-addon-api will crash the\n  /// process.\n  void Check() const;\n\n  /// Return the value of type T contained in the Maybe. If this Maybe is\n  /// nothing (empty), node-addon-api will crash the process.\n  T Unwrap() const;\n\n  /// Return the value of type T contained in the Maybe, or using a default\n  /// value if this Maybe is nothing (empty).\n  T UnwrapOr(const T& default_value) const;\n\n  /// Converts this Maybe to a value of type T in the out. If this Maybe is\n  /// nothing (empty), `false` is returned and `out` is left untouched.\n  bool UnwrapTo(T* out) const;\n\n  bool operator==(const Maybe& other) const;\n  bool operator!=(const Maybe& other) const;\n\n private:\n  Maybe();\n  explicit Maybe(const T& t);\n\n  bool _has_value;\n  T _value;\n\n  template <class U>\n  friend Maybe<U> Nothing();\n  template <class U>\n  friend Maybe<U> Just(const U& u);\n};\n\ntemplate <class T>\ninline Maybe<T> Nothing();\n\ntemplate <class T>\ninline Maybe<T> Just(const T& t);\n\n#if defined(NODE_ADDON_API_ENABLE_MAYBE)\ntemplate <typename T>\nusing MaybeOrValue = Maybe<T>;\n#else\ntemplate <typename T>\nusing MaybeOrValue = T;\n#endif\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\nusing node_addon_api_basic_env = node_api_nogc_env;\nusing node_addon_api_basic_finalize = node_api_nogc_finalize;\n#else\nusing node_addon_api_basic_env = napi_env;\nusing node_addon_api_basic_finalize = napi_finalize;\n#endif\n\n/// Environment for Node-API values and operations.\n///\n/// All Node-API values and operations must be associated with an environment.\n/// An environment instance is always provided to callback functions; that\n/// environment must then be used for any creation of Node-API values or other\n/// Node-API operations within the callback. (Many methods infer the\n/// environment from the `this` instance that the method is called on.)\n///\n/// Multiple environments may co-exist in a single process or a thread.\n///\n/// In the V8 JavaScript engine, a Node-API environment approximately\n/// corresponds to an Isolate.\nclass BasicEnv {\n private:\n  node_addon_api_basic_env _env;\n#if NAPI_VERSION > 5\n  template <typename T>\n  static void DefaultFini(Env, T* data);\n  template <typename DataType, typename HintType>\n  static void DefaultFiniWithHint(Env, DataType* data, HintType* hint);\n#endif  // NAPI_VERSION > 5\n public:\n  BasicEnv(node_addon_api_basic_env env);\n\n  operator node_addon_api_basic_env() const;\n\n  // Without these operator overloads, the error:\n  //\n  //    Use of overloaded operator '==' is ambiguous (with operand types\n  //    'Napi::Env' and 'Napi::Env')\n  //\n  // ... occurs when comparing foo.Env() == bar.Env() or foo.Env() == nullptr\n  bool operator==(const BasicEnv& other) const {\n    return _env == other._env;\n  };\n  bool operator==(std::nullptr_t /*other*/) const {\n    return _env == nullptr;\n  };\n\n#if NAPI_VERSION > 2\n  template <typename Hook, typename Arg = void>\n  class CleanupHook;\n\n  template <typename Hook>\n  CleanupHook<Hook> AddCleanupHook(Hook hook);\n\n  template <typename Hook, typename Arg>\n  CleanupHook<Hook, Arg> AddCleanupHook(Hook hook, Arg* arg);\n#endif  // NAPI_VERSION > 2\n\n#if NAPI_VERSION > 5\n  template <typename T>\n  T* GetInstanceData() const;\n\n  template <typename T>\n  using Finalizer = void (*)(Env, T*);\n  template <typename T, Finalizer<T> fini = BasicEnv::DefaultFini<T>>\n  void SetInstanceData(T* data) const;\n\n  template <typename DataType, typename HintType>\n  using FinalizerWithHint = void (*)(Env, DataType*, HintType*);\n  template <typename DataType,\n            typename HintType,\n            FinalizerWithHint<DataType, HintType> fini =\n                BasicEnv::DefaultFiniWithHint<DataType, HintType>>\n  void SetInstanceData(DataType* data, HintType* hint) const;\n#endif  // NAPI_VERSION > 5\n\n#if NAPI_VERSION > 2\n  template <typename Hook, typename Arg>\n  class CleanupHook {\n   public:\n    CleanupHook();\n    CleanupHook(BasicEnv env, Hook hook, Arg* arg);\n    CleanupHook(BasicEnv env, Hook hook);\n    bool Remove(BasicEnv env);\n    bool IsEmpty() const;\n\n   private:\n    static inline void Wrapper(void* data) NAPI_NOEXCEPT;\n    static inline void WrapperWithArg(void* data) NAPI_NOEXCEPT;\n\n    void (*wrapper)(void* arg);\n    struct CleanupData {\n      Hook hook;\n      Arg* arg;\n    } * data;\n  };\n#endif  // NAPI_VERSION > 2\n\n#if NAPI_VERSION > 8\n  const char* GetModuleFileName() const;\n#endif  // NAPI_VERSION > 8\n\n#ifdef NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n  template <typename FinalizerType>\n  inline void PostFinalizer(FinalizerType finalizeCallback) const;\n\n  template <typename FinalizerType, typename T>\n  inline void PostFinalizer(FinalizerType finalizeCallback, T* data) const;\n\n  template <typename FinalizerType, typename T, typename Hint>\n  inline void PostFinalizer(FinalizerType finalizeCallback,\n                            T* data,\n                            Hint* finalizeHint) const;\n#endif  // NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER\n\n  friend class Env;\n};\n\nclass Env : public BasicEnv {\n public:\n  Env(napi_env env);\n\n  operator napi_env() const;\n\n  Object Global() const;\n  Value Undefined() const;\n  Value Null() const;\n\n  bool IsExceptionPending() const;\n  Error GetAndClearPendingException() const;\n\n  MaybeOrValue<Value> RunScript(const char* utf8script) const;\n  MaybeOrValue<Value> RunScript(const std::string& utf8script) const;\n  MaybeOrValue<Value> RunScript(String script) const;\n};\n\n/// A JavaScript value of unknown type.\n///\n/// For type-specific operations, convert to one of the Value subclasses using a\n/// `To*` or `As()` method. The `To*` methods do type coercion; the `As()`\n/// method does not.\n///\n///     Napi::Value value = ...\n///     if (!value.IsString()) throw Napi::TypeError::New(env, \"Invalid\n///     arg...\"); Napi::String str = value.As<Napi::String>(); // Cast to a\n///     string value\n///\n///     Napi::Value anotherValue = ...\n///     bool isTruthy = anotherValue.ToBoolean(); // Coerce to a boolean value\nclass Value {\n public:\n  Value();  ///< Creates a new _empty_ Value instance.\n  Value(napi_env env,\n        napi_value value);  ///< Wraps a Node-API value primitive.\n\n  /// Creates a JS value from a C++ primitive.\n  ///\n  /// `value` may be any of:\n  /// - bool\n  /// - Any integer type\n  /// - Any floating point type\n  /// - const char* (encoded using UTF-8, null-terminated)\n  /// - const char16_t* (encoded using UTF-16-LE, null-terminated)\n  /// - std::string (encoded using UTF-8)\n  /// - std::u16string\n  /// - napi::Value\n  /// - napi_value\n  template <typename T>\n  static Value From(napi_env env, const T& value);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  /// Converts to a Node-API value primitive.\n  ///\n  /// If the instance is _empty_, this returns `nullptr`.\n  operator napi_value() const;\n\n  /// Tests if this value strictly equals another value.\n  bool operator==(const Value& other) const;\n\n  /// Tests if this value does not strictly equal another value.\n  bool operator!=(const Value& other) const;\n\n  /// Tests if this value strictly equals another value.\n  bool StrictEquals(const Value& other) const;\n\n  /// Gets the environment the value is associated with.\n  Napi::Env Env() const;\n\n  /// Checks if the value is empty (uninitialized).\n  ///\n  /// An empty value is invalid, and most attempts to perform an operation on an\n  /// empty value will result in an exception. Note an empty value is distinct\n  /// from JavaScript `null` or `undefined`, which are valid values.\n  ///\n  /// When C++ exceptions are disabled at compile time, a method with a `Value`\n  /// return type may return an empty value to indicate a pending exception. So\n  /// when not using C++ exceptions, callers should check whether the value is\n  /// empty before attempting to use it.\n  bool IsEmpty() const;\n\n  napi_valuetype Type() const;  ///< Gets the type of the value.\n\n  bool IsUndefined()\n      const;            ///< Tests if a value is an undefined JavaScript value.\n  bool IsNull() const;  ///< Tests if a value is a null JavaScript value.\n  bool IsBoolean() const;  ///< Tests if a value is a JavaScript boolean.\n  bool IsNumber() const;   ///< Tests if a value is a JavaScript number.\n#if NAPI_VERSION > 5\n  bool IsBigInt() const;  ///< Tests if a value is a JavaScript bigint.\n#endif                    // NAPI_VERSION > 5\n#if (NAPI_VERSION > 4)\n  bool IsDate() const;  ///< Tests if a value is a JavaScript date.\n#endif\n  bool IsString() const;  ///< Tests if a value is a JavaScript string.\n  bool IsSymbol() const;  ///< Tests if a value is a JavaScript symbol.\n  bool IsArray() const;   ///< Tests if a value is a JavaScript array.\n  bool IsArrayBuffer()\n      const;  ///< Tests if a value is a JavaScript array buffer.\n  bool IsTypedArray() const;  ///< Tests if a value is a JavaScript typed array.\n  bool IsObject() const;      ///< Tests if a value is a JavaScript object.\n  bool IsFunction() const;    ///< Tests if a value is a JavaScript function.\n  bool IsPromise() const;     ///< Tests if a value is a JavaScript promise.\n  bool IsDataView() const;    ///< Tests if a value is a JavaScript data view.\n  bool IsBuffer() const;      ///< Tests if a value is a Node buffer.\n  bool IsExternal() const;  ///< Tests if a value is a pointer to external data.\n\n  /// Casts to another type of `Napi::Value`, when the actual type is known or\n  /// assumed.\n  ///\n  /// This conversion does NOT coerce the type. Calling any methods\n  /// inappropriate for the actual value type will throw `Napi::Error`.\n  ///\n  /// If `NODE_ADDON_API_ENABLE_TYPE_CHECK_ON_AS` is defined, this method\n  /// asserts that the actual type is the expected type.\n  template <typename T>\n  T As() const;\n\n  // Unsafe Value::As(), should be avoided.\n  template <typename T>\n  T UnsafeAs() const;\n\n  MaybeOrValue<Boolean> ToBoolean()\n      const;  ///< Coerces a value to a JavaScript boolean.\n  MaybeOrValue<Number> ToNumber()\n      const;  ///< Coerces a value to a JavaScript number.\n  MaybeOrValue<String> ToString()\n      const;  ///< Coerces a value to a JavaScript string.\n  MaybeOrValue<Object> ToObject()\n      const;  ///< Coerces a value to a JavaScript object.\n\n protected:\n  /// !cond INTERNAL\n  napi_env _env;\n  napi_value _value;\n  /// !endcond\n};\n\n/// A JavaScript boolean value.\nclass Boolean : public Value {\n public:\n  static Boolean New(napi_env env,  ///< Node-API environment\n                     bool value     ///< Boolean value\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Boolean();  ///< Creates a new _empty_ Boolean instance.\n  Boolean(napi_env env,\n          napi_value value);  ///< Wraps a Node-API value primitive.\n\n  operator bool() const;  ///< Converts a Boolean value to a boolean primitive.\n  bool Value() const;     ///< Converts a Boolean value to a boolean primitive.\n};\n\n/// A JavaScript number value.\nclass Number : public Value {\n public:\n  static Number New(napi_env env,  ///< Node-API environment\n                    double value   ///< Number value\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Number();  ///< Creates a new _empty_ Number instance.\n  Number(napi_env env,\n         napi_value value);  ///< Wraps a Node-API value primitive.\n\n  operator int32_t()\n      const;  ///< Converts a Number value to a 32-bit signed integer value.\n  operator uint32_t()\n      const;  ///< Converts a Number value to a 32-bit unsigned integer value.\n  operator int64_t()\n      const;  ///< Converts a Number value to a 64-bit signed integer value.\n  operator float()\n      const;  ///< Converts a Number value to a 32-bit floating-point value.\n  operator double()\n      const;  ///< Converts a Number value to a 64-bit floating-point value.\n\n  int32_t Int32Value()\n      const;  ///< Converts a Number value to a 32-bit signed integer value.\n  uint32_t Uint32Value()\n      const;  ///< Converts a Number value to a 32-bit unsigned integer value.\n  int64_t Int64Value()\n      const;  ///< Converts a Number value to a 64-bit signed integer value.\n  float FloatValue()\n      const;  ///< Converts a Number value to a 32-bit floating-point value.\n  double DoubleValue()\n      const;  ///< Converts a Number value to a 64-bit floating-point value.\n};\n\n#if NAPI_VERSION > 5\n/// A JavaScript bigint value.\nclass BigInt : public Value {\n public:\n  static BigInt New(napi_env env,  ///< Node-API environment\n                    int64_t value  ///< Number value\n  );\n  static BigInt New(napi_env env,   ///< Node-API environment\n                    uint64_t value  ///< Number value\n  );\n\n  /// Creates a new BigInt object using a specified sign bit and a\n  /// specified list of digits/words.\n  /// The resulting number is calculated as:\n  /// (-1)^sign_bit * (words[0] * (2^64)^0 + words[1] * (2^64)^1 + ...)\n  static BigInt New(napi_env env,          ///< Node-API environment\n                    int sign_bit,          ///< Sign bit. 1 if negative.\n                    size_t word_count,     ///< Number of words in array\n                    const uint64_t* words  ///< Array of words\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  BigInt();  ///< Creates a new _empty_ BigInt instance.\n  BigInt(napi_env env,\n         napi_value value);  ///< Wraps a Node-API value primitive.\n\n  int64_t Int64Value(bool* lossless)\n      const;  ///< Converts a BigInt value to a 64-bit signed integer value.\n  uint64_t Uint64Value(bool* lossless)\n      const;  ///< Converts a BigInt value to a 64-bit unsigned integer value.\n\n  size_t WordCount() const;  ///< The number of 64-bit words needed to store\n                             ///< the result of ToWords().\n\n  /// Writes the contents of this BigInt to a specified memory location.\n  /// `sign_bit` must be provided and will be set to 1 if this BigInt is\n  /// negative.\n  /// `*word_count` has to be initialized to the length of the `words` array.\n  /// Upon return, it will be set to the actual number of words that would\n  /// be needed to store this BigInt (i.e. the return value of `WordCount()`).\n  void ToWords(int* sign_bit, size_t* word_count, uint64_t* words);\n};\n#endif  // NAPI_VERSION > 5\n\n#if (NAPI_VERSION > 4)\n/// A JavaScript date value.\nclass Date : public Value {\n public:\n  /// Creates a new Date value from a double primitive.\n  static Date New(napi_env env,  ///< Node-API environment\n                  double value   ///< Number value\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Date();  ///< Creates a new _empty_ Date instance.\n  Date(napi_env env, napi_value value);  ///< Wraps a Node-API value primitive.\n  operator double() const;  ///< Converts a Date value to double primitive\n\n  double ValueOf() const;  ///< Converts a Date value to a double primitive.\n};\n#endif\n\n/// A JavaScript string or symbol value (that can be used as a property name).\nclass Name : public Value {\n public:\n  static void CheckCast(napi_env env, napi_value value);\n\n  Name();  ///< Creates a new _empty_ Name instance.\n  Name(napi_env env,\n       napi_value value);  ///< Wraps a Node-API value primitive.\n};\n\n/// A JavaScript string value.\nclass String : public Name {\n public:\n  /// Creates a new String value from a UTF-8 encoded C++ string.\n  static String New(napi_env env,             ///< Node-API environment\n                    const std::string& value  ///< UTF-8 encoded C++ string\n  );\n\n  /// Creates a new String value from a UTF-16 encoded C++ string.\n  static String New(napi_env env,                ///< Node-API environment\n                    const std::u16string& value  ///< UTF-16 encoded C++ string\n  );\n\n  /// Creates a new String value from a UTF-8 encoded C string.\n  static String New(\n      napi_env env,      ///< Node-API environment\n      const char* value  ///< UTF-8 encoded null-terminated C string\n  );\n\n  /// Creates a new String value from a UTF-16 encoded C string.\n  static String New(\n      napi_env env,          ///< Node-API environment\n      const char16_t* value  ///< UTF-16 encoded null-terminated C string\n  );\n\n  /// Creates a new String value from a UTF-8 encoded C string with specified\n  /// length.\n  static String New(napi_env env,       ///< Node-API environment\n                    const char* value,  ///< UTF-8 encoded C string (not\n                                        ///< necessarily null-terminated)\n                    size_t length       ///< length of the string in bytes\n  );\n\n  /// Creates a new String value from a UTF-16 encoded C string with specified\n  /// length.\n  static String New(\n      napi_env env,           ///< Node-API environment\n      const char16_t* value,  ///< UTF-16 encoded C string (not necessarily\n                              ///< null-terminated)\n      size_t length           ///< Length of the string in 2-byte code units\n  );\n\n  /// Creates a new String based on the original object's type.\n  ///\n  /// `value` may be any of:\n  /// - const char* (encoded using UTF-8, null-terminated)\n  /// - const char16_t* (encoded using UTF-16-LE, null-terminated)\n  /// - std::string (encoded using UTF-8)\n  /// - std::u16string\n  template <typename T>\n  static String From(napi_env env, const T& value);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  String();  ///< Creates a new _empty_ String instance.\n  String(napi_env env,\n         napi_value value);  ///< Wraps a Node-API value primitive.\n\n  operator std::string()\n      const;  ///< Converts a String value to a UTF-8 encoded C++ string.\n  operator std::u16string()\n      const;  ///< Converts a String value to a UTF-16 encoded C++ string.\n  std::string Utf8Value()\n      const;  ///< Converts a String value to a UTF-8 encoded C++ string.\n  std::u16string Utf16Value()\n      const;  ///< Converts a String value to a UTF-16 encoded C++ string.\n};\n\n/// A JavaScript symbol value.\nclass Symbol : public Name {\n public:\n  /// Creates a new Symbol value with an optional description.\n  static Symbol New(\n      napi_env env,  ///< Node-API environment\n      const char* description =\n          nullptr  ///< Optional UTF-8 encoded null-terminated C string\n                   ///  describing the symbol\n  );\n\n  /// Creates a new Symbol value with a description.\n  static Symbol New(\n      napi_env env,  ///< Node-API environment\n      const std::string&\n          description  ///< UTF-8 encoded C++ string describing the symbol\n  );\n\n  /// Creates a new Symbol value with a description.\n  static Symbol New(napi_env env,       ///< Node-API environment\n                    String description  ///< String value describing the symbol\n  );\n\n  /// Creates a new Symbol value with a description.\n  static Symbol New(\n      napi_env env,           ///< Node-API environment\n      napi_value description  ///< String value describing the symbol\n  );\n\n  /// Get a public Symbol (e.g. Symbol.iterator).\n  static MaybeOrValue<Symbol> WellKnown(napi_env, const std::string& name);\n\n  // Create a symbol in the global registry, UTF-8 Encoded cpp string\n  static MaybeOrValue<Symbol> For(napi_env env, const std::string& description);\n\n  // Create a symbol in the global registry, C style string (null terminated)\n  static MaybeOrValue<Symbol> For(napi_env env, const char* description);\n\n  // Create a symbol in the global registry, String value describing the symbol\n  static MaybeOrValue<Symbol> For(napi_env env, String description);\n\n  // Create a symbol in the global registry, napi_value describing the symbol\n  static MaybeOrValue<Symbol> For(napi_env env, napi_value description);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Symbol();  ///< Creates a new _empty_ Symbol instance.\n  Symbol(napi_env env,\n         napi_value value);  ///< Wraps a Node-API value primitive.\n};\n\nclass TypeTaggable : public Value {\n public:\n#if NAPI_VERSION >= 8\n  void TypeTag(const napi_type_tag* type_tag) const;\n  bool CheckTypeTag(const napi_type_tag* type_tag) const;\n#endif  // NAPI_VERSION >= 8\n protected:\n  TypeTaggable();\n  TypeTaggable(napi_env env, napi_value value);\n};\n\n/// A JavaScript object value.\nclass Object : public TypeTaggable {\n public:\n  /// Enables property and element assignments using indexing syntax.\n  ///\n  /// This is a convenient helper to get and set object properties. As\n  /// getting and setting object properties may throw with JavaScript\n  /// exceptions, it is notable that these operations may fail.\n  /// When NODE_ADDON_API_ENABLE_MAYBE is defined, the process will abort\n  /// on JavaScript exceptions.\n  ///\n  /// Example:\n  ///\n  ///     Napi::Value propertyValue = object1['A'];\n  ///     object2['A'] = propertyValue;\n  ///     Napi::Value elementValue = array[0];\n  ///     array[1] = elementValue;\n  template <typename Key>\n  class PropertyLValue {\n   public:\n    /// Converts an L-value to a value.\n    operator Value() const;\n\n    /// Assigns a value to the property. The type of value can be\n    /// anything supported by `Object::Set`.\n    template <typename ValueType>\n    PropertyLValue& operator=(ValueType value);\n\n   private:\n    PropertyLValue() = delete;\n    PropertyLValue(Object object, Key key);\n    napi_env _env;\n    napi_value _object;\n    Key _key;\n\n    friend class Napi::Object;\n  };\n\n  /// Creates a new Object value.\n  static Object New(napi_env env  ///< Node-API environment\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Object();  ///< Creates a new _empty_ Object instance.\n  Object(napi_env env,\n         napi_value value);  ///< Wraps a Node-API value primitive.\n\n  /// Gets or sets a named property.\n  PropertyLValue<std::string> operator[](\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  );\n\n  /// Gets or sets a named property.\n  PropertyLValue<std::string> operator[](\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  );\n\n  /// Gets or sets an indexed property or array element.\n  PropertyLValue<uint32_t> operator[](\n      uint32_t index  /// Property / element index\n  );\n\n  /// Gets or sets an indexed property or array element.\n  PropertyLValue<Value> operator[](Value index  /// Property / element index\n  ) const;\n\n  /// Gets a named property.\n  MaybeOrValue<Value> operator[](\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  ) const;\n\n  /// Gets a named property.\n  MaybeOrValue<Value> operator[](\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  ) const;\n\n  /// Gets an indexed property or array element.\n  MaybeOrValue<Value> operator[](uint32_t index  ///< Property / element index\n  ) const;\n\n  /// Checks whether a property is present.\n  MaybeOrValue<bool> Has(napi_value key  ///< Property key primitive\n  ) const;\n\n  /// Checks whether a property is present.\n  MaybeOrValue<bool> Has(Value key  ///< Property key\n  ) const;\n\n  /// Checks whether a named property is present.\n  MaybeOrValue<bool> Has(\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  ) const;\n\n  /// Checks whether a named property is present.\n  MaybeOrValue<bool> Has(\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  ) const;\n\n  /// Checks whether a own property is present.\n  MaybeOrValue<bool> HasOwnProperty(napi_value key  ///< Property key primitive\n  ) const;\n\n  /// Checks whether a own property is present.\n  MaybeOrValue<bool> HasOwnProperty(Value key  ///< Property key\n  ) const;\n\n  /// Checks whether a own property is present.\n  MaybeOrValue<bool> HasOwnProperty(\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  ) const;\n\n  /// Checks whether a own property is present.\n  MaybeOrValue<bool> HasOwnProperty(\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  ) const;\n\n  /// Gets a property.\n  MaybeOrValue<Value> Get(napi_value key  ///< Property key primitive\n  ) const;\n\n  /// Gets a property.\n  MaybeOrValue<Value> Get(Value key  ///< Property key\n  ) const;\n\n  /// Gets a named property.\n  MaybeOrValue<Value> Get(\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  ) const;\n\n  /// Gets a named property.\n  MaybeOrValue<Value> Get(\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  ) const;\n\n  /// Sets a property.\n  template <typename ValueType>\n  MaybeOrValue<bool> Set(napi_value key,         ///< Property key primitive\n                         const ValueType& value  ///< Property value primitive\n  ) const;\n\n  /// Sets a property.\n  template <typename ValueType>\n  MaybeOrValue<bool> Set(Value key,              ///< Property key\n                         const ValueType& value  ///< Property value\n  ) const;\n\n  /// Sets a named property.\n  template <typename ValueType>\n  MaybeOrValue<bool> Set(\n      const char* utf8name,  ///< UTF-8 encoded null-terminated property name\n      const ValueType& value) const;\n\n  /// Sets a named property.\n  template <typename ValueType>\n  MaybeOrValue<bool> Set(\n      const std::string& utf8name,  ///< UTF-8 encoded property name\n      const ValueType& value        ///< Property value primitive\n  ) const;\n\n  /// Delete property.\n  MaybeOrValue<bool> Delete(napi_value key  ///< Property key primitive\n  ) const;\n\n  /// Delete property.\n  MaybeOrValue<bool> Delete(Value key  ///< Property key\n  ) const;\n\n  /// Delete property.\n  MaybeOrValue<bool> Delete(\n      const char* utf8name  ///< UTF-8 encoded null-terminated property name\n  ) const;\n\n  /// Delete property.\n  MaybeOrValue<bool> Delete(\n      const std::string& utf8name  ///< UTF-8 encoded property name\n  ) const;\n\n  /// Checks whether an indexed property is present.\n  MaybeOrValue<bool> Has(uint32_t index  ///< Property / element index\n  ) const;\n\n  /// Gets an indexed property or array element.\n  MaybeOrValue<Value> Get(uint32_t index  ///< Property / element index\n  ) const;\n\n  /// Sets an indexed property or array element.\n  template <typename ValueType>\n  MaybeOrValue<bool> Set(uint32_t index,         ///< Property / element index\n                         const ValueType& value  ///< Property value primitive\n  ) const;\n\n  /// Deletes an indexed property or array element.\n  MaybeOrValue<bool> Delete(uint32_t index  ///< Property / element index\n  ) const;\n\n  /// This operation can fail in case of Proxy.[[OwnPropertyKeys]] and\n  /// Proxy.[[GetOwnProperty]] calling into JavaScript. See:\n  /// -\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys\n  /// -\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p\n  MaybeOrValue<Array> GetPropertyNames() const;  ///< Get all property names\n\n  /// Defines a property on the object.\n  ///\n  /// This operation can fail in case of Proxy.[[DefineOwnProperty]] calling\n  /// into JavaScript. See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc\n  MaybeOrValue<bool> DefineProperty(\n      const PropertyDescriptor&\n          property  ///< Descriptor for the property to be defined\n  ) const;\n\n  /// Defines properties on the object.\n  ///\n  /// This operation can fail in case of Proxy.[[DefineOwnProperty]] calling\n  /// into JavaScript. See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc\n  MaybeOrValue<bool> DefineProperties(\n      const std::initializer_list<PropertyDescriptor>& properties\n      ///< List of descriptors for the properties to be defined\n  ) const;\n\n  /// Defines properties on the object.\n  ///\n  /// This operation can fail in case of Proxy.[[DefineOwnProperty]] calling\n  /// into JavaScript. See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc\n  MaybeOrValue<bool> DefineProperties(\n      const std::vector<PropertyDescriptor>& properties\n      ///< Vector of descriptors for the properties to be defined\n  ) const;\n\n  /// Checks if an object is an instance created by a constructor function.\n  ///\n  /// This is equivalent to the JavaScript `instanceof` operator.\n  ///\n  /// This operation can fail in case of Proxy.[[GetPrototypeOf]] calling into\n  /// JavaScript.\n  /// See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof\n  MaybeOrValue<bool> InstanceOf(\n      const Function& constructor  ///< Constructor function\n  ) const;\n\n  template <typename Finalizer, typename T>\n  inline void AddFinalizer(Finalizer finalizeCallback, T* data) const;\n\n  template <typename Finalizer, typename T, typename Hint>\n  inline void AddFinalizer(Finalizer finalizeCallback,\n                           T* data,\n                           Hint* finalizeHint) const;\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  class const_iterator;\n\n  inline const_iterator begin() const;\n\n  inline const_iterator end() const;\n\n  class iterator;\n\n  inline iterator begin();\n\n  inline iterator end();\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n#if NAPI_VERSION >= 8\n  /// This operation can fail in case of Proxy.[[GetPrototypeOf]] calling into\n  /// JavaScript.\n  /// See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof\n  MaybeOrValue<bool> Freeze() const;\n  /// This operation can fail in case of Proxy.[[GetPrototypeOf]] calling into\n  /// JavaScript.\n  /// See\n  /// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof\n  MaybeOrValue<bool> Seal() const;\n#endif  // NAPI_VERSION >= 8\n};\n\ntemplate <typename T>\nclass External : public TypeTaggable {\n public:\n  static External New(napi_env env, T* data);\n\n  // Finalizer must implement `void operator()(Env env, T* data)`.\n  template <typename Finalizer>\n  static External New(napi_env env, T* data, Finalizer finalizeCallback);\n  // Finalizer must implement `void operator()(Env env, T* data, Hint* hint)`.\n  template <typename Finalizer, typename Hint>\n  static External New(napi_env env,\n                      T* data,\n                      Finalizer finalizeCallback,\n                      Hint* finalizeHint);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  External();\n  External(napi_env env, napi_value value);\n\n  T* Data() const;\n};\n\nclass Array : public Object {\n public:\n  static Array New(napi_env env);\n  static Array New(napi_env env, size_t length);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Array();\n  Array(napi_env env, napi_value value);\n\n  uint32_t Length() const;\n};\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\nclass Object::const_iterator {\n private:\n  enum class Type { BEGIN, END };\n\n  inline const_iterator(const Object* object, const Type type);\n\n public:\n  inline const_iterator& operator++();\n\n  inline bool operator==(const const_iterator& other) const;\n\n  inline bool operator!=(const const_iterator& other) const;\n\n  inline const std::pair<Value, Object::PropertyLValue<Value>> operator*()\n      const;\n\n private:\n  const Napi::Object* _object;\n  Array _keys;\n  uint32_t _index;\n\n  friend class Object;\n};\n\nclass Object::iterator {\n private:\n  enum class Type { BEGIN, END };\n\n  inline iterator(Object* object, const Type type);\n\n public:\n  inline iterator& operator++();\n\n  inline bool operator==(const iterator& other) const;\n\n  inline bool operator!=(const iterator& other) const;\n\n  inline std::pair<Value, Object::PropertyLValue<Value>> operator*();\n\n private:\n  Napi::Object* _object;\n  Array _keys;\n  uint32_t _index;\n\n  friend class Object;\n};\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n/// A JavaScript array buffer value.\nclass ArrayBuffer : public Object {\n public:\n  /// Creates a new ArrayBuffer instance over a new automatically-allocated\n  /// buffer.\n  static ArrayBuffer New(\n      napi_env env,      ///< Node-API environment\n      size_t byteLength  ///< Length of the buffer to be allocated, in bytes\n  );\n\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  /// Creates a new ArrayBuffer instance, using an external buffer with\n  /// specified byte length.\n  static ArrayBuffer New(\n      napi_env env,        ///< Node-API environment\n      void* externalData,  ///< Pointer to the external buffer to be used by\n                           ///< the array\n      size_t byteLength    ///< Length of the external buffer to be used by the\n                           ///< array, in bytes\n  );\n\n  /// Creates a new ArrayBuffer instance, using an external buffer with\n  /// specified byte length.\n  template <typename Finalizer>\n  static ArrayBuffer New(\n      napi_env env,        ///< Node-API environment\n      void* externalData,  ///< Pointer to the external buffer to be used by\n                           ///< the array\n      size_t byteLength,   ///< Length of the external buffer to be used by the\n                           ///< array,\n                           ///  in bytes\n      Finalizer finalizeCallback  ///< Function to be called when the array\n                                  ///< buffer is destroyed;\n                                  ///  must implement `void operator()(Env env,\n                                  ///  void* externalData)`\n  );\n\n  /// Creates a new ArrayBuffer instance, using an external buffer with\n  /// specified byte length.\n  template <typename Finalizer, typename Hint>\n  static ArrayBuffer New(\n      napi_env env,        ///< Node-API environment\n      void* externalData,  ///< Pointer to the external buffer to be used by\n                           ///< the array\n      size_t byteLength,   ///< Length of the external buffer to be used by the\n                           ///< array,\n                           ///  in bytes\n      Finalizer finalizeCallback,  ///< Function to be called when the array\n                                   ///< buffer is destroyed;\n                                   ///  must implement `void operator()(Env\n                                   ///  env, void* externalData, Hint* hint)`\n      Hint* finalizeHint  ///< Hint (second parameter) to be passed to the\n                          ///< finalize callback\n  );\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  ArrayBuffer();  ///< Creates a new _empty_ ArrayBuffer instance.\n  ArrayBuffer(napi_env env,\n              napi_value value);  ///< Wraps a Node-API value primitive.\n\n  void* Data();         ///< Gets a pointer to the data buffer.\n  size_t ByteLength();  ///< Gets the length of the array buffer in bytes.\n\n#if NAPI_VERSION >= 7\n  bool IsDetached() const;\n  void Detach();\n#endif  // NAPI_VERSION >= 7\n};\n\n/// A JavaScript typed-array value with unknown array type.\n///\n/// For type-specific operations, cast to a `TypedArrayOf<T>` instance using the\n/// `As()` method:\n///\n///     Napi::TypedArray array = ...\n///     if (t.TypedArrayType() == napi_int32_array) {\n///         Napi::Int32Array int32Array = t.As<Napi::Int32Array>();\n///     }\nclass TypedArray : public Object {\n public:\n  static void CheckCast(napi_env env, napi_value value);\n\n  TypedArray();  ///< Creates a new _empty_ TypedArray instance.\n  TypedArray(napi_env env,\n             napi_value value);  ///< Wraps a Node-API value primitive.\n\n  napi_typedarray_type TypedArrayType()\n      const;  ///< Gets the type of this typed-array.\n  Napi::ArrayBuffer ArrayBuffer() const;  ///< Gets the backing array buffer.\n\n  uint8_t ElementSize()\n      const;  ///< Gets the size in bytes of one element in the array.\n  size_t ElementLength() const;  ///< Gets the number of elements in the array.\n  size_t ByteOffset()\n      const;  ///< Gets the offset into the buffer where the array starts.\n  size_t ByteLength() const;  ///< Gets the length of the array in bytes.\n\n protected:\n  /// !cond INTERNAL\n  napi_typedarray_type _type;\n  size_t _length;\n\n  TypedArray(napi_env env,\n             napi_value value,\n             napi_typedarray_type type,\n             size_t length);\n\n  template <typename T>\n  static\n#if defined(NAPI_HAS_CONSTEXPR)\n      constexpr\n#endif\n      napi_typedarray_type\n      TypedArrayTypeForPrimitiveType() {\n    return std::is_same<T, int8_t>::value     ? napi_int8_array\n           : std::is_same<T, uint8_t>::value  ? napi_uint8_array\n           : std::is_same<T, int16_t>::value  ? napi_int16_array\n           : std::is_same<T, uint16_t>::value ? napi_uint16_array\n           : std::is_same<T, int32_t>::value  ? napi_int32_array\n           : std::is_same<T, uint32_t>::value ? napi_uint32_array\n           : std::is_same<T, float>::value    ? napi_float32_array\n           : std::is_same<T, double>::value   ? napi_float64_array\n#if NAPI_VERSION > 5\n           : std::is_same<T, int64_t>::value  ? napi_bigint64_array\n           : std::is_same<T, uint64_t>::value ? napi_biguint64_array\n#endif  // NAPI_VERSION > 5\n                                              : napi_int8_array;\n  }\n  /// !endcond\n};\n\n/// A JavaScript typed-array value with known array type.\n///\n/// Note while it is possible to create and access Uint8 \"clamped\" arrays using\n/// this class, the _clamping_ behavior is only applied in JavaScript.\ntemplate <typename T>\nclass TypedArrayOf : public TypedArray {\n public:\n  /// Creates a new TypedArray instance over a new automatically-allocated array\n  /// buffer.\n  ///\n  /// The array type parameter can normally be omitted (because it is inferred\n  /// from the template parameter T), except when creating a \"clamped\" array:\n  ///\n  ///     Uint8Array::New(env, length, napi_uint8_clamped_array)\n  static TypedArrayOf New(\n      napi_env env,          ///< Node-API environment\n      size_t elementLength,  ///< Length of the created array, as a number of\n                             ///< elements\n#if defined(NAPI_HAS_CONSTEXPR)\n      napi_typedarray_type type =\n          TypedArray::TypedArrayTypeForPrimitiveType<T>()\n#else\n      napi_typedarray_type type\n#endif\n      ///< Type of array, if different from the default array type for the\n      ///< template parameter T.\n  );\n\n  /// Creates a new TypedArray instance over a provided array buffer.\n  ///\n  /// The array type parameter can normally be omitted (because it is inferred\n  /// from the template parameter T), except when creating a \"clamped\" array:\n  ///\n  ///     Uint8Array::New(env, length, buffer, 0, napi_uint8_clamped_array)\n  static TypedArrayOf New(\n      napi_env env,          ///< Node-API environment\n      size_t elementLength,  ///< Length of the created array, as a number of\n                             ///< elements\n      Napi::ArrayBuffer arrayBuffer,  ///< Backing array buffer instance to use\n      size_t bufferOffset,  ///< Offset into the array buffer where the\n                            ///< typed-array starts\n#if defined(NAPI_HAS_CONSTEXPR)\n      napi_typedarray_type type =\n          TypedArray::TypedArrayTypeForPrimitiveType<T>()\n#else\n      napi_typedarray_type type\n#endif\n      ///< Type of array, if different from the default array type for the\n      ///< template parameter T.\n  );\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  TypedArrayOf();  ///< Creates a new _empty_ TypedArrayOf instance.\n  TypedArrayOf(napi_env env,\n               napi_value value);  ///< Wraps a Node-API value primitive.\n\n  T& operator[](size_t index);  ///< Gets or sets an element in the array.\n  const T& operator[](size_t index) const;  ///< Gets an element in the array.\n\n  /// Gets a pointer to the array's backing buffer.\n  ///\n  /// This is not necessarily the same as the `ArrayBuffer::Data()` pointer,\n  /// because the typed-array may have a non-zero `ByteOffset()` into the\n  /// `ArrayBuffer`.\n  T* Data();\n\n  /// Gets a pointer to the array's backing buffer.\n  ///\n  /// This is not necessarily the same as the `ArrayBuffer::Data()` pointer,\n  /// because the typed-array may have a non-zero `ByteOffset()` into the\n  /// `ArrayBuffer`.\n  const T* Data() const;\n\n private:\n  T* _data;\n\n  TypedArrayOf(napi_env env,\n               napi_value value,\n               napi_typedarray_type type,\n               size_t length,\n               T* data);\n};\n\n/// The DataView provides a low-level interface for reading/writing multiple\n/// number types in an ArrayBuffer irrespective of the platform's endianness.\nclass DataView : public Object {\n public:\n  static DataView New(napi_env env, Napi::ArrayBuffer arrayBuffer);\n  static DataView New(napi_env env,\n                      Napi::ArrayBuffer arrayBuffer,\n                      size_t byteOffset);\n  static DataView New(napi_env env,\n                      Napi::ArrayBuffer arrayBuffer,\n                      size_t byteOffset,\n                      size_t byteLength);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  DataView();  ///< Creates a new _empty_ DataView instance.\n  DataView(napi_env env,\n           napi_value value);  ///< Wraps a Node-API value primitive.\n\n  Napi::ArrayBuffer ArrayBuffer() const;  ///< Gets the backing array buffer.\n  size_t ByteOffset()\n      const;  ///< Gets the offset into the buffer where the array starts.\n  size_t ByteLength() const;  ///< Gets the length of the array in bytes.\n\n  void* Data() const;\n\n  float GetFloat32(size_t byteOffset) const;\n  double GetFloat64(size_t byteOffset) const;\n  int8_t GetInt8(size_t byteOffset) const;\n  int16_t GetInt16(size_t byteOffset) const;\n  int32_t GetInt32(size_t byteOffset) const;\n  uint8_t GetUint8(size_t byteOffset) const;\n  uint16_t GetUint16(size_t byteOffset) const;\n  uint32_t GetUint32(size_t byteOffset) const;\n\n  void SetFloat32(size_t byteOffset, float value) const;\n  void SetFloat64(size_t byteOffset, double value) const;\n  void SetInt8(size_t byteOffset, int8_t value) const;\n  void SetInt16(size_t byteOffset, int16_t value) const;\n  void SetInt32(size_t byteOffset, int32_t value) const;\n  void SetUint8(size_t byteOffset, uint8_t value) const;\n  void SetUint16(size_t byteOffset, uint16_t value) const;\n  void SetUint32(size_t byteOffset, uint32_t value) const;\n\n private:\n  template <typename T>\n  T ReadData(size_t byteOffset) const;\n\n  template <typename T>\n  void WriteData(size_t byteOffset, T value) const;\n\n  void* _data{};\n  size_t _length{};\n};\n\nclass Function : public Object {\n public:\n  using VoidCallback = void (*)(const CallbackInfo& info);\n  using Callback = Value (*)(const CallbackInfo& info);\n\n  template <VoidCallback cb>\n  static Function New(napi_env env,\n                      const char* utf8name = nullptr,\n                      void* data = nullptr);\n\n  template <Callback cb>\n  static Function New(napi_env env,\n                      const char* utf8name = nullptr,\n                      void* data = nullptr);\n\n  template <VoidCallback cb>\n  static Function New(napi_env env,\n                      const std::string& utf8name,\n                      void* data = nullptr);\n\n  template <Callback cb>\n  static Function New(napi_env env,\n                      const std::string& utf8name,\n                      void* data = nullptr);\n\n  /// Callable must implement operator() accepting a const CallbackInfo&\n  /// and return either void or Value.\n  template <typename Callable>\n  static Function New(napi_env env,\n                      Callable cb,\n                      const char* utf8name = nullptr,\n                      void* data = nullptr);\n  /// Callable must implement operator() accepting a const CallbackInfo&\n  /// and return either void or Value.\n  template <typename Callable>\n  static Function New(napi_env env,\n                      Callable cb,\n                      const std::string& utf8name,\n                      void* data = nullptr);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Function();\n  Function(napi_env env, napi_value value);\n\n  MaybeOrValue<Value> operator()(\n      const std::initializer_list<napi_value>& args) const;\n\n  MaybeOrValue<Value> Call(const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Value> Call(const std::vector<napi_value>& args) const;\n  MaybeOrValue<Value> Call(const std::vector<Value>& args) const;\n  MaybeOrValue<Value> Call(size_t argc, const napi_value* args) const;\n  MaybeOrValue<Value> Call(napi_value recv,\n                           const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Value> Call(napi_value recv,\n                           const std::vector<napi_value>& args) const;\n  MaybeOrValue<Value> Call(napi_value recv,\n                           const std::vector<Value>& args) const;\n  MaybeOrValue<Value> Call(napi_value recv,\n                           size_t argc,\n                           const napi_value* args) const;\n\n  MaybeOrValue<Value> MakeCallback(\n      napi_value recv,\n      const std::initializer_list<napi_value>& args,\n      napi_async_context context = nullptr) const;\n  MaybeOrValue<Value> MakeCallback(napi_value recv,\n                                   const std::vector<napi_value>& args,\n                                   napi_async_context context = nullptr) const;\n  MaybeOrValue<Value> MakeCallback(napi_value recv,\n                                   size_t argc,\n                                   const napi_value* args,\n                                   napi_async_context context = nullptr) const;\n\n  MaybeOrValue<Object> New(const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Object> New(const std::vector<napi_value>& args) const;\n  MaybeOrValue<Object> New(size_t argc, const napi_value* args) const;\n};\n\nclass Promise : public Object {\n public:\n  class Deferred {\n   public:\n    static Deferred New(napi_env env);\n    Deferred(napi_env env);\n\n    Napi::Promise Promise() const;\n    Napi::Env Env() const;\n\n    void Resolve(napi_value value) const;\n    void Reject(napi_value value) const;\n\n   private:\n    napi_env _env;\n    napi_deferred _deferred;\n    napi_value _promise;\n  };\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Promise(napi_env env, napi_value value);\n};\n\ntemplate <typename T>\nclass Buffer : public Uint8Array {\n public:\n  static Buffer<T> New(napi_env env, size_t length);\n#ifndef NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n  static Buffer<T> New(napi_env env, T* data, size_t length);\n\n  // Finalizer must implement `void operator()(Env env, T* data)`.\n  template <typename Finalizer>\n  static Buffer<T> New(napi_env env,\n                       T* data,\n                       size_t length,\n                       Finalizer finalizeCallback);\n  // Finalizer must implement `void operator()(Env env, T* data, Hint* hint)`.\n  template <typename Finalizer, typename Hint>\n  static Buffer<T> New(napi_env env,\n                       T* data,\n                       size_t length,\n                       Finalizer finalizeCallback,\n                       Hint* finalizeHint);\n#endif  // NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED\n\n  static Buffer<T> NewOrCopy(napi_env env, T* data, size_t length);\n  // Finalizer must implement `void operator()(Env env, T* data)`.\n  template <typename Finalizer>\n  static Buffer<T> NewOrCopy(napi_env env,\n                             T* data,\n                             size_t length,\n                             Finalizer finalizeCallback);\n  // Finalizer must implement `void operator()(Env env, T* data, Hint* hint)`.\n  template <typename Finalizer, typename Hint>\n  static Buffer<T> NewOrCopy(napi_env env,\n                             T* data,\n                             size_t length,\n                             Finalizer finalizeCallback,\n                             Hint* finalizeHint);\n\n  static Buffer<T> Copy(napi_env env, const T* data, size_t length);\n\n  static void CheckCast(napi_env env, napi_value value);\n\n  Buffer();\n  Buffer(napi_env env, napi_value value);\n  size_t Length() const;\n  T* Data() const;\n\n private:\n};\n\n/// Holds a counted reference to a value; initially a weak reference unless\n/// otherwise specified, may be changed to/from a strong reference by adjusting\n/// the refcount.\n///\n/// The referenced value is not immediately destroyed when the reference count\n/// is zero; it is merely then eligible for garbage-collection if there are no\n/// other references to the value.\ntemplate <typename T>\nclass Reference {\n public:\n  static Reference<T> New(const T& value, uint32_t initialRefcount = 0);\n\n  Reference();\n  Reference(napi_env env, napi_ref ref);\n  ~Reference();\n\n  // A reference can be moved but cannot be copied.\n  Reference(Reference<T>&& other);\n  Reference<T>& operator=(Reference<T>&& other);\n  NAPI_DISALLOW_ASSIGN(Reference<T>)\n\n  operator napi_ref() const;\n  bool operator==(const Reference<T>& other) const;\n  bool operator!=(const Reference<T>& other) const;\n\n  Napi::Env Env() const;\n  bool IsEmpty() const;\n\n  // Note when getting the value of a Reference it is usually correct to do so\n  // within a HandleScope so that the value handle gets cleaned up efficiently.\n  T Value() const;\n\n  uint32_t Ref() const;\n  uint32_t Unref() const;\n  void Reset();\n  void Reset(const T& value, uint32_t refcount = 0);\n\n  // Call this on a reference that is declared as static data, to prevent its\n  // destructor from running at program shutdown time, which would attempt to\n  // reset the reference when the environment is no longer valid. Avoid using\n  // this if at all possible. If you do need to use static data, MAKE SURE to\n  // warn your users that your addon is NOT threadsafe.\n  void SuppressDestruct();\n\n protected:\n  Reference(const Reference<T>&);\n\n  /// !cond INTERNAL\n  napi_env _env;\n  napi_ref _ref;\n  /// !endcond\n\n private:\n  bool _suppressDestruct;\n};\n\nclass ObjectReference : public Reference<Object> {\n public:\n  ObjectReference();\n  ObjectReference(napi_env env, napi_ref ref);\n\n  // A reference can be moved but cannot be copied.\n  ObjectReference(Reference<Object>&& other);\n  ObjectReference& operator=(Reference<Object>&& other);\n  ObjectReference(ObjectReference&& other);\n  ObjectReference& operator=(ObjectReference&& other);\n  NAPI_DISALLOW_ASSIGN(ObjectReference)\n\n  MaybeOrValue<Napi::Value> Get(const char* utf8name) const;\n  MaybeOrValue<Napi::Value> Get(const std::string& utf8name) const;\n  MaybeOrValue<bool> Set(const char* utf8name, napi_value value) const;\n  MaybeOrValue<bool> Set(const char* utf8name, Napi::Value value) const;\n  MaybeOrValue<bool> Set(const char* utf8name, const char* utf8value) const;\n  MaybeOrValue<bool> Set(const char* utf8name, bool boolValue) const;\n  MaybeOrValue<bool> Set(const char* utf8name, double numberValue) const;\n  MaybeOrValue<bool> Set(const std::string& utf8name, napi_value value) const;\n  MaybeOrValue<bool> Set(const std::string& utf8name, Napi::Value value) const;\n  MaybeOrValue<bool> Set(const std::string& utf8name,\n                         std::string& utf8value) const;\n  MaybeOrValue<bool> Set(const std::string& utf8name, bool boolValue) const;\n  MaybeOrValue<bool> Set(const std::string& utf8name, double numberValue) const;\n\n  MaybeOrValue<Napi::Value> Get(uint32_t index) const;\n  MaybeOrValue<bool> Set(uint32_t index, const napi_value value) const;\n  MaybeOrValue<bool> Set(uint32_t index, const Napi::Value value) const;\n  MaybeOrValue<bool> Set(uint32_t index, const char* utf8value) const;\n  MaybeOrValue<bool> Set(uint32_t index, const std::string& utf8value) const;\n  MaybeOrValue<bool> Set(uint32_t index, bool boolValue) const;\n  MaybeOrValue<bool> Set(uint32_t index, double numberValue) const;\n\n protected:\n  ObjectReference(const ObjectReference&);\n};\n\nclass FunctionReference : public Reference<Function> {\n public:\n  FunctionReference();\n  FunctionReference(napi_env env, napi_ref ref);\n\n  // A reference can be moved but cannot be copied.\n  FunctionReference(Reference<Function>&& other);\n  FunctionReference& operator=(Reference<Function>&& other);\n  FunctionReference(FunctionReference&& other);\n  FunctionReference& operator=(FunctionReference&& other);\n  NAPI_DISALLOW_ASSIGN_COPY(FunctionReference)\n\n  MaybeOrValue<Napi::Value> operator()(\n      const std::initializer_list<napi_value>& args) const;\n\n  MaybeOrValue<Napi::Value> Call(\n      const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Napi::Value> Call(const std::vector<napi_value>& args) const;\n  MaybeOrValue<Napi::Value> Call(\n      napi_value recv, const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Napi::Value> Call(napi_value recv,\n                                 const std::vector<napi_value>& args) const;\n  MaybeOrValue<Napi::Value> Call(napi_value recv,\n                                 size_t argc,\n                                 const napi_value* args) const;\n\n  MaybeOrValue<Napi::Value> MakeCallback(\n      napi_value recv,\n      const std::initializer_list<napi_value>& args,\n      napi_async_context context = nullptr) const;\n  MaybeOrValue<Napi::Value> MakeCallback(\n      napi_value recv,\n      const std::vector<napi_value>& args,\n      napi_async_context context = nullptr) const;\n  MaybeOrValue<Napi::Value> MakeCallback(\n      napi_value recv,\n      size_t argc,\n      const napi_value* args,\n      napi_async_context context = nullptr) const;\n\n  MaybeOrValue<Object> New(const std::initializer_list<napi_value>& args) const;\n  MaybeOrValue<Object> New(const std::vector<napi_value>& args) const;\n};\n\n// Shortcuts to creating a new reference with inferred type and refcount = 0.\ntemplate <typename T>\nReference<T> Weak(T value);\nObjectReference Weak(Object value);\nFunctionReference Weak(Function value);\n\n// Shortcuts to creating a new reference with inferred type and refcount = 1.\ntemplate <typename T>\nReference<T> Persistent(T value);\nObjectReference Persistent(Object value);\nFunctionReference Persistent(Function value);\n\n/// A persistent reference to a JavaScript error object. Use of this class\n/// depends somewhat on whether C++ exceptions are enabled at compile time.\n///\n/// ### Handling Errors With C++ Exceptions\n///\n/// If C++ exceptions are enabled, then the `Error` class extends\n/// `std::exception` and enables integrated error-handling for C++ exceptions\n/// and JavaScript exceptions.\n///\n/// If a Node-API call fails without executing any JavaScript code (for\n/// example due to an invalid argument), then the Node-API wrapper\n/// automatically converts and throws the error as a C++ exception of type\n/// `Napi::Error`. Or if a JavaScript function called by C++ code via Node-API\n/// throws a JavaScript exception, then the Node-API wrapper automatically\n/// converts and throws it as a C++ exception of type `Napi::Error`.\n///\n/// If a C++ exception of type `Napi::Error` escapes from a Node-API C++\n/// callback, then the Node-API wrapper automatically converts and throws it\n/// as a JavaScript exception. Therefore, catching a C++ exception of type\n/// `Napi::Error` prevents a JavaScript exception from being thrown.\n///\n/// #### Example 1A - Throwing a C++ exception:\n///\n///     Napi::Env env = ...\n///     throw Napi::Error::New(env, \"Example exception\");\n///\n/// Following C++ statements will not be executed. The exception will bubble\n/// up as a C++ exception of type `Napi::Error`, until it is either caught\n/// while still in C++, or else automatically propagated as a JavaScript\n/// exception when the callback returns to JavaScript.\n///\n/// #### Example 2A - Propagating a Node-API C++ exception:\n///\n///     Napi::Function jsFunctionThatThrows = someObj.As<Napi::Function>();\n///     Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });\n///\n/// Following C++ statements will not be executed. The exception will bubble\n/// up as a C++ exception of type `Napi::Error`, until it is either caught\n/// while still in C++, or else automatically propagated as a JavaScript\n/// exception when the callback returns to JavaScript.\n///\n/// #### Example 3A - Handling a Node-API C++ exception:\n///\n///     Napi::Function jsFunctionThatThrows = someObj.As<Napi::Function>();\n///     Napi::Value result;\n///     try {\n///        result = jsFunctionThatThrows({ arg1, arg2 });\n///     } catch (const Napi::Error& e) {\n///       cerr << \"Caught JavaScript exception: \" + e.what();\n///     }\n///\n/// Since the exception was caught here, it will not be propagated as a\n/// JavaScript exception.\n///\n/// ### Handling Errors Without C++ Exceptions\n///\n/// If C++ exceptions are disabled (by defining\n/// `NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS`) then this class does not extend\n/// `std::exception`, and APIs in the `Napi` namespace do not throw C++\n/// exceptions when they fail. Instead, they raise _pending_ JavaScript\n/// exceptions and return _empty_ `Value`s. Calling code should check\n/// `Value::IsEmpty()` before attempting to use a returned value, and may use\n/// methods on the `Env` class to check for, get, and clear a pending JavaScript\n/// exception. If the pending exception is not cleared, it will be thrown when\n/// the native callback returns to JavaScript.\n///\n/// #### Example 1B - Throwing a JS exception\n///\n///     Napi::Env env = ...\n///     Napi::Error::New(env, \"Example\n///     exception\").ThrowAsJavaScriptException(); return;\n///\n/// After throwing a JS exception, the code should generally return\n/// immediately from the native callback, after performing any necessary\n/// cleanup.\n///\n/// #### Example 2B - Propagating a Node-API JS exception:\n///\n///     Napi::Function jsFunctionThatThrows = someObj.As<Napi::Function>();\n///     Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });\n///     if (result.IsEmpty()) return;\n///\n/// An empty value result from a Node-API call indicates an error occurred,\n/// and a JavaScript exception is pending. To let the exception propagate, the\n/// code should generally return immediately from the native callback, after\n/// performing any necessary cleanup.\n///\n/// #### Example 3B - Handling a Node-API JS exception:\n///\n///     Napi::Function jsFunctionThatThrows = someObj.As<Napi::Function>();\n///     Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });\n///     if (result.IsEmpty()) {\n///       Napi::Error e = env.GetAndClearPendingException();\n///       cerr << \"Caught JavaScript exception: \" + e.Message();\n///     }\n///\n/// Since the exception was cleared here, it will not be propagated as a\n/// JavaScript exception after the native callback returns.\nclass Error : public ObjectReference\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n    ,\n              public std::exception\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n{\n public:\n  static Error New(napi_env env);\n  static Error New(napi_env env, const char* message);\n  static Error New(napi_env env, const std::string& message);\n\n  static NAPI_NO_RETURN void Fatal(const char* location, const char* message);\n\n  Error();\n  Error(napi_env env, napi_value value);\n\n  // An error can be moved or copied.\n  Error(Error&& other);\n  Error& operator=(Error&& other);\n  Error(const Error&);\n  Error& operator=(const Error&);\n\n  const std::string& Message() const NAPI_NOEXCEPT;\n  void ThrowAsJavaScriptException() const;\n\n  Object Value() const;\n\n#ifdef NODE_ADDON_API_CPP_EXCEPTIONS\n  const char* what() const NAPI_NOEXCEPT override;\n#endif  // NODE_ADDON_API_CPP_EXCEPTIONS\n\n protected:\n  /// !cond INTERNAL\n  using create_error_fn = napi_status (*)(napi_env envb,\n                                          napi_value code,\n                                          napi_value msg,\n                                          napi_value* result);\n\n  template <typename TError>\n  static TError New(napi_env env,\n                    const char* message,\n                    size_t length,\n                    create_error_fn create_error);\n  /// !endcond\n\n private:\n  static inline const char* ERROR_WRAP_VALUE() NAPI_NOEXCEPT;\n  mutable std::string _message;\n};\n\nclass TypeError : public Error {\n public:\n  static TypeError New(napi_env env, const char* message);\n  static TypeError New(napi_env env, const std::string& message);\n\n  TypeError();\n  TypeError(napi_env env, napi_value value);\n};\n\nclass RangeError : public Error {\n public:\n  static RangeError New(napi_env env, const char* message);\n  static RangeError New(napi_env env, const std::string& message);\n\n  RangeError();\n  RangeError(napi_env env, napi_value value);\n};\n\n#if NAPI_VERSION > 8\nclass SyntaxError : public Error {\n public:\n  static SyntaxError New(napi_env env, const char* message);\n  static SyntaxError New(napi_env env, const std::string& message);\n\n  SyntaxError();\n  SyntaxError(napi_env env, napi_value value);\n};\n#endif  // NAPI_VERSION > 8\n\nclass CallbackInfo {\n public:\n  CallbackInfo(napi_env env, napi_callback_info info);\n  ~CallbackInfo();\n\n  // Disallow copying to prevent multiple free of _dynamicArgs\n  NAPI_DISALLOW_ASSIGN_COPY(CallbackInfo)\n\n  Napi::Env Env() const;\n  Value NewTarget() const;\n  bool IsConstructCall() const;\n  size_t Length() const;\n  const Value operator[](size_t index) const;\n  Value This() const;\n  void* Data() const;\n  void SetData(void* data);\n  explicit operator napi_callback_info() const;\n\n private:\n  const size_t _staticArgCount = 6;\n  napi_env _env;\n  napi_callback_info _info;\n  napi_value _this;\n  size_t _argc;\n  napi_value* _argv;\n  napi_value _staticArgs[6]{};\n  napi_value* _dynamicArgs;\n  void* _data;\n};\n\nclass PropertyDescriptor {\n public:\n  using GetterCallback = Napi::Value (*)(const Napi::CallbackInfo& info);\n  using SetterCallback = void (*)(const Napi::CallbackInfo& info);\n\n#ifndef NODE_ADDON_API_DISABLE_DEPRECATED\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      const char* utf8name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      const std::string& utf8name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      napi_value name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      Name name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      const char* utf8name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      const std::string& utf8name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      napi_value name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      Name name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      const char* utf8name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      const std::string& utf8name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      napi_value name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      Name name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n#endif  // !NODE_ADDON_API_DISABLE_DEPRECATED\n\n  template <GetterCallback Getter>\n  static PropertyDescriptor Accessor(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <GetterCallback Getter>\n  static PropertyDescriptor Accessor(\n      const std::string& utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <GetterCallback Getter>\n  static PropertyDescriptor Accessor(\n      Name name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <GetterCallback Getter, SetterCallback Setter>\n  static PropertyDescriptor Accessor(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <GetterCallback Getter, SetterCallback Setter>\n  static PropertyDescriptor Accessor(\n      const std::string& utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <GetterCallback Getter, SetterCallback Setter>\n  static PropertyDescriptor Accessor(\n      Name name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      const char* utf8name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      const std::string& utf8name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      Name name,\n      Getter getter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      const char* utf8name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      const std::string& utf8name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Getter, typename Setter>\n  static PropertyDescriptor Accessor(\n      Napi::Env env,\n      Napi::Object object,\n      Name name,\n      Getter getter,\n      Setter setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      Napi::Env env,\n      Napi::Object object,\n      const char* utf8name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      Napi::Env env,\n      Napi::Object object,\n      const std::string& utf8name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <typename Callable>\n  static PropertyDescriptor Function(\n      Napi::Env env,\n      Napi::Object object,\n      Name name,\n      Callable cb,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor Value(\n      const char* utf8name,\n      napi_value value,\n      napi_property_attributes attributes = napi_default);\n  static PropertyDescriptor Value(\n      const std::string& utf8name,\n      napi_value value,\n      napi_property_attributes attributes = napi_default);\n  static PropertyDescriptor Value(\n      napi_value name,\n      napi_value value,\n      napi_property_attributes attributes = napi_default);\n  static PropertyDescriptor Value(\n      Name name,\n      Napi::Value value,\n      napi_property_attributes attributes = napi_default);\n\n  PropertyDescriptor(napi_property_descriptor desc);\n\n  operator napi_property_descriptor&();\n  operator const napi_property_descriptor&() const;\n\n private:\n  napi_property_descriptor _desc;\n};\n\n/// Property descriptor for use with `ObjectWrap::DefineClass()`.\n///\n/// This is different from the standalone `PropertyDescriptor` because it is\n/// specific to each `ObjectWrap<T>` subclass. This prevents using descriptors\n/// from a different class when defining a new class (preventing the callbacks\n/// from having incorrect `this` pointers).\ntemplate <typename T>\nclass ClassPropertyDescriptor {\n public:\n  ClassPropertyDescriptor(napi_property_descriptor desc) : _desc(desc) {}\n\n  operator napi_property_descriptor&() { return _desc; }\n  operator const napi_property_descriptor&() const { return _desc; }\n\n private:\n  napi_property_descriptor _desc;\n};\n\ntemplate <typename T, typename TCallback>\nstruct MethodCallbackData {\n  TCallback callback;\n  void* data;\n};\n\ntemplate <typename T, typename TGetterCallback, typename TSetterCallback>\nstruct AccessorCallbackData {\n  TGetterCallback getterCallback;\n  TSetterCallback setterCallback;\n  void* data;\n};\n\ntemplate <typename T>\nclass InstanceWrap {\n public:\n  using InstanceVoidMethodCallback = void (T::*)(const CallbackInfo& info);\n  using InstanceMethodCallback = Napi::Value (T::*)(const CallbackInfo& info);\n  using InstanceGetterCallback = Napi::Value (T::*)(const CallbackInfo& info);\n  using InstanceSetterCallback = void (T::*)(const CallbackInfo& info,\n                                             const Napi::Value& value);\n\n  using PropertyDescriptor = ClassPropertyDescriptor<T>;\n\n  static PropertyDescriptor InstanceMethod(\n      const char* utf8name,\n      InstanceVoidMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceMethod(\n      const char* utf8name,\n      InstanceMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceMethod(\n      Symbol name,\n      InstanceVoidMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceMethod(\n      Symbol name,\n      InstanceMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceVoidMethodCallback method>\n  static PropertyDescriptor InstanceMethod(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceMethodCallback method>\n  static PropertyDescriptor InstanceMethod(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceVoidMethodCallback method>\n  static PropertyDescriptor InstanceMethod(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceMethodCallback method>\n  static PropertyDescriptor InstanceMethod(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceAccessor(\n      const char* utf8name,\n      InstanceGetterCallback getter,\n      InstanceSetterCallback setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceAccessor(\n      Symbol name,\n      InstanceGetterCallback getter,\n      InstanceSetterCallback setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceGetterCallback getter,\n            InstanceSetterCallback setter = nullptr>\n  static PropertyDescriptor InstanceAccessor(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <InstanceGetterCallback getter,\n            InstanceSetterCallback setter = nullptr>\n  static PropertyDescriptor InstanceAccessor(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor InstanceValue(\n      const char* utf8name,\n      Napi::Value value,\n      napi_property_attributes attributes = napi_default);\n  static PropertyDescriptor InstanceValue(\n      Symbol name,\n      Napi::Value value,\n      napi_property_attributes attributes = napi_default);\n\n protected:\n  static void AttachPropData(napi_env env,\n                             napi_value value,\n                             const napi_property_descriptor* prop);\n\n private:\n  using This = InstanceWrap<T>;\n\n  using InstanceVoidMethodCallbackData =\n      MethodCallbackData<T, InstanceVoidMethodCallback>;\n  using InstanceMethodCallbackData =\n      MethodCallbackData<T, InstanceMethodCallback>;\n  using InstanceAccessorCallbackData =\n      AccessorCallbackData<T, InstanceGetterCallback, InstanceSetterCallback>;\n\n  static napi_value InstanceVoidMethodCallbackWrapper(napi_env env,\n                                                      napi_callback_info info);\n  static napi_value InstanceMethodCallbackWrapper(napi_env env,\n                                                  napi_callback_info info);\n  static napi_value InstanceGetterCallbackWrapper(napi_env env,\n                                                  napi_callback_info info);\n  static napi_value InstanceSetterCallbackWrapper(napi_env env,\n                                                  napi_callback_info info);\n\n  template <InstanceSetterCallback method>\n  static napi_value WrappedMethod(napi_env env,\n                                  napi_callback_info info) NAPI_NOEXCEPT;\n\n  template <InstanceSetterCallback setter>\n  struct SetterTag {};\n\n  template <InstanceSetterCallback setter>\n  static napi_callback WrapSetter(SetterTag<setter>) NAPI_NOEXCEPT {\n    return &This::WrappedMethod<setter>;\n  }\n  static napi_callback WrapSetter(SetterTag<nullptr>) NAPI_NOEXCEPT {\n    return nullptr;\n  }\n};\n\n/// Base class to be extended by C++ classes exposed to JavaScript; each C++\n/// class instance gets \"wrapped\" by a JavaScript object that is managed by this\n/// class.\n///\n/// At initialization time, the `DefineClass()` method must be used to\n/// hook up the accessor and method callbacks. It takes a list of\n/// property descriptors, which can be constructed via the various\n/// static methods on the base class.\n///\n/// #### Example:\n///\n///     class Example: public Napi::ObjectWrap<Example> {\n///       public:\n///         static void Initialize(Napi::Env& env, Napi::Object& target) {\n///           Napi::Function constructor = DefineClass(env, \"Example\", {\n///             InstanceAccessor<&Example::GetSomething,\n///             &Example::SetSomething>(\"value\"),\n///             InstanceMethod<&Example::DoSomething>(\"doSomething\"),\n///           });\n///           target.Set(\"Example\", constructor);\n///         }\n///\n///         Example(const Napi::CallbackInfo& info); // Constructor\n///         Napi::Value GetSomething(const Napi::CallbackInfo& info);\n///         void SetSomething(const Napi::CallbackInfo& info, const Napi::Value&\n///         value); Napi::Value DoSomething(const Napi::CallbackInfo& info);\n///     }\ntemplate <typename T>\nclass ObjectWrap : public InstanceWrap<T>, public Reference<Object> {\n public:\n  ObjectWrap(const CallbackInfo& callbackInfo);\n  virtual ~ObjectWrap();\n\n  static T* Unwrap(Object wrapper);\n\n  // Methods exposed to JavaScript must conform to one of these callback\n  // signatures.\n  using StaticVoidMethodCallback = void (*)(const CallbackInfo& info);\n  using StaticMethodCallback = Napi::Value (*)(const CallbackInfo& info);\n  using StaticGetterCallback = Napi::Value (*)(const CallbackInfo& info);\n  using StaticSetterCallback = void (*)(const CallbackInfo& info,\n                                        const Napi::Value& value);\n\n  using PropertyDescriptor = ClassPropertyDescriptor<T>;\n\n  static Function DefineClass(\n      Napi::Env env,\n      const char* utf8name,\n      const std::initializer_list<PropertyDescriptor>& properties,\n      void* data = nullptr);\n  static Function DefineClass(Napi::Env env,\n                              const char* utf8name,\n                              const std::vector<PropertyDescriptor>& properties,\n                              void* data = nullptr);\n  static PropertyDescriptor StaticMethod(\n      const char* utf8name,\n      StaticVoidMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticMethod(\n      const char* utf8name,\n      StaticMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticMethod(\n      Symbol name,\n      StaticVoidMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticMethod(\n      Symbol name,\n      StaticMethodCallback method,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticVoidMethodCallback method>\n  static PropertyDescriptor StaticMethod(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticVoidMethodCallback method>\n  static PropertyDescriptor StaticMethod(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticMethodCallback method>\n  static PropertyDescriptor StaticMethod(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticMethodCallback method>\n  static PropertyDescriptor StaticMethod(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticAccessor(\n      const char* utf8name,\n      StaticGetterCallback getter,\n      StaticSetterCallback setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticAccessor(\n      Symbol name,\n      StaticGetterCallback getter,\n      StaticSetterCallback setter,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticGetterCallback getter, StaticSetterCallback setter = nullptr>\n  static PropertyDescriptor StaticAccessor(\n      const char* utf8name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  template <StaticGetterCallback getter, StaticSetterCallback setter = nullptr>\n  static PropertyDescriptor StaticAccessor(\n      Symbol name,\n      napi_property_attributes attributes = napi_default,\n      void* data = nullptr);\n  static PropertyDescriptor StaticValue(\n      const char* utf8name,\n      Napi::Value value,\n      napi_property_attributes attributes = napi_default);\n  static PropertyDescriptor StaticValue(\n      Symbol name,\n      Napi::Value value,\n      napi_property_attributes attributes = napi_default);\n  static Napi::Value OnCalledAsFunction(const Napi::CallbackInfo& callbackInfo);\n  virtual void Finalize(Napi::Env env);\n  virtual void Finalize(BasicEnv env);\n\n private:\n  using This = ObjectWrap<T>;\n\n  static napi_value ConstructorCallbackWrapper(napi_env env,\n                                               napi_callback_info info);\n  static napi_value StaticVoidMethodCallbackWrapper(napi_env env,\n                                                    napi_callback_info info);\n  static napi_value StaticMethodCallbackWrapper(napi_env env,\n                                                napi_callback_info info);\n  static napi_value StaticGetterCallbackWrapper(napi_env env,\n                                                napi_callback_info info);\n  static napi_value StaticSetterCallbackWrapper(napi_env env,\n                                                napi_callback_info info);\n  static void FinalizeCallback(node_addon_api_basic_env env,\n                               void* data,\n                               void* hint);\n\n  static void PostFinalizeCallback(napi_env env, void* data, void* hint);\n\n  static Function DefineClass(Napi::Env env,\n                              const char* utf8name,\n                              const size_t props_count,\n                              const napi_property_descriptor* props,\n                              void* data = nullptr);\n\n  using StaticVoidMethodCallbackData =\n      MethodCallbackData<T, StaticVoidMethodCallback>;\n  using StaticMethodCallbackData = MethodCallbackData<T, StaticMethodCallback>;\n\n  using StaticAccessorCallbackData =\n      AccessorCallbackData<T, StaticGetterCallback, StaticSetterCallback>;\n\n  template <StaticSetterCallback method>\n  static napi_value WrappedMethod(napi_env env,\n                                  napi_callback_info info) NAPI_NOEXCEPT;\n\n  template <StaticSetterCallback setter>\n  struct StaticSetterTag {};\n\n  template <StaticSetterCallback setter>\n  static napi_callback WrapStaticSetter(StaticSetterTag<setter>) NAPI_NOEXCEPT {\n    return &This::WrappedMethod<setter>;\n  }\n  static napi_callback WrapStaticSetter(StaticSetterTag<nullptr>)\n      NAPI_NOEXCEPT {\n    return nullptr;\n  }\n\n  bool _construction_failed = true;\n  bool _finalized = false;\n};\n\nclass HandleScope {\n public:\n  HandleScope(napi_env env, napi_handle_scope scope);\n  explicit HandleScope(Napi::Env env);\n  ~HandleScope();\n\n  // Disallow copying to prevent double close of napi_handle_scope\n  NAPI_DISALLOW_ASSIGN_COPY(HandleScope)\n\n  operator napi_handle_scope() const;\n\n  Napi::Env Env() const;\n\n private:\n  napi_env _env;\n  napi_handle_scope _scope;\n};\n\nclass EscapableHandleScope {\n public:\n  EscapableHandleScope(napi_env env, napi_escapable_handle_scope scope);\n  explicit EscapableHandleScope(Napi::Env env);\n  ~EscapableHandleScope();\n\n  // Disallow copying to prevent double close of napi_escapable_handle_scope\n  NAPI_DISALLOW_ASSIGN_COPY(EscapableHandleScope)\n\n  operator napi_escapable_handle_scope() const;\n\n  Napi::Env Env() const;\n  Value Escape(napi_value escapee);\n\n private:\n  napi_env _env;\n  napi_escapable_handle_scope _scope;\n};\n\n#if (NAPI_VERSION > 2)\nclass CallbackScope {\n public:\n  CallbackScope(napi_env env, napi_callback_scope scope);\n  CallbackScope(napi_env env, napi_async_context context);\n  virtual ~CallbackScope();\n\n  // Disallow copying to prevent double close of napi_callback_scope\n  NAPI_DISALLOW_ASSIGN_COPY(CallbackScope)\n\n  operator napi_callback_scope() const;\n\n  Napi::Env Env() const;\n\n private:\n  napi_env _env;\n  napi_callback_scope _scope;\n};\n#endif\n\nclass AsyncContext {\n public:\n  explicit AsyncContext(napi_env env, const char* resource_name);\n  explicit AsyncContext(napi_env env,\n                        const char* resource_name,\n                        const Object& resource);\n  virtual ~AsyncContext();\n\n  AsyncContext(AsyncContext&& other);\n  AsyncContext& operator=(AsyncContext&& other);\n  NAPI_DISALLOW_ASSIGN_COPY(AsyncContext)\n\n  operator napi_async_context() const;\n\n  Napi::Env Env() const;\n\n private:\n  napi_env _env;\n  napi_async_context _context;\n};\n\n#if NAPI_HAS_THREADS\nclass AsyncWorker {\n public:\n  virtual ~AsyncWorker();\n\n  NAPI_DISALLOW_ASSIGN_COPY(AsyncWorker)\n\n  operator napi_async_work() const;\n\n  Napi::Env Env() const;\n\n  void Queue();\n  void Cancel();\n  void SuppressDestruct();\n\n  ObjectReference& Receiver();\n  FunctionReference& Callback();\n\n  virtual void OnExecute(Napi::Env env);\n  virtual void OnWorkComplete(Napi::Env env, napi_status status);\n\n protected:\n  explicit AsyncWorker(const Function& callback);\n  explicit AsyncWorker(const Function& callback, const char* resource_name);\n  explicit AsyncWorker(const Function& callback,\n                       const char* resource_name,\n                       const Object& resource);\n  explicit AsyncWorker(const Object& receiver, const Function& callback);\n  explicit AsyncWorker(const Object& receiver,\n                       const Function& callback,\n                       const char* resource_name);\n  explicit AsyncWorker(const Object& receiver,\n                       const Function& callback,\n                       const char* resource_name,\n                       const Object& resource);\n\n  explicit AsyncWorker(Napi::Env env);\n  explicit AsyncWorker(Napi::Env env, const char* resource_name);\n  explicit AsyncWorker(Napi::Env env,\n                       const char* resource_name,\n                       const Object& resource);\n\n  virtual void Execute() = 0;\n  virtual void OnOK();\n  virtual void OnError(const Error& e);\n  virtual void Destroy();\n  virtual std::vector<napi_value> GetResult(Napi::Env env);\n\n  void SetError(const std::string& error);\n\n private:\n  static inline void OnAsyncWorkExecute(napi_env env, void* asyncworker);\n  static inline void OnAsyncWorkComplete(napi_env env,\n                                         napi_status status,\n                                         void* asyncworker);\n\n  napi_env _env;\n  napi_async_work _work;\n  ObjectReference _receiver;\n  FunctionReference _callback;\n  std::string _error;\n  bool _suppress_destruct;\n};\n#endif  // NAPI_HAS_THREADS\n\n#if (NAPI_VERSION > 3 && NAPI_HAS_THREADS)\nclass ThreadSafeFunction {\n public:\n  // This API may only be called from the main thread.\n  template <typename ResourceString>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename ContextType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename Finalizer>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                Finalizer finalizeCallback);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                Finalizer finalizeCallback,\n                                FinalizerDataType* data);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename ContextType, typename Finalizer>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context,\n                                Finalizer finalizeCallback);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString,\n            typename ContextType,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context,\n                                Finalizer finalizeCallback,\n                                FinalizerDataType* data);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename ContextType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename Finalizer>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                Finalizer finalizeCallback);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                Finalizer finalizeCallback,\n                                FinalizerDataType* data);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString, typename ContextType, typename Finalizer>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context,\n                                Finalizer finalizeCallback);\n\n  // This API may only be called from the main thread.\n  template <typename ResourceString,\n            typename ContextType,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context,\n                                Finalizer finalizeCallback,\n                                FinalizerDataType* data);\n\n  ThreadSafeFunction();\n  ThreadSafeFunction(napi_threadsafe_function tsFunctionValue);\n\n  operator napi_threadsafe_function() const;\n\n  // This API may be called from any thread.\n  napi_status BlockingCall() const;\n\n  // This API may be called from any thread.\n  template <typename Callback>\n  napi_status BlockingCall(Callback callback) const;\n\n  // This API may be called from any thread.\n  template <typename DataType, typename Callback>\n  napi_status BlockingCall(DataType* data, Callback callback) const;\n\n  // This API may be called from any thread.\n  napi_status NonBlockingCall() const;\n\n  // This API may be called from any thread.\n  template <typename Callback>\n  napi_status NonBlockingCall(Callback callback) const;\n\n  // This API may be called from any thread.\n  template <typename DataType, typename Callback>\n  napi_status NonBlockingCall(DataType* data, Callback callback) const;\n\n  // This API may only be called from the main thread.\n  void Ref(napi_env env) const;\n\n  // This API may only be called from the main thread.\n  void Unref(napi_env env) const;\n\n  // This API may be called from any thread.\n  napi_status Acquire() const;\n\n  // This API may be called from any thread.\n  napi_status Release() const;\n\n  // This API may be called from any thread.\n  napi_status Abort() const;\n\n  struct ConvertibleContext {\n    template <class T>\n    operator T*() {\n      return static_cast<T*>(context);\n    }\n    void* context;\n  };\n\n  // This API may be called from any thread.\n  ConvertibleContext GetContext() const;\n\n private:\n  using CallbackWrapper = std::function<void(Napi::Env, Napi::Function)>;\n\n  template <typename ResourceString,\n            typename ContextType,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static ThreadSafeFunction New(napi_env env,\n                                const Function& callback,\n                                const Object& resource,\n                                ResourceString resourceName,\n                                size_t maxQueueSize,\n                                size_t initialThreadCount,\n                                ContextType* context,\n                                Finalizer finalizeCallback,\n                                FinalizerDataType* data,\n                                napi_finalize wrapper);\n\n  napi_status CallInternal(CallbackWrapper* callbackWrapper,\n                           napi_threadsafe_function_call_mode mode) const;\n\n  static void CallJS(napi_env env,\n                     napi_value jsCallback,\n                     void* context,\n                     void* data);\n\n  napi_threadsafe_function _tsfn;\n};\n\n// A TypedThreadSafeFunction by default has no context (nullptr) and can\n// accept any type (void) to its CallJs.\ntemplate <typename ContextType = std::nullptr_t,\n          typename DataType = void,\n          void (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*) =\n              nullptr>\nclass TypedThreadSafeFunction {\n public:\n  // This API may only be called from the main thread.\n  // Helper function that returns nullptr if running Node-API 5+, otherwise a\n  // non-empty, no-op Function. This provides the ability to specify at\n  // compile-time a callback parameter to `New` that safely does no action\n  // when targeting _any_ Node-API version.\n#if NAPI_VERSION > 4\n  static std::nullptr_t EmptyFunctionFactory(Napi::Env env);\n#else\n  static Napi::Function EmptyFunctionFactory(Napi::Env env);\n#endif\n  static Napi::Function FunctionOrEmpty(Napi::Env env,\n                                        Napi::Function& callback);\n\n#if NAPI_VERSION > 4\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [missing] Resource [missing] Finalizer [missing]\n  template <typename ResourceString>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [missing] Resource [passed] Finalizer [missing]\n  template <typename ResourceString>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Object& resource,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [missing] Resource [missing] Finalizer [passed]\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType = void>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context,\n      Finalizer finalizeCallback,\n      FinalizerDataType* data = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [missing] Resource [passed] Finalizer [passed]\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType = void>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Object& resource,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context,\n      Finalizer finalizeCallback,\n      FinalizerDataType* data = nullptr);\n#endif\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [passed] Resource [missing] Finalizer [missing]\n  template <typename ResourceString>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Function& callback,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [passed] Resource [passed] Finalizer [missing]\n  template <typename ResourceString>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Function& callback,\n      const Object& resource,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [passed] Resource [missing] Finalizer [passed]\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType = void>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Function& callback,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context,\n      Finalizer finalizeCallback,\n      FinalizerDataType* data = nullptr);\n\n  // This API may only be called from the main thread.\n  // Creates a new threadsafe function with:\n  //   Callback [passed] Resource [passed] Finalizer [passed]\n  template <typename CallbackType,\n            typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      CallbackType callback,\n      const Object& resource,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context,\n      Finalizer finalizeCallback,\n      FinalizerDataType* data = nullptr);\n\n  TypedThreadSafeFunction();\n  TypedThreadSafeFunction(napi_threadsafe_function tsFunctionValue);\n\n  operator napi_threadsafe_function() const;\n\n  // This API may be called from any thread.\n  napi_status BlockingCall(DataType* data = nullptr) const;\n\n  // This API may be called from any thread.\n  napi_status NonBlockingCall(DataType* data = nullptr) const;\n\n  // This API may only be called from the main thread.\n  void Ref(napi_env env) const;\n\n  // This API may only be called from the main thread.\n  void Unref(napi_env env) const;\n\n  // This API may be called from any thread.\n  napi_status Acquire() const;\n\n  // This API may be called from any thread.\n  napi_status Release() const;\n\n  // This API may be called from any thread.\n  napi_status Abort() const;\n\n  // This API may be called from any thread.\n  ContextType* GetContext() const;\n\n private:\n  template <typename ResourceString,\n            typename Finalizer,\n            typename FinalizerDataType>\n  static TypedThreadSafeFunction<ContextType, DataType, CallJs> New(\n      napi_env env,\n      const Function& callback,\n      const Object& resource,\n      ResourceString resourceName,\n      size_t maxQueueSize,\n      size_t initialThreadCount,\n      ContextType* context,\n      Finalizer finalizeCallback,\n      FinalizerDataType* data,\n      napi_finalize wrapper);\n\n  static void CallJsInternal(napi_env env,\n                             napi_value jsCallback,\n                             void* context,\n                             void* data);\n\n protected:\n  napi_threadsafe_function _tsfn;\n};\ntemplate <typename DataType>\nclass AsyncProgressWorkerBase : public AsyncWorker {\n public:\n  virtual void OnWorkProgress(DataType* data) = 0;\n  class ThreadSafeData {\n   public:\n    ThreadSafeData(AsyncProgressWorkerBase* asyncprogressworker, DataType* data)\n        : _asyncprogressworker(asyncprogressworker), _data(data) {}\n\n    AsyncProgressWorkerBase* asyncprogressworker() {\n      return _asyncprogressworker;\n    };\n    DataType* data() { return _data; };\n\n   private:\n    AsyncProgressWorkerBase* _asyncprogressworker;\n    DataType* _data;\n  };\n  void OnWorkComplete(Napi::Env env, napi_status status) override;\n\n protected:\n  explicit AsyncProgressWorkerBase(const Object& receiver,\n                                   const Function& callback,\n                                   const char* resource_name,\n                                   const Object& resource,\n                                   size_t queue_size = 1);\n  virtual ~AsyncProgressWorkerBase();\n\n// Optional callback of Napi::ThreadSafeFunction only available after\n// NAPI_VERSION 4. Refs: https://github.com/nodejs/node/pull/27791\n#if NAPI_VERSION > 4\n  explicit AsyncProgressWorkerBase(Napi::Env env,\n                                   const char* resource_name,\n                                   const Object& resource,\n                                   size_t queue_size = 1);\n#endif\n\n  static inline void OnAsyncWorkProgress(Napi::Env env,\n                                         Napi::Function jsCallback,\n                                         void* data);\n\n  napi_status NonBlockingCall(DataType* data);\n\n private:\n  ThreadSafeFunction _tsfn;\n  bool _work_completed = false;\n  napi_status _complete_status;\n  static inline void OnThreadSafeFunctionFinalize(\n      Napi::Env env, void* data, AsyncProgressWorkerBase* context);\n};\n\ntemplate <class T>\nclass AsyncProgressWorker : public AsyncProgressWorkerBase<void> {\n public:\n  virtual ~AsyncProgressWorker();\n\n  class ExecutionProgress {\n    friend class AsyncProgressWorker;\n\n   public:\n    void Signal() const;\n    void Send(const T* data, size_t count) const;\n\n   private:\n    explicit ExecutionProgress(AsyncProgressWorker* worker) : _worker(worker) {}\n    AsyncProgressWorker* const _worker;\n  };\n\n  void OnWorkProgress(void*) override;\n\n protected:\n  explicit AsyncProgressWorker(const Function& callback);\n  explicit AsyncProgressWorker(const Function& callback,\n                               const char* resource_name);\n  explicit AsyncProgressWorker(const Function& callback,\n                               const char* resource_name,\n                               const Object& resource);\n  explicit AsyncProgressWorker(const Object& receiver,\n                               const Function& callback);\n  explicit AsyncProgressWorker(const Object& receiver,\n                               const Function& callback,\n                               const char* resource_name);\n  explicit AsyncProgressWorker(const Object& receiver,\n                               const Function& callback,\n                               const char* resource_name,\n                               const Object& resource);\n\n// Optional callback of Napi::ThreadSafeFunction only available after\n// NAPI_VERSION 4. Refs: https://github.com/nodejs/node/pull/27791\n#if NAPI_VERSION > 4\n  explicit AsyncProgressWorker(Napi::Env env);\n  explicit AsyncProgressWorker(Napi::Env env, const char* resource_name);\n  explicit AsyncProgressWorker(Napi::Env env,\n                               const char* resource_name,\n                               const Object& resource);\n#endif\n  virtual void Execute(const ExecutionProgress& progress) = 0;\n  virtual void OnProgress(const T* data, size_t count) = 0;\n\n private:\n  void Execute() override;\n  void Signal();\n  void SendProgress_(const T* data, size_t count);\n\n  std::mutex _mutex;\n  T* _asyncdata;\n  size_t _asyncsize;\n  bool _signaled;\n};\n\ntemplate <class T>\nclass AsyncProgressQueueWorker\n    : public AsyncProgressWorkerBase<std::pair<T*, size_t>> {\n public:\n  virtual ~AsyncProgressQueueWorker(){};\n\n  class ExecutionProgress {\n    friend class AsyncProgressQueueWorker;\n\n   public:\n    void Signal() const;\n    void Send(const T* data, size_t count) const;\n\n   private:\n    explicit ExecutionProgress(AsyncProgressQueueWorker* worker)\n        : _worker(worker) {}\n    AsyncProgressQueueWorker* const _worker;\n  };\n\n  void OnWorkComplete(Napi::Env env, napi_status status) override;\n  void OnWorkProgress(std::pair<T*, size_t>*) override;\n\n protected:\n  explicit AsyncProgressQueueWorker(const Function& callback);\n  explicit AsyncProgressQueueWorker(const Function& callback,\n                                    const char* resource_name);\n  explicit AsyncProgressQueueWorker(const Function& callback,\n                                    const char* resource_name,\n                                    const Object& resource);\n  explicit AsyncProgressQueueWorker(const Object& receiver,\n                                    const Function& callback);\n  explicit AsyncProgressQueueWorker(const Object& receiver,\n                                    const Function& callback,\n                                    const char* resource_name);\n  explicit AsyncProgressQueueWorker(const Object& receiver,\n                                    const Function& callback,\n                                    const char* resource_name,\n                                    const Object& resource);\n\n// Optional callback of Napi::ThreadSafeFunction only available after\n// NAPI_VERSION 4. Refs: https://github.com/nodejs/node/pull/27791\n#if NAPI_VERSION > 4\n  explicit AsyncProgressQueueWorker(Napi::Env env);\n  explicit AsyncProgressQueueWorker(Napi::Env env, const char* resource_name);\n  explicit AsyncProgressQueueWorker(Napi::Env env,\n                                    const char* resource_name,\n                                    const Object& resource);\n#endif\n  virtual void Execute(const ExecutionProgress& progress) = 0;\n  virtual void OnProgress(const T* data, size_t count) = 0;\n\n private:\n  void Execute() override;\n  void Signal() const;\n  void SendProgress_(const T* data, size_t count);\n};\n#endif  // NAPI_VERSION > 3 && NAPI_HAS_THREADS\n\n// Memory management.\nclass MemoryManagement {\n public:\n  static int64_t AdjustExternalMemory(BasicEnv env, int64_t change_in_bytes);\n};\n\n// Version management\nclass VersionManagement {\n public:\n  static uint32_t GetNapiVersion(BasicEnv env);\n  static const napi_node_version* GetNodeVersion(BasicEnv env);\n};\n\n#if NAPI_VERSION > 5\ntemplate <typename T>\nclass Addon : public InstanceWrap<T> {\n public:\n  static inline Object Init(Env env, Object exports);\n  static T* Unwrap(Object wrapper);\n\n protected:\n  using AddonProp = ClassPropertyDescriptor<T>;\n  void DefineAddon(Object exports,\n                   const std::initializer_list<AddonProp>& props);\n  Napi::Object DefineProperties(Object object,\n                                const std::initializer_list<AddonProp>& props);\n\n private:\n  Object entry_point_;\n};\n#endif  // NAPI_VERSION > 5\n\n#ifdef NAPI_CPP_CUSTOM_NAMESPACE\n}  // namespace NAPI_CPP_CUSTOM_NAMESPACE\n#endif\n\n}  // namespace Napi\n\n// Inline implementations of all the above class methods are included here.\n#include \"napi-inl.h\"\n\n#endif  // SRC_NAPI_H_\n"
        },
        {
          "name": "node_addon_api.gyp",
          "type": "blob",
          "size": 1.0712890625,
          "content": "{\n  'targets': [\n    {\n      'target_name': 'node_addon_api',\n      'type': 'none',\n      'sources': [ 'napi.h', 'napi-inl.h' ],\n      'direct_dependent_settings': {\n        'include_dirs': [ '.' ],\n        'includes': ['noexcept.gypi'],\n      }\n    },\n    {\n      'target_name': 'node_addon_api_except',\n      'type': 'none',\n      'sources': [ 'napi.h', 'napi-inl.h' ],\n      'direct_dependent_settings': {\n        'include_dirs': [ '.' ],\n        'includes': ['except.gypi'],\n      }\n    },\n    {\n      'target_name': 'node_addon_api_except_all',\n      'type': 'none',\n      'sources': [ 'napi.h', 'napi-inl.h' ],\n      'direct_dependent_settings': {\n        'include_dirs': [ '.' ],\n        'includes': ['except.gypi'],\n        'defines': [ 'NODE_ADDON_API_CPP_EXCEPTIONS_ALL' ]\n      }\n    },\n    {\n      'target_name': 'node_addon_api_maybe',\n      'type': 'none',\n      'sources': [ 'napi.h', 'napi-inl.h' ],\n      'direct_dependent_settings': {\n        'include_dirs': [ '.' ],\n        'includes': ['noexcept.gypi'],\n        'defines': ['NODE_ADDON_API_ENABLE_MAYBE']\n      }\n    },\n  ]\n}\n"
        },
        {
          "name": "node_api.gyp",
          "type": "blob",
          "size": 0.12890625,
          "content": "{\n  'targets': [\n    {\n      'target_name': 'nothing',\n      'type': 'static_library',\n      'sources': [ 'nothing.c' ]\n    }\n  ]\n}\n"
        },
        {
          "name": "noexcept.gypi",
          "type": "blob",
          "size": 0.6337890625,
          "content": "{\n  'defines': [ 'NODE_ADDON_API_DISABLE_CPP_EXCEPTIONS' ],\n  'cflags': [ '-fno-exceptions' ],\n  'cflags_cc': [ '-fno-exceptions' ],\n  'conditions': [\n    [\"OS=='win'\", {\n      # _HAS_EXCEPTIONS is already defined and set to 0 in common.gypi\n      #\"defines\": [\n      #  \"_HAS_EXCEPTIONS=0\"\n      #],\n      \"msvs_settings\": {\n        \"VCCLCompilerTool\": {\n          'ExceptionHandling': 0,\n          'EnablePREfast': 'true',\n        },\n      },\n    }],\n    [\"OS=='mac'\", {\n      'xcode_settings': {\n        'CLANG_CXX_LIBRARY': 'libc++',\n        'MACOSX_DEPLOYMENT_TARGET': '10.7',\n        'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',\n      },\n    }],\n  ],\n}\n"
        },
        {
          "name": "nothing.c",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "package-support.json",
          "type": "blob",
          "size": 0.4560546875,
          "content": "{\n  \"versions\": [\n    {\n      \"version\": \"*\",\n      \"target\": {\n        \"node\": \"active\"\n      },\n      \"response\": {\n        \"type\": \"time-permitting\",\n        \"paid\": false,\n        \"contact\": {\n          \"name\": \"node-addon-api team\",\n          \"url\": \"https://github.com/nodejs/node-addon-api/issues\"\n        }\n      },\n      \"backing\": [ { \"project\": \"https://github.com/nodejs\" },\n                   { \"foundation\": \"https://openjsf.org/\" }\n      ]\n    }\n  ]\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 10.7470703125,
          "content": "{\n  \"bugs\": {\n    \"url\": \"https://github.com/nodejs/node-addon-api/issues\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Abhishek Kumar Singh\",\n      \"url\": \"https://github.com/abhi11210646\"\n    },\n    {\n      \"name\": \"Alba Mendez\",\n      \"url\": \"https://github.com/jmendeth\"\n    },\n    {\n      \"name\": \"Alexander Floh\",\n      \"url\": \"https://github.com/alexanderfloh\"\n    },\n    {\n      \"name\": \"Ammar Faizi\",\n      \"url\": \"https://github.com/ammarfaizi2\"\n    },\n    {\n      \"name\": \"András Timár, Dr\",\n      \"url\": \"https://github.com/timarandras\"\n    },\n    {\n      \"name\": \"Andrew Petersen\",\n      \"url\": \"https://github.com/kirbysayshi\"\n    },\n    {\n      \"name\": \"Anisha Rohra\",\n      \"url\": \"https://github.com/anisha-rohra\"\n    },\n    {\n      \"name\": \"Anna Henningsen\",\n      \"url\": \"https://github.com/addaleax\"\n    },\n    {\n      \"name\": \"Arnaud Botella\",\n      \"url\": \"https://github.com/BotellaA\"\n    },\n    {\n      \"name\": \"Arunesh Chandra\",\n      \"url\": \"https://github.com/aruneshchandra\"\n    },\n    {\n      \"name\": \"Azlan Mukhtar\",\n      \"url\": \"https://github.com/azlan\"\n    },\n    {\n      \"name\": \"Ben Berman\",\n      \"url\": \"https://github.com/rivertam\"\n    },\n    {\n      \"name\": \"Benjamin Byholm\",\n      \"url\": \"https://github.com/kkoopa\"\n    },\n    {\n      \"name\": \"Bill Gallafent\",\n      \"url\": \"https://github.com/gallafent\"\n    },\n    {\n      \"name\": \"blagoev\",\n      \"url\": \"https://github.com/blagoev\"\n    },\n    {\n      \"name\": \"Bruce A. MacNaughton\",\n      \"url\": \"https://github.com/bmacnaughton\"\n    },\n    {\n      \"name\": \"Cory Mickelson\",\n      \"url\": \"https://github.com/corymickelson\"\n    },\n    {\n      \"name\": \"Daniel Bevenius\",\n      \"url\": \"https://github.com/danbev\"\n    },\n    {\n      \"name\": \"Dante Calderón\",\n      \"url\": \"https://github.com/dantehemerson\"\n    },\n    {\n      \"name\": \"Darshan Sen\",\n      \"url\": \"https://github.com/RaisinTen\"\n    },\n    {\n      \"name\": \"David Halls\",\n      \"url\": \"https://github.com/davedoesdev\"\n    },\n    {\n      \"name\": \"Deepak Rajamohan\",\n      \"url\": \"https://github.com/deepakrkris\"\n    },\n    {\n      \"name\": \"Dmitry Ashkadov\",\n      \"url\": \"https://github.com/dmitryash\"\n    },\n    {\n      \"name\": \"Dongjin Na\",\n      \"url\": \"https://github.com/nadongguri\"\n    },\n    {\n      \"name\": \"Doni Rubiagatra\",\n      \"url\": \"https://github.com/rubiagatra\"\n    },\n    {\n      \"name\": \"Eric Bickle\",\n      \"url\": \"https://github.com/ebickle\"\n    },\n    {\n      \"name\": \"extremeheat\",\n      \"url\": \"https://github.com/extremeheat\"\n    },\n    {\n      \"name\": \"Feng Yu\",\n      \"url\": \"https://github.com/F3n67u\"\n    },\n    {\n      \"name\": \"Ferdinand Holzer\",\n      \"url\": \"https://github.com/fholzer\"\n    },\n    {\n      \"name\": \"Gabriel Schulhof\",\n      \"url\": \"https://github.com/gabrielschulhof\"\n    },\n    {\n      \"name\": \"Guenter Sandner\",\n      \"url\": \"https://github.com/gms1\"\n    },\n    {\n      \"name\": \"Gus Caplan\",\n      \"url\": \"https://github.com/devsnek\"\n    },\n    {\n      \"name\": \"Helio Frota\",\n      \"url\": \"https://github.com/helio-frota\"\n    },\n    {\n      \"name\": \"Hitesh Kanwathirtha\",\n      \"url\": \"https://github.com/digitalinfinity\"\n    },\n    {\n      \"name\": \"ikokostya\",\n      \"url\": \"https://github.com/ikokostya\"\n    },\n    {\n      \"name\": \"Jack Xia\",\n      \"url\": \"https://github.com/JckXia\"\n    },\n    {\n      \"name\": \"Jake Barnes\",\n      \"url\": \"https://github.com/DuBistKomisch\"\n    },\n    {\n      \"name\": \"Jake Yoon\",\n      \"url\": \"https://github.com/yjaeseok\"\n    },\n    {\n      \"name\": \"Jason Ginchereau\",\n      \"url\": \"https://github.com/jasongin\"\n    },\n    {\n      \"name\": \"Jenny\",\n      \"url\": \"https://github.com/egg-bread\"\n    },\n    {\n      \"name\": \"Jeroen Janssen\",\n      \"url\": \"https://github.com/japj\"\n    },\n    {\n      \"name\": \"Jim Schlight\",\n      \"url\": \"https://github.com/jschlight\"\n    },\n    {\n      \"name\": \"Jinho Bang\",\n      \"url\": \"https://github.com/romandev\"\n    },\n    {\n      \"name\": \"José Expósito\",\n      \"url\": \"https://github.com/JoseExposito\"\n    },\n    {\n      \"name\": \"joshgarde\",\n      \"url\": \"https://github.com/joshgarde\"\n    },\n    {\n      \"name\": \"Julian Mesa\",\n      \"url\": \"https://github.com/julianmesa-gitkraken\"\n    },\n    {\n      \"name\": \"Kasumi Hanazuki\",\n      \"url\": \"https://github.com/hanazuki\"\n    },\n    {\n      \"name\": \"Kelvin\",\n      \"url\": \"https://github.com/kelvinhammond\"\n    },\n    {\n      \"name\": \"Kevin Eady\",\n      \"url\": \"https://github.com/KevinEady\"\n    },\n    {\n      \"name\": \"Kévin VOYER\",\n      \"url\": \"https://github.com/kecsou\"\n    },\n    {\n      \"name\": \"kidneysolo\",\n      \"url\": \"https://github.com/kidneysolo\"\n    },\n    {\n      \"name\": \"Koki Nishihara\",\n      \"url\": \"https://github.com/Nishikoh\"\n    },\n    {\n      \"name\": \"Konstantin Tarkus\",\n      \"url\": \"https://github.com/koistya\"\n    },\n    {\n      \"name\": \"Kyle Farnung\",\n      \"url\": \"https://github.com/kfarnung\"\n    },\n    {\n      \"name\": \"Kyle Kovacs\",\n      \"url\": \"https://github.com/nullromo\"\n    },\n    {\n      \"name\": \"legendecas\",\n      \"url\": \"https://github.com/legendecas\"\n    },\n    {\n      \"name\": \"LongYinan\",\n      \"url\": \"https://github.com/Brooooooklyn\"\n    },\n    {\n      \"name\": \"Lovell Fuller\",\n      \"url\": \"https://github.com/lovell\"\n    },\n    {\n      \"name\": \"Luciano Martorella\",\n      \"url\": \"https://github.com/lmartorella\"\n    },\n    {\n      \"name\": \"mastergberry\",\n      \"url\": \"https://github.com/mastergberry\"\n    },\n    {\n      \"name\": \"Mathias Küsel\",\n      \"url\": \"https://github.com/mathiask88\"\n    },\n    {\n      \"name\": \"Mathias Stearn\",\n      \"url\": \"https://github.com/RedBeard0531\"\n    },\n    {\n      \"name\": \"Matteo Collina\",\n      \"url\": \"https://github.com/mcollina\"\n    },\n    {\n      \"name\": \"Michael Dawson\",\n      \"url\": \"https://github.com/mhdawson\"\n    },\n    {\n      \"name\": \"Michael Price\",\n      \"url\": \"https://github.com/mikepricedev\"\n    },\n    {\n      \"name\": \"Michele Campus\",\n      \"url\": \"https://github.com/kYroL01\"\n    },\n    {\n      \"name\": \"Mikhail Cheshkov\",\n      \"url\": \"https://github.com/mcheshkov\"\n    },\n    {\n      \"name\": \"nempoBu4\",\n      \"url\": \"https://github.com/nempoBu4\"\n    },\n    {\n      \"name\": \"Nicola Del Gobbo\",\n      \"url\": \"https://github.com/NickNaso\"\n    },\n    {\n      \"name\": \"Nick Soggin\",\n      \"url\": \"https://github.com/iSkore\"\n    },\n    {\n      \"name\": \"Nikolai Vavilov\",\n      \"url\": \"https://github.com/seishun\"\n    },\n    {\n      \"name\": \"Nurbol Alpysbayev\",\n      \"url\": \"https://github.com/anurbol\"\n    },\n    {\n      \"name\": \"pacop\",\n      \"url\": \"https://github.com/pacop\"\n    },\n    {\n      \"name\": \"Peter Šándor\",\n      \"url\": \"https://github.com/petersandor\"\n    },\n    {\n      \"name\": \"Philipp Renoth\",\n      \"url\": \"https://github.com/DaAitch\"\n    },\n    {\n      \"name\": \"rgerd\",\n      \"url\": \"https://github.com/rgerd\"\n    },\n    {\n      \"name\": \"Richard Lau\",\n      \"url\": \"https://github.com/richardlau\"\n    },\n    {\n      \"name\": \"Rolf Timmermans\",\n      \"url\": \"https://github.com/rolftimmermans\"\n    },\n    {\n      \"name\": \"Ross Weir\",\n      \"url\": \"https://github.com/ross-weir\"\n    },\n    {\n      \"name\": \"Ryuichi Okumura\",\n      \"url\": \"https://github.com/okuryu\"\n    },\n    {\n      \"name\": \"Saint Gabriel\",\n      \"url\": \"https://github.com/chineduG\"\n    },\n    {\n      \"name\": \"Sampson Gao\",\n      \"url\": \"https://github.com/sampsongao\"\n    },\n    {\n      \"name\": \"Sam Roberts\",\n      \"url\": \"https://github.com/sam-github\"\n    },\n    {\n      \"name\": \"strager\",\n      \"url\": \"https://github.com/strager\"\n    },\n    {\n      \"name\": \"Taylor Woll\",\n      \"url\": \"https://github.com/boingoing\"\n    },\n    {\n      \"name\": \"Thomas Gentilhomme\",\n      \"url\": \"https://github.com/fraxken\"\n    },\n    {\n      \"name\": \"Tim Rach\",\n      \"url\": \"https://github.com/timrach\"\n    },\n    {\n      \"name\": \"Tobias Nießen\",\n      \"url\": \"https://github.com/tniessen\"\n    },\n    {\n      \"name\": \"todoroff\",\n      \"url\": \"https://github.com/todoroff\"\n    },\n    {\n      \"name\": \"Toyo Li\",\n      \"url\": \"https://github.com/toyobayashi\"\n    },\n    {\n      \"name\": \"Tux3\",\n      \"url\": \"https://github.com/tux3\"\n    },\n    {\n      \"name\": \"Vlad Velmisov\",\n      \"url\": \"https://github.com/Velmisov\"\n    },\n    {\n      \"name\": \"Vladimir Morozov\",\n      \"url\": \"https://github.com/vmoroz\"\n    },\n    {\n      \"name\": \"WenheLI\",\n      \"url\": \"https://github.com/WenheLI\"\n    },\n    {\n      \"name\": \"Xuguang Mei\",\n      \"url\": \"https://github.com/meixg\"\n    },\n    {\n      \"name\": \"Yohei Kishimoto\",\n      \"url\": \"https://github.com/morokosi\"\n    },\n    {\n      \"name\": \"Yulong Wang\",\n      \"url\": \"https://github.com/fs-eire\"\n    },\n    {\n      \"name\": \"Ziqiu Zhao\",\n      \"url\": \"https://github.com/ZzqiZQute\"\n    },\n    {\n      \"name\": \"Feng Yu\",\n      \"url\": \"https://github.com/F3n67u\"\n    },\n    {\n      \"name\": \"wanlu wang\",\n      \"url\": \"https://github.com/wanlu\"\n    },\n    {\n      \"name\": \"Caleb Hearon\",\n      \"url\": \"https://github.com/chearon\"\n    },\n    {\n      \"name\": \"Marx\",\n      \"url\": \"https://github.com/MarxJiao\"\n    },\n    {\n      \"name\": \"Ömer AKGÜL\",\n      \"url\": \"https://github.com/tuhalf\"\n    }\n  ],\n  \"description\": \"Node.js API (Node-API)\",\n  \"devDependencies\": {\n    \"benchmark\": \"^2.1.4\",\n    \"bindings\": \"^1.5.0\",\n    \"clang-format\": \"^1.4.0\",\n    \"eslint\": \"^9.13.0\",\n    \"fs-extra\": \"^11.1.1\",\n    \"neostandard\": \"^0.12.0\",\n    \"pre-commit\": \"^1.2.2\",\n    \"semver\": \"^7.6.0\"\n  },\n  \"directories\": {},\n  \"gypfile\": false,\n  \"homepage\": \"https://github.com/nodejs/node-addon-api\",\n  \"keywords\": [\n    \"n-api\",\n    \"napi\",\n    \"addon\",\n    \"native\",\n    \"bindings\",\n    \"c\",\n    \"c++\",\n    \"nan\",\n    \"node-addon-api\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"name\": \"node-addon-api\",\n  \"readme\": \"README.md\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/nodejs/node-addon-api.git\"\n  },\n  \"files\": [\n    \"*.{c,h,gyp,gypi}\",\n    \"package-support.json\",\n    \"tools/\"\n  ],\n  \"scripts\": {\n    \"prebenchmark\": \"node-gyp rebuild -C benchmark\",\n    \"benchmark\": \"node benchmark\",\n    \"create-coverage\": \"npm test --coverage\",\n    \"report-coverage-html\": \"rm -rf coverage-html && mkdir coverage-html && gcovr -e test --merge-mode-functions merge-use-line-max --html-nested ./coverage-html/index.html test\",\n    \"report-coverage-xml\": \"rm -rf coverage-xml && mkdir coverage-xml && gcovr -e test --merge-mode-functions merge-use-line-max --xml -o ./coverage-xml/coverage-cxx.xml test\",\n    \"pretest\": \"node-gyp rebuild -C test\",\n    \"test\": \"node test\",\n    \"test:debug\": \"node-gyp rebuild -C test --debug && NODE_API_BUILD_CONFIG=Debug node ./test/index.js\",\n    \"predev\": \"node-gyp rebuild -C test --debug\",\n    \"dev\": \"node test\",\n    \"predev:incremental\": \"node-gyp configure build -C test --debug\",\n    \"dev:incremental\": \"node test\",\n    \"doc\": \"doxygen doc/Doxyfile\",\n    \"lint\": \"eslint && node tools/clang-format\",\n    \"lint:fix\": \"eslint --fix && node tools/clang-format --fix\"\n  },\n  \"pre-commit\": \"lint\",\n  \"version\": \"8.3.0\",\n  \"support\": true,\n  \"engines\": {\n    \"node\": \"^18 || ^20 || >= 21\"\n  }\n}\n"
        },
        {
          "name": "release-please-config.json",
          "type": "blob",
          "size": 0.4150390625,
          "content": "{\n  \"$schema\": \"https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json\",\n  \"release-type\": \"node\",\n  \"pull-request-title-pattern\": \"chore: release v${version}\",\n  \"bootstrap-sha\": \"bc5acef9dd5298cbbcabd5c01c9590ada683951d\",\n  \"packages\": {\n    \".\": {\n      \"include-component-in-tag\": false,\n      \"extra-files\": [\n        \"README.md\"\n      ],\n      \"changelog-path\": \"CHANGELOG.md\"\n    }\n  }\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "unit-test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}