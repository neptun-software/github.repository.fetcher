{
  "metadata": {
    "timestamp": 1736565431734,
    "page": 278,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tinyobjloader/tinyobjloader",
      "stars": 3386,
      "defaultBranch": "release",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 0.9169921875,
          "content": "build_and_store_wheels: &BUILD_AND_STORE_WHEELS\n  install_cibuildwheel_script:\n    - python -m pip install cibuildwheel==2.16.2\n  run_cibuildwheel_script:\n    - cibuildwheel\n  wheels_artifacts:\n    path: \"wheelhouse/*\"\n\n  # Upload only for tagged commit\n  only_if: $CIRRUS_TAG != ''\n  publish_script:\n    - python -m pip install twine\n    - python -m twine upload --repository-url https://upload.pypi.org/legacy/ --username __token__ wheelhouse/*.whl\n\n\nlinux_aarch64_task:\n  name: Build Linux aarch64 wheels.\n  compute_engine_instance:\n    image_project: cirrus-images\n    image: family/docker-builder-arm64\n    architecture: arm64\n    platform: linux\n    cpu: 4\n    memory: 4G\n  environment:\n    TWINE_PASSWORD: ENCRYPTED[ade2037764e68fea251152f7585f3f77cdd748af06dc0f06942c45a8a8770fff19032c985f8dc193229c8adb2c0fecb9]\n\n  install_pre_requirements_script:\n    - apt install -y python3-venv python-is-python3\n  <<: *BUILD_AND_STORE_WHEELS\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.10546875,
          "content": "---\nBasedOnStyle: Google\nIndentWidth: 2\nTabWidth: 2\nUseTab: Never\nBreakBeforeBraces: Attach\nStandard: Cpp03\n"
        },
        {
          "name": ".drone.yml",
          "type": "blob",
          "size": 0.2490234375,
          "content": "image: syoyo/ubu-dev\nscript:\n  - curl -L -o premake4 https://github.com/syoyo/orebuildenv/blob/master/build/linux/bin/premake4?raw=true\n  - chmod +x ./premake4\n  - ./premake4 gmake\n  - make\nnotify:\n email:\n    recipients:\n      - syoyo@lighttransport.com\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1455078125,
          "content": "#Common folder for building objects\nbuild/\n/python/dist/\n/python/*.egg-info\n/python/.eggs\n/python/tiny_obj_loader.h\n/tests/tester\n/tests/tester.dSYM\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.626953125,
          "content": "language: cpp\nsudo: required\nmatrix:\n  include:\n  - addons: &1\n      apt:\n        sources:\n        - george-edison55-precise-backports\n        - ubuntu-toolchain-r-test\n        - llvm-toolchain-precise-3.7\n        packages:\n        - cmake\n        - cmake-data\n        - ninja-build\n        - g++-4.9\n        - clang-3.7\n    compiler: clang\n    env: DEPLOY_BUILD=1 COMPILER_VERSION=3.7 BUILD_TYPE=Debug\n  - addons: *1\n    compiler: clang\n    env: COMPILER_VERSION=3.7 BUILD_TYPE=Release\n  - addons: &2\n      apt:\n        sources:\n        - george-edison55-precise-backports\n        - ubuntu-toolchain-r-test\n        packages:\n        - cmake\n        - cmake-data\n        - ninja-build\n        - g++-4.9\n    compiler: gcc\n    env: COMPILER_VERSION=4.9 BUILD_TYPE=Debug\n  - addons: *2\n    compiler: gcc\n    env: COMPILER_VERSION=4.9 BUILD_TYPE=Release\n  - addons: *1\n    compiler: clang\n    env: COMPILER_VERSION=3.7 BUILD_TYPE=Debug\nbefore_install:\n- if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew upgrade; fi\n- if [ -n \"$REPORT_COVERAGE\" ]; then sudo apt-get update python; fi\n- if [ -n \"$REPORT_COVERAGE\" ]; then sudo apt-get install python-dev libffi-dev libssl-dev; fi\n- if [ -n \"$REPORT_COVERAGE\" ]; then sudo pip install --upgrade pip; fi\n- if [ -n \"$REPORT_COVERAGE\" ]; then CXX=g++ pip install --user requests[security]; fi\n- if [ -n \"$REPORT_COVERAGE\" ]; then CXX=g++ pip install --user cpp-coveralls; fi\nscript:\n- cd tests\n- make check\n- if [ -n \"$REPORT_COVERAGE\" ]; then coveralls -b . -r .. -e examples -e tools -e\n  jni -e python -e images -E \".*CompilerId.*\" -E \".*feature_tests.*\" ; fi\n- cd ..\n- rm -rf dist\n- mkdir dist\n- cp tiny_obj_loader.h dist/\n\n"
        },
        {
          "name": "BUILD.bazel",
          "type": "blob",
          "size": 0.2412109375,
          "content": "cc_library(\n    name = \"tinyobjloader\",\n    hdrs = [\"tiny_obj_loader.h\"],\n    copts = select({\n        \"@platforms//os:windows\": [],\n        \"//conditions:default\": [\"-Wno-maybe-uninitialized\"],\n    }),\n    visibility = [\"//visibility:public\"],\n)\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 6.404296875,
          "content": "#Tiny Object Loader Cmake configuration file.\n#This configures the Cmake system with multiple properties, depending\n#on the platform and configuration it is set to build in.\ncmake_minimum_required(VERSION 3.16)\nproject(tinyobjloader CXX)\nset(TINYOBJLOADER_SOVERSION 2)\nset(TINYOBJLOADER_VERSION 2.0.0-rc.13)\nset(PY_TARGET \"pytinyobjloader\")\n\n#optional double precision support\noption(TINYOBJLOADER_USE_DOUBLE \"Build library with double precision instead of single (float)\" OFF)\noption(TINYOBJLOADER_WITH_PYTHON \"Build Python module(for developer). Use pyproject.toml/setup.py to build Python module for end-users\" OFF)\noption(TINYOBJLOADER_PREFER_LOCAL_PYTHON_INSTALLATION\n      \"Prefer locally-installed Python interpreter than system or conda/brew installed Python. Please specify your Python interpreter   with `Python3_EXECUTABLE` cmake option if you enable this option.\"\n      OFF)\n\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake/sanitizers)\nfind_package(Sanitizers) # Address sanitizer (-DSANITIZE_ADDRESS=ON)\n\n\nif(TINYOBJLOADER_USE_DOUBLE)\n  set(LIBRARY_NAME ${PROJECT_NAME}_double)\nelse()\n  set(LIBRARY_NAME ${PROJECT_NAME})\nendif()\n\n#Folder Shortcuts\nset(TINYOBJLOADEREXAMPLES_DIR ${CMAKE_CURRENT_SOURCE_DIR}/examples)\n\nset(tinyobjloader-Source\n  ${CMAKE_CURRENT_SOURCE_DIR}/tiny_obj_loader.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/tiny_obj_loader.cc\n  )\n\nset(tinyobjloader-Example-Source\n  ${CMAKE_CURRENT_SOURCE_DIR}/loader_example.cc\n  )\n\nset(tinyobjloader-examples-objsticher\n  ${TINYOBJLOADEREXAMPLES_DIR}/obj_sticher/obj_writer.h\n  ${TINYOBJLOADEREXAMPLES_DIR}/obj_sticher/obj_writer.cc\n  ${TINYOBJLOADEREXAMPLES_DIR}/obj_sticher/obj_sticher.cc\n  )\n\n#Install destinations\ninclude(GNUInstallDirs)\n\nset(TINYOBJLOADER_CMAKE_DIR ${CMAKE_INSTALL_LIBDIR}/${PROJECT_NAME}/cmake)\nset(TINYOBJLOADER_DOC_DIR ${CMAKE_INSTALL_DOCDIR})\nset(TINYOBJLOADER_INCLUDE_DIR ${CMAKE_INSTALL_INCLUDEDIR})\nset(TINYOBJLOADER_LIBRARY_DIR ${CMAKE_INSTALL_LIBDIR})\nset(TINYOBJLOADER_PKGCONFIG_DIR ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\nset(TINYOBJLOADER_RUNTIME_DIR ${CMAKE_INSTALL_BINDIR})\n\noption(TINYOBJLOADER_BUILD_TEST_LOADER \"Build Example Loader Application\" OFF)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\n# Build standalone .so for Python binding(for developer)\nif (TINYOBJLOADER_WITH_PYTHON)\n\n  if(TINYOBJLOADER_PREFER_LOCAL_PYTHON_INSTALLATION)\n    #message(STATUS \"Local Python\")\n    set(Python3_FIND_FRAMEWORK NEVER) # Do not search framework python\n    set(Python3_FIND_STRATEGY LOCATION)\n    set(Python3_FIND_REGISTRY NEVER) # Windows only\n  else()\n    set(Python3_FIND_FRAMEWORK LAST\n    )# Prefer Brew/Conda to Apple framework python\n  endif()\n\n  find_package(\n    Python3\n    COMPONENTS Interpreter Development\n    REQUIRED)\n\n  find_package(pybind11 CONFIG REQUIRED)\n\nendif()\n\n\n\nadd_library(${LIBRARY_NAME} ${tinyobjloader-Source})\nadd_sanitizers(${LIBRARY_NAME})\n\nif(BUILD_SHARED_LIBS)\n  set_target_properties(${LIBRARY_NAME} PROPERTIES\n    SOVERSION ${TINYOBJLOADER_SOVERSION}\n    WINDOWS_EXPORT_ALL_SYMBOLS ON\n  )\nendif()\n\nif(TINYOBJLOADER_USE_DOUBLE)\n  target_compile_definitions(${LIBRARY_NAME} PUBLIC TINYOBJLOADER_USE_DOUBLE)\nendif()\n\nset_target_properties(${LIBRARY_NAME} PROPERTIES VERSION ${TINYOBJLOADER_VERSION})\n\ntarget_include_directories(${LIBRARY_NAME} INTERFACE\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n  $<INSTALL_INTERFACE:${TINYOBJLOADER_INCLUDE_DIR}>\n  )\n\nexport(TARGETS ${LIBRARY_NAME} FILE ${PROJECT_NAME}-targets.cmake)\n\nif(TINYOBJLOADER_BUILD_TEST_LOADER)\n  add_executable(test_loader ${tinyobjloader-Example-Source})\n  target_link_libraries(test_loader ${LIBRARY_NAME})\nendif()\n\noption(TINYOBJLOADER_BUILD_OBJ_STICHER \"Build OBJ Sticher Application\" OFF)\nif(TINYOBJLOADER_BUILD_OBJ_STICHER)\n  add_executable(obj_sticher ${tinyobjloader-examples-objsticher})\n  target_link_libraries(obj_sticher ${LIBRARY_NAME})\n\n  install(TARGETS\n    obj_sticher\n    DESTINATION\n    ${TINYOBJLOADER_RUNTIME_DIR}\n    )\nendif()\n\nif (TINYOBJLOADER_WITH_PYTHON)\n  # pybind11 method:\n  pybind11_add_module(${PY_TARGET} ${CMAKE_SOURCE_DIR}/python/bindings.cc ${CMAKE_SOURCE_DIR}/python/tiny_obj_loader.cc)\n\n  add_sanitizers(${PY_TARGET})\n  set_target_properties(${PY_TARGET} PROPERTIES OUTPUT_NAME \"tinyobjloader\")\n\n  # copy .so to jdepp/\n  add_custom_command(\n    TARGET ${PY_TARGET}\n    POST_BUILD\n    COMMAND \"${CMAKE_COMMAND}\" -E copy \"$<TARGET_FILE:${PY_TARGET}>\"\n            \"${CMAKE_SOURCE_DIR}/python/$<TARGET_FILE_NAME:${PY_TARGET}>\"\n    COMMENT \"copying tinyobjloader native python module file to python/\"\n    VERBATIM)\n\nendif()\n\n#Write CMake package config files\ninclude(CMakePackageConfigHelpers)\n\nconfigure_package_config_file(\n  ${PROJECT_NAME}-config.cmake.in\n  ${PROJECT_NAME}-config.cmake\n  INSTALL_DESTINATION\n  ${TINYOBJLOADER_CMAKE_DIR}\n  PATH_VARS\n  TINYOBJLOADER_INCLUDE_DIR\n  TINYOBJLOADER_LIBRARY_DIR\n  NO_CHECK_REQUIRED_COMPONENTS_MACRO\n  )\n\nwrite_basic_package_version_file(${PROJECT_NAME}-config-version.cmake\n  VERSION\n  ${TINYOBJLOADER_VERSION}\n  COMPATIBILITY\n  SameMajorVersion\n  )\n\n#pkg-config file\nconfigure_file(${PROJECT_NAME}.pc.in ${LIBRARY_NAME}.pc @ONLY)\n\nif(DEFINED ENV{LIB_FUZZING_ENGINE})\n  add_executable(fuzz_ParseFromString fuzzer/fuzz_ParseFromString.cc)\n  target_link_libraries(fuzz_ParseFromString ${LIBRARY_NAME} $ENV{LIB_FUZZING_ENGINE})\nendif()\n\n#Installation\ninstall(TARGETS\n  ${LIBRARY_NAME}\n  EXPORT ${PROJECT_NAME}-targets\n  DESTINATION\n  ${TINYOBJLOADER_LIBRARY_DIR}\n  PUBLIC_HEADER DESTINATION\n  ${TINYOBJLOADER_INCLUDE_DIR}\n  RUNTIME DESTINATION\n  ${TINYOBJLOADER_RUNTIME_DIR}\n  )\ninstall(EXPORT\n  ${PROJECT_NAME}-targets\n  NAMESPACE\n  tinyobjloader::\n  DESTINATION\n  ${TINYOBJLOADER_CMAKE_DIR}\n  )\ninstall(FILES\n  tiny_obj_loader.h\n  DESTINATION\n  ${TINYOBJLOADER_INCLUDE_DIR}\n  )\ninstall(FILES\n  LICENSE\n  DESTINATION\n  ${TINYOBJLOADER_DOC_DIR}\n  )\ninstall(FILES\n  \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake\"\n  DESTINATION\n  ${TINYOBJLOADER_CMAKE_DIR}\n  )\ninstall(FILES\n  \"${CMAKE_CURRENT_BINARY_DIR}/${LIBRARY_NAME}.pc\"\n  DESTINATION\n  ${TINYOBJLOADER_PKGCONFIG_DIR}\n  )\n\nif(NOT TARGET uninstall)\n  configure_file(\n    ${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\n    ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake IMMEDIATE @ONLY)\n\n  add_custom_target(\n    uninstall COMMAND ${CMAKE_COMMAND} -P\n                      ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.857421875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2012-2019 Syoyo Fujita and many contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n----------------------------------\n\nmapbox/earcut.hpp\n\nISC License\n\nCopyright (c) 2015, Mapbox\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.181640625,
          "content": "include pyproject.toml\ninclude setup.py\ninclude README.md\ninclude LICENSE\ninclude python/sample.py\ninclude python/bindings.cc\ninclude python/tiny_obj_loader.cc\ninclude tiny_obj_loader.h\n"
        },
        {
          "name": "MODULE.bazel",
          "type": "blob",
          "size": 0.125,
          "content": "module(\n    name = \"tinyobjloader\",\n    compatibility_level = 1,\n)\n\nbazel_dep(\n    name = \"platforms\",\n    version = \"0.0.8\",\n)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.9013671875,
          "content": "# tinyobjloader\n\n[![PyPI version](https://badge.fury.io/py/tinyobjloader.svg)](https://badge.fury.io/py/tinyobjloader)\n\n[![AZ Build Status](https://dev.azure.com/tinyobjloader/tinyobjloader/_apis/build/status/tinyobjloader.tinyobjloader?branchName=master)](https://dev.azure.com/tinyobjloader/tinyobjloader/_build/latest?definitionId=1&branchName=master)\n\n[![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/m6wfkvket7gth8wn/branch/master?svg=true)](https://ci.appveyor.com/project/syoyo/tinyobjloader-6e4qf/branch/master)\n\n[![Coverage Status](https://coveralls.io/repos/github/syoyo/tinyobjloader/badge.svg?branch=master)](https://coveralls.io/github/syoyo/tinyobjloader?branch=master)\n\n[![AUR version](https://img.shields.io/aur/version/tinyobjloader?logo=arch-linux)](https://aur.archlinux.org/packages/tinyobjloader)\n\nTiny but powerful single file wavefront obj loader written in C++03. No dependency except for C++ STL. It can parse over 10M polygons with moderate memory and time.\n\n`tinyobjloader` is good for embedding .obj loader to your (global illumination) renderer ;-)\n\nIf you are looking for C99 version, please see https://github.com/syoyo/tinyobjloader-c .\n\nVersion notice\n--------------\n\nWe recommend to use `master`(`main`) branch. Its v2.0 release candidate. Most features are now nearly robust and stable(Remaining task for release v2.0 is polishing C++ and Python API, and fix built-in triangulation code).\n\nWe have released new version v1.0.0 on 20 Aug, 2016.\nOld version is available as `v0.9.x` branch https://github.com/syoyo/tinyobjloader/tree/v0.9.x\n\n## What's new\n\n* 29 Jul, 2021 : Added Mapbox's earcut for robust triangulation. Also fixes triangulation bug(still there is some issue in built-in triangulation algorithm: https://github.com/tinyobjloader/tinyobjloader/issues/319).\n* 19 Feb, 2020 : The repository has been moved to https://github.com/tinyobjloader/tinyobjloader !\n* 18 May, 2019 : Python binding!(See `python` folder. Also see https://pypi.org/project/tinyobjloader/)\n* 14 Apr, 2019 : Bump version v2.0.0 rc0. New C++ API and python bindings!(1.x API still exists for backward compatibility)\n* 20 Aug, 2016 : Bump version v1.0.0. New data structure and API!\n\n## Requirements\n\n* C++03 compiler\n\n### Old version\n\nPrevious old version is available in `v0.9.x` branch.\n\n## Example\n\n![Rungholt](images/rungholt.jpg)\n\ntinyobjloader can successfully load 6M triangles Rungholt scene.\nhttp://casual-effects.com/data/index.html\n\n![](images/sanmugel.png)\n\n* [examples/viewer/](examples/viewer) OpenGL .obj viewer\n* [examples/callback_api/](examples/callback_api/) Callback API example\n* [examples/voxelize/](examples/voxelize/) Voxelizer example\n\n## Use case\n\nTinyObjLoader is successfully used in ...\n\n### New version(v1.0.x)\n\n* Double precision support through `TINYOBJLOADER_USE_DOUBLE` thanks to noma\n* Loading models in Vulkan Tutorial https://vulkan-tutorial.com/Loading_models\n* .obj viewer with Metal https://github.com/middlefeng/NuoModelViewer/tree/master\n* Vulkan Cookbook https://github.com/PacktPublishing/Vulkan-Cookbook\n* cudabox: CUDA Solid Voxelizer Engine https://github.com/gaspardzoss/cudavox\n* Drake: A planning, control, and analysis toolbox for nonlinear dynamical systems https://github.com/RobotLocomotion/drake\n* VFPR - a Vulkan Forward Plus Renderer : https://github.com/WindyDarian/Vulkan-Forward-Plus-Renderer\n* glslViewer: https://github.com/patriciogonzalezvivo/glslViewer\n* Lighthouse2: https://github.com/jbikker/lighthouse2\n* rayrender(an open source R package for raytracing scenes in created in R): https://github.com/tylermorganwall/rayrender\n* liblava - A modern C++ and easy-to-use framework for the Vulkan API. [MIT]: https://github.com/liblava/liblava\n* rtxON - Simple Vulkan raytracing tutorials  https://github.com/iOrange/rtxON\n* metal-ray-tracer - Writing ray-tracer using Metal Performance Shaders https://github.com/sergeyreznik/metal-ray-tracer https://sergeyreznik.github.io/metal-ray-tracer/index.html\n* Supernova Engine - 2D and 3D projects with Lua or C++ in data oriented design: https://github.com/supernovaengine/supernova\n* AGE (Arc Game Engine) - An open-source engine for building 2D & 3D real-time rendering and interactive contents: https://github.com/MohitSethi99/ArcGameEngine\n* [Wicked Engine<img src=\"https://github.com/turanszkij/WickedEngine/blob/master/Content/logo_small.png\" width=\"28px\" align=\"center\"/>](https://github.com/turanszkij/WickedEngine) - 3D engine with modern graphics \n* Your project here! (Letting us know via github issue is welcome!)\n\n### Old version(v0.9.x)\n\n* bullet3 https://github.com/erwincoumans/bullet3\n* pbrt-v2 https://github.com/mmp/pbrt-v2\n* OpenGL game engine development http://swarminglogic.com/jotting/2013_10_gamedev01\n* mallie https://lighttransport.github.io/mallie\n* IBLBaker (Image Based Lighting Baker). http://www.derkreature.com/iblbaker/\n* Stanford CS148 http://web.stanford.edu/class/cs148/assignments/assignment3.pdf\n* Awesome Bump http://awesomebump.besaba.com/about/\n* sdlgl3-wavefront OpenGL .obj viewer https://github.com/chrisliebert/sdlgl3-wavefront\n* pbrt-v3 https://github.com/mmp/pbrt-v3\n* cocos2d-x https://github.com/cocos2d/cocos2d-x/\n* Android Vulkan demo https://github.com/SaschaWillems/Vulkan\n* voxelizer https://github.com/karimnaaji/voxelizer\n* Probulator https://github.com/kayru/Probulator\n* OptiX Prime baking https://github.com/nvpro-samples/optix_prime_baking\n* FireRays SDK https://github.com/GPUOpen-LibrariesAndSDKs/FireRays_SDK\n* parg, tiny C library of various graphics utilities and GL demos https://github.com/prideout/parg\n* Opengl unit of ChronoEngine https://github.com/projectchrono/chrono-opengl\n* Point Based Global Illumination on modern GPU https://pbgi.wordpress.com/code-source/\n* Fast OBJ file importing and parsing in CUDA http://researchonline.jcu.edu.au/42515/1/2015.CVM.OBJCUDA.pdf\n* Sorted Shading for Uni-Directional Pathtracing by Joshua Bainbridge https://nccastaff.bournemouth.ac.uk/jmacey/MastersProjects/MSc15/02Josh/joshua_bainbridge_thesis.pdf\n* GeeXLab http://www.geeks3d.com/hacklab/20160531/geexlab-0-12-0-0-released-for-windows/\n\n\n## Features\n\n* Group(parse multiple group name)\n* Vertex\n  * Vertex color(as an extension: https://blender.stackexchange.com/questions/31997/how-can-i-get-vertex-painted-obj-files-to-import-into-blender)\n* Texcoord\n* Normal\n* Crease tag('t'). This is OpenSubdiv specific(not in wavefront .obj specification)\n* Callback API for custom loading.\n* Double precision support(for HPC application).\n* Smoothing group\n* Python binding : See `python` folder.\n  * Precompiled binary(manylinux1-x86_64 only) is hosted at pypi https://pypi.org/project/tinyobjloader/)\n\n### Primitives\n\n* [x] face(`f`)\n* [x] lines(`l`)\n* [ ] points(`p`)\n* [ ] curve\n* [ ] 2D curve\n* [ ] surface.\n* [ ] Free form curve/surfaces\n\n### Material\n\n* PBR material extension for .MTL. Please see [pbr-mtl.md](pbr-mtl.md) for details.\n* Texture options\n* Unknown material attributes are returned as key-value(value is string) map.\n\n## TODO\n\n* [ ] Fix obj_sticker example.\n* [ ] More unit test codes.\n\n## License\n\nTinyObjLoader is licensed under MIT license.\n\n### Third party licenses.\n\n* pybind11 : BSD-style license.\n* mapbox earcut.hpp: ISC License.\n\n## Usage\n\n### Installation\n\nOne option is to simply copy the header file into your project and to make sure that `TINYOBJLOADER_IMPLEMENTATION` is defined exactly once.\n\n### Building tinyobjloader - Using vcpkg(not recommended though)\n\nAlthough it is not a recommended way, you can download and install tinyobjloader using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    ./vcpkg install tinyobjloader\n\nThe tinyobjloader port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n### Data format\n\n`attrib_t` contains single and linear array of vertex data(position, normal and texcoord).\n\n```\nattrib_t::vertices => 3 floats per vertex\n\n       v[0]        v[1]        v[2]        v[3]               v[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::normals => 3 floats per vertex\n\n       n[0]        n[1]        n[2]        n[3]               n[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::texcoords => 2 floats per vertex\n\n       t[0]        t[1]        t[2]        t[3]               t[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  |  u  |  v  |  u  |  v  |  u  |  v  |  u  |  v  | .... |  u  |  v  |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::colors => 3 floats per vertex(vertex color. optional)\n\n       c[0]        c[1]        c[2]        c[3]               c[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\n```\n\nEach `shape_t::mesh_t` does not contain vertex data but contains array index to `attrib_t`.\nSee `loader_example.cc` for more details.\n\n\n```\n\nmesh_t::indices => array of vertex indices.\n\n  +----+----+----+----+----+----+----+----+----+----+     +--------+\n  | i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | ... | i(n-1) |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+\n\nEach index has an array index to attrib_t::vertices, attrib_t::normals and attrib_t::texcoords.\n\nmesh_t::num_face_vertices => array of the number of vertices per face(e.g. 3 = triangle, 4 = quad , 5 or more = N-gons).\n\n\n  +---+---+---+        +---+\n  | 3 | 4 | 3 | ...... | 3 |\n  +---+---+---+        +---+\n    |   |   |            |\n    |   |   |            +-----------------------------------------+\n    |   |   |                                                      |\n    |   |   +------------------------------+                       |\n    |   |                                  |                       |\n    |   +------------------+               |                       |\n    |                      |               |                       |\n    |/                     |/              |/                      |/\n\n mesh_t::indices\n\n  |    face[0]   |       face[1]     |    face[2]   |     |      face[n-1]           |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+--------+--------+\n  | i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | ... | i(n-3) | i(n-2) | i(n-1) |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+--------+--------+\n\n```\n\nNote that when `triangulate` flag is true in `tinyobj::LoadObj()` argument, `num_face_vertices` are all filled with 3(triangle).\n\n### float data type\n\nTinyObjLoader now use `real_t` for floating point data type.\nDefault is `float(32bit)`.\nYou can enable `double(64bit)` precision by using `TINYOBJLOADER_USE_DOUBLE` define.\n\n### Robust triangulation\n\nWhen you enable `triangulation`(default is enabled),\nTinyObjLoader triangulate polygons(faces with 4 or more vertices).\n\nBuilt-in triangulation code may not work well in some polygon shape.\n\nYou can define `TINYOBJLOADER_USE_MAPBOX_EARCUT` for robust triangulation using `mapbox/earcut.hpp`.\nThis requires C++11 compiler though. And you need to copy `mapbox/earcut.hpp` to your project.\nIf you have your own `mapbox/earcut.hpp` file incuded in your project, you can define `TINYOBJLOADER_DONOT_INCLUDE_MAPBOX_EARCUT` so that `mapbox/earcut.hpp` is not included inside of `tiny_obj_loader.h`.\n\n#### Example code (Deprecated API)\n\n```c++\n#define TINYOBJLOADER_IMPLEMENTATION // define this in only *one* .cc\n// Optional. define TINYOBJLOADER_USE_MAPBOX_EARCUT gives robust triangulation. Requires C++11\n//#define TINYOBJLOADER_USE_MAPBOX_EARCUT\n#include \"tiny_obj_loader.h\"\n\nstd::string inputfile = \"cornell_box.obj\";\ntinyobj::attrib_t attrib;\nstd::vector<tinyobj::shape_t> shapes;\nstd::vector<tinyobj::material_t> materials;\n\nstd::string warn;\nstd::string err;\n\nbool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, inputfile.c_str());\n\nif (!warn.empty()) {\n  std::cout << warn << std::endl;\n}\n\nif (!err.empty()) {\n  std::cerr << err << std::endl;\n}\n\nif (!ret) {\n  exit(1);\n}\n\n// Loop over shapes\nfor (size_t s = 0; s < shapes.size(); s++) {\n  // Loop over faces(polygon)\n  size_t index_offset = 0;\n  for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++) {\n    size_t fv = size_t(shapes[s].mesh.num_face_vertices[f]);\n\n    // Loop over vertices in the face.\n    for (size_t v = 0; v < fv; v++) {\n      // access to vertex\n      tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];\n\n      tinyobj::real_t vx = attrib.vertices[3*size_t(idx.vertex_index)+0];\n      tinyobj::real_t vy = attrib.vertices[3*size_t(idx.vertex_index)+1];\n      tinyobj::real_t vz = attrib.vertices[3*size_t(idx.vertex_index)+2];\n\n      // Check if `normal_index` is zero or positive. negative = no normal data\n      if (idx.normal_index >= 0) {\n        tinyobj::real_t nx = attrib.normals[3*size_t(idx.normal_index)+0];\n        tinyobj::real_t ny = attrib.normals[3*size_t(idx.normal_index)+1];\n        tinyobj::real_t nz = attrib.normals[3*size_t(idx.normal_index)+2];\n      }\n\n      // Check if `texcoord_index` is zero or positive. negative = no texcoord data\n      if (idx.texcoord_index >= 0) {\n        tinyobj::real_t tx = attrib.texcoords[2*size_t(idx.texcoord_index)+0];\n        tinyobj::real_t ty = attrib.texcoords[2*size_t(idx.texcoord_index)+1];\n      }\n      // Optional: vertex colors\n      // tinyobj::real_t red   = attrib.colors[3*size_t(idx.vertex_index)+0];\n      // tinyobj::real_t green = attrib.colors[3*size_t(idx.vertex_index)+1];\n      // tinyobj::real_t blue  = attrib.colors[3*size_t(idx.vertex_index)+2];\n    }\n    index_offset += fv;\n\n    // per-face material\n    shapes[s].mesh.material_ids[f];\n  }\n}\n\n```\n\n#### Example code (New Object Oriented API)\n\n```c++\n#define TINYOBJLOADER_IMPLEMENTATION // define this in only *one* .cc\n// Optional. define TINYOBJLOADER_USE_MAPBOX_EARCUT gives robust triangulation. Requires C++11\n//#define TINYOBJLOADER_USE_MAPBOX_EARCUT\n#include \"tiny_obj_loader.h\"\n\n\nstd::string inputfile = \"cornell_box.obj\";\ntinyobj::ObjReaderConfig reader_config;\nreader_config.mtl_search_path = \"./\"; // Path to material files\n\ntinyobj::ObjReader reader;\n\nif (!reader.ParseFromFile(inputfile, reader_config)) {\n  if (!reader.Error().empty()) {\n      std::cerr << \"TinyObjReader: \" << reader.Error();\n  }\n  exit(1);\n}\n\nif (!reader.Warning().empty()) {\n  std::cout << \"TinyObjReader: \" << reader.Warning();\n}\n\nauto& attrib = reader.GetAttrib();\nauto& shapes = reader.GetShapes();\nauto& materials = reader.GetMaterials();\n\n// Loop over shapes\nfor (size_t s = 0; s < shapes.size(); s++) {\n  // Loop over faces(polygon)\n  size_t index_offset = 0;\n  for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++) {\n    size_t fv = size_t(shapes[s].mesh.num_face_vertices[f]);\n\n    // Loop over vertices in the face.\n    for (size_t v = 0; v < fv; v++) {\n      // access to vertex\n      tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];\n      tinyobj::real_t vx = attrib.vertices[3*size_t(idx.vertex_index)+0];\n      tinyobj::real_t vy = attrib.vertices[3*size_t(idx.vertex_index)+1];\n      tinyobj::real_t vz = attrib.vertices[3*size_t(idx.vertex_index)+2];\n\n      // Check if `normal_index` is zero or positive. negative = no normal data\n      if (idx.normal_index >= 0) {\n        tinyobj::real_t nx = attrib.normals[3*size_t(idx.normal_index)+0];\n        tinyobj::real_t ny = attrib.normals[3*size_t(idx.normal_index)+1];\n        tinyobj::real_t nz = attrib.normals[3*size_t(idx.normal_index)+2];\n      }\n\n      // Check if `texcoord_index` is zero or positive. negative = no texcoord data\n      if (idx.texcoord_index >= 0) {\n        tinyobj::real_t tx = attrib.texcoords[2*size_t(idx.texcoord_index)+0];\n        tinyobj::real_t ty = attrib.texcoords[2*size_t(idx.texcoord_index)+1];\n      }\n\n      // Optional: vertex colors\n      // tinyobj::real_t red   = attrib.colors[3*size_t(idx.vertex_index)+0];\n      // tinyobj::real_t green = attrib.colors[3*size_t(idx.vertex_index)+1];\n      // tinyobj::real_t blue  = attrib.colors[3*size_t(idx.vertex_index)+2];\n    }\n    index_offset += fv;\n\n    // per-face material\n    shapes[s].mesh.material_ids[f];\n  }\n}\n\n```\n\n\n\n## Optimized loader\n\nOptimized multi-threaded .obj loader is available at `experimental/` directory.\nIf you want absolute performance to load .obj data, this optimized loader will fit your purpose.\nNote that the optimized loader uses C++11 thread and it does less error checks but may work most .obj data.\n\nHere is some benchmark result. Time are measured on MacBook 12(Early 2016, Core m5 1.2GHz).\n\n* Rungholt scene(6M triangles)\n  * old version(v0.9.x): 15500 msecs.\n  * baseline(v1.0.x): 6800 msecs(2.3x faster than old version)\n  * optimised: 1500 msecs(10x faster than old version, 4.5x faster than baseline)\n\n## Python binding\n\n```\n$ python -m pip install tinyobjloader\n```\n\nSee [python/sample.py](python/sample.py) for example use of Python binding of tinyobjloader.\n\n### CI + PyPI upload\n\ncibuildwheels + twine upload for each git tagging event is handled in Github Actions and Cirrus CI(arm builds).\n\n#### How to bump version(For developer)\n\n* Apply `black` to python files(`python/sample.py`)\n* Bump version in CMakeLists.txt\n* Commit and push `release`. Confirm C.I. build is OK.\n* Create tag starting with `v`(e.g. `v2.1.0`)\n* `git push --tags`\n  * version settings is automatically handled in python binding through setuptools_scm.\n  * cibuildwheels + pypi upload(through twine) will be automatically triggered in Github Actions + Cirrus CI.\n\n## Tests\n\nUnit tests are provided in `tests` directory. See `tests/README.md` for details.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.80859375,
          "content": "version: 1.0.{build}\n\nplatform: x64\n\ninstall:\n  #######################################################################################\n  # All external dependencies are installed in C:\\projects\\deps\n  #######################################################################################\n  - mkdir C:\\projects\\deps\n\n  #######################################################################################\n  # Install Ninja\n  #######################################################################################\n  - set NINJA_URL=\"https://github.com/ninja-build/ninja/releases/download/v1.10.0/ninja-win.zip\"\n  - appveyor DownloadFile %NINJA_URL% -FileName ninja.zip\n  - 7z x ninja.zip -oC:\\projects\\deps\\ninja > nul\n  - set PATH=C:\\projects\\deps\\ninja;%PATH%\n  - ninja --version\n\nbuild_script:\n  - cd tests\n  - vcbuild.bat\n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 5.474609375,
          "content": "#\n# Python wheels build is now done in Github Actions + Cirrus CI(for arm build)\n# so python build is disabled in Azure pipelines.\n# \n\nvariables:\n  # https://cibuildwheel.readthedocs.io/en/stable/cpp_standards/\n  # cibuildwheel now supports python 3.6+(as of 2022 Oct)\n  #CIBW_SKIP: \"pp*\"\n  CIBW_BEFORE_BUILD: \"pip install pybind11\"\n  CIBW_ARCHS_LINUXBEFORE_BUILD: \"pip install pybind11\"\n  # disable aarch64 build for a while since it(pulling docker aarch64 image)  exceeds Azure's 60 min limit\n  # NOTE: aarch64 linux support in Azure pipeline is not yet officially supported(as of 2022 Oct) https://github.com/microsoft/azure-pipelines-agent/issues/3935\n  #CIBW_ARCHS_LINUX: auto aarch64\n  CIBW_ARCHS_MACOS: x86_64 universal2 arm64\n  #CIBW_BEFORE_BUILD_MACOS: \"pip install -U pip setuptools\"\n  #CIBW_BEFORE_BUILD_LINUX: \"pip install -U pip setuptools\"\n  #CIBW_TEST_COMMAND: TODO \"python -c \\\"import tinyobjloader; tinyobjloader.test()\\\"\"\n  CIBW_BUILD_VERBOSITY: \"2\"\n  #CIBW_MANYLINUX_X86_64_IMAGE: manylinux2014\n  #CIBW_MANYLINUX_I686_IMAGE: manylinux2014\n\njobs:\n  - job: unit_linux\n    pool: { vmImage: \"ubuntu-latest\" }\n    steps:\n      - script: |\n          cd tests\n          make && ./tester\n        displayName: Run unit tests\n\n  - job: python_format\n    pool: { vmImage: \"ubuntu-latest\" }\n    steps:\n      - task: UsePythonVersion@0\n      - script: |\n          # 19.10b0 triggers 'cannot import name '_unicodefun' from 'click'' error.\n          # https://stackoverflow.com/questions/71673404/importerror-cannot-import-name-unicodefun-from-click\n          #pip install black==19.10b0\n          #pip install black==22.3.0\n          pip install black==22.10.0\n\n          black --check python/\n        displayName: Check Python code format\n\n  # Disabled: python build\n  ##\n  ## Ubuntu16.04 seems now deprecated(as of 2021/12/01),\n  ## so use `ubuntu-latest`\n  #- job: linux\n  #  pool: {vmImage: \"ubuntu-latest\"}\n  #  steps:\n  #    - task: UsePythonVersion@0\n  #    - bash: |\n  #        python3 -m pip install --upgrade pip\n  #        pip3 install cibuildwheel twine\n\n  #        # Use pipx to build source dist\n  #        pip3 install pipx\n\n  #        # Source dist\n  #        pipx run build --sdist\n  #        ls -la dist/*\n\n  #        # build binary wheels\n  #        cibuildwheel --platform linux --output-dir wheelhouse .\n\n  #    - task: CopyFiles@2\n  #      inputs:\n  #        contents: 'wheelhouse/**'\n  #        targetFolder: $(Build.ArtifactStagingDirectory)\n\n  #    - task: CopyFiles@2\n  #      inputs:\n  #        contents: 'dist/**'\n  #        targetFolder: $(Build.ArtifactStagingDirectory)\n\n  #    - task: PublishBuildArtifacts@1\n  #      inputs:\n  #        path: $(Build.ArtifactStagingDirectory)\n  #        artifactName: tinyobjDeployLinux\n\n  #- job: macos\n  #  pool: {vmImage: 'macOS-latest'}\n  #  variables:\n  #    # Support C++11: https://github.com/joerick/cibuildwheel/pull/156\n  #    MACOSX_DEPLOYMENT_TARGET: 10.9\n  #  steps:\n  #    - task: UsePythonVersion@0\n  #    - bash: |\n  #        python3 -m pip install --upgrade pip\n  #        pip3 install cibuildwheel\n  #        cibuildwheel --platform macos --output-dir wheelhouse .\n  #    - task: CopyFiles@2\n  #      inputs:\n  #        contents: 'wheelhouse/*.whl'\n  #        targetFolder: $(Build.ArtifactStagingDirectory)\n  #    - task: PublishBuildArtifacts@1\n  #      inputs:\n  #        path: $(Build.ArtifactStagingDirectory)\n  #        artifactName: tinyobjDeployMacOS\n\n  #- job: windows\n  #  pool: {vmImage: 'windows-latest'}\n  #  steps:\n  #    - task: UsePythonVersion@0\n  #    - bash: |\n  #        python -m pip install --upgrade pip\n  #        pip install cibuildwheel\n  #        cibuildwheel --platform windows --output-dir wheelhouse .\n  #    - task: CopyFiles@2\n  #      inputs:\n  #        contents: 'wheelhouse/*.whl'\n  #        targetFolder: $(Build.ArtifactStagingDirectory)\n  #    - task: PublishBuildArtifacts@1\n  #      inputs:\n  #        path: $(Build.ArtifactStagingDirectory)\n  #        artifactName: tinyobjDeployWindows\n\n  #- job: deployPyPI\n  #  # Based on vispy: https://github.com/vispy/vispy/blob/master/azure-pipelines.yml\n  #  pool: {vmImage: 'ubuntu-latest'}\n  #  condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/v'))\n  #  dependsOn:\n  #    - linux\n  #    - macos\n  #    - windows\n  #  steps:\n  #    - task: UsePythonVersion@0\n\n  #    # TODO(syoyo): Use buildType: specific to download multiple artifacts at once?\n  #    - task: DownloadBuildArtifacts@0\n  #      inputs:\n  #        artifactName: 'tinyobjDeployLinux'\n  #        downloadPath: $(Pipeline.Workspace)\n\n  #    - task: DownloadBuildArtifacts@0\n  #      inputs:\n  #        artifactName: 'tinyobjDeployMacOS'\n  #        downloadPath: $(Pipeline.Workspace)\n\n  #    - task: DownloadBuildArtifacts@0\n  #      inputs:\n  #        artifactName: 'tinyobjDeployWindows'\n  #        downloadPath: $(Pipeline.Workspace)\n\n  #    # Publish to PyPI through twine\n  #    - bash: |\n  #        cd $(Pipeline.Workspace)\n  #        find .\n  #        python -m pip install --upgrade pip\n  #        pip install twine\n  #        echo tinyobjDeployLinux/dist/*\n  #        echo tinyobjDeployLinux/wheelhouse/* tinyobjDeployMacOS/wheelhouse/* tinyobjDeployWindows/wheelhouse/*\n  #        twine upload -u \"__token__\" --skip-existing tinyobjDeployLinux/dist/* tinyobjDeployLinux/wheelhouse/* tinyobjDeployMacOS/wheelhouse/* tinyobjDeployWindows/wheelhouse/*\n  #      env:\n  #        TWINE_PASSWORD: $(pypiToken2)\n\ntrigger:\n  branches:\n    include:\n      - '*'\n  tags:\n    include:\n      - 'v*'\n\npr:\n  branches:\n    include:\n      - \"*\"\n"
        },
        {
          "name": "bootstrap-cmake-linux-with-pyhthon.sh",
          "type": "blob",
          "size": 0.4677734375,
          "content": "curdir=`pwd`\n\nbuilddir=${curdir}/build_python_module\n\nrm -rf ${builddir}\nmkdir ${builddir}\n\n# set path to pybind11\n# If you install pybind11 through pip, its usually installed to <site-package path>/pybind11.\npybind11_path=`python -c \"import site; print (site.getsitepackages()[0])\"`\necho ${pybind11_path}\n\nCC=clang CXX=clang++ \\\n  pybind11_DIR=${pybind11_path}/pybind11 \\\n  cmake \\\n  -B${builddir} \\\n  -DCMAKE_VERBOSE_MAKEFILE=1 \\\n  -DTINYOBJLOADER_WITH_PYTHON=1 \n\ncd ${curdir}\n"
        },
        {
          "name": "build.ninja",
          "type": "blob",
          "size": 1.3046875,
          "content": "ninja_required_version = 1.4\n\ngnubuilddir = build\ngnudefines = \ngnuincludes = -I.\ngnucflags = -O2 -g\ngnucxxflags = -O2 -g -pedantic -Wall -Wextra -Wcast-align -Wcast-qual $\n    -Wctor-dtor-privacy -Wdisabled-optimization -Wformat=2 -Winit-self $\n    -Wmissing-declarations -Wmissing-include-dirs -Wold-style-cast $\n    -Woverloaded-virtual -Wredundant-decls -Wshadow -Wsign-conversion $\n    -Wsign-promo -Wstrict-overflow=5 -Wswitch-default -Wundef -Werror $\n    -Wno-unused -fsanitize=address\ngnuldflags = -fsanitize=address\n\npool link_pool\n  depth = 1\n\nrule gnucxx\n  command = $gnucxx -MMD -MF $out.d $gnudefines $gnuincludes $gnucxxflags $\n      -c $in -o $out\n  description = CXX $out\n  depfile = $out.d\n  deps = gcc\nrule gnucc\n  command = $gnucc -MMD -MF $out.d $gnudefines $gnuincludes $gnucflags -c $\n      $in -o $out\n  description = CC $out\n  depfile = $out.d\n  deps = gcc\nrule gnulink\n  command = $gnuld -o $out $in $libs $gnuldflags\n  description = LINK $out\n  pool = link_pool\nrule gnuar\n  command = $gnuar rsc $out $in\n  description = AR $out\n  pool = link_pool\nrule gnustamp\n  command = touch $out\n  description = STAMP $out\n\ngnucxx = g++\ngnucc = gcc\ngnuld = $gnucxx\ngnuar = ar\n\nbuild loader_example.o: gnucxx loader_example.cc\n\n\nbuild loader_example: gnulink loader_example.o\nbuild all: phony loader_example\n\ndefault all\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 1.0107421875,
          "content": "if(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n  message(FATAL_ERROR \"Cannot find install manifest: @CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\nendif(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n\nfile(READ \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n  message(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n  if(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    exec_program(\n      \"@CMAKE_COMMAND@\" ARGS \"-E remove \\\"$ENV{DESTDIR}${file}\\\"\"\n      OUTPUT_VARIABLE rm_out\n      RETURN_VALUE rm_retval\n      )\n    if(NOT \"${rm_retval}\" STREQUAL 0)\n      message(FATAL_ERROR \"Problem when removing $ENV{DESTDIR}${file}\")\n    endif(NOT \"${rm_retval}\" STREQUAL 0)\n  else(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    message(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n  endif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\nendforeach(file)\n"
        },
        {
          "name": "deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "experimental",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzzer",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "jni",
          "type": "tree",
          "content": null
        },
        {
          "name": "loader_example.cc",
          "type": "blob",
          "size": 14.7197265625,
          "content": "//\n// g++ loader_example.cc\n//\n#define TINYOBJLOADER_IMPLEMENTATION\n#include \"tiny_obj_loader.h\"\n\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n\n#ifdef _WIN32\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#include <windows.h>\n#include <mmsystem.h>\n#ifdef __cplusplus\n}\n#endif\n#pragma comment(lib, \"winmm.lib\")\n#else\n#if defined(__unix__) || defined(__APPLE__)\n#include <sys/time.h>\n#else\n#include <ctime>\n#endif\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n#endif\n\nclass timerutil {\n public:\n#ifdef _WIN32\n  typedef DWORD time_t;\n\n  timerutil() { ::timeBeginPeriod(1); }\n  ~timerutil() { ::timeEndPeriod(1); }\n\n  void start() { t_[0] = ::timeGetTime(); }\n  void end() { t_[1] = ::timeGetTime(); }\n\n  time_t sec() { return (time_t)((t_[1] - t_[0]) / 1000); }\n  time_t msec() { return (time_t)((t_[1] - t_[0])); }\n  time_t usec() { return (time_t)((t_[1] - t_[0]) * 1000); }\n  time_t current() { return ::timeGetTime(); }\n\n#else\n#if defined(__unix__) || defined(__APPLE__)\n  typedef unsigned long int time_t;\n\n  void start() { gettimeofday(tv + 0, &tz); }\n  void end() { gettimeofday(tv + 1, &tz); }\n\n  time_t sec() { return static_cast<time_t>(tv[1].tv_sec - tv[0].tv_sec); }\n  time_t msec() {\n    return this->sec() * 1000 +\n           static_cast<time_t>((tv[1].tv_usec - tv[0].tv_usec) / 1000);\n  }\n  time_t usec() {\n    return this->sec() * 1000000 +\n           static_cast<time_t>(tv[1].tv_usec - tv[0].tv_usec);\n  }\n  time_t current() {\n    struct timeval t;\n    gettimeofday(&t, NULL);\n    return static_cast<time_t>(t.tv_sec * 1000 + t.tv_usec);\n  }\n\n#else  // C timer\n  // using namespace std;\n  typedef clock_t time_t;\n\n  void start() { t_[0] = clock(); }\n  void end() { t_[1] = clock(); }\n\n  time_t sec() { return (time_t)((t_[1] - t_[0]) / CLOCKS_PER_SEC); }\n  time_t msec() { return (time_t)((t_[1] - t_[0]) * 1000 / CLOCKS_PER_SEC); }\n  time_t usec() { return (time_t)((t_[1] - t_[0]) * 1000000 / CLOCKS_PER_SEC); }\n  time_t current() { return (time_t)clock(); }\n\n#endif\n#endif\n\n private:\n#ifdef _WIN32\n  DWORD t_[2];\n#else\n#if defined(__unix__) || defined(__APPLE__)\n  struct timeval tv[2];\n  struct timezone tz;\n#else\n  time_t t_[2];\n#endif\n#endif\n};\n\nstatic void PrintInfo(const tinyobj::attrib_t& attrib,\n                      const std::vector<tinyobj::shape_t>& shapes,\n                      const std::vector<tinyobj::material_t>& materials) {\n  std::cout << \"# of vertices  : \" << (attrib.vertices.size() / 3) << std::endl;\n  std::cout << \"# of normals   : \" << (attrib.normals.size() / 3) << std::endl;\n  std::cout << \"# of texcoords : \" << (attrib.texcoords.size() / 2)\n            << std::endl;\n\n  std::cout << \"# of shapes    : \" << shapes.size() << std::endl;\n  std::cout << \"# of materials : \" << materials.size() << std::endl;\n\n  for (size_t v = 0; v < attrib.vertices.size() / 3; v++) {\n    printf(\"  v[%ld] = (%f, %f, %f)\\n\", static_cast<long>(v),\n           static_cast<const double>(attrib.vertices[3 * v + 0]),\n           static_cast<const double>(attrib.vertices[3 * v + 1]),\n           static_cast<const double>(attrib.vertices[3 * v + 2]));\n  }\n\n  for (size_t v = 0; v < attrib.normals.size() / 3; v++) {\n    printf(\"  n[%ld] = (%f, %f, %f)\\n\", static_cast<long>(v),\n           static_cast<const double>(attrib.normals[3 * v + 0]),\n           static_cast<const double>(attrib.normals[3 * v + 1]),\n           static_cast<const double>(attrib.normals[3 * v + 2]));\n  }\n\n  for (size_t v = 0; v < attrib.texcoords.size() / 2; v++) {\n    printf(\"  uv[%ld] = (%f, %f)\\n\", static_cast<long>(v),\n           static_cast<const double>(attrib.texcoords[2 * v + 0]),\n           static_cast<const double>(attrib.texcoords[2 * v + 1]));\n  }\n\n  // For each shape\n  for (size_t i = 0; i < shapes.size(); i++) {\n    printf(\"shape[%ld].name = %s\\n\", static_cast<long>(i),\n           shapes[i].name.c_str());\n    printf(\"Size of shape[%ld].mesh.indices: %lu\\n\", static_cast<long>(i),\n           static_cast<unsigned long>(shapes[i].mesh.indices.size()));\n    printf(\"Size of shape[%ld].lines.indices: %lu\\n\", static_cast<long>(i),\n           static_cast<unsigned long>(shapes[i].lines.indices.size()));\n    printf(\"Size of shape[%ld].points.indices: %lu\\n\", static_cast<long>(i),\n           static_cast<unsigned long>(shapes[i].points.indices.size()));\n\n    size_t index_offset = 0;\n\n    assert(shapes[i].mesh.num_face_vertices.size() ==\n           shapes[i].mesh.material_ids.size());\n\n    assert(shapes[i].mesh.num_face_vertices.size() ==\n           shapes[i].mesh.smoothing_group_ids.size());\n\n    printf(\"shape[%ld].num_faces: %lu\\n\", static_cast<long>(i),\n           static_cast<unsigned long>(shapes[i].mesh.num_face_vertices.size()));\n\n    // For each face\n    for (size_t f = 0; f < shapes[i].mesh.num_face_vertices.size(); f++) {\n      size_t fnum = shapes[i].mesh.num_face_vertices[f];\n\n      printf(\"  face[%ld].fnum = %ld\\n\", static_cast<long>(f),\n             static_cast<unsigned long>(fnum));\n\n      // For each vertex in the face\n      for (size_t v = 0; v < fnum; v++) {\n        tinyobj::index_t idx = shapes[i].mesh.indices[index_offset + v];\n        printf(\"    face[%ld].v[%ld].idx = %d/%d/%d\\n\", static_cast<long>(f),\n               static_cast<long>(v), idx.vertex_index, idx.normal_index,\n               idx.texcoord_index);\n      }\n\n      printf(\"  face[%ld].material_id = %d\\n\", static_cast<long>(f),\n             shapes[i].mesh.material_ids[f]);\n      printf(\"  face[%ld].smoothing_group_id = %d\\n\", static_cast<long>(f),\n             shapes[i].mesh.smoothing_group_ids[f]);\n\n      index_offset += fnum;\n    }\n\n    printf(\"shape[%ld].num_tags: %lu\\n\", static_cast<long>(i),\n           static_cast<unsigned long>(shapes[i].mesh.tags.size()));\n    for (size_t t = 0; t < shapes[i].mesh.tags.size(); t++) {\n      printf(\"  tag[%ld] = %s \", static_cast<long>(t),\n             shapes[i].mesh.tags[t].name.c_str());\n      printf(\" ints: [\");\n      for (size_t j = 0; j < shapes[i].mesh.tags[t].intValues.size(); ++j) {\n        printf(\"%ld\", static_cast<long>(shapes[i].mesh.tags[t].intValues[j]));\n        if (j < (shapes[i].mesh.tags[t].intValues.size() - 1)) {\n          printf(\", \");\n        }\n      }\n      printf(\"]\");\n\n      printf(\" floats: [\");\n      for (size_t j = 0; j < shapes[i].mesh.tags[t].floatValues.size(); ++j) {\n        printf(\"%f\", static_cast<const double>(\n                         shapes[i].mesh.tags[t].floatValues[j]));\n        if (j < (shapes[i].mesh.tags[t].floatValues.size() - 1)) {\n          printf(\", \");\n        }\n      }\n      printf(\"]\");\n\n      printf(\" strings: [\");\n      for (size_t j = 0; j < shapes[i].mesh.tags[t].stringValues.size(); ++j) {\n        printf(\"%s\", shapes[i].mesh.tags[t].stringValues[j].c_str());\n        if (j < (shapes[i].mesh.tags[t].stringValues.size() - 1)) {\n          printf(\", \");\n        }\n      }\n      printf(\"]\");\n      printf(\"\\n\");\n    }\n  }\n\n  for (size_t i = 0; i < materials.size(); i++) {\n    printf(\"material[%ld].name = %s\\n\", static_cast<long>(i),\n           materials[i].name.c_str());\n    printf(\"  material.Ka = (%f, %f ,%f)\\n\",\n           static_cast<const double>(materials[i].ambient[0]),\n           static_cast<const double>(materials[i].ambient[1]),\n           static_cast<const double>(materials[i].ambient[2]));\n    printf(\"  material.Kd = (%f, %f ,%f)\\n\",\n           static_cast<const double>(materials[i].diffuse[0]),\n           static_cast<const double>(materials[i].diffuse[1]),\n           static_cast<const double>(materials[i].diffuse[2]));\n    printf(\"  material.Ks = (%f, %f ,%f)\\n\",\n           static_cast<const double>(materials[i].specular[0]),\n           static_cast<const double>(materials[i].specular[1]),\n           static_cast<const double>(materials[i].specular[2]));\n    printf(\"  material.Tr = (%f, %f ,%f)\\n\",\n           static_cast<const double>(materials[i].transmittance[0]),\n           static_cast<const double>(materials[i].transmittance[1]),\n           static_cast<const double>(materials[i].transmittance[2]));\n    printf(\"  material.Ke = (%f, %f ,%f)\\n\",\n           static_cast<const double>(materials[i].emission[0]),\n           static_cast<const double>(materials[i].emission[1]),\n           static_cast<const double>(materials[i].emission[2]));\n    printf(\"  material.Ns = %f\\n\",\n           static_cast<const double>(materials[i].shininess));\n    printf(\"  material.Ni = %f\\n\", static_cast<const double>(materials[i].ior));\n    printf(\"  material.dissolve = %f\\n\",\n           static_cast<const double>(materials[i].dissolve));\n    printf(\"  material.illum = %d\\n\", materials[i].illum);\n    printf(\"  material.map_Ka = %s\\n\", materials[i].ambient_texname.c_str());\n    printf(\"  material.map_Kd = %s\\n\", materials[i].diffuse_texname.c_str());\n    printf(\"  material.map_Ks = %s\\n\", materials[i].specular_texname.c_str());\n    printf(\"  material.map_Ns = %s\\n\",\n           materials[i].specular_highlight_texname.c_str());\n    printf(\"  material.map_bump = %s\\n\", materials[i].bump_texname.c_str());\n    printf(\"    bump_multiplier = %f\\n\", static_cast<const double>(materials[i].bump_texopt.bump_multiplier));\n    printf(\"  material.map_d = %s\\n\", materials[i].alpha_texname.c_str());\n    printf(\"  material.disp = %s\\n\", materials[i].displacement_texname.c_str());\n    printf(\"  <<PBR>>\\n\");\n    printf(\"  material.Pr     = %f\\n\", static_cast<const double>(materials[i].roughness));\n    printf(\"  material.Pm     = %f\\n\", static_cast<const double>(materials[i].metallic));\n    printf(\"  material.Ps     = %f\\n\", static_cast<const double>(materials[i].sheen));\n    printf(\"  material.Pc     = %f\\n\", static_cast<const double>(materials[i].clearcoat_thickness));\n    printf(\"  material.Pcr    = %f\\n\", static_cast<const double>(materials[i].clearcoat_roughness));\n    printf(\"  material.aniso  = %f\\n\", static_cast<const double>(materials[i].anisotropy));\n    printf(\"  material.anisor = %f\\n\", static_cast<const double>(materials[i].anisotropy_rotation));\n    printf(\"  material.map_Ke = %s\\n\", materials[i].emissive_texname.c_str());\n    printf(\"  material.map_Pr = %s\\n\", materials[i].roughness_texname.c_str());\n    printf(\"  material.map_Pm = %s\\n\", materials[i].metallic_texname.c_str());\n    printf(\"  material.map_Ps = %s\\n\", materials[i].sheen_texname.c_str());\n    printf(\"  material.norm   = %s\\n\", materials[i].normal_texname.c_str());\n    std::map<std::string, std::string>::const_iterator it(\n        materials[i].unknown_parameter.begin());\n    std::map<std::string, std::string>::const_iterator itEnd(\n        materials[i].unknown_parameter.end());\n\n    for (; it != itEnd; it++) {\n      printf(\"  material.%s = %s\\n\", it->first.c_str(), it->second.c_str());\n    }\n    printf(\"\\n\");\n  }\n}\n\nstatic bool TestLoadObj(const char* filename, const char* basepath = NULL,\n                        bool triangulate = true) {\n  std::cout << \"Loading \" << filename << std::endl;\n\n  tinyobj::attrib_t attrib;\n  std::vector<tinyobj::shape_t> shapes;\n  std::vector<tinyobj::material_t> materials;\n\n  timerutil t;\n  t.start();\n  std::string warn;\n  std::string err;\n  bool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, filename,\n                              basepath, triangulate);\n  t.end();\n  printf(\"Parsing time: %lu [msecs]\\n\", t.msec());\n\n  if (!warn.empty()) {\n    std::cout << \"WARN: \" << warn << std::endl;\n  }\n\n  if (!err.empty()) {\n    std::cerr << \"ERR: \" << err << std::endl;\n  }\n\n  if (!ret) {\n    printf(\"Failed to load/parse .obj.\\n\");\n    return false;\n  }\n\n  PrintInfo(attrib, shapes, materials);\n\n  return true;\n}\n\nstatic bool TestStreamLoadObj() {\n  std::cout << \"Stream Loading \" << std::endl;\n\n  std::stringstream objStream;\n  objStream << \"mtllib cube.mtl\\n\"\n               \"\\n\"\n               \"v 0.000000 2.000000 2.000000\\n\"\n               \"v 0.000000 0.000000 2.000000\\n\"\n               \"v 2.000000 0.000000 2.000000\\n\"\n               \"v 2.000000 2.000000 2.000000\\n\"\n               \"v 0.000000 2.000000 0.000000\\n\"\n               \"v 0.000000 0.000000 0.000000\\n\"\n               \"v 2.000000 0.000000 0.000000\\n\"\n               \"v 2.000000 2.000000 0.000000\\n\"\n               \"# 8 vertices\\n\"\n               \"\\n\"\n               \"g front cube\\n\"\n               \"usemtl white\\n\"\n               \"f 1 2 3 4\\n\"\n               \"g back cube\\n\"\n               \"# expects white material\\n\"\n               \"f 8 7 6 5\\n\"\n               \"g right cube\\n\"\n               \"usemtl red\\n\"\n               \"f 4 3 7 8\\n\"\n               \"g top cube\\n\"\n               \"usemtl white\\n\"\n               \"f 5 1 4 8\\n\"\n               \"g left cube\\n\"\n               \"usemtl green\\n\"\n               \"f 5 6 2 1\\n\"\n               \"g bottom cube\\n\"\n               \"usemtl white\\n\"\n               \"f 2 6 7 3\\n\"\n               \"# 6 elements\";\n\n  std::string matStream(\n      \"newmtl white\\n\"\n      \"Ka 0 0 0\\n\"\n      \"Kd 1 1 1\\n\"\n      \"Ks 0 0 0\\n\"\n      \"\\n\"\n      \"newmtl red\\n\"\n      \"Ka 0 0 0\\n\"\n      \"Kd 1 0 0\\n\"\n      \"Ks 0 0 0\\n\"\n      \"\\n\"\n      \"newmtl green\\n\"\n      \"Ka 0 0 0\\n\"\n      \"Kd 0 1 0\\n\"\n      \"Ks 0 0 0\\n\"\n      \"\\n\"\n      \"newmtl blue\\n\"\n      \"Ka 0 0 0\\n\"\n      \"Kd 0 0 1\\n\"\n      \"Ks 0 0 0\\n\"\n      \"\\n\"\n      \"newmtl light\\n\"\n      \"Ka 20 20 20\\n\"\n      \"Kd 1 1 1\\n\"\n      \"Ks 0 0 0\");\n\n  using namespace tinyobj;\n  class MaterialStringStreamReader : public MaterialReader {\n   public:\n    MaterialStringStreamReader(const std::string& matSStream)\n        : m_matSStream(matSStream) {}\n    virtual ~MaterialStringStreamReader() TINYOBJ_OVERRIDE {}\n    virtual bool operator()(const std::string& matId,\n                            std::vector<material_t>* materials,\n                            std::map<std::string, int>* matMap,\n                            std::string* warn,\n                            std::string* err) TINYOBJ_OVERRIDE {\n      (void)err;\n      (void)matId;\n      LoadMtl(matMap, materials, &m_matSStream, warn, err);\n\n      return true;\n    }\n\n   private:\n    std::stringstream m_matSStream;\n  };\n\n  MaterialStringStreamReader matSSReader(matStream);\n  tinyobj::attrib_t attrib;\n  std::vector<tinyobj::shape_t> shapes;\n  std::vector<tinyobj::material_t> materials;\n  std::string warn;\n  std::string err;\n  bool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, &objStream,\n                              &matSSReader);\n\n  if (!err.empty()) {\n    std::cerr << err << std::endl;\n  }\n\n  if (!ret) {\n    return false;\n  }\n\n  PrintInfo(attrib, shapes, materials);\n\n  return true;\n}\n\nint main(int argc, char** argv) {\n  if (argc > 1) {\n    const char* basepath = \"models/\";\n    if (argc > 2) {\n      basepath = argv[2];\n    }\n    assert(true == TestLoadObj(argv[1], basepath));\n  } else {\n    // assert(true == TestLoadObj(\"cornell_box.obj\"));\n    // assert(true == TestLoadObj(\"cube.obj\"));\n    assert(true == TestStreamLoadObj());\n    assert(true ==\n           TestLoadObj(\"models/catmark_torus_creases0.obj\", \"models/\", false));\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "mapbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "models",
          "type": "tree",
          "content": null
        },
        {
          "name": "pbr-mtl.md",
          "type": "blob",
          "size": 0.8095703125,
          "content": "## PBR material extension.\n\nThe spec can be found in either\n\nhttps://benhouston3d.com/blog/extended-wavefront-obj-mtl-for-pbr/\n\nor Internet Archive: https://web.archive.org/web/20230210121526/http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr\n\n* Kd/map_Kd (base/diffuse) // reuse\n* Ks/map_Ks (specular) // reuse\n* d or Tr (opacity) // reuse\n* map_d/map_Tr (opacitymap) // reuse\n* Tf (translucency) // reuse\n* bump/-bm (bump map) // reuse\n* disp (displacement map) // reuse\n\nPBR material parameters as defined by the Disney PBR.\n\n* Pr/map_Pr (roughness) // new\n* Pm/map_Pm (metallic) // new\n* Ps/map_Ps (sheen) // new\n* Pc (clearcoat thickness) // new\n* Pcr (clearcoat roughness) // new\n* Ke/map_Ke (emissive) // new\n* aniso (anisotropy) // new\n* anisor (anisotropy rotation) // new\n* norm (normal map) // new\n\nEoL.\n"
        },
        {
          "name": "premake4.lua",
          "type": "blob",
          "size": 0.669921875,
          "content": "sources = {\n   \"loader_example.cc\",\n   }\n\n-- premake4.lua\nsolution \"TinyObjLoaderSolution\"\n   configurations { \"Release\", \"Debug\" }\n\n   if (os.is(\"windows\")) then\n      platforms { \"x32\", \"x64\" }\n   else\n      platforms { \"native\", \"x32\", \"x64\" }\n   end\n\n   -- A project defines one build target\n   project \"tinyobjloader\"\n      kind \"ConsoleApp\"\n      language \"C++\"\n      files { sources }\n\n      configuration \"Debug\"\n         defines { \"DEBUG\" } -- -DDEBUG\n         flags { \"Symbols\" }\n         targetname \"loader_example_debug\"\n\n      configuration \"Release\"\n         -- defines { \"NDEBUG\" } -- -NDEBUG\n         flags { \"Symbols\", \"Optimize\" }\n         targetname \"loader_example\"\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.8173828125,
          "content": "[build-system]\n\nrequires = [\n    # NOTE: setuptools_scm>=8 is not supported in py3.6 cibuildwheel env.\n    # so use older setuptools_scm for a while\n    #\"setuptools>=64\",\n    #\"setuptools_scm>=8\",\n    \"setuptools>=45\",\n    \"setuptools_scm[toml]<8\",\n    \"wheel\",\n    \"pybind11>=2.10.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 140\n\n[project]\nname = \"tinyobjloader\"\n\n# version: Use setuptools_scm\ndynamic = [\"version\", \"classifiers\", \"authors\", \"description\"]\n\n\nreadme = {file = \"README.md\", content-type = \"text/markdown\"}\n\n# Project URLs in pyproject.toml is not mature.\n# so write it to setup.py\n# https://github.com/pypa/packaging-problems/issues/606\n#\n# [project.urils]\n\n\n[tool.setuptools_scm]\n# setuptools_scm>=8\n#version_file = \"python/_version.py\"\n\n# setuptools_scm<8\nwrite_to = \"python/_version.py\"\n"
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.44140625,
          "content": "# Adapted from https://github.com/pybind/python_example/blob/master/setup.py\nimport sys\n\n#from pybind11 import get_cmake_dir\n# Available at setup time due to pyproject.toml\nfrom pybind11.setup_helpers import Pybind11Extension#, build_ext\nfrom setuptools import setup\n\ntry:\n    # try to read setuptools_scm generated _version.py\n    from .python import _version\nexcept:\n    __version__ = \"2.0.0rc10\"\n\nwith open(\"README.md\", \"r\", encoding=\"utf8\") as fh:\n    long_description = fh.read()\n\n# The main interface is through Pybind11Extension.\n# * You can add cxx_std=11/14/17, and then build_ext can be removed.\n# * You can set include_pybind11=false to add the include directory yourself,\n#   say from a submodule.\n#\n# Note:\n#   Sort input source files if you glob sources to ensure bit-for-bit\n#   reproducible builds (https://github.com/pybind/python_example/pull/53)\n\next_modules = [\n    Pybind11Extension(\"tinyobjloader\",\n        sorted([\"python/bindings.cc\", \"python/tiny_obj_loader.cc\"]),\n        # Example: passing in the version to the compiled code\n        define_macros = [('VERSION_INFO', __version__)],\n        cxx_std=11,\n        ),\n]\n\nsetup(\n    name=\"tinyobjloader\",\n    packages=['python'],\n    #version=__version__,\n    author=\"Syoyo Fujita\",\n    author_email=\"syoyo@lighttransport.com\",\n    url=\"https://github.com/tinyobjloader/tinyobjloader\",\n    #project_urls={\n    #    \"Issue Tracker\": \"https://github.com/tinyobjloader/tinyobjloader/issues\",\n    #},\n    description=\"Tiny but powerful Wavefront OBJ loader\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Manufacturing\",\n        \"Topic :: Artistic Software\",\n        \"Topic :: Multimedia :: Graphics :: 3D Modeling\",\n        \"Topic :: Scientific/Engineering :: Visualization\",\n        \"License :: OSI Approved :: MIT License\",\n        \"License :: OSI Approved :: ISC License (ISCL)\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3\",\n    ],\n    ext_modules=ext_modules,\n    #extras_require={\"test\": \"pytest\"},\n    # Currently, build_ext only provides an optional \"highest supported C++\n    # level\" feature, but in the future it may provide more features.\n    # cmdclass={\"build_ext\": build_ext},\n    #zip_safe=False,\n    #python_requires=\">=3.6\",\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tiny_obj_loader.cc",
          "type": "blob",
          "size": 0.064453125,
          "content": "#define TINYOBJLOADER_IMPLEMENTATION\n#include \"tiny_obj_loader.h\"\n"
        },
        {
          "name": "tiny_obj_loader.h",
          "type": "blob",
          "size": 105.228515625,
          "content": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2012-Present, Syoyo Fujita and many contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n//\n// version 2.0.0 : Add new object oriented API. 1.x API is still provided.\n//                 * Add python binding.\n//                 * Support line primitive.\n//                 * Support points primitive.\n//                 * Support multiple search path for .mtl(v1 API).\n//                 * Support vertex skinning weight `vw`(as an tinyobj\n//                 extension). Note that this differs vertex weight([w]\n//                 component in `v` line)\n//                 * Support escaped whitespece in mtllib\n//                 * Add robust triangulation using Mapbox\n//                 earcut(TINYOBJLOADER_USE_MAPBOX_EARCUT).\n// version 1.4.0 : Modifed ParseTextureNameAndOption API\n// version 1.3.1 : Make ParseTextureNameAndOption API public\n// version 1.3.0 : Separate warning and error message(breaking API of LoadObj)\n// version 1.2.3 : Added color space extension('-colorspace') to tex opts.\n// version 1.2.2 : Parse multiple group names.\n// version 1.2.1 : Added initial support for line('l') primitive(PR #178)\n// version 1.2.0 : Hardened implementation(#175)\n// version 1.1.1 : Support smoothing groups(#162)\n// version 1.1.0 : Support parsing vertex color(#144)\n// version 1.0.8 : Fix parsing `g` tag just after `usemtl`(#138)\n// version 1.0.7 : Support multiple tex options(#126)\n// version 1.0.6 : Add TINYOBJLOADER_USE_DOUBLE option(#124)\n// version 1.0.5 : Ignore `Tr` when `d` exists in MTL(#43)\n// version 1.0.4 : Support multiple filenames for 'mtllib'(#112)\n// version 1.0.3 : Support parsing texture options(#85)\n// version 1.0.2 : Improve parsing speed by about a factor of 2 for large\n// files(#105)\n// version 1.0.1 : Fixes a shape is lost if obj ends with a 'usemtl'(#104)\n// version 1.0.0 : Change data structure. Change license from BSD to MIT.\n//\n\n//\n// Use this in *one* .cc\n//   #define TINYOBJLOADER_IMPLEMENTATION\n//   #include \"tiny_obj_loader.h\"\n//\n\n#ifndef TINY_OBJ_LOADER_H_\n#define TINY_OBJ_LOADER_H_\n\n#include <map>\n#include <string>\n#include <vector>\n\nnamespace tinyobj {\n\n// TODO(syoyo): Better C++11 detection for older compiler\n#if __cplusplus > 199711L\n#define TINYOBJ_OVERRIDE override\n#else\n#define TINYOBJ_OVERRIDE\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#pragma clang diagnostic ignored \"-Wpadded\"\n\n#endif\n\n// https://en.wikipedia.org/wiki/Wavefront_.obj_file says ...\n//\n//  -blendu on | off                       # set horizontal texture blending\n//  (default on)\n//  -blendv on | off                       # set vertical texture blending\n//  (default on)\n//  -boost real_value                      # boost mip-map sharpness\n//  -mm base_value gain_value              # modify texture map values (default\n//  0 1)\n//                                         #     base_value = brightness,\n//                                         gain_value = contrast\n//  -o u [v [w]]                           # Origin offset             (default\n//  0 0 0)\n//  -s u [v [w]]                           # Scale                     (default\n//  1 1 1)\n//  -t u [v [w]]                           # Turbulence                (default\n//  0 0 0)\n//  -texres resolution                     # texture resolution to create\n//  -clamp on | off                        # only render texels in the clamped\n//  0-1 range (default off)\n//                                         #   When unclamped, textures are\n//                                         repeated across a surface,\n//                                         #   when clamped, only texels which\n//                                         fall within the 0-1\n//                                         #   range are rendered.\n//  -bm mult_value                         # bump multiplier (for bump maps\n//  only)\n//\n//  -imfchan r | g | b | m | l | z         # specifies which channel of the file\n//  is used to\n//                                         # create a scalar or bump texture.\n//                                         r:red, g:green,\n//                                         # b:blue, m:matte, l:luminance,\n//                                         z:z-depth..\n//                                         # (the default for bump is 'l' and\n//                                         for decal is 'm')\n//  bump -imfchan r bumpmap.tga            # says to use the red channel of\n//  bumpmap.tga as the bumpmap\n//\n// For reflection maps...\n//\n//   -type sphere                           # specifies a sphere for a \"refl\"\n//   reflection map\n//   -type cube_top    | cube_bottom |      # when using a cube map, the texture\n//   file for each\n//         cube_front  | cube_back   |      # side of the cube is specified\n//         separately\n//         cube_left   | cube_right\n//\n// TinyObjLoader extension.\n//\n//   -colorspace SPACE                      # Color space of the texture. e.g.\n//   'sRGB` or 'linear'\n//\n\n#ifdef TINYOBJLOADER_USE_DOUBLE\n//#pragma message \"using double\"\ntypedef double real_t;\n#else\n//#pragma message \"using float\"\ntypedef float real_t;\n#endif\n\ntypedef enum {\n  TEXTURE_TYPE_NONE,  // default\n  TEXTURE_TYPE_SPHERE,\n  TEXTURE_TYPE_CUBE_TOP,\n  TEXTURE_TYPE_CUBE_BOTTOM,\n  TEXTURE_TYPE_CUBE_FRONT,\n  TEXTURE_TYPE_CUBE_BACK,\n  TEXTURE_TYPE_CUBE_LEFT,\n  TEXTURE_TYPE_CUBE_RIGHT\n} texture_type_t;\n\nstruct texture_option_t {\n  texture_type_t type;      // -type (default TEXTURE_TYPE_NONE)\n  real_t sharpness;         // -boost (default 1.0?)\n  real_t brightness;        // base_value in -mm option (default 0)\n  real_t contrast;          // gain_value in -mm option (default 1)\n  real_t origin_offset[3];  // -o u [v [w]] (default 0 0 0)\n  real_t scale[3];          // -s u [v [w]] (default 1 1 1)\n  real_t turbulence[3];     // -t u [v [w]] (default 0 0 0)\n  int texture_resolution;   // -texres resolution (No default value in the spec.\n                            // We'll use -1)\n  bool clamp;               // -clamp (default false)\n  char imfchan;  // -imfchan (the default for bump is 'l' and for decal is 'm')\n  bool blendu;   // -blendu (default on)\n  bool blendv;   // -blendv (default on)\n  real_t bump_multiplier;  // -bm (for bump maps only, default 1.0)\n\n  // extension\n  std::string colorspace;  // Explicitly specify color space of stored texel\n                           // value. Usually `sRGB` or `linear` (default empty).\n};\n\nstruct material_t {\n  std::string name;\n\n  real_t ambient[3];\n  real_t diffuse[3];\n  real_t specular[3];\n  real_t transmittance[3];\n  real_t emission[3];\n  real_t shininess;\n  real_t ior;       // index of refraction\n  real_t dissolve;  // 1 == opaque; 0 == fully transparent\n  // illumination model (see http://www.fileformat.info/format/material/)\n  int illum;\n\n  int dummy;  // Suppress padding warning.\n\n  std::string ambient_texname;   // map_Ka. For ambient or ambient occlusion.\n  std::string diffuse_texname;   // map_Kd\n  std::string specular_texname;  // map_Ks\n  std::string specular_highlight_texname;  // map_Ns\n  std::string bump_texname;                // map_bump, map_Bump, bump\n  std::string displacement_texname;        // disp\n  std::string alpha_texname;               // map_d\n  std::string reflection_texname;          // refl\n\n  texture_option_t ambient_texopt;\n  texture_option_t diffuse_texopt;\n  texture_option_t specular_texopt;\n  texture_option_t specular_highlight_texopt;\n  texture_option_t bump_texopt;\n  texture_option_t displacement_texopt;\n  texture_option_t alpha_texopt;\n  texture_option_t reflection_texopt;\n\n  // PBR extension\n  // http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr\n  real_t roughness;            // [0, 1] default 0\n  real_t metallic;             // [0, 1] default 0\n  real_t sheen;                // [0, 1] default 0\n  real_t clearcoat_thickness;  // [0, 1] default 0\n  real_t clearcoat_roughness;  // [0, 1] default 0\n  real_t anisotropy;           // aniso. [0, 1] default 0\n  real_t anisotropy_rotation;  // anisor. [0, 1] default 0\n  real_t pad0;\n  std::string roughness_texname;  // map_Pr\n  std::string metallic_texname;   // map_Pm\n  std::string sheen_texname;      // map_Ps\n  std::string emissive_texname;   // map_Ke\n  std::string normal_texname;     // norm. For normal mapping.\n\n  texture_option_t roughness_texopt;\n  texture_option_t metallic_texopt;\n  texture_option_t sheen_texopt;\n  texture_option_t emissive_texopt;\n  texture_option_t normal_texopt;\n\n  int pad2;\n\n  std::map<std::string, std::string> unknown_parameter;\n\n#ifdef TINY_OBJ_LOADER_PYTHON_BINDING\n  // For pybind11\n  std::array<double, 3> GetDiffuse() {\n    std::array<double, 3> values;\n    values[0] = double(diffuse[0]);\n    values[1] = double(diffuse[1]);\n    values[2] = double(diffuse[2]);\n\n    return values;\n  }\n\n  std::array<double, 3> GetSpecular() {\n    std::array<double, 3> values;\n    values[0] = double(specular[0]);\n    values[1] = double(specular[1]);\n    values[2] = double(specular[2]);\n\n    return values;\n  }\n\n  std::array<double, 3> GetTransmittance() {\n    std::array<double, 3> values;\n    values[0] = double(transmittance[0]);\n    values[1] = double(transmittance[1]);\n    values[2] = double(transmittance[2]);\n\n    return values;\n  }\n\n  std::array<double, 3> GetEmission() {\n    std::array<double, 3> values;\n    values[0] = double(emission[0]);\n    values[1] = double(emission[1]);\n    values[2] = double(emission[2]);\n\n    return values;\n  }\n\n  std::array<double, 3> GetAmbient() {\n    std::array<double, 3> values;\n    values[0] = double(ambient[0]);\n    values[1] = double(ambient[1]);\n    values[2] = double(ambient[2]);\n\n    return values;\n  }\n\n  void SetDiffuse(std::array<double, 3> &a) {\n    diffuse[0] = real_t(a[0]);\n    diffuse[1] = real_t(a[1]);\n    diffuse[2] = real_t(a[2]);\n  }\n\n  void SetAmbient(std::array<double, 3> &a) {\n    ambient[0] = real_t(a[0]);\n    ambient[1] = real_t(a[1]);\n    ambient[2] = real_t(a[2]);\n  }\n\n  void SetSpecular(std::array<double, 3> &a) {\n    specular[0] = real_t(a[0]);\n    specular[1] = real_t(a[1]);\n    specular[2] = real_t(a[2]);\n  }\n\n  void SetTransmittance(std::array<double, 3> &a) {\n    transmittance[0] = real_t(a[0]);\n    transmittance[1] = real_t(a[1]);\n    transmittance[2] = real_t(a[2]);\n  }\n\n  std::string GetCustomParameter(const std::string &key) {\n    std::map<std::string, std::string>::const_iterator it =\n        unknown_parameter.find(key);\n\n    if (it != unknown_parameter.end()) {\n      return it->second;\n    }\n    return std::string();\n  }\n\n#endif\n};\n\nstruct tag_t {\n  std::string name;\n\n  std::vector<int> intValues;\n  std::vector<real_t> floatValues;\n  std::vector<std::string> stringValues;\n};\n\nstruct joint_and_weight_t {\n  int joint_id;\n  real_t weight;\n};\n\nstruct skin_weight_t {\n  int vertex_id;  // Corresponding vertex index in `attrib_t::vertices`.\n                  // Compared to `index_t`, this index must be positive and\n                  // start with 0(does not allow relative indexing)\n  std::vector<joint_and_weight_t> weightValues;\n};\n\n// Index struct to support different indices for vtx/normal/texcoord.\n// -1 means not used.\nstruct index_t {\n  int vertex_index;\n  int normal_index;\n  int texcoord_index;\n};\n\nstruct mesh_t {\n  std::vector<index_t> indices;\n  std::vector<unsigned int>\n      num_face_vertices;          // The number of vertices per\n                                  // face. 3 = triangle, 4 = quad, ...\n  std::vector<int> material_ids;  // per-face material ID\n  std::vector<unsigned int> smoothing_group_ids;  // per-face smoothing group\n                                                  // ID(0 = off. positive value\n                                                  // = group id)\n  std::vector<tag_t> tags;                        // SubD tag\n};\n\n// struct path_t {\n//  std::vector<int> indices;  // pairs of indices for lines\n//};\n\nstruct lines_t {\n  // Linear flattened indices.\n  std::vector<index_t> indices;        // indices for vertices(poly lines)\n  std::vector<int> num_line_vertices;  // The number of vertices per line.\n};\n\nstruct points_t {\n  std::vector<index_t> indices;  // indices for points\n};\n\nstruct shape_t {\n  std::string name;\n  mesh_t mesh;\n  lines_t lines;\n  points_t points;\n};\n\n// Vertex attributes\nstruct attrib_t {\n  std::vector<real_t> vertices;  // 'v'(xyz)\n\n  // For backward compatibility, we store vertex weight in separate array.\n  std::vector<real_t> vertex_weights;  // 'v'(w)\n  std::vector<real_t> normals;         // 'vn'\n  std::vector<real_t> texcoords;       // 'vt'(uv)\n\n  // For backward compatibility, we store texture coordinate 'w' in separate\n  // array.\n  std::vector<real_t> texcoord_ws;  // 'vt'(w)\n  std::vector<real_t> colors;       // extension: vertex colors\n\n  //\n  // TinyObj extension.\n  //\n\n  // NOTE(syoyo): array index is based on the appearance order.\n  // To get a corresponding skin weight for a specific vertex id `vid`,\n  // Need to reconstruct a look up table: `skin_weight_t::vertex_id` == `vid`\n  // (e.g. using std::map, std::unordered_map)\n  std::vector<skin_weight_t> skin_weights;\n\n  attrib_t() {}\n\n  //\n  // For pybind11\n  //\n  const std::vector<real_t> &GetVertices() const { return vertices; }\n\n  const std::vector<real_t> &GetVertexWeights() const { return vertex_weights; }\n};\n\nstruct callback_t {\n  // W is optional and set to 1 if there is no `w` item in `v` line\n  void (*vertex_cb)(void *user_data, real_t x, real_t y, real_t z, real_t w);\n  void (*vertex_color_cb)(void *user_data, real_t x, real_t y, real_t z,\n                          real_t r, real_t g, real_t b, bool has_color);\n  void (*normal_cb)(void *user_data, real_t x, real_t y, real_t z);\n\n  // y and z are optional and set to 0 if there is no `y` and/or `z` item(s) in\n  // `vt` line.\n  void (*texcoord_cb)(void *user_data, real_t x, real_t y, real_t z);\n\n  // called per 'f' line. num_indices is the number of face indices(e.g. 3 for\n  // triangle, 4 for quad)\n  // 0 will be passed for undefined index in index_t members.\n  void (*index_cb)(void *user_data, index_t *indices, int num_indices);\n  // `name` material name, `material_id` = the array index of material_t[]. -1\n  // if\n  // a material not found in .mtl\n  void (*usemtl_cb)(void *user_data, const char *name, int material_id);\n  // `materials` = parsed material data.\n  void (*mtllib_cb)(void *user_data, const material_t *materials,\n                    int num_materials);\n  // There may be multiple group names\n  void (*group_cb)(void *user_data, const char **names, int num_names);\n  void (*object_cb)(void *user_data, const char *name);\n\n  callback_t()\n      : vertex_cb(NULL),\n        vertex_color_cb(NULL),\n        normal_cb(NULL),\n        texcoord_cb(NULL),\n        index_cb(NULL),\n        usemtl_cb(NULL),\n        mtllib_cb(NULL),\n        group_cb(NULL),\n        object_cb(NULL) {}\n};\n\nclass MaterialReader {\n public:\n  MaterialReader() {}\n  virtual ~MaterialReader();\n\n  virtual bool operator()(const std::string &matId,\n                          std::vector<material_t> *materials,\n                          std::map<std::string, int> *matMap, std::string *warn,\n                          std::string *err) = 0;\n};\n\n///\n/// Read .mtl from a file.\n///\nclass MaterialFileReader : public MaterialReader {\n public:\n  // Path could contain separator(';' in Windows, ':' in Posix)\n  explicit MaterialFileReader(const std::string &mtl_basedir)\n      : m_mtlBaseDir(mtl_basedir) {}\n  virtual ~MaterialFileReader() TINYOBJ_OVERRIDE {}\n  virtual bool operator()(const std::string &matId,\n                          std::vector<material_t> *materials,\n                          std::map<std::string, int> *matMap, std::string *warn,\n                          std::string *err) TINYOBJ_OVERRIDE;\n\n private:\n  std::string m_mtlBaseDir;\n};\n\n///\n/// Read .mtl from a stream.\n///\nclass MaterialStreamReader : public MaterialReader {\n public:\n  explicit MaterialStreamReader(std::istream &inStream)\n      : m_inStream(inStream) {}\n  virtual ~MaterialStreamReader() TINYOBJ_OVERRIDE {}\n  virtual bool operator()(const std::string &matId,\n                          std::vector<material_t> *materials,\n                          std::map<std::string, int> *matMap, std::string *warn,\n                          std::string *err) TINYOBJ_OVERRIDE;\n\n private:\n  std::istream &m_inStream;\n};\n\n// v2 API\nstruct ObjReaderConfig {\n  bool triangulate;  // triangulate polygon?\n\n  // Currently not used.\n  // \"simple\" or empty: Create triangle fan\n  // \"earcut\": Use the algorithm based on Ear clipping\n  std::string triangulation_method;\n\n  /// Parse vertex color.\n  /// If vertex color is not present, its filled with default value.\n  /// false = no vertex color\n  /// This will increase memory of parsed .obj\n  bool vertex_color;\n\n  ///\n  /// Search path to .mtl file.\n  /// Default = \"\" = search from the same directory of .obj file.\n  /// Valid only when loading .obj from a file.\n  ///\n  std::string mtl_search_path;\n\n  ObjReaderConfig()\n      : triangulate(true), triangulation_method(\"simple\"), vertex_color(true) {}\n};\n\n///\n/// Wavefront .obj reader class(v2 API)\n///\nclass ObjReader {\n public:\n  ObjReader() : valid_(false) {}\n\n  ///\n  /// Load .obj and .mtl from a file.\n  ///\n  /// @param[in] filename wavefront .obj filename\n  /// @param[in] config Reader configuration\n  ///\n  bool ParseFromFile(const std::string &filename,\n                     const ObjReaderConfig &config = ObjReaderConfig());\n\n  ///\n  /// Parse .obj from a text string.\n  /// Need to supply .mtl text string by `mtl_text`.\n  /// This function ignores `mtllib` line in .obj text.\n  ///\n  /// @param[in] obj_text wavefront .obj filename\n  /// @param[in] mtl_text wavefront .mtl filename\n  /// @param[in] config Reader configuration\n  ///\n  bool ParseFromString(const std::string &obj_text, const std::string &mtl_text,\n                       const ObjReaderConfig &config = ObjReaderConfig());\n\n  ///\n  /// .obj was loaded or parsed correctly.\n  ///\n  bool Valid() const { return valid_; }\n\n  const attrib_t &GetAttrib() const { return attrib_; }\n\n  const std::vector<shape_t> &GetShapes() const { return shapes_; }\n\n  const std::vector<material_t> &GetMaterials() const { return materials_; }\n\n  ///\n  /// Warning message(may be filled after `Load` or `Parse`)\n  ///\n  const std::string &Warning() const { return warning_; }\n\n  ///\n  /// Error message(filled when `Load` or `Parse` failed)\n  ///\n  const std::string &Error() const { return error_; }\n\n private:\n  bool valid_;\n\n  attrib_t attrib_;\n  std::vector<shape_t> shapes_;\n  std::vector<material_t> materials_;\n\n  std::string warning_;\n  std::string error_;\n};\n\n/// ==>>========= Legacy v1 API =============================================\n\n/// Loads .obj from a file.\n/// 'attrib', 'shapes' and 'materials' will be filled with parsed shape data\n/// 'shapes' will be filled with parsed shape data\n/// Returns true when loading .obj become success.\n/// Returns warning message into `warn`, and error message into `err`\n/// 'mtl_basedir' is optional, and used for base directory for .mtl file.\n/// In default(`NULL'), .mtl file is searched from an application's working\n/// directory.\n/// 'triangulate' is optional, and used whether triangulate polygon face in .obj\n/// or not.\n/// Option 'default_vcols_fallback' specifies whether vertex colors should\n/// always be defined, even if no colors are given (fallback to white).\nbool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,\n             std::vector<material_t> *materials, std::string *warn,\n             std::string *err, const char *filename,\n             const char *mtl_basedir = NULL, bool triangulate = true,\n             bool default_vcols_fallback = true);\n\n/// Loads .obj from a file with custom user callback.\n/// .mtl is loaded as usual and parsed material_t data will be passed to\n/// `callback.mtllib_cb`.\n/// Returns true when loading .obj/.mtl become success.\n/// Returns warning message into `warn`, and error message into `err`\n/// See `examples/callback_api/` for how to use this function.\nbool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,\n                         void *user_data = NULL,\n                         MaterialReader *readMatFn = NULL,\n                         std::string *warn = NULL, std::string *err = NULL);\n\n/// Loads object from a std::istream, uses `readMatFn` to retrieve\n/// std::istream for materials.\n/// Returns true when loading .obj become success.\n/// Returns warning and error message into `err`\nbool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,\n             std::vector<material_t> *materials, std::string *warn,\n             std::string *err, std::istream *inStream,\n             MaterialReader *readMatFn = NULL, bool triangulate = true,\n             bool default_vcols_fallback = true);\n\n/// Loads materials into std::map\nvoid LoadMtl(std::map<std::string, int> *material_map,\n             std::vector<material_t> *materials, std::istream *inStream,\n             std::string *warning, std::string *err);\n\n///\n/// Parse texture name and texture option for custom texture parameter through\n/// material::unknown_parameter\n///\n/// @param[out] texname Parsed texture name\n/// @param[out] texopt Parsed texopt\n/// @param[in] linebuf Input string\n///\nbool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,\n                               const char *linebuf);\n\n/// =<<========== Legacy v1 API =============================================\n\n}  // namespace tinyobj\n\n#endif  // TINY_OBJ_LOADER_H_\n\n#ifdef TINYOBJLOADER_IMPLEMENTATION\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <limits>\n#include <set>\n#include <sstream>\n#include <utility>\n\n#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT\n\n#ifdef TINYOBJLOADER_DONOT_INCLUDE_MAPBOX_EARCUT\n// Assume earcut.hpp is included outside of tiny_obj_loader.h\n#else\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Weverything\"\n#endif\n\n#include <array>\n\n#include \"mapbox/earcut.hpp\"\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif\n\n#endif  // TINYOBJLOADER_USE_MAPBOX_EARCUT\n\nnamespace tinyobj {\n\nMaterialReader::~MaterialReader() {}\n\nstruct vertex_index_t {\n  int v_idx, vt_idx, vn_idx;\n  vertex_index_t() : v_idx(-1), vt_idx(-1), vn_idx(-1) {}\n  explicit vertex_index_t(int idx) : v_idx(idx), vt_idx(idx), vn_idx(idx) {}\n  vertex_index_t(int vidx, int vtidx, int vnidx)\n      : v_idx(vidx), vt_idx(vtidx), vn_idx(vnidx) {}\n};\n\n// Internal data structure for face representation\n// index + smoothing group.\nstruct face_t {\n  unsigned int\n      smoothing_group_id;  // smoothing group id. 0 = smoothing groupd is off.\n  int pad_;\n  std::vector<vertex_index_t> vertex_indices;  // face vertex indices.\n\n  face_t() : smoothing_group_id(0), pad_(0) {}\n};\n\n// Internal data structure for line representation\nstruct __line_t {\n  // l v1/vt1 v2/vt2 ...\n  // In the specification, line primitrive does not have normal index, but\n  // TinyObjLoader allow it\n  std::vector<vertex_index_t> vertex_indices;\n};\n\n// Internal data structure for points representation\nstruct __points_t {\n  // p v1 v2 ...\n  // In the specification, point primitrive does not have normal index and\n  // texture coord index, but TinyObjLoader allow it.\n  std::vector<vertex_index_t> vertex_indices;\n};\n\nstruct tag_sizes {\n  tag_sizes() : num_ints(0), num_reals(0), num_strings(0) {}\n  int num_ints;\n  int num_reals;\n  int num_strings;\n};\n\nstruct obj_shape {\n  std::vector<real_t> v;\n  std::vector<real_t> vn;\n  std::vector<real_t> vt;\n};\n\n//\n// Manages group of primitives(face, line, points, ...)\nstruct PrimGroup {\n  std::vector<face_t> faceGroup;\n  std::vector<__line_t> lineGroup;\n  std::vector<__points_t> pointsGroup;\n\n  void clear() {\n    faceGroup.clear();\n    lineGroup.clear();\n    pointsGroup.clear();\n  }\n\n  bool IsEmpty() const {\n    return faceGroup.empty() && lineGroup.empty() && pointsGroup.empty();\n  }\n\n  // TODO(syoyo): bspline, surface, ...\n};\n\n// See\n// http://stackoverflow.com/questions/6089231/getting-std-ifstream-to-handle-lf-cr-and-crlf\nstatic std::istream &safeGetline(std::istream &is, std::string &t) {\n  t.clear();\n\n  // The characters in the stream are read one-by-one using a std::streambuf.\n  // That is faster than reading them one-by-one using the std::istream.\n  // Code that uses streambuf this way must be guarded by a sentry object.\n  // The sentry object performs various tasks,\n  // such as thread synchronization and updating the stream state.\n\n  std::istream::sentry se(is, true);\n  std::streambuf *sb = is.rdbuf();\n\n  if (se) {\n    for (;;) {\n      int c = sb->sbumpc();\n      switch (c) {\n        case '\\n':\n          return is;\n        case '\\r':\n          if (sb->sgetc() == '\\n') sb->sbumpc();\n          return is;\n        case EOF:\n          // Also handle the case when the last line has no line ending\n          if (t.empty()) is.setstate(std::ios::eofbit);\n          return is;\n        default:\n          t += static_cast<char>(c);\n      }\n    }\n  }\n\n  return is;\n}\n\n#define IS_SPACE(x) (((x) == ' ') || ((x) == '\\t'))\n#define IS_DIGIT(x) \\\n  (static_cast<unsigned int>((x) - '0') < static_cast<unsigned int>(10))\n#define IS_NEW_LINE(x) (((x) == '\\r') || ((x) == '\\n') || ((x) == '\\0'))\n\ntemplate <typename T>\nstatic inline std::string toString(const T &t) {\n  std::stringstream ss;\n  ss << t;\n  return ss.str();\n}\n\nstruct warning_context {\n  std::string *warn;\n  size_t line_number;\n};\n\n// Make index zero-base, and also support relative index.\nstatic inline bool fixIndex(int idx, int n, int *ret, bool allow_zero,\n                            const warning_context &context) {\n  if (!ret) {\n    return false;\n  }\n\n  if (idx > 0) {\n    (*ret) = idx - 1;\n    return true;\n  }\n\n  if (idx == 0) {\n    // zero is not allowed according to the spec.\n    if (context.warn) {\n      (*context.warn) +=\n          \"A zero value index found (will have a value of -1 for normal and \"\n          \"tex indices. Line \" +\n          toString(context.line_number) + \").\\n\";\n    }\n\n    (*ret) = idx - 1;\n    return allow_zero;\n  }\n\n  if (idx < 0) {\n    (*ret) = n + idx;  // negative value = relative\n    if ((*ret) < 0) {\n      return false;  // invalid relative index\n    }\n    return true;\n  }\n\n  return false;  // never reach here.\n}\n\nstatic inline std::string parseString(const char **token) {\n  std::string s;\n  (*token) += strspn((*token), \" \\t\");\n  size_t e = strcspn((*token), \" \\t\\r\");\n  s = std::string((*token), &(*token)[e]);\n  (*token) += e;\n  return s;\n}\n\nstatic inline int parseInt(const char **token) {\n  (*token) += strspn((*token), \" \\t\");\n  int i = atoi((*token));\n  (*token) += strcspn((*token), \" \\t\\r\");\n  return i;\n}\n\n// Tries to parse a floating point number located at s.\n//\n// s_end should be a location in the string where reading should absolutely\n// stop. For example at the end of the string, to prevent buffer overflows.\n//\n// Parses the following EBNF grammar:\n//   sign    = \"+\" | \"-\" ;\n//   END     = ? anything not in digit ?\n//   digit   = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\n//   integer = [sign] , digit , {digit} ;\n//   decimal = integer , [\".\" , integer] ;\n//   float   = ( decimal , END ) | ( decimal , (\"E\" | \"e\") , integer , END ) ;\n//\n//  Valid strings are for example:\n//   -0  +3.1417e+2  -0.0E-3  1.0324  -1.41   11e2\n//\n// If the parsing is a success, result is set to the parsed value and true\n// is returned.\n//\n// The function is greedy and will parse until any of the following happens:\n//  - a non-conforming character is encountered.\n//  - s_end is reached.\n//\n// The following situations triggers a failure:\n//  - s >= s_end.\n//  - parse failure.\n//\nstatic bool tryParseDouble(const char *s, const char *s_end, double *result) {\n  if (s >= s_end) {\n    return false;\n  }\n\n  double mantissa = 0.0;\n  // This exponent is base 2 rather than 10.\n  // However the exponent we parse is supposed to be one of ten,\n  // thus we must take care to convert the exponent/and or the\n  // mantissa to a * 2^E, where a is the mantissa and E is the\n  // exponent.\n  // To get the final double we will use ldexp, it requires the\n  // exponent to be in base 2.\n  int exponent = 0;\n\n  // NOTE: THESE MUST BE DECLARED HERE SINCE WE ARE NOT ALLOWED\n  // TO JUMP OVER DEFINITIONS.\n  char sign = '+';\n  char exp_sign = '+';\n  char const *curr = s;\n\n  // How many characters were read in a loop.\n  int read = 0;\n  // Tells whether a loop terminated due to reaching s_end.\n  bool end_not_reached = false;\n  bool leading_decimal_dots = false;\n\n  /*\n          BEGIN PARSING.\n  */\n\n  // Find out what sign we've got.\n  if (*curr == '+' || *curr == '-') {\n    sign = *curr;\n    curr++;\n    if ((curr != s_end) && (*curr == '.')) {\n      // accept. Somethig like `.7e+2`, `-.5234`\n      leading_decimal_dots = true;\n    }\n  } else if (IS_DIGIT(*curr)) { /* Pass through. */\n  } else if (*curr == '.') {\n    // accept. Somethig like `.7e+2`, `-.5234`\n    leading_decimal_dots = true;\n  } else {\n    goto fail;\n  }\n\n  // Read the integer part.\n  end_not_reached = (curr != s_end);\n  if (!leading_decimal_dots) {\n    while (end_not_reached && IS_DIGIT(*curr)) {\n      mantissa *= 10;\n      mantissa += static_cast<int>(*curr - 0x30);\n      curr++;\n      read++;\n      end_not_reached = (curr != s_end);\n    }\n\n    // We must make sure we actually got something.\n    if (read == 0) goto fail;\n  }\n\n  // We allow numbers of form \"#\", \"###\" etc.\n  if (!end_not_reached) goto assemble;\n\n  // Read the decimal part.\n  if (*curr == '.') {\n    curr++;\n    read = 1;\n    end_not_reached = (curr != s_end);\n    while (end_not_reached && IS_DIGIT(*curr)) {\n      static const double pow_lut[] = {\n          1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 0.0000001,\n      };\n      const int lut_entries = sizeof pow_lut / sizeof pow_lut[0];\n\n      // NOTE: Don't use powf here, it will absolutely murder precision.\n      mantissa += static_cast<int>(*curr - 0x30) *\n                  (read < lut_entries ? pow_lut[read] : std::pow(10.0, -read));\n      read++;\n      curr++;\n      end_not_reached = (curr != s_end);\n    }\n  } else if (*curr == 'e' || *curr == 'E') {\n  } else {\n    goto assemble;\n  }\n\n  if (!end_not_reached) goto assemble;\n\n  // Read the exponent part.\n  if (*curr == 'e' || *curr == 'E') {\n    curr++;\n    // Figure out if a sign is present and if it is.\n    end_not_reached = (curr != s_end);\n    if (end_not_reached && (*curr == '+' || *curr == '-')) {\n      exp_sign = *curr;\n      curr++;\n    } else if (IS_DIGIT(*curr)) { /* Pass through. */\n    } else {\n      // Empty E is not allowed.\n      goto fail;\n    }\n\n    read = 0;\n    end_not_reached = (curr != s_end);\n    while (end_not_reached && IS_DIGIT(*curr)) {\n      // To avoid annoying MSVC's min/max macro definiton,\n      // Use hardcoded int max value\n      if (exponent >\n          (2147483647 / 10)) {  // 2147483647 = std::numeric_limits<int>::max()\n        // Integer overflow\n        goto fail;\n      }\n      exponent *= 10;\n      exponent += static_cast<int>(*curr - 0x30);\n      curr++;\n      read++;\n      end_not_reached = (curr != s_end);\n    }\n    exponent *= (exp_sign == '+' ? 1 : -1);\n    if (read == 0) goto fail;\n  }\n\nassemble:\n  *result = (sign == '+' ? 1 : -1) *\n            (exponent ? std::ldexp(mantissa * std::pow(5.0, exponent), exponent)\n                      : mantissa);\n  return true;\nfail:\n  return false;\n}\n\nstatic inline real_t parseReal(const char **token, double default_value = 0.0) {\n  (*token) += strspn((*token), \" \\t\");\n  const char *end = (*token) + strcspn((*token), \" \\t\\r\");\n  double val = default_value;\n  tryParseDouble((*token), end, &val);\n  real_t f = static_cast<real_t>(val);\n  (*token) = end;\n  return f;\n}\n\nstatic inline bool parseReal(const char **token, real_t *out) {\n  (*token) += strspn((*token), \" \\t\");\n  const char *end = (*token) + strcspn((*token), \" \\t\\r\");\n  double val;\n  bool ret = tryParseDouble((*token), end, &val);\n  if (ret) {\n    real_t f = static_cast<real_t>(val);\n    (*out) = f;\n  }\n  (*token) = end;\n  return ret;\n}\n\nstatic inline void parseReal2(real_t *x, real_t *y, const char **token,\n                              const double default_x = 0.0,\n                              const double default_y = 0.0) {\n  (*x) = parseReal(token, default_x);\n  (*y) = parseReal(token, default_y);\n}\n\nstatic inline void parseReal3(real_t *x, real_t *y, real_t *z,\n                              const char **token, const double default_x = 0.0,\n                              const double default_y = 0.0,\n                              const double default_z = 0.0) {\n  (*x) = parseReal(token, default_x);\n  (*y) = parseReal(token, default_y);\n  (*z) = parseReal(token, default_z);\n}\n\n#if 0  // not used\nstatic inline void parseV(real_t *x, real_t *y, real_t *z, real_t *w,\n                          const char **token, const double default_x = 0.0,\n                          const double default_y = 0.0,\n                          const double default_z = 0.0,\n                          const double default_w = 1.0) {\n  (*x) = parseReal(token, default_x);\n  (*y) = parseReal(token, default_y);\n  (*z) = parseReal(token, default_z);\n  (*w) = parseReal(token, default_w);\n}\n#endif\n\n// Extension: parse vertex with colors(6 items)\n// Return 3: xyz, 4: xyzw, 6: xyzrgb\n// `r`: red(case 6) or [w](case 4)\nstatic inline int parseVertexWithColor(real_t *x, real_t *y, real_t *z,\n                                       real_t *r, real_t *g, real_t *b,\n                                       const char **token,\n                                       const double default_x = 0.0,\n                                       const double default_y = 0.0,\n                                       const double default_z = 0.0) {\n  // TODO: Check error\n  (*x) = parseReal(token, default_x);\n  (*y) = parseReal(token, default_y);\n  (*z) = parseReal(token, default_z);\n\n  // - 4 components(x, y, z, w) ot 6 components\n  bool has_r = parseReal(token, r);\n\n  if (!has_r) {\n    (*r) = (*g) = (*b) = 1.0;\n    return 3;\n  }\n\n  bool has_g = parseReal(token, g);\n\n  if (!has_g) {\n    (*g) = (*b) = 1.0;\n    return 4;\n  }\n\n  bool has_b = parseReal(token, b);\n\n  if (!has_b) {\n    (*r) = (*g) = (*b) = 1.0;\n    return 3;  // treated as xyz\n  }\n\n  return 6;\n}\n\nstatic inline bool parseOnOff(const char **token, bool default_value = true) {\n  (*token) += strspn((*token), \" \\t\");\n  const char *end = (*token) + strcspn((*token), \" \\t\\r\");\n\n  bool ret = default_value;\n  if ((0 == strncmp((*token), \"on\", 2))) {\n    ret = true;\n  } else if ((0 == strncmp((*token), \"off\", 3))) {\n    ret = false;\n  }\n\n  (*token) = end;\n  return ret;\n}\n\nstatic inline texture_type_t parseTextureType(\n    const char **token, texture_type_t default_value = TEXTURE_TYPE_NONE) {\n  (*token) += strspn((*token), \" \\t\");\n  const char *end = (*token) + strcspn((*token), \" \\t\\r\");\n  texture_type_t ty = default_value;\n\n  if ((0 == strncmp((*token), \"cube_top\", strlen(\"cube_top\")))) {\n    ty = TEXTURE_TYPE_CUBE_TOP;\n  } else if ((0 == strncmp((*token), \"cube_bottom\", strlen(\"cube_bottom\")))) {\n    ty = TEXTURE_TYPE_CUBE_BOTTOM;\n  } else if ((0 == strncmp((*token), \"cube_left\", strlen(\"cube_left\")))) {\n    ty = TEXTURE_TYPE_CUBE_LEFT;\n  } else if ((0 == strncmp((*token), \"cube_right\", strlen(\"cube_right\")))) {\n    ty = TEXTURE_TYPE_CUBE_RIGHT;\n  } else if ((0 == strncmp((*token), \"cube_front\", strlen(\"cube_front\")))) {\n    ty = TEXTURE_TYPE_CUBE_FRONT;\n  } else if ((0 == strncmp((*token), \"cube_back\", strlen(\"cube_back\")))) {\n    ty = TEXTURE_TYPE_CUBE_BACK;\n  } else if ((0 == strncmp((*token), \"sphere\", strlen(\"sphere\")))) {\n    ty = TEXTURE_TYPE_SPHERE;\n  }\n\n  (*token) = end;\n  return ty;\n}\n\nstatic tag_sizes parseTagTriple(const char **token) {\n  tag_sizes ts;\n\n  (*token) += strspn((*token), \" \\t\");\n  ts.num_ints = atoi((*token));\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    return ts;\n  }\n\n  (*token)++;  // Skip '/'\n\n  (*token) += strspn((*token), \" \\t\");\n  ts.num_reals = atoi((*token));\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    return ts;\n  }\n  (*token)++;  // Skip '/'\n\n  ts.num_strings = parseInt(token);\n\n  return ts;\n}\n\n// Parse triples with index offsets: i, i/j/k, i//k, i/j\nstatic bool parseTriple(const char **token, int vsize, int vnsize, int vtsize,\n                        vertex_index_t *ret, const warning_context &context) {\n  if (!ret) {\n    return false;\n  }\n\n  vertex_index_t vi(-1);\n\n  if (!fixIndex(atoi((*token)), vsize, &vi.v_idx, false, context)) {\n    return false;\n  }\n\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    (*ret) = vi;\n    return true;\n  }\n  (*token)++;\n\n  // i//k\n  if ((*token)[0] == '/') {\n    (*token)++;\n    if (!fixIndex(atoi((*token)), vnsize, &vi.vn_idx, true, context)) {\n      return false;\n    }\n    (*token) += strcspn((*token), \"/ \\t\\r\");\n    (*ret) = vi;\n    return true;\n  }\n\n  // i/j/k or i/j\n  if (!fixIndex(atoi((*token)), vtsize, &vi.vt_idx, true, context)) {\n    return false;\n  }\n\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    (*ret) = vi;\n    return true;\n  }\n\n  // i/j/k\n  (*token)++;  // skip '/'\n  if (!fixIndex(atoi((*token)), vnsize, &vi.vn_idx, true, context)) {\n    return false;\n  }\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n\n  (*ret) = vi;\n\n  return true;\n}\n\n// Parse raw triples: i, i/j/k, i//k, i/j\nstatic vertex_index_t parseRawTriple(const char **token) {\n  vertex_index_t vi(static_cast<int>(0));  // 0 is an invalid index in OBJ\n\n  vi.v_idx = atoi((*token));\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    return vi;\n  }\n  (*token)++;\n\n  // i//k\n  if ((*token)[0] == '/') {\n    (*token)++;\n    vi.vn_idx = atoi((*token));\n    (*token) += strcspn((*token), \"/ \\t\\r\");\n    return vi;\n  }\n\n  // i/j/k or i/j\n  vi.vt_idx = atoi((*token));\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  if ((*token)[0] != '/') {\n    return vi;\n  }\n\n  // i/j/k\n  (*token)++;  // skip '/'\n  vi.vn_idx = atoi((*token));\n  (*token) += strcspn((*token), \"/ \\t\\r\");\n  return vi;\n}\n\nbool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,\n                               const char *linebuf) {\n  // @todo { write more robust lexer and parser. }\n  bool found_texname = false;\n  std::string texture_name;\n\n  const char *token = linebuf;  // Assume line ends with NULL\n\n  while (!IS_NEW_LINE((*token))) {\n    token += strspn(token, \" \\t\");  // skip space\n    if ((0 == strncmp(token, \"-blendu\", 7)) && IS_SPACE((token[7]))) {\n      token += 8;\n      texopt->blendu = parseOnOff(&token, /* default */ true);\n    } else if ((0 == strncmp(token, \"-blendv\", 7)) && IS_SPACE((token[7]))) {\n      token += 8;\n      texopt->blendv = parseOnOff(&token, /* default */ true);\n    } else if ((0 == strncmp(token, \"-clamp\", 6)) && IS_SPACE((token[6]))) {\n      token += 7;\n      texopt->clamp = parseOnOff(&token, /* default */ true);\n    } else if ((0 == strncmp(token, \"-boost\", 6)) && IS_SPACE((token[6]))) {\n      token += 7;\n      texopt->sharpness = parseReal(&token, 1.0);\n    } else if ((0 == strncmp(token, \"-bm\", 3)) && IS_SPACE((token[3]))) {\n      token += 4;\n      texopt->bump_multiplier = parseReal(&token, 1.0);\n    } else if ((0 == strncmp(token, \"-o\", 2)) && IS_SPACE((token[2]))) {\n      token += 3;\n      parseReal3(&(texopt->origin_offset[0]), &(texopt->origin_offset[1]),\n                 &(texopt->origin_offset[2]), &token);\n    } else if ((0 == strncmp(token, \"-s\", 2)) && IS_SPACE((token[2]))) {\n      token += 3;\n      parseReal3(&(texopt->scale[0]), &(texopt->scale[1]), &(texopt->scale[2]),\n                 &token, 1.0, 1.0, 1.0);\n    } else if ((0 == strncmp(token, \"-t\", 2)) && IS_SPACE((token[2]))) {\n      token += 3;\n      parseReal3(&(texopt->turbulence[0]), &(texopt->turbulence[1]),\n                 &(texopt->turbulence[2]), &token);\n    } else if ((0 == strncmp(token, \"-type\", 5)) && IS_SPACE((token[5]))) {\n      token += 5;\n      texopt->type = parseTextureType((&token), TEXTURE_TYPE_NONE);\n    } else if ((0 == strncmp(token, \"-texres\", 7)) && IS_SPACE((token[7]))) {\n      token += 7;\n      // TODO(syoyo): Check if arg is int type.\n      texopt->texture_resolution = parseInt(&token);\n    } else if ((0 == strncmp(token, \"-imfchan\", 8)) && IS_SPACE((token[8]))) {\n      token += 9;\n      token += strspn(token, \" \\t\");\n      const char *end = token + strcspn(token, \" \\t\\r\");\n      if ((end - token) == 1) {  // Assume one char for -imfchan\n        texopt->imfchan = (*token);\n      }\n      token = end;\n    } else if ((0 == strncmp(token, \"-mm\", 3)) && IS_SPACE((token[3]))) {\n      token += 4;\n      parseReal2(&(texopt->brightness), &(texopt->contrast), &token, 0.0, 1.0);\n    } else if ((0 == strncmp(token, \"-colorspace\", 11)) &&\n               IS_SPACE((token[11]))) {\n      token += 12;\n      texopt->colorspace = parseString(&token);\n    } else {\n// Assume texture filename\n#if 0\n      size_t len = strcspn(token, \" \\t\\r\");  // untile next space\n      texture_name = std::string(token, token + len);\n      token += len;\n\n      token += strspn(token, \" \\t\");  // skip space\n#else\n      // Read filename until line end to parse filename containing whitespace\n      // TODO(syoyo): Support parsing texture option flag after the filename.\n      texture_name = std::string(token);\n      token += texture_name.length();\n#endif\n\n      found_texname = true;\n    }\n  }\n\n  if (found_texname) {\n    (*texname) = texture_name;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic void InitTexOpt(texture_option_t *texopt, const bool is_bump) {\n  if (is_bump) {\n    texopt->imfchan = 'l';\n  } else {\n    texopt->imfchan = 'm';\n  }\n  texopt->bump_multiplier = static_cast<real_t>(1.0);\n  texopt->clamp = false;\n  texopt->blendu = true;\n  texopt->blendv = true;\n  texopt->sharpness = static_cast<real_t>(1.0);\n  texopt->brightness = static_cast<real_t>(0.0);\n  texopt->contrast = static_cast<real_t>(1.0);\n  texopt->origin_offset[0] = static_cast<real_t>(0.0);\n  texopt->origin_offset[1] = static_cast<real_t>(0.0);\n  texopt->origin_offset[2] = static_cast<real_t>(0.0);\n  texopt->scale[0] = static_cast<real_t>(1.0);\n  texopt->scale[1] = static_cast<real_t>(1.0);\n  texopt->scale[2] = static_cast<real_t>(1.0);\n  texopt->turbulence[0] = static_cast<real_t>(0.0);\n  texopt->turbulence[1] = static_cast<real_t>(0.0);\n  texopt->turbulence[2] = static_cast<real_t>(0.0);\n  texopt->texture_resolution = -1;\n  texopt->type = TEXTURE_TYPE_NONE;\n}\n\nstatic void InitMaterial(material_t *material) {\n  InitTexOpt(&material->ambient_texopt, /* is_bump */ false);\n  InitTexOpt(&material->diffuse_texopt, /* is_bump */ false);\n  InitTexOpt(&material->specular_texopt, /* is_bump */ false);\n  InitTexOpt(&material->specular_highlight_texopt, /* is_bump */ false);\n  InitTexOpt(&material->bump_texopt, /* is_bump */ true);\n  InitTexOpt(&material->displacement_texopt, /* is_bump */ false);\n  InitTexOpt(&material->alpha_texopt, /* is_bump */ false);\n  InitTexOpt(&material->reflection_texopt, /* is_bump */ false);\n  InitTexOpt(&material->roughness_texopt, /* is_bump */ false);\n  InitTexOpt(&material->metallic_texopt, /* is_bump */ false);\n  InitTexOpt(&material->sheen_texopt, /* is_bump */ false);\n  InitTexOpt(&material->emissive_texopt, /* is_bump */ false);\n  InitTexOpt(&material->normal_texopt,\n             /* is_bump */ false);  // @fixme { is_bump will be true? }\n  material->name = \"\";\n  material->ambient_texname = \"\";\n  material->diffuse_texname = \"\";\n  material->specular_texname = \"\";\n  material->specular_highlight_texname = \"\";\n  material->bump_texname = \"\";\n  material->displacement_texname = \"\";\n  material->reflection_texname = \"\";\n  material->alpha_texname = \"\";\n  for (int i = 0; i < 3; i++) {\n    material->ambient[i] = static_cast<real_t>(0.0);\n    material->diffuse[i] = static_cast<real_t>(0.0);\n    material->specular[i] = static_cast<real_t>(0.0);\n    material->transmittance[i] = static_cast<real_t>(0.0);\n    material->emission[i] = static_cast<real_t>(0.0);\n  }\n  material->illum = 0;\n  material->dissolve = static_cast<real_t>(1.0);\n  material->shininess = static_cast<real_t>(1.0);\n  material->ior = static_cast<real_t>(1.0);\n\n  material->roughness = static_cast<real_t>(0.0);\n  material->metallic = static_cast<real_t>(0.0);\n  material->sheen = static_cast<real_t>(0.0);\n  material->clearcoat_thickness = static_cast<real_t>(0.0);\n  material->clearcoat_roughness = static_cast<real_t>(0.0);\n  material->anisotropy_rotation = static_cast<real_t>(0.0);\n  material->anisotropy = static_cast<real_t>(0.0);\n  material->roughness_texname = \"\";\n  material->metallic_texname = \"\";\n  material->sheen_texname = \"\";\n  material->emissive_texname = \"\";\n  material->normal_texname = \"\";\n\n  material->unknown_parameter.clear();\n}\n\n// code from https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html\ntemplate <typename T>\nstatic int pnpoly(int nvert, T *vertx, T *verty, T testx, T testy) {\n  int i, j, c = 0;\n  for (i = 0, j = nvert - 1; i < nvert; j = i++) {\n    if (((verty[i] > testy) != (verty[j] > testy)) &&\n        (testx <\n         (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) +\n             vertx[i]))\n      c = !c;\n  }\n  return c;\n}\n\nstruct TinyObjPoint {\n  real_t x, y, z;\n  TinyObjPoint() : x(0), y(0), z(0) {}\n  TinyObjPoint(real_t x_, real_t y_, real_t z_) : x(x_), y(y_), z(z_) {}\n};\n\ninline TinyObjPoint cross(const TinyObjPoint &v1, const TinyObjPoint &v2) {\n  return TinyObjPoint(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z,\n                      v1.x * v2.y - v1.y * v2.x);\n}\n\ninline real_t dot(const TinyObjPoint &v1, const TinyObjPoint &v2) {\n  return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);\n}\n\ninline real_t GetLength(TinyObjPoint &e) {\n  return std::sqrt(e.x * e.x + e.y * e.y + e.z * e.z);\n}\n\ninline TinyObjPoint Normalize(TinyObjPoint e) {\n  real_t inv_length = real_t(1) / GetLength(e);\n  return TinyObjPoint(e.x * inv_length, e.y * inv_length, e.z * inv_length);\n}\n\ninline TinyObjPoint WorldToLocal(const TinyObjPoint &a, const TinyObjPoint &u,\n                                 const TinyObjPoint &v, const TinyObjPoint &w) {\n  return TinyObjPoint(dot(a, u), dot(a, v), dot(a, w));\n}\n\n// TODO(syoyo): refactor function.\nstatic bool exportGroupsToShape(shape_t *shape, const PrimGroup &prim_group,\n                                const std::vector<tag_t> &tags,\n                                const int material_id, const std::string &name,\n                                bool triangulate, const std::vector<real_t> &v,\n                                std::string *warn) {\n  if (prim_group.IsEmpty()) {\n    return false;\n  }\n\n  shape->name = name;\n\n  // polygon\n  if (!prim_group.faceGroup.empty()) {\n    // Flatten vertices and indices\n    for (size_t i = 0; i < prim_group.faceGroup.size(); i++) {\n      const face_t &face = prim_group.faceGroup[i];\n\n      size_t npolys = face.vertex_indices.size();\n\n      if (npolys < 3) {\n        // Face must have 3+ vertices.\n        if (warn) {\n          (*warn) += \"Degenerated face found\\n.\";\n        }\n        continue;\n      }\n\n      if (triangulate && npolys != 3) {\n        if (npolys == 4) {\n          vertex_index_t i0 = face.vertex_indices[0];\n          vertex_index_t i1 = face.vertex_indices[1];\n          vertex_index_t i2 = face.vertex_indices[2];\n          vertex_index_t i3 = face.vertex_indices[3];\n\n          size_t vi0 = size_t(i0.v_idx);\n          size_t vi1 = size_t(i1.v_idx);\n          size_t vi2 = size_t(i2.v_idx);\n          size_t vi3 = size_t(i3.v_idx);\n\n          if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||\n              ((3 * vi2 + 2) >= v.size()) || ((3 * vi3 + 2) >= v.size())) {\n            // Invalid triangle.\n            // FIXME(syoyo): Is it ok to simply skip this invalid triangle?\n            if (warn) {\n              (*warn) += \"Face with invalid vertex index found.\\n\";\n            }\n            continue;\n          }\n\n          real_t v0x = v[vi0 * 3 + 0];\n          real_t v0y = v[vi0 * 3 + 1];\n          real_t v0z = v[vi0 * 3 + 2];\n          real_t v1x = v[vi1 * 3 + 0];\n          real_t v1y = v[vi1 * 3 + 1];\n          real_t v1z = v[vi1 * 3 + 2];\n          real_t v2x = v[vi2 * 3 + 0];\n          real_t v2y = v[vi2 * 3 + 1];\n          real_t v2z = v[vi2 * 3 + 2];\n          real_t v3x = v[vi3 * 3 + 0];\n          real_t v3y = v[vi3 * 3 + 1];\n          real_t v3z = v[vi3 * 3 + 2];\n\n          // There are two candidates to split the quad into two triangles.\n          //\n          // Choose the shortest edge.\n          // TODO: Is it better to determine the edge to split by calculating\n          // the area of each triangle?\n          //\n          // +---+\n          // |\\  |\n          // | \\ |\n          // |  \\|\n          // +---+\n          //\n          // +---+\n          // |  /|\n          // | / |\n          // |/  |\n          // +---+\n\n          real_t e02x = v2x - v0x;\n          real_t e02y = v2y - v0y;\n          real_t e02z = v2z - v0z;\n          real_t e13x = v3x - v1x;\n          real_t e13y = v3y - v1y;\n          real_t e13z = v3z - v1z;\n\n          real_t sqr02 = e02x * e02x + e02y * e02y + e02z * e02z;\n          real_t sqr13 = e13x * e13x + e13y * e13y + e13z * e13z;\n\n          index_t idx0, idx1, idx2, idx3;\n\n          idx0.vertex_index = i0.v_idx;\n          idx0.normal_index = i0.vn_idx;\n          idx0.texcoord_index = i0.vt_idx;\n          idx1.vertex_index = i1.v_idx;\n          idx1.normal_index = i1.vn_idx;\n          idx1.texcoord_index = i1.vt_idx;\n          idx2.vertex_index = i2.v_idx;\n          idx2.normal_index = i2.vn_idx;\n          idx2.texcoord_index = i2.vt_idx;\n          idx3.vertex_index = i3.v_idx;\n          idx3.normal_index = i3.vn_idx;\n          idx3.texcoord_index = i3.vt_idx;\n\n          if (sqr02 < sqr13) {\n            // [0, 1, 2], [0, 2, 3]\n            shape->mesh.indices.push_back(idx0);\n            shape->mesh.indices.push_back(idx1);\n            shape->mesh.indices.push_back(idx2);\n\n            shape->mesh.indices.push_back(idx0);\n            shape->mesh.indices.push_back(idx2);\n            shape->mesh.indices.push_back(idx3);\n          } else {\n            // [0, 1, 3], [1, 2, 3]\n            shape->mesh.indices.push_back(idx0);\n            shape->mesh.indices.push_back(idx1);\n            shape->mesh.indices.push_back(idx3);\n\n            shape->mesh.indices.push_back(idx1);\n            shape->mesh.indices.push_back(idx2);\n            shape->mesh.indices.push_back(idx3);\n          }\n\n          // Two triangle faces\n          shape->mesh.num_face_vertices.push_back(3);\n          shape->mesh.num_face_vertices.push_back(3);\n\n          shape->mesh.material_ids.push_back(material_id);\n          shape->mesh.material_ids.push_back(material_id);\n\n          shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);\n          shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);\n\n        } else {\n#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT\n          vertex_index_t i0 = face.vertex_indices[0];\n          vertex_index_t i0_2 = i0;\n\n          // TMW change: Find the normal axis of the polygon using Newell's\n          // method\n          TinyObjPoint n;\n          for (size_t k = 0; k < npolys; ++k) {\n            i0 = face.vertex_indices[k % npolys];\n            size_t vi0 = size_t(i0.v_idx);\n\n            size_t j = (k + 1) % npolys;\n            i0_2 = face.vertex_indices[j];\n            size_t vi0_2 = size_t(i0_2.v_idx);\n\n            real_t v0x = v[vi0 * 3 + 0];\n            real_t v0y = v[vi0 * 3 + 1];\n            real_t v0z = v[vi0 * 3 + 2];\n\n            real_t v0x_2 = v[vi0_2 * 3 + 0];\n            real_t v0y_2 = v[vi0_2 * 3 + 1];\n            real_t v0z_2 = v[vi0_2 * 3 + 2];\n\n            const TinyObjPoint point1(v0x, v0y, v0z);\n            const TinyObjPoint point2(v0x_2, v0y_2, v0z_2);\n\n            TinyObjPoint a(point1.x - point2.x, point1.y - point2.y,\n                           point1.z - point2.z);\n            TinyObjPoint b(point1.x + point2.x, point1.y + point2.y,\n                           point1.z + point2.z);\n\n            n.x += (a.y * b.z);\n            n.y += (a.z * b.x);\n            n.z += (a.x * b.y);\n          }\n          real_t length_n = GetLength(n);\n          // Check if zero length normal\n          if (length_n <= 0) {\n            continue;\n          }\n          // Negative is to flip the normal to the correct direction\n          real_t inv_length = -real_t(1.0) / length_n;\n          n.x *= inv_length;\n          n.y *= inv_length;\n          n.z *= inv_length;\n\n          TinyObjPoint axis_w, axis_v, axis_u;\n          axis_w = n;\n          TinyObjPoint a;\n          if (std::fabs(axis_w.x) > real_t(0.9999999)) {\n            a = TinyObjPoint(0, 1, 0);\n          } else {\n            a = TinyObjPoint(1, 0, 0);\n          }\n          axis_v = Normalize(cross(axis_w, a));\n          axis_u = cross(axis_w, axis_v);\n          using Point = std::array<real_t, 2>;\n\n          // first polyline define the main polygon.\n          // following polylines define holes(not used in tinyobj).\n          std::vector<std::vector<Point> > polygon;\n\n          std::vector<Point> polyline;\n\n          // TMW change: Find best normal and project v0x and v0y to those\n          // coordinates, instead of picking a plane aligned with an axis (which\n          // can flip polygons).\n\n          // Fill polygon data(facevarying vertices).\n          for (size_t k = 0; k < npolys; k++) {\n            i0 = face.vertex_indices[k];\n            size_t vi0 = size_t(i0.v_idx);\n\n            assert(((3 * vi0 + 2) < v.size()));\n\n            real_t v0x = v[vi0 * 3 + 0];\n            real_t v0y = v[vi0 * 3 + 1];\n            real_t v0z = v[vi0 * 3 + 2];\n\n            TinyObjPoint polypoint(v0x, v0y, v0z);\n            TinyObjPoint loc = WorldToLocal(polypoint, axis_u, axis_v, axis_w);\n\n            polyline.push_back({loc.x, loc.y});\n          }\n\n          polygon.push_back(polyline);\n          std::vector<uint32_t> indices = mapbox::earcut<uint32_t>(polygon);\n          // => result = 3 * faces, clockwise\n\n          assert(indices.size() % 3 == 0);\n\n          // Reconstruct vertex_index_t\n          for (size_t k = 0; k < indices.size() / 3; k++) {\n            {\n              index_t idx0, idx1, idx2;\n              idx0.vertex_index = face.vertex_indices[indices[3 * k + 0]].v_idx;\n              idx0.normal_index =\n                  face.vertex_indices[indices[3 * k + 0]].vn_idx;\n              idx0.texcoord_index =\n                  face.vertex_indices[indices[3 * k + 0]].vt_idx;\n              idx1.vertex_index = face.vertex_indices[indices[3 * k + 1]].v_idx;\n              idx1.normal_index =\n                  face.vertex_indices[indices[3 * k + 1]].vn_idx;\n              idx1.texcoord_index =\n                  face.vertex_indices[indices[3 * k + 1]].vt_idx;\n              idx2.vertex_index = face.vertex_indices[indices[3 * k + 2]].v_idx;\n              idx2.normal_index =\n                  face.vertex_indices[indices[3 * k + 2]].vn_idx;\n              idx2.texcoord_index =\n                  face.vertex_indices[indices[3 * k + 2]].vt_idx;\n\n              shape->mesh.indices.push_back(idx0);\n              shape->mesh.indices.push_back(idx1);\n              shape->mesh.indices.push_back(idx2);\n\n              shape->mesh.num_face_vertices.push_back(3);\n              shape->mesh.material_ids.push_back(material_id);\n              shape->mesh.smoothing_group_ids.push_back(\n                  face.smoothing_group_id);\n            }\n          }\n\n#else  // Built-in ear clipping triangulation\n          vertex_index_t i0 = face.vertex_indices[0];\n          vertex_index_t i1(-1);\n          vertex_index_t i2 = face.vertex_indices[1];\n\n          // find the two axes to work in\n          size_t axes[2] = {1, 2};\n          for (size_t k = 0; k < npolys; ++k) {\n            i0 = face.vertex_indices[(k + 0) % npolys];\n            i1 = face.vertex_indices[(k + 1) % npolys];\n            i2 = face.vertex_indices[(k + 2) % npolys];\n            size_t vi0 = size_t(i0.v_idx);\n            size_t vi1 = size_t(i1.v_idx);\n            size_t vi2 = size_t(i2.v_idx);\n\n            if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||\n                ((3 * vi2 + 2) >= v.size())) {\n              // Invalid triangle.\n              // FIXME(syoyo): Is it ok to simply skip this invalid triangle?\n              continue;\n            }\n            real_t v0x = v[vi0 * 3 + 0];\n            real_t v0y = v[vi0 * 3 + 1];\n            real_t v0z = v[vi0 * 3 + 2];\n            real_t v1x = v[vi1 * 3 + 0];\n            real_t v1y = v[vi1 * 3 + 1];\n            real_t v1z = v[vi1 * 3 + 2];\n            real_t v2x = v[vi2 * 3 + 0];\n            real_t v2y = v[vi2 * 3 + 1];\n            real_t v2z = v[vi2 * 3 + 2];\n            real_t e0x = v1x - v0x;\n            real_t e0y = v1y - v0y;\n            real_t e0z = v1z - v0z;\n            real_t e1x = v2x - v1x;\n            real_t e1y = v2y - v1y;\n            real_t e1z = v2z - v1z;\n            real_t cx = std::fabs(e0y * e1z - e0z * e1y);\n            real_t cy = std::fabs(e0z * e1x - e0x * e1z);\n            real_t cz = std::fabs(e0x * e1y - e0y * e1x);\n            const real_t epsilon = std::numeric_limits<real_t>::epsilon();\n            // std::cout << \"cx \" << cx << \", cy \" << cy << \", cz \" << cz <<\n            // \"\\n\";\n            if (cx > epsilon || cy > epsilon || cz > epsilon) {\n              // std::cout << \"corner\\n\";\n              // found a corner\n              if (cx > cy && cx > cz) {\n                // std::cout << \"pattern0\\n\";\n              } else {\n                // std::cout << \"axes[0] = 0\\n\";\n                axes[0] = 0;\n                if (cz > cx && cz > cy) {\n                  // std::cout << \"axes[1] = 1\\n\";\n                  axes[1] = 1;\n                }\n              }\n              break;\n            }\n          }\n\n          face_t remainingFace = face;  // copy\n          size_t guess_vert = 0;\n          vertex_index_t ind[3];\n          real_t vx[3];\n          real_t vy[3];\n\n          // How many iterations can we do without decreasing the remaining\n          // vertices.\n          size_t remainingIterations = face.vertex_indices.size();\n          size_t previousRemainingVertices =\n              remainingFace.vertex_indices.size();\n\n          while (remainingFace.vertex_indices.size() > 3 &&\n                 remainingIterations > 0) {\n            // std::cout << \"remainingIterations \" << remainingIterations <<\n            // \"\\n\";\n\n            npolys = remainingFace.vertex_indices.size();\n            if (guess_vert >= npolys) {\n              guess_vert -= npolys;\n            }\n\n            if (previousRemainingVertices != npolys) {\n              // The number of remaining vertices decreased. Reset counters.\n              previousRemainingVertices = npolys;\n              remainingIterations = npolys;\n            } else {\n              // We didn't consume a vertex on previous iteration, reduce the\n              // available iterations.\n              remainingIterations--;\n            }\n\n            for (size_t k = 0; k < 3; k++) {\n              ind[k] = remainingFace.vertex_indices[(guess_vert + k) % npolys];\n              size_t vi = size_t(ind[k].v_idx);\n              if (((vi * 3 + axes[0]) >= v.size()) ||\n                  ((vi * 3 + axes[1]) >= v.size())) {\n                // ???\n                vx[k] = static_cast<real_t>(0.0);\n                vy[k] = static_cast<real_t>(0.0);\n              } else {\n                vx[k] = v[vi * 3 + axes[0]];\n                vy[k] = v[vi * 3 + axes[1]];\n              }\n            }\n\n            //\n            // area is calculated per face\n            //\n            real_t e0x = vx[1] - vx[0];\n            real_t e0y = vy[1] - vy[0];\n            real_t e1x = vx[2] - vx[1];\n            real_t e1y = vy[2] - vy[1];\n            real_t cross = e0x * e1y - e0y * e1x;\n            // std::cout << \"axes = \" << axes[0] << \", \" << axes[1] << \"\\n\";\n            // std::cout << \"e0x, e0y, e1x, e1y \" << e0x << \", \" << e0y << \", \"\n            // << e1x << \", \" << e1y << \"\\n\";\n\n            real_t area =\n                (vx[0] * vy[1] - vy[0] * vx[1]) * static_cast<real_t>(0.5);\n            // std::cout << \"cross \" << cross << \", area \" << area << \"\\n\";\n            // if an internal angle\n            if (cross * area < static_cast<real_t>(0.0)) {\n              // std::cout << \"internal \\n\";\n              guess_vert += 1;\n              // std::cout << \"guess vert : \" << guess_vert << \"\\n\";\n              continue;\n            }\n\n            // check all other verts in case they are inside this triangle\n            bool overlap = false;\n            for (size_t otherVert = 3; otherVert < npolys; ++otherVert) {\n              size_t idx = (guess_vert + otherVert) % npolys;\n\n              if (idx >= remainingFace.vertex_indices.size()) {\n                // std::cout << \"???0\\n\";\n                // ???\n                continue;\n              }\n\n              size_t ovi = size_t(remainingFace.vertex_indices[idx].v_idx);\n\n              if (((ovi * 3 + axes[0]) >= v.size()) ||\n                  ((ovi * 3 + axes[1]) >= v.size())) {\n                // std::cout << \"???1\\n\";\n                // ???\n                continue;\n              }\n              real_t tx = v[ovi * 3 + axes[0]];\n              real_t ty = v[ovi * 3 + axes[1]];\n              if (pnpoly(3, vx, vy, tx, ty)) {\n                // std::cout << \"overlap\\n\";\n                overlap = true;\n                break;\n              }\n            }\n\n            if (overlap) {\n              // std::cout << \"overlap2\\n\";\n              guess_vert += 1;\n              continue;\n            }\n\n            // this triangle is an ear\n            {\n              index_t idx0, idx1, idx2;\n              idx0.vertex_index = ind[0].v_idx;\n              idx0.normal_index = ind[0].vn_idx;\n              idx0.texcoord_index = ind[0].vt_idx;\n              idx1.vertex_index = ind[1].v_idx;\n              idx1.normal_index = ind[1].vn_idx;\n              idx1.texcoord_index = ind[1].vt_idx;\n              idx2.vertex_index = ind[2].v_idx;\n              idx2.normal_index = ind[2].vn_idx;\n              idx2.texcoord_index = ind[2].vt_idx;\n\n              shape->mesh.indices.push_back(idx0);\n              shape->mesh.indices.push_back(idx1);\n              shape->mesh.indices.push_back(idx2);\n\n              shape->mesh.num_face_vertices.push_back(3);\n              shape->mesh.material_ids.push_back(material_id);\n              shape->mesh.smoothing_group_ids.push_back(\n                  face.smoothing_group_id);\n            }\n\n            // remove v1 from the list\n            size_t removed_vert_index = (guess_vert + 1) % npolys;\n            while (removed_vert_index + 1 < npolys) {\n              remainingFace.vertex_indices[removed_vert_index] =\n                  remainingFace.vertex_indices[removed_vert_index + 1];\n              removed_vert_index += 1;\n            }\n            remainingFace.vertex_indices.pop_back();\n          }\n\n          // std::cout << \"remainingFace.vi.size = \" <<\n          // remainingFace.vertex_indices.size() << \"\\n\";\n          if (remainingFace.vertex_indices.size() == 3) {\n            i0 = remainingFace.vertex_indices[0];\n            i1 = remainingFace.vertex_indices[1];\n            i2 = remainingFace.vertex_indices[2];\n            {\n              index_t idx0, idx1, idx2;\n              idx0.vertex_index = i0.v_idx;\n              idx0.normal_index = i0.vn_idx;\n              idx0.texcoord_index = i0.vt_idx;\n              idx1.vertex_index = i1.v_idx;\n              idx1.normal_index = i1.vn_idx;\n              idx1.texcoord_index = i1.vt_idx;\n              idx2.vertex_index = i2.v_idx;\n              idx2.normal_index = i2.vn_idx;\n              idx2.texcoord_index = i2.vt_idx;\n\n              shape->mesh.indices.push_back(idx0);\n              shape->mesh.indices.push_back(idx1);\n              shape->mesh.indices.push_back(idx2);\n\n              shape->mesh.num_face_vertices.push_back(3);\n              shape->mesh.material_ids.push_back(material_id);\n              shape->mesh.smoothing_group_ids.push_back(\n                  face.smoothing_group_id);\n            }\n          }\n#endif\n        }  // npolys\n      } else {\n        for (size_t k = 0; k < npolys; k++) {\n          index_t idx;\n          idx.vertex_index = face.vertex_indices[k].v_idx;\n          idx.normal_index = face.vertex_indices[k].vn_idx;\n          idx.texcoord_index = face.vertex_indices[k].vt_idx;\n          shape->mesh.indices.push_back(idx);\n        }\n\n        shape->mesh.num_face_vertices.push_back(\n            static_cast<unsigned int>(npolys));\n        shape->mesh.material_ids.push_back(material_id);  // per face\n        shape->mesh.smoothing_group_ids.push_back(\n            face.smoothing_group_id);  // per face\n      }\n    }\n\n    shape->mesh.tags = tags;\n  }\n\n  // line\n  if (!prim_group.lineGroup.empty()) {\n    // Flatten indices\n    for (size_t i = 0; i < prim_group.lineGroup.size(); i++) {\n      for (size_t j = 0; j < prim_group.lineGroup[i].vertex_indices.size();\n           j++) {\n        const vertex_index_t &vi = prim_group.lineGroup[i].vertex_indices[j];\n\n        index_t idx;\n        idx.vertex_index = vi.v_idx;\n        idx.normal_index = vi.vn_idx;\n        idx.texcoord_index = vi.vt_idx;\n\n        shape->lines.indices.push_back(idx);\n      }\n\n      shape->lines.num_line_vertices.push_back(\n          int(prim_group.lineGroup[i].vertex_indices.size()));\n    }\n  }\n\n  // points\n  if (!prim_group.pointsGroup.empty()) {\n    // Flatten & convert indices\n    for (size_t i = 0; i < prim_group.pointsGroup.size(); i++) {\n      for (size_t j = 0; j < prim_group.pointsGroup[i].vertex_indices.size();\n           j++) {\n        const vertex_index_t &vi = prim_group.pointsGroup[i].vertex_indices[j];\n\n        index_t idx;\n        idx.vertex_index = vi.v_idx;\n        idx.normal_index = vi.vn_idx;\n        idx.texcoord_index = vi.vt_idx;\n\n        shape->points.indices.push_back(idx);\n      }\n    }\n  }\n\n  return true;\n}\n\n// Split a string with specified delimiter character and escape character.\n// https://rosettacode.org/wiki/Tokenize_a_string_with_escaping#C.2B.2B\nstatic void SplitString(const std::string &s, char delim, char escape,\n                        std::vector<std::string> &elems) {\n  std::string token;\n\n  bool escaping = false;\n  for (size_t i = 0; i < s.size(); ++i) {\n    char ch = s[i];\n    if (escaping) {\n      escaping = false;\n    } else if (ch == escape) {\n      escaping = true;\n      continue;\n    } else if (ch == delim) {\n      if (!token.empty()) {\n        elems.push_back(token);\n      }\n      token.clear();\n      continue;\n    }\n    token += ch;\n  }\n\n  elems.push_back(token);\n}\n\nstatic std::string JoinPath(const std::string &dir,\n                            const std::string &filename) {\n  if (dir.empty()) {\n    return filename;\n  } else {\n    // check '/'\n    char lastChar = *dir.rbegin();\n    if (lastChar != '/') {\n      return dir + std::string(\"/\") + filename;\n    } else {\n      return dir + filename;\n    }\n  }\n}\n\nvoid LoadMtl(std::map<std::string, int> *material_map,\n             std::vector<material_t> *materials, std::istream *inStream,\n             std::string *warning, std::string *err) {\n  (void)err;\n\n  // Create a default material anyway.\n  material_t material;\n  InitMaterial(&material);\n\n  // Issue 43. `d` wins against `Tr` since `Tr` is not in the MTL specification.\n  bool has_d = false;\n  bool has_tr = false;\n\n  // has_kd is used to set a default diffuse value when map_Kd is present\n  // and Kd is not.\n  bool has_kd = false;\n\n  std::stringstream warn_ss;\n\n  size_t line_no = 0;\n  std::string linebuf;\n  while (inStream->peek() != -1) {\n    safeGetline(*inStream, linebuf);\n    line_no++;\n\n    // Trim trailing whitespace.\n    if (linebuf.size() > 0) {\n      linebuf = linebuf.substr(0, linebuf.find_last_not_of(\" \\t\") + 1);\n    }\n\n    // Trim newline '\\r\\n' or '\\n'\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\n')\n        linebuf.erase(linebuf.size() - 1);\n    }\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\r')\n        linebuf.erase(linebuf.size() - 1);\n    }\n\n    // Skip if empty line.\n    if (linebuf.empty()) {\n      continue;\n    }\n\n    // Skip leading space.\n    const char *token = linebuf.c_str();\n    token += strspn(token, \" \\t\");\n\n    assert(token);\n    if (token[0] == '\\0') continue;  // empty line\n\n    if (token[0] == '#') continue;  // comment line\n\n    // new mtl\n    if ((0 == strncmp(token, \"newmtl\", 6)) && IS_SPACE((token[6]))) {\n      // flush previous material.\n      if (!material.name.empty()) {\n        material_map->insert(std::pair<std::string, int>(\n            material.name, static_cast<int>(materials->size())));\n        materials->push_back(material);\n      }\n\n      // initial temporary material\n      InitMaterial(&material);\n\n      has_d = false;\n      has_tr = false;\n\n      // set new mtl name\n      token += 7;\n      {\n        std::string namebuf = parseString(&token);\n        // TODO: empty name check?\n        if (namebuf.empty()) {\n          if (warning) {\n            (*warning) += \"empty material name in `newmtl`\\n\";\n          }\n        }\n        material.name = namebuf;\n      }\n      continue;\n    }\n\n    // ambient\n    if (token[0] == 'K' && token[1] == 'a' && IS_SPACE((token[2]))) {\n      token += 2;\n      real_t r, g, b;\n      parseReal3(&r, &g, &b, &token);\n      material.ambient[0] = r;\n      material.ambient[1] = g;\n      material.ambient[2] = b;\n      continue;\n    }\n\n    // diffuse\n    if (token[0] == 'K' && token[1] == 'd' && IS_SPACE((token[2]))) {\n      token += 2;\n      real_t r, g, b;\n      parseReal3(&r, &g, &b, &token);\n      material.diffuse[0] = r;\n      material.diffuse[1] = g;\n      material.diffuse[2] = b;\n      has_kd = true;\n      continue;\n    }\n\n    // specular\n    if (token[0] == 'K' && token[1] == 's' && IS_SPACE((token[2]))) {\n      token += 2;\n      real_t r, g, b;\n      parseReal3(&r, &g, &b, &token);\n      material.specular[0] = r;\n      material.specular[1] = g;\n      material.specular[2] = b;\n      continue;\n    }\n\n    // transmittance\n    if ((token[0] == 'K' && token[1] == 't' && IS_SPACE((token[2]))) ||\n        (token[0] == 'T' && token[1] == 'f' && IS_SPACE((token[2])))) {\n      token += 2;\n      real_t r, g, b;\n      parseReal3(&r, &g, &b, &token);\n      material.transmittance[0] = r;\n      material.transmittance[1] = g;\n      material.transmittance[2] = b;\n      continue;\n    }\n\n    // ior(index of refraction)\n    if (token[0] == 'N' && token[1] == 'i' && IS_SPACE((token[2]))) {\n      token += 2;\n      material.ior = parseReal(&token);\n      continue;\n    }\n\n    // emission\n    if (token[0] == 'K' && token[1] == 'e' && IS_SPACE(token[2])) {\n      token += 2;\n      real_t r, g, b;\n      parseReal3(&r, &g, &b, &token);\n      material.emission[0] = r;\n      material.emission[1] = g;\n      material.emission[2] = b;\n      continue;\n    }\n\n    // shininess\n    if (token[0] == 'N' && token[1] == 's' && IS_SPACE(token[2])) {\n      token += 2;\n      material.shininess = parseReal(&token);\n      continue;\n    }\n\n    // illum model\n    if (0 == strncmp(token, \"illum\", 5) && IS_SPACE(token[5])) {\n      token += 6;\n      material.illum = parseInt(&token);\n      continue;\n    }\n\n    // dissolve\n    if ((token[0] == 'd' && IS_SPACE(token[1]))) {\n      token += 1;\n      material.dissolve = parseReal(&token);\n\n      if (has_tr) {\n        warn_ss << \"Both `d` and `Tr` parameters defined for \\\"\"\n                << material.name\n                << \"\\\". Use the value of `d` for dissolve (line \" << line_no\n                << \" in .mtl.)\\n\";\n      }\n      has_d = true;\n      continue;\n    }\n    if (token[0] == 'T' && token[1] == 'r' && IS_SPACE(token[2])) {\n      token += 2;\n      if (has_d) {\n        // `d` wins. Ignore `Tr` value.\n        warn_ss << \"Both `d` and `Tr` parameters defined for \\\"\"\n                << material.name\n                << \"\\\". Use the value of `d` for dissolve (line \" << line_no\n                << \" in .mtl.)\\n\";\n      } else {\n        // We invert value of Tr(assume Tr is in range [0, 1])\n        // NOTE: Interpretation of Tr is application(exporter) dependent. For\n        // some application(e.g. 3ds max obj exporter), Tr = d(Issue 43)\n        material.dissolve = static_cast<real_t>(1.0) - parseReal(&token);\n      }\n      has_tr = true;\n      continue;\n    }\n\n    // PBR: roughness\n    if (token[0] == 'P' && token[1] == 'r' && IS_SPACE(token[2])) {\n      token += 2;\n      material.roughness = parseReal(&token);\n      continue;\n    }\n\n    // PBR: metallic\n    if (token[0] == 'P' && token[1] == 'm' && IS_SPACE(token[2])) {\n      token += 2;\n      material.metallic = parseReal(&token);\n      continue;\n    }\n\n    // PBR: sheen\n    if (token[0] == 'P' && token[1] == 's' && IS_SPACE(token[2])) {\n      token += 2;\n      material.sheen = parseReal(&token);\n      continue;\n    }\n\n    // PBR: clearcoat thickness\n    if (token[0] == 'P' && token[1] == 'c' && IS_SPACE(token[2])) {\n      token += 2;\n      material.clearcoat_thickness = parseReal(&token);\n      continue;\n    }\n\n    // PBR: clearcoat roughness\n    if ((0 == strncmp(token, \"Pcr\", 3)) && IS_SPACE(token[3])) {\n      token += 4;\n      material.clearcoat_roughness = parseReal(&token);\n      continue;\n    }\n\n    // PBR: anisotropy\n    if ((0 == strncmp(token, \"aniso\", 5)) && IS_SPACE(token[5])) {\n      token += 6;\n      material.anisotropy = parseReal(&token);\n      continue;\n    }\n\n    // PBR: anisotropy rotation\n    if ((0 == strncmp(token, \"anisor\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      material.anisotropy_rotation = parseReal(&token);\n      continue;\n    }\n\n    // ambient or ambient occlusion texture\n    if ((0 == strncmp(token, \"map_Ka\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.ambient_texname),\n                                &(material.ambient_texopt), token);\n      continue;\n    }\n\n    // diffuse texture\n    if ((0 == strncmp(token, \"map_Kd\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.diffuse_texname),\n                                &(material.diffuse_texopt), token);\n\n      // Set a decent diffuse default value if a diffuse texture is specified\n      // without a matching Kd value.\n      if (!has_kd) {\n        material.diffuse[0] = static_cast<real_t>(0.6);\n        material.diffuse[1] = static_cast<real_t>(0.6);\n        material.diffuse[2] = static_cast<real_t>(0.6);\n      }\n\n      continue;\n    }\n\n    // specular texture\n    if ((0 == strncmp(token, \"map_Ks\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.specular_texname),\n                                &(material.specular_texopt), token);\n      continue;\n    }\n\n    // specular highlight texture\n    if ((0 == strncmp(token, \"map_Ns\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.specular_highlight_texname),\n                                &(material.specular_highlight_texopt), token);\n      continue;\n    }\n\n    // bump texture\n    if (((0 == strncmp(token, \"map_bump\", 8)) ||\n         (0 == strncmp(token, \"map_Bump\", 8))) &&\n        IS_SPACE(token[8])) {\n      token += 9;\n      ParseTextureNameAndOption(&(material.bump_texname),\n                                &(material.bump_texopt), token);\n      continue;\n    }\n\n    // bump texture\n    if ((0 == strncmp(token, \"bump\", 4)) && IS_SPACE(token[4])) {\n      token += 5;\n      ParseTextureNameAndOption(&(material.bump_texname),\n                                &(material.bump_texopt), token);\n      continue;\n    }\n\n    // alpha texture\n    if ((0 == strncmp(token, \"map_d\", 5)) && IS_SPACE(token[5])) {\n      token += 6;\n      material.alpha_texname = token;\n      ParseTextureNameAndOption(&(material.alpha_texname),\n                                &(material.alpha_texopt), token);\n      continue;\n    }\n\n    // displacement texture\n    if (((0 == strncmp(token, \"map_disp\", 8)) ||\n         (0 == strncmp(token, \"map_Disp\", 8))) &&\n        IS_SPACE(token[8])) {\n      token += 9;\n      ParseTextureNameAndOption(&(material.displacement_texname),\n                                &(material.displacement_texopt), token);\n      continue;\n    }\n\n    // displacement texture\n    if ((0 == strncmp(token, \"disp\", 4)) && IS_SPACE(token[4])) {\n      token += 5;\n      ParseTextureNameAndOption(&(material.displacement_texname),\n                                &(material.displacement_texopt), token);\n      continue;\n    }\n\n    // reflection map\n    if ((0 == strncmp(token, \"refl\", 4)) && IS_SPACE(token[4])) {\n      token += 5;\n      ParseTextureNameAndOption(&(material.reflection_texname),\n                                &(material.reflection_texopt), token);\n      continue;\n    }\n\n    // PBR: roughness texture\n    if ((0 == strncmp(token, \"map_Pr\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.roughness_texname),\n                                &(material.roughness_texopt), token);\n      continue;\n    }\n\n    // PBR: metallic texture\n    if ((0 == strncmp(token, \"map_Pm\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.metallic_texname),\n                                &(material.metallic_texopt), token);\n      continue;\n    }\n\n    // PBR: sheen texture\n    if ((0 == strncmp(token, \"map_Ps\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.sheen_texname),\n                                &(material.sheen_texopt), token);\n      continue;\n    }\n\n    // PBR: emissive texture\n    if ((0 == strncmp(token, \"map_Ke\", 6)) && IS_SPACE(token[6])) {\n      token += 7;\n      ParseTextureNameAndOption(&(material.emissive_texname),\n                                &(material.emissive_texopt), token);\n      continue;\n    }\n\n    // PBR: normal map texture\n    if ((0 == strncmp(token, \"norm\", 4)) && IS_SPACE(token[4])) {\n      token += 5;\n      ParseTextureNameAndOption(&(material.normal_texname),\n                                &(material.normal_texopt), token);\n      continue;\n    }\n\n    // unknown parameter\n    const char *_space = strchr(token, ' ');\n    if (!_space) {\n      _space = strchr(token, '\\t');\n    }\n    if (_space) {\n      std::ptrdiff_t len = _space - token;\n      std::string key(token, static_cast<size_t>(len));\n      std::string value = _space + 1;\n      material.unknown_parameter.insert(\n          std::pair<std::string, std::string>(key, value));\n    }\n  }\n  // flush last material.\n  material_map->insert(std::pair<std::string, int>(\n      material.name, static_cast<int>(materials->size())));\n  materials->push_back(material);\n\n  if (warning) {\n    (*warning) = warn_ss.str();\n  }\n}\n\nbool MaterialFileReader::operator()(const std::string &matId,\n                                    std::vector<material_t> *materials,\n                                    std::map<std::string, int> *matMap,\n                                    std::string *warn, std::string *err) {\n  if (!m_mtlBaseDir.empty()) {\n#ifdef _WIN32\n    char sep = ';';\n#else\n    char sep = ':';\n#endif\n\n    // https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g\n    std::vector<std::string> paths;\n    std::istringstream f(m_mtlBaseDir);\n\n    std::string s;\n    while (getline(f, s, sep)) {\n      paths.push_back(s);\n    }\n\n    for (size_t i = 0; i < paths.size(); i++) {\n      std::string filepath = JoinPath(paths[i], matId);\n\n      std::ifstream matIStream(filepath.c_str());\n      if (matIStream) {\n        LoadMtl(matMap, materials, &matIStream, warn, err);\n\n        return true;\n      }\n    }\n\n    std::stringstream ss;\n    ss << \"Material file [ \" << matId\n       << \" ] not found in a path : \" << m_mtlBaseDir << \"\\n\";\n    if (warn) {\n      (*warn) += ss.str();\n    }\n    return false;\n\n  } else {\n    std::string filepath = matId;\n    std::ifstream matIStream(filepath.c_str());\n    if (matIStream) {\n      LoadMtl(matMap, materials, &matIStream, warn, err);\n\n      return true;\n    }\n\n    std::stringstream ss;\n    ss << \"Material file [ \" << filepath\n       << \" ] not found in a path : \" << m_mtlBaseDir << \"\\n\";\n    if (warn) {\n      (*warn) += ss.str();\n    }\n\n    return false;\n  }\n}\n\nbool MaterialStreamReader::operator()(const std::string &matId,\n                                      std::vector<material_t> *materials,\n                                      std::map<std::string, int> *matMap,\n                                      std::string *warn, std::string *err) {\n  (void)err;\n  (void)matId;\n  if (!m_inStream) {\n    std::stringstream ss;\n    ss << \"Material stream in error state. \\n\";\n    if (warn) {\n      (*warn) += ss.str();\n    }\n    return false;\n  }\n\n  LoadMtl(matMap, materials, &m_inStream, warn, err);\n\n  return true;\n}\n\nbool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,\n             std::vector<material_t> *materials, std::string *warn,\n             std::string *err, const char *filename, const char *mtl_basedir,\n             bool triangulate, bool default_vcols_fallback) {\n  attrib->vertices.clear();\n  attrib->normals.clear();\n  attrib->texcoords.clear();\n  attrib->colors.clear();\n  shapes->clear();\n\n  std::stringstream errss;\n\n  std::ifstream ifs(filename);\n  if (!ifs) {\n    errss << \"Cannot open file [\" << filename << \"]\\n\";\n    if (err) {\n      (*err) = errss.str();\n    }\n    return false;\n  }\n\n  std::string baseDir = mtl_basedir ? mtl_basedir : \"\";\n  if (!baseDir.empty()) {\n#ifndef _WIN32\n    const char dirsep = '/';\n#else\n    const char dirsep = '\\\\';\n#endif\n    if (baseDir[baseDir.length() - 1] != dirsep) baseDir += dirsep;\n  }\n  MaterialFileReader matFileReader(baseDir);\n\n  return LoadObj(attrib, shapes, materials, warn, err, &ifs, &matFileReader,\n                 triangulate, default_vcols_fallback);\n}\n\nbool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,\n             std::vector<material_t> *materials, std::string *warn,\n             std::string *err, std::istream *inStream,\n             MaterialReader *readMatFn /*= NULL*/, bool triangulate,\n             bool default_vcols_fallback) {\n  std::stringstream errss;\n\n  std::vector<real_t> v;\n  std::vector<real_t> vertex_weights;  // optional [w] component in `v`\n  std::vector<real_t> vn;\n  std::vector<real_t> vt;\n  std::vector<real_t> vc;\n  std::vector<skin_weight_t> vw;  // tinyobj extension: vertex skin weights\n  std::vector<tag_t> tags;\n  PrimGroup prim_group;\n  std::string name;\n\n  // material\n  std::set<std::string> material_filenames;\n  std::map<std::string, int> material_map;\n  int material = -1;\n\n  // smoothing group id\n  unsigned int current_smoothing_id =\n      0;  // Initial value. 0 means no smoothing.\n\n  int greatest_v_idx = -1;\n  int greatest_vn_idx = -1;\n  int greatest_vt_idx = -1;\n\n  shape_t shape;\n\n  bool found_all_colors = true;  // check if all 'v' line has color info\n\n  size_t line_num = 0;\n  std::string linebuf;\n  while (inStream->peek() != -1) {\n    safeGetline(*inStream, linebuf);\n\n    line_num++;\n\n    // Trim newline '\\r\\n' or '\\n'\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\n')\n        linebuf.erase(linebuf.size() - 1);\n    }\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\r')\n        linebuf.erase(linebuf.size() - 1);\n    }\n\n    // Skip if empty line.\n    if (linebuf.empty()) {\n      continue;\n    }\n\n    // Skip leading space.\n    const char *token = linebuf.c_str();\n    token += strspn(token, \" \\t\");\n\n    assert(token);\n    if (token[0] == '\\0') continue;  // empty line\n\n    if (token[0] == '#') continue;  // comment line\n\n    // vertex\n    if (token[0] == 'v' && IS_SPACE((token[1]))) {\n      token += 2;\n      real_t x, y, z;\n      real_t r, g, b;\n\n      int num_components = parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token);\n      found_all_colors &= (num_components == 6);\n\n      v.push_back(x);\n      v.push_back(y);\n      v.push_back(z);\n\n      vertex_weights.push_back(\n          r);  // r = w, and initialized to 1.0 when `w` component is not found.\n\n      if ((num_components == 6) || default_vcols_fallback) {\n        vc.push_back(r);\n        vc.push_back(g);\n        vc.push_back(b);\n      }\n\n      continue;\n    }\n\n    // normal\n    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {\n      token += 3;\n      real_t x, y, z;\n      parseReal3(&x, &y, &z, &token);\n      vn.push_back(x);\n      vn.push_back(y);\n      vn.push_back(z);\n      continue;\n    }\n\n    // texcoord\n    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {\n      token += 3;\n      real_t x, y;\n      parseReal2(&x, &y, &token);\n      vt.push_back(x);\n      vt.push_back(y);\n      continue;\n    }\n\n    // skin weight. tinyobj extension\n    if (token[0] == 'v' && token[1] == 'w' && IS_SPACE((token[2]))) {\n      token += 3;\n\n      // vw <vid> <joint_0> <weight_0> <joint_1> <weight_1> ...\n      // example:\n      // vw 0 0 0.25 1 0.25 2 0.5\n\n      // TODO(syoyo): Add syntax check\n      int vid = 0;\n      vid = parseInt(&token);\n\n      skin_weight_t sw;\n\n      sw.vertex_id = vid;\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        real_t j, w;\n        // joint_id should not be negative, weight may be negative\n        // TODO(syoyo): # of elements check\n        parseReal2(&j, &w, &token, -1.0);\n\n        if (j < static_cast<real_t>(0)) {\n          if (err) {\n            std::stringstream ss;\n            ss << \"Failed parse `vw' line. joint_id is negative. \"\n                  \"line \"\n               << line_num << \".)\\n\";\n            (*err) += ss.str();\n          }\n          return false;\n        }\n\n        joint_and_weight_t jw;\n\n        jw.joint_id = int(j);\n        jw.weight = w;\n\n        sw.weightValues.push_back(jw);\n\n        size_t n = strspn(token, \" \\t\\r\");\n        token += n;\n      }\n\n      vw.push_back(sw);\n    }\n\n    warning_context context;\n    context.warn = warn;\n    context.line_number = line_num;\n\n    // line\n    if (token[0] == 'l' && IS_SPACE((token[1]))) {\n      token += 2;\n\n      __line_t line;\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        vertex_index_t vi;\n        if (!parseTriple(&token, static_cast<int>(v.size() / 3),\n                         static_cast<int>(vn.size() / 3),\n                         static_cast<int>(vt.size() / 2), &vi, context)) {\n          if (err) {\n            (*err) +=\n                \"Failed to parse `l' line (e.g. a zero value for vertex index. \"\n                \"Line \" +\n                toString(line_num) + \").\\n\";\n          }\n          return false;\n        }\n\n        line.vertex_indices.push_back(vi);\n\n        size_t n = strspn(token, \" \\t\\r\");\n        token += n;\n      }\n\n      prim_group.lineGroup.push_back(line);\n\n      continue;\n    }\n\n    // points\n    if (token[0] == 'p' && IS_SPACE((token[1]))) {\n      token += 2;\n\n      __points_t pts;\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        vertex_index_t vi;\n        if (!parseTriple(&token, static_cast<int>(v.size() / 3),\n                         static_cast<int>(vn.size() / 3),\n                         static_cast<int>(vt.size() / 2), &vi, context)) {\n          if (err) {\n            (*err) +=\n                \"Failed to parse `p' line (e.g. a zero value for vertex index. \"\n                \"Line \" +\n                toString(line_num) + \").\\n\";\n          }\n          return false;\n        }\n\n        pts.vertex_indices.push_back(vi);\n\n        size_t n = strspn(token, \" \\t\\r\");\n        token += n;\n      }\n\n      prim_group.pointsGroup.push_back(pts);\n\n      continue;\n    }\n\n    // face\n    if (token[0] == 'f' && IS_SPACE((token[1]))) {\n      token += 2;\n      token += strspn(token, \" \\t\");\n\n      face_t face;\n\n      face.smoothing_group_id = current_smoothing_id;\n      face.vertex_indices.reserve(3);\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        vertex_index_t vi;\n        if (!parseTriple(&token, static_cast<int>(v.size() / 3),\n                         static_cast<int>(vn.size() / 3),\n                         static_cast<int>(vt.size() / 2), &vi, context)) {\n          if (err) {\n            (*err) +=\n                \"Failed to parse `f' line (e.g. a zero value for vertex index \"\n                \"or invalid relative vertex index). Line \" +\n                toString(line_num) + \").\\n\";\n          }\n          return false;\n        }\n\n        greatest_v_idx = greatest_v_idx > vi.v_idx ? greatest_v_idx : vi.v_idx;\n        greatest_vn_idx =\n            greatest_vn_idx > vi.vn_idx ? greatest_vn_idx : vi.vn_idx;\n        greatest_vt_idx =\n            greatest_vt_idx > vi.vt_idx ? greatest_vt_idx : vi.vt_idx;\n\n        face.vertex_indices.push_back(vi);\n        size_t n = strspn(token, \" \\t\\r\");\n        token += n;\n      }\n\n      // replace with emplace_back + std::move on C++11\n      prim_group.faceGroup.push_back(face);\n\n      continue;\n    }\n\n    // use mtl\n    if ((0 == strncmp(token, \"usemtl\", 6))) {\n      token += 6;\n      std::string namebuf = parseString(&token);\n\n      int newMaterialId = -1;\n      std::map<std::string, int>::const_iterator it =\n          material_map.find(namebuf);\n      if (it != material_map.end()) {\n        newMaterialId = it->second;\n      } else {\n        // { error!! material not found }\n        if (warn) {\n          (*warn) += \"material [ '\" + namebuf + \"' ] not found in .mtl\\n\";\n        }\n      }\n\n      if (newMaterialId != material) {\n        // Create per-face material. Thus we don't add `shape` to `shapes` at\n        // this time.\n        // just clear `faceGroup` after `exportGroupsToShape()` call.\n        exportGroupsToShape(&shape, prim_group, tags, material, name,\n                            triangulate, v, warn);\n        prim_group.faceGroup.clear();\n        material = newMaterialId;\n      }\n\n      continue;\n    }\n\n    // load mtl\n    if ((0 == strncmp(token, \"mtllib\", 6)) && IS_SPACE((token[6]))) {\n      if (readMatFn) {\n        token += 7;\n\n        std::vector<std::string> filenames;\n        SplitString(std::string(token), ' ', '\\\\', filenames);\n\n        if (filenames.empty()) {\n          if (warn) {\n            std::stringstream ss;\n            ss << \"Looks like empty filename for mtllib. Use default \"\n                  \"material (line \"\n               << line_num << \".)\\n\";\n\n            (*warn) += ss.str();\n          }\n        } else {\n          bool found = false;\n          for (size_t s = 0; s < filenames.size(); s++) {\n            if (material_filenames.count(filenames[s]) > 0) {\n              found = true;\n              continue;\n            }\n\n            std::string warn_mtl;\n            std::string err_mtl;\n            bool ok = (*readMatFn)(filenames[s].c_str(), materials,\n                                   &material_map, &warn_mtl, &err_mtl);\n            if (warn && (!warn_mtl.empty())) {\n              (*warn) += warn_mtl;\n            }\n\n            if (err && (!err_mtl.empty())) {\n              (*err) += err_mtl;\n            }\n\n            if (ok) {\n              found = true;\n              material_filenames.insert(filenames[s]);\n              break;\n            }\n          }\n\n          if (!found) {\n            if (warn) {\n              (*warn) +=\n                  \"Failed to load material file(s). Use default \"\n                  \"material.\\n\";\n            }\n          }\n        }\n      }\n\n      continue;\n    }\n\n    // group name\n    if (token[0] == 'g' && IS_SPACE((token[1]))) {\n      // flush previous face group.\n      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,\n                                     triangulate, v, warn);\n      (void)ret;  // return value not used.\n\n      if (shape.mesh.indices.size() > 0) {\n        shapes->push_back(shape);\n      }\n\n      shape = shape_t();\n\n      // material = -1;\n      prim_group.clear();\n\n      std::vector<std::string> names;\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        std::string str = parseString(&token);\n        names.push_back(str);\n        token += strspn(token, \" \\t\\r\");  // skip tag\n      }\n\n      // names[0] must be 'g'\n\n      if (names.size() < 2) {\n        // 'g' with empty names\n        if (warn) {\n          std::stringstream ss;\n          ss << \"Empty group name. line: \" << line_num << \"\\n\";\n          (*warn) += ss.str();\n          name = \"\";\n        }\n      } else {\n        std::stringstream ss;\n        ss << names[1];\n\n        // tinyobjloader does not support multiple groups for a primitive.\n        // Currently we concatinate multiple group names with a space to get\n        // single group name.\n\n        for (size_t i = 2; i < names.size(); i++) {\n          ss << \" \" << names[i];\n        }\n\n        name = ss.str();\n      }\n\n      continue;\n    }\n\n    // object name\n    if (token[0] == 'o' && IS_SPACE((token[1]))) {\n      // flush previous face group.\n      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,\n                                     triangulate, v, warn);\n      (void)ret;  // return value not used.\n\n      if (shape.mesh.indices.size() > 0 || shape.lines.indices.size() > 0 ||\n          shape.points.indices.size() > 0) {\n        shapes->push_back(shape);\n      }\n\n      // material = -1;\n      prim_group.clear();\n      shape = shape_t();\n\n      // @todo { multiple object name? }\n      token += 2;\n      std::stringstream ss;\n      ss << token;\n      name = ss.str();\n\n      continue;\n    }\n\n    if (token[0] == 't' && IS_SPACE(token[1])) {\n      const int max_tag_nums = 8192;  // FIXME(syoyo): Parameterize.\n      tag_t tag;\n\n      token += 2;\n\n      tag.name = parseString(&token);\n\n      tag_sizes ts = parseTagTriple(&token);\n\n      if (ts.num_ints < 0) {\n        ts.num_ints = 0;\n      }\n      if (ts.num_ints > max_tag_nums) {\n        ts.num_ints = max_tag_nums;\n      }\n\n      if (ts.num_reals < 0) {\n        ts.num_reals = 0;\n      }\n      if (ts.num_reals > max_tag_nums) {\n        ts.num_reals = max_tag_nums;\n      }\n\n      if (ts.num_strings < 0) {\n        ts.num_strings = 0;\n      }\n      if (ts.num_strings > max_tag_nums) {\n        ts.num_strings = max_tag_nums;\n      }\n\n      tag.intValues.resize(static_cast<size_t>(ts.num_ints));\n\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {\n        tag.intValues[i] = parseInt(&token);\n      }\n\n      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {\n        tag.floatValues[i] = parseReal(&token);\n      }\n\n      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {\n        tag.stringValues[i] = parseString(&token);\n      }\n\n      tags.push_back(tag);\n\n      continue;\n    }\n\n    if (token[0] == 's' && IS_SPACE(token[1])) {\n      // smoothing group id\n      token += 2;\n\n      // skip space.\n      token += strspn(token, \" \\t\");  // skip space\n\n      if (token[0] == '\\0') {\n        continue;\n      }\n\n      if (token[0] == '\\r' || token[1] == '\\n') {\n        continue;\n      }\n\n      if (strlen(token) >= 3 && token[0] == 'o' && token[1] == 'f' &&\n          token[2] == 'f') {\n        current_smoothing_id = 0;\n      } else {\n        // assume number\n        int smGroupId = parseInt(&token);\n        if (smGroupId < 0) {\n          // parse error. force set to 0.\n          // FIXME(syoyo): Report warning.\n          current_smoothing_id = 0;\n        } else {\n          current_smoothing_id = static_cast<unsigned int>(smGroupId);\n        }\n      }\n\n      continue;\n    }  // smoothing group id\n\n    // Ignore unknown command.\n  }\n\n  // not all vertices have colors, no default colors desired? -> clear colors\n  if (!found_all_colors && !default_vcols_fallback) {\n    vc.clear();\n  }\n\n  if (greatest_v_idx >= static_cast<int>(v.size() / 3)) {\n    if (warn) {\n      std::stringstream ss;\n      ss << \"Vertex indices out of bounds (line \" << line_num << \".)\\n\\n\";\n      (*warn) += ss.str();\n    }\n  }\n  if (greatest_vn_idx >= static_cast<int>(vn.size() / 3)) {\n    if (warn) {\n      std::stringstream ss;\n      ss << \"Vertex normal indices out of bounds (line \" << line_num\n         << \".)\\n\\n\";\n      (*warn) += ss.str();\n    }\n  }\n  if (greatest_vt_idx >= static_cast<int>(vt.size() / 2)) {\n    if (warn) {\n      std::stringstream ss;\n      ss << \"Vertex texcoord indices out of bounds (line \" << line_num\n         << \".)\\n\\n\";\n      (*warn) += ss.str();\n    }\n  }\n\n  bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,\n                                 triangulate, v, warn);\n  // exportGroupsToShape return false when `usemtl` is called in the last\n  // line.\n  // we also add `shape` to `shapes` when `shape.mesh` has already some\n  // faces(indices)\n  if (ret || shape.mesh.indices\n                 .size()) {  // FIXME(syoyo): Support other prims(e.g. lines)\n    shapes->push_back(shape);\n  }\n  prim_group.clear();  // for safety\n\n  if (err) {\n    (*err) += errss.str();\n  }\n\n  attrib->vertices.swap(v);\n  attrib->vertex_weights.swap(vertex_weights);\n  attrib->normals.swap(vn);\n  attrib->texcoords.swap(vt);\n  attrib->texcoord_ws.swap(vt);\n  attrib->colors.swap(vc);\n  attrib->skin_weights.swap(vw);\n\n  return true;\n}\n\nbool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,\n                         void *user_data /*= NULL*/,\n                         MaterialReader *readMatFn /*= NULL*/,\n                         std::string *warn, /* = NULL*/\n                         std::string *err /*= NULL*/) {\n  std::stringstream errss;\n\n  // material\n  std::set<std::string> material_filenames;\n  std::map<std::string, int> material_map;\n  int material_id = -1;  // -1 = invalid\n\n  std::vector<index_t> indices;\n  std::vector<material_t> materials;\n  std::vector<std::string> names;\n  names.reserve(2);\n  std::vector<const char *> names_out;\n\n  std::string linebuf;\n  while (inStream.peek() != -1) {\n    safeGetline(inStream, linebuf);\n\n    // Trim newline '\\r\\n' or '\\n'\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\n')\n        linebuf.erase(linebuf.size() - 1);\n    }\n    if (linebuf.size() > 0) {\n      if (linebuf[linebuf.size() - 1] == '\\r')\n        linebuf.erase(linebuf.size() - 1);\n    }\n\n    // Skip if empty line.\n    if (linebuf.empty()) {\n      continue;\n    }\n\n    // Skip leading space.\n    const char *token = linebuf.c_str();\n    token += strspn(token, \" \\t\");\n\n    assert(token);\n    if (token[0] == '\\0') continue;  // empty line\n\n    if (token[0] == '#') continue;  // comment line\n\n    // vertex\n    if (token[0] == 'v' && IS_SPACE((token[1]))) {\n      token += 2;\n      real_t x, y, z;\n      real_t r, g, b;\n\n      int num_components = parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token);\n      if (callback.vertex_cb) {\n        callback.vertex_cb(user_data, x, y, z, r);  // r=w is optional\n      }\n      if (callback.vertex_color_cb) {\n        bool found_color = (num_components == 6);\n        callback.vertex_color_cb(user_data, x, y, z, r, g, b, found_color);\n      }\n      continue;\n    }\n\n    // normal\n    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {\n      token += 3;\n      real_t x, y, z;\n      parseReal3(&x, &y, &z, &token);\n      if (callback.normal_cb) {\n        callback.normal_cb(user_data, x, y, z);\n      }\n      continue;\n    }\n\n    // texcoord\n    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {\n      token += 3;\n      real_t x, y, z;  // y and z are optional. default = 0.0\n      parseReal3(&x, &y, &z, &token);\n      if (callback.texcoord_cb) {\n        callback.texcoord_cb(user_data, x, y, z);\n      }\n      continue;\n    }\n\n    // face\n    if (token[0] == 'f' && IS_SPACE((token[1]))) {\n      token += 2;\n      token += strspn(token, \" \\t\");\n\n      indices.clear();\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        vertex_index_t vi = parseRawTriple(&token);\n\n        index_t idx;\n        idx.vertex_index = vi.v_idx;\n        idx.normal_index = vi.vn_idx;\n        idx.texcoord_index = vi.vt_idx;\n\n        indices.push_back(idx);\n        size_t n = strspn(token, \" \\t\\r\");\n        token += n;\n      }\n\n      if (callback.index_cb && indices.size() > 0) {\n        callback.index_cb(user_data, &indices.at(0),\n                          static_cast<int>(indices.size()));\n      }\n\n      continue;\n    }\n\n    // use mtl\n    if ((0 == strncmp(token, \"usemtl\", 6)) && IS_SPACE((token[6]))) {\n      token += 7;\n      std::stringstream ss;\n      ss << token;\n      std::string namebuf = ss.str();\n\n      int newMaterialId = -1;\n      std::map<std::string, int>::const_iterator it =\n          material_map.find(namebuf);\n      if (it != material_map.end()) {\n        newMaterialId = it->second;\n      } else {\n        // { warn!! material not found }\n        if (warn && (!callback.usemtl_cb)) {\n          (*warn) += \"material [ \" + namebuf + \" ] not found in .mtl\\n\";\n        }\n      }\n\n      if (newMaterialId != material_id) {\n        material_id = newMaterialId;\n      }\n\n      if (callback.usemtl_cb) {\n        callback.usemtl_cb(user_data, namebuf.c_str(), material_id);\n      }\n\n      continue;\n    }\n\n    // load mtl\n    if ((0 == strncmp(token, \"mtllib\", 6)) && IS_SPACE((token[6]))) {\n      if (readMatFn) {\n        token += 7;\n\n        std::vector<std::string> filenames;\n        SplitString(std::string(token), ' ', '\\\\', filenames);\n\n        if (filenames.empty()) {\n          if (warn) {\n            (*warn) +=\n                \"Looks like empty filename for mtllib. Use default \"\n                \"material. \\n\";\n          }\n        } else {\n          bool found = false;\n          for (size_t s = 0; s < filenames.size(); s++) {\n            if (material_filenames.count(filenames[s]) > 0) {\n              found = true;\n              continue;\n            }\n\n            std::string warn_mtl;\n            std::string err_mtl;\n            bool ok = (*readMatFn)(filenames[s].c_str(), &materials,\n                                   &material_map, &warn_mtl, &err_mtl);\n\n            if (warn && (!warn_mtl.empty())) {\n              (*warn) += warn_mtl;  // This should be warn message.\n            }\n\n            if (err && (!err_mtl.empty())) {\n              (*err) += err_mtl;\n            }\n\n            if (ok) {\n              found = true;\n              material_filenames.insert(filenames[s]);\n              break;\n            }\n          }\n\n          if (!found) {\n            if (warn) {\n              (*warn) +=\n                  \"Failed to load material file(s). Use default \"\n                  \"material.\\n\";\n            }\n          } else {\n            if (callback.mtllib_cb) {\n              callback.mtllib_cb(user_data, &materials.at(0),\n                                 static_cast<int>(materials.size()));\n            }\n          }\n        }\n      }\n\n      continue;\n    }\n\n    // group name\n    if (token[0] == 'g' && IS_SPACE((token[1]))) {\n      names.clear();\n\n      while (!IS_NEW_LINE(token[0]) && token[0] != '#') {\n        std::string str = parseString(&token);\n        names.push_back(str);\n        token += strspn(token, \" \\t\\r\");  // skip tag\n      }\n\n      assert(names.size() > 0);\n\n      if (callback.group_cb) {\n        if (names.size() > 1) {\n          // create const char* array.\n          names_out.resize(names.size() - 1);\n          for (size_t j = 0; j < names_out.size(); j++) {\n            names_out[j] = names[j + 1].c_str();\n          }\n          callback.group_cb(user_data, &names_out.at(0),\n                            static_cast<int>(names_out.size()));\n\n        } else {\n          callback.group_cb(user_data, NULL, 0);\n        }\n      }\n\n      continue;\n    }\n\n    // object name\n    if (token[0] == 'o' && IS_SPACE((token[1]))) {\n      // @todo { multiple object name? }\n      token += 2;\n\n      std::stringstream ss;\n      ss << token;\n      std::string object_name = ss.str();\n\n      if (callback.object_cb) {\n        callback.object_cb(user_data, object_name.c_str());\n      }\n\n      continue;\n    }\n\n#if 0  // @todo\n    if (token[0] == 't' && IS_SPACE(token[1])) {\n      tag_t tag;\n\n      token += 2;\n      std::stringstream ss;\n      ss << token;\n      tag.name = ss.str();\n\n      token += tag.name.size() + 1;\n\n      tag_sizes ts = parseTagTriple(&token);\n\n      tag.intValues.resize(static_cast<size_t>(ts.num_ints));\n\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {\n        tag.intValues[i] = atoi(token);\n        token += strcspn(token, \"/ \\t\\r\") + 1;\n      }\n\n      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {\n        tag.floatValues[i] = parseReal(&token);\n        token += strcspn(token, \"/ \\t\\r\") + 1;\n      }\n\n      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));\n      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {\n        std::stringstream ss;\n        ss << token;\n        tag.stringValues[i] = ss.str();\n        token += tag.stringValues[i].size() + 1;\n      }\n\n      tags.push_back(tag);\n    }\n#endif\n\n    // Ignore unknown command.\n  }\n\n  if (err) {\n    (*err) += errss.str();\n  }\n\n  return true;\n}\n\nbool ObjReader::ParseFromFile(const std::string &filename,\n                              const ObjReaderConfig &config) {\n  std::string mtl_search_path;\n\n  if (config.mtl_search_path.empty()) {\n    //\n    // split at last '/'(for unixish system) or '\\\\'(for windows) to get\n    // the base directory of .obj file\n    //\n    size_t pos = filename.find_last_of(\"/\\\\\");\n    if (pos != std::string::npos) {\n      mtl_search_path = filename.substr(0, pos);\n    }\n  } else {\n    mtl_search_path = config.mtl_search_path;\n  }\n\n  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,\n                   filename.c_str(), mtl_search_path.c_str(),\n                   config.triangulate, config.vertex_color);\n\n  return valid_;\n}\n\nbool ObjReader::ParseFromString(const std::string &obj_text,\n                                const std::string &mtl_text,\n                                const ObjReaderConfig &config) {\n  std::stringbuf obj_buf(obj_text);\n  std::stringbuf mtl_buf(mtl_text);\n\n  std::istream obj_ifs(&obj_buf);\n  std::istream mtl_ifs(&mtl_buf);\n\n  MaterialStreamReader mtl_ss(mtl_ifs);\n\n  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,\n                   &obj_ifs, &mtl_ss, config.triangulate, config.vertex_color);\n\n  return valid_;\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n}  // namespace tinyobj\n\n#endif\n"
        },
        {
          "name": "tinyobjloader-config.cmake.in",
          "type": "blob",
          "size": 0.3330078125,
          "content": "@PACKAGE_INIT@\n\nset(TINYOBJLOADER_VERSION \"@TINYOBJLOADER_VERSION@\")\n\nset_and_check(TINYOBJLOADER_INCLUDE_DIRS \"@PACKAGE_TINYOBJLOADER_INCLUDE_DIR@\")\nset_and_check(TINYOBJLOADER_LIBRARY_DIRS \"@PACKAGE_TINYOBJLOADER_LIBRARY_DIR@\")\nset(TINYOBJLOADER_LIBRARIES @LIBRARY_NAME@)\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@-targets.cmake\")\n"
        },
        {
          "name": "tinyobjloader.pc.in",
          "type": "blob",
          "size": 0.525390625,
          "content": "# Generated by CMake @CMAKE_VERSION@ for @PROJECT_NAME@. Any changes to this\n# file will be overwritten by the next CMake run. The input file was\n# tinyobjloader.pc.in.\n\nprefix=@CMAKE_INSTALL_PREFIX@\nexec_prefix=${prefix}\nlibdir=${prefix}/@TINYOBJLOADER_LIBRARY_DIR@\nincludedir=${prefix}/@TINYOBJLOADER_INCLUDE_DIR@\n\nName: @PROJECT_NAME@\nDescription: Tiny but powerful single file wavefront obj loader\nURL: https://syoyo.github.io/tinyobjloader/\nVersion: @TINYOBJLOADER_VERSION@\nLibs: -L${libdir} -l@LIBRARY_NAME@\nCflags: -I${includedir}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "vcsetup.bat",
          "type": "blob",
          "size": 0.0380859375,
          "content": ".\\\\tools\\\\windows\\\\premake5.exe vs2013\n"
        }
      ]
    }
  ]
}