{
  "metadata": {
    "timestamp": 1736565451721,
    "page": 303,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "CedricGuillemet/ImGuizmo",
      "stars": 3292,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1826171875,
          "content": "root = true\n\n[*]\nindent_style    = space\nindent_size     = 3\nend_of_line     = lf\ninsert_final_newline     = true\ntrim_trailing_whitespace = true\n\n[*.md]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.068359375,
          "content": "build/\n.*/\n*.vcxproj.user\nexample/x64/\nexample/x86/\nexample/imgui.ini\n"
        },
        {
          "name": "GraphEditor.cpp",
          "type": "blob",
          "size": 43.8828125,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n#define IMGUI_DEFINE_MATH_OPERATORS\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n#include <math.h>\n#include <vector>\n#include <float.h>\n#include <array>\n#include \"GraphEditor.h\"\n\nnamespace GraphEditor {\n\nstatic inline float Distance(const ImVec2& a, const ImVec2& b)\n{\n    return sqrtf((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstatic inline float sign(float v)\n{\n    return (v >= 0.f) ? 1.f : -1.f;\n}\n\nstatic ImVec2 GetInputSlotPos(Delegate& delegate, const Node& node, SlotIndex slotIndex, float factor)\n{\n    ImVec2 Size = node.mRect.GetSize() * factor;\n    size_t InputsCount = delegate.GetTemplate(node.mTemplateIndex).mInputCount;\n    return ImVec2(node.mRect.Min.x * factor,\n                  node.mRect.Min.y * factor + Size.y * ((float)slotIndex + 1) / ((float)InputsCount + 1) + 8.f);\n}\n\nstatic ImVec2 GetOutputSlotPos(Delegate& delegate, const Node& node, SlotIndex slotIndex, float factor)\n{\n    ImVec2 Size = node.mRect.GetSize() * factor;\n    size_t OutputsCount = delegate.GetTemplate(node.mTemplateIndex).mOutputCount;\n    return ImVec2(node.mRect.Min.x * factor + Size.x,\n                  node.mRect.Min.y * factor + Size.y * ((float)slotIndex + 1) / ((float)OutputsCount + 1) + 8.f);\n}\n\nstatic ImRect GetNodeRect(const Node& node, float factor)\n{\n    ImVec2 Size = node.mRect.GetSize() * factor;\n    return ImRect(node.mRect.Min * factor, node.mRect.Min * factor + Size);\n}\n\nstatic ImVec2 editingNodeSource;\nstatic bool editingInput = false;\nstatic ImVec2 captureOffset;\n\nenum NodeOperation\n{\n    NO_None,\n    NO_EditingLink,\n    NO_QuadSelecting,\n    NO_MovingNodes,\n    NO_EditInput,\n    NO_PanView,\n};\nstatic NodeOperation nodeOperation = NO_None;\n\nstatic void HandleZoomScroll(ImRect regionRect, ViewState& viewState, const Options& options)\n{\n    ImGuiIO& io = ImGui::GetIO();\n\n    if (regionRect.Contains(io.MousePos))\n    {\n        if (io.MouseWheel < -FLT_EPSILON)\n        {\n            viewState.mFactorTarget *= 1.f - options.mZoomRatio;\n        }\n\n        if (io.MouseWheel > FLT_EPSILON)\n        {\n            viewState.mFactorTarget *= 1.0f + options.mZoomRatio;\n        }\n    }\n\n    ImVec2 mouseWPosPre = (io.MousePos - ImGui::GetCursorScreenPos()) / viewState.mFactor;\n    viewState.mFactorTarget = ImClamp(viewState.mFactorTarget, options.mMinZoom, options.mMaxZoom);\n    viewState.mFactor = ImLerp(viewState.mFactor, viewState.mFactorTarget, options.mZoomLerpFactor);\n    ImVec2 mouseWPosPost = (io.MousePos - ImGui::GetCursorScreenPos()) / viewState.mFactor;\n    if (ImGui::IsMousePosValid())\n    {\n        viewState.mPosition += mouseWPosPost - mouseWPosPre;\n    }\n}\n\nvoid GraphEditorClear()\n{\n    nodeOperation = NO_None;\n}\n\nstatic void FitNodes(Delegate& delegate, ViewState& viewState, const ImVec2 viewSize, bool selectedNodesOnly)\n{\n    const size_t nodeCount = delegate.GetNodeCount();\n\n    if (!nodeCount)\n    {\n        return;\n    }\n\n    bool validNode = false;\n    ImVec2 min(FLT_MAX, FLT_MAX);\n    ImVec2 max(-FLT_MAX, -FLT_MAX);\n    for (NodeIndex nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n    {\n        const Node& node = delegate.GetNode(nodeIndex);\n        \n        if (selectedNodesOnly && !node.mSelected)\n        {\n            continue;\n        }\n        \n        min = ImMin(min, node.mRect.Min);\n        min = ImMin(min, node.mRect.Max);\n        max = ImMax(max, node.mRect.Min);\n        max = ImMax(max, node.mRect.Max);\n        validNode = true;\n    }\n    \n    if (!validNode)\n    {\n        return;\n    }\n    \n    min -= viewSize * 0.05f;\n    max += viewSize * 0.05f;\n    ImVec2 nodesSize = max - min;\n    ImVec2 nodeCenter = (max + min) * 0.5f;\n    \n    float ratioY = viewSize.y / nodesSize.y;\n    float ratioX = viewSize.x / nodesSize.x;\n\n    viewState.mFactor = viewState.mFactorTarget = ImMin(ImMin(ratioY, ratioX), 1.f);\n    viewState.mPosition = ImVec2(-nodeCenter.x, -nodeCenter.y) + (viewSize * 0.5f) / viewState.mFactorTarget;\n}\n\nstatic void DisplayLinks(Delegate& delegate,\n                         ImDrawList* drawList,\n                         const ImVec2 offset,\n                         const float factor,\n                         const ImRect regionRect,\n                         NodeIndex hoveredNode,\n                         const Options& options)\n{\n    const size_t linkCount = delegate.GetLinkCount();\n    for (LinkIndex linkIndex = 0; linkIndex < linkCount; linkIndex++)\n    {\n        const auto link = delegate.GetLink(linkIndex);\n        const auto nodeInput = delegate.GetNode(link.mInputNodeIndex);\n        const auto nodeOutput = delegate.GetNode(link.mOutputNodeIndex);\n        ImVec2 p1 = offset + GetOutputSlotPos(delegate, nodeInput, link.mInputSlotIndex, factor);\n        ImVec2 p2 = offset + GetInputSlotPos(delegate, nodeOutput, link.mOutputSlotIndex, factor);\n\n        // con. view clipping\n        if ((p1.y < 0.f && p2.y < 0.f) || (p1.y > regionRect.Max.y && p2.y > regionRect.Max.y) ||\n            (p1.x < 0.f && p2.x < 0.f) || (p1.x > regionRect.Max.x && p2.x > regionRect.Max.x))\n            continue;\n\n        bool highlightCons = hoveredNode == link.mInputNodeIndex || hoveredNode == link.mOutputNodeIndex;\n        uint32_t col = delegate.GetTemplate(nodeInput.mTemplateIndex).mHeaderColor | (highlightCons ? 0xF0F0F0 : 0);\n        if (options.mDisplayLinksAsCurves)\n        {\n            // curves\n             drawList->AddBezierCubic(p1, p1 + ImVec2(50, 0) * factor, p2 + ImVec2(-50, 0) * factor, p2, 0xFF000000, options.mLineThickness * 1.5f * factor);\n             drawList->AddBezierCubic(p1, p1 + ImVec2(50, 0) * factor, p2 + ImVec2(-50, 0) * factor, p2, col, options.mLineThickness * 1.5f * factor);\n             /*\n            ImVec2 p10 = p1 + ImVec2(20.f * factor, 0.f);\n            ImVec2 p20 = p2 - ImVec2(20.f * factor, 0.f);\n\n            ImVec2 dif = p20 - p10;\n            ImVec2 p1a, p1b;\n            if (fabsf(dif.x) > fabsf(dif.y))\n            {\n                p1a = p10 + ImVec2(fabsf(fabsf(dif.x) - fabsf(dif.y)) * 0.5 * sign(dif.x), 0.f);\n                p1b = p1a + ImVec2(fabsf(dif.y) * sign(dif.x) , dif.y);\n            }\n            else\n            {\n                p1a = p10 + ImVec2(0.f, fabsf(fabsf(dif.y) - fabsf(dif.x)) * 0.5 * sign(dif.y));\n                p1b = p1a + ImVec2(dif.x, fabsf(dif.x) * sign(dif.y));\n            }\n            drawList->AddLine(p1,  p10, col, 3.f * factor);\n            drawList->AddLine(p10, p1a, col, 3.f * factor);\n            drawList->AddLine(p1a, p1b, col, 3.f * factor);\n            drawList->AddLine(p1b, p20, col, 3.f * factor);\n            drawList->AddLine(p20,  p2, col, 3.f * factor);\n            */\n        }\n        else\n        {\n            // straight lines\n            std::array<ImVec2, 6> pts;\n            int ptCount = 0;\n            ImVec2 dif = p2 - p1;\n\n            ImVec2 p1a, p1b;\n            const float limitx = 12.f * factor;\n            if (dif.x < limitx)\n            {\n                ImVec2 p10 = p1 + ImVec2(limitx, 0.f);\n                ImVec2 p20 = p2 - ImVec2(limitx, 0.f);\n\n                dif = p20 - p10;\n                p1a = p10 + ImVec2(0.f, dif.y * 0.5f);\n                p1b = p1a + ImVec2(dif.x, 0.f);\n\n                pts = { p1, p10, p1a, p1b, p20, p2 };\n                ptCount = 6;\n            }\n            else\n            {\n                if (fabsf(dif.y) < 1.f)\n                {\n                    pts = { p1, (p1 + p2) * 0.5f, p2 };\n                    ptCount = 3;\n                }\n                else\n                {\n                    if (fabsf(dif.y) < 10.f)\n                    {\n                        if (fabsf(dif.x) > fabsf(dif.y))\n                        {\n                            p1a = p1 + ImVec2(fabsf(fabsf(dif.x) - fabsf(dif.y)) * 0.5f * sign(dif.x), 0.f);\n                            p1b = p1a + ImVec2(fabsf(dif.y) * sign(dif.x), dif.y);\n                        }\n                        else\n                        {\n                            p1a = p1 + ImVec2(0.f, fabsf(fabsf(dif.y) - fabsf(dif.x)) * 0.5f * sign(dif.y));\n                            p1b = p1a + ImVec2(dif.x, fabsf(dif.x) * sign(dif.y));\n                        }\n                    }\n                    else\n                    {\n                        if (fabsf(dif.x) > fabsf(dif.y))\n                        {\n                            float d = fabsf(dif.y) * sign(dif.x) * 0.5f;\n                            p1a = p1 + ImVec2(d, dif.y * 0.5f);\n                            p1b = p1a + ImVec2(fabsf(fabsf(dif.x) - fabsf(d) * 2.f) * sign(dif.x), 0.f);\n                        }\n                        else\n                        {\n                            float d = fabsf(dif.x) * sign(dif.y) * 0.5f;\n                            p1a = p1 + ImVec2(dif.x * 0.5f, d);\n                            p1b = p1a + ImVec2(0.f, fabsf(fabsf(dif.y) - fabsf(d) * 2.f) * sign(dif.y));\n                        }\n                    }\n                    pts = { p1, p1a, p1b, p2 };\n                    ptCount = 4;\n                }\n            }\n            float highLightFactor = factor * (highlightCons ? 2.0f : 1.f);\n            for (int pass = 0; pass < 2; pass++)\n            {\n                drawList->AddPolyline(pts.data(), ptCount, pass ? col : 0xFF000000, false, (pass ? options.mLineThickness : (options.mLineThickness * 1.5f)) * highLightFactor);\n            }\n        }\n    }\n}\n\nstatic void HandleQuadSelection(Delegate& delegate, ImDrawList* drawList, const ImVec2 offset, const float factor, ImRect contentRect, const Options& options)\n{\n    if (!options.mAllowQuadSelection)\n    {\n        return;\n    }\n    ImGuiIO& io = ImGui::GetIO();\n    static ImVec2 quadSelectPos;\n    //auto& nodes = delegate->GetNodes();\n    auto nodeCount = delegate.GetNodeCount();\n\n    if (nodeOperation == NO_QuadSelecting && ImGui::IsWindowFocused())\n    {\n        const ImVec2 bmin = ImMin(quadSelectPos, io.MousePos);\n        const ImVec2 bmax = ImMax(quadSelectPos, io.MousePos);\n        drawList->AddRectFilled(bmin, bmax, options.mQuadSelection, 1.f);\n        drawList->AddRect(bmin, bmax, options.mQuadSelectionBorder, 1.f);\n        if (!io.MouseDown[0])\n        {\n            if (!io.KeyCtrl && !io.KeyShift)\n            {\n                for (size_t nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n                {\n                    delegate.SelectNode(nodeIndex, false);\n                }\n            }\n\n            nodeOperation = NO_None;\n            ImRect selectionRect(bmin, bmax);\n            for (unsigned int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n            {\n                const auto node = delegate.GetNode(nodeIndex);\n                ImVec2 nodeRectangleMin = offset + node.mRect.Min * factor;\n                ImVec2 nodeRectangleMax = nodeRectangleMin + node.mRect.GetSize() * factor;\n                if (selectionRect.Overlaps(ImRect(nodeRectangleMin, nodeRectangleMax)))\n                {\n                    if (io.KeyCtrl)\n                    {\n                        delegate.SelectNode(nodeIndex, false);\n                    }\n                    else\n                    {\n                        delegate.SelectNode(nodeIndex, true);\n                    }\n                }\n                else\n                {\n                    if (!io.KeyShift)\n                    {\n                        delegate.SelectNode(nodeIndex, false);\n                    }\n                }\n            }\n        }\n    }\n    else if (nodeOperation == NO_None && io.MouseDown[0] && ImGui::IsWindowFocused() &&\n             contentRect.Contains(io.MousePos))\n    {\n        nodeOperation = NO_QuadSelecting;\n        quadSelectPos = io.MousePos;\n    }\n}\n\nstatic bool HandleConnections(ImDrawList* drawList,\n                       NodeIndex nodeIndex,\n                       const ImVec2 offset,\n                       const float factor,\n                       Delegate& delegate,\n                       const Options& options,\n                       bool bDrawOnly,\n                       SlotIndex& inputSlotOver,\n                       SlotIndex& outputSlotOver,\n                       const bool inMinimap)\n{\n    static NodeIndex editingNodeIndex;\n    static SlotIndex editingSlotIndex;\n\n    ImGuiIO& io = ImGui::GetIO();\n    const auto node = delegate.GetNode(nodeIndex);\n    const auto nodeTemplate = delegate.GetTemplate(node.mTemplateIndex);\n    const auto linkCount = delegate.GetLinkCount();\n\n    size_t InputsCount = nodeTemplate.mInputCount;\n    size_t OutputsCount = nodeTemplate.mOutputCount;\n    inputSlotOver = -1;\n    outputSlotOver = -1;\n\n    // draw/use inputs/outputs\n    bool hoverSlot = false;\n    for (int i = 0; i < 2; i++)\n    {\n        float closestDistance = FLT_MAX;\n        SlotIndex closestConn = -1;\n        ImVec2 closestTextPos;\n        ImVec2 closestPos;\n        const size_t slotCount[2] = {InputsCount, OutputsCount};\n        \n        for (SlotIndex slotIndex = 0; slotIndex < slotCount[i]; slotIndex++)\n        {\n            const char** con = i ? nodeTemplate.mOutputNames : nodeTemplate.mInputNames;\n            const char* conText = (con && con[slotIndex]) ? con[slotIndex] : \"\";\n\n            ImVec2 p =\n                offset + (i ? GetOutputSlotPos(delegate, node, slotIndex, factor) : GetInputSlotPos(delegate, node, slotIndex, factor));\n            float distance = Distance(p, io.MousePos);\n            bool overCon = (nodeOperation == NO_None || nodeOperation == NO_EditingLink) &&\n                           (distance < options.mNodeSlotRadius * 2.f) && (distance < closestDistance);\n\n            \n            ImVec2 textSize;\n            textSize = ImGui::CalcTextSize(conText);\n            ImVec2 textPos =\n                p + ImVec2(-options.mNodeSlotRadius * (i ? -1.f : 1.f) * (overCon ? 3.f : 2.f) - (i ? 0 : textSize.x),\n                           -textSize.y / 2);\n\n            ImRect nodeRect = GetNodeRect(node, factor);\n            if (!inMinimap && (overCon || (nodeRect.Contains(io.MousePos - offset) && closestConn == -1 &&\n                            (editingInput == (i != 0)) && nodeOperation == NO_EditingLink)))\n            {\n                closestDistance = distance;\n                closestConn = slotIndex;\n                closestTextPos = textPos;\n                closestPos = p;\n                \n                if (i)\n                {\n                    outputSlotOver = slotIndex;\n                }\n                else\n                {\n                    inputSlotOver = slotIndex;\n                }\n            }\n            else\n            {\n               const ImU32* slotColorSource = i ? nodeTemplate.mOutputColors : nodeTemplate.mInputColors;\n               const ImU32 slotColor = slotColorSource ? slotColorSource[slotIndex] : options.mDefaultSlotColor;\n               drawList->AddCircleFilled(p, options.mNodeSlotRadius, IM_COL32(0, 0, 0, 200));\n               drawList->AddCircleFilled(p, options.mNodeSlotRadius * 0.75f, slotColor);\n               if (!options.mDrawIONameOnHover)\n               {\n                    drawList->AddText(io.FontDefault, 14, textPos + ImVec2(2, 2), IM_COL32(0, 0, 0, 255), conText);\n                    drawList->AddText(io.FontDefault, 14, textPos, IM_COL32(150, 150, 150, 255), conText);\n               }\n            }\n        }\n\n        if (closestConn != -1)\n        {\n            const char** con = i ? nodeTemplate.mOutputNames : nodeTemplate.mInputNames;\n            const char* conText = (con && con[closestConn]) ? con[closestConn] : \"\";\n            const ImU32* slotColorSource = i ? nodeTemplate.mOutputColors : nodeTemplate.mInputColors;\n            const ImU32 slotColor = slotColorSource ? slotColorSource[closestConn] : options.mDefaultSlotColor;\n            hoverSlot = true;\n            drawList->AddCircleFilled(closestPos, options.mNodeSlotRadius * options.mNodeSlotHoverFactor * 0.75f, IM_COL32(0, 0, 0, 200));\n            drawList->AddCircleFilled(closestPos, options.mNodeSlotRadius * options.mNodeSlotHoverFactor, slotColor);\n            drawList->AddText(io.FontDefault, 16, closestTextPos + ImVec2(1, 1), IM_COL32(0, 0, 0, 255), conText);\n            drawList->AddText(io.FontDefault, 16, closestTextPos, IM_COL32(250, 250, 250, 255), conText);\n            bool inputToOutput = (!editingInput && !i) || (editingInput && i);\n            if (nodeOperation == NO_EditingLink && !io.MouseDown[0] && !bDrawOnly)\n            {\n                if (inputToOutput)\n                {\n                    // check loopback\n                    Link nl;\n                    if (editingInput)\n                        nl = Link{nodeIndex, closestConn, editingNodeIndex, editingSlotIndex};\n                    else\n                        nl = Link{editingNodeIndex, editingSlotIndex, nodeIndex, closestConn};\n\n                    if (!delegate.AllowedLink(nl.mOutputNodeIndex, nl.mInputNodeIndex))\n                    {\n                        break;\n                    }\n                    bool alreadyExisting = false;\n                    for (size_t linkIndex = 0; linkIndex < linkCount; linkIndex++)\n                    {\n                        const auto link = delegate.GetLink(linkIndex);\n                        if (!memcmp(&link, &nl, sizeof(Link)))\n                        {\n                            alreadyExisting = true;\n                            break;\n                        }\n                    }\n\n                    if (!alreadyExisting)\n                    {\n                        for (unsigned int linkIndex = 0; linkIndex < linkCount; linkIndex++)\n                        {\n                            const auto link = delegate.GetLink(linkIndex);\n                            if (link.mOutputNodeIndex == nl.mOutputNodeIndex && link.mOutputSlotIndex == nl.mOutputSlotIndex)\n                            {\n                                delegate.DelLink(linkIndex);\n                                \n                                break;\n                            }\n                        }\n\n                        delegate.AddLink(nl.mInputNodeIndex, nl.mInputSlotIndex, nl.mOutputNodeIndex, nl.mOutputSlotIndex);\n                    }\n                }\n            }\n            // when ImGui::IsWindowHovered() && !ImGui::IsAnyItemActive() is uncommented, one can't click the node\n            // input/output when mouse is over the node itself.\n            if (nodeOperation == NO_None &&\n                /*ImGui::IsWindowHovered() && !ImGui::IsAnyItemActive() &&*/ io.MouseClicked[0] && !bDrawOnly)\n            {\n                nodeOperation = NO_EditingLink;\n                editingInput = i == 0;\n                editingNodeSource = closestPos;\n                editingNodeIndex = nodeIndex;\n                editingSlotIndex = closestConn;\n                if (editingInput)\n                {\n                    // remove existing link\n                    for (unsigned int linkIndex = 0; linkIndex < linkCount; linkIndex++)\n                    {\n                        const auto link = delegate.GetLink(linkIndex);\n                        if (link.mOutputNodeIndex == nodeIndex && link.mOutputSlotIndex == closestConn)\n                        {\n                            delegate.DelLink(linkIndex);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return hoverSlot;\n}\n\nstatic void DrawGrid(ImDrawList* drawList, ImVec2 windowPos, const ViewState& viewState, const ImVec2 canvasSize, ImU32 gridColor, ImU32 gridColor2, float gridSize)\n{\n    float gridSpace = gridSize * viewState.mFactor;\n    int divx = static_cast<int>(-viewState.mPosition.x / gridSize);\n    int divy = static_cast<int>(-viewState.mPosition.y / gridSize);\n    for (float x = fmodf(viewState.mPosition.x * viewState.mFactor, gridSpace); x < canvasSize.x; x += gridSpace, divx ++)\n    {\n        bool tenth = !(divx % 10);\n        drawList->AddLine(ImVec2(x, 0.0f) + windowPos, ImVec2(x, canvasSize.y) + windowPos, tenth ? gridColor2 : gridColor);\n    }\n    for (float y = fmodf(viewState.mPosition.y * viewState.mFactor, gridSpace); y < canvasSize.y; y += gridSpace, divy ++)\n    {\n        bool tenth = !(divy % 10);\n        drawList->AddLine(ImVec2(0.0f, y) + windowPos, ImVec2(canvasSize.x, y) + windowPos, tenth ? gridColor2 : gridColor);\n    }\n}\n\n// return true if node is hovered\nstatic bool DrawNode(ImDrawList* drawList,\n                     NodeIndex nodeIndex,\n                     const ImVec2 offset,\n                     const float factor,\n                     Delegate& delegate,\n                     bool overInput,\n                     const Options& options,\n                     const bool inMinimap,\n                     const ImRect& viewPort)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    const auto node = delegate.GetNode(nodeIndex);\n    IM_ASSERT((node.mRect.GetWidth() != 0.f) && (node.mRect.GetHeight() != 0.f) && \"Nodes must have a non-zero rect.\");\n    const auto nodeTemplate = delegate.GetTemplate(node.mTemplateIndex);\n    const ImVec2 nodeRectangleMin = offset + node.mRect.Min * factor;\n\n    const bool old_any_active = ImGui::IsAnyItemActive();\n    ImGui::SetCursorScreenPos(nodeRectangleMin);\n    const ImVec2 nodeSize = node.mRect.GetSize() * factor;\n\n    // test nested IO\n    drawList->ChannelsSetCurrent(1); // Background\n    const size_t InputsCount = nodeTemplate.mInputCount;\n    const size_t OutputsCount = nodeTemplate.mOutputCount;\n\n    /*\n    for (int i = 0; i < 2; i++)\n    {\n        const size_t slotCount[2] = {InputsCount, OutputsCount};\n        \n        for (size_t slotIndex = 0; slotIndex < slotCount[i]; slotIndex++)\n        {\n            const char* con = i ? nodeTemplate.mOutputNames[slotIndex] : nodeTemplate.mInputNames[slotIndex];//node.mOutputs[slot_idx] : node->mInputs[slot_idx];\n            if (!delegate->IsIOPinned(nodeIndex, slot_idx, i == 1))\n            {\n               \n            }\n            continue;\n\n            ImVec2 p = offset + (i ? GetOutputSlotPos(delegate, node, slotIndex, factor) : GetInputSlotPos(delegate, node, slotIndex, factor));\n            const float arc = 28.f * (float(i) * 0.3f + 1.0f) * (i ? 1.f : -1.f);\n            const float ofs = 0.f;\n\n            ImVec2 pts[3] = {p + ImVec2(arc + ofs, 0.f), p + ImVec2(0.f + ofs, -arc), p + ImVec2(0.f + ofs, arc)};\n            drawList->AddTriangleFilled(pts[0], pts[1], pts[2], i ? 0xFFAA5030 : 0xFF30AA50);\n            drawList->AddTriangle(pts[0], pts[1], pts[2], 0xFF000000, 2.f);\n        }\n    }\n    */\n\n    ImGui::SetCursorScreenPos(nodeRectangleMin);\n    float maxHeight = ImMin(viewPort.Max.y, nodeRectangleMin.y + nodeSize.y) - nodeRectangleMin.y;\n    float maxWidth = ImMin(viewPort.Max.x, nodeRectangleMin.x + nodeSize.x) - nodeRectangleMin.x;\n    ImGui::InvisibleButton(\"node\", ImVec2(maxWidth, maxHeight));\n    // must be called right after creating the control we want to be able to move\n    bool nodeMovingActive = ImGui::IsItemActive();\n\n    // Save the size of what we have emitted and whether any of the widgets are being used\n    bool nodeWidgetsActive = (!old_any_active && ImGui::IsAnyItemActive());\n    ImVec2 nodeRectangleMax = nodeRectangleMin + nodeSize;\n\n    bool nodeHovered = false;\n    if (ImGui::IsItemHovered() && nodeOperation == NO_None && !overInput)\n    {\n        nodeHovered = true;\n    }\n\n    if (ImGui::IsWindowFocused())\n    {\n        if ((nodeWidgetsActive || nodeMovingActive) && !inMinimap)\n        {\n            if (!node.mSelected)\n            {\n                if (!io.KeyShift)\n                {\n                    const auto nodeCount = delegate.GetNodeCount();\n                    for (size_t i = 0; i < nodeCount; i++)\n                    {\n                        delegate.SelectNode(i, false);\n                    }\n                }\n                delegate.SelectNode(nodeIndex, true);\n            }\n        }\n    }\n    if (nodeMovingActive && io.MouseDown[0] && nodeHovered && !inMinimap)\n    {\n        if (nodeOperation != NO_MovingNodes)\n        {\n            nodeOperation = NO_MovingNodes;\n        }\n    }\n\n    const bool currentSelectedNode = node.mSelected;\n    const ImU32 node_bg_color = nodeHovered ? nodeTemplate.mBackgroundColorOver : nodeTemplate.mBackgroundColor;\n\n    drawList->AddRect(nodeRectangleMin,\n                      nodeRectangleMax,\n                      currentSelectedNode ? options.mSelectedNodeBorderColor : options.mNodeBorderColor,\n                      options.mRounding,\n                      ImDrawFlags_RoundCornersAll,\n                      currentSelectedNode ? options.mBorderSelectionThickness : options.mBorderThickness);\n\n    ImVec2 imgPos = nodeRectangleMin + ImVec2(14, 25);\n    ImVec2 imgSize = nodeRectangleMax + ImVec2(-5, -5) - imgPos;\n    float imgSizeComp = std::min(imgSize.x, imgSize.y);\n\n    drawList->AddRectFilled(nodeRectangleMin, nodeRectangleMax, node_bg_color, options.mRounding);\n    /*float progress = delegate->NodeProgress(nodeIndex);\n    if (progress > FLT_EPSILON && progress < 1.f - FLT_EPSILON)\n    {\n        ImVec2 progressLineA = nodeRectangleMax - ImVec2(nodeSize.x - 2.f, 3.f);\n        ImVec2 progressLineB = progressLineA + ImVec2(nodeSize.x * factor - 4.f, 0.f);\n        drawList->AddLine(progressLineA, progressLineB, 0xFF400000, 3.f);\n        drawList->AddLine(progressLineA, ImLerp(progressLineA, progressLineB, progress), 0xFFFF0000, 3.f);\n    }*/\n    ImVec2 imgPosMax = imgPos + ImVec2(imgSizeComp, imgSizeComp);\n\n    //ImVec2 imageSize = delegate->GetEvaluationSize(nodeIndex);\n    /*float imageRatio = 1.f;\n    if (imageSize.x > 0.f && imageSize.y > 0.f)\n    {\n        imageRatio = imageSize.y / imageSize.x;\n    }\n    ImVec2 quadSize = imgPosMax - imgPos;\n    ImVec2 marge(0.f, 0.f);\n    if (imageRatio > 1.f)\n    {\n        marge.x = (quadSize.x - quadSize.y / imageRatio) * 0.5f;\n    }\n    else\n    {\n        marge.y = (quadSize.y - quadSize.y * imageRatio) * 0.5f;\n    }*/\n\n    //delegate->DrawNodeImage(drawList, ImRect(imgPos, imgPosMax), marge, nodeIndex);\n\n    drawList->AddRectFilled(nodeRectangleMin,\n                            ImVec2(nodeRectangleMax.x, nodeRectangleMin.y + 20),\n                            nodeTemplate.mHeaderColor, options.mRounding);\n\n    drawList->PushClipRect(nodeRectangleMin, ImVec2(nodeRectangleMax.x, nodeRectangleMin.y + 20), true);\n    drawList->AddText(nodeRectangleMin + ImVec2(2, 2), IM_COL32(0, 0, 0, 255), node.mName);\n    drawList->PopClipRect();\n\n    ImRect customDrawRect(nodeRectangleMin + ImVec2(options.mRounding, 20 + options.mRounding), nodeRectangleMax - ImVec2(options.mRounding, options.mRounding));\n    if (customDrawRect.Max.y > customDrawRect.Min.y && customDrawRect.Max.x > customDrawRect.Min.x)\n    {\n        delegate.CustomDraw(drawList, customDrawRect, nodeIndex);\n    }\n/*\n    const ImTextureID bmpInfo = (ImTextureID)(uint64_t)delegate->GetBitmapInfo(nodeIndex).idx;\n    if (bmpInfo)\n    {\n        ImVec2 bmpInfoPos(nodeRectangleMax - ImVec2(26, 12));\n        ImVec2 bmpInfoSize(20, 20);\n        if (delegate->NodeIsCompute(nodeIndex))\n        {\n            drawList->AddImageQuad(bmpInfo,\n                                   bmpInfoPos,\n                                   bmpInfoPos + ImVec2(bmpInfoSize.x, 0.f),\n                                   bmpInfoPos + bmpInfoSize,\n                                   bmpInfoPos + ImVec2(0., bmpInfoSize.y));\n        }\n        else if (delegate->NodeIs2D(nodeIndex))\n        {\n            drawList->AddImageQuad(bmpInfo,\n                                   bmpInfoPos,\n                                   bmpInfoPos + ImVec2(bmpInfoSize.x, 0.f),\n                                   bmpInfoPos + bmpInfoSize,\n                                   bmpInfoPos + ImVec2(0., bmpInfoSize.y));\n        }\n        else if (delegate->NodeIsCubemap(nodeIndex))\n        {\n            drawList->AddImageQuad(bmpInfo,\n                                   bmpInfoPos + ImVec2(0., bmpInfoSize.y),\n                                   bmpInfoPos + bmpInfoSize,\n                                   bmpInfoPos + ImVec2(bmpInfoSize.x, 0.f),\n                                   bmpInfoPos);\n        }\n    }*/\n    return nodeHovered;\n}\n\nbool DrawMiniMap(ImDrawList* drawList, Delegate& delegate, ViewState& viewState, const Options& options, const ImVec2 windowPos, const ImVec2 canvasSize)\n{\n    if (Distance(options.mMinimap.Min, options.mMinimap.Max) <= FLT_EPSILON)\n    {\n        return false;\n    }\n\n    const size_t nodeCount = delegate.GetNodeCount();\n\n    if (!nodeCount)\n    {\n        return false;\n    }\n\n    ImVec2 min(FLT_MAX, FLT_MAX);\n    ImVec2 max(-FLT_MAX, -FLT_MAX);\n    const ImVec2 margin(50, 50);\n    for (NodeIndex nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n    {\n        const Node& node = delegate.GetNode(nodeIndex);\n        min = ImMin(min, node.mRect.Min - margin);\n        min = ImMin(min, node.mRect.Max + margin);\n        max = ImMax(max, node.mRect.Min - margin);\n        max = ImMax(max, node.mRect.Max + margin);\n    }\n\n    // add view in world space\n    const ImVec2 worldSizeView = canvasSize / viewState.mFactor;\n    const ImVec2 viewMin(-viewState.mPosition.x, -viewState.mPosition.y);\n    const ImVec2 viewMax = viewMin + worldSizeView;\n    min = ImMin(min, viewMin);\n    max = ImMax(max, viewMax);\n    const ImVec2 nodesSize = max - min;\n    const ImVec2 middleWorld = (min + max) * 0.5f;\n    const ImVec2 minScreen = windowPos + options.mMinimap.Min * canvasSize;\n    const ImVec2 maxScreen = windowPos + options.mMinimap.Max * canvasSize;\n    const ImVec2 viewSize = maxScreen - minScreen;\n    const ImVec2 middleScreen = (minScreen + maxScreen) * 0.5f;\n    const float ratioY = viewSize.y / nodesSize.y;\n    const float ratioX = viewSize.x / nodesSize.x;\n    const float factor = ImMin(ImMin(ratioY, ratioX), 1.f);\n\n    drawList->AddRectFilled(minScreen, maxScreen, IM_COL32(30, 30, 30, 200), 3, ImDrawFlags_RoundCornersAll);\n\n    for (NodeIndex nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n    {\n        const Node& node = delegate.GetNode(nodeIndex);\n        const auto nodeTemplate = delegate.GetTemplate(node.mTemplateIndex);\n\n        ImRect rect = node.mRect;\n        rect.Min -= middleWorld;\n        rect.Min *= factor;\n        rect.Min += middleScreen;\n\n        rect.Max -= middleWorld;\n        rect.Max *= factor;\n        rect.Max += middleScreen;\n\n        drawList->AddRectFilled(rect.Min, rect.Max, nodeTemplate.mBackgroundColor, 1, ImDrawFlags_RoundCornersAll);\n        if (node.mSelected)\n        {\n            drawList->AddRect(rect.Min, rect.Max, options.mSelectedNodeBorderColor, 1, ImDrawFlags_RoundCornersAll);\n        }\n    }\n\n    // add view\n    ImVec2 viewMinScreen = (viewMin - middleWorld) * factor + middleScreen;\n    ImVec2 viewMaxScreen = (viewMax - middleWorld) * factor + middleScreen;\n    drawList->AddRectFilled(viewMinScreen, viewMaxScreen, IM_COL32(255, 255, 255, 32), 1, ImDrawFlags_RoundCornersAll);\n    drawList->AddRect(viewMinScreen, viewMaxScreen, IM_COL32(255, 255, 255, 128), 1, ImDrawFlags_RoundCornersAll);\n    \n    ImGuiIO& io = ImGui::GetIO();\n    const bool mouseInMinimap = ImRect(minScreen, maxScreen).Contains(io.MousePos);\n    if (mouseInMinimap && io.MouseClicked[0])\n    {\n        const ImVec2 clickedRatio = (io.MousePos - minScreen) / viewSize;\n        const ImVec2 worldPosCenter = ImVec2(ImLerp(min.x, max.x, clickedRatio.x), ImLerp(min.y, max.y, clickedRatio.y));\n        \n        ImVec2 worldPosViewMin = worldPosCenter - worldSizeView * 0.5;\n        ImVec2 worldPosViewMax = worldPosCenter + worldSizeView * 0.5;\n        if (worldPosViewMin.x < min.x)\n        {\n            worldPosViewMin.x = min.x;\n            worldPosViewMax.x = worldPosViewMin.x + worldSizeView.x;\n        }\n        if (worldPosViewMin.y < min.y)\n        {\n            worldPosViewMin.y = min.y;\n            worldPosViewMax.y = worldPosViewMin.y + worldSizeView.y;\n        }\n        if (worldPosViewMax.x > max.x)\n        {\n            worldPosViewMax.x = max.x;\n            worldPosViewMin.x = worldPosViewMax.x - worldSizeView.x;\n        }\n        if (worldPosViewMax.y > max.y)\n        {\n            worldPosViewMax.y = max.y;\n            worldPosViewMin.y = worldPosViewMax.y - worldSizeView.y;\n        }\n        viewState.mPosition = ImVec2(-worldPosViewMin.x, -worldPosViewMin.y);\n    }\n    return mouseInMinimap;\n}\n\nvoid Show(Delegate& delegate, const Options& options, ViewState& viewState, bool enabled, FitOnScreen* fit)\n{\n    ImGui::PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.f);\n    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));\n    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.f);\n\n    const ImVec2 windowPos = ImGui::GetCursorScreenPos();\n    const ImVec2 canvasSize = ImGui::GetContentRegionAvail();\n    const ImVec2 scrollRegionLocalPos(0, 0);\n\n    ImRect regionRect(windowPos, windowPos + canvasSize);\n\n    HandleZoomScroll(regionRect, viewState, options);\n    ImVec2 offset = ImGui::GetCursorScreenPos() + viewState.mPosition * viewState.mFactor;\n    captureOffset = viewState.mPosition * viewState.mFactor;\n\n    //ImGui::InvisibleButton(\"GraphEditorButton\", canvasSize);\n    ImGui::BeginChild(71711, canvasSize, ImGuiChildFlags_FrameStyle);\n\n    ImGui::SetCursorPos(windowPos);\n    ImGui::BeginGroup();\n\n    ImGuiIO& io = ImGui::GetIO();\n\n    // Create our child canvas\n    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1, 1));\n    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));\n    ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(30, 30, 30, 200));\n\n    ImDrawList* drawList = ImGui::GetWindowDrawList();\n    ImGui::PushClipRect(regionRect.Min, regionRect.Max, true);\n    drawList->AddRectFilled(windowPos, windowPos + canvasSize, options.mBackgroundColor);\n\n    // Background or Display grid\n    if (options.mRenderGrid)\n    {\n        DrawGrid(drawList, windowPos, viewState, canvasSize, options.mGridColor, options.mGridColor2, options.mGridSize);\n    }\n    \n    // Fit view\n    if (fit && ((*fit == Fit_AllNodes) || (*fit == Fit_SelectedNodes)))\n    {\n        FitNodes(delegate, viewState, canvasSize, (*fit == Fit_SelectedNodes));\n    }\n\n    if (enabled)\n    {\n        static NodeIndex hoveredNode = -1;\n        // Display links\n        drawList->ChannelsSplit(3);\n\n        // minimap\n        drawList->ChannelsSetCurrent(2); // minimap\n        const bool inMinimap = DrawMiniMap(drawList, delegate, viewState, options, windowPos, canvasSize);\n\n        // Focus rectangle\n        if (ImGui::IsWindowFocused())\n        {\n           drawList->AddRect(regionRect.Min, regionRect.Max, options.mFrameFocus, 1.f, 0, 2.f);\n        }\n\n        drawList->ChannelsSetCurrent(1); // Background\n\n        // Links\n        DisplayLinks(delegate, drawList, offset, viewState.mFactor, regionRect, hoveredNode, options);\n\n        // edit node link\n        if (nodeOperation == NO_EditingLink)\n        {\n            ImVec2 p1 = editingNodeSource;\n            ImVec2 p2 = io.MousePos;\n            drawList->AddLine(p1, p2, IM_COL32(200, 200, 200, 255), 3.0f);\n        }\n\n        // Display nodes\n        drawList->PushClipRect(regionRect.Min, regionRect.Max, true);\n        hoveredNode = -1;\n        \n        SlotIndex inputSlotOver = -1;\n        SlotIndex outputSlotOver = -1;\n        NodeIndex nodeOver = -1;\n\n        const auto nodeCount = delegate.GetNodeCount();\n        for (int i = 0; i < 2; i++)\n        {\n            for (NodeIndex nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)\n            {\n                //const auto* node = &nodes[nodeIndex];\n                const auto node = delegate.GetNode(nodeIndex);\n                if (node.mSelected != (i != 0))\n                {\n                    continue;\n                }\n\n                // node view clipping\n                ImRect nodeRect = GetNodeRect(node, viewState.mFactor);\n                nodeRect.Min += offset;\n                nodeRect.Max += offset;\n                if (!regionRect.Overlaps(nodeRect))\n                {\n                    continue;\n                }\n\n                ImGui::PushID((int)nodeIndex);\n                SlotIndex inputSlot = -1;\n                SlotIndex outputSlot = -1;\n\n                bool overInput = (!inMinimap) && HandleConnections(drawList, nodeIndex, offset, viewState.mFactor, delegate, options, false, inputSlot, outputSlot, inMinimap);\n\n                // shadow\n                /*\n                ImVec2 shadowOffset = ImVec2(30, 30);\n                ImVec2 shadowPivot = (nodeRect.Min + nodeRect.Max) /2.f;\n                ImVec2 shadowPointMiddle = shadowPivot + shadowOffset;\n                ImVec2 shadowPointTop = ImVec2(shadowPivot.x, nodeRect.Min.y) + shadowOffset;\n                ImVec2 shadowPointBottom = ImVec2(shadowPivot.x, nodeRect.Max.y) + shadowOffset;\n                ImVec2 shadowPointLeft = ImVec2(nodeRect.Min.x, shadowPivot.y) + shadowOffset;\n                ImVec2 shadowPointRight = ImVec2(nodeRect.Max.x, shadowPivot.y) + shadowOffset;\n\n                // top left\n                drawList->AddRectFilledMultiColor(nodeRect.Min + shadowOffset, shadowPointMiddle, IM_COL32(0 ,0, 0, 0), IM_COL32(0,0,0,0), IM_COL32(0, 0, 0, 255), IM_COL32(0, 0, 0, 0));\n\n                // top right\n                drawList->AddRectFilledMultiColor(shadowPointTop, shadowPointRight, IM_COL32(0 ,0, 0, 0), IM_COL32(0,0,0,0), IM_COL32(0, 0, 0, 0), IM_COL32(0, 0, 0, 255));\n\n                // bottom left\n                drawList->AddRectFilledMultiColor(shadowPointLeft, shadowPointBottom, IM_COL32(0 ,0, 0, 0), IM_COL32(0, 0, 0, 255), IM_COL32(0, 0, 0, 0), IM_COL32(0,0,0,0));\n\n                // bottom right\n                drawList->AddRectFilledMultiColor(shadowPointMiddle, nodeRect.Max + shadowOffset, IM_COL32(0, 0, 0, 255), IM_COL32(0 ,0, 0, 0), IM_COL32(0,0,0,0), IM_COL32(0, 0, 0, 0));\n                */\n                if (DrawNode(drawList, nodeIndex, offset, viewState.mFactor, delegate, overInput, options, inMinimap, regionRect))\n                {\n                    hoveredNode = nodeIndex;\n                }\n\n                HandleConnections(drawList, nodeIndex, offset, viewState.mFactor, delegate, options, true, inputSlot, outputSlot, inMinimap);\n                if (inputSlot != -1 || outputSlot != -1)\n                {\n                    inputSlotOver = inputSlot;\n                    outputSlotOver = outputSlot;\n                    nodeOver = nodeIndex;\n                }\n\n                ImGui::PopID();\n            }\n        }\n        \n\n        \n        drawList->PopClipRect();\n\n        if (nodeOperation == NO_MovingNodes)\n        {\n            if (ImGui::IsMouseDragging(0, 1))\n            {\n                ImVec2 delta = io.MouseDelta / viewState.mFactor;\n                if (fabsf(delta.x) >= 1.f || fabsf(delta.y) >= 1.f)\n                {\n                    delegate.MoveSelectedNodes(delta);\n                }\n            }\n        }\n\n        drawList->ChannelsSetCurrent(0);\n\n        // quad selection\n        if (!inMinimap)\n        {\n            HandleQuadSelection(delegate, drawList, offset, viewState.mFactor, regionRect, options);\n        }\n\n        drawList->ChannelsMerge();\n\n        // releasing mouse button means it's done in any operation\n        if (nodeOperation == NO_PanView)\n        {\n            if (!io.MouseDown[2])\n            {\n                nodeOperation = NO_None;\n            }\n        }\n        else if (nodeOperation != NO_None && !io.MouseDown[0])\n        {\n            nodeOperation = NO_None;\n        }\n\n        // right click\n        if (!inMinimap && nodeOperation == NO_None && regionRect.Contains(io.MousePos) &&\n                (ImGui::IsMouseClicked(1) /*|| (ImGui::IsWindowFocused() && ImGui::IsKeyPressedMap(ImGuiKey_Tab))*/))\n        {\n            delegate.RightClick(nodeOver, inputSlotOver, outputSlotOver);\n        }\n\n        // Scrolling\n        if (ImGui::IsWindowHovered() && !ImGui::IsAnyItemActive() && io.MouseClicked[2] && nodeOperation == NO_None)\n        {\n            nodeOperation = NO_PanView;\n        }\n        if (nodeOperation == NO_PanView)\n        {\n            viewState.mPosition += io.MouseDelta / viewState.mFactor;\n        }\n    }\n\n    ImGui::PopClipRect();\n\n    ImGui::PopStyleColor(1);\n    ImGui::PopStyleVar(2);\n    ImGui::EndGroup();\n    ImGui::EndChild();\n\n    ImGui::PopStyleVar(3);\n    \n    // change fit to none\n    if (fit)\n    {\n        *fit = Fit_None;\n    }\n}\n\nbool EditOptions(Options& options)\n{\n    bool updated = false;\n    if (ImGui::CollapsingHeader(\"Colors\", nullptr))\n    {\n        ImColor backgroundColor(options.mBackgroundColor);\n        ImColor gridColor(options.mGridColor);\n        ImColor selectedNodeBorderColor(options.mSelectedNodeBorderColor);\n        ImColor nodeBorderColor(options.mNodeBorderColor);\n        ImColor quadSelection(options.mQuadSelection);\n        ImColor quadSelectionBorder(options.mQuadSelectionBorder);\n        ImColor defaultSlotColor(options.mDefaultSlotColor);\n        ImColor frameFocus(options.mFrameFocus);\n\n        updated |= ImGui::ColorEdit4(\"Background\", (float*)&backgroundColor);\n        updated |= ImGui::ColorEdit4(\"Grid\", (float*)&gridColor);\n        updated |= ImGui::ColorEdit4(\"Selected Node Border\", (float*)&selectedNodeBorderColor);\n        updated |= ImGui::ColorEdit4(\"Node Border\", (float*)&nodeBorderColor);\n        updated |= ImGui::ColorEdit4(\"Quad Selection\", (float*)&quadSelection);\n        updated |= ImGui::ColorEdit4(\"Quad Selection Border\", (float*)&quadSelectionBorder);\n        updated |= ImGui::ColorEdit4(\"Default Slot\", (float*)&defaultSlotColor);\n        updated |= ImGui::ColorEdit4(\"Frame when has focus\", (float*)&frameFocus);\n\n        options.mBackgroundColor = backgroundColor;\n        options.mGridColor = gridColor;\n        options.mSelectedNodeBorderColor = selectedNodeBorderColor;\n        options.mNodeBorderColor = nodeBorderColor;\n        options.mQuadSelection = quadSelection;\n        options.mQuadSelectionBorder = quadSelectionBorder;\n        options.mDefaultSlotColor = defaultSlotColor;\n        options.mFrameFocus = frameFocus;\n    }\n\n    if (ImGui::CollapsingHeader(\"Options\", nullptr))\n    {\n        updated |= ImGui::InputFloat4(\"Minimap\", &options.mMinimap.Min.x);\n        updated |= ImGui::InputFloat(\"Line Thickness\", &options.mLineThickness);\n        updated |= ImGui::InputFloat(\"Grid Size\", &options.mGridSize);\n        updated |= ImGui::InputFloat(\"Rounding\", &options.mRounding);\n        updated |= ImGui::InputFloat(\"Zoom Ratio\", &options.mZoomRatio);\n        updated |= ImGui::InputFloat(\"Zoom Lerp Factor\", &options.mZoomLerpFactor);\n        updated |= ImGui::InputFloat(\"Border Selection Thickness\", &options.mBorderSelectionThickness);\n        updated |= ImGui::InputFloat(\"Border Thickness\", &options.mBorderThickness);\n        updated |= ImGui::InputFloat(\"Slot Radius\", &options.mNodeSlotRadius);\n        updated |= ImGui::InputFloat(\"Slot Hover Factor\", &options.mNodeSlotHoverFactor);\n        updated |= ImGui::InputFloat2(\"Zoom min/max\", &options.mMinZoom);\n        updated |= ImGui::InputFloat(\"Slot Hover Factor\", &options.mSnap);\n        \n        if (ImGui::RadioButton(\"Curved Links\", options.mDisplayLinksAsCurves))\n        {\n            options.mDisplayLinksAsCurves = !options.mDisplayLinksAsCurves;\n            updated = true;\n        }\n        if (ImGui::RadioButton(\"Straight Links\", !options.mDisplayLinksAsCurves))\n        {\n            options.mDisplayLinksAsCurves = !options.mDisplayLinksAsCurves;\n            updated = true;\n        }\n\n        updated |= ImGui::Checkbox(\"Allow Quad Selection\", &options.mAllowQuadSelection);\n        updated |= ImGui::Checkbox(\"Render Grid\", &options.mRenderGrid);\n        updated |= ImGui::Checkbox(\"Draw IO names on hover\", &options.mDrawIONameOnHover);\n    }\n\n    return updated;\n}\n\n} // namespace\n"
        },
        {
          "name": "GraphEditor.h",
          "type": "blob",
          "size": 5.84765625,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#pragma once\n\n#include <vector>\n#include <stdint.h>\n#include <string>\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n\nnamespace GraphEditor {\n\ntypedef size_t NodeIndex;\ntypedef size_t SlotIndex;\ntypedef size_t LinkIndex;\ntypedef size_t TemplateIndex;\n\n// Force the view to be respositionned and zoom to fit nodes with Show function.\n// Parameter value will be changed to Fit_None by the function.\nenum FitOnScreen\n{\n    Fit_None,\n    Fit_AllNodes,\n    Fit_SelectedNodes\n};\n\n// Display options and colors\nstruct Options\n{\n    ImRect mMinimap{{0.75f, 0.8f, 0.99f, 0.99f}}; // rectangle coordinates of minimap\n    ImU32 mBackgroundColor{ IM_COL32(40, 40, 40, 255) }; // full background color\n    ImU32 mGridColor{ IM_COL32(0, 0, 0, 60) }; // grid lines color\n    ImU32 mGridColor2{ IM_COL32(0, 0, 0, 160) }; // grid lines color every 10th\n    ImU32 mSelectedNodeBorderColor{ IM_COL32(255, 130, 30, 255) }; // node border color when it's selected\n    ImU32 mNodeBorderColor{ IM_COL32(100, 100, 100, 0) }; // node border color when it's not selected\n    ImU32 mQuadSelection{ IM_COL32(255, 32, 32, 64) }; // quad selection inside color\n    ImU32 mQuadSelectionBorder{ IM_COL32(255, 32, 32, 255) }; // quad selection border color\n    ImU32 mDefaultSlotColor{ IM_COL32(128, 128, 128, 255) }; // when no color is provided in node template, use this value\n    ImU32 mFrameFocus{ IM_COL32(64, 128, 255, 255) }; // rectangle border when graph editor has focus\n    float mLineThickness{ 5 }; // links width in pixels when zoom value is 1\n    float mGridSize{ 64.f }; // background grid size in pixels when zoom value is 1\n    float mRounding{ 3.f }; // rounding at node corners\n    float mZoomRatio{ 0.1f }; // factor per mouse wheel delta\n    float mZoomLerpFactor{ 0.25f }; // the smaller, the smoother\n    float mBorderSelectionThickness{ 6.f }; // thickness of selection border around nodes\n    float mBorderThickness{ 6.f }; // thickness of selection border around nodes\n    float mNodeSlotRadius{ 8.f }; // circle radius for inputs and outputs\n    float mNodeSlotHoverFactor{ 1.2f }; // increase size when hovering\n    float mMinZoom{ 0.2f }, mMaxZoom { 1.1f };\n    float mSnap{ 5.f };\n    bool mDisplayLinksAsCurves{ true }; // false is straight and 45deg lines\n    bool mAllowQuadSelection{ true }; // multiple selection using drag and drop\n    bool mRenderGrid{ true }; // grid or nothing\n    bool mDrawIONameOnHover{ true }; // only draw node input/output when hovering\n};\n\n// View state: scroll position and zoom factor\nstruct ViewState\n{\n    ImVec2 mPosition{0.0f, 0.0f}; // scroll position\n    float mFactor{ 1.0f }; // current zoom factor\n    float mFactorTarget{ 1.0f }; // targeted zoom factor interpolated using Options.mZoomLerpFactor\n};\n\nstruct Template\n{\n    ImU32 mHeaderColor;\n    ImU32 mBackgroundColor;\n    ImU32 mBackgroundColorOver;\n    ImU8 mInputCount;\n    const char** mInputNames; // can be nullptr. No text displayed.\n    ImU32* mInputColors; // can be nullptr, default slot color will be used.\n    ImU8 mOutputCount;\n    const char** mOutputNames; // can be nullptr. No text displayed.\n    ImU32* mOutputColors; // can be nullptr, default slot color will be used.\n};\n\nstruct Node\n{\n    const char* mName;\n    TemplateIndex mTemplateIndex;\n    ImRect mRect;\n    bool mSelected{ false };\n};\n\nstruct Link\n{\n    NodeIndex mInputNodeIndex;\n    SlotIndex mInputSlotIndex;\n    NodeIndex mOutputNodeIndex;\n    SlotIndex mOutputSlotIndex;\n};\n\nstruct Delegate\n{\n    virtual bool AllowedLink(NodeIndex from, NodeIndex to) = 0;\n\n    virtual void SelectNode(NodeIndex nodeIndex, bool selected) = 0;\n    virtual void MoveSelectedNodes(const ImVec2 delta) = 0;\n    \n    virtual void AddLink(NodeIndex inputNodeIndex, SlotIndex inputSlotIndex, NodeIndex outputNodeIndex, SlotIndex outputSlotIndex) = 0;\n    virtual void DelLink(LinkIndex linkIndex) = 0;\n    \n    // user is responsible for clipping\n    virtual void CustomDraw(ImDrawList* drawList, ImRect rectangle, NodeIndex nodeIndex) = 0;\n    \n    // use mouse position to open context menu\n    // if nodeIndex != -1, right click happens on the specified node\n    virtual void RightClick(NodeIndex nodeIndex, SlotIndex slotIndexInput, SlotIndex slotIndexOutput) = 0;\n\n    virtual const size_t GetTemplateCount() = 0;\n    virtual const Template GetTemplate(TemplateIndex index) = 0;\n\n    virtual const size_t GetNodeCount() = 0;\n    virtual const Node GetNode(NodeIndex index) = 0;\n    \n    virtual const size_t GetLinkCount() = 0;\n    virtual const Link GetLink(LinkIndex index) = 0;\n\n    virtual ~Delegate() = default;\n};\n\nvoid Show(Delegate& delegate, const Options& options, ViewState& viewState, bool enabled, FitOnScreen* fit = nullptr);\nvoid GraphEditorClear();\n\nbool EditOptions(Options& options);\n\n} // namespace\n"
        },
        {
          "name": "ImCurveEdit.cpp",
          "type": "blob",
          "size": 15.31640625,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#include \"ImCurveEdit.h\"\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n#include <stdint.h>\n#include <set>\n#include <vector>\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#include <malloc.h>\n#endif\n#if !defined(_MSC_VER) && !defined(__MINGW64_VERSION_MAJOR)\n#define _malloca(x) alloca(x)\n#define _freea(x)\n#endif\n\nnamespace ImCurveEdit\n{\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n   static ImVec2 operator+(const ImVec2& a, const ImVec2& b) {\n      return ImVec2(a.x + b.x, a.y + b.y);\n   }\n\n   static ImVec2 operator-(const ImVec2& a, const ImVec2& b) {\n      return ImVec2(a.x - b.x, a.y - b.y);\n   }\n\n   static ImVec2 operator*(const ImVec2& a, const ImVec2& b) {\n      return ImVec2(a.x * b.x, a.y * b.y);\n   }\n\n   static ImVec2 operator/(const ImVec2& a, const ImVec2& b) {\n      return ImVec2(a.x / b.x, a.y / b.y);\n   }\n\n   static ImVec2 operator*(const ImVec2& a, const float b) {\n      return ImVec2(a.x * b, a.y * b);\n   }\n#endif\n\n   static float smoothstep(float edge0, float edge1, float x)\n   {\n      x = ImClamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n      return x * x * (3 - 2 * x);\n   }\n\n   static float distance(float x, float y, float x1, float y1, float x2, float y2)\n   {\n      float A = x - x1;\n      float B = y - y1;\n      float C = x2 - x1;\n      float D = y2 - y1;\n\n      float dot = A * C + B * D;\n      float len_sq = C * C + D * D;\n      float param = -1.f;\n      if (len_sq > FLT_EPSILON)\n         param = dot / len_sq;\n\n      float xx, yy;\n\n      if (param < 0.f) {\n         xx = x1;\n         yy = y1;\n      }\n      else if (param > 1.f) {\n         xx = x2;\n         yy = y2;\n      }\n      else {\n         xx = x1 + param * C;\n         yy = y1 + param * D;\n      }\n\n      float dx = x - xx;\n      float dy = y - yy;\n      return sqrtf(dx * dx + dy * dy);\n   }\n\n   static int DrawPoint(ImDrawList* draw_list, ImVec2 pos, const ImVec2 size, const ImVec2 offset, bool edited)\n   {\n      int ret = 0;\n      ImGuiIO& io = ImGui::GetIO();\n\n      static const ImVec2 localOffsets[4] = { ImVec2(1,0), ImVec2(0,1), ImVec2(-1,0), ImVec2(0,-1) };\n      ImVec2 offsets[4];\n      for (int i = 0; i < 4; i++)\n      {\n         offsets[i] = pos * size + localOffsets[i] * 4.5f + offset;\n      }\n\n      const ImVec2 center = pos * size + offset;\n      const ImRect anchor(center - ImVec2(5, 5), center + ImVec2(5, 5));\n      draw_list->AddConvexPolyFilled(offsets, 4, 0xFF000000);\n      if (anchor.Contains(io.MousePos))\n      {\n         ret = 1;\n         if (io.MouseDown[0])\n            ret = 2;\n      }\n      if (edited)\n         draw_list->AddPolyline(offsets, 4, 0xFFFFFFFF, true, 3.0f);\n      else if (ret)\n         draw_list->AddPolyline(offsets, 4, 0xFF80B0FF, true, 2.0f);\n      else\n         draw_list->AddPolyline(offsets, 4, 0xFF0080FF, true, 2.0f);\n\n      return ret;\n   }\n\n   int Edit(Delegate& delegate, const ImVec2& size, unsigned int id, const ImRect* clippingRect, ImVector<EditPoint>* selectedPoints)\n   {\n      static bool selectingQuad = false;\n      static ImVec2 quadSelection;\n      static int overCurve = -1;\n      static int movingCurve = -1;\n      static bool scrollingV = false;\n      static std::set<EditPoint> selection;\n      static bool overSelectedPoint = false;\n\n      int ret = 0;\n\n      ImGuiIO& io = ImGui::GetIO();\n      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n      ImGui::PushStyleColor(ImGuiCol_Border, 0);\n      ImGui::BeginChild(id, size, ImGuiChildFlags_FrameStyle);\n      delegate.focused = ImGui::IsWindowFocused();\n      ImDrawList* draw_list = ImGui::GetWindowDrawList();\n      if (clippingRect)\n         draw_list->PushClipRect(clippingRect->Min, clippingRect->Max, true);\n\n      const ImVec2 offset = ImGui::GetCursorScreenPos() + ImVec2(0.f, size.y);\n      const ImVec2 ssize(size.x, -size.y);\n      const ImRect container(offset + ImVec2(0.f, ssize.y), offset + ImVec2(ssize.x, 0.f));\n      ImVec2& min = delegate.GetMin();\n      ImVec2& max = delegate.GetMax();\n\n      // handle zoom and VScroll\n      if (container.Contains(io.MousePos))\n      {\n         if (fabsf(io.MouseWheel) > FLT_EPSILON)\n         {\n            const float r = (io.MousePos.y - offset.y) / ssize.y;\n            float ratioY = ImLerp(min.y, max.y, r);\n            auto scaleValue = [&](float v) {\n               v -= ratioY;\n               v *= (1.f - io.MouseWheel * 0.05f);\n               v += ratioY;\n               return v;\n            };\n            min.y = scaleValue(min.y);\n            max.y = scaleValue(max.y);\n         }\n         if (!scrollingV && ImGui::IsMouseDown(2))\n         {\n            scrollingV = true;\n         }\n      }\n      ImVec2 range = max - min + ImVec2(1.f, 0.f);  // +1 because of inclusive last frame\n\n      const ImVec2 viewSize(size.x, -size.y);\n      const ImVec2 sizeOfPixel = ImVec2(1.f, 1.f) / viewSize;\n      const size_t curveCount = delegate.GetCurveCount();\n\n      if (scrollingV)\n      {\n         float deltaH = io.MouseDelta.y * range.y * sizeOfPixel.y;\n         min.y -= deltaH;\n         max.y -= deltaH;\n         if (!ImGui::IsMouseDown(2))\n            scrollingV = false;\n      }\n\n      draw_list->AddRectFilled(offset, offset + ssize, delegate.GetBackgroundColor());\n\n      auto pointToRange = [&](ImVec2 pt) { return (pt - min) / range; };\n      auto rangeToPoint = [&](ImVec2 pt) { return (pt * range) + min; };\n\n      draw_list->AddLine(ImVec2(-1.f, -min.y / range.y) * viewSize + offset, ImVec2(1.f, -min.y / range.y) * viewSize + offset, 0xFF000000, 1.5f);\n      bool overCurveOrPoint = false;\n\n      int localOverCurve = -1;\n      // make sure highlighted curve is rendered last\n      int* curvesIndex = (int*)_malloca(sizeof(int) * curveCount);\n      for (size_t c = 0; c < curveCount; c++)\n         curvesIndex[c] = int(c);\n      int highLightedCurveIndex = -1;\n      if (overCurve != -1 && curveCount)\n      {\n         ImSwap(curvesIndex[overCurve], curvesIndex[curveCount - 1]);\n         highLightedCurveIndex = overCurve;\n      }\n\n      for (size_t cur = 0; cur < curveCount; cur++)\n      {\n         int c = curvesIndex[cur];\n         if (!delegate.IsVisible(c))\n            continue;\n         const size_t ptCount = delegate.GetPointCount(c);\n         if (ptCount < 1)\n            continue;\n         CurveType curveType = delegate.GetCurveType(c);\n         if (curveType == CurveNone)\n            continue;\n         const ImVec2* pts = delegate.GetPoints(c);\n         uint32_t curveColor = delegate.GetCurveColor(c);\n         if ((c == highLightedCurveIndex && selection.empty() && !selectingQuad) || movingCurve == c)\n            curveColor = 0xFFFFFFFF;\n\n         for (size_t p = 0; p < ptCount - 1; p++)\n         {\n            const ImVec2 p1 = pointToRange(pts[p]);\n            const ImVec2 p2 = pointToRange(pts[p + 1]);\n\n            if (curveType == CurveSmooth || curveType == CurveLinear)\n            {\n               size_t subStepCount = (curveType == CurveSmooth) ? 20 : 2;\n               float step = 1.f / float(subStepCount - 1);\n               for (size_t substep = 0; substep < subStepCount - 1; substep++)\n               {\n                  float t = float(substep) * step;\n\n                  const ImVec2 sp1 = ImLerp(p1, p2, t);\n                  const ImVec2 sp2 = ImLerp(p1, p2, t + step);\n\n                  const float rt1 = smoothstep(p1.x, p2.x, sp1.x);\n                  const float rt2 = smoothstep(p1.x, p2.x, sp2.x);\n\n                  const ImVec2 pos1 = ImVec2(sp1.x, ImLerp(p1.y, p2.y, rt1)) * viewSize + offset;\n                  const ImVec2 pos2 = ImVec2(sp2.x, ImLerp(p1.y, p2.y, rt2)) * viewSize + offset;\n\n                  if (distance(io.MousePos.x, io.MousePos.y, pos1.x, pos1.y, pos2.x, pos2.y) < 8.f && !scrollingV)\n                  {\n                     localOverCurve = int(c);\n                     overCurve = int(c);\n                     overCurveOrPoint = true;\n                  }\n\n                  draw_list->AddLine(pos1, pos2, curveColor, 1.3f);\n               } // substep\n            }\n            else if (curveType == CurveDiscrete)\n            {\n               ImVec2 dp1 = p1 * viewSize + offset;\n               ImVec2 dp2 = ImVec2(p2.x, p1.y) * viewSize + offset;\n               ImVec2 dp3 = p2 * viewSize + offset;\n               draw_list->AddLine(dp1, dp2, curveColor, 1.3f);\n               draw_list->AddLine(dp2, dp3, curveColor, 1.3f);\n\n               if ((distance(io.MousePos.x, io.MousePos.y, dp1.x, dp1.y, dp3.x, dp1.y) < 8.f ||\n                  distance(io.MousePos.x, io.MousePos.y, dp3.x, dp1.y, dp3.x, dp3.y) < 8.f)\n                  /*&& localOverCurve == -1*/)\n               {\n                  localOverCurve = int(c);\n                  overCurve = int(c);\n                  overCurveOrPoint = true;\n               }\n            }\n         } // point loop\n\n         for (size_t p = 0; p < ptCount; p++)\n         {\n            const int drawState = DrawPoint(draw_list, pointToRange(pts[p]), viewSize, offset, (selection.find({ int(c), int(p) }) != selection.end() && movingCurve == -1 && !scrollingV));\n            if (drawState && movingCurve == -1 && !selectingQuad)\n            {\n               overCurveOrPoint = true;\n               overSelectedPoint = true;\n               overCurve = -1;\n               if (drawState == 2)\n               {\n                  if (!io.KeyShift && selection.find({ int(c), int(p) }) == selection.end())\n                     selection.clear();\n                  selection.insert({ int(c), int(p) });\n               }\n            }\n         }\n      } // curves loop\n\n      if (localOverCurve == -1)\n         overCurve = -1;\n\n      // move selection\n      static bool pointsMoved = false;\n      static ImVec2 mousePosOrigin;\n      static std::vector<ImVec2> originalPoints;\n      if (overSelectedPoint && io.MouseDown[0])\n      {\n         if ((fabsf(io.MouseDelta.x) > 0.f || fabsf(io.MouseDelta.y) > 0.f) && !selection.empty())\n         {\n            if (!pointsMoved)\n            {\n               delegate.BeginEdit(0);\n               mousePosOrigin = io.MousePos;\n               originalPoints.resize(selection.size());\n               int index = 0;\n               for (auto& sel : selection)\n               {\n                  const ImVec2* pts = delegate.GetPoints(sel.curveIndex);\n                  originalPoints[index++] = pts[sel.pointIndex];\n               }\n            }\n            pointsMoved = true;\n            ret = 1;\n            auto prevSelection = selection;\n            int originalIndex = 0;\n            for (auto& sel : prevSelection)\n            {\n               const ImVec2 p = rangeToPoint(pointToRange(originalPoints[originalIndex]) + (io.MousePos - mousePosOrigin) * sizeOfPixel);\n               const int newIndex = delegate.EditPoint(sel.curveIndex, sel.pointIndex, p);\n               if (newIndex != sel.pointIndex)\n               {\n                  selection.erase(sel);\n                  selection.insert({ sel.curveIndex, newIndex });\n               }\n               originalIndex++;\n            }\n         }\n      }\n\n      if (overSelectedPoint && !io.MouseDown[0])\n      {\n         overSelectedPoint = false;\n         if (pointsMoved)\n         {\n            pointsMoved = false;\n            delegate.EndEdit();\n         }\n      }\n\n      // add point\n      if (overCurve != -1 && io.MouseDoubleClicked[0])\n      {\n         const ImVec2 np = rangeToPoint((io.MousePos - offset) / viewSize);\n         delegate.BeginEdit(overCurve);\n         delegate.AddPoint(overCurve, np);\n         delegate.EndEdit();\n         ret = 1;\n      }\n\n      // move curve\n\n      if (movingCurve != -1)\n      {\n         const size_t ptCount = delegate.GetPointCount(movingCurve);\n         const ImVec2* pts = delegate.GetPoints(movingCurve);\n         if (!pointsMoved)\n         {\n            mousePosOrigin = io.MousePos;\n            pointsMoved = true;\n            originalPoints.resize(ptCount);\n            for (size_t index = 0; index < ptCount; index++)\n            {\n               originalPoints[index] = pts[index];\n            }\n         }\n         if (ptCount >= 1)\n         {\n            for (size_t p = 0; p < ptCount; p++)\n            {\n               delegate.EditPoint(movingCurve, int(p), rangeToPoint(pointToRange(originalPoints[p]) + (io.MousePos - mousePosOrigin) * sizeOfPixel));\n            }\n            ret = 1;\n         }\n         if (!io.MouseDown[0])\n         {\n            movingCurve = -1;\n            pointsMoved = false;\n            delegate.EndEdit();\n         }\n      }\n      if (movingCurve == -1 && overCurve != -1 && ImGui::IsMouseClicked(0) && selection.empty() && !selectingQuad)\n      {\n         movingCurve = overCurve;\n         delegate.BeginEdit(overCurve);\n      }\n\n      // quad selection\n      if (selectingQuad)\n      {\n         const ImVec2 bmin = ImMin(quadSelection, io.MousePos);\n         const ImVec2 bmax = ImMax(quadSelection, io.MousePos);\n         draw_list->AddRectFilled(bmin, bmax, 0x40FF0000, 1.f);\n         draw_list->AddRect(bmin, bmax, 0xFFFF0000, 1.f);\n         const ImRect selectionQuad(bmin, bmax);\n         if (!io.MouseDown[0])\n         {\n            if (!io.KeyShift)\n               selection.clear();\n            // select everythnig is quad\n            for (size_t c = 0; c < curveCount; c++)\n            {\n               if (!delegate.IsVisible(c))\n                  continue;\n\n               const size_t ptCount = delegate.GetPointCount(c);\n               if (ptCount < 1)\n                  continue;\n\n               const ImVec2* pts = delegate.GetPoints(c);\n               for (size_t p = 0; p < ptCount; p++)\n               {\n                  const ImVec2 center = pointToRange(pts[p]) * viewSize + offset;\n                  if (selectionQuad.Contains(center))\n                     selection.insert({ int(c), int(p) });\n               }\n            }\n            // done\n            selectingQuad = false;\n         }\n      }\n      if (!overCurveOrPoint && ImGui::IsMouseClicked(0) && !selectingQuad && movingCurve == -1 && !overSelectedPoint && container.Contains(io.MousePos))\n      {\n         selectingQuad = true;\n         quadSelection = io.MousePos;\n      }\n      if (clippingRect)\n         draw_list->PopClipRect();\n\n      ImGui::EndChild();\n      ImGui::PopStyleVar();\n      ImGui::PopStyleColor(1);\n\n      if (selectedPoints)\n      {\n         selectedPoints->resize(int(selection.size()));\n         int index = 0;\n         for (auto& point : selection)\n            (*selectedPoints)[index++] = point;\n      }\n      return ret;\n   }\n}\n"
        },
        {
          "name": "ImCurveEdit.h",
          "type": "blob",
          "size": 2.77734375,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#pragma once\n#include <stdint.h>\n#include \"imgui.h\"\n\nstruct ImRect;\n\nnamespace ImCurveEdit\n{\n   enum CurveType\n   {\n      CurveNone,\n      CurveDiscrete,\n      CurveLinear,\n      CurveSmooth,\n      CurveBezier,\n   };\n\n   struct EditPoint\n   {\n      int curveIndex;\n      int pointIndex;\n      bool operator <(const EditPoint& other) const\n      {\n         if (curveIndex < other.curveIndex)\n            return true;\n         if (curveIndex > other.curveIndex)\n            return false;\n\n         if (pointIndex < other.pointIndex)\n            return true;\n         return false;\n      }\n   };\n\n   struct Delegate\n   {\n      bool focused = false;\n      virtual size_t GetCurveCount() = 0;\n      virtual bool IsVisible(size_t /*curveIndex*/) { return true; }\n      virtual CurveType GetCurveType(size_t /*curveIndex*/) const { return CurveLinear; }\n      virtual ImVec2& GetMin() = 0;\n      virtual ImVec2& GetMax() = 0;\n      virtual size_t GetPointCount(size_t curveIndex) = 0;\n      virtual uint32_t GetCurveColor(size_t curveIndex) = 0;\n      virtual ImVec2* GetPoints(size_t curveIndex) = 0;\n      virtual int EditPoint(size_t curveIndex, int pointIndex, ImVec2 value) = 0;\n      virtual void AddPoint(size_t curveIndex, ImVec2 value) = 0;\n      virtual unsigned int GetBackgroundColor() { return 0xFF202020; }\n      // handle undo/redo thru this functions\n      virtual void BeginEdit(int /*index*/) {}\n      virtual void EndEdit() {}\n\n      virtual ~Delegate() = default;\n   };\n\n   int Edit(Delegate& delegate, const ImVec2& size, unsigned int id, const ImRect* clippingRect = NULL, ImVector<EditPoint>* selectedPoints = NULL);\n}\n"
        },
        {
          "name": "ImGradient.cpp",
          "type": "blob",
          "size": 4.3720703125,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#include \"ImGradient.h\"\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n\nnamespace ImGradient\n{\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n   static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }\n   static inline ImVec2 operator/(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x / rhs, lhs.y / rhs); }\n   static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }\n   static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }\n   static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }\n   static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }\n#endif\n\n   static int DrawPoint(ImDrawList* draw_list, ImVec4 color, const ImVec2 size, bool editing, ImVec2 pos)\n   {\n      ImGuiIO& io = ImGui::GetIO();\n\n      ImVec2 p1 = ImLerp(pos, ImVec2(pos + ImVec2(size.x - size.y, 0.f)), color.w) + ImVec2(3, 3);\n      ImVec2 p2 = ImLerp(pos + ImVec2(size.y, size.y), ImVec2(pos + size), color.w) - ImVec2(3, 3);\n      ImRect rc(p1, p2);\n\n      color.w = 1.f;\n      draw_list->AddRectFilled(p1, p2, ImColor(color));\n      if (editing)\n         draw_list->AddRect(p1, p2, 0xFFFFFFFF, 2.f, 15, 2.5f);\n      else\n         draw_list->AddRect(p1, p2, 0x80FFFFFF, 2.f, 15, 1.25f);\n\n      if (rc.Contains(io.MousePos))\n      {\n         if (io.MouseClicked[0])\n            return 2;\n         return 1;\n      }\n      return 0;\n   }\n\n   bool Edit(Delegate& delegate, const ImVec2& size, int& selection)\n   {\n      bool ret = false;\n      ImGuiIO& io = ImGui::GetIO();\n      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n      ImGui::BeginChild(137, size, ImGuiChildFlags_FrameStyle);\n\n      ImDrawList* draw_list = ImGui::GetWindowDrawList();\n      const ImVec2 offset = ImGui::GetCursorScreenPos();\n\n      const ImVec4* pts = delegate.GetPoints();\n      static int currentSelection = -1;\n      static int movingPt = -1;\n      if (currentSelection >= int(delegate.GetPointCount()))\n         currentSelection = -1;\n      if (movingPt != -1)\n      {\n         ImVec4 current = pts[movingPt];\n         current.w += io.MouseDelta.x / size.x;\n         current.w = ImClamp(current.w, 0.f, 1.f);\n         delegate.EditPoint(movingPt, current);\n         ret = true;\n         if (!io.MouseDown[0])\n            movingPt = -1;\n      }\n      for (size_t i = 0; i < delegate.GetPointCount(); i++)\n      {\n         int ptSel = DrawPoint(draw_list, pts[i], size, i == currentSelection, offset);\n         if (ptSel == 2)\n         {\n            currentSelection = int(i);\n            ret = true;\n         }\n         if (ptSel == 1 && io.MouseDown[0] && movingPt == -1)\n         {\n            movingPt = int(i);\n         }\n      }\n      ImRect rc(offset, offset + size);\n      if (rc.Contains(io.MousePos) && io.MouseDoubleClicked[0])\n      {\n         float t = (io.MousePos.x - offset.x) / size.x;\n         delegate.AddPoint(delegate.GetPoint(t));\n         ret = true;\n      }\n      ImGui::EndChild();\n      ImGui::PopStyleVar();\n\n      selection = currentSelection;\n      return ret;\n   }\n}\n"
        },
        {
          "name": "ImGradient.h",
          "type": "blob",
          "size": 1.6318359375,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#pragma once\n#include <cstddef>\n\nstruct ImVec4;\nstruct ImVec2;\n\nnamespace ImGradient\n{\n   struct Delegate\n   {\n      virtual size_t GetPointCount() = 0;\n      virtual ImVec4* GetPoints() = 0;\n      virtual int EditPoint(int pointIndex, ImVec4 value) = 0;\n      virtual ImVec4 GetPoint(float t) = 0;\n      virtual void AddPoint(ImVec4 value) = 0;\n      virtual ~Delegate() = default;\n   };\n\n   bool Edit(Delegate& delegate, const ImVec2& size, int& selection);\n}\n"
        },
        {
          "name": "ImGuizmo.cpp",
          "type": "blob",
          "size": 116.4287109375,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n#include \"ImGuizmo.h\"\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#include <malloc.h>\n#endif\n#if !defined(_MSC_VER) && !defined(__MINGW64_VERSION_MAJOR)\n#define _malloca(x) alloca(x)\n#define _freea(x)\n#endif\n\n// includes patches for multiview from\n// https://github.com/CedricGuillemet/ImGuizmo/issues/15\n\nnamespace IMGUIZMO_NAMESPACE\n{\n   static const float ZPI = 3.14159265358979323846f;\n   static const float RAD2DEG = (180.f / ZPI);\n   static const float DEG2RAD = (ZPI / 180.f);\n   const float screenRotateSize = 0.06f;\n   // scale a bit so translate axis do not touch when in universal\n   const float rotationDisplayFactor = 1.2f;\n\n   static OPERATION operator&(OPERATION lhs, OPERATION rhs)\n   {\n     return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));\n   }\n\n   static bool operator!=(OPERATION lhs, int rhs)\n   {\n     return static_cast<int>(lhs) != rhs;\n   }\n\n   static bool Intersects(OPERATION lhs, OPERATION rhs)\n   {\n     return (lhs & rhs) != 0;\n   }\n\n   // True if lhs contains rhs\n   static bool Contains(OPERATION lhs, OPERATION rhs)\n   {\n     return (lhs & rhs) == rhs;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   // utility and math\n\n   void FPU_MatrixF_x_MatrixF(const float* a, const float* b, float* r)\n   {\n      r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];\n      r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];\n      r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];\n      r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];\n\n      r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];\n      r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];\n      r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];\n      r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];\n\n      r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];\n      r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];\n      r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];\n      r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];\n\n      r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];\n      r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];\n      r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];\n      r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];\n   }\n\n   void Frustum(float left, float right, float bottom, float top, float znear, float zfar, float* m16)\n   {\n      float temp, temp2, temp3, temp4;\n      temp = 2.0f * znear;\n      temp2 = right - left;\n      temp3 = top - bottom;\n      temp4 = zfar - znear;\n      m16[0] = temp / temp2;\n      m16[1] = 0.0;\n      m16[2] = 0.0;\n      m16[3] = 0.0;\n      m16[4] = 0.0;\n      m16[5] = temp / temp3;\n      m16[6] = 0.0;\n      m16[7] = 0.0;\n      m16[8] = (right + left) / temp2;\n      m16[9] = (top + bottom) / temp3;\n      m16[10] = (-zfar - znear) / temp4;\n      m16[11] = -1.0f;\n      m16[12] = 0.0;\n      m16[13] = 0.0;\n      m16[14] = (-temp * zfar) / temp4;\n      m16[15] = 0.0;\n   }\n\n   void Perspective(float fovyInDegrees, float aspectRatio, float znear, float zfar, float* m16)\n   {\n      float ymax, xmax;\n      ymax = znear * tanf(fovyInDegrees * DEG2RAD);\n      xmax = ymax * aspectRatio;\n      Frustum(-xmax, xmax, -ymax, ymax, znear, zfar, m16);\n   }\n\n   void Cross(const float* a, const float* b, float* r)\n   {\n      r[0] = a[1] * b[2] - a[2] * b[1];\n      r[1] = a[2] * b[0] - a[0] * b[2];\n      r[2] = a[0] * b[1] - a[1] * b[0];\n   }\n\n   float Dot(const float* a, const float* b)\n   {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n   }\n\n   void Normalize(const float* a, float* r)\n   {\n      float il = 1.f / (sqrtf(Dot(a, a)) + FLT_EPSILON);\n      r[0] = a[0] * il;\n      r[1] = a[1] * il;\n      r[2] = a[2] * il;\n   }\n\n   void LookAt(const float* eye, const float* at, const float* up, float* m16)\n   {\n      float X[3], Y[3], Z[3], tmp[3];\n\n      tmp[0] = eye[0] - at[0];\n      tmp[1] = eye[1] - at[1];\n      tmp[2] = eye[2] - at[2];\n      Normalize(tmp, Z);\n      Normalize(up, Y);\n      Cross(Y, Z, tmp);\n      Normalize(tmp, X);\n      Cross(Z, X, tmp);\n      Normalize(tmp, Y);\n\n      m16[0] = X[0];\n      m16[1] = Y[0];\n      m16[2] = Z[0];\n      m16[3] = 0.0f;\n      m16[4] = X[1];\n      m16[5] = Y[1];\n      m16[6] = Z[1];\n      m16[7] = 0.0f;\n      m16[8] = X[2];\n      m16[9] = Y[2];\n      m16[10] = Z[2];\n      m16[11] = 0.0f;\n      m16[12] = -Dot(X, eye);\n      m16[13] = -Dot(Y, eye);\n      m16[14] = -Dot(Z, eye);\n      m16[15] = 1.0f;\n   }\n\n   template <typename T> T Clamp(T x, T y, T z) { return ((x < y) ? y : ((x > z) ? z : x)); }\n   template <typename T> T max(T x, T y) { return (x > y) ? x : y; }\n   template <typename T> T min(T x, T y) { return (x < y) ? x : y; }\n   template <typename T> bool IsWithin(T x, T y, T z) { return (x >= y) && (x <= z); }\n\n   struct matrix_t;\n   struct vec_t\n   {\n   public:\n      float x, y, z, w;\n\n      void Lerp(const vec_t& v, float t)\n      {\n         x += (v.x - x) * t;\n         y += (v.y - y) * t;\n         z += (v.z - z) * t;\n         w += (v.w - w) * t;\n      }\n\n      void Set(float v) { x = y = z = w = v; }\n      void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }\n\n      vec_t& operator -= (const vec_t& v) { x -= v.x; y -= v.y; z -= v.z; w -= v.w; return *this; }\n      vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }\n      vec_t& operator *= (const vec_t& v) { x *= v.x; y *= v.y; z *= v.z; w *= v.w; return *this; }\n      vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }\n\n      vec_t operator * (float f) const;\n      vec_t operator - () const;\n      vec_t operator - (const vec_t& v) const;\n      vec_t operator + (const vec_t& v) const;\n      vec_t operator * (const vec_t& v) const;\n\n      const vec_t& operator + () const { return (*this); }\n      float Length() const { return sqrtf(x * x + y * y + z * z); };\n      float LengthSq() const { return (x * x + y * y + z * z); };\n      vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }\n      vec_t Normalize(const vec_t& v) { this->Set(v.x, v.y, v.z, v.w); this->Normalize(); return (*this); }\n      vec_t Abs() const;\n\n      void Cross(const vec_t& v)\n      {\n         vec_t res;\n         res.x = y * v.z - z * v.y;\n         res.y = z * v.x - x * v.z;\n         res.z = x * v.y - y * v.x;\n\n         x = res.x;\n         y = res.y;\n         z = res.z;\n         w = 0.f;\n      }\n\n      void Cross(const vec_t& v1, const vec_t& v2)\n      {\n         x = v1.y * v2.z - v1.z * v2.y;\n         y = v1.z * v2.x - v1.x * v2.z;\n         z = v1.x * v2.y - v1.y * v2.x;\n         w = 0.f;\n      }\n\n      float Dot(const vec_t& v) const\n      {\n         return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);\n      }\n\n      float Dot3(const vec_t& v) const\n      {\n         return (x * v.x) + (y * v.y) + (z * v.z);\n      }\n\n      void Transform(const matrix_t& matrix);\n      void Transform(const vec_t& s, const matrix_t& matrix);\n\n      void TransformVector(const matrix_t& matrix);\n      void TransformPoint(const matrix_t& matrix);\n      void TransformVector(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformVector(matrix); }\n      void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }\n\n      float& operator [] (size_t index) { return ((float*)&x)[index]; }\n      const float& operator [] (size_t index) const { return ((float*)&x)[index]; }\n      bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }\n   };\n\n   vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }\n   vec_t makeVect(ImVec2 v) { vec_t res; res.x = v.x; res.y = v.y; res.z = 0.f; res.w = 0.f; return res; }\n   vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }\n   vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }\n   vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }\n   vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }\n   vec_t vec_t::operator * (const vec_t& v) const { return makeVect(x * v.x, y * v.y, z * v.z, w * v.w); }\n   vec_t vec_t::Abs() const { return makeVect(fabsf(x), fabsf(y), fabsf(z)); }\n\n   vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }\n   vec_t Cross(const vec_t& v1, const vec_t& v2)\n   {\n      vec_t res;\n      res.x = v1.y * v2.z - v1.z * v2.y;\n      res.y = v1.z * v2.x - v1.x * v2.z;\n      res.z = v1.x * v2.y - v1.y * v2.x;\n      res.w = 0.f;\n      return res;\n   }\n\n   float Dot(const vec_t& v1, const vec_t& v2)\n   {\n      return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);\n   }\n\n   vec_t BuildPlan(const vec_t& p_point1, const vec_t& p_normal)\n   {\n      vec_t normal, res;\n      normal.Normalize(p_normal);\n      res.w = normal.Dot(p_point1);\n      res.x = normal.x;\n      res.y = normal.y;\n      res.z = normal.z;\n      return res;\n   }\n\n   struct matrix_t\n   {\n   public:\n\n      union\n      {\n         float m[4][4];\n         float m16[16];\n         struct\n         {\n            vec_t right, up, dir, position;\n         } v;\n         vec_t component[4];\n      };\n\n      operator float* () { return m16; }\n      operator const float* () const { return m16; }\n      void Translation(float _x, float _y, float _z) { this->Translation(makeVect(_x, _y, _z)); }\n\n      void Translation(const vec_t& vt)\n      {\n         v.right.Set(1.f, 0.f, 0.f, 0.f);\n         v.up.Set(0.f, 1.f, 0.f, 0.f);\n         v.dir.Set(0.f, 0.f, 1.f, 0.f);\n         v.position.Set(vt.x, vt.y, vt.z, 1.f);\n      }\n\n      void Scale(float _x, float _y, float _z)\n      {\n         v.right.Set(_x, 0.f, 0.f, 0.f);\n         v.up.Set(0.f, _y, 0.f, 0.f);\n         v.dir.Set(0.f, 0.f, _z, 0.f);\n         v.position.Set(0.f, 0.f, 0.f, 1.f);\n      }\n      void Scale(const vec_t& s) { Scale(s.x, s.y, s.z); }\n\n      matrix_t& operator *= (const matrix_t& mat)\n      {\n         matrix_t tmpMat;\n         tmpMat = *this;\n         tmpMat.Multiply(mat);\n         *this = tmpMat;\n         return *this;\n      }\n      matrix_t operator * (const matrix_t& mat) const\n      {\n         matrix_t matT;\n         matT.Multiply(*this, mat);\n         return matT;\n      }\n\n      void Multiply(const matrix_t& matrix)\n      {\n         matrix_t tmp;\n         tmp = *this;\n\n         FPU_MatrixF_x_MatrixF((float*)&tmp, (float*)&matrix, (float*)this);\n      }\n\n      void Multiply(const matrix_t& m1, const matrix_t& m2)\n      {\n         FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);\n      }\n\n      float GetDeterminant() const\n      {\n         return m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] -\n            m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1];\n      }\n\n      float Inverse(const matrix_t& srcMatrix, bool affine = false);\n      void SetToIdentity()\n      {\n         v.right.Set(1.f, 0.f, 0.f, 0.f);\n         v.up.Set(0.f, 1.f, 0.f, 0.f);\n         v.dir.Set(0.f, 0.f, 1.f, 0.f);\n         v.position.Set(0.f, 0.f, 0.f, 1.f);\n      }\n      void Transpose()\n      {\n         matrix_t tmpm;\n         for (int l = 0; l < 4; l++)\n         {\n            for (int c = 0; c < 4; c++)\n            {\n               tmpm.m[l][c] = m[c][l];\n            }\n         }\n         (*this) = tmpm;\n      }\n\n      void RotationAxis(const vec_t& axis, float angle);\n\n      void OrthoNormalize()\n      {\n         v.right.Normalize();\n         v.up.Normalize();\n         v.dir.Normalize();\n      }\n   };\n\n   void vec_t::Transform(const matrix_t& matrix)\n   {\n      vec_t out;\n\n      out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];\n      out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];\n      out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];\n      out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];\n\n      x = out.x;\n      y = out.y;\n      z = out.z;\n      w = out.w;\n   }\n\n   void vec_t::Transform(const vec_t& s, const matrix_t& matrix)\n   {\n      *this = s;\n      Transform(matrix);\n   }\n\n   void vec_t::TransformPoint(const matrix_t& matrix)\n   {\n      vec_t out;\n\n      out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];\n      out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];\n      out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];\n      out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];\n\n      x = out.x;\n      y = out.y;\n      z = out.z;\n      w = out.w;\n   }\n\n   void vec_t::TransformVector(const matrix_t& matrix)\n   {\n      vec_t out;\n\n      out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];\n      out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];\n      out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];\n      out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];\n\n      x = out.x;\n      y = out.y;\n      z = out.z;\n      w = out.w;\n   }\n\n   float matrix_t::Inverse(const matrix_t& srcMatrix, bool affine)\n   {\n      float det = 0;\n\n      if (affine)\n      {\n         det = GetDeterminant();\n         float s = 1 / det;\n         m[0][0] = (srcMatrix.m[1][1] * srcMatrix.m[2][2] - srcMatrix.m[1][2] * srcMatrix.m[2][1]) * s;\n         m[0][1] = (srcMatrix.m[2][1] * srcMatrix.m[0][2] - srcMatrix.m[2][2] * srcMatrix.m[0][1]) * s;\n         m[0][2] = (srcMatrix.m[0][1] * srcMatrix.m[1][2] - srcMatrix.m[0][2] * srcMatrix.m[1][1]) * s;\n         m[1][0] = (srcMatrix.m[1][2] * srcMatrix.m[2][0] - srcMatrix.m[1][0] * srcMatrix.m[2][2]) * s;\n         m[1][1] = (srcMatrix.m[2][2] * srcMatrix.m[0][0] - srcMatrix.m[2][0] * srcMatrix.m[0][2]) * s;\n         m[1][2] = (srcMatrix.m[0][2] * srcMatrix.m[1][0] - srcMatrix.m[0][0] * srcMatrix.m[1][2]) * s;\n         m[2][0] = (srcMatrix.m[1][0] * srcMatrix.m[2][1] - srcMatrix.m[1][1] * srcMatrix.m[2][0]) * s;\n         m[2][1] = (srcMatrix.m[2][0] * srcMatrix.m[0][1] - srcMatrix.m[2][1] * srcMatrix.m[0][0]) * s;\n         m[2][2] = (srcMatrix.m[0][0] * srcMatrix.m[1][1] - srcMatrix.m[0][1] * srcMatrix.m[1][0]) * s;\n         m[3][0] = -(m[0][0] * srcMatrix.m[3][0] + m[1][0] * srcMatrix.m[3][1] + m[2][0] * srcMatrix.m[3][2]);\n         m[3][1] = -(m[0][1] * srcMatrix.m[3][0] + m[1][1] * srcMatrix.m[3][1] + m[2][1] * srcMatrix.m[3][2]);\n         m[3][2] = -(m[0][2] * srcMatrix.m[3][0] + m[1][2] * srcMatrix.m[3][1] + m[2][2] * srcMatrix.m[3][2]);\n      }\n      else\n      {\n         // transpose matrix\n         float src[16];\n         for (int i = 0; i < 4; ++i)\n         {\n            src[i] = srcMatrix.m16[i * 4];\n            src[i + 4] = srcMatrix.m16[i * 4 + 1];\n            src[i + 8] = srcMatrix.m16[i * 4 + 2];\n            src[i + 12] = srcMatrix.m16[i * 4 + 3];\n         }\n\n         // calculate pairs for first 8 elements (cofactors)\n         float tmp[12]; // temp array for pairs\n         tmp[0] = src[10] * src[15];\n         tmp[1] = src[11] * src[14];\n         tmp[2] = src[9] * src[15];\n         tmp[3] = src[11] * src[13];\n         tmp[4] = src[9] * src[14];\n         tmp[5] = src[10] * src[13];\n         tmp[6] = src[8] * src[15];\n         tmp[7] = src[11] * src[12];\n         tmp[8] = src[8] * src[14];\n         tmp[9] = src[10] * src[12];\n         tmp[10] = src[8] * src[13];\n         tmp[11] = src[9] * src[12];\n\n         // calculate first 8 elements (cofactors)\n         m16[0] = (tmp[0] * src[5] + tmp[3] * src[6] + tmp[4] * src[7]) - (tmp[1] * src[5] + tmp[2] * src[6] + tmp[5] * src[7]);\n         m16[1] = (tmp[1] * src[4] + tmp[6] * src[6] + tmp[9] * src[7]) - (tmp[0] * src[4] + tmp[7] * src[6] + tmp[8] * src[7]);\n         m16[2] = (tmp[2] * src[4] + tmp[7] * src[5] + tmp[10] * src[7]) - (tmp[3] * src[4] + tmp[6] * src[5] + tmp[11] * src[7]);\n         m16[3] = (tmp[5] * src[4] + tmp[8] * src[5] + tmp[11] * src[6]) - (tmp[4] * src[4] + tmp[9] * src[5] + tmp[10] * src[6]);\n         m16[4] = (tmp[1] * src[1] + tmp[2] * src[2] + tmp[5] * src[3]) - (tmp[0] * src[1] + tmp[3] * src[2] + tmp[4] * src[3]);\n         m16[5] = (tmp[0] * src[0] + tmp[7] * src[2] + tmp[8] * src[3]) - (tmp[1] * src[0] + tmp[6] * src[2] + tmp[9] * src[3]);\n         m16[6] = (tmp[3] * src[0] + tmp[6] * src[1] + tmp[11] * src[3]) - (tmp[2] * src[0] + tmp[7] * src[1] + tmp[10] * src[3]);\n         m16[7] = (tmp[4] * src[0] + tmp[9] * src[1] + tmp[10] * src[2]) - (tmp[5] * src[0] + tmp[8] * src[1] + tmp[11] * src[2]);\n\n         // calculate pairs for second 8 elements (cofactors)\n         tmp[0] = src[2] * src[7];\n         tmp[1] = src[3] * src[6];\n         tmp[2] = src[1] * src[7];\n         tmp[3] = src[3] * src[5];\n         tmp[4] = src[1] * src[6];\n         tmp[5] = src[2] * src[5];\n         tmp[6] = src[0] * src[7];\n         tmp[7] = src[3] * src[4];\n         tmp[8] = src[0] * src[6];\n         tmp[9] = src[2] * src[4];\n         tmp[10] = src[0] * src[5];\n         tmp[11] = src[1] * src[4];\n\n         // calculate second 8 elements (cofactors)\n         m16[8] = (tmp[0] * src[13] + tmp[3] * src[14] + tmp[4] * src[15]) - (tmp[1] * src[13] + tmp[2] * src[14] + tmp[5] * src[15]);\n         m16[9] = (tmp[1] * src[12] + tmp[6] * src[14] + tmp[9] * src[15]) - (tmp[0] * src[12] + tmp[7] * src[14] + tmp[8] * src[15]);\n         m16[10] = (tmp[2] * src[12] + tmp[7] * src[13] + tmp[10] * src[15]) - (tmp[3] * src[12] + tmp[6] * src[13] + tmp[11] * src[15]);\n         m16[11] = (tmp[5] * src[12] + tmp[8] * src[13] + tmp[11] * src[14]) - (tmp[4] * src[12] + tmp[9] * src[13] + tmp[10] * src[14]);\n         m16[12] = (tmp[2] * src[10] + tmp[5] * src[11] + tmp[1] * src[9]) - (tmp[4] * src[11] + tmp[0] * src[9] + tmp[3] * src[10]);\n         m16[13] = (tmp[8] * src[11] + tmp[0] * src[8] + tmp[7] * src[10]) - (tmp[6] * src[10] + tmp[9] * src[11] + tmp[1] * src[8]);\n         m16[14] = (tmp[6] * src[9] + tmp[11] * src[11] + tmp[3] * src[8]) - (tmp[10] * src[11] + tmp[2] * src[8] + tmp[7] * src[9]);\n         m16[15] = (tmp[10] * src[10] + tmp[4] * src[8] + tmp[9] * src[9]) - (tmp[8] * src[9] + tmp[11] * src[10] + tmp[5] * src[8]);\n\n         // calculate determinant\n         det = src[0] * m16[0] + src[1] * m16[1] + src[2] * m16[2] + src[3] * m16[3];\n\n         // calculate matrix inverse\n         float invdet = 1 / det;\n         for (int j = 0; j < 16; ++j)\n         {\n            m16[j] *= invdet;\n         }\n      }\n\n      return det;\n   }\n\n   void matrix_t::RotationAxis(const vec_t& axis, float angle)\n   {\n      float length2 = axis.LengthSq();\n      if (length2 < FLT_EPSILON)\n      {\n         SetToIdentity();\n         return;\n      }\n\n      vec_t n = axis * (1.f / sqrtf(length2));\n      float s = sinf(angle);\n      float c = cosf(angle);\n      float k = 1.f - c;\n\n      float xx = n.x * n.x * k + c;\n      float yy = n.y * n.y * k + c;\n      float zz = n.z * n.z * k + c;\n      float xy = n.x * n.y * k;\n      float yz = n.y * n.z * k;\n      float zx = n.z * n.x * k;\n      float xs = n.x * s;\n      float ys = n.y * s;\n      float zs = n.z * s;\n\n      m[0][0] = xx;\n      m[0][1] = xy + zs;\n      m[0][2] = zx - ys;\n      m[0][3] = 0.f;\n      m[1][0] = xy - zs;\n      m[1][1] = yy;\n      m[1][2] = yz + xs;\n      m[1][3] = 0.f;\n      m[2][0] = zx + ys;\n      m[2][1] = yz - xs;\n      m[2][2] = zz;\n      m[2][3] = 0.f;\n      m[3][0] = 0.f;\n      m[3][1] = 0.f;\n      m[3][2] = 0.f;\n      m[3][3] = 1.f;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   //\n\n   enum MOVETYPE\n   {\n      MT_NONE,\n      MT_MOVE_X,\n      MT_MOVE_Y,\n      MT_MOVE_Z,\n      MT_MOVE_YZ,\n      MT_MOVE_ZX,\n      MT_MOVE_XY,\n      MT_MOVE_SCREEN,\n      MT_ROTATE_X,\n      MT_ROTATE_Y,\n      MT_ROTATE_Z,\n      MT_ROTATE_SCREEN,\n      MT_SCALE_X,\n      MT_SCALE_Y,\n      MT_SCALE_Z,\n      MT_SCALE_XYZ\n   };\n\n   static bool IsTranslateType(int type)\n   {\n     return type >= MT_MOVE_X && type <= MT_MOVE_SCREEN;\n   }\n\n   static bool IsRotateType(int type)\n   {\n     return type >= MT_ROTATE_X && type <= MT_ROTATE_SCREEN;\n   }\n\n   static bool IsScaleType(int type)\n   {\n     return type >= MT_SCALE_X && type <= MT_SCALE_XYZ;\n   }\n\n   // Matches MT_MOVE_AB order\n   static const OPERATION TRANSLATE_PLANS[3] = { TRANSLATE_Y | TRANSLATE_Z, TRANSLATE_X | TRANSLATE_Z, TRANSLATE_X | TRANSLATE_Y };\n\n   Style::Style()\n   {\n      // default values\n      TranslationLineThickness   = 3.0f;\n      TranslationLineArrowSize   = 6.0f;\n      RotationLineThickness      = 2.0f;\n      RotationOuterLineThickness = 3.0f;\n      ScaleLineThickness         = 3.0f;\n      ScaleLineCircleSize        = 6.0f;\n      HatchedAxisLineThickness   = 6.0f;\n      CenterCircleSize           = 6.0f;\n\n      // initialize default colors\n      Colors[DIRECTION_X]           = ImVec4(0.666f, 0.000f, 0.000f, 1.000f);\n      Colors[DIRECTION_Y]           = ImVec4(0.000f, 0.666f, 0.000f, 1.000f);\n      Colors[DIRECTION_Z]           = ImVec4(0.000f, 0.000f, 0.666f, 1.000f);\n      Colors[PLANE_X]               = ImVec4(0.666f, 0.000f, 0.000f, 0.380f);\n      Colors[PLANE_Y]               = ImVec4(0.000f, 0.666f, 0.000f, 0.380f);\n      Colors[PLANE_Z]               = ImVec4(0.000f, 0.000f, 0.666f, 0.380f);\n      Colors[SELECTION]             = ImVec4(1.000f, 0.500f, 0.062f, 0.541f);\n      Colors[INACTIVE]              = ImVec4(0.600f, 0.600f, 0.600f, 0.600f);\n      Colors[TRANSLATION_LINE]      = ImVec4(0.666f, 0.666f, 0.666f, 0.666f);\n      Colors[SCALE_LINE]            = ImVec4(0.250f, 0.250f, 0.250f, 1.000f);\n      Colors[ROTATION_USING_BORDER] = ImVec4(1.000f, 0.500f, 0.062f, 1.000f);\n      Colors[ROTATION_USING_FILL]   = ImVec4(1.000f, 0.500f, 0.062f, 0.500f);\n      Colors[HATCHED_AXIS_LINES]    = ImVec4(0.000f, 0.000f, 0.000f, 0.500f);\n      Colors[TEXT]                  = ImVec4(1.000f, 1.000f, 1.000f, 1.000f);\n      Colors[TEXT_SHADOW]           = ImVec4(0.000f, 0.000f, 0.000f, 1.000f);\n   }\n\n   struct Context\n   {\n      Context() : mbUsing(false), mbUsingViewManipulate(false), mbEnable(true), mIsViewManipulatorHovered(false), mbUsingBounds(false)\n      {\n      }\n\n      ImDrawList* mDrawList;\n      Style mStyle;\n\n      MODE mMode;\n      matrix_t mViewMat;\n      matrix_t mProjectionMat;\n      matrix_t mModel;\n      matrix_t mModelLocal; // orthonormalized model\n      matrix_t mModelInverse;\n      matrix_t mModelSource;\n      matrix_t mModelSourceInverse;\n      matrix_t mMVP;\n      matrix_t mMVPLocal; // MVP with full model matrix whereas mMVP's model matrix might only be translation in case of World space edition\n      matrix_t mViewProjection;\n\n      vec_t mModelScaleOrigin;\n      vec_t mCameraEye;\n      vec_t mCameraRight;\n      vec_t mCameraDir;\n      vec_t mCameraUp;\n      vec_t mRayOrigin;\n      vec_t mRayVector;\n\n      float  mRadiusSquareCenter;\n      ImVec2 mScreenSquareCenter;\n      ImVec2 mScreenSquareMin;\n      ImVec2 mScreenSquareMax;\n\n      float mScreenFactor;\n      vec_t mRelativeOrigin;\n\n      bool mbUsing;\n      bool mbUsingViewManipulate;\n      bool mbEnable;\n      bool mbMouseOver;\n      bool mReversed; // reversed projection matrix\n      bool mIsViewManipulatorHovered;\n\n      // translation\n      vec_t mTranslationPlan;\n      vec_t mTranslationPlanOrigin;\n      vec_t mMatrixOrigin;\n      vec_t mTranslationLastDelta;\n\n      // rotation\n      vec_t mRotationVectorSource;\n      float mRotationAngle;\n      float mRotationAngleOrigin;\n      //vec_t mWorldToLocalAxis;\n\n      // scale\n      vec_t mScale;\n      vec_t mScaleValueOrigin;\n      vec_t mScaleLast;\n      float mSaveMousePosx;\n\n      // save axis factor when using gizmo\n      bool mBelowAxisLimit[3];\n      int mAxisMask = 0;\n      bool mBelowPlaneLimit[3];\n      float mAxisFactor[3];\n\n      float mAxisLimit=0.0025f;\n      float mPlaneLimit=0.02f;\n\n      // bounds stretching\n      vec_t mBoundsPivot;\n      vec_t mBoundsAnchor;\n      vec_t mBoundsPlan;\n      vec_t mBoundsLocalPivot;\n      int mBoundsBestAxis;\n      int mBoundsAxis[2];\n      bool mbUsingBounds;\n      matrix_t mBoundsMatrix;\n\n      //\n      int mCurrentOperation;\n\n      float mX = 0.f;\n      float mY = 0.f;\n      float mWidth = 0.f;\n      float mHeight = 0.f;\n      float mXMax = 0.f;\n      float mYMax = 0.f;\n      float mDisplayRatio = 1.f;\n\n      bool mIsOrthographic = false;\n      // check to not have multiple gizmo highlighted at the same time\n      bool mbOverGizmoHotspot = false;\n\n      ImGuiWindow* mAlternativeWindow = nullptr;\n      ImVector<ImGuiID> mIDStack;\n      ImGuiID mEditingID = -1;\n      OPERATION mOperation = OPERATION(-1);\n\n      bool mAllowAxisFlip = true;\n      float mGizmoSizeClipSpace = 0.1f;\n\n      inline ImGuiID GetCurrentID()\n      {\n         if (mIDStack.empty())\n         {\n            mIDStack.push_back(-1);\n         }\n         return mIDStack.back();\n      }\n   };\n\n   static Context gContext;\n\n   static const vec_t directionUnary[3] = { makeVect(1.f, 0.f, 0.f), makeVect(0.f, 1.f, 0.f), makeVect(0.f, 0.f, 1.f) };\n   static const char* translationInfoMask[] = { \"X : %5.3f\", \"Y : %5.3f\", \"Z : %5.3f\",\n      \"Y : %5.3f Z : %5.3f\", \"X : %5.3f Z : %5.3f\", \"X : %5.3f Y : %5.3f\",\n      \"X : %5.3f Y : %5.3f Z : %5.3f\" };\n   static const char* scaleInfoMask[] = { \"X : %5.2f\", \"Y : %5.2f\", \"Z : %5.2f\", \"XYZ : %5.2f\" };\n   static const char* rotationInfoMask[] = { \"X : %5.2f deg %5.2f rad\", \"Y : %5.2f deg %5.2f rad\", \"Z : %5.2f deg %5.2f rad\", \"Screen : %5.2f deg %5.2f rad\" };\n   static const int translationInfoIndex[] = { 0,0,0, 1,0,0, 2,0,0, 1,2,0, 0,2,0, 0,1,0, 0,1,2 };\n   static const float quadMin = 0.5f;\n   static const float quadMax = 0.8f;\n   static const float quadUV[8] = { quadMin, quadMin, quadMin, quadMax, quadMax, quadMax, quadMax, quadMin };\n   static const int halfCircleSegmentCount = 64;\n   static const float snapTension = 0.5f;\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   //\n   static int GetMoveType(OPERATION op, vec_t* gizmoHitProportion);\n   static int GetRotateType(OPERATION op);\n   static int GetScaleType(OPERATION op);\n\n   Style& GetStyle()\n   {\n      return gContext.mStyle;\n   }\n\n   static ImU32 GetColorU32(int idx)\n   {\n      IM_ASSERT(idx < COLOR::COUNT);\n      return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);\n   }\n\n   static ImVec2 worldToPos(const vec_t& worldPos, const matrix_t& mat, ImVec2 position = ImVec2(gContext.mX, gContext.mY), ImVec2 size = ImVec2(gContext.mWidth, gContext.mHeight))\n   {\n      vec_t trans;\n      trans.TransformPoint(worldPos, mat);\n      trans *= 0.5f / trans.w;\n      trans += makeVect(0.5f, 0.5f);\n      trans.y = 1.f - trans.y;\n      trans.x *= size.x;\n      trans.y *= size.y;\n      trans.x += position.x;\n      trans.y += position.y;\n      return ImVec2(trans.x, trans.y);\n   }\n\n   static void ComputeCameraRay(vec_t& rayOrigin, vec_t& rayDir, ImVec2 position = ImVec2(gContext.mX, gContext.mY), ImVec2 size = ImVec2(gContext.mWidth, gContext.mHeight))\n   {\n      ImGuiIO& io = ImGui::GetIO();\n\n      matrix_t mViewProjInverse;\n      mViewProjInverse.Inverse(gContext.mViewMat * gContext.mProjectionMat);\n\n      const float mox = ((io.MousePos.x - position.x) / size.x) * 2.f - 1.f;\n      const float moy = (1.f - ((io.MousePos.y - position.y) / size.y)) * 2.f - 1.f;\n\n      const float zNear = gContext.mReversed ? (1.f - FLT_EPSILON) : 0.f;\n      const float zFar = gContext.mReversed ? 0.f : (1.f - FLT_EPSILON);\n\n      rayOrigin.Transform(makeVect(mox, moy, zNear, 1.f), mViewProjInverse);\n      rayOrigin *= 1.f / rayOrigin.w;\n      vec_t rayEnd;\n      rayEnd.Transform(makeVect(mox, moy, zFar, 1.f), mViewProjInverse);\n      rayEnd *= 1.f / rayEnd.w;\n      rayDir = Normalized(rayEnd - rayOrigin);\n   }\n\n   static float GetSegmentLengthClipSpace(const vec_t& start, const vec_t& end, const bool localCoordinates = false)\n   {\n      vec_t startOfSegment = start;\n      const matrix_t& mvp = localCoordinates ? gContext.mMVPLocal : gContext.mMVP;\n      startOfSegment.TransformPoint(mvp);\n      if (fabsf(startOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction\n      {\n         startOfSegment *= 1.f / startOfSegment.w;\n      }\n\n      vec_t endOfSegment = end;\n      endOfSegment.TransformPoint(mvp);\n      if (fabsf(endOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction\n      {\n         endOfSegment *= 1.f / endOfSegment.w;\n      }\n\n      vec_t clipSpaceAxis = endOfSegment - startOfSegment;\n      if (gContext.mDisplayRatio < 1.0)\n         clipSpaceAxis.x *= gContext.mDisplayRatio;\n      else\n         clipSpaceAxis.y /= gContext.mDisplayRatio;\n      float segmentLengthInClipSpace = sqrtf(clipSpaceAxis.x * clipSpaceAxis.x + clipSpaceAxis.y * clipSpaceAxis.y);\n      return segmentLengthInClipSpace;\n   }\n\n   static float GetParallelogram(const vec_t& ptO, const vec_t& ptA, const vec_t& ptB)\n   {\n      vec_t pts[] = { ptO, ptA, ptB };\n      for (unsigned int i = 0; i < 3; i++)\n      {\n         pts[i].TransformPoint(gContext.mMVP);\n         if (fabsf(pts[i].w) > FLT_EPSILON) // check for axis aligned with camera direction\n         {\n            pts[i] *= 1.f / pts[i].w;\n         }\n      }\n      vec_t segA = pts[1] - pts[0];\n      vec_t segB = pts[2] - pts[0];\n      segA.y /= gContext.mDisplayRatio;\n      segB.y /= gContext.mDisplayRatio;\n      vec_t segAOrtho = makeVect(-segA.y, segA.x);\n      segAOrtho.Normalize();\n      float dt = segAOrtho.Dot3(segB);\n      float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);\n      return surface;\n   }\n\n   inline vec_t PointOnSegment(const vec_t& point, const vec_t& vertPos1, const vec_t& vertPos2)\n   {\n      vec_t c = point - vertPos1;\n      vec_t V;\n\n      V.Normalize(vertPos2 - vertPos1);\n      float d = (vertPos2 - vertPos1).Length();\n      float t = V.Dot3(c);\n\n      if (t < 0.f)\n      {\n         return vertPos1;\n      }\n\n      if (t > d)\n      {\n         return vertPos2;\n      }\n\n      return vertPos1 + V * t;\n   }\n\n   static float IntersectRayPlane(const vec_t& rOrigin, const vec_t& rVector, const vec_t& plan)\n   {\n      const float numer = plan.Dot3(rOrigin) - plan.w;\n      const float denom = plan.Dot3(rVector);\n\n      if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect\n      {\n         return -1.0f;\n      }\n\n      return -(numer / denom);\n   }\n\n   static float DistanceToPlane(const vec_t& point, const vec_t& plan)\n   {\n      return plan.Dot3(point) + plan.w;\n   }\n\n   static bool IsInContextRect(ImVec2 p)\n   {\n      return IsWithin(p.x, gContext.mX, gContext.mXMax) && IsWithin(p.y, gContext.mY, gContext.mYMax);\n   }\n\n   static bool IsHoveringWindow()\n   {\n      ImGuiContext& g = *ImGui::GetCurrentContext();\n      ImGuiWindow* window = ImGui::FindWindowByName(gContext.mDrawList->_OwnerName);\n      if (g.HoveredWindow == window)   // Mouse hovering drawlist window\n         return true;\n      if (gContext.mAlternativeWindow != nullptr && g.HoveredWindow == gContext.mAlternativeWindow)\n         return true;\n      if (g.HoveredWindow != NULL)     // Any other window is hovered\n         return false;\n      if (ImGui::IsMouseHoveringRect(window->InnerRect.Min, window->InnerRect.Max, false))   // Hovering drawlist window rect, while no other window is hovered (for _NoInputs windows)\n         return true;\n      return false;\n   }\n\n   void SetRect(float x, float y, float width, float height)\n   {\n      gContext.mX = x;\n      gContext.mY = y;\n      gContext.mWidth = width;\n      gContext.mHeight = height;\n      gContext.mXMax = gContext.mX + gContext.mWidth;\n      gContext.mYMax = gContext.mY + gContext.mXMax;\n      gContext.mDisplayRatio = width / height;\n   }\n\n   void SetOrthographic(bool isOrthographic)\n   {\n      gContext.mIsOrthographic = isOrthographic;\n   }\n\n   void SetDrawlist(ImDrawList* drawlist)\n   {\n      gContext.mDrawList = drawlist ? drawlist : ImGui::GetWindowDrawList();\n   }\n\n   void SetImGuiContext(ImGuiContext* ctx)\n   {\n      ImGui::SetCurrentContext(ctx);\n   }\n\n   void BeginFrame()\n   {\n      const ImU32 flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoBringToFrontOnFocus;\n\n#ifdef IMGUI_HAS_VIEWPORT\n      ImGui::SetNextWindowSize(ImGui::GetMainViewport()->Size);\n      ImGui::SetNextWindowPos(ImGui::GetMainViewport()->Pos);\n#else\n      ImGuiIO& io = ImGui::GetIO();\n      ImGui::SetNextWindowSize(io.DisplaySize);\n      ImGui::SetNextWindowPos(ImVec2(0, 0));\n#endif\n\n      ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);\n      ImGui::PushStyleColor(ImGuiCol_Border, 0);\n      ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);\n\n      ImGui::Begin(\"gizmo\", NULL, flags);\n      gContext.mDrawList = ImGui::GetWindowDrawList();\n      gContext.mbOverGizmoHotspot = false;\n      ImGui::End();\n      ImGui::PopStyleVar();\n      ImGui::PopStyleColor(2);\n   }\n\n   bool IsUsing()\n   {\n      return (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID)) || gContext.mbUsingBounds;\n   }\n\n   bool IsUsingViewManipulate()\n   {\n      return gContext.mbUsingViewManipulate;\n   }\n\n   bool IsViewManipulateHovered()\n   {\n      return gContext.mIsViewManipulatorHovered;\n   }\n\n   bool IsUsingAny()\n   {\n      return gContext.mbUsing || gContext.mbUsingBounds;\n   }\n\n   bool IsOver()\n   {\n      return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||\n         (Intersects(gContext.mOperation, ROTATE) && GetRotateType(gContext.mOperation) != MT_NONE) ||\n         (Intersects(gContext.mOperation, SCALE) && GetScaleType(gContext.mOperation) != MT_NONE) || IsUsing();\n   }\n\n   bool IsOver(OPERATION op)\n   {\n      if(IsUsing())\n      {\n         return true;\n      }\n      if(Intersects(op, SCALE) && GetScaleType(op) != MT_NONE)\n      {\n         return true;\n      }\n      if(Intersects(op, ROTATE) && GetRotateType(op) != MT_NONE)\n      {\n         return true;\n      }\n      if(Intersects(op, TRANSLATE) && GetMoveType(op, NULL) != MT_NONE)\n      {\n         return true;\n      }\n      return false;\n   }\n\n   void Enable(bool enable)\n   {\n      gContext.mbEnable = enable;\n      if (!enable)\n      {\n         gContext.mbUsing = false;\n         gContext.mbUsingBounds = false;\n      }\n   }\n\n   static void ComputeContext(const float* view, const float* projection, float* matrix, MODE mode)\n   {\n      gContext.mMode = mode;\n      gContext.mViewMat = *(matrix_t*)view;\n      gContext.mProjectionMat = *(matrix_t*)projection;\n      gContext.mbMouseOver = IsHoveringWindow();\n\n      gContext.mModelLocal = *(matrix_t*)matrix;\n      gContext.mModelLocal.OrthoNormalize();\n\n      if (mode == LOCAL)\n      {\n         gContext.mModel = gContext.mModelLocal;\n      }\n      else\n      {\n         gContext.mModel.Translation(((matrix_t*)matrix)->v.position);\n      }\n      gContext.mModelSource = *(matrix_t*)matrix;\n      gContext.mModelScaleOrigin.Set(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());\n\n      gContext.mModelInverse.Inverse(gContext.mModel);\n      gContext.mModelSourceInverse.Inverse(gContext.mModelSource);\n      gContext.mViewProjection = gContext.mViewMat * gContext.mProjectionMat;\n      gContext.mMVP = gContext.mModel * gContext.mViewProjection;\n      gContext.mMVPLocal = gContext.mModelLocal * gContext.mViewProjection;\n\n      matrix_t viewInverse;\n      viewInverse.Inverse(gContext.mViewMat);\n      gContext.mCameraDir = viewInverse.v.dir;\n      gContext.mCameraEye = viewInverse.v.position;\n      gContext.mCameraRight = viewInverse.v.right;\n      gContext.mCameraUp = viewInverse.v.up;\n\n      // projection reverse\n       vec_t nearPos, farPos;\n       nearPos.Transform(makeVect(0, 0, 1.f, 1.f), gContext.mProjectionMat);\n       farPos.Transform(makeVect(0, 0, 2.f, 1.f), gContext.mProjectionMat);\n\n       gContext.mReversed = (nearPos.z/nearPos.w) > (farPos.z / farPos.w);\n\n      // compute scale from the size of camera right vector projected on screen at the matrix position\n      vec_t pointRight = viewInverse.v.right;\n      pointRight.TransformPoint(gContext.mViewProjection);\n\n      vec_t rightViewInverse = viewInverse.v.right;\n      rightViewInverse.TransformVector(gContext.mModelInverse);\n      float rightLength = GetSegmentLengthClipSpace(makeVect(0.f, 0.f), rightViewInverse);\n      gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / rightLength;\n\n      ImVec2 centerSSpace = worldToPos(makeVect(0.f, 0.f), gContext.mMVP);\n      gContext.mScreenSquareCenter = centerSSpace;\n      gContext.mScreenSquareMin = ImVec2(centerSSpace.x - 10.f, centerSSpace.y - 10.f);\n      gContext.mScreenSquareMax = ImVec2(centerSSpace.x + 10.f, centerSSpace.y + 10.f);\n\n      ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);\n   }\n\n   static void ComputeColors(ImU32* colors, int type, OPERATION operation)\n   {\n      if (gContext.mbEnable)\n      {\n         ImU32 selectionColor = GetColorU32(SELECTION);\n\n         switch (operation)\n         {\n         case TRANSLATE:\n            colors[0] = (type == MT_MOVE_SCREEN) ? selectionColor : IM_COL32_WHITE;\n            for (int i = 0; i < 3; i++)\n            {\n               colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);\n               colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);\n               colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];\n            }\n            break;\n         case ROTATE:\n            colors[0] = (type == MT_ROTATE_SCREEN) ? selectionColor : IM_COL32_WHITE;\n            for (int i = 0; i < 3; i++)\n            {\n               colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);\n            }\n            break;\n         case SCALEU:\n         case SCALE:\n            colors[0] = (type == MT_SCALE_XYZ) ? selectionColor : IM_COL32_WHITE;\n            for (int i = 0; i < 3; i++)\n            {\n               colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);\n            }\n            break;\n         // note: this internal function is only called with three possible values for operation\n         default:\n            break;\n         }\n      }\n      else\n      {\n         ImU32 inactiveColor = GetColorU32(INACTIVE);\n         for (int i = 0; i < 7; i++)\n         {\n            colors[i] = inactiveColor;\n         }\n      }\n   }\n\n   static void ComputeTripodAxisAndVisibility(const int axisIndex, vec_t& dirAxis, vec_t& dirPlaneX, vec_t& dirPlaneY, bool& belowAxisLimit, bool& belowPlaneLimit, const bool localCoordinates = false)\n   {\n      dirAxis = directionUnary[axisIndex];\n      dirPlaneX = directionUnary[(axisIndex + 1) % 3];\n      dirPlaneY = directionUnary[(axisIndex + 2) % 3];\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID))\n      {\n         // when using, use stored factors so the gizmo doesn't flip when we translate\n\n         // Apply axis mask to axes and planes\n         belowAxisLimit = gContext.mBelowAxisLimit[axisIndex] && ((1<<axisIndex)&gContext.mAxisMask);\n         belowPlaneLimit = gContext.mBelowPlaneLimit[axisIndex] && (((1<<axisIndex) == gContext.mAxisMask) || !gContext.mAxisMask);\n\n         dirAxis *= gContext.mAxisFactor[axisIndex];\n         dirPlaneX *= gContext.mAxisFactor[(axisIndex + 1) % 3];\n         dirPlaneY *= gContext.mAxisFactor[(axisIndex + 2) % 3];\n      }\n      else\n      {\n         // new method\n         float lenDir = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis, localCoordinates);\n         float lenDirMinus = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirAxis, localCoordinates);\n\n         float lenDirPlaneX = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirPlaneX, localCoordinates);\n         float lenDirMinusPlaneX = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneX, localCoordinates);\n\n         float lenDirPlaneY = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirPlaneY, localCoordinates);\n         float lenDirMinusPlaneY = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneY, localCoordinates);\n\n         // For readability\n         bool & allowFlip = gContext.mAllowAxisFlip;\n         float mulAxis = (allowFlip && lenDir < lenDirMinus&& fabsf(lenDir - lenDirMinus) > FLT_EPSILON) ? -1.f : 1.f;\n         float mulAxisX = (allowFlip && lenDirPlaneX < lenDirMinusPlaneX&& fabsf(lenDirPlaneX - lenDirMinusPlaneX) > FLT_EPSILON) ? -1.f : 1.f;\n         float mulAxisY = (allowFlip && lenDirPlaneY < lenDirMinusPlaneY&& fabsf(lenDirPlaneY - lenDirMinusPlaneY) > FLT_EPSILON) ? -1.f : 1.f;\n         dirAxis *= mulAxis;\n         dirPlaneX *= mulAxisX;\n         dirPlaneY *= mulAxisY;\n\n         // for axis\n         float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);\n\n         float paraSurf = GetParallelogram(makeVect(0.f, 0.f, 0.f), dirPlaneX * gContext.mScreenFactor, dirPlaneY * gContext.mScreenFactor);\n         // Apply axis mask to axes and planes\n         belowPlaneLimit = (paraSurf > gContext.mAxisLimit) && (((1<<axisIndex) == gContext.mAxisMask) || !gContext.mAxisMask);\n         belowAxisLimit = (axisLengthInClipSpace > gContext.mPlaneLimit) && !((1<<axisIndex)&gContext.mAxisMask);\n\n         // and store values\n         gContext.mAxisFactor[axisIndex] = mulAxis;\n         gContext.mAxisFactor[(axisIndex + 1) % 3] = mulAxisX;\n         gContext.mAxisFactor[(axisIndex + 2) % 3] = mulAxisY;\n         gContext.mBelowAxisLimit[axisIndex] = belowAxisLimit;\n         gContext.mBelowPlaneLimit[axisIndex] = belowPlaneLimit;\n      }\n   }\n\n   static void ComputeSnap(float* value, float snap)\n   {\n      if (snap <= FLT_EPSILON)\n      {\n         return;\n      }\n\n      float modulo = fmodf(*value, snap);\n      float moduloRatio = fabsf(modulo) / snap;\n      if (moduloRatio < snapTension)\n      {\n         *value -= modulo;\n      }\n      else if (moduloRatio > (1.f - snapTension))\n      {\n         *value = *value - modulo + snap * ((*value < 0.f) ? -1.f : 1.f);\n      }\n   }\n   static void ComputeSnap(vec_t& value, const float* snap)\n   {\n      for (int i = 0; i < 3; i++)\n      {\n         ComputeSnap(&value[i], snap[i]);\n      }\n   }\n\n   static float ComputeAngleOnPlan()\n   {\n      const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n      vec_t localPos = Normalized(gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position);\n\n      vec_t perpendicularVector;\n      perpendicularVector.Cross(gContext.mRotationVectorSource, gContext.mTranslationPlan);\n      perpendicularVector.Normalize();\n      float acosAngle = Clamp(Dot(localPos, gContext.mRotationVectorSource), -1.f, 1.f);\n      float angle = acosf(acosAngle);\n      angle *= (Dot(localPos, perpendicularVector) < 0.f) ? 1.f : -1.f;\n      return angle;\n   }\n\n   static void DrawRotationGizmo(OPERATION op, int type)\n   {\n      if(!Intersects(op, ROTATE))\n      {\n         return;\n      }\n      ImDrawList* drawList = gContext.mDrawList;\n\n      bool isMultipleAxesMasked = gContext.mAxisMask & (gContext.mAxisMask - 1);\n      bool isNoAxesMasked = !gContext.mAxisMask;\n\n      // colors\n      ImU32 colors[7];\n      ComputeColors(colors, type, ROTATE);\n\n      vec_t cameraToModelNormalized;\n      if (gContext.mIsOrthographic)\n      {\n         matrix_t viewInverse;\n         viewInverse.Inverse(*(matrix_t*)&gContext.mViewMat);\n         cameraToModelNormalized = -viewInverse.v.dir;\n      }\n      else\n      {\n         cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);\n      }\n\n      cameraToModelNormalized.TransformVector(gContext.mModelInverse);\n\n      gContext.mRadiusSquareCenter = screenRotateSize * gContext.mHeight;\n\n      bool hasRSC = Intersects(op, ROTATE_SCREEN);\n      for (int axis = 0; axis < 3; axis++)\n      {\n         if(!Intersects(op, static_cast<OPERATION>(ROTATE_Z >> axis)))\n         {\n            continue;\n         }\n\n         bool isAxisMasked = (1 << (2 - axis)) & gContext.mAxisMask;\n\n         if ((!isAxisMasked || isMultipleAxesMasked) && !isNoAxesMasked)\n         {\n            continue;\n         }\n         const bool usingAxis = (gContext.mbUsing && type == MT_ROTATE_Z - axis);\n         const int circleMul = (hasRSC && !usingAxis) ? 1 : 2;\n\n         ImVec2* circlePos = (ImVec2*)alloca(sizeof(ImVec2) * (circleMul * halfCircleSegmentCount + 1));\n\n         float angleStart = atan2f(cameraToModelNormalized[(4 - axis) % 3], cameraToModelNormalized[(3 - axis) % 3]) + ZPI * 0.5f;\n\n         for (int i = 0; i < circleMul * halfCircleSegmentCount + 1; i++)\n         {\n            float ng = angleStart + (float)circleMul * ZPI * ((float)i / (float)(circleMul * halfCircleSegmentCount));\n            vec_t axisPos = makeVect(cosf(ng), sinf(ng), 0.f);\n            vec_t pos = makeVect(axisPos[axis], axisPos[(axis + 1) % 3], axisPos[(axis + 2) % 3]) * gContext.mScreenFactor * rotationDisplayFactor;\n            circlePos[i] = worldToPos(pos, gContext.mMVP);\n         }\n         if (!gContext.mbUsing || usingAxis)\n         {\n            drawList->AddPolyline(circlePos, circleMul* halfCircleSegmentCount + 1, colors[3 - axis], false, gContext.mStyle.RotationLineThickness);\n         }\n\n         float radiusAxis = sqrtf((ImLengthSqr(worldToPos(gContext.mModel.v.position, gContext.mViewProjection) - circlePos[0])));\n         if (radiusAxis > gContext.mRadiusSquareCenter)\n         {\n            gContext.mRadiusSquareCenter = radiusAxis;\n         }\n      }\n      if(hasRSC && (!gContext.mbUsing || type == MT_ROTATE_SCREEN) && (!isMultipleAxesMasked && isNoAxesMasked))\n      {\n         drawList->AddCircle(worldToPos(gContext.mModel.v.position, gContext.mViewProjection), gContext.mRadiusSquareCenter, colors[0], 64, gContext.mStyle.RotationOuterLineThickness);\n      }\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsRotateType(type))\n      {\n         ImVec2 circlePos[halfCircleSegmentCount + 1];\n\n         circlePos[0] = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n         for (unsigned int i = 1; i < halfCircleSegmentCount + 1; i++)\n         {\n            float ng = gContext.mRotationAngle * ((float)(i - 1) / (float)(halfCircleSegmentCount - 1));\n            matrix_t rotateVectorMatrix;\n            rotateVectorMatrix.RotationAxis(gContext.mTranslationPlan, ng);\n            vec_t pos;\n            pos.TransformPoint(gContext.mRotationVectorSource, rotateVectorMatrix);\n            pos *= gContext.mScreenFactor * rotationDisplayFactor;\n            circlePos[i] = worldToPos(pos + gContext.mModel.v.position, gContext.mViewProjection);\n         }\n         drawList->AddConvexPolyFilled(circlePos, halfCircleSegmentCount + 1, GetColorU32(ROTATION_USING_FILL));\n         drawList->AddPolyline(circlePos, halfCircleSegmentCount + 1, GetColorU32(ROTATION_USING_BORDER), true, gContext.mStyle.RotationLineThickness);\n\n         ImVec2 destinationPosOnScreen = circlePos[1];\n         char tmps[512];\n         ImFormatString(tmps, sizeof(tmps), rotationInfoMask[type - MT_ROTATE_X], (gContext.mRotationAngle / ZPI) * 180.f, gContext.mRotationAngle);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);\n      }\n   }\n\n   static void DrawHatchedAxis(const vec_t& axis)\n   {\n      if (gContext.mStyle.HatchedAxisLineThickness <= 0.0f)\n      {\n         return;\n      }\n\n      for (int j = 1; j < 10; j++)\n      {\n         ImVec2 baseSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2) * gContext.mScreenFactor, gContext.mMVP);\n         ImVec2 worldDirSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2 + 1) * gContext.mScreenFactor, gContext.mMVP);\n         gContext.mDrawList->AddLine(baseSSpace2, worldDirSSpace2, GetColorU32(HATCHED_AXIS_LINES), gContext.mStyle.HatchedAxisLineThickness);\n      }\n   }\n\n   static void DrawScaleGizmo(OPERATION op, int type)\n   {\n      ImDrawList* drawList = gContext.mDrawList;\n\n      if(!Intersects(op, SCALE))\n      {\n        return;\n      }\n\n      // colors\n      ImU32 colors[7];\n      ComputeColors(colors, type, SCALE);\n\n      // draw\n      vec_t scaleDisplay = { 1.f, 1.f, 1.f, 1.f };\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID))\n      {\n         scaleDisplay = gContext.mScale;\n      }\n\n      for (int i = 0; i < 3; i++)\n      {\n         if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))\n         {\n            continue;\n         }\n         const bool usingAxis = (gContext.mbUsing && type == MT_SCALE_X + i);\n         if (!gContext.mbUsing || usingAxis)\n         {\n            vec_t dirPlaneX, dirPlaneY, dirAxis;\n            bool belowAxisLimit, belowPlaneLimit;\n            ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);\n\n            // draw axis\n            if (belowAxisLimit)\n            {\n               bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));\n               float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;\n               ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);\n               ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);\n               ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVP);\n\n               if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID))\n               {\n                  ImU32 scaleLineColor = GetColorU32(SCALE_LINE);\n                  drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, scaleLineColor, gContext.mStyle.ScaleLineThickness);\n                  drawList->AddCircleFilled(worldDirSSpaceNoScale, gContext.mStyle.ScaleLineCircleSize, scaleLineColor);\n               }\n\n               if (!hasTranslateOnAxis || gContext.mbUsing)\n               {\n                  drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.ScaleLineThickness);\n               }\n               drawList->AddCircleFilled(worldDirSSpace, gContext.mStyle.ScaleLineCircleSize, colors[i + 1]);\n\n               if (gContext.mAxisFactor[i] < 0.f)\n               {\n                  DrawHatchedAxis(dirAxis * scaleDisplay[i]);\n               }\n            }\n         }\n      }\n\n      // draw screen cirle\n      drawList->AddCircleFilled(gContext.mScreenSquareCenter, gContext.mStyle.CenterCircleSize, colors[0], 32);\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsScaleType(type))\n      {\n         //ImVec2 sourcePosOnScreen = worldToPos(gContext.mMatrixOrigin, gContext.mViewProjection);\n         ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n         /*vec_t dif(destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y);\n         dif.Normalize();\n         dif *= 5.f;\n         drawList->AddCircle(sourcePosOnScreen, 6.f, translationLineColor);\n         drawList->AddCircle(destinationPosOnScreen, 6.f, translationLineColor);\n         drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);\n         */\n         char tmps[512];\n         //vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;\n         int componentInfoIndex = (type - MT_SCALE_X) * 3;\n         ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);\n      }\n   }\n\n\n   static void DrawScaleUniveralGizmo(OPERATION op, int type)\n   {\n      ImDrawList* drawList = gContext.mDrawList;\n\n      if (!Intersects(op, SCALEU))\n      {\n         return;\n      }\n\n      // colors\n      ImU32 colors[7];\n      ComputeColors(colors, type, SCALEU);\n\n      // draw\n      vec_t scaleDisplay = { 1.f, 1.f, 1.f, 1.f };\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID))\n      {\n         scaleDisplay = gContext.mScale;\n      }\n\n      for (int i = 0; i < 3; i++)\n      {\n         if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))\n         {\n            continue;\n         }\n         const bool usingAxis = (gContext.mbUsing && type == MT_SCALE_X + i);\n         if (!gContext.mbUsing || usingAxis)\n         {\n            vec_t dirPlaneX, dirPlaneY, dirAxis;\n            bool belowAxisLimit, belowPlaneLimit;\n            ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);\n\n            // draw axis\n            if (belowAxisLimit)\n            {\n               bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));\n               float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;\n               //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);\n               //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);\n               ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVPLocal);\n\n#if 0\n               if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID))\n               {\n                  drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, IM_COL32(0x40, 0x40, 0x40, 0xFF), 3.f);\n                  drawList->AddCircleFilled(worldDirSSpaceNoScale, 6.f, IM_COL32(0x40, 0x40, 0x40, 0xFF));\n               }\n               /*\n               if (!hasTranslateOnAxis || gContext.mbUsing)\n               {\n                  drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], 3.f);\n               }\n               */\n#endif\n               drawList->AddCircleFilled(worldDirSSpace, 12.f, colors[i + 1]);\n            }\n         }\n      }\n\n      // draw screen cirle\n      drawList->AddCircle(gContext.mScreenSquareCenter, 20.f, colors[0], 32, gContext.mStyle.CenterCircleSize);\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsScaleType(type))\n      {\n         //ImVec2 sourcePosOnScreen = worldToPos(gContext.mMatrixOrigin, gContext.mViewProjection);\n         ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n         /*vec_t dif(destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y);\n         dif.Normalize();\n         dif *= 5.f;\n         drawList->AddCircle(sourcePosOnScreen, 6.f, translationLineColor);\n         drawList->AddCircle(destinationPosOnScreen, 6.f, translationLineColor);\n         drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);\n         */\n         char tmps[512];\n         //vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;\n         int componentInfoIndex = (type - MT_SCALE_X) * 3;\n         ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);\n      }\n   }\n\n   static void DrawTranslationGizmo(OPERATION op, int type)\n   {\n      ImDrawList* drawList = gContext.mDrawList;\n      if (!drawList)\n      {\n         return;\n      }\n\n      if(!Intersects(op, TRANSLATE))\n      {\n         return;\n      }\n\n      // colors\n      ImU32 colors[7];\n      ComputeColors(colors, type, TRANSLATE);\n\n      const ImVec2 origin = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n\n      // draw\n      bool belowAxisLimit = false;\n      bool belowPlaneLimit = false;\n      for (int i = 0; i < 3; ++i)\n      {\n         vec_t dirPlaneX, dirPlaneY, dirAxis;\n         ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit);\n\n         if (!gContext.mbUsing || (gContext.mbUsing && type == MT_MOVE_X + i))\n         {\n            // draw axis\n            if (belowAxisLimit && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i)))\n            {\n               ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);\n               ImVec2 worldDirSSpace = worldToPos(dirAxis * gContext.mScreenFactor, gContext.mMVP);\n\n               drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);\n\n               // Arrow head begin\n               ImVec2 dir(origin - worldDirSSpace);\n\n               float d = sqrtf(ImLengthSqr(dir));\n               dir /= d; // Normalize\n               dir *= gContext.mStyle.TranslationLineArrowSize;\n\n               ImVec2 ortogonalDir(dir.y, -dir.x); // Perpendicular vector\n               ImVec2 a(worldDirSSpace + dir);\n               drawList->AddTriangleFilled(worldDirSSpace - dir, a + ortogonalDir, a - ortogonalDir, colors[i + 1]);\n               // Arrow head end\n\n               if (gContext.mAxisFactor[i] < 0.f)\n               {\n                  DrawHatchedAxis(dirAxis);\n               }\n            }\n         }\n         // draw plane\n         if (!gContext.mbUsing || (gContext.mbUsing && type == MT_MOVE_YZ + i))\n         {\n            if (belowPlaneLimit && Contains(op, TRANSLATE_PLANS[i]))\n            {\n               ImVec2 screenQuadPts[4];\n               for (int j = 0; j < 4; ++j)\n               {\n                  vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;\n                  screenQuadPts[j] = worldToPos(cornerWorldPos, gContext.mMVP);\n               }\n               drawList->AddPolyline(screenQuadPts, 4, GetColorU32(DIRECTION_X + i), true, 1.0f);\n               drawList->AddConvexPolyFilled(screenQuadPts, 4, colors[i + 4]);\n            }\n         }\n      }\n\n      drawList->AddCircleFilled(gContext.mScreenSquareCenter, gContext.mStyle.CenterCircleSize, colors[0], 32);\n\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsTranslateType(type))\n      {\n         ImU32 translationLineColor = GetColorU32(TRANSLATION_LINE);\n\n         ImVec2 sourcePosOnScreen = worldToPos(gContext.mMatrixOrigin, gContext.mViewProjection);\n         ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n         vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };\n         dif.Normalize();\n         dif *= 5.f;\n         drawList->AddCircle(sourcePosOnScreen, 6.f, translationLineColor);\n         drawList->AddCircle(destinationPosOnScreen, 6.f, translationLineColor);\n         drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);\n\n         char tmps[512];\n         vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;\n         int componentInfoIndex = (type - MT_MOVE_X) * 3;\n         ImFormatString(tmps, sizeof(tmps), translationInfoMask[type - MT_MOVE_X], deltaInfo[translationInfoIndex[componentInfoIndex]], deltaInfo[translationInfoIndex[componentInfoIndex + 1]], deltaInfo[translationInfoIndex[componentInfoIndex + 2]]);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);\n         drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);\n      }\n   }\n\n   static bool CanActivate()\n   {\n      if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())\n      {\n         return true;\n      }\n      return false;\n   }\n\n   static void HandleAndDrawLocalBounds(const float* bounds, matrix_t* matrix, const float* snapValues, OPERATION operation)\n   {\n      ImGuiIO& io = ImGui::GetIO();\n      ImDrawList* drawList = gContext.mDrawList;\n\n      // compute best projection axis\n      vec_t axesWorldDirections[3];\n      vec_t bestAxisWorldDirection = { 0.0f, 0.0f, 0.0f, 0.0f };\n      int axes[3];\n      unsigned int numAxes = 1;\n      axes[0] = gContext.mBoundsBestAxis;\n      int bestAxis = axes[0];\n      if (!gContext.mbUsingBounds)\n      {\n         numAxes = 0;\n         float bestDot = 0.f;\n         for (int i = 0; i < 3; i++)\n         {\n            vec_t dirPlaneNormalWorld;\n            dirPlaneNormalWorld.TransformVector(directionUnary[i], gContext.mModelSource);\n            dirPlaneNormalWorld.Normalize();\n\n            float dt = fabsf(Dot(Normalized(gContext.mCameraEye - gContext.mModelSource.v.position), dirPlaneNormalWorld));\n            if (dt >= bestDot)\n            {\n               bestDot = dt;\n               bestAxis = i;\n               bestAxisWorldDirection = dirPlaneNormalWorld;\n            }\n\n            if (dt >= 0.1f)\n            {\n               axes[numAxes] = i;\n               axesWorldDirections[numAxes] = dirPlaneNormalWorld;\n               ++numAxes;\n            }\n         }\n      }\n\n      if (numAxes == 0)\n      {\n         axes[0] = bestAxis;\n         axesWorldDirections[0] = bestAxisWorldDirection;\n         numAxes = 1;\n      }\n\n      else if (bestAxis != axes[0])\n      {\n         unsigned int bestIndex = 0;\n         for (unsigned int i = 0; i < numAxes; i++)\n         {\n            if (axes[i] == bestAxis)\n            {\n               bestIndex = i;\n               break;\n            }\n         }\n         int tempAxis = axes[0];\n         axes[0] = axes[bestIndex];\n         axes[bestIndex] = tempAxis;\n         vec_t tempDirection = axesWorldDirections[0];\n         axesWorldDirections[0] = axesWorldDirections[bestIndex];\n         axesWorldDirections[bestIndex] = tempDirection;\n      }\n\n      for (unsigned int axisIndex = 0; axisIndex < numAxes; ++axisIndex)\n      {\n         bestAxis = axes[axisIndex];\n         bestAxisWorldDirection = axesWorldDirections[axisIndex];\n\n         // corners\n         vec_t aabb[4];\n\n         int secondAxis = (bestAxis + 1) % 3;\n         int thirdAxis = (bestAxis + 2) % 3;\n\n         for (int i = 0; i < 4; i++)\n         {\n            aabb[i][3] = aabb[i][bestAxis] = 0.f;\n            aabb[i][secondAxis] = bounds[secondAxis + 3 * (i >> 1)];\n            aabb[i][thirdAxis] = bounds[thirdAxis + 3 * ((i >> 1) ^ (i & 1))];\n         }\n\n         // draw bounds\n         unsigned int anchorAlpha = gContext.mbEnable ? IM_COL32_BLACK : IM_COL32(0, 0, 0, 0x80);\n\n         matrix_t boundsMVP = gContext.mModelSource * gContext.mViewProjection;\n         for (int i = 0; i < 4; i++)\n         {\n            ImVec2 worldBound1 = worldToPos(aabb[i], boundsMVP);\n            ImVec2 worldBound2 = worldToPos(aabb[(i + 1) % 4], boundsMVP);\n            if (!IsInContextRect(worldBound1) || !IsInContextRect(worldBound2))\n            {\n               continue;\n            }\n            float boundDistance = sqrtf(ImLengthSqr(worldBound1 - worldBound2));\n            int stepCount = (int)(boundDistance / 10.f);\n            stepCount = min(stepCount, 1000);\n            for (int j = 0; j < stepCount; j++)\n            {\n               float stepLength = 1.f / (float)stepCount;\n               float t1 = (float)j * stepLength;\n               float t2 = (float)j * stepLength + stepLength * 0.5f;\n               ImVec2 worldBoundSS1 = ImLerp(worldBound1, worldBound2, ImVec2(t1, t1));\n               ImVec2 worldBoundSS2 = ImLerp(worldBound1, worldBound2, ImVec2(t2, t2));\n               //drawList->AddLine(worldBoundSS1, worldBoundSS2, IM_COL32(0, 0, 0, 0) + anchorAlpha, 3.f);\n               drawList->AddLine(worldBoundSS1, worldBoundSS2, IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha, 2.f);\n            }\n            vec_t midPoint = (aabb[i] + aabb[(i + 1) % 4]) * 0.5f;\n            ImVec2 midBound = worldToPos(midPoint, boundsMVP);\n            static const float AnchorBigRadius = 8.f;\n            static const float AnchorSmallRadius = 6.f;\n            bool overBigAnchor = ImLengthSqr(worldBound1 - io.MousePos) <= (AnchorBigRadius * AnchorBigRadius);\n            bool overSmallAnchor = ImLengthSqr(midBound - io.MousePos) <= (AnchorBigRadius * AnchorBigRadius);\n\n            int type = MT_NONE;\n            vec_t gizmoHitProportion;\n\n            if(Intersects(operation, TRANSLATE))\n            {\n               type = GetMoveType(operation, &gizmoHitProportion);\n            }\n            if(Intersects(operation, ROTATE) && type == MT_NONE)\n            {\n               type = GetRotateType(operation);\n            }\n            if(Intersects(operation, SCALE) && type == MT_NONE)\n            {\n               type = GetScaleType(operation);\n            }\n\n            if (type != MT_NONE)\n            {\n               overBigAnchor = false;\n               overSmallAnchor = false;\n            }\n\n            ImU32 selectionColor = GetColorU32(SELECTION);\n\n            unsigned int bigAnchorColor = overBigAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);\n            unsigned int smallAnchorColor = overSmallAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);\n\n            drawList->AddCircleFilled(worldBound1, AnchorBigRadius, IM_COL32_BLACK);\n            drawList->AddCircleFilled(worldBound1, AnchorBigRadius - 1.2f, bigAnchorColor);\n\n            drawList->AddCircleFilled(midBound, AnchorSmallRadius, IM_COL32_BLACK);\n            drawList->AddCircleFilled(midBound, AnchorSmallRadius - 1.2f, smallAnchorColor);\n            int oppositeIndex = (i + 2) % 4;\n            // big anchor on corners\n            if (!gContext.mbUsingBounds && gContext.mbEnable && overBigAnchor && CanActivate())\n            {\n               gContext.mBoundsPivot.TransformPoint(aabb[(i + 2) % 4], gContext.mModelSource);\n               gContext.mBoundsAnchor.TransformPoint(aabb[i], gContext.mModelSource);\n               gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);\n               gContext.mBoundsBestAxis = bestAxis;\n               gContext.mBoundsAxis[0] = secondAxis;\n               gContext.mBoundsAxis[1] = thirdAxis;\n\n               gContext.mBoundsLocalPivot.Set(0.f);\n               gContext.mBoundsLocalPivot[secondAxis] = aabb[oppositeIndex][secondAxis];\n               gContext.mBoundsLocalPivot[thirdAxis] = aabb[oppositeIndex][thirdAxis];\n\n               gContext.mbUsingBounds = true;\n               gContext.mEditingID = gContext.GetCurrentID();\n               gContext.mBoundsMatrix = gContext.mModelSource;\n            }\n            // small anchor on middle of segment\n            if (!gContext.mbUsingBounds && gContext.mbEnable && overSmallAnchor && CanActivate())\n            {\n               vec_t midPointOpposite = (aabb[(i + 2) % 4] + aabb[(i + 3) % 4]) * 0.5f;\n               gContext.mBoundsPivot.TransformPoint(midPointOpposite, gContext.mModelSource);\n               gContext.mBoundsAnchor.TransformPoint(midPoint, gContext.mModelSource);\n               gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);\n               gContext.mBoundsBestAxis = bestAxis;\n               int indices[] = { secondAxis , thirdAxis };\n               gContext.mBoundsAxis[0] = indices[i % 2];\n               gContext.mBoundsAxis[1] = -1;\n\n               gContext.mBoundsLocalPivot.Set(0.f);\n               gContext.mBoundsLocalPivot[gContext.mBoundsAxis[0]] = aabb[oppositeIndex][indices[i % 2]];// bounds[gContext.mBoundsAxis[0]] * (((i + 1) & 2) ? 1.f : -1.f);\n\n               gContext.mbUsingBounds = true;\n               gContext.mEditingID = gContext.GetCurrentID();\n               gContext.mBoundsMatrix = gContext.mModelSource;\n            }\n         }\n\n         if (gContext.mbUsingBounds && (gContext.GetCurrentID() == gContext.mEditingID))\n         {\n            matrix_t scale;\n            scale.SetToIdentity();\n\n            // compute projected mouse position on plan\n            const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mBoundsPlan);\n            vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;\n\n            // compute a reference and delta vectors base on mouse move\n            vec_t deltaVector = (newPos - gContext.mBoundsPivot).Abs();\n            vec_t referenceVector = (gContext.mBoundsAnchor - gContext.mBoundsPivot).Abs();\n\n            // for 1 or 2 axes, compute a ratio that's used for scale and snap it based on resulting length\n            for (int i = 0; i < 2; i++)\n            {\n               int axisIndex1 = gContext.mBoundsAxis[i];\n               if (axisIndex1 == -1)\n               {\n                  continue;\n               }\n\n               float ratioAxis = 1.f;\n               vec_t axisDir = gContext.mBoundsMatrix.component[axisIndex1].Abs();\n\n               float dtAxis = axisDir.Dot(referenceVector);\n               float boundSize = bounds[axisIndex1 + 3] - bounds[axisIndex1];\n               if (dtAxis > FLT_EPSILON)\n               {\n                  ratioAxis = axisDir.Dot(deltaVector) / dtAxis;\n               }\n\n               if (snapValues)\n               {\n                  float length = boundSize * ratioAxis;\n                  ComputeSnap(&length, snapValues[axisIndex1]);\n                  if (boundSize > FLT_EPSILON)\n                  {\n                     ratioAxis = length / boundSize;\n                  }\n               }\n               scale.component[axisIndex1] *= ratioAxis;\n            }\n\n            // transform matrix\n            matrix_t preScale, postScale;\n            preScale.Translation(-gContext.mBoundsLocalPivot);\n            postScale.Translation(gContext.mBoundsLocalPivot);\n            matrix_t res = preScale * scale * postScale * gContext.mBoundsMatrix;\n            *matrix = res;\n\n            // info text\n            char tmps[512];\n            ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);\n            ImFormatString(tmps, sizeof(tmps), \"X: %.2f Y: %.2f Z: %.2f\"\n               , (bounds[3] - bounds[0]) * gContext.mBoundsMatrix.component[0].Length() * scale.component[0].Length()\n               , (bounds[4] - bounds[1]) * gContext.mBoundsMatrix.component[1].Length() * scale.component[1].Length()\n               , (bounds[5] - bounds[2]) * gContext.mBoundsMatrix.component[2].Length() * scale.component[2].Length()\n            );\n            drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);\n            drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);\n         }\n\n         if (!io.MouseDown[0]) {\n            gContext.mbUsingBounds = false;\n            gContext.mEditingID = -1;\n         }\n         if (gContext.mbUsingBounds)\n         {\n            break;\n         }\n      }\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   //\n\n   static int GetScaleType(OPERATION op)\n   {\n      if (gContext.mbUsing)\n      {\n         return MT_NONE;\n      }\n      ImGuiIO& io = ImGui::GetIO();\n      int type = MT_NONE;\n\n      // screen\n      if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&\n         io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&\n         Contains(op, SCALE))\n      {\n         type = MT_SCALE_XYZ;\n      }\n\n      // compute\n      for (int i = 0; i < 3 && type == MT_NONE; i++)\n      {\n         if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))\n         {\n            continue;\n         }\n         bool isAxisMasked = (1 << i) & gContext.mAxisMask;\n\n         vec_t dirPlaneX, dirPlaneY, dirAxis;\n         bool belowAxisLimit, belowPlaneLimit;\n         ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);\n         dirAxis.TransformVector(gContext.mModelLocal);\n         dirPlaneX.TransformVector(gContext.mModelLocal);\n         dirPlaneY.TransformVector(gContext.mModelLocal);\n\n         const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModelLocal.v.position, dirAxis));\n         vec_t posOnPlan = gContext.mRayOrigin + gContext.mRayVector * len;\n\n         const float startOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.0f : 0.1f;\n         const float endOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.4f : 1.0f;\n         const ImVec2 posOnPlanScreen = worldToPos(posOnPlan, gContext.mViewProjection);\n         const ImVec2 axisStartOnScreen = worldToPos(gContext.mModelLocal.v.position + dirAxis * gContext.mScreenFactor * startOffset, gContext.mViewProjection);\n         const ImVec2 axisEndOnScreen = worldToPos(gContext.mModelLocal.v.position + dirAxis * gContext.mScreenFactor * endOffset, gContext.mViewProjection);\n\n         vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));\n\n         if ((closestPointOnAxis - makeVect(posOnPlanScreen)).Length() < 12.f) // pixel size\n         {\n            if (!isAxisMasked)\n               type = MT_SCALE_X + i;\n         }\n      }\n\n      // universal\n\n      vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };\n      float dist = deltaScreen.Length();\n      if (Contains(op, SCALEU) && dist >= 17.0f && dist < 23.0f)\n      {\n         type = MT_SCALE_XYZ;\n      }\n\n      for (int i = 0; i < 3 && type == MT_NONE; i++)\n      {\n         if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))\n         {\n            continue;\n         }\n\n         vec_t dirPlaneX, dirPlaneY, dirAxis;\n         bool belowAxisLimit, belowPlaneLimit;\n         ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);\n\n         // draw axis\n         if (belowAxisLimit)\n         {\n            bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));\n            float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;\n            //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);\n            //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);\n            ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale) * gContext.mScreenFactor, gContext.mMVPLocal);\n\n            float distance = sqrtf(ImLengthSqr(worldDirSSpace - io.MousePos));\n            if (distance < 12.f)\n            {\n               type = MT_SCALE_X + i;\n            }\n         }\n      }\n      return type;\n   }\n\n   static int GetRotateType(OPERATION op)\n   {\n      if (gContext.mbUsing)\n      {\n         return MT_NONE;\n      }\n\n      bool isNoAxesMasked = !gContext.mAxisMask;\n      bool isMultipleAxesMasked = gContext.mAxisMask & (gContext.mAxisMask - 1);\n\n      ImGuiIO& io = ImGui::GetIO();\n      int type = MT_NONE;\n\n      vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };\n      float dist = deltaScreen.Length();\n      if (Intersects(op, ROTATE_SCREEN) && dist >= (gContext.mRadiusSquareCenter - 4.0f) && dist < (gContext.mRadiusSquareCenter + 4.0f))\n      {\n         if (!isNoAxesMasked)\n            return MT_NONE;\n         type = MT_ROTATE_SCREEN;\n      }\n\n      const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };\n\n      vec_t modelViewPos;\n      modelViewPos.TransformPoint(gContext.mModel.v.position, gContext.mViewMat);\n\n      for (int i = 0; i < 3 && type == MT_NONE; i++)\n      {\n         if(!Intersects(op, static_cast<OPERATION>(ROTATE_X << i)))\n         {\n            continue;\n         }\n         bool isAxisMasked = (1 << i) & gContext.mAxisMask;\n         // pickup plan\n         vec_t pickupPlan = BuildPlan(gContext.mModel.v.position, planNormals[i]);\n\n         const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, pickupPlan);\n         const vec_t intersectWorldPos = gContext.mRayOrigin + gContext.mRayVector * len;\n         vec_t intersectViewPos;\n         intersectViewPos.TransformPoint(intersectWorldPos, gContext.mViewMat);\n\n         if (ImAbs(modelViewPos.z) - ImAbs(intersectViewPos.z) < -FLT_EPSILON)\n         {\n            continue;\n         }\n\n         const vec_t localPos = intersectWorldPos - gContext.mModel.v.position;\n         vec_t idealPosOnCircle = Normalized(localPos);\n         idealPosOnCircle.TransformVector(gContext.mModelInverse);\n         const ImVec2 idealPosOnCircleScreen = worldToPos(idealPosOnCircle * rotationDisplayFactor * gContext.mScreenFactor, gContext.mMVP);\n\n         //gContext.mDrawList->AddCircle(idealPosOnCircleScreen, 5.f, IM_COL32_WHITE);\n         const ImVec2 distanceOnScreen = idealPosOnCircleScreen - io.MousePos;\n\n         const float distance = makeVect(distanceOnScreen).Length();\n         if (distance < 8.f) // pixel size\n         {\n            if ((!isAxisMasked || isMultipleAxesMasked) && !isNoAxesMasked)\n               break;\n            type = MT_ROTATE_X + i;\n         }\n      }\n\n      return type;\n   }\n\n   static int GetMoveType(OPERATION op, vec_t* gizmoHitProportion)\n   {\n      if(!Intersects(op, TRANSLATE) || gContext.mbUsing || !gContext.mbMouseOver)\n      {\n        return MT_NONE;\n      }\n\n      bool isNoAxesMasked = !gContext.mAxisMask;\n      bool isMultipleAxesMasked = gContext.mAxisMask & (gContext.mAxisMask - 1);\n\n      ImGuiIO& io = ImGui::GetIO();\n      int type = MT_NONE;\n\n      // screen\n      if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&\n         io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&\n         Contains(op, TRANSLATE))\n      {\n         type = MT_MOVE_SCREEN;\n      }\n\n      const vec_t screenCoord = makeVect(io.MousePos - ImVec2(gContext.mX, gContext.mY));\n\n      // compute\n      for (int i = 0; i < 3 && type == MT_NONE; i++)\n      {\n         bool isAxisMasked = (1 << i) & gContext.mAxisMask;\n         vec_t dirPlaneX, dirPlaneY, dirAxis;\n         bool belowAxisLimit, belowPlaneLimit;\n         ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit);\n         dirAxis.TransformVector(gContext.mModel);\n         dirPlaneX.TransformVector(gContext.mModel);\n         dirPlaneY.TransformVector(gContext.mModel);\n\n         const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModel.v.position, dirAxis));\n         vec_t posOnPlan = gContext.mRayOrigin + gContext.mRayVector * len;\n\n         const ImVec2 axisStartOnScreen = worldToPos(gContext.mModel.v.position + dirAxis * gContext.mScreenFactor * 0.1f, gContext.mViewProjection) - ImVec2(gContext.mX, gContext.mY);\n         const ImVec2 axisEndOnScreen = worldToPos(gContext.mModel.v.position + dirAxis * gContext.mScreenFactor, gContext.mViewProjection) - ImVec2(gContext.mX, gContext.mY);\n\n         vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));\n         if ((closestPointOnAxis - screenCoord).Length() < 12.f && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i))) // pixel size\n         {\n            if (isAxisMasked)\n               break;\n            type = MT_MOVE_X + i;\n         }\n\n         const float dx = dirPlaneX.Dot3((posOnPlan - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor));\n         const float dy = dirPlaneY.Dot3((posOnPlan - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor));\n         if (belowPlaneLimit && dx >= quadUV[0] && dx <= quadUV[4] && dy >= quadUV[1] && dy <= quadUV[3] && Contains(op, TRANSLATE_PLANS[i]))\n         {\n            if ((!isAxisMasked || isMultipleAxesMasked) && !isNoAxesMasked)\n               break;\n            type = MT_MOVE_YZ + i;\n         }\n\n         if (gizmoHitProportion)\n         {\n            *gizmoHitProportion = makeVect(dx, dy, 0.f);\n         }\n      }\n      return type;\n   }\n\n   static bool HandleTranslation(float* matrix, float* deltaMatrix, OPERATION op, int& type, const float* snap)\n   {\n      if(!Intersects(op, TRANSLATE) || type != MT_NONE)\n      {\n        return false;\n      }\n      const ImGuiIO& io = ImGui::GetIO();\n      const bool applyRotationLocaly = gContext.mMode == LOCAL || type == MT_MOVE_SCREEN;\n      bool modified = false;\n\n      // move\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsTranslateType(gContext.mCurrentOperation))\n      {\n#if IMGUI_VERSION_NUM >= 18723\n         ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n         ImGui::CaptureMouseFromApp();\n#endif\n         const float signedLength = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n         const float len = fabsf(signedLength); // near plan\n         const vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;\n\n         // compute delta\n         const vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;\n         vec_t delta = newOrigin - gContext.mModel.v.position;\n\n         // 1 axis constraint\n         if (gContext.mCurrentOperation >= MT_MOVE_X && gContext.mCurrentOperation <= MT_MOVE_Z)\n         {\n            const int axisIndex = gContext.mCurrentOperation - MT_MOVE_X;\n            const vec_t& axisValue = *(vec_t*)&gContext.mModel.m[axisIndex];\n            const float lengthOnAxis = Dot(axisValue, delta);\n            delta = axisValue * lengthOnAxis;\n         }\n\n         // snap\n         if (snap)\n         {\n            vec_t cumulativeDelta = gContext.mModel.v.position + delta - gContext.mMatrixOrigin;\n            if (applyRotationLocaly)\n            {\n               matrix_t modelSourceNormalized = gContext.mModelSource;\n               modelSourceNormalized.OrthoNormalize();\n               matrix_t modelSourceNormalizedInverse;\n               modelSourceNormalizedInverse.Inverse(modelSourceNormalized);\n               cumulativeDelta.TransformVector(modelSourceNormalizedInverse);\n               ComputeSnap(cumulativeDelta, snap);\n               cumulativeDelta.TransformVector(modelSourceNormalized);\n            }\n            else\n            {\n               ComputeSnap(cumulativeDelta, snap);\n            }\n            delta = gContext.mMatrixOrigin + cumulativeDelta - gContext.mModel.v.position;\n\n         }\n\n         if (delta != gContext.mTranslationLastDelta)\n         {\n            modified = true;\n         }\n         gContext.mTranslationLastDelta = delta;\n\n         // compute matrix & delta\n         matrix_t deltaMatrixTranslation;\n         deltaMatrixTranslation.Translation(delta);\n         if (deltaMatrix)\n         {\n            memcpy(deltaMatrix, deltaMatrixTranslation.m16, sizeof(float) * 16);\n         }\n\n         const matrix_t res = gContext.mModelSource * deltaMatrixTranslation;\n         *(matrix_t*)matrix = res;\n\n         if (!io.MouseDown[0])\n         {\n            gContext.mbUsing = false;\n         }\n\n         type = gContext.mCurrentOperation;\n      }\n      else\n      {\n         // find new possible way to move\n         vec_t gizmoHitProportion;\n         type = gContext.mbOverGizmoHotspot ? MT_NONE : GetMoveType(op, &gizmoHitProportion);\n         gContext.mbOverGizmoHotspot |= type != MT_NONE;\n         if (type != MT_NONE)\n         {\n#if IMGUI_VERSION_NUM >= 18723\n            ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n            ImGui::CaptureMouseFromApp();\n#endif\n         }\n         if (CanActivate() && type != MT_NONE)\n         {\n            gContext.mbUsing = true;\n            gContext.mEditingID = gContext.GetCurrentID();\n            gContext.mCurrentOperation = type;\n            vec_t movePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,\n               gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,\n               -gContext.mCameraDir };\n\n            vec_t cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);\n            for (unsigned int i = 0; i < 3; i++)\n            {\n               vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);\n               movePlanNormal[i].Cross(orthoVector);\n               movePlanNormal[i].Normalize();\n            }\n            // pickup plan\n            gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);\n            const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n            gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;\n            gContext.mMatrixOrigin = gContext.mModel.v.position;\n\n            gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);\n         }\n      }\n      return modified;\n   }\n\n   static bool HandleScale(float* matrix, float* deltaMatrix, OPERATION op, int& type, const float* snap)\n   {\n      if((!Intersects(op, SCALE) && !Intersects(op, SCALEU)) || type != MT_NONE || !gContext.mbMouseOver)\n      {\n         return false;\n      }\n      ImGuiIO& io = ImGui::GetIO();\n      bool modified = false;\n\n      if (!gContext.mbUsing)\n      {\n         // find new possible way to scale\n         type = gContext.mbOverGizmoHotspot ? MT_NONE : GetScaleType(op);\n         gContext.mbOverGizmoHotspot |= type != MT_NONE;\n\n         if (type != MT_NONE)\n         {\n#if IMGUI_VERSION_NUM >= 18723\n            ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n            ImGui::CaptureMouseFromApp();\n#endif\n         }\n         if (CanActivate() && type != MT_NONE)\n         {\n            gContext.mbUsing = true;\n            gContext.mEditingID = gContext.GetCurrentID();\n            gContext.mCurrentOperation = type;\n            const vec_t movePlanNormal[] = { gContext.mModelLocal.v.up, gContext.mModelLocal.v.dir, gContext.mModelLocal.v.right, gContext.mModelLocal.v.dir, gContext.mModelLocal.v.up, gContext.mModelLocal.v.right, -gContext.mCameraDir };\n            // pickup plan\n\n            gContext.mTranslationPlan = BuildPlan(gContext.mModelLocal.v.position, movePlanNormal[type - MT_SCALE_X]);\n            const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n            gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;\n            gContext.mMatrixOrigin = gContext.mModelLocal.v.position;\n            gContext.mScale.Set(1.f, 1.f, 1.f);\n            gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModelLocal.v.position) * (1.f / gContext.mScreenFactor);\n            gContext.mScaleValueOrigin = makeVect(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());\n            gContext.mSaveMousePosx = io.MousePos.x;\n         }\n      }\n      // scale\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsScaleType(gContext.mCurrentOperation))\n      {\n#if IMGUI_VERSION_NUM >= 18723\n         ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n         ImGui::CaptureMouseFromApp();\n#endif\n         const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n         vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;\n         vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;\n         vec_t delta = newOrigin - gContext.mModelLocal.v.position;\n\n         // 1 axis constraint\n         if (gContext.mCurrentOperation >= MT_SCALE_X && gContext.mCurrentOperation <= MT_SCALE_Z)\n         {\n            int axisIndex = gContext.mCurrentOperation - MT_SCALE_X;\n            const vec_t& axisValue = *(vec_t*)&gContext.mModelLocal.m[axisIndex];\n            float lengthOnAxis = Dot(axisValue, delta);\n            delta = axisValue * lengthOnAxis;\n\n            vec_t baseVector = gContext.mTranslationPlanOrigin - gContext.mModelLocal.v.position;\n            float ratio = Dot(axisValue, baseVector + delta) / Dot(axisValue, baseVector);\n\n            gContext.mScale[axisIndex] = max(ratio, 0.001f);\n         }\n         else\n         {\n            float scaleDelta = (io.MousePos.x - gContext.mSaveMousePosx) * 0.01f;\n            gContext.mScale.Set(max(1.f + scaleDelta, 0.001f));\n         }\n\n         // snap\n         if (snap)\n         {\n            float scaleSnap[] = { snap[0], snap[0], snap[0] };\n            ComputeSnap(gContext.mScale, scaleSnap);\n         }\n\n         // no 0 allowed\n         for (int i = 0; i < 3; i++)\n            gContext.mScale[i] = max(gContext.mScale[i], 0.001f);\n\n         if (gContext.mScaleLast != gContext.mScale)\n         {\n            modified = true;\n         }\n         gContext.mScaleLast = gContext.mScale;\n\n         // compute matrix & delta\n         matrix_t deltaMatrixScale;\n         deltaMatrixScale.Scale(gContext.mScale * gContext.mScaleValueOrigin);\n\n         matrix_t res = deltaMatrixScale * gContext.mModelLocal;\n         *(matrix_t*)matrix = res;\n\n         if (deltaMatrix)\n         {\n            vec_t deltaScale = gContext.mScale * gContext.mScaleValueOrigin;\n\n            vec_t originalScaleDivider;\n            originalScaleDivider.x = 1 / gContext.mModelScaleOrigin.x;\n            originalScaleDivider.y = 1 / gContext.mModelScaleOrigin.y;\n            originalScaleDivider.z = 1 / gContext.mModelScaleOrigin.z;\n\n            deltaScale = deltaScale * originalScaleDivider;\n\n            deltaMatrixScale.Scale(deltaScale);\n            memcpy(deltaMatrix, deltaMatrixScale.m16, sizeof(float) * 16);\n         }\n\n         if (!io.MouseDown[0])\n         {\n            gContext.mbUsing = false;\n            gContext.mScale.Set(1.f, 1.f, 1.f);\n         }\n\n         type = gContext.mCurrentOperation;\n      }\n      return modified;\n   }\n\n   static bool HandleRotation(float* matrix, float* deltaMatrix, OPERATION op, int& type, const float* snap)\n   {\n      if(!Intersects(op, ROTATE) || type != MT_NONE || !gContext.mbMouseOver)\n      {\n        return false;\n      }\n      ImGuiIO& io = ImGui::GetIO();\n      bool applyRotationLocaly = gContext.mMode == LOCAL;\n      bool modified = false;\n\n      if (!gContext.mbUsing)\n      {\n         type = gContext.mbOverGizmoHotspot ? MT_NONE : GetRotateType(op);\n         gContext.mbOverGizmoHotspot |= type != MT_NONE;\n\n         if (type != MT_NONE)\n         {\n#if IMGUI_VERSION_NUM >= 18723\n            ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n            ImGui::CaptureMouseFromApp();\n#endif\n         }\n\n         if (type == MT_ROTATE_SCREEN)\n         {\n            applyRotationLocaly = true;\n         }\n\n         if (CanActivate() && type != MT_NONE)\n         {\n            gContext.mbUsing = true;\n            gContext.mEditingID = gContext.GetCurrentID();\n            gContext.mCurrentOperation = type;\n            const vec_t rotatePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir, -gContext.mCameraDir };\n            // pickup plan\n            if (applyRotationLocaly)\n            {\n               gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, rotatePlanNormal[type - MT_ROTATE_X]);\n            }\n            else\n            {\n               gContext.mTranslationPlan = BuildPlan(gContext.mModelSource.v.position, directionUnary[type - MT_ROTATE_X]);\n            }\n\n            const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);\n            vec_t localPos = gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position;\n            gContext.mRotationVectorSource = Normalized(localPos);\n            gContext.mRotationAngleOrigin = ComputeAngleOnPlan();\n         }\n      }\n\n      // rotation\n      if (gContext.mbUsing && (gContext.GetCurrentID() == gContext.mEditingID) && IsRotateType(gContext.mCurrentOperation))\n      {\n#if IMGUI_VERSION_NUM >= 18723\n         ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n         ImGui::CaptureMouseFromApp();\n#endif\n         gContext.mRotationAngle = ComputeAngleOnPlan();\n         if (snap)\n         {\n            float snapInRadian = snap[0] * DEG2RAD;\n            ComputeSnap(&gContext.mRotationAngle, snapInRadian);\n         }\n         vec_t rotationAxisLocalSpace;\n\n         rotationAxisLocalSpace.TransformVector(makeVect(gContext.mTranslationPlan.x, gContext.mTranslationPlan.y, gContext.mTranslationPlan.z, 0.f), gContext.mModelInverse);\n         rotationAxisLocalSpace.Normalize();\n\n         matrix_t deltaRotation;\n         deltaRotation.RotationAxis(rotationAxisLocalSpace, gContext.mRotationAngle - gContext.mRotationAngleOrigin);\n         if (gContext.mRotationAngle != gContext.mRotationAngleOrigin)\n         {\n            modified = true;\n         }\n         gContext.mRotationAngleOrigin = gContext.mRotationAngle;\n\n         matrix_t scaleOrigin;\n         scaleOrigin.Scale(gContext.mModelScaleOrigin);\n\n         if (applyRotationLocaly)\n         {\n            *(matrix_t*)matrix = scaleOrigin * deltaRotation * gContext.mModelLocal;\n         }\n         else\n         {\n            matrix_t res = gContext.mModelSource;\n            res.v.position.Set(0.f);\n\n            *(matrix_t*)matrix = res * deltaRotation;\n            ((matrix_t*)matrix)->v.position = gContext.mModelSource.v.position;\n         }\n\n         if (deltaMatrix)\n         {\n            *(matrix_t*)deltaMatrix = gContext.mModelInverse * deltaRotation * gContext.mModel;\n         }\n\n         if (!io.MouseDown[0])\n         {\n            gContext.mbUsing = false;\n            gContext.mEditingID = -1;\n         }\n         type = gContext.mCurrentOperation;\n      }\n      return modified;\n   }\n\n   void DecomposeMatrixToComponents(const float* matrix, float* translation, float* rotation, float* scale)\n   {\n      matrix_t mat = *(matrix_t*)matrix;\n\n      scale[0] = mat.v.right.Length();\n      scale[1] = mat.v.up.Length();\n      scale[2] = mat.v.dir.Length();\n\n      mat.OrthoNormalize();\n\n      rotation[0] = RAD2DEG * atan2f(mat.m[1][2], mat.m[2][2]);\n      rotation[1] = RAD2DEG * atan2f(-mat.m[0][2], sqrtf(mat.m[1][2] * mat.m[1][2] + mat.m[2][2] * mat.m[2][2]));\n      rotation[2] = RAD2DEG * atan2f(mat.m[0][1], mat.m[0][0]);\n\n      translation[0] = mat.v.position.x;\n      translation[1] = mat.v.position.y;\n      translation[2] = mat.v.position.z;\n   }\n\n   void RecomposeMatrixFromComponents(const float* translation, const float* rotation, const float* scale, float* matrix)\n   {\n      matrix_t& mat = *(matrix_t*)matrix;\n\n      matrix_t rot[3];\n      for (int i = 0; i < 3; i++)\n      {\n         rot[i].RotationAxis(directionUnary[i], rotation[i] * DEG2RAD);\n      }\n\n      mat = rot[0] * rot[1] * rot[2];\n\n      float validScale[3];\n      for (int i = 0; i < 3; i++)\n      {\n         if (fabsf(scale[i]) < FLT_EPSILON)\n         {\n            validScale[i] = 0.001f;\n         }\n         else\n         {\n            validScale[i] = scale[i];\n         }\n      }\n      mat.v.right *= validScale[0];\n      mat.v.up *= validScale[1];\n      mat.v.dir *= validScale[2];\n      mat.v.position.Set(translation[0], translation[1], translation[2], 1.f);\n   }\n\n   void SetAlternativeWindow(ImGuiWindow* window)\n   {\n      gContext.mAlternativeWindow = window;\n   }\n\n   void SetID(int id)\n   {\n      if (gContext.mIDStack.empty())\n      {\n         gContext.mIDStack.push_back(-1);\n      }\n      gContext.mIDStack.back() = id;\n   }\n\n   ImGuiID GetID(const char* str, const char* str_end)\n   {\n      ImGuiID seed = gContext.GetCurrentID();\n      ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);\n      return id;\n   }\n\n   ImGuiID GetID(const char* str)\n   {\n      return GetID(str, nullptr);\n   }\n\n   ImGuiID GetID(const void* ptr)\n   {\n      ImGuiID seed = gContext.GetCurrentID();\n      ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);\n      return id;\n   }\n\n   ImGuiID GetID(int n)\n   {\n      ImGuiID seed = gContext.GetCurrentID();\n      ImGuiID id = ImHashData(&n, sizeof(n), seed);\n      return id;\n   }\n\n   void PushID(const char* str_id)\n   {\n      ImGuiID id = GetID(str_id);\n      gContext.mIDStack.push_back(id);\n   }\n\n   void PushID(const char* str_id_begin, const char* str_id_end)\n   {\n      ImGuiID id = GetID(str_id_begin, str_id_end);\n      gContext.mIDStack.push_back(id);\n   }\n\n   void PushID(const void* ptr_id)\n   {\n      ImGuiID id = GetID(ptr_id);\n      gContext.mIDStack.push_back(id);\n   }\n\n   void PushID(int int_id)\n   {\n      ImGuiID id = GetID(int_id);\n      gContext.mIDStack.push_back(id);\n   }\n\n   void PopID()\n   {\n      IM_ASSERT(gContext.mIDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?\n      gContext.mIDStack.pop_back();\n   }\n\n   void AllowAxisFlip(bool value)\n   {\n     gContext.mAllowAxisFlip = value;\n   }\n\n   void SetAxisLimit(float value)\n   {\n     gContext.mAxisLimit=value;\n   }\n\n   void SetAxisMask(bool x, bool y, bool z)\n   {\n      gContext.mAxisMask = (x ? 1 : 0) + (y ? 2 : 0) + (z ? 4 : 0);\n   }\n\n   void SetPlaneLimit(float value)\n   {\n     gContext.mPlaneLimit = value;\n   }\n\n   bool IsOver(float* position, float pixelRadius)\n   {\n      const ImGuiIO& io = ImGui::GetIO();\n\n      float radius = sqrtf((ImLengthSqr(worldToPos({ position[0], position[1], position[2], 0.0f }, gContext.mViewProjection) - io.MousePos)));\n      return radius < pixelRadius;\n   }\n\n   bool Manipulate(const float* view, const float* projection, OPERATION operation, MODE mode, float* matrix, float* deltaMatrix, const float* snap, const float* localBounds, const float* boundsSnap)\n   {\n      gContext.mDrawList->PushClipRect (ImVec2 (gContext.mX, gContext.mY), ImVec2 (gContext.mX + gContext.mWidth, gContext.mY + gContext.mHeight), false);\n\n      // Scale is always local or matrix will be skewed when applying world scale or oriented matrix\n      ComputeContext(view, projection, matrix, (operation & SCALE) ? LOCAL : mode);\n\n      // set delta to identity\n      if (deltaMatrix)\n      {\n         ((matrix_t*)deltaMatrix)->SetToIdentity();\n      }\n\n      // behind camera\n      vec_t camSpacePosition;\n      camSpacePosition.TransformPoint(makeVect(0.f, 0.f, 0.f), gContext.mMVP);\n      if (!gContext.mIsOrthographic && camSpacePosition.z < 0.001f && !gContext.mbUsing)\n      {\n         return false;\n      }\n\n      // --\n      int type = MT_NONE;\n      bool manipulated = false;\n      if (gContext.mbEnable)\n      {\n         if (!gContext.mbUsingBounds)\n         {\n            manipulated = HandleTranslation(matrix, deltaMatrix, operation, type, snap) ||\n                          HandleScale(matrix, deltaMatrix, operation, type, snap) ||\n                          HandleRotation(matrix, deltaMatrix, operation, type, snap);\n         }\n      }\n\n      if (localBounds && !gContext.mbUsing)\n      {\n         HandleAndDrawLocalBounds(localBounds, (matrix_t*)matrix, boundsSnap, operation);\n      }\n\n      gContext.mOperation = operation;\n      if (!gContext.mbUsingBounds)\n      {\n         DrawRotationGizmo(operation, type);\n         DrawTranslationGizmo(operation, type);\n         DrawScaleGizmo(operation, type);\n         DrawScaleUniveralGizmo(operation, type);\n      }\n\n      gContext.mDrawList->PopClipRect ();\n      return manipulated;\n   }\n\n   void SetGizmoSizeClipSpace(float value)\n   {\n      gContext.mGizmoSizeClipSpace = value;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////\n   void ComputeFrustumPlanes(vec_t* frustum, const float* clip)\n   {\n      frustum[0].x = clip[3] - clip[0];\n      frustum[0].y = clip[7] - clip[4];\n      frustum[0].z = clip[11] - clip[8];\n      frustum[0].w = clip[15] - clip[12];\n\n      frustum[1].x = clip[3] + clip[0];\n      frustum[1].y = clip[7] + clip[4];\n      frustum[1].z = clip[11] + clip[8];\n      frustum[1].w = clip[15] + clip[12];\n\n      frustum[2].x = clip[3] + clip[1];\n      frustum[2].y = clip[7] + clip[5];\n      frustum[2].z = clip[11] + clip[9];\n      frustum[2].w = clip[15] + clip[13];\n\n      frustum[3].x = clip[3] - clip[1];\n      frustum[3].y = clip[7] - clip[5];\n      frustum[3].z = clip[11] - clip[9];\n      frustum[3].w = clip[15] - clip[13];\n\n      frustum[4].x = clip[3] - clip[2];\n      frustum[4].y = clip[7] - clip[6];\n      frustum[4].z = clip[11] - clip[10];\n      frustum[4].w = clip[15] - clip[14];\n\n      frustum[5].x = clip[3] + clip[2];\n      frustum[5].y = clip[7] + clip[6];\n      frustum[5].z = clip[11] + clip[10];\n      frustum[5].w = clip[15] + clip[14];\n\n      for (int i = 0; i < 6; i++)\n      {\n         frustum[i].Normalize();\n      }\n   }\n\n   void DrawCubes(const float* view, const float* projection, const float* matrices, int matrixCount)\n   {\n      matrix_t viewInverse;\n      viewInverse.Inverse(*(matrix_t*)view);\n\n      struct CubeFace\n      {\n         float z;\n         ImVec2 faceCoordsScreen[4];\n         ImU32 color;\n      };\n      CubeFace* faces = (CubeFace*)_malloca(sizeof(CubeFace) * matrixCount * 6);\n\n      if (!faces)\n      {\n         return;\n      }\n\n      vec_t frustum[6];\n      matrix_t viewProjection = *(matrix_t*)view * *(matrix_t*)projection;\n      ComputeFrustumPlanes(frustum, viewProjection.m16);\n\n      int cubeFaceCount = 0;\n      for (int cube = 0; cube < matrixCount; cube++)\n      {\n         const float* matrix = &matrices[cube * 16];\n\n         matrix_t res = *(matrix_t*)matrix * *(matrix_t*)view * *(matrix_t*)projection;\n\n         for (int iFace = 0; iFace < 6; iFace++)\n         {\n            const int normalIndex = (iFace % 3);\n            const int perpXIndex = (normalIndex + 1) % 3;\n            const int perpYIndex = (normalIndex + 2) % 3;\n            const float invert = (iFace > 2) ? -1.f : 1.f;\n\n            const vec_t faceCoords[4] = { directionUnary[normalIndex] + directionUnary[perpXIndex] + directionUnary[perpYIndex],\n               directionUnary[normalIndex] + directionUnary[perpXIndex] - directionUnary[perpYIndex],\n               directionUnary[normalIndex] - directionUnary[perpXIndex] - directionUnary[perpYIndex],\n               directionUnary[normalIndex] - directionUnary[perpXIndex] + directionUnary[perpYIndex],\n            };\n\n            // clipping\n            /*\n            bool skipFace = false;\n            for (unsigned int iCoord = 0; iCoord < 4; iCoord++)\n            {\n               vec_t camSpacePosition;\n               camSpacePosition.TransformPoint(faceCoords[iCoord] * 0.5f * invert, res);\n               if (camSpacePosition.z < 0.001f)\n               {\n                  skipFace = true;\n                  break;\n               }\n            }\n            if (skipFace)\n            {\n               continue;\n            }\n            */\n            vec_t centerPosition, centerPositionVP;\n            centerPosition.TransformPoint(directionUnary[normalIndex] * 0.5f * invert, *(matrix_t*)matrix);\n            centerPositionVP.TransformPoint(directionUnary[normalIndex] * 0.5f * invert, res);\n\n            bool inFrustum = true;\n            for (int iFrustum = 0; iFrustum < 6; iFrustum++)\n            {\n               float dist = DistanceToPlane(centerPosition, frustum[iFrustum]);\n               if (dist < 0.f)\n               {\n                  inFrustum = false;\n                  break;\n               }\n            }\n\n            if (!inFrustum)\n            {\n               continue;\n            }\n            CubeFace& cubeFace = faces[cubeFaceCount];\n\n            // 3D->2D\n            //ImVec2 faceCoordsScreen[4];\n            for (unsigned int iCoord = 0; iCoord < 4; iCoord++)\n            {\n               cubeFace.faceCoordsScreen[iCoord] = worldToPos(faceCoords[iCoord] * 0.5f * invert, res);\n            }\n\n            ImU32 directionColor = GetColorU32(DIRECTION_X + normalIndex);\n            cubeFace.color = directionColor | IM_COL32(0x80, 0x80, 0x80, 0);\n\n            cubeFace.z = centerPositionVP.z / centerPositionVP.w;\n            cubeFaceCount++;\n         }\n      }\n      qsort(faces, cubeFaceCount, sizeof(CubeFace), [](void const* _a, void const* _b) {\n         CubeFace* a = (CubeFace*)_a;\n         CubeFace* b = (CubeFace*)_b;\n         if (a->z < b->z)\n         {\n            return 1;\n         }\n         return -1;\n         });\n      // draw face with lighter color\n      for (int iFace = 0; iFace < cubeFaceCount; iFace++)\n      {\n         const CubeFace& cubeFace = faces[iFace];\n         gContext.mDrawList->AddConvexPolyFilled(cubeFace.faceCoordsScreen, 4, cubeFace.color);\n      }\n\n      _freea(faces);\n   }\n\n   void DrawGrid(const float* view, const float* projection, const float* matrix, const float gridSize)\n   {\n      matrix_t viewProjection = *(matrix_t*)view * *(matrix_t*)projection;\n      vec_t frustum[6];\n      ComputeFrustumPlanes(frustum, viewProjection.m16);\n      matrix_t res = *(matrix_t*)matrix * viewProjection;\n\n      for (float f = -gridSize; f <= gridSize; f += 1.f)\n      {\n         for (int dir = 0; dir < 2; dir++)\n         {\n            vec_t ptA = makeVect(dir ? -gridSize : f, 0.f, dir ? f : -gridSize);\n            vec_t ptB = makeVect(dir ? gridSize : f, 0.f, dir ? f : gridSize);\n            bool visible = true;\n            for (int i = 0; i < 6; i++)\n            {\n               float dA = DistanceToPlane(ptA, frustum[i]);\n               float dB = DistanceToPlane(ptB, frustum[i]);\n               if (dA < 0.f && dB < 0.f)\n               {\n                  visible = false;\n                  break;\n               }\n               if (dA > 0.f && dB > 0.f)\n               {\n                  continue;\n               }\n               if (dA < 0.f)\n               {\n                  float len = fabsf(dA - dB);\n                  float t = fabsf(dA) / len;\n                  ptA.Lerp(ptB, t);\n               }\n               if (dB < 0.f)\n               {\n                  float len = fabsf(dB - dA);\n                  float t = fabsf(dB) / len;\n                  ptB.Lerp(ptA, t);\n               }\n            }\n            if (visible)\n            {\n               ImU32 col = IM_COL32(0x80, 0x80, 0x80, 0xFF);\n               col = (fmodf(fabsf(f), 10.f) < FLT_EPSILON) ? IM_COL32(0x90, 0x90, 0x90, 0xFF) : col;\n               col = (fabsf(f) < FLT_EPSILON) ? IM_COL32(0x40, 0x40, 0x40, 0xFF): col;\n\n               float thickness = 1.f;\n               thickness = (fmodf(fabsf(f), 10.f) < FLT_EPSILON) ? 1.5f : thickness;\n               thickness = (fabsf(f) < FLT_EPSILON) ? 2.3f : thickness;\n\n               gContext.mDrawList->AddLine(worldToPos(ptA, res), worldToPos(ptB, res), col, thickness);\n            }\n         }\n      }\n   }\n\n   void ViewManipulate(float* view, const float* projection, OPERATION operation, MODE mode, float* matrix, float length, ImVec2 position, ImVec2 size, ImU32 backgroundColor)\n   {\n      // Scale is always local or matrix will be skewed when applying world scale or oriented matrix\n      ComputeContext(view, projection, matrix, (operation & SCALE) ? LOCAL : mode);\n      ViewManipulate(view, length, position, size, backgroundColor);\n   }\n\n   void ViewManipulate(float* view, float length, ImVec2 position, ImVec2 size, ImU32 backgroundColor)\n   {\n      static bool isDraging = false;\n      static bool isClicking = false;\n      static vec_t interpolationUp;\n      static vec_t interpolationDir;\n      static int interpolationFrames = 0;\n      const vec_t referenceUp = makeVect(0.f, 1.f, 0.f);\n\n      matrix_t svgView, svgProjection;\n      svgView = gContext.mViewMat;\n      svgProjection = gContext.mProjectionMat;\n\n      ImGuiIO& io = ImGui::GetIO();\n      gContext.mDrawList->AddRectFilled(position, position + size, backgroundColor);\n      matrix_t viewInverse;\n      viewInverse.Inverse(*(matrix_t*)view);\n\n      const vec_t camTarget = viewInverse.v.position - viewInverse.v.dir * length;\n\n      // view/projection matrices\n      const float distance = 3.f;\n      matrix_t cubeProjection, cubeView;\n      float fov = acosf(distance / (sqrtf(distance * distance + 3.f))) * RAD2DEG;\n      Perspective(fov / sqrtf(2.f), size.x / size.y, 0.01f, 1000.f, cubeProjection.m16);\n\n      vec_t dir = makeVect(viewInverse.m[2][0], viewInverse.m[2][1], viewInverse.m[2][2]);\n      vec_t up = makeVect(viewInverse.m[1][0], viewInverse.m[1][1], viewInverse.m[1][2]);\n      vec_t eye = dir * distance;\n      vec_t zero = makeVect(0.f, 0.f);\n      LookAt(&eye.x, &zero.x, &up.x, cubeView.m16);\n\n      // set context\n      gContext.mViewMat = cubeView;\n      gContext.mProjectionMat = cubeProjection;\n      ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector, position, size);\n\n      const matrix_t res = cubeView * cubeProjection;\n\n      // panels\n      static const ImVec2 panelPosition[9] = { ImVec2(0.75f,0.75f), ImVec2(0.25f, 0.75f), ImVec2(0.f, 0.75f),\n         ImVec2(0.75f, 0.25f), ImVec2(0.25f, 0.25f), ImVec2(0.f, 0.25f),\n         ImVec2(0.75f, 0.f), ImVec2(0.25f, 0.f), ImVec2(0.f, 0.f) };\n\n      static const ImVec2 panelSize[9] = { ImVec2(0.25f,0.25f), ImVec2(0.5f, 0.25f), ImVec2(0.25f, 0.25f),\n         ImVec2(0.25f, 0.5f), ImVec2(0.5f, 0.5f), ImVec2(0.25f, 0.5f),\n         ImVec2(0.25f, 0.25f), ImVec2(0.5f, 0.25f), ImVec2(0.25f, 0.25f) };\n\n      // tag faces\n      bool boxes[27]{};\n      static int overBox = -1;\n      for (int iPass = 0; iPass < 2; iPass++)\n      {\n         for (int iFace = 0; iFace < 6; iFace++)\n         {\n            const int normalIndex = (iFace % 3);\n            const int perpXIndex = (normalIndex + 1) % 3;\n            const int perpYIndex = (normalIndex + 2) % 3;\n            const float invert = (iFace > 2) ? -1.f : 1.f;\n            const vec_t indexVectorX = directionUnary[perpXIndex] * invert;\n            const vec_t indexVectorY = directionUnary[perpYIndex] * invert;\n            const vec_t boxOrigin = directionUnary[normalIndex] * -invert - indexVectorX - indexVectorY;\n\n            // plan local space\n            const vec_t n = directionUnary[normalIndex] * invert;\n            vec_t viewSpaceNormal = n;\n            vec_t viewSpacePoint = n * 0.5f;\n            viewSpaceNormal.TransformVector(cubeView);\n            viewSpaceNormal.Normalize();\n            viewSpacePoint.TransformPoint(cubeView);\n            const vec_t viewSpaceFacePlan = BuildPlan(viewSpacePoint, viewSpaceNormal);\n\n            // back face culling\n            if (viewSpaceFacePlan.w > 0.f)\n            {\n               continue;\n            }\n\n            const vec_t facePlan = BuildPlan(n * 0.5f, n);\n\n            const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, facePlan);\n            vec_t posOnPlan = gContext.mRayOrigin + gContext.mRayVector * len - (n * 0.5f);\n\n            float localx = Dot(directionUnary[perpXIndex], posOnPlan) * invert + 0.5f;\n            float localy = Dot(directionUnary[perpYIndex], posOnPlan) * invert + 0.5f;\n\n            // panels\n            const vec_t dx = directionUnary[perpXIndex];\n            const vec_t dy = directionUnary[perpYIndex];\n            const vec_t origin = directionUnary[normalIndex] - dx - dy;\n            for (int iPanel = 0; iPanel < 9; iPanel++)\n            {\n               vec_t boxCoord = boxOrigin + indexVectorX * float(iPanel % 3) + indexVectorY * float(iPanel / 3) + makeVect(1.f, 1.f, 1.f);\n               const ImVec2 p = panelPosition[iPanel] * 2.f;\n               const ImVec2 s = panelSize[iPanel] * 2.f;\n               ImVec2 faceCoordsScreen[4];\n               vec_t panelPos[4] = { dx * p.x + dy * p.y,\n                                     dx * p.x + dy * (p.y + s.y),\n                                     dx * (p.x + s.x) + dy * (p.y + s.y),\n                                     dx * (p.x + s.x) + dy * p.y };\n\n               for (unsigned int iCoord = 0; iCoord < 4; iCoord++)\n               {\n                  faceCoordsScreen[iCoord] = worldToPos((panelPos[iCoord] + origin) * 0.5f * invert, res, position, size);\n               }\n\n               const ImVec2 panelCorners[2] = { panelPosition[iPanel], panelPosition[iPanel] + panelSize[iPanel] };\n               bool insidePanel = localx > panelCorners[0].x && localx < panelCorners[1].x && localy > panelCorners[0].y && localy < panelCorners[1].y;\n               int boxCoordInt = int(boxCoord.x * 9.f + boxCoord.y * 3.f + boxCoord.z);\n               IM_ASSERT(boxCoordInt < 27);\n               boxes[boxCoordInt] |= insidePanel && (!isDraging) && gContext.mbMouseOver;\n\n               // draw face with lighter color\n               if (iPass)\n               {\n                  ImU32 directionColor = GetColorU32(DIRECTION_X + normalIndex);\n                  gContext.mDrawList->AddConvexPolyFilled(faceCoordsScreen, 4, (directionColor | IM_COL32(0x80, 0x80, 0x80, 0x80)) | (gContext.mIsViewManipulatorHovered ? IM_COL32(0x08, 0x08, 0x08, 0) : 0));\n                  if (boxes[boxCoordInt])\n                  {\n                     gContext.mDrawList->AddConvexPolyFilled(faceCoordsScreen, 4, IM_COL32(0xF0, 0xA0, 0x60, 0x80));\n\n                     if (io.MouseDown[0] && !isClicking && !isDraging && GImGui->ActiveId == 0) {\n                        overBox = boxCoordInt;\n                        isClicking = true;\n                        isDraging = true;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      if (interpolationFrames)\n      {\n         interpolationFrames--;\n         vec_t newDir = viewInverse.v.dir;\n         newDir.Lerp(interpolationDir, 0.2f);\n         newDir.Normalize();\n\n         vec_t newUp = viewInverse.v.up;\n         newUp.Lerp(interpolationUp, 0.3f);\n         newUp.Normalize();\n         newUp = interpolationUp;\n         vec_t newEye = camTarget + newDir * length;\n         LookAt(&newEye.x, &camTarget.x, &newUp.x, view);\n      }\n      gContext.mIsViewManipulatorHovered = gContext.mbMouseOver && ImRect(position, position + size).Contains(io.MousePos);\n\n      if (io.MouseDown[0] && (fabsf(io.MouseDelta[0]) || fabsf(io.MouseDelta[1])) && isClicking)\n      {\n         isClicking = false;\n      }\n\n      if (!io.MouseDown[0])\n      {\n         if (isClicking)\n         {\n            // apply new view direction\n            int cx = overBox / 9;\n            int cy = (overBox - cx * 9) / 3;\n            int cz = overBox % 3;\n            interpolationDir = makeVect(1.f - (float)cx, 1.f - (float)cy, 1.f - (float)cz);\n            interpolationDir.Normalize();\n\n            if (fabsf(Dot(interpolationDir, referenceUp)) > 1.0f - 0.01f)\n            {\n               vec_t right = viewInverse.v.right;\n               if (fabsf(right.x) > fabsf(right.z))\n               {\n                  right.z = 0.f;\n               }\n               else\n               {\n                  right.x = 0.f;\n               }\n               right.Normalize();\n               interpolationUp = Cross(interpolationDir, right);\n               interpolationUp.Normalize();\n            }\n            else\n            {\n               interpolationUp = referenceUp;\n            }\n            interpolationFrames = 40;\n\n         }\n         isClicking = false;\n         isDraging = false;\n      }\n\n\n      if (isDraging)\n      {\n         matrix_t rx, ry, roll;\n\n         rx.RotationAxis(referenceUp, -io.MouseDelta.x * 0.01f);\n         ry.RotationAxis(viewInverse.v.right, -io.MouseDelta.y * 0.01f);\n\n         roll = rx * ry;\n\n         vec_t newDir = viewInverse.v.dir;\n         newDir.TransformVector(roll);\n         newDir.Normalize();\n\n         // clamp\n         vec_t planDir = Cross(viewInverse.v.right, referenceUp);\n         planDir.y = 0.f;\n         planDir.Normalize();\n         float dt = Dot(planDir, newDir);\n         if (dt < 0.0f)\n         {\n            newDir += planDir * dt;\n            newDir.Normalize();\n         }\n\n         vec_t newEye = camTarget + newDir * length;\n         LookAt(&newEye.x, &camTarget.x, &referenceUp.x, view);\n      }\n\n      gContext.mbUsingViewManipulate = (interpolationFrames != 0) || isDraging;\n\n      // restore view/projection because it was used to compute ray\n      ComputeContext(svgView.m16, svgProjection.m16, gContext.mModelSource.m16, gContext.mMode);\n   }\n};\n"
        },
        {
          "name": "ImGuizmo.h",
          "type": "blob",
          "size": 14.24609375,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// -------------------------------------------------------------------------------------------\n// History :\n// 2019/11/03 View gizmo\n// 2016/09/11 Behind camera culling. Scaling Delta matrix not multiplied by source matrix scales. local/world rotation and translation fixed. Display message is incorrect (X: ... Y:...) in local mode.\n// 2016/09/09 Hatched negative axis. Snapping. Documentation update.\n// 2016/09/04 Axis switch and translation plan autohiding. Scale transform stability improved\n// 2016/09/01 Mogwai changed to Manipulate. Draw debug cube. Fixed inverted scale. Mixing scale and translation/rotation gives bad results.\n// 2016/08/31 First version\n//\n// -------------------------------------------------------------------------------------------\n// Future (no order):\n//\n// - Multi view\n// - display rotation/translation/scale infos in local/world space and not only local\n// - finish local/world matrix application\n// - OPERATION as bitmask\n//\n// -------------------------------------------------------------------------------------------\n// Example\n#if 0\nvoid EditTransform(const Camera& camera, matrix_t& matrix)\n{\n   static ImGuizmo::OPERATION mCurrentGizmoOperation(ImGuizmo::ROTATE);\n   static ImGuizmo::MODE mCurrentGizmoMode(ImGuizmo::WORLD);\n   if (ImGui::IsKeyPressed(90))\n      mCurrentGizmoOperation = ImGuizmo::TRANSLATE;\n   if (ImGui::IsKeyPressed(69))\n      mCurrentGizmoOperation = ImGuizmo::ROTATE;\n   if (ImGui::IsKeyPressed(82)) // r Key\n      mCurrentGizmoOperation = ImGuizmo::SCALE;\n   if (ImGui::RadioButton(\"Translate\", mCurrentGizmoOperation == ImGuizmo::TRANSLATE))\n      mCurrentGizmoOperation = ImGuizmo::TRANSLATE;\n   ImGui::SameLine();\n   if (ImGui::RadioButton(\"Rotate\", mCurrentGizmoOperation == ImGuizmo::ROTATE))\n      mCurrentGizmoOperation = ImGuizmo::ROTATE;\n   ImGui::SameLine();\n   if (ImGui::RadioButton(\"Scale\", mCurrentGizmoOperation == ImGuizmo::SCALE))\n      mCurrentGizmoOperation = ImGuizmo::SCALE;\n   float matrixTranslation[3], matrixRotation[3], matrixScale[3];\n   ImGuizmo::DecomposeMatrixToComponents(matrix.m16, matrixTranslation, matrixRotation, matrixScale);\n   ImGui::InputFloat3(\"Tr\", matrixTranslation, 3);\n   ImGui::InputFloat3(\"Rt\", matrixRotation, 3);\n   ImGui::InputFloat3(\"Sc\", matrixScale, 3);\n   ImGuizmo::RecomposeMatrixFromComponents(matrixTranslation, matrixRotation, matrixScale, matrix.m16);\n\n   if (mCurrentGizmoOperation != ImGuizmo::SCALE)\n   {\n      if (ImGui::RadioButton(\"Local\", mCurrentGizmoMode == ImGuizmo::LOCAL))\n         mCurrentGizmoMode = ImGuizmo::LOCAL;\n      ImGui::SameLine();\n      if (ImGui::RadioButton(\"World\", mCurrentGizmoMode == ImGuizmo::WORLD))\n         mCurrentGizmoMode = ImGuizmo::WORLD;\n   }\n   static bool useSnap(false);\n   if (ImGui::IsKeyPressed(83))\n      useSnap = !useSnap;\n   ImGui::Checkbox(\"\", &useSnap);\n   ImGui::SameLine();\n   vec_t snap;\n   switch (mCurrentGizmoOperation)\n   {\n   case ImGuizmo::TRANSLATE:\n      snap = config.mSnapTranslation;\n      ImGui::InputFloat3(\"Snap\", &snap.x);\n      break;\n   case ImGuizmo::ROTATE:\n      snap = config.mSnapRotation;\n      ImGui::InputFloat(\"Angle Snap\", &snap.x);\n      break;\n   case ImGuizmo::SCALE:\n      snap = config.mSnapScale;\n      ImGui::InputFloat(\"Scale Snap\", &snap.x);\n      break;\n   }\n   ImGuiIO& io = ImGui::GetIO();\n   ImGuizmo::SetRect(0, 0, io.DisplaySize.x, io.DisplaySize.y);\n   ImGuizmo::Manipulate(camera.mView.m16, camera.mProjection.m16, mCurrentGizmoOperation, mCurrentGizmoMode, matrix.m16, NULL, useSnap ? &snap.x : NULL);\n}\n#endif\n#pragma once\n\n#ifdef USE_IMGUI_API\n#include \"imconfig.h\"\n#endif\n#ifndef IMGUI_API\n#define IMGUI_API\n#endif\n\n#ifndef IMGUIZMO_NAMESPACE\n#define IMGUIZMO_NAMESPACE ImGuizmo\n#endif\n\nstruct ImGuiWindow;\n\nnamespace IMGUIZMO_NAMESPACE\n{\n   // call inside your own window and before Manipulate() in order to draw gizmo to that window.\n   // Or pass a specific ImDrawList to draw to (e.g. ImGui::GetForegroundDrawList()).\n   IMGUI_API void SetDrawlist(ImDrawList* drawlist = nullptr);\n\n   // call BeginFrame right after ImGui_XXXX_NewFrame();\n   IMGUI_API void BeginFrame();\n\n   // this is necessary because when imguizmo is compiled into a dll, and imgui into another\n   // globals are not shared between them.\n   // More details at https://stackoverflow.com/questions/19373061/what-happens-to-global-and-static-variables-in-a-shared-library-when-it-is-dynam\n   // expose method to set imgui context\n   IMGUI_API void SetImGuiContext(ImGuiContext* ctx);\n\n   // return true if mouse cursor is over any gizmo control (axis, plan or screen component)\n   IMGUI_API bool IsOver();\n\n   // return true if mouse IsOver or if the gizmo is in moving state\n   IMGUI_API bool IsUsing();\n\n   // return true if the view gizmo is in moving state\n   IMGUI_API bool IsUsingViewManipulate();\n   // only check if your mouse is over the view manipulator - no matter whether it's active or not\n   IMGUI_API bool IsViewManipulateHovered();\n\n   // return true if any gizmo is in moving state\n   IMGUI_API bool IsUsingAny();\n\n   // enable/disable the gizmo. Stay in the state until next call to Enable.\n   // gizmo is rendered with gray half transparent color when disabled\n   IMGUI_API void Enable(bool enable);\n\n   // helper functions for manualy editing translation/rotation/scale with an input float\n   // translation, rotation and scale float points to 3 floats each\n   // Angles are in degrees (more suitable for human editing)\n   // example:\n   // float matrixTranslation[3], matrixRotation[3], matrixScale[3];\n   // ImGuizmo::DecomposeMatrixToComponents(gizmoMatrix.m16, matrixTranslation, matrixRotation, matrixScale);\n   // ImGui::InputFloat3(\"Tr\", matrixTranslation, 3);\n   // ImGui::InputFloat3(\"Rt\", matrixRotation, 3);\n   // ImGui::InputFloat3(\"Sc\", matrixScale, 3);\n   // ImGuizmo::RecomposeMatrixFromComponents(matrixTranslation, matrixRotation, matrixScale, gizmoMatrix.m16);\n   //\n   // These functions have some numerical stability issues for now. Use with caution.\n   IMGUI_API void DecomposeMatrixToComponents(const float* matrix, float* translation, float* rotation, float* scale);\n   IMGUI_API void RecomposeMatrixFromComponents(const float* translation, const float* rotation, const float* scale, float* matrix);\n\n   IMGUI_API void SetRect(float x, float y, float width, float height);\n   // default is false\n   IMGUI_API void SetOrthographic(bool isOrthographic);\n\n   // Render a cube with face color corresponding to face normal. Usefull for debug/tests\n   IMGUI_API void DrawCubes(const float* view, const float* projection, const float* matrices, int matrixCount);\n   IMGUI_API void DrawGrid(const float* view, const float* projection, const float* matrix, const float gridSize);\n\n   // call it when you want a gizmo\n   // Needs view and projection matrices.\n   // matrix parameter is the source matrix (where will be gizmo be drawn) and might be transformed by the function. Return deltaMatrix is optional\n   // translation is applied in world space\n   enum OPERATION\n   {\n      TRANSLATE_X      = (1u << 0),\n      TRANSLATE_Y      = (1u << 1),\n      TRANSLATE_Z      = (1u << 2),\n      ROTATE_X         = (1u << 3),\n      ROTATE_Y         = (1u << 4),\n      ROTATE_Z         = (1u << 5),\n      ROTATE_SCREEN    = (1u << 6),\n      SCALE_X          = (1u << 7),\n      SCALE_Y          = (1u << 8),\n      SCALE_Z          = (1u << 9),\n      BOUNDS           = (1u << 10),\n      SCALE_XU         = (1u << 11),\n      SCALE_YU         = (1u << 12),\n      SCALE_ZU         = (1u << 13),\n\n      TRANSLATE = TRANSLATE_X | TRANSLATE_Y | TRANSLATE_Z,\n      ROTATE = ROTATE_X | ROTATE_Y | ROTATE_Z | ROTATE_SCREEN,\n      SCALE = SCALE_X | SCALE_Y | SCALE_Z,\n      SCALEU = SCALE_XU | SCALE_YU | SCALE_ZU, // universal\n      UNIVERSAL = TRANSLATE | ROTATE | SCALEU\n   };\n\n   inline OPERATION operator|(OPERATION lhs, OPERATION rhs)\n   {\n     return static_cast<OPERATION>(static_cast<int>(lhs) | static_cast<int>(rhs));\n   }\n\n   enum MODE\n   {\n      LOCAL,\n      WORLD\n   };\n\n   IMGUI_API bool Manipulate(const float* view, const float* projection, OPERATION operation, MODE mode, float* matrix, float* deltaMatrix = NULL, const float* snap = NULL, const float* localBounds = NULL, const float* boundsSnap = NULL);\n   //\n   // Please note that this cubeview is patented by Autodesk : https://patents.google.com/patent/US7782319B2/en\n   // It seems to be a defensive patent in the US. I don't think it will bring troubles using it as\n   // other software are using the same mechanics. But just in case, you are now warned!\n   //\n   IMGUI_API void ViewManipulate(float* view, float length, ImVec2 position, ImVec2 size, ImU32 backgroundColor);\n\n   // use this version if you did not call Manipulate before and you are just using ViewManipulate\n   IMGUI_API void ViewManipulate(float* view, const float* projection, OPERATION operation, MODE mode, float* matrix, float length, ImVec2 position, ImVec2 size, ImU32 backgroundColor);\n\n   IMGUI_API void SetAlternativeWindow(ImGuiWindow* window);\n\n   [[deprecated(\"Use PushID/PopID instead.\")]]\n   IMGUI_API void SetID(int id);\n\n\t// ID stack/scopes\n\t// Read the FAQ (docs/FAQ.md or http://dearimgui.org/faq) for more details about how ID are handled in dear imgui.\n\t// - Those questions are answered and impacted by understanding of the ID stack system:\n\t//   - \"Q: Why is my widget not reacting when I click on it?\"\n\t//   - \"Q: How can I have widgets with an empty label?\"\n\t//   - \"Q: How can I have multiple widgets with the same label?\"\n\t// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely\n\t//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.\n\t// - You can also use the \"Label##foobar\" syntax within widget label to distinguish them from each others.\n\t// - In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed + used as an ID,\n\t//   whereas \"str_id\" denote a string that is only used as an ID and not normally displayed.\n\tIMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).\n\tIMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).\n\tIMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer).\n\tIMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).\n\tIMGUI_API void          PopID();                                                        // pop from the ID stack.\n\tIMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\n\tIMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\n\tIMGUI_API ImGuiID       GetID(const void* ptr_id);\n\n   // return true if the cursor is over the operation's gizmo\n   IMGUI_API bool IsOver(OPERATION op);\n   IMGUI_API void SetGizmoSizeClipSpace(float value);\n\n   // Allow axis to flip\n   // When true (default), the guizmo axis flip for better visibility\n   // When false, they always stay along the positive world/local axis\n   IMGUI_API void AllowAxisFlip(bool value);\n\n   // Configure the limit where axis are hidden\n   IMGUI_API void SetAxisLimit(float value);\n   // Set an axis mask to permanently hide a given axis (true -> hidden, false -> shown)\n   IMGUI_API void SetAxisMask(bool x, bool y, bool z);\n   // Configure the limit where planes are hiden\n   IMGUI_API void SetPlaneLimit(float value);\n   // from a x,y,z point in space and using Manipulation view/projection matrix, check if mouse is in pixel radius distance of that projected point\n   IMGUI_API bool IsOver(float* position, float pixelRadius);\n\n   enum COLOR\n   {\n      DIRECTION_X,      // directionColor[0]\n      DIRECTION_Y,      // directionColor[1]\n      DIRECTION_Z,      // directionColor[2]\n      PLANE_X,          // planeColor[0]\n      PLANE_Y,          // planeColor[1]\n      PLANE_Z,          // planeColor[2]\n      SELECTION,        // selectionColor\n      INACTIVE,         // inactiveColor\n      TRANSLATION_LINE, // translationLineColor\n      SCALE_LINE,\n      ROTATION_USING_BORDER,\n      ROTATION_USING_FILL,\n      HATCHED_AXIS_LINES,\n      TEXT,\n      TEXT_SHADOW,\n      COUNT\n   };\n\n   struct Style\n   {\n      IMGUI_API Style();\n\n      float TranslationLineThickness;   // Thickness of lines for translation gizmo\n      float TranslationLineArrowSize;   // Size of arrow at the end of lines for translation gizmo\n      float RotationLineThickness;      // Thickness of lines for rotation gizmo\n      float RotationOuterLineThickness; // Thickness of line surrounding the rotation gizmo\n      float ScaleLineThickness;         // Thickness of lines for scale gizmo\n      float ScaleLineCircleSize;        // Size of circle at the end of lines for scale gizmo\n      float HatchedAxisLineThickness;   // Thickness of hatched axis lines\n      float CenterCircleSize;           // Size of circle at the center of the translate/scale gizmo\n\n      ImVec4 Colors[COLOR::COUNT];\n   };\n\n   IMGUI_API Style& GetStyle();\n}\n"
        },
        {
          "name": "ImSequencer.cpp",
          "type": "blob",
          "size": 29.9794921875,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#include \"ImSequencer.h\"\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n#include <cstdlib>\n\nnamespace ImSequencer\n{\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n   static ImVec2 operator+(const ImVec2& a, const ImVec2& b) {\n      return ImVec2(a.x + b.x, a.y + b.y);\n   }\n#endif\n   static bool SequencerAddDelButton(ImDrawList* draw_list, ImVec2 pos, bool add = true)\n   {\n      ImGuiIO& io = ImGui::GetIO();\n      ImRect btnRect(pos, ImVec2(pos.x + 16, pos.y + 16));\n      bool overBtn = btnRect.Contains(io.MousePos);\n      bool containedClick = overBtn && btnRect.Contains(io.MouseClickedPos[0]);\n      bool clickedBtn = containedClick && io.MouseReleased[0];\n      int btnColor = overBtn ? 0xAAEAFFAA : 0x77A3B2AA;\n      if (containedClick && io.MouseDownDuration[0] > 0)\n         btnRect.Expand(2.0f);\n\n      float midy = pos.y + 16 / 2 - 0.5f;\n      float midx = pos.x + 16 / 2 - 0.5f;\n      draw_list->AddRect(btnRect.Min, btnRect.Max, btnColor, 4);\n      draw_list->AddLine(ImVec2(btnRect.Min.x + 3, midy), ImVec2(btnRect.Max.x - 3, midy), btnColor, 2);\n      if (add)\n         draw_list->AddLine(ImVec2(midx, btnRect.Min.y + 3), ImVec2(midx, btnRect.Max.y - 3), btnColor, 2);\n      return clickedBtn;\n   }\n\n   bool Sequencer(SequenceInterface* sequence, int* currentFrame, bool* expanded, int* selectedEntry, int* firstFrame, int sequenceOptions)\n   {\n      bool ret = false;\n      ImGuiIO& io = ImGui::GetIO();\n      int cx = (int)(io.MousePos.x);\n      int cy = (int)(io.MousePos.y);\n      static float framePixelWidth = 10.f;\n      static float framePixelWidthTarget = 10.f;\n      int legendWidth = 200;\n\n      static int movingEntry = -1;\n      static int movingPos = -1;\n      static int movingPart = -1;\n      int delEntry = -1;\n      int dupEntry = -1;\n      int ItemHeight = 20;\n\n      bool popupOpened = false;\n      int sequenceCount = sequence->GetItemCount();\n      if (!sequenceCount)\n         return false;\n      ImGui::BeginGroup();\n\n      ImDrawList* draw_list = ImGui::GetWindowDrawList();\n      ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates!\n      ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available\n      int firstFrameUsed = firstFrame ? *firstFrame : 0;\n\n\n      int controlHeight = sequenceCount * ItemHeight;\n      for (int i = 0; i < sequenceCount; i++)\n         controlHeight += int(sequence->GetCustomHeight(i));\n      int frameCount = ImMax(sequence->GetFrameMax() - sequence->GetFrameMin(), 1);\n\n      static bool MovingScrollBar = false;\n      static bool MovingCurrentFrame = false;\n      struct CustomDraw\n      {\n         int index;\n         ImRect customRect;\n         ImRect legendRect;\n         ImRect clippingRect;\n         ImRect legendClippingRect;\n      };\n      ImVector<CustomDraw> customDraws;\n      ImVector<CustomDraw> compactCustomDraws;\n      // zoom in/out\n      const int visibleFrameCount = (int)floorf((canvas_size.x - legendWidth) / framePixelWidth);\n      const float barWidthRatio = ImMin(visibleFrameCount / (float)frameCount, 1.f);\n      const float barWidthInPixels = barWidthRatio * (canvas_size.x - legendWidth);\n\n      ImRect regionRect(canvas_pos, canvas_pos + canvas_size);\n\n      static bool panningView = false;\n      static ImVec2 panningViewSource;\n      static int panningViewFrame;\n      if (ImGui::IsWindowFocused() && io.KeyAlt && io.MouseDown[2])\n      {\n         if (!panningView)\n         {\n            panningViewSource = io.MousePos;\n            panningView = true;\n            panningViewFrame = *firstFrame;\n         }\n         *firstFrame = panningViewFrame - int((io.MousePos.x - panningViewSource.x) / framePixelWidth);\n         *firstFrame = ImClamp(*firstFrame, sequence->GetFrameMin(), sequence->GetFrameMax() - visibleFrameCount);\n      }\n      if (panningView && !io.MouseDown[2])\n      {\n         panningView = false;\n      }\n      framePixelWidthTarget = ImClamp(framePixelWidthTarget, 0.1f, 50.f);\n\n      framePixelWidth = ImLerp(framePixelWidth, framePixelWidthTarget, 0.33f);\n\n      frameCount = sequence->GetFrameMax() - sequence->GetFrameMin();\n      if (visibleFrameCount >= frameCount && firstFrame)\n         *firstFrame = sequence->GetFrameMin();\n\n\n      // --\n      if (expanded && !*expanded)\n      {\n         ImGui::InvisibleButton(\"canvas\", ImVec2(canvas_size.x - canvas_pos.x, (float)ItemHeight));\n         draw_list->AddRectFilled(canvas_pos, ImVec2(canvas_size.x + canvas_pos.x, canvas_pos.y + ItemHeight), 0xFF3D3837, 0);\n         char tmps[512];\n         ImFormatString(tmps, IM_ARRAYSIZE(tmps), sequence->GetCollapseFmt(), frameCount, sequenceCount);\n         draw_list->AddText(ImVec2(canvas_pos.x + 26, canvas_pos.y + 2), 0xFFFFFFFF, tmps);\n      }\n      else\n      {\n         bool hasScrollBar(true);\n         /*\n         int framesPixelWidth = int(frameCount * framePixelWidth);\n         if ((framesPixelWidth + legendWidth) >= canvas_size.x)\n         {\n             hasScrollBar = true;\n         }\n         */\n         // test scroll area\n         ImVec2 headerSize(canvas_size.x, (float)ItemHeight);\n         ImVec2 scrollBarSize(canvas_size.x, 14.f);\n         ImGui::InvisibleButton(\"topBar\", headerSize);\n         draw_list->AddRectFilled(canvas_pos, canvas_pos + headerSize, 0xFFFF0000, 0);\n         ImVec2 childFramePos = ImGui::GetCursorScreenPos();\n         ImVec2 childFrameSize(canvas_size.x, canvas_size.y - 8.f - headerSize.y - (hasScrollBar ? scrollBarSize.y : 0));\n         ImGui::PushStyleColor(ImGuiCol_FrameBg, 0);\n         ImGui::BeginChild(889, childFrameSize, ImGuiChildFlags_FrameStyle);\n         sequence->focused = ImGui::IsWindowFocused();\n         ImGui::InvisibleButton(\"contentBar\", ImVec2(canvas_size.x, float(controlHeight)));\n         const ImVec2 contentMin = ImGui::GetItemRectMin();\n         const ImVec2 contentMax = ImGui::GetItemRectMax();\n         const ImRect contentRect(contentMin, contentMax);\n         const float contentHeight = contentMax.y - contentMin.y;\n\n         // full background\n         draw_list->AddRectFilled(canvas_pos, canvas_pos + canvas_size, 0xFF242424, 0);\n\n         // current frame top\n         ImRect topRect(ImVec2(canvas_pos.x + legendWidth, canvas_pos.y), ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + ItemHeight));\n\n         if (!MovingCurrentFrame && !MovingScrollBar && movingEntry == -1 && sequenceOptions & SEQUENCER_CHANGE_FRAME && currentFrame && *currentFrame >= 0 && topRect.Contains(io.MousePos) && io.MouseDown[0])\n         {\n            MovingCurrentFrame = true;\n         }\n         if (MovingCurrentFrame)\n         {\n            if (frameCount)\n            {\n               *currentFrame = (int)((io.MousePos.x - topRect.Min.x) / framePixelWidth) + firstFrameUsed;\n               if (*currentFrame < sequence->GetFrameMin())\n                  *currentFrame = sequence->GetFrameMin();\n               if (*currentFrame >= sequence->GetFrameMax())\n                  *currentFrame = sequence->GetFrameMax();\n            }\n            if (!io.MouseDown[0])\n               MovingCurrentFrame = false;\n         }\n\n         //header\n         draw_list->AddRectFilled(canvas_pos, ImVec2(canvas_size.x + canvas_pos.x, canvas_pos.y + ItemHeight), 0xFF3D3837, 0);\n         if (sequenceOptions & SEQUENCER_ADD)\n         {\n            if (SequencerAddDelButton(draw_list, ImVec2(canvas_pos.x + legendWidth - ItemHeight, canvas_pos.y + 2), true))\n               ImGui::OpenPopup(\"addEntry\");\n\n            if (ImGui::BeginPopup(\"addEntry\"))\n            {\n               for (int i = 0; i < sequence->GetItemTypeCount(); i++)\n                  if (ImGui::Selectable(sequence->GetItemTypeName(i)))\n                  {\n                     sequence->Add(i);\n                     *selectedEntry = sequence->GetItemCount() - 1;\n                  }\n\n               ImGui::EndPopup();\n               popupOpened = true;\n            }\n         }\n\n         //header frame number and lines\n         int modFrameCount = 10;\n         int frameStep = 1;\n         while ((modFrameCount * framePixelWidth) < 150)\n         {\n            modFrameCount *= 2;\n            frameStep *= 2;\n         };\n         int halfModFrameCount = modFrameCount / 2;\n\n         auto drawLine = [&](int i, int regionHeight) {\n            bool baseIndex = ((i % modFrameCount) == 0) || (i == sequence->GetFrameMax() || i == sequence->GetFrameMin());\n            bool halfIndex = (i % halfModFrameCount) == 0;\n            int px = (int)canvas_pos.x + int(i * framePixelWidth) + legendWidth - int(firstFrameUsed * framePixelWidth);\n            int tiretStart = baseIndex ? 4 : (halfIndex ? 10 : 14);\n            int tiretEnd = baseIndex ? regionHeight : ItemHeight;\n\n            if (px <= (canvas_size.x + canvas_pos.x) && px >= (canvas_pos.x + legendWidth))\n            {\n               draw_list->AddLine(ImVec2((float)px, canvas_pos.y + (float)tiretStart), ImVec2((float)px, canvas_pos.y + (float)tiretEnd - 1), 0xFF606060, 1);\n\n               draw_list->AddLine(ImVec2((float)px, canvas_pos.y + (float)ItemHeight), ImVec2((float)px, canvas_pos.y + (float)regionHeight - 1), 0x30606060, 1);\n            }\n\n            if (baseIndex && px > (canvas_pos.x + legendWidth))\n            {\n               char tmps[512];\n               ImFormatString(tmps, IM_ARRAYSIZE(tmps), \"%d\", i);\n               draw_list->AddText(ImVec2((float)px + 3.f, canvas_pos.y), 0xFFBBBBBB, tmps);\n            }\n\n         };\n\n         auto drawLineContent = [&](int i, int /*regionHeight*/) {\n            int px = (int)canvas_pos.x + int(i * framePixelWidth) + legendWidth - int(firstFrameUsed * framePixelWidth);\n            int tiretStart = int(contentMin.y);\n            int tiretEnd = int(contentMax.y);\n\n            if (px <= (canvas_size.x + canvas_pos.x) && px >= (canvas_pos.x + legendWidth))\n            {\n               //draw_list->AddLine(ImVec2((float)px, canvas_pos.y + (float)tiretStart), ImVec2((float)px, canvas_pos.y + (float)tiretEnd - 1), 0xFF606060, 1);\n\n               draw_list->AddLine(ImVec2(float(px), float(tiretStart)), ImVec2(float(px), float(tiretEnd)), 0x30606060, 1);\n            }\n         };\n         for (int i = sequence->GetFrameMin(); i <= sequence->GetFrameMax(); i += frameStep)\n         {\n            drawLine(i, ItemHeight);\n         }\n         drawLine(sequence->GetFrameMin(), ItemHeight);\n         drawLine(sequence->GetFrameMax(), ItemHeight);\n         /*\n                  draw_list->AddLine(canvas_pos, ImVec2(canvas_pos.x, canvas_pos.y + controlHeight), 0xFF000000, 1);\n                  draw_list->AddLine(ImVec2(canvas_pos.x, canvas_pos.y + ItemHeight), ImVec2(canvas_size.x, canvas_pos.y + ItemHeight), 0xFF000000, 1);\n                  */\n                  // clip content\n\n         draw_list->PushClipRect(childFramePos, childFramePos + childFrameSize, true);\n\n         // draw item names in the legend rect on the left\n         size_t customHeight = 0;\n         for (int i = 0; i < sequenceCount; i++)\n         {\n            int type;\n            sequence->Get(i, NULL, NULL, &type, NULL);\n            ImVec2 tpos(contentMin.x + 3, contentMin.y + i * ItemHeight + 2 + customHeight);\n            draw_list->AddText(tpos, 0xFFFFFFFF, sequence->GetItemLabel(i));\n\n            if (sequenceOptions & SEQUENCER_DEL)\n            {\n               if (SequencerAddDelButton(draw_list, ImVec2(contentMin.x + legendWidth - ItemHeight + 2 - 10, tpos.y + 2), false))\n                  delEntry = i;\n\n               if (SequencerAddDelButton(draw_list, ImVec2(contentMin.x + legendWidth - ItemHeight - ItemHeight + 2 - 10, tpos.y + 2), true))\n                  dupEntry = i;\n            }\n            customHeight += sequence->GetCustomHeight(i);\n         }\n\n         // slots background\n         customHeight = 0;\n         for (int i = 0; i < sequenceCount; i++)\n         {\n            unsigned int col = (i & 1) ? 0xFF3A3636 : 0xFF413D3D;\n\n            size_t localCustomHeight = sequence->GetCustomHeight(i);\n            ImVec2 pos = ImVec2(contentMin.x + legendWidth, contentMin.y + ItemHeight * i + 1 + customHeight);\n            ImVec2 sz = ImVec2(canvas_size.x + canvas_pos.x, pos.y + ItemHeight - 1 + localCustomHeight);\n            if (!popupOpened && cy >= pos.y && cy < pos.y + (ItemHeight + localCustomHeight) && movingEntry == -1 && cx>contentMin.x && cx < contentMin.x + canvas_size.x)\n            {\n               col += 0x80201008;\n               pos.x -= legendWidth;\n            }\n            draw_list->AddRectFilled(pos, sz, col, 0);\n            customHeight += localCustomHeight;\n         }\n\n         draw_list->PushClipRect(childFramePos + ImVec2(float(legendWidth), 0.f), childFramePos + childFrameSize, true);\n\n         // vertical frame lines in content area\n         for (int i = sequence->GetFrameMin(); i <= sequence->GetFrameMax(); i += frameStep)\n         {\n            drawLineContent(i, int(contentHeight));\n         }\n         drawLineContent(sequence->GetFrameMin(), int(contentHeight));\n         drawLineContent(sequence->GetFrameMax(), int(contentHeight));\n\n         // selection\n         bool selected = selectedEntry && (*selectedEntry >= 0);\n         if (selected)\n         {\n            customHeight = 0;\n            for (int i = 0; i < *selectedEntry; i++)\n               customHeight += sequence->GetCustomHeight(i);\n            draw_list->AddRectFilled(ImVec2(contentMin.x, contentMin.y + ItemHeight * *selectedEntry + customHeight), ImVec2(contentMin.x + canvas_size.x, contentMin.y + ItemHeight * (*selectedEntry + 1) + customHeight), 0x801080FF, 1.f);\n         }\n\n         // slots\n         customHeight = 0;\n         for (int i = 0; i < sequenceCount; i++)\n         {\n            int* start, * end;\n            unsigned int color;\n            sequence->Get(i, &start, &end, NULL, &color);\n            size_t localCustomHeight = sequence->GetCustomHeight(i);\n\n            ImVec2 pos = ImVec2(contentMin.x + legendWidth - firstFrameUsed * framePixelWidth, contentMin.y + ItemHeight * i + 1 + customHeight);\n            ImVec2 slotP1(pos.x + *start * framePixelWidth, pos.y + 2);\n            ImVec2 slotP2(pos.x + *end * framePixelWidth + framePixelWidth, pos.y + ItemHeight - 2);\n            ImVec2 slotP3(pos.x + *end * framePixelWidth + framePixelWidth, pos.y + ItemHeight - 2 + localCustomHeight);\n            unsigned int slotColor = color | 0xFF000000;\n            unsigned int slotColorHalf = (color & 0xFFFFFF) | 0x40000000;\n\n            if (slotP1.x <= (canvas_size.x + contentMin.x) && slotP2.x >= (contentMin.x + legendWidth))\n            {\n               draw_list->AddRectFilled(slotP1, slotP3, slotColorHalf, 2);\n               draw_list->AddRectFilled(slotP1, slotP2, slotColor, 2);\n            }\n            if (ImRect(slotP1, slotP2).Contains(io.MousePos) && io.MouseDoubleClicked[0])\n            {\n               sequence->DoubleClick(i);\n            }\n            // Ensure grabbable handles\n            const float max_handle_width = slotP2.x - slotP1.x / 3.0f;\n            const float min_handle_width = ImMin(10.0f, max_handle_width);\n            const float handle_width = ImClamp(framePixelWidth / 2.0f, min_handle_width, max_handle_width);\n            ImRect rects[3] = { ImRect(slotP1, ImVec2(slotP1.x + handle_width, slotP2.y))\n                , ImRect(ImVec2(slotP2.x - handle_width, slotP1.y), slotP2)\n                , ImRect(slotP1, slotP2) };\n\n            const unsigned int quadColor[] = { 0xFFFFFFFF, 0xFFFFFFFF, slotColor + (selected ? 0 : 0x202020) };\n            if (movingEntry == -1 && (sequenceOptions & SEQUENCER_EDIT_STARTEND))// TODOFOCUS && backgroundRect.Contains(io.MousePos))\n            {\n               for (int j = 2; j >= 0; j--)\n               {\n                  ImRect& rc = rects[j];\n                  if (!rc.Contains(io.MousePos))\n                     continue;\n                  draw_list->AddRectFilled(rc.Min, rc.Max, quadColor[j], 2);\n               }\n\n               for (int j = 0; j < 3; j++)\n               {\n                  ImRect& rc = rects[j];\n                  if (!rc.Contains(io.MousePos))\n                     continue;\n                  if (!ImRect(childFramePos, childFramePos + childFrameSize).Contains(io.MousePos))\n                     continue;\n                  if (ImGui::IsMouseClicked(0) && !MovingScrollBar && !MovingCurrentFrame)\n                  {\n                     movingEntry = i;\n                     movingPos = cx;\n                     movingPart = j + 1;\n                     sequence->BeginEdit(movingEntry);\n                     break;\n                  }\n               }\n            }\n\n            // custom draw\n            if (localCustomHeight > 0)\n            {\n               ImVec2 rp(canvas_pos.x, contentMin.y + ItemHeight * i + 1 + customHeight);\n               ImRect customRect(rp + ImVec2(legendWidth - (firstFrameUsed - sequence->GetFrameMin() - 0.5f) * framePixelWidth, float(ItemHeight)),\n                  rp + ImVec2(legendWidth + (sequence->GetFrameMax() - firstFrameUsed - 0.5f + 2.f) * framePixelWidth, float(localCustomHeight + ItemHeight)));\n               ImRect clippingRect(rp + ImVec2(float(legendWidth), float(ItemHeight)), rp + ImVec2(canvas_size.x, float(localCustomHeight + ItemHeight)));\n\n               ImRect legendRect(rp + ImVec2(0.f, float(ItemHeight)), rp + ImVec2(float(legendWidth), float(localCustomHeight)));\n               ImRect legendClippingRect(canvas_pos + ImVec2(0.f, float(ItemHeight)), canvas_pos + ImVec2(float(legendWidth), float(localCustomHeight + ItemHeight)));\n               customDraws.push_back({ i, customRect, legendRect, clippingRect, legendClippingRect });\n            }\n            else\n            {\n               ImVec2 rp(canvas_pos.x, contentMin.y + ItemHeight * i + customHeight);\n               ImRect customRect(rp + ImVec2(legendWidth - (firstFrameUsed - sequence->GetFrameMin() - 0.5f) * framePixelWidth, float(0.f)),\n                  rp + ImVec2(legendWidth + (sequence->GetFrameMax() - firstFrameUsed - 0.5f + 2.f) * framePixelWidth, float(ItemHeight)));\n               ImRect clippingRect(rp + ImVec2(float(legendWidth), float(0.f)), rp + ImVec2(canvas_size.x, float(ItemHeight)));\n\n               compactCustomDraws.push_back({ i, customRect, ImRect(), clippingRect, ImRect() });\n            }\n            customHeight += localCustomHeight;\n         }\n\n\n         // moving\n         if (/*backgroundRect.Contains(io.MousePos) && */movingEntry >= 0)\n         {\n#if IMGUI_VERSION_NUM >= 18723\n            ImGui::SetNextFrameWantCaptureMouse(true);\n#else\n            ImGui::CaptureMouseFromApp();\n#endif\n            int diffFrame = int((cx - movingPos) / framePixelWidth);\n            if (std::abs(diffFrame) > 0)\n            {\n               int* start, * end;\n               sequence->Get(movingEntry, &start, &end, NULL, NULL);\n               if (selectedEntry)\n                  *selectedEntry = movingEntry;\n               int& l = *start;\n               int& r = *end;\n               if (movingPart & 1)\n                  l += diffFrame;\n               if (movingPart & 2)\n                  r += diffFrame;\n               if (l < 0)\n               {\n                  if (movingPart & 2)\n                     r -= l;\n                  l = 0;\n               }\n               if (movingPart & 1 && l > r)\n                  l = r;\n               if (movingPart & 2 && r < l)\n                  r = l;\n               movingPos += int(diffFrame * framePixelWidth);\n            }\n            if (!io.MouseDown[0])\n            {\n               // single select\n               if (!diffFrame && movingPart && selectedEntry)\n               {\n                  *selectedEntry = movingEntry;\n                  ret = true;\n               }\n\n               movingEntry = -1;\n               sequence->EndEdit();\n            }\n         }\n\n         // cursor\n         if (currentFrame && firstFrame && *currentFrame >= *firstFrame && *currentFrame <= sequence->GetFrameMax())\n         {\n            static const float cursorWidth = 8.f;\n            float cursorOffset = contentMin.x + legendWidth + (*currentFrame - firstFrameUsed) * framePixelWidth + framePixelWidth / 2 - cursorWidth * 0.5f;\n            draw_list->AddLine(ImVec2(cursorOffset, canvas_pos.y), ImVec2(cursorOffset, contentMax.y), 0xA02A2AFF, cursorWidth);\n            char tmps[512];\n            ImFormatString(tmps, IM_ARRAYSIZE(tmps), \"%d\", *currentFrame);\n            draw_list->AddText(ImVec2(cursorOffset + 10, canvas_pos.y + 2), 0xFF2A2AFF, tmps);\n         }\n\n         draw_list->PopClipRect();\n         draw_list->PopClipRect();\n\n         for (auto& customDraw : customDraws)\n            sequence->CustomDraw(customDraw.index, draw_list, customDraw.customRect, customDraw.legendRect, customDraw.clippingRect, customDraw.legendClippingRect);\n         for (auto& customDraw : compactCustomDraws)\n            sequence->CustomDrawCompact(customDraw.index, draw_list, customDraw.customRect, customDraw.clippingRect);\n\n         // copy paste\n         if (sequenceOptions & SEQUENCER_COPYPASTE)\n         {\n            ImRect rectCopy(ImVec2(contentMin.x + 100, canvas_pos.y + 2)\n               , ImVec2(contentMin.x + 100 + 30, canvas_pos.y + ItemHeight - 2));\n            bool inRectCopy = rectCopy.Contains(io.MousePos);\n            unsigned int copyColor = inRectCopy ? 0xFF1080FF : 0xFF000000;\n            draw_list->AddText(rectCopy.Min, copyColor, \"Copy\");\n\n            ImRect rectPaste(ImVec2(contentMin.x + 140, canvas_pos.y + 2)\n               , ImVec2(contentMin.x + 140 + 30, canvas_pos.y + ItemHeight - 2));\n            bool inRectPaste = rectPaste.Contains(io.MousePos);\n            unsigned int pasteColor = inRectPaste ? 0xFF1080FF : 0xFF000000;\n            draw_list->AddText(rectPaste.Min, pasteColor, \"Paste\");\n\n            if (inRectCopy && io.MouseReleased[0])\n            {\n               sequence->Copy();\n            }\n            if (inRectPaste && io.MouseReleased[0])\n            {\n               sequence->Paste();\n            }\n         }\n         //\n\n         ImGui::EndChild();\n         ImGui::PopStyleColor();\n         if (hasScrollBar)\n         {\n            ImGui::InvisibleButton(\"scrollBar\", scrollBarSize);\n            ImVec2 scrollBarMin = ImGui::GetItemRectMin();\n            ImVec2 scrollBarMax = ImGui::GetItemRectMax();\n\n            // ratio = number of frames visible in control / number to total frames\n\n            float startFrameOffset = ((float)(firstFrameUsed - sequence->GetFrameMin()) / (float)frameCount) * (canvas_size.x - legendWidth);\n            ImVec2 scrollBarA(scrollBarMin.x + legendWidth, scrollBarMin.y - 2);\n            ImVec2 scrollBarB(scrollBarMin.x + canvas_size.x, scrollBarMax.y - 1);\n            draw_list->AddRectFilled(scrollBarA, scrollBarB, 0xFF222222, 0);\n\n            ImRect scrollBarRect(scrollBarA, scrollBarB);\n            bool inScrollBar = scrollBarRect.Contains(io.MousePos);\n\n            draw_list->AddRectFilled(scrollBarA, scrollBarB, 0xFF101010, 8);\n\n\n            ImVec2 scrollBarC(scrollBarMin.x + legendWidth + startFrameOffset, scrollBarMin.y);\n            ImVec2 scrollBarD(scrollBarMin.x + legendWidth + barWidthInPixels + startFrameOffset, scrollBarMax.y - 2);\n            draw_list->AddRectFilled(scrollBarC, scrollBarD, (inScrollBar || MovingScrollBar) ? 0xFF606060 : 0xFF505050, 6);\n\n            ImRect barHandleLeft(scrollBarC, ImVec2(scrollBarC.x + 14, scrollBarD.y));\n            ImRect barHandleRight(ImVec2(scrollBarD.x - 14, scrollBarC.y), scrollBarD);\n\n            bool onLeft = barHandleLeft.Contains(io.MousePos);\n            bool onRight = barHandleRight.Contains(io.MousePos);\n\n            static bool sizingRBar = false;\n            static bool sizingLBar = false;\n\n            draw_list->AddRectFilled(barHandleLeft.Min, barHandleLeft.Max, (onLeft || sizingLBar) ? 0xFFAAAAAA : 0xFF666666, 6);\n            draw_list->AddRectFilled(barHandleRight.Min, barHandleRight.Max, (onRight || sizingRBar) ? 0xFFAAAAAA : 0xFF666666, 6);\n\n            ImRect scrollBarThumb(scrollBarC, scrollBarD);\n            static const float MinBarWidth = 44.f;\n            if (sizingRBar)\n            {\n               if (!io.MouseDown[0])\n               {\n                  sizingRBar = false;\n               }\n               else\n               {\n                  float barNewWidth = ImMax(barWidthInPixels + io.MouseDelta.x, MinBarWidth);\n                  float barRatio = barNewWidth / barWidthInPixels;\n                  framePixelWidthTarget = framePixelWidth = framePixelWidth / barRatio;\n                  int newVisibleFrameCount = int((canvas_size.x - legendWidth) / framePixelWidthTarget);\n                  int lastFrame = *firstFrame + newVisibleFrameCount;\n                  if (lastFrame > sequence->GetFrameMax())\n                  {\n                     framePixelWidthTarget = framePixelWidth = (canvas_size.x - legendWidth) / float(sequence->GetFrameMax() - *firstFrame);\n                  }\n               }\n            }\n            else if (sizingLBar)\n            {\n               if (!io.MouseDown[0])\n               {\n                  sizingLBar = false;\n               }\n               else\n               {\n                  if (fabsf(io.MouseDelta.x) > FLT_EPSILON)\n                  {\n                     float barNewWidth = ImMax(barWidthInPixels - io.MouseDelta.x, MinBarWidth);\n                     float barRatio = barNewWidth / barWidthInPixels;\n                     float previousFramePixelWidthTarget = framePixelWidthTarget;\n                     framePixelWidthTarget = framePixelWidth = framePixelWidth / barRatio;\n                     int newVisibleFrameCount = int(visibleFrameCount / barRatio);\n                     int newFirstFrame = *firstFrame + newVisibleFrameCount - visibleFrameCount;\n                     newFirstFrame = ImClamp(newFirstFrame, sequence->GetFrameMin(), ImMax(sequence->GetFrameMax() - visibleFrameCount, sequence->GetFrameMin()));\n                     if (newFirstFrame == *firstFrame)\n                     {\n                        framePixelWidth = framePixelWidthTarget = previousFramePixelWidthTarget;\n                     }\n                     else\n                     {\n                        *firstFrame = newFirstFrame;\n                     }\n                  }\n               }\n            }\n            else\n            {\n               if (MovingScrollBar)\n               {\n                  if (!io.MouseDown[0])\n                  {\n                     MovingScrollBar = false;\n                  }\n                  else\n                  {\n                     float framesPerPixelInBar = barWidthInPixels / (float)visibleFrameCount;\n                     *firstFrame = int((io.MousePos.x - panningViewSource.x) / framesPerPixelInBar) - panningViewFrame;\n                     *firstFrame = ImClamp(*firstFrame, sequence->GetFrameMin(), ImMax(sequence->GetFrameMax() - visibleFrameCount, sequence->GetFrameMin()));\n                  }\n               }\n               else\n               {\n                  if (scrollBarThumb.Contains(io.MousePos) && ImGui::IsMouseClicked(0) && firstFrame && !MovingCurrentFrame && movingEntry == -1)\n                  {\n                     MovingScrollBar = true;\n                     panningViewSource = io.MousePos;\n                     panningViewFrame = -*firstFrame;\n                  }\n                  if (!sizingRBar && onRight && ImGui::IsMouseClicked(0))\n                     sizingRBar = true;\n                  if (!sizingLBar && onLeft && ImGui::IsMouseClicked(0))\n                     sizingLBar = true;\n\n               }\n            }\n         }\n      }\n\n      ImGui::EndGroup();\n\n      if (regionRect.Contains(io.MousePos))\n      {\n         bool overCustomDraw = false;\n         for (auto& custom : customDraws)\n         {\n            if (custom.customRect.Contains(io.MousePos))\n            {\n               overCustomDraw = true;\n            }\n         }\n         if (overCustomDraw)\n         {\n         }\n         else\n         {\n#if 0\n            frameOverCursor = *firstFrame + (int)(visibleFrameCount * ((io.MousePos.x - (float)legendWidth - canvas_pos.x) / (canvas_size.x - legendWidth)));\n            //frameOverCursor = max(min(*firstFrame - visibleFrameCount / 2, frameCount - visibleFrameCount), 0);\n\n            /**firstFrame -= frameOverCursor;\n            *firstFrame *= framePixelWidthTarget / framePixelWidth;\n            *firstFrame += frameOverCursor;*/\n            if (io.MouseWheel < -FLT_EPSILON)\n            {\n               *firstFrame -= frameOverCursor;\n               *firstFrame = int(*firstFrame * 1.1f);\n               framePixelWidthTarget *= 0.9f;\n               *firstFrame += frameOverCursor;\n            }\n\n            if (io.MouseWheel > FLT_EPSILON)\n            {\n               *firstFrame -= frameOverCursor;\n               *firstFrame = int(*firstFrame * 0.9f);\n               framePixelWidthTarget *= 1.1f;\n               *firstFrame += frameOverCursor;\n            }\n#endif\n         }\n      }\n\n      if (expanded)\n      {\n         if (SequencerAddDelButton(draw_list, ImVec2(canvas_pos.x + 2, canvas_pos.y + 2), !*expanded))\n            *expanded = !*expanded;\n      }\n\n      if (delEntry != -1)\n      {\n         sequence->Del(delEntry);\n         if (selectedEntry && (*selectedEntry == delEntry || *selectedEntry >= sequence->GetItemCount()))\n            *selectedEntry = -1;\n      }\n\n      if (dupEntry != -1)\n      {\n         sequence->Duplicate(dupEntry);\n      }\n      return ret;\n   }\n}\n"
        },
        {
          "name": "ImSequencer.h",
          "type": "blob",
          "size": 3.08984375,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#pragma once\n\n#include <cstddef>\n\nstruct ImDrawList;\nstruct ImRect;\nnamespace ImSequencer\n{\n   enum SEQUENCER_OPTIONS\n   {\n      SEQUENCER_EDIT_NONE = 0,\n      SEQUENCER_EDIT_STARTEND = 1 << 1,\n      SEQUENCER_CHANGE_FRAME = 1 << 3,\n      SEQUENCER_ADD = 1 << 4,\n      SEQUENCER_DEL = 1 << 5,\n      SEQUENCER_COPYPASTE = 1 << 6,\n      SEQUENCER_EDIT_ALL = SEQUENCER_EDIT_STARTEND | SEQUENCER_CHANGE_FRAME\n   };\n\n   struct SequenceInterface\n   {\n      bool focused = false;\n      virtual int GetFrameMin() const = 0;\n      virtual int GetFrameMax() const = 0;\n      virtual int GetItemCount() const = 0;\n\n      virtual void BeginEdit(int /*index*/) {}\n      virtual void EndEdit() {}\n      virtual int GetItemTypeCount() const { return 0; }\n      virtual const char* GetItemTypeName(int /*typeIndex*/) const { return \"\"; }\n      virtual const char* GetItemLabel(int /*index*/) const { return \"\"; }\n      virtual const char* GetCollapseFmt() const { return \"%d Frames / %d entries\"; }\n\n      virtual void Get(int index, int** start, int** end, int* type, unsigned int* color) = 0;\n      virtual void Add(int /*type*/) {}\n      virtual void Del(int /*index*/) {}\n      virtual void Duplicate(int /*index*/) {}\n\n      virtual void Copy() {}\n      virtual void Paste() {}\n\n      virtual size_t GetCustomHeight(int /*index*/) { return 0; }\n      virtual void DoubleClick(int /*index*/) {}\n      virtual void CustomDraw(int /*index*/, ImDrawList* /*draw_list*/, const ImRect& /*rc*/, const ImRect& /*legendRect*/, const ImRect& /*clippingRect*/, const ImRect& /*legendClippingRect*/) {}\n      virtual void CustomDrawCompact(int /*index*/, ImDrawList* /*draw_list*/, const ImRect& /*rc*/, const ImRect& /*clippingRect*/) {}\n\n       virtual ~SequenceInterface() = default;\n   };\n\n\n   // return true if selection is made\n   bool Sequencer(SequenceInterface* sequence, int* currentFrame, bool* expanded, int* selectedEntry, int* firstFrame, int sequenceOptions);\n\n}\n"
        },
        {
          "name": "ImZoomSlider.h",
          "type": "blob",
          "size": 10.1962890625,
          "content": "// https://github.com/CedricGuillemet/ImGuizmo\n// v1.91.3 WIP\n//\n// The MIT License(MIT)\n//\n// Copyright(c) 2021 Cedric Guillemet\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n#pragma once\n\nnamespace ImZoomSlider\n{\n   typedef int ImGuiZoomSliderFlags;\n   enum ImGuiPopupFlags_\n   {\n      ImGuiZoomSliderFlags_None = 0,\n      ImGuiZoomSliderFlags_Vertical = 1,\n      ImGuiZoomSliderFlags_NoAnchors = 2,\n      ImGuiZoomSliderFlags_NoMiddleCarets = 4,\n      ImGuiZoomSliderFlags_NoWheel = 8,\n   };\n\n   template<typename T> bool ImZoomSlider(const T lower, const T higher, T& viewLower, T& viewHigher, float wheelRatio = 0.01f, ImGuiZoomSliderFlags flags = ImGuiZoomSliderFlags_None)\n   {\n      bool interacted = false;\n      ImGuiIO& io = ImGui::GetIO();\n      ImDrawList* draw_list = ImGui::GetWindowDrawList();\n\n      static const float handleSize = 12;\n      static const float roundRadius = 3.f;\n      static const char* controlName = \"ImZoomSlider\";\n\n      static bool movingScrollBarSvg = false;\n      static bool sizingRBarSvg = false;\n      static bool sizingLBarSvg = false;\n      static ImGuiID editingId = (ImGuiID)-1;\n      static float scrollingSource = 0.f;\n      static float saveViewLower;\n      static float saveViewHigher;\n\n      const bool isVertical = flags & ImGuiZoomSliderFlags_Vertical;\n      const ImVec2 canvasPos = ImGui::GetCursorScreenPos();\n      const ImVec2 canvasSize = ImGui::GetContentRegionAvail();\n      const float canvasSizeLength = isVertical ? ImGui::GetItemRectSize().y : canvasSize.x;\n      const ImVec2 scrollBarSize = isVertical ? ImVec2(14.f, canvasSizeLength) : ImVec2(canvasSizeLength, 14.f);\n\n      ImGui::InvisibleButton(controlName, scrollBarSize);\n      const ImGuiID currentId = ImGui::GetID(controlName);\n\n      const bool usingEditingId = currentId == editingId;\n      const bool canUseControl = usingEditingId || editingId == -1;\n      const bool movingScrollBar = usingEditingId ? movingScrollBarSvg : false;\n      const bool sizingRBar = usingEditingId ? sizingRBarSvg : false;\n      const bool sizingLBar = usingEditingId ? sizingLBarSvg : false;\n      const int componentIndex = isVertical ? 1 : 0;\n      const ImVec2 scrollBarMin = ImGui::GetItemRectMin();\n      const ImVec2 scrollBarMax = ImGui::GetItemRectMax();\n      const ImVec2 scrollBarA = ImVec2(scrollBarMin.x, scrollBarMin.y) - (isVertical ? ImVec2(2,0) : ImVec2(0,2));\n      const ImVec2 scrollBarB = isVertical ? ImVec2(scrollBarMax.x - 1.f, scrollBarMin.y + canvasSizeLength) : ImVec2(scrollBarMin.x + canvasSizeLength, scrollBarMax.y - 1.f);\n      const float scrollStart = ((viewLower - lower) / (higher - lower)) * canvasSizeLength + scrollBarMin[componentIndex];\n      const float scrollEnd = ((viewHigher - lower) / (higher - lower)) * canvasSizeLength + scrollBarMin[componentIndex];\n      const float screenSize = scrollEnd - scrollStart;\n      const ImVec2 scrollTopLeft = isVertical ? ImVec2(scrollBarMin.x, scrollStart) : ImVec2(scrollStart, scrollBarMin.y);\n      const ImVec2 scrollBottomRight = isVertical ? ImVec2(scrollBarMax.x - 2.f, scrollEnd) : ImVec2(scrollEnd, scrollBarMax.y - 2.f);\n      const bool inScrollBar = canUseControl && ImRect(scrollTopLeft, scrollBottomRight).Contains(io.MousePos);\n      const ImRect scrollBarRect(scrollBarA, scrollBarB);\n      const float deltaScreen = io.MousePos[componentIndex] - scrollingSource;\n      const float deltaView = ((higher - lower) / canvasSizeLength) * deltaScreen;\n      const uint32_t barColor = ImGui::GetColorU32((inScrollBar || movingScrollBar) ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\n      const float middleCoord = (scrollStart + scrollEnd) * 0.5f;\n      const bool insideControl = canUseControl && ImRect(scrollBarMin, scrollBarMax).Contains(io.MousePos);\n      const bool hasAnchors = !(flags & ImGuiZoomSliderFlags_NoAnchors);\n      const float viewMinSize = ((3.f * handleSize) / canvasSizeLength) * (higher - lower);\n      const auto ClipView = [lower, higher, &viewLower, &viewHigher]() {\n         if (viewLower < lower)\n         {\n            const float deltaClip = lower - viewLower;\n            viewLower += deltaClip;\n            viewHigher += deltaClip;\n         }\n         if (viewHigher > higher)\n         {\n            const float deltaClip = viewHigher - higher;\n            viewLower -= deltaClip;\n            viewHigher -= deltaClip;\n         }\n      };\n\n      bool onLeft = false;\n      bool onRight = false;\n\n      draw_list->AddRectFilled(scrollBarA, scrollBarB, 0xFF101010, roundRadius);\n      draw_list->AddRectFilled(scrollBarA, scrollBarB, 0xFF222222, 0);\n      draw_list->AddRectFilled(scrollTopLeft, scrollBottomRight, barColor, roundRadius);\n\n      if (!(flags & ImGuiZoomSliderFlags_NoMiddleCarets))\n      {\n         for (float i = 0.5f; i < 3.f; i += 1.f)\n         {\n            const float coordA = middleCoord - handleSize * 0.5f;\n            const float coordB = middleCoord + handleSize * 0.5f;\n            ImVec2 base = scrollBarMin;\n            base.x += scrollBarSize.x * 0.25f * i;\n            base.y += scrollBarSize.y * 0.25f * i;\n\n            if (isVertical)\n            {\n               draw_list->AddLine(ImVec2(base.x, coordA), ImVec2(base.x, coordB), ImGui::GetColorU32(ImGuiCol_SliderGrab));\n            }\n            else\n            {\n               draw_list->AddLine(ImVec2(coordA, base.y), ImVec2(coordB, base.y), ImGui::GetColorU32(ImGuiCol_SliderGrab));\n            }\n         }\n      }\n\n      // Mouse wheel\n      if (io.MouseClicked[0] && insideControl && !inScrollBar)\n      {\n         const float ratio = (io.MousePos[componentIndex] - scrollBarMin[componentIndex]) / (scrollBarMax[componentIndex] - scrollBarMin[componentIndex]);\n         const float size = (higher - lower);\n         const float halfViewSize = (viewHigher - viewLower) * 0.5f;\n         const float middle = ratio * size + lower;\n         viewLower = middle - halfViewSize;\n         viewHigher = middle + halfViewSize;\n         ClipView();\n         interacted = true;\n      }\n\n      if (!(flags & ImGuiZoomSliderFlags_NoWheel) && inScrollBar && fabsf(io.MouseWheel) > 0.f)\n      {\n         const float ratio = (io.MousePos[componentIndex] - scrollStart) / (scrollEnd - scrollStart);\n         const float amount = io.MouseWheel * wheelRatio * (viewHigher - viewLower);\n         \n         viewLower -= ratio * amount;\n         viewHigher += (1.f - ratio) * amount;\n         ClipView();\n         interacted = true;\n      }\n\n      if (screenSize > handleSize * 2.f && hasAnchors)\n      {\n         const ImRect barHandleLeft(scrollTopLeft, isVertical ? ImVec2(scrollBottomRight.x, scrollTopLeft.y + handleSize) : ImVec2(scrollTopLeft.x + handleSize, scrollBottomRight.y));\n         const ImRect barHandleRight(isVertical ? ImVec2(scrollTopLeft.x, scrollBottomRight.y - handleSize) : ImVec2(scrollBottomRight.x - handleSize, scrollTopLeft.y), scrollBottomRight);\n\n         onLeft = barHandleLeft.Contains(io.MousePos);\n         onRight = barHandleRight.Contains(io.MousePos);\n\n         draw_list->AddRectFilled(barHandleLeft.Min, barHandleLeft.Max, ImGui::GetColorU32((onLeft || sizingLBar) ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), roundRadius);\n         draw_list->AddRectFilled(barHandleRight.Min, barHandleRight.Max, ImGui::GetColorU32((onRight || sizingRBar) ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), roundRadius);\n      }\n\n      if (sizingRBar)\n      {\n         if (!io.MouseDown[0])\n         {\n            sizingRBarSvg = false;\n            editingId = (ImGuiID)-1;\n         }\n         else\n         {\n            viewHigher = ImMin(saveViewHigher + deltaView, higher);\n         }\n      }\n      else if (sizingLBar)\n      {\n         if (!io.MouseDown[0])\n         {\n            sizingLBarSvg = false;\n            editingId = (ImGuiID)-1;\n         }\n         else\n         {\n            viewLower = ImMax(saveViewLower + deltaView, lower);\n         }\n      }\n      else\n      {\n         if (movingScrollBar)\n         {\n            if (!io.MouseDown[0])\n            {\n               movingScrollBarSvg = false;\n               editingId = (ImGuiID)-1;\n            }\n            else\n            {\n               viewLower = saveViewLower + deltaView;\n               viewHigher = saveViewHigher + deltaView;\n               ClipView();\n            }\n         }\n         else\n         {\n            if (inScrollBar && ImGui::IsMouseClicked(0))\n            {\n               movingScrollBarSvg = true;\n               scrollingSource = io.MousePos[componentIndex];\n               saveViewLower = viewLower;\n               saveViewHigher = viewHigher;\n               editingId = currentId;\n            }\n            if (!sizingRBar && onRight && ImGui::IsMouseClicked(0) && hasAnchors)\n            {\n               sizingRBarSvg = true;\n               editingId = currentId;\n            }\n            if (!sizingLBar && onLeft && ImGui::IsMouseClicked(0) && hasAnchors)\n            {\n               sizingLBarSvg = true;\n               editingId = currentId;\n            }\n         }\n      }\n\n      // minimal size check\n      if ((viewHigher - viewLower) < viewMinSize)\n      {\n         const float middle = (viewLower + viewHigher) * 0.5f;\n         viewLower = middle - viewMinSize * 0.5f;\n         viewHigher = middle + viewMinSize * 0.5f;\n         ClipView();\n      }\n\n      return movingScrollBar || sizingRBar || sizingLBar || interacted;\n   }\n\n} // namespace\n"
        },
        {
          "name": "Images",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Cedric Guillemet\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5283203125,
          "content": "CXXFLAGS=-std=c++11\nCPPFLAGS=-I. -Iexample\n\nLIB_OBJS = ImGuizmo.o GraphEditor.o ImCurveEdit.o ImGradient.o ImSequencer.o\nEXAMPLE_OBJS = example/imgui.o example/imgui_draw.o example/imgui_tables.o example/imgui_widgets.o example/main.o\n\nEXAMPLE_NAME = example.exe\nLDFLAGS=-mwindows -static-libgcc -static-libstdc++\nLIBS=-limm32 -lopengl32 -lgdi32\n\n$(EXAMPLE_NAME): $(LIB_OBJS) $(EXAMPLE_OBJS)\n\t$(CXX) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nexample/main.o: CXXFLAGS := -std=c++17\n\nclean:\n\t$(RM) $(LIB_OBJS)\n\t$(RM) $(EXAMPLE_OBJS)\n\t$(RM) $(EXAMPLE_NAME)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.283203125,
          "content": "# ImGuizmo\n\nLatest stable tagged version is 1.83. Current master version is 1.84 WIP.\n\nWhat started with the gizmo is now a collection of dear imgui widgets and more advanced controls.\n\n## Guizmos\n\n### ImViewGizmo\n\nManipulate view orientation with 1 single line of code\n\n![Image of ImViewGizmo](http://i.imgur.com/7UVcyDd.gif)\n\n### ImGuizmo\n\nImGizmo is a small (.h and .cpp) library built ontop of Dear ImGui that allow you to manipulate(Rotate & translate at the moment) 4x4 float matrices. No other dependancies. Coded with Immediate Mode (IM) philosophy in mind.\n\nBuilt against DearImgui 1.53WIP\n\n![Image of Rotation](http://i.imgur.com/y4mcVoT.gif)\n![Image of Translation](http://i.imgur.com/o8q8iHq.gif)\n![Image of Bounds](http://i.imgur.com/3Ez5LBr.gif)\n\nThere is now a sample for Win32/OpenGL ! With a binary in bin directory.\n![Image of Sample](https://i.imgur.com/nXlzyqD.png)\n\n### ImSequencer\n\nA WIP little sequencer used to edit frame start/end for different events in a timeline.\n![Image of Rotation](http://i.imgur.com/BeyNwCn.png)\nCheck the sample for the documentation. More to come...\n\n### Graph Editor\n\nNodes + connections. Custom draw inside nodes is possible with the delegate system in place.\n![Image of GraphEditor](Images/nodeeditor.jpg)\n\n### API doc\n\nCall BeginFrame right after ImGui_XXXX_NewFrame();\n\n```C++\nvoid BeginFrame();\n```\n\nreturn true if mouse cursor is over any gizmo control (axis, plan or screen component)\n\n```C++\nbool IsOver();**\n```\n\nreturn true if mouse IsOver or if the gizmo is in moving state\n\n```C++\nbool IsUsing();**\n```\n\nenable/disable the gizmo. Stay in the state until next call to Enable. gizmo is rendered with gray half transparent color when disabled\n\n```C++\nvoid Enable(bool enable);**\n```\n\nhelper functions for manualy editing translation/rotation/scale with an input float\ntranslation, rotation and scale float points to 3 floats each\nAngles are in degrees (more suitable for human editing)\nexample:\n\n```C++\n float matrixTranslation[3], matrixRotation[3], matrixScale[3];\n ImGuizmo::DecomposeMatrixToComponents(gizmoMatrix.m16, matrixTranslation, matrixRotation, matrixScale);\n ImGui::InputFloat3(\"Tr\", matrixTranslation, 3);\n ImGui::InputFloat3(\"Rt\", matrixRotation, 3);\n ImGui::InputFloat3(\"Sc\", matrixScale, 3);\n ImGuizmo::RecomposeMatrixFromComponents(matrixTranslation, matrixRotation, matrixScale, gizmoMatrix.m16);\n```\n\nThese functions have some numerical stability issues for now. Use with caution.\n\n```C++\nvoid DecomposeMatrixToComponents(const float *matrix, float *translation, float *rotation, float *scale);\nvoid RecomposeMatrixFromComponents(const float *translation, const float *rotation, const float *scale, float *matrix);**\n```\n\nRender a cube with face color corresponding to face normal. Usefull for debug/test\n\n```C++\nvoid DrawCube(const float *view, const float *projection, float *matrix);**\n```\n\nCall it when you want a gizmo\nNeeds view and projection matrices.\nMatrix parameter is the source matrix (where will be gizmo be drawn) and might be transformed by the function. Return deltaMatrix is optional. snap points to a float[3] for translation and to a single float for scale or rotation. Snap angle is in Euler Degrees.\n\n```C++\n    enum OPERATION\n    {\n        TRANSLATE,\n        ROTATE,\n        SCALE\n    };\n\n    enum MODE\n    {\n        LOCAL,\n        WORLD\n    };\n\nvoid Manipulate(const float *view, const float *projection, OPERATION operation, MODE mode, float *matrix, float *deltaMatrix = 0, float *snap = 0);**\n```\n\n### ImGui Example\n\nCode for :\n\n![Image of dialog](http://i.imgur.com/GL5flN1.png)\n\n```C++\nvoid EditTransform(const Camera& camera, matrix_t& matrix)\n{\n    static ImGuizmo::OPERATION mCurrentGizmoOperation(ImGuizmo::ROTATE);\n    static ImGuizmo::MODE mCurrentGizmoMode(ImGuizmo::WORLD);\n    if (ImGui::IsKeyPressed(90))\n        mCurrentGizmoOperation = ImGuizmo::TRANSLATE;\n    if (ImGui::IsKeyPressed(69))\n        mCurrentGizmoOperation = ImGuizmo::ROTATE;\n    if (ImGui::IsKeyPressed(82)) // r Key\n        mCurrentGizmoOperation = ImGuizmo::SCALE;\n    if (ImGui::RadioButton(\"Translate\", mCurrentGizmoOperation == ImGuizmo::TRANSLATE))\n        mCurrentGizmoOperation = ImGuizmo::TRANSLATE;\n    ImGui::SameLine();\n    if (ImGui::RadioButton(\"Rotate\", mCurrentGizmoOperation == ImGuizmo::ROTATE))\n        mCurrentGizmoOperation = ImGuizmo::ROTATE;\n    ImGui::SameLine();\n    if (ImGui::RadioButton(\"Scale\", mCurrentGizmoOperation == ImGuizmo::SCALE))\n        mCurrentGizmoOperation = ImGuizmo::SCALE;\n    float matrixTranslation[3], matrixRotation[3], matrixScale[3];\n    ImGuizmo::DecomposeMatrixToComponents(matrix.m16, matrixTranslation, matrixRotation, matrixScale);\n    ImGui::InputFloat3(\"Tr\", matrixTranslation, 3);\n    ImGui::InputFloat3(\"Rt\", matrixRotation, 3);\n    ImGui::InputFloat3(\"Sc\", matrixScale, 3);\n    ImGuizmo::RecomposeMatrixFromComponents(matrixTranslation, matrixRotation, matrixScale, matrix.m16);\n\n    if (mCurrentGizmoOperation != ImGuizmo::SCALE)\n    {\n        if (ImGui::RadioButton(\"Local\", mCurrentGizmoMode == ImGuizmo::LOCAL))\n            mCurrentGizmoMode = ImGuizmo::LOCAL;\n        ImGui::SameLine();\n        if (ImGui::RadioButton(\"World\", mCurrentGizmoMode == ImGuizmo::WORLD))\n            mCurrentGizmoMode = ImGuizmo::WORLD;\n    }\n    static bool useSnap(false);\n    if (ImGui::IsKeyPressed(83))\n        useSnap = !useSnap;\n    ImGui::Checkbox(\"\", &useSnap);\n    ImGui::SameLine();\n    vec_t snap;\n    switch (mCurrentGizmoOperation)\n    {\n    case ImGuizmo::TRANSLATE:\n        snap = config.mSnapTranslation;\n        ImGui::InputFloat3(\"Snap\", &snap.x);\n        break;\n    case ImGuizmo::ROTATE:\n        snap = config.mSnapRotation;\n        ImGui::InputFloat(\"Angle Snap\", &snap.x);\n        break;\n    case ImGuizmo::SCALE:\n        snap = config.mSnapScale;\n        ImGui::InputFloat(\"Scale Snap\", &snap.x);\n        break;\n    }\n    ImGuiIO& io = ImGui::GetIO();\n    ImGuizmo::SetRect(0, 0, io.DisplaySize.x, io.DisplaySize.y);\n    ImGuizmo::Manipulate(camera.mView.m16, camera.mProjection.m16, mCurrentGizmoOperation, mCurrentGizmoMode, matrix.m16, NULL, useSnap ? &snap.x : NULL);\n}\n```\n\n## Install\n\nImGuizmo can be installed via [vcpkg](https://github.com/microsoft/vcpkg) and used cmake\n\n```bash\nvcpkg install imguizmo\n```\n\nSee the [vcpkg example](/vcpkg-example) for more details\n\n## License\n\nImGuizmo is licensed under the MIT License, see [LICENSE](/LICENSE) for more information.\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "vcpkg-example",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}