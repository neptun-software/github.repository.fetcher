{
  "metadata": {
    "timestamp": 1736565200958,
    "page": 4,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "epezent/implot",
      "stars": 4985,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2020 Evan Pezent\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0224609375,
          "content": "# ImPlot\nImPlot is an immediate mode, GPU accelerated plotting library for [Dear ImGui](https://github.com/ocornut/imgui). It aims to provide a first-class API that ImGui fans will love. ImPlot is well suited for visualizing program data in real-time or creating interactive plots, and requires minimal code to integrate. Just like ImGui, it does not burden the end user with GUI state management, avoids STL containers and C++ headers, and has no external dependencies except for ImGui itself.\n\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/controls.gif\" width=\"270\"> <img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/dnd.gif\" width=\"270\"> <img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/pie.gif\" width=\"270\">\n\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/query.gif\" width=\"270\"> <img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/bars.gif\" width=\"270\">\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/rt.gif\" width=\"270\">\n\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/stem.gif\" width=\"270\"> <img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/markers.gif\" width=\"270\">\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/shaded.gif\" width=\"270\">\n\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/candle.gif\" width=\"270\"> <img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/heat.gif\" width=\"270\">\n<img src=\"https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/tables.gif\" width=\"270\">\n\n## Features\n\n- GPU accelerated rendering\n- multiple plot types:\n    - line plots\n    - shaded plots\n    - scatter plots\n    - vertical/horizontal/stacked bars graphs\n    - vertical/horizontal error bars\n    - stem plots\n    - stair plots\n    - pie charts\n    - heatmap charts\n    - 1D/2D histograms\n    - images\n    - and more likely to come\n- mix/match multiple plot items on a single plot\n- configurable axes ranges and scaling (linear/log)\n- subplots\n- time formatted x-axes (US formatted or ISO 8601)\n- reversible and lockable axes\n- multiple x-axes and y-axes\n- controls for zooming, panning, box selection, and auto-fitting data\n- controls for creating persistent query ranges (see demo)\n- several plot styling options: 10 marker types, adjustable marker sizes, line weights, outline colors, fill colors, etc.\n- 16 built-in colormaps and support for and user-added colormaps\n- optional plot titles, axis labels, and grid labels\n- optional and configurable legends with toggle buttons to quickly show/hide plot items\n- default styling based on current ImGui theme, or completely custom plot styles\n- customizable data getters and data striding (just like ImGui:PlotLine)\n- accepts data as float, double, and 8, 16, 32, and 64-bit signed/unsigned integral types\n- and more! (see Announcements [2022](https://github.com/epezent/implot/discussions/370)/[2021](https://github.com/epezent/implot/issues/168)/[2020](https://github.com/epezent/implot/issues/48))\n\n## Usage\n\nThe API is used just like any other ImGui `BeginX`/`EndX` pair. First, start a new plot with `ImPlot::BeginPlot()`. Next, plot as many items as you want with the provided `PlotX` functions (e.g. `PlotLine()`, `PlotBars()`, `PlotScatter()`, etc). Finally, wrap things up with a call to `ImPlot::EndPlot()`. That's it!\n\n```cpp\nint   bar_data[11] = ...;\nfloat x_data[1000] = ...;\nfloat y_data[1000] = ...;\n\nImGui::Begin(\"My Window\");\nif (ImPlot::BeginPlot(\"My Plot\")) {\n    ImPlot::PlotBars(\"My Bar Plot\", bar_data, 11);\n    ImPlot::PlotLine(\"My Line Plot\", x_data, y_data, 1000);\n    ...\n    ImPlot::EndPlot();\n}\nImGui::End();\n```\n\n![Usage](https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/example.PNG)\n\n\nOf course, there's much more you can do with ImPlot...\n\n## Demos\n\nA comprehensive example of ImPlot's features can be found in `implot_demo.cpp`. Add this file to your sources and call `ImPlot::ShowDemoWindow()` somewhere in your update loop. You are encouraged to use this file as a reference when needing to implement various plot types. The demo is always updated to show new plot types and features as they are added, so check back with each release!\n\nAn online version of the demo is hosted [here](https://traineq.org/implot_demo/src/implot_demo.html). You can view the plots and the source code that generated them. Note that this demo may not always be up to date and is not as performant as a desktop implementation, but it should give you a general taste of what's possible with ImPlot. Special thanks to [pthom](https://github.com/pthom) for creating and hosting this!\n\nMore sophisticated demos requiring lengthier code and/or third-party libraries can be found in a separate repository: [implot_demos](https://github.com/epezent/implot_demos). Here, you will find advanced signal processing and ImPlot usage in action. Please read the `Contributing` section of that repository if you have an idea for a new demo!\n\n## Integration\n\n0) Set up an [ImGui](https://github.com/ocornut/imgui) environment if you don't already have one.\n1) Add `implot.h`, `implot_internal.h`, `implot.cpp`, `implot_items.cpp` and optionally `implot_demo.cpp` to your sources. Alternatively, you can get ImPlot using [vcpkg](https://github.com/microsoft/vcpkg/tree/master/ports/implot).\n2) Create and destroy an `ImPlotContext` wherever you do so for your `ImGuiContext`:\n\n```cpp\nImGui::CreateContext();\nImPlot::CreateContext();\n...\nImPlot::DestroyContext();\nImGui::DestroyContext();\n```\n\nYou should be good to go!\n\n## Installing ImPlot using vcpkg\n\nYou can download and install ImPlot using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n```bash\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install implot\n```\n\nThe ImPlot port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n## Extremely Important Note\n\nDear ImGui uses **16-bit indexing by default**, so high-density ImPlot widgets like `ImPlot::PlotHeatmap()` may produce too many vertices into `ImDrawList`, which causes an assertion failure and will result in data truncation and/or visual glitches. Therefore, it is **HIGHLY** recommended that you EITHER:\n\n- **Option 1:** Enable 32-bit indices by uncommenting `#define ImDrawIdx unsigned int` in your ImGui [`imconfig.h`](https://github.com/ocornut/imgui/blob/master/imconfig.h#L89) file.\n- **Option 2:** Handle the `ImGuiBackendFlags_RendererHasVtxOffset` flag in your renderer if you must use 16-bit indices. Many of the default ImGui rendering backends already support `ImGuiBackendFlags_RendererHasVtxOffset`. Refer to [this issue](https://github.com/ocornut/imgui/issues/2591) for more information.\n\n## FAQ\n\n**Q: Why?**\n\nA: ImGui is an incredibly powerful tool for rapid prototyping and development, but provides only limited mechanisms for data visualization. Two dimensional plots are ubiquitous and useful to almost any application. Being able to visualize your data in real-time will give you insight and better understanding of your application.\n\n**Q: Is ImPlot the right plotting library for me?**\n\nA: If you're looking to generate publication quality plots and/or export plots to a file, ImPlot is NOT the library for you! ImPlot is geared toward plotting application data at realtime speeds with high levels of interactivity. ImPlot does its best to create pretty plots (indeed, there are quite a few styling options available), but it will always favor function over form.\n\n**Q: Where is the documentation?**\n\nA: The API is thoroughly commented in `implot.h`, and the demo in `implot_demo.cpp` should be more than enough to get you started. Also take a look at the [implot_demos](https://github.com/epezent/implot_demos) repository.\n\n**Q: Is ImPlot suitable for plotting large datasets?**\n\nA: Yes, within reason. You can plot tens to hundreds of thousands of points without issue, but don't expect millions to be a buttery smooth experience. That said, you can always downsample extremely large datasets by telling ImPlot to stride your data at larger intervals if needed. Also try the experimental `backends` branch which aims to provide GPU acceleration support.\n\n**Q: What data types can I plot?**\n\nA: ImPlot plotting functions accept most scalar types:\n`float`, `double`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`. Arrays of custom structs or classes (e.g. `Vector2f` or similar) are easily passed to ImPlot functions using the built-in striding features (see `implot.h` for documentation), and many plotters provide a \"getter\" overload which accepts data generating callbacks. You can fully customize the list of accepted types by defining `IMPLOT_CUSTOM_NUMERIC_TYPES` at compile time: see doc in `implot_items.cpp`.\n\n**Q: Can plot styles be modified?**\n\nA: Yes. Data colormaps and various styling colors and variables can be pushed/popped or modified permanently on startup. Three default styles are available, as well as an automatic style that attempts to match you ImGui style.\n\n**Q: Does ImPlot support logarithmic scaling or time formatting?**\n\nA: Yep! Both logscale and timescale are supported.\n\n**Q: Does ImPlot support multiple y-axes? x-axes?**\n\nA: Yes. Up to three x-axes and three y-axes can be enabled.\n\n**Q: Does ImPlot support [insert plot type]?**\n\nA: Maybe. Check the demo, gallery, or Announcements ([2020](https://github.com/epezent/implot/issues/48)/[2021](https://github.com/epezent/implot/issues/168))to see if your desired plot type is shown. If not, consider submitting an issue or better yet, a PR!\n\n**Q: Does ImPlot support 3D plots?**\n\nA: An experimental extension to ImPlot, [ImPlot3D](https://github.com/brenocq/implot3d), provides a similar API for plotting and interacting with 3D data. \n\n**Q: Does ImPlot provide analytic tools?**\n\nA: Not exactly, but it does give you the ability to query plot sub-ranges, with which you can process your data however you like.\n\n**Q: Can plots be exported/saved to image?**\n\nA: Not currently. Use your OS's screen capturing mechanisms if you need to capture a plot. ImPlot is not suitable for rendering publication quality plots; it is only intended to be used as a visualization tool. Post-process your data with MATLAB or matplotlib for these purposes.\n\n**Q: Why are my plot lines showing aliasing?**\n\nA: You probably need to enable `ImGuiStyle::AntiAliasedLinesUseTex` (or possibly `ImGuiStyle:AntiAliasedLines`). If those settings are already enabled, then you must ensure your backend supports texture based anti-aliasing (i.e. uses bilinear sampling). Most of the default ImGui backends support this feature out of the box. Learn more [here](https://github.com/ocornut/imgui/issues/3245). Alternatively, you can enable MSAA at the application level if your hardware supports it (4x should do).\n\n**Q: Can I compile ImPlot as a dynamic library?**\n\nA: Like ImGui, it is recommended that you compile and link ImPlot as a *static* library or directly as a part of your sources. However, if you must and are compiling ImPlot and ImGui as separate DLLs, make sure you set the current *ImGui* context with `ImPlot::SetImGuiContext(ImGuiContext* ctx)`. This ensures that global ImGui variables are correctly shared across the DLL boundary.\n\n**Q: Can ImPlot be used with other languages/bindings?**\n\nA: Yes, you can use the generated C binding, [cimplot](https://github.com/cimgui/cimplot) with most high level languages. [DearPyGui](https://github.com/hoffstadt/DearPyGui) provides a Python wrapper, among other things. [DearImGui/DearImPlot](https://github.com/aybe/DearImGui) provides bindings for .NET. [imgui-java](https://github.com/SpaiR/imgui-java) provides bindings for Java. [ImPlot.jl](https://github.com/wsphillips/ImPlot.jl) provides bindings for Julia. A Rust binding, [implot-rs](https://github.com/4bb4/implot-rs), is currently in the works. An example using Emscripten can be found [here](https://github.com/pthom/implot_demo).\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 3.5029296875,
          "content": "The list below represents a combination of high-priority work, nice-to-have features, and random ideas. We make no guarantees that all of this work will be completed or even started. If you see something that you need or would like to have, let us know, or better yet consider submitting a PR for the feature.\n\n## API\n\n## Axes\n\n- add flag to remove weekends on Time axis\n- pixel space scale (`ImPlotTransform_Display`), normalized space scale (`ImPlotTransform_Axes`), data space scale (`ImPlotTransform_Data`)\n- make ImPlotFlags_Equal not a flag -> `SetupEqual(ImPlotAxis x, ImPlotAxis y)`\n- allow inverted arguments `SetAxes` to transpose data?\n- `SetupAxisColors()`\n- `SetupAxisHome()`\n\n## Plot Items\n\n- add `PlotBubbles` (see MATLAB bubble chart)\n- add non-zero references for `PlotBars` etc.\n- fix appearance of `PlotBars` spacing\n\n## Styling\n\n- support gradient and/or colormap sampled fills (e.g. ImPlotFillStyle_)\n- API for setting different fonts for plot elements\n\n## Colormaps\n\n- gradient editing tool\n- `RemoveColormap`\n- `enum ImPlotColorRule_ { Solid, Faded, XValue, YValue, ZValue }`\n\n## Legend\n\n- improve legend icons (e.g. adopt markers, gradients, etc)\n- generalize legend rendering for plots and subplots\n- add draggable scroll bar if users need it\n\n## Tools / Misc.\n\n- add `IsPlotChanging` to detect change in limits\n- add ability to extend plot/axis context menus\n- add LTTB downsampling for lines\n- add box selection to axes\n- first frame render delay might fix \"fit pop\" effect\n- move some code to new `implot_tools.cpp`\n- ColormapSlider (see metrics)\n- FillAlpha should not affect markers?\n- fix mouse text for time axes\n\n## Optimizations\n\n- find faster way to buffer data into ImDrawList (very slow)\n- reduce number of calls to `PushClipRect`\n- explore SIMD operations for high density plot items\n\n## Plotter Pipeline\n\nIdeally every `PlotX` function should use our faster rendering pipeline when it is applicable.\n\n` User Data > Getter > Fitter > Renderer > RenderPrimitives`\n\n|Plotter|Getter|Fitter|Renderer|RenderPrimitives|\n|---|:-:|:-:|:-:|:-:|\n|PlotLine|Yes|Yes|Yes|Yes|\n|PlotScatter|Yes|Yes|Yes|Yes|\n|PlotStairs|Yes|Yes|Yes|Yes|\n|PlotShaded|Yes|Yes|Yes|Yes|\n|PlotBars|Yes|Yes|Yes|Yes|\n|PlotBarGroups|:|:|:|:|\n|PlotHistogram|:|:|:|:|\n|PlotErrorBars|Yes|Yes|No|No|\n|PlotStems|Yes|Yes|Yes|Yes|\n|PlotInfLines|Yes|Yes|Yes|Yes|\n|PlotPieChart|No|No|No|No|\n|PlotHeatmap|Yes|No|Yes|Mixed|\n|PlotHistogram2D|:|:|:|:|\n|PlotDigital|Yes|No|No|No|\n|PlotImage|-|-|-|-|\n|PlotText|-|-|-|-|\n|PlotDummy|-|-|-|-|\n\n## Completed\n- add exploding to `PlotPieChart` (on legend hover)\n- make BeginPlot take fewer args:\n- make query a tool -> `DragRect`\n- rework DragLine/Point to use ButtonBehavior\n- add support for multiple x-axes and don't limit count to 3\n- make axis side configurable (top/left, right/bottom) via new flag `ImPlotAxisFlags_Opposite`\n- add support for setting tick label strings via callback\n- give each axis an ID, remove ad-hoc DND solution\n- allow axis to be drag to opposite side (ala ImGui Table headers)\n- legend items can be hovered even if plot is not\n- fix frame delay on DragX tools\n- remove tag from drag line/point -> add `Tag` tool\n- add shortcut/legacy overloads for BeginPlot\n- `SetupAxisConstraints()`\n- `SetupAxisScale()`\n- add `ImPlotLineFlags`, `ImPlotBarsFlags`, etc. for each plot type\n- add `PlotBarGroups` wrapper that makes rendering groups of bars easier, with stacked bar support\n- `PlotBars` restore outlines\n- add hover/active color for plot axes\n- make legend frame use ButtonBehavior\n- `ImPlotLegendFlags_Scroll` (default behavior)\n"
        },
        {
          "name": "implot.cpp",
          "type": "blob",
          "size": 267.1611328125,
          "content": "// MIT License\n\n// Copyright (c) 2023 Evan Pezent\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// ImPlot v0.17\n\n/*\n\nAPI BREAKING CHANGES\n====================\nOccasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.\nBelow is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.\nWhen you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all implot files.\nYou can read releases logs https://github.com/epezent/implot/releases for more details.\n\n- 2023/08/20 (0.17) - ImPlotFlags_NoChild was removed as child windows are no longer needed to capture scroll. You can safely remove this flag if you were using it.\n- 2023/06/26 (0.15) - Various build fixes related to updates in Dear ImGui internals.\n- 2022/11/25 (0.15) - Make PlotText honor ImPlotItemFlags_NoFit.\n- 2022/06/19 (0.14) - The signature of ColormapScale has changed to accommodate a new ImPlotColormapScaleFlags parameter\n- 2022/06/17 (0.14) - **IMPORTANT** All PlotX functions now take an ImPlotX_Flags `flags` parameter. Where applicable, it is located before the existing `offset` and `stride` parameters.\n                      If you were providing offset and stride values, you will need to update your function call to include a `flags` value. If you fail to do this, you will likely see\n                      unexpected results or crashes without a compiler warning since these three are all default args. We apologize for the inconvenience, but this was a necessary evil.\n                    - PlotBarsH has been removed; use PlotBars + ImPlotBarsFlags_Horizontal instead\n                    - PlotErrorBarsH has been removed; use PlotErrorBars + ImPlotErrorBarsFlags_Horizontal\n                    - PlotHistogram/PlotHistogram2D signatures changed; `cumulative`, `density`, and `outliers` options now specified via ImPlotHistogramFlags\n                    - PlotPieChart signature changed; `normalize` option now specified via ImPlotPieChartFlags\n                    - PlotText signature changes; `vertical` option now specified via `ImPlotTextFlags_Vertical`\n                    - `PlotVLines` and `PlotHLines` replaced with `PlotInfLines` (+ ImPlotInfLinesFlags_Horizontal )\n                    - arguments of ImPlotGetter have been reversed to be consistent with other API callbacks\n                    - SetupAxisScale + ImPlotScale have replaced ImPlotAxisFlags_LogScale and ImPlotAxisFlags_Time flags\n                    - ImPlotFormatters should now return an int indicating the size written\n                    - the signature of ImPlotGetter has been reversed so that void* user_data is the last argument and consistent with other callbacks\n- 2021/10/19 (0.13) - MAJOR API OVERHAUL! See #168 and #272\n                    - TRIVIAL RENAME:\n                      - ImPlotLimits                              -> ImPlotRect\n                      - ImPlotYAxis_                              -> ImAxis_\n                      - SetPlotYAxis                              -> SetAxis\n                      - BeginDragDropTarget                       -> BeginDragDropTargetPlot\n                      - BeginDragDropSource                       -> BeginDragDropSourcePlot\n                      - ImPlotFlags_NoMousePos                    -> ImPlotFlags_NoMouseText\n                      - SetNextPlotLimits                         -> SetNextAxesLimits\n                      - SetMouseTextLocation                      -> SetupMouseText\n                    - SIGNATURE MODIFIED:\n                      - PixelsToPlot/PlotToPixels                 -> added optional X-Axis arg\n                      - GetPlotMousePos                           -> added optional X-Axis arg\n                      - GetPlotLimits                             -> added optional X-Axis arg\n                      - GetPlotSelection                          -> added optional X-Axis arg\n                      - DragLineX/Y/DragPoint                     -> now takes int id; removed labels (render with Annotation/Tag instead)\n                    - REPLACED:\n                      - IsPlotXAxisHovered/IsPlotXYAxisHovered    -> IsAxisHovered(ImAxis)\n                      - BeginDragDropTargetX/BeginDragDropTargetY -> BeginDragDropTargetAxis(ImAxis)\n                      - BeginDragDropSourceX/BeginDragDropSourceY -> BeginDragDropSourceAxis(ImAxis)\n                      - ImPlotCol_XAxis, ImPlotCol_YAxis1, etc.   -> ImPlotCol_AxisText (push/pop this around SetupAxis to style individual axes)\n                      - ImPlotCol_XAxisGrid, ImPlotCol_Y1AxisGrid -> ImPlotCol_AxisGrid (push/pop this around SetupAxis to style individual axes)\n                      - SetNextPlotLimitsX/Y                      -> SetNextAxisLimits(ImAxis)\n                      - LinkNextPlotLimits                        -> SetNextAxisLinks(ImAxis)\n                      - FitNextPlotAxes                           -> SetNextAxisToFit(ImAxis)/SetNextAxesToFit\n                      - SetLegendLocation                         -> SetupLegend\n                      - ImPlotFlags_NoHighlight                   -> ImPlotLegendFlags_NoHighlight\n                      - ImPlotOrientation                         -> ImPlotLegendFlags_Horizontal\n                      - Annotate                                  -> Annotation\n                    - REMOVED:\n                      - GetPlotQuery, SetPlotQuery, IsPlotQueried -> use DragRect\n                      - SetNextPlotTicksX, SetNextPlotTicksY      -> use SetupAxisTicks\n                      - SetNextPlotFormatX, SetNextPlotFormatY    -> use SetupAxisFormat\n                      - AnnotateClamped                           -> use Annotation(bool clamp = true)\n                    - OBSOLETED:\n                      - BeginPlot (original signature)            -> use simplified signature + Setup API\n- 2021/07/30 (0.12) - The offset argument of `PlotXG` functions was been removed. Implement offsetting in your getter callback instead.\n- 2021/03/08 (0.9)  - SetColormap and PushColormap(ImVec4*) were removed. Use AddColormap for custom colormap support. LerpColormap was changed to SampleColormap.\n                      ShowColormapScale was changed to ColormapScale and requires additional arguments.\n- 2021/03/07 (0.9)  - The signature of ShowColormapScale was modified to accept a ImVec2 size.\n- 2021/02/28 (0.9)  - BeginLegendDragDropSource was changed to BeginDragDropSourceItem with a number of other drag and drop improvements.\n- 2021/01/18 (0.9)  - The default behavior for opening context menus was change from double right-click to single right-click. ImPlotInputMap and related functions were moved\n                      to implot_internal.h due to its immaturity.\n- 2020/10/16 (0.8)  - ImPlotStyleVar_InfoPadding was changed to ImPlotStyleVar_MousePosPadding\n- 2020/09/10 (0.8)  - The single array versions of PlotLine, PlotScatter, PlotStems, and PlotShaded were given additional arguments for x-scale and x0.\n- 2020/09/07 (0.8)  - Plotting functions which accept a custom getter function pointer have been post-fixed with a G (e.g. PlotLineG)\n- 2020/09/06 (0.7)  - Several flags under ImPlotFlags and ImPlotAxisFlags were inverted (e.g. ImPlotFlags_Legend -> ImPlotFlags_NoLegend) so that the default flagset\n                      is simply 0. This more closely matches ImGui's style and makes it easier to enable non-default but commonly used flags (e.g. ImPlotAxisFlags_Time).\n- 2020/08/28 (0.5)  - ImPlotMarker_ can no longer be combined with bitwise OR, |. This features caused unecessary slow-down, and almost no one used it.\n- 2020/08/25 (0.5)  - ImPlotAxisFlags_Scientific was removed. Logarithmic axes automatically uses scientific notation.\n- 2020/08/17 (0.5)  - PlotText was changed so that text is centered horizontally and vertically about the desired point.\n- 2020/08/16 (0.5)  - An ImPlotContext must be explicitly created and destroyed now with `CreateContext` and `DestroyContext`. Previously, the context was statically initialized in this source file.\n- 2020/06/13 (0.4)  - The flags `ImPlotAxisFlag_Adaptive` and `ImPlotFlags_Cull` were removed. Both are now done internally by default.\n- 2020/06/03 (0.3)  - The signature and behavior of PlotPieChart was changed so that data with sum less than 1 can optionally be normalized. The label format can now be specified as well.\n- 2020/06/01 (0.3)  - SetPalette was changed to `SetColormap` for consistency with other plotting libraries. `RestorePalette` was removed. Use `SetColormap(ImPlotColormap_Default)`.\n- 2020/05/31 (0.3)  - Plot functions taking custom ImVec2* getters were removed. Use the ImPlotPoint* getter versions instead.\n- 2020/05/29 (0.3)  - The signature of ImPlotLimits::Contains was changed to take two doubles instead of ImVec2\n- 2020/05/16 (0.2)  - All plotting functions were reverted to being prefixed with \"Plot\" to maintain a consistent VerbNoun style. `Plot` was split into `PlotLine`\n                      and `PlotScatter` (however, `PlotLine` can still be used to plot scatter points as `Plot` did before.). `Bar` is not `PlotBars`, to indicate\n                      that multiple bars will be plotted.\n- 2020/05/13 (0.2)  - `ImMarker` was change to `ImPlotMarker` and `ImAxisFlags` was changed to `ImPlotAxisFlags`.\n- 2020/05/11 (0.2)  - `ImPlotFlags_Selection` was changed to `ImPlotFlags_BoxSelect`\n- 2020/05/11 (0.2)  - The namespace ImGui:: was replaced with ImPlot::. As a result, the following additional changes were made:\n                      - Functions that were prefixed or decorated with the word \"Plot\" have been truncated. E.g., `ImGui::PlotBars` is now just `ImPlot::Bar`.\n                        It should be fairly obvious what was what.\n                      - Some functions have been given names that would have otherwise collided with the ImGui namespace. This has been done to maintain a consistent\n                        style with ImGui. E.g., 'ImGui::PushPlotStyleVar` is now 'ImPlot::PushStyleVar'.\n- 2020/05/10 (0.2)  - The following function/struct names were changes:\n                     - ImPlotRange       -> ImPlotLimits\n                     - GetPlotRange()    -> GetPlotLimits()\n                     - SetNextPlotRange  -> SetNextPlotLimits\n                     - SetNextPlotRangeX -> SetNextPlotLimitsX\n                     - SetNextPlotRangeY -> SetNextPlotLimitsY\n- 2020/05/10 (0.2)  - Plot queries are pixel based by default. Query rects that maintain relative plot position have been removed. This was done to support multi-y-axis.\n\n*/\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"implot.h\"\n#ifndef IMGUI_DISABLE\n#include \"implot_internal.h\"\n\n#include <stdlib.h>\n\n// Support for pre-1.82 versions. Users on 1.82+ can use 0 (default) flags to mean \"all corners\" but in order to support older versions we are more explicit.\n#if (IMGUI_VERSION_NUM < 18102) && !defined(ImDrawFlags_RoundCornersAll)\n#define ImDrawFlags_RoundCornersAll ImDrawCornerFlags_All\n#endif\n\n// Support for pre-1.89.7 versions.\n#if (IMGUI_VERSION_NUM < 18966)\n#define ImGuiButtonFlags_AllowOverlap ImGuiButtonFlags_AllowItemOverlap\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"  // warning: format string is not a string literal\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"    // warning: format not a string literal, format string not checked\n#endif\n\n// Global plot context\n#ifndef GImPlot\nImPlotContext* GImPlot = nullptr;\n#endif\n\n//-----------------------------------------------------------------------------\n// Struct Implementations\n//-----------------------------------------------------------------------------\n\nImPlotInputMap::ImPlotInputMap() {\n    ImPlot::MapInputDefault(this);\n}\n\nImPlotStyle::ImPlotStyle() {\n\n    LineWeight         = 1;\n    Marker             = ImPlotMarker_None;\n    MarkerSize         = 4;\n    MarkerWeight       = 1;\n    FillAlpha          = 1;\n    ErrorBarSize       = 5;\n    ErrorBarWeight     = 1.5f;\n    DigitalBitHeight   = 8;\n    DigitalBitGap      = 4;\n\n    PlotBorderSize     = 1;\n    MinorAlpha         = 0.25f;\n    MajorTickLen       = ImVec2(10,10);\n    MinorTickLen       = ImVec2(5,5);\n    MajorTickSize      = ImVec2(1,1);\n    MinorTickSize      = ImVec2(1,1);\n    MajorGridSize      = ImVec2(1,1);\n    MinorGridSize      = ImVec2(1,1);\n    PlotPadding        = ImVec2(10,10);\n    LabelPadding       = ImVec2(5,5);\n    LegendPadding      = ImVec2(10,10);\n    LegendInnerPadding = ImVec2(5,5);\n    LegendSpacing      = ImVec2(5,0);\n    MousePosPadding    = ImVec2(10,10);\n    AnnotationPadding  = ImVec2(2,2);\n    FitPadding         = ImVec2(0,0);\n    PlotDefaultSize    = ImVec2(400,300);\n    PlotMinSize        = ImVec2(200,150);\n\n    ImPlot::StyleColorsAuto(this);\n\n    Colormap = ImPlotColormap_Deep;\n\n    UseLocalTime     = false;\n    Use24HourClock   = false;\n    UseISO8601       = false;\n}\n\n//-----------------------------------------------------------------------------\n// Style\n//-----------------------------------------------------------------------------\n\nnamespace ImPlot {\n\nconst char* GetStyleColorName(ImPlotCol col) {\n    static const char* col_names[ImPlotCol_COUNT] = {\n        \"Line\",\n        \"Fill\",\n        \"MarkerOutline\",\n        \"MarkerFill\",\n        \"ErrorBar\",\n        \"FrameBg\",\n        \"PlotBg\",\n        \"PlotBorder\",\n        \"LegendBg\",\n        \"LegendBorder\",\n        \"LegendText\",\n        \"TitleText\",\n        \"InlayText\",\n        \"AxisText\",\n        \"AxisGrid\",\n        \"AxisTick\",\n        \"AxisBg\",\n        \"AxisBgHovered\",\n        \"AxisBgActive\",\n        \"Selection\",\n        \"Crosshairs\"\n    };\n    return col_names[col];\n}\n\nconst char* GetMarkerName(ImPlotMarker marker) {\n    switch (marker) {\n        case ImPlotMarker_None:     return \"None\";\n        case ImPlotMarker_Circle:   return \"Circle\";\n        case ImPlotMarker_Square:   return \"Square\";\n        case ImPlotMarker_Diamond:  return \"Diamond\";\n        case ImPlotMarker_Up:       return \"Up\";\n        case ImPlotMarker_Down:     return \"Down\";\n        case ImPlotMarker_Left:     return \"Left\";\n        case ImPlotMarker_Right:    return \"Right\";\n        case ImPlotMarker_Cross:    return \"Cross\";\n        case ImPlotMarker_Plus:     return \"Plus\";\n        case ImPlotMarker_Asterisk: return \"Asterisk\";\n        default:                    return \"\";\n    }\n}\n\nImVec4 GetAutoColor(ImPlotCol idx) {\n    ImVec4 col(0,0,0,1);\n    switch(idx) {\n        case ImPlotCol_Line:          return col; // these are plot dependent!\n        case ImPlotCol_Fill:          return col; // these are plot dependent!\n        case ImPlotCol_MarkerOutline: return col; // these are plot dependent!\n        case ImPlotCol_MarkerFill:    return col; // these are plot dependent!\n        case ImPlotCol_ErrorBar:      return ImGui::GetStyleColorVec4(ImGuiCol_Text);\n        case ImPlotCol_FrameBg:       return ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);\n        case ImPlotCol_PlotBg:        return ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);\n        case ImPlotCol_PlotBorder:    return ImGui::GetStyleColorVec4(ImGuiCol_Border);\n        case ImPlotCol_LegendBg:      return ImGui::GetStyleColorVec4(ImGuiCol_PopupBg);\n        case ImPlotCol_LegendBorder:  return GetStyleColorVec4(ImPlotCol_PlotBorder);\n        case ImPlotCol_LegendText:    return GetStyleColorVec4(ImPlotCol_InlayText);\n        case ImPlotCol_TitleText:     return ImGui::GetStyleColorVec4(ImGuiCol_Text);\n        case ImPlotCol_InlayText:     return ImGui::GetStyleColorVec4(ImGuiCol_Text);\n        case ImPlotCol_AxisText:      return ImGui::GetStyleColorVec4(ImGuiCol_Text);\n        case ImPlotCol_AxisGrid:      return GetStyleColorVec4(ImPlotCol_AxisText) * ImVec4(1,1,1,0.25f);\n        case ImPlotCol_AxisTick:      return GetStyleColorVec4(ImPlotCol_AxisGrid);\n        case ImPlotCol_AxisBg:        return ImVec4(0,0,0,0);\n        case ImPlotCol_AxisBgHovered: return ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);\n        case ImPlotCol_AxisBgActive:  return ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);\n        case ImPlotCol_Selection:     return ImVec4(1,1,0,1);\n        case ImPlotCol_Crosshairs:    return GetStyleColorVec4(ImPlotCol_PlotBorder);\n        default: return col;\n    }\n}\n\nstruct ImPlotStyleVarInfo {\n    ImGuiDataType   Type;\n    ImU32           Count;\n    ImU32           Offset;\n    void*           GetVarPtr(ImPlotStyle* style) const { return (void*)((unsigned char*)style + Offset); }\n};\n\nstatic const ImPlotStyleVarInfo GPlotStyleVarInfo[] =\n{\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, LineWeight)         }, // ImPlotStyleVar_LineWeight\n    { ImGuiDataType_S32,   1, (ImU32)offsetof(ImPlotStyle, Marker)             }, // ImPlotStyleVar_Marker\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MarkerSize)         }, // ImPlotStyleVar_MarkerSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MarkerWeight)       }, // ImPlotStyleVar_MarkerWeight\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, FillAlpha)          }, // ImPlotStyleVar_FillAlpha\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, ErrorBarSize)       }, // ImPlotStyleVar_ErrorBarSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, ErrorBarWeight)     }, // ImPlotStyleVar_ErrorBarWeight\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, DigitalBitHeight)   }, // ImPlotStyleVar_DigitalBitHeight\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, DigitalBitGap)      }, // ImPlotStyleVar_DigitalBitGap\n\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, PlotBorderSize)     }, // ImPlotStyleVar_PlotBorderSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MinorAlpha)         }, // ImPlotStyleVar_MinorAlpha\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorTickLen)       }, // ImPlotStyleVar_MajorTickLen\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorTickLen)       }, // ImPlotStyleVar_MinorTickLen\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorTickSize)      }, // ImPlotStyleVar_MajorTickSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorTickSize)      }, // ImPlotStyleVar_MinorTickSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorGridSize)      }, // ImPlotStyleVar_MajorGridSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorGridSize)      }, // ImPlotStyleVar_MinorGridSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotPadding)        }, // ImPlotStyleVar_PlotPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LabelPadding)       }, // ImPlotStyleVar_LabelPaddine\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendPadding)      }, // ImPlotStyleVar_LegendPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendInnerPadding) }, // ImPlotStyleVar_LegendInnerPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendSpacing)      }, // ImPlotStyleVar_LegendSpacing\n\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MousePosPadding)    }, // ImPlotStyleVar_MousePosPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, AnnotationPadding)  }, // ImPlotStyleVar_AnnotationPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, FitPadding)         }, // ImPlotStyleVar_FitPadding\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotDefaultSize)    }, // ImPlotStyleVar_PlotDefaultSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotMinSize)        }  // ImPlotStyleVar_PlotMinSize\n};\n\nstatic const ImPlotStyleVarInfo* GetPlotStyleVarInfo(ImPlotStyleVar idx) {\n    IM_ASSERT(idx >= 0 && idx < ImPlotStyleVar_COUNT);\n    IM_ASSERT(IM_ARRAYSIZE(GPlotStyleVarInfo) == ImPlotStyleVar_COUNT);\n    return &GPlotStyleVarInfo[idx];\n}\n\n//-----------------------------------------------------------------------------\n// Generic Helpers\n//-----------------------------------------------------------------------------\n\nvoid AddTextVertical(ImDrawList *DrawList, ImVec2 pos, ImU32 col, const char *text_begin, const char* text_end) {\n    // the code below is based loosely on ImFont::RenderText\n    if (!text_end)\n        text_end = text_begin + strlen(text_begin);\n    ImGuiContext& g = *GImGui;\n    ImFont* font = g.Font;\n    // Align to be pixel perfect\n    pos.x = ImFloor(pos.x);\n    pos.y = ImFloor(pos.y);\n    const float scale = g.FontSize / font->FontSize;\n    const char* s = text_begin;\n    int chars_exp = (int)(text_end - s);\n    int chars_rnd = 0;\n    const int vtx_count_max = chars_exp * 4;\n    const int idx_count_max = chars_exp * 6;\n    DrawList->PrimReserve(idx_count_max, vtx_count_max);\n    while (s < text_end) {\n        unsigned int c = (unsigned int)*s;\n        if (c < 0x80) {\n            s += 1;\n        }\n        else {\n            s += ImTextCharFromUtf8(&c, s, text_end);\n            if (c == 0) // Malformed UTF-8?\n                break;\n        }\n        const ImFontGlyph * glyph = font->FindGlyph((ImWchar)c);\n        if (glyph == nullptr) {\n            continue;\n        }\n        DrawList->PrimQuadUV(pos + ImVec2(glyph->Y0, -glyph->X0) * scale, pos + ImVec2(glyph->Y0, -glyph->X1) * scale,\n                             pos + ImVec2(glyph->Y1, -glyph->X1) * scale, pos + ImVec2(glyph->Y1, -glyph->X0) * scale,\n                             ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V0),\n                             ImVec2(glyph->U1, glyph->V1), ImVec2(glyph->U0, glyph->V1),\n                             col);\n        pos.y -= glyph->AdvanceX * scale;\n        chars_rnd++;\n    }\n    // Give back unused vertices\n    int chars_skp = chars_exp-chars_rnd;\n    DrawList->PrimUnreserve(chars_skp*6, chars_skp*4);\n}\n\nvoid AddTextCentered(ImDrawList* DrawList, ImVec2 top_center, ImU32 col, const char* text_begin, const char* text_end) {\n    float txt_ht = ImGui::GetTextLineHeight();\n    const char* title_end = ImGui::FindRenderedTextEnd(text_begin, text_end);\n    ImVec2 text_size;\n    float  y = 0;\n    while (const char* tmp = (const char*)memchr(text_begin, '\\n', title_end-text_begin)) {\n        text_size = ImGui::CalcTextSize(text_begin,tmp,true);\n        DrawList->AddText(ImVec2(top_center.x - text_size.x * 0.5f, top_center.y+y),col,text_begin,tmp);\n        text_begin = tmp + 1;\n        y += txt_ht;\n    }\n    text_size = ImGui::CalcTextSize(text_begin,title_end,true);\n    DrawList->AddText(ImVec2(top_center.x - text_size.x * 0.5f, top_center.y+y),col,text_begin,title_end);\n}\n\ndouble NiceNum(double x, bool round) {\n    double f;\n    double nf;\n    int expv = (int)floor(ImLog10(x));\n    f = x / ImPow(10.0, (double)expv);\n    if (round)\n        if (f < 1.5)\n            nf = 1;\n        else if (f < 3)\n            nf = 2;\n        else if (f < 7)\n            nf = 5;\n        else\n            nf = 10;\n    else if (f <= 1)\n        nf = 1;\n    else if (f <= 2)\n        nf = 2;\n    else if (f <= 5)\n        nf = 5;\n    else\n        nf = 10;\n    return nf * ImPow(10.0, expv);\n}\n\n//-----------------------------------------------------------------------------\n// Context Utils\n//-----------------------------------------------------------------------------\n\nvoid SetImGuiContext(ImGuiContext* ctx) {\n    ImGui::SetCurrentContext(ctx);\n}\n\nImPlotContext* CreateContext() {\n    ImPlotContext* ctx = IM_NEW(ImPlotContext)();\n    Initialize(ctx);\n    if (GImPlot == nullptr)\n        SetCurrentContext(ctx);\n    return ctx;\n}\n\nvoid DestroyContext(ImPlotContext* ctx) {\n    if (ctx == nullptr)\n        ctx = GImPlot;\n    if (GImPlot == ctx)\n        SetCurrentContext(nullptr);\n    IM_DELETE(ctx);\n}\n\nImPlotContext* GetCurrentContext() {\n    return GImPlot;\n}\n\nvoid SetCurrentContext(ImPlotContext* ctx) {\n    GImPlot = ctx;\n}\n\n#define IMPLOT_APPEND_CMAP(name, qual) ctx->ColormapData.Append(#name, name, sizeof(name)/sizeof(ImU32), qual)\n#define IM_RGB(r,g,b) IM_COL32(r,g,b,255)\n\nvoid Initialize(ImPlotContext* ctx) {\n    ResetCtxForNextPlot(ctx);\n    ResetCtxForNextAlignedPlots(ctx);\n    ResetCtxForNextSubplot(ctx);\n\n    const ImU32 Deep[]     = {4289753676, 4283598045, 4285048917, 4283584196, 4289950337, 4284512403, 4291005402, 4287401100, 4285839820, 4291671396                        };\n    const ImU32 Dark[]     = {4280031972, 4290281015, 4283084621, 4288892568, 4278222847, 4281597951, 4280833702, 4290740727, 4288256409                                    };\n    const ImU32 Pastel[]   = {4289639675, 4293119411, 4291161036, 4293184478, 4289124862, 4291624959, 4290631909, 4293712637, 4294111986                                    };\n    const ImU32 Paired[]   = {4293119554, 4290017311, 4287291314, 4281114675, 4288256763, 4280031971, 4285513725, 4278222847, 4292260554, 4288298346, 4288282623, 4280834481};\n    const ImU32 Viridis[]  = {4283695428, 4285867080, 4287054913, 4287455029, 4287526954, 4287402273, 4286883874, 4285579076, 4283552122, 4280737725, 4280674301            };\n    const ImU32 Plasma[]   = {4287039501, 4288480321, 4289200234, 4288941455, 4287638193, 4286072780, 4284638433, 4283139314, 4281771772, 4280667900, 4280416752            };\n    const ImU32 Hot[]      = {4278190144, 4278190208, 4278190271, 4278190335, 4278206719, 4278223103, 4278239231, 4278255615, 4283826175, 4289396735, 4294967295            };\n    const ImU32 Cool[]     = {4294967040, 4294960666, 4294954035, 4294947661, 4294941030, 4294934656, 4294928025, 4294921651, 4294915020, 4294908646, 4294902015            };\n    const ImU32 Pink[]     = {4278190154, 4282532475, 4284308894, 4285690554, 4286879686, 4287870160, 4288794330, 4289651940, 4291685869, 4293392118, 4294967295            };\n    const ImU32 Jet[]      = {4289331200, 4294901760, 4294923520, 4294945280, 4294967040, 4289396565, 4283826090, 4278255615, 4278233855, 4278212095, 4278190335            };\n    const ImU32 Twilight[] = {IM_RGB(226,217,226),IM_RGB(166,191,202),IM_RGB(109,144,192),IM_RGB(95,88,176),IM_RGB(83,30,124),IM_RGB(47,20,54),IM_RGB(100,25,75),IM_RGB(159,60,80),IM_RGB(192,117,94),IM_RGB(208,179,158),IM_RGB(226,217,226)};\n    const ImU32 RdBu[]     = {IM_RGB(103,0,31),IM_RGB(178,24,43),IM_RGB(214,96,77),IM_RGB(244,165,130),IM_RGB(253,219,199),IM_RGB(247,247,247),IM_RGB(209,229,240),IM_RGB(146,197,222),IM_RGB(67,147,195),IM_RGB(33,102,172),IM_RGB(5,48,97)};\n    const ImU32 BrBG[]     = {IM_RGB(84,48,5),IM_RGB(140,81,10),IM_RGB(191,129,45),IM_RGB(223,194,125),IM_RGB(246,232,195),IM_RGB(245,245,245),IM_RGB(199,234,229),IM_RGB(128,205,193),IM_RGB(53,151,143),IM_RGB(1,102,94),IM_RGB(0,60,48)};\n    const ImU32 PiYG[]     = {IM_RGB(142,1,82),IM_RGB(197,27,125),IM_RGB(222,119,174),IM_RGB(241,182,218),IM_RGB(253,224,239),IM_RGB(247,247,247),IM_RGB(230,245,208),IM_RGB(184,225,134),IM_RGB(127,188,65),IM_RGB(77,146,33),IM_RGB(39,100,25)};\n    const ImU32 Spectral[] = {IM_RGB(158,1,66),IM_RGB(213,62,79),IM_RGB(244,109,67),IM_RGB(253,174,97),IM_RGB(254,224,139),IM_RGB(255,255,191),IM_RGB(230,245,152),IM_RGB(171,221,164),IM_RGB(102,194,165),IM_RGB(50,136,189),IM_RGB(94,79,162)};\n    const ImU32 Greys[]    = {IM_COL32_WHITE, IM_COL32_BLACK                                                                                                                };\n\n    IMPLOT_APPEND_CMAP(Deep, true);\n    IMPLOT_APPEND_CMAP(Dark, true);\n    IMPLOT_APPEND_CMAP(Pastel, true);\n    IMPLOT_APPEND_CMAP(Paired, true);\n    IMPLOT_APPEND_CMAP(Viridis, false);\n    IMPLOT_APPEND_CMAP(Plasma, false);\n    IMPLOT_APPEND_CMAP(Hot, false);\n    IMPLOT_APPEND_CMAP(Cool, false);\n    IMPLOT_APPEND_CMAP(Pink, false);\n    IMPLOT_APPEND_CMAP(Jet, false);\n    IMPLOT_APPEND_CMAP(Twilight, false);\n    IMPLOT_APPEND_CMAP(RdBu, false);\n    IMPLOT_APPEND_CMAP(BrBG, false);\n    IMPLOT_APPEND_CMAP(PiYG, false);\n    IMPLOT_APPEND_CMAP(Spectral, false);\n    IMPLOT_APPEND_CMAP(Greys, false);\n}\n\nvoid ResetCtxForNextPlot(ImPlotContext* ctx) {\n    // reset the next plot/item data\n    ctx->NextPlotData.Reset();\n    ctx->NextItemData.Reset();\n    // reset labels\n    ctx->Annotations.Reset();\n    ctx->Tags.Reset();\n    // reset extents/fit\n    ctx->OpenContextThisFrame = false;\n    // reset digital plot items count\n    ctx->DigitalPlotItemCnt = 0;\n    ctx->DigitalPlotOffset = 0;\n    // nullify plot\n    ctx->CurrentPlot  = nullptr;\n    ctx->CurrentItem  = nullptr;\n    ctx->PreviousItem = nullptr;\n}\n\nvoid ResetCtxForNextAlignedPlots(ImPlotContext* ctx) {\n    ctx->CurrentAlignmentH = nullptr;\n    ctx->CurrentAlignmentV = nullptr;\n}\n\nvoid ResetCtxForNextSubplot(ImPlotContext* ctx) {\n    ctx->CurrentSubplot      = nullptr;\n    ctx->CurrentAlignmentH   = nullptr;\n    ctx->CurrentAlignmentV   = nullptr;\n}\n\n//-----------------------------------------------------------------------------\n// Plot Utils\n//-----------------------------------------------------------------------------\n\nImPlotPlot* GetPlot(const char* title) {\n    ImGuiWindow*   Window = GImGui->CurrentWindow;\n    const ImGuiID  ID     = Window->GetID(title);\n    return GImPlot->Plots.GetByKey(ID);\n}\n\nImPlotPlot* GetCurrentPlot() {\n    return GImPlot->CurrentPlot;\n}\n\nvoid BustPlotCache() {\n    ImPlotContext& gp = *GImPlot;\n    gp.Plots.Clear();\n    gp.Subplots.Clear();\n}\n\n//-----------------------------------------------------------------------------\n// Legend Utils\n//-----------------------------------------------------------------------------\n\nImVec2 GetLocationPos(const ImRect& outer_rect, const ImVec2& inner_size, ImPlotLocation loc, const ImVec2& pad) {\n    ImVec2 pos;\n    if (ImHasFlag(loc, ImPlotLocation_West) && !ImHasFlag(loc, ImPlotLocation_East))\n        pos.x = outer_rect.Min.x + pad.x;\n    else if (!ImHasFlag(loc, ImPlotLocation_West) && ImHasFlag(loc, ImPlotLocation_East))\n        pos.x = outer_rect.Max.x - pad.x - inner_size.x;\n    else\n        pos.x = outer_rect.GetCenter().x - inner_size.x * 0.5f;\n    // legend reference point y\n    if (ImHasFlag(loc, ImPlotLocation_North) && !ImHasFlag(loc, ImPlotLocation_South))\n        pos.y = outer_rect.Min.y + pad.y;\n    else if (!ImHasFlag(loc, ImPlotLocation_North) && ImHasFlag(loc, ImPlotLocation_South))\n        pos.y = outer_rect.Max.y - pad.y - inner_size.y;\n    else\n        pos.y = outer_rect.GetCenter().y - inner_size.y * 0.5f;\n    pos.x = IM_ROUND(pos.x);\n    pos.y = IM_ROUND(pos.y);\n    return pos;\n}\n\nImVec2 CalcLegendSize(ImPlotItemGroup& items, const ImVec2& pad, const ImVec2& spacing, bool vertical) {\n    // vars\n    const int   nItems      = items.GetLegendCount();\n    const float txt_ht      = ImGui::GetTextLineHeight();\n    const float icon_size   = txt_ht;\n    // get label max width\n    float max_label_width = 0;\n    float sum_label_width = 0;\n    for (int i = 0; i < nItems; ++i) {\n        const char* label       = items.GetLegendLabel(i);\n        const float label_width = ImGui::CalcTextSize(label, nullptr, true).x;\n        max_label_width         = label_width > max_label_width ? label_width : max_label_width;\n        sum_label_width        += label_width;\n    }\n    // calc legend size\n    const ImVec2 legend_size = vertical ?\n                               ImVec2(pad.x * 2 + icon_size + max_label_width, pad.y * 2 + nItems * txt_ht + (nItems - 1) * spacing.y) :\n                               ImVec2(pad.x * 2 + icon_size * nItems + sum_label_width + (nItems - 1) * spacing.x, pad.y * 2 + txt_ht);\n    return legend_size;\n}\n\nbool ClampLegendRect(ImRect& legend_rect, const ImRect& outer_rect, const ImVec2& pad) {\n    bool clamped = false;\n    ImRect outer_rect_pad(outer_rect.Min + pad, outer_rect.Max - pad);\n    if (legend_rect.Min.x < outer_rect_pad.Min.x) {\n        legend_rect.Min.x = outer_rect_pad.Min.x;\n        clamped = true;\n    }\n    if (legend_rect.Min.y < outer_rect_pad.Min.y) {\n        legend_rect.Min.y = outer_rect_pad.Min.y;\n        clamped = true;\n    }\n    if (legend_rect.Max.x > outer_rect_pad.Max.x) {\n        legend_rect.Max.x = outer_rect_pad.Max.x;\n        clamped = true;\n    }\n    if (legend_rect.Max.y > outer_rect_pad.Max.y) {\n        legend_rect.Max.y = outer_rect_pad.Max.y;\n        clamped = true;\n    }\n    return clamped;\n}\n\nint LegendSortingComp(const void* _a, const void* _b) {\n    ImPlotItemGroup* items = GImPlot->SortItems;\n    const int a = *(const int*)_a;\n    const int b = *(const int*)_b;\n    const char* label_a = items->GetLegendLabel(a);\n    const char* label_b = items->GetLegendLabel(b);\n    return strcmp(label_a,label_b);\n}\n\nbool ShowLegendEntries(ImPlotItemGroup& items, const ImRect& legend_bb, bool hovered, const ImVec2& pad, const ImVec2& spacing, bool vertical, ImDrawList& DrawList) {\n    // vars\n    const float txt_ht      = ImGui::GetTextLineHeight();\n    const float icon_size   = txt_ht;\n    const float icon_shrink = 2;\n    ImU32 col_txt           = GetStyleColorU32(ImPlotCol_LegendText);\n    ImU32 col_txt_dis       = ImAlphaU32(col_txt, 0.25f);\n    // render each legend item\n    float sum_label_width = 0;\n    bool any_item_hovered = false;\n\n    const int num_items = items.GetLegendCount();\n    if (num_items < 1)\n        return hovered;\n    // build render order\n    ImPlotContext& gp = *GImPlot;\n    ImVector<int>& indices = gp.TempInt1;\n    indices.resize(num_items);\n    for (int i = 0; i < num_items; ++i)\n        indices[i] = i;\n    if (ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_Sort) && num_items > 1) {\n        gp.SortItems = &items;\n        qsort(indices.Data, num_items, sizeof(int), LegendSortingComp);\n    }\n    // render\n    for (int i = 0; i < num_items; ++i) {\n        const int idx           = indices[i];\n        ImPlotItem* item        = items.GetLegendItem(idx);\n        const char* label       = items.GetLegendLabel(idx);\n        const float label_width = ImGui::CalcTextSize(label, nullptr, true).x;\n        const ImVec2 top_left   = vertical ?\n                                  legend_bb.Min + pad + ImVec2(0, i * (txt_ht + spacing.y)) :\n                                  legend_bb.Min + pad + ImVec2(i * (icon_size + spacing.x) + sum_label_width, 0);\n        sum_label_width        += label_width;\n        ImRect icon_bb;\n        icon_bb.Min = top_left + ImVec2(icon_shrink,icon_shrink);\n        icon_bb.Max = top_left + ImVec2(icon_size - icon_shrink, icon_size - icon_shrink);\n        ImRect label_bb;\n        label_bb.Min = top_left;\n        label_bb.Max = top_left + ImVec2(label_width + icon_size, icon_size);\n        ImU32 col_txt_hl;\n        ImU32 col_item = ImAlphaU32(item->Color,1);\n\n        ImRect button_bb(icon_bb.Min, label_bb.Max);\n\n        ImGui::KeepAliveID(item->ID);\n\n        bool item_hov = false;\n        bool item_hld = false;\n        bool item_clk = ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoButtons)\n                      ? false\n                      : ImGui::ButtonBehavior(button_bb, item->ID, &item_hov, &item_hld);\n\n        if (item_clk)\n            item->Show = !item->Show;\n\n\n        const bool can_hover = (item_hov)\n                             && (!ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoHighlightItem)\n                             || !ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoHighlightAxis));\n\n        if (can_hover) {\n            item->LegendHoverRect.Min = icon_bb.Min;\n            item->LegendHoverRect.Max = label_bb.Max;\n            item->LegendHovered = true;\n            col_txt_hl = ImMixU32(col_txt, col_item, 64);\n            any_item_hovered = true;\n        }\n        else {\n            col_txt_hl = ImGui::GetColorU32(col_txt);\n        }\n        ImU32 col_icon;\n        if (item_hld)\n            col_icon = item->Show ? ImAlphaU32(col_item,0.5f) : ImGui::GetColorU32(ImGuiCol_TextDisabled, 0.5f);\n        else if (item_hov)\n            col_icon = item->Show ? ImAlphaU32(col_item,0.75f) : ImGui::GetColorU32(ImGuiCol_TextDisabled, 0.75f);\n        else\n            col_icon = item->Show ? col_item : col_txt_dis;\n\n        DrawList.AddRectFilled(icon_bb.Min, icon_bb.Max, col_icon);\n        const char* text_display_end = ImGui::FindRenderedTextEnd(label, nullptr);\n        if (label != text_display_end)\n            DrawList.AddText(top_left + ImVec2(icon_size, 0), item->Show ? col_txt_hl  : col_txt_dis, label, text_display_end);\n    }\n    return hovered && !any_item_hovered;\n}\n\n//-----------------------------------------------------------------------------\n// Locators\n//-----------------------------------------------------------------------------\n\nstatic const float TICK_FILL_X = 0.8f;\nstatic const float TICK_FILL_Y = 1.0f;\n\nvoid Locator_Default(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {\n    if (range.Min == range.Max)\n        return;\n    const int nMinor        = 10;\n    const int nMajor        = ImMax(2, (int)IM_ROUND(pixels / (vertical ? 300.0f : 400.0f)));\n    const double nice_range = NiceNum(range.Size() * 0.99, false);\n    const double interval   = NiceNum(nice_range / (nMajor - 1), true);\n    const double graphmin   = floor(range.Min / interval) * interval;\n    const double graphmax   = ceil(range.Max / interval) * interval;\n    bool first_major_set    = false;\n    int  first_major_idx    = 0;\n    const int idx0 = ticker.TickCount(); // ticker may have user custom ticks\n    ImVec2 total_size(0,0);\n    for (double major = graphmin; major < graphmax + 0.5 * interval; major += interval) {\n        // is this zero? combat zero formatting issues\n        if (major-interval < 0 && major+interval > 0)\n            major = 0;\n        if (range.Contains(major)) {\n            if (!first_major_set) {\n                first_major_idx = ticker.TickCount();\n                first_major_set = true;\n            }\n            total_size += ticker.AddTick(major, true, 0, true, formatter, formatter_data).LabelSize;\n        }\n        for (int i = 1; i < nMinor; ++i) {\n            double minor = major + i * interval / nMinor;\n            if (range.Contains(minor)) {\n                total_size += ticker.AddTick(minor, false, 0, true, formatter, formatter_data).LabelSize;\n            }\n        }\n    }\n    // prune if necessary\n    if ((!vertical && total_size.x > pixels*TICK_FILL_X) || (vertical && total_size.y > pixels*TICK_FILL_Y)) {\n        for (int i = first_major_idx-1; i >= idx0; i -= 2)\n            ticker.Ticks[i].ShowLabel = false;\n        for (int i = first_major_idx+1; i < ticker.TickCount(); i += 2)\n            ticker.Ticks[i].ShowLabel = false;\n    }\n}\n\nbool CalcLogarithmicExponents(const ImPlotRange& range, float pix, bool vertical, int& exp_min, int& exp_max, int& exp_step) {\n    if (range.Min * range.Max > 0) {\n        const int nMajor = vertical ? ImMax(2, (int)IM_ROUND(pix * 0.02f)) : ImMax(2, (int)IM_ROUND(pix * 0.01f)); // TODO: magic numbers\n        double log_min = ImLog10(ImAbs(range.Min));\n        double log_max = ImLog10(ImAbs(range.Max));\n        double log_a = ImMin(log_min,log_max);\n        double log_b = ImMax(log_min,log_max);\n        exp_step  = ImMax(1,(int)(log_b - log_a) / nMajor);\n        exp_min   = (int)log_a;\n        exp_max   = (int)log_b;\n        if (exp_step != 1) {\n            while(exp_step % 3 != 0)       exp_step++; // make step size multiple of three\n            while(exp_min % exp_step != 0) exp_min--;  // decrease exp_min until exp_min + N * exp_step will be 0\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid AddTicksLogarithmic(const ImPlotRange& range, int exp_min, int exp_max, int exp_step, ImPlotTicker& ticker, ImPlotFormatter formatter, void* data) {\n    const double sign = ImSign(range.Max);\n    for (int e = exp_min - exp_step; e < (exp_max + exp_step); e += exp_step) {\n        double major1 = sign*ImPow(10, (double)(e));\n        double major2 = sign*ImPow(10, (double)(e + 1));\n        double interval = (major2 - major1) / 9;\n        if (major1 >= (range.Min - DBL_EPSILON) && major1 <= (range.Max + DBL_EPSILON))\n            ticker.AddTick(major1, true, 0, true, formatter, data);\n        for (int j = 0; j < exp_step; ++j) {\n            major1 = sign*ImPow(10, (double)(e+j));\n            major2 = sign*ImPow(10, (double)(e+j+1));\n            interval = (major2 - major1) / 9;\n            for (int i = 1; i < (9 + (int)(j < (exp_step - 1))); ++i) {\n                double minor = major1 + i * interval;\n                if (minor >= (range.Min - DBL_EPSILON) && minor <= (range.Max + DBL_EPSILON))\n                    ticker.AddTick(minor, false, 0, false, formatter, data);\n            }\n        }\n    }\n}\n\nvoid Locator_Log10(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {\n    int exp_min, exp_max, exp_step;\n    if (CalcLogarithmicExponents(range, pixels, vertical, exp_min, exp_max, exp_step))\n        AddTicksLogarithmic(range, exp_min, exp_max, exp_step, ticker, formatter, formatter_data);\n}\n\nfloat CalcSymLogPixel(double plt, const ImPlotRange& range, float pixels) {\n    double scaleToPixels = pixels / range.Size();\n    double scaleMin      = TransformForward_SymLog(range.Min,nullptr);\n    double scaleMax      = TransformForward_SymLog(range.Max,nullptr);\n    double s             = TransformForward_SymLog(plt, nullptr);\n    double t             = (s - scaleMin) / (scaleMax - scaleMin);\n    plt                  = range.Min + range.Size() * t;\n\n    return (float)(0 + scaleToPixels * (plt - range.Min));\n}\n\nvoid Locator_SymLog(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {\n    if (range.Min >= -1 && range.Max <= 1) {\n        Locator_Default(ticker, range, pixels, vertical, formatter, formatter_data);\n    }\n    else if (range.Min * range.Max < 0) { // cross zero\n        const float pix_min = 0;\n        const float pix_max = pixels;\n        const float pix_p1  = CalcSymLogPixel(1, range, pixels);\n        const float pix_n1  = CalcSymLogPixel(-1, range, pixels);\n        int exp_min_p, exp_max_p, exp_step_p;\n        int exp_min_n, exp_max_n, exp_step_n;\n        CalcLogarithmicExponents(ImPlotRange(1,range.Max), ImAbs(pix_max-pix_p1),vertical,exp_min_p,exp_max_p,exp_step_p);\n        CalcLogarithmicExponents(ImPlotRange(range.Min,-1),ImAbs(pix_n1-pix_min),vertical,exp_min_n,exp_max_n,exp_step_n);\n        int exp_step = ImMax(exp_step_n, exp_step_p);\n        ticker.AddTick(0,true,0,true,formatter,formatter_data);\n        AddTicksLogarithmic(ImPlotRange(1,range.Max), exp_min_p,exp_max_p,exp_step,ticker,formatter,formatter_data);\n        AddTicksLogarithmic(ImPlotRange(range.Min,-1),exp_min_n,exp_max_n,exp_step,ticker,formatter,formatter_data);\n    }\n    else {\n        Locator_Log10(ticker, range, pixels, vertical, formatter, formatter_data);\n    }\n}\n\nvoid AddTicksCustom(const double* values, const char* const labels[], int n, ImPlotTicker& ticker, ImPlotFormatter formatter, void* data) {\n    for (int i = 0; i < n; ++i) {\n        if (labels != nullptr)\n            ticker.AddTick(values[i], false, 0, true, labels[i]);\n        else\n            ticker.AddTick(values[i], false, 0, true, formatter, data);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Time Ticks and Utils\n//-----------------------------------------------------------------------------\n\n// this may not be thread safe?\nstatic const double TimeUnitSpans[ImPlotTimeUnit_COUNT] = {\n    0.000001,\n    0.001,\n    1,\n    60,\n    3600,\n    86400,\n    2629800,\n    31557600\n};\n\ninline ImPlotTimeUnit GetUnitForRange(double range) {\n    static double cutoffs[ImPlotTimeUnit_COUNT] = {0.001, 1, 60, 3600, 86400, 2629800, 31557600, IMPLOT_MAX_TIME};\n    for (int i = 0; i < ImPlotTimeUnit_COUNT; ++i) {\n        if (range <= cutoffs[i])\n            return (ImPlotTimeUnit)i;\n    }\n    return ImPlotTimeUnit_Yr;\n}\n\ninline int LowerBoundStep(int max_divs, const int* divs, const int* step, int size) {\n    if (max_divs < divs[0])\n        return 0;\n    for (int i = 1; i < size; ++i) {\n        if (max_divs < divs[i])\n            return step[i-1];\n    }\n    return step[size-1];\n}\n\ninline int GetTimeStep(int max_divs, ImPlotTimeUnit unit) {\n    if (unit == ImPlotTimeUnit_Ms || unit == ImPlotTimeUnit_Us) {\n        static const int step[] = {500,250,200,100,50,25,20,10,5,2,1};\n        static const int divs[] = {2,4,5,10,20,40,50,100,200,500,1000};\n        return LowerBoundStep(max_divs, divs, step, 11);\n    }\n    if (unit == ImPlotTimeUnit_S || unit == ImPlotTimeUnit_Min) {\n        static const int step[] = {30,15,10,5,1};\n        static const int divs[] = {2,4,6,12,60};\n        return LowerBoundStep(max_divs, divs, step, 5);\n    }\n    else if (unit == ImPlotTimeUnit_Hr) {\n        static const int step[] = {12,6,3,2,1};\n        static const int divs[] = {2,4,8,12,24};\n        return LowerBoundStep(max_divs, divs, step, 5);\n    }\n    else if (unit == ImPlotTimeUnit_Day) {\n        static const int step[] = {14,7,2,1};\n        static const int divs[] = {2,4,14,28};\n        return LowerBoundStep(max_divs, divs, step, 4);\n    }\n    else if (unit == ImPlotTimeUnit_Mo) {\n        static const int step[] = {6,3,2,1};\n        static const int divs[] = {2,4,6,12};\n        return LowerBoundStep(max_divs, divs, step, 4);\n    }\n    return 0;\n}\n\nImPlotTime MkGmtTime(struct tm *ptm) {\n    ImPlotTime t;\n#ifdef _WIN32\n    t.S = _mkgmtime(ptm);\n#else\n    t.S = timegm(ptm);\n#endif\n    if (t.S < 0)\n        t.S = 0;\n    return t;\n}\n\ntm* GetGmtTime(const ImPlotTime& t, tm* ptm)\n{\n#ifdef _WIN32\n  if (gmtime_s(ptm, &t.S) == 0)\n    return ptm;\n  else\n    return nullptr;\n#else\n  return gmtime_r(&t.S, ptm);\n#endif\n}\n\nImPlotTime MkLocTime(struct tm *ptm) {\n    ImPlotTime t;\n    t.S = mktime(ptm);\n    if (t.S < 0)\n        t.S = 0;\n    return t;\n}\n\ntm* GetLocTime(const ImPlotTime& t, tm* ptm) {\n#ifdef _WIN32\n  if (localtime_s(ptm, &t.S) == 0)\n    return ptm;\n  else\n    return nullptr;\n#else\n    return localtime_r(&t.S, ptm);\n#endif\n}\n\nImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec, int us) {\n    tm& Tm = GImPlot->Tm;\n\n    int yr = year - 1900;\n    if (yr < 0)\n        yr = 0;\n\n    sec  = sec + us / 1000000;\n    us   = us % 1000000;\n\n    Tm.tm_sec  = sec;\n    Tm.tm_min  = min;\n    Tm.tm_hour = hour;\n    Tm.tm_mday = day;\n    Tm.tm_mon  = month;\n    Tm.tm_year = yr;\n\n    ImPlotTime t = MkTime(&Tm);\n\n    t.Us = us;\n    return t;\n}\n\nint GetYear(const ImPlotTime& t) {\n    tm& Tm = GImPlot->Tm;\n    GetTime(t, &Tm);\n    return Tm.tm_year + 1900;\n}\n\nint GetMonth(const ImPlotTime& t) {\n    tm& Tm = GImPlot->Tm;\n    ImPlot::GetTime(t, &Tm);\n    return Tm.tm_mon;\n}\n\nImPlotTime AddTime(const ImPlotTime& t, ImPlotTimeUnit unit, int count) {\n    tm& Tm = GImPlot->Tm;\n    ImPlotTime t_out = t;\n    switch(unit) {\n        case ImPlotTimeUnit_Us:  t_out.Us += count;         break;\n        case ImPlotTimeUnit_Ms:  t_out.Us += count * 1000;  break;\n        case ImPlotTimeUnit_S:   t_out.S  += count;         break;\n        case ImPlotTimeUnit_Min: t_out.S  += count * 60;    break;\n        case ImPlotTimeUnit_Hr:  t_out.S  += count * 3600;  break;\n        case ImPlotTimeUnit_Day: t_out.S  += count * 86400; break;\n        case ImPlotTimeUnit_Mo:  for (int i = 0; i < abs(count); ++i) {\n                                     GetTime(t_out, &Tm);\n                                     if (count > 0)\n                                        t_out.S += 86400 * GetDaysInMonth(Tm.tm_year + 1900, Tm.tm_mon);\n                                     else if (count < 0)\n                                        t_out.S -= 86400 * GetDaysInMonth(Tm.tm_year + 1900 - (Tm.tm_mon == 0 ? 1 : 0), Tm.tm_mon == 0 ? 11 : Tm.tm_mon - 1); // NOT WORKING\n                                 }\n                                 break;\n        case ImPlotTimeUnit_Yr:  for (int i = 0; i < abs(count); ++i) {\n                                    if (count > 0)\n                                        t_out.S += 86400 * (365 + (int)IsLeapYear(GetYear(t_out)));\n                                    else if (count < 0)\n                                        t_out.S -= 86400 * (365 + (int)IsLeapYear(GetYear(t_out) - 1));\n                                    // this is incorrect if leap year and we are past Feb 28\n                                 }\n                                 break;\n        default:                 break;\n    }\n    t_out.RollOver();\n    return t_out;\n}\n\nImPlotTime FloorTime(const ImPlotTime& t, ImPlotTimeUnit unit) {\n    ImPlotContext& gp = *GImPlot;\n    GetTime(t, &gp.Tm);\n    switch (unit) {\n        case ImPlotTimeUnit_S:   return ImPlotTime(t.S, 0);\n        case ImPlotTimeUnit_Ms:  return ImPlotTime(t.S, (t.Us / 1000) * 1000);\n        case ImPlotTimeUnit_Us:  return t;\n        case ImPlotTimeUnit_Yr:  gp.Tm.tm_mon  = 0; // fall-through\n        case ImPlotTimeUnit_Mo:  gp.Tm.tm_mday = 1; // fall-through\n        case ImPlotTimeUnit_Day: gp.Tm.tm_hour = 0; // fall-through\n        case ImPlotTimeUnit_Hr:  gp.Tm.tm_min  = 0; // fall-through\n        case ImPlotTimeUnit_Min: gp.Tm.tm_sec  = 0; break;\n        default:                 return t;\n    }\n    return MkTime(&gp.Tm);\n}\n\nImPlotTime CeilTime(const ImPlotTime& t, ImPlotTimeUnit unit) {\n    return AddTime(FloorTime(t, unit), unit, 1);\n}\n\nImPlotTime RoundTime(const ImPlotTime& t, ImPlotTimeUnit unit) {\n    ImPlotTime t1 = FloorTime(t, unit);\n    ImPlotTime t2 = AddTime(t1,unit,1);\n    if (t1.S == t2.S)\n        return t.Us - t1.Us < t2.Us - t.Us ? t1 : t2;\n    return t.S - t1.S < t2.S - t.S ? t1 : t2;\n}\n\nImPlotTime CombineDateTime(const ImPlotTime& date_part, const ImPlotTime& tod_part) {\n    ImPlotContext& gp = *GImPlot;\n    tm& Tm = gp.Tm;\n    GetTime(date_part, &gp.Tm);\n    int y = Tm.tm_year;\n    int m = Tm.tm_mon;\n    int d = Tm.tm_mday;\n    GetTime(tod_part, &gp.Tm);\n    Tm.tm_year = y;\n    Tm.tm_mon  = m;\n    Tm.tm_mday = d;\n    ImPlotTime t = MkTime(&Tm);\n    t.Us = tod_part.Us;\n    return t;\n}\n\n// TODO: allow users to define these\nstatic const char* MONTH_NAMES[]  = {\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\nstatic const char* WD_ABRVS[]     = {\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"};\nstatic const char* MONTH_ABRVS[]  = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\n\nint FormatTime(const ImPlotTime& t, char* buffer, int size, ImPlotTimeFmt fmt, bool use_24_hr_clk) {\n    tm& Tm = GImPlot->Tm;\n    GetTime(t, &Tm);\n    const int us   = t.Us % 1000;\n    const int ms   = t.Us / 1000;\n    const int sec  = Tm.tm_sec;\n    const int min  = Tm.tm_min;\n    if (use_24_hr_clk) {\n        const int hr   = Tm.tm_hour;\n        switch(fmt) {\n            case ImPlotTimeFmt_Us:        return ImFormatString(buffer, size, \".%03d %03d\", ms, us);\n            case ImPlotTimeFmt_SUs:       return ImFormatString(buffer, size, \":%02d.%03d %03d\", sec, ms, us);\n            case ImPlotTimeFmt_SMs:       return ImFormatString(buffer, size, \":%02d.%03d\", sec, ms);\n            case ImPlotTimeFmt_S:         return ImFormatString(buffer, size, \":%02d\", sec);\n            case ImPlotTimeFmt_MinSMs:    return ImFormatString(buffer, size, \":%02d:%02d.%03d\", min, sec, ms);\n            case ImPlotTimeFmt_HrMinSMs:  return ImFormatString(buffer, size, \"%02d:%02d:%02d.%03d\", hr, min, sec, ms);\n            case ImPlotTimeFmt_HrMinS:    return ImFormatString(buffer, size, \"%02d:%02d:%02d\", hr, min, sec);\n            case ImPlotTimeFmt_HrMin:     return ImFormatString(buffer, size, \"%02d:%02d\", hr, min);\n            case ImPlotTimeFmt_Hr:        return ImFormatString(buffer, size, \"%02d:00\", hr);\n            default:                      return 0;\n        }\n    }\n    else {\n        const char* ap = Tm.tm_hour < 12 ? \"am\" : \"pm\";\n        const int hr   = (Tm.tm_hour == 0 || Tm.tm_hour == 12) ? 12 : Tm.tm_hour % 12;\n        switch(fmt) {\n            case ImPlotTimeFmt_Us:        return ImFormatString(buffer, size, \".%03d %03d\", ms, us);\n            case ImPlotTimeFmt_SUs:       return ImFormatString(buffer, size, \":%02d.%03d %03d\", sec, ms, us);\n            case ImPlotTimeFmt_SMs:       return ImFormatString(buffer, size, \":%02d.%03d\", sec, ms);\n            case ImPlotTimeFmt_S:         return ImFormatString(buffer, size, \":%02d\", sec);\n            case ImPlotTimeFmt_MinSMs:    return ImFormatString(buffer, size, \":%02d:%02d.%03d\", min, sec, ms);\n            case ImPlotTimeFmt_HrMinSMs:  return ImFormatString(buffer, size, \"%d:%02d:%02d.%03d%s\", hr, min, sec, ms, ap);\n            case ImPlotTimeFmt_HrMinS:    return ImFormatString(buffer, size, \"%d:%02d:%02d%s\", hr, min, sec, ap);\n            case ImPlotTimeFmt_HrMin:     return ImFormatString(buffer, size, \"%d:%02d%s\", hr, min, ap);\n            case ImPlotTimeFmt_Hr:        return ImFormatString(buffer, size, \"%d%s\", hr, ap);\n            default:                      return 0;\n        }\n    }\n}\n\nint FormatDate(const ImPlotTime& t, char* buffer, int size, ImPlotDateFmt fmt, bool use_iso_8601) {\n    tm& Tm = GImPlot->Tm;\n    GetTime(t, &Tm);\n    const int day  = Tm.tm_mday;\n    const int mon  = Tm.tm_mon + 1;\n    const int year = Tm.tm_year + 1900;\n    const int yr   = year % 100;\n    if (use_iso_8601) {\n        switch (fmt) {\n            case ImPlotDateFmt_DayMo:   return ImFormatString(buffer, size, \"--%02d-%02d\", mon, day);\n            case ImPlotDateFmt_DayMoYr: return ImFormatString(buffer, size, \"%d-%02d-%02d\", year, mon, day);\n            case ImPlotDateFmt_MoYr:    return ImFormatString(buffer, size, \"%d-%02d\", year, mon);\n            case ImPlotDateFmt_Mo:      return ImFormatString(buffer, size, \"--%02d\", mon);\n            case ImPlotDateFmt_Yr:      return ImFormatString(buffer, size, \"%d\", year);\n            default:                    return 0;\n        }\n    }\n    else {\n        switch (fmt) {\n            case ImPlotDateFmt_DayMo:   return ImFormatString(buffer, size, \"%d/%d\", mon, day);\n            case ImPlotDateFmt_DayMoYr: return ImFormatString(buffer, size, \"%d/%d/%02d\", mon, day, yr);\n            case ImPlotDateFmt_MoYr:    return ImFormatString(buffer, size, \"%s %d\", MONTH_ABRVS[Tm.tm_mon], year);\n            case ImPlotDateFmt_Mo:      return ImFormatString(buffer, size, \"%s\", MONTH_ABRVS[Tm.tm_mon]);\n            case ImPlotDateFmt_Yr:      return ImFormatString(buffer, size, \"%d\", year);\n            default:                    return 0;\n        }\n    }\n }\n\nint FormatDateTime(const ImPlotTime& t, char* buffer, int size, ImPlotDateTimeSpec fmt) {\n    int written = 0;\n    if (fmt.Date != ImPlotDateFmt_None)\n        written += FormatDate(t, buffer, size, fmt.Date, fmt.UseISO8601);\n    if (fmt.Time != ImPlotTimeFmt_None) {\n        if (fmt.Date != ImPlotDateFmt_None)\n            buffer[written++] = ' ';\n        written += FormatTime(t, &buffer[written], size - written, fmt.Time, fmt.Use24HourClock);\n    }\n    return written;\n}\n\ninline float GetDateTimeWidth(ImPlotDateTimeSpec fmt) {\n    static const ImPlotTime t_max_width = MakeTime(2888, 12, 22, 12, 58, 58, 888888); // best guess at time that maximizes pixel width\n    char buffer[32];\n    FormatDateTime(t_max_width, buffer, 32, fmt);\n    return ImGui::CalcTextSize(buffer).x;\n}\n\ninline bool TimeLabelSame(const char* l1, const char* l2) {\n    size_t len1 = strlen(l1);\n    size_t len2 = strlen(l2);\n    size_t n  = len1 < len2 ? len1 : len2;\n    return strcmp(l1 + len1 - n, l2 + len2 - n) == 0;\n}\n\nstatic const ImPlotDateTimeSpec TimeFormatLevel0[ImPlotTimeUnit_COUNT] = {\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_Us),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_SMs),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_S),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_Hr),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMo, ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Mo,    ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,    ImPlotTimeFmt_None)\n};\n\nstatic const ImPlotDateTimeSpec TimeFormatLevel1[ImPlotTimeUnit_COUNT] = {\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMinS),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None)\n};\n\nstatic const ImPlotDateTimeSpec TimeFormatLevel1First[ImPlotTimeUnit_COUNT] = {\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMinS),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMinS),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None)\n};\n\nstatic const ImPlotDateTimeSpec TimeFormatMouseCursor[ImPlotTimeUnit_COUNT] = {\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_Us),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_SUs),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_SMs),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_HrMinS),\n    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_HrMin),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMo,    ImPlotTimeFmt_Hr),\n    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr,  ImPlotTimeFmt_None),\n    ImPlotDateTimeSpec(ImPlotDateFmt_MoYr,     ImPlotTimeFmt_None)\n};\n\ninline ImPlotDateTimeSpec GetDateTimeFmt(const ImPlotDateTimeSpec* ctx, ImPlotTimeUnit idx) {\n    ImPlotStyle& style     = GetStyle();\n    ImPlotDateTimeSpec fmt  = ctx[idx];\n    fmt.UseISO8601         = style.UseISO8601;\n    fmt.Use24HourClock     = style.Use24HourClock;\n    return fmt;\n}\n\nvoid Locator_Time(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {\n    IM_ASSERT_USER_ERROR(vertical == false, \"Cannot locate Time ticks on vertical axis!\");\n    (void)vertical;\n    // get units for level 0 and level 1 labels\n    const ImPlotTimeUnit unit0 = GetUnitForRange(range.Size() / (pixels / 100)); // level = 0 (top)\n    const ImPlotTimeUnit unit1 = ImClamp(unit0 + 1, 0, ImPlotTimeUnit_COUNT-1);  // level = 1 (bottom)\n    // get time format specs\n    const ImPlotDateTimeSpec fmt0 = GetDateTimeFmt(TimeFormatLevel0, unit0);\n    const ImPlotDateTimeSpec fmt1 = GetDateTimeFmt(TimeFormatLevel1, unit1);\n    const ImPlotDateTimeSpec fmtf = GetDateTimeFmt(TimeFormatLevel1First, unit1);\n    // min max times\n    const ImPlotTime t_min = ImPlotTime::FromDouble(range.Min);\n    const ImPlotTime t_max = ImPlotTime::FromDouble(range.Max);\n    // maximum allowable density of labels\n    const float max_density = 0.5f;\n    // book keeping\n    int last_major_offset = -1;\n    // formatter data\n    Formatter_Time_Data ftd;\n    ftd.UserFormatter = formatter;\n    ftd.UserFormatterData = formatter_data;\n    if (unit0 != ImPlotTimeUnit_Yr) {\n        // pixels per major (level 1) division\n        const float pix_per_major_div = pixels / (float)(range.Size() / TimeUnitSpans[unit1]);\n        // nominal pixels taken up by labels\n        const float fmt0_width = GetDateTimeWidth(fmt0);\n        const float fmt1_width = GetDateTimeWidth(fmt1);\n        const float fmtf_width = GetDateTimeWidth(fmtf);\n        // the maximum number of minor (level 0) labels that can fit between major (level 1) divisions\n        const int   minor_per_major   = (int)(max_density * pix_per_major_div / fmt0_width);\n        // the minor step size (level 0)\n        const int step = GetTimeStep(minor_per_major, unit0);\n        // generate ticks\n        ImPlotTime t1 = FloorTime(ImPlotTime::FromDouble(range.Min), unit1);\n        while (t1 < t_max) {\n            // get next major\n            const ImPlotTime t2 = AddTime(t1, unit1, 1);\n            // add major tick\n            if (t1 >= t_min && t1 <= t_max) {\n                // minor level 0 tick\n                ftd.Time = t1; ftd.Spec = fmt0;\n                ticker.AddTick(t1.ToDouble(), true, 0, true, Formatter_Time, &ftd);\n                // major level 1 tick\n                ftd.Time = t1; ftd.Spec = last_major_offset < 0 ? fmtf : fmt1;\n                ImPlotTick& tick_maj = ticker.AddTick(t1.ToDouble(), true, 1, true, Formatter_Time, &ftd);\n                const char* this_major = ticker.GetText(tick_maj);\n                if (last_major_offset >= 0 && TimeLabelSame(ticker.TextBuffer.Buf.Data + last_major_offset, this_major))\n                    tick_maj.ShowLabel = false;\n                last_major_offset = tick_maj.TextOffset;\n            }\n            // add minor ticks up until next major\n            if (minor_per_major > 1 && (t_min <= t2 && t1 <= t_max)) {\n                ImPlotTime t12 = AddTime(t1, unit0, step);\n                while (t12 < t2) {\n                    float px_to_t2 = (float)((t2 - t12).ToDouble()/range.Size()) * pixels;\n                    if (t12 >= t_min && t12 <= t_max) {\n                        ftd.Time = t12; ftd.Spec = fmt0;\n                        ticker.AddTick(t12.ToDouble(), false, 0, px_to_t2 >= fmt0_width, Formatter_Time, &ftd);\n                        if (last_major_offset < 0 && px_to_t2 >= fmt0_width && px_to_t2 >= (fmt1_width + fmtf_width) / 2) {\n                            ftd.Time = t12; ftd.Spec = fmtf;\n                            ImPlotTick& tick_maj = ticker.AddTick(t12.ToDouble(), true, 1, true, Formatter_Time, &ftd);\n                            last_major_offset = tick_maj.TextOffset;\n                        }\n                    }\n                    t12 = AddTime(t12, unit0, step);\n                }\n            }\n            t1 = t2;\n        }\n    }\n    else {\n        const ImPlotDateTimeSpec fmty = GetDateTimeFmt(TimeFormatLevel0, ImPlotTimeUnit_Yr);\n        const float label_width = GetDateTimeWidth(fmty);\n        const int   max_labels  = (int)(max_density * pixels / label_width);\n        const int year_min      = GetYear(t_min);\n        const int year_max      = GetYear(CeilTime(t_max, ImPlotTimeUnit_Yr));\n        const double nice_range = NiceNum((year_max - year_min)*0.99,false);\n        const double interval   = NiceNum(nice_range / (max_labels - 1), true);\n        const int graphmin      = (int)(floor(year_min / interval) * interval);\n        const int graphmax      = (int)(ceil(year_max  / interval) * interval);\n        const int step          = (int)interval <= 0 ? 1 : (int)interval;\n\n        for (int y = graphmin; y < graphmax; y += step) {\n            ImPlotTime t = MakeTime(y);\n            if (t >= t_min && t <= t_max) {\n                ftd.Time = t; ftd.Spec = fmty;\n                ticker.AddTick(t.ToDouble(), true, 0, true, Formatter_Time, &ftd);\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Context Menu\n//-----------------------------------------------------------------------------\n\ntemplate <typename F>\nbool DragFloat(const char*, F*, float, F, F) {\n    return false;\n}\n\ntemplate <>\nbool DragFloat<double>(const char* label, double* v, float v_speed, double v_min, double v_max) {\n    return ImGui::DragScalar(label, ImGuiDataType_Double, v, v_speed, &v_min, &v_max, \"%.3g\", 1);\n}\n\ntemplate <>\nbool DragFloat<float>(const char* label, float* v, float v_speed, float v_min, float v_max) {\n    return ImGui::DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, \"%.3g\", 1);\n}\n\ninline void BeginDisabledControls(bool cond) {\n    if (cond) {\n        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);\n        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.25f);\n    }\n}\n\ninline void EndDisabledControls(bool cond) {\n    if (cond) {\n        ImGui::PopItemFlag();\n        ImGui::PopStyleVar();\n    }\n}\n\nvoid ShowAxisContextMenu(ImPlotAxis& axis, ImPlotAxis* equal_axis, bool /*time_allowed*/) {\n\n    ImGui::PushItemWidth(75);\n    bool always_locked   = axis.IsRangeLocked() || axis.IsAutoFitting();\n    bool label           = axis.HasLabel();\n    bool grid            = axis.HasGridLines();\n    bool ticks           = axis.HasTickMarks();\n    bool labels          = axis.HasTickLabels();\n    double drag_speed    = (axis.Range.Size() <= DBL_EPSILON) ? DBL_EPSILON * 1.0e+13 : 0.01 * axis.Range.Size(); // recover from almost equal axis limits.\n\n    if (axis.Scale == ImPlotScale_Time) {\n        ImPlotTime tmin = ImPlotTime::FromDouble(axis.Range.Min);\n        ImPlotTime tmax = ImPlotTime::FromDouble(axis.Range.Max);\n\n        BeginDisabledControls(always_locked);\n        ImGui::CheckboxFlags(\"##LockMin\", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMin);\n        EndDisabledControls(always_locked);\n        ImGui::SameLine();\n        BeginDisabledControls(axis.IsLockedMin() || always_locked);\n        if (ImGui::BeginMenu(\"Min Time\")) {\n            if (ShowTimePicker(\"mintime\", &tmin)) {\n                if (tmin >= tmax)\n                    tmax = AddTime(tmin, ImPlotTimeUnit_S, 1);\n                axis.SetRange(tmin.ToDouble(),tmax.ToDouble());\n            }\n            ImGui::Separator();\n            if (ShowDatePicker(\"mindate\",&axis.PickerLevel,&axis.PickerTimeMin,&tmin,&tmax)) {\n                tmin = CombineDateTime(axis.PickerTimeMin, tmin);\n                if (tmin >= tmax)\n                    tmax = AddTime(tmin, ImPlotTimeUnit_S, 1);\n                axis.SetRange(tmin.ToDouble(), tmax.ToDouble());\n            }\n            ImGui::EndMenu();\n        }\n        EndDisabledControls(axis.IsLockedMin() || always_locked);\n\n        BeginDisabledControls(always_locked);\n        ImGui::CheckboxFlags(\"##LockMax\", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMax);\n        EndDisabledControls(always_locked);\n        ImGui::SameLine();\n        BeginDisabledControls(axis.IsLockedMax() || always_locked);\n        if (ImGui::BeginMenu(\"Max Time\")) {\n            if (ShowTimePicker(\"maxtime\", &tmax)) {\n                if (tmax <= tmin)\n                    tmin = AddTime(tmax, ImPlotTimeUnit_S, -1);\n                axis.SetRange(tmin.ToDouble(),tmax.ToDouble());\n            }\n            ImGui::Separator();\n            if (ShowDatePicker(\"maxdate\",&axis.PickerLevel,&axis.PickerTimeMax,&tmin,&tmax)) {\n                tmax = CombineDateTime(axis.PickerTimeMax, tmax);\n                if (tmax <= tmin)\n                    tmin = AddTime(tmax, ImPlotTimeUnit_S, -1);\n                axis.SetRange(tmin.ToDouble(), tmax.ToDouble());\n            }\n            ImGui::EndMenu();\n        }\n        EndDisabledControls(axis.IsLockedMax() || always_locked);\n    }\n    else {\n        BeginDisabledControls(always_locked);\n        ImGui::CheckboxFlags(\"##LockMin\", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMin);\n        EndDisabledControls(always_locked);\n        ImGui::SameLine();\n        BeginDisabledControls(axis.IsLockedMin() || always_locked);\n        double temp_min = axis.Range.Min;\n        if (DragFloat(\"Min\", &temp_min, (float)drag_speed, -HUGE_VAL, axis.Range.Max - DBL_EPSILON)) {\n            axis.SetMin(temp_min,true);\n            if (equal_axis != nullptr)\n                equal_axis->SetAspect(axis.GetAspect());\n        }\n        EndDisabledControls(axis.IsLockedMin() || always_locked);\n\n        BeginDisabledControls(always_locked);\n        ImGui::CheckboxFlags(\"##LockMax\", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMax);\n        EndDisabledControls(always_locked);\n        ImGui::SameLine();\n        BeginDisabledControls(axis.IsLockedMax() || always_locked);\n        double temp_max = axis.Range.Max;\n        if (DragFloat(\"Max\", &temp_max, (float)drag_speed, axis.Range.Min + DBL_EPSILON, HUGE_VAL)) {\n            axis.SetMax(temp_max,true);\n            if (equal_axis != nullptr)\n                equal_axis->SetAspect(axis.GetAspect());\n        }\n        EndDisabledControls(axis.IsLockedMax() || always_locked);\n    }\n\n    ImGui::Separator();\n\n    ImGui::CheckboxFlags(\"Auto-Fit\",(unsigned int*)&axis.Flags, ImPlotAxisFlags_AutoFit);\n    // TODO\n    // BeginDisabledControls(axis.IsTime() && time_allowed);\n    // ImGui::CheckboxFlags(\"Log Scale\",(unsigned int*)&axis.Flags, ImPlotAxisFlags_LogScale);\n    // EndDisabledControls(axis.IsTime() && time_allowed);\n    // if (time_allowed) {\n    //     BeginDisabledControls(axis.IsLog() || axis.IsSymLog());\n    //     ImGui::CheckboxFlags(\"Time\",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Time);\n    //     EndDisabledControls(axis.IsLog() || axis.IsSymLog());\n    // }\n    ImGui::Separator();\n    ImGui::CheckboxFlags(\"Invert\",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Invert);\n    ImGui::CheckboxFlags(\"Opposite\",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Opposite);\n    ImGui::Separator();\n    BeginDisabledControls(axis.LabelOffset == -1);\n    if (ImGui::Checkbox(\"Label\", &label))\n        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoLabel);\n    EndDisabledControls(axis.LabelOffset == -1);\n    if (ImGui::Checkbox(\"Grid Lines\", &grid))\n        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoGridLines);\n    if (ImGui::Checkbox(\"Tick Marks\", &ticks))\n        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoTickMarks);\n    if (ImGui::Checkbox(\"Tick Labels\", &labels))\n        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoTickLabels);\n\n}\n\nbool ShowLegendContextMenu(ImPlotLegend& legend, bool visible) {\n    const float s = ImGui::GetFrameHeight();\n    bool ret = false;\n    if (ImGui::Checkbox(\"Show\",&visible))\n        ret = true;\n    if (legend.CanGoInside)\n        ImGui::CheckboxFlags(\"Outside\",(unsigned int*)&legend.Flags, ImPlotLegendFlags_Outside);\n    if (ImGui::RadioButton(\"H\", ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal)))\n        legend.Flags |= ImPlotLegendFlags_Horizontal;\n    ImGui::SameLine();\n    if (ImGui::RadioButton(\"V\", !ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal)))\n        legend.Flags &= ~ImPlotLegendFlags_Horizontal;\n    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2,2));\n    if (ImGui::Button(\"NW\",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_NorthWest; } ImGui::SameLine();\n    if (ImGui::Button(\"N\", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_North;     } ImGui::SameLine();\n    if (ImGui::Button(\"NE\",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_NorthEast; }\n    if (ImGui::Button(\"W\", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_West;      } ImGui::SameLine();\n    if (ImGui::InvisibleButton(\"C\", ImVec2(1.5f*s,s))) {     } ImGui::SameLine();\n    if (ImGui::Button(\"E\", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_East;      }\n    if (ImGui::Button(\"SW\",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_SouthWest; } ImGui::SameLine();\n    if (ImGui::Button(\"S\", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_South;     } ImGui::SameLine();\n    if (ImGui::Button(\"SE\",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_SouthEast; }\n    ImGui::PopStyleVar();\n    return ret;\n}\n\nvoid ShowSubplotsContextMenu(ImPlotSubplot& subplot) {\n    if ((ImGui::BeginMenu(\"Linking\"))) {\n        if (ImGui::MenuItem(\"Link Rows\",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows);\n        if (ImGui::MenuItem(\"Link Cols\",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols);\n        if (ImGui::MenuItem(\"Link All X\",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX);\n        if (ImGui::MenuItem(\"Link All Y\",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY);\n        ImGui::EndMenu();\n    }\n    if ((ImGui::BeginMenu(\"Settings\"))) {\n        BeginDisabledControls(!subplot.HasTitle);\n        if (ImGui::MenuItem(\"Title\",nullptr,subplot.HasTitle && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle);\n        EndDisabledControls(!subplot.HasTitle);\n        if (ImGui::MenuItem(\"Resizable\",nullptr,!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoResize)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoResize);\n        if (ImGui::MenuItem(\"Align\",nullptr,!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign);\n        if (ImGui::MenuItem(\"Share Items\",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems)))\n            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);\n        ImGui::EndMenu();\n    }\n}\n\nvoid ShowPlotContextMenu(ImPlotPlot& plot) {\n    ImPlotContext& gp = *GImPlot;\n    const bool owns_legend = gp.CurrentItems == &plot.Items;\n    const bool equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);\n\n    char buf[16] = {};\n\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        ImPlotAxis& x_axis = plot.XAxis(i);\n        if (!x_axis.Enabled || !x_axis.HasMenus())\n            continue;\n        ImGui::PushID(i);\n        ImFormatString(buf, sizeof(buf) - 1, i == 0 ? \"X-Axis\" : \"X-Axis %d\", i + 1);\n        if (ImGui::BeginMenu(x_axis.HasLabel() ? plot.GetAxisLabel(x_axis) : buf)) {\n            ShowAxisContextMenu(x_axis, equal ? x_axis.OrthoAxis : nullptr, false);\n            ImGui::EndMenu();\n        }\n        ImGui::PopID();\n    }\n\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        ImPlotAxis& y_axis = plot.YAxis(i);\n        if (!y_axis.Enabled || !y_axis.HasMenus())\n            continue;\n        ImGui::PushID(i);\n        ImFormatString(buf, sizeof(buf) - 1, i == 0 ? \"Y-Axis\" : \"Y-Axis %d\", i + 1);\n        if (ImGui::BeginMenu(y_axis.HasLabel() ? plot.GetAxisLabel(y_axis) : buf)) {\n            ShowAxisContextMenu(y_axis, equal ? y_axis.OrthoAxis : nullptr, false);\n            ImGui::EndMenu();\n        }\n        ImGui::PopID();\n    }\n\n    ImGui::Separator();\n    if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoMenus)) {\n        if ((ImGui::BeginMenu(\"Legend\"))) {\n            if (owns_legend) {\n                if (ShowLegendContextMenu(plot.Items.Legend, !ImHasFlag(plot.Flags, ImPlotFlags_NoLegend)))\n                    ImFlipFlag(plot.Flags, ImPlotFlags_NoLegend);\n            }\n            else if (gp.CurrentSubplot != nullptr) {\n                if (ShowLegendContextMenu(gp.CurrentSubplot->Items.Legend, !ImHasFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoLegend)))\n                    ImFlipFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoLegend);\n            }\n            ImGui::EndMenu();\n        }\n    }\n    if ((ImGui::BeginMenu(\"Settings\"))) {\n        if (ImGui::MenuItem(\"Equal\", nullptr, ImHasFlag(plot.Flags, ImPlotFlags_Equal)))\n            ImFlipFlag(plot.Flags, ImPlotFlags_Equal);\n        if (ImGui::MenuItem(\"Box Select\",nullptr,!ImHasFlag(plot.Flags, ImPlotFlags_NoBoxSelect)))\n            ImFlipFlag(plot.Flags, ImPlotFlags_NoBoxSelect);\n        BeginDisabledControls(plot.TitleOffset == -1);\n        if (ImGui::MenuItem(\"Title\",nullptr,plot.HasTitle()))\n            ImFlipFlag(plot.Flags, ImPlotFlags_NoTitle);\n        EndDisabledControls(plot.TitleOffset == -1);\n        if (ImGui::MenuItem(\"Mouse Position\",nullptr,!ImHasFlag(plot.Flags, ImPlotFlags_NoMouseText)))\n            ImFlipFlag(plot.Flags, ImPlotFlags_NoMouseText);\n        if (ImGui::MenuItem(\"Crosshairs\",nullptr,ImHasFlag(plot.Flags, ImPlotFlags_Crosshairs)))\n            ImFlipFlag(plot.Flags, ImPlotFlags_Crosshairs);\n        ImGui::EndMenu();\n    }\n    if (gp.CurrentSubplot != nullptr && !ImHasFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoMenus)) {\n        ImGui::Separator();\n        if ((ImGui::BeginMenu(\"Subplots\"))) {\n            ShowSubplotsContextMenu(*gp.CurrentSubplot);\n            ImGui::EndMenu();\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Axis Utils\n//-----------------------------------------------------------------------------\n\nstatic inline int AxisPrecision(const ImPlotAxis& axis) {\n    const double range = axis.Ticker.TickCount() > 1 ? (axis.Ticker.Ticks[1].PlotPos - axis.Ticker.Ticks[0].PlotPos) : axis.Range.Size();\n    return Precision(range);\n}\n\nstatic inline double RoundAxisValue(const ImPlotAxis& axis, double value) {\n    return RoundTo(value, AxisPrecision(axis));\n}\n\nvoid LabelAxisValue(const ImPlotAxis& axis, double value, char* buff, int size, bool round) {\n    ImPlotContext& gp = *GImPlot;\n    // TODO: We shouldn't explicitly check that the axis is Time here. Ideally,\n    // Formatter_Time would handle the formatting for us, but the code below\n    // needs additional arguments which are not currently available in ImPlotFormatter\n    if (axis.Locator == Locator_Time) {\n        ImPlotTimeUnit unit = axis.Vertical\n                            ? GetUnitForRange(axis.Range.Size() / (gp.CurrentPlot->PlotRect.GetHeight() / 100)) // TODO: magic value!\n                            : GetUnitForRange(axis.Range.Size() / (gp.CurrentPlot->PlotRect.GetWidth() / 100)); // TODO: magic value!\n        FormatDateTime(ImPlotTime::FromDouble(value), buff, size, GetDateTimeFmt(TimeFormatMouseCursor, unit));\n    }\n    else {\n        if (round)\n            value = RoundAxisValue(axis, value);\n        axis.Formatter(value, buff, size, axis.FormatterData);\n    }\n}\n\nvoid UpdateAxisColors(ImPlotAxis& axis) {\n    const ImVec4 col_grid = GetStyleColorVec4(ImPlotCol_AxisGrid);\n    axis.ColorMaj         = ImGui::GetColorU32(col_grid);\n    axis.ColorMin         = ImGui::GetColorU32(col_grid*ImVec4(1,1,1,GImPlot->Style.MinorAlpha));\n    axis.ColorTick        = GetStyleColorU32(ImPlotCol_AxisTick);\n    axis.ColorTxt         = GetStyleColorU32(ImPlotCol_AxisText);\n    axis.ColorBg          = GetStyleColorU32(ImPlotCol_AxisBg);\n    axis.ColorHov         = GetStyleColorU32(ImPlotCol_AxisBgHovered);\n    axis.ColorAct         = GetStyleColorU32(ImPlotCol_AxisBgActive);\n    // axis.ColorHiLi     = IM_COL32_BLACK_TRANS;\n}\n\nvoid PadAndDatumAxesX(ImPlotPlot& plot, float& pad_T, float& pad_B, ImPlotAlignmentData* align) {\n\n    ImPlotContext& gp = *GImPlot;\n\n    const float T = ImGui::GetTextLineHeight();\n    const float P = gp.Style.LabelPadding.y;\n    const float K = gp.Style.MinorTickLen.x;\n\n    int   count_T = 0;\n    int   count_B = 0;\n    float last_T  = plot.AxesRect.Min.y;\n    float last_B  = plot.AxesRect.Max.y;\n\n    for (int i = IMPLOT_NUM_X_AXES; i-- > 0;) { // FYI: can iterate forward\n        ImPlotAxis& axis = plot.XAxis(i);\n        if (!axis.Enabled)\n            continue;\n        const bool label = axis.HasLabel();\n        const bool ticks = axis.HasTickLabels();\n        const bool opp   = axis.IsOpposite();\n        const bool time  = axis.Scale == ImPlotScale_Time;\n        if (opp) {\n            if (count_T++ > 0)\n                pad_T += K + P;\n            if (label)\n                pad_T += T + P;\n            if (ticks)\n                pad_T += ImMax(T, axis.Ticker.MaxSize.y) + P + (time ? T + P : 0);\n            axis.Datum1 = plot.CanvasRect.Min.y + pad_T;\n            axis.Datum2 = last_T;\n            last_T = axis.Datum1;\n        }\n        else {\n            if (count_B++ > 0)\n                pad_B += K + P;\n            if (label)\n                pad_B += T + P;\n            if (ticks)\n                pad_B += ImMax(T, axis.Ticker.MaxSize.y) + P + (time ? T + P : 0);\n            axis.Datum1 = plot.CanvasRect.Max.y - pad_B;\n            axis.Datum2 = last_B;\n            last_B = axis.Datum1;\n        }\n    }\n\n    if (align) {\n        count_T = count_B = 0;\n        float delta_T, delta_B;\n        align->Update(pad_T,pad_B,delta_T,delta_B);\n        for (int i = IMPLOT_NUM_X_AXES; i-- > 0;) {\n            ImPlotAxis& axis = plot.XAxis(i);\n            if (!axis.Enabled)\n                continue;\n            if (axis.IsOpposite()) {\n                axis.Datum1 += delta_T;\n                axis.Datum2 += count_T++ > 1 ? delta_T : 0;\n            }\n            else {\n                axis.Datum1 -= delta_B;\n                axis.Datum2 -= count_B++ > 1 ? delta_B : 0;\n            }\n        }\n    }\n}\n\nvoid PadAndDatumAxesY(ImPlotPlot& plot, float& pad_L, float& pad_R, ImPlotAlignmentData* align) {\n\n    //   [   pad_L   ]                 [   pad_R   ]\n    //   .................CanvasRect................\n    //   :TPWPK.PTPWP _____PlotRect____ PWPTP.KPWPT:\n    //   :A # |- A # |-               -| # A -| # A:\n    //   :X   |  X   |                 |   X  |   x:\n    //   :I # |- I # |-               -| # I -| # I:\n    //   :S   |  S   |                 |   S  |   S:\n    //   :3 # |- 0 # |-_______________-| # 1 -| # 2:\n    //   :.........................................:\n    //\n    //   T = text height\n    //   P = label padding\n    //   K = minor tick length\n    //   W = label width\n\n    ImPlotContext& gp = *GImPlot;\n\n    const float T = ImGui::GetTextLineHeight();\n    const float P = gp.Style.LabelPadding.x;\n    const float K = gp.Style.MinorTickLen.y;\n\n    int   count_L = 0;\n    int   count_R = 0;\n    float last_L  = plot.AxesRect.Min.x;\n    float last_R  = plot.AxesRect.Max.x;\n\n    for (int i = IMPLOT_NUM_Y_AXES; i-- > 0;) { // FYI: can iterate forward\n        ImPlotAxis& axis = plot.YAxis(i);\n        if (!axis.Enabled)\n            continue;\n        const bool label = axis.HasLabel();\n        const bool ticks = axis.HasTickLabels();\n        const bool opp   = axis.IsOpposite();\n        if (opp) {\n            if (count_R++ > 0)\n                pad_R += K + P;\n            if (label)\n                pad_R += T + P;\n            if (ticks)\n                pad_R += axis.Ticker.MaxSize.x + P;\n            axis.Datum1 = plot.CanvasRect.Max.x - pad_R;\n            axis.Datum2 = last_R;\n            last_R = axis.Datum1;\n        }\n        else {\n            if (count_L++ > 0)\n                pad_L += K + P;\n            if (label)\n                pad_L += T + P;\n            if (ticks)\n                pad_L += axis.Ticker.MaxSize.x + P;\n            axis.Datum1 = plot.CanvasRect.Min.x + pad_L;\n            axis.Datum2 = last_L;\n            last_L = axis.Datum1;\n        }\n    }\n\n    plot.PlotRect.Min.x = plot.CanvasRect.Min.x + pad_L;\n    plot.PlotRect.Max.x = plot.CanvasRect.Max.x - pad_R;\n\n    if (align) {\n        count_L = count_R = 0;\n        float delta_L, delta_R;\n        align->Update(pad_L,pad_R,delta_L,delta_R);\n        for (int i = IMPLOT_NUM_Y_AXES; i-- > 0;) {\n            ImPlotAxis& axis = plot.YAxis(i);\n            if (!axis.Enabled)\n                continue;\n            if (axis.IsOpposite()) {\n                axis.Datum1 -= delta_R;\n                axis.Datum2 -= count_R++ > 1 ? delta_R : 0;\n            }\n            else {\n                axis.Datum1 += delta_L;\n                axis.Datum2 += count_L++ > 1 ? delta_L : 0;\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// RENDERING\n//-----------------------------------------------------------------------------\n\nstatic inline void RenderGridLinesX(ImDrawList& DrawList, const ImPlotTicker& ticker, const ImRect& rect, ImU32 col_maj, ImU32 col_min, float size_maj, float size_min) {\n    const float density   = ticker.TickCount() / rect.GetWidth();\n    ImVec4 col_min4  = ImGui::ColorConvertU32ToFloat4(col_min);\n    col_min4.w      *= ImClamp(ImRemap(density, 0.1f, 0.2f, 1.0f, 0.0f), 0.0f, 1.0f);\n    col_min = ImGui::ColorConvertFloat4ToU32(col_min4);\n    for (int t = 0; t < ticker.TickCount(); t++) {\n        const ImPlotTick& xt = ticker.Ticks[t];\n        if (xt.PixelPos < rect.Min.x || xt.PixelPos > rect.Max.x)\n            continue;\n        if (xt.Level == 0) {\n            if (xt.Major)\n                DrawList.AddLine(ImVec2(xt.PixelPos, rect.Min.y), ImVec2(xt.PixelPos, rect.Max.y), col_maj, size_maj);\n            else if (density < 0.2f)\n                DrawList.AddLine(ImVec2(xt.PixelPos, rect.Min.y), ImVec2(xt.PixelPos, rect.Max.y), col_min, size_min);\n        }\n    }\n}\n\nstatic inline void RenderGridLinesY(ImDrawList& DrawList, const ImPlotTicker& ticker, const ImRect& rect, ImU32 col_maj, ImU32 col_min, float size_maj, float size_min) {\n    const float density   = ticker.TickCount() / rect.GetHeight();\n    ImVec4 col_min4  = ImGui::ColorConvertU32ToFloat4(col_min);\n    col_min4.w      *= ImClamp(ImRemap(density, 0.1f, 0.2f, 1.0f, 0.0f), 0.0f, 1.0f);\n    col_min = ImGui::ColorConvertFloat4ToU32(col_min4);\n    for (int t = 0; t < ticker.TickCount(); t++) {\n        const ImPlotTick& yt = ticker.Ticks[t];\n        if (yt.PixelPos < rect.Min.y || yt.PixelPos > rect.Max.y)\n            continue;\n        if (yt.Major)\n            DrawList.AddLine(ImVec2(rect.Min.x, yt.PixelPos), ImVec2(rect.Max.x, yt.PixelPos), col_maj, size_maj);\n        else if (density < 0.2f)\n            DrawList.AddLine(ImVec2(rect.Min.x, yt.PixelPos), ImVec2(rect.Max.x, yt.PixelPos), col_min, size_min);\n    }\n}\n\nstatic inline void RenderSelectionRect(ImDrawList& DrawList, const ImVec2& p_min, const ImVec2& p_max, const ImVec4& col) {\n    const ImU32 col_bg = ImGui::GetColorU32(col * ImVec4(1,1,1,0.25f));\n    const ImU32 col_bd = ImGui::GetColorU32(col);\n    DrawList.AddRectFilled(p_min, p_max, col_bg);\n    DrawList.AddRect(p_min, p_max, col_bd);\n}\n\n//-----------------------------------------------------------------------------\n// Input Handling\n//-----------------------------------------------------------------------------\n\nstatic const float MOUSE_CURSOR_DRAG_THRESHOLD = 5.0f;\nstatic const float BOX_SELECT_DRAG_THRESHOLD   = 4.0f;\n\nbool UpdateInput(ImPlotPlot& plot) {\n\n    bool changed = false;\n\n    ImPlotContext& gp = *GImPlot;\n    ImGuiIO& IO = ImGui::GetIO();\n\n    // BUTTON STATE -----------------------------------------------------------\n\n    const ImGuiButtonFlags plot_button_flags = ImGuiButtonFlags_AllowOverlap\n                                             | ImGuiButtonFlags_PressedOnClick\n                                             | ImGuiButtonFlags_PressedOnDoubleClick\n                                             | ImGuiButtonFlags_MouseButtonLeft\n                                             | ImGuiButtonFlags_MouseButtonRight\n                                             | ImGuiButtonFlags_MouseButtonMiddle;\n    const ImGuiButtonFlags axis_button_flags = ImGuiButtonFlags_FlattenChildren\n                                             | plot_button_flags;\n\n    const bool plot_clicked = ImGui::ButtonBehavior(plot.PlotRect,plot.ID,&plot.Hovered,&plot.Held,plot_button_flags);\n#if (IMGUI_VERSION_NUM < 18966)\n    ImGui::SetItemAllowOverlap(); // Handled by ButtonBehavior()\n#endif\n\n    if (plot_clicked) {\n        if (!ImHasFlag(plot.Flags, ImPlotFlags_NoBoxSelect) && IO.MouseClicked[gp.InputMap.Select] && ImHasFlag(IO.KeyMods, gp.InputMap.SelectMod)) {\n            plot.Selecting   = true;\n            plot.SelectStart = IO.MousePos;\n            plot.SelectRect  = ImRect(0,0,0,0);\n        }\n        if (IO.MouseDoubleClicked[gp.InputMap.Fit]) {\n            plot.FitThisFrame = true;\n            for (int i = 0; i < ImAxis_COUNT; ++i)\n                plot.Axes[i].FitThisFrame = true;\n        }\n    }\n\n    const bool can_pan = IO.MouseDown[gp.InputMap.Pan] && ImHasFlag(IO.KeyMods, gp.InputMap.PanMod);\n\n    plot.Held = plot.Held && can_pan;\n\n    bool x_click[IMPLOT_NUM_X_AXES] = {false};\n    bool x_held[IMPLOT_NUM_X_AXES]  = {false};\n    bool x_hov[IMPLOT_NUM_X_AXES]   = {false};\n\n    bool y_click[IMPLOT_NUM_Y_AXES] = {false};\n    bool y_held[IMPLOT_NUM_Y_AXES]  = {false};\n    bool y_hov[IMPLOT_NUM_Y_AXES]   = {false};\n\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n        ImPlotAxis& xax = plot.XAxis(i);\n        if (xax.Enabled) {\n            ImGui::KeepAliveID(xax.ID);\n            x_click[i]  = ImGui::ButtonBehavior(xax.HoverRect,xax.ID,&xax.Hovered,&xax.Held,axis_button_flags);\n            if (x_click[i] && IO.MouseDoubleClicked[gp.InputMap.Fit])\n                plot.FitThisFrame = xax.FitThisFrame = true;\n            xax.Held  = xax.Held && can_pan;\n            x_hov[i]  = xax.Hovered || plot.Hovered;\n            x_held[i] = xax.Held    || plot.Held;\n        }\n    }\n\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n        ImPlotAxis& yax = plot.YAxis(i);\n        if (yax.Enabled) {\n            ImGui::KeepAliveID(yax.ID);\n            y_click[i]  = ImGui::ButtonBehavior(yax.HoverRect,yax.ID,&yax.Hovered,&yax.Held,axis_button_flags);\n            if (y_click[i] && IO.MouseDoubleClicked[gp.InputMap.Fit])\n                plot.FitThisFrame = yax.FitThisFrame = true;\n            yax.Held  = yax.Held && can_pan;\n            y_hov[i]  = yax.Hovered || plot.Hovered;\n            y_held[i] = yax.Held    || plot.Held;\n        }\n    }\n\n    // cancel due to DND activity\n    if (GImGui->DragDropActive || (IO.KeyMods == gp.InputMap.OverrideMod && gp.InputMap.OverrideMod != 0))\n        return false;\n\n    // STATE -------------------------------------------------------------------\n\n    const bool axis_equal      = ImHasFlag(plot.Flags, ImPlotFlags_Equal);\n\n    const bool any_x_hov       = plot.Hovered || AnyAxesHovered(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);\n    const bool any_x_held      = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);\n    const bool any_y_hov       = plot.Hovered || AnyAxesHovered(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);\n    const bool any_y_held      = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);\n    const bool any_hov         = any_x_hov    || any_y_hov;\n    const bool any_held        = any_x_held   || any_y_held;\n\n    const ImVec2 select_drag   = ImGui::GetMouseDragDelta(gp.InputMap.Select);\n    const ImVec2 pan_drag      = ImGui::GetMouseDragDelta(gp.InputMap.Pan);\n    const float select_drag_sq = ImLengthSqr(select_drag);\n    const float pan_drag_sq    = ImLengthSqr(pan_drag);\n    const bool selecting       = plot.Selecting && select_drag_sq > MOUSE_CURSOR_DRAG_THRESHOLD;\n    const bool panning         = any_held       && pan_drag_sq    > MOUSE_CURSOR_DRAG_THRESHOLD;\n\n    // CONTEXT MENU -----------------------------------------------------------\n\n    if (IO.MouseReleased[gp.InputMap.Menu] && !plot.ContextLocked)\n        gp.OpenContextThisFrame = true;\n\n    if (selecting || panning)\n        plot.ContextLocked = true;\n    else if (!(IO.MouseDown[gp.InputMap.Menu] || IO.MouseReleased[gp.InputMap.Menu]))\n        plot.ContextLocked = false;\n\n    // DRAG INPUT -------------------------------------------------------------\n\n    if (any_held && !plot.Selecting) {\n        int drag_direction = 0;\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            if (x_held[i] && !x_axis.IsInputLocked()) {\n                drag_direction |= (1 << 1);\n                bool increasing = x_axis.IsInverted() ? IO.MouseDelta.x > 0 : IO.MouseDelta.x < 0;\n                if (IO.MouseDelta.x != 0 && !x_axis.IsPanLocked(increasing)) {\n                    const double plot_l = x_axis.PixelsToPlot(plot.PlotRect.Min.x - IO.MouseDelta.x);\n                    const double plot_r = x_axis.PixelsToPlot(plot.PlotRect.Max.x - IO.MouseDelta.x);\n                    x_axis.SetMin(x_axis.IsInverted() ? plot_r : plot_l);\n                    x_axis.SetMax(x_axis.IsInverted() ? plot_l : plot_r);\n                    if (axis_equal && x_axis.OrthoAxis != nullptr)\n                        x_axis.OrthoAxis->SetAspect(x_axis.GetAspect());\n                    changed = true;\n                }\n            }\n        }\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n            ImPlotAxis& y_axis = plot.YAxis(i);\n            if (y_held[i] && !y_axis.IsInputLocked()) {\n                drag_direction |= (1 << 2);\n                bool increasing = y_axis.IsInverted() ? IO.MouseDelta.y < 0 : IO.MouseDelta.y > 0;\n                if (IO.MouseDelta.y != 0 && !y_axis.IsPanLocked(increasing)) {\n                    const double plot_t = y_axis.PixelsToPlot(plot.PlotRect.Min.y - IO.MouseDelta.y);\n                    const double plot_b = y_axis.PixelsToPlot(plot.PlotRect.Max.y - IO.MouseDelta.y);\n                    y_axis.SetMin(y_axis.IsInverted() ? plot_t : plot_b);\n                    y_axis.SetMax(y_axis.IsInverted() ? plot_b : plot_t);\n                    if (axis_equal && y_axis.OrthoAxis != nullptr)\n                        y_axis.OrthoAxis->SetAspect(y_axis.GetAspect());\n                    changed = true;\n                }\n            }\n        }\n        if (IO.MouseDragMaxDistanceSqr[gp.InputMap.Pan] > MOUSE_CURSOR_DRAG_THRESHOLD) {\n            switch (drag_direction) {\n                case 0        : ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed); break;\n                case (1 << 1) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);   break;\n                case (1 << 2) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);   break;\n                default       : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);  break;\n            }\n        }\n    }\n\n    // SCROLL INPUT -----------------------------------------------------------\n\n    if (any_hov && ImHasFlag(IO.KeyMods, gp.InputMap.ZoomMod)) {\n\n        float zoom_rate = gp.InputMap.ZoomRate;\n        if (IO.MouseWheel == 0.0f)\n            zoom_rate = 0;\n        else if (IO.MouseWheel > 0)\n            zoom_rate = (-zoom_rate) / (1.0f + (2.0f * zoom_rate));\n        ImVec2 rect_size = plot.PlotRect.GetSize();\n        float tx = ImRemap(IO.MousePos.x, plot.PlotRect.Min.x, plot.PlotRect.Max.x, 0.0f, 1.0f);\n        float ty = ImRemap(IO.MousePos.y, plot.PlotRect.Min.y, plot.PlotRect.Max.y, 0.0f, 1.0f);\n\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            const bool equal_zoom   = axis_equal && x_axis.OrthoAxis != nullptr;\n            const bool equal_locked = (equal_zoom != false) && x_axis.OrthoAxis->IsInputLocked();\n            if (x_hov[i] && !x_axis.IsInputLocked() && !equal_locked) {\n                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.ID);\n                if (zoom_rate != 0.0f) {\n                    float correction = (plot.Hovered && equal_zoom) ? 0.5f : 1.0f;\n                    const double plot_l = x_axis.PixelsToPlot(plot.PlotRect.Min.x - rect_size.x * tx * zoom_rate * correction);\n                    const double plot_r = x_axis.PixelsToPlot(plot.PlotRect.Max.x + rect_size.x * (1 - tx) * zoom_rate * correction);\n                    x_axis.SetMin(x_axis.IsInverted() ? plot_r : plot_l);\n                    x_axis.SetMax(x_axis.IsInverted() ? plot_l : plot_r);\n                    if (axis_equal && x_axis.OrthoAxis != nullptr)\n                        x_axis.OrthoAxis->SetAspect(x_axis.GetAspect());\n                    changed = true;\n                }\n            }\n        }\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n            ImPlotAxis& y_axis = plot.YAxis(i);\n            const bool equal_zoom   = axis_equal && y_axis.OrthoAxis != nullptr;\n            const bool equal_locked = equal_zoom && y_axis.OrthoAxis->IsInputLocked();\n            if (y_hov[i] && !y_axis.IsInputLocked() && !equal_locked) {\n                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.ID);\n                if (zoom_rate != 0.0f) {\n                    float correction = (plot.Hovered && equal_zoom) ? 0.5f : 1.0f;\n                    const double plot_t = y_axis.PixelsToPlot(plot.PlotRect.Min.y - rect_size.y * ty * zoom_rate * correction);\n                    const double plot_b = y_axis.PixelsToPlot(plot.PlotRect.Max.y + rect_size.y * (1 - ty) * zoom_rate * correction);\n                    y_axis.SetMin(y_axis.IsInverted() ? plot_t : plot_b);\n                    y_axis.SetMax(y_axis.IsInverted() ? plot_b : plot_t);\n                    if (axis_equal && y_axis.OrthoAxis != nullptr)\n                        y_axis.OrthoAxis->SetAspect(y_axis.GetAspect());\n                    changed = true;\n                }\n            }\n        }\n    }\n\n    // BOX-SELECTION ----------------------------------------------------------\n\n    if (plot.Selecting) {\n        const ImVec2 d = plot.SelectStart - IO.MousePos;\n        const bool x_can_change = !ImHasFlag(IO.KeyMods,gp.InputMap.SelectHorzMod) && ImFabs(d.x) > 2;\n        const bool y_can_change = !ImHasFlag(IO.KeyMods,gp.InputMap.SelectVertMod) && ImFabs(d.y) > 2;\n        // confirm\n        if (IO.MouseReleased[gp.InputMap.Select]) {\n            for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n                ImPlotAxis& x_axis = plot.XAxis(i);\n                if (!x_axis.IsInputLocked() && x_can_change) {\n                    const double p1 = x_axis.PixelsToPlot(plot.SelectStart.x);\n                    const double p2 = x_axis.PixelsToPlot(IO.MousePos.x);\n                    x_axis.SetMin(ImMin(p1, p2));\n                    x_axis.SetMax(ImMax(p1, p2));\n                    changed = true;\n                }\n            }\n            for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n                ImPlotAxis& y_axis = plot.YAxis(i);\n                if (!y_axis.IsInputLocked() && y_can_change) {\n                    const double p1 = y_axis.PixelsToPlot(plot.SelectStart.y);\n                    const double p2 = y_axis.PixelsToPlot(IO.MousePos.y);\n                    y_axis.SetMin(ImMin(p1, p2));\n                    y_axis.SetMax(ImMax(p1, p2));\n                    changed = true;\n                }\n            }\n            if (x_can_change || y_can_change || (ImHasFlag(IO.KeyMods,gp.InputMap.SelectHorzMod) && ImHasFlag(IO.KeyMods,gp.InputMap.SelectVertMod)))\n                gp.OpenContextThisFrame = false;\n            plot.Selected = plot.Selecting = false;\n        }\n        // cancel\n        else if (IO.MouseReleased[gp.InputMap.SelectCancel]) {\n            plot.Selected = plot.Selecting = false;\n            gp.OpenContextThisFrame = false;\n        }\n        else if (ImLengthSqr(d) > BOX_SELECT_DRAG_THRESHOLD) {\n            // bad selection\n            if (plot.IsInputLocked()) {\n                ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed);\n                gp.OpenContextThisFrame = false;\n                plot.Selected      = false;\n            }\n            else {\n                // TODO: Handle only min or max locked cases\n                const bool full_width  = ImHasFlag(IO.KeyMods, gp.InputMap.SelectHorzMod) || AllAxesInputLocked(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);\n                const bool full_height = ImHasFlag(IO.KeyMods, gp.InputMap.SelectVertMod) || AllAxesInputLocked(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);\n                plot.SelectRect.Min.x = full_width  ? plot.PlotRect.Min.x : ImMin(plot.SelectStart.x, IO.MousePos.x);\n                plot.SelectRect.Max.x = full_width  ? plot.PlotRect.Max.x : ImMax(plot.SelectStart.x, IO.MousePos.x);\n                plot.SelectRect.Min.y = full_height ? plot.PlotRect.Min.y : ImMin(plot.SelectStart.y, IO.MousePos.y);\n                plot.SelectRect.Max.y = full_height ? plot.PlotRect.Max.y : ImMax(plot.SelectStart.y, IO.MousePos.y);\n                plot.SelectRect.Min  -= plot.PlotRect.Min;\n                plot.SelectRect.Max  -= plot.PlotRect.Min;\n                plot.Selected = true;\n            }\n        }\n        else {\n            plot.Selected = false;\n        }\n    }\n    return changed;\n}\n\n//-----------------------------------------------------------------------------\n// Next Plot Data (Legacy)\n//-----------------------------------------------------------------------------\n\nvoid ApplyNextPlotData(ImAxis idx) {\n    ImPlotContext& gp = *GImPlot;\n    ImPlotPlot& plot  = *gp.CurrentPlot;\n    ImPlotAxis& axis  = plot.Axes[idx];\n    if (!axis.Enabled)\n        return;\n    double*     npd_lmin = gp.NextPlotData.LinkedMin[idx];\n    double*     npd_lmax = gp.NextPlotData.LinkedMax[idx];\n    bool        npd_rngh = gp.NextPlotData.HasRange[idx];\n    ImPlotCond  npd_rngc = gp.NextPlotData.RangeCond[idx];\n    ImPlotRange     npd_rngv = gp.NextPlotData.Range[idx];\n    axis.LinkedMin = npd_lmin;\n    axis.LinkedMax = npd_lmax;\n    axis.PullLinks();\n    if (npd_rngh) {\n        if (!plot.Initialized || npd_rngc == ImPlotCond_Always)\n            axis.SetRange(npd_rngv);\n    }\n    axis.HasRange         = npd_rngh;\n    axis.RangeCond        = npd_rngc;\n}\n\n//-----------------------------------------------------------------------------\n// Setup\n//-----------------------------------------------------------------------------\n\nvoid SetupAxis(ImAxis idx, const char* label, ImPlotAxisFlags flags) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    // get plot and axis\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    // set ID\n    axis.ID = plot.ID + idx + 1;\n    // check and set flags\n    if (plot.JustCreated || flags != axis.PreviousFlags)\n        axis.Flags = flags;\n    axis.PreviousFlags = flags;\n    // enable axis\n    axis.Enabled = true;\n    // set label\n    plot.SetAxisLabel(axis,label);\n    // cache colors\n    UpdateAxisColors(axis);\n}\n\nvoid SetupAxisLimits(ImAxis idx, double min_lim, double max_lim, ImPlotCond cond) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");    // get plot and axis\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    if (!plot.Initialized || cond == ImPlotCond_Always)\n        axis.SetRange(min_lim, max_lim);\n    axis.HasRange  = true;\n    axis.RangeCond = cond;\n}\n\nvoid SetupAxisFormat(ImAxis idx, const char* fmt) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.HasFormatSpec = fmt != nullptr;\n    if (fmt != nullptr)\n        ImStrncpy(axis.FormatSpec,fmt,sizeof(axis.FormatSpec));\n}\n\nvoid SetupAxisLinks(ImAxis idx, double* min_lnk, double* max_lnk) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.LinkedMin = min_lnk;\n    axis.LinkedMax = max_lnk;\n    axis.PullLinks();\n}\n\nvoid SetupAxisFormat(ImAxis idx, ImPlotFormatter formatter, void* data) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.Formatter = formatter;\n    axis.FormatterData = data;\n}\n\nvoid SetupAxisTicks(ImAxis idx, const double* values, int n_ticks, const char* const labels[], bool show_default) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                        \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.ShowDefaultTicks = show_default;\n    AddTicksCustom(values,\n                  labels,\n                  n_ticks,\n                  axis.Ticker,\n                  axis.Formatter ? axis.Formatter : Formatter_Default,\n                  (axis.Formatter && axis.FormatterData) ? axis.FormatterData : axis.HasFormatSpec ? axis.FormatSpec : (void*)IMPLOT_LABEL_FORMAT);\n}\n\nvoid SetupAxisTicks(ImAxis idx, double v_min, double v_max, int n_ticks, const char* const labels[], bool show_default) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    n_ticks = n_ticks < 2 ? 2 : n_ticks;\n    FillRange(gp.TempDouble1, n_ticks, v_min, v_max);\n    SetupAxisTicks(idx, gp.TempDouble1.Data, n_ticks, labels, show_default);\n}\n\nvoid SetupAxisScale(ImAxis idx, ImPlotScale scale) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                        \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.Scale = scale;\n    switch (scale)\n    {\n    case ImPlotScale_Time:\n        axis.TransformForward = nullptr;\n        axis.TransformInverse = nullptr;\n        axis.TransformData    = nullptr;\n        axis.Locator          = Locator_Time;\n        axis.ConstraintRange  = ImPlotRange(IMPLOT_MIN_TIME, IMPLOT_MAX_TIME);\n        axis.Ticker.Levels    = 2;\n        break;\n    case ImPlotScale_Log10:\n        axis.TransformForward = TransformForward_Log10;\n        axis.TransformInverse = TransformInverse_Log10;\n        axis.TransformData    = nullptr;\n        axis.Locator          = Locator_Log10;\n        axis.ConstraintRange  = ImPlotRange(DBL_MIN, INFINITY);\n        break;\n    case ImPlotScale_SymLog:\n        axis.TransformForward = TransformForward_SymLog;\n        axis.TransformInverse = TransformInverse_SymLog;\n        axis.TransformData    = nullptr;\n        axis.Locator          = Locator_SymLog;\n        axis.ConstraintRange  = ImPlotRange(-INFINITY, INFINITY);\n        break;\n    default:\n        axis.TransformForward = nullptr;\n        axis.TransformInverse = nullptr;\n        axis.TransformData    = nullptr;\n        axis.Locator          = nullptr;\n        axis.ConstraintRange  = ImPlotRange(-INFINITY, INFINITY);\n        break;\n    }\n}\n\nvoid SetupAxisScale(ImAxis idx, ImPlotTransform fwd, ImPlotTransform inv, void* data) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                        \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.Scale = IMPLOT_AUTO;\n    axis.TransformForward = fwd;\n    axis.TransformInverse = inv;\n    axis.TransformData = data;\n}\n\nvoid SetupAxisLimitsConstraints(ImAxis idx, double v_min, double v_max) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                        \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.ConstraintRange.Min = v_min;\n    axis.ConstraintRange.Max = v_max;\n}\n\nvoid SetupAxisZoomConstraints(ImAxis idx, double z_min, double z_max) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                        \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& axis = plot.Axes[idx];\n    IM_ASSERT_USER_ERROR(axis.Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    axis.ConstraintZoom.Min = z_min;\n    axis.ConstraintZoom.Max = z_max;\n}\n\nvoid SetupAxes(const char* x_label, const char* y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags) {\n    SetupAxis(ImAxis_X1, x_label, x_flags);\n    SetupAxis(ImAxis_Y1, y_label, y_flags);\n}\n\nvoid SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond) {\n    SetupAxisLimits(ImAxis_X1, x_min, x_max, cond);\n    SetupAxisLimits(ImAxis_Y1, y_min, y_max, cond);\n}\n\nvoid SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR((gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked) || (gp.CurrentSubplot != nullptr && gp.CurrentPlot == nullptr),\n                         \"Setup needs to be called after BeginPlot or BeginSubplots and before any setup locking functions (e.g. PlotX)!\");\n    if (gp.CurrentItems) {\n        ImPlotLegend& legend = gp.CurrentItems->Legend;\n        // check and set location\n        if (location != legend.PreviousLocation)\n            legend.Location = location;\n        legend.PreviousLocation = location;\n        // check and set flags\n        if (flags != legend.PreviousFlags)\n            legend.Flags = flags;\n        legend.PreviousFlags = flags;\n    }\n}\n\nvoid SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,\n                         \"Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!\");\n    gp.CurrentPlot->MouseTextLocation = location;\n    gp.CurrentPlot->MouseTextFlags = flags;\n}\n\n//-----------------------------------------------------------------------------\n// SetNext\n//-----------------------------------------------------------------------------\n\nvoid SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, \"SetNextAxisLimits() needs to be called before BeginPlot()!\");\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    gp.NextPlotData.HasRange[axis]  = true;\n    gp.NextPlotData.RangeCond[axis] = cond;\n    gp.NextPlotData.Range[axis].Min = v_min;\n    gp.NextPlotData.Range[axis].Max = v_max;\n}\n\nvoid SetNextAxisLinks(ImAxis axis, double* link_min, double* link_max) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, \"SetNextAxisLinks() needs to be called before BeginPlot()!\");\n    gp.NextPlotData.LinkedMin[axis] = link_min;\n    gp.NextPlotData.LinkedMax[axis] = link_max;\n}\n\nvoid SetNextAxisToFit(ImAxis axis) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, \"SetNextAxisToFit() needs to be called before BeginPlot()!\");\n    gp.NextPlotData.Fit[axis] = true;\n}\n\nvoid SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond) {\n    SetNextAxisLimits(ImAxis_X1, x_min, x_max, cond);\n    SetNextAxisLimits(ImAxis_Y1, y_min, y_max, cond);\n}\n\nvoid SetNextAxesToFit() {\n    for (int i = 0; i < ImAxis_COUNT; ++i)\n        SetNextAxisToFit(i);\n}\n\n//-----------------------------------------------------------------------------\n// BeginPlot\n//-----------------------------------------------------------------------------\n\nbool BeginPlot(const char* title_id, const ImVec2& size, ImPlotFlags flags) {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, \"Mismatched BeginPlot()/EndPlot()!\");\n\n    // FRONT MATTER -----------------------------------------------------------\n\n    if (gp.CurrentSubplot != nullptr)\n        ImGui::PushID(gp.CurrentSubplot->CurrentIdx);\n\n    // get globals\n    ImGuiContext &G          = *GImGui;\n    ImGuiWindow* Window      = G.CurrentWindow;\n\n    // skip if needed\n    if (Window->SkipItems && !gp.CurrentSubplot) {\n        ResetCtxForNextPlot(GImPlot);\n        return false;\n    }\n\n    // ID and age (TODO: keep track of plot age in frames)\n    const ImGuiID ID         = Window->GetID(title_id);\n    const bool just_created  = gp.Plots.GetByKey(ID) == nullptr;\n    gp.CurrentPlot           = gp.Plots.GetOrAddByKey(ID);\n\n    ImPlotPlot &plot         = *gp.CurrentPlot;\n    plot.ID                  = ID;\n    plot.Items.ID            = ID - 1;\n    plot.JustCreated         = just_created;\n    plot.SetupLocked         = false;\n\n    // check flags\n    if (plot.JustCreated)\n        plot.Flags = flags;\n    else if (flags != plot.PreviousFlags)\n        plot.Flags = flags;\n    plot.PreviousFlags = flags;\n\n    // setup default axes\n    if (plot.JustCreated) {\n        SetupAxis(ImAxis_X1);\n        SetupAxis(ImAxis_Y1);\n    }\n\n    // reset axes\n    for (int i = 0; i < ImAxis_COUNT; ++i) {\n        plot.Axes[i].Reset();\n        UpdateAxisColors(plot.Axes[i]);\n    }\n    // ensure first axes enabled\n    plot.Axes[ImAxis_X1].Enabled = true;\n    plot.Axes[ImAxis_Y1].Enabled = true;\n    // set initial axes\n    plot.CurrentX = ImAxis_X1;\n    plot.CurrentY = ImAxis_Y1;\n\n    // process next plot data (legacy)\n    for (int i = 0; i < ImAxis_COUNT; ++i)\n        ApplyNextPlotData(i);\n\n    // clear text buffers\n    plot.ClearTextBuffer();\n    plot.SetTitle(title_id);\n\n    // set frame size\n    ImVec2 frame_size;\n    if (gp.CurrentSubplot != nullptr)\n        frame_size = gp.CurrentSubplot->CellSize;\n    else\n        frame_size = ImGui::CalcItemSize(size, gp.Style.PlotDefaultSize.x, gp.Style.PlotDefaultSize.y);\n\n    if (frame_size.x < gp.Style.PlotMinSize.x && (size.x < 0.0f || gp.CurrentSubplot != nullptr))\n        frame_size.x = gp.Style.PlotMinSize.x;\n    if (frame_size.y < gp.Style.PlotMinSize.y && (size.y < 0.0f || gp.CurrentSubplot != nullptr))\n        frame_size.y = gp.Style.PlotMinSize.y;\n\n    plot.FrameRect = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);\n    ImGui::ItemSize(plot.FrameRect);\n    if (!ImGui::ItemAdd(plot.FrameRect, plot.ID, &plot.FrameRect) && !gp.CurrentSubplot) {\n        ResetCtxForNextPlot(GImPlot);\n        return false;\n    }\n\n    // setup items (or dont)\n    if (gp.CurrentItems == nullptr)\n        gp.CurrentItems = &plot.Items;\n\n    return true;\n}\n\n//-----------------------------------------------------------------------------\n// SetupFinish\n//-----------------------------------------------------------------------------\n\nvoid SetupFinish() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"SetupFinish needs to be called after BeginPlot!\");\n\n    ImGuiContext& G         = *GImGui;\n    ImDrawList& DrawList    = *G.CurrentWindow->DrawList;\n    const ImGuiStyle& Style = G.Style;\n\n    ImPlotPlot &plot  = *gp.CurrentPlot;\n\n    // lock setup\n    plot.SetupLocked = true;\n\n    // finalize axes and set default formatter/locator\n    for (int i = 0; i < ImAxis_COUNT; ++i) {\n        ImPlotAxis& axis = plot.Axes[i];\n        if (axis.Enabled) {\n            axis.Constrain();\n            if (!plot.Initialized && axis.CanInitFit())\n                plot.FitThisFrame = axis.FitThisFrame = true;\n        }\n        if (axis.Formatter == nullptr) {\n            axis.Formatter = Formatter_Default;\n            if (axis.HasFormatSpec)\n                axis.FormatterData = axis.FormatSpec;\n            else\n                axis.FormatterData = (void*)IMPLOT_LABEL_FORMAT;\n        }\n        if (axis.Locator == nullptr) {\n            axis.Locator = Locator_Default;\n        }\n    }\n\n    // setup nullptr orthogonal axes\n    const bool axis_equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);\n    for (int ix = ImAxis_X1, iy = ImAxis_Y1; ix < ImAxis_Y1 || iy < ImAxis_COUNT; ++ix, ++iy) {\n        ImPlotAxis& x_axis = plot.Axes[ix];\n        ImPlotAxis& y_axis = plot.Axes[iy];\n        if (x_axis.Enabled && y_axis.Enabled) {\n            if (x_axis.OrthoAxis == nullptr)\n                x_axis.OrthoAxis = &y_axis;\n            if (y_axis.OrthoAxis == nullptr)\n                y_axis.OrthoAxis = &x_axis;\n        }\n        else if (x_axis.Enabled)\n        {\n            if (x_axis.OrthoAxis == nullptr && !axis_equal)\n                x_axis.OrthoAxis = &plot.Axes[ImAxis_Y1];\n        }\n        else if (y_axis.Enabled) {\n            if (y_axis.OrthoAxis == nullptr && !axis_equal)\n                y_axis.OrthoAxis = &plot.Axes[ImAxis_X1];\n        }\n    }\n\n    // canvas/axes bb\n    plot.CanvasRect = ImRect(plot.FrameRect.Min + gp.Style.PlotPadding, plot.FrameRect.Max - gp.Style.PlotPadding);\n    plot.AxesRect   = plot.FrameRect;\n\n    // outside legend adjustments\n    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoLegend) && plot.Items.GetLegendCount() > 0 && ImHasFlag(plot.Items.Legend.Flags, ImPlotLegendFlags_Outside)) {\n        ImPlotLegend& legend = plot.Items.Legend;\n        const bool horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);\n        const ImVec2 legend_size = CalcLegendSize(plot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !horz);\n        const bool west = ImHasFlag(legend.Location, ImPlotLocation_West) && !ImHasFlag(legend.Location, ImPlotLocation_East);\n        const bool east = ImHasFlag(legend.Location, ImPlotLocation_East) && !ImHasFlag(legend.Location, ImPlotLocation_West);\n        const bool north = ImHasFlag(legend.Location, ImPlotLocation_North) && !ImHasFlag(legend.Location, ImPlotLocation_South);\n        const bool south = ImHasFlag(legend.Location, ImPlotLocation_South) && !ImHasFlag(legend.Location, ImPlotLocation_North);\n        if ((west && !horz) || (west && horz && !north && !south)) {\n            plot.CanvasRect.Min.x += (legend_size.x + gp.Style.LegendPadding.x);\n            plot.AxesRect.Min.x   += (legend_size.x + gp.Style.PlotPadding.x);\n        }\n        if ((east && !horz) || (east && horz && !north && !south)) {\n            plot.CanvasRect.Max.x -= (legend_size.x + gp.Style.LegendPadding.x);\n            plot.AxesRect.Max.x   -= (legend_size.x + gp.Style.PlotPadding.x);\n        }\n        if ((north && horz) || (north && !horz && !west && !east)) {\n            plot.CanvasRect.Min.y += (legend_size.y + gp.Style.LegendPadding.y);\n            plot.AxesRect.Min.y   += (legend_size.y + gp.Style.PlotPadding.y);\n        }\n        if ((south && horz) || (south && !horz && !west && !east)) {\n            plot.CanvasRect.Max.y -= (legend_size.y + gp.Style.LegendPadding.y);\n            plot.AxesRect.Max.y   -= (legend_size.y + gp.Style.PlotPadding.y);\n        }\n    }\n\n    // plot bb\n    float pad_top = 0, pad_bot = 0, pad_left = 0, pad_right = 0;\n\n    // (0) calc top padding form title\n    ImVec2 title_size(0.0f, 0.0f);\n    if (plot.HasTitle())\n         title_size = ImGui::CalcTextSize(plot.GetTitle(), nullptr, true);\n    if (title_size.x > 0) {\n        pad_top += title_size.y + gp.Style.LabelPadding.y;\n        plot.AxesRect.Min.y += gp.Style.PlotPadding.y + pad_top;\n    }\n\n    // (1) calc addition top padding and bot padding\n    PadAndDatumAxesX(plot,pad_top,pad_bot,gp.CurrentAlignmentH);\n\n    const float plot_height = plot.CanvasRect.GetHeight() - pad_top - pad_bot;\n\n    // (2) get y tick labels (needed for left/right pad)\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        ImPlotAxis& axis = plot.YAxis(i);\n        if (axis.WillRender() && axis.ShowDefaultTicks && plot_height > 0) {\n            axis.Locator(axis.Ticker, axis.Range, plot_height, true, axis.Formatter, axis.FormatterData);\n        }\n    }\n\n    // (3) calc left/right pad\n    PadAndDatumAxesY(plot,pad_left,pad_right,gp.CurrentAlignmentV);\n\n    const float plot_width = plot.CanvasRect.GetWidth() - pad_left - pad_right;\n\n    // (4) get x ticks\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        ImPlotAxis& axis = plot.XAxis(i);\n        if (axis.WillRender() && axis.ShowDefaultTicks && plot_width > 0) {\n            axis.Locator(axis.Ticker, axis.Range, plot_width, false, axis.Formatter, axis.FormatterData);\n        }\n    }\n\n    // (5) calc plot bb\n    plot.PlotRect = ImRect(plot.CanvasRect.Min + ImVec2(pad_left, pad_top), plot.CanvasRect.Max - ImVec2(pad_right, pad_bot));\n\n    // HOVER------------------------------------------------------------\n\n    // axes hover rect, pixel ranges\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n        ImPlotAxis& xax = plot.XAxis(i);\n        xax.HoverRect   = ImRect(ImVec2(plot.PlotRect.Min.x, ImMin(xax.Datum1,xax.Datum2)),\n                                 ImVec2(plot.PlotRect.Max.x, ImMax(xax.Datum1,xax.Datum2)));\n        xax.PixelMin    = xax.IsInverted() ? plot.PlotRect.Max.x : plot.PlotRect.Min.x;\n        xax.PixelMax    = xax.IsInverted() ? plot.PlotRect.Min.x : plot.PlotRect.Max.x;\n        xax.UpdateTransformCache();\n    }\n\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n        ImPlotAxis& yax = plot.YAxis(i);\n        yax.HoverRect   = ImRect(ImVec2(ImMin(yax.Datum1,yax.Datum2),plot.PlotRect.Min.y),\n                                 ImVec2(ImMax(yax.Datum1,yax.Datum2),plot.PlotRect.Max.y));\n        yax.PixelMin    = yax.IsInverted() ? plot.PlotRect.Min.y : plot.PlotRect.Max.y;\n        yax.PixelMax    = yax.IsInverted() ? plot.PlotRect.Max.y : plot.PlotRect.Min.y;\n        yax.UpdateTransformCache();\n    }\n    // Equal axis constraint. Must happen after we set Pixels\n    // constrain equal axes for primary x and y if not approximately equal\n    // constrains x to y since x pixel size depends on y labels width, and causes feedback loops in opposite case\n    if (axis_equal) {\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            if (x_axis.OrthoAxis == nullptr)\n                continue;\n            double xar = x_axis.GetAspect();\n            double yar = x_axis.OrthoAxis->GetAspect();\n            // edge case: user has set x range this frame, so fit y to x so that we honor their request for x range\n            // NB: because of feedback across several frames, the user's x request may not be perfectly honored\n            if (x_axis.HasRange)\n                x_axis.OrthoAxis->SetAspect(xar);\n            else if (!ImAlmostEqual(xar,yar) && !x_axis.OrthoAxis->IsInputLocked())\n                 x_axis.SetAspect(yar);\n        }\n    }\n\n    // INPUT ------------------------------------------------------------------\n    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoInputs))\n        UpdateInput(plot);\n\n    // fit from FitNextPlotAxes or auto fit\n    for (int i = 0; i < ImAxis_COUNT; ++i) {\n        if (gp.NextPlotData.Fit[i] || plot.Axes[i].IsAutoFitting()) {\n            plot.FitThisFrame = true;\n            plot.Axes[i].FitThisFrame = true;\n        }\n    }\n\n    // RENDER -----------------------------------------------------------------\n\n    const float txt_height = ImGui::GetTextLineHeight();\n\n    // render frame\n    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoFrame))\n        ImGui::RenderFrame(plot.FrameRect.Min, plot.FrameRect.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, Style.FrameRounding);\n\n    // grid bg\n    DrawList.AddRectFilled(plot.PlotRect.Min, plot.PlotRect.Max, GetStyleColorU32(ImPlotCol_PlotBg));\n\n    // transform ticks\n    for (int i = 0; i < ImAxis_COUNT; i++) {\n        ImPlotAxis& axis = plot.Axes[i];\n        if (axis.WillRender()) {\n            for (int t = 0; t < axis.Ticker.TickCount(); t++) {\n                ImPlotTick& tk = axis.Ticker.Ticks[t];\n                tk.PixelPos = IM_ROUND(axis.PlotToPixels(tk.PlotPos));\n            }\n        }\n    }\n\n    // render grid (background)\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        ImPlotAxis& x_axis = plot.XAxis(i);\n        if (x_axis.Enabled && x_axis.HasGridLines() && !x_axis.IsForeground())\n            RenderGridLinesX(DrawList, x_axis.Ticker, plot.PlotRect, x_axis.ColorMaj, x_axis.ColorMin, gp.Style.MajorGridSize.x, gp.Style.MinorGridSize.x);\n    }\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        ImPlotAxis& y_axis = plot.YAxis(i);\n        if (y_axis.Enabled && y_axis.HasGridLines() && !y_axis.IsForeground())\n            RenderGridLinesY(DrawList, y_axis.Ticker, plot.PlotRect,  y_axis.ColorMaj, y_axis.ColorMin, gp.Style.MajorGridSize.y, gp.Style.MinorGridSize.y);\n    }\n\n    // render x axis button, label, tick labels\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        ImPlotAxis& ax = plot.XAxis(i);\n        if (!ax.Enabled)\n            continue;\n        if ((ax.Hovered || ax.Held) && !plot.Held && !ImHasFlag(ax.Flags, ImPlotAxisFlags_NoHighlight))\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.Held ? ax.ColorAct : ax.ColorHov);\n        else if (ax.ColorHiLi != IM_COL32_BLACK_TRANS) {\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorHiLi);\n            ax.ColorHiLi = IM_COL32_BLACK_TRANS;\n        }\n        else if (ax.ColorBg != IM_COL32_BLACK_TRANS) {\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorBg);\n        }\n        const ImPlotTicker& tkr = ax.Ticker;\n        const bool opp = ax.IsOpposite();\n        if (ax.HasLabel()) {\n            const char* label        = plot.GetAxisLabel(ax);\n            const ImVec2 label_size  = ImGui::CalcTextSize(label);\n            const float label_offset = (ax.HasTickLabels() ? tkr.MaxSize.y + gp.Style.LabelPadding.y : 0.0f)\n                                     + (tkr.Levels - 1) * (txt_height + gp.Style.LabelPadding.y)\n                                     + gp.Style.LabelPadding.y;\n            const ImVec2 label_pos(plot.PlotRect.GetCenter().x - label_size.x * 0.5f,\n                                   opp ? ax.Datum1 - label_offset - label_size.y : ax.Datum1 + label_offset);\n            DrawList.AddText(label_pos, ax.ColorTxt, label);\n        }\n        if (ax.HasTickLabels()) {\n            for (int j = 0; j < tkr.TickCount(); ++j) {\n                const ImPlotTick& tk = tkr.Ticks[j];\n                const float datum = ax.Datum1 + (opp ? (-gp.Style.LabelPadding.y -txt_height -tk.Level * (txt_height + gp.Style.LabelPadding.y))\n                                                     : gp.Style.LabelPadding.y + tk.Level * (txt_height + gp.Style.LabelPadding.y));\n                if (tk.ShowLabel && tk.PixelPos >= plot.PlotRect.Min.x - 1 && tk.PixelPos <= plot.PlotRect.Max.x + 1) {\n                    ImVec2 start(tk.PixelPos - 0.5f * tk.LabelSize.x, datum);\n                    DrawList.AddText(start, ax.ColorTxt, tkr.GetText(j));\n                }\n            }\n        }\n    }\n\n    // render y axis button, label, tick labels\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        ImPlotAxis& ax = plot.YAxis(i);\n        if (!ax.Enabled)\n            continue;\n        if ((ax.Hovered || ax.Held) && !plot.Held && !ImHasFlag(ax.Flags, ImPlotAxisFlags_NoHighlight))\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.Held ? ax.ColorAct : ax.ColorHov);\n        else if (ax.ColorHiLi != IM_COL32_BLACK_TRANS) {\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorHiLi);\n            ax.ColorHiLi = IM_COL32_BLACK_TRANS;\n        }\n        else if (ax.ColorBg != IM_COL32_BLACK_TRANS) {\n            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorBg);\n        }\n        const ImPlotTicker& tkr = ax.Ticker;\n        const bool opp = ax.IsOpposite();\n        if (ax.HasLabel()) {\n            const char* label        = plot.GetAxisLabel(ax);\n            const ImVec2 label_size  = CalcTextSizeVertical(label);\n            const float label_offset = (ax.HasTickLabels() ? tkr.MaxSize.x + gp.Style.LabelPadding.x : 0.0f)\n                                     + gp.Style.LabelPadding.x;\n            const ImVec2 label_pos(opp ? ax.Datum1 + label_offset : ax.Datum1 - label_offset - label_size.x,\n                                   plot.PlotRect.GetCenter().y + label_size.y * 0.5f);\n            AddTextVertical(&DrawList, label_pos, ax.ColorTxt, label);\n        }\n        if (ax.HasTickLabels()) {\n            for (int j = 0; j < tkr.TickCount(); ++j) {\n                const ImPlotTick& tk = tkr.Ticks[j];\n                const float datum = ax.Datum1 + (opp ? gp.Style.LabelPadding.x : (-gp.Style.LabelPadding.x - tk.LabelSize.x));\n                if (tk.ShowLabel && tk.PixelPos >= plot.PlotRect.Min.y - 1 && tk.PixelPos <= plot.PlotRect.Max.y + 1) {\n                    ImVec2 start(datum, tk.PixelPos - 0.5f * tk.LabelSize.y);\n                    DrawList.AddText(start, ax.ColorTxt, tkr.GetText(j));\n                }\n            }\n        }\n    }\n\n\n    // clear legend (TODO: put elsewhere)\n    plot.Items.Legend.Reset();\n    // push ID to set item hashes (NB: !!!THIS PROBABLY NEEDS TO BE IN BEGIN PLOT!!!!)\n    ImGui::PushOverrideID(gp.CurrentItems->ID);\n}\n\n//-----------------------------------------------------------------------------\n// EndPlot()\n//-----------------------------------------------------------------------------\n\nvoid EndPlot() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"Mismatched BeginPlot()/EndPlot()!\");\n\n    SetupLock();\n\n    ImGuiContext &G       = *GImGui;\n    ImPlotPlot &plot      = *gp.CurrentPlot;\n    ImGuiWindow * Window  = G.CurrentWindow;\n    ImDrawList & DrawList = *Window->DrawList;\n    const ImGuiIO &   IO  = ImGui::GetIO();\n\n    // FINAL RENDER -----------------------------------------------------------\n\n    const bool render_border  = gp.Style.PlotBorderSize > 0 && GetStyleColorVec4(ImPlotCol_PlotBorder).w > 0;\n    const bool any_x_held = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);\n    const bool any_y_held = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);\n\n    ImGui::PushClipRect(plot.FrameRect.Min, plot.FrameRect.Max, true);\n\n    // render grid (foreground)\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        ImPlotAxis& x_axis = plot.XAxis(i);\n        if (x_axis.Enabled && x_axis.HasGridLines() && x_axis.IsForeground())\n            RenderGridLinesX(DrawList, x_axis.Ticker, plot.PlotRect, x_axis.ColorMaj, x_axis.ColorMin, gp.Style.MajorGridSize.x, gp.Style.MinorGridSize.x);\n    }\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        ImPlotAxis& y_axis = plot.YAxis(i);\n        if (y_axis.Enabled && y_axis.HasGridLines() && y_axis.IsForeground())\n            RenderGridLinesY(DrawList, y_axis.Ticker, plot.PlotRect,  y_axis.ColorMaj, y_axis.ColorMin, gp.Style.MajorGridSize.y, gp.Style.MinorGridSize.y);\n    }\n\n\n    // render title\n    if (plot.HasTitle()) {\n        ImU32 col = GetStyleColorU32(ImPlotCol_TitleText);\n        AddTextCentered(&DrawList,ImVec2(plot.PlotRect.GetCenter().x, plot.CanvasRect.Min.y),col,plot.GetTitle());\n    }\n\n    // render x ticks\n    int count_B = 0, count_T = 0;\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n        const ImPlotAxis& ax = plot.XAxis(i);\n        if (!ax.Enabled)\n            continue;\n        const ImPlotTicker& tkr = ax.Ticker;\n        const bool opp = ax.IsOpposite();\n        const bool aux = ((opp && count_T > 0)||(!opp && count_B > 0));\n        if (ax.HasTickMarks()) {\n            const float direction = opp ? 1.0f : -1.0f;\n            for (int j = 0; j < tkr.TickCount(); ++j) {\n                const ImPlotTick& tk = tkr.Ticks[j];\n                if (tk.Level != 0 || tk.PixelPos < plot.PlotRect.Min.x || tk.PixelPos > plot.PlotRect.Max.x)\n                    continue;\n                const ImVec2 start(tk.PixelPos, ax.Datum1);\n                const float len = (!aux && tk.Major) ? gp.Style.MajorTickLen.x  : gp.Style.MinorTickLen.x;\n                const float thk = (!aux && tk.Major) ? gp.Style.MajorTickSize.x : gp.Style.MinorTickSize.x;\n                DrawList.AddLine(start, start + ImVec2(0,direction*len), ax.ColorTick, thk);\n            }\n            if (aux || !render_border)\n                DrawList.AddLine(ImVec2(plot.PlotRect.Min.x,ax.Datum1), ImVec2(plot.PlotRect.Max.x,ax.Datum1), ax.ColorTick, gp.Style.MinorTickSize.x);\n        }\n        count_B += !opp;\n        count_T +=  opp;\n    }\n\n    // render y ticks\n    int count_L = 0, count_R = 0;\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n        const ImPlotAxis& ax = plot.YAxis(i);\n        if (!ax.Enabled)\n            continue;\n        const ImPlotTicker& tkr = ax.Ticker;\n        const bool opp = ax.IsOpposite();\n        const bool aux = ((opp && count_R > 0)||(!opp && count_L > 0));\n        if (ax.HasTickMarks()) {\n            const float direction = opp ? -1.0f : 1.0f;\n            for (int j = 0; j < tkr.TickCount(); ++j) {\n                const ImPlotTick& tk = tkr.Ticks[j];\n                if (tk.Level != 0 || tk.PixelPos < plot.PlotRect.Min.y || tk.PixelPos > plot.PlotRect.Max.y)\n                    continue;\n                const ImVec2 start(ax.Datum1, tk.PixelPos);\n                const float len = (!aux && tk.Major) ? gp.Style.MajorTickLen.y  : gp.Style.MinorTickLen.y;\n                const float thk = (!aux && tk.Major) ? gp.Style.MajorTickSize.y : gp.Style.MinorTickSize.y;\n                DrawList.AddLine(start, start + ImVec2(direction*len,0), ax.ColorTick, thk);\n            }\n            if (aux || !render_border)\n                DrawList.AddLine(ImVec2(ax.Datum1, plot.PlotRect.Min.y), ImVec2(ax.Datum1, plot.PlotRect.Max.y), ax.ColorTick, gp.Style.MinorTickSize.y);\n        }\n        count_L += !opp;\n        count_R +=  opp;\n    }\n    ImGui::PopClipRect();\n\n    // render annotations\n    PushPlotClipRect();\n    for (int i = 0; i < gp.Annotations.Size; ++i) {\n        const char* txt       = gp.Annotations.GetText(i);\n        ImPlotAnnotation& an  = gp.Annotations.Annotations[i];\n        const ImVec2 txt_size = ImGui::CalcTextSize(txt);\n        const ImVec2 size     = txt_size + gp.Style.AnnotationPadding * 2;\n        ImVec2 pos            = an.Pos;\n        if (an.Offset.x == 0)\n            pos.x -= size.x / 2;\n        else if (an.Offset.x > 0)\n            pos.x += an.Offset.x;\n        else\n            pos.x -= size.x - an.Offset.x;\n        if (an.Offset.y == 0)\n            pos.y -= size.y / 2;\n        else if (an.Offset.y > 0)\n            pos.y += an.Offset.y;\n        else\n            pos.y -= size.y - an.Offset.y;\n        if (an.Clamp)\n            pos = ClampLabelPos(pos, size, plot.PlotRect.Min, plot.PlotRect.Max);\n        ImRect rect(pos,pos+size);\n        if (an.Offset.x != 0 || an.Offset.y != 0) {\n            ImVec2 corners[4] = {rect.GetTL(), rect.GetTR(), rect.GetBR(), rect.GetBL()};\n            int min_corner = 0;\n            float min_len = FLT_MAX;\n            for (int c = 0; c < 4; ++c) {\n                float len = ImLengthSqr(an.Pos - corners[c]);\n                if (len < min_len) {\n                    min_corner = c;\n                    min_len = len;\n                }\n            }\n            DrawList.AddLine(an.Pos, corners[min_corner], an.ColorBg);\n        }\n        DrawList.AddRectFilled(rect.Min, rect.Max, an.ColorBg);\n        DrawList.AddText(pos + gp.Style.AnnotationPadding, an.ColorFg, txt);\n    }\n\n    // render selection\n    if (plot.Selected)\n        RenderSelectionRect(DrawList, plot.SelectRect.Min + plot.PlotRect.Min, plot.SelectRect.Max + plot.PlotRect.Min, GetStyleColorVec4(ImPlotCol_Selection));\n\n    // render crosshairs\n    if (ImHasFlag(plot.Flags, ImPlotFlags_Crosshairs) && plot.Hovered && !(any_x_held || any_y_held) && !plot.Selecting && !plot.Items.Legend.Hovered) {\n        ImGui::SetMouseCursor(ImGuiMouseCursor_None);\n        ImVec2 xy = IO.MousePos;\n        ImVec2 h1(plot.PlotRect.Min.x, xy.y);\n        ImVec2 h2(xy.x - 5, xy.y);\n        ImVec2 h3(xy.x + 5, xy.y);\n        ImVec2 h4(plot.PlotRect.Max.x, xy.y);\n        ImVec2 v1(xy.x, plot.PlotRect.Min.y);\n        ImVec2 v2(xy.x, xy.y - 5);\n        ImVec2 v3(xy.x, xy.y + 5);\n        ImVec2 v4(xy.x, plot.PlotRect.Max.y);\n        ImU32 col = GetStyleColorU32(ImPlotCol_Crosshairs);\n        DrawList.AddLine(h1, h2, col);\n        DrawList.AddLine(h3, h4, col);\n        DrawList.AddLine(v1, v2, col);\n        DrawList.AddLine(v3, v4, col);\n    }\n\n    // render mouse pos\n    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoMouseText) && (plot.Hovered || ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_ShowAlways))) {\n\n        const bool no_aux = ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_NoAuxAxes);\n        const bool no_fmt = ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_NoFormat);\n\n        ImGuiTextBuffer& builder = gp.MousePosStringBuilder;\n        builder.Buf.shrink(0);\n        char buff[IMPLOT_LABEL_MAX_SIZE];\n\n        const int num_x = no_aux ? 1 : IMPLOT_NUM_X_AXES;\n        for (int i = 0; i < num_x; ++i) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            if (!x_axis.Enabled)\n                continue;\n            if (i > 0)\n                builder.append(\", (\");\n            double v = x_axis.PixelsToPlot(IO.MousePos.x);\n            if (no_fmt)\n                Formatter_Default(v,buff,IMPLOT_LABEL_MAX_SIZE,(void*)IMPLOT_LABEL_FORMAT);\n            else\n                LabelAxisValue(x_axis,v,buff,IMPLOT_LABEL_MAX_SIZE,true);\n            builder.append(buff);\n            if (i > 0)\n                builder.append(\")\");\n        }\n        builder.append(\", \");\n        const int num_y = no_aux ? 1 : IMPLOT_NUM_Y_AXES;\n        for (int i = 0; i < num_y; ++i) {\n            ImPlotAxis& y_axis = plot.YAxis(i);\n            if (!y_axis.Enabled)\n                continue;\n            if (i > 0)\n                builder.append(\", (\");\n            double v = y_axis.PixelsToPlot(IO.MousePos.y);\n            if (no_fmt)\n                Formatter_Default(v,buff,IMPLOT_LABEL_MAX_SIZE,(void*)IMPLOT_LABEL_FORMAT);\n            else\n                LabelAxisValue(y_axis,v,buff,IMPLOT_LABEL_MAX_SIZE,true);\n            builder.append(buff);\n            if (i > 0)\n                builder.append(\")\");\n        }\n\n        if (!builder.empty()) {\n            const ImVec2 size = ImGui::CalcTextSize(builder.c_str());\n            const ImVec2 pos = GetLocationPos(plot.PlotRect, size, plot.MouseTextLocation, gp.Style.MousePosPadding);\n            DrawList.AddText(pos, GetStyleColorU32(ImPlotCol_InlayText), builder.c_str());\n        }\n    }\n    PopPlotClipRect();\n\n    // axis side switch\n    if (!plot.Held) {\n        ImVec2 mouse_pos = ImGui::GetIO().MousePos;\n        ImRect trigger_rect = plot.PlotRect;\n        trigger_rect.Expand(-10);\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            if (ImHasFlag(x_axis.Flags, ImPlotAxisFlags_NoSideSwitch))\n                continue;\n            if (x_axis.Held && plot.PlotRect.Contains(mouse_pos)) {\n                const bool opp = ImHasFlag(x_axis.Flags, ImPlotAxisFlags_Opposite);\n                if (!opp) {\n                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Min.y - 5,\n                                plot.PlotRect.Max.x + 5, plot.PlotRect.Min.y + 5);\n                    if (mouse_pos.y < plot.PlotRect.Max.y - 10)\n                        DrawList.AddRectFilled(rect.Min, rect.Max, x_axis.ColorHov);\n                    if (rect.Contains(mouse_pos))\n                        x_axis.Flags |= ImPlotAxisFlags_Opposite;\n                }\n                else {\n                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Max.y - 5,\n                                plot.PlotRect.Max.x + 5, plot.PlotRect.Max.y + 5);\n                    if (mouse_pos.y > plot.PlotRect.Min.y + 10)\n                        DrawList.AddRectFilled(rect.Min, rect.Max, x_axis.ColorHov);\n                    if (rect.Contains(mouse_pos))\n                        x_axis.Flags &= ~ImPlotAxisFlags_Opposite;\n                }\n            }\n        }\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n            ImPlotAxis& y_axis = plot.YAxis(i);\n            if (ImHasFlag(y_axis.Flags, ImPlotAxisFlags_NoSideSwitch))\n                continue;\n            if (y_axis.Held && plot.PlotRect.Contains(mouse_pos)) {\n                const bool opp = ImHasFlag(y_axis.Flags, ImPlotAxisFlags_Opposite);\n                if (!opp) {\n                    ImRect rect(plot.PlotRect.Max.x - 5, plot.PlotRect.Min.y - 5,\n                                plot.PlotRect.Max.x + 5, plot.PlotRect.Max.y + 5);\n                    if (mouse_pos.x > plot.PlotRect.Min.x + 10)\n                        DrawList.AddRectFilled(rect.Min, rect.Max, y_axis.ColorHov);\n                    if (rect.Contains(mouse_pos))\n                        y_axis.Flags |= ImPlotAxisFlags_Opposite;\n                }\n                else {\n                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Min.y - 5,\n                                plot.PlotRect.Min.x + 5, plot.PlotRect.Max.y + 5);\n                    if (mouse_pos.x < plot.PlotRect.Max.x - 10)\n                        DrawList.AddRectFilled(rect.Min, rect.Max, y_axis.ColorHov);\n                    if (rect.Contains(mouse_pos))\n                        y_axis.Flags &= ~ImPlotAxisFlags_Opposite;\n                }\n            }\n        }\n    }\n\n    // reset legend hovers\n    plot.Items.Legend.Hovered = false;\n    for (int i = 0; i < plot.Items.GetItemCount(); ++i)\n        plot.Items.GetItemByIndex(i)->LegendHovered = false;\n    // render legend\n    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoLegend) && plot.Items.GetLegendCount() > 0) {\n        ImPlotLegend& legend = plot.Items.Legend;\n        const bool   legend_out  = ImHasFlag(legend.Flags, ImPlotLegendFlags_Outside);\n        const bool   legend_horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);\n        const ImVec2 legend_size = CalcLegendSize(plot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz);\n        const ImVec2 legend_pos  = GetLocationPos(legend_out ? plot.FrameRect : plot.PlotRect,\n                                                  legend_size,\n                                                  legend.Location,\n                                                  legend_out ? gp.Style.PlotPadding : gp.Style.LegendPadding);\n        legend.Rect = ImRect(legend_pos, legend_pos + legend_size);\n        legend.RectClamped = legend.Rect;\n        const bool legend_scrollable = ClampLegendRect(legend.RectClamped,\n                                                        legend_out ? plot.FrameRect : plot.PlotRect,\n                                                        legend_out ? gp.Style.PlotPadding : gp.Style.LegendPadding\n                                                        );\n        const ImGuiButtonFlags legend_button_flags = ImGuiButtonFlags_AllowOverlap\n                                                    | ImGuiButtonFlags_PressedOnClick\n                                                    | ImGuiButtonFlags_PressedOnDoubleClick\n                                                    | ImGuiButtonFlags_MouseButtonLeft\n                                                    | ImGuiButtonFlags_MouseButtonRight\n                                                    | ImGuiButtonFlags_MouseButtonMiddle\n                                                    | ImGuiButtonFlags_FlattenChildren;\n        ImGui::KeepAliveID(plot.Items.ID);\n        ImGui::ButtonBehavior(legend.RectClamped, plot.Items.ID, &legend.Hovered, &legend.Held, legend_button_flags);\n        legend.Hovered = legend.Hovered || (ImGui::IsWindowHovered() && legend.RectClamped.Contains(IO.MousePos));\n\n        if (legend_scrollable) {\n            if (legend.Hovered) {\n                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.Items.ID);\n                if (IO.MouseWheel != 0.0f) {\n                    ImVec2 max_step = legend.Rect.GetSize() * 0.67f;\n                    float font_size = ImGui::GetCurrentWindow()->CalcFontSize();\n                    float scroll_step = ImFloor(ImMin(2 * font_size, max_step.x));\n                    legend.Scroll.x += scroll_step * IO.MouseWheel;\n                    legend.Scroll.y += scroll_step * IO.MouseWheel;\n                }\n            }\n            const ImVec2 min_scroll_offset = legend.RectClamped.GetSize() - legend.Rect.GetSize();\n            legend.Scroll.x = ImClamp(legend.Scroll.x, min_scroll_offset.x, 0.0f);\n            legend.Scroll.y = ImClamp(legend.Scroll.y, min_scroll_offset.y, 0.0f);\n            const ImVec2 scroll_offset = legend_horz ? ImVec2(legend.Scroll.x, 0) : ImVec2(0, legend.Scroll.y);\n            ImVec2 legend_offset = legend.RectClamped.Min - legend.Rect.Min + scroll_offset;\n            legend.Rect.Min += legend_offset;\n            legend.Rect.Max += legend_offset;\n        } else {\n            legend.Scroll = ImVec2(0,0);\n        }\n\n        const ImU32 col_bg  = GetStyleColorU32(ImPlotCol_LegendBg);\n        const ImU32 col_bd  = GetStyleColorU32(ImPlotCol_LegendBorder);\n        ImGui::PushClipRect(legend.RectClamped.Min, legend.RectClamped.Max, true);\n        DrawList.AddRectFilled(legend.RectClamped.Min, legend.RectClamped.Max, col_bg);\n        bool legend_contextable = ShowLegendEntries(plot.Items, legend.Rect, legend.Hovered, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz, DrawList)\n                                && !ImHasFlag(legend.Flags, ImPlotLegendFlags_NoMenus);\n        DrawList.AddRect(legend.RectClamped.Min, legend.RectClamped.Max, col_bd);\n        ImGui::PopClipRect();\n\n        // main ctx menu\n        if (gp.OpenContextThisFrame && legend_contextable && !ImHasFlag(plot.Flags, ImPlotFlags_NoMenus))\n            ImGui::OpenPopup(\"##LegendContext\");\n\n        if (ImGui::BeginPopup(\"##LegendContext\")) {\n            ImGui::Text(\"Legend\"); ImGui::Separator();\n            if (ShowLegendContextMenu(legend, !ImHasFlag(plot.Flags, ImPlotFlags_NoLegend)))\n                ImFlipFlag(plot.Flags, ImPlotFlags_NoLegend);\n            ImGui::EndPopup();\n        }\n    }\n    else {\n        plot.Items.Legend.Rect = ImRect();\n    }\n\n    // render border\n    if (render_border)\n        DrawList.AddRect(plot.PlotRect.Min, plot.PlotRect.Max, GetStyleColorU32(ImPlotCol_PlotBorder), 0, ImDrawFlags_RoundCornersAll, gp.Style.PlotBorderSize);\n\n    // render tags\n    for (int i = 0; i < gp.Tags.Size; ++i) {\n        ImPlotTag& tag  = gp.Tags.Tags[i];\n        ImPlotAxis& axis = plot.Axes[tag.Axis];\n        if (!axis.Enabled || !axis.Range.Contains(tag.Value))\n            continue;\n        const char* txt = gp.Tags.GetText(i);\n        ImVec2 text_size = ImGui::CalcTextSize(txt);\n        ImVec2 size = text_size + gp.Style.AnnotationPadding * 2;\n        ImVec2 pos;\n        axis.Ticker.OverrideSizeLate(size);\n        float pix = IM_ROUND(axis.PlotToPixels(tag.Value));\n        if (axis.Vertical) {\n            if (axis.IsOpposite()) {\n                pos = ImVec2(axis.Datum1 + gp.Style.LabelPadding.x, pix - size.y * 0.5f);\n                DrawList.AddTriangleFilled(ImVec2(axis.Datum1,pix), pos, pos + ImVec2(0,size.y), tag.ColorBg);\n            }\n            else {\n                pos = ImVec2(axis.Datum1 - size.x - gp.Style.LabelPadding.x, pix - size.y * 0.5f);\n                DrawList.AddTriangleFilled(pos + ImVec2(size.x,0), ImVec2(axis.Datum1,pix), pos+size, tag.ColorBg);\n            }\n        }\n        else {\n            if (axis.IsOpposite()) {\n                pos = ImVec2(pix - size.x * 0.5f, axis.Datum1 - size.y - gp.Style.LabelPadding.y );\n                DrawList.AddTriangleFilled(pos + ImVec2(0,size.y), pos + size, ImVec2(pix,axis.Datum1), tag.ColorBg);\n            }\n            else {\n                pos = ImVec2(pix - size.x * 0.5f, axis.Datum1 + gp.Style.LabelPadding.y);\n                DrawList.AddTriangleFilled(pos, ImVec2(pix,axis.Datum1), pos + ImVec2(size.x, 0), tag.ColorBg);\n            }\n        }\n        DrawList.AddRectFilled(pos,pos+size,tag.ColorBg);\n        DrawList.AddText(pos+gp.Style.AnnotationPadding,tag.ColorFg,txt);\n    }\n\n    // FIT DATA --------------------------------------------------------------\n    const bool axis_equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);\n    if (plot.FitThisFrame) {\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {\n            ImPlotAxis& x_axis = plot.XAxis(i);\n            if (x_axis.FitThisFrame) {\n                x_axis.ApplyFit(gp.Style.FitPadding.x);\n                if (axis_equal && x_axis.OrthoAxis != nullptr) {\n                    double aspect = x_axis.GetAspect();\n                    ImPlotAxis& y_axis = *x_axis.OrthoAxis;\n                    if (y_axis.FitThisFrame) {\n                        y_axis.ApplyFit(gp.Style.FitPadding.y);\n                        y_axis.FitThisFrame = false;\n                        aspect = ImMax(aspect, y_axis.GetAspect());\n                    }\n                    x_axis.SetAspect(aspect);\n                    y_axis.SetAspect(aspect);\n                }\n            }\n        }\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {\n            ImPlotAxis& y_axis = plot.YAxis(i);\n            if (y_axis.FitThisFrame) {\n                y_axis.ApplyFit(gp.Style.FitPadding.y);\n                if (axis_equal && y_axis.OrthoAxis != nullptr) {\n                    double aspect = y_axis.GetAspect();\n                    ImPlotAxis& x_axis = *y_axis.OrthoAxis;\n                    if (x_axis.FitThisFrame) {\n                        x_axis.ApplyFit(gp.Style.FitPadding.x);\n                        x_axis.FitThisFrame = false;\n                        aspect = ImMax(x_axis.GetAspect(), aspect);\n                    }\n                    x_axis.SetAspect(aspect);\n                    y_axis.SetAspect(aspect);\n                }\n            }\n        }\n        plot.FitThisFrame = false;\n    }\n\n    // CONTEXT MENUS -----------------------------------------------------------\n\n    ImGui::PushOverrideID(plot.ID);\n\n    const bool can_ctx = gp.OpenContextThisFrame &&\n                         !ImHasFlag(plot.Flags, ImPlotFlags_NoMenus) &&\n                         !plot.Items.Legend.Hovered;\n\n\n\n    // main ctx menu\n    if (can_ctx && plot.Hovered)\n        ImGui::OpenPopup(\"##PlotContext\");\n    if (ImGui::BeginPopup(\"##PlotContext\")) {\n        ShowPlotContextMenu(plot);\n        ImGui::EndPopup();\n    }\n\n    // axes ctx menus\n    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n        ImGui::PushID(i);\n        ImPlotAxis& x_axis = plot.XAxis(i);\n        if (can_ctx && x_axis.Hovered && x_axis.HasMenus())\n            ImGui::OpenPopup(\"##XContext\");\n        if (ImGui::BeginPopup(\"##XContext\")) {\n            ImGui::Text(x_axis.HasLabel() ? plot.GetAxisLabel(x_axis) :  i == 0 ? \"X-Axis\" : \"X-Axis %d\", i + 1);\n            ImGui::Separator();\n            ShowAxisContextMenu(x_axis, axis_equal ? x_axis.OrthoAxis : nullptr, true);\n            ImGui::EndPopup();\n        }\n        ImGui::PopID();\n    }\n    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n        ImGui::PushID(i);\n        ImPlotAxis& y_axis = plot.YAxis(i);\n        if (can_ctx && y_axis.Hovered && y_axis.HasMenus())\n            ImGui::OpenPopup(\"##YContext\");\n        if (ImGui::BeginPopup(\"##YContext\")) {\n            ImGui::Text(y_axis.HasLabel() ? plot.GetAxisLabel(y_axis) : i == 0 ? \"Y-Axis\" : \"Y-Axis %d\", i + 1);\n            ImGui::Separator();\n            ShowAxisContextMenu(y_axis, axis_equal ? y_axis.OrthoAxis : nullptr, false);\n            ImGui::EndPopup();\n        }\n        ImGui::PopID();\n    }\n    ImGui::PopID();\n\n    // LINKED AXES ------------------------------------------------------------\n\n    for (int i = 0; i < ImAxis_COUNT; ++i)\n        plot.Axes[i].PushLinks();\n\n\n    // CLEANUP ----------------------------------------------------------------\n\n    // remove items\n    if (gp.CurrentItems == &plot.Items)\n        gp.CurrentItems = nullptr;\n    // reset the plot items for the next frame\n    for (int i = 0; i < plot.Items.GetItemCount(); ++i) {\n        plot.Items.GetItemByIndex(i)->SeenThisFrame = false;\n    }\n\n    // mark the plot as initialized, i.e. having made it through one frame completely\n    plot.Initialized = true;\n    // Pop ImGui::PushID at the end of BeginPlot\n    ImGui::PopID();\n    // Reset context for next plot\n    ResetCtxForNextPlot(GImPlot);\n\n    // setup next subplot\n    if (gp.CurrentSubplot != nullptr) {\n        ImGui::PopID();\n        SubplotNextCell();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// BEGIN/END SUBPLOT\n//-----------------------------------------------------------------------------\n\nstatic const float SUBPLOT_BORDER_SIZE             = 1.0f;\nstatic const float SUBPLOT_SPLITTER_HALF_THICKNESS = 4.0f;\nstatic const float SUBPLOT_SPLITTER_FEEDBACK_TIMER = 0.06f;\n\nvoid SubplotSetCell(int row, int col) {\n    ImPlotContext& gp      = *GImPlot;\n    ImPlotSubplot& subplot = *gp.CurrentSubplot;\n    if (row >= subplot.Rows || col >= subplot.Cols)\n        return;\n    float xoff = 0;\n    float yoff = 0;\n    for (int c = 0; c < col; ++c)\n        xoff += subplot.ColRatios[c];\n    for (int r = 0; r < row; ++r)\n        yoff += subplot.RowRatios[r];\n    const ImVec2 grid_size = subplot.GridRect.GetSize();\n    ImVec2 cpos            = subplot.GridRect.Min + ImVec2(xoff*grid_size.x,yoff*grid_size.y);\n    cpos.x = IM_ROUND(cpos.x);\n    cpos.y = IM_ROUND(cpos.y);\n    ImGui::GetCurrentWindow()->DC.CursorPos =  cpos;\n    // set cell size\n    subplot.CellSize.x = IM_ROUND(subplot.GridRect.GetWidth()  * subplot.ColRatios[col]);\n    subplot.CellSize.y = IM_ROUND(subplot.GridRect.GetHeight() * subplot.RowRatios[row]);\n    // setup links\n    const bool lx = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX);\n    const bool ly = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY);\n    const bool lr = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows);\n    const bool lc = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols);\n\n    SetNextAxisLinks(ImAxis_X1, lx ? &subplot.ColLinkData[0].Min : lc ? &subplot.ColLinkData[col].Min : nullptr,\n                                lx ? &subplot.ColLinkData[0].Max : lc ? &subplot.ColLinkData[col].Max : nullptr);\n    SetNextAxisLinks(ImAxis_Y1, ly ? &subplot.RowLinkData[0].Min : lr ? &subplot.RowLinkData[row].Min : nullptr,\n                                ly ? &subplot.RowLinkData[0].Max : lr ? &subplot.RowLinkData[row].Max : nullptr);\n    // setup alignment\n    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign)) {\n        gp.CurrentAlignmentH = &subplot.RowAlignmentData[row];\n        gp.CurrentAlignmentV = &subplot.ColAlignmentData[col];\n    }\n    // set idx\n    if (ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ColMajor))\n        subplot.CurrentIdx = col * subplot.Rows + row;\n    else\n        subplot.CurrentIdx = row * subplot.Cols + col;\n}\n\nvoid SubplotSetCell(int idx) {\n    ImPlotContext& gp      = *GImPlot;\n    ImPlotSubplot& subplot = *gp.CurrentSubplot;\n    if (idx >= subplot.Rows * subplot.Cols)\n        return;\n    int row = 0, col = 0;\n    if (ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ColMajor)) {\n        row = idx % subplot.Rows;\n        col = idx / subplot.Rows;\n    }\n    else {\n        row = idx / subplot.Cols;\n        col = idx % subplot.Cols;\n    }\n    return SubplotSetCell(row, col);\n}\n\nvoid SubplotNextCell() {\n    ImPlotContext& gp      = *GImPlot;\n    ImPlotSubplot& subplot = *gp.CurrentSubplot;\n    SubplotSetCell(++subplot.CurrentIdx);\n}\n\nbool BeginSubplots(const char* title, int rows, int cols, const ImVec2& size, ImPlotSubplotFlags flags, float* row_sizes, float* col_sizes) {\n    IM_ASSERT_USER_ERROR(rows > 0 && cols > 0, \"Invalid sizing arguments!\");\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentSubplot == nullptr, \"Mismatched BeginSubplots()/EndSubplots()!\");\n    ImGuiContext &G = *GImGui;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return false;\n    const ImGuiID ID = Window->GetID(title);\n    bool just_created = gp.Subplots.GetByKey(ID) == nullptr;\n    gp.CurrentSubplot = gp.Subplots.GetOrAddByKey(ID);\n    ImPlotSubplot& subplot = *gp.CurrentSubplot;\n    subplot.ID       = ID;\n    subplot.Items.ID = ID - 1;\n    subplot.HasTitle = ImGui::FindRenderedTextEnd(title, nullptr) != title;\n    // push ID\n    ImGui::PushID(ID);\n\n    if (just_created)\n        subplot.Flags = flags;\n    else if (flags != subplot.PreviousFlags)\n        subplot.Flags = flags;\n    subplot.PreviousFlags = flags;\n\n    // check for change in rows and cols\n    if (subplot.Rows != rows || subplot.Cols != cols) {\n        subplot.RowAlignmentData.resize(rows);\n        subplot.RowLinkData.resize(rows);\n        subplot.RowRatios.resize(rows);\n        for (int r = 0; r < rows; ++r) {\n            subplot.RowAlignmentData[r].Reset();\n            subplot.RowLinkData[r] = ImPlotRange(0,1);\n            subplot.RowRatios[r] = 1.0f / rows;\n        }\n        subplot.ColAlignmentData.resize(cols);\n        subplot.ColLinkData.resize(cols);\n        subplot.ColRatios.resize(cols);\n        for (int c = 0; c < cols; ++c) {\n            subplot.ColAlignmentData[c].Reset();\n            subplot.ColLinkData[c] = ImPlotRange(0,1);\n            subplot.ColRatios[c] = 1.0f / cols;\n        }\n    }\n    // check incoming size requests\n    float row_sum = 0, col_sum = 0;\n    if (row_sizes != nullptr) {\n        row_sum = ImSum(row_sizes, rows);\n        for (int r = 0; r < rows; ++r)\n            subplot.RowRatios[r] = row_sizes[r] / row_sum;\n    }\n    if (col_sizes != nullptr) {\n        col_sum = ImSum(col_sizes, cols);\n        for (int c = 0; c < cols; ++c)\n            subplot.ColRatios[c] = col_sizes[c] / col_sum;\n    }\n    subplot.Rows = rows;\n    subplot.Cols = cols;\n\n    // calc plot frame sizes\n    ImVec2 title_size(0.0f, 0.0f);\n    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle))\n         title_size = ImGui::CalcTextSize(title, nullptr, true);\n    const float pad_top = title_size.x > 0.0f ? title_size.y + gp.Style.LabelPadding.y : 0;\n    const ImVec2 half_pad = gp.Style.PlotPadding/2;\n    const ImVec2 frame_size = ImGui::CalcItemSize(size, gp.Style.PlotDefaultSize.x, gp.Style.PlotDefaultSize.y);\n    subplot.FrameRect = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);\n    subplot.GridRect.Min = subplot.FrameRect.Min + half_pad + ImVec2(0,pad_top);\n    subplot.GridRect.Max = subplot.FrameRect.Max - half_pad;\n    subplot.FrameHovered = subplot.FrameRect.Contains(ImGui::GetMousePos()) && ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows|ImGuiHoveredFlags_AllowWhenBlockedByActiveItem);\n\n    // outside legend adjustments (TODO: make function)\n    const bool share_items = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);\n    if (share_items)\n        gp.CurrentItems = &subplot.Items;\n    if (share_items && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoLegend) && subplot.Items.GetLegendCount() > 0) {\n        ImPlotLegend& legend = subplot.Items.Legend;\n        const bool horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);\n        const ImVec2 legend_size = CalcLegendSize(subplot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !horz);\n        const bool west = ImHasFlag(legend.Location, ImPlotLocation_West) && !ImHasFlag(legend.Location, ImPlotLocation_East);\n        const bool east = ImHasFlag(legend.Location, ImPlotLocation_East) && !ImHasFlag(legend.Location, ImPlotLocation_West);\n        const bool north = ImHasFlag(legend.Location, ImPlotLocation_North) && !ImHasFlag(legend.Location, ImPlotLocation_South);\n        const bool south = ImHasFlag(legend.Location, ImPlotLocation_South) && !ImHasFlag(legend.Location, ImPlotLocation_North);\n        if ((west && !horz) || (west && horz && !north && !south))\n            subplot.GridRect.Min.x += (legend_size.x + gp.Style.LegendPadding.x);\n        if ((east && !horz) || (east && horz && !north && !south))\n            subplot.GridRect.Max.x -= (legend_size.x + gp.Style.LegendPadding.x);\n        if ((north && horz) || (north && !horz && !west && !east))\n            subplot.GridRect.Min.y += (legend_size.y + gp.Style.LegendPadding.y);\n        if ((south && horz) || (south && !horz && !west && !east))\n            subplot.GridRect.Max.y -= (legend_size.y + gp.Style.LegendPadding.y);\n    }\n\n    // render single background frame\n    ImGui::RenderFrame(subplot.FrameRect.Min, subplot.FrameRect.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, ImGui::GetStyle().FrameRounding);\n    // render title\n    if (title_size.x > 0.0f && !ImHasFlag(subplot.Flags, ImPlotFlags_NoTitle)) {\n        const ImU32 col = GetStyleColorU32(ImPlotCol_TitleText);\n        AddTextCentered(ImGui::GetWindowDrawList(),ImVec2(subplot.GridRect.GetCenter().x, subplot.GridRect.Min.y - pad_top + half_pad.y),col,title);\n    }\n\n    // render splitters\n    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoResize)) {\n        ImDrawList& DrawList = *ImGui::GetWindowDrawList();\n        const ImU32 hov_col = ImGui::ColorConvertFloat4ToU32(GImGui->Style.Colors[ImGuiCol_SeparatorHovered]);\n        const ImU32 act_col = ImGui::ColorConvertFloat4ToU32(GImGui->Style.Colors[ImGuiCol_SeparatorActive]);\n        float xpos = subplot.GridRect.Min.x;\n        float ypos = subplot.GridRect.Min.y;\n        int separator = 1;\n        // bool pass = false;\n        for (int r = 0; r < subplot.Rows-1; ++r) {\n            ypos += subplot.RowRatios[r] * subplot.GridRect.GetHeight();\n            const ImGuiID sep_id = subplot.ID + separator;\n            ImGui::KeepAliveID(sep_id);\n            const ImRect sep_bb = ImRect(subplot.GridRect.Min.x, ypos-SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Max.x, ypos+SUBPLOT_SPLITTER_HALF_THICKNESS);\n            bool sep_hov = false, sep_hld = false;\n            const bool sep_clk = ImGui::ButtonBehavior(sep_bb, sep_id, &sep_hov, &sep_hld, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick);\n            if ((sep_hov && G.HoveredIdTimer > SUBPLOT_SPLITTER_FEEDBACK_TIMER) || sep_hld) {\n                if (sep_clk && ImGui::IsMouseDoubleClicked(0)) {\n                    float p = (subplot.RowRatios[r] + subplot.RowRatios[r+1])/2;\n                    subplot.RowRatios[r] = subplot.RowRatios[r+1] = p;\n                }\n                if (sep_clk) {\n                    subplot.TempSizes[0] = subplot.RowRatios[r];\n                    subplot.TempSizes[1] = subplot.RowRatios[r+1];\n                }\n                if (sep_hld) {\n                    float dp = ImGui::GetMouseDragDelta(0).y  / subplot.GridRect.GetHeight();\n                    if (subplot.TempSizes[0] + dp > 0.1f && subplot.TempSizes[1] - dp > 0.1f) {\n                        subplot.RowRatios[r]   = subplot.TempSizes[0] + dp;\n                        subplot.RowRatios[r+1] = subplot.TempSizes[1] - dp;\n                    }\n                }\n                DrawList.AddLine(ImVec2(IM_ROUND(subplot.GridRect.Min.x),IM_ROUND(ypos)),\n                                 ImVec2(IM_ROUND(subplot.GridRect.Max.x),IM_ROUND(ypos)),\n                                 sep_hld ? act_col : hov_col, SUBPLOT_BORDER_SIZE);\n                ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);\n            }\n            separator++;\n        }\n        for (int c = 0; c < subplot.Cols-1; ++c) {\n            xpos += subplot.ColRatios[c] * subplot.GridRect.GetWidth();\n            const ImGuiID sep_id = subplot.ID + separator;\n            ImGui::KeepAliveID(sep_id);\n            const ImRect sep_bb = ImRect(xpos-SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Min.y, xpos+SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Max.y);\n            bool sep_hov = false, sep_hld = false;\n            const bool sep_clk = ImGui::ButtonBehavior(sep_bb, sep_id, &sep_hov, &sep_hld, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick);\n            if ((sep_hov && G.HoveredIdTimer > SUBPLOT_SPLITTER_FEEDBACK_TIMER) || sep_hld) {\n                if (sep_clk && ImGui::IsMouseDoubleClicked(0)) {\n                    float p = (subplot.ColRatios[c] + subplot.ColRatios[c+1])/2;\n                    subplot.ColRatios[c] = subplot.ColRatios[c+1] = p;\n                }\n                if (sep_clk) {\n                    subplot.TempSizes[0] = subplot.ColRatios[c];\n                    subplot.TempSizes[1] = subplot.ColRatios[c+1];\n                }\n                if (sep_hld) {\n                    float dp = ImGui::GetMouseDragDelta(0).x / subplot.GridRect.GetWidth();\n                    if (subplot.TempSizes[0] + dp > 0.1f && subplot.TempSizes[1] - dp > 0.1f) {\n                        subplot.ColRatios[c]   = subplot.TempSizes[0] + dp;\n                        subplot.ColRatios[c+1] = subplot.TempSizes[1] - dp;\n                    }\n                }\n                DrawList.AddLine(ImVec2(IM_ROUND(xpos),IM_ROUND(subplot.GridRect.Min.y)),\n                                 ImVec2(IM_ROUND(xpos),IM_ROUND(subplot.GridRect.Max.y)),\n                                 sep_hld ? act_col : hov_col, SUBPLOT_BORDER_SIZE);\n                ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);\n            }\n            separator++;\n        }\n    }\n\n    // set outgoing sizes\n    if (row_sizes != nullptr) {\n        for (int r = 0; r < rows; ++r)\n            row_sizes[r] = subplot.RowRatios[r] * row_sum;\n    }\n    if (col_sizes != nullptr) {\n        for (int c = 0; c < cols; ++c)\n            col_sizes[c] = subplot.ColRatios[c] * col_sum;\n    }\n\n    // push styling\n    PushStyleColor(ImPlotCol_FrameBg, IM_COL32_BLACK_TRANS);\n    PushStyleVar(ImPlotStyleVar_PlotPadding, half_pad);\n    PushStyleVar(ImPlotStyleVar_PlotMinSize, ImVec2(0,0));\n    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize,0);\n\n    // set initial cursor pos\n    Window->DC.CursorPos = subplot.GridRect.Min;\n    // begin alignments\n    for (int r = 0; r < subplot.Rows; ++r)\n        subplot.RowAlignmentData[r].Begin();\n    for (int c = 0; c < subplot.Cols; ++c)\n        subplot.ColAlignmentData[c].Begin();\n    // clear legend data\n    subplot.Items.Legend.Reset();\n    // Setup first subplot\n    SubplotSetCell(0,0);\n    return true;\n}\n\nvoid EndSubplots() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentSubplot != nullptr, \"Mismatched BeginSubplots()/EndSubplots()!\");\n    ImPlotSubplot& subplot = *gp.CurrentSubplot;\n    const ImGuiIO& IO  = ImGui::GetIO();\n    // set alignments\n    for (int r = 0; r < subplot.Rows; ++r)\n        subplot.RowAlignmentData[r].End();\n    for (int c = 0; c < subplot.Cols; ++c)\n        subplot.ColAlignmentData[c].End();\n    // pop styling\n    PopStyleColor();\n    PopStyleVar();\n    PopStyleVar();\n    ImGui::PopStyleVar();\n    // legend\n    subplot.Items.Legend.Hovered = false;\n    for (int i = 0; i < subplot.Items.GetItemCount(); ++i)\n        subplot.Items.GetItemByIndex(i)->LegendHovered = false;\n    // render legend\n    const bool share_items = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);\n    ImDrawList& DrawList = *ImGui::GetWindowDrawList();\n    if (share_items && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoLegend) && subplot.Items.GetLegendCount() > 0) {\n        ImPlotLegend& legend = subplot.Items.Legend;\n        const bool   legend_horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);\n        const ImVec2 legend_size = CalcLegendSize(subplot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz);\n        const ImVec2 legend_pos  = GetLocationPos(subplot.FrameRect, legend_size, legend.Location, gp.Style.PlotPadding);\n        legend.Rect = ImRect(legend_pos, legend_pos + legend_size);\n        legend.RectClamped = legend.Rect;\n        const bool legend_scrollable = ClampLegendRect(legend.RectClamped,subplot.FrameRect, gp.Style.PlotPadding);\n        const ImGuiButtonFlags legend_button_flags = ImGuiButtonFlags_AllowOverlap\n                                                    | ImGuiButtonFlags_PressedOnClick\n                                                    | ImGuiButtonFlags_PressedOnDoubleClick\n                                                    | ImGuiButtonFlags_MouseButtonLeft\n                                                    | ImGuiButtonFlags_MouseButtonRight\n                                                    | ImGuiButtonFlags_MouseButtonMiddle\n                                                    | ImGuiButtonFlags_FlattenChildren;\n        ImGui::KeepAliveID(subplot.Items.ID);\n        ImGui::ButtonBehavior(legend.RectClamped, subplot.Items.ID, &legend.Hovered, &legend.Held, legend_button_flags);\n        legend.Hovered = legend.Hovered || (subplot.FrameHovered && legend.RectClamped.Contains(ImGui::GetIO().MousePos));\n\n        if (legend_scrollable) {\n            if (legend.Hovered) {\n                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, subplot.Items.ID);\n                if (IO.MouseWheel != 0.0f) {\n                    ImVec2 max_step = legend.Rect.GetSize() * 0.67f;\n                    float font_size = ImGui::GetCurrentWindow()->CalcFontSize();\n                    float scroll_step = ImFloor(ImMin(2 * font_size, max_step.x));\n                    legend.Scroll.x += scroll_step * IO.MouseWheel;\n                    legend.Scroll.y += scroll_step * IO.MouseWheel;\n                }\n            }\n            const ImVec2 min_scroll_offset = legend.RectClamped.GetSize() - legend.Rect.GetSize();\n            legend.Scroll.x = ImClamp(legend.Scroll.x, min_scroll_offset.x, 0.0f);\n            legend.Scroll.y = ImClamp(legend.Scroll.y, min_scroll_offset.y, 0.0f);\n            const ImVec2 scroll_offset = legend_horz ? ImVec2(legend.Scroll.x, 0) : ImVec2(0, legend.Scroll.y);\n            ImVec2 legend_offset = legend.RectClamped.Min - legend.Rect.Min + scroll_offset;\n            legend.Rect.Min += legend_offset;\n            legend.Rect.Max += legend_offset;\n        } else {\n            legend.Scroll = ImVec2(0,0);\n        }\n\n        const ImU32 col_bg = GetStyleColorU32(ImPlotCol_LegendBg);\n        const ImU32 col_bd = GetStyleColorU32(ImPlotCol_LegendBorder);\n        ImGui::PushClipRect(legend.RectClamped.Min, legend.RectClamped.Max, true);\n        DrawList.AddRectFilled(legend.RectClamped.Min, legend.RectClamped.Max, col_bg);\n        bool legend_contextable = ShowLegendEntries(subplot.Items, legend.Rect, legend.Hovered, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz, DrawList)\n                                && !ImHasFlag(legend.Flags, ImPlotLegendFlags_NoMenus);\n        DrawList.AddRect(legend.RectClamped.Min, legend.RectClamped.Max, col_bd);\n        ImGui::PopClipRect();\n\n        if (legend_contextable && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoMenus) && ImGui::GetIO().MouseReleased[gp.InputMap.Menu])\n            ImGui::OpenPopup(\"##LegendContext\");\n        if (ImGui::BeginPopup(\"##LegendContext\")) {\n            ImGui::Text(\"Legend\"); ImGui::Separator();\n            if (ShowLegendContextMenu(legend, !ImHasFlag(subplot.Flags, ImPlotFlags_NoLegend)))\n                ImFlipFlag(subplot.Flags, ImPlotFlags_NoLegend);\n            ImGui::EndPopup();\n        }\n    }\n    else {\n        subplot.Items.Legend.Rect = ImRect();\n    }\n    // remove items\n    if (gp.CurrentItems == &subplot.Items)\n        gp.CurrentItems = nullptr;\n    // reset the plot items for the next frame (TODO: put this elswhere)\n    for (int i = 0; i < subplot.Items.GetItemCount(); ++i) {\n        subplot.Items.GetItemByIndex(i)->SeenThisFrame = false;\n    }\n    // pop id\n    ImGui::PopID();\n    // set DC back correctly\n    GImGui->CurrentWindow->DC.CursorPos = subplot.FrameRect.Min;\n    ImGui::Dummy(subplot.FrameRect.GetSize());\n    ResetCtxForNextSubplot(GImPlot);\n\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Utils\n//-----------------------------------------------------------------------------\n\nvoid SetAxis(ImAxis axis) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"SetAxis() needs to be called between BeginPlot() and EndPlot()!\");\n    IM_ASSERT_USER_ERROR(axis >= ImAxis_X1 && axis < ImAxis_COUNT, \"Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[axis].Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    SetupLock();\n    if (axis < ImAxis_Y1)\n        gp.CurrentPlot->CurrentX = axis;\n    else\n        gp.CurrentPlot->CurrentY = axis;\n}\n\nvoid SetAxes(ImAxis x_idx, ImAxis y_idx) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"SetAxes() needs to be called between BeginPlot() and EndPlot()!\");\n    IM_ASSERT_USER_ERROR(x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1, \"X-Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT, \"Y-Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[x_idx].Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[y_idx].Enabled, \"Axis is not enabled! Did you forget to call SetupAxis()?\");\n    SetupLock();\n    gp.CurrentPlot->CurrentX = x_idx;\n    gp.CurrentPlot->CurrentY = y_idx;\n}\n\nImPlotPoint PixelsToPlot(float x, float y, ImAxis x_idx, ImAxis y_idx) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"PixelsToPlot() needs to be called between BeginPlot() and EndPlot()!\");\n    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    \"X-Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), \"Y-Axis index out of bounds!\");\n    SetupLock();\n    ImPlotPlot& plot   = *gp.CurrentPlot;\n    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];\n    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];\n    return ImPlotPoint( x_axis.PixelsToPlot(x), y_axis.PixelsToPlot(y) );\n}\n\nImPlotPoint PixelsToPlot(const ImVec2& pix, ImAxis x_idx, ImAxis y_idx) {\n    return PixelsToPlot(pix.x, pix.y, x_idx, y_idx);\n}\n\nImVec2 PlotToPixels(double x, double y, ImAxis x_idx, ImAxis y_idx) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"PlotToPixels() needs to be called between BeginPlot() and EndPlot()!\");\n    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    \"X-Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), \"Y-Axis index out of bounds!\");\n    SetupLock();\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];\n    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];\n    return ImVec2( x_axis.PlotToPixels(x), y_axis.PlotToPixels(y) );\n}\n\nImVec2 PlotToPixels(const ImPlotPoint& plt, ImAxis x_idx, ImAxis y_idx) {\n    return PlotToPixels(plt.x, plt.y, x_idx, y_idx);\n}\n\nImVec2 GetPlotPos() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"GetPlotPos() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return gp.CurrentPlot->PlotRect.Min;\n}\n\nImVec2 GetPlotSize() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"GetPlotSize() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return gp.CurrentPlot->PlotRect.GetSize();\n}\n\nImPlotPoint GetPlotMousePos(ImAxis x_idx, ImAxis y_idx) {\n    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, \"GetPlotMousePos() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return PixelsToPlot(ImGui::GetMousePos(), x_idx, y_idx);\n}\n\nImPlotRect GetPlotLimits(ImAxis x_idx, ImAxis y_idx) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"GetPlotLimits() needs to be called between BeginPlot() and EndPlot()!\");\n    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    \"X-Axis index out of bounds!\");\n    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), \"Y-Axis index out of bounds!\");\n    SetupLock();\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];\n    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];\n    ImPlotRect limits;\n    limits.X = x_axis.Range;\n    limits.Y = y_axis.Range;\n    return limits;\n}\n\nbool IsPlotHovered() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"IsPlotHovered() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return gp.CurrentPlot->Hovered;\n}\n\nbool IsAxisHovered(ImAxis axis) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"IsPlotXAxisHovered() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return gp.CurrentPlot->Axes[axis].Hovered;\n}\n\nbool IsSubplotsHovered() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentSubplot != nullptr, \"IsSubplotsHovered() needs to be called between BeginSubplots() and EndSubplots()!\");\n    return gp.CurrentSubplot->FrameHovered;\n}\n\nbool IsPlotSelected() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"IsPlotSelected() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    return gp.CurrentPlot->Selected;\n}\n\nImPlotRect GetPlotSelection(ImAxis x_idx, ImAxis y_idx) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"GetPlotSelection() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    if (!plot.Selected)\n        return ImPlotRect(0,0,0,0);\n    ImPlotPoint p1 = PixelsToPlot(plot.SelectRect.Min + plot.PlotRect.Min, x_idx, y_idx);\n    ImPlotPoint p2 = PixelsToPlot(plot.SelectRect.Max + plot.PlotRect.Min, x_idx, y_idx);\n    ImPlotRect result;\n    result.X.Min = ImMin(p1.x, p2.x);\n    result.X.Max = ImMax(p1.x, p2.x);\n    result.Y.Min = ImMin(p1.y, p2.y);\n    result.Y.Max = ImMax(p1.y, p2.y);\n    return result;\n}\n\nvoid CancelPlotSelection() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"CancelPlotSelection() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    ImPlotPlot& plot = *gp.CurrentPlot;\n    if (plot.Selected)\n        plot.Selected = plot.Selecting = false;\n}\n\nvoid HideNextItem(bool hidden, ImPlotCond cond) {\n    ImPlotContext& gp = *GImPlot;\n    gp.NextItemData.HasHidden  = true;\n    gp.NextItemData.Hidden     = hidden;\n    gp.NextItemData.HiddenCond = cond;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Tools\n//-----------------------------------------------------------------------------\n\nvoid Annotation(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, bool round) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"Annotation() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    char x_buff[IMPLOT_LABEL_MAX_SIZE];\n    char y_buff[IMPLOT_LABEL_MAX_SIZE];\n    ImPlotAxis& x_axis = gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentX];\n    ImPlotAxis& y_axis = gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentY];\n    LabelAxisValue(x_axis, x, x_buff, sizeof(x_buff), round);\n    LabelAxisValue(y_axis, y, y_buff, sizeof(y_buff), round);\n    Annotation(x,y,col,offset,clamp,\"%s, %s\",x_buff,y_buff);\n}\n\nvoid AnnotationV(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, const char* fmt, va_list args) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"Annotation() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    ImVec2 pos = PlotToPixels(x,y,IMPLOT_AUTO,IMPLOT_AUTO);\n    ImU32  bg  = ImGui::GetColorU32(col);\n    ImU32  fg  = col.w == 0 ? GetStyleColorU32(ImPlotCol_InlayText) : CalcTextColor(col);\n    gp.Annotations.AppendV(pos, offset, bg, fg, clamp, fmt, args);\n}\n\nvoid Annotation(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    AnnotationV(x,y,col,offset,clamp,fmt,args);\n    va_end(args);\n}\n\nvoid TagV(ImAxis axis, double v, const ImVec4& col, const char* fmt, va_list args) {\n    ImPlotContext& gp = *GImPlot;\n    SetupLock();\n    ImU32 bg = ImGui::GetColorU32(col);\n    ImU32 fg = col.w == 0 ? GetStyleColorU32(ImPlotCol_AxisText) : CalcTextColor(col);\n    gp.Tags.AppendV(axis,v,bg,fg,fmt,args);\n}\n\nvoid Tag(ImAxis axis, double v, const ImVec4& col, const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    TagV(axis,v,col,fmt,args);\n    va_end(args);\n}\n\nvoid Tag(ImAxis axis, double v, const ImVec4& color, bool round) {\n    ImPlotContext& gp = *GImPlot;\n    SetupLock();\n    char buff[IMPLOT_LABEL_MAX_SIZE];\n    ImPlotAxis& ax = gp.CurrentPlot->Axes[axis];\n    LabelAxisValue(ax, v, buff, sizeof(buff), round);\n    Tag(axis,v,color,\"%s\",buff);\n}\n\nIMPLOT_API void TagX(double x, const ImVec4& color, bool round) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagX() needs to be called between BeginPlot() and EndPlot()!\");\n    Tag(gp.CurrentPlot->CurrentX, x, color, round);\n}\n\nIMPLOT_API void TagX(double x, const ImVec4& color, const char* fmt, ...) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagX() needs to be called between BeginPlot() and EndPlot()!\");\n    va_list args;\n    va_start(args, fmt);\n    TagV(gp.CurrentPlot->CurrentX,x,color,fmt,args);\n    va_end(args);\n}\n\nIMPLOT_API void TagXV(double x, const ImVec4& color, const char* fmt, va_list args) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagX() needs to be called between BeginPlot() and EndPlot()!\");\n    TagV(gp.CurrentPlot->CurrentX, x, color, fmt, args);\n}\n\nIMPLOT_API void TagY(double y, const ImVec4& color, bool round) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagY() needs to be called between BeginPlot() and EndPlot()!\");\n    Tag(gp.CurrentPlot->CurrentY, y, color, round);\n}\n\nIMPLOT_API void TagY(double y, const ImVec4& color, const char* fmt, ...) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagY() needs to be called between BeginPlot() and EndPlot()!\");\n    va_list args;\n    va_start(args, fmt);\n    TagV(gp.CurrentPlot->CurrentY,y,color,fmt,args);\n    va_end(args);\n}\n\nIMPLOT_API void TagYV(double y, const ImVec4& color, const char* fmt, va_list args) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"TagY() needs to be called between BeginPlot() and EndPlot()!\");\n    TagV(gp.CurrentPlot->CurrentY, y, color, fmt, args);\n}\n\nstatic const float DRAG_GRAB_HALF_SIZE = 4.0f;\n\nbool DragPoint(int n_id, double* x, double* y, const ImVec4& col, float radius, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {\n    ImGui::PushID(\"#IMPLOT_DRAG_POINT\");\n    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, \"DragPoint() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n\n    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {\n        FitPoint(ImPlotPoint(*x,*y));\n    }\n\n    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);\n    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);\n    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);\n    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, radius);\n    const ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;\n    const ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);\n\n    ImVec2 pos = PlotToPixels(*x,*y,IMPLOT_AUTO,IMPLOT_AUTO);\n    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);\n    ImRect rect(pos.x-grab_half_size,pos.y-grab_half_size,pos.x+grab_half_size,pos.y+grab_half_size);\n    bool hovered = false, held = false;\n\n    ImGui::KeepAliveID(id);\n    if (input) {\n        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);\n        if (out_clicked) *out_clicked = clicked;\n        if (out_hovered) *out_hovered = hovered;\n        if (out_held)    *out_held    = held;\n    }\n\n    bool modified = false;\n    if (held && ImGui::IsMouseDragging(0)) {\n        *x = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;\n        *y = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;\n        modified = true;\n    }\n\n    PushPlotClipRect();\n    ImDrawList& DrawList = *GetPlotDrawList();\n    if ((hovered || held) && show_curs)\n        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);\n    if (modified && no_delay)\n        pos = PlotToPixels(*x,*y,IMPLOT_AUTO,IMPLOT_AUTO);\n    DrawList.AddCircleFilled(pos, radius, col32);\n    PopPlotClipRect();\n\n    ImGui::PopID();\n    return modified;\n}\n\nbool DragLineX(int n_id, double* value, const ImVec4& col, float thickness, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {\n    // ImGui::PushID(\"#IMPLOT_DRAG_LINE_X\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"DragLineX() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n\n    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {\n        FitPointX(*value);\n    }\n\n    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);\n    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);\n    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);\n    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, thickness/2);\n    float yt = gp.CurrentPlot->PlotRect.Min.y;\n    float yb = gp.CurrentPlot->PlotRect.Max.y;\n    float x  = IM_ROUND(PlotToPixels(*value,0,IMPLOT_AUTO,IMPLOT_AUTO).x);\n    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);\n    ImRect rect(x-grab_half_size,yt,x+grab_half_size,yb);\n    bool hovered = false, held = false;\n\n    ImGui::KeepAliveID(id);\n    if (input) {\n        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);\n        if (out_clicked) *out_clicked = clicked;\n        if (out_hovered) *out_hovered = hovered;\n        if (out_held)    *out_held    = held;\n    }\n\n    if ((hovered || held) && show_curs)\n        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);\n\n    float len = gp.Style.MajorTickLen.x;\n    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;\n    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);\n\n    bool modified = false;\n    if (held && ImGui::IsMouseDragging(0)) {\n        *value = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;\n        modified = true;\n    }\n\n    PushPlotClipRect();\n    ImDrawList& DrawList = *GetPlotDrawList();\n    if (modified && no_delay)\n        x  = IM_ROUND(PlotToPixels(*value,0,IMPLOT_AUTO,IMPLOT_AUTO).x);\n    DrawList.AddLine(ImVec2(x,yt), ImVec2(x,yb),     col32,   thickness);\n    DrawList.AddLine(ImVec2(x,yt), ImVec2(x,yt+len), col32, 3*thickness);\n    DrawList.AddLine(ImVec2(x,yb), ImVec2(x,yb-len), col32, 3*thickness);\n    PopPlotClipRect();\n\n    // ImGui::PopID();\n    return modified;\n}\n\nbool DragLineY(int n_id, double* value, const ImVec4& col, float thickness, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {\n    ImGui::PushID(\"#IMPLOT_DRAG_LINE_Y\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"DragLineY() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n\n    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {\n        FitPointY(*value);\n    }\n\n    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);\n    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);\n    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);\n    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, thickness/2);\n    float xl = gp.CurrentPlot->PlotRect.Min.x;\n    float xr = gp.CurrentPlot->PlotRect.Max.x;\n    float y  = IM_ROUND(PlotToPixels(0, *value,IMPLOT_AUTO,IMPLOT_AUTO).y);\n\n    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);\n    ImRect rect(xl,y-grab_half_size,xr,y+grab_half_size);\n    bool hovered = false, held = false;\n\n    ImGui::KeepAliveID(id);\n    if (input) {\n        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);\n        if (out_clicked) *out_clicked = clicked;\n        if (out_hovered) *out_hovered = hovered;\n        if (out_held)    *out_held    = held;\n    }\n\n    if ((hovered || held) && show_curs)\n        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);\n\n    float len = gp.Style.MajorTickLen.y;\n    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;\n    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);\n\n    bool modified = false;\n    if (held && ImGui::IsMouseDragging(0)) {\n        *value = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;\n        modified = true;\n    }\n\n    PushPlotClipRect();\n    ImDrawList& DrawList = *GetPlotDrawList();\n    if (modified && no_delay)\n        y  = IM_ROUND(PlotToPixels(0, *value,IMPLOT_AUTO,IMPLOT_AUTO).y);\n    DrawList.AddLine(ImVec2(xl,y), ImVec2(xr,y),     col32,   thickness);\n    DrawList.AddLine(ImVec2(xl,y), ImVec2(xl+len,y), col32, 3*thickness);\n    DrawList.AddLine(ImVec2(xr,y), ImVec2(xr-len,y), col32, 3*thickness);\n    PopPlotClipRect();\n\n    ImGui::PopID();\n    return modified;\n}\n\nbool DragRect(int n_id, double* x_min, double* y_min, double* x_max, double* y_max, const ImVec4& col, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {\n    ImGui::PushID(\"#IMPLOT_DRAG_RECT\");\n    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, \"DragRect() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n\n    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {\n        FitPoint(ImPlotPoint(*x_min,*y_min));\n        FitPoint(ImPlotPoint(*x_max,*y_max));\n    }\n\n    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);\n    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);\n    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);\n    bool    h[] = {true,false,true,false};\n    double* x[] = {x_min,x_max,x_max,x_min};\n    double* y[] = {y_min,y_min,y_max,y_max};\n    ImVec2 p[4];\n    for (int i = 0; i < 4; ++i)\n        p[i] = PlotToPixels(*x[i],*y[i],IMPLOT_AUTO,IMPLOT_AUTO);\n    ImVec2 pc = PlotToPixels((*x_min+*x_max)/2,(*y_min+*y_max)/2,IMPLOT_AUTO,IMPLOT_AUTO);\n    ImRect rect(ImMin(p[0],p[2]),ImMax(p[0],p[2]));\n    ImRect rect_grab = rect; rect_grab.Expand(DRAG_GRAB_HALF_SIZE);\n\n    ImGuiMouseCursor cur[4];\n    if (show_curs) {\n        cur[0] = (rect.Min.x == p[0].x && rect.Min.y == p[0].y) || (rect.Max.x == p[0].x && rect.Max.y == p[0].y) ? ImGuiMouseCursor_ResizeNWSE : ImGuiMouseCursor_ResizeNESW;\n        cur[1] = cur[0] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;\n        cur[2] = cur[1] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;\n        cur[3] = cur[2] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;\n    }\n\n    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;\n    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);\n    color.w *= 0.25f;\n    ImU32 col32_a = ImGui::ColorConvertFloat4ToU32(color);\n    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);\n\n    bool modified = false;\n    bool clicked = false, hovered = false, held = false;\n    ImRect b_rect(pc.x-DRAG_GRAB_HALF_SIZE,pc.y-DRAG_GRAB_HALF_SIZE,pc.x+DRAG_GRAB_HALF_SIZE,pc.y+DRAG_GRAB_HALF_SIZE);\n\n    ImGui::KeepAliveID(id);\n    if (input) {\n        // middle point\n        clicked = ImGui::ButtonBehavior(b_rect,id,&hovered,&held);\n        if (out_clicked) *out_clicked = clicked;\n        if (out_hovered) *out_hovered = hovered;\n        if (out_held)    *out_held    = held;\n    }\n\n    if ((hovered || held) && show_curs)\n        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);\n    if (held && ImGui::IsMouseDragging(0)) {\n        for (int i = 0; i < 4; ++i) {\n            ImPlotPoint pp = PixelsToPlot(p[i] + ImGui::GetIO().MouseDelta,IMPLOT_AUTO,IMPLOT_AUTO);\n            *y[i] = pp.y;\n            *x[i] = pp.x;\n        }\n        modified = true;\n    }\n\n    for (int i = 0; i < 4; ++i) {\n        // points\n        b_rect = ImRect(p[i].x-DRAG_GRAB_HALF_SIZE,p[i].y-DRAG_GRAB_HALF_SIZE,p[i].x+DRAG_GRAB_HALF_SIZE,p[i].y+DRAG_GRAB_HALF_SIZE);\n        ImGuiID p_id = id + i + 1;\n        ImGui::KeepAliveID(p_id);\n        if (input) {\n            clicked = ImGui::ButtonBehavior(b_rect,p_id,&hovered,&held);\n            if (out_clicked) *out_clicked = *out_clicked || clicked;\n            if (out_hovered) *out_hovered = *out_hovered || hovered;\n            if (out_held)    *out_held    = *out_held    || held;\n        }\n        if ((hovered || held) && show_curs)\n            ImGui::SetMouseCursor(cur[i]);\n\n        if (held && ImGui::IsMouseDragging(0)) {\n            *x[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;\n            *y[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;\n            modified = true;\n        }\n\n        // edges\n        ImVec2 e_min = ImMin(p[i],p[(i+1)%4]);\n        ImVec2 e_max = ImMax(p[i],p[(i+1)%4]);\n        b_rect = h[i] ? ImRect(e_min.x + DRAG_GRAB_HALF_SIZE, e_min.y - DRAG_GRAB_HALF_SIZE, e_max.x - DRAG_GRAB_HALF_SIZE, e_max.y + DRAG_GRAB_HALF_SIZE)\n                    : ImRect(e_min.x - DRAG_GRAB_HALF_SIZE, e_min.y + DRAG_GRAB_HALF_SIZE, e_max.x + DRAG_GRAB_HALF_SIZE, e_max.y - DRAG_GRAB_HALF_SIZE);\n        ImGuiID e_id = id + i + 5;\n        ImGui::KeepAliveID(e_id);\n        if (input) {\n            clicked = ImGui::ButtonBehavior(b_rect,e_id,&hovered,&held);\n            if (out_clicked) *out_clicked = *out_clicked || clicked;\n            if (out_hovered) *out_hovered = *out_hovered || hovered;\n            if (out_held)    *out_held    = *out_held    || held;\n        }\n        if ((hovered || held) && show_curs)\n            h[i] ? ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);\n        if (held && ImGui::IsMouseDragging(0)) {\n            if (h[i])\n                *y[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;\n            else\n                *x[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;\n            modified = true;\n        }\n        if (hovered && ImGui::IsMouseDoubleClicked(0))\n        {\n            ImPlotRect b = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO);\n            if (h[i])\n                *y[i] = ((y[i] == y_min && *y_min < *y_max) || (y[i] == y_max && *y_max < *y_min)) ? b.Y.Min : b.Y.Max;\n            else\n                *x[i] = ((x[i] == x_min && *x_min < *x_max) || (x[i] == x_max && *x_max < *x_min)) ? b.X.Min : b.X.Max;\n            modified = true;\n        }\n    }\n\n    const bool mouse_inside = rect_grab.Contains(ImGui::GetMousePos());\n    const bool mouse_clicked = ImGui::IsMouseClicked(0);\n    const bool mouse_down = ImGui::IsMouseDown(0);\n    if (input && mouse_inside) {\n        if (out_clicked) *out_clicked = *out_clicked || mouse_clicked;\n        if (out_hovered) *out_hovered = true;\n        if (out_held)    *out_held    = *out_held    || mouse_down;\n    }\n\n    PushPlotClipRect();\n    ImDrawList& DrawList = *GetPlotDrawList();\n    if (modified && no_delay) {\n        for (int i = 0; i < 4; ++i)\n            p[i] = PlotToPixels(*x[i],*y[i],IMPLOT_AUTO,IMPLOT_AUTO);\n        pc = PlotToPixels((*x_min+*x_max)/2,(*y_min+*y_max)/2,IMPLOT_AUTO,IMPLOT_AUTO);\n        rect = ImRect(ImMin(p[0],p[2]),ImMax(p[0],p[2]));\n    }\n    DrawList.AddRectFilled(rect.Min, rect.Max, col32_a);\n    DrawList.AddRect(rect.Min, rect.Max, col32);\n    if (input && (modified || mouse_inside)) {\n        DrawList.AddCircleFilled(pc,DRAG_GRAB_HALF_SIZE,col32);\n        for (int i = 0; i < 4; ++i)\n            DrawList.AddCircleFilled(p[i],DRAG_GRAB_HALF_SIZE,col32);\n    }\n    PopPlotClipRect();\n    ImGui::PopID();\n    return modified;\n}\n\nbool DragRect(int id, ImPlotRect* bounds, const ImVec4& col, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {\n    return DragRect(id, &bounds->X.Min, &bounds->Y.Min,&bounds->X.Max, &bounds->Y.Max, col, flags, out_clicked, out_hovered, out_held);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Legend Utils and Tools\n//-----------------------------------------------------------------------------\n\nbool IsLegendEntryHovered(const char* label_id) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, \"IsPlotItemHighlight() needs to be called within an itemized context!\");\n    SetupLock();\n    ImGuiID id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);\n    ImPlotItem* item = gp.CurrentItems->GetItem(id);\n    return item && item->LegendHovered;\n}\n\nbool BeginLegendPopup(const char* label_id, ImGuiMouseButton mouse_button) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, \"BeginLegendPopup() needs to be called within an itemized context!\");\n    SetupLock();\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    if (window->SkipItems)\n        return false;\n    ImGuiID id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);\n    if (ImGui::IsMouseReleased(mouse_button)) {\n        ImPlotItem* item = gp.CurrentItems->GetItem(id);\n        if (item && item->LegendHovered)\n            ImGui::OpenPopupEx(id);\n    }\n    return ImGui::BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);\n}\n\nvoid EndLegendPopup() {\n    SetupLock();\n    ImGui::EndPopup();\n}\n\nvoid ShowAltLegend(const char* title_id, bool vertical, const ImVec2 size, bool interactable) {\n    ImPlotContext& gp    = *GImPlot;\n    ImGuiContext &G      = *GImGui;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return;\n    ImDrawList &DrawList = *Window->DrawList;\n    ImPlotPlot* plot = GetPlot(title_id);\n    ImVec2 legend_size;\n    ImVec2 default_size = gp.Style.LegendPadding * 2;\n    if (plot != nullptr) {\n        legend_size  = CalcLegendSize(plot->Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, vertical);\n        default_size = legend_size + gp.Style.LegendPadding * 2;\n    }\n    ImVec2 frame_size = ImGui::CalcItemSize(size, default_size.x, default_size.y);\n    ImRect bb_frame = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);\n    ImGui::ItemSize(bb_frame);\n    if (!ImGui::ItemAdd(bb_frame, 0, &bb_frame))\n        return;\n    ImGui::RenderFrame(bb_frame.Min, bb_frame.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, G.Style.FrameRounding);\n    DrawList.PushClipRect(bb_frame.Min, bb_frame.Max, true);\n    if (plot != nullptr) {\n        const ImVec2 legend_pos  = GetLocationPos(bb_frame, legend_size, 0, gp.Style.LegendPadding);\n        const ImRect legend_bb(legend_pos, legend_pos + legend_size);\n        interactable = interactable && bb_frame.Contains(ImGui::GetIO().MousePos);\n        // render legend box\n        ImU32  col_bg      = GetStyleColorU32(ImPlotCol_LegendBg);\n        ImU32  col_bd      = GetStyleColorU32(ImPlotCol_LegendBorder);\n        DrawList.AddRectFilled(legend_bb.Min, legend_bb.Max, col_bg);\n        DrawList.AddRect(legend_bb.Min, legend_bb.Max, col_bd);\n        // render entries\n        ShowLegendEntries(plot->Items, legend_bb, interactable, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, vertical, DrawList);\n    }\n    DrawList.PopClipRect();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Drag and Drop Utils\n//-----------------------------------------------------------------------------\n\nbool BeginDragDropTargetPlot() {\n    SetupLock();\n    ImPlotContext& gp = *GImPlot;\n    ImRect rect = gp.CurrentPlot->PlotRect;\n    return ImGui::BeginDragDropTargetCustom(rect, gp.CurrentPlot->ID);\n}\n\nbool BeginDragDropTargetAxis(ImAxis axis) {\n    SetupLock();\n    ImPlotPlot& plot = *GImPlot->CurrentPlot;\n    ImPlotAxis& ax = plot.Axes[axis];\n    ImRect rect = ax.HoverRect;\n    rect.Expand(-3.5f);\n    return ImGui::BeginDragDropTargetCustom(rect, ax.ID);\n}\n\nbool BeginDragDropTargetLegend() {\n    SetupLock();\n    ImPlotItemGroup& items = *GImPlot->CurrentItems;\n    ImRect rect = items.Legend.RectClamped;\n    return ImGui::BeginDragDropTargetCustom(rect, items.ID);\n}\n\nvoid EndDragDropTarget() {\n    SetupLock();\n\tImGui::EndDragDropTarget();\n}\n\nbool BeginDragDropSourcePlot(ImGuiDragDropFlags flags) {\n    SetupLock();\n    ImPlotContext& gp = *GImPlot;\n    ImPlotPlot* plot = gp.CurrentPlot;\n    if (GImGui->IO.KeyMods == gp.InputMap.OverrideMod || GImGui->DragDropPayload.SourceId == plot->ID)\n        return ImGui::ItemAdd(plot->PlotRect, plot->ID) && ImGui::BeginDragDropSource(flags);\n    return false;\n}\n\nbool BeginDragDropSourceAxis(ImAxis idx, ImGuiDragDropFlags flags) {\n    SetupLock();\n    ImPlotContext& gp = *GImPlot;\n    ImPlotAxis& axis = gp.CurrentPlot->Axes[idx];\n    if (GImGui->IO.KeyMods == gp.InputMap.OverrideMod || GImGui->DragDropPayload.SourceId == axis.ID)\n        return ImGui::ItemAdd(axis.HoverRect, axis.ID) && ImGui::BeginDragDropSource(flags);\n    return false;\n}\n\nbool BeginDragDropSourceItem(const char* label_id, ImGuiDragDropFlags flags) {\n    SetupLock();\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, \"BeginDragDropSourceItem() needs to be called within an itemized context!\");\n    ImGuiID item_id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);\n    ImPlotItem* item = gp.CurrentItems->GetItem(item_id);\n    if (item != nullptr) {\n        return ImGui::ItemAdd(item->LegendHoverRect, item->ID) && ImGui::BeginDragDropSource(flags);\n    }\n    return false;\n}\n\nvoid EndDragDropSource() {\n    SetupLock();\n    ImGui::EndDragDropSource();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Aligned Plots\n//-----------------------------------------------------------------------------\n\nbool BeginAlignedPlots(const char* group_id, bool vertical) {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentAlignmentH == nullptr && gp.CurrentAlignmentV == nullptr, \"Mismatched BeginAlignedPlots()/EndAlignedPlots()!\");\n    ImGuiContext &G = *GImGui;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return false;\n    const ImGuiID ID = Window->GetID(group_id);\n    ImPlotAlignmentData* alignment = gp.AlignmentData.GetOrAddByKey(ID);\n    if (vertical)\n        gp.CurrentAlignmentV = alignment;\n    else\n        gp.CurrentAlignmentH = alignment;\n    if (alignment->Vertical != vertical)\n        alignment->Reset();\n    alignment->Vertical = vertical;\n    alignment->Begin();\n    return true;\n}\n\nvoid EndAlignedPlots() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentAlignmentH != nullptr || gp.CurrentAlignmentV != nullptr, \"Mismatched BeginAlignedPlots()/EndAlignedPlots()!\");\n    ImPlotAlignmentData* alignment = gp.CurrentAlignmentH != nullptr ? gp.CurrentAlignmentH : (gp.CurrentAlignmentV != nullptr ? gp.CurrentAlignmentV : nullptr);\n    if (alignment)\n        alignment->End();\n    ResetCtxForNextAlignedPlots(GImPlot);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot and Item Styling\n//-----------------------------------------------------------------------------\n\nImPlotStyle& GetStyle() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    return gp.Style;\n}\n\nvoid PushStyleColor(ImPlotCol idx, ImU32 col) {\n    ImPlotContext& gp = *GImPlot;\n    ImGuiColorMod backup;\n    backup.Col = (ImGuiCol)idx;\n    backup.BackupValue = gp.Style.Colors[idx];\n    gp.ColorModifiers.push_back(backup);\n    gp.Style.Colors[idx] = ImGui::ColorConvertU32ToFloat4(col);\n}\n\nvoid PushStyleColor(ImPlotCol idx, const ImVec4& col) {\n    ImPlotContext& gp = *GImPlot;\n    ImGuiColorMod backup;\n    backup.Col = (ImGuiCol)idx;\n    backup.BackupValue = gp.Style.Colors[idx];\n    gp.ColorModifiers.push_back(backup);\n    gp.Style.Colors[idx] = col;\n}\n\nvoid PopStyleColor(int count) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(count <= gp.ColorModifiers.Size, \"You can't pop more modifiers than have been pushed!\");\n    while (count > 0)\n    {\n        ImGuiColorMod& backup = gp.ColorModifiers.back();\n        gp.Style.Colors[backup.Col] = backup.BackupValue;\n        gp.ColorModifiers.pop_back();\n        count--;\n    }\n}\n\nvoid PushStyleVar(ImPlotStyleVar idx, float val) {\n    ImPlotContext& gp = *GImPlot;\n    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1) {\n        float* pvar = (float*)var_info->GetVarPtr(&gp.Style);\n        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));\n        *pvar = val;\n        return;\n    }\n    IM_ASSERT(0 && \"Called PushStyleVar() float variant but variable is not a float!\");\n}\n\nvoid PushStyleVar(ImPlotStyleVar idx, int val) {\n    ImPlotContext& gp = *GImPlot;\n    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);\n    if (var_info->Type == ImGuiDataType_S32 && var_info->Count == 1) {\n        int* pvar = (int*)var_info->GetVarPtr(&gp.Style);\n        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));\n        *pvar = val;\n        return;\n    }\n    else if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1) {\n        float* pvar = (float*)var_info->GetVarPtr(&gp.Style);\n        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));\n        *pvar = (float)val;\n        return;\n    }\n    IM_ASSERT(0 && \"Called PushStyleVar() int variant but variable is not a int!\");\n}\n\nvoid PushStyleVar(ImPlotStyleVar idx, const ImVec2& val)\n{\n    ImPlotContext& gp = *GImPlot;\n    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)\n    {\n        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&gp.Style);\n        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));\n        *pvar = val;\n        return;\n    }\n    IM_ASSERT(0 && \"Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!\");\n}\n\nvoid PopStyleVar(int count) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(count <= gp.StyleModifiers.Size, \"You can't pop more modifiers than have been pushed!\");\n    while (count > 0) {\n        ImGuiStyleMod& backup = gp.StyleModifiers.back();\n        const ImPlotStyleVarInfo* info = GetPlotStyleVarInfo(backup.VarIdx);\n        void* data = info->GetVarPtr(&gp.Style);\n        if (info->Type == ImGuiDataType_Float && info->Count == 1) {\n            ((float*)data)[0] = backup.BackupFloat[0];\n        }\n        else if (info->Type == ImGuiDataType_Float && info->Count == 2) {\n             ((float*)data)[0] = backup.BackupFloat[0];\n             ((float*)data)[1] = backup.BackupFloat[1];\n        }\n        else if (info->Type == ImGuiDataType_S32 && info->Count == 1) {\n            ((int*)data)[0] = backup.BackupInt[0];\n        }\n        gp.StyleModifiers.pop_back();\n        count--;\n    }\n}\n\n//------------------------------------------------------------------------------\n// [Section] Colormaps\n//------------------------------------------------------------------------------\n\nImPlotColormap AddColormap(const char* name, const ImVec4* colormap, int size, bool qual) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(size > 1, \"The colormap size must be greater than 1!\");\n    IM_ASSERT_USER_ERROR(gp.ColormapData.GetIndex(name) == -1, \"The colormap name has already been used!\");\n    ImVector<ImU32> buffer;\n    buffer.resize(size);\n    for (int i = 0; i < size; ++i)\n        buffer[i] = ImGui::ColorConvertFloat4ToU32(colormap[i]);\n    return gp.ColormapData.Append(name, buffer.Data, size, qual);\n}\n\nImPlotColormap AddColormap(const char* name, const ImU32*  colormap, int size, bool qual) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(size > 1, \"The colormap size must be greater than 1!\");\n    IM_ASSERT_USER_ERROR(gp.ColormapData.GetIndex(name) == -1, \"The colormap name has already be used!\");\n    return gp.ColormapData.Append(name, colormap, size, qual);\n}\n\nint GetColormapCount() {\n    ImPlotContext& gp = *GImPlot;\n    return gp.ColormapData.Count;\n}\n\nconst char* GetColormapName(ImPlotColormap colormap) {\n    ImPlotContext& gp = *GImPlot;\n    return gp.ColormapData.GetName(colormap);\n}\n\nImPlotColormap GetColormapIndex(const char* name) {\n    ImPlotContext& gp = *GImPlot;\n    return gp.ColormapData.GetIndex(name);\n}\n\nvoid PushColormap(ImPlotColormap colormap) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(colormap >= 0 && colormap < gp.ColormapData.Count, \"The colormap index is invalid!\");\n    gp.ColormapModifiers.push_back(gp.Style.Colormap);\n    gp.Style.Colormap = colormap;\n}\n\nvoid PushColormap(const char* name) {\n    ImPlotContext& gp = *GImPlot;\n    ImPlotColormap idx = gp.ColormapData.GetIndex(name);\n    IM_ASSERT_USER_ERROR(idx != -1, \"The colormap name is invalid!\");\n    PushColormap(idx);\n}\n\nvoid PopColormap(int count) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(count <= gp.ColormapModifiers.Size, \"You can't pop more modifiers than have been pushed!\");\n    while (count > 0) {\n        const ImPlotColormap& backup = gp.ColormapModifiers.back();\n        gp.Style.Colormap     = backup;\n        gp.ColormapModifiers.pop_back();\n        count--;\n    }\n}\n\nImU32 NextColormapColorU32() {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, \"NextColormapColor() needs to be called between BeginPlot() and EndPlot()!\");\n    int idx = gp.CurrentItems->ColormapIdx % gp.ColormapData.GetKeyCount(gp.Style.Colormap);\n    ImU32 col  = gp.ColormapData.GetKeyColor(gp.Style.Colormap, idx);\n    gp.CurrentItems->ColormapIdx++;\n    return col;\n}\n\nImVec4 NextColormapColor() {\n    return ImGui::ColorConvertU32ToFloat4(NextColormapColorU32());\n}\n\nint GetColormapSize(ImPlotColormap cmap) {\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n    return gp.ColormapData.GetKeyCount(cmap);\n}\n\nImU32 GetColormapColorU32(int idx, ImPlotColormap cmap) {\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n    idx = idx % gp.ColormapData.GetKeyCount(cmap);\n    return gp.ColormapData.GetKeyColor(cmap, idx);\n}\n\nImVec4 GetColormapColor(int idx, ImPlotColormap cmap) {\n    return ImGui::ColorConvertU32ToFloat4(GetColormapColorU32(idx,cmap));\n}\n\nImU32  SampleColormapU32(float t, ImPlotColormap cmap) {\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n    return gp.ColormapData.LerpTable(cmap, t);\n}\n\nImVec4 SampleColormap(float t, ImPlotColormap cmap) {\n    return ImGui::ColorConvertU32ToFloat4(SampleColormapU32(t,cmap));\n}\n\nvoid RenderColorBar(const ImU32* colors, int size, ImDrawList& DrawList, const ImRect& bounds, bool vert, bool reversed, bool continuous) {\n    const int n = continuous ? size - 1 : size;\n    ImU32 col1, col2;\n    if (vert) {\n        const float step = bounds.GetHeight() / n;\n        ImRect rect(bounds.Min.x, bounds.Min.y, bounds.Max.x, bounds.Min.y + step);\n        for (int i = 0; i < n; ++i) {\n            if (reversed) {\n                col1 = colors[size-i-1];\n                col2 = continuous ? colors[size-i-2] : col1;\n            }\n            else {\n                col1 = colors[i];\n                col2 = continuous ? colors[i+1] : col1;\n            }\n            DrawList.AddRectFilledMultiColor(rect.Min, rect.Max, col1, col1, col2, col2);\n            rect.TranslateY(step);\n        }\n    }\n    else {\n        const float step = bounds.GetWidth() / n;\n        ImRect rect(bounds.Min.x, bounds.Min.y, bounds.Min.x + step, bounds.Max.y);\n        for (int i = 0; i < n; ++i) {\n            if (reversed) {\n                col1 = colors[size-i-1];\n                col2 = continuous ? colors[size-i-2] : col1;\n            }\n            else {\n                col1 = colors[i];\n                col2 = continuous ? colors[i+1] : col1;\n            }\n            DrawList.AddRectFilledMultiColor(rect.Min, rect.Max, col1, col2, col2, col1);\n            rect.TranslateX(step);\n        }\n    }\n}\n\nvoid ColormapScale(const char* label, double scale_min, double scale_max, const ImVec2& size, const char* format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap) {\n    ImGuiContext &G      = *GImGui;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return;\n\n    const ImGuiID ID = Window->GetID(label);\n    ImVec2 label_size(0,0);\n    if (!ImHasFlag(flags, ImPlotColormapScaleFlags_NoLabel)) {\n        label_size = ImGui::CalcTextSize(label,nullptr,true);\n    }\n\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n\n    ImVec2 frame_size  = ImGui::CalcItemSize(size, 0, gp.Style.PlotDefaultSize.y);\n    if (frame_size.y < gp.Style.PlotMinSize.y && size.y < 0.0f)\n        frame_size.y = gp.Style.PlotMinSize.y;\n\n    ImPlotRange range(ImMin(scale_min,scale_max), ImMax(scale_min,scale_max));\n    gp.CTicker.Reset();\n    Locator_Default(gp.CTicker, range, frame_size.y, true, Formatter_Default, (void*)format);\n\n    const bool rend_label = label_size.x > 0;\n    const float txt_off   = gp.Style.LabelPadding.x;\n    const float pad       = txt_off + gp.CTicker.MaxSize.x + (rend_label ? txt_off + label_size.y : 0);\n    float bar_w           = 20;\n    if (frame_size.x == 0)\n        frame_size.x = bar_w + pad + 2 * gp.Style.PlotPadding.x;\n    else {\n        bar_w = frame_size.x - (pad + 2 * gp.Style.PlotPadding.x);\n        if (bar_w < gp.Style.MajorTickLen.y)\n            bar_w = gp.Style.MajorTickLen.y;\n    }\n\n    ImDrawList &DrawList = *Window->DrawList;\n    ImRect bb_frame = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);\n    ImGui::ItemSize(bb_frame);\n    if (!ImGui::ItemAdd(bb_frame, ID, &bb_frame))\n        return;\n\n    ImGui::RenderFrame(bb_frame.Min, bb_frame.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, G.Style.FrameRounding);\n\n    const bool opposite = ImHasFlag(flags, ImPlotColormapScaleFlags_Opposite);\n    const bool inverted = ImHasFlag(flags, ImPlotColormapScaleFlags_Invert);\n    const bool reversed = scale_min > scale_max;\n\n    float bb_grad_shift = opposite ? pad : 0;\n    ImRect bb_grad(bb_frame.Min + gp.Style.PlotPadding + ImVec2(bb_grad_shift, 0),\n                   bb_frame.Min + ImVec2(bar_w + gp.Style.PlotPadding.x + bb_grad_shift,\n                                         frame_size.y - gp.Style.PlotPadding.y));\n\n    ImGui::PushClipRect(bb_frame.Min, bb_frame.Max, true);\n    const ImU32 col_text = ImGui::GetColorU32(ImGuiCol_Text);\n\n    const bool invert_scale = inverted ? (reversed ? false : true) : (reversed ? true : false);\n    const float y_min = invert_scale ? bb_grad.Max.y : bb_grad.Min.y;\n    const float y_max = invert_scale ? bb_grad.Min.y : bb_grad.Max.y;\n\n    RenderColorBar(gp.ColormapData.GetKeys(cmap), gp.ColormapData.GetKeyCount(cmap), DrawList, bb_grad, true, !inverted, !gp.ColormapData.IsQual(cmap));\n    for (int i = 0; i < gp.CTicker.TickCount(); ++i) {\n        const double y_pos_plt = gp.CTicker.Ticks[i].PlotPos;\n        const float y_pos = ImRemap((float)y_pos_plt, (float)range.Max, (float)range.Min, y_min, y_max);\n        const float tick_width = gp.CTicker.Ticks[i].Major ? gp.Style.MajorTickLen.y : gp.Style.MinorTickLen.y;\n        const float tick_thick = gp.CTicker.Ticks[i].Major ? gp.Style.MajorTickSize.y : gp.Style.MinorTickSize.y;\n        const float tick_t     = (float)((y_pos_plt - scale_min) / (scale_max - scale_min));\n        const ImU32 tick_col = CalcTextColor(gp.ColormapData.LerpTable(cmap,tick_t));\n        if (y_pos < bb_grad.Max.y - 2 && y_pos > bb_grad.Min.y + 2) {\n            DrawList.AddLine(opposite ? ImVec2(bb_grad.Min.x+1, y_pos) : ImVec2(bb_grad.Max.x-1, y_pos),\n                             opposite ? ImVec2(bb_grad.Min.x + tick_width, y_pos) : ImVec2(bb_grad.Max.x - tick_width, y_pos),\n                             tick_col,\n                             tick_thick);\n        }\n        const float txt_x = opposite ? bb_grad.Min.x - txt_off - gp.CTicker.Ticks[i].LabelSize.x : bb_grad.Max.x + txt_off;\n        const float txt_y = y_pos - gp.CTicker.Ticks[i].LabelSize.y * 0.5f;\n        DrawList.AddText(ImVec2(txt_x, txt_y), col_text, gp.CTicker.GetText(i));\n    }\n\n    if (rend_label) {\n        const float pos_x = opposite ? bb_frame.Min.x + gp.Style.PlotPadding.x : bb_grad.Max.x + 2 * txt_off + gp.CTicker.MaxSize.x;\n        const float pos_y = bb_grad.GetCenter().y + label_size.x * 0.5f;\n        const char* label_end = ImGui::FindRenderedTextEnd(label);\n        AddTextVertical(&DrawList,ImVec2(pos_x,pos_y),col_text,label,label_end);\n    }\n    DrawList.AddRect(bb_grad.Min, bb_grad.Max, GetStyleColorU32(ImPlotCol_PlotBorder));\n    ImGui::PopClipRect();\n}\n\nbool ColormapSlider(const char* label, float* t, ImVec4* out, const char* format, ImPlotColormap cmap) {\n    *t = ImClamp(*t,0.0f,1.0f);\n    ImGuiContext &G      = *GImGui;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return false;\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n    const ImU32* keys  = gp.ColormapData.GetKeys(cmap);\n    const int    count = gp.ColormapData.GetKeyCount(cmap);\n    const bool   qual  = gp.ColormapData.IsQual(cmap);\n    const ImVec2 pos  = ImGui::GetCurrentWindow()->DC.CursorPos;\n    const float w     = ImGui::CalcItemWidth();\n    const float h     = ImGui::GetFrameHeight();\n    const ImRect rect = ImRect(pos.x,pos.y,pos.x+w,pos.y+h);\n    RenderColorBar(keys,count,*ImGui::GetWindowDrawList(),rect,false,false,!qual);\n    const ImU32 grab = CalcTextColor(gp.ColormapData.LerpTable(cmap,*t));\n    // const ImU32 text = CalcTextColor(gp.ColormapData.LerpTable(cmap,0.5f));\n    ImGui::PushStyleColor(ImGuiCol_FrameBg,IM_COL32_BLACK_TRANS);\n    ImGui::PushStyleColor(ImGuiCol_FrameBgActive,IM_COL32_BLACK_TRANS);\n    ImGui::PushStyleColor(ImGuiCol_FrameBgHovered,ImVec4(1,1,1,0.1f));\n    ImGui::PushStyleColor(ImGuiCol_SliderGrab,grab);\n    ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, grab);\n    ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize,2);\n    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding,0);\n    const bool changed = ImGui::SliderFloat(label,t,0,1,format);\n    ImGui::PopStyleColor(5);\n    ImGui::PopStyleVar(2);\n    if (out != nullptr)\n        *out = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.LerpTable(cmap,*t));\n    return changed;\n}\n\nbool ColormapButton(const char* label, const ImVec2& size_arg, ImPlotColormap cmap) {\n    ImGuiContext &G      = *GImGui;\n    const ImGuiStyle& style = G.Style;\n    ImGuiWindow * Window = G.CurrentWindow;\n    if (Window->SkipItems)\n        return false;\n    ImPlotContext& gp = *GImPlot;\n    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;\n    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, \"Invalid colormap index!\");\n    const ImU32* keys  = gp.ColormapData.GetKeys(cmap);\n    const int    count = gp.ColormapData.GetKeyCount(cmap);\n    const bool   qual  = gp.ColormapData.IsQual(cmap);\n    const ImVec2 pos  = ImGui::GetCurrentWindow()->DC.CursorPos;\n    const ImVec2 label_size = ImGui::CalcTextSize(label, nullptr, true);\n    ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);\n    const ImRect rect = ImRect(pos.x,pos.y,pos.x+size.x,pos.y+size.y);\n    RenderColorBar(keys,count,*ImGui::GetWindowDrawList(),rect,false,false,!qual);\n    const ImU32 text = CalcTextColor(gp.ColormapData.LerpTable(cmap,G.Style.ButtonTextAlign.x));\n    ImGui::PushStyleColor(ImGuiCol_Button,IM_COL32_BLACK_TRANS);\n    ImGui::PushStyleColor(ImGuiCol_ButtonHovered,ImVec4(1,1,1,0.1f));\n    ImGui::PushStyleColor(ImGuiCol_ButtonActive,ImVec4(1,1,1,0.2f));\n    ImGui::PushStyleColor(ImGuiCol_Text,text);\n    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding,0);\n    const bool pressed = ImGui::Button(label,size);\n    ImGui::PopStyleColor(4);\n    ImGui::PopStyleVar(1);\n    return pressed;\n}\n\n//-----------------------------------------------------------------------------\n// [Section] Miscellaneous\n//-----------------------------------------------------------------------------\n\nImPlotInputMap& GetInputMap() {\n    IM_ASSERT_USER_ERROR(GImPlot != nullptr, \"No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?\");\n    ImPlotContext& gp = *GImPlot;\n    return gp.InputMap;\n}\n\nvoid MapInputDefault(ImPlotInputMap* dst) {\n    ImPlotInputMap& map = dst ? *dst : GetInputMap();\n    map.Pan             = ImGuiMouseButton_Left;\n    map.PanMod          = ImGuiMod_None;\n    map.Fit             = ImGuiMouseButton_Left;\n    map.Menu            = ImGuiMouseButton_Right;\n    map.Select          = ImGuiMouseButton_Right;\n    map.SelectMod       = ImGuiMod_None;\n    map.SelectCancel    = ImGuiMouseButton_Left;\n    map.SelectHorzMod   = ImGuiMod_Alt;\n    map.SelectVertMod   = ImGuiMod_Shift;\n    map.OverrideMod     = ImGuiMod_Ctrl;\n    map.ZoomMod         = ImGuiMod_None;\n    map.ZoomRate        = 0.1f;\n}\n\nvoid MapInputReverse(ImPlotInputMap* dst) {\n    ImPlotInputMap& map = dst ? *dst : GetInputMap();\n    map.Pan             = ImGuiMouseButton_Right;\n    map.PanMod          = ImGuiMod_None;\n    map.Fit             = ImGuiMouseButton_Left;\n    map.Menu            = ImGuiMouseButton_Right;\n    map.Select          = ImGuiMouseButton_Left;\n    map.SelectMod       = ImGuiMod_None;\n    map.SelectCancel    = ImGuiMouseButton_Right;\n    map.SelectHorzMod   = ImGuiMod_Alt;\n    map.SelectVertMod   = ImGuiMod_Shift;\n    map.OverrideMod     = ImGuiMod_Ctrl;\n    map.ZoomMod         = ImGuiMod_None;\n    map.ZoomRate        = 0.1f;\n}\n\n//-----------------------------------------------------------------------------\n// [Section] Miscellaneous\n//-----------------------------------------------------------------------------\n\nvoid ItemIcon(const ImVec4& col) {\n    ItemIcon(ImGui::ColorConvertFloat4ToU32(col));\n}\n\nvoid ItemIcon(ImU32 col) {\n    const float txt_size = ImGui::GetTextLineHeight();\n    ImVec2 size(txt_size-4,txt_size);\n    ImGuiWindow* window = ImGui::GetCurrentWindow();\n    ImVec2 pos = window->DC.CursorPos;\n    ImGui::GetWindowDrawList()->AddRectFilled(pos + ImVec2(0,2), pos + size - ImVec2(0,2), col);\n    ImGui::Dummy(size);\n}\n\nvoid ColormapIcon(ImPlotColormap cmap) {\n    ImPlotContext& gp = *GImPlot;\n    const float txt_size = ImGui::GetTextLineHeight();\n    ImVec2 size(txt_size-4,txt_size);\n    ImGuiWindow* window = ImGui::GetCurrentWindow();\n    ImVec2 pos = window->DC.CursorPos;\n    ImRect rect(pos+ImVec2(0,2),pos+size-ImVec2(0,2));\n    ImDrawList& DrawList = *ImGui::GetWindowDrawList();\n    RenderColorBar(gp.ColormapData.GetKeys(cmap),gp.ColormapData.GetKeyCount(cmap),DrawList,rect,false,false,!gp.ColormapData.IsQual(cmap));\n    ImGui::Dummy(size);\n}\n\nImDrawList* GetPlotDrawList() {\n    return ImGui::GetWindowDrawList();\n}\n\nvoid PushPlotClipRect(float expand) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"PushPlotClipRect() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    ImRect rect = gp.CurrentPlot->PlotRect;\n    rect.Expand(expand);\n    ImGui::PushClipRect(rect.Min, rect.Max, true);\n}\n\nvoid PopPlotClipRect() {\n    SetupLock();\n    ImGui::PopClipRect();\n}\n\nstatic void HelpMarker(const char* desc) {\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::IsItemHovered()) {\n        ImGui::BeginTooltip();\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}\n\nbool ShowStyleSelector(const char* label)\n{\n    static int style_idx = -1;\n    if (ImGui::Combo(label, &style_idx, \"Auto\\0Classic\\0Dark\\0Light\\0\"))\n    {\n        switch (style_idx)\n        {\n        case 0: StyleColorsAuto(); break;\n        case 1: StyleColorsClassic(); break;\n        case 2: StyleColorsDark(); break;\n        case 3: StyleColorsLight(); break;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool ShowColormapSelector(const char* label) {\n    ImPlotContext& gp = *GImPlot;\n    bool set = false;\n    if (ImGui::BeginCombo(label, gp.ColormapData.GetName(gp.Style.Colormap))) {\n        for (int i = 0; i < gp.ColormapData.Count; ++i) {\n            const char* name = gp.ColormapData.GetName(i);\n            if (ImGui::Selectable(name, gp.Style.Colormap == i)) {\n                gp.Style.Colormap = i;\n                ImPlot::BustItemCache();\n                set = true;\n            }\n        }\n        ImGui::EndCombo();\n    }\n    return set;\n}\n\nbool ShowInputMapSelector(const char* label) {\n    static int map_idx = -1;\n    if (ImGui::Combo(label, &map_idx, \"Default\\0Reversed\\0\"))\n    {\n        switch (map_idx)\n        {\n        case 0: MapInputDefault(); break;\n        case 1: MapInputReverse(); break;\n        }\n        return true;\n    }\n    return false;\n}\n\n\nvoid ShowStyleEditor(ImPlotStyle* ref) {\n    ImPlotContext& gp = *GImPlot;\n    ImPlotStyle& style = GetStyle();\n    static ImPlotStyle ref_saved_style;\n    // Default to using internal storage as reference\n    static bool init = true;\n    if (init && ref == nullptr)\n        ref_saved_style = style;\n    init = false;\n    if (ref == nullptr)\n        ref = &ref_saved_style;\n\n    if (ImPlot::ShowStyleSelector(\"Colors##Selector\"))\n        ref_saved_style = style;\n\n    // Save/Revert button\n    if (ImGui::Button(\"Save Ref\"))\n        *ref = ref_saved_style = style;\n    ImGui::SameLine();\n    if (ImGui::Button(\"Revert Ref\"))\n        style = *ref;\n    ImGui::SameLine();\n    HelpMarker(\"Save/Revert in local non-persistent storage. Default Colors definition are not affected. \"\n               \"Use \\\"Export\\\" below to save them somewhere.\");\n    if (ImGui::BeginTabBar(\"##StyleEditor\")) {\n        if (ImGui::BeginTabItem(\"Variables\")) {\n            ImGui::Text(\"Item Styling\");\n            ImGui::SliderFloat(\"LineWeight\", &style.LineWeight, 0.0f, 5.0f, \"%.1f\");\n            ImGui::SliderFloat(\"MarkerSize\", &style.MarkerSize, 2.0f, 10.0f, \"%.1f\");\n            ImGui::SliderFloat(\"MarkerWeight\", &style.MarkerWeight, 0.0f, 5.0f, \"%.1f\");\n            ImGui::SliderFloat(\"FillAlpha\", &style.FillAlpha, 0.0f, 1.0f, \"%.2f\");\n            ImGui::SliderFloat(\"ErrorBarSize\", &style.ErrorBarSize, 0.0f, 10.0f, \"%.1f\");\n            ImGui::SliderFloat(\"ErrorBarWeight\", &style.ErrorBarWeight, 0.0f, 5.0f, \"%.1f\");\n            ImGui::SliderFloat(\"DigitalBitHeight\", &style.DigitalBitHeight, 0.0f, 20.0f, \"%.1f\");\n            ImGui::SliderFloat(\"DigitalBitGap\", &style.DigitalBitGap, 0.0f, 20.0f, \"%.1f\");\n            ImGui::Text(\"Plot Styling\");\n            ImGui::SliderFloat(\"PlotBorderSize\", &style.PlotBorderSize, 0.0f, 2.0f, \"%.0f\");\n            ImGui::SliderFloat(\"MinorAlpha\", &style.MinorAlpha, 0.0f, 1.0f, \"%.2f\");\n            ImGui::SliderFloat2(\"MajorTickLen\", (float*)&style.MajorTickLen, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"MinorTickLen\", (float*)&style.MinorTickLen, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"MajorTickSize\",  (float*)&style.MajorTickSize, 0.0f, 2.0f, \"%.1f\");\n            ImGui::SliderFloat2(\"MinorTickSize\", (float*)&style.MinorTickSize, 0.0f, 2.0f, \"%.1f\");\n            ImGui::SliderFloat2(\"MajorGridSize\", (float*)&style.MajorGridSize, 0.0f, 2.0f, \"%.1f\");\n            ImGui::SliderFloat2(\"MinorGridSize\", (float*)&style.MinorGridSize, 0.0f, 2.0f, \"%.1f\");\n            ImGui::SliderFloat2(\"PlotDefaultSize\", (float*)&style.PlotDefaultSize, 0.0f, 1000, \"%.0f\");\n            ImGui::SliderFloat2(\"PlotMinSize\", (float*)&style.PlotMinSize, 0.0f, 300, \"%.0f\");\n            ImGui::Text(\"Plot Padding\");\n            ImGui::SliderFloat2(\"PlotPadding\", (float*)&style.PlotPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"LabelPadding\", (float*)&style.LabelPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"LegendPadding\", (float*)&style.LegendPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"LegendInnerPadding\", (float*)&style.LegendInnerPadding, 0.0f, 10.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"LegendSpacing\", (float*)&style.LegendSpacing, 0.0f, 5.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"MousePosPadding\", (float*)&style.MousePosPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"AnnotationPadding\", (float*)&style.AnnotationPadding, 0.0f, 5.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"FitPadding\", (float*)&style.FitPadding, 0, 0.2f, \"%.2f\");\n\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Colors\")) {\n            static int output_dest = 0;\n            static bool output_only_modified = false;\n\n            if (ImGui::Button(\"Export\", ImVec2(75,0))) {\n                if (output_dest == 0)\n                    ImGui::LogToClipboard();\n                else\n                    ImGui::LogToTTY();\n                ImGui::LogText(\"ImVec4* colors = ImPlot::GetStyle().Colors;\\n\");\n                for (int i = 0; i < ImPlotCol_COUNT; i++) {\n                    const ImVec4& col = style.Colors[i];\n                    const char* name = ImPlot::GetStyleColorName(i);\n                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0) {\n                        if (IsColorAuto(i))\n                            ImGui::LogText(\"colors[ImPlotCol_%s]%*s= IMPLOT_AUTO_COL;\\n\",name,14 - (int)strlen(name), \"\");\n                        else\n                            ImGui::LogText(\"colors[ImPlotCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\\n\",\n                                        name, 14 - (int)strlen(name), \"\", col.x, col.y, col.z, col.w);\n                    }\n                }\n                ImGui::LogFinish();\n            }\n            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo(\"##output_type\", &output_dest, \"To Clipboard\\0To TTY\\0\");\n            ImGui::SameLine(); ImGui::Checkbox(\"Only Modified Colors\", &output_only_modified);\n\n            static ImGuiTextFilter filter;\n            filter.Draw(\"Filter colors\", ImGui::GetFontSize() * 16);\n\n            static ImGuiColorEditFlags alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf;\n            if (ImGui::RadioButton(\"Opaque\", alpha_flags == ImGuiColorEditFlags_None))             { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Alpha\",  alpha_flags == ImGuiColorEditFlags_AlphaPreview))     { alpha_flags = ImGuiColorEditFlags_AlphaPreview; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Both\",   alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();\n            HelpMarker(\n                \"In the color list:\\n\"\n                \"Left-click on colored square to open color picker,\\n\"\n                \"Right-click to open edit options menu.\");\n            ImGui::Separator();\n            ImGui::PushItemWidth(-160);\n            for (int i = 0; i < ImPlotCol_COUNT; i++) {\n                const char* name = ImPlot::GetStyleColorName(i);\n                if (!filter.PassFilter(name))\n                    continue;\n                ImGui::PushID(i);\n                ImVec4 temp = GetStyleColorVec4(i);\n                const bool is_auto = IsColorAuto(i);\n                if (!is_auto)\n                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.25f);\n                if (ImGui::Button(\"Auto\")) {\n                    if (is_auto)\n                        style.Colors[i] = temp;\n                    else\n                        style.Colors[i] = IMPLOT_AUTO_COL;\n                    BustItemCache();\n                }\n                if (!is_auto)\n                    ImGui::PopStyleVar();\n                ImGui::SameLine();\n                if (ImGui::ColorEdit4(name, &temp.x, ImGuiColorEditFlags_NoInputs | alpha_flags)) {\n                    style.Colors[i] = temp;\n                    BustItemCache();\n                }\n                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0) {\n                    ImGui::SameLine(175); if (ImGui::Button(\"Save\")) { ref->Colors[i] = style.Colors[i]; }\n                    ImGui::SameLine(); if (ImGui::Button(\"Revert\")) {\n                        style.Colors[i] = ref->Colors[i];\n                        BustItemCache();\n                    }\n                }\n                ImGui::PopID();\n            }\n            ImGui::PopItemWidth();\n            ImGui::Separator();\n            ImGui::Text(\"Colors that are set to Auto (i.e. IMPLOT_AUTO_COL) will\\n\"\n                        \"be automatically deduced from your ImGui style or the\\n\"\n                        \"current ImPlot Colormap. If you want to style individual\\n\"\n                        \"plot items, use Push/PopStyleColor around its function.\");\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Colormaps\")) {\n            static int output_dest = 0;\n            if (ImGui::Button(\"Export\", ImVec2(75,0))) {\n                if (output_dest == 0)\n                    ImGui::LogToClipboard();\n                else\n                    ImGui::LogToTTY();\n                int size = GetColormapSize();\n                const char* name = GetColormapName(gp.Style.Colormap);\n                ImGui::LogText(\"static const ImU32 %s_Data[%d] = {\\n\", name, size);\n                for (int i = 0; i < size; ++i) {\n                    ImU32 col = GetColormapColorU32(i,gp.Style.Colormap);\n                    ImGui::LogText(\"    %u%s\\n\", col, i == size - 1 ? \"\" : \",\");\n                }\n                ImGui::LogText(\"};\\nImPlotColormap %s = ImPlot::AddColormap(\\\"%s\\\", %s_Data, %d);\", name, name, name, size);\n                ImGui::LogFinish();\n            }\n            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo(\"##output_type\", &output_dest, \"To Clipboard\\0To TTY\\0\");\n            ImGui::SameLine();\n            static bool edit = false;\n            ImGui::Checkbox(\"Edit Mode\",&edit);\n\n            // built-in/added\n            ImGui::Separator();\n            for (int i = 0; i < gp.ColormapData.Count; ++i) {\n                ImGui::PushID(i);\n                int size = gp.ColormapData.GetKeyCount(i);\n                bool selected = i == gp.Style.Colormap;\n\n                const char* name = GetColormapName(i);\n                if (!selected)\n                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.25f);\n                if (ImGui::Button(name, ImVec2(100,0))) {\n                    gp.Style.Colormap = i;\n                    BustItemCache();\n                }\n                if (!selected)\n                    ImGui::PopStyleVar();\n                ImGui::SameLine();\n                ImGui::BeginGroup();\n                if (edit) {\n                    for (int c = 0; c < size; ++c) {\n                        ImGui::PushID(c);\n                        ImVec4 col4 = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.GetKeyColor(i,c));\n                        if (ImGui::ColorEdit4(\"\",&col4.x,ImGuiColorEditFlags_NoInputs)) {\n                            ImU32 col32 = ImGui::ColorConvertFloat4ToU32(col4);\n                            gp.ColormapData.SetKeyColor(i,c,col32);\n                            BustItemCache();\n                        }\n                        if ((c + 1) % 12 != 0 && c != size -1)\n                            ImGui::SameLine();\n                        ImGui::PopID();\n                    }\n                }\n                else {\n                    if (ImPlot::ColormapButton(\"##\",ImVec2(-1,0),i))\n                        edit = true;\n                }\n                ImGui::EndGroup();\n                ImGui::PopID();\n            }\n\n\n            static ImVector<ImVec4> custom;\n            if (custom.Size == 0) {\n                custom.push_back(ImVec4(1,0,0,1));\n                custom.push_back(ImVec4(0,1,0,1));\n                custom.push_back(ImVec4(0,0,1,1));\n            }\n            ImGui::Separator();\n            ImGui::BeginGroup();\n            static char name[16] = \"MyColormap\";\n\n\n            if (ImGui::Button(\"+\", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x)/2,0)))\n                custom.push_back(ImVec4(0,0,0,1));\n            ImGui::SameLine();\n            if (ImGui::Button(\"-\", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x)/2,0)) && custom.Size > 2)\n                custom.pop_back();\n            ImGui::SetNextItemWidth(100);\n            ImGui::InputText(\"##Name\",name,16,ImGuiInputTextFlags_CharsNoBlank);\n            static bool qual = true;\n            ImGui::Checkbox(\"Qualitative\",&qual);\n            if (ImGui::Button(\"Add\", ImVec2(100, 0)) && gp.ColormapData.GetIndex(name)==-1)\n                AddColormap(name,custom.Data,custom.Size,qual);\n\n            ImGui::EndGroup();\n            ImGui::SameLine();\n            ImGui::BeginGroup();\n            for (int c = 0; c < custom.Size; ++c) {\n                ImGui::PushID(c);\n                if (ImGui::ColorEdit4(\"##Col1\", &custom[c].x, ImGuiColorEditFlags_NoInputs)) {\n\n                }\n                if ((c + 1) % 12 != 0)\n                    ImGui::SameLine();\n                ImGui::PopID();\n            }\n            ImGui::EndGroup();\n\n\n            ImGui::EndTabItem();\n        }\n        ImGui::EndTabBar();\n    }\n}\n\nvoid ShowUserGuide() {\n        ImGui::BulletText(\"Left-click drag within the plot area to pan X and Y axes.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"Left-click drag on axis labels to pan an individual axis.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"Scroll in the plot area to zoom both X and Y axes.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"Scroll on axis labels to zoom an individual axis.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"Right-click drag to box select data.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"Hold Alt to expand box selection horizontally.\");\n        ImGui::BulletText(\"Hold Shift to expand box selection vertically.\");\n        ImGui::BulletText(\"Left-click while box selecting to cancel the selection.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"Double left-click to fit all visible data.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"Double left-click axis labels to fit the individual axis.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"Right-click open the full plot context menu.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"Right-click axis labels to open an individual axis context menu.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"Click legend label icons to show/hide plot items.\");\n}\n\nvoid ShowTicksMetrics(const ImPlotTicker& ticker) {\n    ImGui::BulletText(\"Size: %d\", ticker.TickCount());\n    ImGui::BulletText(\"MaxSize: [%f,%f]\", ticker.MaxSize.x, ticker.MaxSize.y);\n}\n\nvoid ShowAxisMetrics(const ImPlotPlot& plot, const ImPlotAxis& axis) {\n    ImGui::BulletText(\"Label: %s\", axis.LabelOffset == -1 ? \"[none]\" : plot.GetAxisLabel(axis));\n    ImGui::BulletText(\"Flags: 0x%08X\", axis.Flags);\n    ImGui::BulletText(\"Range: [%f,%f]\",axis.Range.Min, axis.Range.Max);\n    ImGui::BulletText(\"Pixels: %f\", axis.PixelSize());\n    ImGui::BulletText(\"Aspect: %f\", axis.GetAspect());\n    ImGui::BulletText(axis.OrthoAxis == nullptr ? \"OrtherAxis: NULL\" : \"OrthoAxis: 0x%08X\", axis.OrthoAxis->ID);\n    ImGui::BulletText(\"LinkedMin: %p\", (void*)axis.LinkedMin);\n    ImGui::BulletText(\"LinkedMax: %p\", (void*)axis.LinkedMax);\n    ImGui::BulletText(\"HasRange: %s\", axis.HasRange ? \"true\" : \"false\");\n    ImGui::BulletText(\"Hovered: %s\", axis.Hovered ? \"true\" : \"false\");\n    ImGui::BulletText(\"Held: %s\", axis.Held ? \"true\" : \"false\");\n\n    if (ImGui::TreeNode(\"Transform\")) {\n        ImGui::BulletText(\"PixelMin: %f\", axis.PixelMin);\n        ImGui::BulletText(\"PixelMax: %f\", axis.PixelMax);\n        ImGui::BulletText(\"ScaleToPixel: %f\", axis.ScaleToPixel);\n        ImGui::BulletText(\"ScaleMax: %f\", axis.ScaleMax);\n        ImGui::TreePop();\n    }\n\n    if (ImGui::TreeNode(\"Ticks\")) {\n        ShowTicksMetrics(axis.Ticker);\n        ImGui::TreePop();\n    }\n}\n\nvoid ShowMetricsWindow(bool* p_popen) {\n\n    static bool show_plot_rects = false;\n    static bool show_axes_rects = false;\n    static bool show_axis_rects = false;\n    static bool show_canvas_rects = false;\n    static bool show_frame_rects = false;\n    static bool show_subplot_frame_rects = false;\n    static bool show_subplot_grid_rects = false;\n    static bool show_legend_rects = false;\n\n    ImDrawList& fg = *ImGui::GetForegroundDrawList();\n\n    ImPlotContext& gp = *GImPlot;\n    // ImGuiContext& g = *GImGui;\n    ImGuiIO& io = ImGui::GetIO();\n    ImGui::Begin(\"ImPlot Metrics\", p_popen);\n    ImGui::Text(\"ImPlot \" IMPLOT_VERSION);\n    ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / io.Framerate, io.Framerate);\n    ImGui::Text(\"Mouse Position: [%.0f,%.0f]\", io.MousePos.x, io.MousePos.y);\n    ImGui::Separator();\n    if (ImGui::TreeNode(\"Tools\")) {\n        if (ImGui::Button(\"Bust Plot Cache\"))\n            BustPlotCache();\n        ImGui::SameLine();\n        if (ImGui::Button(\"Bust Item Cache\"))\n            BustItemCache();\n        ImGui::Checkbox(\"Show Frame Rects\", &show_frame_rects);\n        ImGui::Checkbox(\"Show Canvas Rects\",&show_canvas_rects);\n        ImGui::Checkbox(\"Show Plot Rects\",  &show_plot_rects);\n        ImGui::Checkbox(\"Show Axes Rects\",  &show_axes_rects);\n        ImGui::Checkbox(\"Show Axis Rects\",  &show_axis_rects);\n        ImGui::Checkbox(\"Show Subplot Frame Rects\",  &show_subplot_frame_rects);\n        ImGui::Checkbox(\"Show Subplot Grid Rects\",  &show_subplot_grid_rects);\n        ImGui::Checkbox(\"Show Legend Rects\",  &show_legend_rects);\n        ImGui::TreePop();\n    }\n    const int n_plots = gp.Plots.GetBufSize();\n    const int n_subplots = gp.Subplots.GetBufSize();\n    // render rects\n    for (int p = 0; p < n_plots; ++p) {\n        ImPlotPlot* plot = gp.Plots.GetByIndex(p);\n        if (show_frame_rects)\n            fg.AddRect(plot->FrameRect.Min, plot->FrameRect.Max, IM_COL32(255,0,255,255));\n        if (show_canvas_rects)\n            fg.AddRect(plot->CanvasRect.Min, plot->CanvasRect.Max, IM_COL32(0,255,255,255));\n        if (show_plot_rects)\n            fg.AddRect(plot->PlotRect.Min, plot->PlotRect.Max, IM_COL32(255,255,0,255));\n        if (show_axes_rects)\n            fg.AddRect(plot->AxesRect.Min, plot->AxesRect.Max, IM_COL32(0,255,128,255));\n        if (show_axis_rects) {\n            for (int i = 0; i < ImAxis_COUNT; ++i) {\n                if (plot->Axes[i].Enabled)\n                    fg.AddRect(plot->Axes[i].HoverRect.Min, plot->Axes[i].HoverRect.Max, IM_COL32(0,255,0,255));\n            }\n        }\n        if (show_legend_rects && plot->Items.GetLegendCount() > 0) {\n            fg.AddRect(plot->Items.Legend.Rect.Min, plot->Items.Legend.Rect.Max, IM_COL32(255,192,0,255));\n            fg.AddRect(plot->Items.Legend.RectClamped.Min, plot->Items.Legend.RectClamped.Max, IM_COL32(255,128,0,255));\n        }\n    }\n    for (int p = 0; p < n_subplots; ++p) {\n        ImPlotSubplot* subplot = gp.Subplots.GetByIndex(p);\n        if (show_subplot_frame_rects)\n            fg.AddRect(subplot->FrameRect.Min, subplot->FrameRect.Max, IM_COL32(255,0,0,255));\n        if (show_subplot_grid_rects)\n            fg.AddRect(subplot->GridRect.Min, subplot->GridRect.Max, IM_COL32(0,0,255,255));\n        if (show_legend_rects && subplot->Items.GetLegendCount() > 0) {\n            fg.AddRect(subplot->Items.Legend.Rect.Min, subplot->Items.Legend.Rect.Max, IM_COL32(255,192,0,255));\n            fg.AddRect(subplot->Items.Legend.RectClamped.Min, subplot->Items.Legend.RectClamped.Max, IM_COL32(255,128,0,255));\n        }\n    }\n    if (ImGui::TreeNode(\"Plots\",\"Plots (%d)\", n_plots)) {\n        for (int p = 0; p < n_plots; ++p) {\n            // plot\n            ImPlotPlot& plot = *gp.Plots.GetByIndex(p);\n            ImGui::PushID(p);\n            if (ImGui::TreeNode(\"Plot\", \"Plot [0x%08X]\", plot.ID)) {\n                int n_items = plot.Items.GetItemCount();\n                if (ImGui::TreeNode(\"Items\", \"Items (%d)\", n_items)) {\n                    for (int i = 0; i < n_items; ++i) {\n                        ImPlotItem* item = plot.Items.GetItemByIndex(i);\n                        ImGui::PushID(i);\n                        if (ImGui::TreeNode(\"Item\", \"Item [0x%08X]\", item->ID)) {\n                            ImGui::Bullet(); ImGui::Checkbox(\"Show\", &item->Show);\n                            ImGui::Bullet();\n                            ImVec4 temp = ImGui::ColorConvertU32ToFloat4(item->Color);\n                            if (ImGui::ColorEdit4(\"Color\",&temp.x, ImGuiColorEditFlags_NoInputs))\n                                item->Color = ImGui::ColorConvertFloat4ToU32(temp);\n\n                            ImGui::BulletText(\"NameOffset: %d\",item->NameOffset);\n                            ImGui::BulletText(\"Name: %s\", item->NameOffset != -1 ? plot.Items.Legend.Labels.Buf.Data + item->NameOffset : \"N/A\");\n                            ImGui::BulletText(\"Hovered: %s\",item->LegendHovered ? \"true\" : \"false\");\n                            ImGui::TreePop();\n                        }\n                        ImGui::PopID();\n                    }\n                    ImGui::TreePop();\n                }\n                char buff[16];\n                for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n                    ImFormatString(buff,16,\"X-Axis %d\", i+1);\n                    if (plot.XAxis(i).Enabled && ImGui::TreeNode(buff, \"X-Axis %d [0x%08X]\", i+1, plot.XAxis(i).ID)) {\n                        ShowAxisMetrics(plot, plot.XAxis(i));\n                        ImGui::TreePop();\n                    }\n                }\n                for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n                    ImFormatString(buff,16,\"Y-Axis %d\", i+1);\n                    if (plot.YAxis(i).Enabled && ImGui::TreeNode(buff, \"Y-Axis %d [0x%08X]\", i+1, plot.YAxis(i).ID)) {\n                        ShowAxisMetrics(plot, plot.YAxis(i));\n                        ImGui::TreePop();\n                    }\n                }\n                ImGui::BulletText(\"Title: %s\", plot.HasTitle() ? plot.GetTitle() : \"none\");\n                ImGui::BulletText(\"Flags: 0x%08X\", plot.Flags);\n                ImGui::BulletText(\"Initialized: %s\", plot.Initialized ? \"true\" : \"false\");\n                ImGui::BulletText(\"Selecting: %s\", plot.Selecting ? \"true\" : \"false\");\n                ImGui::BulletText(\"Selected: %s\", plot.Selected ? \"true\" : \"false\");\n                ImGui::BulletText(\"Hovered: %s\", plot.Hovered ? \"true\" : \"false\");\n                ImGui::BulletText(\"Held: %s\", plot.Held ? \"true\" : \"false\");\n                ImGui::BulletText(\"LegendHovered: %s\", plot.Items.Legend.Hovered ? \"true\" : \"false\");\n                ImGui::BulletText(\"ContextLocked: %s\", plot.ContextLocked ? \"true\" : \"false\");\n                ImGui::TreePop();\n            }\n            ImGui::PopID();\n        }\n        ImGui::TreePop();\n    }\n\n    if (ImGui::TreeNode(\"Subplots\",\"Subplots (%d)\", n_subplots)) {\n        for (int p = 0; p < n_subplots; ++p) {\n            // plot\n            ImPlotSubplot& plot = *gp.Subplots.GetByIndex(p);\n            ImGui::PushID(p);\n            if (ImGui::TreeNode(\"Subplot\", \"Subplot [0x%08X]\", plot.ID)) {\n                int n_items = plot.Items.GetItemCount();\n                if (ImGui::TreeNode(\"Items\", \"Items (%d)\", n_items)) {\n                    for (int i = 0; i < n_items; ++i) {\n                        ImPlotItem* item = plot.Items.GetItemByIndex(i);\n                        ImGui::PushID(i);\n                        if (ImGui::TreeNode(\"Item\", \"Item [0x%08X]\", item->ID)) {\n                            ImGui::Bullet(); ImGui::Checkbox(\"Show\", &item->Show);\n                            ImGui::Bullet();\n                            ImVec4 temp = ImGui::ColorConvertU32ToFloat4(item->Color);\n                            if (ImGui::ColorEdit4(\"Color\",&temp.x, ImGuiColorEditFlags_NoInputs))\n                                item->Color = ImGui::ColorConvertFloat4ToU32(temp);\n\n                            ImGui::BulletText(\"NameOffset: %d\",item->NameOffset);\n                            ImGui::BulletText(\"Name: %s\", item->NameOffset != -1 ? plot.Items.Legend.Labels.Buf.Data + item->NameOffset : \"N/A\");\n                            ImGui::BulletText(\"Hovered: %s\",item->LegendHovered ? \"true\" : \"false\");\n                            ImGui::TreePop();\n                        }\n                        ImGui::PopID();\n                    }\n                    ImGui::TreePop();\n                }\n                ImGui::BulletText(\"Flags: 0x%08X\", plot.Flags);\n                ImGui::BulletText(\"FrameHovered: %s\", plot.FrameHovered ? \"true\" : \"false\");\n                ImGui::BulletText(\"LegendHovered: %s\", plot.Items.Legend.Hovered ? \"true\" : \"false\");\n                ImGui::TreePop();\n            }\n            ImGui::PopID();\n        }\n        ImGui::TreePop();\n    }\n    if (ImGui::TreeNode(\"Colormaps\")) {\n        ImGui::BulletText(\"Colormaps:  %d\", gp.ColormapData.Count);\n        ImGui::BulletText(\"Memory: %d bytes\", gp.ColormapData.Tables.Size * 4);\n        if (ImGui::TreeNode(\"Data\")) {\n            for (int m = 0; m < gp.ColormapData.Count; ++m) {\n                if (ImGui::TreeNode(gp.ColormapData.GetName(m))) {\n                    int count = gp.ColormapData.GetKeyCount(m);\n                    int size = gp.ColormapData.GetTableSize(m);\n                    bool qual = gp.ColormapData.IsQual(m);\n                    ImGui::BulletText(\"Qualitative: %s\", qual ? \"true\" : \"false\");\n                    ImGui::BulletText(\"Key Count: %d\", count);\n                    ImGui::BulletText(\"Table Size: %d\", size);\n                    ImGui::Indent();\n\n                    static float t = 0.5;\n                    ImVec4 samp;\n                    float wid = 32 * 10 - ImGui::GetFrameHeight() - ImGui::GetStyle().ItemSpacing.x;\n                    ImGui::SetNextItemWidth(wid);\n                    ImPlot::ColormapSlider(\"##Sample\",&t,&samp,\"%.3f\",m);\n                    ImGui::SameLine();\n                    ImGui::ColorButton(\"Sampler\",samp);\n                    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0,0,0,0));\n                    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));\n                    for (int c = 0; c < size; ++c) {\n                        ImVec4 col = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.GetTableColor(m,c));\n                        ImGui::PushID(m*1000+c);\n                        ImGui::ColorButton(\"\",col,0,ImVec2(10,10));\n                        ImGui::PopID();\n                        if ((c + 1) % 32 != 0 && c != size - 1)\n                            ImGui::SameLine();\n                    }\n                    ImGui::PopStyleVar();\n                    ImGui::PopStyleColor();\n                    ImGui::Unindent();\n                    ImGui::TreePop();\n                }\n            }\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n    ImGui::End();\n}\n\nbool ShowDatePicker(const char* id, int* level, ImPlotTime* t, const ImPlotTime* t1, const ImPlotTime* t2) {\n\n    ImGui::PushID(id);\n    ImGui::BeginGroup();\n\n    ImGuiStyle& style = ImGui::GetStyle();\n    ImVec4 col_txt    = style.Colors[ImGuiCol_Text];\n    ImVec4 col_dis    = style.Colors[ImGuiCol_TextDisabled];\n    ImVec4 col_btn    = style.Colors[ImGuiCol_Button];\n    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0,0,0,0));\n    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));\n\n    const float ht    = ImGui::GetFrameHeight();\n    ImVec2 cell_size(ht*1.25f,ht);\n    char buff[32];\n    bool clk = false;\n    tm& Tm = GImPlot->Tm;\n\n    const int min_yr = 1970;\n    const int max_yr = 2999;\n\n    // t1 parts\n    int t1_mo = 0; int t1_md = 0; int t1_yr = 0;\n    if (t1 != nullptr) {\n        GetTime(*t1,&Tm);\n        t1_mo = Tm.tm_mon;\n        t1_md = Tm.tm_mday;\n        t1_yr = Tm.tm_year + 1900;\n    }\n\n     // t2 parts\n    int t2_mo = 0; int t2_md = 0; int t2_yr = 0;\n    if (t2 != nullptr) {\n        GetTime(*t2,&Tm);\n        t2_mo = Tm.tm_mon;\n        t2_md = Tm.tm_mday;\n        t2_yr = Tm.tm_year + 1900;\n    }\n\n    // day widget\n    if (*level == 0) {\n        *t = FloorTime(*t, ImPlotTimeUnit_Day);\n        GetTime(*t, &Tm);\n        const int this_year = Tm.tm_year + 1900;\n        const int last_year = this_year - 1;\n        const int next_year = this_year + 1;\n        const int this_mon  = Tm.tm_mon;\n        const int last_mon  = this_mon == 0 ? 11 : this_mon - 1;\n        const int next_mon  = this_mon == 11 ? 0 : this_mon + 1;\n        const int days_this_mo = GetDaysInMonth(this_year, this_mon);\n        const int days_last_mo = GetDaysInMonth(this_mon == 0 ? last_year : this_year, last_mon);\n        ImPlotTime t_first_mo = FloorTime(*t,ImPlotTimeUnit_Mo);\n        GetTime(t_first_mo,&Tm);\n        const int first_wd = Tm.tm_wday;\n        // month year\n        ImFormatString(buff, 32, \"%s %d\", MONTH_NAMES[this_mon], this_year);\n        if (ImGui::Button(buff))\n            *level = 1;\n        ImGui::SameLine(5*cell_size.x);\n        BeginDisabledControls(this_year <= min_yr && this_mon == 0);\n        if (ImGui::ArrowButtonEx(\"##Up\",ImGuiDir_Up,cell_size))\n            *t = AddTime(*t, ImPlotTimeUnit_Mo, -1);\n        EndDisabledControls(this_year <= min_yr && this_mon == 0);\n        ImGui::SameLine();\n        BeginDisabledControls(this_year >= max_yr && this_mon == 11);\n        if (ImGui::ArrowButtonEx(\"##Down\",ImGuiDir_Down,cell_size))\n            *t = AddTime(*t, ImPlotTimeUnit_Mo, 1);\n        EndDisabledControls(this_year >= max_yr && this_mon == 11);\n        // render weekday abbreviations\n        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);\n        for (int i = 0; i < 7; ++i) {\n            ImGui::Button(WD_ABRVS[i],cell_size);\n            if (i != 6) { ImGui::SameLine(); }\n        }\n        ImGui::PopItemFlag();\n        // 0 = last mo, 1 = this mo, 2 = next mo\n        int mo = first_wd > 0 ? 0 : 1;\n        int day = mo == 1 ? 1 : days_last_mo - first_wd + 1;\n        for (int i = 0; i < 6; ++i) {\n            for (int j = 0; j < 7; ++j) {\n                if (mo == 0 && day > days_last_mo) {\n                    mo = 1;\n                    day = 1;\n                }\n                else if (mo == 1 && day > days_this_mo) {\n                    mo = 2;\n                    day = 1;\n                }\n                const int now_yr = (mo == 0 && this_mon == 0) ? last_year : ((mo == 2 && this_mon == 11) ? next_year : this_year);\n                const int now_mo = mo == 0 ? last_mon : (mo == 1 ? this_mon : next_mon);\n                const int now_md = day;\n\n                const bool off_mo   = mo == 0 || mo == 2;\n                const bool t1_or_t2 = (t1 != nullptr && t1_mo == now_mo && t1_yr == now_yr && t1_md == now_md) ||\n                                      (t2 != nullptr && t2_mo == now_mo && t2_yr == now_yr && t2_md == now_md);\n\n                if (off_mo)\n                    ImGui::PushStyleColor(ImGuiCol_Text, col_dis);\n                if (t1_or_t2) {\n                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);\n                    ImGui::PushStyleColor(ImGuiCol_Text, col_txt);\n                }\n                ImGui::PushID(i*7+j);\n                ImFormatString(buff,32,\"%d\",day);\n                if (now_yr == min_yr-1 || now_yr == max_yr+1) {\n                    ImGui::Dummy(cell_size);\n                }\n                else if (ImGui::Button(buff,cell_size) && !clk) {\n                    *t = MakeTime(now_yr, now_mo, now_md);\n                    clk = true;\n                }\n                ImGui::PopID();\n                if (t1_or_t2)\n                    ImGui::PopStyleColor(2);\n                if (off_mo)\n                    ImGui::PopStyleColor();\n                if (j != 6)\n                    ImGui::SameLine();\n                day++;\n            }\n        }\n    }\n    // month widget\n    else if (*level == 1) {\n        *t = FloorTime(*t, ImPlotTimeUnit_Mo);\n        GetTime(*t, &Tm);\n        int this_yr  = Tm.tm_year + 1900;\n        ImFormatString(buff, 32, \"%d\", this_yr);\n        if (ImGui::Button(buff))\n            *level = 2;\n        BeginDisabledControls(this_yr <= min_yr);\n        ImGui::SameLine(5*cell_size.x);\n        if (ImGui::ArrowButtonEx(\"##Up\",ImGuiDir_Up,cell_size))\n            *t = AddTime(*t, ImPlotTimeUnit_Yr, -1);\n        EndDisabledControls(this_yr <= min_yr);\n        ImGui::SameLine();\n        BeginDisabledControls(this_yr >= max_yr);\n        if (ImGui::ArrowButtonEx(\"##Down\",ImGuiDir_Down,cell_size))\n            *t = AddTime(*t, ImPlotTimeUnit_Yr, 1);\n        EndDisabledControls(this_yr >= max_yr);\n        // ImGui::Dummy(cell_size);\n        cell_size.x *= 7.0f/4.0f;\n        cell_size.y *= 7.0f/3.0f;\n        int mo = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                const bool t1_or_t2 = (t1 != nullptr && t1_yr == this_yr && t1_mo == mo) ||\n                                      (t2 != nullptr && t2_yr == this_yr && t2_mo == mo);\n                if (t1_or_t2)\n                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);\n                if (ImGui::Button(MONTH_ABRVS[mo],cell_size) && !clk) {\n                    *t = MakeTime(this_yr, mo);\n                    *level = 0;\n                }\n                if (t1_or_t2)\n                    ImGui::PopStyleColor();\n                if (j != 3)\n                    ImGui::SameLine();\n                mo++;\n            }\n        }\n    }\n    else if (*level == 2) {\n        *t = FloorTime(*t, ImPlotTimeUnit_Yr);\n        int this_yr = GetYear(*t);\n        int yr = this_yr  - this_yr % 20;\n        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);\n        ImFormatString(buff,32,\"%d-%d\",yr,yr+19);\n        ImGui::Button(buff);\n        ImGui::PopItemFlag();\n        ImGui::SameLine(5*cell_size.x);\n        BeginDisabledControls(yr <= min_yr);\n        if (ImGui::ArrowButtonEx(\"##Up\",ImGuiDir_Up,cell_size))\n            *t = MakeTime(yr-20);\n        EndDisabledControls(yr <= min_yr);\n        ImGui::SameLine();\n        BeginDisabledControls(yr + 20 >= max_yr);\n        if (ImGui::ArrowButtonEx(\"##Down\",ImGuiDir_Down,cell_size))\n            *t = MakeTime(yr+20);\n        EndDisabledControls(yr+ 20 >= max_yr);\n        // ImGui::Dummy(cell_size);\n        cell_size.x *= 7.0f/4.0f;\n        cell_size.y *= 7.0f/5.0f;\n        for (int i = 0; i < 5; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                const bool t1_or_t2 = (t1 != nullptr && t1_yr == yr) || (t2 != nullptr && t2_yr == yr);\n                if (t1_or_t2)\n                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);\n                ImFormatString(buff,32,\"%d\",yr);\n                if (yr<1970||yr>3000) {\n                    ImGui::Dummy(cell_size);\n                }\n                else if (ImGui::Button(buff,cell_size)) {\n                    *t = MakeTime(yr);\n                    *level = 1;\n                }\n                if (t1_or_t2)\n                    ImGui::PopStyleColor();\n                if (j != 3)\n                    ImGui::SameLine();\n                yr++;\n            }\n        }\n    }\n    ImGui::PopStyleVar();\n    ImGui::PopStyleColor();\n    ImGui::EndGroup();\n    ImGui::PopID();\n    return clk;\n}\n\nbool ShowTimePicker(const char* id, ImPlotTime* t) {\n    ImPlotContext& gp = *GImPlot;\n    ImGui::PushID(id);\n    tm& Tm = gp.Tm;\n    GetTime(*t,&Tm);\n\n    static const char* nums[] = { \"00\",\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\n                                  \"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\n                                  \"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\n                                  \"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"37\",\"38\",\"39\",\n                                  \"40\",\"41\",\"42\",\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\n                                  \"50\",\"51\",\"52\",\"53\",\"54\",\"55\",\"56\",\"57\",\"58\",\"59\"};\n\n    static const char* am_pm[] = {\"am\",\"pm\"};\n\n    bool hour24 = gp.Style.Use24HourClock;\n\n    int hr  = hour24 ? Tm.tm_hour : ((Tm.tm_hour == 0 || Tm.tm_hour == 12) ? 12 : Tm.tm_hour % 12);\n    int min = Tm.tm_min;\n    int sec = Tm.tm_sec;\n    int ap  = Tm.tm_hour < 12 ? 0 : 1;\n\n    bool changed = false;\n\n    ImVec2 spacing = ImGui::GetStyle().ItemSpacing;\n    spacing.x = 0;\n    float width    = ImGui::CalcTextSize(\"888\").x;\n    float height   = ImGui::GetFrameHeight();\n\n    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, spacing);\n    ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize,2.0f);\n    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0,0,0,0));\n    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0,0,0,0));\n    ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered));\n\n    ImGui::SetNextItemWidth(width);\n    if (ImGui::BeginCombo(\"##hr\",nums[hr],ImGuiComboFlags_NoArrowButton)) {\n        const int ia = hour24 ? 0 : 1;\n        const int ib = hour24 ? 24 : 13;\n        for (int i = ia; i < ib; ++i) {\n            if (ImGui::Selectable(nums[i],i==hr)) {\n                hr = i;\n                changed = true;\n            }\n        }\n        ImGui::EndCombo();\n    }\n    ImGui::SameLine();\n    ImGui::Text(\":\");\n    ImGui::SameLine();\n    ImGui::SetNextItemWidth(width);\n    if (ImGui::BeginCombo(\"##min\",nums[min],ImGuiComboFlags_NoArrowButton)) {\n        for (int i = 0; i < 60; ++i) {\n            if (ImGui::Selectable(nums[i],i==min)) {\n                min = i;\n                changed = true;\n            }\n        }\n        ImGui::EndCombo();\n    }\n    ImGui::SameLine();\n    ImGui::Text(\":\");\n    ImGui::SameLine();\n    ImGui::SetNextItemWidth(width);\n    if (ImGui::BeginCombo(\"##sec\",nums[sec],ImGuiComboFlags_NoArrowButton)) {\n        for (int i = 0; i < 60; ++i) {\n            if (ImGui::Selectable(nums[i],i==sec)) {\n                sec = i;\n                changed = true;\n            }\n        }\n        ImGui::EndCombo();\n    }\n    if (!hour24) {\n        ImGui::SameLine();\n        if (ImGui::Button(am_pm[ap],ImVec2(0,height))) {\n            ap = 1 - ap;\n            changed = true;\n        }\n    }\n\n    ImGui::PopStyleColor(3);\n    ImGui::PopStyleVar(2);\n    ImGui::PopID();\n\n    if (changed) {\n        if (!hour24)\n            hr = hr % 12 + ap * 12;\n        Tm.tm_hour = hr;\n        Tm.tm_min  = min;\n        Tm.tm_sec  = sec;\n        *t = MkTime(&Tm);\n    }\n\n    return changed;\n}\n\nvoid StyleColorsAuto(ImPlotStyle* dst) {\n    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();\n    ImVec4* colors                  = style->Colors;\n\n    style->MinorAlpha               = 0.25f;\n\n    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_FrameBg]       = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_PlotBg]        = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_PlotBorder]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_LegendBg]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_LegendBorder]  = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_LegendText]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_TitleText]     = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_InlayText]     = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_PlotBorder]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisText]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisGrid]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Selection]     = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Crosshairs]    = IMPLOT_AUTO_COL;\n}\n\nvoid StyleColorsClassic(ImPlotStyle* dst) {\n    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();\n    ImVec4* colors                  = style->Colors;\n\n    style->MinorAlpha               = 0.5f;\n\n    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_ErrorBar]      = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImPlotCol_FrameBg]       = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);\n    colors[ImPlotCol_PlotBg]        = ImVec4(0.00f, 0.00f, 0.00f, 0.35f);\n    colors[ImPlotCol_PlotBorder]    = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);\n    colors[ImPlotCol_LegendBg]      = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);\n    colors[ImPlotCol_LegendBorder]  = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);\n    colors[ImPlotCol_LegendText]    = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImPlotCol_TitleText]     = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImPlotCol_InlayText]     = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImPlotCol_AxisText]      = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImPlotCol_AxisGrid]      = ImVec4(0.90f, 0.90f, 0.90f, 0.25f);\n    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_Selection]     = ImVec4(0.97f, 0.97f, 0.39f, 1.00f);\n    colors[ImPlotCol_Crosshairs]    = ImVec4(0.50f, 0.50f, 0.50f, 0.75f);\n}\n\nvoid StyleColorsDark(ImPlotStyle* dst) {\n    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();\n    ImVec4* colors                  = style->Colors;\n\n    style->MinorAlpha               = 0.25f;\n\n    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_FrameBg]       = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);\n    colors[ImPlotCol_PlotBg]        = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);\n    colors[ImPlotCol_PlotBorder]    = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);\n    colors[ImPlotCol_LegendBg]      = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);\n    colors[ImPlotCol_LegendBorder]  = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);\n    colors[ImPlotCol_LegendText]    = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_TitleText]     = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_InlayText]     = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_AxisText]      = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_AxisGrid]      = ImVec4(1.00f, 1.00f, 1.00f, 0.25f);\n    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_Selection]     = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\n    colors[ImPlotCol_Crosshairs]    = ImVec4(1.00f, 1.00f, 1.00f, 0.50f);\n}\n\nvoid StyleColorsLight(ImPlotStyle* dst) {\n    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();\n    ImVec4* colors                  = style->Colors;\n\n    style->MinorAlpha               = 1.0f;\n\n    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_FrameBg]       = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_PlotBg]        = ImVec4(0.42f, 0.57f, 1.00f, 0.13f);\n    colors[ImPlotCol_PlotBorder]    = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImPlotCol_LegendBg]      = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);\n    colors[ImPlotCol_LegendBorder]  = ImVec4(0.82f, 0.82f, 0.82f, 0.80f);\n    colors[ImPlotCol_LegendText]    = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_TitleText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_InlayText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_AxisText]      = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_AxisGrid]      = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_AxisTick]      = ImVec4(0.00f, 0.00f, 0.00f, 0.25f);\n    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO\n    colors[ImPlotCol_Selection]     = ImVec4(0.82f, 0.64f, 0.03f, 1.00f);\n    colors[ImPlotCol_Crosshairs]    = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Obsolete Functions/Types\n//-----------------------------------------------------------------------------\n\n#ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS\n\nbool BeginPlot(const char* title, const char* x_label, const char* y1_label, const ImVec2& size,\n               ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y1_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags,\n               const char* y2_label, const char* y3_label)\n{\n    if (!BeginPlot(title, size, flags))\n        return false;\n    SetupAxis(ImAxis_X1, x_label, x_flags);\n    SetupAxis(ImAxis_Y1, y1_label, y1_flags);\n    if (ImHasFlag(flags, ImPlotFlags_YAxis2))\n        SetupAxis(ImAxis_Y2, y2_label, y2_flags);\n    if (ImHasFlag(flags, ImPlotFlags_YAxis3))\n        SetupAxis(ImAxis_Y3, y3_label, y3_flags);\n    return true;\n}\n\n#endif\n\n}  // namespace ImPlot\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "implot.h",
          "type": "blob",
          "size": 78.0478515625,
          "content": "// MIT License\n\n// Copyright (c) 2023 Evan Pezent\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// ImPlot v0.17\n\n// Table of Contents:\n//\n// [SECTION] Macros and Defines\n// [SECTION] Enums and Types\n// [SECTION] Callbacks\n// [SECTION] Contexts\n// [SECTION] Begin/End Plot\n// [SECTION] Begin/End Subplot\n// [SECTION] Setup\n// [SECTION] SetNext\n// [SECTION] Plot Items\n// [SECTION] Plot Tools\n// [SECTION] Plot Utils\n// [SECTION] Legend Utils\n// [SECTION] Drag and Drop\n// [SECTION] Styling\n// [SECTION] Colormaps\n// [SECTION] Input Mapping\n// [SECTION] Miscellaneous\n// [SECTION] Demo\n// [SECTION] Obsolete API\n\n#pragma once\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n//-----------------------------------------------------------------------------\n// [SECTION] Macros and Defines\n//-----------------------------------------------------------------------------\n\n// Define attributes of all API symbols declarations (e.g. for DLL under Windows)\n// Using ImPlot via a shared library is not recommended, because we don't guarantee\n// backward nor forward ABI compatibility and also function call overhead. If you\n// do use ImPlot as a DLL, be sure to call SetImGuiContext (see Miscellanous section).\n#ifndef IMPLOT_API\n#define IMPLOT_API\n#endif\n\n// ImPlot version string.\n#define IMPLOT_VERSION \"0.17\"\n// Indicates variable should deduced automatically.\n#define IMPLOT_AUTO -1\n// Special color used to indicate that a color should be deduced automatically.\n#define IMPLOT_AUTO_COL ImVec4(0,0,0,-1)\n// Macro for templated plotting functions; keeps header clean.\n#define IMPLOT_TMP template <typename T> IMPLOT_API\n\n//-----------------------------------------------------------------------------\n// [SECTION] Enums and Types\n//-----------------------------------------------------------------------------\n\n// Forward declarations\nstruct ImPlotContext;             // ImPlot context (opaque struct, see implot_internal.h)\n\n// Enums/Flags\ntypedef int ImAxis;                   // -> enum ImAxis_\ntypedef int ImPlotFlags;              // -> enum ImPlotFlags_\ntypedef int ImPlotAxisFlags;          // -> enum ImPlotAxisFlags_\ntypedef int ImPlotSubplotFlags;       // -> enum ImPlotSubplotFlags_\ntypedef int ImPlotLegendFlags;        // -> enum ImPlotLegendFlags_\ntypedef int ImPlotMouseTextFlags;     // -> enum ImPlotMouseTextFlags_\ntypedef int ImPlotDragToolFlags;      // -> ImPlotDragToolFlags_\ntypedef int ImPlotColormapScaleFlags; // -> ImPlotColormapScaleFlags_\n\ntypedef int ImPlotItemFlags;          // -> ImPlotItemFlags_\ntypedef int ImPlotLineFlags;          // -> ImPlotLineFlags_\ntypedef int ImPlotScatterFlags;       // -> ImPlotScatterFlags\ntypedef int ImPlotStairsFlags;        // -> ImPlotStairsFlags_\ntypedef int ImPlotShadedFlags;        // -> ImPlotShadedFlags_\ntypedef int ImPlotBarsFlags;          // -> ImPlotBarsFlags_\ntypedef int ImPlotBarGroupsFlags;     // -> ImPlotBarGroupsFlags_\ntypedef int ImPlotErrorBarsFlags;     // -> ImPlotErrorBarsFlags_\ntypedef int ImPlotStemsFlags;         // -> ImPlotStemsFlags_\ntypedef int ImPlotInfLinesFlags;      // -> ImPlotInfLinesFlags_\ntypedef int ImPlotPieChartFlags;      // -> ImPlotPieChartFlags_\ntypedef int ImPlotHeatmapFlags;       // -> ImPlotHeatmapFlags_\ntypedef int ImPlotHistogramFlags;     // -> ImPlotHistogramFlags_\ntypedef int ImPlotDigitalFlags;       // -> ImPlotDigitalFlags_\ntypedef int ImPlotImageFlags;         // -> ImPlotImageFlags_\ntypedef int ImPlotTextFlags;          // -> ImPlotTextFlags_\ntypedef int ImPlotDummyFlags;         // -> ImPlotDummyFlags_\n\ntypedef int ImPlotCond;               // -> enum ImPlotCond_\ntypedef int ImPlotCol;                // -> enum ImPlotCol_\ntypedef int ImPlotStyleVar;           // -> enum ImPlotStyleVar_\ntypedef int ImPlotScale;              // -> enum ImPlotScale_\ntypedef int ImPlotMarker;             // -> enum ImPlotMarker_\ntypedef int ImPlotColormap;           // -> enum ImPlotColormap_\ntypedef int ImPlotLocation;           // -> enum ImPlotLocation_\ntypedef int ImPlotBin;                // -> enum ImPlotBin_\n\n// Axis indices. The values assigned may change; NEVER hardcode these.\nenum ImAxis_ {\n    // horizontal axes\n    ImAxis_X1 = 0, // enabled by default\n    ImAxis_X2,     // disabled by default\n    ImAxis_X3,     // disabled by default\n    // vertical axes\n    ImAxis_Y1,     // enabled by default\n    ImAxis_Y2,     // disabled by default\n    ImAxis_Y3,     // disabled by default\n    // bookeeping\n    ImAxis_COUNT\n};\n\n// Options for plots (see BeginPlot).\nenum ImPlotFlags_ {\n    ImPlotFlags_None          = 0,       // default\n    ImPlotFlags_NoTitle       = 1 << 0,  // the plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. \"##MyPlot\")\n    ImPlotFlags_NoLegend      = 1 << 1,  // the legend will not be displayed\n    ImPlotFlags_NoMouseText   = 1 << 2,  // the mouse position, in plot coordinates, will not be displayed inside of the plot\n    ImPlotFlags_NoInputs      = 1 << 3,  // the user will not be able to interact with the plot\n    ImPlotFlags_NoMenus       = 1 << 4,  // the user will not be able to open context menus\n    ImPlotFlags_NoBoxSelect   = 1 << 5,  // the user will not be able to box-select\n    ImPlotFlags_NoFrame       = 1 << 6,  // the ImGui frame will not be rendered\n    ImPlotFlags_Equal         = 1 << 7,  // x and y axes pairs will be constrained to have the same units/pixel\n    ImPlotFlags_Crosshairs    = 1 << 8,  // the default mouse cursor will be replaced with a crosshair when hovered\n    ImPlotFlags_CanvasOnly    = ImPlotFlags_NoTitle | ImPlotFlags_NoLegend | ImPlotFlags_NoMenus | ImPlotFlags_NoBoxSelect | ImPlotFlags_NoMouseText\n};\n\n// Options for plot axes (see SetupAxis).\nenum ImPlotAxisFlags_ {\n    ImPlotAxisFlags_None          = 0,       // default\n    ImPlotAxisFlags_NoLabel       = 1 << 0,  // the axis label will not be displayed (axis labels are also hidden if the supplied string name is nullptr)\n    ImPlotAxisFlags_NoGridLines   = 1 << 1,  // no grid lines will be displayed\n    ImPlotAxisFlags_NoTickMarks   = 1 << 2,  // no tick marks will be displayed\n    ImPlotAxisFlags_NoTickLabels  = 1 << 3,  // no text labels will be displayed\n    ImPlotAxisFlags_NoInitialFit  = 1 << 4,  // axis will not be initially fit to data extents on the first rendered frame\n    ImPlotAxisFlags_NoMenus       = 1 << 5,  // the user will not be able to open context menus with right-click\n    ImPlotAxisFlags_NoSideSwitch  = 1 << 6,  // the user will not be able to switch the axis side by dragging it\n    ImPlotAxisFlags_NoHighlight   = 1 << 7,  // the axis will not have its background highlighted when hovered or held\n    ImPlotAxisFlags_Opposite      = 1 << 8,  // axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top)\n    ImPlotAxisFlags_Foreground    = 1 << 9,  // grid lines will be displayed in the foreground (i.e. on top of data) instead of the background\n    ImPlotAxisFlags_Invert        = 1 << 10, // the axis will be inverted\n    ImPlotAxisFlags_AutoFit       = 1 << 11, // axis will be auto-fitting to data extents\n    ImPlotAxisFlags_RangeFit      = 1 << 12, // axis will only fit points if the point is in the visible range of the **orthogonal** axis\n    ImPlotAxisFlags_PanStretch    = 1 << 13, // panning in a locked or constrained state will cause the axis to stretch if possible\n    ImPlotAxisFlags_LockMin       = 1 << 14, // the axis minimum value will be locked when panning/zooming\n    ImPlotAxisFlags_LockMax       = 1 << 15, // the axis maximum value will be locked when panning/zooming\n    ImPlotAxisFlags_Lock          = ImPlotAxisFlags_LockMin | ImPlotAxisFlags_LockMax,\n    ImPlotAxisFlags_NoDecorations = ImPlotAxisFlags_NoLabel | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoTickMarks | ImPlotAxisFlags_NoTickLabels,\n    ImPlotAxisFlags_AuxDefault    = ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_Opposite\n};\n\n// Options for subplots (see BeginSubplot)\nenum ImPlotSubplotFlags_ {\n    ImPlotSubplotFlags_None        = 0,       // default\n    ImPlotSubplotFlags_NoTitle     = 1 << 0,  // the subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. \"##MySubplot\")\n    ImPlotSubplotFlags_NoLegend    = 1 << 1,  // the legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled)\n    ImPlotSubplotFlags_NoMenus     = 1 << 2,  // the user will not be able to open context menus with right-click\n    ImPlotSubplotFlags_NoResize    = 1 << 3,  // resize splitters between subplot cells will be not be provided\n    ImPlotSubplotFlags_NoAlign     = 1 << 4,  // subplot edges will not be aligned vertically or horizontally\n    ImPlotSubplotFlags_ShareItems  = 1 << 5,  // items across all subplots will be shared and rendered into a single legend entry\n    ImPlotSubplotFlags_LinkRows    = 1 << 6,  // link the y-axis limits of all plots in each row (does not apply to auxiliary axes)\n    ImPlotSubplotFlags_LinkCols    = 1 << 7,  // link the x-axis limits of all plots in each column (does not apply to auxiliary axes)\n    ImPlotSubplotFlags_LinkAllX    = 1 << 8,  // link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes)\n    ImPlotSubplotFlags_LinkAllY    = 1 << 9,  // link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes)\n    ImPlotSubplotFlags_ColMajor    = 1 << 10  // subplots are added in column major order instead of the default row major order\n};\n\n// Options for legends (see SetupLegend)\nenum ImPlotLegendFlags_ {\n    ImPlotLegendFlags_None            = 0,      // default\n    ImPlotLegendFlags_NoButtons       = 1 << 0, // legend icons will not function as hide/show buttons\n    ImPlotLegendFlags_NoHighlightItem = 1 << 1, // plot items will not be highlighted when their legend entry is hovered\n    ImPlotLegendFlags_NoHighlightAxis = 1 << 2, // axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count > 1)\n    ImPlotLegendFlags_NoMenus         = 1 << 3, // the user will not be able to open context menus with right-click\n    ImPlotLegendFlags_Outside         = 1 << 4, // legend will be rendered outside of the plot area\n    ImPlotLegendFlags_Horizontal      = 1 << 5, // legend entries will be displayed horizontally\n    ImPlotLegendFlags_Sort            = 1 << 6, // legend entries will be displayed in alphabetical order\n};\n\n// Options for mouse hover text (see SetupMouseText)\nenum ImPlotMouseTextFlags_ {\n    ImPlotMouseTextFlags_None        = 0,      // default\n    ImPlotMouseTextFlags_NoAuxAxes   = 1 << 0, // only show the mouse position for primary axes\n    ImPlotMouseTextFlags_NoFormat    = 1 << 1, // axes label formatters won't be used to render text\n    ImPlotMouseTextFlags_ShowAlways  = 1 << 2, // always display mouse position even if plot not hovered\n};\n\n// Options for DragPoint, DragLine, DragRect\nenum ImPlotDragToolFlags_ {\n    ImPlotDragToolFlags_None      = 0,      // default\n    ImPlotDragToolFlags_NoCursors = 1 << 0, // drag tools won't change cursor icons when hovered or held\n    ImPlotDragToolFlags_NoFit     = 1 << 1, // the drag tool won't be considered for plot fits\n    ImPlotDragToolFlags_NoInputs  = 1 << 2, // lock the tool from user inputs\n    ImPlotDragToolFlags_Delayed   = 1 << 3, // tool rendering will be delayed one frame; useful when applying position-constraints\n};\n\n// Flags for ColormapScale\nenum ImPlotColormapScaleFlags_ {\n    ImPlotColormapScaleFlags_None     = 0,      // default\n    ImPlotColormapScaleFlags_NoLabel  = 1 << 0, // the colormap axis label will not be displayed\n    ImPlotColormapScaleFlags_Opposite = 1 << 1, // render the colormap label and tick labels on the opposite side\n    ImPlotColormapScaleFlags_Invert   = 1 << 2, // invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min > scale_max)\n};\n\n// Flags for ANY PlotX function\nenum ImPlotItemFlags_ {\n    ImPlotItemFlags_None     = 0,\n    ImPlotItemFlags_NoLegend = 1 << 0, // the item won't have a legend entry displayed\n    ImPlotItemFlags_NoFit    = 1 << 1, // the item won't be considered for plot fits\n};\n\n// Flags for PlotLine\nenum ImPlotLineFlags_ {\n    ImPlotLineFlags_None        = 0,       // default\n    ImPlotLineFlags_Segments    = 1 << 10, // a line segment will be rendered from every two consecutive points\n    ImPlotLineFlags_Loop        = 1 << 11, // the last and first point will be connected to form a closed loop\n    ImPlotLineFlags_SkipNaN     = 1 << 12, // NaNs values will be skipped instead of rendered as missing data\n    ImPlotLineFlags_NoClip      = 1 << 13, // markers (if displayed) on the edge of a plot will not be clipped\n    ImPlotLineFlags_Shaded      = 1 << 14, // a filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases\n};\n\n// Flags for PlotScatter\nenum ImPlotScatterFlags_ {\n    ImPlotScatterFlags_None   = 0,       // default\n    ImPlotScatterFlags_NoClip = 1 << 10, // markers on the edge of a plot will not be clipped\n};\n\n// Flags for PlotStairs\nenum ImPlotStairsFlags_ {\n    ImPlotStairsFlags_None     = 0,       // default\n    ImPlotStairsFlags_PreStep  = 1 << 10, // the y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]\n    ImPlotStairsFlags_Shaded   = 1 << 11  // a filled region between the stairs and horizontal origin will be rendered; use PlotShaded for more advanced cases\n};\n\n// Flags for PlotShaded (placeholder)\nenum ImPlotShadedFlags_ {\n    ImPlotShadedFlags_None  = 0 // default\n};\n\n// Flags for PlotBars\nenum ImPlotBarsFlags_ {\n    ImPlotBarsFlags_None         = 0,       // default\n    ImPlotBarsFlags_Horizontal   = 1 << 10, // bars will be rendered horizontally on the current y-axis\n};\n\n// Flags for PlotBarGroups\nenum ImPlotBarGroupsFlags_ {\n    ImPlotBarGroupsFlags_None        = 0,       // default\n    ImPlotBarGroupsFlags_Horizontal  = 1 << 10, // bar groups will be rendered horizontally on the current y-axis\n    ImPlotBarGroupsFlags_Stacked     = 1 << 11, // items in a group will be stacked on top of each other\n};\n\n// Flags for PlotErrorBars\nenum ImPlotErrorBarsFlags_ {\n    ImPlotErrorBarsFlags_None       = 0,       // default\n    ImPlotErrorBarsFlags_Horizontal = 1 << 10, // error bars will be rendered horizontally on the current y-axis\n};\n\n// Flags for PlotStems\nenum ImPlotStemsFlags_ {\n    ImPlotStemsFlags_None       = 0,       // default\n    ImPlotStemsFlags_Horizontal = 1 << 10, // stems will be rendered horizontally on the current y-axis\n};\n\n// Flags for PlotInfLines\nenum ImPlotInfLinesFlags_ {\n    ImPlotInfLinesFlags_None       = 0,      // default\n    ImPlotInfLinesFlags_Horizontal = 1 << 10 // lines will be rendered horizontally on the current y-axis\n};\n\n// Flags for PlotPieChart\nenum ImPlotPieChartFlags_ {\n    ImPlotPieChartFlags_None         = 0,       // default\n    ImPlotPieChartFlags_Normalize    = 1 << 10, // force normalization of pie chart values (i.e. always make a full circle if sum < 0)\n    ImPlotPieChartFlags_IgnoreHidden = 1 << 11, // ignore hidden slices when drawing the pie chart (as if they were not there)\n    ImPlotPieChartFlags_Exploding    = 1 << 12  // Explode legend-hovered slice\n};\n\n// Flags for PlotHeatmap\nenum ImPlotHeatmapFlags_ {\n    ImPlotHeatmapFlags_None     = 0,       // default\n    ImPlotHeatmapFlags_ColMajor = 1 << 10, // data will be read in column major order\n};\n\n// Flags for PlotHistogram and PlotHistogram2D\nenum ImPlotHistogramFlags_ {\n    ImPlotHistogramFlags_None       = 0,       // default\n    ImPlotHistogramFlags_Horizontal = 1 << 10, // histogram bars will be rendered horizontally (not supported by PlotHistogram2D)\n    ImPlotHistogramFlags_Cumulative = 1 << 11, // each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D)\n    ImPlotHistogramFlags_Density    = 1 << 12, // counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set\n    ImPlotHistogramFlags_NoOutliers = 1 << 13, // exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts\n    ImPlotHistogramFlags_ColMajor   = 1 << 14  // data will be read in column major order (not supported by PlotHistogram)\n};\n\n// Flags for PlotDigital (placeholder)\nenum ImPlotDigitalFlags_ {\n    ImPlotDigitalFlags_None = 0 // default\n};\n\n// Flags for PlotImage (placeholder)\nenum ImPlotImageFlags_ {\n    ImPlotImageFlags_None = 0 // default\n};\n\n// Flags for PlotText\nenum ImPlotTextFlags_ {\n    ImPlotTextFlags_None     = 0,       // default\n    ImPlotTextFlags_Vertical = 1 << 10  // text will be rendered vertically\n};\n\n// Flags for PlotDummy (placeholder)\nenum ImPlotDummyFlags_ {\n    ImPlotDummyFlags_None = 0 // default\n};\n\n// Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums)\nenum ImPlotCond_\n{\n    ImPlotCond_None   = ImGuiCond_None,    // No condition (always set the variable), same as _Always\n    ImPlotCond_Always = ImGuiCond_Always,  // No condition (always set the variable)\n    ImPlotCond_Once   = ImGuiCond_Once,    // Set the variable once per runtime session (only the first call will succeed)\n};\n\n// Plot styling colors.\nenum ImPlotCol_ {\n    // item styling colors\n    ImPlotCol_Line,          // plot line/outline color (defaults to next unused color in current colormap)\n    ImPlotCol_Fill,          // plot fill color for bars (defaults to the current line color)\n    ImPlotCol_MarkerOutline, // marker outline color (defaults to the current line color)\n    ImPlotCol_MarkerFill,    // marker fill color (defaults to the current line color)\n    ImPlotCol_ErrorBar,      // error bar color (defaults to ImGuiCol_Text)\n    // plot styling colors\n    ImPlotCol_FrameBg,       // plot frame background color (defaults to ImGuiCol_FrameBg)\n    ImPlotCol_PlotBg,        // plot area background color (defaults to ImGuiCol_WindowBg)\n    ImPlotCol_PlotBorder,    // plot area border color (defaults to ImGuiCol_Border)\n    ImPlotCol_LegendBg,      // legend background color (defaults to ImGuiCol_PopupBg)\n    ImPlotCol_LegendBorder,  // legend border color (defaults to ImPlotCol_PlotBorder)\n    ImPlotCol_LegendText,    // legend text color (defaults to ImPlotCol_InlayText)\n    ImPlotCol_TitleText,     // plot title text color (defaults to ImGuiCol_Text)\n    ImPlotCol_InlayText,     // color of text appearing inside of plots (defaults to ImGuiCol_Text)\n    ImPlotCol_AxisText,      // axis label and tick lables color (defaults to ImGuiCol_Text)\n    ImPlotCol_AxisGrid,      // axis grid color (defaults to 25% ImPlotCol_AxisText)\n    ImPlotCol_AxisTick,      // axis tick color (defaults to AxisGrid)\n    ImPlotCol_AxisBg,        // background color of axis hover region (defaults to transparent)\n    ImPlotCol_AxisBgHovered, // axis hover color (defaults to ImGuiCol_ButtonHovered)\n    ImPlotCol_AxisBgActive,  // axis active color (defaults to ImGuiCol_ButtonActive)\n    ImPlotCol_Selection,     // box-selection color (defaults to yellow)\n    ImPlotCol_Crosshairs,    // crosshairs color (defaults to ImPlotCol_PlotBorder)\n    ImPlotCol_COUNT\n};\n\n// Plot styling variables.\nenum ImPlotStyleVar_ {\n    // item styling variables\n    ImPlotStyleVar_LineWeight,         // float,  plot item line weight in pixels\n    ImPlotStyleVar_Marker,             // int,    marker specification\n    ImPlotStyleVar_MarkerSize,         // float,  marker size in pixels (roughly the marker's \"radius\")\n    ImPlotStyleVar_MarkerWeight,       // float,  plot outline weight of markers in pixels\n    ImPlotStyleVar_FillAlpha,          // float,  alpha modifier applied to all plot item fills\n    ImPlotStyleVar_ErrorBarSize,       // float,  error bar whisker width in pixels\n    ImPlotStyleVar_ErrorBarWeight,     // float,  error bar whisker weight in pixels\n    ImPlotStyleVar_DigitalBitHeight,   // float,  digital channels bit height (at 1) in pixels\n    ImPlotStyleVar_DigitalBitGap,      // float,  digital channels bit padding gap in pixels\n    // plot styling variables\n    ImPlotStyleVar_PlotBorderSize,     // float,  thickness of border around plot area\n    ImPlotStyleVar_MinorAlpha,         // float,  alpha multiplier applied to minor axis grid lines\n    ImPlotStyleVar_MajorTickLen,       // ImVec2, major tick lengths for X and Y axes\n    ImPlotStyleVar_MinorTickLen,       // ImVec2, minor tick lengths for X and Y axes\n    ImPlotStyleVar_MajorTickSize,      // ImVec2, line thickness of major ticks\n    ImPlotStyleVar_MinorTickSize,      // ImVec2, line thickness of minor ticks\n    ImPlotStyleVar_MajorGridSize,      // ImVec2, line thickness of major grid lines\n    ImPlotStyleVar_MinorGridSize,      // ImVec2, line thickness of minor grid lines\n    ImPlotStyleVar_PlotPadding,        // ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)\n    ImPlotStyleVar_LabelPadding,       // ImVec2, padding between axes labels, tick labels, and plot edge\n    ImPlotStyleVar_LegendPadding,      // ImVec2, legend padding from plot edges\n    ImPlotStyleVar_LegendInnerPadding, // ImVec2, legend inner padding from legend edges\n    ImPlotStyleVar_LegendSpacing,      // ImVec2, spacing between legend entries\n    ImPlotStyleVar_MousePosPadding,    // ImVec2, padding between plot edge and interior info text\n    ImPlotStyleVar_AnnotationPadding,  // ImVec2, text padding around annotation labels\n    ImPlotStyleVar_FitPadding,         // ImVec2, additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)\n    ImPlotStyleVar_PlotDefaultSize,    // ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot\n    ImPlotStyleVar_PlotMinSize,        // ImVec2, minimum size plot frame can be when shrunk\n    ImPlotStyleVar_COUNT\n};\n\n// Axis scale\nenum ImPlotScale_ {\n    ImPlotScale_Linear = 0, // default linear scale\n    ImPlotScale_Time,       // date/time scale\n    ImPlotScale_Log10,      // base 10 logartithmic scale\n    ImPlotScale_SymLog,     // symmetric log scale\n};\n\n// Marker specifications.\nenum ImPlotMarker_ {\n    ImPlotMarker_None = -1, // no marker\n    ImPlotMarker_Circle,    // a circle marker (default)\n    ImPlotMarker_Square,    // a square maker\n    ImPlotMarker_Diamond,   // a diamond marker\n    ImPlotMarker_Up,        // an upward-pointing triangle marker\n    ImPlotMarker_Down,      // an downward-pointing triangle marker\n    ImPlotMarker_Left,      // an leftward-pointing triangle marker\n    ImPlotMarker_Right,     // an rightward-pointing triangle marker\n    ImPlotMarker_Cross,     // a cross marker (not fillable)\n    ImPlotMarker_Plus,      // a plus marker (not fillable)\n    ImPlotMarker_Asterisk,  // a asterisk marker (not fillable)\n    ImPlotMarker_COUNT\n};\n\n// Built-in colormaps\nenum ImPlotColormap_ {\n    ImPlotColormap_Deep     = 0,   // a.k.a. seaborn deep             (qual=true,  n=10) (default)\n    ImPlotColormap_Dark     = 1,   // a.k.a. matplotlib \"Set1\"        (qual=true,  n=9 )\n    ImPlotColormap_Pastel   = 2,   // a.k.a. matplotlib \"Pastel1\"     (qual=true,  n=9 )\n    ImPlotColormap_Paired   = 3,   // a.k.a. matplotlib \"Paired\"      (qual=true,  n=12)\n    ImPlotColormap_Viridis  = 4,   // a.k.a. matplotlib \"viridis\"     (qual=false, n=11)\n    ImPlotColormap_Plasma   = 5,   // a.k.a. matplotlib \"plasma\"      (qual=false, n=11)\n    ImPlotColormap_Hot      = 6,   // a.k.a. matplotlib/MATLAB \"hot\"  (qual=false, n=11)\n    ImPlotColormap_Cool     = 7,   // a.k.a. matplotlib/MATLAB \"cool\" (qual=false, n=11)\n    ImPlotColormap_Pink     = 8,   // a.k.a. matplotlib/MATLAB \"pink\" (qual=false, n=11)\n    ImPlotColormap_Jet      = 9,   // a.k.a. MATLAB \"jet\"             (qual=false, n=11)\n    ImPlotColormap_Twilight = 10,  // a.k.a. matplotlib \"twilight\"    (qual=false, n=11)\n    ImPlotColormap_RdBu     = 11,  // red/blue, Color Brewer          (qual=false, n=11)\n    ImPlotColormap_BrBG     = 12,  // brown/blue-green, Color Brewer  (qual=false, n=11)\n    ImPlotColormap_PiYG     = 13,  // pink/yellow-green, Color Brewer (qual=false, n=11)\n    ImPlotColormap_Spectral = 14,  // color spectrum, Color Brewer    (qual=false, n=11)\n    ImPlotColormap_Greys    = 15,  // white/black                     (qual=false, n=2 )\n};\n\n// Used to position items on a plot (e.g. legends, labels, etc.)\nenum ImPlotLocation_ {\n    ImPlotLocation_Center    = 0,                                          // center-center\n    ImPlotLocation_North     = 1 << 0,                                     // top-center\n    ImPlotLocation_South     = 1 << 1,                                     // bottom-center\n    ImPlotLocation_West      = 1 << 2,                                     // center-left\n    ImPlotLocation_East      = 1 << 3,                                     // center-right\n    ImPlotLocation_NorthWest = ImPlotLocation_North | ImPlotLocation_West, // top-left\n    ImPlotLocation_NorthEast = ImPlotLocation_North | ImPlotLocation_East, // top-right\n    ImPlotLocation_SouthWest = ImPlotLocation_South | ImPlotLocation_West, // bottom-left\n    ImPlotLocation_SouthEast = ImPlotLocation_South | ImPlotLocation_East  // bottom-right\n};\n\n// Enums for different automatic histogram binning methods (k = bin count or w = bin width)\nenum ImPlotBin_ {\n    ImPlotBin_Sqrt    = -1, // k = sqrt(n)\n    ImPlotBin_Sturges = -2, // k = 1 + log2(n)\n    ImPlotBin_Rice    = -3, // k = 2 * cbrt(n)\n    ImPlotBin_Scott   = -4, // w = 3.49 * sigma / cbrt(n)\n};\n\n// Double precision version of ImVec2 used by ImPlot. Extensible by end users.\nIM_MSVC_RUNTIME_CHECKS_OFF\nstruct ImPlotPoint {\n    double x, y;\n    constexpr ImPlotPoint()                     : x(0.0), y(0.0) { }\n    constexpr ImPlotPoint(double _x, double _y) : x(_x), y(_y) { }\n    constexpr ImPlotPoint(const ImVec2& p)      : x((double)p.x), y((double)p.y) { }\n    double& operator[] (size_t idx)             { IM_ASSERT(idx == 0 || idx == 1); return ((double*)(void*)(char*)this)[idx]; }\n    double  operator[] (size_t idx) const       { IM_ASSERT(idx == 0 || idx == 1); return ((const double*)(const void*)(const char*)this)[idx]; }\n#ifdef IMPLOT_POINT_CLASS_EXTRA\n    IMPLOT_POINT_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h\n                                 // to convert back and forth between your math types and ImPlotPoint.\n#endif\n};\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n// Range defined by a min/max value.\nstruct ImPlotRange {\n    double Min, Max;\n    constexpr ImPlotRange()                         : Min(0.0), Max(0.0) { }\n    constexpr ImPlotRange(double _min, double _max) : Min(_min), Max(_max) { }\n    bool Contains(double value) const               { return value >= Min && value <= Max;                      }\n    double Size() const                             { return Max - Min;                                         }\n    double Clamp(double value) const                { return (value < Min) ? Min : (value > Max) ? Max : value; }\n};\n\n// Combination of two range limits for X and Y axes. Also an AABB defined by Min()/Max().\nstruct ImPlotRect {\n    ImPlotRange X, Y;\n    constexpr ImPlotRect()                                                       : X(0.0,0.0), Y(0.0,0.0) { }\n    constexpr ImPlotRect(double x_min, double x_max, double y_min, double y_max) : X(x_min, x_max), Y(y_min, y_max) { }\n    bool Contains(const ImPlotPoint& p) const                                    { return Contains(p.x, p.y);                 }\n    bool Contains(double x, double y) const                                      { return X.Contains(x) && Y.Contains(y);     }\n    ImPlotPoint Size() const                                                     { return ImPlotPoint(X.Size(), Y.Size());    }\n    ImPlotPoint Clamp(const ImPlotPoint& p)                                      { return Clamp(p.x, p.y);                    }\n    ImPlotPoint Clamp(double x, double y)                                        { return ImPlotPoint(X.Clamp(x),Y.Clamp(y)); }\n    ImPlotPoint Min() const                                                      { return ImPlotPoint(X.Min, Y.Min);          }\n    ImPlotPoint Max() const                                                      { return ImPlotPoint(X.Max, Y.Max);          }\n};\n\n// Plot style structure\nstruct ImPlotStyle {\n    // item styling variables\n    float   LineWeight;              // = 1,      item line weight in pixels\n    int     Marker;                  // = ImPlotMarker_None, marker specification\n    float   MarkerSize;              // = 4,      marker size in pixels (roughly the marker's \"radius\")\n    float   MarkerWeight;            // = 1,      outline weight of markers in pixels\n    float   FillAlpha;               // = 1,      alpha modifier applied to plot fills\n    float   ErrorBarSize;            // = 5,      error bar whisker width in pixels\n    float   ErrorBarWeight;          // = 1.5,    error bar whisker weight in pixels\n    float   DigitalBitHeight;        // = 8,      digital channels bit height (at y = 1.0f) in pixels\n    float   DigitalBitGap;           // = 4,      digital channels bit padding gap in pixels\n    // plot styling variables\n    float   PlotBorderSize;          // = 1,      line thickness of border around plot area\n    float   MinorAlpha;              // = 0.25    alpha multiplier applied to minor axis grid lines\n    ImVec2  MajorTickLen;            // = 10,10   major tick lengths for X and Y axes\n    ImVec2  MinorTickLen;            // = 5,5     minor tick lengths for X and Y axes\n    ImVec2  MajorTickSize;           // = 1,1     line thickness of major ticks\n    ImVec2  MinorTickSize;           // = 1,1     line thickness of minor ticks\n    ImVec2  MajorGridSize;           // = 1,1     line thickness of major grid lines\n    ImVec2  MinorGridSize;           // = 1,1     line thickness of minor grid lines\n    ImVec2  PlotPadding;             // = 10,10   padding between widget frame and plot area, labels, or outside legends (i.e. main padding)\n    ImVec2  LabelPadding;            // = 5,5     padding between axes labels, tick labels, and plot edge\n    ImVec2  LegendPadding;           // = 10,10   legend padding from plot edges\n    ImVec2  LegendInnerPadding;      // = 5,5     legend inner padding from legend edges\n    ImVec2  LegendSpacing;           // = 5,0     spacing between legend entries\n    ImVec2  MousePosPadding;         // = 10,10   padding between plot edge and interior mouse location text\n    ImVec2  AnnotationPadding;       // = 2,2     text padding around annotation labels\n    ImVec2  FitPadding;              // = 0,0     additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)\n    ImVec2  PlotDefaultSize;         // = 400,300 default size used when ImVec2(0,0) is passed to BeginPlot\n    ImVec2  PlotMinSize;             // = 200,150 minimum size plot frame can be when shrunk\n    // style colors\n    ImVec4  Colors[ImPlotCol_COUNT]; // Array of styling colors. Indexable with ImPlotCol_ enums.\n    // colormap\n    ImPlotColormap Colormap;         // The current colormap. Set this to either an ImPlotColormap_ enum or an index returned by AddColormap.\n    // settings/flags\n    bool    UseLocalTime;            // = false,  axis labels will be formatted for your timezone when ImPlotAxisFlag_Time is enabled\n    bool    UseISO8601;              // = false,  dates will be formatted according to ISO 8601 where applicable (e.g. YYYY-MM-DD, YYYY-MM, --MM-DD, etc.)\n    bool    Use24HourClock;          // = false,  times will be formatted using a 24 hour clock\n    IMPLOT_API ImPlotStyle();\n};\n\n// Support for legacy versions\n#if (IMGUI_VERSION_NUM < 18716) // Renamed in 1.88\n#define ImGuiMod_None       0\n#define ImGuiMod_Ctrl       ImGuiKeyModFlags_Ctrl\n#define ImGuiMod_Shift      ImGuiKeyModFlags_Shift\n#define ImGuiMod_Alt        ImGuiKeyModFlags_Alt\n#define ImGuiMod_Super      ImGuiKeyModFlags_Super\n#elif (IMGUI_VERSION_NUM < 18823) // Renamed in 1.89, sorry\n#define ImGuiMod_None       0\n#define ImGuiMod_Ctrl       ImGuiModFlags_Ctrl\n#define ImGuiMod_Shift      ImGuiModFlags_Shift\n#define ImGuiMod_Alt        ImGuiModFlags_Alt\n#define ImGuiMod_Super      ImGuiModFlags_Super\n#endif\n\n// Input mapping structure. Default values listed. See also MapInputDefault, MapInputReverse.\nstruct ImPlotInputMap {\n    ImGuiMouseButton Pan;           // LMB    enables panning when held,\n    int              PanMod;        // none   optional modifier that must be held for panning/fitting\n    ImGuiMouseButton Fit;           // LMB    initiates fit when double clicked\n    ImGuiMouseButton Select;        // RMB    begins box selection when pressed and confirms selection when released\n    ImGuiMouseButton SelectCancel;  // LMB    cancels active box selection when pressed; cannot be same as Select\n    int              SelectMod;     // none   optional modifier that must be held for box selection\n    int              SelectHorzMod; // Alt    expands active box selection horizontally to plot edge when held\n    int              SelectVertMod; // Shift  expands active box selection vertically to plot edge when held\n    ImGuiMouseButton Menu;          // RMB    opens context menus (if enabled) when clicked\n    int              OverrideMod;   // Ctrl   when held, all input is ignored; used to enable axis/plots as DND sources\n    int              ZoomMod;       // none   optional modifier that must be held for scroll wheel zooming\n    float            ZoomRate;      // 0.1f   zoom rate for scroll (e.g. 0.1f = 10% plot range every scroll click); make negative to invert\n    IMPLOT_API ImPlotInputMap();\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Callbacks\n//-----------------------------------------------------------------------------\n\n// Callback signature for axis tick label formatter.\ntypedef int (*ImPlotFormatter)(double value, char* buff, int size, void* user_data);\n\n// Callback signature for data getter.\ntypedef ImPlotPoint (*ImPlotGetter)(int idx, void* user_data);\n\n// Callback signature for axis transform.\ntypedef double (*ImPlotTransform)(double value, void* user_data);\n\nnamespace ImPlot {\n\n//-----------------------------------------------------------------------------\n// [SECTION] Contexts\n//-----------------------------------------------------------------------------\n\n// Creates a new ImPlot context. Call this after ImGui::CreateContext.\nIMPLOT_API ImPlotContext* CreateContext();\n// Destroys an ImPlot context. Call this before ImGui::DestroyContext. nullptr = destroy current context.\nIMPLOT_API void DestroyContext(ImPlotContext* ctx = nullptr);\n// Returns the current ImPlot context. nullptr if no context has ben set.\nIMPLOT_API ImPlotContext* GetCurrentContext();\n// Sets the current ImPlot context.\nIMPLOT_API void SetCurrentContext(ImPlotContext* ctx);\n\n// Sets the current **ImGui** context. This is ONLY necessary if you are compiling\n// ImPlot as a DLL (not recommended) separate from your ImGui compilation. It\n// sets the global variable GImGui, which is not shared across DLL boundaries.\n// See GImGui documentation in imgui.cpp for more details.\nIMPLOT_API void SetImGuiContext(ImGuiContext* ctx);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Begin/End Plot\n//-----------------------------------------------------------------------------\n\n// Starts a 2D plotting context. If this function returns true, EndPlot() MUST\n// be called! You are encouraged to use the following convention:\n//\n// if (BeginPlot(...)) {\n//     PlotLine(...);\n//     ...\n//     EndPlot();\n// }\n//\n// Important notes:\n//\n// - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID\n//   collisions or don't want to display a title in the plot, use double hashes\n//   (e.g. \"MyPlot##HiddenIdText\" or \"##NoTitle\").\n// - #size is the **frame** size of the plot widget, not the plot area. The default\n//   size of plots (i.e. when ImVec2(0,0)) can be modified in your ImPlotStyle.\nIMPLOT_API bool BeginPlot(const char* title_id, const ImVec2& size=ImVec2(-1,0), ImPlotFlags flags=0);\n\n// Only call EndPlot() if BeginPlot() returns true! Typically called at the end\n// of an if statement conditioned on BeginPlot(). See example above.\nIMPLOT_API void EndPlot();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Begin/End Subplots\n//-----------------------------------------------------------------------------\n\n// Starts a subdivided plotting context. If the function returns true,\n// EndSubplots() MUST be called! Call BeginPlot/EndPlot AT MOST [rows*cols]\n// times in  between the begining and end of the subplot context. Plots are\n// added in row major order.\n//\n// Example:\n//\n// if (BeginSubplots(\"My Subplot\",2,3,ImVec2(800,400)) {\n//     for (int i = 0; i < 6; ++i) {\n//         if (BeginPlot(...)) {\n//             ImPlot::PlotLine(...);\n//             ...\n//             EndPlot();\n//         }\n//     }\n//     EndSubplots();\n// }\n//\n// Produces:\n//\n// [0] | [1] | [2]\n// ----|-----|----\n// [3] | [4] | [5]\n//\n// Important notes:\n//\n// - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID\n//   collisions or don't want to display a title in the plot, use double hashes\n//   (e.g. \"MySubplot##HiddenIdText\" or \"##NoTitle\").\n// - #rows and #cols must be greater than 0.\n// - #size is the size of the entire grid of subplots, not the individual plots\n// - #row_ratios and #col_ratios must have AT LEAST #rows and #cols elements,\n//   respectively. These are the sizes of the rows and columns expressed in ratios.\n//   If the user adjusts the dimensions, the arrays are updated with new ratios.\n//\n// Important notes regarding BeginPlot from inside of BeginSubplots:\n//\n// - The #title_id parameter of _BeginPlot_ (see above) does NOT have to be\n//   unique when called inside of a subplot context. Subplot IDs are hashed\n//   for your convenience so you don't have call PushID or generate unique title\n//   strings. Simply pass an empty string to BeginPlot unless you want to title\n//   each subplot.\n// - The #size parameter of _BeginPlot_ (see above) is ignored when inside of a\n//   subplot context. The actual size of the subplot will be based on the\n//   #size value you pass to _BeginSubplots_ and #row/#col_ratios if provided.\n\nIMPLOT_API bool BeginSubplots(const char* title_id,\n                             int rows,\n                             int cols,\n                             const ImVec2& size,\n                             ImPlotSubplotFlags flags = 0,\n                             float* row_ratios        = nullptr,\n                             float* col_ratios        = nullptr);\n\n// Only call EndSubplots() if BeginSubplots() returns true! Typically called at the end\n// of an if statement conditioned on BeginSublots(). See example above.\nIMPLOT_API void EndSubplots();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Setup\n//-----------------------------------------------------------------------------\n\n// The following API allows you to setup and customize various aspects of the\n// current plot. The functions should be called immediately after BeginPlot\n// and before any other API calls. Typical usage is as follows:\n\n// if (BeginPlot(...)) {                     1) begin a new plot\n//     SetupAxis(ImAxis_X1, \"My X-Axis\");    2) make Setup calls\n//     SetupAxis(ImAxis_Y1, \"My Y-Axis\");\n//     SetupLegend(ImPlotLocation_North);\n//     ...\n//     SetupFinish();                        3) [optional] explicitly finish setup\n//     PlotLine(...);                        4) plot items\n//     ...\n//     EndPlot();                            5) end the plot\n// }\n//\n// Important notes:\n//\n// - Always call Setup code at the top of your BeginPlot conditional statement.\n// - Setup is locked once you start plotting or explicitly call SetupFinish.\n//   Do NOT call Setup code after you begin plotting or after you make\n//   any non-Setup API calls (e.g. utils like PlotToPixels also lock Setup)\n// - Calling SetupFinish is OPTIONAL, but probably good practice. If you do not\n//   call it yourself, then the first subsequent plotting or utility function will\n//   call it for you.\n\n// Enables an axis or sets the label and/or flags for an existing axis. Leave #label = nullptr for no label.\nIMPLOT_API void SetupAxis(ImAxis axis, const char* label=nullptr, ImPlotAxisFlags flags=0);\n// Sets an axis range limits. If ImPlotCond_Always is used, the axes limits will be locked. Inversion with v_min > v_max is not supported; use SetupAxisLimits instead.\nIMPLOT_API void SetupAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond_Once);\n// Links an axis range limits to external values. Set to nullptr for no linkage. The pointer data must remain valid until EndPlot.\nIMPLOT_API void SetupAxisLinks(ImAxis axis, double* link_min, double* link_max);\n// Sets the format of numeric axis labels via formater specifier (default=\"%g\"). Formated values will be double (i.e. use %f).\nIMPLOT_API void SetupAxisFormat(ImAxis axis, const char* fmt);\n// Sets the format of numeric axis labels via formatter callback. Given #value, write a label into #buff. Optionally pass user data.\nIMPLOT_API void SetupAxisFormat(ImAxis axis, ImPlotFormatter formatter, void* data=nullptr);\n// Sets an axis' ticks and optionally the labels. To keep the default ticks, set #keep_default=true.\nIMPLOT_API void SetupAxisTicks(ImAxis axis, const double* values, int n_ticks, const char* const labels[]=nullptr, bool keep_default=false);\n// Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true.\nIMPLOT_API void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, const char* const labels[]=nullptr, bool keep_default=false);\n// Sets an axis' scale using built-in options.\nIMPLOT_API void SetupAxisScale(ImAxis axis, ImPlotScale scale);\n// Sets an axis' scale using user supplied forward and inverse transfroms.\nIMPLOT_API void SetupAxisScale(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse, void* data=nullptr);\n// Sets an axis' limits constraints.\nIMPLOT_API void SetupAxisLimitsConstraints(ImAxis axis, double v_min, double v_max);\n// Sets an axis' zoom constraints.\nIMPLOT_API void SetupAxisZoomConstraints(ImAxis axis, double z_min, double z_max);\n\n// Sets the label and/or flags for primary X and Y axes (shorthand for two calls to SetupAxis).\nIMPLOT_API void SetupAxes(const char* x_label, const char* y_label, ImPlotAxisFlags x_flags=0, ImPlotAxisFlags y_flags=0);\n// Sets the primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).\nIMPLOT_API void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond_Once);\n\n// Sets up the plot legend. This can also be called immediately after BeginSubplots when using ImPlotSubplotFlags_ShareItems.\nIMPLOT_API void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags=0);\n// Set the location of the current plot's mouse position text (default = South|East).\nIMPLOT_API void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags=0);\n\n// Explicitly finalize plot setup. Once you call this, you cannot make anymore Setup calls for the current plot!\n// Note that calling this function is OPTIONAL; it will be called by the first subsequent setup-locking API call.\nIMPLOT_API void SetupFinish();\n\n//-----------------------------------------------------------------------------\n// [SECTION] SetNext\n//-----------------------------------------------------------------------------\n\n// Though you should default to the `Setup` API above, there are some scenarios\n// where (re)configuring a plot or axis before `BeginPlot` is needed (e.g. if\n// using a preceding button or slider widget to change the plot limits). In\n// this case, you can use the `SetNext` API below. While this is not as feature\n// rich as the Setup API, most common needs are provided. These functions can be\n// called anwhere except for inside of `Begin/EndPlot`. For example:\n\n// if (ImGui::Button(\"Center Plot\"))\n//     ImPlot::SetNextPlotLimits(-1,1,-1,1);\n// if (ImPlot::BeginPlot(...)) {\n//     ...\n//     ImPlot::EndPlot();\n// }\n//\n// Important notes:\n//\n// - You must still enable non-default axes with SetupAxis for these functions\n//   to work properly.\n\n// Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.\nIMPLOT_API void SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond = ImPlotCond_Once);\n// Links an upcoming axis range limits to external values. Set to nullptr for no linkage. The pointer data must remain valid until EndPlot!\nIMPLOT_API void SetNextAxisLinks(ImAxis axis, double* link_min, double* link_max);\n// Set an upcoming axis to auto fit to its data.\nIMPLOT_API void SetNextAxisToFit(ImAxis axis);\n\n// Sets the upcoming primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).\nIMPLOT_API void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond = ImPlotCond_Once);\n// Sets all upcoming axes to auto fit to their data.\nIMPLOT_API void SetNextAxesToFit();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Items\n//-----------------------------------------------------------------------------\n\n// The main plotting API is provied below. Call these functions between\n// Begin/EndPlot and after any Setup API calls. Each plots data on the current\n// x and y axes, which can be changed with `SetAxis/Axes`.\n//\n// The templated functions are explicitly instantiated in implot_items.cpp.\n// They are not intended to be used generically with custom types. You will get\n// a linker error if you try! All functions support the following scalar types:\n//\n// float, double, ImS8, ImU8, ImS16, ImU16, ImS32, ImU32, ImS64, ImU64\n//\n//\n// If you need to plot custom or non-homogenous data you have a few options:\n//\n// 1. If your data is a simple struct/class (e.g. Vector2f), you can use striding.\n//    This is the most performant option if applicable.\n//\n//    struct Vector2f { float X, Y; };\n//    ...\n//    Vector2f data[42];\n//    ImPlot::PlotLine(\"line\", &data[0].x, &data[0].y, 42, 0, 0, sizeof(Vector2f));\n//\n// 2. Write a custom getter C function or C++ lambda and pass it and optionally your data to\n//    an ImPlot function post-fixed with a G (e.g. PlotScatterG). This has a slight performance\n//    cost, but probably not enough to worry about unless your data is very large. Examples:\n//\n//    ImPlotPoint MyDataGetter(int idx, void* data) {\n//        MyData* my_data = (MyData*)data;\n//        ImPlotPoint p;\n//        p.x = my_data->GetTime(idx);\n//        p.y = my_data->GetValue(idx);\n//        return p\n//    }\n//    ...\n//    auto my_lambda = [](int idx, void*) {\n//        double t = idx / 999.0;\n//        return ImPlotPoint(t, 0.5+0.5*std::sin(2*PI*10*t));\n//    };\n//    ...\n//    if (ImPlot::BeginPlot(\"MyPlot\")) {\n//        MyData my_data;\n//        ImPlot::PlotScatterG(\"scatter\", MyDataGetter, &my_data, my_data.Size());\n//        ImPlot::PlotLineG(\"line\", my_lambda, nullptr, 1000);\n//        ImPlot::EndPlot();\n//    }\n//\n// NB: All types are converted to double before plotting. You may lose information\n// if you try plotting extremely large 64-bit integral types. Proceed with caution!\n\n// Plots a standard 2D line plot.\nIMPLOT_TMP void PlotLine(const char* label_id, const T* values, int count, double xscale=1, double xstart=0, ImPlotLineFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotLine(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotLineG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotLineFlags flags=0);\n\n// Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.\nIMPLOT_TMP void PlotScatter(const char* label_id, const T* values, int count, double xscale=1, double xstart=0, ImPlotScatterFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotScatter(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotScatterG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotScatterFlags flags=0);\n\n// Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i]\nIMPLOT_TMP void PlotStairs(const char* label_id, const T* values, int count, double xscale=1, double xstart=0, ImPlotStairsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotStairs(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotStairsG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotStairsFlags flags=0);\n\n// Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.\nIMPLOT_TMP void PlotShaded(const char* label_id, const T* values, int count, double yref=0, double xscale=1, double xstart=0, ImPlotShadedFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotShaded(const char* label_id, const T* xs, const T* ys, int count, double yref=0, ImPlotShadedFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotShaded(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotShadedG(const char* label_id, ImPlotGetter getter1, void* data1, ImPlotGetter getter2, void* data2, int count, ImPlotShadedFlags flags=0);\n\n// Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.\nIMPLOT_TMP void PlotBars(const char* label_id, const T* values, int count, double bar_size=0.67, double shift=0, ImPlotBarsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotBars(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotBarsG(const char* label_id, ImPlotGetter getter, void* data, int count, double bar_size, ImPlotBarsFlags flags=0);\n\n// Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.\nIMPLOT_TMP void PlotBarGroups(const char* const label_ids[], const T* values, int item_count, int group_count, double group_size=0.67, double shift=0, ImPlotBarGroupsFlags flags=0);\n\n// Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.\nIMPLOT_TMP void PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags=0, int offset=0, int stride=sizeof(T));\n\n// Plots stems. Vertical by default.\nIMPLOT_TMP void PlotStems(const char* label_id, const T* values, int count, double ref=0, double scale=1, double start=0, ImPlotStemsFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_TMP void PlotStems(const char* label_id, const T* xs, const T* ys, int count, double ref=0, ImPlotStemsFlags flags=0, int offset=0, int stride=sizeof(T));\n\n// Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).\nIMPLOT_TMP void PlotInfLines(const char* label_id, const T* values, int count, ImPlotInfLinesFlags flags=0, int offset=0, int stride=sizeof(T));\n\n// Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to nullptr for no labels.\nIMPLOT_TMP void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data=nullptr, double angle0=90, ImPlotPieChartFlags flags=0);\nIMPLOT_TMP void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, const char* label_fmt=\"%.1f\", double angle0=90, ImPlotPieChartFlags flags=0);\n\n// Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to nullptr for no labels.\nIMPLOT_TMP void PlotHeatmap(const char* label_id, const T* values, int rows, int cols, double scale_min=0, double scale_max=0, const char* label_fmt=\"%.1f\", const ImPlotPoint& bounds_min=ImPlotPoint(0,0), const ImPlotPoint& bounds_max=ImPlotPoint(1,1), ImPlotHeatmapFlags flags=0);\n\n// Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.\n// Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.\nIMPLOT_TMP double PlotHistogram(const char* label_id, const T* values, int count, int bins=ImPlotBin_Sturges, double bar_scale=1.0, ImPlotRange range=ImPlotRange(), ImPlotHistogramFlags flags=0);\n\n// Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of\n// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.\nIMPLOT_TMP double PlotHistogram2D(const char* label_id, const T* xs, const T* ys, int count, int x_bins=ImPlotBin_Sturges, int y_bins=ImPlotBin_Sturges, ImPlotRect range=ImPlotRect(), ImPlotHistogramFlags flags=0);\n\n// Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.\nIMPLOT_TMP void PlotDigital(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags=0, int offset=0, int stride=sizeof(T));\nIMPLOT_API void PlotDigitalG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotDigitalFlags flags=0);\n\n// Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).\nIMPLOT_API void PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, const ImVec2& uv0=ImVec2(0,0), const ImVec2& uv1=ImVec2(1,1), const ImVec4& tint_col=ImVec4(1,1,1,1), ImPlotImageFlags flags=0);\n\n// Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).\nIMPLOT_API void PlotText(const char* text, double x, double y, const ImVec2& pix_offset=ImVec2(0,0), ImPlotTextFlags flags=0);\n\n// Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line)\nIMPLOT_API void PlotDummy(const char* label_id, ImPlotDummyFlags flags=0);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Tools\n//-----------------------------------------------------------------------------\n\n// The following can be used to render interactive elements and/or annotations.\n// Like the item plotting functions above, they apply to the current x and y\n// axes, which can be changed with `SetAxis/SetAxes`. These functions return true\n// when user interaction causes the provided coordinates to change. Additional\n// user interactions can be retrieved through the optional output parameters.\n\n// Shows a draggable point at x,y. #col defaults to ImGuiCol_Text.\nIMPLOT_API bool DragPoint(int id, double* x, double* y, const ImVec4& col, float size = 4, ImPlotDragToolFlags flags = 0, bool* out_clicked = nullptr, bool* out_hovered = nullptr, bool* held = nullptr);\n// Shows a draggable vertical guide line at an x-value. #col defaults to ImGuiCol_Text.\nIMPLOT_API bool DragLineX(int id, double* x, const ImVec4& col, float thickness = 1, ImPlotDragToolFlags flags = 0, bool* out_clicked = nullptr, bool* out_hovered = nullptr, bool* held = nullptr);\n// Shows a draggable horizontal guide line at a y-value. #col defaults to ImGuiCol_Text.\nIMPLOT_API bool DragLineY(int id, double* y, const ImVec4& col, float thickness = 1, ImPlotDragToolFlags flags = 0, bool* out_clicked = nullptr, bool* out_hovered = nullptr, bool* held = nullptr);\n// Shows a draggable and resizeable rectangle.\nIMPLOT_API bool DragRect(int id, double* x1, double* y1, double* x2, double* y2, const ImVec4& col, ImPlotDragToolFlags flags = 0, bool* out_clicked = nullptr, bool* out_hovered = nullptr, bool* held = nullptr);\n\n// Shows an annotation callout at a chosen point. Clamping keeps annotations in the plot area. Annotations are always rendered on top.\nIMPLOT_API void Annotation(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, bool round = false);\nIMPLOT_API void Annotation(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, const char* fmt, ...)           IM_FMTARGS(6);\nIMPLOT_API void AnnotationV(double x, double y, const ImVec4& col, const ImVec2& pix_offset, bool clamp, const char* fmt, va_list args) IM_FMTLIST(6);\n\n// Shows a x-axis tag at the specified coordinate value.\nIMPLOT_API void TagX(double x, const ImVec4& col, bool round = false);\nIMPLOT_API void TagX(double x, const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(3);\nIMPLOT_API void TagXV(double x, const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(3);\n\n// Shows a y-axis tag at the specified coordinate value.\nIMPLOT_API void TagY(double y, const ImVec4& col, bool round = false);\nIMPLOT_API void TagY(double y, const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(3);\nIMPLOT_API void TagYV(double y, const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(3);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Utils\n//-----------------------------------------------------------------------------\n\n// Select which axis/axes will be used for subsequent plot elements.\nIMPLOT_API void SetAxis(ImAxis axis);\nIMPLOT_API void SetAxes(ImAxis x_axis, ImAxis y_axis);\n\n// Convert pixels to a position in the current plot's coordinate system. Passing IMPLOT_AUTO uses the current axes.\nIMPLOT_API ImPlotPoint PixelsToPlot(const ImVec2& pix, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\nIMPLOT_API ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\n\n// Convert a position in the current plot's coordinate system to pixels. Passing IMPLOT_AUTO uses the current axes.\nIMPLOT_API ImVec2 PlotToPixels(const ImPlotPoint& plt, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\nIMPLOT_API ImVec2 PlotToPixels(double x, double y, ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\n\n// Get the current Plot position (top-left) in pixels.\nIMPLOT_API ImVec2 GetPlotPos();\n// Get the curent Plot size in pixels.\nIMPLOT_API ImVec2 GetPlotSize();\n\n// Returns the mouse position in x,y coordinates of the current plot. Passing IMPLOT_AUTO uses the current axes.\nIMPLOT_API ImPlotPoint GetPlotMousePos(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\n// Returns the current plot axis range.\nIMPLOT_API ImPlotRect GetPlotLimits(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\n\n// Returns true if the plot area in the current plot is hovered.\nIMPLOT_API bool IsPlotHovered();\n// Returns true if the axis label area in the current plot is hovered.\nIMPLOT_API bool IsAxisHovered(ImAxis axis);\n// Returns true if the bounding frame of a subplot is hovered.\nIMPLOT_API bool IsSubplotsHovered();\n\n// Returns true if the current plot is being box selected.\nIMPLOT_API bool IsPlotSelected();\n// Returns the current plot box selection bounds. Passing IMPLOT_AUTO uses the current axes.\nIMPLOT_API ImPlotRect GetPlotSelection(ImAxis x_axis = IMPLOT_AUTO, ImAxis y_axis = IMPLOT_AUTO);\n// Cancels a the current plot box selection.\nIMPLOT_API void CancelPlotSelection();\n\n// Hides or shows the next plot item (i.e. as if it were toggled from the legend).\n// Use ImPlotCond_Always if you need to forcefully set this every frame.\nIMPLOT_API void HideNextItem(bool hidden = true, ImPlotCond cond = ImPlotCond_Once);\n\n// Use the following around calls to Begin/EndPlot to align l/r/t/b padding.\n// Consider using Begin/EndSubplots first. They are more feature rich and\n// accomplish the same behaviour by default. The functions below offer lower\n// level control of plot alignment.\n\n// Align axis padding over multiple plots in a single row or column. #group_id must\n// be unique. If this function returns true, EndAlignedPlots() must be called.\nIMPLOT_API bool BeginAlignedPlots(const char* group_id, bool vertical = true);\n// Only call EndAlignedPlots() if BeginAlignedPlots() returns true!\nIMPLOT_API void EndAlignedPlots();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Legend Utils\n//-----------------------------------------------------------------------------\n\n// Begin a popup for a legend entry.\nIMPLOT_API bool BeginLegendPopup(const char* label_id, ImGuiMouseButton mouse_button=1);\n// End a popup for a legend entry.\nIMPLOT_API void EndLegendPopup();\n// Returns true if a plot item legend entry is hovered.\nIMPLOT_API bool IsLegendEntryHovered(const char* label_id);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Drag and Drop\n//-----------------------------------------------------------------------------\n\n// Turns the current plot's plotting area into a drag and drop target. Don't forget to call EndDragDropTarget!\nIMPLOT_API bool BeginDragDropTargetPlot();\n// Turns the current plot's X-axis into a drag and drop target. Don't forget to call EndDragDropTarget!\nIMPLOT_API bool BeginDragDropTargetAxis(ImAxis axis);\n// Turns the current plot's legend into a drag and drop target. Don't forget to call EndDragDropTarget!\nIMPLOT_API bool BeginDragDropTargetLegend();\n// Ends a drag and drop target (currently just an alias for ImGui::EndDragDropTarget).\nIMPLOT_API void EndDragDropTarget();\n\n// NB: By default, plot and axes drag and drop *sources* require holding the Ctrl modifier to initiate the drag.\n// You can change the modifier if desired. If ImGuiMod_None is provided, the axes will be locked from panning.\n\n// Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!\nIMPLOT_API bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags=0);\n// Turns the current plot's X-axis into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!\nIMPLOT_API bool BeginDragDropSourceAxis(ImAxis axis, ImGuiDragDropFlags flags=0);\n// Turns an item in the current plot's legend into drag and drop source. Don't forget to call EndDragDropSource!\nIMPLOT_API bool BeginDragDropSourceItem(const char* label_id, ImGuiDragDropFlags flags=0);\n// Ends a drag and drop source (currently just an alias for ImGui::EndDragDropSource).\nIMPLOT_API void EndDragDropSource();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Styling\n//-----------------------------------------------------------------------------\n\n// Styling colors in ImPlot works similarly to styling colors in ImGui, but\n// with one important difference. Like ImGui, all style colors are stored in an\n// indexable array in ImPlotStyle. You can permanently modify these values through\n// GetStyle().Colors, or temporarily modify them with Push/Pop functions below.\n// However, by default all style colors in ImPlot default to a special color\n// IMPLOT_AUTO_COL. The behavior of this color depends upon the style color to\n// which it as applied:\n//\n//     1) For style colors associated with plot items (e.g. ImPlotCol_Line),\n//        IMPLOT_AUTO_COL tells ImPlot to color the item with the next unused\n//        color in the current colormap. Thus, every item will have a different\n//        color up to the number of colors in the colormap, at which point the\n//        colormap will roll over. For most use cases, you should not need to\n//        set these style colors to anything but IMPLOT_COL_AUTO; you are\n//        probably better off changing the current colormap. However, if you\n//        need to explicitly color a particular item you may either Push/Pop\n//        the style color around the item in question, or use the SetNextXXXStyle\n//        API below. If you permanently set one of these style colors to a specific\n//        color, or forget to call Pop, then all subsequent items will be styled\n//        with the color you set.\n//\n//     2) For style colors associated with plot styling (e.g. ImPlotCol_PlotBg),\n//        IMPLOT_AUTO_COL tells ImPlot to set that color from color data in your\n//        **ImGuiStyle**. The ImGuiCol_ that these style colors default to are\n//        detailed above, and in general have been mapped to produce plots visually\n//        consistent with your current ImGui style. Of course, you are free to\n//        manually set these colors to whatever you like, and further can Push/Pop\n//        them around individual plots for plot-specific styling (e.g. coloring axes).\n\n// Provides access to plot style structure for permanant modifications to colors, sizes, etc.\nIMPLOT_API ImPlotStyle& GetStyle();\n\n// Style plot colors for current ImGui style (default).\nIMPLOT_API void StyleColorsAuto(ImPlotStyle* dst = nullptr);\n// Style plot colors for ImGui \"Classic\".\nIMPLOT_API void StyleColorsClassic(ImPlotStyle* dst = nullptr);\n// Style plot colors for ImGui \"Dark\".\nIMPLOT_API void StyleColorsDark(ImPlotStyle* dst = nullptr);\n// Style plot colors for ImGui \"Light\".\nIMPLOT_API void StyleColorsLight(ImPlotStyle* dst = nullptr);\n\n// Use PushStyleX to temporarily modify your ImPlotStyle. The modification\n// will last until the matching call to PopStyleX. You MUST call a pop for\n// every push, otherwise you will leak memory! This behaves just like ImGui.\n\n// Temporarily modify a style color. Don't forget to call PopStyleColor!\nIMPLOT_API void PushStyleColor(ImPlotCol idx, ImU32 col);\nIMPLOT_API void PushStyleColor(ImPlotCol idx, const ImVec4& col);\n// Undo temporary style color modification(s). Undo multiple pushes at once by increasing count.\nIMPLOT_API void PopStyleColor(int count = 1);\n\n// Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!\nIMPLOT_API void PushStyleVar(ImPlotStyleVar idx, float val);\n// Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!\nIMPLOT_API void PushStyleVar(ImPlotStyleVar idx, int val);\n// Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!\nIMPLOT_API void PushStyleVar(ImPlotStyleVar idx, const ImVec2& val);\n// Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count.\nIMPLOT_API void PopStyleVar(int count = 1);\n\n// The following can be used to modify the style of the next plot item ONLY. They do\n// NOT require calls to PopStyleX. Leave style attributes you don't want modified to\n// IMPLOT_AUTO or IMPLOT_AUTO_COL. Automatic styles will be deduced from the current\n// values in your ImPlotStyle or from Colormap data.\n\n// Set the line color and weight for the next item only.\nIMPLOT_API void SetNextLineStyle(const ImVec4& col = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO);\n// Set the fill color for the next item only.\nIMPLOT_API void SetNextFillStyle(const ImVec4& col = IMPLOT_AUTO_COL, float alpha_mod = IMPLOT_AUTO);\n// Set the marker style for the next item only.\nIMPLOT_API void SetNextMarkerStyle(ImPlotMarker marker = IMPLOT_AUTO, float size = IMPLOT_AUTO, const ImVec4& fill = IMPLOT_AUTO_COL, float weight = IMPLOT_AUTO, const ImVec4& outline = IMPLOT_AUTO_COL);\n// Set the error bar style for the next item only.\nIMPLOT_API void SetNextErrorBarStyle(const ImVec4& col = IMPLOT_AUTO_COL, float size = IMPLOT_AUTO, float weight = IMPLOT_AUTO);\n\n// Gets the last item primary color (i.e. its legend icon color)\nIMPLOT_API ImVec4 GetLastItemColor();\n\n// Returns the null terminated string name for an ImPlotCol.\nIMPLOT_API const char* GetStyleColorName(ImPlotCol idx);\n// Returns the null terminated string name for an ImPlotMarker.\nIMPLOT_API const char* GetMarkerName(ImPlotMarker idx);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Colormaps\n//-----------------------------------------------------------------------------\n\n// Item styling is based on colormaps when the relevant ImPlotCol_XXX is set to\n// IMPLOT_AUTO_COL (default). Several built-in colormaps are available. You can\n// add and then push/pop your own colormaps as well. To permanently set a colormap,\n// modify the Colormap index member of your ImPlotStyle.\n\n// Colormap data will be ignored and a custom color will be used if you have done one of the following:\n//     1) Modified an item style color in your ImPlotStyle to anything other than IMPLOT_AUTO_COL.\n//     2) Pushed an item style color using PushStyleColor().\n//     3) Set the next item style with a SetNextXXXStyle function.\n\n// Add a new colormap. The color data will be copied. The colormap can be used by pushing either the returned index or the\n// string name with PushColormap. The colormap name must be unique and the size must be greater than 1. You will receive\n// an assert otherwise! By default colormaps are considered to be qualitative (i.e. discrete). If you want to create a\n// continuous colormap, set #qual=false. This will treat the colors you provide as keys, and ImPlot will build a linearly\n// interpolated lookup table. The memory footprint of this table will be exactly ((size-1)*255+1)*4 bytes.\nIMPLOT_API ImPlotColormap AddColormap(const char* name, const ImVec4* cols, int size, bool qual=true);\nIMPLOT_API ImPlotColormap AddColormap(const char* name, const ImU32*  cols, int size, bool qual=true);\n\n// Returns the number of available colormaps (i.e. the built-in + user-added count).\nIMPLOT_API int GetColormapCount();\n// Returns a null terminated string name for a colormap given an index. Returns nullptr if index is invalid.\nIMPLOT_API const char* GetColormapName(ImPlotColormap cmap);\n// Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid.\nIMPLOT_API ImPlotColormap GetColormapIndex(const char* name);\n\n// Temporarily switch to one of the built-in (i.e. ImPlotColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to call PopColormap!\nIMPLOT_API void PushColormap(ImPlotColormap cmap);\n// Push a colormap by string name. Use built-in names such as \"Default\", \"Deep\", \"Jet\", etc. or a string you provided to AddColormap. Don't forget to call PopColormap!\nIMPLOT_API void PushColormap(const char* name);\n// Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count.\nIMPLOT_API void PopColormap(int count = 1);\n\n// Returns the next color from the current colormap and advances the colormap for the current plot.\n// Can also be used with no return value to skip colors if desired. You need to call this between Begin/EndPlot!\nIMPLOT_API ImVec4 NextColormapColor();\n\n// Colormap utils. If cmap = IMPLOT_AUTO (default), the current colormap is assumed.\n// Pass an explicit colormap index (built-in or user-added) to specify otherwise.\n\n// Returns the size of a colormap.\nIMPLOT_API int GetColormapSize(ImPlotColormap cmap = IMPLOT_AUTO);\n// Returns a color from a colormap given an index >= 0 (modulo will be performed).\nIMPLOT_API ImVec4 GetColormapColor(int idx, ImPlotColormap cmap = IMPLOT_AUTO);\n// Sample a color from the current colormap given t between 0 and 1.\nIMPLOT_API ImVec4 SampleColormap(float t, ImPlotColormap cmap = IMPLOT_AUTO);\n\n// Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. \"##NoLabel\"). If scale_min > scale_max, the scale to color mapping will be reversed.\nIMPLOT_API void ColormapScale(const char* label, double scale_min, double scale_max, const ImVec2& size = ImVec2(0,0), const char* format = \"%g\", ImPlotColormapScaleFlags flags = 0, ImPlotColormap cmap = IMPLOT_AUTO);\n// Shows a horizontal slider with a colormap gradient background. Optionally returns the color sampled at t in [0 1].\nIMPLOT_API bool ColormapSlider(const char* label, float* t, ImVec4* out = nullptr, const char* format = \"\", ImPlotColormap cmap = IMPLOT_AUTO);\n// Shows a button with a colormap gradient brackground.\nIMPLOT_API bool ColormapButton(const char* label, const ImVec2& size = ImVec2(0,0), ImPlotColormap cmap = IMPLOT_AUTO);\n\n// When items in a plot sample their color from a colormap, the color is cached and does not change\n// unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted,\n// item colors will NOT update. If you need item colors to resample the new colormap, then use this\n// function to bust the cached colors. If #plot_title_id is nullptr, then every item in EVERY existing plot\n// will be cache busted. Otherwise only the plot specified by #plot_title_id will be busted. For the\n// latter, this function must be called in the same ImGui ID scope that the plot is in. You should rarely if ever\n// need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).\nIMPLOT_API void BustColorCache(const char* plot_title_id = nullptr);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Input Mapping\n//-----------------------------------------------------------------------------\n\n// Provides access to input mapping structure for permanant modifications to controls for pan, select, etc.\nIMPLOT_API ImPlotInputMap& GetInputMap();\n\n// Default input mapping: pan = LMB drag, box select = RMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.\nIMPLOT_API void MapInputDefault(ImPlotInputMap* dst = nullptr);\n// Reverse input mapping: pan = RMB drag, box select = LMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.\nIMPLOT_API void MapInputReverse(ImPlotInputMap* dst = nullptr);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Miscellaneous\n//-----------------------------------------------------------------------------\n\n// Render icons similar to those that appear in legends (nifty for data lists).\nIMPLOT_API void ItemIcon(const ImVec4& col);\nIMPLOT_API void ItemIcon(ImU32 col);\nIMPLOT_API void ColormapIcon(ImPlotColormap cmap);\n\n// Get the plot draw list for custom rendering to the current plot area. Call between Begin/EndPlot.\nIMPLOT_API ImDrawList* GetPlotDrawList();\n// Push clip rect for rendering to current plot area. The rect can be expanded or contracted by #expand pixels. Call between Begin/EndPlot.\nIMPLOT_API void PushPlotClipRect(float expand=0);\n// Pop plot clip rect. Call between Begin/EndPlot.\nIMPLOT_API void PopPlotClipRect();\n\n// Shows ImPlot style selector dropdown menu.\nIMPLOT_API bool ShowStyleSelector(const char* label);\n// Shows ImPlot colormap selector dropdown menu.\nIMPLOT_API bool ShowColormapSelector(const char* label);\n// Shows ImPlot input map selector dropdown menu.\nIMPLOT_API bool ShowInputMapSelector(const char* label);\n// Shows ImPlot style editor block (not a window).\nIMPLOT_API void ShowStyleEditor(ImPlotStyle* ref = nullptr);\n// Add basic help/info block for end users (not a window).\nIMPLOT_API void ShowUserGuide();\n// Shows ImPlot metrics/debug information window.\nIMPLOT_API void ShowMetricsWindow(bool* p_popen = nullptr);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Demo\n//-----------------------------------------------------------------------------\n\n// Shows the ImPlot demo window (add implot_demo.cpp to your sources!)\nIMPLOT_API void ShowDemoWindow(bool* p_open = nullptr);\n\n}  // namespace ImPlot\n\n//-----------------------------------------------------------------------------\n// [SECTION] Obsolete API\n//-----------------------------------------------------------------------------\n\n// The following functions will be removed! Keep your copy of implot up to date!\n// Occasionally set '#define IMPLOT_DISABLE_OBSOLETE_FUNCTIONS' to stay ahead.\n// If you absolutely must use these functions and do not want to receive compiler\n// warnings, set '#define IMPLOT_DISABLE_OBSOLETE_WARNINGS'.\n\n#ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS\n\n#ifndef IMPLOT_DISABLE_DEPRECATED_WARNINGS\n#if __cplusplus > 201402L\n#define IMPLOT_DEPRECATED(method) [[deprecated]] method\n#elif defined( __GNUC__ ) && !defined( __INTEL_COMPILER ) && ( __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 1 ) )\n#define IMPLOT_DEPRECATED(method) method __attribute__( ( deprecated ) )\n#elif defined( _MSC_VER )\n#define IMPLOT_DEPRECATED(method) __declspec(deprecated) method\n#else\n#define IMPLOT_DEPRECATED(method) method\n#endif\n#else\n#define IMPLOT_DEPRECATED(method) method\n#endif\n\nenum ImPlotFlagsObsolete_ {\n    ImPlotFlags_YAxis2 = 1 << 20,\n    ImPlotFlags_YAxis3 = 1 << 21,\n};\n\nnamespace ImPlot {\n\n// OBSOLETED in v0.13 -> PLANNED REMOVAL in v1.0\nIMPLOT_DEPRECATED( IMPLOT_API bool BeginPlot(const char* title_id,\n                                             const char* x_label,  // = nullptr,\n                                             const char* y_label,  // = nullptr,\n                                             const ImVec2& size       = ImVec2(-1,0),\n                                             ImPlotFlags flags        = ImPlotFlags_None,\n                                             ImPlotAxisFlags x_flags  = 0,\n                                             ImPlotAxisFlags y_flags  = 0,\n                                             ImPlotAxisFlags y2_flags = ImPlotAxisFlags_AuxDefault,\n                                             ImPlotAxisFlags y3_flags = ImPlotAxisFlags_AuxDefault,\n                                             const char* y2_label     = nullptr,\n                                             const char* y3_label     = nullptr) );\n\n} // namespace ImPlot\n\n#endif // #ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "implot_demo.cpp",
          "type": "blob",
          "size": 111.6357421875,
          "content": "// MIT License\n\n// Copyright (c) 2023 Evan Pezent\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// ImPlot v0.17\n\n// We define this so that the demo does not accidentally use deprecated API\n#ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS\n#define IMPLOT_DISABLE_OBSOLETE_FUNCTIONS\n#endif\n\n#include \"implot.h\"\n#ifndef IMGUI_DISABLE\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#ifdef _MSC_VER\n#define sprintf sprintf_s\n#endif\n\n#ifndef PI\n#define PI 3.14159265358979323846\n#endif\n\n#define CHECKBOX_FLAG(flags, flag) ImGui::CheckboxFlags(#flag, (unsigned int*)&flags, flag)\n\n#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)\n\n// Encapsulates examples for customizing ImPlot.\nnamespace MyImPlot {\n\n// Example for Custom Data and Getters section.\nstruct Vector2f {\n    Vector2f(float _x, float _y) { x = _x; y = _y; }\n    float x, y;\n};\n\n// Example for Custom Data and Getters section.\nstruct WaveData {\n    double X, Amp, Freq, Offset;\n    WaveData(double x, double amp, double freq, double offset) { X = x; Amp = amp; Freq = freq; Offset = offset; }\n};\nImPlotPoint SineWave(int idx, void* wave_data);\nImPlotPoint SawWave(int idx, void* wave_data);\nImPlotPoint Spiral(int idx, void* wave_data);\n\n// Example for Tables section.\nvoid Sparkline(const char* id, const float* values, int count, float min_v, float max_v, int offset, const ImVec4& col, const ImVec2& size);\n\n// Example for Custom Plotters and Tooltips section.\nvoid PlotCandlestick(const char* label_id, const double* xs, const double* opens, const double* closes, const double* lows, const double* highs, int count, bool tooltip = true, float width_percent = 0.25f, ImVec4 bullCol = ImVec4(0,1,0,1), ImVec4 bearCol = ImVec4(1,0,0,1));\n\n// Example for Custom Styles section.\nvoid StyleSeaborn();\n\n} // namespace MyImPlot\n\nnamespace ImPlot {\n\ntemplate <typename T>\ninline T RandomRange(T min, T max) {\n    T scale = rand() / (T) RAND_MAX;\n    return min + scale * ( max - min );\n}\n\nImVec4 RandomColor() {\n    ImVec4 col;\n    col.x = RandomRange(0.0f,1.0f);\n    col.y = RandomRange(0.0f,1.0f);\n    col.z = RandomRange(0.0f,1.0f);\n    col.w = 1.0f;\n    return col;\n}\n\ndouble RandomGauss() {\n\tstatic double V1, V2, S;\n\tstatic int phase = 0;\n\tdouble X;\n\tif(phase == 0) {\n\t\tdo {\n\t\t\tdouble U1 = (double)rand() / RAND_MAX;\n\t\t\tdouble U2 = (double)rand() / RAND_MAX;\n\t\t\tV1 = 2 * U1 - 1;\n\t\t\tV2 = 2 * U2 - 1;\n\t\t\tS = V1 * V1 + V2 * V2;\n\t\t\t} while(S >= 1 || S == 0);\n\n\t\tX = V1 * sqrt(-2 * log(S) / S);\n\t} else\n\t\tX = V2 * sqrt(-2 * log(S) / S);\n\tphase = 1 - phase;\n\treturn X;\n}\n\ntemplate <int N>\nstruct NormalDistribution {\n    NormalDistribution(double mean, double sd) {\n        for (int i = 0; i < N; ++i)\n            Data[i] = RandomGauss()*sd + mean;\n    }\n    double Data[N];\n};\n\n// utility structure for realtime plot\nstruct ScrollingBuffer {\n    int MaxSize;\n    int Offset;\n    ImVector<ImVec2> Data;\n    ScrollingBuffer(int max_size = 2000) {\n        MaxSize = max_size;\n        Offset  = 0;\n        Data.reserve(MaxSize);\n    }\n    void AddPoint(float x, float y) {\n        if (Data.size() < MaxSize)\n            Data.push_back(ImVec2(x,y));\n        else {\n            Data[Offset] = ImVec2(x,y);\n            Offset =  (Offset + 1) % MaxSize;\n        }\n    }\n    void Erase() {\n        if (Data.size() > 0) {\n            Data.shrink(0);\n            Offset  = 0;\n        }\n    }\n};\n\n// utility structure for realtime plot\nstruct RollingBuffer {\n    float Span;\n    ImVector<ImVec2> Data;\n    RollingBuffer() {\n        Span = 10.0f;\n        Data.reserve(2000);\n    }\n    void AddPoint(float x, float y) {\n        float xmod = fmodf(x, Span);\n        if (!Data.empty() && xmod < Data.back().x)\n            Data.shrink(0);\n        Data.push_back(ImVec2(xmod, y));\n    }\n};\n\n// Huge data used by Time Formatting example (~500 MB allocation!)\nstruct HugeTimeData {\n    HugeTimeData(double min) {\n        Ts = new double[Size];\n        Ys = new double[Size];\n        for (int i = 0; i < Size; ++i) {\n            Ts[i] = min + i;\n            Ys[i] = GetY(Ts[i]);\n        }\n    }\n    ~HugeTimeData() { delete[] Ts;  delete[] Ys; }\n    static double GetY(double t) {\n        return 0.5 + 0.25 * sin(t/86400/12) +  0.005 * sin(t/3600);\n    }\n    double* Ts;\n    double* Ys;\n    static const int Size = 60*60*24*366;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Demo Functions\n//-----------------------------------------------------------------------------\n\nvoid Demo_Help() {\n    ImGui::Text(\"ABOUT THIS DEMO:\");\n    ImGui::BulletText(\"Sections below are demonstrating many aspects of the library.\");\n    ImGui::BulletText(\"The \\\"Tools\\\" menu above gives access to: Style Editors (ImPlot/ImGui)\\n\"\n                        \"and Metrics (general purpose Dear ImGui debugging tool).\");\n    ImGui::Separator();\n    ImGui::Text(\"PROGRAMMER GUIDE:\");\n    ImGui::BulletText(\"See the ShowDemoWindow() code in implot_demo.cpp. <- you are here!\");\n    ImGui::BulletText(\"If you see visual artifacts, do one of the following:\");\n    ImGui::Indent();\n    ImGui::BulletText(\"Handle ImGuiBackendFlags_RendererHasVtxOffset for 16-bit indices in your backend.\");\n    ImGui::BulletText(\"Or, enable 32-bit indices in imconfig.h.\");\n    ImGui::BulletText(\"Your current configuration is:\");\n    ImGui::Indent();\n    ImGui::BulletText(\"ImDrawIdx: %d-bit\", (int)(sizeof(ImDrawIdx) * 8));\n    ImGui::BulletText(\"ImGuiBackendFlags_RendererHasVtxOffset: %s\", (ImGui::GetIO().BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset) ? \"True\" : \"False\");\n    ImGui::Unindent();\n    ImGui::Unindent();\n    ImGui::Separator();\n    ImGui::Text(\"USER GUIDE:\");\n    ShowUserGuide();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid ButtonSelector(const char* label, ImGuiMouseButton* b) {\n    ImGui::PushID(label);\n    if (ImGui::RadioButton(\"LMB\",*b == ImGuiMouseButton_Left))\n        *b = ImGuiMouseButton_Left;\n    ImGui::SameLine();\n    if (ImGui::RadioButton(\"RMB\",*b == ImGuiMouseButton_Right))\n        *b = ImGuiMouseButton_Right;\n    ImGui::SameLine();\n    if (ImGui::RadioButton(\"MMB\",*b == ImGuiMouseButton_Middle))\n        *b = ImGuiMouseButton_Middle;\n    ImGui::PopID();\n}\n\nvoid ModSelector(const char* label, int* k) {\n    ImGui::PushID(label);\n    ImGui::CheckboxFlags(\"Ctrl\", (unsigned int*)k, ImGuiMod_Ctrl); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Shift\", (unsigned int*)k, ImGuiMod_Shift); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Alt\", (unsigned int*)k, ImGuiMod_Alt); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Super\", (unsigned int*)k, ImGuiMod_Super);\n    ImGui::PopID();\n}\n\nvoid InputMapping(const char* label, ImGuiMouseButton* b, int* k) {\n    ImGui::LabelText(\"##\",\"%s\",label);\n    if (b != nullptr) {\n        ImGui::SameLine(100);\n        ButtonSelector(label,b);\n    }\n    if (k != nullptr) {\n        ImGui::SameLine(300);\n        ModSelector(label,k);\n    }\n}\n\nvoid ShowInputMapping() {\n    ImPlotInputMap& map = ImPlot::GetInputMap();\n    InputMapping(\"Pan\",&map.Pan,&map.PanMod);\n    InputMapping(\"Fit\",&map.Fit,nullptr);\n    InputMapping(\"Select\",&map.Select,&map.SelectMod);\n    InputMapping(\"SelectHorzMod\",nullptr,&map.SelectHorzMod);\n    InputMapping(\"SelectVertMod\",nullptr,&map.SelectVertMod);\n    InputMapping(\"SelectCancel\",&map.SelectCancel,nullptr);\n    InputMapping(\"Menu\",&map.Menu,nullptr);\n    InputMapping(\"OverrideMod\",nullptr,&map.OverrideMod);\n    InputMapping(\"ZoomMod\",nullptr,&map.ZoomMod);\n    ImGui::SliderFloat(\"ZoomRate\",&map.ZoomRate,-1,1);\n}\n\nvoid Demo_Config() {\n    ImGui::ShowFontSelector(\"Font\");\n    ImGui::ShowStyleSelector(\"ImGui Style\");\n    ImPlot::ShowStyleSelector(\"ImPlot Style\");\n    ImPlot::ShowColormapSelector(\"ImPlot Colormap\");\n    ImPlot::ShowInputMapSelector(\"Input Map\");\n    ImGui::Separator();\n    ImGui::Checkbox(\"Use Local Time\", &ImPlot::GetStyle().UseLocalTime);\n    ImGui::Checkbox(\"Use ISO 8601\", &ImPlot::GetStyle().UseISO8601);\n    ImGui::Checkbox(\"Use 24 Hour Clock\", &ImPlot::GetStyle().Use24HourClock);\n    ImGui::Separator();\n    if (ImPlot::BeginPlot(\"Preview\")) {\n        static double now = (double)time(nullptr);\n        ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_Time);\n        ImPlot::SetupAxisLimits(ImAxis_X1, now, now + 24*3600);\n        for (int i = 0; i < 10; ++i) {\n            double x[2] = {now, now + 24*3600};\n            double y[2] = {0,i/9.0};\n            ImGui::PushID(i);\n            ImPlot::PlotLine(\"##Line\",x,y,2);\n            ImGui::PopID();\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_LinePlots() {\n    static float xs1[1001], ys1[1001];\n    for (int i = 0; i < 1001; ++i) {\n        xs1[i] = i * 0.001f;\n        ys1[i] = 0.5f + 0.5f * sinf(50 * (xs1[i] + (float)ImGui::GetTime() / 10));\n    }\n    static double xs2[20], ys2[20];\n    for (int i = 0; i < 20; ++i) {\n        xs2[i] = i * 1/19.0f;\n        ys2[i] = xs2[i] * xs2[i];\n    }\n    if (ImPlot::BeginPlot(\"Line Plots\")) {\n        ImPlot::SetupAxes(\"x\",\"y\");\n        ImPlot::PlotLine(\"f(x)\", xs1, ys1, 1001);\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle);\n        ImPlot::PlotLine(\"g(x)\", xs2, ys2, 20,ImPlotLineFlags_Segments);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_FilledLinePlots() {\n    static double xs1[101], ys1[101], ys2[101], ys3[101];\n    srand(0);\n    for (int i = 0; i < 101; ++i) {\n        xs1[i] = (float)i;\n        ys1[i] = RandomRange(400.0,450.0);\n        ys2[i] = RandomRange(275.0,350.0);\n        ys3[i] = RandomRange(150.0,225.0);\n    }\n    static bool show_lines = true;\n    static bool show_fills = true;\n    static float fill_ref = 0;\n    static int shade_mode = 0;\n    static ImPlotShadedFlags flags = 0;\n    ImGui::Checkbox(\"Lines\",&show_lines); ImGui::SameLine();\n    ImGui::Checkbox(\"Fills\",&show_fills);\n    if (show_fills) {\n        ImGui::SameLine();\n        if (ImGui::RadioButton(\"To -INF\",shade_mode == 0))\n            shade_mode = 0;\n        ImGui::SameLine();\n        if (ImGui::RadioButton(\"To +INF\",shade_mode == 1))\n            shade_mode = 1;\n        ImGui::SameLine();\n        if (ImGui::RadioButton(\"To Ref\",shade_mode == 2))\n            shade_mode = 2;\n        if (shade_mode == 2) {\n            ImGui::SameLine();\n            ImGui::SetNextItemWidth(100);\n            ImGui::DragFloat(\"##Ref\",&fill_ref, 1, -100, 500);\n        }\n    }\n\n    if (ImPlot::BeginPlot(\"Stock Prices\")) {\n        ImPlot::SetupAxes(\"Days\",\"Price\");\n        ImPlot::SetupAxesLimits(0,100,0,500);\n        if (show_fills) {\n            ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, 0.25f);\n            ImPlot::PlotShaded(\"Stock 1\", xs1, ys1, 101, shade_mode == 0 ? -INFINITY : shade_mode == 1 ? INFINITY : fill_ref, flags);\n            ImPlot::PlotShaded(\"Stock 2\", xs1, ys2, 101, shade_mode == 0 ? -INFINITY : shade_mode == 1 ? INFINITY : fill_ref, flags);\n            ImPlot::PlotShaded(\"Stock 3\", xs1, ys3, 101, shade_mode == 0 ? -INFINITY : shade_mode == 1 ? INFINITY : fill_ref, flags);\n            ImPlot::PopStyleVar();\n        }\n        if (show_lines) {\n            ImPlot::PlotLine(\"Stock 1\", xs1, ys1, 101);\n            ImPlot::PlotLine(\"Stock 2\", xs1, ys2, 101);\n            ImPlot::PlotLine(\"Stock 3\", xs1, ys3, 101);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_ShadedPlots() {\n    static float xs[1001], ys[1001], ys1[1001], ys2[1001], ys3[1001], ys4[1001];\n    srand(0);\n    for (int i = 0; i < 1001; ++i) {\n        xs[i]  = i * 0.001f;\n        ys[i]  = 0.25f + 0.25f * sinf(25 * xs[i]) * sinf(5 * xs[i]) + RandomRange(-0.01f, 0.01f);\n        ys1[i] = ys[i] + RandomRange(0.1f, 0.12f);\n        ys2[i] = ys[i] - RandomRange(0.1f, 0.12f);\n        ys3[i] = 0.75f + 0.2f * sinf(25 * xs[i]);\n        ys4[i] = 0.75f + 0.1f * cosf(25 * xs[i]);\n    }\n    static float alpha = 0.25f;\n    ImGui::DragFloat(\"Alpha\",&alpha,0.01f,0,1);\n\n    if (ImPlot::BeginPlot(\"Shaded Plots\")) {\n        ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, alpha);\n        ImPlot::PlotShaded(\"Uncertain Data\",xs,ys1,ys2,1001);\n        ImPlot::PlotLine(\"Uncertain Data\", xs, ys, 1001);\n        ImPlot::PlotShaded(\"Overlapping\",xs,ys3,ys4,1001);\n        ImPlot::PlotLine(\"Overlapping\",xs,ys3,1001);\n        ImPlot::PlotLine(\"Overlapping\",xs,ys4,1001);\n        ImPlot::PopStyleVar();\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_ScatterPlots() {\n    srand(0);\n    static float xs1[100], ys1[100];\n    for (int i = 0; i < 100; ++i) {\n        xs1[i] = i * 0.01f;\n        ys1[i] = xs1[i] + 0.1f * ((float)rand() / (float)RAND_MAX);\n    }\n    static float xs2[50], ys2[50];\n    for (int i = 0; i < 50; i++) {\n        xs2[i] = 0.25f + 0.2f * ((float)rand() / (float)RAND_MAX);\n        ys2[i] = 0.75f + 0.2f * ((float)rand() / (float)RAND_MAX);\n    }\n\n    if (ImPlot::BeginPlot(\"Scatter Plot\")) {\n        ImPlot::PlotScatter(\"Data 1\", xs1, ys1, 100);\n        ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, 0.25f);\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Square, 6, ImPlot::GetColormapColor(1), IMPLOT_AUTO, ImPlot::GetColormapColor(1));\n        ImPlot::PlotScatter(\"Data 2\", xs2, ys2, 50);\n        ImPlot::PopStyleVar();\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_StairstepPlots() {\n    static float ys1[21], ys2[21];\n    for (int i = 0; i < 21; ++i) {\n        ys1[i] = 0.75f + 0.2f * sinf(10 * i * 0.05f);\n        ys2[i] = 0.25f + 0.2f * sinf(10 * i * 0.05f);\n    }\n    static ImPlotStairsFlags flags = 0;\n    CHECKBOX_FLAG(flags, ImPlotStairsFlags_Shaded);\n    if (ImPlot::BeginPlot(\"Stairstep Plot\")) {\n        ImPlot::SetupAxes(\"x\",\"f(x)\");\n        ImPlot::SetupAxesLimits(0,1,0,1);\n\n        ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.5f,0.5f,0.5f,1.0f));\n        ImPlot::PlotLine(\"##1\",ys1,21,0.05f);\n        ImPlot::PlotLine(\"##2\",ys2,21,0.05f);\n        ImPlot::PopStyleColor();\n\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle);\n        ImPlot::SetNextFillStyle(IMPLOT_AUTO_COL, 0.25f);\n        ImPlot::PlotStairs(\"Post Step (default)\", ys1, 21, 0.05f, 0, flags);\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle);\n        ImPlot::SetNextFillStyle(IMPLOT_AUTO_COL, 0.25f);\n        ImPlot::PlotStairs(\"Pre Step\", ys2, 21, 0.05f, 0, flags|ImPlotStairsFlags_PreStep);\n\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_BarPlots() {\n    static ImS8  data[10] = {1,2,3,4,5,6,7,8,9,10};\n    if (ImPlot::BeginPlot(\"Bar Plot\")) {\n        ImPlot::PlotBars(\"Vertical\",data,10,0.7,1);\n        ImPlot::PlotBars(\"Horizontal\",data,10,0.4,1,ImPlotBarsFlags_Horizontal);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_BarGroups() {\n    static ImS8  data[30] = {83, 67, 23, 89, 83, 78, 91, 82, 85, 90,  // midterm\n                             80, 62, 56, 99, 55, 78, 88, 78, 90, 100, // final\n                             80, 69, 52, 92, 72, 78, 75, 76, 89, 95}; // course\n\n    static const char*  ilabels[]   = {\"Midterm Exam\",\"Final Exam\",\"Course Grade\"};\n    static const char*  glabels[]   = {\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\",\"S7\",\"S8\",\"S9\",\"S10\"};\n    static const double positions[] = {0,1,2,3,4,5,6,7,8,9};\n\n    static int items  = 3;\n    static int groups = 10;\n    static float size = 0.67f;\n\n    static ImPlotBarGroupsFlags flags = 0;\n    static bool horz = false;\n\n    ImGui::CheckboxFlags(\"Stacked\", (unsigned int*)&flags, ImPlotBarGroupsFlags_Stacked);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"Horizontal\",&horz);\n\n    ImGui::SliderInt(\"Items\",&items,1,3);\n    ImGui::SliderFloat(\"Size\",&size,0,1);\n\n    if (ImPlot::BeginPlot(\"Bar Group\")) {\n        ImPlot::SetupLegend(ImPlotLocation_East, ImPlotLegendFlags_Outside);\n        if (horz) {\n            ImPlot::SetupAxes(\"Score\",\"Student\",ImPlotAxisFlags_AutoFit,ImPlotAxisFlags_AutoFit);\n            ImPlot::SetupAxisTicks(ImAxis_Y1,positions, groups, glabels);\n            ImPlot::PlotBarGroups(ilabels,data,items,groups,size,0,flags|ImPlotBarGroupsFlags_Horizontal);\n        }\n        else {\n            ImPlot::SetupAxes(\"Student\",\"Score\",ImPlotAxisFlags_AutoFit,ImPlotAxisFlags_AutoFit);\n            ImPlot::SetupAxisTicks(ImAxis_X1,positions, groups, glabels);\n            ImPlot::PlotBarGroups(ilabels,data,items,groups,size,0,flags);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_BarStacks() {\n\n    static ImPlotColormap Liars = -1;\n    if (Liars == -1) {\n        static const ImU32 Liars_Data[6] = { 4282515870, 4282609140, 4287357182, 4294630301, 4294945280, 4294921472 };\n        Liars = ImPlot::AddColormap(\"Liars\", Liars_Data, 6);\n    }\n\n    static bool diverging = true;\n    ImGui::Checkbox(\"Diverging\",&diverging);\n\n    static const char* politicians[] = {\"Trump\",\"Bachman\",\"Cruz\",\"Gingrich\",\"Palin\",\"Santorum\",\"Walker\",\"Perry\",\"Ryan\",\"McCain\",\"Rubio\",\"Romney\",\"Rand Paul\",\"Christie\",\"Biden\",\"Kasich\",\"Sanders\",\"J Bush\",\"H Clinton\",\"Obama\"};\n    static int data_reg[] = {18,26,7,14,10,8,6,11,4,4,3,8,6,8,6,5,0,3,1,2,                // Pants on Fire\n                             43,36,30,21,30,27,25,17,11,22,15,16,16,17,12,12,14,6,13,12,  // False\n                             16,13,28,22,15,21,15,18,30,17,24,18,13,10,14,15,17,22,14,12, // Mostly False\n                             17,10,13,25,12,22,19,26,23,17,22,27,20,26,29,17,18,22,21,27, // Half True\n                             5,7,16,10,10,12,23,13,17,20,22,16,23,19,20,26,36,29,27,26,   // Mostly True\n                             1,8,6,8,23,10,12,15,15,20,14,15,22,20,19,25,15,18,24,21};    // True\n    static const char* labels_reg[] = {\"Pants on Fire\",\"False\",\"Mostly False\",\"Half True\",\"Mostly True\",\"True\"};\n\n\n    static int data_div[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                                         // Pants on Fire (dummy, to order legend logically)\n                             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                                         // False         (dummy, to order legend logically)\n                             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                                         // Mostly False  (dummy, to order legend logically)\n                             -16,-13,-28,-22,-15,-21,-15,-18,-30,-17,-24,-18,-13,-10,-14,-15,-17,-22,-14,-12, // Mostly False\n                             -43,-36,-30,-21,-30,-27,-25,-17,-11,-22,-15,-16,-16,-17,-12,-12,-14,-6,-13,-12,  // False\n                             -18,-26,-7,-14,-10,-8,-6,-11,-4,-4,-3,-8,-6,-8,-6,-5,0,-3,-1,-2,                 // Pants on Fire\n                             17,10,13,25,12,22,19,26,23,17,22,27,20,26,29,17,18,22,21,27,                     // Half True\n                             5,7,16,10,10,12,23,13,17,20,22,16,23,19,20,26,36,29,27,26,                       // Mostly True\n                             1,8,6,8,23,10,12,15,15,20,14,15,22,20,19,25,15,18,24,21};                        // True\n    static const char* labels_div[] = {\"Pants on Fire\",\"False\",\"Mostly False\",\"Mostly False\",\"False\",\"Pants on Fire\",\"Half True\",\"Mostly True\",\"True\"};\n\n    ImPlot::PushColormap(Liars);\n    if (ImPlot::BeginPlot(\"PolitiFact: Who Lies More?\",ImVec2(-1,400),ImPlotFlags_NoMouseText)) {\n        ImPlot::SetupLegend(ImPlotLocation_South, ImPlotLegendFlags_Outside|ImPlotLegendFlags_Horizontal);\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_AutoFit|ImPlotAxisFlags_NoDecorations,ImPlotAxisFlags_AutoFit|ImPlotAxisFlags_Invert);\n        ImPlot::SetupAxisTicks(ImAxis_Y1,0,19,20,politicians,false);\n        if (diverging)\n            ImPlot::PlotBarGroups(labels_div,data_div,9,20,0.75,0,ImPlotBarGroupsFlags_Stacked|ImPlotBarGroupsFlags_Horizontal);\n        else\n            ImPlot::PlotBarGroups(labels_reg,data_reg,6,20,0.75,0,ImPlotBarGroupsFlags_Stacked|ImPlotBarGroupsFlags_Horizontal);\n        ImPlot::EndPlot();\n    }\n    ImPlot::PopColormap();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_ErrorBars() {\n    static float xs[5]    = {1,2,3,4,5};\n    static float bar[5]   = {1,2,5,3,4};\n    static float lin1[5]  = {8,8,9,7,8};\n    static float lin2[5]  = {6,7,6,9,6};\n    static float err1[5]  = {0.2f, 0.4f, 0.2f, 0.6f, 0.4f};\n    static float err2[5]  = {0.4f, 0.2f, 0.4f, 0.8f, 0.6f};\n    static float err3[5]  = {0.09f, 0.14f, 0.09f, 0.12f, 0.16f};\n    static float err4[5]  = {0.02f, 0.08f, 0.15f, 0.05f, 0.2f};\n\n\n    if (ImPlot::BeginPlot(\"##ErrorBars\")) {\n        ImPlot::SetupAxesLimits(0, 6, 0, 10);\n        ImPlot::PlotBars(\"Bar\", xs, bar, 5, 0.5f);\n        ImPlot::PlotErrorBars(\"Bar\", xs, bar, err1, 5);\n        ImPlot::SetNextErrorBarStyle(ImPlot::GetColormapColor(1), 0);\n        ImPlot::PlotErrorBars(\"Line\", xs, lin1, err1, err2, 5);\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Square);\n        ImPlot::PlotLine(\"Line\", xs, lin1, 5);\n        ImPlot::PushStyleColor(ImPlotCol_ErrorBar, ImPlot::GetColormapColor(2));\n        ImPlot::PlotErrorBars(\"Scatter\", xs, lin2, err2, 5);\n        ImPlot::PlotErrorBars(\"Scatter\", xs, lin2,  err3, err4, 5, ImPlotErrorBarsFlags_Horizontal);\n        ImPlot::PopStyleColor();\n        ImPlot::PlotScatter(\"Scatter\", xs, lin2, 5);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_StemPlots() {\n    static double xs[51], ys1[51], ys2[51];\n    for (int i = 0; i < 51; ++i) {\n        xs[i] = i * 0.02;\n        ys1[i] = 1.0 + 0.5 * sin(25*xs[i])*cos(2*xs[i]);\n        ys2[i] = 0.5 + 0.25  * sin(10*xs[i]) * sin(xs[i]);\n    }\n    if (ImPlot::BeginPlot(\"Stem Plots\")) {\n        ImPlot::SetupAxisLimits(ImAxis_X1,0,1.0);\n        ImPlot::SetupAxisLimits(ImAxis_Y1,0,1.6);\n        ImPlot::PlotStems(\"Stems 1\",xs,ys1,51);\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle);\n        ImPlot::PlotStems(\"Stems 2\", xs, ys2,51);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_InfiniteLines() {\n    static double vals[] = {0.25, 0.5, 0.75};\n    if (ImPlot::BeginPlot(\"##Infinite\")) {\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_NoInitialFit,ImPlotAxisFlags_NoInitialFit);\n        ImPlot::PlotInfLines(\"Vertical\",vals,3);\n        ImPlot::PlotInfLines(\"Horizontal\",vals,3,ImPlotInfLinesFlags_Horizontal);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_PieCharts() {\n    static const char* labels1[]    = {\"Frogs\",\"Hogs\",\"Dogs\",\"Logs\"};\n    static float data1[]            = {0.15f,  0.30f,  0.2f, 0.05f};\n    static ImPlotPieChartFlags flags = 0;\n    ImGui::SetNextItemWidth(250);\n    ImGui::DragFloat4(\"Values\", data1, 0.01f, 0, 1);\n    CHECKBOX_FLAG(flags, ImPlotPieChartFlags_Normalize);\n    CHECKBOX_FLAG(flags, ImPlotPieChartFlags_IgnoreHidden);\n    CHECKBOX_FLAG(flags, ImPlotPieChartFlags_Exploding);\n\n    if (ImPlot::BeginPlot(\"##Pie1\", ImVec2(250,250), ImPlotFlags_Equal | ImPlotFlags_NoMouseText)) {\n        ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations, ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(0, 1, 0, 1);\n        ImPlot::PlotPieChart(labels1, data1, 4, 0.5, 0.5, 0.4, \"%.2f\", 90, flags);\n        ImPlot::EndPlot();\n    }\n\n    ImGui::SameLine();\n\n    static const char* labels2[]   = {\"A\",\"B\",\"C\",\"D\",\"E\"};\n    static int data2[]             = {1,1,2,3,5};\n\n    ImPlot::PushColormap(ImPlotColormap_Pastel);\n    if (ImPlot::BeginPlot(\"##Pie2\", ImVec2(250,250), ImPlotFlags_Equal | ImPlotFlags_NoMouseText)) {\n        ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations, ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(0, 1, 0, 1);\n        ImPlot::PlotPieChart(labels2, data2, 5, 0.5, 0.5, 0.4, \"%.0f\", 180, flags);\n        ImPlot::EndPlot();\n    }\n    ImPlot::PopColormap();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Heatmaps() {\n    static float values1[7][7]  = {{0.8f, 2.4f, 2.5f, 3.9f, 0.0f, 4.0f, 0.0f},\n                                    {2.4f, 0.0f, 4.0f, 1.0f, 2.7f, 0.0f, 0.0f},\n                                    {1.1f, 2.4f, 0.8f, 4.3f, 1.9f, 4.4f, 0.0f},\n                                    {0.6f, 0.0f, 0.3f, 0.0f, 3.1f, 0.0f, 0.0f},\n                                    {0.7f, 1.7f, 0.6f, 2.6f, 2.2f, 6.2f, 0.0f},\n                                    {1.3f, 1.2f, 0.0f, 0.0f, 0.0f, 3.2f, 5.1f},\n                                    {0.1f, 2.0f, 0.0f, 1.4f, 0.0f, 1.9f, 6.3f}};\n    static float scale_min       = 0;\n    static float scale_max       = 6.3f;\n    static const char* xlabels[] = {\"C1\",\"C2\",\"C3\",\"C4\",\"C5\",\"C6\",\"C7\"};\n    static const char* ylabels[] = {\"R1\",\"R2\",\"R3\",\"R4\",\"R5\",\"R6\",\"R7\"};\n\n    static ImPlotColormap map = ImPlotColormap_Viridis;\n    if (ImPlot::ColormapButton(ImPlot::GetColormapName(map),ImVec2(225,0),map)) {\n        map = (map + 1) % ImPlot::GetColormapCount();\n        // We bust the color cache of our plots so that item colors will\n        // resample the new colormap in the event that they have already\n        // been created. See documentation in implot.h.\n        BustColorCache(\"##Heatmap1\");\n        BustColorCache(\"##Heatmap2\");\n    }\n\n    ImGui::SameLine();\n    ImGui::LabelText(\"##Colormap Index\", \"%s\", \"Change Colormap\");\n    ImGui::SetNextItemWidth(225);\n    ImGui::DragFloatRange2(\"Min / Max\",&scale_min, &scale_max, 0.01f, -20, 20);\n\n    static ImPlotHeatmapFlags hm_flags = 0;\n\n    ImGui::CheckboxFlags(\"Column Major\", (unsigned int*)&hm_flags, ImPlotHeatmapFlags_ColMajor);\n\n    static ImPlotAxisFlags axes_flags = ImPlotAxisFlags_Lock | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoTickMarks;\n\n    ImPlot::PushColormap(map);\n\n    if (ImPlot::BeginPlot(\"##Heatmap1\",ImVec2(225,225),ImPlotFlags_NoLegend|ImPlotFlags_NoMouseText)) {\n        ImPlot::SetupAxes(nullptr, nullptr, axes_flags, axes_flags);\n        ImPlot::SetupAxisTicks(ImAxis_X1,0 + 1.0/14.0, 1 - 1.0/14.0, 7, xlabels);\n        ImPlot::SetupAxisTicks(ImAxis_Y1,1 - 1.0/14.0, 0 + 1.0/14.0, 7, ylabels);\n        ImPlot::PlotHeatmap(\"heat\",values1[0],7,7,scale_min,scale_max,\"%g\",ImPlotPoint(0,0),ImPlotPoint(1,1),hm_flags);\n        ImPlot::EndPlot();\n    }\n    ImGui::SameLine();\n    ImPlot::ColormapScale(\"##HeatScale\",scale_min, scale_max, ImVec2(60,225));\n\n    ImGui::SameLine();\n\n    const int size = 80;\n    static double values2[size*size];\n    srand((unsigned int)(ImGui::GetTime()*1000000));\n    for (int i = 0; i < size*size; ++i)\n        values2[i] = RandomRange(0.0,1.0);\n\n    if (ImPlot::BeginPlot(\"##Heatmap2\",ImVec2(225,225))) {\n        ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations, ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(-1,1,-1,1);\n        ImPlot::PlotHeatmap(\"heat1\",values2,size,size,0,1,nullptr);\n        ImPlot::PlotHeatmap(\"heat2\",values2,size,size,0,1,nullptr, ImPlotPoint(-1,-1), ImPlotPoint(0,0));\n        ImPlot::EndPlot();\n    }\n    ImPlot::PopColormap();\n\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Histogram() {\n    static ImPlotHistogramFlags hist_flags = ImPlotHistogramFlags_Density;\n    static int  bins       = 50;\n    static double mu       = 5;\n    static double sigma    = 2;\n    ImGui::SetNextItemWidth(200);\n    if (ImGui::RadioButton(\"Sqrt\",bins==ImPlotBin_Sqrt))       { bins = ImPlotBin_Sqrt;    } ImGui::SameLine();\n    if (ImGui::RadioButton(\"Sturges\",bins==ImPlotBin_Sturges)) { bins = ImPlotBin_Sturges; } ImGui::SameLine();\n    if (ImGui::RadioButton(\"Rice\",bins==ImPlotBin_Rice))       { bins = ImPlotBin_Rice;    } ImGui::SameLine();\n    if (ImGui::RadioButton(\"Scott\",bins==ImPlotBin_Scott))     { bins = ImPlotBin_Scott;   } ImGui::SameLine();\n    if (ImGui::RadioButton(\"N Bins\",bins>=0))                  { bins = 50;                }\n    if (bins>=0) {\n        ImGui::SameLine();\n        ImGui::SetNextItemWidth(200);\n        ImGui::SliderInt(\"##Bins\", &bins, 1, 100);\n    }\n    ImGui::CheckboxFlags(\"Horizontal\", (unsigned int*)&hist_flags, ImPlotHistogramFlags_Horizontal);\n    ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Density\", (unsigned int*)&hist_flags, ImPlotHistogramFlags_Density);\n    ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Cumulative\", (unsigned int*)&hist_flags, ImPlotHistogramFlags_Cumulative);\n\n    static bool range = false;\n    ImGui::Checkbox(\"Range\", &range);\n    static float rmin = -3;\n    static float rmax = 13;\n    if (range) {\n        ImGui::SameLine();\n        ImGui::SetNextItemWidth(200);\n        ImGui::DragFloat2(\"##Range\",&rmin,0.1f,-3,13);\n        ImGui::SameLine();\n        ImGui::CheckboxFlags(\"Exclude Outliers\", (unsigned int*)&hist_flags, ImPlotHistogramFlags_NoOutliers);\n    }\n    static NormalDistribution<10000> dist(mu, sigma);\n    static double x[100];\n    static double y[100];\n    if (hist_flags & ImPlotHistogramFlags_Density) {\n        for (int i = 0; i < 100; ++i) {\n            x[i] = -3 + 16 * (double)i/99.0;\n            y[i] = exp( - (x[i]-mu)*(x[i]-mu) / (2*sigma*sigma)) / (sigma * sqrt(2*3.141592653589793238));\n        }\n        if (hist_flags & ImPlotHistogramFlags_Cumulative) {\n            for (int i = 1; i < 100; ++i)\n                y[i] += y[i-1];\n            for (int i = 0; i < 100; ++i)\n                y[i] /= y[99];\n        }\n    }\n\n    if (ImPlot::BeginPlot(\"##Histograms\")) {\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_AutoFit,ImPlotAxisFlags_AutoFit);\n        ImPlot::SetNextFillStyle(IMPLOT_AUTO_COL,0.5f);\n        ImPlot::PlotHistogram(\"Empirical\", dist.Data, 10000, bins, 1.0, range ? ImPlotRange(rmin,rmax) : ImPlotRange(), hist_flags);\n        if ((hist_flags & ImPlotHistogramFlags_Density) && !(hist_flags & ImPlotHistogramFlags_NoOutliers)) {\n            if (hist_flags & ImPlotHistogramFlags_Horizontal)\n                ImPlot::PlotLine(\"Theoretical\",y,x,100);\n            else\n                ImPlot::PlotLine(\"Theoretical\",x,y,100);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Histogram2D() {\n    static int count     = 50000;\n    static int xybins[2] = {100,100};\n\n    static ImPlotHistogramFlags hist_flags = 0;\n\n    ImGui::SliderInt(\"Count\",&count,100,100000);\n    ImGui::SliderInt2(\"Bins\",xybins,1,500);\n    ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Density\", (unsigned int*)&hist_flags, ImPlotHistogramFlags_Density);\n\n    static NormalDistribution<100000> dist1(1, 2);\n    static NormalDistribution<100000> dist2(1, 1);\n    double max_count = 0;\n    ImPlotAxisFlags flags = ImPlotAxisFlags_AutoFit|ImPlotAxisFlags_Foreground;\n    ImPlot::PushColormap(\"Hot\");\n    if (ImPlot::BeginPlot(\"##Hist2D\",ImVec2(ImGui::GetContentRegionAvail().x-100-ImGui::GetStyle().ItemSpacing.x,0))) {\n        ImPlot::SetupAxes(nullptr, nullptr, flags, flags);\n        ImPlot::SetupAxesLimits(-6,6,-6,6);\n        max_count = ImPlot::PlotHistogram2D(\"Hist2D\",dist1.Data,dist2.Data,count,xybins[0],xybins[1],ImPlotRect(-6,6,-6,6), hist_flags);\n        ImPlot::EndPlot();\n    }\n    ImGui::SameLine();\n    ImPlot::ColormapScale(hist_flags & ImPlotHistogramFlags_Density ? \"Density\" : \"Count\",0,max_count,ImVec2(100,0));\n    ImPlot::PopColormap();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_DigitalPlots() {\n    ImGui::BulletText(\"Digital plots do not respond to Y drag and zoom, so that\");\n    ImGui::Indent();\n    ImGui::Text(\"you can drag analog plots over the rising/falling digital edge.\");\n    ImGui::Unindent();\n\n    static bool paused = false;\n    static ScrollingBuffer dataDigital[2];\n    static ScrollingBuffer dataAnalog[2];\n    static bool showDigital[2] = {true, false};\n    static bool showAnalog[2] = {true, false};\n\n    char label[32];\n    ImGui::Checkbox(\"digital_0\", &showDigital[0]); ImGui::SameLine();\n    ImGui::Checkbox(\"digital_1\", &showDigital[1]); ImGui::SameLine();\n    ImGui::Checkbox(\"analog_0\",  &showAnalog[0]);  ImGui::SameLine();\n    ImGui::Checkbox(\"analog_1\",  &showAnalog[1]);\n\n    static float t = 0;\n    if (!paused) {\n        t += ImGui::GetIO().DeltaTime;\n        //digital signal values\n        if (showDigital[0])\n            dataDigital[0].AddPoint(t, sinf(2*t) > 0.45);\n        if (showDigital[1])\n            dataDigital[1].AddPoint(t, sinf(2*t) < 0.45);\n        //Analog signal values\n        if (showAnalog[0])\n            dataAnalog[0].AddPoint(t, sinf(2*t));\n        if (showAnalog[1])\n            dataAnalog[1].AddPoint(t, cosf(2*t));\n    }\n    if (ImPlot::BeginPlot(\"##Digital\")) {\n        ImPlot::SetupAxisLimits(ImAxis_X1, t - 10.0, t, paused ? ImGuiCond_Once : ImGuiCond_Always);\n        ImPlot::SetupAxisLimits(ImAxis_Y1, -1, 1);\n        for (int i = 0; i < 2; ++i) {\n            if (showDigital[i] && dataDigital[i].Data.size() > 0) {\n                snprintf(label, sizeof(label), \"digital_%d\", i);\n                ImPlot::PlotDigital(label, &dataDigital[i].Data[0].x, &dataDigital[i].Data[0].y, dataDigital[i].Data.size(), 0, dataDigital[i].Offset, 2 * sizeof(float));\n            }\n        }\n        for (int i = 0; i < 2; ++i) {\n            if (showAnalog[i]) {\n                snprintf(label, sizeof(label), \"analog_%d\", i);\n                if (dataAnalog[i].Data.size() > 0)\n                    ImPlot::PlotLine(label, &dataAnalog[i].Data[0].x, &dataAnalog[i].Data[0].y, dataAnalog[i].Data.size(), 0, dataAnalog[i].Offset, 2 * sizeof(float));\n            }\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Images() {\n    ImGui::BulletText(\"Below we are displaying the font texture, which is the only texture we have\\naccess to in this demo.\");\n    ImGui::BulletText(\"Use the 'ImTextureID' type as storage to pass pointers or identifiers to your\\nown texture data.\");\n    ImGui::BulletText(\"See ImGui Wiki page 'Image Loading and Displaying Examples'.\");\n    static ImVec2 bmin(0,0);\n    static ImVec2 bmax(1,1);\n    static ImVec2 uv0(0,0);\n    static ImVec2 uv1(1,1);\n    static ImVec4 tint(1,1,1,1);\n    ImGui::SliderFloat2(\"Min\", &bmin.x, -2, 2, \"%.1f\");\n    ImGui::SliderFloat2(\"Max\", &bmax.x, -2, 2, \"%.1f\");\n    ImGui::SliderFloat2(\"UV0\", &uv0.x, -2, 2, \"%.1f\");\n    ImGui::SliderFloat2(\"UV1\", &uv1.x, -2, 2, \"%.1f\");\n    ImGui::ColorEdit4(\"Tint\",&tint.x);\n    if (ImPlot::BeginPlot(\"##image\")) {\n        ImPlot::PlotImage(\"my image\",ImGui::GetIO().Fonts->TexID, bmin, bmax, uv0, uv1, tint);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_RealtimePlots() {\n    ImGui::BulletText(\"Move your mouse to change the data!\");\n    ImGui::BulletText(\"This example assumes 60 FPS. Higher FPS requires larger buffer size.\");\n    static ScrollingBuffer sdata1, sdata2;\n    static RollingBuffer   rdata1, rdata2;\n    ImVec2 mouse = ImGui::GetMousePos();\n    static float t = 0;\n    t += ImGui::GetIO().DeltaTime;\n    sdata1.AddPoint(t, mouse.x * 0.0005f);\n    rdata1.AddPoint(t, mouse.x * 0.0005f);\n    sdata2.AddPoint(t, mouse.y * 0.0005f);\n    rdata2.AddPoint(t, mouse.y * 0.0005f);\n\n    static float history = 10.0f;\n    ImGui::SliderFloat(\"History\",&history,1,30,\"%.1f s\");\n    rdata1.Span = history;\n    rdata2.Span = history;\n\n    static ImPlotAxisFlags flags = ImPlotAxisFlags_NoTickLabels;\n\n    if (ImPlot::BeginPlot(\"##Scrolling\", ImVec2(-1,150))) {\n        ImPlot::SetupAxes(nullptr, nullptr, flags, flags);\n        ImPlot::SetupAxisLimits(ImAxis_X1,t - history, t, ImGuiCond_Always);\n        ImPlot::SetupAxisLimits(ImAxis_Y1,0,1);\n        ImPlot::SetNextFillStyle(IMPLOT_AUTO_COL,0.5f);\n        ImPlot::PlotShaded(\"Mouse X\", &sdata1.Data[0].x, &sdata1.Data[0].y, sdata1.Data.size(), -INFINITY, 0, sdata1.Offset, 2 * sizeof(float));\n        ImPlot::PlotLine(\"Mouse Y\", &sdata2.Data[0].x, &sdata2.Data[0].y, sdata2.Data.size(), 0, sdata2.Offset, 2*sizeof(float));\n        ImPlot::EndPlot();\n    }\n    if (ImPlot::BeginPlot(\"##Rolling\", ImVec2(-1,150))) {\n        ImPlot::SetupAxes(nullptr, nullptr, flags, flags);\n        ImPlot::SetupAxisLimits(ImAxis_X1,0,history, ImGuiCond_Always);\n        ImPlot::SetupAxisLimits(ImAxis_Y1,0,1);\n        ImPlot::PlotLine(\"Mouse X\", &rdata1.Data[0].x, &rdata1.Data[0].y, rdata1.Data.size(), 0, 0, 2 * sizeof(float));\n        ImPlot::PlotLine(\"Mouse Y\", &rdata2.Data[0].x, &rdata2.Data[0].y, rdata2.Data.size(), 0, 0, 2 * sizeof(float));\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_MarkersAndText() {\n    static float mk_size = ImPlot::GetStyle().MarkerSize;\n    static float mk_weight = ImPlot::GetStyle().MarkerWeight;\n    ImGui::DragFloat(\"Marker Size\",&mk_size,0.1f,2.0f,10.0f,\"%.2f px\");\n    ImGui::DragFloat(\"Marker Weight\", &mk_weight,0.05f,0.5f,3.0f,\"%.2f px\");\n\n    if (ImPlot::BeginPlot(\"##MarkerStyles\", ImVec2(-1,0), ImPlotFlags_CanvasOnly)) {\n\n        ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations, ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(0, 10, 0, 12);\n\n        ImS8 xs[2] = {1,4};\n        ImS8 ys[2] = {10,11};\n\n        // filled markers\n        for (int m = 0; m < ImPlotMarker_COUNT; ++m) {\n            ImGui::PushID(m);\n            ImPlot::SetNextMarkerStyle(m, mk_size, IMPLOT_AUTO_COL, mk_weight);\n            ImPlot::PlotLine(\"##Filled\", xs, ys, 2);\n            ImGui::PopID();\n            ys[0]--; ys[1]--;\n        }\n        xs[0] = 6; xs[1] = 9; ys[0] = 10; ys[1] = 11;\n        // open markers\n        for (int m = 0; m < ImPlotMarker_COUNT; ++m) {\n            ImGui::PushID(m);\n            ImPlot::SetNextMarkerStyle(m, mk_size, ImVec4(0,0,0,0), mk_weight);\n            ImPlot::PlotLine(\"##Open\", xs, ys, 2);\n            ImGui::PopID();\n            ys[0]--; ys[1]--;\n        }\n\n        ImPlot::PlotText(\"Filled Markers\", 2.5f, 6.0f);\n        ImPlot::PlotText(\"Open Markers\",   7.5f, 6.0f);\n\n        ImPlot::PushStyleColor(ImPlotCol_InlayText, ImVec4(1,0,1,1));\n        ImPlot::PlotText(\"Vertical Text\", 5.0f, 6.0f, ImVec2(0,0), ImPlotTextFlags_Vertical);\n        ImPlot::PopStyleColor();\n\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_NaNValues() {\n\n    static bool include_nan = true;\n    static ImPlotLineFlags flags = 0;\n\n    float data1[5] = {0.0f,0.25f,0.5f,0.75f,1.0f};\n    float data2[5] = {0.0f,0.25f,0.5f,0.75f,1.0f};\n\n    if (include_nan)\n        data1[2] = NAN;\n\n    ImGui::Checkbox(\"Include NaN\",&include_nan);\n    ImGui::SameLine();\n    ImGui::CheckboxFlags(\"Skip NaN\", (unsigned int*)&flags, ImPlotLineFlags_SkipNaN);\n\n    if (ImPlot::BeginPlot(\"##NaNValues\")) {\n        ImPlot::SetNextMarkerStyle(ImPlotMarker_Square);\n        ImPlot::PlotLine(\"line\", data1, data2, 5, flags);\n        ImPlot::PlotBars(\"bars\", data1, 5);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_LogScale() {\n    static double xs[1001], ys1[1001], ys2[1001], ys3[1001];\n    for (int i = 0; i < 1001; ++i) {\n        xs[i]  = i*0.1f;\n        ys1[i] = sin(xs[i]) + 1;\n        ys2[i] = log(xs[i]);\n        ys3[i] = pow(10.0, xs[i]);\n    }\n    if (ImPlot::BeginPlot(\"Log Plot\", ImVec2(-1,0))) {\n        ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_Log10);\n        ImPlot::SetupAxesLimits(0.1, 100, 0, 10);\n        ImPlot::PlotLine(\"f(x) = x\",        xs, xs,  1001);\n        ImPlot::PlotLine(\"f(x) = sin(x)+1\", xs, ys1, 1001);\n        ImPlot::PlotLine(\"f(x) = log(x)\",   xs, ys2, 1001);\n        ImPlot::PlotLine(\"f(x) = 10^x\",     xs, ys3, 21);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_SymmetricLogScale() {\n    static double xs[1001], ys1[1001], ys2[1001];\n    for (int i = 0; i < 1001; ++i) {\n        xs[i]  = i*0.1f-50;\n        ys1[i] = sin(xs[i]);\n        ys2[i] = i*0.002 - 1;\n    }\n    if (ImPlot::BeginPlot(\"SymLog Plot\", ImVec2(-1,0))) {\n        ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_SymLog);\n        ImPlot::PlotLine(\"f(x) = a*x+b\",xs,ys2,1001);\n        ImPlot::PlotLine(\"f(x) = sin(x)\",xs,ys1,1001);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_TimeScale() {\n\n    static double t_min = 1609459200; // 01/01/2021 @ 12:00:00am (UTC)\n    static double t_max = 1640995200; // 01/01/2022 @ 12:00:00am (UTC)\n\n    ImGui::BulletText(\"When ImPlotAxisFlags_Time is enabled on the X-Axis, values are interpreted as\\n\"\n                        \"UNIX timestamps in seconds and axis labels are formated as date/time.\");\n    ImGui::BulletText(\"By default, labels are in UTC time but can be set to use local time instead.\");\n\n    ImGui::Checkbox(\"Local Time\",&ImPlot::GetStyle().UseLocalTime);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"ISO 8601\",&ImPlot::GetStyle().UseISO8601);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"24 Hour Clock\",&ImPlot::GetStyle().Use24HourClock);\n\n    static HugeTimeData* data = nullptr;\n    if (data == nullptr) {\n        ImGui::SameLine();\n        if (ImGui::Button(\"Generate Huge Data (~500MB!)\")) {\n            static HugeTimeData sdata(t_min);\n            data = &sdata;\n        }\n    }\n\n    if (ImPlot::BeginPlot(\"##Time\", ImVec2(-1,0))) {\n        ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_Time);\n        ImPlot::SetupAxesLimits(t_min,t_max,0,1);\n        if (data != nullptr) {\n            // downsample our data\n            int downsample = (int)ImPlot::GetPlotLimits().X.Size() / 1000 + 1;\n            int start = (int)(ImPlot::GetPlotLimits().X.Min - t_min);\n            start = start < 0 ? 0 : start > HugeTimeData::Size - 1 ? HugeTimeData::Size - 1 : start;\n            int end = (int)(ImPlot::GetPlotLimits().X.Max - t_min) + 1000;\n            end = end < 0 ? 0 : end > HugeTimeData::Size - 1 ? HugeTimeData::Size - 1 : end;\n            int size = (end - start)/downsample;\n            // plot it\n            ImPlot::PlotLine(\"Time Series\", &data->Ts[start], &data->Ys[start], size, 0, 0, sizeof(double)*downsample);\n        }\n        // plot time now\n        double t_now = (double)time(nullptr);\n        double y_now = HugeTimeData::GetY(t_now);\n        ImPlot::PlotScatter(\"Now\",&t_now,&y_now,1);\n        ImPlot::Annotation(t_now,y_now,ImPlot::GetLastItemColor(),ImVec2(10,10),false,\"Now\");\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nstatic inline double TransformForward_Sqrt(double v, void*) {\n    return sqrt(v);\n}\n\nstatic inline double TransformInverse_Sqrt(double v, void*) {\n    return v*v;\n}\n\nvoid Demo_CustomScale() {\n    static float v[100];\n    for (int i = 0; i < 100; ++i) {\n        v[i] = i*0.01f;\n    }\n    if (ImPlot::BeginPlot(\"Sqrt\")) {\n        ImPlot::SetupAxis(ImAxis_X1, \"Linear\");\n        ImPlot::SetupAxis(ImAxis_Y1, \"Sqrt\");\n        ImPlot::SetupAxisScale(ImAxis_Y1, TransformForward_Sqrt, TransformInverse_Sqrt);\n        ImPlot::SetupAxisLimitsConstraints(ImAxis_Y1, 0, INFINITY);\n        ImPlot::PlotLine(\"##data\",v,v,100);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_MultipleAxes() {\n    static float xs[1001], xs2[1001], ys1[1001], ys2[1001], ys3[1001];\n    for (int i = 0; i < 1001; ++i) {\n        xs[i]  = (i*0.1f);\n        xs2[i] = xs[i] + 10.0f;\n        ys1[i] = sinf(xs[i]) * 3 + 1;\n        ys2[i] = cosf(xs[i]) * 0.2f + 0.5f;\n        ys3[i] = sinf(xs[i]+0.5f) * 100 + 200;\n    }\n\n    static bool x2_axis = true;\n    static bool y2_axis = true;\n    static bool y3_axis = true;\n\n    ImGui::Checkbox(\"X-Axis 2\", &x2_axis);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"Y-Axis 2\", &y2_axis);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"Y-Axis 3\", &y3_axis);\n\n    ImGui::BulletText(\"You can drag axes to the opposite side of the plot.\");\n    ImGui::BulletText(\"Hover over legend items to see which axis they are plotted on.\");\n\n    if (ImPlot::BeginPlot(\"Multi-Axis Plot\", ImVec2(-1,0))) {\n        ImPlot::SetupAxes(\"X-Axis 1\", \"Y-Axis 1\");\n        ImPlot::SetupAxesLimits(0, 100, 0, 10);\n        if (x2_axis) {\n            ImPlot::SetupAxis(ImAxis_X2, \"X-Axis 2\",ImPlotAxisFlags_AuxDefault);\n            ImPlot::SetupAxisLimits(ImAxis_X2, 0, 100);\n        }\n        if (y2_axis) {\n            ImPlot::SetupAxis(ImAxis_Y2, \"Y-Axis 2\",ImPlotAxisFlags_AuxDefault);\n            ImPlot::SetupAxisLimits(ImAxis_Y2, 0, 1);\n        }\n        if (y3_axis) {\n            ImPlot::SetupAxis(ImAxis_Y3, \"Y-Axis 3\",ImPlotAxisFlags_AuxDefault);\n            ImPlot::SetupAxisLimits(ImAxis_Y3, 0, 300);\n        }\n\n        ImPlot::PlotLine(\"f(x) = x\", xs, xs, 1001);\n        if (x2_axis) {\n            ImPlot::SetAxes(ImAxis_X2, ImAxis_Y1);\n            ImPlot::PlotLine(\"f(x) = sin(x)*3+1\", xs2, ys1, 1001);\n        }\n        if (y2_axis) {\n            ImPlot::SetAxes(ImAxis_X1, ImAxis_Y2);\n            ImPlot::PlotLine(\"f(x) = cos(x)*.2+.5\", xs, ys2, 1001);\n        }\n        if (x2_axis && y3_axis) {\n            ImPlot::SetAxes(ImAxis_X2, ImAxis_Y3);\n            ImPlot::PlotLine(\"f(x) = sin(x+.5)*100+200 \", xs2, ys3, 1001);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_LinkedAxes() {\n    static ImPlotRect lims(0,1,0,1);\n    static bool linkx = true, linky = true;\n    int data[2] = {0,1};\n    ImGui::Checkbox(\"Link X\", &linkx);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"Link Y\", &linky);\n\n    ImGui::DragScalarN(\"Limits\",ImGuiDataType_Double,&lims.X.Min,4,0.01f);\n\n    if (BeginAlignedPlots(\"AlignedGroup\")) {\n        if (ImPlot::BeginPlot(\"Plot A\")) {\n            ImPlot::SetupAxisLinks(ImAxis_X1, linkx ? &lims.X.Min : nullptr, linkx ? &lims.X.Max : nullptr);\n            ImPlot::SetupAxisLinks(ImAxis_Y1, linky ? &lims.Y.Min : nullptr, linky ? &lims.Y.Max : nullptr);\n            ImPlot::PlotLine(\"Line\",data,2);\n            ImPlot::EndPlot();\n        }\n        if (ImPlot::BeginPlot(\"Plot B\")) {\n            ImPlot::SetupAxisLinks(ImAxis_X1, linkx ? &lims.X.Min : nullptr, linkx ? &lims.X.Max : nullptr);\n            ImPlot::SetupAxisLinks(ImAxis_Y1, linky ? &lims.Y.Min : nullptr, linky ? &lims.Y.Max : nullptr);\n            ImPlot::PlotLine(\"Line\",data,2);\n            ImPlot::EndPlot();\n        }\n        ImPlot::EndAlignedPlots();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_AxisConstraints() {\n    static float constraints[4] = {-10,10,1,20};\n    static ImPlotAxisFlags flags;\n    ImGui::DragFloat2(\"Limits Constraints\", &constraints[0], 0.01f);\n    ImGui::DragFloat2(\"Zoom Constraints\", &constraints[2], 0.01f);\n    CHECKBOX_FLAG(flags, ImPlotAxisFlags_PanStretch);\n    if (ImPlot::BeginPlot(\"##AxisConstraints\",ImVec2(-1,0))) {\n        ImPlot::SetupAxes(\"X\",\"Y\",flags,flags);\n        ImPlot::SetupAxesLimits(-1,1,-1,1);\n        ImPlot::SetupAxisLimitsConstraints(ImAxis_X1,constraints[0], constraints[1]);\n        ImPlot::SetupAxisZoomConstraints(ImAxis_X1,constraints[2], constraints[3]);\n        ImPlot::SetupAxisLimitsConstraints(ImAxis_Y1,constraints[0], constraints[1]);\n        ImPlot::SetupAxisZoomConstraints(ImAxis_Y1,constraints[2], constraints[3]);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_EqualAxes() {\n    ImGui::BulletText(\"Equal constraint applies to axis pairs (e.g ImAxis_X1/Y1, ImAxis_X2/Y2)\");\n    static double xs1[360], ys1[360];\n    for (int i = 0; i < 360; ++i) {\n        double angle = i * 2 * PI / 359.0;\n        xs1[i] = cos(angle); ys1[i] = sin(angle);\n    }\n    float xs2[] = {-1,0,1,0,-1};\n    float ys2[] = {0,1,0,-1,0};\n    if (ImPlot::BeginPlot(\"##EqualAxes\",ImVec2(-1,0),ImPlotFlags_Equal)) {\n        ImPlot::SetupAxis(ImAxis_X2, nullptr, ImPlotAxisFlags_AuxDefault);\n        ImPlot::SetupAxis(ImAxis_Y2, nullptr, ImPlotAxisFlags_AuxDefault);\n        ImPlot::PlotLine(\"Circle\",xs1,ys1,360);\n        ImPlot::SetAxes(ImAxis_X2, ImAxis_Y2);\n        ImPlot::PlotLine(\"Diamond\",xs2,ys2,5);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_AutoFittingData() {\n    ImGui::BulletText(\"The Y-axis has been configured to auto-fit to only the data visible in X-axis range.\");\n    ImGui::BulletText(\"Zoom and pan the X-axis. Disable Stems to see a difference in fit.\");\n    ImGui::BulletText(\"If ImPlotAxisFlags_RangeFit is disabled, the axis will fit ALL data.\");\n\n    static ImPlotAxisFlags xflags = ImPlotAxisFlags_None;\n    static ImPlotAxisFlags yflags = ImPlotAxisFlags_AutoFit|ImPlotAxisFlags_RangeFit;\n\n    ImGui::TextUnformatted(\"X: \"); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"ImPlotAxisFlags_AutoFit##X\", (unsigned int*)&xflags, ImPlotAxisFlags_AutoFit); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"ImPlotAxisFlags_RangeFit##X\", (unsigned int*)&xflags, ImPlotAxisFlags_RangeFit);\n\n    ImGui::TextUnformatted(\"Y: \"); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"ImPlotAxisFlags_AutoFit##Y\", (unsigned int*)&yflags, ImPlotAxisFlags_AutoFit); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"ImPlotAxisFlags_RangeFit##Y\", (unsigned int*)&yflags, ImPlotAxisFlags_RangeFit);\n\n    static double data[101];\n    srand(0);\n    for (int i = 0; i < 101; ++i)\n        data[i] = 1 + sin(i/10.0f);\n\n    if (ImPlot::BeginPlot(\"##DataFitting\")) {\n        ImPlot::SetupAxes(\"X\",\"Y\",xflags,yflags);\n        ImPlot::PlotLine(\"Line\",data,101);\n        ImPlot::PlotStems(\"Stems\",data,101);\n        ImPlot::EndPlot();\n    };\n}\n\n//-----------------------------------------------------------------------------\n\nImPlotPoint SinewaveGetter(int i, void* data) {\n    float f = *(float*)data;\n    return ImPlotPoint(i,sinf(f*i));\n}\n\nvoid Demo_SubplotsSizing() {\n\n    static ImPlotSubplotFlags flags = ImPlotSubplotFlags_ShareItems|ImPlotSubplotFlags_NoLegend;\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_NoResize\", (unsigned int*)&flags, ImPlotSubplotFlags_NoResize);\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_NoTitle\", (unsigned int*)&flags, ImPlotSubplotFlags_NoTitle);\n\n    static int rows = 3;\n    static int cols = 3;\n    ImGui::SliderInt(\"Rows\",&rows,1,5);\n    ImGui::SliderInt(\"Cols\",&cols,1,5);\n    if (rows < 1 || cols < 1) {\n        ImGui::TextColored(ImVec4(1,0,0,1), \"Nice try, but the number of rows and columns must be greater than 0!\");\n        return;\n    }\n    static float rratios[] = {5,1,1,1,1,1};\n    static float cratios[] = {5,1,1,1,1,1};\n    ImGui::DragScalarN(\"Row Ratios\",ImGuiDataType_Float,rratios,rows,0.01f,nullptr);\n    ImGui::DragScalarN(\"Col Ratios\",ImGuiDataType_Float,cratios,cols,0.01f,nullptr);\n    if (ImPlot::BeginSubplots(\"My Subplots\", rows, cols, ImVec2(-1,400), flags, rratios, cratios)) {\n        int id = 0;\n        for (int i = 0; i < rows*cols; ++i) {\n            if (ImPlot::BeginPlot(\"\",ImVec2(),ImPlotFlags_NoLegend)) {\n                ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_NoDecorations,ImPlotAxisFlags_NoDecorations);\n                float fi = 0.01f * (i+1);\n                if (rows*cols > 1) {\n                    ImPlot::SetNextLineStyle(SampleColormap((float)i/(float)(rows*cols-1),ImPlotColormap_Jet));\n                }\n                char label[16];\n                snprintf(label, sizeof(label), \"data%d\", id++);\n                ImPlot::PlotLineG(label,SinewaveGetter,&fi,1000);\n                ImPlot::EndPlot();\n            }\n        }\n        ImPlot::EndSubplots();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_SubplotItemSharing() {\n    static ImPlotSubplotFlags flags = ImPlotSubplotFlags_ShareItems;\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_ShareItems\", (unsigned int*)&flags, ImPlotSubplotFlags_ShareItems);\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_ColMajor\", (unsigned int*)&flags, ImPlotSubplotFlags_ColMajor);\n    ImGui::BulletText(\"Drag and drop items from the legend onto plots (except for 'common')\");\n    static int rows = 2;\n    static int cols = 3;\n    static int id[] = {0,1,2,3,4,5};\n    static int curj = -1;\n    if (ImPlot::BeginSubplots(\"##ItemSharing\", rows, cols, ImVec2(-1,400), flags)) {\n        ImPlot::SetupLegend(ImPlotLocation_South, ImPlotLegendFlags_Sort|ImPlotLegendFlags_Horizontal);\n        for (int i = 0; i < rows*cols; ++i) {\n            if (ImPlot::BeginPlot(\"\")) {\n                float fc = 0.01f;\n                ImPlot::PlotLineG(\"common\",SinewaveGetter,&fc,1000);\n                for (int j = 0; j < 6; ++j) {\n                    if (id[j] == i) {\n                        char label[8];\n                        float fj = 0.01f * (j+2);\n                        snprintf(label, sizeof(label), \"data%d\", j);\n                        ImPlot::PlotLineG(label,SinewaveGetter,&fj,1000);\n                        if (ImPlot::BeginDragDropSourceItem(label)) {\n                            curj = j;\n                            ImGui::SetDragDropPayload(\"MY_DND\",nullptr,0);\n                            ImPlot::ItemIcon(GetLastItemColor()); ImGui::SameLine();\n                            ImGui::TextUnformatted(label);\n                            ImPlot::EndDragDropSource();\n                        }\n                    }\n                }\n                if (ImPlot::BeginDragDropTargetPlot()) {\n                    if (ImGui::AcceptDragDropPayload(\"MY_DND\"))\n                        id[curj] = i;\n                    ImPlot::EndDragDropTarget();\n                }\n                ImPlot::EndPlot();\n            }\n        }\n        ImPlot::EndSubplots();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_SubplotAxisLinking() {\n    static ImPlotSubplotFlags flags = ImPlotSubplotFlags_LinkRows | ImPlotSubplotFlags_LinkCols;\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_LinkRows\", (unsigned int*)&flags, ImPlotSubplotFlags_LinkRows);\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_LinkCols\", (unsigned int*)&flags, ImPlotSubplotFlags_LinkCols);\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_LinkAllX\", (unsigned int*)&flags, ImPlotSubplotFlags_LinkAllX);\n    ImGui::CheckboxFlags(\"ImPlotSubplotFlags_LinkAllY\", (unsigned int*)&flags, ImPlotSubplotFlags_LinkAllY);\n\n    static int rows = 2;\n    static int cols = 2;\n    if (ImPlot::BeginSubplots(\"##AxisLinking\", rows, cols, ImVec2(-1,400), flags)) {\n        for (int i = 0; i < rows*cols; ++i) {\n            if (ImPlot::BeginPlot(\"\")) {\n                ImPlot::SetupAxesLimits(0,1000,-1,1);\n                float fc = 0.01f;\n                ImPlot::PlotLineG(\"common\",SinewaveGetter,&fc,1000);\n                ImPlot::EndPlot();\n            }\n        }\n        ImPlot::EndSubplots();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_LegendOptions() {\n    static ImPlotLocation loc = ImPlotLocation_East;\n    ImGui::CheckboxFlags(\"North\", (unsigned int*)&loc, ImPlotLocation_North); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"South\", (unsigned int*)&loc, ImPlotLocation_South); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"West\",  (unsigned int*)&loc, ImPlotLocation_West);  ImGui::SameLine();\n    ImGui::CheckboxFlags(\"East\",  (unsigned int*)&loc, ImPlotLocation_East);\n\n    static ImPlotLegendFlags flags = 0;\n\n    CHECKBOX_FLAG(flags, ImPlotLegendFlags_Horizontal);\n    CHECKBOX_FLAG(flags, ImPlotLegendFlags_Outside);\n    CHECKBOX_FLAG(flags, ImPlotLegendFlags_Sort);\n\n    ImGui::SliderFloat2(\"LegendPadding\", (float*)&GetStyle().LegendPadding, 0.0f, 20.0f, \"%.0f\");\n    ImGui::SliderFloat2(\"LegendInnerPadding\", (float*)&GetStyle().LegendInnerPadding, 0.0f, 10.0f, \"%.0f\");\n    ImGui::SliderFloat2(\"LegendSpacing\", (float*)&GetStyle().LegendSpacing, 0.0f, 5.0f, \"%.0f\");\n\n    static int num_dummy_items = 25;\n    ImGui::SliderInt(\"Num Dummy Items (Demo Scrolling)\", &num_dummy_items, 0, 100);\n\n    if (ImPlot::BeginPlot(\"##Legend\",ImVec2(-1,0))) {\n        ImPlot::SetupLegend(loc, flags);\n        static MyImPlot::WaveData data1(0.001, 0.2, 4, 0.2);\n        static MyImPlot::WaveData data2(0.001, 0.2, 4, 0.4);\n        static MyImPlot::WaveData data3(0.001, 0.2, 4, 0.6);\n        static MyImPlot::WaveData data4(0.001, 0.2, 4, 0.8);\n        static MyImPlot::WaveData data5(0.001, 0.2, 4, 1.0);\n\n        ImPlot::PlotLineG(\"Item 002\", MyImPlot::SawWave, &data1, 1000);         // \"Item B\" added to legend\n        ImPlot::PlotLineG(\"Item 001##IDText\", MyImPlot::SawWave, &data2, 1000);  // \"Item A\" added to legend, text after ## used for ID only\n        ImPlot::PlotLineG(\"##NotListed\", MyImPlot::SawWave, &data3, 1000);     // plotted, but not added to legend\n        ImPlot::PlotLineG(\"Item 003\", MyImPlot::SawWave, &data4, 1000);         // \"Item C\" added to legend\n        ImPlot::PlotLineG(\"Item 003\", MyImPlot::SawWave,  &data5, 1000);         // combined with previous \"Item C\"\n\n        for (int i = 0; i < num_dummy_items; ++i) {\n            char label[16];\n            snprintf(label, sizeof(label), \"Item %03d\", i+4);\n            ImPlot::PlotDummy(label);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_DragPoints() {\n    ImGui::BulletText(\"Click and drag each point.\");\n    static ImPlotDragToolFlags flags = ImPlotDragToolFlags_None;\n    ImGui::CheckboxFlags(\"NoCursors\", (unsigned int*)&flags, ImPlotDragToolFlags_NoCursors); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoFit\", (unsigned int*)&flags, ImPlotDragToolFlags_NoFit); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoInput\", (unsigned int*)&flags, ImPlotDragToolFlags_NoInputs);\n    ImPlotAxisFlags ax_flags = ImPlotAxisFlags_NoTickLabels | ImPlotAxisFlags_NoTickMarks;\n    bool clicked[4] = {false, false, false, false};\n    bool hovered[4] = {false, false, false, false};\n    bool held[4]    = {false, false, false, false};\n    if (ImPlot::BeginPlot(\"##Bezier\",ImVec2(-1,0),ImPlotFlags_CanvasOnly)) {\n        ImPlot::SetupAxes(nullptr,nullptr,ax_flags,ax_flags);\n        ImPlot::SetupAxesLimits(0,1,0,1);\n        static ImPlotPoint P[] = {ImPlotPoint(.05f,.05f), ImPlotPoint(0.2,0.4),  ImPlotPoint(0.8,0.6),  ImPlotPoint(.95f,.95f)};\n\n        ImPlot::DragPoint(0,&P[0].x,&P[0].y, ImVec4(0,0.9f,0,1),4,flags, &clicked[0], &hovered[0], &held[0]);\n        ImPlot::DragPoint(1,&P[1].x,&P[1].y, ImVec4(1,0.5f,1,1),4,flags, &clicked[1], &hovered[1], &held[1]);\n        ImPlot::DragPoint(2,&P[2].x,&P[2].y, ImVec4(0,0.5f,1,1),4,flags, &clicked[2], &hovered[2], &held[2]);\n        ImPlot::DragPoint(3,&P[3].x,&P[3].y, ImVec4(0,0.9f,0,1),4,flags, &clicked[3], &hovered[3], &held[3]);\n\n        static ImPlotPoint B[100];\n        for (int i = 0; i < 100; ++i) {\n            double t  = i / 99.0;\n            double u  = 1 - t;\n            double w1 = u*u*u;\n            double w2 = 3*u*u*t;\n            double w3 = 3*u*t*t;\n            double w4 = t*t*t;\n            B[i] = ImPlotPoint(w1*P[0].x + w2*P[1].x + w3*P[2].x + w4*P[3].x, w1*P[0].y + w2*P[1].y + w3*P[2].y + w4*P[3].y);\n        }\n\n        ImPlot::SetNextLineStyle(ImVec4(1,0.5f,1,1),hovered[1]||held[1] ? 2.0f : 1.0f);\n        ImPlot::PlotLine(\"##h1\",&P[0].x, &P[0].y, 2, 0, 0, sizeof(ImPlotPoint));\n        ImPlot::SetNextLineStyle(ImVec4(0,0.5f,1,1), hovered[2]||held[2] ? 2.0f : 1.0f);\n        ImPlot::PlotLine(\"##h2\",&P[2].x, &P[2].y, 2, 0, 0, sizeof(ImPlotPoint));\n        ImPlot::SetNextLineStyle(ImVec4(0,0.9f,0,1), hovered[0]||held[0]||hovered[3]||held[3] ? 3.0f : 2.0f);\n        ImPlot::PlotLine(\"##bez\",&B[0].x, &B[0].y, 100, 0, 0, sizeof(ImPlotPoint));\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_DragLines() {\n    ImGui::BulletText(\"Click and drag the horizontal and vertical lines.\");\n    static double x1 = 0.2;\n    static double x2 = 0.8;\n    static double y1 = 0.25;\n    static double y2 = 0.75;\n    static double f = 0.1;\n    bool clicked = false;\n    bool hovered = false;\n    bool held = false;\n    static ImPlotDragToolFlags flags = ImPlotDragToolFlags_None;\n    ImGui::CheckboxFlags(\"NoCursors\", (unsigned int*)&flags, ImPlotDragToolFlags_NoCursors); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoFit\", (unsigned int*)&flags, ImPlotDragToolFlags_NoFit); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoInput\", (unsigned int*)&flags, ImPlotDragToolFlags_NoInputs);\n    if (ImPlot::BeginPlot(\"##lines\",ImVec2(-1,0))) {\n        ImPlot::SetupAxesLimits(0,1,0,1);\n        ImPlot::DragLineX(0,&x1,ImVec4(1,1,1,1),1,flags);\n        ImPlot::DragLineX(1,&x2,ImVec4(1,1,1,1),1,flags);\n        ImPlot::DragLineY(2,&y1,ImVec4(1,1,1,1),1,flags);\n        ImPlot::DragLineY(3,&y2,ImVec4(1,1,1,1),1,flags);\n        double xs[1000], ys[1000];\n        for (int i = 0; i < 1000; ++i) {\n            xs[i] = (x2+x1)/2+fabs(x2-x1)*(i/1000.0f - 0.5f);\n            ys[i] = (y1+y2)/2+fabs(y2-y1)/2*sin(f*i/10);\n        }\n        ImPlot::DragLineY(120482,&f,ImVec4(1,0.5f,1,1),1,flags, &clicked, &hovered, &held);\n        ImPlot::SetNextLineStyle(IMPLOT_AUTO_COL, hovered||held ? 2.0f : 1.0f);\n        ImPlot::PlotLine(\"Interactive Data\", xs, ys, 1000);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_DragRects() {\n\n    static float x_data[512];\n    static float y_data1[512];\n    static float y_data2[512];\n    static float y_data3[512];\n    static float sampling_freq = 44100;\n    static float freq = 500;\n    bool clicked = false;\n    bool hovered = false;\n    bool held = false;\n    for (size_t i = 0; i < 512; ++i) {\n        const float t = i / sampling_freq;\n        x_data[i] = t;\n        const float arg = 2 * 3.14f * freq * t;\n        y_data1[i] = sinf(arg);\n        y_data2[i] = y_data1[i] * -0.6f + sinf(2 * arg) * 0.4f;\n        y_data3[i] = y_data2[i] * -0.6f + sinf(3 * arg) * 0.4f;\n    }\n    ImGui::BulletText(\"Click and drag the edges, corners, and center of the rect.\");\n    ImGui::BulletText(\"Double click edges to expand rect to plot extents.\");\n    static ImPlotRect rect(0.0025,0.0045,0,0.5);\n    static ImPlotDragToolFlags flags = ImPlotDragToolFlags_None;\n    ImGui::CheckboxFlags(\"NoCursors\", (unsigned int*)&flags, ImPlotDragToolFlags_NoCursors); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoFit\", (unsigned int*)&flags, ImPlotDragToolFlags_NoFit); ImGui::SameLine();\n    ImGui::CheckboxFlags(\"NoInput\", (unsigned int*)&flags, ImPlotDragToolFlags_NoInputs);\n\n    if (ImPlot::BeginPlot(\"##Main\",ImVec2(-1,150))) {\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_NoTickLabels,ImPlotAxisFlags_NoTickLabels);\n        ImPlot::SetupAxesLimits(0,0.01,-1,1);\n        ImPlot::PlotLine(\"Signal 1\", x_data, y_data1, 512);\n        ImPlot::PlotLine(\"Signal 2\", x_data, y_data2, 512);\n        ImPlot::PlotLine(\"Signal 3\", x_data, y_data3, 512);\n        ImPlot::DragRect(0,&rect.X.Min,&rect.Y.Min,&rect.X.Max,&rect.Y.Max,ImVec4(1,0,1,1),flags, &clicked, &hovered, &held);\n        ImPlot::EndPlot();\n    }\n    ImVec4 bg_col = held ? ImVec4(0.5f,0,0.5f,1) : (hovered ? ImVec4(0.25f,0,0.25f,1) : ImPlot::GetStyle().Colors[ImPlotCol_PlotBg]);\n    ImPlot::PushStyleColor(ImPlotCol_PlotBg, bg_col);\n    if (ImPlot::BeginPlot(\"##rect\",ImVec2(-1,150), ImPlotFlags_CanvasOnly)) {\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_NoDecorations,ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(rect.X.Min, rect.X.Max, rect.Y.Min, rect.Y.Max, ImGuiCond_Always);\n        ImPlot::PlotLine(\"Signal 1\", x_data, y_data1, 512);\n        ImPlot::PlotLine(\"Signal 2\", x_data, y_data2, 512);\n        ImPlot::PlotLine(\"Signal 3\", x_data, y_data3, 512);\n        ImPlot::EndPlot();\n    }\n    ImPlot::PopStyleColor();\n    ImGui::Text(\"Rect is %sclicked, %shovered, %sheld\", clicked ? \"\" : \"not \", hovered ? \"\" : \"not \", held ? \"\" : \"not \");\n}\n\n//-----------------------------------------------------------------------------\n\nImPlotPoint FindCentroid(const ImVector<ImPlotPoint>& data, const ImPlotRect& bounds, int& cnt) {\n    cnt = 0;\n    ImPlotPoint avg;\n    ImPlotRect bounds_fixed;\n    bounds_fixed.X.Min = bounds.X.Min < bounds.X.Max ? bounds.X.Min : bounds.X.Max;\n    bounds_fixed.X.Max = bounds.X.Min < bounds.X.Max ? bounds.X.Max : bounds.X.Min;\n    bounds_fixed.Y.Min = bounds.Y.Min < bounds.Y.Max ? bounds.Y.Min : bounds.Y.Max;\n    bounds_fixed.Y.Max = bounds.Y.Min < bounds.Y.Max ? bounds.Y.Max : bounds.Y.Min;\n    for (int i = 0; i < data.size(); ++i) {\n        if (bounds_fixed.Contains(data[i].x, data[i].y)) {\n            avg.x += data[i].x;\n            avg.y += data[i].y;\n            cnt++;\n        }\n    }\n    if (cnt > 0) {\n        avg.x = avg.x / cnt;\n        avg.y = avg.y / cnt;\n    }\n    return avg;\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Querying() {\n    static ImVector<ImPlotPoint> data;\n    static ImVector<ImPlotRect> rects;\n    static ImPlotRect limits, select;\n    static bool init = true;\n    if (init) {\n        for (int i = 0; i < 50; ++i)\n        {\n            double x = RandomRange(0.1, 0.9);\n            double y = RandomRange(0.1, 0.9);\n            data.push_back(ImPlotPoint(x,y));\n        }\n        init = false;\n    }\n\n    ImGui::BulletText(\"Box select and left click mouse to create a new query rect.\");\n    ImGui::BulletText(\"Ctrl + click in the plot area to draw points.\");\n\n    if (ImGui::Button(\"Clear Queries\"))\n        rects.shrink(0);\n\n    if (ImPlot::BeginPlot(\"##Centroid\")) {\n        ImPlot::SetupAxesLimits(0,1,0,1);\n        if (ImPlot::IsPlotHovered() && ImGui::IsMouseClicked(0) && ImGui::GetIO().KeyCtrl) {\n            ImPlotPoint pt = ImPlot::GetPlotMousePos();\n            data.push_back(pt);\n        }\n        ImPlot::PlotScatter(\"Points\", &data[0].x, &data[0].y, data.size(), 0, 0, 2 * sizeof(double));\n        if (ImPlot::IsPlotSelected()) {\n            select = ImPlot::GetPlotSelection();\n            int cnt;\n            ImPlotPoint centroid = FindCentroid(data,select,cnt);\n            if (cnt > 0) {\n                ImPlot::SetNextMarkerStyle(ImPlotMarker_Square,6);\n                ImPlot::PlotScatter(\"Centroid\", &centroid.x, &centroid.y, 1);\n            }\n            if (ImGui::IsMouseClicked(ImPlot::GetInputMap().SelectCancel)) {\n                CancelPlotSelection();\n                rects.push_back(select);\n            }\n        }\n        for (int i = 0; i < rects.size(); ++i) {\n            int cnt;\n            ImPlotPoint centroid = FindCentroid(data,rects[i],cnt);\n            if (cnt > 0) {\n                ImPlot::SetNextMarkerStyle(ImPlotMarker_Square,6);\n                ImPlot::PlotScatter(\"Centroid\", &centroid.x, &centroid.y, 1);\n            }\n            ImPlot::DragRect(i,&rects[i].X.Min,&rects[i].Y.Min,&rects[i].X.Max,&rects[i].Y.Max,ImVec4(1,0,1,1));\n        }\n        limits  = ImPlot::GetPlotLimits();\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Annotations() {\n    static bool clamp = false;\n    ImGui::Checkbox(\"Clamp\",&clamp);\n    if (ImPlot::BeginPlot(\"##Annotations\")) {\n        ImPlot::SetupAxesLimits(0,2,0,1);\n        static float p[] = {0.25f, 0.25f, 0.75f, 0.75f, 0.25f};\n        ImPlot::PlotScatter(\"##Points\",&p[0],&p[1],4);\n        ImVec4 col = GetLastItemColor();\n        ImPlot::Annotation(0.25,0.25,col,ImVec2(-15,15),clamp,\"BL\");\n        ImPlot::Annotation(0.75,0.25,col,ImVec2(15,15),clamp,\"BR\");\n        ImPlot::Annotation(0.75,0.75,col,ImVec2(15,-15),clamp,\"TR\");\n        ImPlot::Annotation(0.25,0.75,col,ImVec2(-15,-15),clamp,\"TL\");\n        ImPlot::Annotation(0.5,0.5,col,ImVec2(0,0),clamp,\"Center\");\n\n        ImPlot::Annotation(1.25,0.75,ImVec4(0,1,0,1),ImVec2(0,0),clamp);\n\n        float bx[] = {1.2f,1.5f,1.8f};\n        float by[] = {0.25f, 0.5f, 0.75f};\n        ImPlot::PlotBars(\"##Bars\",bx,by,3,0.2);\n        for (int i = 0; i < 3; ++i)\n            ImPlot::Annotation(bx[i],by[i],ImVec4(0,0,0,0),ImVec2(0,-5),clamp,\"B[%d]=%.2f\",i,by[i]);\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Tags() {\n    static bool show = true;\n    ImGui::Checkbox(\"Show Tags\",&show);\n    if (ImPlot::BeginPlot(\"##Tags\")) {\n        ImPlot::SetupAxis(ImAxis_X2);\n        ImPlot::SetupAxis(ImAxis_Y2);\n        if (show) {\n            ImPlot::TagX(0.25, ImVec4(1,1,0,1));\n            ImPlot::TagY(0.75, ImVec4(1,1,0,1));\n            static double drag_tag = 0.25;\n            ImPlot::DragLineY(0,&drag_tag,ImVec4(1,0,0,1),1,ImPlotDragToolFlags_NoFit);\n            ImPlot::TagY(drag_tag, ImVec4(1,0,0,1), \"Drag\");\n            SetAxes(ImAxis_X2, ImAxis_Y2);\n            ImPlot::TagX(0.5, ImVec4(0,1,1,1), \"%s\", \"MyTag\");\n            ImPlot::TagY(0.5, ImVec4(0,1,1,1), \"Tag: %d\", 42);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_DragAndDrop() {\n    ImGui::BulletText(\"Drag/drop items from the left column.\");\n    ImGui::BulletText(\"Drag/drop items between plots.\");\n    ImGui::Indent();\n    ImGui::BulletText(\"Plot 1 Targets: Plot, Y-Axes, Legend\");\n    ImGui::BulletText(\"Plot 1 Sources: Legend Item Labels\");\n    ImGui::BulletText(\"Plot 2 Targets: Plot, X-Axis, Y-Axis\");\n    ImGui::BulletText(\"Plot 2 Sources: Plot, X-Axis, Y-Axis (hold Ctrl)\");\n    ImGui::Unindent();\n\n    // convenience struct to manage DND items; do this however you like\n    struct MyDndItem {\n        int              Idx;\n        int              Plt;\n        ImAxis           Yax;\n        char             Label[16];\n        ImVector<ImVec2> Data;\n        ImVec4           Color;\n        MyDndItem()        {\n            static int i = 0;\n            Idx = i++;\n            Plt = 0;\n            Yax = ImAxis_Y1;\n            snprintf(Label, sizeof(Label), \"%02d Hz\", Idx+1);\n            Color = RandomColor();\n            Data.reserve(1001);\n            for (int k = 0; k < 1001; ++k) {\n                float t = k * 1.0f / 999;\n                Data.push_back(ImVec2(t, 0.5f + 0.5f * sinf(2*3.14f*t*(Idx+1))));\n            }\n        }\n        void Reset() { Plt = 0; Yax = ImAxis_Y1; }\n    };\n\n    const int         k_dnd = 20;\n    static MyDndItem  dnd[k_dnd];\n    static MyDndItem* dndx = nullptr; // for plot 2\n    static MyDndItem* dndy = nullptr; // for plot 2\n\n    // child window to serve as initial source for our DND items\n    ImGui::BeginChild(\"DND_LEFT\",ImVec2(100,400));\n    if (ImGui::Button(\"Reset Data\")) {\n        for (int k = 0; k < k_dnd; ++k)\n            dnd[k].Reset();\n        dndx = dndy = nullptr;\n    }\n    for (int k = 0; k < k_dnd; ++k) {\n        if (dnd[k].Plt > 0)\n            continue;\n        ImPlot::ItemIcon(dnd[k].Color); ImGui::SameLine();\n        ImGui::Selectable(dnd[k].Label, false, 0, ImVec2(100, 0));\n        if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None)) {\n            ImGui::SetDragDropPayload(\"MY_DND\", &k, sizeof(int));\n            ImPlot::ItemIcon(dnd[k].Color); ImGui::SameLine();\n            ImGui::TextUnformatted(dnd[k].Label);\n            ImGui::EndDragDropSource();\n        }\n    }\n    ImGui::EndChild();\n    if (ImGui::BeginDragDropTarget()) {\n        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n            int i = *(int*)payload->Data; dnd[i].Reset();\n        }\n        ImGui::EndDragDropTarget();\n    }\n\n    ImGui::SameLine();\n    ImGui::BeginChild(\"DND_RIGHT\",ImVec2(-1,400));\n    // plot 1 (time series)\n    ImPlotAxisFlags flags = ImPlotAxisFlags_NoTickLabels | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoHighlight;\n    if (ImPlot::BeginPlot(\"##DND1\", ImVec2(-1,195))) {\n        ImPlot::SetupAxis(ImAxis_X1, nullptr, flags|ImPlotAxisFlags_Lock);\n        ImPlot::SetupAxis(ImAxis_Y1, \"[drop here]\", flags);\n        ImPlot::SetupAxis(ImAxis_Y2, \"[drop here]\", flags|ImPlotAxisFlags_Opposite);\n        ImPlot::SetupAxis(ImAxis_Y3, \"[drop here]\", flags|ImPlotAxisFlags_Opposite);\n\n        for (int k = 0; k < k_dnd; ++k) {\n            if (dnd[k].Plt == 1 && dnd[k].Data.size() > 0) {\n                ImPlot::SetAxis(dnd[k].Yax);\n                ImPlot::SetNextLineStyle(dnd[k].Color);\n                ImPlot::PlotLine(dnd[k].Label, &dnd[k].Data[0].x, &dnd[k].Data[0].y, dnd[k].Data.size(), 0, 0, 2 * sizeof(float));\n                // allow legend item labels to be DND sources\n                if (ImPlot::BeginDragDropSourceItem(dnd[k].Label)) {\n                    ImGui::SetDragDropPayload(\"MY_DND\", &k, sizeof(int));\n                    ImPlot::ItemIcon(dnd[k].Color); ImGui::SameLine();\n                    ImGui::TextUnformatted(dnd[k].Label);\n                    ImPlot::EndDragDropSource();\n                }\n            }\n        }\n        // allow the main plot area to be a DND target\n        if (ImPlot::BeginDragDropTargetPlot()) {\n            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                int i = *(int*)payload->Data; dnd[i].Plt = 1; dnd[i].Yax = ImAxis_Y1;\n            }\n            ImPlot::EndDragDropTarget();\n        }\n        // allow each y-axis to be a DND target\n        for (int y = ImAxis_Y1; y <= ImAxis_Y3; ++y) {\n            if (ImPlot::BeginDragDropTargetAxis(y)) {\n                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                    int i = *(int*)payload->Data; dnd[i].Plt = 1; dnd[i].Yax = y;\n                }\n                ImPlot::EndDragDropTarget();\n            }\n        }\n        // allow the legend to be a DND target\n        if (ImPlot::BeginDragDropTargetLegend()) {\n            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                int i = *(int*)payload->Data; dnd[i].Plt = 1; dnd[i].Yax = ImAxis_Y1;\n            }\n            ImPlot::EndDragDropTarget();\n        }\n        ImPlot::EndPlot();\n    }\n    // plot 2 (Lissajous)\n    if (ImPlot::BeginPlot(\"##DND2\", ImVec2(-1,195))) {\n        ImPlot::PushStyleColor(ImPlotCol_AxisBg, dndx != nullptr ? dndx->Color : ImPlot::GetStyle().Colors[ImPlotCol_AxisBg]);\n        ImPlot::SetupAxis(ImAxis_X1, dndx == nullptr ? \"[drop here]\" : dndx->Label, flags);\n        ImPlot::PushStyleColor(ImPlotCol_AxisBg, dndy != nullptr ? dndy->Color : ImPlot::GetStyle().Colors[ImPlotCol_AxisBg]);\n        ImPlot::SetupAxis(ImAxis_Y1, dndy == nullptr ? \"[drop here]\" : dndy->Label, flags);\n        ImPlot::PopStyleColor(2);\n        if (dndx != nullptr && dndy != nullptr) {\n            ImVec4 mixed((dndx->Color.x + dndy->Color.x)/2,(dndx->Color.y + dndy->Color.y)/2,(dndx->Color.z + dndy->Color.z)/2,(dndx->Color.w + dndy->Color.w)/2);\n            ImPlot::SetNextLineStyle(mixed);\n            ImPlot::PlotLine(\"##dndxy\", &dndx->Data[0].y, &dndy->Data[0].y, dndx->Data.size(), 0, 0, 2 * sizeof(float));\n        }\n        // allow the x-axis to be a DND target\n        if (ImPlot::BeginDragDropTargetAxis(ImAxis_X1)) {\n            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                int i = *(int*)payload->Data; dndx = &dnd[i];\n            }\n            ImPlot::EndDragDropTarget();\n        }\n        // allow the x-axis to be a DND source\n        if (dndx != nullptr && ImPlot::BeginDragDropSourceAxis(ImAxis_X1)) {\n            ImGui::SetDragDropPayload(\"MY_DND\", &dndx->Idx, sizeof(int));\n            ImPlot::ItemIcon(dndx->Color); ImGui::SameLine();\n            ImGui::TextUnformatted(dndx->Label);\n            ImPlot::EndDragDropSource();\n        }\n        // allow the y-axis to be a DND target\n        if (ImPlot::BeginDragDropTargetAxis(ImAxis_Y1)) {\n            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                int i = *(int*)payload->Data; dndy = &dnd[i];\n            }\n            ImPlot::EndDragDropTarget();\n        }\n        // allow the y-axis to be a DND source\n        if (dndy != nullptr && ImPlot::BeginDragDropSourceAxis(ImAxis_Y1)) {\n            ImGui::SetDragDropPayload(\"MY_DND\", &dndy->Idx, sizeof(int));\n            ImPlot::ItemIcon(dndy->Color); ImGui::SameLine();\n            ImGui::TextUnformatted(dndy->Label);\n            ImPlot::EndDragDropSource();\n        }\n        // allow the plot area to be a DND target\n        if (ImPlot::BeginDragDropTargetPlot()) {\n            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"MY_DND\")) {\n                int i = *(int*)payload->Data; dndx = dndy = &dnd[i];\n            }\n        }\n        // allow the plot area to be a DND source\n        if (ImPlot::BeginDragDropSourcePlot()) {\n            ImGui::TextUnformatted(\"Yes, you can\\ndrag this!\");\n            ImPlot::EndDragDropSource();\n        }\n        ImPlot::EndPlot();\n    }\n    ImGui::EndChild();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_Tables() {\n#ifdef IMGUI_HAS_TABLE\n    static ImGuiTableFlags flags = ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV |\n                                   ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable;\n    static bool anim = true;\n    static int offset = 0;\n    ImGui::BulletText(\"Plots can be used inside of ImGui tables as another means of creating subplots.\");\n    ImGui::Checkbox(\"Animate\",&anim);\n    if (anim)\n        offset = (offset + 1) % 100;\n    if (ImGui::BeginTable(\"##table\", 3, flags, ImVec2(-1,0))) {\n        ImGui::TableSetupColumn(\"Electrode\", ImGuiTableColumnFlags_WidthFixed, 75.0f);\n        ImGui::TableSetupColumn(\"Voltage\", ImGuiTableColumnFlags_WidthFixed, 75.0f);\n        ImGui::TableSetupColumn(\"EMG Signal\");\n        ImGui::TableHeadersRow();\n        ImPlot::PushColormap(ImPlotColormap_Cool);\n        for (int row = 0; row < 10; row++) {\n            ImGui::TableNextRow();\n            static float data[100];\n            srand(row);\n            for (int i = 0; i < 100; ++i)\n                data[i] = RandomRange(0.0f,10.0f);\n            ImGui::TableSetColumnIndex(0);\n            ImGui::Text(\"EMG %d\", row);\n            ImGui::TableSetColumnIndex(1);\n            ImGui::Text(\"%.3f V\", data[offset]);\n            ImGui::TableSetColumnIndex(2);\n            ImGui::PushID(row);\n            MyImPlot::Sparkline(\"##spark\",data,100,0,11.0f,offset,ImPlot::GetColormapColor(row),ImVec2(-1, 35));\n            ImGui::PopID();\n        }\n        ImPlot::PopColormap();\n        ImGui::EndTable();\n    }\n#else\n    ImGui::BulletText(\"You need to merge the ImGui 'tables' branch for this section.\");\n#endif\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_OffsetAndStride() {\n    static const int k_circles    = 11;\n    static const int k_points_per = 50;\n    static const int k_size       = 2 * k_points_per * k_circles;\n    static double interleaved_data[k_size];\n    for (int p = 0; p < k_points_per; ++p) {\n        for (int c = 0; c < k_circles; ++c) {\n            double r = (double)c / (k_circles - 1) * 0.2 + 0.2;\n            interleaved_data[p*2*k_circles + 2*c + 0] = 0.5 + r * cos((double)p/k_points_per * 6.28);\n            interleaved_data[p*2*k_circles + 2*c + 1] = 0.5 + r * sin((double)p/k_points_per * 6.28);\n        }\n    }\n    static int offset = 0;\n    ImGui::BulletText(\"Offsetting is useful for realtime plots (see above) and circular buffers.\");\n    ImGui::BulletText(\"Striding is useful for interleaved data (e.g. audio) or plotting structs.\");\n    ImGui::BulletText(\"Here, all circle data is stored in a single interleaved buffer:\");\n    ImGui::BulletText(\"[c0.x0 c0.y0 ... cn.x0 cn.y0 c0.x1 c0.y1 ... cn.x1 cn.y1 ... cn.xm cn.ym]\");\n    ImGui::BulletText(\"The offset value indicates which circle point index is considered the first.\");\n    ImGui::BulletText(\"Offsets can be negative and/or larger than the actual data count.\");\n    ImGui::SliderInt(\"Offset\", &offset, -2*k_points_per, 2*k_points_per);\n    if (ImPlot::BeginPlot(\"##strideoffset\",ImVec2(-1,0),ImPlotFlags_Equal)) {\n        ImPlot::PushColormap(ImPlotColormap_Jet);\n        char buff[32];\n        for (int c = 0; c < k_circles; ++c) {\n            snprintf(buff, sizeof(buff), \"Circle %d\", c);\n            ImPlot::PlotLine(buff, &interleaved_data[c*2 + 0], &interleaved_data[c*2 + 1], k_points_per, 0, offset, 2*k_circles*sizeof(double));\n        }\n        ImPlot::EndPlot();\n        ImPlot::PopColormap();\n    }\n    // offset++; uncomment for animation!\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_CustomDataAndGetters() {\n    ImGui::BulletText(\"You can plot custom structs using the stride feature.\");\n    ImGui::BulletText(\"Most plotters can also be passed a function pointer for getting data.\");\n    ImGui::Indent();\n        ImGui::BulletText(\"You can optionally pass user data to be given to your getter function.\");\n        ImGui::BulletText(\"C++ lambdas can be passed as function pointers as well!\");\n    ImGui::Unindent();\n\n    MyImPlot::Vector2f vec2_data[2] = { MyImPlot::Vector2f(0,0), MyImPlot::Vector2f(1,1) };\n\n    if (ImPlot::BeginPlot(\"##Custom Data\")) {\n\n        // custom structs using stride example:\n        ImPlot::PlotLine(\"Vector2f\", &vec2_data[0].x, &vec2_data[0].y, 2, 0, 0, sizeof(MyImPlot::Vector2f) /* or sizeof(float) * 2 */);\n\n        // custom getter example 1:\n        ImPlot::PlotLineG(\"Spiral\", MyImPlot::Spiral, nullptr, 1000);\n\n        // custom getter example 2:\n        static MyImPlot::WaveData data1(0.001, 0.2, 2, 0.75);\n        static MyImPlot::WaveData data2(0.001, 0.2, 4, 0.25);\n        ImPlot::PlotLineG(\"Waves\", MyImPlot::SineWave, &data1, 1000);\n        ImPlot::PlotLineG(\"Waves\", MyImPlot::SawWave, &data2, 1000);\n        ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, 0.25f);\n        ImPlot::PlotShadedG(\"Waves\", MyImPlot::SineWave, &data1, MyImPlot::SawWave, &data2, 1000);\n        ImPlot::PopStyleVar();\n\n        // you can also pass C++ lambdas:\n        // auto lamda = [](void* data, int idx) { ... return ImPlotPoint(x,y); };\n        // ImPlot::PlotLine(\"My Lambda\", lambda, data, 1000);\n\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nint MetricFormatter(double value, char* buff, int size, void* data) {\n    const char* unit = (const char*)data;\n    static double v[]      = {1000000000,1000000,1000,1,0.001,0.000001,0.000000001};\n    static const char* p[] = {\"G\",\"M\",\"k\",\"\",\"m\",\"u\",\"n\"};\n    if (value == 0) {\n        return snprintf(buff,size,\"0 %s\", unit);\n    }\n    for (int i = 0; i < 7; ++i) {\n        if (fabs(value) >= v[i]) {\n            return snprintf(buff,size,\"%g %s%s\",value/v[i],p[i],unit);\n        }\n    }\n    return snprintf(buff,size,\"%g %s%s\",value/v[6],p[6],unit);\n}\n\nvoid Demo_TickLabels()  {\n    static bool custom_fmt    = true;\n    static bool custom_ticks  = false;\n    static bool custom_labels = true;\n    ImGui::Checkbox(\"Show Custom Format\", &custom_fmt);\n    ImGui::SameLine();\n    ImGui::Checkbox(\"Show Custom Ticks\", &custom_ticks);\n    if (custom_ticks) {\n        ImGui::SameLine();\n        ImGui::Checkbox(\"Show Custom Labels\", &custom_labels);\n    }\n    const double pi = 3.14;\n    const char* pi_str[] = {\"PI\"};\n    static double yticks[] = {100,300,700,900};\n    static const char*  ylabels[] = {\"One\",\"Three\",\"Seven\",\"Nine\"};\n    static double yticks_aux[] = {0.2,0.4,0.6};\n    static const char* ylabels_aux[] = {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n    if (ImPlot::BeginPlot(\"##Ticks\")) {\n        ImPlot::SetupAxesLimits(2.5,5,0,1000);\n        ImPlot::SetupAxis(ImAxis_Y2, nullptr, ImPlotAxisFlags_AuxDefault);\n        ImPlot::SetupAxis(ImAxis_Y3, nullptr, ImPlotAxisFlags_AuxDefault);\n        if (custom_fmt) {\n            ImPlot::SetupAxisFormat(ImAxis_X1, \"%g ms\");\n            ImPlot::SetupAxisFormat(ImAxis_Y1, MetricFormatter, (void*)\"Hz\");\n            ImPlot::SetupAxisFormat(ImAxis_Y2, \"%g dB\");\n            ImPlot::SetupAxisFormat(ImAxis_Y3, MetricFormatter, (void*)\"m\");\n        }\n        if (custom_ticks) {\n            ImPlot::SetupAxisTicks(ImAxis_X1, &pi,1,custom_labels ? pi_str : nullptr, true);\n            ImPlot::SetupAxisTicks(ImAxis_Y1, yticks, 4, custom_labels ? ylabels : nullptr, false);\n            ImPlot::SetupAxisTicks(ImAxis_Y2, yticks_aux, 3, custom_labels ? ylabels_aux : nullptr, false);\n            ImPlot::SetupAxisTicks(ImAxis_Y3, 0, 1, 6, custom_labels ? ylabels_aux : nullptr, false);\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_CustomStyles() {\n    ImPlot::PushColormap(ImPlotColormap_Deep);\n    // normally you wouldn't change the entire style each frame\n    ImPlotStyle backup = ImPlot::GetStyle();\n    MyImPlot::StyleSeaborn();\n    if (ImPlot::BeginPlot(\"seaborn style\")) {\n        ImPlot::SetupAxes( \"x-axis\", \"y-axis\");\n        ImPlot::SetupAxesLimits(-0.5f, 9.5f, 0, 10);\n        unsigned int lin[10] = {8,8,9,7,8,8,8,9,7,8};\n        unsigned int bar[10] = {1,2,5,3,4,1,2,5,3,4};\n        unsigned int dot[10] = {7,6,6,7,8,5,6,5,8,7};\n        ImPlot::PlotBars(\"Bars\", bar, 10, 0.5f);\n        ImPlot::PlotLine(\"Line\", lin, 10);\n        ImPlot::NextColormapColor(); // skip green\n        ImPlot::PlotScatter(\"Scatter\", dot, 10);\n        ImPlot::EndPlot();\n    }\n    ImPlot::GetStyle() = backup;\n    ImPlot::PopColormap();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_CustomRendering() {\n    if (ImPlot::BeginPlot(\"##CustomRend\")) {\n        ImVec2 cntr = ImPlot::PlotToPixels(ImPlotPoint(0.5f,  0.5f));\n        ImVec2 rmin = ImPlot::PlotToPixels(ImPlotPoint(0.25f, 0.75f));\n        ImVec2 rmax = ImPlot::PlotToPixels(ImPlotPoint(0.75f, 0.25f));\n        ImPlot::PushPlotClipRect();\n        ImPlot::GetPlotDrawList()->AddCircleFilled(cntr,20,IM_COL32(255,255,0,255),20);\n        ImPlot::GetPlotDrawList()->AddRect(rmin, rmax, IM_COL32(128,0,255,255));\n        ImPlot::PopPlotClipRect();\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_LegendPopups() {\n    ImGui::BulletText(\"You can implement legend context menus to inject per-item controls and widgets.\");\n    ImGui::BulletText(\"Right click the legend label/icon to edit custom item attributes.\");\n\n    static float  frequency = 0.1f;\n    static float  amplitude = 0.5f;\n    static ImVec4 color     = ImVec4(1,1,0,1);\n    static float  alpha     = 1.0f;\n    static bool   line      = false;\n    static float  thickness = 1;\n    static bool   markers   = false;\n    static bool   shaded    = false;\n\n    static float vals[101];\n    for (int i = 0; i < 101; ++i)\n        vals[i] = amplitude * sinf(frequency * i);\n\n    if (ImPlot::BeginPlot(\"Right Click the Legend\")) {\n        ImPlot::SetupAxesLimits(0,100,-1,1);\n        // rendering logic\n        ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, alpha);\n        if (!line) {\n            ImPlot::SetNextFillStyle(color);\n            ImPlot::PlotBars(\"Right Click Me\", vals, 101);\n        }\n        else {\n            if (markers) ImPlot::SetNextMarkerStyle(ImPlotMarker_Square);\n            ImPlot::SetNextLineStyle(color, thickness);\n            ImPlot::PlotLine(\"Right Click Me\", vals, 101);\n            if (shaded) ImPlot::PlotShaded(\"Right Click Me\",vals,101);\n        }\n        ImPlot::PopStyleVar();\n        // custom legend context menu\n        if (ImPlot::BeginLegendPopup(\"Right Click Me\")) {\n            ImGui::SliderFloat(\"Frequency\",&frequency,0,1,\"%0.2f\");\n            ImGui::SliderFloat(\"Amplitude\",&amplitude,0,1,\"%0.2f\");\n            ImGui::Separator();\n            ImGui::ColorEdit3(\"Color\",&color.x);\n            ImGui::SliderFloat(\"Transparency\",&alpha,0,1,\"%.2f\");\n            ImGui::Checkbox(\"Line Plot\", &line);\n            if (line) {\n                ImGui::SliderFloat(\"Thickness\", &thickness, 0, 5);\n                ImGui::Checkbox(\"Markers\", &markers);\n                ImGui::Checkbox(\"Shaded\",&shaded);\n            }\n            ImPlot::EndLegendPopup();\n        }\n        ImPlot::EndPlot();\n    }\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_ColormapWidgets() {\n    static int cmap = ImPlotColormap_Viridis;\n\n    if (ImPlot::ColormapButton(\"Button\",ImVec2(0,0),cmap)) {\n        cmap = (cmap + 1) % ImPlot::GetColormapCount();\n    }\n\n    static float t = 0.5f;\n    static ImVec4 col;\n    ImGui::ColorButton(\"##Display\",col,ImGuiColorEditFlags_NoInputs);\n    ImGui::SameLine();\n    ImPlot::ColormapSlider(\"Slider\", &t, &col, \"%.3f\", cmap);\n\n    ImPlot::ColormapIcon(cmap); ImGui::SameLine(); ImGui::Text(\"Icon\");\n\n    static ImPlotColormapScaleFlags flags = 0;\n    static float scale[2] = {0, 100};\n    ImPlot::ColormapScale(\"Scale\",scale[0],scale[1],ImVec2(0,0),\"%g dB\",flags,cmap);\n    ImGui::InputFloat2(\"Scale\",scale);\n    CHECKBOX_FLAG(flags, ImPlotColormapScaleFlags_NoLabel);\n    CHECKBOX_FLAG(flags, ImPlotColormapScaleFlags_Opposite);\n    CHECKBOX_FLAG(flags, ImPlotColormapScaleFlags_Invert);\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Demo_CustomPlottersAndTooltips()  {\n    ImGui::BulletText(\"You can create custom plotters or extend ImPlot using implot_internal.h.\");\n    double dates[]  = {1546300800,1546387200,1546473600,1546560000,1546819200,1546905600,1546992000,1547078400,1547164800,1547424000,1547510400,1547596800,1547683200,1547769600,1547942400,1548028800,1548115200,1548201600,1548288000,1548374400,1548633600,1548720000,1548806400,1548892800,1548979200,1549238400,1549324800,1549411200,1549497600,1549584000,1549843200,1549929600,1550016000,1550102400,1550188800,1550361600,1550448000,1550534400,1550620800,1550707200,1550793600,1551052800,1551139200,1551225600,1551312000,1551398400,1551657600,1551744000,1551830400,1551916800,1552003200,1552262400,1552348800,1552435200,1552521600,1552608000,1552867200,1552953600,1553040000,1553126400,1553212800,1553472000,1553558400,1553644800,1553731200,1553817600,1554076800,1554163200,1554249600,1554336000,1554422400,1554681600,1554768000,1554854400,1554940800,1555027200,1555286400,1555372800,1555459200,1555545600,1555632000,1555891200,1555977600,1556064000,1556150400,1556236800,1556496000,1556582400,1556668800,1556755200,1556841600,1557100800,1557187200,1557273600,1557360000,1557446400,1557705600,1557792000,1557878400,1557964800,1558051200,1558310400,1558396800,1558483200,1558569600,1558656000,1558828800,1558915200,1559001600,1559088000,1559174400,1559260800,1559520000,1559606400,1559692800,1559779200,1559865600,1560124800,1560211200,1560297600,1560384000,1560470400,1560729600,1560816000,1560902400,1560988800,1561075200,1561334400,1561420800,1561507200,1561593600,1561680000,1561939200,1562025600,1562112000,1562198400,1562284800,1562544000,1562630400,1562716800,1562803200,1562889600,1563148800,1563235200,1563321600,1563408000,1563494400,1563753600,1563840000,1563926400,1564012800,1564099200,1564358400,1564444800,1564531200,1564617600,1564704000,1564963200,1565049600,1565136000,1565222400,1565308800,1565568000,1565654400,1565740800,1565827200,1565913600,1566172800,1566259200,1566345600,1566432000,1566518400,1566777600,1566864000,1566950400,1567036800,1567123200,1567296000,1567382400,1567468800,1567555200,1567641600,1567728000,1567987200,1568073600,1568160000,1568246400,1568332800,1568592000,1568678400,1568764800,1568851200,1568937600,1569196800,1569283200,1569369600,1569456000,1569542400,1569801600,1569888000,1569974400,1570060800,1570147200,1570406400,1570492800,1570579200,1570665600,1570752000,1571011200,1571097600,1571184000,1571270400,1571356800,1571616000,1571702400,1571788800,1571875200,1571961600};\n    double opens[]  = {1284.7,1319.9,1318.7,1328,1317.6,1321.6,1314.3,1325,1319.3,1323.1,1324.7,1321.3,1323.5,1322,1281.3,1281.95,1311.1,1315,1314,1313.1,1331.9,1334.2,1341.3,1350.6,1349.8,1346.4,1343.4,1344.9,1335.6,1337.9,1342.5,1337,1338.6,1337,1340.4,1324.65,1324.35,1349.5,1371.3,1367.9,1351.3,1357.8,1356.1,1356,1347.6,1339.1,1320.6,1311.8,1314,1312.4,1312.3,1323.5,1319.1,1327.2,1332.1,1320.3,1323.1,1328,1330.9,1338,1333,1335.3,1345.2,1341.1,1332.5,1314,1314.4,1310.7,1314,1313.1,1315,1313.7,1320,1326.5,1329.2,1314.2,1312.3,1309.5,1297.4,1293.7,1277.9,1295.8,1295.2,1290.3,1294.2,1298,1306.4,1299.8,1302.3,1297,1289.6,1302,1300.7,1303.5,1300.5,1303.2,1306,1318.7,1315,1314.5,1304.1,1294.7,1293.7,1291.2,1290.2,1300.4,1284.2,1284.25,1301.8,1295.9,1296.2,1304.4,1323.1,1340.9,1341,1348,1351.4,1351.4,1343.5,1342.3,1349,1357.6,1357.1,1354.7,1361.4,1375.2,1403.5,1414.7,1433.2,1438,1423.6,1424.4,1418,1399.5,1435.5,1421.25,1434.1,1412.4,1409.8,1412.2,1433.4,1418.4,1429,1428.8,1420.6,1441,1460.4,1441.7,1438.4,1431,1439.3,1427.4,1431.9,1439.5,1443.7,1425.6,1457.5,1451.2,1481.1,1486.7,1512.1,1515.9,1509.2,1522.3,1513,1526.6,1533.9,1523,1506.3,1518.4,1512.4,1508.8,1545.4,1537.3,1551.8,1549.4,1536.9,1535.25,1537.95,1535.2,1556,1561.4,1525.6,1516.4,1507,1493.9,1504.9,1506.5,1513.1,1506.5,1509.7,1502,1506.8,1521.5,1529.8,1539.8,1510.9,1511.8,1501.7,1478,1485.4,1505.6,1511.6,1518.6,1498.7,1510.9,1510.8,1498.3,1492,1497.7,1484.8,1494.2,1495.6,1495.6,1487.5,1491.1,1495.1,1506.4};\n    double highs[]  = {1284.75,1320.6,1327,1330.8,1326.8,1321.6,1326,1328,1325.8,1327.1,1326,1326,1323.5,1322.1,1282.7,1282.95,1315.8,1316.3,1314,1333.2,1334.7,1341.7,1353.2,1354.6,1352.2,1346.4,1345.7,1344.9,1340.7,1344.2,1342.7,1342.1,1345.2,1342,1350,1324.95,1330.75,1369.6,1374.3,1368.4,1359.8,1359,1357,1356,1353.4,1340.6,1322.3,1314.1,1316.1,1312.9,1325.7,1323.5,1326.3,1336,1332.1,1330.1,1330.4,1334.7,1341.1,1344.2,1338.8,1348.4,1345.6,1342.8,1334.7,1322.3,1319.3,1314.7,1316.6,1316.4,1315,1325.4,1328.3,1332.2,1329.2,1316.9,1312.3,1309.5,1299.6,1296.9,1277.9,1299.5,1296.2,1298.4,1302.5,1308.7,1306.4,1305.9,1307,1297.2,1301.7,1305,1305.3,1310.2,1307,1308,1319.8,1321.7,1318.7,1316.2,1305.9,1295.8,1293.8,1293.7,1304.2,1302,1285.15,1286.85,1304,1302,1305.2,1323,1344.1,1345.2,1360.1,1355.3,1363.8,1353,1344.7,1353.6,1358,1373.6,1358.2,1369.6,1377.6,1408.9,1425.5,1435.9,1453.7,1438,1426,1439.1,1418,1435,1452.6,1426.65,1437.5,1421.5,1414.1,1433.3,1441.3,1431.4,1433.9,1432.4,1440.8,1462.3,1467,1443.5,1444,1442.9,1447,1437.6,1440.8,1445.7,1447.8,1458.2,1461.9,1481.8,1486.8,1522.7,1521.3,1521.1,1531.5,1546.1,1534.9,1537.7,1538.6,1523.6,1518.8,1518.4,1514.6,1540.3,1565,1554.5,1556.6,1559.8,1541.9,1542.9,1540.05,1558.9,1566.2,1561.9,1536.2,1523.8,1509.1,1506.2,1532.2,1516.6,1519.7,1515,1519.5,1512.1,1524.5,1534.4,1543.3,1543.3,1542.8,1519.5,1507.2,1493.5,1511.4,1525.8,1522.2,1518.8,1515.3,1518,1522.3,1508,1501.5,1503,1495.5,1501.1,1497.9,1498.7,1492.1,1499.4,1506.9,1520.9};\n    double lows[]   = {1282.85,1315,1318.7,1309.6,1317.6,1312.9,1312.4,1319.1,1319,1321,1318.1,1321.3,1319.9,1312,1280.5,1276.15,1308,1309.9,1308.5,1312.3,1329.3,1333.1,1340.2,1347,1345.9,1338,1340.8,1335,1332,1337.9,1333,1336.8,1333.2,1329.9,1340.4,1323.85,1324.05,1349,1366.3,1351.2,1349.1,1352.4,1350.7,1344.3,1338.9,1316.3,1308.4,1306.9,1309.6,1306.7,1312.3,1315.4,1319,1327.2,1317.2,1320,1323,1328,1323,1327.8,1331.7,1335.3,1336.6,1331.8,1311.4,1310,1309.5,1308,1310.6,1302.8,1306.6,1313.7,1320,1322.8,1311,1312.1,1303.6,1293.9,1293.5,1291,1277.9,1294.1,1286,1289.1,1293.5,1296.9,1298,1299.6,1292.9,1285.1,1288.5,1296.3,1297.2,1298.4,1298.6,1302,1300.3,1312,1310.8,1301.9,1292,1291.1,1286.3,1289.2,1289.9,1297.4,1283.65,1283.25,1292.9,1295.9,1290.8,1304.2,1322.7,1336.1,1341,1343.5,1345.8,1340.3,1335.1,1341.5,1347.6,1352.8,1348.2,1353.7,1356.5,1373.3,1398,1414.7,1427,1416.4,1412.7,1420.1,1396.4,1398.8,1426.6,1412.85,1400.7,1406,1399.8,1404.4,1415.5,1417.2,1421.9,1415,1413.7,1428.1,1434,1435.7,1427.5,1429.4,1423.9,1425.6,1427.5,1434.8,1422.3,1412.1,1442.5,1448.8,1468.2,1484.3,1501.6,1506.2,1498.6,1488.9,1504.5,1518.3,1513.9,1503.3,1503,1506.5,1502.1,1503,1534.8,1535.3,1541.4,1528.6,1525.6,1535.25,1528.15,1528,1542.6,1514.3,1510.7,1505.5,1492.1,1492.9,1496.8,1493.1,1503.4,1500.9,1490.7,1496.3,1505.3,1505.3,1517.9,1507.4,1507.1,1493.3,1470.5,1465,1480.5,1501.7,1501.4,1493.3,1492.1,1505.1,1495.7,1478,1487.1,1480.8,1480.6,1487,1488.3,1484.8,1484,1490.7,1490.4,1503.1};\n    double closes[] = {1283.35,1315.3,1326.1,1317.4,1321.5,1317.4,1323.5,1319.2,1321.3,1323.3,1319.7,1325.1,1323.6,1313.8,1282.05,1279.05,1314.2,1315.2,1310.8,1329.1,1334.5,1340.2,1340.5,1350,1347.1,1344.3,1344.6,1339.7,1339.4,1343.7,1337,1338.9,1340.1,1338.7,1346.8,1324.25,1329.55,1369.6,1372.5,1352.4,1357.6,1354.2,1353.4,1346,1341,1323.8,1311.9,1309.1,1312.2,1310.7,1324.3,1315.7,1322.4,1333.8,1319.4,1327.1,1325.8,1330.9,1325.8,1331.6,1336.5,1346.7,1339.2,1334.7,1313.3,1316.5,1312.4,1313.4,1313.3,1312.2,1313.7,1319.9,1326.3,1331.9,1311.3,1313.4,1309.4,1295.2,1294.7,1294.1,1277.9,1295.8,1291.2,1297.4,1297.7,1306.8,1299.4,1303.6,1302.2,1289.9,1299.2,1301.8,1303.6,1299.5,1303.2,1305.3,1319.5,1313.6,1315.1,1303.5,1293,1294.6,1290.4,1291.4,1302.7,1301,1284.15,1284.95,1294.3,1297.9,1304.1,1322.6,1339.3,1340.1,1344.9,1354,1357.4,1340.7,1342.7,1348.2,1355.1,1355.9,1354.2,1362.1,1360.1,1408.3,1411.2,1429.5,1430.1,1426.8,1423.4,1425.1,1400.8,1419.8,1432.9,1423.55,1412.1,1412.2,1412.8,1424.9,1419.3,1424.8,1426.1,1423.6,1435.9,1440.8,1439.4,1439.7,1434.5,1436.5,1427.5,1432.2,1433.3,1441.8,1437.8,1432.4,1457.5,1476.5,1484.2,1519.6,1509.5,1508.5,1517.2,1514.1,1527.8,1531.2,1523.6,1511.6,1515.7,1515.7,1508.5,1537.6,1537.2,1551.8,1549.1,1536.9,1529.4,1538.05,1535.15,1555.9,1560.4,1525.5,1515.5,1511.1,1499.2,1503.2,1507.4,1499.5,1511.5,1513.4,1515.8,1506.2,1515.1,1531.5,1540.2,1512.3,1515.2,1506.4,1472.9,1489,1507.9,1513.8,1512.9,1504.4,1503.9,1512.8,1500.9,1488.7,1497.6,1483.5,1494,1498.3,1494.1,1488.1,1487.5,1495.7,1504.7,1505.3};\n    static bool tooltip = true;\n    ImGui::Checkbox(\"Show Tooltip\", &tooltip);\n    ImGui::SameLine();\n    static ImVec4 bullCol = ImVec4(0.000f, 1.000f, 0.441f, 1.000f);\n    static ImVec4 bearCol = ImVec4(0.853f, 0.050f, 0.310f, 1.000f);\n    ImGui::SameLine(); ImGui::ColorEdit4(\"##Bull\", &bullCol.x, ImGuiColorEditFlags_NoInputs);\n    ImGui::SameLine(); ImGui::ColorEdit4(\"##Bear\", &bearCol.x, ImGuiColorEditFlags_NoInputs);\n    ImPlot::GetStyle().UseLocalTime = false;\n\n    if (ImPlot::BeginPlot(\"Candlestick Chart\",ImVec2(-1,0))) {\n        ImPlot::SetupAxes(nullptr,nullptr,0,ImPlotAxisFlags_AutoFit|ImPlotAxisFlags_RangeFit);\n        ImPlot::SetupAxesLimits(1546300800, 1571961600, 1250, 1600);\n        ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_Time);\n        ImPlot::SetupAxisLimitsConstraints(ImAxis_X1, 1546300800, 1571961600);\n        ImPlot::SetupAxisZoomConstraints(ImAxis_X1, 60*60*24*14, 1571961600-1546300800);\n        ImPlot::SetupAxisFormat(ImAxis_Y1, \"$%.0f\");\n        MyImPlot::PlotCandlestick(\"GOOGL\",dates, opens, closes, lows, highs, 218, tooltip, 0.25f, bullCol, bearCol);\n        ImPlot::EndPlot();\n    }\n    }\n\n//-----------------------------------------------------------------------------\n// DEMO WINDOW\n//-----------------------------------------------------------------------------\n\nvoid DemoHeader(const char* label, void(*demo)()) {\n    if (ImGui::TreeNodeEx(label)) {\n        demo();\n        ImGui::TreePop();\n    }\n}\n\nvoid ShowDemoWindow(bool* p_open) {\n    static bool show_implot_metrics      = false;\n    static bool show_implot_style_editor = false;\n    static bool show_imgui_metrics       = false;\n    static bool show_imgui_style_editor  = false;\n    static bool show_imgui_demo          = false;\n\n    if (show_implot_metrics) {\n        ImPlot::ShowMetricsWindow(&show_implot_metrics);\n    }\n    if (show_implot_style_editor) {\n        ImGui::SetNextWindowSize(ImVec2(415,762), ImGuiCond_Appearing);\n        ImGui::Begin(\"Style Editor (ImPlot)\", &show_implot_style_editor);\n        ImPlot::ShowStyleEditor();\n        ImGui::End();\n    }\n    if (show_imgui_style_editor) {\n        ImGui::Begin(\"Style Editor (ImGui)\", &show_imgui_style_editor);\n        ImGui::ShowStyleEditor();\n        ImGui::End();\n    }\n    if (show_imgui_metrics) {\n        ImGui::ShowMetricsWindow(&show_imgui_metrics);\n    }\n    if (show_imgui_demo) {\n        ImGui::ShowDemoWindow(&show_imgui_demo);\n    }\n    ImGui::SetNextWindowPos(ImVec2(50, 50), ImGuiCond_FirstUseEver);\n    ImGui::SetNextWindowSize(ImVec2(600, 750), ImGuiCond_FirstUseEver);\n    ImGui::Begin(\"ImPlot Demo\", p_open, ImGuiWindowFlags_MenuBar);\n    if (ImGui::BeginMenuBar()) {\n        if (ImGui::BeginMenu(\"Tools\")) {\n            ImGui::MenuItem(\"Metrics\",      nullptr, &show_implot_metrics);\n            ImGui::MenuItem(\"Style Editor\", nullptr, &show_implot_style_editor);\n            ImGui::Separator();\n            ImGui::MenuItem(\"ImGui Metrics\",       nullptr, &show_imgui_metrics);\n            ImGui::MenuItem(\"ImGui Style Editor\",  nullptr, &show_imgui_style_editor);\n            ImGui::MenuItem(\"ImGui Demo\",          nullptr, &show_imgui_demo);\n            ImGui::EndMenu();\n        }\n        ImGui::EndMenuBar();\n    }\n    //-------------------------------------------------------------------------\n    ImGui::Text(\"ImPlot says hello. (%s)\", IMPLOT_VERSION);\n    // display warning about 16-bit indices\n    static bool showWarning = sizeof(ImDrawIdx)*8 == 16 && (ImGui::GetIO().BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset) == false;\n    if (showWarning) {\n        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1,1,0,1));\n        ImGui::TextWrapped(\"WARNING: ImDrawIdx is 16-bit and ImGuiBackendFlags_RendererHasVtxOffset is false. Expect visual glitches and artifacts! See README for more information.\");\n        ImGui::PopStyleColor();\n    }\n\n    ImGui::Spacing();\n\n    if (ImGui::BeginTabBar(\"ImPlotDemoTabs\")) {\n        if (ImGui::BeginTabItem(\"Plots\")) {\n            DemoHeader(\"Line Plots\", Demo_LinePlots);\n            DemoHeader(\"Filled Line Plots\", Demo_FilledLinePlots);\n            DemoHeader(\"Shaded Plots##\", Demo_ShadedPlots);\n            DemoHeader(\"Scatter Plots\", Demo_ScatterPlots);\n            DemoHeader(\"Realtime Plots\", Demo_RealtimePlots);\n            DemoHeader(\"Stairstep Plots\", Demo_StairstepPlots);\n            DemoHeader(\"Bar Plots\", Demo_BarPlots);\n            DemoHeader(\"Bar Groups\", Demo_BarGroups);\n            DemoHeader(\"Bar Stacks\", Demo_BarStacks);\n            DemoHeader(\"Error Bars\", Demo_ErrorBars);\n            DemoHeader(\"Stem Plots##\", Demo_StemPlots);\n            DemoHeader(\"Infinite Lines\", Demo_InfiniteLines);\n            DemoHeader(\"Pie Charts\", Demo_PieCharts);\n            DemoHeader(\"Heatmaps\", Demo_Heatmaps);\n            DemoHeader(\"Histogram\", Demo_Histogram);\n            DemoHeader(\"Histogram 2D\", Demo_Histogram2D);\n            DemoHeader(\"Digital Plots\", Demo_DigitalPlots);\n            DemoHeader(\"Images\", Demo_Images);\n            DemoHeader(\"Markers and Text\", Demo_MarkersAndText);\n            DemoHeader(\"NaN Values\", Demo_NaNValues);\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Subplots\")) {\n            DemoHeader(\"Sizing\", Demo_SubplotsSizing);\n            DemoHeader(\"Item Sharing\", Demo_SubplotItemSharing);\n            DemoHeader(\"Axis Linking\", Demo_SubplotAxisLinking);\n            DemoHeader(\"Tables\", Demo_Tables);\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Axes\")) {\n            DemoHeader(\"Log Scale\", Demo_LogScale);\n            DemoHeader(\"Symmetric Log Scale\", Demo_SymmetricLogScale);\n            DemoHeader(\"Time Scale\", Demo_TimeScale);\n            DemoHeader(\"Custom Scale\", Demo_CustomScale);\n            DemoHeader(\"Multiple Axes\", Demo_MultipleAxes);\n            DemoHeader(\"Tick Labels\", Demo_TickLabels);\n            DemoHeader(\"Linked Axes\", Demo_LinkedAxes);\n            DemoHeader(\"Axis Constraints\", Demo_AxisConstraints);\n            DemoHeader(\"Equal Axes\", Demo_EqualAxes);\n            DemoHeader(\"Auto-Fitting Data\", Demo_AutoFittingData);\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Tools\")) {\n            DemoHeader(\"Offset and Stride\", Demo_OffsetAndStride);\n            DemoHeader(\"Drag Points\", Demo_DragPoints);\n            DemoHeader(\"Drag Lines\", Demo_DragLines);\n            DemoHeader(\"Drag Rects\", Demo_DragRects);\n            DemoHeader(\"Querying\", Demo_Querying);\n            DemoHeader(\"Annotations\", Demo_Annotations);\n            DemoHeader(\"Tags\", Demo_Tags);\n            DemoHeader(\"Drag and Drop\", Demo_DragAndDrop);\n            DemoHeader(\"Legend Options\", Demo_LegendOptions);\n            DemoHeader(\"Legend Popups\", Demo_LegendPopups);\n            DemoHeader(\"Colormap Widgets\", Demo_ColormapWidgets);\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Custom\")) {\n            DemoHeader(\"Custom Styles\", Demo_CustomStyles);\n            DemoHeader(\"Custom Data and Getters\", Demo_CustomDataAndGetters);\n            DemoHeader(\"Custom Rendering\", Demo_CustomRendering);\n            DemoHeader(\"Custom Plotters and Tooltips\", Demo_CustomPlottersAndTooltips);\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Config\")) {\n            Demo_Config();\n            ImGui::EndTabItem();\n        }\n        if (ImGui::BeginTabItem(\"Help\")) {\n            Demo_Help();\n            ImGui::EndTabItem();\n        }\n        ImGui::EndTabBar();\n    }\n    ImGui::End();\n}\n\n} // namespace ImPlot\n\nnamespace MyImPlot {\n\nImPlotPoint SineWave(int idx, void* data) {\n    WaveData* wd = (WaveData*)data;\n    double x = idx * wd->X;\n    return ImPlotPoint(x, wd->Offset + wd->Amp * sin(2 * 3.14 * wd->Freq * x));\n}\n\nImPlotPoint SawWave(int idx, void* data) {\n    WaveData* wd = (WaveData*)data;\n    double x = idx * wd->X;\n    return ImPlotPoint(x, wd->Offset + wd->Amp * (-2 / 3.14 * atan(cos(3.14 * wd->Freq * x) / sin(3.14 * wd->Freq * x))));\n}\n\nImPlotPoint Spiral(int idx, void*) {\n    float r = 0.9f;            // outer radius\n    float a = 0;               // inner radius\n    float b = 0.05f;           // increment per rev\n    float n = (r - a) / b;     // number  of revolutions\n    double th = 2 * n * 3.14;  // angle\n    float Th = float(th * idx / (1000 - 1));\n    return ImPlotPoint(0.5f+(a + b*Th / (2.0f * (float) 3.14))*cos(Th),\n                       0.5f + (a + b*Th / (2.0f * (float)3.14))*sin(Th));\n}\n\nvoid Sparkline(const char* id, const float* values, int count, float min_v, float max_v, int offset, const ImVec4& col, const ImVec2& size) {\n    ImPlot::PushStyleVar(ImPlotStyleVar_PlotPadding, ImVec2(0,0));\n    if (ImPlot::BeginPlot(id,size,ImPlotFlags_CanvasOnly)) {\n        ImPlot::SetupAxes(nullptr,nullptr,ImPlotAxisFlags_NoDecorations,ImPlotAxisFlags_NoDecorations);\n        ImPlot::SetupAxesLimits(0, count - 1, min_v, max_v, ImGuiCond_Always);\n        ImPlot::SetNextLineStyle(col);\n        ImPlot::SetNextFillStyle(col, 0.25);\n        ImPlot::PlotLine(id, values, count, 1, 0, ImPlotLineFlags_Shaded, offset);\n        ImPlot::EndPlot();\n    }\n    ImPlot::PopStyleVar();\n}\n\nvoid StyleSeaborn() {\n\n    ImPlotStyle& style              = ImPlot::GetStyle();\n\n    ImVec4* colors                  = style.Colors;\n    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;\n    colors[ImPlotCol_ErrorBar]      = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_FrameBg]       = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_PlotBg]        = ImVec4(0.92f, 0.92f, 0.95f, 1.00f);\n    colors[ImPlotCol_PlotBorder]    = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImPlotCol_LegendBg]      = ImVec4(0.92f, 0.92f, 0.95f, 1.00f);\n    colors[ImPlotCol_LegendBorder]  = ImVec4(0.80f, 0.81f, 0.85f, 1.00f);\n    colors[ImPlotCol_LegendText]    = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_TitleText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_InlayText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_AxisText]      = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImPlotCol_AxisGrid]      = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImPlotCol_AxisBgHovered]   = ImVec4(0.92f, 0.92f, 0.95f, 1.00f);\n    colors[ImPlotCol_AxisBgActive]    = ImVec4(0.92f, 0.92f, 0.95f, 0.75f);\n    colors[ImPlotCol_Selection]     = ImVec4(1.00f, 0.65f, 0.00f, 1.00f);\n    colors[ImPlotCol_Crosshairs]    = ImVec4(0.23f, 0.10f, 0.64f, 0.50f);\n\n    style.LineWeight       = 1.5;\n    style.Marker           = ImPlotMarker_None;\n    style.MarkerSize       = 4;\n    style.MarkerWeight     = 1;\n    style.FillAlpha        = 1.0f;\n    style.ErrorBarSize     = 5;\n    style.ErrorBarWeight   = 1.5f;\n    style.DigitalBitHeight = 8;\n    style.DigitalBitGap    = 4;\n    style.PlotBorderSize   = 0;\n    style.MinorAlpha       = 1.0f;\n    style.MajorTickLen     = ImVec2(0,0);\n    style.MinorTickLen     = ImVec2(0,0);\n    style.MajorTickSize    = ImVec2(0,0);\n    style.MinorTickSize    = ImVec2(0,0);\n    style.MajorGridSize    = ImVec2(1.2f,1.2f);\n    style.MinorGridSize    = ImVec2(1.2f,1.2f);\n    style.PlotPadding      = ImVec2(12,12);\n    style.LabelPadding     = ImVec2(5,5);\n    style.LegendPadding    = ImVec2(5,5);\n    style.MousePosPadding  = ImVec2(5,5);\n    style.PlotMinSize      = ImVec2(300,225);\n}\n\n} // namespaece MyImPlot\n\n// WARNING:\n//\n// You can use \"implot_internal.h\" to build custom plotting fuctions or extend ImPlot.\n// However, note that forward compatibility of this file is not guaranteed and the\n// internal API is subject to change. At some point we hope to bring more of this\n// into the public API and expose the necessary building blocks to fully support\n// custom plotters. For now, proceed at your own risk!\n\n#include \"implot_internal.h\"\n\nnamespace MyImPlot {\n\ntemplate <typename T>\nint BinarySearch(const T* arr, int l, int r, T x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return BinarySearch(arr, l, mid - 1, x);\n        return BinarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\nvoid PlotCandlestick(const char* label_id, const double* xs, const double* opens, const double* closes, const double* lows, const double* highs, int count, bool tooltip, float width_percent, ImVec4 bullCol, ImVec4 bearCol) {\n\n    // get ImGui window DrawList\n    ImDrawList* draw_list = ImPlot::GetPlotDrawList();\n    // calc real value width\n    double half_width = count > 1 ? (xs[1] - xs[0]) * width_percent : width_percent;\n\n    // custom tool\n    if (ImPlot::IsPlotHovered() && tooltip) {\n        ImPlotPoint mouse   = ImPlot::GetPlotMousePos();\n        mouse.x             = ImPlot::RoundTime(ImPlotTime::FromDouble(mouse.x), ImPlotTimeUnit_Day).ToDouble();\n        float  tool_l       = ImPlot::PlotToPixels(mouse.x - half_width * 1.5, mouse.y).x;\n        float  tool_r       = ImPlot::PlotToPixels(mouse.x + half_width * 1.5, mouse.y).x;\n        float  tool_t       = ImPlot::GetPlotPos().y;\n        float  tool_b       = tool_t + ImPlot::GetPlotSize().y;\n        ImPlot::PushPlotClipRect();\n        draw_list->AddRectFilled(ImVec2(tool_l, tool_t), ImVec2(tool_r, tool_b), IM_COL32(128,128,128,64));\n        ImPlot::PopPlotClipRect();\n        // find mouse location index\n        int idx = BinarySearch(xs, 0, count - 1, mouse.x);\n        // render tool tip (won't be affected by plot clip rect)\n        if (idx != -1) {\n            ImGui::BeginTooltip();\n            char buff[32];\n            ImPlot::FormatDate(ImPlotTime::FromDouble(xs[idx]),buff,32,ImPlotDateFmt_DayMoYr,ImPlot::GetStyle().UseISO8601);\n            ImGui::Text(\"Day:   %s\",  buff);\n            ImGui::Text(\"Open:  $%.2f\", opens[idx]);\n            ImGui::Text(\"Close: $%.2f\", closes[idx]);\n            ImGui::Text(\"Low:   $%.2f\", lows[idx]);\n            ImGui::Text(\"High:  $%.2f\", highs[idx]);\n            ImGui::EndTooltip();\n        }\n    }\n\n    // begin plot item\n    if (ImPlot::BeginItem(label_id)) {\n        // override legend icon color\n        ImPlot::GetCurrentItem()->Color = IM_COL32(64,64,64,255);\n        // fit data if requested\n        if (ImPlot::FitThisFrame()) {\n            for (int i = 0; i < count; ++i) {\n                ImPlot::FitPoint(ImPlotPoint(xs[i], lows[i]));\n                ImPlot::FitPoint(ImPlotPoint(xs[i], highs[i]));\n            }\n        }\n        // render data\n        for (int i = 0; i < count; ++i) {\n            ImVec2 open_pos  = ImPlot::PlotToPixels(xs[i] - half_width, opens[i]);\n            ImVec2 close_pos = ImPlot::PlotToPixels(xs[i] + half_width, closes[i]);\n            ImVec2 low_pos   = ImPlot::PlotToPixels(xs[i], lows[i]);\n            ImVec2 high_pos  = ImPlot::PlotToPixels(xs[i], highs[i]);\n            ImU32 color      = ImGui::GetColorU32(opens[i] > closes[i] ? bearCol : bullCol);\n            draw_list->AddLine(low_pos, high_pos, color);\n            draw_list->AddRectFilled(open_pos, close_pos, color);\n        }\n\n        // end plot item\n        ImPlot::EndItem();\n    }\n}\n\n} // namespace MyImplot\n\n#else\n\nvoid ImPlot::ShowDemoWindow(bool* p_open) {}\n\n#endif\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "implot_internal.h",
          "type": "blob",
          "size": 66.8681640625,
          "content": "// MIT License\n\n// Copyright (c) 2023 Evan Pezent\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// ImPlot v0.17\n\n// You may use this file to debug, understand or extend ImPlot features but we\n// don't provide any guarantee of forward compatibility!\n\n//-----------------------------------------------------------------------------\n// [SECTION] Header Mess\n//-----------------------------------------------------------------------------\n\n#pragma once\n\n#ifndef IMPLOT_VERSION\n#error Must include implot.h before implot_internal.h\n#endif\n\n#ifndef IMGUI_DISABLE\n#include <time.h>\n#include \"imgui_internal.h\"\n\n// Support for pre-1.84 versions. ImPool's GetSize() -> GetBufSize()\n#if (IMGUI_VERSION_NUM < 18303)\n#define GetBufSize GetSize\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Constants\n//-----------------------------------------------------------------------------\n\n// Constants can be changed unless stated otherwise. We may move some of these\n// to ImPlotStyleVar_ over time.\n\n// Mimimum allowable timestamp value 01/01/1970 @ 12:00am (UTC) (DO NOT DECREASE THIS)\n#define IMPLOT_MIN_TIME  0\n// Maximum allowable timestamp value 01/01/3000 @ 12:00am (UTC) (DO NOT INCREASE THIS)\n#define IMPLOT_MAX_TIME  32503680000\n// Default label format for axis labels\n#define IMPLOT_LABEL_FORMAT \"%g\"\n// Max character size for tick labels\n#define IMPLOT_LABEL_MAX_SIZE 32\n\n//-----------------------------------------------------------------------------\n// [SECTION] Macros\n//-----------------------------------------------------------------------------\n\n#define IMPLOT_NUM_X_AXES ImAxis_Y1\n#define IMPLOT_NUM_Y_AXES (ImAxis_COUNT - IMPLOT_NUM_X_AXES)\n\n// Split ImU32 color into RGB components [0 255]\n#define IM_COL32_SPLIT_RGB(col,r,g,b) \\\n    ImU32 r = ((col >> IM_COL32_R_SHIFT) & 0xFF); \\\n    ImU32 g = ((col >> IM_COL32_G_SHIFT) & 0xFF); \\\n    ImU32 b = ((col >> IM_COL32_B_SHIFT) & 0xFF);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Forward Declarations\n//-----------------------------------------------------------------------------\n\nstruct ImPlotTick;\nstruct ImPlotAxis;\nstruct ImPlotAxisColor;\nstruct ImPlotItem;\nstruct ImPlotLegend;\nstruct ImPlotPlot;\nstruct ImPlotNextPlotData;\nstruct ImPlotTicker;\n\n//-----------------------------------------------------------------------------\n// [SECTION] Context Pointer\n//-----------------------------------------------------------------------------\n\n#ifndef GImPlot\nextern IMPLOT_API ImPlotContext* GImPlot; // Current implicit context pointer\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Generic Helpers\n//-----------------------------------------------------------------------------\n\n// Computes the common (base-10) logarithm\nstatic inline float  ImLog10(float x)  { return log10f(x); }\nstatic inline double ImLog10(double x) { return log10(x);  }\nstatic inline float  ImSinh(float x)   { return sinhf(x);  }\nstatic inline double ImSinh(double x)  { return sinh(x);   }\nstatic inline float  ImAsinh(float x)  { return asinhf(x); }\nstatic inline double ImAsinh(double x) { return asinh(x);  }\n// Returns true if a flag is set\ntemplate <typename TSet, typename TFlag>\nstatic inline bool ImHasFlag(TSet set, TFlag flag) { return (set & flag) == flag; }\n// Flips a flag in a flagset\ntemplate <typename TSet, typename TFlag>\nstatic inline void ImFlipFlag(TSet& set, TFlag flag) { ImHasFlag(set, flag) ? set &= ~flag : set |= flag; }\n// Linearly remaps x from [x0 x1] to [y0 y1].\ntemplate <typename T>\nstatic inline T ImRemap(T x, T x0, T x1, T y0, T y1) { return y0 + (x - x0) * (y1 - y0) / (x1 - x0); }\n// Linear rempas x from [x0 x1] to [0 1]\ntemplate <typename T>\nstatic inline T ImRemap01(T x, T x0, T x1) { return (x - x0) / (x1 - x0); }\n// Returns always positive modulo (assumes r != 0)\nstatic inline int ImPosMod(int l, int r) { return (l % r + r) % r; }\n// Returns true if val is NAN\nstatic inline bool ImNan(double val) { return isnan(val); }\n// Returns true if val is NAN or INFINITY\nstatic inline bool ImNanOrInf(double val) { return !(val >= -DBL_MAX && val <= DBL_MAX) || ImNan(val); }\n// Turns NANs to 0s\nstatic inline double ImConstrainNan(double val) { return ImNan(val) ? 0 : val; }\n// Turns infinity to floating point maximums\nstatic inline double ImConstrainInf(double val) { return val >= DBL_MAX ?  DBL_MAX : val <= -DBL_MAX ? - DBL_MAX : val; }\n// Turns numbers less than or equal to 0 to 0.001 (sort of arbitrary, is there a better way?)\nstatic inline double ImConstrainLog(double val) { return val <= 0 ? 0.001f : val; }\n// Turns numbers less than 0 to zero\nstatic inline double ImConstrainTime(double val) { return val < IMPLOT_MIN_TIME ? IMPLOT_MIN_TIME : (val > IMPLOT_MAX_TIME ? IMPLOT_MAX_TIME : val); }\n// True if two numbers are approximately equal using units in the last place.\nstatic inline bool ImAlmostEqual(double v1, double v2, int ulp = 2) { return ImAbs(v1-v2) < DBL_EPSILON * ImAbs(v1+v2) * ulp || ImAbs(v1-v2) < DBL_MIN; }\n// Finds min value in an unsorted array\ntemplate <typename T>\nstatic inline T ImMinArray(const T* values, int count) { T m = values[0]; for (int i = 1; i < count; ++i) { if (values[i] < m) { m = values[i]; } } return m; }\n// Finds the max value in an unsorted array\ntemplate <typename T>\nstatic inline T ImMaxArray(const T* values, int count) { T m = values[0]; for (int i = 1; i < count; ++i) { if (values[i] > m) { m = values[i]; } } return m; }\n// Finds the min and max value in an unsorted array\ntemplate <typename T>\nstatic inline void ImMinMaxArray(const T* values, int count, T* min_out, T* max_out) {\n    T Min = values[0]; T Max = values[0];\n    for (int i = 1; i < count; ++i) {\n        if (values[i] < Min) { Min = values[i]; }\n        if (values[i] > Max) { Max = values[i]; }\n    }\n    *min_out = Min; *max_out = Max;\n}\n// Finds the sim of an array\ntemplate <typename T>\nstatic inline T ImSum(const T* values, int count) {\n    T sum  = 0;\n    for (int i = 0; i < count; ++i)\n        sum += values[i];\n    return sum;\n}\n// Finds the mean of an array\ntemplate <typename T>\nstatic inline double ImMean(const T* values, int count) {\n    double den = 1.0 / count;\n    double mu  = 0;\n    for (int i = 0; i < count; ++i)\n        mu += (double)values[i] * den;\n    return mu;\n}\n// Finds the sample standard deviation of an array\ntemplate <typename T>\nstatic inline double ImStdDev(const T* values, int count) {\n    double den = 1.0 / (count - 1.0);\n    double mu  = ImMean(values, count);\n    double x   = 0;\n    for (int i = 0; i < count; ++i)\n        x += ((double)values[i] - mu) * ((double)values[i] - mu) * den;\n    return sqrt(x);\n}\n// Mix color a and b by factor s in [0 256]\nstatic inline ImU32 ImMixU32(ImU32 a, ImU32 b, ImU32 s) {\n#ifdef IMPLOT_MIX64\n    const ImU32 af = 256-s;\n    const ImU32 bf = s;\n    const ImU64 al = (a & 0x00ff00ff) | (((ImU64)(a & 0xff00ff00)) << 24);\n    const ImU64 bl = (b & 0x00ff00ff) | (((ImU64)(b & 0xff00ff00)) << 24);\n    const ImU64 mix = (al * af + bl * bf);\n    return ((mix >> 32) & 0xff00ff00) | ((mix & 0xff00ff00) >> 8);\n#else\n    const ImU32 af = 256-s;\n    const ImU32 bf = s;\n    const ImU32 al = (a & 0x00ff00ff);\n    const ImU32 ah = (a & 0xff00ff00) >> 8;\n    const ImU32 bl = (b & 0x00ff00ff);\n    const ImU32 bh = (b & 0xff00ff00) >> 8;\n    const ImU32 ml = (al * af + bl * bf);\n    const ImU32 mh = (ah * af + bh * bf);\n    return (mh & 0xff00ff00) | ((ml & 0xff00ff00) >> 8);\n#endif\n}\n\n// Lerp across an array of 32-bit collors given t in [0.0 1.0]\nstatic inline ImU32 ImLerpU32(const ImU32* colors, int size, float t) {\n    int i1 = (int)((size - 1 ) * t);\n    int i2 = i1 + 1;\n    if (i2 == size || size == 1)\n        return colors[i1];\n    float den = 1.0f / (size - 1);\n    float t1 = i1 * den;\n    float t2 = i2 * den;\n    float tr = ImRemap01(t, t1, t2);\n    return ImMixU32(colors[i1], colors[i2], (ImU32)(tr*256));\n}\n\n// Set alpha channel of 32-bit color from float in range [0.0 1.0]\nstatic inline ImU32 ImAlphaU32(ImU32 col, float alpha) {\n    return col & ~((ImU32)((1.0f-alpha)*255)<<IM_COL32_A_SHIFT);\n}\n\n// Returns true of two ranges overlap\ntemplate <typename T>\nstatic inline bool ImOverlaps(T min_a, T max_a, T min_b, T max_b) {\n    return min_a <= max_b && min_b <= max_a;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImPlot Enums\n//-----------------------------------------------------------------------------\n\ntypedef int ImPlotTimeUnit;    // -> enum ImPlotTimeUnit_\ntypedef int ImPlotDateFmt;     // -> enum ImPlotDateFmt_\ntypedef int ImPlotTimeFmt;     // -> enum ImPlotTimeFmt_\n\nenum ImPlotTimeUnit_ {\n    ImPlotTimeUnit_Us,  // microsecond\n    ImPlotTimeUnit_Ms,  // millisecond\n    ImPlotTimeUnit_S,   // second\n    ImPlotTimeUnit_Min, // minute\n    ImPlotTimeUnit_Hr,  // hour\n    ImPlotTimeUnit_Day, // day\n    ImPlotTimeUnit_Mo,  // month\n    ImPlotTimeUnit_Yr,  // year\n    ImPlotTimeUnit_COUNT\n};\n\nenum ImPlotDateFmt_ {              // default        [ ISO 8601     ]\n    ImPlotDateFmt_None = 0,\n    ImPlotDateFmt_DayMo,           // 10/3           [ --10-03      ]\n    ImPlotDateFmt_DayMoYr,         // 10/3/91        [ 1991-10-03   ]\n    ImPlotDateFmt_MoYr,            // Oct 1991       [ 1991-10      ]\n    ImPlotDateFmt_Mo,              // Oct            [ --10         ]\n    ImPlotDateFmt_Yr               // 1991           [ 1991         ]\n};\n\nenum ImPlotTimeFmt_ {              // default        [ 24 Hour Clock ]\n    ImPlotTimeFmt_None = 0,\n    ImPlotTimeFmt_Us,              // .428 552       [ .428 552     ]\n    ImPlotTimeFmt_SUs,             // :29.428 552    [ :29.428 552  ]\n    ImPlotTimeFmt_SMs,             // :29.428        [ :29.428      ]\n    ImPlotTimeFmt_S,               // :29            [ :29          ]\n    ImPlotTimeFmt_MinSMs,          // 21:29.428      [ 21:29.428    ]\n    ImPlotTimeFmt_HrMinSMs,        // 7:21:29.428pm  [ 19:21:29.428 ]\n    ImPlotTimeFmt_HrMinS,          // 7:21:29pm      [ 19:21:29     ]\n    ImPlotTimeFmt_HrMin,           // 7:21pm         [ 19:21        ]\n    ImPlotTimeFmt_Hr               // 7pm            [ 19:00        ]\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Callbacks\n//-----------------------------------------------------------------------------\n\ntypedef void (*ImPlotLocator)(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Structs\n//-----------------------------------------------------------------------------\n\n// Combined date/time format spec\nstruct ImPlotDateTimeSpec {\n    ImPlotDateTimeSpec() {}\n    ImPlotDateTimeSpec(ImPlotDateFmt date_fmt, ImPlotTimeFmt time_fmt, bool use_24_hr_clk = false, bool use_iso_8601 = false) {\n        Date           = date_fmt;\n        Time           = time_fmt;\n        UseISO8601     = use_iso_8601;\n        Use24HourClock = use_24_hr_clk;\n    }\n    ImPlotDateFmt Date;\n    ImPlotTimeFmt Time;\n    bool UseISO8601;\n    bool Use24HourClock;\n};\n\n// Two part timestamp struct.\nstruct ImPlotTime {\n    time_t S;  // second part\n    int    Us; // microsecond part\n    ImPlotTime() { S = 0; Us = 0; }\n    ImPlotTime(time_t s, int us = 0) { S  = s + us / 1000000; Us = us % 1000000; }\n    void RollOver() { S  = S + Us / 1000000;  Us = Us % 1000000; }\n    double ToDouble() const { return (double)S + (double)Us / 1000000.0; }\n    static ImPlotTime FromDouble(double t) { return ImPlotTime((time_t)t, (int)(t * 1000000 - floor(t) * 1000000)); }\n};\n\nstatic inline ImPlotTime operator+(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return ImPlotTime(lhs.S + rhs.S, lhs.Us + rhs.Us); }\nstatic inline ImPlotTime operator-(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return ImPlotTime(lhs.S - rhs.S, lhs.Us - rhs.Us); }\nstatic inline bool operator==(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return lhs.S == rhs.S && lhs.Us == rhs.Us; }\nstatic inline bool operator<(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return lhs.S == rhs.S ? lhs.Us < rhs.Us : lhs.S < rhs.S; }\nstatic inline bool operator>(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return rhs < lhs; }\nstatic inline bool operator<=(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return lhs < rhs || lhs == rhs; }\nstatic inline bool operator>=(const ImPlotTime& lhs, const ImPlotTime& rhs)\n{ return lhs > rhs || lhs == rhs; }\n\n// Colormap data storage\nstruct ImPlotColormapData {\n    ImVector<ImU32> Keys;\n    ImVector<int>   KeyCounts;\n    ImVector<int>   KeyOffsets;\n    ImVector<ImU32> Tables;\n    ImVector<int>   TableSizes;\n    ImVector<int>   TableOffsets;\n    ImGuiTextBuffer Text;\n    ImVector<int>   TextOffsets;\n    ImVector<bool>  Quals;\n    ImGuiStorage    Map;\n    int             Count;\n\n    ImPlotColormapData() { Count = 0; }\n\n    int Append(const char* name, const ImU32* keys, int count, bool qual) {\n        if (GetIndex(name) != -1)\n            return -1;\n        KeyOffsets.push_back(Keys.size());\n        KeyCounts.push_back(count);\n        Keys.reserve(Keys.size()+count);\n        for (int i = 0; i < count; ++i)\n            Keys.push_back(keys[i]);\n        TextOffsets.push_back(Text.size());\n        Text.append(name, name + strlen(name) + 1);\n        Quals.push_back(qual);\n        ImGuiID id = ImHashStr(name);\n        int idx = Count++;\n        Map.SetInt(id,idx);\n        _AppendTable(idx);\n        return idx;\n    }\n\n    void _AppendTable(ImPlotColormap cmap) {\n        int key_count     = GetKeyCount(cmap);\n        const ImU32* keys = GetKeys(cmap);\n        int off = Tables.size();\n        TableOffsets.push_back(off);\n        if (IsQual(cmap)) {\n            Tables.reserve(key_count);\n            for (int i = 0; i < key_count; ++i)\n                Tables.push_back(keys[i]);\n            TableSizes.push_back(key_count);\n        }\n        else {\n            int max_size = 255 * (key_count-1) + 1;\n            Tables.reserve(off + max_size);\n            // ImU32 last = keys[0];\n            // Tables.push_back(last);\n            // int n = 1;\n            for (int i = 0; i < key_count-1; ++i) {\n                for (int s = 0; s < 255; ++s) {\n                    ImU32 a = keys[i];\n                    ImU32 b = keys[i+1];\n                    ImU32 c = ImMixU32(a,b,s);\n                    // if (c != last) {\n                        Tables.push_back(c);\n                        // last = c;\n                        // n++;\n                    // }\n                }\n            }\n            ImU32 c = keys[key_count-1];\n            // if (c != last) {\n                Tables.push_back(c);\n                // n++;\n            // }\n            // TableSizes.push_back(n);\n            TableSizes.push_back(max_size);\n        }\n    }\n\n    void RebuildTables() {\n        Tables.resize(0);\n        TableSizes.resize(0);\n        TableOffsets.resize(0);\n        for (int i = 0; i < Count; ++i)\n            _AppendTable(i);\n    }\n\n    inline bool           IsQual(ImPlotColormap cmap) const                      { return Quals[cmap];                                                }\n    inline const char*    GetName(ImPlotColormap cmap) const                     { return cmap < Count ? Text.Buf.Data + TextOffsets[cmap] : nullptr; }\n    inline ImPlotColormap GetIndex(const char* name) const                       { ImGuiID key = ImHashStr(name); return Map.GetInt(key,-1);          }\n\n    inline const ImU32*   GetKeys(ImPlotColormap cmap) const                     { return &Keys[KeyOffsets[cmap]];                                    }\n    inline int            GetKeyCount(ImPlotColormap cmap) const                 { return KeyCounts[cmap];                                            }\n    inline ImU32          GetKeyColor(ImPlotColormap cmap, int idx) const        { return Keys[KeyOffsets[cmap]+idx];                                 }\n    inline void           SetKeyColor(ImPlotColormap cmap, int idx, ImU32 value) { Keys[KeyOffsets[cmap]+idx] = value; RebuildTables();               }\n\n    inline const ImU32*   GetTable(ImPlotColormap cmap) const                    { return &Tables[TableOffsets[cmap]];                                }\n    inline int            GetTableSize(ImPlotColormap cmap) const                { return TableSizes[cmap];                                           }\n    inline ImU32          GetTableColor(ImPlotColormap cmap, int idx) const      { return Tables[TableOffsets[cmap]+idx];                             }\n\n    inline ImU32 LerpTable(ImPlotColormap cmap, float t) const {\n        int off = TableOffsets[cmap];\n        int siz = TableSizes[cmap];\n        int idx = Quals[cmap] ? ImClamp((int)(siz*t),0,siz-1) : (int)((siz - 1) * t + 0.5f);\n        return Tables[off + idx];\n    }\n};\n\n// ImPlotPoint with positive/negative error values\nstruct ImPlotPointError {\n    double X, Y, Neg, Pos;\n    ImPlotPointError(double x, double y, double neg, double pos) {\n        X = x; Y = y; Neg = neg; Pos = pos;\n    }\n};\n\n// Interior plot label/annotation\nstruct ImPlotAnnotation {\n    ImVec2 Pos;\n    ImVec2 Offset;\n    ImU32  ColorBg;\n    ImU32  ColorFg;\n    int    TextOffset;\n    bool   Clamp;\n    ImPlotAnnotation() {\n        ColorBg = ColorFg = 0;\n        TextOffset = 0;\n        Clamp = false;\n    }\n};\n\n// Collection of plot labels\nstruct ImPlotAnnotationCollection {\n\n    ImVector<ImPlotAnnotation> Annotations;\n    ImGuiTextBuffer            TextBuffer;\n    int                        Size;\n\n    ImPlotAnnotationCollection() { Reset(); }\n\n    void AppendV(const ImVec2& pos, const ImVec2& off, ImU32 bg, ImU32 fg, bool clamp, const char* fmt,  va_list args) IM_FMTLIST(7) {\n        ImPlotAnnotation an;\n        an.Pos = pos; an.Offset = off;\n        an.ColorBg = bg; an.ColorFg = fg;\n        an.TextOffset = TextBuffer.size();\n        an.Clamp = clamp;\n        Annotations.push_back(an);\n        TextBuffer.appendfv(fmt, args);\n        const char nul[] = \"\";\n        TextBuffer.append(nul,nul+1);\n        Size++;\n    }\n\n    void Append(const ImVec2& pos, const ImVec2& off, ImU32 bg, ImU32 fg, bool clamp, const char* fmt,  ...) IM_FMTARGS(7) {\n        va_list args;\n        va_start(args, fmt);\n        AppendV(pos, off, bg, fg, clamp, fmt, args);\n        va_end(args);\n    }\n\n    const char* GetText(int idx) {\n        return TextBuffer.Buf.Data + Annotations[idx].TextOffset;\n    }\n\n    void Reset() {\n        Annotations.shrink(0);\n        TextBuffer.Buf.shrink(0);\n        Size = 0;\n    }\n};\n\nstruct ImPlotTag {\n    ImAxis Axis;\n    double Value;\n    ImU32  ColorBg;\n    ImU32  ColorFg;\n    int    TextOffset;\n};\n\nstruct ImPlotTagCollection {\n\n    ImVector<ImPlotTag> Tags;\n    ImGuiTextBuffer     TextBuffer;\n    int                 Size;\n\n    ImPlotTagCollection() { Reset(); }\n\n    void AppendV(ImAxis axis, double value, ImU32 bg, ImU32 fg, const char* fmt, va_list args) IM_FMTLIST(6) {\n        ImPlotTag tag;\n        tag.Axis = axis;\n        tag.Value = value;\n        tag.ColorBg = bg;\n        tag.ColorFg = fg;\n        tag.TextOffset = TextBuffer.size();\n        Tags.push_back(tag);\n        TextBuffer.appendfv(fmt, args);\n        const char nul[] = \"\";\n        TextBuffer.append(nul,nul+1);\n        Size++;\n    }\n\n    void Append(ImAxis axis, double value, ImU32 bg, ImU32 fg, const char* fmt, ...) IM_FMTARGS(6) {\n        va_list args;\n        va_start(args, fmt);\n        AppendV(axis, value, bg, fg, fmt, args);\n        va_end(args);\n    }\n\n    const char* GetText(int idx) {\n        return TextBuffer.Buf.Data + Tags[idx].TextOffset;\n    }\n\n    void Reset() {\n        Tags.shrink(0);\n        TextBuffer.Buf.shrink(0);\n        Size = 0;\n    }\n};\n\n// Tick mark info\nstruct ImPlotTick\n{\n    double PlotPos;\n    float  PixelPos;\n    ImVec2 LabelSize;\n    int    TextOffset;\n    bool   Major;\n    bool   ShowLabel;\n    int    Level;\n    int    Idx;\n\n    ImPlotTick(double value, bool major, int level, bool show_label) {\n        PixelPos     = 0;\n        PlotPos      = value;\n        Major        = major;\n        ShowLabel    = show_label;\n        Level        = level;\n        TextOffset   = -1;\n    }\n};\n\n// Collection of ticks\nstruct ImPlotTicker {\n    ImVector<ImPlotTick> Ticks;\n    ImGuiTextBuffer      TextBuffer;\n    ImVec2               MaxSize;\n    ImVec2               LateSize;\n    int                  Levels;\n\n    ImPlotTicker() {\n        Reset();\n    }\n\n    ImPlotTick& AddTick(double value, bool major, int level, bool show_label, const char* label) {\n        ImPlotTick tick(value, major, level, show_label);\n        if (show_label && label != nullptr) {\n            tick.TextOffset = TextBuffer.size();\n            TextBuffer.append(label, label + strlen(label) + 1);\n            tick.LabelSize = ImGui::CalcTextSize(TextBuffer.Buf.Data + tick.TextOffset);\n        }\n        return AddTick(tick);\n    }\n\n    ImPlotTick& AddTick(double value, bool major, int level, bool show_label, ImPlotFormatter formatter, void* data) {\n        ImPlotTick tick(value, major, level, show_label);\n        if (show_label && formatter != nullptr) {\n            char buff[IMPLOT_LABEL_MAX_SIZE];\n            tick.TextOffset = TextBuffer.size();\n            formatter(tick.PlotPos, buff, sizeof(buff), data);\n            TextBuffer.append(buff, buff + strlen(buff) + 1);\n            tick.LabelSize = ImGui::CalcTextSize(TextBuffer.Buf.Data + tick.TextOffset);\n        }\n        return AddTick(tick);\n    }\n\n    inline ImPlotTick& AddTick(ImPlotTick tick) {\n        if (tick.ShowLabel) {\n            MaxSize.x     =  tick.LabelSize.x > MaxSize.x ? tick.LabelSize.x : MaxSize.x;\n            MaxSize.y     =  tick.LabelSize.y > MaxSize.y ? tick.LabelSize.y : MaxSize.y;\n        }\n        tick.Idx = Ticks.size();\n        Ticks.push_back(tick);\n        return Ticks.back();\n    }\n\n    const char* GetText(int idx) const {\n        return TextBuffer.Buf.Data + Ticks[idx].TextOffset;\n    }\n\n    const char* GetText(const ImPlotTick& tick) {\n        return GetText(tick.Idx);\n    }\n\n    void OverrideSizeLate(const ImVec2& size) {\n        LateSize.x = size.x > LateSize.x ? size.x : LateSize.x;\n        LateSize.y = size.y > LateSize.y ? size.y : LateSize.y;\n    }\n\n    void Reset() {\n        Ticks.shrink(0);\n        TextBuffer.Buf.shrink(0);\n        MaxSize = LateSize;\n        LateSize = ImVec2(0,0);\n        Levels = 1;\n    }\n\n    int TickCount() const {\n        return Ticks.Size;\n    }\n};\n\n// Axis state information that must persist after EndPlot\nstruct ImPlotAxis\n{\n    ImGuiID              ID;\n    ImPlotAxisFlags      Flags;\n    ImPlotAxisFlags      PreviousFlags;\n    ImPlotRange          Range;\n    ImPlotCond           RangeCond;\n    ImPlotScale          Scale;\n    ImPlotRange          FitExtents;\n    ImPlotAxis*          OrthoAxis;\n    ImPlotRange          ConstraintRange;\n    ImPlotRange          ConstraintZoom;\n\n    ImPlotTicker         Ticker;\n    ImPlotFormatter      Formatter;\n    void*                FormatterData;\n    char                 FormatSpec[16];\n    ImPlotLocator        Locator;\n\n    double*              LinkedMin;\n    double*              LinkedMax;\n\n    int                  PickerLevel;\n    ImPlotTime           PickerTimeMin, PickerTimeMax;\n\n    ImPlotTransform      TransformForward;\n    ImPlotTransform      TransformInverse;\n    void*                TransformData;\n    float                PixelMin, PixelMax;\n    double               ScaleMin, ScaleMax;\n    double               ScaleToPixel;\n    float                Datum1, Datum2;\n\n    ImRect               HoverRect;\n    int                  LabelOffset;\n    ImU32                ColorMaj, ColorMin, ColorTick, ColorTxt, ColorBg, ColorHov, ColorAct, ColorHiLi;\n\n    bool                 Enabled;\n    bool                 Vertical;\n    bool                 FitThisFrame;\n    bool                 HasRange;\n    bool                 HasFormatSpec;\n    bool                 ShowDefaultTicks;\n    bool                 Hovered;\n    bool                 Held;\n\n    ImPlotAxis() {\n        ID               = 0;\n        Flags            = PreviousFlags = ImPlotAxisFlags_None;\n        Range.Min        = 0;\n        Range.Max        = 1;\n        Scale            = ImPlotScale_Linear;\n        TransformForward = TransformInverse = nullptr;\n        TransformData    = nullptr;\n        FitExtents.Min   = HUGE_VAL;\n        FitExtents.Max   = -HUGE_VAL;\n        OrthoAxis        = nullptr;\n        ConstraintRange  = ImPlotRange(-INFINITY,INFINITY);\n        ConstraintZoom   = ImPlotRange(DBL_MIN,INFINITY);\n        LinkedMin        = LinkedMax = nullptr;\n        PickerLevel      = 0;\n        Datum1           = Datum2 = 0;\n        PixelMin         = PixelMax = 0;\n        LabelOffset      = -1;\n        ColorMaj         = ColorMin = ColorTick = ColorTxt = ColorBg = ColorHov = ColorAct = 0;\n        ColorHiLi        = IM_COL32_BLACK_TRANS;\n        Formatter        = nullptr;\n        FormatterData    = nullptr;\n        Locator          = nullptr;\n        Enabled          = Hovered = Held = FitThisFrame = HasRange = HasFormatSpec = false;\n        ShowDefaultTicks = true;\n    }\n\n    inline void Reset() {\n        Enabled          = false;\n        Scale            = ImPlotScale_Linear;\n        TransformForward = TransformInverse = nullptr;\n        TransformData    = nullptr;\n        LabelOffset      = -1;\n        HasFormatSpec    = false;\n        Formatter        = nullptr;\n        FormatterData    = nullptr;\n        Locator          = nullptr;\n        ShowDefaultTicks = true;\n        FitThisFrame     = false;\n        FitExtents.Min   = HUGE_VAL;\n        FitExtents.Max   = -HUGE_VAL;\n        OrthoAxis        = nullptr;\n        ConstraintRange  = ImPlotRange(-INFINITY,INFINITY);\n        ConstraintZoom   = ImPlotRange(DBL_MIN,INFINITY);\n        Ticker.Reset();\n    }\n\n    inline bool SetMin(double _min, bool force=false) {\n        if (!force && IsLockedMin())\n            return false;\n        _min = ImConstrainNan(ImConstrainInf(_min));\n        if (_min < ConstraintRange.Min)\n            _min = ConstraintRange.Min;\n        double z = Range.Max - _min;\n        if (z < ConstraintZoom.Min)\n            _min = Range.Max - ConstraintZoom.Min;\n        if (z > ConstraintZoom.Max)\n            _min = Range.Max - ConstraintZoom.Max;\n        if (_min >= Range.Max)\n            return false;\n        Range.Min = _min;\n        PickerTimeMin = ImPlotTime::FromDouble(Range.Min);\n        UpdateTransformCache();\n        return true;\n    };\n\n    inline bool SetMax(double _max, bool force=false) {\n        if (!force && IsLockedMax())\n            return false;\n        _max = ImConstrainNan(ImConstrainInf(_max));\n        if (_max > ConstraintRange.Max)\n            _max = ConstraintRange.Max;\n        double z = _max - Range.Min;\n        if (z < ConstraintZoom.Min)\n            _max = Range.Min + ConstraintZoom.Min;\n        if (z > ConstraintZoom.Max)\n            _max = Range.Min + ConstraintZoom.Max;\n        if (_max <= Range.Min)\n            return false;\n        Range.Max = _max;\n        PickerTimeMax = ImPlotTime::FromDouble(Range.Max);\n        UpdateTransformCache();\n        return true;\n    };\n\n    inline void SetRange(double v1, double v2) {\n        Range.Min = ImMin(v1,v2);\n        Range.Max = ImMax(v1,v2);\n        Constrain();\n        PickerTimeMin = ImPlotTime::FromDouble(Range.Min);\n        PickerTimeMax = ImPlotTime::FromDouble(Range.Max);\n        UpdateTransformCache();\n    }\n\n    inline void SetRange(const ImPlotRange& range) {\n        SetRange(range.Min, range.Max);\n    }\n\n    inline void SetAspect(double unit_per_pix) {\n        double new_size = unit_per_pix * PixelSize();\n        double delta    = (new_size - Range.Size()) * 0.5;\n        if (IsLocked())\n            return;\n        else if (IsLockedMin() && !IsLockedMax())\n            SetRange(Range.Min, Range.Max  + 2*delta);\n        else if (!IsLockedMin() && IsLockedMax())\n            SetRange(Range.Min - 2*delta, Range.Max);\n        else\n            SetRange(Range.Min - delta, Range.Max + delta);\n    }\n\n    inline float PixelSize() const { return ImAbs(PixelMax - PixelMin); }\n\n    inline double GetAspect() const { return Range.Size() / PixelSize(); }\n\n    inline void Constrain() {\n        Range.Min = ImConstrainNan(ImConstrainInf(Range.Min));\n        Range.Max = ImConstrainNan(ImConstrainInf(Range.Max));\n        if (Range.Min < ConstraintRange.Min)\n            Range.Min = ConstraintRange.Min;\n        if (Range.Max > ConstraintRange.Max)\n            Range.Max = ConstraintRange.Max;\n        double z = Range.Size();\n        if (z < ConstraintZoom.Min) {\n            double delta = (ConstraintZoom.Min - z) * 0.5;\n            Range.Min -= delta;\n            Range.Max += delta;\n        }\n        if (z > ConstraintZoom.Max) {\n            double delta = (z - ConstraintZoom.Max) * 0.5;\n            Range.Min += delta;\n            Range.Max -= delta;\n        }\n        if (Range.Max <= Range.Min)\n            Range.Max = Range.Min + DBL_EPSILON;\n    }\n\n    inline void UpdateTransformCache() {\n        ScaleToPixel = (PixelMax - PixelMin) / Range.Size();\n        if (TransformForward != nullptr) {\n            ScaleMin = TransformForward(Range.Min, TransformData);\n            ScaleMax = TransformForward(Range.Max, TransformData);\n        }\n        else {\n            ScaleMin = Range.Min;\n            ScaleMax = Range.Max;\n        }\n    }\n\n    inline float PlotToPixels(double plt) const {\n        if (TransformForward != nullptr) {\n            double s = TransformForward(plt, TransformData);\n            double t = (s - ScaleMin) / (ScaleMax - ScaleMin);\n            plt      = Range.Min + Range.Size() * t;\n        }\n        return (float)(PixelMin + ScaleToPixel * (plt - Range.Min));\n    }\n\n\n    inline double PixelsToPlot(float pix) const {\n        double plt = (pix - PixelMin) / ScaleToPixel + Range.Min;\n        if (TransformInverse != nullptr) {\n            double t = (plt - Range.Min) / Range.Size();\n            double s = t * (ScaleMax - ScaleMin) + ScaleMin;\n            plt = TransformInverse(s, TransformData);\n        }\n        return plt;\n    }\n\n    inline void ExtendFit(double v) {\n        if (!ImNanOrInf(v) && v >= ConstraintRange.Min && v <= ConstraintRange.Max) {\n            FitExtents.Min = v < FitExtents.Min ? v : FitExtents.Min;\n            FitExtents.Max = v > FitExtents.Max ? v : FitExtents.Max;\n        }\n    }\n\n    inline void ExtendFitWith(ImPlotAxis& alt, double v, double v_alt) {\n        if (ImHasFlag(Flags, ImPlotAxisFlags_RangeFit) && !alt.Range.Contains(v_alt))\n            return;\n        if (!ImNanOrInf(v) && v >= ConstraintRange.Min && v <= ConstraintRange.Max) {\n            FitExtents.Min = v < FitExtents.Min ? v : FitExtents.Min;\n            FitExtents.Max = v > FitExtents.Max ? v : FitExtents.Max;\n        }\n    }\n\n    inline void ApplyFit(float padding) {\n        const double ext_size = FitExtents.Size() * 0.5;\n        FitExtents.Min -= ext_size * padding;\n        FitExtents.Max += ext_size * padding;\n        if (!IsLockedMin() && !ImNanOrInf(FitExtents.Min))\n            Range.Min = FitExtents.Min;\n        if (!IsLockedMax() && !ImNanOrInf(FitExtents.Max))\n            Range.Max = FitExtents.Max;\n        if (ImAlmostEqual(Range.Min, Range.Max))  {\n            Range.Max += 0.5;\n            Range.Min -= 0.5;\n        }\n        Constrain();\n        UpdateTransformCache();\n    }\n\n    inline bool HasLabel()          const { return LabelOffset != -1 && !ImHasFlag(Flags, ImPlotAxisFlags_NoLabel);                          }\n    inline bool HasGridLines()      const { return !ImHasFlag(Flags, ImPlotAxisFlags_NoGridLines);                                           }\n    inline bool HasTickLabels()     const { return !ImHasFlag(Flags, ImPlotAxisFlags_NoTickLabels);                                          }\n    inline bool HasTickMarks()      const { return !ImHasFlag(Flags, ImPlotAxisFlags_NoTickMarks);                                           }\n    inline bool WillRender()        const { return Enabled && (HasGridLines() || HasTickLabels() || HasTickMarks());                         }\n    inline bool IsOpposite()        const { return ImHasFlag(Flags, ImPlotAxisFlags_Opposite);                                               }\n    inline bool IsInverted()        const { return ImHasFlag(Flags, ImPlotAxisFlags_Invert);                                                 }\n    inline bool IsForeground()      const { return ImHasFlag(Flags, ImPlotAxisFlags_Foreground);                                             }\n    inline bool IsAutoFitting()     const { return ImHasFlag(Flags, ImPlotAxisFlags_AutoFit);                                                }\n    inline bool CanInitFit()        const { return !ImHasFlag(Flags, ImPlotAxisFlags_NoInitialFit) && !HasRange && !LinkedMin && !LinkedMax; }\n    inline bool IsRangeLocked()     const { return HasRange && RangeCond == ImPlotCond_Always;                                               }\n    inline bool IsLockedMin()       const { return !Enabled || IsRangeLocked() || ImHasFlag(Flags, ImPlotAxisFlags_LockMin);                 }\n    inline bool IsLockedMax()       const { return !Enabled || IsRangeLocked() || ImHasFlag(Flags, ImPlotAxisFlags_LockMax);                 }\n    inline bool IsLocked()          const { return IsLockedMin() && IsLockedMax();                                                           }\n    inline bool IsInputLockedMin()  const { return IsLockedMin() || IsAutoFitting();                                                         }\n    inline bool IsInputLockedMax()  const { return IsLockedMax() || IsAutoFitting();                                                         }\n    inline bool IsInputLocked()     const { return IsLocked()    || IsAutoFitting();                                                         }\n    inline bool HasMenus()          const { return !ImHasFlag(Flags, ImPlotAxisFlags_NoMenus);                                               }\n\n    inline bool IsPanLocked(bool increasing) {\n        if (ImHasFlag(Flags, ImPlotAxisFlags_PanStretch)) {\n            return IsInputLocked();\n        }\n        else {\n            if (IsLockedMin() || IsLockedMax() || IsAutoFitting())\n                return false;\n            if (increasing)\n                return Range.Max == ConstraintRange.Max;\n            else\n                return Range.Min == ConstraintRange.Min;\n        }\n    }\n\n    void PushLinks() {\n        if (LinkedMin) { *LinkedMin = Range.Min; }\n        if (LinkedMax) { *LinkedMax = Range.Max; }\n    }\n\n    void PullLinks() {\n        if (LinkedMin && LinkedMax) { SetRange(*LinkedMin, *LinkedMax); }\n        else if (LinkedMin) { SetMin(*LinkedMin,true); }\n        else if (LinkedMax) { SetMax(*LinkedMax,true); }\n    }\n};\n\n// Align plots group data\nstruct ImPlotAlignmentData {\n    bool  Vertical;\n    float PadA;\n    float PadB;\n    float PadAMax;\n    float PadBMax;\n    ImPlotAlignmentData() {\n        Vertical    = true;\n        PadA = PadB = PadAMax = PadBMax = 0;\n    }\n    void Begin() { PadAMax = PadBMax = 0; }\n    void Update(float& pad_a, float& pad_b, float& delta_a, float& delta_b) {\n        float bak_a = pad_a; float bak_b = pad_b;\n        if (PadAMax < pad_a) { PadAMax = pad_a; }\n        if (PadBMax < pad_b) { PadBMax = pad_b; }\n        if (pad_a < PadA)    { pad_a = PadA; delta_a = pad_a - bak_a; } else { delta_a = 0; }\n        if (pad_b < PadB)    { pad_b = PadB; delta_b = pad_b - bak_b; } else { delta_b = 0; }\n    }\n    void End()   { PadA = PadAMax; PadB = PadBMax;      }\n    void Reset() { PadA = PadB = PadAMax = PadBMax = 0; }\n};\n\n// State information for Plot items\nstruct ImPlotItem\n{\n    ImGuiID      ID;\n    ImU32        Color;\n    ImRect       LegendHoverRect;\n    int          NameOffset;\n    bool         Show;\n    bool         LegendHovered;\n    bool         SeenThisFrame;\n\n    ImPlotItem() {\n        ID            = 0;\n        Color         = IM_COL32_WHITE;\n        NameOffset    = -1;\n        Show          = true;\n        SeenThisFrame = false;\n        LegendHovered = false;\n    }\n\n    ~ImPlotItem() { ID = 0; }\n};\n\n// Holds Legend state\nstruct ImPlotLegend\n{\n    ImPlotLegendFlags Flags;\n    ImPlotLegendFlags PreviousFlags;\n    ImPlotLocation    Location;\n    ImPlotLocation    PreviousLocation;\n    ImVec2            Scroll;\n    ImVector<int>     Indices;\n    ImGuiTextBuffer   Labels;\n    ImRect            Rect;\n    ImRect            RectClamped;\n    bool              Hovered;\n    bool              Held;\n    bool              CanGoInside;\n\n    ImPlotLegend() {\n        Flags        = PreviousFlags = ImPlotLegendFlags_None;\n        CanGoInside  = true;\n        Hovered      = Held = false;\n        Location     = PreviousLocation = ImPlotLocation_NorthWest;\n        Scroll       = ImVec2(0,0);\n    }\n\n    void Reset() { Indices.shrink(0); Labels.Buf.shrink(0); }\n};\n\n// Holds Items and Legend data\nstruct ImPlotItemGroup\n{\n    ImGuiID            ID;\n    ImPlotLegend       Legend;\n    ImPool<ImPlotItem> ItemPool;\n    int                ColormapIdx;\n\n    ImPlotItemGroup() { ID = 0; ColormapIdx = 0; }\n\n    int         GetItemCount() const             { return ItemPool.GetBufSize();                                 }\n    ImGuiID     GetItemID(const char*  label_id) { return ImGui::GetID(label_id); /* GetIDWithSeed */            }\n    ImPlotItem* GetItem(ImGuiID id)              { return ItemPool.GetByKey(id);                                 }\n    ImPlotItem* GetItem(const char* label_id)    { return GetItem(GetItemID(label_id));                          }\n    ImPlotItem* GetOrAddItem(ImGuiID id)         { return ItemPool.GetOrAddByKey(id);                            }\n    ImPlotItem* GetItemByIndex(int i)            { return ItemPool.GetByIndex(i);                                }\n    int         GetItemIndex(ImPlotItem* item)   { return ItemPool.GetIndex(item);                               }\n    int         GetLegendCount() const           { return Legend.Indices.size();                                 }\n    ImPlotItem* GetLegendItem(int i)             { return ItemPool.GetByIndex(Legend.Indices[i]);                }\n    const char* GetLegendLabel(int i)            { return Legend.Labels.Buf.Data + GetLegendItem(i)->NameOffset; }\n    void        Reset()                          { ItemPool.Clear(); Legend.Reset(); ColormapIdx = 0;            }\n};\n\n// Holds Plot state information that must persist after EndPlot\nstruct ImPlotPlot\n{\n    ImGuiID              ID;\n    ImPlotFlags          Flags;\n    ImPlotFlags          PreviousFlags;\n    ImPlotLocation       MouseTextLocation;\n    ImPlotMouseTextFlags MouseTextFlags;\n    ImPlotAxis           Axes[ImAxis_COUNT];\n    ImGuiTextBuffer      TextBuffer;\n    ImPlotItemGroup      Items;\n    ImAxis               CurrentX;\n    ImAxis               CurrentY;\n    ImRect               FrameRect;\n    ImRect               CanvasRect;\n    ImRect               PlotRect;\n    ImRect               AxesRect;\n    ImRect               SelectRect;\n    ImVec2               SelectStart;\n    int                  TitleOffset;\n    bool                 JustCreated;\n    bool                 Initialized;\n    bool                 SetupLocked;\n    bool                 FitThisFrame;\n    bool                 Hovered;\n    bool                 Held;\n    bool                 Selecting;\n    bool                 Selected;\n    bool                 ContextLocked;\n\n    ImPlotPlot() {\n        Flags             = PreviousFlags = ImPlotFlags_None;\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i)\n            XAxis(i).Vertical = false;\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i)\n            YAxis(i).Vertical = true;\n        SelectStart       = ImVec2(0,0);\n        CurrentX          = ImAxis_X1;\n        CurrentY          = ImAxis_Y1;\n        MouseTextLocation  = ImPlotLocation_South | ImPlotLocation_East;\n        MouseTextFlags     = ImPlotMouseTextFlags_None;\n        TitleOffset       = -1;\n        JustCreated       = true;\n        Initialized = SetupLocked = FitThisFrame = false;\n        Hovered = Held = Selected = Selecting = ContextLocked = false;\n    }\n\n    inline bool IsInputLocked() const {\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {\n            if (!XAxis(i).IsInputLocked())\n                return false;\n        }\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {\n            if (!YAxis(i).IsInputLocked())\n                return false;\n        }\n        return true;\n    }\n\n    inline void ClearTextBuffer() { TextBuffer.Buf.shrink(0); }\n\n    inline void SetTitle(const char* title) {\n        if (title && ImGui::FindRenderedTextEnd(title, nullptr) != title) {\n            TitleOffset = TextBuffer.size();\n            TextBuffer.append(title, title + strlen(title) + 1);\n        }\n        else {\n            TitleOffset = -1;\n        }\n    }\n    inline bool HasTitle() const { return TitleOffset != -1 && !ImHasFlag(Flags, ImPlotFlags_NoTitle); }\n    inline const char* GetTitle() const { return TextBuffer.Buf.Data + TitleOffset; }\n\n    inline       ImPlotAxis& XAxis(int i)       { return Axes[ImAxis_X1 + i]; }\n    inline const ImPlotAxis& XAxis(int i) const { return Axes[ImAxis_X1 + i]; }\n    inline       ImPlotAxis& YAxis(int i)       { return Axes[ImAxis_Y1 + i]; }\n    inline const ImPlotAxis& YAxis(int i) const { return Axes[ImAxis_Y1 + i]; }\n\n    inline int EnabledAxesX() {\n        int cnt = 0;\n        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i)\n            cnt += XAxis(i).Enabled;\n        return cnt;\n    }\n\n    inline int EnabledAxesY() {\n        int cnt = 0;\n        for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i)\n            cnt += YAxis(i).Enabled;\n        return cnt;\n    }\n\n    inline void SetAxisLabel(ImPlotAxis& axis, const char* label) {\n        if (label && ImGui::FindRenderedTextEnd(label, nullptr) != label) {\n            axis.LabelOffset = TextBuffer.size();\n            TextBuffer.append(label, label + strlen(label) + 1);\n        }\n        else {\n            axis.LabelOffset = -1;\n        }\n    }\n\n    inline const char* GetAxisLabel(const ImPlotAxis& axis) const { return TextBuffer.Buf.Data + axis.LabelOffset; }\n};\n\n// Holds subplot data that must persist after EndSubplot\nstruct ImPlotSubplot {\n    ImGuiID                       ID;\n    ImPlotSubplotFlags            Flags;\n    ImPlotSubplotFlags            PreviousFlags;\n    ImPlotItemGroup               Items;\n    int                           Rows;\n    int                           Cols;\n    int                           CurrentIdx;\n    ImRect                        FrameRect;\n    ImRect                        GridRect;\n    ImVec2                        CellSize;\n    ImVector<ImPlotAlignmentData> RowAlignmentData;\n    ImVector<ImPlotAlignmentData> ColAlignmentData;\n    ImVector<float>               RowRatios;\n    ImVector<float>               ColRatios;\n    ImVector<ImPlotRange>         RowLinkData;\n    ImVector<ImPlotRange>         ColLinkData;\n    float                         TempSizes[2];\n    bool                          FrameHovered;\n    bool                          HasTitle;\n\n    ImPlotSubplot() {\n        ID                          = 0;\n        Flags = PreviousFlags       = ImPlotSubplotFlags_None;\n        Rows = Cols = CurrentIdx    = 0;\n        Items.Legend.Location       = ImPlotLocation_North;\n        Items.Legend.Flags          = ImPlotLegendFlags_Horizontal|ImPlotLegendFlags_Outside;\n        Items.Legend.CanGoInside    = false;\n        TempSizes[0] = TempSizes[1] = 0;\n        FrameHovered                = false;\n        HasTitle                    = false;\n    }\n};\n\n// Temporary data storage for upcoming plot\nstruct ImPlotNextPlotData\n{\n    ImPlotCond  RangeCond[ImAxis_COUNT];\n    ImPlotRange Range[ImAxis_COUNT];\n    bool        HasRange[ImAxis_COUNT];\n    bool        Fit[ImAxis_COUNT];\n    double*     LinkedMin[ImAxis_COUNT];\n    double*     LinkedMax[ImAxis_COUNT];\n\n    ImPlotNextPlotData() { Reset(); }\n\n    void Reset() {\n        for (int i = 0; i < ImAxis_COUNT; ++i) {\n            HasRange[i]                 = false;\n            Fit[i]                      = false;\n            LinkedMin[i] = LinkedMax[i] = nullptr;\n        }\n    }\n\n};\n\n// Temporary data storage for upcoming item\nstruct ImPlotNextItemData {\n    ImVec4          Colors[5]; // ImPlotCol_Line, ImPlotCol_Fill, ImPlotCol_MarkerOutline, ImPlotCol_MarkerFill, ImPlotCol_ErrorBar\n    float           LineWeight;\n    ImPlotMarker    Marker;\n    float           MarkerSize;\n    float           MarkerWeight;\n    float           FillAlpha;\n    float           ErrorBarSize;\n    float           ErrorBarWeight;\n    float           DigitalBitHeight;\n    float           DigitalBitGap;\n    bool            RenderLine;\n    bool            RenderFill;\n    bool            RenderMarkerLine;\n    bool            RenderMarkerFill;\n    bool            HasHidden;\n    bool            Hidden;\n    ImPlotCond      HiddenCond;\n    ImPlotNextItemData() { Reset(); }\n    void Reset() {\n        for (int i = 0; i < 5; ++i)\n            Colors[i] = IMPLOT_AUTO_COL;\n        LineWeight    = MarkerSize = MarkerWeight = FillAlpha = ErrorBarSize = ErrorBarWeight = DigitalBitHeight = DigitalBitGap = IMPLOT_AUTO;\n        Marker        = IMPLOT_AUTO;\n        HasHidden     = Hidden = false;\n    }\n};\n\n// Holds state information that must persist between calls to BeginPlot()/EndPlot()\nstruct ImPlotContext {\n    // Plot States\n    ImPool<ImPlotPlot>    Plots;\n    ImPool<ImPlotSubplot> Subplots;\n    ImPlotPlot*           CurrentPlot;\n    ImPlotSubplot*        CurrentSubplot;\n    ImPlotItemGroup*      CurrentItems;\n    ImPlotItem*           CurrentItem;\n    ImPlotItem*           PreviousItem;\n\n    // Tick Marks and Labels\n    ImPlotTicker CTicker;\n\n    // Annotation and Tabs\n    ImPlotAnnotationCollection Annotations;\n    ImPlotTagCollection        Tags;\n\n    // Style and Colormaps\n    ImPlotStyle                 Style;\n    ImVector<ImGuiColorMod>     ColorModifiers;\n    ImVector<ImGuiStyleMod>     StyleModifiers;\n    ImPlotColormapData          ColormapData;\n    ImVector<ImPlotColormap>    ColormapModifiers;\n\n    // Time\n    tm Tm;\n\n    // Temp data for general use\n    ImVector<double>   TempDouble1, TempDouble2;\n    ImVector<int>      TempInt1;\n\n    // Misc\n    int                DigitalPlotItemCnt;\n    int                DigitalPlotOffset;\n    ImPlotNextPlotData NextPlotData;\n    ImPlotNextItemData NextItemData;\n    ImPlotInputMap     InputMap;\n    bool               OpenContextThisFrame;\n    ImGuiTextBuffer    MousePosStringBuilder;\n    ImPlotItemGroup*   SortItems;\n\n    // Align plots\n    ImPool<ImPlotAlignmentData> AlignmentData;\n    ImPlotAlignmentData*        CurrentAlignmentH;\n    ImPlotAlignmentData*        CurrentAlignmentV;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Internal API\n// No guarantee of forward compatibility here!\n//-----------------------------------------------------------------------------\n\nnamespace ImPlot {\n\n//-----------------------------------------------------------------------------\n// [SECTION] Context Utils\n//-----------------------------------------------------------------------------\n\n// Initializes an ImPlotContext\nIMPLOT_API void Initialize(ImPlotContext* ctx);\n// Resets an ImPlot context for the next call to BeginPlot\nIMPLOT_API void ResetCtxForNextPlot(ImPlotContext* ctx);\n// Resets an ImPlot context for the next call to BeginAlignedPlots\nIMPLOT_API void ResetCtxForNextAlignedPlots(ImPlotContext* ctx);\n// Resets an ImPlot context for the next call to BeginSubplot\nIMPLOT_API void ResetCtxForNextSubplot(ImPlotContext* ctx);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Plot Utils\n//-----------------------------------------------------------------------------\n\n// Gets a plot from the current ImPlotContext\nIMPLOT_API ImPlotPlot* GetPlot(const char* title);\n// Gets the current plot from the current ImPlotContext\nIMPLOT_API ImPlotPlot* GetCurrentPlot();\n// Busts the cache for every plot in the current context\nIMPLOT_API void BustPlotCache();\n\n// Shows a plot's context menu.\nIMPLOT_API void ShowPlotContextMenu(ImPlotPlot& plot);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Setup Utils\n//-----------------------------------------------------------------------------\n\n// Lock Setup and call SetupFinish if necessary.\nstatic inline void SetupLock() {\n    ImPlotContext& gp = *GImPlot;\n    if (!gp.CurrentPlot->SetupLocked)\n        SetupFinish();\n    gp.CurrentPlot->SetupLocked = true;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Subplot Utils\n//-----------------------------------------------------------------------------\n\n// Advances to next subplot\nIMPLOT_API void SubplotNextCell();\n\n// Shows a subplot's context menu.\nIMPLOT_API void ShowSubplotsContextMenu(ImPlotSubplot& subplot);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Item Utils\n//-----------------------------------------------------------------------------\n\n// Begins a new item. Returns false if the item should not be plotted. Pushes PlotClipRect.\nIMPLOT_API bool BeginItem(const char* label_id, ImPlotItemFlags flags=0, ImPlotCol recolor_from=IMPLOT_AUTO);\n\n// Same as above but with fitting functionality.\ntemplate <typename _Fitter>\nbool BeginItemEx(const char* label_id, const _Fitter& fitter, ImPlotItemFlags flags=0, ImPlotCol recolor_from=IMPLOT_AUTO) {\n    if (BeginItem(label_id, flags, recolor_from)) {\n        ImPlotPlot& plot = *GetCurrentPlot();\n        if (plot.FitThisFrame && !ImHasFlag(flags, ImPlotItemFlags_NoFit))\n            fitter.Fit(plot.Axes[plot.CurrentX], plot.Axes[plot.CurrentY]);\n        return true;\n    }\n    return false;\n}\n\n// Ends an item (call only if BeginItem returns true). Pops PlotClipRect.\nIMPLOT_API void EndItem();\n\n// Register or get an existing item from the current plot.\nIMPLOT_API ImPlotItem* RegisterOrGetItem(const char* label_id, ImPlotItemFlags flags, bool* just_created = nullptr);\n// Get a plot item from the current plot.\nIMPLOT_API ImPlotItem* GetItem(const char* label_id);\n// Gets the current item.\nIMPLOT_API ImPlotItem* GetCurrentItem();\n// Busts the cache for every item for every plot in the current context.\nIMPLOT_API void BustItemCache();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Axis Utils\n//-----------------------------------------------------------------------------\n\n// Returns true if any enabled axis is locked from user input.\nstatic inline bool AnyAxesInputLocked(ImPlotAxis* axes, int count) {\n    for (int i = 0; i < count; ++i) {\n        if (axes[i].Enabled && axes[i].IsInputLocked())\n            return true;\n    }\n    return false;\n}\n\n// Returns true if all enabled axes are locked from user input.\nstatic inline bool AllAxesInputLocked(ImPlotAxis* axes, int count) {\n    for (int i = 0; i < count; ++i) {\n        if (axes[i].Enabled && !axes[i].IsInputLocked())\n            return false;\n    }\n    return true;\n}\n\nstatic inline bool AnyAxesHeld(ImPlotAxis* axes, int count) {\n    for (int i = 0; i < count; ++i) {\n        if (axes[i].Enabled && axes[i].Held)\n            return true;\n    }\n    return false;\n}\n\nstatic inline bool AnyAxesHovered(ImPlotAxis* axes, int count) {\n    for (int i = 0; i < count; ++i) {\n        if (axes[i].Enabled && axes[i].Hovered)\n            return true;\n    }\n    return false;\n}\n\n// Returns true if the user has requested data to be fit.\nstatic inline bool FitThisFrame() {\n    return GImPlot->CurrentPlot->FitThisFrame;\n}\n\n// Extends the current plot's axes so that it encompasses a vertical line at x\nstatic inline void FitPointX(double x) {\n    ImPlotPlot& plot   = *GetCurrentPlot();\n    ImPlotAxis& x_axis = plot.Axes[plot.CurrentX];\n    x_axis.ExtendFit(x);\n}\n\n// Extends the current plot's axes so that it encompasses a horizontal line at y\nstatic inline void FitPointY(double y) {\n    ImPlotPlot& plot   = *GetCurrentPlot();\n    ImPlotAxis& y_axis = plot.Axes[plot.CurrentY];\n    y_axis.ExtendFit(y);\n}\n\n// Extends the current plot's axes so that it encompasses point p\nstatic inline void FitPoint(const ImPlotPoint& p) {\n    ImPlotPlot& plot   = *GetCurrentPlot();\n    ImPlotAxis& x_axis = plot.Axes[plot.CurrentX];\n    ImPlotAxis& y_axis = plot.Axes[plot.CurrentY];\n    x_axis.ExtendFitWith(y_axis, p.x, p.y);\n    y_axis.ExtendFitWith(x_axis, p.y, p.x);\n}\n\n// Returns true if two ranges overlap\nstatic inline bool RangesOverlap(const ImPlotRange& r1, const ImPlotRange& r2)\n{ return r1.Min <= r2.Max && r2.Min <= r1.Max; }\n\n// Shows an axis's context menu.\nIMPLOT_API void ShowAxisContextMenu(ImPlotAxis& axis, ImPlotAxis* equal_axis, bool time_allowed = false);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Legend Utils\n//-----------------------------------------------------------------------------\n\n// Gets the position of an inner rect that is located inside of an outer rect according to an ImPlotLocation and padding amount.\nIMPLOT_API ImVec2 GetLocationPos(const ImRect& outer_rect, const ImVec2& inner_size, ImPlotLocation location, const ImVec2& pad = ImVec2(0,0));\n// Calculates the bounding box size of a legend _before_ clipping.\nIMPLOT_API ImVec2 CalcLegendSize(ImPlotItemGroup& items, const ImVec2& pad, const ImVec2& spacing, bool vertical);\n// Clips calculated legend size\nIMPLOT_API bool ClampLegendRect(ImRect& legend_rect, const ImRect& outer_rect, const ImVec2& pad);\n// Renders legend entries into a bounding box\nIMPLOT_API bool ShowLegendEntries(ImPlotItemGroup& items, const ImRect& legend_bb, bool interactable, const ImVec2& pad, const ImVec2& spacing, bool vertical, ImDrawList& DrawList);\n// Shows an alternate legend for the plot identified by #title_id, outside of the plot frame (can be called before or after of Begin/EndPlot but must occur in the same ImGui window! This is not thoroughly tested nor scrollable!).\nIMPLOT_API void ShowAltLegend(const char* title_id, bool vertical = true, const ImVec2 size = ImVec2(0,0), bool interactable = true);\n// Shows a legend's context menu.\nIMPLOT_API bool ShowLegendContextMenu(ImPlotLegend& legend, bool visible);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Label Utils\n//-----------------------------------------------------------------------------\n\n// Create a a string label for a an axis value\nIMPLOT_API void LabelAxisValue(const ImPlotAxis& axis, double value, char* buff, int size, bool round = false);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Styling Utils\n//-----------------------------------------------------------------------------\n\n// Get styling data for next item (call between Begin/EndItem)\nstatic inline const ImPlotNextItemData& GetItemData() { return GImPlot->NextItemData; }\n\n// Returns true if a color is set to be automatically determined\nstatic inline bool IsColorAuto(const ImVec4& col) { return col.w == -1; }\n// Returns true if a style color is set to be automatically determined\nstatic inline bool IsColorAuto(ImPlotCol idx) { return IsColorAuto(GImPlot->Style.Colors[idx]); }\n// Returns the automatically deduced style color\nIMPLOT_API ImVec4 GetAutoColor(ImPlotCol idx);\n\n// Returns the style color whether it is automatic or custom set\nstatic inline ImVec4 GetStyleColorVec4(ImPlotCol idx) { return IsColorAuto(idx) ? GetAutoColor(idx) : GImPlot->Style.Colors[idx]; }\nstatic inline ImU32  GetStyleColorU32(ImPlotCol idx)  { return ImGui::ColorConvertFloat4ToU32(GetStyleColorVec4(idx)); }\n\n// Draws vertical text. The position is the bottom left of the text rect.\nIMPLOT_API void AddTextVertical(ImDrawList *DrawList, ImVec2 pos, ImU32 col, const char* text_begin, const char* text_end = nullptr);\n// Draws multiline horizontal text centered.\nIMPLOT_API void AddTextCentered(ImDrawList* DrawList, ImVec2 top_center, ImU32 col, const char* text_begin, const char* text_end = nullptr);\n// Calculates the size of vertical text\nstatic inline ImVec2 CalcTextSizeVertical(const char *text) {\n    ImVec2 sz = ImGui::CalcTextSize(text);\n    return ImVec2(sz.y, sz.x);\n}\n// Returns white or black text given background color\nstatic inline ImU32 CalcTextColor(const ImVec4& bg) { return (bg.x * 0.299f + bg.y * 0.587f + bg.z * 0.114f) > 0.5f ? IM_COL32_BLACK : IM_COL32_WHITE; }\nstatic inline ImU32 CalcTextColor(ImU32 bg)         { return CalcTextColor(ImGui::ColorConvertU32ToFloat4(bg)); }\n// Lightens or darkens a color for hover\nstatic inline ImU32 CalcHoverColor(ImU32 col)       {  return ImMixU32(col, CalcTextColor(col), 32); }\n\n// Clamps a label position so that it fits a rect defined by Min/Max\nstatic inline ImVec2 ClampLabelPos(ImVec2 pos, const ImVec2& size, const ImVec2& Min, const ImVec2& Max) {\n    if (pos.x < Min.x)              pos.x = Min.x;\n    if (pos.y < Min.y)              pos.y = Min.y;\n    if ((pos.x + size.x) > Max.x)   pos.x = Max.x - size.x;\n    if ((pos.y + size.y) > Max.y)   pos.y = Max.y - size.y;\n    return pos;\n}\n\n// Returns a color from the Color map given an index >= 0 (modulo will be performed).\nIMPLOT_API ImU32  GetColormapColorU32(int idx, ImPlotColormap cmap);\n// Returns the next unused colormap color and advances the colormap. Can be used to skip colors if desired.\nIMPLOT_API ImU32  NextColormapColorU32();\n// Linearly interpolates a color from the current colormap given t between 0 and 1.\nIMPLOT_API ImU32  SampleColormapU32(float t, ImPlotColormap cmap);\n\n// Render a colormap bar\nIMPLOT_API void RenderColorBar(const ImU32* colors, int size, ImDrawList& DrawList, const ImRect& bounds, bool vert, bool reversed, bool continuous);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Math and Misc Utils\n//-----------------------------------------------------------------------------\n\n// Rounds x to powers of 2,5 and 10 for generating axis labels (from Graphics Gems 1 Chapter 11.2)\nIMPLOT_API double NiceNum(double x, bool round);\n// Computes order of magnitude of double.\nstatic inline int OrderOfMagnitude(double val) { return val == 0 ? 0 : (int)(floor(log10(fabs(val)))); }\n// Returns the precision required for a order of magnitude.\nstatic inline int OrderToPrecision(int order) { return order > 0 ? 0 : 1 - order; }\n// Returns a floating point precision to use given a value\nstatic inline int Precision(double val) { return OrderToPrecision(OrderOfMagnitude(val)); }\n// Round a value to a given precision\nstatic inline double RoundTo(double val, int prec) { double p = pow(10,(double)prec); return floor(val*p+0.5)/p; }\n\n// Returns the intersection point of two lines A and B (assumes they are not parallel!)\nstatic inline ImVec2 Intersection(const ImVec2& a1, const ImVec2& a2, const ImVec2& b1, const ImVec2& b2) {\n    float v1 = (a1.x * a2.y - a1.y * a2.x);  float v2 = (b1.x * b2.y - b1.y * b2.x);\n    float v3 = ((a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x));\n    return ImVec2((v1 * (b1.x - b2.x) - v2 * (a1.x - a2.x)) / v3, (v1 * (b1.y - b2.y) - v2 * (a1.y - a2.y)) / v3);\n}\n\n// Fills a buffer with n samples linear interpolated from vmin to vmax\ntemplate <typename T>\nvoid FillRange(ImVector<T>& buffer, int n, T vmin, T vmax) {\n    buffer.resize(n);\n    T step = (vmax - vmin) / (n - 1);\n    for (int i = 0; i < n; ++i) {\n        buffer[i] = vmin + i * step;\n    }\n}\n\n// Calculate histogram bin counts and widths\ntemplate <typename T>\nstatic inline void CalculateBins(const T* values, int count, ImPlotBin meth, const ImPlotRange& range, int& bins_out, double& width_out) {\n    switch (meth) {\n        case ImPlotBin_Sqrt:\n            bins_out  = (int)ceil(sqrt(count));\n            break;\n        case ImPlotBin_Sturges:\n            bins_out  = (int)ceil(1.0 + log2(count));\n            break;\n        case ImPlotBin_Rice:\n            bins_out  = (int)ceil(2 * cbrt(count));\n            break;\n        case ImPlotBin_Scott:\n            width_out = 3.49 * ImStdDev(values, count) / cbrt(count);\n            bins_out  = (int)round(range.Size() / width_out);\n            break;\n    }\n    width_out = range.Size() / bins_out;\n}\n\n//-----------------------------------------------------------------------------\n// Time Utils\n//-----------------------------------------------------------------------------\n\n// Returns true if year is leap year (366 days long)\nstatic inline bool IsLeapYear(int year) {\n    return  year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\n}\n// Returns the number of days in a month, accounting for Feb. leap years. #month is zero indexed.\nstatic inline int GetDaysInMonth(int year, int month) {\n    static const int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    return  days[month] + (int)(month == 1 && IsLeapYear(year));\n}\n\n// Make a UNIX timestamp from a tm struct expressed in UTC time (i.e. GMT timezone).\nIMPLOT_API ImPlotTime MkGmtTime(struct tm *ptm);\n// Make a tm struct expressed in UTC time (i.e. GMT timezone) from a UNIX timestamp.\nIMPLOT_API tm* GetGmtTime(const ImPlotTime& t, tm* ptm);\n\n// Make a UNIX timestamp from a tm struct expressed in local time.\nIMPLOT_API ImPlotTime MkLocTime(struct tm *ptm);\n// Make a tm struct expressed in local time from a UNIX timestamp.\nIMPLOT_API tm* GetLocTime(const ImPlotTime& t, tm* ptm);\n\n// NB: The following functions only work if there is a current ImPlotContext because the\n// internal tm struct is owned by the context! They are aware of ImPlotStyle.UseLocalTime.\n\n// // Make a UNIX timestamp from a tm struct according to the current ImPlotStyle.UseLocalTime setting.\nstatic inline ImPlotTime MkTime(struct tm *ptm) {\n    if (GetStyle().UseLocalTime) return MkLocTime(ptm);\n    else                         return MkGmtTime(ptm);\n}\n// Get a tm struct from a UNIX timestamp according to the current ImPlotStyle.UseLocalTime setting.\nstatic inline tm* GetTime(const ImPlotTime& t, tm* ptm) {\n    if (GetStyle().UseLocalTime) return GetLocTime(t,ptm);\n    else                         return GetGmtTime(t,ptm);\n}\n\n// Make a timestamp from time components.\n// year[1970-3000], month[0-11], day[1-31], hour[0-23], min[0-59], sec[0-59], us[0,999999]\nIMPLOT_API ImPlotTime MakeTime(int year, int month = 0, int day = 1, int hour = 0, int min = 0, int sec = 0, int us = 0);\n// Get year component from timestamp [1970-3000]\nIMPLOT_API int GetYear(const ImPlotTime& t);\n// Get month component from timestamp [0-11]\nIMPLOT_API int GetMonth(const ImPlotTime& t);\n\n// Adds or subtracts time from a timestamp. #count > 0 to add, < 0 to subtract.\nIMPLOT_API ImPlotTime AddTime(const ImPlotTime& t, ImPlotTimeUnit unit, int count);\n// Rounds a timestamp down to nearest unit.\nIMPLOT_API ImPlotTime FloorTime(const ImPlotTime& t, ImPlotTimeUnit unit);\n// Rounds a timestamp up to the nearest unit.\nIMPLOT_API ImPlotTime CeilTime(const ImPlotTime& t, ImPlotTimeUnit unit);\n// Rounds a timestamp up or down to the nearest unit.\nIMPLOT_API ImPlotTime RoundTime(const ImPlotTime& t, ImPlotTimeUnit unit);\n// Combines the date of one timestamp with the time-of-day of another timestamp.\nIMPLOT_API ImPlotTime CombineDateTime(const ImPlotTime& date_part, const ImPlotTime& time_part);\n\n// Get the current time as a timestamp.\nstatic inline ImPlotTime Now() { return ImPlotTime::FromDouble((double)time(nullptr)); }\n// Get the current date as a timestamp.\nstatic inline ImPlotTime Today() { return ImPlot::FloorTime(Now(), ImPlotTimeUnit_Day); }\n\n// Formats the time part of timestamp t into a buffer according to #fmt\nIMPLOT_API int FormatTime(const ImPlotTime& t, char* buffer, int size, ImPlotTimeFmt fmt, bool use_24_hr_clk);\n// Formats the date part of timestamp t into a buffer according to #fmt\nIMPLOT_API int FormatDate(const ImPlotTime& t, char* buffer, int size, ImPlotDateFmt fmt, bool use_iso_8601);\n// Formats the time and/or date parts of a timestamp t into a buffer according to #fmt\nIMPLOT_API int FormatDateTime(const ImPlotTime& t, char* buffer, int size, ImPlotDateTimeSpec fmt);\n\n// Shows a date picker widget block (year/month/day).\n// #level = 0 for day, 1 for month, 2 for year. Modified by user interaction.\n// #t will be set when a day is clicked and the function will return true.\n// #t1 and #t2 are optional dates to highlight.\nIMPLOT_API bool ShowDatePicker(const char* id, int* level, ImPlotTime* t, const ImPlotTime* t1 = nullptr, const ImPlotTime* t2 = nullptr);\n// Shows a time picker widget block (hour/min/sec).\n// #t will be set when a new hour, minute, or sec is selected or am/pm is toggled, and the function will return true.\nIMPLOT_API bool ShowTimePicker(const char* id, ImPlotTime* t);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Transforms\n//-----------------------------------------------------------------------------\n\nstatic inline double TransformForward_Log10(double v, void*) {\n    v = v <= 0.0 ? DBL_MIN : v;\n    return ImLog10(v);\n}\n\nstatic inline double TransformInverse_Log10(double v, void*) {\n    return ImPow(10, v);\n}\n\nstatic inline double TransformForward_SymLog(double v, void*) {\n    return 2.0 * ImAsinh(v / 2.0);\n}\n\nstatic inline double TransformInverse_SymLog(double v, void*) {\n    return 2.0 * ImSinh(v / 2.0);\n}\n\nstatic inline double TransformForward_Logit(double v, void*) {\n    v = ImClamp(v, DBL_MIN, 1.0 - DBL_EPSILON);\n    return ImLog10(v / (1 - v));\n}\n\nstatic inline double TransformInverse_Logit(double v, void*) {\n    return 1.0 / (1.0 + ImPow(10,-v));\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Formatters\n//-----------------------------------------------------------------------------\n\nstatic inline int Formatter_Default(double value, char* buff, int size, void* data) {\n    char* fmt = (char*)data;\n    return ImFormatString(buff, size, fmt, value);\n}\n\nstatic inline int Formatter_Logit(double value, char* buff, int size, void*) {\n    if (value == 0.5)\n        return ImFormatString(buff,size,\"1/2\");\n    else if (value < 0.5)\n        return ImFormatString(buff,size,\"%g\", value);\n    else\n        return ImFormatString(buff,size,\"1 - %g\", 1 - value);\n}\n\nstruct Formatter_Time_Data {\n    ImPlotTime Time;\n    ImPlotDateTimeSpec Spec;\n    ImPlotFormatter UserFormatter;\n    void* UserFormatterData;\n};\n\nstatic inline int Formatter_Time(double, char* buff, int size, void* data) {\n    Formatter_Time_Data* ftd = (Formatter_Time_Data*)data;\n    return FormatDateTime(ftd->Time, buff, size, ftd->Spec);\n}\n\n//------------------------------------------------------------------------------\n// [SECTION] Locator\n//------------------------------------------------------------------------------\n\nvoid Locator_Default(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data);\nvoid Locator_Time(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data);\nvoid Locator_Log10(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data);\nvoid Locator_SymLog(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data);\n\n} // namespace ImPlot\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "implot_items.cpp",
          "type": "blob",
          "size": 121.73046875,
          "content": "// MIT License\n\n// Copyright (c) 2023 Evan Pezent\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// ImPlot v0.17\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"implot.h\"\n#ifndef IMGUI_DISABLE\n#include \"implot_internal.h\"\n\n//-----------------------------------------------------------------------------\n// [SECTION] Macros and Defines\n//-----------------------------------------------------------------------------\n\n#define SQRT_1_2 0.70710678118f\n#define SQRT_3_2 0.86602540378f\n\n#ifndef IMPLOT_NO_FORCE_INLINE\n    #ifdef _MSC_VER\n        #define IMPLOT_INLINE __forceinline\n    #elif defined(__GNUC__)\n        #define IMPLOT_INLINE inline __attribute__((__always_inline__))\n    #elif defined(__CLANG__)\n        #if __has_attribute(__always_inline__)\n            #define IMPLOT_INLINE inline __attribute__((__always_inline__))\n        #else\n            #define IMPLOT_INLINE inline\n        #endif\n    #else\n        #define IMPLOT_INLINE inline\n    #endif\n#else\n    #define IMPLOT_INLINE inline\n#endif\n\n#if defined __SSE__ || defined __x86_64__ || defined _M_X64\n#ifndef IMGUI_ENABLE_SSE\n#include <immintrin.h>\n#endif\nstatic IMPLOT_INLINE float  ImInvSqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }\n#else\nstatic IMPLOT_INLINE float  ImInvSqrt(float x) { return 1.0f / sqrtf(x); }\n#endif\n\n#define IMPLOT_NORMALIZE2F_OVER_ZERO(VX,VY) do { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImInvSqrt(d2); VX *= inv_len; VY *= inv_len; } } while (0)\n\n// Support for pre-1.82 versions. Users on 1.82+ can use 0 (default) flags to mean \"all corners\" but in order to support older versions we are more explicit.\n#if (IMGUI_VERSION_NUM < 18102) && !defined(ImDrawFlags_RoundCornersAll)\n#define ImDrawFlags_RoundCornersAll ImDrawCornerFlags_All\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Template instantiation utility\n//-----------------------------------------------------------------------------\n\n// By default, templates are instantiated for `float`, `double`, and for the following integer types, which are defined in imgui.h:\n//     signed char         ImS8;   // 8-bit signed integer\n//     unsigned char       ImU8;   // 8-bit unsigned integer\n//     signed short        ImS16;  // 16-bit signed integer\n//     unsigned short      ImU16;  // 16-bit unsigned integer\n//     signed int          ImS32;  // 32-bit signed integer == int\n//     unsigned int        ImU32;  // 32-bit unsigned integer\n//     signed   long long  ImS64;  // 64-bit signed integer\n//     unsigned long long  ImU64;  // 64-bit unsigned integer\n// (note: this list does *not* include `long`, `unsigned long` and `long double`)\n//\n// You can customize the supported types by defining IMPLOT_CUSTOM_NUMERIC_TYPES at compile time to define your own type list.\n//    As an example, you could use the compile time define given by the line below in order to support only float and double.\n//        -DIMPLOT_CUSTOM_NUMERIC_TYPES=\"(float)(double)\"\n//    In order to support all known C++ types, use:\n//        -DIMPLOT_CUSTOM_NUMERIC_TYPES=\"(signed char)(unsigned char)(signed short)(unsigned short)(signed int)(unsigned int)(signed long)(unsigned long)(signed long long)(unsigned long long)(float)(double)(long double)\"\n\n#ifdef IMPLOT_CUSTOM_NUMERIC_TYPES\n    #define IMPLOT_NUMERIC_TYPES IMPLOT_CUSTOM_NUMERIC_TYPES\n#else\n    #define IMPLOT_NUMERIC_TYPES (ImS8)(ImU8)(ImS16)(ImU16)(ImS32)(ImU32)(ImS64)(ImU64)(float)(double)\n#endif\n\n// CALL_INSTANTIATE_FOR_NUMERIC_TYPES will duplicate the template instantion code `INSTANTIATE_MACRO(T)` on supported types.\n#define _CAT(x, y) _CAT_(x, y)\n#define _CAT_(x,y) x ## y\n#define _INSTANTIATE_FOR_NUMERIC_TYPES(chain) _CAT(_INSTANTIATE_FOR_NUMERIC_TYPES_1 chain, _END)\n#define _INSTANTIATE_FOR_NUMERIC_TYPES_1(T) INSTANTIATE_MACRO(T) _INSTANTIATE_FOR_NUMERIC_TYPES_2\n#define _INSTANTIATE_FOR_NUMERIC_TYPES_2(T) INSTANTIATE_MACRO(T) _INSTANTIATE_FOR_NUMERIC_TYPES_1\n#define _INSTANTIATE_FOR_NUMERIC_TYPES_1_END\n#define _INSTANTIATE_FOR_NUMERIC_TYPES_2_END\n#define CALL_INSTANTIATE_FOR_NUMERIC_TYPES() _INSTANTIATE_FOR_NUMERIC_TYPES(IMPLOT_NUMERIC_TYPES)\n\nnamespace ImPlot {\n\n//-----------------------------------------------------------------------------\n// [SECTION] Utils\n//-----------------------------------------------------------------------------\n\n// Calc maximum index size of ImDrawIdx\ntemplate <typename T>\nstruct MaxIdx { static const unsigned int Value; };\ntemplate <> const unsigned int MaxIdx<unsigned short>::Value = 65535;\ntemplate <> const unsigned int MaxIdx<unsigned int>::Value   = 4294967295;\n\nIMPLOT_INLINE void GetLineRenderProps(const ImDrawList& draw_list, float& half_weight, ImVec2& tex_uv0, ImVec2& tex_uv1) {\n    const bool aa = ImHasFlag(draw_list.Flags, ImDrawListFlags_AntiAliasedLines) &&\n                    ImHasFlag(draw_list.Flags, ImDrawListFlags_AntiAliasedLinesUseTex);\n    if (aa) {\n        ImVec4 tex_uvs = draw_list._Data->TexUvLines[(int)(half_weight*2)];\n        tex_uv0 = ImVec2(tex_uvs.x, tex_uvs.y);\n        tex_uv1 = ImVec2(tex_uvs.z, tex_uvs.w);\n        half_weight += 1;\n    }\n    else {\n        tex_uv0 = tex_uv1 = draw_list._Data->TexUvWhitePixel;\n    }\n}\n\nIMPLOT_INLINE void PrimLine(ImDrawList& draw_list, const ImVec2& P1, const ImVec2& P2, float half_weight, ImU32 col, const ImVec2& tex_uv0, const ImVec2 tex_uv1) {\n    float dx = P2.x - P1.x;\n    float dy = P2.y - P1.y;\n    IMPLOT_NORMALIZE2F_OVER_ZERO(dx, dy);\n    dx *= half_weight;\n    dy *= half_weight;\n    draw_list._VtxWritePtr[0].pos.x = P1.x + dy;\n    draw_list._VtxWritePtr[0].pos.y = P1.y - dx;\n    draw_list._VtxWritePtr[0].uv    = tex_uv0;\n    draw_list._VtxWritePtr[0].col   = col;\n    draw_list._VtxWritePtr[1].pos.x = P2.x + dy;\n    draw_list._VtxWritePtr[1].pos.y = P2.y - dx;\n    draw_list._VtxWritePtr[1].uv    = tex_uv0;\n    draw_list._VtxWritePtr[1].col   = col;\n    draw_list._VtxWritePtr[2].pos.x = P2.x - dy;\n    draw_list._VtxWritePtr[2].pos.y = P2.y + dx;\n    draw_list._VtxWritePtr[2].uv    = tex_uv1;\n    draw_list._VtxWritePtr[2].col   = col;\n    draw_list._VtxWritePtr[3].pos.x = P1.x - dy;\n    draw_list._VtxWritePtr[3].pos.y = P1.y + dx;\n    draw_list._VtxWritePtr[3].uv    = tex_uv1;\n    draw_list._VtxWritePtr[3].col   = col;\n    draw_list._VtxWritePtr += 4;\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n    draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n    draw_list._IdxWritePtr += 6;\n    draw_list._VtxCurrentIdx += 4;\n}\n\nIMPLOT_INLINE void PrimRectFill(ImDrawList& draw_list, const ImVec2& Pmin, const ImVec2& Pmax, ImU32 col, const ImVec2& uv) {\n    draw_list._VtxWritePtr[0].pos   = Pmin;\n    draw_list._VtxWritePtr[0].uv    = uv;\n    draw_list._VtxWritePtr[0].col   = col;\n    draw_list._VtxWritePtr[1].pos   = Pmax;\n    draw_list._VtxWritePtr[1].uv    = uv;\n    draw_list._VtxWritePtr[1].col   = col;\n    draw_list._VtxWritePtr[2].pos.x = Pmin.x;\n    draw_list._VtxWritePtr[2].pos.y = Pmax.y;\n    draw_list._VtxWritePtr[2].uv    = uv;\n    draw_list._VtxWritePtr[2].col   = col;\n    draw_list._VtxWritePtr[3].pos.x = Pmax.x;\n    draw_list._VtxWritePtr[3].pos.y = Pmin.y;\n    draw_list._VtxWritePtr[3].uv    = uv;\n    draw_list._VtxWritePtr[3].col   = col;\n    draw_list._VtxWritePtr += 4;\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n    draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n    draw_list._IdxWritePtr += 6;\n    draw_list._VtxCurrentIdx += 4;\n}\n\nIMPLOT_INLINE void PrimRectLine(ImDrawList& draw_list, const ImVec2& Pmin, const ImVec2& Pmax, float weight, ImU32 col, const ImVec2& uv) {\n\n    draw_list._VtxWritePtr[0].pos.x = Pmin.x;\n    draw_list._VtxWritePtr[0].pos.y = Pmin.y;\n    draw_list._VtxWritePtr[0].uv    = uv;\n    draw_list._VtxWritePtr[0].col   = col;\n\n    draw_list._VtxWritePtr[1].pos.x = Pmin.x;\n    draw_list._VtxWritePtr[1].pos.y = Pmax.y;\n    draw_list._VtxWritePtr[1].uv    = uv;\n    draw_list._VtxWritePtr[1].col   = col;\n\n    draw_list._VtxWritePtr[2].pos.x = Pmax.x;\n    draw_list._VtxWritePtr[2].pos.y = Pmax.y;\n    draw_list._VtxWritePtr[2].uv    = uv;\n    draw_list._VtxWritePtr[2].col   = col;\n\n    draw_list._VtxWritePtr[3].pos.x = Pmax.x;\n    draw_list._VtxWritePtr[3].pos.y = Pmin.y;\n    draw_list._VtxWritePtr[3].uv    = uv;\n    draw_list._VtxWritePtr[3].col   = col;\n\n    draw_list._VtxWritePtr[4].pos.x = Pmin.x + weight;\n    draw_list._VtxWritePtr[4].pos.y = Pmin.y + weight;\n    draw_list._VtxWritePtr[4].uv    = uv;\n    draw_list._VtxWritePtr[4].col   = col;\n\n    draw_list._VtxWritePtr[5].pos.x = Pmin.x + weight;\n    draw_list._VtxWritePtr[5].pos.y = Pmax.y - weight;\n    draw_list._VtxWritePtr[5].uv    = uv;\n    draw_list._VtxWritePtr[5].col   = col;\n\n    draw_list._VtxWritePtr[6].pos.x = Pmax.x - weight;\n    draw_list._VtxWritePtr[6].pos.y = Pmax.y - weight;\n    draw_list._VtxWritePtr[6].uv    = uv;\n    draw_list._VtxWritePtr[6].col   = col;\n\n    draw_list._VtxWritePtr[7].pos.x = Pmax.x - weight;\n    draw_list._VtxWritePtr[7].pos.y = Pmin.y + weight;\n    draw_list._VtxWritePtr[7].uv    = uv;\n    draw_list._VtxWritePtr[7].col   = col;\n\n    draw_list._VtxWritePtr += 8;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);\n    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);\n    draw_list._IdxWritePtr += 3;\n\n    draw_list._VtxCurrentIdx += 8;\n}\n\n\n//-----------------------------------------------------------------------------\n// [SECTION] Item Utils\n//-----------------------------------------------------------------------------\n\nImPlotItem* RegisterOrGetItem(const char* label_id, ImPlotItemFlags flags, bool* just_created) {\n    ImPlotContext& gp = *GImPlot;\n    ImPlotItemGroup& Items = *gp.CurrentItems;\n    ImGuiID id = Items.GetItemID(label_id);\n    if (just_created != nullptr)\n        *just_created = Items.GetItem(id) == nullptr;\n    ImPlotItem* item = Items.GetOrAddItem(id);\n    if (item->SeenThisFrame)\n        return item;\n    item->SeenThisFrame = true;\n    int idx = Items.GetItemIndex(item);\n    item->ID = id;\n    if (!ImHasFlag(flags, ImPlotItemFlags_NoLegend) && ImGui::FindRenderedTextEnd(label_id, nullptr) != label_id) {\n        Items.Legend.Indices.push_back(idx);\n        item->NameOffset = Items.Legend.Labels.size();\n        Items.Legend.Labels.append(label_id, label_id + strlen(label_id) + 1);\n    }\n    else {\n        item->Show = true;\n    }\n    return item;\n}\n\nImPlotItem* GetItem(const char* label_id) {\n    ImPlotContext& gp = *GImPlot;\n    return gp.CurrentItems->GetItem(label_id);\n}\n\nbool IsItemHidden(const char* label_id) {\n    ImPlotItem* item = GetItem(label_id);\n    return item != nullptr && !item->Show;\n}\n\nImPlotItem* GetCurrentItem() {\n    ImPlotContext& gp = *GImPlot;\n    return gp.CurrentItem;\n}\n\nvoid SetNextLineStyle(const ImVec4& col, float weight) {\n    ImPlotContext& gp = *GImPlot;\n    gp.NextItemData.Colors[ImPlotCol_Line] = col;\n    gp.NextItemData.LineWeight             = weight;\n}\n\nvoid SetNextFillStyle(const ImVec4& col, float alpha) {\n    ImPlotContext& gp = *GImPlot;\n    gp.NextItemData.Colors[ImPlotCol_Fill] = col;\n    gp.NextItemData.FillAlpha              = alpha;\n}\n\nvoid SetNextMarkerStyle(ImPlotMarker marker, float size, const ImVec4& fill, float weight, const ImVec4& outline) {\n    ImPlotContext& gp = *GImPlot;\n    gp.NextItemData.Marker                          = marker;\n    gp.NextItemData.Colors[ImPlotCol_MarkerFill]    = fill;\n    gp.NextItemData.MarkerSize                      = size;\n    gp.NextItemData.Colors[ImPlotCol_MarkerOutline] = outline;\n    gp.NextItemData.MarkerWeight                    = weight;\n}\n\nvoid SetNextErrorBarStyle(const ImVec4& col, float size, float weight) {\n    ImPlotContext& gp = *GImPlot;\n    gp.NextItemData.Colors[ImPlotCol_ErrorBar] = col;\n    gp.NextItemData.ErrorBarSize               = size;\n    gp.NextItemData.ErrorBarWeight             = weight;\n}\n\nImVec4 GetLastItemColor() {\n    ImPlotContext& gp = *GImPlot;\n    if (gp.PreviousItem)\n        return ImGui::ColorConvertU32ToFloat4(gp.PreviousItem->Color);\n    return ImVec4();\n}\n\nvoid BustItemCache() {\n    ImPlotContext& gp = *GImPlot;\n    for (int p = 0; p < gp.Plots.GetBufSize(); ++p) {\n        ImPlotPlot& plot = *gp.Plots.GetByIndex(p);\n        plot.Items.Reset();\n    }\n    for (int p = 0; p < gp.Subplots.GetBufSize(); ++p) {\n        ImPlotSubplot& subplot = *gp.Subplots.GetByIndex(p);\n        subplot.Items.Reset();\n    }\n}\n\nvoid BustColorCache(const char* plot_title_id) {\n    ImPlotContext& gp = *GImPlot;\n    if (plot_title_id == nullptr) {\n        BustItemCache();\n    }\n    else {\n        ImGuiID id = ImGui::GetCurrentWindow()->GetID(plot_title_id);\n        ImPlotPlot* plot = gp.Plots.GetByKey(id);\n        if (plot != nullptr)\n            plot->Items.Reset();\n        else {\n            ImPlotSubplot* subplot = gp.Subplots.GetByKey(id);\n            if (subplot != nullptr)\n                subplot->Items.Reset();\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] BeginItem / EndItem\n//-----------------------------------------------------------------------------\n\nstatic const float ITEM_HIGHLIGHT_LINE_SCALE = 2.0f;\nstatic const float ITEM_HIGHLIGHT_MARK_SCALE = 1.25f;\n\n// Begins a new item. Returns false if the item should not be plotted.\nbool BeginItem(const char* label_id, ImPlotItemFlags flags, ImPlotCol recolor_from) {\n    ImPlotContext& gp = *GImPlot;\n    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, \"PlotX() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    bool just_created;\n    ImPlotItem* item = RegisterOrGetItem(label_id, flags, &just_created);\n    // set current item\n    gp.CurrentItem = item;\n    ImPlotNextItemData& s = gp.NextItemData;\n    // set/override item color\n    if (recolor_from != -1) {\n        if (!IsColorAuto(s.Colors[recolor_from]))\n            item->Color = ImGui::ColorConvertFloat4ToU32(s.Colors[recolor_from]);\n        else if (!IsColorAuto(gp.Style.Colors[recolor_from]))\n            item->Color = ImGui::ColorConvertFloat4ToU32(gp.Style.Colors[recolor_from]);\n        else if (just_created)\n            item->Color = NextColormapColorU32();\n    }\n    else if (just_created) {\n        item->Color = NextColormapColorU32();\n    }\n    // hide/show item\n    if (gp.NextItemData.HasHidden) {\n        if (just_created || gp.NextItemData.HiddenCond == ImGuiCond_Always)\n            item->Show = !gp.NextItemData.Hidden;\n    }\n    if (!item->Show) {\n        // reset next item data\n        gp.NextItemData.Reset();\n        gp.PreviousItem = item;\n        gp.CurrentItem  = nullptr;\n        return false;\n    }\n    else {\n        ImVec4 item_color = ImGui::ColorConvertU32ToFloat4(item->Color);\n        // stage next item colors\n        s.Colors[ImPlotCol_Line]           = IsColorAuto(s.Colors[ImPlotCol_Line])          ? ( IsColorAuto(ImPlotCol_Line)           ? item_color                 : gp.Style.Colors[ImPlotCol_Line]          ) : s.Colors[ImPlotCol_Line];\n        s.Colors[ImPlotCol_Fill]           = IsColorAuto(s.Colors[ImPlotCol_Fill])          ? ( IsColorAuto(ImPlotCol_Fill)           ? item_color                 : gp.Style.Colors[ImPlotCol_Fill]          ) : s.Colors[ImPlotCol_Fill];\n        s.Colors[ImPlotCol_MarkerOutline]  = IsColorAuto(s.Colors[ImPlotCol_MarkerOutline]) ? ( IsColorAuto(ImPlotCol_MarkerOutline)  ? s.Colors[ImPlotCol_Line]   : gp.Style.Colors[ImPlotCol_MarkerOutline] ) : s.Colors[ImPlotCol_MarkerOutline];\n        s.Colors[ImPlotCol_MarkerFill]     = IsColorAuto(s.Colors[ImPlotCol_MarkerFill])    ? ( IsColorAuto(ImPlotCol_MarkerFill)     ? s.Colors[ImPlotCol_Line]   : gp.Style.Colors[ImPlotCol_MarkerFill]    ) : s.Colors[ImPlotCol_MarkerFill];\n        s.Colors[ImPlotCol_ErrorBar]       = IsColorAuto(s.Colors[ImPlotCol_ErrorBar])      ? ( GetStyleColorVec4(ImPlotCol_ErrorBar)                                                                         ) : s.Colors[ImPlotCol_ErrorBar];\n        // stage next item style vars\n        s.LineWeight         = s.LineWeight       < 0 ? gp.Style.LineWeight       : s.LineWeight;\n        s.Marker             = s.Marker           < 0 ? gp.Style.Marker           : s.Marker;\n        s.MarkerSize         = s.MarkerSize       < 0 ? gp.Style.MarkerSize       : s.MarkerSize;\n        s.MarkerWeight       = s.MarkerWeight     < 0 ? gp.Style.MarkerWeight     : s.MarkerWeight;\n        s.FillAlpha          = s.FillAlpha        < 0 ? gp.Style.FillAlpha        : s.FillAlpha;\n        s.ErrorBarSize       = s.ErrorBarSize     < 0 ? gp.Style.ErrorBarSize     : s.ErrorBarSize;\n        s.ErrorBarWeight     = s.ErrorBarWeight   < 0 ? gp.Style.ErrorBarWeight   : s.ErrorBarWeight;\n        s.DigitalBitHeight   = s.DigitalBitHeight < 0 ? gp.Style.DigitalBitHeight : s.DigitalBitHeight;\n        s.DigitalBitGap      = s.DigitalBitGap    < 0 ? gp.Style.DigitalBitGap    : s.DigitalBitGap;\n        // apply alpha modifier(s)\n        s.Colors[ImPlotCol_Fill].w       *= s.FillAlpha;\n        s.Colors[ImPlotCol_MarkerFill].w *= s.FillAlpha; // TODO: this should be separate, if it at all\n        // apply highlight mods\n        if (item->LegendHovered) {\n            if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoHighlightItem)) {\n                s.LineWeight   *= ITEM_HIGHLIGHT_LINE_SCALE;\n                s.MarkerSize   *= ITEM_HIGHLIGHT_MARK_SCALE;\n                s.MarkerWeight *= ITEM_HIGHLIGHT_LINE_SCALE;\n                // TODO: how to highlight fills?\n            }\n            if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoHighlightAxis)) {\n                if (gp.CurrentPlot->EnabledAxesX() > 1)\n                    gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentX].ColorHiLi = item->Color;\n                if (gp.CurrentPlot->EnabledAxesY() > 1)\n                    gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentY].ColorHiLi = item->Color;\n            }\n        }\n        // set render flags\n        s.RenderLine       = s.Colors[ImPlotCol_Line].w          > 0 && s.LineWeight > 0;\n        s.RenderFill       = s.Colors[ImPlotCol_Fill].w          > 0;\n        s.RenderMarkerFill = s.Colors[ImPlotCol_MarkerFill].w    > 0;\n        s.RenderMarkerLine = s.Colors[ImPlotCol_MarkerOutline].w > 0 && s.MarkerWeight > 0;\n        // push rendering clip rect\n        PushPlotClipRect();\n        return true;\n    }\n}\n\n// Ends an item (call only if BeginItem returns true)\nvoid EndItem() {\n    ImPlotContext& gp = *GImPlot;\n    // pop rendering clip rect\n    PopPlotClipRect();\n    // reset next item data\n    gp.NextItemData.Reset();\n    // set current item\n    gp.PreviousItem = gp.CurrentItem;\n    gp.CurrentItem  = nullptr;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Indexers\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\nIMPLOT_INLINE T IndexData(const T* data, int idx, int count, int offset, int stride) {\n    const int s = ((offset == 0) << 0) | ((stride == sizeof(T)) << 1);\n    switch (s) {\n        case 3 : return data[idx];\n        case 2 : return data[(offset + idx) % count];\n        case 1 : return *(const T*)(const void*)((const unsigned char*)data + (size_t)((idx) ) * stride);\n        case 0 : return *(const T*)(const void*)((const unsigned char*)data + (size_t)((offset + idx) % count) * stride);\n        default: return T(0);\n    }\n}\n\ntemplate <typename T>\nstruct IndexerIdx {\n    IndexerIdx(const T* data, int count, int offset = 0, int stride = sizeof(T)) :\n        Data(data),\n        Count(count),\n        Offset(count ? ImPosMod(offset, count) : 0),\n        Stride(stride)\n    { }\n    template <typename I> IMPLOT_INLINE double operator()(I idx) const {\n        return (double)IndexData(Data, idx, Count, Offset, Stride);\n    }\n    const T* Data;\n    int Count;\n    int Offset;\n    int Stride;\n};\n\ntemplate <typename _Indexer1, typename _Indexer2>\nstruct IndexerAdd {\n    IndexerAdd(const _Indexer1& indexer1, const _Indexer2& indexer2, double scale1 = 1, double scale2 = 1)\n        : Indexer1(indexer1),\n          Indexer2(indexer2),\n          Scale1(scale1),\n          Scale2(scale2),\n          Count(ImMin(Indexer1.Count, Indexer2.Count))\n    { }\n    template <typename I> IMPLOT_INLINE double operator()(I idx) const {\n        return Scale1 * Indexer1(idx) + Scale2 * Indexer2(idx);\n    }\n    const _Indexer1& Indexer1;\n    const _Indexer2& Indexer2;\n    double Scale1;\n    double Scale2;\n    int Count;\n};\n\nstruct IndexerLin {\n    IndexerLin(double m, double b) : M(m), B(b) { }\n    template <typename I> IMPLOT_INLINE double operator()(I idx) const {\n        return M * idx + B;\n    }\n    const double M;\n    const double B;\n};\n\nstruct IndexerConst {\n    IndexerConst(double ref) : Ref(ref) { }\n    template <typename I> IMPLOT_INLINE double operator()(I) const { return Ref; }\n    const double Ref;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Getters\n//-----------------------------------------------------------------------------\n\ntemplate <typename _IndexerX, typename _IndexerY>\nstruct GetterXY {\n    GetterXY(_IndexerX x, _IndexerY y, int count) : IndxerX(x), IndxerY(y), Count(count) { }\n    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {\n        return ImPlotPoint(IndxerX(idx),IndxerY(idx));\n    }\n    const _IndexerX IndxerX;\n    const _IndexerY IndxerY;\n    const int Count;\n};\n\n/// Interprets a user's function pointer as ImPlotPoints\nstruct GetterFuncPtr {\n    GetterFuncPtr(ImPlotGetter getter, void* data, int count) :\n        Getter(getter),\n        Data(data),\n        Count(count)\n    { }\n    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {\n        return Getter(idx, Data);\n    }\n    ImPlotGetter Getter;\n    void* const Data;\n    const int Count;\n};\n\ntemplate <typename _Getter>\nstruct GetterOverrideX {\n    GetterOverrideX(_Getter getter, double x) : Getter(getter), X(x), Count(getter.Count) { }\n    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {\n        ImPlotPoint p = Getter(idx);\n        p.x = X;\n        return p;\n    }\n    const _Getter Getter;\n    const double X;\n    const int Count;\n};\n\ntemplate <typename _Getter>\nstruct GetterOverrideY {\n    GetterOverrideY(_Getter getter, double y) : Getter(getter), Y(y), Count(getter.Count) { }\n    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {\n        ImPlotPoint p = Getter(idx);\n        p.y = Y;\n        return p;\n    }\n    const _Getter Getter;\n    const double Y;\n    const int Count;\n};\n\ntemplate <typename _Getter>\nstruct GetterLoop {\n    GetterLoop(_Getter getter) : Getter(getter), Count(getter.Count + 1) { }\n    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {\n        idx = idx % (Count - 1);\n        return Getter(idx);\n    }\n    const _Getter Getter;\n    const int Count;\n};\n\ntemplate <typename T>\nstruct GetterError {\n    GetterError(const T* xs, const T* ys, const T* neg, const T* pos, int count, int offset, int stride) :\n        Xs(xs),\n        Ys(ys),\n        Neg(neg),\n        Pos(pos),\n        Count(count),\n        Offset(count ? ImPosMod(offset, count) : 0),\n        Stride(stride)\n    { }\n    template <typename I> IMPLOT_INLINE ImPlotPointError operator()(I idx) const {\n        return ImPlotPointError((double)IndexData(Xs,  idx, Count, Offset, Stride),\n                                (double)IndexData(Ys,  idx, Count, Offset, Stride),\n                                (double)IndexData(Neg, idx, Count, Offset, Stride),\n                                (double)IndexData(Pos, idx, Count, Offset, Stride));\n    }\n    const T* const Xs;\n    const T* const Ys;\n    const T* const Neg;\n    const T* const Pos;\n    const int Count;\n    const int Offset;\n    const int Stride;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Fitters\n//-----------------------------------------------------------------------------\n\ntemplate <typename _Getter1>\nstruct Fitter1 {\n    Fitter1(const _Getter1& getter) : Getter(getter) { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {\n        for (int i = 0; i < Getter.Count; ++i) {\n            ImPlotPoint p = Getter(i);\n            x_axis.ExtendFitWith(y_axis, p.x, p.y);\n            y_axis.ExtendFitWith(x_axis, p.y, p.x);\n        }\n    }\n    const _Getter1& Getter;\n};\n\ntemplate <typename _Getter1>\nstruct FitterX {\n    FitterX(const _Getter1& getter) : Getter(getter) { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis&) const {\n        for (int i = 0; i < Getter.Count; ++i) {\n            ImPlotPoint p = Getter(i);\n            x_axis.ExtendFit(p.x);\n        }\n    }\n    const _Getter1& Getter;\n};\n\ntemplate <typename _Getter1>\nstruct FitterY {\n    FitterY(const _Getter1& getter) : Getter(getter) { }\n    void Fit(ImPlotAxis&, ImPlotAxis& y_axis) const {\n        for (int i = 0; i < Getter.Count; ++i) {\n            ImPlotPoint p = Getter(i);\n            y_axis.ExtendFit(p.y);\n        }\n    }\n    const _Getter1& Getter;\n};\n\ntemplate <typename _Getter1, typename _Getter2>\nstruct Fitter2 {\n    Fitter2(const _Getter1& getter1, const _Getter2& getter2) : Getter1(getter1), Getter2(getter2) { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {\n        for (int i = 0; i < Getter1.Count; ++i) {\n            ImPlotPoint p = Getter1(i);\n            x_axis.ExtendFitWith(y_axis, p.x, p.y);\n            y_axis.ExtendFitWith(x_axis, p.y, p.x);\n        }\n        for (int i = 0; i < Getter2.Count; ++i) {\n            ImPlotPoint p = Getter2(i);\n            x_axis.ExtendFitWith(y_axis, p.x, p.y);\n            y_axis.ExtendFitWith(x_axis, p.y, p.x);\n        }\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n};\n\ntemplate <typename _Getter1, typename _Getter2>\nstruct FitterBarV {\n    FitterBarV(const _Getter1& getter1, const _Getter2& getter2, double width) :\n        Getter1(getter1),\n        Getter2(getter2),\n        HalfWidth(width*0.5)\n    { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {\n        int count = ImMin(Getter1.Count, Getter2.Count);\n        for (int i = 0; i < count; ++i) {\n            ImPlotPoint p1 = Getter1(i); p1.x -= HalfWidth;\n            ImPlotPoint p2 = Getter2(i); p2.x += HalfWidth;\n            x_axis.ExtendFitWith(y_axis, p1.x, p1.y);\n            y_axis.ExtendFitWith(x_axis, p1.y, p1.x);\n            x_axis.ExtendFitWith(y_axis, p2.x, p2.y);\n            y_axis.ExtendFitWith(x_axis, p2.y, p2.x);\n        }\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const double    HalfWidth;\n};\n\ntemplate <typename _Getter1, typename _Getter2>\nstruct FitterBarH {\n    FitterBarH(const _Getter1& getter1, const _Getter2& getter2, double height) :\n        Getter1(getter1),\n        Getter2(getter2),\n        HalfHeight(height*0.5)\n    { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {\n        int count = ImMin(Getter1.Count, Getter2.Count);\n        for (int i = 0; i < count; ++i) {\n            ImPlotPoint p1 = Getter1(i); p1.y -= HalfHeight;\n            ImPlotPoint p2 = Getter2(i); p2.y += HalfHeight;\n            x_axis.ExtendFitWith(y_axis, p1.x, p1.y);\n            y_axis.ExtendFitWith(x_axis, p1.y, p1.x);\n            x_axis.ExtendFitWith(y_axis, p2.x, p2.y);\n            y_axis.ExtendFitWith(x_axis, p2.y, p2.x);\n        }\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const double    HalfHeight;\n};\n\nstruct FitterRect {\n    FitterRect(const ImPlotPoint& pmin, const ImPlotPoint& pmax) :\n        Pmin(pmin),\n        Pmax(pmax)\n    { }\n    FitterRect(const ImPlotRect& rect) :\n        FitterRect(rect.Min(), rect.Max())\n    { }\n    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {\n        x_axis.ExtendFitWith(y_axis, Pmin.x, Pmin.y);\n        y_axis.ExtendFitWith(x_axis, Pmin.y, Pmin.x);\n        x_axis.ExtendFitWith(y_axis, Pmax.x, Pmax.y);\n        y_axis.ExtendFitWith(x_axis, Pmax.y, Pmax.x);\n    }\n    const ImPlotPoint Pmin;\n    const ImPlotPoint Pmax;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Transformers\n//-----------------------------------------------------------------------------\n\nstruct Transformer1 {\n    Transformer1(double pixMin, double pltMin, double pltMax, double m, double scaMin, double scaMax, ImPlotTransform fwd, void* data) :\n        ScaMin(scaMin),\n        ScaMax(scaMax),\n        PltMin(pltMin),\n        PltMax(pltMax),\n        PixMin(pixMin),\n        M(m),\n        TransformFwd(fwd),\n        TransformData(data)\n    { }\n\n    template <typename T> IMPLOT_INLINE float operator()(T p) const {\n        if (TransformFwd != nullptr) {\n            double s = TransformFwd(p, TransformData);\n            double t = (s - ScaMin) / (ScaMax - ScaMin);\n            p = PltMin + (PltMax - PltMin) * t;\n        }\n        return (float)(PixMin + M * (p - PltMin));\n    }\n\n    double ScaMin, ScaMax, PltMin, PltMax, PixMin, M;\n    ImPlotTransform TransformFwd;\n    void*           TransformData;\n};\n\nstruct Transformer2 {\n    Transformer2(const ImPlotAxis& x_axis, const ImPlotAxis& y_axis) :\n        Tx(x_axis.PixelMin,\n           x_axis.Range.Min,\n           x_axis.Range.Max,\n           x_axis.ScaleToPixel,\n           x_axis.ScaleMin,\n           x_axis.ScaleMax,\n           x_axis.TransformForward,\n           x_axis.TransformData),\n        Ty(y_axis.PixelMin,\n           y_axis.Range.Min,\n           y_axis.Range.Max,\n           y_axis.ScaleToPixel,\n           y_axis.ScaleMin,\n           y_axis.ScaleMax,\n           y_axis.TransformForward,\n           y_axis.TransformData)\n    { }\n\n    Transformer2(const ImPlotPlot& plot) :\n        Transformer2(plot.Axes[plot.CurrentX], plot.Axes[plot.CurrentY])\n    { }\n\n    Transformer2() :\n        Transformer2(*GImPlot->CurrentPlot)\n    { }\n\n    template <typename P> IMPLOT_INLINE ImVec2 operator()(const P& plt) const {\n        ImVec2 out;\n        out.x = Tx(plt.x);\n        out.y = Ty(plt.y);\n        return out;\n    }\n\n    template <typename T> IMPLOT_INLINE ImVec2 operator()(T x, T y) const {\n        ImVec2 out;\n        out.x = Tx(x);\n        out.y = Ty(y);\n        return out;\n    }\n\n    Transformer1 Tx;\n    Transformer1 Ty;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Renderers\n//-----------------------------------------------------------------------------\n\nstruct RendererBase {\n    RendererBase(int prims, int idx_consumed, int vtx_consumed) :\n        Prims(prims),\n        IdxConsumed(idx_consumed),\n        VtxConsumed(vtx_consumed)\n    { }\n    const int Prims;\n    Transformer2 Transformer;\n    const int IdxConsumed;\n    const int VtxConsumed;\n};\n\ntemplate <class _Getter>\nstruct RendererLineStrip : RendererBase {\n    RendererLineStrip(const _Getter& getter, ImU32 col, float weight) :\n        RendererBase(getter.Count - 1, 6, 4),\n        Getter(getter),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight)*0.5f)\n    {\n        P1 = this->Transformer(Getter(0));\n    }\n    void Init(ImDrawList& draw_list) const {\n        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {\n            P1 = P2;\n            return false;\n        }\n        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);\n        P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV0;\n    mutable ImVec2 UV1;\n};\n\ntemplate <class _Getter>\nstruct RendererLineStripSkip : RendererBase {\n    RendererLineStripSkip(const _Getter& getter, ImU32 col, float weight) :\n        RendererBase(getter.Count - 1, 6, 4),\n        Getter(getter),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight)*0.5f)\n    {\n        P1 = this->Transformer(Getter(0));\n    }\n    void Init(ImDrawList& draw_list) const {\n        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {\n            if (!ImNan(P2.x) && !ImNan(P2.y))\n                P1 = P2;\n            return false;\n        }\n        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);\n        if (!ImNan(P2.x) && !ImNan(P2.y))\n            P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV0;\n    mutable ImVec2 UV1;\n};\n\ntemplate <class _Getter>\nstruct RendererLineSegments1 : RendererBase {\n    RendererLineSegments1(const _Getter& getter, ImU32 col, float weight) :\n        RendererBase(getter.Count / 2, 6, 4),\n        Getter(getter),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight)*0.5f)\n    { }\n    void Init(ImDrawList& draw_list) const {\n        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P1 = this->Transformer(Getter(prim*2+0));\n        ImVec2 P2 = this->Transformer(Getter(prim*2+1));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))\n            return false;\n        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 UV0;\n    mutable ImVec2 UV1;\n};\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererLineSegments2 : RendererBase {\n    RendererLineSegments2(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, float weight) :\n        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight)*0.5f)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P1 = this->Transformer(Getter1(prim));\n        ImVec2 P2 = this->Transformer(Getter2(prim));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))\n            return false;\n        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 UV0;\n    mutable ImVec2 UV1;\n};\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererBarsFillV : RendererBase {\n    RendererBarsFillV(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double width) :\n        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col),\n        HalfWidth(width/2)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImPlotPoint p1 = Getter1(prim);\n        ImPlotPoint p2 = Getter2(prim);\n        p1.x += HalfWidth;\n        p2.x -= HalfWidth;\n        ImVec2 P1 = this->Transformer(p1);\n        ImVec2 P2 = this->Transformer(p2);\n        float width_px = ImAbs(P1.x-P2.x);\n        if (width_px < 1.0f) {\n            P1.x += P1.x > P2.x ? (1-width_px) / 2 : (width_px-1) / 2;\n            P2.x += P2.x > P1.x ? (1-width_px) / 2 : (width_px-1) / 2;\n        }\n        ImVec2 PMin = ImMin(P1, P2);\n        ImVec2 PMax = ImMax(P1, P2);\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))\n            return false;\n        PrimRectFill(draw_list,PMin,PMax,Col,UV);\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    const double HalfWidth;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererBarsFillH : RendererBase {\n    RendererBarsFillH(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double height) :\n        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col),\n        HalfHeight(height/2)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImPlotPoint p1 = Getter1(prim);\n        ImPlotPoint p2 = Getter2(prim);\n        p1.y += HalfHeight;\n        p2.y -= HalfHeight;\n        ImVec2 P1 = this->Transformer(p1);\n        ImVec2 P2 = this->Transformer(p2);\n        float height_px = ImAbs(P1.y-P2.y);\n        if (height_px < 1.0f) {\n            P1.y += P1.y > P2.y ? (1-height_px) / 2 : (height_px-1) / 2;\n            P2.y += P2.y > P1.y ? (1-height_px) / 2 : (height_px-1) / 2;\n        }\n        ImVec2 PMin = ImMin(P1, P2);\n        ImVec2 PMax = ImMax(P1, P2);\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))\n            return false;\n        PrimRectFill(draw_list,PMin,PMax,Col,UV);\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    const double HalfHeight;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererBarsLineV : RendererBase {\n    RendererBarsLineV(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double width, float weight) :\n        RendererBase(ImMin(getter1.Count, getter1.Count), 24, 8),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col),\n        HalfWidth(width/2),\n        Weight(weight)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImPlotPoint p1 = Getter1(prim);\n        ImPlotPoint p2 = Getter2(prim);\n        p1.x += HalfWidth;\n        p2.x -= HalfWidth;\n        ImVec2 P1 = this->Transformer(p1);\n        ImVec2 P2 = this->Transformer(p2);\n        float width_px = ImAbs(P1.x-P2.x);\n        if (width_px < 1.0f) {\n            P1.x += P1.x > P2.x ? (1-width_px) / 2 : (width_px-1) / 2;\n            P2.x += P2.x > P1.x ? (1-width_px) / 2 : (width_px-1) / 2;\n        }\n        ImVec2 PMin = ImMin(P1, P2);\n        ImVec2 PMax = ImMax(P1, P2);\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))\n            return false;\n        PrimRectLine(draw_list,PMin,PMax,Weight,Col,UV);\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    const double HalfWidth;\n    const float Weight;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererBarsLineH : RendererBase {\n    RendererBarsLineH(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double height, float weight) :\n        RendererBase(ImMin(getter1.Count, getter1.Count), 24, 8),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col),\n        HalfHeight(height/2),\n        Weight(weight)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImPlotPoint p1 = Getter1(prim);\n        ImPlotPoint p2 = Getter2(prim);\n        p1.y += HalfHeight;\n        p2.y -= HalfHeight;\n        ImVec2 P1 = this->Transformer(p1);\n        ImVec2 P2 = this->Transformer(p2);\n        float height_px = ImAbs(P1.y-P2.y);\n        if (height_px < 1.0f) {\n            P1.y += P1.y > P2.y ? (1-height_px) / 2 : (height_px-1) / 2;\n            P2.y += P2.y > P1.y ? (1-height_px) / 2 : (height_px-1) / 2;\n        }\n        ImVec2 PMin = ImMin(P1, P2);\n        ImVec2 PMax = ImMax(P1, P2);\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))\n            return false;\n        PrimRectLine(draw_list,PMin,PMax,Weight,Col,UV);\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    const double HalfHeight;\n    const float Weight;\n    mutable ImVec2 UV;\n};\n\n\ntemplate <class _Getter>\nstruct RendererStairsPre : RendererBase {\n    RendererStairsPre(const _Getter& getter, ImU32 col, float weight) :\n        RendererBase(getter.Count - 1, 12, 8),\n        Getter(getter),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight)*0.5f)\n    {\n        P1 = this->Transformer(Getter(0));\n    }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {\n            P1 = P2;\n            return false;\n        }\n        PrimRectFill(draw_list, ImVec2(P1.x - HalfWeight, P1.y), ImVec2(P1.x + HalfWeight, P2.y), Col, UV);\n        PrimRectFill(draw_list, ImVec2(P1.x, P2.y + HalfWeight), ImVec2(P2.x, P2.y - HalfWeight), Col, UV);\n        P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter>\nstruct RendererStairsPost : RendererBase {\n    RendererStairsPost(const _Getter& getter, ImU32 col, float weight) :\n        RendererBase(getter.Count - 1, 12, 8),\n        Getter(getter),\n        Col(col),\n        HalfWeight(ImMax(1.0f,weight) * 0.5f)\n    {\n        P1 = this->Transformer(Getter(0));\n    }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {\n            P1 = P2;\n            return false;\n        }\n        PrimRectFill(draw_list, ImVec2(P1.x, P1.y + HalfWeight), ImVec2(P2.x, P1.y - HalfWeight), Col, UV);\n        PrimRectFill(draw_list, ImVec2(P2.x - HalfWeight, P2.y), ImVec2(P2.x + HalfWeight, P1.y), Col, UV);\n        P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    mutable float HalfWeight;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter>\nstruct RendererStairsPreShaded : RendererBase {\n    RendererStairsPreShaded(const _Getter& getter, ImU32 col) :\n        RendererBase(getter.Count - 1, 6, 4),\n        Getter(getter),\n        Col(col)\n    {\n        P1 = this->Transformer(Getter(0));\n        Y0 = this->Transformer(ImPlotPoint(0,0)).y;\n    }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        ImVec2 PMin(ImMin(P1.x, P2.x), ImMin(Y0, P2.y));\n        ImVec2 PMax(ImMax(P1.x, P2.x), ImMax(Y0, P2.y));\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax))) {\n            P1 = P2;\n            return false;\n        }\n        PrimRectFill(draw_list, PMin, PMax, Col, UV);\n        P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    float Y0;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV;\n};\n\ntemplate <class _Getter>\nstruct RendererStairsPostShaded : RendererBase {\n    RendererStairsPostShaded(const _Getter& getter, ImU32 col) :\n        RendererBase(getter.Count - 1, 6, 4),\n        Getter(getter),\n        Col(col)\n    {\n        P1 = this->Transformer(Getter(0));\n        Y0 = this->Transformer(ImPlotPoint(0,0)).y;\n    }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P2 = this->Transformer(Getter(prim + 1));\n        ImVec2 PMin(ImMin(P1.x, P2.x), ImMin(P1.y, Y0));\n        ImVec2 PMax(ImMax(P1.x, P2.x), ImMax(P1.y, Y0));\n        if (!cull_rect.Overlaps(ImRect(PMin, PMax))) {\n            P1 = P2;\n            return false;\n        }\n        PrimRectFill(draw_list, PMin, PMax, Col, UV);\n        P1 = P2;\n        return true;\n    }\n    const _Getter& Getter;\n    const ImU32 Col;\n    float Y0;\n    mutable ImVec2 P1;\n    mutable ImVec2 UV;\n};\n\n\n\ntemplate <class _Getter1, class _Getter2>\nstruct RendererShaded : RendererBase {\n    RendererShaded(const _Getter1& getter1, const _Getter2& getter2, ImU32 col) :\n        RendererBase(ImMin(getter1.Count, getter2.Count) - 1, 6, 5),\n        Getter1(getter1),\n        Getter2(getter2),\n        Col(col)\n    {\n        P11 = this->Transformer(Getter1(0));\n        P12 = this->Transformer(Getter2(0));\n    }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 P21 = this->Transformer(Getter1(prim+1));\n        ImVec2 P22 = this->Transformer(Getter2(prim+1));\n        ImRect rect(ImMin(ImMin(ImMin(P11,P12),P21),P22), ImMax(ImMax(ImMax(P11,P12),P21),P22));\n        if (!cull_rect.Overlaps(rect)) {\n            P11 = P21;\n            P12 = P22;\n            return false;\n        }\n        const int intersect = (P11.y > P12.y && P22.y > P21.y) || (P12.y > P11.y && P21.y > P22.y);\n        const ImVec2 intersection = intersect == 0 ? ImVec2(0,0) : Intersection(P11,P21,P12,P22);\n        draw_list._VtxWritePtr[0].pos = P11;\n        draw_list._VtxWritePtr[0].uv  = UV;\n        draw_list._VtxWritePtr[0].col = Col;\n        draw_list._VtxWritePtr[1].pos = P21;\n        draw_list._VtxWritePtr[1].uv  = UV;\n        draw_list._VtxWritePtr[1].col = Col;\n        draw_list._VtxWritePtr[2].pos = intersection;\n        draw_list._VtxWritePtr[2].uv  = UV;\n        draw_list._VtxWritePtr[2].col = Col;\n        draw_list._VtxWritePtr[3].pos = P12;\n        draw_list._VtxWritePtr[3].uv  = UV;\n        draw_list._VtxWritePtr[3].col = Col;\n        draw_list._VtxWritePtr[4].pos = P22;\n        draw_list._VtxWritePtr[4].uv  = UV;\n        draw_list._VtxWritePtr[4].col = Col;\n        draw_list._VtxWritePtr += 5;\n        draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n        draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1 + intersect);\n        draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);\n        draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);\n        draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);\n        draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3 - intersect);\n        draw_list._IdxWritePtr += 6;\n        draw_list._VtxCurrentIdx += 5;\n        P11 = P21;\n        P12 = P22;\n        return true;\n    }\n    const _Getter1& Getter1;\n    const _Getter2& Getter2;\n    const ImU32 Col;\n    mutable ImVec2 P11;\n    mutable ImVec2 P12;\n    mutable ImVec2 UV;\n};\n\nstruct RectC {\n    ImPlotPoint Pos;\n    ImPlotPoint HalfSize;\n    ImU32 Color;\n};\n\ntemplate <typename _Getter>\nstruct RendererRectC : RendererBase {\n    RendererRectC(const _Getter& getter) :\n        RendererBase(getter.Count, 6, 4),\n        Getter(getter)\n    {}\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        RectC rect = Getter(prim);\n        ImVec2 P1 = this->Transformer(rect.Pos.x - rect.HalfSize.x , rect.Pos.y - rect.HalfSize.y);\n        ImVec2 P2 = this->Transformer(rect.Pos.x + rect.HalfSize.x , rect.Pos.y + rect.HalfSize.y);\n        if ((rect.Color & IM_COL32_A_MASK) == 0 || !cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))\n            return false;\n        PrimRectFill(draw_list,P1,P2,rect.Color,UV);\n        return true;\n    }\n    const _Getter& Getter;\n    mutable ImVec2 UV;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] RenderPrimitives\n//-----------------------------------------------------------------------------\n\n/// Renders primitive shapes in bulk as efficiently as possible.\ntemplate <class _Renderer>\nvoid RenderPrimitivesEx(const _Renderer& renderer, ImDrawList& draw_list, const ImRect& cull_rect) {\n    unsigned int prims        = renderer.Prims;\n    unsigned int prims_culled = 0;\n    unsigned int idx          = 0;\n    renderer.Init(draw_list);\n    while (prims) {\n        // find how many can be reserved up to end of current draw command's limit\n        unsigned int cnt = ImMin(prims, (MaxIdx<ImDrawIdx>::Value - draw_list._VtxCurrentIdx) / renderer.VtxConsumed);\n        // make sure at least this many elements can be rendered to avoid situations where at the end of buffer this slow path is not taken all the time\n        if (cnt >= ImMin(64u, prims)) {\n            if (prims_culled >= cnt)\n                prims_culled -= cnt; // reuse previous reservation\n            else {\n                // add more elements to previous reservation\n                draw_list.PrimReserve((cnt - prims_culled) * renderer.IdxConsumed, (cnt - prims_culled) * renderer.VtxConsumed);\n                prims_culled = 0;\n            }\n        }\n        else\n        {\n            if (prims_culled > 0) {\n                draw_list.PrimUnreserve(prims_culled * renderer.IdxConsumed, prims_culled * renderer.VtxConsumed);\n                prims_culled = 0;\n            }\n            cnt = ImMin(prims, (MaxIdx<ImDrawIdx>::Value - 0/*draw_list._VtxCurrentIdx*/) / renderer.VtxConsumed);\n            // reserve new draw command\n            draw_list.PrimReserve(cnt * renderer.IdxConsumed, cnt * renderer.VtxConsumed);\n        }\n        prims -= cnt;\n        for (unsigned int ie = idx + cnt; idx != ie; ++idx) {\n            if (!renderer.Render(draw_list, cull_rect, idx))\n                prims_culled++;\n        }\n    }\n    if (prims_culled > 0)\n        draw_list.PrimUnreserve(prims_culled * renderer.IdxConsumed, prims_culled * renderer.VtxConsumed);\n}\n\ntemplate <template <class> class _Renderer, class _Getter, typename ...Args>\nvoid RenderPrimitives1(const _Getter& getter, Args... args) {\n    ImDrawList& draw_list = *GetPlotDrawList();\n    const ImRect& cull_rect = GetCurrentPlot()->PlotRect;\n    RenderPrimitivesEx(_Renderer<_Getter>(getter,args...), draw_list, cull_rect);\n}\n\ntemplate <template <class,class> class _Renderer, class _Getter1, class _Getter2, typename ...Args>\nvoid RenderPrimitives2(const _Getter1& getter1, const _Getter2& getter2, Args... args) {\n    ImDrawList& draw_list = *GetPlotDrawList();\n    const ImRect& cull_rect = GetCurrentPlot()->PlotRect;\n    RenderPrimitivesEx(_Renderer<_Getter1,_Getter2>(getter1,getter2,args...), draw_list, cull_rect);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Markers\n//-----------------------------------------------------------------------------\n\ntemplate <class _Getter>\nstruct RendererMarkersFill : RendererBase {\n    RendererMarkersFill(const _Getter& getter, const ImVec2* marker, int count, float size, ImU32 col) :\n        RendererBase(getter.Count, (count-2)*3, count),\n        Getter(getter),\n        Marker(marker),\n        Count(count),\n        Size(size),\n        Col(col)\n    { }\n    void Init(ImDrawList& draw_list) const {\n        UV = draw_list._Data->TexUvWhitePixel;\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 p = this->Transformer(Getter(prim));\n        if (p.x >= cull_rect.Min.x && p.y >= cull_rect.Min.y && p.x <= cull_rect.Max.x && p.y <= cull_rect.Max.y) {\n            for (int i = 0; i < Count; i++) {\n                draw_list._VtxWritePtr[0].pos.x = p.x + Marker[i].x * Size;\n                draw_list._VtxWritePtr[0].pos.y = p.y + Marker[i].y * Size;\n                draw_list._VtxWritePtr[0].uv = UV;\n                draw_list._VtxWritePtr[0].col = Col;\n                draw_list._VtxWritePtr++;\n            }\n            for (int i = 2; i < Count; i++) {\n                draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);\n                draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + i - 1);\n                draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + i);\n                draw_list._IdxWritePtr += 3;\n            }\n            draw_list._VtxCurrentIdx += (ImDrawIdx)Count;\n            return true;\n        }\n        return false;\n    }\n    const _Getter& Getter;\n    const ImVec2* Marker;\n    const int Count;\n    const float Size;\n    const ImU32 Col;\n    mutable ImVec2 UV;\n};\n\n\ntemplate <class _Getter>\nstruct RendererMarkersLine : RendererBase {\n    RendererMarkersLine(const _Getter& getter, const ImVec2* marker, int count, float size, float weight, ImU32 col) :\n        RendererBase(getter.Count, count/2*6, count/2*4),\n        Getter(getter),\n        Marker(marker),\n        Count(count),\n        HalfWeight(ImMax(1.0f,weight)*0.5f),\n        Size(size),\n        Col(col)\n    { }\n    void Init(ImDrawList& draw_list) const {\n        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);\n    }\n    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {\n        ImVec2 p = this->Transformer(Getter(prim));\n        if (p.x >= cull_rect.Min.x && p.y >= cull_rect.Min.y && p.x <= cull_rect.Max.x && p.y <= cull_rect.Max.y) {\n            for (int i = 0; i < Count; i = i + 2) {\n                ImVec2 p1(p.x + Marker[i].x * Size, p.y + Marker[i].y * Size);\n                ImVec2 p2(p.x + Marker[i+1].x * Size, p.y + Marker[i+1].y * Size);\n                PrimLine(draw_list, p1, p2, HalfWeight, Col, UV0, UV1);\n            }\n            return true;\n        }\n        return false;\n    }\n    const _Getter& Getter;\n    const ImVec2* Marker;\n    const int Count;\n    mutable float HalfWeight;\n    const float Size;\n    const ImU32 Col;\n    mutable ImVec2 UV0;\n    mutable ImVec2 UV1;\n};\n\nstatic const ImVec2 MARKER_FILL_CIRCLE[10]  = {ImVec2(1.0f, 0.0f), ImVec2(0.809017f, 0.58778524f),ImVec2(0.30901697f, 0.95105654f),ImVec2(-0.30901703f, 0.9510565f),ImVec2(-0.80901706f, 0.5877852f),ImVec2(-1.0f, 0.0f),ImVec2(-0.80901694f, -0.58778536f),ImVec2(-0.3090171f, -0.9510565f),ImVec2(0.30901712f, -0.9510565f),ImVec2(0.80901694f, -0.5877853f)};\nstatic const ImVec2 MARKER_FILL_SQUARE[4]   = {ImVec2(SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2)};\nstatic const ImVec2 MARKER_FILL_DIAMOND[4]  = {ImVec2(1, 0), ImVec2(0, -1), ImVec2(-1, 0), ImVec2(0, 1)};\nstatic const ImVec2 MARKER_FILL_UP[3]       = {ImVec2(SQRT_3_2,0.5f),ImVec2(0,-1),ImVec2(-SQRT_3_2,0.5f)};\nstatic const ImVec2 MARKER_FILL_DOWN[3]     = {ImVec2(SQRT_3_2,-0.5f),ImVec2(0,1),ImVec2(-SQRT_3_2,-0.5f)};\nstatic const ImVec2 MARKER_FILL_LEFT[3]     = {ImVec2(-1,0), ImVec2(0.5, SQRT_3_2), ImVec2(0.5, -SQRT_3_2)};\nstatic const ImVec2 MARKER_FILL_RIGHT[3]    = {ImVec2(1,0), ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, -SQRT_3_2)};\n\nstatic const ImVec2 MARKER_LINE_CIRCLE[20]  = {\n    ImVec2(1.0f, 0.0f),\n    ImVec2(0.809017f, 0.58778524f),\n    ImVec2(0.809017f, 0.58778524f),\n    ImVec2(0.30901697f, 0.95105654f),\n    ImVec2(0.30901697f, 0.95105654f),\n    ImVec2(-0.30901703f, 0.9510565f),\n    ImVec2(-0.30901703f, 0.9510565f),\n    ImVec2(-0.80901706f, 0.5877852f),\n    ImVec2(-0.80901706f, 0.5877852f),\n    ImVec2(-1.0f, 0.0f),\n    ImVec2(-1.0f, 0.0f),\n    ImVec2(-0.80901694f, -0.58778536f),\n    ImVec2(-0.80901694f, -0.58778536f),\n    ImVec2(-0.3090171f, -0.9510565f),\n    ImVec2(-0.3090171f, -0.9510565f),\n    ImVec2(0.30901712f, -0.9510565f),\n    ImVec2(0.30901712f, -0.9510565f),\n    ImVec2(0.80901694f, -0.5877853f),\n    ImVec2(0.80901694f, -0.5877853f),\n    ImVec2(1.0f, 0.0f)\n};\nstatic const ImVec2 MARKER_LINE_SQUARE[8]   = {ImVec2(SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,SQRT_1_2)};\nstatic const ImVec2 MARKER_LINE_DIAMOND[8]  = {ImVec2(1, 0), ImVec2(0, -1), ImVec2(0, -1), ImVec2(-1, 0), ImVec2(-1, 0), ImVec2(0, 1), ImVec2(0, 1), ImVec2(1, 0)};\nstatic const ImVec2 MARKER_LINE_UP[6]       = {ImVec2(SQRT_3_2,0.5f), ImVec2(0,-1),ImVec2(0,-1),ImVec2(-SQRT_3_2,0.5f),ImVec2(-SQRT_3_2,0.5f),ImVec2(SQRT_3_2,0.5f)};\nstatic const ImVec2 MARKER_LINE_DOWN[6]     = {ImVec2(SQRT_3_2,-0.5f),ImVec2(0,1),ImVec2(0,1),ImVec2(-SQRT_3_2,-0.5f), ImVec2(-SQRT_3_2,-0.5f), ImVec2(SQRT_3_2,-0.5f)};\nstatic const ImVec2 MARKER_LINE_LEFT[6]     = {ImVec2(-1,0), ImVec2(0.5, SQRT_3_2),  ImVec2(0.5, SQRT_3_2),  ImVec2(0.5, -SQRT_3_2) , ImVec2(0.5, -SQRT_3_2) , ImVec2(-1,0) };\nstatic const ImVec2 MARKER_LINE_RIGHT[6]    = {ImVec2(1,0),  ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, -SQRT_3_2), ImVec2(-0.5, -SQRT_3_2), ImVec2(1,0) };\nstatic const ImVec2 MARKER_LINE_ASTERISK[6] = {ImVec2(-SQRT_3_2, -0.5f), ImVec2(SQRT_3_2, 0.5f),  ImVec2(-SQRT_3_2, 0.5f), ImVec2(SQRT_3_2, -0.5f), ImVec2(0, -1), ImVec2(0, 1)};\nstatic const ImVec2 MARKER_LINE_PLUS[4]     = {ImVec2(-1, 0), ImVec2(1, 0), ImVec2(0, -1), ImVec2(0, 1)};\nstatic const ImVec2 MARKER_LINE_CROSS[4]    = {ImVec2(-SQRT_1_2,-SQRT_1_2),ImVec2(SQRT_1_2,SQRT_1_2),ImVec2(SQRT_1_2,-SQRT_1_2),ImVec2(-SQRT_1_2,SQRT_1_2)};\n\ntemplate <typename _Getter>\nvoid RenderMarkers(const _Getter& getter, ImPlotMarker marker, float size, bool rend_fill, ImU32 col_fill, bool rend_line, ImU32 col_line, float weight) {\n    if (rend_fill) {\n        switch (marker) {\n            case ImPlotMarker_Circle  : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_CIRCLE,10,size,col_fill); break;\n            case ImPlotMarker_Square  : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_SQUARE, 4,size,col_fill); break;\n            case ImPlotMarker_Diamond : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_DIAMOND,4,size,col_fill); break;\n            case ImPlotMarker_Up      : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_UP,     3,size,col_fill); break;\n            case ImPlotMarker_Down    : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_DOWN,   3,size,col_fill); break;\n            case ImPlotMarker_Left    : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_LEFT,   3,size,col_fill); break;\n            case ImPlotMarker_Right   : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_RIGHT,  3,size,col_fill); break;\n        }\n    }\n    if (rend_line) {\n        switch (marker) {\n            case ImPlotMarker_Circle    : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_CIRCLE, 20,size,weight,col_line); break;\n            case ImPlotMarker_Square    : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_SQUARE,  8,size,weight,col_line); break;\n            case ImPlotMarker_Diamond   : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_DIAMOND, 8,size,weight,col_line); break;\n            case ImPlotMarker_Up        : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_UP,      6,size,weight,col_line); break;\n            case ImPlotMarker_Down      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_DOWN,    6,size,weight,col_line); break;\n            case ImPlotMarker_Left      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_LEFT,    6,size,weight,col_line); break;\n            case ImPlotMarker_Right     : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_RIGHT,   6,size,weight,col_line); break;\n            case ImPlotMarker_Asterisk  : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_ASTERISK,6,size,weight,col_line); break;\n            case ImPlotMarker_Plus      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_PLUS,    4,size,weight,col_line); break;\n            case ImPlotMarker_Cross     : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_CROSS,   4,size,weight,col_line); break;\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotLine\n//-----------------------------------------------------------------------------\n\ntemplate <typename _Getter>\nvoid PlotLineEx(const char* label_id, const _Getter& getter, ImPlotLineFlags flags) {\n    if (BeginItemEx(label_id, Fitter1<_Getter>(getter), flags, ImPlotCol_Line)) {\n        if (getter.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        if (getter.Count > 1) {\n            if (ImHasFlag(flags, ImPlotLineFlags_Shaded) && s.RenderFill) {\n                const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);\n                GetterOverrideY<_Getter> getter2(getter, 0);\n                RenderPrimitives2<RendererShaded>(getter,getter2,col_fill);\n            }\n            if (s.RenderLine) {\n                const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n                if (ImHasFlag(flags,ImPlotLineFlags_Segments)) {\n                    RenderPrimitives1<RendererLineSegments1>(getter,col_line,s.LineWeight);\n                }\n                else if (ImHasFlag(flags, ImPlotLineFlags_Loop)) {\n                    if (ImHasFlag(flags, ImPlotLineFlags_SkipNaN))\n                        RenderPrimitives1<RendererLineStripSkip>(GetterLoop<_Getter>(getter),col_line,s.LineWeight);\n                    else\n                        RenderPrimitives1<RendererLineStrip>(GetterLoop<_Getter>(getter),col_line,s.LineWeight);\n                }\n                else {\n                    if (ImHasFlag(flags, ImPlotLineFlags_SkipNaN))\n                        RenderPrimitives1<RendererLineStripSkip>(getter,col_line,s.LineWeight);\n                    else\n                        RenderPrimitives1<RendererLineStrip>(getter,col_line,s.LineWeight);\n                }\n            }\n        }\n        // render markers\n        if (s.Marker != ImPlotMarker_None) {\n            if (ImHasFlag(flags, ImPlotLineFlags_NoClip)) {\n                PopPlotClipRect();\n                PushPlotClipRect(s.MarkerSize);\n            }\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);\n            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);\n            RenderMarkers<_Getter>(getter, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotLine(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotLineFlags flags, int offset, int stride) {\n    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);\n    PlotLineEx(label_id, getter, flags);\n}\n\ntemplate <typename T>\nvoid PlotLine(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags, int offset, int stride) {\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n    PlotLineEx(label_id, getter, flags);\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotLine<T> (const char* label_id, const T* values, int count, double xscale, double x0, ImPlotLineFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotLine<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n// custom\nvoid PlotLineG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotLineFlags flags) {\n    GetterFuncPtr getter(getter_func,data, count);\n    PlotLineEx(label_id, getter, flags);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotScatter\n//-----------------------------------------------------------------------------\n\ntemplate <typename Getter>\nvoid PlotScatterEx(const char* label_id, const Getter& getter, ImPlotScatterFlags flags) {\n    if (BeginItemEx(label_id, Fitter1<Getter>(getter), flags, ImPlotCol_MarkerOutline)) {\n        if (getter.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        ImPlotMarker marker = s.Marker == ImPlotMarker_None ? ImPlotMarker_Circle: s.Marker;\n        if (marker != ImPlotMarker_None) {\n            if (ImHasFlag(flags,ImPlotScatterFlags_NoClip)) {\n                PopPlotClipRect();\n                PushPlotClipRect(s.MarkerSize);\n            }\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);\n            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);\n            RenderMarkers<Getter>(getter, marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotScatter(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotScatterFlags flags, int offset, int stride) {\n    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);\n    PlotScatterEx(label_id, getter, flags);\n}\n\ntemplate <typename T>\nvoid PlotScatter(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags, int offset, int stride) {\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n    return PlotScatterEx(label_id, getter, flags);\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotScatter<T>(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotScatterFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotScatter<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n// custom\nvoid PlotScatterG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotScatterFlags flags) {\n    GetterFuncPtr getter(getter_func,data, count);\n    return PlotScatterEx(label_id, getter, flags);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotStairs\n//-----------------------------------------------------------------------------\n\ntemplate <typename Getter>\nvoid PlotStairsEx(const char* label_id, const Getter& getter, ImPlotStairsFlags flags) {\n    if (BeginItemEx(label_id, Fitter1<Getter>(getter), flags, ImPlotCol_Line)) {\n        if (getter.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        if (getter.Count > 1) {\n            if (s.RenderFill && ImHasFlag(flags,ImPlotStairsFlags_Shaded)) {\n                const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);\n                if (ImHasFlag(flags, ImPlotStairsFlags_PreStep))\n                    RenderPrimitives1<RendererStairsPreShaded>(getter,col_fill);\n                else\n                    RenderPrimitives1<RendererStairsPostShaded>(getter,col_fill);\n            }\n            if (s.RenderLine) {\n                const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n                if (ImHasFlag(flags, ImPlotStairsFlags_PreStep))\n                    RenderPrimitives1<RendererStairsPre>(getter,col_line,s.LineWeight);\n                else\n                    RenderPrimitives1<RendererStairsPost>(getter,col_line,s.LineWeight);\n            }\n        }\n        // render markers\n        if (s.Marker != ImPlotMarker_None) {\n            PopPlotClipRect();\n            PushPlotClipRect(s.MarkerSize);\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);\n            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);\n            RenderMarkers<Getter>(getter, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotStairs(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotStairsFlags flags, int offset, int stride) {\n    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);\n    PlotStairsEx(label_id, getter, flags);\n}\n\ntemplate <typename T>\nvoid PlotStairs(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags, int offset, int stride) {\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n    return PlotStairsEx(label_id, getter, flags);\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotStairs<T> (const char* label_id, const T* values, int count, double xscale, double x0, ImPlotStairsFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotStairs<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n// custom\nvoid PlotStairsG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotStairsFlags flags) {\n    GetterFuncPtr getter(getter_func,data, count);\n    return PlotStairsEx(label_id, getter, flags);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotShaded\n//-----------------------------------------------------------------------------\n\ntemplate <typename Getter1, typename Getter2>\nvoid PlotShadedEx(const char* label_id, const Getter1& getter1, const Getter2& getter2, ImPlotShadedFlags flags) {\n    if (BeginItemEx(label_id, Fitter2<Getter1,Getter2>(getter1,getter2), flags, ImPlotCol_Fill)) {\n        if (getter1.Count <= 0 || getter2.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        if (s.RenderFill) {\n            const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);\n            RenderPrimitives2<RendererShaded>(getter1,getter2,col);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotShaded(const char* label_id, const T* values, int count, double y_ref, double xscale, double x0, ImPlotShadedFlags flags, int offset, int stride) {\n    if (!(y_ref > -DBL_MAX))\n        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Min;\n    if (!(y_ref < DBL_MAX))\n        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Max;\n    GetterXY<IndexerLin,IndexerIdx<T>> getter1(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);\n    GetterXY<IndexerLin,IndexerConst>  getter2(IndexerLin(xscale,x0),IndexerConst(y_ref),count);\n    PlotShadedEx(label_id, getter1, getter2, flags);\n}\n\ntemplate <typename T>\nvoid PlotShaded(const char* label_id, const T* xs, const T* ys, int count, double y_ref, ImPlotShadedFlags flags, int offset, int stride) {\n    if (y_ref == -HUGE_VAL)\n        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Min;\n    if (y_ref == HUGE_VAL)\n        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Max;\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n    GetterXY<IndexerIdx<T>,IndexerConst>  getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(y_ref),count);\n    PlotShadedEx(label_id, getter1, getter2, flags);\n}\n\n\ntemplate <typename T>\nvoid PlotShaded(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags, int offset, int stride) {\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys1,count,offset,stride),count);\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys2,count,offset,stride),count);\n    PlotShadedEx(label_id, getter1, getter2, flags);\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* values, int count, double y_ref, double xscale, double x0, ImPlotShadedFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* xs, const T* ys, int count, double y_ref, ImPlotShadedFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n// custom\nvoid PlotShadedG(const char* label_id, ImPlotGetter getter_func1, void* data1, ImPlotGetter getter_func2, void* data2, int count, ImPlotShadedFlags flags) {\n    GetterFuncPtr getter1(getter_func1, data1, count);\n    GetterFuncPtr getter2(getter_func2, data2, count);\n    PlotShadedEx(label_id, getter1, getter2, flags);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotBars\n//-----------------------------------------------------------------------------\n\ntemplate <typename Getter1, typename Getter2>\nvoid PlotBarsVEx(const char* label_id, const Getter1& getter1, const Getter2 getter2, double width, ImPlotBarsFlags flags) {\n    if (BeginItemEx(label_id, FitterBarV<Getter1,Getter2>(getter1,getter2,width), flags, ImPlotCol_Fill)) {\n        if (getter1.Count <= 0 || getter2.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);\n        const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n        bool rend_fill = s.RenderFill;\n        bool rend_line = s.RenderLine;\n        if (rend_fill) {\n            RenderPrimitives2<RendererBarsFillV>(getter1,getter2,col_fill,width);\n            if (rend_line && col_fill == col_line)\n                rend_line = false;\n        }\n        if (rend_line) {\n            RenderPrimitives2<RendererBarsLineV>(getter1,getter2,col_line,width,s.LineWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename Getter1, typename Getter2>\nvoid PlotBarsHEx(const char* label_id, const Getter1& getter1, const Getter2& getter2, double height, ImPlotBarsFlags flags) {\n    if (BeginItemEx(label_id, FitterBarH<Getter1,Getter2>(getter1,getter2,height), flags, ImPlotCol_Fill)) {\n        if (getter1.Count <= 0 || getter2.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);\n        const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n        bool rend_fill = s.RenderFill;\n        bool rend_line = s.RenderLine;\n        if (rend_fill) {\n            RenderPrimitives2<RendererBarsFillH>(getter1,getter2,col_fill,height);\n            if (rend_line && col_fill == col_line)\n                rend_line = false;\n        }\n        if (rend_line) {\n            RenderPrimitives2<RendererBarsLineH>(getter1,getter2,col_line,height,s.LineWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotBars(const char* label_id, const T* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride) {\n    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {\n        GetterXY<IndexerIdx<T>,IndexerLin> getter1(IndexerIdx<T>(values,count,offset,stride),IndexerLin(1.0,shift),count);\n        GetterXY<IndexerConst,IndexerLin>  getter2(IndexerConst(0),IndexerLin(1.0,shift),count);\n        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);\n    }\n    else {\n        GetterXY<IndexerLin,IndexerIdx<T>> getter1(IndexerLin(1.0,shift),IndexerIdx<T>(values,count,offset,stride),count);\n        GetterXY<IndexerLin,IndexerConst>  getter2(IndexerLin(1.0,shift),IndexerConst(0),count);\n        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);\n    }\n}\n\ntemplate <typename T>\nvoid PlotBars(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride) {\n    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {\n        GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n        GetterXY<IndexerConst, IndexerIdx<T>> getter2(IndexerConst(0),IndexerIdx<T>(ys,count,offset,stride),count);\n        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);\n    }\n    else {\n        GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n        GetterXY<IndexerIdx<T>,IndexerConst>  getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(0),count);\n        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);\n    }\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotBars<T>(const char* label_id, const T* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotBars<T>(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\nvoid PlotBarsG(const char* label_id, ImPlotGetter getter_func, void* data, int count, double bar_size, ImPlotBarsFlags flags) {\n    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {\n        GetterFuncPtr getter1(getter_func, data, count);\n        GetterOverrideX<GetterFuncPtr> getter2(getter1,0);\n        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);\n    }\n    else {\n        GetterFuncPtr getter1(getter_func, data, count);\n        GetterOverrideY<GetterFuncPtr> getter2(getter1,0);\n        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotBarGroups\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\nvoid PlotBarGroups(const char* const label_ids[], const T* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags) {\n    const bool horz = ImHasFlag(flags, ImPlotBarGroupsFlags_Horizontal);\n    const bool stack = ImHasFlag(flags, ImPlotBarGroupsFlags_Stacked);\n    if (stack) {\n        SetupLock();\n        ImPlotContext& gp = *GImPlot;\n        gp.TempDouble1.resize(4*group_count);\n        double* temp = gp.TempDouble1.Data;\n        double* neg =      &temp[0];\n        double* pos =      &temp[group_count];\n        double* curr_min = &temp[group_count*2];\n        double* curr_max = &temp[group_count*3];\n        for (int g = 0; g < group_count*2; ++g)\n            temp[g] = 0;\n        if (horz) {\n            for (int i = 0; i < item_count; ++i) {\n                if (!IsItemHidden(label_ids[i])) {\n                    for (int g = 0; g < group_count; ++g) {\n                        double v = (double)values[i*group_count+g];\n                        if (v > 0) {\n                            curr_min[g] = pos[g];\n                            curr_max[g] = curr_min[g] + v;\n                            pos[g]      += v;\n                        }\n                        else {\n                            curr_max[g] = neg[g];\n                            curr_min[g] = curr_max[g] + v;\n                            neg[g]      += v;\n                        }\n                    }\n                }\n                GetterXY<IndexerIdx<double>,IndexerLin> getter1(IndexerIdx<double>(curr_min,group_count),IndexerLin(1.0,shift),group_count);\n                GetterXY<IndexerIdx<double>,IndexerLin> getter2(IndexerIdx<double>(curr_max,group_count),IndexerLin(1.0,shift),group_count);\n                PlotBarsHEx(label_ids[i],getter1,getter2,group_size,0);\n            }\n        }\n        else {\n            for (int i = 0; i < item_count; ++i) {\n                if (!IsItemHidden(label_ids[i])) {\n                    for (int g = 0; g < group_count; ++g) {\n                        double v = (double)values[i*group_count+g];\n                        if (v > 0) {\n                            curr_min[g] = pos[g];\n                            curr_max[g] = curr_min[g] + v;\n                            pos[g]      += v;\n                        }\n                        else {\n                            curr_max[g] = neg[g];\n                            curr_min[g] = curr_max[g] + v;\n                            neg[g]      += v;\n                        }\n                    }\n                }\n                GetterXY<IndexerLin,IndexerIdx<double>> getter1(IndexerLin(1.0,shift),IndexerIdx<double>(curr_min,group_count),group_count);\n                GetterXY<IndexerLin,IndexerIdx<double>> getter2(IndexerLin(1.0,shift),IndexerIdx<double>(curr_max,group_count),group_count);\n                PlotBarsVEx(label_ids[i],getter1,getter2,group_size,0);\n            }\n        }\n    }\n    else {\n        const double subsize = group_size / item_count;\n        if (horz) {\n            for (int i = 0; i < item_count; ++i) {\n                const double subshift = (i+0.5)*subsize - group_size/2;\n                PlotBars(label_ids[i],&values[i*group_count],group_count,subsize,subshift+shift,ImPlotBarsFlags_Horizontal);\n            }\n        }\n        else {\n            for (int i = 0; i < item_count; ++i) {\n                const double subshift = (i+0.5)*subsize - group_size/2;\n                PlotBars(label_ids[i],&values[i*group_count],group_count,subsize,subshift+shift);\n            }\n        }\n    }\n}\n\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotBarGroups<T>(const char* const label_ids[], const T* values, int items, int groups, double width, double shift, ImPlotBarGroupsFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotErrorBars\n//-----------------------------------------------------------------------------\n\ntemplate <typename _GetterPos, typename _GetterNeg>\nvoid PlotErrorBarsVEx(const char* label_id, const _GetterPos& getter_pos, const _GetterNeg& getter_neg, ImPlotErrorBarsFlags flags) {\n    if (BeginItemEx(label_id, Fitter2<_GetterPos,_GetterNeg>(getter_pos, getter_neg), flags, IMPLOT_AUTO)) {\n        if (getter_pos.Count <= 0 || getter_neg.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        ImDrawList& draw_list = *GetPlotDrawList();\n        const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_ErrorBar]);\n        const bool rend_whisker  = s.ErrorBarSize > 0;\n        const float half_whisker = s.ErrorBarSize * 0.5f;\n        for (int i = 0; i < getter_pos.Count; ++i) {\n            ImVec2 p1 = PlotToPixels(getter_neg(i),IMPLOT_AUTO,IMPLOT_AUTO);\n            ImVec2 p2 = PlotToPixels(getter_pos(i),IMPLOT_AUTO,IMPLOT_AUTO);\n            draw_list.AddLine(p1,p2,col, s.ErrorBarWeight);\n            if (rend_whisker) {\n                draw_list.AddLine(p1 - ImVec2(half_whisker, 0), p1 + ImVec2(half_whisker, 0), col, s.ErrorBarWeight);\n                draw_list.AddLine(p2 - ImVec2(half_whisker, 0), p2 + ImVec2(half_whisker, 0), col, s.ErrorBarWeight);\n            }\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename _GetterPos, typename _GetterNeg>\nvoid PlotErrorBarsHEx(const char* label_id, const _GetterPos& getter_pos, const _GetterNeg& getter_neg, ImPlotErrorBarsFlags flags) {\n    if (BeginItemEx(label_id, Fitter2<_GetterPos,_GetterNeg>(getter_pos, getter_neg), flags, IMPLOT_AUTO)) {\n        if (getter_pos.Count <= 0 || getter_neg.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        ImDrawList& draw_list = *GetPlotDrawList();\n        const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_ErrorBar]);\n        const bool rend_whisker  = s.ErrorBarSize > 0;\n        const float half_whisker = s.ErrorBarSize * 0.5f;\n        for (int i = 0; i < getter_pos.Count; ++i) {\n            ImVec2 p1 = PlotToPixels(getter_neg(i),IMPLOT_AUTO,IMPLOT_AUTO);\n            ImVec2 p2 = PlotToPixels(getter_pos(i),IMPLOT_AUTO,IMPLOT_AUTO);\n            draw_list.AddLine(p1, p2, col, s.ErrorBarWeight);\n            if (rend_whisker) {\n                draw_list.AddLine(p1 - ImVec2(0, half_whisker), p1 + ImVec2(0, half_whisker), col, s.ErrorBarWeight);\n                draw_list.AddLine(p2 - ImVec2(0, half_whisker), p2 + ImVec2(0, half_whisker), col, s.ErrorBarWeight);\n            }\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride) {\n    PlotErrorBars(label_id, xs, ys, err, err, count, flags, offset, stride);\n}\n\ntemplate <typename T>\nvoid PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride) {\n    IndexerIdx<T> indexer_x(xs, count,offset,stride);\n    IndexerIdx<T> indexer_y(ys, count,offset,stride);\n    IndexerIdx<T> indexer_n(neg,count,offset,stride);\n    IndexerIdx<T> indexer_p(pos,count,offset,stride);\n    GetterError<T> getter(xs, ys, neg, pos, count, offset, stride);\n    if (ImHasFlag(flags, ImPlotErrorBarsFlags_Horizontal)) {\n        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_xp(indexer_x, indexer_p, 1,  1);\n        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_xn(indexer_x, indexer_n, 1, -1);\n        GetterXY<IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>,IndexerIdx<T>> getter_p(indexer_xp, indexer_y, count);\n        GetterXY<IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>,IndexerIdx<T>> getter_n(indexer_xn, indexer_y, count);\n        PlotErrorBarsHEx(label_id, getter_p, getter_n, flags);\n    }\n    else {\n        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_yp(indexer_y, indexer_p, 1,  1);\n        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_yn(indexer_y, indexer_n, 1, -1);\n        GetterXY<IndexerIdx<T>,IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>> getter_p(indexer_x, indexer_yp, count);\n        GetterXY<IndexerIdx<T>,IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>> getter_n(indexer_x, indexer_yn, count);\n        PlotErrorBarsVEx(label_id, getter_p, getter_n, flags);\n    }\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotErrorBars<T>(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotErrorBars<T>(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotStems\n//-----------------------------------------------------------------------------\n\ntemplate <typename _GetterM, typename _GetterB>\nvoid PlotStemsEx(const char* label_id, const _GetterM& getter_mark, const _GetterB& getter_base, ImPlotStemsFlags flags) {\n    if (BeginItemEx(label_id, Fitter2<_GetterM,_GetterB>(getter_mark,getter_base), flags, ImPlotCol_Line)) {\n        if (getter_mark.Count <= 0 || getter_base.Count <= 0) {\n            EndItem();\n            return;\n        }\n        const ImPlotNextItemData& s = GetItemData();\n        // render stems\n        if (s.RenderLine) {\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n            RenderPrimitives2<RendererLineSegments2>(getter_mark, getter_base, col_line, s.LineWeight);\n        }\n        // render markers\n        if (s.Marker != ImPlotMarker_None) {\n            PopPlotClipRect();\n            PushPlotClipRect(s.MarkerSize);\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);\n            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);\n            RenderMarkers<_GetterM>(getter_mark, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);\n        }\n        EndItem();\n    }\n}\n\ntemplate <typename T>\nvoid PlotStems(const char* label_id, const T* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride) {\n    if (ImHasFlag(flags, ImPlotStemsFlags_Horizontal)) {\n        GetterXY<IndexerIdx<T>,IndexerLin> get_mark(IndexerIdx<T>(values,count,offset,stride),IndexerLin(scale,start),count);\n        GetterXY<IndexerConst,IndexerLin>  get_base(IndexerConst(ref),IndexerLin(scale,start),count);\n        PlotStemsEx(label_id, get_mark, get_base, flags);\n    }\n    else {\n        GetterXY<IndexerLin,IndexerIdx<T>> get_mark(IndexerLin(scale,start),IndexerIdx<T>(values,count,offset,stride),count);\n        GetterXY<IndexerLin,IndexerConst>  get_base(IndexerLin(scale,start),IndexerConst(ref),count);\n        PlotStemsEx(label_id, get_mark, get_base, flags);\n    }\n}\n\ntemplate <typename T>\nvoid PlotStems(const char* label_id, const T* xs, const T* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride) {\n    if (ImHasFlag(flags, ImPlotStemsFlags_Horizontal)) {\n        GetterXY<IndexerIdx<T>,IndexerIdx<T>> get_mark(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n        GetterXY<IndexerConst,IndexerIdx<T>>  get_base(IndexerConst(ref),IndexerIdx<T>(ys,count,offset,stride),count);\n        PlotStemsEx(label_id, get_mark, get_base, flags);\n    }\n    else {\n        GetterXY<IndexerIdx<T>,IndexerIdx<T>> get_mark(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n        GetterXY<IndexerIdx<T>,IndexerConst>  get_base(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(ref),count);\n        PlotStemsEx(label_id, get_mark, get_base, flags);\n    }\n}\n\n#define INSTANTIATE_MACRO(T) \\\n    template IMPLOT_API void PlotStems<T>(const char* label_id, const T* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride); \\\n    template IMPLOT_API void PlotStems<T>(const char* label_id, const T* xs, const T* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotInfLines\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\nvoid PlotInfLines(const char* label_id, const T* values, int count, ImPlotInfLinesFlags flags, int offset, int stride) {\n    const ImPlotRect lims = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO);\n    if (ImHasFlag(flags, ImPlotInfLinesFlags_Horizontal)) {\n        GetterXY<IndexerConst,IndexerIdx<T>> getter_min(IndexerConst(lims.X.Min),IndexerIdx<T>(values,count,offset,stride),count);\n        GetterXY<IndexerConst,IndexerIdx<T>> getter_max(IndexerConst(lims.X.Max),IndexerIdx<T>(values,count,offset,stride),count);\n        if (BeginItemEx(label_id, FitterY<GetterXY<IndexerConst,IndexerIdx<T>>>(getter_min), flags, ImPlotCol_Line)) {\n            if (count <= 0) {\n                EndItem();\n                return;\n            }\n            const ImPlotNextItemData& s = GetItemData();\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n            if (s.RenderLine)\n                RenderPrimitives2<RendererLineSegments2>(getter_min, getter_max, col_line, s.LineWeight);\n            EndItem();\n        }\n    }\n    else {\n        GetterXY<IndexerIdx<T>,IndexerConst> get_min(IndexerIdx<T>(values,count,offset,stride),IndexerConst(lims.Y.Min),count);\n        GetterXY<IndexerIdx<T>,IndexerConst> get_max(IndexerIdx<T>(values,count,offset,stride),IndexerConst(lims.Y.Max),count);\n        if (BeginItemEx(label_id, FitterX<GetterXY<IndexerIdx<T>,IndexerConst>>(get_min), flags, ImPlotCol_Line)) {\n            if (count <= 0) {\n                EndItem();\n                return;\n            }\n            const ImPlotNextItemData& s = GetItemData();\n            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);\n            if (s.RenderLine)\n                RenderPrimitives2<RendererLineSegments2>(get_min, get_max, col_line, s.LineWeight);\n            EndItem();\n        }\n    }\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotInfLines<T>(const char* label_id, const T* xs, int count, ImPlotInfLinesFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotPieChart\n//-----------------------------------------------------------------------------\n\nIMPLOT_INLINE void RenderPieSlice(ImDrawList& draw_list, const ImPlotPoint& center, double radius, double a0, double a1, ImU32 col, bool detached = false) {\n    const float resolution = 50 / (2 * IM_PI);\n    ImVec2 buffer[52];\n    \n    int n = ImMax(3, (int)((a1 - a0) * resolution));\n    double da = (a1 - a0) / (n - 1);\n    int i = 0;\n\n    if (detached) {\n        const double offset = 0.08; // Offset of the detached slice\n        const double width_scale = 0.95; // Scale factor for the width of the detached slice\n        \n        double a_mid = (a0 + a1) / 2;\n        double new_a0 = a_mid - (a1 - a0) * width_scale / 2;\n        double new_a1 = a_mid + (a1 - a0) * width_scale / 2;\n        double new_da = (new_a1 - new_a0) / (n - 1);\n        \n        ImPlotPoint offsetCenter(center.x + offset * cos(a_mid), center.y + offset * sin(a_mid));\n        \n        // Start point (center of the offset)\n        buffer[0] = PlotToPixels(offsetCenter, IMPLOT_AUTO, IMPLOT_AUTO);\n\n        for (; i < n; ++i) {\n            double a = new_a0 + i * new_da;\n            buffer[i + 1] = PlotToPixels(\n                offsetCenter.x + (radius + offset/2) * cos(a),\n                offsetCenter.y + (radius + offset/2) * sin(a),\n                IMPLOT_AUTO, IMPLOT_AUTO\n            );\n        }\n\n    } else {\n        buffer[0] = PlotToPixels(center, IMPLOT_AUTO, IMPLOT_AUTO);\n        for (; i < n; ++i) {\n            double a = a0 + i * da;\n            buffer[i + 1] = PlotToPixels(\n                center.x + radius * cos(a), \n                center.y + radius * sin(a), \n                IMPLOT_AUTO, IMPLOT_AUTO);\n        }\n    }\n    // Close the shape\n    buffer[i + 1] = buffer[0];\n    \n    // fill\n    draw_list.AddConvexPolyFilled(buffer, n + 2, col);\n    \n    // border (for AA)\n    draw_list.AddPolyline(buffer, n + 2, col, 0, 2.0f);\n}\n\ntemplate <typename T>\ndouble PieChartSum(const T* values, int count, bool ignore_hidden) {\n    double sum = 0;\n    if (ignore_hidden) {\n        ImPlotContext& gp = *GImPlot;\n        ImPlotItemGroup& Items = *gp.CurrentItems;\n        for (int i = 0; i < count; ++i) {\n            if (i >= Items.GetItemCount())\n                break;\n\n            ImPlotItem* item = Items.GetItemByIndex(i);\n            IM_ASSERT(item != nullptr);\n            if (item->Show) {\n                sum += (double)values[i];\n            }\n        }\n    }\n    else {\n        for (int i = 0; i < count; ++i) {\n            sum += (double)values[i];\n        }\n    }\n    return sum;\n}\n\ntemplate <typename T>\nvoid PlotPieChartEx(const char* const label_ids[], const T* values, int count, ImPlotPoint center, double radius, double angle0, ImPlotPieChartFlags flags) {\n    ImDrawList& draw_list  = *GetPlotDrawList();\n\n    const bool ignore_hidden = ImHasFlag(flags, ImPlotPieChartFlags_IgnoreHidden);\n    const double sum         = PieChartSum(values, count, ignore_hidden);\n    const bool normalize     = ImHasFlag(flags, ImPlotPieChartFlags_Normalize) || sum > 1.0;\n\n    double a0 = angle0 * 2 * IM_PI / 360.0;\n    double a1 = angle0 * 2 * IM_PI / 360.0;\n    ImPlotPoint Pmin = ImPlotPoint(center.x - radius, center.y - radius);\n    ImPlotPoint Pmax = ImPlotPoint(center.x + radius, center.y + radius);\n    for (int i = 0; i < count; ++i) {\n        ImPlotItem* item = GetItem(label_ids[i]);\n        const double percent = normalize ? (double)values[i] / sum : (double)values[i];\n        const bool skip      = sum <= 0.0 || (ignore_hidden && item != nullptr && !item->Show);\n        if (!skip)\n            a1 = a0 + 2 * IM_PI * percent;\n\n        if (BeginItemEx(label_ids[i], FitterRect(Pmin, Pmax))) {\n            const bool hovered = ImPlot::IsLegendEntryHovered(label_ids[i]) && ImHasFlag(flags, ImPlotPieChartFlags_Exploding);\n            if (sum > 0.0) {\n                ImU32 col = GetCurrentItem()->Color;\n                if (percent < 0.5) {\n                    RenderPieSlice(draw_list, center, radius, a0, a1, col, hovered);\n                }\n                else {\n                    RenderPieSlice(draw_list, center, radius, a0, a0 + (a1 - a0) * 0.5, col, hovered);\n                    RenderPieSlice(draw_list, center, radius, a0 + (a1 - a0) * 0.5, a1, col, hovered);\n                }\n            }\n            EndItem();\n        }\n        if (!skip)\n            a0 = a1;\n    }\n}\n\nint PieChartFormatter(double value, char* buff, int size, void* data) {\n    const char* fmt = (const char*)data;\n    return snprintf(buff, size, fmt, value);\n};\n\ntemplate <typename T>\nvoid PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, const char* fmt, double angle0, ImPlotPieChartFlags flags) {\n    PlotPieChart<T>(label_ids, values, count, x, y, radius, PieChartFormatter, (void*)fmt, angle0, flags);\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotPieChart<T>(const char* const label_ids[], const T* values, int count, double x, double y, double radius, const char* fmt, double angle0, ImPlotPieChartFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\ntemplate <typename T>\nvoid PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data, double angle0, ImPlotPieChartFlags flags) {\n    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, \"PlotPieChart() needs to be called between BeginPlot() and EndPlot()!\");\n    ImDrawList& draw_list = *GetPlotDrawList();\n\n    const bool ignore_hidden = ImHasFlag(flags, ImPlotPieChartFlags_IgnoreHidden);\n    const double sum = PieChartSum(values, count, ignore_hidden);\n    const bool normalize = ImHasFlag(flags, ImPlotPieChartFlags_Normalize) || sum > 1.0;\n    ImPlotPoint center(x, y);\n\n    PushPlotClipRect();\n    PlotPieChartEx(label_ids, values, count, center, radius, angle0, flags);\n    if (fmt != nullptr) {\n        double a0 = angle0 * 2 * IM_PI / 360.0;\n        double a1 = angle0 * 2 * IM_PI / 360.0;\n        char buffer[32];\n        for (int i = 0; i < count; ++i) {\n            ImPlotItem* item = GetItem(label_ids[i]);\n            IM_ASSERT(item != nullptr);\n\n            const double percent = normalize ? (double)values[i] / sum : (double)values[i];\n            const bool skip = ignore_hidden && item != nullptr && !item->Show;\n\n            if (!skip) {\n                a1 = a0 + 2 * IM_PI * percent;\n                if (item->Show) {\n                    fmt((double)values[i], buffer, 32, fmt_data);\n                    ImVec2 size = ImGui::CalcTextSize(buffer);\n                    double angle = a0 + (a1 - a0) * 0.5;\n                    const bool hovered = ImPlot::IsLegendEntryHovered(label_ids[i]) && ImHasFlag(flags, ImPlotPieChartFlags_Exploding);\n                    const double offset = (hovered ? 0.6 : 0.5) * radius; \n                    ImVec2 pos = PlotToPixels(center.x + offset * cos(angle), center.y + offset * sin(angle), IMPLOT_AUTO, IMPLOT_AUTO);\n                    ImU32 col = CalcTextColor(ImGui::ColorConvertU32ToFloat4(item->Color));\n                    draw_list.AddText(pos - size * 0.5f, col, buffer);\n                }\n                a0 = a1;\n            }\n        }\n    }\n    PopPlotClipRect();\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data, double angle0, ImPlotPieChartFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotHeatmap\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\nstruct GetterHeatmapRowMaj {\n    GetterHeatmapRowMaj(const T* values, int rows, int cols, double scale_min, double scale_max, double width, double height, double xref, double yref, double ydir) :\n        Values(values),\n        Count(rows*cols),\n        Rows(rows),\n        Cols(cols),\n        ScaleMin(scale_min),\n        ScaleMax(scale_max),\n        Width(width),\n        Height(height),\n        XRef(xref),\n        YRef(yref),\n        YDir(ydir),\n        HalfSize(Width*0.5, Height*0.5)\n    { }\n    template <typename I> IMPLOT_INLINE RectC operator()(I idx) const {\n        double val = (double)Values[idx];\n        const int r = idx / Cols;\n        const int c = idx % Cols;\n        const ImPlotPoint p(XRef + HalfSize.x + c*Width, YRef + YDir * (HalfSize.y + r*Height));\n        RectC rect;\n        rect.Pos = p;\n        rect.HalfSize = HalfSize;\n        const float t = ImClamp((float)ImRemap01(val, ScaleMin, ScaleMax),0.0f,1.0f);\n        ImPlotContext& gp = *GImPlot;\n        rect.Color = gp.ColormapData.LerpTable(gp.Style.Colormap, t);\n        return rect;\n    }\n    const T* const Values;\n    const int Count, Rows, Cols;\n    const double ScaleMin, ScaleMax, Width, Height, XRef, YRef, YDir;\n    const ImPlotPoint HalfSize;\n};\n\ntemplate <typename T>\nstruct GetterHeatmapColMaj {\n    GetterHeatmapColMaj(const T* values, int rows, int cols, double scale_min, double scale_max, double width, double height, double xref, double yref, double ydir) :\n        Values(values),\n        Count(rows*cols),\n        Rows(rows),\n        Cols(cols),\n        ScaleMin(scale_min),\n        ScaleMax(scale_max),\n        Width(width),\n        Height(height),\n        XRef(xref),\n        YRef(yref),\n        YDir(ydir),\n        HalfSize(Width*0.5, Height*0.5)\n    { }\n    template <typename I> IMPLOT_INLINE RectC operator()(I idx) const {\n        double val = (double)Values[idx];\n        const int r = idx % Rows;\n        const int c = idx / Rows;\n        const ImPlotPoint p(XRef + HalfSize.x + c*Width, YRef + YDir * (HalfSize.y + r*Height));\n        RectC rect;\n        rect.Pos = p;\n        rect.HalfSize = HalfSize;\n        const float t = ImClamp((float)ImRemap01(val, ScaleMin, ScaleMax),0.0f,1.0f);\n        ImPlotContext& gp = *GImPlot;\n        rect.Color = gp.ColormapData.LerpTable(gp.Style.Colormap, t);\n        return rect;\n    }\n    const T* const Values;\n    const int Count, Rows, Cols;\n    const double ScaleMin, ScaleMax, Width, Height, XRef, YRef, YDir;\n    const ImPlotPoint HalfSize;\n};\n\ntemplate <typename T>\nvoid RenderHeatmap(ImDrawList& draw_list, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, bool reverse_y, bool col_maj) {\n    ImPlotContext& gp = *GImPlot;\n    Transformer2 transformer;\n    if (scale_min == 0 && scale_max == 0) {\n        T temp_min, temp_max;\n        ImMinMaxArray(values,rows*cols,&temp_min,&temp_max);\n        scale_min = (double)temp_min;\n        scale_max = (double)temp_max;\n    }\n    if (scale_min == scale_max) {\n        ImVec2 a = transformer(bounds_min);\n        ImVec2 b = transformer(bounds_max);\n        ImU32  col = GetColormapColorU32(0,gp.Style.Colormap);\n        draw_list.AddRectFilled(a, b, col);\n        return;\n    }\n    const double yref = reverse_y ? bounds_max.y : bounds_min.y;\n    const double ydir = reverse_y ? -1 : 1;\n    if (col_maj) {\n        GetterHeatmapColMaj<T> getter(values, rows, cols, scale_min, scale_max, (bounds_max.x - bounds_min.x) / cols, (bounds_max.y - bounds_min.y) / rows, bounds_min.x, yref, ydir);\n        RenderPrimitives1<RendererRectC>(getter);\n    }\n    else {\n        GetterHeatmapRowMaj<T> getter(values, rows, cols, scale_min, scale_max, (bounds_max.x - bounds_min.x) / cols, (bounds_max.y - bounds_min.y) / rows, bounds_min.x, yref, ydir);\n        RenderPrimitives1<RendererRectC>(getter);\n    }\n    // labels\n    if (fmt != nullptr) {\n        const double w = (bounds_max.x - bounds_min.x) / cols;\n        const double h = (bounds_max.y - bounds_min.y) / rows;\n        const ImPlotPoint half_size(w*0.5,h*0.5);\n        int i = 0;\n        if (col_maj) {\n            for (int c = 0; c < cols; ++c) {\n                for (int r = 0; r < rows; ++r) {\n                    ImPlotPoint p;\n                    p.x = bounds_min.x + 0.5*w + c*w;\n                    p.y = yref + ydir * (0.5*h + r*h);\n                    ImVec2 px = transformer(p);\n                    char buff[32];\n                    ImFormatString(buff, 32, fmt, values[i]);\n                    ImVec2 size = ImGui::CalcTextSize(buff);\n                    double t = ImClamp(ImRemap01((double)values[i], scale_min, scale_max),0.0,1.0);\n                    ImVec4 color = SampleColormap((float)t);\n                    ImU32 col = CalcTextColor(color);\n                    draw_list.AddText(px - size * 0.5f, col, buff);\n                    i++;\n                }\n            }\n        }\n        else {\n            for (int r = 0; r < rows; ++r) {\n                for (int c = 0; c < cols; ++c) {\n                    ImPlotPoint p;\n                    p.x = bounds_min.x + 0.5*w + c*w;\n                    p.y = yref + ydir * (0.5*h + r*h);\n                    ImVec2 px = transformer(p);\n                    char buff[32];\n                    ImFormatString(buff, 32, fmt, values[i]);\n                    ImVec2 size = ImGui::CalcTextSize(buff);\n                    double t = ImClamp(ImRemap01((double)values[i], scale_min, scale_max),0.0,1.0);\n                    ImVec4 color = SampleColormap((float)t);\n                    ImU32 col = CalcTextColor(color);\n                    draw_list.AddText(px - size * 0.5f, col, buff);\n                    i++;\n                }\n            }\n        }\n    }\n}\n\ntemplate <typename T>\nvoid PlotHeatmap(const char* label_id, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags) {\n    if (BeginItemEx(label_id, FitterRect(bounds_min, bounds_max))) {\n        if (rows <= 0 || cols <= 0) {\n            EndItem();\n            return;\n        }\n        ImDrawList& draw_list = *GetPlotDrawList();\n        const bool col_maj = ImHasFlag(flags, ImPlotHeatmapFlags_ColMajor);\n        RenderHeatmap(draw_list, values, rows, cols, scale_min, scale_max, fmt, bounds_min, bounds_max, true, col_maj);\n        EndItem();\n    }\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotHeatmap<T>(const char* label_id, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotHistogram\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\ndouble PlotHistogram(const char* label_id, const T* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags) {\n\n    const bool cumulative = ImHasFlag(flags, ImPlotHistogramFlags_Cumulative);\n    const bool density    = ImHasFlag(flags, ImPlotHistogramFlags_Density);\n    const bool outliers   = !ImHasFlag(flags, ImPlotHistogramFlags_NoOutliers);\n\n    if (count <= 0 || bins == 0)\n        return 0;\n\n    if (range.Min == 0 && range.Max == 0) {\n        T Min, Max;\n        ImMinMaxArray(values, count, &Min, &Max);\n        range.Min = (double)Min;\n        range.Max = (double)Max;\n    }\n\n    double width;\n    if (bins < 0)\n        CalculateBins(values, count, bins, range, bins, width);\n    else\n        width = range.Size() / bins;\n\n    ImPlotContext& gp = *GImPlot;\n    ImVector<double>& bin_centers = gp.TempDouble1;\n    ImVector<double>& bin_counts  = gp.TempDouble2;\n    bin_centers.resize(bins);\n    bin_counts.resize(bins);\n    int below = 0;\n\n    for (int b = 0; b < bins; ++b) {\n        bin_centers[b] = range.Min + b * width + width * 0.5;\n        bin_counts[b] = 0;\n    }\n    int counted = 0;\n    double max_count = 0;\n    for (int i = 0; i < count; ++i) {\n        double val = (double)values[i];\n        if (range.Contains(val)) {\n            const int b = ImClamp((int)((val - range.Min) / width), 0, bins - 1);\n            bin_counts[b] += 1.0;\n            if (bin_counts[b] > max_count)\n                max_count = bin_counts[b];\n            counted++;\n        }\n        else if (val < range.Min) {\n            below++;\n        }\n    }\n    if (cumulative && density) {\n        if (outliers)\n            bin_counts[0] += below;\n        for (int b = 1; b < bins; ++b)\n            bin_counts[b] += bin_counts[b-1];\n        double scale = 1.0 / (outliers ? count : counted);\n        for (int b = 0; b < bins; ++b)\n            bin_counts[b] *= scale;\n        max_count = bin_counts[bins-1];\n    }\n    else if (cumulative) {\n        if (outliers)\n            bin_counts[0] += below;\n        for (int b = 1; b < bins; ++b)\n            bin_counts[b] += bin_counts[b-1];\n        max_count = bin_counts[bins-1];\n    }\n    else if (density) {\n        double scale = 1.0 / ((outliers ? count : counted) * width);\n        for (int b = 0; b < bins; ++b)\n            bin_counts[b] *= scale;\n        max_count *= scale;\n    }\n    if (ImHasFlag(flags, ImPlotHistogramFlags_Horizontal))\n        PlotBars(label_id, &bin_counts.Data[0], &bin_centers.Data[0], bins, bar_scale*width, ImPlotBarsFlags_Horizontal);\n    else\n        PlotBars(label_id, &bin_centers.Data[0], &bin_counts.Data[0], bins, bar_scale*width);\n    return max_count;\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API double PlotHistogram<T>(const char* label_id, const T* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotHistogram2D\n//-----------------------------------------------------------------------------\n\ntemplate <typename T>\ndouble PlotHistogram2D(const char* label_id, const T* xs, const T* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags) {\n\n    // const bool cumulative = ImHasFlag(flags, ImPlotHistogramFlags_Cumulative); NOT SUPPORTED\n    const bool density  = ImHasFlag(flags, ImPlotHistogramFlags_Density);\n    const bool outliers = !ImHasFlag(flags, ImPlotHistogramFlags_NoOutliers);\n    const bool col_maj  = ImHasFlag(flags, ImPlotHistogramFlags_ColMajor);\n\n    if (count <= 0 || x_bins == 0 || y_bins == 0)\n        return 0;\n\n    if (range.X.Min == 0 && range.X.Max == 0) {\n        T Min, Max;\n        ImMinMaxArray(xs, count, &Min, &Max);\n        range.X.Min = (double)Min;\n        range.X.Max = (double)Max;\n    }\n    if (range.Y.Min == 0 && range.Y.Max == 0) {\n        T Min, Max;\n        ImMinMaxArray(ys, count, &Min, &Max);\n        range.Y.Min = (double)Min;\n        range.Y.Max = (double)Max;\n    }\n\n    double width, height;\n    if (x_bins < 0)\n        CalculateBins(xs, count, x_bins, range.X, x_bins, width);\n    else\n        width = range.X.Size() / x_bins;\n    if (y_bins < 0)\n        CalculateBins(ys, count, y_bins, range.Y, y_bins, height);\n    else\n        height = range.Y.Size() / y_bins;\n\n    const int bins = x_bins * y_bins;\n\n    ImPlotContext& gp = *GImPlot;\n    ImVector<double>& bin_counts = gp.TempDouble1;\n    bin_counts.resize(bins);\n\n    for (int b = 0; b < bins; ++b)\n        bin_counts[b] = 0;\n\n    int counted = 0;\n    double max_count = 0;\n    for (int i = 0; i < count; ++i) {\n        if (range.Contains((double)xs[i], (double)ys[i])) {\n            const int xb = ImClamp( (int)((double)(xs[i] - range.X.Min) / width)  , 0, x_bins - 1);\n            const int yb = ImClamp( (int)((double)(ys[i] - range.Y.Min) / height) , 0, y_bins - 1);\n            const int b  = yb * x_bins + xb;\n            bin_counts[b] += 1.0;\n            if (bin_counts[b] > max_count)\n                max_count = bin_counts[b];\n            counted++;\n        }\n    }\n    if (density) {\n        double scale = 1.0 / ((outliers ? count : counted) * width * height);\n        for (int b = 0; b < bins; ++b)\n            bin_counts[b] *= scale;\n        max_count *= scale;\n    }\n\n    if (BeginItemEx(label_id, FitterRect(range))) {\n        if (y_bins <= 0 || x_bins <= 0) {\n            EndItem();\n            return max_count;\n        }\n        ImDrawList& draw_list = *GetPlotDrawList();\n        RenderHeatmap(draw_list, &bin_counts.Data[0], y_bins, x_bins, 0, max_count, nullptr, range.Min(), range.Max(), false, col_maj);\n        EndItem();\n    }\n    return max_count;\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API double PlotHistogram2D<T>(const char* label_id,   const T*   xs, const T*   ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotDigital\n//-----------------------------------------------------------------------------\n\n// TODO: Make this behave like all the other plot types (.e. not fixed in y axis)\n\ntemplate <typename Getter>\nvoid PlotDigitalEx(const char* label_id, Getter getter, ImPlotDigitalFlags flags) {\n    if (BeginItem(label_id, flags, ImPlotCol_Fill)) {\n        ImPlotContext& gp = *GImPlot;\n        ImDrawList& draw_list = *GetPlotDrawList();\n        const ImPlotNextItemData& s = GetItemData();\n        if (getter.Count > 1 && s.RenderFill) {\n            ImPlotPlot& plot   = *gp.CurrentPlot;\n            ImPlotAxis& x_axis = plot.Axes[plot.CurrentX];\n            ImPlotAxis& y_axis = plot.Axes[plot.CurrentY];\n\n            int pixYMax = 0;\n            ImPlotPoint itemData1 = getter(0);\n            for (int i = 0; i < getter.Count; ++i) {\n                ImPlotPoint itemData2 = getter(i);\n                if (ImNanOrInf(itemData1.y)) {\n                    itemData1 = itemData2;\n                    continue;\n                }\n                if (ImNanOrInf(itemData2.y)) itemData2.y = ImConstrainNan(ImConstrainInf(itemData2.y));\n                int pixY_0 = (int)(s.LineWeight);\n                itemData1.y = ImMax(0.0, itemData1.y);\n                float pixY_1_float = s.DigitalBitHeight * (float)itemData1.y;\n                int pixY_1 = (int)(pixY_1_float); //allow only positive values\n                int pixY_chPosOffset = (int)(ImMax(s.DigitalBitHeight, pixY_1_float) + s.DigitalBitGap);\n                pixYMax = ImMax(pixYMax, pixY_chPosOffset);\n                ImVec2 pMin = PlotToPixels(itemData1,IMPLOT_AUTO,IMPLOT_AUTO);\n                ImVec2 pMax = PlotToPixels(itemData2,IMPLOT_AUTO,IMPLOT_AUTO);\n                int pixY_Offset = 0; //20 pixel from bottom due to mouse cursor label\n                pMin.y = (y_axis.PixelMin) + ((-gp.DigitalPlotOffset)                   - pixY_Offset);\n                pMax.y = (y_axis.PixelMin) + ((-gp.DigitalPlotOffset) - pixY_0 - pixY_1 - pixY_Offset);\n                //plot only one rectangle for same digital state\n                while (((i+2) < getter.Count) && (itemData1.y == itemData2.y)) {\n                    const int in = (i + 1);\n                    itemData2 = getter(in);\n                    if (ImNanOrInf(itemData2.y)) break;\n                    pMax.x = PlotToPixels(itemData2,IMPLOT_AUTO,IMPLOT_AUTO).x;\n                    i++;\n                }\n                //do not extend plot outside plot range\n                if (pMin.x < x_axis.PixelMin) pMin.x = x_axis.PixelMin;\n                if (pMax.x < x_axis.PixelMin) pMax.x = x_axis.PixelMin;\n                if (pMin.x > x_axis.PixelMax) pMin.x = x_axis.PixelMax - 1; //fix issue related to https://github.com/ocornut/imgui/issues/3976\n                if (pMax.x > x_axis.PixelMax) pMax.x = x_axis.PixelMax - 1; //fix issue related to https://github.com/ocornut/imgui/issues/3976\n                //plot a rectangle that extends up to x2 with y1 height\n                if ((pMax.x > pMin.x) && (gp.CurrentPlot->PlotRect.Contains(pMin) || gp.CurrentPlot->PlotRect.Contains(pMax))) {\n                    // ImVec4 colAlpha = item->Color;\n                    // colAlpha.w = item->Highlight ? 1.0f : 0.9f;\n                    draw_list.AddRectFilled(pMin, pMax, ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]));\n                }\n                itemData1 = itemData2;\n            }\n            gp.DigitalPlotItemCnt++;\n            gp.DigitalPlotOffset += pixYMax;\n        }\n        EndItem();\n    }\n}\n\n\ntemplate <typename T>\nvoid PlotDigital(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags, int offset, int stride) {\n    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);\n    return PlotDigitalEx(label_id, getter, flags);\n}\n#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotDigital<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);\nCALL_INSTANTIATE_FOR_NUMERIC_TYPES()\n#undef INSTANTIATE_MACRO\n\n// custom\nvoid PlotDigitalG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotDigitalFlags flags) {\n    GetterFuncPtr getter(getter_func,data,count);\n    return PlotDigitalEx(label_id, getter, flags);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotImage\n//-----------------------------------------------------------------------------\n\nvoid PlotImage(const char* label_id, ImTextureID user_texture_id, const ImPlotPoint& bmin, const ImPlotPoint& bmax, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, ImPlotImageFlags) {\n    if (BeginItemEx(label_id, FitterRect(bmin,bmax))) {\n        ImU32 tint_col32 = ImGui::ColorConvertFloat4ToU32(tint_col);\n        GetCurrentItem()->Color = tint_col32;\n        ImDrawList& draw_list = *GetPlotDrawList();\n        ImVec2 p1 = PlotToPixels(bmin.x, bmax.y,IMPLOT_AUTO,IMPLOT_AUTO);\n        ImVec2 p2 = PlotToPixels(bmax.x, bmin.y,IMPLOT_AUTO,IMPLOT_AUTO);\n        PushPlotClipRect();\n        draw_list.AddImage(user_texture_id, p1, p2, uv0, uv1, tint_col32);\n        PopPlotClipRect();\n        EndItem();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotText\n//-----------------------------------------------------------------------------\n\nvoid PlotText(const char* text, double x, double y, const ImVec2& pixel_offset, ImPlotTextFlags flags) {\n    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, \"PlotText() needs to be called between BeginPlot() and EndPlot()!\");\n    SetupLock();\n    ImDrawList & draw_list = *GetPlotDrawList();\n    PushPlotClipRect();\n    ImU32 colTxt = GetStyleColorU32(ImPlotCol_InlayText);\n    if (ImHasFlag(flags,ImPlotTextFlags_Vertical)) {\n        ImVec2 siz = CalcTextSizeVertical(text) * 0.5f;\n        ImVec2 ctr = siz * 0.5f;\n        ImVec2 pos = PlotToPixels(ImPlotPoint(x,y),IMPLOT_AUTO,IMPLOT_AUTO) + ImVec2(-ctr.x, ctr.y) + pixel_offset;\n        if (FitThisFrame() && !ImHasFlag(flags, ImPlotItemFlags_NoFit)) {\n            FitPoint(PixelsToPlot(pos));\n            FitPoint(PixelsToPlot(pos.x + siz.x, pos.y - siz.y));\n        }\n        AddTextVertical(&draw_list, pos, colTxt, text);\n    }\n    else {\n        ImVec2 siz = ImGui::CalcTextSize(text);\n        ImVec2 pos = PlotToPixels(ImPlotPoint(x,y),IMPLOT_AUTO,IMPLOT_AUTO) - siz * 0.5f + pixel_offset;\n        if (FitThisFrame() && !ImHasFlag(flags, ImPlotItemFlags_NoFit)) {\n            FitPoint(PixelsToPlot(pos));\n            FitPoint(PixelsToPlot(pos+siz));\n        }\n        draw_list.AddText(pos, colTxt, text);\n    }\n    PopPlotClipRect();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] PlotDummy\n//-----------------------------------------------------------------------------\n\nvoid PlotDummy(const char* label_id, ImPlotDummyFlags flags) {\n    if (BeginItem(label_id, flags, ImPlotCol_Line))\n        EndItem();\n}\n\n} // namespace ImPlot\n\n#endif // #ifndef IMGUI_DISABLE\n"
        }
      ]
    }
  ]
}